{"sha": "6940cca76065f7871e53ef2a95019e0841ff408d", "node_id": "C_kwDOAAsO6NoAKDY5NDBjY2E3NjA2NWY3ODcxZTUzZWYyYTk1MDE5ZTA4NDFmZjQwOGQ", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-02-02T12:35:46Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2022-02-03T14:50:14Z"}, "message": "Move attribute path completions into attribute completion module", "tree": {"sha": "8a038710e26724d3eb0ee5a94c70eda48abdc461", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8a038710e26724d3eb0ee5a94c70eda48abdc461"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6940cca76065f7871e53ef2a95019e0841ff408d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6940cca76065f7871e53ef2a95019e0841ff408d", "html_url": "https://github.com/rust-lang/rust/commit/6940cca76065f7871e53ef2a95019e0841ff408d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6940cca76065f7871e53ef2a95019e0841ff408d/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "46b5089bfaa9a6b1e72a96c922fa3dec736aeaf5", "url": "https://api.github.com/repos/rust-lang/rust/commits/46b5089bfaa9a6b1e72a96c922fa3dec736aeaf5", "html_url": "https://github.com/rust-lang/rust/commit/46b5089bfaa9a6b1e72a96c922fa3dec736aeaf5"}], "stats": {"total": 246, "additions": 139, "deletions": 107}, "files": [{"sha": "243ba63b8a0a8b52a583f0d8f14b6b4a35288b6e", "filename": "crates/hir/src/semantics.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6940cca76065f7871e53ef2a95019e0841ff408d/crates%2Fhir%2Fsrc%2Fsemantics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6940cca76065f7871e53ef2a95019e0841ff408d/crates%2Fhir%2Fsrc%2Fsemantics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fsemantics.rs?ref=6940cca76065f7871e53ef2a95019e0841ff408d", "patch": "@@ -949,12 +949,15 @@ impl<'db> SemanticsImpl<'db> {\n         })?;\n \n         match res {\n-            Either::Left(path) => resolve_hir_path(\n-                self.db,\n-                &self.scope(derive.syntax()).resolver,\n-                &Path::from_known_path(path, []),\n-            )\n-            .filter(|res| matches!(res, PathResolution::Def(ModuleDef::Module(_)))),\n+            Either::Left(path) => {\n+                let len = path.len();\n+                resolve_hir_path(\n+                    self.db,\n+                    &self.scope(derive.syntax()).resolver,\n+                    &Path::from_known_path(path, vec![None; len]),\n+                )\n+                .filter(|res| matches!(res, PathResolution::Def(ModuleDef::Module(_))))\n+            }\n             Either::Right(derive) => derive\n                 .map(|call| MacroDef { id: self.db.lookup_intern_macro_call(call).def })\n                 .map(PathResolution::Macro),"}, {"sha": "a6141174c8379b3c458bbde9b1205e1e87b64f74", "filename": "crates/hir_def/src/path.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6940cca76065f7871e53ef2a95019e0841ff408d/crates%2Fhir_def%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6940cca76065f7871e53ef2a95019e0841ff408d/crates%2Fhir_def%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_def%2Fsrc%2Fpath.rs?ref=6940cca76065f7871e53ef2a95019e0841ff408d", "patch": "@@ -92,7 +92,9 @@ impl Path {\n         path: ModPath,\n         generic_args: impl Into<Box<[Option<Interned<GenericArgs>>]>>,\n     ) -> Path {\n-        Path { type_anchor: None, mod_path: Interned::new(path), generic_args: generic_args.into() }\n+        let generic_args = generic_args.into();\n+        assert_eq!(path.len(), generic_args.len());\n+        Path { type_anchor: None, mod_path: Interned::new(path), generic_args }\n     }\n \n     pub fn kind(&self) -> &PathKind {"}, {"sha": "173380654e0cda706659b790ef0ccce3c7cbaeab", "filename": "crates/hir_ty/src/infer.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6940cca76065f7871e53ef2a95019e0841ff408d/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6940cca76065f7871e53ef2a95019e0841ff408d/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer.rs?ref=6940cca76065f7871e53ef2a95019e0841ff408d", "patch": "@@ -253,6 +253,7 @@ pub enum PointerCast {\n     /// Go from a mut raw pointer to a const raw pointer.\n     MutToConstPointer,\n \n+    #[allow(dead_code)]\n     /// Go from `*const [T; N]` to `*const T`\n     ArrayToPointer,\n "}, {"sha": "8950b13d6f0f590fca673314c54a8e54bae78d77", "filename": "crates/ide_completion/src/completions/attribute.rs", "status": "modified", "additions": 71, "deletions": 38, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/6940cca76065f7871e53ef2a95019e0841ff408d/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6940cca76065f7871e53ef2a95019e0841ff408d/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fattribute.rs?ref=6940cca76065f7871e53ef2a95019e0841ff408d", "patch": "@@ -16,62 +16,95 @@ use ide_db::{\n use itertools::Itertools;\n use once_cell::sync::Lazy;\n use rustc_hash::FxHashMap;\n-use syntax::{algo::non_trivia_sibling, ast, AstNode, Direction, SyntaxKind, T};\n+use syntax::{\n+    ast::{self, AttrKind},\n+    AstNode, SyntaxKind, T,\n+};\n \n-use crate::{context::CompletionContext, item::CompletionItem, Completions};\n+use crate::{\n+    completions::module_or_attr,\n+    context::{CompletionContext, PathCompletionContext, PathKind},\n+    item::CompletionItem,\n+    Completions,\n+};\n \n mod cfg;\n mod derive;\n mod lint;\n mod repr;\n \n-pub(crate) fn complete_attribute(acc: &mut Completions, ctx: &CompletionContext) -> Option<()> {\n+/// Complete inputs to known builtin attributes as well as derive attributes\n+pub(crate) fn complete_known_attribute_input(\n+    acc: &mut Completions,\n+    ctx: &CompletionContext,\n+) -> Option<()> {\n     let attribute = ctx.fake_attribute_under_caret.as_ref()?;\n     let name_ref = match attribute.path() {\n         Some(p) => Some(p.as_single_name_ref()?),\n         None => None,\n     };\n-    match (name_ref, attribute.token_tree()) {\n-        (Some(path), Some(tt)) if tt.l_paren_token().is_some() => match path.text().as_str() {\n-            \"repr\" => repr::complete_repr(acc, ctx, tt),\n-            \"derive\" => derive::complete_derive(acc, ctx, ctx.attr.as_ref()?),\n-            \"feature\" => lint::complete_lint(acc, ctx, &parse_tt_as_comma_sep_paths(tt)?, FEATURES),\n-            \"allow\" | \"warn\" | \"deny\" | \"forbid\" => {\n-                let existing_lints = parse_tt_as_comma_sep_paths(tt)?;\n+    let (path, tt) = name_ref.zip(attribute.token_tree())?;\n+    if tt.l_paren_token().is_none() {\n+        return None;\n+    }\n \n-                let lints: Vec<Lint> = CLIPPY_LINT_GROUPS\n-                    .iter()\n-                    .map(|g| &g.lint)\n-                    .chain(DEFAULT_LINTS.iter())\n-                    .chain(CLIPPY_LINTS.iter())\n-                    .chain(RUSTDOC_LINTS)\n-                    .cloned()\n-                    .collect();\n+    match path.text().as_str() {\n+        \"repr\" => repr::complete_repr(acc, ctx, tt),\n+        \"derive\" => derive::complete_derive(acc, ctx, ctx.attr.as_ref()?),\n+        \"feature\" => lint::complete_lint(acc, ctx, &parse_tt_as_comma_sep_paths(tt)?, FEATURES),\n+        \"allow\" | \"warn\" | \"deny\" | \"forbid\" => {\n+            let existing_lints = parse_tt_as_comma_sep_paths(tt)?;\n \n-                lint::complete_lint(acc, ctx, &existing_lints, &lints);\n-            }\n-            \"cfg\" => {\n-                cfg::complete_cfg(acc, ctx);\n-            }\n-            _ => (),\n-        },\n-        (_, Some(_)) => (),\n-        (_, None) if attribute.expr().is_some() => (),\n-        (_, None) => complete_new_attribute(acc, ctx, attribute),\n+            let lints: Vec<Lint> = CLIPPY_LINT_GROUPS\n+                .iter()\n+                .map(|g| &g.lint)\n+                .chain(DEFAULT_LINTS)\n+                .chain(CLIPPY_LINTS)\n+                .chain(RUSTDOC_LINTS)\n+                .cloned()\n+                .collect();\n+\n+            lint::complete_lint(acc, ctx, &existing_lints, &lints);\n+        }\n+        \"cfg\" => {\n+            cfg::complete_cfg(acc, ctx);\n+        }\n+        _ => (),\n     }\n     Some(())\n }\n \n-// FIXME?: Move this functionality to (un)qualified_path, make this module work solely for builtin/known attributes for their inputs?\n-fn complete_new_attribute(acc: &mut Completions, ctx: &CompletionContext, attribute: &ast::Attr) {\n-    let is_inner = attribute.kind() == ast::AttrKind::Inner;\n-    let attribute_annotated_item_kind =\n-        attribute.syntax().parent().map(|it| it.kind()).filter(|_| {\n-            is_inner\n-            // If we got nothing coming after the attribute it could be anything so filter it the kind out\n-                || non_trivia_sibling(attribute.syntax().clone().into(), Direction::Next).is_some()\n-        });\n-    let attributes = attribute_annotated_item_kind.and_then(|kind| {\n+pub(crate) fn complete_attribute(acc: &mut Completions, ctx: &CompletionContext) {\n+    let (is_trivial_path, qualifier, is_inner, annotated_item_kind) = match ctx.path_context {\n+        Some(PathCompletionContext {\n+            kind: Some(PathKind::Attr { kind, annotated_item_kind }),\n+            is_trivial_path,\n+            ref qualifier,\n+            ..\n+        }) => (is_trivial_path, qualifier, kind == AttrKind::Inner, annotated_item_kind),\n+        _ => return,\n+    };\n+\n+    if !is_trivial_path {\n+        return;\n+    }\n+\n+    if let Some((_, Some(hir::PathResolution::Def(hir::ModuleDef::Module(module))))) = qualifier {\n+        for (name, def) in module.scope(ctx.db, ctx.module) {\n+            if let Some(def) = module_or_attr(def) {\n+                acc.add_resolution(ctx, name, def);\n+            }\n+        }\n+        return;\n+    }\n+\n+    ctx.process_all_names(&mut |name, def| {\n+        if let Some(def) = module_or_attr(def) {\n+            acc.add_resolution(ctx, name, def);\n+        }\n+    });\n+\n+    let attributes = annotated_item_kind.and_then(|kind| {\n         if ast::Expr::can_cast(kind) {\n             Some(EXPR_ATTRIBUTES)\n         } else {"}, {"sha": "723abd62aef576e922842312137bacd5fcc30c49", "filename": "crates/ide_completion/src/completions/flyimport.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6940cca76065f7871e53ef2a95019e0841ff408d/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6940cca76065f7871e53ef2a95019e0841ff408d/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fflyimport.rs?ref=6940cca76065f7871e53ef2a95019e0841ff408d", "patch": "@@ -171,8 +171,8 @@ pub(crate) fn import_on_the_fly(acc: &mut Completions, ctx: &CompletionContext)\n             (PathKind::Type, ItemInNs::Types(_)) => true,\n             (PathKind::Type, ItemInNs::Values(_)) => false,\n \n-            (PathKind::Attr, ItemInNs::Macros(mac)) => mac.is_attr(),\n-            (PathKind::Attr, _) => false,\n+            (PathKind::Attr { .. }, ItemInNs::Macros(mac)) => mac.is_attr(),\n+            (PathKind::Attr { .. }, _) => false,\n         }\n     };\n "}, {"sha": "b15ec38b0adc6274203eb7c3a58dbc9c38affb65", "filename": "crates/ide_completion/src/completions/qualified_path.rs", "status": "modified", "additions": 8, "deletions": 29, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/6940cca76065f7871e53ef2a95019e0841ff408d/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fqualified_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6940cca76065f7871e53ef2a95019e0841ff408d/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fqualified_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Fqualified_path.rs?ref=6940cca76065f7871e53ef2a95019e0841ff408d", "patch": "@@ -7,7 +7,7 @@ use rustc_hash::FxHashSet;\n use syntax::{ast, AstNode};\n \n use crate::{\n-    completions::{module_or_attr, module_or_fn_macro},\n+    completions::module_or_fn_macro,\n     context::{PathCompletionContext, PathKind},\n     patterns::ImmediateLocation,\n     CompletionContext, Completions,\n@@ -17,7 +17,7 @@ pub(crate) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionCon\n     if ctx.is_path_disallowed() || ctx.has_impl_or_trait_prev_sibling() {\n         return;\n     }\n-    let (path, use_tree_parent, kind) = match ctx.path_context {\n+    let ((path, resolution), use_tree_parent, kind) = match ctx.path_context {\n         // let ... else, syntax would come in really handy here right now\n         Some(PathCompletionContext {\n             qualifier: Some(ref qualifier),\n@@ -47,17 +47,15 @@ pub(crate) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionCon\n         }\n     }\n \n-    let resolution = match ctx.sema.resolve_path(path) {\n+    let resolution = match resolution {\n         Some(res) => res,\n         None => return,\n     };\n \n-    let context_module = ctx.module;\n-\n     match ctx.completion_location {\n         Some(ImmediateLocation::ItemList | ImmediateLocation::Trait | ImmediateLocation::Impl) => {\n             if let hir::PathResolution::Def(hir::ModuleDef::Module(module)) = resolution {\n-                for (name, def) in module.scope(ctx.db, context_module) {\n+                for (name, def) in module.scope(ctx.db, ctx.module) {\n                     if let Some(def) = module_or_fn_macro(def) {\n                         acc.add_resolution(ctx, name, def);\n                     }\n@@ -76,7 +74,7 @@ pub(crate) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionCon\n                     let next_towards_current = current_module\n                         .path_to_root(ctx.db)\n                         .into_iter()\n-                        .take_while(|&it| it != module)\n+                        .take_while(|it| it != module)\n                         .next();\n                     if let Some(next) = next_towards_current {\n                         if let Some(name) = next.name(ctx.db) {\n@@ -88,14 +86,7 @@ pub(crate) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionCon\n             }\n             return;\n         }\n-        Some(PathKind::Attr) => {\n-            if let hir::PathResolution::Def(hir::ModuleDef::Module(module)) = resolution {\n-                for (name, def) in module.scope(ctx.db, context_module) {\n-                    if let Some(def) = module_or_attr(def) {\n-                        acc.add_resolution(ctx, name, def);\n-                    }\n-                }\n-            }\n+        Some(PathKind::Attr { .. }) => {\n             return;\n         }\n         Some(PathKind::Use) => {\n@@ -127,7 +118,7 @@ pub(crate) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionCon\n \n     match resolution {\n         hir::PathResolution::Def(hir::ModuleDef::Module(module)) => {\n-            let module_scope = module.scope(ctx.db, context_module);\n+            let module_scope = module.scope(ctx.db, ctx.module);\n             for (name, def) in module_scope {\n                 if let Some(PathKind::Use) = kind {\n                     if let ScopeDef::Unknown = def {\n@@ -168,7 +159,7 @@ pub(crate) fn complete_qualified_path(acc: &mut Completions, ctx: &CompletionCon\n             | hir::ModuleDef::TypeAlias(_)\n             | hir::ModuleDef::BuiltinType(_)),\n         ) => {\n-            if let hir::ModuleDef::Adt(hir::Adt::Enum(e)) = def {\n+            if let &hir::ModuleDef::Adt(hir::Adt::Enum(e)) = def {\n                 add_enum_variants(acc, ctx, e);\n             }\n             let ty = match def {\n@@ -622,18 +613,6 @@ fn foo() {\n         );\n     }\n \n-    #[test]\n-    fn dont_complete_attr() {\n-        check(\n-            r#\"\n-mod foo { pub struct Foo; }\n-#[foo::$0]\n-fn f() {}\n-\"#,\n-            expect![[\"\"]],\n-        );\n-    }\n-\n     #[test]\n     fn completes_variant_through_self() {\n         check("}, {"sha": "01f3f777a1ae3d4c1aa556198171b869b14b374d", "filename": "crates/ide_completion/src/completions/unqualified_path.rs", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6940cca76065f7871e53ef2a95019e0841ff408d/crates%2Fide_completion%2Fsrc%2Fcompletions%2Funqualified_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6940cca76065f7871e53ef2a95019e0841ff408d/crates%2Fide_completion%2Fsrc%2Fcompletions%2Funqualified_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Funqualified_path.rs?ref=6940cca76065f7871e53ef2a95019e0841ff408d", "patch": "@@ -4,7 +4,7 @@ use hir::ScopeDef;\n use syntax::{ast, AstNode};\n \n use crate::{\n-    completions::{module_or_attr, module_or_fn_macro},\n+    completions::module_or_fn_macro,\n     context::{PathCompletionContext, PathKind},\n     patterns::ImmediateLocation,\n     CompletionContext, Completions,\n@@ -36,14 +36,7 @@ pub(crate) fn complete_unqualified_path(acc: &mut Completions, ctx: &CompletionC\n \n     match kind {\n         Some(PathKind::Vis { .. }) => return,\n-        Some(PathKind::Attr) => {\n-            ctx.process_all_names(&mut |name, def| {\n-                if let Some(def) = module_or_attr(def) {\n-                    acc.add_resolution(ctx, name, def);\n-                }\n-            });\n-            return;\n-        }\n+        Some(PathKind::Attr { .. }) => return,\n         _ => (),\n     }\n "}, {"sha": "4845427422c1627f5da05ea1a9996756303a680c", "filename": "crates/ide_completion/src/context.rs", "status": "modified", "additions": 37, "deletions": 14, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/6940cca76065f7871e53ef2a95019e0841ff408d/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6940cca76065f7871e53ef2a95019e0841ff408d/crates%2Fide_completion%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcontext.rs?ref=6940cca76065f7871e53ef2a95019e0841ff408d", "patch": "@@ -3,16 +3,18 @@\n use std::iter;\n \n use base_db::SourceDatabaseExt;\n-use hir::{HasAttrs, Local, Name, ScopeDef, Semantics, SemanticsScope, Type, TypeInfo};\n+use hir::{\n+    HasAttrs, Local, Name, PathResolution, ScopeDef, Semantics, SemanticsScope, Type, TypeInfo,\n+};\n use ide_db::{\n     active_parameter::ActiveParameter,\n     base_db::{FilePosition, SourceDatabase},\n     helpers::FamousDefs,\n     RootDatabase,\n };\n use syntax::{\n-    algo::find_node_at_offset,\n-    ast::{self, HasName, NameOrNameRef},\n+    algo::{find_node_at_offset, non_trivia_sibling},\n+    ast::{self, AttrKind, HasName, NameOrNameRef},\n     match_ast, AstNode, NodeOrToken,\n     SyntaxKind::{self, *},\n     SyntaxNode, SyntaxToken, TextRange, TextSize, T,\n@@ -44,7 +46,7 @@ pub(crate) enum Visible {\n pub(super) enum PathKind {\n     Expr,\n     Type,\n-    Attr,\n+    Attr { kind: AttrKind, annotated_item_kind: Option<SyntaxKind> },\n     Mac,\n     Pat,\n     Vis { has_in_token: bool },\n@@ -58,7 +60,7 @@ pub(crate) struct PathCompletionContext {\n     /// A single-indent path, like `foo`. `::foo` should not be considered a trivial path.\n     pub(super) is_trivial_path: bool,\n     /// If not a trivial path, the prefix (qualifier).\n-    pub(super) qualifier: Option<ast::Path>,\n+    pub(super) qualifier: Option<(ast::Path, Option<PathResolution>)>,\n     #[allow(dead_code)]\n     /// If not a trivial path, the suffix (parent).\n     pub(super) parent: Option<ast::Path>,\n@@ -282,7 +284,7 @@ impl<'a> CompletionContext<'a> {\n     }\n \n     pub(crate) fn path_qual(&self) -> Option<&ast::Path> {\n-        self.path_context.as_ref().and_then(|it| it.qualifier.as_ref())\n+        self.path_context.as_ref().and_then(|it| it.qualifier.as_ref().map(|(it, _)| it))\n     }\n \n     pub(crate) fn path_kind(&self) -> Option<PathKind> {\n@@ -786,7 +788,7 @@ impl<'a> CompletionContext<'a> {\n     }\n \n     fn classify_name_ref(\n-        _sema: &Semantics<RootDatabase>,\n+        sema: &Semantics<RootDatabase>,\n         original_file: &SyntaxNode,\n         name_ref: ast::NameRef,\n     ) -> Option<(PathCompletionContext, Option<PatternContext>)> {\n@@ -808,8 +810,9 @@ impl<'a> CompletionContext<'a> {\n         let mut pat_ctx = None;\n         path_ctx.in_loop_body = is_in_loop_body(name_ref.syntax());\n \n-        path_ctx.kind  = path.syntax().ancestors().find_map(|it| {\n-            match_ast! {\n+        path_ctx.kind = path.syntax().ancestors().find_map(|it| {\n+            // using Option<Option<PathKind>> as extra controlflow\n+            let kind = match_ast! {\n                 match it {\n                     ast::PathType(_) => Some(PathKind::Type),\n                     ast::PathExpr(it) => {\n@@ -830,21 +833,41 @@ impl<'a> CompletionContext<'a> {\n                         Some(PathKind::Pat)\n                     },\n                     ast::MacroCall(it) => it.excl_token().and(Some(PathKind::Mac)),\n-                    ast::Meta(_) => Some(PathKind::Attr),\n+                    ast::Meta(meta) => (|| {\n+                        let attr = meta.parent_attr()?;\n+                        let kind = attr.kind();\n+                        let attached = attr.syntax().parent()?;\n+                        let is_trailing_outer_attr = kind != AttrKind::Inner\n+                            && non_trivia_sibling(attr.syntax().clone().into(), syntax::Direction::Next).is_none();\n+                        let annotated_item_kind = if is_trailing_outer_attr {\n+                            None\n+                        } else {\n+                            Some(attached.kind())\n+                        };\n+                        Some(PathKind::Attr {\n+                            kind,\n+                            annotated_item_kind,\n+                        })\n+                    })(),\n                     ast::Visibility(it) => Some(PathKind::Vis { has_in_token: it.in_token().is_some() }),\n                     ast::UseTree(_) => Some(PathKind::Use),\n-                    _ => None,\n+                    _ => return None,\n                 }\n-            }\n-        });\n+            };\n+            Some(kind)\n+        }).flatten();\n         path_ctx.has_type_args = segment.generic_arg_list().is_some();\n \n         if let Some((path, use_tree_parent)) = path_or_use_tree_qualifier(&path) {\n             path_ctx.use_tree_parent = use_tree_parent;\n-            path_ctx.qualifier = path\n+            let path = path\n                 .segment()\n                 .and_then(|it| find_node_in_file(original_file, &it))\n                 .map(|it| it.parent_path());\n+            path_ctx.qualifier = path.map(|path| {\n+                let res = sema.resolve_path(&path);\n+                (path, res)\n+            });\n             return Some((path_ctx, pat_ctx));\n         }\n "}, {"sha": "5b49a4991198eb5ca293fe8d768ef3fdaee1a48c", "filename": "crates/ide_completion/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6940cca76065f7871e53ef2a95019e0841ff408d/crates%2Fide_completion%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6940cca76065f7871e53ef2a95019e0841ff408d/crates%2Fide_completion%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Flib.rs?ref=6940cca76065f7871e53ef2a95019e0841ff408d", "patch": "@@ -151,6 +151,7 @@ pub fn completions(\n     }\n \n     let mut acc = Completions::default();\n+    completions::attribute::complete_known_attribute_input(&mut acc, &ctx);\n     completions::attribute::complete_attribute(&mut acc, &ctx);\n     completions::fn_param::complete_fn_param(&mut acc, &ctx);\n     completions::keyword::complete_expr_keyword(&mut acc, &ctx);"}, {"sha": "ac43a67bdcf15de0232d24cece5ef842208cb41c", "filename": "crates/ide_completion/src/tests/attribute.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/6940cca76065f7871e53ef2a95019e0841ff408d/crates%2Fide_completion%2Fsrc%2Ftests%2Fattribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6940cca76065f7871e53ef2a95019e0841ff408d/crates%2Fide_completion%2Fsrc%2Ftests%2Fattribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Ftests%2Fattribute.rs?ref=6940cca76065f7871e53ef2a95019e0841ff408d", "patch": "@@ -17,6 +17,7 @@ fn proc_macros() {\n struct Foo;\n \"#,\n         expect![[r#\"\n+            md proc_macros\n             at allow(\u2026)\n             at cfg(\u2026)\n             at cfg_attr(\u2026)\n@@ -35,7 +36,6 @@ struct Foo;\n             kw self\n             kw super\n             kw crate\n-            md proc_macros\n         \"#]],\n     )\n }\n@@ -61,10 +61,7 @@ fn proc_macros_qualified() {\n #[proc_macros::$0]\n struct Foo;\n \"#,\n-        expect![[r#\"\n-            at input_replace pub macro input_replace\n-            at identity      pub macro identity\n-        \"#]],\n+        expect![[r#\"\"#]],\n     )\n }\n \n@@ -302,6 +299,8 @@ fn attr_on_struct() {\n struct Foo;\n \"#,\n         expect![[r#\"\n+            md core\n+            at derive           pub macro derive\n             at allow(\u2026)\n             at cfg(\u2026)\n             at cfg_attr(\u2026)\n@@ -320,8 +319,6 @@ struct Foo;\n             kw self\n             kw super\n             kw crate\n-            md core\n-            at derive           pub macro derive\n         \"#]],\n     );\n }"}, {"sha": "067e13ee14dd8f22f08fb6b381ba5696ed8df310", "filename": "crates/syntax/src/ast/node_ext.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6940cca76065f7871e53ef2a95019e0841ff408d/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6940cca76065f7871e53ef2a95019e0841ff408d/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Fnode_ext.rs?ref=6940cca76065f7871e53ef2a95019e0841ff408d", "patch": "@@ -119,7 +119,7 @@ impl From<ast::AssocItem> for ast::Item {\n     }\n }\n \n-#[derive(Debug, Clone, PartialEq, Eq)]\n+#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n pub enum AttrKind {\n     Inner,\n     Outer,"}]}