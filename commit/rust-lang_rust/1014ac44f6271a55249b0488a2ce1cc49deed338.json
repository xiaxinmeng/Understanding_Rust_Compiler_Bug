{"sha": "1014ac44f6271a55249b0488a2ce1cc49deed338", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEwMTRhYzQ0ZjYyNzFhNTUyNDliMDQ4OGEyY2UxY2M0OWRlZWQzMzg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-16T20:34:55Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-04-16T20:34:55Z"}, "message": "Auto merge of #24396 - alexcrichton:rustdoc2, r=aturon\n\nA few final improvements to rustdoc for 1.0:\r\n\r\n* Improve how rustdoc handles stability\r\n* Fix cross-crate macro source links\r\n* Improve experience of types inheriting methods through `Deref`\r\n\r\nSome more details can be found in the commits.\r\n\r\n[Preview](http://people.mozilla.org/~acrichton/doc/std/)", "tree": {"sha": "c827a7db48525741f0e91758c1df38082bee30aa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c827a7db48525741f0e91758c1df38082bee30aa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1014ac44f6271a55249b0488a2ce1cc49deed338", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1014ac44f6271a55249b0488a2ce1cc49deed338", "html_url": "https://github.com/rust-lang/rust/commit/1014ac44f6271a55249b0488a2ce1cc49deed338", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1014ac44f6271a55249b0488a2ce1cc49deed338/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e9080ec39d9a44eb0773d648b348575b19f655e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/e9080ec39d9a44eb0773d648b348575b19f655e5", "html_url": "https://github.com/rust-lang/rust/commit/e9080ec39d9a44eb0773d648b348575b19f655e5"}, {"sha": "71c1b5b704ca3955e5ca22d77a0d59b55c9af4f1", "url": "https://api.github.com/repos/rust-lang/rust/commits/71c1b5b704ca3955e5ca22d77a0d59b55c9af4f1", "html_url": "https://github.com/rust-lang/rust/commit/71c1b5b704ca3955e5ca22d77a0d59b55c9af4f1"}], "stats": {"total": 1037, "additions": 510, "deletions": 527}, "files": [{"sha": "4fc86cf181b8daf361d8756e527cbe25279b5e3f", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 29, "deletions": 20, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/1014ac44f6271a55249b0488a2ce1cc49deed338/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1014ac44f6271a55249b0488a2ce1cc49deed338/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=1014ac44f6271a55249b0488a2ce1cc49deed338", "patch": "@@ -218,15 +218,17 @@ fn build_type(cx: &DocContext, tcx: &ty::ctxt, did: ast::DefId) -> clean::ItemEn\n     })\n }\n \n-fn build_impls(cx: &DocContext, tcx: &ty::ctxt,\n-               did: ast::DefId) -> Vec<clean::Item> {\n+pub fn build_impls(cx: &DocContext, tcx: &ty::ctxt,\n+                   did: ast::DefId) -> Vec<clean::Item> {\n     ty::populate_implementations_for_type_if_necessary(tcx, did);\n     let mut impls = Vec::new();\n \n     match tcx.inherent_impls.borrow().get(&did) {\n         None => {}\n         Some(i) => {\n-            impls.extend(i.iter().map(|&did| { build_impl(cx, tcx, did) }));\n+            for &did in i.iter() {\n+                build_impl(cx, tcx, did, &mut impls);\n+            }\n         }\n     }\n \n@@ -247,9 +249,9 @@ fn build_impls(cx: &DocContext, tcx: &ty::ctxt,\n \n         fn populate_impls(cx: &DocContext, tcx: &ty::ctxt,\n                           def: decoder::DefLike,\n-                          impls: &mut Vec<Option<clean::Item>>) {\n+                          impls: &mut Vec<clean::Item>) {\n             match def {\n-                decoder::DlImpl(did) => impls.push(build_impl(cx, tcx, did)),\n+                decoder::DlImpl(did) => build_impl(cx, tcx, did, impls),\n                 decoder::DlDef(def::DefMod(did)) => {\n                     csearch::each_child_of_item(&tcx.sess.cstore,\n                                                 did,\n@@ -262,14 +264,15 @@ fn build_impls(cx: &DocContext, tcx: &ty::ctxt,\n         }\n     }\n \n-    impls.into_iter().filter_map(|a| a).collect()\n+    return impls;\n }\n \n-fn build_impl(cx: &DocContext,\n-              tcx: &ty::ctxt,\n-              did: ast::DefId) -> Option<clean::Item> {\n+pub fn build_impl(cx: &DocContext,\n+                  tcx: &ty::ctxt,\n+                  did: ast::DefId,\n+                  ret: &mut Vec<clean::Item>) {\n     if !cx.inlined.borrow_mut().as_mut().unwrap().insert(did) {\n-        return None\n+        return\n     }\n \n     let attrs = load_attrs(cx, tcx, did);\n@@ -278,13 +281,13 @@ fn build_impl(cx: &DocContext,\n         // If this is an impl for a #[doc(hidden)] trait, be sure to not inline\n         let trait_attrs = load_attrs(cx, tcx, t.def_id);\n         if trait_attrs.iter().any(|a| is_doc_hidden(a)) {\n-            return None\n+            return\n         }\n     }\n \n     // If this is a defaulted impl, then bail out early here\n     if csearch::is_default_impl(&tcx.sess.cstore, did) {\n-        return Some(clean::Item {\n+        return ret.push(clean::Item {\n             inner: clean::DefaultImplItem(clean::DefaultImpl {\n                 // FIXME: this should be decoded\n                 unsafety: ast::Unsafety::Normal,\n@@ -352,19 +355,25 @@ fn build_impl(cx: &DocContext,\n                 })\n             }\n         }\n-    }).collect();\n+    }).collect::<Vec<_>>();\n     let polarity = csearch::get_impl_polarity(tcx, did);\n     let ty = ty::lookup_item_type(tcx, did);\n-    return Some(clean::Item {\n+    let trait_ = associated_trait.clean(cx).map(|bound| {\n+        match bound {\n+            clean::TraitBound(polyt, _) => polyt.trait_,\n+            clean::RegionBound(..) => unreachable!(),\n+        }\n+    });\n+    if let Some(clean::ResolvedPath { did, .. }) = trait_ {\n+        if Some(did) == cx.deref_trait_did.get() {\n+            super::build_deref_target_impls(cx, &trait_items, ret);\n+        }\n+    }\n+    ret.push(clean::Item {\n         inner: clean::ImplItem(clean::Impl {\n             unsafety: ast::Unsafety::Normal, // FIXME: this should be decoded\n             derived: clean::detect_derived(&attrs),\n-            trait_: associated_trait.clean(cx).map(|bound| {\n-                match bound {\n-                    clean::TraitBound(polyt, _) => polyt.trait_,\n-                    clean::RegionBound(..) => unreachable!(),\n-                }\n-            }),\n+            trait_: trait_,\n             for_: ty.ty.clean(cx),\n             generics: (&ty.generics, &predicates, subst::TypeSpace).clean(cx),\n             items: trait_items,"}, {"sha": "f7fbb67e08a28d65f7cdd9c28cce696b013bb0dc", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 95, "deletions": 6, "changes": 101, "blob_url": "https://github.com/rust-lang/rust/blob/1014ac44f6271a55249b0488a2ce1cc49deed338/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1014ac44f6271a55249b0488a2ce1cc49deed338/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=1014ac44f6271a55249b0488a2ce1cc49deed338", "patch": "@@ -128,6 +128,10 @@ impl<'a, 'tcx> Clean<Crate> for visit_ast::RustdocVisitor<'a, 'tcx> {\n     fn clean(&self, cx: &DocContext) -> Crate {\n         use rustc::session::config::Input;\n \n+        if let Some(t) = cx.tcx_opt() {\n+            cx.deref_trait_did.set(t.lang_items.deref_trait());\n+        }\n+\n         let mut externs = Vec::new();\n         cx.sess().cstore.iter_crate_data(|n, meta| {\n             externs.push((n, meta.clean(cx)));\n@@ -313,6 +317,22 @@ impl Item {\n     pub fn is_fn(&self) -> bool {\n         match self.inner { FunctionItem(..) => true, _ => false }\n     }\n+\n+    pub fn stability_class(&self) -> String {\n+        match self.stability {\n+            Some(ref s) => {\n+                let mut base = match s.level {\n+                    attr::Unstable => \"unstable\".to_string(),\n+                    attr::Stable => String::new(),\n+                };\n+                if !s.deprecated_since.is_empty() {\n+                    base.push_str(\" deprecated\");\n+                }\n+                base\n+            }\n+            _ => String::new(),\n+        }\n+    }\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n@@ -371,7 +391,7 @@ impl Clean<Item> for doctree::Module {\n         items.extend(self.statics.iter().map(|x| x.clean(cx)));\n         items.extend(self.constants.iter().map(|x| x.clean(cx)));\n         items.extend(self.traits.iter().map(|x| x.clean(cx)));\n-        items.extend(self.impls.iter().map(|x| x.clean(cx)));\n+        items.extend(self.impls.iter().flat_map(|x| x.clean(cx).into_iter()));\n         items.extend(self.macros.iter().map(|x| x.clean(cx)));\n         items.extend(self.def_traits.iter().map(|x| x.clean(cx)));\n \n@@ -1254,6 +1274,7 @@ impl Clean<Item> for ast::ImplItem {\n             ast::MacImplItem(_) => {\n                 MacroItem(Macro {\n                     source: self.span.to_src(cx),\n+                    imported_from: None,\n                 })\n             }\n         };\n@@ -2169,9 +2190,21 @@ fn detect_derived<M: AttrMetaMethods>(attrs: &[M]) -> bool {\n     attr::contains_name(attrs, \"automatically_derived\")\n }\n \n-impl Clean<Item> for doctree::Impl {\n-    fn clean(&self, cx: &DocContext) -> Item {\n-        Item {\n+impl Clean<Vec<Item>> for doctree::Impl {\n+    fn clean(&self, cx: &DocContext) -> Vec<Item> {\n+        let mut ret = Vec::new();\n+        let trait_ = self.trait_.clean(cx);\n+        let items = self.items.clean(cx);\n+\n+        // If this impl block is an implementation of the Deref trait, then we\n+        // need to try inlining the target's inherent impl blocks as well.\n+        if let Some(ResolvedPath { did, .. }) = trait_ {\n+            if Some(did) == cx.deref_trait_did.get() {\n+                build_deref_target_impls(cx, &items, &mut ret);\n+            }\n+        }\n+\n+        ret.push(Item {\n             name: None,\n             attrs: self.attrs.clean(cx),\n             source: self.whence.clean(cx),\n@@ -2181,12 +2214,66 @@ impl Clean<Item> for doctree::Impl {\n             inner: ImplItem(Impl {\n                 unsafety: self.unsafety,\n                 generics: self.generics.clean(cx),\n-                trait_: self.trait_.clean(cx),\n+                trait_: trait_,\n                 for_: self.for_.clean(cx),\n-                items: self.items.clean(cx),\n+                items: items,\n                 derived: detect_derived(&self.attrs),\n                 polarity: Some(self.polarity.clean(cx)),\n             }),\n+        });\n+        return ret;\n+    }\n+}\n+\n+fn build_deref_target_impls(cx: &DocContext,\n+                            items: &[Item],\n+                            ret: &mut Vec<Item>) {\n+    let tcx = match cx.tcx_opt() {\n+        Some(t) => t,\n+        None => return,\n+    };\n+\n+    for item in items {\n+        let target = match item.inner {\n+            TypedefItem(ref t) => &t.type_,\n+            _ => continue,\n+        };\n+        let primitive = match *target {\n+            ResolvedPath { did, .. } if ast_util::is_local(did) => continue,\n+            ResolvedPath { did, .. } => {\n+                ret.extend(inline::build_impls(cx, tcx, did));\n+                continue\n+            }\n+            _ => match target.primitive_type() {\n+                Some(prim) => prim,\n+                None => continue,\n+            }\n+        };\n+        let did = match primitive {\n+            Isize => tcx.lang_items.isize_impl(),\n+            I8 => tcx.lang_items.i8_impl(),\n+            I16 => tcx.lang_items.i16_impl(),\n+            I32 => tcx.lang_items.i32_impl(),\n+            I64 => tcx.lang_items.i64_impl(),\n+            Usize => tcx.lang_items.usize_impl(),\n+            U8 => tcx.lang_items.u8_impl(),\n+            U16 => tcx.lang_items.u16_impl(),\n+            U32 => tcx.lang_items.u32_impl(),\n+            U64 => tcx.lang_items.u64_impl(),\n+            F32 => tcx.lang_items.f32_impl(),\n+            F64 => tcx.lang_items.f64_impl(),\n+            Char => tcx.lang_items.char_impl(),\n+            Bool => None,\n+            Str => tcx.lang_items.str_impl(),\n+            Slice => tcx.lang_items.slice_impl(),\n+            Array => tcx.lang_items.slice_impl(),\n+            PrimitiveTuple => None,\n+            PrimitiveRawPointer => tcx.lang_items.const_ptr_impl(),\n+        };\n+        if let Some(did) = did {\n+            if !ast_util::is_local(did) {\n+                inline::build_impl(cx, tcx, did, ret);\n+            }\n         }\n     }\n }\n@@ -2541,6 +2628,7 @@ fn resolve_def(cx: &DocContext, id: ast::NodeId) -> Option<ast::DefId> {\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Macro {\n     pub source: String,\n+    pub imported_from: Option<String>,\n }\n \n impl Clean<Item> for doctree::Macro {\n@@ -2554,6 +2642,7 @@ impl Clean<Item> for doctree::Macro {\n             def_id: ast_util::local_def(self.id),\n             inner: MacroItem(Macro {\n                 source: self.whence.to_src(cx),\n+                imported_from: self.imported_from.clean(cx),\n             }),\n         }\n     }"}, {"sha": "1b74123c4adcde4a9fa17c9d2517e0d64a5354ae", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1014ac44f6271a55249b0488a2ce1cc49deed338/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1014ac44f6271a55249b0488a2ce1cc49deed338/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=1014ac44f6271a55249b0488a2ce1cc49deed338", "patch": "@@ -20,7 +20,7 @@ use rustc_resolve as resolve;\n \n use syntax::{ast, ast_map, codemap, diagnostic};\n \n-use std::cell::RefCell;\n+use std::cell::{RefCell, Cell};\n use std::collections::{HashMap, HashSet};\n \n use visit_ast::RustdocVisitor;\n@@ -48,6 +48,7 @@ pub struct DocContext<'tcx> {\n     pub external_typarams: RefCell<Option<HashMap<ast::DefId, String>>>,\n     pub inlined: RefCell<Option<HashSet<ast::DefId>>>,\n     pub populated_crate_impls: RefCell<HashSet<ast::CrateNum>>,\n+    pub deref_trait_did: Cell<Option<ast::DefId>>,\n }\n \n impl<'tcx> DocContext<'tcx> {\n@@ -77,6 +78,7 @@ pub struct CrateAnalysis {\n     pub external_paths: ExternalPaths,\n     pub external_typarams: RefCell<Option<HashMap<ast::DefId, String>>>,\n     pub inlined: RefCell<Option<HashSet<ast::DefId>>>,\n+    pub deref_trait_did: Option<ast::DefId>,\n }\n \n pub type Externs = HashMap<String, Vec<String>>;\n@@ -147,15 +149,17 @@ pub fn run_core(search_paths: SearchPaths, cfgs: Vec<String>, externs: Externs,\n         external_paths: RefCell::new(Some(HashMap::new())),\n         inlined: RefCell::new(Some(HashSet::new())),\n         populated_crate_impls: RefCell::new(HashSet::new()),\n+        deref_trait_did: Cell::new(None),\n     };\n     debug!(\"crate: {:?}\", ctxt.krate);\n \n-    let analysis = CrateAnalysis {\n+    let mut analysis = CrateAnalysis {\n         exported_items: exported_items,\n         public_items: public_items,\n         external_paths: RefCell::new(None),\n         external_typarams: RefCell::new(None),\n         inlined: RefCell::new(None),\n+        deref_trait_did: None,\n     };\n \n     let krate = {\n@@ -170,5 +174,6 @@ pub fn run_core(search_paths: SearchPaths, cfgs: Vec<String>, externs: Externs,\n     *analysis.external_typarams.borrow_mut() = map;\n     let map = ctxt.inlined.borrow_mut().take();\n     *analysis.inlined.borrow_mut() = map;\n+    analysis.deref_trait_did = ctxt.deref_trait_did.get();\n     (krate, analysis)\n }"}, {"sha": "8fa92304d249cb9d3adcfdba00d3b77e6250992c", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1014ac44f6271a55249b0488a2ce1cc49deed338/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1014ac44f6271a55249b0488a2ce1cc49deed338/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=1014ac44f6271a55249b0488a2ce1cc49deed338", "patch": "@@ -214,6 +214,7 @@ pub struct Macro {\n     pub attrs: Vec<ast::Attribute>,\n     pub whence: Span,\n     pub stab: Option<attr::Stability>,\n+    pub imported_from: Option<Ident>,\n }\n \n pub struct ExternCrate {"}, {"sha": "bb53d532f52f725b00453ad44dda63a16e221b70", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 6, "deletions": 128, "changes": 134, "blob_url": "https://github.com/rust-lang/rust/blob/1014ac44f6271a55249b0488a2ce1cc49deed338/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1014ac44f6271a55249b0488a2ce1cc49deed338/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=1014ac44f6271a55249b0488a2ce1cc49deed338", "patch": "@@ -23,10 +23,8 @@ use syntax::ast;\n use syntax::ast_util;\n \n use clean;\n-use stability_summary::ModuleSummary;\n use html::item_type::ItemType;\n use html::render;\n-use html::escape::Escape;\n use html::render::{cache, CURRENT_LOCATION_KEY};\n \n /// Helper to render an optional visibility with a space after it (if the\n@@ -45,10 +43,6 @@ pub struct MutableSpace(pub clean::Mutability);\n /// Similar to VisSpace, but used for mutability\n #[derive(Copy, Clone)]\n pub struct RawMutableSpace(pub clean::Mutability);\n-/// Wrapper struct for properly emitting the stability level.\n-pub struct Stability<'a>(pub &'a Option<clean::Stability>);\n-/// Wrapper struct for emitting the stability level concisely.\n-pub struct ConciseStability<'a>(pub &'a Option<clean::Stability>);\n /// Wrapper struct for emitting a where clause from Generics.\n pub struct WhereClause<'a>(pub &'a clean::Generics);\n /// Wrapper struct for emitting type parameter bounds.\n@@ -294,9 +288,9 @@ pub fn href(did: ast::DefId) -> Option<(String, ItemType, Vec<String>)> {\n         repeat(\"../\").take(loc.len()).collect::<String>()\n     } else {\n         match cache.extern_locations[&did.krate] {\n-            render::Remote(ref s) => s.to_string(),\n-            render::Local => repeat(\"../\").take(loc.len()).collect::<String>(),\n-            render::Unknown => return None,\n+            (_, render::Remote(ref s)) => s.to_string(),\n+            (_, render::Local) => repeat(\"../\").take(loc.len()).collect(),\n+            (_, render::Unknown) => return None,\n         }\n     };\n     for component in &fqp[..fqp.len() - 1] {\n@@ -385,12 +379,12 @@ fn primitive_link(f: &mut fmt::Formatter,\n                 node: ast::CRATE_NODE_ID,\n             }];\n             let loc = match m.extern_locations[&cnum] {\n-                render::Remote(ref s) => Some(s.to_string()),\n-                render::Local => {\n+                (_, render::Remote(ref s)) => Some(s.to_string()),\n+                (_, render::Local) => {\n                     let len = CURRENT_LOCATION_KEY.with(|s| s.borrow().len());\n                     Some(repeat(\"../\").take(len).collect::<String>())\n                 }\n-                render::Unknown => None,\n+                (_, render::Unknown) => None,\n             };\n             match loc {\n                 Some(root) => {\n@@ -702,119 +696,3 @@ impl fmt::Display for AbiSpace {\n         }\n     }\n }\n-\n-impl<'a> fmt::Display for Stability<'a> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        let Stability(stab) = *self;\n-        match *stab {\n-            Some(ref stability) => {\n-                let lvl = if stability.deprecated_since.is_empty() {\n-                    format!(\"{}\", stability.level)\n-                } else {\n-                    \"Deprecated\".to_string()\n-                };\n-                write!(f, \"<a class='stability {lvl}' title='{reason}'>{lvl}</a>\",\n-                       lvl = Escape(&*lvl),\n-                       reason = Escape(&*stability.reason))\n-            }\n-            None => Ok(())\n-        }\n-    }\n-}\n-\n-impl<'a> fmt::Display for ConciseStability<'a> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        let ConciseStability(stab) = *self;\n-        match *stab {\n-            Some(ref stability) => {\n-                let lvl = if stability.deprecated_since.is_empty() {\n-                    format!(\"{}\", stability.level)\n-                } else {\n-                    \"Deprecated\".to_string()\n-                };\n-                write!(f, \"<a class='stability {lvl}' title='{lvl}{colon}{reason}'></a>\",\n-                       lvl = Escape(&*lvl),\n-                       colon = if !stability.reason.is_empty() { \": \" } else { \"\" },\n-                       reason = Escape(&*stability.reason))\n-            }\n-            None => {\n-                write!(f, \"<a class='stability Unmarked' title='No stability level'></a>\")\n-            }\n-        }\n-    }\n-}\n-\n-impl fmt::Display for ModuleSummary {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        fn fmt_inner<'a>(f: &mut fmt::Formatter,\n-                         context: &mut Vec<&'a str>,\n-                         m: &'a ModuleSummary)\n-                     -> fmt::Result {\n-            let cnt = m.counts;\n-            let tot = cnt.total();\n-            if tot == 0 { return Ok(()) }\n-\n-            context.push(&m.name);\n-            let path = context.connect(\"::\");\n-\n-            try!(write!(f, \"<tr>\"));\n-            try!(write!(f, \"<td><a href='{}'>{}</a></td>\", {\n-                            let mut url = context[1..].to_vec();\n-                            url.push(\"index.html\");\n-                            url.connect(\"/\")\n-                        },\n-                        path));\n-            try!(write!(f, \"<td class='summary-column'>\"));\n-            try!(write!(f, \"<span class='summary Stable' \\\n-                            style='width: {:.4}%; display: inline-block'>&nbsp</span>\",\n-                        (100 * cnt.stable) as f64/tot as f64));\n-            try!(write!(f, \"<span class='summary Unstable' \\\n-                            style='width: {:.4}%; display: inline-block'>&nbsp</span>\",\n-                        (100 * cnt.unstable) as f64/tot as f64));\n-            try!(write!(f, \"<span class='summary Deprecated' \\\n-                            style='width: {:.4}%; display: inline-block'>&nbsp</span>\",\n-                        (100 * cnt.deprecated) as f64/tot as f64));\n-            try!(write!(f, \"<span class='summary Unmarked' \\\n-                            style='width: {:.4}%; display: inline-block'>&nbsp</span>\",\n-                        (100 * cnt.unmarked) as f64/tot as f64));\n-            try!(write!(f, \"</td></tr>\"));\n-\n-            for submodule in &m.submodules {\n-                try!(fmt_inner(f, context, submodule));\n-            }\n-            context.pop();\n-            Ok(())\n-        }\n-\n-        let mut context = Vec::new();\n-\n-        let tot = self.counts.total();\n-        let (stable, unstable, deprecated, unmarked) = if tot == 0 {\n-            (0, 0, 0, 0)\n-        } else {\n-            ((100 * self.counts.stable)/tot,\n-             (100 * self.counts.unstable)/tot,\n-             (100 * self.counts.deprecated)/tot,\n-             (100 * self.counts.unmarked)/tot)\n-        };\n-\n-        try!(write!(f,\n-r\"<h1 class='fqn'>Stability dashboard: crate <a class='mod' href='index.html'>{name}</a></h1>\n-This dashboard summarizes the stability levels for all of the public modules of\n-the crate, according to the total number of items at each level in the module and\n-its children (percentages total for {name}):\n-<blockquote>\n-<a class='stability Stable'></a> stable ({}%),<br/>\n-<a class='stability Unstable'></a> unstable ({}%),<br/>\n-<a class='stability Deprecated'></a> deprecated ({}%),<br/>\n-<a class='stability Unmarked'></a> unmarked ({}%)\n-</blockquote>\n-The counts do not include methods or trait\n-implementations that are visible only through a re-exported type.\",\n-stable, unstable, deprecated, unmarked,\n-name=self.name));\n-        try!(write!(f, \"<table>\"));\n-        try!(fmt_inner(f, &mut context, self));\n-        write!(f, \"</table>\")\n-    }\n-}"}, {"sha": "f87a86eb3a68c1d8315cc35183cbfc156140984b", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 219, "deletions": 141, "changes": 360, "blob_url": "https://github.com/rust-lang/rust/blob/1014ac44f6271a55249b0488a2ce1cc49deed338/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1014ac44f6271a55249b0488a2ce1cc49deed338/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=1014ac44f6271a55249b0488a2ce1cc49deed338", "patch": "@@ -56,19 +56,20 @@ use serialize::json::ToJson;\n use syntax::abi;\n use syntax::ast;\n use syntax::ast_util;\n+use syntax::attr;\n use rustc::util::nodemap::NodeSet;\n \n use clean;\n use doctree;\n use fold::DocFolder;\n-use html::format::{VisSpace, Method, UnsafetySpace, MutableSpace, Stability};\n-use html::format::{ConciseStability, TyParamBounds, WhereClause, href, AbiSpace};\n+use html::escape::Escape;\n+use html::format::{TyParamBounds, WhereClause, href, AbiSpace};\n+use html::format::{VisSpace, Method, UnsafetySpace, MutableSpace};\n use html::highlight;\n use html::item_type::ItemType;\n use html::layout;\n use html::markdown::Markdown;\n use html::markdown;\n-use stability_summary;\n \n /// A pair of name and its optional document.\n pub type NameDoc = (String, Option<String>);\n@@ -192,7 +193,7 @@ pub struct Cache {\n     pub implementors: HashMap<ast::DefId, Vec<Implementor>>,\n \n     /// Cache of where external crate documentation can be found.\n-    pub extern_locations: HashMap<ast::CrateNum, ExternalLocation>,\n+    pub extern_locations: HashMap<ast::CrateNum, (String, ExternalLocation)>,\n \n     /// Cache of where documentation for primitives can be found.\n     pub primitive_locations: HashMap<clean::PrimitiveType, ast::CrateNum>,\n@@ -208,6 +209,7 @@ pub struct Cache {\n     privmod: bool,\n     remove_priv: bool,\n     public_items: NodeSet,\n+    deref_trait_did: Option<ast::DefId>,\n \n     // In rare case where a structure is defined in one module but implemented\n     // in another, if the implementing module is parsed before defining module,\n@@ -395,19 +397,19 @@ pub fn run(mut krate: clean::Crate,\n         public_items: public_items,\n         orphan_methods: Vec::new(),\n         traits: mem::replace(&mut krate.external_traits, HashMap::new()),\n+        deref_trait_did: analysis.as_ref().and_then(|a| a.deref_trait_did),\n         typarams: analysis.as_ref().map(|a| {\n             a.external_typarams.borrow_mut().take().unwrap()\n         }).unwrap_or(HashMap::new()),\n         inlined: analysis.as_ref().map(|a| {\n             a.inlined.borrow_mut().take().unwrap()\n         }).unwrap_or(HashSet::new()),\n     };\n-    cache.stack.push(krate.name.clone());\n-    krate = cache.fold_crate(krate);\n \n     // Cache where all our extern crates are located\n     for &(n, ref e) in &krate.externs {\n-        cache.extern_locations.insert(n, extern_location(e, &cx.dst));\n+        cache.extern_locations.insert(n, (e.name.clone(),\n+                                          extern_location(e, &cx.dst)));\n         let did = ast::DefId { krate: n, node: ast::CRATE_NODE_ID };\n         cache.paths.insert(did, (vec![e.name.to_string()], ItemType::Module));\n     }\n@@ -425,6 +427,9 @@ pub fn run(mut krate: clean::Crate,\n         cache.primitive_locations.insert(prim, ast::LOCAL_CRATE);\n     }\n \n+    cache.stack.push(krate.name.clone());\n+    krate = cache.fold_crate(krate);\n+\n     // Build our search index\n     let index = try!(build_index(&krate, &mut cache));\n \n@@ -437,11 +442,8 @@ pub fn run(mut krate: clean::Crate,\n     try!(write_shared(&cx, &krate, &*cache, index));\n     let krate = try!(render_sources(&mut cx, krate));\n \n-    // Crawl the crate, building a summary of the stability levels.\n-    let summary = stability_summary::build(&krate);\n-\n     // And finally render the whole crate's documentation\n-    cx.krate(krate, summary)\n+    cx.krate(krate)\n }\n \n fn build_index(krate: &clean::Crate, cache: &mut Cache) -> io::Result<String> {\n@@ -645,8 +647,7 @@ fn write_shared(cx: &Context,\n             // going on). If they're in different crates then the crate defining\n             // the trait will be interested in our implementation.\n             if imp.def_id.krate == did.krate { continue }\n-            try!(write!(&mut f, r#\"\"{}impl{} {}{} for {}\",\"#,\n-                        ConciseStability(&imp.stability),\n+            try!(write!(&mut f, r#\"\"impl{} {}{} for {}\",\"#,\n                         imp.generics,\n                         if imp.polarity == Some(clean::ImplPolarity::Negative) { \"!\" } else { \"\" },\n                         imp.trait_, imp.for_));\n@@ -1071,8 +1072,11 @@ impl DocFolder for Cache {\n                             }\n \n                             ref t => {\n-                                t.primitive_type().map(|p| {\n-                                    ast_util::local_def(p.to_node_id())\n+                                t.primitive_type().and_then(|t| {\n+                                    self.primitive_locations.get(&t).map(|n| {\n+                                        let id = t.to_node_id();\n+                                        ast::DefId { krate: *n, node: id }\n+                                    })\n                                 })\n                             }\n                         };\n@@ -1143,38 +1147,13 @@ impl Context {\n     ///\n     /// This currently isn't parallelized, but it'd be pretty easy to add\n     /// parallelization to this function.\n-    fn krate(mut self, mut krate: clean::Crate,\n-             stability: stability_summary::ModuleSummary) -> io::Result<()> {\n+    fn krate(self, mut krate: clean::Crate) -> io::Result<()> {\n         let mut item = match krate.module.take() {\n             Some(i) => i,\n             None => return Ok(())\n         };\n         item.name = Some(krate.name);\n \n-        // render stability dashboard\n-        try!(self.recurse(stability.name.clone(), |this| {\n-            let json_dst = &this.dst.join(\"stability.json\");\n-            let mut json_out = BufWriter::new(try!(File::create(json_dst)));\n-            try!(write!(&mut json_out, \"{}\", json::as_json(&stability)));\n-\n-            let mut title = stability.name.clone();\n-            title.push_str(\" - Stability dashboard\");\n-            let desc = format!(\"API stability overview for the Rust `{}` crate.\",\n-                               this.layout.krate);\n-            let page = layout::Page {\n-                ty: \"mod\",\n-                root_path: &this.root_path,\n-                title: &title,\n-                description: &desc,\n-                keywords: get_basic_keywords(),\n-            };\n-            let html_dst = &this.dst.join(\"stability.html\");\n-            let mut html_out = BufWriter::new(try!(File::create(html_dst)));\n-            layout::render(&mut html_out, &this.layout, &page,\n-                           &Sidebar{ cx: this, item: &item },\n-                           &stability)\n-        }));\n-\n         // render the crate documentation\n         let mut work = vec!((self, item));\n         loop {\n@@ -1371,22 +1350,43 @@ impl<'a> Item<'a> {\n     /// may happen, for example, with externally inlined items where the source\n     /// of their crate documentation isn't known.\n     fn href(&self, cx: &Context) -> Option<String> {\n+        let href = if self.item.source.loline == self.item.source.hiline {\n+            format!(\"{}\", self.item.source.loline)\n+        } else {\n+            format!(\"{}-{}\", self.item.source.loline, self.item.source.hiline)\n+        };\n+\n+        // First check to see if this is an imported macro source. In this case\n+        // we need to handle it specially as cross-crate inlined macros have...\n+        // odd locations!\n+        let imported_macro_from = match self.item.inner {\n+            clean::MacroItem(ref m) => m.imported_from.as_ref(),\n+            _ => None,\n+        };\n+        if let Some(krate) = imported_macro_from {\n+            let cache = cache();\n+            let root = cache.extern_locations.values().find(|&&(ref n, _)| {\n+                *krate == *n\n+            }).map(|l| &l.1);\n+            let root = match root {\n+                Some(&Remote(ref s)) => s.to_string(),\n+                Some(&Local) => self.cx.root_path.clone(),\n+                None | Some(&Unknown) => return None,\n+            };\n+            Some(format!(\"{root}/{krate}/macro.{name}.html?gotomacrosrc=1\",\n+                         root = root,\n+                         krate = krate,\n+                         name = self.item.name.as_ref().unwrap()))\n+\n         // If this item is part of the local crate, then we're guaranteed to\n         // know the span, so we plow forward and generate a proper url. The url\n         // has anchors for the line numbers that we're linking to.\n-        if ast_util::is_local(self.item.def_id) {\n+        } else if ast_util::is_local(self.item.def_id) {\n             let mut path = Vec::new();\n             clean_srcpath(&cx.src_root, Path::new(&self.item.source.filename),\n                           true, |component| {\n                 path.push(component.to_string());\n             });\n-            let href = if self.item.source.loline == self.item.source.hiline {\n-                format!(\"{}\", self.item.source.loline)\n-            } else {\n-                format!(\"{}-{}\",\n-                        self.item.source.loline,\n-                        self.item.source.hiline)\n-            };\n             Some(format!(\"{root}src/{krate}/{path}.html#{href}\",\n                          root = self.cx.root_path,\n                          krate = self.cx.layout.krate,\n@@ -1408,9 +1408,9 @@ impl<'a> Item<'a> {\n             let cache = cache();\n             let path = &cache.external_paths[&self.item.def_id];\n             let root = match cache.extern_locations[&self.item.def_id.krate] {\n-                Remote(ref s) => s.to_string(),\n-                Local => self.cx.root_path.clone(),\n-                Unknown => return None,\n+                (_, Remote(ref s)) => s.to_string(),\n+                (_, Local) => self.cx.root_path.clone(),\n+                (_, Unknown) => return None,\n             };\n             Some(format!(\"{root}{path}/{file}?gotosrc={goto}\",\n                          root = root,\n@@ -1456,21 +1456,8 @@ impl<'a> fmt::Display for Item<'a> {\n         try!(write!(fmt, \"<a class='{}' href=''>{}</a>\",\n                     shortty(self.item), self.item.name.as_ref().unwrap()));\n \n-        // Write stability level\n-        try!(write!(fmt, \"<wbr>{}\", Stability(&self.item.stability)));\n-\n         try!(write!(fmt, \"</span>\")); // in-band\n-        // Links to out-of-band information, i.e. src and stability dashboard\n         try!(write!(fmt, \"<span class='out-of-band'>\"));\n-\n-        // Write stability dashboard link\n-        match self.item.inner {\n-            clean::ModuleItem(ref m) if m.is_crate => {\n-                try!(write!(fmt, \"<a href='stability.html'>[stability]</a> \"));\n-            }\n-            _ => {}\n-        };\n-\n         try!(write!(fmt,\n         r##\"<span id='render-detail'>\n             <a id=\"collapse-all\" href=\"#\">[-]</a>&nbsp;<a id=\"expand-all\" href=\"#\">[+]</a>\n@@ -1485,7 +1472,8 @@ impl<'a> fmt::Display for Item<'a> {\n         if self.cx.include_sources && !is_primitive {\n             match self.href(self.cx) {\n                 Some(l) => {\n-                    try!(write!(fmt, \"<a id='src-{}' href='{}'>[src]</a>\",\n+                    try!(write!(fmt, \"<a id='src-{}' class='srclink' \\\n+                                       href='{}'>[src]</a>\",\n                                 self.item.def_id.node, l));\n                 }\n                 None => {}\n@@ -1554,11 +1542,11 @@ fn plain_summary_line(s: Option<&str>) -> String {\n }\n \n fn document(w: &mut fmt::Formatter, item: &clean::Item) -> fmt::Result {\n-    match item.doc_value() {\n-        Some(s) => {\n-            try!(write!(w, \"<div class='docblock'>{}</div>\", Markdown(s)));\n-        }\n-        None => {}\n+    if let Some(s) = short_stability(item, true) {\n+        try!(write!(w, \"<div class='stability'>{}</div>\", s));\n+    }\n+    if let Some(s) = item.doc_value() {\n+        try!(write!(w, \"<div class='docblock'>{}</div>\", Markdown(s)));\n     }\n     Ok(())\n }\n@@ -1593,10 +1581,17 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n     fn cmp(i1: &clean::Item, i2: &clean::Item, idx1: usize, idx2: usize) -> Ordering {\n         let ty1 = shortty(i1);\n         let ty2 = shortty(i2);\n-        if ty1 == ty2 {\n-            return i1.name.cmp(&i2.name);\n+        if ty1 != ty2 {\n+            return (reorder(ty1), idx1).cmp(&(reorder(ty2), idx2))\n+        }\n+        let s1 = i1.stability.as_ref().map(|s| s.level);\n+        let s2 = i2.stability.as_ref().map(|s| s.level);\n+        match (s1, s2) {\n+            (Some(attr::Unstable), Some(attr::Stable)) => return Ordering::Greater,\n+            (Some(attr::Stable), Some(attr::Unstable)) => return Ordering::Less,\n+            _ => {}\n         }\n-        (reorder(ty1), idx1).cmp(&(reorder(ty2), idx2))\n+        i1.name.cmp(&i2.name)\n     }\n \n     indices.sort_by(|&i1, &i2| cmp(&items[i1], &items[i2], i1, i2));\n@@ -1665,26 +1660,58 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n \n             _ => {\n                 if myitem.name.is_none() { continue }\n+                let stab_docs = if let Some(s) = short_stability(myitem, false) {\n+                    format!(\"[{}]\", s)\n+                } else {\n+                    String::new()\n+                };\n                 try!(write!(w, \"\n-                    <tr>\n-                        <td>{stab}<a class='{class}' href='{href}'\n-                               title='{title}'>{}</a></td>\n-                        <td class='docblock short'>{}</td>\n+                    <tr class='{stab} module-item'>\n+                        <td><a class='{class}' href='{href}'\n+                               title='{title}'>{name}</a></td>\n+                        <td class='docblock short'>\n+                            {stab_docs} {docs}\n+                        </td>\n                     </tr>\n                 \",\n-                *myitem.name.as_ref().unwrap(),\n-                Markdown(&shorter(myitem.doc_value())[..]),\n+                name = *myitem.name.as_ref().unwrap(),\n+                stab_docs = stab_docs,\n+                docs = Markdown(&shorter(myitem.doc_value())),\n                 class = shortty(myitem),\n+                stab = myitem.stability_class(),\n                 href = item_path(myitem),\n-                title = full_path(cx, myitem),\n-                stab = ConciseStability(&myitem.stability)));\n+                title = full_path(cx, myitem)));\n             }\n         }\n     }\n \n     write!(w, \"</table>\")\n }\n \n+fn short_stability(item: &clean::Item, show_reason: bool) -> Option<String> {\n+    item.stability.as_ref().and_then(|stab| {\n+        let reason = if show_reason && !stab.reason.is_empty() {\n+            format!(\": {}\", stab.reason)\n+        } else {\n+            String::new()\n+        };\n+        let text = if !stab.deprecated_since.is_empty() {\n+            let since = if show_reason {\n+                format!(\" since {}\", Escape(&stab.deprecated_since))\n+            } else {\n+                String::new()\n+            };\n+            format!(\"Deprecated{}{}\", since, Markdown(&reason))\n+        } else if stab.level == attr::Unstable {\n+            format!(\"Unstable{}\", Markdown(&reason))\n+        } else {\n+            return None\n+        };\n+        Some(format!(\"<em class='stab {}'>{}</em>\",\n+                     item.stability_class(), text))\n+    })\n+}\n+\n struct Initializer<'a>(&'a str);\n \n impl<'a> fmt::Display for Initializer<'a> {\n@@ -1800,10 +1827,10 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n \n     fn trait_item(w: &mut fmt::Formatter, m: &clean::Item)\n                   -> fmt::Result {\n-        try!(write!(w, \"<h3 id='{}.{}' class='method'>{}<code>\",\n-                    shortty(m),\n-                    *m.name.as_ref().unwrap(),\n-                    ConciseStability(&m.stability)));\n+        try!(write!(w, \"<h3 id='{ty}.{name}' class='method stab {stab}'><code>\",\n+                    ty = shortty(m),\n+                    name = *m.name.as_ref().unwrap(),\n+                    stab = m.stability_class()));\n         try!(render_method(w, m, MethodLink::Anchor));\n         try!(write!(w, \"</code></h3>\"));\n         try!(document(w, m));\n@@ -1844,7 +1871,7 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     }\n \n     // If there are methods directly on this trait object, render them here.\n-    try!(render_methods(w, it));\n+    try!(render_methods(w, it.def_id, MethodRender::All));\n \n     let cache = cache();\n     try!(write!(w, \"\n@@ -1854,8 +1881,7 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     match cache.implementors.get(&it.def_id) {\n         Some(implementors) => {\n             for i in implementors {\n-                try!(writeln!(w, \"<li>{}<code>impl{} {} for {}{}</code></li>\",\n-                              ConciseStability(&i.stability),\n+                try!(writeln!(w, \"<li><code>impl{} {} for {}{}</code></li>\",\n                               i.generics, i.trait_, i.for_, WhereClause(&i.generics)));\n             }\n         }\n@@ -1964,17 +1990,18 @@ fn item_struct(w: &mut fmt::Formatter, it: &clean::Item,\n         if fields.peek().is_some() {\n             try!(write!(w, \"<h2 class='fields'>Fields</h2>\\n<table>\"));\n             for field in fields {\n-                try!(write!(w, \"<tr><td id='structfield.{name}'>\\\n-                                  {stab}<code>{name}</code></td><td>\",\n-                            stab = ConciseStability(&field.stability),\n+                try!(write!(w, \"<tr class='stab {stab}'>\n+                                  <td id='structfield.{name}'>\\\n+                                    <code>{name}</code></td><td>\",\n+                            stab = field.stability_class(),\n                             name = field.name.as_ref().unwrap()));\n                 try!(document(w, field));\n                 try!(write!(w, \"</td></tr>\"));\n             }\n             try!(write!(w, \"</table>\"));\n         }\n     }\n-    render_methods(w, it)\n+    render_methods(w, it.def_id, MethodRender::All)\n }\n \n fn item_enum(w: &mut fmt::Formatter, it: &clean::Item,\n@@ -2034,8 +2061,7 @@ fn item_enum(w: &mut fmt::Formatter, it: &clean::Item,\n     if !e.variants.is_empty() {\n         try!(write!(w, \"<h2 class='variants'>Variants</h2>\\n<table>\"));\n         for variant in &e.variants {\n-            try!(write!(w, \"<tr><td id='variant.{name}'>{stab}<code>{name}</code></td><td>\",\n-                          stab = ConciseStability(&variant.stability),\n+            try!(write!(w, \"<tr><td id='variant.{name}'><code>{name}</code></td><td>\",\n                           name = variant.name.as_ref().unwrap()));\n             try!(document(w, variant));\n             match variant.inner {\n@@ -2074,7 +2100,7 @@ fn item_enum(w: &mut fmt::Formatter, it: &clean::Item,\n         try!(write!(w, \"</table>\"));\n \n     }\n-    try!(render_methods(w, it));\n+    try!(render_methods(w, it.def_id, MethodRender::All));\n     Ok(())\n }\n \n@@ -2163,101 +2189,154 @@ enum MethodLink {\n     GotoSource(ast::DefId),\n }\n \n-fn render_methods(w: &mut fmt::Formatter, it: &clean::Item) -> fmt::Result {\n-    let v = match cache().impls.get(&it.def_id) {\n-        Some(v) => v.clone(),\n+enum MethodRender<'a> {\n+    All,\n+    DerefFor { trait_: &'a clean::Type, type_: &'a clean::Type },\n+}\n+\n+fn render_methods(w: &mut fmt::Formatter,\n+                  it: ast::DefId,\n+                  what: MethodRender) -> fmt::Result {\n+    let c = cache();\n+    let v = match c.impls.get(&it) {\n+        Some(v) => v,\n         None => return Ok(()),\n     };\n-    let (non_trait, traits): (Vec<_>, _) = v.into_iter()\n-        .partition(|i| i.impl_.trait_.is_none());\n+    let (non_trait, traits): (Vec<_>, _) = v.iter().partition(|i| {\n+        i.impl_.trait_.is_none()\n+    });\n     if !non_trait.is_empty() {\n-        try!(write!(w, \"<h2 id='methods'>Methods</h2>\"));\n+        let render_header = match what {\n+            MethodRender::All => {\n+                try!(write!(w, \"<h2 id='methods'>Methods</h2>\"));\n+                true\n+            }\n+            MethodRender::DerefFor { trait_, type_ } => {\n+                try!(write!(w, \"<h2 id='deref-methods'>Methods from \\\n+                                    {}&lt;Target={}&gt;</h2>\", trait_, type_));\n+                false\n+            }\n+        };\n         for i in &non_trait {\n-            try!(render_impl(w, i, MethodLink::Anchor));\n+            try!(render_impl(w, i, MethodLink::Anchor, render_header));\n         }\n     }\n+    if let MethodRender::DerefFor { .. } = what {\n+        return Ok(())\n+    }\n     if !traits.is_empty() {\n+        let deref_impl = traits.iter().find(|t| {\n+            match *t.impl_.trait_.as_ref().unwrap() {\n+                clean::ResolvedPath { did, .. } => {\n+                    Some(did) == c.deref_trait_did\n+                }\n+                _ => false\n+            }\n+        });\n+        if let Some(impl_) = deref_impl {\n+            try!(render_deref_methods(w, impl_));\n+        }\n         try!(write!(w, \"<h2 id='implementations'>Trait \\\n                           Implementations</h2>\"));\n-        let (derived, manual): (Vec<_>, _) = traits.into_iter()\n-            .partition(|i| i.impl_.derived);\n+        let (derived, manual): (Vec<_>, _) = traits.iter().partition(|i| {\n+            i.impl_.derived\n+        });\n         for i in &manual {\n             let did = i.trait_did().unwrap();\n-            try!(render_impl(w, i, MethodLink::GotoSource(did)));\n+            try!(render_impl(w, i, MethodLink::GotoSource(did), true));\n         }\n         if !derived.is_empty() {\n             try!(write!(w, \"<h3 id='derived_implementations'>\\\n                 Derived Implementations \\\n             </h3>\"));\n             for i in &derived {\n                 let did = i.trait_did().unwrap();\n-                try!(render_impl(w, i, MethodLink::GotoSource(did)));\n+                try!(render_impl(w, i, MethodLink::GotoSource(did), true));\n             }\n         }\n     }\n     Ok(())\n }\n \n-fn render_impl(w: &mut fmt::Formatter, i: &Impl, link: MethodLink)\n-               -> fmt::Result {\n-    try!(write!(w, \"<h3 class='impl'>{}<code>impl{} \",\n-                ConciseStability(&i.stability),\n-                i.impl_.generics));\n-    if let Some(clean::ImplPolarity::Negative) = i.impl_.polarity {\n-        try!(write!(w, \"!\"));\n-    }\n-    if let Some(ref ty) = i.impl_.trait_ {\n-        try!(write!(w, \"{} for \", *ty));\n+fn render_deref_methods(w: &mut fmt::Formatter, impl_: &Impl) -> fmt::Result {\n+    let deref_type = impl_.impl_.trait_.as_ref().unwrap();\n+    let target = impl_.impl_.items.iter().filter_map(|item| {\n+        match item.inner {\n+            clean::TypedefItem(ref t) => Some(&t.type_),\n+            _ => None,\n+        }\n+    }).next().unwrap();\n+    let what = MethodRender::DerefFor { trait_: deref_type, type_: target };\n+    match *target {\n+        clean::ResolvedPath { did, .. } => render_methods(w, did, what),\n+        _ => {\n+            if let Some(prim) = target.primitive_type() {\n+                if let Some(c) = cache().primitive_locations.get(&prim) {\n+                    let did = ast::DefId { krate: *c, node: prim.to_node_id() };\n+                    try!(render_methods(w, did, what));\n+                }\n+            }\n+            Ok(())\n+        }\n     }\n-    try!(write!(w, \"{}{}</code></h3>\", i.impl_.for_,\n-                WhereClause(&i.impl_.generics)));\n-    if let Some(ref dox) = i.dox {\n-        try!(write!(w, \"<div class='docblock'>{}</div>\", Markdown(dox)));\n+}\n+\n+fn render_impl(w: &mut fmt::Formatter, i: &Impl, link: MethodLink,\n+               render_header: bool) -> fmt::Result {\n+    if render_header {\n+        try!(write!(w, \"<h3 class='impl'><code>impl{} \",\n+                    i.impl_.generics));\n+        if let Some(clean::ImplPolarity::Negative) = i.impl_.polarity {\n+            try!(write!(w, \"!\"));\n+        }\n+        if let Some(ref ty) = i.impl_.trait_ {\n+            try!(write!(w, \"{} for \", *ty));\n+        }\n+        try!(write!(w, \"{}{}</code></h3>\", i.impl_.for_,\n+                    WhereClause(&i.impl_.generics)));\n+        if let Some(ref dox) = i.dox {\n+            try!(write!(w, \"<div class='docblock'>{}</div>\", Markdown(dox)));\n+        }\n     }\n \n     fn doctraititem(w: &mut fmt::Formatter, item: &clean::Item,\n-                    dox: bool, link: MethodLink) -> fmt::Result {\n+                    link: MethodLink) -> fmt::Result {\n         match item.inner {\n             clean::MethodItem(..) | clean::TyMethodItem(..) => {\n-                try!(write!(w, \"<h4 id='method.{}' class='{}'>{}<code>\",\n+                try!(write!(w, \"<h4 id='method.{}' class='{}'><code>\",\n                             *item.name.as_ref().unwrap(),\n-                            shortty(item),\n-                            ConciseStability(&item.stability)));\n+                            shortty(item)));\n                 try!(render_method(w, item, link));\n                 try!(write!(w, \"</code></h4>\\n\"));\n             }\n             clean::TypedefItem(ref tydef) => {\n                 let name = item.name.as_ref().unwrap();\n-                try!(write!(w, \"<h4 id='assoc_type.{}' class='{}'>{}<code>\",\n+                try!(write!(w, \"<h4 id='assoc_type.{}' class='{}'><code>\",\n                             *name,\n-                            shortty(item),\n-                            ConciseStability(&item.stability)));\n+                            shortty(item)));\n                 try!(write!(w, \"type {} = {}\", name, tydef.type_));\n                 try!(write!(w, \"</code></h4>\\n\"));\n             }\n             clean::AssociatedTypeItem(ref bounds, ref default) => {\n                 let name = item.name.as_ref().unwrap();\n-                try!(write!(w, \"<h4 id='assoc_type.{}' class='{}'>{}<code>\",\n+                try!(write!(w, \"<h4 id='assoc_type.{}' class='{}'><code>\",\n                             *name,\n-                            shortty(item),\n-                            ConciseStability(&item.stability)));\n+                            shortty(item)));\n                 try!(assoc_type(w, item, bounds, default));\n                 try!(write!(w, \"</code></h4>\\n\"));\n             }\n             _ => panic!(\"can't make docs for trait item with name {:?}\", item.name)\n         }\n-        match item.doc_value() {\n-            Some(s) if dox => {\n-                try!(write!(w, \"<div class='docblock'>{}</div>\", Markdown(s)));\n-                Ok(())\n-            }\n-            Some(..) | None => Ok(())\n+        if let MethodLink::Anchor = link {\n+            document(w, item)\n+        } else {\n+            Ok(())\n         }\n     }\n \n     try!(write!(w, \"<div class='impl-items'>\"));\n     for trait_item in i.impl_.items.iter() {\n-        try!(doctraititem(w, trait_item, true, link));\n+        try!(doctraititem(w, trait_item, link));\n     }\n \n     fn render_default_methods(w: &mut fmt::Formatter,\n@@ -2271,8 +2350,7 @@ fn render_impl(w: &mut fmt::Formatter, i: &Impl, link: MethodLink)\n                 None => {}\n             }\n \n-            try!(doctraititem(w, trait_item, false,\n-                              MethodLink::GotoSource(did)));\n+            try!(doctraititem(w, trait_item, MethodLink::GotoSource(did)));\n         }\n         Ok(())\n     }\n@@ -2380,7 +2458,7 @@ fn item_primitive(w: &mut fmt::Formatter,\n                   it: &clean::Item,\n                   _p: &clean::PrimitiveType) -> fmt::Result {\n     try!(document(w, it));\n-    render_methods(w, it)\n+    render_methods(w, it.def_id, MethodRender::All)\n }\n \n fn get_basic_keywords() -> &'static str {"}, {"sha": "c94dbc15103321f031d33a8ed0d587484d239530", "filename": "src/librustdoc/html/static/main.css", "status": "modified", "additions": 34, "deletions": 29, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/1014ac44f6271a55249b0488a2ce1cc49deed338/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css", "raw_url": "https://github.com/rust-lang/rust/raw/1014ac44f6271a55249b0488a2ce1cc49deed338/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.css?ref=1014ac44f6271a55249b0488a2ce1cc49deed338", "patch": "@@ -245,6 +245,10 @@ nav.sub {\n .content .highlighted.tymethod { background-color: #c6afb3; }\n .content .highlighted.type { background-color: #c6afb3; }\n \n+.docblock.short p {\n+    display: inline;\n+}\n+\n .docblock.short.nowrap {\n     display: block;\n     overflow: hidden;\n@@ -337,11 +341,16 @@ nav.sub {\n /* Shift \"where ...\" part of method definition down a line */\n .content .method .where { display: block; }\n /* Bit of whitespace to indent it */\n-.content .method .where::before { content: '      '; }\n+.content .method .where::before { content: '  '; }\n \n-.content .methods .docblock { margin-left: 40px; }\n+.content .methods > div { margin-left: 40px; }\n \n-.content .impl-items .docblock { margin-left: 40px; }\n+.content .impl-items .docblock, .content .impl-items .stability {\n+    margin-left: 40px;\n+}\n+.content .impl-items .method, .content .impl-items .type {\n+    margin-left: 20px;\n+}\n \n nav {\n     border-bottom: 1px solid #e0e0e0;\n@@ -468,30 +477,31 @@ a {\n     padding: 20px;\n }\n \n-.stability {\n-    border-left: 6px solid;\n-    padding: 3px 6px;\n-    border-radius: 3px;\n+em.stab.unstable { background: #FFF5D6; border-color: #FFC600; }\n+em.stab.deprecated { background: #F3DFFF; border-color: #7F0087; }\n+em.stab {\n+    display: inline-block;\n+    border-width: 1px;\n+    border-style: solid;\n+    padding: 3px;\n+    margin-bottom: 5px;\n+    font-size: 90%;\n+    font-style: normal;\n }\n-\n-h1 .stability {\n-    text-transform: lowercase;\n-    font-weight: 400;\n-    margin-left: 14px;\n-    padding: 4px 10px;\n+em.stab p {\n+    display: inline;\n }\n \n-.impl-items .stability, .methods .stability {\n-    margin-right: 20px;\n+.module-item .stab {\n+    border-width: 0;\n+    padding: 0;\n+    margin: 0;\n+    background: inherit !important;\n }\n \n-.stability.Deprecated { border-color: #A071A8; color: #82478C; }\n-.stability.Experimental { border-color: #D46D6A; color: #AA3C39; }\n-.stability.Unstable { border-color: #D4B16A; color: #AA8439; }\n-.stability.Stable { border-color: #54A759; color: #2D8632; }\n-.stability.Frozen { border-color: #009431; color: #007726; }\n-.stability.Locked { border-color: #0084B6; color: #00668c; }\n-.stability.Unmarked { border-color: #BBBBBB; }\n+.module-item.unstable {\n+    opacity: 0.65;\n+}\n \n td.summary-column {\n     width: 100%;\n@@ -500,11 +510,6 @@ td.summary-column {\n .summary {\n     padding-right: 0px;\n }\n-.summary.Deprecated { background-color: #A071A8; }\n-.summary.Experimental { background-color: #D46D6A; }\n-.summary.Unstable { background-color: #D4B16A; }\n-.summary.Stable { background-color: #54A759; }\n-.summary.Unmarked { background-color: #BBBBBB; }\n \n :target { background: #FDFFD3; }\n .line-numbers :target { background-color: transparent; }\n@@ -555,9 +560,9 @@ pre.rust { position: relative; }\n .collapse-toggle {\n     font-weight: 300;\n     position: absolute;\n-    left: 13px;\n+    left: -23px;\n     color: #999;\n-    margin-top: 2px;\n+    top: 0;\n }\n \n .toggle-wrapper > .collapse-toggle {"}, {"sha": "0379c04be4d29746acf5329c71653aa4858f9db0", "filename": "src/librustdoc/html/static/main.js", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1014ac44f6271a55249b0488a2ce1cc49deed338/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "raw_url": "https://github.com/rust-lang/rust/raw/1014ac44f6271a55249b0488a2ce1cc49deed338/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fstatic%2Fmain.js?ref=1014ac44f6271a55249b0488a2ce1cc49deed338", "patch": "@@ -802,6 +802,9 @@\n     if (query['gotosrc']) {\n         window.location = $('#src-' + query['gotosrc']).attr('href');\n     }\n+    if (query['gotomacrosrc']) {\n+        window.location = $('.srclink').attr('href');\n+    }\n \n     $(\"#expand-all\").on(\"click\", function() {\n         $(\".docblock\").show();"}, {"sha": "2682bbf4662e042c739abe4b87d4d064ed931330", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1014ac44f6271a55249b0488a2ce1cc49deed338/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1014ac44f6271a55249b0488a2ce1cc49deed338/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=1014ac44f6271a55249b0488a2ce1cc49deed338", "patch": "@@ -91,7 +91,6 @@ pub mod html {\n pub mod markdown;\n pub mod passes;\n pub mod plugins;\n-pub mod stability_summary;\n pub mod visit_ast;\n pub mod test;\n mod flock;"}, {"sha": "3e4f6896ee68db2181121dd351b79ae33ee65ed2", "filename": "src/librustdoc/stability_summary.rs", "status": "removed", "additions": 0, "deletions": 199, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/e9080ec39d9a44eb0773d648b348575b19f655e5/src%2Flibrustdoc%2Fstability_summary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9080ec39d9a44eb0773d648b348575b19f655e5/src%2Flibrustdoc%2Fstability_summary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fstability_summary.rs?ref=e9080ec39d9a44eb0773d648b348575b19f655e5", "patch": "@@ -1,199 +0,0 @@\n-// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! This module crawls a `clean::Crate` and produces a summarization of the\n-//! stability levels within the crate. The summary contains the module\n-//! hierarchy, with item counts for every stability level per module. A parent\n-//! module's count includes its children's.\n-\n-use std::cmp::Ordering;\n-use std::ops::Add;\n-\n-use syntax::attr::{Unstable, Stable};\n-use syntax::ast::Public;\n-\n-use clean::{Crate, Item, ModuleItem, Module, EnumItem, Enum};\n-use clean::{ImplItem, Impl, Trait, TraitItem};\n-use clean::{ExternCrateItem, ImportItem, PrimitiveItem, Stability};\n-\n-use html::render::cache;\n-\n-#[derive(RustcEncodable, RustcDecodable, PartialEq, Eq)]\n-/// The counts for each stability level.\n-#[derive(Copy, Clone)]\n-pub struct Counts {\n-    pub deprecated: u64,\n-    pub unstable: u64,\n-    pub stable: u64,\n-\n-    /// No stability level, inherited or otherwise.\n-    pub unmarked: u64,\n-}\n-\n-impl Add for Counts {\n-    type Output = Counts;\n-\n-    fn add(self, other: Counts) -> Counts {\n-        Counts {\n-            deprecated:   self.deprecated   + other.deprecated,\n-            unstable:     self.unstable     + other.unstable,\n-            stable:       self.stable       + other.stable,\n-            unmarked:     self.unmarked     + other.unmarked,\n-        }\n-    }\n-}\n-\n-impl Counts {\n-    fn zero() -> Counts {\n-        Counts {\n-            deprecated:   0,\n-            unstable:     0,\n-            stable:       0,\n-            unmarked:     0,\n-        }\n-    }\n-\n-    pub fn total(&self) -> u64 {\n-        self.deprecated + self.unstable + self.stable + self.unmarked\n-    }\n-}\n-\n-#[derive(RustcEncodable, RustcDecodable, PartialEq, Eq)]\n-/// A summarized module, which includes total counts and summarized children\n-/// modules.\n-pub struct ModuleSummary {\n-    pub name: String,\n-    pub counts: Counts,\n-    pub submodules: Vec<ModuleSummary>,\n-}\n-\n-impl PartialOrd for ModuleSummary {\n-    fn partial_cmp(&self, other: &ModuleSummary) -> Option<Ordering> {\n-        self.name.partial_cmp(&other.name)\n-    }\n-}\n-\n-impl Ord for ModuleSummary {\n-    fn cmp(&self, other: &ModuleSummary) -> Ordering {\n-        self.name.cmp(&other.name)\n-    }\n-}\n-\n-// is the item considered publicly visible?\n-fn visible(item: &Item) -> bool {\n-    match item.inner {\n-        ImplItem(_) => true,\n-        _ => item.visibility == Some(Public)\n-    }\n-}\n-\n-fn count_stability(stab: Option<&Stability>) -> Counts {\n-    match stab {\n-        None            => Counts { unmarked: 1,     .. Counts::zero() },\n-        Some(ref stab) => {\n-            if !stab.deprecated_since.is_empty() {\n-                return Counts { deprecated: 1, .. Counts::zero() };\n-            }\n-            match stab.level {\n-                Unstable    => Counts { unstable: 1,     .. Counts::zero() },\n-                Stable      => Counts { stable: 1,       .. Counts::zero() },\n-            }\n-        }\n-    }\n-}\n-\n-fn summarize_methods(item: &Item) -> Counts {\n-    match cache().impls.get(&item.def_id) {\n-        Some(v) => {\n-            v.iter().map(|i| {\n-                let count = count_stability(i.stability.as_ref());\n-                if i.impl_.trait_.is_none() {\n-                    count + i.impl_.items.iter()\n-                        .map(|ti| summarize_item(ti).0)\n-                        .fold(Counts::zero(), |acc, c| acc + c)\n-                } else {\n-                    count\n-                }\n-            }).fold(Counts::zero(), |acc, c| acc + c)\n-        },\n-        None => {\n-            Counts::zero()\n-        },\n-    }\n-}\n-\n-\n-// Produce the summary for an arbitrary item. If the item is a module, include a\n-// module summary. The counts for items with nested items (e.g. modules, traits,\n-// impls) include all children counts.\n-fn summarize_item(item: &Item) -> (Counts, Option<ModuleSummary>) {\n-    let item_counts = count_stability(item.stability.as_ref()) + summarize_methods(item);\n-\n-    // Count this item's children, if any. Note that a trait impl is\n-    // considered to have no children.\n-    match item.inner {\n-        // Require explicit `pub` to be visible\n-        ImplItem(Impl { ref items, trait_: None, .. }) => {\n-            let subcounts = items.iter().filter(|i| visible(*i))\n-                                        .map(summarize_item)\n-                                        .map(|s| s.0)\n-                                        .fold(Counts::zero(), |acc, x| acc + x);\n-            (subcounts, None)\n-        }\n-        // `pub` automatically\n-        EnumItem(Enum { variants: ref subitems, .. }) => {\n-            let subcounts = subitems.iter().map(summarize_item)\n-                                           .map(|s| s.0)\n-                                           .fold(Counts::zero(), |acc, x| acc + x);\n-            (item_counts + subcounts, None)\n-        }\n-        TraitItem(Trait { ref items, .. }) => {\n-            let subcounts = items.iter().map(summarize_item)\n-                                        .map(|s| s.0)\n-                                        .fold(Counts::zero(), |acc, x| acc + x);\n-            (item_counts + subcounts, None)\n-        }\n-        ModuleItem(Module { ref items, .. }) => {\n-            let mut counts = item_counts;\n-            let mut submodules = Vec::new();\n-\n-            for (subcounts, submodule) in items.iter().filter(|i| visible(*i))\n-                                                      .map(summarize_item) {\n-                counts = counts + subcounts;\n-                submodule.map(|m| submodules.push(m));\n-            }\n-            submodules.sort();\n-\n-            (counts, Some(ModuleSummary {\n-                name: item.name.as_ref().map_or(\"\".to_string(), |n| n.clone()),\n-                counts: counts,\n-                submodules: submodules,\n-            }))\n-        }\n-        // no stability information for the following items:\n-        ExternCrateItem(..) | ImportItem(_) |\n-        PrimitiveItem(_) => (Counts::zero(), None),\n-        _ => (item_counts, None)\n-    }\n-}\n-\n-/// Summarizes the stability levels in a crate.\n-pub fn build(krate: &Crate) -> ModuleSummary {\n-    match krate.module {\n-        None => ModuleSummary {\n-            name: krate.name.clone(),\n-            counts: Counts::zero(),\n-            submodules: Vec::new(),\n-        },\n-        Some(ref item) => ModuleSummary {\n-            name: krate.name.clone(), .. summarize_item(item).1.unwrap()\n-        }\n-    }\n-}"}, {"sha": "bbe0a6f267538e9524e387dc55306ebf30f388da", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/1014ac44f6271a55249b0488a2ce1cc49deed338/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1014ac44f6271a55249b0488a2ce1cc49deed338/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=1014ac44f6271a55249b0488a2ce1cc49deed338", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::cell::RefCell;\n+use std::cell::{RefCell, Cell};\n use std::collections::{HashSet, HashMap};\n use std::dynamic_lib::DynamicLibrary;\n use std::env;\n@@ -92,6 +92,7 @@ pub fn run(input: &str,\n         external_typarams: RefCell::new(None),\n         inlined: RefCell::new(None),\n         populated_crate_impls: RefCell::new(HashSet::new()),\n+        deref_trait_did: Cell::new(None),\n     };\n \n     let mut v = RustdocVisitor::new(&ctx, None);"}, {"sha": "4ad693578ccdc312e3aed9aa689614abe19d0e68", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1014ac44f6271a55249b0488a2ce1cc49deed338/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1014ac44f6271a55249b0488a2ce1cc49deed338/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=1014ac44f6271a55249b0488a2ce1cc49deed338", "patch": "@@ -398,6 +398,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             name: def.ident,\n             whence: def.span,\n             stab: self.stability(def.id),\n+            imported_from: def.imported_from,\n         }\n     }\n }"}, {"sha": "435f0176162b89db3968973dae1f18e37324bf84", "filename": "src/test/auxiliary/issue-19190-3.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/1014ac44f6271a55249b0488a2ce1cc49deed338/src%2Ftest%2Fauxiliary%2Fissue-19190-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1014ac44f6271a55249b0488a2ce1cc49deed338/src%2Ftest%2Fauxiliary%2Fissue-19190-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fissue-19190-3.rs?ref=1014ac44f6271a55249b0488a2ce1cc49deed338", "patch": "@@ -0,0 +1,30 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::ops::Deref;\n+\n+pub struct Foo;\n+\n+impl Deref for Foo {\n+    type Target = i32;\n+    fn deref(&self) -> &i32 { loop {} }\n+}\n+\n+pub struct Bar;\n+pub struct Baz;\n+\n+impl Baz {\n+    pub fn baz(&self) {}\n+}\n+\n+impl Deref for Bar {\n+    type Target = Baz;\n+    fn deref(&self) -> &Baz { loop {} }\n+}"}, {"sha": "b84ec6d616636b211adcbf790921e78cb0f9e0d6", "filename": "src/test/rustdoc/issue-19190-2.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1014ac44f6271a55249b0488a2ce1cc49deed338/src%2Ftest%2Frustdoc%2Fissue-19190-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1014ac44f6271a55249b0488a2ce1cc49deed338/src%2Ftest%2Frustdoc%2Fissue-19190-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-19190-2.rs?ref=1014ac44f6271a55249b0488a2ce1cc49deed338", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::ops::Deref;\n+\n+pub struct Bar;\n+\n+impl Deref for Bar {\n+    type Target = i32;\n+    fn deref(&self) -> &i32 { loop {} }\n+}\n+\n+// @has issue_19190_2/struct.Bar.html\n+// @has - '//*[@id=\"method.count_ones\"]' 'fn count_ones(self) -> u32'\n+"}, {"sha": "c315ea26d264291f3ec4a8641c1dc3797d2afc04", "filename": "src/test/rustdoc/issue-19190-3.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/1014ac44f6271a55249b0488a2ce1cc49deed338/src%2Ftest%2Frustdoc%2Fissue-19190-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1014ac44f6271a55249b0488a2ce1cc49deed338/src%2Ftest%2Frustdoc%2Fissue-19190-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-19190-3.rs?ref=1014ac44f6271a55249b0488a2ce1cc49deed338", "patch": "@@ -0,0 +1,35 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:issue-19190-3.rs\n+// ignore-android\n+\n+extern crate issue_19190_3;\n+\n+use std::ops::Deref;\n+use issue_19190_3::Baz;\n+\n+// @has issue_19190_3/struct.Foo.html\n+// @has - '//*[@id=\"method.count_ones\"]' 'fn count_ones(self) -> u32'\n+pub use issue_19190_3::Foo;\n+\n+// @has issue_19190_3/struct.Bar.html\n+// @has - '//*[@id=\"method.baz\"]' 'fn baz(&self)'\n+pub use issue_19190_3::Bar;\n+\n+// @has issue_19190_3/struct.MyBar.html\n+// @has - '//*[@id=\"method.baz\"]' 'fn baz(&self)'\n+pub struct MyBar;\n+\n+impl Deref for MyBar {\n+    type Target = Baz;\n+    fn deref(&self) -> &Baz { loop {} }\n+}\n+"}, {"sha": "f011a3e64a6be0f6ba8023ac2f8dc54b29a87eaf", "filename": "src/test/rustdoc/issue-19190.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/1014ac44f6271a55249b0488a2ce1cc49deed338/src%2Ftest%2Frustdoc%2Fissue-19190.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1014ac44f6271a55249b0488a2ce1cc49deed338/src%2Ftest%2Frustdoc%2Fissue-19190.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fissue-19190.rs?ref=1014ac44f6271a55249b0488a2ce1cc49deed338", "patch": "@@ -0,0 +1,26 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::ops::Deref;\n+\n+pub struct Foo;\n+pub struct Bar;\n+\n+impl Foo {\n+    pub fn foo(&self) {}\n+}\n+\n+impl Deref for Bar {\n+    type Target = Foo;\n+    fn deref(&self) -> &Foo { loop {} }\n+}\n+\n+// @has issue_19190/struct.Bar.html\n+// @has - '//*[@id=\"method.foo\"]' 'fn foo(&self)'"}]}