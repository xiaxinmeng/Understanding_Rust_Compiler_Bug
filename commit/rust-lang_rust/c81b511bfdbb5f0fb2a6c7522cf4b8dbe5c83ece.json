{"sha": "c81b511bfdbb5f0fb2a6c7522cf4b8dbe5c83ece", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM4MWI1MTFiZmRiYjVmMGZiMmE2Yzc1MjJjZjRiOGRiZTVjODNlY2U=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-05-23T07:42:33Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2014-05-25T08:17:57Z"}, "message": "rustdoc: Start inlining structs across crates", "tree": {"sha": "89554fd6763f7b6abbbaab416131ddda1698e8f2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/89554fd6763f7b6abbbaab416131ddda1698e8f2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c81b511bfdbb5f0fb2a6c7522cf4b8dbe5c83ece", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c81b511bfdbb5f0fb2a6c7522cf4b8dbe5c83ece", "html_url": "https://github.com/rust-lang/rust/commit/c81b511bfdbb5f0fb2a6c7522cf4b8dbe5c83ece", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c81b511bfdbb5f0fb2a6c7522cf4b8dbe5c83ece/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8b8e70ba1d47ca76217980f0c4c6f55b60a06e06", "url": "https://api.github.com/repos/rust-lang/rust/commits/8b8e70ba1d47ca76217980f0c4c6f55b60a06e06", "html_url": "https://github.com/rust-lang/rust/commit/8b8e70ba1d47ca76217980f0c4c6f55b60a06e06"}], "stats": {"total": 226, "additions": 192, "deletions": 34}, "files": [{"sha": "5497ca7b135a0e55d75ff692165389ac24a93e3e", "filename": "src/librustdoc/clean.rs", "status": "modified", "additions": 186, "deletions": 27, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/c81b511bfdbb5f0fb2a6c7522cf4b8dbe5c83ece/src%2Flibrustdoc%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c81b511bfdbb5f0fb2a6c7522cf4b8dbe5c83ece/src%2Flibrustdoc%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean.rs?ref=c81b511bfdbb5f0fb2a6c7522cf4b8dbe5c83ece", "patch": "@@ -27,7 +27,7 @@ use rustc::metadata::csearch;\n use rustc::metadata::decoder;\n use rustc::middle::ty;\n \n-use std::string::String;\n+use std::rc::Rc;\n \n use core;\n use doctree;\n@@ -53,6 +53,12 @@ impl<T: Clean<U>, U> Clean<U> for @T {\n     }\n }\n \n+impl<T: Clean<U>, U> Clean<U> for Rc<T> {\n+    fn clean(&self) -> U {\n+        (**self).clean()\n+    }\n+}\n+\n impl<T: Clean<U>, U> Clean<Option<U>> for Option<T> {\n     fn clean(&self) -> Option<U> {\n         match self {\n@@ -337,6 +343,14 @@ impl attr::AttrMetaMethods for Attribute {\n         None\n     }\n }\n+impl<'a> attr::AttrMetaMethods for &'a Attribute {\n+    fn name(&self) -> InternedString { (**self).name() }\n+    fn value_str(&self) -> Option<InternedString> { (**self).value_str() }\n+    fn meta_item_list<'a>(&'a self) -> Option<&'a [@ast::MetaItem]> { None }\n+    fn name_str_pair(&self) -> Option<(InternedString, InternedString)> {\n+        None\n+    }\n+}\n \n #[deriving(Clone, Encodable, Decodable)]\n pub struct TyParam {\n@@ -859,10 +873,7 @@ impl Clean<TraitMethod> for ty::Method {\n             visibility: Some(ast::Inherited),\n             def_id: self.def_id,\n             attrs: load_attrs(tcx, self.def_id),\n-            source: Span {\n-                filename: \"\".to_strbuf(),\n-                loline: 0, locol: 0, hiline: 0, hicol: 0,\n-            },\n+            source: Span::empty(),\n             inner: TyMethodItem(TyMethod {\n                 fn_style: self.fty.fn_style,\n                 generics: self.generics.clean(),\n@@ -1070,6 +1081,31 @@ impl Clean<Item> for ast::StructField {\n     }\n }\n \n+impl Clean<Item> for ty::field_ty {\n+    fn clean(&self) -> Item {\n+        use syntax::parse::token::special_idents::unnamed_field;\n+        let name = if self.name == unnamed_field.name {\n+            None\n+        } else {\n+            Some(self.name)\n+        };\n+        let cx = super::ctxtkey.get().unwrap();\n+        let tcx = match cx.maybe_typed {\n+            core::Typed(ref tycx) => tycx,\n+            core::NotTyped(_) => fail!(),\n+        };\n+        let ty = ty::lookup_item_type(tcx, self.id);\n+        Item {\n+            name: name.clean(),\n+            attrs: load_attrs(tcx, self.id),\n+            source: Span::empty(),\n+            visibility: Some(self.vis),\n+            def_id: self.id,\n+            inner: StructFieldItem(TypedStructField(ty.ty.clean())),\n+        }\n+    }\n+}\n+\n pub type Visibility = ast::Visibility;\n \n impl Clean<Option<Visibility>> for ast::Visibility {\n@@ -1199,6 +1235,16 @@ pub struct Span {\n     pub hicol: uint,\n }\n \n+impl Span {\n+    fn empty() -> Span {\n+        Span {\n+            filename: \"\".to_strbuf(),\n+            loline: 0, locol: 0,\n+            hiline: 0, hicol: 0,\n+        }\n+    }\n+}\n+\n impl Clean<Span> for syntax::codemap::Span {\n     fn clean(&self) -> Span {\n         let ctxt = super::ctxtkey.get().unwrap();\n@@ -1270,6 +1316,12 @@ impl Clean<String> for ast::Ident {\n     }\n }\n \n+impl Clean<StrBuf> for ast::Name {\n+    fn clean(&self) -> StrBuf {\n+        token::get_name(*self).get().to_strbuf()\n+    }\n+}\n+\n #[deriving(Clone, Encodable, Decodable)]\n pub struct Typedef {\n     pub type_: Type,\n@@ -1366,19 +1418,14 @@ pub struct Impl {\n     pub derived: bool,\n }\n \n+fn detect_derived<M: AttrMetaMethods>(attrs: &[M]) -> bool {\n+    attrs.iter().any(|attr| {\n+        attr.name().get() == \"automatically_derived\"\n+    })\n+}\n+\n impl Clean<Item> for doctree::Impl {\n     fn clean(&self) -> Item {\n-        let mut derived = false;\n-        for attr in self.attrs.iter() {\n-            match attr.node.value.node {\n-                ast::MetaWord(ref s) => {\n-                    if s.get() == \"automatically_derived\" {\n-                        derived = true;\n-                    }\n-                }\n-                _ => {}\n-            }\n-        }\n         Item {\n             name: None,\n             attrs: self.attrs.clean(),\n@@ -1390,7 +1437,7 @@ impl Clean<Item> for doctree::Impl {\n                 trait_: self.trait_.clean(),\n                 for_: self.for_.clean(),\n                 methods: self.methods.clean(),\n-                derived: derived,\n+                derived: detect_derived(self.attrs.as_slice()),\n             }),\n         }\n     }\n@@ -1427,7 +1474,9 @@ impl Clean<Vec<Item>> for ast::ViewItem {\n                     ast::ViewPathList(ref a, ref list, ref b) => {\n                         let remaining = list.iter().filter(|path| {\n                             match try_inline(path.node.id) {\n-                                Some(item) => { ret.push(item); false }\n+                                Some(items) => {\n+                                    ret.extend(items.move_iter()); false\n+                                }\n                                 None => true,\n                             }\n                         }).map(|a| a.clone()).collect::<Vec<ast::PathListIdent>>();\n@@ -1441,7 +1490,7 @@ impl Clean<Vec<Item>> for ast::ViewItem {\n                     }\n                     ast::ViewPathSimple(_, _, id) => {\n                         match try_inline(id) {\n-                            Some(item) => ret.push(item),\n+                            Some(items) => ret.extend(items.move_iter()),\n                             None => ret.push(convert(&self.node)),\n                         }\n                     }\n@@ -1453,7 +1502,7 @@ impl Clean<Vec<Item>> for ast::ViewItem {\n     }\n }\n \n-fn try_inline(id: ast::NodeId) -> Option<Item> {\n+fn try_inline(id: ast::NodeId) -> Option<Vec<Item>> {\n     let cx = super::ctxtkey.get().unwrap();\n     let tcx = match cx.maybe_typed {\n         core::Typed(ref tycx) => tycx,\n@@ -1465,23 +1514,28 @@ fn try_inline(id: ast::NodeId) -> Option<Item> {\n     };\n     let did = ast_util::def_id_of_def(def);\n     if ast_util::is_local(did) { return None }\n+\n+    let mut ret = Vec::new();\n     let inner = match def {\n         ast::DefTrait(did) => TraitItem(build_external_trait(tcx, did)),\n         ast::DefFn(did, style) =>\n             FunctionItem(build_external_function(tcx, did, style)),\n+        ast::DefStruct(did) => {\n+            ret.extend(build_impls(tcx, did).move_iter());\n+            StructItem(build_struct(tcx, did))\n+        }\n         _ => return None,\n     };\n     let fqn = csearch::get_item_path(tcx, did);\n-    Some(Item {\n-        source: Span {\n-            filename: \"\".to_strbuf(), loline: 0, locol: 0, hiline: 0, hicol: 0,\n-        },\n+    ret.push(Item {\n+        source: Span::empty(),\n         name: Some(fqn.last().unwrap().to_str().to_strbuf()),\n         attrs: load_attrs(tcx, did),\n         inner: inner,\n         visibility: Some(ast::Public),\n         def_id: did,\n-    })\n+    });\n+    Some(ret)\n }\n \n fn load_attrs(tcx: &ty::ctxt, did: ast::DefId) -> Vec<Attribute> {\n@@ -1726,7 +1780,7 @@ fn register_def(cx: &core::DocContext, def: ast::Def) -> ast::DefId {\n }\n \n fn build_external_trait(tcx: &ty::ctxt, did: ast::DefId) -> Trait {\n-    let def = csearch::get_trait_def(tcx, did);\n+    let def = ty::lookup_trait_def(tcx, did);\n     let methods = ty::trait_methods(tcx, did);\n     Trait {\n         generics: def.generics.clean(),\n@@ -1738,7 +1792,7 @@ fn build_external_trait(tcx: &ty::ctxt, did: ast::DefId) -> Trait {\n fn build_external_function(tcx: &ty::ctxt,\n                            did: ast::DefId,\n                            style: ast::FnStyle) -> Function {\n-    let t = csearch::get_type(tcx, did);\n+    let t = ty::lookup_item_type(tcx, did);\n     Function {\n         decl: match ty::get(t.ty).sty {\n             ty::ty_bare_fn(ref f) => f.sig.clean(),\n@@ -1749,6 +1803,111 @@ fn build_external_function(tcx: &ty::ctxt,\n     }\n }\n \n+fn build_struct(tcx: &ty::ctxt, did: ast::DefId) -> Struct {\n+    use syntax::parse::token::special_idents::unnamed_field;\n+\n+    let t = ty::lookup_item_type(tcx, did);\n+    let fields = ty::lookup_struct_fields(tcx, did);\n+\n+    Struct {\n+        struct_type: match fields.as_slice() {\n+            [] => doctree::Unit,\n+            [ref f] if f.name == unnamed_field.name => doctree::Newtype,\n+            [ref f, ..] if f.name == unnamed_field.name => doctree::Tuple,\n+            _ => doctree::Plain,\n+        },\n+        generics: t.generics.clean(),\n+        fields: fields.iter().map(|f| f.clean()).collect(),\n+        fields_stripped: false,\n+    }\n+}\n+\n+fn build_impls(tcx: &ty::ctxt,\n+               did: ast::DefId) -> Vec<Item> {\n+    ty::populate_implementations_for_type_if_necessary(tcx, did);\n+    let mut impls = Vec::new();\n+\n+    match tcx.inherent_impls.borrow().find(&did) {\n+        None => {}\n+        Some(i) => {\n+            impls.extend(i.borrow().iter().map(|&did| { build_impl(tcx, did) }));\n+        }\n+    }\n+\n+    // csearch::each_impl(&tcx.sess.cstore, did.krate, |imp| {\n+    //     // if imp.krate\n+    //     let t = ty::lookup_item_type(tcx, imp);\n+    //     println!(\"{}\", ::rustc::util::ppaux::ty_to_str(tcx, t.ty));\n+    //     match ty::get(t.ty).sty {\n+    //         ty::ty_struct(tdid, _) |\n+    //         ty::ty_enum(tdid, _) if tdid == did => {\n+    //             impls.push(build_impl(tcx, imp));\n+    //         }\n+    //         _ => {}\n+    //     }\n+    // });\n+    // for (k, v) in tcx.trait_impls.borrow().iter() {\n+    //     if k.krate != did.krate { continue }\n+    //     for imp in v.borrow().iter() {\n+    //         if imp.krate != did.krate { continue }\n+    //         let t = ty::lookup_item_type(tcx, *imp);\n+    //         println!(\"{}\", ::rustc::util::ppaux::ty_to_str(tcx, t.ty));\n+    //         match ty::get(t.ty).sty {\n+    //             ty::ty_struct(tdid, _) |\n+    //             ty::ty_enum(tdid, _) if tdid == did => {\n+    //                 impls.push(build_impl(tcx, *imp));\n+    //             }\n+    //             _ => {}\n+    //         }\n+    //     }\n+    // }\n+\n+    impls\n+}\n+\n+fn build_impl(tcx: &ty::ctxt, did: ast::DefId) -> Item {\n+    let associated_trait = csearch::get_impl_trait(tcx, did);\n+    let attrs = load_attrs(tcx, did);\n+    let ty = ty::lookup_item_type(tcx, did);\n+    let methods = tcx.impl_methods.borrow().get(&did).iter().map(|did| {\n+        let mut item = match ty::method(tcx, *did).clean() {\n+            Provided(item) => item,\n+            Required(item) => item,\n+        };\n+        item.inner = match item.inner.clone() {\n+            TyMethodItem(TyMethod { fn_style, decl, self_, generics }) => {\n+                MethodItem(Method {\n+                    fn_style: fn_style,\n+                    decl: decl,\n+                    self_: self_,\n+                    generics: generics,\n+                })\n+            }\n+            _ => fail!(\"not a tymethod\"),\n+        };\n+        item\n+    }).collect();\n+    Item {\n+        inner: ImplItem(Impl {\n+            derived: detect_derived(attrs.as_slice()),\n+            trait_: associated_trait.clean().map(|bound| {\n+                match bound {\n+                    TraitBound(ty) => ty,\n+                    RegionBound => fail!(),\n+                }\n+            }),\n+            for_: ty.ty.clean(),\n+            generics: ty.generics.clean(),\n+            methods: methods,\n+        }),\n+        source: Span::empty(),\n+        name: None,\n+        attrs: attrs,\n+        visibility: Some(ast::Inherited),\n+        def_id: did,\n+    }\n+}\n+\n fn resolve_use_source(path: Path, id: ast::NodeId) -> ImportSource {\n     ImportSource {\n         path: path,"}, {"sha": "93bd5249a2f71459a074c3e0ccbfa43e71482575", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c81b511bfdbb5f0fb2a6c7522cf4b8dbe5c83ece/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c81b511bfdbb5f0fb2a6c7522cf4b8dbe5c83ece/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=c81b511bfdbb5f0fb2a6c7522cf4b8dbe5c83ece", "patch": "@@ -132,7 +132,7 @@ pub struct Cache {\n     ///\n     /// The values of the map are a list of implementations and documentation\n     /// found on that implementation.\n-    pub impls: HashMap<ast::NodeId, Vec<(clean::Impl, Option<String>)>>,\n+    pub impls: HashMap<ast::DefId, Vec<(clean::Impl, Option<String>)>>,\n \n     /// Maintains a mapping of local crate node ids to the fully qualified name\n     /// and \"short type description\" of that node. This is used when generating\n@@ -837,10 +837,8 @@ impl DocFolder for Cache {\n                 match item {\n                     clean::Item{ attrs, inner: clean::ImplItem(i), .. } => {\n                         match i.for_ {\n-                            clean::ResolvedPath { did, .. }\n-                                if ast_util::is_local(did) =>\n-                            {\n-                                let v = self.impls.find_or_insert_with(did.node, |_| {\n+                            clean::ResolvedPath { did, .. } => {\n+                                let v = self.impls.find_or_insert_with(did, |_| {\n                                     Vec::new()\n                                 });\n                                 // extract relevant documentation for this impl\n@@ -1664,7 +1662,7 @@ fn render_struct(w: &mut fmt::Formatter, it: &clean::Item,\n }\n \n fn render_methods(w: &mut fmt::Formatter, it: &clean::Item) -> fmt::Result {\n-    match cache_key.get().unwrap().impls.find(&it.def_id.node) {\n+    match cache_key.get().unwrap().impls.find(&it.def_id) {\n         Some(v) => {\n             let mut non_trait = v.iter().filter(|p| {\n                 p.ref0().trait_.is_none()"}, {"sha": "390f81642e6b2092cbb045a238a9b5e6fe2f37f5", "filename": "src/librustdoc/passes.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c81b511bfdbb5f0fb2a6c7522cf4b8dbe5c83ece/src%2Flibrustdoc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c81b511bfdbb5f0fb2a6c7522cf4b8dbe5c83ece/src%2Flibrustdoc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses.rs?ref=c81b511bfdbb5f0fb2a6c7522cf4b8dbe5c83ece", "patch": "@@ -152,7 +152,8 @@ impl<'a> fold::DocFolder for Stripper<'a> {\n             clean::ImplItem(clean::Impl{\n                 for_: clean::ResolvedPath{ did, .. }, ..\n             }) => {\n-                if !self.exported_items.contains(&did.node) {\n+                if ast_util::is_local(did) &&\n+                   !self.exported_items.contains(&did.node) {\n                     return None;\n                 }\n             }"}]}