{"sha": "724b6ed751a0070d5c0904895e25578ca97f3fc7", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcyNGI2ZWQ3NTFhMDA3MGQ1YzA5MDQ4OTVlMjU1NzhjYTk3ZjNmYzc=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-05-15T17:20:26Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-05-15T17:23:27Z"}, "message": "Permit token trees, identifiers, and blocks to be following by\nsequences.\n\nFixes #25436.", "tree": {"sha": "abc4d361686230ee62d0ca51c1413b525bd70976", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/abc4d361686230ee62d0ca51c1413b525bd70976"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/724b6ed751a0070d5c0904895e25578ca97f3fc7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/724b6ed751a0070d5c0904895e25578ca97f3fc7", "html_url": "https://github.com/rust-lang/rust/commit/724b6ed751a0070d5c0904895e25578ca97f3fc7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/724b6ed751a0070d5c0904895e25578ca97f3fc7/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7ebaf1c5c6dcff22d554bc0169a7416f1305c8c4", "url": "https://api.github.com/repos/rust-lang/rust/commits/7ebaf1c5c6dcff22d554bc0169a7416f1305c8c4", "html_url": "https://github.com/rust-lang/rust/commit/7ebaf1c5c6dcff22d554bc0169a7416f1305c8c4"}], "stats": {"total": 189, "additions": 155, "deletions": 34}, "files": [{"sha": "febfc7a97fe3dc8c1f389febfbb5d8e4462c5488", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 78, "deletions": 34, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/724b6ed751a0070d5c0904895e25578ca97f3fc7/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/724b6ed751a0070d5c0904895e25578ca97f3fc7/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=724b6ed751a0070d5c0904895e25578ca97f3fc7", "patch": "@@ -325,42 +325,55 @@ fn check_matcher<'a, I>(cx: &mut ExtCtxt, matcher: I, follow: &Token)\n         last = match *token {\n             TtToken(sp, MatchNt(ref name, ref frag_spec, _, _)) => {\n                 // ii. If T is a simple NT, look ahead to the next token T' in\n-                // M.\n-                let next_token = match tokens.peek() {\n-                    // If T' closes a complex NT, replace T' with F\n-                    Some(&&TtToken(_, CloseDelim(_))) => follow.clone(),\n-                    Some(&&TtToken(_, ref tok)) => tok.clone(),\n-                    Some(&&TtSequence(sp, _)) => {\n-                        cx.span_err(sp,\n-                                    &format!(\"`${0}:{1}` is followed by a \\\n-                                              sequence repetition, which is not \\\n-                                              allowed for `{1}` fragments\",\n-                                             name.as_str(), frag_spec.as_str())\n+                // M. If T' is in the set FOLLOW(NT), continue. Else; reject.\n+                if can_be_followed_by_any(frag_spec.as_str()) {\n+                    continue\n+                } else {\n+                    let next_token = match tokens.peek() {\n+                        // If T' closes a complex NT, replace T' with F\n+                        Some(&&TtToken(_, CloseDelim(_))) => follow.clone(),\n+                        Some(&&TtToken(_, ref tok)) => tok.clone(),\n+                        Some(&&TtSequence(sp, _)) => {\n+                            // Be conservative around sequences: to be\n+                            // more specific, we would need to\n+                            // consider FIRST sets, but also the\n+                            // possibility that the sequence occurred\n+                            // zero times (in which case we need to\n+                            // look at the token that follows the\n+                            // sequence, which may itself a sequence,\n+                            // and so on).\n+                            cx.span_err(sp,\n+                                        &format!(\"`${0}:{1}` is followed by a \\\n+                                                  sequence repetition, which is not \\\n+                                                  allowed for `{1}` fragments\",\n+                                                 name.as_str(), frag_spec.as_str())\n                                         );\n-                        Eof\n-                    },\n-                    // die next iteration\n-                    Some(&&TtDelimited(_, ref delim)) => delim.close_token(),\n-                    // else, we're at the end of the macro or sequence\n-                    None => follow.clone()\n-                };\n-\n-                let tok = if let TtToken(_, ref tok) = *token { tok } else { unreachable!() };\n-                // If T' is in the set FOLLOW(NT), continue. Else, reject.\n-                match (&next_token, is_in_follow(cx, &next_token, frag_spec.as_str())) {\n-                    (_, Err(msg)) => {\n-                        cx.span_err(sp, &msg);\n-                        continue\n+                            Eof\n+                        },\n+                        // die next iteration\n+                        Some(&&TtDelimited(_, ref delim)) => delim.close_token(),\n+                        // else, we're at the end of the macro or sequence\n+                        None => follow.clone()\n+                    };\n+\n+                    let tok = if let TtToken(_, ref tok) = *token { tok } else { unreachable!() };\n+\n+                    // If T' is in the set FOLLOW(NT), continue. Else, reject.\n+                    match (&next_token, is_in_follow(cx, &next_token, frag_spec.as_str())) {\n+                        (_, Err(msg)) => {\n+                            cx.span_err(sp, &msg);\n+                            continue\n+                        }\n+                        (&Eof, _) => return Some((sp, tok.clone())),\n+                        (_, Ok(true)) => continue,\n+                        (next, Ok(false)) => {\n+                            cx.span_err(sp, &format!(\"`${0}:{1}` is followed by `{2}`, which \\\n+                                                      is not allowed for `{1}` fragments\",\n+                                                     name.as_str(), frag_spec.as_str(),\n+                                                     token_to_string(next)));\n+                            continue\n+                        },\n                     }\n-                    (&Eof, _) => return Some((sp, tok.clone())),\n-                    (_, Ok(true)) => continue,\n-                    (next, Ok(false)) => {\n-                        cx.span_err(sp, &format!(\"`${0}:{1}` is followed by `{2}`, which \\\n-                                                  is not allowed for `{1}` fragments\",\n-                                                 name.as_str(), frag_spec.as_str(),\n-                                                 token_to_string(next)));\n-                        continue\n-                    },\n                 }\n             },\n             TtSequence(sp, ref seq) => {\n@@ -427,8 +440,39 @@ fn check_matcher<'a, I>(cx: &mut ExtCtxt, matcher: I, follow: &Token)\n     last\n }\n \n+/// True if a fragment of type `frag` can be followed by any sort of\n+/// token.  We use this (among other things) as a useful approximation\n+/// for when `frag` can be followed by a repetition like `$(...)*` or\n+/// `$(...)+`. In general, these can be a bit tricky to reason about,\n+/// so we adopt a conservative position that says that any fragment\n+/// specifier which consumes at most one token tree can be followed by\n+/// a fragment specifier (indeed, these fragments can be followed by\n+/// ANYTHING without fear of future compatibility hazards).\n+fn can_be_followed_by_any(frag: &str) -> bool {\n+    match frag {\n+        \"item\" |  // always terminated by `}` or `;`\n+        \"block\" | // exactly one token tree\n+        \"ident\" | // exactly one token tree\n+        \"meta\" |  // exactly one token tree\n+        \"tt\" =>    // exactly one token tree\n+            true,\n+\n+        _ =>\n+            false,\n+    }\n+}\n+\n+/// True if `frag` can legally be followed by the token `tok`. For\n+/// fragments that can consume an unbounded numbe of tokens, `tok`\n+/// must be within a well-defined follow set. This is intended to\n+/// guarantee future compatibility: for example, without this rule, if\n+/// we expanded `expr` to include a new binary operator, we might\n+/// break macros that were relying on that binary operator as a\n+/// separator.\n fn is_in_follow(_: &ExtCtxt, tok: &Token, frag: &str) -> Result<bool, String> {\n     if let &CloseDelim(_) = tok {\n+        // closing a token tree can never be matched by any fragment;\n+        // iow, we always require that `(` and `)` match, etc.\n         Ok(true)\n     } else {\n         match frag {"}, {"sha": "0ee2221bbc14b9658c9f5010c94be25821b54f7b", "filename": "src/test/compile-fail/macro-followed-by-seq-bad.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/724b6ed751a0070d5c0904895e25578ca97f3fc7/src%2Ftest%2Fcompile-fail%2Fmacro-followed-by-seq-bad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/724b6ed751a0070d5c0904895e25578ca97f3fc7/src%2Ftest%2Fcompile-fail%2Fmacro-followed-by-seq-bad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-followed-by-seq-bad.rs?ref=724b6ed751a0070d5c0904895e25578ca97f3fc7", "patch": "@@ -0,0 +1,19 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for issue #25436: check that things which can be\n+// followed by any token also permit X* to come afterwards.\n+\n+macro_rules! foo {\n+  ( $a:expr $($b:tt)* ) => { }; //~ ERROR not allowed for `expr` fragments\n+  ( $a:ty $($b:tt)* ) => { };   //~ ERROR not allowed for `ty` fragments\n+}\n+\n+fn main() { }"}, {"sha": "15224930b8465bf9662ad167c8719b65ebdf1555", "filename": "src/test/run-pass/macro-followed-by-seq.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/724b6ed751a0070d5c0904895e25578ca97f3fc7/src%2Ftest%2Frun-pass%2Fmacro-followed-by-seq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/724b6ed751a0070d5c0904895e25578ca97f3fc7/src%2Ftest%2Frun-pass%2Fmacro-followed-by-seq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-followed-by-seq.rs?ref=724b6ed751a0070d5c0904895e25578ca97f3fc7", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for issue #25436: check that things which can be\n+// followed by any token also permit X* to come afterwards.\n+\n+macro_rules! foo {\n+  ( $a:tt $($b:tt)* ) => { };\n+  ( $a:ident $($b:tt)* ) => { };\n+  ( $a:item $($b:tt)* ) => { };\n+  ( $a:block $($b:tt)* ) => { };\n+  ( $a:meta $($b:tt)* ) => { }\n+}\n+\n+fn main() { }"}, {"sha": "cdb1f86aea50b234d72199a47aecfa7e9b56cf2e", "filename": "src/test/run-pass/macro-tt-followed-by-seq.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/724b6ed751a0070d5c0904895e25578ca97f3fc7/src%2Ftest%2Frun-pass%2Fmacro-tt-followed-by-seq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/724b6ed751a0070d5c0904895e25578ca97f3fc7/src%2Ftest%2Frun-pass%2Fmacro-tt-followed-by-seq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmacro-tt-followed-by-seq.rs?ref=724b6ed751a0070d5c0904895e25578ca97f3fc7", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Regression test for issue #25436: permit token-trees to be followed\n+// by sequences, enabling more general parsing.\n+\n+use self::Join::*;\n+\n+#[derive(Debug)]\n+enum Join<A,B> {\n+  Keep(A,B),\n+  Skip(A,B),\n+}\n+\n+macro_rules! parse_list {\n+  ( < $a:expr; > $($b:tt)* ) => { Keep(parse_item!($a),parse_list!($($b)*)) };\n+  ( $a:tt $($b:tt)* ) => { Skip(parse_item!($a), parse_list!($($b)*)) };\n+  ( ) => { () };\n+}\n+\n+macro_rules! parse_item {\n+  ( $x:expr ) => { $x }\n+}\n+\n+fn main() {\n+    let list = parse_list!(<1;> 2 <3;> 4);\n+    assert_eq!(\"Keep(1, Skip(2, Keep(3, Skip(4, ()))))\",\n+               format!(\"{:?}\", list));\n+}"}]}