{"sha": "cca48285b87e44f34788773eef520f9e3f9b20c9", "node_id": "C_kwDOAAsO6NoAKGNjYTQ4Mjg1Yjg3ZTQ0ZjM0Nzg4NzczZWVmNTIwZjllM2Y5YjIwYzk", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-09-26T23:39:27Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-09-27T17:42:13Z"}, "message": "Format type_of", "tree": {"sha": "94d652c073dfeebc295a94c6be2347eb5f155236", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/94d652c073dfeebc295a94c6be2347eb5f155236"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cca48285b87e44f34788773eef520f9e3f9b20c9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cca48285b87e44f34788773eef520f9e3f9b20c9", "html_url": "https://github.com/rust-lang/rust/commit/cca48285b87e44f34788773eef520f9e3f9b20c9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cca48285b87e44f34788773eef520f9e3f9b20c9/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "57ee5cf5a93923dae9c98bffb11545fc3a31368d", "url": "https://api.github.com/repos/rust-lang/rust/commits/57ee5cf5a93923dae9c98bffb11545fc3a31368d", "html_url": "https://github.com/rust-lang/rust/commit/57ee5cf5a93923dae9c98bffb11545fc3a31368d"}], "stats": {"total": 64, "additions": 36, "deletions": 28}, "files": [{"sha": "ee7d0e84b57ad97a6eefe7cf13a5090665eb9259", "filename": "compiler/rustc_hir_analysis/src/collect/type_of.rs", "status": "modified", "additions": 36, "deletions": 28, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/cca48285b87e44f34788773eef520f9e3f9b20c9/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cca48285b87e44f34788773eef520f9e3f9b20c9/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcollect%2Ftype_of.rs?ref=cca48285b87e44f34788773eef520f9e3f9b20c9", "patch": "@@ -333,7 +333,12 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                     find_opaque_ty_constraints_for_tait(tcx, def_id)\n                 }\n                 // Opaque types desugared from `impl Trait`.\n-                ItemKind::OpaqueTy(OpaqueTy { origin: hir::OpaqueTyOrigin::FnReturn(owner) | hir::OpaqueTyOrigin::AsyncFn(owner), in_trait, .. }) => {\n+                ItemKind::OpaqueTy(OpaqueTy {\n+                    origin:\n+                        hir::OpaqueTyOrigin::FnReturn(owner) | hir::OpaqueTyOrigin::AsyncFn(owner),\n+                    in_trait,\n+                    ..\n+                }) => {\n                     if in_trait {\n                         span_bug!(item.span, \"impl-trait in trait has no default\")\n                     } else {\n@@ -378,7 +383,9 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n \n         Node::Field(field) => icx.to_ty(field.ty),\n \n-        Node::Expr(&Expr { kind: ExprKind::Closure{..}, .. }) => tcx.typeck(def_id).node_type(hir_id),\n+        Node::Expr(&Expr { kind: ExprKind::Closure { .. }, .. }) => {\n+            tcx.typeck(def_id).node_type(hir_id)\n+        }\n \n         Node::AnonConst(_) if let Some(param) = tcx.opt_const_param_of(def_id) => {\n             // We defer to `type_of` of the corresponding parameter\n@@ -410,40 +417,42 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                 | Node::Item(&Item { kind: ItemKind::GlobalAsm(asm), .. })\n                     if asm.operands.iter().any(|(op, _op_sp)| match op {\n                         hir::InlineAsmOperand::Const { anon_const }\n-                        | hir::InlineAsmOperand::SymFn { anon_const } => anon_const.hir_id == hir_id,\n+                        | hir::InlineAsmOperand::SymFn { anon_const } => {\n+                            anon_const.hir_id == hir_id\n+                        }\n                         _ => false,\n                     }) =>\n                 {\n                     tcx.typeck(def_id).node_type(hir_id)\n                 }\n \n-                Node::Variant(Variant { disr_expr: Some(ref e), .. }) if e.hir_id == hir_id => tcx\n-                    .adt_def(tcx.hir().get_parent_item(hir_id))\n-                    .repr()\n-                    .discr_type()\n-                    .to_ty(tcx),\n+                Node::Variant(Variant { disr_expr: Some(ref e), .. }) if e.hir_id == hir_id => {\n+                    tcx.adt_def(tcx.hir().get_parent_item(hir_id)).repr().discr_type().to_ty(tcx)\n+                }\n \n-                Node::TypeBinding(binding @ &TypeBinding { hir_id: binding_id, ..  })\n-                    if let Node::TraitRef(trait_ref) = tcx.hir().get(\n-                        tcx.hir().get_parent_node(binding_id)\n-                    ) =>\n+                Node::TypeBinding(binding @ &TypeBinding { hir_id: binding_id, .. })\n+                    if let Node::TraitRef(trait_ref) =\n+                        tcx.hir().get(tcx.hir().get_parent_node(binding_id)) =>\n                 {\n-                  let Some(trait_def_id) = trait_ref.trait_def_id() else {\n+                    let Some(trait_def_id) = trait_ref.trait_def_id() else {\n                     return tcx.ty_error_with_message(DUMMY_SP, \"Could not find trait\");\n                   };\n-                  let assoc_items = tcx.associated_items(trait_def_id);\n-                  let assoc_item = assoc_items.find_by_name_and_kind(\n-                    tcx, binding.ident, ty::AssocKind::Const, def_id.to_def_id(),\n-                  );\n-                  if let Some(assoc_item) = assoc_item {\n-                    tcx.type_of(assoc_item.def_id)\n-                  } else {\n-                      // FIXME(associated_const_equality): add a useful error message here.\n-                      tcx.ty_error_with_message(\n-                        DUMMY_SP,\n-                        \"Could not find associated const on trait\",\n-                    )\n-                  }\n+                    let assoc_items = tcx.associated_items(trait_def_id);\n+                    let assoc_item = assoc_items.find_by_name_and_kind(\n+                        tcx,\n+                        binding.ident,\n+                        ty::AssocKind::Const,\n+                        def_id.to_def_id(),\n+                    );\n+                    if let Some(assoc_item) = assoc_item {\n+                        tcx.type_of(assoc_item.def_id)\n+                    } else {\n+                        // FIXME(associated_const_equality): add a useful error message here.\n+                        tcx.ty_error_with_message(\n+                            DUMMY_SP,\n+                            \"Could not find associated const on trait\",\n+                        )\n+                    }\n                 }\n \n                 Node::GenericParam(&GenericParam {\n@@ -452,8 +461,7 @@ pub(super) fn type_of(tcx: TyCtxt<'_>, def_id: DefId) -> Ty<'_> {\n                     ..\n                 }) if ct.hir_id == hir_id => tcx.type_of(tcx.hir().local_def_id(param_hir_id)),\n \n-                x =>\n-                  tcx.ty_error_with_message(\n+                x => tcx.ty_error_with_message(\n                     DUMMY_SP,\n                     &format!(\"unexpected const parent in type_of(): {x:?}\"),\n                 ),"}]}