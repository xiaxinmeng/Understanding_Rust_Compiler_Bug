{"sha": "4aafd8e779bac1122d8218e75872c6b14007f33d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRhYWZkOGU3NzliYWMxMTIyZDgyMThlNzU4NzJjNmIxNDAwN2YzM2Q=", "commit": {"author": {"name": "Caleb Zulawski", "email": "caleb.zulawski@gmail.com", "date": "2021-08-16T20:38:30Z"}, "committer": {"name": "Caleb Zulawski", "email": "caleb.zulawski@gmail.com", "date": "2021-08-16T20:38:30Z"}, "message": "Rename element type variable", "tree": {"sha": "4e1daab4e9bc70c5e7a808e566410eac17f69e66", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4e1daab4e9bc70c5e7a808e566410eac17f69e66"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4aafd8e779bac1122d8218e75872c6b14007f33d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4aafd8e779bac1122d8218e75872c6b14007f33d", "html_url": "https://github.com/rust-lang/rust/commit/4aafd8e779bac1122d8218e75872c6b14007f33d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4aafd8e779bac1122d8218e75872c6b14007f33d/comments", "author": {"login": "calebzulawski", "id": 563826, "node_id": "MDQ6VXNlcjU2MzgyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/563826?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebzulawski", "html_url": "https://github.com/calebzulawski", "followers_url": "https://api.github.com/users/calebzulawski/followers", "following_url": "https://api.github.com/users/calebzulawski/following{/other_user}", "gists_url": "https://api.github.com/users/calebzulawski/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebzulawski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebzulawski/subscriptions", "organizations_url": "https://api.github.com/users/calebzulawski/orgs", "repos_url": "https://api.github.com/users/calebzulawski/repos", "events_url": "https://api.github.com/users/calebzulawski/events{/privacy}", "received_events_url": "https://api.github.com/users/calebzulawski/received_events", "type": "User", "site_admin": false}, "committer": {"login": "calebzulawski", "id": 563826, "node_id": "MDQ6VXNlcjU2MzgyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/563826?v=4", "gravatar_id": "", "url": "https://api.github.com/users/calebzulawski", "html_url": "https://github.com/calebzulawski", "followers_url": "https://api.github.com/users/calebzulawski/followers", "following_url": "https://api.github.com/users/calebzulawski/following{/other_user}", "gists_url": "https://api.github.com/users/calebzulawski/gists{/gist_id}", "starred_url": "https://api.github.com/users/calebzulawski/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/calebzulawski/subscriptions", "organizations_url": "https://api.github.com/users/calebzulawski/orgs", "repos_url": "https://api.github.com/users/calebzulawski/repos", "events_url": "https://api.github.com/users/calebzulawski/events{/privacy}", "received_events_url": "https://api.github.com/users/calebzulawski/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cf653c7b9376eb170d0c8db634f5559e3708a87d", "url": "https://api.github.com/repos/rust-lang/rust/commits/cf653c7b9376eb170d0c8db634f5559e3708a87d", "html_url": "https://github.com/rust-lang/rust/commit/cf653c7b9376eb170d0c8db634f5559e3708a87d"}], "stats": {"total": 428, "additions": 212, "deletions": 216}, "files": [{"sha": "601576e094fa60ce91e796b87c15d65b9ef05099", "filename": "crates/core_simd/src/comparisons.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4aafd8e779bac1122d8218e75872c6b14007f33d/crates%2Fcore_simd%2Fsrc%2Fcomparisons.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4aafd8e779bac1122d8218e75872c6b14007f33d/crates%2Fcore_simd%2Fsrc%2Fcomparisons.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fcomparisons.rs?ref=4aafd8e779bac1122d8218e75872c6b14007f33d", "patch": "@@ -1,49 +1,49 @@\n use crate::{LaneCount, Mask, Simd, SimdElement, SupportedLaneCount};\n \n-impl<Element, const LANES: usize> Simd<Element, LANES>\n+impl<T, const LANES: usize> Simd<T, LANES>\n where\n-    Element: SimdElement + PartialEq,\n+    T: SimdElement + PartialEq,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n     /// Test if each lane is equal to the corresponding lane in `other`.\n     #[inline]\n-    pub fn lanes_eq(self, other: Self) -> Mask<Element::Mask, LANES> {\n+    pub fn lanes_eq(self, other: Self) -> Mask<T::Mask, LANES> {\n         unsafe { Mask::from_int_unchecked(crate::intrinsics::simd_eq(self, other)) }\n     }\n \n     /// Test if each lane is not equal to the corresponding lane in `other`.\n     #[inline]\n-    pub fn lanes_ne(self, other: Self) -> Mask<Element::Mask, LANES> {\n+    pub fn lanes_ne(self, other: Self) -> Mask<T::Mask, LANES> {\n         unsafe { Mask::from_int_unchecked(crate::intrinsics::simd_ne(self, other)) }\n     }\n }\n \n-impl<Element, const LANES: usize> Simd<Element, LANES>\n+impl<T, const LANES: usize> Simd<T, LANES>\n where\n-    Element: SimdElement + PartialOrd,\n+    T: SimdElement + PartialOrd,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n     /// Test if each lane is less than the corresponding lane in `other`.\n     #[inline]\n-    pub fn lanes_lt(self, other: Self) -> Mask<Element::Mask, LANES> {\n+    pub fn lanes_lt(self, other: Self) -> Mask<T::Mask, LANES> {\n         unsafe { Mask::from_int_unchecked(crate::intrinsics::simd_lt(self, other)) }\n     }\n \n     /// Test if each lane is greater than the corresponding lane in `other`.\n     #[inline]\n-    pub fn lanes_gt(self, other: Self) -> Mask<Element::Mask, LANES> {\n+    pub fn lanes_gt(self, other: Self) -> Mask<T::Mask, LANES> {\n         unsafe { Mask::from_int_unchecked(crate::intrinsics::simd_gt(self, other)) }\n     }\n \n     /// Test if each lane is less than or equal to the corresponding lane in `other`.\n     #[inline]\n-    pub fn lanes_le(self, other: Self) -> Mask<Element::Mask, LANES> {\n+    pub fn lanes_le(self, other: Self) -> Mask<T::Mask, LANES> {\n         unsafe { Mask::from_int_unchecked(crate::intrinsics::simd_le(self, other)) }\n     }\n \n     /// Test if each lane is greater than or equal to the corresponding lane in `other`.\n     #[inline]\n-    pub fn lanes_ge(self, other: Self) -> Mask<Element::Mask, LANES> {\n+    pub fn lanes_ge(self, other: Self) -> Mask<T::Mask, LANES> {\n         unsafe { Mask::from_int_unchecked(crate::intrinsics::simd_ge(self, other)) }\n     }\n }"}, {"sha": "c3947c92f2a9ce6c7588bde6dd4998de3fb42223", "filename": "crates/core_simd/src/fmt.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4aafd8e779bac1122d8218e75872c6b14007f33d/crates%2Fcore_simd%2Fsrc%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4aafd8e779bac1122d8218e75872c6b14007f33d/crates%2Fcore_simd%2Fsrc%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Ffmt.rs?ref=4aafd8e779bac1122d8218e75872c6b14007f33d", "patch": "@@ -1,10 +1,10 @@\n macro_rules! impl_fmt_trait {\n     { $($trait:ident,)* } => {\n         $(\n-            impl<Element, const LANES: usize> core::fmt::$trait for crate::Simd<Element, LANES>\n+            impl<T, const LANES: usize> core::fmt::$trait for crate::Simd<T, LANES>\n             where\n                 crate::LaneCount<LANES>: crate::SupportedLaneCount,\n-                Element: crate::SimdElement + core::fmt::$trait,\n+                T: crate::SimdElement + core::fmt::$trait,\n             {\n                 fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n                     #[repr(transparent)]"}, {"sha": "14b1fe08ffbd1fa8fe6608a1907d20231d8f8a47", "filename": "crates/core_simd/src/masks.rs", "status": "modified", "additions": 64, "deletions": 64, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/4aafd8e779bac1122d8218e75872c6b14007f33d/crates%2Fcore_simd%2Fsrc%2Fmasks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4aafd8e779bac1122d8218e75872c6b14007f33d/crates%2Fcore_simd%2Fsrc%2Fmasks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmasks.rs?ref=4aafd8e779bac1122d8218e75872c6b14007f33d", "patch": "@@ -59,31 +59,31 @@ impl_element! { isize }\n ///\n /// The layout of this type is unspecified.\n #[repr(transparent)]\n-pub struct Mask<Element, const LANES: usize>(mask_impl::Mask<Element, LANES>)\n+pub struct Mask<T, const LANES: usize>(mask_impl::Mask<T, LANES>)\n where\n-    Element: MaskElement,\n+    T: MaskElement,\n     LaneCount<LANES>: SupportedLaneCount;\n \n-impl<Element, const LANES: usize> Copy for Mask<Element, LANES>\n+impl<T, const LANES: usize> Copy for Mask<T, LANES>\n where\n-    Element: MaskElement,\n+    T: MaskElement,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n }\n \n-impl<Element, const LANES: usize> Clone for Mask<Element, LANES>\n+impl<T, const LANES: usize> Clone for Mask<T, LANES>\n where\n-    Element: MaskElement,\n+    T: MaskElement,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n     fn clone(&self) -> Self {\n         *self\n     }\n }\n \n-impl<Element, const LANES: usize> Mask<Element, LANES>\n+impl<T, const LANES: usize> Mask<T, LANES>\n where\n-    Element: MaskElement,\n+    T: MaskElement,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n     /// Construct a mask by setting all lanes to the given value.\n@@ -115,7 +115,7 @@ where\n     /// # Safety\n     /// All lanes must be either 0 or -1.\n     #[inline]\n-    pub unsafe fn from_int_unchecked(value: Simd<Element, LANES>) -> Self {\n+    pub unsafe fn from_int_unchecked(value: Simd<T, LANES>) -> Self {\n         Self(mask_impl::Mask::from_int_unchecked(value))\n     }\n \n@@ -125,15 +125,15 @@ where\n     /// # Panics\n     /// Panics if any lane is not 0 or -1.\n     #[inline]\n-    pub fn from_int(value: Simd<Element, LANES>) -> Self {\n-        assert!(Element::valid(value), \"all values must be either 0 or -1\",);\n+    pub fn from_int(value: Simd<T, LANES>) -> Self {\n+        assert!(T::valid(value), \"all values must be either 0 or -1\",);\n         unsafe { Self::from_int_unchecked(value) }\n     }\n \n     /// Converts the mask to a vector of integers, where 0 represents `false` and -1\n     /// represents `true`.\n     #[inline]\n-    pub fn to_int(self) -> Simd<Element, LANES> {\n+    pub fn to_int(self) -> Simd<T, LANES> {\n         self.0.to_int()\n     }\n \n@@ -201,29 +201,29 @@ where\n }\n \n // vector/array conversion\n-impl<Element, const LANES: usize> From<[bool; LANES]> for Mask<Element, LANES>\n+impl<T, const LANES: usize> From<[bool; LANES]> for Mask<T, LANES>\n where\n-    Element: MaskElement,\n+    T: MaskElement,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n     fn from(array: [bool; LANES]) -> Self {\n         Self::from_array(array)\n     }\n }\n \n-impl<Element, const LANES: usize> From<Mask<Element, LANES>> for [bool; LANES]\n+impl<T, const LANES: usize> From<Mask<T, LANES>> for [bool; LANES]\n where\n-    Element: MaskElement,\n+    T: MaskElement,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n-    fn from(vector: Mask<Element, LANES>) -> Self {\n+    fn from(vector: Mask<T, LANES>) -> Self {\n         vector.to_array()\n     }\n }\n \n-impl<Element, const LANES: usize> Default for Mask<Element, LANES>\n+impl<T, const LANES: usize> Default for Mask<T, LANES>\n where\n-    Element: MaskElement,\n+    T: MaskElement,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n     #[inline]\n@@ -232,9 +232,9 @@ where\n     }\n }\n \n-impl<Element, const LANES: usize> PartialEq for Mask<Element, LANES>\n+impl<T, const LANES: usize> PartialEq for Mask<T, LANES>\n where\n-    Element: MaskElement + PartialEq,\n+    T: MaskElement + PartialEq,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n     #[inline]\n@@ -243,9 +243,9 @@ where\n     }\n }\n \n-impl<Element, const LANES: usize> PartialOrd for Mask<Element, LANES>\n+impl<T, const LANES: usize> PartialOrd for Mask<T, LANES>\n where\n-    Element: MaskElement + PartialOrd,\n+    T: MaskElement + PartialOrd,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n     #[inline]\n@@ -254,9 +254,9 @@ where\n     }\n }\n \n-impl<Element, const LANES: usize> core::fmt::Debug for Mask<Element, LANES>\n+impl<T, const LANES: usize> core::fmt::Debug for Mask<T, LANES>\n where\n-    Element: MaskElement + core::fmt::Debug,\n+    T: MaskElement + core::fmt::Debug,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n     fn fmt(&self, f: &mut core::fmt::Formatter) -> core::fmt::Result {\n@@ -266,9 +266,9 @@ where\n     }\n }\n \n-impl<Element, const LANES: usize> core::ops::BitAnd for Mask<Element, LANES>\n+impl<T, const LANES: usize> core::ops::BitAnd for Mask<T, LANES>\n where\n-    Element: MaskElement,\n+    T: MaskElement,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n     type Output = Self;\n@@ -278,9 +278,9 @@ where\n     }\n }\n \n-impl<Element, const LANES: usize> core::ops::BitAnd<bool> for Mask<Element, LANES>\n+impl<T, const LANES: usize> core::ops::BitAnd<bool> for Mask<T, LANES>\n where\n-    Element: MaskElement,\n+    T: MaskElement,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n     type Output = Self;\n@@ -290,21 +290,21 @@ where\n     }\n }\n \n-impl<Element, const LANES: usize> core::ops::BitAnd<Mask<Element, LANES>> for bool\n+impl<T, const LANES: usize> core::ops::BitAnd<Mask<T, LANES>> for bool\n where\n-    Element: MaskElement,\n+    T: MaskElement,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n-    type Output = Mask<Element, LANES>;\n+    type Output = Mask<T, LANES>;\n     #[inline]\n-    fn bitand(self, rhs: Mask<Element, LANES>) -> Mask<Element, LANES> {\n+    fn bitand(self, rhs: Mask<T, LANES>) -> Mask<T, LANES> {\n         Mask::splat(self) & rhs\n     }\n }\n \n-impl<Element, const LANES: usize> core::ops::BitOr for Mask<Element, LANES>\n+impl<T, const LANES: usize> core::ops::BitOr for Mask<T, LANES>\n where\n-    Element: MaskElement,\n+    T: MaskElement,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n     type Output = Self;\n@@ -314,9 +314,9 @@ where\n     }\n }\n \n-impl<Element, const LANES: usize> core::ops::BitOr<bool> for Mask<Element, LANES>\n+impl<T, const LANES: usize> core::ops::BitOr<bool> for Mask<T, LANES>\n where\n-    Element: MaskElement,\n+    T: MaskElement,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n     type Output = Self;\n@@ -326,21 +326,21 @@ where\n     }\n }\n \n-impl<Element, const LANES: usize> core::ops::BitOr<Mask<Element, LANES>> for bool\n+impl<T, const LANES: usize> core::ops::BitOr<Mask<T, LANES>> for bool\n where\n-    Element: MaskElement,\n+    T: MaskElement,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n-    type Output = Mask<Element, LANES>;\n+    type Output = Mask<T, LANES>;\n     #[inline]\n-    fn bitor(self, rhs: Mask<Element, LANES>) -> Mask<Element, LANES> {\n+    fn bitor(self, rhs: Mask<T, LANES>) -> Mask<T, LANES> {\n         Mask::splat(self) | rhs\n     }\n }\n \n-impl<Element, const LANES: usize> core::ops::BitXor for Mask<Element, LANES>\n+impl<T, const LANES: usize> core::ops::BitXor for Mask<T, LANES>\n where\n-    Element: MaskElement,\n+    T: MaskElement,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n     type Output = Self;\n@@ -350,9 +350,9 @@ where\n     }\n }\n \n-impl<Element, const LANES: usize> core::ops::BitXor<bool> for Mask<Element, LANES>\n+impl<T, const LANES: usize> core::ops::BitXor<bool> for Mask<T, LANES>\n where\n-    Element: MaskElement,\n+    T: MaskElement,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n     type Output = Self;\n@@ -362,33 +362,33 @@ where\n     }\n }\n \n-impl<Element, const LANES: usize> core::ops::BitXor<Mask<Element, LANES>> for bool\n+impl<T, const LANES: usize> core::ops::BitXor<Mask<T, LANES>> for bool\n where\n-    Element: MaskElement,\n+    T: MaskElement,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n-    type Output = Mask<Element, LANES>;\n+    type Output = Mask<T, LANES>;\n     #[inline]\n-    fn bitxor(self, rhs: Mask<Element, LANES>) -> Self::Output {\n+    fn bitxor(self, rhs: Mask<T, LANES>) -> Self::Output {\n         Mask::splat(self) ^ rhs\n     }\n }\n \n-impl<Element, const LANES: usize> core::ops::Not for Mask<Element, LANES>\n+impl<T, const LANES: usize> core::ops::Not for Mask<T, LANES>\n where\n-    Element: MaskElement,\n+    T: MaskElement,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n-    type Output = Mask<Element, LANES>;\n+    type Output = Mask<T, LANES>;\n     #[inline]\n     fn not(self) -> Self::Output {\n         Self(!self.0)\n     }\n }\n \n-impl<Element, const LANES: usize> core::ops::BitAndAssign for Mask<Element, LANES>\n+impl<T, const LANES: usize> core::ops::BitAndAssign for Mask<T, LANES>\n where\n-    Element: MaskElement,\n+    T: MaskElement,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n     #[inline]\n@@ -397,9 +397,9 @@ where\n     }\n }\n \n-impl<Element, const LANES: usize> core::ops::BitAndAssign<bool> for Mask<Element, LANES>\n+impl<T, const LANES: usize> core::ops::BitAndAssign<bool> for Mask<T, LANES>\n where\n-    Element: MaskElement,\n+    T: MaskElement,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n     #[inline]\n@@ -408,9 +408,9 @@ where\n     }\n }\n \n-impl<Element, const LANES: usize> core::ops::BitOrAssign for Mask<Element, LANES>\n+impl<T, const LANES: usize> core::ops::BitOrAssign for Mask<T, LANES>\n where\n-    Element: MaskElement,\n+    T: MaskElement,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n     #[inline]\n@@ -419,9 +419,9 @@ where\n     }\n }\n \n-impl<Element, const LANES: usize> core::ops::BitOrAssign<bool> for Mask<Element, LANES>\n+impl<T, const LANES: usize> core::ops::BitOrAssign<bool> for Mask<T, LANES>\n where\n-    Element: MaskElement,\n+    T: MaskElement,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n     #[inline]\n@@ -430,9 +430,9 @@ where\n     }\n }\n \n-impl<Element, const LANES: usize> core::ops::BitXorAssign for Mask<Element, LANES>\n+impl<T, const LANES: usize> core::ops::BitXorAssign for Mask<T, LANES>\n where\n-    Element: MaskElement,\n+    T: MaskElement,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n     #[inline]\n@@ -441,9 +441,9 @@ where\n     }\n }\n \n-impl<Element, const LANES: usize> core::ops::BitXorAssign<bool> for Mask<Element, LANES>\n+impl<T, const LANES: usize> core::ops::BitXorAssign<bool> for Mask<T, LANES>\n where\n-    Element: MaskElement,\n+    T: MaskElement,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n     #[inline]"}, {"sha": "0b5b3a5c595eb98caef755a0bec44853bbf9753f", "filename": "crates/core_simd/src/masks/bitmask.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/4aafd8e779bac1122d8218e75872c6b14007f33d/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fbitmask.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4aafd8e779bac1122d8218e75872c6b14007f33d/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fbitmask.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmasks%2Fbitmask.rs?ref=4aafd8e779bac1122d8218e75872c6b14007f33d", "patch": "@@ -3,71 +3,71 @@ use core::marker::PhantomData;\n \n /// A mask where each lane is represented by a single bit.\n #[repr(transparent)]\n-pub struct Mask<Element, const LANES: usize>(\n+pub struct Mask<T, const LANES: usize>(\n     <LaneCount<LANES> as SupportedLaneCount>::BitMask,\n-    PhantomData<Element>,\n+    PhantomData<T>,\n )\n where\n-    Element: MaskElement,\n+    T: MaskElement,\n     LaneCount<LANES>: SupportedLaneCount;\n \n-impl<Element, const LANES: usize> Copy for Mask<Element, LANES>\n+impl<T, const LANES: usize> Copy for Mask<T, LANES>\n where\n-    Element: MaskElement,\n+    T: MaskElement,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n }\n \n-impl<Element, const LANES: usize> Clone for Mask<Element, LANES>\n+impl<T, const LANES: usize> Clone for Mask<T, LANES>\n where\n-    Element: MaskElement,\n+    T: MaskElement,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n     fn clone(&self) -> Self {\n         *self\n     }\n }\n \n-impl<Element, const LANES: usize> PartialEq for Mask<Element, LANES>\n+impl<T, const LANES: usize> PartialEq for Mask<T, LANES>\n where\n-    Element: MaskElement,\n+    T: MaskElement,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n     fn eq(&self, other: &Self) -> bool {\n         self.0.as_ref() == other.0.as_ref()\n     }\n }\n \n-impl<Element, const LANES: usize> PartialOrd for Mask<Element, LANES>\n+impl<T, const LANES: usize> PartialOrd for Mask<T, LANES>\n where\n-    Element: MaskElement,\n+    T: MaskElement,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n     fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {\n         self.0.as_ref().partial_cmp(other.0.as_ref())\n     }\n }\n \n-impl<Element, const LANES: usize> Eq for Mask<Element, LANES>\n+impl<T, const LANES: usize> Eq for Mask<T, LANES>\n where\n-    Element: MaskElement,\n+    T: MaskElement,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n }\n \n-impl<Element, const LANES: usize> Ord for Mask<Element, LANES>\n+impl<T, const LANES: usize> Ord for Mask<T, LANES>\n where\n-    Element: MaskElement,\n+    T: MaskElement,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n     fn cmp(&self, other: &Self) -> core::cmp::Ordering {\n         self.0.as_ref().cmp(other.0.as_ref())\n     }\n }\n \n-impl<Element, const LANES: usize> Mask<Element, LANES>\n+impl<T, const LANES: usize> Mask<T, LANES>\n where\n-    Element: MaskElement,\n+    T: MaskElement,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n     #[inline]\n@@ -95,20 +95,20 @@ where\n     }\n \n     #[inline]\n-    pub fn to_int(self) -> Simd<Element, LANES> {\n+    pub fn to_int(self) -> Simd<T, LANES> {\n         unsafe {\n             let mask: <LaneCount<LANES> as SupportedLaneCount>::IntBitMask =\n                 core::mem::transmute_copy(&self);\n             crate::intrinsics::simd_select_bitmask(\n                 mask,\n-                Simd::splat(Element::TRUE),\n-                Simd::splat(Element::FALSE),\n+                Simd::splat(T::TRUE),\n+                Simd::splat(T::FALSE),\n             )\n         }\n     }\n \n     #[inline]\n-    pub unsafe fn from_int_unchecked(value: Simd<Element, LANES>) -> Self {\n+    pub unsafe fn from_int_unchecked(value: Simd<T, LANES>) -> Self {\n         // TODO remove the transmute when rustc is more flexible\n         assert_eq!(\n             core::mem::size_of::<<LaneCount::<LANES> as SupportedLaneCount>::BitMask>(),\n@@ -132,9 +132,9 @@ where\n     }\n \n     #[inline]\n-    pub fn convert<T>(self) -> Mask<T, LANES>\n+    pub fn convert<U>(self) -> Mask<U, LANES>\n     where\n-        T: MaskElement,\n+        U: MaskElement,\n     {\n         unsafe { core::mem::transmute_copy(&self) }\n     }\n@@ -150,9 +150,9 @@ where\n     }\n }\n \n-impl<Element, const LANES: usize> core::ops::BitAnd for Mask<Element, LANES>\n+impl<T, const LANES: usize> core::ops::BitAnd for Mask<T, LANES>\n where\n-    Element: MaskElement,\n+    T: MaskElement,\n     LaneCount<LANES>: SupportedLaneCount,\n     <LaneCount<LANES> as SupportedLaneCount>::BitMask: AsRef<[u8]> + AsMut<[u8]>,\n {\n@@ -166,9 +166,9 @@ where\n     }\n }\n \n-impl<Element, const LANES: usize> core::ops::BitOr for Mask<Element, LANES>\n+impl<T, const LANES: usize> core::ops::BitOr for Mask<T, LANES>\n where\n-    Element: MaskElement,\n+    T: MaskElement,\n     LaneCount<LANES>: SupportedLaneCount,\n     <LaneCount<LANES> as SupportedLaneCount>::BitMask: AsRef<[u8]> + AsMut<[u8]>,\n {\n@@ -182,9 +182,9 @@ where\n     }\n }\n \n-impl<Element, const LANES: usize> core::ops::BitXor for Mask<Element, LANES>\n+impl<T, const LANES: usize> core::ops::BitXor for Mask<T, LANES>\n where\n-    Element: MaskElement,\n+    T: MaskElement,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n     type Output = Self;\n@@ -197,9 +197,9 @@ where\n     }\n }\n \n-impl<Element, const LANES: usize> core::ops::Not for Mask<Element, LANES>\n+impl<T, const LANES: usize> core::ops::Not for Mask<T, LANES>\n where\n-    Element: MaskElement,\n+    T: MaskElement,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n     type Output = Self;"}, {"sha": "9c1cc4623f9a84115566147668e15f04a07afcab", "filename": "crates/core_simd/src/masks/full_masks.rs", "status": "modified", "additions": 34, "deletions": 38, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/4aafd8e779bac1122d8218e75872c6b14007f33d/crates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4aafd8e779bac1122d8218e75872c6b14007f33d/crates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fmasks%2Ffull_masks.rs?ref=4aafd8e779bac1122d8218e75872c6b14007f33d", "patch": "@@ -4,21 +4,21 @@ use super::MaskElement;\n use crate::{LaneCount, Simd, SupportedLaneCount};\n \n #[repr(transparent)]\n-pub struct Mask<Element, const LANES: usize>(Simd<Element, LANES>)\n+pub struct Mask<T, const LANES: usize>(Simd<T, LANES>)\n where\n-    Element: MaskElement,\n+    T: MaskElement,\n     LaneCount<LANES>: SupportedLaneCount;\n \n-impl<Element, const LANES: usize> Copy for Mask<Element, LANES>\n+impl<T, const LANES: usize> Copy for Mask<T, LANES>\n where\n-    Element: MaskElement,\n+    T: MaskElement,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n }\n \n-impl<Element, const LANES: usize> Clone for Mask<Element, LANES>\n+impl<T, const LANES: usize> Clone for Mask<T, LANES>\n where\n-    Element: MaskElement,\n+    T: MaskElement,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n     #[inline]\n@@ -27,80 +27,76 @@ where\n     }\n }\n \n-impl<Element, const LANES: usize> PartialEq for Mask<Element, LANES>\n+impl<T, const LANES: usize> PartialEq for Mask<T, LANES>\n where\n-    Element: MaskElement + PartialEq,\n+    T: MaskElement + PartialEq,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n     fn eq(&self, other: &Self) -> bool {\n         self.0.eq(&other.0)\n     }\n }\n \n-impl<Element, const LANES: usize> PartialOrd for Mask<Element, LANES>\n+impl<T, const LANES: usize> PartialOrd for Mask<T, LANES>\n where\n-    Element: MaskElement + PartialOrd,\n+    T: MaskElement + PartialOrd,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n     fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {\n         self.0.partial_cmp(&other.0)\n     }\n }\n \n-impl<Element, const LANES: usize> Eq for Mask<Element, LANES>\n+impl<T, const LANES: usize> Eq for Mask<T, LANES>\n where\n-    Element: MaskElement + Eq,\n+    T: MaskElement + Eq,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n }\n \n-impl<Element, const LANES: usize> Ord for Mask<Element, LANES>\n+impl<T, const LANES: usize> Ord for Mask<T, LANES>\n where\n-    Element: MaskElement + Ord,\n+    T: MaskElement + Ord,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n     fn cmp(&self, other: &Self) -> core::cmp::Ordering {\n         self.0.cmp(&other.0)\n     }\n }\n \n-impl<Element, const LANES: usize> Mask<Element, LANES>\n+impl<T, const LANES: usize> Mask<T, LANES>\n where\n-    Element: MaskElement,\n+    T: MaskElement,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n     pub fn splat(value: bool) -> Self {\n-        Self(Simd::splat(if value {\n-            Element::TRUE\n-        } else {\n-            Element::FALSE\n-        }))\n+        Self(Simd::splat(if value { T::TRUE } else { T::FALSE }))\n     }\n \n     #[inline]\n     pub unsafe fn test_unchecked(&self, lane: usize) -> bool {\n-        Element::eq(self.0[lane], Element::TRUE)\n+        T::eq(self.0[lane], T::TRUE)\n     }\n \n     #[inline]\n     pub unsafe fn set_unchecked(&mut self, lane: usize, value: bool) {\n-        self.0[lane] = if value { Element::TRUE } else { Element::FALSE }\n+        self.0[lane] = if value { T::TRUE } else { T::FALSE }\n     }\n \n     #[inline]\n-    pub fn to_int(self) -> Simd<Element, LANES> {\n+    pub fn to_int(self) -> Simd<T, LANES> {\n         self.0\n     }\n \n     #[inline]\n-    pub unsafe fn from_int_unchecked(value: Simd<Element, LANES>) -> Self {\n+    pub unsafe fn from_int_unchecked(value: Simd<T, LANES>) -> Self {\n         Self(value)\n     }\n \n     #[inline]\n-    pub fn convert<T>(self) -> Mask<T, LANES>\n+    pub fn convert<U>(self) -> Mask<U, LANES>\n     where\n-        T: MaskElement,\n+        U: MaskElement,\n     {\n         unsafe { Mask(crate::intrinsics::simd_cast(self.0)) }\n     }\n@@ -170,19 +166,19 @@ where\n     }\n }\n \n-impl<Element, const LANES: usize> core::convert::From<Mask<Element, LANES>> for Simd<Element, LANES>\n+impl<T, const LANES: usize> core::convert::From<Mask<T, LANES>> for Simd<T, LANES>\n where\n-    Element: MaskElement,\n+    T: MaskElement,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n-    fn from(value: Mask<Element, LANES>) -> Self {\n+    fn from(value: Mask<T, LANES>) -> Self {\n         value.0\n     }\n }\n \n-impl<Element, const LANES: usize> core::ops::BitAnd for Mask<Element, LANES>\n+impl<T, const LANES: usize> core::ops::BitAnd for Mask<T, LANES>\n where\n-    Element: MaskElement,\n+    T: MaskElement,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n     type Output = Self;\n@@ -192,9 +188,9 @@ where\n     }\n }\n \n-impl<Element, const LANES: usize> core::ops::BitOr for Mask<Element, LANES>\n+impl<T, const LANES: usize> core::ops::BitOr for Mask<T, LANES>\n where\n-    Element: MaskElement,\n+    T: MaskElement,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n     type Output = Self;\n@@ -204,9 +200,9 @@ where\n     }\n }\n \n-impl<Element, const LANES: usize> core::ops::BitXor for Mask<Element, LANES>\n+impl<T, const LANES: usize> core::ops::BitXor for Mask<T, LANES>\n where\n-    Element: MaskElement,\n+    T: MaskElement,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n     type Output = Self;\n@@ -216,9 +212,9 @@ where\n     }\n }\n \n-impl<Element, const LANES: usize> core::ops::Not for Mask<Element, LANES>\n+impl<T, const LANES: usize> core::ops::Not for Mask<T, LANES>\n where\n-    Element: MaskElement,\n+    T: MaskElement,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n     type Output = Self;"}, {"sha": "900315660005642eccf4d03ce24fc3c96160be0f", "filename": "crates/core_simd/src/ops.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4aafd8e779bac1122d8218e75872c6b14007f33d/crates%2Fcore_simd%2Fsrc%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4aafd8e779bac1122d8218e75872c6b14007f33d/crates%2Fcore_simd%2Fsrc%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fops.rs?ref=4aafd8e779bac1122d8218e75872c6b14007f33d", "patch": "@@ -1,22 +1,22 @@\n use crate::{LaneCount, Simd, SimdElement, SupportedLaneCount};\n \n-impl<I, Element, const LANES: usize> core::ops::Index<I> for Simd<Element, LANES>\n+impl<I, T, const LANES: usize> core::ops::Index<I> for Simd<T, LANES>\n where\n-    Element: SimdElement,\n+    T: SimdElement,\n     LaneCount<LANES>: SupportedLaneCount,\n-    I: core::slice::SliceIndex<[Element]>,\n+    I: core::slice::SliceIndex<[T]>,\n {\n     type Output = I::Output;\n     fn index(&self, index: I) -> &Self::Output {\n         &self.as_array()[index]\n     }\n }\n \n-impl<I, Element, const LANES: usize> core::ops::IndexMut<I> for Simd<Element, LANES>\n+impl<I, T, const LANES: usize> core::ops::IndexMut<I> for Simd<T, LANES>\n where\n-    Element: SimdElement,\n+    T: SimdElement,\n     LaneCount<LANES>: SupportedLaneCount,\n-    I: core::slice::SliceIndex<[Element]>,\n+    I: core::slice::SliceIndex<[T]>,\n {\n     fn index_mut(&mut self, index: I) -> &mut Self::Output {\n         &mut self.as_mut_array()[index]"}, {"sha": "cc58778b6b4b35fc3d36f4783a27cbb86bf362b0", "filename": "crates/core_simd/src/permute.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4aafd8e779bac1122d8218e75872c6b14007f33d/crates%2Fcore_simd%2Fsrc%2Fpermute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4aafd8e779bac1122d8218e75872c6b14007f33d/crates%2Fcore_simd%2Fsrc%2Fpermute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fpermute.rs?ref=4aafd8e779bac1122d8218e75872c6b14007f33d", "patch": "@@ -1,8 +1,8 @@\n macro_rules! impl_shuffle_lane {\n     { $fn:ident, $n:literal } => {\n-        impl<Element> crate::Simd<Element, $n>\n+        impl<T> crate::Simd<T, $n>\n         where\n-            Element: crate::SimdElement,\n+            T: crate::SimdElement,\n         {\n             /// A const SIMD shuffle that takes 2 SIMD vectors and produces another vector, using\n             /// the indices in the const parameter. The first or \"self\" vector will have its lanes"}, {"sha": "0951639c9426c3e9e12711db8f8d5b0227c8b60d", "filename": "crates/core_simd/src/select.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4aafd8e779bac1122d8218e75872c6b14007f33d/crates%2Fcore_simd%2Fsrc%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4aafd8e779bac1122d8218e75872c6b14007f33d/crates%2Fcore_simd%2Fsrc%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fselect.rs?ref=4aafd8e779bac1122d8218e75872c6b14007f33d", "patch": "@@ -11,34 +11,34 @@ pub trait Select<Mask>: Sealed {\n     fn select(mask: Mask, true_values: Self, false_values: Self) -> Self;\n }\n \n-impl<Element, const LANES: usize> Sealed for Simd<Element, LANES>\n+impl<T, const LANES: usize> Sealed for Simd<T, LANES>\n where\n-    Element: SimdElement,\n+    T: SimdElement,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n }\n \n-impl<Element, const LANES: usize> Select<Mask<Element::Mask, LANES>> for Simd<Element, LANES>\n+impl<T, const LANES: usize> Select<Mask<T::Mask, LANES>> for Simd<T, LANES>\n where\n-    Element: SimdElement,\n+    T: SimdElement,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n     #[inline]\n-    fn select(mask: Mask<Element::Mask, LANES>, true_values: Self, false_values: Self) -> Self {\n+    fn select(mask: Mask<T::Mask, LANES>, true_values: Self, false_values: Self) -> Self {\n         unsafe { crate::intrinsics::simd_select(mask.to_int(), true_values, false_values) }\n     }\n }\n \n-impl<Element, const LANES: usize> Sealed for Mask<Element, LANES>\n+impl<T, const LANES: usize> Sealed for Mask<T, LANES>\n where\n-    Element: MaskElement,\n+    T: MaskElement,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n }\n \n-impl<Element, const LANES: usize> Select<Self> for Mask<Element, LANES>\n+impl<T, const LANES: usize> Select<Self> for Mask<T, LANES>\n where\n-    Element: MaskElement,\n+    T: MaskElement,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n     #[doc(hidden)]\n@@ -48,9 +48,9 @@ where\n     }\n }\n \n-impl<Element, const LANES: usize> Mask<Element, LANES>\n+impl<T, const LANES: usize> Mask<T, LANES>\n where\n-    Element: MaskElement,\n+    T: MaskElement,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n     /// Choose lanes from two vectors."}, {"sha": "07e8a6c5926cbdbd5f9092acf1e8a56270c62e40", "filename": "crates/core_simd/src/vector.rs", "status": "modified", "additions": 52, "deletions": 52, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/4aafd8e779bac1122d8218e75872c6b14007f33d/crates%2Fcore_simd%2Fsrc%2Fvector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4aafd8e779bac1122d8218e75872c6b14007f33d/crates%2Fcore_simd%2Fsrc%2Fvector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fcore_simd%2Fsrc%2Fvector.rs?ref=4aafd8e779bac1122d8218e75872c6b14007f33d", "patch": "@@ -11,40 +11,40 @@ pub(crate) mod ptr;\n \n use crate::{LaneCount, Mask, MaskElement, SupportedLaneCount};\n \n-/// A SIMD vector of `LANES` elements of type `Element`.\n+/// A SIMD vector of `LANES` elements of type `T`.\n #[repr(simd)]\n-pub struct Simd<Element, const LANES: usize>([Element; LANES])\n+pub struct Simd<T, const LANES: usize>([T; LANES])\n where\n-    Element: SimdElement,\n+    T: SimdElement,\n     LaneCount<LANES>: SupportedLaneCount;\n \n-impl<Element, const LANES: usize> Simd<Element, LANES>\n+impl<T, const LANES: usize> Simd<T, LANES>\n where\n     LaneCount<LANES>: SupportedLaneCount,\n-    Element: SimdElement,\n+    T: SimdElement,\n {\n     /// Construct a SIMD vector by setting all lanes to the given value.\n-    pub const fn splat(value: Element) -> Self {\n+    pub const fn splat(value: T) -> Self {\n         Self([value; LANES])\n     }\n \n     /// Returns an array reference containing the entire SIMD vector.\n-    pub const fn as_array(&self) -> &[Element; LANES] {\n+    pub const fn as_array(&self) -> &[T; LANES] {\n         &self.0\n     }\n \n     /// Returns a mutable array reference containing the entire SIMD vector.\n-    pub fn as_mut_array(&mut self) -> &mut [Element; LANES] {\n+    pub fn as_mut_array(&mut self) -> &mut [T; LANES] {\n         &mut self.0\n     }\n \n     /// Converts an array to a SIMD vector.\n-    pub const fn from_array(array: [Element; LANES]) -> Self {\n+    pub const fn from_array(array: [T; LANES]) -> Self {\n         Self(array)\n     }\n \n     /// Converts a SIMD vector to an array.\n-    pub const fn to_array(self) -> [Element; LANES] {\n+    pub const fn to_array(self) -> [T; LANES] {\n         self.0\n     }\n \n@@ -62,7 +62,7 @@ where\n     /// ```\n     #[must_use]\n     #[inline]\n-    pub fn gather_or(slice: &[Element], idxs: Simd<usize, LANES>, or: Self) -> Self {\n+    pub fn gather_or(slice: &[T], idxs: Simd<usize, LANES>, or: Self) -> Self {\n         Self::gather_select(slice, Mask::splat(true), idxs, or)\n     }\n \n@@ -79,11 +79,11 @@ where\n     /// ```\n     #[must_use]\n     #[inline]\n-    pub fn gather_or_default(slice: &[Element], idxs: Simd<usize, LANES>) -> Self\n+    pub fn gather_or_default(slice: &[T], idxs: Simd<usize, LANES>) -> Self\n     where\n-        Element: Default,\n+        T: Default,\n     {\n-        Self::gather_or(slice, idxs, Self::splat(Element::default()))\n+        Self::gather_or(slice, idxs, Self::splat(T::default()))\n     }\n \n     /// SIMD gather: construct a SIMD vector by reading from a slice, using potentially discontiguous indices.\n@@ -102,7 +102,7 @@ where\n     #[must_use]\n     #[inline]\n     pub fn gather_select(\n-        slice: &[Element],\n+        slice: &[T],\n         mask: Mask<isize, LANES>,\n         idxs: Simd<usize, LANES>,\n         or: Self,\n@@ -129,7 +129,7 @@ where\n     /// assert_eq!(vec, vec![124, 11, 12, 82, 14, 15, 16, 17, 18]);\n     /// ```\n     #[inline]\n-    pub fn scatter(self, slice: &mut [Element], idxs: Simd<usize, LANES>) {\n+    pub fn scatter(self, slice: &mut [T], idxs: Simd<usize, LANES>) {\n         self.scatter_select(slice, Mask::splat(true), idxs)\n     }\n \n@@ -150,7 +150,7 @@ where\n     #[inline]\n     pub fn scatter_select(\n         self,\n-        slice: &mut [Element],\n+        slice: &mut [T],\n         mask: Mask<isize, LANES>,\n         idxs: Simd<usize, LANES>,\n     ) {\n@@ -178,38 +178,38 @@ where\n     }\n }\n \n-impl<Element, const LANES: usize> Copy for Simd<Element, LANES>\n+impl<T, const LANES: usize> Copy for Simd<T, LANES>\n where\n-    Element: SimdElement,\n+    T: SimdElement,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n }\n \n-impl<Element, const LANES: usize> Clone for Simd<Element, LANES>\n+impl<T, const LANES: usize> Clone for Simd<T, LANES>\n where\n-    Element: SimdElement,\n+    T: SimdElement,\n     LaneCount<LANES>: SupportedLaneCount,\n {\n     fn clone(&self) -> Self {\n         *self\n     }\n }\n \n-impl<Element, const LANES: usize> Default for Simd<Element, LANES>\n+impl<T, const LANES: usize> Default for Simd<T, LANES>\n where\n     LaneCount<LANES>: SupportedLaneCount,\n-    Element: SimdElement + Default,\n+    T: SimdElement + Default,\n {\n     #[inline]\n     fn default() -> Self {\n-        Self::splat(Element::default())\n+        Self::splat(T::default())\n     }\n }\n \n-impl<Element, const LANES: usize> PartialEq for Simd<Element, LANES>\n+impl<T, const LANES: usize> PartialEq for Simd<T, LANES>\n where\n     LaneCount<LANES>: SupportedLaneCount,\n-    Element: SimdElement + PartialEq,\n+    T: SimdElement + PartialEq,\n {\n     #[inline]\n     fn eq(&self, other: &Self) -> bool {\n@@ -218,10 +218,10 @@ where\n     }\n }\n \n-impl<Element, const LANES: usize> PartialOrd for Simd<Element, LANES>\n+impl<T, const LANES: usize> PartialOrd for Simd<T, LANES>\n where\n     LaneCount<LANES>: SupportedLaneCount,\n-    Element: SimdElement + PartialOrd,\n+    T: SimdElement + PartialOrd,\n {\n     #[inline]\n     fn partial_cmp(&self, other: &Self) -> Option<core::cmp::Ordering> {\n@@ -230,17 +230,17 @@ where\n     }\n }\n \n-impl<Element, const LANES: usize> Eq for Simd<Element, LANES>\n+impl<T, const LANES: usize> Eq for Simd<T, LANES>\n where\n     LaneCount<LANES>: SupportedLaneCount,\n-    Element: SimdElement + Eq,\n+    T: SimdElement + Eq,\n {\n }\n \n-impl<Element, const LANES: usize> Ord for Simd<Element, LANES>\n+impl<T, const LANES: usize> Ord for Simd<T, LANES>\n where\n     LaneCount<LANES>: SupportedLaneCount,\n-    Element: SimdElement + Ord,\n+    T: SimdElement + Ord,\n {\n     #[inline]\n     fn cmp(&self, other: &Self) -> core::cmp::Ordering {\n@@ -249,10 +249,10 @@ where\n     }\n }\n \n-impl<Element, const LANES: usize> core::hash::Hash for Simd<Element, LANES>\n+impl<T, const LANES: usize> core::hash::Hash for Simd<T, LANES>\n where\n     LaneCount<LANES>: SupportedLaneCount,\n-    Element: SimdElement + core::hash::Hash,\n+    T: SimdElement + core::hash::Hash,\n {\n     #[inline]\n     fn hash<H>(&self, state: &mut H)\n@@ -264,68 +264,68 @@ where\n }\n \n // array references\n-impl<Element, const LANES: usize> AsRef<[Element; LANES]> for Simd<Element, LANES>\n+impl<T, const LANES: usize> AsRef<[T; LANES]> for Simd<T, LANES>\n where\n     LaneCount<LANES>: SupportedLaneCount,\n-    Element: SimdElement,\n+    T: SimdElement,\n {\n     #[inline]\n-    fn as_ref(&self) -> &[Element; LANES] {\n+    fn as_ref(&self) -> &[T; LANES] {\n         &self.0\n     }\n }\n \n-impl<Element, const LANES: usize> AsMut<[Element; LANES]> for Simd<Element, LANES>\n+impl<T, const LANES: usize> AsMut<[T; LANES]> for Simd<T, LANES>\n where\n     LaneCount<LANES>: SupportedLaneCount,\n-    Element: SimdElement,\n+    T: SimdElement,\n {\n     #[inline]\n-    fn as_mut(&mut self) -> &mut [Element; LANES] {\n+    fn as_mut(&mut self) -> &mut [T; LANES] {\n         &mut self.0\n     }\n }\n \n // slice references\n-impl<Element, const LANES: usize> AsRef<[Element]> for Simd<Element, LANES>\n+impl<T, const LANES: usize> AsRef<[T]> for Simd<T, LANES>\n where\n     LaneCount<LANES>: SupportedLaneCount,\n-    Element: SimdElement,\n+    T: SimdElement,\n {\n     #[inline]\n-    fn as_ref(&self) -> &[Element] {\n+    fn as_ref(&self) -> &[T] {\n         &self.0\n     }\n }\n \n-impl<Element, const LANES: usize> AsMut<[Element]> for Simd<Element, LANES>\n+impl<T, const LANES: usize> AsMut<[T]> for Simd<T, LANES>\n where\n     LaneCount<LANES>: SupportedLaneCount,\n-    Element: SimdElement,\n+    T: SimdElement,\n {\n     #[inline]\n-    fn as_mut(&mut self) -> &mut [Element] {\n+    fn as_mut(&mut self) -> &mut [T] {\n         &mut self.0\n     }\n }\n \n // vector/array conversion\n-impl<Element, const LANES: usize> From<[Element; LANES]> for Simd<Element, LANES>\n+impl<T, const LANES: usize> From<[T; LANES]> for Simd<T, LANES>\n where\n     LaneCount<LANES>: SupportedLaneCount,\n-    Element: SimdElement,\n+    T: SimdElement,\n {\n-    fn from(array: [Element; LANES]) -> Self {\n+    fn from(array: [T; LANES]) -> Self {\n         Self(array)\n     }\n }\n \n-impl<Element, const LANES: usize> From<Simd<Element, LANES>> for [Element; LANES]\n+impl<T, const LANES: usize> From<Simd<T, LANES>> for [T; LANES]\n where\n     LaneCount<LANES>: SupportedLaneCount,\n-    Element: SimdElement,\n+    T: SimdElement,\n {\n-    fn from(vector: Simd<Element, LANES>) -> Self {\n+    fn from(vector: Simd<T, LANES>) -> Self {\n         vector.to_array()\n     }\n }"}]}