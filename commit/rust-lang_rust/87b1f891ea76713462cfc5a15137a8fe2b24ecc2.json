{"sha": "87b1f891ea76713462cfc5a15137a8fe2b24ecc2", "node_id": "C_kwDOAAsO6NoAKDg3YjFmODkxZWE3NjcxMzQ2MmNmYzVhMTUxMzdhOGZlMmIyNGVjYzI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-29T18:55:28Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-04-29T18:55:28Z"}, "message": "Auto merge of #110576 - jyn514:unify-test-args, r=ozkanonur\n\nbootstrap: Unify test argument handling\n\nFixes #104198. Does *not* help with https://github.com/rust-lang/rust/issues/80124 because I couldn't figure out a reasonable way to omit `--lib` only for `panic_abort` and not other `std` dependencies.\n\n- Remove unnecessary `test_kind` field and `TestKind` struct. These are just subsets of the existing `builder.kind` / `Kind` struct.\n- Add a new `run_cargo_test` function which handles passing arguments to cargo based on `builder.config`\n- Switch all Steps in `mod test` to `run_cargo_test` where possible\n- Combine several steps into one `CrateBootstrap` step. These tests all do the same thing, just with different crate names.\n- Fix `x test --no-doc`. This is much simpler after the refactors mentioned earlier, but I'm happy to split it into a separate PR if desired. Before, this would panic a lot because steps forgot to pass `--lib`.", "tree": {"sha": "1b36219cef7f2f1ff21fc7aea035074422404934", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1b36219cef7f2f1ff21fc7aea035074422404934"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/87b1f891ea76713462cfc5a15137a8fe2b24ecc2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/87b1f891ea76713462cfc5a15137a8fe2b24ecc2", "html_url": "https://github.com/rust-lang/rust/commit/87b1f891ea76713462cfc5a15137a8fe2b24ecc2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/87b1f891ea76713462cfc5a15137a8fe2b24ecc2/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eb62877597000ccf8bb99ab131b5977344afdfa3", "url": "https://api.github.com/repos/rust-lang/rust/commits/eb62877597000ccf8bb99ab131b5977344afdfa3", "html_url": "https://github.com/rust-lang/rust/commit/eb62877597000ccf8bb99ab131b5977344afdfa3"}, {"sha": "78a709348dca33414f76986ae72c651d489092f4", "url": "https://api.github.com/repos/rust-lang/rust/commits/78a709348dca33414f76986ae72c651d489092f4", "html_url": "https://github.com/rust-lang/rust/commit/78a709348dca33414f76986ae72c651d489092f4"}], "stats": {"total": 564, "additions": 215, "deletions": 349}, "files": [{"sha": "d9d4685dfc790e718677664bd7b66fb48b2a2c6f", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/87b1f891ea76713462cfc5a15137a8fe2b24ecc2/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87b1f891ea76713462cfc5a15137a8fe2b24ecc2/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=87b1f891ea76713462cfc5a15137a8fe2b24ecc2", "patch": "@@ -634,6 +634,14 @@ impl Kind {\n             Kind::Suggest => \"suggest\",\n         }\n     }\n+\n+    pub fn test_description(&self) -> &'static str {\n+        match self {\n+            Kind::Test => \"Testing\",\n+            Kind::Bench => \"Benchmarking\",\n+            _ => panic!(\"not a test command: {}!\", self.as_str()),\n+        }\n+    }\n }\n \n impl<'a> Builder<'a> {\n@@ -695,7 +703,6 @@ impl<'a> Builder<'a> {\n                 crate::toolstate::ToolStateCheck,\n                 test::ExpandYamlAnchors,\n                 test::Tidy,\n-                test::TidySelfTest,\n                 test::Ui,\n                 test::RunPassValgrind,\n                 test::MirOpt,\n@@ -711,11 +718,9 @@ impl<'a> Builder<'a> {\n                 test::CrateLibrustc,\n                 test::CrateRustdoc,\n                 test::CrateRustdocJsonTypes,\n-                test::CrateJsonDocLint,\n-                test::SuggestTestsCrate,\n+                test::CrateBootstrap,\n                 test::Linkcheck,\n                 test::TierCheck,\n-                test::ReplacePlaceholderTest,\n                 test::Cargotest,\n                 test::Cargo,\n                 test::RustAnalyzer,"}, {"sha": "72ac46b6bfdddd314b752ab9a680e34f995528a9", "filename": "src/bootstrap/builder/tests.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/87b1f891ea76713462cfc5a15137a8fe2b24ecc2/src%2Fbootstrap%2Fbuilder%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87b1f891ea76713462cfc5a15137a8fe2b24ecc2/src%2Fbootstrap%2Fbuilder%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder%2Ftests.rs?ref=87b1f891ea76713462cfc5a15137a8fe2b24ecc2", "patch": "@@ -578,7 +578,6 @@ mod dist {\n                 compiler: Compiler { host, stage: 0 },\n                 target: host,\n                 mode: Mode::Std,\n-                test_kind: test::TestKind::Test,\n                 crates: vec![INTERNER.intern_str(\"std\")],\n             },]\n         );"}, {"sha": "59d2e9cc69e796794389d35d62f2aec00d91bcda", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/87b1f891ea76713462cfc5a15137a8fe2b24ecc2/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87b1f891ea76713462cfc5a15137a8fe2b24ecc2/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=87b1f891ea76713462cfc5a15137a8fe2b24ecc2", "patch": "@@ -246,6 +246,7 @@ struct Crate {\n     name: Interned<String>,\n     deps: HashSet<Interned<String>>,\n     path: PathBuf,\n+    has_lib: bool,\n }\n \n impl Crate {"}, {"sha": "8f2c3faca3a483e99f0a2697858965a6f5d87ed0", "filename": "src/bootstrap/metadata.rs", "status": "modified", "additions": 26, "deletions": 16, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/87b1f891ea76713462cfc5a15137a8fe2b24ecc2/src%2Fbootstrap%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87b1f891ea76713462cfc5a15137a8fe2b24ecc2/src%2Fbootstrap%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fmetadata.rs?ref=87b1f891ea76713462cfc5a15137a8fe2b24ecc2", "patch": "@@ -5,7 +5,7 @@ use serde_derive::Deserialize;\n \n use crate::cache::INTERNER;\n use crate::util::output;\n-use crate::{Build, Crate};\n+use crate::{t, Build, Crate};\n \n /// For more information, see the output of\n /// <https://doc.rust-lang.org/nightly/cargo/commands/cargo-metadata.html>\n@@ -22,6 +22,7 @@ struct Package {\n     source: Option<String>,\n     manifest_path: String,\n     dependencies: Vec<Dependency>,\n+    targets: Vec<Target>,\n }\n \n /// For more information, see the output of\n@@ -32,6 +33,11 @@ struct Dependency {\n     source: Option<String>,\n }\n \n+#[derive(Debug, Deserialize)]\n+struct Target {\n+    kind: Vec<String>,\n+}\n+\n /// Collects and stores package metadata of each workspace members into `build`,\n /// by executing `cargo metadata` commands.\n pub fn build(build: &mut Build) {\n@@ -46,11 +52,16 @@ pub fn build(build: &mut Build) {\n                 .filter(|dep| dep.source.is_none())\n                 .map(|dep| INTERNER.intern_string(dep.name))\n                 .collect();\n-            let krate = Crate { name, deps, path };\n+            let has_lib = package.targets.iter().any(|t| t.kind.iter().any(|k| k == \"lib\"));\n+            let krate = Crate { name, deps, path, has_lib };\n             let relative_path = krate.local_path(build);\n             build.crates.insert(name, krate);\n             let existing_path = build.crate_paths.insert(relative_path, name);\n-            assert!(existing_path.is_none(), \"multiple crates with the same path\");\n+            assert!(\n+                existing_path.is_none(),\n+                \"multiple crates with the same path: {}\",\n+                existing_path.unwrap()\n+            );\n         }\n     }\n }\n@@ -60,29 +71,28 @@ pub fn build(build: &mut Build) {\n /// Note that `src/tools/cargo` is no longer a workspace member but we still\n /// treat it as one here, by invoking an additional `cargo metadata` command.\n fn workspace_members(build: &Build) -> impl Iterator<Item = Package> {\n-    let cmd_metadata = |manifest_path| {\n+    let collect_metadata = |manifest_path| {\n         let mut cargo = Command::new(&build.initial_cargo);\n         cargo\n             .arg(\"metadata\")\n             .arg(\"--format-version\")\n             .arg(\"1\")\n             .arg(\"--no-deps\")\n             .arg(\"--manifest-path\")\n-            .arg(manifest_path);\n-        cargo\n+            .arg(build.src.join(manifest_path));\n+        let metadata_output = output(&mut cargo);\n+        let Output { packages, .. } = t!(serde_json::from_str(&metadata_output));\n+        packages\n     };\n \n-    // Collects `metadata.packages` from the root workspace.\n-    let root_manifest_path = build.src.join(\"Cargo.toml\");\n-    let root_output = output(&mut cmd_metadata(&root_manifest_path));\n-    let Output { packages, .. } = serde_json::from_str(&root_output).unwrap();\n-\n-    // Collects `metadata.packages` from src/tools/cargo separately.\n-    let cargo_manifest_path = build.src.join(\"src/tools/cargo/Cargo.toml\");\n-    let cargo_output = output(&mut cmd_metadata(&cargo_manifest_path));\n-    let Output { packages: cargo_packages, .. } = serde_json::from_str(&cargo_output).unwrap();\n+    // Collects `metadata.packages` from all workspaces.\n+    let packages = collect_metadata(\"Cargo.toml\");\n+    let cargo_packages = collect_metadata(\"src/tools/cargo/Cargo.toml\");\n+    let ra_packages = collect_metadata(\"src/tools/rust-analyzer/Cargo.toml\");\n+    let bootstrap_packages = collect_metadata(\"src/bootstrap/Cargo.toml\");\n \n     // We only care about the root package from `src/tool/cargo` workspace.\n     let cargo_package = cargo_packages.into_iter().find(|pkg| pkg.name == \"cargo\").into_iter();\n-    packages.into_iter().chain(cargo_package)\n+\n+    packages.into_iter().chain(cargo_package).chain(ra_packages).chain(bootstrap_packages)\n }"}, {"sha": "aee84e9c9beb96d8728dc9cc3ff9e5d8a3a5711b", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 178, "deletions": 327, "changes": 505, "blob_url": "https://github.com/rust-lang/rust/blob/87b1f891ea76713462cfc5a15137a8fe2b24ecc2/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87b1f891ea76713462cfc5a15137a8fe2b24ecc2/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=87b1f891ea76713462cfc5a15137a8fe2b24ecc2", "patch": "@@ -13,6 +13,7 @@ use std::process::{Command, Stdio};\n use crate::builder::crate_description;\n use crate::builder::{Builder, Compiler, Kind, RunConfig, ShouldRun, Step};\n use crate::cache::Interned;\n+use crate::cache::INTERNER;\n use crate::compile;\n use crate::config::TargetSelection;\n use crate::dist;\n@@ -27,44 +28,6 @@ use crate::{envify, CLang, DocTests, GitRepo, Mode};\n \n const ADB_TEST_DIR: &str = \"/data/local/tmp/work\";\n \n-/// The two modes of the test runner; tests or benchmarks.\n-#[derive(Debug, PartialEq, Eq, Hash, Copy, Clone, PartialOrd, Ord)]\n-pub enum TestKind {\n-    /// Run `cargo test`.\n-    Test,\n-    /// Run `cargo bench`.\n-    Bench,\n-}\n-\n-impl From<Kind> for TestKind {\n-    fn from(kind: Kind) -> Self {\n-        match kind {\n-            Kind::Test => TestKind::Test,\n-            Kind::Bench => TestKind::Bench,\n-            _ => panic!(\"unexpected kind in crate: {:?}\", kind),\n-        }\n-    }\n-}\n-\n-impl TestKind {\n-    // Return the cargo subcommand for this test kind\n-    fn subcommand(self) -> &'static str {\n-        match self {\n-            TestKind::Test => \"test\",\n-            TestKind::Bench => \"bench\",\n-        }\n-    }\n-}\n-\n-impl Into<Kind> for TestKind {\n-    fn into(self) -> Kind {\n-        match self {\n-            TestKind::Test => Kind::Test,\n-            TestKind::Bench => Kind::Bench,\n-        }\n-    }\n-}\n-\n fn try_run(builder: &Builder<'_>, cmd: &mut Command) -> bool {\n     if !builder.fail_fast {\n         if !builder.try_run(cmd) {\n@@ -92,74 +55,56 @@ fn try_run_quiet(builder: &Builder<'_>, cmd: &mut Command) -> bool {\n }\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct CrateJsonDocLint {\n+pub struct CrateBootstrap {\n+    path: Interned<PathBuf>,\n     host: TargetSelection,\n }\n \n-impl Step for CrateJsonDocLint {\n+impl Step for CrateBootstrap {\n     type Output = ();\n     const ONLY_HOSTS: bool = true;\n     const DEFAULT: bool = true;\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         run.path(\"src/tools/jsondoclint\")\n+            .path(\"src/tools/suggest-tests\")\n+            .path(\"src/tools/replace-version-placeholder\")\n+            .alias(\"tidyselftest\")\n     }\n \n     fn make_run(run: RunConfig<'_>) {\n-        run.builder.ensure(CrateJsonDocLint { host: run.target });\n+        for path in run.paths {\n+            let path = INTERNER.intern_path(path.assert_single_path().path.clone());\n+            run.builder.ensure(CrateBootstrap { host: run.target, path });\n+        }\n     }\n \n     fn run(self, builder: &Builder<'_>) {\n         let bootstrap_host = builder.config.build;\n         let compiler = builder.compiler(0, bootstrap_host);\n+        let mut path = self.path.to_str().unwrap();\n+        if path == \"tidyselftest\" {\n+            path = \"src/tools/tidy\";\n+        }\n \n         let cargo = tool::prepare_tool_cargo(\n             builder,\n             compiler,\n             Mode::ToolBootstrap,\n             bootstrap_host,\n             \"test\",\n-            \"src/tools/jsondoclint\",\n+            path,\n             SourceType::InTree,\n             &[],\n         );\n-        add_flags_and_try_run_tests(builder, &mut cargo.into());\n-    }\n-}\n-\n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct SuggestTestsCrate {\n-    host: TargetSelection,\n-}\n-\n-impl Step for SuggestTestsCrate {\n-    type Output = ();\n-    const ONLY_HOSTS: bool = true;\n-    const DEFAULT: bool = true;\n-\n-    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n-        run.path(\"src/tools/suggest-tests\")\n-    }\n-\n-    fn make_run(run: RunConfig<'_>) {\n-        run.builder.ensure(SuggestTestsCrate { host: run.target });\n-    }\n-\n-    fn run(self, builder: &Builder<'_>) {\n-        let bootstrap_host = builder.config.build;\n-        let compiler = builder.compiler(0, bootstrap_host);\n-\n-        let suggest_tests = tool::prepare_tool_cargo(\n-            builder,\n-            compiler,\n-            Mode::ToolBootstrap,\n+        builder.info(&format!(\n+            \"{} {} stage0 ({})\",\n+            builder.kind.test_description(),\n+            path,\n             bootstrap_host,\n-            \"test\",\n-            \"src/tools/suggest-tests\",\n-            SourceType::InTree,\n-            &[],\n-        );\n-        add_flags_and_try_run_tests(builder, &mut suggest_tests.into());\n+        ));\n+        let crate_name = path.rsplit_once('/').unwrap().1;\n+        run_cargo_test(cargo, &[], &[], crate_name, compiler, bootstrap_host, builder);\n     }\n }\n \n@@ -208,7 +153,11 @@ You can skip linkcheck with --exclude src/tools/linkchecker\"\n             SourceType::InTree,\n             &[],\n         );\n-        add_flags_and_try_run_tests(builder, &mut cargo.into());\n+        run_cargo_test(cargo, &[], &[], \"linkchecker\", compiler, bootstrap_host, builder);\n+\n+        if builder.doc_tests == DocTests::No {\n+            return;\n+        }\n \n         // Build all the default documentation.\n         builder.default_doc(&[]);\n@@ -344,7 +293,7 @@ impl Step for Cargo {\n         let compiler = builder.compiler(self.stage, self.host);\n \n         builder.ensure(tool::Cargo { compiler, target: self.host });\n-        let mut cargo = tool::prepare_tool_cargo(\n+        let cargo = tool::prepare_tool_cargo(\n             builder,\n             compiler,\n             Mode::ToolRustc,\n@@ -355,21 +304,19 @@ impl Step for Cargo {\n             &[],\n         );\n \n-        if !builder.fail_fast {\n-            cargo.arg(\"--no-fail-fast\");\n-        }\n-        cargo.arg(\"--\").args(builder.config.cmd.test_args());\n+        // NOTE: can't use `run_cargo_test` because we need to overwrite `PATH`\n+        let mut cargo = prepare_cargo_test(cargo, &[], &[], \"cargo\", compiler, self.host, builder);\n \n         // Don't run cross-compile tests, we may not have cross-compiled libstd libs\n         // available.\n         cargo.env(\"CFG_DISABLE_CROSS_TESTS\", \"1\");\n         // Forcibly disable tests using nightly features since any changes to\n         // those features won't be able to land.\n         cargo.env(\"CARGO_TEST_DISABLE_NIGHTLY\", \"1\");\n-\n         cargo.env(\"PATH\", &path_for_cargo(builder, compiler));\n \n-        add_flags_and_try_run_tests(builder, &mut cargo.into());\n+        let _time = util::timeit(&builder);\n+        add_flags_and_try_run_tests(builder, &mut cargo);\n     }\n }\n \n@@ -426,9 +373,7 @@ impl Step for RustAnalyzer {\n         cargo.env(\"SKIP_SLOW_TESTS\", \"1\");\n \n         cargo.add_rustc_lib_path(builder, compiler);\n-        cargo.arg(\"--\").args(builder.config.cmd.test_args());\n-\n-        add_flags_and_try_run_tests(builder, &mut cargo.into());\n+        run_cargo_test(cargo, &[], &[], \"rust-analyzer\", compiler, host, builder);\n     }\n }\n \n@@ -471,17 +416,13 @@ impl Step for Rustfmt {\n             &[],\n         );\n \n-        if !builder.fail_fast {\n-            cargo.arg(\"--no-fail-fast\");\n-        }\n-\n         let dir = testdir(builder, compiler.host);\n         t!(fs::create_dir_all(&dir));\n         cargo.env(\"RUSTFMT_TEST_DIR\", dir);\n \n         cargo.add_rustc_lib_path(builder, compiler);\n \n-        add_flags_and_try_run_tests(builder, &mut cargo.into());\n+        run_cargo_test(cargo, &[], &[], \"rustfmt\", compiler, host, builder);\n     }\n }\n \n@@ -527,12 +468,9 @@ impl Step for RustDemangler {\n         t!(fs::create_dir_all(&dir));\n \n         cargo.env(\"RUST_DEMANGLER_DRIVER_PATH\", rust_demangler);\n-\n-        cargo.arg(\"--\").args(builder.config.cmd.test_args());\n-\n         cargo.add_rustc_lib_path(builder, compiler);\n \n-        add_flags_and_try_run_tests(builder, &mut cargo.into());\n+        run_cargo_test(cargo, &[], &[], \"rust-demangler\", compiler, host, builder);\n     }\n }\n \n@@ -655,10 +593,6 @@ impl Step for Miri {\n         );\n         cargo.add_rustc_lib_path(builder, compiler);\n \n-        if !builder.fail_fast {\n-            cargo.arg(\"--no-fail-fast\");\n-        }\n-\n         // miri tests need to know about the stage sysroot\n         cargo.env(\"MIRI_SYSROOT\", &miri_sysroot);\n         cargo.env(\"MIRI_HOST_SYSROOT\", sysroot);\n@@ -670,13 +604,14 @@ impl Step for Miri {\n \n         // Set the target.\n         cargo.env(\"MIRI_TEST_TARGET\", target.rustc_target_arg());\n-        // Forward test filters.\n-        cargo.arg(\"--\").args(builder.config.cmd.test_args());\n \n-        // This can NOT be `add_flags_and_try_run_tests` since the Miri test runner\n-        // does not understand those flags!\n-        let mut cargo = Command::from(cargo);\n-        builder.run(&mut cargo);\n+        // This can NOT be `run_cargo_test` since the Miri test runner\n+        // does not understand the flags added by `add_flags_and_try_run_test`.\n+        let mut cargo = prepare_cargo_test(cargo, &[], &[], \"miri\", compiler, target, builder);\n+        {\n+            let _time = util::timeit(&builder);\n+            builder.run(&mut cargo);\n+        }\n \n         // # Run `cargo miri test`.\n         // This is just a smoke test (Miri's own CI invokes this in a bunch of different ways and ensures\n@@ -709,6 +644,7 @@ impl Step for Miri {\n         cargo.env(\"RUST_BACKTRACE\", \"1\");\n \n         let mut cargo = Command::from(cargo);\n+        let _time = util::timeit(&builder);\n         builder.run(&mut cargo);\n     }\n }\n@@ -748,8 +684,7 @@ impl Step for CompiletestTest {\n             &[],\n         );\n         cargo.allow_features(\"test\");\n-\n-        add_flags_and_try_run_tests(builder, &mut cargo.into());\n+        run_cargo_test(cargo, &[], &[], \"compiletest\", compiler, host, builder);\n     }\n }\n \n@@ -792,20 +727,15 @@ impl Step for Clippy {\n             &[],\n         );\n \n-        if !builder.fail_fast {\n-            cargo.arg(\"--no-fail-fast\");\n-        }\n-\n         cargo.env(\"RUSTC_TEST_SUITE\", builder.rustc(compiler));\n         cargo.env(\"RUSTC_LIB_PATH\", builder.rustc_libdir(compiler));\n         let host_libs = builder.stage_out(compiler, Mode::ToolRustc).join(builder.cargo_dir());\n         cargo.env(\"HOST_LIBS\", host_libs);\n \n-        cargo.arg(\"--\").args(builder.config.cmd.test_args());\n-\n         cargo.add_rustc_lib_path(builder, compiler);\n+        let mut cargo = prepare_cargo_test(cargo, &[], &[], \"clippy\", compiler, host, builder);\n \n-        if builder.try_run(&mut cargo.into()) {\n+        if builder.try_run(&mut cargo) {\n             // The tests succeeded; nothing to do.\n             return;\n         }\n@@ -1203,40 +1133,6 @@ help: to skip test's attempt to check tidiness, pass `--exclude src/tools/tidy`\n     }\n }\n \n-/// Runs tidy's own tests.\n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct TidySelfTest;\n-\n-impl Step for TidySelfTest {\n-    type Output = ();\n-    const DEFAULT: bool = true;\n-    const ONLY_HOSTS: bool = true;\n-\n-    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n-        run.alias(\"tidyselftest\")\n-    }\n-\n-    fn make_run(run: RunConfig<'_>) {\n-        run.builder.ensure(TidySelfTest);\n-    }\n-\n-    fn run(self, builder: &Builder<'_>) {\n-        let bootstrap_host = builder.config.build;\n-        let compiler = builder.compiler(0, bootstrap_host);\n-        let cargo = tool::prepare_tool_cargo(\n-            builder,\n-            compiler,\n-            Mode::ToolBootstrap,\n-            bootstrap_host,\n-            \"test\",\n-            \"src/tools/tidy\",\n-            SourceType::InTree,\n-            &[],\n-        );\n-        add_flags_and_try_run_tests(builder, &mut cargo.into());\n-    }\n-}\n-\n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct ExpandYamlAnchors;\n \n@@ -2111,7 +2007,6 @@ impl Step for RustcGuide {\n pub struct CrateLibrustc {\n     compiler: Compiler,\n     target: TargetSelection,\n-    test_kind: TestKind,\n     crates: Vec<Interned<String>>,\n }\n \n@@ -2133,28 +2028,115 @@ impl Step for CrateLibrustc {\n             .iter()\n             .map(|p| builder.crate_paths[&p.assert_single_path().path].clone())\n             .collect();\n-        let test_kind = builder.kind.into();\n \n-        builder.ensure(CrateLibrustc { compiler, target: run.target, test_kind, crates });\n+        builder.ensure(CrateLibrustc { compiler, target: run.target, crates });\n     }\n \n     fn run(self, builder: &Builder<'_>) {\n         builder.ensure(Crate {\n             compiler: self.compiler,\n             target: self.target,\n             mode: Mode::Rustc,\n-            test_kind: self.test_kind,\n             crates: self.crates,\n         });\n     }\n }\n \n+/// Given a `cargo test` subcommand, add the appropriate flags and run it.\n+///\n+/// Returns whether the test succeeded.\n+fn run_cargo_test(\n+    cargo: impl Into<Command>,\n+    libtest_args: &[&str],\n+    crates: &[Interned<String>],\n+    primary_crate: &str,\n+    compiler: Compiler,\n+    target: TargetSelection,\n+    builder: &Builder<'_>,\n+) -> bool {\n+    let mut cargo =\n+        prepare_cargo_test(cargo, libtest_args, crates, primary_crate, compiler, target, builder);\n+    let _time = util::timeit(&builder);\n+    add_flags_and_try_run_tests(builder, &mut cargo)\n+}\n+\n+/// Given a `cargo test` subcommand, pass it the appropriate test flags given a `builder`.\n+fn prepare_cargo_test(\n+    cargo: impl Into<Command>,\n+    libtest_args: &[&str],\n+    crates: &[Interned<String>],\n+    primary_crate: &str,\n+    compiler: Compiler,\n+    target: TargetSelection,\n+    builder: &Builder<'_>,\n+) -> Command {\n+    let mut cargo = cargo.into();\n+\n+    // Pass in some standard flags then iterate over the graph we've discovered\n+    // in `cargo metadata` with the maps above and figure out what `-p`\n+    // arguments need to get passed.\n+    if builder.kind == Kind::Test && !builder.fail_fast {\n+        cargo.arg(\"--no-fail-fast\");\n+    }\n+    match builder.doc_tests {\n+        DocTests::Only => {\n+            cargo.arg(\"--doc\");\n+        }\n+        DocTests::No => {\n+            let krate = &builder\n+                .crates\n+                .get(&INTERNER.intern_str(primary_crate))\n+                .unwrap_or_else(|| panic!(\"missing crate {primary_crate}\"));\n+            if krate.has_lib {\n+                cargo.arg(\"--lib\");\n+            }\n+            cargo.args(&[\"--bins\", \"--examples\", \"--tests\", \"--benches\"]);\n+        }\n+        DocTests::Yes => {}\n+    }\n+\n+    for &krate in crates {\n+        cargo.arg(\"-p\").arg(krate);\n+    }\n+\n+    cargo.arg(\"--\").args(&builder.config.cmd.test_args()).args(libtest_args);\n+    if !builder.config.verbose_tests {\n+        cargo.arg(\"--quiet\");\n+    }\n+\n+    // The tests are going to run with the *target* libraries, so we need to\n+    // ensure that those libraries show up in the LD_LIBRARY_PATH equivalent.\n+    //\n+    // Note that to run the compiler we need to run with the *host* libraries,\n+    // but our wrapper scripts arrange for that to be the case anyway.\n+    let mut dylib_path = dylib_path();\n+    dylib_path.insert(0, PathBuf::from(&*builder.sysroot_libdir(compiler, target)));\n+    cargo.env(dylib_path_var(), env::join_paths(&dylib_path).unwrap());\n+\n+    if target.contains(\"emscripten\") {\n+        cargo.env(\n+            format!(\"CARGO_TARGET_{}_RUNNER\", envify(&target.triple)),\n+            builder.config.nodejs.as_ref().expect(\"nodejs not configured\"),\n+        );\n+    } else if target.starts_with(\"wasm32\") {\n+        let node = builder.config.nodejs.as_ref().expect(\"nodejs not configured\");\n+        let runner = format!(\"{} {}/src/etc/wasm32-shim.js\", node.display(), builder.src.display());\n+        cargo.env(format!(\"CARGO_TARGET_{}_RUNNER\", envify(&target.triple)), &runner);\n+    } else if builder.remote_tested(target) {\n+        cargo.env(\n+            format!(\"CARGO_TARGET_{}_RUNNER\", envify(&target.triple)),\n+            format!(\"{} run 0\", builder.tool_exe(Tool::RemoteTestClient).display()),\n+        );\n+    }\n+\n+    cargo\n+}\n+\n #[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub struct Crate {\n     pub compiler: Compiler,\n     pub target: TargetSelection,\n     pub mode: Mode,\n-    pub test_kind: TestKind,\n     pub crates: Vec<Interned<String>>,\n }\n \n@@ -2170,14 +2152,13 @@ impl Step for Crate {\n         let builder = run.builder;\n         let host = run.build_triple();\n         let compiler = builder.compiler_for(builder.top_stage, host, host);\n-        let test_kind = builder.kind.into();\n         let crates = run\n             .paths\n             .iter()\n             .map(|p| builder.crate_paths[&p.assert_single_path().path].clone())\n             .collect();\n \n-        builder.ensure(Crate { compiler, target: run.target, mode: Mode::Std, test_kind, crates });\n+        builder.ensure(Crate { compiler, target: run.target, mode: Mode::Std, crates });\n     }\n \n     /// Runs all unit tests plus documentation tests for a given crate defined\n@@ -2192,7 +2173,6 @@ impl Step for Crate {\n         let compiler = self.compiler;\n         let target = self.target;\n         let mode = self.mode;\n-        let test_kind = self.test_kind;\n \n         builder.ensure(compile::Std::new(compiler, target));\n         builder.ensure(RemoteCopyLibs { compiler, target });\n@@ -2204,7 +2184,7 @@ impl Step for Crate {\n         let compiler = builder.compiler_for(compiler.stage, compiler.host, target);\n \n         let mut cargo =\n-            builder.cargo(compiler, mode, SourceType::InTree, target, test_kind.subcommand());\n+            builder.cargo(compiler, mode, SourceType::InTree, target, builder.kind.as_str());\n         match mode {\n             Mode::Std => {\n                 compile::std_cargo(builder, target, compiler.stage, &mut cargo);\n@@ -2215,77 +2195,21 @@ impl Step for Crate {\n             _ => panic!(\"can only test libraries\"),\n         };\n \n-        // Build up the base `cargo test` command.\n-        //\n-        // Pass in some standard flags then iterate over the graph we've discovered\n-        // in `cargo metadata` with the maps above and figure out what `-p`\n-        // arguments need to get passed.\n-        if test_kind.subcommand() == \"test\" && !builder.fail_fast {\n-            cargo.arg(\"--no-fail-fast\");\n-        }\n-        match builder.doc_tests {\n-            DocTests::Only => {\n-                cargo.arg(\"--doc\");\n-            }\n-            DocTests::No => {\n-                cargo.args(&[\"--lib\", \"--bins\", \"--examples\", \"--tests\", \"--benches\"]);\n-            }\n-            DocTests::Yes => {}\n-        }\n-\n-        for krate in &self.crates {\n-            cargo.arg(\"-p\").arg(krate);\n-        }\n-\n-        // The tests are going to run with the *target* libraries, so we need to\n-        // ensure that those libraries show up in the LD_LIBRARY_PATH equivalent.\n-        //\n-        // Note that to run the compiler we need to run with the *host* libraries,\n-        // but our wrapper scripts arrange for that to be the case anyway.\n-        let mut dylib_path = dylib_path();\n-        dylib_path.insert(0, PathBuf::from(&*builder.sysroot_libdir(compiler, target)));\n-        cargo.env(dylib_path_var(), env::join_paths(&dylib_path).unwrap());\n-\n-        cargo.arg(\"--\");\n-        cargo.args(&builder.config.cmd.test_args());\n-\n-        cargo.arg(\"-Z\").arg(\"unstable-options\");\n-        cargo.arg(\"--format\").arg(\"json\");\n-\n-        if target.contains(\"emscripten\") {\n-            cargo.env(\n-                format!(\"CARGO_TARGET_{}_RUNNER\", envify(&target.triple)),\n-                builder.config.nodejs.as_ref().expect(\"nodejs not configured\"),\n-            );\n-        } else if target.starts_with(\"wasm32\") {\n-            let node = builder.config.nodejs.as_ref().expect(\"nodejs not configured\");\n-            let runner =\n-                format!(\"{} {}/src/etc/wasm32-shim.js\", node.display(), builder.src.display());\n-            cargo.env(format!(\"CARGO_TARGET_{}_RUNNER\", envify(&target.triple)), &runner);\n-        } else if builder.remote_tested(target) {\n-            cargo.env(\n-                format!(\"CARGO_TARGET_{}_RUNNER\", envify(&target.triple)),\n-                format!(\"{} run 0\", builder.tool_exe(Tool::RemoteTestClient).display()),\n-            );\n-        }\n-\n         let _guard = builder.msg(\n-            test_kind,\n+            builder.kind,\n             compiler.stage,\n             crate_description(&self.crates),\n             compiler.host,\n             target,\n         );\n-        let _time = util::timeit(&builder);\n-        crate::render_tests::try_run_tests(builder, &mut cargo.into());\n+        run_cargo_test(cargo, &[], &self.crates, &self.crates[0], compiler, target, builder);\n     }\n }\n \n /// Rustdoc is special in various ways, which is why this step is different from `Crate`.\n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct CrateRustdoc {\n     host: TargetSelection,\n-    test_kind: TestKind,\n }\n \n impl Step for CrateRustdoc {\n@@ -2300,13 +2224,10 @@ impl Step for CrateRustdoc {\n     fn make_run(run: RunConfig<'_>) {\n         let builder = run.builder;\n \n-        let test_kind = builder.kind.into();\n-\n-        builder.ensure(CrateRustdoc { host: run.target, test_kind });\n+        builder.ensure(CrateRustdoc { host: run.target });\n     }\n \n     fn run(self, builder: &Builder<'_>) {\n-        let test_kind = self.test_kind;\n         let target = self.host;\n \n         let compiler = if builder.download_rustc() {\n@@ -2325,29 +2246,11 @@ impl Step for CrateRustdoc {\n             compiler,\n             Mode::ToolRustc,\n             target,\n-            test_kind.subcommand(),\n+            builder.kind.as_str(),\n             \"src/tools/rustdoc\",\n             SourceType::InTree,\n             &[],\n         );\n-        if test_kind.subcommand() == \"test\" && !builder.fail_fast {\n-            cargo.arg(\"--no-fail-fast\");\n-        }\n-        match builder.doc_tests {\n-            DocTests::Only => {\n-                cargo.arg(\"--doc\");\n-            }\n-            DocTests::No => {\n-                cargo.args(&[\"--lib\", \"--bins\", \"--examples\", \"--tests\", \"--benches\"]);\n-            }\n-            DocTests::Yes => {}\n-        }\n-\n-        cargo.arg(\"-p\").arg(\"rustdoc:0.0.0\");\n-\n-        cargo.arg(\"--\");\n-        cargo.args(&builder.config.cmd.test_args());\n-\n         if self.host.contains(\"musl\") {\n             cargo.arg(\"'-Ctarget-feature=-crt-static'\");\n         }\n@@ -2387,22 +2290,22 @@ impl Step for CrateRustdoc {\n         dylib_path.insert(0, PathBuf::from(&*libdir));\n         cargo.env(dylib_path_var(), env::join_paths(&dylib_path).unwrap());\n \n-        if !builder.config.verbose_tests {\n-            cargo.arg(\"--quiet\");\n-        }\n-\n-        let _guard = builder.msg(test_kind, compiler.stage, \"rustdoc\", compiler.host, target);\n-\n-        let _time = util::timeit(&builder);\n-\n-        add_flags_and_try_run_tests(builder, &mut cargo.into());\n+        let _guard = builder.msg(builder.kind, compiler.stage, \"rustdoc\", compiler.host, target);\n+        run_cargo_test(\n+            cargo,\n+            &[],\n+            &[INTERNER.intern_str(\"rustdoc:0.0.0\")],\n+            \"rustdoc\",\n+            compiler,\n+            target,\n+            builder,\n+        );\n     }\n }\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct CrateRustdocJsonTypes {\n     host: TargetSelection,\n-    test_kind: TestKind,\n }\n \n impl Step for CrateRustdocJsonTypes {\n@@ -2417,13 +2320,10 @@ impl Step for CrateRustdocJsonTypes {\n     fn make_run(run: RunConfig<'_>) {\n         let builder = run.builder;\n \n-        let test_kind = builder.kind.into();\n-\n-        builder.ensure(CrateRustdocJsonTypes { host: run.target, test_kind });\n+        builder.ensure(CrateRustdocJsonTypes { host: run.target });\n     }\n \n     fn run(self, builder: &Builder<'_>) {\n-        let test_kind = self.test_kind;\n         let target = self.host;\n \n         // Use the previous stage compiler to reuse the artifacts that are\n@@ -2433,34 +2333,35 @@ impl Step for CrateRustdocJsonTypes {\n         let compiler = builder.compiler_for(builder.top_stage, target, target);\n         builder.ensure(compile::Rustc::new(compiler, target));\n \n-        let mut cargo = tool::prepare_tool_cargo(\n+        let cargo = tool::prepare_tool_cargo(\n             builder,\n             compiler,\n             Mode::ToolRustc,\n             target,\n-            test_kind.subcommand(),\n+            builder.kind.as_str(),\n             \"src/rustdoc-json-types\",\n             SourceType::InTree,\n             &[],\n         );\n-        if test_kind.subcommand() == \"test\" && !builder.fail_fast {\n-            cargo.arg(\"--no-fail-fast\");\n-        }\n-\n-        cargo.arg(\"-p\").arg(\"rustdoc-json-types\");\n-\n-        cargo.arg(\"--\");\n-        cargo.args(&builder.config.cmd.test_args());\n \n-        if self.host.contains(\"musl\") {\n-            cargo.arg(\"'-Ctarget-feature=-crt-static'\");\n-        }\n+        // FIXME: this looks very wrong, libtest doesn't accept `-C` arguments and the quotes are fishy.\n+        let libtest_args = if self.host.contains(\"musl\") {\n+            [\"'-Ctarget-feature=-crt-static'\"].as_slice()\n+        } else {\n+            &[]\n+        };\n \n         let _guard =\n-            builder.msg(test_kind, compiler.stage, \"rustdoc-json-types\", compiler.host, target);\n-        let _time = util::timeit(&builder);\n-\n-        add_flags_and_try_run_tests(builder, &mut cargo.into());\n+            builder.msg(builder.kind, compiler.stage, \"rustdoc-json-types\", compiler.host, target);\n+        run_cargo_test(\n+            cargo,\n+            libtest_args,\n+            &[INTERNER.intern_str(\"rustdoc-json-types\")],\n+            \"rustdoc-json-types\",\n+            compiler,\n+            target,\n+            builder,\n+        );\n     }\n }\n \n@@ -2598,38 +2499,25 @@ impl Step for Bootstrap {\n         check_bootstrap.arg(\"bootstrap_test.py\").current_dir(builder.src.join(\"src/bootstrap/\"));\n         try_run(builder, &mut check_bootstrap);\n \n+        let host = builder.config.build;\n+        let compiler = builder.compiler(0, host);\n         let mut cmd = Command::new(&builder.initial_cargo);\n         cmd.arg(\"test\")\n             .current_dir(builder.src.join(\"src/bootstrap\"))\n             .env(\"RUSTFLAGS\", \"-Cdebuginfo=2\")\n             .env(\"CARGO_TARGET_DIR\", builder.out.join(\"bootstrap\"))\n             .env(\"RUSTC_BOOTSTRAP\", \"1\")\n-            .env(\"RUSTDOC\", builder.rustdoc(builder.compiler(0, builder.build.build)))\n+            .env(\"RUSTDOC\", builder.rustdoc(compiler))\n             .env(\"RUSTC\", &builder.initial_rustc);\n         if let Some(flags) = option_env!(\"RUSTFLAGS\") {\n             // Use the same rustc flags for testing as for \"normal\" compilation,\n             // so that Cargo doesn\u2019t recompile the entire dependency graph every time:\n             // https://github.com/rust-lang/rust/issues/49215\n             cmd.env(\"RUSTFLAGS\", flags);\n         }\n-        if !builder.fail_fast {\n-            cmd.arg(\"--no-fail-fast\");\n-        }\n-        match builder.doc_tests {\n-            DocTests::Only => {\n-                cmd.arg(\"--doc\");\n-            }\n-            DocTests::No => {\n-                cmd.args(&[\"--lib\", \"--bins\", \"--examples\", \"--tests\", \"--benches\"]);\n-            }\n-            DocTests::Yes => {}\n-        }\n-\n-        cmd.arg(\"--\").args(&builder.config.cmd.test_args());\n         // rustbuild tests are racy on directory creation so just run them one at a time.\n         // Since there's not many this shouldn't be a problem.\n-        cmd.arg(\"--test-threads=1\");\n-        add_flags_and_try_run_tests(builder, &mut cmd);\n+        run_cargo_test(cmd, &[\"--test-threads=1\"], &[], \"bootstrap\", compiler, host, builder);\n     }\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n@@ -2685,43 +2573,6 @@ impl Step for TierCheck {\n     }\n }\n \n-#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n-pub struct ReplacePlaceholderTest;\n-\n-impl Step for ReplacePlaceholderTest {\n-    type Output = ();\n-    const ONLY_HOSTS: bool = true;\n-    const DEFAULT: bool = true;\n-\n-    /// Ensure the version placeholder replacement tool builds\n-    fn run(self, builder: &Builder<'_>) {\n-        builder.info(\"build check for version replacement placeholder\");\n-\n-        // Test the version placeholder replacement tool itself.\n-        let bootstrap_host = builder.config.build;\n-        let compiler = builder.compiler(0, bootstrap_host);\n-        let cargo = tool::prepare_tool_cargo(\n-            builder,\n-            compiler,\n-            Mode::ToolBootstrap,\n-            bootstrap_host,\n-            \"test\",\n-            \"src/tools/replace-version-placeholder\",\n-            SourceType::InTree,\n-            &[],\n-        );\n-        add_flags_and_try_run_tests(builder, &mut cargo.into());\n-    }\n-\n-    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n-        run.path(\"src/tools/replace-version-placeholder\")\n-    }\n-\n-    fn make_run(run: RunConfig<'_>) {\n-        run.builder.ensure(Self);\n-    }\n-}\n-\n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct LintDocs {\n     pub compiler: Compiler,\n@@ -2779,7 +2630,7 @@ impl Step for RustInstaller {\n             SourceType::InTree,\n             &[],\n         );\n-        try_run(builder, &mut cargo.into());\n+        run_cargo_test(cargo, &[], &[], \"installer\", compiler, bootstrap_host, builder);\n \n         // We currently don't support running the test.sh script outside linux(?) environments.\n         // Eventually this should likely migrate to #[test]s in rust-installer proper rather than a"}, {"sha": "39f6369b4d3f5fe747aa85adc313730f1958f2de", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/87b1f891ea76713462cfc5a15137a8fe2b24ecc2/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/87b1f891ea76713462cfc5a15137a8fe2b24ecc2/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=87b1f891ea76713462cfc5a15137a8fe2b24ecc2", "patch": "@@ -141,7 +141,7 @@ pub fn prepare_tool_cargo(\n     mode: Mode,\n     target: TargetSelection,\n     command: &'static str,\n-    path: &'static str,\n+    path: &str,\n     source_type: SourceType,\n     extra_features: &[String],\n ) -> CargoCommand {"}]}