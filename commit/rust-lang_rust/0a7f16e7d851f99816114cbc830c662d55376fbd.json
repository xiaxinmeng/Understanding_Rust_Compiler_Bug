{"sha": "0a7f16e7d851f99816114cbc830c662d55376fbd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBhN2YxNmU3ZDg1MWY5OTgxNjExNGNiYzgzMGM2NjJkNTUzNzZmYmQ=", "commit": {"author": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-02-15T12:11:59Z"}, "committer": {"name": "Matthew Jasper", "email": "mjjasper1@gmail.com", "date": "2020-03-17T09:07:56Z"}, "message": "Erase regions in writeback\n\nAlso skip duplicated region solving entirely with `-Zborrowck=mir`.", "tree": {"sha": "96c82e5e86c6658519be36698a6e33eb009da95a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/96c82e5e86c6658519be36698a6e33eb009da95a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0a7f16e7d851f99816114cbc830c662d55376fbd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0a7f16e7d851f99816114cbc830c662d55376fbd", "html_url": "https://github.com/rust-lang/rust/commit/0a7f16e7d851f99816114cbc830c662d55376fbd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0a7f16e7d851f99816114cbc830c662d55376fbd/comments", "author": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matthewjasper", "id": 20113453, "node_id": "MDQ6VXNlcjIwMTEzNDUz", "avatar_url": "https://avatars.githubusercontent.com/u/20113453?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthewjasper", "html_url": "https://github.com/matthewjasper", "followers_url": "https://api.github.com/users/matthewjasper/followers", "following_url": "https://api.github.com/users/matthewjasper/following{/other_user}", "gists_url": "https://api.github.com/users/matthewjasper/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthewjasper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthewjasper/subscriptions", "organizations_url": "https://api.github.com/users/matthewjasper/orgs", "repos_url": "https://api.github.com/users/matthewjasper/repos", "events_url": "https://api.github.com/users/matthewjasper/events{/privacy}", "received_events_url": "https://api.github.com/users/matthewjasper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cefd0305b1e67ad95f86c273e5cf76f189a7206e", "url": "https://api.github.com/repos/rust-lang/rust/commits/cefd0305b1e67ad95f86c273e5cf76f189a7206e", "html_url": "https://github.com/rust-lang/rust/commit/cefd0305b1e67ad95f86c273e5cf76f189a7206e"}], "stats": {"total": 167, "additions": 103, "deletions": 64}, "files": [{"sha": "ebbfcb28db2f533244821293bf8f538c69f581c6", "filename": "src/librustc_infer/infer/error_reporting/mod.rs", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0a7f16e7d851f99816114cbc830c662d55376fbd/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a7f16e7d851f99816114cbc830c662d55376fbd/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs?ref=0a7f16e7d851f99816114cbc830c662d55376fbd", "patch": "@@ -49,7 +49,7 @@ use super::lexical_region_resolve::RegionResolutionError;\n use super::region_constraints::GenericKind;\n use super::{InferCtxt, RegionVariableOrigin, SubregionOrigin, TypeTrace, ValuePairs};\n \n-use crate::infer::{self, SuppressRegionErrors};\n+use crate::infer;\n use crate::traits::error_reporting::report_object_safety_error;\n use crate::traits::{\n     IfExpressionCause, MatchExpressionArmCause, ObligationCause, ObligationCauseCode,\n@@ -372,17 +372,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         &self,\n         region_scope_tree: &region::ScopeTree,\n         errors: &Vec<RegionResolutionError<'tcx>>,\n-        suppress: SuppressRegionErrors,\n     ) {\n-        debug!(\n-            \"report_region_errors(): {} errors to start, suppress = {:?}\",\n-            errors.len(),\n-            suppress\n-        );\n-\n-        if suppress.suppressed() {\n-            return;\n-        }\n+        debug!(\"report_region_errors(): {} errors to start\", errors.len());\n \n         // try to pre-process the errors, which will group some of them\n         // together into a `ProcessedErrors` group:"}, {"sha": "3af10e850d534fe2c3112c58339f7075672fdfbb", "filename": "src/librustc_infer/infer/lexical_region_resolve/mod.rs", "status": "modified", "additions": 33, "deletions": 2, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/0a7f16e7d851f99816114cbc830c662d55376fbd/src%2Flibrustc_infer%2Finfer%2Flexical_region_resolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a7f16e7d851f99816114cbc830c662d55376fbd/src%2Flibrustc_infer%2Finfer%2Flexical_region_resolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Flexical_region_resolve%2Fmod.rs?ref=0a7f16e7d851f99816114cbc830c662d55376fbd", "patch": "@@ -7,6 +7,7 @@ use crate::infer::region_constraints::RegionConstraintData;\n use crate::infer::region_constraints::VarInfos;\n use crate::infer::region_constraints::VerifyBound;\n use crate::infer::RegionVariableOrigin;\n+use crate::infer::RegionckMode;\n use crate::infer::SubregionOrigin;\n use rustc::middle::free_region::RegionRelations;\n use rustc::ty::fold::TypeFoldable;\n@@ -33,12 +34,29 @@ pub fn resolve<'tcx>(\n     region_rels: &RegionRelations<'_, 'tcx>,\n     var_infos: VarInfos,\n     data: RegionConstraintData<'tcx>,\n+    mode: RegionckMode,\n ) -> (LexicalRegionResolutions<'tcx>, Vec<RegionResolutionError<'tcx>>) {\n     debug!(\"RegionConstraintData: resolve_regions()\");\n     let mut errors = vec![];\n     let mut resolver = LexicalResolver { region_rels, var_infos, data };\n-    let values = resolver.infer_variable_values(&mut errors);\n-    (values, errors)\n+    match mode {\n+        RegionckMode::Solve => {\n+            let values = resolver.infer_variable_values(&mut errors);\n+            (values, errors)\n+        }\n+        RegionckMode::Erase { suppress_errors: false } => {\n+            // Do real inference to get errors, then erase the results.\n+            let mut values = resolver.infer_variable_values(&mut errors);\n+            let re_erased = region_rels.tcx.lifetimes.re_erased;\n+\n+            values.values.iter_mut().for_each(|v| *v = VarValue::Value(re_erased));\n+            (values, errors)\n+        }\n+        RegionckMode::Erase { suppress_errors: true } => {\n+            // Skip region inference entirely.\n+            (resolver.erased_data(region_rels.tcx), Vec::new())\n+        }\n+    }\n }\n \n /// Contains the result of lexical region resolution. Offers methods\n@@ -163,6 +181,19 @@ impl<'cx, 'tcx> LexicalResolver<'cx, 'tcx> {\n         }\n     }\n \n+    /// An erased version of the lexical region resolutions. Used when we're\n+    /// erasing regions and suppressing errors: in item bodies with\n+    /// `-Zborrowck=mir`.\n+    fn erased_data(&self, tcx: TyCtxt<'tcx>) -> LexicalRegionResolutions<'tcx> {\n+        LexicalRegionResolutions {\n+            error_region: tcx.lifetimes.re_static,\n+            values: IndexVec::from_elem_n(\n+                VarValue::Value(tcx.lifetimes.re_erased),\n+                self.num_vars(),\n+            ),\n+        }\n+    }\n+\n     fn dump_constraints(&self, free_regions: &RegionRelations<'_, 'tcx>) {\n         debug!(\"----() Start constraint listing (context={:?}) ()----\", free_regions.context);\n         for (idx, (constraint, _)) in self.data.constraints.iter().enumerate() {"}, {"sha": "c5f06d53b8f73d4ad2952d94b2fade858b00ce9a", "filename": "src/librustc_infer/infer/mod.rs", "status": "modified", "additions": 41, "deletions": 21, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/0a7f16e7d851f99816114cbc830c662d55376fbd/src%2Flibrustc_infer%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a7f16e7d851f99816114cbc830c662d55376fbd/src%2Flibrustc_infer%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Fmod.rs?ref=0a7f16e7d851f99816114cbc830c662d55376fbd", "patch": "@@ -79,31 +79,50 @@ pub type Bound<T> = Option<T>;\n pub type UnitResult<'tcx> = RelateResult<'tcx, ()>; // \"unify result\"\n pub type FixupResult<'tcx, T> = Result<T, FixupError<'tcx>>; // \"fixup result\"\n \n-/// A flag that is used to suppress region errors. This is normally\n-/// false, but sometimes -- when we are doing region checks that the\n-/// NLL borrow checker will also do -- it might be set to true.\n-#[derive(Copy, Clone, Default, Debug)]\n-pub struct SuppressRegionErrors {\n-    suppressed: bool,\n+/// How we should handle region solving.\n+///\n+/// This is used so that the region values inferred by HIR region solving are\n+/// not exposed, and so that we can avoid doing work in HIR typeck that MIR\n+/// typeck will also do.\n+#[derive(Copy, Clone, Debug)]\n+pub enum RegionckMode {\n+    /// The default mode: report region errors, don't erase regions.\n+    Solve,\n+    /// Erase the results of region after solving.\n+    Erase {\n+        /// A flag that is used to suppress region errors, when we are doing\n+        /// region checks that the NLL borrow checker will also do -- it might\n+        /// be set to true.\n+        suppress_errors: bool,\n+    },\n+}\n+\n+impl Default for RegionckMode {\n+    fn default() -> Self {\n+        RegionckMode::Solve\n+    }\n }\n \n-impl SuppressRegionErrors {\n+impl RegionckMode {\n     pub fn suppressed(self) -> bool {\n-        self.suppressed\n+        match self {\n+            Self::Solve => false,\n+            Self::Erase { suppress_errors } => suppress_errors,\n+        }\n     }\n \n     /// Indicates that the MIR borrowck will repeat these region\n     /// checks, so we should ignore errors if NLL is (unconditionally)\n     /// enabled.\n-    pub fn when_nll_is_enabled(tcx: TyCtxt<'_>) -> Self {\n+    pub fn for_item_body(tcx: TyCtxt<'_>) -> Self {\n         // FIXME(Centril): Once we actually remove `::Migrate` also make\n         // this always `true` and then proceed to eliminate the dead code.\n         match tcx.borrowck_mode() {\n             // If we're on Migrate mode, report AST region errors\n-            BorrowckMode::Migrate => SuppressRegionErrors { suppressed: false },\n+            BorrowckMode::Migrate => RegionckMode::Erase { suppress_errors: false },\n \n             // If we're on MIR, don't report AST region errors as they should be reported by NLL\n-            BorrowckMode::Mir => SuppressRegionErrors { suppressed: true },\n+            BorrowckMode::Mir => RegionckMode::Erase { suppress_errors: true },\n         }\n     }\n }\n@@ -1207,29 +1226,30 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         region_context: DefId,\n         region_map: &region::ScopeTree,\n         outlives_env: &OutlivesEnvironment<'tcx>,\n-        suppress: SuppressRegionErrors,\n+        mode: RegionckMode,\n     ) {\n         assert!(\n             self.is_tainted_by_errors() || self.inner.borrow().region_obligations.is_empty(),\n             \"region_obligations not empty: {:#?}\",\n             self.inner.borrow().region_obligations\n         );\n-\n-        let region_rels = &RegionRelations::new(\n-            self.tcx,\n-            region_context,\n-            region_map,\n-            outlives_env.free_region_map(),\n-        );\n         let (var_infos, data) = self\n             .inner\n             .borrow_mut()\n             .region_constraints\n             .take()\n             .expect(\"regions already resolved\")\n             .into_infos_and_data();\n+\n+        let region_rels = &RegionRelations::new(\n+            self.tcx,\n+            region_context,\n+            region_map,\n+            outlives_env.free_region_map(),\n+        );\n+\n         let (lexical_region_resolutions, errors) =\n-            lexical_region_resolve::resolve(region_rels, var_infos, data);\n+            lexical_region_resolve::resolve(region_rels, var_infos, data, mode);\n \n         let old_value = self.lexical_region_resolutions.replace(Some(lexical_region_resolutions));\n         assert!(old_value.is_none());\n@@ -1240,7 +1260,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             // this infcx was in use.  This is totally hokey but\n             // otherwise we have a hard time separating legit region\n             // errors from silly ones.\n-            self.report_region_errors(region_map, &errors, suppress);\n+            self.report_region_errors(region_map, &errors);\n         }\n     }\n "}, {"sha": "43a90c4a6c1649dd5e38ed771ce24441374b55bc", "filename": "src/librustc_trait_selection/traits/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a7f16e7d851f99816114cbc830c662d55376fbd/src%2Flibrustc_trait_selection%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a7f16e7d851f99816114cbc830c662d55376fbd/src%2Flibrustc_trait_selection%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trait_selection%2Ftraits%2Fmod.rs?ref=0a7f16e7d851f99816114cbc830c662d55376fbd", "patch": "@@ -21,7 +21,7 @@ mod util;\n pub mod wf;\n \n use crate::infer::outlives::env::OutlivesEnvironment;\n-use crate::infer::{InferCtxt, SuppressRegionErrors, TyCtxtInferExt};\n+use crate::infer::{InferCtxt, RegionckMode, TyCtxtInferExt};\n use crate::traits::error_reporting::InferCtxtExt as _;\n use crate::traits::query::evaluate_obligation::InferCtxtExt as _;\n use rustc::middle::region;\n@@ -244,7 +244,7 @@ fn do_normalize_predicates<'tcx>(\n             region_context,\n             &region_scope_tree,\n             &outlives_env,\n-            SuppressRegionErrors::default(),\n+            RegionckMode::default(),\n         );\n \n         let predicates = match infcx.fully_resolve(&predicates) {"}, {"sha": "e48ebbbb23514b153438220d9c04b8d3b185784d", "filename": "src/librustc_typeck/check/dropck.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a7f16e7d851f99816114cbc830c662d55376fbd/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a7f16e7d851f99816114cbc830c662d55376fbd/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fdropck.rs?ref=0a7f16e7d851f99816114cbc830c662d55376fbd", "patch": "@@ -9,7 +9,7 @@ use rustc::ty::subst::{Subst, SubstsRef};\n use rustc::ty::{self, Predicate, Ty, TyCtxt};\n use rustc_errors::struct_span_err;\n use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n-use rustc_infer::infer::{InferOk, SuppressRegionErrors, TyCtxtInferExt};\n+use rustc_infer::infer::{InferOk, RegionckMode, TyCtxtInferExt};\n use rustc_infer::traits::TraitEngineExt as _;\n use rustc_span::Span;\n use rustc_trait_selection::traits::error_reporting::InferCtxtExt;\n@@ -139,7 +139,7 @@ fn ensure_drop_params_and_item_params_correspond<'tcx>(\n             drop_impl_did,\n             &region_scope_tree,\n             &outlives_env,\n-            SuppressRegionErrors::default(),\n+            RegionckMode::default(),\n         );\n         Ok(())\n     })"}, {"sha": "b6d6d3a7a873f52fdf4b0ed6c00866d26aedba94", "filename": "src/librustc_typeck/check/regionck.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0a7f16e7d851f99816114cbc830c662d55376fbd/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a7f16e7d851f99816114cbc830c662d55376fbd/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fregionck.rs?ref=0a7f16e7d851f99816114cbc830c662d55376fbd", "patch": "@@ -85,7 +85,7 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::intravisit::{self, NestedVisitorMap, Visitor};\n use rustc_hir::PatKind;\n use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n-use rustc_infer::infer::{self, RegionObligation, SuppressRegionErrors};\n+use rustc_infer::infer::{self, RegionObligation, RegionckMode};\n use rustc_span::Span;\n use rustc_trait_selection::infer::OutlivesEnvironmentExt;\n use rustc_trait_selection::opaque_types::InferCtxtExt;\n@@ -124,7 +124,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             rcx.visit_body(body);\n             rcx.visit_region_obligations(id);\n         }\n-        rcx.resolve_regions_and_report_errors(SuppressRegionErrors::when_nll_is_enabled(self.tcx));\n+        rcx.resolve_regions_and_report_errors(RegionckMode::for_item_body(self.tcx));\n     }\n \n     /// Region checking during the WF phase for items. `wf_tys` are the\n@@ -142,7 +142,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         rcx.outlives_environment.add_implied_bounds(self, wf_tys, item_id, span);\n         rcx.outlives_environment.save_implied_bounds(item_id);\n         rcx.visit_region_obligations(item_id);\n-        rcx.resolve_regions_and_report_errors(SuppressRegionErrors::default());\n+        rcx.resolve_regions_and_report_errors(RegionckMode::default());\n     }\n \n     /// Region check a function body. Not invoked on closures, but\n@@ -165,7 +165,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             rcx.visit_fn_body(fn_id, body, self.tcx.hir().span(fn_id));\n         }\n \n-        rcx.resolve_regions_and_report_errors(SuppressRegionErrors::when_nll_is_enabled(self.tcx));\n+        rcx.resolve_regions_and_report_errors(RegionckMode::for_item_body(self.tcx));\n     }\n }\n \n@@ -346,7 +346,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n         self.select_all_obligations_or_error();\n     }\n \n-    fn resolve_regions_and_report_errors(&self, suppress: SuppressRegionErrors) {\n+    fn resolve_regions_and_report_errors(&self, mode: RegionckMode) {\n         self.infcx.process_registered_region_obligations(\n             self.outlives_environment.region_bound_pairs_map(),\n             self.implicit_region_bound,\n@@ -357,7 +357,7 @@ impl<'a, 'tcx> RegionCtxt<'a, 'tcx> {\n             self.subject_def_id,\n             &self.region_scope_tree,\n             &self.outlives_environment,\n-            suppress,\n+            mode,\n         );\n     }\n "}, {"sha": "8ed6cc3a94329821f1826804c767020773570abb", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/0a7f16e7d851f99816114cbc830c662d55376fbd/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a7f16e7d851f99816114cbc830c662d55376fbd/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=0a7f16e7d851f99816114cbc830c662d55376fbd", "patch": "@@ -124,7 +124,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n \n     fn write_ty_to_tables(&mut self, hir_id: hir::HirId, ty: Ty<'tcx>) {\n         debug!(\"write_ty_to_tables({:?}, {:?})\", hir_id, ty);\n-        assert!(!ty.needs_infer() && !ty.has_placeholders());\n+        assert!(!ty.needs_infer() && !ty.has_placeholders() && !ty.has_free_regions());\n         self.tables.node_types_mut().insert(hir_id, ty);\n     }\n \n@@ -326,9 +326,10 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n             let new_upvar_capture = match *upvar_capture {\n                 ty::UpvarCapture::ByValue => ty::UpvarCapture::ByValue,\n                 ty::UpvarCapture::ByRef(ref upvar_borrow) => {\n-                    let r = upvar_borrow.region;\n-                    let r = self.resolve(&r, &upvar_id.var_path.hir_id);\n-                    ty::UpvarCapture::ByRef(ty::UpvarBorrow { kind: upvar_borrow.kind, region: r })\n+                    ty::UpvarCapture::ByRef(ty::UpvarBorrow {\n+                        kind: upvar_borrow.kind,\n+                        region: self.tcx().lifetimes.re_erased,\n+                    })\n                 }\n             };\n             debug!(\"Upvar capture for {:?} resolved to {:?}\", upvar_id, new_upvar_capture);\n@@ -421,8 +422,7 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n     fn visit_opaque_types(&mut self, span: Span) {\n         for (&def_id, opaque_defn) in self.fcx.opaque_types.borrow().iter() {\n             let hir_id = self.tcx().hir().as_local_hir_id(def_id).unwrap();\n-            let instantiated_ty =\n-                self.tcx().erase_regions(&self.resolve(&opaque_defn.concrete_ty, &hir_id));\n+            let instantiated_ty = self.resolve(&opaque_defn.concrete_ty, &hir_id);\n \n             debug_assert!(!instantiated_ty.has_escaping_bound_vars());\n \n@@ -611,10 +611,8 @@ impl Locatable for hir::HirId {\n     }\n }\n \n-///////////////////////////////////////////////////////////////////////////\n-// The Resolver. This is the type folding engine that detects\n-// unresolved types and so forth.\n-\n+/// The Resolver. This is the type folding engine that detects\n+/// unresolved types and so forth.\n struct Resolver<'cx, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n     infcx: &'cx InferCtxt<'cx, 'tcx>,\n@@ -647,7 +645,7 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Resolver<'cx, 'tcx> {\n \n     fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n         match self.infcx.fully_resolve(&t) {\n-            Ok(t) => t,\n+            Ok(t) => self.infcx.tcx.erase_regions(&t),\n             Err(_) => {\n                 debug!(\"Resolver::fold_ty: input type `{:?}` not fully resolvable\", t);\n                 self.report_error(t);\n@@ -656,15 +654,14 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Resolver<'cx, 'tcx> {\n         }\n     }\n \n-    // FIXME This should be carefully checked\n-    // We could use `self.report_error` but it doesn't accept a ty::Region, right now.\n     fn fold_region(&mut self, r: ty::Region<'tcx>) -> ty::Region<'tcx> {\n-        self.infcx.fully_resolve(&r).unwrap_or(self.tcx.lifetimes.re_static)\n+        debug_assert!(!r.is_late_bound(), \"Should not be resolving bound region.\");\n+        self.tcx.lifetimes.re_erased\n     }\n \n     fn fold_const(&mut self, ct: &'tcx ty::Const<'tcx>) -> &'tcx ty::Const<'tcx> {\n         match self.infcx.fully_resolve(&ct) {\n-            Ok(ct) => ct,\n+            Ok(ct) => self.infcx.tcx.erase_regions(&ct),\n             Err(_) => {\n                 debug!(\"Resolver::fold_const: input const `{:?}` not fully resolvable\", ct);\n                 // FIXME: we'd like to use `self.report_error`, but it doesn't yet"}, {"sha": "e24d9bebf657fd730cee09280c26499a0b679507", "filename": "src/librustc_typeck/coherence/builtin.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0a7f16e7d851f99816114cbc830c662d55376fbd/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a7f16e7d851f99816114cbc830c662d55376fbd/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fbuiltin.rs?ref=0a7f16e7d851f99816114cbc830c662d55376fbd", "patch": "@@ -12,7 +12,7 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::ItemKind;\n use rustc_infer::infer;\n use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n-use rustc_infer::infer::{SuppressRegionErrors, TyCtxtInferExt};\n+use rustc_infer::infer::{RegionckMode, TyCtxtInferExt};\n use rustc_trait_selection::traits::error_reporting::InferCtxtExt;\n use rustc_trait_selection::traits::misc::{can_type_implement_copy, CopyImplementationError};\n use rustc_trait_selection::traits::predicate_for_trait_def;\n@@ -307,7 +307,7 @@ fn visit_implementation_of_dispatch_from_dyn(tcx: TyCtxt<'_>, impl_did: DefId) {\n                             impl_did,\n                             &region_scope_tree,\n                             &outlives_env,\n-                            SuppressRegionErrors::default(),\n+                            RegionckMode::default(),\n                         );\n                     }\n                 }\n@@ -568,7 +568,7 @@ pub fn coerce_unsized_info(tcx: TyCtxt<'tcx>, impl_did: DefId) -> CoerceUnsizedI\n             impl_did,\n             &region_scope_tree,\n             &outlives_env,\n-            SuppressRegionErrors::default(),\n+            RegionckMode::default(),\n         );\n \n         CoerceUnsizedInfo { custom_kind: kind }"}, {"sha": "cae88376118466d9bd0fb5b5efbac9097b76db30", "filename": "src/librustc_typeck/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0a7f16e7d851f99816114cbc830c662d55376fbd/src%2Flibrustc_typeck%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0a7f16e7d851f99816114cbc830c662d55376fbd/src%2Flibrustc_typeck%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fimpl_wf_check%2Fmin_specialization.rs?ref=0a7f16e7d851f99816114cbc830c662d55376fbd", "patch": "@@ -75,7 +75,7 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n use rustc_infer::infer::outlives::env::OutlivesEnvironment;\n-use rustc_infer::infer::{InferCtxt, SuppressRegionErrors, TyCtxtInferExt};\n+use rustc_infer::infer::{InferCtxt, RegionckMode, TyCtxtInferExt};\n use rustc_infer::traits::specialization_graph::Node;\n use rustc_span::Span;\n use rustc_trait_selection::traits::{self, translate_substs, wf};\n@@ -162,7 +162,7 @@ fn get_impl_substs<'tcx>(\n         impl1_def_id,\n         &ScopeTree::default(),\n         &outlives_env,\n-        SuppressRegionErrors::default(),\n+        RegionckMode::default(),\n     );\n     let impl2_substs = match infcx.fully_resolve(&impl2_substs) {\n         Ok(s) => s,"}]}