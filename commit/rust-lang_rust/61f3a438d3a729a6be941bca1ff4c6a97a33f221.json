{"sha": "61f3a438d3a729a6be941bca1ff4c6a97a33f221", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYxZjNhNDM4ZDNhNzI5YTZiZTk0MWJjYTFmZjRjNmE5N2EzM2YyMjE=", "commit": {"author": {"name": "Jeremy A. Kolb", "email": "jkolb@ara.com", "date": "2018-10-15T21:44:23Z"}, "committer": {"name": "Jeremy A. Kolb", "email": "jkolb@ara.com", "date": "2018-10-16T13:41:10Z"}, "message": "Cargo Format\n\nRun `cargo fmt` and ignore generated files", "tree": {"sha": "6551967cc8c6e921b66071453ad7888a9121d326", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6551967cc8c6e921b66071453ad7888a9121d326"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/61f3a438d3a729a6be941bca1ff4c6a97a33f221", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/61f3a438d3a729a6be941bca1ff4c6a97a33f221", "html_url": "https://github.com/rust-lang/rust/commit/61f3a438d3a729a6be941bca1ff4c6a97a33f221", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/61f3a438d3a729a6be941bca1ff4c6a97a33f221/comments", "author": {"login": "kjeremy", "id": 4325700, "node_id": "MDQ6VXNlcjQzMjU3MDA=", "avatar_url": "https://avatars.githubusercontent.com/u/4325700?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kjeremy", "html_url": "https://github.com/kjeremy", "followers_url": "https://api.github.com/users/kjeremy/followers", "following_url": "https://api.github.com/users/kjeremy/following{/other_user}", "gists_url": "https://api.github.com/users/kjeremy/gists{/gist_id}", "starred_url": "https://api.github.com/users/kjeremy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kjeremy/subscriptions", "organizations_url": "https://api.github.com/users/kjeremy/orgs", "repos_url": "https://api.github.com/users/kjeremy/repos", "events_url": "https://api.github.com/users/kjeremy/events{/privacy}", "received_events_url": "https://api.github.com/users/kjeremy/received_events", "type": "User", "site_admin": false}, "committer": {"login": "kjeremy", "id": 4325700, "node_id": "MDQ6VXNlcjQzMjU3MDA=", "avatar_url": "https://avatars.githubusercontent.com/u/4325700?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kjeremy", "html_url": "https://github.com/kjeremy", "followers_url": "https://api.github.com/users/kjeremy/followers", "following_url": "https://api.github.com/users/kjeremy/following{/other_user}", "gists_url": "https://api.github.com/users/kjeremy/gists{/gist_id}", "starred_url": "https://api.github.com/users/kjeremy/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kjeremy/subscriptions", "organizations_url": "https://api.github.com/users/kjeremy/orgs", "repos_url": "https://api.github.com/users/kjeremy/repos", "events_url": "https://api.github.com/users/kjeremy/events{/privacy}", "received_events_url": "https://api.github.com/users/kjeremy/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "39cb6c6d3f78b193f5873c3492e530bbd24d5dd2", "url": "https://api.github.com/repos/rust-lang/rust/commits/39cb6c6d3f78b193f5873c3492e530bbd24d5dd2", "html_url": "https://github.com/rust-lang/rust/commit/39cb6c6d3f78b193f5873c3492e530bbd24d5dd2"}], "stats": {"total": 3454, "additions": 1930, "deletions": 1524}, "files": [{"sha": "e45a6b5e27c93b4d76bea97ad09de0b12107c481", "filename": "crates/gen_lsp_server/src/lib.rs", "status": "modified", "additions": 13, "deletions": 22, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fgen_lsp_server%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fgen_lsp_server%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fgen_lsp_server%2Fsrc%2Flib.rs?ref=61f3a438d3a729a6be941bca1ff4c6a97a33f221", "patch": "@@ -59,7 +59,6 @@\n //! }\n //! ```\n \n-\n #[macro_use]\n extern crate failure;\n #[macro_use]\n@@ -74,16 +73,16 @@ extern crate languageserver_types;\n mod msg;\n mod stdio;\n \n-use crossbeam_channel::{Sender, Receiver};\n+use crossbeam_channel::{Receiver, Sender};\n use languageserver_types::{\n-    ServerCapabilities, InitializeResult, InitializeParams,\n+    notification::{Exit, Initialized},\n     request::{Initialize, Shutdown},\n-    notification::{Initialized, Exit},\n+    InitializeParams, InitializeResult, ServerCapabilities,\n };\n \n pub type Result<T> = ::std::result::Result<T, failure::Error>;\n pub use {\n-    msg::{RawMessage, RawRequest, RawResponse, RawResponseError, RawNotification, ErrorCode},\n+    msg::{ErrorCode, RawMessage, RawNotification, RawRequest, RawResponse, RawResponseError},\n     stdio::{stdio_transport, Threads},\n };\n \n@@ -97,24 +96,18 @@ pub fn run_server(\n     caps: ServerCapabilities,\n     receiver: Receiver<RawMessage>,\n     sender: Sender<RawMessage>,\n-    server: impl FnOnce(\n-        InitializeParams,\n-        &Receiver<RawMessage>,\n-        &Sender<RawMessage>,\n-    ) -> Result<()>,\n+    server: impl FnOnce(InitializeParams, &Receiver<RawMessage>, &Sender<RawMessage>) -> Result<()>,\n ) -> Result<()> {\n     info!(\"lsp server initializes\");\n     let params = initialize(&receiver, &sender, caps)?;\n     info!(\"lsp server initialized, serving requests\");\n     server(params, &receiver, &sender)?;\n     info!(\"lsp server waiting for exit notification\");\n     match receiver.recv() {\n-        Some(RawMessage::Notification(n)) => {\n-            n.cast::<Exit>().map_err(|n| format_err!(\n-                \"unexpected notification during shutdown: {:?}\", n\n-            ))?\n-        }\n-        m => bail!(\"unexpected message during shutdown: {:?}\", m)\n+        Some(RawMessage::Notification(n)) => n\n+            .cast::<Exit>()\n+            .map_err(|n| format_err!(\"unexpected notification during shutdown: {:?}\", n))?,\n+        m => bail!(\"unexpected message during shutdown: {:?}\", m),\n     }\n     info!(\"lsp server shutdown complete\");\n     Ok(())\n@@ -141,17 +134,15 @@ fn initialize(\n         Some(RawMessage::Request(req)) => match req.cast::<Initialize>() {\n             Err(req) => bail!(\"expected initialize request, got {:?}\", req),\n             Ok(req) => req,\n-        }\n-        msg =>\n-            bail!(\"expected initialize request, got {:?}\", msg),\n+        },\n+        msg => bail!(\"expected initialize request, got {:?}\", msg),\n     };\n     let resp = RawResponse::ok::<Initialize>(id, &InitializeResult { capabilities: caps });\n     sender.send(RawMessage::Response(resp));\n     match receiver.recv() {\n         Some(RawMessage::Notification(n)) => {\n-            n.cast::<Initialized>().map_err(|_| format_err!(\n-                \"expected initialized notification\"\n-            ))?;\n+            n.cast::<Initialized>()\n+                .map_err(|_| format_err!(\"expected initialized notification\"))?;\n         }\n         _ => bail!(\"expected initialized notification\"),\n     }"}, {"sha": "e0d0aeab55c8813e35f95e023264fa11831fd81c", "filename": "crates/gen_lsp_server/src/msg.rs", "status": "modified", "additions": 18, "deletions": 11, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fgen_lsp_server%2Fsrc%2Fmsg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fgen_lsp_server%2Fsrc%2Fmsg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fgen_lsp_server%2Fsrc%2Fmsg.rs?ref=61f3a438d3a729a6be941bca1ff4c6a97a33f221", "patch": "@@ -1,11 +1,8 @@\n use std::io::{BufRead, Write};\n \n-use serde_json::{Value, from_str, to_string, from_value, to_value};\n-use serde::{Serialize, de::DeserializeOwned};\n-use languageserver_types::{\n-    request::Request,\n-    notification::Notification,\n-};\n+use languageserver_types::{notification::Notification, request::Request};\n+use serde::{de::DeserializeOwned, Serialize};\n+use serde_json::{from_str, from_value, to_string, to_value, Value};\n \n use Result;\n \n@@ -81,7 +78,10 @@ impl RawMessage {\n             #[serde(flatten)]\n             msg: RawMessage,\n         }\n-        let text = to_string(&JsonRpc { jsonrpc: \"2.0\", msg: self })?;\n+        let text = to_string(&JsonRpc {\n+            jsonrpc: \"2.0\",\n+            msg: self,\n+        })?;\n         write_msg_text(w, &text)?;\n         Ok(())\n     }\n@@ -115,8 +115,9 @@ impl RawRequest {\n \n impl RawResponse {\n     pub fn ok<R>(id: u64, result: &R::Result) -> RawResponse\n-    where R: Request,\n-          R::Result: Serialize,\n+    where\n+        R: Request,\n+        R::Result: Serialize,\n     {\n         RawResponse {\n             id,\n@@ -125,7 +126,11 @@ impl RawResponse {\n         }\n     }\n     pub fn err(id: u64, code: i32, message: String) -> RawResponse {\n-        let error = RawResponseError { code, message, data: None };\n+        let error = RawResponseError {\n+            code,\n+            message,\n+            data: None,\n+        };\n         RawResponse {\n             id,\n             result: None,\n@@ -174,7 +179,9 @@ fn read_msg_text(inp: &mut impl BufRead) -> Result<Option<String>> {\n         }\n         let mut parts = buf.splitn(2, \": \");\n         let header_name = parts.next().unwrap();\n-        let header_value = parts.next().ok_or_else(|| format_err!(\"malformed header: {:?}\", buf))?;\n+        let header_value = parts\n+            .next()\n+            .ok_or_else(|| format_err!(\"malformed header: {:?}\", buf))?;\n         if header_name == \"Content-Length\" {\n             size = Some(header_value.parse::<usize>()?);\n         }"}, {"sha": "3d8a1712abe7507a64c88fba0fe94af11efbea87", "filename": "crates/gen_lsp_server/src/stdio.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fgen_lsp_server%2Fsrc%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fgen_lsp_server%2Fsrc%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fgen_lsp_server%2Fsrc%2Fstdio.rs?ref=61f3a438d3a729a6be941bca1ff4c6a97a33f221", "patch": "@@ -1,11 +1,9 @@\n use std::{\n+    io::{stdin, stdout},\n     thread,\n-    io::{\n-        stdout, stdin,\n-    },\n };\n \n-use crossbeam_channel::{Receiver, Sender, bounded};\n+use crossbeam_channel::{bounded, Receiver, Sender};\n \n use {RawMessage, Result};\n "}, {"sha": "042dde1aca982819c755cb30966a7a2743d3de92", "filename": "crates/ra_analysis/src/db.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_analysis%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_analysis%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fdb.rs?ref=61f3a438d3a729a6be941bca1ff4c6a97a33f221", "patch": "@@ -1,17 +1,18 @@\n-use std::{\n-    fmt,\n-    sync::Arc,\n-    hash::{Hash, Hasher},\n-};\n-use salsa;\n-use rustc_hash::FxHashSet;\n-use ra_syntax::File;\n-use ra_editor::{LineIndex};\n use crate::{\n+    module_map::{ModuleDescriptorQuery, ModuleTreeQuery, ModulesDatabase},\n     symbol_index::SymbolIndex,\n-    module_map::{ModulesDatabase, ModuleTreeQuery, ModuleDescriptorQuery},\n     FileId, FileResolverImp,\n };\n+use ra_editor::LineIndex;\n+use ra_syntax::File;\n+use rustc_hash::FxHashSet;\n+use salsa;\n+\n+use std::{\n+    fmt,\n+    hash::{Hash, Hasher},\n+    sync::Arc,\n+};\n \n #[derive(Default)]\n pub(crate) struct RootDatabase {"}, {"sha": "6f26f9935dd980d306662d4c4fa73d5aff521ea1", "filename": "crates/ra_analysis/src/descriptors.rs", "status": "modified", "additions": 58, "deletions": 50, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_analysis%2Fsrc%2Fdescriptors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_analysis%2Fsrc%2Fdescriptors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fdescriptors.rs?ref=61f3a438d3a729a6be941bca1ff4c6a97a33f221", "patch": "@@ -1,41 +1,34 @@\n-use std::{\n-    collections::BTreeMap,\n-};\n-use relative_path::RelativePathBuf;\n+use crate::{imp::FileResolverImp, FileId};\n use ra_syntax::{\n+    ast::{self, AstNode, NameOwner},\n+    text_utils::is_subrange,\n     SmolStr,\n-    ast::{self, NameOwner, AstNode},\n-    text_utils::is_subrange\n-};\n-use crate::{\n-    FileId,\n-    imp::FileResolverImp,\n };\n+use relative_path::RelativePathBuf;\n+\n+use std::collections::BTreeMap;\n \n #[derive(Debug, PartialEq, Eq, Hash)]\n pub struct ModuleDescriptor {\n-    pub submodules: Vec<Submodule>\n+    pub submodules: Vec<Submodule>,\n }\n \n impl ModuleDescriptor {\n     pub fn new(root: ast::Root) -> ModuleDescriptor {\n-        let submodules = modules(root)\n-            .map(|(name, _)| Submodule { name })\n-            .collect();\n+        let submodules = modules(root).map(|(name, _)| Submodule { name }).collect();\n \n-        ModuleDescriptor { submodules } }\n+        ModuleDescriptor { submodules }\n+    }\n }\n \n-fn modules<'a>(root: ast::Root<'a>) -> impl Iterator<Item=(SmolStr, ast::Module<'a>)> {\n-    root\n-        .modules()\n-        .filter_map(|module| {\n-            let name = module.name()?.text();\n-            if !module.has_semi() {\n-                return None;\n-            }\n-            Some((name, module))\n-        })\n+fn modules<'a>(root: ast::Root<'a>) -> impl Iterator<Item = (SmolStr, ast::Module<'a>)> {\n+    root.modules().filter_map(|module| {\n+        let name = module.name()?.text();\n+        if !module.has_semi() {\n+            return None;\n+        }\n+        Some((name, module))\n+    })\n }\n \n #[derive(Clone, Hash, PartialEq, Eq, Debug)]\n@@ -56,7 +49,7 @@ struct Node(usize);\n struct NodeData {\n     file_id: FileId,\n     links: Vec<Link>,\n-    parents: Vec<Link>\n+    parents: Vec<Link>,\n }\n \n #[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n@@ -69,7 +62,6 @@ struct LinkData {\n     problem: Option<Problem>,\n }\n \n-\n #[derive(Clone, Debug, Hash, PartialEq, Eq)]\n pub enum Problem {\n     UnresolvedModule {\n@@ -78,16 +70,18 @@ pub enum Problem {\n     NotDirOwner {\n         move_to: RelativePathBuf,\n         candidate: RelativePathBuf,\n-    }\n+    },\n }\n \n impl ModuleTreeDescriptor {\n     pub(crate) fn new<'a>(\n-        files: impl Iterator<Item=(FileId, &'a ModuleDescriptor)> + Clone,\n+        files: impl Iterator<Item = (FileId, &'a ModuleDescriptor)> + Clone,\n         file_resolver: &FileResolverImp,\n     ) -> ModuleTreeDescriptor {\n         let mut file_id2node = BTreeMap::new();\n-        let mut nodes: Vec<NodeData> = files.clone().enumerate()\n+        let mut nodes: Vec<NodeData> = files\n+            .clone()\n+            .enumerate()\n             .map(|(idx, (file_id, _))| {\n                 file_id2node.insert(file_id, Node(idx));\n                 NodeData {\n@@ -120,31 +114,38 @@ impl ModuleTreeDescriptor {\n                     points_to,\n                     problem,\n                 })\n-\n             }\n         }\n \n         ModuleTreeDescriptor {\n-            nodes, links, file_id2node\n+            nodes,\n+            links,\n+            file_id2node,\n         }\n     }\n \n     pub(crate) fn parent_modules(&self, file_id: FileId) -> Vec<Link> {\n         let node = self.file_id2node[&file_id];\n-        self.node(node)\n-            .parents\n-            .clone()\n+        self.node(node).parents.clone()\n     }\n     pub(crate) fn child_module_by_name(&self, file_id: FileId, name: &str) -> Vec<FileId> {\n         let node = self.file_id2node[&file_id];\n         self.node(node)\n             .links\n             .iter()\n             .filter(|it| it.name(self) == name)\n-            .flat_map(|link| link.points_to(self).iter().map(|&node| self.node(node).file_id))\n+            .flat_map(|link| {\n+                link.points_to(self)\n+                    .iter()\n+                    .map(|&node| self.node(node).file_id)\n+            })\n             .collect()\n     }\n-    pub(crate) fn problems<'a, 'b>(&'b self, file_id: FileId, root: ast::Root<'a>) -> Vec<(ast::Name<'a>, &'b Problem)> {\n+    pub(crate) fn problems<'a, 'b>(\n+        &'b self,\n+        file_id: FileId,\n+        root: ast::Root<'a>,\n+    ) -> Vec<(ast::Name<'a>, &'b Problem)> {\n         let node = self.file_id2node[&file_id];\n         self.node(node)\n             .links\n@@ -176,7 +177,11 @@ impl Link {\n     fn points_to(self, tree: &ModuleTreeDescriptor) -> &[Node] {\n         &tree.link(self).points_to\n     }\n-    pub(crate) fn bind_source<'a>(self, tree: &ModuleTreeDescriptor, root: ast::Root<'a>) -> ast::Module<'a> {\n+    pub(crate) fn bind_source<'a>(\n+        self,\n+        tree: &ModuleTreeDescriptor,\n+        root: ast::Root<'a>,\n+    ) -> ast::Module<'a> {\n         modules(root)\n             .filter(|(name, _)| name == &tree.link(self).name)\n             .next()\n@@ -185,22 +190,21 @@ impl Link {\n     }\n }\n \n-\n fn resolve_submodule(\n     file_id: FileId,\n     name: &SmolStr,\n-    file_resolver: &FileResolverImp\n+    file_resolver: &FileResolverImp,\n ) -> (Vec<FileId>, Option<Problem>) {\n     let mod_name = file_resolver.file_stem(file_id);\n-    let is_dir_owner =\n-        mod_name == \"mod\" || mod_name == \"lib\" || mod_name == \"main\";\n+    let is_dir_owner = mod_name == \"mod\" || mod_name == \"lib\" || mod_name == \"main\";\n \n     let file_mod = RelativePathBuf::from(format!(\"../{}.rs\", name));\n     let dir_mod = RelativePathBuf::from(format!(\"../{}/mod.rs\", name));\n     let points_to: Vec<FileId>;\n     let problem: Option<Problem>;\n     if is_dir_owner {\n-        points_to = [&file_mod, &dir_mod].iter()\n+        points_to = [&file_mod, &dir_mod]\n+            .iter()\n             .filter_map(|path| file_resolver.resolve(file_id, path))\n             .collect();\n         problem = if points_to.is_empty() {\n@@ -223,7 +227,7 @@ fn resolve_submodule(\n #[derive(Debug, Clone)]\n pub struct FnDescriptor {\n     pub name: String,\n-    pub label : String,\n+    pub label: String,\n     pub ret_type: Option<String>,\n     pub params: Vec<String>,\n }\n@@ -233,9 +237,11 @@ impl FnDescriptor {\n         let name = node.name()?.text().to_string();\n \n         // Strip the body out for the label.\n-        let label : String = if let Some(body) = node.body() {\n+        let label: String = if let Some(body) = node.body() {\n             let body_range = body.syntax().range();\n-            let label : String = node.syntax().children()\n+            let label: String = node\n+                .syntax()\n+                .children()\n                 .filter(|child| !is_subrange(body_range, child.range()))\n                 .map(|node| node.text().to_string())\n                 .collect();\n@@ -251,7 +257,7 @@ impl FnDescriptor {\n             name,\n             ret_type,\n             params,\n-            label\n+            label,\n         })\n     }\n \n@@ -264,9 +270,11 @@ impl FnDescriptor {\n \n             // Maybe use param.pat here? See if we can just extract the name?\n             //res.extend(param_list.params().map(|p| p.syntax().text().to_string()));\n-            res.extend(param_list.params()\n-                .filter_map(|p| p.pat())\n-                .map(|pat| pat.syntax().text().to_string())\n+            res.extend(\n+                param_list\n+                    .params()\n+                    .filter_map(|p| p.pat())\n+                    .map(|pat| pat.syntax().text().to_string()),\n             );\n         }\n         res"}, {"sha": "f1403cb5d7845f480757200e35c536312cec884f", "filename": "crates/ra_analysis/src/imp.rs", "status": "modified", "additions": 123, "deletions": 84, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_analysis%2Fsrc%2Fimp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fimp.rs?ref=61f3a438d3a729a6be941bca1ff4c6a97a33f221", "patch": "@@ -1,32 +1,31 @@\n use std::{\n-    sync::{\n-        Arc,\n-    },\n-    hash::{Hash, Hasher},\n-    fmt,\n     collections::VecDeque,\n+    fmt,\n+    hash::{Hash, Hasher},\n     iter,\n+    sync::Arc,\n };\n \n-use relative_path::RelativePath;\n-use rustc_hash::FxHashSet;\n-use ra_editor::{self, FileSymbol, LineIndex, find_node_at_offset, LocalEdit, resolve_local_name};\n+use ra_editor::{self, find_node_at_offset, resolve_local_name, FileSymbol, LineIndex, LocalEdit};\n use ra_syntax::{\n-    TextUnit, TextRange, SmolStr, File, AstNode, SyntaxNodeRef,\n+    ast::{self, ArgListOwner, Expr, NameOwner},\n+    AstNode, File, SmolStr,\n     SyntaxKind::*,\n-    ast::{self, NameOwner, ArgListOwner, Expr},\n+    SyntaxNodeRef, TextRange, TextUnit,\n };\n+use relative_path::RelativePath;\n+use rustc_hash::FxHashSet;\n \n use crate::{\n-    FileId, FileResolver, Query, Diagnostic, SourceChange, SourceFileEdit, Position, FileSystemEdit,\n-    JobToken, CrateGraph, CrateId,\n-    roots::{SourceRoot, ReadonlySourceRoot, WritableSourceRoot},\n     descriptors::{FnDescriptor, ModuleTreeDescriptor, Problem},\n+    roots::{ReadonlySourceRoot, SourceRoot, WritableSourceRoot},\n+    CrateGraph, CrateId, Diagnostic, FileId, FileResolver, FileSystemEdit, JobToken, Position,\n+    Query, SourceChange, SourceFileEdit,\n };\n \n #[derive(Clone, Debug)]\n pub(crate) struct FileResolverImp {\n-    inner: Arc<FileResolver>\n+    inner: Arc<FileResolver>,\n }\n \n impl PartialEq for FileResolverImp {\n@@ -35,8 +34,7 @@ impl PartialEq for FileResolverImp {\n     }\n }\n \n-impl Eq for FileResolverImp {\n-}\n+impl Eq for FileResolverImp {}\n \n impl Hash for FileResolverImp {\n     fn hash<H: Hasher>(&self, hasher: &mut H) {\n@@ -67,17 +65,23 @@ impl Default for FileResolverImp {\n             fn file_stem(&self, _file_: FileId) -> String {\n                 panic!(\"file resolver not set\")\n             }\n-            fn resolve(&self, _file_id: FileId, _path: &::relative_path::RelativePath) -> Option<FileId> {\n+            fn resolve(\n+                &self,\n+                _file_id: FileId,\n+                _path: &::relative_path::RelativePath,\n+            ) -> Option<FileId> {\n                 panic!(\"file resolver not set\")\n             }\n         }\n-        FileResolverImp { inner: Arc::new(DummyResolver) }\n+        FileResolverImp {\n+            inner: Arc::new(DummyResolver),\n+        }\n     }\n }\n \n #[derive(Debug)]\n pub(crate) struct AnalysisHostImpl {\n-    data: WorldData\n+    data: WorldData,\n }\n \n impl AnalysisHostImpl {\n@@ -91,13 +95,13 @@ impl AnalysisHostImpl {\n             data: self.data.clone(),\n         }\n     }\n-    pub fn change_files(&mut self, changes: &mut dyn Iterator<Item=(FileId, Option<String>)>) {\n-        self.data_mut()\n-            .root.apply_changes(changes, None);\n+    pub fn change_files(&mut self, changes: &mut dyn Iterator<Item = (FileId, Option<String>)>) {\n+        self.data_mut().root.apply_changes(changes, None);\n     }\n     pub fn set_file_resolver(&mut self, resolver: FileResolverImp) {\n         self.data_mut()\n-            .root.apply_changes(&mut iter::empty(), Some(resolver));\n+            .root\n+            .apply_changes(&mut iter::empty(), Some(resolver));\n     }\n     pub fn set_crate_graph(&mut self, graph: CrateGraph) {\n         let mut visited = FxHashSet::default();\n@@ -131,7 +135,12 @@ impl AnalysisImpl {\n         if self.data.root.contains(file_id) {\n             return &self.data.root;\n         }\n-        &**self.data.libs.iter().find(|it| it.contains(file_id)).unwrap()\n+        &**self\n+            .data\n+            .libs\n+            .iter()\n+            .find(|it| it.contains(file_id))\n+            .unwrap()\n     }\n     pub fn file_syntax(&self, file_id: FileId) -> File {\n         self.root(file_id).syntax(file_id)\n@@ -142,18 +151,17 @@ impl AnalysisImpl {\n     pub fn world_symbols(&self, query: Query, token: &JobToken) -> Vec<(FileId, FileSymbol)> {\n         let mut buf = Vec::new();\n         if query.libs {\n-            self.data.libs.iter()\n-                .for_each(|it| it.symbols(&mut buf));\n+            self.data.libs.iter().for_each(|it| it.symbols(&mut buf));\n         } else {\n             self.data.root.symbols(&mut buf);\n         }\n         query.search(&buf, token)\n-\n     }\n     pub fn parent_module(&self, file_id: FileId) -> Vec<(FileId, FileSymbol)> {\n         let root = self.root(file_id);\n         let module_tree = root.module_tree();\n-        module_tree.parent_modules(file_id)\n+        module_tree\n+            .parent_modules(file_id)\n             .iter()\n             .map(|link| {\n                 let file_id = link.owner(&module_tree);\n@@ -203,15 +211,17 @@ impl AnalysisImpl {\n         let file = root.syntax(file_id);\n         let syntax = file.syntax();\n         if let Some(name_ref) = find_node_at_offset::<ast::NameRef>(syntax, offset) {\n-\n             // First try to resolve the symbol locally\n             if let Some((name, range)) = resolve_local_name(&file, offset, name_ref) {\n                 let mut vec = vec![];\n-                vec.push((file_id, FileSymbol {\n-                    name,\n-                    node_range: range,\n-                    kind : NAME\n-                }));\n+                vec.push((\n+                    file_id,\n+                    FileSymbol {\n+                        name,\n+                        node_range: range,\n+                        kind: NAME,\n+                    },\n+                ));\n \n                 return vec;\n             } else {\n@@ -224,17 +234,21 @@ impl AnalysisImpl {\n                 if module.has_semi() {\n                     let file_ids = self.resolve_module(&*module_tree, file_id, module);\n \n-                    let res = file_ids.into_iter().map(|id| {\n-                        let name = module.name()\n-                            .map(|n| n.text())\n-                            .unwrap_or_else(|| SmolStr::new(\"\"));\n-                        let symbol = FileSymbol {\n-                            name,\n-                            node_range: TextRange::offset_len(0.into(), 0.into()),\n-                            kind: MODULE,\n-                        };\n-                        (id, symbol)\n-                    }).collect();\n+                    let res = file_ids\n+                        .into_iter()\n+                        .map(|id| {\n+                            let name = module\n+                                .name()\n+                                .map(|n| n.text())\n+                                .unwrap_or_else(|| SmolStr::new(\"\"));\n+                            let symbol = FileSymbol {\n+                                name,\n+                                node_range: TextRange::offset_len(0.into(), 0.into()),\n+                                kind: MODULE,\n+                            };\n+                            (id, symbol)\n+                        })\n+                        .collect();\n \n                     return res;\n                 }\n@@ -245,12 +259,16 @@ impl AnalysisImpl {\n \n     pub fn diagnostics(&self, file_id: FileId) -> Vec<Diagnostic> {\n         let root = self.root(file_id);\n-        let module_tree  = root.module_tree();\n+        let module_tree = root.module_tree();\n         let syntax = root.syntax(file_id);\n \n         let mut res = ra_editor::diagnostics(&syntax)\n             .into_iter()\n-            .map(|d| Diagnostic { range: d.range, message: d.msg, fix: None })\n+            .map(|d| Diagnostic {\n+                range: d.range,\n+                message: d.msg,\n+                fix: None,\n+            })\n             .collect::<Vec<_>>();\n \n         for (name_node, problem) in module_tree.problems(file_id, syntax.ast()) {\n@@ -273,8 +291,14 @@ impl AnalysisImpl {\n                     }\n                 }\n                 Problem::NotDirOwner { move_to, candidate } => {\n-                    let move_file = FileSystemEdit::MoveFile { file: file_id, path: move_to.clone() };\n-                    let create_file = FileSystemEdit::CreateFile { anchor: file_id, path: move_to.join(candidate) };\n+                    let move_file = FileSystemEdit::MoveFile {\n+                        file: file_id,\n+                        path: move_to.clone(),\n+                    };\n+                    let create_file = FileSystemEdit::CreateFile {\n+                        anchor: file_id,\n+                        path: move_to.join(candidate),\n+                    };\n                     let fix = SourceChange {\n                         label: \"move file and create module\".to_string(),\n                         source_file_edits: Vec::new(),\n@@ -297,23 +321,34 @@ impl AnalysisImpl {\n         let file = self.file_syntax(file_id);\n         let offset = range.start();\n         let actions = vec![\n-            (\"flip comma\", ra_editor::flip_comma(&file, offset).map(|f| f())),\n-            (\"add `#[derive]`\", ra_editor::add_derive(&file, offset).map(|f| f())),\n+            (\n+                \"flip comma\",\n+                ra_editor::flip_comma(&file, offset).map(|f| f()),\n+            ),\n+            (\n+                \"add `#[derive]`\",\n+                ra_editor::add_derive(&file, offset).map(|f| f()),\n+            ),\n             (\"add impl\", ra_editor::add_impl(&file, offset).map(|f| f())),\n-            (\"introduce variable\", ra_editor::introduce_variable(&file, range).map(|f| f())),\n+            (\n+                \"introduce variable\",\n+                ra_editor::introduce_variable(&file, range).map(|f| f()),\n+            ),\n         ];\n-        actions.into_iter()\n+        actions\n+            .into_iter()\n             .filter_map(|(name, local_edit)| {\n-                Some(SourceChange::from_local_edit(\n-                    file_id, name, local_edit?,\n-                ))\n+                Some(SourceChange::from_local_edit(file_id, name, local_edit?))\n             })\n             .collect()\n     }\n \n-    pub fn resolve_callable(&self, file_id: FileId, offset: TextUnit, token: &JobToken)\n-        -> Option<(FnDescriptor, Option<usize>)> {\n-\n+    pub fn resolve_callable(\n+        &self,\n+        file_id: FileId,\n+        offset: TextUnit,\n+        token: &JobToken,\n+    ) -> Option<(FnDescriptor, Option<usize>)> {\n         let root = self.root(file_id);\n         let file = root.syntax(file_id);\n         let syntax = file.syntax();\n@@ -332,9 +367,7 @@ impl AnalysisImpl {\n                         let mut current_parameter = None;\n \n                         let num_params = descriptor.params.len();\n-                        let has_self = fn_def.param_list()\n-                            .and_then(|l| l.self_param())\n-                            .is_some();\n+                        let has_self = fn_def.param_list().and_then(|l| l.self_param()).is_some();\n \n                         if num_params == 1 {\n                             if !has_self {\n@@ -350,8 +383,11 @@ impl AnalysisImpl {\n                                 let start = arg_list.syntax().range().start();\n \n                                 let range_search = TextRange::from_to(start, offset);\n-                                let mut commas: usize = arg_list.syntax().text()\n-                                    .slice(range_search).to_string()\n+                                let mut commas: usize = arg_list\n+                                    .syntax()\n+                                    .text()\n+                                    .slice(range_search)\n+                                    .to_string()\n                                     .matches(\",\")\n                                     .count();\n \n@@ -381,7 +417,12 @@ impl AnalysisImpl {\n         self.world_symbols(query, token)\n     }\n \n-    fn resolve_module(&self, module_tree: &ModuleTreeDescriptor, file_id: FileId, module: ast::Module) -> Vec<FileId> {\n+    fn resolve_module(\n+        &self,\n+        module_tree: &ModuleTreeDescriptor,\n+        file_id: FileId,\n+        module: ast::Module,\n+    ) -> Vec<FileId> {\n         let name = match module.name() {\n             Some(name) => name.text(),\n             None => return Vec::new(),\n@@ -407,15 +448,17 @@ impl SourceChange {\n             label: label.to_string(),\n             source_file_edits: vec![file_edit],\n             file_system_edits: vec![],\n-            cursor_position: edit.cursor_position\n-                .map(|offset| Position { offset, file_id })\n+            cursor_position: edit\n+                .cursor_position\n+                .map(|offset| Position { offset, file_id }),\n         }\n     }\n }\n \n impl CrateGraph {\n     fn crate_id_for_crate_root(&self, file_id: FileId) -> Option<CrateId> {\n-        let (&crate_id, _) = self.crate_roots\n+        let (&crate_id, _) = self\n+            .crate_roots\n             .iter()\n             .find(|(_crate_id, &root_id)| root_id == file_id)?;\n         Some(crate_id)\n@@ -424,7 +467,7 @@ impl CrateGraph {\n \n enum FnCallNode<'a> {\n     CallExpr(ast::CallExpr<'a>),\n-    MethodCallExpr(ast::MethodCallExpr<'a>)\n+    MethodCallExpr(ast::MethodCallExpr<'a>),\n }\n \n impl<'a> FnCallNode<'a> {\n@@ -440,27 +483,23 @@ impl<'a> FnCallNode<'a> {\n \n     pub fn name_ref(&self) -> Option<ast::NameRef> {\n         match *self {\n-            FnCallNode::CallExpr(call_expr) => {\n-                Some(match call_expr.expr()? {\n-                    Expr::PathExpr(path_expr) => {\n-                        path_expr.path()?.segment()?.name_ref()?\n-                    },\n-                    _ => return None\n-                })\n-            },\n-\n-            FnCallNode::MethodCallExpr(call_expr) => {\n-                call_expr.syntax().children()\n-                    .filter_map(ast::NameRef::cast)\n-                    .nth(0)\n-            }\n+            FnCallNode::CallExpr(call_expr) => Some(match call_expr.expr()? {\n+                Expr::PathExpr(path_expr) => path_expr.path()?.segment()?.name_ref()?,\n+                _ => return None,\n+            }),\n+\n+            FnCallNode::MethodCallExpr(call_expr) => call_expr\n+                .syntax()\n+                .children()\n+                .filter_map(ast::NameRef::cast)\n+                .nth(0),\n         }\n     }\n \n     pub fn arg_list(&self) -> Option<ast::ArgList> {\n         match *self {\n             FnCallNode::CallExpr(expr) => expr.arg_list(),\n-            FnCallNode::MethodCallExpr(expr) => expr.arg_list()\n+            FnCallNode::MethodCallExpr(expr) => expr.arg_list(),\n         }\n     }\n }"}, {"sha": "2871f983908306b8bb6881b3af4dedce8f55198d", "filename": "crates/ra_analysis/src/job.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_analysis%2Fsrc%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_analysis%2Fsrc%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fjob.rs?ref=61f3a438d3a729a6be941bca1ff4c6a97a33f221", "patch": "@@ -14,15 +14,20 @@ impl JobHandle {\n     pub fn new() -> (JobHandle, JobToken) {\n         let (sender_alive, receiver_alive) = bounded(0);\n         let (sender_canceled, receiver_canceled) = bounded(0);\n-        let token = JobToken { _job_alive: sender_alive, job_canceled: receiver_canceled };\n-        let handle = JobHandle { job_alive: receiver_alive, _job_canceled: sender_canceled };\n+        let token = JobToken {\n+            _job_alive: sender_alive,\n+            job_canceled: receiver_canceled,\n+        };\n+        let handle = JobHandle {\n+            job_alive: receiver_alive,\n+            _job_canceled: sender_canceled,\n+        };\n         (handle, token)\n     }\n     pub fn has_completed(&self) -> bool {\n         is_closed(&self.job_alive)\n     }\n-    pub fn cancel(self) {\n-    }\n+    pub fn cancel(self) {}\n }\n \n impl JobToken {\n@@ -31,7 +36,6 @@ impl JobToken {\n     }\n }\n \n-\n // We don't actually send messages through the channels,\n // and instead just check if the channel is closed,\n // so we use uninhabited enum as a message type"}, {"sha": "2eeacaabe34e844019a1f5120a8f56a1d0672ab9", "filename": "crates/ra_analysis/src/lib.rs", "status": "modified", "additions": 46, "deletions": 32, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_analysis%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_analysis%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Flib.rs?ref=61f3a438d3a729a6be941bca1ff4c6a97a33f221", "patch": "@@ -1,44 +1,40 @@\n extern crate parking_lot;\n #[macro_use]\n extern crate log;\n+extern crate fst;\n extern crate once_cell;\n-extern crate ra_syntax;\n extern crate ra_editor;\n-extern crate fst;\n+extern crate ra_syntax;\n extern crate rayon;\n extern crate relative_path;\n #[macro_use]\n extern crate crossbeam_channel;\n extern crate im;\n-extern crate salsa;\n extern crate rustc_hash;\n+extern crate salsa;\n \n-mod symbol_index;\n-mod module_map;\n+mod db;\n+mod descriptors;\n mod imp;\n mod job;\n+mod module_map;\n mod roots;\n-mod db;\n-mod descriptors;\n+mod symbol_index;\n \n-use std::{\n-    sync::Arc,\n-    fmt::Debug,\n-};\n+use std::{fmt::Debug, sync::Arc};\n \n+use crate::imp::{AnalysisHostImpl, AnalysisImpl, FileResolverImp};\n+use ra_syntax::{AtomEdit, File, TextRange, TextUnit};\n use relative_path::{RelativePath, RelativePathBuf};\n-use ra_syntax::{File, TextRange, TextUnit, AtomEdit};\n use rustc_hash::FxHashMap;\n-use crate::imp::{AnalysisImpl, AnalysisHostImpl, FileResolverImp};\n \n-pub use ra_editor::{\n-    StructureNode, LineIndex, FileSymbol,\n-    Runnable, RunnableKind, HighlightedRange, CompletionItem,\n-    Fold, FoldKind\n-};\n pub use crate::{\n-    job::{JobToken, JobHandle},\n     descriptors::FnDescriptor,\n+    job::{JobHandle, JobToken},\n+};\n+pub use ra_editor::{\n+    CompletionItem, FileSymbol, Fold, FoldKind, HighlightedRange, LineIndex, Runnable,\n+    RunnableKind, StructureNode,\n };\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n@@ -59,20 +55,24 @@ pub trait FileResolver: Debug + Send + Sync + 'static {\n \n #[derive(Debug)]\n pub struct AnalysisHost {\n-    imp: AnalysisHostImpl\n+    imp: AnalysisHostImpl,\n }\n \n impl AnalysisHost {\n     pub fn new() -> AnalysisHost {\n-        AnalysisHost { imp: AnalysisHostImpl::new() }\n+        AnalysisHost {\n+            imp: AnalysisHostImpl::new(),\n+        }\n     }\n     pub fn analysis(&self) -> Analysis {\n-        Analysis { imp: self.imp.analysis() }\n+        Analysis {\n+            imp: self.imp.analysis(),\n+        }\n     }\n     pub fn change_file(&mut self, file_id: FileId, text: Option<String>) {\n         self.change_files(::std::iter::once((file_id, text)));\n     }\n-    pub fn change_files(&mut self, mut changes: impl Iterator<Item=(FileId, Option<String>)>) {\n+    pub fn change_files(&mut self, mut changes: impl Iterator<Item = (FileId, Option<String>)>) {\n         self.imp.change_files(&mut changes)\n     }\n     pub fn set_file_resolver(&mut self, resolver: Arc<FileResolver>) {\n@@ -115,7 +115,7 @@ pub enum FileSystemEdit {\n     MoveFile {\n         file: FileId,\n         path: RelativePathBuf,\n-    }\n+    },\n }\n \n #[derive(Debug)]\n@@ -144,7 +144,7 @@ impl Query {\n             only_types: false,\n             libs: false,\n             exact: false,\n-            limit: usize::max_value()\n+            limit: usize::max_value(),\n         }\n     }\n     pub fn only_types(&mut self) {\n@@ -163,7 +163,7 @@ impl Query {\n \n #[derive(Debug)]\n pub struct Analysis {\n-    imp: AnalysisImpl\n+    imp: AnalysisImpl,\n }\n \n impl Analysis {\n@@ -195,7 +195,11 @@ impl Analysis {\n     }\n     pub fn on_eq_typed(&self, file_id: FileId, offset: TextUnit) -> Option<SourceChange> {\n         let file = self.imp.file_syntax(file_id);\n-        Some(SourceChange::from_local_edit(file_id, \"add semicolon\", ra_editor::on_eq_typed(&file, offset)?))\n+        Some(SourceChange::from_local_edit(\n+            file_id,\n+            \"add semicolon\",\n+            ra_editor::on_eq_typed(&file, offset)?,\n+        ))\n     }\n     pub fn file_structure(&self, file_id: FileId) -> Vec<StructureNode> {\n         let file = self.imp.file_syntax(file_id);\n@@ -204,8 +208,14 @@ impl Analysis {\n     pub fn symbol_search(&self, query: Query, token: &JobToken) -> Vec<(FileId, FileSymbol)> {\n         self.imp.world_symbols(query, token)\n     }\n-    pub fn approximately_resolve_symbol(&self, file_id: FileId, offset: TextUnit, token: &JobToken) -> Vec<(FileId, FileSymbol)> {\n-        self.imp.approximately_resolve_symbol(file_id, offset, token)\n+    pub fn approximately_resolve_symbol(\n+        &self,\n+        file_id: FileId,\n+        offset: TextUnit,\n+        token: &JobToken,\n+    ) -> Vec<(FileId, FileSymbol)> {\n+        self.imp\n+            .approximately_resolve_symbol(file_id, offset, token)\n     }\n     pub fn parent_module(&self, file_id: FileId) -> Vec<(FileId, FileSymbol)> {\n         self.imp.parent_module(file_id)\n@@ -239,15 +249,19 @@ impl Analysis {\n         ra_editor::folding_ranges(&file)\n     }\n \n-    pub fn resolve_callable(&self, file_id: FileId, offset: TextUnit, token: &JobToken)\n-        -> Option<(FnDescriptor, Option<usize>)> {\n+    pub fn resolve_callable(\n+        &self,\n+        file_id: FileId,\n+        offset: TextUnit,\n+        token: &JobToken,\n+    ) -> Option<(FnDescriptor, Option<usize>)> {\n         self.imp.resolve_callable(file_id, offset, token)\n     }\n }\n \n #[derive(Debug)]\n pub struct LibraryData {\n-    root: roots::ReadonlySourceRoot\n+    root: roots::ReadonlySourceRoot,\n }\n \n impl LibraryData {"}, {"sha": "ff0ec3cc7b2d8ca15d1ed092fdd90ccaf1971a7e", "filename": "crates/ra_analysis/src/module_map.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_analysis%2Fsrc%2Fmodule_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_analysis%2Fsrc%2Fmodule_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fmodule_map.rs?ref=61f3a438d3a729a6be941bca1ff4c6a97a33f221", "patch": "@@ -1,10 +1,11 @@\n-use std::sync::Arc;\n use crate::{\n-    FileId,\n-    db::{SyntaxDatabase},\n+    db::SyntaxDatabase,\n     descriptors::{ModuleDescriptor, ModuleTreeDescriptor},\n+    FileId,\n };\n \n+use std::sync::Arc;\n+\n salsa::query_group! {\n     pub(crate) trait ModulesDatabase: SyntaxDatabase {\n         fn module_tree(key: ()) -> Arc<ModuleTreeDescriptor> {\n@@ -16,7 +17,6 @@ salsa::query_group! {\n     }\n }\n \n-\n fn module_descriptor(db: &impl ModulesDatabase, file_id: FileId) -> Arc<ModuleDescriptor> {\n     let file = db.file_syntax(file_id);\n     Arc::new(ModuleDescriptor::new(file.ast()))\n@@ -29,6 +29,9 @@ fn module_tree(db: &impl ModulesDatabase, (): ()) -> Arc<ModuleTreeDescriptor> {\n         let module_descr = db.module_descriptor(file_id);\n         files.push((file_id, module_descr));\n     }\n-    let res = ModuleTreeDescriptor::new(files.iter().map(|(file_id, descr)| (*file_id, &**descr)), &file_set.resolver);\n+    let res = ModuleTreeDescriptor::new(\n+        files.iter().map(|(file_id, descr)| (*file_id, &**descr)),\n+        &file_set.resolver,\n+    );\n     Arc::new(res)\n }"}, {"sha": "1f2b21b272f29fa15584166af941ce31e6094245", "filename": "crates/ra_analysis/src/roots.rs", "status": "modified", "additions": 31, "deletions": 32, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_analysis%2Fsrc%2Froots.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_analysis%2Fsrc%2Froots.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Froots.rs?ref=61f3a438d3a729a6be941bca1ff4c6a97a33f221", "patch": "@@ -1,22 +1,19 @@\n-use std::{\n-    sync::Arc,\n-    panic,\n-};\n+use std::{panic, sync::Arc};\n \n use once_cell::sync::OnceCell;\n-use rayon::prelude::*;\n-use salsa::Database;\n-use rustc_hash::{FxHashMap, FxHashSet};\n use ra_editor::LineIndex;\n use ra_syntax::File;\n+use rayon::prelude::*;\n+use rustc_hash::{FxHashMap, FxHashSet};\n+use salsa::Database;\n \n use crate::{\n-    FileId,\n-    imp::FileResolverImp,\n-    symbol_index::SymbolIndex,\n-    descriptors::{ModuleDescriptor, ModuleTreeDescriptor},\n     db::{self, FilesDatabase, SyntaxDatabase},\n+    descriptors::{ModuleDescriptor, ModuleTreeDescriptor},\n+    imp::FileResolverImp,\n     module_map::ModulesDatabase,\n+    symbol_index::SymbolIndex,\n+    FileId,\n };\n \n pub(crate) trait SourceRoot {\n@@ -35,7 +32,7 @@ pub(crate) struct WritableSourceRoot {\n impl WritableSourceRoot {\n     pub fn apply_changes(\n         &mut self,\n-        changes: &mut dyn Iterator<Item=(FileId, Option<String>)>,\n+        changes: &mut dyn Iterator<Item = (FileId, Option<String>)>,\n         file_resolver: Option<FileResolverImp>,\n     ) {\n         let mut changed = FxHashSet::default();\n@@ -46,22 +43,22 @@ impl WritableSourceRoot {\n                     removed.insert(file_id);\n                 }\n                 Some(text) => {\n-                    self.db.query(db::FileTextQuery)\n+                    self.db\n+                        .query(db::FileTextQuery)\n                         .set(file_id, Arc::new(text));\n                     changed.insert(file_id);\n                 }\n             }\n         }\n         let file_set = self.db.file_set(());\n-        let mut files: FxHashSet<FileId> = file_set\n-            .files\n-            .clone();\n+        let mut files: FxHashSet<FileId> = file_set.files.clone();\n         for file_id in removed {\n             files.remove(&file_id);\n         }\n         files.extend(changed);\n         let resolver = file_resolver.unwrap_or_else(|| file_set.resolver.clone());\n-        self.db.query(db::FileSetQuery)\n+        self.db\n+            .query(db::FileSetQuery)\n             .set((), Arc::new(db::FileSet { files, resolver }));\n     }\n }\n@@ -71,9 +68,7 @@ impl SourceRoot for WritableSourceRoot {\n         self.db.module_tree(())\n     }\n     fn contains(&self, file_id: FileId) -> bool {\n-        self.db.file_set(())\n-            .files\n-            .contains(&file_id)\n+        self.db.file_set(()).files.contains(&file_id)\n     }\n     fn lines(&self, file_id: FileId) -> Arc<LineIndex> {\n         self.db.file_lines(file_id)\n@@ -83,7 +78,7 @@ impl SourceRoot for WritableSourceRoot {\n     }\n     fn symbols<'a>(&'a self, acc: &mut Vec<Arc<SymbolIndex>>) {\n         let db = &self.db;\n-        let symbols =  db.file_set(());\n+        let symbols = db.file_set(());\n         let symbols = symbols\n             .files\n             .iter()\n@@ -108,12 +103,15 @@ impl FileData {\n         }\n     }\n     fn lines(&self) -> &Arc<LineIndex> {\n-        self.lines.get_or_init(|| Arc::new(LineIndex::new(&self.text)))\n+        self.lines\n+            .get_or_init(|| Arc::new(LineIndex::new(&self.text)))\n     }\n     fn syntax(&self) -> &File {\n         let text = &self.text;\n         let syntax = &self.syntax;\n-        match panic::catch_unwind(panic::AssertUnwindSafe(|| syntax.get_or_init(|| File::parse(text)))) {\n+        match panic::catch_unwind(panic::AssertUnwindSafe(|| {\n+            syntax.get_or_init(|| File::parse(text))\n+        })) {\n             Ok(file) => file,\n             Err(err) => {\n                 error!(\"Parser paniced on:\\n------\\n{}\\n------\\n\", text);\n@@ -131,22 +129,23 @@ pub(crate) struct ReadonlySourceRoot {\n }\n \n impl ReadonlySourceRoot {\n-    pub(crate) fn new(files: Vec<(FileId, String)>, file_resolver: FileResolverImp) -> ReadonlySourceRoot {\n-        let modules = files.par_iter()\n+    pub(crate) fn new(\n+        files: Vec<(FileId, String)>,\n+        file_resolver: FileResolverImp,\n+    ) -> ReadonlySourceRoot {\n+        let modules = files\n+            .par_iter()\n             .map(|(file_id, text)| {\n                 let syntax = File::parse(text);\n                 let mod_descr = ModuleDescriptor::new(syntax.ast());\n                 (*file_id, syntax, mod_descr)\n             })\n             .collect::<Vec<_>>();\n-        let module_tree = ModuleTreeDescriptor::new(\n-            modules.iter().map(|it| (it.0, &it.2)),\n-            &file_resolver,\n-        );\n+        let module_tree =\n+            ModuleTreeDescriptor::new(modules.iter().map(|it| (it.0, &it.2)), &file_resolver);\n \n-        let symbol_index = SymbolIndex::for_files(\n-            modules.par_iter().map(|it| (it.0, it.1.clone()))\n-        );\n+        let symbol_index =\n+            SymbolIndex::for_files(modules.par_iter().map(|it| (it.0, it.1.clone())));\n         let file_map: FxHashMap<FileId, FileData> = files\n             .into_iter()\n             .map(|(id, text)| (id, FileData::new(text)))"}, {"sha": "51eef817043344c6b4c9d6ce0c3084a13f25a56f", "filename": "crates/ra_analysis/src/symbol_index.rs", "status": "modified", "additions": 12, "deletions": 17, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_analysis%2Fsrc%2Fsymbol_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_analysis%2Fsrc%2Fsymbol_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Fsrc%2Fsymbol_index.rs?ref=61f3a438d3a729a6be941bca1ff4c6a97a33f221", "patch": "@@ -1,15 +1,16 @@\n-use std::{\n-    sync::Arc,\n-    hash::{Hash, Hasher},\n-};\n-use ra_editor::{FileSymbol, file_symbols};\n+use crate::{FileId, JobToken, Query};\n+use fst::{self, Streamer};\n+use ra_editor::{file_symbols, FileSymbol};\n use ra_syntax::{\n     File,\n     SyntaxKind::{self, *},\n };\n-use fst::{self, Streamer};\n use rayon::prelude::*;\n-use crate::{Query, FileId, JobToken};\n+\n+use std::{\n+    hash::{Hash, Hasher},\n+    sync::Arc,\n+};\n \n #[derive(Debug)]\n pub(crate) struct SymbolIndex {\n@@ -23,8 +24,7 @@ impl PartialEq for SymbolIndex {\n     }\n }\n \n-impl Eq for SymbolIndex {\n-}\n+impl Eq for SymbolIndex {}\n \n impl Hash for SymbolIndex {\n     fn hash<H: Hasher>(&self, hasher: &mut H) {\n@@ -33,24 +33,20 @@ impl Hash for SymbolIndex {\n }\n \n impl SymbolIndex {\n-    pub(crate) fn for_files(files: impl ParallelIterator<Item=(FileId, File)>) -> SymbolIndex {\n+    pub(crate) fn for_files(files: impl ParallelIterator<Item = (FileId, File)>) -> SymbolIndex {\n         let mut symbols = files\n             .flat_map(|(file_id, file)| {\n                 file_symbols(&file)\n                     .into_iter()\n-                    .map(move |symbol| {\n-                        (symbol.name.as_str().to_lowercase(), (file_id, symbol))\n-                    })\n+                    .map(move |symbol| (symbol.name.as_str().to_lowercase(), (file_id, symbol)))\n                     .collect::<Vec<_>>()\n             })\n             .collect::<Vec<_>>();\n         symbols.par_sort_by(|s1, s2| s1.0.cmp(&s2.0));\n         symbols.dedup_by(|s1, s2| s1.0 == s2.0);\n         let (names, symbols): (Vec<String>, Vec<(FileId, FileSymbol)>) =\n             symbols.into_iter().unzip();\n-        let map = fst::Map::from_iter(\n-            names.into_iter().zip(0u64..)\n-        ).unwrap();\n+        let map = fst::Map::from_iter(names.into_iter().zip(0u64..)).unwrap();\n         SymbolIndex { symbols, map }\n     }\n \n@@ -65,7 +61,6 @@ impl Query {\n         indices: &[Arc<SymbolIndex>],\n         token: &JobToken,\n     ) -> Vec<(FileId, FileSymbol)> {\n-\n         let mut op = fst::map::OpBuilder::new();\n         for file_symbols in indices.iter() {\n             let automaton = fst::automaton::Subsequence::new(&self.lowercased);"}, {"sha": "e0c637d65d59748e0982c0a6cc7a48dcffa311eb", "filename": "crates/ra_analysis/tests/tests.rs", "status": "modified", "additions": 34, "deletions": 48, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_analysis%2Ftests%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_analysis%2Ftests%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_analysis%2Ftests%2Ftests.rs?ref=61f3a438d3a729a6be941bca1ff4c6a97a33f221", "patch": "@@ -1,32 +1,31 @@\n-extern crate relative_path;\n extern crate ra_analysis;\n-extern crate rustc_hash;\n extern crate ra_editor;\n extern crate ra_syntax;\n+extern crate relative_path;\n+extern crate rustc_hash;\n extern crate test_utils;\n \n-use std::{\n-    sync::Arc,\n-};\n+use std::sync::Arc;\n \n-use rustc_hash::FxHashMap;\n+use ra_analysis::{\n+    Analysis, AnalysisHost, CrateGraph, CrateId, FileId, FileResolver, FnDescriptor, JobHandle,\n+};\n use relative_path::{RelativePath, RelativePathBuf};\n-use ra_analysis::{Analysis, AnalysisHost, FileId, FileResolver, JobHandle, CrateGraph, CrateId, FnDescriptor};\n+use rustc_hash::FxHashMap;\n use test_utils::{assert_eq_dbg, extract_offset};\n \n #[derive(Debug)]\n struct FileMap(Vec<(FileId, RelativePathBuf)>);\n \n impl FileMap {\n-    fn iter<'a>(&'a self) -> impl Iterator<Item=(FileId, &'a RelativePath)> + 'a {\n-        self.0.iter().map(|(id, path)| (*id, path.as_relative_path()))\n+    fn iter<'a>(&'a self) -> impl Iterator<Item = (FileId, &'a RelativePath)> + 'a {\n+        self.0\n+            .iter()\n+            .map(|(id, path)| (*id, path.as_relative_path()))\n     }\n \n     fn path(&self, id: FileId) -> &RelativePath {\n-        self.iter()\n-            .find(|&(it, _)| it == id)\n-            .unwrap()\n-            .1\n+        self.iter().find(|&(it, _)| it == id).unwrap().1\n     }\n }\n \n@@ -71,21 +70,15 @@ fn get_signature(text: &str) -> (FnDescriptor, Option<usize>) {\n \n #[test]\n fn test_resolve_module() {\n-    let snap = analysis(&[\n-        (\"/lib.rs\", \"mod foo;\"),\n-        (\"/foo.rs\", \"\")\n-    ]);\n+    let snap = analysis(&[(\"/lib.rs\", \"mod foo;\"), (\"/foo.rs\", \"\")]);\n     let (_handle, token) = JobHandle::new();\n     let symbols = snap.approximately_resolve_symbol(FileId(1), 4.into(), &token);\n     assert_eq_dbg(\n         r#\"[(FileId(2), FileSymbol { name: \"foo\", node_range: [0; 0), kind: MODULE })]\"#,\n         &symbols,\n     );\n \n-    let snap = analysis(&[\n-        (\"/lib.rs\", \"mod foo;\"),\n-        (\"/foo/mod.rs\", \"\")\n-    ]);\n+    let snap = analysis(&[(\"/lib.rs\", \"mod foo;\"), (\"/foo/mod.rs\", \"\")]);\n     let symbols = snap.approximately_resolve_symbol(FileId(1), 4.into(), &token);\n     assert_eq_dbg(\n         r#\"[(FileId(2), FileSymbol { name: \"foo\", node_range: [0; 0), kind: MODULE })]\"#,\n@@ -114,18 +107,12 @@ fn test_unresolved_module_diagnostic() {\n fn test_unresolved_module_diagnostic_no_diag_for_inline_mode() {\n     let snap = analysis(&[(\"/lib.rs\", \"mod foo {}\")]);\n     let diagnostics = snap.diagnostics(FileId(1));\n-    assert_eq_dbg(\n-        r#\"[]\"#,\n-        &diagnostics,\n-    );\n+    assert_eq_dbg(r#\"[]\"#, &diagnostics);\n }\n \n #[test]\n fn test_resolve_parent_module() {\n-    let snap = analysis(&[\n-        (\"/lib.rs\", \"mod foo;\"),\n-        (\"/foo.rs\", \"\"),\n-    ]);\n+    let snap = analysis(&[(\"/lib.rs\", \"mod foo;\"), (\"/foo.rs\", \"\")]);\n     let symbols = snap.parent_module(FileId(2));\n     assert_eq_dbg(\n         r#\"[(FileId(1), FileSymbol { name: \"foo\", node_range: [0; 8), kind: MODULE })]\"#,\n@@ -135,10 +122,7 @@ fn test_resolve_parent_module() {\n \n #[test]\n fn test_resolve_crate_root() {\n-    let mut host = analysis_host(&[\n-        (\"/lib.rs\", \"mod foo;\"),\n-        (\"/foo.rs\", \"\"),\n-    ]);\n+    let mut host = analysis_host(&[(\"/lib.rs\", \"mod foo;\"), (\"/foo.rs\", \"\")]);\n     let snap = host.analysis();\n     assert!(snap.crate_for(FileId(2)).is_empty());\n \n@@ -152,20 +136,18 @@ fn test_resolve_crate_root() {\n     host.set_crate_graph(crate_graph);\n     let snap = host.analysis();\n \n-    assert_eq!(\n-        snap.crate_for(FileId(2)),\n-        vec![CrateId(1)],\n-    );\n+    assert_eq!(snap.crate_for(FileId(2)), vec![CrateId(1)],);\n }\n \n #[test]\n fn test_fn_signature_two_args_first() {\n     let (desc, param) = get_signature(\n-r#\"fn foo(x: u32, y: u32) -> u32 {x + y}\n-fn bar() { foo(<|>3, ); }\"#);\n+        r#\"fn foo(x: u32, y: u32) -> u32 {x + y}\n+fn bar() { foo(<|>3, ); }\"#,\n+    );\n \n     assert_eq!(desc.name, \"foo\".to_string());\n-    assert_eq!(desc.params, vec!(\"x\".to_string(),\"y\".to_string()));\n+    assert_eq!(desc.params, vec!(\"x\".to_string(), \"y\".to_string()));\n     assert_eq!(desc.ret_type, Some(\"-> u32\".into()));\n     assert_eq!(param, Some(0));\n }\n@@ -174,19 +156,21 @@ fn bar() { foo(<|>3, ); }\"#);\n fn test_fn_signature_two_args_second() {\n     let (desc, param) = get_signature(\n         r#\"fn foo(x: u32, y: u32) -> u32 {x + y}\n-fn bar() { foo(3, <|>); }\"#);\n+fn bar() { foo(3, <|>); }\"#,\n+    );\n \n     assert_eq!(desc.name, \"foo\".to_string());\n-    assert_eq!(desc.params, vec!(\"x\".to_string(),\"y\".to_string()));\n+    assert_eq!(desc.params, vec!(\"x\".to_string(), \"y\".to_string()));\n     assert_eq!(desc.ret_type, Some(\"-> u32\".into()));\n     assert_eq!(param, Some(1));\n }\n \n #[test]\n fn test_fn_signature_for_impl() {\n     let (desc, param) = get_signature(\n-r#\"struct F; impl F { pub fn new() { F{}} }\n-fn bar() {let _ : F = F::new(<|>);}\"#);\n+        r#\"struct F; impl F { pub fn new() { F{}} }\n+fn bar() {let _ : F = F::new(<|>);}\"#,\n+    );\n \n     assert_eq!(desc.name, \"new\".to_string());\n     assert_eq!(desc.params, Vec::<String>::new());\n@@ -197,7 +181,7 @@ fn bar() {let _ : F = F::new(<|>);}\"#);\n #[test]\n fn test_fn_signature_for_method_self() {\n     let (desc, param) = get_signature(\n-r#\"struct F;\n+        r#\"struct F;\n impl F {\n     pub fn new() -> F{\n         F{}\n@@ -209,7 +193,8 @@ impl F {\n fn bar() {\n     let f : F = F::new();\n     f.do_it(<|>);\n-}\"#);\n+}\"#,\n+    );\n \n     assert_eq!(desc.name, \"do_it\".to_string());\n     assert_eq!(desc.params, vec![\"&self\".to_string()]);\n@@ -220,7 +205,7 @@ fn bar() {\n #[test]\n fn test_fn_signature_for_method_with_arg() {\n     let (desc, param) = get_signature(\n-r#\"struct F;\n+        r#\"struct F;\n impl F {\n     pub fn new() -> F{\n         F{}\n@@ -232,7 +217,8 @@ impl F {\n fn bar() {\n     let f : F = F::new();\n     f.do_it(<|>);\n-}\"#);\n+}\"#,\n+    );\n \n     assert_eq!(desc.name, \"do_it\".to_string());\n     assert_eq!(desc.params, vec![\"&self\".to_string(), \"x\".to_string()]);"}, {"sha": "239d846b323ff588083cf60225db4e6dad492e8d", "filename": "crates/ra_cli/src/main.rs", "status": "modified", "additions": 12, "deletions": 15, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_cli%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_cli%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_cli%2Fsrc%2Fmain.rs?ref=61f3a438d3a729a6be941bca1ff4c6a97a33f221", "patch": "@@ -2,19 +2,17 @@ extern crate clap;\n #[macro_use]\n extern crate failure;\n extern crate join_to_string;\n-extern crate ra_syntax;\n extern crate ra_editor;\n+extern crate ra_syntax;\n extern crate tools;\n \n-use std::{\n-    fs, io::Read, path::Path,\n-    time::Instant\n-};\n+use std::{fs, io::Read, path::Path, time::Instant};\n+\n use clap::{App, Arg, SubCommand};\n use join_to_string::join;\n+use ra_editor::{extend_selection, file_structure, syntax_tree};\n+use ra_syntax::{File, TextRange};\n use tools::collect_tests;\n-use ra_syntax::{TextRange, File};\n-use ra_editor::{syntax_tree, file_structure, extend_selection};\n \n type Result<T> = ::std::result::Result<T, failure::Error>;\n \n@@ -36,14 +34,12 @@ fn main() -> Result<()> {\n                         .takes_value(true),\n                 ),\n         )\n-        .subcommand(\n-            SubCommand::with_name(\"parse\")\n-                .arg(Arg::with_name(\"no-dump\").long(\"--no-dump\"))\n-        )\n+        .subcommand(SubCommand::with_name(\"parse\").arg(Arg::with_name(\"no-dump\").long(\"--no-dump\")))\n         .subcommand(SubCommand::with_name(\"symbols\"))\n-        .subcommand(SubCommand::with_name(\"extend-selection\")\n-            .arg(Arg::with_name(\"start\"))\n-            .arg(Arg::with_name(\"end\"))\n+        .subcommand(\n+            SubCommand::with_name(\"extend-selection\")\n+                .arg(Arg::with_name(\"start\"))\n+                .arg(Arg::with_name(\"end\")),\n         )\n         .get_matches();\n     match matches.subcommand() {\n@@ -116,7 +112,8 @@ fn selections(file: &File, start: u32, end: u32) -> String {\n         ranges.push(r);\n         cur = extend_selection(&file, r);\n     }\n-    let ranges = ranges.iter()\n+    let ranges = ranges\n+        .iter()\n         .map(|r| (1 + u32::from(r.start()), 1 + u32::from(r.end())))\n         .map(|(s, e)| format!(\"({} {})\", s, e));\n     join(ranges)"}, {"sha": "cadcd27207a5215a4c58b75f119abf4e56a67e63", "filename": "crates/ra_editor/src/code_actions.rs", "status": "modified", "additions": 29, "deletions": 20, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_editor%2Fsrc%2Fcode_actions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_editor%2Fsrc%2Fcode_actions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fsrc%2Fcode_actions.rs?ref=61f3a438d3a729a6be941bca1ff4c6a97a33f221", "patch": "@@ -1,17 +1,14 @@\n use join_to_string::join;\n \n use ra_syntax::{\n-    File, TextUnit, TextRange, Direction,\n-    ast::{self, AstNode, AttrsOwner, TypeParamsOwner, NameOwner},\n+    algo::{find_covering_node, find_leaf_at_offset},\n+    ast::{self, AstNode, AttrsOwner, NameOwner, TypeParamsOwner},\n+    Direction, File,\n     SyntaxKind::{COMMA, WHITESPACE},\n-    SyntaxNodeRef,\n-    algo::{\n-        find_leaf_at_offset,\n-        find_covering_node,\n-    },\n+    SyntaxNodeRef, TextRange, TextUnit,\n };\n \n-use crate::{EditBuilder, Edit, find_node_at_offset};\n+use crate::{find_node_at_offset, Edit, EditBuilder};\n \n #[derive(Debug)]\n pub struct LocalEdit {\n@@ -52,9 +49,7 @@ pub fn add_derive<'a>(file: &'a File, offset: TextUnit) -> Option<impl FnOnce()\n                 edit.insert(node_start, \"#[derive()]\\n\".to_string());\n                 node_start + TextUnit::of_str(\"#[derive(\")\n             }\n-            Some(tt) => {\n-                tt.syntax().range().end() - TextUnit::of_char(')')\n-            }\n+            Some(tt) => tt.syntax().range().end() - TextUnit::of_char(')'),\n         };\n         LocalEdit {\n             edit: edit.finish(),\n@@ -74,14 +69,19 @@ pub fn add_impl<'a>(file: &'a File, offset: TextUnit) -> Option<impl FnOnce() ->\n         let mut buf = String::new();\n         buf.push_str(\"\\n\\nimpl\");\n         if let Some(type_params) = type_params {\n-            type_params.syntax().text()\n-                .push_to(&mut buf);\n+            type_params.syntax().text().push_to(&mut buf);\n         }\n         buf.push_str(\" \");\n         buf.push_str(name.text().as_str());\n         if let Some(type_params) = type_params {\n-            let lifetime_params = type_params.lifetime_params().filter_map(|it| it.lifetime()).map(|it| it.text());\n-            let type_params = type_params.type_params().filter_map(|it| it.name()).map(|it| it.text());\n+            let lifetime_params = type_params\n+                .lifetime_params()\n+                .filter_map(|it| it.lifetime())\n+                .map(|it| it.text());\n+            let type_params = type_params\n+                .type_params()\n+                .filter_map(|it| it.name())\n+                .map(|it| it.text());\n             join(lifetime_params.chain(type_params))\n                 .surround_with(\"<\", \">\")\n                 .to_buf(&mut buf);\n@@ -97,10 +97,17 @@ pub fn add_impl<'a>(file: &'a File, offset: TextUnit) -> Option<impl FnOnce() ->\n     })\n }\n \n-pub fn introduce_variable<'a>(file: &'a File, range: TextRange) -> Option<impl FnOnce() -> LocalEdit + 'a> {\n+pub fn introduce_variable<'a>(\n+    file: &'a File,\n+    range: TextRange,\n+) -> Option<impl FnOnce() -> LocalEdit + 'a> {\n     let node = find_covering_node(file.syntax(), range);\n     let expr = node.ancestors().filter_map(ast::Expr::cast).next()?;\n-    let anchor_stmt = expr.syntax().ancestors().filter_map(ast::Stmt::cast).next()?;\n+    let anchor_stmt = expr\n+        .syntax()\n+        .ancestors()\n+        .filter_map(ast::Stmt::cast)\n+        .next()?;\n     let indent = anchor_stmt.syntax().prev_sibling()?;\n     if indent.kind() != WHITESPACE {\n         return None;\n@@ -191,7 +198,8 @@ mod tests {\n             \"\n fn foo() {\n     foo(<|>1 + 1<|>);\n-}\", \"\n+}\",\n+            \"\n fn foo() {\n     let <|>var_name = 1 + 1;\n     foo(var_name);\n@@ -201,11 +209,12 @@ fn foo() {\n     }\n     #[test]\n     fn test_intrdoduce_var_expr_stmt() {\n-check_action_range(\n+        check_action_range(\n             \"\n fn foo() {\n     <|>1 + 1<|>;\n-}\", \"\n+}\",\n+            \"\n fn foo() {\n     let <|>var_name = 1 + 1;\n }\","}, {"sha": "86ef46ebd943a11e94294b240b1c9f6454411745", "filename": "crates/ra_editor/src/completion.rs", "status": "modified", "additions": 114, "deletions": 64, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_editor%2Fsrc%2Fcompletion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_editor%2Fsrc%2Fcompletion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fsrc%2Fcompletion.rs?ref=61f3a438d3a729a6be941bca1ff4c6a97a33f221", "patch": "@@ -1,17 +1,18 @@\n use rustc_hash::{FxHashMap, FxHashSet};\n \n use ra_syntax::{\n-    File, TextUnit, AstNode, SyntaxNodeRef, SyntaxKind::*,\n+    algo::visit::{visitor, visitor_ctx, Visitor, VisitorCtx},\n     ast::{self, LoopBodyOwner, ModuleItemOwner},\n-    algo::{\n-        visit::{visitor, Visitor, visitor_ctx, VisitorCtx},\n-    },\n     text_utils::is_subrange,\n+    AstNode, File,\n+    SyntaxKind::*,\n+    SyntaxNodeRef, TextUnit,\n };\n \n use crate::{\n-    AtomEdit, find_node_at_offset,\n+    find_node_at_offset,\n     scope::{FnScopes, ModuleScope},\n+    AtomEdit,\n };\n \n #[derive(Debug)]\n@@ -21,7 +22,7 @@ pub struct CompletionItem {\n     /// What string is used for filtering, defaults to label\n     pub lookup: Option<String>,\n     /// What is inserted, defaults to label\n-    pub snippet: Option<String>\n+    pub snippet: Option<String>,\n }\n \n pub fn scope_completion(file: &File, offset: TextUnit) -> Option<Vec<CompletionItem>> {\n@@ -40,7 +41,12 @@ pub fn scope_completion(file: &File, offset: TextUnit) -> Option<Vec<CompletionI\n             param_completions(name_ref.syntax(), &mut res);\n         }\n         let name_range = name_ref.syntax().range();\n-        let top_node = name_ref.syntax().ancestors().take_while(|it| it.range() == name_range).last().unwrap();\n+        let top_node = name_ref\n+            .syntax()\n+            .ancestors()\n+            .take_while(|it| it.range() == name_range)\n+            .last()\n+            .unwrap();\n         match top_node.parent().map(|it| it.kind()) {\n             Some(ROOT) | Some(ITEM_LIST) => complete_mod_item_snippets(&mut res),\n             _ => (),\n@@ -68,21 +74,23 @@ fn complete_name_ref(file: &File, name_ref: ast::NameRef, acc: &mut Vec<Completi\n         if let Some(items) = visitor()\n             .visit::<ast::Root, _>(|it| Some(it.items()))\n             .visit::<ast::Module, _>(|it| Some(it.item_list()?.items()))\n-            .accept(node) {\n+            .accept(node)\n+        {\n             if let Some(items) = items {\n                 let scope = ModuleScope::new(items);\n                 acc.extend(\n-                    scope.entries().iter()\n+                    scope\n+                        .entries()\n+                        .iter()\n                         .filter(|entry| entry.syntax() != name_ref.syntax())\n                         .map(|entry| CompletionItem {\n                             label: entry.name().to_string(),\n                             lookup: None,\n                             snippet: None,\n-                        })\n+                        }),\n                 );\n             }\n             break;\n-\n         } else if !visited_fn {\n             if let Some(fn_def) = ast::FnDef::cast(node) {\n                 visited_fn = true;\n@@ -103,26 +111,34 @@ fn param_completions(ctx: SyntaxNodeRef, acc: &mut Vec<CompletionItem>) {\n             .visit::<ast::ItemList, _>(process)\n             .accept(node);\n     }\n-    params.into_iter()\n+    params\n+        .into_iter()\n         .filter_map(|(label, (count, param))| {\n             let lookup = param.pat()?.syntax().text().to_string();\n-            if count < 2 { None } else { Some((label, lookup)) }\n+            if count < 2 {\n+                None\n+            } else {\n+                Some((label, lookup))\n+            }\n         })\n         .for_each(|(label, lookup)| {\n             acc.push(CompletionItem {\n-                label, lookup: Some(lookup), snippet: None\n+                label,\n+                lookup: Some(lookup),\n+                snippet: None,\n             })\n         });\n \n-    fn process<'a, N: ast::FnDefOwner<'a>>(node: N, params: &mut FxHashMap<String, (u32, ast::Param<'a>)>) {\n+    fn process<'a, N: ast::FnDefOwner<'a>>(\n+        node: N,\n+        params: &mut FxHashMap<String, (u32, ast::Param<'a>)>,\n+    ) {\n         node.functions()\n             .filter_map(|it| it.param_list())\n             .flat_map(|it| it.params())\n             .for_each(|param| {\n                 let text = param.syntax().text().to_string();\n-                params.entry(text)\n-                      .or_insert((0, param))\n-                      .0 += 1;\n+                params.entry(text).or_insert((0, param)).0 += 1;\n             })\n     }\n }\n@@ -134,8 +150,12 @@ fn is_node<'a, N: AstNode<'a>>(node: SyntaxNodeRef<'a>) -> bool {\n     }\n }\n \n-\n-fn complete_expr_keywords(file: &File, fn_def: ast::FnDef, name_ref: ast::NameRef, acc: &mut Vec<CompletionItem>) {\n+fn complete_expr_keywords(\n+    file: &File,\n+    fn_def: ast::FnDef,\n+    name_ref: ast::NameRef,\n+    acc: &mut Vec<CompletionItem>,\n+) {\n     acc.push(keyword(\"if\", \"if $0 {}\"));\n     acc.push(keyword(\"match\", \"match $0 {}\"));\n     acc.push(keyword(\"while\", \"while $0 {}\"));\n@@ -186,9 +206,14 @@ fn complete_return(fn_def: ast::FnDef, name_ref: ast::NameRef) -> Option<Complet\n     //     return None;\n     // }\n \n-    let is_stmt = match name_ref.syntax().ancestors().filter_map(ast::ExprStmt::cast).next() {\n+    let is_stmt = match name_ref\n+        .syntax()\n+        .ancestors()\n+        .filter_map(ast::ExprStmt::cast)\n+        .next()\n+    {\n         None => false,\n-        Some(expr_stmt) => expr_stmt.syntax().range() == name_ref.syntax().range()\n+        Some(expr_stmt) => expr_stmt.syntax().range() == name_ref.syntax().range(),\n     };\n     let snip = match (is_stmt, fn_def.ret_type().is_some()) {\n         (true, true) => \"return $0;\",\n@@ -209,39 +234,37 @@ fn keyword(kw: &str, snip: &str) -> CompletionItem {\n \n fn complete_expr_snippets(acc: &mut Vec<CompletionItem>) {\n     acc.push(CompletionItem {\n-            label: \"pd\".to_string(),\n-            lookup: None,\n-            snippet: Some(\"eprintln!(\\\"$0 = {:?}\\\", $0);\".to_string()),\n-        }\n-    );\n+        label: \"pd\".to_string(),\n+        lookup: None,\n+        snippet: Some(\"eprintln!(\\\"$0 = {:?}\\\", $0);\".to_string()),\n+    });\n     acc.push(CompletionItem {\n-            label: \"ppd\".to_string(),\n-            lookup: None,\n-            snippet: Some(\"eprintln!(\\\"$0 = {:#?}\\\", $0);\".to_string()),\n-        }\n-    );\n+        label: \"ppd\".to_string(),\n+        lookup: None,\n+        snippet: Some(\"eprintln!(\\\"$0 = {:#?}\\\", $0);\".to_string()),\n+    });\n }\n \n fn complete_mod_item_snippets(acc: &mut Vec<CompletionItem>) {\n     acc.push(CompletionItem {\n-            label: \"tfn\".to_string(),\n-            lookup: None,\n-            snippet: Some(\"#[test]\\nfn $1() {\\n    $0\\n}\".to_string()),\n-        }\n-    );\n+        label: \"tfn\".to_string(),\n+        lookup: None,\n+        snippet: Some(\"#[test]\\nfn $1() {\\n    $0\\n}\".to_string()),\n+    });\n }\n \n fn complete_fn(name_ref: ast::NameRef, scopes: &FnScopes, acc: &mut Vec<CompletionItem>) {\n     let mut shadowed = FxHashSet::default();\n     acc.extend(\n-        scopes.scope_chain(name_ref.syntax())\n+        scopes\n+            .scope_chain(name_ref.syntax())\n             .flat_map(|scope| scopes.entries(scope).iter())\n             .filter(|entry| shadowed.insert(entry.name()))\n             .map(|entry| CompletionItem {\n                 label: entry.name().to_string(),\n                 lookup: None,\n                 snippet: None,\n-            })\n+            }),\n     );\n     if scopes.self_param.is_some() {\n         acc.push(CompletionItem {\n@@ -281,20 +304,24 @@ mod tests {\n \n     #[test]\n     fn test_completion_let_scope() {\n-        check_scope_completion(r\"\n+        check_scope_completion(\n+            r\"\n             fn quux(x: i32) {\n                 let y = 92;\n                 1 + <|>;\n                 let z = ();\n             }\n-            \", r#\"[CompletionItem { label: \"y\", lookup: None, snippet: None },\n+            \",\n+            r#\"[CompletionItem { label: \"y\", lookup: None, snippet: None },\n                    CompletionItem { label: \"x\", lookup: None, snippet: None },\n-                   CompletionItem { label: \"quux\", lookup: None, snippet: None }]\"#);\n+                   CompletionItem { label: \"quux\", lookup: None, snippet: None }]\"#,\n+        );\n     }\n \n     #[test]\n     fn test_completion_if_let_scope() {\n-        check_scope_completion(r\"\n+        check_scope_completion(\n+            r\"\n             fn quux() {\n                 if let Some(x) = foo() {\n                     let y = 92;\n@@ -304,83 +331,106 @@ mod tests {\n                     1 + <|>\n                 }\n             }\n-            \", r#\"[CompletionItem { label: \"b\", lookup: None, snippet: None },\n+            \",\n+            r#\"[CompletionItem { label: \"b\", lookup: None, snippet: None },\n                    CompletionItem { label: \"a\", lookup: None, snippet: None },\n-                   CompletionItem { label: \"quux\", lookup: None, snippet: None }]\"#);\n+                   CompletionItem { label: \"quux\", lookup: None, snippet: None }]\"#,\n+        );\n     }\n \n     #[test]\n     fn test_completion_for_scope() {\n-        check_scope_completion(r\"\n+        check_scope_completion(\n+            r\"\n             fn quux() {\n                 for x in &[1, 2, 3] {\n                     <|>\n                 }\n             }\n-            \", r#\"[CompletionItem { label: \"x\", lookup: None, snippet: None },\n-                   CompletionItem { label: \"quux\", lookup: None, snippet: None }]\"#);\n+            \",\n+            r#\"[CompletionItem { label: \"x\", lookup: None, snippet: None },\n+                   CompletionItem { label: \"quux\", lookup: None, snippet: None }]\"#,\n+        );\n     }\n \n     #[test]\n     fn test_completion_mod_scope() {\n-        check_scope_completion(r\"\n+        check_scope_completion(\n+            r\"\n             struct Foo;\n             enum Baz {}\n             fn quux() {\n                 <|>\n             }\n-            \", r#\"[CompletionItem { label: \"Foo\", lookup: None, snippet: None },\n+            \",\n+            r#\"[CompletionItem { label: \"Foo\", lookup: None, snippet: None },\n                    CompletionItem { label: \"Baz\", lookup: None, snippet: None },\n-                   CompletionItem { label: \"quux\", lookup: None, snippet: None }]\"#);\n+                   CompletionItem { label: \"quux\", lookup: None, snippet: None }]\"#,\n+        );\n     }\n \n     #[test]\n     fn test_completion_mod_scope_no_self_use() {\n-        check_scope_completion(r\"\n+        check_scope_completion(\n+            r\"\n             use foo<|>;\n-            \", r#\"[]\"#);\n+            \",\n+            r#\"[]\"#,\n+        );\n     }\n \n     #[test]\n     fn test_completion_mod_scope_nested() {\n-        check_scope_completion(r\"\n+        check_scope_completion(\n+            r\"\n             struct Foo;\n             mod m {\n                 struct Bar;\n                 fn quux() { <|> }\n             }\n-            \", r#\"[CompletionItem { label: \"Bar\", lookup: None, snippet: None },\n-                   CompletionItem { label: \"quux\", lookup: None, snippet: None }]\"#);\n+            \",\n+            r#\"[CompletionItem { label: \"Bar\", lookup: None, snippet: None },\n+                   CompletionItem { label: \"quux\", lookup: None, snippet: None }]\"#,\n+        );\n     }\n \n     #[test]\n     fn test_complete_type() {\n-        check_scope_completion(r\"\n+        check_scope_completion(\n+            r\"\n             struct Foo;\n             fn x() -> <|>\n-        \", r#\"[CompletionItem { label: \"Foo\", lookup: None, snippet: None },\n-               CompletionItem { label: \"x\", lookup: None, snippet: None }]\"#)\n+        \",\n+            r#\"[CompletionItem { label: \"Foo\", lookup: None, snippet: None },\n+               CompletionItem { label: \"x\", lookup: None, snippet: None }]\"#,\n+        )\n     }\n \n     #[test]\n     fn test_complete_shadowing() {\n-        check_scope_completion(r\"\n+        check_scope_completion(\n+            r\"\n             fn foo() -> {\n                 let bar = 92;\n                 {\n                     let bar = 62;\n                     <|>\n                 }\n             }\n-        \", r#\"[CompletionItem { label: \"bar\", lookup: None, snippet: None },\n-               CompletionItem { label: \"foo\", lookup: None, snippet: None }]\"#)\n+        \",\n+            r#\"[CompletionItem { label: \"bar\", lookup: None, snippet: None },\n+               CompletionItem { label: \"foo\", lookup: None, snippet: None }]\"#,\n+        )\n     }\n \n     #[test]\n     fn test_complete_self() {\n-        check_scope_completion(r\"\n+        check_scope_completion(\n+            r\"\n             impl S { fn foo(&self) { <|> } }\n-        \", r#\"[CompletionItem { label: \"self\", lookup: None, snippet: None }]\"#)\n+        \",\n+            r#\"[CompletionItem { label: \"self\", lookup: None, snippet: None }]\"#,\n+        )\n     }\n \n     #[test]"}, {"sha": "c3149ec541c00fc9f9ac0530f8f0cb6d41184f52", "filename": "crates/ra_editor/src/edit.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_editor%2Fsrc%2Fedit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_editor%2Fsrc%2Fedit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fsrc%2Fedit.rs?ref=61f3a438d3a729a6be941bca1ff4c6a97a33f221", "patch": "@@ -1,8 +1,5 @@\n use crate::{TextRange, TextUnit};\n-use ra_syntax::{\n-    AtomEdit,\n-    text_utils::contains_offset_nonstrict,\n-};\n+use ra_syntax::{text_utils::contains_offset_nonstrict, AtomEdit};\n \n #[derive(Debug, Clone)]\n pub struct Edit {\n@@ -11,7 +8,7 @@ pub struct Edit {\n \n #[derive(Debug)]\n pub struct EditBuilder {\n-    atoms: Vec<AtomEdit>\n+    atoms: Vec<AtomEdit>,\n }\n \n impl EditBuilder {\n@@ -36,7 +33,9 @@ impl EditBuilder {\n         Edit { atoms }\n     }\n     pub fn invalidates_offset(&self, offset: TextUnit) -> bool {\n-        self.atoms.iter().any(|atom| contains_offset_nonstrict(atom.delete, offset))\n+        self.atoms\n+            .iter()\n+            .any(|atom| contains_offset_nonstrict(atom.delete, offset))\n     }\n }\n \n@@ -74,7 +73,7 @@ impl Edit {\n                 break;\n             }\n             if offset < atom.delete.end() {\n-                return None\n+                return None;\n             }\n             res += TextUnit::of_str(&atom.insert);\n             res -= atom.delete.len();"}, {"sha": "9ee1df2810836312f668f091f17878d3fb4829c3", "filename": "crates/ra_editor/src/extend_selection.rs", "status": "modified", "additions": 24, "deletions": 34, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_editor%2Fsrc%2Fextend_selection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_editor%2Fsrc%2Fextend_selection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fsrc%2Fextend_selection.rs?ref=61f3a438d3a729a6be941bca1ff4c6a97a33f221", "patch": "@@ -1,7 +1,8 @@\n use ra_syntax::{\n-    File, TextRange, SyntaxNodeRef, TextUnit, Direction,\n+    algo::{find_covering_node, find_leaf_at_offset, LeafAtOffset},\n+    Direction, File,\n     SyntaxKind::*,\n-    algo::{find_leaf_at_offset, LeafAtOffset, find_covering_node},\n+    SyntaxNodeRef, TextRange, TextUnit,\n };\n \n pub fn extend_selection(file: &File, range: TextRange) -> Option<TextRange> {\n@@ -20,11 +21,11 @@ pub(crate) fn extend(root: SyntaxNodeRef, range: TextRange) -> Option<TextRange>\n             LeafAtOffset::None => return None,\n             LeafAtOffset::Single(l) => {\n                 if l.kind() == COMMENT {\n-                    extend_single_word_in_comment(l, offset).unwrap_or_else(||l.range())\n+                    extend_single_word_in_comment(l, offset).unwrap_or_else(|| l.range())\n                 } else {\n                     l.range()\n                 }\n-            },\n+            }\n             LeafAtOffset::Between(l, r) => pick_best(l, r).range(),\n         };\n         return Some(leaf_range);\n@@ -66,7 +67,7 @@ fn extend_ws(root: SyntaxNodeRef, ws: SyntaxNodeRef, offset: TextUnit) -> TextRa\n         if let Some(node) = ws.next_sibling() {\n             let start = match ws_prefix.rfind('\\n') {\n                 Some(idx) => ws.range().start() + TextUnit::from((idx + 1) as u32),\n-                None => node.range().start()\n+                None => node.range().start(),\n             };\n             let end = if root.text().char_at(node.range().end()) == Some('\\n') {\n                 node.range().end() + TextUnit::of_char('\\n')\n@@ -94,10 +95,7 @@ fn extend_comments(node: SyntaxNodeRef) -> Option<TextRange> {\n     let prev = adj_comments(node, Direction::Prev);\n     let next = adj_comments(node, Direction::Next);\n     if prev != next {\n-        Some(TextRange::from_to(\n-            prev.range().start(),\n-            next.range().end(),\n-        ))\n+        Some(TextRange::from_to(prev.range().start(), next.range().end()))\n     } else {\n         None\n     }\n@@ -109,7 +107,7 @@ fn adj_comments(node: SyntaxNodeRef, dir: Direction) -> SyntaxNodeRef {\n         match node.kind() {\n             COMMENT => res = node,\n             WHITESPACE if !node.leaf_text().unwrap().as_str().contains(\"\\n\\n\") => (),\n-            _ => break\n+            _ => break,\n         }\n     }\n     res\n@@ -125,19 +123,15 @@ mod tests {\n         let file = File::parse(&before);\n         let mut range = TextRange::offset_len(cursor, 0.into());\n         for &after in afters {\n-            range = extend_selection(&file, range)\n-                .unwrap();\n+            range = extend_selection(&file, range).unwrap();\n             let actual = &before[range];\n             assert_eq!(after, actual);\n         }\n     }\n \n     #[test]\n     fn test_extend_selection_arith() {\n-        do_check(\n-            r#\"fn foo() { <|>1 + 1 }\"#,\n-            &[\"1\", \"1 + 1\", \"{ 1 + 1 }\"],\n-        );\n+        do_check(r#\"fn foo() { <|>1 + 1 }\"#, &[\"1\", \"1 + 1\", \"{ 1 + 1 }\"]);\n     }\n \n     #[test]\n@@ -149,7 +143,7 @@ impl S {\n \n     }\n }\"#,\n-            &[\"    fn foo() {\\n\\n    }\\n\"]\n+            &[\"    fn foo() {\\n\\n    }\\n\"],\n         );\n     }\n \n@@ -165,7 +159,11 @@ struct B {\n     <|>\n }\n             \"#,\n-            &[\"\\n    \\n\", \"{\\n    \\n}\", \"/// bla\\n/// bla\\nstruct B {\\n    \\n}\"]\n+            &[\n+                \"\\n    \\n\",\n+                \"{\\n    \\n}\",\n+                \"/// bla\\n/// bla\\nstruct B {\\n    \\n}\",\n+            ],\n         )\n     }\n \n@@ -181,7 +179,7 @@ fn bar(){}\n \n // fn foo(){}\n     \"#,\n-            &[\"// 1 + 1\", \"// fn foo() {\\n// 1 + 1\\n// }\"]\n+            &[\"// 1 + 1\", \"// fn foo() {\\n// 1 + 1\\n// }\"],\n         );\n     }\n \n@@ -191,42 +189,34 @@ fn bar(){}\n             r#\"\n fn main() { foo<|>+bar;}\n     \"#,\n-            &[\"foo\", \"foo+bar\"]\n+            &[\"foo\", \"foo+bar\"],\n         );\n         do_check(\n             r#\"\n fn main() { foo+<|>bar;}\n     \"#,\n-            &[\"bar\", \"foo+bar\"]\n+            &[\"bar\", \"foo+bar\"],\n         );\n     }\n \n     #[test]\n     fn test_extend_selection_prefer_lifetimes() {\n-        do_check(\n-            r#\"fn foo<<|>'a>() {}\"#,\n-            &[\"'a\", \"<'a>\"]\n-        );\n-        do_check(\n-            r#\"fn foo<'a<|>>() {}\"#,\n-            &[\"'a\", \"<'a>\"]\n-        );\n+        do_check(r#\"fn foo<<|>'a>() {}\"#, &[\"'a\", \"<'a>\"]);\n+        do_check(r#\"fn foo<'a<|>>() {}\"#, &[\"'a\", \"<'a>\"]);\n     }\n \n     #[test]\n     fn test_extend_selection_select_first_word() {\n+        do_check(r#\"// foo bar b<|>az quxx\"#, &[\"baz\", \"// foo bar baz quxx\"]);\n         do_check(\n-            r#\"// foo bar b<|>az quxx\"#,\n-            &[\"baz\", \"// foo bar baz quxx\"]\n-        );\n-        do_check(r#\"\n+            r#\"\n impl S {\n     fn foo() {\n         // hel<|>lo world\n     }\n }\n         \"#,\n-            &[\"hello\", \"// hello world\"]\n+            &[\"hello\", \"// hello world\"],\n         );\n     }\n }"}, {"sha": "e5bc0c4ee5cfbc1848aed653336eea24261d9cb7", "filename": "crates/ra_editor/src/folding_ranges.rs", "status": "modified", "additions": 20, "deletions": 16, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_editor%2Fsrc%2Ffolding_ranges.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_editor%2Fsrc%2Ffolding_ranges.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fsrc%2Ffolding_ranges.rs?ref=61f3a438d3a729a6be941bca1ff4c6a97a33f221", "patch": "@@ -1,11 +1,9 @@\n use rustc_hash::FxHashSet;\n \n use ra_syntax::{\n-    ast,\n-    AstNode,\n-    File, TextRange, SyntaxNodeRef,\n+    ast, AstNode, Direction, File,\n     SyntaxKind::{self, *},\n-    Direction,\n+    SyntaxNodeRef, TextRange,\n };\n \n #[derive(Debug, PartialEq, Eq)]\n@@ -28,7 +26,10 @@ pub fn folding_ranges(file: &File) -> Vec<Fold> {\n         // Fold items that span multiple lines\n         if let Some(kind) = fold_kind(node.kind()) {\n             if has_newline(node) {\n-                res.push(Fold { range: node.range(), kind });\n+                res.push(Fold {\n+                    range: node.range(),\n+                    kind,\n+                });\n             }\n         }\n \n@@ -37,8 +38,12 @@ pub fn folding_ranges(file: &File) -> Vec<Fold> {\n             continue;\n         }\n         if node.kind() == COMMENT {\n-            contiguous_range_for_comment(node, &mut visited_comments)\n-                .map(|range| res.push(Fold { range, kind: FoldKind::Comment }));\n+            contiguous_range_for_comment(node, &mut visited_comments).map(|range| {\n+                res.push(Fold {\n+                    range,\n+                    kind: FoldKind::Comment,\n+                })\n+            });\n         }\n     }\n \n@@ -49,13 +54,11 @@ fn fold_kind(kind: SyntaxKind) -> Option<FoldKind> {\n     match kind {\n         COMMENT => Some(FoldKind::Comment),\n         USE_ITEM => Some(FoldKind::Imports),\n-        _ => None\n+        _ => None,\n     }\n }\n \n-fn has_newline(\n-    node: SyntaxNodeRef,\n-) -> bool {\n+fn has_newline(node: SyntaxNodeRef) -> bool {\n     for descendant in node.descendants() {\n         if let Some(ws) = ast::Whitespace::cast(descendant) {\n             if ws.has_newlines() {\n@@ -100,9 +103,7 @@ fn contiguous_range_for_comment<'a>(\n             // The comment group ends because either:\n             // * An element of a different kind was reached\n             // * A comment of a different flavor was reached\n-            _ => {\n-                break\n-            }\n+            _ => break,\n         }\n     }\n \n@@ -128,7 +129,11 @@ mod tests {\n         let folds = folding_ranges(&file);\n \n         assert_eq!(folds.len(), ranges.len());\n-        for ((fold, range), fold_kind) in folds.into_iter().zip(ranges.into_iter()).zip(fold_kinds.into_iter()) {\n+        for ((fold, range), fold_kind) in folds\n+            .into_iter()\n+            .zip(ranges.into_iter())\n+            .zip(fold_kinds.into_iter())\n+        {\n             assert_eq!(fold.range.start(), range.start());\n             assert_eq!(fold.range.end(), range.end());\n             assert_eq!(&fold.kind, fold_kind);\n@@ -181,5 +186,4 @@ fn main() {\n         do_check(text, folds);\n     }\n \n-\n }"}, {"sha": "417080d90bbf20d1425eb068714cfaf85c67b59c", "filename": "crates/ra_editor/src/lib.rs", "status": "modified", "additions": 53, "deletions": 50, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_editor%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_editor%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fsrc%2Flib.rs?ref=61f3a438d3a729a6be941bca1ff4c6a97a33f221", "patch": "@@ -1,44 +1,41 @@\n-extern crate ra_syntax;\n-extern crate superslice;\n extern crate itertools;\n extern crate join_to_string;\n+extern crate ra_syntax;\n extern crate rustc_hash;\n+extern crate superslice;\n #[cfg(test)]\n #[macro_use]\n extern crate test_utils as _test_utils;\n \n-mod extend_selection;\n-mod symbols;\n-mod line_index;\n-mod edit;\n-mod folding_ranges;\n mod code_actions;\n-mod typing;\n mod completion;\n+mod edit;\n+mod extend_selection;\n+mod folding_ranges;\n+mod line_index;\n mod scope;\n+mod symbols;\n #[cfg(test)]\n mod test_utils;\n+mod typing;\n \n+pub use self::{\n+    code_actions::{add_derive, add_impl, flip_comma, introduce_variable, LocalEdit},\n+    completion::{scope_completion, CompletionItem},\n+    edit::{Edit, EditBuilder},\n+    extend_selection::extend_selection,\n+    folding_ranges::{folding_ranges, Fold, FoldKind},\n+    line_index::{LineCol, LineIndex},\n+    symbols::{file_structure, file_symbols, FileSymbol, StructureNode},\n+    typing::{join_lines, on_enter, on_eq_typed},\n+};\n+pub use ra_syntax::AtomEdit;\n use ra_syntax::{\n-    File, TextUnit, TextRange, SmolStr, SyntaxNodeRef,\n-    ast::{self, AstNode, NameOwner},\n     algo::find_leaf_at_offset,\n+    ast::{self, AstNode, NameOwner},\n+    File, SmolStr,\n     SyntaxKind::{self, *},\n-};\n-pub use ra_syntax::AtomEdit;\n-pub use self::{\n-    line_index::{LineIndex, LineCol},\n-    extend_selection::extend_selection,\n-    symbols::{StructureNode, file_structure, FileSymbol, file_symbols},\n-    edit::{EditBuilder, Edit},\n-    code_actions::{\n-        LocalEdit,\n-        flip_comma, add_derive, add_impl,\n-        introduce_variable,\n-    },\n-    typing::{join_lines, on_eq_typed, on_enter},\n-    completion::{scope_completion, CompletionItem},\n-    folding_ranges::{Fold, FoldKind, folding_ranges}\n+    SyntaxNodeRef, TextRange, TextUnit,\n };\n \n #[derive(Debug)]\n@@ -67,10 +64,7 @@ pub enum RunnableKind {\n \n pub fn matching_brace(file: &File, offset: TextUnit) -> Option<TextUnit> {\n     const BRACES: &[SyntaxKind] = &[\n-        L_CURLY, R_CURLY,\n-        L_BRACK, R_BRACK,\n-        L_PAREN, R_PAREN,\n-        L_ANGLE, R_ANGLE,\n+        L_CURLY, R_CURLY, L_BRACK, R_BRACK, L_PAREN, R_PAREN, L_ANGLE, R_ANGLE,\n     ];\n     let (brace_node, brace_idx) = find_leaf_at_offset(file.syntax(), offset)\n         .filter_map(|node| {\n@@ -80,7 +74,8 @@ pub fn matching_brace(file: &File, offset: TextUnit) -> Option<TextUnit> {\n         .next()?;\n     let parent = brace_node.parent()?;\n     let matching_kind = BRACES[brace_idx ^ 1];\n-    let matching_node = parent.children()\n+    let matching_node = parent\n+        .children()\n         .find(|node| node.kind() == matching_kind)?;\n     Some(matching_node.range().start())\n }\n@@ -108,26 +103,30 @@ pub fn highlight(file: &File) -> Vec<HighlightedRange> {\n }\n \n pub fn diagnostics(file: &File) -> Vec<Diagnostic> {\n-    file.errors().into_iter().map(|err| Diagnostic {\n-        range: TextRange::offset_len(err.offset, 1.into()),\n-        msg: \"Syntax Error: \".to_string() + &err.msg,\n-    }).collect()\n+    file.errors()\n+        .into_iter()\n+        .map(|err| Diagnostic {\n+            range: TextRange::offset_len(err.offset, 1.into()),\n+            msg: \"Syntax Error: \".to_string() + &err.msg,\n+        })\n+        .collect()\n }\n \n pub fn syntax_tree(file: &File) -> String {\n     ::ra_syntax::utils::dump_tree(file.syntax())\n }\n \n pub fn runnables(file: &File) -> Vec<Runnable> {\n-    file.syntax().descendants()\n+    file.syntax()\n+        .descendants()\n         .filter_map(ast::FnDef::cast)\n         .filter_map(|f| {\n             let name = f.name()?.text();\n             let kind = if name == \"main\" {\n                 RunnableKind::Bin\n             } else if f.has_atom_attr(\"test\") {\n                 RunnableKind::Test {\n-                    name: name.to_string()\n+                    name: name.to_string(),\n                 }\n             } else {\n                 return None;\n@@ -145,15 +144,18 @@ pub fn find_node_at_offset<'a, N: AstNode<'a>>(\n     offset: TextUnit,\n ) -> Option<N> {\n     let leaves = find_leaf_at_offset(syntax, offset);\n-    let leaf = leaves.clone()\n+    let leaf = leaves\n+        .clone()\n         .find(|leaf| !leaf.kind().is_trivia())\n         .or_else(|| leaves.right_biased())?;\n-    leaf.ancestors()\n-        .filter_map(N::cast)\n-        .next()\n+    leaf.ancestors().filter_map(N::cast).next()\n }\n \n-pub fn resolve_local_name(file: &File, offset: TextUnit, name_ref: ast::NameRef) -> Option<(SmolStr, TextRange)> {\n+pub fn resolve_local_name(\n+    file: &File,\n+    offset: TextUnit,\n+    name_ref: ast::NameRef,\n+) -> Option<(SmolStr, TextRange)> {\n     let fn_def = find_node_at_offset::<ast::FnDef>(file.syntax(), offset)?;\n     let scopes = scope::FnScopes::new(fn_def);\n     let scope_entry = scope::resolve_local_name(name_ref, &scopes)?;\n@@ -164,15 +166,17 @@ pub fn resolve_local_name(file: &File, offset: TextUnit, name_ref: ast::NameRef)\n #[cfg(test)]\n mod tests {\n     use super::*;\n-    use crate::test_utils::{assert_eq_dbg, extract_offset, add_cursor};\n+    use crate::test_utils::{add_cursor, assert_eq_dbg, extract_offset};\n \n     #[test]\n     fn test_highlighting() {\n-        let file = File::parse(r#\"\n+        let file = File::parse(\n+            r#\"\n // comment\n fn main() {}\n     println!(\"Hello, {}!\", 92);\n-\"#);\n+\"#,\n+        );\n         let hls = highlight(&file);\n         assert_eq_dbg(\n             r#\"[HighlightedRange { range: [1; 11), tag: \"comment\" },\n@@ -187,7 +191,8 @@ fn main() {}\n \n     #[test]\n     fn test_runnables() {\n-      let file = File::parse(r#\"\n+        let file = File::parse(\n+            r#\"\n fn main() {}\n \n #[test]\n@@ -196,7 +201,8 @@ fn test_foo() {}\n #[test]\n #[ignore]\n fn test_foo() {}\n-\"#);\n+\"#,\n+        );\n         let runnables = runnables(&file);\n         assert_eq_dbg(\n             r#\"[Runnable { range: [1; 13), kind: Bin },\n@@ -219,9 +225,6 @@ fn test_foo() {}\n             assert_eq_text!(after, &actual);\n         }\n \n-        do_check(\n-            \"struct Foo { a: i32, }<|>\",\n-            \"struct Foo <|>{ a: i32, }\",\n-        );\n+        do_check(\"struct Foo { a: i32, }<|>\", \"struct Foo <|>{ a: i32, }\");\n     }\n }"}, {"sha": "da0f2a7f7944816b0bf8f6a8481605e350723007", "filename": "crates/ra_editor/src/line_index.rs", "status": "modified", "additions": 103, "deletions": 16, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_editor%2Fsrc%2Fline_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_editor%2Fsrc%2Fline_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fsrc%2Fline_index.rs?ref=61f3a438d3a729a6be941bca1ff4c6a97a33f221", "patch": "@@ -1,5 +1,5 @@\n-use superslice::Ext;\n use crate::TextUnit;\n+use superslice::Ext;\n \n #[derive(Clone, Debug, Hash, PartialEq, Eq)]\n pub struct LineIndex {\n@@ -29,7 +29,10 @@ impl LineIndex {\n         let line = self.newlines.upper_bound(&offset) - 1;\n         let line_start_offset = self.newlines[line];\n         let col = offset - line_start_offset;\n-        return LineCol { line: line as u32, col };\n+        return LineCol {\n+            line: line as u32,\n+            col,\n+        };\n     }\n \n     pub fn offset(&self, line_col: LineCol) -> TextUnit {\n@@ -42,21 +45,105 @@ impl LineIndex {\n fn test_line_index() {\n     let text = \"hello\\nworld\";\n     let index = LineIndex::new(text);\n-    assert_eq!(index.line_col(0.into()), LineCol { line: 0, col: 0.into() });\n-    assert_eq!(index.line_col(1.into()), LineCol { line: 0, col: 1.into() });\n-    assert_eq!(index.line_col(5.into()), LineCol { line: 0, col: 5.into() });\n-    assert_eq!(index.line_col(6.into()), LineCol { line: 1, col: 0.into() });\n-    assert_eq!(index.line_col(7.into()), LineCol { line: 1, col: 1.into() });\n-    assert_eq!(index.line_col(8.into()), LineCol { line: 1, col: 2.into() });\n-    assert_eq!(index.line_col(10.into()), LineCol { line: 1, col: 4.into() });\n-    assert_eq!(index.line_col(11.into()), LineCol { line: 1, col: 5.into() });\n-    assert_eq!(index.line_col(12.into()), LineCol { line: 1, col: 6.into() });\n+    assert_eq!(\n+        index.line_col(0.into()),\n+        LineCol {\n+            line: 0,\n+            col: 0.into()\n+        }\n+    );\n+    assert_eq!(\n+        index.line_col(1.into()),\n+        LineCol {\n+            line: 0,\n+            col: 1.into()\n+        }\n+    );\n+    assert_eq!(\n+        index.line_col(5.into()),\n+        LineCol {\n+            line: 0,\n+            col: 5.into()\n+        }\n+    );\n+    assert_eq!(\n+        index.line_col(6.into()),\n+        LineCol {\n+            line: 1,\n+            col: 0.into()\n+        }\n+    );\n+    assert_eq!(\n+        index.line_col(7.into()),\n+        LineCol {\n+            line: 1,\n+            col: 1.into()\n+        }\n+    );\n+    assert_eq!(\n+        index.line_col(8.into()),\n+        LineCol {\n+            line: 1,\n+            col: 2.into()\n+        }\n+    );\n+    assert_eq!(\n+        index.line_col(10.into()),\n+        LineCol {\n+            line: 1,\n+            col: 4.into()\n+        }\n+    );\n+    assert_eq!(\n+        index.line_col(11.into()),\n+        LineCol {\n+            line: 1,\n+            col: 5.into()\n+        }\n+    );\n+    assert_eq!(\n+        index.line_col(12.into()),\n+        LineCol {\n+            line: 1,\n+            col: 6.into()\n+        }\n+    );\n \n     let text = \"\\nhello\\nworld\";\n     let index = LineIndex::new(text);\n-    assert_eq!(index.line_col(0.into()), LineCol { line: 0, col: 0.into() });\n-    assert_eq!(index.line_col(1.into()), LineCol { line: 1, col: 0.into() });\n-    assert_eq!(index.line_col(2.into()), LineCol { line: 1, col: 1.into() });\n-    assert_eq!(index.line_col(6.into()), LineCol { line: 1, col: 5.into() });\n-    assert_eq!(index.line_col(7.into()), LineCol { line: 2, col: 0.into() });\n+    assert_eq!(\n+        index.line_col(0.into()),\n+        LineCol {\n+            line: 0,\n+            col: 0.into()\n+        }\n+    );\n+    assert_eq!(\n+        index.line_col(1.into()),\n+        LineCol {\n+            line: 1,\n+            col: 0.into()\n+        }\n+    );\n+    assert_eq!(\n+        index.line_col(2.into()),\n+        LineCol {\n+            line: 1,\n+            col: 1.into()\n+        }\n+    );\n+    assert_eq!(\n+        index.line_col(6.into()),\n+        LineCol {\n+            line: 1,\n+            col: 5.into()\n+        }\n+    );\n+    assert_eq!(\n+        index.line_col(7.into()),\n+        LineCol {\n+            line: 2,\n+            col: 0.into()\n+        }\n+    );\n }"}, {"sha": "9088e5a608b562125b5ff62b45c1e1c69036f5f7", "filename": "crates/ra_editor/src/scope/fn_scope.rs", "status": "modified", "additions": 95, "deletions": 55, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_editor%2Fsrc%2Fscope%2Ffn_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_editor%2Fsrc%2Fscope%2Ffn_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fsrc%2Fscope%2Ffn_scope.rs?ref=61f3a438d3a729a6be941bca1ff4c6a97a33f221", "patch": "@@ -1,10 +1,11 @@\n use std::fmt;\n+\n use rustc_hash::FxHashMap;\n \n use ra_syntax::{\n-    SyntaxNodeRef, SyntaxNode, SmolStr, AstNode,\n-    ast::{self, NameOwner, LoopBodyOwner, ArgListOwner},\n-    algo::{generate}\n+    algo::generate,\n+    ast::{self, ArgListOwner, LoopBodyOwner, NameOwner},\n+    AstNode, SmolStr, SyntaxNode, SyntaxNodeRef,\n };\n \n type ScopeId = usize;\n@@ -19,11 +20,12 @@ pub struct FnScopes {\n impl FnScopes {\n     pub fn new(fn_def: ast::FnDef) -> FnScopes {\n         let mut scopes = FnScopes {\n-            self_param: fn_def.param_list()\n+            self_param: fn_def\n+                .param_list()\n                 .and_then(|it| it.self_param())\n                 .map(|it| it.syntax().owned()),\n             scopes: Vec::new(),\n-            scope_for: FxHashMap::default()\n+            scope_for: FxHashMap::default(),\n         };\n         let root = scopes.root_scope();\n         scopes.add_params_bindings(root, fn_def.param_list());\n@@ -35,27 +37,38 @@ impl FnScopes {\n     pub fn entries(&self, scope: ScopeId) -> &[ScopeEntry] {\n         &self.scopes[scope].entries\n     }\n-    pub fn scope_chain<'a>(&'a self, node: SyntaxNodeRef) -> impl Iterator<Item=ScopeId> + 'a {\n-        generate(self.scope_for(node), move |&scope| self.scopes[scope].parent)\n+    pub fn scope_chain<'a>(&'a self, node: SyntaxNodeRef) -> impl Iterator<Item = ScopeId> + 'a {\n+        generate(self.scope_for(node), move |&scope| {\n+            self.scopes[scope].parent\n+        })\n     }\n     fn root_scope(&mut self) -> ScopeId {\n         let res = self.scopes.len();\n-        self.scopes.push(ScopeData { parent: None, entries: vec![] });\n+        self.scopes.push(ScopeData {\n+            parent: None,\n+            entries: vec![],\n+        });\n         res\n     }\n     fn new_scope(&mut self, parent: ScopeId) -> ScopeId {\n         let res = self.scopes.len();\n-        self.scopes.push(ScopeData { parent: Some(parent), entries: vec![] });\n+        self.scopes.push(ScopeData {\n+            parent: Some(parent),\n+            entries: vec![],\n+        });\n         res\n     }\n     fn add_bindings(&mut self, scope: ScopeId, pat: ast::Pat) {\n-        let entries = pat.syntax().descendants()\n+        let entries = pat\n+            .syntax()\n+            .descendants()\n             .filter_map(ast::BindPat::cast)\n             .filter_map(ScopeEntry::new);\n         self.scopes[scope].entries.extend(entries);\n     }\n     fn add_params_bindings(&mut self, scope: ScopeId, params: Option<ast::ParamList>) {\n-        params.into_iter()\n+        params\n+            .into_iter()\n             .flat_map(|it| it.params())\n             .filter_map(|it| it.pat())\n             .for_each(|it| self.add_bindings(scope, it));\n@@ -71,34 +84,33 @@ impl FnScopes {\n }\n \n pub struct ScopeEntry {\n-    syntax: SyntaxNode\n+    syntax: SyntaxNode,\n }\n \n impl ScopeEntry {\n     fn new(pat: ast::BindPat) -> Option<ScopeEntry> {\n         if pat.name().is_some() {\n-            Some(ScopeEntry { syntax: pat.syntax().owned() })\n+            Some(ScopeEntry {\n+                syntax: pat.syntax().owned(),\n+            })\n         } else {\n             None\n         }\n     }\n     pub fn name(&self) -> SmolStr {\n-        self.ast().name()\n-            .unwrap()\n-            .text()\n+        self.ast().name().unwrap().text()\n     }\n     pub fn ast(&self) -> ast::BindPat {\n-        ast::BindPat::cast(self.syntax.borrowed())\n-            .unwrap()\n+        ast::BindPat::cast(self.syntax.borrowed()).unwrap()\n     }\n }\n \n impl fmt::Debug for ScopeEntry {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         f.debug_struct(\"ScopeEntry\")\n-         .field(\"name\", &self.name())\n-         .field(\"syntax\", &self.syntax)\n-         .finish()\n+            .field(\"name\", &self.name())\n+            .field(\"syntax\", &self.syntax)\n+            .finish()\n     }\n }\n \n@@ -132,16 +144,16 @@ fn compute_block_scopes(block: ast::Block, scopes: &mut FnScopes, mut scope: Sco\n fn compute_expr_scopes(expr: ast::Expr, scopes: &mut FnScopes, scope: ScopeId) {\n     match expr {\n         ast::Expr::IfExpr(e) => {\n-            let cond_scope = e.condition().and_then(|cond| {\n-                compute_cond_scopes(cond, scopes, scope)\n-            });\n+            let cond_scope = e\n+                .condition()\n+                .and_then(|cond| compute_cond_scopes(cond, scopes, scope));\n             if let Some(block) = e.then_branch() {\n                 compute_block_scopes(block, scopes, cond_scope.unwrap_or(scope));\n             }\n             if let Some(block) = e.else_branch() {\n                 compute_block_scopes(block, scopes, scope);\n             }\n-        },\n+        }\n         ast::Expr::BlockExpr(e) => {\n             if let Some(block) = e.block() {\n                 compute_block_scopes(block, scopes, scope);\n@@ -153,9 +165,9 @@ fn compute_expr_scopes(expr: ast::Expr, scopes: &mut FnScopes, scope: ScopeId) {\n             }\n         }\n         ast::Expr::WhileExpr(e) => {\n-            let cond_scope = e.condition().and_then(|cond| {\n-                compute_cond_scopes(cond, scopes, scope)\n-            });\n+            let cond_scope = e\n+                .condition()\n+                .and_then(|cond| compute_cond_scopes(cond, scopes, scope));\n             if let Some(block) = e.loop_body() {\n                 compute_block_scopes(block, scopes, cond_scope.unwrap_or(scope));\n             }\n@@ -201,25 +213,31 @@ fn compute_expr_scopes(expr: ast::Expr, scopes: &mut FnScopes, scope: ScopeId) {\n                 }\n             }\n         }\n-        _ => {\n-            expr.syntax().children()\n-                .filter_map(ast::Expr::cast)\n-                .for_each(|expr| compute_expr_scopes(expr, scopes, scope))\n-        }\n+        _ => expr\n+            .syntax()\n+            .children()\n+            .filter_map(ast::Expr::cast)\n+            .for_each(|expr| compute_expr_scopes(expr, scopes, scope)),\n     };\n \n     fn compute_call_scopes(\n         receiver: Option<ast::Expr>,\n         arg_list: Option<ast::ArgList>,\n-        scopes: &mut FnScopes, scope: ScopeId,\n+        scopes: &mut FnScopes,\n+        scope: ScopeId,\n     ) {\n-        arg_list.into_iter()\n+        arg_list\n+            .into_iter()\n             .flat_map(|it| it.args())\n             .chain(receiver)\n             .for_each(|expr| compute_expr_scopes(expr, scopes, scope));\n     }\n \n-    fn compute_cond_scopes(cond: ast::Condition, scopes: &mut FnScopes, scope: ScopeId) -> Option<ScopeId> {\n+    fn compute_cond_scopes(\n+        cond: ast::Condition,\n+        scopes: &mut FnScopes,\n+        scope: ScopeId,\n+    ) -> Option<ScopeId> {\n         if let Some(expr) = cond.expr() {\n             compute_expr_scopes(expr, scopes, scope);\n         }\n@@ -236,14 +254,18 @@ fn compute_expr_scopes(expr: ast::Expr, scopes: &mut FnScopes, scope: ScopeId) {\n #[derive(Debug)]\n struct ScopeData {\n     parent: Option<ScopeId>,\n-    entries: Vec<ScopeEntry>\n+    entries: Vec<ScopeEntry>,\n }\n \n-pub fn resolve_local_name<'a>(name_ref: ast::NameRef, scopes: &'a FnScopes) -> Option<&'a ScopeEntry> {\n+pub fn resolve_local_name<'a>(\n+    name_ref: ast::NameRef,\n+    scopes: &'a FnScopes,\n+) -> Option<&'a ScopeEntry> {\n     use rustc_hash::FxHashSet;\n \n     let mut shadowed = FxHashSet::default();\n-    let ret = scopes.scope_chain(name_ref.syntax())\n+    let ret = scopes\n+        .scope_chain(name_ref.syntax())\n         .flat_map(|scope| scopes.entries(scope).iter())\n         .filter(|entry| shadowed.insert(entry.name()))\n         .filter(|entry| entry.name() == name_ref.text())\n@@ -255,8 +277,8 @@ pub fn resolve_local_name<'a>(name_ref: ast::NameRef, scopes: &'a FnScopes) -> O\n #[cfg(test)]\n mod tests {\n     use super::*;\n-    use ra_syntax::File;\n     use crate::{find_node_at_offset, test_utils::extract_offset};\n+    use ra_syntax::File;\n \n     fn do_check(code: &str, expected: &[&str]) {\n         let (off, code) = extract_offset(code);\n@@ -272,7 +294,8 @@ mod tests {\n         let marker: ast::PathExpr = find_node_at_offset(file.syntax(), off).unwrap();\n         let fn_def: ast::FnDef = find_node_at_offset(file.syntax(), off).unwrap();\n         let scopes = FnScopes::new(fn_def);\n-        let actual = scopes.scope_chain(marker.syntax())\n+        let actual = scopes\n+            .scope_chain(marker.syntax())\n             .flat_map(|scope| scopes.entries(scope))\n             .map(|it| it.name())\n             .collect::<Vec<_>>();\n@@ -281,7 +304,8 @@ mod tests {\n \n     #[test]\n     fn test_lambda_scope() {\n-        do_check(r\"\n+        do_check(\n+            r\"\n             fn quux(foo: i32) {\n                 let f = |bar, baz: i32| {\n                     <|>\n@@ -293,7 +317,8 @@ mod tests {\n \n     #[test]\n     fn test_call_scope() {\n-        do_check(r\"\n+        do_check(\n+            r\"\n             fn quux() {\n                 f(|x| <|> );\n             }\",\n@@ -303,7 +328,8 @@ mod tests {\n \n     #[test]\n     fn test_metod_call_scope() {\n-        do_check(r\"\n+        do_check(\n+            r\"\n             fn quux() {\n                 z.f(|x| <|> );\n             }\",\n@@ -313,7 +339,8 @@ mod tests {\n \n     #[test]\n     fn test_loop_scope() {\n-        do_check(r\"\n+        do_check(\n+            r\"\n             fn quux() {\n                 loop {\n                     let x = ();\n@@ -326,7 +353,8 @@ mod tests {\n \n     #[test]\n     fn test_match() {\n-        do_check(r\"\n+        do_check(\n+            r\"\n             fn quux() {\n                 match () {\n                     Some(x) => {\n@@ -340,7 +368,8 @@ mod tests {\n \n     #[test]\n     fn test_shadow_variable() {\n-        do_check(r\"\n+        do_check(\n+            r\"\n             fn foo(x: String) {\n                 let x : &str = &x<|>;\n             }\",\n@@ -356,14 +385,20 @@ mod tests {\n \n         let scopes = FnScopes::new(fn_def);\n \n-        let local_name = resolve_local_name(name_ref, &scopes).unwrap().ast().name().unwrap();\n-        let expected_name = find_node_at_offset::<ast::Name>(file.syntax(), expected_offset.into()).unwrap();\n+        let local_name = resolve_local_name(name_ref, &scopes)\n+            .unwrap()\n+            .ast()\n+            .name()\n+            .unwrap();\n+        let expected_name =\n+            find_node_at_offset::<ast::Name>(file.syntax(), expected_offset.into()).unwrap();\n         assert_eq!(local_name.syntax().range(), expected_name.syntax().range());\n     }\n \n     #[test]\n     fn test_resolve_local_name() {\n-        do_check_local_name(r#\"\n+        do_check_local_name(\n+            r#\"\n             fn foo(x: i32, y: u32) {\n                 {\n                     let z = x * 2;\n@@ -372,25 +407,30 @@ mod tests {\n                     let t = x<|> * 3;\n                 }\n             }\"#,\n-            21);\n+            21,\n+        );\n     }\n \n     #[test]\n     fn test_resolve_local_name_declaration() {\n-        do_check_local_name(r#\"\n+        do_check_local_name(\n+            r#\"\n             fn foo(x: String) {\n                 let x : &str = &x<|>;\n             }\"#,\n-            21);\n+            21,\n+        );\n     }\n \n     #[test]\n     fn test_resolve_local_name_shadow() {\n-        do_check_local_name(r\"\n+        do_check_local_name(\n+            r\"\n         fn foo(x: String) {\n             let x : &str = &x;\n             x<|>\n         }\",\n-        46);\n+            46,\n+        );\n     }\n }"}, {"sha": "cc2d493926c20326d9118dcbe915189c48341b46", "filename": "crates/ra_editor/src/scope/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_editor%2Fsrc%2Fscope%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_editor%2Fsrc%2Fscope%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fsrc%2Fscope%2Fmod.rs?ref=61f3a438d3a729a6be941bca1ff4c6a97a33f221", "patch": "@@ -2,7 +2,6 @@ mod fn_scope;\n mod mod_scope;\n \n pub use self::{\n-    fn_scope::{FnScopes, resolve_local_name},\n+    fn_scope::{resolve_local_name, FnScopes},\n     mod_scope::ModuleScope,\n };\n-"}, {"sha": "8d7e408f851f826ada9e6426267cdd4bf8045799", "filename": "crates/ra_editor/src/scope/mod_scope.rs", "status": "modified", "additions": 25, "deletions": 22, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_editor%2Fsrc%2Fscope%2Fmod_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_editor%2Fsrc%2Fscope%2Fmod_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fsrc%2Fscope%2Fmod_scope.rs?ref=61f3a438d3a729a6be941bca1ff4c6a97a33f221", "patch": "@@ -1,6 +1,6 @@\n use ra_syntax::{\n-    AstNode, SyntaxNode, SyntaxNodeRef, SmolStr,\n     ast::{self, AstChildren},\n+    AstNode, SmolStr, SyntaxNode, SyntaxNodeRef,\n };\n \n pub struct ModuleScope {\n@@ -13,7 +13,8 @@ pub struct Entry {\n }\n \n enum EntryKind {\n-    Item, Import,\n+    Item,\n+    Import,\n }\n \n impl ModuleScope {\n@@ -34,9 +35,8 @@ impl ModuleScope {\n                         collect_imports(tree, &mut entries);\n                     }\n                     continue;\n-                },\n-                ast::ModuleItem::ExternCrateItem(_) |\n-                ast::ModuleItem::ImplItem(_) => continue,\n+                }\n+                ast::ModuleItem::ExternCrateItem(_) | ast::ModuleItem::ImplItem(_) => continue,\n             };\n             entries.extend(entry)\n         }\n@@ -52,20 +52,22 @@ impl ModuleScope {\n impl Entry {\n     fn new<'a>(item: impl ast::NameOwner<'a>) -> Option<Entry> {\n         let name = item.name()?;\n-        Some(Entry { node: name.syntax().owned(), kind: EntryKind::Item })\n+        Some(Entry {\n+            node: name.syntax().owned(),\n+            kind: EntryKind::Item,\n+        })\n     }\n     fn new_import(path: ast::Path) -> Option<Entry> {\n         let name_ref = path.segment()?.name_ref()?;\n-        Some(Entry { node: name_ref.syntax().owned(), kind: EntryKind::Import })\n+        Some(Entry {\n+            node: name_ref.syntax().owned(),\n+            kind: EntryKind::Import,\n+        })\n     }\n     pub fn name(&self) -> SmolStr {\n         match self.kind {\n-            EntryKind::Item =>\n-                ast::Name::cast(self.node.borrowed()).unwrap()\n-                    .text(),\n-            EntryKind::Import =>\n-                ast::NameRef::cast(self.node.borrowed()).unwrap()\n-                    .text(),\n+            EntryKind::Item => ast::Name::cast(self.node.borrowed()).unwrap().text(),\n+            EntryKind::Import => ast::NameRef::cast(self.node.borrowed()).unwrap().text(),\n         }\n     }\n     pub fn syntax(&self) -> SyntaxNodeRef {\n@@ -75,32 +77,31 @@ impl Entry {\n \n fn collect_imports(tree: ast::UseTree, acc: &mut Vec<Entry>) {\n     if let Some(use_tree_list) = tree.use_tree_list() {\n-        return use_tree_list.use_trees().for_each(|it| collect_imports(it, acc));\n+        return use_tree_list\n+            .use_trees()\n+            .for_each(|it| collect_imports(it, acc));\n     }\n     if let Some(path) = tree.path() {\n         acc.extend(Entry::new_import(path));\n     }\n }\n \n-\n #[cfg(test)]\n mod tests {\n     use super::*;\n-    use ra_syntax::{File, ast::ModuleItemOwner};\n+    use ra_syntax::{ast::ModuleItemOwner, File};\n \n     fn do_check(code: &str, expected: &[&str]) {\n         let file = File::parse(&code);\n         let scope = ModuleScope::new(file.ast().items());\n-        let actual = scope.entries\n-            .iter()\n-            .map(|it| it.name())\n-            .collect::<Vec<_>>();\n+        let actual = scope.entries.iter().map(|it| it.name()).collect::<Vec<_>>();\n         assert_eq!(expected, actual.as_slice());\n     }\n \n     #[test]\n     fn test_module_scope() {\n-        do_check(\"\n+        do_check(\n+            \"\n             struct Foo;\n             enum Bar {}\n             mod baz {}\n@@ -110,6 +111,8 @@ mod tests {\n                 t,\n             };\n             type T = ();\n-        \", &[\"Foo\", \"Bar\", \"baz\", \"quux\", \"z\", \"t\", \"T\"])\n+        \",\n+            &[\"Foo\", \"Bar\", \"baz\", \"quux\", \"z\", \"t\", \"T\"],\n+        )\n     }\n }"}, {"sha": "b768b34bc59ef2600e27077622808f094344e8f3", "filename": "crates/ra_editor/src/symbols.rs", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_editor%2Fsrc%2Fsymbols.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_editor%2Fsrc%2Fsymbols.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fsrc%2Fsymbols.rs?ref=61f3a438d3a729a6be941bca1ff4c6a97a33f221", "patch": "@@ -1,12 +1,13 @@\n+use crate::TextRange;\n+\n use ra_syntax::{\n-    SyntaxKind, SyntaxNodeRef, AstNode, File, SmolStr,\n-    ast::{self, NameOwner},\n     algo::{\n         visit::{visitor, Visitor},\n         walk::{walk, WalkEvent},\n     },\n+    ast::{self, NameOwner},\n+    AstNode, File, SmolStr, SyntaxKind, SyntaxNodeRef,\n };\n-use crate::TextRange;\n \n #[derive(Debug, Clone)]\n pub struct StructureNode {\n@@ -25,9 +26,7 @@ pub struct FileSymbol {\n }\n \n pub fn file_symbols(file: &File) -> Vec<FileSymbol> {\n-    file.syntax().descendants()\n-        .filter_map(to_symbol)\n-        .collect()\n+    file.syntax().descendants().filter_map(to_symbol).collect()\n }\n \n fn to_symbol(node: SyntaxNodeRef) -> Option<FileSymbol> {\n@@ -51,23 +50,20 @@ fn to_symbol(node: SyntaxNodeRef) -> Option<FileSymbol> {\n         .accept(node)?\n }\n \n-\n pub fn file_structure(file: &File) -> Vec<StructureNode> {\n     let mut res = Vec::new();\n     let mut stack = Vec::new();\n \n     for event in walk(file.syntax()) {\n         match event {\n-            WalkEvent::Enter(node) => {\n-                match structure_node(node) {\n-                    Some(mut symbol) => {\n-                        symbol.parent = stack.last().map(|&n| n);\n-                        stack.push(res.len());\n-                        res.push(symbol);\n-                    }\n-                    None => (),\n+            WalkEvent::Enter(node) => match structure_node(node) {\n+                Some(mut symbol) => {\n+                    symbol.parent = stack.last().map(|&n| n);\n+                    stack.push(res.len());\n+                    res.push(symbol);\n                 }\n-            }\n+                None => (),\n+            },\n             WalkEvent::Exit(node) => {\n                 if structure_node(node).is_some() {\n                     stack.pop().unwrap();\n@@ -131,7 +127,8 @@ mod tests {\n \n     #[test]\n     fn test_file_structure() {\n-        let file = File::parse(r#\"\n+        let file = File::parse(\n+            r#\"\n struct Foo {\n     x: i32\n }\n@@ -148,7 +145,8 @@ const C: i32 = 92;\n impl E {}\n \n impl fmt::Debug for E {}\n-\"#);\n+\"#,\n+        );\n         let symbols = file_structure(&file);\n         assert_eq_dbg(\n             r#\"[StructureNode { parent: None, label: \"Foo\", navigation_range: [8; 11), node_range: [1; 26), kind: STRUCT_DEF },"}, {"sha": "bc3d700f64d097f9346f18cfcfe738f42c0f1d23", "filename": "crates/ra_editor/src/test_utils.rs", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_editor%2Fsrc%2Ftest_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_editor%2Fsrc%2Ftest_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fsrc%2Ftest_utils.rs?ref=61f3a438d3a729a6be941bca1ff4c6a97a33f221", "patch": "@@ -1,12 +1,8 @@\n-use ra_syntax::{File, TextUnit, TextRange};\n-pub use crate::_test_utils::*;\n use crate::LocalEdit;\n+pub use crate::_test_utils::*;\n+use ra_syntax::{File, TextRange, TextUnit};\n \n-pub fn check_action<F: Fn(&File, TextUnit) -> Option<LocalEdit>> (\n-    before: &str,\n-    after: &str,\n-    f: F,\n-) {\n+pub fn check_action<F: Fn(&File, TextUnit) -> Option<LocalEdit>>(before: &str, after: &str, f: F) {\n     let (before_cursor_pos, before) = extract_offset(before);\n     let file = File::parse(&before);\n     let result = f(&file, before_cursor_pos).expect(\"code action is not applicable\");\n@@ -19,7 +15,7 @@ pub fn check_action<F: Fn(&File, TextUnit) -> Option<LocalEdit>> (\n     assert_eq_text!(after, &actual);\n }\n \n-pub fn check_action_range<F: Fn(&File, TextRange) -> Option<LocalEdit>> (\n+pub fn check_action_range<F: Fn(&File, TextRange) -> Option<LocalEdit>>(\n     before: &str,\n     after: &str,\n     f: F,"}, {"sha": "50b52e7a12792e1ce247dccdd57b261013bc9567", "filename": "crates/ra_editor/src/typing.rs", "status": "modified", "additions": 122, "deletions": 83, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_editor%2Fsrc%2Ftyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_editor%2Fsrc%2Ftyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_editor%2Fsrc%2Ftyping.rs?ref=61f3a438d3a729a6be941bca1ff4c6a97a33f221", "patch": "@@ -1,32 +1,30 @@\n use std::mem;\n \n use ra_syntax::{\n-    TextUnit, TextRange, SyntaxNodeRef, File, AstNode, SyntaxKind,\n+    algo::{find_covering_node, find_leaf_at_offset, LeafAtOffset},\n     ast,\n-    algo::{\n-        find_covering_node, find_leaf_at_offset, LeafAtOffset,\n-    },\n-    text_utils::{intersect, contains_offset_nonstrict},\n+    text_utils::{contains_offset_nonstrict, intersect},\n+    AstNode, File, SyntaxKind,\n     SyntaxKind::*,\n+    SyntaxNodeRef, TextRange, TextUnit,\n };\n \n-use crate::{LocalEdit, EditBuilder, find_node_at_offset};\n+use crate::{find_node_at_offset, EditBuilder, LocalEdit};\n \n pub fn join_lines(file: &File, range: TextRange) -> LocalEdit {\n     let range = if range.is_empty() {\n         let syntax = file.syntax();\n         let text = syntax.text().slice(range.start()..);\n         let pos = match text.find('\\n') {\n-            None => return LocalEdit {\n-                edit: EditBuilder::new().finish(),\n-                cursor_position: None\n-            },\n-            Some(pos) => pos\n+            None => {\n+                return LocalEdit {\n+                    edit: EditBuilder::new().finish(),\n+                    cursor_position: None,\n+                }\n+            }\n+            Some(pos) => pos,\n         };\n-        TextRange::offset_len(\n-            range.start() + pos,\n-            TextUnit::of_char('\\n'),\n-        )\n+        TextRange::offset_len(range.start() + pos, TextUnit::of_char('\\n'))\n     } else {\n         range\n     };\n@@ -58,7 +56,9 @@ pub fn join_lines(file: &File, range: TextRange) -> LocalEdit {\n }\n \n pub fn on_enter(file: &File, offset: TextUnit) -> Option<LocalEdit> {\n-    let comment = find_leaf_at_offset(file.syntax(), offset).left_biased().and_then(|it| ast::Comment::cast(it))?;\n+    let comment = find_leaf_at_offset(file.syntax(), offset)\n+        .left_biased()\n+        .and_then(|it| ast::Comment::cast(it))?;\n \n     if let ast::CommentFlavor::Multiline = comment.flavor() {\n         return None;\n@@ -88,7 +88,7 @@ fn node_indent<'a>(file: &'a File, node: SyntaxNodeRef) -> Option<&'a str> {\n         }\n         LeafAtOffset::Single(n) => {\n             assert!(n == node);\n-            return Some(\"\")\n+            return Some(\"\");\n         }\n         LeafAtOffset::None => unreachable!(),\n     };\n@@ -110,7 +110,12 @@ pub fn on_eq_typed(file: &File, offset: TextUnit) -> Option<LocalEdit> {\n         if contains_offset_nonstrict(expr_range, offset) && offset != expr_range.start() {\n             return None;\n         }\n-        if file.syntax().text().slice(offset..expr_range.start()).contains('\\n') {\n+        if file\n+            .syntax()\n+            .text()\n+            .slice(offset..expr_range.start())\n+            .contains('\\n')\n+        {\n             return None;\n         }\n     } else {\n@@ -125,12 +130,7 @@ pub fn on_eq_typed(file: &File, offset: TextUnit) -> Option<LocalEdit> {\n     })\n }\n \n-fn remove_newline(\n-    edit: &mut EditBuilder,\n-    node: SyntaxNodeRef,\n-    node_text: &str,\n-    offset: TextUnit,\n-) {\n+fn remove_newline(edit: &mut EditBuilder, node: SyntaxNodeRef, node_text: &str, offset: TextUnit) {\n     if node.kind() != WHITESPACE || node_text.bytes().filter(|&b| b == b'\\n').count() != 1 {\n         // The node is either the first or the last in the file\n         let suff = &node_text[TextRange::from_to(\n@@ -156,7 +156,7 @@ fn remove_newline(\n     //\n     // into `my_function(<some-expr>)`\n     if join_single_expr_block(edit, node).is_some() {\n-        return\n+        return;\n     }\n \n     // The node is between two other nodes\n@@ -170,34 +170,28 @@ fn remove_newline(\n         // Adds: a single whitespace\n         edit.replace(\n             TextRange::from_to(prev.range().start(), node.range().end()),\n-            \" \".to_string()\n+            \" \".to_string(),\n         );\n     } else if let (Some(_), Some(next)) = (ast::Comment::cast(prev), ast::Comment::cast(next)) {\n         // Removes: newline (incl. surrounding whitespace), start of the next comment\n         edit.delete(TextRange::from_to(\n             node.range().start(),\n-            next.syntax().range().start() + TextUnit::of_str(next.prefix())\n+            next.syntax().range().start() + TextUnit::of_str(next.prefix()),\n         ));\n     } else {\n         // Remove newline but add a computed amount of whitespace characters\n-        edit.replace(\n-            node.range(),\n-            compute_ws(prev, next).to_string(),\n-        );\n+        edit.replace(node.range(), compute_ws(prev, next).to_string());\n     }\n }\n \n fn is_trailing_comma(left: SyntaxKind, right: SyntaxKind) -> bool {\n     match (left, right) {\n-       (COMMA, R_PAREN) | (COMMA, R_BRACK) => true,\n-       _ => false\n+        (COMMA, R_PAREN) | (COMMA, R_BRACK) => true,\n+        _ => false,\n     }\n }\n \n-fn join_single_expr_block(\n-    edit: &mut EditBuilder,\n-    node: SyntaxNodeRef,\n-) -> Option<()> {\n+fn join_single_expr_block(edit: &mut EditBuilder, node: SyntaxNodeRef) -> Option<()> {\n     let block = ast::Block::cast(node.parent()?)?;\n     let block_expr = ast::BlockExpr::cast(block.syntax().parent()?)?;\n     let expr = single_expr(block)?;\n@@ -244,7 +238,7 @@ fn compute_ws(left: SyntaxNodeRef, right: SyntaxNodeRef) -> &'static str {\n #[cfg(test)]\n mod tests {\n     use super::*;\n-    use crate::test_utils::{check_action, extract_range, extract_offset, add_cursor};\n+    use crate::test_utils::{add_cursor, check_action, extract_offset, extract_range};\n \n     fn check_join_lines(before: &str, after: &str) {\n         check_action(before, after, |file, offset| {\n@@ -256,118 +250,142 @@ mod tests {\n \n     #[test]\n     fn test_join_lines_comma() {\n-        check_join_lines(r\"\n+        check_join_lines(\n+            r\"\n fn foo() {\n     <|>foo(1,\n     )\n }\n-\", r\"\n+\",\n+            r\"\n fn foo() {\n     <|>foo(1)\n }\n-\");\n+\",\n+        );\n     }\n \n     #[test]\n     fn test_join_lines_lambda_block() {\n-        check_join_lines(r\"\n+        check_join_lines(\n+            r\"\n pub fn reparse(&self, edit: &AtomEdit) -> File {\n     <|>self.incremental_reparse(edit).unwrap_or_else(|| {\n         self.full_reparse(edit)\n     })\n }\n-\", r\"\n+\",\n+            r\"\n pub fn reparse(&self, edit: &AtomEdit) -> File {\n     <|>self.incremental_reparse(edit).unwrap_or_else(|| self.full_reparse(edit))\n }\n-\");\n+\",\n+        );\n     }\n \n     #[test]\n     fn test_join_lines_block() {\n-        check_join_lines(r\"\n+        check_join_lines(\n+            r\"\n fn foo() {\n     foo(<|>{\n         92\n     })\n-}\", r\"\n+}\",\n+            r\"\n fn foo() {\n     foo(<|>92)\n-}\");\n+}\",\n+        );\n     }\n \n     #[test]\n     fn test_join_lines_normal_comments() {\n-        check_join_lines(r\"\n+        check_join_lines(\n+            r\"\n fn foo() {\n     // Hello<|>\n     // world!\n }\n-\", r\"\n+\",\n+            r\"\n fn foo() {\n     // Hello<|> world!\n }\n-\");\n+\",\n+        );\n     }\n \n     #[test]\n     fn test_join_lines_doc_comments() {\n-        check_join_lines(r\"\n+        check_join_lines(\n+            r\"\n fn foo() {\n     /// Hello<|>\n     /// world!\n }\n-\", r\"\n+\",\n+            r\"\n fn foo() {\n     /// Hello<|> world!\n }\n-\");\n+\",\n+        );\n     }\n \n     #[test]\n     fn test_join_lines_mod_comments() {\n-        check_join_lines(r\"\n+        check_join_lines(\n+            r\"\n fn foo() {\n     //! Hello<|>\n     //! world!\n }\n-\", r\"\n+\",\n+            r\"\n fn foo() {\n     //! Hello<|> world!\n }\n-\");\n+\",\n+        );\n     }\n \n     #[test]\n     fn test_join_lines_multiline_comments_1() {\n-        check_join_lines(r\"\n+        check_join_lines(\n+            r\"\n fn foo() {\n     // Hello<|>\n     /* world! */\n }\n-\", r\"\n+\",\n+            r\"\n fn foo() {\n     // Hello<|> world! */\n }\n-\");\n+\",\n+        );\n     }\n \n     #[test]\n     fn test_join_lines_multiline_comments_2() {\n-        check_join_lines(r\"\n+        check_join_lines(\n+            r\"\n fn foo() {\n     // The<|>\n     /* quick\n     brown\n     fox! */\n }\n-\", r\"\n+\",\n+            r\"\n fn foo() {\n     // The<|> quick\n     brown\n     fox! */\n }\n-\");\n+\",\n+        );\n     }\n \n     fn check_join_lines_sel(before: &str, after: &str) {\n@@ -380,59 +398,71 @@ fn foo() {\n \n     #[test]\n     fn test_join_lines_selection_fn_args() {\n-        check_join_lines_sel(r\"\n+        check_join_lines_sel(\n+            r\"\n fn foo() {\n     <|>foo(1,\n         2,\n         3,\n     <|>)\n }\n-    \", r\"\n+    \",\n+            r\"\n fn foo() {\n     foo(1, 2, 3)\n }\n-    \");\n+    \",\n+        );\n     }\n \n     #[test]\n     fn test_join_lines_selection_struct() {\n-        check_join_lines_sel(r\"\n+        check_join_lines_sel(\n+            r\"\n struct Foo <|>{\n     f: u32,\n }<|>\n-    \", r\"\n+    \",\n+            r\"\n struct Foo { f: u32 }\n-    \");\n+    \",\n+        );\n     }\n \n     #[test]\n     fn test_join_lines_selection_dot_chain() {\n-        check_join_lines_sel(r\"\n+        check_join_lines_sel(\n+            r\"\n fn foo() {\n     join(<|>type_params.type_params()\n             .filter_map(|it| it.name())\n             .map(|it| it.text())<|>)\n-}\", r\"\n+}\",\n+            r\"\n fn foo() {\n     join(type_params.type_params().filter_map(|it| it.name()).map(|it| it.text()))\n-}\");\n+}\",\n+        );\n     }\n \n     #[test]\n     fn test_join_lines_selection_lambda_block_body() {\n-        check_join_lines_sel(r\"\n+        check_join_lines_sel(\n+            r\"\n pub fn handle_find_matching_brace() {\n     params.offsets\n         .map(|offset| <|>{\n             world.analysis().matching_brace(&file, offset).unwrap_or(offset)\n         }<|>)\n         .collect();\n-}\", r\"\n+}\",\n+            r\"\n pub fn handle_find_matching_brace() {\n     params.offsets\n         .map(|offset| world.analysis().matching_brace(&file, offset).unwrap_or(offset))\n         .collect();\n-}\");\n+}\",\n+        );\n     }\n \n     #[test]\n@@ -454,15 +484,18 @@ pub fn handle_find_matching_brace() {\n         //     let foo =;\n         // }\n         // \");\n-        do_check(r\"\n+        do_check(\n+            r\"\n fn foo() {\n     let foo =<|> 1 + 1\n }\n-\", r\"\n+\",\n+            r\"\n fn foo() {\n     let foo = 1 + 1;\n }\n-\");\n+\",\n+        );\n         //     do_check(r\"\n         // fn foo() {\n         //     let foo =<|>\n@@ -496,28 +529,34 @@ fn foo() {\n             assert!(apply_on_enter(text).is_none())\n         }\n \n-        do_check(r\"\n+        do_check(\n+            r\"\n /// Some docs<|>\n fn foo() {\n }\n-\", r\"\n+\",\n+            r\"\n /// Some docs\n /// <|>\n fn foo() {\n }\n-\");\n-        do_check(r\"\n+\",\n+        );\n+        do_check(\n+            r\"\n impl S {\n     /// Some<|> docs.\n     fn foo() {}\n }\n-\", r\"\n+\",\n+            r\"\n impl S {\n     /// Some\n     /// <|> docs.\n     fn foo() {}\n }\n-\");\n+\",\n+        );\n         do_check_noop(r\"<|>//! docz\");\n     }\n }"}, {"sha": "1dd4957911ddf891f17e0487322a119b5e1a1fad", "filename": "crates/ra_lsp_server/src/caps.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_lsp_server%2Fsrc%2Fcaps.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_lsp_server%2Fsrc%2Fcaps.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fcaps.rs?ref=61f3a438d3a729a6be941bca1ff4c6a97a33f221", "patch": "@@ -1,14 +1,8 @@\n use languageserver_types::{\n-    ServerCapabilities,\n-    CodeActionProviderCapability,\n-    FoldingRangeProviderCapability,\n-    TextDocumentSyncCapability,\n+    CodeActionProviderCapability, CompletionOptions, DocumentOnTypeFormattingOptions,\n+    ExecuteCommandOptions, FoldingRangeProviderCapability, ServerCapabilities,\n+    SignatureHelpOptions, TextDocumentSyncCapability, TextDocumentSyncKind,\n     TextDocumentSyncOptions,\n-    TextDocumentSyncKind,\n-    ExecuteCommandOptions,\n-    CompletionOptions,\n-    SignatureHelpOptions,\n-    DocumentOnTypeFormattingOptions,\n };\n \n pub fn server_capabilities() -> ServerCapabilities {\n@@ -20,15 +14,15 @@ pub fn server_capabilities() -> ServerCapabilities {\n                 will_save: None,\n                 will_save_wait_until: None,\n                 save: None,\n-            }\n+            },\n         )),\n         hover_provider: None,\n         completion_provider: Some(CompletionOptions {\n             resolve_provider: None,\n             trigger_characters: None,\n         }),\n         signature_help_provider: Some(SignatureHelpOptions {\n-            trigger_characters: Some(vec![\"(\".to_string(), \",\".to_string()])\n+            trigger_characters: Some(vec![\"(\".to_string(), \",\".to_string()]),\n         }),\n         definition_provider: Some(true),\n         type_definition_provider: None,"}, {"sha": "8325e8c1e24d8fe851b6e7f9ed62b0677d10cded", "filename": "crates/ra_lsp_server/src/conv.rs", "status": "modified", "additions": 31, "deletions": 35, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_lsp_server%2Fsrc%2Fconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_lsp_server%2Fsrc%2Fconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fconv.rs?ref=61f3a438d3a729a6be941bca1ff4c6a97a33f221", "patch": "@@ -1,17 +1,12 @@\n use languageserver_types::{\n-    Range, SymbolKind, Position, TextEdit, Location, Url,\n-    TextDocumentIdentifier, VersionedTextDocumentIdentifier, TextDocumentItem,\n-    TextDocumentPositionParams, TextDocumentEdit,\n-};\n-use ra_editor::{LineIndex, LineCol, Edit, AtomEdit};\n-use ra_syntax::{SyntaxKind, TextUnit, TextRange};\n-use ra_analysis::{FileId, SourceChange, SourceFileEdit, FileSystemEdit};\n-\n-use crate::{\n-    Result,\n-    server_world::ServerWorld,\n-    req,\n+    Location, Position, Range, SymbolKind, TextDocumentEdit, TextDocumentIdentifier,\n+    TextDocumentItem, TextDocumentPositionParams, TextEdit, Url, VersionedTextDocumentIdentifier,\n };\n+use ra_analysis::{FileId, FileSystemEdit, SourceChange, SourceFileEdit};\n+use ra_editor::{AtomEdit, Edit, LineCol, LineIndex};\n+use ra_syntax::{SyntaxKind, TextRange, TextUnit};\n+\n+use crate::{req, server_world::ServerWorld, Result};\n \n pub trait Conv {\n     type Output;\n@@ -190,8 +185,12 @@ impl TryConvWith for SourceChange {\n             None => None,\n             Some(pos) => {\n                 let line_index = world.analysis().file_line_index(pos.file_id);\n-                let edits = self.source_file_edits.iter().find(|it| it.file_id == pos.file_id)\n-                    .map(|it| it.edits.as_slice()).unwrap_or(&[]);\n+                let edits = self\n+                    .source_file_edits\n+                    .iter()\n+                    .find(|it| it.file_id == pos.file_id)\n+                    .map(|it| it.edits.as_slice())\n+                    .unwrap_or(&[]);\n                 let line_col = translate_offset_with_edit(&*line_index, pos.offset, edits);\n                 let position = Position::new(line_col.line as u64, u32::from(line_col.col) as u64);\n                 Some(TextDocumentPositionParams {\n@@ -224,11 +223,11 @@ fn translate_offset_with_edit(\n     let fallback = pre_edit_index.line_col(offset);\n     let edit = match edits.first() {\n         None => return fallback,\n-        Some(edit) => edit\n+        Some(edit) => edit,\n     };\n     let end_offset = edit.delete.start() + TextUnit::of_str(&edit.insert);\n     if !(edit.delete.start() <= offset && offset <= end_offset) {\n-        return fallback\n+        return fallback;\n     }\n     let rel_offset = offset - edit.delete.start();\n     let in_edit_line_col = LineIndex::new(&edit.insert).line_col(rel_offset);\n@@ -255,11 +254,11 @@ impl TryConvWith for SourceFileEdit {\n             version: None,\n         };\n         let line_index = world.analysis().file_line_index(self.file_id);\n-        let edits = self.edits\n-            .into_iter()\n-            .map_conv_with(&line_index)\n-            .collect();\n-        Ok(TextDocumentEdit { text_document, edits })\n+        let edits = self.edits.into_iter().map_conv_with(&line_index).collect();\n+        Ok(TextDocumentEdit {\n+            text_document,\n+            edits,\n+        })\n     }\n }\n \n@@ -273,13 +272,13 @@ impl TryConvWith for FileSystemEdit {\n                 let path = &path.as_str()[3..]; // strip `../` b/c url is weird\n                 let uri = uri.join(path)?;\n                 req::FileSystemEdit::CreateFile { uri }\n-            },\n+            }\n             FileSystemEdit::MoveFile { file, path } => {\n                 let src = world.file_id_to_uri(file)?;\n                 let path = &path.as_str()[3..]; // strip `../` b/c url is weird\n                 let dst = src.join(path)?;\n                 req::FileSystemEdit::MoveFile { src, dst }\n-            },\n+            }\n         };\n         Ok(res)\n     }\n@@ -291,12 +290,9 @@ pub fn to_location(\n     world: &ServerWorld,\n     line_index: &LineIndex,\n ) -> Result<Location> {\n-        let url = file_id.try_conv_with(world)?;\n-        let loc = Location::new(\n-            url,\n-            range.conv_with(line_index),\n-        );\n-        Ok(loc)\n+    let url = file_id.try_conv_with(world)?;\n+    let loc = Location::new(url, range.conv_with(line_index));\n+    Ok(loc)\n }\n \n pub trait MapConvWith<'a>: Sized + 'a {\n@@ -309,8 +305,9 @@ pub trait MapConvWith<'a>: Sized + 'a {\n }\n \n impl<'a, I> MapConvWith<'a> for I\n-    where I: Iterator + 'a,\n-          I::Item: ConvWith\n+where\n+    I: Iterator + 'a,\n+    I::Item: ConvWith,\n {\n     type Ctx = <I::Item as ConvWith>::Ctx;\n     type Output = <I::Item as ConvWith>::Output;\n@@ -322,14 +319,13 @@ pub struct ConvWithIter<'a, I, Ctx: 'a> {\n }\n \n impl<'a, I, Ctx> Iterator for ConvWithIter<'a, I, Ctx>\n-    where\n-        I: Iterator,\n-        I::Item: ConvWith<Ctx=Ctx>,\n+where\n+    I: Iterator,\n+    I::Item: ConvWith<Ctx = Ctx>,\n {\n     type Item = <I::Item as ConvWith>::Output;\n \n     fn next(&mut self) -> Option<Self::Item> {\n         self.iter.next().map(|item| item.conv_with(self.ctx))\n     }\n }\n-"}, {"sha": "f1b17f2825d077297c8a780e9dfcb9a6d7a08154", "filename": "crates/ra_lsp_server/src/lib.rs", "status": "modified", "additions": 9, "deletions": 12, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_lsp_server%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_lsp_server%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Flib.rs?ref=61f3a438d3a729a6be941bca1ff4c6a97a33f221", "patch": "@@ -2,39 +2,36 @@\n extern crate failure;\n #[macro_use]\n extern crate serde_derive;\n+extern crate languageserver_types;\n extern crate serde;\n extern crate serde_json;\n-extern crate languageserver_types;\n #[macro_use]\n extern crate crossbeam_channel;\n extern crate rayon;\n #[macro_use]\n extern crate log;\n+extern crate cargo_metadata;\n extern crate drop_bomb;\n-extern crate url_serde;\n-extern crate walkdir;\n extern crate im;\n extern crate relative_path;\n-extern crate cargo_metadata;\n extern crate rustc_hash;\n+extern crate url_serde;\n+extern crate walkdir;\n \n extern crate gen_lsp_server;\n-extern crate ra_editor;\n extern crate ra_analysis;\n+extern crate ra_editor;\n extern crate ra_syntax;\n \n mod caps;\n-pub mod req;\n mod conv;\n mod main_loop;\n-mod vfs;\n mod path_map;\n-mod server_world;\n mod project_model;\n+pub mod req;\n+mod server_world;\n pub mod thread_watcher;\n+mod vfs;\n \n pub type Result<T> = ::std::result::Result<T, ::failure::Error>;\n-pub use crate::{\n-    main_loop::main_loop,\n-    caps::server_capabilities,\n-};\n+pub use crate::{caps::server_capabilities, main_loop::main_loop};"}, {"sha": "9f62347f1298ed2ca70db033c5129712cccced92", "filename": "crates/ra_lsp_server/src/main.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_lsp_server%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_lsp_server%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fmain.rs?ref=61f3a438d3a729a6be941bca1ff4c6a97a33f221", "patch": "@@ -6,7 +6,7 @@ extern crate flexi_logger;\n extern crate gen_lsp_server;\n extern crate ra_lsp_server;\n \n-use flexi_logger::{Logger, Duplicate};\n+use flexi_logger::{Duplicate, Logger};\n use gen_lsp_server::{run_server, stdio_transport};\n use ra_lsp_server::Result;\n \n@@ -38,7 +38,8 @@ fn main_inner() -> Result<()> {\n         receiver,\n         sender,\n         |params, r, s| {\n-            let root = params.root_uri\n+            let root = params\n+                .root_uri\n                 .and_then(|it| it.to_file_path().ok())\n                 .unwrap_or(cwd);\n             ra_lsp_server::main_loop(false, root, r, s)\n@@ -49,4 +50,3 @@ fn main_inner() -> Result<()> {\n     info!(\"... IO is down\");\n     Ok(())\n }\n-"}, {"sha": "c25b6385202977e5a74e049ed82dd8731dbe9e11", "filename": "crates/ra_lsp_server/src/main_loop/handlers.rs", "status": "modified", "additions": 114, "deletions": 92, "changes": 206, "blob_url": "https://github.com/rust-lang/rust/blob/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs?ref=61f3a438d3a729a6be941bca1ff4c6a97a33f221", "patch": "@@ -1,23 +1,20 @@\n use rustc_hash::FxHashMap;\n \n use languageserver_types::{\n-    Diagnostic, DiagnosticSeverity, DocumentSymbol,\n-    CodeActionResponse, Command, TextDocumentIdentifier,\n-    SymbolInformation, Position, Location, TextEdit,\n-    CompletionItem, InsertTextFormat, CompletionItemKind,\n-    FoldingRange, FoldingRangeParams, FoldingRangeKind\n+    CodeActionResponse, Command, CompletionItem, CompletionItemKind, Diagnostic,\n+    DiagnosticSeverity, DocumentSymbol, FoldingRange, FoldingRangeKind, FoldingRangeParams,\n+    InsertTextFormat, Location, Position, SymbolInformation, TextDocumentIdentifier, TextEdit,\n };\n+use ra_analysis::{FileId, FoldKind, JobToken, Query, RunnableKind};\n+use ra_syntax::text_utils::contains_offset_nonstrict;\n use serde_json::to_value;\n-use ra_analysis::{Query, FileId, RunnableKind, JobToken, FoldKind};\n-use ra_syntax::{\n-    text_utils::contains_offset_nonstrict\n-};\n \n use crate::{\n-    req::{self, Decoration}, Result,\n-    conv::{Conv, ConvWith, TryConvWith, MapConvWith, to_location},\n-    server_world::ServerWorld,\n+    conv::{to_location, Conv, ConvWith, MapConvWith, TryConvWith},\n     project_model::TargetKind,\n+    req::{self, Decoration},\n+    server_world::ServerWorld,\n+    Result,\n };\n \n pub fn handle_syntax_tree(\n@@ -38,7 +35,9 @@ pub fn handle_extend_selection(\n     let file_id = params.text_document.try_conv_with(&world)?;\n     let file = world.analysis().file_syntax(file_id);\n     let line_index = world.analysis().file_line_index(file_id);\n-    let selections = params.selections.into_iter()\n+    let selections = params\n+        .selections\n+        .into_iter()\n         .map_conv_with(&line_index)\n         .map(|r| world.analysis().extend_selection(&file, r))\n         .map_conv_with(&line_index)\n@@ -54,11 +53,15 @@ pub fn handle_find_matching_brace(\n     let file_id = params.text_document.try_conv_with(&world)?;\n     let file = world.analysis().file_syntax(file_id);\n     let line_index = world.analysis().file_line_index(file_id);\n-    let res = params.offsets\n+    let res = params\n+        .offsets\n         .into_iter()\n         .map_conv_with(&line_index)\n         .map(|offset| {\n-            world.analysis().matching_brace(&file, offset).unwrap_or(offset)\n+            world\n+                .analysis()\n+                .matching_brace(&file, offset)\n+                .unwrap_or(offset)\n         })\n         .map_conv_with(&line_index)\n         .collect();\n@@ -73,7 +76,9 @@ pub fn handle_join_lines(\n     let file_id = params.text_document.try_conv_with(&world)?;\n     let line_index = world.analysis().file_line_index(file_id);\n     let range = params.range.conv_with(&line_index);\n-    world.analysis().join_lines(file_id, range)\n+    world\n+        .analysis()\n+        .join_lines(file_id, range)\n         .try_conv_with(&world)\n }\n \n@@ -87,7 +92,7 @@ pub fn handle_on_enter(\n     let offset = params.position.conv_with(&line_index);\n     match world.analysis().on_enter(file_id, offset) {\n         None => Ok(None),\n-        Some(edit) => Ok(Some(edit.try_conv_with(&world)?))\n+        Some(edit) => Ok(Some(edit.try_conv_with(&world)?)),\n     }\n }\n \n@@ -158,7 +163,9 @@ pub fn handle_workspace_symbol(\n     let all_symbols = params.query.contains(\"#\");\n     let libs = params.query.contains(\"*\");\n     let query = {\n-        let query: String = params.query.chars()\n+        let query: String = params\n+            .query\n+            .chars()\n             .filter(|&c| c != '#' && c != '*')\n             .collect();\n         let mut q = Query::new(query);\n@@ -180,22 +187,23 @@ pub fn handle_workspace_symbol(\n \n     return Ok(Some(res));\n \n-    fn exec_query(world: &ServerWorld, query: Query, token: &JobToken) -> Result<Vec<SymbolInformation>> {\n+    fn exec_query(\n+        world: &ServerWorld,\n+        query: Query,\n+        token: &JobToken,\n+    ) -> Result<Vec<SymbolInformation>> {\n         let mut res = Vec::new();\n         for (file_id, symbol) in world.analysis().symbol_search(query, token) {\n             let line_index = world.analysis().file_line_index(file_id);\n             let info = SymbolInformation {\n                 name: symbol.name.to_string(),\n                 kind: symbol.kind.conv(),\n-                location: to_location(\n-                    file_id, symbol.node_range,\n-                    world, &line_index\n-                )?,\n+                location: to_location(file_id, symbol.node_range, world, &line_index)?,\n                 container_name: None,\n                 deprecated: None,\n             };\n             res.push(info);\n-        };\n+        }\n         Ok(res)\n     }\n }\n@@ -209,12 +217,12 @@ pub fn handle_goto_definition(\n     let line_index = world.analysis().file_line_index(file_id);\n     let offset = params.position.conv_with(&line_index);\n     let mut res = Vec::new();\n-    for (file_id, symbol) in world.analysis().approximately_resolve_symbol(file_id, offset, &token) {\n+    for (file_id, symbol) in world\n+        .analysis()\n+        .approximately_resolve_symbol(file_id, offset, &token)\n+    {\n         let line_index = world.analysis().file_line_index(file_id);\n-        let location = to_location(\n-            file_id, symbol.node_range,\n-            &world, &line_index,\n-        )?;\n+        let location = to_location(file_id, symbol.node_range, &world, &line_index)?;\n         res.push(location)\n     }\n     Ok(Some(req::GotoDefinitionResponse::Array(res)))\n@@ -229,10 +237,7 @@ pub fn handle_parent_module(\n     let mut res = Vec::new();\n     for (file_id, symbol) in world.analysis().parent_module(file_id) {\n         let line_index = world.analysis().file_line_index(file_id);\n-        let location = to_location(\n-            file_id, symbol.node_range,\n-            &world, &line_index\n-        )?;\n+        let location = to_location(file_id, symbol.node_range, &world, &line_index)?;\n         res.push(location);\n     }\n     Ok(res)\n@@ -259,21 +264,16 @@ pub fn handle_runnables(\n         let r = req::Runnable {\n             range: runnable.range.conv_with(&line_index),\n             label: match &runnable.kind {\n-                RunnableKind::Test { name } =>\n-                    format!(\"test {}\", name),\n-                RunnableKind::Bin =>\n-                    \"run binary\".to_string(),\n+                RunnableKind::Test { name } => format!(\"test {}\", name),\n+                RunnableKind::Bin => \"run binary\".to_string(),\n             },\n             bin: \"cargo\".to_string(),\n             args,\n             env: {\n                 let mut m = FxHashMap::default();\n-                m.insert(\n-                    \"RUST_BACKTRACE\".to_string(),\n-                    \"short\".to_string(),\n-                );\n+                m.insert(\"RUST_BACKTRACE\".to_string(), \"short\".to_string());\n                 m\n-            }\n+            },\n         };\n         res.push(r);\n     }\n@@ -283,33 +283,39 @@ pub fn handle_runnables(\n         let spec = if let Some(&crate_id) = world.analysis().crate_for(file_id).first() {\n             let file_id = world.analysis().crate_root(crate_id);\n             let path = world.path_map.get_path(file_id);\n-            world.workspaces.iter()\n+            world\n+                .workspaces\n+                .iter()\n                 .filter_map(|ws| {\n                     let tgt = ws.target_by_root(path)?;\n-                    Some((tgt.package(ws).name(ws).clone(), tgt.name(ws).clone(), tgt.kind(ws)))\n+                    Some((\n+                        tgt.package(ws).name(ws).clone(),\n+                        tgt.name(ws).clone(),\n+                        tgt.kind(ws),\n+                    ))\n                 })\n                 .next()\n         } else {\n             None\n         };\n         let mut res = Vec::new();\n         match kind {\n-                RunnableKind::Test { name } => {\n-                    res.push(\"test\".to_string());\n-                    if let Some((pkg_name, tgt_name, tgt_kind)) = spec {\n-                        spec_args(pkg_name, tgt_name, tgt_kind, &mut res);\n-                    }\n-                    res.push(\"--\".to_string());\n-                    res.push(name.to_string());\n-                    res.push(\"--nocapture\".to_string());\n+            RunnableKind::Test { name } => {\n+                res.push(\"test\".to_string());\n+                if let Some((pkg_name, tgt_name, tgt_kind)) = spec {\n+                    spec_args(pkg_name, tgt_name, tgt_kind, &mut res);\n                 }\n-                RunnableKind::Bin => {\n-                    res.push(\"run\".to_string());\n-                    if let Some((pkg_name, tgt_name, tgt_kind)) = spec {\n-                        spec_args(pkg_name, tgt_name, tgt_kind, &mut res);\n-                    }\n+                res.push(\"--\".to_string());\n+                res.push(name.to_string());\n+                res.push(\"--nocapture\".to_string());\n+            }\n+            RunnableKind::Bin => {\n+                res.push(\"run\".to_string());\n+                if let Some((pkg_name, tgt_name, tgt_kind)) = spec {\n+                    spec_args(pkg_name, tgt_name, tgt_kind, &mut res);\n                 }\n             }\n+        }\n         res\n     }\n \n@@ -362,12 +368,13 @@ pub fn handle_completion(\n         None => return Ok(None),\n         Some(items) => items,\n     };\n-    let items = items.into_iter()\n+    let items = items\n+        .into_iter()\n         .map(|item| {\n             let mut res = CompletionItem {\n                 label: item.label,\n                 filter_text: item.lookup,\n-                .. Default::default()\n+                ..Default::default()\n             };\n             if let Some(snip) = item.snippet {\n                 res.insert_text = Some(snip);\n@@ -389,24 +396,27 @@ pub fn handle_folding_range(\n     let file_id = params.text_document.try_conv_with(&world)?;\n     let line_index = world.analysis().file_line_index(file_id);\n \n-    let res = Some(world.analysis()\n-        .folding_ranges(file_id)\n-        .into_iter()\n-        .map(|fold| {\n-            let kind = match fold.kind {\n-                FoldKind::Comment => FoldingRangeKind::Comment,\n-                FoldKind::Imports => FoldingRangeKind::Imports\n-            };\n-            let range = fold.range.conv_with(&line_index);\n-            FoldingRange {\n-                start_line: range.start.line,\n-                start_character: Some(range.start.character),\n-                end_line: range.end.line,\n-                end_character: Some(range.start.character),\n-                kind: Some(kind)\n-            }\n-        })\n-        .collect());\n+    let res = Some(\n+        world\n+            .analysis()\n+            .folding_ranges(file_id)\n+            .into_iter()\n+            .map(|fold| {\n+                let kind = match fold.kind {\n+                    FoldKind::Comment => FoldingRangeKind::Comment,\n+                    FoldKind::Imports => FoldingRangeKind::Imports,\n+                };\n+                let range = fold.range.conv_with(&line_index);\n+                FoldingRange {\n+                    start_line: range.start.line,\n+                    start_character: Some(range.start.character),\n+                    end_line: range.end.line,\n+                    end_character: Some(range.start.character),\n+                    kind: Some(kind),\n+                }\n+            })\n+            .collect(),\n+    );\n \n     Ok(res)\n }\n@@ -422,25 +432,28 @@ pub fn handle_signature_help(\n     let line_index = world.analysis().file_line_index(file_id);\n     let offset = params.position.conv_with(&line_index);\n \n-    if let Some((descriptor, active_param)) = world.analysis().resolve_callable(file_id, offset, &token) {\n-        let parameters : Vec<ParameterInformation> =\n-            descriptor.params.iter().map(|param|\n-                ParameterInformation {\n-                    label: param.clone(),\n-                    documentation: None\n-                }\n-            ).collect();\n+    if let Some((descriptor, active_param)) =\n+        world.analysis().resolve_callable(file_id, offset, &token)\n+    {\n+        let parameters: Vec<ParameterInformation> = descriptor\n+            .params\n+            .iter()\n+            .map(|param| ParameterInformation {\n+                label: param.clone(),\n+                documentation: None,\n+            })\n+            .collect();\n \n         let sig_info = SignatureInformation {\n             label: descriptor.label,\n             documentation: None,\n-            parameters: Some(parameters)\n+            parameters: Some(parameters),\n         };\n \n         Ok(Some(req::SignatureHelp {\n             signatures: vec![sig_info],\n             active_signature: Some(0),\n-            active_parameter: active_param.map(|a| a as u64)\n+            active_parameter: active_param.map(|a| a as u64),\n         }))\n     } else {\n         Ok(None)\n@@ -457,7 +470,10 @@ pub fn handle_code_action(\n     let range = params.range.conv_with(&line_index);\n \n     let assists = world.analysis().assists(file_id, range).into_iter();\n-    let fixes = world.analysis().diagnostics(file_id).into_iter()\n+    let fixes = world\n+        .analysis()\n+        .diagnostics(file_id)\n+        .into_iter()\n         .filter_map(|d| Some((d.range, d.fix?)))\n         .filter(|(range, _fix)| contains_offset_nonstrict(*range, range.start()))\n         .map(|(_range, fix)| fix);\n@@ -483,7 +499,9 @@ pub fn publish_diagnostics(\n ) -> Result<req::PublishDiagnosticsParams> {\n     let uri = world.file_id_to_uri(file_id)?;\n     let line_index = world.analysis().file_line_index(file_id);\n-    let diagnostics = world.analysis().diagnostics(file_id)\n+    let diagnostics = world\n+        .analysis()\n+        .diagnostics(file_id)\n         .into_iter()\n         .map(|d| Diagnostic {\n             range: d.range.conv_with(&line_index),\n@@ -492,7 +510,8 @@ pub fn publish_diagnostics(\n             source: Some(\"rust-analyzer\".to_string()),\n             message: d.message,\n             related_information: None,\n-        }).collect();\n+        })\n+        .collect();\n     Ok(req::PublishDiagnosticsParams { uri, diagnostics })\n }\n \n@@ -509,10 +528,13 @@ pub fn publish_decorations(\n \n fn highlight(world: &ServerWorld, file_id: FileId) -> Vec<Decoration> {\n     let line_index = world.analysis().file_line_index(file_id);\n-    world.analysis().highlight(file_id)\n+    world\n+        .analysis()\n+        .highlight(file_id)\n         .into_iter()\n         .map(|h| Decoration {\n             range: h.range.conv_with(&line_index),\n             tag: h.tag,\n-        }).collect()\n+        })\n+        .collect()\n }"}, {"sha": "a11baf4aaecb1682f1650e0dc4649f845ca6e496", "filename": "crates/ra_lsp_server/src/main_loop/mod.rs", "status": "modified", "additions": 79, "deletions": 82, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fmod.rs?ref=61f3a438d3a729a6be941bca1ff4c6a97a33f221", "patch": "@@ -1,29 +1,26 @@\n mod handlers;\n mod subscriptions;\n \n-use std::{\n-    path::PathBuf,\n-};\n+use std::path::PathBuf;\n \n-use serde::{Serialize, de::DeserializeOwned};\n-use crossbeam_channel::{unbounded, Sender, Receiver};\n-use rayon::{self, ThreadPool};\n-use languageserver_types::{NumberOrString};\n-use ra_analysis::{FileId, JobHandle, JobToken, LibraryData};\n+use crossbeam_channel::{unbounded, Receiver, Sender};\n use gen_lsp_server::{\n-    RawRequest, RawNotification, RawMessage, RawResponse, ErrorCode,\n-    handle_shutdown,\n+    handle_shutdown, ErrorCode, RawMessage, RawNotification, RawRequest, RawResponse,\n };\n+use languageserver_types::NumberOrString;\n+use ra_analysis::{FileId, JobHandle, JobToken, LibraryData};\n+use rayon::{self, ThreadPool};\n use rustc_hash::FxHashMap;\n+use serde::{de::DeserializeOwned, Serialize};\n \n use crate::{\n+    main_loop::subscriptions::Subscriptions,\n+    project_model::{workspace_loader, CargoWorkspace},\n     req,\n-    Result,\n-    vfs::{self, FileEvent},\n-    server_world::{ServerWorldState, ServerWorld},\n-    main_loop::subscriptions::{Subscriptions},\n-    project_model::{CargoWorkspace, workspace_loader},\n+    server_world::{ServerWorld, ServerWorldState},\n     thread_watcher::Worker,\n+    vfs::{self, FileEvent},\n+    Result,\n };\n \n #[derive(Debug)]\n@@ -147,56 +144,50 @@ fn main_loop_inner(\n                 }\n                 state_changed = true;\n             }\n-            Event::Ws(ws) => {\n-                match ws {\n-                    Ok(ws) => {\n-                        let workspaces = vec![ws];\n-                        feedback(internal_mode, \"workspace loaded\", msg_sender);\n-                        for ws in workspaces.iter() {\n-                            for pkg in ws.packages().filter(|pkg| !pkg.is_member(ws)) {\n-                                debug!(\"sending root, {}\", pkg.root(ws).to_path_buf().display());\n-                                fs_worker.send(pkg.root(ws).to_path_buf());\n-                            }\n+            Event::Ws(ws) => match ws {\n+                Ok(ws) => {\n+                    let workspaces = vec![ws];\n+                    feedback(internal_mode, \"workspace loaded\", msg_sender);\n+                    for ws in workspaces.iter() {\n+                        for pkg in ws.packages().filter(|pkg| !pkg.is_member(ws)) {\n+                            debug!(\"sending root, {}\", pkg.root(ws).to_path_buf().display());\n+                            fs_worker.send(pkg.root(ws).to_path_buf());\n                         }\n-                        state.set_workspaces(workspaces);\n-                        state_changed = true;\n                     }\n-                    Err(e) => warn!(\"loading workspace failed: {}\", e),\n+                    state.set_workspaces(workspaces);\n+                    state_changed = true;\n                 }\n-            }\n+                Err(e) => warn!(\"loading workspace failed: {}\", e),\n+            },\n             Event::Lib(lib) => {\n                 feedback(internal_mode, \"library loaded\", msg_sender);\n                 state.add_lib(lib);\n             }\n-            Event::Msg(msg) => {\n-                match msg {\n-                    RawMessage::Request(req) => {\n-                        let req = match handle_shutdown(req, msg_sender) {\n-                            Some(req) => req,\n-                            None => return Ok(()),\n-                        };\n-                        match on_request(state, pending_requests, pool, &task_sender, req)? {\n-                            None => (),\n-                            Some(req) => {\n-                                error!(\"unknown request: {:?}\", req);\n-                                let resp = RawResponse::err(\n-                                    req.id,\n-                                    ErrorCode::MethodNotFound as i32,\n-                                    \"unknown request\".to_string(),\n-                                );\n-                                msg_sender.send(RawMessage::Response(resp))\n-                            }\n+            Event::Msg(msg) => match msg {\n+                RawMessage::Request(req) => {\n+                    let req = match handle_shutdown(req, msg_sender) {\n+                        Some(req) => req,\n+                        None => return Ok(()),\n+                    };\n+                    match on_request(state, pending_requests, pool, &task_sender, req)? {\n+                        None => (),\n+                        Some(req) => {\n+                            error!(\"unknown request: {:?}\", req);\n+                            let resp = RawResponse::err(\n+                                req.id,\n+                                ErrorCode::MethodNotFound as i32,\n+                                \"unknown request\".to_string(),\n+                            );\n+                            msg_sender.send(RawMessage::Response(resp))\n                         }\n                     }\n-                    RawMessage::Notification(not) => {\n-                        on_notification(msg_sender, state, pending_requests, subs, not)?;\n-                        state_changed = true;\n-                    }\n-                    RawMessage::Response(resp) => {\n-                        error!(\"unexpected response: {:?}\", resp)\n-                    }\n                 }\n-            }\n+                RawMessage::Notification(not) => {\n+                    on_notification(msg_sender, state, pending_requests, subs, not)?;\n+                    state_changed = true;\n+                }\n+                RawMessage::Response(resp) => error!(\"unexpected response: {:?}\", resp),\n+            },\n         };\n \n         if state_changed {\n@@ -222,8 +213,7 @@ fn on_task(\n             }\n             msg_sender.send(RawMessage::Response(response))\n         }\n-        Task::Notify(n) =>\n-            msg_sender.send(RawMessage::Notification(n)),\n+        Task::Notify(n) => msg_sender.send(RawMessage::Notification(n)),\n     }\n }\n \n@@ -237,7 +227,9 @@ fn on_request(\n     let mut pool_dispatcher = PoolDispatcher {\n         req: Some(req),\n         res: None,\n-        pool, world, sender\n+        pool,\n+        world,\n+        sender,\n     };\n     let req = pool_dispatcher\n         .on::<req::SyntaxTree>(handlers::handle_syntax_tree)?\n@@ -262,7 +254,7 @@ fn on_request(\n             let inserted = pending_requests.insert(id, handle).is_none();\n             assert!(inserted, \"duplicate request: {}\", id);\n             Ok(None)\n-        },\n+        }\n         Err(req) => Ok(Some(req)),\n     }\n }\n@@ -285,45 +277,53 @@ fn on_notification(\n             if let Some(handle) = pending_requests.remove(&id) {\n                 handle.cancel();\n             }\n-            return Ok(())\n+            return Ok(());\n         }\n         Err(not) => not,\n     };\n     let not = match not.cast::<req::DidOpenTextDocument>() {\n         Ok(params) => {\n             let uri = params.text_document.uri;\n-            let path = uri.to_file_path()\n+            let path = uri\n+                .to_file_path()\n                 .map_err(|()| format_err!(\"invalid uri: {}\", uri))?;\n             let file_id = state.add_mem_file(path, params.text_document.text);\n             subs.add_sub(file_id);\n-            return Ok(())\n+            return Ok(());\n         }\n         Err(not) => not,\n     };\n     let not = match not.cast::<req::DidChangeTextDocument>() {\n         Ok(mut params) => {\n             let uri = params.text_document.uri;\n-            let path = uri.to_file_path()\n+            let path = uri\n+                .to_file_path()\n                 .map_err(|()| format_err!(\"invalid uri: {}\", uri))?;\n-            let text = params.content_changes.pop()\n+            let text = params\n+                .content_changes\n+                .pop()\n                 .ok_or_else(|| format_err!(\"empty changes\"))?\n                 .text;\n             state.change_mem_file(path.as_path(), text)?;\n-            return Ok(())\n+            return Ok(());\n         }\n         Err(not) => not,\n     };\n     let not = match not.cast::<req::DidCloseTextDocument>() {\n         Ok(params) => {\n             let uri = params.text_document.uri;\n-            let path = uri.to_file_path()\n+            let path = uri\n+                .to_file_path()\n                 .map_err(|()| format_err!(\"invalid uri: {}\", uri))?;\n             let file_id = state.remove_mem_file(path.as_path())?;\n             subs.remove_sub(file_id);\n-            let params = req::PublishDiagnosticsParams { uri, diagnostics: Vec::new() };\n+            let params = req::PublishDiagnosticsParams {\n+                uri,\n+                diagnostics: Vec::new(),\n+            };\n             let not = RawNotification::new::<req::PublishDiagnostics>(&params);\n             msg_sender.send(RawMessage::Notification(not));\n-            return Ok(())\n+            return Ok(());\n         }\n         Err(not) => not,\n     };\n@@ -342,11 +342,12 @@ struct PoolDispatcher<'a> {\n impl<'a> PoolDispatcher<'a> {\n     fn on<'b, R>(\n         &'b mut self,\n-        f: fn(ServerWorld, R::Params, JobToken) -> Result<R::Result>\n+        f: fn(ServerWorld, R::Params, JobToken) -> Result<R::Result>,\n     ) -> Result<&'b mut Self>\n-    where R: req::Request,\n-          R::Params: DeserializeOwned + Send + 'static,\n-          R::Result: Serialize + 'static,\n+    where\n+        R: req::Request,\n+        R::Params: DeserializeOwned + Send + 'static,\n+        R::Result: Serialize + 'static,\n     {\n         let req = match self.req.take() {\n             None => return Ok(self),\n@@ -360,16 +361,16 @@ impl<'a> PoolDispatcher<'a> {\n                 self.pool.spawn(move || {\n                     let resp = match f(world, params, token) {\n                         Ok(resp) => RawResponse::ok::<R>(id, &resp),\n-                        Err(e) => RawResponse::err(id, ErrorCode::InternalError as i32, e.to_string()),\n+                        Err(e) => {\n+                            RawResponse::err(id, ErrorCode::InternalError as i32, e.to_string())\n+                        }\n                     };\n                     let task = Task::Respond(resp);\n                     sender.send(task);\n                 });\n                 self.res = Some((id, handle));\n             }\n-            Err(req) => {\n-                self.req = Some(req)\n-            }\n+            Err(req) => self.req = Some(req),\n         }\n         Ok(self)\n     }\n@@ -392,18 +393,14 @@ fn update_file_notifications_on_threadpool(\n     pool.spawn(move || {\n         for file_id in subscriptions {\n             match handlers::publish_diagnostics(&world, file_id) {\n-                Err(e) => {\n-                    error!(\"failed to compute diagnostics: {:?}\", e)\n-                }\n+                Err(e) => error!(\"failed to compute diagnostics: {:?}\", e),\n                 Ok(params) => {\n                     let not = RawNotification::new::<req::PublishDiagnostics>(&params);\n                     sender.send(Task::Notify(not));\n                 }\n             }\n             match handlers::publish_decorations(&world, file_id) {\n-                Err(e) => {\n-                    error!(\"failed to compute decorations: {:?}\", e)\n-                }\n+                Err(e) => error!(\"failed to compute decorations: {:?}\", e),\n                 Ok(params) => {\n                     let not = RawNotification::new::<req::PublishDecorations>(&params);\n                     sender.send(Task::Notify(not))"}, {"sha": "03f41e8705f5bb5c3cf33a24bc2c7a1dfa51fb51", "filename": "crates/ra_lsp_server/src/main_loop/subscriptions.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fsubscriptions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fsubscriptions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fsubscriptions.rs?ref=61f3a438d3a729a6be941bca1ff4c6a97a33f221", "patch": "@@ -1,13 +1,15 @@\n-use rustc_hash::FxHashSet;\n use ra_analysis::FileId;\n+use rustc_hash::FxHashSet;\n \n pub struct Subscriptions {\n     subs: FxHashSet<FileId>,\n }\n \n impl Subscriptions {\n     pub fn new() -> Subscriptions {\n-        Subscriptions { subs: FxHashSet::default() }\n+        Subscriptions {\n+            subs: FxHashSet::default(),\n+        }\n     }\n     pub fn add_sub(&mut self, file_id: FileId) {\n         self.subs.insert(file_id);"}, {"sha": "585013acd3e20e2afe1e9aa537f8980fc538cb57", "filename": "crates/ra_lsp_server/src/path_map.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_lsp_server%2Fsrc%2Fpath_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_lsp_server%2Fsrc%2Fpath_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fpath_map.rs?ref=61f3a438d3a729a6be941bca1ff4c6a97a33f221", "patch": "@@ -1,11 +1,13 @@\n-use std::path::{PathBuf, Path, Component};\n use im;\n-use relative_path::RelativePath;\n use ra_analysis::{FileId, FileResolver};\n+use relative_path::RelativePath;\n+\n+use std::path::{Component, Path, PathBuf};\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n pub enum Root {\n-    Workspace, Lib\n+    Workspace,\n+    Lib,\n }\n \n #[derive(Debug, Default, Clone)]\n@@ -21,7 +23,8 @@ impl PathMap {\n         Default::default()\n     }\n     pub fn get_or_insert(&mut self, path: PathBuf, root: Root) -> FileId {\n-        self.path2id.get(path.as_path())\n+        self.path2id\n+            .get(path.as_path())\n             .map(|&id| id)\n             .unwrap_or_else(|| {\n                 let id = self.new_file_id();\n@@ -33,9 +36,7 @@ impl PathMap {\n         self.path2id.get(path).map(|&id| id)\n     }\n     pub fn get_path(&self, file_id: FileId) -> &Path {\n-        self.id2path.get(&file_id)\n-            .unwrap()\n-            .as_path()\n+        self.id2path.get(&file_id).unwrap().as_path()\n     }\n     pub fn get_root(&self, file_id: FileId) -> Root {\n         self.id2root[&file_id]\n@@ -55,7 +56,12 @@ impl PathMap {\n \n impl FileResolver for PathMap {\n     fn file_stem(&self, file_id: FileId) -> String {\n-        self.get_path(file_id).file_stem().unwrap().to_str().unwrap().to_string()\n+        self.get_path(file_id)\n+            .file_stem()\n+            .unwrap()\n+            .to_str()\n+            .unwrap()\n+            .to_string()\n     }\n \n     fn resolve(&self, file_id: FileId, path: &RelativePath) -> Option<FileId> {\n@@ -101,10 +107,6 @@ mod test {\n         let mut m = PathMap::new();\n         let id1 = m.get_or_insert(PathBuf::from(\"/foo\"), Root::Workspace);\n         let id2 = m.get_or_insert(PathBuf::from(\"/foo/bar.rs\"), Root::Workspace);\n-        assert_eq!(\n-            m.resolve(id1, &RelativePath::new(\"bar.rs\")),\n-            Some(id2),\n-        )\n+        assert_eq!(m.resolve(id1, &RelativePath::new(\"bar.rs\")), Some(id2),)\n     }\n }\n-"}, {"sha": "d170ceb733511fb717c9b1ea975db4c09e091415", "filename": "crates/ra_lsp_server/src/project_model.rs", "status": "modified", "additions": 19, "deletions": 13, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_lsp_server%2Fsrc%2Fproject_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_lsp_server%2Fsrc%2Fproject_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fproject_model.rs?ref=61f3a438d3a729a6be941bca1ff4c6a97a33f221", "patch": "@@ -1,13 +1,12 @@\n-use std::{\n-    path::{Path, PathBuf},\n-};\n-use rustc_hash::{FxHashMap, FxHashSet};\n use cargo_metadata::{metadata_run, CargoOpt};\n use ra_syntax::SmolStr;\n+use rustc_hash::{FxHashMap, FxHashSet};\n+\n+use std::path::{Path, PathBuf};\n \n use crate::{\n+    thread_watcher::{ThreadWatcher, Worker},\n     Result,\n-    thread_watcher::{Worker, ThreadWatcher},\n };\n \n #[derive(Debug, Clone)]\n@@ -39,7 +38,12 @@ struct TargetData {\n \n #[derive(Debug, Clone, Copy, PartialEq, Eq)]\n pub enum TargetKind {\n-    Bin, Lib, Example, Test, Bench, Other,\n+    Bin,\n+    Lib,\n+    Example,\n+    Test,\n+    Bench,\n+    Other,\n }\n \n impl Package {\n@@ -49,7 +53,7 @@ impl Package {\n     pub fn root(self, ws: &CargoWorkspace) -> &Path {\n         ws.pkg(self).manifest.parent().unwrap()\n     }\n-    pub fn targets<'a>(self, ws: &'a CargoWorkspace) -> impl Iterator<Item=Target> + 'a {\n+    pub fn targets<'a>(self, ws: &'a CargoWorkspace) -> impl Iterator<Item = Target> + 'a {\n         ws.pkg(self).targets.iter().cloned()\n     }\n     pub fn is_member(self, ws: &CargoWorkspace) -> bool {\n@@ -78,13 +82,15 @@ impl CargoWorkspace {\n         let meta = metadata_run(\n             Some(cargo_toml.as_path()),\n             true,\n-            Some(CargoOpt::AllFeatures)\n-        ).map_err(|e| format_err!(\"cargo metadata failed: {}\", e))?;\n+            Some(CargoOpt::AllFeatures),\n+        )\n+        .map_err(|e| format_err!(\"cargo metadata failed: {}\", e))?;\n         let mut pkg_by_id = FxHashMap::default();\n         let mut packages = Vec::new();\n         let mut targets = Vec::new();\n \n-        let ws_members: FxHashSet<String> = meta.workspace_members\n+        let ws_members: FxHashSet<String> = meta\n+            .workspace_members\n             .into_iter()\n             .map(|it| it.raw)\n             .collect();\n@@ -114,7 +120,7 @@ impl CargoWorkspace {\n \n         Ok(CargoWorkspace { packages, targets })\n     }\n-    pub fn packages<'a>(&'a self) -> impl Iterator<Item=Package> + 'a {\n+    pub fn packages<'a>(&'a self) -> impl Iterator<Item = Package> + 'a {\n         (0..self.packages.len()).map(Package)\n     }\n     pub fn target_by_root(&self, root: &Path) -> Option<Target> {\n@@ -155,7 +161,7 @@ impl TargetKind {\n                 \"example\" => TargetKind::Example,\n                 _ if kind.contains(\"lib\") => TargetKind::Lib,\n                 _ => continue,\n-            }\n+            };\n         }\n         TargetKind::Other\n     }\n@@ -170,6 +176,6 @@ pub fn workspace_loader() -> (Worker<PathBuf, Result<CargoWorkspace>>, ThreadWat\n                 .into_iter()\n                 .map(|path| CargoWorkspace::from_cargo_metadata(path.as_path()))\n                 .for_each(|it| output_sender.send(it))\n-        }\n+        },\n     )\n }"}, {"sha": "b76bfbcbc67315597a9370f6842a631635533933", "filename": "crates/ra_lsp_server/src/req.rs", "status": "modified", "additions": 10, "deletions": 17, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_lsp_server%2Fsrc%2Freq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_lsp_server%2Fsrc%2Freq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Freq.rs?ref=61f3a438d3a729a6be941bca1ff4c6a97a33f221", "patch": "@@ -1,20 +1,13 @@\n+use languageserver_types::{Location, Position, Range, TextDocumentIdentifier, Url};\n use rustc_hash::FxHashMap;\n-use languageserver_types::{TextDocumentIdentifier, Range, Url, Position, Location};\n use url_serde;\n \n pub use languageserver_types::{\n-    request::*, notification::*,\n-    InitializeResult, PublishDiagnosticsParams,\n-    DocumentSymbolParams, DocumentSymbolResponse,\n-    CodeActionParams, ApplyWorkspaceEditParams,\n-    ExecuteCommandParams,\n-    WorkspaceSymbolParams,\n-    TextDocumentPositionParams,\n-    TextEdit,\n-    CompletionParams, CompletionResponse,\n-    DocumentOnTypeFormattingParams,\n-    TextDocumentEdit,\n-    SignatureHelp, Hover\n+    notification::*, request::*, ApplyWorkspaceEditParams, CodeActionParams, CompletionParams,\n+    CompletionResponse, DocumentOnTypeFormattingParams, DocumentSymbolParams,\n+    DocumentSymbolResponse, ExecuteCommandParams, Hover, InitializeResult,\n+    PublishDiagnosticsParams, SignatureHelp, TextDocumentEdit, TextDocumentPositionParams,\n+    TextEdit, WorkspaceSymbolParams,\n };\n \n pub enum SyntaxTree {}\n@@ -28,7 +21,7 @@ impl Request for SyntaxTree {\n #[derive(Deserialize, Debug)]\n #[serde(rename_all = \"camelCase\")]\n pub struct SyntaxTreeParams {\n-    pub text_document: TextDocumentIdentifier\n+    pub text_document: TextDocumentIdentifier,\n }\n \n pub enum ExtendSelection {}\n@@ -94,7 +87,7 @@ pub struct PublishDecorationsParams {\n #[serde(rename_all = \"camelCase\")]\n pub struct Decoration {\n     pub range: Range,\n-    pub tag: &'static str\n+    pub tag: &'static str,\n }\n \n pub enum ParentModule {}\n@@ -167,14 +160,14 @@ pub struct SourceChange {\n pub enum FileSystemEdit {\n     CreateFile {\n         #[serde(with = \"url_serde\")]\n-        uri: Url\n+        uri: Url,\n     },\n     MoveFile {\n         #[serde(with = \"url_serde\")]\n         src: Url,\n         #[serde(with = \"url_serde\")]\n         dst: Url,\n-    }\n+    },\n }\n \n pub enum InternalFeedback {}"}, {"sha": "35ff65ea1610d126e15a84051ff0135a9f15339a", "filename": "crates/ra_lsp_server/src/server_world.rs", "status": "modified", "additions": 43, "deletions": 33, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_lsp_server%2Fsrc%2Fserver_world.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_lsp_server%2Fsrc%2Fserver_world.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fserver_world.rs?ref=61f3a438d3a729a6be941bca1ff4c6a97a33f221", "patch": "@@ -1,18 +1,18 @@\n use std::{\n     fs,\n-    path::{PathBuf, Path},\n+    path::{Path, PathBuf},\n     sync::Arc,\n };\n \n-use rustc_hash::FxHashMap;\n use languageserver_types::Url;\n-use ra_analysis::{FileId, AnalysisHost, Analysis, CrateGraph, CrateId, LibraryData, FileResolver};\n+use ra_analysis::{Analysis, AnalysisHost, CrateGraph, CrateId, FileId, FileResolver, LibraryData};\n+use rustc_hash::FxHashMap;\n \n use crate::{\n-    Result,\n     path_map::{PathMap, Root},\n-    vfs::{FileEvent, FileEventKind},\n     project_model::CargoWorkspace,\n+    vfs::{FileEvent, FileEventKind},\n+    Result,\n };\n \n #[derive(Debug)]\n@@ -42,16 +42,15 @@ impl ServerWorldState {\n         {\n             let pm = &mut self.path_map;\n             let mm = &mut self.mem_map;\n-            let changes = events.into_iter()\n+            let changes = events\n+                .into_iter()\n                 .map(|event| {\n                     let text = match event.kind {\n                         FileEventKind::Add(text) => Some(text),\n                     };\n                     (event.path, text)\n                 })\n-                .map(|(path, text)| {\n-                    (pm.get_or_insert(path, Root::Workspace), text)\n-                })\n+                .map(|(path, text)| (pm.get_or_insert(path, Root::Workspace), text))\n                 .filter_map(|(id, text)| {\n                     if mm.contains_key(&id) {\n                         mm.insert(id, text);\n@@ -62,12 +61,17 @@ impl ServerWorldState {\n                 });\n             self.analysis_host.change_files(changes);\n         }\n-        self.analysis_host.set_file_resolver(Arc::new(self.path_map.clone()));\n+        self.analysis_host\n+            .set_file_resolver(Arc::new(self.path_map.clone()));\n     }\n-    pub fn events_to_files(&mut self, events: Vec<FileEvent>) -> (Vec<(FileId, String)>, Arc<FileResolver>) {\n+    pub fn events_to_files(\n+        &mut self,\n+        events: Vec<FileEvent>,\n+    ) -> (Vec<(FileId, String)>, Arc<FileResolver>) {\n         let files = {\n             let pm = &mut self.path_map;\n-            events.into_iter()\n+            events\n+                .into_iter()\n                 .map(|event| {\n                     let text = match event.kind {\n                         FileEventKind::Add(text) => text,\n@@ -86,7 +90,8 @@ impl ServerWorldState {\n \n     pub fn add_mem_file(&mut self, path: PathBuf, text: String) -> FileId {\n         let file_id = self.path_map.get_or_insert(path, Root::Workspace);\n-        self.analysis_host.set_file_resolver(Arc::new(self.path_map.clone()));\n+        self.analysis_host\n+            .set_file_resolver(Arc::new(self.path_map.clone()));\n         self.mem_map.insert(file_id, None);\n         if self.path_map.get_root(file_id) != Root::Lib {\n             self.analysis_host.change_file(file_id, Some(text));\n@@ -95,19 +100,21 @@ impl ServerWorldState {\n     }\n \n     pub fn change_mem_file(&mut self, path: &Path, text: String) -> Result<()> {\n-        let file_id = self.path_map.get_id(path).ok_or_else(|| {\n-            format_err!(\"change to unknown file: {}\", path.display())\n-        })?;\n+        let file_id = self\n+            .path_map\n+            .get_id(path)\n+            .ok_or_else(|| format_err!(\"change to unknown file: {}\", path.display()))?;\n         if self.path_map.get_root(file_id) != Root::Lib {\n             self.analysis_host.change_file(file_id, Some(text));\n         }\n         Ok(())\n     }\n \n     pub fn remove_mem_file(&mut self, path: &Path) -> Result<FileId> {\n-        let file_id = self.path_map.get_id(path).ok_or_else(|| {\n-            format_err!(\"change to unknown file: {}\", path.display())\n-        })?;\n+        let file_id = self\n+            .path_map\n+            .get_id(path)\n+            .ok_or_else(|| format_err!(\"change to unknown file: {}\", path.display()))?;\n         match self.mem_map.remove(&file_id) {\n             Some(_) => (),\n             None => bail!(\"unmatched close notification\"),\n@@ -122,17 +129,17 @@ impl ServerWorldState {\n     pub fn set_workspaces(&mut self, ws: Vec<CargoWorkspace>) {\n         let mut crate_roots = FxHashMap::default();\n         ws.iter()\n-          .flat_map(|ws| {\n-              ws.packages()\n-                .flat_map(move |pkg| pkg.targets(ws))\n-                .map(move |tgt| tgt.root(ws))\n-          })\n-          .for_each(|root| {\n-              if let Some(file_id) = self.path_map.get_id(root) {\n-                  let crate_id = CrateId(crate_roots.len() as u32);\n-                  crate_roots.insert(crate_id, file_id);\n-              }\n-          });\n+            .flat_map(|ws| {\n+                ws.packages()\n+                    .flat_map(move |pkg| pkg.targets(ws))\n+                    .map(move |tgt| tgt.root(ws))\n+            })\n+            .for_each(|root| {\n+                if let Some(file_id) = self.path_map.get_id(root) {\n+                    let crate_id = CrateId(crate_roots.len() as u32);\n+                    crate_roots.insert(crate_id, file_id);\n+                }\n+            });\n         let crate_graph = CrateGraph { crate_roots };\n         self.workspaces = Arc::new(ws);\n         self.analysis_host.set_crate_graph(crate_graph);\n@@ -141,7 +148,7 @@ impl ServerWorldState {\n         ServerWorld {\n             workspaces: Arc::clone(&self.workspaces),\n             analysis: self.analysis_host.analysis(),\n-            path_map: self.path_map.clone()\n+            path_map: self.path_map.clone(),\n         }\n     }\n }\n@@ -152,9 +159,12 @@ impl ServerWorld {\n     }\n \n     pub fn uri_to_file_id(&self, uri: &Url) -> Result<FileId> {\n-        let path = uri.to_file_path()\n+        let path = uri\n+            .to_file_path()\n             .map_err(|()| format_err!(\"invalid uri: {}\", uri))?;\n-        self.path_map.get_id(&path).ok_or_else(|| format_err!(\"unknown file: {}\", path.display()))\n+        self.path_map\n+            .get_id(&path)\n+            .ok_or_else(|| format_err!(\"unknown file: {}\", path.display()))\n     }\n \n     pub fn file_id_to_uri(&self, id: FileId) -> Result<Url> {"}, {"sha": "67952eb747a683397e1e7158b80ece18917b3e56", "filename": "crates/ra_lsp_server/src/thread_watcher.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_lsp_server%2Fsrc%2Fthread_watcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_lsp_server%2Fsrc%2Fthread_watcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fthread_watcher.rs?ref=61f3a438d3a729a6be941bca1ff4c6a97a33f221", "patch": "@@ -1,7 +1,8 @@\n-use std::thread;\n-use crossbeam_channel::{bounded, unbounded, Sender, Receiver};\n-use drop_bomb::DropBomb;\n use crate::Result;\n+use crossbeam_channel::{bounded, unbounded, Receiver, Sender};\n+use drop_bomb::DropBomb;\n+\n+use std::thread;\n \n pub struct Worker<I, O> {\n     pub inp: Sender<I>,\n@@ -50,11 +51,13 @@ impl ThreadWatcher {\n         info!(\"waiting for {} to finish ...\", self.name);\n         let name = self.name;\n         self.bomb.defuse();\n-        let res = self.thread.join()\n+        let res = self\n+            .thread\n+            .join()\n             .map_err(|_| format_err!(\"ThreadWatcher {} died\", name));\n         match &res {\n             Ok(()) => info!(\"... {} terminated with ok\", name),\n-            Err(_) => error!(\"... {} terminated with err\", name)\n+            Err(_) => error!(\"... {} terminated with err\", name),\n         }\n         res\n     }\n@@ -66,5 +69,9 @@ impl ThreadWatcher {\n fn worker_chan<I, O>(buf: usize) -> ((Sender<I>, Receiver<O>), Receiver<I>, Sender<O>) {\n     let (input_sender, input_receiver) = bounded::<I>(buf);\n     let (output_sender, output_receiver) = unbounded::<O>();\n-    ((input_sender, output_receiver), input_receiver, output_sender)\n+    (\n+        (input_sender, output_receiver),\n+        input_receiver,\n+        output_sender,\n+    )\n }"}, {"sha": "417a3c19ae459fc726ae8b823a8c0abbddf52e25", "filename": "crates/ra_lsp_server/src/vfs.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_lsp_server%2Fsrc%2Fvfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_lsp_server%2Fsrc%2Fvfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fvfs.rs?ref=61f3a438d3a729a6be941bca1ff4c6a97a33f221", "patch": "@@ -1,14 +1,11 @@\n use std::{\n-    path::{PathBuf, Path},\n     fs,\n+    path::{Path, PathBuf},\n };\n \n use walkdir::WalkDir;\n \n-use crate::{\n-    thread_watcher::{Worker, ThreadWatcher},\n-};\n-\n+use crate::thread_watcher::{ThreadWatcher, Worker};\n \n #[derive(Debug)]\n pub struct FileEvent {\n@@ -24,7 +21,8 @@ pub enum FileEventKind {\n pub fn roots_loader() -> (Worker<PathBuf, (PathBuf, Vec<FileEvent>)>, ThreadWatcher) {\n     Worker::<PathBuf, (PathBuf, Vec<FileEvent>)>::spawn(\n         \"roots loader\",\n-        128, |input_receiver, output_sender| {\n+        128,\n+        |input_receiver, output_sender| {\n             input_receiver\n                 .into_iter()\n                 .map(|path| {\n@@ -34,7 +32,7 @@ pub fn roots_loader() -> (Worker<PathBuf, (PathBuf, Vec<FileEvent>)>, ThreadWatc\n                     (path, events)\n                 })\n                 .for_each(|it| output_sender.send(it))\n-        }\n+        },\n     )\n }\n "}, {"sha": "8e566d3c8fbf0753e56401a9c4cea952cea0f85e", "filename": "crates/ra_lsp_server/tests/heavy_tests/main.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_lsp_server%2Ftests%2Fheavy_tests%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_lsp_server%2Ftests%2Fheavy_tests%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Ftests%2Fheavy_tests%2Fmain.rs?ref=61f3a438d3a729a6be941bca1ff4c6a97a33f221", "patch": "@@ -1,30 +1,31 @@\n #[macro_use]\n extern crate crossbeam_channel;\n-extern crate tempdir;\n+extern crate flexi_logger;\n+extern crate gen_lsp_server;\n extern crate languageserver_types;\n+extern crate ra_lsp_server;\n extern crate serde;\n extern crate serde_json;\n-extern crate gen_lsp_server;\n-extern crate flexi_logger;\n-extern crate ra_lsp_server;\n+extern crate tempdir;\n \n mod support;\n \n use ra_lsp_server::req::{Runnables, RunnablesParams};\n \n use crate::support::project;\n \n-\n const LOG: &'static str = \"\";\n \n #[test]\n fn test_runnables_no_project() {\n-    let server = project(r\"\n+    let server = project(\n+        r\"\n //- lib.rs\n #[test]\n fn foo() {\n }\n-\");\n+\",\n+    );\n     server.request::<Runnables>(\n         RunnablesParams {\n             text_document: server.doc_id(\"lib.rs\"),\n@@ -41,13 +42,14 @@ fn foo() {\n               \"start\": { \"character\": 0, \"line\": 0 }\n             }\n           }\n-        ]\"#\n+        ]\"#,\n     );\n }\n \n #[test]\n fn test_runnables_project() {\n-    let server = project(r#\"\n+    let server = project(\n+        r#\"\n //- Cargo.toml\n [package]\n name = \"foo\"\n@@ -59,7 +61,8 @@ pub fn foo() {}\n //- tests/spam.rs\n #[test]\n fn test_eggs() {}\n-\"#);\n+\"#,\n+    );\n     server.wait_for_feedback(\"workspace loaded\");\n     server.request::<Runnables>(\n         RunnablesParams {"}, {"sha": "004d7e8adde3a5a7df971890c66399c025fa8d89", "filename": "crates/ra_lsp_server/tests/heavy_tests/support.rs", "status": "modified", "additions": 33, "deletions": 45, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_lsp_server%2Ftests%2Fheavy_tests%2Fsupport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_lsp_server%2Ftests%2Fheavy_tests%2Fsupport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Ftests%2Fheavy_tests%2Fsupport.rs?ref=61f3a438d3a729a6be941bca1ff4c6a97a33f221", "patch": "@@ -1,34 +1,33 @@\n use std::{\n-    fs,\n     cell::{Cell, RefCell},\n+    fs,\n     path::PathBuf,\n-    time::Duration,\n     sync::Once,\n+    time::Duration,\n };\n \n-use tempdir::TempDir;\n use crossbeam_channel::{after, Receiver};\n use flexi_logger::Logger;\n+use gen_lsp_server::{RawMessage, RawNotification, RawRequest};\n use languageserver_types::{\n-    Url,\n-    TextDocumentIdentifier,\n-    request::{Request, Shutdown},\n     notification::DidOpenTextDocument,\n-    DidOpenTextDocumentParams,\n-    TextDocumentItem,\n+    request::{Request, Shutdown},\n+    DidOpenTextDocumentParams, TextDocumentIdentifier, TextDocumentItem, Url,\n };\n use serde::Serialize;\n-use serde_json::{Value, from_str, to_string_pretty};\n-use gen_lsp_server::{RawMessage, RawRequest, RawNotification};\n+use serde_json::{from_str, to_string_pretty, Value};\n+use tempdir::TempDir;\n \n-use ra_lsp_server::{main_loop, req, thread_watcher::{ThreadWatcher, Worker}};\n+use ra_lsp_server::{\n+    main_loop, req,\n+    thread_watcher::{ThreadWatcher, Worker},\n+};\n \n pub fn project(fixture: &str) -> Server {\n     static INIT: Once = Once::new();\n     INIT.call_once(|| Logger::with_env_or_str(crate::LOG).start().unwrap());\n \n-    let tmp_dir = TempDir::new(\"test-project\")\n-        .unwrap();\n+    let tmp_dir = TempDir::new(\"test-project\").unwrap();\n     let mut buf = String::new();\n     let mut file_name = None;\n     let mut paths = vec![];\n@@ -40,7 +39,7 @@ pub fn project(fixture: &str) -> Server {\n                 fs::write(path.as_path(), buf.as_bytes()).unwrap();\n                 paths.push((path, buf.clone()));\n             }\n-        }\n+        };\n     };\n     for line in fixture.lines() {\n         if line.starts_with(\"//-\") {\n@@ -71,9 +70,8 @@ impl Server {\n             \"test server\",\n             128,\n             move |mut msg_receiver, mut msg_sender| {\n-                main_loop(true, path, &mut msg_receiver, &mut msg_sender)\n-                    .unwrap()\n-            }\n+                main_loop(true, path, &mut msg_receiver, &mut msg_sender).unwrap()\n+            },\n         );\n         let res = Server {\n             req_id: Cell::new(1),\n@@ -91,8 +89,8 @@ impl Server {\n                         language_id: \"rust\".to_string(),\n                         version: 0,\n                         text,\n-                    }\n-                }\n+                    },\n+                },\n             ))\n         }\n         res\n@@ -105,11 +103,7 @@ impl Server {\n         }\n     }\n \n-    pub fn request<R>(\n-        &self,\n-        params: R::Params,\n-        expected_resp: &str,\n-    )\n+    pub fn request<R>(&self, params: R::Params, expected_resp: &str)\n     where\n         R: Request,\n         R::Params: Serialize,\n@@ -119,7 +113,8 @@ impl Server {\n         let expected_resp: Value = from_str(expected_resp).unwrap();\n         let actual = self.send_request::<R>(id, params);\n         assert_eq!(\n-            expected_resp, actual,\n+            expected_resp,\n+            actual,\n             \"Expected:\\n{}\\n\\\n              Actual:\\n{}\\n\",\n             to_string_pretty(&expected_resp).unwrap(),\n@@ -135,12 +130,9 @@ impl Server {\n         let r = RawRequest::new::<R>(id, &params);\n         self.send_request_(r)\n     }\n-    fn send_request_(&self, r: RawRequest) -> Value\n-    {\n+    fn send_request_(&self, r: RawRequest) -> Value {\n         let id = r.id;\n-        self.worker.as_ref()\n-            .unwrap()\n-            .send(RawMessage::Request(r));\n+        self.worker.as_ref().unwrap().send(RawMessage::Request(r));\n         while let Some(msg) = self.recv() {\n             match msg {\n                 RawMessage::Request(req) => panic!(\"unexpected request: {:?}\", req),\n@@ -161,11 +153,10 @@ impl Server {\n     }\n     pub fn wait_for_feedback_n(&self, feedback: &str, n: usize) {\n         let f = |msg: &RawMessage| match msg {\n-                RawMessage::Notification(n) if n.method == \"internalFeedback\" => {\n-                    return n.clone().cast::<req::InternalFeedback>()\n-                        .unwrap() == feedback\n-                }\n-                _ => false,\n+            RawMessage::Notification(n) if n.method == \"internalFeedback\" => {\n+                return n.clone().cast::<req::InternalFeedback>().unwrap() == feedback\n+            }\n+            _ => false,\n         };\n         let mut total = 0;\n         for msg in self.messages.borrow().iter() {\n@@ -181,14 +172,14 @@ impl Server {\n         }\n     }\n     fn recv(&self) -> Option<RawMessage> {\n-        recv_timeout(&self.worker.as_ref().unwrap().out)\n-            .map(|msg| {\n-                self.messages.borrow_mut().push(msg.clone());\n-                msg\n-            })\n+        recv_timeout(&self.worker.as_ref().unwrap().out).map(|msg| {\n+            self.messages.borrow_mut().push(msg.clone());\n+            msg\n+        })\n     }\n     fn send_notification(&self, not: RawNotification) {\n-        self.worker.as_ref()\n+        self.worker\n+            .as_ref()\n             .unwrap()\n             .send(RawMessage::Notification(not));\n     }\n@@ -201,10 +192,7 @@ impl Drop for Server {\n         while let Some(msg) = recv_timeout(&receiver) {\n             drop(msg);\n         }\n-        self.watcher.take()\n-            .unwrap()\n-            .stop()\n-            .unwrap();\n+        self.watcher.take().unwrap().stop().unwrap();\n     }\n }\n "}, {"sha": "b4896c4822847b8c3ccb4f2a71e3cb9801028581", "filename": "crates/ra_syntax/src/algo/mod.rs", "status": "modified", "additions": 33, "deletions": 21, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_syntax%2Fsrc%2Falgo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_syntax%2Fsrc%2Falgo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Falgo%2Fmod.rs?ref=61f3a438d3a729a6be941bca1ff4c6a97a33f221", "patch": "@@ -1,16 +1,18 @@\n-pub mod walk;\n pub mod visit;\n+pub mod walk;\n \n use crate::{\n-    SyntaxNodeRef, TextUnit, TextRange,\n     text_utils::{contains_offset_nonstrict, is_subrange},\n+    SyntaxNodeRef, TextRange, TextUnit,\n };\n \n pub fn find_leaf_at_offset(node: SyntaxNodeRef, offset: TextUnit) -> LeafAtOffset {\n     let range = node.range();\n     assert!(\n         contains_offset_nonstrict(range, offset),\n-        \"Bad offset: range {:?} offset {:?}\", range, offset\n+        \"Bad offset: range {:?} offset {:?}\",\n+        range,\n+        offset\n     );\n     if range.is_empty() {\n         return LeafAtOffset::None;\n@@ -20,20 +22,23 @@ pub fn find_leaf_at_offset(node: SyntaxNodeRef, offset: TextUnit) -> LeafAtOffse\n         return LeafAtOffset::Single(node);\n     }\n \n-    let mut children = node.children()\n-        .filter(|child| {\n-            let child_range = child.range();\n-            !child_range.is_empty() && contains_offset_nonstrict(child_range, offset)\n-        });\n+    let mut children = node.children().filter(|child| {\n+        let child_range = child.range();\n+        !child_range.is_empty() && contains_offset_nonstrict(child_range, offset)\n+    });\n \n     let left = children.next().unwrap();\n     let right = children.next();\n     assert!(children.next().is_none());\n     return if let Some(right) = right {\n-        match (find_leaf_at_offset(left, offset), find_leaf_at_offset(right, offset)) {\n-            (LeafAtOffset::Single(left), LeafAtOffset::Single(right)) =>\n-                LeafAtOffset::Between(left, right),\n-            _ => unreachable!()\n+        match (\n+            find_leaf_at_offset(left, offset),\n+            find_leaf_at_offset(right, offset),\n+        ) {\n+            (LeafAtOffset::Single(left), LeafAtOffset::Single(right)) => {\n+                LeafAtOffset::Between(left, right)\n+            }\n+            _ => unreachable!(),\n         }\n     } else {\n         find_leaf_at_offset(left, offset)\n@@ -44,23 +49,23 @@ pub fn find_leaf_at_offset(node: SyntaxNodeRef, offset: TextUnit) -> LeafAtOffse\n pub enum LeafAtOffset<'a> {\n     None,\n     Single(SyntaxNodeRef<'a>),\n-    Between(SyntaxNodeRef<'a>, SyntaxNodeRef<'a>)\n+    Between(SyntaxNodeRef<'a>, SyntaxNodeRef<'a>),\n }\n \n impl<'a> LeafAtOffset<'a> {\n     pub fn right_biased(self) -> Option<SyntaxNodeRef<'a>> {\n         match self {\n             LeafAtOffset::None => None,\n             LeafAtOffset::Single(node) => Some(node),\n-            LeafAtOffset::Between(_, right) => Some(right)\n+            LeafAtOffset::Between(_, right) => Some(right),\n         }\n     }\n \n     pub fn left_biased(self) -> Option<SyntaxNodeRef<'a>> {\n         match self {\n             LeafAtOffset::None => None,\n             LeafAtOffset::Single(node) => Some(node),\n-            LeafAtOffset::Between(left, _) => Some(left)\n+            LeafAtOffset::Between(left, _) => Some(left),\n         }\n     }\n }\n@@ -71,8 +76,14 @@ impl<'f> Iterator for LeafAtOffset<'f> {\n     fn next(&mut self) -> Option<SyntaxNodeRef<'f>> {\n         match *self {\n             LeafAtOffset::None => None,\n-            LeafAtOffset::Single(node) => { *self = LeafAtOffset::None; Some(node) }\n-            LeafAtOffset::Between(left, right) => { *self = LeafAtOffset::Single(right); Some(left) }\n+            LeafAtOffset::Single(node) => {\n+                *self = LeafAtOffset::None;\n+                Some(node)\n+            }\n+            LeafAtOffset::Between(left, right) => {\n+                *self = LeafAtOffset::Single(right);\n+                Some(left)\n+            }\n         }\n     }\n }\n@@ -81,14 +92,15 @@ pub fn find_covering_node(root: SyntaxNodeRef, range: TextRange) -> SyntaxNodeRe\n     assert!(\n         is_subrange(root.range(), range),\n         \"node range: {:?}, target range: {:?}\",\n-        root.range(), range,\n+        root.range(),\n+        range,\n     );\n     let (left, right) = match (\n         find_leaf_at_offset(root, range.start()).right_biased(),\n-        find_leaf_at_offset(root, range.end()).left_biased()\n+        find_leaf_at_offset(root, range.end()).left_biased(),\n     ) {\n         (Some(l), Some(r)) => (l, r),\n-        _ => return root\n+        _ => return root,\n     };\n \n     common_ancestor(left, right)\n@@ -103,7 +115,7 @@ fn common_ancestor<'a>(n1: SyntaxNodeRef<'a>, n2: SyntaxNodeRef<'a>) -> SyntaxNo\n     panic!(\"Can't find common ancestor of {:?} and {:?}\", n1, n2)\n }\n \n-pub fn generate<T>(seed: Option<T>, step: impl Fn(&T) -> Option<T>) -> impl Iterator<Item=T> {\n+pub fn generate<T>(seed: Option<T>, step: impl Fn(&T) -> Option<T>) -> impl Iterator<Item = T> {\n     ::itertools::unfold(seed, move |slot| {\n         slot.take().map(|curr| {\n             *slot = step(&curr);"}, {"sha": "c021f464c3f84563281a1c2d9b114725e48fa28e", "filename": "crates/ra_syntax/src/algo/visit.rs", "status": "modified", "additions": 37, "deletions": 26, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_syntax%2Fsrc%2Falgo%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_syntax%2Fsrc%2Falgo%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Falgo%2Fvisit.rs?ref=61f3a438d3a729a6be941bca1ff4c6a97a33f221", "patch": "@@ -1,23 +1,31 @@\n-use std::marker::PhantomData;\n-use crate::{SyntaxNodeRef, AstNode};\n+use crate::{AstNode, SyntaxNodeRef};\n \n+use std::marker::PhantomData;\n \n-pub fn visitor<'a, T>() -> impl Visitor<'a, Output=T> {\n+pub fn visitor<'a, T>() -> impl Visitor<'a, Output = T> {\n     EmptyVisitor { ph: PhantomData }\n }\n \n-pub fn visitor_ctx<'a, T, C>(ctx: C) -> impl VisitorCtx<'a, Output=T, Ctx=C> {\n-    EmptyVisitorCtx { ph: PhantomData, ctx }\n+pub fn visitor_ctx<'a, T, C>(ctx: C) -> impl VisitorCtx<'a, Output = T, Ctx = C> {\n+    EmptyVisitorCtx {\n+        ph: PhantomData,\n+        ctx,\n+    }\n }\n \n pub trait Visitor<'a>: Sized {\n     type Output;\n     fn accept(self, node: SyntaxNodeRef<'a>) -> Option<Self::Output>;\n     fn visit<N, F>(self, f: F) -> Vis<Self, N, F>\n-        where N: AstNode<'a>,\n-              F: FnOnce(N) -> Self::Output,\n+    where\n+        N: AstNode<'a>,\n+        F: FnOnce(N) -> Self::Output,\n     {\n-        Vis { inner: self, f, ph: PhantomData }\n+        Vis {\n+            inner: self,\n+            f,\n+            ph: PhantomData,\n+        }\n     }\n }\n \n@@ -26,16 +34,21 @@ pub trait VisitorCtx<'a>: Sized {\n     type Ctx;\n     fn accept(self, node: SyntaxNodeRef<'a>) -> Result<Self::Output, Self::Ctx>;\n     fn visit<N, F>(self, f: F) -> VisCtx<Self, N, F>\n-        where N: AstNode<'a>,\n-              F: FnOnce(N, Self::Ctx) -> Self::Output,\n+    where\n+        N: AstNode<'a>,\n+        F: FnOnce(N, Self::Ctx) -> Self::Output,\n     {\n-        VisCtx { inner: self, f, ph: PhantomData }\n+        VisCtx {\n+            inner: self,\n+            f,\n+            ph: PhantomData,\n+        }\n     }\n }\n \n #[derive(Debug)]\n struct EmptyVisitor<T> {\n-    ph: PhantomData<fn() -> T>\n+    ph: PhantomData<fn() -> T>,\n }\n \n impl<'a, T> Visitor<'a> for EmptyVisitor<T> {\n@@ -69,10 +82,10 @@ pub struct Vis<V, N, F> {\n }\n \n impl<'a, V, N, F> Visitor<'a> for Vis<V, N, F>\n-    where\n-        V: Visitor<'a>,\n-        N: AstNode<'a>,\n-        F: FnOnce(N) -> <V as Visitor<'a>>::Output,\n+where\n+    V: Visitor<'a>,\n+    N: AstNode<'a>,\n+    F: FnOnce(N) -> <V as Visitor<'a>>::Output,\n {\n     type Output = <V as Visitor<'a>>::Output;\n \n@@ -90,21 +103,19 @@ pub struct VisCtx<V, N, F> {\n }\n \n impl<'a, V, N, F> VisitorCtx<'a> for VisCtx<V, N, F>\n-    where\n-        V: VisitorCtx<'a>,\n-        N: AstNode<'a>,\n-        F: FnOnce(N, <V as VisitorCtx<'a>>::Ctx) -> <V as VisitorCtx<'a>>::Output,\n+where\n+    V: VisitorCtx<'a>,\n+    N: AstNode<'a>,\n+    F: FnOnce(N, <V as VisitorCtx<'a>>::Ctx) -> <V as VisitorCtx<'a>>::Output,\n {\n     type Output = <V as VisitorCtx<'a>>::Output;\n     type Ctx = <V as VisitorCtx<'a>>::Ctx;\n \n     fn accept(self, node: SyntaxNodeRef<'a>) -> Result<Self::Output, Self::Ctx> {\n         let VisCtx { inner, f, .. } = self;\n-        inner.accept(node).or_else(|ctx|\n-            match N::cast(node) {\n-                None => Err(ctx),\n-                Some(node) => Ok(f(node, ctx))\n-            }\n-        )\n+        inner.accept(node).or_else(|ctx| match N::cast(node) {\n+            None => Err(ctx),\n+            Some(node) => Ok(f(node, ctx)),\n+        })\n     }\n }"}, {"sha": "9afa86401bf82e3394a0f7b11f245d77954e01ff", "filename": "crates/ra_syntax/src/algo/walk.rs", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_syntax%2Fsrc%2Falgo%2Fwalk.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_syntax%2Fsrc%2Falgo%2Fwalk.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Falgo%2Fwalk.rs?ref=61f3a438d3a729a6be941bca1ff4c6a97a33f221", "patch": "@@ -1,8 +1,4 @@\n-use crate::{\n-    SyntaxNodeRef,\n-    algo::generate,\n-};\n-\n+use crate::{algo::generate, SyntaxNodeRef};\n \n #[derive(Debug, Copy, Clone)]\n pub enum WalkEvent<'a> {"}, {"sha": "a15e0017692558112b4ae415ce8eb50689ce6606", "filename": "crates/ra_syntax/src/ast/generated.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs?ref=61f3a438d3a729a6be941bca1ff4c6a97a33f221", "patch": "@@ -1,6 +1,8 @@\n // This file is automatically generated based on the file `./generated.rs.tera` when `cargo gen-kinds` is run\n // Do not edit manually\n \n+#![cfg_attr(rustfmt, rustfmt_skip)]\n+\n use crate::{\n     ast,\n     SyntaxNodeRef, AstNode,"}, {"sha": "d2a281137e15f55435f7ca64c30748c858105e33", "filename": "crates/ra_syntax/src/ast/generated.rs.tera", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs.tera", "raw_url": "https://github.com/rust-lang/rust/raw/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs.tera", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs.tera?ref=61f3a438d3a729a6be941bca1ff4c6a97a33f221", "patch": "@@ -3,6 +3,8 @@ the below applies to the result of this template\n #}// This file is automatically generated based on the file `./generated.rs.tera` when `cargo gen-kinds` is run\n // Do not edit manually\n \n+#![cfg_attr(rustfmt, rustfmt_skip)]\n+\n use crate::{\n     ast,\n     SyntaxNodeRef, AstNode,"}, {"sha": "34958b6cb3b6b771bcb91c29a670c7126d1619fe", "filename": "crates/ra_syntax/src/ast/mod.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_syntax%2Fsrc%2Fast%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_syntax%2Fsrc%2Fast%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fmod.rs?ref=61f3a438d3a729a6be941bca1ff4c6a97a33f221", "patch": "@@ -4,15 +4,18 @@ use std::marker::PhantomData;\n \n use itertools::Itertools;\n \n+pub use self::generated::*;\n use crate::{\n-    SmolStr, SyntaxNodeRef, SyntaxKind::*,\n     yellow::{RefRoot, SyntaxNodeChildren},\n+    SmolStr,\n+    SyntaxKind::*,\n+    SyntaxNodeRef,\n };\n-pub use self::generated::*;\n \n pub trait AstNode<'a>: Clone + Copy + 'a {\n     fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self>\n-        where Self: Sized;\n+    where\n+        Self: Sized;\n     fn syntax(self) -> SyntaxNodeRef<'a>;\n }\n \n@@ -64,9 +67,7 @@ pub trait AttrsOwner<'a>: AstNode<'a> {\n \n impl<'a> FnDef<'a> {\n     pub fn has_atom_attr(&self, atom: &str) -> bool {\n-        self.attrs()\n-            .filter_map(|x| x.as_atom())\n-            .any(|x| x == atom)\n+        self.attrs().filter_map(|x| x.as_atom()).any(|x| x == atom)\n     }\n }\n \n@@ -135,7 +136,7 @@ pub enum CommentFlavor {\n     Line,\n     Doc,\n     ModuleDoc,\n-    Multiline\n+    Multiline,\n }\n \n impl CommentFlavor {\n@@ -145,7 +146,7 @@ impl CommentFlavor {\n             Line => \"//\",\n             Doc => \"///\",\n             ModuleDoc => \"//!\",\n-            Multiline => \"/*\"\n+            Multiline => \"/*\",\n         }\n     }\n }\n@@ -166,16 +167,14 @@ impl<'a> Whitespace<'a> {\n \n impl<'a> Name<'a> {\n     pub fn text(&self) -> SmolStr {\n-        let ident = self.syntax().first_child()\n-            .unwrap();\n+        let ident = self.syntax().first_child().unwrap();\n         ident.leaf_text().unwrap().clone()\n     }\n }\n \n impl<'a> NameRef<'a> {\n     pub fn text(&self) -> SmolStr {\n-        let ident = self.syntax().first_child()\n-            .unwrap();\n+        let ident = self.syntax().first_child().unwrap();\n         ident.leaf_text().unwrap().clone()\n     }\n }\n@@ -241,7 +240,6 @@ fn children<'a, P: AstNode<'a>, C: AstNode<'a>>(parent: P) -> AstChildren<'a, C>\n     AstChildren::new(parent.syntax())\n }\n \n-\n #[derive(Debug)]\n pub struct AstChildren<'a, N> {\n     inner: SyntaxNodeChildren<RefRoot<'a>>,"}, {"sha": "11f766d3356de04ca5daa96a8bbdcd5245bd29b3", "filename": "crates/ra_syntax/src/grammar/expressions/atom.rs", "status": "modified", "additions": 45, "deletions": 13, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_syntax%2Fsrc%2Fgrammar%2Fexpressions%2Fatom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_syntax%2Fsrc%2Fgrammar%2Fexpressions%2Fatom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fgrammar%2Fexpressions%2Fatom.rs?ref=61f3a438d3a729a6be941bca1ff4c6a97a33f221", "patch": "@@ -13,9 +13,18 @@ use super::*;\n //     let _ = b\"e\";\n //     let _ = br\"f\";\n // }\n-pub(crate) const LITERAL_FIRST: TokenSet =\n-    token_set![TRUE_KW, FALSE_KW, INT_NUMBER, FLOAT_NUMBER, BYTE, CHAR,\n-               STRING, RAW_STRING, BYTE_STRING, RAW_BYTE_STRING];\n+pub(crate) const LITERAL_FIRST: TokenSet = token_set![\n+    TRUE_KW,\n+    FALSE_KW,\n+    INT_NUMBER,\n+    FLOAT_NUMBER,\n+    BYTE,\n+    CHAR,\n+    STRING,\n+    RAW_STRING,\n+    BYTE_STRING,\n+    RAW_BYTE_STRING\n+];\n \n pub(crate) fn literal(p: &mut Parser) -> Option<CompletedMarker> {\n     if !p.at_ts(LITERAL_FIRST) {\n@@ -26,15 +35,31 @@ pub(crate) fn literal(p: &mut Parser) -> Option<CompletedMarker> {\n     Some(m.complete(p, LITERAL))\n }\n \n-pub(super) const ATOM_EXPR_FIRST: TokenSet =\n-    token_set_union![\n-        LITERAL_FIRST,\n-        token_set![L_CURLY, L_PAREN, L_BRACK, PIPE, MOVE_KW, IF_KW, WHILE_KW, MATCH_KW, UNSAFE_KW,\n-                   RETURN_KW, IDENT, SELF_KW, SUPER_KW, CRATE_KW, COLONCOLON, BREAK_KW, CONTINUE_KW, LIFETIME ],\n-    ];\n+pub(super) const ATOM_EXPR_FIRST: TokenSet = token_set_union![\n+    LITERAL_FIRST,\n+    token_set![\n+        L_CURLY,\n+        L_PAREN,\n+        L_BRACK,\n+        PIPE,\n+        MOVE_KW,\n+        IF_KW,\n+        WHILE_KW,\n+        MATCH_KW,\n+        UNSAFE_KW,\n+        RETURN_KW,\n+        IDENT,\n+        SELF_KW,\n+        SUPER_KW,\n+        CRATE_KW,\n+        COLONCOLON,\n+        BREAK_KW,\n+        CONTINUE_KW,\n+        LIFETIME\n+    ],\n+];\n \n-const EXPR_RECOVERY_SET: TokenSet =\n-    token_set![LET_KW];\n+const EXPR_RECOVERY_SET: TokenSet = token_set![LET_KW];\n \n pub(super) fn atom_expr(p: &mut Parser, r: Restrictions) -> Option<CompletedMarker> {\n     match literal(p) {\n@@ -80,7 +105,7 @@ pub(super) fn atom_expr(p: &mut Parser, r: Restrictions) -> Option<CompletedMark\n             let m = p.start();\n             p.bump();\n             block_expr(p, Some(m))\n-        },\n+        }\n         L_CURLY => block_expr(p, None),\n         RETURN_KW => return_expr(p),\n         CONTINUE_KW => continue_expr(p),\n@@ -119,7 +144,14 @@ fn tuple_expr(p: &mut Parser) -> CompletedMarker {\n         }\n     }\n     p.expect(R_PAREN);\n-    m.complete(p, if saw_expr && !saw_comma { PAREN_EXPR } else { TUPLE_EXPR })\n+    m.complete(\n+        p,\n+        if saw_expr && !saw_comma {\n+            PAREN_EXPR\n+        } else {\n+            TUPLE_EXPR\n+        },\n+    )\n }\n \n // test array_expr"}, {"sha": "60c8602f9f012fc320c591ef800ad2c75665687c", "filename": "crates/ra_syntax/src/grammar/expressions/mod.rs", "status": "modified", "additions": 29, "deletions": 24, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_syntax%2Fsrc%2Fgrammar%2Fexpressions%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_syntax%2Fsrc%2Fgrammar%2Fexpressions%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fgrammar%2Fexpressions%2Fmod.rs?ref=61f3a438d3a729a6be941bca1ff4c6a97a33f221", "patch": "@@ -1,23 +1,32 @@\n mod atom;\n \n-use super::*;\n-pub(super) use self::atom::{literal, LITERAL_FIRST};\n pub(crate) use self::atom::match_arm_list;\n+pub(super) use self::atom::{literal, LITERAL_FIRST};\n+use super::*;\n \n const EXPR_FIRST: TokenSet = LHS_FIRST;\n \n pub(super) fn expr(p: &mut Parser) -> BlockLike {\n-    let r = Restrictions { forbid_structs: false, prefer_stmt: false };\n+    let r = Restrictions {\n+        forbid_structs: false,\n+        prefer_stmt: false,\n+    };\n     expr_bp(p, r, 1)\n }\n \n pub(super) fn expr_stmt(p: &mut Parser) -> BlockLike {\n-    let r = Restrictions { forbid_structs: false, prefer_stmt: true };\n+    let r = Restrictions {\n+        forbid_structs: false,\n+        prefer_stmt: true,\n+    };\n     expr_bp(p, r, 1)\n }\n \n fn expr_no_struct(p: &mut Parser) {\n-    let r = Restrictions { forbid_structs: true, prefer_stmt: false };\n+    let r = Restrictions {\n+        forbid_structs: true,\n+        prefer_stmt: false,\n+    };\n     expr_bp(p, r, 1);\n }\n \n@@ -107,10 +116,8 @@ enum Op {\n fn current_op(p: &Parser) -> (u8, Op) {\n     if let Some(t) = p.next3() {\n         match t {\n-            (L_ANGLE, L_ANGLE, EQ) =>\n-                return (1, Op::Composite(SHLEQ, 3)),\n-            (R_ANGLE, R_ANGLE, EQ) =>\n-                return (1, Op::Composite(SHREQ, 3)),\n+            (L_ANGLE, L_ANGLE, EQ) => return (1, Op::Composite(SHLEQ, 3)),\n+            (R_ANGLE, R_ANGLE, EQ) => return (1, Op::Composite(SHREQ, 3)),\n             _ => (),\n         }\n     }\n@@ -201,11 +208,10 @@ fn is_block(kind: SyntaxKind) -> bool {\n     }\n }\n \n-const LHS_FIRST: TokenSet =\n-    token_set_union![\n-        token_set![AMP, STAR, EXCL, DOTDOT, MINUS],\n-        atom::ATOM_EXPR_FIRST,\n-    ];\n+const LHS_FIRST: TokenSet = token_set_union![\n+    token_set![AMP, STAR, EXCL, DOTDOT, MINUS],\n+    atom::ATOM_EXPR_FIRST,\n+];\n \n fn lhs(p: &mut Parser, r: Restrictions) -> Option<CompletedMarker> {\n     let m;\n@@ -265,11 +271,13 @@ fn postfix_expr(p: &mut Parser, r: Restrictions, mut lhs: CompletedMarker) -> Co\n             // }\n             L_PAREN if allow_calls => call_expr(p, lhs),\n             L_BRACK if allow_calls => index_expr(p, lhs),\n-            DOT if p.nth(1) == IDENT => if p.nth(2) == L_PAREN || p.nth(2) == COLONCOLON {\n-                method_call_expr(p, lhs)\n-            } else {\n-                field_expr(p, lhs)\n-            },\n+            DOT if p.nth(1) == IDENT => {\n+                if p.nth(2) == L_PAREN || p.nth(2) == COLONCOLON {\n+                    method_call_expr(p, lhs)\n+                } else {\n+                    field_expr(p, lhs)\n+                }\n+            }\n             DOT if p.nth(1) == INT_NUMBER => field_expr(p, lhs),\n             // test postfix_range\n             // fn foo() { let x = 1..; }\n@@ -318,10 +326,7 @@ fn index_expr(p: &mut Parser, lhs: CompletedMarker) -> CompletedMarker {\n //     y.bar::<T>(1, 2,);\n // }\n fn method_call_expr(p: &mut Parser, lhs: CompletedMarker) -> CompletedMarker {\n-    assert!(\n-        p.at(DOT) && p.nth(1) == IDENT\n-            && (p.nth(2) == L_PAREN || p.nth(2) == COLONCOLON)\n-    );\n+    assert!(p.at(DOT) && p.nth(1) == IDENT && (p.nth(2) == L_PAREN || p.nth(2) == COLONCOLON));\n     let m = lhs.precede(p);\n     p.bump();\n     name_ref(p);\n@@ -410,7 +415,7 @@ fn path_expr(p: &mut Parser, r: Restrictions) -> CompletedMarker {\n             items::macro_call_after_excl(p);\n             m.complete(p, MACRO_CALL)\n         }\n-        _ => m.complete(p, PATH_EXPR)\n+        _ => m.complete(p, PATH_EXPR),\n     }\n }\n "}, {"sha": "dc4742bce95604b470a12341fb58f2c49322365e", "filename": "crates/ra_syntax/src/grammar/items/mod.rs", "status": "modified", "additions": 24, "deletions": 21, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_syntax%2Fsrc%2Fgrammar%2Fitems%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_syntax%2Fsrc%2Fgrammar%2Fitems%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fgrammar%2Fitems%2Fmod.rs?ref=61f3a438d3a729a6be941bca1ff4c6a97a33f221", "patch": "@@ -1,16 +1,15 @@\n-\n mod consts;\n mod nominal;\n mod traits;\n mod use_item;\n \n-use super::*;\n pub(crate) use self::{\n-    expressions::{named_field_list, match_arm_list},\n+    expressions::{match_arm_list, named_field_list},\n     nominal::{enum_variant_list, named_field_def_list},\n-    traits::{trait_item_list, impl_item_list},\n+    traits::{impl_item_list, trait_item_list},\n     use_item::use_tree_list,\n };\n+use super::*;\n \n // test mod_contents\n // fn foo() {}\n@@ -26,12 +25,14 @@ pub(super) fn mod_contents(p: &mut Parser, stop_on_r_curly: bool) {\n }\n \n pub(super) enum ItemFlavor {\n-    Mod, Trait\n+    Mod,\n+    Trait,\n }\n \n-const ITEM_RECOVERY_SET: TokenSet =\n-    token_set![FN_KW, STRUCT_KW, ENUM_KW, IMPL_KW, TRAIT_KW, CONST_KW, STATIC_KW, LET_KW,\n-               MOD_KW, PUB_KW, CRATE_KW];\n+const ITEM_RECOVERY_SET: TokenSet = token_set![\n+    FN_KW, STRUCT_KW, ENUM_KW, IMPL_KW, TRAIT_KW, CONST_KW, STATIC_KW, LET_KW, MOD_KW, PUB_KW,\n+    CRATE_KW\n+];\n \n pub(super) fn item_or_macro(p: &mut Parser, stop_on_r_curly: bool, flavor: ItemFlavor) {\n     let m = p.start();\n@@ -153,10 +154,12 @@ pub(super) fn maybe_item(p: &mut Parser, flavor: ItemFlavor) -> MaybeItem {\n             traits::impl_item(p);\n             IMPL_ITEM\n         }\n-        _ => return if has_mods {\n-            MaybeItem::Modifiers\n-        } else {\n-            MaybeItem::None\n+        _ => {\n+            return if has_mods {\n+                MaybeItem::Modifiers\n+            } else {\n+                MaybeItem::None\n+            }\n         }\n     };\n \n@@ -194,7 +197,7 @@ fn items_without_modifiers(p: &mut Parser) -> Option<SyntaxKind> {\n             if p.at(SEMI) {\n                 p.err_and_bump(\n                     \"expected item, found `;`\\n\\\n-                     consider removing this semicolon\"\n+                     consider removing this semicolon\",\n                 );\n             }\n             STRUCT_DEF\n@@ -227,7 +230,9 @@ fn items_without_modifiers(p: &mut Parser) -> Option<SyntaxKind> {\n         }\n         // test extern_block\n         // extern {}\n-        EXTERN_KW if la == L_CURLY || ((la == STRING || la == RAW_STRING) && p.nth(2) == L_CURLY) => {\n+        EXTERN_KW\n+            if la == L_CURLY || ((la == STRING || la == RAW_STRING) && p.nth(2) == L_CURLY) =>\n+        {\n             abi(p);\n             extern_item_list(p);\n             EXTERN_BLOCK\n@@ -267,10 +272,8 @@ fn fn_def(p: &mut Parser, flavor: ItemFlavor) {\n \n     if p.at(L_PAREN) {\n         match flavor {\n-            ItemFlavor::Mod =>\n-                params::param_list(p),\n-            ItemFlavor::Trait =>\n-                params::param_list_opt_patterns(p),\n+            ItemFlavor::Mod => params::param_list(p),\n+            ItemFlavor::Trait => params::param_list_opt_patterns(p),\n         }\n     } else {\n         p.error(\"expected function arguments\");\n@@ -361,7 +364,7 @@ pub(super) fn macro_call_after_excl(p: &mut Parser) -> BlockLike {\n         _ => {\n             p.error(\"expected `{`, `[`, `(`\");\n             BlockLike::NotBlock\n-        },\n+        }\n     };\n \n     flavor\n@@ -385,9 +388,9 @@ pub(crate) fn token_tree(p: &mut Parser) {\n                 return;\n             }\n             R_PAREN | R_BRACK => p.err_and_bump(\"unmatched brace\"),\n-            _ => p.bump()\n+            _ => p.bump(),\n         }\n-    };\n+    }\n     p.expect(closing_paren_kind);\n     m.complete(p, TOKEN_TREE);\n }"}, {"sha": "31258c2537367446737feb50360fab6701bcbe64", "filename": "crates/ra_syntax/src/grammar/items/traits.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_syntax%2Fsrc%2Fgrammar%2Fitems%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_syntax%2Fsrc%2Fgrammar%2Fitems%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fgrammar%2Fitems%2Ftraits.rs?ref=61f3a438d3a729a6be941bca1ff4c6a97a33f221", "patch": "@@ -128,4 +128,3 @@ pub(crate) fn impl_type(p: &mut Parser) {\n     }\n     types::type_(p);\n }\n-"}, {"sha": "c875640730a62d9203d3299ccb8efe3cdde6f31f", "filename": "crates/ra_syntax/src/grammar/mod.rs", "status": "modified", "additions": 11, "deletions": 20, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_syntax%2Fsrc%2Fgrammar%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_syntax%2Fsrc%2Fgrammar%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fgrammar%2Fmod.rs?ref=61f3a438d3a729a6be941bca1ff4c6a97a33f221", "patch": "@@ -31,28 +31,18 @@ mod type_args;\n mod type_params;\n mod types;\n \n-use crate::{\n-    token_set::TokenSet,\n-    parser_api::{Marker, CompletedMarker, Parser},\n-    SyntaxKind::{self, *},\n-};\n pub(crate) use self::{\n-    expressions::{\n-        block,\n-    },\n+    expressions::block,\n     items::{\n-        enum_variant_list,\n-        extern_item_list,\n-        impl_item_list,\n-        match_arm_list,\n-        mod_item_list,\n-        named_field_def_list,\n-        named_field_list,\n-        token_tree,\n-        trait_item_list,\n-        use_tree_list,\n+        enum_variant_list, extern_item_list, impl_item_list, match_arm_list, mod_item_list,\n+        named_field_def_list, named_field_list, token_tree, trait_item_list, use_tree_list,\n     },\n };\n+use crate::{\n+    parser_api::{CompletedMarker, Marker, Parser},\n+    token_set::TokenSet,\n+    SyntaxKind::{self, *},\n+};\n \n pub(crate) fn root(p: &mut Parser) {\n     let m = p.start();\n@@ -61,15 +51,16 @@ pub(crate) fn root(p: &mut Parser) {\n     m.complete(p, ROOT);\n }\n \n-\n #[derive(Clone, Copy, PartialEq, Eq)]\n enum BlockLike {\n     Block,\n     NotBlock,\n }\n \n impl BlockLike {\n-    fn is_block(self) -> bool { self == BlockLike::Block }\n+    fn is_block(self) -> bool {\n+        self == BlockLike::Block\n+    }\n }\n \n fn opt_visibility(p: &mut Parser) {"}, {"sha": "b71a72ca3e941fd6b4056a56a1e351eb257c7eb4", "filename": "crates/ra_syntax/src/grammar/params.rs", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_syntax%2Fsrc%2Fgrammar%2Fparams.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_syntax%2Fsrc%2Fgrammar%2Fparams.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fgrammar%2Fparams.rs?ref=61f3a438d3a729a6be941bca1ff4c6a97a33f221", "patch": "@@ -61,12 +61,8 @@ fn list_(p: &mut Parser, flavor: Flavor) {\n     m.complete(p, PARAM_LIST);\n }\n \n-\n const VALUE_PARAMETER_FIRST: TokenSet =\n-    token_set_union![\n-        patterns::PATTERN_FIRST,\n-        types::TYPE_FIRST,\n-    ];\n+    token_set_union![patterns::PATTERN_FIRST, types::TYPE_FIRST,];\n \n fn value_parameter(p: &mut Parser, flavor: Flavor) {\n     let m = p.start();\n@@ -76,7 +72,7 @@ fn value_parameter(p: &mut Parser, flavor: Flavor) {\n             if p.at(COLON) || flavor.type_required() {\n                 types::ascription(p)\n             }\n-        },\n+        }\n         // test value_parameters_no_patterns\n         // type F = Box<Fn(a: i32, &b: &i32, &mut c: &i32, ())>;\n         Flavor::OptionalPattern => {\n@@ -86,13 +82,14 @@ fn value_parameter(p: &mut Parser, flavor: Flavor) {\n             let la3 = p.nth(3);\n             if la0 == IDENT && la1 == COLON\n                 || la0 == AMP && la1 == IDENT && la2 == COLON\n-                || la0 == AMP && la1 == MUT_KW && la2 == IDENT && la3 == COLON {\n+                || la0 == AMP && la1 == MUT_KW && la2 == IDENT && la3 == COLON\n+            {\n                 patterns::pattern(p);\n                 types::ascription(p);\n             } else {\n                 types::type_(p);\n             }\n-        },\n+        }\n     }\n     m.complete(p, PARAM);\n }"}, {"sha": "a35a339ccac0c9768e8e2526a0cda580d43b66e5", "filename": "crates/ra_syntax/src/grammar/paths.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_syntax%2Fsrc%2Fgrammar%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_syntax%2Fsrc%2Fgrammar%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fgrammar%2Fpaths.rs?ref=61f3a438d3a729a6be941bca1ff4c6a97a33f221", "patch": "@@ -97,7 +97,7 @@ fn opt_path_type_args(p: &mut Parser, mode: Mode) {\n             } else {\n                 type_args::opt_type_arg_list(p, false)\n             }\n-        },\n+        }\n         Mode::Expr => type_args::opt_type_arg_list(p, true),\n     }\n }"}, {"sha": "9d35dbb3d8da42d470cb4dc6c30c070c96d9705d", "filename": "crates/ra_syntax/src/grammar/patterns.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_syntax%2Fsrc%2Fgrammar%2Fpatterns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_syntax%2Fsrc%2Fgrammar%2Fpatterns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fgrammar%2Fpatterns.rs?ref=61f3a438d3a729a6be941bca1ff4c6a97a33f221", "patch": "@@ -1,11 +1,10 @@\n use super::*;\n \n-pub(super) const PATTERN_FIRST: TokenSet =\n-    token_set_union![\n-        token_set![REF_KW, MUT_KW, L_PAREN, L_BRACK, AMP, UNDERSCORE],\n-        expressions::LITERAL_FIRST,\n-        paths::PATH_FIRST,\n-    ];\n+pub(super) const PATTERN_FIRST: TokenSet = token_set_union![\n+    token_set![REF_KW, MUT_KW, L_PAREN, L_BRACK, AMP, UNDERSCORE],\n+    expressions::LITERAL_FIRST,\n+    paths::PATH_FIRST,\n+];\n \n pub(super) fn pattern(p: &mut Parser) {\n     pattern_r(p, PAT_RECOVERY_SET)\n@@ -29,12 +28,13 @@ pub(super) fn pattern_r(p: &mut Parser, recovery_set: TokenSet) {\n const PAT_RECOVERY_SET: TokenSet =\n     token_set![LET_KW, IF_KW, WHILE_KW, LOOP_KW, MATCH_KW, R_PAREN, COMMA];\n \n-\n fn atom_pat(p: &mut Parser, recovery_set: TokenSet) -> Option<CompletedMarker> {\n     let la0 = p.nth(0);\n     let la1 = p.nth(1);\n-    if la0 == REF_KW || la0 == MUT_KW\n-        || (la0 == IDENT && !(la1 == COLONCOLON || la1 == L_PAREN || la1 == L_CURLY)) {\n+    if la0 == REF_KW\n+        || la0 == MUT_KW\n+        || (la0 == IDENT && !(la1 == COLONCOLON || la1 == L_PAREN || la1 == L_CURLY))\n+    {\n         return Some(bind_pat(p, true));\n     }\n     if paths::is_path_start(p) {\n@@ -87,7 +87,7 @@ fn path_pat(p: &mut Parser) -> CompletedMarker {\n             field_pat_list(p);\n             STRUCT_PAT\n         }\n-        _ => PATH_PAT\n+        _ => PATH_PAT,\n     };\n     m.complete(p, kind)\n }\n@@ -195,7 +195,7 @@ fn pat_list(p: &mut Parser, ket: SyntaxKind) {\n                     break;\n                 }\n                 pattern(p)\n-            },\n+            }\n         }\n         if !p.at(ket) {\n             p.expect(COMMA);"}, {"sha": "79f5036b415d47173fda9ec49004b5b63c43b23d", "filename": "crates/ra_syntax/src/grammar/type_params.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_syntax%2Fsrc%2Fgrammar%2Ftype_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_syntax%2Fsrc%2Fgrammar%2Ftype_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fgrammar%2Ftype_params.rs?ref=61f3a438d3a729a6be941bca1ff4c6a97a33f221", "patch": "@@ -72,12 +72,8 @@ pub(super) fn bounds_without_colon(p: &mut Parser) {\n         p.eat(QUESTION);\n         match p.current() {\n             LIFETIME => p.bump(),\n-            FOR_KW => {\n-                types::for_type(p)\n-            }\n-            _ if paths::is_path_start(p) => {\n-                types::path_type(p)\n-            }\n+            FOR_KW => types::for_type(p),\n+            _ if paths::is_path_start(p) => types::path_type(p),\n             _ => break,\n         }\n         if has_paren {\n@@ -104,7 +100,7 @@ pub(super) fn opt_where_clause(p: &mut Parser) {\n     p.bump();\n     loop {\n         if !(paths::is_path_start(p) || p.current() == LIFETIME) {\n-            break\n+            break;\n         }\n         where_predicate(p);\n         if p.current() != L_CURLY && p.current() != SEMI {\n@@ -130,7 +126,6 @@ fn where_predicate(p: &mut Parser) {\n         } else {\n             p.error(\"expected colon\")\n         }\n-\n     }\n     m.complete(p, WHERE_PRED);\n }"}, {"sha": "f308aef894e9763085d07a0a589cabe1ba81f034", "filename": "crates/ra_syntax/src/grammar/types.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_syntax%2Fsrc%2Fgrammar%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_syntax%2Fsrc%2Fgrammar%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fgrammar%2Ftypes.rs?ref=61f3a438d3a729a6be941bca1ff4c6a97a33f221", "patch": "@@ -1,15 +1,14 @@\n use super::*;\n \n-pub(super) const TYPE_FIRST: TokenSet =\n-    token_set_union![\n-        token_set![\n-            L_PAREN, EXCL, STAR, L_BRACK, AMP, UNDERSCORE, FN_KW, UNSAFE_KW, EXTERN_KW, FOR_KW, IMPL_KW, DYN_KW, L_ANGLE,\n-        ],\n-        paths::PATH_FIRST,\n-    ];\n+pub(super) const TYPE_FIRST: TokenSet = token_set_union![\n+    token_set![\n+        L_PAREN, EXCL, STAR, L_BRACK, AMP, UNDERSCORE, FN_KW, UNSAFE_KW, EXTERN_KW, FOR_KW,\n+        IMPL_KW, DYN_KW, L_ANGLE,\n+    ],\n+    paths::PATH_FIRST,\n+];\n \n-const TYPE_RECOVERY_SET: TokenSet =\n-    token_set![R_PAREN, COMMA];\n+const TYPE_RECOVERY_SET: TokenSet = token_set![R_PAREN, COMMA];\n \n pub(super) fn type_(p: &mut Parser) {\n     match p.current() {\n@@ -200,7 +199,6 @@ pub(super) fn for_type(p: &mut Parser) {\n         FN_KW | UNSAFE_KW | EXTERN_KW => fn_pointer_type(p),\n         _ if paths::is_path_start(p) => path_type_(p, false),\n         _ => p.error(\"expected a path\"),\n-\n     }\n     m.complete(p, FOR_TYPE);\n }"}, {"sha": "f388da273fae80586a1e82b3468d2b994201754a", "filename": "crates/ra_syntax/src/lexer/mod.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_syntax%2Fsrc%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_syntax%2Fsrc%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Flexer%2Fmod.rs?ref=61f3a438d3a729a6be941bca1ff4c6a97a33f221", "patch": "@@ -58,12 +58,16 @@ fn next_token_inner(c: char, ptr: &mut Ptr) -> SyntaxKind {\n     }\n \n     match c {\n-        '#' => if scan_shebang(ptr) {\n-            return SHEBANG;\n-        },\n-        '/' => if let Some(kind) = scan_comment(ptr) {\n-            return kind;\n-        },\n+        '#' => {\n+            if scan_shebang(ptr) {\n+                return SHEBANG;\n+            }\n+        }\n+        '/' => {\n+            if let Some(kind) = scan_comment(ptr) {\n+                return kind;\n+            }\n+        }\n         _ => (),\n     }\n "}, {"sha": "fa79d8862a460b53ca79ebdd1a5036aacd02f0fb", "filename": "crates/ra_syntax/src/lexer/ptr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_syntax%2Fsrc%2Flexer%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_syntax%2Fsrc%2Flexer%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Flexer%2Fptr.rs?ref=61f3a438d3a729a6be941bca1ff4c6a97a33f221", "patch": "@@ -134,10 +134,10 @@ mod tests {\n     #[test]\n     fn test_nth_is_p() {\n         let ptr = Ptr::new(\"test\");\n-        assert!(ptr.nth_is_p(0,|c| c == 't'));\n-        assert!(!ptr.nth_is_p(1,|c| c == 't'));\n-        assert!(ptr.nth_is_p(3,|c| c == 't'));\n-        assert!(!ptr.nth_is_p(150,|c| c == 't'));\n+        assert!(ptr.nth_is_p(0, |c| c == 't'));\n+        assert!(!ptr.nth_is_p(1, |c| c == 't'));\n+        assert!(ptr.nth_is_p(3, |c| c == 't'));\n+        assert!(!ptr.nth_is_p(150, |c| c == 't'));\n     }\n \n     #[test]"}, {"sha": "5090feae649a57e6f3d3478fabd4f6b7466de2e1", "filename": "crates/ra_syntax/src/lexer/strings.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_syntax%2Fsrc%2Flexer%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_syntax%2Fsrc%2Flexer%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Flexer%2Fstrings.rs?ref=61f3a438d3a729a6be941bca1ff4c6a97a33f221", "patch": "@@ -71,7 +71,7 @@ pub(crate) fn scan_string(ptr: &mut Ptr) {\n             }\n             _ => {\n                 ptr.bump();\n-            },\n+            }\n         }\n     }\n }\n@@ -90,7 +90,7 @@ pub(crate) fn scan_raw_string(ptr: &mut Ptr) {\n     while let Some(c) = ptr.bump() {\n         if c == '\"' {\n             let mut hashes_left = hashes;\n-            while ptr.at('#') && hashes_left > 0{\n+            while ptr.at('#') && hashes_left > 0 {\n                 hashes_left -= 1;\n                 ptr.bump();\n             }"}, {"sha": "7a9718aad4d83986361ab2eaf408c49a6fcd79b4", "filename": "crates/ra_syntax/src/lib.rs", "status": "modified", "additions": 16, "deletions": 18, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_syntax%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_syntax%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Flib.rs?ref=61f3a438d3a729a6be941bca1ff4c6a97a33f221", "patch": "@@ -20,11 +20,11 @@\n #![allow(missing_docs)]\n //#![warn(unreachable_pub)] // rust-lang/rust#47816\n \n-extern crate itertools;\n-extern crate unicode_xid;\n extern crate drop_bomb;\n+extern crate itertools;\n extern crate parking_lot;\n extern crate rowan;\n+extern crate unicode_xid;\n \n #[cfg(test)]\n #[macro_use]\n@@ -35,33 +35,31 @@ pub mod ast;\n mod lexer;\n #[macro_use]\n mod token_set;\n-mod parser_api;\n mod grammar;\n+mod parser_api;\n mod parser_impl;\n mod reparsing;\n \n mod syntax_kinds;\n-mod yellow;\n+pub mod text_utils;\n /// Utilities for simple uses of the parser.\n pub mod utils;\n-pub mod text_utils;\n+mod yellow;\n \n pub use crate::{\n-    rowan::{SmolStr, TextRange, TextUnit},\n     ast::AstNode,\n     lexer::{tokenize, Token},\n-    syntax_kinds::SyntaxKind,\n-    yellow::{SyntaxNode, SyntaxNodeRef, OwnedRoot, RefRoot, TreeRoot, SyntaxError, Direction},\n     reparsing::AtomEdit,\n+    rowan::{SmolStr, TextRange, TextUnit},\n+    syntax_kinds::SyntaxKind,\n+    yellow::{Direction, OwnedRoot, RefRoot, SyntaxError, SyntaxNode, SyntaxNodeRef, TreeRoot},\n };\n \n-use crate::{\n-    yellow::{GreenNode},\n-};\n+use crate::yellow::GreenNode;\n \n #[derive(Clone, Debug, Hash, PartialEq, Eq)]\n pub struct File {\n-    root: SyntaxNode\n+    root: SyntaxNode,\n }\n \n impl File {\n@@ -74,21 +72,21 @@ impl File {\n     }\n     pub fn parse(text: &str) -> File {\n         let tokens = tokenize(&text);\n-        let (green, errors) = parser_impl::parse_with(\n-            yellow::GreenBuilder::new(),\n-            text, &tokens, grammar::root,\n-        );\n+        let (green, errors) =\n+            parser_impl::parse_with(yellow::GreenBuilder::new(), text, &tokens, grammar::root);\n         File::new(green, errors)\n     }\n     pub fn reparse(&self, edit: &AtomEdit) -> File {\n-        self.incremental_reparse(edit).unwrap_or_else(|| self.full_reparse(edit))\n+        self.incremental_reparse(edit)\n+            .unwrap_or_else(|| self.full_reparse(edit))\n     }\n     pub fn incremental_reparse(&self, edit: &AtomEdit) -> Option<File> {\n         reparsing::incremental_reparse(self.syntax(), edit, self.errors())\n             .map(|(green_node, errors)| File::new(green_node, errors))\n     }\n     fn full_reparse(&self, edit: &AtomEdit) -> File {\n-        let text = text_utils::replace_range(self.syntax().text().to_string(), edit.delete, &edit.insert);\n+        let text =\n+            text_utils::replace_range(self.syntax().text().to_string(), edit.delete, &edit.insert);\n         File::parse(&text)\n     }\n     pub fn ast(&self) -> ast::Root {"}, {"sha": "42046d36fde4b3548388c03abc4d7e868c14eae5", "filename": "crates/ra_syntax/src/parser_api.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_syntax%2Fsrc%2Fparser_api.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_syntax%2Fsrc%2Fparser_api.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fparser_api.rs?ref=61f3a438d3a729a6be941bca1ff4c6a97a33f221", "patch": "@@ -1,8 +1,8 @@\n use crate::{\n-    token_set::TokenSet,\n+    drop_bomb::DropBomb,\n     parser_impl::ParserImpl,\n+    token_set::TokenSet,\n     SyntaxKind::{self, ERROR},\n-    drop_bomb::DropBomb,\n };\n \n /// `Parser` struct provides the low-level API for\n@@ -116,9 +116,7 @@ impl<'t> Parser<'t> {\n \n     /// Create an error node and consume the next token.\n     pub(crate) fn err_recover(&mut self, message: &str, recovery: TokenSet) {\n-        if self.at(SyntaxKind::L_CURLY)\n-            || self.at(SyntaxKind::R_CURLY)\n-            || self.at_ts(recovery) {\n+        if self.at(SyntaxKind::L_CURLY) || self.at(SyntaxKind::R_CURLY) || self.at_ts(recovery) {\n             self.error(message);\n         } else {\n             let m = self.start();"}, {"sha": "79fa21389d1ffa3d1b2e73e0f541f81dd033b2de", "filename": "crates/ra_syntax/src/parser_impl/event.rs", "status": "modified", "additions": 32, "deletions": 22, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_syntax%2Fsrc%2Fparser_impl%2Fevent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_syntax%2Fsrc%2Fparser_impl%2Fevent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fparser_impl%2Fevent.rs?ref=61f3a438d3a729a6be941bca1ff4c6a97a33f221", "patch": "@@ -7,14 +7,14 @@\n //! tree builder: the parser produces a stream of events like\n //! `start node`, `finish node`, and `FileBuilder` converts\n //! this stream to a real tree.\n-use std::mem;\n use crate::{\n-    TextUnit, TextRange, SmolStr,\n     lexer::Token,\n     parser_impl::Sink,\n+    SmolStr,\n     SyntaxKind::{self, *},\n+    TextRange, TextUnit,\n };\n-\n+use std::mem;\n \n /// `Parser` produces a flat list of `Event`s.\n /// They are converted to a tree-structure in\n@@ -89,20 +89,28 @@ pub(super) struct EventProcessor<'a, S: Sink> {\n }\n \n impl<'a, S: Sink> EventProcessor<'a, S> {\n-    pub(super) fn new(sink: S, text: &'a str, tokens: &'a[Token], events: &'a mut [Event]) -> EventProcessor<'a, S> {\n+    pub(super) fn new(\n+        sink: S,\n+        text: &'a str,\n+        tokens: &'a [Token],\n+        events: &'a mut [Event],\n+    ) -> EventProcessor<'a, S> {\n         EventProcessor {\n             sink,\n             text_pos: 0.into(),\n             text,\n             token_pos: 0,\n             tokens,\n-            events\n+            events,\n         }\n     }\n \n     pub(super) fn process(mut self) -> S {\n         fn tombstone() -> Event {\n-            Event::Start { kind: TOMBSTONE, forward_parent: None }\n+            Event::Start {\n+                kind: TOMBSTONE,\n+                forward_parent: None,\n+            }\n         }\n         let mut forward_parents = Vec::new();\n \n@@ -112,7 +120,10 @@ impl<'a, S: Sink> EventProcessor<'a, S> {\n                     kind: TOMBSTONE, ..\n                 } => (),\n \n-                Event::Start { kind, forward_parent } => {\n+                Event::Start {\n+                    kind,\n+                    forward_parent,\n+                } => {\n                     forward_parents.push(kind);\n                     let mut idx = i;\n                     let mut fp = forward_parent;\n@@ -125,7 +136,7 @@ impl<'a, S: Sink> EventProcessor<'a, S> {\n                             } => {\n                                 forward_parents.push(kind);\n                                 forward_parent\n-                            },\n+                            }\n                             _ => unreachable!(),\n                         };\n                     }\n@@ -136,7 +147,7 @@ impl<'a, S: Sink> EventProcessor<'a, S> {\n                 Event::Finish => {\n                     let last = i == self.events.len() - 1;\n                     self.finish(last);\n-                },\n+                }\n                 Event::Token { kind, n_raw_tokens } => {\n                     self.eat_ws();\n                     let n_raw_tokens = n_raw_tokens as usize;\n@@ -162,19 +173,16 @@ impl<'a, S: Sink> EventProcessor<'a, S> {\n             .take_while(|it| it.kind.is_trivia())\n             .count();\n         let leading_trivias = &self.tokens[self.token_pos..self.token_pos + n_trivias];\n-        let mut trivia_end = self.text_pos + leading_trivias\n-            .iter()\n-            .map(|it| it.len)\n-            .sum::<TextUnit>();\n+        let mut trivia_end =\n+            self.text_pos + leading_trivias.iter().map(|it| it.len).sum::<TextUnit>();\n \n         let n_attached_trivias = {\n-            let leading_trivias = leading_trivias.iter().rev()\n-                .map(|it| {\n-                    let next_end = trivia_end - it.len;\n-                    let range = TextRange::from_to(next_end, trivia_end);\n-                    trivia_end = next_end;\n-                    (it.kind, &self.text[range])\n-                });\n+            let leading_trivias = leading_trivias.iter().rev().map(|it| {\n+                let next_end = trivia_end - it.len;\n+                let range = TextRange::from_to(next_end, trivia_end);\n+                trivia_end = next_end;\n+                (it.kind, &self.text[range])\n+            });\n             n_attached_trivias(kind, leading_trivias)\n         };\n         self.eat_n_trivias(n_trivias - n_attached_trivias);\n@@ -215,7 +223,10 @@ impl<'a, S: Sink> EventProcessor<'a, S> {\n     }\n }\n \n-fn n_attached_trivias<'a>(kind: SyntaxKind, trivias: impl Iterator<Item=(SyntaxKind, &'a str)>) -> usize {\n+fn n_attached_trivias<'a>(\n+    kind: SyntaxKind,\n+    trivias: impl Iterator<Item = (SyntaxKind, &'a str)>,\n+) -> usize {\n     match kind {\n         STRUCT_DEF | ENUM_DEF | FN_DEF | TRAIT_DEF | MODULE => {\n             let mut res = 0;\n@@ -236,5 +247,4 @@ fn n_attached_trivias<'a>(kind: SyntaxKind, trivias: impl Iterator<Item=(SyntaxK\n         }\n         _ => 0,\n     }\n-\n }"}, {"sha": "2b026d61e4c1c5dc17ddc37549c8632d4c53f82c", "filename": "crates/ra_syntax/src/parser_impl/mod.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_syntax%2Fsrc%2Fparser_impl%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_syntax%2Fsrc%2Fparser_impl%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fparser_impl%2Fmod.rs?ref=61f3a438d3a729a6be941bca1ff4c6a97a33f221", "patch": "@@ -4,13 +4,13 @@ mod input;\n use std::cell::Cell;\n \n use crate::{\n-    TextUnit, SmolStr,\n     lexer::Token,\n     parser_api::Parser,\n     parser_impl::{\n-        event::{EventProcessor, Event},\n+        event::{Event, EventProcessor},\n         input::{InputPosition, ParserInput},\n     },\n+    SmolStr, TextUnit,\n };\n \n use crate::SyntaxKind::{self, EOF, TOMBSTONE};\n@@ -86,7 +86,9 @@ impl<'t> ParserImpl<'t> {\n         let c2 = self.inp.kind(self.pos + 1);\n         let c3 = self.inp.kind(self.pos + 2);\n         if self.inp.start(self.pos + 1) == self.inp.start(self.pos) + self.inp.len(self.pos)\n-           && self.inp.start(self.pos + 2) == self.inp.start(self.pos + 1) + self.inp.len(self.pos + 1){\n+            && self.inp.start(self.pos + 2)\n+                == self.inp.start(self.pos + 1) + self.inp.len(self.pos + 1)\n+        {\n             Some((c1, c2, c3))\n         } else {\n             None\n@@ -138,10 +140,7 @@ impl<'t> ParserImpl<'t> {\n \n     fn do_bump(&mut self, kind: SyntaxKind, n_raw_tokens: u8) {\n         self.pos += u32::from(n_raw_tokens);\n-        self.event(Event::Token {\n-            kind,\n-            n_raw_tokens,\n-        });\n+        self.event(Event::Token { kind, n_raw_tokens });\n     }\n \n     pub(super) fn error(&mut self, msg: String) {"}, {"sha": "a0014e0162783b022e819674506b1a381098b711", "filename": "crates/ra_syntax/src/reparsing.rs", "status": "modified", "additions": 152, "deletions": 95, "changes": 247, "blob_url": "https://github.com/rust-lang/rust/blob/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_syntax%2Fsrc%2Freparsing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_syntax%2Fsrc%2Freparsing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Freparsing.rs?ref=61f3a438d3a729a6be941bca1ff4c6a97a33f221", "patch": "@@ -1,14 +1,11 @@\n use crate::algo;\n use crate::grammar;\n use crate::lexer::{tokenize, Token};\n-use crate::yellow::{self, GreenNode, SyntaxNodeRef, SyntaxError};\n-use crate::parser_impl;\n use crate::parser_api::Parser;\n-use crate::{\n-    TextUnit, TextRange,\n-    SyntaxKind::*,\n-};\n+use crate::parser_impl;\n use crate::text_utils::replace_range;\n+use crate::yellow::{self, GreenNode, SyntaxError, SyntaxNodeRef};\n+use crate::{SyntaxKind::*, TextRange, TextUnit};\n \n #[derive(Debug, Clone)]\n pub struct AtomEdit {\n@@ -18,7 +15,10 @@ pub struct AtomEdit {\n \n impl AtomEdit {\n     pub fn replace(range: TextRange, replace_with: String) -> AtomEdit {\n-        AtomEdit { delete: range, insert: replace_with }\n+        AtomEdit {\n+            delete: range,\n+            insert: replace_with,\n+        }\n     }\n \n     pub fn delete(range: TextRange) -> AtomEdit {\n@@ -48,12 +48,7 @@ fn reparse_leaf<'node>(\n ) -> Option<(SyntaxNodeRef<'node>, GreenNode, Vec<SyntaxError>)> {\n     let node = algo::find_covering_node(node, edit.delete);\n     match node.kind() {\n-        | WHITESPACE\n-        | COMMENT\n-        | DOC_COMMENT\n-        | IDENT\n-        | STRING\n-        | RAW_STRING => {\n+        WHITESPACE | COMMENT | DOC_COMMENT | IDENT | STRING | RAW_STRING => {\n             let text = get_text_after_edit(node, &edit);\n             let tokens = tokenize(&text);\n             let token = match tokens[..] {\n@@ -84,10 +79,7 @@ fn reparse_block<'node>(\n         return None;\n     }\n     let (green, new_errors) =\n-        parser_impl::parse_with(\n-            yellow::GreenBuilder::new(),\n-            &text, &tokens, reparser,\n-        );\n+        parser_impl::parse_with(yellow::GreenBuilder::new(), &text, &tokens, reparser);\n     Some((node, green, new_errors))\n }\n \n@@ -101,9 +93,7 @@ fn get_text_after_edit(node: SyntaxNodeRef, edit: &AtomEdit) -> String {\n \n fn is_contextual_kw(text: &str) -> bool {\n     match text {\n-        | \"auto\"\n-        | \"default\"\n-        | \"union\" => true,\n+        \"auto\" | \"default\" | \"union\" => true,\n         _ => false,\n     }\n }\n@@ -113,7 +103,8 @@ fn find_reparsable_node<'node>(\n     range: TextRange,\n ) -> Option<(SyntaxNodeRef<'node>, fn(&mut Parser))> {\n     let node = algo::find_covering_node(node, range);\n-    return node.ancestors()\n+    return node\n+        .ancestors()\n         .filter_map(|node| reparser(node).map(|r| (node, r)))\n         .next();\n \n@@ -145,17 +136,20 @@ fn find_reparsable_node<'node>(\n fn is_balanced(tokens: &[Token]) -> bool {\n     if tokens.len() == 0\n         || tokens.first().unwrap().kind != L_CURLY\n-        || tokens.last().unwrap().kind != R_CURLY {\n+        || tokens.last().unwrap().kind != R_CURLY\n+    {\n         return false;\n     }\n     let mut balance = 0usize;\n     for t in tokens.iter() {\n         match t.kind {\n             L_CURLY => balance += 1,\n-            R_CURLY => balance = match balance.checked_sub(1) {\n-                Some(b) => b,\n-                None => return false,\n-            },\n+            R_CURLY => {\n+                balance = match balance.checked_sub(1) {\n+                    Some(b) => b,\n+                    None => return false,\n+                }\n+            }\n             _ => (),\n         }\n     }\n@@ -191,32 +185,25 @@ fn merge_errors(\n #[cfg(test)]\n mod tests {\n     use super::{\n-        super::{\n-            File,\n-            test_utils::extract_range,\n-            text_utils::replace_range,\n-            utils::dump_tree,\n-        },\n-        reparse_leaf, reparse_block, AtomEdit, GreenNode, SyntaxError, SyntaxNodeRef,\n+        super::{test_utils::extract_range, text_utils::replace_range, utils::dump_tree, File},\n+        reparse_block, reparse_leaf, AtomEdit, GreenNode, SyntaxError, SyntaxNodeRef,\n     };\n \n-    fn do_check<F>(\n-        before: &str,\n-        replace_with: &str,\n-        reparser: F,\n-    ) where\n-        for<'a> F: Fn(\n-            SyntaxNodeRef<'a>,\n-            &AtomEdit,\n-        ) -> Option<(SyntaxNodeRef<'a>, GreenNode, Vec<SyntaxError>)>\n+    fn do_check<F>(before: &str, replace_with: &str, reparser: F)\n+    where\n+        for<'a> F: Fn(SyntaxNodeRef<'a>, &AtomEdit)\n+            -> Option<(SyntaxNodeRef<'a>, GreenNode, Vec<SyntaxError>)>,\n     {\n         let (range, before) = extract_range(before);\n         let after = replace_range(before.clone(), range, replace_with);\n \n         let fully_reparsed = File::parse(&after);\n         let incrementally_reparsed = {\n             let f = File::parse(&before);\n-            let edit = AtomEdit { delete: range, insert: replace_with.to_string() };\n+            let edit = AtomEdit {\n+                delete: range,\n+                insert: replace_with.to_string(),\n+            };\n             let (node, green, new_errors) =\n                 reparser(f.syntax(), &edit).expect(\"cannot incrementally reparse\");\n             let green_root = node.replace_with(green);\n@@ -232,113 +219,183 @@ mod tests {\n \n     #[test]\n     fn reparse_block_tests() {\n-        let do_check = |before, replace_to|\n-            do_check(before, replace_to, reparse_block);\n+        let do_check = |before, replace_to| do_check(before, replace_to, reparse_block);\n \n-        do_check(r\"\n+        do_check(\n+            r\"\n fn foo() {\n     let x = foo + <|>bar<|>\n }\n-\", \"baz\");\n-        do_check(r\"\n+\",\n+            \"baz\",\n+        );\n+        do_check(\n+            r\"\n fn foo() {\n     let x = foo<|> + bar<|>\n }\n-\", \"baz\");\n-        do_check(r\"\n+\",\n+            \"baz\",\n+        );\n+        do_check(\n+            r\"\n struct Foo {\n     f: foo<|><|>\n }\n-\", \",\\n    g: (),\");\n-        do_check(r\"\n+\",\n+            \",\\n    g: (),\",\n+        );\n+        do_check(\n+            r\"\n fn foo {\n     let;\n     1 + 1;\n     <|>92<|>;\n }\n-\", \"62\");\n-        do_check(r\"\n+\",\n+            \"62\",\n+        );\n+        do_check(\n+            r\"\n mod foo {\n     fn <|><|>\n }\n-\", \"bar\");\n-        do_check(r\"\n+\",\n+            \"bar\",\n+        );\n+        do_check(\n+            r\"\n trait Foo {\n     type <|>Foo<|>;\n }\n-\", \"Output\");\n-        do_check(r\"\n+\",\n+            \"Output\",\n+        );\n+        do_check(\n+            r\"\n impl IntoIterator<Item=i32> for Foo {\n     f<|><|>\n }\n-\", \"n next(\");\n-        do_check(r\"\n+\",\n+            \"n next(\",\n+        );\n+        do_check(\n+            r\"\n use a::b::{foo,<|>,bar<|>};\n-    \", \"baz\");\n-        do_check(r\"\n+    \",\n+            \"baz\",\n+        );\n+        do_check(\n+            r\"\n pub enum A {\n     Foo<|><|>\n }\n-\", \"\\nBar;\\n\");\n-        do_check(r\"\n+\",\n+            \"\\nBar;\\n\",\n+        );\n+        do_check(\n+            r\"\n foo!{a, b<|><|> d}\n-\", \", c[3]\");\n-        do_check(r\"\n+\",\n+            \", c[3]\",\n+        );\n+        do_check(\n+            r\"\n fn foo() {\n     vec![<|><|>]\n }\n-\", \"123\");\n-        do_check(r\"\n+\",\n+            \"123\",\n+        );\n+        do_check(\n+            r\"\n extern {\n     fn<|>;<|>\n }\n-\", \" exit(code: c_int)\");\n+\",\n+            \" exit(code: c_int)\",\n+        );\n     }\n \n     #[test]\n     fn reparse_leaf_tests() {\n-        let do_check = |before, replace_to|\n-            do_check(before, replace_to, reparse_leaf);\n+        let do_check = |before, replace_to| do_check(before, replace_to, reparse_leaf);\n \n-        do_check(r\"<|><|>\n+        do_check(\n+            r\"<|><|>\n fn foo() -> i32 { 1 }\n-\", \"\\n\\n\\n   \\n\");\n-        do_check(r\"\n+\",\n+            \"\\n\\n\\n   \\n\",\n+        );\n+        do_check(\n+            r\"\n fn foo() -> <|><|> {}\n-\", \"  \\n\");\n-        do_check(r\"\n+\",\n+            \"  \\n\",\n+        );\n+        do_check(\n+            r\"\n fn <|>foo<|>() -> i32 { 1 }\n-\", \"bar\");\n-        do_check(r\"\n+\",\n+            \"bar\",\n+        );\n+        do_check(\n+            r\"\n fn foo<|><|>foo() {  }\n-\", \"bar\");\n-        do_check(r\"\n+\",\n+            \"bar\",\n+        );\n+        do_check(\n+            r\"\n fn foo /* <|><|> */ () {}\n-\", \"some comment\");\n-        do_check(r\"\n+\",\n+            \"some comment\",\n+        );\n+        do_check(\n+            r\"\n fn baz <|><|> () {}\n-\", \"    \\t\\t\\n\\n\");\n-        do_check(r\"\n+\",\n+            \"    \\t\\t\\n\\n\",\n+        );\n+        do_check(\n+            r\"\n fn baz <|><|> () {}\n-\", \"    \\t\\t\\n\\n\");\n-        do_check(r\"\n+\",\n+            \"    \\t\\t\\n\\n\",\n+        );\n+        do_check(\n+            r\"\n /// foo <|><|>omment\n mod { }\n-\", \"c\");\n-        do_check(r#\"\n+\",\n+            \"c\",\n+        );\n+        do_check(\n+            r#\"\n fn -> &str { \"Hello<|><|>\" }\n-\"#, \", world\");\n-        do_check(r#\"\n+\"#,\n+            \", world\",\n+        );\n+        do_check(\n+            r#\"\n fn -> &str { // \"Hello<|><|>\"\n-\"#, \", world\");\n-        do_check(r##\"\n+\"#,\n+            \", world\",\n+        );\n+        do_check(\n+            r##\"\n fn -> &str { r#\"Hello<|><|>\"#\n-\"##, \", world\");\n-        do_check(r\"\n+\"##,\n+            \", world\",\n+        );\n+        do_check(\n+            r\"\n #[derive(<|>Copy<|>)]\n enum Foo {\n \n }\n-\", \"Clone\");\n+\",\n+            \"Clone\",\n+        );\n     }\n }"}, {"sha": "0fcd07cbfe072d09593807819589c9ee9f799f86", "filename": "crates/ra_syntax/src/syntax_kinds/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_syntax%2Fsrc%2Fsyntax_kinds%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_syntax%2Fsrc%2Fsyntax_kinds%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fsyntax_kinds%2Fmod.rs?ref=61f3a438d3a729a6be941bca1ff4c6a97a33f221", "patch": "@@ -1,7 +1,7 @@\n mod generated;\n \n-use std::fmt;\n use crate::SyntaxKind::*;\n+use std::fmt;\n \n pub use self::generated::SyntaxKind;\n "}, {"sha": "abda5ec393327abebeb151ca14a2725361bb3f11", "filename": "crates/ra_syntax/src/text_utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_syntax%2Fsrc%2Ftext_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_syntax%2Fsrc%2Ftext_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Ftext_utils.rs?ref=61f3a438d3a729a6be941bca1ff4c6a97a33f221", "patch": "@@ -23,4 +23,4 @@ pub fn replace_range(mut text: String, range: TextRange, replace_with: &str) ->\n     let end = u32::from(range.end()) as usize;\n     text.replace_range(start..end, replace_with);\n     text\n-}\n\\ No newline at end of file\n+}"}, {"sha": "27248ff324baaab2e4f01d0b634cd5fd70012a13", "filename": "crates/ra_syntax/src/utils.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_syntax%2Fsrc%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_syntax%2Fsrc%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Futils.rs?ref=61f3a438d3a729a6be941bca1ff4c6a97a33f221", "patch": "@@ -1,8 +1,8 @@\n-use std::fmt::Write;\n use crate::{\n     algo::walk::{walk, WalkEvent},\n-    SyntaxKind, File, SyntaxNodeRef\n+    File, SyntaxKind, SyntaxNodeRef,\n };\n+use std::fmt::Write;\n \n /// Parse a file and create a string representation of the resulting parse tree.\n pub fn dump_tree(syntax: SyntaxNodeRef) -> String {\n@@ -58,9 +58,7 @@ pub(crate) fn validate_block_structure(root: SyntaxNodeRef) {\n     let mut stack = Vec::new();\n     for node in root.descendants() {\n         match node.kind() {\n-            SyntaxKind::L_CURLY => {\n-                stack.push(node)\n-            }\n+            SyntaxKind::L_CURLY => stack.push(node),\n             SyntaxKind::R_CURLY => {\n                 if let Some(pair) = stack.pop() {\n                     assert_eq!("}, {"sha": "d6405340993af67632a1bf80aa60d7b820080812", "filename": "crates/ra_syntax/src/yellow/builder.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_syntax%2Fsrc%2Fyellow%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_syntax%2Fsrc%2Fyellow%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fyellow%2Fbuilder.rs?ref=61f3a438d3a729a6be941bca1ff4c6a97a33f221", "patch": "@@ -1,10 +1,9 @@\n-use rowan::GreenNodeBuilder;\n use crate::{\n-    TextUnit, SmolStr,\n     parser_impl::Sink,\n-    yellow::{GreenNode, SyntaxError, RaTypes},\n-    SyntaxKind,\n+    yellow::{GreenNode, RaTypes, SyntaxError},\n+    SmolStr, SyntaxKind, TextUnit,\n };\n+use rowan::GreenNodeBuilder;\n \n pub(crate) struct GreenBuilder {\n     errors: Vec<SyntaxError>,\n@@ -36,7 +35,10 @@ impl Sink for GreenBuilder {\n     }\n \n     fn error(&mut self, message: String, offset: TextUnit) {\n-        let error = SyntaxError { msg: message, offset };\n+        let error = SyntaxError {\n+            msg: message,\n+            offset,\n+        };\n         self.errors.push(error)\n     }\n "}, {"sha": "b5c9da81352a295f0c8f66ae7736848f4df07a7a", "filename": "crates/ra_syntax/src/yellow/mod.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_syntax%2Fsrc%2Fyellow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_syntax%2Fsrc%2Fyellow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fyellow%2Fmod.rs?ref=61f3a438d3a729a6be941bca1ff4c6a97a33f221", "patch": "@@ -1,16 +1,16 @@\n mod builder;\n mod syntax_text;\n \n+use self::syntax_text::SyntaxText;\n+use crate::{SmolStr, SyntaxKind, TextRange, TextUnit};\n+use rowan::Types;\n use std::{\n     fmt,\n     hash::{Hash, Hasher},\n };\n-use rowan::Types;\n-use crate::{SyntaxKind, TextUnit, TextRange, SmolStr};\n-use self::syntax_text::SyntaxText;\n \n-pub use rowan::{TreeRoot};\n pub(crate) use self::builder::GreenBuilder;\n+pub use rowan::TreeRoot;\n \n #[derive(Debug, Clone, Copy)]\n pub enum RaTypes {}\n@@ -31,9 +31,7 @@ pub struct SyntaxError {\n }\n \n #[derive(Clone, Copy)]\n-pub struct SyntaxNode<R: TreeRoot<RaTypes> = OwnedRoot>(\n-    ::rowan::SyntaxNode<RaTypes, R>,\n-);\n+pub struct SyntaxNode<R: TreeRoot<RaTypes> = OwnedRoot>(::rowan::SyntaxNode<RaTypes, R>);\n pub type SyntaxNodeRef<'a> = SyntaxNode<RefRoot<'a>>;\n \n impl<R1, R2> PartialEq<SyntaxNode<R1>> for SyntaxNode<R2>\n@@ -69,16 +67,16 @@ impl<'a> SyntaxNodeRef<'a> {\n     pub fn leaf_text(self) -> Option<&'a SmolStr> {\n         self.0.leaf_text()\n     }\n-    pub fn ancestors(self) -> impl Iterator<Item=SyntaxNodeRef<'a>> {\n+    pub fn ancestors(self) -> impl Iterator<Item = SyntaxNodeRef<'a>> {\n         crate::algo::generate(Some(self), |&node| node.parent())\n     }\n-    pub fn descendants(self) -> impl Iterator<Item=SyntaxNodeRef<'a>> {\n+    pub fn descendants(self) -> impl Iterator<Item = SyntaxNodeRef<'a>> {\n         crate::algo::walk::walk(self).filter_map(|event| match event {\n             crate::algo::walk::WalkEvent::Enter(node) => Some(node),\n             crate::algo::walk::WalkEvent::Exit(_) => None,\n         })\n     }\n-    pub fn siblings(self, direction: Direction) -> impl Iterator<Item=SyntaxNodeRef<'a>> {\n+    pub fn siblings(self, direction: Direction) -> impl Iterator<Item = SyntaxNodeRef<'a>> {\n         crate::algo::generate(Some(self), move |&node| match direction {\n             Direction::Next => node.next_sibling(),\n             Direction::Prev => node.prev_sibling(),\n@@ -142,9 +140,7 @@ impl<R: TreeRoot<RaTypes>> fmt::Debug for SyntaxNode<R> {\n }\n \n #[derive(Debug)]\n-pub struct SyntaxNodeChildren<R: TreeRoot<RaTypes>>(\n-    ::rowan::SyntaxNodeChildren<RaTypes, R>\n-);\n+pub struct SyntaxNodeChildren<R: TreeRoot<RaTypes>>(::rowan::SyntaxNodeChildren<RaTypes, R>);\n \n impl<R: TreeRoot<RaTypes>> Iterator for SyntaxNodeChildren<R> {\n     type Item = SyntaxNode<R>;\n@@ -154,7 +150,6 @@ impl<R: TreeRoot<RaTypes>> Iterator for SyntaxNodeChildren<R> {\n     }\n }\n \n-\n fn has_short_text(kind: SyntaxKind) -> bool {\n     use crate::SyntaxKind::*;\n     match kind {"}, {"sha": "5395ca90b926a378018bf04d4cdfea8b511d0372", "filename": "crates/ra_syntax/src/yellow/syntax_text.rs", "status": "modified", "additions": 17, "deletions": 19, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_syntax%2Fsrc%2Fyellow%2Fsyntax_text.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_syntax%2Fsrc%2Fyellow%2Fsyntax_text.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fyellow%2Fsyntax_text.rs?ref=61f3a438d3a729a6be941bca1ff4c6a97a33f221", "patch": "@@ -1,10 +1,8 @@\n-use std::{\n-    fmt, ops,\n-};\n+use std::{fmt, ops};\n \n use crate::{\n+    text_utils::{contains_offset_nonstrict, intersect},\n     SyntaxNodeRef, TextRange, TextUnit,\n-    text_utils::{intersect, contains_offset_nonstrict},\n };\n \n #[derive(Clone)]\n@@ -17,19 +15,17 @@ impl<'a> SyntaxText<'a> {\n     pub(crate) fn new(node: SyntaxNodeRef<'a>) -> SyntaxText<'a> {\n         SyntaxText {\n             node,\n-            range: node.range()\n+            range: node.range(),\n         }\n     }\n-    pub fn chunks(&self) -> impl Iterator<Item=&'a str> {\n+    pub fn chunks(&self) -> impl Iterator<Item = &'a str> {\n         let range = self.range;\n-        self.node\n-            .descendants()\n-            .filter_map(move |node| {\n-                let text = node.leaf_text()?;\n-                let range = intersect(range, node.range())?;\n-                let range = range - node.range().start();\n-                Some(&text[range])\n-            })\n+        self.node.descendants().filter_map(move |node| {\n+            let text = node.leaf_text()?;\n+            let range = intersect(range, node.range())?;\n+            let range = range - node.range().start();\n+            Some(&text[range])\n+        })\n     }\n     pub fn push_to(&self, buf: &mut String) {\n         self.chunks().for_each(|it| buf.push_str(it));\n@@ -55,11 +51,13 @@ impl<'a> SyntaxText<'a> {\n         self.range.len()\n     }\n     pub fn slice(&self, range: impl SyntaxTextSlice) -> SyntaxText<'a> {\n-        let range = range.restrict(self.range)\n-            .unwrap_or_else(|| {\n-                panic!(\"invalid slice, range: {:?}, slice: {:?}\", self.range, range)\n-            });\n-        SyntaxText { node: self.node, range }\n+        let range = range.restrict(self.range).unwrap_or_else(|| {\n+            panic!(\"invalid slice, range: {:?}, slice: {:?}\", self.range, range)\n+        });\n+        SyntaxText {\n+            node: self.node,\n+            range,\n+        }\n     }\n     pub fn char_at(&self, offset: TextUnit) -> Option<char> {\n         let mut start: TextUnit = 0.into();"}, {"sha": "9d1ded093b898f7c734debb000f31c60a05bee03", "filename": "crates/ra_syntax/tests/test.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_syntax%2Ftests%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Fra_syntax%2Ftests%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Ftests%2Ftest.rs?ref=61f3a438d3a729a6be941bca1ff4c6a97a33f221", "patch": "@@ -4,14 +4,14 @@ extern crate test_utils;\n extern crate walkdir;\n \n use std::{\n+    fmt::Write,\n     fs,\n     path::{Path, PathBuf},\n-    fmt::Write,\n };\n \n use ra_syntax::{\n+    utils::{check_fuzz_invariants, dump_tree},\n     File,\n-    utils::{dump_tree, check_fuzz_invariants},\n };\n \n #[test]\n@@ -37,7 +37,6 @@ fn parser_fuzz_tests() {\n     }\n }\n \n-\n /// Read file and normalize newlines.\n ///\n /// `rustc` seems to always normalize `\\r\\n` newlines to `\\n`:\n@@ -54,8 +53,8 @@ fn read_text(path: &Path) -> String {\n }\n \n pub fn dir_tests<F>(paths: &[&str], f: F)\n-    where\n-        F: Fn(&str) -> String,\n+where\n+    F: Fn(&str) -> String,\n {\n     for (path, input_code) in collect_tests(paths) {\n         let parse_tree = f(&input_code);"}, {"sha": "dbe2997eba84952021608412d0b99ac434c1682c", "filename": "crates/test_utils/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Ftest_utils%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Ftest_utils%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftest_utils%2Fsrc%2Flib.rs?ref=61f3a438d3a729a6be941bca1ff4c6a97a33f221", "patch": "@@ -2,9 +2,9 @@ extern crate difference;\n extern crate itertools;\n extern crate text_unit;\n \n-use std::fmt;\n use itertools::Itertools;\n-use text_unit::{TextUnit, TextRange};\n+use std::fmt;\n+use text_unit::{TextRange, TextUnit};\n \n pub use self::difference::Changeset as __Changeset;\n "}, {"sha": "5d5d372bb8562542a008269b7e5cf75009d23907", "filename": "crates/tools/src/lib.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Ftools%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Ftools%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftools%2Fsrc%2Flib.rs?ref=61f3a438d3a729a6be941bca1ff4c6a97a33f221", "patch": "@@ -1,17 +1,17 @@\n extern crate itertools;\n #[macro_use]\n extern crate failure;\n+extern crate heck;\n extern crate ron;\n extern crate tera;\n-extern crate heck;\n \n+use heck::{CamelCase, ShoutySnakeCase, SnakeCase};\n+use itertools::Itertools;\n use std::{\n     collections::HashMap,\n     fs,\n     path::{Path, PathBuf},\n };\n-use itertools::Itertools;\n-use heck::{CamelCase, ShoutySnakeCase, SnakeCase};\n \n pub type Result<T> = ::std::result::Result<T, failure::Error>;\n \n@@ -61,7 +61,6 @@ pub fn collect_tests(s: &str) -> Vec<(usize, Test)> {\n     res\n }\n \n-\n pub fn update(path: &Path, contents: &str, verify: bool) -> Result<()> {\n     match fs::read_to_string(path) {\n         Ok(ref old_contents) if old_contents == contents => {\n@@ -116,5 +115,8 @@ pub fn render_template(template: &Path) -> Result<String> {\n }\n \n pub fn project_root() -> PathBuf {\n-    Path::new(&std::env::var(\"CARGO_MANIFEST_DIR\").unwrap()).parent().unwrap().to_path_buf()\n+    Path::new(&std::env::var(\"CARGO_MANIFEST_DIR\").unwrap())\n+        .parent()\n+        .unwrap()\n+        .to_path_buf()\n }"}, {"sha": "b662d78df817e28a51175c52e854b4c0950d04be", "filename": "crates/tools/src/main.rs", "status": "modified", "additions": 33, "deletions": 12, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Ftools%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Ftools%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftools%2Fsrc%2Fmain.rs?ref=61f3a438d3a729a6be941bca1ff4c6a97a33f221", "patch": "@@ -11,7 +11,10 @@ use std::{\n     path::{Path, PathBuf},\n     process::Command,\n };\n-use tools::{AST, AST_TEMPLATE, Result, SYNTAX_KINDS, SYNTAX_KINDS_TEMPLATE, Test, collect_tests, render_template, update, project_root};\n+use tools::{\n+    collect_tests, project_root, render_template, update, Result, Test, AST, AST_TEMPLATE,\n+    SYNTAX_KINDS, SYNTAX_KINDS_TEMPLATE,\n+};\n \n const GRAMMAR_DIR: &str = \"./crates/ra_syntax/src/grammar\";\n const INLINE_TESTS_DIR: &str = \"./crates/ra_syntax/tests/data/parser/inline\";\n@@ -40,18 +43,23 @@ fn main() -> Result<()> {\n fn run_gen_command(name: &str, verify: bool) -> Result<()> {\n     match name {\n         \"gen-kinds\" => {\n-            update(&project_root().join(SYNTAX_KINDS), &render_template(&project_root().join(SYNTAX_KINDS_TEMPLATE))?, verify)?;\n-            update(&project_root().join(AST), &render_template(&project_root().join(AST_TEMPLATE))?, verify)?;\n-        },\n-        \"gen-tests\" => {\n-            gen_tests(verify)?\n-        },\n+            update(\n+                &project_root().join(SYNTAX_KINDS),\n+                &render_template(&project_root().join(SYNTAX_KINDS_TEMPLATE))?,\n+                verify,\n+            )?;\n+            update(\n+                &project_root().join(AST),\n+                &render_template(&project_root().join(AST_TEMPLATE))?,\n+                verify,\n+            )?;\n+        }\n+        \"gen-tests\" => gen_tests(verify)?,\n         _ => unreachable!(),\n     }\n     Ok(())\n }\n \n-\n fn gen_tests(verify: bool) -> Result<()> {\n     let tests = tests_from_dir(Path::new(GRAMMAR_DIR))?;\n \n@@ -133,19 +141,32 @@ fn install_code_extension() -> Result<()> {\n     } else {\n         run(r\"npm install\", \"./editors/code\")?;\n     }\n-    run(r\"node ./node_modules/vsce/out/vsce package\", \"./editors/code\")?;\n+    run(\n+        r\"node ./node_modules/vsce/out/vsce package\",\n+        \"./editors/code\",\n+    )?;\n     if cfg!(windows) {\n-        run(r\"cmd.exe /c code.cmd --install-extension ./ra-lsp-0.0.1.vsix\", \"./editors/code\")?;\n+        run(\n+            r\"cmd.exe /c code.cmd --install-extension ./ra-lsp-0.0.1.vsix\",\n+            \"./editors/code\",\n+        )?;\n     } else {\n-        run(r\"code --install-extension ./ra-lsp-0.0.1.vsix\", \"./editors/code\")?;\n+        run(\n+            r\"code --install-extension ./ra-lsp-0.0.1.vsix\",\n+            \"./editors/code\",\n+        )?;\n     }\n     Ok(())\n }\n \n fn run(cmdline: &'static str, dir: &str) -> Result<()> {\n     eprintln!(\"\\nwill run: {}\", cmdline);\n     let manifest_dir = env!(\"CARGO_MANIFEST_DIR\");\n-    let project_dir = Path::new(manifest_dir).ancestors().nth(2).unwrap().join(dir);\n+    let project_dir = Path::new(manifest_dir)\n+        .ancestors()\n+        .nth(2)\n+        .unwrap()\n+        .join(dir);\n     let mut args = cmdline.split_whitespace();\n     let exec = args.next().unwrap();\n     let status = Command::new(exec)"}, {"sha": "16899bb5f434d83092bc5d36847e920365949b41", "filename": "crates/tools/tests/cli.rs", "status": "modified", "additions": 13, "deletions": 3, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Ftools%2Ftests%2Fcli.rs", "raw_url": "https://github.com/rust-lang/rust/raw/61f3a438d3a729a6be941bca1ff4c6a97a33f221/crates%2Ftools%2Ftests%2Fcli.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Ftools%2Ftests%2Fcli.rs?ref=61f3a438d3a729a6be941bca1ff4c6a97a33f221", "patch": "@@ -1,13 +1,23 @@\n extern crate tools;\n \n-use tools::{AST, AST_TEMPLATE, SYNTAX_KINDS, SYNTAX_KINDS_TEMPLATE, render_template, update, project_root};\n+use tools::{\n+    project_root, render_template, update, AST, AST_TEMPLATE, SYNTAX_KINDS, SYNTAX_KINDS_TEMPLATE,\n+};\n \n #[test]\n fn verify_template_generation() {\n-    if let Err(error) = update(&project_root().join(SYNTAX_KINDS), &render_template(&project_root().join(SYNTAX_KINDS_TEMPLATE)).unwrap(), true) {\n+    if let Err(error) = update(\n+        &project_root().join(SYNTAX_KINDS),\n+        &render_template(&project_root().join(SYNTAX_KINDS_TEMPLATE)).unwrap(),\n+        true,\n+    ) {\n         panic!(\"{}. Please update it by running `cargo gen-kinds`\", error);\n     }\n-    if let Err(error) = update(&project_root().join(AST), &render_template(&project_root().join(AST_TEMPLATE)).unwrap(), true) {\n+    if let Err(error) = update(\n+        &project_root().join(AST),\n+        &render_template(&project_root().join(AST_TEMPLATE)).unwrap(),\n+        true,\n+    ) {\n         panic!(\"{}. Please update it by running `cargo gen-kinds`\", error);\n     }\n }"}]}