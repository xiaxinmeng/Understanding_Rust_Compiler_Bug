{"sha": "182248a466468a7599f21b414904c12daeb8d827", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE4MjI0OGE0NjY0NjhhNzU5OWYyMWI0MTQ5MDRjMTJkYWViOGQ4Mjc=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-07-06T00:37:54Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-07-06T00:37:54Z"}, "message": "Rollup merge of #62245 - RalfJung:miri-extra-fn, r=eddyb,zackmdavis\n\nMiri engine: support extra function (pointer) values\n\nWe want to add basic support for `dlsym` in Miri (needed to run the latest version of `getrandom`). For that to work, `dlsym` needs to return *something* that can be stored in a function pointer and later called.\n\nSo we add a new `ExtraFnVal` type to the `Machine` trait, and enable Miri's memory to associate allocation IDs with such values, so that `create_fn_alloc` and `get_fn` can work on *both* `Instance` (this is used for \"normal\" function pointers) and `ExtraFnVal`.\n\nCc @oli-obk", "tree": {"sha": "1d6674b83e7609436d834f9709451e8172320f78", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1d6674b83e7609436d834f9709451e8172320f78"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/182248a466468a7599f21b414904c12daeb8d827", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdH+1jCRBK7hj4Ov3rIwAAdHIIABGUU4zY0kILejjud+yuB+NG\nMPN22FEr/NWNV0RzhzuZ09EXzue3aL7fkwDJzeel5/lpW0vxp7de+H/92b0B+9TC\nW2NhPqnqmObj37O4hd83ziOqNZ4smmfd4rcX/dJdb2Iw4z5RoRvxNjHwhNCiZ8Tt\n2eRv6xgMzM+7K7vk3G+ahXs0V706hWvTjGCXueLuK3S/g7HuG3oqSnb4Q/Zgmv59\ndPi2HGoMHMZDlM4OzTOMPyyqUn7T3txicDSVkxNTbmMui6LyU8SveSfNU7yCyl5q\nt7+EkTaX7oFW3Z5dsyZBahNGNw2NjO1Awr2QvrtDuWjTrPMWU9Xm8PMpzT31gDc=\n=4XuL\n-----END PGP SIGNATURE-----\n", "payload": "tree 1d6674b83e7609436d834f9709451e8172320f78\nparent a8f8c7c78c32111dc2dd906060e53326e7d52f1b\nparent ceb496cf59ea28d98146cdcfc072cede4f7c6585\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1562373474 +0200\ncommitter GitHub <noreply@github.com> 1562373474 +0200\n\nRollup merge of #62245 - RalfJung:miri-extra-fn, r=eddyb,zackmdavis\n\nMiri engine: support extra function (pointer) values\n\nWe want to add basic support for `dlsym` in Miri (needed to run the latest version of `getrandom`). For that to work, `dlsym` needs to return *something* that can be stored in a function pointer and later called.\n\nSo we add a new `ExtraFnVal` type to the `Machine` trait, and enable Miri's memory to associate allocation IDs with such values, so that `create_fn_alloc` and `get_fn` can work on *both* `Instance` (this is used for \"normal\" function pointers) and `ExtraFnVal`.\n\nCc @oli-obk\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/182248a466468a7599f21b414904c12daeb8d827", "html_url": "https://github.com/rust-lang/rust/commit/182248a466468a7599f21b414904c12daeb8d827", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/182248a466468a7599f21b414904c12daeb8d827/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a8f8c7c78c32111dc2dd906060e53326e7d52f1b", "url": "https://api.github.com/repos/rust-lang/rust/commits/a8f8c7c78c32111dc2dd906060e53326e7d52f1b", "html_url": "https://github.com/rust-lang/rust/commit/a8f8c7c78c32111dc2dd906060e53326e7d52f1b"}, {"sha": "ceb496cf59ea28d98146cdcfc072cede4f7c6585", "url": "https://api.github.com/repos/rust-lang/rust/commits/ceb496cf59ea28d98146cdcfc072cede4f7c6585", "html_url": "https://github.com/rust-lang/rust/commit/ceb496cf59ea28d98146cdcfc072cede4f7c6585"}], "stats": {"total": 375, "additions": 253, "deletions": 122}, "files": [{"sha": "49a42955d8dd6032bfa4b21e4ffcdd5eaa20b393", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/182248a466468a7599f21b414904c12daeb8d827/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/182248a466468a7599f21b414904c12daeb8d827/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=182248a466468a7599f21b414904c12daeb8d827", "patch": "@@ -316,6 +316,7 @@ impl interpret::MayLeak for ! {\n impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir, 'tcx> {\n     type MemoryKinds = !;\n     type PointerTag = ();\n+    type ExtraFnVal = !;\n \n     type FrameExtra = ();\n     type MemoryExtra = ();\n@@ -370,6 +371,16 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         }))\n     }\n \n+    fn call_extra_fn(\n+        _ecx: &mut InterpCx<'mir, 'tcx, Self>,\n+        fn_val: !,\n+        _args: &[OpTy<'tcx>],\n+        _dest: Option<PlaceTy<'tcx>>,\n+        _ret: Option<mir::BasicBlock>,\n+    ) -> InterpResult<'tcx> {\n+        match fn_val {}\n+    }\n+\n     fn call_intrinsic(\n         ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         instance: ty::Instance<'tcx>,"}, {"sha": "3ef525979f8c9ecce2f61480797957cc8557d081", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/182248a466468a7599f21b414904c12daeb8d827/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/182248a466468a7599f21b414904c12daeb8d827/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=182248a466468a7599f21b414904c12daeb8d827", "patch": "@@ -11,7 +11,7 @@ use rustc::mir::interpret::{\n };\n use rustc::mir::CastKind;\n \n-use super::{InterpCx, Machine, PlaceTy, OpTy, Immediate};\n+use super::{InterpCx, Machine, PlaceTy, OpTy, Immediate, FnVal};\n \n impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     fn type_is_fat_ptr(&self, ty: Ty<'tcx>) -> bool {\n@@ -86,7 +86,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                             def_id,\n                             substs,\n                         ).ok_or_else(|| InterpError::TooGeneric.into());\n-                        let fn_ptr = self.memory.create_fn_alloc(instance?);\n+                        let fn_ptr = self.memory.create_fn_alloc(FnVal::Instance(instance?));\n                         self.write_scalar(Scalar::Ptr(fn_ptr.into()), dest)?;\n                     }\n                     _ => bug!(\"reify fn pointer on {:?}\", src.layout.ty),\n@@ -115,7 +115,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                             substs,\n                             ty::ClosureKind::FnOnce,\n                         );\n-                        let fn_ptr = self.memory.create_fn_alloc(instance);\n+                        let fn_ptr = self.memory.create_fn_alloc(FnVal::Instance(instance));\n                         let val = Immediate::Scalar(Scalar::Ptr(fn_ptr.into()).into());\n                         self.write_immediate(val, dest)?;\n                     }"}, {"sha": "922b5e0676a194c44933eefcd8c81af01709eccb", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/182248a466468a7599f21b414904c12daeb8d827/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/182248a466468a7599f21b414904c12daeb8d827/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=182248a466468a7599f21b414904c12daeb8d827", "patch": "@@ -67,6 +67,11 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     /// The `default()` is used for pointers to consts, statics, vtables and functions.\n     type PointerTag: ::std::fmt::Debug + Copy + Eq + Hash + 'static;\n \n+    /// Machines can define extra (non-instance) things that represent values of function pointers.\n+    /// For example, Miri uses this to return a fucntion pointer from `dlsym`\n+    /// that can later be called to execute the right thing.\n+    type ExtraFnVal: ::std::fmt::Debug + Copy;\n+\n     /// Extra data stored in every call frame.\n     type FrameExtra;\n \n@@ -119,6 +124,16 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         ret: Option<mir::BasicBlock>,\n     ) -> InterpResult<'tcx, Option<&'mir mir::Body<'tcx>>>;\n \n+    /// Execute `fn_val`.  it is the hook's responsibility to advance the instruction\n+    /// pointer as appropriate.\n+    fn call_extra_fn(\n+        ecx: &mut InterpCx<'mir, 'tcx, Self>,\n+        fn_val: Self::ExtraFnVal,\n+        args: &[OpTy<'tcx, Self::PointerTag>],\n+        dest: Option<PlaceTy<'tcx, Self::PointerTag>>,\n+        ret: Option<mir::BasicBlock>,\n+    ) -> InterpResult<'tcx>;\n+\n     /// Directly process an intrinsic without pushing a stack frame.\n     /// If this returns successfully, the engine will take care of jumping to the next block.\n     fn call_intrinsic("}, {"sha": "835853cbd21bb51528dacdff512db37aad1cf2cb", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 84, "deletions": 36, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/182248a466468a7599f21b414904c12daeb8d827/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/182248a466468a7599f21b414904c12daeb8d827/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=182248a466468a7599f21b414904c12daeb8d827", "patch": "@@ -54,6 +54,26 @@ pub enum AllocCheck {\n     MaybeDead,\n }\n \n+/// The value of a function pointer.\n+#[derive(Debug, Copy, Clone)]\n+pub enum FnVal<'tcx, Other> {\n+    Instance(Instance<'tcx>),\n+    Other(Other),\n+}\n+\n+impl<'tcx, Other> FnVal<'tcx, Other> {\n+    pub fn as_instance(self) -> InterpResult<'tcx, Instance<'tcx>> {\n+        match self {\n+            FnVal::Instance(instance) =>\n+                Ok(instance),\n+            FnVal::Other(_) =>\n+                err!(MachineError(\n+                    format!(\"Expected instance function pointer, got 'other' pointer\")\n+                )),\n+        }\n+    }\n+}\n+\n // `Memory` has to depend on the `Machine` because some of its operations\n // (e.g., `get`) call a `Machine` hook.\n pub struct Memory<'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n@@ -69,16 +89,20 @@ pub struct Memory<'mir, 'tcx, M: Machine<'mir, 'tcx>> {\n     // FIXME: this should not be public, but interning currently needs access to it\n     pub(super) alloc_map: M::MemoryMap,\n \n+    /// Map for \"extra\" function pointers.\n+    extra_fn_ptr_map: FxHashMap<AllocId, M::ExtraFnVal>,\n+\n     /// To be able to compare pointers with NULL, and to check alignment for accesses\n     /// to ZSTs (where pointers may dangle), we keep track of the size even for allocations\n     /// that do not exist any more.\n+    // FIXME: this should not be public, but interning currently needs access to it\n     pub(super) dead_alloc_map: FxHashMap<AllocId, (Size, Align)>,\n \n     /// Extra data added by the machine.\n     pub extra: M::MemoryExtra,\n \n     /// Lets us implement `HasDataLayout`, which is awfully convenient.\n-    pub(super) tcx: TyCtxtAt<'tcx>,\n+    pub tcx: TyCtxtAt<'tcx>,\n }\n \n impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> HasDataLayout for Memory<'mir, 'tcx, M> {\n@@ -98,6 +122,7 @@ where\n     fn clone(&self) -> Self {\n         Memory {\n             alloc_map: self.alloc_map.clone(),\n+            extra_fn_ptr_map: self.extra_fn_ptr_map.clone(),\n             dead_alloc_map: self.dead_alloc_map.clone(),\n             extra: (),\n             tcx: self.tcx,\n@@ -109,6 +134,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     pub fn new(tcx: TyCtxtAt<'tcx>, extra: M::MemoryExtra) -> Self {\n         Memory {\n             alloc_map: M::MemoryMap::default(),\n+            extra_fn_ptr_map: FxHashMap::default(),\n             dead_alloc_map: FxHashMap::default(),\n             extra,\n             tcx,\n@@ -120,8 +146,21 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         ptr.with_tag(M::tag_static_base_pointer(ptr.alloc_id, &self))\n     }\n \n-    pub fn create_fn_alloc(&mut self, instance: Instance<'tcx>) -> Pointer<M::PointerTag> {\n-        let id = self.tcx.alloc_map.lock().create_fn_alloc(instance);\n+    pub fn create_fn_alloc(\n+        &mut self,\n+        fn_val: FnVal<'tcx, M::ExtraFnVal>,\n+    ) -> Pointer<M::PointerTag>\n+    {\n+        let id = match fn_val {\n+            FnVal::Instance(instance) => self.tcx.alloc_map.lock().create_fn_alloc(instance),\n+            FnVal::Other(extra) => {\n+                // FIXME(RalfJung): Should we have a cache here?\n+                let id = self.tcx.alloc_map.lock().reserve();\n+                let old = self.extra_fn_ptr_map.insert(id, extra);\n+                assert!(old.is_none());\n+                id\n+            }\n+        };\n         self.tag_static_base_pointer(Pointer::from(id))\n     }\n \n@@ -495,56 +534,65 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         id: AllocId,\n         liveness: AllocCheck,\n     ) -> InterpResult<'static, (Size, Align)> {\n+        // Regular allocations.\n         if let Ok(alloc) = self.get(id) {\n             return Ok((Size::from_bytes(alloc.bytes.len() as u64), alloc.align));\n         }\n-        // can't do this in the match argument, we may get cycle errors since the lock would get\n-        // dropped after the match.\n+        // Function pointers.\n+        if let Ok(_) = self.get_fn_alloc(id) {\n+            return if let AllocCheck::Dereferencable = liveness {\n+                // The caller requested no function pointers.\n+                err!(DerefFunctionPointer)\n+            } else {\n+                Ok((Size::ZERO, Align::from_bytes(1).unwrap()))\n+            };\n+        }\n+        // Foreign statics.\n+        // Can't do this in the match argument, we may get cycle errors since the lock would\n+        // be held throughout the match.\n         let alloc = self.tcx.alloc_map.lock().get(id);\n-        // Could also be a fn ptr or extern static\n         match alloc {\n-            Some(GlobalAlloc::Function(..)) => {\n-                if let AllocCheck::Dereferencable = liveness {\n-                    // The caller requested no function pointers.\n-                    err!(DerefFunctionPointer)\n-                } else {\n-                    Ok((Size::ZERO, Align::from_bytes(1).unwrap()))\n-                }\n-            }\n-            // `self.get` would also work, but can cause cycles if a static refers to itself\n             Some(GlobalAlloc::Static(did)) => {\n-                // The only way `get` couldn't have worked here is if this is an extern static\n                 assert!(self.tcx.is_foreign_item(did));\n                 // Use size and align of the type\n                 let ty = self.tcx.type_of(did);\n                 let layout = self.tcx.layout_of(ParamEnv::empty().and(ty)).unwrap();\n-                Ok((layout.size, layout.align.abi))\n+                return Ok((layout.size, layout.align.abi));\n             }\n-            _ => {\n-                if let Ok(alloc) = self.get(id) {\n-                    Ok((Size::from_bytes(alloc.bytes.len() as u64), alloc.align))\n-                }\n-                else if let AllocCheck::MaybeDead = liveness {\n-                    // Deallocated pointers are allowed, we should be able to find\n-                    // them in the map.\n-                    Ok(*self.dead_alloc_map.get(&id)\n-                        .expect(\"deallocated pointers should all be recorded in `dead_alloc_map`\"))\n-                } else {\n-                    err!(DanglingPointerDeref)\n-                }\n-            },\n+            _ => {}\n+        }\n+        // The rest must be dead.\n+        if let AllocCheck::MaybeDead = liveness {\n+            // Deallocated pointers are allowed, we should be able to find\n+            // them in the map.\n+            Ok(*self.dead_alloc_map.get(&id)\n+                .expect(\"deallocated pointers should all be recorded in `dead_alloc_map`\"))\n+        } else {\n+            err!(DanglingPointerDeref)\n         }\n     }\n \n-    pub fn get_fn(&self, ptr: Pointer<M::PointerTag>) -> InterpResult<'tcx, Instance<'tcx>> {\n+    fn get_fn_alloc(&self, id: AllocId) -> InterpResult<'tcx, FnVal<'tcx, M::ExtraFnVal>> {\n+        trace!(\"reading fn ptr: {}\", id);\n+        if let Some(extra) = self.extra_fn_ptr_map.get(&id) {\n+            Ok(FnVal::Other(*extra))\n+        } else {\n+            match self.tcx.alloc_map.lock().get(id) {\n+                Some(GlobalAlloc::Function(instance)) => Ok(FnVal::Instance(instance)),\n+                _ => Err(InterpError::ExecuteMemory.into()),\n+            }\n+        }\n+    }\n+\n+    pub fn get_fn(\n+        &self,\n+        ptr: Scalar<M::PointerTag>,\n+    ) -> InterpResult<'tcx, FnVal<'tcx, M::ExtraFnVal>> {\n+        let ptr = self.force_ptr(ptr)?; // We definitely need a pointer value.\n         if ptr.offset.bytes() != 0 {\n             return err!(InvalidFunctionPointer);\n         }\n-        trace!(\"reading fn ptr: {}\", ptr.alloc_id);\n-        match self.tcx.alloc_map.lock().get(ptr.alloc_id) {\n-            Some(GlobalAlloc::Function(instance)) => Ok(instance),\n-            _ => Err(InterpError::ExecuteMemory.into()),\n-        }\n+        self.get_fn_alloc(ptr.alloc_id)\n     }\n \n     pub fn mark_immutable(&mut self, id: AllocId) -> InterpResult<'tcx> {"}, {"sha": "45d24347e4efd45618c3a5ff2eb41b80beefc01c", "filename": "src/librustc_mir/interpret/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/182248a466468a7599f21b414904c12daeb8d827/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/182248a466468a7599f21b414904c12daeb8d827/src%2Flibrustc_mir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmod.rs?ref=182248a466468a7599f21b414904c12daeb8d827", "patch": "@@ -24,7 +24,7 @@ pub use self::eval_context::{\n \n pub use self::place::{Place, PlaceTy, MemPlace, MPlaceTy};\n \n-pub use self::memory::{Memory, MemoryKind, AllocCheck};\n+pub use self::memory::{Memory, MemoryKind, AllocCheck, FnVal};\n \n pub use self::machine::{Machine, AllocMap, MayLeak};\n "}, {"sha": "0ab428628de688d12ee78c08ee383225453ad839", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 21, "deletions": 14, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/182248a466468a7599f21b414904c12daeb8d827/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/182248a466468a7599f21b414904c12daeb8d827/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=182248a466468a7599f21b414904c12daeb8d827", "patch": "@@ -6,9 +6,9 @@ use rustc::ty::layout::{self, TyLayout, LayoutOf};\n use syntax::source_map::Span;\n use rustc_target::spec::abi::Abi;\n \n-use rustc::mir::interpret::{InterpResult, PointerArithmetic, InterpError, Scalar};\n use super::{\n-    InterpCx, Machine, Immediate, OpTy, ImmTy, PlaceTy, MPlaceTy, StackPopCleanup\n+    InterpResult, PointerArithmetic, InterpError, Scalar,\n+    InterpCx, Machine, Immediate, OpTy, ImmTy, PlaceTy, MPlaceTy, StackPopCleanup, FnVal,\n };\n \n impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n@@ -76,16 +76,16 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 };\n \n                 let func = self.eval_operand(func, None)?;\n-                let (fn_def, abi) = match func.layout.ty.sty {\n+                let (fn_val, abi) = match func.layout.ty.sty {\n                     ty::FnPtr(sig) => {\n                         let caller_abi = sig.abi();\n-                        let fn_ptr = self.force_ptr(self.read_scalar(func)?.not_undef()?)?;\n-                        let instance = self.memory.get_fn(fn_ptr)?;\n-                        (instance, caller_abi)\n+                        let fn_ptr = self.read_scalar(func)?.not_undef()?;\n+                        let fn_val = self.memory.get_fn(fn_ptr)?;\n+                        (fn_val, caller_abi)\n                     }\n                     ty::FnDef(def_id, substs) => {\n                         let sig = func.layout.ty.fn_sig(*self.tcx);\n-                        (self.resolve(def_id, substs)?, sig.abi())\n+                        (FnVal::Instance(self.resolve(def_id, substs)?), sig.abi())\n                     },\n                     _ => {\n                         let msg = format!(\"can't handle callee of type {:?}\", func.layout.ty);\n@@ -94,7 +94,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 };\n                 let args = self.eval_operands(args)?;\n                 self.eval_fn_call(\n-                    fn_def,\n+                    fn_val,\n                     terminator.source_info.span,\n                     abi,\n                     &args[..],\n@@ -228,14 +228,21 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// Call this function -- pushing the stack frame and initializing the arguments.\n     fn eval_fn_call(\n         &mut self,\n-        instance: ty::Instance<'tcx>,\n+        fn_val: FnVal<'tcx, M::ExtraFnVal>,\n         span: Span,\n         caller_abi: Abi,\n         args: &[OpTy<'tcx, M::PointerTag>],\n         dest: Option<PlaceTy<'tcx, M::PointerTag>>,\n         ret: Option<mir::BasicBlock>,\n     ) -> InterpResult<'tcx> {\n-        trace!(\"eval_fn_call: {:#?}\", instance);\n+        trace!(\"eval_fn_call: {:#?}\", fn_val);\n+\n+        let instance = match fn_val {\n+            FnVal::Instance(instance) => instance,\n+            FnVal::Other(extra) => {\n+                return M::call_extra_fn(self, extra, args, dest, ret);\n+            }\n+        };\n \n         match instance.def {\n             ty::InstanceDef::Intrinsic(..) => {\n@@ -431,8 +438,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     self.tcx.data_layout.pointer_align.abi,\n                 )?.expect(\"cannot be a ZST\");\n                 let fn_ptr = self.memory.get(vtable_slot.alloc_id)?\n-                    .read_ptr_sized(self, vtable_slot)?.to_ptr()?;\n-                let instance = self.memory.get_fn(fn_ptr)?;\n+                    .read_ptr_sized(self, vtable_slot)?.not_undef()?;\n+                let drop_fn = self.memory.get_fn(fn_ptr)?;\n \n                 // `*mut receiver_place.layout.ty` is almost the layout that we\n                 // want for args[0]: We have to project to field 0 because we want\n@@ -447,7 +454,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 });\n                 trace!(\"Patched self operand to {:#?}\", args[0]);\n                 // recurse with concrete function\n-                self.eval_fn_call(instance, span, caller_abi, &args, dest, ret)\n+                self.eval_fn_call(drop_fn, span, caller_abi, &args, dest, ret)\n             }\n         }\n     }\n@@ -482,7 +489,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let dest = MPlaceTy::dangling(self.layout_of(ty)?, self);\n \n         self.eval_fn_call(\n-            instance,\n+            FnVal::Instance(instance),\n             span,\n             Abi::Rust,\n             &[arg.into()],"}, {"sha": "e7363f6876c28ce7abeb9a2370d4eeb60fb685e0", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/182248a466468a7599f21b414904c12daeb8d827/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/182248a466468a7599f21b414904c12daeb8d827/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=182248a466468a7599f21b414904c12daeb8d827", "patch": "@@ -2,7 +2,7 @@ use rustc::ty::{self, Ty, Instance};\n use rustc::ty::layout::{Size, Align, LayoutOf};\n use rustc::mir::interpret::{Scalar, Pointer, InterpResult, PointerArithmetic};\n \n-use super::{InterpCx, InterpError, Machine, MemoryKind};\n+use super::{InterpCx, InterpError, Machine, MemoryKind, FnVal};\n \n impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// Creates a dynamic vtable for the given type and vtable origin. This is used only for\n@@ -56,7 +56,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let tcx = &*self.tcx;\n \n         let drop = Instance::resolve_drop_in_place(*tcx, ty);\n-        let drop = self.memory.create_fn_alloc(drop);\n+        let drop = self.memory.create_fn_alloc(FnVal::Instance(drop));\n \n         // no need to do any alignment checks on the memory accesses below, because we know the\n         // allocation is correctly aligned as we created it above. Also we're only offsetting by\n@@ -84,7 +84,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     def_id,\n                     substs,\n                 ).ok_or_else(|| InterpError::TooGeneric)?;\n-                let fn_ptr = self.memory.create_fn_alloc(instance);\n+                let fn_ptr = self.memory.create_fn_alloc(FnVal::Instance(instance));\n                 let method_ptr = vtable.offset(ptr_size * (3 + i as u64), self)?;\n                 self.memory\n                     .get_mut(method_ptr.alloc_id)?\n@@ -112,8 +112,10 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let drop_fn = self.memory\n             .get(vtable.alloc_id)?\n             .read_ptr_sized(self, vtable)?\n-            .to_ptr()?;\n-        let drop_instance = self.memory.get_fn(drop_fn)?;\n+            .not_undef()?;\n+        // We *need* an instance here, no other kind of function value, to be able\n+        // to determine the type.\n+        let drop_instance = self.memory.get_fn(drop_fn)?.as_instance()?;\n         trace!(\"Found drop fn: {:?}\", drop_instance);\n         let fn_sig = drop_instance.ty(*self.tcx).fn_sig(*self.tcx);\n         let fn_sig = self.tcx.normalize_erasing_late_bound_regions(self.param_env, &fn_sig);"}, {"sha": "34892f5b8ca01bda2f702e94523609fdf6e423f5", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 23, "deletions": 26, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/182248a466468a7599f21b414904c12daeb8d827/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/182248a466468a7599f21b414904c12daeb8d827/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=182248a466468a7599f21b414904c12daeb8d827", "patch": "@@ -6,13 +6,11 @@ use rustc::hir;\n use rustc::ty::layout::{self, TyLayout, LayoutOf, VariantIdx};\n use rustc::ty;\n use rustc_data_structures::fx::FxHashSet;\n-use rustc::mir::interpret::{\n-    GlobalAlloc, InterpResult, InterpError,\n-};\n \n use std::hash::Hash;\n \n use super::{\n+    GlobalAlloc, InterpResult, InterpError,\n     OpTy, Machine, InterpCx, ValueVisitor, MPlaceTy,\n };\n \n@@ -153,15 +151,16 @@ fn wrapping_range_format(r: &RangeInclusive<u128>, max_hi: u128) -> String {\n     debug_assert!(hi <= max_hi);\n     if lo > hi {\n         format!(\"less or equal to {}, or greater or equal to {}\", hi, lo)\n+    } else if lo == hi {\n+        format!(\"equal to {}\", lo)\n+    } else if lo == 0 {\n+        debug_assert!(hi < max_hi, \"should not be printing if the range covers everything\");\n+        format!(\"less or equal to {}\", hi)\n+    } else if hi == max_hi {\n+        debug_assert!(lo > 0, \"should not be printing if the range covers everything\");\n+        format!(\"greater or equal to {}\", lo)\n     } else {\n-        if lo == 0 {\n-            debug_assert!(hi < max_hi, \"should not be printing if the range covers everything\");\n-            format!(\"less or equal to {}\", hi)\n-        } else if hi == max_hi {\n-            format!(\"greater or equal to {}\", lo)\n-        } else {\n-            format!(\"in the range {:?}\", r)\n-        }\n+        format!(\"in the range {:?}\", r)\n     }\n }\n \n@@ -457,10 +456,10 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n             }\n             ty::FnPtr(_sig) => {\n                 let value = value.to_scalar_or_undef();\n-                let ptr = try_validation!(value.to_ptr(),\n-                    value, self.path, \"a pointer\");\n-                let _fn = try_validation!(self.ecx.memory.get_fn(ptr),\n-                    value, self.path, \"a function pointer\");\n+                let _fn = try_validation!(\n+                    value.not_undef().and_then(|ptr| self.ecx.memory.get_fn(ptr)),\n+                    value, self.path, \"a function pointer\"\n+                );\n                 // FIXME: Check if the signature matches\n             }\n             // This should be all the primitive types\n@@ -504,20 +503,18 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                 if lo == 1 && hi == max_hi {\n                     // Only NULL is the niche.  So make sure the ptr is NOT NULL.\n                     if self.ecx.memory.ptr_may_be_null(ptr) {\n-                        // These conditions are just here to improve the diagnostics so we can\n-                        // differentiate between null pointers and dangling pointers\n-                        if self.ref_tracking_for_consts.is_some() &&\n-                            self.ecx.memory.get(ptr.alloc_id).is_err() &&\n-                            self.ecx.memory.get_fn(ptr).is_err() {\n-                            return validation_failure!(\n-                                \"encountered dangling pointer\", self.path\n-                            );\n-                        }\n-                        return validation_failure!(\"a potentially NULL pointer\", self.path);\n+                        return validation_failure!(\n+                            \"a potentially NULL pointer\",\n+                            self.path,\n+                            format!(\n+                                \"something that cannot possibly fail to be {}\",\n+                                wrapping_range_format(&layout.valid_range, max_hi)\n+                            )\n+                        );\n                     }\n                     return Ok(());\n                 } else {\n-                    // Conservatively, we reject, because the pointer *could* have this\n+                    // Conservatively, we reject, because the pointer *could* have a bad\n                     // value.\n                     return validation_failure!(\n                         \"a pointer\","}, {"sha": "d4b2220695102aa87ae61c857d08412951ec4fa4", "filename": "src/test/ui/consts/const-eval/ub-enum.rs", "status": "modified", "additions": 22, "deletions": 10, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/182248a466468a7599f21b414904c12daeb8d827/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/182248a466468a7599f21b414904c12daeb8d827/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.rs?ref=182248a466468a7599f21b414904c12daeb8d827", "patch": "@@ -1,17 +1,31 @@\n #![allow(const_err)] // make sure we cannot allow away the errors tested here\n \n+\n+#[repr(transparent)]\n+#[derive(Copy, Clone)]\n+struct Wrap<T>(T);\n+\n #[repr(usize)]\n #[derive(Copy, Clone)]\n enum Enum {\n     A = 0,\n }\n union TransmuteEnum {\n     in1: &'static u8,\n+    in2: usize,\n     out1: Enum,\n+    out2: Wrap<Enum>,\n }\n \n-// A pointer is guaranteed non-null\n-const BAD_ENUM: Enum = unsafe { TransmuteEnum { in1: &1 }.out1 };\n+const GOOD_ENUM: Enum = unsafe { TransmuteEnum { in2: 0 }.out1 };\n+\n+const BAD_ENUM: Enum = unsafe { TransmuteEnum { in2: 1 }.out1 };\n+//~^ ERROR is undefined behavior\n+\n+const BAD_ENUM_PTR: Enum = unsafe { TransmuteEnum { in1: &1 }.out1 };\n+//~^ ERROR is undefined behavior\n+\n+const BAD_ENUM_WRAPPED: Wrap<Enum> = unsafe { TransmuteEnum { in1: &1 }.out2 };\n //~^ ERROR is undefined behavior\n \n // (Potentially) invalid enum discriminant\n@@ -20,9 +34,7 @@ const BAD_ENUM: Enum = unsafe { TransmuteEnum { in1: &1 }.out1 };\n enum Enum2 {\n     A = 2,\n }\n-#[repr(transparent)]\n-#[derive(Copy, Clone)]\n-struct Wrap<T>(T);\n+\n union TransmuteEnum2 {\n     in1: usize,\n     in2: &'static u8,\n@@ -33,17 +45,17 @@ union TransmuteEnum2 {\n }\n const BAD_ENUM2: Enum2 = unsafe { TransmuteEnum2 { in1: 0 }.out1 };\n //~^ ERROR is undefined behavior\n-const BAD_ENUM3: Enum2 = unsafe { TransmuteEnum2 { in2: &0 }.out1 };\n+const BAD_ENUM2_PTR: Enum2 = unsafe { TransmuteEnum2 { in2: &0 }.out1 };\n //~^ ERROR is undefined behavior\n-const BAD_ENUM4: Wrap<Enum2> = unsafe { TransmuteEnum2 { in2: &0 }.out2 };\n+const BAD_ENUM2_WRAPPED: Wrap<Enum2> = unsafe { TransmuteEnum2 { in2: &0 }.out2 };\n //~^ ERROR is undefined behavior\n \n // Undef enum discriminant.\n-const BAD_ENUM_UNDEF : Enum2 = unsafe { TransmuteEnum2 { in3: () }.out1 };\n+const BAD_ENUM2_UNDEF : Enum2 = unsafe { TransmuteEnum2 { in3: () }.out1 };\n //~^ ERROR is undefined behavior\n \n // Pointer value in an enum with a niche that is not just 0.\n-const BAD_ENUM_PTR: Option<Enum2> = unsafe { TransmuteEnum2 { in2: &0 }.out3 };\n+const BAD_ENUM2_OPTION_PTR: Option<Enum2> = unsafe { TransmuteEnum2 { in2: &0 }.out3 };\n //~^ ERROR is undefined behavior\n \n // Invalid enum field content (mostly to test printing of paths for enum tuple\n@@ -53,7 +65,7 @@ union TransmuteChar {\n     b: char,\n }\n // Need to create something which does not clash with enum layout optimizations.\n-const BAD_ENUM_CHAR: Option<(char, char)> = Some(('x', unsafe { TransmuteChar { a: !0 }.b }));\n+const BAD_OPTION_CHAR: Option<(char, char)> = Some(('x', unsafe { TransmuteChar { a: !0 }.b }));\n //~^ ERROR is undefined behavior\n \n fn main() {"}, {"sha": "8ecb1aabdd0f72a55a2e6b0de0c1681403fd3a55", "filename": "src/test/ui/consts/const-eval/ub-enum.stderr", "status": "modified", "additions": 36, "deletions": 20, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/182248a466468a7599f21b414904c12daeb8d827/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/182248a466468a7599f21b414904c12daeb8d827/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-enum.stderr?ref=182248a466468a7599f21b414904c12daeb8d827", "patch": "@@ -1,59 +1,75 @@\n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-enum.rs:14:1\n+  --> $DIR/ub-enum.rs:22:1\n    |\n-LL | const BAD_ENUM: Enum = unsafe { TransmuteEnum { in1: &1 }.out1 };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer, but expected a valid enum discriminant\n+LL | const BAD_ENUM: Enum = unsafe { TransmuteEnum { in2: 1 }.out1 };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 1, but expected a valid enum discriminant\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-enum.rs:34:1\n+  --> $DIR/ub-enum.rs:25:1\n+   |\n+LL | const BAD_ENUM_PTR: Enum = unsafe { TransmuteEnum { in1: &1 }.out1 };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer, but expected a valid enum discriminant\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/ub-enum.rs:28:1\n+   |\n+LL | const BAD_ENUM_WRAPPED: Wrap<Enum> = unsafe { TransmuteEnum { in1: &1 }.out2 };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer, but expected something that cannot possibly fail to be equal to 0\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/ub-enum.rs:46:1\n    |\n LL | const BAD_ENUM2: Enum2 = unsafe { TransmuteEnum2 { in1: 0 }.out1 };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 0, but expected a valid enum discriminant\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-enum.rs:36:1\n+  --> $DIR/ub-enum.rs:48:1\n    |\n-LL | const BAD_ENUM3: Enum2 = unsafe { TransmuteEnum2 { in2: &0 }.out1 };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer, but expected a valid enum discriminant\n+LL | const BAD_ENUM2_PTR: Enum2 = unsafe { TransmuteEnum2 { in2: &0 }.out1 };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer, but expected a valid enum discriminant\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-enum.rs:38:1\n+  --> $DIR/ub-enum.rs:50:1\n    |\n-LL | const BAD_ENUM4: Wrap<Enum2> = unsafe { TransmuteEnum2 { in2: &0 }.out2 };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer, but expected something that cannot possibly fail to be in the range 2..=2\n+LL | const BAD_ENUM2_WRAPPED: Wrap<Enum2> = unsafe { TransmuteEnum2 { in2: &0 }.out2 };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer, but expected something that cannot possibly fail to be equal to 2\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-enum.rs:42:1\n+  --> $DIR/ub-enum.rs:54:1\n    |\n-LL | const BAD_ENUM_UNDEF : Enum2 = unsafe { TransmuteEnum2 { in3: () }.out1 };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered uninitialized bytes, but expected a valid enum discriminant\n+LL | const BAD_ENUM2_UNDEF : Enum2 = unsafe { TransmuteEnum2 { in3: () }.out1 };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered uninitialized bytes, but expected a valid enum discriminant\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-enum.rs:46:1\n+  --> $DIR/ub-enum.rs:58:1\n    |\n-LL | const BAD_ENUM_PTR: Option<Enum2> = unsafe { TransmuteEnum2 { in2: &0 }.out3 };\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer, but expected a valid enum discriminant\n+LL | const BAD_ENUM2_OPTION_PTR: Option<Enum2> = unsafe { TransmuteEnum2 { in2: &0 }.out3 };\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered a pointer, but expected a valid enum discriminant\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-enum.rs:56:1\n+  --> $DIR/ub-enum.rs:68:1\n    |\n-LL | const BAD_ENUM_CHAR: Option<(char, char)> = Some(('x', unsafe { TransmuteChar { a: !0 }.b }));\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 4294967295 at .<downcast-variant(Some)>.0.1, but expected something less or equal to 1114111\n+LL | const BAD_OPTION_CHAR: Option<(char, char)> = Some(('x', unsafe { TransmuteChar { a: !0 }.b }));\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 4294967295 at .<downcast-variant(Some)>.0.1, but expected something less or equal to 1114111\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n-error: aborting due to 7 previous errors\n+error: aborting due to 9 previous errors\n \n For more information about this error, try `rustc --explain E0080`."}, {"sha": "bcbb4358aec03823682766573052a389ad4d2eba", "filename": "src/test/ui/consts/const-eval/ub-nonnull.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/182248a466468a7599f21b414904c12daeb8d827/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.rs", "raw_url": "https://github.com/rust-lang/rust/raw/182248a466468a7599f21b414904c12daeb8d827/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.rs?ref=182248a466468a7599f21b414904c12daeb8d827", "patch": "@@ -5,9 +5,19 @@ use std::mem;\n use std::ptr::NonNull;\n use std::num::{NonZeroU8, NonZeroUsize};\n \n+const NON_NULL: NonNull<u8> = unsafe { mem::transmute(1usize) };\n+const NON_NULL_PTR: NonNull<u8> = unsafe { mem::transmute(&1) };\n+\n const NULL_PTR: NonNull<u8> = unsafe { mem::transmute(0usize) };\n //~^ ERROR it is undefined behavior to use this value\n \n+const OUT_OF_BOUNDS_PTR: NonNull<u8> = { unsafe {\n+//~^ ERROR it is undefined behavior to use this value\n+    let ptr: &(u8, u8, u8) = mem::transmute(&0u8); // &0 gets promoted so it does not dangle\n+    let out_of_bounds_ptr = &ptr.2; // use address-of-field for pointer arithmetic\n+    mem::transmute(out_of_bounds_ptr)\n+} };\n+\n const NULL_U8: NonZeroU8 = unsafe { mem::transmute(0u8) };\n //~^ ERROR it is undefined behavior to use this value\n const NULL_USIZE: NonZeroUsize = unsafe { mem::transmute(0usize) };"}, {"sha": "2f9423fed3530389b6f1a4b726d852cc56030050", "filename": "src/test/ui/consts/const-eval/ub-nonnull.stderr", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/182248a466468a7599f21b414904c12daeb8d827/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/182248a466468a7599f21b414904c12daeb8d827/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.stderr?ref=182248a466468a7599f21b414904c12daeb8d827", "patch": "@@ -1,51 +1,64 @@\n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-nonnull.rs:8:1\n+  --> $DIR/ub-nonnull.rs:11:1\n    |\n LL | const NULL_PTR: NonNull<u8> = unsafe { mem::transmute(0usize) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 0, but expected something greater or equal to 1\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-nonnull.rs:11:1\n+  --> $DIR/ub-nonnull.rs:14:1\n+   |\n+LL | / const OUT_OF_BOUNDS_PTR: NonNull<u8> = { unsafe {\n+LL | |\n+LL | |     let ptr: &(u8, u8, u8) = mem::transmute(&0u8); // &0 gets promoted so it does not dangle\n+LL | |     let out_of_bounds_ptr = &ptr.2; // use address-of-field for pointer arithmetic\n+LL | |     mem::transmute(out_of_bounds_ptr)\n+LL | | } };\n+   | |____^ type validation failed: encountered a potentially NULL pointer, but expected something that cannot possibly fail to be greater or equal to 1\n+   |\n+   = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n+\n+error[E0080]: it is undefined behavior to use this value\n+  --> $DIR/ub-nonnull.rs:21:1\n    |\n LL | const NULL_U8: NonZeroU8 = unsafe { mem::transmute(0u8) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 0, but expected something greater or equal to 1\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-nonnull.rs:13:1\n+  --> $DIR/ub-nonnull.rs:23:1\n    |\n LL | const NULL_USIZE: NonZeroUsize = unsafe { mem::transmute(0usize) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 0, but expected something greater or equal to 1\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-nonnull.rs:20:1\n+  --> $DIR/ub-nonnull.rs:30:1\n    |\n LL | const UNINIT: NonZeroU8 = unsafe { Transmute { uninit: () }.out };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered uninitialized bytes, but expected something greater or equal to 1\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-nonnull.rs:28:1\n+  --> $DIR/ub-nonnull.rs:38:1\n    |\n LL | const BAD_RANGE1: RestrictedRange1 = unsafe { RestrictedRange1(42) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 42, but expected something in the range 10..=30\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n error[E0080]: it is undefined behavior to use this value\n-  --> $DIR/ub-nonnull.rs:34:1\n+  --> $DIR/ub-nonnull.rs:44:1\n    |\n LL | const BAD_RANGE2: RestrictedRange2 = unsafe { RestrictedRange2(20) };\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ type validation failed: encountered 20, but expected something less or equal to 10, or greater or equal to 30\n    |\n    = note: The rules on what exactly is undefined behavior aren't clear, so this check might be overzealous. Please open an issue on the rust compiler repository if you believe it should not be considered undefined behavior\n \n-error: aborting due to 6 previous errors\n+error: aborting due to 7 previous errors\n \n For more information about this error, try `rustc --explain E0080`."}]}