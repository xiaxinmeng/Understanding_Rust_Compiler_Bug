{"sha": "6e302ad76a2e579d5c66876be3f2bd582523167b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZlMzAyYWQ3NmEyZTU3OWQ1YzY2ODc2YmUzZjJiZDU4MjUyMzE2N2I=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-10-18T09:39:53Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-10-18T09:39:53Z"}, "message": "resolve_lifetime.rs: rustfmt", "tree": {"sha": "2e9e90fbe658e23d8494a3aa9e49bfcb32c89566", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2e9e90fbe658e23d8494a3aa9e49bfcb32c89566"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6e302ad76a2e579d5c66876be3f2bd582523167b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6e302ad76a2e579d5c66876be3f2bd582523167b", "html_url": "https://github.com/rust-lang/rust/commit/6e302ad76a2e579d5c66876be3f2bd582523167b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6e302ad76a2e579d5c66876be3f2bd582523167b/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1f4d100472c7ea84091fc5a2b028d517cf6cdaf1", "url": "https://api.github.com/repos/rust-lang/rust/commits/1f4d100472c7ea84091fc5a2b028d517cf6cdaf1", "html_url": "https://github.com/rust-lang/rust/commit/1f4d100472c7ea84091fc5a2b028d517cf6cdaf1"}], "stats": {"total": 664, "additions": 369, "deletions": 295}, "files": [{"sha": "b22ea3dceb3678bc5a3305805406980876bcb241", "filename": "src/librustc/middle/resolve_lifetime.rs", "status": "modified", "additions": 369, "deletions": 295, "changes": 664, "blob_url": "https://github.com/rust-lang/rust/blob/6e302ad76a2e579d5c66876be3f2bd582523167b/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6e302ad76a2e579d5c66876be3f2bd582523167b/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve_lifetime.rs?ref=6e302ad76a2e579d5c66876be3f2bd582523167b", "patch": "@@ -18,8 +18,8 @@\n use hir::def::Def;\n use hir::def_id::{CrateNum, DefId, LocalDefId, LOCAL_CRATE};\n use hir::map::Map;\n-use hir::{GenericArg, GenericParam, ItemLocalId, LifetimeName, ParamName, Node};\n-use ty::{self, TyCtxt, DefIdTree, GenericParamDefKind};\n+use hir::{GenericArg, GenericParam, ItemLocalId, LifetimeName, Node, ParamName};\n+use ty::{self, DefIdTree, GenericParamDefKind, TyCtxt};\n \n use errors::{Applicability, DiagnosticBuilder};\n use rustc::lint;\n@@ -54,14 +54,12 @@ pub enum LifetimeDefOrigin {\n impl LifetimeDefOrigin {\n     fn from_param(param: &GenericParam) -> Self {\n         match param.kind {\n-            GenericParamKind::Lifetime { kind } => {\n-                match kind {\n-                    LifetimeParamKind::InBand => LifetimeDefOrigin::InBand,\n-                    LifetimeParamKind::Explicit => LifetimeDefOrigin::ExplicitOrElided,\n-                    LifetimeParamKind::Elided => LifetimeDefOrigin::ExplicitOrElided,\n-                    LifetimeParamKind::Error => LifetimeDefOrigin::Error,\n-                }\n-            }\n+            GenericParamKind::Lifetime { kind } => match kind {\n+                LifetimeParamKind::InBand => LifetimeDefOrigin::InBand,\n+                LifetimeParamKind::Explicit => LifetimeDefOrigin::ExplicitOrElided,\n+                LifetimeParamKind::Elided => LifetimeDefOrigin::ExplicitOrElided,\n+                LifetimeParamKind::Error => LifetimeDefOrigin::Error,\n+            },\n             _ => bug!(\"expected a lifetime param\"),\n         }\n     }\n@@ -107,12 +105,12 @@ impl Region {\n         let origin = LifetimeDefOrigin::from_param(param);\n         debug!(\n             \"Region::late: param={:?} depth={:?} def_id={:?} origin={:?}\",\n-            param,\n-            depth,\n-            def_id,\n-            origin,\n+            param, depth, def_id, origin,\n         );\n-        (param.name.modern(), Region::LateBound(depth, def_id, origin))\n+        (\n+            param.name.modern(),\n+            Region::LateBound(depth, def_id, origin),\n+        )\n     }\n \n     fn late_anon(index: &Cell<u32>) -> Region {\n@@ -146,23 +144,24 @@ impl Region {\n \n     fn shifted_out_to_binder(self, binder: ty::DebruijnIndex) -> Region {\n         match self {\n-            Region::LateBound(debruijn, id, origin) => Region::LateBound(\n-                debruijn.shifted_out_to_binder(binder),\n-                id,\n-                origin,\n-            ),\n-            Region::LateBoundAnon(debruijn, index) => Region::LateBoundAnon(\n-                debruijn.shifted_out_to_binder(binder),\n-                index,\n-            ),\n+            Region::LateBound(debruijn, id, origin) => {\n+                Region::LateBound(debruijn.shifted_out_to_binder(binder), id, origin)\n+            }\n+            Region::LateBoundAnon(debruijn, index) => {\n+                Region::LateBoundAnon(debruijn.shifted_out_to_binder(binder), index)\n+            }\n             _ => self,\n         }\n     }\n \n     fn subst<'a, L>(self, mut params: L, map: &NamedRegionMap) -> Option<Region>\n-            where L: Iterator<Item = &'a hir::Lifetime>  {\n+    where\n+        L: Iterator<Item = &'a hir::Lifetime>,\n+    {\n         if let Region::EarlyBound(index, _, _) = self {\n-            params.nth(index as usize).and_then(|lifetime| map.defs.get(&lifetime.id).cloned())\n+            params\n+                .nth(index as usize)\n+                .and_then(|lifetime| map.defs.get(&lifetime.id).cloned())\n         } else {\n             Some(self)\n         }\n@@ -364,17 +363,17 @@ pub fn provide(providers: &mut ty::query::Providers<'_>) {\n         is_late_bound_map: |tcx, id| {\n             let id = LocalDefId::from_def_id(DefId::local(id)); // (*)\n             tcx.resolve_lifetimes(LOCAL_CRATE)\n-               .late_bound\n-               .get(&id)\n-               .cloned()\n+                .late_bound\n+                .get(&id)\n+                .cloned()\n         },\n \n         object_lifetime_defaults_map: |tcx, id| {\n             let id = LocalDefId::from_def_id(DefId::local(id)); // (*)\n             tcx.resolve_lifetimes(LOCAL_CRATE)\n-               .object_lifetime_defaults\n-               .get(&id)\n-               .cloned()\n+                .object_lifetime_defaults\n+                .get(&id)\n+                .cloned()\n         },\n \n         ..*providers\n@@ -408,14 +407,16 @@ fn resolve_lifetimes<'tcx>(\n     }\n     for k in named_region_map.late_bound {\n         let hir_id = tcx.hir.node_to_hir_id(k);\n-        let map = rl.late_bound.entry(hir_id.owner_local_def_id()).or_default();\n+        let map = rl.late_bound\n+            .entry(hir_id.owner_local_def_id())\n+            .or_default();\n         Lrc::get_mut(map).unwrap().insert(hir_id.local_id);\n     }\n     for (k, v) in named_region_map.object_lifetime_defaults {\n         let hir_id = tcx.hir.node_to_hir_id(k);\n         let map = rl.object_lifetime_defaults\n-                    .entry(hir_id.owner_local_def_id())\n-                    .or_default();\n+            .entry(hir_id.owner_local_def_id())\n+            .or_default();\n         Lrc::get_mut(map)\n             .unwrap()\n             .insert(hir_id.local_id, Lrc::new(v));\n@@ -498,13 +499,20 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 };\n                 self.with(scope, |_, this| intravisit::walk_item(this, item));\n             }\n-            hir::ItemKind::Existential(hir::ExistTy { impl_trait_fn: Some(_), .. }) => {\n+            hir::ItemKind::Existential(hir::ExistTy {\n+                impl_trait_fn: Some(_),\n+                ..\n+            }) => {\n                 // currently existential type declarations are just generated from impl Trait\n                 // items. doing anything on this node is irrelevant, as we currently don't need\n                 // it.\n             }\n             hir::ItemKind::Ty(_, ref generics)\n-            | hir::ItemKind::Existential(hir::ExistTy { impl_trait_fn: None, ref generics, .. })\n+            | hir::ItemKind::Existential(hir::ExistTy {\n+                impl_trait_fn: None,\n+                ref generics,\n+                ..\n+            })\n             | hir::ItemKind::Enum(_, ref generics)\n             | hir::ItemKind::Struct(_, ref generics)\n             | hir::ItemKind::Union(_, ref generics)\n@@ -524,15 +532,19 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     0\n                 };\n                 let mut type_count = 0;\n-                let lifetimes = generics.params.iter().filter_map(|param| match param.kind {\n-                    GenericParamKind::Lifetime { .. } => {\n-                        Some(Region::early(&self.tcx.hir, &mut index, param))\n-                    }\n-                    GenericParamKind::Type { .. } => {\n-                        type_count += 1;\n-                        None\n-                    }\n-                }).collect();\n+                let lifetimes = generics\n+                    .params\n+                    .iter()\n+                    .filter_map(|param| match param.kind {\n+                        GenericParamKind::Lifetime { .. } => {\n+                            Some(Region::early(&self.tcx.hir, &mut index, param))\n+                        }\n+                        GenericParamKind::Type { .. } => {\n+                            type_count += 1;\n+                            None\n+                        }\n+                    })\n+                    .collect();\n                 let scope = Scope::Binder {\n                     lifetimes,\n                     next_early_index: index + type_count,\n@@ -572,12 +584,15 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 let was_in_fn_syntax = self.is_in_fn_syntax;\n                 self.is_in_fn_syntax = true;\n                 let scope = Scope::Binder {\n-                    lifetimes: c.generic_params.iter().filter_map(|param| match param.kind {\n-                        GenericParamKind::Lifetime { .. } => {\n-                            Some(Region::late(&self.tcx.hir, param))\n-                        }\n-                        _ => None,\n-                    }).collect(),\n+                    lifetimes: c.generic_params\n+                        .iter()\n+                        .filter_map(|param| match param.kind {\n+                            GenericParamKind::Lifetime { .. } => {\n+                                Some(Region::late(&self.tcx.hir, param))\n+                            }\n+                            _ => None,\n+                        })\n+                        .collect(),\n                     s: self.scope,\n                     next_early_index,\n                     track_lifetime_uses: true,\n@@ -615,7 +630,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         // If the user wrote an explicit name, use that.\n                         self.visit_lifetime(lifetime);\n                     }\n-                    LifetimeName::Error => { }\n+                    LifetimeName::Error => {}\n                 }\n             }\n             hir::TyKind::Rptr(ref lifetime_ref, ref mt) => {\n@@ -635,19 +650,19 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 let (generics, bounds) = match self.tcx.hir.expect_item(item_id.id).node {\n                     // named existential types are reached via TyKind::Path\n                     // this arm is for `impl Trait` in the types of statics, constants and locals\n-                    hir::ItemKind::Existential(hir::ExistTy{ impl_trait_fn: None, .. }) => {\n+                    hir::ItemKind::Existential(hir::ExistTy {\n+                        impl_trait_fn: None,\n+                        ..\n+                    }) => {\n                         intravisit::walk_ty(self, ty);\n                         return;\n-                    },\n+                    }\n                     // RPIT (return position impl trait)\n-                    hir::ItemKind::Existential(hir::ExistTy{\n+                    hir::ItemKind::Existential(hir::ExistTy {\n                         ref generics,\n                         ref bounds,\n                         ..\n-                    }) => (\n-                        generics,\n-                        bounds,\n-                    ),\n+                    }) => (generics, bounds),\n                     ref i => bug!(\"impl Trait pointed to non-existential type?? {:#?}\", i),\n                 };\n \n@@ -778,15 +793,19 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 let mut index = self.next_early_index();\n                 debug!(\"visit_ty: index = {}\", index);\n                 let mut type_count = 0;\n-                let lifetimes = generics.params.iter().filter_map(|param| match param.kind {\n-                    GenericParamKind::Lifetime { .. } => {\n-                        Some(Region::early(&self.tcx.hir, &mut index, param))\n-                    }\n-                    GenericParamKind::Type { .. } => {\n-                        type_count += 1;\n-                        None\n-                    }\n-                }).collect();\n+                let lifetimes = generics\n+                    .params\n+                    .iter()\n+                    .filter_map(|param| match param.kind {\n+                        GenericParamKind::Lifetime { .. } => {\n+                            Some(Region::early(&self.tcx.hir, &mut index, param))\n+                        }\n+                        GenericParamKind::Type { .. } => {\n+                            type_count += 1;\n+                            None\n+                        }\n+                    })\n+                    .collect();\n                 let scope = Scope::Binder {\n                     lifetimes,\n                     next_early_index: index + type_count,\n@@ -829,15 +848,19 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 let mut index = self.next_early_index();\n                 let mut next_early_index = index;\n                 debug!(\"visit_ty: index = {}\", index);\n-                let lifetimes = generics.params.iter().filter_map(|param| match param.kind {\n-                    GenericParamKind::Lifetime { .. } => {\n-                        Some(Region::early(&self.tcx.hir, &mut index, param))\n-                    }\n-                    GenericParamKind::Type { .. } => {\n-                        next_early_index += 1;\n-                        None\n-                    }\n-                }).collect();\n+                let lifetimes = generics\n+                    .params\n+                    .iter()\n+                    .filter_map(|param| match param.kind {\n+                        GenericParamKind::Lifetime { .. } => {\n+                            Some(Region::early(&self.tcx.hir, &mut index, param))\n+                        }\n+                        GenericParamKind::Type { .. } => {\n+                            next_early_index += 1;\n+                            None\n+                        }\n+                    })\n+                    .collect();\n                 let scope = Scope::Binder {\n                     lifetimes,\n                     next_early_index,\n@@ -855,15 +878,19 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 let mut index = self.next_early_index();\n                 let mut next_early_index = index;\n                 debug!(\"visit_ty: index = {}\", index);\n-                let lifetimes = generics.params.iter().filter_map(|param| match param.kind {\n-                    GenericParamKind::Lifetime { .. } => {\n-                        Some(Region::early(&self.tcx.hir, &mut index, param))\n-                    }\n-                    GenericParamKind::Type { .. } => {\n-                        next_early_index += 1;\n-                        None\n-                    }\n-                }).collect();\n+                let lifetimes = generics\n+                    .params\n+                    .iter()\n+                    .filter_map(|param| match param.kind {\n+                        GenericParamKind::Lifetime { .. } => {\n+                            Some(Region::early(&self.tcx.hir, &mut index, param))\n+                        }\n+                        GenericParamKind::Type { .. } => {\n+                            next_early_index += 1;\n+                            None\n+                        }\n+                    })\n+                    .collect();\n \n                 let scope = Scope::Binder {\n                     lifetimes,\n@@ -937,13 +964,15 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     ref bound_generic_params,\n                     ..\n                 }) => {\n-                    let lifetimes: FxHashMap<_, _> = bound_generic_params.iter()\n+                    let lifetimes: FxHashMap<_, _> = bound_generic_params\n+                        .iter()\n                         .filter_map(|param| match param.kind {\n                             GenericParamKind::Lifetime { .. } => {\n                                 Some(Region::late(&self.tcx.hir, param))\n                             }\n                             _ => None,\n-                        }).collect();\n+                        })\n+                        .collect();\n                     if !lifetimes.is_empty() {\n                         self.trait_ref_hack = true;\n                         let next_early_index = self.next_early_index();\n@@ -993,15 +1022,12 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     ) {\n         debug!(\"visit_poly_trait_ref trait_ref={:?}\", trait_ref);\n \n-        if !self.trait_ref_hack\n-            || trait_ref\n-                .bound_generic_params\n-                .iter()\n-                .any(|param| match param.kind {\n-                    GenericParamKind::Lifetime { .. } => true,\n-                    _ => false,\n-                })\n-        {\n+        if !self.trait_ref_hack || trait_ref.bound_generic_params.iter().any(|param| {\n+            match param.kind {\n+                GenericParamKind::Lifetime { .. } => true,\n+                _ => false,\n+            }\n+        }) {\n             if self.trait_ref_hack {\n                 span_err!(\n                     self.tcx.sess,\n@@ -1012,13 +1038,16 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n             }\n             let next_early_index = self.next_early_index();\n             let scope = Scope::Binder {\n-                lifetimes: trait_ref.bound_generic_params.iter()\n+                lifetimes: trait_ref\n+                    .bound_generic_params\n+                    .iter()\n                     .filter_map(|param| match param.kind {\n                         GenericParamKind::Lifetime { .. } => {\n                             Some(Region::late(&self.tcx.hir, param))\n                         }\n                         _ => None,\n-                    }).collect(),\n+                    })\n+                    .collect(),\n                 s: self.scope,\n                 next_early_index,\n                 track_lifetime_uses: true,\n@@ -1083,29 +1112,30 @@ impl ShadowKind {\n     }\n }\n \n-fn check_mixed_explicit_and_in_band_defs(\n-    tcx: TyCtxt<'_, '_, '_>,\n-    params: &P<[hir::GenericParam]>,\n-) {\n-    let lifetime_params: Vec<_> = params.iter().filter_map(|param| match param.kind {\n-        GenericParamKind::Lifetime { kind, .. } => Some((kind, param.span)),\n-        _ => None,\n-    }).collect();\n-    let explicit = lifetime_params.iter().find(|(kind, _)| *kind == LifetimeParamKind::Explicit);\n-    let in_band = lifetime_params.iter().find(|(kind, _)| *kind == LifetimeParamKind::InBand);\n-\n-    if let (Some((_, explicit_span)), Some((_, in_band_span)))\n-        = (explicit, in_band) {\n+fn check_mixed_explicit_and_in_band_defs(tcx: TyCtxt<'_, '_, '_>, params: &P<[hir::GenericParam]>) {\n+    let lifetime_params: Vec<_> = params\n+        .iter()\n+        .filter_map(|param| match param.kind {\n+            GenericParamKind::Lifetime { kind, .. } => Some((kind, param.span)),\n+            _ => None,\n+        })\n+        .collect();\n+    let explicit = lifetime_params\n+        .iter()\n+        .find(|(kind, _)| *kind == LifetimeParamKind::Explicit);\n+    let in_band = lifetime_params\n+        .iter()\n+        .find(|(kind, _)| *kind == LifetimeParamKind::InBand);\n+\n+    if let (Some((_, explicit_span)), Some((_, in_band_span))) = (explicit, in_band) {\n         struct_span_err!(\n             tcx.sess,\n             *in_band_span,\n             E0688,\n             \"cannot mix in-band and explicit lifetime definitions\"\n-        ).span_label(\n-            *in_band_span,\n-            \"in-band lifetime definition here\",\n-        ).span_label(*explicit_span, \"explicit lifetime definition here\")\n-        .emit();\n+        ).span_label(*in_band_span, \"in-band lifetime definition here\")\n+            .span_label(*explicit_span, \"explicit lifetime definition here\")\n+            .emit();\n     }\n }\n \n@@ -1191,8 +1221,9 @@ fn extract_labels(ctxt: &mut LifetimeContext<'_, '_>, body: &hir::Body) {\n \n     fn expression_label(ex: &hir::Expr) -> Option<ast::Ident> {\n         match ex.node {\n-            hir::ExprKind::While(.., Some(label)) |\n-            hir::ExprKind::Loop(_, Some(label), _) => Some(label.ident),\n+            hir::ExprKind::While(.., Some(label)) | hir::ExprKind::Loop(_, Some(label), _) => {\n+                Some(label.ident)\n+            }\n             _ => None,\n         }\n     }\n@@ -1245,7 +1276,11 @@ fn compute_object_lifetime_defaults(\n             hir::ItemKind::Struct(_, ref generics)\n             | hir::ItemKind::Union(_, ref generics)\n             | hir::ItemKind::Enum(_, ref generics)\n-            | hir::ItemKind::Existential(hir::ExistTy { ref generics, impl_trait_fn: None, .. })\n+            | hir::ItemKind::Existential(hir::ExistTy {\n+                ref generics,\n+                impl_trait_fn: None,\n+                ..\n+            })\n             | hir::ItemKind::Ty(_, ref generics)\n             | hir::ItemKind::Trait(_, _, ref generics, ..) => {\n                 let result = object_lifetime_defaults_for_item(tcx, generics);\n@@ -1257,8 +1292,10 @@ fn compute_object_lifetime_defaults(\n                         .map(|set| match *set {\n                             Set1::Empty => \"BaseDefault\".into(),\n                             Set1::One(Region::Static) => \"'static\".into(),\n-                            Set1::One(Region::EarlyBound(mut i, _, _)) => {\n-                                generics.params.iter().find_map(|param| match param.kind {\n+                            Set1::One(Region::EarlyBound(mut i, _, _)) => generics\n+                                .params\n+                                .iter()\n+                                .find_map(|param| match param.kind {\n                                     GenericParamKind::Lifetime { .. } => {\n                                         if i == 0 {\n                                             return Some(param.name.ident().to_string().into());\n@@ -1267,8 +1304,8 @@ fn compute_object_lifetime_defaults(\n                                         None\n                                     }\n                                     _ => None,\n-                                }).unwrap()\n-                            }\n+                                })\n+                                .unwrap(),\n                             Set1::One(_) => bug!(),\n                             Set1::Many => \"Ambiguous\".into(),\n                         })\n@@ -1300,66 +1337,70 @@ fn object_lifetime_defaults_for_item(\n         }\n     }\n \n-    generics.params.iter().filter_map(|param| match param.kind {\n-        GenericParamKind::Lifetime { .. } => None,\n-        GenericParamKind::Type { .. } => {\n-            let mut set = Set1::Empty;\n+    generics\n+        .params\n+        .iter()\n+        .filter_map(|param| match param.kind {\n+            GenericParamKind::Lifetime { .. } => None,\n+            GenericParamKind::Type { .. } => {\n+                let mut set = Set1::Empty;\n \n-            add_bounds(&mut set, &param.bounds);\n+                add_bounds(&mut set, &param.bounds);\n \n-            let param_def_id = tcx.hir.local_def_id(param.id);\n-            for predicate in &generics.where_clause.predicates {\n-                // Look for `type: ...` where clauses.\n-                let data = match *predicate {\n-                    hir::WherePredicate::BoundPredicate(ref data) => data,\n-                    _ => continue,\n-                };\n+                let param_def_id = tcx.hir.local_def_id(param.id);\n+                for predicate in &generics.where_clause.predicates {\n+                    // Look for `type: ...` where clauses.\n+                    let data = match *predicate {\n+                        hir::WherePredicate::BoundPredicate(ref data) => data,\n+                        _ => continue,\n+                    };\n \n-                // Ignore `for<'a> type: ...` as they can change what\n-                // lifetimes mean (although we could \"just\" handle it).\n-                if !data.bound_generic_params.is_empty() {\n-                    continue;\n-                }\n+                    // Ignore `for<'a> type: ...` as they can change what\n+                    // lifetimes mean (although we could \"just\" handle it).\n+                    if !data.bound_generic_params.is_empty() {\n+                        continue;\n+                    }\n \n-                let def = match data.bounded_ty.node {\n-                    hir::TyKind::Path(hir::QPath::Resolved(None, ref path)) => path.def,\n-                    _ => continue,\n-                };\n+                    let def = match data.bounded_ty.node {\n+                        hir::TyKind::Path(hir::QPath::Resolved(None, ref path)) => path.def,\n+                        _ => continue,\n+                    };\n \n-                if def == Def::TyParam(param_def_id) {\n-                    add_bounds(&mut set, &data.bounds);\n+                    if def == Def::TyParam(param_def_id) {\n+                        add_bounds(&mut set, &data.bounds);\n+                    }\n                 }\n-            }\n \n-            Some(match set {\n-                Set1::Empty => Set1::Empty,\n-                Set1::One(name) => {\n-                    if name == hir::LifetimeName::Static {\n-                        Set1::One(Region::Static)\n-                    } else {\n-                        generics.params.iter().filter_map(|param| match param.kind {\n-                            GenericParamKind::Lifetime { .. } => {\n-                                Some((\n-                                    param.id,\n-                                    hir::LifetimeName::Param(param.name),\n-                                    LifetimeDefOrigin::from_param(param),\n-                                ))\n-                            }\n-                            _ => None,\n-                        })\n-                        .enumerate()\n-                        .find(|&(_, (_, lt_name, _))| lt_name == name)\n-                        .map_or(Set1::Many, |(i, (id, _, origin))| {\n-                            let def_id = tcx.hir.local_def_id(id);\n-                            Set1::One(Region::EarlyBound(i as u32, def_id, origin))\n-                        })\n+                Some(match set {\n+                    Set1::Empty => Set1::Empty,\n+                    Set1::One(name) => {\n+                        if name == hir::LifetimeName::Static {\n+                            Set1::One(Region::Static)\n+                        } else {\n+                            generics\n+                                .params\n+                                .iter()\n+                                .filter_map(|param| match param.kind {\n+                                    GenericParamKind::Lifetime { .. } => Some((\n+                                        param.id,\n+                                        hir::LifetimeName::Param(param.name),\n+                                        LifetimeDefOrigin::from_param(param),\n+                                    )),\n+                                    _ => None,\n+                                })\n+                                .enumerate()\n+                                .find(|&(_, (_, lt_name, _))| lt_name == name)\n+                                .map_or(Set1::Many, |(i, (id, _, origin))| {\n+                                    let def_id = tcx.hir.local_def_id(id);\n+                                    Set1::One(Region::EarlyBound(i as u32, def_id, origin))\n+                                })\n+                        }\n                     }\n-                }\n-                Set1::Many => Set1::Many,\n-            })\n-        }\n-    })\n-    .collect()\n+                    Set1::Many => Set1::Many,\n+                })\n+            }\n+        })\n+        .collect()\n }\n \n impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n@@ -1409,20 +1450,19 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             // if sole lifetime, remove the `<>` brackets\n             Some(generics.span)\n         } else {\n-            generics.params.iter().enumerate()\n-                .find_map(|(i, param)| {\n-                    if param.name.ident() == name {\n-                        // We also want to delete a leading or trailing comma\n-                        // as appropriate\n-                        if i >= generics.params.len() - 1 {\n-                            Some(generics.params[i-1].span.shrink_to_hi().to(param.span))\n-                        } else {\n-                            Some(param.span.to(generics.params[i+1].span.shrink_to_lo()))\n-                        }\n+            generics.params.iter().enumerate().find_map(|(i, param)| {\n+                if param.name.ident() == name {\n+                    // We also want to delete a leading or trailing comma\n+                    // as appropriate\n+                    if i >= generics.params.len() - 1 {\n+                        Some(generics.params[i - 1].span.shrink_to_hi().to(param.span))\n                     } else {\n-                        None\n+                        Some(param.span.to(generics.params[i + 1].span.shrink_to_lo()))\n                     }\n-                })\n+                } else {\n+                    None\n+                }\n+            })\n         }\n     }\n \n@@ -1435,7 +1475,8 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             }\n         };\n \n-        let mut def_ids: Vec<_> = defined_by.values()\n+        let mut def_ids: Vec<_> = defined_by\n+            .values()\n             .flat_map(|region| match region {\n                 Region::EarlyBound(_, def_id, _)\n                 | Region::LateBound(_, def_id, _)\n@@ -1449,21 +1490,28 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         def_ids.sort_by_key(|&def_id| self.tcx.def_path_hash(def_id));\n \n         for def_id in def_ids {\n-            debug!(\"check_uses_for_lifetimes_defined_by_scope: def_id = {:?}\", def_id);\n+            debug!(\n+                \"check_uses_for_lifetimes_defined_by_scope: def_id = {:?}\",\n+                def_id\n+            );\n \n             let lifetimeuseset = self.lifetime_uses.remove(&def_id);\n \n-            debug!(\"check_uses_for_lifetimes_defined_by_scope: lifetimeuseset = {:?}\",\n-                   lifetimeuseset);\n+            debug!(\n+                \"check_uses_for_lifetimes_defined_by_scope: lifetimeuseset = {:?}\",\n+                lifetimeuseset\n+            );\n \n             match lifetimeuseset {\n                 Some(LifetimeUseSet::One(lifetime)) => {\n                     let node_id = self.tcx.hir.as_local_node_id(def_id).unwrap();\n                     debug!(\"node id first={:?}\", node_id);\n                     if let Some((id, span, name)) = match self.tcx.hir.get(node_id) {\n-                        Node::Lifetime(hir_lifetime) => {\n-                            Some((hir_lifetime.id, hir_lifetime.span, hir_lifetime.name.ident()))\n-                        }\n+                        Node::Lifetime(hir_lifetime) => Some((\n+                            hir_lifetime.id,\n+                            hir_lifetime.span,\n+                            hir_lifetime.name.ident(),\n+                        )),\n                         Node::GenericParam(param) => {\n                             Some((param.id, param.span, param.name.ident()))\n                         }\n@@ -1487,9 +1535,11 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 None => {\n                     let node_id = self.tcx.hir.as_local_node_id(def_id).unwrap();\n                     if let Some((id, span, name)) = match self.tcx.hir.get(node_id) {\n-                        Node::Lifetime(hir_lifetime) => {\n-                            Some((hir_lifetime.id, hir_lifetime.span, hir_lifetime.name.ident()))\n-                        }\n+                        Node::Lifetime(hir_lifetime) => Some((\n+                            hir_lifetime.id,\n+                            hir_lifetime.span,\n+                            hir_lifetime.name.ident(),\n+                        )),\n                         Node::GenericParam(param) => {\n                             Some((param.id, param.span, param.name.ident()))\n                         }\n@@ -1500,7 +1550,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                             lint::builtin::UNUSED_LIFETIMES,\n                             id,\n                             span,\n-                            &format!(\"lifetime parameter `{}` never used\", name)\n+                            &format!(\"lifetime parameter `{}` never used\", name),\n                         );\n                         if let Some(parent_def_id) = self.tcx.parent(def_id) {\n                             if let Some(generics) = self.tcx.hir.get_generics(parent_def_id) {\n@@ -1510,7 +1560,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                                         span,\n                                         \"remove it\",\n                                         String::new(),\n-                                        Applicability::MachineApplicable\n+                                        Applicability::MachineApplicable,\n                                     );\n                                 }\n                             }\n@@ -1568,19 +1618,23 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         }\n \n         let mut type_count = 0;\n-        let lifetimes = generics.params.iter().filter_map(|param| match param.kind {\n-            GenericParamKind::Lifetime { .. } => {\n-                if self.map.late_bound.contains(&param.id) {\n-                    Some(Region::late(&self.tcx.hir, param))\n-                } else {\n-                    Some(Region::early(&self.tcx.hir, &mut index, param))\n+        let lifetimes = generics\n+            .params\n+            .iter()\n+            .filter_map(|param| match param.kind {\n+                GenericParamKind::Lifetime { .. } => {\n+                    if self.map.late_bound.contains(&param.id) {\n+                        Some(Region::late(&self.tcx.hir, param))\n+                    } else {\n+                        Some(Region::early(&self.tcx.hir, &mut index, param))\n+                    }\n                 }\n-            }\n-            GenericParamKind::Type { .. } => {\n-                type_count += 1;\n-                None\n-            }\n-        }).collect();\n+                GenericParamKind::Type { .. } => {\n+                    type_count += 1;\n+                    None\n+                }\n+            })\n+            .collect();\n         let next_early_index = index + type_count;\n \n         let scope = Scope::Binder {\n@@ -1659,7 +1713,9 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     break None;\n                 }\n \n-                Scope::Binder { ref lifetimes, s, .. } => {\n+                Scope::Binder {\n+                    ref lifetimes, s, ..\n+                } => {\n                     match lifetime_ref.name {\n                         LifetimeName::Param(param_name) => {\n                             if let Some(&def) = lifetimes.get(&param_name.modern()) {\n@@ -1716,7 +1772,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                             \"lifetimes used in `fn` or `Fn` syntax must be \\\n                              explicitly declared using `<...>` binders\"\n                         ).span_label(lifetime_ref.span, \"in-band lifetime definition\")\n-                         .emit();\n+                            .emit();\n                     }\n \n                     Region::Static\n@@ -1738,35 +1794,33 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 \"use of undeclared lifetime name `{}`\",\n                 lifetime_ref\n             ).span_label(lifetime_ref.span, \"undeclared lifetime\")\n-             .emit();\n+                .emit();\n         }\n     }\n \n-    fn visit_segment_args(\n-        &mut self,\n-        def: Def,\n-        depth: usize,\n-        generic_args: &'tcx hir::GenericArgs,\n-    ) {\n+    fn visit_segment_args(&mut self, def: Def, depth: usize, generic_args: &'tcx hir::GenericArgs) {\n         if generic_args.parenthesized {\n             let was_in_fn_syntax = self.is_in_fn_syntax;\n             self.is_in_fn_syntax = true;\n-            self.visit_fn_like_elision(generic_args.inputs(),\n-                                       Some(&generic_args.bindings[0].ty));\n+            self.visit_fn_like_elision(generic_args.inputs(), Some(&generic_args.bindings[0].ty));\n             self.is_in_fn_syntax = was_in_fn_syntax;\n             return;\n         }\n \n         let mut elide_lifetimes = true;\n-        let lifetimes = generic_args.args.iter().filter_map(|arg| match arg {\n-            hir::GenericArg::Lifetime(lt) => {\n-                if !lt.is_elided() {\n-                    elide_lifetimes = false;\n+        let lifetimes = generic_args\n+            .args\n+            .iter()\n+            .filter_map(|arg| match arg {\n+                hir::GenericArg::Lifetime(lt) => {\n+                    if !lt.is_elided() {\n+                        elide_lifetimes = false;\n+                    }\n+                    Some(lt)\n                 }\n-                Some(lt)\n-            }\n-            _ => None,\n-        }).collect();\n+                _ => None,\n+            })\n+            .collect();\n         if elide_lifetimes {\n             self.resolve_elided_lifetimes(lifetimes);\n         } else {\n@@ -1822,33 +1876,37 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 self.xcrate_object_lifetime_defaults\n                     .entry(def_id)\n                     .or_insert_with(|| {\n-                        tcx.generics_of(def_id).params.iter().filter_map(|param| {\n-                            match param.kind {\n-                                GenericParamDefKind::Type { object_lifetime_default, .. } => {\n-                                    Some(object_lifetime_default)\n-                                }\n+                        tcx.generics_of(def_id)\n+                            .params\n+                            .iter()\n+                            .filter_map(|param| match param.kind {\n+                                GenericParamDefKind::Type {\n+                                    object_lifetime_default,\n+                                    ..\n+                                } => Some(object_lifetime_default),\n                                 GenericParamDefKind::Lifetime => None,\n-                            }\n-                        }).collect()\n+                            })\n+                            .collect()\n                     })\n             };\n-            unsubst.iter()\n-                   .map(|set| match *set {\n-                       Set1::Empty => if in_body {\n-                           None\n-                       } else {\n-                           Some(Region::Static)\n-                       },\n-                       Set1::One(r) => {\n-                           let lifetimes = generic_args.args.iter().filter_map(|arg| match arg {\n-                               GenericArg::Lifetime(lt) => Some(lt),\n-                               _ => None,\n-                           });\n-                           r.subst(lifetimes, map)\n-                       }\n-                       Set1::Many => None,\n-                   })\n-                   .collect()\n+            unsubst\n+                .iter()\n+                .map(|set| match *set {\n+                    Set1::Empty => if in_body {\n+                        None\n+                    } else {\n+                        Some(Region::Static)\n+                    },\n+                    Set1::One(r) => {\n+                        let lifetimes = generic_args.args.iter().filter_map(|arg| match arg {\n+                            GenericArg::Lifetime(lt) => Some(lt),\n+                            _ => None,\n+                        });\n+                        r.subst(lifetimes, map)\n+                    }\n+                    Set1::Many => None,\n+                })\n+                .collect()\n         });\n \n         let mut i = 0;\n@@ -1875,11 +1933,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         }\n     }\n \n-    fn visit_fn_like_elision(\n-        &mut self,\n-        inputs: &'tcx [hir::Ty],\n-        output: Option<&'tcx P<hir::Ty>>,\n-    ) {\n+    fn visit_fn_like_elision(&mut self, inputs: &'tcx [hir::Ty], output: Option<&'tcx P<hir::Ty>>) {\n         debug!(\"visit_fn_like_elision: enter\");\n         let mut arg_elide = Elide::FreshLateAnon(Cell::new(0));\n         let arg_scope = Scope::Elision {\n@@ -2139,8 +2193,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         }\n     }\n \n-    fn resolve_elided_lifetimes(&mut self,\n-                                lifetime_refs: Vec<&'tcx hir::Lifetime>) {\n+    fn resolve_elided_lifetimes(&mut self, lifetime_refs: Vec<&'tcx hir::Lifetime>) {\n         if lifetime_refs.is_empty() {\n             return;\n         }\n@@ -2298,23 +2351,32 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n                 Scope::Body { .. } | Scope::ObjectLifetimeDefault { lifetime: None, .. } => return,\n \n-                Scope::ObjectLifetimeDefault { lifetime: Some(l), .. } => break l,\n+                Scope::ObjectLifetimeDefault {\n+                    lifetime: Some(l), ..\n+                } => break l,\n             }\n         };\n         self.insert_lifetime(lifetime_ref, lifetime.shifted(late_depth));\n     }\n \n-    fn check_lifetime_params(&mut self, old_scope: ScopeRef<'_>,\n-                             params: &'tcx [hir::GenericParam]) {\n-        let lifetimes: Vec<_> = params.iter().filter_map(|param| match param.kind {\n-            GenericParamKind::Lifetime { .. } => Some((param, param.name)),\n-            _ => None,\n-        }).collect();\n+    fn check_lifetime_params(\n+        &mut self,\n+        old_scope: ScopeRef<'_>,\n+        params: &'tcx [hir::GenericParam],\n+    ) {\n+        let lifetimes: Vec<_> = params\n+            .iter()\n+            .filter_map(|param| match param.kind {\n+                GenericParamKind::Lifetime { .. } => Some((param, param.name)),\n+                _ => None,\n+            })\n+            .collect();\n         for (i, (lifetime_i, lifetime_i_name)) in lifetimes.iter().enumerate() {\n             if let hir::ParamName::Plain(_) = lifetime_i_name {\n                 let name = lifetime_i_name.ident().name;\n-                if name == keywords::UnderscoreLifetime.name() ||\n-                   name == keywords::StaticLifetime.name() {\n+                if name == keywords::UnderscoreLifetime.name()\n+                    || name == keywords::StaticLifetime.name()\n+                {\n                     let mut err = struct_span_err!(\n                         self.tcx.sess,\n                         lifetime_i.span,\n@@ -2340,8 +2402,8 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                         \"lifetime name `{}` declared twice in the same scope\",\n                         lifetime_j.name.ident()\n                     ).span_label(lifetime_j.span, \"declared twice\")\n-                     .span_label(lifetime_i.span, \"previous declaration here\")\n-                     .emit();\n+                        .span_label(lifetime_i.span, \"previous declaration here\")\n+                        .emit();\n                 }\n             }\n \n@@ -2351,29 +2413,34 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             for bound in &lifetime_i.bounds {\n                 match bound {\n                     hir::GenericBound::Outlives(lt) => match lt.name {\n-                        hir::LifetimeName::Underscore => {\n-                            self.tcx.sess.delay_span_bug(lt.span, \"use of `'_` in illegal place, but not caught by lowering\")\n-                        }\n+                        hir::LifetimeName::Underscore => self.tcx.sess.delay_span_bug(\n+                            lt.span,\n+                            \"use of `'_` in illegal place, but not caught by lowering\",\n+                        ),\n                         hir::LifetimeName::Static => {\n                             self.insert_lifetime(lt, Region::Static);\n-                            self.tcx.sess.struct_span_warn(\n-                                lifetime_i.span.to(lt.span),\n-                                &format!(\n-                                    \"unnecessary lifetime parameter `{}`\",\n+                            self.tcx\n+                                .sess\n+                                .struct_span_warn(\n+                                    lifetime_i.span.to(lt.span),\n+                                    &format!(\n+                                        \"unnecessary lifetime parameter `{}`\",\n+                                        lifetime_i.name.ident(),\n+                                    ),\n+                                )\n+                                .help(&format!(\n+                                    \"you can use the `'static` lifetime directly, in place of `{}`\",\n                                     lifetime_i.name.ident(),\n-                                ),\n-                            ).help(&format!(\n-                                \"you can use the `'static` lifetime directly, in place of `{}`\",\n-                                lifetime_i.name.ident(),\n-                            )).emit();\n+                                ))\n+                                .emit();\n                         }\n                         hir::LifetimeName::Param(_) | hir::LifetimeName::Implicit => {\n                             self.resolve_lifetime_ref(lt);\n                         }\n                         hir::LifetimeName::Error => {\n                             // No need to do anything, error already reported.\n                         }\n-                    }\n+                    },\n                     _ => bug!(),\n                 }\n             }\n@@ -2542,8 +2609,10 @@ fn insert_late_bound_lifetimes(\n     decl: &hir::FnDecl,\n     generics: &hir::Generics,\n ) {\n-    debug!(\"insert_late_bound_lifetimes(decl={:?}, generics={:?})\",\n-           decl, generics);\n+    debug!(\n+        \"insert_late_bound_lifetimes(decl={:?}, generics={:?})\",\n+        decl, generics\n+    );\n \n     let mut constrained_by_input = ConstrainedCollector {\n         regions: FxHashSet(),\n@@ -2557,8 +2626,10 @@ fn insert_late_bound_lifetimes(\n     };\n     intravisit::walk_fn_ret_ty(&mut appears_in_output, &decl.output);\n \n-    debug!(\"insert_late_bound_lifetimes: constrained_by_input={:?}\",\n-           constrained_by_input.regions);\n+    debug!(\n+        \"insert_late_bound_lifetimes: constrained_by_input={:?}\",\n+        constrained_by_input.regions\n+    );\n \n     // Walk the lifetimes that appear in where clauses.\n     //\n@@ -2574,7 +2645,8 @@ fn insert_late_bound_lifetimes(\n             if !param.bounds.is_empty() {\n                 // `'a: 'b` means both `'a` and `'b` are referenced\n                 appears_in_where_clause\n-                    .regions.insert(hir::LifetimeName::Param(param.name.modern()));\n+                    .regions\n+                    .insert(hir::LifetimeName::Param(param.name.modern()));\n             }\n         }\n     }\n@@ -2609,9 +2681,11 @@ fn insert_late_bound_lifetimes(\n             continue;\n         }\n \n-        debug!(\"insert_late_bound_lifetimes: lifetime {:?} with id {:?} is late-bound\",\n-               param.name.ident(),\n-               param.id);\n+        debug!(\n+            \"insert_late_bound_lifetimes: lifetime {:?} with id {:?} is late-bound\",\n+            param.name.ident(),\n+            param.id\n+        );\n \n         let inserted = map.late_bound.insert(param.id);\n         assert!(inserted, \"visited lifetime {:?} twice\", param.id);"}]}