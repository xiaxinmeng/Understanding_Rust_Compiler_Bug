{"sha": "9d1792a4265c3645d716c5bf085c07be8749332a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlkMTc5MmE0MjY1YzM2NDVkNzE2YzViZjA4NWMwN2JlODc0OTMzMmE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-03-03T12:26:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-03-03T12:26:15Z"}, "message": "Auto merge of #3834 - ljedrz:HirIdification_fix, r=phansch\n\nHirIdification fixes\n\nSupersedes https://github.com/rust-lang/rust-clippy/pull/3828, enables https://github.com/rust-lang/rust/pull/58836.\n\nAs usual, requesting a branch.", "tree": {"sha": "58d6e4c1d348159781009d5e559b9698ad4eee5c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/58d6e4c1d348159781009d5e559b9698ad4eee5c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9d1792a4265c3645d716c5bf085c07be8749332a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9d1792a4265c3645d716c5bf085c07be8749332a", "html_url": "https://github.com/rust-lang/rust/commit/9d1792a4265c3645d716c5bf085c07be8749332a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9d1792a4265c3645d716c5bf085c07be8749332a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8dfabdf11c6cdaffd7c6e6552a6ead8d52c49b10", "url": "https://api.github.com/repos/rust-lang/rust/commits/8dfabdf11c6cdaffd7c6e6552a6ead8d52c49b10", "html_url": "https://github.com/rust-lang/rust/commit/8dfabdf11c6cdaffd7c6e6552a6ead8d52c49b10"}, {"sha": "68096cf181a792d89699369427f505100df188c1", "url": "https://api.github.com/repos/rust-lang/rust/commits/68096cf181a792d89699369427f505100df188c1", "html_url": "https://github.com/rust-lang/rust/commit/68096cf181a792d89699369427f505100df188c1"}], "stats": {"total": 230, "additions": 114, "deletions": 116}, "files": [{"sha": "3fac6e78adbe8f2fc403b5e27e5da26752db6872", "filename": "clippy_lints/src/copy_iterator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d1792a4265c3645d716c5bf085c07be8749332a/clippy_lints%2Fsrc%2Fcopy_iterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1792a4265c3645d716c5bf085c07be8749332a/clippy_lints%2Fsrc%2Fcopy_iterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fcopy_iterator.rs?ref=9d1792a4265c3645d716c5bf085c07be8749332a", "patch": "@@ -44,7 +44,7 @@ impl LintPass for CopyIterator {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for CopyIterator {\n     fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n         if let ItemKind::Impl(_, _, _, _, Some(ref trait_ref), _, _) = item.node {\n-            let ty = cx.tcx.type_of(cx.tcx.hir().local_def_id(item.id));\n+            let ty = cx.tcx.type_of(cx.tcx.hir().local_def_id_from_hir_id(item.hir_id));\n \n             if is_copy(cx, ty) && match_path(&trait_ref.path, &paths::ITERATOR) {\n                 span_note_and_lint("}, {"sha": "2460a2746e3dba772f413c3ebe56802080c50e19", "filename": "clippy_lints/src/derive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d1792a4265c3645d716c5bf085c07be8749332a/clippy_lints%2Fsrc%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1792a4265c3645d716c5bf085c07be8749332a/clippy_lints%2Fsrc%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fderive.rs?ref=9d1792a4265c3645d716c5bf085c07be8749332a", "patch": "@@ -77,7 +77,7 @@ impl LintPass for Derive {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Derive {\n     fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n         if let ItemKind::Impl(_, _, _, _, Some(ref trait_ref), _, _) = item.node {\n-            let ty = cx.tcx.type_of(cx.tcx.hir().local_def_id(item.id));\n+            let ty = cx.tcx.type_of(cx.tcx.hir().local_def_id_from_hir_id(item.hir_id));\n             let is_automatically_derived = is_automatically_derived(&*item.attrs);\n \n             check_hash_peq(cx, item.span, trait_ref, ty, is_automatically_derived);"}, {"sha": "60d83a98d51e5a94fffea9483abcd896ddc922f0", "filename": "clippy_lints/src/empty_enum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d1792a4265c3645d716c5bf085c07be8749332a/clippy_lints%2Fsrc%2Fempty_enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1792a4265c3645d716c5bf085c07be8749332a/clippy_lints%2Fsrc%2Fempty_enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fempty_enum.rs?ref=9d1792a4265c3645d716c5bf085c07be8749332a", "patch": "@@ -38,7 +38,7 @@ impl LintPass for EmptyEnum {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for EmptyEnum {\n     fn check_item(&mut self, cx: &LateContext<'_, '_>, item: &Item) {\n-        let did = cx.tcx.hir().local_def_id(item.id);\n+        let did = cx.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n         if let ItemKind::Enum(..) = item.node {\n             let ty = cx.tcx.type_of(did);\n             let adt = ty.ty_adt_def().expect(\"already checked whether this is an enum\");"}, {"sha": "45ecdc3d31034cf64b05e659951aec98a800f6f2", "filename": "clippy_lints/src/escape.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9d1792a4265c3645d716c5bf085c07be8749332a/clippy_lints%2Fsrc%2Fescape.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1792a4265c3645d716c5bf085c07be8749332a/clippy_lints%2Fsrc%2Fescape.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fescape.rs?ref=9d1792a4265c3645d716c5bf085c07be8749332a", "patch": "@@ -6,9 +6,8 @@ use rustc::middle::expr_use_visitor::*;\n use rustc::middle::mem_categorization::{cmt_, Categorization};\n use rustc::ty::layout::LayoutOf;\n use rustc::ty::{self, Ty};\n-use rustc::util::nodemap::NodeSet;\n+use rustc::util::nodemap::HirIdSet;\n use rustc::{declare_tool_lint, lint_array};\n-use syntax::ast::NodeId;\n use syntax::source_map::Span;\n \n pub struct Pass {\n@@ -44,7 +43,7 @@ fn is_non_trait_box(ty: Ty<'_>) -> bool {\n \n struct EscapeDelegate<'a, 'tcx: 'a> {\n     cx: &'a LateContext<'a, 'tcx>,\n-    set: NodeSet,\n+    set: HirIdSet,\n     too_large_for_stack: u64,\n }\n \n@@ -80,7 +79,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n \n         let mut v = EscapeDelegate {\n             cx,\n-            set: NodeSet::default(),\n+            set: HirIdSet::default(),\n             too_large_for_stack: self.too_large_for_stack,\n         };\n \n@@ -92,7 +91,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             span_lint(\n                 cx,\n                 BOXED_LOCAL,\n-                cx.tcx.hir().span(node),\n+                cx.tcx.hir().span_by_hir_id(node),\n                 \"local variable doesn't need to be boxed here\",\n             );\n         }\n@@ -111,13 +110,13 @@ impl<'a, 'tcx> Delegate<'tcx> for EscapeDelegate<'a, 'tcx> {\n     fn matched_pat(&mut self, _: &Pat, _: &cmt_<'tcx>, _: MatchMode) {}\n     fn consume_pat(&mut self, consume_pat: &Pat, cmt: &cmt_<'tcx>, _: ConsumeMode) {\n         let map = &self.cx.tcx.hir();\n-        if map.is_argument(consume_pat.id) {\n+        if map.is_argument(map.hir_to_node_id(consume_pat.hir_id)) {\n             // Skip closure arguments\n-            if let Some(Node::Expr(..)) = map.find(map.get_parent_node(consume_pat.id)) {\n+            if let Some(Node::Expr(..)) = map.find_by_hir_id(map.get_parent_node_by_hir_id(consume_pat.hir_id)) {\n                 return;\n             }\n             if is_non_trait_box(cmt.ty) && !self.is_large_box(cmt.ty) {\n-                self.set.insert(consume_pat.id);\n+                self.set.insert(consume_pat.hir_id);\n             }\n             return;\n         }\n@@ -129,7 +128,7 @@ impl<'a, 'tcx> Delegate<'tcx> for EscapeDelegate<'a, 'tcx> {\n                         if let ExprKind::Box(..) = ex.node {\n                             if is_non_trait_box(cmt.ty) && !self.is_large_box(cmt.ty) {\n                                 // let x = box (...)\n-                                self.set.insert(consume_pat.id);\n+                                self.set.insert(consume_pat.hir_id);\n                             }\n                             // TODO Box::new\n                             // TODO vec![]\n@@ -143,7 +142,7 @@ impl<'a, 'tcx> Delegate<'tcx> for EscapeDelegate<'a, 'tcx> {\n             if self.set.contains(&lid) {\n                 // let y = x where x is known\n                 // remove x, insert y\n-                self.set.insert(consume_pat.id);\n+                self.set.insert(consume_pat.hir_id);\n                 self.set.remove(&lid);\n             }\n         }\n@@ -177,7 +176,7 @@ impl<'a, 'tcx> Delegate<'tcx> for EscapeDelegate<'a, 'tcx> {\n             }\n         }\n     }\n-    fn decl_without_init(&mut self, _: NodeId, _: Span) {}\n+    fn decl_without_init(&mut self, _: HirId, _: Span) {}\n     fn mutate(&mut self, _: HirId, _: Span, _: &cmt_<'tcx>, _: MutateMode) {}\n }\n "}, {"sha": "48d4db53d32e28d69df5d57c50ac5b15299e8785", "filename": "clippy_lints/src/fallible_impl_from.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9d1792a4265c3645d716c5bf085c07be8749332a/clippy_lints%2Fsrc%2Ffallible_impl_from.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1792a4265c3645d716c5bf085c07be8749332a/clippy_lints%2Fsrc%2Ffallible_impl_from.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffallible_impl_from.rs?ref=9d1792a4265c3645d716c5bf085c07be8749332a", "patch": "@@ -43,7 +43,7 @@ impl LintPass for FallibleImplFrom {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for FallibleImplFrom {\n     fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx hir::Item) {\n         // check for `impl From<???> for ..`\n-        let impl_def_id = cx.tcx.hir().local_def_id(item.id);\n+        let impl_def_id = cx.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n         if_chain! {\n             if let hir::ItemKind::Impl(.., ref impl_items) = item.node;\n             if let Some(impl_trait_ref) = cx.tcx.impl_trait_ref(impl_def_id);\n@@ -105,7 +105,7 @@ fn lint_impl_body<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, impl_span: Span, impl_it\n             then {\n                 // check the body for `begin_panic` or `unwrap`\n                 let body = cx.tcx.hir().body(body_id);\n-                let impl_item_def_id = cx.tcx.hir().local_def_id(impl_item.id.node_id);\n+                let impl_item_def_id = cx.tcx.hir().local_def_id_from_hir_id(impl_item.id.hir_id);\n                 let mut fpu = FindPanicUnwrap {\n                     tcx: cx.tcx,\n                     tables: cx.tcx.typeck_tables_of(impl_item_def_id),"}, {"sha": "1a9089b55d77f000d45b54166d491b7101057450", "filename": "clippy_lints/src/functions.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9d1792a4265c3645d716c5bf085c07be8749332a/clippy_lints%2Fsrc%2Ffunctions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1792a4265c3645d716c5bf085c07be8749332a/clippy_lints%2Fsrc%2Ffunctions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ffunctions.rs?ref=9d1792a4265c3645d716c5bf085c07be8749332a", "patch": "@@ -150,8 +150,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Functions {\n             }\n         }\n \n-        let nodeid = cx.tcx.hir().hir_to_node_id(hir_id);\n-        self.check_raw_ptr(cx, unsafety, decl, body, nodeid);\n+        self.check_raw_ptr(cx, unsafety, decl, body, hir_id);\n         self.check_line_number(cx, span, body);\n     }\n \n@@ -164,7 +163,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Functions {\n \n             if let hir::TraitMethod::Provided(eid) = *eid {\n                 let body = cx.tcx.hir().body(eid);\n-                self.check_raw_ptr(cx, sig.header.unsafety, &sig.decl, body, item.id);\n+                self.check_raw_ptr(cx, sig.header.unsafety, &sig.decl, body, item.hir_id);\n             }\n         }\n     }\n@@ -255,10 +254,11 @@ impl<'a, 'tcx> Functions {\n         unsafety: hir::Unsafety,\n         decl: &'tcx hir::FnDecl,\n         body: &'tcx hir::Body,\n-        nodeid: ast::NodeId,\n+        hir_id: hir::HirId,\n     ) {\n         let expr = &body.value;\n-        if unsafety == hir::Unsafety::Normal && cx.access_levels.is_exported(nodeid) {\n+        let node_id = cx.tcx.hir().hir_to_node_id(hir_id);\n+        if unsafety == hir::Unsafety::Normal && cx.access_levels.is_exported(node_id) {\n             let raw_ptrs = iter_input_pats(decl, body)\n                 .zip(decl.inputs.iter())\n                 .filter_map(|(arg, ty)| raw_ptr_arg(arg, ty))"}, {"sha": "7a1a0e599c1404a00c3831e931eef73db9db7170", "filename": "clippy_lints/src/large_enum_variant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d1792a4265c3645d716c5bf085c07be8749332a/clippy_lints%2Fsrc%2Flarge_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1792a4265c3645d716c5bf085c07be8749332a/clippy_lints%2Fsrc%2Flarge_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flarge_enum_variant.rs?ref=9d1792a4265c3645d716c5bf085c07be8749332a", "patch": "@@ -54,7 +54,7 @@ impl LintPass for LargeEnumVariant {\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LargeEnumVariant {\n     fn check_item(&mut self, cx: &LateContext<'_, '_>, item: &Item) {\n-        let did = cx.tcx.hir().local_def_id(item.id);\n+        let did = cx.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n         if let ItemKind::Enum(ref def, _) = item.node {\n             let ty = cx.tcx.type_of(did);\n             let adt = ty.ty_adt_def().expect(\"already checked whether this is an enum\");"}, {"sha": "094cfcf1b1f654b92118133a40a241b45799a990", "filename": "clippy_lints/src/len_zero.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9d1792a4265c3645d716c5bf085c07be8749332a/clippy_lints%2Fsrc%2Flen_zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1792a4265c3645d716c5bf085c07be8749332a/clippy_lints%2Fsrc%2Flen_zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Flen_zero.rs?ref=9d1792a4265c3645d716c5bf085c07be8749332a", "patch": "@@ -132,7 +132,7 @@ fn check_trait_items(cx: &LateContext<'_, '_>, visited_trait: &Item, trait_items\n         item.ident.name == name\n             && if let AssociatedItemKind::Method { has_self } = item.kind {\n                 has_self && {\n-                    let did = cx.tcx.hir().local_def_id(item.id.node_id);\n+                    let did = cx.tcx.hir().local_def_id_from_hir_id(item.id.hir_id);\n                     cx.tcx.fn_sig(did).inputs().skip_binder().len() == 1\n                 }\n             } else {\n@@ -149,9 +149,11 @@ fn check_trait_items(cx: &LateContext<'_, '_>, visited_trait: &Item, trait_items\n         }\n     }\n \n-    if cx.access_levels.is_exported(visited_trait.id) && trait_items.iter().any(|i| is_named_self(cx, i, \"len\")) {\n+    let trait_node_id = cx.tcx.hir().hir_to_node_id(visited_trait.hir_id);\n+\n+    if cx.access_levels.is_exported(trait_node_id) && trait_items.iter().any(|i| is_named_self(cx, i, \"len\")) {\n         let mut current_and_super_traits = FxHashSet::default();\n-        let visited_trait_def_id = cx.tcx.hir().local_def_id(visited_trait.id);\n+        let visited_trait_def_id = cx.tcx.hir().local_def_id_from_hir_id(visited_trait.hir_id);\n         fill_trait_set(visited_trait_def_id, &mut current_and_super_traits, cx);\n \n         let is_empty_method_found = current_and_super_traits\n@@ -183,7 +185,7 @@ fn check_impl_items(cx: &LateContext<'_, '_>, item: &Item, impl_items: &[ImplIte\n         item.ident.name == name\n             && if let AssociatedItemKind::Method { has_self } = item.kind {\n                 has_self && {\n-                    let did = cx.tcx.hir().local_def_id(item.id.node_id);\n+                    let did = cx.tcx.hir().local_def_id_from_hir_id(item.id.hir_id);\n                     cx.tcx.fn_sig(did).inputs().skip_binder().len() == 1\n                 }\n             } else {\n@@ -192,7 +194,10 @@ fn check_impl_items(cx: &LateContext<'_, '_>, item: &Item, impl_items: &[ImplIte\n     }\n \n     let is_empty = if let Some(is_empty) = impl_items.iter().find(|i| is_named_self(cx, i, \"is_empty\")) {\n-        if cx.access_levels.is_exported(is_empty.id.node_id) {\n+        if cx\n+            .access_levels\n+            .is_exported(cx.tcx.hir().hir_to_node_id(is_empty.id.hir_id))\n+        {\n             return;\n         } else {\n             \"a private\"\n@@ -202,8 +207,8 @@ fn check_impl_items(cx: &LateContext<'_, '_>, item: &Item, impl_items: &[ImplIte\n     };\n \n     if let Some(i) = impl_items.iter().find(|i| is_named_self(cx, i, \"len\")) {\n-        if cx.access_levels.is_exported(i.id.node_id) {\n-            let def_id = cx.tcx.hir().local_def_id(item.id);\n+        if cx.access_levels.is_exported(cx.tcx.hir().hir_to_node_id(i.id.hir_id)) {\n+            let def_id = cx.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n             let ty = cx.tcx.type_of(def_id);\n \n             span_lint("}, {"sha": "811e7fc6c6338f5d90f47d2e67057cbe4ab5857a", "filename": "clippy_lints/src/loops.rs", "status": "modified", "additions": 23, "deletions": 24, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/9d1792a4265c3645d716c5bf085c07be8749332a/clippy_lints%2Fsrc%2Floops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1792a4265c3645d716c5bf085c07be8749332a/clippy_lints%2Fsrc%2Floops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Floops.rs?ref=9d1792a4265c3645d716c5bf085c07be8749332a", "patch": "@@ -1562,8 +1562,8 @@ fn check_for_loop_over_map_kv<'a, 'tcx>(\n }\n \n struct MutatePairDelegate {\n-    node_id_low: Option<NodeId>,\n-    node_id_high: Option<NodeId>,\n+    hir_id_low: Option<HirId>,\n+    hir_id_high: Option<HirId>,\n     span_low: Option<Span>,\n     span_high: Option<Span>,\n }\n@@ -1578,10 +1578,10 @@ impl<'tcx> Delegate<'tcx> for MutatePairDelegate {\n     fn borrow(&mut self, _: HirId, sp: Span, cmt: &cmt_<'tcx>, _: ty::Region<'_>, bk: ty::BorrowKind, _: LoanCause) {\n         if let ty::BorrowKind::MutBorrow = bk {\n             if let Categorization::Local(id) = cmt.cat {\n-                if Some(id) == self.node_id_low {\n+                if Some(id) == self.hir_id_low {\n                     self.span_low = Some(sp)\n                 }\n-                if Some(id) == self.node_id_high {\n+                if Some(id) == self.hir_id_high {\n                     self.span_high = Some(sp)\n                 }\n             }\n@@ -1590,16 +1590,16 @@ impl<'tcx> Delegate<'tcx> for MutatePairDelegate {\n \n     fn mutate(&mut self, _: HirId, sp: Span, cmt: &cmt_<'tcx>, _: MutateMode) {\n         if let Categorization::Local(id) = cmt.cat {\n-            if Some(id) == self.node_id_low {\n+            if Some(id) == self.hir_id_low {\n                 self.span_low = Some(sp)\n             }\n-            if Some(id) == self.node_id_high {\n+            if Some(id) == self.hir_id_high {\n                 self.span_high = Some(sp)\n             }\n         }\n     }\n \n-    fn decl_without_init(&mut self, _: NodeId, _: Span) {}\n+    fn decl_without_init(&mut self, _: HirId, _: Span) {}\n }\n \n impl<'tcx> MutatePairDelegate {\n@@ -1635,7 +1635,7 @@ fn mut_warn_with_span(cx: &LateContext<'_, '_>, span: Option<Span>) {\n     }\n }\n \n-fn check_for_mutability(cx: &LateContext<'_, '_>, bound: &Expr) -> Option<NodeId> {\n+fn check_for_mutability(cx: &LateContext<'_, '_>, bound: &Expr) -> Option<HirId> {\n     if_chain! {\n         if let ExprKind::Path(ref qpath) = bound.node;\n         if let QPath::Resolved(None, _) = *qpath;\n@@ -1648,7 +1648,7 @@ fn check_for_mutability(cx: &LateContext<'_, '_>, bound: &Expr) -> Option<NodeId\n                     if let PatKind::Binding(bind_ann, ..) = pat.node;\n                     if let BindingAnnotation::Mutable = bind_ann;\n                     then {\n-                        return Some(node_id);\n+                        return Some(cx.tcx.hir().node_to_hir_id(node_id));\n                     }\n                 }\n             }\n@@ -1660,11 +1660,11 @@ fn check_for_mutability(cx: &LateContext<'_, '_>, bound: &Expr) -> Option<NodeId\n fn check_for_mutation(\n     cx: &LateContext<'_, '_>,\n     body: &Expr,\n-    bound_ids: &[Option<NodeId>],\n+    bound_ids: &[Option<HirId>],\n ) -> (Option<Span>, Option<Span>) {\n     let mut delegate = MutatePairDelegate {\n-        node_id_low: bound_ids[0],\n-        node_id_high: bound_ids[1],\n+        hir_id_low: bound_ids[0],\n+        hir_id_high: bound_ids[1],\n         span_low: None,\n         span_high: None,\n     };\n@@ -1938,16 +1938,15 @@ fn is_iterator_used_after_while_let<'a, 'tcx: 'a>(cx: &LateContext<'a, 'tcx>, it\n         past_while_let: false,\n         var_used_after_while_let: false,\n     };\n-    let def_hir_id = cx.tcx.hir().node_to_hir_id(def_id);\n-    if let Some(enclosing_block) = get_enclosing_block(cx, def_hir_id) {\n+    if let Some(enclosing_block) = get_enclosing_block(cx, def_id) {\n         walk_block(&mut visitor, enclosing_block);\n     }\n     visitor.var_used_after_while_let\n }\n \n struct VarUsedAfterLoopVisitor<'a, 'tcx: 'a> {\n     cx: &'a LateContext<'a, 'tcx>,\n-    def_id: NodeId,\n+    def_id: HirId,\n     iter_expr_id: HirId,\n     past_while_let: bool,\n     var_used_after_while_let: bool,\n@@ -2052,9 +2051,9 @@ enum VarState {\n \n /// Scan a for loop for variables that are incremented exactly once.\n struct IncrementVisitor<'a, 'tcx: 'a> {\n-    cx: &'a LateContext<'a, 'tcx>,       // context reference\n-    states: FxHashMap<NodeId, VarState>, // incremented variables\n-    depth: u32,                          // depth of conditional expressions\n+    cx: &'a LateContext<'a, 'tcx>,      // context reference\n+    states: FxHashMap<HirId, VarState>, // incremented variables\n+    depth: u32,                         // depth of conditional expressions\n     done: bool,\n }\n \n@@ -2108,7 +2107,7 @@ impl<'a, 'tcx> Visitor<'tcx> for IncrementVisitor<'a, 'tcx> {\n struct InitializeVisitor<'a, 'tcx: 'a> {\n     cx: &'a LateContext<'a, 'tcx>, // context reference\n     end_expr: &'tcx Expr,          // the for loop. Stop scanning here.\n-    var_id: NodeId,\n+    var_id: HirId,\n     state: VarState,\n     name: Option<Name>,\n     depth: u32, // depth of conditional expressions\n@@ -2119,7 +2118,7 @@ impl<'a, 'tcx> Visitor<'tcx> for InitializeVisitor<'a, 'tcx> {\n     fn visit_stmt(&mut self, stmt: &'tcx Stmt) {\n         // Look for declarations of the variable\n         if let StmtKind::Local(ref local) = stmt.node {\n-            if local.pat.id == self.var_id {\n+            if local.pat.hir_id == self.var_id {\n                 if let PatKind::Binding(.., ident, _) = local.pat.node {\n                     self.name = Some(ident.name);\n \n@@ -2191,11 +2190,11 @@ impl<'a, 'tcx> Visitor<'tcx> for InitializeVisitor<'a, 'tcx> {\n     }\n }\n \n-fn var_def_id(cx: &LateContext<'_, '_>, expr: &Expr) -> Option<NodeId> {\n+fn var_def_id(cx: &LateContext<'_, '_>, expr: &Expr) -> Option<HirId> {\n     if let ExprKind::Path(ref qpath) = expr.node {\n         let path_res = cx.tables.qpath_def(qpath, expr.hir_id);\n         if let Def::Local(node_id) = path_res {\n-            return Some(node_id);\n+            return Some(cx.tcx.hir().node_to_hir_id(node_id));\n         }\n     }\n     None\n@@ -2376,7 +2375,7 @@ fn check_infinite_loop<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, cond: &'tcx Expr, e\n /// All variables definition IDs are collected\n struct VarCollectorVisitor<'a, 'tcx: 'a> {\n     cx: &'a LateContext<'a, 'tcx>,\n-    ids: FxHashSet<NodeId>,\n+    ids: FxHashSet<HirId>,\n     def_ids: FxHashMap<def_id::DefId, bool>,\n     skip: bool,\n }\n@@ -2390,7 +2389,7 @@ impl<'a, 'tcx> VarCollectorVisitor<'a, 'tcx> {\n             then {\n                 match def {\n                     Def::Local(node_id) | Def::Upvar(node_id, ..) => {\n-                        self.ids.insert(node_id);\n+                        self.ids.insert(self.cx.tcx.hir().node_to_hir_id(node_id));\n                     },\n                     Def::Static(def_id, mutable) => {\n                         self.def_ids.insert(def_id, mutable);"}, {"sha": "deaf054aec7dd5189606e8d2005b8848da8a5374", "filename": "clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9d1792a4265c3645d716c5bf085c07be8749332a/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1792a4265c3645d716c5bf085c07be8749332a/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=9d1792a4265c3645d716c5bf085c07be8749332a", "patch": "@@ -907,17 +907,18 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             return;\n         }\n         let name = implitem.ident.name;\n-        let parent = cx.tcx.hir().get_parent(implitem.id);\n-        let item = cx.tcx.hir().expect_item(parent);\n-        let def_id = cx.tcx.hir().local_def_id(item.id);\n+        let parent = cx.tcx.hir().get_parent_item(implitem.hir_id);\n+        let item = cx.tcx.hir().expect_item_by_hir_id(parent);\n+        let def_id = cx.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n         let ty = cx.tcx.type_of(def_id);\n         if_chain! {\n             if let hir::ImplItemKind::Method(ref sig, id) = implitem.node;\n             if let Some(first_arg_ty) = sig.decl.inputs.get(0);\n             if let Some(first_arg) = iter_input_pats(&sig.decl, cx.tcx.hir().body(id)).next();\n             if let hir::ItemKind::Impl(_, _, _, _, None, ref self_ty, _) = item.node;\n             then {\n-                if cx.access_levels.is_exported(implitem.id) {\n+                let node_id = cx.tcx.hir().hir_to_node_id(implitem.hir_id);\n+                if cx.access_levels.is_exported(node_id) {\n                 // check missing trait implementations\n                     for &(method_name, n_args, self_kind, out_type, trait_name) in &TRAIT_METHODS {\n                         if name == method_name &&\n@@ -964,7 +965,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n         }\n \n         if let hir::ImplItemKind::Method(_, _) = implitem.node {\n-            let ret_ty = return_ty(cx, implitem.id);\n+            let ret_ty = return_ty(cx, implitem.hir_id);\n \n             // walk the return type and check for Self (this does not check associated types)\n             for inner_type in ret_ty.walk() {"}, {"sha": "c081384db4b82a320f7392b6cb3b143f6524df13", "filename": "clippy_lints/src/methods/unnecessary_filter_map.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9d1792a4265c3645d716c5bf085c07be8749332a/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1792a4265c3645d716c5bf085c07be8749332a/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmethods%2Funnecessary_filter_map.rs?ref=9d1792a4265c3645d716c5bf085c07be8749332a", "patch": "@@ -5,7 +5,6 @@ use rustc::hir;\n use rustc::hir::def::Def;\n use rustc::hir::intravisit::{walk_expr, NestedVisitorMap, Visitor};\n use rustc::lint::LateContext;\n-use syntax::ast;\n \n use if_chain::if_chain;\n \n@@ -18,7 +17,7 @@ pub(super) fn lint(cx: &LateContext<'_, '_>, expr: &hir::Expr, args: &[hir::Expr\n \n     if let hir::ExprKind::Closure(_, _, body_id, ..) = args[1].node {\n         let body = cx.tcx.hir().body(body_id);\n-        let arg_id = body.arguments[0].pat.id;\n+        let arg_id = body.arguments[0].pat.hir_id;\n         let mutates_arg = match mutated_variables(&body.value, cx) {\n             Some(used_mutably) => used_mutably.contains(&arg_id),\n             None => true,\n@@ -56,7 +55,7 @@ pub(super) fn lint(cx: &LateContext<'_, '_>, expr: &hir::Expr, args: &[hir::Expr\n // returns (found_mapping, found_filtering)\n fn check_expression<'a, 'tcx: 'a>(\n     cx: &'a LateContext<'a, 'tcx>,\n-    arg_id: ast::NodeId,\n+    arg_id: hir::HirId,\n     expr: &'tcx hir::Expr,\n ) -> (bool, bool) {\n     match &expr.node {\n@@ -69,7 +68,7 @@ fn check_expression<'a, 'tcx: 'a>(\n                             if let hir::ExprKind::Path(path) = &args[0].node;\n                             if let Def::Local(ref local) = cx.tables.qpath_def(path, args[0].hir_id);\n                             then {\n-                                if arg_id == *local {\n+                                if arg_id == cx.tcx.hir().node_to_hir_id(*local) {\n                                     return (false, false)\n                                 }\n                             }\n@@ -113,15 +112,15 @@ fn check_expression<'a, 'tcx: 'a>(\n \n struct ReturnVisitor<'a, 'tcx: 'a> {\n     cx: &'a LateContext<'a, 'tcx>,\n-    arg_id: ast::NodeId,\n+    arg_id: hir::HirId,\n     // Found a non-None return that isn't Some(input)\n     found_mapping: bool,\n     // Found a return that isn't Some\n     found_filtering: bool,\n }\n \n impl<'a, 'tcx: 'a> ReturnVisitor<'a, 'tcx> {\n-    fn new(cx: &'a LateContext<'a, 'tcx>, arg_id: ast::NodeId) -> ReturnVisitor<'a, 'tcx> {\n+    fn new(cx: &'a LateContext<'a, 'tcx>, arg_id: hir::HirId) -> ReturnVisitor<'a, 'tcx> {\n         ReturnVisitor {\n             cx,\n             arg_id,"}, {"sha": "8c5c1f65280fc98e40c76749f51aea2b07c7368e", "filename": "clippy_lints/src/missing_doc.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9d1792a4265c3645d716c5bf085c07be8749332a/clippy_lints%2Fsrc%2Fmissing_doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1792a4265c3645d716c5bf085c07be8749332a/clippy_lints%2Fsrc%2Fmissing_doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_doc.rs?ref=9d1792a4265c3645d716c5bf085c07be8749332a", "patch": "@@ -124,7 +124,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n             hir::ItemKind::Fn(..) => {\n                 // ignore main()\n                 if it.ident.name == \"main\" {\n-                    let def_id = cx.tcx.hir().local_def_id(it.id);\n+                    let def_id = cx.tcx.hir().local_def_id_from_hir_id(it.hir_id);\n                     let def_key = cx.tcx.hir().def_key(def_id);\n                     if def_key.parent == Some(hir::def_id::CRATE_DEF_INDEX) {\n                         return;\n@@ -162,7 +162,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n \n     fn check_impl_item(&mut self, cx: &LateContext<'a, 'tcx>, impl_item: &'tcx hir::ImplItem) {\n         // If the method is an impl for a trait, don't doc.\n-        let def_id = cx.tcx.hir().local_def_id(impl_item.id);\n+        let def_id = cx.tcx.hir().local_def_id_from_hir_id(impl_item.hir_id);\n         match cx.tcx.associated_item(def_id).container {\n             ty::TraitContainer(_) => return,\n             ty::ImplContainer(cid) => {"}, {"sha": "2a7a211f26cb2d085e29046773a226b25c686e04", "filename": "clippy_lints/src/missing_inline.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9d1792a4265c3645d716c5bf085c07be8749332a/clippy_lints%2Fsrc%2Fmissing_inline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1792a4265c3645d716c5bf085c07be8749332a/clippy_lints%2Fsrc%2Fmissing_inline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fmissing_inline.rs?ref=9d1792a4265c3645d716c5bf085c07be8749332a", "patch": "@@ -95,7 +95,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingInline {\n             return;\n         }\n \n-        if !cx.access_levels.is_exported(it.id) {\n+        if !cx.access_levels.is_exported(cx.tcx.hir().hir_to_node_id(it.hir_id)) {\n             return;\n         }\n         match it.node {\n@@ -115,7 +115,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingInline {\n                                 // trait method with default body needs inline in case\n                                 // an impl is not provided\n                                 let desc = \"a default trait method\";\n-                                let item = cx.tcx.hir().expect_trait_item(tit.id.node_id);\n+                                let item = cx.tcx.hir().expect_trait_item_by_hir_id(tit.id.hir_id);\n                                 check_missing_inline_attrs(cx, &item.attrs, item.span, desc);\n                             }\n                         },\n@@ -146,7 +146,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingInline {\n         }\n \n         // If the item being implemented is not exported, then we don't need #[inline]\n-        if !cx.access_levels.is_exported(impl_item.id) {\n+        let node_id = cx.tcx.hir().hir_to_node_id(impl_item.hir_id);\n+        if !cx.access_levels.is_exported(node_id) {\n             return;\n         }\n \n@@ -155,7 +156,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingInline {\n             hir::ImplItemKind::Const(..) | hir::ImplItemKind::Type(_) | hir::ImplItemKind::Existential(_) => return,\n         };\n \n-        let def_id = cx.tcx.hir().local_def_id(impl_item.id);\n+        let def_id = cx.tcx.hir().local_def_id_from_hir_id(impl_item.hir_id);\n         let trait_def_id = match cx.tcx.associated_item(def_id).container {\n             TraitContainer(cid) => Some(cid),\n             ImplContainer(cid) => cx.tcx.impl_trait_ref(cid).map(|t| t.def_id),"}, {"sha": "91e3918731202b8bd9158410ac4b737cc6cdfe52", "filename": "clippy_lints/src/needless_borrow.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9d1792a4265c3645d716c5bf085c07be8749332a/clippy_lints%2Fsrc%2Fneedless_borrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1792a4265c3645d716c5bf085c07be8749332a/clippy_lints%2Fsrc%2Fneedless_borrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_borrow.rs?ref=9d1792a4265c3645d716c5bf085c07be8749332a", "patch": "@@ -4,13 +4,12 @@\n \n use crate::utils::{in_macro, snippet_opt, span_lint_and_then};\n use if_chain::if_chain;\n-use rustc::hir::{BindingAnnotation, Expr, ExprKind, Item, MutImmutable, Pat, PatKind};\n+use rustc::hir::{BindingAnnotation, Expr, ExprKind, HirId, Item, MutImmutable, Pat, PatKind};\n use rustc::lint::{LateContext, LateLintPass, LintArray, LintPass};\n use rustc::ty;\n use rustc::ty::adjustment::{Adjust, Adjustment};\n use rustc::{declare_tool_lint, lint_array};\n use rustc_errors::Applicability;\n-use syntax::ast::NodeId;\n \n /// **What it does:** Checks for address of operations (`&`) that are going to\n /// be dereferenced immediately by the compiler.\n@@ -32,7 +31,7 @@ declare_clippy_lint! {\n \n #[derive(Default)]\n pub struct NeedlessBorrow {\n-    derived_item: Option<NodeId>,\n+    derived_item: Option<HirId>,\n }\n \n impl LintPass for NeedlessBorrow {\n@@ -119,13 +118,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessBorrow {\n     fn check_item(&mut self, _: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n         if item.attrs.iter().any(|a| a.check_name(\"automatically_derived\")) {\n             debug_assert!(self.derived_item.is_none());\n-            self.derived_item = Some(item.id);\n+            self.derived_item = Some(item.hir_id);\n         }\n     }\n \n     fn check_item_post(&mut self, _: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n         if let Some(id) = self.derived_item {\n-            if item.id == id {\n+            if item.hir_id == id {\n                 self.derived_item = None;\n             }\n         }"}, {"sha": "43343bcfabf18ffc21f7df514a8fb887f211ebad", "filename": "clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9d1792a4265c3645d716c5bf085c07be8749332a/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1792a4265c3645d716c5bf085c07be8749332a/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=9d1792a4265c3645d716c5bf085c07be8749332a", "patch": "@@ -17,7 +17,6 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::Applicability;\n use rustc_target::spec::abi::Abi;\n use std::borrow::Cow;\n-use syntax::ast::NodeId;\n use syntax::errors::DiagnosticBuilder;\n use syntax_pos::Span;\n \n@@ -210,7 +209,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n                 if !implements_borrow_trait;\n                 if !all_borrowable_trait;\n \n-                if let PatKind::Binding(mode, canonical_id, ..) = arg.pat.node;\n+                if let PatKind::Binding(mode, _, canonical_id, ..) = arg.pat.node;\n                 if !moved_vars.contains(&canonical_id);\n                 then {\n                     if mode == BindingAnnotation::Mutable || mode == BindingAnnotation::RefMut {\n@@ -326,10 +325,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NeedlessPassByValue {\n \n struct MovedVariablesCtxt<'a, 'tcx: 'a> {\n     cx: &'a LateContext<'a, 'tcx>,\n-    moved_vars: FxHashSet<NodeId>,\n+    moved_vars: FxHashSet<HirId>,\n     /// Spans which need to be prefixed with `*` for dereferencing the\n     /// suggested additional reference.\n-    spans_need_deref: FxHashMap<NodeId, FxHashSet<Span>>,\n+    spans_need_deref: FxHashMap<HirId, FxHashSet<Span>>,\n }\n \n impl<'a, 'tcx> MovedVariablesCtxt<'a, 'tcx> {\n@@ -353,16 +352,16 @@ impl<'a, 'tcx> MovedVariablesCtxt<'a, 'tcx> {\n         let cmt = unwrap_downcast_or_interior(cmt);\n \n         if let mc::Categorization::Local(vid) = cmt.cat {\n-            let mut id = matched_pat.id;\n+            let mut id = matched_pat.hir_id;\n             loop {\n-                let parent = self.cx.tcx.hir().get_parent_node(id);\n+                let parent = self.cx.tcx.hir().get_parent_node_by_hir_id(id);\n                 if id == parent {\n                     // no parent\n                     return;\n                 }\n                 id = parent;\n \n-                if let Some(node) = self.cx.tcx.hir().find(id) {\n+                if let Some(node) = self.cx.tcx.hir().find_by_hir_id(id) {\n                     match node {\n                         Node::Expr(e) => {\n                             // `match` and `if let`\n@@ -432,7 +431,7 @@ impl<'a, 'tcx> euv::Delegate<'tcx> for MovedVariablesCtxt<'a, 'tcx> {\n \n     fn mutate(&mut self, _: HirId, _: Span, _: &mc::cmt_<'tcx>, _: euv::MutateMode) {}\n \n-    fn decl_without_init(&mut self, _: NodeId, _: Span) {}\n+    fn decl_without_init(&mut self, _: HirId, _: Span) {}\n }\n \n fn unwrap_downcast_or_interior<'a, 'tcx>(mut cmt: &'a mc::cmt_<'tcx>) -> mc::cmt_<'tcx> {"}, {"sha": "fe992d3cf22c0f5b46c90b5de126d3c012c2b2c0", "filename": "clippy_lints/src/new_without_default.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d1792a4265c3645d716c5bf085c07be8749332a/clippy_lints%2Fsrc%2Fnew_without_default.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1792a4265c3645d716c5bf085c07be8749332a/clippy_lints%2Fsrc%2Fnew_without_default.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnew_without_default.rs?ref=9d1792a4265c3645d716c5bf085c07be8749332a", "patch": "@@ -133,7 +133,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NewWithoutDefault {\n                             let self_did = cx.tcx.hir().local_def_id_from_hir_id(cx.tcx.hir().get_parent_item(id));\n                             let self_ty = cx.tcx.type_of(self_did);\n                             if_chain! {\n-                                if same_tys(cx, self_ty, return_ty(cx, node_id));\n+                                if same_tys(cx, self_ty, return_ty(cx, id));\n                                 if let Some(default_trait_id) = get_trait_def_id(cx, &paths::DEFAULT_TRAIT);\n                                 then {\n                                     if self.impling_types.is_none() {"}, {"sha": "34a4a7eb2f72db4a5f79a0590aa81e7435abab75", "filename": "clippy_lints/src/non_copy_const.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9d1792a4265c3645d716c5bf085c07be8749332a/clippy_lints%2Fsrc%2Fnon_copy_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1792a4265c3645d716c5bf085c07be8749332a/clippy_lints%2Fsrc%2Fnon_copy_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fnon_copy_const.rs?ref=9d1792a4265c3645d716c5bf085c07be8749332a", "patch": "@@ -177,8 +177,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonCopyConst {\n \n     fn check_impl_item(&mut self, cx: &LateContext<'a, 'tcx>, impl_item: &'tcx ImplItem) {\n         if let ImplItemKind::Const(hir_ty, ..) = &impl_item.node {\n-            let item_node_id = cx.tcx.hir().get_parent_node(impl_item.id);\n-            let item = cx.tcx.hir().expect_item(item_node_id);\n+            let item_hir_id = cx.tcx.hir().get_parent_node_by_hir_id(impl_item.hir_id);\n+            let item = cx.tcx.hir().expect_item_by_hir_id(item_hir_id);\n             // ensure the impl is an inherent impl.\n             if let ItemKind::Impl(_, _, _, _, None, _, _) = item.node {\n                 let ty = hir_ty_to_ty(cx.tcx, hir_ty);"}, {"sha": "5c532516b94367d20ce4754c091c625a94124d6a", "filename": "clippy_lints/src/partialeq_ne_impl.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9d1792a4265c3645d716c5bf085c07be8749332a/clippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1792a4265c3645d716c5bf085c07be8749332a/clippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fpartialeq_ne_impl.rs?ref=9d1792a4265c3645d716c5bf085c07be8749332a", "patch": "@@ -51,11 +51,10 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for Pass {\n             then {\n                 for impl_item in impl_items {\n                     if impl_item.ident.name == \"ne\" {\n-                        let hir_id = cx.tcx.hir().node_to_hir_id(impl_item.id.node_id);\n                         span_lint_node(\n                             cx,\n                             PARTIALEQ_NE_IMPL,\n-                            hir_id,\n+                            impl_item.id.hir_id,\n                             impl_item.span,\n                             \"re-implementing `PartialEq::ne` is unnecessary\",\n                         );"}, {"sha": "e930aae1040bd5e3d36d5c6e525521cfa97a6464", "filename": "clippy_lints/src/ptr.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/9d1792a4265c3645d716c5bf085c07be8749332a/clippy_lints%2Fsrc%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1792a4265c3645d716c5bf085c07be8749332a/clippy_lints%2Fsrc%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fptr.rs?ref=9d1792a4265c3645d716c5bf085c07be8749332a", "patch": "@@ -10,7 +10,6 @@ use rustc::ty;\n use rustc::{declare_tool_lint, lint_array};\n use rustc_errors::Applicability;\n use std::borrow::Cow;\n-use syntax::ast::NodeId;\n use syntax::source_map::Span;\n use syntax_pos::MultiSpan;\n \n@@ -111,18 +110,19 @@ impl LintPass for PointerPass {\n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for PointerPass {\n     fn check_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx Item) {\n         if let ItemKind::Fn(ref decl, _, _, body_id) = item.node {\n-            check_fn(cx, decl, item.id, Some(body_id));\n+            check_fn(cx, decl, item.hir_id, Some(body_id));\n         }\n     }\n \n     fn check_impl_item(&mut self, cx: &LateContext<'a, 'tcx>, item: &'tcx ImplItem) {\n         if let ImplItemKind::Method(ref sig, body_id) = item.node {\n-            if let Some(Node::Item(it)) = cx.tcx.hir().find(cx.tcx.hir().get_parent(item.id)) {\n+            let parent_item = cx.tcx.hir().get_parent_item(item.hir_id);\n+            if let Some(Node::Item(it)) = cx.tcx.hir().find_by_hir_id(parent_item) {\n                 if let ItemKind::Impl(_, _, _, _, Some(_), _, _) = it.node {\n                     return; // ignore trait impls\n                 }\n             }\n-            check_fn(cx, &sig.decl, item.id, Some(body_id));\n+            check_fn(cx, &sig.decl, item.hir_id, Some(body_id));\n         }\n     }\n \n@@ -133,7 +133,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for PointerPass {\n             } else {\n                 None\n             };\n-            check_fn(cx, &sig.decl, item.id, body_id);\n+            check_fn(cx, &sig.decl, item.hir_id, body_id);\n         }\n     }\n \n@@ -152,8 +152,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for PointerPass {\n }\n \n #[allow(clippy::too_many_lines)]\n-fn check_fn(cx: &LateContext<'_, '_>, decl: &FnDecl, fn_id: NodeId, opt_body_id: Option<BodyId>) {\n-    let fn_def_id = cx.tcx.hir().local_def_id(fn_id);\n+fn check_fn(cx: &LateContext<'_, '_>, decl: &FnDecl, fn_id: HirId, opt_body_id: Option<BodyId>) {\n+    let fn_def_id = cx.tcx.hir().local_def_id_from_hir_id(fn_id);\n     let sig = cx.tcx.fn_sig(fn_def_id);\n     let fn_ty = sig.skip_binder();\n "}, {"sha": "5c1d637874c60fdb8e1d81397b8600559cc120c4", "filename": "clippy_lints/src/trivially_copy_pass_by_ref.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9d1792a4265c3645d716c5bf085c07be8749332a/clippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1792a4265c3645d716c5bf085c07be8749332a/clippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftrivially_copy_pass_by_ref.rs?ref=9d1792a4265c3645d716c5bf085c07be8749332a", "patch": "@@ -72,11 +72,11 @@ impl<'a, 'tcx> TriviallyCopyPassByRef {\n     }\n \n     fn check_trait_method(&mut self, cx: &LateContext<'_, 'tcx>, item: &TraitItemRef) {\n-        let method_def_id = cx.tcx.hir().local_def_id(item.id.node_id);\n+        let method_def_id = cx.tcx.hir().local_def_id_from_hir_id(item.id.hir_id);\n         let method_sig = cx.tcx.fn_sig(method_def_id);\n         let method_sig = cx.tcx.erase_late_bound_regions(&method_sig);\n \n-        let decl = match cx.tcx.hir().fn_decl(item.id.node_id) {\n+        let decl = match cx.tcx.hir().fn_decl_by_hir_id(item.id.hir_id) {\n             Some(b) => b,\n             None => return,\n         };"}, {"sha": "09f596a10254469c5bc551903a2a30a13135d709", "filename": "clippy_lints/src/types.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d1792a4265c3645d716c5bf085c07be8749332a/clippy_lints%2Fsrc%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1792a4265c3645d716c5bf085c07be8749332a/clippy_lints%2Fsrc%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Ftypes.rs?ref=9d1792a4265c3645d716c5bf085c07be8749332a", "patch": "@@ -2034,7 +2034,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ImplicitHasher {\n             }\n         }\n \n-        if !cx.access_levels.is_exported(item.id) {\n+        if !cx.access_levels.is_exported(cx.tcx.hir().hir_to_node_id(item.hir_id)) {\n             return;\n         }\n "}, {"sha": "fb7bb1f0d2ae6b9675280a2d0e9aeff2d6d4229b", "filename": "clippy_lints/src/use_self.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9d1792a4265c3645d716c5bf085c07be8749332a/clippy_lints%2Fsrc%2Fuse_self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1792a4265c3645d716c5bf085c07be8749332a/clippy_lints%2Fsrc%2Fuse_self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fuse_self.rs?ref=9d1792a4265c3645d716c5bf085c07be8749332a", "patch": "@@ -137,7 +137,7 @@ fn check_trait_method_impl_decl<'a, 'tcx: 'a>(\n     let trait_method_sig = cx.tcx.fn_sig(trait_method.def_id);\n     let trait_method_sig = cx.tcx.erase_late_bound_regions(&trait_method_sig);\n \n-    let impl_method_def_id = cx.tcx.hir().local_def_id(impl_item.id);\n+    let impl_method_def_id = cx.tcx.hir().local_def_id_from_hir_id(impl_item.hir_id);\n     let impl_method_sig = cx.tcx.fn_sig(impl_method_def_id);\n     let impl_method_sig = cx.tcx.erase_late_bound_regions(&impl_method_sig);\n \n@@ -192,7 +192,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UseSelf {\n                         item_path,\n                         cx,\n                     };\n-                    let impl_def_id = cx.tcx.hir().local_def_id(item.id);\n+                    let impl_def_id = cx.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n                     let impl_trait_ref = cx.tcx.impl_trait_ref(impl_def_id);\n \n                     if let Some(impl_trait_ref) = impl_trait_ref {"}, {"sha": "6d04ce70bc434abbcb1936bb04af3c6fdc9e5ddb", "filename": "clippy_lints/src/utils/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9d1792a4265c3645d716c5bf085c07be8749332a/clippy_lints%2Fsrc%2Futils%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1792a4265c3645d716c5bf085c07be8749332a/clippy_lints%2Fsrc%2Futils%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fdiagnostics.rs?ref=9d1792a4265c3645d716c5bf085c07be8749332a", "patch": "@@ -135,8 +135,7 @@ pub fn span_lint_and_then<'a, 'tcx: 'a, T: LintContext<'tcx>, F>(\n }\n \n pub fn span_lint_node(cx: &LateContext<'_, '_>, lint: &'static Lint, node: HirId, sp: Span, msg: &str) {\n-    let node_id = cx.tcx.hir().hir_to_node_id(node);\n-    DiagnosticWrapper(cx.tcx.struct_span_lint_node(lint, node_id, sp, msg)).docs_link(lint);\n+    DiagnosticWrapper(cx.tcx.struct_span_lint_hir(lint, node, sp, msg)).docs_link(lint);\n }\n \n pub fn span_lint_node_and_then(\n@@ -147,8 +146,7 @@ pub fn span_lint_node_and_then(\n     msg: &str,\n     f: impl FnOnce(&mut DiagnosticBuilder<'_>),\n ) {\n-    let node_id = cx.tcx.hir().hir_to_node_id(node);\n-    let mut db = DiagnosticWrapper(cx.tcx.struct_span_lint_node(lint, node_id, sp, msg));\n+    let mut db = DiagnosticWrapper(cx.tcx.struct_span_lint_hir(lint, node, sp, msg));\n     f(&mut db.0);\n     db.docs_link(lint);\n }"}, {"sha": "4d43c374b722c0ddb44ec228405d84c1a85af83e", "filename": "clippy_lints/src/utils/inspector.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9d1792a4265c3645d716c5bf085c07be8749332a/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1792a4265c3645d716c5bf085c07be8749332a/clippy_lints%2Fsrc%2Futils%2Finspector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finspector.rs?ref=9d1792a4265c3645d716c5bf085c07be8749332a", "patch": "@@ -344,7 +344,7 @@ fn print_expr(cx: &LateContext<'_, '_>, expr: &hir::Expr, indent: usize) {\n }\n \n fn print_item(cx: &LateContext<'_, '_>, item: &hir::Item) {\n-    let did = cx.tcx.hir().local_def_id(item.id);\n+    let did = cx.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n     println!(\"item `{}`\", item.ident.name);\n     match item.vis.node {\n         hir::VisibilityKind::Public => println!(\"public\"),\n@@ -357,7 +357,7 @@ fn print_item(cx: &LateContext<'_, '_>, item: &hir::Item) {\n     }\n     match item.node {\n         hir::ItemKind::ExternCrate(ref _renamed_from) => {\n-            let def_id = cx.tcx.hir().local_def_id(item.id);\n+            let def_id = cx.tcx.hir().local_def_id_from_hir_id(item.hir_id);\n             if let Some(crate_id) = cx.tcx.extern_mod_stmt_cnum(def_id) {\n                 let source = cx.tcx.used_crate_source(crate_id);\n                 if let Some(ref src) = source.dylib {"}, {"sha": "0821ab036b0a464f9cf37df47f152a437c7f3c04", "filename": "clippy_lints/src/utils/internal_lints.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9d1792a4265c3645d716c5bf085c07be8749332a/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1792a4265c3645d716c5bf085c07be8749332a/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Finternal_lints.rs?ref=9d1792a4265c3645d716c5bf085c07be8749332a", "patch": "@@ -164,7 +164,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for LintWithoutLintPass {\n                         output: &mut self.registered_lints,\n                         cx,\n                     };\n-                    let body_id = cx.tcx.hir().body_owned_by(impl_item_refs[0].id.node_id);\n+                    let node_id = cx.tcx.hir().hir_to_node_id(impl_item_refs[0].id.hir_id);\n+                    let body_id = cx.tcx.hir().body_owned_by(node_id);\n                     collector.visit_expr(&cx.tcx.hir().body(body_id).value);\n                 }\n             }"}, {"sha": "70ba0592caa314884f6e031a0702ea6a14748df3", "filename": "clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9d1792a4265c3645d716c5bf085c07be8749332a/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1792a4265c3645d716c5bf085c07be8749332a/clippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=9d1792a4265c3645d716c5bf085c07be8749332a", "patch": "@@ -702,8 +702,8 @@ pub fn is_direct_expn_of(span: Span, name: &str) -> Option<Span> {\n }\n \n /// Convenience function to get the return type of a function\n-pub fn return_ty<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, fn_item: NodeId) -> Ty<'tcx> {\n-    let fn_def_id = cx.tcx.hir().local_def_id(fn_item);\n+pub fn return_ty<'a, 'tcx>(cx: &LateContext<'a, 'tcx>, fn_item: hir::HirId) -> Ty<'tcx> {\n+    let fn_def_id = cx.tcx.hir().local_def_id_from_hir_id(fn_item);\n     let ret_ty = cx.tcx.fn_sig(fn_def_id).output();\n     cx.tcx.erase_late_bound_regions(&ret_ty)\n }\n@@ -878,8 +878,7 @@ pub fn is_try(expr: &Expr) -> Option<&Expr> {\n ///\n /// Useful for skipping long running code when it's unnecessary\n pub fn is_allowed(cx: &LateContext<'_, '_>, lint: &'static Lint, id: HirId) -> bool {\n-    let node_id = cx.tcx.hir().hir_to_node_id(id);\n-    cx.tcx.lint_level_at_node(lint, node_id).0 == Level::Allow\n+    cx.tcx.lint_level_at_node(lint, id).0 == Level::Allow\n }\n \n pub fn get_arg_name(pat: &Pat) -> Option<ast::Name> {"}, {"sha": "f4c89a8caec7e475210d6e53b4eeadc570c9c9a3", "filename": "clippy_lints/src/utils/usage.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9d1792a4265c3645d716c5bf085c07be8749332a/clippy_lints%2Fsrc%2Futils%2Fusage.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d1792a4265c3645d716c5bf085c07be8749332a/clippy_lints%2Fsrc%2Futils%2Fusage.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Futils%2Fusage.rs?ref=9d1792a4265c3645d716c5bf085c07be8749332a", "patch": "@@ -7,11 +7,10 @@ use rustc::middle::mem_categorization::cmt_;\n use rustc::middle::mem_categorization::Categorization;\n use rustc::ty;\n use rustc_data_structures::fx::FxHashSet;\n-use syntax::ast::NodeId;\n use syntax::source_map::Span;\n \n /// Returns a set of mutated local variable ids or None if mutations could not be determined.\n-pub fn mutated_variables<'a, 'tcx: 'a>(expr: &'tcx Expr, cx: &'a LateContext<'a, 'tcx>) -> Option<FxHashSet<NodeId>> {\n+pub fn mutated_variables<'a, 'tcx: 'a>(expr: &'tcx Expr, cx: &'a LateContext<'a, 'tcx>) -> Option<FxHashSet<HirId>> {\n     let mut delegate = MutVarsDelegate {\n         used_mutably: FxHashSet::default(),\n         skip: false,\n@@ -35,11 +34,11 @@ pub fn is_potentially_mutated<'a, 'tcx: 'a>(\n         Def::Local(id) | Def::Upvar(id, ..) => id,\n         _ => return true,\n     };\n-    mutated_variables(expr, cx).map_or(true, |mutated| mutated.contains(&id))\n+    mutated_variables(expr, cx).map_or(true, |mutated| mutated.contains(&cx.tcx.hir().node_to_hir_id(id)))\n }\n \n struct MutVarsDelegate {\n-    used_mutably: FxHashSet<NodeId>,\n+    used_mutably: FxHashSet<HirId>,\n     skip: bool,\n }\n \n@@ -79,5 +78,5 @@ impl<'tcx> Delegate<'tcx> for MutVarsDelegate {\n         self.update(&cmt.cat)\n     }\n \n-    fn decl_without_init(&mut self, _: NodeId, _: Span) {}\n+    fn decl_without_init(&mut self, _: HirId, _: Span) {}\n }"}]}