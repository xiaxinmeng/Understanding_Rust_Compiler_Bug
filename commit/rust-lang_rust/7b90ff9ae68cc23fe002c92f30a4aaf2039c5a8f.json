{"sha": "7b90ff9ae68cc23fe002c92f30a4aaf2039c5a8f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdiOTBmZjlhZTY4Y2MyM2ZlMDAyYzkyZjMwYTRhYWYyMDM5YzVhOGY=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-04-13T15:07:54Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-04-13T15:08:27Z"}, "message": "add after_stack_push hook; add public ImmTy::from_immediate method, and make ImmTy::imm field private", "tree": {"sha": "34368d5af75fd5674ae706e8e638a85e7c1ae6db", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/34368d5af75fd5674ae706e8e638a85e7c1ae6db"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7b90ff9ae68cc23fe002c92f30a4aaf2039c5a8f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7b90ff9ae68cc23fe002c92f30a4aaf2039c5a8f", "html_url": "https://github.com/rust-lang/rust/commit/7b90ff9ae68cc23fe002c92f30a4aaf2039c5a8f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7b90ff9ae68cc23fe002c92f30a4aaf2039c5a8f/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1a3bda648747e2d332f58988a12bbed1aefd4cda", "url": "https://api.github.com/repos/rust-lang/rust/commits/1a3bda648747e2d332f58988a12bbed1aefd4cda", "html_url": "https://github.com/rust-lang/rust/commit/1a3bda648747e2d332f58988a12bbed1aefd4cda"}], "stats": {"total": 71, "additions": 43, "deletions": 28}, "files": [{"sha": "33f8397887336ebff02aa03d9de98f14a30715a4", "filename": "src/librustc_mir/const_eval/eval_queries.rs", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/7b90ff9ae68cc23fe002c92f30a4aaf2039c5a8f/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b90ff9ae68cc23fe002c92f30a4aaf2039c5a8f/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval%2Feval_queries.rs?ref=7b90ff9ae68cc23fe002c92f30a4aaf2039c5a8f", "patch": "@@ -1,7 +1,7 @@\n use super::{error_to_const_error, CompileTimeEvalContext, CompileTimeInterpreter, MemoryExtra};\n use crate::interpret::eval_nullary_intrinsic;\n use crate::interpret::{\n-    intern_const_alloc_recursive, Allocation, ConstValue, GlobalId, ImmTy, Immediate, InternKind,\n+    intern_const_alloc_recursive, Allocation, ConstValue, GlobalId, Immediate, InternKind,\n     InterpCx, InterpResult, MPlaceTy, MemoryKind, OpTy, RawConst, RefTracking, Scalar,\n     ScalarMaybeUndef, StackPopCleanup,\n };\n@@ -147,24 +147,26 @@ pub(super) fn op_to_const<'tcx>(\n     match immediate {\n         Ok(mplace) => to_const_value(mplace),\n         // see comment on `let try_as_immediate` above\n-        Err(ImmTy { imm: Immediate::Scalar(x), .. }) => match x {\n-            ScalarMaybeUndef::Scalar(s) => ConstValue::Scalar(s),\n-            ScalarMaybeUndef::Undef => to_const_value(op.assert_mem_place(ecx)),\n-        },\n-        Err(ImmTy { imm: Immediate::ScalarPair(a, b), .. }) => {\n-            let (data, start) = match a.not_undef().unwrap() {\n-                Scalar::Ptr(ptr) => {\n-                    (ecx.tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id), ptr.offset.bytes())\n-                }\n-                Scalar::Raw { .. } => (\n-                    ecx.tcx.intern_const_alloc(Allocation::from_byte_aligned_bytes(b\"\" as &[u8])),\n-                    0,\n-                ),\n-            };\n-            let len = b.to_machine_usize(&ecx.tcx.tcx).unwrap();\n-            let start = start.try_into().unwrap();\n-            let len: usize = len.try_into().unwrap();\n-            ConstValue::Slice { data, start, end: start + len }\n+        Err(imm) => match *imm {\n+            Immediate::Scalar(x) => match x {\n+                ScalarMaybeUndef::Scalar(s) => ConstValue::Scalar(s),\n+                ScalarMaybeUndef::Undef => to_const_value(op.assert_mem_place(ecx)),\n+            },\n+            Immediate::ScalarPair(a, b) => {\n+                let (data, start) = match a.not_undef().unwrap() {\n+                    Scalar::Ptr(ptr) => {\n+                        (ecx.tcx.alloc_map.lock().unwrap_memory(ptr.alloc_id), ptr.offset.bytes())\n+                    }\n+                    Scalar::Raw { .. } => (\n+                        ecx.tcx.intern_const_alloc(Allocation::from_byte_aligned_bytes(b\"\" as &[u8])),\n+                        0,\n+                    ),\n+                };\n+                let len = b.to_machine_usize(&ecx.tcx.tcx).unwrap();\n+                let start = start.try_into().unwrap();\n+                let len: usize = len.try_into().unwrap();\n+                ConstValue::Slice { data, start, end: start + len }\n+            }\n         }\n     }\n }"}, {"sha": "f111eecb9450e33625f58147a24f01839b362a98", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/7b90ff9ae68cc23fe002c92f30a4aaf2039c5a8f/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b90ff9ae68cc23fe002c92f30a4aaf2039c5a8f/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=7b90ff9ae68cc23fe002c92f30a4aaf2039c5a8f", "patch": "@@ -646,6 +646,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             self.frame_mut().locals = locals;\n         }\n \n+        M::after_stack_push(self)?;\n         info!(\"ENTERING({}) {}\", self.cur_frame(), self.frame().instance);\n \n         if self.stack.len() > *self.tcx.sess.recursion_limit.get() {\n@@ -751,7 +752,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             // We want to skip the `info!` below, hence early return.\n             return Ok(());\n         }\n-        // Normal return.\n+        // Normal return, figure out where to jump.\n         if unwinding {\n             // Follow the unwind edge.\n             let unwind = next_block.expect(\"Encountered StackPopCleanup::None when unwinding!\");"}, {"sha": "3c7cb73610ea698536e81110c40ef41f84094439", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/7b90ff9ae68cc23fe002c92f30a4aaf2039c5a8f/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b90ff9ae68cc23fe002c92f30a4aaf2039c5a8f/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=7b90ff9ae68cc23fe002c92f30a4aaf2039c5a8f", "patch": "@@ -285,6 +285,11 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         frame: Frame<'mir, 'tcx, Self::PointerTag>,\n     ) -> InterpResult<'tcx, Frame<'mir, 'tcx, Self::PointerTag, Self::FrameExtra>>;\n \n+    /// Called immediately after a stack frame got pushed and its locals got initialized.\n+    fn after_stack_push(_ecx: &mut InterpCx<'mir, 'tcx, Self>) -> InterpResult<'tcx> {\n+        Ok(())\n+    }\n+\n     /// Called immediately after a stack frame got popped, but before jumping back to the caller.\n     fn after_stack_pop(\n         _ecx: &mut InterpCx<'mir, 'tcx, Self>,"}, {"sha": "893f4c1db7e0aa20b24c9d82228d2e582d40e4cb", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/7b90ff9ae68cc23fe002c92f30a4aaf2039c5a8f/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b90ff9ae68cc23fe002c92f30a4aaf2039c5a8f/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=7b90ff9ae68cc23fe002c92f30a4aaf2039c5a8f", "patch": "@@ -87,7 +87,7 @@ impl<'tcx, Tag> Immediate<Tag> {\n // as input for binary and cast operations.\n #[derive(Copy, Clone, Debug)]\n pub struct ImmTy<'tcx, Tag = ()> {\n-    pub(crate) imm: Immediate<Tag>,\n+    imm: Immediate<Tag>,\n     pub layout: TyAndLayout<'tcx>,\n }\n \n@@ -183,6 +183,11 @@ impl<'tcx, Tag: Copy> ImmTy<'tcx, Tag> {\n         ImmTy { imm: val.into(), layout }\n     }\n \n+    #[inline]\n+    pub fn from_immediate(imm: Immediate<Tag>, layout: TyAndLayout<'tcx>) -> Self {\n+        ImmTy { imm, layout }\n+    }\n+\n     #[inline]\n     pub fn try_from_uint(i: impl Into<u128>, layout: TyAndLayout<'tcx>) -> Option<Self> {\n         Some(Self::from_scalar(Scalar::try_from_uint(i, layout.size)?, layout))\n@@ -424,7 +429,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         Ok(OpTy { op, layout })\n     }\n \n-    /// Every place can be read from, so we can turn them into an operand\n+    /// Every place can be read from, so we can turn them into an operand.\n+    /// This will definitely return `Indirect` if the place is a `Ptr`, i.e., this\n+    /// will never actually read from memory.\n     #[inline(always)]\n     pub fn place_to_op(\n         &self,"}, {"sha": "9ac4b3551fc4307c0ea01da5f11d5929ca4ff1d8", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7b90ff9ae68cc23fe002c92f30a4aaf2039c5a8f/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b90ff9ae68cc23fe002c92f30a4aaf2039c5a8f/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=7b90ff9ae68cc23fe002c92f30a4aaf2039c5a8f", "patch": "@@ -247,7 +247,7 @@ impl<'tcx, Tag: ::std::fmt::Debug + Copy> OpTy<'tcx, Tag> {\n             Operand::Immediate(_) if self.layout.is_zst() => {\n                 Ok(MPlaceTy::dangling(self.layout, cx))\n             }\n-            Operand::Immediate(imm) => Err(ImmTy { imm, layout: self.layout }),\n+            Operand::Immediate(imm) => Err(ImmTy::from_immediate(imm, self.layout)),\n         }\n     }\n "}, {"sha": "49fee1bddcb6db1b06cdc8343938ff2896ea8373", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7b90ff9ae68cc23fe002c92f30a4aaf2039c5a8f/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7b90ff9ae68cc23fe002c92f30a4aaf2039c5a8f/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=7b90ff9ae68cc23fe002c92f30a4aaf2039c5a8f", "patch": "@@ -407,7 +407,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let this_receiver_ptr = self.layout_of(receiver_ptr_ty)?.field(self, 0)?;\n                 // Adjust receiver argument.\n                 args[0] =\n-                    OpTy::from(ImmTy { layout: this_receiver_ptr, imm: receiver_place.ptr.into() });\n+                    OpTy::from(ImmTy::from_immediate(receiver_place.ptr.into(), this_receiver_ptr));\n                 trace!(\"Patched self operand to {:#?}\", args[0]);\n                 // recurse with concrete function\n                 self.eval_fn_call(drop_fn, caller_abi, &args, ret, unwind)\n@@ -436,10 +436,10 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             _ => (instance, place),\n         };\n \n-        let arg = ImmTy {\n-            imm: place.to_ref(),\n-            layout: self.layout_of(self.tcx.mk_mut_ptr(place.layout.ty))?,\n-        };\n+        let arg = ImmTy::from_immediate(\n+            place.to_ref(),\n+            self.layout_of(self.tcx.mk_mut_ptr(place.layout.ty))?,\n+        );\n \n         let ty = self.tcx.mk_unit(); // return type is ()\n         let dest = MPlaceTy::dangling(self.layout_of(ty)?, self);"}]}