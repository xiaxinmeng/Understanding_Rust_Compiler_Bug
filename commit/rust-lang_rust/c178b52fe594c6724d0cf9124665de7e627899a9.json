{"sha": "c178b52fe594c6724d0cf9124665de7e627899a9", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMxNzhiNTJmZTU5NGM2NzI0ZDBjZjkxMjQ2NjVkZTdlNjI3ODk5YTk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-19T04:51:58Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2013-08-19T04:51:58Z"}, "message": "auto merge of #8556 : sfackler/rust/quote, r=alexcrichton\n\nThey previously required one called \"ext_cx\" to be in scope.\r\n\r\nFixes part of #7727", "tree": {"sha": "2f211e10e54c2e6a112041814aeb5f5ebdec9ef0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2f211e10e54c2e6a112041814aeb5f5ebdec9ef0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c178b52fe594c6724d0cf9124665de7e627899a9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c178b52fe594c6724d0cf9124665de7e627899a9", "html_url": "https://github.com/rust-lang/rust/commit/c178b52fe594c6724d0cf9124665de7e627899a9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c178b52fe594c6724d0cf9124665de7e627899a9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "557ff049f098ab0d53670291fca660eb23549827", "url": "https://api.github.com/repos/rust-lang/rust/commits/557ff049f098ab0d53670291fca660eb23549827", "html_url": "https://github.com/rust-lang/rust/commit/557ff049f098ab0d53670291fca660eb23549827"}, {"sha": "8b80922a4c7414c5bd3fc96e8f2b511e9603d5e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/8b80922a4c7414c5bd3fc96e8f2b511e9603d5e5", "html_url": "https://github.com/rust-lang/rust/commit/8b80922a4c7414c5bd3fc96e8f2b511e9603d5e5"}], "stats": {"total": 442, "additions": 256, "deletions": 186}, "files": [{"sha": "0aacd4c5063db28a3c8eea9a972cb04b237acba4", "filename": "src/librustc/front/test.rs", "status": "modified", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/c178b52fe594c6724d0cf9124665de7e627899a9/src%2Flibrustc%2Ffront%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c178b52fe594c6724d0cf9124665de7e627899a9/src%2Flibrustc%2Ffront%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Ftest.rs?ref=c178b52fe594c6724d0cf9124665de7e627899a9", "patch": "@@ -292,6 +292,7 @@ fn mk_std(cx: &TestCtxt) -> ast::view_item {\n     }\n }\n \n+#[cfg(stage0)]\n fn mk_test_module(cx: &TestCtxt) -> @ast::item {\n \n     // Link to extra\n@@ -334,6 +335,48 @@ fn mk_test_module(cx: &TestCtxt) -> @ast::item {\n \n     return @item;\n }\n+#[cfg(not(stage0))]\n+fn mk_test_module(cx: &TestCtxt) -> @ast::item {\n+\n+    // Link to extra\n+    let view_items = ~[mk_std(cx)];\n+\n+    // A constant vector of test descriptors.\n+    let tests = mk_tests(cx);\n+\n+    // The synthesized main function which will call the console test runner\n+    // with our list of tests\n+    let mainfn = (quote_item!(cx.ext_cx,\n+        pub fn main() {\n+            #[main];\n+            extra::test::test_main_static(::std::os::args(), TESTS);\n+        }\n+    )).unwrap();\n+\n+    let testmod = ast::_mod {\n+        view_items: view_items,\n+        items: ~[mainfn, tests],\n+    };\n+    let item_ = ast::item_mod(testmod);\n+\n+    // This attribute tells resolve to let us call unexported functions\n+    let resolve_unexported_attr =\n+        attr::mk_attr(attr::mk_word_item(@\"!resolve_unexported\"));\n+\n+    let item = ast::item {\n+        ident: cx.sess.ident_of(\"__test\"),\n+        attrs: ~[resolve_unexported_attr],\n+        id: cx.sess.next_node_id(),\n+        node: item_,\n+        vis: ast::public,\n+        span: dummy_sp(),\n+     };\n+\n+    debug!(\"Synthetic test module:\\n%s\\n\",\n+           pprust::item_to_str(@item.clone(), cx.sess.intr()));\n+\n+    return @item;\n+}\n \n fn nospan<T>(t: T) -> codemap::spanned<T> {\n     codemap::spanned { node: t, span: dummy_sp() }\n@@ -355,6 +398,7 @@ fn path_node_global(ids: ~[ast::ident]) -> ast::Path {\n                  types: ~[] }\n }\n \n+#[cfg(stage0)]\n fn mk_tests(cx: &TestCtxt) -> @ast::item {\n \n     let ext_cx = cx.ext_cx;\n@@ -368,6 +412,17 @@ fn mk_tests(cx: &TestCtxt) -> @ast::item {\n         ;\n     )).unwrap()\n }\n+#[cfg(not(stage0))]\n+fn mk_tests(cx: &TestCtxt) -> @ast::item {\n+    // The vector of test_descs for this crate\n+    let test_descs = mk_test_descs(cx);\n+\n+    (quote_item!(cx.ext_cx,\n+        pub static TESTS : &'static [self::extra::test::TestDescAndFn] =\n+            $test_descs\n+        ;\n+    )).unwrap()\n+}\n \n fn is_extra(cx: &TestCtxt) -> bool {\n     let items = attr::find_linkage_metas(cx.crate.attrs);\n@@ -398,6 +453,7 @@ fn mk_test_descs(cx: &TestCtxt) -> @ast::expr {\n     }\n }\n \n+#[cfg(stage0)]\n fn mk_test_desc_and_fn_rec(cx: &TestCtxt, test: &Test) -> @ast::expr {\n     let span = test.span;\n     let path = test.path.clone();\n@@ -453,3 +509,57 @@ fn mk_test_desc_and_fn_rec(cx: &TestCtxt, test: &Test) -> @ast::expr {\n     );\n     e\n }\n+#[cfg(not(stage0))]\n+fn mk_test_desc_and_fn_rec(cx: &TestCtxt, test: &Test) -> @ast::expr {\n+    let span = test.span;\n+    let path = test.path.clone();\n+\n+    debug!(\"encoding %s\", ast_util::path_name_i(path));\n+\n+    let name_lit: ast::lit =\n+        nospan(ast::lit_str(ast_util::path_name_i(path).to_managed()));\n+\n+    let name_expr = @ast::expr {\n+          id: cx.sess.next_node_id(),\n+          node: ast::expr_lit(@name_lit),\n+          span: span\n+    };\n+\n+    let fn_path = path_node_global(path);\n+\n+    let fn_expr = @ast::expr {\n+        id: cx.sess.next_node_id(),\n+        node: ast::expr_path(fn_path),\n+        span: span,\n+    };\n+\n+    let t_expr = if test.bench {\n+        quote_expr!(cx.ext_cx, self::extra::test::StaticBenchFn($fn_expr) )\n+    } else {\n+        quote_expr!(cx.ext_cx, self::extra::test::StaticTestFn($fn_expr) )\n+    };\n+\n+    let ignore_expr = if test.ignore {\n+        quote_expr!(cx.ext_cx, true )\n+    } else {\n+        quote_expr!(cx.ext_cx, false )\n+    };\n+\n+    let fail_expr = if test.should_fail {\n+        quote_expr!(cx.ext_cx, true )\n+    } else {\n+        quote_expr!(cx.ext_cx, false )\n+    };\n+\n+    let e = quote_expr!(cx.ext_cx,\n+        self::extra::test::TestDescAndFn {\n+            desc: self::extra::test::TestDesc {\n+                name: self::extra::test::StaticTestName($name_expr),\n+                ignore: $ignore_expr,\n+                should_fail: $fail_expr\n+            },\n+            testfn: $t_expr,\n+        }\n+    );\n+    e\n+}"}, {"sha": "bca1a811a13727d17b14b3386a41a298a84a038d", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/c178b52fe594c6724d0cf9124665de7e627899a9/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c178b52fe594c6724d0cf9124665de7e627899a9/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=c178b52fe594c6724d0cf9124665de7e627899a9", "patch": "@@ -1288,24 +1288,24 @@ fn roundtrip(in_item: Option<@ast::item>) {\n \n #[test]\n fn test_basic() {\n-    let ext_cx = mk_ctxt();\n-    roundtrip(quote_item!(\n+    let cx = mk_ctxt();\n+    roundtrip(quote_item!(cx,\n         fn foo() {}\n     ));\n }\n \n #[test]\n fn test_smalltalk() {\n-    let ext_cx = mk_ctxt();\n-    roundtrip(quote_item!(\n+    let cx = mk_ctxt();\n+    roundtrip(quote_item!(cx,\n         fn foo() -> int { 3 + 4 } // first smalltalk program ever executed.\n     ));\n }\n \n #[test]\n fn test_more() {\n-    let ext_cx = mk_ctxt();\n-    roundtrip(quote_item!(\n+    let cx = mk_ctxt();\n+    roundtrip(quote_item!(cx,\n         fn foo(x: uint, y: uint) -> uint {\n             let z = x + y;\n             return z;\n@@ -1315,15 +1315,15 @@ fn test_more() {\n \n #[test]\n fn test_simplification() {\n-    let ext_cx = mk_ctxt();\n-    let item_in = ast::ii_item(quote_item!(\n+    let cx = mk_ctxt();\n+    let item_in = ast::ii_item(quote_item!(cx,\n         fn new_int_alist<B>() -> alist<int, B> {\n             fn eq_int(a: int, b: int) -> bool { a == b }\n             return alist {eq_fn: eq_int, data: ~[]};\n         }\n     ).unwrap());\n     let item_out = simplify_ast(&item_in);\n-    let item_exp = ast::ii_item(quote_item!(\n+    let item_exp = ast::ii_item(quote_item!(cx,\n         fn new_int_alist<B>() -> alist<int, B> {\n             return alist {eq_fn: eq_int, data: ~[]};\n         }"}, {"sha": "9f179672422cd7295fffcfbd8a006d6e9ee19eb5", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c178b52fe594c6724d0cf9124665de7e627899a9/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c178b52fe594c6724d0cf9124665de7e627899a9/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=c178b52fe594c6724d0cf9124665de7e627899a9", "patch": "@@ -605,17 +605,29 @@ impl AstBuilder for @ExtCtxt {\n \n         self.expr(span, ast::expr_fn_block(fn_decl, blk))\n     }\n+    #[cfg(stage0)]\n     fn lambda0(&self, _span: span, blk: ast::Block) -> @ast::expr {\n         let ext_cx = *self;\n         let blk_e = self.expr(blk.span, ast::expr_block(blk.clone()));\n         quote_expr!(|| $blk_e )\n     }\n+    #[cfg(not(stage0))]\n+    fn lambda0(&self, _span: span, blk: ast::Block) -> @ast::expr {\n+        let blk_e = self.expr(blk.span, ast::expr_block(blk.clone()));\n+        quote_expr!(*self, || $blk_e )\n+    }\n \n+    #[cfg(stage0)]\n     fn lambda1(&self, _span: span, blk: ast::Block, ident: ast::ident) -> @ast::expr {\n         let ext_cx = *self;\n         let blk_e = self.expr(blk.span, ast::expr_block(blk.clone()));\n         quote_expr!(|$ident| $blk_e )\n     }\n+    #[cfg(not(stage0))]\n+    fn lambda1(&self, _span: span, blk: ast::Block, ident: ast::ident) -> @ast::expr {\n+        let blk_e = self.expr(blk.span, ast::expr_block(blk.clone()));\n+        quote_expr!(*self, |$ident| $blk_e )\n+    }\n \n     fn lambda_expr(&self, span: span, ids: ~[ast::ident], expr: @ast::expr) -> @ast::expr {\n         self.lambda(span, ids, self.block_expr(expr))"}, {"sha": "d906f8f45185847e0bdb525848c980dec174d1aa", "filename": "src/libsyntax/ext/env.rs", "status": "modified", "additions": 20, "deletions": 8, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/c178b52fe594c6724d0cf9124665de7e627899a9/src%2Flibsyntax%2Fext%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c178b52fe594c6724d0cf9124665de7e627899a9/src%2Flibsyntax%2Fext%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fenv.rs?ref=c178b52fe594c6724d0cf9124665de7e627899a9", "patch": "@@ -22,6 +22,7 @@ use ext::build::AstBuilder;\n \n use std::os;\n \n+#[cfg(stage0)]\n pub fn expand_option_env(ext_cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     let var = get_single_str_from_tts(ext_cx, sp, tts, \"option_env!\");\n@@ -32,25 +33,36 @@ pub fn expand_option_env(ext_cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n     };\n     MRExpr(e)\n }\n+#[cfg(not(stage0))]\n+pub fn expand_option_env(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n+    -> base::MacResult {\n+    let var = get_single_str_from_tts(cx, sp, tts, \"option_env!\");\n+\n+    let e = match os::getenv(var) {\n+      None => quote_expr!(cx, ::std::option::None::<&'static str>),\n+      Some(s) => quote_expr!(cx, ::std::option::Some($s))\n+    };\n+    MRExpr(e)\n+}\n \n-pub fn expand_env(ext_cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n+pub fn expand_env(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n     -> base::MacResult {\n-    let exprs = get_exprs_from_tts(ext_cx, sp, tts);\n+    let exprs = get_exprs_from_tts(cx, sp, tts);\n \n     if exprs.len() == 0 {\n-        ext_cx.span_fatal(sp, \"env! takes 1 or 2 arguments\");\n+        cx.span_fatal(sp, \"env! takes 1 or 2 arguments\");\n     }\n \n-    let var = expr_to_str(ext_cx, exprs[0], \"expected string literal\");\n+    let var = expr_to_str(cx, exprs[0], \"expected string literal\");\n     let msg = match exprs.len() {\n         1 => fmt!(\"Environment variable %s not defined\", var).to_managed(),\n-        2 => expr_to_str(ext_cx, exprs[1], \"expected string literal\"),\n-        _ => ext_cx.span_fatal(sp, \"env! takes 1 or 2 arguments\")\n+        2 => expr_to_str(cx, exprs[1], \"expected string literal\"),\n+        _ => cx.span_fatal(sp, \"env! takes 1 or 2 arguments\")\n     };\n \n     let e = match os::getenv(var) {\n-        None => ext_cx.span_fatal(sp, msg),\n-        Some(s) => ext_cx.expr_str(sp, s.to_managed())\n+        None => cx.span_fatal(sp, msg),\n+        Some(s) => cx.expr_str(sp, s.to_managed())\n     };\n     MRExpr(e)\n }"}, {"sha": "fcc5a8c93fa5959a92eab9c8334b732246f889b8", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 82, "deletions": 146, "changes": 228, "blob_url": "https://github.com/rust-lang/rust/blob/c178b52fe594c6724d0cf9124665de7e627899a9/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c178b52fe594c6724d0cf9124665de7e627899a9/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=c178b52fe594c6724d0cf9124665de7e627899a9", "patch": "@@ -196,119 +196,45 @@ pub mod rt {\n \n     // Alas ... we write these out instead. All redundant.\n \n-    impl ToTokens for ast::ident {\n-        fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n-            cx.parse_tts(self.to_source())\n-        }\n-    }\n-\n-    impl ToTokens for @ast::item {\n-        fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n-            cx.parse_tts(self.to_source())\n-        }\n-    }\n-\n-    impl<'self> ToTokens for &'self [@ast::item] {\n-        fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n-            cx.parse_tts(self.to_source())\n-        }\n-    }\n-\n-    impl ToTokens for ast::Ty {\n-        fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n-            cx.parse_tts(self.to_source())\n-        }\n-    }\n-\n-    impl<'self> ToTokens for &'self [ast::Ty] {\n-        fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n-            cx.parse_tts(self.to_source())\n-        }\n-    }\n-\n-    impl ToTokens for Generics {\n-        fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n-            cx.parse_tts(self.to_source())\n-        }\n-    }\n-\n-    impl ToTokens for @ast::expr {\n-        fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n-            cx.parse_tts(self.to_source())\n-        }\n-    }\n-\n-    impl ToTokens for ast::Block {\n-        fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n-            cx.parse_tts(self.to_source())\n-        }\n-    }\n-\n-    impl<'self> ToTokens for &'self str {\n-        fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n-            cx.parse_tts(self.to_source())\n-        }\n-    }\n-\n-    impl ToTokens for int {\n-        fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n-            cx.parse_tts(self.to_source())\n-        }\n-    }\n-\n-    impl ToTokens for i8 {\n-        fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n-            cx.parse_tts(self.to_source())\n-        }\n-    }\n-\n-    impl ToTokens for i16 {\n-        fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n-            cx.parse_tts(self.to_source())\n-        }\n-    }\n-\n-    impl ToTokens for i32 {\n-        fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n-            cx.parse_tts(self.to_source())\n-        }\n-    }\n-\n-    impl ToTokens for i64 {\n-        fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n-            cx.parse_tts(self.to_source())\n-        }\n-    }\n-\n-    impl ToTokens for uint {\n-        fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n-            cx.parse_tts(self.to_source())\n-        }\n-    }\n-\n-    impl ToTokens for u8 {\n-        fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n-            cx.parse_tts(self.to_source())\n-        }\n-    }\n-\n-    impl ToTokens for u16 {\n-        fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n-            cx.parse_tts(self.to_source())\n-        }\n-    }\n-\n-    impl ToTokens for u32 {\n-        fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n-            cx.parse_tts(self.to_source())\n-        }\n-    }\n-\n-    impl ToTokens for u64 {\n-        fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n-            cx.parse_tts(self.to_source())\n-        }\n-    }\n+    macro_rules! impl_to_tokens(\n+        ($t:ty) => (\n+            impl ToTokens for $t {\n+                fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n+                    cx.parse_tts(self.to_source())\n+                }\n+            }\n+        )\n+    )\n+\n+    macro_rules! impl_to_tokens_self(\n+        ($t:ty) => (\n+            impl<'self> ToTokens for $t {\n+                fn to_tokens(&self, cx: @ExtCtxt) -> ~[token_tree] {\n+                    cx.parse_tts(self.to_source())\n+                }\n+            }\n+        )\n+    )\n+\n+    impl_to_tokens!(ast::ident)\n+    impl_to_tokens!(@ast::item)\n+    impl_to_tokens_self!(&'self [@ast::item])\n+    impl_to_tokens!(ast::Ty)\n+    impl_to_tokens_self!(&'self [ast::Ty])\n+    impl_to_tokens!(Generics)\n+    impl_to_tokens!(@ast::expr)\n+    impl_to_tokens!(ast::Block)\n+    impl_to_tokens_self!(&'self str)\n+    impl_to_tokens!(int)\n+    impl_to_tokens!(i8)\n+    impl_to_tokens!(i16)\n+    impl_to_tokens!(i32)\n+    impl_to_tokens!(i64)\n+    impl_to_tokens!(uint)\n+    impl_to_tokens!(u8)\n+    impl_to_tokens!(u16)\n+    impl_to_tokens!(u32)\n+    impl_to_tokens!(u64)\n \n     pub trait ExtParseUtils {\n         fn parse_item(&self, s: @str) -> @ast::item;\n@@ -366,7 +292,8 @@ pub mod rt {\n pub fn expand_quote_tokens(cx: @ExtCtxt,\n                            sp: span,\n                            tts: &[ast::token_tree]) -> base::MacResult {\n-    base::MRExpr(expand_tts(cx, sp, tts))\n+    let (cx_expr, expr) = expand_tts(cx, sp, tts);\n+    base::MRExpr(expand_wrapper(cx, sp, cx_expr, expr))\n }\n \n pub fn expand_quote_expr(cx: @ExtCtxt,\n@@ -640,7 +567,7 @@ fn mk_tts(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n \n fn expand_tts(cx: @ExtCtxt,\n               sp: span,\n-              tts: &[ast::token_tree]) -> @ast::expr {\n+              tts: &[ast::token_tree]) -> (@ast::expr, @ast::expr) {\n \n     // NB: It appears that the main parser loses its mind if we consider\n     // $foo as a tt_nonterminal during the main parse, so we have to re-parse\n@@ -654,17 +581,14 @@ fn expand_tts(cx: @ExtCtxt,\n         tts.to_owned()\n     );\n     *p.quote_depth += 1u;\n-    let tts = p.parse_all_token_trees();\n-    p.abort_if_errors();\n \n-    // We want to emit a block expression that does a sequence of 'use's to\n-    // import the runtime module, followed by a tt-building expression.\n+    let cx_expr = p.parse_expr();\n+    if !p.eat(&token::COMMA) {\n+        p.fatal(\"Expected token `,`\");\n+    }\n \n-    let uses = ~[ cx.view_use_glob(sp, ast::public,\n-                                   ids_ext(~[~\"syntax\",\n-                                             ~\"ext\",\n-                                             ~\"quote\",\n-                                             ~\"rt\"])) ];\n+    let tts = p.parse_all_token_trees();\n+    p.abort_if_errors();\n \n     // We also bind a single value, sp, to ext_cx.call_site()\n     //\n@@ -683,9 +607,9 @@ fn expand_tts(cx: @ExtCtxt,\n     // the site the string literal occurred, which was in a source file\n     // _other_ than the one the user has control over. For example, an\n     // error in a quote from the protocol compiler, invoked in user code\n-    // using macro_rules! for example, will be attributed to the macro_rules.rs file in\n-    // libsyntax, which the user might not even have source to (unless they\n-    // happen to have a compiler on hand). Over all, the phase distinction\n+    // using macro_rules! for example, will be attributed to the macro_rules.rs\n+    // file in libsyntax, which the user might not even have source to (unless\n+    // they happen to have a compiler on hand). Over all, the phase distinction\n     // just makes quotes \"hard to attribute\". Possibly this could be fixed\n     // by recreating some of the original qq machinery in the tt regime\n     // (pushing fake FileMaps onto the parser to account for original sites\n@@ -705,19 +629,36 @@ fn expand_tts(cx: @ExtCtxt,\n                                   id_ext(\"tt\"),\n                                   cx.expr_vec_uniq(sp, ~[]));\n \n-    cx.expr_block(\n-        cx.block_all(sp, uses,\n-                     ~[stmt_let_sp,\n-                       stmt_let_tt] + mk_tts(cx, sp, tts),\n-                     Some(cx.expr_ident(sp, id_ext(\"tt\")))))\n+    let block = cx.expr_block(\n+        cx.block_all(sp,\n+                     ~[],\n+                     ~[stmt_let_sp, stmt_let_tt] + mk_tts(cx, sp, tts),\n+                     Some(cx.expr_ident(sp, id_ext(\"tt\")))));\n+\n+    (cx_expr, block)\n+}\n+\n+fn expand_wrapper(cx: @ExtCtxt,\n+                  sp: span,\n+                  cx_expr: @ast::expr,\n+                  expr: @ast::expr) -> @ast::expr {\n+    let uses = ~[ cx.view_use_glob(sp, ast::public,\n+                                   ids_ext(~[~\"syntax\",\n+                                             ~\"ext\",\n+                                             ~\"quote\",\n+                                             ~\"rt\"])) ];\n+\n+    let stmt_let_ext_cx = cx.stmt_let(sp, false, id_ext(\"ext_cx\"), cx_expr);\n+\n+    cx.expr_block(cx.block_all(sp, uses, ~[stmt_let_ext_cx], Some(expr)))\n }\n \n fn expand_parse_call(cx: @ExtCtxt,\n                      sp: span,\n                      parse_method: &str,\n                      arg_exprs: ~[@ast::expr],\n                      tts: &[ast::token_tree]) -> @ast::expr {\n-    let tts_expr = expand_tts(cx, sp, tts);\n+    let (cx_expr, tts_expr) = expand_tts(cx, sp, tts);\n \n     let cfg_call = || cx.expr_method_call(\n         sp, cx.expr_ident(sp, id_ext(\"ext_cx\")),\n@@ -728,17 +669,12 @@ fn expand_parse_call(cx: @ExtCtxt,\n         id_ext(\"parse_sess\"), ~[]);\n \n     let new_parser_call =\n-        cx.expr_call_global(sp,\n-                            ids_ext(~[~\"syntax\",\n-                                      ~\"ext\",\n-                                      ~\"quote\",\n-                                      ~\"rt\",\n-                                      ~\"new_parser_from_tts\"]),\n-                            ~[parse_sess_call(),\n-                              cfg_call(),\n-                              tts_expr]);\n-\n-    cx.expr_method_call(sp, new_parser_call,\n-                        id_ext(parse_method),\n-                        arg_exprs)\n+        cx.expr_call(sp,\n+                     cx.expr_ident(sp, id_ext(\"new_parser_from_tts\")),\n+                     ~[parse_sess_call(), cfg_call(), tts_expr]);\n+\n+    let expr = cx.expr_method_call(sp, new_parser_call, id_ext(parse_method),\n+                                   arg_exprs);\n+\n+    expand_wrapper(cx, sp, cx_expr, expr)\n }"}, {"sha": "0112c0adea298ddd9c263cb4207e66b999cb61ee", "filename": "src/test/compile-fail/qquote-1.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c178b52fe594c6724d0cf9124665de7e627899a9/src%2Ftest%2Fcompile-fail%2Fqquote-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c178b52fe594c6724d0cf9124665de7e627899a9/src%2Ftest%2Fcompile-fail%2Fqquote-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fqquote-1.rs?ref=c178b52fe594c6724d0cf9124665de7e627899a9", "patch": "@@ -53,12 +53,12 @@ fn mk_ctxt() -> fake_ext_ctxt {\n \n \n fn main() {\n-    let ext_cx = mk_ctxt();\n+    let cx = mk_ctxt();\n \n-    let abc = quote_expr!(23);\n+    let abc = quote_expr!(cx, 23);\n     check_pp(abc,  pprust::print_expr, \"23\");\n \n-    let expr3 = quote_expr!(2 - $abcd + 7); //~ ERROR unresolved name: abcd\n+    let expr3 = quote_expr!(cx, 2 - $abcd + 7); //~ ERROR unresolved name: abcd\n     check_pp(expr3,  pprust::print_expr, \"2 - 23 + 7\");\n }\n "}, {"sha": "57355885e2f46d1db79b46d746224300554a003a", "filename": "src/test/compile-fail/qquote-2.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c178b52fe594c6724d0cf9124665de7e627899a9/src%2Ftest%2Fcompile-fail%2Fqquote-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c178b52fe594c6724d0cf9124665de7e627899a9/src%2Ftest%2Fcompile-fail%2Fqquote-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fqquote-2.rs?ref=c178b52fe594c6724d0cf9124665de7e627899a9", "patch": "@@ -51,9 +51,9 @@ fn mk_ctxt() -> fake_ext_ctxt {\n \n \n fn main() {\n-    let ext_cx = mk_ctxt();\n+    let cx = mk_ctxt();\n \n-    let stmt = quote_stmt!(let x int = 20;); //~ ERROR expected end-of-string\n+    let stmt = quote_stmt!(cx, let x int = 20;); //~ ERROR expected end-of-string\n     check_pp(*stmt,  pprust::print_stmt, \"\");\n }\n "}, {"sha": "8951eff2fb9bd684636d316ed9672ec7fafe5225", "filename": "src/test/run-pass-fulldeps/issue-1926.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c178b52fe594c6724d0cf9124665de7e627899a9/src%2Ftest%2Frun-pass-fulldeps%2Fissue-1926.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c178b52fe594c6724d0cf9124665de7e627899a9/src%2Ftest%2Frun-pass-fulldeps%2Fissue-1926.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fissue-1926.rs?ref=c178b52fe594c6724d0cf9124665de7e627899a9", "patch": "@@ -54,9 +54,9 @@ fn mk_ctxt() -> fake_ext_ctxt {\n \n \n fn main() {\n-    let ext_cx = mk_ctxt();\n-    let s = quote_expr!(__s);\n-    let e = quote_expr!(__e);\n-    let f = quote_expr!($s.foo {|__e| $e});\n+    let cx = mk_ctxt();\n+    let s = quote_expr!(cx, __s);\n+    let e = quote_expr!(cx, __e);\n+    let f = quote_expr!(cx, $s.foo {|__e| $e});\n     log(error, pprust::expr_to_str(f));\n }"}, {"sha": "c39c32753679bc2afa69e875bc0f98b1751b1a9e", "filename": "src/test/run-pass-fulldeps/qquote.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c178b52fe594c6724d0cf9124665de7e627899a9/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c178b52fe594c6724d0cf9124665de7e627899a9/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs?ref=c178b52fe594c6724d0cf9124665de7e627899a9", "patch": "@@ -52,22 +52,22 @@ fn mk_ctxt() -> fake_ext_ctxt {\n }\n \n fn main() {\n-    let ext_cx = mk_ctxt();\n+    let cx = mk_ctxt();\n \n-    let abc = quote_expr!(23);\n+    let abc = quote_expr!(cx, 23);\n     check_pp(ext_cx, abc,  pprust::print_expr, ~\"23\");\n \n \n-    let ty = quote_ty!(int);\n+    let ty = quote_ty!(cx, int);\n     check_pp(ext_cx, ty, pprust::print_type, ~\"int\");\n \n-    let item = quote_item!(static x : int = 10;).get();\n+    let item = quote_item!(cx, static x : int = 10;).get();\n     check_pp(ext_cx, item, pprust::print_item, ~\"static x: int = 10;\");\n \n-    let stmt = quote_stmt!(let x = 20;);\n+    let stmt = quote_stmt!(cx, let x = 20;);\n     check_pp(ext_cx, *stmt, pprust::print_stmt, ~\"let x = 20;\");\n \n-    let pat = quote_pat!(Some(_));\n+    let pat = quote_pat!(cx, Some(_));\n     check_pp(ext_cx, pat, pprust::print_pat, ~\"Some(_)\");\n \n }"}, {"sha": "62ce4e7c02c0901e984c949aaf7048b91fcabc35", "filename": "src/test/run-pass-fulldeps/quote-tokens.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/c178b52fe594c6724d0cf9124665de7e627899a9/src%2Ftest%2Frun-pass-fulldeps%2Fquote-tokens.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c178b52fe594c6724d0cf9124665de7e627899a9/src%2Ftest%2Frun-pass-fulldeps%2Fquote-tokens.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fquote-tokens.rs?ref=c178b52fe594c6724d0cf9124665de7e627899a9", "patch": "@@ -12,15 +12,15 @@ extern mod syntax;\n \n use syntax::ext::base::ExtCtxt;\n \n-fn syntax_extension(ext_cx: @ExtCtxt) {\n-    let e_toks : ~[syntax::ast::token_tree] = quote_tokens!(1 + 2);\n-    let p_toks : ~[syntax::ast::token_tree] = quote_tokens!((x, 1 .. 4, *));\n+fn syntax_extension(cx: @ExtCtxt) {\n+    let e_toks : ~[syntax::ast::token_tree] = quote_tokens!(cx, 1 + 2);\n+    let p_toks : ~[syntax::ast::token_tree] = quote_tokens!(cx, (x, 1 .. 4, *));\n \n-    let a: @syntax::ast::expr = quote_expr!(1 + 2);\n-    let _b: Option<@syntax::ast::item> = quote_item!( static foo : int = $e_toks; );\n-    let _c: @syntax::ast::pat = quote_pat!( (x, 1 .. 4, *) );\n-    let _d: @syntax::ast::stmt = quote_stmt!( let x = $a; );\n-    let _e: @syntax::ast::expr = quote_expr!( match foo { $p_toks => 10 } );\n+    let a: @syntax::ast::expr = quote_expr!(cx, 1 + 2);\n+    let _b: Option<@syntax::ast::item> = quote_item!(cx, static foo : int = $e_toks; );\n+    let _c: @syntax::ast::pat = quote_pat!(cx, (x, 1 .. 4, *) );\n+    let _d: @syntax::ast::stmt = quote_stmt!(cx, let x = $a; );\n+    let _e: @syntax::ast::expr = quote_expr!(cx, match foo { $p_toks => 10 } );\n }\n \n fn main() {"}]}