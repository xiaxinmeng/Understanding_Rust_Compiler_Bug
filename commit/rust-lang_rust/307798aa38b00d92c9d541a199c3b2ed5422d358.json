{"sha": "307798aa38b00d92c9d541a199c3b2ed5422d358", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMwNzc5OGFhMzhiMDBkOTJjOWQ1NDFhMTk5YzNiMmVkNTQyMmQzNTg=", "commit": {"author": {"name": "Saleem Jaffer", "email": "ssaleem1992@gmail.com", "date": "2019-07-27T12:19:12Z"}, "committer": {"name": "Saleem Jaffer", "email": "ssaleem1992@gmail.com", "date": "2019-07-29T08:05:09Z"}, "message": "fixing fallout due to InterpError refactor", "tree": {"sha": "8e552e9fef3561aa48fe4023391a445a85f01da0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8e552e9fef3561aa48fe4023391a445a85f01da0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/307798aa38b00d92c9d541a199c3b2ed5422d358", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/307798aa38b00d92c9d541a199c3b2ed5422d358", "html_url": "https://github.com/rust-lang/rust/commit/307798aa38b00d92c9d541a199c3b2ed5422d358", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/307798aa38b00d92c9d541a199c3b2ed5422d358/comments", "author": {"login": "saleemjaffer", "id": 19221716, "node_id": "MDQ6VXNlcjE5MjIxNzE2", "avatar_url": "https://avatars.githubusercontent.com/u/19221716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saleemjaffer", "html_url": "https://github.com/saleemjaffer", "followers_url": "https://api.github.com/users/saleemjaffer/followers", "following_url": "https://api.github.com/users/saleemjaffer/following{/other_user}", "gists_url": "https://api.github.com/users/saleemjaffer/gists{/gist_id}", "starred_url": "https://api.github.com/users/saleemjaffer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saleemjaffer/subscriptions", "organizations_url": "https://api.github.com/users/saleemjaffer/orgs", "repos_url": "https://api.github.com/users/saleemjaffer/repos", "events_url": "https://api.github.com/users/saleemjaffer/events{/privacy}", "received_events_url": "https://api.github.com/users/saleemjaffer/received_events", "type": "User", "site_admin": false}, "committer": {"login": "saleemjaffer", "id": 19221716, "node_id": "MDQ6VXNlcjE5MjIxNzE2", "avatar_url": "https://avatars.githubusercontent.com/u/19221716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saleemjaffer", "html_url": "https://github.com/saleemjaffer", "followers_url": "https://api.github.com/users/saleemjaffer/followers", "following_url": "https://api.github.com/users/saleemjaffer/following{/other_user}", "gists_url": "https://api.github.com/users/saleemjaffer/gists{/gist_id}", "starred_url": "https://api.github.com/users/saleemjaffer/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saleemjaffer/subscriptions", "organizations_url": "https://api.github.com/users/saleemjaffer/orgs", "repos_url": "https://api.github.com/users/saleemjaffer/repos", "events_url": "https://api.github.com/users/saleemjaffer/events{/privacy}", "received_events_url": "https://api.github.com/users/saleemjaffer/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4f0ab6ccce86bb9742090b97f1e130360ac7734a", "url": "https://api.github.com/repos/rust-lang/rust/commits/4f0ab6ccce86bb9742090b97f1e130360ac7734a", "html_url": "https://github.com/rust-lang/rust/commit/4f0ab6ccce86bb9742090b97f1e130360ac7734a"}], "stats": {"total": 525, "additions": 259, "deletions": 266}, "files": [{"sha": "b5ec30c9212f37b5edf0116d88c61bbebf906613", "filename": "src/librustc/mir/interpret/allocation.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/307798aa38b00d92c9d541a199c3b2ed5422d358/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/307798aa38b00d92c9d541a199c3b2ed5422d358/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fallocation.rs?ref=307798aa38b00d92c9d541a199c3b2ed5422d358", "patch": "@@ -4,6 +4,7 @@ use super::{\n     Pointer, InterpResult, AllocId, ScalarMaybeUndef, write_target_uint, read_target_uint, Scalar,\n };\n \n+use super::error::UnsupportedInfo::*;\n use crate::ty::layout::{Size, Align};\n use syntax::ast::Mutability;\n use std::iter;\n@@ -244,7 +245,7 @@ impl<'tcx, Tag: Copy, Extra: AllocationExtra<Tag>> Allocation<Tag, Extra> {\n                 Ok(&self.get_bytes(cx, ptr, size_with_null)?[..size])\n             }\n             // This includes the case where `offset` is out-of-bounds to begin with.\n-            None => err!(UnterminatedCString(ptr.erase_tag())),\n+            None => err!(Unsupported(UnterminatedCString(ptr.erase_tag()))),\n         }\n     }\n \n@@ -446,7 +447,7 @@ impl<'tcx, Tag: Copy, Extra> Allocation<Tag, Extra> {\n         if self.relocations(cx, ptr, size).is_empty() {\n             Ok(())\n         } else {\n-            err!(ReadPointerAsBytes)\n+            err!(Unsupported(ReadPointerAsBytes))\n         }\n     }\n \n@@ -516,7 +517,7 @@ impl<'tcx, Tag, Extra> Allocation<Tag, Extra> {\n         self.undef_mask.is_range_defined(\n             ptr.offset,\n             ptr.offset + size,\n-        ).or_else(|idx| err!(ReadUndefBytes(idx)))\n+        ).or_else(|idx| err!(Unsupported(ReadUndefBytes(idx))))\n     }\n \n     pub fn mark_definedness("}, {"sha": "c28582f1ab08ddb674695d21efed9d646527e7c8", "filename": "src/librustc/mir/interpret/error.rs", "status": "modified", "additions": 104, "deletions": 68, "changes": 172, "blob_url": "https://github.com/rust-lang/rust/blob/307798aa38b00d92c9d541a199c3b2ed5422d358/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/307798aa38b00d92c9d541a199c3b2ed5422d358/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Ferror.rs?ref=307798aa38b00d92c9d541a199c3b2ed5422d358", "patch": "@@ -142,7 +142,7 @@ impl<'tcx> ConstEvalErr<'tcx> {\n             InterpError::InvalidProgram(Layout(LayoutError::Unknown(_))) |\n             InterpError::InvalidProgram(TooGeneric) =>\n                 return Err(ErrorHandled::TooGeneric),\n-            InterpError::Layout(LayoutError::SizeOverflow(_)) |\n+            InterpError::InvalidProgram(Layout(LayoutError::SizeOverflow(_))) |\n             InterpError::InvalidProgram(TypeckError) =>\n                 return Err(ErrorHandled::Reported),\n             _ => {},\n@@ -325,16 +325,47 @@ pub enum InvalidProgramInfo<'tcx> {\n     Layout(layout::LayoutError<'tcx>),\n }\n \n+impl fmt::Debug for InvalidProgramInfo<'tcx> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        use InvalidProgramInfo::*;\n+        match self {\n+            TooGeneric =>\n+                write!(f, \"encountered overly generic constant\"),\n+            ReferencedConstant =>\n+                write!(f, \"referenced constant has errors\"),\n+            TypeckError =>\n+                write!(f, \"encountered constants with type errors, stopping evaluation\"),\n+            Layout(ref err) =>\n+                write!(f, \"rustc layout computation failed: {:?}\", err),\n+        }\n+    }\n+}\n+\n #[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]\n pub enum UndefinedBehaviourInfo {\n-    /// Handle cases which for which we do not have a fixed variant\n+    /// Handle cases which for which we do not have a fixed variant.\n     Ub(String),\n+    /// Unreachable code was executed.\n     Unreachable,\n }\n \n+impl fmt::Debug for UndefinedBehaviourInfo {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        use UndefinedBehaviourInfo::*;\n+        match self {\n+            Ub(ref msg) =>\n+                write!(f, \"{}\", msg),\n+            Unreachable =>\n+                write!(f, \"entered unreachable code\"),\n+        }\n+    }\n+}\n+\n #[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]\n pub enum UnsupportedInfo<'tcx> {\n     Unimplemented(String),\n+\n+    // -- Everything below is not classified yet --\n     FunctionAbiMismatch(Abi, Abi),\n     FunctionArgMismatch(Ty<'tcx>, Ty<'tcx>),\n     FunctionRetMismatch(Ty<'tcx>, Ty<'tcx>),\n@@ -400,6 +431,19 @@ pub enum ResourceExhaustionInfo {\n     InfiniteLoop,\n }\n \n+impl fmt::Debug for ResourceExhaustionInfo {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        use ResourceExhaustionInfo::*;\n+        match self {\n+            StackFrameLimitReached =>\n+                write!(f, \"reached the configured maximum number of stack frames\"),\n+            InfiniteLoop =>\n+                write!(f, \"duplicate interpreter state observed here, const evaluation will never \\\n+                    terminate\"),\n+        }\n+    }\n+}\n+\n #[derive(Clone, RustcEncodable, RustcDecodable, HashStable)]\n pub enum InterpError<'tcx> {\n     /// The program panicked.\n@@ -431,139 +475,131 @@ impl fmt::Display for InterpError<'_> {\n impl fmt::Debug for InterpError<'_> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         use InterpError::*;\n+        use UnsupportedInfo::*;\n         match *self {\n-            PointerOutOfBounds { ptr, msg, allocation_size } => {\n+            Unsupported(PointerOutOfBounds { ptr, msg, allocation_size }) => {\n                 write!(f, \"{} failed: pointer must be in-bounds at offset {}, \\\n                           but is outside bounds of allocation {} which has size {}\",\n                     msg, ptr.offset.bytes(), ptr.alloc_id, allocation_size.bytes())\n             },\n-            ValidationFailure(ref err) => {\n+            Unsupported(ValidationFailure(ref err)) => {\n                 write!(f, \"type validation failed: {}\", err)\n             }\n-            NoMirFor(ref func) => write!(f, \"no mir for `{}`\", func),\n-            FunctionAbiMismatch(caller_abi, callee_abi) =>\n+            Unsupported(NoMirFor(ref func)) => write!(f, \"no mir for `{}`\", func),\n+            Unsupported(FunctionAbiMismatch(caller_abi, callee_abi)) =>\n                 write!(f, \"tried to call a function with ABI {:?} using caller ABI {:?}\",\n                     callee_abi, caller_abi),\n-            FunctionArgMismatch(caller_ty, callee_ty) =>\n+            Unsupported(FunctionArgMismatch(caller_ty, callee_ty)) =>\n                 write!(f, \"tried to call a function with argument of type {:?} \\\n                            passing data of type {:?}\",\n                     callee_ty, caller_ty),\n-            FunctionRetMismatch(caller_ty, callee_ty) =>\n+            Unsupported(FunctionRetMismatch(caller_ty, callee_ty)) =>\n                 write!(f, \"tried to call a function with return type {:?} \\\n                            passing return place of type {:?}\",\n                     callee_ty, caller_ty),\n-            FunctionArgCountMismatch =>\n+            Unsupported(FunctionArgCountMismatch) =>\n                 write!(f, \"tried to call a function with incorrect number of arguments\"),\n-            ReallocatedWrongMemoryKind(ref old, ref new) =>\n+            Unsupported(ReallocatedWrongMemoryKind(ref old, ref new)) =>\n                 write!(f, \"tried to reallocate memory from {} to {}\", old, new),\n-            DeallocatedWrongMemoryKind(ref old, ref new) =>\n+            Unsupported(DeallocatedWrongMemoryKind(ref old, ref new)) =>\n                 write!(f, \"tried to deallocate {} memory but gave {} as the kind\", old, new),\n-            InvalidChar(c) =>\n+            Unsupported(InvalidChar(c)) =>\n                 write!(f, \"tried to interpret an invalid 32-bit value as a char: {}\", c),\n-            AlignmentCheckFailed { required, has } =>\n+            Unsupported(AlignmentCheckFailed { required, has }) =>\n                write!(f, \"tried to access memory with alignment {}, but alignment {} is required\",\n                       has.bytes(), required.bytes()),\n-            TypeNotPrimitive(ty) =>\n+            Unsupported(TypeNotPrimitive(ty)) =>\n                 write!(f, \"expected primitive type, got {}\", ty),\n-            Layout(ref err) =>\n-                write!(f, \"rustc layout computation failed: {:?}\", err),\n-            PathNotFound(ref path) =>\n+            Unsupported(PathNotFound(ref path)) =>\n                 write!(f, \"Cannot find path {:?}\", path),\n-            IncorrectAllocationInformation(size, size2, align, align2) =>\n+            Unsupported(IncorrectAllocationInformation(size, size2, align, align2)) =>\n                 write!(f, \"incorrect alloc info: expected size {} and align {}, \\\n                            got size {} and align {}\",\n                     size.bytes(), align.bytes(), size2.bytes(), align2.bytes()),\n-            InvalidDiscriminant(val) =>\n+            Unsupported(InvalidDiscriminant(val)) =>\n                 write!(f, \"encountered invalid enum discriminant {}\", val),\n-            Exit(code) =>\n-                write!(f, \"exited with status code {}\", code),\n-            InvalidMemoryAccess =>\n+            Unsupported(InvalidMemoryAccess) =>\n                 write!(f, \"tried to access memory through an invalid pointer\"),\n-            DanglingPointerDeref =>\n+            Unsupported(DanglingPointerDeref) =>\n                 write!(f, \"dangling pointer was dereferenced\"),\n-            DoubleFree =>\n+            Unsupported(DoubleFree) =>\n                 write!(f, \"tried to deallocate dangling pointer\"),\n-            InvalidFunctionPointer =>\n+            Unsupported(InvalidFunctionPointer) =>\n                 write!(f, \"tried to use a function pointer after offsetting it\"),\n-            InvalidBool =>\n+            Unsupported(InvalidBool) =>\n                 write!(f, \"invalid boolean value read\"),\n-            InvalidNullPointerUsage =>\n+            Unsupported(InvalidNullPointerUsage) =>\n                 write!(f, \"invalid use of NULL pointer\"),\n-            ReadPointerAsBytes =>\n+            Unsupported(ReadPointerAsBytes) =>\n                 write!(f, \"a raw memory access tried to access part of a pointer value as raw \\\n                     bytes\"),\n-            ReadBytesAsPointer =>\n+            Unsupported(ReadBytesAsPointer) =>\n                 write!(f, \"a memory access tried to interpret some bytes as a pointer\"),\n-            ReadForeignStatic =>\n+            Unsupported(ReadForeignStatic) =>\n                 write!(f, \"tried to read from foreign (extern) static\"),\n-            InvalidPointerMath =>\n+            Unsupported(InvalidPointerMath) =>\n                 write!(f, \"attempted to do invalid arithmetic on pointers that would leak base \\\n                     addresses, e.g., comparing pointers into different allocations\"),\n-            DeadLocal =>\n+            Unsupported(DeadLocal) =>\n                 write!(f, \"tried to access a dead local variable\"),\n-            DerefFunctionPointer =>\n+            Unsupported(DerefFunctionPointer) =>\n                 write!(f, \"tried to dereference a function pointer\"),\n-            ExecuteMemory =>\n+            Unsupported(ExecuteMemory) =>\n                 write!(f, \"tried to treat a memory pointer as a function pointer\"),\n-            StackFrameLimitReached =>\n-                write!(f, \"reached the configured maximum number of stack frames\"),\n-            OutOfTls =>\n+            Unsupported(OutOfTls) =>\n                 write!(f, \"reached the maximum number of representable TLS keys\"),\n-            TlsOutOfBounds =>\n+            Unsupported(TlsOutOfBounds) =>\n                 write!(f, \"accessed an invalid (unallocated) TLS key\"),\n-            CalledClosureAsFunction =>\n+            Unsupported(CalledClosureAsFunction) =>\n                 write!(f, \"tried to call a closure through a function pointer\"),\n-            VtableForArgumentlessMethod =>\n+            Unsupported(VtableForArgumentlessMethod) =>\n                 write!(f, \"tried to call a vtable function without arguments\"),\n-            ModifiedConstantMemory =>\n+            Unsupported(ModifiedConstantMemory) =>\n                 write!(f, \"tried to modify constant memory\"),\n-            ModifiedStatic =>\n+            Unsupported(ModifiedStatic) =>\n                 write!(f, \"tried to modify a static's initial value from another static's \\\n                     initializer\"),\n-            AssumptionNotHeld =>\n+            Unsupported(AssumptionNotHeld) =>\n                 write!(f, \"`assume` argument was false\"),\n-            InlineAsm =>\n+            Unsupported(InlineAsm) =>\n                 write!(f, \"miri does not support inline assembly\"),\n-            ReallocateNonBasePtr =>\n+            Unsupported(ReallocateNonBasePtr) =>\n                 write!(f, \"tried to reallocate with a pointer not to the beginning of an \\\n                     existing object\"),\n-            DeallocateNonBasePtr =>\n+            Unsupported(DeallocateNonBasePtr) =>\n                 write!(f, \"tried to deallocate with a pointer not to the beginning of an \\\n                     existing object\"),\n-            HeapAllocZeroBytes =>\n+            Unsupported(HeapAllocZeroBytes) =>\n                 write!(f, \"tried to re-, de- or allocate zero bytes on the heap\"),\n-            Unreachable =>\n-                write!(f, \"entered unreachable code\"),\n-            ReadFromReturnPointer =>\n+            Unsupported(ReadFromReturnPointer) =>\n                 write!(f, \"tried to read from the return pointer\"),\n-            UnimplementedTraitSelection =>\n+            Unsupported(UnimplementedTraitSelection) =>\n                 write!(f, \"there were unresolved type arguments during trait selection\"),\n-            TypeckError =>\n-                write!(f, \"encountered constants with type errors, stopping evaluation\"),\n-            TooGeneric =>\n-                write!(f, \"encountered overly generic constant\"),\n-            ReferencedConstant =>\n-                write!(f, \"referenced constant has errors\"),\n-            InfiniteLoop =>\n-                write!(f, \"duplicate interpreter state observed here, const evaluation will never \\\n-                    terminate\"),\n-            InvalidBoolOp(_) =>\n+            Unsupported(InvalidBoolOp(_)) =>\n                 write!(f, \"invalid boolean operation\"),\n-            UnterminatedCString(_) =>\n+            Unsupported(UnterminatedCString(_)) =>\n                 write!(f, \"attempted to get length of a null terminated string, but no null \\\n                     found before end of allocation\"),\n-            ReadUndefBytes(_) =>\n+            Unsupported(ReadUndefBytes(_)) =>\n                 write!(f, \"attempted to read undefined bytes\"),\n-            HeapAllocNonPowerOfTwoAlignment(_) =>\n+            Unsupported(HeapAllocNonPowerOfTwoAlignment(_)) =>\n                 write!(f, \"tried to re-, de-, or allocate heap memory with alignment that is \\\n                     not a power of two\"),\n-            MachineError(ref msg) |\n-            Unimplemented(ref msg) |\n-            AbiViolation(ref msg) |\n-            Intrinsic(ref msg) =>\n+            Unsupported(MachineError(ref msg)) |\n+            Unsupported(Unimplemented(ref msg)) |\n+            Unsupported(AbiViolation(ref msg)) |\n+            Unsupported(Intrinsic(ref msg)) =>\n                 write!(f, \"{}\", msg),\n+            InvalidProgram(ref msg) =>\n+                write!(f, \"{:?}\", msg),\n+            UndefinedBehaviour(ref msg) =>\n+                write!(f, \"{:?}\", msg),\n+            ResourceExhaustion(ref msg) =>\n+                write!(f, \"{:?}\", msg),\n             Panic(ref msg) =>\n                 write!(f, \"{:?}\", msg),\n+            Exit(code) =>\n+                write!(f, \"exited with status code {}\", code),\n         }\n     }\n }"}, {"sha": "ceed59885b27501919c74daa4475f5085d763ac0", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/307798aa38b00d92c9d541a199c3b2ed5422d358/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/307798aa38b00d92c9d541a199c3b2ed5422d358/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=307798aa38b00d92c9d541a199c3b2ed5422d358", "patch": "@@ -12,7 +12,8 @@ mod pointer;\n \n pub use self::error::{\n     InterpErrorInfo, InterpResult, InterpError, AssertMessage, ConstEvalErr, struct_error,\n-    FrameInfo, ConstEvalRawResult, ConstEvalResult, ErrorHandled, PanicMessage\n+    FrameInfo, ConstEvalRawResult, ConstEvalResult, ErrorHandled, PanicMessage, UnsupportedInfo,\n+    InvalidProgramInfo, ResourceExhaustionInfo, UndefinedBehaviourInfo,\n };\n \n pub use self::value::{Scalar, ScalarMaybeUndef, RawConst, ConstValue};"}, {"sha": "afbe1ed9a9395f583dc151d977db7820bbc7875b", "filename": "src/librustc/mir/interpret/pointer.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/307798aa38b00d92c9d541a199c3b2ed5422d358/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/307798aa38b00d92c9d541a199c3b2ed5422d358/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fpointer.rs?ref=307798aa38b00d92c9d541a199c3b2ed5422d358", "patch": "@@ -1,5 +1,6 @@\n use std::fmt::{self, Display};\n \n+use super::error::UnsupportedInfo::*;\n use crate::mir;\n use crate::ty::layout::{self, HasDataLayout, Size};\n use rustc_macros::HashStable;\n@@ -198,11 +199,11 @@ impl<'tcx, Tag> Pointer<Tag> {\n         msg: CheckInAllocMsg,\n     ) -> InterpResult<'tcx, ()> {\n         if self.offset > allocation_size {\n-            err!(PointerOutOfBounds {\n+            err!(Unsupported(PointerOutOfBounds {\n                 ptr: self.erase_tag(),\n                 msg,\n                 allocation_size,\n-            })\n+            }))\n         } else {\n             Ok(())\n         }"}, {"sha": "29bf94292ef86e11fc941b7101b5822682607fae", "filename": "src/librustc/mir/interpret/value.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/307798aa38b00d92c9d541a199c3b2ed5422d358/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/307798aa38b00d92c9d541a199c3b2ed5422d358/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fvalue.rs?ref=307798aa38b00d92c9d541a199c3b2ed5422d358", "patch": "@@ -2,6 +2,7 @@ use std::fmt;\n use rustc_macros::HashStable;\n use rustc_apfloat::{Float, ieee::{Double, Single}};\n \n+use super::error::UnsupportedInfo::*;\n use crate::ty::{Ty, InferConst, ParamConst, layout::{HasDataLayout, Size, Align}, subst::SubstsRef};\n use crate::ty::PlaceholderConst;\n use crate::hir::def_id::DefId;\n@@ -360,7 +361,7 @@ impl<'tcx, Tag> Scalar<Tag> {\n                 Scalar::check_data(data, size);\n                 Ok(data)\n             }\n-            Scalar::Ptr(_) => err!(ReadPointerAsBytes),\n+            Scalar::Ptr(_) => err!(Unsupported(ReadPointerAsBytes)),\n         }\n     }\n \n@@ -373,8 +374,8 @@ impl<'tcx, Tag> Scalar<Tag> {\n     #[inline]\n     pub fn to_ptr(self) -> InterpResult<'tcx, Pointer<Tag>> {\n         match self {\n-            Scalar::Raw { data: 0, .. } => err!(InvalidNullPointerUsage),\n-            Scalar::Raw { .. } => err!(ReadBytesAsPointer),\n+            Scalar::Raw { data: 0, .. } => err!(Unsupported(InvalidNullPointerUsage)),\n+            Scalar::Raw { .. } => err!(Unsupported(ReadBytesAsPointer)),\n             Scalar::Ptr(p) => Ok(p),\n         }\n     }\n@@ -406,15 +407,15 @@ impl<'tcx, Tag> Scalar<Tag> {\n         match self {\n             Scalar::Raw { data: 0, size: 1 } => Ok(false),\n             Scalar::Raw { data: 1, size: 1 } => Ok(true),\n-            _ => err!(InvalidBool),\n+            _ => err!(Unsupported(InvalidBool)),\n         }\n     }\n \n     pub fn to_char(self) -> InterpResult<'tcx, char> {\n         let val = self.to_u32()?;\n         match ::std::char::from_u32(val) {\n             Some(c) => Ok(c),\n-            None => err!(InvalidChar(val as u128)),\n+            None => err!(Unsupported(InvalidChar(val as u128))),\n         }\n     }\n \n@@ -537,7 +538,7 @@ impl<'tcx, Tag> ScalarMaybeUndef<Tag> {\n     pub fn not_undef(self) -> InterpResult<'static, Scalar<Tag>> {\n         match self {\n             ScalarMaybeUndef::Scalar(scalar) => Ok(scalar),\n-            ScalarMaybeUndef::Undef => err!(ReadUndefBytes(Size::from_bytes(0))),\n+            ScalarMaybeUndef::Undef => err!(Unsupported(ReadUndefBytes(Size::from_bytes(0)))),\n         }\n     }\n "}, {"sha": "60381e0365fae8ba19b85652bdcc6e77b9a396f4", "filename": "src/librustc_mir/const_eval.rs", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/307798aa38b00d92c9d541a199c3b2ed5422d358/src%2Flibrustc_mir%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/307798aa38b00d92c9d541a199c3b2ed5422d358/src%2Flibrustc_mir%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fconst_eval.rs?ref=307798aa38b00d92c9d541a199c3b2ed5422d358", "patch": "@@ -24,7 +24,8 @@ use crate::interpret::{self,\n     RawConst, ConstValue,\n     InterpResult, InterpErrorInfo, InterpError, GlobalId, InterpCx, StackPopCleanup,\n     Allocation, AllocId, MemoryKind,\n-    snapshot, RefTracking, intern_const_alloc_recursive,\n+    snapshot, RefTracking, intern_const_alloc_recursive, UnsupportedInfo::*,\n+    InvalidProgramInfo::*,\n };\n \n /// Number of steps until the detector even starts doing anything.\n@@ -183,7 +184,7 @@ fn eval_body_using_ecx<'mir, 'tcx>(\n \n impl<'tcx> Into<InterpErrorInfo<'tcx>> for ConstEvalError {\n     fn into(self) -> InterpErrorInfo<'tcx> {\n-        InterpError::MachineError(self.to_string()).into()\n+        InterpError::Unsupported(MachineError(self.to_string())).into()\n     }\n }\n \n@@ -352,15 +353,17 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n                     ecx.goto_block(ret)?; // fully evaluated and done\n                     Ok(None)\n                 } else {\n-                    err!(MachineError(format!(\"calling non-const function `{}`\", instance)))\n+                    err!(Unsupported(\n+                        MachineError(format!(\"calling non-const function `{}`\", instance))\n+                    ))\n                 };\n             }\n         }\n         // This is a const fn. Call it.\n         Ok(Some(match ecx.load_mir(instance.def) {\n             Ok(body) => body,\n             Err(err) => {\n-                if let InterpError::NoMirFor(ref path) = err.kind {\n+                if let InterpError::Unsupported(NoMirFor(ref path)) = err.kind {\n                     return Err(\n                         ConstEvalError::NeedsRfc(format!(\"calling extern function `{}`\", path))\n                             .into(),\n@@ -412,7 +415,7 @@ impl<'mir, 'tcx> interpret::Machine<'mir, 'tcx> for CompileTimeInterpreter<'mir,\n         _tcx: TyCtxt<'tcx>,\n         _def_id: DefId,\n     ) -> InterpResult<'tcx, Cow<'tcx, Allocation<Self::PointerTag>>> {\n-        err!(ReadForeignStatic)\n+        err!(Unsupported(ReadForeignStatic))\n     }\n \n     #[inline(always)]\n@@ -698,7 +701,7 @@ pub fn const_eval_raw_provider<'tcx>(\n                 // any other kind of error will be reported to the user as a deny-by-default lint\n                 _ => if let Some(p) = cid.promoted {\n                     let span = tcx.promoted_mir(def_id)[p].span;\n-                    if let InterpError::ReferencedConstant = err.error {\n+                    if let InterpError::InvalidProgram(ReferencedConstant) = err.error {\n                         err.report_as_error(\n                             tcx.at(span),\n                             \"evaluation of constant expression failed\","}, {"sha": "443d264b351f71cd8543df55d2cfba066ef3b733", "filename": "src/librustc_mir/interpret/cast.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/307798aa38b00d92c9d541a199c3b2ed5422d358/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/307798aa38b00d92c9d541a199c3b2ed5422d358/src%2Flibrustc_mir%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fcast.rs?ref=307798aa38b00d92c9d541a199c3b2ed5422d358", "patch": "@@ -9,7 +9,8 @@ use rustc_apfloat::{Float, FloatConvert};\n use rustc::mir::interpret::{\n     Scalar, InterpResult, Pointer, PointerArithmetic, InterpError,\n };\n-use rustc::mir::CastKind;\n+use rustc::mir::{CastKind, interpret::{UnsupportedInfo::*, InvalidProgramInfo::*}};\n+\n \n use super::{InterpCx, Machine, PlaceTy, OpTy, Immediate, FnVal};\n \n@@ -85,7 +86,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                             self.param_env,\n                             def_id,\n                             substs,\n-                        ).ok_or_else(|| InterpError::TooGeneric.into());\n+                        ).ok_or_else(|| InterpError::InvalidProgram(TooGeneric).into());\n                         let fn_ptr = self.memory.create_fn_alloc(FnVal::Instance(instance?));\n                         self.write_scalar(Scalar::Ptr(fn_ptr.into()), dest)?;\n                     }\n@@ -199,7 +200,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             },\n \n             // Casts to bool are not permitted by rustc, no need to handle them here.\n-            _ => err!(Unimplemented(format!(\"int to {:?} cast\", dest_layout.ty))),\n+            _ => err!(Unsupported(Unimplemented(format!(\"int to {:?} cast\", dest_layout.ty)))),\n         }\n     }\n "}, {"sha": "e732484b9b7bcb69daf492894e1474d673794c9e", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/307798aa38b00d92c9d541a199c3b2ed5422d358/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/307798aa38b00d92c9d541a199c3b2ed5422d358/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=307798aa38b00d92c9d541a199c3b2ed5422d358", "patch": "@@ -17,7 +17,8 @@ use rustc::mir::interpret::{\n     ErrorHandled,\n     GlobalId, Scalar, Pointer, FrameInfo, AllocId,\n     InterpResult, InterpError,\n-    truncate, sign_extend,\n+    truncate, sign_extend, UnsupportedInfo::*, InvalidProgramInfo::*,\n+    ResourceExhaustionInfo::*, UndefinedBehaviourInfo::*,\n };\n use rustc_data_structures::fx::FxHashMap;\n \n@@ -135,7 +136,7 @@ pub enum LocalValue<Tag=(), Id=AllocId> {\n impl<'tcx, Tag: Copy + 'static> LocalState<'tcx, Tag> {\n     pub fn access(&self) -> InterpResult<'tcx, Operand<Tag>> {\n         match self.value {\n-            LocalValue::Dead => err!(DeadLocal),\n+            LocalValue::Dead => err!(Unsupported(DeadLocal)),\n             LocalValue::Uninitialized =>\n                 bug!(\"The type checker should prevent reading from a never-written local\"),\n             LocalValue::Live(val) => Ok(val),\n@@ -148,7 +149,7 @@ impl<'tcx, Tag: Copy + 'static> LocalState<'tcx, Tag> {\n         &mut self,\n     ) -> InterpResult<'tcx, Result<&mut LocalValue<Tag>, MemPlace<Tag>>> {\n         match self.value {\n-            LocalValue::Dead => err!(DeadLocal),\n+            LocalValue::Dead => err!(Unsupported(DeadLocal)),\n             LocalValue::Live(Operand::Indirect(mplace)) => Ok(Err(mplace)),\n             ref mut local @ LocalValue::Live(Operand::Immediate(_)) |\n             ref mut local @ LocalValue::Uninitialized => {\n@@ -191,7 +192,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> LayoutOf for InterpCx<'mir, 'tcx, M> {\n     #[inline]\n     fn layout_of(&self, ty: Ty<'tcx>) -> Self::TyLayout {\n         self.tcx.layout_of(self.param_env.and(ty))\n-            .map_err(|layout| InterpError::Layout(layout).into())\n+            .map_err(|layout| InterpError::InvalidProgram(Layout(layout)).into())\n     }\n }\n \n@@ -302,7 +303,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 &substs,\n             )),\n             None => if substs.needs_subst() {\n-                err!(TooGeneric).into()\n+                err!(InvalidProgram(TooGeneric)).into()\n             } else {\n                 Ok(substs)\n             },\n@@ -323,7 +324,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             self.param_env,\n             def_id,\n             substs,\n-        ).ok_or_else(|| InterpError::TooGeneric.into())\n+        ).ok_or_else(|| InterpError::InvalidProgram(TooGeneric).into())\n     }\n \n     pub fn load_mir(\n@@ -336,14 +337,14 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             && self.tcx.has_typeck_tables(did)\n             && self.tcx.typeck_tables_of(did).tainted_by_errors\n         {\n-            return err!(TypeckError);\n+            return err!(InvalidProgram(TypeckError));\n         }\n         trace!(\"load mir {:?}\", instance);\n         match instance {\n             ty::InstanceDef::Item(def_id) => if self.tcx.is_mir_available(did) {\n                 Ok(self.tcx.optimized_mir(did))\n             } else {\n-                err!(NoMirFor(self.tcx.def_path_str(def_id)))\n+                err!(Unsupported(NoMirFor(self.tcx.def_path_str(def_id))))\n             },\n             _ => Ok(self.tcx.instance_mir(instance)),\n         }\n@@ -356,7 +357,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         match self.stack.last() {\n             Some(frame) => Ok(self.monomorphize_with_substs(t, frame.instance.substs)?),\n             None => if t.needs_subst() {\n-                err!(TooGeneric).into()\n+                err!(InvalidProgram(TooGeneric)).into()\n             } else {\n                 Ok(t)\n             },\n@@ -373,7 +374,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let substituted = t.subst(*self.tcx, substs);\n \n         if substituted.needs_subst() {\n-            return err!(TooGeneric);\n+            return err!(InvalidProgram(TooGeneric));\n         }\n \n         Ok(self.tcx.normalize_erasing_regions(ty::ParamEnv::reveal_all(), substituted))\n@@ -572,7 +573,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         info!(\"ENTERING({}) {}\", self.cur_frame(), self.frame().instance);\n \n         if self.stack.len() > self.tcx.sess.const_eval_stack_frame_limit {\n-            err!(StackFrameLimitReached)\n+            err!(ResourceExhaustion(StackFrameLimitReached))\n         } else {\n             Ok(())\n         }\n@@ -620,7 +621,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n         } else {\n             // Uh, that shouldn't happen... the function did not intend to return\n-            return err!(Unreachable);\n+            return err!(UndefinedBehaviour(Unreachable));\n         }\n         // Jump to new block -- *after* validation so that the spans make more sense.\n         match frame.return_to_block {\n@@ -694,8 +695,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // `Memory::get_static_alloc` which has to use `const_eval_raw` to avoid cycles.\n         let val = self.tcx.const_eval_raw(param_env.and(gid)).map_err(|err| {\n             match err {\n-                ErrorHandled::Reported => InterpError::ReferencedConstant,\n-                ErrorHandled::TooGeneric => InterpError::TooGeneric,\n+                ErrorHandled::Reported => InterpError::InvalidProgram(ReferencedConstant),\n+                ErrorHandled::TooGeneric => InterpError::InvalidProgram(TooGeneric),\n             }\n         })?;\n         self.raw_const_to_mplace(val)"}, {"sha": "f1e6132132c0b5361075b17726be962507eb87f7", "filename": "src/librustc_mir/interpret/intern.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/307798aa38b00d92c9d541a199c3b2ed5422d358/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/307798aa38b00d92c9d541a199c3b2ed5422d358/src%2Flibrustc_mir%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintern.rs?ref=307798aa38b00d92c9d541a199c3b2ed5422d358", "patch": "@@ -5,7 +5,7 @@\n \n use rustc::ty::{Ty, TyCtxt, ParamEnv, self};\n use rustc::mir::interpret::{\n-    InterpResult, ErrorHandled,\n+    InterpResult, ErrorHandled, UnsupportedInfo::*,\n };\n use rustc::hir;\n use rustc::hir::def_id::DefId;\n@@ -293,7 +293,7 @@ pub fn intern_const_alloc_recursive(\n         if let Err(error) = interned {\n             // This can happen when e.g. the tag of an enum is not a valid discriminant. We do have\n             // to read enum discriminants in order to find references in enum variant fields.\n-            if let InterpError::ValidationFailure(_) = error.kind {\n+            if let InterpError::Unsupported(ValidationFailure(_)) = error.kind {\n                 let err = crate::const_eval::error_to_const_error(&ecx, error);\n                 match err.struct_error(ecx.tcx, \"it is undefined behavior to use this value\") {\n                     Ok(mut diag) => {\n@@ -328,9 +328,9 @@ pub fn intern_const_alloc_recursive(\n             }\n         } else if ecx.memory().dead_alloc_map.contains_key(&alloc_id) {\n             // dangling pointer\n-            return err!(ValidationFailure(\n+            return err!(Unsupported(ValidationFailure(\n                 \"encountered dangling pointer in final constant\".into(),\n-            ))\n+            )))\n         }\n     }\n     Ok(())"}, {"sha": "880984ed88cef4dcfd721e4b58049d79e207e4c9", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/307798aa38b00d92c9d541a199c3b2ed5422d358/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/307798aa38b00d92c9d541a199c3b2ed5422d358/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=307798aa38b00d92c9d541a199c3b2ed5422d358", "patch": "@@ -7,7 +7,7 @@ use rustc::ty;\n use rustc::ty::layout::{LayoutOf, Primitive, Size};\n use rustc::mir::BinOp;\n use rustc::mir::interpret::{\n-    InterpResult, InterpError, Scalar, PanicMessage,\n+    InterpResult, InterpError, Scalar, PanicMessage, UnsupportedInfo::*,\n };\n \n use super::{\n@@ -100,11 +100,13 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let bits = self.read_scalar(args[0])?.to_bits(layout_of.size)?;\n                 let kind = match layout_of.abi {\n                     ty::layout::Abi::Scalar(ref scalar) => scalar.value,\n-                    _ => Err(::rustc::mir::interpret::InterpError::TypeNotPrimitive(ty))?,\n+                    _ => Err(InterpError::Unsupported(TypeNotPrimitive(ty)))?,\n                 };\n                 let out_val = if intrinsic_name.ends_with(\"_nonzero\") {\n                     if bits == 0 {\n-                        return err!(Intrinsic(format!(\"{} called on 0\", intrinsic_name)));\n+                        return err!(\n+                            Unsupported(Intrinsic(format!(\"{} called on 0\", intrinsic_name)))\n+                        );\n                     }\n                     numeric_intrinsic(intrinsic_name.trim_end_matches(\"_nonzero\"), bits, kind)?\n                 } else {\n@@ -190,9 +192,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 if overflowed {\n                     let layout = self.layout_of(substs.type_at(0))?;\n                     let r_val =  r.to_scalar()?.to_bits(layout.size)?;\n-                    return err!(Intrinsic(\n+                    return err!(Unsupported(Intrinsic(\n                         format!(\"Overflowing shift by {} in {}\", r_val, intrinsic_name),\n-                    ));\n+                    )));\n                 }\n                 self.write_scalar(val, dest)?;\n             }"}, {"sha": "c40f80940688c4ef41cecd052f1ef46f221f24cd", "filename": "src/librustc_mir/interpret/machine.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/307798aa38b00d92c9d541a199c3b2ed5422d358/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/307798aa38b00d92c9d541a199c3b2ed5422d358/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmachine.rs?ref=307798aa38b00d92c9d541a199c3b2ed5422d358", "patch": "@@ -11,7 +11,7 @@ use rustc::ty::{self, TyCtxt};\n \n use super::{\n     Allocation, AllocId, InterpResult, InterpError, Scalar, AllocationExtra,\n-    InterpCx, PlaceTy, OpTy, ImmTy, MemoryKind, Pointer, Memory,\n+    InterpCx, PlaceTy, OpTy, ImmTy, MemoryKind, Pointer, Memory, UnsupportedInfo::*\n };\n \n /// Whether this kind of memory is allowed to leak\n@@ -240,9 +240,9 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         int: u64,\n     ) -> InterpResult<'tcx, Pointer<Self::PointerTag>> {\n         Err((if int == 0 {\n-            InterpError::InvalidNullPointerUsage\n+            InterpError::Unsupported(InvalidNullPointerUsage)\n         } else {\n-            InterpError::ReadBytesAsPointer\n+            InterpError::Unsupported(ReadBytesAsPointer)\n         }).into())\n     }\n \n@@ -251,6 +251,6 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         _mem: &Memory<'mir, 'tcx, Self>,\n         _ptr: Pointer<Self::PointerTag>,\n     ) -> InterpResult<'tcx, u64> {\n-        err!(ReadPointerAsBytes)\n+        err!(Unsupported(ReadPointerAsBytes))\n     }\n }"}, {"sha": "74da59182c145f1c5ef5823e61958d90a9eacbbb", "filename": "src/librustc_mir/interpret/memory.rs", "status": "modified", "additions": 34, "deletions": 32, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/307798aa38b00d92c9d541a199c3b2ed5422d358/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/307798aa38b00d92c9d541a199c3b2ed5422d358/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fmemory.rs?ref=307798aa38b00d92c9d541a199c3b2ed5422d358", "patch": "@@ -19,7 +19,8 @@ use syntax::ast::Mutability;\n use super::{\n     Pointer, AllocId, Allocation, GlobalId, AllocationExtra,\n     InterpResult, Scalar, InterpError, GlobalAlloc, PointerArithmetic,\n-    Machine, AllocMap, MayLeak, ErrorHandled, CheckInAllocMsg,\n+    Machine, AllocMap, MayLeak, ErrorHandled, CheckInAllocMsg, UnsupportedInfo::*,\n+    InvalidProgramInfo::*\n };\n \n #[derive(Debug, PartialEq, Eq, Copy, Clone, Hash)]\n@@ -66,10 +67,9 @@ impl<'tcx, Other> FnVal<'tcx, Other> {\n         match self {\n             FnVal::Instance(instance) =>\n                 Ok(instance),\n-            FnVal::Other(_) =>\n-                err!(MachineError(\n-                    format!(\"Expected instance function pointer, got 'other' pointer\")\n-                )),\n+            FnVal::Other(_) => err!(Unsupported(MachineError(format!(\n+                \"Expected instance function pointer, got 'other' pointer\"\n+            )))),\n         }\n     }\n }\n@@ -203,7 +203,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         kind: MemoryKind<M::MemoryKinds>,\n     ) -> InterpResult<'tcx, Pointer<M::PointerTag>> {\n         if ptr.offset.bytes() != 0 {\n-            return err!(ReallocateNonBasePtr);\n+            return err!(Unsupported(ReallocateNonBasePtr));\n         }\n \n         // For simplicities' sake, we implement reallocate as \"alloc, copy, dealloc\".\n@@ -244,41 +244,41 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         trace!(\"deallocating: {}\", ptr.alloc_id);\n \n         if ptr.offset.bytes() != 0 {\n-            return err!(DeallocateNonBasePtr);\n+            return err!(Unsupported(DeallocateNonBasePtr));\n         }\n \n         let (alloc_kind, mut alloc) = match self.alloc_map.remove(&ptr.alloc_id) {\n             Some(alloc) => alloc,\n             None => {\n                 // Deallocating static memory -- always an error\n                 return match self.tcx.alloc_map.lock().get(ptr.alloc_id) {\n-                    Some(GlobalAlloc::Function(..)) => err!(DeallocatedWrongMemoryKind(\n+                    Some(GlobalAlloc::Function(..)) => err!(Unsupported(DeallocatedWrongMemoryKind(\n                         \"function\".to_string(),\n                         format!(\"{:?}\", kind),\n-                    )),\n+                    ))),\n                     Some(GlobalAlloc::Static(..)) |\n-                    Some(GlobalAlloc::Memory(..)) => err!(DeallocatedWrongMemoryKind(\n+                    Some(GlobalAlloc::Memory(..)) => err!(Unsupported(DeallocatedWrongMemoryKind(\n                         \"static\".to_string(),\n                         format!(\"{:?}\", kind),\n-                    )),\n-                    None => err!(DoubleFree)\n+                    ))),\n+                    None => err!(Unsupported(DoubleFree))\n                 }\n             }\n         };\n \n         if alloc_kind != kind {\n-            return err!(DeallocatedWrongMemoryKind(\n+            return err!(Unsupported(DeallocatedWrongMemoryKind(\n                 format!(\"{:?}\", alloc_kind),\n                 format!(\"{:?}\", kind),\n-            ));\n+            )));\n         }\n         if let Some((size, align)) = old_size_and_align {\n             if size.bytes() != alloc.bytes.len() as u64 || align != alloc.align {\n                 let bytes = Size::from_bytes(alloc.bytes.len() as u64);\n-                return err!(IncorrectAllocationInformation(size,\n+                return err!(Unsupported(IncorrectAllocationInformation(size,\n                                                            bytes,\n                                                            align,\n-                                                           alloc.align));\n+                                                           alloc.align)));\n             }\n         }\n \n@@ -323,10 +323,10 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             } else {\n                 // The biggest power of two through which `offset` is divisible.\n                 let offset_pow2 = 1 << offset.trailing_zeros();\n-                err!(AlignmentCheckFailed {\n+                err!(Unsupported(AlignmentCheckFailed {\n                     has: Align::from_bytes(offset_pow2).unwrap(),\n                     required: align,\n-                })\n+                }))\n             }\n         }\n \n@@ -345,7 +345,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                 assert!(size.bytes() == 0);\n                 // Must be non-NULL and aligned.\n                 if bits == 0 {\n-                    return err!(InvalidNullPointerUsage);\n+                    return err!(Unsupported(InvalidNullPointerUsage));\n                 }\n                 check_offset_align(bits, align)?;\n                 None\n@@ -366,10 +366,10 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                     // got picked we might be aligned even if this check fails.\n                     // We instead have to fall back to converting to an integer and checking\n                     // the \"real\" alignment.\n-                    return err!(AlignmentCheckFailed {\n+                    return err!(Unsupported(AlignmentCheckFailed {\n                         has: alloc_align,\n                         required: align,\n-                    });\n+                    }));\n                 }\n                 check_offset_align(ptr.offset.bytes(), align)?;\n \n@@ -417,9 +417,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             Some(GlobalAlloc::Memory(mem)) =>\n                 Cow::Borrowed(mem),\n             Some(GlobalAlloc::Function(..)) =>\n-                return err!(DerefFunctionPointer),\n+                return err!(Unsupported(DerefFunctionPointer)),\n             None =>\n-                return err!(DanglingPointerDeref),\n+                return err!(Unsupported(DanglingPointerDeref)),\n             Some(GlobalAlloc::Static(def_id)) => {\n                 // We got a \"lazy\" static that has not been computed yet.\n                 if tcx.is_foreign_item(def_id) {\n@@ -440,8 +440,10 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                             // for statics\n                             assert!(tcx.is_static(def_id));\n                             match err {\n-                                ErrorHandled::Reported => InterpError::ReferencedConstant,\n-                                ErrorHandled::TooGeneric => InterpError::TooGeneric,\n+                                ErrorHandled::Reported =>\n+                                    InterpError::InvalidProgram(ReferencedConstant),\n+                                ErrorHandled::TooGeneric =>\n+                                    InterpError::InvalidProgram(TooGeneric),\n                             }\n                         })?;\n                     // Make sure we use the ID of the resolved memory, not the lazy one!\n@@ -505,11 +507,11 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             // to give us a cheap reference.\n             let alloc = Self::get_static_alloc(memory_extra, tcx, id)?;\n             if alloc.mutability == Mutability::Immutable {\n-                return err!(ModifiedConstantMemory);\n+                return err!(Unsupported(ModifiedConstantMemory));\n             }\n             match M::STATIC_KIND {\n                 Some(kind) => Ok((MemoryKind::Machine(kind), alloc.into_owned())),\n-                None => err!(ModifiedStatic),\n+                None => err!(Unsupported(ModifiedStatic)),\n             }\n         });\n         // Unpack the error type manually because type inference doesn't\n@@ -519,7 +521,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n             Ok(a) => {\n                 let a = &mut a.1;\n                 if a.mutability == Mutability::Immutable {\n-                    return err!(ModifiedConstantMemory);\n+                    return err!(Unsupported(ModifiedConstantMemory));\n                 }\n                 Ok(a)\n             }\n@@ -591,7 +593,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n         } else {\n             match self.tcx.alloc_map.lock().get(id) {\n                 Some(GlobalAlloc::Function(instance)) => Ok(FnVal::Instance(instance)),\n-                _ => Err(InterpError::ExecuteMemory.into()),\n+                _ => Err(InterpError::Unsupported(ExecuteMemory).into()),\n             }\n         }\n     }\n@@ -602,7 +604,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n     ) -> InterpResult<'tcx, FnVal<'tcx, M::ExtraFnVal>> {\n         let ptr = self.force_ptr(ptr)?; // We definitely need a pointer value.\n         if ptr.offset.bytes() != 0 {\n-            return err!(InvalidFunctionPointer);\n+            return err!(Unsupported(InvalidFunctionPointer));\n         }\n         self.get_fn_alloc(ptr.alloc_id)\n     }\n@@ -837,9 +839,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> Memory<'mir, 'tcx, M> {\n                     if (src.offset <= dest.offset && src.offset + size > dest.offset) ||\n                         (dest.offset <= src.offset && dest.offset + size > src.offset)\n                     {\n-                        return err!(Intrinsic(\n+                        return err!(Unsupported(Intrinsic(\n                             \"copy_nonoverlapping called on overlapping ranges\".to_string(),\n-                        ));\n+                        )));\n                     }\n                 }\n "}, {"sha": "3edc7748e5b046e8abc79b9313ef2ae416de3b67", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 14, "deletions": 8, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/307798aa38b00d92c9d541a199c3b2ed5422d358/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/307798aa38b00d92c9d541a199c3b2ed5422d358/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=307798aa38b00d92c9d541a199c3b2ed5422d358", "patch": "@@ -12,7 +12,7 @@ use rustc::mir::interpret::{\n     GlobalId, AllocId,\n     ConstValue, Pointer, Scalar,\n     InterpResult, InterpError,\n-    sign_extend, truncate,\n+    sign_extend, truncate, UnsupportedInfo::*, InvalidProgramInfo::*\n };\n use super::{\n     InterpCx, Machine,\n@@ -332,7 +332,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         let len = mplace.len(self)?;\n         let bytes = self.memory.read_bytes(mplace.ptr, Size::from_bytes(len as u64))?;\n         let str = ::std::str::from_utf8(bytes)\n-            .map_err(|err| InterpError::ValidationFailure(err.to_string()))?;\n+            .map_err(|err| InterpError::Unsupported(ValidationFailure(err.to_string())))?;\n         Ok(str)\n     }\n \n@@ -459,7 +459,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n         mir_place.iterate(|place_base, place_projection| {\n             let mut op = match place_base {\n-                PlaceBase::Local(mir::RETURN_PLACE) => return err!(ReadFromReturnPointer),\n+                PlaceBase::Local(mir::RETURN_PLACE) =>\n+                    return err!(Unsupported(ReadFromReturnPointer)),\n                 PlaceBase::Local(local) => {\n                     // Do not use the layout passed in as argument if the base we are looking at\n                     // here is not the entire place.\n@@ -530,7 +531,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         };\n         // Early-return cases.\n         match val.val {\n-            ConstValue::Param(_) => return err!(TooGeneric), // FIXME(oli-obk): try to monomorphize\n+            ConstValue::Param(_) =>\n+                // FIXME(oli-obk): try to monomorphize\n+                return err!(InvalidProgram(TooGeneric)),\n             ConstValue::Unevaluated(def_id, substs) => {\n                 let instance = self.resolve(def_id, substs)?;\n                 return Ok(OpTy::from(self.const_eval_raw(GlobalId {\n@@ -604,7 +607,8 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             layout::DiscriminantKind::Tag => {\n                 let bits_discr = match raw_discr.to_bits(discr_val.layout.size) {\n                     Ok(raw_discr) => raw_discr,\n-                    Err(_) => return err!(InvalidDiscriminant(raw_discr.erase_tag())),\n+                    Err(_) =>\n+                        return err!(Unsupported(InvalidDiscriminant(raw_discr.erase_tag()))),\n                 };\n                 let real_discr = if discr_val.layout.ty.is_signed() {\n                     // going from layout tag type to typeck discriminant type\n@@ -630,7 +634,9 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                         .discriminants(*def_id, self.tcx.tcx)\n                         .find(|(_, var)| var.val == real_discr),\n                     _ => bug!(\"tagged layout for non-adt non-generator\"),\n-                }.ok_or_else(|| InterpError::InvalidDiscriminant(raw_discr.erase_tag()))?;\n+                }.ok_or_else(\n+                    || InterpError::Unsupported(InvalidDiscriminant(raw_discr.erase_tag()))\n+                )?;\n                 (real_discr, index.0)\n             },\n             layout::DiscriminantKind::Niche {\n@@ -641,14 +647,14 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let variants_start = niche_variants.start().as_u32() as u128;\n                 let variants_end = niche_variants.end().as_u32() as u128;\n                 let raw_discr = raw_discr.not_undef()\n-                    .map_err(|_| InterpError::InvalidDiscriminant(ScalarMaybeUndef::Undef))?;\n+                    .map_err(|_| InterpError::Unsupported(InvalidDiscriminant(ScalarMaybeUndef::Undef)))?;\n                 match raw_discr.to_bits_or_ptr(discr_val.layout.size, self) {\n                     Err(ptr) => {\n                         // The niche must be just 0 (which an inbounds pointer value never is)\n                         let ptr_valid = niche_start == 0 && variants_start == variants_end &&\n                             !self.memory.ptr_may_be_null(ptr);\n                         if !ptr_valid {\n-                            return err!(InvalidDiscriminant(raw_discr.erase_tag().into()));\n+                            return err!(Unsupported(InvalidDiscriminant(raw_discr.erase_tag().into())));\n                         }\n                         (dataful_variant.as_u32() as u128, dataful_variant)\n                     },"}, {"sha": "8af4c71299d215dc7b39e743e44b5d8b6f821ef8", "filename": "src/librustc_mir/interpret/operator.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/307798aa38b00d92c9d541a199c3b2ed5422d358/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/307798aa38b00d92c9d541a199c3b2ed5422d358/src%2Flibrustc_mir%2Finterpret%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperator.rs?ref=307798aa38b00d92c9d541a199c3b2ed5422d358", "patch": "@@ -4,7 +4,7 @@ use syntax::ast::FloatTy;\n use rustc_apfloat::Float;\n use rustc::mir::interpret::{InterpResult, PanicMessage, Scalar};\n \n-use super::{InterpCx, PlaceTy, Immediate, Machine, ImmTy};\n+use super::{InterpCx, PlaceTy, Immediate, Machine, ImmTy, UnsupportedInfo::*};\n \n \n impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n@@ -155,7 +155,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 r,\n                 right_layout.ty\n             );\n-            return err!(Unimplemented(msg));\n+            return err!(Unsupported(Unimplemented(msg)));\n         }\n \n         // Operations that need special treatment for signed integers\n@@ -250,7 +250,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     r,\n                     right_layout.ty,\n                 );\n-                return err!(Unimplemented(msg));\n+                return err!(Unsupported(Unimplemented(msg)));\n             }\n         };\n "}, {"sha": "65e70b7bedc702166ef2f6f944247b98af438e0f", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/307798aa38b00d92c9d541a199c3b2ed5422d358/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/307798aa38b00d92c9d541a199c3b2ed5422d358/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=307798aa38b00d92c9d541a199c3b2ed5422d358", "patch": "@@ -14,7 +14,8 @@ use rustc::ty::TypeFoldable;\n use super::{\n     GlobalId, AllocId, Allocation, Scalar, InterpResult, Pointer, PointerArithmetic,\n     InterpCx, Machine, AllocMap, AllocationExtra, PanicMessage,\n-    RawConst, Immediate, ImmTy, ScalarMaybeUndef, Operand, OpTy, MemoryKind, LocalValue\n+    RawConst, Immediate, ImmTy, ScalarMaybeUndef, Operand, OpTy, MemoryKind, LocalValue,\n+    UnsupportedInfo::*,\n };\n \n #[derive(Copy, Clone, Debug, Hash, PartialEq, Eq)]\n@@ -622,7 +623,7 @@ where\n                                 .layout_of(self.monomorphize(self.frame().body.return_ty())?)?,\n                         }\n                     }\n-                    None => return err!(InvalidNullPointerUsage),\n+                    None => return err!(Unsupported(InvalidNullPointerUsage)),\n                 },\n                 PlaceBase::Local(local) => PlaceTy {\n                     // This works even for dead/uninitialized locals; we check further when writing"}, {"sha": "112e592329f5f8965f62b612b065b0df7d391e87", "filename": "src/librustc_mir/interpret/snapshot.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/307798aa38b00d92c9d541a199c3b2ed5422d358/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/307798aa38b00d92c9d541a199c3b2ed5422d358/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fsnapshot.rs?ref=307798aa38b00d92c9d541a199c3b2ed5422d358", "patch": "@@ -12,7 +12,7 @@ use rustc::mir;\n use rustc::mir::interpret::{\n     AllocId, Pointer, Scalar,\n     Relocations, Allocation, UndefMask,\n-    InterpResult, InterpError,\n+    InterpResult, InterpError, ResourceExhaustionInfo::*,\n };\n \n use rustc::ty::{self, TyCtxt};\n@@ -77,7 +77,7 @@ impl<'mir, 'tcx> InfiniteLoopDetector<'mir, 'tcx> {\n         }\n \n         // Second cycle\n-        Err(InterpError::InfiniteLoop.into())\n+        Err(InterpError::ResourceExhaustion(InfiniteLoop).into())\n     }\n }\n "}, {"sha": "24aa5489e528a53646ff21280e2e2ec76048f8f7", "filename": "src/librustc_mir/interpret/step.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/307798aa38b00d92c9d541a199c3b2ed5422d358/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/307798aa38b00d92c9d541a199c3b2ed5422d358/src%2Flibrustc_mir%2Finterpret%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fstep.rs?ref=307798aa38b00d92c9d541a199c3b2ed5422d358", "patch": "@@ -4,7 +4,7 @@\n \n use rustc::mir;\n use rustc::ty::layout::LayoutOf;\n-use rustc::mir::interpret::{InterpResult, Scalar, PointerArithmetic};\n+use rustc::mir::interpret::{InterpResult, Scalar, PointerArithmetic, UnsupportedInfo};\n \n use super::{InterpCx, Machine};\n \n@@ -121,7 +121,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             // size of MIR constantly.\n             Nop => {}\n \n-            InlineAsm { .. } => return err!(InlineAsm),\n+            InlineAsm { .. } => return err!(Unsupported(UnsupportedInfo::InlineAsm)),\n         }\n \n         self.stack[frame_idx].stmt += 1;"}, {"sha": "cfb901d380ea0ec93716422f105a7a26f59821c8", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 15, "deletions": 12, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/307798aa38b00d92c9d541a199c3b2ed5422d358/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/307798aa38b00d92c9d541a199c3b2ed5422d358/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=307798aa38b00d92c9d541a199c3b2ed5422d358", "patch": "@@ -9,6 +9,7 @@ use rustc_target::spec::abi::Abi;\n use super::{\n     InterpResult, PointerArithmetic, InterpError, Scalar,\n     InterpCx, Machine, Immediate, OpTy, ImmTy, PlaceTy, MPlaceTy, StackPopCleanup, FnVal,\n+    UndefinedBehaviourInfo, UnsupportedInfo::*,\n };\n \n impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n@@ -19,7 +20,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             self.frame_mut().stmt = 0;\n             Ok(())\n         } else {\n-            err!(Unreachable)\n+            err!(UndefinedBehaviour(UndefinedBehaviourInfo::Unreachable))\n         }\n     }\n \n@@ -89,7 +90,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     },\n                     _ => {\n                         let msg = format!(\"can't handle callee of type {:?}\", func.layout.ty);\n-                        return err!(Unimplemented(msg));\n+                        return err!(Unsupported(Unimplemented(msg)));\n                     }\n                 };\n                 let args = self.eval_operands(args)?;\n@@ -173,7 +174,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                                       `simplify_branches` mir pass\"),\n             FalseUnwind { .. } => bug!(\"should have been eliminated by\\\n                                        `simplify_branches` mir pass\"),\n-            Unreachable => return err!(Unreachable),\n+            Unreachable => return err!(UndefinedBehaviour(UndefinedBehaviourInfo::Unreachable)),\n         }\n \n         Ok(())\n@@ -220,13 +221,15 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             return Ok(());\n         }\n         let caller_arg = caller_arg.next()\n-            .ok_or_else(|| InterpError::FunctionArgCountMismatch)?;\n+            .ok_or_else(|| InterpError::Unsupported(FunctionArgCountMismatch))?;\n         if rust_abi {\n             debug_assert!(!caller_arg.layout.is_zst(), \"ZSTs must have been already filtered out\");\n         }\n         // Now, check\n         if !Self::check_argument_compat(rust_abi, caller_arg.layout, callee_arg.layout) {\n-            return err!(FunctionArgMismatch(caller_arg.layout.ty, callee_arg.layout.ty));\n+            return err!(\n+                Unsupported(FunctionArgMismatch(caller_arg.layout.ty, callee_arg.layout.ty))\n+            );\n         }\n         // We allow some transmutes here\n         self.copy_op_transmute(caller_arg, callee_arg)\n@@ -254,13 +257,13 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         match instance.def {\n             ty::InstanceDef::Intrinsic(..) => {\n                 if caller_abi != Abi::RustIntrinsic {\n-                    return err!(FunctionAbiMismatch(caller_abi, Abi::RustIntrinsic));\n+                    return err!(Unsupported(FunctionAbiMismatch(caller_abi, Abi::RustIntrinsic)));\n                 }\n                 // The intrinsic itself cannot diverge, so if we got here without a return\n                 // place... (can happen e.g., for transmute returning `!`)\n                 let dest = match dest {\n                     Some(dest) => dest,\n-                    None => return err!(Unreachable)\n+                    None => return err!(UndefinedBehaviour(UndefinedBehaviourInfo::Unreachable))\n                 };\n                 M::call_intrinsic(self, instance, args, dest)?;\n                 // No stack frame gets pushed, the main loop will just act as if the\n@@ -295,7 +298,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                             abi,\n                     };\n                     if normalize_abi(caller_abi) != normalize_abi(callee_abi) {\n-                        return err!(FunctionAbiMismatch(caller_abi, callee_abi));\n+                        return err!(Unsupported(FunctionAbiMismatch(caller_abi, callee_abi)));\n                     }\n                 }\n \n@@ -390,7 +393,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     // Now we should have no more caller args\n                     if caller_iter.next().is_some() {\n                         trace!(\"Caller has passed too many args\");\n-                        return err!(FunctionArgCountMismatch);\n+                        return err!(Unsupported(FunctionArgCountMismatch));\n                     }\n                     // Don't forget to check the return type!\n                     if let Some(caller_ret) = dest {\n@@ -402,15 +405,15 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                             caller_ret.layout,\n                             callee_ret.layout,\n                         ) {\n-                            return err!(FunctionRetMismatch(\n-                                caller_ret.layout.ty, callee_ret.layout.ty\n+                            return err!(Unsupported(\n+                                FunctionRetMismatch(caller_ret.layout.ty, callee_ret.layout.ty)\n                             ));\n                         }\n                     } else {\n                         let local = mir::RETURN_PLACE;\n                         let ty = self.frame().body.local_decls[local].ty;\n                         if !self.tcx.is_ty_uninhabited_from_any_module(ty) {\n-                            return err!(FunctionRetMismatch(self.tcx.types.never, ty));\n+                            return err!(Unsupported(FunctionRetMismatch(self.tcx.types.never, ty)));\n                         }\n                     }\n                     Ok(())"}, {"sha": "677d6c89b38d5e4cb183cf73bf2a0afbe7f98b7c", "filename": "src/librustc_mir/interpret/traits.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/307798aa38b00d92c9d541a199c3b2ed5422d358/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/307798aa38b00d92c9d541a199c3b2ed5422d358/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Ftraits.rs?ref=307798aa38b00d92c9d541a199c3b2ed5422d358", "patch": "@@ -1,6 +1,6 @@\n use rustc::ty::{self, Ty, Instance};\n use rustc::ty::layout::{Size, Align, LayoutOf};\n-use rustc::mir::interpret::{Scalar, Pointer, InterpResult, PointerArithmetic};\n+use rustc::mir::interpret::{Scalar, Pointer, InterpResult, PointerArithmetic, InvalidProgramInfo};\n \n use super::{InterpCx, InterpError, Machine, MemoryKind, FnVal};\n \n@@ -83,7 +83,7 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                     self.param_env,\n                     def_id,\n                     substs,\n-                ).ok_or_else(|| InterpError::TooGeneric)?;\n+                ).ok_or_else(|| InterpError::InvalidProgram(InvalidProgramInfo::TooGeneric))?;\n                 let fn_ptr = self.memory.create_fn_alloc(FnVal::Instance(instance));\n                 let method_ptr = vtable.offset(ptr_size * (3 + i as u64), self)?;\n                 self.memory"}, {"sha": "acbd2066d0e47deeb4afa42e13a14d872336b393", "filename": "src/librustc_mir/interpret/validity.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/307798aa38b00d92c9d541a199c3b2ed5422d358/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/307798aa38b00d92c9d541a199c3b2ed5422d358/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fvalidity.rs?ref=307798aa38b00d92c9d541a199c3b2ed5422d358", "patch": "@@ -11,7 +11,7 @@ use std::hash::Hash;\n \n use super::{\n     GlobalAlloc, InterpResult, InterpError,\n-    OpTy, Machine, InterpCx, ValueVisitor, MPlaceTy,\n+    OpTy, Machine, InterpCx, ValueVisitor, MPlaceTy, UnsupportedInfo::*,\n };\n \n macro_rules! validation_failure {\n@@ -22,10 +22,10 @@ macro_rules! validation_failure {\n         } else {\n             format!(\" at {}\", where_)\n         };\n-        err!(ValidationFailure(format!(\n+        err!(Unsupported(ValidationFailure(format!(\n             \"encountered {}{}, but expected {}\",\n             $what, where_, $details,\n-        )))\n+        ))))\n     }};\n     ($what:expr, $where:expr) => {{\n         let where_ = path_format(&$where);\n@@ -34,10 +34,10 @@ macro_rules! validation_failure {\n         } else {\n             format!(\" at {}\", where_)\n         };\n-        err!(ValidationFailure(format!(\n+        err!(Unsupported(ValidationFailure(format!(\n             \"encountered {}{}\",\n             $what, where_,\n-        )))\n+        ))))\n     }};\n }\n \n@@ -297,11 +297,11 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n         match self.walk_value(op) {\n             Ok(()) => Ok(()),\n             Err(err) => match err.kind {\n-                InterpError::InvalidDiscriminant(val) =>\n+                InterpError::Unsupported(InvalidDiscriminant(val)) =>\n                     validation_failure!(\n                         val, self.path, \"a valid enum discriminant\"\n                     ),\n-                InterpError::ReadPointerAsBytes =>\n+                InterpError::Unsupported(ReadPointerAsBytes) =>\n                     validation_failure!(\n                         \"a pointer\", self.path, \"plain (non-pointer) bytes\"\n                     ),\n@@ -406,13 +406,13 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                             ptr, size, align\n                         );\n                         match err.kind {\n-                            InterpError::InvalidNullPointerUsage =>\n+                            InterpError::Unsupported(InvalidNullPointerUsage) =>\n                                 return validation_failure!(\"NULL reference\", self.path),\n-                            InterpError::AlignmentCheckFailed { required, has } =>\n+                            InterpError::Unsupported(AlignmentCheckFailed { required, has }) =>\n                                 return validation_failure!(format!(\"unaligned reference \\\n                                     (required {} byte alignment but found {})\",\n                                     required.bytes(), has.bytes()), self.path),\n-                            InterpError::ReadBytesAsPointer =>\n+                            InterpError::Unsupported(ReadBytesAsPointer) =>\n                                 return validation_failure!(\n                                     \"dangling reference (created from integer)\",\n                                     self.path\n@@ -608,7 +608,7 @@ impl<'rt, 'mir, 'tcx, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                     Err(err) => {\n                         // For some errors we might be able to provide extra information\n                         match err.kind {\n-                            InterpError::ReadUndefBytes(offset) => {\n+                            InterpError::Unsupported(ReadUndefBytes(offset)) => {\n                                 // Some byte was undefined, determine which\n                                 // element that byte belongs to so we can\n                                 // provide an index."}, {"sha": "518489753a120d6f71d9db79a6e144249a594973", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 10, "deletions": 76, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/307798aa38b00d92c9d541a199c3b2ed5422d358/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/307798aa38b00d92c9d541a199c3b2ed5422d358/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=307798aa38b00d92c9d541a199c3b2ed5422d358", "patch": "@@ -257,86 +257,20 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n             Err(error) => {\n                 let diagnostic = error_to_const_error(&self.ecx, error);\n                 use rustc::mir::interpret::InterpError::*;\n+                use rustc::mir::interpret::UnsupportedInfo::*;\n                 match diagnostic.error {\n-                    // don't report these, they make no sense in a const prop context\n-                    | MachineError(_)\n-                    | Exit(_)\n-                    // at runtime these transformations might make sense\n-                    // FIXME: figure out the rules and start linting\n-                    | FunctionAbiMismatch(..)\n-                    | FunctionArgMismatch(..)\n-                    | FunctionRetMismatch(..)\n-                    | FunctionArgCountMismatch\n-                    // fine at runtime, might be a register address or sth\n-                    | ReadBytesAsPointer\n-                    // fine at runtime\n-                    | ReadForeignStatic\n-                    | Unimplemented(_)\n-                    // don't report const evaluator limits\n-                    | StackFrameLimitReached\n-                    | NoMirFor(..)\n-                    | InlineAsm\n-                    => {},\n-\n-                    | InvalidMemoryAccess\n-                    | DanglingPointerDeref\n-                    | DoubleFree\n-                    | InvalidFunctionPointer\n-                    | InvalidBool\n-                    | InvalidDiscriminant(..)\n-                    | PointerOutOfBounds { .. }\n-                    | InvalidNullPointerUsage\n-                    | ValidationFailure(..)\n-                    | InvalidPointerMath\n-                    | ReadUndefBytes(_)\n-                    | DeadLocal\n-                    | InvalidBoolOp(_)\n-                    | DerefFunctionPointer\n-                    | ExecuteMemory\n-                    | Intrinsic(..)\n-                    | InvalidChar(..)\n-                    | AbiViolation(_)\n-                    | AlignmentCheckFailed{..}\n-                    | CalledClosureAsFunction\n-                    | VtableForArgumentlessMethod\n-                    | ModifiedConstantMemory\n-                    | ModifiedStatic\n-                    | AssumptionNotHeld\n-                    // FIXME: should probably be removed and turned into a bug! call\n-                    | TypeNotPrimitive(_)\n-                    | ReallocatedWrongMemoryKind(_, _)\n-                    | DeallocatedWrongMemoryKind(_, _)\n-                    | ReallocateNonBasePtr\n-                    | DeallocateNonBasePtr\n-                    | IncorrectAllocationInformation(..)\n-                    | UnterminatedCString(_)\n-                    | HeapAllocZeroBytes\n-                    | HeapAllocNonPowerOfTwoAlignment(_)\n-                    | Unreachable\n-                    | ReadFromReturnPointer\n-                    | ReferencedConstant\n-                    | InfiniteLoop\n-                    => {\n-                        // FIXME: report UB here\n-                    },\n+                    Exit(_) => {},\n \n-                    | OutOfTls\n-                    | TlsOutOfBounds\n-                    | PathNotFound(_)\n+                    | Unsupported(OutOfTls)\n+                    | Unsupported(TlsOutOfBounds)\n+                    | Unsupported(PathNotFound(_))\n                     => bug!(\"these should not be in rustc, but in miri's machine errors\"),\n \n-                    | Layout(_)\n-                    | UnimplementedTraitSelection\n-                    | TypeckError\n-                    | TooGeneric\n-                    // these are just noise\n-                    => {},\n-\n-                    // non deterministic\n-                    | ReadPointerAsBytes\n-                    // FIXME: implement\n-                    => {},\n-\n+                    | Unsupported(_) => {},\n+                    | UndefinedBehaviour(_) => {},\n+                    | InvalidProgram(_) => {},\n+                    | ResourceExhaustion(_) => {},\n+                    \n                     | Panic(_)\n                     => {\n                         diagnostic.report_as_lint("}]}