{"sha": "9567b5a9f52f35f1bb127f626a1b14062d735751", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk1NjdiNWE5ZjUyZjM1ZjFiYjEyN2Y2MjZhMWIxNDA2MmQ3MzU3NTE=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-09-20T13:52:03Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-09-20T13:52:03Z"}, "message": "Rollup merge of #76891 - lcnr:less-ref, r=ecstatic-morse\n\ndon't take `TyCtxt` by reference\n\nsmall cleanup", "tree": {"sha": "cd74ead16bfc29e9b6fe63d16648190a80f51626", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cd74ead16bfc29e9b6fe63d16648190a80f51626"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9567b5a9f52f35f1bb127f626a1b14062d735751", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfZ16DCRBK7hj4Ov3rIwAAdHIIAFGoZaUfPxc8otmrc/OH4ru6\nLfphMguc7NZJCs1doX74iaXdvddO6hF7ZHkrCN4wR3vrtsQR8RJ0ENoPfAFZJBT8\nlixUYb6jE+FjdDycUYXytD5glyVv2WBvjaRqpftjIXvfrPKefFUmg63bzjBqPb0w\nQGxEZWasXBF9F9zbjy+m6NNPNqyBGTwcV4Zv0GpEspTHy15LOgJmco0QYMz54awP\nhP3Gd2PeOuONLx68O5mh27GeQVPEqICfrbzol5ipV8Dr34J3RjTpqoou3laFHDEB\nX8igl64af/6iE2GfGJX67SNb3X7YLab3UXn0lAyu1uHIcmT8AQHvt3WHAbLTdZw=\n=Rgyc\n-----END PGP SIGNATURE-----\n", "payload": "tree cd74ead16bfc29e9b6fe63d16648190a80f51626\nparent 8405d50e128d7c8ed38f8e0f7432d3c2dfb31195\nparent 925cd2616238d4f93b80cc26f02b5f5b256978fc\nauthor Ralf Jung <post@ralfj.de> 1600609923 +0200\ncommitter GitHub <noreply@github.com> 1600609923 +0200\n\nRollup merge of #76891 - lcnr:less-ref, r=ecstatic-morse\n\ndon't take `TyCtxt` by reference\n\nsmall cleanup\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9567b5a9f52f35f1bb127f626a1b14062d735751", "html_url": "https://github.com/rust-lang/rust/commit/9567b5a9f52f35f1bb127f626a1b14062d735751", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9567b5a9f52f35f1bb127f626a1b14062d735751/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8405d50e128d7c8ed38f8e0f7432d3c2dfb31195", "url": "https://api.github.com/repos/rust-lang/rust/commits/8405d50e128d7c8ed38f8e0f7432d3c2dfb31195", "html_url": "https://github.com/rust-lang/rust/commit/8405d50e128d7c8ed38f8e0f7432d3c2dfb31195"}, {"sha": "925cd2616238d4f93b80cc26f02b5f5b256978fc", "url": "https://api.github.com/repos/rust-lang/rust/commits/925cd2616238d4f93b80cc26f02b5f5b256978fc", "html_url": "https://github.com/rust-lang/rust/commit/925cd2616238d4f93b80cc26f02b5f5b256978fc"}], "stats": {"total": 72, "additions": 35, "deletions": 37}, "files": [{"sha": "cc9706f2d867cbe6db1bd1d222363e3455ced817", "filename": "compiler/rustc_middle/src/middle/lang_items.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9567b5a9f52f35f1bb127f626a1b14062d735751/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9567b5a9f52f35f1bb127f626a1b14062d735751/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Flang_items.rs?ref=9567b5a9f52f35f1bb127f626a1b14062d735751", "patch": "@@ -17,7 +17,7 @@ use rustc_target::spec::PanicStrategy;\n impl<'tcx> TyCtxt<'tcx> {\n     /// Returns the `DefId` for a given `LangItem`.\n     /// If not found, fatally aborts compilation.\n-    pub fn require_lang_item(&self, lang_item: LangItem, span: Option<Span>) -> DefId {\n+    pub fn require_lang_item(self, lang_item: LangItem, span: Option<Span>) -> DefId {\n         self.lang_items().require(lang_item).unwrap_or_else(|msg| {\n             if let Some(span) = span {\n                 self.sess.span_fatal(span, &msg)\n@@ -27,7 +27,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         })\n     }\n \n-    pub fn fn_trait_kind_from_lang_item(&self, id: DefId) -> Option<ty::ClosureKind> {\n+    pub fn fn_trait_kind_from_lang_item(self, id: DefId) -> Option<ty::ClosureKind> {\n         let items = self.lang_items();\n         match Some(id) {\n             x if x == items.fn_trait() => Some(ty::ClosureKind::Fn),\n@@ -37,7 +37,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         }\n     }\n \n-    pub fn is_weak_lang_item(&self, item_def_id: DefId) -> bool {\n+    pub fn is_weak_lang_item(self, item_def_id: DefId) -> bool {\n         self.lang_items().is_weak_lang_item(item_def_id)\n     }\n }"}, {"sha": "20363625e42b644dc1820b503f2ba406dcf710d7", "filename": "compiler/rustc_middle/src/mir/interpret/mod.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9567b5a9f52f35f1bb127f626a1b14062d735751/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9567b5a9f52f35f1bb127f626a1b14062d735751/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fmod.rs?ref=9567b5a9f52f35f1bb127f626a1b14062d735751", "patch": "@@ -447,14 +447,14 @@ impl<'tcx> TyCtxt<'tcx> {\n     ///\n     /// Make sure to call `set_alloc_id_memory` or `set_alloc_id_same_memory` before returning such\n     /// an `AllocId` from a query.\n-    pub fn reserve_alloc_id(&self) -> AllocId {\n+    pub fn reserve_alloc_id(self) -> AllocId {\n         self.alloc_map.lock().reserve()\n     }\n \n     /// Reserves a new ID *if* this allocation has not been dedup-reserved before.\n     /// Should only be used for function pointers and statics, we don't want\n     /// to dedup IDs for \"real\" memory!\n-    fn reserve_and_set_dedup(&self, alloc: GlobalAlloc<'tcx>) -> AllocId {\n+    fn reserve_and_set_dedup(self, alloc: GlobalAlloc<'tcx>) -> AllocId {\n         let mut alloc_map = self.alloc_map.lock();\n         match alloc {\n             GlobalAlloc::Function(..) | GlobalAlloc::Static(..) => {}\n@@ -472,13 +472,13 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     /// Generates an `AllocId` for a static or return a cached one in case this function has been\n     /// called on the same static before.\n-    pub fn create_static_alloc(&self, static_id: DefId) -> AllocId {\n+    pub fn create_static_alloc(self, static_id: DefId) -> AllocId {\n         self.reserve_and_set_dedup(GlobalAlloc::Static(static_id))\n     }\n \n     /// Generates an `AllocId` for a function.  Depending on the function type,\n     /// this might get deduplicated or assigned a new ID each time.\n-    pub fn create_fn_alloc(&self, instance: Instance<'tcx>) -> AllocId {\n+    pub fn create_fn_alloc(self, instance: Instance<'tcx>) -> AllocId {\n         // Functions cannot be identified by pointers, as asm-equal functions can get deduplicated\n         // by the linker (we set the \"unnamed_addr\" attribute for LLVM) and functions can be\n         // duplicated across crates.\n@@ -507,7 +507,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// Statics with identical content will still point to the same `Allocation`, i.e.,\n     /// their data will be deduplicated through `Allocation` interning -- but they\n     /// are different places in memory and as such need different IDs.\n-    pub fn create_memory_alloc(&self, mem: &'tcx Allocation) -> AllocId {\n+    pub fn create_memory_alloc(self, mem: &'tcx Allocation) -> AllocId {\n         let id = self.reserve_alloc_id();\n         self.set_alloc_id_memory(id, mem);\n         id\n@@ -519,7 +519,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// This function exists to allow const eval to detect the difference between evaluation-\n     /// local dangling pointers and allocations in constants/statics.\n     #[inline]\n-    pub fn get_global_alloc(&self, id: AllocId) -> Option<GlobalAlloc<'tcx>> {\n+    pub fn get_global_alloc(self, id: AllocId) -> Option<GlobalAlloc<'tcx>> {\n         self.alloc_map.lock().alloc_map.get(&id).cloned()\n     }\n \n@@ -529,7 +529,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// constants (as all constants must pass interning and validation that check for dangling\n     /// ids), this function is frequently used throughout rustc, but should not be used within\n     /// the miri engine.\n-    pub fn global_alloc(&self, id: AllocId) -> GlobalAlloc<'tcx> {\n+    pub fn global_alloc(self, id: AllocId) -> GlobalAlloc<'tcx> {\n         match self.get_global_alloc(id) {\n             Some(alloc) => alloc,\n             None => bug!(\"could not find allocation for {}\", id),\n@@ -538,15 +538,15 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     /// Freezes an `AllocId` created with `reserve` by pointing it at an `Allocation`. Trying to\n     /// call this function twice, even with the same `Allocation` will ICE the compiler.\n-    pub fn set_alloc_id_memory(&self, id: AllocId, mem: &'tcx Allocation) {\n+    pub fn set_alloc_id_memory(self, id: AllocId, mem: &'tcx Allocation) {\n         if let Some(old) = self.alloc_map.lock().alloc_map.insert(id, GlobalAlloc::Memory(mem)) {\n             bug!(\"tried to set allocation ID {}, but it was already existing as {:#?}\", id, old);\n         }\n     }\n \n     /// Freezes an `AllocId` created with `reserve` by pointing it at an `Allocation`. May be called\n     /// twice for the same `(AllocId, Allocation)` pair.\n-    fn set_alloc_id_same_memory(&self, id: AllocId, mem: &'tcx Allocation) {\n+    fn set_alloc_id_same_memory(self, id: AllocId, mem: &'tcx Allocation) {\n         self.alloc_map.lock().alloc_map.insert_same(id, GlobalAlloc::Memory(mem));\n     }\n }"}, {"sha": "cd8f12a4f3576f5ce29cc909a2623cba258fce19", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/9567b5a9f52f35f1bb127f626a1b14062d735751/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9567b5a9f52f35f1bb127f626a1b14062d735751/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=9567b5a9f52f35f1bb127f626a1b14062d735751", "patch": "@@ -1403,7 +1403,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     // Returns the `DefId` and the `BoundRegion` corresponding to the given region.\n-    pub fn is_suitable_region(&self, region: Region<'tcx>) -> Option<FreeRegionInfo> {\n+    pub fn is_suitable_region(self, region: Region<'tcx>) -> Option<FreeRegionInfo> {\n         let (suitable_region_binding_scope, bound_region) = match *region {\n             ty::ReFree(ref free_region) => {\n                 (free_region.scope.expect_local(), free_region.bound_region)\n@@ -1433,7 +1433,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     /// Given a `DefId` for an `fn`, return all the `dyn` and `impl` traits in its return type.\n     pub fn return_type_impl_or_dyn_traits(\n-        &self,\n+        self,\n         scope_def_id: LocalDefId,\n     ) -> Vec<&'tcx hir::Ty<'tcx>> {\n         let hir_id = self.hir().local_def_id_to_hir_id(scope_def_id);\n@@ -1479,7 +1479,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         v.0\n     }\n \n-    pub fn return_type_impl_trait(&self, scope_def_id: LocalDefId) -> Option<(Ty<'tcx>, Span)> {\n+    pub fn return_type_impl_trait(self, scope_def_id: LocalDefId) -> Option<(Ty<'tcx>, Span)> {\n         // HACK: `type_of_def_id()` will fail on these (#55796), so return `None`.\n         let hir_id = self.hir().local_def_id_to_hir_id(scope_def_id);\n         match self.hir().get(hir_id) {\n@@ -1497,7 +1497,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         let ret_ty = self.type_of(scope_def_id);\n         match ret_ty.kind() {\n             ty::FnDef(_, _) => {\n-                let sig = ret_ty.fn_sig(*self);\n+                let sig = ret_ty.fn_sig(self);\n                 let output = self.erase_late_bound_regions(&sig.output());\n                 if output.is_impl_trait() {\n                     let fn_decl = self.hir().fn_decl_by_hir_id(hir_id).unwrap();\n@@ -1511,7 +1511,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     // Checks if the bound region is in Impl Item.\n-    pub fn is_bound_region_in_impl_item(&self, suitable_region_binding_scope: LocalDefId) -> bool {\n+    pub fn is_bound_region_in_impl_item(self, suitable_region_binding_scope: LocalDefId) -> bool {\n         let container_id =\n             self.associated_item(suitable_region_binding_scope.to_def_id()).container.id();\n         if self.impl_trait_ref(container_id).is_some() {\n@@ -1528,21 +1528,21 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     /// Determines whether identifiers in the assembly have strict naming rules.\n     /// Currently, only NVPTX* targets need it.\n-    pub fn has_strict_asm_symbol_naming(&self) -> bool {\n+    pub fn has_strict_asm_symbol_naming(self) -> bool {\n         self.sess.target.target.arch.contains(\"nvptx\")\n     }\n \n     /// Returns `&'static core::panic::Location<'static>`.\n-    pub fn caller_location_ty(&self) -> Ty<'tcx> {\n+    pub fn caller_location_ty(self) -> Ty<'tcx> {\n         self.mk_imm_ref(\n             self.lifetimes.re_static,\n             self.type_of(self.require_lang_item(LangItem::PanicLocation, None))\n-                .subst(*self, self.mk_substs([self.lifetimes.re_static.into()].iter())),\n+                .subst(self, self.mk_substs([self.lifetimes.re_static.into()].iter())),\n         )\n     }\n \n     /// Returns a displayable description and article for the given `def_id` (e.g. `(\"a\", \"struct\")`).\n-    pub fn article_and_description(&self, def_id: DefId) -> (&'static str, &'static str) {\n+    pub fn article_and_description(self, def_id: DefId) -> (&'static str, &'static str) {\n         match self.def_kind(def_id) {\n             DefKind::Generator => match self.generator_kind(def_id).unwrap() {\n                 rustc_hir::GeneratorKind::Async(..) => (\"an\", \"async closure\"),"}, {"sha": "475c3101c1e98eefbc7697137b90bd94836913c7", "filename": "compiler/rustc_middle/src/ty/error.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9567b5a9f52f35f1bb127f626a1b14062d735751/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9567b5a9f52f35f1bb127f626a1b14062d735751/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs?ref=9567b5a9f52f35f1bb127f626a1b14062d735751", "patch": "@@ -546,22 +546,22 @@ impl<T> Trait<T> for X {\n     }\n \n     fn suggest_constraint(\n-        &self,\n+        self,\n         db: &mut DiagnosticBuilder<'_>,\n         msg: &str,\n         body_owner_def_id: DefId,\n         proj_ty: &ty::ProjectionTy<'tcx>,\n         ty: Ty<'tcx>,\n     ) -> bool {\n         let assoc = self.associated_item(proj_ty.item_def_id);\n-        let trait_ref = proj_ty.trait_ref(*self);\n+        let trait_ref = proj_ty.trait_ref(self);\n         if let Some(item) = self.hir().get_if_local(body_owner_def_id) {\n             if let Some(hir_generics) = item.generics() {\n                 // Get the `DefId` for the type parameter corresponding to `A` in `<A as T>::Foo`.\n                 // This will also work for `impl Trait`.\n                 let def_id = if let ty::Param(param_ty) = proj_ty.self_ty().kind() {\n                     let generics = self.generics_of(body_owner_def_id);\n-                    generics.type_param(&param_ty, *self).def_id\n+                    generics.type_param(param_ty, self).def_id\n                 } else {\n                     return false;\n                 };\n@@ -629,7 +629,7 @@ impl<T> Trait<T> for X {\n     ///    and the `impl`, we provide a generic `help` to constrain the assoc type or call an assoc\n     ///    fn that returns the type.\n     fn expected_projection(\n-        &self,\n+        self,\n         db: &mut DiagnosticBuilder<'_>,\n         proj_ty: &ty::ProjectionTy<'tcx>,\n         values: &ExpectedFound<Ty<'tcx>>,\n@@ -734,7 +734,7 @@ fn foo(&self) -> Self::T { String::new() }\n     }\n \n     fn point_at_methods_that_satisfy_associated_type(\n-        &self,\n+        self,\n         db: &mut DiagnosticBuilder<'_>,\n         assoc_container_id: DefId,\n         current_method_ident: Option<Symbol>,\n@@ -789,7 +789,7 @@ fn foo(&self) -> Self::T { String::new() }\n     }\n \n     fn point_at_associated_type(\n-        &self,\n+        self,\n         db: &mut DiagnosticBuilder<'_>,\n         body_owner_def_id: DefId,\n         found: Ty<'tcx>,"}, {"sha": "84134bedef0bc218564ac823ae45e97f5a1014ed", "filename": "compiler/rustc_middle/src/ty/fold.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9567b5a9f52f35f1bb127f626a1b14062d735751/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9567b5a9f52f35f1bb127f626a1b14062d735751/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs?ref=9567b5a9f52f35f1bb127f626a1b14062d735751", "patch": "@@ -623,7 +623,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// Replaces any late-bound regions bound in `value` with\n     /// free variants attached to `all_outlive_scope`.\n     pub fn liberate_late_bound_regions<T>(\n-        &self,\n+        self,\n         all_outlive_scope: DefId,\n         value: &ty::Binder<T>,\n     ) -> T\n@@ -644,7 +644,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     /// variables and equate `value` with something else, those\n     /// variables will also be equated.\n     pub fn collect_constrained_late_bound_regions<T>(\n-        &self,\n+        self,\n         value: &Binder<T>,\n     ) -> FxHashSet<ty::BoundRegion>\n     where\n@@ -655,7 +655,7 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     /// Returns a set of all late-bound regions that appear in `value` anywhere.\n     pub fn collect_referenced_late_bound_regions<T>(\n-        &self,\n+        self,\n         value: &Binder<T>,\n     ) -> FxHashSet<ty::BoundRegion>\n     where\n@@ -665,7 +665,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     fn collect_late_bound_regions<T>(\n-        &self,\n+        self,\n         value: &Binder<T>,\n         just_constraint: bool,\n     ) -> FxHashSet<ty::BoundRegion>"}, {"sha": "4127b6535bca6c5a013d0bf624dd61660367757f", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/9567b5a9f52f35f1bb127f626a1b14062d735751/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9567b5a9f52f35f1bb127f626a1b14062d735751/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=9567b5a9f52f35f1bb127f626a1b14062d735751", "patch": "@@ -170,9 +170,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         });\n         hasher.finish()\n     }\n-}\n \n-impl<'tcx> TyCtxt<'tcx> {\n     pub fn has_error_field(self, ty: Ty<'tcx>) -> bool {\n         if let ty::Adt(def, substs) = *ty.kind() {\n             for field in def.all_fields() {\n@@ -526,22 +524,22 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     /// Returns `true` if the node pointed to by `def_id` is a `static` item.\n-    pub fn is_static(&self, def_id: DefId) -> bool {\n+    pub fn is_static(self, def_id: DefId) -> bool {\n         self.static_mutability(def_id).is_some()\n     }\n \n     /// Returns `true` if this is a `static` item with the `#[thread_local]` attribute.\n-    pub fn is_thread_local_static(&self, def_id: DefId) -> bool {\n+    pub fn is_thread_local_static(self, def_id: DefId) -> bool {\n         self.codegen_fn_attrs(def_id).flags.contains(CodegenFnAttrFlags::THREAD_LOCAL)\n     }\n \n     /// Returns `true` if the node pointed to by `def_id` is a mutable `static` item.\n-    pub fn is_mutable_static(&self, def_id: DefId) -> bool {\n+    pub fn is_mutable_static(self, def_id: DefId) -> bool {\n         self.static_mutability(def_id) == Some(hir::Mutability::Mut)\n     }\n \n     /// Get the type of the pointer to the static that we use in MIR.\n-    pub fn static_ptr_ty(&self, def_id: DefId) -> Ty<'tcx> {\n+    pub fn static_ptr_ty(self, def_id: DefId) -> Ty<'tcx> {\n         // Make sure that any constants in the static's type are evaluated.\n         let static_ty = self.normalize_erasing_regions(ty::ParamEnv::empty(), self.type_of(def_id));\n "}]}