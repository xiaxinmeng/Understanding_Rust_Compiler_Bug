{"sha": "6d55211700545d253dec4ebbe386832e00d2a247", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZkNTUyMTE3MDA1NDVkMjUzZGVjNGViYmUzODY4MzJlMDBkMmEyNDc=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-19T05:56:34Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-01-19T05:56:34Z"}, "message": "auto merge of #11615 : adwhit/rust/master, r=cmr\n\nThis is my first patch so feedback appreciated!\r\n\r\nBug when initialising `bitv:Bitv::new(int,bool)` when `bool=true`. It created a `Bitv` with underlying representation `!0u` rather than the actual desired bit layout ( e.g. `11111111` instead of `00001111`). This works OK because a size attribute is included which keeps access to legal bounds.  However when using `BitvSet::from_bitv(Bitv)`, we then find that `bitvset.contains(i)` can return true when `i` should not in fact be in the set.\r\n\r\n```\r\nlet bs = BitvSet::from_bitv(Bitv::new(100, true));\r\nassert!(!bs.contains(&127)) //fails\r\n```\r\n\r\nThe fix is to create the correct representation by treating various cases separately and using a bitshift `(1<<nbits) - 1` to generate correct number of `1`s where necessary.", "tree": {"sha": "0dfbc7c07c5fa4b34c6e3e13d342e35331b0f402", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0dfbc7c07c5fa4b34c6e3e13d342e35331b0f402"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6d55211700545d253dec4ebbe386832e00d2a247", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6d55211700545d253dec4ebbe386832e00d2a247", "html_url": "https://github.com/rust-lang/rust/commit/6d55211700545d253dec4ebbe386832e00d2a247", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6d55211700545d253dec4ebbe386832e00d2a247/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1a9641bf8e02230427a6e90e6662b879dec8caf2", "url": "https://api.github.com/repos/rust-lang/rust/commits/1a9641bf8e02230427a6e90e6662b879dec8caf2", "html_url": "https://github.com/rust-lang/rust/commit/1a9641bf8e02230427a6e90e6662b879dec8caf2"}, {"sha": "32408a6e32ba396a8e5f4d183d6b80352dfad092", "url": "https://api.github.com/repos/rust-lang/rust/commits/32408a6e32ba396a8e5f4d183d6b80352dfad092", "html_url": "https://github.com/rust-lang/rust/commit/32408a6e32ba396a8e5f4d183d6b80352dfad092"}], "stats": {"total": 37, "additions": 30, "deletions": 7}, "files": [{"sha": "305c97020018bc46f258b62f460bcf5ac263e24e", "filename": "src/libextra/bitv.rs", "status": "modified", "additions": 30, "deletions": 7, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/6d55211700545d253dec4ebbe386832e00d2a247/src%2Flibextra%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d55211700545d253dec4ebbe386832e00d2a247/src%2Flibextra%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbitv.rs?ref=6d55211700545d253dec4ebbe386832e00d2a247", "patch": "@@ -269,14 +269,23 @@ impl Bitv {\n \n impl Bitv {\n     pub fn new(nbits: uint, init: bool) -> Bitv {\n-        let rep = if nbits <= uint::bits {\n+        let rep = if nbits < uint::bits {\n+            Small(SmallBitv::new(if init {(1<<nbits)-1} else {0}))\n+        } else if nbits == uint::bits {\n             Small(SmallBitv::new(if init {!0} else {0}))\n-        }\n-        else {\n-            let nelems = nbits/uint::bits +\n-                         if nbits % uint::bits == 0 {0} else {1};\n-            let elem = if init {!0u} else {0u};\n-            let s = vec::from_elem(nelems, elem);\n+        } else {\n+            let exact = nbits % uint::bits == 0;\n+            let nelems = nbits/uint::bits + if exact {0} else {1};\n+            let s =\n+                if init {\n+                    if exact {\n+                        vec::from_elem(nelems, !0u)\n+                    } else {\n+                        let mut v = vec::from_elem(nelems-1, !0u);\n+                        v.push((1<<nbits % uint::bits)-1);\n+                        v\n+                    }\n+                } else { vec::from_elem(nelems, 0u)};\n             Big(BigBitv::new(s))\n         };\n         Bitv {rep: rep, nbits: nbits}\n@@ -1329,6 +1338,20 @@ mod tests {\n         assert_eq!(idxs, ~[0, 2, 3]);\n     }\n \n+    #[test]\n+    fn test_bitv_set_frombitv_init() {\n+        let bools = [true, false];\n+        let lengths = [10, 64, 100];\n+        for &b in bools.iter() {\n+            for &l in lengths.iter() {\n+                let bitset = BitvSet::from_bitv(Bitv::new(l, b));\n+                assert_eq!(bitset.contains(&1u), b)\n+                assert_eq!(bitset.contains(&(l-1u)), b)\n+                assert!(!bitset.contains(&l))\n+            }\n+        }\n+    }\n+\n     #[test]\n     fn test_small_difference() {\n         let mut b1 = Bitv::new(3, false);"}]}