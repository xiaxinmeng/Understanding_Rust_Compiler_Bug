{"sha": "c6ca2205eae522387237057812b7901a2c5d3906", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM2Y2EyMjA1ZWFlNTIyMzg3MjM3MDU3ODEyYjc5MDFhMmM1ZDM5MDY=", "commit": {"author": {"name": "Jake Goulding", "email": "jake.goulding@gmail.com", "date": "2015-03-15T00:07:13Z"}, "committer": {"name": "Jake Goulding", "email": "jake.goulding@gmail.com", "date": "2015-03-19T23:25:22Z"}, "message": "StrExt::splitn should not require a DoubleEndedSearcher\n\nCloses #23262", "tree": {"sha": "3f47dad793b14ee6b574ed29d2cc03b4b82020ca", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3f47dad793b14ee6b574ed29d2cc03b4b82020ca"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c6ca2205eae522387237057812b7901a2c5d3906", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c6ca2205eae522387237057812b7901a2c5d3906", "html_url": "https://github.com/rust-lang/rust/commit/c6ca2205eae522387237057812b7901a2c5d3906", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c6ca2205eae522387237057812b7901a2c5d3906/comments", "author": {"login": "shepmaster", "id": 174509, "node_id": "MDQ6VXNlcjE3NDUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/174509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/shepmaster", "html_url": "https://github.com/shepmaster", "followers_url": "https://api.github.com/users/shepmaster/followers", "following_url": "https://api.github.com/users/shepmaster/following{/other_user}", "gists_url": "https://api.github.com/users/shepmaster/gists{/gist_id}", "starred_url": "https://api.github.com/users/shepmaster/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/shepmaster/subscriptions", "organizations_url": "https://api.github.com/users/shepmaster/orgs", "repos_url": "https://api.github.com/users/shepmaster/repos", "events_url": "https://api.github.com/users/shepmaster/events{/privacy}", "received_events_url": "https://api.github.com/users/shepmaster/received_events", "type": "User", "site_admin": false}, "committer": {"login": "shepmaster", "id": 174509, "node_id": "MDQ6VXNlcjE3NDUwOQ==", "avatar_url": "https://avatars.githubusercontent.com/u/174509?v=4", "gravatar_id": "", "url": "https://api.github.com/users/shepmaster", "html_url": "https://github.com/shepmaster", "followers_url": "https://api.github.com/users/shepmaster/followers", "following_url": "https://api.github.com/users/shepmaster/following{/other_user}", "gists_url": "https://api.github.com/users/shepmaster/gists{/gist_id}", "starred_url": "https://api.github.com/users/shepmaster/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/shepmaster/subscriptions", "organizations_url": "https://api.github.com/users/shepmaster/orgs", "repos_url": "https://api.github.com/users/shepmaster/repos", "events_url": "https://api.github.com/users/shepmaster/events{/privacy}", "received_events_url": "https://api.github.com/users/shepmaster/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6a5148bda1364bd46607a3c4ebdcfb0f408e0850", "url": "https://api.github.com/repos/rust-lang/rust/commits/6a5148bda1364bd46607a3c4ebdcfb0f408e0850", "html_url": "https://github.com/rust-lang/rust/commit/6a5148bda1364bd46607a3c4ebdcfb0f408e0850"}], "stats": {"total": 98, "additions": 59, "deletions": 39}, "files": [{"sha": "67b7039a1959eb568714a5674d13fedd726ba887", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/c6ca2205eae522387237057812b7901a2c5d3906/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6ca2205eae522387237057812b7901a2c5d3906/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=c6ca2205eae522387237057812b7901a2c5d3906", "patch": "@@ -727,23 +727,20 @@ impl str {\n         core_str::StrExt::rsplit(&self[..], pat)\n     }\n \n-    /// An iterator over substrings of `self`, separated by characters matched by a pattern,\n-    /// starting from the end of the string.\n-    ///\n-    /// Restricted to splitting at most `count` times.\n-    ///\n-    /// The pattern can be a simple `&str`, or a closure that determines the split.\n+    /// An iterator over substrings of `self`, separated by a pattern,\n+    /// starting from the end of the string, restricted to splitting\n+    /// at most `count` times.\n     ///\n     /// # Examples\n     ///\n-    /// Simple `&str` patterns:\n+    /// Simple patterns:\n     ///\n     /// ```\n     /// let v: Vec<&str> = \"Mary had a little lamb\".rsplitn(2, ' ').collect();\n     /// assert_eq!(v, [\"lamb\", \"little\", \"Mary had a\"]);\n     ///\n-    /// let v: Vec<&str> = \"lionXXtigerXleopard\".rsplitn(2, 'X').collect();\n-    /// assert_eq!(v, [\"leopard\", \"tiger\", \"lionX\"]);\n+    /// let v: Vec<&str> = \"lion::tiger::leopard\".rsplitn(1, \"::\").collect();\n+    /// assert_eq!(v, [\"leopard\", \"lion::tiger\"]);\n     /// ```\n     ///\n     /// More complex patterns with a lambda:\n@@ -753,7 +750,9 @@ impl str {\n     /// assert_eq!(v, [\"ghi\", \"abc1def\"]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn rsplitn<'a, P: Pattern<'a>>(&'a self, count: usize, pat: P) -> RSplitN<'a, P> {\n+    pub fn rsplitn<'a, P: Pattern<'a>>(&'a self, count: usize, pat: P) -> RSplitN<'a, P>\n+        where P::Searcher: ReverseSearcher<'a>\n+    {\n         core_str::StrExt::rsplitn(&self[..], count, pat)\n     }\n "}, {"sha": "5cfa800905415dd855554be725c97731ac513448", "filename": "src/libcollectionstest/str.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c6ca2205eae522387237057812b7901a2c5d3906/src%2Flibcollectionstest%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6ca2205eae522387237057812b7901a2c5d3906/src%2Flibcollectionstest%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollectionstest%2Fstr.rs?ref=c6ca2205eae522387237057812b7901a2c5d3906", "patch": "@@ -924,6 +924,20 @@ fn test_rsplit() {\n     assert_eq!(split, [\"mb\\n\", \"mb\\nLittle l\", \" little l\", \"d \", \"ry h\", \"\\nM\"]);\n }\n \n+#[test]\n+fn test_rsplitn() {\n+    let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n+\n+    let split: Vec<&str> = data.rsplitn(1, ' ').collect();\n+    assert_eq!(split, [\"l\u00e4mb\\n\", \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle\"]);\n+\n+    let split: Vec<&str> = data.rsplitn(1, \"l\u00e4mb\").collect();\n+    assert_eq!(split, [\"\\n\", \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle \"]);\n+\n+    let split: Vec<&str> = data.rsplitn(1, |c: char| c == '\u00e4').collect();\n+    assert_eq!(split, [\"mb\\n\", \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\"]);\n+}\n+\n #[test]\n fn test_words() {\n     let data = \"\\n \\tM\u00e4ry   h\u00e4d\\t\u00e4  little l\u00e4mb\\nLittle l\u00e4mb\\n\";"}, {"sha": "4734e9b7a9fe58d3e8bec8086943323ee30ecfe1", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 36, "deletions": 29, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/c6ca2205eae522387237057812b7901a2c5d3906/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c6ca2205eae522387237057812b7901a2c5d3906/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=c6ca2205eae522387237057812b7901a2c5d3906", "patch": "@@ -567,7 +567,6 @@ struct CharSplitsN<'a, P: Pattern<'a>> {\n     iter: CharSplits<'a, P>,\n     /// The number of splits remaining\n     count: usize,\n-    invert: bool,\n }\n \n /// An iterator over the substrings of a string, separated by a\n@@ -582,6 +581,13 @@ struct RCharSplits<'a, P: Pattern<'a>> {\n     finished: bool,\n }\n \n+/// An iterator over the substrings of a string, separated by a\n+/// pattern, splitting at most `count` times, in reverse order.\n+struct RCharSplitsN<'a, P: Pattern<'a>> {\n+    iter: RCharSplits<'a, P>,\n+    /// The number of splits remaining\n+    count: usize,\n+}\n \n /// An iterator over the lines of a string, separated by `\\n`.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -661,15 +667,14 @@ where P::Searcher: DoubleEndedSearcher<'a> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, P: Pattern<'a>> Iterator for CharSplitsN<'a, P>\n-where P::Searcher: DoubleEndedSearcher<'a> {\n+impl<'a, P: Pattern<'a>> Iterator for CharSplitsN<'a, P> {\n     type Item = &'a str;\n \n     #[inline]\n     fn next(&mut self) -> Option<&'a str> {\n         if self.count != 0 {\n             self.count -= 1;\n-            if self.invert { self.iter.next_back() } else { self.iter.next() }\n+            self.iter.next()\n         } else {\n             self.iter.get_end()\n         }\n@@ -713,6 +718,23 @@ impl<'a, P: Pattern<'a>> Iterator for RCharSplits<'a, P>\n     }\n }\n \n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<'a, P: Pattern<'a>> Iterator for RCharSplitsN<'a, P>\n+    where P::Searcher: ReverseSearcher<'a>\n+{\n+    type Item = &'a str;\n+\n+    #[inline]\n+    fn next(&mut self) -> Option<&'a str> {\n+        if self.count != 0 {\n+            self.count -= 1;\n+            self.iter.next()\n+        } else {\n+            self.iter.get_remainder()\n+        }\n+    }\n+}\n+\n /// The internal state of an iterator that searches for matches of a substring\n /// within a larger string using two-way search\n #[derive(Clone)]\n@@ -1360,23 +1382,7 @@ impl<'a, S: ?Sized> Str for &'a S where S: Str {\n /// Return type of `StrExt::split`\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Split<'a, P: Pattern<'a>>(CharSplits<'a, P>);\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, P: Pattern<'a>> Iterator for Split<'a, P> {\n-    type Item = &'a str;\n-\n-    #[inline]\n-    fn next(&mut self) -> Option<&'a str> {\n-        self.0.next()\n-    }\n-}\n-#[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, P: Pattern<'a>> DoubleEndedIterator for Split<'a, P>\n-where P::Searcher: DoubleEndedSearcher<'a> {\n-    #[inline]\n-    fn next_back(&mut self) -> Option<&'a str> {\n-        self.0.next_back()\n-    }\n-}\n+delegate_iter!{pattern &'a str : Split<'a, P>}\n \n /// Return type of `StrExt::split_terminator`\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1395,8 +1401,8 @@ delegate_iter!{pattern reverse &'a str : RSplit<'a, P>}\n \n /// Return type of `StrExt::rsplitn`\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct RSplitN<'a, P: Pattern<'a>>(CharSplitsN<'a, P>);\n-delegate_iter!{pattern forward &'a str : RSplitN<'a, P>}\n+pub struct RSplitN<'a, P: Pattern<'a>>(RCharSplitsN<'a, P>);\n+delegate_iter!{pattern reverse &'a str : RSplitN<'a, P>}\n \n /// Methods for string slices\n #[allow(missing_docs)]\n@@ -1414,7 +1420,8 @@ pub trait StrExt {\n     fn split_terminator<'a, P: Pattern<'a>>(&'a self, pat: P) -> SplitTerminator<'a, P>;\n     fn rsplit<'a, P: Pattern<'a>>(&'a self, pat: P) -> RSplit<'a, P>\n         where P::Searcher: ReverseSearcher<'a>;\n-    fn rsplitn<'a, P: Pattern<'a>>(&'a self, count: usize, pat: P) -> RSplitN<'a, P>;\n+    fn rsplitn<'a, P: Pattern<'a>>(&'a self, count: usize, pat: P) -> RSplitN<'a, P>\n+        where P::Searcher: ReverseSearcher<'a>;\n     fn match_indices<'a, P: Pattern<'a>>(&'a self, pat: P) -> MatchIndices<'a, P>;\n     #[allow(deprecated) /* for SplitStr */]\n     fn split_str<'a, P: Pattern<'a>>(&'a self, pat: P) -> SplitStr<'a, P>;\n@@ -1498,7 +1505,6 @@ impl StrExt for str {\n         SplitN(CharSplitsN {\n             iter: self.split(pat).0,\n             count: count,\n-            invert: false,\n         })\n     }\n \n@@ -1524,11 +1530,12 @@ impl StrExt for str {\n     }\n \n     #[inline]\n-    fn rsplitn<'a, P: Pattern<'a>>(&'a self, count: usize, pat: P) -> RSplitN<'a, P> {\n-        RSplitN(CharSplitsN {\n-            iter: self.split(pat).0,\n+    fn rsplitn<'a, P: Pattern<'a>>(&'a self, count: usize, pat: P) -> RSplitN<'a, P>\n+        where P::Searcher: ReverseSearcher<'a>\n+    {\n+        RSplitN(RCharSplitsN {\n+            iter: self.rsplit(pat).0,\n             count: count,\n-            invert: true,\n         })\n     }\n "}]}