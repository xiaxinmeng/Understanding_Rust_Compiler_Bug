{"sha": "f6a28aa4036415d8aa713bf707842779b709935e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY2YTI4YWE0MDM2NDE1ZDhhYTcxM2JmNzA3ODQyNzc5YjcwOTkzNWU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-26T13:51:30Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-26T13:51:30Z"}, "message": "Auto merge of #85720 - Dylan-DPC:rollup-in5917x, r=Dylan-DPC\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #85478 (Disallow shadowing const parameters)\n - #85625 (Prevent double drop in `Vec::dedup_by` if a destructor panics)\n - #85627 (Fix a few details in THIR unsafeck)\n - #85633 (Post-monomorphization errors traces MVP)\n - #85670 (Remove arrays/IntoIterator message from Iterator trait.)\n - #85678 (fix `matches!` and `assert_matches!` on edition 2021)\n - #85679 (Remove num_as_ne_bytes feature)\n - #85712 (Fix typo in core::array::IntoIter comment)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "c7147f4dc0f77bc3ed1cfd14731b161e30967308", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c7147f4dc0f77bc3ed1cfd14731b161e30967308"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f6a28aa4036415d8aa713bf707842779b709935e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f6a28aa4036415d8aa713bf707842779b709935e", "html_url": "https://github.com/rust-lang/rust/commit/f6a28aa4036415d8aa713bf707842779b709935e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f6a28aa4036415d8aa713bf707842779b709935e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1969c2e312303faa458cf19dad9783165e3c72c8", "url": "https://api.github.com/repos/rust-lang/rust/commits/1969c2e312303faa458cf19dad9783165e3c72c8", "html_url": "https://github.com/rust-lang/rust/commit/1969c2e312303faa458cf19dad9783165e3c72c8"}, {"sha": "9ee87c7e006491931cd9dbfa90e5bda9e452a6fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/9ee87c7e006491931cd9dbfa90e5bda9e452a6fd", "html_url": "https://github.com/rust-lang/rust/commit/9ee87c7e006491931cd9dbfa90e5bda9e452a6fd"}], "stats": {"total": 645, "additions": 444, "deletions": 201}, "files": [{"sha": "0109580a0bba90062c773206f1b31e4f703686cb", "filename": "compiler/rustc_middle/src/mir/mono.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f6a28aa4036415d8aa713bf707842779b709935e/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6a28aa4036415d8aa713bf707842779b709935e/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmono.rs?ref=f6a28aa4036415d8aa713bf707842779b709935e", "patch": "@@ -186,6 +186,15 @@ impl<'tcx> MonoItem<'tcx> {\n     pub fn codegen_dep_node(&self, tcx: TyCtxt<'tcx>) -> DepNode {\n         crate::dep_graph::make_compile_mono_item(tcx, self)\n     }\n+\n+    /// Returns the item's `CrateNum`\n+    pub fn krate(&self) -> CrateNum {\n+        match self {\n+            MonoItem::Fn(ref instance) => instance.def_id().krate,\n+            MonoItem::Static(def_id) => def_id.krate,\n+            MonoItem::GlobalAsm(..) => LOCAL_CRATE,\n+        }\n+    }\n }\n \n impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for MonoItem<'tcx> {"}, {"sha": "afe4457bf433d5f772ea7708dfcccedeeb2e265a", "filename": "compiler/rustc_mir/src/monomorphize/collector.rs", "status": "modified", "additions": 44, "deletions": 2, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/f6a28aa4036415d8aa713bf707842779b709935e/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6a28aa4036415d8aa713bf707842779b709935e/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fmonomorphize%2Fcollector.rs?ref=f6a28aa4036415d8aa713bf707842779b709935e", "patch": "@@ -184,7 +184,7 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::sync::{par_iter, MTLock, MTRef, ParallelIterator};\n use rustc_errors::{ErrorReported, FatalError};\n use rustc_hir as hir;\n-use rustc_hir::def_id::{DefId, DefIdMap, LocalDefId};\n+use rustc_hir::def_id::{DefId, DefIdMap, LocalDefId, LOCAL_CRATE};\n use rustc_hir::itemlikevisit::ItemLikeVisitor;\n use rustc_hir::lang_items::LangItem;\n use rustc_index::bit_set::GrowableBitSet;\n@@ -342,7 +342,8 @@ fn collect_roots(tcx: TyCtxt<'_>, mode: MonoItemCollectionMode) -> Vec<MonoItem<\n         .collect()\n }\n \n-// Collect all monomorphized items reachable from `starting_point`\n+/// Collect all monomorphized items reachable from `starting_point`, and emit a note diagnostic if a\n+/// post-monorphization error is encountered during a collection step.\n fn collect_items_rec<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     starting_point: Spanned<MonoItem<'tcx>>,\n@@ -359,6 +360,31 @@ fn collect_items_rec<'tcx>(\n     let mut neighbors = Vec::new();\n     let recursion_depth_reset;\n \n+    //\n+    // Post-monomorphization errors MVP\n+    //\n+    // We can encounter errors while monomorphizing an item, but we don't have a good way of\n+    // showing a complete stack of spans ultimately leading to collecting the erroneous one yet.\n+    // (It's also currently unclear exactly which diagnostics and information would be interesting\n+    // to report in such cases)\n+    //\n+    // This leads to suboptimal error reporting: a post-monomorphization error (PME) will be\n+    // shown with just a spanned piece of code causing the error, without information on where\n+    // it was called from. This is especially obscure if the erroneous mono item is in a\n+    // dependency. See for example issue #85155, where, before minimization, a PME happened two\n+    // crates downstream from libcore's stdarch, without a way to know which dependency was the\n+    // cause.\n+    //\n+    // If such an error occurs in the current crate, its span will be enough to locate the\n+    // source. If the cause is in another crate, the goal here is to quickly locate which mono\n+    // item in the current crate is ultimately responsible for causing the error.\n+    //\n+    // To give at least _some_ context to the user: while collecting mono items, we check the\n+    // error count. If it has changed, a PME occurred, and we trigger some diagnostics about the\n+    // current step of mono items collection.\n+    //\n+    let error_count = tcx.sess.diagnostic().err_count();\n+\n     match starting_point.node {\n         MonoItem::Static(def_id) => {\n             let instance = Instance::mono(tcx, def_id);\n@@ -411,6 +437,22 @@ fn collect_items_rec<'tcx>(\n         }\n     }\n \n+    // Check for PMEs and emit a diagnostic if one happened. To try to show relevant edges of the\n+    // mono item graph where the PME diagnostics are currently the most problematic (e.g. ones\n+    // involving a dependency, and the lack of context is confusing) in this MVP, we focus on\n+    // diagnostics on edges crossing a crate boundary: the collected mono items which are not\n+    // defined in the local crate.\n+    if tcx.sess.diagnostic().err_count() > error_count && starting_point.node.krate() != LOCAL_CRATE\n+    {\n+        tcx.sess.span_note_without_error(\n+            starting_point.span,\n+            &format!(\n+                \"the above error was encountered while instantiating `{}`\",\n+                starting_point.node\n+            ),\n+        );\n+    }\n+\n     record_accesses(tcx, starting_point.node, neighbors.iter().map(|i| &i.node), inlining_map);\n \n     for neighbour in neighbors {"}, {"sha": "971b6dd9e1c8905bcd592f56342eba299fc9cd1e", "filename": "compiler/rustc_mir_build/src/check_unsafety.rs", "status": "modified", "additions": 25, "deletions": 16, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/f6a28aa4036415d8aa713bf707842779b709935e/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6a28aa4036415d8aa713bf707842779b709935e/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fcheck_unsafety.rs?ref=f6a28aa4036415d8aa713bf707842779b709935e", "patch": "@@ -42,7 +42,7 @@ impl<'tcx> UnsafetyVisitor<'_, 'tcx> {\n             self.warn_unused_unsafe(\n                 hir_id,\n                 block_span,\n-                Some(self.tcx.sess.source_map().guess_head_span(enclosing_span)),\n+                Some((self.tcx.sess.source_map().guess_head_span(enclosing_span), \"block\")),\n             );\n             f(self);\n         } else {\n@@ -52,7 +52,15 @@ impl<'tcx> UnsafetyVisitor<'_, 'tcx> {\n             f(self);\n \n             if let SafetyContext::UnsafeBlock { used: false, span, hir_id } = self.safety_context {\n-                self.warn_unused_unsafe(hir_id, span, self.body_unsafety.unsafe_fn_sig_span());\n+                self.warn_unused_unsafe(\n+                    hir_id,\n+                    span,\n+                    if self.unsafe_op_in_unsafe_fn_allowed() {\n+                        self.body_unsafety.unsafe_fn_sig_span().map(|span| (span, \"fn\"))\n+                    } else {\n+                        None\n+                    },\n+                );\n             }\n             self.safety_context = prev_context;\n             return;\n@@ -72,16 +80,20 @@ impl<'tcx> UnsafetyVisitor<'_, 'tcx> {\n             SafetyContext::UnsafeFn if unsafe_op_in_unsafe_fn_allowed => {}\n             SafetyContext::UnsafeFn => {\n                 // unsafe_op_in_unsafe_fn is disallowed\n-                struct_span_err!(\n-                    self.tcx.sess,\n+                self.tcx.struct_span_lint_hir(\n+                    UNSAFE_OP_IN_UNSAFE_FN,\n+                    self.hir_context,\n                     span,\n-                    E0133,\n-                    \"{} is unsafe and requires unsafe block\",\n-                    description,\n+                    |lint| {\n+                        lint.build(&format!(\n+                            \"{} is unsafe and requires unsafe block (error E0133)\",\n+                            description,\n+                        ))\n+                        .span_label(span, description)\n+                        .note(note)\n+                        .emit();\n+                    },\n                 )\n-                .span_label(span, description)\n-                .note(note)\n-                .emit();\n             }\n             SafetyContext::Safe => {\n                 let fn_sugg = if unsafe_op_in_unsafe_fn_allowed { \" function or\" } else { \"\" };\n@@ -104,18 +116,15 @@ impl<'tcx> UnsafetyVisitor<'_, 'tcx> {\n         &self,\n         hir_id: hir::HirId,\n         block_span: Span,\n-        enclosing_span: Option<Span>,\n+        enclosing_unsafe: Option<(Span, &'static str)>,\n     ) {\n         let block_span = self.tcx.sess.source_map().guess_head_span(block_span);\n         self.tcx.struct_span_lint_hir(UNUSED_UNSAFE, hir_id, block_span, |lint| {\n             let msg = \"unnecessary `unsafe` block\";\n             let mut db = lint.build(msg);\n             db.span_label(block_span, msg);\n-            if let Some(enclosing_span) = enclosing_span {\n-                db.span_label(\n-                    enclosing_span,\n-                    format!(\"because it's nested under this `unsafe` block\"),\n-                );\n+            if let Some((span, kind)) = enclosing_unsafe {\n+                db.span_label(span, format!(\"because it's nested under this `unsafe` {}\", kind));\n             }\n             db.emit();\n         });"}, {"sha": "a1eafd65d643d57bc238fb060e4708bc722ef01f", "filename": "compiler/rustc_resolve/src/diagnostics.rs", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/f6a28aa4036415d8aa713bf707842779b709935e/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6a28aa4036415d8aa713bf707842779b709935e/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fdiagnostics.rs?ref=f6a28aa4036415d8aa713bf707842779b709935e", "patch": "@@ -425,24 +425,29 @@ impl<'a> Resolver<'a> {\n                 }\n                 err\n             }\n-            ResolutionError::BindingShadowsSomethingUnacceptable(what_binding, name, binding) => {\n-                let res = binding.res();\n-                let shadows_what = res.descr();\n+            ResolutionError::BindingShadowsSomethingUnacceptable {\n+                shadowing_binding_descr,\n+                name,\n+                participle,\n+                article,\n+                shadowed_binding_descr,\n+                shadowed_binding_span,\n+            } => {\n                 let mut err = struct_span_err!(\n                     self.session,\n                     span,\n                     E0530,\n                     \"{}s cannot shadow {}s\",\n-                    what_binding,\n-                    shadows_what\n+                    shadowing_binding_descr,\n+                    shadowed_binding_descr,\n                 );\n                 err.span_label(\n                     span,\n-                    format!(\"cannot be named the same as {} {}\", res.article(), shadows_what),\n+                    format!(\"cannot be named the same as {} {}\", article, shadowed_binding_descr),\n                 );\n-                let participle = if binding.is_import() { \"imported\" } else { \"defined\" };\n-                let msg = format!(\"the {} `{}` is {} here\", shadows_what, name, participle);\n-                err.span_label(binding.span, msg);\n+                let msg =\n+                    format!(\"the {} `{}` is {} here\", shadowed_binding_descr, name, participle);\n+                err.span_label(shadowed_binding_span, msg);\n                 err\n             }\n             ResolutionError::ForwardDeclaredTyParam => {"}, {"sha": "662d39f6ef39ca41bf7390f38c860f385e374823", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 25, "deletions": 5, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f6a28aa4036415d8aa713bf707842779b709935e/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6a28aa4036415d8aa713bf707842779b709935e/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=f6a28aa4036415d8aa713bf707842779b709935e", "patch": "@@ -1763,13 +1763,33 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 // to something unusable as a pattern (e.g., constructor function),\n                 // but we still conservatively report an error, see\n                 // issues/33118#issuecomment-233962221 for one reason why.\n+                let binding = binding.expect(\"no binding for a ctor or static\");\n                 self.report_error(\n                     ident.span,\n-                    ResolutionError::BindingShadowsSomethingUnacceptable(\n-                        pat_src.descr(),\n-                        ident.name,\n-                        binding.expect(\"no binding for a ctor or static\"),\n-                    ),\n+                    ResolutionError::BindingShadowsSomethingUnacceptable {\n+                        shadowing_binding_descr: pat_src.descr(),\n+                        name: ident.name,\n+                        participle: if binding.is_import() { \"imported\" } else { \"defined\" },\n+                        article: binding.res().article(),\n+                        shadowed_binding_descr: binding.res().descr(),\n+                        shadowed_binding_span: binding.span,\n+                    },\n+                );\n+                None\n+            }\n+            Res::Def(DefKind::ConstParam, def_id) => {\n+                // Same as for DefKind::Const above, but here, `binding` is `None`, so we\n+                // have to construct the error differently\n+                self.report_error(\n+                    ident.span,\n+                    ResolutionError::BindingShadowsSomethingUnacceptable {\n+                        shadowing_binding_descr: pat_src.descr(),\n+                        name: ident.name,\n+                        participle: \"defined\",\n+                        article: res.article(),\n+                        shadowed_binding_descr: res.descr(),\n+                        shadowed_binding_span: self.r.opt_span(def_id).expect(\"const parameter defined outside of local crate\"),\n+                    }\n                 );\n                 None\n             }"}, {"sha": "76d845f782e7e8dfaeb0ebce6ccd0812766898e8", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f6a28aa4036415d8aa713bf707842779b709935e/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6a28aa4036415d8aa713bf707842779b709935e/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=f6a28aa4036415d8aa713bf707842779b709935e", "patch": "@@ -233,7 +233,14 @@ enum ResolutionError<'a> {\n         /* current */ &'static str,\n     ),\n     /// Error E0530: `X` bindings cannot shadow `Y`s.\n-    BindingShadowsSomethingUnacceptable(&'static str, Symbol, &'a NameBinding<'a>),\n+    BindingShadowsSomethingUnacceptable {\n+        shadowing_binding_descr: &'static str,\n+        name: Symbol,\n+        participle: &'static str,\n+        article: &'static str,\n+        shadowed_binding_descr: &'static str,\n+        shadowed_binding_span: Span,\n+    },\n     /// Error E0128: generic parameters with a default cannot use forward-declared identifiers.\n     ForwardDeclaredTyParam, // FIXME(const_generics_defaults)\n     /// ERROR E0770: the type of const parameters must not depend on other generic parameters."}, {"sha": "105c60e7bf0851c270b853db941db50806f43350", "filename": "library/alloc/src/vec/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f6a28aa4036415d8aa713bf707842779b709935e/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6a28aa4036415d8aa713bf707842779b709935e/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Fmod.rs?ref=f6a28aa4036415d8aa713bf707842779b709935e", "patch": "@@ -1619,6 +1619,8 @@ impl<T, A: Allocator> Vec<T, A> {\n                 let prev_ptr = ptr.add(gap.write.wrapping_sub(1));\n \n                 if same_bucket(&mut *read_ptr, &mut *prev_ptr) {\n+                    // Increase `gap.read` now since the drop may panic.\n+                    gap.read += 1;\n                     /* We have found duplicate, drop it in-place */\n                     ptr::drop_in_place(read_ptr);\n                 } else {\n@@ -1631,9 +1633,8 @@ impl<T, A: Allocator> Vec<T, A> {\n \n                     /* We have filled that place, so go further */\n                     gap.write += 1;\n+                    gap.read += 1;\n                 }\n-\n-                gap.read += 1;\n             }\n \n             /* Technically we could let `gap` clean up with its Drop, but"}, {"sha": "36c81b49709735cb3a126faf27733355b261ccbb", "filename": "library/alloc/tests/vec.rs", "status": "modified", "additions": 25, "deletions": 23, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/f6a28aa4036415d8aa713bf707842779b709935e/library%2Falloc%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6a28aa4036415d8aa713bf707842779b709935e/library%2Falloc%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Ftests%2Fvec.rs?ref=f6a28aa4036415d8aa713bf707842779b709935e", "patch": "@@ -2234,48 +2234,50 @@ fn test_vec_dedup() {\n #[test]\n fn test_vec_dedup_panicking() {\n     #[derive(Debug)]\n-    struct Panic {\n-        drop_counter: &'static AtomicU32,\n+    struct Panic<'a> {\n+        drop_counter: &'a Cell<u32>,\n         value: bool,\n         index: usize,\n     }\n \n-    impl PartialEq for Panic {\n+    impl<'a> PartialEq for Panic<'a> {\n         fn eq(&self, other: &Self) -> bool {\n             self.value == other.value\n         }\n     }\n \n-    impl Drop for Panic {\n+    impl<'a> Drop for Panic<'a> {\n         fn drop(&mut self) {\n-            let x = self.drop_counter.fetch_add(1, Ordering::SeqCst);\n-            assert!(x != 4);\n+            self.drop_counter.set(self.drop_counter.get() + 1);\n+            if !std::thread::panicking() {\n+                assert!(self.index != 4);\n+            }\n         }\n     }\n \n-    static DROP_COUNTER: AtomicU32 = AtomicU32::new(0);\n+    let drop_counter = &Cell::new(0);\n     let expected = [\n-        Panic { drop_counter: &DROP_COUNTER, value: false, index: 0 },\n-        Panic { drop_counter: &DROP_COUNTER, value: false, index: 5 },\n-        Panic { drop_counter: &DROP_COUNTER, value: true, index: 6 },\n-        Panic { drop_counter: &DROP_COUNTER, value: true, index: 7 },\n+        Panic { drop_counter, value: false, index: 0 },\n+        Panic { drop_counter, value: false, index: 5 },\n+        Panic { drop_counter, value: true, index: 6 },\n+        Panic { drop_counter, value: true, index: 7 },\n     ];\n     let mut vec = vec![\n-        Panic { drop_counter: &DROP_COUNTER, value: false, index: 0 },\n+        Panic { drop_counter, value: false, index: 0 },\n         // these elements get deduplicated\n-        Panic { drop_counter: &DROP_COUNTER, value: false, index: 1 },\n-        Panic { drop_counter: &DROP_COUNTER, value: false, index: 2 },\n-        Panic { drop_counter: &DROP_COUNTER, value: false, index: 3 },\n-        Panic { drop_counter: &DROP_COUNTER, value: false, index: 4 },\n-        // here it panics\n-        Panic { drop_counter: &DROP_COUNTER, value: false, index: 5 },\n-        Panic { drop_counter: &DROP_COUNTER, value: true, index: 6 },\n-        Panic { drop_counter: &DROP_COUNTER, value: true, index: 7 },\n+        Panic { drop_counter, value: false, index: 1 },\n+        Panic { drop_counter, value: false, index: 2 },\n+        Panic { drop_counter, value: false, index: 3 },\n+        Panic { drop_counter, value: false, index: 4 },\n+        // here it panics while dropping the item with index==4\n+        Panic { drop_counter, value: false, index: 5 },\n+        Panic { drop_counter, value: true, index: 6 },\n+        Panic { drop_counter, value: true, index: 7 },\n     ];\n \n-    let _ = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {\n-        vec.dedup();\n-    }));\n+    let _ = catch_unwind(AssertUnwindSafe(|| vec.dedup())).unwrap_err();\n+\n+    assert_eq!(drop_counter.get(), 4);\n \n     let ok = vec.iter().zip(expected.iter()).all(|(x, y)| x.index == y.index);\n "}, {"sha": "aedbeab661058bf7f2953713e118fd272b907693", "filename": "library/core/src/array/iter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f6a28aa4036415d8aa713bf707842779b709935e/library%2Fcore%2Fsrc%2Farray%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6a28aa4036415d8aa713bf707842779b709935e/library%2Fcore%2Fsrc%2Farray%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Farray%2Fiter.rs?ref=f6a28aa4036415d8aa713bf707842779b709935e", "patch": "@@ -139,7 +139,7 @@ impl<T, const N: usize> Iterator for IntoIter<T, N> {\n         // SAFETY: Callers are only allowed to pass an index that is in bounds\n         // Additionally Self: TrustedRandomAccess is only implemented for T: Copy which means even\n         // multiple repeated reads of the same index would be safe and the\n-        // values aree !Drop, thus won't suffer from double drops.\n+        // values are !Drop, thus won't suffer from double drops.\n         unsafe { self.data.get_unchecked(self.alive.start + idx).assume_init_read() }\n     }\n }"}, {"sha": "1eef0f9064c90da8e1b566e5cd444e5cf6de20e9", "filename": "library/core/src/iter/traits/iterator.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/f6a28aa4036415d8aa713bf707842779b709935e/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6a28aa4036415d8aa713bf707842779b709935e/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fiter%2Ftraits%2Fiterator.rs?ref=f6a28aa4036415d8aa713bf707842779b709935e", "patch": "@@ -79,11 +79,6 @@ fn _assert_is_object_safe(_: &dyn Iterator<Item = ()>) {}\n         _Self = \"std::string::String\",\n         label = \"`{Self}` is not an iterator; try calling `.chars()` or `.bytes()`\"\n     ),\n-    on(\n-        _Self = \"[]\",\n-        label = \"arrays do not yet implement `IntoIterator`; try using `std::array::IntoIter::new(arr)`\",\n-        note = \"see <https://github.com/rust-lang/rust/pull/65819> for more details\"\n-    ),\n     on(\n         _Self = \"{integral}\",\n         note = \"if you want to iterate between `start` until a value `end`, use the exclusive range \\"}, {"sha": "a023edaca9e940563911eb1117989b774e4182f6", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f6a28aa4036415d8aa713bf707842779b709935e/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6a28aa4036415d8aa713bf707842779b709935e/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=f6a28aa4036415d8aa713bf707842779b709935e", "patch": "@@ -168,6 +168,7 @@\n #![feature(no_coverage)] // rust-lang/rust#84605\n #![feature(int_error_matching)]\n #![deny(unsafe_op_in_unsafe_fn)]\n+#![deny(or_patterns_back_compat)]\n \n // allow using `core::` in intra-doc links\n #[allow(unused_extern_crates)]"}, {"sha": "7eb65483b99e77e09ea5825062c6e5828a110d94", "filename": "library/core/src/macros/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f6a28aa4036415d8aa713bf707842779b709935e/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6a28aa4036415d8aa713bf707842779b709935e/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs?ref=f6a28aa4036415d8aa713bf707842779b709935e", "patch": "@@ -138,7 +138,7 @@ macro_rules! assert_ne {\n #[unstable(feature = \"assert_matches\", issue = \"82775\")]\n #[allow_internal_unstable(core_panic)]\n macro_rules! assert_matches {\n-    ($left:expr, $( $pattern:pat )|+ $( if $guard: expr )? $(,)?) => ({\n+    ($left:expr, $( $pattern:pat_param )|+ $( if $guard: expr )? $(,)?) => ({\n         match $left {\n             $( $pattern )|+ $( if $guard )? => {}\n             ref left_val => {\n@@ -150,7 +150,7 @@ macro_rules! assert_matches {\n             }\n         }\n     });\n-    ($left:expr, $( $pattern:pat )|+ $( if $guard: expr )?, $($arg:tt)+) => ({\n+    ($left:expr, $( $pattern:pat_param )|+ $( if $guard: expr )?, $($arg:tt)+) => ({\n         match $left {\n             $( $pattern )|+ $( if $guard )? => {}\n             ref left_val => {\n@@ -315,7 +315,7 @@ macro_rules! debug_assert_matches {\n #[macro_export]\n #[stable(feature = \"matches_macro\", since = \"1.42.0\")]\n macro_rules! matches {\n-    ($expression:expr, $( $pattern:pat )|+ $( if $guard: expr )? $(,)?) => {\n+    ($expression:expr, $( $pattern:pat_param )|+ $( if $guard: expr )? $(,)?) => {\n         match $expression {\n             $( $pattern )|+ $( if $guard )? => true,\n             _ => false"}, {"sha": "77132cddca272c2bdefa606776e89789ceedef4c", "filename": "library/core/src/num/f32.rs", "status": "modified", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/f6a28aa4036415d8aa713bf707842779b709935e/library%2Fcore%2Fsrc%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6a28aa4036415d8aa713bf707842779b709935e/library%2Fcore%2Fsrc%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Ff32.rs?ref=f6a28aa4036415d8aa713bf707842779b709935e", "patch": "@@ -854,35 +854,6 @@ impl f32 {\n         self.to_bits().to_ne_bytes()\n     }\n \n-    /// Return the memory representation of this floating point number as a byte array in\n-    /// native byte order.\n-    ///\n-    /// [`to_ne_bytes`] should be preferred over this whenever possible.\n-    ///\n-    /// [`to_ne_bytes`]: f32::to_ne_bytes\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(num_as_ne_bytes)]\n-    /// let num = 12.5f32;\n-    /// let bytes = num.as_ne_bytes();\n-    /// assert_eq!(\n-    ///     bytes,\n-    ///     if cfg!(target_endian = \"big\") {\n-    ///         &[0x41, 0x48, 0x00, 0x00]\n-    ///     } else {\n-    ///         &[0x00, 0x00, 0x48, 0x41]\n-    ///     }\n-    /// );\n-    /// ```\n-    #[unstable(feature = \"num_as_ne_bytes\", issue = \"76976\")]\n-    #[inline]\n-    pub fn as_ne_bytes(&self) -> &[u8; 4] {\n-        // SAFETY: `f32` is a plain old datatype so we can always transmute to it\n-        unsafe { &*(self as *const Self as *const _) }\n-    }\n-\n     /// Create a floating point value from its representation as a byte array in big endian.\n     ///\n     /// # Examples"}, {"sha": "4c3f1fd16a0db51f615db89a57cfc0b5cb045c58", "filename": "library/core/src/num/f64.rs", "status": "modified", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/f6a28aa4036415d8aa713bf707842779b709935e/library%2Fcore%2Fsrc%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6a28aa4036415d8aa713bf707842779b709935e/library%2Fcore%2Fsrc%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Ff64.rs?ref=f6a28aa4036415d8aa713bf707842779b709935e", "patch": "@@ -868,35 +868,6 @@ impl f64 {\n         self.to_bits().to_ne_bytes()\n     }\n \n-    /// Return the memory representation of this floating point number as a byte array in\n-    /// native byte order.\n-    ///\n-    /// [`to_ne_bytes`] should be preferred over this whenever possible.\n-    ///\n-    /// [`to_ne_bytes`]: f64::to_ne_bytes\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// #![feature(num_as_ne_bytes)]\n-    /// let num = 12.5f64;\n-    /// let bytes = num.as_ne_bytes();\n-    /// assert_eq!(\n-    ///     bytes,\n-    ///     if cfg!(target_endian = \"big\") {\n-    ///         &[0x40, 0x29, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]\n-    ///     } else {\n-    ///         &[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x29, 0x40]\n-    ///     }\n-    /// );\n-    /// ```\n-    #[unstable(feature = \"num_as_ne_bytes\", issue = \"76976\")]\n-    #[inline]\n-    pub fn as_ne_bytes(&self) -> &[u8; 8] {\n-        // SAFETY: `f64` is a plain old datatype so we can always transmute to it\n-        unsafe { &*(self as *const Self as *const _) }\n-    }\n-\n     /// Create a floating point value from its representation as a byte array in big endian.\n     ///\n     /// # Examples"}, {"sha": "4af86ed98f26f0a80ee49783d460a7605abbe2bc", "filename": "library/core/src/num/int_macros.rs", "status": "modified", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f6a28aa4036415d8aa713bf707842779b709935e/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6a28aa4036415d8aa713bf707842779b709935e/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs?ref=f6a28aa4036415d8aa713bf707842779b709935e", "patch": "@@ -1842,36 +1842,6 @@ macro_rules! int_impl {\n             unsafe { mem::transmute(self) }\n         }\n \n-        /// Return the memory representation of this integer as a byte array in\n-        /// native byte order.\n-        ///\n-        /// [`to_ne_bytes`] should be preferred over this whenever possible.\n-        ///\n-        /// [`to_ne_bytes`]: Self::to_ne_bytes\n-        ///\n-        /// # Examples\n-        ///\n-        /// ```\n-        /// #![feature(num_as_ne_bytes)]\n-        #[doc = concat!(\"let num = \", $swap_op, stringify!($SelfT), \";\")]\n-        /// let bytes = num.as_ne_bytes();\n-        /// assert_eq!(\n-        ///     bytes,\n-        ///     if cfg!(target_endian = \"big\") {\n-        #[doc = concat!(\"        &\", $be_bytes)]\n-        ///     } else {\n-        #[doc = concat!(\"        &\", $le_bytes)]\n-        ///     }\n-        /// );\n-        /// ```\n-        #[unstable(feature = \"num_as_ne_bytes\", issue = \"76976\")]\n-        #[inline]\n-        pub fn as_ne_bytes(&self) -> &[u8; mem::size_of::<Self>()] {\n-            // SAFETY: integers are plain old datatypes so we can always transmute them to\n-            // arrays of bytes\n-            unsafe { &*(self as *const Self as *const _) }\n-        }\n-\n         /// Create an integer value from its representation as a byte array in\n         /// big endian.\n         ///"}, {"sha": "a525e02d5e1849f8b39238fd8ead2a26f48627f3", "filename": "library/core/src/num/uint_macros.rs", "status": "modified", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/f6a28aa4036415d8aa713bf707842779b709935e/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6a28aa4036415d8aa713bf707842779b709935e/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs?ref=f6a28aa4036415d8aa713bf707842779b709935e", "patch": "@@ -1672,36 +1672,6 @@ macro_rules! uint_impl {\n             unsafe { mem::transmute(self) }\n         }\n \n-        /// Return the memory representation of this integer as a byte array in\n-        /// native byte order.\n-        ///\n-        /// [`to_ne_bytes`] should be preferred over this whenever possible.\n-        ///\n-        /// [`to_ne_bytes`]: Self::to_ne_bytes\n-        ///\n-        /// # Examples\n-        ///\n-        /// ```\n-        /// #![feature(num_as_ne_bytes)]\n-        #[doc = concat!(\"let num = \", $swap_op, stringify!($SelfT), \";\")]\n-        /// let bytes = num.as_ne_bytes();\n-        /// assert_eq!(\n-        ///     bytes,\n-        ///     if cfg!(target_endian = \"big\") {\n-        #[doc = concat!(\"        &\", $be_bytes)]\n-        ///     } else {\n-        #[doc = concat!(\"        &\", $le_bytes)]\n-        ///     }\n-        /// );\n-        /// ```\n-        #[unstable(feature = \"num_as_ne_bytes\", issue = \"76976\")]\n-        #[inline]\n-        pub fn as_ne_bytes(&self) -> &[u8; mem::size_of::<Self>()] {\n-            // SAFETY: integers are plain old datatypes so we can always transmute them to\n-            // arrays of bytes\n-            unsafe { &*(self as *const Self as *const _) }\n-        }\n-\n         /// Create a native endian integer value from its representation\n         /// as a byte array in big endian.\n         ///"}, {"sha": "bdeaa0cd3606281e3e6b32e0ed5aed838d2e7609", "filename": "src/test/ui/consts/const-eval/auxiliary/post_monomorphization_error.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f6a28aa4036415d8aa713bf707842779b709935e/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fauxiliary%2Fpost_monomorphization_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6a28aa4036415d8aa713bf707842779b709935e/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fauxiliary%2Fpost_monomorphization_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fauxiliary%2Fpost_monomorphization_error.rs?ref=f6a28aa4036415d8aa713bf707842779b709935e", "patch": "@@ -0,0 +1,20 @@\n+// Auxiliary crate used for testing post-monomorphization errors cross-crate.\n+// It duplicates the setup used in `stdarch` to validate its intrinsics' const arguments.\n+\n+struct ValidateConstImm<const IMM: i32, const MIN: i32, const MAX: i32>;\n+impl<const IMM: i32, const MIN: i32, const MAX: i32> ValidateConstImm<IMM, MIN, MAX> {\n+    pub(crate) const VALID: () = {\n+        let _ = 1 / ((IMM >= MIN && IMM <= MAX) as usize);\n+    };\n+}\n+\n+macro_rules! static_assert_imm1 {\n+    ($imm:ident) => {\n+        let _ = $crate::ValidateConstImm::<$imm, 0, { (1 << 1) - 1 }>::VALID;\n+    };\n+}\n+\n+// This function triggers an error whenever the const argument does not fit in 1-bit.\n+pub fn stdarch_intrinsic<const IMM1: i32>() {\n+    static_assert_imm1!(IMM1);\n+}"}, {"sha": "c3216d53d055406260e338b9e66d69fb4733c430", "filename": "src/test/ui/consts/const-eval/issue-85155.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/f6a28aa4036415d8aa713bf707842779b709935e/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-85155.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6a28aa4036415d8aa713bf707842779b709935e/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-85155.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-85155.rs?ref=f6a28aa4036415d8aa713bf707842779b709935e", "patch": "@@ -0,0 +1,21 @@\n+// This is a test with a setup similar to issue 85155, which triggers a const eval error: a const\n+// argument value is outside the range expected by the `stdarch` intrinsic.\n+//\n+// It's not the exact code mentioned in that issue because it depends both on `stdarch` intrinsics\n+// only available on x64, and internal implementation details of `stdarch`. But mostly because these\n+// are not important to trigger the diagnostics issue: it's specifically about the lack of context\n+// in the diagnostics of post-monomorphization errors (PMEs) for consts, happening in a dependency.\n+// Therefore, its setup is reproduced with an aux crate, which will similarly trigger a PME\n+// depending on the const argument value, like the `stdarch` intrinsics would.\n+//\n+// aux-build: post_monomorphization_error.rs\n+// build-fail: this is a post-monomorphization error, it passes check runs and requires building\n+//             to actually fail.\n+\n+extern crate post_monomorphization_error;\n+\n+fn main() {\n+    // This function triggers a PME whenever the const argument does not fit in 1-bit.\n+    post_monomorphization_error::stdarch_intrinsic::<2>();\n+    //~^ NOTE the above error was encountered while instantiating\n+}"}, {"sha": "0a1edfb8a33568c7470f10290350f2418ac5216f", "filename": "src/test/ui/consts/const-eval/issue-85155.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/f6a28aa4036415d8aa713bf707842779b709935e/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-85155.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f6a28aa4036415d8aa713bf707842779b709935e/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-85155.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-85155.stderr?ref=f6a28aa4036415d8aa713bf707842779b709935e", "patch": "@@ -0,0 +1,15 @@\n+error[E0080]: evaluation of constant value failed\n+  --> $DIR/auxiliary/post_monomorphization_error.rs:7:17\n+   |\n+LL |         let _ = 1 / ((IMM >= MIN && IMM <= MAX) as usize);\n+   |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ attempt to divide `1_usize` by zero\n+\n+note: the above error was encountered while instantiating `fn stdarch_intrinsic::<2_i32>`\n+  --> $DIR/issue-85155.rs:19:5\n+   |\n+LL |     post_monomorphization_error::stdarch_intrinsic::<2>();\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0080`."}, {"sha": "1090b1578ba511b6e8a6e2dad8810c73d559d24c", "filename": "src/test/ui/matches2021.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f6a28aa4036415d8aa713bf707842779b709935e/src%2Ftest%2Fui%2Fmatches2021.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6a28aa4036415d8aa713bf707842779b709935e/src%2Ftest%2Fui%2Fmatches2021.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmatches2021.rs?ref=f6a28aa4036415d8aa713bf707842779b709935e", "patch": "@@ -0,0 +1,12 @@\n+// run-pass\n+// edition:2021\n+// compile-flags: -Zunstable-options\n+\n+// regression test for https://github.com/rust-lang/rust/pull/85678\n+\n+#![feature(assert_matches)]\n+\n+fn main() {\n+    assert!(matches!((), ()));\n+    assert_matches!((), ());\n+}"}, {"sha": "3a33c1934084185e9976a8c9cbb3a3105a3253a9", "filename": "src/test/ui/resolve/issue-85348.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f6a28aa4036415d8aa713bf707842779b709935e/src%2Ftest%2Fui%2Fresolve%2Fissue-85348.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6a28aa4036415d8aa713bf707842779b709935e/src%2Ftest%2Fui%2Fresolve%2Fissue-85348.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-85348.rs?ref=f6a28aa4036415d8aa713bf707842779b709935e", "patch": "@@ -0,0 +1,12 @@\n+// Checks whether shadowing a const parameter leads to an ICE (#85348).\n+\n+impl<const N: usize> ArrayWindowsExample {\n+//~^ ERROR: cannot find type `ArrayWindowsExample` in this scope [E0412]\n+    fn next() {\n+        let mut N;\n+        //~^ ERROR: let bindings cannot shadow const parameters [E0530]\n+        //~| ERROR: type annotations needed [E0282]\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "f475c26f32b8fec5f7f6e893c242684d528e4107", "filename": "src/test/ui/resolve/issue-85348.stderr", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/f6a28aa4036415d8aa713bf707842779b709935e/src%2Ftest%2Fui%2Fresolve%2Fissue-85348.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f6a28aa4036415d8aa713bf707842779b709935e/src%2Ftest%2Fui%2Fresolve%2Fissue-85348.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-85348.stderr?ref=f6a28aa4036415d8aa713bf707842779b709935e", "patch": "@@ -0,0 +1,25 @@\n+error[E0530]: let bindings cannot shadow const parameters\n+  --> $DIR/issue-85348.rs:6:17\n+   |\n+LL | impl<const N: usize> ArrayWindowsExample {\n+   |            - the const parameter `N` is defined here\n+...\n+LL |         let mut N;\n+   |                 ^ cannot be named the same as a const parameter\n+\n+error[E0412]: cannot find type `ArrayWindowsExample` in this scope\n+  --> $DIR/issue-85348.rs:3:22\n+   |\n+LL | impl<const N: usize> ArrayWindowsExample {\n+   |                      ^^^^^^^^^^^^^^^^^^^ not found in this scope\n+\n+error[E0282]: type annotations needed\n+  --> $DIR/issue-85348.rs:6:13\n+   |\n+LL |         let mut N;\n+   |             ^^^^^ consider giving `N` a type\n+\n+error: aborting due to 3 previous errors\n+\n+Some errors have detailed explanations: E0282, E0412, E0530.\n+For more information about an error, try `rustc --explain E0282`."}, {"sha": "c435c16dc67885dcc4890a78c24e6d6009f499ef", "filename": "src/test/ui/resolve/shadow-const-param.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f6a28aa4036415d8aa713bf707842779b709935e/src%2Ftest%2Fui%2Fresolve%2Fshadow-const-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6a28aa4036415d8aa713bf707842779b709935e/src%2Ftest%2Fui%2Fresolve%2Fshadow-const-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fshadow-const-param.rs?ref=f6a28aa4036415d8aa713bf707842779b709935e", "patch": "@@ -0,0 +1,20 @@\n+// Checks that const parameters cannot be shadowed with fresh bindings\n+// even in syntactically unambiguous contexts. See\n+// https://github.com/rust-lang/rust/issues/33118#issuecomment-233962221\n+\n+fn foo<const N: i32>(i: i32) -> bool {\n+    match i {\n+        N @ _ => true,\n+        //~^ ERROR: match bindings cannot shadow const parameters [E0530]\n+    }\n+}\n+\n+fn bar<const N: i32>(i: i32) -> bool {\n+    let N @ _ = 0;\n+    //~^ ERROR: let bindings cannot shadow const parameters [E0530]\n+    match i {\n+        N @ _ => true,\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "fbd0d811000822d9d5146fdbeea112dd85c72ee9", "filename": "src/test/ui/resolve/shadow-const-param.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/f6a28aa4036415d8aa713bf707842779b709935e/src%2Ftest%2Fui%2Fresolve%2Fshadow-const-param.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f6a28aa4036415d8aa713bf707842779b709935e/src%2Ftest%2Fui%2Fresolve%2Fshadow-const-param.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fshadow-const-param.stderr?ref=f6a28aa4036415d8aa713bf707842779b709935e", "patch": "@@ -0,0 +1,20 @@\n+error[E0530]: match bindings cannot shadow const parameters\n+  --> $DIR/shadow-const-param.rs:7:9\n+   |\n+LL | fn foo<const N: i32>(i: i32) -> bool {\n+   |              - the const parameter `N` is defined here\n+LL |     match i {\n+LL |         N @ _ => true,\n+   |         ^ cannot be named the same as a const parameter\n+\n+error[E0530]: let bindings cannot shadow const parameters\n+  --> $DIR/shadow-const-param.rs:13:9\n+   |\n+LL | fn bar<const N: i32>(i: i32) -> bool {\n+   |              - the const parameter `N` is defined here\n+LL |     let N @ _ = 0;\n+   |         ^ cannot be named the same as a const parameter\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0530`."}, {"sha": "9a522fac65fad7d4681411200a99f539fc3091dc", "filename": "src/test/ui/unsafe/rfc-2585-unsafe_op_in_unsafe_fn.mir.stderr", "status": "renamed", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/f6a28aa4036415d8aa713bf707842779b709935e/src%2Ftest%2Fui%2Funsafe%2Frfc-2585-unsafe_op_in_unsafe_fn.mir.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f6a28aa4036415d8aa713bf707842779b709935e/src%2Ftest%2Fui%2Funsafe%2Frfc-2585-unsafe_op_in_unsafe_fn.mir.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsafe%2Frfc-2585-unsafe_op_in_unsafe_fn.mir.stderr?ref=f6a28aa4036415d8aa713bf707842779b709935e", "patch": "@@ -1,90 +1,90 @@\n error: call to unsafe function is unsafe and requires unsafe block (error E0133)\n-  --> $DIR/rfc-2585-unsafe_op_in_unsafe_fn.rs:9:5\n+  --> $DIR/rfc-2585-unsafe_op_in_unsafe_fn.rs:12:5\n    |\n LL |     unsf();\n    |     ^^^^^^ call to unsafe function\n    |\n note: the lint level is defined here\n-  --> $DIR/rfc-2585-unsafe_op_in_unsafe_fn.rs:1:9\n+  --> $DIR/rfc-2585-unsafe_op_in_unsafe_fn.rs:4:9\n    |\n LL | #![deny(unsafe_op_in_unsafe_fn)]\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n    = note: consult the function's documentation for information on how to avoid undefined behavior\n \n error: dereference of raw pointer is unsafe and requires unsafe block (error E0133)\n-  --> $DIR/rfc-2585-unsafe_op_in_unsafe_fn.rs:11:5\n+  --> $DIR/rfc-2585-unsafe_op_in_unsafe_fn.rs:14:5\n    |\n LL |     *PTR;\n    |     ^^^^ dereference of raw pointer\n    |\n    = note: raw pointers may be null, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior\n \n error: use of mutable static is unsafe and requires unsafe block (error E0133)\n-  --> $DIR/rfc-2585-unsafe_op_in_unsafe_fn.rs:13:5\n+  --> $DIR/rfc-2585-unsafe_op_in_unsafe_fn.rs:16:5\n    |\n LL |     VOID = ();\n    |     ^^^^^^^^^ use of mutable static\n    |\n    = note: mutable statics can be mutated by multiple threads: aliasing violations or data races will cause undefined behavior\n \n error: unnecessary `unsafe` block\n-  --> $DIR/rfc-2585-unsafe_op_in_unsafe_fn.rs:16:5\n+  --> $DIR/rfc-2585-unsafe_op_in_unsafe_fn.rs:19:5\n    |\n LL |     unsafe {}\n    |     ^^^^^^ unnecessary `unsafe` block\n    |\n note: the lint level is defined here\n-  --> $DIR/rfc-2585-unsafe_op_in_unsafe_fn.rs:2:9\n+  --> $DIR/rfc-2585-unsafe_op_in_unsafe_fn.rs:5:9\n    |\n LL | #![deny(unused_unsafe)]\n    |         ^^^^^^^^^^^^^\n \n error: call to unsafe function is unsafe and requires unsafe block (error E0133)\n-  --> $DIR/rfc-2585-unsafe_op_in_unsafe_fn.rs:24:5\n+  --> $DIR/rfc-2585-unsafe_op_in_unsafe_fn.rs:27:5\n    |\n LL |     unsf();\n    |     ^^^^^^ call to unsafe function\n    |\n note: the lint level is defined here\n-  --> $DIR/rfc-2585-unsafe_op_in_unsafe_fn.rs:22:8\n+  --> $DIR/rfc-2585-unsafe_op_in_unsafe_fn.rs:25:8\n    |\n LL | #[deny(warnings)]\n    |        ^^^^^^^^\n    = note: `#[deny(unsafe_op_in_unsafe_fn)]` implied by `#[deny(warnings)]`\n    = note: consult the function's documentation for information on how to avoid undefined behavior\n \n error: dereference of raw pointer is unsafe and requires unsafe block (error E0133)\n-  --> $DIR/rfc-2585-unsafe_op_in_unsafe_fn.rs:26:5\n+  --> $DIR/rfc-2585-unsafe_op_in_unsafe_fn.rs:29:5\n    |\n LL |     *PTR;\n    |     ^^^^ dereference of raw pointer\n    |\n    = note: raw pointers may be null, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior\n \n error: use of mutable static is unsafe and requires unsafe block (error E0133)\n-  --> $DIR/rfc-2585-unsafe_op_in_unsafe_fn.rs:28:5\n+  --> $DIR/rfc-2585-unsafe_op_in_unsafe_fn.rs:31:5\n    |\n LL |     VOID = ();\n    |     ^^^^^^^^^ use of mutable static\n    |\n    = note: mutable statics can be mutated by multiple threads: aliasing violations or data races will cause undefined behavior\n \n error: unnecessary `unsafe` block\n-  --> $DIR/rfc-2585-unsafe_op_in_unsafe_fn.rs:30:5\n+  --> $DIR/rfc-2585-unsafe_op_in_unsafe_fn.rs:33:5\n    |\n LL |     unsafe {}\n    |     ^^^^^^ unnecessary `unsafe` block\n \n error: unnecessary `unsafe` block\n-  --> $DIR/rfc-2585-unsafe_op_in_unsafe_fn.rs:44:14\n+  --> $DIR/rfc-2585-unsafe_op_in_unsafe_fn.rs:47:14\n    |\n LL |     unsafe { unsafe { unsf() } }\n    |     ------   ^^^^^^ unnecessary `unsafe` block\n    |     |\n    |     because it's nested under this `unsafe` block\n \n error: unnecessary `unsafe` block\n-  --> $DIR/rfc-2585-unsafe_op_in_unsafe_fn.rs:55:5\n+  --> $DIR/rfc-2585-unsafe_op_in_unsafe_fn.rs:58:5\n    |\n LL | unsafe fn allow_level() {\n    | ----------------------- because it's nested under this `unsafe` fn\n@@ -93,7 +93,7 @@ LL |     unsafe { unsf() }\n    |     ^^^^^^ unnecessary `unsafe` block\n \n error: unnecessary `unsafe` block\n-  --> $DIR/rfc-2585-unsafe_op_in_unsafe_fn.rs:67:9\n+  --> $DIR/rfc-2585-unsafe_op_in_unsafe_fn.rs:70:9\n    |\n LL | unsafe fn nested_allow_level() {\n    | ------------------------------ because it's nested under this `unsafe` fn\n@@ -102,15 +102,15 @@ LL |         unsafe { unsf() }\n    |         ^^^^^^ unnecessary `unsafe` block\n \n error[E0133]: call to unsafe function is unsafe and requires unsafe block\n-  --> $DIR/rfc-2585-unsafe_op_in_unsafe_fn.rs:73:5\n+  --> $DIR/rfc-2585-unsafe_op_in_unsafe_fn.rs:76:5\n    |\n LL |     unsf();\n    |     ^^^^^^ call to unsafe function\n    |\n    = note: consult the function's documentation for information on how to avoid undefined behavior\n \n error[E0133]: call to unsafe function is unsafe and requires unsafe function or block\n-  --> $DIR/rfc-2585-unsafe_op_in_unsafe_fn.rs:77:9\n+  --> $DIR/rfc-2585-unsafe_op_in_unsafe_fn.rs:80:9\n    |\n LL |         unsf();\n    |         ^^^^^^ call to unsafe function", "previous_filename": "src/test/ui/unsafe/rfc-2585-unsafe_op_in_unsafe_fn.stderr"}, {"sha": "7ca714b85c216a940a79733a24c4229792ce3705", "filename": "src/test/ui/unsafe/rfc-2585-unsafe_op_in_unsafe_fn.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/f6a28aa4036415d8aa713bf707842779b709935e/src%2Ftest%2Fui%2Funsafe%2Frfc-2585-unsafe_op_in_unsafe_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f6a28aa4036415d8aa713bf707842779b709935e/src%2Ftest%2Fui%2Funsafe%2Frfc-2585-unsafe_op_in_unsafe_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsafe%2Frfc-2585-unsafe_op_in_unsafe_fn.rs?ref=f6a28aa4036415d8aa713bf707842779b709935e", "patch": "@@ -1,3 +1,6 @@\n+// revisions: mir thir\n+// [thir]compile-flags: -Zthir-unsafeck\n+\n #![deny(unsafe_op_in_unsafe_fn)]\n #![deny(unused_unsafe)]\n "}, {"sha": "ad87690bb52f04869ef5792a29286931ebdafb8e", "filename": "src/test/ui/unsafe/rfc-2585-unsafe_op_in_unsafe_fn.thir.stderr", "status": "added", "additions": 122, "deletions": 0, "changes": 122, "blob_url": "https://github.com/rust-lang/rust/blob/f6a28aa4036415d8aa713bf707842779b709935e/src%2Ftest%2Fui%2Funsafe%2Frfc-2585-unsafe_op_in_unsafe_fn.thir.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/f6a28aa4036415d8aa713bf707842779b709935e/src%2Ftest%2Fui%2Funsafe%2Frfc-2585-unsafe_op_in_unsafe_fn.thir.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsafe%2Frfc-2585-unsafe_op_in_unsafe_fn.thir.stderr?ref=f6a28aa4036415d8aa713bf707842779b709935e", "patch": "@@ -0,0 +1,122 @@\n+error: call to unsafe function is unsafe and requires unsafe block (error E0133)\n+  --> $DIR/rfc-2585-unsafe_op_in_unsafe_fn.rs:12:5\n+   |\n+LL |     unsf();\n+   |     ^^^^^^ call to unsafe function\n+   |\n+note: the lint level is defined here\n+  --> $DIR/rfc-2585-unsafe_op_in_unsafe_fn.rs:4:9\n+   |\n+LL | #![deny(unsafe_op_in_unsafe_fn)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^\n+   = note: consult the function's documentation for information on how to avoid undefined behavior\n+\n+error: dereference of raw pointer is unsafe and requires unsafe block (error E0133)\n+  --> $DIR/rfc-2585-unsafe_op_in_unsafe_fn.rs:14:5\n+   |\n+LL |     *PTR;\n+   |     ^^^^ dereference of raw pointer\n+   |\n+   = note: raw pointers may be null, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior\n+\n+error: use of mutable static is unsafe and requires unsafe block (error E0133)\n+  --> $DIR/rfc-2585-unsafe_op_in_unsafe_fn.rs:16:5\n+   |\n+LL |     VOID = ();\n+   |     ^^^^ use of mutable static\n+   |\n+   = note: mutable statics can be mutated by multiple threads: aliasing violations or data races will cause undefined behavior\n+\n+error: unnecessary `unsafe` block\n+  --> $DIR/rfc-2585-unsafe_op_in_unsafe_fn.rs:19:5\n+   |\n+LL |     unsafe {}\n+   |     ^^^^^^ unnecessary `unsafe` block\n+   |\n+note: the lint level is defined here\n+  --> $DIR/rfc-2585-unsafe_op_in_unsafe_fn.rs:5:9\n+   |\n+LL | #![deny(unused_unsafe)]\n+   |         ^^^^^^^^^^^^^\n+\n+error: call to unsafe function is unsafe and requires unsafe block (error E0133)\n+  --> $DIR/rfc-2585-unsafe_op_in_unsafe_fn.rs:27:5\n+   |\n+LL |     unsf();\n+   |     ^^^^^^ call to unsafe function\n+   |\n+note: the lint level is defined here\n+  --> $DIR/rfc-2585-unsafe_op_in_unsafe_fn.rs:25:8\n+   |\n+LL | #[deny(warnings)]\n+   |        ^^^^^^^^\n+   = note: `#[deny(unsafe_op_in_unsafe_fn)]` implied by `#[deny(warnings)]`\n+   = note: consult the function's documentation for information on how to avoid undefined behavior\n+\n+error: dereference of raw pointer is unsafe and requires unsafe block (error E0133)\n+  --> $DIR/rfc-2585-unsafe_op_in_unsafe_fn.rs:29:5\n+   |\n+LL |     *PTR;\n+   |     ^^^^ dereference of raw pointer\n+   |\n+   = note: raw pointers may be null, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior\n+\n+error: use of mutable static is unsafe and requires unsafe block (error E0133)\n+  --> $DIR/rfc-2585-unsafe_op_in_unsafe_fn.rs:31:5\n+   |\n+LL |     VOID = ();\n+   |     ^^^^ use of mutable static\n+   |\n+   = note: mutable statics can be mutated by multiple threads: aliasing violations or data races will cause undefined behavior\n+\n+error: unnecessary `unsafe` block\n+  --> $DIR/rfc-2585-unsafe_op_in_unsafe_fn.rs:33:5\n+   |\n+LL |     unsafe {}\n+   |     ^^^^^^ unnecessary `unsafe` block\n+\n+error: unnecessary `unsafe` block\n+  --> $DIR/rfc-2585-unsafe_op_in_unsafe_fn.rs:47:14\n+   |\n+LL |     unsafe { unsafe { unsf() } }\n+   |     ------   ^^^^^^ unnecessary `unsafe` block\n+   |     |\n+   |     because it's nested under this `unsafe` block\n+\n+error: unnecessary `unsafe` block\n+  --> $DIR/rfc-2585-unsafe_op_in_unsafe_fn.rs:58:5\n+   |\n+LL | unsafe fn allow_level() {\n+   | ----------------------- because it's nested under this `unsafe` fn\n+...\n+LL |     unsafe { unsf() }\n+   |     ^^^^^^ unnecessary `unsafe` block\n+\n+error: unnecessary `unsafe` block\n+  --> $DIR/rfc-2585-unsafe_op_in_unsafe_fn.rs:70:9\n+   |\n+LL | unsafe fn nested_allow_level() {\n+   | ------------------------------ because it's nested under this `unsafe` fn\n+...\n+LL |         unsafe { unsf() }\n+   |         ^^^^^^ unnecessary `unsafe` block\n+\n+error[E0133]: call to unsafe function is unsafe and requires unsafe block\n+  --> $DIR/rfc-2585-unsafe_op_in_unsafe_fn.rs:76:5\n+   |\n+LL |     unsf();\n+   |     ^^^^^^ call to unsafe function\n+   |\n+   = note: consult the function's documentation for information on how to avoid undefined behavior\n+\n+error[E0133]: call to unsafe function is unsafe and requires unsafe function or block\n+  --> $DIR/rfc-2585-unsafe_op_in_unsafe_fn.rs:80:9\n+   |\n+LL |         unsf();\n+   |         ^^^^^^ call to unsafe function\n+   |\n+   = note: consult the function's documentation for information on how to avoid undefined behavior\n+\n+error: aborting due to 13 previous errors\n+\n+For more information about this error, try `rustc --explain E0133`."}]}