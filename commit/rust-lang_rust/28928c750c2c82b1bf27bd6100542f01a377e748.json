{"sha": "28928c750c2c82b1bf27bd6100542f01a377e748", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI4OTI4Yzc1MGMyYzgyYjFiZjI3YmQ2MTAwNTQyZjAxYTM3N2U3NDg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-07T17:31:56Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-10-07T17:31:56Z"}, "message": "Auto merge of #77617 - AnthonyMikh:slice_windows_no_bounds_checking, r=lcnr\n\nEliminate bounds checking in slice::Windows\n\nThis is how `<core::slice::Windows as Iterator>::next` looks right now:\n\n```rust\nfn next(&mut self) -> Option<&'a [T]> {\n    if self.size > self.v.len() {\n        None\n    } else {\n        let ret = Some(&self.v[..self.size]);\n        self.v = &self.v[1..];\n        ret\n    }\n}\n```\n\nThe line with `self.v = &self.v[1..];` relies on assumption that `self.v` is definitely not empty at this point. Else branch is taken when `self.size <= self.v.len()`, so `self.v` can be empty if `self.size` is zero. In practice, since `Windows` is never created directly but rather trough `[T]::windows` which panics when `size` is zero, `self.size` is never zero. However, the compiler doesn't know about this check, so it keeps the code which checks bounds and panics.\n\nUsing `NonZeroUsize` lets the compiler know about this invariant and reliably eliminate bounds checking without `unsafe` on `-O2`. Here is assembly of `Windows<'a, u32>::next` before and after this change ([goldbolt](https://godbolt.org/z/xrefzx)):\n\n<details>\n<summary>Before</summary>\n\n```\nexample::next:\n        push    rax\n        mov     rcx, qword ptr [rdi + 8]\n        mov     rdx, qword ptr [rdi + 16]\n        cmp     rdx, rcx\n        jbe     .LBB0_2\n        xor     eax, eax\n        pop     rcx\n        ret\n.LBB0_2:\n        test    rcx, rcx\n        je      .LBB0_5\n        mov     rax, qword ptr [rdi]\n        mov     rsi, rax\n        add     rsi, 4\n        add     rcx, -1\n        mov     qword ptr [rdi], rsi\n        mov     qword ptr [rdi + 8], rcx\n        pop     rcx\n        ret\n.LBB0_5:\n        lea     rdx, [rip + .L__unnamed_1]\n        mov     edi, 1\n        xor     esi, esi\n        call    qword ptr [rip + core::slice::slice_index_order_fail@GOTPCREL]\n        ud2\n\n.L__unnamed_2:\n        .ascii  \"./example.rs\"\n\n.L__unnamed_1:\n        .quad   .L__unnamed_2\n        .asciz  \"\\f\\000\\000\\000\\000\\000\\000\\000\\016\\000\\000\\000\\027\\000\\000\"\n```\n\n</details>\n\n<details>\n<summary>After</summary>\n\n```\nexample::next:\n        mov     rcx, qword ptr [rdi + 8]\n        mov     rdx, qword ptr [rdi + 16]\n        cmp     rdx, rcx\n        jbe     .LBB0_2\n        xor     eax, eax\n        ret\n.LBB0_2:\n        mov     rax, qword ptr [rdi]\n        lea     rsi, [rax + 4]\n        add     rcx, -1\n        mov     qword ptr [rdi], rsi\n        mov     qword ptr [rdi + 8], rcx\n        ret\n```\n\n</details>\n\nNote the lack of call to `core::slice::slice_index_order_fail` in second snippet.\n\n#### Possible reasons _not_ to merge this PR:\n\n* this changes the error message on panic in `[T]::windows`. However, AFAIK this messages are not covered by backwards compatibility policy.", "tree": {"sha": "cf8aafa39a366cfc81a329ef864072cdb254e53a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cf8aafa39a366cfc81a329ef864072cdb254e53a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/28928c750c2c82b1bf27bd6100542f01a377e748", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/28928c750c2c82b1bf27bd6100542f01a377e748", "html_url": "https://github.com/rust-lang/rust/commit/28928c750c2c82b1bf27bd6100542f01a377e748", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/28928c750c2c82b1bf27bd6100542f01a377e748/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "deec53052312ac709f6a37110b59ada486bea0bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/deec53052312ac709f6a37110b59ada486bea0bd", "html_url": "https://github.com/rust-lang/rust/commit/deec53052312ac709f6a37110b59ada486bea0bd"}, {"sha": "e699e83758a9695081964a6f0bed7b4482b8e22d", "url": "https://api.github.com/repos/rust-lang/rust/commits/e699e83758a9695081964a6f0bed7b4482b8e22d", "html_url": "https://github.com/rust-lang/rust/commit/e699e83758a9695081964a6f0bed7b4482b8e22d"}], "stats": {"total": 67, "additions": 52, "deletions": 15}, "files": [{"sha": "24f955a70b67e14094e5dc4799c8cb6b669b4a6a", "filename": "library/core/src/slice/iter.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/28928c750c2c82b1bf27bd6100542f01a377e748/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28928c750c2c82b1bf27bd6100542f01a377e748/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs?ref=28928c750c2c82b1bf27bd6100542f01a377e748", "patch": "@@ -10,6 +10,7 @@ use crate::intrinsics::{assume, exact_div, unchecked_sub};\n use crate::iter::{FusedIterator, TrustedLen, TrustedRandomAccess};\n use crate::marker::{PhantomData, Send, Sized, Sync};\n use crate::mem;\n+use crate::num::NonZeroUsize;\n use crate::ptr::NonNull;\n \n use super::{from_raw_parts, from_raw_parts_mut};\n@@ -1187,12 +1188,12 @@ forward_iterator! { RSplitNMut: T, &'a mut [T] }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Windows<'a, T: 'a> {\n     v: &'a [T],\n-    size: usize,\n+    size: NonZeroUsize,\n }\n \n impl<'a, T: 'a> Windows<'a, T> {\n     #[inline]\n-    pub(super) fn new(slice: &'a [T], size: usize) -> Self {\n+    pub(super) fn new(slice: &'a [T], size: NonZeroUsize) -> Self {\n         Self { v: slice, size }\n     }\n }\n@@ -1211,21 +1212,21 @@ impl<'a, T> Iterator for Windows<'a, T> {\n \n     #[inline]\n     fn next(&mut self) -> Option<&'a [T]> {\n-        if self.size > self.v.len() {\n+        if self.size.get() > self.v.len() {\n             None\n         } else {\n-            let ret = Some(&self.v[..self.size]);\n+            let ret = Some(&self.v[..self.size.get()]);\n             self.v = &self.v[1..];\n             ret\n         }\n     }\n \n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        if self.size > self.v.len() {\n+        if self.size.get() > self.v.len() {\n             (0, Some(0))\n         } else {\n-            let size = self.v.len() - self.size + 1;\n+            let size = self.v.len() - self.size.get() + 1;\n             (size, Some(size))\n         }\n     }\n@@ -1237,7 +1238,7 @@ impl<'a, T> Iterator for Windows<'a, T> {\n \n     #[inline]\n     fn nth(&mut self, n: usize) -> Option<Self::Item> {\n-        let (end, overflow) = self.size.overflowing_add(n);\n+        let (end, overflow) = self.size.get().overflowing_add(n);\n         if end > self.v.len() || overflow {\n             self.v = &[];\n             None\n@@ -1250,10 +1251,10 @@ impl<'a, T> Iterator for Windows<'a, T> {\n \n     #[inline]\n     fn last(self) -> Option<Self::Item> {\n-        if self.size > self.v.len() {\n+        if self.size.get() > self.v.len() {\n             None\n         } else {\n-            let start = self.v.len() - self.size;\n+            let start = self.v.len() - self.size.get();\n             Some(&self.v[start..])\n         }\n     }\n@@ -1264,18 +1265,18 @@ impl<'a, T> Iterator for Windows<'a, T> {\n         // which means that `i` cannot overflow an `isize`, and the\n         // slice created by `from_raw_parts` is a subslice of `self.v`\n         // thus is guaranteed to be valid for the lifetime `'a` of `self.v`.\n-        unsafe { from_raw_parts(self.v.as_ptr().add(idx), self.size) }\n+        unsafe { from_raw_parts(self.v.as_ptr().add(idx), self.size.get()) }\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> DoubleEndedIterator for Windows<'a, T> {\n     #[inline]\n     fn next_back(&mut self) -> Option<&'a [T]> {\n-        if self.size > self.v.len() {\n+        if self.size.get() > self.v.len() {\n             None\n         } else {\n-            let ret = Some(&self.v[self.v.len() - self.size..]);\n+            let ret = Some(&self.v[self.v.len() - self.size.get()..]);\n             self.v = &self.v[..self.v.len() - 1];\n             ret\n         }\n@@ -1284,11 +1285,11 @@ impl<'a, T> DoubleEndedIterator for Windows<'a, T> {\n     #[inline]\n     fn nth_back(&mut self, n: usize) -> Option<Self::Item> {\n         let (end, overflow) = self.v.len().overflowing_sub(n);\n-        if end < self.size || overflow {\n+        if end < self.size.get() || overflow {\n             self.v = &[];\n             None\n         } else {\n-            let ret = &self.v[end - self.size..end];\n+            let ret = &self.v[end - self.size.get()..end];\n             self.v = &self.v[..end - 1];\n             Some(ret)\n         }"}, {"sha": "73d085c3fb29910675ff831380e5c62cffe107db", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/28928c750c2c82b1bf27bd6100542f01a377e748/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28928c750c2c82b1bf27bd6100542f01a377e748/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=28928c750c2c82b1bf27bd6100542f01a377e748", "patch": "@@ -11,6 +11,7 @@\n use crate::cmp::Ordering::{self, Equal, Greater, Less};\n use crate::marker::Copy;\n use crate::mem;\n+use crate::num::NonZeroUsize;\n use crate::ops::{FnMut, Range, RangeBounds};\n use crate::option::Option;\n use crate::option::Option::{None, Some};\n@@ -751,7 +752,7 @@ impl<T> [T] {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn windows(&self, size: usize) -> Windows<'_, T> {\n-        assert_ne!(size, 0);\n+        let size = NonZeroUsize::new(size).expect(\"size is zero\");\n         Windows::new(self, size)\n     }\n "}, {"sha": "4f5f4425c271cda8d6f5642431a46913ff4156e3", "filename": "src/test/codegen/slice-windows-no-bounds-check.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/28928c750c2c82b1bf27bd6100542f01a377e748/src%2Ftest%2Fcodegen%2Fslice-windows-no-bounds-check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28928c750c2c82b1bf27bd6100542f01a377e748/src%2Ftest%2Fcodegen%2Fslice-windows-no-bounds-check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Fslice-windows-no-bounds-check.rs?ref=28928c750c2c82b1bf27bd6100542f01a377e748", "patch": "@@ -0,0 +1,35 @@\n+#![crate_type = \"lib\"]\n+\n+// compile-flags: -O\n+\n+use std::slice::Windows;\n+\n+// CHECK-LABEL: @naive_string_search\n+#[no_mangle]\n+pub fn naive_string_search(haystack: &str, needle: &str) -> Option<usize> {\n+    if needle.is_empty() {\n+        return Some(0);\n+    }\n+    // CHECK-NOT: panic\n+    // CHECK-NOT: fail\n+    haystack\n+        .as_bytes()\n+        .windows(needle.len())\n+        .position(|sub| sub == needle.as_bytes())\n+}\n+\n+// CHECK-LABEL: @next\n+#[no_mangle]\n+pub fn next<'a>(w: &mut Windows<'a, u32>) -> Option<&'a [u32]> {\n+    // CHECK-NOT: panic\n+    // CHECK-NOT: fail\n+    w.next()\n+}\n+\n+// CHECK-LABEL: @next_back\n+#[no_mangle]\n+pub fn next_back<'a>(w: &mut Windows<'a, u32>) -> Option<&'a [u32]> {\n+    // CHECK-NOT: panic\n+    // CHECK-NOT: fail\n+    w.next_back()\n+}"}]}