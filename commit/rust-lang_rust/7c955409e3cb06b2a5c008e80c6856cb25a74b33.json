{"sha": "7c955409e3cb06b2a5c008e80c6856cb25a74b33", "node_id": "MDY6Q29tbWl0NzI0NzEyOjdjOTU1NDA5ZTNjYjA2YjJhNWMwMDhlODBjNjg1NmNiMjVhNzRiMzM=", "commit": {"author": {"name": "David Wood", "email": "david@davidtw.co", "date": "2019-04-07T21:18:13Z"}, "committer": {"name": "David Wood", "email": "david@davidtw.co", "date": "2019-04-11T23:54:33Z"}, "message": "Handle edge cases.\n\nThis commit introduces more dirty span manipulation into the compiler\nin order to handle the various edge cases in moving/renaming the macro\nimport so it is at the root of the import.", "tree": {"sha": "d14c882c12f6fa5c68be7dbed99331daafd9c577", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d14c882c12f6fa5c68be7dbed99331daafd9c577"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7c955409e3cb06b2a5c008e80c6856cb25a74b33", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCgAdFiEEWwgxPGhT5b/6kagXAXYLT59T8VQFAlyv07kACgkQAXYLT59T\n8VS4BhAAwA5s2MR2tE7xPRqR3SlCEUeMJB4Mh/tdvVQ5sM+z55+uxQyuhlV7SMIr\n3D0vIkQrK2Xof8VAwL89NyuPEC79ZYG3YbHuEJjZdWky/IBdYfN4478k4CSsEMru\nl6P0lfpojcnjwScmboUEHvJlfg5zIf/2dMuRBmEZvFOmNzu7WThZHaedGsE4AGaM\nFxehvdEZZBsu6dp3mvtxeUlZ6ISxPes1iaGjJuCbJWdgLGlhtWH9hKV+rni3a/re\nGqhdxTKbivMjbF89Gf4TY3IKOEq910U78Qg/YLGQ2sDmFY8/3FHVmUrP1AlH3Sjy\n7T/9/ZqrBgxbeG1yfl5dtGTop48WE+OqlgC9irFxj363qjrLqIW2CyqHFquCFeg9\nIi8X6P++czDqWN+2yZFCXBWsYqD5l7Mo8s4dcDWmQR4xOiGtMazgUFycmCoOUXr9\n2u//zDQcin5ImdI839uK8HGxIBonDBY3NWKlVfMzHEgO4JGhc76cTpqfoFoQAjwF\nudGxDjW2AU1N016AgEZAYZeOakuJZgiWzkoyjD6/Ir90vzTusUfC6UZjxE2+jfWt\nZPJFswk1ghqoa8bH1dj94vm3IRmabUgUmPbS45qzyc52ENvMzNcbaGuv00PdVdV7\nLuU/R78+fdOcVh4P6eiwftkElAVG/fKvDE6hfwkz5IWr13ETwiM=\n=OrDX\n-----END PGP SIGNATURE-----", "payload": "tree d14c882c12f6fa5c68be7dbed99331daafd9c577\nparent d589cf911109149564c8898ad1cb1d906f91caea\nauthor David Wood <david@davidtw.co> 1554671893 +0200\ncommitter David Wood <david@davidtw.co> 1555026873 +0200\n\nHandle edge cases.\n\nThis commit introduces more dirty span manipulation into the compiler\nin order to handle the various edge cases in moving/renaming the macro\nimport so it is at the root of the import.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7c955409e3cb06b2a5c008e80c6856cb25a74b33", "html_url": "https://github.com/rust-lang/rust/commit/7c955409e3cb06b2a5c008e80c6856cb25a74b33", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7c955409e3cb06b2a5c008e80c6856cb25a74b33/comments", "author": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidtwco", "id": 1295100, "node_id": "MDQ6VXNlcjEyOTUxMDA=", "avatar_url": "https://avatars.githubusercontent.com/u/1295100?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidtwco", "html_url": "https://github.com/davidtwco", "followers_url": "https://api.github.com/users/davidtwco/followers", "following_url": "https://api.github.com/users/davidtwco/following{/other_user}", "gists_url": "https://api.github.com/users/davidtwco/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidtwco/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidtwco/subscriptions", "organizations_url": "https://api.github.com/users/davidtwco/orgs", "repos_url": "https://api.github.com/users/davidtwco/repos", "events_url": "https://api.github.com/users/davidtwco/events{/privacy}", "received_events_url": "https://api.github.com/users/davidtwco/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d589cf911109149564c8898ad1cb1d906f91caea", "url": "https://api.github.com/repos/rust-lang/rust/commits/d589cf911109149564c8898ad1cb1d906f91caea", "html_url": "https://github.com/rust-lang/rust/commit/d589cf911109149564c8898ad1cb1d906f91caea"}], "stats": {"total": 698, "additions": 625, "deletions": 73}, "files": [{"sha": "eea8cb80f69ef75dd01c9a7a0c0aee3a839057ef", "filename": "src/librustc_resolve/error_reporting.rs", "status": "modified", "additions": 225, "deletions": 5, "changes": 230, "blob_url": "https://github.com/rust-lang/rust/blob/7c955409e3cb06b2a5c008e80c6856cb25a74b33/src%2Flibrustc_resolve%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c955409e3cb06b2a5c008e80c6856cb25a74b33/src%2Flibrustc_resolve%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Ferror_reporting.rs?ref=7c955409e3cb06b2a5c008e80c6856cb25a74b33", "patch": "@@ -4,11 +4,11 @@ use errors::{Applicability, DiagnosticBuilder, DiagnosticId};\n use log::debug;\n use rustc::hir::def::{Def, CtorKind, Namespace::*};\n use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n-use rustc::session::config::nightly_options;\n+use rustc::session::{Session, config::nightly_options};\n use syntax::ast::{Expr, ExprKind, Ident};\n use syntax::ext::base::MacroKind;\n-use syntax::symbol::keywords;\n-use syntax_pos::Span;\n+use syntax::symbol::{Symbol, keywords};\n+use syntax_pos::{BytePos, Span};\n \n use crate::macros::ParentScope;\n use crate::resolve_imports::{ImportDirective, ImportDirectiveSubclass, ImportResolver};\n@@ -616,10 +616,84 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n                     format!(\"{} as {}\", source, target),\n                 _ => format!(\"{}\", ident),\n             };\n+\n+            // Assume this is the easy case of `use issue_59764::foo::makro;` and just remove\n+            // intermediate segments.\n+            let (mut span, mut correction) = (directive.span,\n+                                              format!(\"{}::{}\", module_name, import));\n+\n+            if directive.is_nested() {\n+                span = directive.use_span;\n+\n+                // Find the binding span (and any trailing commas and spaces).\n+                //   ie. `use a::b::{c, d, e};`\n+                //                      ^^^\n+                let (found_closing_brace, binding_span) = find_span_of_binding_until_next_binding(\n+                    self.resolver.session, directive.span, directive.use_span,\n+                );\n+                debug!(\"check_for_module_export_macro: found_closing_brace={:?} binding_span={:?}\",\n+                       found_closing_brace, binding_span);\n+\n+                let mut removal_span = binding_span;\n+                if found_closing_brace {\n+                    // If the binding span ended with a closing brace, as in the below example:\n+                    //   ie. `use a::b::{c, d};`\n+                    //                      ^\n+                    // Then expand the span of characters to remove to include the previous\n+                    // binding's trailing comma.\n+                    //   ie. `use a::b::{c, d};`\n+                    //                    ^^^\n+                    if let Some(previous_span) = extend_span_to_previous_binding(\n+                        self.resolver.session, binding_span,\n+                    ) {\n+                        debug!(\"check_for_module_export_macro: previous_span={:?}\", previous_span);\n+                        removal_span = removal_span.with_lo(previous_span.lo());\n+                    }\n+                }\n+                debug!(\"check_for_module_export_macro: removal_span={:?}\", removal_span);\n+\n+                // Find the span after the crate name and if it has nested imports immediatately\n+                // after the crate name already.\n+                //   ie. `use a::b::{c, d};`\n+                //               ^^^^^^^^^\n+                //   or  `use a::{b, c, d}};`\n+                //               ^^^^^^^^^^^\n+                let (has_nested, after_crate_name) = find_span_immediately_after_crate_name(\n+                    self.resolver.session, module_name, directive.use_span,\n+                );\n+                debug!(\"check_for_module_export_macro: has_nested={:?} after_crate_name={:?}\",\n+                       has_nested, after_crate_name);\n+\n+                let source_map = self.resolver.session.source_map();\n+\n+                // Remove two bytes at the end to keep all but the `};` characters.\n+                //   ie. `{b::{c, d}, e::{f, g}};`\n+                //        ^^^^^^^^^^^^^^^^^^^^^\n+                let end_bytes = BytePos(if has_nested { 2 } else { 1 });\n+                let mut remaining_span = after_crate_name.with_hi(\n+                    after_crate_name.hi() - end_bytes);\n+                if has_nested {\n+                    // Remove two bytes at the start to keep all but the initial `{` character.\n+                    //   ie. `{b::{c, d}, e::{f, g}`\n+                    //         ^^^^^^^^^^^^^^^^^^^^\n+                    remaining_span = remaining_span.with_lo(after_crate_name.lo() + BytePos(1));\n+                }\n+\n+                // Calculate the number of characters into a snippet to remove the removal\n+                // span.\n+                let lo = removal_span.lo() - remaining_span.lo();\n+                let hi = lo + (removal_span.hi() - removal_span.lo());\n+                if let Ok(mut remaining) = source_map.span_to_snippet(remaining_span) {\n+                    // Remove the original location of the binding.\n+                    remaining.replace_range((lo.0 as usize)..(hi.0 as usize), \"\");\n+                    correction = format!(\"use {}::{{{}, {}}};\", module_name, import, remaining);\n+                }\n+            }\n+\n             let suggestion = Some((\n-                directive.span,\n+                span,\n                 String::from(\"a macro with this name exists at the root of the crate\"),\n-                format!(\"{}::{}\", module_name, import),\n+                correction,\n                 Applicability::MaybeIncorrect,\n             ));\n             let note = vec![\n@@ -632,3 +706,149 @@ impl<'a, 'b:'a> ImportResolver<'a, 'b> {\n         }\n     }\n }\n+\n+/// Given a `binding_span` of a binding within a use statement:\n+///\n+/// ```\n+/// use foo::{a, b, c};\n+///              ^\n+/// ```\n+///\n+/// then return the span until the next binding or the end of the statement:\n+///\n+/// ```\n+/// use foo::{a, b, c};\n+///              ^^^\n+/// ```\n+pub(crate) fn find_span_of_binding_until_next_binding(\n+    sess: &Session,\n+    binding_span: Span,\n+    use_span: Span,\n+) -> (bool, Span) {\n+    let source_map = sess.source_map();\n+\n+    // Find the span of everything after the binding.\n+    //   ie. `a, e};` or `a};`\n+    let binding_until_end = binding_span.with_hi(use_span.hi());\n+\n+    // Find everything after the binding but not including the binding.\n+    //   ie. `, e};` or `};`\n+    let after_binding_until_end = binding_until_end.with_lo(binding_span.hi());\n+\n+    // Keep characters in the span until we encounter something that isn't a comma or\n+    // whitespace.\n+    //   ie. `, ` or ``.\n+    //\n+    // Also note whether a closing brace character was encountered. If there\n+    // was, then later go backwards to remove any trailing commas that are left.\n+    let mut found_closing_brace = false;\n+    let after_binding_until_next_binding = source_map.span_take_while(\n+        after_binding_until_end,\n+        |&ch| {\n+            if ch == '}' { found_closing_brace = true; }\n+            ch == ' ' || ch == ','\n+        }\n+    );\n+\n+    // Combine the two spans.\n+    //   ie. `a, ` or `a`.\n+    //\n+    // Removing these would leave `issue_52891::{d, e};` or `issue_52891::{d, e, };`\n+    let span = binding_span.with_hi(after_binding_until_next_binding.hi());\n+\n+    (found_closing_brace, span)\n+}\n+\n+/// Given a `binding_span`, return the span through to the comma or opening brace of the previous\n+/// binding.\n+///\n+/// ```\n+/// use foo::a::{a, b, c};\n+///               ^^--- binding span\n+///               |\n+///               returned span\n+///\n+/// use foo::{a, b, c};\n+///           --- binding span\n+/// ```\n+pub(crate) fn extend_span_to_previous_binding(\n+    sess: &Session,\n+    binding_span: Span,\n+) -> Option<Span> {\n+    let source_map = sess.source_map();\n+\n+    // `prev_source` will contain all of the source that came before the span.\n+    // Then split based on a command and take the first (ie. closest to our span)\n+    // snippet. In the example, this is a space.\n+    let prev_source = source_map.span_to_prev_source(binding_span).ok()?;\n+\n+    let prev_comma = prev_source.rsplit(',').collect::<Vec<_>>();\n+    let prev_starting_brace = prev_source.rsplit('{').collect::<Vec<_>>();\n+    if prev_comma.len() <= 1 || prev_starting_brace.len() <= 1 {\n+        return None;\n+    }\n+\n+    let prev_comma = prev_comma.first().unwrap();\n+    let prev_starting_brace = prev_starting_brace.first().unwrap();\n+\n+    // If the amount of source code before the comma is greater than\n+    // the amount of source code before the starting brace then we've only\n+    // got one item in the nested item (eg. `issue_52891::{self}`).\n+    if prev_comma.len() > prev_starting_brace.len() {\n+        return None;\n+    }\n+\n+    Some(binding_span.with_lo(BytePos(\n+        // Take away the number of bytes for the characters we've found and an\n+        // extra for the comma.\n+        binding_span.lo().0 - (prev_comma.as_bytes().len() as u32) - 1\n+    )))\n+}\n+\n+/// Given a `use_span` of a binding within a use statement, returns the highlighted span and if\n+/// it is a nested use tree.\n+///\n+/// ```\n+/// use foo::a::{b, c};\n+///          ^^^^^^^^^^ // false\n+///\n+/// use foo::{a, b, c};\n+///          ^^^^^^^^^^ // true\n+///\n+/// use foo::{a, b::{c, d}};\n+///          ^^^^^^^^^^^^^^^ // true\n+/// ```\n+fn find_span_immediately_after_crate_name(\n+    sess: &Session,\n+    module_name: Symbol,\n+    use_span: Span,\n+) -> (bool, Span) {\n+    debug!(\"find_span_immediately_after_crate_name: module_name={:?} use_span={:?}\",\n+           module_name, use_span);\n+    let source_map = sess.source_map();\n+\n+    // Get position of the first `{` character for the use statement.\n+    //  ie. `use foo::{a, b::{c, d}};`\n+    //                ^\n+    let pos_of_use_tree_left_bracket = source_map.span_until_char(use_span, '{').hi();\n+    debug!(\"find_span_immediately_after_crate_name: pos_of_use_tree_left_bracket={:?}\",\n+           pos_of_use_tree_left_bracket);\n+\n+    // Calculate the expected difference between the first `{` character and the start of a\n+    // use statement.\n+    //  ie. `use foo::{..};`\n+    //       ^^^^\n+    //       |   ^^^\n+    //       4   |  ^^\n+    //           3  |\n+    //              2\n+    let expected_difference = BytePos((module_name.as_str().len() + 4 + 2) as u32);\n+    debug!(\"find_span_immediately_after_crate_name: expected_difference={:?}\",\n+           expected_difference);\n+    let actual_difference = pos_of_use_tree_left_bracket - use_span.lo();\n+    debug!(\"find_span_immediately_after_crate_name: actual_difference={:?}\",\n+           actual_difference);\n+\n+    (expected_difference == actual_difference,\n+     use_span.with_lo(use_span.lo() + expected_difference))\n+}"}, {"sha": "b33356c2ba7aec945d8ea12de021c829f0101bdb", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 14, "deletions": 63, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/7c955409e3cb06b2a5c008e80c6856cb25a74b33/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c955409e3cb06b2a5c008e80c6856cb25a74b33/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=7c955409e3cb06b2a5c008e80c6856cb25a74b33", "patch": "@@ -50,7 +50,7 @@ use syntax::ast::{QSelf, TraitItemKind, TraitRef, Ty, TyKind};\n use syntax::ptr::P;\n use syntax::{span_err, struct_span_err, unwrap_or, walk_list};\n \n-use syntax_pos::{BytePos, Span, DUMMY_SP, MultiSpan};\n+use syntax_pos::{Span, DUMMY_SP, MultiSpan};\n use errors::{Applicability, DiagnosticBuilder, DiagnosticId};\n \n use log::debug;\n@@ -62,6 +62,7 @@ use std::mem::replace;\n use rustc_data_structures::ptr_key::PtrKey;\n use rustc_data_structures::sync::Lrc;\n \n+use error_reporting::{find_span_of_binding_until_next_binding, extend_span_to_previous_binding};\n use resolve_imports::{ImportDirective, ImportDirectiveSubclass, NameResolution, ImportResolver};\n use macros::{InvocationData, LegacyBinding, ParentScope};\n \n@@ -5144,7 +5145,6 @@ impl<'a> Resolver<'a> {\n     ) {\n         assert!(directive.is_nested());\n         let message = \"remove unnecessary import\";\n-        let source_map = self.session.source_map();\n \n         // Two examples will be used to illustrate the span manipulations we're doing:\n         //\n@@ -5153,73 +5153,24 @@ impl<'a> Resolver<'a> {\n         // - Given `use issue_52891::{d, e, a};` where `a` is a duplicate then `binding_span` is\n         //   `a` and `directive.use_span` is `issue_52891::{d, e, a};`.\n \n-        // Find the span of everything after the binding.\n-        //   ie. `a, e};` or `a};`\n-        let binding_until_end = binding_span.with_hi(directive.use_span.hi());\n-\n-        // Find everything after the binding but not including the binding.\n-        //   ie. `, e};` or `};`\n-        let after_binding_until_end = binding_until_end.with_lo(binding_span.hi());\n-\n-        // Keep characters in the span until we encounter something that isn't a comma or\n-        // whitespace.\n-        //   ie. `, ` or ``.\n-        //\n-        // Also note whether a closing brace character was encountered. If there\n-        // was, then later go backwards to remove any trailing commas that are left.\n-        let mut found_closing_brace = false;\n-        let after_binding_until_next_binding = source_map.span_take_while(\n-            after_binding_until_end,\n-            |&ch| {\n-                if ch == '}' { found_closing_brace = true; }\n-                ch == ' ' || ch == ','\n-            }\n+        let (found_closing_brace, span) = find_span_of_binding_until_next_binding(\n+            self.session, binding_span, directive.use_span,\n         );\n \n-        // Combine the two spans.\n-        //   ie. `a, ` or `a`.\n-        //\n-        // Removing these would leave `issue_52891::{d, e};` or `issue_52891::{d, e, };`\n-        let span = binding_span.with_hi(after_binding_until_next_binding.hi());\n-\n         // If there was a closing brace then identify the span to remove any trailing commas from\n         // previous imports.\n         if found_closing_brace {\n-            if let Ok(prev_source) = source_map.span_to_prev_source(span) {\n-                // `prev_source` will contain all of the source that came before the span.\n-                // Then split based on a command and take the first (ie. closest to our span)\n-                // snippet. In the example, this is a space.\n-                let prev_comma = prev_source.rsplit(',').collect::<Vec<_>>();\n-                let prev_starting_brace = prev_source.rsplit('{').collect::<Vec<_>>();\n-                if prev_comma.len() > 1 && prev_starting_brace.len() > 1 {\n-                    let prev_comma = prev_comma.first().unwrap();\n-                    let prev_starting_brace = prev_starting_brace.first().unwrap();\n-\n-                    // If the amount of source code before the comma is greater than\n-                    // the amount of source code before the starting brace then we've only\n-                    // got one item in the nested item (eg. `issue_52891::{self}`).\n-                    if prev_comma.len() > prev_starting_brace.len() {\n-                        // So just remove the entire line...\n-                        err.span_suggestion(\n-                            directive.use_span_with_attributes,\n-                            message,\n-                            String::new(),\n-                            Applicability::MaybeIncorrect,\n-                        );\n-                        return;\n-                    }\n-\n-                    let span = span.with_lo(BytePos(\n-                        // Take away the number of bytes for the characters we've found and an\n-                        // extra for the comma.\n-                        span.lo().0 - (prev_comma.as_bytes().len() as u32) - 1\n-                    ));\n-                    err.tool_only_span_suggestion(\n-                        span, message, String::new(), Applicability::MaybeIncorrect,\n-                    );\n-                    return;\n-                }\n+            if let Some(span) = extend_span_to_previous_binding(self.session, span) {\n+                err.tool_only_span_suggestion(span, message, String::new(),\n+                                              Applicability::MaybeIncorrect);\n+            } else {\n+                // Remove the entire line if we cannot extend the span back, this indicates a\n+                // `issue_52891::{self}` case.\n+                err.span_suggestion(directive.use_span_with_attributes, message, String::new(),\n+                                    Applicability::MaybeIncorrect);\n             }\n+\n+            return;\n         }\n \n         err.span_suggestion(span, message, String::new(), Applicability::MachineApplicable);"}, {"sha": "a92eed968d0607b7a1e1e0f81f0e43cc3e2ec79f", "filename": "src/test/ui/auxiliary/issue-59764.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/7c955409e3cb06b2a5c008e80c6856cb25a74b33/src%2Ftest%2Fui%2Fauxiliary%2Fissue-59764.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c955409e3cb06b2a5c008e80c6856cb25a74b33/src%2Ftest%2Fui%2Fauxiliary%2Fissue-59764.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fauxiliary%2Fissue-59764.rs?ref=7c955409e3cb06b2a5c008e80c6856cb25a74b33", "patch": "@@ -5,4 +5,14 @@ pub mod foo {\n             fn $foo() { }\n         }\n     }\n+\n+    pub fn baz() {}\n+\n+    pub fn foobar() {}\n+\n+    pub mod barbaz {\n+        pub fn barfoo() {}\n+    }\n }\n+\n+pub fn foobaz() {}"}, {"sha": "ff193fce7eb1dedb7f65632cb8cb4bd0fd413c7a", "filename": "src/test/ui/issue-59764.fixed", "status": "modified", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/7c955409e3cb06b2a5c008e80c6856cb25a74b33/src%2Ftest%2Fui%2Fissue-59764.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/7c955409e3cb06b2a5c008e80c6856cb25a74b33/src%2Ftest%2Fui%2Fissue-59764.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-59764.fixed?ref=7c955409e3cb06b2a5c008e80c6856cb25a74b33", "patch": "@@ -11,11 +11,104 @@\n \n // Edge cases..\n \n+mod multiple_imports_same_line_at_end {\n+    use issue_59764::{makro, foo::{baz}};\n+    //~^ ERROR unresolved import `issue_59764::foo::makro` [E0432]\n+}\n+\n+mod multiple_imports_multiline_at_end_trailing_comma {\n+    use issue_59764::{makro, foo::{\n+        baz,\n+        //~ ERROR unresolved import `issue_59764::foo::makro` [E0432]\n+    }};\n+}\n+\n+mod multiple_imports_multiline_at_end {\n+    use issue_59764::{makro, foo::{\n+        baz,\n+        //~ ERROR unresolved import `issue_59764::foo::makro` [E0432]\n+    }};\n+}\n+\n+mod multiple_imports_same_line_in_middle {\n+    use issue_59764::{makro, foo::{baz, foobar}};\n+    //~^ ERROR unresolved import `issue_59764::foo::makro` [E0432]\n+}\n+\n+mod multiple_imports_multiline_in_middle_trailing_comma {\n+    use issue_59764::{makro, foo::{\n+        baz,\n+        //~ ERROR unresolved import `issue_59764::foo::makro` [E0432]\n+        foobar,\n+    }};\n+}\n+\n+mod multiple_imports_multiline_in_middle {\n+    use issue_59764::{makro, foo::{\n+        baz,\n+        //~ ERROR unresolved import `issue_59764::foo::makro` [E0432]\n+        foobar\n+    }};\n+}\n+\n+mod nested_imports {\n+    use issue_59764::{makro, foobaz};\n+    //~^ ERROR unresolved import `issue_59764::foo::makro` [E0432]\n+}\n+\n+mod nested_multiple_imports {\n+    use issue_59764::{makro, foobaz, foo::{baz}};\n+    //~^ ERROR unresolved import `issue_59764::foo::makro` [E0432]\n+}\n+\n+mod nested_multiline_multiple_imports_trailing_comma {\n+    use issue_59764::{makro, \n+        foobaz,\n+        foo::{\n+            baz,\n+            //~ ERROR unresolved import `issue_59764::foo::makro` [E0432]\n+        },\n+    };\n+}\n+\n+mod nested_multiline_multiple_imports {\n+    use issue_59764::{makro, \n+        foobaz,\n+        foo::{\n+            baz,\n+            //~ ERROR unresolved import `issue_59764::foo::makro` [E0432]\n+        }\n+    };\n+}\n+\n+mod doubly_nested_multiple_imports {\n+    use issue_59764::{makro, foobaz, foo::{baz, barbaz::{barfoo}}};\n+    //~^ ERROR unresolved import `issue_59764::foo::makro` [E0432]\n+}\n+\n+mod doubly_multiline_nested_multiple_imports {\n+    use issue_59764::{makro, \n+        foobaz,\n+        foo::{\n+            baz,\n+            //~ ERROR unresolved import `issue_59764::foo::makro` [E0432]\n+            barbaz::{\n+                barfoo,\n+            }\n+        }\n+    };\n+}\n+\n mod renamed_import {\n     use issue_59764::makro as baz;\n     //~^ ERROR unresolved import `issue_59764::foo::makro` [E0432]\n }\n \n+mod renamed_multiple_imports {\n+    use issue_59764::{makro as foobar, foo::{baz}};\n+    //~^ ERROR unresolved import `issue_59764::foo::makro` [E0432]\n+}\n+\n // Simple case..\n \n use issue_59764::makro;"}, {"sha": "c68471adaad56170d2c0e1c31ae12381ffb2068c", "filename": "src/test/ui/issue-59764.rs", "status": "modified", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/7c955409e3cb06b2a5c008e80c6856cb25a74b33/src%2Ftest%2Fui%2Fissue-59764.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7c955409e3cb06b2a5c008e80c6856cb25a74b33/src%2Ftest%2Fui%2Fissue-59764.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-59764.rs?ref=7c955409e3cb06b2a5c008e80c6856cb25a74b33", "patch": "@@ -11,11 +11,104 @@\n \n // Edge cases..\n \n+mod multiple_imports_same_line_at_end {\n+    use issue_59764::foo::{baz, makro};\n+    //~^ ERROR unresolved import `issue_59764::foo::makro` [E0432]\n+}\n+\n+mod multiple_imports_multiline_at_end_trailing_comma {\n+    use issue_59764::foo::{\n+        baz,\n+        makro, //~ ERROR unresolved import `issue_59764::foo::makro` [E0432]\n+    };\n+}\n+\n+mod multiple_imports_multiline_at_end {\n+    use issue_59764::foo::{\n+        baz,\n+        makro //~ ERROR unresolved import `issue_59764::foo::makro` [E0432]\n+    };\n+}\n+\n+mod multiple_imports_same_line_in_middle {\n+    use issue_59764::foo::{baz, makro, foobar};\n+    //~^ ERROR unresolved import `issue_59764::foo::makro` [E0432]\n+}\n+\n+mod multiple_imports_multiline_in_middle_trailing_comma {\n+    use issue_59764::foo::{\n+        baz,\n+        makro, //~ ERROR unresolved import `issue_59764::foo::makro` [E0432]\n+        foobar,\n+    };\n+}\n+\n+mod multiple_imports_multiline_in_middle {\n+    use issue_59764::foo::{\n+        baz,\n+        makro, //~ ERROR unresolved import `issue_59764::foo::makro` [E0432]\n+        foobar\n+    };\n+}\n+\n+mod nested_imports {\n+    use issue_59764::{foobaz, foo::makro};\n+    //~^ ERROR unresolved import `issue_59764::foo::makro` [E0432]\n+}\n+\n+mod nested_multiple_imports {\n+    use issue_59764::{foobaz, foo::{baz, makro}};\n+    //~^ ERROR unresolved import `issue_59764::foo::makro` [E0432]\n+}\n+\n+mod nested_multiline_multiple_imports_trailing_comma {\n+    use issue_59764::{\n+        foobaz,\n+        foo::{\n+            baz,\n+            makro, //~ ERROR unresolved import `issue_59764::foo::makro` [E0432]\n+        },\n+    };\n+}\n+\n+mod nested_multiline_multiple_imports {\n+    use issue_59764::{\n+        foobaz,\n+        foo::{\n+            baz,\n+            makro //~ ERROR unresolved import `issue_59764::foo::makro` [E0432]\n+        }\n+    };\n+}\n+\n+mod doubly_nested_multiple_imports {\n+    use issue_59764::{foobaz, foo::{baz, makro, barbaz::{barfoo}}};\n+    //~^ ERROR unresolved import `issue_59764::foo::makro` [E0432]\n+}\n+\n+mod doubly_multiline_nested_multiple_imports {\n+    use issue_59764::{\n+        foobaz,\n+        foo::{\n+            baz,\n+            makro, //~ ERROR unresolved import `issue_59764::foo::makro` [E0432]\n+            barbaz::{\n+                barfoo,\n+            }\n+        }\n+    };\n+}\n+\n mod renamed_import {\n     use issue_59764::foo::makro as baz;\n     //~^ ERROR unresolved import `issue_59764::foo::makro` [E0432]\n }\n \n+mod renamed_multiple_imports {\n+    use issue_59764::foo::{baz, makro as foobar};\n+    //~^ ERROR unresolved import `issue_59764::foo::makro` [E0432]\n+}\n+\n // Simple case..\n \n use issue_59764::foo::makro;"}, {"sha": "fe935473184683b19241fa1dafe28f98f86b0458", "filename": "src/test/ui/issue-59764.stderr", "status": "modified", "additions": 190, "deletions": 5, "changes": 195, "blob_url": "https://github.com/rust-lang/rust/blob/7c955409e3cb06b2a5c008e80c6856cb25a74b33/src%2Ftest%2Fui%2Fissue-59764.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/7c955409e3cb06b2a5c008e80c6856cb25a74b33/src%2Ftest%2Fui%2Fissue-59764.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissue-59764.stderr?ref=7c955409e3cb06b2a5c008e80c6856cb25a74b33", "patch": "@@ -1,5 +1,178 @@\n error[E0432]: unresolved import `issue_59764::foo::makro`\n-  --> $DIR/issue-59764.rs:15:9\n+  --> $DIR/issue-59764.rs:15:33\n+   |\n+LL |     use issue_59764::foo::{baz, makro};\n+   |                                 ^^^^^ no `makro` in `foo`\n+   |\n+   = note: this could be because a macro annotated with `#[macro_export]` will be exported at the root of the crate instead of the module where it is defined\n+help: a macro with this name exists at the root of the crate\n+   |\n+LL |     use issue_59764::{makro, foo::{baz}};\n+   |\n+\n+error[E0432]: unresolved import `issue_59764::foo::makro`\n+  --> $DIR/issue-59764.rs:22:9\n+   |\n+LL |         makro,\n+   |         ^^^^^ no `makro` in `foo`\n+   |\n+   = note: this could be because a macro annotated with `#[macro_export]` will be exported at the root of the crate instead of the module where it is defined\n+help: a macro with this name exists at the root of the crate\n+   |\n+LL |     use issue_59764::{makro, foo::{\n+LL |         baz,\n+LL |\n+LL |     }};\n+   |\n+\n+error[E0432]: unresolved import `issue_59764::foo::makro`\n+  --> $DIR/issue-59764.rs:29:9\n+   |\n+LL |         makro\n+   |         ^^^^^ no `makro` in `foo`\n+   |\n+   = note: this could be because a macro annotated with `#[macro_export]` will be exported at the root of the crate instead of the module where it is defined\n+help: a macro with this name exists at the root of the crate\n+   |\n+LL |     use issue_59764::{makro, foo::{\n+LL |         baz,\n+LL |\n+LL |     }};\n+   |\n+\n+error[E0432]: unresolved import `issue_59764::foo::makro`\n+  --> $DIR/issue-59764.rs:34:33\n+   |\n+LL |     use issue_59764::foo::{baz, makro, foobar};\n+   |                                 ^^^^^ no `makro` in `foo`\n+   |\n+   = note: this could be because a macro annotated with `#[macro_export]` will be exported at the root of the crate instead of the module where it is defined\n+help: a macro with this name exists at the root of the crate\n+   |\n+LL |     use issue_59764::{makro, foo::{baz, foobar}};\n+   |\n+\n+error[E0432]: unresolved import `issue_59764::foo::makro`\n+  --> $DIR/issue-59764.rs:41:9\n+   |\n+LL |         makro,\n+   |         ^^^^^ no `makro` in `foo`\n+   |\n+   = note: this could be because a macro annotated with `#[macro_export]` will be exported at the root of the crate instead of the module where it is defined\n+help: a macro with this name exists at the root of the crate\n+   |\n+LL |     use issue_59764::{makro, foo::{\n+LL |         baz,\n+LL |\n+LL |         foobar,\n+LL |     }};\n+   |\n+\n+error[E0432]: unresolved import `issue_59764::foo::makro`\n+  --> $DIR/issue-59764.rs:49:9\n+   |\n+LL |         makro,\n+   |         ^^^^^ no `makro` in `foo`\n+   |\n+   = note: this could be because a macro annotated with `#[macro_export]` will be exported at the root of the crate instead of the module where it is defined\n+help: a macro with this name exists at the root of the crate\n+   |\n+LL |     use issue_59764::{makro, foo::{\n+LL |         baz,\n+LL |\n+LL |         foobar\n+LL |     }};\n+   |\n+\n+error[E0432]: unresolved import `issue_59764::foo::makro`\n+  --> $DIR/issue-59764.rs:55:31\n+   |\n+LL |     use issue_59764::{foobaz, foo::makro};\n+   |                               ^^^^^^^^^^ no `makro` in `foo`\n+   |\n+   = note: this could be because a macro annotated with `#[macro_export]` will be exported at the root of the crate instead of the module where it is defined\n+help: a macro with this name exists at the root of the crate\n+   |\n+LL |     use issue_59764::{makro, foobaz};\n+   |\n+\n+error[E0432]: unresolved import `issue_59764::foo::makro`\n+  --> $DIR/issue-59764.rs:60:42\n+   |\n+LL |     use issue_59764::{foobaz, foo::{baz, makro}};\n+   |                                          ^^^^^ no `makro` in `foo`\n+   |\n+   = note: this could be because a macro annotated with `#[macro_export]` will be exported at the root of the crate instead of the module where it is defined\n+help: a macro with this name exists at the root of the crate\n+   |\n+LL |     use issue_59764::{makro, foobaz, foo::{baz}};\n+   |\n+\n+error[E0432]: unresolved import `issue_59764::foo::makro`\n+  --> $DIR/issue-59764.rs:69:13\n+   |\n+LL |             makro,\n+   |             ^^^^^ no `makro` in `foo`\n+   |\n+   = note: this could be because a macro annotated with `#[macro_export]` will be exported at the root of the crate instead of the module where it is defined\n+help: a macro with this name exists at the root of the crate\n+   |\n+LL |     use issue_59764::{makro, \n+LL |         foobaz,\n+LL |         foo::{\n+LL |             baz,\n+LL |\n+LL |         },\n+ ...\n+\n+error[E0432]: unresolved import `issue_59764::foo::makro`\n+  --> $DIR/issue-59764.rs:79:13\n+   |\n+LL |             makro\n+   |             ^^^^^ no `makro` in `foo`\n+   |\n+   = note: this could be because a macro annotated with `#[macro_export]` will be exported at the root of the crate instead of the module where it is defined\n+help: a macro with this name exists at the root of the crate\n+   |\n+LL |     use issue_59764::{makro, \n+LL |         foobaz,\n+LL |         foo::{\n+LL |             baz,\n+LL |\n+LL |         }\n+ ...\n+\n+error[E0432]: unresolved import `issue_59764::foo::makro`\n+  --> $DIR/issue-59764.rs:85:42\n+   |\n+LL |     use issue_59764::{foobaz, foo::{baz, makro, barbaz::{barfoo}}};\n+   |                                          ^^^^^ no `makro` in `foo`\n+   |\n+   = note: this could be because a macro annotated with `#[macro_export]` will be exported at the root of the crate instead of the module where it is defined\n+help: a macro with this name exists at the root of the crate\n+   |\n+LL |     use issue_59764::{makro, foobaz, foo::{baz, barbaz::{barfoo}}};\n+   |\n+\n+error[E0432]: unresolved import `issue_59764::foo::makro`\n+  --> $DIR/issue-59764.rs:94:13\n+   |\n+LL |             makro,\n+   |             ^^^^^ no `makro` in `foo`\n+   |\n+   = note: this could be because a macro annotated with `#[macro_export]` will be exported at the root of the crate instead of the module where it is defined\n+help: a macro with this name exists at the root of the crate\n+   |\n+LL |     use issue_59764::{makro, \n+LL |         foobaz,\n+LL |         foo::{\n+LL |             baz,\n+LL |\n+LL |             barbaz::{\n+ ...\n+\n+error[E0432]: unresolved import `issue_59764::foo::makro`\n+  --> $DIR/issue-59764.rs:103:9\n    |\n LL |     use issue_59764::foo::makro as baz;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ no `makro` in `foo`\n@@ -11,7 +184,19 @@ LL |     use issue_59764::makro as baz;\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0432]: unresolved import `issue_59764::foo::makro`\n-  --> $DIR/issue-59764.rs:21:5\n+  --> $DIR/issue-59764.rs:108:33\n+   |\n+LL |     use issue_59764::foo::{baz, makro as foobar};\n+   |                                 ^^^^^^^^^^^^^^^ no `makro` in `foo`\n+   |\n+   = note: this could be because a macro annotated with `#[macro_export]` will be exported at the root of the crate instead of the module where it is defined\n+help: a macro with this name exists at the root of the crate\n+   |\n+LL |     use issue_59764::{makro as foobar, foo::{baz}};\n+   |\n+\n+error[E0432]: unresolved import `issue_59764::foo::makro`\n+  --> $DIR/issue-59764.rs:114:5\n    |\n LL | use issue_59764::foo::makro;\n    |     ^^^^^^^^^^^^^^^^^^^^^^^ no `makro` in `foo`\n@@ -23,20 +208,20 @@ LL | use issue_59764::makro;\n    |     ^^^^^^^^^^^^^^^^^^\n \n error: cannot determine resolution for the macro `makro`\n-  --> $DIR/issue-59764.rs:24:1\n+  --> $DIR/issue-59764.rs:117:1\n    |\n LL | makro!(bar);\n    | ^^^^^\n    |\n    = note: import resolution is stuck, try simplifying macro imports\n \n error[E0425]: cannot find function `bar` in this scope\n-  --> $DIR/issue-59764.rs:28:5\n+  --> $DIR/issue-59764.rs:121:5\n    |\n LL |     bar();\n    |     ^^^ not found in this scope\n \n-error: aborting due to 4 previous errors\n+error: aborting due to 17 previous errors\n \n Some errors occurred: E0425, E0432.\n For more information about an error, try `rustc --explain E0425`."}]}