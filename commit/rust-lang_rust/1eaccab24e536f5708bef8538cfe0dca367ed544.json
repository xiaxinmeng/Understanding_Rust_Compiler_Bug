{"sha": "1eaccab24e536f5708bef8538cfe0dca367ed544", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFlYWNjYWIyNGU1MzZmNTcwOGJlZjg1MzhjZmUwZGNhMzY3ZWQ1NDQ=", "commit": {"author": {"name": "Erik Desjardins", "email": "erikdesjardins@users.noreply.github.com", "date": "2021-08-10T23:29:18Z"}, "committer": {"name": "Erik Desjardins", "email": "erikdesjardins@users.noreply.github.com", "date": "2021-08-25T21:49:28Z"}, "message": "optimize initialization checks", "tree": {"sha": "4a851ff38536d53b96311f72dfb665d2cc70594d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4a851ff38536d53b96311f72dfb665d2cc70594d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1eaccab24e536f5708bef8538cfe0dca367ed544", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1eaccab24e536f5708bef8538cfe0dca367ed544", "html_url": "https://github.com/rust-lang/rust/commit/1eaccab24e536f5708bef8538cfe0dca367ed544", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1eaccab24e536f5708bef8538cfe0dca367ed544/comments", "author": {"login": "erikdesjardins", "id": 7673145, "node_id": "MDQ6VXNlcjc2NzMxNDU=", "avatar_url": "https://avatars.githubusercontent.com/u/7673145?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erikdesjardins", "html_url": "https://github.com/erikdesjardins", "followers_url": "https://api.github.com/users/erikdesjardins/followers", "following_url": "https://api.github.com/users/erikdesjardins/following{/other_user}", "gists_url": "https://api.github.com/users/erikdesjardins/gists{/gist_id}", "starred_url": "https://api.github.com/users/erikdesjardins/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erikdesjardins/subscriptions", "organizations_url": "https://api.github.com/users/erikdesjardins/orgs", "repos_url": "https://api.github.com/users/erikdesjardins/repos", "events_url": "https://api.github.com/users/erikdesjardins/events{/privacy}", "received_events_url": "https://api.github.com/users/erikdesjardins/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erikdesjardins", "id": 7673145, "node_id": "MDQ6VXNlcjc2NzMxNDU=", "avatar_url": "https://avatars.githubusercontent.com/u/7673145?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erikdesjardins", "html_url": "https://github.com/erikdesjardins", "followers_url": "https://api.github.com/users/erikdesjardins/followers", "following_url": "https://api.github.com/users/erikdesjardins/following{/other_user}", "gists_url": "https://api.github.com/users/erikdesjardins/gists{/gist_id}", "starred_url": "https://api.github.com/users/erikdesjardins/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erikdesjardins/subscriptions", "organizations_url": "https://api.github.com/users/erikdesjardins/orgs", "repos_url": "https://api.github.com/users/erikdesjardins/repos", "events_url": "https://api.github.com/users/erikdesjardins/events{/privacy}", "received_events_url": "https://api.github.com/users/erikdesjardins/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c9599c4cacb4c5b9f8a2c353ac062885525960c9", "url": "https://api.github.com/repos/rust-lang/rust/commits/c9599c4cacb4c5b9f8a2c353ac062885525960c9", "html_url": "https://github.com/rust-lang/rust/commit/c9599c4cacb4c5b9f8a2c353ac062885525960c9"}], "stats": {"total": 111, "additions": 102, "deletions": 9}, "files": [{"sha": "4040f4a112e771dc69e3a2664ccc62644c52fcb1", "filename": "compiler/rustc_middle/src/mir/interpret/allocation.rs", "status": "modified", "additions": 102, "deletions": 9, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/1eaccab24e536f5708bef8538cfe0dca367ed544/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1eaccab24e536f5708bef8538cfe0dca367ed544/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fallocation.rs?ref=1eaccab24e536f5708bef8538cfe0dca367ed544", "patch": "@@ -1,7 +1,7 @@\n //! The virtual memory representation of the MIR interpreter.\n \n use std::borrow::Cow;\n-use std::convert::TryFrom;\n+use std::convert::{TryFrom, TryInto};\n use std::iter;\n use std::ops::{Deref, Range};\n use std::ptr;\n@@ -720,13 +720,12 @@ impl InitMask {\n             return Err(self.len..end);\n         }\n \n-        // FIXME(oli-obk): optimize this for allocations larger than a block.\n-        let idx = (start..end).find(|&i| !self.get(i));\n+        let uninit_start = find_bit(self, start, end, false);\n \n-        match idx {\n-            Some(idx) => {\n-                let uninit_end = (idx..end).find(|&i| self.get(i)).unwrap_or(end);\n-                Err(idx..uninit_end)\n+        match uninit_start {\n+            Some(uninit_start) => {\n+                let uninit_end = find_bit(self, uninit_start, end, true).unwrap_or(end);\n+                Err(uninit_start..uninit_end)\n             }\n             None => Ok(()),\n         }\n@@ -863,9 +862,8 @@ impl<'a> Iterator for InitChunkIter<'a> {\n         }\n \n         let is_init = self.init_mask.get(self.start);\n-        // FIXME(oli-obk): optimize this for allocations larger than a block.\n         let end_of_chunk =\n-            (self.start..self.end).find(|&i| self.init_mask.get(i) != is_init).unwrap_or(self.end);\n+            find_bit(&self.init_mask, self.start, self.end, !is_init).unwrap_or(self.end);\n         let range = self.start..end_of_chunk;\n \n         self.start = end_of_chunk;\n@@ -874,10 +872,105 @@ impl<'a> Iterator for InitChunkIter<'a> {\n     }\n }\n \n+/// Returns the index of the first bit in `start..end` (end-exclusive) that is equal to is_init.\n+fn find_bit(init_mask: &InitMask, start: Size, end: Size, is_init: bool) -> Option<Size> {\n+    fn find_bit_fast(init_mask: &InitMask, start: Size, end: Size, is_init: bool) -> Option<Size> {\n+        fn search_block(\n+            bits: Block,\n+            block: usize,\n+            start_bit: usize,\n+            is_init: bool,\n+        ) -> Option<Size> {\n+            // invert bits so we're always looking for the first set bit\n+            let bits = if is_init { bits } else { !bits };\n+            // mask off unused start bits\n+            let bits = bits & (!0 << start_bit);\n+            // find set bit, if any\n+            if bits == 0 {\n+                None\n+            } else {\n+                let bit = bits.trailing_zeros();\n+                Some(size_from_bit_index(block, bit))\n+            }\n+        }\n+\n+        if start >= end {\n+            return None;\n+        }\n+\n+        let (start_block, start_bit) = bit_index(start);\n+        let (end_block, end_bit) = bit_index(end);\n+\n+        // handle first block: need to skip `start_bit` bits\n+        if let Some(i) =\n+            search_block(init_mask.blocks[start_block], start_block, start_bit, is_init)\n+        {\n+            if i < end {\n+                return Some(i);\n+            } else {\n+                // if the range is less than a block, we may find a matching bit after `end`\n+                return None;\n+            }\n+        }\n+\n+        let one_block_past_the_end = if end_bit > 0 {\n+            // if `end_bit` > 0, then the range overlaps `end_block`\n+            end_block + 1\n+        } else {\n+            end_block\n+        };\n+\n+        // handle remaining blocks\n+        if start_block < one_block_past_the_end {\n+            for (&bits, block) in init_mask.blocks[start_block + 1..one_block_past_the_end]\n+                .iter()\n+                .zip(start_block + 1..)\n+            {\n+                if let Some(i) = search_block(bits, block, 0, is_init) {\n+                    if i < end {\n+                        return Some(i);\n+                    } else {\n+                        // if this is the last block, we may find a matching bit after `end`\n+                        return None;\n+                    }\n+                }\n+            }\n+        }\n+\n+        None\n+    }\n+\n+    #[cfg_attr(not(debug_assertions), allow(dead_code))]\n+    fn find_bit_slow(init_mask: &InitMask, start: Size, end: Size, is_init: bool) -> Option<Size> {\n+        (start..end).find(|&i| init_mask.get(i) == is_init)\n+    }\n+\n+    let result = find_bit_fast(init_mask, start, end, is_init);\n+\n+    debug_assert_eq!(\n+        result,\n+        find_bit_slow(init_mask, start, end, is_init),\n+        \"optimized implementation of find_bit is wrong for start={:?} end={:?} is_init={} init_mask={:#?}\",\n+        start,\n+        end,\n+        is_init,\n+        init_mask\n+    );\n+\n+    result\n+}\n+\n #[inline]\n fn bit_index(bits: Size) -> (usize, usize) {\n     let bits = bits.bytes();\n     let a = bits / InitMask::BLOCK_SIZE;\n     let b = bits % InitMask::BLOCK_SIZE;\n     (usize::try_from(a).unwrap(), usize::try_from(b).unwrap())\n }\n+\n+#[inline]\n+fn size_from_bit_index(block: impl TryInto<u64>, bit: impl TryInto<u64>) -> Size {\n+    let block = block.try_into().ok().unwrap();\n+    let bit = bit.try_into().ok().unwrap();\n+    Size::from_bytes(block * InitMask::BLOCK_SIZE + bit)\n+}"}]}