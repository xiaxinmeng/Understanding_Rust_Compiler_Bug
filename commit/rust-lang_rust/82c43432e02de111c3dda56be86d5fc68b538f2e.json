{"sha": "82c43432e02de111c3dda56be86d5fc68b538f2e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgyYzQzNDMyZTAyZGUxMTFjM2RkYTU2YmU4NmQ1ZmM2OGI1MzhmMmU=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2015-11-26T11:46:00Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-01-14T17:59:50Z"}, "message": "modify trait checker to track the variables on which trait resolution is\nstalled rather than keeping this annoying mark; I checked that the\noriginal compile-time regression that the mark was intended to\nfix (https://github.com/rust-lang/rust/issues/18208) was still\nreasonable, but I've not done exhaustive measurements to see how\nimportant this \"optimization\" really is anymore", "tree": {"sha": "bafcfff394019c5347828f1867b0e421ae232754", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bafcfff394019c5347828f1867b0e421ae232754"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/82c43432e02de111c3dda56be86d5fc68b538f2e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/82c43432e02de111c3dda56be86d5fc68b538f2e", "html_url": "https://github.com/rust-lang/rust/commit/82c43432e02de111c3dda56be86d5fc68b538f2e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/82c43432e02de111c3dda56be86d5fc68b538f2e/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "02fbf31fb26e0b5eccf34cef8a5f8becef6f3ada", "url": "https://api.github.com/repos/rust-lang/rust/commits/02fbf31fb26e0b5eccf34cef8a5f8becef6f3ada", "html_url": "https://github.com/rust-lang/rust/commit/02fbf31fb26e0b5eccf34cef8a5f8becef6f3ada"}], "stats": {"total": 147, "additions": 74, "deletions": 73}, "files": [{"sha": "6ab18a459d2017def860a44181ba6a7d65dc75b8", "filename": "src/librustc/middle/traits/fulfill.rs", "status": "modified", "additions": 69, "deletions": 46, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/82c43432e02de111c3dda56be86d5fc68b538f2e/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82c43432e02de111c3dda56be86d5fc68b538f2e/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Ffulfill.rs?ref=82c43432e02de111c3dda56be86d5fc68b538f2e", "patch": "@@ -57,12 +57,7 @@ pub struct FulfillmentContext<'tcx> {\n \n     // A list of all obligations that have been registered with this\n     // fulfillment context.\n-    predicates: Vec<PredicateObligation<'tcx>>,\n-\n-    // Remembers the count of trait obligations that we have already\n-    // attempted to select. This is used to avoid repeating work\n-    // when `select_new_obligations` is called.\n-    attempted_mark: usize,\n+    predicates: Vec<PendingPredicateObligation<'tcx>>,\n \n     // A set of constraints that regionck must validate. Each\n     // constraint has the form `T:'a`, meaning \"some type `T` must\n@@ -100,6 +95,12 @@ pub struct RegionObligation<'tcx> {\n     pub cause: ObligationCause<'tcx>,\n }\n \n+#[derive(Clone, Debug)]\n+pub struct PendingPredicateObligation<'tcx> {\n+    pub obligation: PredicateObligation<'tcx>,\n+    pub stalled_on: Vec<Ty<'tcx>>,\n+}\n+\n impl<'tcx> FulfillmentContext<'tcx> {\n     /// Creates a new fulfillment context.\n     ///\n@@ -122,7 +123,6 @@ impl<'tcx> FulfillmentContext<'tcx> {\n         FulfillmentContext {\n             duplicate_set: FulfilledPredicates::new(),\n             predicates: Vec::new(),\n-            attempted_mark: 0,\n             region_obligations: NodeMap(),\n             errors_will_be_reported: errors_will_be_reported,\n         }\n@@ -198,6 +198,10 @@ impl<'tcx> FulfillmentContext<'tcx> {\n         }\n \n         debug!(\"register_predicate({:?})\", obligation);\n+        let obligation = PendingPredicateObligation {\n+            obligation: obligation,\n+            stalled_on: vec![]\n+        };\n         self.predicates.push(obligation);\n     }\n \n@@ -221,7 +225,7 @@ impl<'tcx> FulfillmentContext<'tcx> {\n         let errors: Vec<FulfillmentError> =\n             self.predicates\n             .iter()\n-            .map(|o| FulfillmentError::new((*o).clone(), CodeAmbiguity))\n+            .map(|o| FulfillmentError::new(o.obligation.clone(), CodeAmbiguity))\n             .collect();\n \n         if errors.is_empty() {\n@@ -231,18 +235,6 @@ impl<'tcx> FulfillmentContext<'tcx> {\n         }\n     }\n \n-    /// Attempts to select obligations that were registered since the call to a selection routine.\n-    /// This is used by the type checker to eagerly attempt to resolve obligations in hopes of\n-    /// gaining type information. It'd be equally valid to use `select_where_possible` but it\n-    /// results in `O(n^2)` performance (#18208).\n-    pub fn select_new_obligations<'a>(&mut self,\n-                                      infcx: &InferCtxt<'a,'tcx>)\n-                                      -> Result<(),Vec<FulfillmentError<'tcx>>>\n-    {\n-        let mut selcx = SelectionContext::new(infcx);\n-        self.select(&mut selcx, true)\n-    }\n-\n     pub fn select_where_possible<'a>(&mut self,\n                                      infcx: &InferCtxt<'a,'tcx>)\n                                      -> Result<(),Vec<FulfillmentError<'tcx>>>\n@@ -251,7 +243,7 @@ impl<'tcx> FulfillmentContext<'tcx> {\n         self.select(&mut selcx, false)\n     }\n \n-    pub fn pending_obligations(&self) -> &[PredicateObligation<'tcx>] {\n+    pub fn pending_obligations(&self) -> &[PendingPredicateObligation<'tcx>] {\n         &self.predicates\n     }\n \n@@ -299,36 +291,25 @@ impl<'tcx> FulfillmentContext<'tcx> {\n \n             let mut new_obligations = Vec::new();\n \n-            // If we are only attempting obligations we haven't seen yet,\n-            // then set `skip` to the number of obligations we've already\n-            // seen.\n-            let mut skip = if only_new_obligations {\n-                self.attempted_mark\n-            } else {\n-                0\n-            };\n-\n             // First pass: walk each obligation, retaining\n             // only those that we cannot yet process.\n             {\n                 let region_obligations = &mut self.region_obligations;\n-                self.predicates.retain(|predicate| {\n-                    // Hack: Retain does not pass in the index, but we want\n-                    // to avoid processing the first `start_count` entries.\n-                    let processed =\n-                        if skip == 0 {\n-                            process_predicate(selcx, predicate,\n-                                              &mut new_obligations, &mut errors, region_obligations)\n-                        } else {\n-                            skip -= 1;\n-                            false\n-                        };\n-                    !processed\n-                });\n+                let mut i = 0;\n+                while i < self.predicates.len() {\n+                    let processed = process_predicate(selcx,\n+                                                      &mut self.predicates[i],\n+                                                      &mut new_obligations,\n+                                                      &mut errors,\n+                                                      region_obligations);\n+                    if processed {\n+                        self.predicates.swap_remove(i);\n+                    } else {\n+                        i += 1;\n+                    }\n+                }\n             }\n \n-            self.attempted_mark = self.predicates.len();\n-\n             if self.predicates.len() == count {\n                 // Nothing changed.\n                 break;\n@@ -354,7 +335,7 @@ impl<'tcx> FulfillmentContext<'tcx> {\n }\n \n fn process_predicate<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n-                              obligation: &PredicateObligation<'tcx>,\n+                              pending_obligation: &mut PendingPredicateObligation<'tcx>,\n                               new_obligations: &mut Vec<PredicateObligation<'tcx>>,\n                               errors: &mut Vec<FulfillmentError<'tcx>>,\n                               region_obligations: &mut NodeMap<Vec<RegionObligation<'tcx>>>)\n@@ -367,11 +348,53 @@ fn process_predicate<'a,'tcx>(selcx: &mut SelectionContext<'a,'tcx>,\n      * type inference.\n      */\n \n+    // if we were stalled on some unresolved variables, first check\n+    // whether any of them have been resolved; if not, don't bother\n+    // doing more work yet\n+    if !pending_obligation.stalled_on.is_empty() {\n+        if pending_obligation.stalled_on.iter().all(|&ty| {\n+            let resolved_ty = selcx.infcx().resolve_type_vars_if_possible(&ty);\n+            resolved_ty == ty // nothing changed here\n+        }) {\n+            debug!(\"process_predicate: pending obligation {:?} still stalled on {:?}\",\n+                   selcx.infcx().resolve_type_vars_if_possible(&pending_obligation.obligation),\n+                   pending_obligation.stalled_on);\n+            return false;\n+        }\n+        pending_obligation.stalled_on = vec![];\n+    }\n+\n+    let obligation = &mut pending_obligation.obligation;\n     match obligation.predicate {\n         ty::Predicate::Trait(ref data) => {\n             let trait_obligation = obligation.with(data.clone());\n             match selcx.select(&trait_obligation) {\n                 Ok(None) => {\n+                    // This is a bit subtle: for the most part, the\n+                    // only reason we can fail to make progress on\n+                    // trait selection is because we don't have enough\n+                    // information about the types in the trait. One\n+                    // exception is that we sometimes haven't decided\n+                    // what kind of closure a closure is. *But*, in\n+                    // that case, it turns out, the type of the\n+                    // closure will also change, because the closure\n+                    // also includes references to its upvars as part\n+                    // of its type, and those types are resolved at\n+                    // the same time.\n+                    pending_obligation.stalled_on =\n+                        data.skip_binder() // ok b/c this check doesn't care about regions\n+                        .input_types()\n+                        .iter()\n+                        .map(|t| selcx.infcx().resolve_type_vars_if_possible(t))\n+                        .filter(|t| t.has_infer_types())\n+                        .flat_map(|t| t.walk())\n+                        .filter(|t| t.is_ty_var())\n+                        .collect();\n+\n+                    debug!(\"process_predicate: pending obligation {:?} now stalled on {:?}\",\n+                           selcx.infcx().resolve_type_vars_if_possible(obligation),\n+                           pending_obligation.stalled_on);\n+\n                     false\n                 }\n                 Ok(Some(s)) => {"}, {"sha": "3b7cb2bd4b4667423fc5651e768104bee8b87e94", "filename": "src/librustc_typeck/check/closure.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82c43432e02de111c3dda56be86d5fc68b538f2e/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82c43432e02de111c3dda56be86d5fc68b538f2e/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fclosure.rs?ref=82c43432e02de111c3dda56be86d5fc68b538f2e", "patch": "@@ -141,6 +141,7 @@ fn deduce_expectations_from_obligations<'a,'tcx>(\n         fulfillment_cx\n         .pending_obligations()\n         .iter()\n+        .map(|obligation| &obligation.obligation)\n         .filter_map(|obligation| {\n             debug!(\"deduce_expectations_from_obligations: obligation.predicate={:?}\",\n                    obligation.predicate);\n@@ -168,6 +169,7 @@ fn deduce_expectations_from_obligations<'a,'tcx>(\n         fulfillment_cx\n         .pending_obligations()\n         .iter()\n+        .map(|obligation| &obligation.obligation)\n         .filter_map(|obligation| {\n             let opt_trait_ref = match obligation.predicate {\n                 ty::Predicate::Projection(ref data) => Some(data.to_poly_trait_ref()),"}, {"sha": "d462e2b45b28121d44d85cfe1d200197c2331834", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82c43432e02de111c3dda56be86d5fc68b538f2e/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82c43432e02de111c3dda56be86d5fc68b538f2e/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=82c43432e02de111c3dda56be86d5fc68b538f2e", "patch": "@@ -261,7 +261,7 @@ pub fn lookup_in_trait_adjusted<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     // FIXME(#18653) -- Try to resolve obligations, giving us more\n     // typing information, which can sometimes be needed to avoid\n     // pathological region inference failures.\n-    fcx.select_new_obligations();\n+    fcx.select_obligations_where_possible();\n \n     // Insert any adjustments needed (always an autoref of some mutability).\n     match self_expr {"}, {"sha": "4de04d99bd9e81bb48076b9084d22b72ee8c47c5", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 2, "deletions": 26, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/82c43432e02de111c3dda56be86d5fc68b538f2e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82c43432e02de111c3dda56be86d5fc68b538f2e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=82c43432e02de111c3dda56be86d5fc68b538f2e", "patch": "@@ -1235,15 +1235,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             return ty;\n         }\n \n-        // If not, try resolving any new fcx obligations that have cropped up.\n-        self.select_new_obligations();\n-        ty = self.infcx().resolve_type_vars_if_possible(&ty);\n-        if !ty.has_infer_types() {\n-            debug!(\"resolve_type_vars_if_possible: ty={:?}\", ty);\n-            return ty;\n-        }\n-\n-        // If not, try resolving *all* pending obligations as much as\n+        // If not, try resolving pending obligations as much as\n         // possible. This can help substantially when there are\n         // indirect dependencies that don't seem worth tracking\n         // precisely.\n@@ -2029,22 +2021,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             Err(errors) => { report_fulfillment_errors(self.infcx(), &errors); }\n         }\n     }\n-\n-    /// Try to select any fcx obligation that we haven't tried yet, in an effort\n-    /// to improve inference. You could just call\n-    /// `select_obligations_where_possible` except that it leads to repeated\n-    /// work.\n-    fn select_new_obligations(&self) {\n-        match\n-            self.inh.infcx.fulfillment_cx\n-            .borrow_mut()\n-            .select_new_obligations(self.infcx())\n-        {\n-            Ok(()) => { }\n-            Err(errors) => { report_fulfillment_errors(self.infcx(), &errors); }\n-        }\n-    }\n-\n }\n \n impl<'a, 'tcx> RegionScope for FnCtxt<'a, 'tcx> {\n@@ -2496,7 +2472,7 @@ fn check_argument_types<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n         // an \"opportunistic\" vtable resolution of any trait bounds on\n         // the call. This helps coercions.\n         if check_blocks {\n-            fcx.select_new_obligations();\n+            fcx.select_obligations_where_possible();\n         }\n \n         // For variadic functions, we don't have a declared type for all of"}]}