{"sha": "47799de35a118ffc5a24a414fd003428f850fae4", "node_id": "C_kwDOAAsO6NoAKDQ3Nzk5ZGUzNWExMThmZmM1YTI0YTQxNGZkMDAzNDI4Zjg1MGZhZTQ", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2021-07-13T22:48:51Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-06-14T20:44:27Z"}, "message": "Separate Definitions and CrateStore from ResolverOutputs.", "tree": {"sha": "883c1c324b6e4d421cd8e678c656fa06c8c6b641", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/883c1c324b6e4d421cd8e678c656fa06c8c6b641"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/47799de35a118ffc5a24a414fd003428f850fae4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/47799de35a118ffc5a24a414fd003428f850fae4", "html_url": "https://github.com/rust-lang/rust/commit/47799de35a118ffc5a24a414fd003428f850fae4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/47799de35a118ffc5a24a414fd003428f850fae4/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "url": "https://api.github.com/repos/rust-lang/rust/commits/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966", "html_url": "https://github.com/rust-lang/rust/commit/1f34da9ec8a85b6f86c5fa1c121ab6f88f2f4966"}], "stats": {"total": 147, "additions": 72, "deletions": 75}, "files": [{"sha": "42520c1d032a14656b603b3e1bf557d880d95bde", "filename": "compiler/rustc_interface/src/passes.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/47799de35a118ffc5a24a414fd003428f850fae4/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47799de35a118ffc5a24a414fd003428f850fae4/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fpasses.rs?ref=47799de35a118ffc5a24a414fd003428f850fae4", "patch": "@@ -13,6 +13,7 @@ use rustc_data_structures::temp_dir::MaybeTempDir;\n use rustc_errors::{Applicability, ErrorGuaranteed, MultiSpan, PResult};\n use rustc_expand::base::{ExtCtxt, LintStoreExpand, ResolverExpand};\n use rustc_hir::def_id::{StableCrateId, LOCAL_CRATE};\n+use rustc_hir::definitions::Definitions;\n use rustc_hir::Crate;\n use rustc_lint::{EarlyCheckNode, LintStore};\n use rustc_metadata::creader::CStore;\n@@ -28,7 +29,7 @@ use rustc_plugin_impl as plugin;\n use rustc_query_impl::{OnDiskCache, Queries as TcxQueries};\n use rustc_resolve::{Resolver, ResolverArenas};\n use rustc_session::config::{CrateType, Input, OutputFilenames, OutputType};\n-use rustc_session::cstore::{MetadataLoader, MetadataLoaderDyn};\n+use rustc_session::cstore::{CrateStoreDyn, MetadataLoader, MetadataLoaderDyn};\n use rustc_session::output::{filename_for_input, filename_for_metadata};\n use rustc_session::search_paths::PathKind;\n use rustc_session::{Limit, Session};\n@@ -136,7 +137,9 @@ mod boxed_resolver {\n             f((&mut *resolver).as_mut().unwrap())\n         }\n \n-        pub fn to_resolver_outputs(resolver: Rc<RefCell<BoxedResolver>>) -> ResolverOutputs {\n+        pub fn to_resolver_outputs(\n+            resolver: Rc<RefCell<BoxedResolver>>,\n+        ) -> (Definitions, Box<CrateStoreDyn>, ResolverOutputs) {\n             match Rc::try_unwrap(resolver) {\n                 Ok(resolver) => {\n                     let mut resolver = resolver.into_inner();\n@@ -826,7 +829,7 @@ pub fn create_global_ctxt<'tcx>(\n     let sess = &compiler.session();\n     let krate =\n         resolver.borrow_mut().access(|resolver| lower_to_hir(sess, resolver, krate, hir_arena));\n-    let resolver_outputs = BoxedResolver::to_resolver_outputs(resolver);\n+    let (definitions, cstore, resolver_outputs) = BoxedResolver::to_resolver_outputs(resolver);\n \n     let query_result_on_disk_cache = rustc_incremental::load_query_result_cache(sess);\n \n@@ -851,6 +854,8 @@ pub fn create_global_ctxt<'tcx>(\n                 sess,\n                 lint_store,\n                 arena,\n+                definitions,\n+                cstore,\n                 resolver_outputs,\n                 krate,\n                 dep_graph,"}, {"sha": "746ab510be8df63550c5348a64cb77c33167953d", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/47799de35a118ffc5a24a414fd003428f850fae4/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47799de35a118ffc5a24a414fd003428f850fae4/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=47799de35a118ffc5a24a414fd003428f850fae4", "patch": "@@ -429,7 +429,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n     }\n \n     fn encode_def_path_table(&mut self) {\n-        let table = self.tcx.resolutions(()).definitions.def_path_table();\n+        let table = self.tcx.definitions_untracked().def_path_table();\n         if self.is_proc_macro {\n             for def_index in std::iter::once(CRATE_DEF_INDEX)\n                 .chain(self.tcx.resolutions(()).proc_macros.iter().map(|p| p.local_def_index))\n@@ -450,7 +450,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n     fn encode_def_path_hash_map(&mut self) -> LazyValue<DefPathHashMapRef<'static>> {\n         self.lazy(DefPathHashMapRef::BorrowedFromTcx(\n-            self.tcx.resolutions(()).definitions.def_path_hash_to_def_index_map(),\n+            self.tcx.definitions_untracked().def_path_hash_to_def_index_map(),\n         ))\n     }\n "}, {"sha": "73aa23ce2b2db380bf45f01724c0752047ebcfaa", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/47799de35a118ffc5a24a414fd003428f850fae4/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47799de35a118ffc5a24a414fd003428f850fae4/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=47799de35a118ffc5a24a414fd003428f850fae4", "patch": "@@ -170,7 +170,7 @@ impl<'hir> Map<'hir> {\n \n     pub fn def_key(self, def_id: LocalDefId) -> DefKey {\n         // Accessing the DefKey is ok, since it is part of DefPathHash.\n-        self.tcx.untracked_resolutions.definitions.def_key(def_id)\n+        self.tcx.definitions_untracked().def_key(def_id)\n     }\n \n     pub fn def_path_from_hir_id(self, id: HirId) -> Option<DefPath> {\n@@ -179,13 +179,13 @@ impl<'hir> Map<'hir> {\n \n     pub fn def_path(self, def_id: LocalDefId) -> DefPath {\n         // Accessing the DefPath is ok, since it is part of DefPathHash.\n-        self.tcx.untracked_resolutions.definitions.def_path(def_id)\n+        self.tcx.definitions_untracked().def_path(def_id)\n     }\n \n     #[inline]\n     pub fn def_path_hash(self, def_id: LocalDefId) -> DefPathHash {\n         // Accessing the DefPathHash is ok, it is incr. comp. stable.\n-        self.tcx.untracked_resolutions.definitions.def_path_hash(def_id)\n+        self.tcx.definitions_untracked().def_path_hash(def_id)\n     }\n \n     #[inline]\n@@ -222,7 +222,7 @@ impl<'hir> Map<'hir> {\n         // Create a dependency to the crate to be sure we re-execute this when the amount of\n         // definitions change.\n         self.tcx.ensure().hir_crate(());\n-        self.tcx.untracked_resolutions.definitions.iter_local_def_id()\n+        self.tcx.definitions_untracked().iter_local_def_id()\n     }\n \n     pub fn opt_def_kind(self, local_def_id: LocalDefId) -> Option<DefKind> {\n@@ -1100,7 +1100,7 @@ pub(super) fn crate_hash(tcx: TyCtxt<'_>, crate_num: CrateNum) -> Svh {\n     upstream_crates.hash_stable(&mut hcx, &mut stable_hasher);\n     source_file_names.hash_stable(&mut hcx, &mut stable_hasher);\n     if tcx.sess.opts.debugging_opts.incremental_relative_spans {\n-        let definitions = &tcx.untracked_resolutions.definitions;\n+        let definitions = &tcx.definitions_untracked();\n         let mut owner_spans: Vec<_> = krate\n             .owners\n             .iter_enumerated()\n@@ -1131,7 +1131,7 @@ fn upstream_crates(tcx: TyCtxt<'_>) -> Vec<(StableCrateId, Svh)> {\n         .crates(())\n         .iter()\n         .map(|&cnum| {\n-            let stable_crate_id = tcx.resolutions(()).cstore.stable_crate_id(cnum);\n+            let stable_crate_id = tcx.stable_crate_id(cnum);\n             let hash = tcx.crate_hash(cnum);\n             (stable_crate_id, hash)\n         })"}, {"sha": "8068e6dff95a6e2248b0bbd215648018d6250e76", "filename": "compiler/rustc_middle/src/hir/mod.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/47799de35a118ffc5a24a414fd003428f850fae4/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47799de35a118ffc5a24a414fd003428f850fae4/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmod.rs?ref=47799de35a118ffc5a24a414fd003428f850fae4", "patch": "@@ -7,7 +7,7 @@ pub mod nested_filter;\n pub mod place;\n \n use crate::ty::query::Providers;\n-use crate::ty::{ImplSubject, TyCtxt};\n+use crate::ty::{DefIdTree, ImplSubject, TyCtxt};\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_hir::def_id::{DefId, LocalDefId};\n@@ -104,23 +104,20 @@ pub fn provide(providers: &mut Providers) {\n     };\n     providers.hir_owner_nodes = |tcx, id| tcx.hir_crate(()).owners[id].map(|i| &i.nodes);\n     providers.hir_owner_parent = |tcx, id| {\n-        // Accessing the def_key is ok since its value is hashed as part of `id`'s DefPathHash.\n-        let parent = tcx.untracked_resolutions.definitions.def_key(id).parent;\n-        let parent = parent.map_or(CRATE_HIR_ID, |local_def_index| {\n-            let def_id = LocalDefId { local_def_index };\n-            let mut parent_hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n+        // Accessing the local_parent is ok since its value is hashed as part of `id`'s DefPathHash.\n+        tcx.opt_local_parent(id).map_or(CRATE_HIR_ID, |parent| {\n+            let mut parent_hir_id = tcx.hir().local_def_id_to_hir_id(parent);\n             if let Some(local_id) =\n                 tcx.hir_crate(()).owners[parent_hir_id.owner].unwrap().parenting.get(&id)\n             {\n                 parent_hir_id.local_id = *local_id;\n             }\n             parent_hir_id\n-        });\n-        parent\n+        })\n     };\n     providers.hir_attrs =\n         |tcx, id| tcx.hir_crate(()).owners[id].as_owner().map_or(AttributeMap::EMPTY, |o| &o.attrs);\n-    providers.source_span = |tcx, def_id| tcx.resolutions(()).definitions.def_span(def_id);\n+    providers.source_span = |tcx, def_id| tcx.definitions_untracked().def_span(def_id);\n     providers.def_span = |tcx, def_id| {\n         let def_id = def_id.expect_local();\n         let hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n@@ -150,7 +147,7 @@ pub fn provide(providers: &mut Providers) {\n     providers.all_local_trait_impls = |tcx, ()| &tcx.resolutions(()).trait_impls;\n     providers.expn_that_defined = |tcx, id| {\n         let id = id.expect_local();\n-        tcx.resolutions(()).definitions.expansion_that_defined(id)\n+        tcx.definitions_untracked().expansion_that_defined(id)\n     };\n     providers.in_scope_traits_map =\n         |tcx, id| tcx.hir_crate(()).owners[id].as_owner().map(|owner_info| &owner_info.trait_map);"}, {"sha": "ce075805aef80b6d996e1aac4c416e9f662c593f", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/47799de35a118ffc5a24a414fd003428f850fae4/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47799de35a118ffc5a24a414fd003428f850fae4/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=47799de35a118ffc5a24a414fd003428f850fae4", "patch": "@@ -31,6 +31,7 @@ rustc_queries! {\n     /// This span is meant for dep-tracking rather than diagnostics. It should not be used outside\n     /// of rustc_middle::hir::source_map.\n     query source_span(key: LocalDefId) -> Span {\n+        eval_always\n         desc { \"get the source span\" }\n     }\n "}, {"sha": "5d020f429c064079085e448f2ce23b84b6ef72bc", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 35, "deletions": 39, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/47799de35a118ffc5a24a414fd003428f850fae4/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47799de35a118ffc5a24a414fd003428f850fae4/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=47799de35a118ffc5a24a414fd003428f850fae4", "patch": "@@ -50,6 +50,7 @@ use rustc_middle::mir::FakeReadCause;\n use rustc_query_system::ich::StableHashingContext;\n use rustc_serialize::opaque::{FileEncodeResult, FileEncoder};\n use rustc_session::config::{CrateType, OutputFilenames};\n+use rustc_session::cstore::CrateStoreDyn;\n use rustc_session::lint::{Level, Lint};\n use rustc_session::Limit;\n use rustc_session::Session;\n@@ -177,7 +178,8 @@ impl<'tcx> CtxtInterners<'tcx> {\n         &self,\n         kind: TyKind<'tcx>,\n         sess: &Session,\n-        resolutions: &ty::ResolverOutputs,\n+        definitions: &rustc_hir::definitions::Definitions,\n+        cstore: &CrateStoreDyn,\n     ) -> Ty<'tcx> {\n         Ty(Interned::new_unchecked(\n             self.type_\n@@ -192,11 +194,7 @@ impl<'tcx> CtxtInterners<'tcx> {\n                         Fingerprint::ZERO\n                     } else {\n                         let mut hasher = StableHasher::new();\n-                        let mut hcx = StableHashingContext::ignore_spans(\n-                            sess,\n-                            &resolutions.definitions,\n-                            &*resolutions.cstore,\n-                        );\n+                        let mut hcx = StableHashingContext::ignore_spans(sess, definitions, cstore);\n                         kind.hash_stable(&mut hcx, &mut hasher);\n                         hasher.finish()\n                     };\n@@ -934,9 +932,10 @@ impl<'tcx> CommonTypes<'tcx> {\n     fn new(\n         interners: &CtxtInterners<'tcx>,\n         sess: &Session,\n-        resolutions: &ty::ResolverOutputs,\n+        definitions: &rustc_hir::definitions::Definitions,\n+        cstore: &CrateStoreDyn,\n     ) -> CommonTypes<'tcx> {\n-        let mk = |ty| interners.intern_ty(ty, sess, resolutions);\n+        let mk = |ty| interners.intern_ty(ty, sess, definitions, cstore);\n \n         CommonTypes {\n             unit: mk(Tuple(List::empty())),\n@@ -1057,6 +1056,9 @@ pub struct GlobalCtxt<'tcx> {\n     /// Common consts, pre-interned for your convenience.\n     pub consts: CommonConsts<'tcx>,\n \n+    definitions: rustc_hir::definitions::Definitions,\n+    cstore: Box<CrateStoreDyn>,\n+\n     /// Output of the resolver.\n     pub(crate) untracked_resolutions: ty::ResolverOutputs,\n \n@@ -1218,7 +1220,9 @@ impl<'tcx> TyCtxt<'tcx> {\n         s: &'tcx Session,\n         lint_store: Lrc<dyn Any + sync::Send + sync::Sync>,\n         arena: &'tcx WorkerLocal<Arena<'tcx>>,\n-        resolutions: ty::ResolverOutputs,\n+        definitions: rustc_hir::definitions::Definitions,\n+        cstore: Box<CrateStoreDyn>,\n+        untracked_resolutions: ty::ResolverOutputs,\n         krate: &'tcx hir::Crate<'tcx>,\n         dep_graph: DepGraph,\n         on_disk_cache: Option<&'tcx dyn OnDiskCache<'tcx>>,\n@@ -1231,7 +1235,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             s.fatal(&err);\n         });\n         let interners = CtxtInterners::new(arena);\n-        let common_types = CommonTypes::new(&interners, s, &resolutions);\n+        let common_types = CommonTypes::new(&interners, s, &definitions, &*cstore);\n         let common_lifetimes = CommonLifetimes::new(&interners);\n         let common_consts = CommonConsts::new(&interners, &common_types);\n \n@@ -1241,7 +1245,9 @@ impl<'tcx> TyCtxt<'tcx> {\n             arena,\n             interners,\n             dep_graph,\n-            untracked_resolutions: resolutions,\n+            definitions,\n+            cstore,\n+            untracked_resolutions,\n             prof: s.prof.clone(),\n             types: common_types,\n             lifetimes: common_lifetimes,\n@@ -1342,9 +1348,9 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn def_key(self, id: DefId) -> rustc_hir::definitions::DefKey {\n         // Accessing the DefKey is ok, since it is part of DefPathHash.\n         if let Some(id) = id.as_local() {\n-            self.untracked_resolutions.definitions.def_key(id)\n+            self.definitions.def_key(id)\n         } else {\n-            self.untracked_resolutions.cstore.def_key(id)\n+            self.cstore.def_key(id)\n         }\n     }\n \n@@ -1356,19 +1362,19 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn def_path(self, id: DefId) -> rustc_hir::definitions::DefPath {\n         // Accessing the DefPath is ok, since it is part of DefPathHash.\n         if let Some(id) = id.as_local() {\n-            self.untracked_resolutions.definitions.def_path(id)\n+            self.definitions.def_path(id)\n         } else {\n-            self.untracked_resolutions.cstore.def_path(id)\n+            self.cstore.def_path(id)\n         }\n     }\n \n     #[inline]\n     pub fn def_path_hash(self, def_id: DefId) -> rustc_hir::definitions::DefPathHash {\n         // Accessing the DefPathHash is ok, it is incr. comp. stable.\n         if let Some(def_id) = def_id.as_local() {\n-            self.untracked_resolutions.definitions.def_path_hash(def_id)\n+            self.definitions.def_path_hash(def_id)\n         } else {\n-            self.untracked_resolutions.cstore.def_path_hash(def_id)\n+            self.cstore.def_path_hash(def_id)\n         }\n     }\n \n@@ -1377,7 +1383,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         if crate_num == LOCAL_CRATE {\n             self.sess.local_stable_crate_id()\n         } else {\n-            self.untracked_resolutions.cstore.stable_crate_id(crate_num)\n+            self.cstore.stable_crate_id(crate_num)\n         }\n     }\n \n@@ -1388,7 +1394,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         if stable_crate_id == self.sess.local_stable_crate_id() {\n             LOCAL_CRATE\n         } else {\n-            self.untracked_resolutions.cstore.stable_crate_id_to_crate_num(stable_crate_id)\n+            self.cstore.stable_crate_id_to_crate_num(stable_crate_id)\n         }\n     }\n \n@@ -1403,16 +1409,12 @@ impl<'tcx> TyCtxt<'tcx> {\n         // If this is a DefPathHash from the local crate, we can look up the\n         // DefId in the tcx's `Definitions`.\n         if stable_crate_id == self.sess.local_stable_crate_id() {\n-            self.untracked_resolutions\n-                .definitions\n-                .local_def_path_hash_to_def_id(hash, err)\n-                .to_def_id()\n+            self.definitions.local_def_path_hash_to_def_id(hash, err).to_def_id()\n         } else {\n             // If this is a DefPathHash from an upstream crate, let the CrateStore map\n             // it to a DefId.\n-            let cstore = &self.untracked_resolutions.cstore;\n-            let cnum = cstore.stable_crate_id_to_crate_num(stable_crate_id);\n-            cstore.def_path_hash_to_def_id(cnum, hash)\n+            let cnum = self.cstore.stable_crate_id_to_crate_num(stable_crate_id);\n+            self.cstore.def_path_hash_to_def_id(cnum, hash)\n         }\n     }\n \n@@ -1424,7 +1426,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         let (crate_name, stable_crate_id) = if def_id.is_local() {\n             (self.crate_name, self.sess.local_stable_crate_id())\n         } else {\n-            let cstore = &self.untracked_resolutions.cstore;\n+            let cstore = &self.cstore;\n             (cstore.crate_name(def_id.krate), cstore.stable_crate_id(def_id.krate))\n         };\n \n@@ -1440,30 +1442,24 @@ impl<'tcx> TyCtxt<'tcx> {\n \n     /// Note that this is *untracked* and should only be used within the query\n     /// system if the result is otherwise tracked through queries\n-    pub fn cstore_untracked(self) -> &'tcx ty::CrateStoreDyn {\n-        &*self.untracked_resolutions.cstore\n+    pub fn cstore_untracked(self) -> &'tcx CrateStoreDyn {\n+        &*self.cstore\n     }\n \n     /// Note that this is *untracked* and should only be used within the query\n     /// system if the result is otherwise tracked through queries\n     pub fn definitions_untracked(self) -> &'tcx hir::definitions::Definitions {\n-        &self.untracked_resolutions.definitions\n+        &self.definitions\n     }\n \n     #[inline(always)]\n     pub fn create_stable_hashing_context(self) -> StableHashingContext<'tcx> {\n-        let resolutions = &self.gcx.untracked_resolutions;\n-        StableHashingContext::new(self.sess, &resolutions.definitions, &*resolutions.cstore)\n+        StableHashingContext::new(self.sess, &self.definitions, &*self.cstore)\n     }\n \n     #[inline(always)]\n     pub fn create_no_span_stable_hashing_context(self) -> StableHashingContext<'tcx> {\n-        let resolutions = &self.gcx.untracked_resolutions;\n-        StableHashingContext::ignore_spans(\n-            self.sess,\n-            &resolutions.definitions,\n-            &*resolutions.cstore,\n-        )\n+        StableHashingContext::ignore_spans(self.sess, &self.definitions, &*self.cstore)\n     }\n \n     pub fn serialize_query_result_cache(self, encoder: FileEncoder) -> FileEncodeResult {\n@@ -2254,7 +2250,7 @@ impl<'tcx> TyCtxt<'tcx> {\n     #[allow(rustc::usage_of_ty_tykind)]\n     #[inline]\n     pub fn mk_ty(self, st: TyKind<'tcx>) -> Ty<'tcx> {\n-        self.interners.intern_ty(st, self.sess, &self.gcx.untracked_resolutions)\n+        self.interners.intern_ty(st, self.sess, &self.definitions, &*self.cstore)\n     }\n \n     #[inline]"}, {"sha": "826d85c1866970b93f0a24ddc7a3b1a6c63950af", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/47799de35a118ffc5a24a414fd003428f850fae4/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47799de35a118ffc5a24a414fd003428f850fae4/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=47799de35a118ffc5a24a414fd003428f850fae4", "patch": "@@ -39,7 +39,6 @@ use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, LocalDefIdMap};\n use rustc_hir::Node;\n use rustc_macros::HashStable;\n use rustc_query_system::ich::StableHashingContext;\n-use rustc_session::cstore::CrateStoreDyn;\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::Span;\n use rustc_target::abi::{Align, VariantIdx};\n@@ -133,8 +132,6 @@ pub type RegisteredTools = FxHashSet<Ident>;\n \n #[derive(Debug)]\n pub struct ResolverOutputs {\n-    pub definitions: rustc_hir::definitions::Definitions,\n-    pub cstore: Box<CrateStoreDyn>,\n     pub visibilities: FxHashMap<LocalDefId, Visibility>,\n     /// This field is used to decide whether we should make `PRIVATE_IN_PUBLIC` a hard error.\n     pub has_pub_restricted: bool,"}, {"sha": "5e8e0e1efe3e1e2b778e372937597240c0475706", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/47799de35a118ffc5a24a414fd003428f850fae4/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/47799de35a118ffc5a24a414fd003428f850fae4/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=47799de35a118ffc5a24a414fd003428f850fae4", "patch": "@@ -47,7 +47,7 @@ use rustc_middle::span_bug;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, DefIdTree, MainDefinition, RegisteredTools, ResolverOutputs};\n use rustc_query_system::ich::StableHashingContext;\n-use rustc_session::cstore::{CrateStore, MetadataLoaderDyn};\n+use rustc_session::cstore::{CrateStore, CrateStoreDyn, MetadataLoaderDyn};\n use rustc_session::lint::LintBuffer;\n use rustc_session::Session;\n use rustc_span::hygiene::{ExpnId, LocalExpnId, MacroKind, SyntaxContext, Transparency};\n@@ -1439,9 +1439,10 @@ impl<'a> Resolver<'a> {\n         Default::default()\n     }\n \n-    pub fn into_outputs(self) -> ResolverOutputs {\n+    pub fn into_outputs(self) -> (Definitions, Box<CrateStoreDyn>, ResolverOutputs) {\n         let proc_macros = self.proc_macros.iter().map(|id| self.local_def_id(*id)).collect();\n         let definitions = self.definitions;\n+        let cstore = Box::new(self.crate_loader.into_cstore());\n         let visibilities = self.visibilities;\n         let has_pub_restricted = self.has_pub_restricted;\n         let extern_crate_map = self.extern_crate_map;\n@@ -1452,9 +1453,7 @@ impl<'a> Resolver<'a> {\n         let main_def = self.main_def;\n         let confused_type_with_std_module = self.confused_type_with_std_module;\n         let access_levels = self.access_levels;\n-        ResolverOutputs {\n-            definitions,\n-            cstore: Box::new(self.crate_loader.into_cstore()),\n+        let resolutions = ResolverOutputs {\n             visibilities,\n             has_pub_restricted,\n             access_levels,\n@@ -1473,15 +1472,15 @@ impl<'a> Resolver<'a> {\n             proc_macros,\n             confused_type_with_std_module,\n             registered_tools: self.registered_tools,\n-        }\n+        };\n+        (definitions, cstore, resolutions)\n     }\n \n-    pub fn clone_outputs(&self) -> ResolverOutputs {\n+    pub fn clone_outputs(&self) -> (Definitions, Box<CrateStoreDyn>, ResolverOutputs) {\n         let proc_macros = self.proc_macros.iter().map(|id| self.local_def_id(*id)).collect();\n-        ResolverOutputs {\n-            definitions: self.definitions.clone(),\n-            access_levels: self.access_levels.clone(),\n-            cstore: Box::new(self.cstore().clone()),\n+        let definitions = self.definitions.clone();\n+        let cstore = Box::new(self.cstore().clone());\n+        let resolutions = ResolverOutputs {\n             visibilities: self.visibilities.clone(),\n             has_pub_restricted: self.has_pub_restricted,\n             extern_crate_map: self.extern_crate_map.clone(),\n@@ -1499,7 +1498,9 @@ impl<'a> Resolver<'a> {\n             proc_macros,\n             confused_type_with_std_module: self.confused_type_with_std_module.clone(),\n             registered_tools: self.registered_tools.clone(),\n-        }\n+            access_levels: self.access_levels.clone(),\n+        };\n+        (definitions, cstore, resolutions)\n     }\n \n     pub fn cstore(&self) -> &CStore {"}]}