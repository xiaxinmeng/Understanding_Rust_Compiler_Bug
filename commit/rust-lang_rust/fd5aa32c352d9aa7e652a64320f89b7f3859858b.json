{"sha": "fd5aa32c352d9aa7e652a64320f89b7f3859858b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZkNWFhMzJjMzUyZDlhYTdlNjUyYTY0MzIwZjg5YjdmMzg1OTg1OGI=", "commit": {"author": {"name": "Santiago Pastorino", "email": "spastorino@gmail.com", "date": "2019-12-11T13:39:24Z"}, "committer": {"name": "Oliver Scherer", "email": "github35764891676564198441@oli-obk.de", "date": "2020-01-10T08:08:24Z"}, "message": "Remove Static from PlaceBase", "tree": {"sha": "d8f3068aa129d83428f3268019dd5b9d7fe226cf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d8f3068aa129d83428f3268019dd5b9d7fe226cf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fd5aa32c352d9aa7e652a64320f89b7f3859858b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fd5aa32c352d9aa7e652a64320f89b7f3859858b", "html_url": "https://github.com/rust-lang/rust/commit/fd5aa32c352d9aa7e652a64320f89b7f3859858b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fd5aa32c352d9aa7e652a64320f89b7f3859858b/comments", "author": {"login": "spastorino", "id": 52642, "node_id": "MDQ6VXNlcjUyNjQy", "avatar_url": "https://avatars.githubusercontent.com/u/52642?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spastorino", "html_url": "https://github.com/spastorino", "followers_url": "https://api.github.com/users/spastorino/followers", "following_url": "https://api.github.com/users/spastorino/following{/other_user}", "gists_url": "https://api.github.com/users/spastorino/gists{/gist_id}", "starred_url": "https://api.github.com/users/spastorino/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spastorino/subscriptions", "organizations_url": "https://api.github.com/users/spastorino/orgs", "repos_url": "https://api.github.com/users/spastorino/repos", "events_url": "https://api.github.com/users/spastorino/events{/privacy}", "received_events_url": "https://api.github.com/users/spastorino/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9e70c4778371130ecc9ac5f1aff24000411eabd8", "url": "https://api.github.com/repos/rust-lang/rust/commits/9e70c4778371130ecc9ac5f1aff24000411eabd8", "html_url": "https://github.com/rust-lang/rust/commit/9e70c4778371130ecc9ac5f1aff24000411eabd8"}], "stats": {"total": 645, "additions": 193, "deletions": 452}, "files": [{"sha": "05bb1d9698016ebd380f2ced2093484b25b54bea", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 6, "deletions": 48, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/fd5aa32c352d9aa7e652a64320f89b7f3859858b/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd5aa32c352d9aa7e652a64320f89b7f3859858b/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=fd5aa32c352d9aa7e652a64320f89b7f3859858b", "patch": "@@ -1655,7 +1655,7 @@ impl Debug for Statement<'_> {\n /// changing or disturbing program state.\n #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, HashStable)]\n pub struct Place<'tcx> {\n-    pub base: PlaceBase<'tcx>,\n+    pub base: PlaceBase,\n \n     /// projection out of a place (access a field, deref a pointer, etc)\n     pub projection: &'tcx List<PlaceElem<'tcx>>,\n@@ -1664,34 +1664,9 @@ pub struct Place<'tcx> {\n impl<'tcx> rustc_serialize::UseSpecializedDecodable for Place<'tcx> {}\n \n #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable, HashStable)]\n-pub enum PlaceBase<'tcx> {\n+pub enum PlaceBase {\n     /// local variable\n     Local(Local),\n-\n-    /// static or static mut variable\n-    Static(Box<Static<'tcx>>),\n-}\n-\n-/// We store the normalized type to avoid requiring normalization when reading MIR\n-#[derive(\n-    Clone,\n-    Debug,\n-    PartialEq,\n-    Eq,\n-    PartialOrd,\n-    Ord,\n-    Hash,\n-    RustcEncodable,\n-    RustcDecodable,\n-    HashStable\n-)]\n-pub struct Static<'tcx> {\n-    pub ty: Ty<'tcx>,\n-    /// The `DefId` of the item this static was declared in. For promoted values, usually, this is\n-    /// the same as the `DefId` of the `mir::Body` containing the `Place` this promoted appears in.\n-    /// However, after inlining, that might no longer be the case as inlined `Place`s are copied\n-    /// into the calling frame.\n-    pub def_id: DefId,\n }\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n@@ -1781,7 +1756,7 @@ rustc_index::newtype_index! {\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub struct PlaceRef<'a, 'tcx> {\n-    pub base: &'a PlaceBase<'tcx>,\n+    pub base: &'a PlaceBase,\n     pub projection: &'a [PlaceElem<'tcx>],\n }\n \n@@ -1830,7 +1805,7 @@ impl From<Local> for Place<'_> {\n     }\n }\n \n-impl From<Local> for PlaceBase<'_> {\n+impl From<Local> for PlaceBase {\n     fn from(local: Local) -> Self {\n         PlaceBase::Local(local)\n     }\n@@ -1921,13 +1896,10 @@ impl Debug for Place<'_> {\n     }\n }\n \n-impl Debug for PlaceBase<'_> {\n+impl Debug for PlaceBase {\n     fn fmt(&self, fmt: &mut Formatter<'_>) -> fmt::Result {\n         match *self {\n             PlaceBase::Local(id) => write!(fmt, \"{:?}\", id),\n-            PlaceBase::Static(box self::Static { ty, def_id }) => {\n-                write!(fmt, \"({}: {:?})\", ty::tls::with(|tcx| tcx.def_path_str(def_id)), ty)\n-            }\n         }\n     }\n }\n@@ -3000,18 +2972,16 @@ impl<'tcx> TypeFoldable<'tcx> for Place<'tcx> {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for PlaceBase<'tcx> {\n+impl<'tcx> TypeFoldable<'tcx> for PlaceBase {\n     fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n         match self {\n             PlaceBase::Local(local) => PlaceBase::Local(local.fold_with(folder)),\n-            PlaceBase::Static(static_) => PlaceBase::Static(static_.fold_with(folder)),\n         }\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n         match self {\n             PlaceBase::Local(local) => local.visit_with(visitor),\n-            PlaceBase::Static(static_) => (**static_).visit_with(visitor),\n         }\n     }\n }\n@@ -3027,18 +2997,6 @@ impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<PlaceElem<'tcx>> {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for Static<'tcx> {\n-    fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n-        Static { ty: self.ty.fold_with(folder), def_id: self.def_id }\n-    }\n-\n-    fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> bool {\n-        let Static { ty, def_id: _ } = self;\n-\n-        ty.visit_with(visitor)\n-    }\n-}\n-\n impl<'tcx> TypeFoldable<'tcx> for Rvalue<'tcx> {\n     fn super_fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> Self {\n         use crate::mir::Rvalue::*;"}, {"sha": "5adf6447d39816a16bb761813abcf1f19744ff1e", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fd5aa32c352d9aa7e652a64320f89b7f3859858b/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd5aa32c352d9aa7e652a64320f89b7f3859858b/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=fd5aa32c352d9aa7e652a64320f89b7f3859858b", "patch": "@@ -114,7 +114,7 @@ impl<'tcx> PlaceTy<'tcx> {\n \n impl<'tcx> Place<'tcx> {\n     pub fn ty_from<D>(\n-        base: &PlaceBase<'tcx>,\n+        base: &PlaceBase,\n         projection: &[PlaceElem<'tcx>],\n         local_decls: &D,\n         tcx: TyCtxt<'tcx>,\n@@ -135,14 +135,13 @@ impl<'tcx> Place<'tcx> {\n     }\n }\n \n-impl<'tcx> PlaceBase<'tcx> {\n+impl<'tcx> PlaceBase {\n     pub fn ty<D>(&self, local_decls: &D) -> PlaceTy<'tcx>\n     where\n         D: HasLocalDecls<'tcx>,\n     {\n         match self {\n             PlaceBase::Local(index) => PlaceTy::from_ty(local_decls.local_decls()[*index].ty),\n-            PlaceBase::Static(data) => PlaceTy::from_ty(data.ty),\n         }\n     }\n }"}, {"sha": "a31931c8a99bcde2adac3aed60f9d391ac07ba73", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fd5aa32c352d9aa7e652a64320f89b7f3859858b/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd5aa32c352d9aa7e652a64320f89b7f3859858b/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=fd5aa32c352d9aa7e652a64320f89b7f3859858b", "patch": "@@ -164,7 +164,7 @@ macro_rules! make_mir_visitor {\n             }\n \n             fn visit_place_base(&mut self,\n-                                base: & $($mutability)? PlaceBase<'tcx>,\n+                                base: & $($mutability)? PlaceBase,\n                                 context: PlaceContext,\n                                 location: Location) {\n                 self.super_place_base(base, context, location);\n@@ -705,16 +705,13 @@ macro_rules! make_mir_visitor {\n             }\n \n             fn super_place_base(&mut self,\n-                                place_base: & $($mutability)? PlaceBase<'tcx>,\n+                                place_base: & $($mutability)? PlaceBase,\n                                 context: PlaceContext,\n                                 location: Location) {\n                 match place_base {\n                     PlaceBase::Local(local) => {\n                         self.visit_local(local, context, location);\n                     }\n-                    PlaceBase::Static(box Static { ty, def_id: _ }) => {\n-                        self.visit_ty(& $($mutability)? *ty, TyContext::Location(location));\n-                    }\n                 }\n             }\n \n@@ -889,7 +886,7 @@ macro_rules! visit_place_fns {\n     () => (\n         fn visit_projection(\n             &mut self,\n-            base: &PlaceBase<'tcx>,\n+            base: &PlaceBase,\n             projection: &[PlaceElem<'tcx>],\n             context: PlaceContext,\n             location: Location,\n@@ -899,7 +896,7 @@ macro_rules! visit_place_fns {\n \n         fn visit_projection_elem(\n             &mut self,\n-            base: &PlaceBase<'tcx>,\n+            base: &PlaceBase,\n             proj_base: &[PlaceElem<'tcx>],\n             elem: &PlaceElem<'tcx>,\n             context: PlaceContext,\n@@ -934,7 +931,7 @@ macro_rules! visit_place_fns {\n \n         fn super_projection(\n             &mut self,\n-            base: &PlaceBase<'tcx>,\n+            base: &PlaceBase,\n             projection: &[PlaceElem<'tcx>],\n             context: PlaceContext,\n             location: Location,\n@@ -948,7 +945,7 @@ macro_rules! visit_place_fns {\n \n         fn super_projection_elem(\n             &mut self,\n-            _base: &PlaceBase<'tcx>,\n+            _base: &PlaceBase,\n             _proj_base: &[PlaceElem<'tcx>],\n             elem: &PlaceElem<'tcx>,\n             _context: PlaceContext,"}, {"sha": "c691cb44f011832affa64c53f08bb8eeac68087e", "filename": "src/librustc/ty/codec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd5aa32c352d9aa7e652a64320f89b7f3859858b/src%2Flibrustc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd5aa32c352d9aa7e652a64320f89b7f3859858b/src%2Flibrustc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcodec.rs?ref=fd5aa32c352d9aa7e652a64320f89b7f3859858b", "patch": "@@ -226,7 +226,7 @@ pub fn decode_place<D>(decoder: &mut D) -> Result<mir::Place<'tcx>, D::Error>\n where\n     D: TyDecoder<'tcx>,\n {\n-    let base: mir::PlaceBase<'tcx> = Decodable::decode(decoder)?;\n+    let base: mir::PlaceBase = Decodable::decode(decoder)?;\n     let len = decoder.read_usize()?;\n     let projection: &'tcx List<mir::PlaceElem<'tcx>> =\n         decoder.tcx().mk_place_elems((0..len).map(|_| Decodable::decode(decoder)))?;"}, {"sha": "7b9bc923cd6fdcafdb9d0729ac6a39e4f995815a", "filename": "src/librustc_codegen_ssa/mir/analyze.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fd5aa32c352d9aa7e652a64320f89b7f3859858b/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd5aa32c352d9aa7e652a64320f89b7f3859858b/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs?ref=fd5aa32c352d9aa7e652a64320f89b7f3859858b", "patch": "@@ -14,7 +14,6 @@ use rustc::ty::layout::{HasTyCtxt, LayoutOf};\n use rustc_data_structures::graph::dominators::Dominators;\n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::{Idx, IndexVec};\n-use rustc_span::DUMMY_SP;\n \n pub fn non_ssa_locals<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n     fx: &FunctionCx<'a, 'tcx, Bx>,\n@@ -135,10 +134,10 @@ impl<Bx: BuilderMethods<'a, 'tcx>> LocalAnalyzer<'mir, 'a, 'tcx, Bx> {\n                 // ZSTs don't require any actual memory access.\n                 let elem_ty = base_ty.projection_ty(cx.tcx(), elem).ty;\n                 let elem_ty = self.fx.monomorphize(&elem_ty);\n-                let span = if let mir::PlaceBase::Local(index) = place_ref.base {\n-                    self.fx.mir.local_decls[*index].source_info.span\n-                } else {\n-                    DUMMY_SP\n+                let span = match place_ref.base {\n+                    mir::PlaceBase::Local(index) => {\n+                        self.fx.mir.local_decls[*index].source_info.span\n+                    }\n                 };\n                 if cx.spanned_layout_of(elem_ty, span).is_zst() {\n                     return;\n@@ -179,8 +178,8 @@ impl<Bx: BuilderMethods<'a, 'tcx>> LocalAnalyzer<'mir, 'a, 'tcx, Bx> {\n                     // We use `NonUseContext::VarDebugInfo` for the base,\n                     // which might not force the base local to memory,\n                     // so we have to do it manually.\n-                    if let mir::PlaceBase::Local(local) = place_ref.base {\n-                        self.visit_local(&local, context, location);\n+                    match place_ref.base {\n+                        mir::PlaceBase::Local(local) => self.visit_local(&local, context, location),\n                     }\n                 }\n             }"}, {"sha": "88e43c7f5352835e1b641c0f143720ef9a46a175", "filename": "src/librustc_codegen_ssa/mir/debuginfo.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fd5aa32c352d9aa7e652a64320f89b7f3859858b/src%2Flibrustc_codegen_ssa%2Fmir%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd5aa32c352d9aa7e652a64320f89b7f3859858b/src%2Flibrustc_codegen_ssa%2Fmir%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fdebuginfo.rs?ref=fd5aa32c352d9aa7e652a64320f89b7f3859858b", "patch": "@@ -258,8 +258,8 @@ pub fn per_local_var_debug_info(\n     if tcx.sess.opts.debuginfo == DebugInfo::Full || !tcx.sess.fewer_names() {\n         let mut per_local = IndexVec::from_elem(vec![], &body.local_decls);\n         for var in &body.var_debug_info {\n-            if let mir::PlaceBase::Local(local) = var.place.base {\n-                per_local[local].push(var);\n+            match var.place.base {\n+                mir::PlaceBase::Local(local) => per_local[local].push(var),\n             }\n         }\n         Some(per_local)"}, {"sha": "be6e05b948c7cb6b93dd30e6a1de186b8ff66d9e", "filename": "src/librustc_codegen_ssa/mir/operand.rs", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/fd5aa32c352d9aa7e652a64320f89b7f3859858b/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd5aa32c352d9aa7e652a64320f89b7f3859858b/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs?ref=fd5aa32c352d9aa7e652a64320f89b7f3859858b", "patch": "@@ -373,44 +373,44 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     ) -> Option<OperandRef<'tcx, Bx::Value>> {\n         debug!(\"maybe_codegen_consume_direct(place_ref={:?})\", place_ref);\n \n-        if let mir::PlaceBase::Local(index) = place_ref.base {\n-            match self.locals[*index] {\n-                LocalRef::Operand(Some(mut o)) => {\n-                    // Moves out of scalar and scalar pair fields are trivial.\n-                    for elem in place_ref.projection.iter() {\n-                        match elem {\n-                            mir::ProjectionElem::Field(ref f, _) => {\n-                                o = o.extract_field(bx, f.index());\n-                            }\n-                            mir::ProjectionElem::Index(_)\n-                            | mir::ProjectionElem::ConstantIndex { .. } => {\n-                                // ZSTs don't require any actual memory access.\n-                                // FIXME(eddyb) deduplicate this with the identical\n-                                // checks in `codegen_consume` and `extract_field`.\n-                                let elem = o.layout.field(bx.cx(), 0);\n-                                if elem.is_zst() {\n-                                    o = OperandRef::new_zst(bx, elem);\n-                                } else {\n-                                    return None;\n+        match place_ref.base {\n+            mir::PlaceBase::Local(index) => {\n+                match self.locals[*index] {\n+                    LocalRef::Operand(Some(mut o)) => {\n+                        // Moves out of scalar and scalar pair fields are trivial.\n+                        for elem in place_ref.projection.iter() {\n+                            match elem {\n+                                mir::ProjectionElem::Field(ref f, _) => {\n+                                    o = o.extract_field(bx, f.index());\n+                                }\n+                                mir::ProjectionElem::Index(_)\n+                                | mir::ProjectionElem::ConstantIndex { .. } => {\n+                                    // ZSTs don't require any actual memory access.\n+                                    // FIXME(eddyb) deduplicate this with the identical\n+                                    // checks in `codegen_consume` and `extract_field`.\n+                                    let elem = o.layout.field(bx.cx(), 0);\n+                                    if elem.is_zst() {\n+                                        o = OperandRef::new_zst(bx, elem);\n+                                    } else {\n+                                        return None;\n+                                    }\n                                 }\n+                                _ => return None,\n                             }\n-                            _ => return None,\n                         }\n-                    }\n \n-                    Some(o)\n-                }\n-                LocalRef::Operand(None) => {\n-                    bug!(\"use of {:?} before def\", place_ref);\n-                }\n-                LocalRef::Place(..) | LocalRef::UnsizedPlace(..) => {\n-                    // watch out for locals that do not have an\n-                    // alloca; they are handled somewhat differently\n-                    None\n+                        Some(o)\n+                    }\n+                    LocalRef::Operand(None) => {\n+                        bug!(\"use of {:?} before def\", place_ref);\n+                    }\n+                    LocalRef::Place(..) | LocalRef::UnsizedPlace(..) => {\n+                        // watch out for locals that do not have an\n+                        // alloca; they are handled somewhat differently\n+                        None\n+                    }\n                 }\n             }\n-        } else {\n-            None\n         }\n     }\n "}, {"sha": "3d94cf9aa2c4665e6173f9f38d1dbdf2610abca7", "filename": "src/librustc_codegen_ssa/mir/place.rs", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fd5aa32c352d9aa7e652a64320f89b7f3859858b/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd5aa32c352d9aa7e652a64320f89b7f3859858b/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs?ref=fd5aa32c352d9aa7e652a64320f89b7f3859858b", "patch": "@@ -37,15 +37,6 @@ impl<'a, 'tcx, V: CodegenObject> PlaceRef<'tcx, V> {\n         PlaceRef { llval, llextra: None, layout, align }\n     }\n \n-    fn new_thin_place<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n-        bx: &mut Bx,\n-        llval: V,\n-        layout: TyLayout<'tcx>,\n-    ) -> PlaceRef<'tcx, V> {\n-        assert!(!bx.cx().type_has_metadata(layout.ty));\n-        PlaceRef { llval, llextra: None, layout, align: layout.align.abi }\n-    }\n-\n     // FIXME(eddyb) pass something else for the name so no work is done\n     // unless LLVM IR names are turned on (e.g. for `--emit=llvm-ir`).\n     pub fn alloca<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n@@ -437,16 +428,6 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     }\n                 }\n             }\n-            mir::PlaceRef {\n-                base: mir::PlaceBase::Static(box mir::Static { ty, def_id }),\n-                projection: [],\n-            } => {\n-                // NB: The layout of a static may be unsized as is the case when working\n-                // with a static that is an extern_type.\n-                let layout = cx.layout_of(self.monomorphize(&ty));\n-                let static_ = bx.get_static(*def_id);\n-                PlaceRef::new_thin_place(bx, static_, layout)\n-            }\n             mir::PlaceRef { base, projection: [proj_base @ .., mir::ProjectionElem::Deref] } => {\n                 // Load the pointer from its location.\n                 self.codegen_consume(bx, &mir::PlaceRef { base, projection: proj_base })"}, {"sha": "4c6b9bc02a4ba4763aaae2e4910a721e8daf230f", "filename": "src/librustc_mir/borrow_check/borrow_set.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fd5aa32c352d9aa7e652a64320f89b7f3859858b/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd5aa32c352d9aa7e652a64320f89b7f3859858b/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs?ref=fd5aa32c352d9aa7e652a64320f89b7f3859858b", "patch": "@@ -208,8 +208,10 @@ impl<'a, 'tcx> Visitor<'tcx> for GatherBorrows<'a, 'tcx> {\n \n             self.insert_as_pending_if_two_phase(location, &assigned_place, kind, idx);\n \n-            if let mir::PlaceBase::Local(local) = borrowed_place.base {\n-                self.local_map.entry(local).or_default().insert(idx);\n+            match borrowed_place.base {\n+                mir::PlaceBase::Local(local) => {\n+                    self.local_map.entry(local).or_default().insert(idx);\n+                }\n             }\n         }\n "}, {"sha": "2a9ad6a1505daf1057d8c569b259f64399100607", "filename": "src/librustc_mir/borrow_check/constraint_generation.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fd5aa32c352d9aa7e652a64320f89b7f3859858b/src%2Flibrustc_mir%2Fborrow_check%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd5aa32c352d9aa7e652a64320f89b7f3859858b/src%2Flibrustc_mir%2Fborrow_check%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fconstraint_generation.rs?ref=fd5aa32c352d9aa7e652a64320f89b7f3859858b", "patch": "@@ -207,10 +207,6 @@ impl<'cx, 'cg, 'tcx> ConstraintGeneration<'cx, 'cg, 'tcx> {\n                     );\n                 }\n \n-                PlaceRef { base: &PlaceBase::Static(_), .. } => {\n-                    // Ignore kills of static or static mut variables.\n-                }\n-\n                 PlaceRef { base: &PlaceBase::Local(local), projection: &[.., _] } => {\n                     // Kill conflicting borrows of the innermost local.\n                     debug!("}, {"sha": "dc3157f6b4d9cf5b689488f838b2b62728936c63", "filename": "src/librustc_mir/borrow_check/diagnostics/conflict_errors.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fd5aa32c352d9aa7e652a64320f89b7f3859858b/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd5aa32c352d9aa7e652a64320f89b7f3859858b/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs?ref=fd5aa32c352d9aa7e652a64320f89b7f3859858b", "patch": "@@ -688,7 +688,6 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         assert!(root_place.projection.is_empty());\n         let proper_span = match root_place.base {\n             PlaceBase::Local(local) => self.body.local_decls[*local].source_info.span,\n-            _ => drop_span,\n         };\n \n         let root_place_projection = self.infcx.tcx.intern_place_elems(root_place.projection);\n@@ -709,12 +708,16 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             borrow_span,\n         ));\n \n-        if let PlaceBase::Local(local) = borrow.borrowed_place.base {\n-            if self.body.local_decls[local].is_ref_to_thread_local() {\n-                let err = self\n-                    .report_thread_local_value_does_not_live_long_enough(drop_span, borrow_span);\n-                err.buffer(&mut self.errors_buffer);\n-                return;\n+        match borrow.borrowed_place.base {\n+            PlaceBase::Local(local) => {\n+                if self.body.local_decls[local].is_ref_to_thread_local() {\n+                    let err = self.report_thread_local_value_does_not_live_long_enough(\n+                        drop_span,\n+                        borrow_span,\n+                    );\n+                    err.buffer(&mut self.errors_buffer);\n+                    return;\n+                }\n             }\n         };\n "}, {"sha": "38c479c72c1e782a35ad6f53ae6412c356a8a6e7", "filename": "src/librustc_mir/borrow_check/diagnostics/mod.rs", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fd5aa32c352d9aa7e652a64320f89b7f3859858b/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd5aa32c352d9aa7e652a64320f89b7f3859858b/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmod.rs?ref=fd5aa32c352d9aa7e652a64320f89b7f3859858b", "patch": "@@ -2,7 +2,7 @@\n \n use rustc::mir::{\n     AggregateKind, Constant, Field, Local, LocalInfo, LocalKind, Location, Operand, Place,\n-    PlaceBase, PlaceRef, ProjectionElem, Rvalue, Statement, StatementKind, Static, Terminator,\n+    PlaceBase, PlaceRef, ProjectionElem, Rvalue, Statement, StatementKind, Terminator,\n     TerminatorKind,\n };\n use rustc::ty::layout::VariantIdx;\n@@ -172,9 +172,6 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             PlaceRef { base: PlaceBase::Local(local), projection: [] } => {\n                 self.append_local_to_string(*local, buf)?;\n             }\n-            PlaceRef { base: PlaceBase::Static(box Static { def_id, .. }), projection: [] } => {\n-                buf.push_str(&self.infcx.tcx.item_name(*def_id).to_string());\n-            }\n             PlaceRef { base: &PlaceBase::Local(local), projection: [ProjectionElem::Deref] }\n                 if self.body.local_decls[local].is_ref_for_guard() =>\n             {\n@@ -318,9 +315,6 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 let local = &self.body.local_decls[*local];\n                 self.describe_field_from_ty(&local.ty, field, None)\n             }\n-            PlaceRef { base: PlaceBase::Static(static_), projection: [] } => {\n-                self.describe_field_from_ty(&static_.ty, field, None)\n-            }\n             PlaceRef { base, projection: [proj_base @ .., elem] } => match elem {\n                 ProjectionElem::Deref => {\n                     self.describe_field(PlaceRef { base, projection: proj_base }, field)"}, {"sha": "ceb97a98f1f7e157abc41bf772f94f6f14929a11", "filename": "src/librustc_mir/borrow_check/diagnostics/move_errors.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fd5aa32c352d9aa7e652a64320f89b7f3859858b/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd5aa32c352d9aa7e652a64320f89b7f3859858b/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs?ref=fd5aa32c352d9aa7e652a64320f89b7f3859858b", "patch": "@@ -243,9 +243,6 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n             );\n             (\n                 match kind {\n-                    IllegalMoveOriginKind::Static => {\n-                        unreachable!();\n-                    }\n                     IllegalMoveOriginKind::BorrowedContent { target_place } => self\n                         .report_cannot_move_from_borrowed_content(\n                             original_path,"}, {"sha": "e81a012cef59ab8cefede0ead12c2de4627f5f17", "filename": "src/librustc_mir/borrow_check/diagnostics/mutability_errors.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fd5aa32c352d9aa7e652a64320f89b7f3859858b/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd5aa32c352d9aa7e652a64320f89b7f3859858b/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs?ref=fd5aa32c352d9aa7e652a64320f89b7f3859858b", "patch": "@@ -136,8 +136,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 }\n             }\n \n-            PlaceRef { base: PlaceBase::Static(_), .. }\n-            | PlaceRef { base: _, projection: [.., ProjectionElem::Index(_)] }\n+            PlaceRef { base: _, projection: [.., ProjectionElem::Index(_)] }\n             | PlaceRef { base: _, projection: [.., ProjectionElem::ConstantIndex { .. }] }\n             | PlaceRef { base: _, projection: [.., ProjectionElem::Subslice { .. }] }\n             | PlaceRef { base: _, projection: [.., ProjectionElem::Downcast(..)] } => {"}, {"sha": "d0b0a159e86646a4cc8d7de8b85ef6e4ffc49edb", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 31, "deletions": 55, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/fd5aa32c352d9aa7e652a64320f89b7f3859858b/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd5aa32c352d9aa7e652a64320f89b7f3859858b/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=fd5aa32c352d9aa7e652a64320f89b7f3859858b", "patch": "@@ -5,7 +5,7 @@ use rustc::lint::builtin::MUTABLE_BORROW_RESERVATION_CONFLICT;\n use rustc::lint::builtin::UNUSED_MUT;\n use rustc::mir::{\n     read_only, Body, BodyAndCache, ClearCrossCrate, Local, Location, Mutability, Operand, Place,\n-    PlaceBase, PlaceElem, PlaceRef, ReadOnlyBodyAndCache, Static,\n+    PlaceBase, PlaceElem, PlaceRef, ReadOnlyBodyAndCache,\n };\n use rustc::mir::{AggregateKind, BasicBlock, BorrowCheckResult, BorrowKind};\n use rustc::mir::{Field, ProjectionElem, Promoted, Rvalue, Statement, StatementKind};\n@@ -815,7 +815,7 @@ enum InitializationRequiringAction {\n }\n \n struct RootPlace<'d, 'tcx> {\n-    place_base: &'d PlaceBase<'tcx>,\n+    place_base: &'d PlaceBase,\n     place_projection: &'d [PlaceElem<'tcx>],\n     is_local_mutation_allowed: LocalMutationIsAllowed,\n }\n@@ -1251,8 +1251,12 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 if let Some(field) = this.is_upvar_field_projection(place.as_ref()) {\n                     this.used_mut_upvars.push(field);\n                 }\n-            } else if let PlaceBase::Local(local) = place.base {\n-                this.used_mut.insert(local);\n+            } else {\n+                match place.base {\n+                    PlaceBase::Local(local) => {\n+                        this.used_mut.insert(local);\n+                    }\n+                }\n             }\n         };\n \n@@ -1385,7 +1389,6 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         // FIXME: allow thread-locals to borrow other thread locals?\n \n         let (might_be_alive, will_be_dropped) = match root_place.base {\n-            PlaceBase::Static(_) => (true, false),\n             PlaceBase::Local(local) => {\n                 if self.body.local_decls[*local].is_ref_to_thread_local() {\n                     // Thread-locals might be dropped after the function exits\n@@ -1649,26 +1652,20 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         // This code covers scenarios 1, 2, and 3.\n \n         debug!(\"check_if_full_path_is_moved place: {:?}\", place_span.0);\n-        match self.move_path_closest_to(place_span.0) {\n-            Ok((prefix, mpi)) => {\n-                if maybe_uninits.contains(mpi) {\n-                    self.report_use_of_moved_or_uninitialized(\n-                        location,\n-                        desired_action,\n-                        (prefix, place_span.0, place_span.1),\n-                        mpi,\n-                    );\n-                }\n-            }\n-            Err(NoMovePathFound::ReachedStatic) => {\n-                // Okay: we do not build MoveData for static variables\n-            } // Only query longest prefix with a MovePath, not further\n-              // ancestors; dataflow recurs on children when parents\n-              // move (to support partial (re)inits).\n-              //\n-              // (I.e., querying parents breaks scenario 7; but may want\n-              // to do such a query based on partial-init feature-gate.)\n-        }\n+        let (prefix, mpi) = self.move_path_closest_to(place_span.0);\n+        if maybe_uninits.contains(mpi) {\n+            self.report_use_of_moved_or_uninitialized(\n+                location,\n+                desired_action,\n+                (prefix, place_span.0, place_span.1),\n+                mpi,\n+            );\n+        } // Only query longest prefix with a MovePath, not further\n+        // ancestors; dataflow recurs on children when parents\n+        // move (to support partial (re)inits).\n+        //\n+        // (I.e., querying parents breaks scenario 7; but may want\n+        // to do such a query based on partial-init feature-gate.)\n     }\n \n     /// Subslices correspond to multiple move paths, so we iterate through the\n@@ -1792,12 +1789,12 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     fn move_path_closest_to(\n         &mut self,\n         place: PlaceRef<'_, 'tcx>,\n-    ) -> Result<(PlaceRef<'cx, 'tcx>, MovePathIndex), NoMovePathFound> {\n+    ) -> (PlaceRef<'cx, 'tcx>, MovePathIndex) {\n         match self.move_data.rev_lookup.find(place) {\n             LookupResult::Parent(Some(mpi)) | LookupResult::Exact(mpi) => {\n-                Ok((self.move_data.move_paths[mpi].place.as_ref(), mpi))\n+                (self.move_data.move_paths[mpi].place.as_ref(), mpi)\n             }\n-            LookupResult::Parent(None) => Err(NoMovePathFound::ReachedStatic),\n+            LookupResult::Parent(None) => panic!(\"should have move path for every Local\"),\n         }\n     }\n \n@@ -1881,7 +1878,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                                 projection: proj_base,\n                             }, span, flow_state);\n \n-                            if let PlaceBase::Local(local) = place.base {\n+                            match place.base {\n                                 // rust-lang/rust#21232,\n                                 // #54499, #54986: during\n                                 // period where we reject\n@@ -1890,7 +1887,9 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                                 // unnecessary `mut` on an\n                                 // attempt to do a partial\n                                 // initialization.\n-                                self.used_mut.insert(local);\n+                                PlaceBase::Local(local) => {\n+                                    self.used_mut.insert(local);\n+                                }\n                             }\n                         }\n \n@@ -2088,10 +2087,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         // partial initialization, do not complain about mutability\n         // errors except for actual mutation (as opposed to an attempt\n         // to do a partial initialization).\n-        let previously_initialized = if let PlaceBase::Local(local) = place.base {\n-            self.is_local_ever_initialized(local, flow_state).is_some()\n-        } else {\n-            true\n+        let previously_initialized = match place.base {\n+            PlaceBase::Local(local) => self.is_local_ever_initialized(local, flow_state).is_some(),\n         };\n \n         // at this point, we have set up the error reporting state.\n@@ -2152,11 +2149,6 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     self.used_mut_upvars.push(field);\n                 }\n             }\n-            RootPlace {\n-                place_base: PlaceBase::Static(..),\n-                place_projection: [],\n-                is_local_mutation_allowed: _,\n-            } => {}\n         }\n     }\n \n@@ -2191,17 +2183,6 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     }),\n                 }\n             }\n-            PlaceRef { base: PlaceBase::Static(box Static { def_id, .. }), projection: [] } => {\n-                if !self.infcx.tcx.is_mutable_static(*def_id) {\n-                    Err(place)\n-                } else {\n-                    Ok(RootPlace {\n-                        place_base: place.base,\n-                        place_projection: place.projection,\n-                        is_local_mutation_allowed,\n-                    })\n-                }\n-            }\n             PlaceRef { base: _, projection: [proj_base @ .., elem] } => {\n                 match elem {\n                     ProjectionElem::Deref => {\n@@ -2356,11 +2337,6 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     }\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-enum NoMovePathFound {\n-    ReachedStatic,\n-}\n-\n /// The degree of overlap between 2 places for borrow-checking.\n enum Overlap {\n     /// The places might partially overlap - in this case, we give"}, {"sha": "41bf1aa47d415553a7d71d6d69b25d123ee79ac7", "filename": "src/librustc_mir/borrow_check/path_utils.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fd5aa32c352d9aa7e652a64320f89b7f3859858b/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd5aa32c352d9aa7e652a64320f89b7f3859858b/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs?ref=fd5aa32c352d9aa7e652a64320f89b7f3859858b", "patch": "@@ -132,8 +132,6 @@ pub(super) fn is_active<'tcx>(\n /// This is called for all Yield expressions on movable generators\n pub(super) fn borrow_of_local_data(place: &Place<'_>) -> bool {\n     match place.base {\n-        PlaceBase::Static(_) => false,\n-\n         // Reborrow of already borrowed data is ignored\n         // Any errors will be caught on the initial borrow\n         PlaceBase::Local(_) => !place.is_indirect(),"}, {"sha": "445ba057c1b51c10fb58d0115f5f19041c78a21e", "filename": "src/librustc_mir/borrow_check/place_ext.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fd5aa32c352d9aa7e652a64320f89b7f3859858b/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd5aa32c352d9aa7e652a64320f89b7f3859858b/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs?ref=fd5aa32c352d9aa7e652a64320f89b7f3859858b", "patch": "@@ -47,7 +47,6 @@ impl<'tcx> PlaceExt<'tcx> for Place<'tcx> {\n                     }\n                 }\n             },\n-            PlaceBase::Static(_) => return true,\n         };\n \n         for (i, elem) in self.projection.iter().enumerate() {"}, {"sha": "a09779a766ffb411c5968f754ada948981456f7d", "filename": "src/librustc_mir/borrow_check/places_conflict.rs", "status": "modified", "additions": 3, "deletions": 25, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/fd5aa32c352d9aa7e652a64320f89b7f3859858b/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd5aa32c352d9aa7e652a64320f89b7f3859858b/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs?ref=fd5aa32c352d9aa7e652a64320f89b7f3859858b", "patch": "@@ -122,7 +122,7 @@ fn place_components_conflict<'tcx>(\n     let borrow_base = &borrow_place.base;\n     let access_base = access_place.base;\n \n-    match place_base_conflict(tcx, borrow_base, access_base) {\n+    match place_base_conflict(borrow_base, access_base) {\n         Overlap::Arbitrary => {\n             bug!(\"Two base can't return Arbitrary\");\n         }\n@@ -293,11 +293,7 @@ fn place_components_conflict<'tcx>(\n // Given that the bases of `elem1` and `elem2` are always either equal\n // or disjoint (and have the same type!), return the overlap situation\n // between `elem1` and `elem2`.\n-fn place_base_conflict<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n-    elem1: &PlaceBase<'tcx>,\n-    elem2: &PlaceBase<'tcx>,\n-) -> Overlap {\n+fn place_base_conflict(elem1: &PlaceBase, elem2: &PlaceBase) -> Overlap {\n     match (elem1, elem2) {\n         (PlaceBase::Local(l1), PlaceBase::Local(l2)) => {\n             if l1 == l2 {\n@@ -310,24 +306,6 @@ fn place_base_conflict<'tcx>(\n                 Overlap::Disjoint\n             }\n         }\n-        (PlaceBase::Static(s1), PlaceBase::Static(s2)) => {\n-            if s1.def_id != s2.def_id {\n-                debug!(\"place_element_conflict: DISJOINT-STATIC\");\n-                Overlap::Disjoint\n-            } else if tcx.is_mutable_static(s1.def_id) {\n-                // We ignore mutable statics - they can only be unsafe code.\n-                debug!(\"place_element_conflict: IGNORE-STATIC-MUT\");\n-                Overlap::Disjoint\n-            } else {\n-                debug!(\"place_element_conflict: DISJOINT-OR-EQ-STATIC\");\n-                Overlap::EqualOrDisjoint\n-            }\n-        }\n-        (PlaceBase::Local(_), PlaceBase::Static(_))\n-        | (PlaceBase::Static(_), PlaceBase::Local(_)) => {\n-            debug!(\"place_element_conflict: DISJOINT-STATIC-LOCAL-PROMOTED\");\n-            Overlap::Disjoint\n-        }\n     }\n }\n \n@@ -337,7 +315,7 @@ fn place_base_conflict<'tcx>(\n fn place_projection_conflict<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     body: &Body<'tcx>,\n-    pi1_base: &PlaceBase<'tcx>,\n+    pi1_base: &PlaceBase,\n     pi1_proj_base: &[PlaceElem<'tcx>],\n     pi1_elem: &PlaceElem<'tcx>,\n     pi2_elem: &PlaceElem<'tcx>,"}, {"sha": "c41f2f45012e2918b7e495dfc1fdc82eab3b2aae", "filename": "src/librustc_mir/borrow_check/prefixes.rs", "status": "modified", "additions": 13, "deletions": 48, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/fd5aa32c352d9aa7e652a64320f89b7f3859858b/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd5aa32c352d9aa7e652a64320f89b7f3859858b/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs?ref=fd5aa32c352d9aa7e652a64320f89b7f3859858b", "patch": "@@ -69,39 +69,22 @@ impl<'cx, 'tcx> Iterator for Prefixes<'cx, 'tcx> {\n \n         'cursor: loop {\n             match &cursor {\n-                PlaceRef {\n-                    base: PlaceBase::Local(_),\n-                    projection: [],\n-                }\n-                | // search yielded this leaf\n-                PlaceRef {\n-                    base: PlaceBase::Static(_),\n-                    projection: [],\n-                } => {\n+                PlaceRef { base: PlaceBase::Local(_), projection: [] } => {\n                     self.next = None;\n                     return Some(cursor);\n                 }\n-                PlaceRef {\n-                    base: _,\n-                    projection: [proj_base @ .., elem],\n-                } => {\n+                PlaceRef { base: _, projection: [proj_base @ .., elem] } => {\n                     match elem {\n                         ProjectionElem::Field(_ /*field*/, _ /*ty*/) => {\n                             // FIXME: add union handling\n-                            self.next = Some(PlaceRef {\n-                                base: cursor.base,\n-                                projection: proj_base,\n-                            });\n+                            self.next = Some(PlaceRef { base: cursor.base, projection: proj_base });\n                             return Some(cursor);\n                         }\n-                        ProjectionElem::Downcast(..) |\n-                        ProjectionElem::Subslice { .. } |\n-                        ProjectionElem::ConstantIndex { .. } |\n-                        ProjectionElem::Index(_) => {\n-                            cursor = PlaceRef {\n-                                base: cursor.base,\n-                                projection: proj_base,\n-                            };\n+                        ProjectionElem::Downcast(..)\n+                        | ProjectionElem::Subslice { .. }\n+                        | ProjectionElem::ConstantIndex { .. }\n+                        | ProjectionElem::Index(_) => {\n+                            cursor = PlaceRef { base: cursor.base, projection: proj_base };\n                             continue 'cursor;\n                         }\n                         ProjectionElem::Deref => {\n@@ -122,10 +105,7 @@ impl<'cx, 'tcx> Iterator for Prefixes<'cx, 'tcx> {\n                         PrefixSet::All => {\n                             // All prefixes: just blindly enqueue the base\n                             // of the projection.\n-                            self.next = Some(PlaceRef {\n-                                base: cursor.base,\n-                                projection: proj_base,\n-                            });\n+                            self.next = Some(PlaceRef { base: cursor.base, projection: proj_base });\n                             return Some(cursor);\n                         }\n                         PrefixSet::Supporting => {\n@@ -140,35 +120,20 @@ impl<'cx, 'tcx> Iterator for Prefixes<'cx, 'tcx> {\n \n                     let ty = Place::ty_from(cursor.base, proj_base, *self.body, self.tcx).ty;\n                     match ty.kind {\n-                        ty::RawPtr(_) |\n-                        ty::Ref(\n-                            _, /*rgn*/\n-                            _, /*ty*/\n-                            hir::Mutability::Not\n-                            ) => {\n+                        ty::RawPtr(_) | ty::Ref(_ /*rgn*/, _ /*ty*/, hir::Mutability::Not) => {\n                             // don't continue traversing over derefs of raw pointers or shared\n                             // borrows.\n                             self.next = None;\n                             return Some(cursor);\n                         }\n \n-                        ty::Ref(\n-                            _, /*rgn*/\n-                            _, /*ty*/\n-                            hir::Mutability::Mut,\n-                            ) => {\n-                            self.next = Some(PlaceRef {\n-                                base: cursor.base,\n-                                projection: proj_base,\n-                            });\n+                        ty::Ref(_ /*rgn*/, _ /*ty*/, hir::Mutability::Mut) => {\n+                            self.next = Some(PlaceRef { base: cursor.base, projection: proj_base });\n                             return Some(cursor);\n                         }\n \n                         ty::Adt(..) if ty.is_box() => {\n-                            self.next = Some(PlaceRef {\n-                                base: cursor.base,\n-                                projection: proj_base,\n-                            });\n+                            self.next = Some(PlaceRef { base: cursor.base, projection: proj_base });\n                             return Some(cursor);\n                         }\n "}, {"sha": "001f2fc3b2287aab657e601dfdbea053a3dbf564", "filename": "src/librustc_mir/borrow_check/type_check/mod.rs", "status": "modified", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/fd5aa32c352d9aa7e652a64320f89b7f3859858b/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd5aa32c352d9aa7e652a64320f89b7f3859858b/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ftype_check%2Fmod.rs?ref=fd5aa32c352d9aa7e652a64320f89b7f3859858b", "patch": "@@ -467,32 +467,6 @@ impl<'a, 'b, 'tcx> TypeVerifier<'a, 'b, 'tcx> {\n \n         let mut place_ty = match &place.base {\n             PlaceBase::Local(index) => PlaceTy::from_ty(self.body.local_decls[*index].ty),\n-            PlaceBase::Static(box Static { ty, def_id }) => {\n-                let san_ty = self.sanitize_type(place, ty);\n-                let check_err =\n-                    |verifier: &mut TypeVerifier<'a, 'b, 'tcx>, place: &Place<'tcx>, ty, san_ty| {\n-                        if let Err(terr) = verifier.cx.eq_types(\n-                            san_ty,\n-                            ty,\n-                            location.to_locations(),\n-                            ConstraintCategory::Boring,\n-                        ) {\n-                            span_mirbug!(\n-                                verifier,\n-                                place,\n-                                \"bad promoted type ({:?}: {:?}): {:?}\",\n-                                ty,\n-                                san_ty,\n-                                terr\n-                            );\n-                        };\n-                    };\n-                let ty = self.tcx().type_of(*def_id);\n-                let ty = self.cx.normalize(ty, location);\n-\n-                check_err(self, place, ty, san_ty);\n-                PlaceTy::from_ty(san_ty)\n-            }\n         };\n \n         if place.projection.is_empty() {"}, {"sha": "ea530042913e8d46b0ad060f5016c5aceb983bce", "filename": "src/librustc_mir/borrow_check/used_muts.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/fd5aa32c352d9aa7e652a64320f89b7f3859858b/src%2Flibrustc_mir%2Fborrow_check%2Fused_muts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd5aa32c352d9aa7e652a64320f89b7f3859858b/src%2Flibrustc_mir%2Fborrow_check%2Fused_muts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fused_muts.rs?ref=fd5aa32c352d9aa7e652a64320f89b7f3859858b", "patch": "@@ -57,8 +57,10 @@ impl GatherUsedMutsVisitor<'_, '_, '_> {\n         // be those that were never initialized - we will consider those as being used as\n         // they will either have been removed by unreachable code optimizations; or linted\n         // as unused variables.\n-        if let PlaceBase::Local(local) = into.base {\n-            let _ = self.never_initialized_mut_locals.remove(&local);\n+        match into.base {\n+            PlaceBase::Local(local) => {\n+                self.never_initialized_mut_locals.remove(&local);\n+            }\n         }\n     }\n }\n@@ -80,12 +82,12 @@ impl<'visit, 'cx, 'tcx> Visitor<'tcx> for GatherUsedMutsVisitor<'visit, 'cx, 'tc\n     fn visit_statement(&mut self, statement: &Statement<'tcx>, _location: Location) {\n         match &statement.kind {\n             StatementKind::Assign(box (into, _)) => {\n-                if let PlaceBase::Local(local) = into.base {\n-                    debug!(\n+                match into.base {\n+                    PlaceBase::Local(local) => debug!(\n                         \"visit_statement: statement={:?} local={:?} \\\n-                         never_initialized_mut_locals={:?}\",\n+                            never_initialized_mut_locals={:?}\",\n                         statement, local, self.never_initialized_mut_locals\n-                    );\n+                    ),\n                 }\n                 self.remove_never_initialized_mut_locals(into);\n             }"}, {"sha": "661111ed9484c00cb8dc7e1428705b75d77e5972", "filename": "src/librustc_mir/build/expr/as_place.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fd5aa32c352d9aa7e652a64320f89b7f3859858b/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd5aa32c352d9aa7e652a64320f89b7f3859858b/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs?ref=fd5aa32c352d9aa7e652a64320f89b7f3859858b", "patch": "@@ -20,7 +20,7 @@ use rustc_index::vec::Idx;\n /// and `c` can be progressively pushed onto the place builder that is created when converting `a`.\n #[derive(Clone)]\n struct PlaceBuilder<'tcx> {\n-    base: PlaceBase<'tcx>,\n+    base: PlaceBase,\n     projection: Vec<PlaceElem<'tcx>>,\n }\n \n@@ -53,8 +53,8 @@ impl From<Local> for PlaceBuilder<'tcx> {\n     }\n }\n \n-impl From<PlaceBase<'tcx>> for PlaceBuilder<'tcx> {\n-    fn from(base: PlaceBase<'tcx>) -> Self {\n+impl From<PlaceBase> for PlaceBuilder<'tcx> {\n+    fn from(base: PlaceBase) -> Self {\n         Self { base, projection: Vec::new() }\n     }\n }"}, {"sha": "d6ada9162272d2c3e9d95fda9bef7b9e5421b561", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 29, "deletions": 27, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/fd5aa32c352d9aa7e652a64320f89b7f3859858b/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd5aa32c352d9aa7e652a64320f89b7f3859858b/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=fd5aa32c352d9aa7e652a64320f89b7f3859858b", "patch": "@@ -195,35 +195,37 @@ impl<'a, 'tcx> Borrows<'a, 'tcx> {\n     fn kill_borrows_on_place(&self, trans: &mut GenKillSet<BorrowIndex>, place: &Place<'tcx>) {\n         debug!(\"kill_borrows_on_place: place={:?}\", place);\n \n-        if let PlaceBase::Local(local) = place.base {\n-            let other_borrows_of_local =\n-                self.borrow_set.local_map.get(&local).into_iter().flat_map(|bs| bs.into_iter());\n-\n-            // If the borrowed place is a local with no projections, all other borrows of this\n-            // local must conflict. This is purely an optimization so we don't have to call\n-            // `places_conflict` for every borrow.\n-            if place.projection.is_empty() {\n-                if !self.body.local_decls[local].is_ref_to_static() {\n-                    trans.kill_all(other_borrows_of_local);\n+        match place.base {\n+            PlaceBase::Local(local) => {\n+                let other_borrows_of_local =\n+                    self.borrow_set.local_map.get(&local).into_iter().flat_map(|bs| bs.into_iter());\n+\n+                // If the borrowed place is a local with no projections, all other borrows of this\n+                // local must conflict. This is purely an optimization so we don't have to call\n+                // `places_conflict` for every borrow.\n+                if place.projection.is_empty() {\n+                    if !self.body.local_decls[local].is_ref_to_static() {\n+                        trans.kill_all(other_borrows_of_local);\n+                    }\n+                    return;\n                 }\n-                return;\n-            }\n \n-            // By passing `PlaceConflictBias::NoOverlap`, we conservatively assume that any given\n-            // pair of array indices are unequal, so that when `places_conflict` returns true, we\n-            // will be assured that two places being compared definitely denotes the same sets of\n-            // locations.\n-            let definitely_conflicting_borrows = other_borrows_of_local.filter(|&&i| {\n-                places_conflict(\n-                    self.tcx,\n-                    self.body,\n-                    &self.borrow_set.borrows[i].borrowed_place,\n-                    place,\n-                    PlaceConflictBias::NoOverlap,\n-                )\n-            });\n-\n-            trans.kill_all(definitely_conflicting_borrows);\n+                // By passing `PlaceConflictBias::NoOverlap`, we conservatively assume that any given\n+                // pair of array indices are unequal, so that when `places_conflict` returns true, we\n+                // will be assured that two places being compared definitely denotes the same sets of\n+                // locations.\n+                let definitely_conflicting_borrows = other_borrows_of_local.filter(|&&i| {\n+                    places_conflict(\n+                        self.tcx,\n+                        self.body,\n+                        &self.borrow_set.borrows[i].borrowed_place,\n+                        place,\n+                        PlaceConflictBias::NoOverlap,\n+                    )\n+                });\n+\n+                trans.kill_all(definitely_conflicting_borrows);\n+            }\n         }\n     }\n }"}, {"sha": "e4d5d6adfc17c06f6f51cc9821f13a7bd0bbb331", "filename": "src/librustc_mir/dataflow/impls/storage_liveness.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fd5aa32c352d9aa7e652a64320f89b7f3859858b/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd5aa32c352d9aa7e652a64320f89b7f3859858b/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fstorage_liveness.rs?ref=fd5aa32c352d9aa7e652a64320f89b7f3859858b", "patch": "@@ -115,15 +115,13 @@ impl<'mir, 'tcx> BitDenotation<'tcx> for RequiresStorage<'mir, 'tcx> {\n         match stmt.kind {\n             StatementKind::StorageDead(l) => sets.kill(l),\n             StatementKind::Assign(box (ref place, _))\n-            | StatementKind::SetDiscriminant { box ref place, .. } => {\n-                if let PlaceBase::Local(local) = place.base {\n-                    sets.gen(local);\n-                }\n-            }\n+            | StatementKind::SetDiscriminant { box ref place, .. } => match place.base {\n+                PlaceBase::Local(local) => sets.gen(local),\n+            },\n             StatementKind::InlineAsm(box InlineAsm { ref outputs, .. }) => {\n                 for p in &**outputs {\n-                    if let PlaceBase::Local(local) = p.base {\n-                        sets.gen(local);\n+                    match p.base {\n+                        PlaceBase::Local(local) => sets.gen(local),\n                     }\n                 }\n             }\n@@ -171,8 +169,10 @@ impl<'mir, 'tcx> BitDenotation<'tcx> for RequiresStorage<'mir, 'tcx> {\n         _dest_bb: mir::BasicBlock,\n         dest_place: &mir::Place<'tcx>,\n     ) {\n-        if let PlaceBase::Local(local) = dest_place.base {\n-            in_out.insert(local);\n+        match dest_place.base {\n+            PlaceBase::Local(local) => {\n+                in_out.insert(local);\n+            }\n         }\n     }\n }"}, {"sha": "b0be49689f953b1af4d49a8d43b9720ae56ae4d0", "filename": "src/librustc_mir/dataflow/move_paths/builder.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fd5aa32c352d9aa7e652a64320f89b7f3859858b/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd5aa32c352d9aa7e652a64320f89b7f3859858b/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs?ref=fd5aa32c352d9aa7e652a64320f89b7f3859858b", "patch": "@@ -98,9 +98,6 @@ impl<'b, 'a, 'tcx> Gatherer<'b, 'a, 'tcx> {\n         debug!(\"lookup({:?})\", place);\n         let mut base = match place.base {\n             PlaceBase::Local(local) => self.builder.data.rev_lookup.locals[local],\n-            PlaceBase::Static(..) => {\n-                return Err(MoveError::cannot_move_out_of(self.loc, Static));\n-            }\n         };\n \n         // The move path index of the first union that we find. Once this is"}, {"sha": "7133c46d6c70f5de712a1a175641a4394d92ae35", "filename": "src/librustc_mir/dataflow/move_paths/mod.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fd5aa32c352d9aa7e652a64320f89b7f3859858b/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd5aa32c352d9aa7e652a64320f89b7f3859858b/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs?ref=fd5aa32c352d9aa7e652a64320f89b7f3859858b", "patch": "@@ -248,7 +248,6 @@ impl MovePathLookup {\n     pub fn find(&self, place: PlaceRef<'_, '_>) -> LookupResult {\n         let mut result = match place.base {\n             PlaceBase::Local(local) => self.locals[*local],\n-            PlaceBase::Static(..) => return LookupResult::Parent(None),\n         };\n \n         for elem in place.projection.iter() {\n@@ -281,9 +280,6 @@ pub struct IllegalMoveOrigin<'tcx> {\n \n #[derive(Debug)]\n pub(crate) enum IllegalMoveOriginKind<'tcx> {\n-    /// Illegal move due to attempt to move from `static` variable.\n-    Static,\n-\n     /// Illegal move due to attempt to move from behind a reference.\n     BorrowedContent {\n         /// The place the reference refers to: if erroneous code was trying to"}, {"sha": "30725d781dc7ff5cfea394bb9c86caf7a50b7a6f", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fd5aa32c352d9aa7e652a64320f89b7f3859858b/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd5aa32c352d9aa7e652a64320f89b7f3859858b/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=fd5aa32c352d9aa7e652a64320f89b7f3859858b", "patch": "@@ -474,7 +474,6 @@ impl<'mir, 'tcx, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n                 self.access_local(self.frame(), *local, layout)?\n             }\n-            PlaceBase::Static(place_static) => self.eval_static_to_mplace(&place_static)?.into(),\n         };\n \n         let op = place"}, {"sha": "bd3059951e86b183f84b3fc933c186904c899cf5", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/fd5aa32c352d9aa7e652a64320f89b7f3859858b/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd5aa32c352d9aa7e652a64320f89b7f3859858b/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=fd5aa32c352d9aa7e652a64320f89b7f3859858b", "patch": "@@ -10,7 +10,6 @@ use rustc::mir::interpret::truncate;\n use rustc::ty::layout::{\n     self, Align, HasDataLayout, LayoutOf, PrimitiveExt, Size, TyLayout, VariantIdx,\n };\n-use rustc::ty::TypeFoldable;\n use rustc::ty::{self, Ty};\n use rustc_macros::HashStable;\n \n@@ -619,35 +618,6 @@ where\n         })\n     }\n \n-    /// Evaluate statics and promoteds to an `MPlace`. Used to share some code between\n-    /// `eval_place` and `eval_place_to_op`.\n-    pub(super) fn eval_static_to_mplace(\n-        &self,\n-        place_static: &mir::Static<'tcx>,\n-    ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n-        let ty = place_static.ty;\n-        assert!(!ty.needs_subst());\n-        let layout = self.layout_of(ty)?;\n-        // Just create a lazy reference, so we can support recursive statics.\n-        // tcx takes care of assigning every static one and only one unique AllocId.\n-        // When the data here is ever actually used, memory will notice,\n-        // and it knows how to deal with alloc_id that are present in the\n-        // global table but not in its local memory: It calls back into tcx through\n-        // a query, triggering the CTFE machinery to actually turn this lazy reference\n-        // into a bunch of bytes.  IOW, statics are evaluated with CTFE even when\n-        // this InterpCx uses another Machine (e.g., in miri).  This is what we\n-        // want!  This way, computing statics works consistently between codegen\n-        // and miri: They use the same query to eventually obtain a `ty::Const`\n-        // and use that for further computation.\n-        //\n-        // Notice that statics have *two* AllocIds: the lazy one, and the resolved\n-        // one.  Here we make sure that the interpreted program never sees the\n-        // resolved ID.  Also see the doc comment of `Memory::get_static_alloc`.\n-        let alloc_id = self.tcx.alloc_map.lock().create_static_alloc(place_static.def_id);\n-        let ptr = self.tag_static_base_pointer(Pointer::from(alloc_id));\n-        Ok(MPlaceTy::from_aligned_ptr(ptr, layout))\n-    }\n-\n     /// Computes a place. You should only use this if you intend to write into this\n     /// place; for reading, a more efficient alternative is `eval_place_for_read`.\n     pub fn eval_place(\n@@ -683,7 +653,6 @@ where\n                 place: Place::Local { frame: self.cur_frame(), local: *local },\n                 layout: self.layout_of_local(self.frame(), *local, None)?,\n             },\n-            PlaceBase::Static(place_static) => self.eval_static_to_mplace(&place_static)?.into(),\n         };\n \n         for elem in place.projection.iter() {"}, {"sha": "5da5695a4d4eb7e79e25261d85983c8f0d0a7b73", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 3, "deletions": 12, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fd5aa32c352d9aa7e652a64320f89b7f3859858b/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd5aa32c352d9aa7e652a64320f89b7f3859858b/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=fd5aa32c352d9aa7e652a64320f89b7f3859858b", "patch": "@@ -182,7 +182,7 @@ use rustc::mir::interpret::{AllocId, ConstValue};\n use rustc::mir::interpret::{ErrorHandled, GlobalAlloc, Scalar};\n use rustc::mir::mono::{InstantiationMode, MonoItem};\n use rustc::mir::visit::Visitor as MirVisitor;\n-use rustc::mir::{self, Location, PlaceBase, Static};\n+use rustc::mir::{self, Location, PlaceBase};\n use rustc::session::config::EntryFnType;\n use rustc::ty::adjustment::{CustomCoerceUnsized, PointerCast};\n use rustc::ty::print::obsolete::DefPathBasedNames;\n@@ -642,20 +642,11 @@ impl<'a, 'tcx> MirVisitor<'tcx> for MirNeighborCollector<'a, 'tcx> {\n \n     fn visit_place_base(\n         &mut self,\n-        place_base: &mir::PlaceBase<'tcx>,\n+        place_base: &mir::PlaceBase,\n         _context: mir::visit::PlaceContext,\n-        location: Location,\n+        _location: Location,\n     ) {\n         match place_base {\n-            PlaceBase::Static(box Static { def_id, .. }) => {\n-                debug!(\"visiting static {:?} @ {:?}\", def_id, location);\n-\n-                let tcx = self.tcx;\n-                let instance = Instance::mono(tcx, *def_id);\n-                if should_monomorphize_locally(tcx, &instance) {\n-                    self.output.push(MonoItem::Static(*def_id));\n-                }\n-            }\n             PlaceBase::Local(_) => {\n                 // Locals have no relevance for collector.\n             }"}, {"sha": "8c52a4e7a29dd5ac4436882ffb7f2b62fadafed0", "filename": "src/librustc_mir/transform/check_consts/qualifs.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fd5aa32c352d9aa7e652a64320f89b7f3859858b/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd5aa32c352d9aa7e652a64320f89b7f3859858b/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fqualifs.rs?ref=fd5aa32c352d9aa7e652a64320f89b7f3859858b", "patch": "@@ -76,9 +76,6 @@ pub trait Qualif {\n     ) -> bool {\n         match place {\n             PlaceRef { base: PlaceBase::Local(local), projection: [] } => per_local(*local),\n-            PlaceRef { base: PlaceBase::Static(_), projection: [] } => {\n-                bug!(\"qualifying already promoted MIR\")\n-            }\n             PlaceRef { base: _, projection: [.., _] } => Self::in_projection(cx, per_local, place),\n         }\n     }"}, {"sha": "c864abdae66a53cf6f29d127c7e7acdd53ca8504", "filename": "src/librustc_mir/transform/check_consts/validation.rs", "status": "modified", "additions": 7, "deletions": 17, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fd5aa32c352d9aa7e652a64320f89b7f3859858b/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd5aa32c352d9aa7e652a64320f89b7f3859858b/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=fd5aa32c352d9aa7e652a64320f89b7f3859858b", "patch": "@@ -369,15 +369,6 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n \n             Rvalue::AddressOf(Mutability::Mut, _) => self.check_op(ops::MutAddressOf),\n \n-            // At the moment, `PlaceBase::Static` is only used for promoted MIR.\n-            Rvalue::Ref(_, BorrowKind::Shared, ref place)\n-            | Rvalue::Ref(_, BorrowKind::Shallow, ref place)\n-            | Rvalue::AddressOf(Mutability::Not, ref place)\n-                if matches!(place.base, PlaceBase::Static(_)) =>\n-            {\n-                bug!(\"Saw a promoted during const-checking, which must run before promotion\")\n-            }\n-\n             Rvalue::Ref(_, BorrowKind::Shared, ref place)\n             | Rvalue::Ref(_, BorrowKind::Shallow, ref place) => {\n                 self.check_immutable_borrow_like(location, place)\n@@ -423,7 +414,7 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n \n     fn visit_place_base(\n         &mut self,\n-        place_base: &PlaceBase<'tcx>,\n+        place_base: &PlaceBase,\n         context: PlaceContext,\n         location: Location,\n     ) {\n@@ -437,9 +428,6 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n \n         match place_base {\n             PlaceBase::Local(_) => {}\n-            PlaceBase::Static(_) => {\n-                bug!(\"Promotion must be run after const validation\");\n-            }\n         }\n     }\n \n@@ -453,7 +441,7 @@ impl Visitor<'tcx> for Validator<'_, 'mir, 'tcx> {\n     }\n     fn visit_projection_elem(\n         &mut self,\n-        place_base: &PlaceBase<'tcx>,\n+        place_base: &PlaceBase,\n         proj_base: &[PlaceElem<'tcx>],\n         elem: &PlaceElem<'tcx>,\n         context: PlaceContext,\n@@ -681,9 +669,11 @@ fn place_as_reborrow(\n \n         // A borrow of a `static` also looks like `&(*_1)` in the MIR, but `_1` is a `const`\n         // that points to the allocation for the static. Don't treat these as reborrows.\n-        if let PlaceBase::Local(local) = place.base {\n-            if body.local_decls[local].is_ref_to_static() {\n-                return None;\n+        match place.base {\n+            PlaceBase::Local(local) => {\n+                if body.local_decls[local].is_ref_to_static() {\n+                    return None;\n+                }\n             }\n         }\n "}, {"sha": "017d0f34674105ef48bbc17e7d629677cce10747", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fd5aa32c352d9aa7e652a64320f89b7f3859858b/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd5aa32c352d9aa7e652a64320f89b7f3859858b/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=fd5aa32c352d9aa7e652a64320f89b7f3859858b", "patch": "@@ -194,9 +194,6 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n             PlaceBase::Local(..) => {\n                 // Locals are safe.\n             }\n-            PlaceBase::Static(box Static { .. }) => {\n-                bug!(\"Static should not exist\");\n-            }\n         }\n \n         for (i, elem) in place.projection.iter().enumerate() {"}, {"sha": "f9b24b00e8719d6b4c2a8dbd6451b65065963e10", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fd5aa32c352d9aa7e652a64320f89b7f3859858b/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd5aa32c352d9aa7e652a64320f89b7f3859858b/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=fd5aa32c352d9aa7e652a64320f89b7f3859858b", "patch": "@@ -872,8 +872,8 @@ impl<'mir, 'tcx> MutVisitor<'tcx> for ConstPropagator<'mir, 'tcx> {\n                         // doesn't use the invalid value\n                         match cond {\n                             Operand::Move(ref place) | Operand::Copy(ref place) => {\n-                                if let PlaceBase::Local(local) = place.base {\n-                                    self.remove_const(local);\n+                                match place.base {\n+                                    PlaceBase::Local(local) => self.remove_const(local),\n                                 }\n                             }\n                             Operand::Constant(_) => {}"}, {"sha": "b075a3995161314303585eb5e0fc9d0dfc1ec089", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/fd5aa32c352d9aa7e652a64320f89b7f3859858b/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd5aa32c352d9aa7e652a64320f89b7f3859858b/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=fd5aa32c352d9aa7e652a64320f89b7f3859858b", "patch": "@@ -275,18 +275,18 @@ impl MutVisitor<'tcx> for TransformVisitor<'tcx> {\n         assert_eq!(self.remap.get(local), None);\n     }\n \n-    fn visit_place(&mut self, place: &mut Place<'tcx>, context: PlaceContext, location: Location) {\n-        if let PlaceBase::Local(l) = place.base {\n+    fn visit_place(\n+        &mut self,\n+        place: &mut Place<'tcx>,\n+        _context: PlaceContext,\n+        _location: Location,\n+    ) {\n+        match place.base {\n+            PlaceBase::Local(l) =>\n             // Replace an Local in the remap with a generator struct access\n-            if let Some(&(ty, variant_index, idx)) = self.remap.get(&l) {\n-                replace_base(place, self.make_field(variant_index, idx, ty), self.tcx);\n-            }\n-        } else {\n-            self.visit_place_base(&mut place.base, context, location);\n-\n-            for elem in place.projection.iter() {\n-                if let PlaceElem::Index(local) = elem {\n-                    assert_ne!(*local, self_arg());\n+            {\n+                if let Some(&(ty, variant_index, idx)) = self.remap.get(&l) {\n+                    replace_base(place, self.make_field(variant_index, idx, ty), self.tcx);\n                 }\n             }\n         }"}, {"sha": "52992f7d7a8cce4fc36ed343c38415058ab22348", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fd5aa32c352d9aa7e652a64320f89b7f3859858b/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd5aa32c352d9aa7e652a64320f89b7f3859858b/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=fd5aa32c352d9aa7e652a64320f89b7f3859858b", "patch": "@@ -431,9 +431,6 @@ impl Inliner<'tcx> {\n                     }\n \n                     match place.base {\n-                        // Static variables need a borrow because the callee\n-                        // might modify the same static.\n-                        PlaceBase::Static(_) => true,\n                         _ => false,\n                     }\n                 }\n@@ -649,7 +646,6 @@ impl<'a, 'tcx> Integrator<'a, 'tcx> {\n         if *local == RETURN_PLACE {\n             match self.destination.base {\n                 PlaceBase::Local(l) => return l,\n-                PlaceBase::Static(ref s) => bug!(\"Return place is {:?}, not local\", s),\n             }\n         }\n \n@@ -673,7 +669,6 @@ impl<'a, 'tcx> MutVisitor<'tcx> for Integrator<'a, 'tcx> {\n \n     fn visit_place(&mut self, place: &mut Place<'tcx>, context: PlaceContext, location: Location) {\n         match &mut place.base {\n-            PlaceBase::Static(_) => {}\n             PlaceBase::Local(l) => {\n                 // If this is the `RETURN_PLACE`, we need to rebase any projections onto it.\n                 let dest_proj_len = self.destination.projection.len();"}, {"sha": "494b61c5d1ee70e2244d0f277dc44ff0b3dc821e", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fd5aa32c352d9aa7e652a64320f89b7f3859858b/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd5aa32c352d9aa7e652a64320f89b7f3859858b/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=fd5aa32c352d9aa7e652a64320f89b7f3859858b", "patch": "@@ -310,7 +310,6 @@ impl<'tcx> Validator<'_, 'tcx> {\n                         // don't get promoted anyway).\n                         let base = match place.base {\n                             PlaceBase::Local(local) => local,\n-                            _ => return Err(Unpromotable),\n                         };\n                         self.validate_local(base)?;\n \n@@ -482,9 +481,6 @@ impl<'tcx> Validator<'_, 'tcx> {\n             PlaceRef { base: PlaceBase::Local(local), projection: [] } => {\n                 self.validate_local(*local)\n             }\n-            PlaceRef { base: PlaceBase::Static(_), projection: [] } => {\n-                bug!(\"qualifying already promoted MIR\")\n-            }\n             PlaceRef { base: _, projection: [proj_base @ .., elem] } => {\n                 match *elem {\n                     ProjectionElem::Deref | ProjectionElem::Downcast(..) => {\n@@ -648,7 +644,6 @@ impl<'tcx> Validator<'_, 'tcx> {\n                 // `check_consts::qualifs` but without recursion.\n                 let mut has_mut_interior = match place.base {\n                     PlaceBase::Local(local) => self.qualif_local::<qualifs::HasMutInterior>(*local),\n-                    PlaceBase::Static(_) => false,\n                 };\n                 if has_mut_interior {\n                     let mut place_projection = place.projection;"}, {"sha": "e96baefc8229b3a2d7f6ee0690a10e3b54651b6e", "filename": "src/librustc_mir/transform/simplify.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fd5aa32c352d9aa7e652a64320f89b7f3859858b/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd5aa32c352d9aa7e652a64320f89b7f3859858b/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fsimplify.rs?ref=fd5aa32c352d9aa7e652a64320f89b7f3859858b", "patch": "@@ -388,13 +388,9 @@ impl<'tcx> MutVisitor<'tcx> for LocalUpdater<'tcx> {\n         // Remove unnecessary StorageLive and StorageDead annotations.\n         data.statements.retain(|stmt| match &stmt.kind {\n             StatementKind::StorageLive(l) | StatementKind::StorageDead(l) => self.map[*l].is_some(),\n-            StatementKind::Assign(box (place, _)) => {\n-                if let PlaceBase::Local(local) = place.base {\n-                    self.map[local].is_some()\n-                } else {\n-                    true\n-                }\n-            }\n+            StatementKind::Assign(box (place, _)) => match place.base {\n+                PlaceBase::Local(local) => self.map[local].is_some(),\n+            },\n             _ => true,\n         });\n         self.super_basic_block_data(block, data);"}]}