{"sha": "28ea249ab526c6b114c4dc9ba311fc62fccb28e2", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI4ZWEyNDlhYjUyNmM2YjExNGM0ZGM5YmEzMTFmYzYyZmNjYjI4ZTI=", "commit": {"author": {"name": "Jacob Greenfield", "email": "xales@naveria.com", "date": "2019-04-07T05:48:59Z"}, "committer": {"name": "Jacob Greenfield", "email": "xales@naveria.com", "date": "2019-04-07T07:16:31Z"}, "message": "Revert \"Auto merge of #57842 - gnzlbg:extract_libtest, r=gnzlbg\"\n\nThis reverts commit 3eb4890dfe6db0279fdd3cda19f9643873ae3db9, reversing\nchanges made to 7a4df3b53da369110984a2b57419c05a53e33b38.", "tree": {"sha": "2bcccba6a6b5fd002891ba57a8db91aab36cba77", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2bcccba6a6b5fd002891ba57a8db91aab36cba77"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/28ea249ab526c6b114c4dc9ba311fc62fccb28e2", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEEIayUOrvwlRE1p3XTTk7w0lbJWsEFAlypo9cACgkQTk7w0lbJ\nWsFcSRAAi8pPsLT38WpCphsQ5YrYS5nX81rDuw60SDzK6KzsVG24XR2ySBkI+7v2\nd0h1sBx6D43L2B1AgORMTM/Wr8viedNBiBPEXNsxj6m/oyHba8uFjNXWB0s6fp4L\nZODPPgAeEP9Wig9OeU7OvpJjLSurtvYK1aQ7bKjnUWyr7Bxv79ORQ9BKc73n9/0l\nRoqtVxkkHfS/fPWZnrYXQSFAgoIcVkcJ3MdA6DwYeSinmmlJfTB9MqfEnIoh6fvT\n6PvzsN5Mp3LLRI6f1KRsZbLYwtxBcPpDD1C8I6thR5oxd5S5MgPSNZmGxRE9XL0H\nD7t3Ibrr9WozUbgTECORL1KND+OmtgHW+OXkNAbiofwlj2yVW1cTI4K4HXTwgliF\nCzMqCiLBgBVZvQP25g/fNQjNK6syv8uELWyaEQQL0u9TwT/O8SV464twylImBzDO\nQTt+zNrIfJrdnk0uU2KI/9Cv12A+0HbcTThyaDTCyktrNsIdYBmMSuvSckWaFTRo\nRoqLk8X5IOEv6SHo3X/KCUEYIOFEa4UaCGQ4TIO9Ahs1Tr7qgAvxGPca4AOvtCBx\n3rYMu/2V0tU/bijP367JvOPhEuuETgI595C8UxDbWKRhrp6eQef1xO2PCfBkx4JL\n44nQFQRQN3wI7kbuRLD1MbeSx4Akc0U1HWoP2KDmqcslHysw56c=\n=0xlS\n-----END PGP SIGNATURE-----", "payload": "tree 2bcccba6a6b5fd002891ba57a8db91aab36cba77\nparent dec0a98c4b392b5fd153ba8b944c496218717813\nauthor Jacob Greenfield <xales@naveria.com> 1554616139 -0400\ncommitter Jacob Greenfield <xales@naveria.com> 1554621391 -0400\n\nRevert \"Auto merge of #57842 - gnzlbg:extract_libtest, r=gnzlbg\"\n\nThis reverts commit 3eb4890dfe6db0279fdd3cda19f9643873ae3db9, reversing\nchanges made to 7a4df3b53da369110984a2b57419c05a53e33b38.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/28ea249ab526c6b114c4dc9ba311fc62fccb28e2", "html_url": "https://github.com/rust-lang/rust/commit/28ea249ab526c6b114c4dc9ba311fc62fccb28e2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/28ea249ab526c6b114c4dc9ba311fc62fccb28e2/comments", "author": {"login": "xales", "id": 341605, "node_id": "MDQ6VXNlcjM0MTYwNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/341605?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xales", "html_url": "https://github.com/xales", "followers_url": "https://api.github.com/users/xales/followers", "following_url": "https://api.github.com/users/xales/following{/other_user}", "gists_url": "https://api.github.com/users/xales/gists{/gist_id}", "starred_url": "https://api.github.com/users/xales/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xales/subscriptions", "organizations_url": "https://api.github.com/users/xales/orgs", "repos_url": "https://api.github.com/users/xales/repos", "events_url": "https://api.github.com/users/xales/events{/privacy}", "received_events_url": "https://api.github.com/users/xales/received_events", "type": "User", "site_admin": false}, "committer": {"login": "xales", "id": 341605, "node_id": "MDQ6VXNlcjM0MTYwNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/341605?v=4", "gravatar_id": "", "url": "https://api.github.com/users/xales", "html_url": "https://github.com/xales", "followers_url": "https://api.github.com/users/xales/followers", "following_url": "https://api.github.com/users/xales/following{/other_user}", "gists_url": "https://api.github.com/users/xales/gists{/gist_id}", "starred_url": "https://api.github.com/users/xales/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/xales/subscriptions", "organizations_url": "https://api.github.com/users/xales/orgs", "repos_url": "https://api.github.com/users/xales/repos", "events_url": "https://api.github.com/users/xales/events{/privacy}", "received_events_url": "https://api.github.com/users/xales/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dec0a98c4b392b5fd153ba8b944c496218717813", "url": "https://api.github.com/repos/rust-lang/rust/commits/dec0a98c4b392b5fd153ba8b944c496218717813", "html_url": "https://github.com/rust-lang/rust/commit/dec0a98c4b392b5fd153ba8b944c496218717813"}], "stats": {"total": 5665, "additions": 5608, "deletions": 57}, "files": [{"sha": "0256132be7db746d8f952c5a6b1674e2b4d6c304", "filename": "Cargo.lock", "status": "modified", "additions": 6, "deletions": 17, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/28ea249ab526c6b114c4dc9ba311fc62fccb28e2/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/28ea249ab526c6b114c4dc9ba311fc62fccb28e2/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=28ea249ab526c6b114c4dc9ba311fc62fccb28e2", "patch": "@@ -1319,15 +1319,6 @@ dependencies = [\n  \"vcpkg 0.2.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n-[[package]]\n-name = \"libtest\"\n-version = \"0.0.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-dependencies = [\n- \"getopts 0.2.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"rustc_term 0.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n-]\n-\n [[package]]\n name = \"libz-sys\"\n version = \"1.0.25\"\n@@ -2952,11 +2943,6 @@ dependencies = [\n  \"serialize 0.0.0\",\n ]\n \n-[[package]]\n-name = \"rustc_term\"\n-version = \"0.0.1\"\n-source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-\n [[package]]\n name = \"rustc_tools_util\"\n version = \"0.1.1\"\n@@ -3439,6 +3425,10 @@ dependencies = [\n  \"utf-8 0.7.2 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n+[[package]]\n+name = \"term\"\n+version = \"0.0.0\"\n+\n [[package]]\n name = \"term\"\n version = \"0.4.6\"\n@@ -3479,8 +3469,9 @@ dependencies = [\n name = \"test\"\n version = \"0.0.0\"\n dependencies = [\n- \"libtest 0.0.1 (registry+https://github.com/rust-lang/crates.io-index)\",\n+ \"getopts 0.2.17 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"proc_macro 0.0.0\",\n+ \"term 0.0.0\",\n ]\n \n [[package]]\n@@ -4113,7 +4104,6 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum libgit2-sys 0.7.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"48441cb35dc255da8ae72825689a95368bf510659ae1ad55dc4aa88cb1789bf1\"\n \"checksum libnghttp2-sys 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"d75d7966bda4730b722d1eab8e668df445368a24394bae9fc1e8dc0ab3dbe4f4\"\n \"checksum libssh2-sys 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)\" = \"126a1f4078368b163bfdee65fbab072af08a1b374a5551b21e87ade27b1fbf9d\"\n-\"checksum libtest 0.0.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"1a51ac59582b915cdfc426dada72c6d9eba95818a6b481ca340f5c7152166837\"\n \"checksum libz-sys 1.0.25 (registry+https://github.com/rust-lang/crates.io-index)\" = \"2eb5e43362e38e2bca2fd5f5134c4d4564a23a5c28e9b95411652021a8675ebe\"\n \"checksum lock_api 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"949826a5ccf18c1b3a7c3d57692778d21768b79e46eb9dd07bfc4c2160036c54\"\n \"checksum log 0.4.6 (registry+https://github.com/rust-lang/crates.io-index)\" = \"c84ec4b527950aa83a329754b01dbe3f58361d1c5efacd1f6d68c494d08a17c6\"\n@@ -4222,7 +4212,6 @@ source = \"registry+https://github.com/rust-lang/crates.io-index\"\n \"checksum rustc-rayon 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"8d98c51d9cbbe810c8b6693236d3412d8cd60513ff27a3e1b6af483dca0af544\"\n \"checksum rustc-rayon-core 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)\" = \"526e7b6d2707a5b9bec3927d424ad70fa3cfc68e0ac1b75e46cdbbc95adc5108\"\n \"checksum rustc-serialize 0.3.24 (registry+https://github.com/rust-lang/crates.io-index)\" = \"dcf128d1287d2ea9d80910b5f1120d0b8eede3fbf1abe91c40d39ea7d51e6fda\"\n-\"checksum rustc_term 0.0.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"9c69abe7f181d2ea8d2f7b44a4aa86f4b4a567444bcfcf51ed45ede957fbf064\"\n \"checksum rustc_tools_util 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)\" = \"b3c5a95edfa0c893236ae4778bb7c4752760e4c0d245e19b5eff33c5aa5eb9dc\"\n \"checksum rustc_version 0.2.3 (registry+https://github.com/rust-lang/crates.io-index)\" = \"138e3e0acb6c9fb258b19b67cb8abd63c00679d2851805ea151465464fe9030a\"\n \"checksum rustfix 0.4.4 (registry+https://github.com/rust-lang/crates.io-index)\" = \"af7c21531a91512a4a51b490be6ba1c8eff34fdda0dc5bf87dc28d86748aac56\""}, {"sha": "61a7705bd6cc6796cd8716ed6cc3b6c22b66c53c", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/28ea249ab526c6b114c4dc9ba311fc62fccb28e2/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28ea249ab526c6b114c4dc9ba311fc62fccb28e2/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=28ea249ab526c6b114c4dc9ba311fc62fccb28e2", "patch": "@@ -901,6 +901,7 @@ impl Step for Src {\n             \"src/libstd\",\n             \"src/libunwind\",\n             \"src/libtest\",\n+            \"src/libterm\",\n             \"src/libprofiler_builtins\",\n             \"src/stdsimd\",\n             \"src/libproc_macro\","}, {"sha": "4eba9a9d79cc431f2bd43ee8cae66c5fda0400eb", "filename": "src/libterm/Cargo.toml", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/28ea249ab526c6b114c4dc9ba311fc62fccb28e2/src%2Flibterm%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/28ea249ab526c6b114c4dc9ba311fc62fccb28e2/src%2Flibterm%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2FCargo.toml?ref=28ea249ab526c6b114c4dc9ba311fc62fccb28e2", "patch": "@@ -0,0 +1,10 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"term\"\n+version = \"0.0.0\"\n+edition = \"2018\"\n+\n+[lib]\n+name = \"term\"\n+path = \"lib.rs\"\n+crate-type = [\"dylib\", \"rlib\"]"}, {"sha": "711716d9b926c10c11a50eca2437571fe57ebe75", "filename": "src/libterm/lib.rs", "status": "added", "additions": 201, "deletions": 0, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/28ea249ab526c6b114c4dc9ba311fc62fccb28e2/src%2Flibterm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28ea249ab526c6b114c4dc9ba311fc62fccb28e2/src%2Flibterm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Flib.rs?ref=28ea249ab526c6b114c4dc9ba311fc62fccb28e2", "patch": "@@ -0,0 +1,201 @@\n+//! Terminal formatting library.\n+//!\n+//! This crate provides the `Terminal` trait, which abstracts over an [ANSI\n+//! Terminal][ansi] to provide color printing, among other things. There are two\n+//! implementations, the `TerminfoTerminal`, which uses control characters from\n+//! a [terminfo][ti] database, and `WinConsole`, which uses the [Win32 Console\n+//! API][win].\n+//!\n+//! # Examples\n+//!\n+//! ```no_run\n+//! # #![feature(rustc_private)]\n+//! extern crate term;\n+//! use std::io::prelude::*;\n+//!\n+//! fn main() {\n+//!     let mut t = term::stdout().unwrap();\n+//!\n+//!     t.fg(term::color::GREEN).unwrap();\n+//!     write!(t, \"hello, \").unwrap();\n+//!\n+//!     t.fg(term::color::RED).unwrap();\n+//!     writeln!(t, \"world!\").unwrap();\n+//!\n+//!     assert!(t.reset().unwrap());\n+//! }\n+//! ```\n+//!\n+//! [ansi]: https://en.wikipedia.org/wiki/ANSI_escape_code\n+//! [win]: http://msdn.microsoft.com/en-us/library/windows/desktop/ms682010%28v=vs.85%29.aspx\n+//! [ti]: https://en.wikipedia.org/wiki/Terminfo\n+\n+#![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\",\n+       html_playground_url = \"https://play.rust-lang.org/\",\n+       test(attr(deny(warnings))))]\n+#![deny(missing_docs)]\n+\n+#![deny(rust_2018_idioms)]\n+\n+#![cfg_attr(windows, feature(libc))]\n+// Handle rustfmt skips\n+#![feature(custom_attribute)]\n+#![allow(unused_attributes)]\n+\n+use std::io::prelude::*;\n+use std::io::{self, Stdout, Stderr};\n+\n+pub use terminfo::TerminfoTerminal;\n+#[cfg(windows)]\n+pub use win::WinConsole;\n+\n+pub mod terminfo;\n+\n+#[cfg(windows)]\n+mod win;\n+\n+/// Alias for stdout terminals.\n+pub type StdoutTerminal = dyn Terminal<Output = Stdout> + Send;\n+/// Alias for stderr terminals.\n+pub type StderrTerminal = dyn Terminal<Output = Stderr> + Send;\n+\n+#[cfg(not(windows))]\n+/// Returns a Terminal wrapping stdout, or None if a terminal couldn't be\n+/// opened.\n+pub fn stdout() -> Option<Box<StdoutTerminal>> {\n+    TerminfoTerminal::new(io::stdout()).map(|t| Box::new(t) as Box<StdoutTerminal>)\n+}\n+\n+#[cfg(windows)]\n+/// Returns a Terminal wrapping stdout, or None if a terminal couldn't be\n+/// opened.\n+pub fn stdout() -> Option<Box<StdoutTerminal>> {\n+    TerminfoTerminal::new(io::stdout())\n+        .map(|t| Box::new(t) as Box<StdoutTerminal>)\n+        .or_else(|| WinConsole::new(io::stdout()).ok().map(|t| Box::new(t) as Box<StdoutTerminal>))\n+}\n+\n+#[cfg(not(windows))]\n+/// Returns a Terminal wrapping stderr, or None if a terminal couldn't be\n+/// opened.\n+pub fn stderr() -> Option<Box<StderrTerminal>> {\n+    TerminfoTerminal::new(io::stderr()).map(|t| Box::new(t) as Box<StderrTerminal>)\n+}\n+\n+#[cfg(windows)]\n+/// Returns a Terminal wrapping stderr, or None if a terminal couldn't be\n+/// opened.\n+pub fn stderr() -> Option<Box<StderrTerminal>> {\n+    TerminfoTerminal::new(io::stderr())\n+        .map(|t| Box::new(t) as Box<StderrTerminal>)\n+        .or_else(|| WinConsole::new(io::stderr()).ok().map(|t| Box::new(t) as Box<StderrTerminal>))\n+}\n+\n+\n+/// Terminal color definitions\n+#[allow(missing_docs)]\n+pub mod color {\n+    /// Number for a terminal color\n+    pub type Color = u16;\n+\n+    pub const BLACK: Color = 0;\n+    pub const RED: Color = 1;\n+    pub const GREEN: Color = 2;\n+    pub const YELLOW: Color = 3;\n+    pub const BLUE: Color = 4;\n+    pub const MAGENTA: Color = 5;\n+    pub const CYAN: Color = 6;\n+    pub const WHITE: Color = 7;\n+\n+    pub const BRIGHT_BLACK: Color = 8;\n+    pub const BRIGHT_RED: Color = 9;\n+    pub const BRIGHT_GREEN: Color = 10;\n+    pub const BRIGHT_YELLOW: Color = 11;\n+    pub const BRIGHT_BLUE: Color = 12;\n+    pub const BRIGHT_MAGENTA: Color = 13;\n+    pub const BRIGHT_CYAN: Color = 14;\n+    pub const BRIGHT_WHITE: Color = 15;\n+}\n+\n+/// Terminal attributes for use with term.attr().\n+///\n+/// Most attributes can only be turned on and must be turned off with term.reset().\n+/// The ones that can be turned off explicitly take a boolean value.\n+/// Color is also represented as an attribute for convenience.\n+#[derive(Debug, PartialEq, Eq, Copy, Clone)]\n+pub enum Attr {\n+    /// Bold (or possibly bright) mode\n+    Bold,\n+    /// Dim mode, also called faint or half-bright. Often not supported\n+    Dim,\n+    /// Italics mode. Often not supported\n+    Italic(bool),\n+    /// Underline mode\n+    Underline(bool),\n+    /// Blink mode\n+    Blink,\n+    /// Standout mode. Often implemented as Reverse, sometimes coupled with Bold\n+    Standout(bool),\n+    /// Reverse mode, inverts the foreground and background colors\n+    Reverse,\n+    /// Secure mode, also called invis mode. Hides the printed text\n+    Secure,\n+    /// Convenience attribute to set the foreground color\n+    ForegroundColor(color::Color),\n+    /// Convenience attribute to set the background color\n+    BackgroundColor(color::Color),\n+}\n+\n+/// A terminal with similar capabilities to an ANSI Terminal\n+/// (foreground/background colors etc).\n+pub trait Terminal: Write {\n+    /// The terminal's output writer type.\n+    type Output: Write;\n+\n+    /// Sets the foreground color to the given color.\n+    ///\n+    /// If the color is a bright color, but the terminal only supports 8 colors,\n+    /// the corresponding normal color will be used instead.\n+    ///\n+    /// Returns `Ok(true)` if the color was set, `Ok(false)` otherwise, and `Err(e)`\n+    /// if there was an I/O error.\n+    fn fg(&mut self, color: color::Color) -> io::Result<bool>;\n+\n+    /// Sets the background color to the given color.\n+    ///\n+    /// If the color is a bright color, but the terminal only supports 8 colors,\n+    /// the corresponding normal color will be used instead.\n+    ///\n+    /// Returns `Ok(true)` if the color was set, `Ok(false)` otherwise, and `Err(e)`\n+    /// if there was an I/O error.\n+    fn bg(&mut self, color: color::Color) -> io::Result<bool>;\n+\n+    /// Sets the given terminal attribute, if supported. Returns `Ok(true)`\n+    /// if the attribute was supported, `Ok(false)` otherwise, and `Err(e)` if\n+    /// there was an I/O error.\n+    fn attr(&mut self, attr: Attr) -> io::Result<bool>;\n+\n+    /// Returns `true` if the given terminal attribute is supported.\n+    fn supports_attr(&self, attr: Attr) -> bool;\n+\n+    /// Resets all terminal attributes and colors to their defaults.\n+    ///\n+    /// Returns `Ok(true)` if the terminal was reset, `Ok(false)` otherwise, and `Err(e)` if there\n+    /// was an I/O error.\n+    ///\n+    /// *Note: This does not flush.*\n+    ///\n+    /// That means the reset command may get buffered so, if you aren't planning on doing anything\n+    /// else that might flush stdout's buffer (e.g., writing a line of text), you should flush after\n+    /// calling reset.\n+    fn reset(&mut self) -> io::Result<bool>;\n+\n+    /// Gets an immutable reference to the stream inside\n+    fn get_ref(&self) -> &Self::Output;\n+\n+    /// Gets a mutable reference to the stream inside\n+    fn get_mut(&mut self) -> &mut Self::Output;\n+\n+    /// Returns the contained stream, destroying the `Terminal`\n+    fn into_inner(self) -> Self::Output where Self: Sized;\n+}"}, {"sha": "be90195065eb7a4deeeda80e27b565372029f137", "filename": "src/libterm/terminfo/mod.rs", "status": "added", "additions": 265, "deletions": 0, "changes": 265, "blob_url": "https://github.com/rust-lang/rust/blob/28ea249ab526c6b114c4dc9ba311fc62fccb28e2/src%2Flibterm%2Fterminfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28ea249ab526c6b114c4dc9ba311fc62fccb28e2/src%2Flibterm%2Fterminfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fmod.rs?ref=28ea249ab526c6b114c4dc9ba311fc62fccb28e2", "patch": "@@ -0,0 +1,265 @@\n+//! Terminfo database interface.\n+\n+use std::collections::HashMap;\n+use std::env;\n+use std::error;\n+use std::fmt;\n+use std::fs::File;\n+use std::io::{self, prelude::*, BufReader};\n+use std::path::Path;\n+\n+use crate::Attr;\n+use crate::color;\n+use crate::Terminal;\n+\n+use searcher::get_dbpath_for_term;\n+use parser::compiled::{parse, msys_terminfo};\n+use parm::{expand, Variables, Param};\n+\n+/// A parsed terminfo database entry.\n+#[derive(Debug)]\n+pub struct TermInfo {\n+    /// Names for the terminal\n+    pub names: Vec<String>,\n+    /// Map of capability name to boolean value\n+    pub bools: HashMap<String, bool>,\n+    /// Map of capability name to numeric value\n+    pub numbers: HashMap<String, u16>,\n+    /// Map of capability name to raw (unexpanded) string\n+    pub strings: HashMap<String, Vec<u8>>,\n+}\n+\n+/// A terminfo creation error.\n+#[derive(Debug)]\n+pub enum Error {\n+    /// TermUnset Indicates that the environment doesn't include enough information to find\n+    /// the terminfo entry.\n+    TermUnset,\n+    /// MalformedTerminfo indicates that parsing the terminfo entry failed.\n+    MalformedTerminfo(String),\n+    /// io::Error forwards any io::Errors encountered when finding or reading the terminfo entry.\n+    IoError(io::Error),\n+}\n+\n+impl error::Error for Error {\n+    fn description(&self) -> &str {\n+        \"failed to create TermInfo\"\n+    }\n+\n+    fn cause(&self) -> Option<&dyn error::Error> {\n+        use Error::*;\n+        match *self {\n+            IoError(ref e) => Some(e),\n+            _ => None,\n+        }\n+    }\n+}\n+\n+impl fmt::Display for Error {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        use Error::*;\n+        match *self {\n+            TermUnset => Ok(()),\n+            MalformedTerminfo(ref e) => e.fmt(f),\n+            IoError(ref e) => e.fmt(f),\n+        }\n+    }\n+}\n+\n+impl TermInfo {\n+    /// Creates a TermInfo based on current environment.\n+    pub fn from_env() -> Result<TermInfo, Error> {\n+        let term = match env::var(\"TERM\") {\n+            Ok(name) => TermInfo::from_name(&name),\n+            Err(..) => return Err(Error::TermUnset),\n+        };\n+\n+        if term.is_err() && env::var(\"MSYSCON\").ok().map_or(false, |s| \"mintty.exe\" == s) {\n+            // msys terminal\n+            Ok(msys_terminfo())\n+        } else {\n+            term\n+        }\n+    }\n+\n+    /// Creates a TermInfo for the named terminal.\n+    pub fn from_name(name: &str) -> Result<TermInfo, Error> {\n+        get_dbpath_for_term(name)\n+            .ok_or_else(|| {\n+                Error::IoError(io::Error::new(io::ErrorKind::NotFound, \"terminfo file not found\"))\n+            })\n+            .and_then(|p| TermInfo::from_path(&(*p)))\n+    }\n+\n+    /// Parse the given TermInfo.\n+    pub fn from_path<P: AsRef<Path>>(path: P) -> Result<TermInfo, Error> {\n+        Self::_from_path(path.as_ref())\n+    }\n+    // Keep the metadata small\n+    fn _from_path(path: &Path) -> Result<TermInfo, Error> {\n+        let file = File::open(path).map_err(Error::IoError)?;\n+        let mut reader = BufReader::new(file);\n+        parse(&mut reader, false).map_err(Error::MalformedTerminfo)\n+    }\n+}\n+\n+pub mod searcher;\n+\n+/// TermInfo format parsing.\n+pub mod parser {\n+    //! ncurses-compatible compiled terminfo format parsing (term(5))\n+    pub mod compiled;\n+}\n+pub mod parm;\n+\n+\n+fn cap_for_attr(attr: Attr) -> &'static str {\n+    match attr {\n+        Attr::Bold => \"bold\",\n+        Attr::Dim => \"dim\",\n+        Attr::Italic(true) => \"sitm\",\n+        Attr::Italic(false) => \"ritm\",\n+        Attr::Underline(true) => \"smul\",\n+        Attr::Underline(false) => \"rmul\",\n+        Attr::Blink => \"blink\",\n+        Attr::Standout(true) => \"smso\",\n+        Attr::Standout(false) => \"rmso\",\n+        Attr::Reverse => \"rev\",\n+        Attr::Secure => \"invis\",\n+        Attr::ForegroundColor(_) => \"setaf\",\n+        Attr::BackgroundColor(_) => \"setab\",\n+    }\n+}\n+\n+/// A Terminal that knows how many colors it supports, with a reference to its\n+/// parsed Terminfo database record.\n+pub struct TerminfoTerminal<T> {\n+    num_colors: u16,\n+    out: T,\n+    ti: TermInfo,\n+}\n+\n+impl<T: Write + Send> Terminal for TerminfoTerminal<T> {\n+    type Output = T;\n+    fn fg(&mut self, color: color::Color) -> io::Result<bool> {\n+        let color = self.dim_if_necessary(color);\n+        if self.num_colors > color {\n+            return self.apply_cap(\"setaf\", &[Param::Number(color as i32)]);\n+        }\n+        Ok(false)\n+    }\n+\n+    fn bg(&mut self, color: color::Color) -> io::Result<bool> {\n+        let color = self.dim_if_necessary(color);\n+        if self.num_colors > color {\n+            return self.apply_cap(\"setab\", &[Param::Number(color as i32)]);\n+        }\n+        Ok(false)\n+    }\n+\n+    fn attr(&mut self, attr: Attr) -> io::Result<bool> {\n+        match attr {\n+            Attr::ForegroundColor(c) => self.fg(c),\n+            Attr::BackgroundColor(c) => self.bg(c),\n+            _ => self.apply_cap(cap_for_attr(attr), &[]),\n+        }\n+    }\n+\n+    fn supports_attr(&self, attr: Attr) -> bool {\n+        match attr {\n+            Attr::ForegroundColor(_) | Attr::BackgroundColor(_) => self.num_colors > 0,\n+            _ => {\n+                let cap = cap_for_attr(attr);\n+                self.ti.strings.get(cap).is_some()\n+            }\n+        }\n+    }\n+\n+    fn reset(&mut self) -> io::Result<bool> {\n+        // are there any terminals that have color/attrs and not sgr0?\n+        // Try falling back to sgr, then op\n+        let cmd = match [\"sgr0\", \"sgr\", \"op\"]\n+                            .iter()\n+                            .filter_map(|cap| self.ti.strings.get(*cap))\n+                            .next() {\n+            Some(op) => {\n+                match expand(&op, &[], &mut Variables::new()) {\n+                    Ok(cmd) => cmd,\n+                    Err(e) => return Err(io::Error::new(io::ErrorKind::InvalidData, e)),\n+                }\n+            }\n+            None => return Ok(false),\n+        };\n+        self.out.write_all(&cmd).and(Ok(true))\n+    }\n+\n+    fn get_ref(&self) -> &T {\n+        &self.out\n+    }\n+\n+    fn get_mut(&mut self) -> &mut T {\n+        &mut self.out\n+    }\n+\n+    fn into_inner(self) -> T\n+        where Self: Sized\n+    {\n+        self.out\n+    }\n+}\n+\n+impl<T: Write + Send> TerminfoTerminal<T> {\n+    /// Creates a new TerminfoTerminal with the given TermInfo and Write.\n+    pub fn new_with_terminfo(out: T, terminfo: TermInfo) -> TerminfoTerminal<T> {\n+        let nc = if terminfo.strings.contains_key(\"setaf\") &&\n+                    terminfo.strings.contains_key(\"setab\") {\n+            terminfo.numbers.get(\"colors\").map_or(0, |&n| n)\n+        } else {\n+            0\n+        };\n+\n+        TerminfoTerminal {\n+            out,\n+            ti: terminfo,\n+            num_colors: nc,\n+        }\n+    }\n+\n+    /// Creates a new TerminfoTerminal for the current environment with the given Write.\n+    ///\n+    /// Returns `None` when the terminfo cannot be found or parsed.\n+    pub fn new(out: T) -> Option<TerminfoTerminal<T>> {\n+        TermInfo::from_env().map(move |ti| TerminfoTerminal::new_with_terminfo(out, ti)).ok()\n+    }\n+\n+    fn dim_if_necessary(&self, color: color::Color) -> color::Color {\n+        if color >= self.num_colors && color >= 8 && color < 16 {\n+            color - 8\n+        } else {\n+            color\n+        }\n+    }\n+\n+    fn apply_cap(&mut self, cmd: &str, params: &[Param]) -> io::Result<bool> {\n+        match self.ti.strings.get(cmd) {\n+            Some(cmd) => {\n+                match expand(&cmd, params, &mut Variables::new()) {\n+                    Ok(s) => self.out.write_all(&s).and(Ok(true)),\n+                    Err(e) => Err(io::Error::new(io::ErrorKind::InvalidData, e)),\n+                }\n+            }\n+            None => Ok(false),\n+        }\n+    }\n+}\n+\n+\n+impl<T: Write> Write for TerminfoTerminal<T> {\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        self.out.write(buf)\n+    }\n+\n+    fn flush(&mut self) -> io::Result<()> {\n+        self.out.flush()\n+    }\n+}"}, {"sha": "28229bd87b0a5ebc632b977f3f24130c023e5140", "filename": "src/libterm/terminfo/parm.rs", "status": "added", "additions": 669, "deletions": 0, "changes": 669, "blob_url": "https://github.com/rust-lang/rust/blob/28ea249ab526c6b114c4dc9ba311fc62fccb28e2/src%2Flibterm%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28ea249ab526c6b114c4dc9ba311fc62fccb28e2/src%2Flibterm%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparm.rs?ref=28ea249ab526c6b114c4dc9ba311fc62fccb28e2", "patch": "@@ -0,0 +1,669 @@\n+//! Parameterized string expansion\n+\n+use self::Param::*;\n+use self::States::*;\n+\n+use std::iter::repeat;\n+\n+#[derive(Clone, Copy, PartialEq)]\n+enum States {\n+    Nothing,\n+    Percent,\n+    SetVar,\n+    GetVar,\n+    PushParam,\n+    CharConstant,\n+    CharClose,\n+    IntConstant(i32),\n+    FormatPattern(Flags, FormatState),\n+    SeekIfElse(usize),\n+    SeekIfElsePercent(usize),\n+    SeekIfEnd(usize),\n+    SeekIfEndPercent(usize),\n+}\n+\n+#[derive(Copy, PartialEq, Clone)]\n+enum FormatState {\n+    Flags,\n+    Width,\n+    Precision,\n+}\n+\n+/// Types of parameters a capability can use\n+#[allow(missing_docs)]\n+#[derive(Clone)]\n+pub enum Param {\n+    Words(String),\n+    Number(i32),\n+}\n+\n+/// Container for static and dynamic variable arrays\n+pub struct Variables {\n+    /// Static variables A-Z\n+    sta_va: [Param; 26],\n+    /// Dynamic variables a-z\n+    dyn_va: [Param; 26],\n+}\n+\n+impl Variables {\n+    /// Returns a new zero-initialized Variables\n+    pub fn new() -> Variables {\n+        Variables {\n+            sta_va: [\n+                Number(0), Number(0), Number(0), Number(0), Number(0), Number(0), Number(0),\n+                Number(0), Number(0), Number(0), Number(0), Number(0), Number(0), Number(0),\n+                Number(0), Number(0), Number(0), Number(0), Number(0), Number(0), Number(0),\n+                Number(0), Number(0), Number(0), Number(0), Number(0)\n+            ],\n+            dyn_va: [\n+                Number(0), Number(0), Number(0), Number(0), Number(0), Number(0), Number(0),\n+                Number(0), Number(0), Number(0), Number(0), Number(0), Number(0), Number(0),\n+                Number(0), Number(0), Number(0), Number(0), Number(0), Number(0), Number(0),\n+                Number(0), Number(0), Number(0), Number(0), Number(0)\n+            ],\n+        }\n+    }\n+}\n+\n+/// Expand a parameterized capability\n+///\n+/// # Arguments\n+/// * `cap`    - string to expand\n+/// * `params` - vector of params for %p1 etc\n+/// * `vars`   - Variables struct for %Pa etc\n+///\n+/// To be compatible with ncurses, `vars` should be the same between calls to `expand` for\n+/// multiple capabilities for the same terminal.\n+pub fn expand(cap: &[u8], params: &[Param], vars: &mut Variables) -> Result<Vec<u8>, String> {\n+    let mut state = Nothing;\n+\n+    // expanded cap will only rarely be larger than the cap itself\n+    let mut output = Vec::with_capacity(cap.len());\n+\n+    let mut stack: Vec<Param> = Vec::new();\n+\n+    // Copy parameters into a local vector for mutability\n+    let mut mparams = [Number(0), Number(0), Number(0), Number(0), Number(0), Number(0),\n+                       Number(0), Number(0), Number(0)];\n+    for (dst, src) in mparams.iter_mut().zip(params.iter()) {\n+        *dst = (*src).clone();\n+    }\n+\n+    for &c in cap.iter() {\n+        let cur = c as char;\n+        let mut old_state = state;\n+        match state {\n+            Nothing => {\n+                if cur == '%' {\n+                    state = Percent;\n+                } else {\n+                    output.push(c);\n+                }\n+            }\n+            Percent => {\n+                match cur {\n+                    '%' => {\n+                        output.push(c);\n+                        state = Nothing\n+                    }\n+                    'c' => {\n+                        match stack.pop() {\n+                            // if c is 0, use 0200 (128) for ncurses compatibility\n+                            Some(Number(0)) => output.push(128u8),\n+                            // Don't check bounds. ncurses just casts and truncates.\n+                            Some(Number(c)) => output.push(c as u8),\n+                            Some(_) => return Err(\"a non-char was used with %c\".to_string()),\n+                            None => return Err(\"stack is empty\".to_string()),\n+                        }\n+                    }\n+                    'p' => state = PushParam,\n+                    'P' => state = SetVar,\n+                    'g' => state = GetVar,\n+                    '\\'' => state = CharConstant,\n+                    '{' => state = IntConstant(0),\n+                    'l' => {\n+                        match stack.pop() {\n+                            Some(Words(s)) => stack.push(Number(s.len() as i32)),\n+                            Some(_) => return Err(\"a non-str was used with %l\".to_string()),\n+                            None => return Err(\"stack is empty\".to_string()),\n+                        }\n+                    }\n+                    '+' | '-' | '/' | '*' | '^' | '&' | '|' | 'm' => {\n+                        match (stack.pop(), stack.pop()) {\n+                            (Some(Number(y)), Some(Number(x))) => {\n+                                stack.push(Number(match cur {\n+                                    '+' => x + y,\n+                                    '-' => x - y,\n+                                    '*' => x * y,\n+                                    '/' => x / y,\n+                                    '|' => x | y,\n+                                    '&' => x & y,\n+                                    '^' => x ^ y,\n+                                    'm' => x % y,\n+                                    _ => unreachable!(\"All cases handled\"),\n+                                }))\n+                            }\n+                            (Some(_), Some(_)) => {\n+                                return Err(format!(\"non-numbers on stack with {}\", cur))\n+                            }\n+                            _ => return Err(\"stack is empty\".to_string()),\n+                        }\n+                    }\n+                    '=' | '>' | '<' | 'A' | 'O' => {\n+                        match (stack.pop(), stack.pop()) {\n+                            (Some(Number(y)), Some(Number(x))) => {\n+                                stack.push(Number(if match cur {\n+                                    '=' => x == y,\n+                                    '<' => x < y,\n+                                    '>' => x > y,\n+                                    'A' => x > 0 && y > 0,\n+                                    'O' => x > 0 || y > 0,\n+                                    _ => unreachable!(),\n+                                } {\n+                                    1\n+                                } else {\n+                                    0\n+                                }))\n+                            }\n+                            (Some(_), Some(_)) => {\n+                                return Err(format!(\"non-numbers on stack with {}\", cur))\n+                            }\n+                            _ => return Err(\"stack is empty\".to_string()),\n+                        }\n+                    }\n+                    '!' | '~' => {\n+                        match stack.pop() {\n+                            Some(Number(x)) => {\n+                                stack.push(Number(match cur {\n+                                    '!' if x > 0 => 0,\n+                                    '!' => 1,\n+                                    '~' => !x,\n+                                    _ => unreachable!(),\n+                                }))\n+                            }\n+                            Some(_) => return Err(format!(\"non-numbers on stack with {}\", cur)),\n+                            None => return Err(\"stack is empty\".to_string()),\n+                        }\n+                    }\n+                    'i' => {\n+                        match (&mparams[0], &mparams[1]) {\n+                            (&Number(x), &Number(y)) => {\n+                                mparams[0] = Number(x + 1);\n+                                mparams[1] = Number(y + 1);\n+                            }\n+                            _ => {\n+                                return Err(\"first two params not numbers with %i\".to_string())\n+                            }\n+                        }\n+                    }\n+\n+                    // printf-style support for %doxXs\n+                    'd' | 'o' | 'x' | 'X' | 's' => {\n+                        if let Some(arg) = stack.pop() {\n+                            let flags = Flags::new();\n+                            let res = format(arg, FormatOp::from_char(cur), flags)?;\n+                            output.extend(res.iter().cloned());\n+                        } else {\n+                            return Err(\"stack is empty\".to_string());\n+                        }\n+                    }\n+                    ':' | '#' | ' ' | '.' | '0'..='9' => {\n+                        let mut flags = Flags::new();\n+                        let mut fstate = FormatState::Flags;\n+                        match cur {\n+                            ':' => (),\n+                            '#' => flags.alternate = true,\n+                            ' ' => flags.space = true,\n+                            '.' => fstate = FormatState::Precision,\n+                            '0'..='9' => {\n+                                flags.width = cur as usize - '0' as usize;\n+                                fstate = FormatState::Width;\n+                            }\n+                            _ => unreachable!(),\n+                        }\n+                        state = FormatPattern(flags, fstate);\n+                    }\n+\n+                    // conditionals\n+                    '?' => (),\n+                    't' => {\n+                        match stack.pop() {\n+                            Some(Number(0)) => state = SeekIfElse(0),\n+                            Some(Number(_)) => (),\n+                            Some(_) => {\n+                                return Err(\"non-number on stack with conditional\".to_string())\n+                            }\n+                            None => return Err(\"stack is empty\".to_string()),\n+                        }\n+                    }\n+                    'e' => state = SeekIfEnd(0),\n+                    ';' => (),\n+                    _ => return Err(format!(\"unrecognized format option {}\", cur)),\n+                }\n+            }\n+            PushParam => {\n+                // params are 1-indexed\n+                stack.push(mparams[match cur.to_digit(10) {\n+                               Some(d) => d as usize - 1,\n+                               None => return Err(\"bad param number\".to_string()),\n+                           }]\n+                           .clone());\n+            }\n+            SetVar => {\n+                if cur >= 'A' && cur <= 'Z' {\n+                    if let Some(arg) = stack.pop() {\n+                        let idx = (cur as u8) - b'A';\n+                        vars.sta_va[idx as usize] = arg;\n+                    } else {\n+                        return Err(\"stack is empty\".to_string());\n+                    }\n+                } else if cur >= 'a' && cur <= 'z' {\n+                    if let Some(arg) = stack.pop() {\n+                        let idx = (cur as u8) - b'a';\n+                        vars.dyn_va[idx as usize] = arg;\n+                    } else {\n+                        return Err(\"stack is empty\".to_string());\n+                    }\n+                } else {\n+                    return Err(\"bad variable name in %P\".to_string());\n+                }\n+            }\n+            GetVar => {\n+                if cur >= 'A' && cur <= 'Z' {\n+                    let idx = (cur as u8) - b'A';\n+                    stack.push(vars.sta_va[idx as usize].clone());\n+                } else if cur >= 'a' && cur <= 'z' {\n+                    let idx = (cur as u8) - b'a';\n+                    stack.push(vars.dyn_va[idx as usize].clone());\n+                } else {\n+                    return Err(\"bad variable name in %g\".to_string());\n+                }\n+            }\n+            CharConstant => {\n+                stack.push(Number(c as i32));\n+                state = CharClose;\n+            }\n+            CharClose => {\n+                if cur != '\\'' {\n+                    return Err(\"malformed character constant\".to_string());\n+                }\n+            }\n+            IntConstant(i) => {\n+                if cur == '}' {\n+                    stack.push(Number(i));\n+                    state = Nothing;\n+                } else if let Some(digit) = cur.to_digit(10) {\n+                    match i.checked_mul(10).and_then(|i_ten| i_ten.checked_add(digit as i32)) {\n+                        Some(i) => {\n+                            state = IntConstant(i);\n+                            old_state = Nothing;\n+                        }\n+                        None => return Err(\"int constant too large\".to_string()),\n+                    }\n+                } else {\n+                    return Err(\"bad int constant\".to_string());\n+                }\n+            }\n+            FormatPattern(ref mut flags, ref mut fstate) => {\n+                old_state = Nothing;\n+                match (*fstate, cur) {\n+                    (_, 'd') | (_, 'o') | (_, 'x') | (_, 'X') | (_, 's') => {\n+                        if let Some(arg) = stack.pop() {\n+                            let res = format(arg, FormatOp::from_char(cur), *flags)?;\n+                            output.extend(res.iter().cloned());\n+                            // will cause state to go to Nothing\n+                            old_state = FormatPattern(*flags, *fstate);\n+                        } else {\n+                            return Err(\"stack is empty\".to_string());\n+                        }\n+                    }\n+                    (FormatState::Flags, '#') => {\n+                        flags.alternate = true;\n+                    }\n+                    (FormatState::Flags, '-') => {\n+                        flags.left = true;\n+                    }\n+                    (FormatState::Flags, '+') => {\n+                        flags.sign = true;\n+                    }\n+                    (FormatState::Flags, ' ') => {\n+                        flags.space = true;\n+                    }\n+                    (FormatState::Flags, '0'..='9') => {\n+                        flags.width = cur as usize - '0' as usize;\n+                        *fstate = FormatState::Width;\n+                    }\n+                    (FormatState::Flags, '.') => {\n+                        *fstate = FormatState::Precision;\n+                    }\n+                    (FormatState::Width, '0'..='9') => {\n+                        let old = flags.width;\n+                        flags.width = flags.width * 10 + (cur as usize - '0' as usize);\n+                        if flags.width < old {\n+                            return Err(\"format width overflow\".to_string());\n+                        }\n+                    }\n+                    (FormatState::Width, '.') => {\n+                        *fstate = FormatState::Precision;\n+                    }\n+                    (FormatState::Precision, '0'..='9') => {\n+                        let old = flags.precision;\n+                        flags.precision = flags.precision * 10 + (cur as usize - '0' as usize);\n+                        if flags.precision < old {\n+                            return Err(\"format precision overflow\".to_string());\n+                        }\n+                    }\n+                    _ => return Err(\"invalid format specifier\".to_string()),\n+                }\n+            }\n+            SeekIfElse(level) => {\n+                if cur == '%' {\n+                    state = SeekIfElsePercent(level);\n+                }\n+                old_state = Nothing;\n+            }\n+            SeekIfElsePercent(level) => {\n+                if cur == ';' {\n+                    if level == 0 {\n+                        state = Nothing;\n+                    } else {\n+                        state = SeekIfElse(level - 1);\n+                    }\n+                } else if cur == 'e' && level == 0 {\n+                    state = Nothing;\n+                } else if cur == '?' {\n+                    state = SeekIfElse(level + 1);\n+                } else {\n+                    state = SeekIfElse(level);\n+                }\n+            }\n+            SeekIfEnd(level) => {\n+                if cur == '%' {\n+                    state = SeekIfEndPercent(level);\n+                }\n+                old_state = Nothing;\n+            }\n+            SeekIfEndPercent(level) => {\n+                if cur == ';' {\n+                    if level == 0 {\n+                        state = Nothing;\n+                    } else {\n+                        state = SeekIfEnd(level - 1);\n+                    }\n+                } else if cur == '?' {\n+                    state = SeekIfEnd(level + 1);\n+                } else {\n+                    state = SeekIfEnd(level);\n+                }\n+            }\n+        }\n+        if state == old_state {\n+            state = Nothing;\n+        }\n+    }\n+    Ok(output)\n+}\n+\n+#[derive(Copy, PartialEq, Clone)]\n+struct Flags {\n+    width: usize,\n+    precision: usize,\n+    alternate: bool,\n+    left: bool,\n+    sign: bool,\n+    space: bool,\n+}\n+\n+impl Flags {\n+    fn new() -> Flags {\n+        Flags {\n+            width: 0,\n+            precision: 0,\n+            alternate: false,\n+            left: false,\n+            sign: false,\n+            space: false,\n+        }\n+    }\n+}\n+\n+#[derive(Copy, Clone)]\n+enum FormatOp {\n+    Digit,\n+    Octal,\n+    LowerHex,\n+    UpperHex,\n+    String,\n+}\n+\n+impl FormatOp {\n+    fn from_char(c: char) -> FormatOp {\n+        match c {\n+            'd' => FormatOp::Digit,\n+            'o' => FormatOp::Octal,\n+            'x' => FormatOp::LowerHex,\n+            'X' => FormatOp::UpperHex,\n+            's' => FormatOp::String,\n+            _ => panic!(\"bad FormatOp char\"),\n+        }\n+    }\n+    fn to_char(self) -> char {\n+        match self {\n+            FormatOp::Digit => 'd',\n+            FormatOp::Octal => 'o',\n+            FormatOp::LowerHex => 'x',\n+            FormatOp::UpperHex => 'X',\n+            FormatOp::String => 's',\n+        }\n+    }\n+}\n+\n+fn format(val: Param, op: FormatOp, flags: Flags) -> Result<Vec<u8>, String> {\n+    let mut s = match val {\n+        Number(d) => {\n+            match op {\n+                FormatOp::Digit => {\n+                    if flags.sign {\n+                        format!(\"{:+01$}\", d, flags.precision)\n+                    } else if d < 0 {\n+                        // C doesn't take sign into account in precision calculation.\n+                        format!(\"{:01$}\", d, flags.precision + 1)\n+                    } else if flags.space {\n+                        format!(\" {:01$}\", d, flags.precision)\n+                    } else {\n+                        format!(\"{:01$}\", d, flags.precision)\n+                    }\n+                }\n+                FormatOp::Octal => {\n+                    if flags.alternate {\n+                        // Leading octal zero counts against precision.\n+                        format!(\"0{:01$o}\", d, flags.precision.saturating_sub(1))\n+                    } else {\n+                        format!(\"{:01$o}\", d, flags.precision)\n+                    }\n+                }\n+                FormatOp::LowerHex => {\n+                    if flags.alternate && d != 0 {\n+                        format!(\"0x{:01$x}\", d, flags.precision)\n+                    } else {\n+                        format!(\"{:01$x}\", d, flags.precision)\n+                    }\n+                }\n+                FormatOp::UpperHex => {\n+                    if flags.alternate && d != 0 {\n+                        format!(\"0X{:01$X}\", d, flags.precision)\n+                    } else {\n+                        format!(\"{:01$X}\", d, flags.precision)\n+                    }\n+                }\n+                FormatOp::String => return Err(\"non-number on stack with %s\".to_string()),\n+            }\n+            .into_bytes()\n+        }\n+        Words(s) => {\n+            match op {\n+                FormatOp::String => {\n+                    let mut s = s.into_bytes();\n+                    if flags.precision > 0 && flags.precision < s.len() {\n+                        s.truncate(flags.precision);\n+                    }\n+                    s\n+                }\n+                _ => return Err(format!(\"non-string on stack with %{}\", op.to_char())),\n+            }\n+        }\n+    };\n+    if flags.width > s.len() {\n+        let n = flags.width - s.len();\n+        if flags.left {\n+            s.extend(repeat(b' ').take(n));\n+        } else {\n+            let mut s_ = Vec::with_capacity(flags.width);\n+            s_.extend(repeat(b' ').take(n));\n+            s_.extend(s.into_iter());\n+            s = s_;\n+        }\n+    }\n+    Ok(s)\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use super::{expand, Variables};\n+    use super::Param::{self, Words, Number};\n+    use std::result::Result::Ok;\n+\n+    #[test]\n+    fn test_basic_setabf() {\n+        let s = b\"\\\\E[48;5;%p1%dm\";\n+        assert_eq!(expand(s, &[Number(1)], &mut Variables::new()).unwrap(),\n+                   \"\\\\E[48;5;1m\".bytes().collect::<Vec<_>>());\n+    }\n+\n+    #[test]\n+    fn test_multiple_int_constants() {\n+        assert_eq!(expand(b\"%{1}%{2}%d%d\", &[], &mut Variables::new()).unwrap(),\n+                   \"21\".bytes().collect::<Vec<_>>());\n+    }\n+\n+    #[test]\n+    fn test_op_i() {\n+        let mut vars = Variables::new();\n+        assert_eq!(expand(b\"%p1%d%p2%d%p3%d%i%p1%d%p2%d%p3%d\",\n+                          &[Number(1), Number(2), Number(3)],\n+                          &mut vars),\n+                   Ok(\"123233\".bytes().collect::<Vec<_>>()));\n+        assert_eq!(expand(b\"%p1%d%p2%d%i%p1%d%p2%d\", &[], &mut vars),\n+                   Ok(\"0011\".bytes().collect::<Vec<_>>()));\n+    }\n+\n+    #[test]\n+    fn test_param_stack_failure_conditions() {\n+        let mut varstruct = Variables::new();\n+        let vars = &mut varstruct;\n+        fn get_res(fmt: &str,\n+                   cap: &str,\n+                   params: &[Param],\n+                   vars: &mut Variables)\n+                   -> Result<Vec<u8>, String> {\n+            let mut u8v: Vec<_> = fmt.bytes().collect();\n+            u8v.extend(cap.as_bytes().iter().map(|&b| b));\n+            expand(&u8v, params, vars)\n+        }\n+\n+        let caps = [\"%d\", \"%c\", \"%s\", \"%Pa\", \"%l\", \"%!\", \"%~\"];\n+        for &cap in caps.iter() {\n+            let res = get_res(\"\", cap, &[], vars);\n+            assert!(res.is_err(),\n+                    \"Op {} succeeded incorrectly with 0 stack entries\",\n+                    cap);\n+            let p = if cap == \"%s\" || cap == \"%l\" {\n+                Words(\"foo\".to_string())\n+            } else {\n+                Number(97)\n+            };\n+            let res = get_res(\"%p1\", cap, &[p], vars);\n+            assert!(res.is_ok(),\n+                    \"Op {} failed with 1 stack entry: {}\",\n+                    cap,\n+                    res.unwrap_err());\n+        }\n+        let caps = [\"%+\", \"%-\", \"%*\", \"%/\", \"%m\", \"%&\", \"%|\", \"%A\", \"%O\"];\n+        for &cap in caps.iter() {\n+            let res = expand(cap.as_bytes(), &[], vars);\n+            assert!(res.is_err(),\n+                    \"Binop {} succeeded incorrectly with 0 stack entries\",\n+                    cap);\n+            let res = get_res(\"%{1}\", cap, &[], vars);\n+            assert!(res.is_err(),\n+                    \"Binop {} succeeded incorrectly with 1 stack entry\",\n+                    cap);\n+            let res = get_res(\"%{1}%{2}\", cap, &[], vars);\n+            assert!(res.is_ok(),\n+                    \"Binop {} failed with 2 stack entries: {}\",\n+                    cap,\n+                    res.unwrap_err());\n+        }\n+    }\n+\n+    #[test]\n+    fn test_push_bad_param() {\n+        assert!(expand(b\"%pa\", &[], &mut Variables::new()).is_err());\n+    }\n+\n+    #[test]\n+    fn test_comparison_ops() {\n+        let v = [('<', [1u8, 0u8, 0u8]), ('=', [0u8, 1u8, 0u8]), ('>', [0u8, 0u8, 1u8])];\n+        for &(op, bs) in v.iter() {\n+            let s = format!(\"%{{1}}%{{2}}%{}%d\", op);\n+            let res = expand(s.as_bytes(), &[], &mut Variables::new());\n+            assert!(res.is_ok(), res.unwrap_err());\n+            assert_eq!(res.unwrap(), vec![b'0' + bs[0]]);\n+            let s = format!(\"%{{1}}%{{1}}%{}%d\", op);\n+            let res = expand(s.as_bytes(), &[], &mut Variables::new());\n+            assert!(res.is_ok(), res.unwrap_err());\n+            assert_eq!(res.unwrap(), vec![b'0' + bs[1]]);\n+            let s = format!(\"%{{2}}%{{1}}%{}%d\", op);\n+            let res = expand(s.as_bytes(), &[], &mut Variables::new());\n+            assert!(res.is_ok(), res.unwrap_err());\n+            assert_eq!(res.unwrap(), vec![b'0' + bs[2]]);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_conditionals() {\n+        let mut vars = Variables::new();\n+        let s = b\"\\\\E[%?%p1%{8}%<%t3%p1%d%e%p1%{16}%<%t9%p1%{8}%-%d%e38;5;%p1%d%;m\";\n+        let res = expand(s, &[Number(1)], &mut vars);\n+        assert!(res.is_ok(), res.unwrap_err());\n+        assert_eq!(res.unwrap(), \"\\\\E[31m\".bytes().collect::<Vec<_>>());\n+        let res = expand(s, &[Number(8)], &mut vars);\n+        assert!(res.is_ok(), res.unwrap_err());\n+        assert_eq!(res.unwrap(), \"\\\\E[90m\".bytes().collect::<Vec<_>>());\n+        let res = expand(s, &[Number(42)], &mut vars);\n+        assert!(res.is_ok(), res.unwrap_err());\n+        assert_eq!(res.unwrap(), \"\\\\E[38;5;42m\".bytes().collect::<Vec<_>>());\n+    }\n+\n+    #[test]\n+    fn test_format() {\n+        let mut varstruct = Variables::new();\n+        let vars = &mut varstruct;\n+        assert_eq!(expand(b\"%p1%s%p2%2s%p3%2s%p4%.2s\",\n+                          &[Words(\"foo\".to_string()),\n+                            Words(\"foo\".to_string()),\n+                            Words(\"f\".to_string()),\n+                            Words(\"foo\".to_string())],\n+                          vars),\n+                   Ok(\"foofoo ffo\".bytes().collect::<Vec<_>>()));\n+        assert_eq!(expand(b\"%p1%:-4.2s\", &[Words(\"foo\".to_string())], vars),\n+                   Ok(\"fo  \".bytes().collect::<Vec<_>>()));\n+\n+        assert_eq!(expand(b\"%p1%d%p1%.3d%p1%5d%p1%:+d\", &[Number(1)], vars),\n+                   Ok(\"1001    1+1\".bytes().collect::<Vec<_>>()));\n+        assert_eq!(expand(b\"%p1%o%p1%#o%p2%6.4x%p2%#6.4X\",\n+                          &[Number(15), Number(27)],\n+                          vars),\n+                   Ok(\"17017  001b0X001B\".bytes().collect::<Vec<_>>()));\n+    }\n+}"}, {"sha": "05a8c9420ed942e489588b2c7ce72e52b621dd94", "filename": "src/libterm/terminfo/parser/compiled.rs", "status": "added", "additions": 346, "deletions": 0, "changes": 346, "blob_url": "https://github.com/rust-lang/rust/blob/28ea249ab526c6b114c4dc9ba311fc62fccb28e2/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28ea249ab526c6b114c4dc9ba311fc62fccb28e2/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparser%2Fcompiled.rs?ref=28ea249ab526c6b114c4dc9ba311fc62fccb28e2", "patch": "@@ -0,0 +1,346 @@\n+#![allow(non_upper_case_globals, missing_docs)]\n+\n+//! ncurses-compatible compiled terminfo format parsing (term(5))\n+\n+use std::collections::HashMap;\n+use std::io;\n+use std::io::prelude::*;\n+use super::super::TermInfo;\n+\n+// These are the orders ncurses uses in its compiled format (as of 5.9). Not sure if portable.\n+\n+#[rustfmt::skip]\n+pub static boolfnames: &[&str] = &[\"auto_left_margin\", \"auto_right_margin\",\n+    \"no_esc_ctlc\", \"ceol_standout_glitch\", \"eat_newline_glitch\", \"erase_overstrike\", \"generic_type\",\n+    \"hard_copy\", \"has_meta_key\", \"has_status_line\", \"insert_null_glitch\", \"memory_above\",\n+    \"memory_below\", \"move_insert_mode\", \"move_standout_mode\", \"over_strike\", \"status_line_esc_ok\",\n+    \"dest_tabs_magic_smso\", \"tilde_glitch\", \"transparent_underline\", \"xon_xoff\", \"needs_xon_xoff\",\n+    \"prtr_silent\", \"hard_cursor\", \"non_rev_rmcup\", \"no_pad_char\", \"non_dest_scroll_region\",\n+    \"can_change\", \"back_color_erase\", \"hue_lightness_saturation\", \"col_addr_glitch\",\n+    \"cr_cancels_micro_mode\", \"has_print_wheel\", \"row_addr_glitch\", \"semi_auto_right_margin\",\n+    \"cpi_changes_res\", \"lpi_changes_res\", \"backspaces_with_bs\", \"crt_no_scrolling\",\n+    \"no_correctly_working_cr\", \"gnu_has_meta_key\", \"linefeed_is_newline\", \"has_hardware_tabs\",\n+    \"return_does_clr_eol\"];\n+\n+#[rustfmt::skip]\n+pub static boolnames: &[&str] = &[\"bw\", \"am\", \"xsb\", \"xhp\", \"xenl\", \"eo\",\n+    \"gn\", \"hc\", \"km\", \"hs\", \"in\", \"db\", \"da\", \"mir\", \"msgr\", \"os\", \"eslok\", \"xt\", \"hz\", \"ul\", \"xon\",\n+    \"nxon\", \"mc5i\", \"chts\", \"nrrmc\", \"npc\", \"ndscr\", \"ccc\", \"bce\", \"hls\", \"xhpa\", \"crxm\", \"daisy\",\n+    \"xvpa\", \"sam\", \"cpix\", \"lpix\", \"OTbs\", \"OTns\", \"OTnc\", \"OTMT\", \"OTNL\", \"OTpt\", \"OTxr\"];\n+\n+#[rustfmt::skip]\n+pub static numfnames: &[&str] = &[ \"columns\", \"init_tabs\", \"lines\",\n+    \"lines_of_memory\", \"magic_cookie_glitch\", \"padding_baud_rate\", \"virtual_terminal\",\n+    \"width_status_line\", \"num_labels\", \"label_height\", \"label_width\", \"max_attributes\",\n+    \"maximum_windows\", \"max_colors\", \"max_pairs\", \"no_color_video\", \"buffer_capacity\",\n+    \"dot_vert_spacing\", \"dot_horz_spacing\", \"max_micro_address\", \"max_micro_jump\", \"micro_col_size\",\n+    \"micro_line_size\", \"number_of_pins\", \"output_res_char\", \"output_res_line\",\n+    \"output_res_horz_inch\", \"output_res_vert_inch\", \"print_rate\", \"wide_char_size\", \"buttons\",\n+    \"bit_image_entwining\", \"bit_image_type\", \"magic_cookie_glitch_ul\", \"carriage_return_delay\",\n+    \"new_line_delay\", \"backspace_delay\", \"horizontal_tab_delay\", \"number_of_function_keys\"];\n+\n+#[rustfmt::skip]\n+pub static numnames: &[&str] = &[ \"cols\", \"it\", \"lines\", \"lm\", \"xmc\", \"pb\",\n+    \"vt\", \"wsl\", \"nlab\", \"lh\", \"lw\", \"ma\", \"wnum\", \"colors\", \"pairs\", \"ncv\", \"bufsz\", \"spinv\",\n+    \"spinh\", \"maddr\", \"mjump\", \"mcs\", \"mls\", \"npins\", \"orc\", \"orl\", \"orhi\", \"orvi\", \"cps\", \"widcs\",\n+    \"btns\", \"bitwin\", \"bitype\", \"UTug\", \"OTdC\", \"OTdN\", \"OTdB\", \"OTdT\", \"OTkn\"];\n+\n+#[rustfmt::skip]\n+pub static stringfnames: &[&str] = &[ \"back_tab\", \"bell\", \"carriage_return\",\n+    \"change_scroll_region\", \"clear_all_tabs\", \"clear_screen\", \"clr_eol\", \"clr_eos\",\n+    \"column_address\", \"command_character\", \"cursor_address\", \"cursor_down\", \"cursor_home\",\n+    \"cursor_invisible\", \"cursor_left\", \"cursor_mem_address\", \"cursor_normal\", \"cursor_right\",\n+    \"cursor_to_ll\", \"cursor_up\", \"cursor_visible\", \"delete_character\", \"delete_line\",\n+    \"dis_status_line\", \"down_half_line\", \"enter_alt_charset_mode\", \"enter_blink_mode\",\n+    \"enter_bold_mode\", \"enter_ca_mode\", \"enter_delete_mode\", \"enter_dim_mode\", \"enter_insert_mode\",\n+    \"enter_secure_mode\", \"enter_protected_mode\", \"enter_reverse_mode\", \"enter_standout_mode\",\n+    \"enter_underline_mode\", \"erase_chars\", \"exit_alt_charset_mode\", \"exit_attribute_mode\",\n+    \"exit_ca_mode\", \"exit_delete_mode\", \"exit_insert_mode\", \"exit_standout_mode\",\n+    \"exit_underline_mode\", \"flash_screen\", \"form_feed\", \"from_status_line\", \"init_1string\",\n+    \"init_2string\", \"init_3string\", \"init_file\", \"insert_character\", \"insert_line\",\n+    \"insert_padding\", \"key_backspace\", \"key_catab\", \"key_clear\", \"key_ctab\", \"key_dc\", \"key_dl\",\n+    \"key_down\", \"key_eic\", \"key_eol\", \"key_eos\", \"key_f0\", \"key_f1\", \"key_f10\", \"key_f2\", \"key_f3\",\n+    \"key_f4\", \"key_f5\", \"key_f6\", \"key_f7\", \"key_f8\", \"key_f9\", \"key_home\", \"key_ic\", \"key_il\",\n+    \"key_left\", \"key_ll\", \"key_npage\", \"key_ppage\", \"key_right\", \"key_sf\", \"key_sr\", \"key_stab\",\n+    \"key_up\", \"keypad_local\", \"keypad_xmit\", \"lab_f0\", \"lab_f1\", \"lab_f10\", \"lab_f2\", \"lab_f3\",\n+    \"lab_f4\", \"lab_f5\", \"lab_f6\", \"lab_f7\", \"lab_f8\", \"lab_f9\", \"meta_off\", \"meta_on\", \"newline\",\n+    \"pad_char\", \"parm_dch\", \"parm_delete_line\", \"parm_down_cursor\", \"parm_ich\", \"parm_index\",\n+    \"parm_insert_line\", \"parm_left_cursor\", \"parm_right_cursor\", \"parm_rindex\", \"parm_up_cursor\",\n+    \"pkey_key\", \"pkey_local\", \"pkey_xmit\", \"print_screen\", \"prtr_off\", \"prtr_on\", \"repeat_char\",\n+    \"reset_1string\", \"reset_2string\", \"reset_3string\", \"reset_file\", \"restore_cursor\",\n+    \"row_address\", \"save_cursor\", \"scroll_forward\", \"scroll_reverse\", \"set_attributes\", \"set_tab\",\n+    \"set_window\", \"tab\", \"to_status_line\", \"underline_char\", \"up_half_line\", \"init_prog\", \"key_a1\",\n+    \"key_a3\", \"key_b2\", \"key_c1\", \"key_c3\", \"prtr_non\", \"char_padding\", \"acs_chars\", \"plab_norm\",\n+    \"key_btab\", \"enter_xon_mode\", \"exit_xon_mode\", \"enter_am_mode\", \"exit_am_mode\", \"xon_character\",\n+    \"xoff_character\", \"ena_acs\", \"label_on\", \"label_off\", \"key_beg\", \"key_cancel\", \"key_close\",\n+    \"key_command\", \"key_copy\", \"key_create\", \"key_end\", \"key_enter\", \"key_exit\", \"key_find\",\n+    \"key_help\", \"key_mark\", \"key_message\", \"key_move\", \"key_next\", \"key_open\", \"key_options\",\n+    \"key_previous\", \"key_print\", \"key_redo\", \"key_reference\", \"key_refresh\", \"key_replace\",\n+    \"key_restart\", \"key_resume\", \"key_save\", \"key_suspend\", \"key_undo\", \"key_sbeg\", \"key_scancel\",\n+    \"key_scommand\", \"key_scopy\", \"key_screate\", \"key_sdc\", \"key_sdl\", \"key_select\", \"key_send\",\n+    \"key_seol\", \"key_sexit\", \"key_sfind\", \"key_shelp\", \"key_shome\", \"key_sic\", \"key_sleft\",\n+    \"key_smessage\", \"key_smove\", \"key_snext\", \"key_soptions\", \"key_sprevious\", \"key_sprint\",\n+    \"key_sredo\", \"key_sreplace\", \"key_sright\", \"key_srsume\", \"key_ssave\", \"key_ssuspend\",\n+    \"key_sundo\", \"req_for_input\", \"key_f11\", \"key_f12\", \"key_f13\", \"key_f14\", \"key_f15\", \"key_f16\",\n+    \"key_f17\", \"key_f18\", \"key_f19\", \"key_f20\", \"key_f21\", \"key_f22\", \"key_f23\", \"key_f24\",\n+    \"key_f25\", \"key_f26\", \"key_f27\", \"key_f28\", \"key_f29\", \"key_f30\", \"key_f31\", \"key_f32\",\n+    \"key_f33\", \"key_f34\", \"key_f35\", \"key_f36\", \"key_f37\", \"key_f38\", \"key_f39\", \"key_f40\",\n+    \"key_f41\", \"key_f42\", \"key_f43\", \"key_f44\", \"key_f45\", \"key_f46\", \"key_f47\", \"key_f48\",\n+    \"key_f49\", \"key_f50\", \"key_f51\", \"key_f52\", \"key_f53\", \"key_f54\", \"key_f55\", \"key_f56\",\n+    \"key_f57\", \"key_f58\", \"key_f59\", \"key_f60\", \"key_f61\", \"key_f62\", \"key_f63\", \"clr_bol\",\n+    \"clear_margins\", \"set_left_margin\", \"set_right_margin\", \"label_format\", \"set_clock\",\n+    \"display_clock\", \"remove_clock\", \"create_window\", \"goto_window\", \"hangup\", \"dial_phone\",\n+    \"quick_dial\", \"tone\", \"pulse\", \"flash_hook\", \"fixed_pause\", \"wait_tone\", \"user0\", \"user1\",\n+    \"user2\", \"user3\", \"user4\", \"user5\", \"user6\", \"user7\", \"user8\", \"user9\", \"orig_pair\",\n+    \"orig_colors\", \"initialize_color\", \"initialize_pair\", \"set_color_pair\", \"set_foreground\",\n+    \"set_background\", \"change_char_pitch\", \"change_line_pitch\", \"change_res_horz\",\n+    \"change_res_vert\", \"define_char\", \"enter_doublewide_mode\", \"enter_draft_quality\",\n+    \"enter_italics_mode\", \"enter_leftward_mode\", \"enter_micro_mode\", \"enter_near_letter_quality\",\n+    \"enter_normal_quality\", \"enter_shadow_mode\", \"enter_subscript_mode\", \"enter_superscript_mode\",\n+    \"enter_upward_mode\", \"exit_doublewide_mode\", \"exit_italics_mode\", \"exit_leftward_mode\",\n+    \"exit_micro_mode\", \"exit_shadow_mode\", \"exit_subscript_mode\", \"exit_superscript_mode\",\n+    \"exit_upward_mode\", \"micro_column_address\", \"micro_down\", \"micro_left\", \"micro_right\",\n+    \"micro_row_address\", \"micro_up\", \"order_of_pins\", \"parm_down_micro\", \"parm_left_micro\",\n+    \"parm_right_micro\", \"parm_up_micro\", \"select_char_set\", \"set_bottom_margin\",\n+    \"set_bottom_margin_parm\", \"set_left_margin_parm\", \"set_right_margin_parm\", \"set_top_margin\",\n+    \"set_top_margin_parm\", \"start_bit_image\", \"start_char_set_def\", \"stop_bit_image\",\n+    \"stop_char_set_def\", \"subscript_characters\", \"superscript_characters\", \"these_cause_cr\",\n+    \"zero_motion\", \"char_set_names\", \"key_mouse\", \"mouse_info\", \"req_mouse_pos\", \"get_mouse\",\n+    \"set_a_foreground\", \"set_a_background\", \"pkey_plab\", \"device_type\", \"code_set_init\",\n+    \"set0_des_seq\", \"set1_des_seq\", \"set2_des_seq\", \"set3_des_seq\", \"set_lr_margin\",\n+    \"set_tb_margin\", \"bit_image_repeat\", \"bit_image_newline\", \"bit_image_carriage_return\",\n+    \"color_names\", \"define_bit_image_region\", \"end_bit_image_region\", \"set_color_band\",\n+    \"set_page_length\", \"display_pc_char\", \"enter_pc_charset_mode\", \"exit_pc_charset_mode\",\n+    \"enter_scancode_mode\", \"exit_scancode_mode\", \"pc_term_options\", \"scancode_escape\",\n+    \"alt_scancode_esc\", \"enter_horizontal_hl_mode\", \"enter_left_hl_mode\", \"enter_low_hl_mode\",\n+    \"enter_right_hl_mode\", \"enter_top_hl_mode\", \"enter_vertical_hl_mode\", \"set_a_attributes\",\n+    \"set_pglen_inch\", \"termcap_init2\", \"termcap_reset\", \"linefeed_if_not_lf\", \"backspace_if_not_bs\",\n+    \"other_non_function_keys\", \"arrow_key_map\", \"acs_ulcorner\", \"acs_llcorner\", \"acs_urcorner\",\n+    \"acs_lrcorner\", \"acs_ltee\", \"acs_rtee\", \"acs_btee\", \"acs_ttee\", \"acs_hline\", \"acs_vline\",\n+    \"acs_plus\", \"memory_lock\", \"memory_unlock\", \"box_chars_1\"];\n+\n+#[rustfmt::skip]\n+pub static stringnames: &[&str] = &[ \"cbt\", \"_\", \"cr\", \"csr\", \"tbc\", \"clear\",\n+    \"_\", \"_\", \"hpa\", \"cmdch\", \"cup\", \"cud1\", \"home\", \"civis\", \"cub1\", \"mrcup\", \"cnorm\", \"cuf1\",\n+    \"ll\", \"cuu1\", \"cvvis\", \"dch1\", \"dl1\", \"dsl\", \"hd\", \"smacs\", \"blink\", \"bold\", \"smcup\", \"smdc\",\n+    \"dim\", \"smir\", \"invis\", \"prot\", \"rev\", \"smso\", \"smul\", \"ech\", \"rmacs\", \"sgr0\", \"rmcup\", \"rmdc\",\n+    \"rmir\", \"rmso\", \"rmul\", \"flash\", \"ff\", \"fsl\", \"is1\", \"is2\", \"is3\", \"if\", \"ich1\", \"il1\", \"ip\",\n+    \"kbs\", \"ktbc\", \"kclr\", \"kctab\", \"_\", \"_\", \"kcud1\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\",\n+    \"_\", \"_\", \"_\", \"_\", \"_\", \"khome\", \"_\", \"_\", \"kcub1\", \"_\", \"knp\", \"kpp\", \"kcuf1\", \"_\", \"_\",\n+    \"khts\", \"_\", \"rmkx\", \"smkx\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"rmm\", \"_\",\n+    \"_\", \"pad\", \"dch\", \"dl\", \"cud\", \"ich\", \"indn\", \"il\", \"cub\", \"cuf\", \"rin\", \"cuu\", \"pfkey\",\n+    \"pfloc\", \"pfx\", \"mc0\", \"mc4\", \"_\", \"rep\", \"rs1\", \"rs2\", \"rs3\", \"rf\", \"rc\", \"vpa\", \"sc\", \"ind\",\n+    \"ri\", \"sgr\", \"_\", \"wind\", \"_\", \"tsl\", \"uc\", \"hu\", \"iprog\", \"_\", \"_\", \"_\", \"_\", \"_\", \"mc5p\",\n+    \"rmp\", \"acsc\", \"pln\", \"kcbt\", \"smxon\", \"rmxon\", \"smam\", \"rmam\", \"xonc\", \"xoffc\", \"_\", \"smln\",\n+    \"rmln\", \"_\", \"kcan\", \"kclo\", \"kcmd\", \"kcpy\", \"kcrt\", \"_\", \"kent\", \"kext\", \"kfnd\", \"khlp\",\n+    \"kmrk\", \"kmsg\", \"kmov\", \"knxt\", \"kopn\", \"kopt\", \"kprv\", \"kprt\", \"krdo\", \"kref\", \"krfr\", \"krpl\",\n+    \"krst\", \"kres\", \"ksav\", \"kspd\", \"kund\", \"kBEG\", \"kCAN\", \"kCMD\", \"kCPY\", \"kCRT\", \"_\", \"_\",\n+    \"kslt\", \"kEND\", \"kEOL\", \"kEXT\", \"kFND\", \"kHLP\", \"kHOM\", \"_\", \"kLFT\", \"kMSG\", \"kMOV\", \"kNXT\",\n+    \"kOPT\", \"kPRV\", \"kPRT\", \"kRDO\", \"kRPL\", \"kRIT\", \"kRES\", \"kSAV\", \"kSPD\", \"kUND\", \"rfi\", \"_\", \"_\",\n+    \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\",\n+    \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\",\n+    \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\",\n+    \"dclk\", \"rmclk\", \"cwin\", \"wingo\", \"_\", \"dial\", \"qdial\", \"_\", \"_\", \"hook\", \"pause\", \"wait\", \"_\",\n+    \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"_\", \"op\", \"oc\", \"initc\", \"initp\", \"scp\", \"setf\",\n+    \"setb\", \"cpi\", \"lpi\", \"chr\", \"cvr\", \"defc\", \"swidm\", \"sdrfq\", \"sitm\", \"slm\", \"smicm\", \"snlq\",\n+    \"snrmq\", \"sshm\", \"ssubm\", \"ssupm\", \"sum\", \"rwidm\", \"ritm\", \"rlm\", \"rmicm\", \"rshm\", \"rsubm\",\n+    \"rsupm\", \"rum\", \"mhpa\", \"mcud1\", \"mcub1\", \"mcuf1\", \"mvpa\", \"mcuu1\", \"porder\", \"mcud\", \"mcub\",\n+    \"mcuf\", \"mcuu\", \"scs\", \"smgb\", \"smgbp\", \"smglp\", \"smgrp\", \"smgt\", \"smgtp\", \"sbim\", \"scsd\",\n+    \"rbim\", \"rcsd\", \"subcs\", \"supcs\", \"docr\", \"zerom\", \"csnm\", \"kmous\", \"minfo\", \"reqmp\", \"getm\",\n+    \"setaf\", \"setab\", \"pfxl\", \"devt\", \"csin\", \"s0ds\", \"s1ds\", \"s2ds\", \"s3ds\", \"smglr\", \"smgtb\",\n+    \"birep\", \"binel\", \"bicr\", \"colornm\", \"defbi\", \"endbi\", \"setcolor\", \"slines\", \"dispc\", \"smpch\",\n+    \"rmpch\", \"smsc\", \"rmsc\", \"pctrm\", \"scesc\", \"scesa\", \"ehhlm\", \"elhlm\", \"elohlm\", \"erhlm\",\n+    \"ethlm\", \"evhlm\", \"sgr1\", \"slength\", \"OTi2\", \"OTrs\", \"OTnl\", \"OTbs\", \"OTko\", \"OTma\", \"OTG2\",\n+    \"OTG3\", \"OTG1\", \"OTG4\", \"OTGR\", \"OTGL\", \"OTGU\", \"OTGD\", \"OTGH\", \"OTGV\", \"OTGC\", \"meml\", \"memu\",\n+    \"box1\"];\n+\n+fn read_le_u16(r: &mut dyn io::Read) -> io::Result<u16> {\n+    let mut b = [0; 2];\n+    let mut amt = 0;\n+    while amt < b.len() {\n+        match r.read(&mut b[amt..])? {\n+            0 => return Err(io::Error::new(io::ErrorKind::Other, \"end of file\")),\n+            n => amt += n,\n+        }\n+    }\n+    Ok((b[0] as u16) | ((b[1] as u16) << 8))\n+}\n+\n+fn read_byte(r: &mut dyn io::Read) -> io::Result<u8> {\n+    match r.bytes().next() {\n+        Some(s) => s,\n+        None => Err(io::Error::new(io::ErrorKind::Other, \"end of file\")),\n+    }\n+}\n+\n+/// Parse a compiled terminfo entry, using long capability names if `longnames`\n+/// is true\n+pub fn parse(file: &mut dyn io::Read, longnames: bool) -> Result<TermInfo, String> {\n+    macro_rules! t( ($e:expr) => (\n+        match $e {\n+            Ok(e) => e,\n+            Err(e) => return Err(e.to_string())\n+        }\n+    ) );\n+\n+    let (bnames, snames, nnames) = if longnames {\n+        (boolfnames, stringfnames, numfnames)\n+    } else {\n+        (boolnames, stringnames, numnames)\n+    };\n+\n+    // Check magic number\n+    let magic = t!(read_le_u16(file));\n+    if magic != 0x011A {\n+        return Err(format!(\"invalid magic number: expected {:x}, found {:x}\",\n+                           0x011A,\n+                           magic));\n+    }\n+\n+    // According to the spec, these fields must be >= -1 where -1 means that the feature is not\n+    // supported. Using 0 instead of -1 works because we skip sections with length 0.\n+    macro_rules! read_nonneg {\n+        () => {{\n+            match t!(read_le_u16(file)) as i16 {\n+                n if n >= 0 => n as usize,\n+                -1 => 0,\n+                _ => return Err(\"incompatible file: length fields must be  >= -1\".to_string()),\n+            }\n+        }}\n+    }\n+\n+    let names_bytes = read_nonneg!();\n+    let bools_bytes = read_nonneg!();\n+    let numbers_count = read_nonneg!();\n+    let string_offsets_count = read_nonneg!();\n+    let string_table_bytes = read_nonneg!();\n+\n+    if names_bytes == 0 {\n+        return Err(\"incompatible file: names field must be at least 1 byte wide\".to_string());\n+    }\n+\n+    if bools_bytes > boolnames.len() {\n+        return Err(\"incompatible file: more booleans than expected\".to_string());\n+    }\n+\n+    if numbers_count > numnames.len() {\n+        return Err(\"incompatible file: more numbers than expected\".to_string());\n+    }\n+\n+    if string_offsets_count > stringnames.len() {\n+        return Err(\"incompatible file: more string offsets than expected\".to_string());\n+    }\n+\n+    // don't read NUL\n+    let mut bytes = Vec::new();\n+    t!(file.take((names_bytes - 1) as u64).read_to_end(&mut bytes));\n+    let names_str = match String::from_utf8(bytes) {\n+        Ok(s) => s,\n+        Err(_) => return Err(\"input not utf-8\".to_string()),\n+    };\n+\n+    let term_names: Vec<String> = names_str.split('|')\n+                                           .map(|s| s.to_string())\n+                                           .collect();\n+    // consume NUL\n+    if t!(read_byte(file)) != b'\\0' {\n+        return Err(\"incompatible file: missing null terminator for names section\".to_string());\n+    }\n+\n+    let bools_map: HashMap<String, bool> = t! {\n+        (0..bools_bytes).filter_map(|i| match read_byte(file) {\n+            Err(e) => Some(Err(e)),\n+            Ok(1) => Some(Ok((bnames[i].to_string(), true))),\n+            Ok(_) => None\n+        }).collect()\n+    };\n+\n+    if (bools_bytes + names_bytes) % 2 == 1 {\n+        t!(read_byte(file)); // compensate for padding\n+    }\n+\n+    let numbers_map: HashMap<String, u16> = t! {\n+        (0..numbers_count).filter_map(|i| match read_le_u16(file) {\n+            Ok(0xFFFF) => None,\n+            Ok(n) => Some(Ok((nnames[i].to_string(), n))),\n+            Err(e) => Some(Err(e))\n+        }).collect()\n+    };\n+\n+    let string_map: HashMap<String, Vec<u8>> = if string_offsets_count > 0 {\n+        let string_offsets: Vec<u16> = t!((0..string_offsets_count)\n+                                                .map(|_| read_le_u16(file))\n+                                                .collect());\n+\n+        let mut string_table = Vec::new();\n+        t!(file.take(string_table_bytes as u64).read_to_end(&mut string_table));\n+\n+        t!(string_offsets.into_iter().enumerate().filter(|&(_, offset)| {\n+            // non-entry\n+            offset != 0xFFFF\n+        }).map(|(i, offset)| {\n+            let offset = offset as usize;\n+\n+            let name = if snames[i] == \"_\" {\n+                stringfnames[i]\n+            } else {\n+                snames[i]\n+            };\n+\n+            if offset == 0xFFFE {\n+                // undocumented: FFFE indicates cap@, which means the capability is not present\n+                // unsure if the handling for this is correct\n+                return Ok((name.to_string(), Vec::new()));\n+            }\n+\n+            // Find the offset of the NUL we want to go to\n+            let nulpos = string_table[offset..string_table_bytes].iter().position(|&b| b == 0);\n+            match nulpos {\n+                Some(len) => Ok((name.to_string(), string_table[offset..offset + len].to_vec())),\n+                None => Err(\"invalid file: missing NUL in string_table\".to_string()),\n+            }\n+        }).collect())\n+    } else {\n+        HashMap::new()\n+    };\n+\n+    // And that's all there is to it\n+    Ok(TermInfo {\n+        names: term_names,\n+        bools: bools_map,\n+        numbers: numbers_map,\n+        strings: string_map,\n+    })\n+}\n+\n+/// Creates a dummy TermInfo struct for msys terminals\n+pub fn msys_terminfo() -> TermInfo {\n+    let mut strings = HashMap::new();\n+    strings.insert(\"sgr0\".to_string(), b\"\\x1B[0m\".to_vec());\n+    strings.insert(\"bold\".to_string(), b\"\\x1B[1m\".to_vec());\n+    strings.insert(\"setaf\".to_string(), b\"\\x1B[3%p1%dm\".to_vec());\n+    strings.insert(\"setab\".to_string(), b\"\\x1B[4%p1%dm\".to_vec());\n+\n+    let mut numbers = HashMap::new();\n+    numbers.insert(\"colors\".to_string(), 8u16);\n+\n+    TermInfo {\n+        names: vec![\"cygwin\".to_string()], // msys is a fork of an older cygwin version\n+        bools: HashMap::new(),\n+        numbers,\n+        strings,\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+\n+    use super::{boolnames, boolfnames, numnames, numfnames, stringnames, stringfnames};\n+\n+    #[test]\n+    fn test_veclens() {\n+        assert_eq!(boolfnames.len(), boolnames.len());\n+        assert_eq!(numfnames.len(), numnames.len());\n+        assert_eq!(stringfnames.len(), stringnames.len());\n+    }\n+}"}, {"sha": "0b17ed36fc8caed81bb88990837d5691f7d3ecf0", "filename": "src/libterm/terminfo/searcher.rs", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/28ea249ab526c6b114c4dc9ba311fc62fccb28e2/src%2Flibterm%2Fterminfo%2Fsearcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28ea249ab526c6b114c4dc9ba311fc62fccb28e2/src%2Flibterm%2Fterminfo%2Fsearcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fsearcher.rs?ref=28ea249ab526c6b114c4dc9ba311fc62fccb28e2", "patch": "@@ -0,0 +1,84 @@\n+//! ncurses-compatible database discovery.\n+//!\n+//! Does not support hashed database, only filesystem!\n+\n+use std::env;\n+use std::fs;\n+use std::path::PathBuf;\n+\n+/// Return path to database entry for `term`\n+#[allow(deprecated)]\n+pub fn get_dbpath_for_term(term: &str) -> Option<PathBuf> {\n+    let mut dirs_to_search = Vec::new();\n+    let first_char = term.chars().next()?;\n+\n+    // Find search directory\n+    if let Some(dir) = env::var_os(\"TERMINFO\") {\n+        dirs_to_search.push(PathBuf::from(dir));\n+    }\n+\n+    if let Ok(dirs) = env::var(\"TERMINFO_DIRS\") {\n+        for i in dirs.split(':') {\n+            if i == \"\" {\n+                dirs_to_search.push(PathBuf::from(\"/usr/share/terminfo\"));\n+            } else {\n+                dirs_to_search.push(PathBuf::from(i));\n+            }\n+        }\n+    } else {\n+        // Found nothing in TERMINFO_DIRS, use the default paths:\n+        // According to  /etc/terminfo/README, after looking at\n+        // ~/.terminfo, ncurses will search /etc/terminfo, then\n+        // /lib/terminfo, and eventually /usr/share/terminfo.\n+        // On Haiku the database can be found at /boot/system/data/terminfo\n+        if let Some(mut homedir) = env::home_dir() {\n+            homedir.push(\".terminfo\");\n+            dirs_to_search.push(homedir)\n+        }\n+\n+        dirs_to_search.push(PathBuf::from(\"/etc/terminfo\"));\n+        dirs_to_search.push(PathBuf::from(\"/lib/terminfo\"));\n+        dirs_to_search.push(PathBuf::from(\"/usr/share/terminfo\"));\n+        dirs_to_search.push(PathBuf::from(\"/boot/system/data/terminfo\"));\n+    }\n+\n+    // Look for the terminal in all of the search directories\n+    for mut p in dirs_to_search {\n+        if fs::metadata(&p).is_ok() {\n+            p.push(&first_char.to_string());\n+            p.push(&term);\n+            if fs::metadata(&p).is_ok() {\n+                return Some(p);\n+            }\n+            p.pop();\n+            p.pop();\n+\n+            // on some installations the dir is named after the hex of the char\n+            // (e.g., macOS)\n+            p.push(&format!(\"{:x}\", first_char as usize));\n+            p.push(term);\n+            if fs::metadata(&p).is_ok() {\n+                return Some(p);\n+            }\n+        }\n+    }\n+    None\n+}\n+\n+#[test]\n+#[ignore = \"buildbots don't have ncurses installed and I can't mock everything I need\"]\n+fn test_get_dbpath_for_term() {\n+    // woefully inadequate test coverage\n+    // note: current tests won't work with non-standard terminfo hierarchies (e.g., macOS's)\n+    use std::env;\n+    // FIXME (#9639): This needs to handle non-utf8 paths\n+    fn x(t: &str) -> String {\n+        let p = get_dbpath_for_term(t).expect(\"no terminfo entry found\");\n+        p.to_str().unwrap().to_string()\n+    }\n+    assert!(x(\"screen\") == \"/usr/share/terminfo/s/screen\");\n+    assert!(get_dbpath_for_term(\"\") == None);\n+    env::set_var(\"TERMINFO_DIRS\", \":\");\n+    assert!(x(\"screen\") == \"/usr/share/terminfo/s/screen\");\n+    env::remove_var(\"TERMINFO_DIRS\");\n+}"}, {"sha": "6d42b01337ed531bd36e2c323a5effcbd9a7a548", "filename": "src/libterm/win.rs", "status": "added", "additions": 203, "deletions": 0, "changes": 203, "blob_url": "https://github.com/rust-lang/rust/blob/28ea249ab526c6b114c4dc9ba311fc62fccb28e2/src%2Flibterm%2Fwin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28ea249ab526c6b114c4dc9ba311fc62fccb28e2/src%2Flibterm%2Fwin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fwin.rs?ref=28ea249ab526c6b114c4dc9ba311fc62fccb28e2", "patch": "@@ -0,0 +1,203 @@\n+//! Windows console handling\n+\n+// FIXME (#13400): this is only a tiny fraction of the Windows console api\n+\n+extern crate libc;\n+\n+use std::io;\n+use std::io::prelude::*;\n+\n+use crate::Attr;\n+use crate::color;\n+use crate::Terminal;\n+\n+/// A Terminal implementation that uses the Win32 Console API.\n+pub struct WinConsole<T> {\n+    buf: T,\n+    def_foreground: color::Color,\n+    def_background: color::Color,\n+    foreground: color::Color,\n+    background: color::Color,\n+}\n+\n+type WORD = u16;\n+type DWORD = u32;\n+type BOOL = i32;\n+type HANDLE = *mut u8;\n+\n+#[allow(non_snake_case)]\n+#[repr(C)]\n+struct CONSOLE_SCREEN_BUFFER_INFO {\n+    dwSize: [libc::c_short; 2],\n+    dwCursorPosition: [libc::c_short; 2],\n+    wAttributes: WORD,\n+    srWindow: [libc::c_short; 4],\n+    dwMaximumWindowSize: [libc::c_short; 2],\n+}\n+\n+#[allow(non_snake_case)]\n+#[link(name = \"kernel32\")]\n+extern \"system\" {\n+    fn SetConsoleTextAttribute(handle: HANDLE, attr: WORD) -> BOOL;\n+    fn GetStdHandle(which: DWORD) -> HANDLE;\n+    fn GetConsoleScreenBufferInfo(handle: HANDLE, info: *mut CONSOLE_SCREEN_BUFFER_INFO) -> BOOL;\n+}\n+\n+fn color_to_bits(color: color::Color) -> u16 {\n+    // magic numbers from mingw-w64's wincon.h\n+\n+    let bits = match color % 8 {\n+        color::BLACK => 0,\n+        color::BLUE => 0x1,\n+        color::GREEN => 0x2,\n+        color::RED => 0x4,\n+        color::YELLOW => 0x2 | 0x4,\n+        color::MAGENTA => 0x1 | 0x4,\n+        color::CYAN => 0x1 | 0x2,\n+        color::WHITE => 0x1 | 0x2 | 0x4,\n+        _ => unreachable!(),\n+    };\n+\n+    if color >= 8 {\n+        bits | 0x8\n+    } else {\n+        bits\n+    }\n+}\n+\n+fn bits_to_color(bits: u16) -> color::Color {\n+    let color = match bits & 0x7 {\n+        0 => color::BLACK,\n+        0x1 => color::BLUE,\n+        0x2 => color::GREEN,\n+        0x4 => color::RED,\n+        0x6 => color::YELLOW,\n+        0x5 => color::MAGENTA,\n+        0x3 => color::CYAN,\n+        0x7 => color::WHITE,\n+        _ => unreachable!(),\n+    };\n+\n+    color | (bits & 0x8) // copy the hi-intensity bit\n+}\n+\n+impl<T: Write + Send + 'static> WinConsole<T> {\n+    fn apply(&mut self) {\n+        let _unused = self.buf.flush();\n+        let mut accum: WORD = 0;\n+        accum |= color_to_bits(self.foreground);\n+        accum |= color_to_bits(self.background) << 4;\n+\n+        unsafe {\n+            // Magic -11 means stdout, from\n+            // http://msdn.microsoft.com/en-us/library/windows/desktop/ms683231%28v=vs.85%29.aspx\n+            //\n+            // You may be wondering, \"but what about stderr?\", and the answer\n+            // to that is that setting terminal attributes on the stdout\n+            // handle also sets them for stderr, since they go to the same\n+            // terminal! Admittedly, this is fragile, since stderr could be\n+            // redirected to a different console. This is good enough for\n+            // rustc though. See #13400.\n+            let out = GetStdHandle(-11i32 as DWORD);\n+            SetConsoleTextAttribute(out, accum);\n+        }\n+    }\n+\n+    /// Returns `None` whenever the terminal cannot be created for some reason.\n+    pub fn new(out: T) -> io::Result<WinConsole<T>> {\n+        let fg;\n+        let bg;\n+        unsafe {\n+            let mut buffer_info = ::std::mem::uninitialized();\n+            if GetConsoleScreenBufferInfo(GetStdHandle(-11i32 as DWORD), &mut buffer_info) != 0 {\n+                fg = bits_to_color(buffer_info.wAttributes);\n+                bg = bits_to_color(buffer_info.wAttributes >> 4);\n+            } else {\n+                fg = color::WHITE;\n+                bg = color::BLACK;\n+            }\n+        }\n+        Ok(WinConsole {\n+            buf: out,\n+            def_foreground: fg,\n+            def_background: bg,\n+            foreground: fg,\n+            background: bg,\n+        })\n+    }\n+}\n+\n+impl<T: Write> Write for WinConsole<T> {\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        self.buf.write(buf)\n+    }\n+\n+    fn flush(&mut self) -> io::Result<()> {\n+        self.buf.flush()\n+    }\n+}\n+\n+impl<T: Write + Send + 'static> Terminal for WinConsole<T> {\n+    type Output = T;\n+\n+    fn fg(&mut self, color: color::Color) -> io::Result<bool> {\n+        self.foreground = color;\n+        self.apply();\n+\n+        Ok(true)\n+    }\n+\n+    fn bg(&mut self, color: color::Color) -> io::Result<bool> {\n+        self.background = color;\n+        self.apply();\n+\n+        Ok(true)\n+    }\n+\n+    fn attr(&mut self, attr: Attr) -> io::Result<bool> {\n+        match attr {\n+            Attr::ForegroundColor(f) => {\n+                self.foreground = f;\n+                self.apply();\n+                Ok(true)\n+            }\n+            Attr::BackgroundColor(b) => {\n+                self.background = b;\n+                self.apply();\n+                Ok(true)\n+            }\n+            _ => Ok(false),\n+        }\n+    }\n+\n+    fn supports_attr(&self, attr: Attr) -> bool {\n+        // it claims support for underscore and reverse video, but I can't get\n+        // it to do anything -cmr\n+        match attr {\n+            Attr::ForegroundColor(_) | Attr::BackgroundColor(_) => true,\n+            _ => false,\n+        }\n+    }\n+\n+    fn reset(&mut self) -> io::Result<bool> {\n+        self.foreground = self.def_foreground;\n+        self.background = self.def_background;\n+        self.apply();\n+\n+        Ok(true)\n+    }\n+\n+    fn get_ref(&self) -> &T {\n+        &self.buf\n+    }\n+\n+    fn get_mut(&mut self) -> &mut T {\n+        &mut self.buf\n+    }\n+\n+    fn into_inner(self) -> T\n+        where Self: Sized\n+    {\n+        self.buf\n+    }\n+}"}, {"sha": "10bdd6e877c4f2da1c17c9044cbae0d0da46dfd2", "filename": "src/libtest/Cargo.toml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/28ea249ab526c6b114c4dc9ba311fc62fccb28e2/src%2Flibtest%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/28ea249ab526c6b114c4dc9ba311fc62fccb28e2/src%2Flibtest%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2FCargo.toml?ref=28ea249ab526c6b114c4dc9ba311fc62fccb28e2", "patch": "@@ -10,7 +10,8 @@ path = \"lib.rs\"\n crate-type = [\"dylib\", \"rlib\"]\n \n [dependencies]\n-libtest = { version = \"0.0.1\" }\n+getopts = \"0.2\"\n+term = { path = \"../libterm\" }\n \n # not actually used but needed to always have proc_macro in the sysroot\n proc_macro = { path = \"../libproc_macro\" }"}, {"sha": "6d9fe30dcadb2f6f9f3f43331c6b0aad4731aaa4", "filename": "src/libtest/README.md", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/dec0a98c4b392b5fd153ba8b944c496218717813/src%2Flibtest%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/dec0a98c4b392b5fd153ba8b944c496218717813/src%2Flibtest%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2FREADME.md?ref=dec0a98c4b392b5fd153ba8b944c496218717813", "patch": "@@ -1,13 +0,0 @@\n-WIP - stable libtest\n-===\n-\n-The migration of libtest to stable Rust is currently in progress.\n-\n-You can find libtest at: https://github.com/rust-lang/libtest . If you need to\n-make a change:\n-\n-* perform the change there, \n-* do a new crates.io release, and\n-* send a PR to rust-lang/rust bumping the libtest version.\n-\n-The roadmap of the migration is being tracked here: https://github.com/rust-lang/libtest/issues/2"}, {"sha": "a06497f98626aa9f03bc406b6450c2b8856222aa", "filename": "src/libtest/formatters/json.rs", "status": "added", "additions": 208, "deletions": 0, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/28ea249ab526c6b114c4dc9ba311fc62fccb28e2/src%2Flibtest%2Fformatters%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28ea249ab526c6b114c4dc9ba311fc62fccb28e2/src%2Flibtest%2Fformatters%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fformatters%2Fjson.rs?ref=28ea249ab526c6b114c4dc9ba311fc62fccb28e2", "patch": "@@ -0,0 +1,208 @@\n+use super::*;\n+\n+pub(crate) struct JsonFormatter<T> {\n+    out: OutputLocation<T>,\n+}\n+\n+impl<T: Write> JsonFormatter<T> {\n+    pub fn new(out: OutputLocation<T>) -> Self {\n+        Self { out }\n+    }\n+\n+    fn write_message(&mut self, s: &str) -> io::Result<()> {\n+        assert!(!s.contains('\\n'));\n+\n+        self.out.write_all(s.as_ref())?;\n+        self.out.write_all(b\"\\n\")\n+    }\n+\n+    fn write_event(\n+        &mut self,\n+        ty: &str,\n+        name: &str,\n+        evt: &str,\n+        extra: Option<String>,\n+    ) -> io::Result<()> {\n+        if let Some(extras) = extra {\n+            self.write_message(&*format!(\n+                r#\"{{ \"type\": \"{}\", \"name\": \"{}\", \"event\": \"{}\", {} }}\"#,\n+                ty, name, evt, extras\n+            ))\n+        } else {\n+            self.write_message(&*format!(\n+                r#\"{{ \"type\": \"{}\", \"name\": \"{}\", \"event\": \"{}\" }}\"#,\n+                ty, name, evt\n+            ))\n+        }\n+    }\n+}\n+\n+impl<T: Write> OutputFormatter for JsonFormatter<T> {\n+    fn write_run_start(&mut self, test_count: usize) -> io::Result<()> {\n+        self.write_message(&*format!(\n+            r#\"{{ \"type\": \"suite\", \"event\": \"started\", \"test_count\": {} }}\"#,\n+            test_count\n+        ))\n+    }\n+\n+    fn write_test_start(&mut self, desc: &TestDesc) -> io::Result<()> {\n+        self.write_message(&*format!(\n+            r#\"{{ \"type\": \"test\", \"event\": \"started\", \"name\": \"{}\" }}\"#,\n+            desc.name\n+        ))\n+    }\n+\n+    fn write_result(\n+        &mut self,\n+        desc: &TestDesc,\n+        result: &TestResult,\n+        stdout: &[u8],\n+    ) -> io::Result<()> {\n+        match *result {\n+            TrOk => self.write_event(\"test\", desc.name.as_slice(), \"ok\", None),\n+\n+            TrFailed => {\n+                let extra_data = if stdout.len() > 0 {\n+                    Some(format!(\n+                        r#\"\"stdout\": \"{}\"\"#,\n+                        EscapedString(String::from_utf8_lossy(stdout))\n+                    ))\n+                } else {\n+                    None\n+                };\n+\n+                self.write_event(\"test\", desc.name.as_slice(), \"failed\", extra_data)\n+            }\n+\n+            TrFailedMsg(ref m) => self.write_event(\n+                \"test\",\n+                desc.name.as_slice(),\n+                \"failed\",\n+                Some(format!(r#\"\"message\": \"{}\"\"#, EscapedString(m))),\n+            ),\n+\n+            TrIgnored => self.write_event(\"test\", desc.name.as_slice(), \"ignored\", None),\n+\n+            TrAllowedFail => {\n+                self.write_event(\"test\", desc.name.as_slice(), \"allowed_failure\", None)\n+            }\n+\n+            TrBench(ref bs) => {\n+                let median = bs.ns_iter_summ.median as usize;\n+                let deviation = (bs.ns_iter_summ.max - bs.ns_iter_summ.min) as usize;\n+\n+                let mbps = if bs.mb_s == 0 {\n+                    String::new()\n+                } else {\n+                    format!(r#\", \"mib_per_second\": {}\"#, bs.mb_s)\n+                };\n+\n+                let line = format!(\n+                    \"{{ \\\"type\\\": \\\"bench\\\", \\\n+                     \\\"name\\\": \\\"{}\\\", \\\n+                     \\\"median\\\": {}, \\\n+                     \\\"deviation\\\": {}{} }}\",\n+                    desc.name, median, deviation, mbps\n+                );\n+\n+                self.write_message(&*line)\n+            }\n+        }\n+    }\n+\n+    fn write_timeout(&mut self, desc: &TestDesc) -> io::Result<()> {\n+        self.write_message(&*format!(\n+            r#\"{{ \"type\": \"test\", \"event\": \"timeout\", \"name\": \"{}\" }}\"#,\n+            desc.name\n+        ))\n+    }\n+\n+    fn write_run_finish(&mut self, state: &ConsoleTestState) -> io::Result<bool> {\n+        self.write_message(&*format!(\n+            \"{{ \\\"type\\\": \\\"suite\\\", \\\n+             \\\"event\\\": \\\"{}\\\", \\\n+             \\\"passed\\\": {}, \\\n+             \\\"failed\\\": {}, \\\n+             \\\"allowed_fail\\\": {}, \\\n+             \\\"ignored\\\": {}, \\\n+             \\\"measured\\\": {}, \\\n+             \\\"filtered_out\\\": {} }}\",\n+            if state.failed == 0 { \"ok\" } else { \"failed\" },\n+            state.passed,\n+            state.failed + state.allowed_fail,\n+            state.allowed_fail,\n+            state.ignored,\n+            state.measured,\n+            state.filtered_out\n+        ))?;\n+\n+        Ok(state.failed == 0)\n+    }\n+}\n+\n+/// A formatting utility used to print strings with characters in need of escaping.\n+/// Base code taken form `libserialize::json::escape_str`\n+struct EscapedString<S: AsRef<str>>(S);\n+\n+impl<S: AsRef<str>> ::std::fmt::Display for EscapedString<S> {\n+    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {\n+        let mut start = 0;\n+\n+        for (i, byte) in self.0.as_ref().bytes().enumerate() {\n+            let escaped = match byte {\n+                b'\"' => \"\\\\\\\"\",\n+                b'\\\\' => \"\\\\\\\\\",\n+                b'\\x00' => \"\\\\u0000\",\n+                b'\\x01' => \"\\\\u0001\",\n+                b'\\x02' => \"\\\\u0002\",\n+                b'\\x03' => \"\\\\u0003\",\n+                b'\\x04' => \"\\\\u0004\",\n+                b'\\x05' => \"\\\\u0005\",\n+                b'\\x06' => \"\\\\u0006\",\n+                b'\\x07' => \"\\\\u0007\",\n+                b'\\x08' => \"\\\\b\",\n+                b'\\t' => \"\\\\t\",\n+                b'\\n' => \"\\\\n\",\n+                b'\\x0b' => \"\\\\u000b\",\n+                b'\\x0c' => \"\\\\f\",\n+                b'\\r' => \"\\\\r\",\n+                b'\\x0e' => \"\\\\u000e\",\n+                b'\\x0f' => \"\\\\u000f\",\n+                b'\\x10' => \"\\\\u0010\",\n+                b'\\x11' => \"\\\\u0011\",\n+                b'\\x12' => \"\\\\u0012\",\n+                b'\\x13' => \"\\\\u0013\",\n+                b'\\x14' => \"\\\\u0014\",\n+                b'\\x15' => \"\\\\u0015\",\n+                b'\\x16' => \"\\\\u0016\",\n+                b'\\x17' => \"\\\\u0017\",\n+                b'\\x18' => \"\\\\u0018\",\n+                b'\\x19' => \"\\\\u0019\",\n+                b'\\x1a' => \"\\\\u001a\",\n+                b'\\x1b' => \"\\\\u001b\",\n+                b'\\x1c' => \"\\\\u001c\",\n+                b'\\x1d' => \"\\\\u001d\",\n+                b'\\x1e' => \"\\\\u001e\",\n+                b'\\x1f' => \"\\\\u001f\",\n+                b'\\x7f' => \"\\\\u007f\",\n+                _ => {\n+                    continue;\n+                }\n+            };\n+\n+            if start < i {\n+                f.write_str(&self.0.as_ref()[start..i])?;\n+            }\n+\n+            f.write_str(escaped)?;\n+\n+            start = i + 1;\n+        }\n+\n+        if start != self.0.as_ref().len() {\n+            f.write_str(&self.0.as_ref()[start..])?;\n+        }\n+\n+        Ok(())\n+    }\n+}"}, {"sha": "be5f6a65039b76c43eb6c836b154d5e377a36ee2", "filename": "src/libtest/formatters/mod.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/28ea249ab526c6b114c4dc9ba311fc62fccb28e2/src%2Flibtest%2Fformatters%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28ea249ab526c6b114c4dc9ba311fc62fccb28e2/src%2Flibtest%2Fformatters%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fformatters%2Fmod.rs?ref=28ea249ab526c6b114c4dc9ba311fc62fccb28e2", "patch": "@@ -0,0 +1,22 @@\n+use super::*;\n+\n+mod pretty;\n+mod json;\n+mod terse;\n+\n+pub(crate) use self::pretty::PrettyFormatter;\n+pub(crate) use self::json::JsonFormatter;\n+pub(crate) use self::terse::TerseFormatter;\n+\n+pub(crate) trait OutputFormatter {\n+    fn write_run_start(&mut self, test_count: usize) -> io::Result<()>;\n+    fn write_test_start(&mut self, desc: &TestDesc) -> io::Result<()>;\n+    fn write_timeout(&mut self, desc: &TestDesc) -> io::Result<()>;\n+    fn write_result(\n+        &mut self,\n+        desc: &TestDesc,\n+        result: &TestResult,\n+        stdout: &[u8],\n+    ) -> io::Result<()>;\n+    fn write_run_finish(&mut self, state: &ConsoleTestState) -> io::Result<bool>;\n+}"}, {"sha": "4af00428ca87e991e6862b9a3645517cd4b2a3b0", "filename": "src/libtest/formatters/pretty.rs", "status": "added", "additions": 232, "deletions": 0, "changes": 232, "blob_url": "https://github.com/rust-lang/rust/blob/28ea249ab526c6b114c4dc9ba311fc62fccb28e2/src%2Flibtest%2Fformatters%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28ea249ab526c6b114c4dc9ba311fc62fccb28e2/src%2Flibtest%2Fformatters%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fformatters%2Fpretty.rs?ref=28ea249ab526c6b114c4dc9ba311fc62fccb28e2", "patch": "@@ -0,0 +1,232 @@\n+use super::*;\n+\n+pub(crate) struct PrettyFormatter<T> {\n+    out: OutputLocation<T>,\n+    use_color: bool,\n+\n+    /// Number of columns to fill when aligning names\n+    max_name_len: usize,\n+\n+    is_multithreaded: bool,\n+}\n+\n+impl<T: Write> PrettyFormatter<T> {\n+    pub fn new(\n+        out: OutputLocation<T>,\n+        use_color: bool,\n+        max_name_len: usize,\n+        is_multithreaded: bool,\n+    ) -> Self {\n+        PrettyFormatter {\n+            out,\n+            use_color,\n+            max_name_len,\n+            is_multithreaded,\n+        }\n+    }\n+\n+    #[cfg(test)]\n+    pub fn output_location(&self) -> &OutputLocation<T> {\n+        &self.out\n+    }\n+\n+    pub fn write_ok(&mut self) -> io::Result<()> {\n+        self.write_short_result(\"ok\", term::color::GREEN)\n+    }\n+\n+    pub fn write_failed(&mut self) -> io::Result<()> {\n+        self.write_short_result(\"FAILED\", term::color::RED)\n+    }\n+\n+    pub fn write_ignored(&mut self) -> io::Result<()> {\n+        self.write_short_result(\"ignored\", term::color::YELLOW)\n+    }\n+\n+    pub fn write_allowed_fail(&mut self) -> io::Result<()> {\n+        self.write_short_result(\"FAILED (allowed)\", term::color::YELLOW)\n+    }\n+\n+    pub fn write_bench(&mut self) -> io::Result<()> {\n+        self.write_pretty(\"bench\", term::color::CYAN)\n+    }\n+\n+    pub fn write_short_result(\n+        &mut self,\n+        result: &str,\n+        color: term::color::Color,\n+    ) -> io::Result<()> {\n+        self.write_pretty(result, color)?;\n+        self.write_plain(\"\\n\")\n+    }\n+\n+    pub fn write_pretty(&mut self, word: &str, color: term::color::Color) -> io::Result<()> {\n+        match self.out {\n+            Pretty(ref mut term) => {\n+                if self.use_color {\n+                    term.fg(color)?;\n+                }\n+                term.write_all(word.as_bytes())?;\n+                if self.use_color {\n+                    term.reset()?;\n+                }\n+                term.flush()\n+            }\n+            Raw(ref mut stdout) => {\n+                stdout.write_all(word.as_bytes())?;\n+                stdout.flush()\n+            }\n+        }\n+    }\n+\n+    pub fn write_plain<S: AsRef<str>>(&mut self, s: S) -> io::Result<()> {\n+        let s = s.as_ref();\n+        self.out.write_all(s.as_bytes())?;\n+        self.out.flush()\n+    }\n+\n+    pub fn write_successes(&mut self, state: &ConsoleTestState) -> io::Result<()> {\n+        self.write_plain(\"\\nsuccesses:\\n\")?;\n+        let mut successes = Vec::new();\n+        let mut stdouts = String::new();\n+        for &(ref f, ref stdout) in &state.not_failures {\n+            successes.push(f.name.to_string());\n+            if !stdout.is_empty() {\n+                stdouts.push_str(&format!(\"---- {} stdout ----\\n\", f.name));\n+                let output = String::from_utf8_lossy(stdout);\n+                stdouts.push_str(&output);\n+                stdouts.push_str(\"\\n\");\n+            }\n+        }\n+        if !stdouts.is_empty() {\n+            self.write_plain(\"\\n\")?;\n+            self.write_plain(&stdouts)?;\n+        }\n+\n+        self.write_plain(\"\\nsuccesses:\\n\")?;\n+        successes.sort();\n+        for name in &successes {\n+            self.write_plain(&format!(\"    {}\\n\", name))?;\n+        }\n+        Ok(())\n+    }\n+\n+    pub fn write_failures(&mut self, state: &ConsoleTestState) -> io::Result<()> {\n+        self.write_plain(\"\\nfailures:\\n\")?;\n+        let mut failures = Vec::new();\n+        let mut fail_out = String::new();\n+        for &(ref f, ref stdout) in &state.failures {\n+            failures.push(f.name.to_string());\n+            if !stdout.is_empty() {\n+                fail_out.push_str(&format!(\"---- {} stdout ----\\n\", f.name));\n+                let output = String::from_utf8_lossy(stdout);\n+                fail_out.push_str(&output);\n+                fail_out.push_str(\"\\n\");\n+            }\n+        }\n+        if !fail_out.is_empty() {\n+            self.write_plain(\"\\n\")?;\n+            self.write_plain(&fail_out)?;\n+        }\n+\n+        self.write_plain(\"\\nfailures:\\n\")?;\n+        failures.sort();\n+        for name in &failures {\n+            self.write_plain(&format!(\"    {}\\n\", name))?;\n+        }\n+        Ok(())\n+    }\n+\n+    fn write_test_name(&mut self, desc: &TestDesc) -> io::Result<()> {\n+        let name = desc.padded_name(self.max_name_len, desc.name.padding());\n+        self.write_plain(&format!(\"test {} ... \", name))?;\n+\n+        Ok(())\n+    }\n+}\n+\n+impl<T: Write> OutputFormatter for PrettyFormatter<T> {\n+    fn write_run_start(&mut self, test_count: usize) -> io::Result<()> {\n+        let noun = if test_count != 1 { \"tests\" } else { \"test\" };\n+        self.write_plain(&format!(\"\\nrunning {} {}\\n\", test_count, noun))\n+    }\n+\n+    fn write_test_start(&mut self, desc: &TestDesc) -> io::Result<()> {\n+        // When running tests concurrently, we should not print\n+        // the test's name as the result will be mis-aligned.\n+        // When running the tests serially, we print the name here so\n+        // that the user can see which test hangs.\n+        if !self.is_multithreaded {\n+            self.write_test_name(desc)?;\n+        }\n+\n+        Ok(())\n+    }\n+\n+    fn write_result(&mut self, desc: &TestDesc, result: &TestResult, _: &[u8]) -> io::Result<()> {\n+        if self.is_multithreaded {\n+            self.write_test_name(desc)?;\n+        }\n+\n+        match *result {\n+            TrOk => self.write_ok(),\n+            TrFailed | TrFailedMsg(_) => self.write_failed(),\n+            TrIgnored => self.write_ignored(),\n+            TrAllowedFail => self.write_allowed_fail(),\n+            TrBench(ref bs) => {\n+                self.write_bench()?;\n+                self.write_plain(&format!(\": {}\\n\", fmt_bench_samples(bs)))\n+            }\n+        }\n+    }\n+\n+    fn write_timeout(&mut self, desc: &TestDesc) -> io::Result<()> {\n+        if self.is_multithreaded {\n+            self.write_test_name(desc)?;\n+        }\n+\n+        self.write_plain(&format!(\n+            \"test {} has been running for over {} seconds\\n\",\n+            desc.name, TEST_WARN_TIMEOUT_S\n+        ))\n+    }\n+\n+    fn write_run_finish(&mut self, state: &ConsoleTestState) -> io::Result<bool> {\n+        if state.options.display_output {\n+            self.write_successes(state)?;\n+        }\n+        let success = state.failed == 0;\n+        if !success {\n+            self.write_failures(state)?;\n+        }\n+\n+        self.write_plain(\"\\ntest result: \")?;\n+\n+        if success {\n+            // There's no parallelism at this point so it's safe to use color\n+            self.write_pretty(\"ok\", term::color::GREEN)?;\n+        } else {\n+            self.write_pretty(\"FAILED\", term::color::RED)?;\n+        }\n+\n+        let s = if state.allowed_fail > 0 {\n+            format!(\n+                \". {} passed; {} failed ({} allowed); {} ignored; {} measured; {} filtered out\\n\\n\",\n+                state.passed,\n+                state.failed + state.allowed_fail,\n+                state.allowed_fail,\n+                state.ignored,\n+                state.measured,\n+                state.filtered_out\n+            )\n+        } else {\n+            format!(\n+                \". {} passed; {} failed; {} ignored; {} measured; {} filtered out\\n\\n\",\n+                state.passed, state.failed, state.ignored, state.measured, state.filtered_out\n+            )\n+        };\n+\n+        self.write_plain(&s)?;\n+\n+        Ok(success)\n+    }\n+}"}, {"sha": "1400fba5d60923e7345f961240d0eb015cdc1bdc", "filename": "src/libtest/formatters/terse.rs", "status": "added", "additions": 235, "deletions": 0, "changes": 235, "blob_url": "https://github.com/rust-lang/rust/blob/28ea249ab526c6b114c4dc9ba311fc62fccb28e2/src%2Flibtest%2Fformatters%2Fterse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28ea249ab526c6b114c4dc9ba311fc62fccb28e2/src%2Flibtest%2Fformatters%2Fterse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fformatters%2Fterse.rs?ref=28ea249ab526c6b114c4dc9ba311fc62fccb28e2", "patch": "@@ -0,0 +1,235 @@\n+use super::*;\n+\n+pub(crate) struct TerseFormatter<T> {\n+    out: OutputLocation<T>,\n+    use_color: bool,\n+    is_multithreaded: bool,\n+    /// Number of columns to fill when aligning names\n+    max_name_len: usize,\n+\n+    test_count: usize,\n+    total_test_count: usize,\n+}\n+\n+impl<T: Write> TerseFormatter<T> {\n+    pub fn new(\n+        out: OutputLocation<T>,\n+        use_color: bool,\n+        max_name_len: usize,\n+        is_multithreaded: bool,\n+    ) -> Self {\n+        TerseFormatter {\n+            out,\n+            use_color,\n+            max_name_len,\n+            is_multithreaded,\n+            test_count: 0,\n+            total_test_count: 0, // initialized later, when write_run_start is called\n+        }\n+    }\n+\n+    pub fn write_ok(&mut self) -> io::Result<()> {\n+        self.write_short_result(\".\", term::color::GREEN)\n+    }\n+\n+    pub fn write_failed(&mut self) -> io::Result<()> {\n+        self.write_short_result(\"F\", term::color::RED)\n+    }\n+\n+    pub fn write_ignored(&mut self) -> io::Result<()> {\n+        self.write_short_result(\"i\", term::color::YELLOW)\n+    }\n+\n+    pub fn write_allowed_fail(&mut self) -> io::Result<()> {\n+        self.write_short_result(\"a\", term::color::YELLOW)\n+    }\n+\n+    pub fn write_bench(&mut self) -> io::Result<()> {\n+        self.write_pretty(\"bench\", term::color::CYAN)\n+    }\n+\n+    pub fn write_short_result(\n+        &mut self,\n+        result: &str,\n+        color: term::color::Color,\n+    ) -> io::Result<()> {\n+        self.write_pretty(result, color)?;\n+        if self.test_count % QUIET_MODE_MAX_COLUMN == QUIET_MODE_MAX_COLUMN - 1 {\n+            // we insert a new line every 100 dots in order to flush the\n+            // screen when dealing with line-buffered output (e.g., piping to\n+            // `stamp` in the rust CI).\n+            let out = format!(\" {}/{}\\n\", self.test_count+1, self.total_test_count);\n+            self.write_plain(&out)?;\n+        }\n+\n+        self.test_count += 1;\n+        Ok(())\n+    }\n+\n+    pub fn write_pretty(&mut self, word: &str, color: term::color::Color) -> io::Result<()> {\n+        match self.out {\n+            Pretty(ref mut term) => {\n+                if self.use_color {\n+                    term.fg(color)?;\n+                }\n+                term.write_all(word.as_bytes())?;\n+                if self.use_color {\n+                    term.reset()?;\n+                }\n+                term.flush()\n+            }\n+            Raw(ref mut stdout) => {\n+                stdout.write_all(word.as_bytes())?;\n+                stdout.flush()\n+            }\n+        }\n+    }\n+\n+    pub fn write_plain<S: AsRef<str>>(&mut self, s: S) -> io::Result<()> {\n+        let s = s.as_ref();\n+        self.out.write_all(s.as_bytes())?;\n+        self.out.flush()\n+    }\n+\n+    pub fn write_outputs(&mut self, state: &ConsoleTestState) -> io::Result<()> {\n+        self.write_plain(\"\\nsuccesses:\\n\")?;\n+        let mut successes = Vec::new();\n+        let mut stdouts = String::new();\n+        for &(ref f, ref stdout) in &state.not_failures {\n+            successes.push(f.name.to_string());\n+            if !stdout.is_empty() {\n+                stdouts.push_str(&format!(\"---- {} stdout ----\\n\", f.name));\n+                let output = String::from_utf8_lossy(stdout);\n+                stdouts.push_str(&output);\n+                stdouts.push_str(\"\\n\");\n+            }\n+        }\n+        if !stdouts.is_empty() {\n+            self.write_plain(\"\\n\")?;\n+            self.write_plain(&stdouts)?;\n+        }\n+\n+        self.write_plain(\"\\nsuccesses:\\n\")?;\n+        successes.sort();\n+        for name in &successes {\n+            self.write_plain(&format!(\"    {}\\n\", name))?;\n+        }\n+        Ok(())\n+    }\n+\n+    pub fn write_failures(&mut self, state: &ConsoleTestState) -> io::Result<()> {\n+        self.write_plain(\"\\nfailures:\\n\")?;\n+        let mut failures = Vec::new();\n+        let mut fail_out = String::new();\n+        for &(ref f, ref stdout) in &state.failures {\n+            failures.push(f.name.to_string());\n+            if !stdout.is_empty() {\n+                fail_out.push_str(&format!(\"---- {} stdout ----\\n\", f.name));\n+                let output = String::from_utf8_lossy(stdout);\n+                fail_out.push_str(&output);\n+                fail_out.push_str(\"\\n\");\n+            }\n+        }\n+        if !fail_out.is_empty() {\n+            self.write_plain(\"\\n\")?;\n+            self.write_plain(&fail_out)?;\n+        }\n+\n+        self.write_plain(\"\\nfailures:\\n\")?;\n+        failures.sort();\n+        for name in &failures {\n+            self.write_plain(&format!(\"    {}\\n\", name))?;\n+        }\n+        Ok(())\n+    }\n+\n+    fn write_test_name(&mut self, desc: &TestDesc) -> io::Result<()> {\n+        let name = desc.padded_name(self.max_name_len, desc.name.padding());\n+        self.write_plain(&format!(\"test {} ... \", name))?;\n+\n+        Ok(())\n+    }\n+}\n+\n+impl<T: Write> OutputFormatter for TerseFormatter<T> {\n+    fn write_run_start(&mut self, test_count: usize) -> io::Result<()> {\n+        self.total_test_count = test_count;\n+        let noun = if test_count != 1 { \"tests\" } else { \"test\" };\n+        self.write_plain(&format!(\"\\nrunning {} {}\\n\", test_count, noun))\n+    }\n+\n+    fn write_test_start(&mut self, desc: &TestDesc) -> io::Result<()> {\n+        // Remnants from old libtest code that used the padding value\n+        // in order to indicate benchmarks.\n+        // When running benchmarks, terse-mode should still print their name as if\n+        // it is the Pretty formatter.\n+        if !self.is_multithreaded && desc.name.padding() == PadOnRight {\n+            self.write_test_name(desc)?;\n+        }\n+\n+        Ok(())\n+    }\n+\n+    fn write_result(&mut self, desc: &TestDesc, result: &TestResult, _: &[u8]) -> io::Result<()> {\n+        match *result {\n+            TrOk => self.write_ok(),\n+            TrFailed | TrFailedMsg(_) => self.write_failed(),\n+            TrIgnored => self.write_ignored(),\n+            TrAllowedFail => self.write_allowed_fail(),\n+            TrBench(ref bs) => {\n+                if self.is_multithreaded {\n+                    self.write_test_name(desc)?;\n+                }\n+                self.write_bench()?;\n+                self.write_plain(&format!(\": {}\\n\", fmt_bench_samples(bs)))\n+            }\n+        }\n+    }\n+\n+    fn write_timeout(&mut self, desc: &TestDesc) -> io::Result<()> {\n+        self.write_plain(&format!(\n+            \"test {} has been running for over {} seconds\\n\",\n+            desc.name, TEST_WARN_TIMEOUT_S\n+        ))\n+    }\n+\n+    fn write_run_finish(&mut self, state: &ConsoleTestState) -> io::Result<bool> {\n+        if state.options.display_output {\n+            self.write_outputs(state)?;\n+        }\n+        let success = state.failed == 0;\n+        if !success {\n+            self.write_failures(state)?;\n+        }\n+\n+        self.write_plain(\"\\ntest result: \")?;\n+\n+        if success {\n+            // There's no parallelism at this point so it's safe to use color\n+            self.write_pretty(\"ok\", term::color::GREEN)?;\n+        } else {\n+            self.write_pretty(\"FAILED\", term::color::RED)?;\n+        }\n+\n+        let s = if state.allowed_fail > 0 {\n+            format!(\n+                \". {} passed; {} failed ({} allowed); {} ignored; {} measured; {} filtered out\\n\\n\",\n+                state.passed,\n+                state.failed + state.allowed_fail,\n+                state.allowed_fail,\n+                state.ignored,\n+                state.measured,\n+                state.filtered_out\n+            )\n+        } else {\n+            format!(\n+                \". {} passed; {} failed; {} ignored; {} measured; {} filtered out\\n\\n\",\n+                state.passed, state.failed, state.ignored, state.measured, state.filtered_out\n+            )\n+        };\n+\n+        self.write_plain(&s)?;\n+\n+        Ok(success)\n+    }\n+}"}, {"sha": "26612964c308fa8cd50d1cb4d25b4626ad02f5a1", "filename": "src/libtest/lib.rs", "status": "modified", "additions": 2202, "deletions": 26, "changes": 2228, "blob_url": "https://github.com/rust-lang/rust/blob/28ea249ab526c6b114c4dc9ba311fc62fccb28e2/src%2Flibtest%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28ea249ab526c6b114c4dc9ba311fc62fccb28e2/src%2Flibtest%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Flib.rs?ref=28ea249ab526c6b114c4dc9ba311fc62fccb28e2", "patch": "@@ -8,48 +8,2224 @@\n //!\n //! See the [Testing Chapter](../book/ch11-00-testing.html) of the book for more details.\n \n+// Currently, not much of this is meant for users. It is intended to\n+// support the simplest interface possible for representing and\n+// running tests while providing a base that other test frameworks may\n+// build off of.\n+\n+// N.B., this is also specified in this crate's Cargo.toml, but libsyntax contains logic specific to\n+// this crate, which relies on this attribute (rather than the value of `--crate-name` passed by\n+// cargo) to detect this crate.\n+\n+#![deny(rust_2018_idioms)]\n #![crate_name = \"test\"]\n #![unstable(feature = \"test\", issue = \"27812\")]\n-#![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\",\n-       test(attr(deny(warnings))))]\n+#![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\", test(attr(deny(warnings))))]\n #![feature(asm)]\n+#![feature(fnbox)]\n+#![cfg_attr(any(unix, target_os = \"cloudabi\"), feature(libc, rustc_private))]\n+#![feature(nll)]\n+#![feature(set_stdio)]\n+#![feature(panic_unwind)]\n #![feature(staged_api)]\n+#![feature(termination_trait_lib)]\n #![feature(test)]\n \n-extern crate libtest;\n+use getopts;\n+#[cfg(any(unix, target_os = \"cloudabi\"))]\n+extern crate libc;\n+use term;\n+\n+// FIXME(#54291): rustc and/or LLVM don't yet support building with panic-unwind\n+//                on aarch64-pc-windows-msvc, so we don't link libtest against\n+//                libunwind (for the time being), even though it means that\n+//                libtest won't be fully functional on this platform.\n+//\n+// See also: https://github.com/rust-lang/rust/issues/54190#issuecomment-422904437\n+#[cfg(not(all(windows, target_arch = \"aarch64\")))]\n+extern crate panic_unwind;\n+\n+pub use self::ColorConfig::*;\n+use self::NamePadding::*;\n+use self::OutputLocation::*;\n+use self::TestEvent::*;\n+pub use self::TestFn::*;\n+pub use self::TestName::*;\n+pub use self::TestResult::*;\n+\n+use std::any::Any;\n+use std::borrow::Cow;\n+use std::boxed::FnBox;\n+use std::cmp;\n+use std::collections::BTreeMap;\n+use std::env;\n+use std::fmt;\n+use std::fs::File;\n+use std::io;\n+use std::io::prelude::*;\n+use std::panic::{catch_unwind, AssertUnwindSafe};\n+use std::path::PathBuf;\n+use std::process;\n+use std::process::Termination;\n+use std::sync::mpsc::{channel, Sender};\n+use std::sync::{Arc, Mutex};\n+use std::thread;\n+use std::time::{Duration, Instant};\n+\n+const TEST_WARN_TIMEOUT_S: u64 = 60;\n+const QUIET_MODE_MAX_COLUMN: usize = 100; // insert a '\\n' after 100 tests in quiet mode\n+\n+// to be used by rustc to compile tests in libtest\n+pub mod test {\n+    pub use crate::{\n+        assert_test_result, filter_tests, parse_opts, run_test, test_main, test_main_static,\n+        Bencher, DynTestFn, DynTestName, Metric, MetricMap, Options, RunIgnored, ShouldPanic,\n+        StaticBenchFn, StaticTestFn, StaticTestName, TestDesc, TestDescAndFn, TestName, TestOpts,\n+        TestResult, TrFailed, TrFailedMsg, TrIgnored, TrOk,\n+    };\n+}\n+\n+mod formatters;\n+pub mod stats;\n+\n+use crate::formatters::{JsonFormatter, OutputFormatter, PrettyFormatter, TerseFormatter};\n+\n+/// Whether to execute tests concurrently or not\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub enum Concurrent {\n+    Yes,\n+    No,\n+}\n+\n+// The name of a test. By convention this follows the rules for rust\n+// paths; i.e., it should be a series of identifiers separated by double\n+// colons. This way if some test runner wants to arrange the tests\n+// hierarchically it may.\n+\n+#[derive(Clone, PartialEq, Eq, Hash, Debug)]\n+pub enum TestName {\n+    StaticTestName(&'static str),\n+    DynTestName(String),\n+    AlignedTestName(Cow<'static, str>, NamePadding),\n+}\n+impl TestName {\n+    fn as_slice(&self) -> &str {\n+        match *self {\n+            StaticTestName(s) => s,\n+            DynTestName(ref s) => s,\n+            AlignedTestName(ref s, _) => &*s,\n+        }\n+    }\n+\n+    fn padding(&self) -> NamePadding {\n+        match self {\n+            &AlignedTestName(_, p) => p,\n+            _ => PadNone,\n+        }\n+    }\n+\n+    fn with_padding(&self, padding: NamePadding) -> TestName {\n+        let name = match self {\n+            &TestName::StaticTestName(name) => Cow::Borrowed(name),\n+            &TestName::DynTestName(ref name) => Cow::Owned(name.clone()),\n+            &TestName::AlignedTestName(ref name, _) => name.clone(),\n+        };\n+\n+        TestName::AlignedTestName(name, padding)\n+    }\n+}\n+impl fmt::Display for TestName {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        fmt::Display::fmt(self.as_slice(), f)\n+    }\n+}\n+\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, Debug)]\n+pub enum NamePadding {\n+    PadNone,\n+    PadOnRight,\n+}\n+\n+impl TestDesc {\n+    fn padded_name(&self, column_count: usize, align: NamePadding) -> String {\n+        let mut name = String::from(self.name.as_slice());\n+        let fill = column_count.saturating_sub(name.len());\n+        let pad = \" \".repeat(fill);\n+        match align {\n+            PadNone => name,\n+            PadOnRight => {\n+                name.push_str(&pad);\n+                name\n+            }\n+        }\n+    }\n+}\n+\n+/// Represents a benchmark function.\n+pub trait TDynBenchFn: Send {\n+    fn run(&self, harness: &mut Bencher);\n+}\n+\n+// A function that runs a test. If the function returns successfully,\n+// the test succeeds; if the function panics then the test fails. We\n+// may need to come up with a more clever definition of test in order\n+// to support isolation of tests into threads.\n+pub enum TestFn {\n+    StaticTestFn(fn()),\n+    StaticBenchFn(fn(&mut Bencher)),\n+    DynTestFn(Box<dyn FnBox() + Send>),\n+    DynBenchFn(Box<dyn TDynBenchFn + 'static>),\n+}\n+\n+impl TestFn {\n+    fn padding(&self) -> NamePadding {\n+        match *self {\n+            StaticTestFn(..) => PadNone,\n+            StaticBenchFn(..) => PadOnRight,\n+            DynTestFn(..) => PadNone,\n+            DynBenchFn(..) => PadOnRight,\n+        }\n+    }\n+}\n+\n+impl fmt::Debug for TestFn {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        f.write_str(match *self {\n+            StaticTestFn(..) => \"StaticTestFn(..)\",\n+            StaticBenchFn(..) => \"StaticBenchFn(..)\",\n+            DynTestFn(..) => \"DynTestFn(..)\",\n+            DynBenchFn(..) => \"DynBenchFn(..)\",\n+        })\n+    }\n+}\n+\n+/// Manager of the benchmarking runs.\n+///\n+/// This is fed into functions marked with `#[bench]` to allow for\n+/// set-up & tear-down before running a piece of code repeatedly via a\n+/// call to `iter`.\n+#[derive(Clone)]\n+pub struct Bencher {\n+    mode: BenchMode,\n+    summary: Option<stats::Summary>,\n+    pub bytes: u64,\n+}\n+\n+#[derive(Clone, PartialEq, Eq)]\n+pub enum BenchMode {\n+    Auto,\n+    Single,\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n+pub enum ShouldPanic {\n+    No,\n+    Yes,\n+    YesWithMessage(&'static str),\n+}\n+\n+// The definition of a single test. A test runner will run a list of\n+// these.\n+#[derive(Clone, Debug, PartialEq, Eq, Hash)]\n+pub struct TestDesc {\n+    pub name: TestName,\n+    pub ignore: bool,\n+    pub should_panic: ShouldPanic,\n+    pub allow_fail: bool,\n+}\n+\n+#[derive(Debug)]\n+pub struct TestDescAndFn {\n+    pub desc: TestDesc,\n+    pub testfn: TestFn,\n+}\n+\n+#[derive(Clone, PartialEq, Debug, Copy)]\n+pub struct Metric {\n+    value: f64,\n+    noise: f64,\n+}\n+\n+impl Metric {\n+    pub fn new(value: f64, noise: f64) -> Metric {\n+        Metric { value, noise }\n+    }\n+}\n+\n+/// In case we want to add other options as well, just add them in this struct.\n+#[derive(Copy, Clone, Debug)]\n+pub struct Options {\n+    display_output: bool,\n+}\n+\n+impl Options {\n+    pub fn new() -> Options {\n+        Options {\n+            display_output: false,\n+        }\n+    }\n+\n+    pub fn display_output(mut self, display_output: bool) -> Options {\n+        self.display_output = display_output;\n+        self\n+    }\n+}\n+\n+// The default console test runner. It accepts the command line\n+// arguments and a vector of test_descs.\n+pub fn test_main(args: &[String], tests: Vec<TestDescAndFn>, options: Options) {\n+    let mut opts = match parse_opts(args) {\n+        Some(Ok(o)) => o,\n+        Some(Err(msg)) => {\n+            eprintln!(\"error: {}\", msg);\n+            process::exit(101);\n+        }\n+        None => return,\n+    };\n+\n+    opts.options = options;\n+    if opts.list {\n+        if let Err(e) = list_tests_console(&opts, tests) {\n+            eprintln!(\"error: io error when listing tests: {:?}\", e);\n+            process::exit(101);\n+        }\n+    } else {\n+        match run_tests_console(&opts, tests) {\n+            Ok(true) => {}\n+            Ok(false) => process::exit(101),\n+            Err(e) => {\n+                eprintln!(\"error: io error when listing tests: {:?}\", e);\n+                process::exit(101);\n+            }\n+        }\n+    }\n+}\n+\n+// A variant optimized for invocation with a static test vector.\n+// This will panic (intentionally) when fed any dynamic tests, because\n+// it is copying the static values out into a dynamic vector and cannot\n+// copy dynamic values. It is doing this because from this point on\n+// a Vec<TestDescAndFn> is used in order to effect ownership-transfer\n+// semantics into parallel test runners, which in turn requires a Vec<>\n+// rather than a &[].\n+pub fn test_main_static(tests: &[&TestDescAndFn]) {\n+    let args = env::args().collect::<Vec<_>>();\n+    let owned_tests = tests\n+        .iter()\n+        .map(|t| match t.testfn {\n+            StaticTestFn(f) => TestDescAndFn {\n+                testfn: StaticTestFn(f),\n+                desc: t.desc.clone(),\n+            },\n+            StaticBenchFn(f) => TestDescAndFn {\n+                testfn: StaticBenchFn(f),\n+                desc: t.desc.clone(),\n+            },\n+            _ => panic!(\"non-static tests passed to test::test_main_static\"),\n+        })\n+        .collect();\n+    test_main(&args, owned_tests, Options::new())\n+}\n+\n+/// Invoked when unit tests terminate. Should panic if the unit\n+/// Tests is considered a failure. By default, invokes `report()`\n+/// and checks for a `0` result.\n+pub fn assert_test_result<T: Termination>(result: T) {\n+    let code = result.report();\n+    assert_eq!(\n+        code, 0,\n+        \"the test returned a termination value with a non-zero status code ({}) \\\n+         which indicates a failure\",\n+        code\n+    );\n+}\n+\n+#[derive(Copy, Clone, Debug)]\n+pub enum ColorConfig {\n+    AutoColor,\n+    AlwaysColor,\n+    NeverColor,\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub enum OutputFormat {\n+    Pretty,\n+    Terse,\n+    Json,\n+}\n+\n+#[derive(Copy, Clone, Debug, PartialEq, Eq)]\n+pub enum RunIgnored {\n+    Yes,\n+    No,\n+    Only,\n+}\n+\n+#[derive(Debug)]\n+pub struct TestOpts {\n+    pub list: bool,\n+    pub filter: Option<String>,\n+    pub filter_exact: bool,\n+    pub exclude_should_panic: bool,\n+    pub run_ignored: RunIgnored,\n+    pub run_tests: bool,\n+    pub bench_benchmarks: bool,\n+    pub logfile: Option<PathBuf>,\n+    pub nocapture: bool,\n+    pub color: ColorConfig,\n+    pub format: OutputFormat,\n+    pub test_threads: Option<usize>,\n+    pub skip: Vec<String>,\n+    pub options: Options,\n+}\n+\n+impl TestOpts {\n+    #[cfg(test)]\n+    fn new() -> TestOpts {\n+        TestOpts {\n+            list: false,\n+            filter: None,\n+            filter_exact: false,\n+            exclude_should_panic: false,\n+            run_ignored: RunIgnored::No,\n+            run_tests: false,\n+            bench_benchmarks: false,\n+            logfile: None,\n+            nocapture: false,\n+            color: AutoColor,\n+            format: OutputFormat::Pretty,\n+            test_threads: None,\n+            skip: vec![],\n+            options: Options::new(),\n+        }\n+    }\n+}\n+\n+/// Result of parsing the options.\n+pub type OptRes = Result<TestOpts, String>;\n+\n+fn optgroups() -> getopts::Options {\n+    let mut opts = getopts::Options::new();\n+    opts.optflag(\"\", \"include-ignored\", \"Run ignored and not ignored tests\")\n+        .optflag(\"\", \"ignored\", \"Run only ignored tests\")\n+        .optflag(\"\", \"exclude-should-panic\", \"Excludes tests marked as should_panic\")\n+        .optflag(\"\", \"test\", \"Run tests and not benchmarks\")\n+        .optflag(\"\", \"bench\", \"Run benchmarks instead of tests\")\n+        .optflag(\"\", \"list\", \"List all tests and benchmarks\")\n+        .optflag(\"h\", \"help\", \"Display this message (longer with --help)\")\n+        .optopt(\n+            \"\",\n+            \"logfile\",\n+            \"Write logs to the specified file instead \\\n+             of stdout\",\n+            \"PATH\",\n+        )\n+        .optflag(\n+            \"\",\n+            \"nocapture\",\n+            \"don't capture stdout/stderr of each \\\n+             task, allow printing directly\",\n+        )\n+        .optopt(\n+            \"\",\n+            \"test-threads\",\n+            \"Number of threads used for running tests \\\n+             in parallel\",\n+            \"n_threads\",\n+        )\n+        .optmulti(\n+            \"\",\n+            \"skip\",\n+            \"Skip tests whose names contain FILTER (this flag can \\\n+             be used multiple times)\",\n+            \"FILTER\",\n+        )\n+        .optflag(\n+            \"q\",\n+            \"quiet\",\n+            \"Display one character per test instead of one line. \\\n+             Alias to --format=terse\",\n+        )\n+        .optflag(\n+            \"\",\n+            \"exact\",\n+            \"Exactly match filters rather than by substring\",\n+        )\n+        .optopt(\n+            \"\",\n+            \"color\",\n+            \"Configure coloring of output:\n+            auto   = colorize if stdout is a tty and tests are run on serially (default);\n+            always = always colorize output;\n+            never  = never colorize output;\",\n+            \"auto|always|never\",\n+        )\n+        .optopt(\n+            \"\",\n+            \"format\",\n+            \"Configure formatting of output:\n+            pretty = Print verbose output;\n+            terse  = Display one character per test;\n+            json   = Output a json document\",\n+            \"pretty|terse|json\",\n+        )\n+        .optopt(\n+            \"Z\",\n+            \"\",\n+            \"Enable nightly-only flags:\n+            unstable-options = Allow use of experimental features\",\n+            \"unstable-options\",\n+        );\n+    return opts;\n+}\n+\n+fn usage(binary: &str, options: &getopts::Options) {\n+    let message = format!(\"Usage: {} [OPTIONS] [FILTER]\", binary);\n+    println!(\n+        r#\"{usage}\n+\n+The FILTER string is tested against the name of all tests, and only those\n+tests whose names contain the filter are run.\n+\n+By default, all tests are run in parallel. This can be altered with the\n+--test-threads flag or the RUST_TEST_THREADS environment variable when running\n+tests (set it to 1).\n+\n+All tests have their standard output and standard error captured by default.\n+This can be overridden with the --nocapture flag or setting RUST_TEST_NOCAPTURE\n+environment variable to a value other than \"0\". Logging is not captured by default.\n+\n+Test Attributes:\n+\n+    #[test]        - Indicates a function is a test to be run. This function\n+                     takes no arguments.\n+    #[bench]       - Indicates a function is a benchmark to be run. This\n+                     function takes one argument (test::Bencher).\n+    #[should_panic] - This function (also labeled with #[test]) will only pass if\n+                     the code causes a panic (an assertion failure or panic!)\n+                     A message may be provided, which the failure string must\n+                     contain: #[should_panic(expected = \"foo\")].\n+    #[ignore]      - When applied to a function which is already attributed as a\n+                     test, then the test runner will ignore these tests during\n+                     normal test runs. Running with --ignored or --include-ignored will run\n+                     these tests.\"#,\n+        usage = options.usage(&message)\n+    );\n+}\n+\n+// FIXME: Copied from libsyntax until linkage errors are resolved. Issue #47566\n+fn is_nightly() -> bool {\n+    // Whether this is a feature-staged build, i.e., on the beta or stable channel\n+    let disable_unstable_features = option_env!(\"CFG_DISABLE_UNSTABLE_FEATURES\").is_some();\n+    // Whether we should enable unstable features for bootstrapping\n+    let bootstrap = env::var(\"RUSTC_BOOTSTRAP\").is_ok();\n+\n+    bootstrap || !disable_unstable_features\n+}\n+\n+// Parses command line arguments into test options\n+pub fn parse_opts(args: &[String]) -> Option<OptRes> {\n+    let mut allow_unstable = false;\n+    let opts = optgroups();\n+    let args = args.get(1..).unwrap_or(args);\n+    let matches = match opts.parse(args) {\n+        Ok(m) => m,\n+        Err(f) => return Some(Err(f.to_string())),\n+    };\n+\n+    if let Some(opt) = matches.opt_str(\"Z\") {\n+        if !is_nightly() {\n+            return Some(Err(\n+                \"the option `Z` is only accepted on the nightly compiler\".into(),\n+            ));\n+        }\n+\n+        match &*opt {\n+            \"unstable-options\" => {\n+                allow_unstable = true;\n+            }\n+            _ => {\n+                return Some(Err(\"Unrecognized option to `Z`\".into()));\n+            }\n+        }\n+    };\n+\n+    if matches.opt_present(\"h\") {\n+        usage(&args[0], &opts);\n+        return None;\n+    }\n+\n+    let filter = if !matches.free.is_empty() {\n+        Some(matches.free[0].clone())\n+    } else {\n+        None\n+    };\n+\n+    let exclude_should_panic = matches.opt_present(\"exclude-should-panic\");\n+    if !allow_unstable && exclude_should_panic {\n+        return Some(Err(\n+            \"The \\\"exclude-should-panic\\\" flag is only accepted on the nightly compiler\".into(),\n+        ));\n+    }\n+\n+    let include_ignored = matches.opt_present(\"include-ignored\");\n+    if !allow_unstable && include_ignored {\n+        return Some(Err(\n+            \"The \\\"include-ignored\\\" flag is only accepted on the nightly compiler\".into(),\n+        ));\n+    }\n+\n+    let run_ignored = match (include_ignored, matches.opt_present(\"ignored\")) {\n+        (true, true) => {\n+            return Some(Err(\n+                \"the options --include-ignored and --ignored are mutually exclusive\".into(),\n+            ));\n+        }\n+        (true, false) => RunIgnored::Yes,\n+        (false, true) => RunIgnored::Only,\n+        (false, false) => RunIgnored::No,\n+    };\n+    let quiet = matches.opt_present(\"quiet\");\n+    let exact = matches.opt_present(\"exact\");\n+    let list = matches.opt_present(\"list\");\n+\n+    let logfile = matches.opt_str(\"logfile\");\n+    let logfile = logfile.map(|s| PathBuf::from(&s));\n+\n+    let bench_benchmarks = matches.opt_present(\"bench\");\n+    let run_tests = !bench_benchmarks || matches.opt_present(\"test\");\n+\n+    let mut nocapture = matches.opt_present(\"nocapture\");\n+    if !nocapture {\n+        nocapture = match env::var(\"RUST_TEST_NOCAPTURE\") {\n+            Ok(val) => &val != \"0\",\n+            Err(_) => false,\n+        };\n+    }\n+\n+    let test_threads = match matches.opt_str(\"test-threads\") {\n+        Some(n_str) => match n_str.parse::<usize>() {\n+            Ok(0) => return Some(Err(\"argument for --test-threads must not be 0\".to_string())),\n+            Ok(n) => Some(n),\n+            Err(e) => {\n+                return Some(Err(format!(\n+                    \"argument for --test-threads must be a number > 0 \\\n+                     (error: {})\",\n+                    e\n+                )));\n+            }\n+        },\n+        None => None,\n+    };\n+\n+    let color = match matches.opt_str(\"color\").as_ref().map(|s| &**s) {\n+        Some(\"auto\") | None => AutoColor,\n+        Some(\"always\") => AlwaysColor,\n+        Some(\"never\") => NeverColor,\n+\n+        Some(v) => {\n+            return Some(Err(format!(\n+                \"argument for --color must be auto, always, or never (was \\\n+                 {})\",\n+                v\n+            )));\n+        }\n+    };\n+\n+    let format = match matches.opt_str(\"format\").as_ref().map(|s| &**s) {\n+        None if quiet => OutputFormat::Terse,\n+        Some(\"pretty\") | None => OutputFormat::Pretty,\n+        Some(\"terse\") => OutputFormat::Terse,\n+        Some(\"json\") => {\n+            if !allow_unstable {\n+                return Some(Err(\n+                    \"The \\\"json\\\" format is only accepted on the nightly compiler\".into(),\n+                ));\n+            }\n+            OutputFormat::Json\n+        }\n+\n+        Some(v) => {\n+            return Some(Err(format!(\n+                \"argument for --format must be pretty, terse, or json (was \\\n+                 {})\",\n+                v\n+            )));\n+        }\n+    };\n+\n+    let test_opts = TestOpts {\n+        list,\n+        filter,\n+        filter_exact: exact,\n+        exclude_should_panic,\n+        run_ignored,\n+        run_tests,\n+        bench_benchmarks,\n+        logfile,\n+        nocapture,\n+        color,\n+        format,\n+        test_threads,\n+        skip: matches.opt_strs(\"skip\"),\n+        options: Options::new(),\n+    };\n+\n+    Some(Ok(test_opts))\n+}\n+\n+#[derive(Clone, PartialEq)]\n+pub struct BenchSamples {\n+    ns_iter_summ: stats::Summary,\n+    mb_s: usize,\n+}\n+\n+#[derive(Clone, PartialEq)]\n+pub enum TestResult {\n+    TrOk,\n+    TrFailed,\n+    TrFailedMsg(String),\n+    TrIgnored,\n+    TrAllowedFail,\n+    TrBench(BenchSamples),\n+}\n+\n+unsafe impl Send for TestResult {}\n+\n+enum OutputLocation<T> {\n+    Pretty(Box<term::StdoutTerminal>),\n+    Raw(T),\n+}\n+\n+impl<T: Write> Write for OutputLocation<T> {\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        match *self {\n+            Pretty(ref mut term) => term.write(buf),\n+            Raw(ref mut stdout) => stdout.write(buf),\n+        }\n+    }\n+\n+    fn flush(&mut self) -> io::Result<()> {\n+        match *self {\n+            Pretty(ref mut term) => term.flush(),\n+            Raw(ref mut stdout) => stdout.flush(),\n+        }\n+    }\n+}\n+\n+struct ConsoleTestState {\n+    log_out: Option<File>,\n+    total: usize,\n+    passed: usize,\n+    failed: usize,\n+    ignored: usize,\n+    allowed_fail: usize,\n+    filtered_out: usize,\n+    measured: usize,\n+    metrics: MetricMap,\n+    failures: Vec<(TestDesc, Vec<u8>)>,\n+    not_failures: Vec<(TestDesc, Vec<u8>)>,\n+    options: Options,\n+}\n+\n+impl ConsoleTestState {\n+    pub fn new(opts: &TestOpts) -> io::Result<ConsoleTestState> {\n+        let log_out = match opts.logfile {\n+            Some(ref path) => Some(File::create(path)?),\n+            None => None,\n+        };\n+\n+        Ok(ConsoleTestState {\n+            log_out,\n+            total: 0,\n+            passed: 0,\n+            failed: 0,\n+            ignored: 0,\n+            allowed_fail: 0,\n+            filtered_out: 0,\n+            measured: 0,\n+            metrics: MetricMap::new(),\n+            failures: Vec::new(),\n+            not_failures: Vec::new(),\n+            options: opts.options,\n+        })\n+    }\n+\n+    pub fn write_log<S: AsRef<str>>(&mut self, msg: S) -> io::Result<()> {\n+        let msg = msg.as_ref();\n+        match self.log_out {\n+            None => Ok(()),\n+            Some(ref mut o) => o.write_all(msg.as_bytes()),\n+        }\n+    }\n+\n+    pub fn write_log_result(&mut self, test: &TestDesc, result: &TestResult) -> io::Result<()> {\n+        self.write_log(format!(\n+            \"{} {}\\n\",\n+            match *result {\n+                TrOk => \"ok\".to_owned(),\n+                TrFailed => \"failed\".to_owned(),\n+                TrFailedMsg(ref msg) => format!(\"failed: {}\", msg),\n+                TrIgnored => \"ignored\".to_owned(),\n+                TrAllowedFail => \"failed (allowed)\".to_owned(),\n+                TrBench(ref bs) => fmt_bench_samples(bs),\n+            },\n+            test.name\n+        ))\n+    }\n+\n+    fn current_test_count(&self) -> usize {\n+        self.passed + self.failed + self.ignored + self.measured + self.allowed_fail\n+    }\n+}\n+\n+// Format a number with thousands separators\n+fn fmt_thousands_sep(mut n: usize, sep: char) -> String {\n+    use std::fmt::Write;\n+    let mut output = String::new();\n+    let mut trailing = false;\n+    for &pow in &[9, 6, 3, 0] {\n+        let base = 10_usize.pow(pow);\n+        if pow == 0 || trailing || n / base != 0 {\n+            if !trailing {\n+                output.write_fmt(format_args!(\"{}\", n / base)).unwrap();\n+            } else {\n+                output.write_fmt(format_args!(\"{:03}\", n / base)).unwrap();\n+            }\n+            if pow != 0 {\n+                output.push(sep);\n+            }\n+            trailing = true;\n+        }\n+        n %= base;\n+    }\n+\n+    output\n+}\n+\n+pub fn fmt_bench_samples(bs: &BenchSamples) -> String {\n+    use std::fmt::Write;\n+    let mut output = String::new();\n+\n+    let median = bs.ns_iter_summ.median as usize;\n+    let deviation = (bs.ns_iter_summ.max - bs.ns_iter_summ.min) as usize;\n+\n+    output\n+        .write_fmt(format_args!(\n+            \"{:>11} ns/iter (+/- {})\",\n+            fmt_thousands_sep(median, ','),\n+            fmt_thousands_sep(deviation, ',')\n+        ))\n+        .unwrap();\n+    if bs.mb_s != 0 {\n+        output\n+            .write_fmt(format_args!(\" = {} MB/s\", bs.mb_s))\n+            .unwrap();\n+    }\n+    output\n+}\n+\n+// List the tests to console, and optionally to logfile. Filters are honored.\n+pub fn list_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> io::Result<()> {\n+    let mut output = match term::stdout() {\n+        None => Raw(io::stdout()),\n+        Some(t) => Pretty(t),\n+    };\n+\n+    let quiet = opts.format == OutputFormat::Terse;\n+    let mut st = ConsoleTestState::new(opts)?;\n+\n+    let mut ntest = 0;\n+    let mut nbench = 0;\n+\n+    for test in filter_tests(&opts, tests) {\n+        use crate::TestFn::*;\n+\n+        let TestDescAndFn {\n+            desc: TestDesc { name, .. },\n+            testfn,\n+        } = test;\n+\n+        let fntype = match testfn {\n+            StaticTestFn(..) | DynTestFn(..) => {\n+                ntest += 1;\n+                \"test\"\n+            }\n+            StaticBenchFn(..) | DynBenchFn(..) => {\n+                nbench += 1;\n+                \"benchmark\"\n+            }\n+        };\n+\n+        writeln!(output, \"{}: {}\", name, fntype)?;\n+        st.write_log(format!(\"{} {}\\n\", fntype, name))?;\n+    }\n+\n+    fn plural(count: u32, s: &str) -> String {\n+        match count {\n+            1 => format!(\"{} {}\", 1, s),\n+            n => format!(\"{} {}s\", n, s),\n+        }\n+    }\n+\n+    if !quiet {\n+        if ntest != 0 || nbench != 0 {\n+            writeln!(output, \"\")?;\n+        }\n+\n+        writeln!(\n+            output,\n+            \"{}, {}\",\n+            plural(ntest, \"test\"),\n+            plural(nbench, \"benchmark\")\n+        )?;\n+    }\n+\n+    Ok(())\n+}\n+\n+// A simple console test runner\n+pub fn run_tests_console(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> io::Result<bool> {\n+    fn callback(\n+        event: &TestEvent,\n+        st: &mut ConsoleTestState,\n+        out: &mut dyn OutputFormatter,\n+    ) -> io::Result<()> {\n+        match (*event).clone() {\n+            TeFiltered(ref filtered_tests) => {\n+                st.total = filtered_tests.len();\n+                out.write_run_start(filtered_tests.len())\n+            }\n+            TeFilteredOut(filtered_out) => Ok(st.filtered_out = filtered_out),\n+            TeWait(ref test) => out.write_test_start(test),\n+            TeTimeout(ref test) => out.write_timeout(test),\n+            TeResult(test, result, stdout) => {\n+                st.write_log_result(&test, &result)?;\n+                out.write_result(&test, &result, &*stdout)?;\n+                match result {\n+                    TrOk => {\n+                        st.passed += 1;\n+                        st.not_failures.push((test, stdout));\n+                    }\n+                    TrIgnored => st.ignored += 1,\n+                    TrAllowedFail => st.allowed_fail += 1,\n+                    TrBench(bs) => {\n+                        st.metrics.insert_metric(\n+                            test.name.as_slice(),\n+                            bs.ns_iter_summ.median,\n+                            bs.ns_iter_summ.max - bs.ns_iter_summ.min,\n+                        );\n+                        st.measured += 1\n+                    }\n+                    TrFailed => {\n+                        st.failed += 1;\n+                        st.failures.push((test, stdout));\n+                    }\n+                    TrFailedMsg(msg) => {\n+                        st.failed += 1;\n+                        let mut stdout = stdout;\n+                        stdout.extend_from_slice(format!(\"note: {}\", msg).as_bytes());\n+                        st.failures.push((test, stdout));\n+                    }\n+                }\n+                Ok(())\n+            }\n+        }\n+    }\n+\n+    let output = match term::stdout() {\n+        None => Raw(io::stdout()),\n+        Some(t) => Pretty(t),\n+    };\n+\n+    let max_name_len = tests\n+        .iter()\n+        .max_by_key(|t| len_if_padded(*t))\n+        .map(|t| t.desc.name.as_slice().len())\n+        .unwrap_or(0);\n+\n+    let is_multithreaded = opts.test_threads.unwrap_or_else(get_concurrency) > 1;\n+\n+    let mut out: Box<dyn OutputFormatter> = match opts.format {\n+        OutputFormat::Pretty => Box::new(PrettyFormatter::new(\n+            output,\n+            use_color(opts),\n+            max_name_len,\n+            is_multithreaded,\n+        )),\n+        OutputFormat::Terse => Box::new(TerseFormatter::new(\n+            output,\n+            use_color(opts),\n+            max_name_len,\n+            is_multithreaded,\n+        )),\n+        OutputFormat::Json => Box::new(JsonFormatter::new(output)),\n+    };\n+    let mut st = ConsoleTestState::new(opts)?;\n+    fn len_if_padded(t: &TestDescAndFn) -> usize {\n+        match t.testfn.padding() {\n+            PadNone => 0,\n+            PadOnRight => t.desc.name.as_slice().len(),\n+        }\n+    }\n+\n+    run_tests(opts, tests, |x| callback(&x, &mut st, &mut *out))?;\n+\n+    assert!(st.current_test_count() == st.total);\n+\n+    return out.write_run_finish(&st);\n+}\n+\n+#[test]\n+fn should_sort_failures_before_printing_them() {\n+    let test_a = TestDesc {\n+        name: StaticTestName(\"a\"),\n+        ignore: false,\n+        should_panic: ShouldPanic::No,\n+        allow_fail: false,\n+    };\n+\n+    let test_b = TestDesc {\n+        name: StaticTestName(\"b\"),\n+        ignore: false,\n+        should_panic: ShouldPanic::No,\n+        allow_fail: false,\n+    };\n+\n+    let mut out = PrettyFormatter::new(Raw(Vec::new()), false, 10, false);\n+\n+    let st = ConsoleTestState {\n+        log_out: None,\n+        total: 0,\n+        passed: 0,\n+        failed: 0,\n+        ignored: 0,\n+        allowed_fail: 0,\n+        filtered_out: 0,\n+        measured: 0,\n+        metrics: MetricMap::new(),\n+        failures: vec![(test_b, Vec::new()), (test_a, Vec::new())],\n+        options: Options::new(),\n+        not_failures: Vec::new(),\n+    };\n+\n+    out.write_failures(&st).unwrap();\n+    let s = match out.output_location() {\n+        &Raw(ref m) => String::from_utf8_lossy(&m[..]),\n+        &Pretty(_) => unreachable!(),\n+    };\n+\n+    let apos = s.find(\"a\").unwrap();\n+    let bpos = s.find(\"b\").unwrap();\n+    assert!(apos < bpos);\n+}\n+\n+fn use_color(opts: &TestOpts) -> bool {\n+    match opts.color {\n+        AutoColor => !opts.nocapture && stdout_isatty(),\n+        AlwaysColor => true,\n+        NeverColor => false,\n+    }\n+}\n+\n+#[cfg(any(\n+    target_os = \"cloudabi\",\n+    target_os = \"redox\",\n+    all(target_arch = \"wasm32\", not(target_os = \"emscripten\")),\n+    all(target_vendor = \"fortanix\", target_env = \"sgx\")\n+))]\n+fn stdout_isatty() -> bool {\n+    // FIXME: Implement isatty on Redox and SGX\n+    false\n+}\n+#[cfg(unix)]\n+fn stdout_isatty() -> bool {\n+    unsafe { libc::isatty(libc::STDOUT_FILENO) != 0 }\n+}\n+#[cfg(windows)]\n+fn stdout_isatty() -> bool {\n+    type DWORD = u32;\n+    type BOOL = i32;\n+    type HANDLE = *mut u8;\n+    type LPDWORD = *mut u32;\n+    const STD_OUTPUT_HANDLE: DWORD = -11i32 as DWORD;\n+    extern \"system\" {\n+        fn GetStdHandle(which: DWORD) -> HANDLE;\n+        fn GetConsoleMode(hConsoleHandle: HANDLE, lpMode: LPDWORD) -> BOOL;\n+    }\n+    unsafe {\n+        let handle = GetStdHandle(STD_OUTPUT_HANDLE);\n+        let mut out = 0;\n+        GetConsoleMode(handle, &mut out) != 0\n+    }\n+}\n+\n+#[derive(Clone)]\n+pub enum TestEvent {\n+    TeFiltered(Vec<TestDesc>),\n+    TeWait(TestDesc),\n+    TeResult(TestDesc, TestResult, Vec<u8>),\n+    TeTimeout(TestDesc),\n+    TeFilteredOut(usize),\n+}\n+\n+pub type MonitorMsg = (TestDesc, TestResult, Vec<u8>);\n \n-// FIXME: we should be more explicit about the exact APIs that we\n-// export to users.\n-pub use libtest::{\n-    assert_test_result, filter_tests, parse_opts, run_test, test_main, test_main_static,\n-    Bencher, DynTestFn, DynTestName, Metric, MetricMap, Options, RunIgnored, ShouldPanic,\n-    StaticBenchFn, StaticTestFn, StaticTestName, TestDesc, TestDescAndFn, TestName, TestOpts,\n-    TestResult, TrFailed, TrFailedMsg, TrIgnored, TrOk, stats::Summary\n-};\n+struct Sink(Arc<Mutex<Vec<u8>>>);\n+impl Write for Sink {\n+    fn write(&mut self, data: &[u8]) -> io::Result<usize> {\n+        Write::write(&mut *self.0.lock().unwrap(), data)\n+    }\n+    fn flush(&mut self) -> io::Result<()> {\n+        Ok(())\n+    }\n+}\n+\n+pub fn run_tests<F>(opts: &TestOpts, tests: Vec<TestDescAndFn>, mut callback: F) -> io::Result<()>\n+where\n+    F: FnMut(TestEvent) -> io::Result<()>,\n+{\n+    use std::collections::{self, HashMap};\n+    use std::hash::BuildHasherDefault;\n+    use std::sync::mpsc::RecvTimeoutError;\n+    // Use a deterministic hasher\n+    type TestMap =\n+        HashMap<TestDesc, Instant, BuildHasherDefault<collections::hash_map::DefaultHasher>>;\n+\n+    let tests_len = tests.len();\n+\n+    let mut filtered_tests = filter_tests(opts, tests);\n+    if !opts.bench_benchmarks {\n+        filtered_tests = convert_benchmarks_to_tests(filtered_tests);\n+    }\n+\n+    let filtered_tests = {\n+        let mut filtered_tests = filtered_tests;\n+        for test in filtered_tests.iter_mut() {\n+            test.desc.name = test.desc.name.with_padding(test.testfn.padding());\n+        }\n+\n+        filtered_tests\n+    };\n+\n+    let filtered_out = tests_len - filtered_tests.len();\n+    callback(TeFilteredOut(filtered_out))?;\n+\n+    let filtered_descs = filtered_tests.iter().map(|t| t.desc.clone()).collect();\n+\n+    callback(TeFiltered(filtered_descs))?;\n+\n+    let (filtered_tests, filtered_benchs): (Vec<_>, _) =\n+        filtered_tests.into_iter().partition(|e| match e.testfn {\n+            StaticTestFn(_) | DynTestFn(_) => true,\n+            _ => false,\n+        });\n+\n+    let concurrency = opts.test_threads.unwrap_or_else(get_concurrency);\n+\n+    let mut remaining = filtered_tests;\n+    remaining.reverse();\n+    let mut pending = 0;\n+\n+    let (tx, rx) = channel::<MonitorMsg>();\n+\n+    let mut running_tests: TestMap = HashMap::default();\n+\n+    fn get_timed_out_tests(running_tests: &mut TestMap) -> Vec<TestDesc> {\n+        let now = Instant::now();\n+        let timed_out = running_tests\n+            .iter()\n+            .filter_map(|(desc, timeout)| {\n+                if &now >= timeout {\n+                    Some(desc.clone())\n+                } else {\n+                    None\n+                }\n+            })\n+            .collect();\n+        for test in &timed_out {\n+            running_tests.remove(test);\n+        }\n+        timed_out\n+    };\n+\n+    fn calc_timeout(running_tests: &TestMap) -> Option<Duration> {\n+        running_tests.values().min().map(|next_timeout| {\n+            let now = Instant::now();\n+            if *next_timeout >= now {\n+                *next_timeout - now\n+            } else {\n+                Duration::new(0, 0)\n+            }\n+        })\n+    };\n+\n+    if concurrency == 1 {\n+        while !remaining.is_empty() {\n+            let test = remaining.pop().unwrap();\n+            callback(TeWait(test.desc.clone()))?;\n+            run_test(opts, !opts.run_tests, test, tx.clone(), Concurrent::No);\n+            let (test, result, stdout) = rx.recv().unwrap();\n+            callback(TeResult(test, result, stdout))?;\n+        }\n+    } else {\n+        while pending > 0 || !remaining.is_empty() {\n+            while pending < concurrency && !remaining.is_empty() {\n+                let test = remaining.pop().unwrap();\n+                let timeout = Instant::now() + Duration::from_secs(TEST_WARN_TIMEOUT_S);\n+                running_tests.insert(test.desc.clone(), timeout);\n+                callback(TeWait(test.desc.clone()))?; //here no pad\n+                run_test(opts, !opts.run_tests, test, tx.clone(), Concurrent::Yes);\n+                pending += 1;\n+            }\n+\n+            let mut res;\n+            loop {\n+                if let Some(timeout) = calc_timeout(&running_tests) {\n+                    res = rx.recv_timeout(timeout);\n+                    for test in get_timed_out_tests(&mut running_tests) {\n+                        callback(TeTimeout(test))?;\n+                    }\n+                    if res != Err(RecvTimeoutError::Timeout) {\n+                        break;\n+                    }\n+                } else {\n+                    res = rx.recv().map_err(|_| RecvTimeoutError::Disconnected);\n+                    break;\n+                }\n+            }\n+\n+            let (desc, result, stdout) = res.unwrap();\n+            running_tests.remove(&desc);\n+\n+            callback(TeResult(desc, result, stdout))?;\n+            pending -= 1;\n+        }\n+    }\n+\n+    if opts.bench_benchmarks {\n+        // All benchmarks run at the end, in serial.\n+        for b in filtered_benchs {\n+            callback(TeWait(b.desc.clone()))?;\n+            run_test(opts, false, b, tx.clone(), Concurrent::No);\n+            let (test, result, stdout) = rx.recv().unwrap();\n+            callback(TeResult(test, result, stdout))?;\n+        }\n+    }\n+    Ok(())\n+}\n+\n+#[allow(deprecated)]\n+fn get_concurrency() -> usize {\n+    return match env::var(\"RUST_TEST_THREADS\") {\n+        Ok(s) => {\n+            let opt_n: Option<usize> = s.parse().ok();\n+            match opt_n {\n+                Some(n) if n > 0 => n,\n+                _ => panic!(\n+                    \"RUST_TEST_THREADS is `{}`, should be a positive integer.\",\n+                    s\n+                ),\n+            }\n+        }\n+        Err(..) => num_cpus(),\n+    };\n+\n+    #[cfg(windows)]\n+    #[allow(nonstandard_style)]\n+    fn num_cpus() -> usize {\n+        #[repr(C)]\n+        struct SYSTEM_INFO {\n+            wProcessorArchitecture: u16,\n+            wReserved: u16,\n+            dwPageSize: u32,\n+            lpMinimumApplicationAddress: *mut u8,\n+            lpMaximumApplicationAddress: *mut u8,\n+            dwActiveProcessorMask: *mut u8,\n+            dwNumberOfProcessors: u32,\n+            dwProcessorType: u32,\n+            dwAllocationGranularity: u32,\n+            wProcessorLevel: u16,\n+            wProcessorRevision: u16,\n+        }\n+        extern \"system\" {\n+            fn GetSystemInfo(info: *mut SYSTEM_INFO) -> i32;\n+        }\n+        unsafe {\n+            let mut sysinfo = std::mem::zeroed();\n+            GetSystemInfo(&mut sysinfo);\n+            sysinfo.dwNumberOfProcessors as usize\n+        }\n+    }\n+\n+    #[cfg(target_os = \"redox\")]\n+    fn num_cpus() -> usize {\n+        // FIXME: Implement num_cpus on Redox\n+        1\n+    }\n+\n+    #[cfg(any(\n+        all(target_arch = \"wasm32\", not(target_os = \"emscripten\")),\n+        all(target_vendor = \"fortanix\", target_env = \"sgx\")\n+    ))]\n+    fn num_cpus() -> usize {\n+        1\n+    }\n+\n+    #[cfg(any(\n+        target_os = \"android\",\n+        target_os = \"cloudabi\",\n+        target_os = \"emscripten\",\n+        target_os = \"fuchsia\",\n+        target_os = \"ios\",\n+        target_os = \"linux\",\n+        target_os = \"macos\",\n+        target_os = \"solaris\"\n+    ))]\n+    fn num_cpus() -> usize {\n+        unsafe { libc::sysconf(libc::_SC_NPROCESSORS_ONLN) as usize }\n+    }\n+\n+    #[cfg(any(\n+        target_os = \"freebsd\",\n+        target_os = \"dragonfly\",\n+        target_os = \"bitrig\",\n+        target_os = \"netbsd\"\n+    ))]\n+    fn num_cpus() -> usize {\n+        use std::ptr;\n+\n+        let mut cpus: libc::c_uint = 0;\n+        let mut cpus_size = std::mem::size_of_val(&cpus);\n+\n+        unsafe {\n+            cpus = libc::sysconf(libc::_SC_NPROCESSORS_ONLN) as libc::c_uint;\n+        }\n+        if cpus < 1 {\n+            let mut mib = [libc::CTL_HW, libc::HW_NCPU, 0, 0];\n+            unsafe {\n+                libc::sysctl(\n+                    mib.as_mut_ptr(),\n+                    2,\n+                    &mut cpus as *mut _ as *mut _,\n+                    &mut cpus_size as *mut _ as *mut _,\n+                    ptr::null_mut(),\n+                    0,\n+                );\n+            }\n+            if cpus < 1 {\n+                cpus = 1;\n+            }\n+        }\n+        cpus as usize\n+    }\n+\n+    #[cfg(target_os = \"openbsd\")]\n+    fn num_cpus() -> usize {\n+        use std::ptr;\n+\n+        let mut cpus: libc::c_uint = 0;\n+        let mut cpus_size = std::mem::size_of_val(&cpus);\n+        let mut mib = [libc::CTL_HW, libc::HW_NCPU, 0, 0];\n+\n+        unsafe {\n+            libc::sysctl(\n+                mib.as_mut_ptr(),\n+                2,\n+                &mut cpus as *mut _ as *mut _,\n+                &mut cpus_size as *mut _ as *mut _,\n+                ptr::null_mut(),\n+                0,\n+            );\n+        }\n+        if cpus < 1 {\n+            cpus = 1;\n+        }\n+        cpus as usize\n+    }\n+\n+    #[cfg(target_os = \"haiku\")]\n+    fn num_cpus() -> usize {\n+        // FIXME: implement\n+        1\n+    }\n+\n+    #[cfg(target_os = \"l4re\")]\n+    fn num_cpus() -> usize {\n+        // FIXME: implement\n+        1\n+    }\n+}\n+\n+pub fn filter_tests(opts: &TestOpts, tests: Vec<TestDescAndFn>) -> Vec<TestDescAndFn> {\n+    let mut filtered = tests;\n+    let matches_filter = |test: &TestDescAndFn, filter: &str| {\n+        let test_name = test.desc.name.as_slice();\n+\n+        match opts.filter_exact {\n+            true => test_name == filter,\n+            false => test_name.contains(filter),\n+        }\n+    };\n+\n+    // Remove tests that don't match the test filter\n+    if let Some(ref filter) = opts.filter {\n+        filtered.retain(|test| matches_filter(test, filter));\n+    }\n+\n+    // Skip tests that match any of the skip filters\n+    filtered.retain(|test| !opts.skip.iter().any(|sf| matches_filter(test, sf)));\n+\n+    // Excludes #[should_panic] tests\n+    if opts.exclude_should_panic {\n+        filtered.retain(|test| test.desc.should_panic == ShouldPanic::No);\n+    }\n+\n+    // maybe unignore tests\n+    match opts.run_ignored {\n+        RunIgnored::Yes => {\n+            filtered\n+                .iter_mut()\n+                .for_each(|test| test.desc.ignore = false);\n+        }\n+        RunIgnored::Only => {\n+            filtered.retain(|test| test.desc.ignore);\n+            filtered\n+                .iter_mut()\n+                .for_each(|test| test.desc.ignore = false);\n+        }\n+        RunIgnored::No => {}\n+    }\n+\n+    // Sort the tests alphabetically\n+    filtered.sort_by(|t1, t2| t1.desc.name.as_slice().cmp(t2.desc.name.as_slice()));\n+\n+    filtered\n+}\n+\n+pub fn convert_benchmarks_to_tests(tests: Vec<TestDescAndFn>) -> Vec<TestDescAndFn> {\n+    // convert benchmarks to tests, if we're not benchmarking them\n+    tests\n+        .into_iter()\n+        .map(|x| {\n+            let testfn = match x.testfn {\n+                DynBenchFn(bench) => DynTestFn(Box::new(move || {\n+                    bench::run_once(|b| __rust_begin_short_backtrace(|| bench.run(b)))\n+                })),\n+                StaticBenchFn(benchfn) => DynTestFn(Box::new(move || {\n+                    bench::run_once(|b| __rust_begin_short_backtrace(|| benchfn(b)))\n+                })),\n+                f => f,\n+            };\n+            TestDescAndFn {\n+                desc: x.desc,\n+                testfn,\n+            }\n+        })\n+        .collect()\n+}\n+\n+pub fn run_test(\n+    opts: &TestOpts,\n+    force_ignore: bool,\n+    test: TestDescAndFn,\n+    monitor_ch: Sender<MonitorMsg>,\n+    concurrency: Concurrent,\n+) {\n+    let TestDescAndFn { desc, testfn } = test;\n+\n+    let ignore_because_panic_abort = cfg!(target_arch = \"wasm32\")\n+        && !cfg!(target_os = \"emscripten\")\n+        && desc.should_panic != ShouldPanic::No;\n+\n+    if force_ignore || desc.ignore || ignore_because_panic_abort {\n+        monitor_ch.send((desc, TrIgnored, Vec::new())).unwrap();\n+        return;\n+    }\n+\n+    fn run_test_inner(\n+        desc: TestDesc,\n+        monitor_ch: Sender<MonitorMsg>,\n+        nocapture: bool,\n+        testfn: Box<dyn FnBox() + Send>,\n+        concurrency: Concurrent,\n+    ) {\n+        // Buffer for capturing standard I/O\n+        let data = Arc::new(Mutex::new(Vec::new()));\n+        let data2 = data.clone();\n+\n+        let name = desc.name.clone();\n+        let runtest = move || {\n+            let oldio = if !nocapture {\n+                Some((\n+                    io::set_print(Some(Box::new(Sink(data2.clone())))),\n+                    io::set_panic(Some(Box::new(Sink(data2)))),\n+                ))\n+            } else {\n+                None\n+            };\n+\n+            let result = catch_unwind(AssertUnwindSafe(testfn));\n+\n+            if let Some((printio, panicio)) = oldio {\n+                io::set_print(printio);\n+                io::set_panic(panicio);\n+            };\n+\n+            let test_result = calc_result(&desc, result);\n+            let stdout = data.lock().unwrap().to_vec();\n+            monitor_ch\n+                .send((desc.clone(), test_result, stdout))\n+                .unwrap();\n+        };\n+\n+        // If the platform is single-threaded we're just going to run\n+        // the test synchronously, regardless of the concurrency\n+        // level.\n+        let supports_threads = !cfg!(target_os = \"emscripten\") && !cfg!(target_arch = \"wasm32\");\n+        if concurrency == Concurrent::Yes && supports_threads {\n+            let cfg = thread::Builder::new().name(name.as_slice().to_owned());\n+            cfg.spawn(runtest).unwrap();\n+        } else {\n+            runtest();\n+        }\n+    }\n+\n+    match testfn {\n+        DynBenchFn(bencher) => {\n+            crate::bench::benchmark(desc, monitor_ch, opts.nocapture, |harness| {\n+                bencher.run(harness)\n+            });\n+        }\n+        StaticBenchFn(benchfn) => {\n+            crate::bench::benchmark(desc, monitor_ch, opts.nocapture, |harness| {\n+                (benchfn.clone())(harness)\n+            });\n+        }\n+        DynTestFn(f) => {\n+            let cb = move || __rust_begin_short_backtrace(f);\n+            run_test_inner(desc, monitor_ch, opts.nocapture, Box::new(cb), concurrency)\n+        }\n+        StaticTestFn(f) => run_test_inner(\n+            desc,\n+            monitor_ch,\n+            opts.nocapture,\n+            Box::new(move || __rust_begin_short_backtrace(f)),\n+            concurrency,\n+        ),\n+    }\n+}\n+\n+/// Fixed frame used to clean the backtrace with `RUST_BACKTRACE=1`.\n+#[inline(never)]\n+fn __rust_begin_short_backtrace<F: FnOnce()>(f: F) {\n+    f()\n+}\n+\n+fn calc_result(desc: &TestDesc, task_result: Result<(), Box<dyn Any + Send>>) -> TestResult {\n+    match (&desc.should_panic, task_result) {\n+        (&ShouldPanic::No, Ok(())) | (&ShouldPanic::Yes, Err(_)) => TrOk,\n+        (&ShouldPanic::YesWithMessage(msg), Err(ref err)) => {\n+            if err\n+                .downcast_ref::<String>()\n+                .map(|e| &**e)\n+                .or_else(|| err.downcast_ref::<&'static str>().map(|e| *e))\n+                .map(|e| e.contains(msg))\n+                .unwrap_or(false)\n+            {\n+                TrOk\n+            } else {\n+                if desc.allow_fail {\n+                    TrAllowedFail\n+                } else {\n+                    TrFailedMsg(format!(\"Panic did not include expected string '{}'\", msg))\n+                }\n+            }\n+        }\n+        _ if desc.allow_fail => TrAllowedFail,\n+        _ => TrFailed,\n+    }\n+}\n+\n+#[derive(Clone, PartialEq)]\n+pub struct MetricMap(BTreeMap<String, Metric>);\n+\n+impl MetricMap {\n+    pub fn new() -> MetricMap {\n+        MetricMap(BTreeMap::new())\n+    }\n+\n+    /// Insert a named `value` (+/- `noise`) metric into the map. The value\n+    /// must be non-negative. The `noise` indicates the uncertainty of the\n+    /// metric, which doubles as the \"noise range\" of acceptable\n+    /// pairwise-regressions on this named value, when comparing from one\n+    /// metric to the next using `compare_to_old`.\n+    ///\n+    /// If `noise` is positive, then it means this metric is of a value\n+    /// you want to see grow smaller, so a change larger than `noise` in the\n+    /// positive direction represents a regression.\n+    ///\n+    /// If `noise` is negative, then it means this metric is of a value\n+    /// you want to see grow larger, so a change larger than `noise` in the\n+    /// negative direction represents a regression.\n+    pub fn insert_metric(&mut self, name: &str, value: f64, noise: f64) {\n+        let m = Metric { value, noise };\n+        self.0.insert(name.to_owned(), m);\n+    }\n+\n+    pub fn fmt_metrics(&self) -> String {\n+        let v = self\n+            .0\n+            .iter()\n+            .map(|(k, v)| format!(\"{}: {} (+/- {})\", *k, v.value, v.noise))\n+            .collect::<Vec<_>>();\n+        v.join(\", \")\n+    }\n+}\n+\n+// Benchmarking\n \n pub use std::hint::black_box;\n \n+impl Bencher {\n+    /// Callback for benchmark functions to run in their body.\n+    pub fn iter<T, F>(&mut self, mut inner: F)\n+    where\n+        F: FnMut() -> T,\n+    {\n+        if self.mode == BenchMode::Single {\n+            ns_iter_inner(&mut inner, 1);\n+            return;\n+        }\n+\n+        self.summary = Some(iter(&mut inner));\n+    }\n+\n+    pub fn bench<F>(&mut self, mut f: F) -> Option<stats::Summary>\n+    where\n+        F: FnMut(&mut Bencher),\n+    {\n+        f(self);\n+        return self.summary;\n+    }\n+}\n+\n+fn ns_from_dur(dur: Duration) -> u64 {\n+    dur.as_secs() * 1_000_000_000 + (dur.subsec_nanos() as u64)\n+}\n+\n+fn ns_iter_inner<T, F>(inner: &mut F, k: u64) -> u64\n+where\n+    F: FnMut() -> T,\n+{\n+    let start = Instant::now();\n+    for _ in 0..k {\n+        black_box(inner());\n+    }\n+    return ns_from_dur(start.elapsed());\n+}\n+\n+pub fn iter<T, F>(inner: &mut F) -> stats::Summary\n+where\n+    F: FnMut() -> T,\n+{\n+    // Initial bench run to get ballpark figure.\n+    let ns_single = ns_iter_inner(inner, 1);\n+\n+    // Try to estimate iter count for 1ms falling back to 1m\n+    // iterations if first run took < 1ns.\n+    let ns_target_total = 1_000_000; // 1ms\n+    let mut n = ns_target_total / cmp::max(1, ns_single);\n+\n+    // if the first run took more than 1ms we don't want to just\n+    // be left doing 0 iterations on every loop. The unfortunate\n+    // side effect of not being able to do as many runs is\n+    // automatically handled by the statistical analysis below\n+    // (i.e., larger error bars).\n+    n = cmp::max(1, n);\n+\n+    let mut total_run = Duration::new(0, 0);\n+    let samples: &mut [f64] = &mut [0.0_f64; 50];\n+    loop {\n+        let loop_start = Instant::now();\n+\n+        for p in &mut *samples {\n+            *p = ns_iter_inner(inner, n) as f64 / n as f64;\n+        }\n+\n+        stats::winsorize(samples, 5.0);\n+        let summ = stats::Summary::new(samples);\n+\n+        for p in &mut *samples {\n+            let ns = ns_iter_inner(inner, 5 * n);\n+            *p = ns as f64 / (5 * n) as f64;\n+        }\n+\n+        stats::winsorize(samples, 5.0);\n+        let summ5 = stats::Summary::new(samples);\n+\n+        let loop_run = loop_start.elapsed();\n+\n+        // If we've run for 100ms and seem to have converged to a\n+        // stable median.\n+        if loop_run > Duration::from_millis(100)\n+            && summ.median_abs_dev_pct < 1.0\n+            && summ.median - summ5.median < summ5.median_abs_dev\n+        {\n+            return summ5;\n+        }\n+\n+        total_run = total_run + loop_run;\n+        // Longest we ever run for is 3s.\n+        if total_run > Duration::from_secs(3) {\n+            return summ5;\n+        }\n+\n+        // If we overflow here just return the results so far. We check a\n+        // multiplier of 10 because we're about to multiply by 2 and the\n+        // next iteration of the loop will also multiply by 5 (to calculate\n+        // the summ5 result)\n+        n = match n.checked_mul(10) {\n+            Some(_) => n * 2,\n+            None => {\n+                return summ5;\n+            }\n+        };\n+    }\n+}\n+\n+pub mod bench {\n+    use super::{BenchMode, BenchSamples, Bencher, MonitorMsg, Sender, Sink, TestDesc, TestResult};\n+    use crate::stats;\n+    use std::cmp;\n+    use std::io;\n+    use std::panic::{catch_unwind, AssertUnwindSafe};\n+    use std::sync::{Arc, Mutex};\n+\n+    pub fn benchmark<F>(desc: TestDesc, monitor_ch: Sender<MonitorMsg>, nocapture: bool, f: F)\n+    where\n+        F: FnMut(&mut Bencher),\n+    {\n+        let mut bs = Bencher {\n+            mode: BenchMode::Auto,\n+            summary: None,\n+            bytes: 0,\n+        };\n+\n+        let data = Arc::new(Mutex::new(Vec::new()));\n+        let data2 = data.clone();\n+\n+        let oldio = if !nocapture {\n+            Some((\n+                io::set_print(Some(Box::new(Sink(data2.clone())))),\n+                io::set_panic(Some(Box::new(Sink(data2)))),\n+            ))\n+        } else {\n+            None\n+        };\n+\n+        let result = catch_unwind(AssertUnwindSafe(|| bs.bench(f)));\n+\n+        if let Some((printio, panicio)) = oldio {\n+            io::set_print(printio);\n+            io::set_panic(panicio);\n+        };\n+\n+        let test_result = match result {\n+            //bs.bench(f) {\n+            Ok(Some(ns_iter_summ)) => {\n+                let ns_iter = cmp::max(ns_iter_summ.median as u64, 1);\n+                let mb_s = bs.bytes * 1000 / ns_iter;\n+\n+                let bs = BenchSamples {\n+                    ns_iter_summ,\n+                    mb_s: mb_s as usize,\n+                };\n+                TestResult::TrBench(bs)\n+            }\n+            Ok(None) => {\n+                // iter not called, so no data.\n+                // FIXME: error in this case?\n+                let samples: &mut [f64] = &mut [0.0_f64; 1];\n+                let bs = BenchSamples {\n+                    ns_iter_summ: stats::Summary::new(samples),\n+                    mb_s: 0,\n+                };\n+                TestResult::TrBench(bs)\n+            }\n+            Err(_) => TestResult::TrFailed,\n+        };\n+\n+        let stdout = data.lock().unwrap().to_vec();\n+        monitor_ch.send((desc, test_result, stdout)).unwrap();\n+    }\n+\n+    pub fn run_once<F>(f: F)\n+    where\n+        F: FnMut(&mut Bencher),\n+    {\n+        let mut bs = Bencher {\n+            mode: BenchMode::Single,\n+            summary: None,\n+            bytes: 0,\n+        };\n+        bs.bench(f);\n+    }\n+}\n+\n #[cfg(test)]\n mod tests {\n+    use crate::bench;\n+    use crate::test::{\n+        filter_tests, parse_opts, run_test, DynTestFn, DynTestName, MetricMap, RunIgnored,\n+        ShouldPanic, StaticTestName, TestDesc, TestDescAndFn, TestOpts, TrFailed, TrFailedMsg,\n+        TrIgnored, TrOk,\n+    };\n     use crate::Bencher;\n-    use libtest::stats::Stats;\n+    use crate::Concurrent;\n+    use std::sync::mpsc::channel;\n \n-    #[bench]\n-    pub fn sum_three_items(b: &mut Bencher) {\n-        b.iter(|| {\n-            [1e20f64, 1.5f64, -1e20f64].sum();\n-        })\n+    fn one_ignored_one_unignored_test() -> Vec<TestDescAndFn> {\n+        vec![\n+            TestDescAndFn {\n+                desc: TestDesc {\n+                    name: StaticTestName(\"1\"),\n+                    ignore: true,\n+                    should_panic: ShouldPanic::No,\n+                    allow_fail: false,\n+                },\n+                testfn: DynTestFn(Box::new(move || {})),\n+            },\n+            TestDescAndFn {\n+                desc: TestDesc {\n+                    name: StaticTestName(\"2\"),\n+                    ignore: false,\n+                    should_panic: ShouldPanic::No,\n+                    allow_fail: false,\n+                },\n+                testfn: DynTestFn(Box::new(move || {})),\n+            },\n+        ]\n     }\n \n-    #[bench]\n-    pub fn sum_many_f64(b: &mut Bencher) {\n-        let nums = [-1e30f64, 1e60, 1e30, 1.0, -1e60];\n-        let v = (0..500).map(|i| nums[i % 5]).collect::<Vec<_>>();\n-        b.iter(|| {\n-            v.sum();\n-        })\n+    #[test]\n+    pub fn do_not_run_ignored_tests() {\n+        fn f() {\n+            panic!();\n+        }\n+        let desc = TestDescAndFn {\n+            desc: TestDesc {\n+                name: StaticTestName(\"whatever\"),\n+                ignore: true,\n+                should_panic: ShouldPanic::No,\n+                allow_fail: false,\n+            },\n+            testfn: DynTestFn(Box::new(f)),\n+        };\n+        let (tx, rx) = channel();\n+        run_test(&TestOpts::new(), false, desc, tx, Concurrent::No);\n+        let (_, res, _) = rx.recv().unwrap();\n+        assert!(res != TrOk);\n+    }\n+\n+    #[test]\n+    pub fn ignored_tests_result_in_ignored() {\n+        fn f() {}\n+        let desc = TestDescAndFn {\n+            desc: TestDesc {\n+                name: StaticTestName(\"whatever\"),\n+                ignore: true,\n+                should_panic: ShouldPanic::No,\n+                allow_fail: false,\n+            },\n+            testfn: DynTestFn(Box::new(f)),\n+        };\n+        let (tx, rx) = channel();\n+        run_test(&TestOpts::new(), false, desc, tx, Concurrent::No);\n+        let (_, res, _) = rx.recv().unwrap();\n+        assert!(res == TrIgnored);\n+    }\n+\n+    #[test]\n+    fn test_should_panic() {\n+        fn f() {\n+            panic!();\n+        }\n+        let desc = TestDescAndFn {\n+            desc: TestDesc {\n+                name: StaticTestName(\"whatever\"),\n+                ignore: false,\n+                should_panic: ShouldPanic::Yes,\n+                allow_fail: false,\n+            },\n+            testfn: DynTestFn(Box::new(f)),\n+        };\n+        let (tx, rx) = channel();\n+        run_test(&TestOpts::new(), false, desc, tx, Concurrent::No);\n+        let (_, res, _) = rx.recv().unwrap();\n+        assert!(res == TrOk);\n+    }\n+\n+    #[test]\n+    fn test_should_panic_good_message() {\n+        fn f() {\n+            panic!(\"an error message\");\n+        }\n+        let desc = TestDescAndFn {\n+            desc: TestDesc {\n+                name: StaticTestName(\"whatever\"),\n+                ignore: false,\n+                should_panic: ShouldPanic::YesWithMessage(\"error message\"),\n+                allow_fail: false,\n+            },\n+            testfn: DynTestFn(Box::new(f)),\n+        };\n+        let (tx, rx) = channel();\n+        run_test(&TestOpts::new(), false, desc, tx, Concurrent::No);\n+        let (_, res, _) = rx.recv().unwrap();\n+        assert!(res == TrOk);\n+    }\n+\n+    #[test]\n+    fn test_should_panic_bad_message() {\n+        fn f() {\n+            panic!(\"an error message\");\n+        }\n+        let expected = \"foobar\";\n+        let failed_msg = \"Panic did not include expected string\";\n+        let desc = TestDescAndFn {\n+            desc: TestDesc {\n+                name: StaticTestName(\"whatever\"),\n+                ignore: false,\n+                should_panic: ShouldPanic::YesWithMessage(expected),\n+                allow_fail: false,\n+            },\n+            testfn: DynTestFn(Box::new(f)),\n+        };\n+        let (tx, rx) = channel();\n+        run_test(&TestOpts::new(), false, desc, tx, Concurrent::No);\n+        let (_, res, _) = rx.recv().unwrap();\n+        assert!(res == TrFailedMsg(format!(\"{} '{}'\", failed_msg, expected)));\n+    }\n+\n+    #[test]\n+    fn test_should_panic_but_succeeds() {\n+        fn f() {}\n+        let desc = TestDescAndFn {\n+            desc: TestDesc {\n+                name: StaticTestName(\"whatever\"),\n+                ignore: false,\n+                should_panic: ShouldPanic::Yes,\n+                allow_fail: false,\n+            },\n+            testfn: DynTestFn(Box::new(f)),\n+        };\n+        let (tx, rx) = channel();\n+        run_test(&TestOpts::new(), false, desc, tx, Concurrent::No);\n+        let (_, res, _) = rx.recv().unwrap();\n+        assert!(res == TrFailed);\n+    }\n+\n+    #[test]\n+    fn parse_ignored_flag() {\n+        let args = vec![\n+            \"progname\".to_string(),\n+            \"filter\".to_string(),\n+            \"--ignored\".to_string(),\n+        ];\n+        let opts = parse_opts(&args).unwrap().unwrap();\n+        assert_eq!(opts.run_ignored, RunIgnored::Only);\n+    }\n+\n+    #[test]\n+    fn parse_include_ignored_flag() {\n+        let args = vec![\n+            \"progname\".to_string(),\n+            \"filter\".to_string(),\n+            \"-Zunstable-options\".to_string(),\n+            \"--include-ignored\".to_string(),\n+        ];\n+        let opts = parse_opts(&args).unwrap().unwrap();\n+        assert_eq!(opts.run_ignored, RunIgnored::Yes);\n+    }\n+\n+    #[test]\n+    pub fn filter_for_ignored_option() {\n+        // When we run ignored tests the test filter should filter out all the\n+        // unignored tests and flip the ignore flag on the rest to false\n+\n+        let mut opts = TestOpts::new();\n+        opts.run_tests = true;\n+        opts.run_ignored = RunIgnored::Only;\n+\n+        let tests = one_ignored_one_unignored_test();\n+        let filtered = filter_tests(&opts, tests);\n+\n+        assert_eq!(filtered.len(), 1);\n+        assert_eq!(filtered[0].desc.name.to_string(), \"1\");\n+        assert!(!filtered[0].desc.ignore);\n     }\n \n-    #[bench]\n-    pub fn no_iter(_: &mut Bencher) {}\n+    #[test]\n+    pub fn run_include_ignored_option() {\n+        // When we \"--include-ignored\" tests, the ignore flag should be set to false on\n+        // all tests and no test filtered out\n+\n+        let mut opts = TestOpts::new();\n+        opts.run_tests = true;\n+        opts.run_ignored = RunIgnored::Yes;\n+\n+        let tests = one_ignored_one_unignored_test();\n+        let filtered = filter_tests(&opts, tests);\n+\n+        assert_eq!(filtered.len(), 2);\n+        assert!(!filtered[0].desc.ignore);\n+        assert!(!filtered[1].desc.ignore);\n+    }\n+\n+    #[test]\n+    pub fn exclude_should_panic_option() {\n+        let mut opts = TestOpts::new();\n+        opts.run_tests = true;\n+        opts.exclude_should_panic = true;\n+\n+        let mut tests = one_ignored_one_unignored_test();\n+        tests.push(TestDescAndFn {\n+            desc: TestDesc {\n+                name: StaticTestName(\"3\"),\n+                ignore: false,\n+                should_panic: ShouldPanic::Yes,\n+                allow_fail: false,\n+            },\n+            testfn: DynTestFn(Box::new(move || {})),\n+        });\n+\n+        let filtered = filter_tests(&opts, tests);\n+\n+        assert_eq!(filtered.len(), 2);\n+        assert!(filtered.iter().all(|test| test.desc.should_panic == ShouldPanic::No));\n+    }\n+\n+    #[test]\n+    pub fn exact_filter_match() {\n+        fn tests() -> Vec<TestDescAndFn> {\n+            vec![\"base\", \"base::test\", \"base::test1\", \"base::test2\"]\n+                .into_iter()\n+                .map(|name| TestDescAndFn {\n+                    desc: TestDesc {\n+                        name: StaticTestName(name),\n+                        ignore: false,\n+                        should_panic: ShouldPanic::No,\n+                        allow_fail: false,\n+                    },\n+                    testfn: DynTestFn(Box::new(move || {})),\n+                })\n+                .collect()\n+        }\n+\n+        let substr = filter_tests(\n+            &TestOpts {\n+                filter: Some(\"base\".into()),\n+                ..TestOpts::new()\n+            },\n+            tests(),\n+        );\n+        assert_eq!(substr.len(), 4);\n+\n+        let substr = filter_tests(\n+            &TestOpts {\n+                filter: Some(\"bas\".into()),\n+                ..TestOpts::new()\n+            },\n+            tests(),\n+        );\n+        assert_eq!(substr.len(), 4);\n+\n+        let substr = filter_tests(\n+            &TestOpts {\n+                filter: Some(\"::test\".into()),\n+                ..TestOpts::new()\n+            },\n+            tests(),\n+        );\n+        assert_eq!(substr.len(), 3);\n+\n+        let substr = filter_tests(\n+            &TestOpts {\n+                filter: Some(\"base::test\".into()),\n+                ..TestOpts::new()\n+            },\n+            tests(),\n+        );\n+        assert_eq!(substr.len(), 3);\n+\n+        let exact = filter_tests(\n+            &TestOpts {\n+                filter: Some(\"base\".into()),\n+                filter_exact: true,\n+                ..TestOpts::new()\n+            },\n+            tests(),\n+        );\n+        assert_eq!(exact.len(), 1);\n+\n+        let exact = filter_tests(\n+            &TestOpts {\n+                filter: Some(\"bas\".into()),\n+                filter_exact: true,\n+                ..TestOpts::new()\n+            },\n+            tests(),\n+        );\n+        assert_eq!(exact.len(), 0);\n+\n+        let exact = filter_tests(\n+            &TestOpts {\n+                filter: Some(\"::test\".into()),\n+                filter_exact: true,\n+                ..TestOpts::new()\n+            },\n+            tests(),\n+        );\n+        assert_eq!(exact.len(), 0);\n+\n+        let exact = filter_tests(\n+            &TestOpts {\n+                filter: Some(\"base::test\".into()),\n+                filter_exact: true,\n+                ..TestOpts::new()\n+            },\n+            tests(),\n+        );\n+        assert_eq!(exact.len(), 1);\n+    }\n+\n+    #[test]\n+    pub fn sort_tests() {\n+        let mut opts = TestOpts::new();\n+        opts.run_tests = true;\n+\n+        let names = vec![\n+            \"sha1::test\".to_string(),\n+            \"isize::test_to_str\".to_string(),\n+            \"isize::test_pow\".to_string(),\n+            \"test::do_not_run_ignored_tests\".to_string(),\n+            \"test::ignored_tests_result_in_ignored\".to_string(),\n+            \"test::first_free_arg_should_be_a_filter\".to_string(),\n+            \"test::parse_ignored_flag\".to_string(),\n+            \"test::parse_include_ignored_flag\".to_string(),\n+            \"test::filter_for_ignored_option\".to_string(),\n+            \"test::run_include_ignored_option\".to_string(),\n+            \"test::sort_tests\".to_string(),\n+        ];\n+        let tests = {\n+            fn testfn() {}\n+            let mut tests = Vec::new();\n+            for name in &names {\n+                let test = TestDescAndFn {\n+                    desc: TestDesc {\n+                        name: DynTestName((*name).clone()),\n+                        ignore: false,\n+                        should_panic: ShouldPanic::No,\n+                        allow_fail: false,\n+                    },\n+                    testfn: DynTestFn(Box::new(testfn)),\n+                };\n+                tests.push(test);\n+            }\n+            tests\n+        };\n+        let filtered = filter_tests(&opts, tests);\n+\n+        let expected = vec![\n+            \"isize::test_pow\".to_string(),\n+            \"isize::test_to_str\".to_string(),\n+            \"sha1::test\".to_string(),\n+            \"test::do_not_run_ignored_tests\".to_string(),\n+            \"test::filter_for_ignored_option\".to_string(),\n+            \"test::first_free_arg_should_be_a_filter\".to_string(),\n+            \"test::ignored_tests_result_in_ignored\".to_string(),\n+            \"test::parse_ignored_flag\".to_string(),\n+            \"test::parse_include_ignored_flag\".to_string(),\n+            \"test::run_include_ignored_option\".to_string(),\n+            \"test::sort_tests\".to_string(),\n+        ];\n+\n+        for (a, b) in expected.iter().zip(filtered) {\n+            assert!(*a == b.desc.name.to_string());\n+        }\n+    }\n+\n+    #[test]\n+    pub fn test_metricmap_compare() {\n+        let mut m1 = MetricMap::new();\n+        let mut m2 = MetricMap::new();\n+        m1.insert_metric(\"in-both-noise\", 1000.0, 200.0);\n+        m2.insert_metric(\"in-both-noise\", 1100.0, 200.0);\n+\n+        m1.insert_metric(\"in-first-noise\", 1000.0, 2.0);\n+        m2.insert_metric(\"in-second-noise\", 1000.0, 2.0);\n+\n+        m1.insert_metric(\"in-both-want-downwards-but-regressed\", 1000.0, 10.0);\n+        m2.insert_metric(\"in-both-want-downwards-but-regressed\", 2000.0, 10.0);\n+\n+        m1.insert_metric(\"in-both-want-downwards-and-improved\", 2000.0, 10.0);\n+        m2.insert_metric(\"in-both-want-downwards-and-improved\", 1000.0, 10.0);\n+\n+        m1.insert_metric(\"in-both-want-upwards-but-regressed\", 2000.0, -10.0);\n+        m2.insert_metric(\"in-both-want-upwards-but-regressed\", 1000.0, -10.0);\n+\n+        m1.insert_metric(\"in-both-want-upwards-and-improved\", 1000.0, -10.0);\n+        m2.insert_metric(\"in-both-want-upwards-and-improved\", 2000.0, -10.0);\n+    }\n+\n+    #[test]\n+    pub fn test_bench_once_no_iter() {\n+        fn f(_: &mut Bencher) {}\n+        bench::run_once(f);\n+    }\n+\n+    #[test]\n+    pub fn test_bench_once_iter() {\n+        fn f(b: &mut Bencher) {\n+            b.iter(|| {})\n+        }\n+        bench::run_once(f);\n+    }\n+\n+    #[test]\n+    pub fn test_bench_no_iter() {\n+        fn f(_: &mut Bencher) {}\n+\n+        let (tx, rx) = channel();\n+\n+        let desc = TestDesc {\n+            name: StaticTestName(\"f\"),\n+            ignore: false,\n+            should_panic: ShouldPanic::No,\n+            allow_fail: false,\n+        };\n+\n+        crate::bench::benchmark(desc, tx, true, f);\n+        rx.recv().unwrap();\n+    }\n+\n+    #[test]\n+    pub fn test_bench_iter() {\n+        fn f(b: &mut Bencher) {\n+            b.iter(|| {})\n+        }\n+\n+        let (tx, rx) = channel();\n+\n+        let desc = TestDesc {\n+            name: StaticTestName(\"f\"),\n+            ignore: false,\n+            should_panic: ShouldPanic::No,\n+            allow_fail: false,\n+        };\n+\n+        crate::bench::benchmark(desc, tx, true, f);\n+        rx.recv().unwrap();\n+    }\n }"}, {"sha": "5c9421d5ea4b023089049f6e23529af7a2ddf165", "filename": "src/libtest/stats.rs", "status": "added", "additions": 922, "deletions": 0, "changes": 922, "blob_url": "https://github.com/rust-lang/rust/blob/28ea249ab526c6b114c4dc9ba311fc62fccb28e2/src%2Flibtest%2Fstats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/28ea249ab526c6b114c4dc9ba311fc62fccb28e2/src%2Flibtest%2Fstats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibtest%2Fstats.rs?ref=28ea249ab526c6b114c4dc9ba311fc62fccb28e2", "patch": "@@ -0,0 +1,922 @@\n+#![allow(missing_docs)]\n+#![allow(deprecated)] // Float\n+\n+use std::cmp::Ordering::{self, Equal, Greater, Less};\n+use std::mem;\n+\n+fn local_cmp(x: f64, y: f64) -> Ordering {\n+    // arbitrarily decide that NaNs are larger than everything.\n+    if y.is_nan() {\n+        Less\n+    } else if x.is_nan() {\n+        Greater\n+    } else if x < y {\n+        Less\n+    } else if x == y {\n+        Equal\n+    } else {\n+        Greater\n+    }\n+}\n+\n+fn local_sort(v: &mut [f64]) {\n+    v.sort_by(|x: &f64, y: &f64| local_cmp(*x, *y));\n+}\n+\n+/// Trait that provides simple descriptive statistics on a univariate set of numeric samples.\n+pub trait Stats {\n+    /// Sum of the samples.\n+    ///\n+    /// Note: this method sacrifices performance at the altar of accuracy\n+    /// Depends on IEEE-754 arithmetic guarantees. See proof of correctness at:\n+    /// [\"Adaptive Precision Floating-Point Arithmetic and Fast Robust Geometric\n+    /// Predicates\"][paper]\n+    ///\n+    /// [paper]: http://www.cs.cmu.edu/~quake-papers/robust-arithmetic.ps\n+    fn sum(&self) -> f64;\n+\n+    /// Minimum value of the samples.\n+    fn min(&self) -> f64;\n+\n+    /// Maximum value of the samples.\n+    fn max(&self) -> f64;\n+\n+    /// Arithmetic mean (average) of the samples: sum divided by sample-count.\n+    ///\n+    /// See: <https://en.wikipedia.org/wiki/Arithmetic_mean>\n+    fn mean(&self) -> f64;\n+\n+    /// Median of the samples: value separating the lower half of the samples from the higher half.\n+    /// Equal to `self.percentile(50.0)`.\n+    ///\n+    /// See: <https://en.wikipedia.org/wiki/Median>\n+    fn median(&self) -> f64;\n+\n+    /// Variance of the samples: bias-corrected mean of the squares of the differences of each\n+    /// sample from the sample mean. Note that this calculates the _sample variance_ rather than the\n+    /// population variance, which is assumed to be unknown. It therefore corrects the `(n-1)/n`\n+    /// bias that would appear if we calculated a population variance, by dividing by `(n-1)` rather\n+    /// than `n`.\n+    ///\n+    /// See: <https://en.wikipedia.org/wiki/Variance>\n+    fn var(&self) -> f64;\n+\n+    /// Standard deviation: the square root of the sample variance.\n+    ///\n+    /// Note: this is not a robust statistic for non-normal distributions. Prefer the\n+    /// `median_abs_dev` for unknown distributions.\n+    ///\n+    /// See: <https://en.wikipedia.org/wiki/Standard_deviation>\n+    fn std_dev(&self) -> f64;\n+\n+    /// Standard deviation as a percent of the mean value. See `std_dev` and `mean`.\n+    ///\n+    /// Note: this is not a robust statistic for non-normal distributions. Prefer the\n+    /// `median_abs_dev_pct` for unknown distributions.\n+    fn std_dev_pct(&self) -> f64;\n+\n+    /// Scaled median of the absolute deviations of each sample from the sample median. This is a\n+    /// robust (distribution-agnostic) estimator of sample variability. Use this in preference to\n+    /// `std_dev` if you cannot assume your sample is normally distributed. Note that this is scaled\n+    /// by the constant `1.4826` to allow its use as a consistent estimator for the standard\n+    /// deviation.\n+    ///\n+    /// See: <http://en.wikipedia.org/wiki/Median_absolute_deviation>\n+    fn median_abs_dev(&self) -> f64;\n+\n+    /// Median absolute deviation as a percent of the median. See `median_abs_dev` and `median`.\n+    fn median_abs_dev_pct(&self) -> f64;\n+\n+    /// Percentile: the value below which `pct` percent of the values in `self` fall. For example,\n+    /// percentile(95.0) will return the value `v` such that 95% of the samples `s` in `self`\n+    /// satisfy `s <= v`.\n+    ///\n+    /// Calculated by linear interpolation between closest ranks.\n+    ///\n+    /// See: <http://en.wikipedia.org/wiki/Percentile>\n+    fn percentile(&self, pct: f64) -> f64;\n+\n+    /// Quartiles of the sample: three values that divide the sample into four equal groups, each\n+    /// with 1/4 of the data. The middle value is the median. See `median` and `percentile`. This\n+    /// function may calculate the 3 quartiles more efficiently than 3 calls to `percentile`, but\n+    /// is otherwise equivalent.\n+    ///\n+    /// See also: <https://en.wikipedia.org/wiki/Quartile>\n+    fn quartiles(&self) -> (f64, f64, f64);\n+\n+    /// Inter-quartile range: the difference between the 25th percentile (1st quartile) and the 75th\n+    /// percentile (3rd quartile). See `quartiles`.\n+    ///\n+    /// See also: <https://en.wikipedia.org/wiki/Interquartile_range>\n+    fn iqr(&self) -> f64;\n+}\n+\n+/// Extracted collection of all the summary statistics of a sample set.\n+#[derive(Clone, PartialEq, Copy)]\n+#[allow(missing_docs)]\n+pub struct Summary {\n+    pub sum: f64,\n+    pub min: f64,\n+    pub max: f64,\n+    pub mean: f64,\n+    pub median: f64,\n+    pub var: f64,\n+    pub std_dev: f64,\n+    pub std_dev_pct: f64,\n+    pub median_abs_dev: f64,\n+    pub median_abs_dev_pct: f64,\n+    pub quartiles: (f64, f64, f64),\n+    pub iqr: f64,\n+}\n+\n+impl Summary {\n+    /// Construct a new summary of a sample set.\n+    pub fn new(samples: &[f64]) -> Summary {\n+        Summary {\n+            sum: samples.sum(),\n+            min: samples.min(),\n+            max: samples.max(),\n+            mean: samples.mean(),\n+            median: samples.median(),\n+            var: samples.var(),\n+            std_dev: samples.std_dev(),\n+            std_dev_pct: samples.std_dev_pct(),\n+            median_abs_dev: samples.median_abs_dev(),\n+            median_abs_dev_pct: samples.median_abs_dev_pct(),\n+            quartiles: samples.quartiles(),\n+            iqr: samples.iqr(),\n+        }\n+    }\n+}\n+\n+impl Stats for [f64] {\n+    // FIXME #11059 handle NaN, inf and overflow\n+    fn sum(&self) -> f64 {\n+        let mut partials = vec![];\n+\n+        for &x in self {\n+            let mut x = x;\n+            let mut j = 0;\n+            // This inner loop applies `hi`/`lo` summation to each\n+            // partial so that the list of partial sums remains exact.\n+            for i in 0..partials.len() {\n+                let mut y: f64 = partials[i];\n+                if x.abs() < y.abs() {\n+                    mem::swap(&mut x, &mut y);\n+                }\n+                // Rounded `x+y` is stored in `hi` with round-off stored in\n+                // `lo`. Together `hi+lo` are exactly equal to `x+y`.\n+                let hi = x + y;\n+                let lo = y - (hi - x);\n+                if lo != 0.0 {\n+                    partials[j] = lo;\n+                    j += 1;\n+                }\n+                x = hi;\n+            }\n+            if j >= partials.len() {\n+                partials.push(x);\n+            } else {\n+                partials[j] = x;\n+                partials.truncate(j + 1);\n+            }\n+        }\n+        let zero: f64 = 0.0;\n+        partials.iter().fold(zero, |p, q| p + *q)\n+    }\n+\n+    fn min(&self) -> f64 {\n+        assert!(!self.is_empty());\n+        self.iter().fold(self[0], |p, q| p.min(*q))\n+    }\n+\n+    fn max(&self) -> f64 {\n+        assert!(!self.is_empty());\n+        self.iter().fold(self[0], |p, q| p.max(*q))\n+    }\n+\n+    fn mean(&self) -> f64 {\n+        assert!(!self.is_empty());\n+        self.sum() / (self.len() as f64)\n+    }\n+\n+    fn median(&self) -> f64 {\n+        self.percentile(50 as f64)\n+    }\n+\n+    fn var(&self) -> f64 {\n+        if self.len() < 2 {\n+            0.0\n+        } else {\n+            let mean = self.mean();\n+            let mut v: f64 = 0.0;\n+            for s in self {\n+                let x = *s - mean;\n+                v = v + x * x;\n+            }\n+            // N.B., this is _supposed to be_ len-1, not len. If you\n+            // change it back to len, you will be calculating a\n+            // population variance, not a sample variance.\n+            let denom = (self.len() - 1) as f64;\n+            v / denom\n+        }\n+    }\n+\n+    fn std_dev(&self) -> f64 {\n+        self.var().sqrt()\n+    }\n+\n+    fn std_dev_pct(&self) -> f64 {\n+        let hundred = 100 as f64;\n+        (self.std_dev() / self.mean()) * hundred\n+    }\n+\n+    fn median_abs_dev(&self) -> f64 {\n+        let med = self.median();\n+        let abs_devs: Vec<f64> = self.iter().map(|&v| (med - v).abs()).collect();\n+        // This constant is derived by smarter statistics brains than me, but it is\n+        // consistent with how R and other packages treat the MAD.\n+        let number = 1.4826;\n+        abs_devs.median() * number\n+    }\n+\n+    fn median_abs_dev_pct(&self) -> f64 {\n+        let hundred = 100 as f64;\n+        (self.median_abs_dev() / self.median()) * hundred\n+    }\n+\n+    fn percentile(&self, pct: f64) -> f64 {\n+        let mut tmp = self.to_vec();\n+        local_sort(&mut tmp);\n+        percentile_of_sorted(&tmp, pct)\n+    }\n+\n+    fn quartiles(&self) -> (f64, f64, f64) {\n+        let mut tmp = self.to_vec();\n+        local_sort(&mut tmp);\n+        let first = 25f64;\n+        let a = percentile_of_sorted(&tmp, first);\n+        let second = 50f64;\n+        let b = percentile_of_sorted(&tmp, second);\n+        let third = 75f64;\n+        let c = percentile_of_sorted(&tmp, third);\n+        (a, b, c)\n+    }\n+\n+    fn iqr(&self) -> f64 {\n+        let (a, _, c) = self.quartiles();\n+        c - a\n+    }\n+}\n+\n+// Helper function: extract a value representing the `pct` percentile of a sorted sample-set, using\n+// linear interpolation. If samples are not sorted, return nonsensical value.\n+fn percentile_of_sorted(sorted_samples: &[f64], pct: f64) -> f64 {\n+    assert!(!sorted_samples.is_empty());\n+    if sorted_samples.len() == 1 {\n+        return sorted_samples[0];\n+    }\n+    let zero: f64 = 0.0;\n+    assert!(zero <= pct);\n+    let hundred = 100f64;\n+    assert!(pct <= hundred);\n+    if pct == hundred {\n+        return sorted_samples[sorted_samples.len() - 1];\n+    }\n+    let length = (sorted_samples.len() - 1) as f64;\n+    let rank = (pct / hundred) * length;\n+    let lrank = rank.floor();\n+    let d = rank - lrank;\n+    let n = lrank as usize;\n+    let lo = sorted_samples[n];\n+    let hi = sorted_samples[n + 1];\n+    lo + (hi - lo) * d\n+}\n+\n+/// Winsorize a set of samples, replacing values above the `100-pct` percentile\n+/// and below the `pct` percentile with those percentiles themselves. This is a\n+/// way of minimizing the effect of outliers, at the cost of biasing the sample.\n+/// It differs from trimming in that it does not change the number of samples,\n+/// just changes the values of those that are outliers.\n+///\n+/// See: <http://en.wikipedia.org/wiki/Winsorising>\n+pub fn winsorize(samples: &mut [f64], pct: f64) {\n+    let mut tmp = samples.to_vec();\n+    local_sort(&mut tmp);\n+    let lo = percentile_of_sorted(&tmp, pct);\n+    let hundred = 100 as f64;\n+    let hi = percentile_of_sorted(&tmp, hundred - pct);\n+    for samp in samples {\n+        if *samp > hi {\n+            *samp = hi\n+        } else if *samp < lo {\n+            *samp = lo\n+        }\n+    }\n+}\n+\n+// Test vectors generated from R, using the script src/etc/stat-test-vectors.r.\n+\n+#[cfg(test)]\n+mod tests {\n+    use crate::stats::Stats;\n+    use crate::stats::Summary;\n+    use std::f64;\n+    use std::io::prelude::*;\n+    use std::io;\n+\n+    macro_rules! assert_approx_eq {\n+        ($a: expr, $b: expr) => {{\n+            let (a, b) = (&$a, &$b);\n+            assert!(\n+                (*a - *b).abs() < 1.0e-6,\n+                \"{} is not approximately equal to {}\",\n+                *a,\n+                *b\n+            );\n+        }};\n+    }\n+\n+    fn check(samples: &[f64], summ: &Summary) {\n+        let summ2 = Summary::new(samples);\n+\n+        let mut w = io::sink();\n+        let w = &mut w;\n+        (write!(w, \"\\n\")).unwrap();\n+\n+        assert_eq!(summ.sum, summ2.sum);\n+        assert_eq!(summ.min, summ2.min);\n+        assert_eq!(summ.max, summ2.max);\n+        assert_eq!(summ.mean, summ2.mean);\n+        assert_eq!(summ.median, summ2.median);\n+\n+        // We needed a few more digits to get exact equality on these\n+        // but they're within float epsilon, which is 1.0e-6.\n+        assert_approx_eq!(summ.var, summ2.var);\n+        assert_approx_eq!(summ.std_dev, summ2.std_dev);\n+        assert_approx_eq!(summ.std_dev_pct, summ2.std_dev_pct);\n+        assert_approx_eq!(summ.median_abs_dev, summ2.median_abs_dev);\n+        assert_approx_eq!(summ.median_abs_dev_pct, summ2.median_abs_dev_pct);\n+\n+        assert_eq!(summ.quartiles, summ2.quartiles);\n+        assert_eq!(summ.iqr, summ2.iqr);\n+    }\n+\n+    #[test]\n+    fn test_min_max_nan() {\n+        let xs = &[1.0, 2.0, f64::NAN, 3.0, 4.0];\n+        let summary = Summary::new(xs);\n+        assert_eq!(summary.min, 1.0);\n+        assert_eq!(summary.max, 4.0);\n+    }\n+\n+    #[test]\n+    fn test_norm2() {\n+        let val = &[958.0000000000, 924.0000000000];\n+        let summ = &Summary {\n+            sum: 1882.0000000000,\n+            min: 924.0000000000,\n+            max: 958.0000000000,\n+            mean: 941.0000000000,\n+            median: 941.0000000000,\n+            var: 578.0000000000,\n+            std_dev: 24.0416305603,\n+            std_dev_pct: 2.5549022912,\n+            median_abs_dev: 25.2042000000,\n+            median_abs_dev_pct: 2.6784484591,\n+            quartiles: (932.5000000000, 941.0000000000, 949.5000000000),\n+            iqr: 17.0000000000,\n+        };\n+        check(val, summ);\n+    }\n+    #[test]\n+    fn test_norm10narrow() {\n+        let val = &[\n+            966.0000000000,\n+            985.0000000000,\n+            1110.0000000000,\n+            848.0000000000,\n+            821.0000000000,\n+            975.0000000000,\n+            962.0000000000,\n+            1157.0000000000,\n+            1217.0000000000,\n+            955.0000000000,\n+        ];\n+        let summ = &Summary {\n+            sum: 9996.0000000000,\n+            min: 821.0000000000,\n+            max: 1217.0000000000,\n+            mean: 999.6000000000,\n+            median: 970.5000000000,\n+            var: 16050.7111111111,\n+            std_dev: 126.6914010938,\n+            std_dev_pct: 12.6742097933,\n+            median_abs_dev: 102.2994000000,\n+            median_abs_dev_pct: 10.5408964451,\n+            quartiles: (956.7500000000, 970.5000000000, 1078.7500000000),\n+            iqr: 122.0000000000,\n+        };\n+        check(val, summ);\n+    }\n+    #[test]\n+    fn test_norm10medium() {\n+        let val = &[\n+            954.0000000000,\n+            1064.0000000000,\n+            855.0000000000,\n+            1000.0000000000,\n+            743.0000000000,\n+            1084.0000000000,\n+            704.0000000000,\n+            1023.0000000000,\n+            357.0000000000,\n+            869.0000000000,\n+        ];\n+        let summ = &Summary {\n+            sum: 8653.0000000000,\n+            min: 357.0000000000,\n+            max: 1084.0000000000,\n+            mean: 865.3000000000,\n+            median: 911.5000000000,\n+            var: 48628.4555555556,\n+            std_dev: 220.5186059170,\n+            std_dev_pct: 25.4846418487,\n+            median_abs_dev: 195.7032000000,\n+            median_abs_dev_pct: 21.4704552935,\n+            quartiles: (771.0000000000, 911.5000000000, 1017.2500000000),\n+            iqr: 246.2500000000,\n+        };\n+        check(val, summ);\n+    }\n+    #[test]\n+    fn test_norm10wide() {\n+        let val = &[\n+            505.0000000000,\n+            497.0000000000,\n+            1591.0000000000,\n+            887.0000000000,\n+            1026.0000000000,\n+            136.0000000000,\n+            1580.0000000000,\n+            940.0000000000,\n+            754.0000000000,\n+            1433.0000000000,\n+        ];\n+        let summ = &Summary {\n+            sum: 9349.0000000000,\n+            min: 136.0000000000,\n+            max: 1591.0000000000,\n+            mean: 934.9000000000,\n+            median: 913.5000000000,\n+            var: 239208.9888888889,\n+            std_dev: 489.0899599142,\n+            std_dev_pct: 52.3146817750,\n+            median_abs_dev: 611.5725000000,\n+            median_abs_dev_pct: 66.9482758621,\n+            quartiles: (567.2500000000, 913.5000000000, 1331.2500000000),\n+            iqr: 764.0000000000,\n+        };\n+        check(val, summ);\n+    }\n+    #[test]\n+    fn test_norm25verynarrow() {\n+        let val = &[\n+            991.0000000000,\n+            1018.0000000000,\n+            998.0000000000,\n+            1013.0000000000,\n+            974.0000000000,\n+            1007.0000000000,\n+            1014.0000000000,\n+            999.0000000000,\n+            1011.0000000000,\n+            978.0000000000,\n+            985.0000000000,\n+            999.0000000000,\n+            983.0000000000,\n+            982.0000000000,\n+            1015.0000000000,\n+            1002.0000000000,\n+            977.0000000000,\n+            948.0000000000,\n+            1040.0000000000,\n+            974.0000000000,\n+            996.0000000000,\n+            989.0000000000,\n+            1015.0000000000,\n+            994.0000000000,\n+            1024.0000000000,\n+        ];\n+        let summ = &Summary {\n+            sum: 24926.0000000000,\n+            min: 948.0000000000,\n+            max: 1040.0000000000,\n+            mean: 997.0400000000,\n+            median: 998.0000000000,\n+            var: 393.2066666667,\n+            std_dev: 19.8294393937,\n+            std_dev_pct: 1.9888308788,\n+            median_abs_dev: 22.2390000000,\n+            median_abs_dev_pct: 2.2283567134,\n+            quartiles: (983.0000000000, 998.0000000000, 1013.0000000000),\n+            iqr: 30.0000000000,\n+        };\n+        check(val, summ);\n+    }\n+    #[test]\n+    fn test_exp10a() {\n+        let val = &[\n+            23.0000000000,\n+            11.0000000000,\n+            2.0000000000,\n+            57.0000000000,\n+            4.0000000000,\n+            12.0000000000,\n+            5.0000000000,\n+            29.0000000000,\n+            3.0000000000,\n+            21.0000000000,\n+        ];\n+        let summ = &Summary {\n+            sum: 167.0000000000,\n+            min: 2.0000000000,\n+            max: 57.0000000000,\n+            mean: 16.7000000000,\n+            median: 11.5000000000,\n+            var: 287.7888888889,\n+            std_dev: 16.9643416875,\n+            std_dev_pct: 101.5828843560,\n+            median_abs_dev: 13.3434000000,\n+            median_abs_dev_pct: 116.0295652174,\n+            quartiles: (4.2500000000, 11.5000000000, 22.5000000000),\n+            iqr: 18.2500000000,\n+        };\n+        check(val, summ);\n+    }\n+    #[test]\n+    fn test_exp10b() {\n+        let val = &[\n+            24.0000000000,\n+            17.0000000000,\n+            6.0000000000,\n+            38.0000000000,\n+            25.0000000000,\n+            7.0000000000,\n+            51.0000000000,\n+            2.0000000000,\n+            61.0000000000,\n+            32.0000000000,\n+        ];\n+        let summ = &Summary {\n+            sum: 263.0000000000,\n+            min: 2.0000000000,\n+            max: 61.0000000000,\n+            mean: 26.3000000000,\n+            median: 24.5000000000,\n+            var: 383.5666666667,\n+            std_dev: 19.5848580967,\n+            std_dev_pct: 74.4671410520,\n+            median_abs_dev: 22.9803000000,\n+            median_abs_dev_pct: 93.7971428571,\n+            quartiles: (9.5000000000, 24.5000000000, 36.5000000000),\n+            iqr: 27.0000000000,\n+        };\n+        check(val, summ);\n+    }\n+    #[test]\n+    fn test_exp10c() {\n+        let val = &[\n+            71.0000000000,\n+            2.0000000000,\n+            32.0000000000,\n+            1.0000000000,\n+            6.0000000000,\n+            28.0000000000,\n+            13.0000000000,\n+            37.0000000000,\n+            16.0000000000,\n+            36.0000000000,\n+        ];\n+        let summ = &Summary {\n+            sum: 242.0000000000,\n+            min: 1.0000000000,\n+            max: 71.0000000000,\n+            mean: 24.2000000000,\n+            median: 22.0000000000,\n+            var: 458.1777777778,\n+            std_dev: 21.4050876611,\n+            std_dev_pct: 88.4507754589,\n+            median_abs_dev: 21.4977000000,\n+            median_abs_dev_pct: 97.7168181818,\n+            quartiles: (7.7500000000, 22.0000000000, 35.0000000000),\n+            iqr: 27.2500000000,\n+        };\n+        check(val, summ);\n+    }\n+    #[test]\n+    fn test_exp25() {\n+        let val = &[\n+            3.0000000000,\n+            24.0000000000,\n+            1.0000000000,\n+            19.0000000000,\n+            7.0000000000,\n+            5.0000000000,\n+            30.0000000000,\n+            39.0000000000,\n+            31.0000000000,\n+            13.0000000000,\n+            25.0000000000,\n+            48.0000000000,\n+            1.0000000000,\n+            6.0000000000,\n+            42.0000000000,\n+            63.0000000000,\n+            2.0000000000,\n+            12.0000000000,\n+            108.0000000000,\n+            26.0000000000,\n+            1.0000000000,\n+            7.0000000000,\n+            44.0000000000,\n+            25.0000000000,\n+            11.0000000000,\n+        ];\n+        let summ = &Summary {\n+            sum: 593.0000000000,\n+            min: 1.0000000000,\n+            max: 108.0000000000,\n+            mean: 23.7200000000,\n+            median: 19.0000000000,\n+            var: 601.0433333333,\n+            std_dev: 24.5161851301,\n+            std_dev_pct: 103.3565983562,\n+            median_abs_dev: 19.2738000000,\n+            median_abs_dev_pct: 101.4410526316,\n+            quartiles: (6.0000000000, 19.0000000000, 31.0000000000),\n+            iqr: 25.0000000000,\n+        };\n+        check(val, summ);\n+    }\n+    #[test]\n+    fn test_binom25() {\n+        let val = &[\n+            18.0000000000,\n+            17.0000000000,\n+            27.0000000000,\n+            15.0000000000,\n+            21.0000000000,\n+            25.0000000000,\n+            17.0000000000,\n+            24.0000000000,\n+            25.0000000000,\n+            24.0000000000,\n+            26.0000000000,\n+            26.0000000000,\n+            23.0000000000,\n+            15.0000000000,\n+            23.0000000000,\n+            17.0000000000,\n+            18.0000000000,\n+            18.0000000000,\n+            21.0000000000,\n+            16.0000000000,\n+            15.0000000000,\n+            31.0000000000,\n+            20.0000000000,\n+            17.0000000000,\n+            15.0000000000,\n+        ];\n+        let summ = &Summary {\n+            sum: 514.0000000000,\n+            min: 15.0000000000,\n+            max: 31.0000000000,\n+            mean: 20.5600000000,\n+            median: 20.0000000000,\n+            var: 20.8400000000,\n+            std_dev: 4.5650848842,\n+            std_dev_pct: 22.2037202539,\n+            median_abs_dev: 5.9304000000,\n+            median_abs_dev_pct: 29.6520000000,\n+            quartiles: (17.0000000000, 20.0000000000, 24.0000000000),\n+            iqr: 7.0000000000,\n+        };\n+        check(val, summ);\n+    }\n+    #[test]\n+    fn test_pois25lambda30() {\n+        let val = &[\n+            27.0000000000,\n+            33.0000000000,\n+            34.0000000000,\n+            34.0000000000,\n+            24.0000000000,\n+            39.0000000000,\n+            28.0000000000,\n+            27.0000000000,\n+            31.0000000000,\n+            28.0000000000,\n+            38.0000000000,\n+            21.0000000000,\n+            33.0000000000,\n+            36.0000000000,\n+            29.0000000000,\n+            37.0000000000,\n+            32.0000000000,\n+            34.0000000000,\n+            31.0000000000,\n+            39.0000000000,\n+            25.0000000000,\n+            31.0000000000,\n+            32.0000000000,\n+            40.0000000000,\n+            24.0000000000,\n+        ];\n+        let summ = &Summary {\n+            sum: 787.0000000000,\n+            min: 21.0000000000,\n+            max: 40.0000000000,\n+            mean: 31.4800000000,\n+            median: 32.0000000000,\n+            var: 26.5933333333,\n+            std_dev: 5.1568724372,\n+            std_dev_pct: 16.3814245145,\n+            median_abs_dev: 5.9304000000,\n+            median_abs_dev_pct: 18.5325000000,\n+            quartiles: (28.0000000000, 32.0000000000, 34.0000000000),\n+            iqr: 6.0000000000,\n+        };\n+        check(val, summ);\n+    }\n+    #[test]\n+    fn test_pois25lambda40() {\n+        let val = &[\n+            42.0000000000,\n+            50.0000000000,\n+            42.0000000000,\n+            46.0000000000,\n+            34.0000000000,\n+            45.0000000000,\n+            34.0000000000,\n+            49.0000000000,\n+            39.0000000000,\n+            28.0000000000,\n+            40.0000000000,\n+            35.0000000000,\n+            37.0000000000,\n+            39.0000000000,\n+            46.0000000000,\n+            44.0000000000,\n+            32.0000000000,\n+            45.0000000000,\n+            42.0000000000,\n+            37.0000000000,\n+            48.0000000000,\n+            42.0000000000,\n+            33.0000000000,\n+            42.0000000000,\n+            48.0000000000,\n+        ];\n+        let summ = &Summary {\n+            sum: 1019.0000000000,\n+            min: 28.0000000000,\n+            max: 50.0000000000,\n+            mean: 40.7600000000,\n+            median: 42.0000000000,\n+            var: 34.4400000000,\n+            std_dev: 5.8685603004,\n+            std_dev_pct: 14.3978417577,\n+            median_abs_dev: 5.9304000000,\n+            median_abs_dev_pct: 14.1200000000,\n+            quartiles: (37.0000000000, 42.0000000000, 45.0000000000),\n+            iqr: 8.0000000000,\n+        };\n+        check(val, summ);\n+    }\n+    #[test]\n+    fn test_pois25lambda50() {\n+        let val = &[\n+            45.0000000000,\n+            43.0000000000,\n+            44.0000000000,\n+            61.0000000000,\n+            51.0000000000,\n+            53.0000000000,\n+            59.0000000000,\n+            52.0000000000,\n+            49.0000000000,\n+            51.0000000000,\n+            51.0000000000,\n+            50.0000000000,\n+            49.0000000000,\n+            56.0000000000,\n+            42.0000000000,\n+            52.0000000000,\n+            51.0000000000,\n+            43.0000000000,\n+            48.0000000000,\n+            48.0000000000,\n+            50.0000000000,\n+            42.0000000000,\n+            43.0000000000,\n+            42.0000000000,\n+            60.0000000000,\n+        ];\n+        let summ = &Summary {\n+            sum: 1235.0000000000,\n+            min: 42.0000000000,\n+            max: 61.0000000000,\n+            mean: 49.4000000000,\n+            median: 50.0000000000,\n+            var: 31.6666666667,\n+            std_dev: 5.6273143387,\n+            std_dev_pct: 11.3913245723,\n+            median_abs_dev: 4.4478000000,\n+            median_abs_dev_pct: 8.8956000000,\n+            quartiles: (44.0000000000, 50.0000000000, 52.0000000000),\n+            iqr: 8.0000000000,\n+        };\n+        check(val, summ);\n+    }\n+    #[test]\n+    fn test_unif25() {\n+        let val = &[\n+            99.0000000000,\n+            55.0000000000,\n+            92.0000000000,\n+            79.0000000000,\n+            14.0000000000,\n+            2.0000000000,\n+            33.0000000000,\n+            49.0000000000,\n+            3.0000000000,\n+            32.0000000000,\n+            84.0000000000,\n+            59.0000000000,\n+            22.0000000000,\n+            86.0000000000,\n+            76.0000000000,\n+            31.0000000000,\n+            29.0000000000,\n+            11.0000000000,\n+            41.0000000000,\n+            53.0000000000,\n+            45.0000000000,\n+            44.0000000000,\n+            98.0000000000,\n+            98.0000000000,\n+            7.0000000000,\n+        ];\n+        let summ = &Summary {\n+            sum: 1242.0000000000,\n+            min: 2.0000000000,\n+            max: 99.0000000000,\n+            mean: 49.6800000000,\n+            median: 45.0000000000,\n+            var: 1015.6433333333,\n+            std_dev: 31.8691595957,\n+            std_dev_pct: 64.1488719719,\n+            median_abs_dev: 45.9606000000,\n+            median_abs_dev_pct: 102.1346666667,\n+            quartiles: (29.0000000000, 45.0000000000, 79.0000000000),\n+            iqr: 50.0000000000,\n+        };\n+        check(val, summ);\n+    }\n+\n+    #[test]\n+    fn test_sum_f64s() {\n+        assert_eq!([0.5f64, 3.2321f64, 1.5678f64].sum(), 5.2999);\n+    }\n+    #[test]\n+    fn test_sum_f64_between_ints_that_sum_to_0() {\n+        assert_eq!([1e30f64, 1.2f64, -1e30f64].sum(), 1.2);\n+    }\n+}\n+\n+#[cfg(test)]\n+mod bench {\n+    extern crate test;\n+    use self::test::Bencher;\n+    use crate::stats::Stats;\n+\n+    #[bench]\n+    pub fn sum_three_items(b: &mut Bencher) {\n+        b.iter(|| {\n+            [1e20f64, 1.5f64, -1e20f64].sum();\n+        })\n+    }\n+    #[bench]\n+    pub fn sum_many_f64(b: &mut Bencher) {\n+        let nums = [-1e30f64, 1e60, 1e30, 1.0, -1e60];\n+        let v = (0..500).map(|i| nums[i % 5]).collect::<Vec<_>>();\n+\n+        b.iter(|| {\n+            v.sum();\n+        })\n+    }\n+\n+    #[bench]\n+    pub fn no_iter(_: &mut Bencher) {}\n+}"}]}