{"sha": "59524410a7eb3c6afe3ac01b4257d916efe2421b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU5NTI0NDEwYTdlYjNjNmFmZTNhYzAxYjQyNTdkOTE2ZWZlMjQyMWI=", "commit": {"author": {"name": "Robin Kruppe", "email": "robin.kruppe@gmail.com", "date": "2017-11-09T23:24:05Z"}, "committer": {"name": "Robin Kruppe", "email": "robin.kruppe@gmail.com", "date": "2017-11-10T09:12:30Z"}, "message": "Make saturating u128 -> f32 casts the default behavior\n\n... rather than being gated by -Z saturating-float-casts.\nThere are several reasons for this:\n\n1. Const eval already implements this behavior.\n2. Unlike with float->int casts, this behavior is uncontroversially the\nright behavior and it is not as performance critical. Thus there is no\nparticular need to make the bug fix for u128->f32 casts opt-in.\n3. Having two orthogonal features under one flag is silly, and never\nshould have happened in the first place.\n4. Benchmarking float->int casts with the -Z flag should not pick up\nperformance changes due to the u128->f32 casts (assuming there are any).\n\nFixes #41799", "tree": {"sha": "155dd4768dfc1aff7795dba6784126f9f90326e3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/155dd4768dfc1aff7795dba6784126f9f90326e3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/59524410a7eb3c6afe3ac01b4257d916efe2421b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/59524410a7eb3c6afe3ac01b4257d916efe2421b", "html_url": "https://github.com/rust-lang/rust/commit/59524410a7eb3c6afe3ac01b4257d916efe2421b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/59524410a7eb3c6afe3ac01b4257d916efe2421b/comments", "author": null, "committer": null, "parents": [{"sha": "f1ea23e2cc72cafad1dc25a06c09ec2de8e323eb", "url": "https://api.github.com/repos/rust-lang/rust/commits/f1ea23e2cc72cafad1dc25a06c09ec2de8e323eb", "html_url": "https://github.com/rust-lang/rust/commit/f1ea23e2cc72cafad1dc25a06c09ec2de8e323eb"}], "stats": {"total": 109, "additions": 64, "deletions": 45}, "files": [{"sha": "3f53c89c9d6cbcc862d3d2653ec7458f0926f07f", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/59524410a7eb3c6afe3ac01b4257d916efe2421b/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59524410a7eb3c6afe3ac01b4257d916efe2421b/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=59524410a7eb3c6afe3ac01b4257d916efe2421b", "patch": "@@ -1138,8 +1138,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n     tls_model: Option<String> = (None, parse_opt_string, [TRACKED],\n          \"choose the TLS model to use (rustc --print tls-models for details)\"),\n     saturating_float_casts: bool = (false, parse_bool, [TRACKED],\n-        \"make casts between integers and floats safe: clip out-of-range inputs to the min/max \\\n-         integer or to infinity respectively, and turn `NAN` into 0 when casting to integers\"),\n+        \"make float->int casts UB-free: numbers outside the integer type's range are clipped to \\\n+         the max/min integer respectively, and NaN is mapped to 0\"),\n }\n \n pub fn default_lib_output() -> CrateType {"}, {"sha": "7e187a85867cbd870f9c1418fa2c6405127c3cd8", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/59524410a7eb3c6afe3ac01b4257d916efe2421b/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59524410a7eb3c6afe3ac01b4257d916efe2421b/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=59524410a7eb3c6afe3ac01b4257d916efe2421b", "patch": "@@ -827,7 +827,7 @@ fn cast_int_to_float(bcx: &Builder,\n     // It's only u128 -> f32 that can cause overflows (i.e., should yield infinity).\n     // LLVM's uitofp produces undef in those cases, so we manually check for that case.\n     let is_u128_to_f32 = !signed && int_ty.int_width() == 128 && float_ty.float_width() == 32;\n-    if is_u128_to_f32 && bcx.sess().opts.debugging_opts.saturating_float_casts {\n+    if is_u128_to_f32 {\n         // All inputs greater or equal to (f32::MAX + 0.5 ULP) are rounded to infinity,\n         // and for everything else LLVM's uitofp works just fine.\n         let max = C_big_integral(int_ty, MAX_F32_PLUS_HALF_ULP);"}, {"sha": "c2fc296617098ce2cc458234d18f506a7121b7d6", "filename": "src/test/codegen/unchecked-float-casts.rs", "status": "modified", "additions": 2, "deletions": 21, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/59524410a7eb3c6afe3ac01b4257d916efe2421b/src%2Ftest%2Fcodegen%2Funchecked-float-casts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59524410a7eb3c6afe3ac01b4257d916efe2421b/src%2Ftest%2Fcodegen%2Funchecked-float-casts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Funchecked-float-casts.rs?ref=59524410a7eb3c6afe3ac01b4257d916efe2421b", "patch": "@@ -37,29 +37,10 @@ pub fn f32_to_i32(x: f32) -> i32 {\n }\n \n #[no_mangle]\n-pub fn f64_to_u8(x: f32) -> u16 {\n+pub fn f64_to_u16(x: f64) -> u16 {\n+    // CHECK: fptoui\n     // CHECK-NOT: fcmp\n     // CHECK-NOT: icmp\n     // CHECK-NOT: select\n     x as u16\n }\n-\n-// CHECK-LABEL: @i32_to_f64\n-#[no_mangle]\n-pub fn i32_to_f64(x: i32) -> f64 {\n-    // CHECK: sitofp\n-    // CHECK-NOT: fcmp\n-    // CHECK-NOT: icmp\n-    // CHECK-NOT: select\n-    x as f64\n-}\n-\n-// CHECK-LABEL: @u128_to_f32\n-#[no_mangle]\n-pub fn u128_to_f32(x: u128) -> f32 {\n-    // CHECK: uitofp\n-    // CHECK-NOT: fcmp\n-    // CHECK-NOT: icmp\n-    // CHECK-NOT: select\n-    x as f32\n-}"}, {"sha": "6377a8c0a7331c248ae2c3f5bcca0efdb13e98d3", "filename": "src/test/run-pass/saturating-float-casts.rs", "status": "modified", "additions": 1, "deletions": 21, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/59524410a7eb3c6afe3ac01b4257d916efe2421b/src%2Ftest%2Frun-pass%2Fsaturating-float-casts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59524410a7eb3c6afe3ac01b4257d916efe2421b/src%2Ftest%2Frun-pass%2Fsaturating-float-casts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fsaturating-float-casts.rs?ref=59524410a7eb3c6afe3ac01b4257d916efe2421b", "patch": "@@ -8,6 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+// Tests saturating float->int casts. See u128-as-f32.rs for the opposite direction.\n // compile-flags: -Z saturating-float-casts\n \n #![feature(test, i128, i128_type, stmt_expr_attributes)]\n@@ -139,26 +140,5 @@ pub fn main() {\n         // nextDown(f32::MAX) = 2^128 - 2 * 2^104\n         const SECOND_LARGEST_F32: f32 = 340282326356119256160033759537265639424.;\n         test_c!(SECOND_LARGEST_F32, f32 -> u128, 0xfffffe00000000000000000000000000);\n-\n-        // int->float:\n-        // f32::MAX - 0.5 ULP and smaller should be rounded down\n-        test_c!(0xfffffe00000000000000000000000000, u128 -> f32, SECOND_LARGEST_F32);\n-        test_c!(0xfffffe7fffffffffffffffffffffffff, u128 -> f32, SECOND_LARGEST_F32);\n-        test_c!(0xfffffe80000000000000000000000000, u128 -> f32, SECOND_LARGEST_F32);\n-        // numbers within < 0.5 ULP of f32::MAX it should be rounded to f32::MAX\n-        test_c!(0xfffffe80000000000000000000000001, u128 -> f32, f32::MAX);\n-        test_c!(0xfffffeffffffffffffffffffffffffff, u128 -> f32, f32::MAX);\n-        test_c!(0xffffff00000000000000000000000000, u128 -> f32, f32::MAX);\n-        test_c!(0xffffff00000000000000000000000001, u128 -> f32, f32::MAX);\n-        test_c!(0xffffff7fffffffffffffffffffffffff, u128 -> f32, f32::MAX);\n-        // f32::MAX + 0.5 ULP and greater should be rounded to infinity\n-        test_c!(0xffffff80000000000000000000000000, u128 -> f32, f32::INFINITY);\n-        test_c!(0xffffff80000000f00000000000000000, u128 -> f32, f32::INFINITY);\n-        test_c!(0xffffff87ffffffffffffffff00000001, u128 -> f32, f32::INFINITY);\n-\n-        // u128->f64 should not be affected by the u128->f32 checks\n-        test_c!(0xffffff80000000000000000000000000, u128 -> f64,\n-              340282356779733661637539395458142568448.0);\n-        test_c!(u128::MAX, u128 -> f64, 340282366920938463463374607431768211455.0);\n     }\n }"}, {"sha": "117e520155fd176d9a09286de974efb74f83d990", "filename": "src/test/run-pass/u128-as-f32.rs", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/59524410a7eb3c6afe3ac01b4257d916efe2421b/src%2Ftest%2Frun-pass%2Fu128-as-f32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/59524410a7eb3c6afe3ac01b4257d916efe2421b/src%2Ftest%2Frun-pass%2Fu128-as-f32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fu128-as-f32.rs?ref=59524410a7eb3c6afe3ac01b4257d916efe2421b", "patch": "@@ -0,0 +1,58 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-emscripten u128 not supported\n+\n+#![feature(test, i128, i128_type)]\n+#![deny(overflowing_literals)]\n+extern crate test;\n+\n+use std::f32;\n+use std::u128;\n+use test::black_box;\n+\n+macro_rules! test {\n+    ($val:expr, $src_ty:ident -> $dest_ty:ident, $expected:expr) => ({\n+        {\n+            const X: $src_ty = $val;\n+            const Y: $dest_ty = X as $dest_ty;\n+            assert_eq!(Y, $expected,\n+                        \"const eval {} -> {}\", stringify!($src_ty), stringify!($dest_ty));\n+        }\n+        // black_box disables constant evaluation to test run-time conversions:\n+        assert_eq!(black_box::<$src_ty>($val) as $dest_ty, $expected,\n+                    \"run-time {} -> {}\", stringify!($src_ty), stringify!($dest_ty));\n+    });\n+}\n+\n+pub fn main() {\n+    // nextDown(f32::MAX) = 2^128 - 2 * 2^104\n+    const SECOND_LARGEST_F32: f32 = 340282326356119256160033759537265639424.;\n+\n+    // f32::MAX - 0.5 ULP and smaller should be rounded down\n+    test!(0xfffffe00000000000000000000000000, u128 -> f32, SECOND_LARGEST_F32);\n+    test!(0xfffffe7fffffffffffffffffffffffff, u128 -> f32, SECOND_LARGEST_F32);\n+    test!(0xfffffe80000000000000000000000000, u128 -> f32, SECOND_LARGEST_F32);\n+    // numbers within < 0.5 ULP of f32::MAX it should be rounded to f32::MAX\n+    test!(0xfffffe80000000000000000000000001, u128 -> f32, f32::MAX);\n+    test!(0xfffffeffffffffffffffffffffffffff, u128 -> f32, f32::MAX);\n+    test!(0xffffff00000000000000000000000000, u128 -> f32, f32::MAX);\n+    test!(0xffffff00000000000000000000000001, u128 -> f32, f32::MAX);\n+    test!(0xffffff7fffffffffffffffffffffffff, u128 -> f32, f32::MAX);\n+    // f32::MAX + 0.5 ULP and greater should be rounded to infinity\n+    test!(0xffffff80000000000000000000000000, u128 -> f32, f32::INFINITY);\n+    test!(0xffffff80000000f00000000000000000, u128 -> f32, f32::INFINITY);\n+    test!(0xffffff87ffffffffffffffff00000001, u128 -> f32, f32::INFINITY);\n+\n+    // u128->f64 should not be affected by the u128->f32 checks\n+    test!(0xffffff80000000000000000000000000, u128 -> f64,\n+          340282356779733661637539395458142568448.0);\n+    test!(u128::MAX, u128 -> f64, 340282366920938463463374607431768211455.0);\n+}"}]}