{"sha": "71448d7c37b84a0d4713441bc4c9ef6d851df62b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjcxNDQ4ZDdjMzdiODRhMGQ0NzEzNDQxYmM0YzllZjZkODUxZGY2MmI=", "commit": {"author": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-08-27T10:00:57Z"}, "committer": {"name": "Huon Wilson", "email": "dbau.pp+github@gmail.com", "date": "2013-08-27T10:12:39Z"}, "message": "Rename UnsafeAtomicRcBox to UnsafeArc. Fixes #7674.", "tree": {"sha": "fc51fefc4e72c4626e63c9bb7aea4e2c499a4dc0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fc51fefc4e72c4626e63c9bb7aea4e2c499a4dc0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/71448d7c37b84a0d4713441bc4c9ef6d851df62b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/71448d7c37b84a0d4713441bc4c9ef6d851df62b", "html_url": "https://github.com/rust-lang/rust/commit/71448d7c37b84a0d4713441bc4c9ef6d851df62b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/71448d7c37b84a0d4713441bc4c9ef6d851df62b/comments", "author": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "committer": {"login": "huonw", "id": 1203825, "node_id": "MDQ6VXNlcjEyMDM4MjU=", "avatar_url": "https://avatars.githubusercontent.com/u/1203825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/huonw", "html_url": "https://github.com/huonw", "followers_url": "https://api.github.com/users/huonw/followers", "following_url": "https://api.github.com/users/huonw/following{/other_user}", "gists_url": "https://api.github.com/users/huonw/gists{/gist_id}", "starred_url": "https://api.github.com/users/huonw/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/huonw/subscriptions", "organizations_url": "https://api.github.com/users/huonw/orgs", "repos_url": "https://api.github.com/users/huonw/repos", "events_url": "https://api.github.com/users/huonw/events{/privacy}", "received_events_url": "https://api.github.com/users/huonw/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "604ab9477a800ee36ff59433a187cb471a5c7f79", "url": "https://api.github.com/repos/rust-lang/rust/commits/604ab9477a800ee36ff59433a187cb471a5c7f79", "html_url": "https://github.com/rust-lang/rust/commit/604ab9477a800ee36ff59433a187cb471a5c7f79"}], "stats": {"total": 144, "additions": 72, "deletions": 72}, "files": [{"sha": "792fb7f9ca7214c91ed30ce7d5148942f7dd2563", "filename": "src/libextra/arc.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/71448d7c37b84a0d4713441bc4c9ef6d851df62b/src%2Flibextra%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71448d7c37b84a0d4713441bc4c9ef6d851df62b/src%2Flibextra%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Farc.rs?ref=71448d7c37b84a0d4713441bc4c9ef6d851df62b", "patch": "@@ -44,7 +44,7 @@ use sync;\n use sync::{Mutex, RWLock};\n \n use std::cast;\n-use std::unstable::sync::UnsafeAtomicRcBox;\n+use std::unstable::sync::UnsafeArc;\n use std::task;\n use std::borrow;\n \n@@ -108,7 +108,7 @@ impl<'self> Condvar<'self> {\n  ****************************************************************************/\n \n /// An atomically reference counted wrapper for shared immutable state.\n-pub struct Arc<T> { priv x: UnsafeAtomicRcBox<T> }\n+pub struct Arc<T> { priv x: UnsafeArc<T> }\n \n \n /**\n@@ -118,7 +118,7 @@ pub struct Arc<T> { priv x: UnsafeAtomicRcBox<T> }\n impl<T:Freeze+Send> Arc<T> {\n     /// Create an atomically reference counted wrapper.\n     pub fn new(data: T) -> Arc<T> {\n-        Arc { x: UnsafeAtomicRcBox::new(data) }\n+        Arc { x: UnsafeArc::new(data) }\n     }\n \n     pub fn get<'a>(&'a self) -> &'a T {\n@@ -160,7 +160,7 @@ impl<T:Freeze + Send> Clone for Arc<T> {\n #[doc(hidden)]\n struct MutexArcInner<T> { priv lock: Mutex, priv failed: bool, priv data: T }\n /// An Arc with mutable data protected by a blocking mutex.\n-struct MutexArc<T> { priv x: UnsafeAtomicRcBox<MutexArcInner<T>> }\n+struct MutexArc<T> { priv x: UnsafeArc<MutexArcInner<T>> }\n \n \n impl<T:Send> Clone for MutexArc<T> {\n@@ -187,7 +187,7 @@ impl<T:Send> MutexArc<T> {\n             lock: Mutex::new_with_condvars(num_condvars),\n             failed: false, data: user_data\n         };\n-        MutexArc { x: UnsafeAtomicRcBox::new(data) }\n+        MutexArc { x: UnsafeArc::new(data) }\n     }\n \n     /**\n@@ -309,7 +309,7 @@ struct RWArcInner<T> { priv lock: RWLock, priv failed: bool, priv data: T }\n  */\n #[no_freeze]\n struct RWArc<T> {\n-    priv x: UnsafeAtomicRcBox<RWArcInner<T>>,\n+    priv x: UnsafeArc<RWArcInner<T>>,\n }\n \n impl<T:Freeze + Send> Clone for RWArc<T> {\n@@ -335,7 +335,7 @@ impl<T:Freeze + Send> RWArc<T> {\n             lock: RWLock::new_with_condvars(num_condvars),\n             failed: false, data: user_data\n         };\n-        RWArc { x: UnsafeAtomicRcBox::new(data), }\n+        RWArc { x: UnsafeArc::new(data), }\n     }\n \n     /**"}, {"sha": "6640635130549f2d998d149035312743cf2673fe", "filename": "src/libextra/sync.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/71448d7c37b84a0d4713441bc4c9ef6d851df62b/src%2Flibextra%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71448d7c37b84a0d4713441bc4c9ef6d851df62b/src%2Flibextra%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsync.rs?ref=71448d7c37b84a0d4713441bc4c9ef6d851df62b", "patch": "@@ -21,7 +21,7 @@ use std::comm;\n use std::comm::SendDeferred;\n use std::comm::{GenericPort, Peekable};\n use std::task;\n-use std::unstable::sync::{Exclusive, UnsafeAtomicRcBox};\n+use std::unstable::sync::{Exclusive, UnsafeArc};\n use std::unstable::atomics;\n use std::unstable::finally::Finally;\n use std::util;\n@@ -448,7 +448,7 @@ struct RWLockInner {\n pub struct RWLock {\n     priv order_lock:  Semaphore,\n     priv access_lock: Sem<~[WaitQueue]>,\n-    priv state:       UnsafeAtomicRcBox<RWLockInner>,\n+    priv state:       UnsafeArc<RWLockInner>,\n }\n \n impl RWLock {\n@@ -460,7 +460,7 @@ impl RWLock {\n     * Similar to mutex_with_condvars.\n     */\n     pub fn new_with_condvars(num_condvars: uint) -> RWLock {\n-        let state = UnsafeAtomicRcBox::new(RWLockInner {\n+        let state = UnsafeArc::new(RWLockInner {\n             read_mode:  false,\n             read_count: atomics::AtomicUint::new(0),\n         });"}, {"sha": "b547d3c9c3015f757254e24fe92ca8f259f9c739", "filename": "src/libstd/rt/comm.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/71448d7c37b84a0d4713441bc4c9ef6d851df62b/src%2Flibstd%2Frt%2Fcomm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71448d7c37b84a0d4713441bc4c9ef6d851df62b/src%2Flibstd%2Frt%2Fcomm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fcomm.rs?ref=71448d7c37b84a0d4713441bc4c9ef6d851df62b", "patch": "@@ -21,7 +21,7 @@ use rt::local::Local;\n use rt::select::{SelectInner, SelectPortInner};\n use select::{Select, SelectPort};\n use unstable::atomics::{AtomicUint, AtomicOption, Acquire, Relaxed, SeqCst};\n-use unstable::sync::UnsafeAtomicRcBox;\n+use unstable::sync::UnsafeArc;\n use util::Void;\n use comm::{GenericChan, GenericSmartChan, GenericPort, Peekable};\n use cell::Cell;\n@@ -567,14 +567,14 @@ impl<'self, T> SelectPort<T> for &'self Port<T> { }\n \n pub struct SharedChan<T> {\n     // Just like Chan, but a shared AtomicOption instead of Cell\n-    priv next: UnsafeAtomicRcBox<AtomicOption<StreamChanOne<T>>>\n+    priv next: UnsafeArc<AtomicOption<StreamChanOne<T>>>\n }\n \n impl<T> SharedChan<T> {\n     pub fn new(chan: Chan<T>) -> SharedChan<T> {\n         let next = chan.next.take();\n         let next = AtomicOption::new(~next);\n-        SharedChan { next: UnsafeAtomicRcBox::new(next) }\n+        SharedChan { next: UnsafeArc::new(next) }\n     }\n }\n \n@@ -620,7 +620,7 @@ impl<T> Clone for SharedChan<T> {\n \n pub struct SharedPort<T> {\n     // The next port on which we will receive the next port on which we will receive T\n-    priv next_link: UnsafeAtomicRcBox<AtomicOption<PortOne<StreamPortOne<T>>>>\n+    priv next_link: UnsafeArc<AtomicOption<PortOne<StreamPortOne<T>>>>\n }\n \n impl<T> SharedPort<T> {\n@@ -630,7 +630,7 @@ impl<T> SharedPort<T> {\n         let (next_link_port, next_link_chan) = oneshot();\n         next_link_chan.send(next_data_port);\n         let next_link = AtomicOption::new(~next_link_port);\n-        SharedPort { next_link: UnsafeAtomicRcBox::new(next_link) }\n+        SharedPort { next_link: UnsafeArc::new(next_link) }\n     }\n }\n "}, {"sha": "e31a98a9a7addb473bbceda27291cfc4f5e5691c", "filename": "src/libstd/rt/kill.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/71448d7c37b84a0d4713441bc4c9ef6d851df62b/src%2Flibstd%2Frt%2Fkill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71448d7c37b84a0d4713441bc4c9ef6d851df62b/src%2Flibstd%2Frt%2Fkill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fkill.rs?ref=71448d7c37b84a0d4713441bc4c9ef6d851df62b", "patch": "@@ -159,7 +159,7 @@ use rt::task::Task;\n use task::spawn::Taskgroup;\n use to_bytes::IterBytes;\n use unstable::atomics::{AtomicUint, Relaxed};\n-use unstable::sync::{UnsafeAtomicRcBox, LittleLock};\n+use unstable::sync::{UnsafeArc, LittleLock};\n use util;\n \n static KILLED_MSG: &'static str = \"killed by linked failure\";\n@@ -170,7 +170,7 @@ static KILL_KILLED:     uint = 1;\n static KILL_UNKILLABLE: uint = 2;\n \n struct KillFlag(AtomicUint);\n-type KillFlagHandle = UnsafeAtomicRcBox<KillFlag>;\n+type KillFlagHandle = UnsafeArc<KillFlag>;\n \n /// A handle to a blocked task. Usually this means having the ~Task pointer by\n /// ownership, but if the task is killable, a killer can steal it at any time.\n@@ -211,7 +211,7 @@ struct KillHandleInner {\n \n /// State shared between tasks used for task killing during linked failure.\n #[deriving(Clone)]\n-pub struct KillHandle(UnsafeAtomicRcBox<KillHandleInner>);\n+pub struct KillHandle(UnsafeArc<KillHandleInner>);\n \n /// Per-task state related to task death, killing, failure, etc.\n pub struct Death {\n@@ -317,7 +317,7 @@ impl BlockedTask {\n         let handles = match self {\n             Unkillable(task) => {\n                 let flag = unsafe { KillFlag(AtomicUint::new(cast::transmute(task))) };\n-                UnsafeAtomicRcBox::newN(flag, num_handles)\n+                UnsafeArc::newN(flag, num_handles)\n             }\n             Killable(flag_arc) => flag_arc.cloneN(num_handles),\n         };\n@@ -380,8 +380,8 @@ impl Eq for KillHandle {\n impl KillHandle {\n     pub fn new() -> (KillHandle, KillFlagHandle) {\n         let (flag, flag_clone) =\n-            UnsafeAtomicRcBox::new2(KillFlag(AtomicUint::new(KILL_RUNNING)));\n-        let handle = KillHandle(UnsafeAtomicRcBox::new(KillHandleInner {\n+            UnsafeArc::new2(KillFlag(AtomicUint::new(KILL_RUNNING)));\n+        let handle = KillHandle(UnsafeArc::new(KillHandleInner {\n             // Linked failure fields\n             killed:     flag,\n             unkillable: AtomicUint::new(KILL_RUNNING),\n@@ -460,7 +460,7 @@ impl KillHandle {\n     pub fn notify_immediate_failure(&mut self) {\n         // A benign data race may happen here if there are failing sibling\n         // tasks that were also spawned-watched. The refcount's write barriers\n-        // in UnsafeAtomicRcBox ensure that this write will be seen by the\n+        // in UnsafeArc ensure that this write will be seen by the\n         // unwrapper/destructor, whichever task may unwrap it.\n         unsafe { (*self.get()).any_child_failed = true; }\n     }"}, {"sha": "99b5156b319553b1ece12c24ccfa8a8a1e91ecd8", "filename": "src/libstd/rt/message_queue.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/71448d7c37b84a0d4713441bc4c9ef6d851df62b/src%2Flibstd%2Frt%2Fmessage_queue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71448d7c37b84a0d4713441bc4c9ef6d851df62b/src%2Flibstd%2Frt%2Fmessage_queue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmessage_queue.rs?ref=71448d7c37b84a0d4713441bc4c9ef6d851df62b", "patch": "@@ -16,11 +16,11 @@ use kinds::Send;\n use vec::OwnedVector;\n use cell::Cell;\n use option::*;\n-use unstable::sync::{UnsafeAtomicRcBox, LittleLock};\n+use unstable::sync::{UnsafeArc, LittleLock};\n use clone::Clone;\n \n pub struct MessageQueue<T> {\n-    priv state: UnsafeAtomicRcBox<State<T>>\n+    priv state: UnsafeArc<State<T>>\n }\n \n struct State<T> {\n@@ -32,7 +32,7 @@ struct State<T> {\n impl<T: Send> MessageQueue<T> {\n     pub fn new() -> MessageQueue<T> {\n         MessageQueue {\n-            state: UnsafeAtomicRcBox::new(State {\n+            state: UnsafeArc::new(State {\n                 count: 0,\n                 queue: ~[],\n                 lock: LittleLock::new()"}, {"sha": "7436efb5bf5336e7ff7f108d52bc8c5e0cfd2b9f", "filename": "src/libstd/rt/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/71448d7c37b84a0d4713441bc4c9ef6d851df62b/src%2Flibstd%2Frt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71448d7c37b84a0d4713441bc4c9ef6d851df62b/src%2Flibstd%2Frt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fmod.rs?ref=71448d7c37b84a0d4713441bc4c9ef6d851df62b", "patch": "@@ -74,7 +74,7 @@ use rt::thread::Thread;\n use rt::work_queue::WorkQueue;\n use rt::uv::uvio::UvEventLoop;\n use unstable::atomics::{AtomicInt, SeqCst};\n-use unstable::sync::UnsafeAtomicRcBox;\n+use unstable::sync::UnsafeArc;\n use vec::{OwnedVector, MutableVector};\n \n /// The global (exchange) heap.\n@@ -311,7 +311,7 @@ fn run_(main: ~fn(), use_main_sched: bool) -> int {\n \n     // Create a shared cell for transmitting the process exit\n     // code from the main task to this function.\n-    let exit_code = UnsafeAtomicRcBox::new(AtomicInt::new(0));\n+    let exit_code = UnsafeArc::new(AtomicInt::new(0));\n     let exit_code_clone = exit_code.clone();\n \n     // When the main task exits, after all the tasks in the main"}, {"sha": "f4fdf15cda62e2f11ea71eabf16401e127e99530", "filename": "src/libstd/rt/sleeper_list.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/71448d7c37b84a0d4713441bc4c9ef6d851df62b/src%2Flibstd%2Frt%2Fsleeper_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71448d7c37b84a0d4713441bc4c9ef6d851df62b/src%2Flibstd%2Frt%2Fsleeper_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fsleeper_list.rs?ref=71448d7c37b84a0d4713441bc4c9ef6d851df62b", "patch": "@@ -15,12 +15,12 @@ use container::Container;\n use vec::OwnedVector;\n use option::{Option, Some, None};\n use cell::Cell;\n-use unstable::sync::{UnsafeAtomicRcBox, LittleLock};\n+use unstable::sync::{UnsafeArc, LittleLock};\n use rt::sched::SchedHandle;\n use clone::Clone;\n \n pub struct SleeperList {\n-    priv state: UnsafeAtomicRcBox<State>\n+    priv state: UnsafeArc<State>\n }\n \n struct State {\n@@ -32,7 +32,7 @@ struct State {\n impl SleeperList {\n     pub fn new() -> SleeperList {\n         SleeperList {\n-            state: UnsafeAtomicRcBox::new(State {\n+            state: UnsafeArc::new(State {\n                 count: 0,\n                 stack: ~[],\n                 lock: LittleLock::new()"}, {"sha": "67d7ee9961610c54e6b41917edec75299900f855", "filename": "src/libstd/unstable/sync.rs", "status": "modified", "additions": 42, "deletions": 42, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/71448d7c37b84a0d4713441bc4c9ef6d851df62b/src%2Flibstd%2Funstable%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/71448d7c37b84a0d4713441bc4c9ef6d851df62b/src%2Flibstd%2Funstable%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fsync.rs?ref=71448d7c37b84a0d4713441bc4c9ef6d851df62b", "patch": "@@ -26,11 +26,11 @@ use vec;\n /// An atomically reference counted pointer.\n ///\n /// Enforces no shared-memory safety.\n-pub struct UnsafeAtomicRcBox<T> {\n+pub struct UnsafeArc<T> {\n     data: *mut libc::c_void,\n }\n \n-struct AtomicRcBoxData<T> {\n+struct ArcData<T> {\n     count: AtomicUint,\n     // An unwrapper uses this protocol to communicate with the \"other\" task that\n     // drops the last refcount on an arc. Unfortunately this can't be a proper\n@@ -42,59 +42,59 @@ struct AtomicRcBoxData<T> {\n }\n \n unsafe fn new_inner<T: Send>(data: T, refcount: uint) -> *mut libc::c_void {\n-    let data = ~AtomicRcBoxData { count: AtomicUint::new(refcount),\n-                                  unwrapper: AtomicOption::empty(),\n-                                  data: Some(data) };\n+    let data = ~ArcData { count: AtomicUint::new(refcount),\n+                          unwrapper: AtomicOption::empty(),\n+                          data: Some(data) };\n     cast::transmute(data)\n }\n \n-impl<T: Send> UnsafeAtomicRcBox<T> {\n-    pub fn new(data: T) -> UnsafeAtomicRcBox<T> {\n-        unsafe { UnsafeAtomicRcBox { data: new_inner(data, 1) } }\n+impl<T: Send> UnsafeArc<T> {\n+    pub fn new(data: T) -> UnsafeArc<T> {\n+        unsafe { UnsafeArc { data: new_inner(data, 1) } }\n     }\n \n     /// As new(), but returns an extra pre-cloned handle.\n-    pub fn new2(data: T) -> (UnsafeAtomicRcBox<T>, UnsafeAtomicRcBox<T>) {\n+    pub fn new2(data: T) -> (UnsafeArc<T>, UnsafeArc<T>) {\n         unsafe {\n             let ptr = new_inner(data, 2);\n-            (UnsafeAtomicRcBox { data: ptr }, UnsafeAtomicRcBox { data: ptr })\n+            (UnsafeArc { data: ptr }, UnsafeArc { data: ptr })\n         }\n     }\n \n     /// As new(), but returns a vector of as many pre-cloned handles as requested.\n-    pub fn newN(data: T, num_handles: uint) -> ~[UnsafeAtomicRcBox<T>] {\n+    pub fn newN(data: T, num_handles: uint) -> ~[UnsafeArc<T>] {\n         unsafe {\n             if num_handles == 0 {\n                 ~[] // need to free data here\n             } else {\n                 let ptr = new_inner(data, num_handles);\n-                vec::from_fn(num_handles, |_| UnsafeAtomicRcBox { data: ptr })\n+                vec::from_fn(num_handles, |_| UnsafeArc { data: ptr })\n             }\n         }\n     }\n \n     /// As newN(), but from an already-existing handle. Uses one xadd.\n-    pub fn cloneN(self, num_handles: uint) -> ~[UnsafeAtomicRcBox<T>] {\n+    pub fn cloneN(self, num_handles: uint) -> ~[UnsafeArc<T>] {\n         if num_handles == 0 {\n             ~[] // The \"num_handles - 1\" trick (below) fails in the 0 case.\n         } else {\n             unsafe {\n-                let mut data: ~AtomicRcBoxData<T> = cast::transmute(self.data);\n+                let mut data: ~ArcData<T> = cast::transmute(self.data);\n                 // Minus one because we are recycling the given handle's refcount.\n                 let old_count = data.count.fetch_add(num_handles - 1, Acquire);\n                 // let old_count = data.count.fetch_add(num_handles, Acquire);\n                 assert!(old_count >= 1);\n                 let ptr = cast::transmute(data);\n                 cast::forget(self); // Don't run the destructor on this handle.\n-                vec::from_fn(num_handles, |_| UnsafeAtomicRcBox { data: ptr })\n+                vec::from_fn(num_handles, |_| UnsafeArc { data: ptr })\n             }\n         }\n     }\n \n     #[inline]\n     pub fn get(&self) -> *mut T {\n         unsafe {\n-            let mut data: ~AtomicRcBoxData<T> = cast::transmute(self.data);\n+            let mut data: ~ArcData<T> = cast::transmute(self.data);\n             assert!(data.count.load(Relaxed) > 0);\n             let r: *mut T = data.data.get_mut_ref();\n             cast::forget(data);\n@@ -105,7 +105,7 @@ impl<T: Send> UnsafeAtomicRcBox<T> {\n     #[inline]\n     pub fn get_immut(&self) -> *T {\n         unsafe {\n-            let data: ~AtomicRcBoxData<T> = cast::transmute(self.data);\n+            let data: ~ArcData<T> = cast::transmute(self.data);\n             assert!(data.count.load(Relaxed) > 0);\n             let r: *T = data.data.get_ref();\n             cast::forget(data);\n@@ -122,7 +122,7 @@ impl<T: Send> UnsafeAtomicRcBox<T> {\n         do task::unkillable {\n             unsafe {\n                 let mut this = this.take();\n-                let mut data: ~AtomicRcBoxData<T> = cast::transmute(this.data);\n+                let mut data: ~ArcData<T> = cast::transmute(this.data);\n                 // Set up the unwrap protocol.\n                 let (p1,c1) = comm::oneshot(); // ()\n                 let (p2,c2) = comm::oneshot(); // bool\n@@ -139,7 +139,7 @@ impl<T: Send> UnsafeAtomicRcBox<T> {\n                         // We were the last owner. Can unwrap immediately.\n                         // AtomicOption's destructor will free the server endpoint.\n                         // FIXME(#3224): it should be like this\n-                        // let ~AtomicRcBoxData { data: user_data, _ } = data;\n+                        // let ~ArcData { data: user_data, _ } = data;\n                         // user_data\n                         data.data.take_unwrap()\n                     } else {\n@@ -154,7 +154,7 @@ impl<T: Send> UnsafeAtomicRcBox<T> {\n                             let (c2, data) = c2_and_data.take();\n                             c2.send(true);\n                             // FIXME(#3224): it should be like this\n-                            // let ~AtomicRcBoxData { data: user_data, _ } = data;\n+                            // let ~ArcData { data: user_data, _ } = data;\n                             // user_data\n                             let mut data = data;\n                             data.data.take_unwrap()\n@@ -183,10 +183,10 @@ impl<T: Send> UnsafeAtomicRcBox<T> {\n \n     /// As unwrap above, but without blocking. Returns 'Left(self)' if this is\n     /// not the last reference; 'Right(unwrapped_data)' if so.\n-    pub fn try_unwrap(self) -> Either<UnsafeAtomicRcBox<T>, T> {\n+    pub fn try_unwrap(self) -> Either<UnsafeArc<T>, T> {\n         unsafe {\n             let mut this = self; // FIXME(#4330) mutable self\n-            let mut data: ~AtomicRcBoxData<T> = cast::transmute(this.data);\n+            let mut data: ~ArcData<T> = cast::transmute(this.data);\n             // This can of course race with anybody else who has a handle, but in\n             // such a case, the returned count will always be at least 2. If we\n             // see 1, no race was possible. All that matters is 1 or not-1.\n@@ -209,27 +209,27 @@ impl<T: Send> UnsafeAtomicRcBox<T> {\n     }\n }\n \n-impl<T: Send> Clone for UnsafeAtomicRcBox<T> {\n-    fn clone(&self) -> UnsafeAtomicRcBox<T> {\n+impl<T: Send> Clone for UnsafeArc<T> {\n+    fn clone(&self) -> UnsafeArc<T> {\n         unsafe {\n-            let mut data: ~AtomicRcBoxData<T> = cast::transmute(self.data);\n+            let mut data: ~ArcData<T> = cast::transmute(self.data);\n             // This barrier might be unnecessary, but I'm not sure...\n             let old_count = data.count.fetch_add(1, Acquire);\n             assert!(old_count >= 1);\n             cast::forget(data);\n-            return UnsafeAtomicRcBox { data: self.data };\n+            return UnsafeArc { data: self.data };\n         }\n     }\n }\n \n #[unsafe_destructor]\n-impl<T> Drop for UnsafeAtomicRcBox<T>{\n+impl<T> Drop for UnsafeArc<T>{\n     fn drop(&self) {\n         unsafe {\n             if self.data.is_null() {\n                 return; // Happens when destructing an unwrapper's handle.\n             }\n-            let mut data: ~AtomicRcBoxData<T> = cast::transmute(self.data);\n+            let mut data: ~ArcData<T> = cast::transmute(self.data);\n             // Must be acquire+release, not just release, to make sure this\n             // doesn't get reordered to after the unwrapper pointer load.\n             let old_count = data.count.fetch_sub(1, SeqCst);\n@@ -355,7 +355,7 @@ struct ExData<T> {\n  * need to block or deschedule while accessing shared state, use extra::sync::RWArc.\n  */\n pub struct Exclusive<T> {\n-    x: UnsafeAtomicRcBox<ExData<T>>\n+    x: UnsafeArc<ExData<T>>\n }\n \n impl<T:Send> Clone for Exclusive<T> {\n@@ -373,7 +373,7 @@ impl<T:Send> Exclusive<T> {\n             data: user_data\n         };\n         Exclusive {\n-            x: UnsafeAtomicRcBox::new(data)\n+            x: UnsafeArc::new(data)\n         }\n     }\n \n@@ -441,7 +441,7 @@ mod tests {\n     use comm;\n     use option::*;\n     use prelude::*;\n-    use super::{Exclusive, UnsafeAtomicRcBox, atomically};\n+    use super::{Exclusive, UnsafeArc, atomically};\n     use task;\n     use util;\n \n@@ -506,44 +506,44 @@ mod tests {\n     #[test]\n     fn arclike_newN() {\n         // Tests that the many-refcounts-at-once constructors don't leak.\n-        let _ = UnsafeAtomicRcBox::new2(~~\"hello\");\n-        let x = UnsafeAtomicRcBox::newN(~~\"hello\", 0);\n+        let _ = UnsafeArc::new2(~~\"hello\");\n+        let x = UnsafeArc::newN(~~\"hello\", 0);\n         assert_eq!(x.len(), 0)\n-        let x = UnsafeAtomicRcBox::newN(~~\"hello\", 1);\n+        let x = UnsafeArc::newN(~~\"hello\", 1);\n         assert_eq!(x.len(), 1)\n-        let x = UnsafeAtomicRcBox::newN(~~\"hello\", 10);\n+        let x = UnsafeArc::newN(~~\"hello\", 10);\n         assert_eq!(x.len(), 10)\n     }\n \n     #[test]\n     fn arclike_cloneN() {\n         // Tests that the many-refcounts-at-once special-clone doesn't leak.\n-        let x = UnsafeAtomicRcBox::new(~~\"hello\");\n+        let x = UnsafeArc::new(~~\"hello\");\n         let x = x.cloneN(0);\n         assert_eq!(x.len(), 0);\n-        let x = UnsafeAtomicRcBox::new(~~\"hello\");\n+        let x = UnsafeArc::new(~~\"hello\");\n         let x = x.cloneN(1);\n         assert_eq!(x.len(), 1);\n-        let x = UnsafeAtomicRcBox::new(~~\"hello\");\n+        let x = UnsafeArc::new(~~\"hello\");\n         let x = x.cloneN(10);\n         assert_eq!(x.len(), 10);\n     }\n \n     #[test]\n     fn arclike_unwrap_basic() {\n-        let x = UnsafeAtomicRcBox::new(~~\"hello\");\n+        let x = UnsafeArc::new(~~\"hello\");\n         assert!(x.unwrap() == ~~\"hello\");\n     }\n \n     #[test]\n     fn arclike_try_unwrap() {\n-        let x = UnsafeAtomicRcBox::new(~~\"hello\");\n+        let x = UnsafeArc::new(~~\"hello\");\n         assert!(x.try_unwrap().expect_right(\"try_unwrap failed\") == ~~\"hello\");\n     }\n \n     #[test]\n     fn arclike_try_unwrap_fail() {\n-        let x = UnsafeAtomicRcBox::new(~~\"hello\");\n+        let x = UnsafeArc::new(~~\"hello\");\n         let x2 = x.clone();\n         let left_x = x.try_unwrap();\n         assert!(left_x.is_left());\n@@ -554,7 +554,7 @@ mod tests {\n     #[test]\n     fn arclike_try_unwrap_unwrap_race() {\n         // When an unwrap and a try_unwrap race, the unwrapper should always win.\n-        let x = UnsafeAtomicRcBox::new(~~\"hello\");\n+        let x = UnsafeArc::new(~~\"hello\");\n         let x2 = Cell::new(x.clone());\n         let (p,c) = comm::stream();\n         do task::spawn {"}]}