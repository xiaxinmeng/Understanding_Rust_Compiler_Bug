{"sha": "a83b64d15dd8e4ad175fec976772a624437eb9b1", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE4M2I2NGQxNWRkOGU0YWQxNzVmZWM5NzY3NzJhNjI0NDM3ZWI5YjE=", "commit": {"author": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-06-28T19:53:59Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2011-06-28T22:25:47Z"}, "message": "Rework how linkage attributes are determined\n\nThe meta items within a crate's link attribute are used in linkage:\n\n #[link(name = \"std\",\n        vers = \"1.0\",\n        custom = \"whatever\")];\n\nName and vers are treated specially, and everything else is hashed together\ninto the crate meta hash.\n\nIssue #487", "tree": {"sha": "9ebccccddbfa0443c7032966d07d2c518c09acae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9ebccccddbfa0443c7032966d07d2c518c09acae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a83b64d15dd8e4ad175fec976772a624437eb9b1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a83b64d15dd8e4ad175fec976772a624437eb9b1", "html_url": "https://github.com/rust-lang/rust/commit/a83b64d15dd8e4ad175fec976772a624437eb9b1", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a83b64d15dd8e4ad175fec976772a624437eb9b1/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0608e277b62bb96de225bfae404b3fcfef6253c4", "url": "https://api.github.com/repos/rust-lang/rust/commits/0608e277b62bb96de225bfae404b3fcfef6253c4", "html_url": "https://github.com/rust-lang/rust/commit/0608e277b62bb96de225bfae404b3fcfef6253c4"}], "stats": {"total": 451, "additions": 322, "deletions": 129}, "files": [{"sha": "1c1bdee8747864fecc592609ca29619726797501", "filename": "src/comp/back/link.rs", "status": "modified", "additions": 45, "deletions": 63, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/a83b64d15dd8e4ad175fec976772a624437eb9b1/src%2Fcomp%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a83b64d15dd8e4ad175fec976772a624437eb9b1/src%2Fcomp%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Flink.rs?ref=a83b64d15dd8e4ad175fec976772a624437eb9b1", "patch": "@@ -1,6 +1,7 @@\n \n import driver::session;\n import lib::llvm::llvm;\n+import middle::attr;\n import middle::trans;\n import middle::ty;\n import std::str;\n@@ -274,57 +275,38 @@ mod write {\n  *    system linkers understand.\n  *\n  */\n-iter crate_export_metas(&ast::crate c) -> @ast::meta_item {\n-    // FIXME: Need to identify exported attributes as described above,\n-    // reevaluate how the above strategy fits in with attributes\n-    for (ast::attribute attr in c.node.attrs) {\n-        put @attr.node.value;\n-    }\n-}\n-\n-iter crate_local_metas(&ast::crate c) -> @ast::meta_item {\n-    // FIXME: As above\n-}\n-\n-fn get_crate_meta_export(&session::session sess, &ast::crate c, str k,\n-                         str default, bool warn_default) -> str {\n-    let vec[@ast::meta_item] v = [];\n-    for each (@ast::meta_item mi in crate_export_metas(c)) {\n-        // FIXME (#487): Support all variants of meta_item\n-        alt (mi.node) {\n-            case (ast::meta_name_value(?name, ?value)) {\n-                if (name == k) { v += [mi]; }\n+type link_metas = rec(option::t[str] name,\n+                      option::t[str] vers,\n+                      vec[@ast::meta_item] cmh_items);\n+\n+fn crate_link_metas(&ast::crate c) -> link_metas {\n+    let option::t[str] name = none;\n+    let option::t[str] vers = none;\n+    let vec[@ast::meta_item] cmh_items = [];\n+    for (@ast::meta_item meta in\n+             attr::find_linkage_metas(c.node.attrs)) {\n+        alt (meta.node) {\n+            case (ast::meta_name_value(\"name\", ?v)) {\n+                // FIXME: Should probably warn about duplicate name items\n+                name = some(v);\n             }\n-            case (_) {}\n-        }\n-    }\n-    alt (vec::len(v)) {\n-        case (0u) {\n-            if (warn_default) {\n-                sess.warn(#fmt(\"missing meta '%s', using '%s' as default\", k,\n-                               default));\n+            case (ast::meta_name_value(\"value\", ?v)) {\n+                // FIXME: Should probably warn about duplicate value items\n+                vers = some(v);\n             }\n-            ret default;\n-        }\n-        case (1u) {\n-            alt (v.(0).node) {\n-                case (ast::meta_name_value(_, ?value)) {\n-                    ret value;\n-                }\n-                case (_) {\n-                    ret default;\n-                }\n+            case (_) {\n+                cmh_items += [meta];\n             }\n         }\n-        case (_) {\n-            sess.span_fatal(v.(1).span, #fmt(\"duplicate meta '%s'\", k));\n-        }\n     }\n+    ret rec(name = name,\n+            vers = vers,\n+            cmh_items = cmh_items);\n }\n \n-\n // This calculates CMH as defined above\n fn crate_meta_extras_hash(sha1 sha, &ast::crate crate) -> str {\n+    // FIXME (#487) Move this sorting stuff into middle::attr\n     fn lteq(&@ast::meta_item ma, &@ast::meta_item mb) -> bool {\n         fn key(&@ast::meta_item m) -> ast::ident {\n             alt (m.node) {\n@@ -342,18 +324,10 @@ fn crate_meta_extras_hash(sha1 sha, &ast::crate crate) -> str {\n         ret key(ma) <= key(mb);\n     }\n     fn len_and_str(&str s) -> str { ret #fmt(\"%u_%s\", str::byte_len(s), s); }\n+\n     let vec[mutable @ast::meta_item] v = [mutable ];\n-    for each (@ast::meta_item mi in crate_export_metas(crate)) {\n-        alt (mi.node) {\n-            case (ast::meta_name_value(?name, _)) {\n-                if (name != \"name\" && name != \"vers\") {\n-                    v += [mutable mi];\n-                }\n-            }\n-            case (_) {\n-                v += [mutable mi];\n-            }\n-        }\n+    for (@ast::meta_item mi in crate_link_metas(crate).cmh_items) {\n+        v += [mutable mi];\n     }\n     sort::quick_sort(lteq, v);\n     sha.reset();\n@@ -367,24 +341,32 @@ fn crate_meta_extras_hash(sha1 sha, &ast::crate crate) -> str {\n             case (ast::meta_word(?name)) {\n                 sha.input_str(len_and_str(name));\n             }\n-            case (_) {}\n+            case (ast::meta_list(_, _)) {\n+                fail \"unimplemented meta_item variant\";\n+            }\n         }\n     }\n     ret truncated_sha1_result(sha);\n }\n \n-fn crate_meta_name(&session::session sess, &ast::crate crate, &str output) ->\n-   str {\n-    auto os = str::split(fs::basename(output), '.' as u8);\n-    assert (vec::len(os) >= 2u);\n-    vec::pop(os);\n-    ret get_crate_meta_export(sess, crate, \"name\", str::connect(os, \".\"),\n-                              sess.get_opts().shared);\n+fn crate_meta_name(&session::session sess, &ast::crate crate,\n+                   &str output) -> str {\n+    ret alt (crate_link_metas(crate).name) {\n+        case (some(?v)) { v }\n+        case (none) {\n+            auto os = str::split(fs::basename(output), '.' as u8);\n+            assert (vec::len(os) >= 2u);\n+            vec::pop(os);\n+            str::connect(os, \".\")\n+        }\n+    };\n }\n \n fn crate_meta_vers(&session::session sess, &ast::crate crate) -> str {\n-    ret get_crate_meta_export(sess, crate, \"vers\", \"0.0\",\n-                              sess.get_opts().shared);\n+    ret alt (crate_link_metas(crate).vers) {\n+        case (some(?v)) { v }\n+        case (none) { \"0.0\" }\n+    };\n }\n \n fn truncated_sha1_result(sha1 sha) -> str {"}, {"sha": "6c23a7d0568188363e2944f61a5f144bc70966ca", "filename": "src/comp/metadata/creader.rs", "status": "modified", "additions": 15, "deletions": 34, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/a83b64d15dd8e4ad175fec976772a624437eb9b1/src%2Fcomp%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a83b64d15dd8e4ad175fec976772a624437eb9b1/src%2Fcomp%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fcreader.rs?ref=a83b64d15dd8e4ad175fec976772a624437eb9b1", "patch": "@@ -6,6 +6,7 @@ import lib::llvm::False;\n import lib::llvm::llvm;\n import lib::llvm::mk_object_file;\n import lib::llvm::mk_section_iter;\n+import middle::attr;\n import middle::resolve;\n import middle::walk;\n import back::x86;\n@@ -19,42 +20,24 @@ import std::option;\n import std::option::none;\n import std::option::some;\n import std::map::hashmap;\n+import pretty::pprust;\n import tags::*;\n \n export read_crates;\n export list_file_metadata;\n \n-fn metadata_matches(hashmap[str, str] mm, &vec[@ast::meta_item] metas) ->\n-   bool {\n-    log #fmt(\"matching %u metadata requirements against %u metadata items\",\n-             vec::len(metas), mm.size());\n-    for (@ast::meta_item mi in metas) {\n-        alt (mi.node) {\n-            case (ast::meta_name_value(?name, ?value)) {\n-                alt (mm.find(name)) {\n-                    case (some(?v)) {\n-                        if (v == value) {\n-                            log #fmt(\"matched '%s': '%s'\", name,\n-                                     value);\n-                        } else {\n-                            log #fmt(\"missing '%s': '%s' (got '%s')\",\n-                                     name,\n-                                     value, v);\n-                            ret false;\n-                        }\n-                    }\n-                    case (none) {\n-                        log #fmt(\"missing '%s': '%s'\",\n-                                 name, value);\n-                        ret false;\n-                    }\n-                }\n-            }\n-            case (_) {\n-                // FIXME (#487): Support all forms of meta_item\n-                log_err \"unimplemented meta_item variant in metadata_matches\";\n-                ret false;\n-            }\n+fn metadata_matches(&vec[u8] crate_data,\n+                    &vec[@ast::meta_item] metas) -> bool {\n+    auto attrs = decoder::get_crate_attributes(crate_data);\n+    auto linkage_metas = attr::find_linkage_metas(attrs);\n+\n+    log #fmt(\"matching %u metadata requirements against %u items\",\n+             vec::len(metas), vec::len(linkage_metas));\n+\n+    for (@ast::meta_item needed in metas) {\n+        if (!attr::contains(linkage_metas, needed)) {\n+            log #fmt(\"missing %s\", pprust::meta_item_to_str(*needed));\n+            ret false;\n         }\n     }\n     ret true;\n@@ -106,9 +89,7 @@ fn find_library_crate(&session::session sess, &ast::ident ident,\n             }\n             alt (get_metadata_section(path)) {\n                 case (option::some(?cvec)) {\n-                    auto mm = decoder::get_exported_metadata(sess,\n-                                                             path, cvec);\n-                    if (!metadata_matches(mm, metas)) {\n+                    if (!metadata_matches(cvec, metas)) {\n                         log #fmt(\"skipping %s, metadata doesn't match\", path);\n                         cont;\n                     }"}, {"sha": "9d0efd213370ca893335b8f23f208d726d338625", "filename": "src/comp/metadata/decoder.rs", "status": "modified", "additions": 2, "deletions": 21, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/a83b64d15dd8e4ad175fec976772a624437eb9b1/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a83b64d15dd8e4ad175fec976772a624437eb9b1/src%2Fcomp%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fdecoder.rs?ref=a83b64d15dd8e4ad175fec976772a624437eb9b1", "patch": "@@ -20,6 +20,7 @@ export get_tag_variants;\n export get_type;\n export lookup_defs;\n export get_type;\n+export get_crate_attributes;\n export list_crate_metadata;\n export get_exported_metadata;\n \n@@ -294,7 +295,6 @@ fn get_attributes(&ebml::doc md) -> vec[ast::attribute] {\n                 auto meta_items = get_meta_items(attr_doc);\n                 // Currently it's only possible to have a single meta item on\n                 // an attribute\n-                log_err vec::len(meta_items);\n                 assert (vec::len(meta_items) == 1u);\n                 auto meta_item = meta_items.(0);\n                 attrs += [rec(node=rec(style=ast::attr_outer,\n@@ -316,7 +316,7 @@ fn list_meta_items(&ebml::doc meta_items, io::writer out) {\n fn list_crate_attributes(&ebml::doc md, io::writer out) {\n     out.write_str(\"=Crate=\");\n \n-    // FIXME: This is transitional until attributes are snapshotted\n+    // FIXME (#487): This is transitional until attributes are snapshotted\n     out.write_str(\"old-style:\\n\");\n     auto meta_items = ebml::get_doc(md, tag_meta_export);\n     list_meta_items(meta_items, out);\n@@ -359,25 +359,6 @@ fn list_crate_metadata(vec[u8] bytes, io::writer out) {\n     list_crate_items(bytes, md, out);\n }\n \n-fn get_exported_metadata(&session::session sess, &str path, &vec[u8] data) ->\n-   hashmap[str, str] {\n-    auto meta_items =\n-        ebml::get_doc(ebml::new_doc(data), tag_meta_export);\n-    auto mm = common::new_str_hash[str]();\n-    for each (ebml::doc m in\n-             ebml::tagged_docs(meta_items, tag_meta_item_name_value)) {\n-        auto nd = ebml::get_doc(m, tag_meta_item_name);\n-        auto vd = ebml::get_doc(m, tag_meta_item_value);\n-        auto n = str::unsafe_from_bytes(ebml::doc_data(nd));\n-        auto v = str::unsafe_from_bytes(ebml::doc_data(vd));\n-        log #fmt(\"metadata in %s: %s = %s\", path, n, v);\n-        if (!mm.insert(n, v)) {\n-            sess.warn(#fmt(\"Duplicate metadata item in %s: %s\", path, n));\n-        }\n-    }\n-    ret mm;\n-}\n-\n // Local Variables:\n // mode: rust\n // fill-column: 78;"}, {"sha": "63d56a04a72d7e639ced937a8e9830e061a049b0", "filename": "src/comp/metadata/encoder.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/a83b64d15dd8e4ad175fec976772a624437eb9b1/src%2Fcomp%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a83b64d15dd8e4ad175fec976772a624437eb9b1/src%2Fcomp%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmetadata%2Fencoder.rs?ref=a83b64d15dd8e4ad175fec976772a624437eb9b1", "patch": "@@ -13,8 +13,6 @@ import tags::*;\n import middle::trans::crate_ctxt;\n import middle::trans::node_id_type;\n import middle::ty;\n-import back::link::crate_export_metas;\n-import back::link::crate_local_metas;\n \n export def_to_str;\n export hash_path;\n@@ -459,16 +457,20 @@ fn encode_attributes(&ebml::writer ebml_w, &vec[attribute] attrs) {\n     ebml::end_tag(ebml_w);\n }\n \n+// FIXME (#487): Transitional\n fn encode_meta_items(&ebml::writer ebml_w, &crate crate) {\n+    auto name = middle::attr::find_attrs_by_name(crate.node.attrs,\n+                                                 \"name\");\n+    auto value = middle::attr::find_attrs_by_name(crate.node.attrs,\n+                                                 \"value\");\n+    auto name_and_val = middle::attr::attr_metas(name + value);\n+\n     ebml::start_tag(ebml_w, tag_meta_export);\n-    for each (@meta_item mi in crate_export_metas(crate)) {\n+    for (@meta_item mi in name_and_val) {\n         encode_meta_item(ebml_w, *mi);\n     }\n     ebml::end_tag(ebml_w);\n     ebml::start_tag(ebml_w, tag_meta_local);\n-    for each (@meta_item mi in crate_local_metas(crate)) {\n-        encode_meta_item(ebml_w, *mi);\n-    }\n     ebml::end_tag(ebml_w);\n }\n "}, {"sha": "d255291c1d40648e82d2fdcde2060717882726f1", "filename": "src/comp/middle/attr.rs", "status": "modified", "additions": 39, "deletions": 1, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/a83b64d15dd8e4ad175fec976772a624437eb9b1/src%2Fcomp%2Fmiddle%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a83b64d15dd8e4ad175fec976772a624437eb9b1/src%2Fcomp%2Fmiddle%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fattr.rs?ref=a83b64d15dd8e4ad175fec976772a624437eb9b1", "patch": "@@ -2,8 +2,10 @@ import std::vec;\n import std::option;\n import front::ast;\n \n-export get_linkage_metas;\n+export attr_metas;\n+export find_linkage_metas;\n export find_attrs_by_name;\n+export contains;\n \n // From a list of crate attributes get only the meta_items that impact crate\n // linkage\n@@ -62,6 +64,42 @@ fn get_meta_item_name(&@ast::meta_item meta) -> ast::ident {\n     }\n }\n \n+fn attr_meta(&ast::attribute attr) -> @ast::meta_item { @attr.node.value }\n+\n+fn attr_metas(&vec[ast::attribute] attrs) -> vec[@ast::meta_item] {\n+    ret vec::map(attr_meta, attrs);\n+}\n+\n+fn eq(@ast::meta_item a, @ast::meta_item b) -> bool {\n+    ret alt (a.node) {\n+        case (ast::meta_word(?na)) {\n+            alt (b.node) {\n+                case(ast::meta_word(?nb)) { na == nb }\n+                case(_) { false }\n+            }\n+        }\n+        case (ast::meta_name_value(?na, ?va)) {\n+            alt (b.node) {\n+                case (ast::meta_name_value(?nb, ?vb)) { na == nb && va == vb }\n+                case (_) { false }\n+            }\n+        }\n+        case (ast::meta_list(?na, ?la)) {\n+            // FIXME (#487): This involves probably sorting the list by name\n+            fail \"unimplemented meta_item variant\"\n+        }\n+    }\n+}\n+\n+fn contains(&vec[@ast::meta_item] haystack, @ast::meta_item needle) -> bool {\n+    for (@ast::meta_item item in haystack) {\n+        if (eq(item, needle)) {\n+            ret true;\n+        }\n+    }\n+    ret false;\n+}\n+\n //\n // Local Variables:\n // mode: rust"}, {"sha": "c4687e6a000bf80958fb91a519f278666fc6a323", "filename": "src/lib/std.rc", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a83b64d15dd8e4ad175fec976772a624437eb9b1/src%2Flib%2Fstd.rc", "raw_url": "https://github.com/rust-lang/rust/raw/a83b64d15dd8e4ad175fec976772a624437eb9b1/src%2Flib%2Fstd.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib%2Fstd.rc?ref=a83b64d15dd8e4ad175fec976772a624437eb9b1", "patch": "@@ -1,7 +1,9 @@\n-#[name = \"std\"];\n-#[vers = \"0.1\"];\n-#[uuid = \"122bed0b-c19b-4b82-b0b7-7ae8aead7297\"];\n-#[url = \"http://rust-lang.org/src/std\"];\n+\n+#[link(name = \"std\",\n+       vers = \"0.1\",\n+       uuid = \"122bed0b-c19b-4b82-b0b7-7ae8aead7297\",\n+       url = \"http://rust-lang.org/src/std\")];\n+\n #[comment = \"Rust standard library\"];\n #[license = \"BSD\"];\n "}, {"sha": "cf8fc4098f2ea66063317c1516c95e7fdd2350d3", "filename": "src/test/run-pass/item-attributes.rs", "status": "added", "additions": 207, "deletions": 0, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/a83b64d15dd8e4ad175fec976772a624437eb9b1/src%2Ftest%2Frun-pass%2Fitem-attributes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a83b64d15dd8e4ad175fec976772a624437eb9b1/src%2Ftest%2Frun-pass%2Fitem-attributes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fitem-attributes.rs?ref=a83b64d15dd8e4ad175fec976772a624437eb9b1", "patch": "@@ -0,0 +1,207 @@\n+// xfail-stage0\n+\n+// These are attributes of the implicit crate. Really this just needs to parse\n+// for completeness since .rs files linked from .rc files support this\n+// notation to specify their module's attributes\n+#[attr1 = \"val\"];\n+#[attr2 = \"val\"];\n+#[attr3];\n+#[attr4(attr5)];\n+\n+// Special linkage attributes for the crate\n+#[link(name = \"std\",\n+       vers = \"0.1\",\n+       uuid = \"122bed0b-c19b-4b82-b0b7-7ae8aead7297\",\n+       url = \"http://rust-lang.org/src/std\")];\n+\n+// These are are attributes of the following mod\n+#[attr1 = \"val\"]\n+#[attr2 = \"val\"]\n+mod test_first_item_in_file_mod {\n+}\n+\n+mod test_single_attr_outer {\n+\n+    #[attr = \"val\"]\n+    const int x = 10;\n+\n+    #[attr = \"val\"]\n+    fn f() {}\n+\n+    #[attr = \"val\"]\n+    mod mod1 {\n+    }\n+\n+    #[attr = \"val\"]\n+    native \"rust\" mod rustrt { }\n+\n+    #[attr = \"val\"]\n+    type t = obj { };\n+\n+\n+    #[attr = \"val\"]\n+    obj o() { }\n+}\n+\n+mod test_multi_attr_outer {\n+\n+    #[attr1 = \"val\"]\n+    #[attr2 = \"val\"]\n+    const int x = 10;\n+\n+    #[attr1 = \"val\"]\n+    #[attr2 = \"val\"]\n+    fn f() {}\n+\n+    #[attr1 = \"val\"]\n+    #[attr2 = \"val\"]\n+    mod mod1 {\n+    }\n+\n+    #[attr1 = \"val\"]\n+    #[attr2 = \"val\"]\n+    native \"rust\" mod rustrt { }\n+\n+    #[attr1 = \"val\"]\n+    #[attr2 = \"val\"]\n+    type t = obj { };\n+\n+\n+    #[attr1 = \"val\"]\n+    #[attr2 = \"val\"]\n+    obj o() { }\n+}\n+\n+mod test_stmt_single_attr_outer {\n+\n+    fn f() {\n+\n+        #[attr = \"val\"]\n+        const int x = 10;\n+\n+        #[attr = \"val\"]\n+        fn f() {}\n+\n+        /* FIXME: Issue #493\n+        #[attr = \"val\"]\n+        mod mod1 {\n+        }\n+\n+        #[attr = \"val\"]\n+        native \"rust\" mod rustrt {\n+        }\n+        */\n+\n+        #[attr = \"val\"]\n+        type t = obj { };\n+\n+        #[attr = \"val\"]\n+        obj o() { }\n+\n+    }\n+}\n+\n+mod test_stmt_multi_attr_outer {\n+\n+    fn f() {\n+\n+        #[attr1 = \"val\"]\n+        #[attr2 = \"val\"]\n+        const int x = 10;\n+\n+        #[attr1 = \"val\"]\n+        #[attr2 = \"val\"]\n+        fn f() {}\n+\n+        /* FIXME: Issue #493\n+        #[attr1 = \"val\"]\n+        #[attr2 = \"val\"]\n+        mod mod1 {\n+        }\n+\n+        #[attr1 = \"val\"]\n+        #[attr2 = \"val\"]\n+        native \"rust\" mod rustrt {\n+        }\n+        */\n+\n+        #[attr1 = \"val\"]\n+        #[attr2 = \"val\"]\n+        type t = obj { };\n+\n+        #[attr1 = \"val\"]\n+        #[attr2 = \"val\"]\n+        obj o() { }\n+\n+    }\n+}\n+\n+mod test_attr_inner {\n+\n+    mod m {\n+        // This is an attribute of mod m\n+        #[attr = \"val\"];\n+    }\n+}\n+\n+mod test_attr_inner_then_outer {\n+\n+    mod m {\n+        // This is an attribute of mod m\n+        #[attr = \"val\"];\n+        // This is an attribute of fn f\n+        #[attr = \"val\"]\n+        fn f() {\n+        }\n+    }\n+}\n+\n+mod test_attr_inner_then_outer_multi {\n+    mod m {\n+        // This is an attribute of mod m\n+        #[attr1 = \"val\"];\n+        #[attr2 = \"val\"];\n+        // This is an attribute of fn f\n+        #[attr1 = \"val\"]\n+        #[attr2 = \"val\"]\n+        fn f() {\n+        }\n+    }\n+}\n+\n+mod test_distinguish_syntax_ext {\n+\n+    use std;\n+\n+    fn f() {\n+        #fmt(\"test%s\", \"s\");\n+        #[attr = \"val\"]\n+        fn g() {\n+        }\n+    }\n+}\n+\n+mod test_other_forms {\n+    #[attr]\n+    #[attr(word)]\n+    #[attr(attr(word))]\n+    #[attr(key1 = \"val\",\n+           key2 = \"val\",\n+           attr)]\n+    fn f() {\n+    }\n+}\n+\n+fn main() {\n+}\n+\n+//\n+// Local Variables:\n+// mode: rust\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+// End:\n+//"}]}