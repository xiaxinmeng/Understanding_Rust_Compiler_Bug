{"sha": "09395f626b2ff7378fb250300654b1817953a390", "node_id": "C_kwDOAAsO6NoAKDA5Mzk1ZjYyNmIyZmY3Mzc4ZmIyNTAzMDA2NTRiMTgxNzk1M2EzOTA", "commit": {"author": {"name": "Alexis Beingessner", "email": "a.beingessner@gmail.com", "date": "2022-03-23T01:29:38Z"}, "committer": {"name": "Aria Beingessner", "email": "a.beingessner@gmail.com", "date": "2022-03-30T00:18:27Z"}, "message": "Make some linux/unix APIs better conform to strict provenance.\n\nThis largely makes the stdlib conform to strict provenance on Ubuntu.\nSome hairier things have been left alone for now.", "tree": {"sha": "92ff9d059a640e5638062b633f1e62a2665701a9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/92ff9d059a640e5638062b633f1e62a2665701a9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/09395f626b2ff7378fb250300654b1817953a390", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/09395f626b2ff7378fb250300654b1817953a390", "html_url": "https://github.com/rust-lang/rust/commit/09395f626b2ff7378fb250300654b1817953a390", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/09395f626b2ff7378fb250300654b1817953a390/comments", "author": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "68643603ad00900d6a91a0dae90bb2ebb4f0db48", "url": "https://api.github.com/repos/rust-lang/rust/commits/68643603ad00900d6a91a0dae90bb2ebb4f0db48", "html_url": "https://github.com/rust-lang/rust/commit/68643603ad00900d6a91a0dae90bb2ebb4f0db48"}], "stats": {"total": 75, "additions": 39, "deletions": 36}, "files": [{"sha": "3b0922ad16f2566480f802c055876d0050af2698", "filename": "library/std/src/backtrace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09395f626b2ff7378fb250300654b1817953a390/library%2Fstd%2Fsrc%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09395f626b2ff7378fb250300654b1817953a390/library%2Fstd%2Fsrc%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fbacktrace.rs?ref=09395f626b2ff7378fb250300654b1817953a390", "patch": "@@ -493,7 +493,7 @@ impl RawFrame {\n         match self {\n             RawFrame::Actual(frame) => frame.ip(),\n             #[cfg(test)]\n-            RawFrame::Fake => ptr::invalid_mut(1),\n+            RawFrame::Fake => crate::ptr::invalid_mut(1),\n         }\n     }\n }"}, {"sha": "c323161d76537d4956a3507114ceb4bde87541ca", "filename": "library/std/src/os/unix/net/addr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/09395f626b2ff7378fb250300654b1817953a390/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Faddr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09395f626b2ff7378fb250300654b1817953a390/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Faddr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Funix%2Fnet%2Faddr.rs?ref=09395f626b2ff7378fb250300654b1817953a390", "patch": "@@ -17,8 +17,8 @@ mod libc {\n \n fn sun_path_offset(addr: &libc::sockaddr_un) -> usize {\n     // Work with an actual instance of the type since using a null pointer is UB\n-    let base = addr as *const _ as usize;\n-    let path = &addr.sun_path as *const _ as usize;\n+    let base = (addr as *const libc::sockaddr_un).addr();\n+    let path = (&addr.sun_path as *const i8).addr();\n     path - base\n }\n "}, {"sha": "a3e4f8ff56aeed946a08e29dac1479902b88cf84", "filename": "library/std/src/sys/unix/memchr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/09395f626b2ff7378fb250300654b1817953a390/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmemchr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09395f626b2ff7378fb250300654b1817953a390/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmemchr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fmemchr.rs?ref=09395f626b2ff7378fb250300654b1817953a390", "patch": "@@ -9,7 +9,7 @@ pub fn memchr(needle: u8, haystack: &[u8]) -> Option<usize> {\n             haystack.len(),\n         )\n     };\n-    if p.is_null() { None } else { Some(p as usize - (haystack.as_ptr() as usize)) }\n+    if p.is_null() { None } else { Some(p.addr() - haystack.as_ptr().addr()) }\n }\n \n pub fn memrchr(needle: u8, haystack: &[u8]) -> Option<usize> {\n@@ -26,7 +26,7 @@ pub fn memrchr(needle: u8, haystack: &[u8]) -> Option<usize> {\n                 haystack.len(),\n             )\n         };\n-        if p.is_null() { None } else { Some(p as usize - (haystack.as_ptr() as usize)) }\n+        if p.is_null() { None } else { Some(p.addr() - haystack.as_ptr().addr()) }\n     }\n \n     #[cfg(not(target_os = \"linux\"))]"}, {"sha": "be70d00cb1ace5c622849ed2242f5b1468d2185c", "filename": "library/std/src/sys/unix/thread.rs", "status": "modified", "additions": 25, "deletions": 23, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/09395f626b2ff7378fb250300654b1817953a390/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09395f626b2ff7378fb250300654b1817953a390/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fthread.rs?ref=09395f626b2ff7378fb250300654b1817953a390", "patch": "@@ -505,24 +505,24 @@ pub mod guard {\n     #[cfg(target_os = \"macos\")]\n     unsafe fn get_stack_start() -> Option<*mut libc::c_void> {\n         let th = libc::pthread_self();\n-        let stackaddr =\n-            libc::pthread_get_stackaddr_np(th) as usize - libc::pthread_get_stacksize_np(th);\n-        Some(stackaddr as *mut libc::c_void)\n+        let stackptr = libc::pthread_get_stackaddr_np(th);\n+        Some(stackptr.map_addr(|addr| addr - libc::pthread_get_stacksize_np(th)))\n     }\n \n     #[cfg(target_os = \"openbsd\")]\n     unsafe fn get_stack_start() -> Option<*mut libc::c_void> {\n         let mut current_stack: libc::stack_t = crate::mem::zeroed();\n         assert_eq!(libc::pthread_stackseg_np(libc::pthread_self(), &mut current_stack), 0);\n \n+        let stack_ptr = current_stack.ss_sp;\n         let stackaddr = if libc::pthread_main_np() == 1 {\n             // main thread\n-            current_stack.ss_sp as usize - current_stack.ss_size + PAGE_SIZE.load(Ordering::Relaxed)\n+            stack_ptr.addr() - current_stack.ss_size + PAGE_SIZE.load(Ordering::Relaxed)\n         } else {\n             // new thread\n-            current_stack.ss_sp as usize - current_stack.ss_size\n+            stack_ptr.addr() - current_stack.ss_size\n         };\n-        Some(stackaddr as *mut libc::c_void)\n+        Some(stack_ptr.with_addr(stack_addr))\n     }\n \n     #[cfg(any(\n@@ -557,19 +557,20 @@ pub mod guard {\n     unsafe fn get_stack_start_aligned() -> Option<*mut libc::c_void> {\n         let page_size = PAGE_SIZE.load(Ordering::Relaxed);\n         assert!(page_size != 0);\n-        let stackaddr = get_stack_start()?;\n+        let stackptr = get_stack_start()?;\n+        let stackaddr = stackptr.addr();\n \n         // Ensure stackaddr is page aligned! A parent process might\n         // have reset RLIMIT_STACK to be non-page aligned. The\n         // pthread_attr_getstack() reports the usable stack area\n         // stackaddr < stackaddr + stacksize, so if stackaddr is not\n         // page-aligned, calculate the fix such that stackaddr <\n         // new_page_aligned_stackaddr < stackaddr + stacksize\n-        let remainder = (stackaddr as usize) % page_size;\n+        let remainder = stackaddr % page_size;\n         Some(if remainder == 0 {\n-            stackaddr\n+            stackptr\n         } else {\n-            ((stackaddr as usize) + page_size - remainder) as *mut libc::c_void\n+            stackptr.with_addr(stackaddr + page_size - remainder)\n         })\n     }\n \n@@ -588,8 +589,8 @@ pub mod guard {\n             // Instead, we'll just note where we expect rlimit to start\n             // faulting, so our handler can report \"stack overflow\", and\n             // trust that the kernel's own stack guard will work.\n-            let stackaddr = get_stack_start_aligned()?;\n-            let stackaddr = stackaddr as usize;\n+            let stackptr = get_stack_start_aligned()?;\n+            let stackaddr = stackptr.addr();\n             Some(stackaddr - page_size..stackaddr)\n         } else if cfg!(all(target_os = \"linux\", target_env = \"musl\")) {\n             // For the main thread, the musl's pthread_attr_getstack\n@@ -602,8 +603,8 @@ pub mod guard {\n             // at the bottom.  If we try to remap the bottom of the stack\n             // ourselves, FreeBSD's guard page moves upwards.  So we'll just use\n             // the builtin guard page.\n-            let stackaddr = get_stack_start_aligned()?;\n-            let guardaddr = stackaddr as usize;\n+            let stackptr = get_stack_start_aligned()?;\n+            let guardaddr = stackptr.addr();\n             // Technically the number of guard pages is tunable and controlled\n             // by the security.bsd.stack_guard_page sysctl, but there are\n             // few reasons to change it from the default.  The default value has\n@@ -620,33 +621,34 @@ pub mod guard {\n             // than the initial mmap() used, so we mmap() here with\n             // read/write permissions and only then mprotect() it to\n             // no permissions at all. See issue #50313.\n-            let stackaddr = get_stack_start_aligned()?;\n+            let stackptr = get_stack_start_aligned()?;\n             let result = mmap(\n-                stackaddr,\n+                stackptr,\n                 page_size,\n                 PROT_READ | PROT_WRITE,\n                 MAP_PRIVATE | MAP_ANON | MAP_FIXED,\n                 -1,\n                 0,\n             );\n-            if result != stackaddr || result == MAP_FAILED {\n+            if result != stackptr || result == MAP_FAILED {\n                 panic!(\"failed to allocate a guard page: {}\", io::Error::last_os_error());\n             }\n \n-            let result = mprotect(stackaddr, page_size, PROT_NONE);\n+            let result = mprotect(stackptr, page_size, PROT_NONE);\n             if result != 0 {\n                 panic!(\"failed to protect the guard page: {}\", io::Error::last_os_error());\n             }\n \n-            let guardaddr = stackaddr as usize;\n+            let guardaddr = stackptr.addr();\n \n             Some(guardaddr..guardaddr + page_size)\n         }\n     }\n \n     #[cfg(any(target_os = \"macos\", target_os = \"openbsd\", target_os = \"solaris\"))]\n     pub unsafe fn current() -> Option<Guard> {\n-        let stackaddr = get_stack_start()? as usize;\n+        let stackptr = get_stack_start()?;\n+        let stackaddr = stackptr.addr();\n         Some(stackaddr - PAGE_SIZE.load(Ordering::Relaxed)..stackaddr)\n     }\n \n@@ -679,11 +681,11 @@ pub mod guard {\n                     panic!(\"there is no guard page\");\n                 }\n             }\n-            let mut stackaddr = crate::ptr::null_mut();\n+            let mut stackptr = crate::ptr::null_mut::<libc::c_void>();\n             let mut size = 0;\n-            assert_eq!(libc::pthread_attr_getstack(&attr, &mut stackaddr, &mut size), 0);\n+            assert_eq!(libc::pthread_attr_getstack(&attr, &mut stackptr, &mut size), 0);\n \n-            let stackaddr = stackaddr as usize;\n+            let stackaddr = stackptr.addr();\n             ret = if cfg!(any(target_os = \"freebsd\", target_os = \"netbsd\")) {\n                 Some(stackaddr - guardsize..stackaddr)\n             } else if cfg!(all(target_os = \"linux\", target_env = \"musl\")) {"}, {"sha": "c9606aec3f6dfb7e466f116f80da8059e0e019f7", "filename": "library/std/src/sys/unix/weak.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/09395f626b2ff7378fb250300654b1817953a390/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fweak.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09395f626b2ff7378fb250300654b1817953a390/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fweak.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fweak.rs?ref=09395f626b2ff7378fb250300654b1817953a390", "patch": "@@ -22,9 +22,10 @@\n // that, we'll just allow that some unix targets don't use this module at all.\n #![allow(dead_code, unused_macros)]\n \n-use crate::ffi::CStr;\n+use crate::ffi::{c_void, CStr};\n use crate::marker::PhantomData;\n use crate::mem;\n+use crate::ptr;\n use crate::sync::atomic::{self, AtomicUsize, Ordering};\n \n // We can use true weak linkage on ELF targets.\n@@ -129,25 +130,25 @@ impl<F> DlsymWeak<F> {\n     // Cold because it should only happen during first-time initialization.\n     #[cold]\n     unsafe fn initialize(&self) -> Option<F> {\n-        assert_eq!(mem::size_of::<F>(), mem::size_of::<usize>());\n+        assert_eq!(mem::size_of::<F>(), mem::size_of::<*mut ()>());\n \n         let val = fetch(self.name);\n         // This synchronizes with the acquire fence in `get`.\n-        self.addr.store(val, Ordering::Release);\n+        self.addr.store(val.addr(), Ordering::Release);\n \n-        match val {\n+        match val.addr() {\n             0 => None,\n-            addr => Some(mem::transmute_copy::<usize, F>(&addr)),\n+            _ => Some(mem::transmute_copy::<*mut c_void, F>(&val)),\n         }\n     }\n }\n \n-unsafe fn fetch(name: &str) -> usize {\n+unsafe fn fetch(name: &str) -> *mut c_void {\n     let name = match CStr::from_bytes_with_nul(name.as_bytes()) {\n         Ok(cstr) => cstr,\n-        Err(..) => return 0,\n+        Err(..) => return ptr::null_mut(),\n     };\n-    libc::dlsym(libc::RTLD_DEFAULT, name.as_ptr()) as usize\n+    libc::dlsym(libc::RTLD_DEFAULT, name.as_ptr())\n }\n \n #[cfg(not(any(target_os = \"linux\", target_os = \"android\")))]"}]}