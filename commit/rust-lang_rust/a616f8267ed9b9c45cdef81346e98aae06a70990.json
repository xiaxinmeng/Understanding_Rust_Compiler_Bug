{"sha": "a616f8267ed9b9c45cdef81346e98aae06a70990", "node_id": "MDY6Q29tbWl0NzI0NzEyOmE2MTZmODI2N2VkOWI5YzQ1Y2RlZjgxMzQ2ZTk4YWFlMDZhNzA5OTA=", "commit": {"author": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2021-02-01T21:30:09Z"}, "committer": {"name": "Mara Bos", "email": "m-ou.se@m-ou.se", "date": "2021-02-03T21:42:53Z"}, "message": "Add lint for `panic!(123)` which is not accepted in Rust 2021.\n\nThis extends the `panic_fmt` lint to warn for all cases where the first\nargument cannot be interpreted as a format string, as will happen in\nRust 2021.\n\nIt suggests to add `\"{}\", ` to format the message as a string. In the\ncase of `std::panic!()`, it also suggests the recently stabilized\n`std::panic::panic_any()` function as an alternative.\n\nIt renames the lint to `non_fmt_panic` to match the lint naming\nguidelines.", "tree": {"sha": "1a0067599ada3571732f0d6b7dba7c93ec59820c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1a0067599ada3571732f0d6b7dba7c93ec59820c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a616f8267ed9b9c45cdef81346e98aae06a70990", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a616f8267ed9b9c45cdef81346e98aae06a70990", "html_url": "https://github.com/rust-lang/rust/commit/a616f8267ed9b9c45cdef81346e98aae06a70990", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a616f8267ed9b9c45cdef81346e98aae06a70990/comments", "author": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "committer": {"login": "m-ou-se", "id": 783247, "node_id": "MDQ6VXNlcjc4MzI0Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/783247?v=4", "gravatar_id": "", "url": "https://api.github.com/users/m-ou-se", "html_url": "https://github.com/m-ou-se", "followers_url": "https://api.github.com/users/m-ou-se/followers", "following_url": "https://api.github.com/users/m-ou-se/following{/other_user}", "gists_url": "https://api.github.com/users/m-ou-se/gists{/gist_id}", "starred_url": "https://api.github.com/users/m-ou-se/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/m-ou-se/subscriptions", "organizations_url": "https://api.github.com/users/m-ou-se/orgs", "repos_url": "https://api.github.com/users/m-ou-se/repos", "events_url": "https://api.github.com/users/m-ou-se/events{/privacy}", "received_events_url": "https://api.github.com/users/m-ou-se/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "120b2a704a60d4341286bd82f6e638c65ca169b6", "url": "https://api.github.com/repos/rust-lang/rust/commits/120b2a704a60d4341286bd82f6e638c65ca169b6", "html_url": "https://github.com/rust-lang/rust/commit/120b2a704a60d4341286bd82f6e638c65ca169b6"}], "stats": {"total": 490, "additions": 310, "deletions": 180}, "files": [{"sha": "638b73c27a8d7c467f99e6dddce83cc37f6212b4", "filename": "compiler/rustc_lint/src/lib.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/a616f8267ed9b9c45cdef81346e98aae06a70990/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a616f8267ed9b9c45cdef81346e98aae06a70990/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flib.rs?ref=a616f8267ed9b9c45cdef81346e98aae06a70990", "patch": "@@ -55,8 +55,8 @@ mod late;\n mod levels;\n mod methods;\n mod non_ascii_idents;\n+mod non_fmt_panic;\n mod nonstandard_style;\n-mod panic_fmt;\n mod passes;\n mod redundant_semicolon;\n mod traits;\n@@ -81,8 +81,8 @@ use builtin::*;\n use internal::*;\n use methods::*;\n use non_ascii_idents::*;\n+use non_fmt_panic::NonPanicFmt;\n use nonstandard_style::*;\n-use panic_fmt::PanicFmt;\n use redundant_semicolon::*;\n use traits::*;\n use types::*;\n@@ -169,7 +169,7 @@ macro_rules! late_lint_passes {\n                 ClashingExternDeclarations: ClashingExternDeclarations::new(),\n                 DropTraitConstraints: DropTraitConstraints,\n                 TemporaryCStringAsPtr: TemporaryCStringAsPtr,\n-                PanicFmt: PanicFmt,\n+                NonPanicFmt: NonPanicFmt,\n             ]\n         );\n     };"}, {"sha": "e98297b692c92d887ec3fec65114f7959d3dcd9a", "filename": "compiler/rustc_lint/src/non_fmt_panic.rs", "status": "added", "additions": 197, "deletions": 0, "changes": 197, "blob_url": "https://github.com/rust-lang/rust/blob/a616f8267ed9b9c45cdef81346e98aae06a70990/compiler%2Frustc_lint%2Fsrc%2Fnon_fmt_panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a616f8267ed9b9c45cdef81346e98aae06a70990/compiler%2Frustc_lint%2Fsrc%2Fnon_fmt_panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnon_fmt_panic.rs?ref=a616f8267ed9b9c45cdef81346e98aae06a70990", "patch": "@@ -0,0 +1,197 @@\n+use crate::{LateContext, LateLintPass, LintContext};\n+use rustc_ast as ast;\n+use rustc_errors::{pluralize, Applicability};\n+use rustc_hir as hir;\n+use rustc_middle::ty;\n+use rustc_parse_format::{ParseMode, Parser, Piece};\n+use rustc_span::{sym, symbol::kw, InnerSpan, Span, Symbol};\n+\n+declare_lint! {\n+    /// The `non_fmt_panic` lint detects `panic!(..)` invocations where the first\n+    /// argument is not a formatting string.\n+    ///\n+    /// ### Example\n+    ///\n+    /// ```rust,no_run\n+    /// panic!(\"{}\");\n+    /// panic!(123);\n+    /// ```\n+    ///\n+    /// {{produces}}\n+    ///\n+    /// ### Explanation\n+    ///\n+    /// In Rust 2018 and earlier, `panic!(x)` directly uses `x` as the message.\n+    /// That means that `panic!(\"{}\")` panics with the message `\"{}\"` instead\n+    /// of using it as a formatting string, and `panic!(123)` will panic with\n+    /// an `i32` as message.\n+    ///\n+    /// Rust 2021 always interprets the first argument as format string.\n+    NON_FMT_PANIC,\n+    Warn,\n+    \"detect single-argument panic!() invocations in which the argument is not a format string\",\n+    report_in_external_macro\n+}\n+\n+declare_lint_pass!(NonPanicFmt => [NON_FMT_PANIC]);\n+\n+impl<'tcx> LateLintPass<'tcx> for NonPanicFmt {\n+    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'tcx>) {\n+        if let hir::ExprKind::Call(f, [arg]) = &expr.kind {\n+            if let &ty::FnDef(def_id, _) = cx.typeck_results().expr_ty(f).kind() {\n+                if Some(def_id) == cx.tcx.lang_items().begin_panic_fn()\n+                    || Some(def_id) == cx.tcx.lang_items().panic_fn()\n+                    || Some(def_id) == cx.tcx.lang_items().panic_str()\n+                {\n+                    if let Some(id) = f.span.ctxt().outer_expn_data().macro_def_id {\n+                        if cx.tcx.is_diagnostic_item(sym::std_panic_2015_macro, id)\n+                            || cx.tcx.is_diagnostic_item(sym::core_panic_2015_macro, id)\n+                        {\n+                            check_panic(cx, f, arg);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+fn check_panic<'tcx>(cx: &LateContext<'tcx>, f: &'tcx hir::Expr<'tcx>, arg: &'tcx hir::Expr<'tcx>) {\n+    if let hir::ExprKind::Lit(lit) = &arg.kind {\n+        if let ast::LitKind::Str(sym, _) = lit.node {\n+            // The argument is a string literal.\n+            check_panic_str(cx, f, arg, &sym.as_str());\n+            return;\n+        }\n+    }\n+\n+    // The argument is *not* a string literal.\n+\n+    let (span, panic) = panic_call(cx, f);\n+\n+    cx.struct_span_lint(NON_FMT_PANIC, arg.span, |lint| {\n+        let mut l = lint.build(\"panic message is not a string literal\");\n+        l.note(\"this is no longer accepted in Rust 2021\");\n+        if span.contains(arg.span) {\n+            l.span_suggestion_verbose(\n+                arg.span.shrink_to_lo(),\n+                \"add a \\\"{}\\\" format string to Display the message\",\n+                \"\\\"{}\\\", \".into(),\n+                Applicability::MaybeIncorrect,\n+            );\n+            if panic == sym::std_panic_macro {\n+                l.span_suggestion_verbose(\n+                    span.until(arg.span),\n+                    \"or use std::panic::panic_any instead\",\n+                    \"std::panic::panic_any(\".into(),\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+        }\n+        l.emit();\n+    });\n+}\n+\n+fn check_panic_str<'tcx>(\n+    cx: &LateContext<'tcx>,\n+    f: &'tcx hir::Expr<'tcx>,\n+    arg: &'tcx hir::Expr<'tcx>,\n+    fmt: &str,\n+) {\n+    if !fmt.contains(&['{', '}'][..]) {\n+        // No brace, no problem.\n+        return;\n+    }\n+\n+    let fmt_span = arg.span.source_callsite();\n+\n+    let (snippet, style) = match cx.sess().parse_sess.source_map().span_to_snippet(fmt_span) {\n+        Ok(snippet) => {\n+            // Count the number of `#`s between the `r` and `\"`.\n+            let style = snippet.strip_prefix('r').and_then(|s| s.find('\"'));\n+            (Some(snippet), style)\n+        }\n+        Err(_) => (None, None),\n+    };\n+\n+    let mut fmt_parser =\n+        Parser::new(fmt.as_ref(), style, snippet.clone(), false, ParseMode::Format);\n+    let n_arguments = (&mut fmt_parser).filter(|a| matches!(a, Piece::NextArgument(_))).count();\n+\n+    let (span, _) = panic_call(cx, f);\n+\n+    if n_arguments > 0 && fmt_parser.errors.is_empty() {\n+        let arg_spans: Vec<_> = match &fmt_parser.arg_places[..] {\n+            [] => vec![fmt_span],\n+            v => v.iter().map(|span| fmt_span.from_inner(*span)).collect(),\n+        };\n+        cx.struct_span_lint(NON_FMT_PANIC, arg_spans, |lint| {\n+            let mut l = lint.build(match n_arguments {\n+                1 => \"panic message contains an unused formatting placeholder\",\n+                _ => \"panic message contains unused formatting placeholders\",\n+            });\n+            l.note(\"this message is not used as a format string when given without arguments, but will be in Rust 2021\");\n+            if span.contains(arg.span) {\n+                l.span_suggestion(\n+                    arg.span.shrink_to_hi(),\n+                    &format!(\"add the missing argument{}\", pluralize!(n_arguments)),\n+                    \", ...\".into(),\n+                    Applicability::HasPlaceholders,\n+                );\n+                l.span_suggestion(\n+                    arg.span.shrink_to_lo(),\n+                    \"or add a \\\"{}\\\" format string to use the message literally\",\n+                    \"\\\"{}\\\", \".into(),\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+            l.emit();\n+        });\n+    } else {\n+        let brace_spans: Option<Vec<_>> =\n+            snippet.filter(|s| s.starts_with('\"') || s.starts_with(\"r#\")).map(|s| {\n+                s.char_indices()\n+                    .filter(|&(_, c)| c == '{' || c == '}')\n+                    .map(|(i, _)| fmt_span.from_inner(InnerSpan { start: i, end: i + 1 }))\n+                    .collect()\n+            });\n+        let msg = match &brace_spans {\n+            Some(v) if v.len() == 1 => \"panic message contains a brace\",\n+            _ => \"panic message contains braces\",\n+        };\n+        cx.struct_span_lint(NON_FMT_PANIC, brace_spans.unwrap_or(vec![span]), |lint| {\n+            let mut l = lint.build(msg);\n+            l.note(\"this message is not used as a format string, but will be in Rust 2021\");\n+            if span.contains(arg.span) {\n+                l.span_suggestion(\n+                    arg.span.shrink_to_lo(),\n+                    \"add a \\\"{}\\\" format string to use the message literally\",\n+                    \"\\\"{}\\\", \".into(),\n+                    Applicability::MachineApplicable,\n+                );\n+            }\n+            l.emit();\n+        });\n+    }\n+}\n+\n+fn panic_call<'tcx>(cx: &LateContext<'tcx>, f: &'tcx hir::Expr<'tcx>) -> (Span, Symbol) {\n+    let mut expn = f.span.ctxt().outer_expn_data();\n+\n+    let mut panic_macro = kw::Empty;\n+\n+    // Unwrap more levels of macro expansion, as panic_2015!()\n+    // was likely expanded from panic!() and possibly from\n+    // [debug_]assert!().\n+    for &i in\n+        &[sym::std_panic_macro, sym::core_panic_macro, sym::assert_macro, sym::debug_assert_macro]\n+    {\n+        let parent = expn.call_site.ctxt().outer_expn_data();\n+        if parent.macro_def_id.map_or(false, |id| cx.tcx.is_diagnostic_item(i, id)) {\n+            expn = parent;\n+            panic_macro = i;\n+        }\n+    }\n+\n+    (expn.call_site, panic_macro)\n+}"}, {"sha": "4a6aca72acbbec957c2b4af13594c57ee60a22ed", "filename": "compiler/rustc_lint/src/panic_fmt.rs", "status": "removed", "additions": 0, "deletions": 155, "changes": 155, "blob_url": "https://github.com/rust-lang/rust/blob/120b2a704a60d4341286bd82f6e638c65ca169b6/compiler%2Frustc_lint%2Fsrc%2Fpanic_fmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/120b2a704a60d4341286bd82f6e638c65ca169b6/compiler%2Frustc_lint%2Fsrc%2Fpanic_fmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fpanic_fmt.rs?ref=120b2a704a60d4341286bd82f6e638c65ca169b6", "patch": "@@ -1,155 +0,0 @@\n-use crate::{LateContext, LateLintPass, LintContext};\n-use rustc_ast as ast;\n-use rustc_errors::{pluralize, Applicability};\n-use rustc_hir as hir;\n-use rustc_middle::ty;\n-use rustc_parse_format::{ParseMode, Parser, Piece};\n-use rustc_span::{sym, InnerSpan};\n-\n-declare_lint! {\n-    /// The `panic_fmt` lint detects `panic!(\"..\")` with `{` or `}` in the string literal.\n-    ///\n-    /// ### Example\n-    ///\n-    /// ```rust,no_run\n-    /// panic!(\"{}\");\n-    /// ```\n-    ///\n-    /// {{produces}}\n-    ///\n-    /// ### Explanation\n-    ///\n-    /// In Rust 2018 and earlier, `panic!(\"{}\")` panics with the message `\"{}\"`,\n-    /// as a `panic!()` invocation with a single argument does not use `format_args!()`.\n-    /// Rust 2021 interprets this string as format string, which breaks this.\n-    PANIC_FMT,\n-    Warn,\n-    \"detect braces in single-argument panic!() invocations\",\n-    report_in_external_macro\n-}\n-\n-declare_lint_pass!(PanicFmt => [PANIC_FMT]);\n-\n-impl<'tcx> LateLintPass<'tcx> for PanicFmt {\n-    fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &'tcx hir::Expr<'tcx>) {\n-        if let hir::ExprKind::Call(f, [arg]) = &expr.kind {\n-            if let &ty::FnDef(def_id, _) = cx.typeck_results().expr_ty(f).kind() {\n-                if Some(def_id) == cx.tcx.lang_items().begin_panic_fn()\n-                    || Some(def_id) == cx.tcx.lang_items().panic_fn()\n-                {\n-                    check_panic(cx, f, arg);\n-                }\n-            }\n-        }\n-    }\n-}\n-\n-fn check_panic<'tcx>(cx: &LateContext<'tcx>, f: &'tcx hir::Expr<'tcx>, arg: &'tcx hir::Expr<'tcx>) {\n-    if let hir::ExprKind::Lit(lit) = &arg.kind {\n-        if let ast::LitKind::Str(sym, _) = lit.node {\n-            let mut expn = f.span.ctxt().outer_expn_data();\n-            if let Some(id) = expn.macro_def_id {\n-                if cx.tcx.is_diagnostic_item(sym::std_panic_2015_macro, id)\n-                    || cx.tcx.is_diagnostic_item(sym::core_panic_2015_macro, id)\n-                {\n-                    let fmt = sym.as_str();\n-                    if !fmt.contains(&['{', '}'][..]) {\n-                        return;\n-                    }\n-\n-                    let fmt_span = arg.span.source_callsite();\n-\n-                    let (snippet, style) =\n-                        match cx.sess().parse_sess.source_map().span_to_snippet(fmt_span) {\n-                            Ok(snippet) => {\n-                                // Count the number of `#`s between the `r` and `\"`.\n-                                let style = snippet.strip_prefix('r').and_then(|s| s.find('\"'));\n-                                (Some(snippet), style)\n-                            }\n-                            Err(_) => (None, None),\n-                        };\n-\n-                    let mut fmt_parser =\n-                        Parser::new(fmt.as_ref(), style, snippet.clone(), false, ParseMode::Format);\n-                    let n_arguments =\n-                        (&mut fmt_parser).filter(|a| matches!(a, Piece::NextArgument(_))).count();\n-\n-                    // Unwrap more levels of macro expansion, as panic_2015!()\n-                    // was likely expanded from panic!() and possibly from\n-                    // [debug_]assert!().\n-                    for &assert in &[\n-                        sym::std_panic_macro,\n-                        sym::core_panic_macro,\n-                        sym::assert_macro,\n-                        sym::debug_assert_macro,\n-                    ] {\n-                        let parent = expn.call_site.ctxt().outer_expn_data();\n-                        if parent\n-                            .macro_def_id\n-                            .map_or(false, |id| cx.tcx.is_diagnostic_item(assert, id))\n-                        {\n-                            expn = parent;\n-                        }\n-                    }\n-\n-                    if n_arguments > 0 && fmt_parser.errors.is_empty() {\n-                        let arg_spans: Vec<_> = match &fmt_parser.arg_places[..] {\n-                            [] => vec![fmt_span],\n-                            v => v.iter().map(|span| fmt_span.from_inner(*span)).collect(),\n-                        };\n-                        cx.struct_span_lint(PANIC_FMT, arg_spans, |lint| {\n-                            let mut l = lint.build(match n_arguments {\n-                                1 => \"panic message contains an unused formatting placeholder\",\n-                                _ => \"panic message contains unused formatting placeholders\",\n-                            });\n-                            l.note(\"this message is not used as a format string when given without arguments, but will be in a future Rust edition\");\n-                            if expn.call_site.contains(arg.span) {\n-                                l.span_suggestion(\n-                                    arg.span.shrink_to_hi(),\n-                                    &format!(\"add the missing argument{}\", pluralize!(n_arguments)),\n-                                    \", ...\".into(),\n-                                    Applicability::HasPlaceholders,\n-                                );\n-                                l.span_suggestion(\n-                                    arg.span.shrink_to_lo(),\n-                                    \"or add a \\\"{}\\\" format string to use the message literally\",\n-                                    \"\\\"{}\\\", \".into(),\n-                                    Applicability::MachineApplicable,\n-                                );\n-                            }\n-                            l.emit();\n-                        });\n-                    } else {\n-                        let brace_spans: Option<Vec<_>> = snippet\n-                            .filter(|s| s.starts_with('\"') || s.starts_with(\"r#\"))\n-                            .map(|s| {\n-                                s.char_indices()\n-                                    .filter(|&(_, c)| c == '{' || c == '}')\n-                                    .map(|(i, _)| {\n-                                        fmt_span.from_inner(InnerSpan { start: i, end: i + 1 })\n-                                    })\n-                                    .collect()\n-                            });\n-                        let msg = match &brace_spans {\n-                            Some(v) if v.len() == 1 => \"panic message contains a brace\",\n-                            _ => \"panic message contains braces\",\n-                        };\n-                        cx.struct_span_lint(PANIC_FMT, brace_spans.unwrap_or(vec![expn.call_site]), |lint| {\n-                            let mut l = lint.build(msg);\n-                            l.note(\"this message is not used as a format string, but will be in a future Rust edition\");\n-                            if expn.call_site.contains(arg.span) {\n-                                l.span_suggestion(\n-                                    arg.span.shrink_to_lo(),\n-                                    \"add a \\\"{}\\\" format string to use the message literally\",\n-                                    \"\\\"{}\\\", \".into(),\n-                                    Applicability::MachineApplicable,\n-                                );\n-                            }\n-                            l.emit();\n-                        });\n-                    }\n-                }\n-            }\n-        }\n-    }\n-}"}, {"sha": "d5886a13558c627d8703fdee6705cf23322ff318", "filename": "src/test/ui/fmt/format-args-capture.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a616f8267ed9b9c45cdef81346e98aae06a70990/src%2Ftest%2Fui%2Ffmt%2Fformat-args-capture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a616f8267ed9b9c45cdef81346e98aae06a70990/src%2Ftest%2Fui%2Ffmt%2Fformat-args-capture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffmt%2Fformat-args-capture.rs?ref=a616f8267ed9b9c45cdef81346e98aae06a70990", "patch": "@@ -31,7 +31,7 @@ fn panic_with_single_argument_does_not_get_formatted() {\n     // RFC #2795 suggests that this may need to change so that captured arguments are formatted.\n     // For stability reasons this will need to part of an edition change.\n \n-    #[allow(panic_fmt)]\n+    #[allow(non_fmt_panic)]\n     let msg = std::panic::catch_unwind(|| {\n         panic!(\"{foo}\");\n     }).unwrap_err();"}, {"sha": "fd2c590ae5fd6eac0af7664732daf8ddd034b728", "filename": "src/test/ui/macros/macro-comma-behavior-rpass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a616f8267ed9b9c45cdef81346e98aae06a70990/src%2Ftest%2Fui%2Fmacros%2Fmacro-comma-behavior-rpass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a616f8267ed9b9c45cdef81346e98aae06a70990/src%2Ftest%2Fui%2Fmacros%2Fmacro-comma-behavior-rpass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-comma-behavior-rpass.rs?ref=a616f8267ed9b9c45cdef81346e98aae06a70990", "patch": "@@ -57,7 +57,7 @@ fn writeln_1arg() {\n //\n // (Example: Issue #48042)\n #[test]\n-#[allow(panic_fmt)]\n+#[allow(non_fmt_panic)]\n fn to_format_or_not_to_format() {\n     // (\"{}\" is the easiest string to test because if this gets\n     // sent to format_args!, it'll simply fail to compile."}, {"sha": "25c53316e1290a04436fad7dab169ac900d44d18", "filename": "src/test/ui/non-fmt-panic.rs", "status": "renamed", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a616f8267ed9b9c45cdef81346e98aae06a70990/src%2Ftest%2Fui%2Fnon-fmt-panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a616f8267ed9b9c45cdef81346e98aae06a70990/src%2Ftest%2Fui%2Fnon-fmt-panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnon-fmt-panic.rs?ref=a616f8267ed9b9c45cdef81346e98aae06a70990", "patch": "@@ -13,19 +13,27 @@ fn main() {\n     core::panic!(\"Hello {}\"); //~ WARN panic message contains an unused formatting placeholder\n     assert!(false, \"{:03x} {test} bla\");\n     //~^ WARN panic message contains unused formatting placeholders\n+    assert!(false, S);\n+    //~^ WARN panic message is not a string literal\n     debug_assert!(false, \"{{}} bla\"); //~ WARN panic message contains braces\n-    panic!(C); // No warning (yet)\n-    panic!(S); // No warning (yet)\n+    panic!(C); //~ WARN panic message is not a string literal\n+    panic!(S); //~ WARN panic message is not a string literal\n+    std::panic!(123); //~ WARN panic message is not a string literal\n+    core::panic!(&*\"abc\"); //~ WARN panic message is not a string literal\n     panic!(concat!(\"{\", \"}\")); //~ WARN panic message contains an unused formatting placeholder\n     panic!(concat!(\"{\", \"{\")); //~ WARN panic message contains braces\n \n     fancy_panic::fancy_panic!(\"test {} 123\");\n     //~^ WARN panic message contains an unused formatting placeholder\n \n+    fancy_panic::fancy_panic!(S);\n+    //~^ WARN panic message is not a string literal\n+\n     // Check that the lint only triggers for std::panic and core::panic,\n     // not any panic macro:\n     macro_rules! panic {\n         ($e:expr) => ();\n     }\n     panic!(\"{}\"); // OK\n+    panic!(S); // OK\n }", "previous_filename": "src/test/ui/panic-brace.rs"}, {"sha": "45187c518c423901ffc246209bc4fb8598e34d9b", "filename": "src/test/ui/non-fmt-panic.stderr", "status": "renamed", "additions": 98, "deletions": 18, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/a616f8267ed9b9c45cdef81346e98aae06a70990/src%2Ftest%2Fui%2Fnon-fmt-panic.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/a616f8267ed9b9c45cdef81346e98aae06a70990/src%2Ftest%2Fui%2Fnon-fmt-panic.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnon-fmt-panic.stderr?ref=a616f8267ed9b9c45cdef81346e98aae06a70990", "patch": "@@ -1,35 +1,35 @@\n warning: panic message contains a brace\n-  --> $DIR/panic-brace.rs:11:29\n+  --> $DIR/non-fmt-panic.rs:11:29\n    |\n LL |     panic!(\"here's a brace: {\");\n    |                             ^\n    |\n-   = note: `#[warn(panic_fmt)]` on by default\n-   = note: this message is not used as a format string, but will be in a future Rust edition\n+   = note: `#[warn(non_fmt_panic)]` on by default\n+   = note: this message is not used as a format string, but will be in Rust 2021\n help: add a \"{}\" format string to use the message literally\n    |\n LL |     panic!(\"{}\", \"here's a brace: {\");\n    |            ^^^^^\n \n warning: panic message contains a brace\n-  --> $DIR/panic-brace.rs:12:31\n+  --> $DIR/non-fmt-panic.rs:12:31\n    |\n LL |     std::panic!(\"another one: }\");\n    |                               ^\n    |\n-   = note: this message is not used as a format string, but will be in a future Rust edition\n+   = note: this message is not used as a format string, but will be in Rust 2021\n help: add a \"{}\" format string to use the message literally\n    |\n LL |     std::panic!(\"{}\", \"another one: }\");\n    |                 ^^^^^\n \n warning: panic message contains an unused formatting placeholder\n-  --> $DIR/panic-brace.rs:13:25\n+  --> $DIR/non-fmt-panic.rs:13:25\n    |\n LL |     core::panic!(\"Hello {}\");\n    |                         ^^\n    |\n-   = note: this message is not used as a format string when given without arguments, but will be in a future Rust edition\n+   = note: this message is not used as a format string when given without arguments, but will be in Rust 2021\n help: add the missing argument\n    |\n LL |     core::panic!(\"Hello {}\", ...);\n@@ -40,12 +40,12 @@ LL |     core::panic!(\"{}\", \"Hello {}\");\n    |                  ^^^^^\n \n warning: panic message contains unused formatting placeholders\n-  --> $DIR/panic-brace.rs:14:21\n+  --> $DIR/non-fmt-panic.rs:14:21\n    |\n LL |     assert!(false, \"{:03x} {test} bla\");\n    |                     ^^^^^^ ^^^^^^\n    |\n-   = note: this message is not used as a format string when given without arguments, but will be in a future Rust edition\n+   = note: this message is not used as a format string when given without arguments, but will be in Rust 2021\n help: add the missing arguments\n    |\n LL |     assert!(false, \"{:03x} {test} bla\", ...);\n@@ -55,25 +55,97 @@ help: or add a \"{}\" format string to use the message literally\n LL |     assert!(false, \"{}\", \"{:03x} {test} bla\");\n    |                    ^^^^^\n \n+warning: panic message is not a string literal\n+  --> $DIR/non-fmt-panic.rs:16:20\n+   |\n+LL |     assert!(false, S);\n+   |                    ^\n+   |\n+   = note: this is no longer accepted in Rust 2021\n+help: add a \"{}\" format string to Display the message\n+   |\n+LL |     assert!(false, \"{}\", S);\n+   |                    ^^^^^\n+\n warning: panic message contains braces\n-  --> $DIR/panic-brace.rs:16:27\n+  --> $DIR/non-fmt-panic.rs:18:27\n    |\n LL |     debug_assert!(false, \"{{}} bla\");\n    |                           ^^^^\n    |\n-   = note: this message is not used as a format string, but will be in a future Rust edition\n+   = note: this message is not used as a format string, but will be in Rust 2021\n help: add a \"{}\" format string to use the message literally\n    |\n LL |     debug_assert!(false, \"{}\", \"{{}} bla\");\n    |                          ^^^^^\n \n+warning: panic message is not a string literal\n+  --> $DIR/non-fmt-panic.rs:19:12\n+   |\n+LL |     panic!(C);\n+   |            ^\n+   |\n+   = note: this is no longer accepted in Rust 2021\n+help: add a \"{}\" format string to Display the message\n+   |\n+LL |     panic!(\"{}\", C);\n+   |            ^^^^^\n+help: or use std::panic::panic_any instead\n+   |\n+LL |     std::panic::panic_any(C);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^\n+\n+warning: panic message is not a string literal\n+  --> $DIR/non-fmt-panic.rs:20:12\n+   |\n+LL |     panic!(S);\n+   |            ^\n+   |\n+   = note: this is no longer accepted in Rust 2021\n+help: add a \"{}\" format string to Display the message\n+   |\n+LL |     panic!(\"{}\", S);\n+   |            ^^^^^\n+help: or use std::panic::panic_any instead\n+   |\n+LL |     std::panic::panic_any(S);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^\n+\n+warning: panic message is not a string literal\n+  --> $DIR/non-fmt-panic.rs:21:17\n+   |\n+LL |     std::panic!(123);\n+   |                 ^^^\n+   |\n+   = note: this is no longer accepted in Rust 2021\n+help: add a \"{}\" format string to Display the message\n+   |\n+LL |     std::panic!(\"{}\", 123);\n+   |                 ^^^^^\n+help: or use std::panic::panic_any instead\n+   |\n+LL |     std::panic::panic_any(123);\n+   |     ^^^^^^^^^^^^^^^^^^^^^^\n+\n+warning: panic message is not a string literal\n+  --> $DIR/non-fmt-panic.rs:22:18\n+   |\n+LL |     core::panic!(&*\"abc\");\n+   |                  ^^^^^^^\n+   |\n+   = note: this is no longer accepted in Rust 2021\n+help: add a \"{}\" format string to Display the message\n+   |\n+LL |     core::panic!(\"{}\", &*\"abc\");\n+   |                  ^^^^^\n+\n warning: panic message contains an unused formatting placeholder\n-  --> $DIR/panic-brace.rs:19:12\n+  --> $DIR/non-fmt-panic.rs:23:12\n    |\n LL |     panic!(concat!(\"{\", \"}\"));\n    |            ^^^^^^^^^^^^^^^^^\n    |\n-   = note: this message is not used as a format string when given without arguments, but will be in a future Rust edition\n+   = note: this message is not used as a format string when given without arguments, but will be in Rust 2021\n help: add the missing argument\n    |\n LL |     panic!(concat!(\"{\", \"}\"), ...);\n@@ -84,24 +156,32 @@ LL |     panic!(\"{}\", concat!(\"{\", \"}\"));\n    |            ^^^^^\n \n warning: panic message contains braces\n-  --> $DIR/panic-brace.rs:20:5\n+  --> $DIR/non-fmt-panic.rs:24:5\n    |\n LL |     panic!(concat!(\"{\", \"{\"));\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = note: this message is not used as a format string, but will be in a future Rust edition\n+   = note: this message is not used as a format string, but will be in Rust 2021\n help: add a \"{}\" format string to use the message literally\n    |\n LL |     panic!(\"{}\", concat!(\"{\", \"{\"));\n    |            ^^^^^\n \n warning: panic message contains an unused formatting placeholder\n-  --> $DIR/panic-brace.rs:22:37\n+  --> $DIR/non-fmt-panic.rs:26:37\n    |\n LL |     fancy_panic::fancy_panic!(\"test {} 123\");\n    |                                     ^^\n    |\n-   = note: this message is not used as a format string when given without arguments, but will be in a future Rust edition\n+   = note: this message is not used as a format string when given without arguments, but will be in Rust 2021\n+\n+warning: panic message is not a string literal\n+  --> $DIR/non-fmt-panic.rs:29:31\n+   |\n+LL |     fancy_panic::fancy_panic!(S);\n+   |                               ^\n+   |\n+   = note: this is no longer accepted in Rust 2021\n \n-warning: 8 warnings emitted\n+warning: 14 warnings emitted\n ", "previous_filename": "src/test/ui/panic-brace.stderr"}]}