{"sha": "b68eb507da6a2621a74676fc9a4ca76b37561ec8", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI2OGViNTA3ZGE2YTI2MjFhNzQ2NzZmYzlhNGNhNzZiMzc1NjFlYzg=", "commit": {"author": {"name": "Jeff Olson", "email": "olson.jeffery@gmail.com", "date": "2012-02-21T15:56:27Z"}, "committer": {"name": "Brian Anderson", "email": "banderson@mozilla.com", "date": "2012-02-29T01:56:14Z"}, "message": "cleaning up uv_async stuff and stubbing uv_timer", "tree": {"sha": "ca80171b6074131e5c9e37322f0122da5e3a5193", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ca80171b6074131e5c9e37322f0122da5e3a5193"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b68eb507da6a2621a74676fc9a4ca76b37561ec8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b68eb507da6a2621a74676fc9a4ca76b37561ec8", "html_url": "https://github.com/rust-lang/rust/commit/b68eb507da6a2621a74676fc9a4ca76b37561ec8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b68eb507da6a2621a74676fc9a4ca76b37561ec8/comments", "author": {"login": "olsonjeffery", "id": 10408, "node_id": "MDQ6VXNlcjEwNDA4", "avatar_url": "https://avatars.githubusercontent.com/u/10408?v=4", "gravatar_id": "", "url": "https://api.github.com/users/olsonjeffery", "html_url": "https://github.com/olsonjeffery", "followers_url": "https://api.github.com/users/olsonjeffery/followers", "following_url": "https://api.github.com/users/olsonjeffery/following{/other_user}", "gists_url": "https://api.github.com/users/olsonjeffery/gists{/gist_id}", "starred_url": "https://api.github.com/users/olsonjeffery/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/olsonjeffery/subscriptions", "organizations_url": "https://api.github.com/users/olsonjeffery/orgs", "repos_url": "https://api.github.com/users/olsonjeffery/repos", "events_url": "https://api.github.com/users/olsonjeffery/events{/privacy}", "received_events_url": "https://api.github.com/users/olsonjeffery/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "974c23cbeb4c0183723bac89aa50bf58e0bf7f6c", "url": "https://api.github.com/repos/rust-lang/rust/commits/974c23cbeb4c0183723bac89aa50bf58e0bf7f6c", "html_url": "https://github.com/rust-lang/rust/commit/974c23cbeb4c0183723bac89aa50bf58e0bf7f6c"}], "stats": {"total": 353, "additions": 279, "deletions": 74}, "files": [{"sha": "75e962bd331b6b5a45517d34c06a8732062e27e0", "filename": "src/libstd/uvtmp.rs", "status": "modified", "additions": 188, "deletions": 38, "changes": 226, "blob_url": "https://github.com/rust-lang/rust/blob/b68eb507da6a2621a74676fc9a4ca76b37561ec8/src%2Flibstd%2Fuvtmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b68eb507da6a2621a74676fc9a4ca76b37561ec8/src%2Flibstd%2Fuvtmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fuvtmp.rs?ref=b68eb507da6a2621a74676fc9a4ca76b37561ec8", "patch": "@@ -1,26 +1,31 @@\n // Some temporary libuv hacks for servo\n \n // UV2\n+\n+// these are processed solely in the\n+// process_operation() crust fn below\n enum uv_operation {\n-    op_async_init([u8])\n+    op_async_init([u8]),\n+    op_close(uv_handle, *ctypes::void)\n }\n \n-type uv_async = {\n-    id: [u8],\n-    loop: uv_loop\n-};\n+enum uv_handle {\n+    uv_async([u8], uv_loop)\n+}\n \n enum uv_msg {\n     // requests from library users\n     msg_run(comm::chan<bool>),\n     msg_run_in_bg(),\n-    msg_loop_delete(),\n-    msg_async_init(fn~(uv_async), fn~(uv_async)),\n+    msg_async_init(fn~(uv_handle), fn~(uv_handle)),\n     msg_async_send([u8]),\n+    msg_close(uv_handle, fn~()),\n \n     // dispatches from libuv\n     uv_async_init([u8], *ctypes::void),\n-    uv_async_send([u8])\n+    uv_async_send([u8]),\n+    uv_close([u8]),\n+    uv_end()\n }\n \n type uv_loop_data = {\n@@ -65,7 +70,10 @@ native mod rustrt {\n         loop: *ctypes::void,\n         data: *uv_loop_data);\n     fn rust_uvtmp_uv_bind_op_cb(loop: *ctypes::void, cb: *u8) -> *ctypes::void;\n+    fn rust_uvtmp_uv_stop_op_cb(handle: *ctypes::void);\n     fn rust_uvtmp_uv_run(loop_handle: *ctypes::void);\n+    fn rust_uvtmp_uv_close(handle: *ctypes::void, cb: *u8);\n+    fn rust_uvtmp_uv_close_async(handle: *ctypes::void);\n     fn rust_uvtmp_uv_async_send(handle: *ctypes::void);\n     fn rust_uvtmp_uv_async_init(\n         loop_handle: *ctypes::void,\n@@ -74,7 +82,8 @@ native mod rustrt {\n }\n \n mod uv {\n-    export loop_new, run, run_in_bg, async_init, async_send;\n+    export loop_new, run, close, run_in_bg, async_init, async_send,\n+           timer_init;\n \n     // public functions\n     fn loop_new() -> uv_loop unsafe {\n@@ -129,10 +138,14 @@ mod uv {\n             // all state goes here\n             let handles: map::map<[u8], *ctypes::void> =\n                 map::new_bytes_hash();\n-            let async_cbs: map::map<[u8], fn~(uv_async)> =\n+            let id_to_handle: map::map<[u8], uv_handle> =\n+                map::new_bytes_hash();\n+            let async_cbs: map::map<[u8], fn~(uv_handle)> =\n                 map::new_bytes_hash();\n             let async_init_after_cbs: map::map<[u8],\n-                                               fn~(uv_async)> =\n+                                               fn~(uv_handle)> =\n+                map::new_bytes_hash();\n+            let close_callbacks: map::map<[u8], fn~()> =\n                 map::new_bytes_hash();\n \n             // the main loop that this task blocks on.\n@@ -152,7 +165,9 @@ mod uv {\n                         rustrt::rust_uvtmp_uv_run(loop_handle);\n                         // when we're done, msg the\n                         // end chan\n+                        rustrt::rust_uvtmp_uv_stop_op_cb(op_handle);\n                         comm::send(end_chan, true);\n+                        comm::send(rust_loop_chan, uv_end);\n                     };\n                   }\n                   \n@@ -163,6 +178,34 @@ mod uv {\n                     };\n                   }\n                   \n+                  msg_close(handle, cb) {\n+                    let id = get_id_from_handle(handle);\n+                    close_callbacks.insert(id, cb);\n+                    let handle_ptr = handles.get(id);\n+                    let op = op_close(handle, handle_ptr);\n+\n+                    pass_to_libuv(op_handle, operation_chan, op);\n+                  }\n+                  uv_close(id) {\n+                    handles.remove(id);\n+                    let handle = id_to_handle.get(id);\n+                    id_to_handle.remove(id);\n+                    alt handle {\n+                      uv_async(id, _) {\n+                        async_cbs.remove(id);\n+                      }\n+                      _ {\n+                        fail \"unknown form of uv_handle encountered \"\n+                            + \"in uv_close handler\";\n+                      }\n+                    }\n+                    let cb = close_callbacks.get(id);\n+                    close_callbacks.remove(id);\n+                    task::spawn {||\n+                        cb();\n+                    };\n+                  }\n+                  \n                   msg_async_init(callback, after_cb) {\n                     // create a new async handle\n                     // with the id as the handle's\n@@ -172,9 +215,7 @@ mod uv {\n                     async_cbs.insert(id, callback);\n                     async_init_after_cbs.insert(id, after_cb);\n                     let op = op_async_init(id);\n-                    comm::send(operation_chan, op);\n-                    rustrt::rust_uvtmp_uv_async_send(op_handle);\n-                    io::println(\"MSG_ASYNC_INIT\");\n+                    pass_to_libuv(op_handle, operation_chan, op);\n                   }\n                   uv_async_init(id, async_handle) {\n                     // libuv created a handle, which is\n@@ -184,22 +225,25 @@ mod uv {\n                     handles.insert(id, async_handle);\n                     let after_cb = async_init_after_cbs.get(id);\n                     async_init_after_cbs.remove(id);\n+                    let async = uv_async(id, rust_loop_chan);\n+                    id_to_handle.insert(id, copy(async));\n                     task::spawn {||\n-                        let async: uv_async = {\n-                            id: id,\n-                            loop: rust_loop_chan\n-                        };\n                         after_cb(async);\n                     };\n                   }\n \n                   msg_async_send(id) {\n                     let async_handle = handles.get(id);\n-                    rustrt::rust_uvtmp_uv_async_send(async_handle);\n+                    do_send(async_handle);\n                   }\n                   uv_async_send(id) {\n                     let async_cb = async_cbs.get(id);\n-                    async_cb({id: id, loop: rust_loop_chan});\n+                    task::spawn {||\n+                        async_cb(uv_async(id, rust_loop_chan));\n+                    };\n+                  }\n+                  uv_end() {\n+                    keep_going = false;\n                   }\n \n                   _ { fail \"unknown form of uv_msg received\"; }\n@@ -222,42 +266,91 @@ mod uv {\n \n     fn async_init (\n         loop: uv_loop,\n-        async_cb: fn~(uv_async),\n-        after_cb: fn~(uv_async)) {\n+        async_cb: fn~(uv_handle),\n+        after_cb: fn~(uv_handle)) {\n         let msg = msg_async_init(async_cb, after_cb);\n         comm::send(loop, msg);\n     }\n \n-    fn async_send(async: uv_async) {\n-        comm::send(async.loop, msg_async_send(async.id));\n+    fn async_send(async: uv_handle) {\n+        alt async {\n+          uv_async(id, loop) {\n+            comm::send(loop, msg_async_send(id));\n+          }\n+          _ {\n+            fail \"attempting to call async_send() with a\" +\n+                \" uv_async uv_handle\";\n+          }\n+        }\n+    }\n+\n+    fn close(h: uv_handle, cb: fn~()) {\n+        let loop_chan = get_loop_chan_from_handle(h);\n+        comm::send(loop_chan, msg_close(h, cb)); \n+    }\n+\n+    fn timer_init(loop: uv_loop, after_cb: fn~(uv_handle)) {\n+        let msg = msg_timer_init(after_cb);\n+        comm::send(loop, msg);\n     }\n \n     // internal functions\n+    fn pass_to_libuv(\n+            op_handle: *ctypes::void,\n+            operation_chan: comm::chan<uv_operation>,\n+            op: uv_operation) unsafe {\n+        comm::send(operation_chan, copy(op));\n+        do_send(op_handle);\n+    }\n+    fn do_send(h: *ctypes::void) {\n+        rustrt::rust_uvtmp_uv_async_send(h);\n+    }\n     fn gen_handle_id() -> [u8] {\n         ret rand::mk_rng().gen_bytes(16u);\n     }\n     fn get_handle_id_from(buf: *u8) -> [u8] unsafe {\n         ret vec::unsafe::from_buf(buf, 16u); \n     }\n \n-    fn get_loop_chan_from(data: *uv_loop_data)\n-            -> comm::chan<uv_msg> unsafe {\n+    fn get_loop_chan_from_data(data: *uv_loop_data)\n+            -> uv_loop unsafe {\n         ret (*data).rust_loop_chan;\n     }\n \n+    fn get_loop_chan_from_handle(handle: uv_handle)\n+        -> uv_loop {\n+        alt handle {\n+          uv_async(id,loop) {\n+            ret loop;\n+          }\n+          _ {\n+            fail \"unknown form of uv_handle for get_loop_chan_from \"\n+                 + \" handle\";\n+          }\n+        }\n+    }\n+\n+    fn get_id_from_handle(handle: uv_handle) -> [u8] {\n+        alt handle {\n+          uv_async(id,loop) {\n+            ret id;\n+          }\n+          _ {\n+            fail \"unknown form of uv_handle for get_id_from handle\";\n+          }\n+        }\n+    }\n+\n     // crust\n     crust fn process_operation(\n             loop: *ctypes::void,\n             data: *uv_loop_data) unsafe {\n-        io::println(\"IN PROCESS_OPERATION\");\n         let op_port = (*data).operation_port;\n-        let loop_chan = get_loop_chan_from(data);\n+        let loop_chan = get_loop_chan_from_data(data);\n         let op_pending = comm::peek(op_port);\n         while(op_pending) {\n-            io::println(\"OPERATION PENDING!\");\n             alt comm::recv(op_port) {\n               op_async_init(id) {\n-                io::println(\"OP_ASYNC_INIT\");\n                 let id_ptr = vec::unsafe::to_ptr(id);\n                 let async_handle = rustrt::rust_uvtmp_uv_async_init(\n                     loop,\n@@ -267,21 +360,61 @@ mod uv {\n                     id,\n                     async_handle));\n               }\n+              op_close(handle, handle_ptr) {\n+                handle_op_close(handle, handle_ptr);\n+              }\n               \n               _ { fail \"unknown form of uv_operation received\"; }\n             }\n             op_pending = comm::peek(op_port);\n         }\n-        io::println(\"NO MORE OPERATIONS PENDING!\");\n+    }\n+\n+    fn handle_op_close(handle: uv_handle, handle_ptr: *ctypes::void) {\n+        // it's just like im doing C\n+        alt handle {\n+          uv_async(id, loop) {\n+            let cb = process_close_async;\n+            rustrt::rust_uvtmp_uv_close(\n+                handle_ptr, cb);\n+          }\n+          _ {\n+            fail \"unknown form of uv_handle encountered \" +\n+                \"in process_operation/op_close\";\n+          }\n+        }\n     }\n \n     crust fn process_async_send(id_buf: *u8, data: *uv_loop_data)\n             unsafe {\n         let handle_id = get_handle_id_from(id_buf);\n-        let loop_chan = get_loop_chan_from(data);\n+        let loop_chan = get_loop_chan_from_data(data);\n         comm::send(loop_chan, uv_async_send(handle_id));\n     }\n \n+    fn process_close_common(id: [u8], data: *uv_loop_data)\n+        unsafe {\n+        // notify the rust loop that their handle is closed, then\n+        // the caller will invoke a per-handle-type c++ func to\n+        // free allocated memory\n+        let loop_chan = get_loop_chan_from_data(data);\n+        comm::send(loop_chan, uv_close(id));\n+    }\n+\n+    crust fn process_close_async(\n+        id_buf: *u8,\n+        handle_ptr: *ctypes::void,\n+        data: *uv_loop_data)\n+        unsafe {\n+        let id = get_handle_id_from(id_buf);\n+        rustrt::rust_uvtmp_uv_close_async(handle_ptr);\n+        // at this point, the handle and its data has been\n+        // released. notify the rust loop to remove the\n+        // handle and its data and call the user-supplied\n+        // close cb\n+        process_close_common(id, data);\n+    }\n+\n     \n }\n \n@@ -295,14 +428,31 @@ fn test_uvtmp_uv_new_loop_no_handles() {\n #[test]\n fn test_uvtmp_uv_simple_async() {\n     let test_loop = uv::loop_new();\n-    let cb: fn~(uv_async) = fn~(h: uv_async) {\n-        io::println(\"HELLO FROM ASYNC CALLBACK!\");\n-    };\n-    uv::async_init(test_loop, cb) {|new_async|\n-        io::println(\"NEW_ASYNC CREATED!\");\n+    let exit_port = comm::port::<bool>();\n+    let exit_chan = comm::chan::<bool>(exit_port);\n+    uv::async_init(test_loop, {|new_async|\n+        uv::close(new_async) {||\n+            comm::send(exit_chan, true);\n+        };\n+    }, {|new_async|\n         uv::async_send(new_async);\n-    };\n+    });\n+    uv::run(test_loop);\n+    assert comm::recv(exit_port);\n+}\n+\n+#[test]\n+fn test_uvtmp_uv_timer() {\n+    let test_loop = uv::loop_new();\n+    let exit_port = comm::port::<bool>();\n+    let exit_chan = comm::chan::<bool>(exit_port);\n+    uv::timer(test_loop, {|new_timer|\n+        uv::timer_start(new_async) {||\n+            comm::send(exit_chan, true);\n+        };\n+    }); \n     uv::run(test_loop);\n+    assert comm::recv(exit_port);\n }\n \n // END OF UV2"}, {"sha": "f97312eaf44aacd6bdb835255ef64f36494b94ea", "filename": "src/rt/rust_uvtmp.cpp", "status": "modified", "additions": 91, "deletions": 36, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/b68eb507da6a2621a74676fc9a4ca76b37561ec8/src%2Frt%2Frust_uvtmp.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/b68eb507da6a2621a74676fc9a4ca76b37561ec8/src%2Frt%2Frust_uvtmp.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frt%2Frust_uvtmp.cpp?ref=b68eb507da6a2621a74676fc9a4ca76b37561ec8", "patch": "@@ -57,26 +57,63 @@ struct timer_start_data {\n \n // UVTMP REWORK\n \n-typedef void (*async_op_cb)(uv_loop_t* loop, void* data);\n-typedef void (*rust_async_cb)(uint8_t* id_buf, void* loop_data);\n+// crust fn pointers\n+typedef void (*crust_async_op_cb)(uv_loop_t* loop, void* data);\n+typedef void (*crust_async_cb)(uint8_t* id_buf, void* loop_data);\n+typedef void (*crust_close_cb)(uint8_t* id_buf, void* handle,\n+\t\t\t\t\t\t\t  void* data);\n \n+// data types\n+#define RUST_UV_HANDLE_LEN 16\n+\n+struct handle_data {\n+\tuint8_t id_buf[RUST_UV_HANDLE_LEN];\n+\tcrust_async_cb cb;\n+\tcrust_close_cb close_cb;\n+};\n+\n+// helpers\n static void*\n current_kernel_malloc(size_t size, const char* tag) {\n-  return rust_task_thread::get_task()->malloc(size, tag);\n+  void* ptr = rust_task_thread::get_task()->kernel->malloc(size, tag);\n+  return ptr;\n }\n \n-/*\n static void\n current_kernel_free(void* ptr) {\n-  rust_task_thread::get_task()->free(ptr);\n+  rust_task_thread::get_task()->kernel->free(ptr);\n+}\n+\n+// libuv callback impls\n+static void\n+native_crust_async_op_cb(uv_async_t* handle, int status) {\n+    crust_async_op_cb cb = (crust_async_op_cb)handle->data;\n+\tvoid* loop_data = handle->loop->data;\n+\tcb(handle->loop, loop_data);\n+}\n+\n+static void\n+native_async_cb(uv_async_t* handle, int status) {\n+\thandle_data* handle_d = (handle_data*)handle->data;\n+\tvoid* loop_data = handle->loop->data;\n+\thandle_d->cb(handle_d->id_buf, loop_data);\n+}\n+\n+static void\n+native_close_cb(uv_handle_t* handle) {\n+\thandle_data* data = (handle_data*)handle->data;\n+\tdata->close_cb(data->id_buf, handle, handle->loop->data);\n+}\n+\n+static void\n+native_close_op_cb(uv_handle_t* op_handle) {\n+  uv_loop_t* loop = op_handle->loop;\n+  current_kernel_free(op_handle);\n+  loop->data = 0; // a ptr to some stack-allocated rust mem\n+  uv_loop_delete(loop);\n }\n-*/\n-#define RUST_UV_HANDLE_LEN 16\n-struct async_data {\n-\tuint8_t id_buf[RUST_UV_HANDLE_LEN];\n-\trust_async_cb cb;\n-};\n \n+// native fns bound in rust\n extern \"C\" void*\n rust_uvtmp_uv_loop_new() {\n     return (void*)uv_loop_new();\n@@ -87,51 +124,69 @@ rust_uvtmp_uv_loop_set_data(uv_loop_t* loop, void* data) {\n     loop->data = data;\n }\n \n-static void\n-native_async_op_cb(uv_async_t* handle, int status) {\n-    async_op_cb cb = (async_op_cb)handle->data;\n-\tvoid* loop_data = handle->loop->data;\n-\tcb(handle->loop, loop_data);\n-}\n-\n extern \"C\" void*\n-rust_uvtmp_uv_bind_op_cb(uv_loop_t* loop, async_op_cb cb) {\n-    uv_async_t* async = (uv_async_t*)current_kernel_malloc(\n+rust_uvtmp_uv_bind_op_cb(uv_loop_t* loop, crust_async_op_cb cb) {\n+\tuv_async_t* async = (uv_async_t*)current_kernel_malloc(\n \t\tsizeof(uv_async_t),\n \t\t\"uv_async_t\");\n-\tuv_async_init(loop, async, native_async_op_cb);\n-\t// decrement the ref count, so that our async bind\n-\t// does count towards keeping the loop alive\n+\tuv_async_init(loop, async, native_crust_async_op_cb);\n \tasync->data = (void*)cb;\n+\t// decrement the ref count, so that our async bind\n+\t// doesn't count towards keeping the loop alive\n+\tuv_unref(loop);\n \treturn async;\n }\n \n-extern \"C\" void rust_uvtmp_uv_run(uv_loop_t* loop) {\n+extern \"C\" void\n+rust_uvtmp_uv_stop_op_cb(uv_handle_t* op_handle) {\n+  /*  // this is a hack to get libuv to cleanup a\n+  // handle that was made to not prevent the loop\n+  // from exiting via uv_unref().\n+  uv_ref(op_handle->loop);\n+  uv_close(op_handle, native_close_op_cb);\n+  uv_run(op_handle->loop); // this should process the handle's\n+                           // close event and then return\n+\t\t\t\t\t\t   */\n+  // the above code is supposed to work to cleanly close\n+  // a handler that was uv_unref()'d. but it causes much spew\n+  // instead. this is the ugly/quick way to deal w/ it for now.\n+  uv_close(op_handle, native_close_op_cb);\n+  native_close_op_cb(op_handle);\n+}\n+\n+extern \"C\" void\n+rust_uvtmp_uv_run(uv_loop_t* loop) {\n \tuv_run(loop);\n }\n \n extern \"C\" void\n-rust_uvtmp_uv_async_send(uv_async_t* handle) {\n-    uv_async_send(handle);\n+rust_uvtmp_uv_close(uv_handle_t* handle, crust_close_cb cb) {\n+\thandle_data* data = (handle_data*)handle->data;\n+\tdata->close_cb = cb;\n+\tuv_close(handle, native_close_cb);\n }\n \n-static void\n-native_async_cb(uv_async_t* handle, int status) {\n-\tasync_data* handle_data = (async_data*)handle->data;\n-\tvoid* loop_data = handle->loop->data;\n-\thandle_data->cb(handle_data->id_buf, loop_data);\n+extern \"C\" void\n+rust_uvtmp_uv_close_async(uv_async_t* handle) {\n+  current_kernel_free(handle->data);\n+  current_kernel_free(handle);\n+}\n+\n+extern \"C\" void\n+rust_uvtmp_uv_async_send(uv_async_t* handle) {\n+    uv_async_send(handle);\n }\n \n extern \"C\" void*\n-rust_uvtmp_uv_async_init(uv_loop_t* loop, rust_async_cb cb,\n+rust_uvtmp_uv_async_init(uv_loop_t* loop, crust_async_cb cb,\n \t\t\t\t\t\t uint8_t* buf) {\n-    uv_async_t* async = (uv_async_t*)current_kernel_malloc(\n+\tuv_async_t* async = (uv_async_t*)current_kernel_malloc(\n \t\tsizeof(uv_async_t),\n \t\t\"uv_async_t\");\n \tuv_async_init(loop, async, native_async_cb);\n-\tasync_data* data = (async_data*)current_kernel_malloc(\n-\t\tsizeof(async_data),\n-\t\t\"async_data\");\n+\thandle_data* data = (handle_data*)current_kernel_malloc(\n+\t\tsizeof(handle_data),\n+\t\t\"handle_data\");\n \tmemcpy(data->id_buf, buf, RUST_UV_HANDLE_LEN);\n \tdata->cb = cb;\n \tasync->data = data;"}]}