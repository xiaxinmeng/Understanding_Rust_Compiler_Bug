{"sha": "b8725520af466783f1c99c6aaae1b233cfa0a508", "node_id": "C_kwDOAAsO6NoAKGI4NzI1NTIwYWY0NjY3ODNmMWM5OWM2YWFhZTFiMjMzY2ZhMGE1MDg", "commit": {"author": {"name": "Dylan DPC", "email": "99973273+Dylan-DPC@users.noreply.github.com", "date": "2023-04-10T08:43:14Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2023-04-10T08:43:14Z"}, "message": "Rollup merge of #110021 - scottmcm:fix-110005, r=compiler-errors\n\nFix a couple ICEs in the new `CastKind::Transmute` code\n\nCheck the sizes of the immediates, rather than the overall types, when deciding whether we can convert types without going through memory.\n\nFixes #110005\nFixes #109992\nFixes #110032\ncc `@matthiaskrgr`", "tree": {"sha": "deb9847e454621e4e9cc8cb68d0b2e493c0196b1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/deb9847e454621e4e9cc8cb68d0b2e493c0196b1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b8725520af466783f1c99c6aaae1b233cfa0a508", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJkM8wiCRBK7hj4Ov3rIwAAr+wIAAmnMJx+Wp3kExwLXCAFAfIc\nXtSrHNoS15uaux8zXevWMDnU2S0wQ3mAfVqsfA2XXVq4GeXoeQBWb1z/uQZntQw9\nrEDcRZ4wR4QWDFYNw3avaEc35+BKPYcZKMCGQPAO9viYc9teEDS3ZhaCOUOVUVoF\nJEzIwBcOXCrzPaDkS8YAUrZ/B/npjJ7vLfKEptq3kERxQl1FVXJWtL1Nkskk3j1y\nQfVSn503kHK7y4AjJ3nGxZdFeszYAeFCv/a5lfN4AxA/sS2RLh79D+t9tHp7ppyF\n7V4688t7WxObI1BniibukiMZ1WZozn7pSyFK7LUVtxK2kkq0rmJbZaifPw/Ak9M=\n=lque\n-----END PGP SIGNATURE-----\n", "payload": "tree deb9847e454621e4e9cc8cb68d0b2e493c0196b1\nparent c30d7e97a813cbd9c022227528b1b26ce88e8ddd\nparent d757c4b904869967f1e665dc2bb9a2ca5122bc96\nauthor Dylan DPC <99973273+Dylan-DPC@users.noreply.github.com> 1681116194 +0530\ncommitter GitHub <noreply@github.com> 1681116194 +0530\n\nRollup merge of #110021 - scottmcm:fix-110005, r=compiler-errors\n\nFix a couple ICEs in the new `CastKind::Transmute` code\n\nCheck the sizes of the immediates, rather than the overall types, when deciding whether we can convert types without going through memory.\n\nFixes #110005\nFixes #109992\nFixes #110032\ncc `@matthiaskrgr`\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b8725520af466783f1c99c6aaae1b233cfa0a508", "html_url": "https://github.com/rust-lang/rust/commit/b8725520af466783f1c99c6aaae1b233cfa0a508", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b8725520af466783f1c99c6aaae1b233cfa0a508/comments", "author": {"login": "Dylan-DPC", "id": 99973273, "node_id": "U_kgDOBfV4mQ", "avatar_url": "https://avatars.githubusercontent.com/u/99973273?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Dylan-DPC", "html_url": "https://github.com/Dylan-DPC", "followers_url": "https://api.github.com/users/Dylan-DPC/followers", "following_url": "https://api.github.com/users/Dylan-DPC/following{/other_user}", "gists_url": "https://api.github.com/users/Dylan-DPC/gists{/gist_id}", "starred_url": "https://api.github.com/users/Dylan-DPC/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Dylan-DPC/subscriptions", "organizations_url": "https://api.github.com/users/Dylan-DPC/orgs", "repos_url": "https://api.github.com/users/Dylan-DPC/repos", "events_url": "https://api.github.com/users/Dylan-DPC/events{/privacy}", "received_events_url": "https://api.github.com/users/Dylan-DPC/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c30d7e97a813cbd9c022227528b1b26ce88e8ddd", "url": "https://api.github.com/repos/rust-lang/rust/commits/c30d7e97a813cbd9c022227528b1b26ce88e8ddd", "html_url": "https://github.com/rust-lang/rust/commit/c30d7e97a813cbd9c022227528b1b26ce88e8ddd"}, {"sha": "d757c4b904869967f1e665dc2bb9a2ca5122bc96", "url": "https://api.github.com/repos/rust-lang/rust/commits/d757c4b904869967f1e665dc2bb9a2ca5122bc96", "html_url": "https://github.com/rust-lang/rust/commit/d757c4b904869967f1e665dc2bb9a2ca5122bc96"}], "stats": {"total": 299, "additions": 261, "deletions": 38}, "files": [{"sha": "b37797fef4ce3d10a6406247e9be3be250174805", "filename": "compiler/rustc_codegen_ssa/src/mir/operand.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b8725520af466783f1c99c6aaae1b233cfa0a508/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8725520af466783f1c99c6aaae1b233cfa0a508/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Foperand.rs?ref=b8725520af466783f1c99c6aaae1b233cfa0a508", "patch": "@@ -259,6 +259,31 @@ impl<'a, 'tcx, V: CodegenObject> OperandRef<'tcx, V> {\n }\n \n impl<'a, 'tcx, V: CodegenObject> OperandValue<V> {\n+    /// Returns an `OperandValue` that's generally UB to use in any way.\n+    ///\n+    /// Depending on the `layout`, returns an `Immediate` or `Pair` containing\n+    /// poison value(s), or a `Ref` containing a poison pointer.\n+    ///\n+    /// Supports sized types only.\n+    pub fn poison<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n+        bx: &mut Bx,\n+        layout: TyAndLayout<'tcx>,\n+    ) -> OperandValue<V> {\n+        assert!(layout.is_sized());\n+        if bx.cx().is_backend_immediate(layout) {\n+            let ibty = bx.cx().immediate_backend_type(layout);\n+            OperandValue::Immediate(bx.const_poison(ibty))\n+        } else if bx.cx().is_backend_scalar_pair(layout) {\n+            let ibty0 = bx.cx().scalar_pair_element_backend_type(layout, 0, true);\n+            let ibty1 = bx.cx().scalar_pair_element_backend_type(layout, 1, true);\n+            OperandValue::Pair(bx.const_poison(ibty0), bx.const_poison(ibty1))\n+        } else {\n+            let bty = bx.cx().backend_type(layout);\n+            let ptr_bty = bx.cx().type_ptr_to(bty);\n+            OperandValue::Ref(bx.const_poison(ptr_bty), None, layout.align.abi)\n+        }\n+    }\n+\n     pub fn store<Bx: BuilderMethods<'a, 'tcx, Value = V>>(\n         self,\n         bx: &mut Bx,"}, {"sha": "d88226f5db05335ee404e996c8fc5c6969b81333", "filename": "compiler/rustc_codegen_ssa/src/mir/rvalue.rs", "status": "modified", "additions": 71, "deletions": 36, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/b8725520af466783f1c99c6aaae1b233cfa0a508/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8725520af466783f1c99c6aaae1b233cfa0a508/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmir%2Frvalue.rs?ref=b8725520af466783f1c99c6aaae1b233cfa0a508", "patch": "@@ -158,17 +158,6 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         debug_assert!(src.layout.is_sized());\n         debug_assert!(dst.layout.is_sized());\n \n-        if src.layout.size != dst.layout.size\n-            || src.layout.abi.is_uninhabited()\n-            || dst.layout.abi.is_uninhabited()\n-        {\n-            // In all of these cases it's UB to run this transmute, but that's\n-            // known statically so might as well trap for it, rather than just\n-            // making it unreachable.\n-            bx.abort();\n-            return;\n-        }\n-\n         if let Some(val) = self.codegen_transmute_operand(bx, src, dst.layout) {\n             val.store(bx, dst);\n             return;\n@@ -202,8 +191,21 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         operand: OperandRef<'tcx, Bx::Value>,\n         cast: TyAndLayout<'tcx>,\n     ) -> Option<OperandValue<Bx::Value>> {\n-        // Callers already checked that the layout sizes match\n-        debug_assert_eq!(operand.layout.size, cast.size);\n+        // Check for transmutes that are always UB.\n+        if operand.layout.size != cast.size\n+            || operand.layout.abi.is_uninhabited()\n+            || cast.abi.is_uninhabited()\n+        {\n+            if !operand.layout.abi.is_uninhabited() {\n+                // Since this is known statically and the input could have existed\n+                // without already having hit UB, might as well trap for it.\n+                bx.abort();\n+            }\n+\n+            // Because this transmute is UB, return something easy to generate,\n+            // since it's fine that later uses of the value are probably UB.\n+            return Some(OperandValue::poison(bx, cast));\n+        }\n \n         let operand_kind = self.value_kind(operand.layout);\n         let cast_kind = self.value_kind(cast);\n@@ -222,10 +224,20 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     bug!(\"Found {operand_kind:?} for operand {operand:?}\");\n                 };\n                 if let OperandValueKind::Immediate(out_scalar) = cast_kind {\n-                    let cast_bty = bx.backend_type(cast);\n-                    Some(OperandValue::Immediate(Self::transmute_immediate(\n-                        bx, imm, in_scalar, out_scalar, cast_bty,\n-                    )))\n+                    match (in_scalar, out_scalar) {\n+                        (ScalarOrZst::Zst, ScalarOrZst::Zst) => {\n+                            Some(OperandRef::new_zst(bx, cast).val)\n+                        }\n+                        (ScalarOrZst::Scalar(in_scalar), ScalarOrZst::Scalar(out_scalar))\n+                            if in_scalar.size(self.cx) == out_scalar.size(self.cx) =>\n+                        {\n+                            let cast_bty = bx.backend_type(cast);\n+                            Some(OperandValue::Immediate(\n+                                self.transmute_immediate(bx, imm, in_scalar, out_scalar, cast_bty),\n+                            ))\n+                        }\n+                        _ => None,\n+                    }\n                 } else {\n                     None\n                 }\n@@ -234,12 +246,15 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 let OperandValueKind::Pair(in_a, in_b) = operand_kind else {\n                     bug!(\"Found {operand_kind:?} for operand {operand:?}\");\n                 };\n-                if let OperandValueKind::Pair(out_a, out_b) = cast_kind {\n+                if let OperandValueKind::Pair(out_a, out_b) = cast_kind\n+                    && in_a.size(self.cx) == out_a.size(self.cx)\n+                    && in_b.size(self.cx) == out_b.size(self.cx)\n+                {\n                     let out_a_ibty = bx.scalar_pair_element_backend_type(cast, 0, false);\n                     let out_b_ibty = bx.scalar_pair_element_backend_type(cast, 1, false);\n                     Some(OperandValue::Pair(\n-                        Self::transmute_immediate(bx, imm_a, in_a, out_a, out_a_ibty),\n-                        Self::transmute_immediate(bx, imm_b, in_b, out_b, out_b_ibty),\n+                        self.transmute_immediate(bx, imm_a, in_a, out_a, out_a_ibty),\n+                        self.transmute_immediate(bx, imm_b, in_b, out_b, out_b_ibty),\n                     ))\n                 } else {\n                     None\n@@ -254,12 +269,15 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     /// `to_backend_ty` must be the *non*-immediate backend type (so it will be\n     /// `i8`, not `i1`, for `bool`-like types.)\n     fn transmute_immediate(\n+        &self,\n         bx: &mut Bx,\n         mut imm: Bx::Value,\n         from_scalar: abi::Scalar,\n         to_scalar: abi::Scalar,\n         to_backend_ty: Bx::Type,\n     ) -> Bx::Value {\n+        debug_assert_eq!(from_scalar.size(self.cx), to_scalar.size(self.cx));\n+\n         use abi::Primitive::*;\n         imm = bx.from_immediate(imm);\n         imm = match (from_scalar.primitive(), to_scalar.primitive()) {\n@@ -831,14 +849,6 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                 let operand_ty = operand.ty(self.mir, self.cx.tcx());\n                 let cast_layout = self.cx.layout_of(self.monomorphize(cast_ty));\n                 let operand_layout = self.cx.layout_of(self.monomorphize(operand_ty));\n-                if operand_layout.size != cast_layout.size\n-                    || operand_layout.abi.is_uninhabited()\n-                    || cast_layout.abi.is_uninhabited()\n-                {\n-                    // Send UB cases to the full form so the operand version can\n-                    // `bitcast` without worrying about malformed IR.\n-                    return false;\n-                }\n \n                 match (self.value_kind(operand_layout), self.value_kind(cast_layout)) {\n                     // Can always load from a pointer as needed\n@@ -847,9 +857,12 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     // Need to generate an `alloc` to get a pointer from an immediate\n                     (OperandValueKind::Immediate(..) | OperandValueKind::Pair(..), OperandValueKind::Ref) => false,\n \n-                    // When we have scalar immediates, we can convert them as needed\n-                    (OperandValueKind::Immediate(..), OperandValueKind::Immediate(..)) |\n-                    (OperandValueKind::Pair(..), OperandValueKind::Pair(..)) => true,\n+                    // When we have scalar immediates, we can only convert things\n+                    // where the sizes match, to avoid endianness questions.\n+                    (OperandValueKind::Immediate(a), OperandValueKind::Immediate(b)) =>\n+                        a.size(self.cx) == b.size(self.cx),\n+                    (OperandValueKind::Pair(a0, a1), OperandValueKind::Pair(b0, b1)) =>\n+                        a0.size(self.cx) == b0.size(self.cx) && a1.size(self.cx) == b1.size(self.cx),\n \n                     // Send mixings between scalars and pairs through the memory route\n                     // FIXME: Maybe this could use insertvalue/extractvalue instead?\n@@ -887,13 +900,18 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         if self.cx.is_backend_immediate(layout) {\n             debug_assert!(!self.cx.is_backend_scalar_pair(layout));\n             OperandValueKind::Immediate(match layout.abi {\n-                abi::Abi::Scalar(s) => s,\n-                abi::Abi::Vector { element, .. } => element,\n-                x => bug!(\"Couldn't translate {x:?} as backend immediate\"),\n+                abi::Abi::Scalar(s) => ScalarOrZst::Scalar(s),\n+                abi::Abi::Vector { element, .. } => ScalarOrZst::Scalar(element),\n+                _ if layout.is_zst() => ScalarOrZst::Zst,\n+                x => span_bug!(self.mir.span, \"Couldn't translate {x:?} as backend immediate\"),\n             })\n         } else if self.cx.is_backend_scalar_pair(layout) {\n             let abi::Abi::ScalarPair(s1, s2) = layout.abi else {\n-                bug!(\"Couldn't translate {:?} as backend scalar pair\", layout.abi)\n+                span_bug!(\n+                    self.mir.span,\n+                    \"Couldn't translate {:?} as backend scalar pair\",\n+                    layout.abi,\n+                );\n             };\n             OperandValueKind::Pair(s1, s2)\n         } else {\n@@ -902,9 +920,26 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     }\n }\n \n+/// The variants of this match [`OperandValue`], giving details about the\n+/// backend values that will be held in that other type.\n #[derive(Debug, Copy, Clone)]\n enum OperandValueKind {\n     Ref,\n-    Immediate(abi::Scalar),\n+    Immediate(ScalarOrZst),\n     Pair(abi::Scalar, abi::Scalar),\n }\n+\n+#[derive(Debug, Copy, Clone)]\n+enum ScalarOrZst {\n+    Zst,\n+    Scalar(abi::Scalar),\n+}\n+\n+impl ScalarOrZst {\n+    pub fn size(self, cx: &impl abi::HasDataLayout) -> abi::Size {\n+        match self {\n+            ScalarOrZst::Zst => abi::Size::ZERO,\n+            ScalarOrZst::Scalar(s) => s.size(cx),\n+        }\n+    }\n+}"}, {"sha": "99d258c62040fed5c5cc72b84d84b759c9352d04", "filename": "tests/codegen/intrinsics/transmute-x64.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/b8725520af466783f1c99c6aaae1b233cfa0a508/tests%2Fcodegen%2Fintrinsics%2Ftransmute-x64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8725520af466783f1c99c6aaae1b233cfa0a508/tests%2Fcodegen%2Fintrinsics%2Ftransmute-x64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fintrinsics%2Ftransmute-x64.rs?ref=b8725520af466783f1c99c6aaae1b233cfa0a508", "patch": "@@ -0,0 +1,35 @@\n+// compile-flags: -O -C no-prepopulate-passes\n+// only-x86_64 (it's using arch-specific types)\n+// min-llvm-version: 15.0 # this test assumes `ptr`s\n+\n+#![crate_type = \"lib\"]\n+\n+use std::arch::x86_64::{__m128, __m128i, __m256i};\n+use std::mem::transmute;\n+\n+// CHECK-LABEL: @check_sse_float_to_int(\n+#[no_mangle]\n+pub unsafe fn check_sse_float_to_int(x: __m128) -> __m128i {\n+    // CHECK-NOT: alloca\n+    // CHECK: %1 = load <4 x float>, ptr %x, align 16\n+    // CHECK: store <4 x float> %1, ptr %0, align 16\n+    transmute(x)\n+}\n+\n+// CHECK-LABEL: @check_sse_pair_to_avx(\n+#[no_mangle]\n+pub unsafe fn check_sse_pair_to_avx(x: (__m128i, __m128i)) -> __m256i {\n+    // CHECK-NOT: alloca\n+    // CHECK: %1 = load <4 x i64>, ptr %x, align 16\n+    // CHECK: store <4 x i64> %1, ptr %0, align 32\n+    transmute(x)\n+}\n+\n+// CHECK-LABEL: @check_sse_pair_from_avx(\n+#[no_mangle]\n+pub unsafe fn check_sse_pair_from_avx(x: __m256i) -> (__m128i, __m128i) {\n+    // CHECK-NOT: alloca\n+    // CHECK: %1 = load <4 x i64>, ptr %x, align 32\n+    // CHECK: store <4 x i64> %1, ptr %0, align 16\n+    transmute(x)\n+}"}, {"sha": "57f901c6719921b284e79863307ed9462c154b2a", "filename": "tests/codegen/intrinsics/transmute.rs", "status": "modified", "additions": 130, "deletions": 2, "changes": 132, "blob_url": "https://github.com/rust-lang/rust/blob/b8725520af466783f1c99c6aaae1b233cfa0a508/tests%2Fcodegen%2Fintrinsics%2Ftransmute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b8725520af466783f1c99c6aaae1b233cfa0a508/tests%2Fcodegen%2Fintrinsics%2Ftransmute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcodegen%2Fintrinsics%2Ftransmute.rs?ref=b8725520af466783f1c99c6aaae1b233cfa0a508", "patch": "@@ -8,7 +8,7 @@\n #![feature(inline_const)]\n #![allow(unreachable_code)]\n \n-use std::mem::transmute;\n+use std::mem::{transmute, MaybeUninit};\n \n // Some of the cases here are statically rejected by `mem::transmute`, so\n // we need to generate custom MIR for those cases to get to codegen.\n@@ -54,6 +54,32 @@ pub unsafe fn check_smaller_size(x: u32) -> u16 {\n     }\n }\n \n+// CHECK-LABEL: @check_smaller_array(\n+#[no_mangle]\n+#[custom_mir(dialect = \"runtime\", phase = \"initial\")]\n+pub unsafe fn check_smaller_array(x: [u32; 7]) -> [u32; 3] {\n+    // CHECK: call void @llvm.trap\n+    mir!{\n+        {\n+            RET = CastTransmute(x);\n+            Return()\n+        }\n+    }\n+}\n+\n+// CHECK-LABEL: @check_bigger_array(\n+#[no_mangle]\n+#[custom_mir(dialect = \"runtime\", phase = \"initial\")]\n+pub unsafe fn check_bigger_array(x: [u32; 3]) -> [u32; 7] {\n+    // CHECK: call void @llvm.trap\n+    mir!{\n+        {\n+            RET = CastTransmute(x);\n+            Return()\n+        }\n+    }\n+}\n+\n // CHECK-LABEL: @check_to_uninhabited(\n #[no_mangle]\n #[custom_mir(dialect = \"runtime\", phase = \"initial\")]\n@@ -71,7 +97,7 @@ pub unsafe fn check_to_uninhabited(x: u16) -> BigNever {\n #[no_mangle]\n #[custom_mir(dialect = \"runtime\", phase = \"initial\")]\n pub unsafe fn check_from_uninhabited(x: BigNever) -> u16 {\n-    // CHECK: call void @llvm.trap\n+    // CHECK: ret i16 poison\n     mir!{\n         {\n             RET = CastTransmute(x);\n@@ -301,3 +327,105 @@ pub unsafe fn check_pair_to_array(x: (i64, u64)) -> [u8; 16] {\n     // CHECK: store i64 %x.1, ptr %{{.+}}, align 1\n     transmute(x)\n }\n+\n+// CHECK-LABEL: @check_heterogeneous_integer_pair(\n+#[no_mangle]\n+pub unsafe fn check_heterogeneous_integer_pair(x: (i32, bool)) -> (bool, u32) {\n+    // CHECK: store i32 %x.0\n+    // CHECK: %[[WIDER:.+]] = zext i1 %x.1 to i8\n+    // CHECK: store i8 %[[WIDER]]\n+\n+    // CHECK: %[[BYTE:.+]] = load i8\n+    // CHECK: trunc i8 %[[BYTE:.+]] to i1\n+    // CHECK: load i32\n+    transmute(x)\n+}\n+\n+// CHECK-LABEL: @check_heterogeneous_float_pair(\n+#[no_mangle]\n+pub unsafe fn check_heterogeneous_float_pair(x: (f64, f32)) -> (f32, f64) {\n+    // CHECK: store double %x.0\n+    // CHECK: store float %x.1\n+    // CHECK: %[[A:.+]] = load float\n+    // CHECK: %[[B:.+]] = load double\n+    // CHECK: %[[P:.+]] = insertvalue { float, double } poison, float %[[A]], 0\n+    // CHECK: insertvalue { float, double } %[[P]], double %[[B]], 1\n+    transmute(x)\n+}\n+\n+// CHECK-LABEL: @check_issue_110005(\n+#[no_mangle]\n+pub unsafe fn check_issue_110005(x: (usize, bool)) -> Option<Box<[u8]>> {\n+    // CHECK: store i64 %x.0\n+    // CHECK: %[[WIDER:.+]] = zext i1 %x.1 to i8\n+    // CHECK: store i8 %[[WIDER]]\n+    // CHECK: load ptr\n+    // CHECK: load i64\n+    transmute(x)\n+}\n+\n+// CHECK-LABEL: @check_pair_to_dst_ref(\n+#[no_mangle]\n+pub unsafe fn check_pair_to_dst_ref<'a>(x: (usize, usize)) -> &'a [u8] {\n+    // CHECK: %0 = inttoptr i64 %x.0 to ptr\n+    // CHECK: %1 = insertvalue { ptr, i64 } poison, ptr %0, 0\n+    // CHECK: %2 = insertvalue { ptr, i64 } %1, i64 %x.1, 1\n+    // CHECK: ret { ptr, i64 } %2\n+    transmute(x)\n+}\n+\n+// CHECK-LABEL: @check_issue_109992(\n+#[no_mangle]\n+#[custom_mir(dialect = \"runtime\", phase = \"optimized\")]\n+pub unsafe fn check_issue_109992(x: ()) -> [(); 1] {\n+    // This uses custom MIR to avoid MIR optimizations having removed ZST ops.\n+\n+    // CHECK: start\n+    // CHECK-NEXT: ret void\n+    mir!{\n+        {\n+            RET = CastTransmute(x);\n+            Return()\n+        }\n+    }\n+}\n+\n+// CHECK-LABEL: @check_maybe_uninit_pair(i16 %x.0, i64 %x.1)\n+#[no_mangle]\n+pub unsafe fn check_maybe_uninit_pair(\n+    x: (MaybeUninit<u16>, MaybeUninit<u64>),\n+) -> (MaybeUninit<i64>, MaybeUninit<i16>) {\n+    // Thanks to `MaybeUninit` this is actually defined behaviour,\n+    // unlike the examples above with pairs of primitives.\n+\n+    // CHECK: store i16 %x.0\n+    // CHECK: store i64 %x.1\n+    // CHECK: load i64\n+    // CHECK-NOT: noundef\n+    // CHECK: load i16\n+    // CHECK-NOT: noundef\n+    // CHECK: ret { i64, i16 }\n+    transmute(x)\n+}\n+\n+#[repr(align(8))]\n+pub struct HighAlignScalar(u8);\n+\n+// CHECK-LABEL: @check_to_overalign(\n+#[no_mangle]\n+pub unsafe fn check_to_overalign(x: u64) -> HighAlignScalar {\n+    // CHECK: %0 = alloca %HighAlignScalar, align 8\n+    // CHECK: store i64 %x, ptr %0, align 8\n+    // CHECK: %1 = load i64, ptr %0, align 8\n+    // CHECK: ret i64 %1\n+    transmute(x)\n+}\n+\n+// CHECK-LABEL: @check_from_overalign(\n+#[no_mangle]\n+pub unsafe fn check_from_overalign(x: HighAlignScalar) -> u64 {\n+    // CHECK: %x = alloca %HighAlignScalar, align 8\n+    // CHECK: %[[VAL:.+]] = load i64, ptr %x, align 8\n+    // CHECK: ret i64 %[[VAL]]\n+    transmute(x)\n+}"}]}