{"sha": "cb464a919af8a3297a0374bff3ab671567c1300c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNiNDY0YTkxOWFmOGEzMjk3YTAzNzRiZmYzYWI2NzE1NjdjMTMwMGM=", "commit": {"author": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2017-05-23T20:47:10Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-05-23T20:47:10Z"}, "message": "Merge pull request #1576 from topecongiro/chain/float-first-child\n\n Allow first child to stay on the same line with block parent when rewriting chain", "tree": {"sha": "cfe1a19edcee492dcf014135f7b2603870f90692", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cfe1a19edcee492dcf014135f7b2603870f90692"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cb464a919af8a3297a0374bff3ab671567c1300c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cb464a919af8a3297a0374bff3ab671567c1300c", "html_url": "https://github.com/rust-lang/rust/commit/cb464a919af8a3297a0374bff3ab671567c1300c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cb464a919af8a3297a0374bff3ab671567c1300c/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7c8432f05bf77ccd7aba238e9871ba50160e85df", "url": "https://api.github.com/repos/rust-lang/rust/commits/7c8432f05bf77ccd7aba238e9871ba50160e85df", "html_url": "https://github.com/rust-lang/rust/commit/7c8432f05bf77ccd7aba238e9871ba50160e85df"}, {"sha": "04bb5d892978b868a953bce4153dde66e583c7f4", "url": "https://api.github.com/repos/rust-lang/rust/commits/04bb5d892978b868a953bce4153dde66e583c7f4", "html_url": "https://github.com/rust-lang/rust/commit/04bb5d892978b868a953bce4153dde66e583c7f4"}], "stats": {"total": 360, "additions": 184, "deletions": 176}, "files": [{"sha": "5ea43708af39e7161c4f8d5b6316b5b10c569305", "filename": "src/chains.rs", "status": "modified", "additions": 40, "deletions": 27, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/cb464a919af8a3297a0374bff3ab671567c1300c/src%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb464a919af8a3297a0374bff3ab671567c1300c/src%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fchains.rs?ref=cb464a919af8a3297a0374bff3ab671567c1300c", "patch": "@@ -99,10 +99,14 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n     }\n \n     // Parent is the first item in the chain, e.g., `foo` in `foo.bar.baz()`.\n-    let mut parent_shape = shape;\n-    if is_block_expr(&parent, \"\\n\") {\n-        parent_shape = chain_indent(context, shape);\n-    }\n+    let parent_shape = if is_block_expr(context, &parent, \"\\n\") {\n+        match context.config.chain_indent() {\n+            IndentStyle::Visual => shape.visual_indent(0),\n+            IndentStyle::Block => shape.block(),\n+        }\n+    } else {\n+        shape\n+    };\n     let parent_rewrite = try_opt!(parent.rewrite(context, parent_shape));\n     let parent_rewrite_contains_newline = parent_rewrite.contains('\\n');\n \n@@ -121,30 +125,28 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n         (nested_shape,\n          context.config.chain_indent() == IndentStyle::Visual ||\n          parent_rewrite.len() <= context.config.tab_spaces())\n-    } else if is_block_expr(&parent, &parent_rewrite) {\n-        // The parent is a block, so align the rest of the chain with the closing\n-        // brace.\n-        (parent_shape, false)\n+    } else if is_block_expr(context, &parent, &parent_rewrite) {\n+        match context.config.chain_indent() {\n+            // Try to put the first child on the same line with parent's last line\n+            IndentStyle::Block => (parent_shape.block_indent(context.config.tab_spaces()), true),\n+            // The parent is a block, so align the rest of the chain with the closing\n+            // brace.\n+            IndentStyle::Visual => (parent_shape, false),\n+        }\n     } else if parent_rewrite_contains_newline {\n         (chain_indent(context, parent_shape), false)\n     } else {\n         (shape.block_indent(context.config.tab_spaces()), false)\n     };\n \n-    let max_width = try_opt!((shape.width + shape.indent.width() + shape.offset)\n-                                 .checked_sub(nested_shape.indent.width() +\n-                                              nested_shape.offset));\n+    let other_child_shape = nested_shape.with_max_width(context.config);\n \n-    let other_child_shape = Shape {\n-        width: max_width,\n-        ..nested_shape\n-    };\n     let first_child_shape = if extend {\n-        let first_child_shape = try_opt!(parent_shape\n-                                             .offset_left(last_line_width(&parent_rewrite)));\n+        let overhead = last_line_width(&parent_rewrite);\n+        let offset = parent_rewrite.lines().rev().next().unwrap().trim().len();\n         match context.config.chain_indent() {\n-            IndentStyle::Visual => first_child_shape,\n-            IndentStyle::Block => first_child_shape.block(),\n+            IndentStyle::Visual => try_opt!(parent_shape.offset_left(overhead)),\n+            IndentStyle::Block => try_opt!(parent_shape.block().offset_left(offset)),\n         }\n     } else {\n         other_child_shape\n@@ -153,10 +155,10 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n            first_child_shape,\n            other_child_shape);\n \n-    let child_shape_iter =\n-        Some(first_child_shape)\n-            .into_iter()\n-            .chain(::std::iter::repeat(other_child_shape).take(subexpr_list.len() - 1));\n+    let child_shape_iter = Some(first_child_shape)\n+        .into_iter()\n+        .chain(::std::iter::repeat(other_child_shape)\n+                   .take(subexpr_list.len() - 1));\n     let iter = subexpr_list.iter().rev().zip(child_shape_iter);\n     let mut rewrites =\n         try_opt!(iter.map(|(e, shape)| rewrite_chain_subexpr(e, total_span, context, shape))\n@@ -173,7 +175,7 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n         if rewrites.len() > 1 {\n             true\n         } else if rewrites.len() == 1 {\n-            one_line_len > shape.width\n+            parent_rewrite.len() > context.config.chain_one_line_max() / 2\n         } else {\n             false\n         }\n@@ -224,8 +226,16 @@ pub fn rewrite_chain(expr: &ast::Expr, context: &RewriteContext, shape: Shape) -\n         format!(\"\\n{}\", nested_shape.indent.to_string(context.config))\n     };\n \n-    let first_connector = if extend || subexpr_list.is_empty() || first_subexpr_is_try {\n+    let first_connector = if subexpr_list.is_empty() {\n         \"\"\n+    } else if extend || first_subexpr_is_try {\n+        // 1 = \";\", being conservative here.\n+        if last_line_width(&parent_rewrite) + first_line_width(&rewrites[0]) + 1 <=\n+           context.config.max_width() {\n+            \"\"\n+        } else {\n+            &*connector\n+        }\n     } else {\n         &*connector\n     };\n@@ -277,8 +287,11 @@ fn join_rewrites(rewrites: &[String], subexps: &[ast::Expr], connector: &str) ->\n \n // States whether an expression's last line exclusively consists of closing\n // parens, braces, and brackets in its idiomatic formatting.\n-fn is_block_expr(expr: &ast::Expr, repr: &str) -> bool {\n+fn is_block_expr(context: &RewriteContext, expr: &ast::Expr, repr: &str) -> bool {\n     match expr.node {\n+        ast::ExprKind::Call(..) => {\n+            context.config.fn_call_style() == IndentStyle::Block && repr.contains('\\n')\n+        }\n         ast::ExprKind::Struct(..) |\n         ast::ExprKind::While(..) |\n         ast::ExprKind::WhileLet(..) |\n@@ -291,7 +304,7 @@ fn is_block_expr(expr: &ast::Expr, repr: &str) -> bool {\n         ast::ExprKind::Paren(ref expr) |\n         ast::ExprKind::Binary(_, _, ref expr) |\n         ast::ExprKind::Index(_, ref expr) |\n-        ast::ExprKind::Unary(_, ref expr) => is_block_expr(expr, repr),\n+        ast::ExprKind::Unary(_, ref expr) => is_block_expr(context, expr, repr),\n         _ => false,\n     }\n }"}, {"sha": "9591ffc4427f8010c0153816e4990fac9fd35024", "filename": "src/comment.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/cb464a919af8a3297a0374bff3ab671567c1300c/src%2Fcomment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb464a919af8a3297a0374bff3ab671567c1300c/src%2Fcomment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomment.rs?ref=cb464a919af8a3297a0374bff3ab671567c1300c", "patch": "@@ -158,15 +158,14 @@ fn light_rewrite_comment(orig: &str, offset: Indent, config: &Config) -> Option<\n             // `*` in `/*`.\n             let first_non_whitespace = l.find(|c| !char::is_whitespace(c));\n             if let Some(fnw) = first_non_whitespace {\n-                    if l.as_bytes()[fnw] == '*' as u8 && fnw > 0 {\n-                        &l[fnw - 1..]\n-                    } else {\n-                        &l[fnw..]\n-                    }\n+                if l.as_bytes()[fnw] == '*' as u8 && fnw > 0 {\n+                    &l[fnw - 1..]\n                 } else {\n-                    \"\"\n+                    &l[fnw..]\n                 }\n-                .trim_right()\n+            } else {\n+                \"\"\n+            }.trim_right()\n         })\n         .collect();\n     Some(lines.join(&format!(\"\\n{}\", offset.to_string(config))))"}, {"sha": "29edb0a3e3fa6e2be9f825ef15f01e03cf5bb1cf", "filename": "src/expr.rs", "status": "modified", "additions": 32, "deletions": 25, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/cb464a919af8a3297a0374bff3ab671567c1300c/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb464a919af8a3297a0374bff3ab671567c1300c/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=cb464a919af8a3297a0374bff3ab671567c1300c", "patch": "@@ -98,16 +98,20 @@ fn format_expr(expr: &ast::Expr,\n         }\n         ast::ExprKind::Tup(ref items) => rewrite_tuple(context, items, expr.span, shape),\n         ast::ExprKind::While(ref cond, ref block, label) => {\n-            ControlFlow::new_while(None, cond, block, label, expr.span).rewrite(context, shape)\n+            ControlFlow::new_while(None, cond, block, label, expr.span)\n+                .rewrite(context, shape)\n         }\n         ast::ExprKind::WhileLet(ref pat, ref cond, ref block, label) => {\n-            ControlFlow::new_while(Some(pat), cond, block, label, expr.span).rewrite(context, shape)\n+            ControlFlow::new_while(Some(pat), cond, block, label, expr.span)\n+                .rewrite(context, shape)\n         }\n         ast::ExprKind::ForLoop(ref pat, ref cond, ref block, label) => {\n-            ControlFlow::new_for(pat, cond, block, label, expr.span).rewrite(context, shape)\n+            ControlFlow::new_for(pat, cond, block, label, expr.span)\n+                .rewrite(context, shape)\n         }\n         ast::ExprKind::Loop(ref block, label) => {\n-            ControlFlow::new_loop(block, label, expr.span).rewrite(context, shape)\n+            ControlFlow::new_loop(block, label, expr.span)\n+                .rewrite(context, shape)\n         }\n         ast::ExprKind::Block(ref block) => block.rewrite(context, shape),\n         ast::ExprKind::If(ref cond, ref if_block, ref else_block) => {\n@@ -175,11 +179,12 @@ fn format_expr(expr: &ast::Expr,\n         ast::ExprKind::Mac(ref mac) => {\n             // Failure to rewrite a marco should not imply failure to\n             // rewrite the expression.\n-            rewrite_macro(mac, None, context, shape, MacroPosition::Expression).or_else(|| {\n-                wrap_str(context.snippet(expr.span),\n-                         context.config.max_width(),\n-                         shape)\n-            })\n+            rewrite_macro(mac, None, context, shape, MacroPosition::Expression)\n+                .or_else(|| {\n+                             wrap_str(context.snippet(expr.span),\n+                                      context.config.max_width(),\n+                                      shape)\n+                         })\n         }\n         ast::ExprKind::Ret(None) => {\n             wrap_str(\"return\".to_owned(), context.config.max_width(), shape)\n@@ -316,11 +321,11 @@ pub fn rewrite_pair<LHS, RHS>(lhs: &LHS,\n     let lhs_budget = try_opt!(context\n                                   .config\n                                   .max_width()\n-                                  .checked_sub(shape.used_width() + prefix.len() +\n-                                               infix.len()));\n+                                  .checked_sub(shape.used_width() + prefix.len() + infix.len()));\n     let rhs_shape = match context.config.control_style() {\n         Style::Default => {\n-            try_opt!(shape.sub_width(suffix.len() + prefix.len())).visual_indent(prefix.len())\n+            try_opt!(shape.sub_width(suffix.len() + prefix.len()))\n+                .visual_indent(prefix.len())\n         }\n         Style::Rfc => try_opt!(shape.block_left(context.config.tab_spaces())),\n     };\n@@ -511,7 +516,8 @@ fn rewrite_closure(capture: ast::CaptureBy,\n \n     // 1 = space between `|...|` and body.\n     let extra_offset = extra_offset(&prefix, shape) + 1;\n-    let body_shape = try_opt!(shape.sub_width(extra_offset)).add_offset(extra_offset);\n+    let body_shape = try_opt!(shape.sub_width(extra_offset))\n+        .add_offset(extra_offset);\n \n     if let ast::ExprKind::Block(ref block) = body.node {\n         // The body of the closure is an empty block.\n@@ -953,14 +959,13 @@ impl<'a> Rewrite for ControlFlow<'a> {\n         };\n \n         // for event in event\n-        let between_kwd_cond =\n-            mk_sp(context.codemap.span_after(self.span, self.keyword.trim()),\n-                  self.pat\n-                      .map_or(cond_span.lo, |p| if self.matcher.is_empty() {\n-                p.span.lo\n-            } else {\n-                context.codemap.span_before(self.span, self.matcher.trim())\n-            }));\n+        let between_kwd_cond = mk_sp(context.codemap.span_after(self.span, self.keyword.trim()),\n+                                     self.pat\n+                                         .map_or(cond_span.lo, |p| if self.matcher.is_empty() {\n+            p.span.lo\n+        } else {\n+            context.codemap.span_before(self.span, self.matcher.trim())\n+        }));\n \n         let between_kwd_cond_comment = extract_comment(between_kwd_cond, context, shape);\n \n@@ -1042,9 +1047,10 @@ impl<'a> Rewrite for ControlFlow<'a> {\n             let between_kwd_else_block_comment =\n                 extract_comment(between_kwd_else_block, context, shape);\n \n-            let after_else = mk_sp(context.codemap.span_after(mk_sp(self.block.span.hi,\n-                                                                    else_block.span.lo),\n-                                                              \"else\"),\n+            let after_else = mk_sp(context\n+                                       .codemap\n+                                       .span_after(mk_sp(self.block.span.hi, else_block.span.lo),\n+                                                   \"else\"),\n                                    else_block.span.lo);\n             let after_else_comment = extract_comment(after_else, context, shape);\n \n@@ -1791,11 +1797,11 @@ fn rewrite_call_args(context: &RewriteContext,\n \n fn can_be_overflowed(context: &RewriteContext, args: &[ptr::P<ast::Expr>]) -> bool {\n     match args.last().map(|x| &x.node) {\n-        Some(&ast::ExprKind::Block(..)) |\n         Some(&ast::ExprKind::Match(..)) => {\n             (context.config.fn_call_style() == IndentStyle::Block && args.len() == 1) ||\n             (context.config.fn_call_style() == IndentStyle::Visual && args.len() > 1)\n         }\n+        Some(&ast::ExprKind::Block(..)) |\n         Some(&ast::ExprKind::Closure(..)) => {\n             context.config.fn_call_style() == IndentStyle::Block ||\n             context.config.fn_call_style() == IndentStyle::Visual && args.len() > 1\n@@ -1822,6 +1828,7 @@ fn is_extendable(args: &[ptr::P<ast::Expr>]) -> bool {\n         }\n     } else if args.len() > 1 {\n         match args[args.len() - 1].node {\n+            ast::ExprKind::Block(..) |\n             ast::ExprKind::Closure(..) |\n             ast::ExprKind::Tup(..) => true,\n             _ => false,"}, {"sha": "9256f853f808bedf2bb6d5e8e2f65d37b6066d72", "filename": "src/file_lines.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cb464a919af8a3297a0374bff3ab671567c1300c/src%2Ffile_lines.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb464a919af8a3297a0374bff3ab671567c1300c/src%2Ffile_lines.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ffile_lines.rs?ref=cb464a919af8a3297a0374bff3ab671567c1300c", "patch": "@@ -126,7 +126,8 @@ impl FileLines {\n             Some(ref map) => map,\n         };\n \n-        match canonicalize_path_string(file_name).and_then(|file| map.get_vec(&file).ok_or(())) {\n+        match canonicalize_path_string(file_name)\n+                  .and_then(|file| map.get_vec(&file).ok_or(())) {\n             Ok(ranges) => ranges.iter().any(f),\n             Err(_) => false,\n         }"}, {"sha": "e21abb9117fe89cff34b204e2df7d2585aca9ec4", "filename": "src/items.rs", "status": "modified", "additions": 28, "deletions": 27, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/cb464a919af8a3297a0374bff3ab671567c1300c/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb464a919af8a3297a0374bff3ab671567c1300c/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=cb464a919af8a3297a0374bff3ab671567c1300c", "patch": "@@ -1062,11 +1062,11 @@ fn format_tuple_struct(context: &RewriteContext,\n                          |field| field.rewrite(context, Shape::legacy(item_budget, item_indent)),\n                          context.codemap.span_after(span, \"(\"),\n                          span.hi);\n-        let body_budget = try_opt!(context\n-                                       .config\n-                                       .max_width()\n-                                       .checked_sub(offset.block_only().width() + result.len() +\n-                                                    3));\n+        let body_budget =\n+            try_opt!(context\n+                         .config\n+                         .max_width()\n+                         .checked_sub(offset.block_only().width() + result.len() + 3));\n         let body = try_opt!(list_helper(items,\n                                         // TODO budget is wrong in block case\n                                         Shape::legacy(body_budget, item_indent),\n@@ -1310,28 +1310,30 @@ pub fn rewrite_associated_type(ident: ast::Ident,\n                                -> Option<String> {\n     let prefix = format!(\"type {}\", ident);\n \n-    let type_bounds_str =\n-        if let Some(ty_param_bounds) = ty_param_bounds_opt {\n-            let joiner = match context.config.type_punctuation_density() {\n-                TypeDensity::Compressed => \"+\",\n-                TypeDensity::Wide => \" + \",\n-            };\n-            let bounds: &[_] = ty_param_bounds;\n-            let bound_str = try_opt!(bounds\n-                                         .iter()\n-                                         .map(|ty_bound| {\n-                ty_bound.rewrite(context, Shape::legacy(context.config.max_width(), indent))\n-            })\n-                                         .intersperse(Some(joiner.to_string()))\n-                                         .collect::<Option<String>>());\n-            if bounds.len() > 0 {\n-                format!(\": {}\", bound_str)\n-            } else {\n-                String::new()\n-            }\n+    let type_bounds_str = if let Some(ty_param_bounds) = ty_param_bounds_opt {\n+        let joiner = match context.config.type_punctuation_density() {\n+            TypeDensity::Compressed => \"+\",\n+            TypeDensity::Wide => \" + \",\n+        };\n+        let bounds: &[_] = ty_param_bounds;\n+        let bound_str =\n+            try_opt!(bounds\n+                         .iter()\n+                         .map(|ty_bound| {\n+                                  ty_bound.rewrite(context,\n+                                                   Shape::legacy(context.config.max_width(),\n+                                                                 indent))\n+                              })\n+                         .intersperse(Some(joiner.to_string()))\n+                         .collect::<Option<String>>());\n+        if bounds.len() > 0 {\n+            format!(\": {}\", bound_str)\n         } else {\n             String::new()\n-        };\n+        }\n+    } else {\n+        String::new()\n+    };\n \n     if let Some(ty) = ty_opt {\n         let ty_str = try_opt!(ty.rewrite(context,\n@@ -1931,8 +1933,7 @@ fn compute_budgets_for_args(context: &RewriteContext,\n             let multi_line_budget = try_opt!(context\n                                                  .config\n                                                  .max_width()\n-                                                 .checked_sub(indent.width() + result.len() +\n-                                                              4));\n+                                                 .checked_sub(indent.width() + result.len() + 4));\n \n             return Some((one_line_budget, multi_line_budget, indent + result.len() + 1));\n         }"}, {"sha": "adc18c14581e1053ccce7dd9d1b43196d36b1f24", "filename": "src/lists.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cb464a919af8a3297a0374bff3ab671567c1300c/src%2Flists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb464a919af8a3297a0374bff3ab671567c1300c/src%2Flists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flists.rs?ref=cb464a919af8a3297a0374bff3ab671567c1300c", "patch": "@@ -430,7 +430,8 @@ impl<'a, T, I, F1, F2, F3> Iterator for ListItems<'a, I, F1, F2, F3>\n             let post_snippet_trimmed = if post_snippet.starts_with(',') {\n                 post_snippet[1..].trim_matches(white_space)\n             } else if post_snippet.ends_with(',') {\n-                post_snippet[..(post_snippet.len() - 1)].trim_matches(white_space)\n+                post_snippet[..(post_snippet.len() - 1)]\n+                    .trim_matches(white_space)\n             } else {\n                 post_snippet\n             };\n@@ -528,7 +529,8 @@ pub fn struct_lit_shape(shape: Shape,\n                         -> Option<(Option<Shape>, Shape)> {\n     let v_shape = match context.config.struct_lit_style() {\n         IndentStyle::Visual => {\n-            try_opt!(try_opt!(shape.shrink_left(prefix_width)).sub_width(suffix_width))\n+            try_opt!(try_opt!(shape.shrink_left(prefix_width))\n+                         .sub_width(suffix_width))\n         }\n         IndentStyle::Block => {\n             let shape = shape.block_indent(context.config.tab_spaces());"}, {"sha": "30786de6d59d00a709f50e218bdcf2b286b5c368", "filename": "src/macros.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/cb464a919af8a3297a0374bff3ab671567c1300c/src%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb464a919af8a3297a0374bff3ab671567c1300c/src%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmacros.rs?ref=cb464a919af8a3297a0374bff3ab671567c1300c", "patch": "@@ -172,12 +172,11 @@ pub fn rewrite_macro(mac: &ast::Mac,\n         MacroStyle::Parens => {\n             // Format macro invocation as function call, forcing no trailing\n             // comma because not all macros support them.\n-            rewrite_call(context, &macro_name, &expr_vec, mac.span, shape).map(|rw| {\n-                match position {\n-                    MacroPosition::Item => format!(\"{};\", rw),\n-                    _ => rw,\n-                }\n-            })\n+            rewrite_call(context, &macro_name, &expr_vec, mac.span, shape)\n+                .map(|rw| match position {\n+                         MacroPosition::Item => format!(\"{};\", rw),\n+                         _ => rw,\n+                     })\n         }\n         MacroStyle::Brackets => {\n             let mac_shape = try_opt!(shape.shrink_left(macro_name.len()));"}, {"sha": "5e09a311dcb6a064419b2368a4352d17012feaa1", "filename": "src/modules.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cb464a919af8a3297a0374bff3ab671567c1300c/src%2Fmodules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb464a919af8a3297a0374bff3ab671567c1300c/src%2Fmodules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmodules.rs?ref=cb464a919af8a3297a0374bff3ab671567c1300c", "patch": "@@ -68,7 +68,8 @@ fn module_file(id: ast::Ident,\n         return path;\n     }\n \n-    match parser::Parser::default_submod_path(id, dir_path, codemap).result {\n+    match parser::Parser::default_submod_path(id, dir_path, codemap)\n+              .result {\n         Ok(parser::ModulePathSuccess { path, .. }) => path,\n         Err(_) => panic!(\"Couldn't find module {}\", id),\n     }"}, {"sha": "17c6533f7a0ea6fcfcd268a827eb93c326c47da1", "filename": "src/string.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cb464a919af8a3297a0374bff3ab671567c1300c/src%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb464a919af8a3297a0374bff3ab671567c1300c/src%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstring.rs?ref=cb464a919af8a3297a0374bff3ab671567c1300c", "patch": "@@ -35,7 +35,8 @@ pub fn rewrite_string<'a>(orig: &str, fmt: &StringFormat<'a>) -> Option<String>\n     let re = Regex::new(r\"([^\\\\](\\\\\\\\)*)\\\\[\\n\\r][[:space:]]*\").unwrap();\n     let stripped_str = re.replace_all(orig, \"$1\");\n \n-    let graphemes = UnicodeSegmentation::graphemes(&*stripped_str, false).collect::<Vec<&str>>();\n+    let graphemes = UnicodeSegmentation::graphemes(&*stripped_str, false)\n+        .collect::<Vec<&str>>();\n     let shape = fmt.shape.visual_indent(0);\n     let indent = shape.indent.to_string(fmt.config);\n     let punctuation = \":,;.\";"}, {"sha": "688d6719441610cce02b2fe22d3078a28b92c3be", "filename": "src/types.rs", "status": "modified", "additions": 25, "deletions": 36, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/cb464a919af8a3297a0374bff3ab671567c1300c/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb464a919af8a3297a0374bff3ab671567c1300c/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=cb464a919af8a3297a0374bff3ab671567c1300c", "patch": "@@ -364,12 +364,11 @@ impl Rewrite for ast::WherePredicate {\n                 let colon = type_bound_colon(context);\n \n                 if !bound_lifetimes.is_empty() {\n-                    let lifetime_str: String =\n-                        try_opt!(bound_lifetimes\n-                                     .iter()\n-                                     .map(|lt| lt.rewrite(context, shape))\n-                                     .intersperse(Some(\", \".to_string()))\n-                                     .collect());\n+                    let lifetime_str: String = try_opt!(bound_lifetimes\n+                                                            .iter()\n+                                                            .map(|lt| lt.rewrite(context, shape))\n+                                                            .intersperse(Some(\", \".to_string()))\n+                                                            .collect());\n \n                     let joiner = match context.config.type_punctuation_density() {\n                         TypeDensity::Compressed => \"+\",\n@@ -378,17 +377,13 @@ impl Rewrite for ast::WherePredicate {\n                     // 6 = \"for<> \".len()\n                     let used_width = lifetime_str.len() + type_str.len() + colon.len() + 6;\n                     let budget = try_opt!(shape.width.checked_sub(used_width));\n-                    let bounds_str: String =\n-                        try_opt!(bounds\n-                                     .iter()\n-                                     .map(|ty_bound| {\n-                                              ty_bound.rewrite(context,\n-                                                               Shape::legacy(budget,\n-                                                                             shape.indent +\n-                                                                             used_width))\n-                                          })\n-                                     .intersperse(Some(joiner.to_string()))\n-                                     .collect());\n+                    let bounds_str: String = try_opt!(bounds\n+                                                          .iter()\n+                                                          .map(|ty_bound| {\n+                        ty_bound.rewrite(context, Shape::legacy(budget, shape.indent + used_width))\n+                    })\n+                                                          .intersperse(Some(joiner.to_string()))\n+                                                          .collect());\n \n                     if context.config.spaces_within_angle_brackets() && lifetime_str.len() > 0 {\n                         format!(\"for< {} > {}{}{}\",\n@@ -406,17 +401,13 @@ impl Rewrite for ast::WherePredicate {\n                     };\n                     let used_width = type_str.len() + colon.len();\n                     let budget = try_opt!(shape.width.checked_sub(used_width));\n-                    let bounds_str: String =\n-                        try_opt!(bounds\n-                                     .iter()\n-                                     .map(|ty_bound| {\n-                                              ty_bound.rewrite(context,\n-                                                               Shape::legacy(budget,\n-                                                                             shape.indent +\n-                                                                             used_width))\n-                                          })\n-                                     .intersperse(Some(joiner.to_string()))\n-                                     .collect());\n+                    let bounds_str: String = try_opt!(bounds\n+                                                          .iter()\n+                                                          .map(|ty_bound| {\n+                        ty_bound.rewrite(context, Shape::legacy(budget, shape.indent + used_width))\n+                    })\n+                                                          .intersperse(Some(joiner.to_string()))\n+                                                          .collect());\n \n                     format!(\"{}{}{}\", type_str, colon, bounds_str)\n                 }\n@@ -532,12 +523,11 @@ impl Rewrite for ast::TyParam {\n                 TypeDensity::Compressed => \"+\",\n                 TypeDensity::Wide => \" + \",\n             };\n-            let bounds: String =\n-                try_opt!(self.bounds\n-                             .iter()\n-                             .map(|ty_bound| ty_bound.rewrite(context, shape))\n-                             .intersperse(Some(joiner.to_string()))\n-                             .collect());\n+            let bounds: String = try_opt!(self.bounds\n+                                              .iter()\n+                                              .map(|ty_bound| ty_bound.rewrite(context, shape))\n+                                              .intersperse(Some(joiner.to_string()))\n+                                              .collect());\n \n             result.push_str(&bounds);\n         }\n@@ -612,8 +602,7 @@ impl Rewrite for ast::Ty {\n                              let lt_budget = try_opt!(shape.width.checked_sub(2 + mut_len));\n                              let lt_str = try_opt!(lifetime.rewrite(context,\n                                                                     Shape::legacy(lt_budget,\n-                                                                                  shape.indent +\n-                                                                                  2 +\n+                                                                                  shape.indent + 2 +\n                                                                                   mut_len)));\n                              let lt_len = lt_str.len();\n                              let budget = try_opt!(shape.width.checked_sub(2 + mut_len + lt_len));"}, {"sha": "ded35d04196e00abef327654b5a9e9a4eafc37c9", "filename": "src/utils.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cb464a919af8a3297a0374bff3ab671567c1300c/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb464a919af8a3297a0374bff3ab671567c1300c/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=cb464a919af8a3297a0374bff3ab671567c1300c", "patch": "@@ -334,7 +334,8 @@ pub fn wrap_str<S: AsRef<str>>(s: S, max_width: usize, shape: Shape) -> Option<S\n \n impl Rewrite for String {\n     fn rewrite(&self, context: &RewriteContext, shape: Shape) -> Option<String> {\n-        wrap_str(self, context.config.max_width(), shape).map(ToOwned::to_owned)\n+        wrap_str(self, context.config.max_width(), shape)\n+            .map(ToOwned::to_owned)\n     }\n }\n "}, {"sha": "70c8033da6c52986e3845d5364dd313021e102e7", "filename": "tests/system.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/cb464a919af8a3297a0374bff3ab671567c1300c/tests%2Fsystem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb464a919af8a3297a0374bff3ab671567c1300c/tests%2Fsystem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsystem.rs?ref=cb464a919af8a3297a0374bff3ab671567c1300c", "patch": "@@ -55,7 +55,8 @@ fn system_tests() {\n // the only difference is the coverage mode\n #[test]\n fn coverage_tests() {\n-    let files = fs::read_dir(\"tests/coverage/source\").expect(\"Couldn't read source dir\");\n+    let files = fs::read_dir(\"tests/coverage/source\")\n+        .expect(\"Couldn't read source dir\");\n     let files = files.map(get_path_string);\n     let (_reports, count, fails) = check_files(files);\n \n@@ -82,7 +83,8 @@ fn assert_output(source: &str, expected_filename: &str) {\n     let _ = filemap::write_all_files(&file_map, &mut out, &config);\n     let output = String::from_utf8(out).unwrap();\n \n-    let mut expected_file = fs::File::open(&expected_filename).expect(\"Couldn't open target\");\n+    let mut expected_file = fs::File::open(&expected_filename)\n+        .expect(\"Couldn't open target\");\n     let mut expected_text = String::new();\n     expected_file\n         .read_to_string(&mut expected_text)\n@@ -277,7 +279,8 @@ fn get_config(config_file: Option<&str>) -> Config {\n         }\n     };\n \n-    let mut def_config_file = fs::File::open(config_file_name).expect(\"Couldn't open config\");\n+    let mut def_config_file = fs::File::open(config_file_name)\n+        .expect(\"Couldn't open config\");\n     let mut def_config = String::new();\n     def_config_file\n         .read_to_string(&mut def_config)"}, {"sha": "80b024829912fd786336d20f11b69d5881f5e47c", "filename": "tests/target/chains.rs", "status": "modified", "additions": 23, "deletions": 29, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/cb464a919af8a3297a0374bff3ab671567c1300c/tests%2Ftarget%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb464a919af8a3297a0374bff3ab671567c1300c/tests%2Ftarget%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fchains.rs?ref=cb464a919af8a3297a0374bff3ab671567c1300c", "patch": "@@ -66,38 +66,34 @@ fn floaters() {\n     };\n \n     let x = Foo {\n-            field1: val1,\n-            field2: val2,\n-        }\n-        .method_call()\n+        field1: val1,\n+        field2: val2,\n+    }.method_call()\n         .method_call();\n \n     let y = if cond {\n-            val1\n-        } else {\n-            val2\n-        }\n-        .method_call();\n+        val1\n+    } else {\n+        val2\n+    }.method_call();\n \n     {\n         match x {\n             PushParam => {\n                 // params are 1-indexed\n                 stack.push(mparams[match cur.to_digit(10) {\n-                                   Some(d) => d as usize - 1,\n-                                   None => return Err(\"bad param number\".to_owned()),\n-                               }]\n-                               .clone());\n+                    Some(d) => d as usize - 1,\n+                    None => return Err(\"bad param number\".to_owned()),\n+                }].clone());\n             }\n         }\n     }\n \n     if cond {\n-            some();\n-        } else {\n-            none();\n-        }\n-        .bar()\n+        some();\n+    } else {\n+        none();\n+    }.bar()\n         .baz();\n \n     Foo { x: val }\n@@ -108,21 +104,19 @@ fn floaters() {\n         .quux();\n \n     Foo {\n-            y: i_am_multi_line,\n-            z: ok,\n-        }\n-        .baz(|| {\n-                 force();\n-                 multiline();\n-             })\n+        y: i_am_multi_line,\n+        z: ok,\n+    }.baz(|| {\n+              force();\n+              multiline();\n+          })\n         .quux();\n \n     a +\n     match x {\n-            true => \"yay!\",\n-            false => \"boo!\",\n-        }\n-        .bar()\n+        true => \"yay!\",\n+        false => \"boo!\",\n+    }.bar()\n }\n \n fn is_replaced_content() -> bool {"}, {"sha": "8149269158c2fa89110952654d6466c9a1e8dbfb", "filename": "tests/target/configs-fn_call_style-block.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/cb464a919af8a3297a0374bff3ab671567c1300c/tests%2Ftarget%2Fconfigs-fn_call_style-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb464a919af8a3297a0374bff3ab671567c1300c/tests%2Ftarget%2Fconfigs-fn_call_style-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fconfigs-fn_call_style-block.rs?ref=cb464a919af8a3297a0374bff3ab671567c1300c", "patch": "@@ -37,8 +37,7 @@ fn issue1420() {\n         # Getting started\n         ...\n     \"#,\n-    )\n-        .running(waltz)\n+    ).running(waltz)\n }\n \n // #1563"}, {"sha": "a43f314a2420c554b419dbef365c0f81f41966a6", "filename": "tests/target/file-lines-1.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cb464a919af8a3297a0374bff3ab671567c1300c/tests%2Ftarget%2Ffile-lines-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb464a919af8a3297a0374bff3ab671567c1300c/tests%2Ftarget%2Ffile-lines-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Ffile-lines-1.rs?ref=cb464a919af8a3297a0374bff3ab671567c1300c", "patch": "@@ -2,10 +2,9 @@\n \n fn floaters() {\n     let x = Foo {\n-            field1: val1,\n-            field2: val2,\n-        }\n-        .method_call()\n+        field1: val1,\n+        field2: val2,\n+    }.method_call()\n         .method_call();\n \n     let y = if cond {"}, {"sha": "754c7c879b014e6e510c46f5e58b78e967243eb1", "filename": "tests/target/file-lines-3.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/cb464a919af8a3297a0374bff3ab671567c1300c/tests%2Ftarget%2Ffile-lines-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb464a919af8a3297a0374bff3ab671567c1300c/tests%2Ftarget%2Ffile-lines-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Ffile-lines-3.rs?ref=cb464a919af8a3297a0374bff3ab671567c1300c", "patch": "@@ -3,10 +3,9 @@\n \n fn floaters() {\n     let x = Foo {\n-            field1: val1,\n-            field2: val2,\n-        }\n-        .method_call()\n+        field1: val1,\n+        field2: val2,\n+    }.method_call()\n         .method_call();\n \n     let y = if cond { val1 } else { val2 }.method_call();"}]}