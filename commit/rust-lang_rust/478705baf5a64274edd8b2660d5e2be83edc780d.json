{"sha": "478705baf5a64274edd8b2660d5e2be83edc780d", "node_id": "C_kwDOAAsO6NoAKDQ3ODcwNWJhZjVhNjQyNzRlZGQ4YjI2NjBkNWUyYmU4M2VkYzc4MGQ", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2023-05-16T20:47:27Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2023-05-16T20:47:27Z"}, "message": "fix: Diagnose non-value return and break type mismatches", "tree": {"sha": "ebe6e011dc37cdc3d79f58b28bbb91f9d26a8731", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ebe6e011dc37cdc3d79f58b28bbb91f9d26a8731"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/478705baf5a64274edd8b2660d5e2be83edc780d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/478705baf5a64274edd8b2660d5e2be83edc780d", "html_url": "https://github.com/rust-lang/rust/commit/478705baf5a64274edd8b2660d5e2be83edc780d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/478705baf5a64274edd8b2660d5e2be83edc780d/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2f8cd66fb4c98026d2bdbdf17270e3472e1ca42a", "url": "https://api.github.com/repos/rust-lang/rust/commits/2f8cd66fb4c98026d2bdbdf17270e3472e1ca42a", "html_url": "https://github.com/rust-lang/rust/commit/2f8cd66fb4c98026d2bdbdf17270e3472e1ca42a"}], "stats": {"total": 85, "additions": 62, "deletions": 23}, "files": [{"sha": "05a476f632dc25341d72163f526f57050fb5cd2d", "filename": "crates/hir-ty/src/infer/coerce.rs", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/478705baf5a64274edd8b2660d5e2be83edc780d/crates%2Fhir-ty%2Fsrc%2Finfer%2Fcoerce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478705baf5a64274edd8b2660d5e2be83edc780d/crates%2Fhir-ty%2Fsrc%2Finfer%2Fcoerce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fcoerce.rs?ref=478705baf5a64274edd8b2660d5e2be83edc780d", "patch": "@@ -50,6 +50,13 @@ fn success(\n     Ok(InferOk { goals, value: (adj, target) })\n }\n \n+pub(super) enum CoercionCause {\n+    // FIXME: Make better use of this. Right now things like return and break without a value\n+    // use it to point to themselves, causing us to report a mismatch on those expressions even\n+    // though technically they themselves are `!`\n+    Expr(ExprId),\n+}\n+\n #[derive(Clone, Debug)]\n pub(super) struct CoerceMany {\n     expected_ty: Ty,\n@@ -90,8 +97,12 @@ impl CoerceMany {\n         }\n     }\n \n-    pub(super) fn coerce_forced_unit(&mut self, ctx: &mut InferenceContext<'_>) {\n-        self.coerce(ctx, None, &ctx.result.standard_types.unit.clone())\n+    pub(super) fn coerce_forced_unit(\n+        &mut self,\n+        ctx: &mut InferenceContext<'_>,\n+        cause: CoercionCause,\n+    ) {\n+        self.coerce(ctx, None, &ctx.result.standard_types.unit.clone(), cause)\n     }\n \n     /// Merge two types from different branches, with possible coercion.\n@@ -106,6 +117,7 @@ impl CoerceMany {\n         ctx: &mut InferenceContext<'_>,\n         expr: Option<ExprId>,\n         expr_ty: &Ty,\n+        cause: CoercionCause,\n     ) {\n         let expr_ty = ctx.resolve_ty_shallow(expr_ty);\n         self.expected_ty = ctx.resolve_ty_shallow(&self.expected_ty);\n@@ -153,11 +165,13 @@ impl CoerceMany {\n         } else if let Ok(res) = ctx.coerce(expr, &self.merged_ty(), &expr_ty) {\n             self.final_ty = Some(res);\n         } else {\n-            if let Some(id) = expr {\n-                ctx.result.type_mismatches.insert(\n-                    id.into(),\n-                    TypeMismatch { expected: self.merged_ty(), actual: expr_ty.clone() },\n-                );\n+            match cause {\n+                CoercionCause::Expr(id) => {\n+                    ctx.result.type_mismatches.insert(\n+                        id.into(),\n+                        TypeMismatch { expected: self.merged_ty(), actual: expr_ty.clone() },\n+                    );\n+                }\n             }\n             cov_mark::hit!(coerce_merge_fail_fallback);\n         }"}, {"sha": "353bf6568c107d097bfe13bcd6bd551a4b67c473", "filename": "crates/hir-ty/src/infer/expr.rs", "status": "modified", "additions": 27, "deletions": 16, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/478705baf5a64274edd8b2660d5e2be83edc780d/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478705baf5a64274edd8b2660d5e2be83edc780d/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fexpr.rs?ref=478705baf5a64274edd8b2660d5e2be83edc780d", "patch": "@@ -26,7 +26,10 @@ use crate::{\n     autoderef::{builtin_deref, deref_by_trait, Autoderef},\n     consteval,\n     infer::{\n-        coerce::CoerceMany, find_continuable, pat::contains_explicit_ref_binding, BreakableKind,\n+        coerce::{CoerceMany, CoercionCause},\n+        find_continuable,\n+        pat::contains_explicit_ref_binding,\n+        BreakableKind,\n     },\n     lang_items::lang_items_for_bin_op,\n     lower::{\n@@ -132,24 +135,28 @@ impl<'a> InferenceContext<'a> {\n                 );\n \n                 let condition_diverges = mem::replace(&mut self.diverges, Diverges::Maybe);\n-                let mut both_arms_diverge = Diverges::Always;\n \n                 let then_ty = self.infer_expr_inner(then_branch, expected);\n-                both_arms_diverge &= mem::replace(&mut self.diverges, Diverges::Maybe);\n+                let then_diverges = mem::replace(&mut self.diverges, Diverges::Maybe);\n                 let mut coerce = CoerceMany::new(expected.coercion_target_type(&mut self.table));\n-                coerce.coerce(self, Some(then_branch), &then_ty);\n+                coerce.coerce(self, Some(then_branch), &then_ty, CoercionCause::Expr(then_branch));\n                 match else_branch {\n                     Some(else_branch) => {\n                         let else_ty = self.infer_expr_inner(else_branch, expected);\n-                        coerce.coerce(self, Some(else_branch), &else_ty);\n+                        let else_diverges = mem::replace(&mut self.diverges, Diverges::Maybe);\n+                        coerce.coerce(\n+                            self,\n+                            Some(else_branch),\n+                            &else_ty,\n+                            CoercionCause::Expr(else_branch),\n+                        );\n+                        self.diverges = condition_diverges | then_diverges & else_diverges;\n                     }\n                     None => {\n-                        coerce.coerce_forced_unit(self);\n+                        coerce.coerce_forced_unit(self, CoercionCause::Expr(tgt_expr));\n+                        self.diverges = condition_diverges;\n                     }\n                 }\n-                both_arms_diverge &= self.diverges;\n-\n-                self.diverges = condition_diverges | both_arms_diverge;\n \n                 coerce.complete(self)\n             }\n@@ -444,7 +451,7 @@ impl<'a> InferenceContext<'a> {\n \n                         let arm_ty = self.infer_expr_inner(arm.expr, &expected);\n                         all_arms_diverge &= self.diverges;\n-                        coerce.coerce(self, Some(arm.expr), &arm_ty);\n+                        coerce.coerce(self, Some(arm.expr), &arm_ty, CoercionCause::Expr(arm.expr));\n                     }\n \n                     self.diverges = matchee_diverges | all_arms_diverge;\n@@ -492,7 +499,11 @@ impl<'a> InferenceContext<'a> {\n                 match find_breakable(&mut self.breakables, label) {\n                     Some(ctxt) => match ctxt.coerce.take() {\n                         Some(mut coerce) => {\n-                            coerce.coerce(self, expr, &val_ty);\n+                            let cause = match expr {\n+                                Some(expr) => CoercionCause::Expr(expr),\n+                                None => CoercionCause::Expr(tgt_expr),\n+                            };\n+                            coerce.coerce(self, expr, &val_ty, cause);\n \n                             // Avoiding borrowck\n                             let ctxt = find_breakable(&mut self.breakables, label)\n@@ -512,7 +523,7 @@ impl<'a> InferenceContext<'a> {\n                 }\n                 self.result.standard_types.never.clone()\n             }\n-            &Expr::Return { expr } => self.infer_expr_return(expr),\n+            &Expr::Return { expr } => self.infer_expr_return(tgt_expr, expr),\n             Expr::Yield { expr } => {\n                 if let Some((resume_ty, yield_ty)) = self.resume_yield_tys.clone() {\n                     if let Some(expr) = expr {\n@@ -952,7 +963,7 @@ impl<'a> InferenceContext<'a> {\n                 let mut coerce = CoerceMany::new(elem_ty);\n                 for &expr in elements.iter() {\n                     let cur_elem_ty = self.infer_expr_inner(expr, &expected);\n-                    coerce.coerce(self, Some(expr), &cur_elem_ty);\n+                    coerce.coerce(self, Some(expr), &cur_elem_ty, CoercionCause::Expr(expr));\n                 }\n                 (\n                     coerce.complete(self),\n@@ -997,18 +1008,18 @@ impl<'a> InferenceContext<'a> {\n             .expected_ty();\n         let return_expr_ty = self.infer_expr_inner(expr, &Expectation::HasType(ret_ty));\n         let mut coerce_many = self.return_coercion.take().unwrap();\n-        coerce_many.coerce(self, Some(expr), &return_expr_ty);\n+        coerce_many.coerce(self, Some(expr), &return_expr_ty, CoercionCause::Expr(expr));\n         self.return_coercion = Some(coerce_many);\n     }\n \n-    fn infer_expr_return(&mut self, expr: Option<ExprId>) -> Ty {\n+    fn infer_expr_return(&mut self, ret: ExprId, expr: Option<ExprId>) -> Ty {\n         match self.return_coercion {\n             Some(_) => {\n                 if let Some(expr) = expr {\n                     self.infer_return(expr);\n                 } else {\n                     let mut coerce = self.return_coercion.take().unwrap();\n-                    coerce.coerce_forced_unit(self);\n+                    coerce.coerce_forced_unit(self, CoercionCause::Expr(ret));\n                     self.return_coercion = Some(coerce);\n                 }\n             }"}, {"sha": "a5359741ac9502e8179d54bf6f5068c8ac61f506", "filename": "crates/ide-diagnostics/src/handlers/type_mismatch.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/478705baf5a64274edd8b2660d5e2be83edc780d/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Ftype_mismatch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/478705baf5a64274edd8b2660d5e2be83edc780d/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Ftype_mismatch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Ftype_mismatch.rs?ref=478705baf5a64274edd8b2660d5e2be83edc780d", "patch": "@@ -678,6 +678,20 @@ struct Bar {\n     f2: &[u16],\n     f3: dyn Debug,\n }\n+\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn return_no_value() {\n+        check_diagnostics(\n+            r#\"\n+fn f() -> i32 {\n+    return;\n+ // ^^^^^^ error: expected i32, found ()\n+    0\n+}\n+fn g() { return; }\n \"#,\n         );\n     }"}]}