{"sha": "c654a07d29c77b5a023cb9d36dfc61811349f64e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM2NTRhMDdkMjljNzdiNWEwMjNjYjlkMzZkZmM2MTgxMTM0OWY2NGU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-05-26T12:15:30Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-05-26T12:15:30Z"}, "message": "Auto merge of #25785 - arielb1:cleanup-201505, r=eddyb\n\nThe caching essentially eliminates \"stability checking\" time (my attempt to clean-up junk got tangled up with stability, so I added the caching while I was at it).\r\n\r\nr? @eddyb", "tree": {"sha": "4faa4a46234225d1a2aa9de818975f334ff3037c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4faa4a46234225d1a2aa9de818975f334ff3037c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c654a07d29c77b5a023cb9d36dfc61811349f64e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c654a07d29c77b5a023cb9d36dfc61811349f64e", "html_url": "https://github.com/rust-lang/rust/commit/c654a07d29c77b5a023cb9d36dfc61811349f64e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c654a07d29c77b5a023cb9d36dfc61811349f64e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8a872943ff0fac763eefa52de1ffb1344e698d98", "url": "https://api.github.com/repos/rust-lang/rust/commits/8a872943ff0fac763eefa52de1ffb1344e698d98", "html_url": "https://github.com/rust-lang/rust/commit/8a872943ff0fac763eefa52de1ffb1344e698d98"}, {"sha": "0ec3183df8d0cdccc735fa6572d664b43dbb5e31", "url": "https://api.github.com/repos/rust-lang/rust/commits/0ec3183df8d0cdccc735fa6572d664b43dbb5e31", "html_url": "https://github.com/rust-lang/rust/commit/0ec3183df8d0cdccc735fa6572d664b43dbb5e31"}], "stats": {"total": 700, "additions": 210, "deletions": 490}, "files": [{"sha": "5f785fefa1241f93c50eb644a5d05daf467c348b", "filename": "src/librustc/metadata/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c654a07d29c77b5a023cb9d36dfc61811349f64e/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c654a07d29c77b5a023cb9d36dfc61811349f64e/src%2Flibrustc%2Fmetadata%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcommon.rs?ref=c654a07d29c77b5a023cb9d36dfc61811349f64e", "patch": "@@ -146,7 +146,7 @@ enum_from_u32! {\n         tag_table_closure_kinds = 0x65,\n         tag_table_upvar_capture_map = 0x66,\n         tag_table_capture_modes = 0x67,\n-        tag_table_object_cast_map = 0x68,\n+        // GAP 0x68\n         tag_table_const_qualif = 0x69,\n         tag_table_cast_kinds = 0x6a,\n     }"}, {"sha": "47aad257d156f73d8eec20d664aa67cb57c49a94", "filename": "src/librustc/metadata/csearch.rs", "status": "modified", "additions": 7, "deletions": 16, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c654a07d29c77b5a023cb9d36dfc61811349f64e/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c654a07d29c77b5a023cb9d36dfc61811349f64e/src%2Flibrustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcsearch.rs?ref=c654a07d29c77b5a023cb9d36dfc61811349f64e", "patch": "@@ -297,15 +297,6 @@ pub fn get_impl_trait<'tcx>(tcx: &ty::ctxt<'tcx>,\n     decoder::get_impl_trait(&*cdata, def.node, tcx)\n }\n \n-// Given a def_id for an impl, return information about its vtables\n-pub fn get_impl_vtables<'tcx>(tcx: &ty::ctxt<'tcx>,\n-                              def: ast::DefId)\n-                              -> ty::vtable_res<'tcx> {\n-    let cstore = &tcx.sess.cstore;\n-    let cdata = cstore.get_crate_data(def.krate);\n-    decoder::get_impl_vtables(&*cdata, def.node, tcx)\n-}\n-\n pub fn get_native_libraries(cstore: &cstore::CStore, crate_num: ast::CrateNum)\n                             -> Vec<(cstore::NativeLibraryKind, String)> {\n     let cdata = cstore.get_crate_data(crate_num);\n@@ -389,15 +380,20 @@ pub fn is_const_fn(cstore: &cstore::CStore, did: ast::DefId) -> bool {\n     decoder::is_const_fn(&*cdata, did.node)\n }\n \n+pub fn is_impl(cstore: &cstore::CStore, did: ast::DefId) -> bool {\n+    let cdata = cstore.get_crate_data(did.krate);\n+    decoder::is_impl(&*cdata, did.node)\n+}\n+\n pub fn get_stability(cstore: &cstore::CStore,\n                      def: ast::DefId)\n                      -> Option<attr::Stability> {\n     let cdata = cstore.get_crate_data(def.krate);\n     decoder::get_stability(&*cdata, def.node)\n }\n \n-pub fn is_staged_api(cstore: &cstore::CStore, def: ast::DefId) -> bool {\n-    let cdata = cstore.get_crate_data(def.krate);\n+pub fn is_staged_api(cstore: &cstore::CStore, krate: ast::CrateNum) -> bool {\n+    let cdata = cstore.get_crate_data(krate);\n     let attrs = decoder::get_crate_attributes(cdata.data());\n     for attr in &attrs {\n         if &attr.name()[..] == \"staged_api\" {\n@@ -414,11 +410,6 @@ pub fn get_repr_attrs(cstore: &cstore::CStore, def: ast::DefId)\n     decoder::get_repr_attrs(&*cdata, def.node)\n }\n \n-pub fn is_associated_type(cstore: &cstore::CStore, def: ast::DefId) -> bool {\n-    let cdata = cstore.get_crate_data(def.krate);\n-    decoder::is_associated_type(&*cdata, def.node)\n-}\n-\n pub fn is_defaulted_trait(cstore: &cstore::CStore, trait_def_id: ast::DefId) -> bool {\n     let cdata = cstore.get_crate_data(trait_def_id.krate);\n     decoder::is_defaulted_trait(&*cdata, trait_def_id.node)"}, {"sha": "42dcc9661ca2d0ec97619d27ac6019c703de275b", "filename": "src/librustc/metadata/decoder.rs", "status": "modified", "additions": 8, "deletions": 21, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/c654a07d29c77b5a023cb9d36dfc61811349f64e/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c654a07d29c77b5a023cb9d36dfc61811349f64e/src%2Flibrustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fdecoder.rs?ref=c654a07d29c77b5a023cb9d36dfc61811349f64e", "patch": "@@ -30,7 +30,6 @@ use middle::lang_items;\n use middle::subst;\n use middle::ty::{ImplContainer, TraitContainer};\n use middle::ty::{self, Ty};\n-use middle::astencode::vtable_decoder_helpers;\n use util::nodemap::FnvHashMap;\n \n use std::cell::{Cell, RefCell};\n@@ -522,18 +521,6 @@ pub fn get_impl_trait<'tcx>(cdata: Cmd,\n     }\n }\n \n-pub fn get_impl_vtables<'tcx>(cdata: Cmd,\n-                              id: ast::NodeId,\n-                              tcx: &ty::ctxt<'tcx>)\n-                              -> ty::vtable_res<'tcx>\n-{\n-    let item_doc = lookup_item(id, cdata.data());\n-    let vtables_doc = reader::get_doc(item_doc, tag_item_impl_vtables);\n-    let mut decoder = reader::Decoder::new(vtables_doc);\n-    decoder.read_vtable_res(tcx, cdata)\n-}\n-\n-\n pub fn get_symbol(data: &[u8], id: ast::NodeId) -> String {\n     return item_symbol(lookup_item(id, data));\n }\n@@ -1546,6 +1533,14 @@ pub fn is_const_fn(cdata: Cmd, id: ast::NodeId) -> bool {\n     }\n }\n \n+pub fn is_impl(cdata: Cmd, id: ast::NodeId) -> bool {\n+    let item_doc = lookup_item(id, cdata.data());\n+    match item_family(item_doc) {\n+        Impl => true,\n+        _ => false,\n+    }\n+}\n+\n fn doc_generics<'tcx>(base_doc: rbml::Doc,\n                       tcx: &ty::ctxt<'tcx>,\n                       cdata: Cmd,\n@@ -1623,14 +1618,6 @@ fn doc_predicates<'tcx>(base_doc: rbml::Doc,\n     ty::GenericPredicates { predicates: predicates }\n }\n \n-pub fn is_associated_type(cdata: Cmd, id: ast::NodeId) -> bool {\n-    let items = reader::get_doc(rbml::Doc::new(cdata.data()), tag_items);\n-    match maybe_find_item(id, items) {\n-        None => false,\n-        Some(item) => item_sort(item) == Some('t'),\n-    }\n-}\n-\n pub fn is_defaulted_trait(cdata: Cmd, trait_id: ast::NodeId) -> bool {\n     let trait_doc = lookup_item(trait_id, cdata.data());\n     assert!(item_family(trait_doc) == Family::Trait);"}, {"sha": "0908ffd249fe40ba880dffd64649d1a39caa5ed4", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c654a07d29c77b5a023cb9d36dfc61811349f64e/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c654a07d29c77b5a023cb9d36dfc61811349f64e/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=c654a07d29c77b5a023cb9d36dfc61811349f64e", "patch": "@@ -999,7 +999,7 @@ fn encode_extension_implementations(ecx: &EncodeContext,\n     });\n }\n \n-fn encode_stability(rbml_w: &mut Encoder, stab_opt: Option<attr::Stability>) {\n+fn encode_stability(rbml_w: &mut Encoder, stab_opt: Option<&attr::Stability>) {\n     stab_opt.map(|stab| {\n         rbml_w.start_tag(tag_items_data_item_stability);\n         stab.encode(rbml_w).unwrap();\n@@ -1215,11 +1215,11 @@ fn encode_info_for_item(ecx: &EncodeContext,\n           encode_name(rbml_w, item.ident.name);\n           encode_unsafety(rbml_w, unsafety);\n \n-          let trait_ref = ty::impl_id_to_trait_ref(tcx, item.id);\n+          let trait_ref = ty::impl_trait_ref(tcx, local_def(item.id)).unwrap();\n           encode_trait_ref(rbml_w, ecx, trait_ref, tag_item_trait_ref);\n           rbml_w.end_tag();\n       }\n-      ast::ItemImpl(unsafety, polarity, _, ref opt_trait, ref ty, ref ast_items) => {\n+      ast::ItemImpl(unsafety, polarity, _, _, ref ty, ref ast_items) => {\n         // We need to encode information about the default methods we\n         // have inherited, so we drive this based on the impl structure.\n         let impl_items = tcx.impl_items.borrow();\n@@ -1269,8 +1269,7 @@ fn encode_info_for_item(ecx: &EncodeContext,\n             }\n             rbml_w.end_tag();\n         }\n-        if opt_trait.is_some() {\n-            let trait_ref = ty::impl_id_to_trait_ref(tcx, item.id);\n+        if let Some(trait_ref) = ty::impl_trait_ref(tcx, local_def(item.id)) {\n             encode_trait_ref(rbml_w, ecx, trait_ref, tag_item_trait_ref);\n         }\n         encode_path(rbml_w, path.clone());"}, {"sha": "fda57c9dc610a5a222bc6faba121920b5ce07b77", "filename": "src/librustc/middle/astencode.rs", "status": "modified", "additions": 0, "deletions": 104, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/c654a07d29c77b5a023cb9d36dfc61811349f64e/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c654a07d29c77b5a023cb9d36dfc61811349f64e/src%2Flibrustc%2Fmiddle%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fastencode.rs?ref=c654a07d29c77b5a023cb9d36dfc61811349f64e", "patch": "@@ -696,19 +696,6 @@ pub fn encode_cast_kind(ebml_w: &mut Encoder, kind: cast::CastKind) {\n pub trait vtable_decoder_helpers<'tcx> {\n     fn read_vec_per_param_space<T, F>(&mut self, f: F) -> VecPerParamSpace<T> where\n         F: FnMut(&mut Self) -> T;\n-    fn read_vtable_res_with_key(&mut self,\n-                                tcx: &ty::ctxt<'tcx>,\n-                                cdata: &cstore::crate_metadata)\n-                                -> (u32, ty::vtable_res<'tcx>);\n-    fn read_vtable_res(&mut self,\n-                       tcx: &ty::ctxt<'tcx>, cdata: &cstore::crate_metadata)\n-                      -> ty::vtable_res<'tcx>;\n-    fn read_vtable_param_res(&mut self,\n-                       tcx: &ty::ctxt<'tcx>, cdata: &cstore::crate_metadata)\n-                      -> ty::vtable_param_res<'tcx>;\n-    fn read_vtable_origin(&mut self,\n-                          tcx: &ty::ctxt<'tcx>, cdata: &cstore::crate_metadata)\n-                          -> ty::vtable_origin<'tcx>;\n }\n \n impl<'tcx, 'a> vtable_decoder_helpers<'tcx> for reader::Decoder<'a> {\n@@ -720,85 +707,6 @@ impl<'tcx, 'a> vtable_decoder_helpers<'tcx> for reader::Decoder<'a> {\n         let fns = self.read_to_vec(|this| Ok(f(this))).unwrap();\n         VecPerParamSpace::new(types, selfs, fns)\n     }\n-\n-    fn read_vtable_res_with_key(&mut self,\n-                                tcx: &ty::ctxt<'tcx>,\n-                                cdata: &cstore::crate_metadata)\n-                                -> (u32, ty::vtable_res<'tcx>) {\n-        self.read_struct(\"VtableWithKey\", 2, |this| {\n-            let autoderef = this.read_struct_field(\"autoderef\", 0, |this| {\n-                Decodable::decode(this)\n-            }).unwrap();\n-            Ok((autoderef, this.read_struct_field(\"vtable_res\", 1, |this| {\n-                Ok(this.read_vtable_res(tcx, cdata))\n-            }).unwrap()))\n-        }).unwrap()\n-    }\n-\n-    fn read_vtable_res(&mut self,\n-                       tcx: &ty::ctxt<'tcx>,\n-                       cdata: &cstore::crate_metadata)\n-                       -> ty::vtable_res<'tcx>\n-    {\n-        self.read_vec_per_param_space(\n-            |this| this.read_vtable_param_res(tcx, cdata))\n-    }\n-\n-    fn read_vtable_param_res(&mut self,\n-                             tcx: &ty::ctxt<'tcx>, cdata: &cstore::crate_metadata)\n-                      -> ty::vtable_param_res<'tcx> {\n-        self.read_to_vec(|this| Ok(this.read_vtable_origin(tcx, cdata)))\n-             .unwrap().into_iter().collect()\n-    }\n-\n-    fn read_vtable_origin(&mut self,\n-                          tcx: &ty::ctxt<'tcx>, cdata: &cstore::crate_metadata)\n-        -> ty::vtable_origin<'tcx> {\n-        self.read_enum(\"vtable_origin\", |this| {\n-            this.read_enum_variant(&[\"vtable_static\",\n-                                     \"vtable_param\",\n-                                     \"vtable_error\",\n-                                     \"vtable_closure\"],\n-                                   |this, i| {\n-                Ok(match i {\n-                  0 => {\n-                    ty::vtable_static(\n-                        this.read_enum_variant_arg(0, |this| {\n-                            Ok(this.read_def_id_nodcx(cdata))\n-                        }).unwrap(),\n-                        this.read_enum_variant_arg(1, |this| {\n-                            Ok(this.read_substs_nodcx(tcx, cdata))\n-                        }).unwrap(),\n-                        this.read_enum_variant_arg(2, |this| {\n-                            Ok(this.read_vtable_res(tcx, cdata))\n-                        }).unwrap()\n-                    )\n-                  }\n-                  1 => {\n-                    ty::vtable_param(\n-                        this.read_enum_variant_arg(0, |this| {\n-                            Decodable::decode(this)\n-                        }).unwrap(),\n-                        this.read_enum_variant_arg(1, |this| {\n-                            this.read_uint()\n-                        }).unwrap()\n-                    )\n-                  }\n-                  2 => {\n-                    ty::vtable_closure(\n-                        this.read_enum_variant_arg(0, |this| {\n-                            Ok(this.read_def_id_nodcx(cdata))\n-                        }).unwrap()\n-                    )\n-                  }\n-                  3 => {\n-                    ty::vtable_error\n-                  }\n-                  _ => panic!(\"bad enum variant\")\n-                })\n-            })\n-        }).unwrap()\n-    }\n }\n \n // ___________________________________________________________________________\n@@ -1209,13 +1117,6 @@ fn encode_side_tables_for_id(ecx: &e::EncodeContext,\n         })\n     }\n \n-    if let Some(trait_ref) = tcx.object_cast_map.borrow().get(&id) {\n-        rbml_w.tag(c::tag_table_object_cast_map, |rbml_w| {\n-            rbml_w.id(id);\n-            rbml_w.emit_trait_ref(ecx, &trait_ref.0);\n-        })\n-    }\n-\n     if let Some(adjustment) = tcx.adjustments.borrow().get(&id) {\n         match *adjustment {\n             ty::AdjustDerefRef(ref adj) => {\n@@ -1800,11 +1701,6 @@ fn decode_side_tables(dcx: &DecodeContext,\n                         };\n                         dcx.tcx.method_map.borrow_mut().insert(method_call, method);\n                     }\n-                    c::tag_table_object_cast_map => {\n-                        let trait_ref = val_dsr.read_poly_trait_ref(dcx);\n-                        dcx.tcx.object_cast_map.borrow_mut()\n-                                               .insert(id, trait_ref);\n-                    }\n                     c::tag_table_adjustments => {\n                         let adj: ty::AutoAdjustment = val_dsr.read_auto_adjustment(dcx);\n                         dcx.tcx.adjustments.borrow_mut().insert(id, adj);"}, {"sha": "b29e40d2d5ec61cbbd3596ca82dbbdbf306f11fb", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 69, "deletions": 61, "changes": 130, "blob_url": "https://github.com/rust-lang/rust/blob/c654a07d29c77b5a023cb9d36dfc61811349f64e/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c654a07d29c77b5a023cb9d36dfc61811349f64e/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=c654a07d29c77b5a023cb9d36dfc61811349f64e", "patch": "@@ -23,46 +23,47 @@ use syntax::{attr, visit};\n use syntax::ast;\n use syntax::ast::{Attribute, Block, Crate, DefId, FnDecl, NodeId, Variant};\n use syntax::ast::{Item, Generics, StructField};\n-use syntax::ast_util::is_local;\n+use syntax::ast_util::{is_local, local_def};\n use syntax::attr::{Stability, AttrMetaMethods};\n use syntax::visit::{FnKind, Visitor};\n use syntax::feature_gate::emit_feature_err;\n-use util::nodemap::{NodeMap, DefIdMap, FnvHashSet, FnvHashMap};\n+use util::nodemap::{DefIdMap, FnvHashSet, FnvHashMap};\n use util::ppaux::Repr;\n \n use std::mem::replace;\n \n /// A stability index, giving the stability level for items and methods.\n-pub struct Index {\n-    // Indicates whether this crate has #![feature(staged_api)]\n-    staged_api: bool,\n-    // stability for crate-local items; unmarked stability == no entry\n-    local: NodeMap<Stability>,\n-    // cache for extern-crate items; unmarked stability == entry with None\n-    extern_cache: DefIdMap<Option<Stability>>\n+pub struct Index<'tcx> {\n+    /// This is mostly a cache, except the stabilities of local items\n+    /// are filled by the annotator.\n+    map: DefIdMap<Option<&'tcx Stability>>,\n+\n+    /// Maps for each crate whether it is part of the staged API.\n+    staged_api: FnvHashMap<ast::CrateNum, bool>\n }\n \n // A private tree-walker for producing an Index.\n-struct Annotator<'a> {\n-    sess: &'a Session,\n-    index: &'a mut Index,\n-    parent: Option<Stability>,\n+struct Annotator<'a, 'tcx: 'a> {\n+    tcx: &'a ty::ctxt<'tcx>,\n+    index: &'a mut Index<'tcx>,\n+    parent: Option<&'tcx Stability>,\n     export_map: &'a PublicItems,\n }\n \n-impl<'a> Annotator<'a> {\n+impl<'a, 'tcx: 'a> Annotator<'a, 'tcx> {\n     // Determine the stability for a node based on its attributes and inherited\n     // stability. The stability is recorded in the index and used as the parent.\n     fn annotate<F>(&mut self, id: NodeId, use_parent: bool,\n                    attrs: &Vec<Attribute>, item_sp: Span, f: F, required: bool) where\n         F: FnOnce(&mut Annotator),\n     {\n-        if self.index.staged_api {\n+        if self.index.staged_api[&ast::LOCAL_CRATE] {\n             debug!(\"annotate(id = {:?}, attrs = {:?})\", id, attrs);\n-            match attr::find_stability(self.sess.diagnostic(), attrs, item_sp) {\n+            match attr::find_stability(self.tcx.sess.diagnostic(), attrs, item_sp) {\n                 Some(stab) => {\n                     debug!(\"annotate: found {:?}\", stab);\n-                    self.index.local.insert(id, stab.clone());\n+                    let stab = self.tcx.intern_stability(stab);\n+                    self.index.map.insert(local_def(id), Some(stab));\n \n                     // Don't inherit #[stable(feature = \"rust1\", since = \"1.0.0\")]\n                     if stab.level != attr::Stable {\n@@ -77,13 +78,14 @@ impl<'a> Annotator<'a> {\n                     debug!(\"annotate: not found, use_parent = {:?}, parent = {:?}\",\n                            use_parent, self.parent);\n                     if use_parent {\n-                        if let Some(stab) = self.parent.clone() {\n-                            self.index.local.insert(id, stab);\n-                        } else if self.index.staged_api && required\n+                        if let Some(stab) = self.parent {\n+                            self.index.map.insert(local_def(id), Some(stab));\n+                        } else if self.index.staged_api[&ast::LOCAL_CRATE] && required\n                             && self.export_map.contains(&id)\n-                            && !self.sess.opts.test {\n-                                self.sess.span_err(item_sp,\n-                                                   \"This node does not have a stability attribute\");\n+                            && !self.tcx.sess.opts.test {\n+                                self.tcx.sess.span_err(item_sp,\n+                                                       \"This node does not \\\n+                                                        have a stability attribute\");\n                             }\n                     }\n                     f(self);\n@@ -95,7 +97,7 @@ impl<'a> Annotator<'a> {\n                 let tag = attr.name();\n                 if tag == \"unstable\" || tag == \"stable\" || tag == \"deprecated\" {\n                     attr::mark_used(attr);\n-                    self.sess.span_err(attr.span(),\n+                    self.tcx.sess.span_err(attr.span(),\n                                        \"stability attributes may not be used outside \\\n                                         of the standard library\");\n                 }\n@@ -105,7 +107,7 @@ impl<'a> Annotator<'a> {\n     }\n }\n \n-impl<'a, 'v> Visitor<'v> for Annotator<'a> {\n+impl<'a, 'tcx, 'v> Visitor<'v> for Annotator<'a, 'tcx> {\n     fn visit_item(&mut self, i: &Item) {\n         // FIXME (#18969): the following is a hack around the fact\n         // that we cannot currently annotate the stability of\n@@ -168,11 +170,11 @@ impl<'a, 'v> Visitor<'v> for Annotator<'a> {\n     }\n }\n \n-impl Index {\n+impl<'tcx> Index<'tcx> {\n     /// Construct the stability index for a crate being compiled.\n-    pub fn build(&mut self, sess: &Session, krate: &Crate, export_map: &PublicItems) {\n+    pub fn build(&mut self, tcx: &ty::ctxt<'tcx>, krate: &Crate, export_map: &PublicItems) {\n         let mut annotator = Annotator {\n-            sess: sess,\n+            tcx: tcx,\n             index: self,\n             parent: None,\n             export_map: export_map,\n@@ -182,22 +184,23 @@ impl Index {\n     }\n \n     pub fn new(krate: &Crate) -> Index {\n-        let mut staged_api = false;\n+        let mut is_staged_api = false;\n         for attr in &krate.attrs {\n             if &attr.name()[..] == \"staged_api\" {\n                 match attr.node.value.node {\n                     ast::MetaWord(_) => {\n                         attr::mark_used(attr);\n-                        staged_api = true;\n+                        is_staged_api = true;\n                     }\n                     _ => (/*pass*/)\n                 }\n             }\n         }\n+        let mut staged_api = FnvHashMap();\n+        staged_api.insert(ast::LOCAL_CRATE, is_staged_api);\n         Index {\n             staged_api: staged_api,\n-            local: NodeMap(),\n-            extern_cache: DefIdMap()\n+            map: DefIdMap(),\n         }\n     }\n }\n@@ -232,13 +235,13 @@ struct Checker<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> Checker<'a, 'tcx> {\n-    fn check(&mut self, id: ast::DefId, span: Span, stab: &Option<Stability>) {\n+    fn check(&mut self, id: ast::DefId, span: Span, stab: &Option<&Stability>) {\n         // Only the cross-crate scenario matters when checking unstable APIs\n         let cross_crate = !is_local(id);\n         if !cross_crate { return }\n \n         match *stab {\n-            Some(Stability { level: attr::Unstable, ref feature, ref reason, .. }) => {\n+            Some(&Stability { level: attr::Unstable, ref feature, ref reason, .. }) => {\n                 self.used_features.insert(feature.clone(), attr::Unstable);\n \n                 if !self.active_features.contains(feature) {\n@@ -252,7 +255,7 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n                                       &feature, span, &msg);\n                 }\n             }\n-            Some(Stability { level, ref feature, .. }) => {\n+            Some(&Stability { level, ref feature, .. }) => {\n                 self.used_features.insert(feature.clone(), level);\n \n                 // Stable APIs are always ok to call and deprecated APIs are\n@@ -312,7 +315,7 @@ impl<'a, 'v, 'tcx> Visitor<'v> for Checker<'a, 'tcx> {\n \n /// Helper for discovering nodes to check for stability\n pub fn check_item(tcx: &ty::ctxt, item: &ast::Item, warn_about_defns: bool,\n-                  cb: &mut FnMut(ast::DefId, Span, &Option<Stability>)) {\n+                  cb: &mut FnMut(ast::DefId, Span, &Option<&Stability>)) {\n     match item.node {\n         ast::ItemExternCrate(_) => {\n             // compiler-generated `extern crate` items have a dummy span.\n@@ -349,7 +352,7 @@ pub fn check_item(tcx: &ty::ctxt, item: &ast::Item, warn_about_defns: bool,\n \n /// Helper for discovering nodes to check for stability\n pub fn check_expr(tcx: &ty::ctxt, e: &ast::Expr,\n-                  cb: &mut FnMut(ast::DefId, Span, &Option<Stability>)) {\n+                  cb: &mut FnMut(ast::DefId, Span, &Option<&Stability>)) {\n     let span;\n     let id = match e.node {\n         ast::ExprMethodCall(i, _, _) => {\n@@ -458,7 +461,7 @@ pub fn check_expr(tcx: &ty::ctxt, e: &ast::Expr,\n }\n \n pub fn check_path(tcx: &ty::ctxt, path: &ast::Path, id: ast::NodeId,\n-                  cb: &mut FnMut(ast::DefId, Span, &Option<Stability>)) {\n+                  cb: &mut FnMut(ast::DefId, Span, &Option<&Stability>)) {\n     match tcx.def_map.borrow().get(&id).map(|d| d.full_def()) {\n         Some(def::DefPrimTy(..)) => {}\n         Some(def) => {\n@@ -470,7 +473,7 @@ pub fn check_path(tcx: &ty::ctxt, path: &ast::Path, id: ast::NodeId,\n }\n \n pub fn check_pat(tcx: &ty::ctxt, pat: &ast::Pat,\n-                 cb: &mut FnMut(ast::DefId, Span, &Option<Stability>)) {\n+                 cb: &mut FnMut(ast::DefId, Span, &Option<&Stability>)) {\n     debug!(\"check_pat(pat = {:?})\", pat);\n     if is_internal(tcx, pat.span) { return; }\n \n@@ -511,7 +514,7 @@ pub fn check_pat(tcx: &ty::ctxt, pat: &ast::Pat,\n }\n \n fn maybe_do_stability_check(tcx: &ty::ctxt, id: ast::DefId, span: Span,\n-                            cb: &mut FnMut(ast::DefId, Span, &Option<Stability>)) {\n+                            cb: &mut FnMut(ast::DefId, Span, &Option<&Stability>)) {\n     if !is_staged_api(tcx, id) { return  }\n     if is_internal(tcx, span) { return }\n     let ref stability = lookup(tcx, id);\n@@ -528,20 +531,27 @@ fn is_staged_api(tcx: &ty::ctxt, id: DefId) -> bool {\n             if trait_method_id != id => {\n                 is_staged_api(tcx, trait_method_id)\n             }\n-        _ if is_local(id) => {\n-            tcx.stability.borrow().staged_api\n-        }\n         _ => {\n-            csearch::is_staged_api(&tcx.sess.cstore, id)\n+            *tcx.stability.borrow_mut().staged_api.entry(id.krate).or_insert_with(\n+                || csearch::is_staged_api(&tcx.sess.cstore, id.krate))\n         }\n     }\n }\n \n /// Lookup the stability for a node, loading external crate\n /// metadata as necessary.\n-pub fn lookup(tcx: &ty::ctxt, id: DefId) -> Option<Stability> {\n-    debug!(\"lookup(id={})\",\n-           id.repr(tcx));\n+pub fn lookup<'tcx>(tcx: &ty::ctxt<'tcx>, id: DefId) -> Option<&'tcx Stability> {\n+    if let Some(st) = tcx.stability.borrow().map.get(&id) {\n+        return *st;\n+    }\n+\n+    let st = lookup_uncached(tcx, id);\n+    tcx.stability.borrow_mut().map.insert(id, st);\n+    st\n+}\n+\n+fn lookup_uncached<'tcx>(tcx: &ty::ctxt<'tcx>, id: DefId) -> Option<&'tcx Stability> {\n+    debug!(\"lookup(id={})\", id.repr(tcx));\n \n     // is this definition the implementation of a trait method?\n     match ty::trait_item_of_item(tcx, id) {\n@@ -553,25 +563,23 @@ pub fn lookup(tcx: &ty::ctxt, id: DefId) -> Option<Stability> {\n     }\n \n     let item_stab = if is_local(id) {\n-        tcx.stability.borrow().local.get(&id.node).cloned()\n+        None // The stability cache is filled partially lazily\n     } else {\n-        let stab = csearch::get_stability(&tcx.sess.cstore, id);\n-        let mut index = tcx.stability.borrow_mut();\n-        (*index).extern_cache.insert(id, stab.clone());\n-        stab\n+        csearch::get_stability(&tcx.sess.cstore, id).map(|st| tcx.intern_stability(st))\n     };\n \n     item_stab.or_else(|| {\n-        if let Some(trait_id) = ty::trait_id_of_impl(tcx, id) {\n-            // FIXME (#18969): for the time being, simply use the\n-            // stability of the trait to determine the stability of any\n-            // unmarked impls for it. See FIXME above for more details.\n-\n-            debug!(\"lookup: trait_id={:?}\", trait_id);\n-            lookup(tcx, trait_id)\n-        } else {\n-            None\n+        if ty::is_impl(tcx, id) {\n+            if let Some(trait_id) = ty::trait_id_of_impl(tcx, id) {\n+                // FIXME (#18969): for the time being, simply use the\n+                // stability of the trait to determine the stability of any\n+                // unmarked impls for it. See FIXME above for more details.\n+\n+                debug!(\"lookup: trait_id={:?}\", trait_id);\n+                return lookup(tcx, trait_id);\n+            }\n         }\n+        None\n     })\n }\n "}, {"sha": "2ccbb0c5c103e98bcad2b9e83ee2c7a34c70270d", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 62, "deletions": 183, "changes": 245, "blob_url": "https://github.com/rust-lang/rust/blob/c654a07d29c77b5a023cb9d36dfc61811349f64e/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c654a07d29c77b5a023cb9d36dfc61811349f64e/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=c654a07d29c77b5a023cb9d36dfc61811349f64e", "patch": "@@ -32,7 +32,6 @@ pub use self::ImplOrTraitItem::*;\n pub use self::BoundRegion::*;\n pub use self::sty::*;\n pub use self::IntVarValue::*;\n-pub use self::vtable_origin::*;\n pub use self::MethodOrigin::*;\n pub use self::CopyImplementationError::*;\n \n@@ -402,12 +401,6 @@ pub enum CustomCoerceUnsized {\n     Struct(usize)\n }\n \n-#[derive(Clone, Copy, RustcEncodable, RustcDecodable, PartialEq, PartialOrd, Debug)]\n-pub struct param_index {\n-    pub space: subst::ParamSpace,\n-    pub index: usize\n-}\n-\n #[derive(Clone, Debug)]\n pub enum MethodOrigin<'tcx> {\n     // fully statically resolved method\n@@ -510,50 +503,6 @@ impl MethodCall {\n // of the method to be invoked\n pub type MethodMap<'tcx> = RefCell<FnvHashMap<MethodCall, MethodCallee<'tcx>>>;\n \n-pub type vtable_param_res<'tcx> = Vec<vtable_origin<'tcx>>;\n-\n-// Resolutions for bounds of all parameters, left to right, for a given path.\n-pub type vtable_res<'tcx> = VecPerParamSpace<vtable_param_res<'tcx>>;\n-\n-#[derive(Clone)]\n-pub enum vtable_origin<'tcx> {\n-    /*\n-      Statically known vtable. def_id gives the impl item\n-      from whence comes the vtable, and tys are the type substs.\n-      vtable_res is the vtable itself.\n-     */\n-    vtable_static(ast::DefId, subst::Substs<'tcx>, vtable_res<'tcx>),\n-\n-    /*\n-      Dynamic vtable, comes from a parameter that has a bound on it:\n-      fn foo<T:quux,baz,bar>(a: T) -- a's vtable would have a\n-      vtable_param origin\n-\n-      The first argument is the param index (identifying T in the example),\n-      and the second is the bound number (identifying baz)\n-     */\n-    vtable_param(param_index, usize),\n-\n-    /*\n-      Vtable automatically generated for a closure. The def ID is the\n-      ID of the closure expression.\n-     */\n-    vtable_closure(ast::DefId),\n-\n-    /*\n-      Asked to determine the vtable for ty_err. This is the value used\n-      for the vtables of `Self` in a virtual call like `foo.bar()`\n-      where `foo` is of object type. The same value is also used when\n-      type errors occur.\n-     */\n-    vtable_error,\n-}\n-\n-\n-// For every explicit cast into an object type, maps from the cast\n-// expr to the associated trait ref.\n-pub type ObjectCastMap<'tcx> = RefCell<NodeMap<ty::PolyTraitRef<'tcx>>>;\n-\n // Contains information needed to resolve types and (in the future) look up\n // the types of AST nodes.\n #[derive(Copy, Clone, PartialEq, Eq, Hash)]\n@@ -601,9 +550,10 @@ pub struct CtxtArenas<'tcx> {\n     substs: TypedArena<Substs<'tcx>>,\n     bare_fn: TypedArena<BareFnTy<'tcx>>,\n     region: TypedArena<Region>,\n+    stability: TypedArena<attr::Stability>,\n \n     // references\n-    trait_defs: TypedArena<TraitDef<'tcx>>\n+    trait_defs: TypedArena<TraitDef<'tcx>>,\n }\n \n impl<'tcx> CtxtArenas<'tcx> {\n@@ -613,6 +563,7 @@ impl<'tcx> CtxtArenas<'tcx> {\n             substs: TypedArena::new(),\n             bare_fn: TypedArena::new(),\n             region: TypedArena::new(),\n+            stability: TypedArena::new(),\n \n             trait_defs: TypedArena::new()\n         }\n@@ -654,6 +605,7 @@ pub struct ctxt<'tcx> {\n     substs_interner: RefCell<FnvHashMap<&'tcx Substs<'tcx>, &'tcx Substs<'tcx>>>,\n     bare_fn_interner: RefCell<FnvHashMap<&'tcx BareFnTy<'tcx>, &'tcx BareFnTy<'tcx>>>,\n     region_interner: RefCell<FnvHashMap<&'tcx Region, &'tcx Region>>,\n+    stability_interner: RefCell<FnvHashMap<&'tcx attr::Stability, &'tcx attr::Stability>>,\n \n     /// Common types, pre-interned for your convenience.\n     pub types: CommonTypes<'tcx>,\n@@ -692,9 +644,7 @@ pub struct ctxt<'tcx> {\n     /// A cache for the trait_items() routine\n     pub trait_items_cache: RefCell<DefIdMap<Rc<Vec<ImplOrTraitItem<'tcx>>>>>,\n \n-    pub impl_trait_cache: RefCell<DefIdMap<Option<TraitRef<'tcx>>>>,\n-\n-    pub impl_trait_refs: RefCell<NodeMap<TraitRef<'tcx>>>,\n+    pub impl_trait_refs: RefCell<DefIdMap<Option<TraitRef<'tcx>>>>,\n     pub trait_defs: RefCell<DefIdMap<&'tcx TraitDef<'tcx>>>,\n \n     /// Maps from the def-id of an item (trait/struct/enum/fn) to its\n@@ -709,15 +659,10 @@ pub struct ctxt<'tcx> {\n     /// additional acyclicity requirements).\n     pub super_predicates: RefCell<DefIdMap<GenericPredicates<'tcx>>>,\n \n-    /// Maps from node-id of a trait object cast (like `foo as\n-    /// Box<Trait>`) to the trait reference.\n-    pub object_cast_map: ObjectCastMap<'tcx>,\n-\n     pub map: ast_map::Map<'tcx>,\n     pub freevars: RefCell<FreevarMap>,\n     pub tcache: RefCell<DefIdMap<TypeScheme<'tcx>>>,\n     pub rcache: RefCell<FnvHashMap<creader_cache_key, Ty<'tcx>>>,\n-    pub short_names_cache: RefCell<FnvHashMap<Ty<'tcx>, String>>,\n     pub tc_cache: RefCell<FnvHashMap<Ty<'tcx>, TypeContents>>,\n     pub ast_ty_to_ty_cache: RefCell<NodeMap<Ty<'tcx>>>,\n     pub enum_var_cache: RefCell<DefIdMap<Rc<Vec<Rc<VariantInfo<'tcx>>>>>>,\n@@ -801,10 +746,7 @@ pub struct ctxt<'tcx> {\n     pub transmute_restrictions: RefCell<Vec<TransmuteRestriction<'tcx>>>,\n \n     /// Maps any item's def-id to its stability index.\n-    pub stability: RefCell<stability::Index>,\n-\n-    /// Maps def IDs to true if and only if they're associated types.\n-    pub associated_types: RefCell<DefIdMap<bool>>,\n+    pub stability: RefCell<stability::Index<'tcx>>,\n \n     /// Caches the results of trait selection. This cache is used\n     /// for things that do not have to do with the parameters in scope.\n@@ -847,6 +789,16 @@ impl<'tcx> ctxt<'tcx> {\n         interned\n     }\n \n+    pub fn intern_stability(&self, stab: attr::Stability) -> &'tcx attr::Stability {\n+        if let Some(st) = self.stability_interner.borrow().get(&stab) {\n+            return st;\n+        }\n+\n+        let interned = self.arenas.stability.alloc(stab);\n+        self.stability_interner.borrow_mut().insert(interned, interned);\n+        interned\n+    }\n+\n     pub fn store_free_region_map(&self, id: NodeId, map: FreeRegionMap) {\n         self.free_region_maps.borrow_mut()\n                              .insert(id, map);\n@@ -948,6 +900,7 @@ impl<'tcx> ctxt<'tcx> {\n         println!(\"Substs interner: #{}\", self.substs_interner.borrow().len());\n         println!(\"BareFnTy interner: #{}\", self.bare_fn_interner.borrow().len());\n         println!(\"Region interner: #{}\", self.region_interner.borrow().len());\n+        println!(\"Stability interner: #{}\", self.stability_interner.borrow().len());\n     }\n }\n \n@@ -2753,7 +2706,7 @@ pub fn mk_ctxt<'tcx>(s: Session,\n                      freevars: RefCell<FreevarMap>,\n                      region_maps: RegionMaps,\n                      lang_items: middle::lang_items::LanguageItems,\n-                     stability: stability::Index) -> ctxt<'tcx>\n+                     stability: stability::Index<'tcx>) -> ctxt<'tcx>\n {\n     let mut interner = FnvHashMap();\n     let common_types = CommonTypes::new(&arenas.type_, &mut interner);\n@@ -2764,6 +2717,7 @@ pub fn mk_ctxt<'tcx>(s: Session,\n         substs_interner: RefCell::new(FnvHashMap()),\n         bare_fn_interner: RefCell::new(FnvHashMap()),\n         region_interner: RefCell::new(FnvHashMap()),\n+        stability_interner: RefCell::new(FnvHashMap()),\n         types: common_types,\n         named_region_map: named_region_map,\n         region_maps: region_maps,\n@@ -2774,23 +2728,20 @@ pub fn mk_ctxt<'tcx>(s: Session,\n         def_map: def_map,\n         node_types: RefCell::new(FnvHashMap()),\n         item_substs: RefCell::new(NodeMap()),\n-        impl_trait_refs: RefCell::new(NodeMap()),\n+        impl_trait_refs: RefCell::new(DefIdMap()),\n         trait_defs: RefCell::new(DefIdMap()),\n         predicates: RefCell::new(DefIdMap()),\n         super_predicates: RefCell::new(DefIdMap()),\n-        object_cast_map: RefCell::new(NodeMap()),\n         map: map,\n         freevars: freevars,\n         tcache: RefCell::new(DefIdMap()),\n         rcache: RefCell::new(FnvHashMap()),\n-        short_names_cache: RefCell::new(FnvHashMap()),\n         tc_cache: RefCell::new(FnvHashMap()),\n         ast_ty_to_ty_cache: RefCell::new(NodeMap()),\n         enum_var_cache: RefCell::new(DefIdMap()),\n         impl_or_trait_items: RefCell::new(DefIdMap()),\n         trait_item_def_ids: RefCell::new(DefIdMap()),\n         trait_items_cache: RefCell::new(DefIdMap()),\n-        impl_trait_cache: RefCell::new(DefIdMap()),\n         ty_param_defs: RefCell::new(NodeMap()),\n         adjustments: RefCell::new(NodeMap()),\n         normalized_cache: RefCell::new(FnvHashMap()),\n@@ -2816,7 +2767,6 @@ pub fn mk_ctxt<'tcx>(s: Session,\n         node_lint_levels: RefCell::new(FnvHashMap()),\n         transmute_restrictions: RefCell::new(Vec::new()),\n         stability: RefCell::new(stability),\n-        associated_types: RefCell::new(DefIdMap()),\n         selection_cache: traits::SelectionCache::new(),\n         repr_hint_cache: RefCell::new(DefIdMap()),\n         type_impls_copy_cache: RefCell::new(HashMap::new()),\n@@ -4305,17 +4255,9 @@ pub fn is_type_representable<'tcx>(cx: &ctxt<'tcx>, sp: Span, ty: Ty<'tcx>)\n }\n \n pub fn type_is_trait(ty: Ty) -> bool {\n-    type_trait_info(ty).is_some()\n-}\n-\n-pub fn type_trait_info<'tcx>(ty: Ty<'tcx>) -> Option<&'tcx TyTrait<'tcx>> {\n     match ty.sty {\n-        ty_uniq(ty) | ty_rptr(_, mt { ty, ..}) | ty_ptr(mt { ty, ..}) => match ty.sty {\n-            ty_trait(ref t) => Some(&**t),\n-            _ => None\n-        },\n-        ty_trait(ref t) => Some(&**t),\n-        _ => None\n+        ty_trait(..) => true,\n+        _ => false\n     }\n }\n \n@@ -4506,16 +4448,6 @@ pub fn named_element_ty<'tcx>(cx: &ctxt<'tcx>,\n     }\n }\n \n-pub fn impl_id_to_trait_ref<'tcx>(cx: &ctxt<'tcx>, id: ast::NodeId)\n-                                  -> ty::TraitRef<'tcx> {\n-    match cx.impl_trait_refs.borrow().get(&id) {\n-        Some(ty) => *ty,\n-        None => cx.sess.bug(\n-            &format!(\"impl_id_to_trait_ref: no trait ref for impl `{}`\",\n-                    cx.map.node_to_string(id)))\n-    }\n-}\n-\n pub fn node_id_to_type<'tcx>(cx: &ctxt<'tcx>, id: ast::NodeId) -> Ty<'tcx> {\n     match node_id_to_type_opt(cx, id) {\n        Some(ty) => ty,\n@@ -5310,12 +5242,12 @@ pub fn associated_consts<'tcx>(cx: &ctxt<'tcx>, id: ast::DefId)\n /// the future).\n fn lookup_locally_or_in_crate_store<V, F>(descr: &str,\n                                           def_id: ast::DefId,\n-                                          map: &mut DefIdMap<V>,\n+                                          map: &RefCell<DefIdMap<V>>,\n                                           load_external: F) -> V where\n     V: Clone,\n     F: FnOnce() -> V,\n {\n-    match map.get(&def_id).cloned() {\n+    match map.borrow().get(&def_id).cloned() {\n         Some(v) => { return v; }\n         None => { }\n     }\n@@ -5324,7 +5256,7 @@ fn lookup_locally_or_in_crate_store<V, F>(descr: &str,\n         panic!(\"No def'n found for {:?} in tcx.{}\", def_id, descr);\n     }\n     let v = load_external();\n-    map.insert(def_id, v.clone());\n+    map.borrow_mut().insert(def_id, v.clone());\n     v\n }\n \n@@ -5390,33 +5322,9 @@ pub fn custom_coerce_unsized_kind<'tcx>(cx: &ctxt<'tcx>, did: ast::DefId)\n \n pub fn impl_or_trait_item<'tcx>(cx: &ctxt<'tcx>, id: ast::DefId)\n                                 -> ImplOrTraitItem<'tcx> {\n-    lookup_locally_or_in_crate_store(\"impl_or_trait_items\",\n-                                     id,\n-                                     &mut *cx.impl_or_trait_items\n-                                             .borrow_mut(),\n-                                     || {\n-        csearch::get_impl_or_trait_item(cx, id)\n-    })\n-}\n-\n-/// Returns true if the given ID refers to an associated type and false if it\n-/// refers to anything else.\n-pub fn is_associated_type(cx: &ctxt, id: ast::DefId) -> bool {\n-    memoized(&cx.associated_types, id, |id: ast::DefId| {\n-        if id.krate == ast::LOCAL_CRATE {\n-            match cx.impl_or_trait_items.borrow().get(&id) {\n-                Some(ref item) => {\n-                    match **item {\n-                        TypeTraitItem(_) => true,\n-                        _ => false,\n-                    }\n-                }\n-                None => false,\n-            }\n-        } else {\n-            csearch::is_associated_type(&cx.sess.cstore, id)\n-        }\n-    })\n+    lookup_locally_or_in_crate_store(\n+        \"impl_or_trait_items\", id, &cx.impl_or_trait_items,\n+        || csearch::get_impl_or_trait_item(cx, id))\n }\n \n /// Returns the parameter index that the given associated type corresponds to.\n@@ -5434,34 +5342,33 @@ pub fn associated_type_parameter_index(cx: &ctxt,\n \n pub fn trait_item_def_ids(cx: &ctxt, id: ast::DefId)\n                           -> Rc<Vec<ImplOrTraitItemId>> {\n-    lookup_locally_or_in_crate_store(\"trait_item_def_ids\",\n-                                     id,\n-                                     &mut *cx.trait_item_def_ids.borrow_mut(),\n-                                     || {\n-        Rc::new(csearch::get_trait_item_def_ids(&cx.sess.cstore, id))\n-    })\n+    lookup_locally_or_in_crate_store(\n+        \"trait_item_def_ids\", id, &cx.trait_item_def_ids,\n+        || Rc::new(csearch::get_trait_item_def_ids(&cx.sess.cstore, id)))\n }\n \n+/// Returns the trait-ref corresponding to a given impl, or None if it is\n+/// an inherent impl.\n pub fn impl_trait_ref<'tcx>(cx: &ctxt<'tcx>, id: ast::DefId)\n-                            -> Option<TraitRef<'tcx>> {\n-    memoized(&cx.impl_trait_cache, id, |id: ast::DefId| {\n-        if id.krate == ast::LOCAL_CRATE {\n-            debug!(\"(impl_trait_ref) searching for trait impl {:?}\", id);\n-            if let Some(ast_map::NodeItem(item)) = cx.map.find(id.node) {\n-                match item.node {\n-                    ast::ItemImpl(_, _, _, Some(_), _, _) |\n-                    ast::ItemDefaultImpl(..) => {\n-                        Some(ty::impl_id_to_trait_ref(cx, id.node))\n-                    }\n-                    _ => None\n-                }\n-            } else {\n-                None\n-            }\n+                            -> Option<TraitRef<'tcx>>\n+{\n+    lookup_locally_or_in_crate_store(\n+        \"impl_trait_refs\", id, &cx.impl_trait_refs,\n+        || csearch::get_impl_trait(cx, id))\n+}\n+\n+/// Returns whether this DefId refers to an impl\n+pub fn is_impl<'tcx>(cx: &ctxt<'tcx>, id: ast::DefId) -> bool {\n+    if id.krate == ast::LOCAL_CRATE {\n+        if let Some(ast_map::NodeItem(\n+            &ast::Item { node: ast::ItemImpl(..), .. })) = cx.map.find(id.node) {\n+            true\n         } else {\n-            csearch::get_impl_trait(cx, id)\n+            false\n         }\n-    })\n+    } else {\n+        csearch::is_impl(&cx.sess.cstore, id)\n+    }\n }\n \n pub fn trait_ref_to_def_id(tcx: &ctxt, tr: &ast::TraitRef) -> ast::DefId {\n@@ -5944,37 +5851,35 @@ pub fn lookup_item_type<'tcx>(cx: &ctxt<'tcx>,\n                               did: ast::DefId)\n                               -> TypeScheme<'tcx> {\n     lookup_locally_or_in_crate_store(\n-        \"tcache\", did, &mut *cx.tcache.borrow_mut(),\n+        \"tcache\", did, &cx.tcache,\n         || csearch::get_type(cx, did))\n }\n \n /// Given the did of a trait, returns its canonical trait ref.\n pub fn lookup_trait_def<'tcx>(cx: &ctxt<'tcx>, did: ast::DefId)\n                               -> &'tcx TraitDef<'tcx> {\n-    memoized(&cx.trait_defs, did, |did: DefId| {\n-        assert!(did.krate != ast::LOCAL_CRATE);\n-        cx.arenas.trait_defs.alloc(csearch::get_trait_def(cx, did))\n-    })\n+    lookup_locally_or_in_crate_store(\n+        \"trait_defs\", did, &cx.trait_defs,\n+        || cx.arenas.trait_defs.alloc(csearch::get_trait_def(cx, did))\n+    )\n }\n \n /// Given the did of an item, returns its full set of predicates.\n pub fn lookup_predicates<'tcx>(cx: &ctxt<'tcx>, did: ast::DefId)\n                                 -> GenericPredicates<'tcx>\n {\n-    memoized(&cx.predicates, did, |did: DefId| {\n-        assert!(did.krate != ast::LOCAL_CRATE);\n-        csearch::get_predicates(cx, did)\n-    })\n+    lookup_locally_or_in_crate_store(\n+        \"predicates\", did, &cx.predicates,\n+        || csearch::get_predicates(cx, did))\n }\n \n /// Given the did of a trait, returns its superpredicates.\n pub fn lookup_super_predicates<'tcx>(cx: &ctxt<'tcx>, did: ast::DefId)\n                                      -> GenericPredicates<'tcx>\n {\n-    memoized(&cx.super_predicates, did, |did: DefId| {\n-        assert!(did.krate != ast::LOCAL_CRATE);\n-        csearch::get_super_predicates(cx, did)\n-    })\n+    lookup_locally_or_in_crate_store(\n+        \"super_predicates\", did, &cx.super_predicates,\n+        || csearch::get_super_predicates(cx, did))\n }\n \n pub fn predicates<'tcx>(\n@@ -6344,7 +6249,7 @@ pub fn required_region_bounds<'tcx>(tcx: &ctxt<'tcx>,\n \n pub fn item_variances(tcx: &ctxt, item_id: ast::DefId) -> Rc<ItemVariances> {\n     lookup_locally_or_in_crate_store(\n-        \"item_variance_map\", item_id, &mut *tcx.item_variance_map.borrow_mut(),\n+        \"item_variance_map\", item_id, &tcx.item_variance_map,\n         || Rc::new(csearch::get_item_variances(&tcx.sess.cstore, item_id)))\n }\n \n@@ -7223,32 +7128,6 @@ impl<'tcx> Repr<'tcx> for ty::Predicate<'tcx> {\n     }\n }\n \n-impl<'tcx> Repr<'tcx> for vtable_origin<'tcx> {\n-    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n-        match *self {\n-            vtable_static(def_id, ref tys, ref vtable_res) => {\n-                format!(\"vtable_static({:?}:{}, {}, {})\",\n-                        def_id,\n-                        ty::item_path_str(tcx, def_id),\n-                        tys.repr(tcx),\n-                        vtable_res.repr(tcx))\n-            }\n-\n-            vtable_param(x, y) => {\n-                format!(\"vtable_param({:?}, {})\", x, y)\n-            }\n-\n-            vtable_closure(def_id) => {\n-                format!(\"vtable_closure({:?})\", def_id)\n-            }\n-\n-            vtable_error => {\n-                format!(\"vtable_error\")\n-            }\n-        }\n-    }\n-}\n-\n pub fn make_substs_for_receiver_types<'tcx>(tcx: &ty::ctxt<'tcx>,\n                                             trait_ref: &ty::TraitRef<'tcx>,\n                                             method: &ty::Method<'tcx>)"}, {"sha": "6f098a53238b68ee2d7a122145564b68550910bf", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c654a07d29c77b5a023cb9d36dfc61811349f64e/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c654a07d29c77b5a023cb9d36dfc61811349f64e/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=c654a07d29c77b5a023cb9d36dfc61811349f64e", "patch": "@@ -336,27 +336,6 @@ impl<'tcx> TypeFoldable<'tcx> for ty::MethodOrigin<'tcx> {\n     }\n }\n \n-impl<'tcx> TypeFoldable<'tcx> for ty::vtable_origin<'tcx> {\n-    fn fold_with<F: TypeFolder<'tcx>>(&self, folder: &mut F) -> ty::vtable_origin<'tcx> {\n-        match *self {\n-            ty::vtable_static(def_id, ref substs, ref origins) => {\n-                let r_substs = substs.fold_with(folder);\n-                let r_origins = origins.fold_with(folder);\n-                ty::vtable_static(def_id, r_substs, r_origins)\n-            }\n-            ty::vtable_param(n, b) => {\n-                ty::vtable_param(n, b)\n-            }\n-            ty::vtable_closure(def_id) => {\n-                ty::vtable_closure(def_id)\n-            }\n-            ty::vtable_error => {\n-                ty::vtable_error\n-            }\n-        }\n-    }\n-}\n-\n impl<'tcx> TypeFoldable<'tcx> for ty::BuiltinBounds {\n     fn fold_with<F: TypeFolder<'tcx>>(&self, _folder: &mut F) -> ty::BuiltinBounds {\n         *self"}, {"sha": "13dec30e0a0162e22797365670fdfc45214ae739", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c654a07d29c77b5a023cb9d36dfc61811349f64e/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c654a07d29c77b5a023cb9d36dfc61811349f64e/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=c654a07d29c77b5a023cb9d36dfc61811349f64e", "patch": "@@ -653,7 +653,7 @@ pub fn phase_3_run_analysis_passes<'tcx>(sess: Session,\n \n     // Do not move this check past lint\n     time(time_passes, \"stability index\", (), |_|\n-         ty_cx.stability.borrow_mut().build(&ty_cx.sess, krate, &public_items));\n+         ty_cx.stability.borrow_mut().build(&ty_cx, krate, &public_items));\n \n     time(time_passes, \"intrinsic checking\", (), |_|\n          middle::intrinsicck::check_crate(&ty_cx));"}, {"sha": "4678b5335eab7347cbbe3eb70c1133ddfb64e800", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/c654a07d29c77b5a023cb9d36dfc61811349f64e/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c654a07d29c77b5a023cb9d36dfc61811349f64e/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=c654a07d29c77b5a023cb9d36dfc61811349f64e", "patch": "@@ -1798,20 +1798,21 @@ declare_lint! {\n pub struct Stability;\n \n impl Stability {\n-    fn lint(&self, cx: &Context, _id: ast::DefId, span: Span, stability: &Option<attr::Stability>) {\n+    fn lint(&self, cx: &Context, _id: ast::DefId,\n+            span: Span, stability: &Option<&attr::Stability>) {\n         // Deprecated attributes apply in-crate and cross-crate.\n         let (lint, label) = match *stability {\n-            Some(attr::Stability { deprecated_since: Some(_), .. }) =>\n+            Some(&attr::Stability { deprecated_since: Some(_), .. }) =>\n                 (DEPRECATED, \"deprecated\"),\n             _ => return\n         };\n \n         output(cx, span, stability, lint, label);\n \n-        fn output(cx: &Context, span: Span, stability: &Option<attr::Stability>,\n+        fn output(cx: &Context, span: Span, stability: &Option<&attr::Stability>,\n                   lint: &'static Lint, label: &'static str) {\n             let msg = match *stability {\n-                Some(attr::Stability { reason: Some(ref s), .. }) => {\n+                Some(&attr::Stability { reason: Some(ref s), .. }) => {\n                     format!(\"use of {} item: {}\", label, *s)\n                 }\n                 _ => format!(\"use of {} item\", label)"}, {"sha": "eb6e90414e3fda3f34a5031c1f3051fabbdc697e", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c654a07d29c77b5a023cb9d36dfc61811349f64e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c654a07d29c77b5a023cb9d36dfc61811349f64e/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=c654a07d29c77b5a023cb9d36dfc61811349f64e", "patch": "@@ -98,7 +98,7 @@ use middle::ty::{FnSig, GenericPredicates, TypeScheme};\n use middle::ty::{Disr, ParamTy, ParameterEnvironment};\n use middle::ty::{self, HasProjectionTypes, RegionEscape, ToPolyTraitRef, Ty};\n use middle::ty::liberate_late_bound_regions;\n-use middle::ty::{MethodCall, MethodCallee, MethodMap, ObjectCastMap};\n+use middle::ty::{MethodCall, MethodCallee, MethodMap};\n use middle::ty_fold::{TypeFolder, TypeFoldable};\n use rscope::RegionScope;\n use session::Session;\n@@ -164,7 +164,6 @@ pub struct Inherited<'a, 'tcx: 'a> {\n     upvar_capture_map: RefCell<ty::UpvarCaptureMap>,\n     closure_tys: RefCell<DefIdMap<ty::ClosureTy<'tcx>>>,\n     closure_kinds: RefCell<DefIdMap<ty::ClosureKind>>,\n-    object_cast_map: ObjectCastMap<'tcx>,\n \n     // A mapping from each fn's id to its signature, with all bound\n     // regions replaced with free ones. Unlike the other tables, this\n@@ -383,7 +382,6 @@ impl<'a, 'tcx> Inherited<'a, 'tcx> {\n             item_substs: RefCell::new(NodeMap()),\n             adjustments: RefCell::new(NodeMap()),\n             method_map: RefCell::new(FnvHashMap()),\n-            object_cast_map: RefCell::new(NodeMap()),\n             upvar_capture_map: RefCell::new(FnvHashMap()),\n             closure_tys: RefCell::new(DefIdMap()),\n             closure_kinds: RefCell::new(DefIdMap()),"}, {"sha": "8ec406ff41b92b4f5a3ed7f62f111cbc6de93c5f", "filename": "src/librustc_typeck/check/wf.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c654a07d29c77b5a023cb9d36dfc61811349f64e/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c654a07d29c77b5a023cb9d36dfc61811349f64e/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwf.rs?ref=c654a07d29c77b5a023cb9d36dfc61811349f64e", "patch": "@@ -81,7 +81,8 @@ impl<'ccx, 'tcx> CheckTypeWellFormedVisitor<'ccx, 'tcx> {\n                 self.check_impl(item);\n             }\n             ast::ItemImpl(_, ast::ImplPolarity::Negative, _, Some(_), _, _) => {\n-                let trait_ref = ty::impl_id_to_trait_ref(ccx.tcx, item.id);\n+                let trait_ref = ty::impl_trait_ref(ccx.tcx,\n+                                                   local_def(item.id)).unwrap();\n                 ty::populate_implementations_for_trait_if_necessary(ccx.tcx, trait_ref.def_id);\n                 match ccx.tcx.lang_items.to_builtin_kind(trait_ref.def_id) {\n                     Some(ty::BoundSend) | Some(ty::BoundSync) => {}"}, {"sha": "7eba4c0375f9a76770ea556d0e2e1fb972cbd4f9", "filename": "src/librustc_typeck/check/writeback.rs", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/c654a07d29c77b5a023cb9d36dfc61811349f64e/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c654a07d29c77b5a023cb9d36dfc61811349f64e/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fwriteback.rs?ref=c654a07d29c77b5a023cb9d36dfc61811349f64e", "patch": "@@ -41,7 +41,6 @@ pub fn resolve_type_vars_in_expr(fcx: &FnCtxt, e: &ast::Expr) {\n     wbcx.visit_expr(e);\n     wbcx.visit_upvar_borrow_map();\n     wbcx.visit_closures();\n-    wbcx.visit_object_cast_map();\n }\n \n pub fn resolve_type_vars_in_fn(fcx: &FnCtxt,\n@@ -62,7 +61,6 @@ pub fn resolve_type_vars_in_fn(fcx: &FnCtxt,\n     }\n     wbcx.visit_upvar_borrow_map();\n     wbcx.visit_closures();\n-    wbcx.visit_object_cast_map();\n }\n \n ///////////////////////////////////////////////////////////////////////////\n@@ -239,27 +237,6 @@ impl<'cx, 'tcx> WritebackCx<'cx, 'tcx> {\n         }\n     }\n \n-    fn visit_object_cast_map(&self) {\n-        if self.fcx.writeback_errors.get() {\n-            return\n-        }\n-\n-        for (&node_id, trait_ref) in self.fcx\n-                                            .inh\n-                                            .object_cast_map\n-                                            .borrow()\n-                                            .iter()\n-        {\n-            let span = ty::expr_span(self.tcx(), node_id);\n-            let reason = ResolvingExpr(span);\n-            let closure_ty = self.resolve(trait_ref, reason);\n-            self.tcx()\n-                .object_cast_map\n-                .borrow_mut()\n-                .insert(node_id, closure_ty);\n-        }\n-    }\n-\n     fn visit_node_id(&self, reason: ResolveReason, id: ast::NodeId) {\n         // Resolve any borrowings for the node with id `id`\n         self.visit_adjustments(reason, id);"}, {"sha": "212423d16d43b3bf2a1d5f8ddb1257d0a7c4021e", "filename": "src/librustc_typeck/coherence/mod.rs", "status": "modified", "additions": 20, "deletions": 33, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/c654a07d29c77b5a023cb9d36dfc61811349f64e/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c654a07d29c77b5a023cb9d36dfc61811349f64e/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Fmod.rs?ref=c654a07d29c77b5a023cb9d36dfc61811349f64e", "patch": "@@ -36,7 +36,7 @@ use std::cell::RefCell;\n use std::rc::Rc;\n use syntax::ast::{Crate, DefId};\n use syntax::ast::{Item, ItemImpl};\n-use syntax::ast::{LOCAL_CRATE, TraitRef};\n+use syntax::ast::{LOCAL_CRATE};\n use syntax::ast;\n use syntax::ast_map::NodeItem;\n use syntax::ast_map;\n@@ -100,11 +100,8 @@ struct CoherenceCheckVisitor<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx, 'v> visit::Visitor<'v> for CoherenceCheckVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &Item) {\n-\n-        //debug!(\"(checking coherence) item '{}'\", token::get_ident(item.ident));\n-\n-        if let ItemImpl(_, _, _, ref opt_trait, _, _) = item.node {\n-            self.cc.check_implementation(item, opt_trait.as_ref())\n+        if let ItemImpl(..) = item.node {\n+            self.cc.check_implementation(item)\n         }\n \n         visit::walk_item(self, item);\n@@ -141,7 +138,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n         self.check_implementations_of_coerce_unsized();\n     }\n \n-    fn check_implementation(&self, item: &Item, opt_trait: Option<&TraitRef>) {\n+    fn check_implementation(&self, item: &Item) {\n         let tcx = self.crate_context.tcx;\n         let impl_did = local_def(item.id);\n         let self_type = ty::lookup_item_type(tcx, impl_did);\n@@ -151,8 +148,8 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n \n         let impl_items = self.create_impl_from_item(item);\n \n-        if opt_trait.is_some() {\n-            let trait_ref = ty::impl_id_to_trait_ref(self.crate_context.tcx, item.id);\n+        if let Some(trait_ref) = ty::impl_trait_ref(self.crate_context.tcx,\n+                                                    impl_did) {\n             debug!(\"(checking implementation) adding impl for trait '{}', item '{}'\",\n                    trait_ref.repr(self.crate_context.tcx),\n                    token::get_ident(item.ident));\n@@ -161,22 +158,13 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                                                  item.span,\n                                                  trait_ref.def_id);\n             self.add_trait_impl(trait_ref, impl_did);\n-        }\n-\n-        // Add the implementation to the mapping from implementation to base\n-        // type def ID, if there is a base type for this implementation and\n-        // the implementation does not have any associated traits.\n-        match get_base_type_def_id(&self.inference_context,\n-                                   item.span,\n-                                   self_type.ty) {\n-            None => {\n-                // Nothing to do.\n-            }\n-            Some(base_type_def_id) => {\n-                // FIXME: Gather up default methods?\n-                if opt_trait.is_none() {\n-                    self.add_inherent_impl(base_type_def_id, impl_did);\n-                }\n+        } else {\n+            // Add the implementation to the mapping from implementation to base\n+            // type def ID, if there is a base type for this implementation and\n+            // the implementation does not have any associated traits.\n+            if let Some(base_type_def_id) = get_base_type_def_id(\n+                    &self.inference_context, item.span, self_type.ty) {\n+                self.add_inherent_impl(base_type_def_id, impl_did);\n             }\n         }\n \n@@ -267,7 +255,7 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n     // Converts an implementation in the AST to a vector of items.\n     fn create_impl_from_item(&self, item: &Item) -> Vec<ImplOrTraitItemId> {\n         match item.node {\n-            ItemImpl(_, _, _, ref opt_trait, _, ref impl_items) => {\n+            ItemImpl(_, _, _, _, _, ref impl_items) => {\n                 let mut items: Vec<ImplOrTraitItemId> =\n                         impl_items.iter().map(|impl_item| {\n                     match impl_item.node {\n@@ -287,10 +275,8 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n                     }\n                 }).collect();\n \n-                if opt_trait.is_some() {\n-                    let trait_ref = ty::impl_id_to_trait_ref(self.crate_context.tcx,\n-                                                             item.id);\n-\n+                if let Some(trait_ref) = ty::impl_trait_ref(self.crate_context.tcx,\n+                                                            local_def(item.id)) {\n                     self.instantiate_default_methods(local_def(item.id),\n                                                      &trait_ref,\n                                                      &mut items);\n@@ -300,7 +286,8 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             }\n             _ => {\n                 self.crate_context.tcx.sess.span_bug(item.span,\n-                                                     \"can't convert a non-impl to an impl\");\n+                                                     \"can't convert a non-impl \\\n+                                                      to an impl\");\n             }\n         }\n     }\n@@ -453,8 +440,8 @@ impl<'a, 'tcx> CoherenceChecker<'a, 'tcx> {\n             }\n \n             let source = ty::lookup_item_type(tcx, impl_did).ty;\n-            let trait_ref = ty::impl_id_to_trait_ref(self.crate_context.tcx,\n-                                                     impl_did.node);\n+            let trait_ref = ty::impl_trait_ref(self.crate_context.tcx,\n+                                               impl_did).unwrap();\n             let target = *trait_ref.substs.types.get(subst::TypeSpace, 0);\n             debug!(\"check_implementations_of_coerce_unsized: {} -> {} (bound)\",\n                    source.repr(tcx), target.repr(tcx));"}, {"sha": "2fba967b3b237780a43665900393a73a090c7ffe", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c654a07d29c77b5a023cb9d36dfc61811349f64e/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c654a07d29c77b5a023cb9d36dfc61811349f64e/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=c654a07d29c77b5a023cb9d36dfc61811349f64e", "patch": "@@ -820,15 +820,14 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n \n             ty::record_trait_has_default_impl(tcx, trait_ref.def_id);\n \n-            tcx.impl_trait_refs.borrow_mut().insert(it.id, trait_ref);\n+            tcx.impl_trait_refs.borrow_mut().insert(local_def(it.id), Some(trait_ref));\n         }\n         ast::ItemImpl(_, _,\n                       ref generics,\n                       ref opt_trait_ref,\n                       ref selfty,\n                       ref impl_items) => {\n             // Create generics from the generics specified in the impl head.\n-\n             debug!(\"convert: ast_generics={:?}\", generics);\n             let ty_generics = ty_generics_for_type_or_impl(ccx, generics);\n             let ty_predicates = ty_generic_predicates_for_type_or_impl(ccx, generics);\n@@ -926,14 +925,16 @@ fn convert_item(ccx: &CrateCtxt, it: &ast::Item) {\n                 }\n             }\n \n-            if let Some(ref ast_trait_ref) = *opt_trait_ref {\n-                let trait_ref =\n-                    astconv::instantiate_mono_trait_ref(&ccx.icx(&ty_predicates),\n-                                                        &ExplicitRscope,\n-                                                        ast_trait_ref,\n-                                                        Some(selfty));\n-\n-                tcx.impl_trait_refs.borrow_mut().insert(it.id, trait_ref);\n+            if let &Some(ref ast_trait_ref) = opt_trait_ref {\n+                tcx.impl_trait_refs.borrow_mut().insert(\n+                    local_def(it.id),\n+                    Some(astconv::instantiate_mono_trait_ref(&ccx.icx(&ty_predicates),\n+                                                             &ExplicitRscope,\n+                                                             ast_trait_ref,\n+                                                             Some(selfty)))\n+                        );\n+            } else {\n+                tcx.impl_trait_refs.borrow_mut().insert(local_def(it.id), None);\n             }\n \n             enforce_impl_params_are_constrained(tcx,"}, {"sha": "95444bb915872d6ccd0cabe7116c22187d093317", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/c654a07d29c77b5a023cb9d36dfc61811349f64e/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c654a07d29c77b5a023cb9d36dfc61811349f64e/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=c654a07d29c77b5a023cb9d36dfc61811349f64e", "patch": "@@ -2695,6 +2695,21 @@ impl Clean<Stability> for attr::Stability {\n     }\n }\n \n+impl<'a> Clean<Stability> for &'a attr::Stability {\n+    fn clean(&self, _: &DocContext) -> Stability {\n+        Stability {\n+            level: self.level,\n+            feature: self.feature.to_string(),\n+            since: self.since.as_ref().map_or(\"\".to_string(),\n+                                              |interned| interned.to_string()),\n+            deprecated_since: self.deprecated_since.as_ref().map_or(\"\".to_string(),\n+                                                                    |istr| istr.to_string()),\n+            reason: self.reason.as_ref().map_or(\"\".to_string(),\n+                                                |interned| interned.to_string()),\n+        }\n+    }\n+}\n+\n impl<'tcx> Clean<Item> for ty::AssociatedConst<'tcx> {\n     fn clean(&self, cx: &DocContext) -> Item {\n         Item {"}, {"sha": "e0a462dd43795c96f6108256492de754d95b25bd", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c654a07d29c77b5a023cb9d36dfc61811349f64e/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c654a07d29c77b5a023cb9d36dfc61811349f64e/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=c654a07d29c77b5a023cb9d36dfc61811349f64e", "patch": "@@ -61,7 +61,8 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n     }\n \n     fn stability(&self, id: ast::NodeId) -> Option<attr::Stability> {\n-        self.cx.tcx_opt().and_then(|tcx| stability::lookup(tcx, ast_util::local_def(id)))\n+        self.cx.tcx_opt().and_then(\n+            |tcx| stability::lookup(tcx, ast_util::local_def(id)).map(|x| x.clone()))\n     }\n \n     pub fn visit(&mut self, krate: &ast::Crate) {"}, {"sha": "3c4c4d70343c38484b0e406f6bc55c571dad2101", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c654a07d29c77b5a023cb9d36dfc61811349f64e/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c654a07d29c77b5a023cb9d36dfc61811349f64e/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=c654a07d29c77b5a023cb9d36dfc61811349f64e", "patch": "@@ -366,7 +366,7 @@ pub fn cfg_matches(diagnostic: &SpanHandler, cfgs: &[P<MetaItem>], cfg: &ast::Me\n }\n \n /// Represents the #[deprecated] and friends attributes.\n-#[derive(RustcEncodable,RustcDecodable,Clone,Debug)]\n+#[derive(RustcEncodable, RustcDecodable, Clone, Debug, PartialEq, Eq, Hash)]\n pub struct Stability {\n     pub level: StabilityLevel,\n     pub feature: InternedString,\n@@ -378,7 +378,7 @@ pub struct Stability {\n }\n \n /// The available stability levels.\n-#[derive(RustcEncodable,RustcDecodable,PartialEq,PartialOrd,Clone,Debug,Copy)]\n+#[derive(RustcEncodable, RustcDecodable, PartialEq, PartialOrd, Clone, Debug, Copy, Eq, Hash)]\n pub enum StabilityLevel {\n     Unstable,\n     Stable,"}]}