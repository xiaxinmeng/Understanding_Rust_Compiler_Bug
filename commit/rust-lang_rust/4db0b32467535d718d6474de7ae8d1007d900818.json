{"sha": "4db0b32467535d718d6474de7ae8d1007d900818", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRkYjBiMzI0Njc1MzVkNzE4ZDY0NzRkZTdhZThkMTAwN2Q5MDA4MTg=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-02-25T20:32:58Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-02-25T20:32:58Z"}, "message": "Auto merge of #22796 - Manishearth:rollup, r=Manishearth", "tree": {"sha": "85c3f0131e2347eb2c0b2931a6c41284a52aaa1b", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/85c3f0131e2347eb2c0b2931a6c41284a52aaa1b"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4db0b32467535d718d6474de7ae8d1007d900818", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4db0b32467535d718d6474de7ae8d1007d900818", "html_url": "https://github.com/rust-lang/rust/commit/4db0b32467535d718d6474de7ae8d1007d900818", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4db0b32467535d718d6474de7ae8d1007d900818/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "880fb89bde126aa43fc348d0b93839d3d18a1f51", "url": "https://api.github.com/repos/rust-lang/rust/commits/880fb89bde126aa43fc348d0b93839d3d18a1f51", "html_url": "https://github.com/rust-lang/rust/commit/880fb89bde126aa43fc348d0b93839d3d18a1f51"}, {"sha": "357b41bfcfcfd902d842a20f2c5858b8e196495d", "url": "https://api.github.com/repos/rust-lang/rust/commits/357b41bfcfcfd902d842a20f2c5858b8e196495d", "html_url": "https://github.com/rust-lang/rust/commit/357b41bfcfcfd902d842a20f2c5858b8e196495d"}], "stats": {"total": 2791, "additions": 1698, "deletions": 1093}, "files": [{"sha": "f6b0a18824a0253327356b9eeb169b2a1e7f3bf2", "filename": "src/doc/index.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Fdoc%2Findex.md", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Fdoc%2Findex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Findex.md?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -68,7 +68,7 @@ There are questions that are asked quite often, and so we've made FAQs for them:\n * [Language Design FAQ](complement-design-faq.html)\n * [Language FAQ](complement-lang-faq.html)\n * [Project FAQ](complement-project-faq.html)\n-* [How to submit a bug report](complement-bugreport.html)\n+* [How to submit a bug report](https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.md#bug-reports)\n \n # The standard library\n "}, {"sha": "781b40be768c86f03b05ce809ce1a9c7aead5145", "filename": "src/doc/reference.md", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -731,15 +731,20 @@ Rust syntax is restricted in two ways:\n    pairs when they occur at the beginning of, or immediately after, a `$(...)*`;\n    requiring a distinctive token in front can solve the problem.\n \n-## Syntax extensions useful for the macro author\n+## Syntax extensions useful in macros\n \n-* `log_syntax!` : print out the arguments at compile time\n-* `trace_macros!` : supply `true` or `false` to enable or disable macro expansion logging\n * `stringify!` : turn the identifier argument into a string literal\n * `concat!` : concatenates a comma-separated list of literals\n-* `concat_idents!` : create a new identifier by concatenating the arguments\n \n-The following attributes are used for quasiquoting in procedural macros:\n+## Syntax extensions for macro debugging\n+\n+* `log_syntax!` : print out the arguments at compile time\n+* `trace_macros!` : supply `true` or `false` to enable or disable macro expansion logging\n+\n+## Quasiquoting\n+\n+The following syntax extensions are used for quasiquoting Rust syntax trees,\n+usually in [procedural macros](book/plugins.html#syntax-extensions):\n \n * `quote_expr!`\n * `quote_item!`\n@@ -748,6 +753,8 @@ The following attributes are used for quasiquoting in procedural macros:\n * `quote_tokens!`\n * `quote_ty!`\n \n+Documentation is very limited at the moment.\n+\n # Crates and source files\n \n Rust is a *compiled* language. Its semantics obey a *phase distinction*"}, {"sha": "a226e4d0bf911ac97b57c420129c3ff515bb53aa", "filename": "src/doc/trpl/advanced-macros.md", "status": "modified", "additions": 48, "deletions": 9, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Fdoc%2Ftrpl%2Fadvanced-macros.md", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Fdoc%2Ftrpl%2Fadvanced-macros.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fadvanced-macros.md?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -192,19 +192,58 @@ To keep this system simple and correct, `#[macro_use] extern crate ...` may\n only appear at the root of your crate, not inside `mod`. This ensures that\n `$crate` is a single identifier.\n \n-# A final note\n+# The deep end\n \n-Macros, as currently implemented, are not for the faint of heart. Even\n-ordinary syntax errors can be more difficult to debug when they occur inside a\n-macro, and errors caused by parse problems in generated code can be very\n-tricky. Invoking the `log_syntax!` macro can help elucidate intermediate\n-states, invoking `trace_macros!(true)` will automatically print those\n-intermediate states out, and passing the flag `--pretty expanded` as a\n-command-line argument to the compiler will show the result of expansion.\n+The introductory chapter mentioned recursive macros, but it did not give the\n+full story. Recursive macros are useful for another reason: Each recursive\n+invocation gives you another opportunity to pattern-match the macro's\n+arguments.\n+\n+As an extreme example, it is possible, though hardly advisable, to implement\n+the [Bitwise Cyclic Tag](http://esolangs.org/wiki/Bitwise_Cyclic_Tag) automaton\n+within Rust's macro system.\n+\n+```rust\n+#![feature(trace_macros)]\n+\n+macro_rules! bct {\n+    // cmd 0:  d ... => ...\n+    (0, $($ps:tt),* ; $_d:tt)\n+        => (bct!($($ps),*, 0 ; ));\n+    (0, $($ps:tt),* ; $_d:tt, $($ds:tt),*)\n+        => (bct!($($ps),*, 0 ; $($ds),*));\n+\n+    // cmd 1p:  1 ... => 1 ... p\n+    (1, $p:tt, $($ps:tt),* ; 1)\n+        => (bct!($($ps),*, 1, $p ; 1, $p));\n+    (1, $p:tt, $($ps:tt),* ; 1, $($ds:tt),*)\n+        => (bct!($($ps),*, 1, $p ; 1, $($ds),*, $p));\n+\n+    // cmd 1p:  0 ... => 0 ...\n+    (1, $p:tt, $($ps:tt),* ; $($ds:tt),*)\n+        => (bct!($($ps),*, 1, $p ; $($ds),*));\n+\n+    // halt on empty data string\n+    ( $($ps:tt),* ; )\n+        => (());\n+}\n+\n+fn main() {\n+    trace_macros!(true);\n+# /* just check the definition\n+    bct!(0, 0, 1, 1, 1 ; 1, 0, 1);\n+# */\n+}\n+```\n+\n+Exercise: use macros to reduce duplication in the above definition of the\n+`bct!` macro.\n+\n+# Procedural macros\n \n If Rust's macro system can't do what you need, you may want to write a\n [compiler plugin](plugins.html) instead. Compared to `macro_rules!`\n macros, this is significantly more work, the interfaces are much less stable,\n-and the warnings about debugging apply ten-fold. In exchange you get the\n+and bugs can be much harder to track down. In exchange you get the\n flexibility of running arbitrary Rust code within the compiler. Syntax\n extension plugins are sometimes called *procedural macros* for this reason."}, {"sha": "cf60bd88c542be85ff5f6c90d20c5cd599a9827d", "filename": "src/doc/trpl/error-handling.md", "status": "modified", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Fdoc%2Ftrpl%2Ferror-handling.md", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Fdoc%2Ftrpl%2Ferror-handling.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ferror-handling.md?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -223,6 +223,78 @@ let input = io::stdin().read_line()\n                        .ok()\n                        .expect(\"Failed to read line\");\n ```\n+\n `ok()` converts the `IoResult` into an `Option`, and `expect()` does the same\n thing as `unwrap()`, but takes a message. This message is passed along to the\n underlying `panic!`, providing a better error message if the code errors.\n+\n+# Using `try!`\n+\n+When writing code that calls many functions that return the `Result` type, the\n+error handling can be tedious. The `try!` macro hides some of the boilerplate\n+of propagating errors up the call stack.\n+\n+It replaces this:\n+\n+```rust\n+use std::fs::File;\n+use std::io;\n+use std::io::prelude::*;\n+\n+struct Info {\n+    name: String,\n+    age: i32,\n+    rating: i32,\n+}\n+\n+fn write_info(info: &Info) -> io::Result<()> {\n+    let mut file = File::open(\"my_best_friends.txt\").unwrap();\n+\n+    if let Err(e) = writeln!(&mut file, \"name: {}\", info.name) {\n+        return Err(e)\n+    }\n+    if let Err(e) = writeln!(&mut file, \"age: {}\", info.age) {\n+        return Err(e)\n+    }\n+    if let Err(e) = writeln!(&mut file, \"rating: {}\", info.rating) {\n+        return Err(e)\n+    }\n+\n+    return Ok(());\n+}\n+```\n+\n+With this:\n+\n+```rust\n+use std::fs::File;\n+use std::io;\n+use std::io::prelude::*;\n+\n+struct Info {\n+    name: String,\n+    age: i32,\n+    rating: i32,\n+}\n+\n+fn write_info(info: &Info) -> io::Result<()> {\n+    let mut file = try!(File::open(\"my_best_friends.txt\"));\n+\n+    try!(writeln!(&mut file, \"name: {}\", info.name));\n+    try!(writeln!(&mut file, \"age: {}\", info.age));\n+    try!(writeln!(&mut file, \"rating: {}\", info.rating));\n+\n+    return Ok(());\n+}\n+```\n+\n+Wrapping an expression in `try!` will result in the unwrapped success (`Ok`)\n+value, unless the result is `Err`, in which case `Err` is returned early from\n+the enclosing function.\n+\n+It's worth noting that you can only use `try!` from a function that returns a\n+`Result`, which means that you cannot use `try!` inside of `main()`, because\n+`main()` doesn't return anything.\n+\n+`try!` makes use of [`FromError`](../std/error/#the-fromerror-trait) to determine\n+what to return in the error case."}, {"sha": "7da36043f6cf17726a3641bab0381564aeb1ada1", "filename": "src/doc/trpl/macros.md", "status": "modified", "additions": 78, "deletions": 11, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Fdoc%2Ftrpl%2Fmacros.md", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Fdoc%2Ftrpl%2Fmacros.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fmacros.md?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -73,7 +73,7 @@ macro_rules! vec {\n     };\n }\n # fn main() {\n-#     assert_eq!(&[1,2,3], &vec![1,2,3]);\n+#     assert_eq!([1,2,3], vec![1,2,3]);\n # }\n ```\n \n@@ -189,14 +189,12 @@ shorthand for a data type could be valid as either an expression or a pattern.\n \n ## Repetition\n \n-The repetition behavior can seem somewhat magical, especially when multiple\n-names are bound at multiple nested levels of repetition. The two rules to keep\n-in mind are:\n+The repetition operator follows two principal rules:\n \n-1. the behavior of `$(...)*` is to walk through one \"layer\" of repetitions, for\n-all of the `$name`s it contains, in lockstep, and\n+1. `$(...)*` walks through one \"layer\" of repetitions, for all of the `$name`s\n+   it contains, in lockstep, and\n 2. each `$name` must be under at least as many `$(...)*`s as it was matched\n-against. If it is under more, it'll be duplicated, as appropriate.\n+   against. If it is under more, it'll be duplicated, as appropriate.\n \n This baroque macro illustrates the duplication of variables from outer\n repetition levels.\n@@ -226,6 +224,10 @@ That's most of the matcher syntax. These examples use `$(...)*`, which is a\n more\" match. Both forms optionally include a separator, which can be any token\n except `+` or `*`.\n \n+This system is based on\n+\"[Macro-by-Example](http://www.cs.indiana.edu/ftp/techreports/TR206.pdf)\"\n+(PDF link).\n+\n # Hygiene\n \n Some languages implement macros using simple text substitution, which leads to\n@@ -273,19 +275,26 @@ macro, using [a GNU C extension] to emulate Rust's expression blocks.\n })\n ```\n \n-This looks reasonable, but watch what happens in this example:\n+Here's a simple use case that goes terribly wrong:\n \n ```text\n const char *state = \"reticulating splines\";\n-LOG(state);\n+LOG(state)\n ```\n \n-The program will likely segfault, after it tries to execute\n+This expands to\n \n ```text\n-printf(\"log(%d): %s\\n\", state, state);\n+const char *state = \"reticulating splines\";\n+int state = get_log_state();\n+if (state > 0) {\n+    printf(\"log(%d): %s\\n\", state, state);\n+}\n ```\n \n+The second variable named `state` shadows the first one.  This is a problem\n+because the print statement should refer to both of them.\n+\n The equivalent Rust macro has the desired behavior.\n \n ```rust\n@@ -357,6 +366,64 @@ fn main() {\n \n [items]: ../reference.html#items\n \n+# Recursive macros\n+\n+A macro's expansion can include more macro invocations, including invocations\n+of the very same macro being expanded.  These recursive macros are useful for\n+processing tree-structured input, as illustrated by this (simplistic) HTML\n+shorthand:\n+\n+```rust\n+# #![allow(unused_must_use)]\n+macro_rules! write_html {\n+    ($w:expr, ) => (());\n+\n+    ($w:expr, $e:tt) => (write!($w, \"{}\", $e));\n+\n+    ($w:expr, $tag:ident [ $($inner:tt)* ] $($rest:tt)*) => {{\n+        write!($w, \"<{}>\", stringify!($tag));\n+        write_html!($w, $($inner)*);\n+        write!($w, \"</{}>\", stringify!($tag));\n+        write_html!($w, $($rest)*);\n+    }};\n+}\n+\n+fn main() {\n+#   // FIXME(#21826)\n+    use std::fmt::Write;\n+    let mut out = String::new();\n+\n+    write_html!(&mut out,\n+        html[\n+            head[title[\"Macros guide\"]]\n+            body[h1[\"Macros are the best!\"]]\n+        ]);\n+\n+    assert_eq!(out,\n+        \"<html><head><title>Macros guide</title></head>\\\n+         <body><h1>Macros are the best!</h1></body></html>\");\n+}\n+```\n+\n+# Debugging macro code\n+\n+To see the results of expanding macros, run `rustc --pretty expanded`. The\n+output represents a whole crate, so you can also feed it back in to `rustc`,\n+which will sometimes produce better error messages than the original\n+compilation. Note that the `--pretty expanded` output may have a different\n+meaning if multiple variables of the same name (but different syntax contexts)\n+are in play in the same scope. In this case `--pretty expanded,hygiene` will\n+tell you about the syntax contexts.\n+\n+`rustc` provides two syntax extensions that help with macro debugging. For now,\n+they are unstable and require feature gates.\n+\n+* `log_syntax!(...)` will print its arguments to standard output, at compile\n+  time, and \"expand\" to nothing.\n+\n+* `trace_macros!(true)` will enable a compiler message every time a macro is\n+  expanded. Use `trace_macros!(false)` later in expansion to turn it off.\n+\n # Further reading\n \n The [advanced macros chapter][] goes into more detail about macro syntax. It"}, {"sha": "f609a0a918aa7628a6dc05372da67c168dd7335f", "filename": "src/doc/trpl/plugins.md", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Fdoc%2Ftrpl%2Fplugins.md", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Fdoc%2Ftrpl%2Fplugins.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Fplugins.md?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -146,14 +146,7 @@ a more involved macro example, see\n \n ## Tips and tricks\n \n-To see the results of expanding syntax extensions, run\n-`rustc --pretty expanded`. The output represents a whole crate, so you\n-can also feed it back in to `rustc`, which will sometimes produce better\n-error messages than the original compilation. Note that the\n-`--pretty expanded` output may have a different meaning if multiple\n-variables of the same name (but different syntax contexts) are in play\n-in the same scope. In this case `--pretty expanded,hygiene` will tell\n-you about the syntax contexts.\n+Some of the [macro debugging tips](macros.html#debugging-macro-code) are applicable.\n \n You can use [`syntax::parse`](../syntax/parse/index.html) to turn token trees into\n higher-level syntax elements like expressions:\n@@ -184,6 +177,11 @@ and return\n [`DummyResult`](../syntax/ext/base/struct.DummyResult.html),\n so that the compiler can continue and find further errors.\n \n+To print syntax fragments for debugging, you can use\n+[`span_note`](../syntax/ext/base/struct.ExtCtxt.html#method.span_note) together\n+with\n+[`syntax::print::pprust::*_to_string`](http://doc.rust-lang.org/syntax/print/pprust/index.html#functions).\n+\n The example above produced an integer literal using\n [`AstBuilder::expr_uint`](../syntax/ext/build/trait.AstBuilder.html#tymethod.expr_uint).\n As an alternative to the `AstBuilder` trait, `libsyntax` provides a set of"}, {"sha": "82bd13475c74eabb6f106112edd5434c7411cc70", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -73,6 +73,7 @@\n #![feature(unboxed_closures)]\n #![feature(unsafe_no_drop_flag)]\n #![feature(core)]\n+#![feature(unique)]\n #![cfg_attr(test, feature(test, alloc, rustc_private))]\n #![cfg_attr(all(not(feature = \"external_funcs\"), not(feature = \"external_crate\")),\n             feature(libc))]"}, {"sha": "36c76dbad14aefcb20076f4d9c63613aa80fe221", "filename": "src/libcollections/binary_heap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbinary_heap.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -480,7 +480,7 @@ impl<T: Ord> BinaryHeap<T> {\n     /// heap.push(3);\n     ///\n     /// let vec = heap.into_sorted_vec();\n-    /// assert_eq!(vec, vec![1, 2, 3, 4, 5, 6, 7]);\n+    /// assert_eq!(vec, [1, 2, 3, 4, 5, 6, 7]);\n     /// ```\n     pub fn into_sorted_vec(mut self) -> Vec<T> {\n         let mut end = self.len();"}, {"sha": "5b19de42ac919240167e67892b48ba519dd55b63", "filename": "src/libcollections/bit.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibcollections%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibcollections%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbit.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -640,13 +640,13 @@ impl BitVec {\n     /// let mut bv = BitVec::from_elem(3, true);\n     /// bv.set(1, false);\n     ///\n-    /// assert_eq!(bv.to_bytes(), vec!(0b10100000));\n+    /// assert_eq!(bv.to_bytes(), [0b10100000]);\n     ///\n     /// let mut bv = BitVec::from_elem(9, false);\n     /// bv.set(2, true);\n     /// bv.set(8, true);\n     ///\n-    /// assert_eq!(bv.to_bytes(), vec!(0b00100000, 0b10000000));\n+    /// assert_eq!(bv.to_bytes(), [0b00100000, 0b10000000]);\n     /// ```\n     pub fn to_bytes(&self) -> Vec<u8> {\n         fn bit(bit_vec: &BitVec, byte: usize, bit: usize) -> u8 {\n@@ -806,7 +806,7 @@ impl BitVec {\n     /// let mut bv = BitVec::from_bytes(&[0b01001011]);\n     /// bv.grow(2, true);\n     /// assert_eq!(bv.len(), 10);\n-    /// assert_eq!(bv.to_bytes(), vec!(0b01001011, 0b11000000));\n+    /// assert_eq!(bv.to_bytes(), [0b01001011, 0b11000000]);\n     /// ```\n     pub fn grow(&mut self, n: usize, value: bool) {\n         // Note: we just bulk set all the bits in the last word in this fn in multiple places\n@@ -978,7 +978,7 @@ impl Ord for BitVec {\n impl fmt::Debug for BitVec {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n         for bit in self {\n-            try!(write!(fmt, \"{}\", if bit { 1u32 } else { 0u32 }));\n+            try!(write!(fmt, \"{}\", if bit { 1 } else { 0 }));\n         }\n         Ok(())\n     }\n@@ -1752,7 +1752,7 @@ impl BitSet {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Debug for BitSet {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(fmt, \"BitSet {{\"));\n+        try!(write!(fmt, \"{{\"));\n         let mut first = true;\n         for n in self {\n             if !first {\n@@ -2285,12 +2285,12 @@ mod tests {\n     fn test_to_bytes() {\n         let mut bv = BitVec::from_elem(3, true);\n         bv.set(1, false);\n-        assert_eq!(bv.to_bytes(), vec!(0b10100000));\n+        assert_eq!(bv.to_bytes(), [0b10100000]);\n \n         let mut bv = BitVec::from_elem(9, false);\n         bv.set(2, true);\n         bv.set(8, true);\n-        assert_eq!(bv.to_bytes(), vec!(0b00100000, 0b10000000));\n+        assert_eq!(bv.to_bytes(), [0b00100000, 0b10000000]);\n     }\n \n     #[test]\n@@ -2655,7 +2655,7 @@ mod bit_set_test {\n         s.insert(10);\n         s.insert(50);\n         s.insert(2);\n-        assert_eq!(\"BitSet {1, 2, 10, 50}\", format!(\"{:?}\", s));\n+        assert_eq!(\"{1, 2, 10, 50}\", format!(\"{:?}\", s));\n     }\n \n     #[test]\n@@ -2675,7 +2675,7 @@ mod bit_set_test {\n         let bit_vec: BitSet = usizes.into_iter().collect();\n \n         let idxs: Vec<_> = bit_vec.iter().collect();\n-        assert_eq!(idxs, vec![0, 2, 3]);\n+        assert_eq!(idxs, [0, 2, 3]);\n \n         let long: BitSet = (0..10000).filter(|&n| n % 2 == 0).collect();\n         let real: Vec<_> = range_step(0, 10000, 2).collect();"}, {"sha": "8a3a1fcb9f387a8bc060a4f29eb0983a2ae9372c", "filename": "src/libcollections/btree/map.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fmap.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -347,7 +347,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n             let result = stack.with(move |pusher, node| {\n                 // Same basic logic as found in `find`, but with PartialSearchStack mediating the\n                 // actual nodes for us\n-                return match Node::search(node, &key) {\n+                match Node::search(node, &key) {\n                     Found(mut handle) => {\n                         // Perfect match, swap the values and return the old one\n                         mem::swap(handle.val_mut(), &mut value);\n@@ -372,7 +372,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n                 }\n             });\n             match result {\n-                Finished(ret) => { return ret; },\n+                Finished(ret) => return ret,\n                 Continue((new_stack, renewed_key, renewed_val)) => {\n                     stack = new_stack;\n                     key = renewed_key;\n@@ -439,7 +439,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         let mut stack = stack::PartialSearchStack::new(self);\n         loop {\n             let result = stack.with(move |pusher, node| {\n-                return match Node::search(node, key) {\n+                match Node::search(node, key) {\n                     Found(handle) => {\n                         // Perfect match. Terminate the stack here, and remove the entry\n                         Finished(Some(pusher.seal(handle).remove()))\n@@ -899,7 +899,7 @@ impl<K: Ord, V: Ord> Ord for BTreeMap<K, V> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<K: Debug, V: Debug> Debug for BTreeMap<K, V> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(f, \"BTreeMap {{\"));\n+        try!(write!(f, \"{{\"));\n \n         for (i, (k, v)) in self.iter().enumerate() {\n             if i != 0 { try!(write!(f, \", \")); }\n@@ -1281,7 +1281,7 @@ impl<K, V> BTreeMap<K, V> {\n     /// a.insert(2, \"b\");\n     ///\n     /// let keys: Vec<usize> = a.keys().cloned().collect();\n-    /// assert_eq!(keys, vec![1,2,]);\n+    /// assert_eq!(keys, [1, 2]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn keys<'a>(&'a self) -> Keys<'a, K, V> {\n@@ -1303,7 +1303,7 @@ impl<K, V> BTreeMap<K, V> {\n     /// a.insert(2, \"b\");\n     ///\n     /// let values: Vec<&str> = a.values().cloned().collect();\n-    /// assert_eq!(values, vec![\"a\",\"b\"]);\n+    /// assert_eq!(values, [\"a\", \"b\"]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn values<'a>(&'a self) -> Values<'a, K, V> {\n@@ -1560,7 +1560,7 @@ impl<K: Ord, V> BTreeMap<K, V> {\n         let mut stack = stack::PartialSearchStack::new(self);\n         loop {\n             let result = stack.with(move |pusher, node| {\n-                return match Node::search(node, &key) {\n+                match Node::search(node, &key) {\n                     Found(handle) => {\n                         // Perfect match\n                         Finished(Occupied(OccupiedEntry {"}, {"sha": "b8703f6e7d9350fe6186ae73d40199939789863f", "filename": "src/libcollections/btree/node.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fnode.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -1136,12 +1136,12 @@ impl<K, V> Node<K, V> {\n     // This must be followed by insert_edge on an internal node.\n     #[inline]\n     unsafe fn insert_kv(&mut self, index: usize, key: K, val: V) -> &mut V {\n-        ptr::copy_memory(\n+        ptr::copy(\n             self.keys_mut().as_mut_ptr().offset(index as isize + 1),\n             self.keys().as_ptr().offset(index as isize),\n             self.len() - index\n         );\n-        ptr::copy_memory(\n+        ptr::copy(\n             self.vals_mut().as_mut_ptr().offset(index as isize + 1),\n             self.vals().as_ptr().offset(index as isize),\n             self.len() - index\n@@ -1158,7 +1158,7 @@ impl<K, V> Node<K, V> {\n     // This can only be called immediately after a call to insert_kv.\n     #[inline]\n     unsafe fn insert_edge(&mut self, index: usize, edge: Node<K, V>) {\n-        ptr::copy_memory(\n+        ptr::copy(\n             self.edges_mut().as_mut_ptr().offset(index as isize + 1),\n             self.edges().as_ptr().offset(index as isize),\n             self.len() - index\n@@ -1191,12 +1191,12 @@ impl<K, V> Node<K, V> {\n         let key = ptr::read(self.keys().get_unchecked(index));\n         let val = ptr::read(self.vals().get_unchecked(index));\n \n-        ptr::copy_memory(\n+        ptr::copy(\n             self.keys_mut().as_mut_ptr().offset(index as isize),\n             self.keys().as_ptr().offset(index as isize + 1),\n             self.len() - index - 1\n         );\n-        ptr::copy_memory(\n+        ptr::copy(\n             self.vals_mut().as_mut_ptr().offset(index as isize),\n             self.vals().as_ptr().offset(index as isize + 1),\n             self.len() - index - 1\n@@ -1212,7 +1212,7 @@ impl<K, V> Node<K, V> {\n     unsafe fn remove_edge(&mut self, index: usize) -> Node<K, V> {\n         let edge = ptr::read(self.edges().get_unchecked(index));\n \n-        ptr::copy_memory(\n+        ptr::copy(\n             self.edges_mut().as_mut_ptr().offset(index as isize),\n             self.edges().as_ptr().offset(index as isize + 1),\n             self.len() - index + 1\n@@ -1239,18 +1239,18 @@ impl<K, V> Node<K, V> {\n         unsafe {\n             right._len = self.len() / 2;\n             let right_offset = self.len() - right.len();\n-            ptr::copy_nonoverlapping_memory(\n+            ptr::copy_nonoverlapping(\n                 right.keys_mut().as_mut_ptr(),\n                 self.keys().as_ptr().offset(right_offset as isize),\n                 right.len()\n             );\n-            ptr::copy_nonoverlapping_memory(\n+            ptr::copy_nonoverlapping(\n                 right.vals_mut().as_mut_ptr(),\n                 self.vals().as_ptr().offset(right_offset as isize),\n                 right.len()\n             );\n             if !self.is_leaf() {\n-                ptr::copy_nonoverlapping_memory(\n+                ptr::copy_nonoverlapping(\n                     right.edges_mut().as_mut_ptr(),\n                     self.edges().as_ptr().offset(right_offset as isize),\n                     right.len() + 1\n@@ -1280,18 +1280,18 @@ impl<K, V> Node<K, V> {\n             ptr::write(self.keys_mut().get_unchecked_mut(old_len), key);\n             ptr::write(self.vals_mut().get_unchecked_mut(old_len), val);\n \n-            ptr::copy_nonoverlapping_memory(\n+            ptr::copy_nonoverlapping(\n                 self.keys_mut().as_mut_ptr().offset(old_len as isize + 1),\n                 right.keys().as_ptr(),\n                 right.len()\n             );\n-            ptr::copy_nonoverlapping_memory(\n+            ptr::copy_nonoverlapping(\n                 self.vals_mut().as_mut_ptr().offset(old_len as isize + 1),\n                 right.vals().as_ptr(),\n                 right.len()\n             );\n             if !self.is_leaf() {\n-                ptr::copy_nonoverlapping_memory(\n+                ptr::copy_nonoverlapping(\n                     self.edges_mut().as_mut_ptr().offset(old_len as isize + 1),\n                     right.edges().as_ptr(),\n                     right.len() + 1"}, {"sha": "bc2e68b999a55e29ce02c218e60d3e7003e28da3", "filename": "src/libcollections/btree/set.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fbtree%2Fset.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -121,7 +121,7 @@ impl<T> BTreeSet<T> {\n     /// }\n     ///\n     /// let v: Vec<usize> = set.iter().cloned().collect();\n-    /// assert_eq!(v, vec![1,2,3,4]);\n+    /// assert_eq!(v, [1, 2, 3, 4]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn iter(&self) -> Iter<T> {\n@@ -138,7 +138,7 @@ impl<T> BTreeSet<T> {\n     /// let set: BTreeSet<usize> = [1, 2, 3, 4].iter().cloned().collect();\n     ///\n     /// let v: Vec<usize> = set.into_iter().collect();\n-    /// assert_eq!(v, vec![1,2,3,4]);\n+    /// assert_eq!(v, [1, 2, 3, 4]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_iter(self) -> IntoIter<T> {\n@@ -197,7 +197,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// b.insert(3);\n     ///\n     /// let diff: Vec<usize> = a.difference(&b).cloned().collect();\n-    /// assert_eq!(diff, vec![1]);\n+    /// assert_eq!(diff, [1]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn difference<'a>(&'a self, other: &'a BTreeSet<T>) -> Difference<'a, T> {\n@@ -220,7 +220,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// b.insert(3);\n     ///\n     /// let sym_diff: Vec<usize> = a.symmetric_difference(&b).cloned().collect();\n-    /// assert_eq!(sym_diff, vec![1,3]);\n+    /// assert_eq!(sym_diff, [1, 3]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn symmetric_difference<'a>(&'a self, other: &'a BTreeSet<T>)\n@@ -244,7 +244,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// b.insert(3);\n     ///\n     /// let intersection: Vec<usize> = a.intersection(&b).cloned().collect();\n-    /// assert_eq!(intersection, vec![2]);\n+    /// assert_eq!(intersection, [2]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn intersection<'a>(&'a self, other: &'a BTreeSet<T>)\n@@ -266,7 +266,7 @@ impl<T: Ord> BTreeSet<T> {\n     /// b.insert(2);\n     ///\n     /// let union: Vec<usize> = a.union(&b).cloned().collect();\n-    /// assert_eq!(union, vec![1,2]);\n+    /// assert_eq!(union, [1, 2]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn union<'a>(&'a self, other: &'a BTreeSet<T>) -> Union<'a, T> {\n@@ -534,7 +534,7 @@ impl<'a, 'b, T: Ord + Clone> Sub<&'b BTreeSet<T>> for &'a BTreeSet<T> {\n     ///\n     /// let result = &a - &b;\n     /// let result_vec: Vec<_> = result.into_iter().collect();\n-    /// assert_eq!(result_vec, vec![1, 2]);\n+    /// assert_eq!(result_vec, [1, 2]);\n     /// ```\n     fn sub(self, rhs: &BTreeSet<T>) -> BTreeSet<T> {\n         self.difference(rhs).cloned().collect()\n@@ -557,7 +557,7 @@ impl<'a, 'b, T: Ord + Clone> BitXor<&'b BTreeSet<T>> for &'a BTreeSet<T> {\n     ///\n     /// let result = &a ^ &b;\n     /// let result_vec: Vec<_> = result.into_iter().collect();\n-    /// assert_eq!(result_vec, vec![1, 4]);\n+    /// assert_eq!(result_vec, [1, 4]);\n     /// ```\n     fn bitxor(self, rhs: &BTreeSet<T>) -> BTreeSet<T> {\n         self.symmetric_difference(rhs).cloned().collect()\n@@ -580,7 +580,7 @@ impl<'a, 'b, T: Ord + Clone> BitAnd<&'b BTreeSet<T>> for &'a BTreeSet<T> {\n     ///\n     /// let result = &a & &b;\n     /// let result_vec: Vec<_> = result.into_iter().collect();\n-    /// assert_eq!(result_vec, vec![2, 3]);\n+    /// assert_eq!(result_vec, [2, 3]);\n     /// ```\n     fn bitand(self, rhs: &BTreeSet<T>) -> BTreeSet<T> {\n         self.intersection(rhs).cloned().collect()\n@@ -603,7 +603,7 @@ impl<'a, 'b, T: Ord + Clone> BitOr<&'b BTreeSet<T>> for &'a BTreeSet<T> {\n     ///\n     /// let result = &a | &b;\n     /// let result_vec: Vec<_> = result.into_iter().collect();\n-    /// assert_eq!(result_vec, vec![1, 2, 3, 4, 5]);\n+    /// assert_eq!(result_vec, [1, 2, 3, 4, 5]);\n     /// ```\n     fn bitor(self, rhs: &BTreeSet<T>) -> BTreeSet<T> {\n         self.union(rhs).cloned().collect()\n@@ -613,7 +613,7 @@ impl<'a, 'b, T: Ord + Clone> BitOr<&'b BTreeSet<T>> for &'a BTreeSet<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Debug> Debug for BTreeSet<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(f, \"BTreeSet {{\"));\n+        try!(write!(f, \"{{\"));\n \n         for (i, x) in self.iter().enumerate() {\n             if i != 0 { try!(write!(f, \", \")); }\n@@ -911,7 +911,7 @@ mod test {\n \n         let set_str = format!(\"{:?}\", set);\n \n-        assert_eq!(set_str, \"BTreeSet {1, 2}\");\n-        assert_eq!(format!(\"{:?}\", empty), \"BTreeSet {}\");\n+        assert_eq!(set_str, \"{1, 2}\");\n+        assert_eq!(format!(\"{:?}\", empty), \"{}\");\n     }\n }"}, {"sha": "62dd91915211b85a37aa1295c52ffa6b4439e6b8", "filename": "src/libcollections/enum_set.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibcollections%2Fenum_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibcollections%2Fenum_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fenum_set.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -36,7 +36,7 @@ impl<E> Copy for EnumSet<E> {}\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<E:CLike + fmt::Debug> fmt::Debug for EnumSet<E> {\n     fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(fmt, \"EnumSet {{\"));\n+        try!(write!(fmt, \"{{\"));\n         let mut first = true;\n         for e in self {\n             if !first {\n@@ -314,11 +314,11 @@ mod test {\n     #[test]\n     fn test_show() {\n         let mut e = EnumSet::new();\n-        assert!(format!(\"{:?}\", e) == \"EnumSet {}\");\n+        assert!(format!(\"{:?}\", e) == \"{}\");\n         e.insert(A);\n-        assert!(format!(\"{:?}\", e) == \"EnumSet {A}\");\n+        assert!(format!(\"{:?}\", e) == \"{A}\");\n         e.insert(C);\n-        assert!(format!(\"{:?}\", e) == \"EnumSet {A, C}\");\n+        assert!(format!(\"{:?}\", e) == \"{A, C}\");\n     }\n \n     #[test]\n@@ -428,19 +428,19 @@ mod test {\n \n         e1.insert(A);\n         let elems: ::vec::Vec<_> = e1.iter().collect();\n-        assert_eq!(vec![A], elems);\n+        assert_eq!([A], elems);\n \n         e1.insert(C);\n         let elems: ::vec::Vec<_> = e1.iter().collect();\n-        assert_eq!(vec![A,C], elems);\n+        assert_eq!([A,C], elems);\n \n         e1.insert(C);\n         let elems: ::vec::Vec<_> = e1.iter().collect();\n-        assert_eq!(vec![A,C], elems);\n+        assert_eq!([A,C], elems);\n \n         e1.insert(B);\n         let elems: ::vec::Vec<_> = e1.iter().collect();\n-        assert_eq!(vec![A,B,C], elems);\n+        assert_eq!([A,B,C], elems);\n     }\n \n     ///////////////////////////////////////////////////////////////////////////\n@@ -458,35 +458,35 @@ mod test {\n \n         let e_union = e1 | e2;\n         let elems: ::vec::Vec<_> = e_union.iter().collect();\n-        assert_eq!(vec![A,B,C], elems);\n+        assert_eq!([A,B,C], elems);\n \n         let e_intersection = e1 & e2;\n         let elems: ::vec::Vec<_> = e_intersection.iter().collect();\n-        assert_eq!(vec![C], elems);\n+        assert_eq!([C], elems);\n \n         // Another way to express intersection\n         let e_intersection = e1 - (e1 - e2);\n         let elems: ::vec::Vec<_> = e_intersection.iter().collect();\n-        assert_eq!(vec![C], elems);\n+        assert_eq!([C], elems);\n \n         let e_subtract = e1 - e2;\n         let elems: ::vec::Vec<_> = e_subtract.iter().collect();\n-        assert_eq!(vec![A], elems);\n+        assert_eq!([A], elems);\n \n         // Bitwise XOR of two sets, aka symmetric difference\n         let e_symmetric_diff = e1 ^ e2;\n         let elems: ::vec::Vec<_> = e_symmetric_diff.iter().collect();\n-        assert_eq!(vec![A,B], elems);\n+        assert_eq!([A,B], elems);\n \n         // Another way to express symmetric difference\n         let e_symmetric_diff = (e1 - e2) | (e2 - e1);\n         let elems: ::vec::Vec<_> = e_symmetric_diff.iter().collect();\n-        assert_eq!(vec![A,B], elems);\n+        assert_eq!([A,B], elems);\n \n         // Yet another way to express symmetric difference\n         let e_symmetric_diff = (e1 | e2) - (e1 & e2);\n         let elems: ::vec::Vec<_> = e_symmetric_diff.iter().collect();\n-        assert_eq!(vec![A,B], elems);\n+        assert_eq!([A,B], elems);\n     }\n \n     #[test]"}, {"sha": "7b66bfee34f2121b15f4e06ae47e832ed4a7edcf", "filename": "src/libcollections/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibcollections%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibcollections%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flib.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -30,6 +30,7 @@\n #![feature(unboxed_closures)]\n #![feature(unicode)]\n #![feature(unsafe_destructor)]\n+#![feature(unique)]\n #![feature(unsafe_no_drop_flag)]\n #![cfg_attr(test, feature(rand, rustc_private, test))]\n #![cfg_attr(test, allow(deprecated))] // rand"}, {"sha": "3d68bb13db8e90a35f423a05b9c84845e8adba36", "filename": "src/libcollections/linked_list.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flinked_list.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -777,7 +777,7 @@ impl<'a, A> IterMut<'a, A> {\n     /// }\n     /// {\n     ///     let vec: Vec<_> = list.into_iter().collect();\n-    ///     assert_eq!(vec, vec![1, 2, 3, 4]);\n+    ///     assert_eq!(vec, [1, 2, 3, 4]);\n     /// }\n     /// ```\n     #[inline]\n@@ -918,7 +918,7 @@ impl<A: Clone> Clone for LinkedList<A> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A: fmt::Debug> fmt::Debug for LinkedList<A> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(f, \"LinkedList [\"));\n+        try!(write!(f, \"[\"));\n \n         for (i, e) in self.iter().enumerate() {\n             if i != 0 { try!(write!(f, \", \")); }\n@@ -1273,7 +1273,7 @@ mod tests {\n         }\n         check_links(&m);\n         assert_eq!(m.len(), 3 + len * 2);\n-        assert_eq!(m.into_iter().collect::<Vec<_>>(), vec![-2,0,1,2,3,4,5,6,7,8,9,0,1]);\n+        assert_eq!(m.into_iter().collect::<Vec<_>>(), [-2,0,1,2,3,4,5,6,7,8,9,0,1]);\n     }\n \n     #[test]\n@@ -1387,10 +1387,10 @@ mod tests {\n     #[test]\n     fn test_show() {\n         let list: LinkedList<_> = (0..10).collect();\n-        assert_eq!(format!(\"{:?}\", list), \"LinkedList [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\");\n+        assert_eq!(format!(\"{:?}\", list), \"[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\");\n \n         let list: LinkedList<_> = vec![\"just\", \"one\", \"test\", \"more\"].iter().cloned().collect();\n-        assert_eq!(format!(\"{:?}\", list), \"LinkedList [\\\"just\\\", \\\"one\\\", \\\"test\\\", \\\"more\\\"]\");\n+        assert_eq!(format!(\"{:?}\", list), \"[\\\"just\\\", \\\"one\\\", \\\"test\\\", \\\"more\\\"]\");\n     }\n \n     #[cfg(test)]"}, {"sha": "e9764547628c052cd22db69dbf5424e619881db4", "filename": "src/libcollections/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibcollections%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibcollections%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fmacros.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -26,7 +26,7 @@\n ///\n /// ```\n /// let v = vec![1; 3];\n-/// assert_eq!(v, vec![1, 1, 1]);\n+/// assert_eq!(v, [1, 1, 1]);\n /// ```\n ///\n /// Note that unlike array expressions this syntax supports all elements"}, {"sha": "d4c53739686142cfa6ffb16dc7db15bd840a4a95", "filename": "src/libcollections/slice.rs", "status": "modified", "additions": 32, "deletions": 34, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibcollections%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibcollections%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fslice.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -1331,12 +1331,10 @@ fn insertion_sort<T, F>(v: &mut [T], mut compare: F) where F: FnMut(&T, &T) -> O\n \n             if i != j {\n                 let tmp = ptr::read(read_ptr);\n-                ptr::copy_memory(buf_v.offset(j + 1),\n-                                 &*buf_v.offset(j),\n-                                 (i - j) as usize);\n-                ptr::copy_nonoverlapping_memory(buf_v.offset(j),\n-                                                &tmp,\n-                                                1);\n+                ptr::copy(buf_v.offset(j + 1),\n+                          &*buf_v.offset(j),\n+                          (i - j) as usize);\n+                ptr::copy_nonoverlapping(buf_v.offset(j), &tmp, 1);\n                 mem::forget(tmp);\n             }\n         }\n@@ -1409,10 +1407,10 @@ fn merge_sort<T, F>(v: &mut [T], mut compare: F) where F: FnMut(&T, &T) -> Order\n                 // j + 1 could be `len` (for the last `i`), but in\n                 // that case, `i == j` so we don't copy. The\n                 // `.offset(j)` is always in bounds.\n-                ptr::copy_memory(buf_dat.offset(j + 1),\n-                                 &*buf_dat.offset(j),\n-                                 i - j as usize);\n-                ptr::copy_nonoverlapping_memory(buf_dat.offset(j), read_ptr, 1);\n+                ptr::copy(buf_dat.offset(j + 1),\n+                          &*buf_dat.offset(j),\n+                          i - j as usize);\n+                ptr::copy_nonoverlapping(buf_dat.offset(j), read_ptr, 1);\n             }\n         }\n     }\n@@ -1460,11 +1458,11 @@ fn merge_sort<T, F>(v: &mut [T], mut compare: F) where F: FnMut(&T, &T) -> Order\n                     if left == right_start {\n                         // the number remaining in this run.\n                         let elems = (right_end as usize - right as usize) / mem::size_of::<T>();\n-                        ptr::copy_nonoverlapping_memory(out, &*right, elems);\n+                        ptr::copy_nonoverlapping(out, &*right, elems);\n                         break;\n                     } else if right == right_end {\n                         let elems = (right_start as usize - left as usize) / mem::size_of::<T>();\n-                        ptr::copy_nonoverlapping_memory(out, &*left, elems);\n+                        ptr::copy_nonoverlapping(out, &*left, elems);\n                         break;\n                     }\n \n@@ -1478,7 +1476,7 @@ fn merge_sort<T, F>(v: &mut [T], mut compare: F) where F: FnMut(&T, &T) -> Order\n                     } else {\n                         step(&mut left)\n                     };\n-                    ptr::copy_nonoverlapping_memory(out, &*to_copy, 1);\n+                    ptr::copy_nonoverlapping(out, &*to_copy, 1);\n                     step(&mut out);\n                 }\n             }\n@@ -1492,7 +1490,7 @@ fn merge_sort<T, F>(v: &mut [T], mut compare: F) where F: FnMut(&T, &T) -> Order\n     // write the result to `v` in one go, so that there are never two copies\n     // of the same object in `v`.\n     unsafe {\n-        ptr::copy_nonoverlapping_memory(v.as_mut_ptr(), &*buf_dat, len);\n+        ptr::copy_nonoverlapping(v.as_mut_ptr(), &*buf_dat, len);\n     }\n \n     // increment the pointer, returning the old pointer.\n@@ -1779,10 +1777,10 @@ mod tests {\n         let mut v = vec![1, 2, 3, 4, 5];\n         let mut e = v.swap_remove(0);\n         assert_eq!(e, 1);\n-        assert_eq!(v, vec![5, 2, 3, 4]);\n+        assert_eq!(v, [5, 2, 3, 4]);\n         e = v.swap_remove(3);\n         assert_eq!(e, 4);\n-        assert_eq!(v, vec![5, 2, 3]);\n+        assert_eq!(v, [5, 2, 3]);\n     }\n \n     #[test]\n@@ -1890,7 +1888,7 @@ mod tests {\n     fn test_retain() {\n         let mut v = vec![1, 2, 3, 4, 5];\n         v.retain(is_odd);\n-        assert_eq!(v, vec![1, 3, 5]);\n+        assert_eq!(v, [1, 3, 5]);\n     }\n \n     #[test]\n@@ -2159,45 +2157,45 @@ mod tests {\n         let v: [Vec<i32>; 0] = [];\n         let c = v.concat();\n         assert_eq!(c, []);\n-        let d = [vec![1], vec![2,3]].concat();\n-        assert_eq!(d, vec![1, 2, 3]);\n+        let d = [vec![1], vec![2, 3]].concat();\n+        assert_eq!(d, [1, 2, 3]);\n \n         let v: &[&[_]] = &[&[1], &[2, 3]];\n-        assert_eq!(v.connect(&0), vec![1, 0, 2, 3]);\n+        assert_eq!(v.connect(&0), [1, 0, 2, 3]);\n         let v: &[&[_]] = &[&[1], &[2], &[3]];\n-        assert_eq!(v.connect(&0), vec![1, 0, 2, 0, 3]);\n+        assert_eq!(v.connect(&0), [1, 0, 2, 0, 3]);\n     }\n \n     #[test]\n     fn test_connect() {\n         let v: [Vec<i32>; 0] = [];\n-        assert_eq!(v.connect(&0), vec![]);\n-        assert_eq!([vec![1], vec![2, 3]].connect(&0), vec![1, 0, 2, 3]);\n-        assert_eq!([vec![1], vec![2], vec![3]].connect(&0), vec![1, 0, 2, 0, 3]);\n+        assert_eq!(v.connect(&0), []);\n+        assert_eq!([vec![1i], vec![2, 3]].connect(&0), [1, 0, 2, 3]);\n+        assert_eq!([vec![1i], vec![2], vec![3]].connect(&0), [1, 0, 2, 0, 3]);\n \n         let v: [&[_]; 2] = [&[1], &[2, 3]];\n-        assert_eq!(v.connect(&0), vec![1, 0, 2, 3]);\n+        assert_eq!(v.connect(&0), [1, 0, 2, 3]);\n         let v: [&[_]; 3] = [&[1], &[2], &[3]];\n-        assert_eq!(v.connect(&0), vec![1, 0, 2, 0, 3]);\n+        assert_eq!(v.connect(&0), [1, 0, 2, 0, 3]);\n     }\n \n     #[test]\n     fn test_insert() {\n         let mut a = vec![1, 2, 4];\n         a.insert(2, 3);\n-        assert_eq!(a, vec![1, 2, 3, 4]);\n+        assert_eq!(a, [1, 2, 3, 4]);\n \n         let mut a = vec![1, 2, 3];\n         a.insert(0, 0);\n-        assert_eq!(a, vec![0, 1, 2, 3]);\n+        assert_eq!(a, [0, 1, 2, 3]);\n \n         let mut a = vec![1, 2, 3];\n         a.insert(3, 4);\n-        assert_eq!(a, vec![1, 2, 3, 4]);\n+        assert_eq!(a, [1, 2, 3, 4]);\n \n         let mut a = vec![];\n         a.insert(0, 1);\n-        assert_eq!(a, vec![1]);\n+        assert_eq!(a, [1]);\n     }\n \n     #[test]\n@@ -2212,16 +2210,16 @@ mod tests {\n         let mut a = vec![1, 2, 3, 4];\n \n         assert_eq!(a.remove(2), 3);\n-        assert_eq!(a, vec![1, 2, 4]);\n+        assert_eq!(a, [1, 2, 4]);\n \n         assert_eq!(a.remove(2), 4);\n-        assert_eq!(a, vec![1, 2]);\n+        assert_eq!(a, [1, 2]);\n \n         assert_eq!(a.remove(0), 1);\n-        assert_eq!(a, vec![2]);\n+        assert_eq!(a, [2]);\n \n         assert_eq!(a.remove(0), 2);\n-        assert_eq!(a, vec![]);\n+        assert_eq!(a, []);\n     }\n \n     #[test]"}, {"sha": "c58cca828d8c39a04c9fc542aa7b0ff3ec54a8ad", "filename": "src/libcollections/str.rs", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibcollections%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibcollections%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstr.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -552,7 +552,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// ```\n     /// let v: Vec<char> = \"abc \u00e5\u00e4\u00f6\".chars().collect();\n     ///\n-    /// assert_eq!(v, vec!['a', 'b', 'c', ' ', '\u00e5', '\u00e4', '\u00f6']);\n+    /// assert_eq!(v, ['a', 'b', 'c', ' ', '\u00e5', '\u00e4', '\u00f6']);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn chars(&self) -> Chars {\n@@ -600,20 +600,20 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     ///\n     /// ```\n     /// let v: Vec<&str> = \"Mary had a little lamb\".split(' ').collect();\n-    /// assert_eq!(v, vec![\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]);\n+    /// assert_eq!(v, [\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]);\n     ///\n     /// let v: Vec<&str> = \"\".split('X').collect();\n-    /// assert_eq!(v, vec![\"\"]);\n+    /// assert_eq!(v, [\"\"]);\n     /// ```\n     ///\n     /// More complex patterns with a lambda:\n     ///\n     /// ```\n     /// let v: Vec<&str> = \"abc1def2ghi\".split(|c: char| c.is_numeric()).collect();\n-    /// assert_eq!(v, vec![\"abc\", \"def\", \"ghi\"]);\n+    /// assert_eq!(v, [\"abc\", \"def\", \"ghi\"]);\n     ///\n     /// let v: Vec<&str> = \"lionXXtigerXleopard\".split('X').collect();\n-    /// assert_eq!(v, vec![\"lion\", \"\", \"tiger\", \"leopard\"]);\n+    /// assert_eq!(v, [\"lion\", \"\", \"tiger\", \"leopard\"]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn split<'a, P: Pattern<'a>>(&'a self, pat: P) -> Split<'a, P> {\n@@ -632,23 +632,23 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     ///\n     /// ```\n     /// let v: Vec<&str> = \"Mary had a little lambda\".splitn(2, ' ').collect();\n-    /// assert_eq!(v, vec![\"Mary\", \"had\", \"a little lambda\"]);\n+    /// assert_eq!(v, [\"Mary\", \"had\", \"a little lambda\"]);\n     ///\n     /// let v: Vec<&str> = \"lionXXtigerXleopard\".splitn(2, 'X').collect();\n-    /// assert_eq!(v, vec![\"lion\", \"\", \"tigerXleopard\"]);\n+    /// assert_eq!(v, [\"lion\", \"\", \"tigerXleopard\"]);\n     ///\n     /// let v: Vec<&str> = \"abcXdef\".splitn(0, 'X').collect();\n-    /// assert_eq!(v, vec![\"abcXdef\"]);\n+    /// assert_eq!(v, [\"abcXdef\"]);\n     ///\n     /// let v: Vec<&str> = \"\".splitn(1, 'X').collect();\n-    /// assert_eq!(v, vec![\"\"]);\n+    /// assert_eq!(v, [\"\"]);\n     /// ```\n     ///\n     /// More complex patterns with a lambda:\n     ///\n     /// ```\n     /// let v: Vec<&str> = \"abc1def2ghi\".splitn(1, |c: char| c.is_numeric()).collect();\n-    /// assert_eq!(v, vec![\"abc\", \"def2ghi\"]);\n+    /// assert_eq!(v, [\"abc\", \"def2ghi\"]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn splitn<'a, P: Pattern<'a>>(&'a self, count: usize, pat: P) -> SplitN<'a, P> {\n@@ -669,17 +669,17 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     ///\n     /// ```\n     /// let v: Vec<&str> = \"A.B.\".split_terminator('.').collect();\n-    /// assert_eq!(v, vec![\"A\", \"B\"]);\n+    /// assert_eq!(v, [\"A\", \"B\"]);\n     ///\n     /// let v: Vec<&str> = \"A..B..\".split_terminator('.').collect();\n-    /// assert_eq!(v, vec![\"A\", \"\", \"B\", \"\"]);\n+    /// assert_eq!(v, [\"A\", \"\", \"B\", \"\"]);\n     /// ```\n     ///\n     /// More complex patterns with a lambda:\n     ///\n     /// ```\n     /// let v: Vec<&str> = \"abc1def2ghi3\".split_terminator(|c: char| c.is_numeric()).collect();\n-    /// assert_eq!(v, vec![\"abc\", \"def\", \"ghi\"]);\n+    /// assert_eq!(v, [\"abc\", \"def\", \"ghi\"]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn split_terminator<'a, P: Pattern<'a>>(&'a self, pat: P) -> SplitTerminator<'a, P> {\n@@ -699,17 +699,17 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     ///\n     /// ```\n     /// let v: Vec<&str> = \"Mary had a little lamb\".rsplitn(2, ' ').collect();\n-    /// assert_eq!(v, vec![\"lamb\", \"little\", \"Mary had a\"]);\n+    /// assert_eq!(v, [\"lamb\", \"little\", \"Mary had a\"]);\n     ///\n     /// let v: Vec<&str> = \"lionXXtigerXleopard\".rsplitn(2, 'X').collect();\n-    /// assert_eq!(v, vec![\"leopard\", \"tiger\", \"lionX\"]);\n+    /// assert_eq!(v, [\"leopard\", \"tiger\", \"lionX\"]);\n     /// ```\n     ///\n     /// More complex patterns with a lambda:\n     ///\n     /// ```\n     /// let v: Vec<&str> = \"abc1def2ghi\".rsplitn(1, |c: char| c.is_numeric()).collect();\n-    /// assert_eq!(v, vec![\"ghi\", \"abc1def\"]);\n+    /// assert_eq!(v, [\"ghi\", \"abc1def\"]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn rsplitn<'a, P: Pattern<'a>>(&'a self, count: usize, pat: P) -> RSplitN<'a, P> {\n@@ -727,13 +727,13 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     ///\n     /// ```\n     /// let v: Vec<(usize, usize)> = \"abcXXXabcYYYabc\".match_indices(\"abc\").collect();\n-    /// assert_eq!(v, vec![(0,3), (6,9), (12,15)]);\n+    /// assert_eq!(v, [(0,3), (6,9), (12,15)]);\n     ///\n     /// let v: Vec<(usize, usize)> = \"1abcabc2\".match_indices(\"abc\").collect();\n-    /// assert_eq!(v, vec![(1,4), (4,7)]);\n+    /// assert_eq!(v, [(1,4), (4,7)]);\n     ///\n     /// let v: Vec<(usize, usize)> = \"ababa\".match_indices(\"aba\").collect();\n-    /// assert_eq!(v, vec![(0, 3)]); // only the first `aba`\n+    /// assert_eq!(v, [(0, 3)]); // only the first `aba`\n     /// ```\n     #[unstable(feature = \"collections\",\n                reason = \"might have its iterator type changed\")]\n@@ -749,10 +749,10 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     ///\n     /// ```\n     /// let v: Vec<&str> = \"abcXXXabcYYYabc\".split_str(\"abc\").collect();\n-    /// assert_eq!(v, vec![\"\", \"XXX\", \"YYY\", \"\"]);\n+    /// assert_eq!(v, [\"\", \"XXX\", \"YYY\", \"\"]);\n     ///\n     /// let v: Vec<&str> = \"1abcabc2\".split_str(\"abc\").collect();\n-    /// assert_eq!(v, vec![\"1\", \"\", \"2\"]);\n+    /// assert_eq!(v, [\"1\", \"\", \"2\"]);\n     /// ```\n     #[unstable(feature = \"collections\")]\n     #[deprecated(since = \"1.0.0\", reason = \"use `split()` with a `&str`\")]\n@@ -770,7 +770,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// let four_lines = \"foo\\nbar\\n\\nbaz\";\n     /// let v: Vec<&str> = four_lines.lines().collect();\n     ///\n-    /// assert_eq!(v, vec![\"foo\", \"bar\", \"\", \"baz\"]);\n+    /// assert_eq!(v, [\"foo\", \"bar\", \"\", \"baz\"]);\n     /// ```\n     ///\n     /// Leaving off the trailing character:\n@@ -779,7 +779,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// let four_lines = \"foo\\nbar\\n\\nbaz\\n\";\n     /// let v: Vec<&str> = four_lines.lines().collect();\n     ///\n-    /// assert_eq!(v, vec![\"foo\", \"bar\", \"\", \"baz\"]);\n+    /// assert_eq!(v, [\"foo\", \"bar\", \"\", \"baz\"]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn lines(&self) -> Lines {\n@@ -796,7 +796,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// let four_lines = \"foo\\r\\nbar\\n\\r\\nbaz\";\n     /// let v: Vec<&str> = four_lines.lines_any().collect();\n     ///\n-    /// assert_eq!(v, vec![\"foo\", \"bar\", \"\", \"baz\"]);\n+    /// assert_eq!(v, [\"foo\", \"bar\", \"\", \"baz\"]);\n     /// ```\n     ///\n     /// Leaving off the trailing character:\n@@ -805,7 +805,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// let four_lines = \"foo\\r\\nbar\\n\\r\\nbaz\\n\";\n     /// let v: Vec<&str> = four_lines.lines_any().collect();\n     ///\n-    /// assert_eq!(v, vec![\"foo\", \"bar\", \"\", \"baz\"]);\n+    /// assert_eq!(v, [\"foo\", \"bar\", \"\", \"baz\"]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn lines_any(&self) -> LinesAny {\n@@ -1441,7 +1441,7 @@ pub trait StrExt: Index<RangeFull, Output = str> {\n     /// let some_words = \" Mary   had\\ta little  \\n\\t lamb\";\n     /// let v: Vec<&str> = some_words.words().collect();\n     ///\n-    /// assert_eq!(v, vec![\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]);\n+    /// assert_eq!(v, [\"Mary\", \"had\", \"a\", \"little\", \"lamb\"]);\n     /// ```\n     #[unstable(feature = \"str_words\",\n                reason = \"the precise algorithm to use is unclear\")]\n@@ -2400,35 +2400,35 @@ mod tests {\n         let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n \n         let split: Vec<&str> = data.splitn(3, ' ').collect();\n-        assert_eq!(split, vec![\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little l\u00e4mb\\nLittle l\u00e4mb\\n\"]);\n+        assert_eq!(split, [\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little l\u00e4mb\\nLittle l\u00e4mb\\n\"]);\n \n         let split: Vec<&str> = data.splitn(3, |c: char| c == ' ').collect();\n-        assert_eq!(split, vec![\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little l\u00e4mb\\nLittle l\u00e4mb\\n\"]);\n+        assert_eq!(split, [\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little l\u00e4mb\\nLittle l\u00e4mb\\n\"]);\n \n         // Unicode\n         let split: Vec<&str> = data.splitn(3, '\u00e4').collect();\n-        assert_eq!(split, vec![\"\\nM\", \"ry h\", \"d \", \" little l\u00e4mb\\nLittle l\u00e4mb\\n\"]);\n+        assert_eq!(split, [\"\\nM\", \"ry h\", \"d \", \" little l\u00e4mb\\nLittle l\u00e4mb\\n\"]);\n \n         let split: Vec<&str> = data.splitn(3, |c: char| c == '\u00e4').collect();\n-        assert_eq!(split, vec![\"\\nM\", \"ry h\", \"d \", \" little l\u00e4mb\\nLittle l\u00e4mb\\n\"]);\n+        assert_eq!(split, [\"\\nM\", \"ry h\", \"d \", \" little l\u00e4mb\\nLittle l\u00e4mb\\n\"]);\n     }\n \n     #[test]\n     fn test_split_char_iterator_no_trailing() {\n         let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n \n         let split: Vec<&str> = data.split('\\n').collect();\n-        assert_eq!(split, vec![\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"Little l\u00e4mb\", \"\"]);\n+        assert_eq!(split, [\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"Little l\u00e4mb\", \"\"]);\n \n         let split: Vec<&str> = data.split_terminator('\\n').collect();\n-        assert_eq!(split, vec![\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"Little l\u00e4mb\"]);\n+        assert_eq!(split, [\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"Little l\u00e4mb\"]);\n     }\n \n     #[test]\n     fn test_words() {\n         let data = \"\\n \\tM\u00e4ry   h\u00e4d\\t\u00e4  little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n         let words: Vec<&str> = data.words().collect();\n-        assert_eq!(words, vec![\"M\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\", \"Little\", \"l\u00e4mb\"])\n+        assert_eq!(words, [\"M\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\", \"Little\", \"l\u00e4mb\"])\n     }\n \n     #[test]\n@@ -2513,11 +2513,11 @@ mod tests {\n     fn test_lines() {\n         let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\n\\nLittle l\u00e4mb\\n\";\n         let lines: Vec<&str> = data.lines().collect();\n-        assert_eq!(lines, vec![\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"\", \"Little l\u00e4mb\"]);\n+        assert_eq!(lines, [\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"\", \"Little l\u00e4mb\"]);\n \n         let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\n\\nLittle l\u00e4mb\"; // no trailing \\n\n         let lines: Vec<&str> = data.lines().collect();\n-        assert_eq!(lines, vec![\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"\", \"Little l\u00e4mb\"]);\n+        assert_eq!(lines, [\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"\", \"Little l\u00e4mb\"]);\n     }\n \n     #[test]"}, {"sha": "94abffa3db61cf6c33d24e87807af67e419fe1a1", "filename": "src/libcollections/string.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibcollections%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibcollections%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fstring.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -120,7 +120,7 @@ impl String {\n     /// let invalid_vec = vec![240, 144, 128];\n     /// let s = String::from_utf8(invalid_vec).err().unwrap();\n     /// assert_eq!(s.utf8_error(), Utf8Error::TooShort);\n-    /// assert_eq!(s.into_bytes(), vec![240, 144, 128]);\n+    /// assert_eq!(s.into_bytes(), [240, 144, 128]);\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -340,7 +340,7 @@ impl String {\n     /// ```\n     /// let s = String::from_str(\"hello\");\n     /// let bytes = s.into_bytes();\n-    /// assert_eq!(bytes, vec![104, 101, 108, 108, 111]);\n+    /// assert_eq!(bytes, [104, 101, 108, 108, 111]);\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -568,9 +568,9 @@ impl String {\n \n         let CharRange { ch, next } = self.char_range_at(idx);\n         unsafe {\n-            ptr::copy_memory(self.vec.as_mut_ptr().offset(idx as isize),\n-                             self.vec.as_ptr().offset(next as isize),\n-                             len - next);\n+            ptr::copy(self.vec.as_mut_ptr().offset(idx as isize),\n+                      self.vec.as_ptr().offset(next as isize),\n+                      len - next);\n             self.vec.set_len(len - (next - idx));\n         }\n         ch\n@@ -598,12 +598,12 @@ impl String {\n         let amt = ch.encode_utf8(&mut bits).unwrap();\n \n         unsafe {\n-            ptr::copy_memory(self.vec.as_mut_ptr().offset((idx + amt) as isize),\n-                             self.vec.as_ptr().offset(idx as isize),\n-                             len - idx);\n-            ptr::copy_memory(self.vec.as_mut_ptr().offset(idx as isize),\n-                             bits.as_ptr(),\n-                             amt);\n+            ptr::copy(self.vec.as_mut_ptr().offset((idx + amt) as isize),\n+                      self.vec.as_ptr().offset(idx as isize),\n+                      len - idx);\n+            ptr::copy(self.vec.as_mut_ptr().offset(idx as isize),\n+                      bits.as_ptr(),\n+                      amt);\n             self.vec.set_len(len + amt);\n         }\n     }\n@@ -619,7 +619,7 @@ impl String {\n     /// let mut s = String::from_str(\"hello\");\n     /// unsafe {\n     ///     let vec = s.as_mut_vec();\n-    ///     assert!(vec == &mut vec![104, 101, 108, 108, 111]);\n+    ///     assert!(vec == &[104, 101, 108, 108, 111]);\n     ///     vec.reverse();\n     /// }\n     /// assert_eq!(s.as_slice(), \"olleh\");"}, {"sha": "6d4541b5bde16d25f0616c7953476b0fe38a9b98", "filename": "src/libcollections/vec.rs", "status": "modified", "additions": 36, "deletions": 36, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibcollections%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibcollections%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -93,15 +93,15 @@ use borrow::{Cow, IntoCow};\n /// for x in vec.iter() {\n ///     println!(\"{}\", x);\n /// }\n-/// assert_eq!(vec, vec![7, 1, 2, 3]);\n+/// assert_eq!(vec, [7, 1, 2, 3]);\n /// ```\n ///\n /// The `vec!` macro is provided to make initialization more convenient:\n ///\n /// ```\n /// let mut vec = vec![1, 2, 3];\n /// vec.push(4);\n-/// assert_eq!(vec, vec![1, 2, 3, 4]);\n+/// assert_eq!(vec, [1, 2, 3, 4]);\n /// ```\n ///\n /// Use a `Vec<T>` as an efficient stack:\n@@ -242,7 +242,7 @@ impl<T> Vec<T> {\n     ///\n     ///         // Put everything back together into a Vec\n     ///         let rebuilt = Vec::from_raw_parts(p, len, cap);\n-    ///         assert_eq!(rebuilt, vec![4, 5, 6]);\n+    ///         assert_eq!(rebuilt, [4, 5, 6]);\n     ///     }\n     /// }\n     /// ```\n@@ -267,7 +267,7 @@ impl<T> Vec<T> {\n     pub unsafe fn from_raw_buf(ptr: *const T, elts: usize) -> Vec<T> {\n         let mut dst = Vec::with_capacity(elts);\n         dst.set_len(elts);\n-        ptr::copy_nonoverlapping_memory(dst.as_mut_ptr(), ptr, elts);\n+        ptr::copy_nonoverlapping(dst.as_mut_ptr(), ptr, elts);\n         dst\n     }\n \n@@ -404,7 +404,7 @@ impl<T> Vec<T> {\n     /// ```\n     /// let mut vec = vec![1, 2, 3, 4];\n     /// vec.truncate(2);\n-    /// assert_eq!(vec, vec![1, 2]);\n+    /// assert_eq!(vec, [1, 2]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn truncate(&mut self, len: usize) {\n@@ -505,10 +505,10 @@ impl<T> Vec<T> {\n     /// let mut v = vec![\"foo\", \"bar\", \"baz\", \"qux\"];\n     ///\n     /// assert_eq!(v.swap_remove(1), \"bar\");\n-    /// assert_eq!(v, vec![\"foo\", \"qux\", \"baz\"]);\n+    /// assert_eq!(v, [\"foo\", \"qux\", \"baz\"]);\n     ///\n     /// assert_eq!(v.swap_remove(0), \"foo\");\n-    /// assert_eq!(v, vec![\"baz\", \"qux\"]);\n+    /// assert_eq!(v, [\"baz\", \"qux\"]);\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -531,9 +531,9 @@ impl<T> Vec<T> {\n     /// ```\n     /// let mut vec = vec![1, 2, 3];\n     /// vec.insert(1, 4);\n-    /// assert_eq!(vec, vec![1, 4, 2, 3]);\n+    /// assert_eq!(vec, [1, 4, 2, 3]);\n     /// vec.insert(4, 5);\n-    /// assert_eq!(vec, vec![1, 4, 2, 3, 5]);\n+    /// assert_eq!(vec, [1, 4, 2, 3, 5]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn insert(&mut self, index: usize, element: T) {\n@@ -548,7 +548,7 @@ impl<T> Vec<T> {\n                 let p = self.as_mut_ptr().offset(index as isize);\n                 // Shift everything over to make space. (Duplicating the\n                 // `index`th element into two consecutive places.)\n-                ptr::copy_memory(p.offset(1), &*p, len - index);\n+                ptr::copy(p.offset(1), &*p, len - index);\n                 // Write it in, overwriting the first copy of the `index`th\n                 // element.\n                 ptr::write(&mut *p, element);\n@@ -569,7 +569,7 @@ impl<T> Vec<T> {\n     /// ```\n     /// let mut v = vec![1, 2, 3];\n     /// assert_eq!(v.remove(1), 2);\n-    /// assert_eq!(v, vec![1, 3]);\n+    /// assert_eq!(v, [1, 3]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn remove(&mut self, index: usize) -> T {\n@@ -585,7 +585,7 @@ impl<T> Vec<T> {\n                 ret = ptr::read(ptr);\n \n                 // Shift everything down to fill in that spot.\n-                ptr::copy_memory(ptr, &*ptr.offset(1), len - index - 1);\n+                ptr::copy(ptr, &*ptr.offset(1), len - index - 1);\n             }\n             self.set_len(len - 1);\n             ret\n@@ -603,7 +603,7 @@ impl<T> Vec<T> {\n     /// ```\n     /// let mut vec = vec![1, 2, 3, 4];\n     /// vec.retain(|&x| x%2 == 0);\n-    /// assert_eq!(vec, vec![2, 4]);\n+    /// assert_eq!(vec, [2, 4]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn retain<F>(&mut self, mut f: F) where F: FnMut(&T) -> bool {\n@@ -636,7 +636,7 @@ impl<T> Vec<T> {\n     /// ```rust\n     /// let mut vec = vec!(1, 2);\n     /// vec.push(3);\n-    /// assert_eq!(vec, vec!(1, 2, 3));\n+    /// assert_eq!(vec, [1, 2, 3]);\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -674,7 +674,7 @@ impl<T> Vec<T> {\n     /// ```rust\n     /// let mut vec = vec![1, 2, 3];\n     /// assert_eq!(vec.pop(), Some(3));\n-    /// assert_eq!(vec, vec![1, 2]);\n+    /// assert_eq!(vec, [1, 2]);\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -701,8 +701,8 @@ impl<T> Vec<T> {\n     /// let mut vec = vec![1, 2, 3];\n     /// let mut vec2 = vec![4, 5, 6];\n     /// vec.append(&mut vec2);\n-    /// assert_eq!(vec, vec![1, 2, 3, 4, 5, 6]);\n-    /// assert_eq!(vec2, vec![]);\n+    /// assert_eq!(vec, [1, 2, 3, 4, 5, 6]);\n+    /// assert_eq!(vec2, []);\n     /// ```\n     #[inline]\n     #[unstable(feature = \"collections\",\n@@ -718,7 +718,7 @@ impl<T> Vec<T> {\n         self.reserve(other.len());\n         let len = self.len();\n         unsafe {\n-            ptr::copy_nonoverlapping_memory(\n+            ptr::copy_nonoverlapping(\n                 self.get_unchecked_mut(len),\n                 other.as_ptr(),\n                 other.len());\n@@ -1019,8 +1019,8 @@ impl<T> Vec<T> {\n     /// ```\n     /// let mut vec = vec![1,2,3];\n     /// let vec2 = vec.split_off(1);\n-    /// assert_eq!(vec, vec![1]);\n-    /// assert_eq!(vec2, vec![2, 3]);\n+    /// assert_eq!(vec, [1]);\n+    /// assert_eq!(vec2, [2, 3]);\n     /// ```\n     #[inline]\n     #[unstable(feature = \"collections\",\n@@ -1036,7 +1036,7 @@ impl<T> Vec<T> {\n             self.set_len(at);\n             other.set_len(other_len);\n \n-            ptr::copy_nonoverlapping_memory(\n+            ptr::copy_nonoverlapping(\n                 other.as_mut_ptr(),\n                 self.as_ptr().offset(at as isize),\n                 other.len());\n@@ -1057,11 +1057,11 @@ impl<T: Clone> Vec<T> {\n     /// ```\n     /// let mut vec = vec![\"hello\"];\n     /// vec.resize(3, \"world\");\n-    /// assert_eq!(vec, vec![\"hello\", \"world\", \"world\"]);\n+    /// assert_eq!(vec, [\"hello\", \"world\", \"world\"]);\n     ///\n     /// let mut vec = vec![1, 2, 3, 4];\n     /// vec.resize(2, 0);\n-    /// assert_eq!(vec, vec![1, 2]);\n+    /// assert_eq!(vec, [1, 2]);\n     /// ```\n     #[unstable(feature = \"collections\",\n                reason = \"matches collection reform specification; waiting for dust to settle\")]\n@@ -1085,7 +1085,7 @@ impl<T: Clone> Vec<T> {\n     /// ```\n     /// let mut vec = vec![1];\n     /// vec.push_all(&[2, 3, 4]);\n-    /// assert_eq!(vec, vec![1, 2, 3, 4]);\n+    /// assert_eq!(vec, [1, 2, 3, 4]);\n     /// ```\n     #[inline]\n     #[unstable(feature = \"collections\",\n@@ -1121,7 +1121,7 @@ impl<T: PartialEq> Vec<T> {\n     ///\n     /// vec.dedup();\n     ///\n-    /// assert_eq!(vec, vec![1, 2, 3, 2]);\n+    /// assert_eq!(vec, [1, 2, 3, 2]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn dedup(&mut self) {\n@@ -2105,7 +2105,7 @@ mod tests {\n             }\n         }\n \n-        assert!(values == vec![2, 3, 5, 6, 7]);\n+        assert_eq!(values, [2, 3, 5, 6, 7]);\n     }\n \n     #[test]\n@@ -2147,7 +2147,7 @@ mod tests {\n     fn test_retain() {\n         let mut vec = vec![1, 2, 3, 4];\n         vec.retain(|&x| x % 2 == 0);\n-        assert!(vec == vec![2, 4]);\n+        assert_eq!(vec, [2, 4]);\n     }\n \n     #[test]\n@@ -2207,13 +2207,13 @@ mod tests {\n             let a = [1, 2, 3];\n             let ptr = a.as_ptr();\n             let b = Vec::from_raw_buf(ptr, 3);\n-            assert_eq!(b, vec![1, 2, 3]);\n+            assert_eq!(b, [1, 2, 3]);\n \n             // Test on-heap copy-from-buf.\n             let c = vec![1, 2, 3, 4, 5];\n             let ptr = c.as_ptr();\n             let d = Vec::from_raw_buf(ptr, 5);\n-            assert_eq!(d, vec![1, 2, 3, 4, 5]);\n+            assert_eq!(d, [1, 2, 3, 4, 5]);\n         }\n     }\n \n@@ -2375,7 +2375,7 @@ mod tests {\n         for i in vec {\n             vec2.push(i);\n         }\n-        assert!(vec2 == vec![1, 2, 3]);\n+        assert_eq!(vec2, [1, 2, 3]);\n     }\n \n     #[test]\n@@ -2385,7 +2385,7 @@ mod tests {\n         for i in vec.into_iter().rev() {\n             vec2.push(i);\n         }\n-        assert!(vec2 == vec![3, 2, 1]);\n+        assert_eq!(vec2, [3, 2, 1]);\n     }\n \n     #[test]\n@@ -2395,7 +2395,7 @@ mod tests {\n         for i in vec {\n             vec2.push(i);\n         }\n-        assert!(vec2 == vec![(), (), ()]);\n+        assert_eq!(vec2, [(), (), ()]);\n     }\n \n     #[test]\n@@ -2443,16 +2443,16 @@ mod tests {\n         let mut vec = vec![1, 2, 3];\n         let mut vec2 = vec![4, 5, 6];\n         vec.append(&mut vec2);\n-        assert_eq!(vec, vec![1, 2, 3, 4, 5, 6]);\n-        assert_eq!(vec2, vec![]);\n+        assert_eq!(vec, [1, 2, 3, 4, 5, 6]);\n+        assert_eq!(vec2, []);\n     }\n \n     #[test]\n     fn test_split_off() {\n         let mut vec = vec![1, 2, 3, 4, 5, 6];\n         let vec2 = vec.split_off(4);\n-        assert_eq!(vec, vec![1, 2, 3, 4]);\n-        assert_eq!(vec2, vec![5, 6]);\n+        assert_eq!(vec, [1, 2, 3, 4]);\n+        assert_eq!(vec2, [5, 6]);\n     }\n \n     #[bench]"}, {"sha": "e99d44551d5368c1f5fe05c81b76188d10032814", "filename": "src/libcollections/vec_deque.rs", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_deque.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -134,7 +134,7 @@ impl<T> VecDeque<T> {\n                       self.cap);\n         debug_assert!(src + len <= self.cap, \"dst={} src={} len={} cap={}\", dst, src, len,\n                       self.cap);\n-        ptr::copy_memory(\n+        ptr::copy(\n             self.ptr.offset(dst as isize),\n             self.ptr.offset(src as isize),\n             len);\n@@ -147,7 +147,7 @@ impl<T> VecDeque<T> {\n                       self.cap);\n         debug_assert!(src + len <= self.cap, \"dst={} src={} len={} cap={}\", dst, src, len,\n                       self.cap);\n-        ptr::copy_nonoverlapping_memory(\n+        ptr::copy_nonoverlapping(\n             self.ptr.offset(dst as isize),\n             self.ptr.offset(src as isize),\n             len);\n@@ -1343,22 +1343,22 @@ impl<T> VecDeque<T> {\n                 // `at` lies in the first half.\n                 let amount_in_first = first_len - at;\n \n-                ptr::copy_nonoverlapping_memory(*other.ptr,\n-                                                first_half.as_ptr().offset(at as isize),\n-                                                amount_in_first);\n+                ptr::copy_nonoverlapping(*other.ptr,\n+                                         first_half.as_ptr().offset(at as isize),\n+                                         amount_in_first);\n \n                 // just take all of the second half.\n-                ptr::copy_nonoverlapping_memory(other.ptr.offset(amount_in_first as isize),\n-                                                second_half.as_ptr(),\n-                                                second_len);\n+                ptr::copy_nonoverlapping(other.ptr.offset(amount_in_first as isize),\n+                                         second_half.as_ptr(),\n+                                         second_len);\n             } else {\n                 // `at` lies in the second half, need to factor in the elements we skipped\n                 // in the first half.\n                 let offset = at - first_len;\n                 let amount_in_second = second_len - offset;\n-                ptr::copy_nonoverlapping_memory(*other.ptr,\n-                                                second_half.as_ptr().offset(offset as isize),\n-                                                amount_in_second);\n+                ptr::copy_nonoverlapping(*other.ptr,\n+                                         second_half.as_ptr().offset(offset as isize),\n+                                         amount_in_second);\n             }\n         }\n \n@@ -1754,7 +1754,7 @@ impl<A> Extend<A> for VecDeque<A> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: fmt::Debug> fmt::Debug for VecDeque<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(f, \"VecDeque [\"));\n+        try!(write!(f, \"[\"));\n \n         for (i, e) in self.iter().enumerate() {\n             if i != 0 { try!(write!(f, \", \")); }\n@@ -2105,7 +2105,7 @@ mod tests {\n         let mut d: VecDeque<_> = (0..5).collect();\n         d.pop_front();\n         d.swap(0, 3);\n-        assert_eq!(d.iter().cloned().collect::<Vec<_>>(), vec!(4, 2, 3, 1));\n+        assert_eq!(d.iter().cloned().collect::<Vec<_>>(), [4, 2, 3, 1]);\n     }\n \n     #[test]\n@@ -2435,12 +2435,12 @@ mod tests {\n     #[test]\n     fn test_show() {\n         let ringbuf: VecDeque<_> = (0..10).collect();\n-        assert_eq!(format!(\"{:?}\", ringbuf), \"VecDeque [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\");\n+        assert_eq!(format!(\"{:?}\", ringbuf), \"[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\");\n \n         let ringbuf: VecDeque<_> = vec![\"just\", \"one\", \"test\", \"more\"].iter()\n                                                                         .cloned()\n                                                                         .collect();\n-        assert_eq!(format!(\"{:?}\", ringbuf), \"VecDeque [\\\"just\\\", \\\"one\\\", \\\"test\\\", \\\"more\\\"]\");\n+        assert_eq!(format!(\"{:?}\", ringbuf), \"[\\\"just\\\", \\\"one\\\", \\\"test\\\", \\\"more\\\"]\");\n     }\n \n     #[test]\n@@ -2868,17 +2868,17 @@ mod tests {\n \n         // normal append\n         a.append(&mut b);\n-        assert_eq!(a.iter().cloned().collect(), vec![1, 2, 3, 4, 5, 6]);\n-        assert_eq!(b.iter().cloned().collect(), vec![]);\n+        assert_eq!(a.iter().cloned().collect::<Vec<_>>(), [1, 2, 3, 4, 5, 6]);\n+        assert_eq!(b.iter().cloned().collect::<Vec<_>>(), []);\n \n         // append nothing to something\n         a.append(&mut b);\n-        assert_eq!(a.iter().cloned().collect(), vec![1, 2, 3, 4, 5, 6]);\n-        assert_eq!(b.iter().cloned().collect(), vec![]);\n+        assert_eq!(a.iter().cloned().collect::<Vec<_>>(), [1, 2, 3, 4, 5, 6]);\n+        assert_eq!(b.iter().cloned().collect::<Vec<_>>(), []);\n \n         // append something to nothing\n         b.append(&mut a);\n-        assert_eq!(b.iter().cloned().collect(), vec![1, 2, 3, 4, 5, 6]);\n-        assert_eq!(a.iter().cloned().collect(), vec![]);\n+        assert_eq!(b.iter().cloned().collect::<Vec<_>>(), [1, 2, 3, 4, 5, 6]);\n+        assert_eq!(a.iter().cloned().collect::<Vec<_>>(), []);\n     }\n }"}, {"sha": "5a0aa750bf5670dc1a569ca9f9c5e9715c17c884", "filename": "src/libcollections/vec_map.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibcollections%2Fvec_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibcollections%2Fvec_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Fvec_map.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -308,7 +308,7 @@ impl<V> VecMap<V> {\n     ///\n     /// let vec: Vec<(usize, &str)> = map.into_iter().collect();\n     ///\n-    /// assert_eq!(vec, vec![(1, \"a\"), (2, \"b\"), (3, \"c\")]);\n+    /// assert_eq!(vec, [(1, \"a\"), (2, \"b\"), (3, \"c\")]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn into_iter(self) -> IntoIter<V> {\n@@ -425,7 +425,7 @@ impl<V> VecMap<V> {\n     ///\n     /// let vec: Vec<(usize, &str)> = map.drain().collect();\n     ///\n-    /// assert_eq!(vec, vec![(1, \"a\"), (2, \"b\"), (3, \"c\")]);\n+    /// assert_eq!(vec, [(1, \"a\"), (2, \"b\"), (3, \"c\")]);\n     /// ```\n     #[unstable(feature = \"collections\",\n                reason = \"matches collection reform specification, waiting for dust to settle\")]\n@@ -739,7 +739,7 @@ impl<V: Ord> Ord for VecMap<V> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<V: fmt::Debug> fmt::Debug for VecMap<V> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(f, \"VecMap {{\"));\n+        try!(write!(f, \"{{\"));\n \n         for (i, (k, v)) in self.iter().enumerate() {\n             if i != 0 { try!(write!(f, \", \")); }\n@@ -1226,7 +1226,7 @@ mod test_map {\n \n         let vec: Vec<_> = map.drain().collect();\n \n-        assert_eq!(vec, vec![(1, \"a\"), (2, \"b\"), (3, \"c\")]);\n+        assert_eq!(vec, [(1, \"a\"), (2, \"b\"), (3, \"c\")]);\n         assert_eq!(map.len(), 0);\n     }\n \n@@ -1318,8 +1318,8 @@ mod test_map {\n         map.insert(3, 4);\n \n         let map_str = format!(\"{:?}\", map);\n-        assert!(map_str == \"VecMap {1: 2, 3: 4}\" || map_str == \"{3: 4, 1: 2}\");\n-        assert_eq!(format!(\"{:?}\", empty), \"VecMap {}\");\n+        assert!(map_str == \"{1: 2, 3: 4}\" || map_str == \"{3: 4, 1: 2}\");\n+        assert_eq!(format!(\"{:?}\", empty), \"{}\");\n     }\n \n     #[test]"}, {"sha": "e7af0be88a0859bae60fa9c76f5d02040151667c", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -293,7 +293,7 @@ extern \"rust-intrinsic\" {\n     ///     }\n     /// }\n     /// ```\n-    #[unstable(feature = \"core\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn copy_nonoverlapping_memory<T>(dst: *mut T, src: *const T, count: usize);\n \n     /// Copies `count * size_of<T>` bytes from `src` to `dst`. The source\n@@ -323,13 +323,12 @@ extern \"rust-intrinsic\" {\n     /// }\n     /// ```\n     ///\n-    #[unstable(feature = \"core\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn copy_memory<T>(dst: *mut T, src: *const T, count: usize);\n \n     /// Invokes memset on the specified pointer, setting `count * size_of::<T>()`\n     /// bytes of memory starting at `dst` to `c`.\n-    #[unstable(feature = \"core\",\n-               reason = \"uncertain about naming and semantics\")]\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn set_memory<T>(dst: *mut T, val: u8, count: usize);\n \n     /// Equivalent to the appropriate `llvm.memcpy.p0i8.0i8.*` intrinsic, with"}, {"sha": "b4ccf93043729072b2df6861fb4cebd65ab8a699", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -582,8 +582,8 @@ pub trait IteratorExt: Iterator + Sized {\n     /// ```\n     /// let vec = vec![1, 2, 3, 4];\n     /// let (even, odd): (Vec<_>, Vec<_>) = vec.into_iter().partition(|&n| n % 2 == 0);\n-    /// assert_eq!(even, vec![2, 4]);\n-    /// assert_eq!(odd, vec![1, 3]);\n+    /// assert_eq!(even, [2, 4]);\n+    /// assert_eq!(odd, [1, 3]);\n     /// ```\n     #[unstable(feature = \"core\",\n                reason = \"recently added as part of collections reform\")]"}, {"sha": "2aa8ec0c548d958b4c20eeb8b57ca68908b469fb", "filename": "src/libcore/mem.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -203,9 +203,9 @@ pub fn swap<T>(x: &mut T, y: &mut T) {\n         let mut t: T = uninitialized();\n \n         // Perform the swap, `&mut` pointers never alias\n-        ptr::copy_nonoverlapping_memory(&mut t, &*x, 1);\n-        ptr::copy_nonoverlapping_memory(x, &*y, 1);\n-        ptr::copy_nonoverlapping_memory(y, &t, 1);\n+        ptr::copy_nonoverlapping(&mut t, &*x, 1);\n+        ptr::copy_nonoverlapping(x, &*y, 1);\n+        ptr::copy_nonoverlapping(y, &t, 1);\n \n         // y and t now point to the same thing, but we need to completely forget `t`\n         // because it's no longer relevant."}, {"sha": "b1039f79f23de1989343683d2d4cc99cd528a906", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -1672,6 +1672,7 @@ macro_rules! from_str_radix_int_impl {\n                 let is_signed_ty = (0 as $T) > Int::min_value();\n \n                 match src.slice_shift_char() {\n+                    Some(('-', \"\")) => Err(PIE { kind: Empty }),\n                     Some(('-', src)) if is_signed_ty => {\n                         // The number is negative\n                         let mut result = 0;"}, {"sha": "1ecbd8fae8cdb664b5f9549a358ea6c7cb7b7b01", "filename": "src/libcore/option.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -556,7 +556,7 @@ impl<T> Option<T> {\n     /// ```\n     /// let x = Some(\"string\");\n     /// let v: Vec<&str> = x.into_iter().collect();\n-    /// assert_eq!(v, vec![\"string\"]);\n+    /// assert_eq!(v, [\"string\"]);\n     ///\n     /// let x = None;\n     /// let v: Vec<&str> = x.into_iter().collect();"}, {"sha": "0625c3c7d6018e26d4e36f2c0a43246cd6794d88", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 56, "deletions": 53, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -101,16 +101,28 @@ use cmp::Ordering::{self, Less, Equal, Greater};\n \n // FIXME #19649: intrinsic docs don't render, so these have no docs :(\n \n-#[unstable(feature = \"core\")]\n-pub use intrinsics::copy_nonoverlapping_memory;\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use intrinsics::copy_nonoverlapping_memory as copy_nonoverlapping;\n \n-#[unstable(feature = \"core\")]\n-pub use intrinsics::copy_memory;\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use intrinsics::copy_memory as copy;\n \n-#[unstable(feature = \"core\",\n-           reason = \"uncertain about naming and semantics\")]\n-pub use intrinsics::set_memory;\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+pub use intrinsics::set_memory as write_bytes;\n \n+extern \"rust-intrinsic\" {\n+    #[unstable(feature = \"core\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"renamed to `copy_nonoverlapping`\")]\n+    pub fn copy_nonoverlapping_memory<T>(dst: *mut T, src: *const T, count: usize);\n+    #[unstable(feature = \"core\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"renamed to `copy`\")]\n+    pub fn copy_memory<T>(dst: *mut T, src: *const T, count: usize);\n+\n+    #[unstable(feature = \"core\",\n+               reason = \"uncertain about naming and semantics\")]\n+    #[deprecated(since = \"1.0.0\", reason = \"renamed to `write_bytes`\")]\n+    pub fn set_memory<T>(dst: *mut T, val: u8, count: usize);\n+}\n \n /// Creates a null raw pointer.\n ///\n@@ -150,8 +162,9 @@ pub fn null_mut<T>() -> *mut T { 0 as *mut T }\n #[inline]\n #[unstable(feature = \"core\",\n            reason = \"may play a larger role in std::ptr future extensions\")]\n+#[deprecated(since = \"1.0.0\", reason = \"use `write_bytes` instead\")]\n pub unsafe fn zero_memory<T>(dst: *mut T, count: usize) {\n-    set_memory(dst, 0, count);\n+    write_bytes(dst, 0, count);\n }\n \n /// Swaps the values at two mutable locations of the same type, without\n@@ -169,9 +182,9 @@ pub unsafe fn swap<T>(x: *mut T, y: *mut T) {\n     let t: *mut T = &mut tmp;\n \n     // Perform the swap\n-    copy_nonoverlapping_memory(t, &*x, 1);\n-    copy_memory(x, &*y, 1); // `x` and `y` may overlap\n-    copy_nonoverlapping_memory(y, &*t, 1);\n+    copy_nonoverlapping(t, &*x, 1);\n+    copy(x, &*y, 1); // `x` and `y` may overlap\n+    copy_nonoverlapping(y, &*t, 1);\n \n     // y and t now point to the same thing, but we need to completely forget `tmp`\n     // because it's no longer relevant.\n@@ -207,7 +220,7 @@ pub unsafe fn replace<T>(dest: *mut T, mut src: T) -> T {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub unsafe fn read<T>(src: *const T) -> T {\n     let mut tmp: T = mem::uninitialized();\n-    copy_nonoverlapping_memory(&mut tmp, src, 1);\n+    copy_nonoverlapping(&mut tmp, src, 1);\n     tmp\n }\n \n@@ -224,7 +237,7 @@ pub unsafe fn read_and_zero<T>(dest: *mut T) -> T {\n     let tmp = read(&*dest);\n \n     // Now zero out `dest`:\n-    zero_memory(dest, 1);\n+    write_bytes(dest, 0, 1);\n \n     tmp\n }\n@@ -248,9 +261,9 @@ pub unsafe fn write<T>(dst: *mut T, src: T) {\n \n /// Methods on raw pointers\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub trait PtrExt: Sized {\n+pub trait PtrExt {\n     /// The type which is being pointed at\n-    type Target;\n+    type Target: ?Sized;\n \n     /// Returns true if the pointer is null.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -279,14 +292,14 @@ pub trait PtrExt: Sized {\n     /// Otherwise `offset` invokes Undefined Behaviour, regardless of whether\n     /// the pointer is used.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    unsafe fn offset(self, count: isize) -> Self;\n+    unsafe fn offset(self, count: isize) -> Self where Self::Target: Sized;\n }\n \n /// Methods on mutable raw pointers\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait MutPtrExt {\n     /// The type which is being pointed at\n-    type Target;\n+    type Target: ?Sized;\n \n     /// Returns `None` if the pointer is null, or else returns a mutable\n     /// reference to the value wrapped in `Some`.\n@@ -302,7 +315,7 @@ pub trait MutPtrExt {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> PtrExt for *const T {\n+impl<T: ?Sized> PtrExt for *const T {\n     type Target = T;\n \n     #[inline]\n@@ -311,7 +324,7 @@ impl<T> PtrExt for *const T {\n \n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    unsafe fn offset(self, count: isize) -> *const T {\n+    unsafe fn offset(self, count: isize) -> *const T where T: Sized {\n         intrinsics::offset(self, count)\n     }\n \n@@ -329,7 +342,7 @@ impl<T> PtrExt for *const T {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> PtrExt for *mut T {\n+impl<T: ?Sized> PtrExt for *mut T {\n     type Target = T;\n \n     #[inline]\n@@ -338,7 +351,7 @@ impl<T> PtrExt for *mut T {\n \n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    unsafe fn offset(self, count: isize) -> *mut T {\n+    unsafe fn offset(self, count: isize) -> *mut T where T: Sized {\n         intrinsics::offset(self, count) as *mut T\n     }\n \n@@ -356,7 +369,7 @@ impl<T> PtrExt for *mut T {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> MutPtrExt for *mut T {\n+impl<T: ?Sized> MutPtrExt for *mut T {\n     type Target = T;\n \n     #[inline]\n@@ -374,41 +387,33 @@ impl<T> MutPtrExt for *mut T {\n \n // Equality for pointers\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> PartialEq for *const T {\n+impl<T: ?Sized> PartialEq for *const T {\n     #[inline]\n-    fn eq(&self, other: &*const T) -> bool {\n-        *self == *other\n-    }\n-    #[inline]\n-    fn ne(&self, other: &*const T) -> bool { !self.eq(other) }\n+    fn eq(&self, other: &*const T) -> bool { *self == *other }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> Eq for *const T {}\n+impl<T: ?Sized> Eq for *const T {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> PartialEq for *mut T {\n-    #[inline]\n-    fn eq(&self, other: &*mut T) -> bool {\n-        *self == *other\n-    }\n+impl<T: ?Sized> PartialEq for *mut T {\n     #[inline]\n-    fn ne(&self, other: &*mut T) -> bool { !self.eq(other) }\n+    fn eq(&self, other: &*mut T) -> bool { *self == *other }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> Eq for *mut T {}\n+impl<T: ?Sized> Eq for *mut T {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> Clone for *const T {\n+impl<T: ?Sized> Clone for *const T {\n     #[inline]\n     fn clone(&self) -> *const T {\n         *self\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> Clone for *mut T {\n+impl<T: ?Sized> Clone for *mut T {\n     #[inline]\n     fn clone(&self) -> *mut T {\n         *self\n@@ -452,7 +457,7 @@ mod externfnpointers {\n \n // Comparison for pointers\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> Ord for *const T {\n+impl<T: ?Sized> Ord for *const T {\n     #[inline]\n     fn cmp(&self, other: &*const T) -> Ordering {\n         if self < other {\n@@ -466,7 +471,7 @@ impl<T> Ord for *const T {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> PartialOrd for *const T {\n+impl<T: ?Sized> PartialOrd for *const T {\n     #[inline]\n     fn partial_cmp(&self, other: &*const T) -> Option<Ordering> {\n         Some(self.cmp(other))\n@@ -486,7 +491,7 @@ impl<T> PartialOrd for *const T {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> Ord for *mut T {\n+impl<T: ?Sized> Ord for *mut T {\n     #[inline]\n     fn cmp(&self, other: &*mut T) -> Ordering {\n         if self < other {\n@@ -500,7 +505,7 @@ impl<T> Ord for *mut T {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> PartialOrd for *mut T {\n+impl<T: ?Sized> PartialOrd for *mut T {\n     #[inline]\n     fn partial_cmp(&self, other: &*mut T) -> Option<Ordering> {\n         Some(self.cmp(other))\n@@ -527,8 +532,8 @@ impl<T> PartialOrd for *mut T {\n /// modified without a unique path to the `Unique` reference. Useful\n /// for building abstractions like `Vec<T>` or `Box<T>`, which\n /// internally use raw pointers to manage the memory that they own.\n-#[unstable(feature = \"core\", reason = \"recently added to this module\")]\n-pub struct Unique<T:?Sized> {\n+#[unstable(feature = \"unique\")]\n+pub struct Unique<T: ?Sized> {\n     pointer: NonZero<*const T>,\n     _marker: PhantomData<T>,\n }\n@@ -537,39 +542,37 @@ pub struct Unique<T:?Sized> {\n /// reference is unaliased. Note that this aliasing invariant is\n /// unenforced by the type system; the abstraction using the\n /// `Unique` must enforce it.\n-#[unstable(feature = \"core\", reason = \"recently added to this module\")]\n+#[unstable(feature = \"unique\")]\n unsafe impl<T: Send + ?Sized> Send for Unique<T> { }\n \n /// `Unique` pointers are `Sync` if `T` is `Sync` because the data they\n /// reference is unaliased. Note that this aliasing invariant is\n /// unenforced by the type system; the abstraction using the\n /// `Unique` must enforce it.\n-#[unstable(feature = \"core\", reason = \"recently added to this module\")]\n+#[unstable(feature = \"unique\")]\n unsafe impl<T: Sync + ?Sized> Sync for Unique<T> { }\n \n-impl<T:?Sized> Unique<T> {\n+impl<T: ?Sized> Unique<T> {\n     /// Create a new `Unique`.\n-    #[unstable(feature = \"core\",\n-               reason = \"recently added to this module\")]\n+    #[unstable(feature = \"unique\")]\n     pub unsafe fn new(ptr: *mut T) -> Unique<T> {\n         Unique { pointer: NonZero::new(ptr as *const T), _marker: PhantomData }\n     }\n \n     /// Dereference the content.\n-    #[unstable(feature = \"core\",\n-               reason = \"recently added to this module\")]\n+    #[unstable(feature = \"unique\")]\n     pub unsafe fn get(&self) -> &T {\n         &**self.pointer\n     }\n \n     /// Mutably dereference the content.\n-    #[unstable(feature = \"core\",\n-               reason = \"recently added to this module\")]\n+    #[unstable(feature = \"unique\")]\n     pub unsafe fn get_mut(&mut self) -> &mut T {\n         &mut ***self\n     }\n }\n \n+#[unstable(feature = \"unique\")]\n impl<T:?Sized> Deref for Unique<T> {\n     type Target = *mut T;\n "}, {"sha": "bca73782491bf5fe30571f61665babdbf2163767", "filename": "src/libcore/result.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -548,11 +548,11 @@ impl<T, E> Result<T, E> {\n     /// ```\n     /// let x: Result<u32, &str> = Ok(5);\n     /// let v: Vec<u32> = x.into_iter().collect();\n-    /// assert_eq!(v, vec![5]);\n+    /// assert_eq!(v, [5]);\n     ///\n     /// let x: Result<u32, &str> = Err(\"nothing!\");\n     /// let v: Vec<u32> = x.into_iter().collect();\n-    /// assert_eq!(v, vec![]);\n+    /// assert_eq!(v, []);\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "ae64a57a390f8938b1817ab71597342ad7a3cfef", "filename": "src/libcore/slice.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibcore%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibcore%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -1500,7 +1500,7 @@ pub mod bytes {\n     impl MutableByteVector for [u8] {\n         #[inline]\n         fn set_memory(&mut self, value: u8) {\n-            unsafe { ptr::set_memory(self.as_mut_ptr(), value, self.len()) };\n+            unsafe { ptr::write_bytes(self.as_mut_ptr(), value, self.len()) };\n         }\n     }\n \n@@ -1514,9 +1514,9 @@ pub mod bytes {\n         // `dst` is unaliasable, so we know statically it doesn't overlap\n         // with `src`.\n         unsafe {\n-            ptr::copy_nonoverlapping_memory(dst.as_mut_ptr(),\n-                                            src.as_ptr(),\n-                                            len_src);\n+            ptr::copy_nonoverlapping(dst.as_mut_ptr(),\n+                                     src.as_ptr(),\n+                                     len_src);\n         }\n     }\n }"}, {"sha": "8a27400389f4ada601d595879b3b0ed651c46ff4", "filename": "src/libcoretest/iter.rs", "status": "modified", "additions": 21, "deletions": 32, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibcoretest%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibcoretest%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fiter.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -74,7 +74,7 @@ fn test_multi_iter() {\n fn test_counter_from_iter() {\n     let it = count(0, 5).take(10);\n     let xs: Vec<int> = FromIterator::from_iter(it);\n-    assert!(xs == vec![0, 5, 10, 15, 20, 25, 30, 35, 40, 45]);\n+    assert_eq!(xs, [0, 5, 10, 15, 20, 25, 30, 35, 40, 45]);\n }\n \n #[test]\n@@ -104,7 +104,7 @@ fn test_iterator_chain() {\n fn test_filter_map() {\n     let it = count(0, 1).take(10)\n         .filter_map(|x| if x % 2 == 0 { Some(x*x) } else { None });\n-    assert!(it.collect::<Vec<uint>>() == vec![0*0, 2*2, 4*4, 6*6, 8*8]);\n+    assert_eq!(it.collect::<Vec<uint>>(), [0*0, 2*2, 4*4, 6*6, 8*8]);\n }\n \n #[test]\n@@ -730,23 +730,22 @@ fn test_random_access_cycle() {\n \n #[test]\n fn test_double_ended_range() {\n-    assert!((11..14).rev().collect::<Vec<_>>() == vec![13, 12, 11]);\n+    assert_eq!((11..14).rev().collect::<Vec<_>>(), [13, 12, 11]);\n     for _ in (10..0).rev() {\n         panic!(\"unreachable\");\n     }\n \n-    assert!((11..14).rev().collect::<Vec<_>>() == vec![13, 12, 11]);\n+    assert_eq!((11..14).rev().collect::<Vec<_>>(), [13, 12, 11]);\n     for _ in (10..0).rev() {\n         panic!(\"unreachable\");\n     }\n }\n \n #[test]\n fn test_range() {\n-    assert!((0..5).collect::<Vec<_>>() == vec![0, 1, 2, 3, 4]);\n-    assert!((-10..-1).collect::<Vec<_>>() ==\n-               vec![-10, -9, -8, -7, -6, -5, -4, -3, -2]);\n-    assert!((0..5).rev().collect::<Vec<_>>() == vec![4, 3, 2, 1, 0]);\n+    assert_eq!((0..5).collect::<Vec<_>>(), [0, 1, 2, 3, 4]);\n+    assert_eq!((-10..-1).collect::<Vec<_>>(), [-10, -9, -8, -7, -6, -5, -4, -3, -2]);\n+    assert_eq!((0..5).rev().collect::<Vec<_>>(), [4, 3, 2, 1, 0]);\n     assert_eq!((200..-5).count(), 0);\n     assert_eq!((200..-5).rev().count(), 0);\n     assert_eq!((200..200).count(), 0);\n@@ -767,38 +766,28 @@ fn test_range_inclusive() {\n             vec![5, 4, 3, 2, 1, 0]);\n     assert_eq!(range_inclusive(200, -5).count(), 0);\n     assert_eq!(range_inclusive(200, -5).rev().count(), 0);\n-    assert!(range_inclusive(200, 200).collect::<Vec<int>>() == vec![200]);\n-    assert!(range_inclusive(200, 200).rev().collect::<Vec<int>>() == vec![200]);\n+    assert_eq!(range_inclusive(200, 200).collect::<Vec<int>>(), [200]);\n+    assert_eq!(range_inclusive(200, 200).rev().collect::<Vec<int>>(), [200]);\n }\n \n #[test]\n fn test_range_step() {\n-    assert!(range_step(0, 20, 5).collect::<Vec<int>>() ==\n-            vec![0, 5, 10, 15]);\n-    assert!(range_step(20, 0, -5).collect::<Vec<int>>() ==\n-            vec![20, 15, 10, 5]);\n-    assert!(range_step(20, 0, -6).collect::<Vec<int>>() ==\n-            vec![20, 14, 8, 2]);\n-    assert!(range_step(200u8, 255, 50).collect::<Vec<u8>>() ==\n-            vec![200u8, 250]);\n-    assert!(range_step(200, -5, 1).collect::<Vec<int>>() == vec![]);\n-    assert!(range_step(200, 200, 1).collect::<Vec<int>>() == vec![]);\n+    assert_eq!(range_step(0, 20, 5).collect::<Vec<int>>(), [0, 5, 10, 15]);\n+    assert_eq!(range_step(20, 0, -5).collect::<Vec<int>>(), [20, 15, 10, 5]);\n+    assert_eq!(range_step(20, 0, -6).collect::<Vec<int>>(), [20, 14, 8, 2]);\n+    assert_eq!(range_step(200u8, 255, 50).collect::<Vec<u8>>(), [200u8, 250]);\n+    assert_eq!(range_step(200i, -5, 1).collect::<Vec<int>>(), []);\n+    assert_eq!(range_step(200i, 200, 1).collect::<Vec<int>>(), []);\n }\n \n #[test]\n fn test_range_step_inclusive() {\n-    assert!(range_step_inclusive(0, 20, 5).collect::<Vec<int>>() ==\n-            vec![0, 5, 10, 15, 20]);\n-    assert!(range_step_inclusive(20, 0, -5).collect::<Vec<int>>() ==\n-            vec![20, 15, 10, 5, 0]);\n-    assert!(range_step_inclusive(20, 0, -6).collect::<Vec<int>>() ==\n-            vec![20, 14, 8, 2]);\n-    assert!(range_step_inclusive(200u8, 255, 50).collect::<Vec<u8>>() ==\n-            vec![200u8, 250]);\n-    assert!(range_step_inclusive(200, -5, 1).collect::<Vec<int>>() ==\n-            vec![]);\n-    assert!(range_step_inclusive(200, 200, 1).collect::<Vec<int>>() ==\n-            vec![200]);\n+    assert_eq!(range_step_inclusive(0, 20, 5).collect::<Vec<int>>(), [0, 5, 10, 15, 20]);\n+    assert_eq!(range_step_inclusive(20, 0, -5).collect::<Vec<int>>(), [20, 15, 10, 5, 0]);\n+    assert_eq!(range_step_inclusive(20, 0, -6).collect::<Vec<int>>(), [20, 14, 8, 2]);\n+    assert_eq!(range_step_inclusive(200u8, 255, 50).collect::<Vec<u8>>(), [200u8, 250]);\n+    assert_eq!(range_step_inclusive(200, -5, 1).collect::<Vec<int>>(), []);\n+    assert_eq!(range_step_inclusive(200, 200, 1).collect::<Vec<int>>(), [200]);\n }\n \n #[test]"}, {"sha": "73000670c61aa839e975fb39829b45eb39be2789", "filename": "src/libcoretest/mem.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibcoretest%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibcoretest%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fmem.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -103,7 +103,7 @@ fn test_transmute() {\n     }\n \n     unsafe {\n-        assert!(vec![76u8] == transmute::<_, Vec<u8>>(\"L\".to_string()));\n+        assert_eq!([76u8], transmute::<_, Vec<u8>>(\"L\".to_string()));\n     }\n }\n "}, {"sha": "f60570eaaf417941f4e54b4cf6beb5b60f5b8dc2", "filename": "src/libcoretest/nonzero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibcoretest%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibcoretest%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnonzero.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -54,7 +54,7 @@ fn test_match_option_empty_vec() {\n fn test_match_option_vec() {\n     let a = Some(vec![1, 2, 3, 4]);\n     match a {\n-        Some(v) => assert_eq!(v, vec![1, 2, 3, 4]),\n+        Some(v) => assert_eq!(v, [1, 2, 3, 4]),\n         None => panic!(\"unexpected None while matching on Some(vec![1, 2, 3, 4])\")\n     }\n }"}, {"sha": "03f6e51a3498a4c72f1ce88639172695add9b5cc", "filename": "src/libcoretest/num/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibcoretest%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibcoretest%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fnum%2Fmod.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -122,4 +122,9 @@ mod test {\n         assert_eq!(\"-9223372036854775808\".parse::<i64>().ok(), Some(i64_val));\n         assert_eq!(\"-9223372036854775809\".parse::<i64>().ok(), None);\n     }\n+\n+    #[test]\n+    fn test_int_from_minus_sign() {\n+        assert_eq!(\"-\".parse::<i32>().ok(), None);\n+    }\n }"}, {"sha": "c8a54ef59abda2c0676e72bd196db6090ae220c8", "filename": "src/libcoretest/ptr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibcoretest%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibcoretest%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fptr.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -156,7 +156,7 @@ fn test_ptr_subtraction() {\n             m_ptr = m_ptr.offset(-1);\n         }\n \n-        assert!(xs_mut == vec![0,2,4,6,8,10,12,14,16,18]);\n+        assert_eq!(xs_mut, [0,2,4,6,8,10,12,14,16,18]);\n     }\n }\n "}, {"sha": "019f935911f7a78315f834be60b88c8928835c13", "filename": "src/libcoretest/str.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibcoretest%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibcoretest%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fstr.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -22,7 +22,7 @@ fn test_pattern_deref_forward() {\n fn test_empty_match_indices() {\n     let data = \"a\u00e4\u4e2d!\";\n     let vec: Vec<_> = data.match_indices(\"\").collect();\n-    assert_eq!(vec, vec![(0, 0), (1, 1), (3, 3), (6, 6), (7, 7)]);\n+    assert_eq!(vec, [(0, 0), (1, 1), (3, 3), (6, 6), (7, 7)]);\n }\n \n #[test]\n@@ -69,54 +69,54 @@ fn test_rsplitn_char_iterator() {\n \n     let mut split: Vec<&str> = data.rsplitn(3, ' ').collect();\n     split.reverse();\n-    assert_eq!(split, vec![\"\\nM\u00e4ry h\u00e4d \u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n+    assert_eq!(split, [\"\\nM\u00e4ry h\u00e4d \u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n \n     let mut split: Vec<&str> = data.rsplitn(3, |c: char| c == ' ').collect();\n     split.reverse();\n-    assert_eq!(split, vec![\"\\nM\u00e4ry h\u00e4d \u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n+    assert_eq!(split, [\"\\nM\u00e4ry h\u00e4d \u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n \n     // Unicode\n     let mut split: Vec<&str> = data.rsplitn(3, '\u00e4').collect();\n     split.reverse();\n-    assert_eq!(split, vec![\"\\nM\u00e4ry h\u00e4d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n+    assert_eq!(split, [\"\\nM\u00e4ry h\u00e4d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n \n     let mut split: Vec<&str> = data.rsplitn(3, |c: char| c == '\u00e4').collect();\n     split.reverse();\n-    assert_eq!(split, vec![\"\\nM\u00e4ry h\u00e4d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n+    assert_eq!(split, [\"\\nM\u00e4ry h\u00e4d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n }\n \n #[test]\n fn test_split_char_iterator() {\n     let data = \"\\nM\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\\nLittle l\u00e4mb\\n\";\n \n     let split: Vec<&str> = data.split(' ').collect();\n-    assert_eq!( split, vec![\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n+    assert_eq!( split, [\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n \n     let mut rsplit: Vec<&str> = data.split(' ').rev().collect();\n     rsplit.reverse();\n-    assert_eq!(rsplit, vec![\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n+    assert_eq!(rsplit, [\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n \n     let split: Vec<&str> = data.split(|c: char| c == ' ').collect();\n-    assert_eq!( split, vec![\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n+    assert_eq!( split, [\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n \n     let mut rsplit: Vec<&str> = data.split(|c: char| c == ' ').rev().collect();\n     rsplit.reverse();\n-    assert_eq!(rsplit, vec![\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n+    assert_eq!(rsplit, [\"\\nM\u00e4ry\", \"h\u00e4d\", \"\u00e4\", \"little\", \"l\u00e4mb\\nLittle\", \"l\u00e4mb\\n\"]);\n \n     // Unicode\n     let split: Vec<&str> = data.split('\u00e4').collect();\n-    assert_eq!( split, vec![\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n+    assert_eq!( split, [\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n \n     let mut rsplit: Vec<&str> = data.split('\u00e4').rev().collect();\n     rsplit.reverse();\n-    assert_eq!(rsplit, vec![\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n+    assert_eq!(rsplit, [\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n \n     let split: Vec<&str> = data.split(|c: char| c == '\u00e4').collect();\n-    assert_eq!( split, vec![\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n+    assert_eq!( split, [\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n \n     let mut rsplit: Vec<&str> = data.split(|c: char| c == '\u00e4').rev().collect();\n     rsplit.reverse();\n-    assert_eq!(rsplit, vec![\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n+    assert_eq!(rsplit, [\"\\nM\", \"ry h\", \"d \", \" little l\", \"mb\\nLittle l\", \"mb\\n\"]);\n }\n \n #[test]\n@@ -125,18 +125,18 @@ fn test_rev_split_char_iterator_no_trailing() {\n \n     let mut split: Vec<&str> = data.split('\\n').rev().collect();\n     split.reverse();\n-    assert_eq!(split, vec![\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"Little l\u00e4mb\", \"\"]);\n+    assert_eq!(split, [\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"Little l\u00e4mb\", \"\"]);\n \n     let mut split: Vec<&str> = data.split_terminator('\\n').rev().collect();\n     split.reverse();\n-    assert_eq!(split, vec![\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"Little l\u00e4mb\"]);\n+    assert_eq!(split, [\"\", \"M\u00e4ry h\u00e4d \u00e4 little l\u00e4mb\", \"Little l\u00e4mb\"]);\n }\n \n #[test]\n fn test_utf16_code_units() {\n     use unicode::str::Utf16Encoder;\n     assert_eq!(Utf16Encoder::new(vec!['\u00e9', '\\u{1F4A9}'].into_iter()).collect::<Vec<u16>>(),\n-               vec![0xE9, 0xD83D, 0xDCA9])\n+               [0xE9, 0xD83D, 0xDCA9])\n }\n \n #[test]"}, {"sha": "2ce52cdec2560a92ee1e32559e2ae4392b73e37e", "filename": "src/libflate/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibflate%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibflate%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibflate%2Flib.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -27,6 +27,7 @@\n #![feature(int_uint)]\n #![feature(libc)]\n #![feature(staged_api)]\n+#![feature(unique)]\n \n #[cfg(test)] #[macro_use] extern crate log;\n "}, {"sha": "74a95b3aba056cdd194a1637b1950d5f5ba5bafa", "filename": "src/liblibc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Fliblibc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Fliblibc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliblibc%2Flib.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -1362,7 +1362,6 @@ pub mod types {\n                 use types::os::arch::c95::{c_long};\n                 pub type off_t = i64;\n                 pub type dev_t = i32;\n-                pub type ino_t = u64;\n                 pub type pid_t = i32;\n                 pub type uid_t = u32;\n                 pub type gid_t = u32;"}, {"sha": "c52465a889907b57c4357f19d4a801677ab8b6c5", "filename": "src/librbml/io.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibrbml%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibrbml%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Fio.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -45,7 +45,7 @@ fn combine(seek: SeekStyle, cur: uint, end: uint, offset: i64) -> IoResult<u64>\n /// let mut w = SeekableMemWriter::new();\n /// w.write(&[0, 1, 2]);\n ///\n-/// assert_eq!(w.unwrap(), vec!(0, 1, 2));\n+/// assert_eq!(w.unwrap(), [0, 1, 2]);\n /// ```\n pub struct SeekableMemWriter {\n     buf: Vec<u8>,"}, {"sha": "26cb4f917c5669d5114364f506625fc1476043bc", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -40,6 +40,7 @@\n #![feature(staged_api)]\n #![feature(std_misc)]\n #![feature(unicode)]\n+#![feature(os)]\n #![cfg_attr(test, feature(test))]\n \n extern crate arena;"}, {"sha": "a4f69e651df60a9e1738c4034d9018f12417b40f", "filename": "src/librustc/lint/builtin.rs", "status": "modified", "additions": 22, "deletions": 32, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibrustc%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibrustc%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fbuiltin.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -1295,46 +1295,36 @@ impl LintPass for UnsafeCode {\n     }\n \n     fn check_item(&mut self, cx: &Context, it: &ast::Item) {\n-        use syntax::ast::Unsafety::Unsafe;\n-\n-        fn check_method(cx: &Context, meth: &P<ast::Method>) {\n-            if let ast::Method_::MethDecl(_, _, _, _, Unsafe, _, _, _) = meth.node {\n-                cx.span_lint(UNSAFE_CODE, meth.span, \"implementation of an `unsafe` method\");\n-            }\n-        }\n-\n         match it.node {\n-            ast::ItemFn(_, Unsafe, _, _, _) =>\n-                cx.span_lint(UNSAFE_CODE, it.span, \"declaration of an `unsafe` function\"),\n+            ast::ItemTrait(ast::Unsafety::Unsafe, _, _, _) =>\n+                cx.span_lint(UNSAFE_CODE, it.span, \"declaration of an `unsafe` trait\"),\n \n-            ast::ItemTrait(trait_safety, _, _, ref items) => {\n-                if trait_safety == Unsafe {\n-                    cx.span_lint(UNSAFE_CODE, it.span, \"declaration of an `unsafe` trait\");\n-                }\n+            ast::ItemImpl(ast::Unsafety::Unsafe, _, _, _, _, _) =>\n+                cx.span_lint(UNSAFE_CODE, it.span, \"implementation of an `unsafe` trait\"),\n \n-                for it in items {\n-                    match *it {\n-                        ast::RequiredMethod(ast::TypeMethod { unsafety: Unsafe, span, ..}) =>\n-                            cx.span_lint(UNSAFE_CODE, span, \"declaration of an `unsafe` method\"),\n-                        ast::ProvidedMethod(ref meth) => check_method(cx, meth),\n-                        _ => (),\n-                    }\n-                }\n-            },\n+            _ => return,\n+        }\n+    }\n \n-            ast::ItemImpl(impl_safety, _, _, _, _, ref impls) => {\n-                if impl_safety == Unsafe {\n-                    cx.span_lint(UNSAFE_CODE, it.span, \"implementation of an `unsafe` trait\");\n-                }\n+    fn check_fn(&mut self, cx: &Context, fk: visit::FnKind, _: &ast::FnDecl,\n+                _: &ast::Block, span: Span, _: ast::NodeId) {\n+        match fk {\n+            visit::FkItemFn(_, _, ast::Unsafety::Unsafe, _) =>\n+                cx.span_lint(UNSAFE_CODE, span, \"declaration of an `unsafe` function\"),\n \n-                for item in impls {\n-                    if let ast::ImplItem::MethodImplItem(ref meth) = *item {\n-                        check_method(cx, meth);\n-                    }\n+            visit::FkMethod(_, _, m) => {\n+                if let ast::Method_::MethDecl(_, _, _, _, ast::Unsafety::Unsafe, _, _, _) = m.node {\n+                    cx.span_lint(UNSAFE_CODE, m.span, \"implementation of an `unsafe` method\")\n                 }\n             },\n \n-            _ => return,\n+            _ => (),\n+        }\n+    }\n+\n+    fn check_ty_method(&mut self, cx: &Context, ty_method: &ast::TypeMethod) {\n+        if let ast::TypeMethod { unsafety: ast::Unsafety::Unsafe, span, ..} = *ty_method {\n+            cx.span_lint(UNSAFE_CODE, span, \"declaration of an `unsafe` method\")\n         }\n     }\n }"}, {"sha": "a8d39f95739326174f2f3714ef3085173ffcbfa4", "filename": "src/librustc/metadata/filesearch.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Ffilesearch.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -14,6 +14,7 @@ pub use self::FileMatch::*;\n \n use std::collections::HashSet;\n use std::env;\n+use std::os;\n use std::old_io::fs::PathExtensions;\n use std::old_io::fs;\n \n@@ -194,7 +195,7 @@ pub fn get_or_default_sysroot() -> Path {\n             })\n     }\n \n-    match canonicalize(env::current_exe().ok()) {\n+    match canonicalize(os::self_exe_name()) {\n         Some(mut p) => { p.pop(); p.pop(); p }\n         None => panic!(\"can't determine value for sysroot\")\n     }\n@@ -224,7 +225,7 @@ pub fn rust_path() -> Vec<Path> {\n         }\n         None => Vec::new()\n     };\n-    let mut cwd = env::current_dir().unwrap();\n+    let mut cwd = os::getcwd().unwrap();\n     // now add in default entries\n     let cwd_dot_rust = cwd.join(\".rust\");\n     if !env_rust_path.contains(&cwd_dot_rust) {\n@@ -243,7 +244,7 @@ pub fn rust_path() -> Vec<Path> {\n         }\n         cwd.pop();\n     }\n-    if let Some(h) = env::home_dir() {\n+    if let Some(h) = os::homedir() {\n         let p = h.join(\".rust\");\n         if !env_rust_path.contains(&p) && p.exists() {\n             env_rust_path.push(p);"}, {"sha": "07082d818769c44ba1d2cf25e5528b396fe1f346", "filename": "src/librustc/metadata/loader.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibrustc%2Fmetadata%2Floader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibrustc%2Fmetadata%2Floader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Floader.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -736,12 +736,10 @@ fn get_metadata_section_imp(is_osx: bool, filename: &Path) -> Result<MetadataBlo\n             }\n         };\n         return match ArchiveMetadata::new(archive).map(|ar| MetadataArchive(ar)) {\n-            None => {\n-                return Err((format!(\"failed to read rlib metadata: '{}'\",\n-                                    filename.display())))\n-            }\n-            Some(blob) => return Ok(blob)\n-        }\n+            None => Err(format!(\"failed to read rlib metadata: '{}'\",\n+                                filename.display())),\n+            Some(blob) => Ok(blob)\n+        };\n     }\n     unsafe {\n         let buf = CString::new(filename.as_vec()).unwrap();\n@@ -791,7 +789,7 @@ fn get_metadata_section_imp(is_osx: bool, filename: &Path) -> Result<MetadataBlo\n             }\n             llvm::LLVMMoveToNextSection(si.llsi);\n         }\n-        return Err(format!(\"metadata not found: '{}'\", filename.display()));\n+        Err(format!(\"metadata not found: '{}'\", filename.display()))\n     }\n }\n "}, {"sha": "b782a655d89ff11155bf156793000776a9c6bbed", "filename": "src/librustc/middle/infer/combine.rs", "status": "modified", "additions": 168, "deletions": 192, "changes": 360, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fcombine.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -228,11 +228,11 @@ pub trait Combine<'tcx> : Sized {\n                              variadic: a.variadic});\n \n \n-        fn argvecs<'tcx, C: Combine<'tcx>>(combiner: &C,\n-                                           a_args: &[Ty<'tcx>],\n-                                           b_args: &[Ty<'tcx>])\n-                                           -> cres<'tcx, Vec<Ty<'tcx>>>\n-        {\n+        fn argvecs<'tcx, C>(combiner: &C,\n+                            a_args: &[Ty<'tcx>],\n+                            b_args: &[Ty<'tcx>])\n+                            -> cres<'tcx, Vec<Ty<'tcx>>>\n+                            where C: Combine<'tcx> {\n             if a_args.len() == b_args.len() {\n                 a_args.iter().zip(b_args.iter())\n                     .map(|(a, b)| combiner.args(*a, *b)).collect()\n@@ -265,13 +265,7 @@ pub trait Combine<'tcx> : Sized {\n             Err(ty::terr_projection_name_mismatched(\n                 expected_found(self, a.item_name, b.item_name)))\n         } else {\n-            // Note that the trait refs for the projection must be\n-            // *equal*. This is because there is no inherent\n-            // relationship between `<T as Foo>::Bar` and `<U as\n-            // Foo>::Bar` that we can derive based on how `T` relates\n-            // to `U`. Issue #21726 contains further discussion and\n-            // in-depth examples.\n-            let trait_ref = try!(self.equate().trait_refs(&*a.trait_ref, &*b.trait_ref));\n+            let trait_ref = try!(self.trait_refs(&*a.trait_ref, &*b.trait_ref));\n             Ok(ty::ProjectionTy { trait_ref: Rc::new(trait_ref), item_name: a.item_name })\n         }\n     }\n@@ -351,51 +345,51 @@ pub trait Combineable<'tcx> : Repr<'tcx> + TypeFoldable<'tcx> {\n impl<'tcx,T> Combineable<'tcx> for Rc<T>\n     where T : Combineable<'tcx>\n {\n-    fn combine<C:Combine<'tcx>>(combiner: &C,\n-                                a: &Rc<T>,\n-                                b: &Rc<T>)\n-                                -> cres<'tcx, Rc<T>>\n-    {\n+    fn combine<C>(combiner: &C,\n+                  a: &Rc<T>,\n+                  b: &Rc<T>)\n+                  -> cres<'tcx, Rc<T>>\n+                  where C: Combine<'tcx> {\n         Ok(Rc::new(try!(Combineable::combine(combiner, &**a, &**b))))\n     }\n }\n \n impl<'tcx> Combineable<'tcx> for ty::TraitRef<'tcx> {\n-    fn combine<C:Combine<'tcx>>(combiner: &C,\n-                                a: &ty::TraitRef<'tcx>,\n-                                b: &ty::TraitRef<'tcx>)\n-                                -> cres<'tcx, ty::TraitRef<'tcx>>\n-    {\n+    fn combine<C>(combiner: &C,\n+                  a: &ty::TraitRef<'tcx>,\n+                  b: &ty::TraitRef<'tcx>)\n+                  -> cres<'tcx, ty::TraitRef<'tcx>>\n+                  where C: Combine<'tcx> {\n         combiner.trait_refs(a, b)\n     }\n }\n \n impl<'tcx> Combineable<'tcx> for Ty<'tcx> {\n-    fn combine<C:Combine<'tcx>>(combiner: &C,\n-                                a: &Ty<'tcx>,\n-                                b: &Ty<'tcx>)\n-                                -> cres<'tcx, Ty<'tcx>>\n-    {\n+    fn combine<C>(combiner: &C,\n+                  a: &Ty<'tcx>,\n+                  b: &Ty<'tcx>)\n+                  -> cres<'tcx, Ty<'tcx>>\n+                  where C: Combine<'tcx> {\n         combiner.tys(*a, *b)\n     }\n }\n \n impl<'tcx> Combineable<'tcx> for ty::ProjectionPredicate<'tcx> {\n-    fn combine<C:Combine<'tcx>>(combiner: &C,\n-                                a: &ty::ProjectionPredicate<'tcx>,\n-                                b: &ty::ProjectionPredicate<'tcx>)\n-                                -> cres<'tcx, ty::ProjectionPredicate<'tcx>>\n-    {\n+    fn combine<C>(combiner: &C,\n+                  a: &ty::ProjectionPredicate<'tcx>,\n+                  b: &ty::ProjectionPredicate<'tcx>)\n+                  -> cres<'tcx, ty::ProjectionPredicate<'tcx>>\n+                  where C: Combine<'tcx> {\n         combiner.projection_predicates(a, b)\n     }\n }\n \n impl<'tcx> Combineable<'tcx> for ty::FnSig<'tcx> {\n-    fn combine<C:Combine<'tcx>>(combiner: &C,\n-                                a: &ty::FnSig<'tcx>,\n-                                b: &ty::FnSig<'tcx>)\n-                                -> cres<'tcx, ty::FnSig<'tcx>>\n-    {\n+    fn combine<C>(combiner: &C,\n+                  a: &ty::FnSig<'tcx>,\n+                  b: &ty::FnSig<'tcx>)\n+                  -> cres<'tcx, ty::FnSig<'tcx>>\n+                  where C: Combine<'tcx> {\n         combiner.fn_sigs(a, b)\n     }\n }\n@@ -407,38 +401,38 @@ pub struct CombineFields<'a, 'tcx: 'a> {\n     pub trace: TypeTrace<'tcx>,\n }\n \n-pub fn expected_found<'tcx, C: Combine<'tcx>, T>(\n-        this: &C, a: T, b: T) -> ty::expected_found<T> {\n+pub fn expected_found<'tcx, C, T>(this: &C,\n+                                  a: T,\n+                                  b: T)\n+                                  -> ty::expected_found<T>\n+                                  where C: Combine<'tcx> {\n     if this.a_is_expected() {\n         ty::expected_found {expected: a, found: b}\n     } else {\n         ty::expected_found {expected: b, found: a}\n     }\n }\n \n-pub fn super_tys<'tcx, C: Combine<'tcx>>(this: &C,\n-                                         a: Ty<'tcx>,\n-                                         b: Ty<'tcx>)\n-                                         -> cres<'tcx, Ty<'tcx>>\n-{\n+pub fn super_tys<'tcx, C>(this: &C,\n+                          a: Ty<'tcx>,\n+                          b: Ty<'tcx>)\n+                          -> cres<'tcx, Ty<'tcx>>\n+                          where C: Combine<'tcx> {\n     let tcx = this.infcx().tcx;\n     let a_sty = &a.sty;\n     let b_sty = &b.sty;\n     debug!(\"super_tys: a_sty={:?} b_sty={:?}\", a_sty, b_sty);\n     return match (a_sty, b_sty) {\n-      // The \"subtype\" ought to be handling cases involving var:\n-      (&ty::ty_infer(TyVar(_)), _) |\n-      (_, &ty::ty_infer(TyVar(_))) => {\n-        tcx.sess.bug(\n-            &format!(\"{}: bot and var types should have been handled ({},{})\",\n-                    this.tag(),\n-                    a.repr(this.infcx().tcx),\n-                    b.repr(this.infcx().tcx)));\n-      }\n-\n-      (&ty::ty_err, _) | (_, &ty::ty_err) => {\n-          Ok(tcx.types.err)\n-      }\n+        // The \"subtype\" ought to be handling cases involving var:\n+        (&ty::ty_infer(TyVar(_)), _)\n+        | (_, &ty::ty_infer(TyVar(_))) =>\n+            tcx.sess.bug(\n+                &format!(\"{}: bot and var types should have been handled ({},{})\",\n+                this.tag(),\n+                a.repr(this.infcx().tcx),\n+                b.repr(this.infcx().tcx))),\n+\n+        (&ty::ty_err, _) | (_, &ty::ty_err) => Ok(tcx.types.err),\n \n         // Relate integral variables to other types\n         (&ty::ty_infer(IntVar(a_id)), &ty::ty_infer(IntVar(b_id))) => {\n@@ -475,68 +469,62 @@ pub fn super_tys<'tcx, C: Combine<'tcx>>(this: &C,\n             unify_float_variable(this, !this.a_is_expected(), v_id, v)\n         }\n \n-      (&ty::ty_char, _) |\n-      (&ty::ty_bool, _) |\n-      (&ty::ty_int(_), _) |\n-      (&ty::ty_uint(_), _) |\n-      (&ty::ty_float(_), _) => {\n-        if a == b {\n-            Ok(a)\n-        } else {\n-            Err(ty::terr_sorts(expected_found(this, a, b)))\n-        }\n-      }\n-\n-      (&ty::ty_param(ref a_p), &ty::ty_param(ref b_p)) if\n-          a_p.idx == b_p.idx && a_p.space == b_p.space => {\n-        Ok(a)\n-      }\n-\n-      (&ty::ty_enum(a_id, a_substs),\n-       &ty::ty_enum(b_id, b_substs))\n-      if a_id == b_id => {\n-          let substs = try!(this.substs(a_id,\n-                                          a_substs,\n-                                          b_substs));\n-          Ok(ty::mk_enum(tcx, a_id, tcx.mk_substs(substs)))\n-      }\n-\n-      (&ty::ty_trait(ref a_),\n-       &ty::ty_trait(ref b_)) => {\n-          debug!(\"Trying to match traits {:?} and {:?}\", a, b);\n-          let principal = try!(this.binders(&a_.principal, &b_.principal));\n-          let bounds = try!(this.existential_bounds(&a_.bounds, &b_.bounds));\n-          Ok(ty::mk_trait(tcx, principal, bounds))\n-      }\n-\n-      (&ty::ty_struct(a_id, a_substs), &ty::ty_struct(b_id, b_substs))\n-      if a_id == b_id => {\n+        (&ty::ty_char, _)\n+        | (&ty::ty_bool, _)\n+        | (&ty::ty_int(_), _)\n+        | (&ty::ty_uint(_), _)\n+        | (&ty::ty_float(_), _) => {\n+            if a == b {\n+                Ok(a)\n+            } else {\n+                Err(ty::terr_sorts(expected_found(this, a, b)))\n+            }\n+        }\n+\n+        (&ty::ty_param(ref a_p), &ty::ty_param(ref b_p)) if\n+          a_p.idx == b_p.idx && a_p.space == b_p.space => Ok(a),\n+\n+        (&ty::ty_enum(a_id, a_substs), &ty::ty_enum(b_id, b_substs))\n+          if a_id == b_id => {\n+            let substs = try!(this.substs(a_id, a_substs, b_substs));\n+            Ok(ty::mk_enum(tcx, a_id, tcx.mk_substs(substs)))\n+        }\n+\n+        (&ty::ty_trait(ref a_), &ty::ty_trait(ref b_)) => {\n+            debug!(\"Trying to match traits {:?} and {:?}\", a, b);\n+            let principal = try!(this.binders(&a_.principal, &b_.principal));\n+            let bounds = try!(this.existential_bounds(&a_.bounds, &b_.bounds));\n+            Ok(ty::mk_trait(tcx, principal, bounds))\n+        }\n+\n+        (&ty::ty_struct(a_id, a_substs), &ty::ty_struct(b_id, b_substs))\n+          if a_id == b_id => {\n             let substs = try!(this.substs(a_id, a_substs, b_substs));\n             Ok(ty::mk_struct(tcx, a_id, tcx.mk_substs(substs)))\n-      }\n-\n-      (&ty::ty_closure(a_id, a_region, a_substs),\n-       &ty::ty_closure(b_id, b_region, b_substs))\n-      if a_id == b_id => {\n-          // All ty_closure types with the same id represent\n-          // the (anonymous) type of the same closure expression. So\n-          // all of their regions should be equated.\n-          let region = try!(this.equate().regions(*a_region, *b_region));\n-          let substs = try!(this.substs_variances(None, a_substs, b_substs));\n-          Ok(ty::mk_closure(tcx, a_id, tcx.mk_region(region), tcx.mk_substs(substs)))\n-      }\n-\n-      (&ty::ty_uniq(a_inner), &ty::ty_uniq(b_inner)) => {\n-          let typ = try!(this.tys(a_inner, b_inner));\n-          Ok(ty::mk_uniq(tcx, typ))\n-      }\n-\n-      (&ty::ty_ptr(ref a_mt), &ty::ty_ptr(ref b_mt)) => {\n-          let mt = try!(this.mts(a_mt, b_mt));\n-          Ok(ty::mk_ptr(tcx, mt))\n-      }\n-\n-      (&ty::ty_rptr(a_r, ref a_mt), &ty::ty_rptr(b_r, ref b_mt)) => {\n+        }\n+\n+        (&ty::ty_closure(a_id, a_region, a_substs),\n+         &ty::ty_closure(b_id, b_region, b_substs))\n+          if a_id == b_id => {\n+            // All ty_closure types with the same id represent\n+            // the (anonymous) type of the same closure expression. So\n+            // all of their regions should be equated.\n+            let region = try!(this.equate().regions(*a_region, *b_region));\n+            let substs = try!(this.substs_variances(None, a_substs, b_substs));\n+            Ok(ty::mk_closure(tcx, a_id, tcx.mk_region(region), tcx.mk_substs(substs)))\n+        }\n+\n+        (&ty::ty_uniq(a_inner), &ty::ty_uniq(b_inner)) => {\n+            let typ = try!(this.tys(a_inner, b_inner));\n+            Ok(ty::mk_uniq(tcx, typ))\n+        }\n+\n+        (&ty::ty_ptr(ref a_mt), &ty::ty_ptr(ref b_mt)) => {\n+            let mt = try!(this.mts(a_mt, b_mt));\n+            Ok(ty::mk_ptr(tcx, mt))\n+        }\n+\n+        (&ty::ty_rptr(a_r, ref a_mt), &ty::ty_rptr(b_r, ref b_mt)) => {\n             let r = try!(this.regions_with_variance(ty::Contravariant, *a_r, *b_r));\n \n             // FIXME(14985)  If we have mutable references to trait objects, we\n@@ -551,45 +539,43 @@ pub fn super_tys<'tcx, C: Combine<'tcx>>(this: &C,\n                 _ => try!(this.mts(a_mt, b_mt))\n             };\n             Ok(ty::mk_rptr(tcx, tcx.mk_region(r), mt))\n-      }\n+        }\n \n-      (&ty::ty_vec(a_t, Some(sz_a)), &ty::ty_vec(b_t, Some(sz_b))) => {\n-        this.tys(a_t, b_t).and_then(|t| {\n-            if sz_a == sz_b {\n-                Ok(ty::mk_vec(tcx, t, Some(sz_a)))\n-            } else {\n-                Err(ty::terr_fixed_array_size(expected_found(this, sz_a, sz_b)))\n-            }\n-        })\n-      }\n+        (&ty::ty_vec(a_t, Some(sz_a)), &ty::ty_vec(b_t, Some(sz_b))) => {\n+            this.tys(a_t, b_t).and_then(|t| {\n+                if sz_a == sz_b {\n+                    Ok(ty::mk_vec(tcx, t, Some(sz_a)))\n+                } else {\n+                    Err(ty::terr_fixed_array_size(expected_found(this, sz_a, sz_b)))\n+                }\n+            })\n+        }\n \n-      (&ty::ty_vec(a_t, sz_a), &ty::ty_vec(b_t, sz_b)) => {\n-        this.tys(a_t, b_t).and_then(|t| {\n-            if sz_a == sz_b {\n-                Ok(ty::mk_vec(tcx, t, sz_a))\n+        (&ty::ty_vec(a_t, sz_a), &ty::ty_vec(b_t, sz_b)) => {\n+            this.tys(a_t, b_t).and_then(|t| {\n+                if sz_a == sz_b {\n+                    Ok(ty::mk_vec(tcx, t, sz_a))\n+                } else {\n+                    Err(ty::terr_sorts(expected_found(this, a, b)))\n+                }\n+            })\n+        }\n+\n+        (&ty::ty_str, &ty::ty_str) => Ok(ty::mk_str(tcx)),\n+\n+        (&ty::ty_tup(ref as_), &ty::ty_tup(ref bs)) => {\n+            if as_.len() == bs.len() {\n+                as_.iter().zip(bs.iter())\n+                   .map(|(a, b)| this.tys(*a, *b))\n+                   .collect::<Result<_, _>>()\n+                   .map(|ts| ty::mk_tup(tcx, ts))\n+            } else if as_.len() != 0 && bs.len() != 0 {\n+                Err(ty::terr_tuple_size(\n+                    expected_found(this, as_.len(), bs.len())))\n             } else {\n                 Err(ty::terr_sorts(expected_found(this, a, b)))\n             }\n-        })\n-      }\n-\n-      (&ty::ty_str, &ty::ty_str) => {\n-            Ok(ty::mk_str(tcx))\n-      }\n-\n-      (&ty::ty_tup(ref as_), &ty::ty_tup(ref bs)) => {\n-        if as_.len() == bs.len() {\n-            as_.iter().zip(bs.iter())\n-               .map(|(a, b)| this.tys(*a, *b))\n-               .collect::<Result<_, _>>()\n-               .map(|ts| ty::mk_tup(tcx, ts))\n-        } else if as_.len() != 0 && bs.len() != 0 {\n-            Err(ty::terr_tuple_size(\n-                expected_found(this, as_.len(), bs.len())))\n-        } else {\n-            Err(ty::terr_sorts(expected_found(this, a, b)))\n         }\n-      }\n \n         (&ty::ty_bare_fn(a_opt_def_id, a_fty), &ty::ty_bare_fn(b_opt_def_id, b_fty))\n             if a_opt_def_id == b_opt_def_id =>\n@@ -598,33 +584,33 @@ pub fn super_tys<'tcx, C: Combine<'tcx>>(this: &C,\n             Ok(ty::mk_bare_fn(tcx, a_opt_def_id, tcx.mk_bare_fn(fty)))\n         }\n \n-      (&ty::ty_projection(ref a_data), &ty::ty_projection(ref b_data)) => {\n-          let projection_ty = try!(this.projection_tys(a_data, b_data));\n-          Ok(ty::mk_projection(tcx, projection_ty.trait_ref, projection_ty.item_name))\n-      }\n+        (&ty::ty_projection(ref a_data), &ty::ty_projection(ref b_data)) => {\n+            let projection_ty = try!(this.projection_tys(a_data, b_data));\n+            Ok(ty::mk_projection(tcx, projection_ty.trait_ref, projection_ty.item_name))\n+        }\n \n-      _ => Err(ty::terr_sorts(expected_found(this, a, b)))\n+        _ => Err(ty::terr_sorts(expected_found(this, a, b))),\n     };\n \n-    fn unify_integral_variable<'tcx, C: Combine<'tcx>>(\n-        this: &C,\n-        vid_is_expected: bool,\n-        vid: ty::IntVid,\n-        val: ty::IntVarValue) -> cres<'tcx, Ty<'tcx>>\n-    {\n+    fn unify_integral_variable<'tcx, C>(this: &C,\n+                                        vid_is_expected: bool,\n+                                        vid: ty::IntVid,\n+                                        val: ty::IntVarValue)\n+                                        -> cres<'tcx, Ty<'tcx>>\n+                                        where C: Combine<'tcx> {\n         try!(this.infcx().simple_var_t(vid_is_expected, vid, val));\n         match val {\n             IntType(v) => Ok(ty::mk_mach_int(this.tcx(), v)),\n-            UintType(v) => Ok(ty::mk_mach_uint(this.tcx(), v))\n+            UintType(v) => Ok(ty::mk_mach_uint(this.tcx(), v)),\n         }\n     }\n \n-    fn unify_float_variable<'tcx, C: Combine<'tcx>>(\n-        this: &C,\n-        vid_is_expected: bool,\n-        vid: ty::FloatVid,\n-        val: ast::FloatTy) -> cres<'tcx, Ty<'tcx>>\n-    {\n+    fn unify_float_variable<'tcx, C>(this: &C,\n+                                     vid_is_expected: bool,\n+                                     vid: ty::FloatVid,\n+                                     val: ast::FloatTy)\n+                                     -> cres<'tcx, Ty<'tcx>>\n+                                     where C: Combine<'tcx> {\n         try!(this.infcx().simple_var_t(vid_is_expected, vid, val));\n         Ok(ty::mk_mach_float(this.tcx(), val))\n     }\n@@ -696,12 +682,8 @@ impl<'f, 'tcx> CombineFields<'f, 'tcx> {\n                 None => {     // ...not yet instantiated:\n                     // Generalize type if necessary.\n                     let generalized_ty = try!(match dir {\n-                        EqTo => {\n-                            self.generalize(a_ty, b_vid, false)\n-                        }\n-                        BiTo | SupertypeOf | SubtypeOf => {\n-                            self.generalize(a_ty, b_vid, true)\n-                        }\n+                        EqTo => self.generalize(a_ty, b_vid, false),\n+                        BiTo | SupertypeOf | SubtypeOf => self.generalize(a_ty, b_vid, true),\n                     });\n                     debug!(\"instantiate(a_ty={}, dir={:?}, \\\n                                         b_vid={}, generalized_ty={})\",\n@@ -723,22 +705,14 @@ impl<'f, 'tcx> CombineFields<'f, 'tcx> {\n             // to associate causes/spans with each of the relations in\n             // the stack to get this right.\n             match dir {\n-                BiTo => {\n-                    try!(self.bivariate().tys(a_ty, b_ty));\n-                }\n+                BiTo => try!(self.bivariate().tys(a_ty, b_ty)),\n \n-                EqTo => {\n-                    try!(self.equate().tys(a_ty, b_ty));\n-                }\n+                EqTo => try!(self.equate().tys(a_ty, b_ty)),\n \n-                SubtypeOf => {\n-                    try!(self.sub().tys(a_ty, b_ty));\n-                }\n+                SubtypeOf => try!(self.sub().tys(a_ty, b_ty)),\n \n-                SupertypeOf => {\n-                    try!(self.sub().tys_with_variance(ty::Contravariant, a_ty, b_ty));\n-                }\n-            }\n+                SupertypeOf => try!(self.sub().tys_with_variance(ty::Contravariant, a_ty, b_ty)),\n+            };\n         }\n \n         Ok(())\n@@ -754,11 +728,13 @@ impl<'f, 'tcx> CombineFields<'f, 'tcx> {\n                   make_region_vars: bool)\n                   -> cres<'tcx, Ty<'tcx>>\n     {\n-        let mut generalize = Generalizer { infcx: self.infcx,\n-                                           span: self.trace.origin.span(),\n-                                           for_vid: for_vid,\n-                                           make_region_vars: make_region_vars,\n-                                           cycle_detected: false };\n+        let mut generalize = Generalizer {\n+            infcx: self.infcx,\n+            span: self.trace.origin.span(),\n+            for_vid: for_vid,\n+            make_region_vars: make_region_vars,\n+            cycle_detected: false\n+        };\n         let u = ty.fold_with(&mut generalize);\n         if generalize.cycle_detected {\n             Err(ty::terr_cyclic_ty)"}, {"sha": "759d7357df1931d71b0843e61594c2dd4624cbcb", "filename": "src/librustc/middle/infer/region_inference/mod.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -1133,18 +1133,12 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                 true // changed\n             }\n \n-            ErrorValue => {\n-                false // no change\n-            }\n+            ErrorValue => false, // no change\n \n             Value(a_region) => {\n                 match a_data.classification {\n-                    Expanding => {\n-                        check_node(self, a_vid, a_data, a_region, b_region)\n-                    }\n-                    Contracting => {\n-                        adjust_node(self, a_vid, a_data, a_region, b_region)\n-                    }\n+                    Expanding => check_node(self, a_vid, a_data, a_region, b_region),\n+                    Contracting => adjust_node(self, a_vid, a_data, a_region, b_region),\n                 }\n             }\n         };\n@@ -1154,7 +1148,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                       a_data: &mut VarData,\n                       a_region: Region,\n                       b_region: Region)\n-                   -> bool {\n+                      -> bool {\n             if !this.is_subregion_of(a_region, b_region) {\n                 debug!(\"Setting {:?} to ErrorValue: {} not subregion of {}\",\n                        a_vid,\n@@ -1170,7 +1164,7 @@ impl<'a, 'tcx> RegionVarBindings<'a, 'tcx> {\n                        a_data: &mut VarData,\n                        a_region: Region,\n                        b_region: Region)\n-                    -> bool {\n+                       -> bool {\n             match this.glb_concrete_regions(a_region, b_region) {\n                 Ok(glb) => {\n                     if glb == a_region {"}, {"sha": "62b81f0ebe7dba8b98e7d4368d755f4aba55da64", "filename": "src/librustc/middle/traits/coherence.rs", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fcoherence.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -52,9 +52,16 @@ fn overlap(selcx: &mut SelectionContext,\n            b_def_id: ast::DefId)\n            -> bool\n {\n+    debug!(\"overlap(a_def_id={}, b_def_id={})\",\n+           a_def_id.repr(selcx.tcx()),\n+           b_def_id.repr(selcx.tcx()));\n+\n     let (a_trait_ref, a_obligations) = impl_trait_ref_and_oblig(selcx, a_def_id);\n     let (b_trait_ref, b_obligations) = impl_trait_ref_and_oblig(selcx, b_def_id);\n \n+    debug!(\"overlap: a_trait_ref={}\", a_trait_ref.repr(selcx.tcx()));\n+    debug!(\"overlap: b_trait_ref={}\", b_trait_ref.repr(selcx.tcx()));\n+\n     // Does `a <: b` hold? If not, no overlap.\n     if let Err(_) = infer::mk_sub_poly_trait_refs(selcx.infcx(),\n                                                   true,\n@@ -64,10 +71,20 @@ fn overlap(selcx: &mut SelectionContext,\n         return false;\n     }\n \n+    debug!(\"overlap: subtraitref check succeeded\");\n+\n     // Are any of the obligations unsatisfiable? If so, no overlap.\n-    a_obligations.iter()\n-                 .chain(b_obligations.iter())\n-                 .all(|o| selcx.evaluate_obligation(o))\n+    let opt_failing_obligation =\n+        a_obligations.iter()\n+                     .chain(b_obligations.iter())\n+                     .find(|o| !selcx.evaluate_obligation(o));\n+\n+    if let Some(failing_obligation) = opt_failing_obligation {\n+        debug!(\"overlap: obligation unsatisfiable {}\", failing_obligation.repr(selcx.tcx()));\n+        return false;\n+    }\n+\n+    true\n }\n \n /// Instantiate fresh variables for all bound parameters of the impl"}, {"sha": "5a5639c701291f54716eba3b701e76f8bc825786", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 50, "deletions": 41, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -18,7 +18,7 @@ pub use self::ObligationCauseCode::*;\n use middle::subst;\n use middle::ty::{self, HasProjectionTypes, Ty};\n use middle::ty_fold::TypeFoldable;\n-use middle::infer::{self, InferCtxt};\n+use middle::infer::{self, fixup_err_to_string, InferCtxt};\n use std::slice::Iter;\n use std::rc::Rc;\n use syntax::ast;\n@@ -395,53 +395,64 @@ pub fn type_known_to_meet_builtin_bound<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n     }\n }\n \n+/// Normalizes the parameter environment, reporting errors if they occur.\n pub fn normalize_param_env_or_error<'a,'tcx>(unnormalized_env: ty::ParameterEnvironment<'a,'tcx>,\n                                              cause: ObligationCause<'tcx>)\n                                              -> ty::ParameterEnvironment<'a,'tcx>\n {\n-    match normalize_param_env(&unnormalized_env, cause) {\n-        Ok(p) => p,\n+    // I'm not wild about reporting errors here; I'd prefer to\n+    // have the errors get reported at a defined place (e.g.,\n+    // during typeck). Instead I have all parameter\n+    // environments, in effect, going through this function\n+    // and hence potentially reporting errors. This ensurse of\n+    // course that we never forget to normalize (the\n+    // alternative seemed like it would involve a lot of\n+    // manual invocations of this fn -- and then we'd have to\n+    // deal with the errors at each of those sites).\n+    //\n+    // In any case, in practice, typeck constructs all the\n+    // parameter environments once for every fn as it goes,\n+    // and errors will get reported then; so after typeck we\n+    // can be sure that no errors should occur.\n+\n+    let tcx = unnormalized_env.tcx;\n+    let span = cause.span;\n+    let body_id = cause.body_id;\n+\n+    debug!(\"normalize_param_env_or_error(unnormalized_env={})\",\n+           unnormalized_env.repr(tcx));\n+\n+    let infcx = infer::new_infer_ctxt(tcx);\n+    let predicates = match fully_normalize(&infcx, &unnormalized_env, cause,\n+                                           &unnormalized_env.caller_bounds) {\n+        Ok(predicates) => predicates,\n         Err(errors) => {\n-            // I'm not wild about reporting errors here; I'd prefer to\n-            // have the errors get reported at a defined place (e.g.,\n-            // during typeck). Instead I have all parameter\n-            // environments, in effect, going through this function\n-            // and hence potentially reporting errors. This ensurse of\n-            // course that we never forget to normalize (the\n-            // alternative seemed like it would involve a lot of\n-            // manual invocations of this fn -- and then we'd have to\n-            // deal with the errors at each of those sites).\n-            //\n-            // In any case, in practice, typeck constructs all the\n-            // parameter environments once for every fn as it goes,\n-            // and errors will get reported then; so after typeck we\n-            // can be sure that no errors should occur.\n-            let infcx = infer::new_infer_ctxt(unnormalized_env.tcx);\n             report_fulfillment_errors(&infcx, &errors);\n-\n-            // Normalized failed? use what they gave us, it's better than nothing.\n-            unnormalized_env\n+            return unnormalized_env; // an unnormalized env is better than nothing\n         }\n-    }\n-}\n-\n-pub fn normalize_param_env<'a,'tcx>(param_env: &ty::ParameterEnvironment<'a,'tcx>,\n-                                    cause: ObligationCause<'tcx>)\n-                                    -> Result<ty::ParameterEnvironment<'a,'tcx>,\n-                                              Vec<FulfillmentError<'tcx>>>\n-{\n-    let tcx = param_env.tcx;\n-\n-    debug!(\"normalize_param_env(param_env={})\",\n-           param_env.repr(tcx));\n+    };\n \n-    let infcx = infer::new_infer_ctxt(tcx);\n-    let predicates = try!(fully_normalize(&infcx, param_env, cause, &param_env.caller_bounds));\n+    infcx.resolve_regions_and_report_errors(body_id);\n+    let predicates = match infcx.fully_resolve(&predicates) {\n+        Ok(predicates) => predicates,\n+        Err(fixup_err) => {\n+            // If we encounter a fixup error, it means that some type\n+            // variable wound up unconstrained. I actually don't know\n+            // if this can happen, and I certainly don't expect it to\n+            // happen often, but if it did happen it probably\n+            // represents a legitimate failure due to some kind of\n+            // unconstrained variable, and it seems better not to ICE,\n+            // all things considered.\n+            let err_msg = fixup_err_to_string(fixup_err);\n+            tcx.sess.span_err(span, &err_msg);\n+            return unnormalized_env; // an unnormalized env is better than nothing\n+        }\n+    };\n \n-    debug!(\"normalize_param_env: predicates={}\",\n+    debug!(\"normalize_param_env_or_error: predicates={}\",\n            predicates.repr(tcx));\n \n-    Ok(param_env.with_caller_bounds(predicates))\n+    unnormalized_env.with_caller_bounds(predicates)\n }\n \n pub fn fully_normalize<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n@@ -453,8 +464,7 @@ pub fn fully_normalize<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n {\n     let tcx = closure_typer.tcx();\n \n-    debug!(\"normalize_param_env(value={})\",\n-           value.repr(tcx));\n+    debug!(\"normalize_param_env(value={})\", value.repr(tcx));\n \n     let mut selcx = &mut SelectionContext::new(infcx, closure_typer);\n     let mut fulfill_cx = FulfillmentContext::new();\n@@ -468,8 +478,7 @@ pub fn fully_normalize<'a,'tcx,T>(infcx: &InferCtxt<'a,'tcx>,\n     }\n     try!(fulfill_cx.select_all_or_error(infcx, closure_typer));\n     let resolved_value = infcx.resolve_type_vars_if_possible(&normalized_value);\n-    debug!(\"normalize_param_env: resolved_value={}\",\n-           resolved_value.repr(tcx));\n+    debug!(\"normalize_param_env: resolved_value={}\", resolved_value.repr(tcx));\n     Ok(resolved_value)\n }\n "}, {"sha": "9ec89f55b8f329cd61ae5715580cb65aed420893", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 58, "deletions": 102, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -1409,27 +1409,23 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         let self_ty = self.infcx.shallow_resolve(obligation.predicate.0.self_ty());\n         return match self_ty.sty {\n-            ty::ty_infer(ty::IntVar(_)) |\n-            ty::ty_infer(ty::FloatVar(_)) |\n-            ty::ty_uint(_) |\n-            ty::ty_int(_) |\n-            ty::ty_bool |\n-            ty::ty_float(_) |\n-            ty::ty_bare_fn(..) |\n-            ty::ty_char => {\n+            ty::ty_infer(ty::IntVar(_))\n+            | ty::ty_infer(ty::FloatVar(_))\n+            | ty::ty_uint(_)\n+            | ty::ty_int(_)\n+            | ty::ty_bool\n+            | ty::ty_float(_)\n+            | ty::ty_bare_fn(..)\n+            | ty::ty_char => {\n                 // safe for everything\n                 Ok(If(Vec::new()))\n             }\n \n             ty::ty_uniq(_) => {  // Box<T>\n                 match bound {\n-                    ty::BoundCopy => {\n-                        Err(Unimplemented)\n-                    }\n+                    ty::BoundCopy => Err(Unimplemented),\n \n-                    ty::BoundSized => {\n-                        Ok(If(Vec::new()))\n-                    }\n+                    ty::BoundSized => Ok(If(Vec::new())),\n \n                     ty::BoundSync | ty::BoundSend => {\n                         self.tcx().sess.bug(\"Send/Sync shouldn't occur in builtin_bounds()\");\n@@ -1439,9 +1435,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n             ty::ty_ptr(..) => {     // *const T, *mut T\n                 match bound {\n-                    ty::BoundCopy | ty::BoundSized => {\n-                        Ok(If(Vec::new()))\n-                    }\n+                    ty::BoundCopy | ty::BoundSized => Ok(If(Vec::new())),\n \n                     ty::BoundSync | ty::BoundSend => {\n                         self.tcx().sess.bug(\"Send/Sync shouldn't occur in builtin_bounds()\");\n@@ -1451,9 +1445,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n             ty::ty_trait(ref data) => {\n                 match bound {\n-                    ty::BoundSized => {\n-                        Err(Unimplemented)\n-                    }\n+                    ty::BoundSized => Err(Unimplemented),\n                     ty::BoundCopy => {\n                         if data.bounds.builtin_bounds.contains(&bound) {\n                             Ok(If(Vec::new()))\n@@ -1485,20 +1477,14 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     ty::BoundCopy => {\n                         match mutbl {\n                             // &mut T is affine and hence never `Copy`\n-                            ast::MutMutable => {\n-                                Err(Unimplemented)\n-                            }\n+                            ast::MutMutable => Err(Unimplemented),\n \n                             // &T is always copyable\n-                            ast::MutImmutable => {\n-                                Ok(If(Vec::new()))\n-                            }\n+                            ast::MutImmutable => Ok(If(Vec::new())),\n                         }\n                     }\n \n-                    ty::BoundSized => {\n-                        Ok(If(Vec::new()))\n-                    }\n+                    ty::BoundSized => Ok(If(Vec::new())),\n \n                     ty::BoundSync | ty::BoundSend => {\n                         self.tcx().sess.bug(\"Send/Sync shouldn't occur in builtin_bounds()\");\n@@ -1511,14 +1497,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 match bound {\n                     ty::BoundCopy => {\n                         match *len {\n-                            Some(_) => {\n-                                // [T, ..n] is copy iff T is copy\n-                                Ok(If(vec![element_ty]))\n-                            }\n-                            None => {\n-                                // [T] is unsized and hence affine\n-                                Err(Unimplemented)\n-                            }\n+                            // [T, ..n] is copy iff T is copy\n+                            Some(_) => Ok(If(vec![element_ty])),\n+\n+                            // [T] is unsized and hence affine\n+                            None => Err(Unimplemented),\n                         }\n                     }\n \n@@ -1543,16 +1526,12 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                         self.tcx().sess.bug(\"Send/Sync shouldn't occur in builtin_bounds()\");\n                     }\n \n-                    ty::BoundCopy | ty::BoundSized => {\n-                        Err(Unimplemented)\n-                    }\n+                    ty::BoundCopy | ty::BoundSized => Err(Unimplemented),\n                 }\n             }\n \n-            ty::ty_tup(ref tys) => {\n-                // (T1, ..., Tn) -- meets any bound that all of T1...Tn meet\n-                Ok(If(tys.clone()))\n-            }\n+            // (T1, ..., Tn) -- meets any bound that all of T1...Tn meet\n+            ty::ty_tup(ref tys) => Ok(If(tys.clone())),\n \n             ty::ty_closure(def_id, _, substs) => {\n                 // FIXME -- This case is tricky. In the case of by-ref\n@@ -1581,9 +1560,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 }\n \n                 match self.closure_typer.closure_upvars(def_id, substs) {\n-                    Some(upvars) => {\n-                        Ok(If(upvars.iter().map(|c| c.ty).collect()))\n-                    }\n+                    Some(upvars) => Ok(If(upvars.iter().map(|c| c.ty).collect())),\n                     None => {\n                         debug!(\"assemble_builtin_bound_candidates: no upvar types available yet\");\n                         Ok(AmbiguousBuiltin)\n@@ -1609,8 +1586,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 nominal(bound, types)\n             }\n \n-            ty::ty_projection(_) |\n-            ty::ty_param(_) => {\n+            ty::ty_projection(_) | ty::ty_param(_) => {\n                 // Note: A type parameter is only considered to meet a\n                 // particular bound if there is a where clause telling\n                 // us that it does, and that case is handled by\n@@ -1626,12 +1602,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 Ok(AmbiguousBuiltin)\n             }\n \n-            ty::ty_err => {\n-                Ok(If(Vec::new()))\n-            }\n+            ty::ty_err => Ok(If(Vec::new())),\n \n-            ty::ty_infer(ty::FreshTy(_)) |\n-            ty::ty_infer(ty::FreshIntTy(_)) => {\n+            ty::ty_infer(ty::FreshTy(_))\n+            | ty::ty_infer(ty::FreshIntTy(_)) => {\n                 self.tcx().sess.bug(\n                     &format!(\n                         \"asked to assemble builtin bounds of unexpected type: {}\",\n@@ -1641,7 +1615,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         fn nominal<'cx, 'tcx>(bound: ty::BuiltinBound,\n                               types: Vec<Ty<'tcx>>)\n-                              -> Result<BuiltinBoundConditions<'tcx>,SelectionError<'tcx>>\n+                              -> Result<BuiltinBoundConditions<'tcx>, SelectionError<'tcx>>\n         {\n             // First check for markers and other nonsense.\n             match bound {\n@@ -1692,7 +1666,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 self.tcx().sess.bug(\n                     &format!(\n                         \"asked to assemble constituent types of unexpected type: {}\",\n-                        t.repr(self.tcx()))[]);\n+                        t.repr(self.tcx())));\n             }\n \n             ty::ty_uniq(referent_ty) => {  // Box<T>\n@@ -1909,7 +1883,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }).collect::<Result<_, _>>();\n         let obligations = match obligations {\n             Ok(o) => o,\n-            Err(ErrorReported) => Vec::new()\n+            Err(ErrorReported) => Vec::new(),\n         };\n \n         let obligations = VecPerParamSpace::new(obligations, Vec::new(), Vec::new());\n@@ -1937,14 +1911,12 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         let self_ty = self.infcx.shallow_resolve(obligation.predicate.0.self_ty());\n         match self.constituent_types_for_ty(self_ty) {\n-            Some(types) => {\n-                Ok(self.vtable_default_impl(obligation, impl_def_id, types))\n-            }\n+            Some(types) => Ok(self.vtable_default_impl(obligation, impl_def_id, types)),\n             None => {\n                 self.tcx().sess.bug(\n                     &format!(\n                         \"asked to confirm default implementation for ambiguous type: {}\",\n-                        self_ty.repr(self.tcx()))[]);\n+                        self_ty.repr(self.tcx())));\n             }\n         }\n     }\n@@ -2223,9 +2195,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     {\n         match self.match_impl(impl_def_id, obligation, snapshot,\n                               skol_map, skol_obligation_trait_ref) {\n-            Ok(substs) => {\n-                substs\n-            }\n+            Ok(substs) => substs,\n             Err(()) => {\n                 self.tcx().sess.bug(\n                     &format!(\"Impl {} was matchable against {} but now is not\",\n@@ -2273,30 +2243,26 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                skol_obligation_trait_ref.repr(self.tcx()));\n \n         let origin = infer::RelateOutputImplTypes(obligation.cause.span);\n-        match self.infcx.sub_trait_refs(false,\n-                                        origin,\n-                                        impl_trait_ref.value.clone(),\n-                                        skol_obligation_trait_ref) {\n-            Ok(()) => { }\n-            Err(e) => {\n-                debug!(\"match_impl: failed sub_trait_refs due to `{}`\",\n-                       ty::type_err_to_str(self.tcx(), &e));\n-                return Err(());\n-            }\n+        if let Err(e) = self.infcx.sub_trait_refs(false,\n+                                                  origin,\n+                                                  impl_trait_ref.value.clone(),\n+                                                  skol_obligation_trait_ref) {\n+            debug!(\"match_impl: failed sub_trait_refs due to `{}`\",\n+                   ty::type_err_to_str(self.tcx(), &e));\n+            return Err(());\n         }\n \n-        match self.infcx.leak_check(skol_map, snapshot) {\n-            Ok(()) => { }\n-            Err(e) => {\n-                debug!(\"match_impl: failed leak check due to `{}`\",\n-                       ty::type_err_to_str(self.tcx(), &e));\n-                return Err(());\n-            }\n+        if let Err(e) = self.infcx.leak_check(skol_map, snapshot) {\n+            debug!(\"match_impl: failed leak check due to `{}`\",\n+                   ty::type_err_to_str(self.tcx(), &e));\n+            return Err(());\n         }\n \n         debug!(\"match_impl: success impl_substs={}\", impl_substs.repr(self.tcx()));\n-        Ok(Normalized { value: impl_substs,\n-                        obligations: impl_trait_ref.obligations })\n+        Ok(Normalized {\n+            value: impl_substs,\n+            obligations: impl_trait_ref.obligations\n+        })\n     }\n \n     fn fast_reject_trait_refs(&mut self,\n@@ -2332,9 +2298,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                     where_clause_trait_ref: ty::PolyTraitRef<'tcx>)\n                                     -> Result<Vec<PredicateObligation<'tcx>>,()>\n     {\n-        let () =\n-            try!(self.match_poly_trait_ref(obligation, where_clause_trait_ref));\n-\n+        try!(self.match_poly_trait_ref(obligation, where_clause_trait_ref));\n         Ok(Vec::new())\n     }\n \n@@ -2451,7 +2415,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n \n         match self.tcx().trait_impls.borrow().get(&trait_def_id) {\n             None => Vec::new(),\n-            Some(impls) => impls.borrow().clone()\n+            Some(impls) => impls.borrow().clone(),\n         }\n     }\n \n@@ -2549,9 +2513,7 @@ impl<'tcx> Repr<'tcx> for SelectionCandidate<'tcx> {\n             DefaultImplCandidate(t) => format!(\"DefaultImplCandidate({:?})\", t),\n             ProjectionCandidate => format!(\"ProjectionCandidate\"),\n             FnPointerCandidate => format!(\"FnPointerCandidate\"),\n-            ObjectCandidate => {\n-                format!(\"ObjectCandidate\")\n-            }\n+            ObjectCandidate => format!(\"ObjectCandidate\"),\n             ClosureCandidate(c, ref s) => {\n                 format!(\"ClosureCandidate({:?},{})\", c, s.repr(tcx))\n             }\n@@ -2582,9 +2544,7 @@ impl<'o, 'tcx> Iterator for Option<&'o TraitObligationStack<'o, 'tcx>> {\n                 *self = o.previous;\n                 Some(o)\n             }\n-            None => {\n-                None\n-            }\n+            None => None\n         }\n     }\n }\n@@ -2599,15 +2559,11 @@ impl<'o, 'tcx> Repr<'tcx> for TraitObligationStack<'o, 'tcx> {\n impl<'tcx> EvaluationResult<'tcx> {\n     fn may_apply(&self) -> bool {\n         match *self {\n-            EvaluatedToOk |\n-            EvaluatedToAmbig |\n-            EvaluatedToErr(Overflow) |\n-            EvaluatedToErr(OutputTypeParameterMismatch(..)) => {\n-                true\n-            }\n-            EvaluatedToErr(Unimplemented) => {\n-                false\n-            }\n+            EvaluatedToOk\n+            | EvaluatedToAmbig\n+            | EvaluatedToErr(Overflow)\n+            | EvaluatedToErr(OutputTypeParameterMismatch(..)) => true,\n+            EvaluatedToErr(Unimplemented) => false,\n         }\n     }\n }"}, {"sha": "a419d4134b40e4677faba9b0355848ccc5e1b98a", "filename": "src/librustc/plugin/load.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibrustc%2Fplugin%2Fload.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibrustc%2Fplugin%2Fload.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fplugin%2Fload.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -15,7 +15,7 @@ use metadata::creader::CrateReader;\n use plugin::registry::Registry;\n \n use std::mem;\n-use std::env;\n+use std::os;\n use std::dynamic_lib::DynamicLibrary;\n use std::borrow::ToOwned;\n use syntax::ast;\n@@ -103,7 +103,7 @@ impl<'a> PluginLoader<'a> {\n                         path: Path,\n                         symbol: String) -> PluginRegistrarFun {\n         // Make sure the path contains a / or the linker will search for it.\n-        let path = env::current_dir().unwrap().join(&path);\n+        let path = os::getcwd().unwrap().join(&path);\n \n         let lib = match DynamicLibrary::open(Some(&path)) {\n             Ok(lib) => lib,"}, {"sha": "99b2fce0607686193070e53e859611f6f4efd639", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -27,8 +27,8 @@ use syntax::{ast, codemap};\n \n use rustc_back::target::Target;\n \n-use std::env;\n use std::cell::{Cell, RefCell};\n+use std::os;\n \n pub mod config;\n pub mod search_paths;\n@@ -356,7 +356,7 @@ pub fn build_session_(sopts: config::Options,\n         if path.is_absolute() {\n             path.clone()\n         } else {\n-            env::current_dir().unwrap().join(&path)\n+            os::getcwd().unwrap().join(&path)\n         }\n     );\n \n@@ -379,7 +379,7 @@ pub fn build_session_(sopts: config::Options,\n         plugin_registrar_fn: Cell::new(None),\n         default_sysroot: default_sysroot,\n         local_crate_source_file: local_crate_source_file,\n-        working_dir: env::current_dir().unwrap(),\n+        working_dir: os::getcwd().unwrap(),\n         lint_store: RefCell::new(lint::LintStore::new()),\n         lints: RefCell::new(NodeMap()),\n         crate_types: RefCell::new(Vec::new()),"}, {"sha": "3fcae6a8034c207ac3408c2beb3ea76bdf2f97cb", "filename": "src/librustc_back/archive.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibrustc_back%2Farchive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibrustc_back%2Farchive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Farchive.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -14,7 +14,7 @@ use std::old_io::fs::PathExtensions;\n use std::old_io::process::{Command, ProcessOutput};\n use std::old_io::{fs, TempDir};\n use std::old_io;\n-use std::env;\n+use std::os;\n use std::str;\n use syntax::diagnostic::Handler as ErrorHandler;\n \n@@ -224,7 +224,7 @@ impl<'a> ArchiveBuilder<'a> {\n     pub fn build(self) -> Archive<'a> {\n         // Get an absolute path to the destination, so `ar` will work even\n         // though we run it from `self.work_dir`.\n-        let abs_dst = env::current_dir().unwrap().join(&self.archive.dst);\n+        let abs_dst = os::getcwd().unwrap().join(&self.archive.dst);\n         assert!(!abs_dst.is_relative());\n         let mut args = vec![&abs_dst];\n         let mut total_len = abs_dst.as_vec().len();\n@@ -283,7 +283,7 @@ impl<'a> ArchiveBuilder<'a> {\n         // First, extract the contents of the archive to a temporary directory.\n         // We don't unpack directly into `self.work_dir` due to the possibility\n         // of filename collisions.\n-        let archive = env::current_dir().unwrap().join(archive);\n+        let archive = os::getcwd().unwrap().join(archive);\n         run_ar(self.archive.handler, &self.archive.maybe_ar_prog,\n                \"x\", Some(loc.path()), &[&archive]);\n "}, {"sha": "99a1df95a80cddf398549aa2226f3d48fb2be119", "filename": "src/librustc_back/fs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibrustc_back%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibrustc_back%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ffs.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -10,13 +10,13 @@\n \n use std::old_io;\n use std::old_io::fs;\n-use std::env;\n+use std::os;\n \n /// Returns an absolute path in the filesystem that `path` points to. The\n /// returned path does not contain any symlinks in its hierarchy.\n pub fn realpath(original: &Path) -> old_io::IoResult<Path> {\n     static MAX_LINKS_FOLLOWED: uint = 256;\n-    let original = try!(env::current_dir()).join(original);\n+    let original = try!(os::getcwd()).join(original);\n \n     // Right now lstat on windows doesn't work quite well\n     if cfg!(windows) {"}, {"sha": "711f937d2f355991e5cc6ac1f97b6d47ffb93734", "filename": "src/librustc_back/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibrustc_back%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibrustc_back%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Flib.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -41,6 +41,7 @@\n #![feature(rustc_private)]\n #![feature(staged_api)]\n #![feature(env)]\n+#![feature(path)]\n \n extern crate syntax;\n extern crate serialize;"}, {"sha": "943ff52925a244545de15c4856f252db57bf7991", "filename": "src/librustc_back/rpath.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibrustc_back%2Frpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibrustc_back%2Frpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Frpath.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -8,10 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-\n use std::collections::HashSet;\n use std::env;\n use std::old_io::IoError;\n+use std::os;\n use syntax::ast;\n \n pub struct RPathConfig<F, G> where\n@@ -109,7 +109,7 @@ fn get_rpath_relative_to_output<F, G>(config: &mut RPathConfig<F, G>, lib: &Path\n         \"$ORIGIN\"\n     };\n \n-    let cwd = env::current_dir().unwrap();\n+    let cwd = os::getcwd().unwrap();\n     let mut lib = (config.realpath)(&cwd.join(lib)).unwrap();\n     lib.pop();\n     let mut output = (config.realpath)(&cwd.join(&config.out_filename)).unwrap();\n@@ -129,7 +129,7 @@ fn get_install_prefix_rpath<F, G>(config: RPathConfig<F, G>) -> String where\n     let path = (config.get_install_prefix_lib_path)();\n     let path = env::current_dir().unwrap().join(&path);\n     // FIXME (#9639): This needs to handle non-utf8 paths\n-    path.as_str().expect(\"non-utf8 component in rpath\").to_string()\n+    path.to_str().expect(\"non-utf8 component in rpath\").to_string()\n }\n \n fn minimize_rpaths(rpaths: &[String]) -> Vec<String> {"}, {"sha": "d09a7c355d3e3c32ef00aa2d1f819f1d9d39ff26", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -310,6 +310,7 @@ impl Target {\n     /// JSON decoding.\n     pub fn search(target: &str) -> Result<Target, String> {\n         use std::env;\n+        use std::os;\n         use std::ffi::OsString;\n         use std::old_io::File;\n         use std::old_path::Path;\n@@ -396,7 +397,7 @@ impl Target {\n \n         // FIXME 16351: add a sane default search path?\n \n-        for dir in env::split_paths(&target_path) {\n+        for dir in os::split_paths(target_path.to_str().unwrap()).iter() {\n             let p =  dir.join(path.clone());\n             if p.is_file() {\n                 return load_file(&p);"}, {"sha": "67462ab01003e29ec33f3f21e3a1cd1998ee3bfa", "filename": "src/librustc_borrowck/borrowck/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_borrowck%2Fborrowck%2Fmod.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -105,10 +105,10 @@ fn borrowck_item(this: &mut BorrowckCtxt, item: &ast::Item) {\n         ast::ItemConst(_, ref ex) => {\n             gather_loans::gather_loans_in_static_initializer(this, &**ex);\n         }\n-        _ => {\n-            visit::walk_item(this, item);\n-        }\n+        _ => { }\n     }\n+\n+    visit::walk_item(this, item);\n }\n \n /// Collection of conclusions determined via borrow checker analyses."}, {"sha": "425ec7ec452eecd4b2347c36a5d32257f7accf01", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -32,6 +32,7 @@ use super::Compilation;\n use serialize::json;\n \n use std::env;\n+use std::os;\n use std::ffi::OsString;\n use std::old_io::fs;\n use std::old_io;\n@@ -471,7 +472,7 @@ pub fn phase_2_configure_and_expand(sess: &Session,\n             if cfg!(windows) {\n                 _old_path = env::var_os(\"PATH\").unwrap_or(_old_path);\n                 let mut new_path = sess.host_filesearch(PathKind::All).get_dylib_search_paths();\n-                new_path.extend(env::split_paths(&_old_path));\n+                new_path.extend(os::split_paths(_old_path.to_str().unwrap()).into_iter());\n                 env::set_var(\"PATH\", &env::join_paths(new_path.iter()).unwrap());\n             }\n             let features = sess.features.borrow();\n@@ -736,7 +737,7 @@ pub fn phase_6_link_output(sess: &Session,\n                            outputs: &OutputFilenames) {\n     let old_path = env::var_os(\"PATH\").unwrap_or(OsString::from_str(\"\"));\n     let mut new_path = sess.host_filesearch(PathKind::All).get_tools_search_paths();\n-    new_path.extend(env::split_paths(&old_path));\n+    new_path.extend(os::split_paths(old_path.to_str().unwrap()).into_iter());\n     env::set_var(\"PATH\", &env::join_paths(new_path.iter()).unwrap());\n \n     time(sess.time_passes(), \"linking\", (), |_|"}, {"sha": "d9cedc482985155e84445cc947292d222e412359", "filename": "src/librustc_driver/test.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibrustc_driver%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibrustc_driver%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Ftest.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -806,11 +806,11 @@ fn walk_ty() {\n         let tup2_ty = ty::mk_tup(tcx, vec!(tup1_ty, tup1_ty, uint_ty));\n         let uniq_ty = ty::mk_uniq(tcx, tup2_ty);\n         let walked: Vec<_> = uniq_ty.walk().collect();\n-        assert_eq!(vec!(uniq_ty,\n-                        tup2_ty,\n-                        tup1_ty, int_ty, uint_ty, int_ty, uint_ty,\n-                        tup1_ty, int_ty, uint_ty, int_ty, uint_ty,\n-                        uint_ty),\n+        assert_eq!([uniq_ty,\n+                    tup2_ty,\n+                    tup1_ty, int_ty, uint_ty, int_ty, uint_ty,\n+                    tup1_ty, int_ty, uint_ty, int_ty, uint_ty,\n+                    uint_ty],\n                    walked);\n     })\n }"}, {"sha": "c1d22cc973c240c209b88dce5d1d5c8728c2eb70", "filename": "src/librustc_trans/trans/consts.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fconsts.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -359,7 +359,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n     };\n     unsafe {\n         let _icx = push_ctxt(\"const_expr\");\n-        return match e.node {\n+        match e.node {\n           ast::ExprLit(ref lit) => {\n               const_lit(cx, e, &**lit)\n           }\n@@ -379,7 +379,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             let (te2, _) = const_expr(cx, &**e2, param_substs);\n             let te2 = base::cast_shift_const_rhs(b, te1, te2);\n \n-            return match b.node {\n+            match b.node {\n               ast::BiAdd   => {\n                 if is_float { llvm::LLVMConstFAdd(te1, te2) }\n                 else        { llvm::LLVMConstAdd(te1, te2) }\n@@ -433,7 +433,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n           ast::ExprUnary(u, ref e) => {\n             let (te, ty) = const_expr(cx, &**e, param_substs);\n             let is_float = ty::type_is_fp(ty);\n-            return match u {\n+            match u {\n               ast::UnUniq | ast::UnDeref => {\n                 const_deref(cx, te, ty).0\n               }\n@@ -514,8 +514,8 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n             if expr::cast_is_noop(basety, ety) {\n                 return v;\n             }\n-            return match (expr::cast_type_kind(cx.tcx(), basety),\n-                           expr::cast_type_kind(cx.tcx(), ety)) {\n+            match (expr::cast_type_kind(cx.tcx(), basety),\n+                   expr::cast_type_kind(cx.tcx(), ety)) {\n \n               (expr::cast_integral, expr::cast_integral) => {\n                 let s = ty::type_is_signed(basety) as Bool;\n@@ -584,13 +584,13 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n               }\n               let opt_def = cx.tcx().def_map.borrow().get(&cur.id).map(|d| d.full_def());\n               if let Some(def::DefStatic(def_id, _)) = opt_def {\n-                  return get_static_val(cx, def_id, ety);\n+                  get_static_val(cx, def_id, ety)\n+              } else {\n+                  // If this isn't the address of a static, then keep going through\n+                  // normal constant evaluation.\n+                  let (v, _) = const_expr(cx, &**sub, param_substs);\n+                  addr_of(cx, v, \"ref\", e.id)\n               }\n-\n-              // If this isn't the address of a static, then keep going through\n-              // normal constant evaluation.\n-              let (v, _) = const_expr(cx, &**sub, param_substs);\n-              addr_of(cx, v, \"ref\", e.id)\n           }\n           ast::ExprAddrOf(ast::MutMutable, ref sub) => {\n               let (v, _) = const_expr(cx, &**sub, param_substs);\n@@ -740,7 +740,7 @@ fn const_expr_unadjusted<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n           }\n           _ => cx.sess().span_bug(e.span,\n                   \"bad constant expression type in consts::const_expr\")\n-        };\n+        }\n     }\n }\n "}, {"sha": "1fba4a21ccd376a61ab08fbc52609e1cb9b32b50", "filename": "src/librustc_typeck/variance.rs", "status": "modified", "additions": 63, "deletions": 2, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibrustc_typeck%2Fvariance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibrustc_typeck%2Fvariance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fvariance.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -203,6 +203,56 @@\n //! failure, but rather because the target type `Foo<Y>` is itself just\n //! not well-formed. Basically we get to assume well-formedness of all\n //! types involved before considering variance.\n+//!\n+//! ### Associated types\n+//!\n+//! Any trait with an associated type is invariant with respect to all\n+//! of its inputs. To see why this makes sense, consider what\n+//! subtyping for a trait reference means:\n+//!\n+//!    <T as Trait> <: <U as Trait>\n+//!\n+//! means that if I know that `T as Trait`,\n+//! I also know that `U as\n+//! Trait`. Moreover, if you think of it as\n+//! dictionary passing style, it means that\n+//! a dictionary for `<T as Trait>` is safe\n+//! to use where a dictionary for `<U as\n+//! Trait>` is expected.\n+//!\n+//! The problem is that when you can\n+//! project types out from `<T as Trait>`,\n+//! the relationship to types projected out\n+//! of `<U as Trait>` is completely unknown\n+//! unless `T==U` (see #21726 for more\n+//! details). Making `Trait` invariant\n+//! ensures that this is true.\n+//!\n+//! *Historical note: we used to preserve this invariant another way,\n+//! by tweaking the subtyping rules and requiring that when a type `T`\n+//! appeared as part of a projection, that was considered an invariant\n+//! location, but this version does away with the need for those\n+//! somewhat \"special-case-feeling\" rules.*\n+//!\n+//! Another related reason is that if we didn't make traits with\n+//! associated types invariant, then projection is no longer a\n+//! function with a single result. Consider:\n+//!\n+//! ```\n+//! trait Identity { type Out; fn foo(&self); }\n+//! impl<T> Identity for T { type Out = T; ... }\n+//! ```\n+//!\n+//! Now if I have `<&'static () as Identity>::Out`, this can be\n+//! validly derived as `&'a ()` for any `'a`:\n+//!\n+//!    <&'a () as Identity> <: <&'static () as Identity>\n+//!    if &'static () < : &'a ()   -- Identity is contravariant in Self\n+//!    if 'static : 'a             -- Subtyping rules for relations\n+//!\n+//! This change otoh means that `<'static () as Identity>::Out` is\n+//! always `&'static ()` (which might then be upcast to `'a ()`,\n+//! separately). This was helpful in solving #21750.\n \n use self::VarianceTerm::*;\n use self::ParamKind::*;\n@@ -613,7 +663,18 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ConstraintContext<'a, 'tcx> {\n                                 &method.fty.sig,\n                                 self.covariant);\n                         }\n-                        ty::TypeTraitItem(_) => {}\n+                        ty::TypeTraitItem(ref data) => {\n+                            // Any trait with an associated type is\n+                            // invariant with respect to all of its\n+                            // inputs. See length discussion in the comment\n+                            // on this module.\n+                            let projection_ty = ty::mk_projection(tcx,\n+                                                                  trait_def.trait_ref.clone(),\n+                                                                  data.name);\n+                            self.add_constraints_from_ty(&trait_def.generics,\n+                                                         projection_ty,\n+                                                         self.invariant);\n+                        }\n                     }\n                 }\n             }\n@@ -893,7 +954,7 @@ impl<'a, 'tcx> ConstraintContext<'a, 'tcx> {\n                     trait_def.generics.types.as_slice(),\n                     trait_def.generics.regions.as_slice(),\n                     trait_ref.substs,\n-                    self.invariant);\n+                    variance);\n             }\n \n             ty::ty_trait(ref data) => {"}, {"sha": "78f126dcf6a827d438057e6cd074c2a7a47e853e", "filename": "src/librustdoc/test.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibrustdoc%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibrustdoc%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Ftest.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -13,7 +13,7 @@ use std::sync::mpsc::channel;\n use std::dynamic_lib::DynamicLibrary;\n use std::old_io::{Command, TempDir};\n use std::old_io;\n-use std::env;\n+use std::os;\n use std::str;\n use std::thread;\n use std::thunk::Thunk;\n@@ -46,7 +46,7 @@ pub fn run(input: &str,\n     let input = config::Input::File(input_path.clone());\n \n     let sessopts = config::Options {\n-        maybe_sysroot: Some(env::current_exe().unwrap().dir_path().dir_path()),\n+        maybe_sysroot: Some(os::self_exe_name().unwrap().dir_path().dir_path()),\n         search_paths: libs.clone(),\n         crate_types: vec!(config::CrateTypeDylib),\n         externs: externs.clone(),\n@@ -113,7 +113,7 @@ fn runtest(test: &str, cratename: &str, libs: SearchPaths,\n     let input = config::Input::Str(test.to_string());\n \n     let sessopts = config::Options {\n-        maybe_sysroot: Some(env::current_exe().unwrap().dir_path().dir_path()),\n+        maybe_sysroot: Some(os::self_exe_name().unwrap().dir_path().dir_path()),\n         search_paths: libs,\n         crate_types: vec!(config::CrateTypeExecutable),\n         output_types: vec!(config::OutputTypeExe),"}, {"sha": "05d4e0f59fefc4d1732c83ec6ff588deda10df5d", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -3074,19 +3074,19 @@ mod tests {\n     #[test]\n     fn test_decode_array() {\n         let v: Vec<()> = super::decode(\"[]\").unwrap();\n-        assert_eq!(v, vec![]);\n+        assert_eq!(v, []);\n \n         let v: Vec<()> = super::decode(\"[null]\").unwrap();\n-        assert_eq!(v, vec![()]);\n+        assert_eq!(v, [()]);\n \n         let v: Vec<bool> = super::decode(\"[true]\").unwrap();\n-        assert_eq!(v, vec![true]);\n+        assert_eq!(v, [true]);\n \n         let v: Vec<int> = super::decode(\"[3, 1]\").unwrap();\n-        assert_eq!(v, vec![3, 1]);\n+        assert_eq!(v, [3, 1]);\n \n         let v: Vec<Vec<uint>> = super::decode(\"[[3], [1, 2]]\").unwrap();\n-        assert_eq!(v, vec![vec![3], vec![1, 2]]);\n+        assert_eq!(v, [vec![3], vec![1, 2]]);\n     }\n \n     #[test]"}, {"sha": "faddbba50590f9ce1a87499ef7db2a299e21b038", "filename": "src/libstd/collections/hash/map.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fmap.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -1212,7 +1212,7 @@ impl<K, V, S> Debug for HashMap<K, V, S>\n     where K: Eq + Hash + Debug, V: Debug, S: HashState\n {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(f, \"HashMap {{\"));\n+        try!(write!(f, \"{{\"));\n \n         for (i, (k, v)) in self.iter().enumerate() {\n             if i != 0 { try!(write!(f, \", \")); }\n@@ -1999,9 +1999,9 @@ mod test_map {\n \n         let map_str = format!(\"{:?}\", map);\n \n-        assert!(map_str == \"HashMap {1: 2, 3: 4}\" ||\n-                map_str == \"HashMap {3: 4, 1: 2}\");\n-        assert_eq!(format!(\"{:?}\", empty), \"HashMap {}\");\n+        assert!(map_str == \"{1: 2, 3: 4}\" ||\n+                map_str == \"{3: 4, 1: 2}\");\n+        assert_eq!(format!(\"{:?}\", empty), \"{}\");\n     }\n \n     #[test]"}, {"sha": "cdc0ebd76aada5d823709363e9c96203211cf0dd", "filename": "src/libstd/collections/hash/set.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Fset.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -598,7 +598,7 @@ impl<T, S> fmt::Debug for HashSet<T, S>\n           S: HashState\n {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        try!(write!(f, \"HashSet {{\"));\n+        try!(write!(f, \"{{\"));\n \n         for (i, x) in self.iter().enumerate() {\n             if i != 0 { try!(write!(f, \", \")); }\n@@ -1186,8 +1186,8 @@ mod test_set {\n \n         let set_str = format!(\"{:?}\", set);\n \n-        assert!(set_str == \"HashSet {1, 2}\" || set_str == \"HashSet {2, 1}\");\n-        assert_eq!(format!(\"{:?}\", empty), \"HashSet {}\");\n+        assert!(set_str == \"{1, 2}\" || set_str == \"{2, 1}\");\n+        assert_eq!(format!(\"{:?}\", empty), \"{}\");\n     }\n \n     #[test]"}, {"sha": "4c03d8915eb8a04ca0909e022739eb6c38ade22a", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -23,7 +23,7 @@ use num::{Int, UnsignedInt};\n use ops::{Deref, DerefMut, Drop};\n use option::Option;\n use option::Option::{Some, None};\n-use ptr::{self, PtrExt, copy_nonoverlapping_memory, Unique, zero_memory};\n+use ptr::{self, PtrExt, Unique};\n use rt::heap::{allocate, deallocate, EMPTY};\n use collections::hash_state::HashState;\n \n@@ -477,8 +477,8 @@ impl<K, V, M: Deref<Target=RawTable<K, V>>> GapThenFull<K, V, M> {\n     pub fn shift(mut self) -> Option<GapThenFull<K, V, M>> {\n         unsafe {\n             *self.gap.raw.hash = mem::replace(&mut *self.full.raw.hash, EMPTY_BUCKET);\n-            copy_nonoverlapping_memory(self.gap.raw.key, self.full.raw.key, 1);\n-            copy_nonoverlapping_memory(self.gap.raw.val, self.full.raw.val, 1);\n+            ptr::copy_nonoverlapping(self.gap.raw.key, self.full.raw.key, 1);\n+            ptr::copy_nonoverlapping(self.gap.raw.val, self.full.raw.val, 1);\n         }\n \n         let FullBucket { raw: prev_raw, idx: prev_idx, .. } = self.full;\n@@ -637,7 +637,7 @@ impl<K, V> RawTable<K, V> {\n     pub fn new(capacity: usize) -> RawTable<K, V> {\n         unsafe {\n             let ret = RawTable::new_uninitialized(capacity);\n-            zero_memory(*ret.hashes, capacity);\n+            ptr::write_bytes(*ret.hashes, 0, capacity);\n             ret\n         }\n     }"}, {"sha": "babae3b3019ec18c33d01b2749c4395d4ae7bd13", "filename": "src/libstd/dynamic_lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Fdynamic_lib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Fdynamic_lib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fdynamic_lib.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -21,6 +21,7 @@ use ffi::CString;\n use mem;\n use env;\n use str;\n+use os;\n \n pub struct DynamicLibrary {\n     handle: *mut u8\n@@ -102,7 +103,7 @@ impl DynamicLibrary {\n     /// process\n     pub fn search_path() -> Vec<Path> {\n         match env::var_os(DynamicLibrary::envvar()) {\n-            Some(var) => env::split_paths(&var).collect(),\n+            Some(var) => os::split_paths(var.to_str().unwrap()),\n             None => Vec::new(),\n         }\n     }"}, {"sha": "e2849ec92e08835f007cdbaba0e1901b84a3f477", "filename": "src/libstd/env.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fenv.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -21,7 +21,8 @@ use prelude::v1::*;\n use error::Error;\n use ffi::{OsString, AsOsStr};\n use fmt;\n-use old_io::IoResult;\n+use io;\n+use path::{AsPath, PathBuf};\n use sync::atomic::{AtomicIsize, ATOMIC_ISIZE_INIT, Ordering};\n use sync::{StaticMutex, MUTEX_INIT};\n use sys::os as os_imp;\n@@ -46,7 +47,7 @@ use sys::os as os_imp;\n /// let p = env::current_dir().unwrap();\n /// println!(\"The current directory is {}\", p.display());\n /// ```\n-pub fn current_dir() -> IoResult<Path> {\n+pub fn current_dir() -> io::Result<PathBuf> {\n     os_imp::getcwd()\n }\n \n@@ -57,14 +58,14 @@ pub fn current_dir() -> IoResult<Path> {\n ///\n /// ```rust\n /// use std::env;\n-/// use std::old_path::Path;\n+/// use std::path::Path;\n ///\n /// let root = Path::new(\"/\");\n /// assert!(env::set_current_dir(&root).is_ok());\n /// println!(\"Successfully changed working directory to {}!\", root.display());\n /// ```\n-pub fn set_current_dir(p: &Path) -> IoResult<()> {\n-    os_imp::chdir(p)\n+pub fn set_current_dir<P: AsPath + ?Sized>(p: &P) -> io::Result<()> {\n+    os_imp::chdir(p.as_path())\n }\n \n static ENV_LOCK: StaticMutex = MUTEX_INIT;\n@@ -280,8 +281,8 @@ pub fn split_paths<T: AsOsStr + ?Sized>(unparsed: &T) -> SplitPaths {\n }\n \n impl<'a> Iterator for SplitPaths<'a> {\n-    type Item = Path;\n-    fn next(&mut self) -> Option<Path> { self.inner.next() }\n+    type Item = PathBuf;\n+    fn next(&mut self) -> Option<PathBuf> { self.inner.next() }\n     fn size_hint(&self) -> (usize, Option<usize>) { self.inner.size_hint() }\n }\n \n@@ -305,10 +306,11 @@ pub struct JoinPathsError {\n ///\n /// ```rust\n /// use std::env;\n+/// use std::path::PathBuf;\n ///\n /// if let Some(path) = env::var_os(\"PATH\") {\n ///     let mut paths = env::split_paths(&path).collect::<Vec<_>>();\n-///     paths.push(Path::new(\"/home/xyz/bin\"));\n+///     paths.push(PathBuf::new(\"/home/xyz/bin\"));\n ///     let new_path = env::join_paths(paths.iter()).unwrap();\n ///     env::set_var(\"PATH\", &new_path);\n /// }\n@@ -355,7 +357,7 @@ impl Error for JoinPathsError {\n ///     None => println!(\"Impossible to get your home dir!\")\n /// }\n /// ```\n-pub fn home_dir() -> Option<Path> {\n+pub fn home_dir() -> Option<PathBuf> {\n     os_imp::home_dir()\n }\n \n@@ -369,7 +371,7 @@ pub fn home_dir() -> Option<Path> {\n /// On Windows, returns the value of, in order, the 'TMP', 'TEMP',\n /// 'USERPROFILE' environment variable  if any are set and not the empty\n /// string. Otherwise, tmpdir returns the path to the Windows directory.\n-pub fn temp_dir() -> Path {\n+pub fn temp_dir() -> PathBuf {\n     os_imp::temp_dir()\n }\n \n@@ -396,7 +398,7 @@ pub fn temp_dir() -> Path {\n ///     Err(e) => println!(\"failed to get current exe path: {}\", e),\n /// };\n /// ```\n-pub fn current_exe() -> IoResult<Path> {\n+pub fn current_exe() -> io::Result<PathBuf> {\n     os_imp::current_exe()\n }\n \n@@ -825,6 +827,7 @@ mod tests {\n     use iter::repeat;\n     use rand::{self, Rng};\n     use ffi::{OsString, OsStr};\n+    use path::PathBuf;\n \n     fn make_rand_name() -> OsString {\n         let mut rng = rand::thread_rng();\n@@ -924,7 +927,7 @@ mod tests {\n     fn split_paths_windows() {\n         fn check_parse(unparsed: &str, parsed: &[&str]) -> bool {\n             split_paths(unparsed).collect::<Vec<_>>() ==\n-                parsed.iter().map(|s| Path::new(*s)).collect::<Vec<_>>()\n+                parsed.iter().map(|s| PathBuf::new(*s)).collect::<Vec<_>>()\n         }\n \n         assert!(check_parse(\"\", &mut [\"\"]));\n@@ -944,7 +947,7 @@ mod tests {\n     fn split_paths_unix() {\n         fn check_parse(unparsed: &str, parsed: &[&str]) -> bool {\n             split_paths(unparsed).collect::<Vec<_>>() ==\n-                parsed.iter().map(|s| Path::new(*s)).collect::<Vec<_>>()\n+                parsed.iter().map(|s| PathBuf::new(*s)).collect::<Vec<_>>()\n         }\n \n         assert!(check_parse(\"\", &mut [\"\"]));"}, {"sha": "64ec025a5c423bc087426f835ef43aef8e93eb5e", "filename": "src/libstd/fs/mod.rs", "status": "renamed", "additions": 23, "deletions": 1, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Ffs%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Ffs%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs%2Fmod.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -25,6 +25,10 @@ use sys::fs2 as fs_imp;\n use sys_common::{AsInnerMut, FromInner, AsInner};\n use vec::Vec;\n \n+pub use self::tempdir::TempDir;\n+\n+mod tempdir;\n+\n /// A reference to an open file on the filesystem.\n ///\n /// An instance of a `File` can be read and/or written depending on what options\n@@ -325,6 +329,10 @@ impl FromInner<fs_imp::FilePermissions> for Permissions {\n     }\n }\n \n+impl AsInner<fs_imp::FilePermissions> for Permissions {\n+    fn as_inner(&self) -> &fs_imp::FilePermissions { &self.0 }\n+}\n+\n impl Iterator for ReadDir {\n     type Item = io::Result<DirEntry>;\n \n@@ -540,7 +548,14 @@ pub fn create_dir_all<P: AsPath + ?Sized>(path: &P) -> io::Result<()> {\n         Some(p) if p != path => try!(create_dir_all(p)),\n         _ => {}\n     }\n-    create_dir(path)\n+    // If the file name of the given `path` is blank then the creation of the\n+    // parent directory will have taken care of the whole path for us, so we're\n+    // good to go.\n+    if path.file_name().is_none() {\n+        Ok(())\n+    } else {\n+        create_dir(path)\n+    }\n }\n \n /// Remove an existing, empty directory\n@@ -1500,4 +1515,11 @@ mod tests {\n         check!(fs::set_permissions(&path, perm));\n         check!(fs::remove_file(&path));\n     }\n+\n+    #[test]\n+    fn mkdir_trailing_slash() {\n+        let tmpdir = tmpdir();\n+        let path = tmpdir.join(\"file\");\n+        check!(fs::create_dir_all(&path.join(\"a/\")));\n+    }\n }", "previous_filename": "src/libstd/fs.rs"}, {"sha": "79bdb35dd48cd3b6ebc1e3f9b5d5d6004be241c0", "filename": "src/libstd/fs/tempdir.rs", "status": "added", "additions": 125, "deletions": 0, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Ffs%2Ftempdir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Ffs%2Ftempdir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ffs%2Ftempdir.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -0,0 +1,125 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![unstable(feature = \"tempdir\", reason = \"needs an RFC before stabilization\")]\n+\n+use prelude::v1::*;\n+\n+use env;\n+use io::{self, Error, ErrorKind};\n+use fs;\n+use path::{self, PathBuf, AsPath};\n+use rand::{thread_rng, Rng};\n+\n+/// A wrapper for a path to temporary directory implementing automatic\n+/// scope-based deletion.\n+pub struct TempDir {\n+    path: Option<PathBuf>,\n+}\n+\n+// How many times should we (re)try finding an unused random name? It should be\n+// enough that an attacker will run out of luck before we run out of patience.\n+const NUM_RETRIES: u32 = 1 << 31;\n+// How many characters should we include in a random file name? It needs to\n+// be enough to dissuade an attacker from trying to preemptively create names\n+// of that length, but not so huge that we unnecessarily drain the random number\n+// generator of entropy.\n+const NUM_RAND_CHARS: uint = 12;\n+\n+impl TempDir {\n+    /// Attempts to make a temporary directory inside of `tmpdir` whose name\n+    /// will have the prefix `prefix`. The directory will be automatically\n+    /// deleted once the returned wrapper is destroyed.\n+    ///\n+    /// If no directory can be created, `Err` is returned.\n+    #[allow(deprecated)] // rand usage\n+    pub fn new_in<P: AsPath + ?Sized>(tmpdir: &P, prefix: &str)\n+                                      -> io::Result<TempDir> {\n+        let storage;\n+        let mut tmpdir = tmpdir.as_path();\n+        if !tmpdir.is_absolute() {\n+            let cur_dir = try!(env::current_dir());\n+            storage = cur_dir.join(tmpdir);\n+            tmpdir = &storage;\n+            // return TempDir::new_in(&cur_dir.join(tmpdir), prefix);\n+        }\n+\n+        let mut rng = thread_rng();\n+        for _ in 0..NUM_RETRIES {\n+            let suffix: String = rng.gen_ascii_chars().take(NUM_RAND_CHARS).collect();\n+            let leaf = if prefix.len() > 0 {\n+                format!(\"{}.{}\", prefix, suffix)\n+            } else {\n+                // If we're given an empty string for a prefix, then creating a\n+                // directory starting with \".\" would lead to it being\n+                // semi-invisible on some systems.\n+                suffix\n+            };\n+            let path = tmpdir.join(&leaf);\n+            match fs::create_dir(&path) {\n+                Ok(_) => return Ok(TempDir { path: Some(path) }),\n+                Err(ref e) if e.kind() == ErrorKind::PathAlreadyExists => {}\n+                Err(e) => return Err(e)\n+            }\n+        }\n+\n+        Err(Error::new(ErrorKind::PathAlreadyExists,\n+                       \"too many temporary directories already exist\",\n+                       None))\n+    }\n+\n+    /// Attempts to make a temporary directory inside of `env::temp_dir()` whose\n+    /// name will have the prefix `prefix`. The directory will be automatically\n+    /// deleted once the returned wrapper is destroyed.\n+    ///\n+    /// If no directory can be created, `Err` is returned.\n+    #[allow(deprecated)]\n+    pub fn new(prefix: &str) -> io::Result<TempDir> {\n+        TempDir::new_in(&env::temp_dir(), prefix)\n+    }\n+\n+    /// Unwrap the wrapped `std::path::Path` from the `TempDir` wrapper.\n+    /// This discards the wrapper so that the automatic deletion of the\n+    /// temporary directory is prevented.\n+    pub fn into_path(mut self) -> PathBuf {\n+        self.path.take().unwrap()\n+    }\n+\n+    /// Access the wrapped `std::path::Path` to the temporary directory.\n+    pub fn path(&self) -> &path::Path {\n+        self.path.as_ref().unwrap()\n+    }\n+\n+    /// Close and remove the temporary directory\n+    ///\n+    /// Although `TempDir` removes the directory on drop, in the destructor\n+    /// any errors are ignored. To detect errors cleaning up the temporary\n+    /// directory, call `close` instead.\n+    pub fn close(mut self) -> io::Result<()> {\n+        self.cleanup_dir()\n+    }\n+\n+    fn cleanup_dir(&mut self) -> io::Result<()> {\n+        match self.path {\n+            Some(ref p) => fs::remove_dir_all(p),\n+            None => Ok(())\n+        }\n+    }\n+}\n+\n+impl Drop for TempDir {\n+    fn drop(&mut self) {\n+        let _ = self.cleanup_dir();\n+    }\n+}\n+\n+// the tests for this module need to change the path using change_dir,\n+// and this doesn't play nicely with other tests so these unit tests are located\n+// in src/test/run-pass/tempfile.rs"}, {"sha": "1135609959015d2fbee5d2565a0dd18affd69b7f", "filename": "src/libstd/io/buffered.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Fio%2Fbuffered.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Fio%2Fbuffered.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fbuffered.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -48,7 +48,7 @@ impl<R: Read> BufReader<R> {\n     }\n \n     /// Gets a reference to the underlying reader.\n-    pub fn get_ref<'a>(&self) -> &R { &self.inner }\n+    pub fn get_ref(&self) -> &R { &self.inner }\n \n     /// Gets a mutable reference to the underlying reader.\n     ///\n@@ -155,9 +155,9 @@ impl<W: Write> BufWriter<W> {\n         if written > 0 {\n             // NB: would be better expressed as .remove(0..n) if it existed\n             unsafe {\n-                ptr::copy_memory(self.buf.as_mut_ptr(),\n-                                 self.buf.as_ptr().offset(written as isize),\n-                                 len - written);\n+                ptr::copy(self.buf.as_mut_ptr(),\n+                          self.buf.as_ptr().offset(written as isize),\n+                          len - written);\n             }\n         }\n         self.buf.truncate(len - written);"}, {"sha": "b5bdeb7f181b0ddab0bebb3c25491c619d385ddc", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -123,6 +123,7 @@\n #![feature(unsafe_no_drop_flag)]\n #![feature(macro_reexport)]\n #![feature(hash)]\n+#![feature(unique)]\n #![cfg_attr(test, feature(test, rustc_private, env))]\n \n // Don't link to std. We are std."}, {"sha": "aec50d638c69f2393c116c1daa55a031107e7b4b", "filename": "src/libstd/net/test.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Fnet%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Fnet%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Ftest.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -34,6 +34,6 @@ fn base_port() -> u16 {\n     let dirs = [\"32-opt\", \"32-nopt\", \"64-opt\", \"64-nopt\", \"64-opt-vg\",\n                 \"all-opt\", \"snap3\", \"dist\"];\n     dirs.iter().enumerate().find(|&(_, dir)| {\n-        cwd.as_str().unwrap().contains(dir)\n+        cwd.to_str().unwrap().contains(dir)\n     }).map(|p| p.0).unwrap_or(0) as u16 * 1000 + 19600\n }"}, {"sha": "8bd19f063f0300c51cc9256b70f6c7f0d1aa5fba", "filename": "src/libstd/old_io/extensions.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Fold_io%2Fextensions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Fold_io%2Fextensions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fextensions.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -328,7 +328,7 @@ mod test {\n     fn read_bytes() {\n         let mut reader = MemReader::new(vec!(10, 11, 12, 13));\n         let bytes = reader.read_exact(4).unwrap();\n-        assert!(bytes == vec!(10, 11, 12, 13));\n+        assert_eq!(bytes, [10, 11, 12, 13]);\n     }\n \n     #[test]\n@@ -337,7 +337,7 @@ mod test {\n             count: 0,\n         };\n         let bytes = reader.read_exact(4).unwrap();\n-        assert!(bytes == vec!(10, 11, 12, 13));\n+        assert_eq!(bytes, [10, 11, 12, 13]);\n     }\n \n     #[test]\n@@ -351,7 +351,7 @@ mod test {\n         let mut reader = MemReader::new(vec![10, 11, 12, 13]);\n         let mut buf = vec![8, 9];\n         assert!(reader.push_at_least(4, 4, &mut buf).is_ok());\n-        assert!(buf == vec![8, 9, 10, 11, 12, 13]);\n+        assert_eq!(buf, [8, 9, 10, 11, 12, 13]);\n     }\n \n     #[test]\n@@ -361,15 +361,15 @@ mod test {\n         };\n         let mut buf = vec![8, 9];\n         assert!(reader.push_at_least(4, 4, &mut buf).is_ok());\n-        assert!(buf == vec![8, 9, 10, 11, 12, 13]);\n+        assert_eq!(buf, [8, 9, 10, 11, 12, 13]);\n     }\n \n     #[test]\n     fn push_at_least_eof() {\n         let mut reader = MemReader::new(vec![10, 11]);\n         let mut buf = vec![8, 9];\n         assert!(reader.push_at_least(4, 4, &mut buf).is_err());\n-        assert!(buf == vec![8, 9, 10, 11]);\n+        assert_eq!(buf, [8, 9, 10, 11]);\n     }\n \n     #[test]\n@@ -379,7 +379,7 @@ mod test {\n         };\n         let mut buf = vec![8, 9];\n         assert!(reader.push_at_least(4, 4, &mut buf).is_err());\n-        assert!(buf == vec![8, 9, 10]);\n+        assert_eq!(buf, [8, 9, 10]);\n     }\n \n     #[test]\n@@ -388,7 +388,7 @@ mod test {\n             count: 0,\n         };\n         let buf = reader.read_to_end().unwrap();\n-        assert!(buf == vec!(10, 11, 12, 13));\n+        assert_eq!(buf, [10, 11, 12, 13]);\n     }\n \n     #[test]\n@@ -398,7 +398,7 @@ mod test {\n             count: 0,\n         };\n         let buf = reader.read_to_end().unwrap();\n-        assert!(buf == vec!(10, 11));\n+        assert_eq!(buf, [10, 11]);\n     }\n \n     #[test]"}, {"sha": "c08a2c1f477b3ea6017fffbaff6e739d301af081", "filename": "src/libstd/old_io/mem.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Fold_io%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Fold_io%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fmem.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -60,7 +60,7 @@ impl Writer for Vec<u8> {\n /// let mut w = MemWriter::new();\n /// w.write(&[0, 1, 2]);\n ///\n-/// assert_eq!(w.into_inner(), vec!(0, 1, 2));\n+/// assert_eq!(w.into_inner(), [0, 1, 2]);\n /// ```\n #[unstable(feature = \"io\")]\n #[deprecated(since = \"1.0.0\",\n@@ -118,7 +118,7 @@ impl Writer for MemWriter {\n ///\n /// let mut r = MemReader::new(vec!(0, 1, 2));\n ///\n-/// assert_eq!(r.read_to_end().unwrap(), vec!(0, 1, 2));\n+/// assert_eq!(r.read_to_end().unwrap(), [0, 1, 2]);\n /// ```\n pub struct MemReader {\n     buf: Vec<u8>,\n@@ -321,7 +321,7 @@ impl<'a> Seek for BufWriter<'a> {\n /// let buf = [0, 1, 2, 3];\n /// let mut r = BufReader::new(&buf);\n ///\n-/// assert_eq!(r.read_to_end().unwrap(), vec![0, 1, 2, 3]);\n+/// assert_eq!(r.read_to_end().unwrap(), [0, 1, 2, 3]);\n /// ```\n pub struct BufReader<'a> {\n     buf: &'a [u8],\n@@ -504,8 +504,8 @@ mod test {\n         assert_eq!(&buf[..3], b);\n         assert!(reader.read(&mut buf).is_err());\n         let mut reader = MemReader::new(vec!(0, 1, 2, 3, 4, 5, 6, 7));\n-        assert_eq!(reader.read_until(3).unwrap(), vec!(0, 1, 2, 3));\n-        assert_eq!(reader.read_until(3).unwrap(), vec!(4, 5, 6, 7));\n+        assert_eq!(reader.read_until(3).unwrap(), [0, 1, 2, 3]);\n+        assert_eq!(reader.read_until(3).unwrap(), [4, 5, 6, 7]);\n         assert!(reader.read(&mut buf).is_err());\n     }\n \n@@ -530,8 +530,8 @@ mod test {\n         assert_eq!(&buf[..3], b);\n         assert!(reader.read(&mut buf).is_err());\n         let mut reader = &mut &*in_buf;\n-        assert_eq!(reader.read_until(3).unwrap(), vec!(0, 1, 2, 3));\n-        assert_eq!(reader.read_until(3).unwrap(), vec!(4, 5, 6, 7));\n+        assert_eq!(reader.read_until(3).unwrap(), [0, 1, 2, 3]);\n+        assert_eq!(reader.read_until(3).unwrap(), [4, 5, 6, 7]);\n         assert!(reader.read(&mut buf).is_err());\n     }\n \n@@ -557,8 +557,8 @@ mod test {\n         assert_eq!(&buf[..3], b);\n         assert!(reader.read(&mut buf).is_err());\n         let mut reader = BufReader::new(&in_buf);\n-        assert_eq!(reader.read_until(3).unwrap(), vec!(0, 1, 2, 3));\n-        assert_eq!(reader.read_until(3).unwrap(), vec!(4, 5, 6, 7));\n+        assert_eq!(reader.read_until(3).unwrap(), [0, 1, 2, 3]);\n+        assert_eq!(reader.read_until(3).unwrap(), [4, 5, 6, 7]);\n         assert!(reader.read(&mut buf).is_err());\n     }\n "}, {"sha": "cdf2bae1cbad3c260e28e36b682b1db6b1a4a201", "filename": "src/libstd/old_io/result.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Fold_io%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Fold_io%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Fresult.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -87,7 +87,7 @@ mod test {\n         let mut writer: old_io::IoResult<Vec<u8>> = Ok(Vec::new());\n         writer.write_all(&[0, 1, 2]).unwrap();\n         writer.flush().unwrap();\n-        assert_eq!(writer.unwrap(), vec!(0, 1, 2));\n+        assert_eq!(writer.unwrap(), [0, 1, 2]);\n     }\n \n     #[test]"}, {"sha": "76753dca52e1eec4dfdad70d862723c3b5e88427", "filename": "src/libstd/old_io/tempfile.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Fold_io%2Ftempfile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Fold_io%2Ftempfile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Ftempfile.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -96,9 +96,10 @@ impl TempDir {\n     /// deleted once the returned wrapper is destroyed.\n     ///\n     /// If no directory can be created, `Err` is returned.\n+    #[allow(deprecated)]\n     pub fn new_in(tmpdir: &Path, prefix: &str) -> IoResult<TempDir> {\n         if !tmpdir.is_absolute() {\n-            let cur_dir = try!(env::current_dir());\n+            let cur_dir = try!(::os::getcwd());\n             return TempDir::new_in(&cur_dir.join(tmpdir), prefix);\n         }\n \n@@ -132,8 +133,9 @@ impl TempDir {\n     /// deleted once the returned wrapper is destroyed.\n     ///\n     /// If no directory can be created, `Err` is returned.\n+    #[allow(deprecated)]\n     pub fn new(prefix: &str) -> IoResult<TempDir> {\n-        TempDir::new_in(&env::temp_dir(), prefix)\n+        TempDir::new_in(&::os::tmpdir(), prefix)\n     }\n \n     /// Unwrap the wrapped `std::path::Path` from the `TempDir` wrapper."}, {"sha": "43c0b9268a242d065cc90b9c53c0a71a3207cb9c", "filename": "src/libstd/old_io/test.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Fold_io%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Fold_io%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Ftest.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -38,10 +38,11 @@ fn next_test_unix_socket() -> String {\n \n /// Get a temporary path which could be the location of a unix socket\n #[cfg(not(target_os = \"ios\"))]\n+#[allow(deprecated)]\n pub fn next_test_unix() -> Path {\n     let string = next_test_unix_socket();\n     if cfg!(unix) {\n-        env::temp_dir().join(string)\n+        ::os::tmpdir().join(string)\n     } else {\n         Path::new(format!(\"{}{}\", r\"\\\\.\\pipe\\\", string))\n     }\n@@ -88,7 +89,7 @@ fn base_port() -> u16 {\n \n     // FIXME (#9639): This needs to handle non-utf8 paths\n     let path = env::current_dir().unwrap();\n-    let path_s = path.as_str().unwrap();\n+    let path_s = path.to_str().unwrap();\n \n     let mut final_base = base;\n "}, {"sha": "8e49335ed5469e110114ab9823866d113903e071", "filename": "src/libstd/old_io/util.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Fold_io%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Fold_io%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_io%2Futil.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -284,7 +284,7 @@ mod test {\n         let mut r = MemReader::new(vec!(0, 1, 2));\n         {\n             let mut r = LimitReader::new(r.by_ref(), 4);\n-            assert_eq!(vec!(0, 1, 2), r.read_to_end().unwrap());\n+            assert_eq!([0, 1, 2], r.read_to_end().unwrap());\n         }\n     }\n \n@@ -293,9 +293,9 @@ mod test {\n         let mut r = MemReader::new(vec!(0, 1, 2));\n         {\n             let mut r = LimitReader::new(r.by_ref(), 2);\n-            assert_eq!(vec!(0, 1), r.read_to_end().unwrap());\n+            assert_eq!([0, 1], r.read_to_end().unwrap());\n         }\n-        assert_eq!(vec!(2), r.read_to_end().unwrap());\n+        assert_eq!([2], r.read_to_end().unwrap());\n     }\n \n     #[test]\n@@ -305,7 +305,7 @@ mod test {\n         assert_eq!(3, r.limit());\n         assert_eq!(0, r.read_byte().unwrap());\n         assert_eq!(2, r.limit());\n-        assert_eq!(vec!(1, 2), r.read_to_end().unwrap());\n+        assert_eq!([1, 2], r.read_to_end().unwrap());\n         assert_eq!(0, r.limit());\n     }\n \n@@ -314,7 +314,7 @@ mod test {\n         let mut r = MemReader::new(vec![0, 1, 2, 3, 4, 5]);\n         let mut r = LimitReader::new(r.by_ref(), 1);\n         r.consume(2);\n-        assert_eq!(vec![], r.read_to_end().unwrap());\n+        assert_eq!([], r.read_to_end().unwrap());\n     }\n \n     #[test]\n@@ -330,7 +330,7 @@ mod test {\n         let mut s = ZeroReader;\n         let mut buf = vec![1, 2, 3];\n         assert_eq!(s.read(&mut buf), Ok(3));\n-        assert_eq!(vec![0, 0, 0], buf);\n+        assert_eq!([0, 0, 0], buf);\n     }\n \n     #[test]\n@@ -373,24 +373,24 @@ mod test {\n         let rs = vec!(MemReader::new(vec!(0, 1)), MemReader::new(vec!()),\n                       MemReader::new(vec!(2, 3)));\n         let mut r = ChainedReader::new(rs.into_iter());\n-        assert_eq!(vec!(0, 1, 2, 3), r.read_to_end().unwrap());\n+        assert_eq!([0, 1, 2, 3], r.read_to_end().unwrap());\n     }\n \n     #[test]\n     fn test_tee_reader() {\n         let mut r = TeeReader::new(MemReader::new(vec!(0, 1, 2)),\n                                    Vec::new());\n-        assert_eq!(vec!(0, 1, 2), r.read_to_end().unwrap());\n+        assert_eq!([0, 1, 2], r.read_to_end().unwrap());\n         let (_, w) = r.into_inner();\n-        assert_eq!(vec!(0, 1, 2), w);\n+        assert_eq!([0, 1, 2], w);\n     }\n \n     #[test]\n     fn test_copy() {\n         let mut r = MemReader::new(vec!(0, 1, 2, 3, 4));\n         let mut w = Vec::new();\n         copy(&mut r, &mut w).unwrap();\n-        assert_eq!(vec!(0, 1, 2, 3, 4), w);\n+        assert_eq!([0, 1, 2, 3, 4], w);\n     }\n \n     #[test]"}, {"sha": "9c42d1be77ee1c009ead6a37df39ebbaeda03878", "filename": "src/libstd/os.rs", "status": "modified", "additions": 39, "deletions": 16, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -49,6 +49,7 @@ use ops::{Drop, FnOnce};\n use option::Option::{Some, None};\n use option::Option;\n use old_path::{Path, GenericPath, BytesContainer};\n+use path::{self, PathBuf};\n use ptr::PtrExt;\n use ptr;\n use result::Result::{Err, Ok};\n@@ -67,6 +68,35 @@ use vec::Vec;\n #[cfg(unix)] pub use sys::ext as unix;\n #[cfg(windows)] pub use sys::ext as windows;\n \n+fn err2old(new: ::io::Error) -> IoError {\n+    IoError {\n+        kind: ::old_io::OtherIoError,\n+        desc: \"os error\",\n+        detail: Some(new.to_string()),\n+    }\n+}\n+\n+#[cfg(windows)]\n+fn path2new(path: &Path) -> PathBuf {\n+    PathBuf::new(path.as_str().unwrap())\n+}\n+#[cfg(unix)]\n+fn path2new(path: &Path) -> PathBuf {\n+    use os::unix::prelude::*;\n+    PathBuf::new(<OsStr as OsStrExt>::from_bytes(path.as_vec()))\n+}\n+\n+#[cfg(unix)]\n+fn path2old(path: &path::Path) -> Path {\n+    use os::unix::prelude::*;\n+    use ffi::AsOsStr;\n+    Path::new(path.as_os_str().as_bytes())\n+}\n+#[cfg(windows)]\n+fn path2old(path: &path::Path) -> Path {\n+    Path::new(path.to_str().unwrap())\n+}\n+\n /// Get the number of cores available\n pub fn num_cpus() -> uint {\n     unsafe {\n@@ -100,10 +130,9 @@ pub const TMPBUF_SZ : uint = 1000;\n /// let current_working_directory = os::getcwd().unwrap();\n /// println!(\"The current directory is {:?}\", current_working_directory.display());\n /// ```\n-#[deprecated(since = \"1.0.0\", reason = \"renamed to std::env::current_dir\")]\n #[unstable(feature = \"os\")]\n pub fn getcwd() -> IoResult<Path> {\n-    env::current_dir()\n+    env::current_dir().map_err(err2old).map(|s| path2old(&s))\n }\n \n /// Returns a vector of (variable, value) pairs, for all the environment\n@@ -245,12 +274,11 @@ pub fn unsetenv(n: &str) {\n ///     None => println!(\"{} is not defined in the environment.\", key)\n /// }\n /// ```\n-#[deprecated(since = \"1.0.0\", reason = \"renamed to env::split_paths\")]\n #[unstable(feature = \"os\")]\n pub fn split_paths<T: BytesContainer>(unparsed: T) -> Vec<Path> {\n     let b = unparsed.container_as_bytes();\n     let s = str::from_utf8(b).unwrap();\n-    env::split_paths(s).collect()\n+    env::split_paths(s).map(|s| path2old(&s)).collect()\n }\n \n /// Joins a collection of `Path`s appropriately for the `PATH`\n@@ -274,7 +302,6 @@ pub fn split_paths<T: BytesContainer>(unparsed: T) -> Vec<Path> {\n /// paths.push(Path::new(\"/home/xyz/bin\"));\n /// os::setenv(key, os::join_paths(paths.as_slice()).unwrap());\n /// ```\n-#[deprecated(since = \"1.0.0\", reason = \"renamed to env::join_paths\")]\n #[unstable(feature = \"os\")]\n pub fn join_paths<T: BytesContainer>(paths: &[T]) -> Result<Vec<u8>, &'static str> {\n     env::join_paths(paths.iter().map(|s| {\n@@ -335,10 +362,9 @@ pub fn dll_filename(base: &str) -> String {\n ///     None => println!(\"Unable to get the path of this executable!\")\n /// };\n /// ```\n-#[deprecated(since = \"1.0.0\", reason = \"renamed to env::current_exe\")]\n #[unstable(feature = \"os\")]\n pub fn self_exe_name() -> Option<Path> {\n-    env::current_exe().ok()\n+    env::current_exe().ok().map(|p| path2old(&p))\n }\n \n /// Optionally returns the filesystem path to the current executable which is\n@@ -356,10 +382,9 @@ pub fn self_exe_name() -> Option<Path> {\n ///     None => println!(\"Impossible to fetch the path of this executable.\")\n /// };\n /// ```\n-#[deprecated(since = \"1.0.0\", reason = \"use env::current_exe + dir_path/pop\")]\n #[unstable(feature = \"os\")]\n pub fn self_exe_path() -> Option<Path> {\n-    env::current_exe().ok().map(|mut p| { p.pop(); p })\n+    env::current_exe().ok().map(|p| { let mut p = path2old(&p); p.pop(); p })\n }\n \n /// Optionally returns the path to the current user's home directory if known.\n@@ -386,9 +411,8 @@ pub fn self_exe_path() -> Option<Path> {\n ///     None => println!(\"Impossible to get your home dir!\")\n /// }\n /// ```\n-#[deprecated(since = \"1.0.0\", reason = \"renamed to env::home_dir\")]\n-#[allow(deprecated)]\n #[unstable(feature = \"os\")]\n+#[allow(deprecated)]\n pub fn homedir() -> Option<Path> {\n     #[inline]\n     #[cfg(unix)]\n@@ -424,9 +448,8 @@ pub fn homedir() -> Option<Path> {\n /// On Windows, returns the value of, in order, the 'TMP', 'TEMP',\n /// 'USERPROFILE' environment variable  if any are set and not the empty\n /// string. Otherwise, tmpdir returns the path to the Windows directory.\n-#[deprecated(since = \"1.0.0\", reason = \"renamed to env::temp_dir\")]\n-#[allow(deprecated)]\n #[unstable(feature = \"os\")]\n+#[allow(deprecated)]\n pub fn tmpdir() -> Path {\n     return lookup();\n \n@@ -488,7 +511,8 @@ pub fn make_absolute(p: &Path) -> IoResult<Path> {\n     if p.is_absolute() {\n         Ok(p.clone())\n     } else {\n-        env::current_dir().map(|mut cwd| {\n+        env::current_dir().map_err(err2old).map(|cwd| {\n+            let mut cwd = path2old(&cwd);\n             cwd.push(p);\n             cwd\n         })\n@@ -507,10 +531,9 @@ pub fn make_absolute(p: &Path) -> IoResult<Path> {\n /// assert!(os::change_dir(&root).is_ok());\n /// println!(\"Successfully changed working directory to {}!\", root.display());\n /// ```\n-#[deprecated(since = \"1.0.0\", reason = \"renamed to env::set_current_dir\")]\n #[unstable(feature = \"os\")]\n pub fn change_dir(p: &Path) -> IoResult<()> {\n-    return sys::os::chdir(p);\n+    sys::os::chdir(&path2new(p)).map_err(err2old)\n }\n \n /// Returns the platform-specific value of errno"}, {"sha": "1a13405633d2ede6f2218e4caa596c67baf7d4e1", "filename": "src/libstd/rand/os.rs", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Frand%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Frand%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frand%2Fos.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -188,7 +188,6 @@ mod imp {\n     extern crate libc;\n \n     use old_io::{IoResult};\n-    use marker::Sync;\n     use mem;\n     use os;\n     use rand::Rng;\n@@ -214,10 +213,8 @@ mod imp {\n     #[repr(C)]\n     struct SecRandom;\n \n-    unsafe impl Sync for *const SecRandom {}\n-\n     #[allow(non_upper_case_globals)]\n-    static kSecRandomDefault: *const SecRandom = 0 as *const SecRandom;\n+    const kSecRandomDefault: *const SecRandom = 0 as *const SecRandom;\n \n     #[link(name = \"Security\", kind = \"framework\")]\n     extern \"C\" {"}, {"sha": "e7ee9bd2066514f4e47a04b3bf2eb102de874fc6", "filename": "src/libstd/sync/condvar.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Fsync%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Fsync%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fcondvar.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -61,9 +61,6 @@ use sync::{mutex, MutexGuard, PoisonError};\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Condvar { inner: Box<StaticCondvar> }\n \n-unsafe impl Send for Condvar {}\n-unsafe impl Sync for Condvar {}\n-\n /// Statically allocated condition variables.\n ///\n /// This structure is identical to `Condvar` except that it is suitable for use\n@@ -83,9 +80,6 @@ pub struct StaticCondvar {\n     mutex: AtomicUsize,\n }\n \n-unsafe impl Send for StaticCondvar {}\n-unsafe impl Sync for StaticCondvar {}\n-\n /// Constant initializer for a statically allocated condition variable.\n #[unstable(feature = \"std_misc\",\n            reason = \"may be merged with Condvar in the future\")]"}, {"sha": "68137601c405c84876ee746a0b8d302300cd2b03", "filename": "src/libstd/sync/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Fsync%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Fsync%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmod.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -31,6 +31,7 @@ pub use self::barrier::{Barrier, BarrierWaitResult};\n pub use self::poison::{PoisonError, TryLockError, TryLockResult, LockResult};\n \n pub use self::future::Future;\n+#[allow(deprecated)]\n pub use self::task_pool::TaskPool;\n \n pub mod mpsc;"}, {"sha": "b9785f204406a076ae7248b9cb6e61a0fb0d4ba7", "filename": "src/libstd/sync/mutex.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmutex.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -152,8 +152,6 @@ pub struct StaticMutex {\n     poison: poison::Flag,\n }\n \n-unsafe impl Sync for StaticMutex {}\n-\n /// An RAII implementation of a \"scoped lock\" of a mutex. When this structure is\n /// dropped (falls out of scope), the lock will be unlocked.\n ///"}, {"sha": "d2054a1e819ab377d5204799f8e33e77e7bad937", "filename": "src/libstd/sync/once.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Fsync%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Fsync%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fonce.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -13,10 +13,9 @@\n //! This primitive is meant to be used to run one-time initialization. An\n //! example use case would be for initializing an FFI library.\n \n+use prelude::v1::*;\n+\n use isize;\n-use marker::Sync;\n-use mem::drop;\n-use ops::FnOnce;\n use sync::atomic::{AtomicIsize, Ordering, ATOMIC_ISIZE_INIT};\n use sync::{StaticMutex, MUTEX_INIT};\n \n@@ -43,8 +42,6 @@ pub struct Once {\n     lock_cnt: AtomicIsize,\n }\n \n-unsafe impl Sync for Once {}\n-\n /// Initialization value for static `Once` values.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub const ONCE_INIT: Once = Once {"}, {"sha": "2587ff5238ea7b86eb29d107856be5ed31629198", "filename": "src/libstd/sync/poison.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Fsync%2Fpoison.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Fsync%2Fpoison.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fpoison.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -16,6 +16,12 @@ use fmt;\n use thread;\n \n pub struct Flag { failed: UnsafeCell<bool> }\n+\n+// This flag is only ever accessed with a lock previously held. Note that this\n+// a totally private structure.\n+unsafe impl Send for Flag {}\n+unsafe impl Sync for Flag {}\n+\n pub const FLAG_INIT: Flag = Flag { failed: UnsafeCell { value: false } };\n \n impl Flag {"}, {"sha": "6fee6094d4ffcd5be99fb712278705244ebbfc26", "filename": "src/libstd/sync/rwlock.rs", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Frwlock.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -97,9 +97,6 @@ pub struct StaticRwLock {\n     poison: poison::Flag,\n }\n \n-unsafe impl Send for StaticRwLock {}\n-unsafe impl Sync for StaticRwLock {}\n-\n /// Constant initialization for a statically-initialized rwlock.\n #[unstable(feature = \"std_misc\",\n            reason = \"may be merged with RwLock in the future\")]"}, {"sha": "efb6689e7855a40da3f9d374ead25439b9bee138", "filename": "src/libstd/sync/task_pool.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Fsync%2Ftask_pool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Fsync%2Ftask_pool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Ftask_pool.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -10,11 +10,13 @@\n \n //! Abstraction of a thread pool for basic parallelism.\n \n-#![unstable(feature = \"std_misc\",\n-            reason = \"the semantics of a failing task and whether a thread is \\\n-                      re-attached to a thread pool are somewhat unclear, and the \\\n-                      utility of this type in `std::sync` is questionable with \\\n-                      respect to the jobs of other primitives\")]\n+#![deprecated(since = \"1.0.0\",\n+              reason = \"This kind of API needs some time to bake in \\\n+                        crates.io. This functionality is available through \\\n+                        https://crates.io/crates/threadpool\")]\n+#![unstable(feature = \"std_misc\")]\n+\n+#![allow(deprecated)]\n \n use core::prelude::*;\n "}, {"sha": "228362e3d62ae2450ed349fae0b518f02db651b6", "filename": "src/libstd/sys/common/net.rs", "status": "modified", "additions": 8, "deletions": 13, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fnet.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -503,7 +503,7 @@ pub fn connect_timeout(fd: sock_t,\n     #[cfg(windows)] use libc::WSAEWOULDBLOCK as WOULDBLOCK;\n \n     // Make sure the call to connect() doesn't block\n-    try!(set_nonblocking(fd, true));\n+    set_nonblocking(fd, true);\n \n     let ret = match unsafe { libc::connect(fd, addrp, len) } {\n         // If the connection is in progress, then we need to wait for it to\n@@ -533,7 +533,7 @@ pub fn connect_timeout(fd: sock_t,\n     };\n \n     // be sure to turn blocking I/O back on\n-    try!(set_nonblocking(fd, false));\n+    set_nonblocking(fd, false);\n     return ret;\n \n     #[cfg(unix)]\n@@ -626,7 +626,7 @@ pub struct Guard<'a> {\n #[unsafe_destructor]\n impl<'a> Drop for Guard<'a> {\n     fn drop(&mut self) {\n-        assert!(set_nonblocking(self.fd, false).is_ok());\n+        set_nonblocking(self.fd, false);\n     }\n }\n \n@@ -723,7 +723,7 @@ impl TcpStream {\n             fd: self.fd(),\n             guard: self.inner.lock.lock().unwrap(),\n         };\n-        assert!(set_nonblocking(self.fd(), true).is_ok());\n+        set_nonblocking(self.fd(), true);\n         ret\n     }\n \n@@ -862,7 +862,7 @@ impl UdpSocket {\n             fd: self.fd(),\n             guard: self.inner.lock.lock().unwrap(),\n         };\n-        assert!(set_nonblocking(self.fd(), true).is_ok());\n+        set_nonblocking(self.fd(), true);\n         ret\n     }\n \n@@ -887,9 +887,7 @@ impl UdpSocket {\n                            storagep,\n                            &mut addrlen) as libc::c_int\n         }));\n-        sockaddr_to_addr(&storage, addrlen as uint).and_then(|addr| {\n-            Ok((n as uint, addr))\n-        })\n+        Ok((n as uint, sockaddr_to_addr(&storage, addrlen as uint).unwrap()))\n     }\n \n     pub fn send_to(&mut self, buf: &[u8], dst: SocketAddr) -> IoResult<()> {\n@@ -910,11 +908,8 @@ impl UdpSocket {\n         };\n \n         let n = try!(write(fd, self.write_deadline, buf, false, dolock, dowrite));\n-        if n != buf.len() {\n-            Err(short_write(n, \"couldn't send entire packet at once\"))\n-        } else {\n-            Ok(())\n-        }\n+        assert!(n == buf.len(), \"UDP packet not completely written.\");\n+        Ok(())\n     }\n \n     pub fn join_multicast(&mut self, multi: IpAddr) -> IoResult<()> {"}, {"sha": "fb9d6fef1faa7e0071343937f6aad0eea519eba4", "filename": "src/libstd/sys/common/wtf8.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fcommon%2Fwtf8.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -1202,11 +1202,11 @@ mod tests {\n             string.code_points().map(|c| c.to_char()).collect::<Vec<_>>()\n         }\n         let mut string = Wtf8Buf::from_str(\"\u00e9 \");\n-        assert_eq!(cp(&string), vec![Some('\u00e9'), Some(' ')]);\n+        assert_eq!(cp(&string), [Some('\u00e9'), Some(' ')]);\n         string.push(c(0xD83D));\n-        assert_eq!(cp(&string), vec![Some('\u00e9'), Some(' '), None]);\n+        assert_eq!(cp(&string), [Some('\u00e9'), Some(' '), None]);\n         string.push(c(0xDCA9));\n-        assert_eq!(cp(&string), vec![Some('\u00e9'), Some(' '), Some('\ud83d\udca9')]);\n+        assert_eq!(cp(&string), [Some('\u00e9'), Some(' '), Some('\ud83d\udca9')]);\n     }\n \n     #[test]"}, {"sha": "6267792ba745e5ffa82bcca807c959d8ed4dd2a5", "filename": "src/libstd/sys/unix/backtrace.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fbacktrace.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -84,8 +84,9 @@\n /// all unix platforms we support right now, so it at least gets the job done.\n \n use prelude::v1::*;\n+use os::unix::prelude::*;\n \n-use ffi::CStr;\n+use ffi::{CStr, AsOsStr};\n use old_io::IoResult;\n use libc;\n use mem;\n@@ -327,7 +328,7 @@ fn print(w: &mut Writer, idx: int, addr: *mut libc::c_void) -> IoResult<()> {\n         };\n         let filename = match selfname {\n             Some(path) => {\n-                let bytes = path.as_vec();\n+                let bytes = path.as_os_str().as_bytes();\n                 if bytes.len() < LAST_FILENAME.len() {\n                     let i = bytes.iter();\n                     for (slot, val) in LAST_FILENAME.iter_mut().zip(i) {"}, {"sha": "90dfebc4c454c7735808255c52a5994e08452f34", "filename": "src/libstd/sys/unix/condvar.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Fsys%2Funix%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Fsys%2Funix%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fcondvar.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -8,10 +8,11 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use prelude::v1::*;\n+\n use cell::UnsafeCell;\n use libc;\n use ptr;\n-use std::option::Option::{Some, None};\n use sys::mutex::{self, Mutex};\n use sys::time;\n use sys::sync as ffi;\n@@ -20,6 +21,9 @@ use num::{Int, NumCast};\n \n pub struct Condvar { inner: UnsafeCell<ffi::pthread_cond_t> }\n \n+unsafe impl Send for Condvar {}\n+unsafe impl Sync for Condvar {}\n+\n pub const CONDVAR_INIT: Condvar = Condvar {\n     inner: UnsafeCell { value: ffi::PTHREAD_COND_INITIALIZER },\n };"}, {"sha": "3f9da6e3c51bb004fb6b1cf40a917825237136b5", "filename": "src/libstd/sys/unix/ext.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Fsys%2Funix%2Fext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Fsys%2Funix%2Fext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fext.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -173,10 +173,13 @@ impl OsStrExt for OsStr {\n \n // Unix-specific extensions to `Permissions`\n pub trait PermissionsExt {\n+    fn mode(&self) -> i32;\n     fn set_mode(&mut self, mode: i32);\n }\n \n impl PermissionsExt for Permissions {\n+    fn mode(&self) -> i32 { self.as_inner().mode() }\n+\n     fn set_mode(&mut self, mode: i32) {\n         *self = FromInner::from_inner(FromInner::from_inner(mode));\n     }"}, {"sha": "72e0b8dd36c66151eab686d374a2f44f928c42d3", "filename": "src/libstd/sys/unix/fs2.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Fsys%2Funix%2Ffs2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Fsys%2Funix%2Ffs2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffs2.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -90,6 +90,7 @@ impl FilePermissions {\n             self.mode |= 0o222;\n         }\n     }\n+    pub fn mode(&self) -> i32 { self.mode as i32 }\n }\n \n impl FromInner<i32> for FilePermissions {"}, {"sha": "632270bc5ccbf250286bc176d1f7c08ce9ea4935", "filename": "src/libstd/sys/unix/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Fsys%2Funix%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmod.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -214,9 +214,9 @@ pub fn wouldblock() -> bool {\n     err == libc::EWOULDBLOCK as i32 || err == libc::EAGAIN as i32\n }\n \n-pub fn set_nonblocking(fd: sock_t, nb: bool) -> IoResult<()> {\n+pub fn set_nonblocking(fd: sock_t, nb: bool) {\n     let set = nb as libc::c_int;\n-    mkerr_libc(retry(|| unsafe { c::ioctl(fd, c::FIONBIO, &set) }))\n+    mkerr_libc(retry(|| unsafe { c::ioctl(fd, c::FIONBIO, &set) })).unwrap();\n }\n \n // nothing needed on unix platforms"}, {"sha": "f87c0339533dfb672273d881cbf9b7623e9b16c2", "filename": "src/libstd/sys/unix/mutex.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Fsys%2Funix%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Fsys%2Funix%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fmutex.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -8,8 +8,9 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use prelude::v1::*;\n+\n use cell::UnsafeCell;\n-use marker::Sync;\n use sys::sync as ffi;\n use sys_common::mutex;\n \n@@ -24,6 +25,7 @@ pub const MUTEX_INIT: Mutex = Mutex {\n     inner: UnsafeCell { value: ffi::PTHREAD_MUTEX_INITIALIZER },\n };\n \n+unsafe impl Send for Mutex {}\n unsafe impl Sync for Mutex {}\n \n impl Mutex {"}, {"sha": "899280aa7094bb2f17f245be0ab6ed3044cf1f9c", "filename": "src/libstd/sys/unix/os.rs", "status": "modified", "additions": 43, "deletions": 36, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fos.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -16,12 +16,13 @@ use os::unix::*;\n use error::Error as StdError;\n use ffi::{CString, CStr, OsString, OsStr, AsOsStr};\n use fmt;\n+use io;\n use iter;\n use libc::{self, c_int, c_char, c_void};\n use mem;\n-use io;\n-use old_io::{IoResult, IoError, fs};\n+use old_io::{IoError, IoResult};\n use ptr;\n+use path::{self, PathBuf};\n use slice;\n use str;\n use sys::c;\n@@ -32,6 +33,14 @@ use vec;\n const BUF_BYTES: usize = 2048;\n const TMPBUF_SZ: usize = 128;\n \n+fn bytes2path(b: &[u8]) -> PathBuf {\n+    PathBuf::new(<OsStr as OsStrExt>::from_bytes(b))\n+}\n+\n+fn os2path(os: OsString) -> PathBuf {\n+    bytes2path(os.as_bytes())\n+}\n+\n /// Returns the platform-specific value of errno\n pub fn errno() -> i32 {\n     #[cfg(any(target_os = \"macos\",\n@@ -102,44 +111,44 @@ pub fn error_string(errno: i32) -> String {\n     }\n }\n \n-pub fn getcwd() -> IoResult<Path> {\n+pub fn getcwd() -> io::Result<PathBuf> {\n     let mut buf = [0 as c_char; BUF_BYTES];\n     unsafe {\n         if libc::getcwd(buf.as_mut_ptr(), buf.len() as libc::size_t).is_null() {\n-            Err(IoError::last_error())\n+            Err(io::Error::last_os_error())\n         } else {\n-            Ok(Path::new(CStr::from_ptr(buf.as_ptr()).to_bytes()))\n+            Ok(bytes2path(CStr::from_ptr(buf.as_ptr()).to_bytes()))\n         }\n     }\n }\n \n-pub fn chdir(p: &Path) -> IoResult<()> {\n-    let p = CString::new(p.as_vec()).unwrap();\n+pub fn chdir(p: &path::Path) -> io::Result<()> {\n+    let p = try!(CString::new(p.as_os_str().as_bytes()));\n     unsafe {\n         match libc::chdir(p.as_ptr()) == (0 as c_int) {\n             true => Ok(()),\n-            false => Err(IoError::last_error()),\n+            false => Err(io::Error::last_os_error()),\n         }\n     }\n }\n \n pub struct SplitPaths<'a> {\n     iter: iter::Map<slice::Split<'a, u8, fn(&u8) -> bool>,\n-                    fn(&'a [u8]) -> Path>,\n+                    fn(&'a [u8]) -> PathBuf>,\n }\n \n pub fn split_paths<'a>(unparsed: &'a OsStr) -> SplitPaths<'a> {\n     fn is_colon(b: &u8) -> bool { *b == b':' }\n     let unparsed = unparsed.as_bytes();\n     SplitPaths {\n         iter: unparsed.split(is_colon as fn(&u8) -> bool)\n-                      .map(Path::new as fn(&'a [u8]) ->  Path)\n+                      .map(bytes2path as fn(&'a [u8]) -> PathBuf)\n     }\n }\n \n impl<'a> Iterator for SplitPaths<'a> {\n-    type Item = Path;\n-    fn next(&mut self) -> Option<Path> { self.iter.next() }\n+    type Item = PathBuf;\n+    fn next(&mut self) -> Option<PathBuf> { self.iter.next() }\n     fn size_hint(&self) -> (usize, Option<usize>) { self.iter.size_hint() }\n }\n \n@@ -174,7 +183,7 @@ impl StdError for JoinPathsError {\n }\n \n #[cfg(target_os = \"freebsd\")]\n-pub fn current_exe() -> IoResult<Path> {\n+pub fn current_exe() -> io::Result<PathBuf> {\n     unsafe {\n         use libc::funcs::bsd44::*;\n         use libc::consts::os::extra::*;\n@@ -186,26 +195,26 @@ pub fn current_exe() -> IoResult<Path> {\n         let err = sysctl(mib.as_mut_ptr(), mib.len() as ::libc::c_uint,\n                          ptr::null_mut(), &mut sz, ptr::null_mut(),\n                          0 as libc::size_t);\n-        if err != 0 { return Err(IoError::last_error()); }\n-        if sz == 0 { return Err(IoError::last_error()); }\n+        if err != 0 { return Err(io::Error::last_os_error()); }\n+        if sz == 0 { return Err(io::Error::last_os_error()); }\n         let mut v: Vec<u8> = Vec::with_capacity(sz as uint);\n         let err = sysctl(mib.as_mut_ptr(), mib.len() as ::libc::c_uint,\n                          v.as_mut_ptr() as *mut libc::c_void, &mut sz,\n                          ptr::null_mut(), 0 as libc::size_t);\n-        if err != 0 { return Err(IoError::last_error()); }\n-        if sz == 0 { return Err(IoError::last_error()); }\n+        if err != 0 { return Err(io::Error::last_os_error()); }\n+        if sz == 0 { return Err(io::Error::last_os_error()); }\n         v.set_len(sz as uint - 1); // chop off trailing NUL\n-        Ok(Path::new(v))\n+        Ok(PathBuf::new::<OsString>(&OsStringExt::from_vec(v)))\n     }\n }\n \n #[cfg(target_os = \"dragonfly\")]\n-pub fn current_exe() -> IoResult<Path> {\n-    fs::readlink(&Path::new(\"/proc/curproc/file\"))\n+pub fn current_exe() -> io::Result<PathBuf> {\n+    ::fs::read_link(\"/proc/curproc/file\")\n }\n \n #[cfg(any(target_os = \"bitrig\", target_os = \"openbsd\"))]\n-pub fn current_exe() -> IoResult<Path> {\n+pub fn current_exe() -> io::Result<PathBuf> {\n     use sync::{StaticMutex, MUTEX_INIT};\n     static LOCK: StaticMutex = MUTEX_INIT;\n \n@@ -218,30 +227,30 @@ pub fn current_exe() -> IoResult<Path> {\n     unsafe {\n         let v = rust_current_exe();\n         if v.is_null() {\n-            Err(IoError::last_error())\n+            Err(io::Error::last_os_error())\n         } else {\n             Ok(Path::new(CStr::from_ptr(v).to_bytes().to_vec()))\n         }\n     }\n }\n \n #[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n-pub fn current_exe() -> IoResult<Path> {\n-    fs::readlink(&Path::new(\"/proc/self/exe\"))\n+pub fn current_exe() -> io::Result<PathBuf> {\n+    ::fs::read_link(\"/proc/self/exe\")\n }\n \n #[cfg(any(target_os = \"macos\", target_os = \"ios\"))]\n-pub fn current_exe() -> IoResult<Path> {\n+pub fn current_exe() -> io::Result<PathBuf> {\n     unsafe {\n         use libc::funcs::extra::_NSGetExecutablePath;\n         let mut sz: u32 = 0;\n         _NSGetExecutablePath(ptr::null_mut(), &mut sz);\n-        if sz == 0 { return Err(IoError::last_error()); }\n+        if sz == 0 { return Err(io::Error::last_os_error()); }\n         let mut v: Vec<u8> = Vec::with_capacity(sz as uint);\n         let err = _NSGetExecutablePath(v.as_mut_ptr() as *mut i8, &mut sz);\n-        if err != 0 { return Err(IoError::last_error()); }\n+        if err != 0 { return Err(io::Error::last_os_error()); }\n         v.set_len(sz as uint - 1); // chop off trailing NUL\n-        Ok(Path::new(v))\n+        Ok(PathBuf::new::<OsString>(&OsStringExt::from_vec(v)))\n     }\n }\n \n@@ -451,22 +460,20 @@ pub fn page_size() -> usize {\n     }\n }\n \n-pub fn temp_dir() -> Path {\n-    getenv(\"TMPDIR\".as_os_str()).map(|p| Path::new(p.into_vec())).unwrap_or_else(|| {\n+pub fn temp_dir() -> PathBuf {\n+    getenv(\"TMPDIR\".as_os_str()).map(os2path).unwrap_or_else(|| {\n         if cfg!(target_os = \"android\") {\n-            Path::new(\"/data/local/tmp\")\n+            PathBuf::new(\"/data/local/tmp\")\n         } else {\n-            Path::new(\"/tmp\")\n+            PathBuf::new(\"/tmp\")\n         }\n     })\n }\n \n-pub fn home_dir() -> Option<Path> {\n+pub fn home_dir() -> Option<PathBuf> {\n     return getenv(\"HOME\".as_os_str()).or_else(|| unsafe {\n         fallback()\n-    }).map(|os| {\n-        Path::new(os.into_vec())\n-    });\n+    }).map(os2path);\n \n     #[cfg(any(target_os = \"android\",\n               target_os = \"ios\"))]"}, {"sha": "33863d31437f3f7f68d4a6e2aaf4d1907cbc3d75", "filename": "src/libstd/sys/unix/pipe.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -145,7 +145,7 @@ impl UnixStream {\n             fd: self.fd(),\n             guard: unsafe { self.inner.lock.lock().unwrap() },\n         };\n-        assert!(set_nonblocking(self.fd(), true).is_ok());\n+        set_nonblocking(self.fd(), true);\n         ret\n     }\n \n@@ -235,9 +235,9 @@ impl UnixListener {\n \n             _ => {\n                 let (reader, writer) = try!(unsafe { sys::os::pipe() });\n-                try!(set_nonblocking(reader.fd(), true));\n-                try!(set_nonblocking(writer.fd(), true));\n-                try!(set_nonblocking(self.fd(), true));\n+                set_nonblocking(reader.fd(), true);\n+                set_nonblocking(writer.fd(), true);\n+                set_nonblocking(self.fd(), true);\n                 Ok(UnixAcceptor {\n                     inner: Arc::new(AcceptorInner {\n                         listener: self,"}, {"sha": "68c5c65e7cdb11cfac9bf64ff25732d8efbba32b", "filename": "src/libstd/sys/unix/process.rs", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -69,7 +69,6 @@ impl Process {\n               K: BytesContainer + Eq + Hash, V: BytesContainer\n     {\n         use libc::funcs::posix88::unistd::{fork, dup2, close, chdir, execvp};\n-        use libc::funcs::bsd44::getdtablesize;\n \n         mod rustrt {\n             extern {\n@@ -82,6 +81,15 @@ impl Process {\n             assert_eq!(ret, 0);\n         }\n \n+        #[cfg(all(target_os = \"android\", target_arch = \"aarch64\"))]\n+        unsafe fn getdtablesize() -> c_int {\n+            libc::sysconf(libc::consts::os::sysconf::_SC_OPEN_MAX) as c_int\n+        }\n+        #[cfg(not(all(target_os = \"android\", target_arch = \"aarch64\")))]\n+        unsafe fn getdtablesize() -> c_int {\n+            libc::funcs::bsd44::getdtablesize()\n+        }\n+\n         let dirp = cfg.cwd().map(|c| c.as_ptr()).unwrap_or(ptr::null());\n \n         // temporary until unboxed closures land\n@@ -345,8 +353,8 @@ impl Process {\n             unsafe {\n                 let mut pipes = [0; 2];\n                 assert_eq!(libc::pipe(pipes.as_mut_ptr()), 0);\n-                set_nonblocking(pipes[0], true).ok().unwrap();\n-                set_nonblocking(pipes[1], true).ok().unwrap();\n+                set_nonblocking(pipes[0], true);\n+                set_nonblocking(pipes[1], true);\n                 WRITE_FD = pipes[1];\n \n                 let mut old: c::sigaction = mem::zeroed();\n@@ -362,7 +370,7 @@ impl Process {\n         fn waitpid_helper(input: libc::c_int,\n                           messages: Receiver<Req>,\n                           (read_fd, old): (libc::c_int, c::sigaction)) {\n-            set_nonblocking(input, true).ok().unwrap();\n+            set_nonblocking(input, true);\n             let mut set: c::fd_set = unsafe { mem::zeroed() };\n             let mut tv: libc::timeval;\n             let mut active = Vec::<(libc::pid_t, Sender<ProcessExit>, u64)>::new();"}, {"sha": "b7a1b002f55983a0048fc742f2a0167a8be32ecc", "filename": "src/libstd/sys/unix/process2.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Fsys%2Funix%2Fprocess2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Fsys%2Funix%2Fprocess2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess2.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -141,7 +141,6 @@ impl Process {\n                  -> io::Result<Process>\n     {\n         use libc::funcs::posix88::unistd::{fork, dup2, close, chdir, execvp};\n-        use libc::funcs::bsd44::getdtablesize;\n \n         mod rustrt {\n             extern {\n@@ -154,6 +153,16 @@ impl Process {\n             assert_eq!(ret, 0);\n         }\n \n+        #[cfg(all(target_os = \"android\", target_arch = \"aarch64\"))]\n+        unsafe fn getdtablesize() -> c_int {\n+            libc::sysconf(libc::consts::os::sysconf::_SC_OPEN_MAX) as c_int\n+        }\n+\n+        #[cfg(not(all(target_os = \"android\", target_arch = \"aarch64\")))]\n+        unsafe fn getdtablesize() -> c_int {\n+            libc::funcs::bsd44::getdtablesize()\n+        }\n+\n         let dirp = cfg.cwd.as_ref().map(|c| c.as_ptr()).unwrap_or(ptr::null());\n \n         with_envp(cfg.env.as_ref(), |envp: *const c_void| {"}, {"sha": "b857f4ab75fed31160e45e63acdf887f545acdca", "filename": "src/libstd/sys/unix/rwlock.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Fsys%2Funix%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Fsys%2Funix%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Frwlock.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use prelude::v1::*;\n+\n use cell::UnsafeCell;\n use sys::sync as ffi;\n \n@@ -17,6 +19,9 @@ pub const RWLOCK_INIT: RWLock = RWLock {\n     inner: UnsafeCell { value: ffi::PTHREAD_RWLOCK_INITIALIZER },\n };\n \n+unsafe impl Send for RWLock {}\n+unsafe impl Sync for RWLock {}\n+\n impl RWLock {\n     #[inline]\n     pub unsafe fn new() -> RWLock {"}, {"sha": "b08f6ef9b9032ebe19b9af176d086164f0de2d7a", "filename": "src/libstd/sys/unix/tcp.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Fsys%2Funix%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Fsys%2Funix%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ftcp.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -67,9 +67,9 @@ impl TcpListener {\n             -1 => Err(last_net_error()),\n             _ => {\n                 let (reader, writer) = try!(unsafe { sys::os::pipe() });\n-                try!(set_nonblocking(reader.fd(), true));\n-                try!(set_nonblocking(writer.fd(), true));\n-                try!(set_nonblocking(self.fd(), true));\n+                set_nonblocking(reader.fd(), true);\n+                set_nonblocking(writer.fd(), true);\n+                set_nonblocking(self.fd(), true);\n                 Ok(TcpAcceptor {\n                     inner: Arc::new(AcceptorInner {\n                         listener: self,"}, {"sha": "071637e3a939f82eda497d497dabdbef9e72ea31", "filename": "src/libstd/sys/windows/condvar.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Fsys%2Fwindows%2Fcondvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Fsys%2Fwindows%2Fcondvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fcondvar.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use prelude::v1::*;\n+\n use cell::UnsafeCell;\n use libc::{self, DWORD};\n use os;\n@@ -17,6 +19,9 @@ use time::Duration;\n \n pub struct Condvar { inner: UnsafeCell<ffi::CONDITION_VARIABLE> }\n \n+unsafe impl Send for Condvar {}\n+unsafe impl Sync for Condvar {}\n+\n pub const CONDVAR_INIT: Condvar = Condvar {\n     inner: UnsafeCell { value: ffi::CONDITION_VARIABLE_INIT }\n };"}, {"sha": "309d6c9dc48c26b48c27f4cae8af38e2a11a194c", "filename": "src/libstd/sys/windows/fs.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ffs.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -368,7 +368,9 @@ pub fn readlink(p: &Path) -> IoResult<Path> {\n                                   buf as *const u16,\n                                   sz - 1,\n                                   libc::VOLUME_NAME_DOS)\n-    }, super::os2path);\n+    }, |data| {\n+        Path::new(String::from_utf16(data).unwrap())\n+    });\n     assert!(unsafe { libc::CloseHandle(handle) } != 0);\n     return ret;\n }"}, {"sha": "5bb2a134533ed0217b7dd9135b51e070e56fd346", "filename": "src/libstd/sys/windows/mod.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmod.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -14,13 +14,14 @@\n \n use prelude::v1::*;\n \n-use ffi::OsStr;\n+use ffi::{OsStr, OsString};\n use io::{self, ErrorKind};\n use libc;\n use mem;\n-use old_io::{self, IoResult, IoError};\n use num::Int;\n-use os::windows::OsStrExt;\n+use old_io::{self, IoResult, IoError};\n+use os::windows::{OsStrExt, OsStringExt};\n+use path::PathBuf;\n use sync::{Once, ONCE_INIT};\n \n macro_rules! helper_init { (static $name:ident: Helper<$m:ty>) => (\n@@ -192,12 +193,12 @@ pub fn wouldblock() -> bool {\n     err == libc::WSAEWOULDBLOCK as i32\n }\n \n-pub fn set_nonblocking(fd: sock_t, nb: bool) -> IoResult<()> {\n+pub fn set_nonblocking(fd: sock_t, nb: bool) {\n     let mut set = nb as libc::c_ulong;\n-    if unsafe { c::ioctlsocket(fd, c::FIONBIO, &mut set) != 0 } {\n-        Err(last_error())\n-    } else {\n-        Ok(())\n+    if unsafe { c::ioctlsocket(fd, c::FIONBIO, &mut set) } != 0 {\n+        // The above function should not return an error unless we passed it\n+        // invalid parameters. Panic on errors.\n+        panic!(\"set_nonblocking called with invalid parameters: {}\", last_error());\n     }\n }\n \n@@ -314,9 +315,10 @@ fn fill_utf16_buf_new<F1, F2, T>(f1: F1, f2: F2) -> io::Result<T>\n     fill_utf16_buf_base(f1, f2).map_err(|()| io::Error::last_os_error())\n }\n \n-fn os2path(s: &[u16]) -> Path {\n-    // FIXME: this should not be a panicking conversion (aka path reform)\n-    Path::new(String::from_utf16(s).unwrap())\n+fn os2path(s: &[u16]) -> PathBuf {\n+    let os = <OsString as OsStringExt>::from_wide(s);\n+    // FIXME(#22751) should consume `os`\n+    PathBuf::new(&os)\n }\n \n pub fn truncate_utf16_at_nul<'a>(v: &'a [u16]) -> &'a [u16] {"}, {"sha": "0847f3b52bfabe171e370bed4e1b6a43cb75bfa5", "filename": "src/libstd/sys/windows/mutex.rs", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Fsys%2Fwindows%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Fsys%2Fwindows%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fmutex.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -8,7 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use marker::Sync;\n+use prelude::v1::*;\n+\n use cell::UnsafeCell;\n use sys::sync as ffi;\n \n@@ -18,6 +19,7 @@ pub const MUTEX_INIT: Mutex = Mutex {\n     inner: UnsafeCell { value: ffi::SRWLOCK_INIT }\n };\n \n+unsafe impl Send for Mutex {}\n unsafe impl Sync for Mutex {}\n \n #[inline]\n@@ -27,14 +29,15 @@ pub unsafe fn raw(m: &Mutex) -> ffi::PSRWLOCK {\n \n // So you might be asking why we're using SRWLock instead of CriticalSection?\n //\n-// 1. SRWLock is several times faster than CriticalSection according to benchmarks performed on both\n-// Windows 8 and Windows 7.\n+// 1. SRWLock is several times faster than CriticalSection according to\n+//    benchmarks performed on both Windows 8 and Windows 7.\n //\n-// 2. CriticalSection allows recursive locking while SRWLock deadlocks. The Unix implementation\n-// deadlocks so consistency is preferred. See #19962 for more details.\n+// 2. CriticalSection allows recursive locking while SRWLock deadlocks. The Unix\n+//    implementation deadlocks so consistency is preferred. See #19962 for more\n+//    details.\n //\n-// 3. While CriticalSection is fair and SRWLock is not, the current Rust policy is there there are\n-// no guarantees of fairness.\n+// 3. While CriticalSection is fair and SRWLock is not, the current Rust policy\n+//    is there there are no guarantees of fairness.\n \n impl Mutex {\n     #[inline]"}, {"sha": "6caa4df5dfe6269e58bd3fa903e4ee19d70dfe81", "filename": "src/libstd/sys/windows/net.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fnet.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -25,6 +25,8 @@ pub type wrlen_t = i32;\n \n pub struct Socket(libc::SOCKET);\n \n+/// Checks whether the Windows socket interface has been started already, and\n+/// if not, starts it.\n pub fn init() {\n     static START: Once = ONCE_INIT;\n \n@@ -38,10 +40,16 @@ pub fn init() {\n     });\n }\n \n+/// Returns the last error from the Windows socket interface.\n fn last_error() -> io::Error {\n     io::Error::from_os_error(unsafe { c::WSAGetLastError() })\n }\n \n+/// Checks if the signed integer is the Windows constant `SOCKET_ERROR` (-1)\n+/// and if so, returns the last error from the Windows socket interface. . This\n+/// function must be called before another call to the socket API is made.\n+///\n+/// FIXME: generics needed?\n pub fn cvt<T: SignedInt>(t: T) -> io::Result<T> {\n     let one: T = Int::one();\n     if t == -one {\n@@ -51,11 +59,14 @@ pub fn cvt<T: SignedInt>(t: T) -> io::Result<T> {\n     }\n }\n \n+/// Provides the functionality of `cvt` for the return values of `getaddrinfo`\n+/// and similar, meaning that they return an error if the return value is 0.\n pub fn cvt_gai(err: c_int) -> io::Result<()> {\n     if err == 0 { return Ok(()) }\n     cvt(err).map(|_| ())\n }\n \n+/// Provides the functionality of `cvt` for a closure.\n pub fn cvt_r<T: SignedInt, F>(mut f: F) -> io::Result<T> where F: FnMut() -> T {\n     cvt(f())\n }\n@@ -112,7 +123,7 @@ impl Socket {\n \n impl Drop for Socket {\n     fn drop(&mut self) {\n-        unsafe { let _ = libc::closesocket(self.0); }\n+        unsafe { cvt(libc::closesocket(self.0)).unwrap(); }\n     }\n }\n "}, {"sha": "587ab7924fd1dc541fd7751cb82a61ff077f3362", "filename": "src/libstd/sys/windows/os.rs", "status": "modified", "additions": 19, "deletions": 17, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fos.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -18,11 +18,13 @@ use os::windows::*;\n use error::Error as StdError;\n use ffi::{OsString, OsStr, AsOsStr};\n use fmt;\n-use ops::Range;\n+use io;\n use libc::types::os::arch::extra::LPWCH;\n use libc::{self, c_int, c_void};\n use mem;\n use old_io::{IoError, IoResult};\n+use ops::Range;\n+use path::{self, PathBuf};\n use ptr;\n use slice;\n use sys::c;\n@@ -151,8 +153,8 @@ pub fn split_paths(unparsed: &OsStr) -> SplitPaths {\n }\n \n impl<'a> Iterator for SplitPaths<'a> {\n-    type Item = Path;\n-    fn next(&mut self) -> Option<Path> {\n+    type Item = PathBuf;\n+    fn next(&mut self) -> Option<PathBuf> {\n         // On Windows, the PATH environment variable is semicolon separated.\n         // Double quotes are used as a way of introducing literal semicolons\n         // (since c:\\some;dir is a valid Windows path). Double quotes are not\n@@ -186,7 +188,7 @@ impl<'a> Iterator for SplitPaths<'a> {\n         if !must_yield && in_progress.is_empty() {\n             None\n         } else {\n-            Some(super::os2path(&in_progress[..]))\n+            Some(super::os2path(&in_progress))\n         }\n     }\n }\n@@ -228,33 +230,33 @@ impl StdError for JoinPathsError {\n     fn description(&self) -> &str { \"failed to join paths\" }\n }\n \n-pub fn current_exe() -> IoResult<Path> {\n-    super::fill_utf16_buf(|buf, sz| unsafe {\n+pub fn current_exe() -> io::Result<PathBuf> {\n+    super::fill_utf16_buf_new(|buf, sz| unsafe {\n         libc::GetModuleFileNameW(ptr::null_mut(), buf, sz)\n     }, super::os2path)\n }\n \n-pub fn getcwd() -> IoResult<Path> {\n-    super::fill_utf16_buf(|buf, sz| unsafe {\n+pub fn getcwd() -> io::Result<PathBuf> {\n+    super::fill_utf16_buf_new(|buf, sz| unsafe {\n         libc::GetCurrentDirectoryW(sz, buf)\n     }, super::os2path)\n }\n \n-pub fn chdir(p: &Path) -> IoResult<()> {\n+pub fn chdir(p: &path::Path) -> io::Result<()> {\n     let mut p = p.as_os_str().encode_wide().collect::<Vec<_>>();\n     p.push(0);\n \n     unsafe {\n         match libc::SetCurrentDirectoryW(p.as_ptr()) != (0 as libc::BOOL) {\n             true => Ok(()),\n-            false => Err(IoError::last_error()),\n+            false => Err(io::Error::last_os_error()),\n         }\n     }\n }\n \n pub fn getenv(k: &OsStr) -> Option<OsString> {\n     let k = super::to_utf16_os(k);\n-    super::fill_utf16_buf(|buf, sz| unsafe {\n+    super::fill_utf16_buf_new(|buf, sz| unsafe {\n         libc::GetEnvironmentVariableW(k.as_ptr(), buf, sz)\n     }, |buf| {\n         OsStringExt::from_wide(buf)\n@@ -349,26 +351,26 @@ pub unsafe fn pipe() -> IoResult<(FileDesc, FileDesc)> {\n     }\n }\n \n-pub fn temp_dir() -> Path {\n-    super::fill_utf16_buf(|buf, sz| unsafe {\n+pub fn temp_dir() -> PathBuf {\n+    super::fill_utf16_buf_new(|buf, sz| unsafe {\n         c::GetTempPathW(sz, buf)\n     }, super::os2path).unwrap()\n }\n \n-pub fn home_dir() -> Option<Path> {\n+pub fn home_dir() -> Option<PathBuf> {\n     getenv(\"HOME\".as_os_str()).or_else(|| {\n         getenv(\"USERPROFILE\".as_os_str())\n     }).map(|os| {\n-        // FIXME: OsString => Path\n-        Path::new(os.to_str().unwrap())\n+        // FIXME(#22751) should consume `os`\n+        PathBuf::new(&os)\n     }).or_else(|| unsafe {\n         let me = c::GetCurrentProcess();\n         let mut token = ptr::null_mut();\n         if c::OpenProcessToken(me, c::TOKEN_READ, &mut token) == 0 {\n             return None\n         }\n         let _handle = RawHandle::new(token);\n-        super::fill_utf16_buf(|buf, mut sz| {\n+        super::fill_utf16_buf_new(|buf, mut sz| {\n             match c::GetUserProfileDirectoryW(token, buf, &mut sz) {\n                 0 if libc::GetLastError() != 0 => 0,\n                 0 => sz,"}, {"sha": "d4c6e85489f5d25d87f82e01791834869ba96fea", "filename": "src/libstd/sys/windows/process2.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Fsys%2Fwindows%2Fprocess2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Fsys%2Fwindows%2Fprocess2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fprocess2.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -16,16 +16,15 @@ use collections;\n use env;\n use ffi::{OsString, OsStr};\n use fmt;\n+use fs;\n use io::{self, Error};\n use libc::{self, c_void};\n-use old_io::fs;\n-use old_path;\n use os::windows::OsStrExt;\n use ptr;\n use sync::{StaticMutex, MUTEX_INIT};\n+use sys::handle::Handle;\n use sys::pipe2::AnonPipe;\n use sys::{self, cvt};\n-use sys::handle::Handle;\n use sys_common::{AsInner, FromInner};\n \n ////////////////////////////////////////////////////////////////////////////////\n@@ -142,9 +141,8 @@ impl Process {\n                 for path in split_paths(&v) {\n                     let path = path.join(cfg.program.to_str().unwrap())\n                                    .with_extension(env::consts::EXE_EXTENSION);\n-                    // FIXME: update with new fs module once it lands\n-                    if fs::stat(&old_path::Path::new(&path)).is_ok() {\n-                        return Some(OsString::from_str(path.as_str().unwrap()))\n+                    if fs::metadata(&path).is_ok() {\n+                        return Some(path.into_os_string())\n                     }\n                 }\n                 break"}, {"sha": "009605535a0237026d18ec29e0d783feb626a362", "filename": "src/libstd/sys/windows/rwlock.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Fsys%2Fwindows%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Fsys%2Fwindows%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Frwlock.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use prelude::v1::*;\n+\n use cell::UnsafeCell;\n use sys::sync as ffi;\n \n@@ -17,6 +19,9 @@ pub const RWLOCK_INIT: RWLock = RWLock {\n     inner: UnsafeCell { value: ffi::SRWLOCK_INIT }\n };\n \n+unsafe impl Send for RWLock {}\n+unsafe impl Sync for RWLock {}\n+\n impl RWLock {\n     #[inline]\n     pub unsafe fn read(&self) {"}, {"sha": "25b70918591d0fc54c6ad488f36f8e42643013ac", "filename": "src/libstd/sys/windows/tcp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Fsys%2Fwindows%2Ftcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Fsys%2Fwindows%2Ftcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ftcp.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -192,7 +192,7 @@ impl TcpAcceptor {\n                         c::WSAEventSelect(socket, events[1], 0)\n                     };\n                     if ret != 0 { return Err(last_net_error()) }\n-                    try!(set_nonblocking(socket, false));\n+                    set_nonblocking(socket, false);\n                     return Ok(stream)\n                 }\n             }"}, {"sha": "c9bac69c434c32ff965213742d1c4d0c08346d51", "filename": "src/libstd/sys/windows/tty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Fsys%2Fwindows%2Ftty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibstd%2Fsys%2Fwindows%2Ftty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Ftty.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -52,7 +52,7 @@ fn invalid_encoding() -> IoError {\n \n pub fn is_tty(fd: c_int) -> bool {\n     let mut out: DWORD = 0;\n-    // If this function doesn't panic then fd is a TTY\n+    // If this function doesn't return an error, then fd is a TTY\n     match unsafe { GetConsoleMode(get_osfhandle(fd) as HANDLE,\n                                   &mut out as LPDWORD) } {\n         0 => false,"}, {"sha": "bea57ae14e4af27c91d8600e7016525bdda30456", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -2025,7 +2025,7 @@ foo_module!();\n         let renamed_crate = renamer.fold_crate(the_crate);\n         let idents = crate_idents(&renamed_crate);\n         let resolved : Vec<ast::Name> = idents.iter().map(|id| mtwt::resolve(*id)).collect();\n-        assert_eq!(resolved,vec!(f_ident.name,Name(16),int_ident.name,Name(16),Name(16),Name(16)));\n+        assert_eq!(resolved, [f_ident.name,Name(16),int_ident.name,Name(16),Name(16),Name(16)]);\n     }\n \n     // test the PatIdentRenamer; only PatIdents get renamed\n@@ -2041,8 +2041,6 @@ foo_module!();\n         let idents = crate_idents(&renamed_crate);\n         let resolved : Vec<ast::Name> = idents.iter().map(|id| mtwt::resolve(*id)).collect();\n         let x_name = x_ident.name;\n-        assert_eq!(resolved,vec!(f_ident.name,Name(16),int_ident.name,Name(16),x_name,x_name));\n+        assert_eq!(resolved, [f_ident.name,Name(16),int_ident.name,Name(16),x_name,x_name]);\n     }\n-\n-\n }"}, {"sha": "72431d8e6aa2c317ccd23aa9449193f01445c344", "filename": "src/libsyntax/ext/mtwt.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibsyntax%2Fext%2Fmtwt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibsyntax%2Fext%2Fmtwt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fmtwt.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -288,19 +288,19 @@ mod tests {\n     fn xorpush_test () {\n         let mut s = Vec::new();\n         xor_push(&mut s, 14);\n-        assert_eq!(s.clone(), vec!(14));\n+        assert_eq!(s.clone(), [14]);\n         xor_push(&mut s, 14);\n-        assert_eq!(s.clone(), Vec::new());\n+        assert_eq!(s.clone(), []);\n         xor_push(&mut s, 14);\n-        assert_eq!(s.clone(), vec!(14));\n+        assert_eq!(s.clone(), [14]);\n         xor_push(&mut s, 15);\n-        assert_eq!(s.clone(), vec!(14, 15));\n+        assert_eq!(s.clone(), [14, 15]);\n         xor_push(&mut s, 16);\n-        assert_eq!(s.clone(), vec!(14, 15, 16));\n+        assert_eq!(s.clone(), [14, 15, 16]);\n         xor_push(&mut s, 16);\n-        assert_eq!(s.clone(), vec!(14, 15));\n+        assert_eq!(s.clone(), [14, 15]);\n         xor_push(&mut s, 15);\n-        assert_eq!(s.clone(), vec!(14));\n+        assert_eq!(s.clone(), [14]);\n     }\n \n     fn id(n: u32, s: SyntaxContext) -> Ident {\n@@ -389,29 +389,29 @@ mod tests {\n         assert_eq!(marksof_internal (EMPTY_CTXT,stopname,&t),Vec::new());\n         // FIXME #5074: ANF'd to dodge nested calls\n         { let ans = unfold_marks(vec!(4,98),EMPTY_CTXT,&mut t);\n-         assert_eq! (marksof_internal (ans,stopname,&t),vec!(4,98));}\n+         assert_eq! (marksof_internal (ans,stopname,&t), [4, 98]);}\n         // does xoring work?\n         { let ans = unfold_marks(vec!(5,5,16),EMPTY_CTXT,&mut t);\n-         assert_eq! (marksof_internal (ans,stopname,&t), vec!(16));}\n+         assert_eq! (marksof_internal (ans,stopname,&t), [16]);}\n         // does nested xoring work?\n         { let ans = unfold_marks(vec!(5,10,10,5,16),EMPTY_CTXT,&mut t);\n-         assert_eq! (marksof_internal (ans, stopname,&t), vec!(16));}\n+         assert_eq! (marksof_internal (ans, stopname,&t), [16]);}\n         // rename where stop doesn't match:\n         { let chain = vec!(M(9),\n                         R(id(name1.usize() as u32,\n                              apply_mark_internal (4, EMPTY_CTXT,&mut t)),\n                           Name(100101102)),\n                         M(14));\n          let ans = unfold_test_sc(chain,EMPTY_CTXT,&mut t);\n-         assert_eq! (marksof_internal (ans, stopname, &t), vec!(9,14));}\n+         assert_eq! (marksof_internal (ans, stopname, &t), [9, 14]);}\n         // rename where stop does match\n         { let name1sc = apply_mark_internal(4, EMPTY_CTXT, &mut t);\n          let chain = vec!(M(9),\n                        R(id(name1.usize() as u32, name1sc),\n                          stopname),\n                        M(14));\n          let ans = unfold_test_sc(chain,EMPTY_CTXT,&mut t);\n-         assert_eq! (marksof_internal (ans, stopname, &t), vec!(9)); }\n+         assert_eq! (marksof_internal (ans, stopname, &t), [9]); }\n     }\n \n "}, {"sha": "c1865ffa9d9a1eb36e96e01f4d9ca1011e8c452e", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -243,7 +243,9 @@ pub static KNOWN_ATTRIBUTES: &'static [(&'static str, AttributeType)] = &[\n     (\"static_assert\", Whitelisted),\n     (\"no_debug\", Whitelisted),\n     (\"omit_gdb_pretty_printer_section\", Whitelisted),\n-    (\"unsafe_no_drop_flag\", Whitelisted),\n+    (\"unsafe_no_drop_flag\", Gated(\"unsafe_no_drop_flag\",\n+                                  \"unsafe_no_drop_flag has unstable semantics \\\n+                                   and may be removed in the future\")),\n \n     // used in resolve\n     (\"prelude_import\", Whitelisted),"}, {"sha": "90df23882a1d4bf53c790a36ed40dae5ac899696", "filename": "src/libsyntax/util/small_vector.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibsyntax%2Futil%2Fsmall_vector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fsmall_vector.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -229,10 +229,10 @@ mod test {\n         assert_eq!(Vec::new(), v);\n \n         let v = SmallVector::one(1);\n-        assert_eq!(vec![1], v.into_iter().collect::<Vec<_>>());\n+        assert_eq!([1], v.into_iter().collect::<Vec<_>>());\n \n         let v = SmallVector::many(vec![1, 2, 3]);\n-        assert_eq!(vec!(1, 2, 3), v.into_iter().collect::<Vec<_>>());\n+        assert_eq!([1, 2, 3], v.into_iter().collect::<Vec<_>>());\n     }\n \n     #[test]"}, {"sha": "823d2879236d1a9d961a60f5c9a8a646968fb7a0", "filename": "src/libterm/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibterm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibterm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Flib.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -60,6 +60,7 @@\n #![feature(unicode)]\n #![feature(std_misc)]\n #![feature(env)]\n+#![feature(os)]\n #![cfg_attr(windows, feature(libc))]\n \n #[macro_use] extern crate log;"}, {"sha": "112525fcce96efe2a1762a6555f4ddee0a80daa5", "filename": "src/libterm/terminfo/parm.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibterm%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibterm%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparm.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -652,15 +652,15 @@ mod test {\n             let s = format!(\"%{{1}}%{{2}}%{}%d\", op);\n             let res = expand(s.as_bytes(), &[], &mut Variables::new());\n             assert!(res.is_ok(), res.err().unwrap());\n-            assert_eq!(res.unwrap(), vec!(b'0' + bs[0]));\n+            assert_eq!(res.unwrap(), [b'0' + bs[0]]);\n             let s = format!(\"%{{1}}%{{1}}%{}%d\", op);\n             let res = expand(s.as_bytes(), &[], &mut Variables::new());\n             assert!(res.is_ok(), res.err().unwrap());\n-            assert_eq!(res.unwrap(), vec!(b'0' + bs[1]));\n+            assert_eq!(res.unwrap(), [b'0' + bs[1]]);\n             let s = format!(\"%{{2}}%{{1}}%{}%d\", op);\n             let res = expand(s.as_bytes(), &[], &mut Variables::new());\n             assert!(res.is_ok(), res.err().unwrap());\n-            assert_eq!(res.unwrap(), vec!(b'0' + bs[2]));\n+            assert_eq!(res.unwrap(), [b'0' + bs[2]]);\n         }\n     }\n "}, {"sha": "a0cd78420700187e78aa2ef451e5ff81f0bf2a3a", "filename": "src/libterm/terminfo/searcher.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibterm%2Fterminfo%2Fsearcher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Flibterm%2Fterminfo%2Fsearcher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fsearcher.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -17,12 +17,13 @@ use std::old_io::fs::PathExtensions;\n use std::env;\n \n /// Return path to database entry for `term`\n+#[allow(deprecated)]\n pub fn get_dbpath_for_term(term: &str) -> Option<Box<Path>> {\n     if term.len() == 0 {\n         return None;\n     }\n \n-    let homedir = env::home_dir();\n+    let homedir = ::std::os::homedir();\n \n     let mut dirs_to_search = Vec::new();\n     let first_char = term.char_at(0);"}, {"sha": "f36d97d6d120d50ef2f42aaa2f47f3de788e49c7", "filename": "src/rustbook/build.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Frustbook%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Frustbook%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustbook%2Fbuild.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -11,6 +11,7 @@\n //! Implementation of the `build` subcommand, used to compile a book.\n \n use std::env;\n+use std::os;\n use std::old_io;\n use std::old_io::{fs, File, BufferedWriter, TempDir, IoResult};\n \n@@ -81,7 +82,7 @@ fn render(book: &Book, tgt: &Path) -> CliResult<()> {\n \n         let src;\n         if env::args().len() < 3 {\n-            src = env::current_dir().unwrap().clone();\n+            src = os::getcwd().unwrap().clone();\n         } else {\n             src = Path::new(env::args().nth(2).unwrap().clone());\n         }\n@@ -149,7 +150,7 @@ impl Subcommand for Build {\n     }\n     fn usage(&self) {}\n     fn execute(&mut self, term: &mut Term) -> CommandResult<()> {\n-        let cwd = env::current_dir().unwrap();\n+        let cwd = os::getcwd().unwrap();\n         let src;\n         let tgt;\n "}, {"sha": "b9fc011e8b9a584edf198247e2eb1d0de9f67399", "filename": "src/rustbook/main.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Frustbook%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Frustbook%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustbook%2Fmain.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -13,6 +13,7 @@\n #![feature(core)]\n #![feature(old_io)]\n #![feature(env)]\n+#![feature(os)]\n #![feature(old_path)]\n #![feature(rustdoc)]\n "}, {"sha": "727a385a8f02811e19eb7a43d87b6500cd369e63", "filename": "src/rustbook/test.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Frustbook%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Frustbook%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustbook%2Ftest.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -17,7 +17,7 @@ use error::Error;\n use term::Term;\n use book;\n use std::old_io::{Command, File};\n-use std::env;\n+use std::os;\n \n struct Test;\n \n@@ -35,7 +35,7 @@ impl Subcommand for Test {\n     }\n     fn usage(&self) {}\n     fn execute(&mut self, term: &mut Term) -> CommandResult<()> {\n-        let cwd = env::current_dir().unwrap();\n+        let cwd = os::getcwd().unwrap();\n         let src = cwd.clone();\n \n         let summary = File::open(&src.join(\"SUMMARY.md\"));"}, {"sha": "3098807f272f3ed2163047ae215c5732cba70129", "filename": "src/test/compile-fail/borrowck-fn-in-const-a.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Ftest%2Fcompile-fail%2Fborrowck-fn-in-const-a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Ftest%2Fcompile-fail%2Fborrowck-fn-in-const-a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-fn-in-const-a.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that we check fns appearing in constant declarations.\n+// Issue #22382.\n+\n+const MOVE: fn(&String) -> String = {\n+    fn broken(x: &String) -> String {\n+        return *x //~ ERROR cannot move\n+    }\n+    broken\n+};\n+\n+fn main() {\n+}"}, {"sha": "7e29b2ee0fd4e76c326dd03684cb0e17e49a576a", "filename": "src/test/compile-fail/borrowck-fn-in-const-b.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Ftest%2Fcompile-fail%2Fborrowck-fn-in-const-b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Ftest%2Fcompile-fail%2Fborrowck-fn-in-const-b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-fn-in-const-b.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that we check fns appearing in constant declarations.\n+// Issue #22382.\n+\n+// How about mutating an immutable vector?\n+const MUTATE: fn(&Vec<String>) = {\n+    fn broken(x: &Vec<String>) {\n+        x.push(format!(\"this is broken\"));\n+        //~^ ERROR cannot borrow\n+    }\n+    broken\n+};\n+\n+fn main() {\n+}"}, {"sha": "e607397e920e27c5bffbee6a5e59108556fb54c9", "filename": "src/test/compile-fail/borrowck-fn-in-const-c.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Ftest%2Fcompile-fail%2Fborrowck-fn-in-const-c.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Ftest%2Fcompile-fail%2Fborrowck-fn-in-const-c.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-fn-in-const-c.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -0,0 +1,33 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Check that we check fns appearing in constant declarations.\n+// Issue #22382.\n+\n+// Returning local references?\n+struct DropString {\n+    inner: String\n+}\n+impl Drop for DropString {\n+    fn drop(&mut self) {\n+        self.inner.clear();\n+        self.inner.push_str(\"dropped\");\n+    }\n+}\n+const LOCAL_REF: fn() -> &'static str = {\n+    fn broken() -> &'static str {\n+        let local = DropString { inner: format!(\"Some local string\") };\n+        return &local.inner; //~ ERROR does not live long enough\n+    }\n+    broken\n+};\n+\n+fn main() {\n+}"}, {"sha": "8440cf3a88e10adda62bc34751beb3a3d62e5548", "filename": "src/test/compile-fail/lint-unsafe-code.rs", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Ftest%2Fcompile-fail%2Flint-unsafe-code.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Ftest%2Fcompile-fail%2Flint-unsafe-code.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-unsafe-code.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -15,6 +15,8 @@\n use std::marker::PhantomFn;\n \n struct Bar;\n+struct Bar2;\n+struct Bar3;\n \n #[allow(unsafe_code)]\n mod allowed_unsafe {\n@@ -46,6 +48,53 @@ impl Baz for Bar {\n     unsafe fn provided_override(&self) {} //~ ERROR: implementation of an `unsafe` method\n }\n \n+\n+#[allow(unsafe_code)]\n+trait A {\n+    unsafe fn allowed_unsafe(&self);\n+    unsafe fn allowed_unsafe_provided(&self) {}\n+}\n+\n+#[allow(unsafe_code)]\n+impl Baz for Bar2 {\n+    unsafe fn baz(&self) {}\n+    unsafe fn provided_override(&self) {}\n+}\n+\n+impl Baz for Bar3 {\n+    #[allow(unsafe_code)]\n+    unsafe fn baz(&self) {}\n+    unsafe fn provided_override(&self) {} //~ ERROR: implementation of an `unsafe` method\n+}\n+\n+#[allow(unsafe_code)]\n+unsafe trait B {\n+    fn dummy(&self) {}\n+}\n+\n+trait C {\n+    #[allow(unsafe_code)]\n+    unsafe fn baz(&self);\n+    unsafe fn provided(&self) {} //~ ERROR: implementation of an `unsafe` method\n+}\n+\n+impl C for Bar {\n+    #[allow(unsafe_code)]\n+    unsafe fn baz(&self) {}\n+    unsafe fn provided(&self) {} //~ ERROR: implementation of an `unsafe` method\n+}\n+\n+impl C for Bar2 {\n+    unsafe fn baz(&self) {} //~ ERROR: implementation of an `unsafe` method\n+}\n+\n+trait D {\n+    #[allow(unsafe_code)]\n+    unsafe fn unsafe_provided(&self) {}\n+}\n+\n+impl D for Bar {}\n+\n fn main() {\n     unsafe {} //~ ERROR: usage of an `unsafe` block\n "}, {"sha": "542698fd15295f13260cacc029234fabda8f4cd1", "filename": "src/test/compile-fail/unsafe_no_drop_flag-gate.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Ftest%2Fcompile-fail%2Funsafe_no_drop_flag-gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Ftest%2Fcompile-fail%2Funsafe_no_drop_flag-gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funsafe_no_drop_flag-gate.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub struct T;\n+\n+#[unsafe_no_drop_flag]\n+//~^ ERROR unsafe_no_drop_flag has unstable semantics and may be removed\n+pub struct S {\n+    pub x: T,\n+}\n+\n+impl Drop for S {\n+    fn drop(&mut self) {}\n+}\n+\n+pub fn main() {}"}, {"sha": "d2e9bc2efe7279c10a0a00d7c25b6b1522aea5d1", "filename": "src/test/run-pass/auto-ref-sliceable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Ftest%2Frun-pass%2Fauto-ref-sliceable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Ftest%2Frun-pass%2Fauto-ref-sliceable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fauto-ref-sliceable.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -23,5 +23,5 @@ pub fn main() {\n     let mut v = vec!(1);\n     v.push_val(2);\n     v.push_val(3);\n-    assert_eq!(v, vec!(1, 2, 3));\n+    assert_eq!(v, [1, 2, 3]);\n }"}, {"sha": "2473b4b674e5784a1fcf94cd65253014952ac748", "filename": "src/test/run-pass/coerce-reborrow-mut-vec-arg.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-mut-vec-arg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-mut-vec-arg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-mut-vec-arg.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -22,5 +22,5 @@ fn bar(v: &mut [uint]) {\n pub fn main() {\n     let mut the_vec = vec!(1, 2, 3, 100);\n     bar(&mut the_vec);\n-    assert_eq!(the_vec, vec!(100, 3, 2, 1));\n+    assert_eq!(the_vec, [100, 3, 2, 1]);\n }"}, {"sha": "ea09bb3904de6b950f027f95b9094bd885ed66ef", "filename": "src/test/run-pass/coerce-reborrow-mut-vec-rcvr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-mut-vec-rcvr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-mut-vec-rcvr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fcoerce-reborrow-mut-vec-rcvr.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -18,5 +18,5 @@ fn bar(v: &mut [uint]) {\n pub fn main() {\n     let mut the_vec = vec!(1, 2, 3, 100);\n     bar(&mut the_vec);\n-    assert_eq!(the_vec, vec!(100, 3, 2, 1));\n+    assert_eq!(the_vec, [100, 3, 2, 1]);\n }"}, {"sha": "5d68a25a14ada73433012e8a3a13ccdf1c9c04f0", "filename": "src/test/run-pass/env-home-dir.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Ftest%2Frun-pass%2Fenv-home-dir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Ftest%2Frun-pass%2Fenv-home-dir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fenv-home-dir.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -9,13 +9,14 @@\n // except according to those terms.\n \n use std::env::*;\n+use std::path::PathBuf;\n \n #[cfg(unix)]\n fn main() {\n     let oldhome = var(\"HOME\");\n \n     set_var(\"HOME\", \"/home/MountainView\");\n-    assert!(home_dir() == Some(Path::new(\"/home/MountainView\")));\n+    assert!(home_dir() == Some(PathBuf::new(\"/home/MountainView\")));\n \n     remove_var(\"HOME\");\n     if cfg!(target_os = \"android\") {\n@@ -36,14 +37,14 @@ fn main() {\n     assert!(home_dir().is_some());\n \n     set_var(\"HOME\", \"/home/MountainView\");\n-    assert!(home_dir() == Some(Path::new(\"/home/MountainView\")));\n+    assert!(home_dir() == Some(PathBuf::new(\"/home/MountainView\")));\n \n     remove_var(\"HOME\");\n \n     set_var(\"USERPROFILE\", \"/home/MountainView\");\n-    assert!(home_dir() == Some(Path::new(\"/home/MountainView\")));\n+    assert!(home_dir() == Some(PathBuf::new(\"/home/MountainView\")));\n \n     set_var(\"HOME\", \"/home/MountainView\");\n     set_var(\"USERPROFILE\", \"/home/PaloAlto\");\n-    assert!(home_dir() == Some(Path::new(\"/home/MountainView\")));\n+    assert!(home_dir() == Some(PathBuf::new(\"/home/MountainView\")));\n }"}, {"sha": "010f54dd55934ea53c425066dd4bb67dde200c85", "filename": "src/test/run-pass/generic-static-methods.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Ftest%2Frun-pass%2Fgeneric-static-methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Ftest%2Frun-pass%2Fgeneric-static-methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fgeneric-static-methods.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -24,5 +24,5 @@ impl<T> vec_utils<T> for Vec<T> {\n }\n \n pub fn main() {\n-    assert_eq!(vec_utils::map_(&vec!(1,2,3), |&x| x+1), vec!(2,3,4));\n+    assert_eq!(vec_utils::map_(&vec!(1,2,3), |&x| x+1), [2,3,4]);\n }"}, {"sha": "d995ecc492e3477f65d3ac466c4d30e8e00d100c", "filename": "src/test/run-pass/issue-15149.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Ftest%2Frun-pass%2Fissue-15149.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Ftest%2Frun-pass%2Fissue-15149.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-15149.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -1,5 +1,3 @@\n-// no-prefer-dynamic\n-\n // Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n@@ -10,12 +8,15 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::slice::SliceExt;\n-use std::old_io::{fs, USER_RWX};\n-use std::process;\n+// no-prefer-dynamic\n+\n+#![feature(fs, process, env, path, rand)]\n+\n use std::env;\n-use std::old_path::BytesContainer;\n+use std::fs;\n+use std::process;\n use std::rand::random;\n+use std::str;\n \n fn main() {\n     // If we're the child, make sure we were invoked correctly\n@@ -34,21 +35,20 @@ fn main() {\n fn test() {\n     // If we're the parent, copy our own binary to a new directory.\n     let my_path = env::current_exe().unwrap();\n-    let my_dir  = my_path.dir_path();\n+    let my_dir  = my_path.parent().unwrap();\n \n     let random_u32: u32 = random();\n-    let child_dir = Path::new(my_dir.join(format!(\"issue-15149-child-{}\",\n-                                                  random_u32)));\n-    fs::mkdir(&child_dir, USER_RWX).unwrap();\n+    let child_dir = my_dir.join(&format!(\"issue-15149-child-{}\", random_u32));\n+    fs::create_dir(&child_dir).unwrap();\n \n-    let child_path = child_dir.join(format!(\"mytest{}\",\n-                                            env::consts::EXE_SUFFIX));\n+    let child_path = child_dir.join(&format!(\"mytest{}\",\n+                                             env::consts::EXE_SUFFIX));\n     fs::copy(&my_path, &child_path).unwrap();\n \n     // Append the new directory to our own PATH.\n     let path = {\n         let mut paths: Vec<_> = env::split_paths(&env::var_os(\"PATH\").unwrap()).collect();\n-        paths.push(child_dir.clone());\n+        paths.push(child_dir.to_path_buf());\n         env::join_paths(paths.iter()).unwrap()\n     };\n \n@@ -58,9 +58,9 @@ fn test() {\n \n     assert!(child_output.status.success(),\n             format!(\"child assertion failed\\n child stdout:\\n {}\\n child stderr:\\n {}\",\n-                    child_output.stdout.container_as_str().unwrap(),\n-                    child_output.stderr.container_as_str().unwrap()));\n+                    str::from_utf8(&child_output.stdout).unwrap(),\n+                    str::from_utf8(&child_output.stderr).unwrap()));\n \n-    fs::rmdir_recursive(&child_dir).unwrap();\n+    fs::remove_dir_all(&child_dir).unwrap();\n \n }"}, {"sha": "92d8dfa2cf9a975bc306078ebdfeebe5267c1f63", "filename": "src/test/run-pass/issue-16272.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Ftest%2Frun-pass%2Fissue-16272.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Ftest%2Frun-pass%2Fissue-16272.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-16272.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::old_io::{process, Command};\n+use std::process::Command;\n use std::env;\n \n fn main() {\n@@ -22,10 +22,8 @@ fn main() {\n }\n \n fn test() {\n-    let status = Command::new(env::current_exe().unwrap())\n+    let status = Command::new(&env::current_exe().unwrap())\n                          .arg(\"foo\").arg(\"\")\n-                         .stdout(process::InheritFd(1))\n-                         .stderr(process::InheritFd(2))\n                          .status().unwrap();\n     assert!(status.success());\n }"}, {"sha": "ba107dd2cf9a2457b8b41db94e66834b9b56847f", "filename": "src/test/run-pass/issue-20091.rs", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Ftest%2Frun-pass%2Fissue-20091.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Ftest%2Frun-pass%2Fissue-20091.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-20091.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -8,14 +8,19 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// ignore-windows currently windows requires UTF-8 for spawning processes\n-\n-use std::old_io::Command;\n-use std::env;\n-\n+#[cfg(unix)]\n fn main() {\n+    use std::process::Command;\n+    use std::env;\n+    use std::os::unix::prelude::*;\n+    use std::ffi::OsStr;\n+\n     if env::args().len() == 1 {\n-        assert!(Command::new(env::current_exe().unwrap()).arg(b\"\\xff\")\n+        assert!(Command::new(&env::current_exe().unwrap())\n+                        .arg(<OsStr as OsStrExt>::from_bytes(b\"\\xff\"))\n                         .status().unwrap().success())\n     }\n }\n+\n+#[cfg(windows)]\n+fn main() {}"}, {"sha": "3f1a1c75d8a78c077fad6d1c1fceb651c5be0e82", "filename": "src/test/run-pass/issue-3559.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Ftest%2Frun-pass%2Fissue-3559.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Ftest%2Frun-pass%2Fissue-3559.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-3559.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -24,6 +24,6 @@ pub fn main() {\n     let mut table = HashMap::new();\n     table.insert(\"one\".to_string(), 1);\n     table.insert(\"two\".to_string(), 2);\n-    assert!(check_strs(&format!(\"{:?}\", table), \"HashMap {\\\"one\\\": 1, \\\"two\\\": 2}\") ||\n-            check_strs(&format!(\"{:?}\", table), \"HashMap {\\\"two\\\": 2, \\\"one\\\": 1}\"));\n+    assert!(check_strs(&format!(\"{:?}\", table), \"{\\\"one\\\": 1, \\\"two\\\": 2}\") ||\n+            check_strs(&format!(\"{:?}\", table), \"{\\\"two\\\": 2, \\\"one\\\": 1}\"));\n }"}, {"sha": "0d563f1a714c350cecbf0f18523c9a2c7fa993ad", "filename": "src/test/run-pass/monad.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Ftest%2Frun-pass%2Fmonad.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Ftest%2Frun-pass%2Fmonad.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmonad.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -44,11 +44,11 @@ fn transform(x: Option<int>) -> Option<String> {\n pub fn main() {\n     assert_eq!(transform(Some(10)), Some(\"11\".to_string()));\n     assert_eq!(transform(None), None);\n-    assert!((vec!(\"hi\".to_string()))\n+    assert_eq!((vec!(\"hi\".to_string()))\n         .bind(|x| vec!(x.clone(), format!(\"{}!\", x)) )\n-        .bind(|x| vec!(x.clone(), format!(\"{}?\", x)) ) ==\n-        vec!(\"hi\".to_string(),\n-             \"hi?\".to_string(),\n-             \"hi!\".to_string(),\n-             \"hi!?\".to_string()));\n+        .bind(|x| vec!(x.clone(), format!(\"{}?\", x)) ),\n+        [\"hi\".to_string(),\n+         \"hi?\".to_string(),\n+         \"hi!\".to_string(),\n+         \"hi!?\".to_string()]);\n }"}, {"sha": "d2d72ed16618df6e74be3321eb5f9346043cc665", "filename": "src/test/run-pass/std-sync-right-kind-impls.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Ftest%2Frun-pass%2Fstd-sync-right-kind-impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Ftest%2Frun-pass%2Fstd-sync-right-kind-impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fstd-sync-right-kind-impls.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use std::sync;\n+\n+fn assert_both<T: Sync + Send>() {}\n+\n+fn main() {\n+    assert_both::<sync::StaticMutex>();\n+    assert_both::<sync::StaticCondvar>();\n+    assert_both::<sync::StaticRwLock>();\n+    assert_both::<sync::Mutex<()>>();\n+    assert_both::<sync::Condvar>();\n+    assert_both::<sync::RwLock<()>>();\n+    assert_both::<sync::Semaphore>();\n+    assert_both::<sync::Barrier>();\n+    assert_both::<sync::Arc<()>>();\n+    assert_both::<sync::Weak<()>>();\n+    assert_both::<sync::Once>();\n+}"}, {"sha": "0dedf621a4f2887f0f6205142239e505e9e638bf", "filename": "src/test/run-pass/trait-generic.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Ftest%2Frun-pass%2Ftrait-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Ftest%2Frun-pass%2Ftrait-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ftrait-generic.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -44,9 +44,9 @@ fn bar<U:to_str,T:map<U>>(x: T) -> Vec<String> {\n }\n \n pub fn main() {\n-    assert_eq!(foo(vec!(1)), vec!(\"hi\".to_string()));\n-    assert_eq!(bar::<int, Vec<int> >(vec!(4, 5)), vec!(\"4\".to_string(), \"5\".to_string()));\n+    assert_eq!(foo(vec!(1)), [\"hi\".to_string()]);\n+    assert_eq!(bar::<int, Vec<int> >(vec!(4, 5)), [\"4\".to_string(), \"5\".to_string()]);\n     assert_eq!(bar::<String, Vec<String> >(vec!(\"x\".to_string(), \"y\".to_string())),\n-               vec!(\"x\".to_string(), \"y\".to_string()));\n-    assert_eq!(bar::<(), Vec<()>>(vec!(())), vec!(\"()\".to_string()));\n+               [\"x\".to_string(), \"y\".to_string()]);\n+    assert_eq!(bar::<(), Vec<()>>(vec!(())), [\"()\".to_string()]);\n }"}, {"sha": "1401fe7470b0a1d71f0772e2d9217414625cdbde", "filename": "src/test/run-pass/unboxed-closures-infer-upvar.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4db0b32467535d718d6474de7ae8d1007d900818/src%2Ftest%2Frun-pass%2Funboxed-closures-infer-upvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4db0b32467535d718d6474de7ae8d1007d900818/src%2Ftest%2Frun-pass%2Funboxed-closures-infer-upvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Funboxed-closures-infer-upvar.rs?ref=4db0b32467535d718d6474de7ae8d1007d900818", "patch": "@@ -18,5 +18,5 @@ fn f<F: FnMut()>(mut f: F) {\n fn main() {\n     let mut v: Vec<_> = vec![];\n     f(|| v.push(0));\n-    assert_eq!(v, vec![0]);\n+    assert_eq!(v, [0]);\n }"}]}