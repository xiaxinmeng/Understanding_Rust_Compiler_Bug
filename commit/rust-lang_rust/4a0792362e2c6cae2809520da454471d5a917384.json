{"sha": "4a0792362e2c6cae2809520da454471d5a917384", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRhMDc5MjM2MmUyYzZjYWUyODA5NTIwZGE0NTQ0NzFkNWE5MTczODQ=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-11-26T13:59:24Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-11-26T14:44:43Z"}, "message": "Detangle ty from traits a bit", "tree": {"sha": "e0205440b58772a43f13e2a4c547f1b7008efe46", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e0205440b58772a43f13e2a4c547f1b7008efe46"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4a0792362e2c6cae2809520da454471d5a917384", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4a0792362e2c6cae2809520da454471d5a917384", "html_url": "https://github.com/rust-lang/rust/commit/4a0792362e2c6cae2809520da454471d5a917384", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4a0792362e2c6cae2809520da454471d5a917384/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4d753fa6f514ea1105c25ace91201c5324ee0b92", "url": "https://api.github.com/repos/rust-lang/rust/commits/4d753fa6f514ea1105c25ace91201c5324ee0b92", "html_url": "https://github.com/rust-lang/rust/commit/4d753fa6f514ea1105c25ace91201c5324ee0b92"}], "stats": {"total": 112, "additions": 63, "deletions": 49}, "files": [{"sha": "9930cff6635aab8dbb7b94467cf591c9fb5ccdf8", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 7, "deletions": 46, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/4a0792362e2c6cae2809520da454471d5a917384/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a0792362e2c6cae2809520da454471d5a917384/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=4a0792362e2c6cae2809520da454471d5a917384", "patch": "@@ -9,7 +9,7 @@ use hir_def::{\n     builtin_type::BuiltinType,\n     docs::Documentation,\n     per_ns::PerNs,\n-    resolver::{HasResolver, TypeNs},\n+    resolver::HasResolver,\n     type_ref::{Mutability, TypeRef},\n     AdtId, AstItemDef, ConstId, ContainerId, DefWithBodyId, EnumId, FunctionId, GenericDefId,\n     HasModule, ImplId, LocalEnumVariantId, LocalImportId, LocalModuleId, LocalStructFieldId,\n@@ -28,8 +28,8 @@ use crate::{\n     expr::{BindingAnnotation, Body, BodySourceMap, ExprValidator, Pat, PatId},\n     ty::display::HirFormatter,\n     ty::{\n-        self, InEnvironment, InferenceResult, Namespace, TraitEnvironment, TraitRef, Ty, TypeCtor,\n-        TypeWalk,\n+        self, utils::all_super_traits, InEnvironment, InferenceResult, Namespace, TraitEnvironment,\n+        TraitRef, Ty, TypeCtor, TypeWalk,\n     },\n     CallableDef, Either, HirDisplay, Name, Source,\n };\n@@ -740,48 +740,6 @@ impl Trait {\n         db.trait_data(self.id).items.iter().map(|it| (*it).into()).collect()\n     }\n \n-    fn direct_super_traits(self, db: &impl HirDatabase) -> Vec<Trait> {\n-        let resolver = self.id.resolver(db);\n-        // returning the iterator directly doesn't easily work because of\n-        // lifetime problems, but since there usually shouldn't be more than a\n-        // few direct traits this should be fine (we could even use some kind of\n-        // SmallVec if performance is a concern)\n-        db.generic_params(self.id.into())\n-            .where_predicates\n-            .iter()\n-            .filter_map(|pred| match &pred.type_ref {\n-                TypeRef::Path(p) if p.as_ident() == Some(&name::SELF_TYPE) => pred.bound.as_path(),\n-                _ => None,\n-            })\n-            .filter_map(|path| match resolver.resolve_path_in_type_ns_fully(db, path) {\n-                Some(TypeNs::TraitId(t)) => Some(t),\n-                _ => None,\n-            })\n-            .map(Trait::from)\n-            .collect()\n-    }\n-\n-    /// Returns an iterator over the whole super trait hierarchy (including the\n-    /// trait itself).\n-    pub fn all_super_traits(self, db: &impl HirDatabase) -> Vec<Trait> {\n-        // we need to take care a bit here to avoid infinite loops in case of cycles\n-        // (i.e. if we have `trait A: B; trait B: A;`)\n-        let mut result = vec![self];\n-        let mut i = 0;\n-        while i < result.len() {\n-            let t = result[i];\n-            // yeah this is quadratic, but trait hierarchies should be flat\n-            // enough that this doesn't matter\n-            for tt in t.direct_super_traits(db) {\n-                if !result.contains(&tt) {\n-                    result.push(tt);\n-                }\n-            }\n-            i += 1;\n-        }\n-        result\n-    }\n-\n     pub fn associated_type_by_name(self, db: &impl DefDatabase, name: &Name) -> Option<TypeAlias> {\n         let trait_data = db.trait_data(self.id);\n         let res =\n@@ -794,7 +752,10 @@ impl Trait {\n         db: &impl HirDatabase,\n         name: &Name,\n     ) -> Option<TypeAlias> {\n-        self.all_super_traits(db).into_iter().find_map(|t| t.associated_type_by_name(db, name))\n+        all_super_traits(db, self.id)\n+            .into_iter()\n+            .map(Trait::from)\n+            .find_map(|t| t.associated_type_by_name(db, name))\n     }\n \n     pub fn trait_ref(self, db: &impl HirDatabase) -> TraitRef {"}, {"sha": "2a2dc26b493c05a389b21012b6fef44ca31c3127", "filename": "crates/ra_hir/src/ty.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/4a0792362e2c6cae2809520da454471d5a917384/crates%2Fra_hir%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a0792362e2c6cae2809520da454471d5a917384/crates%2Fra_hir%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty.rs?ref=4a0792362e2c6cae2809520da454471d5a917384", "patch": "@@ -9,6 +9,7 @@ mod op;\n mod lower;\n mod infer;\n pub(crate) mod display;\n+pub(crate) mod utils;\n \n #[cfg(test)]\n mod tests;"}, {"sha": "9e3afabe0d309bb3faeb654928fe9c38a3c64356", "filename": "crates/ra_hir/src/ty/lower.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4a0792362e2c6cae2809520da454471d5a917384/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a0792362e2c6cae2809520da454471d5a917384/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Flower.rs?ref=4a0792362e2c6cae2809520da454471d5a917384", "patch": "@@ -28,6 +28,7 @@ use crate::{\n     db::HirDatabase,\n     ty::{\n         primitive::{FloatTy, IntTy},\n+        utils::all_super_traits,\n         Adt,\n     },\n     util::make_mut_slice,\n@@ -260,7 +261,7 @@ impl Ty {\n             GenericPredicate::Implemented(tr) if tr.self_ty() == &self_ty => Some(tr.trait_),\n             _ => None,\n         });\n-        let traits = traits_from_env.flat_map(|t| t.all_super_traits(db));\n+        let traits = traits_from_env.flat_map(|t| all_super_traits(db, t.id)).map(Trait::from);\n         for t in traits {\n             if let Some(associated_ty) = t.associated_type_by_name(db, &segment.name) {\n                 let substs = Substs::build_for_def(db, t.id)"}, {"sha": "0e18684ed794932db53de11eee068bf3a8958966", "filename": "crates/ra_hir/src/ty/method_resolution.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/4a0792362e2c6cae2809520da454471d5a917384/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a0792362e2c6cae2809520da454471d5a917384/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs?ref=4a0792362e2c6cae2809520da454471d5a917384", "patch": "@@ -16,7 +16,7 @@ use rustc_hash::FxHashMap;\n use crate::{\n     db::HirDatabase,\n     ty::primitive::{FloatBitness, Uncertain},\n-    ty::{Ty, TypeCtor},\n+    ty::{utils::all_super_traits, Ty, TypeCtor},\n     AssocItem, Crate, Function, Mutability, Name, Trait,\n };\n \n@@ -249,7 +249,8 @@ fn iterate_trait_method_candidates<T>(\n     let traits_from_env = env\n         .trait_predicates_for_self_ty(&ty.value)\n         .map(|tr| tr.trait_)\n-        .flat_map(|t| t.all_super_traits(db));\n+        .flat_map(|t| all_super_traits(db, t.id))\n+        .map(Trait::from);\n     let traits = inherent_trait\n         .chain(traits_from_env)\n         .chain(resolver.traits_in_scope(db).into_iter().map(Trait::from));"}, {"sha": "345fa94300a5587b797b66d895add18f49a0ee3f", "filename": "crates/ra_hir/src/ty/utils.rs", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/4a0792362e2c6cae2809520da454471d5a917384/crates%2Fra_hir%2Fsrc%2Fty%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4a0792362e2c6cae2809520da454471d5a917384/crates%2Fra_hir%2Fsrc%2Fty%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Futils.rs?ref=4a0792362e2c6cae2809520da454471d5a917384", "patch": "@@ -0,0 +1,50 @@\n+use hir_def::{\n+    db::DefDatabase,\n+    resolver::{HasResolver, TypeNs},\n+    type_ref::TypeRef,\n+    TraitId,\n+};\n+use hir_expand::name;\n+\n+// FIXME: this is wrong, b/c it can't express `trait T: PartialEq<()>`.\n+// We should return a `TraitREf` here.\n+fn direct_super_traits(db: &impl DefDatabase, trait_: TraitId) -> Vec<TraitId> {\n+    let resolver = trait_.resolver(db);\n+    // returning the iterator directly doesn't easily work because of\n+    // lifetime problems, but since there usually shouldn't be more than a\n+    // few direct traits this should be fine (we could even use some kind of\n+    // SmallVec if performance is a concern)\n+    db.generic_params(trait_.into())\n+        .where_predicates\n+        .iter()\n+        .filter_map(|pred| match &pred.type_ref {\n+            TypeRef::Path(p) if p.as_ident() == Some(&name::SELF_TYPE) => pred.bound.as_path(),\n+            _ => None,\n+        })\n+        .filter_map(|path| match resolver.resolve_path_in_type_ns_fully(db, path) {\n+            Some(TypeNs::TraitId(t)) => Some(t),\n+            _ => None,\n+        })\n+        .collect()\n+}\n+\n+/// Returns an iterator over the whole super trait hierarchy (including the\n+/// trait itself).\n+pub(crate) fn all_super_traits(db: &impl DefDatabase, trait_: TraitId) -> Vec<TraitId> {\n+    // we need to take care a bit here to avoid infinite loops in case of cycles\n+    // (i.e. if we have `trait A: B; trait B: A;`)\n+    let mut result = vec![trait_];\n+    let mut i = 0;\n+    while i < result.len() {\n+        let t = result[i];\n+        // yeah this is quadratic, but trait hierarchies should be flat\n+        // enough that this doesn't matter\n+        for tt in direct_super_traits(db, t) {\n+            if !result.contains(&tt) {\n+                result.push(tt);\n+            }\n+        }\n+        i += 1;\n+    }\n+    result\n+}"}]}