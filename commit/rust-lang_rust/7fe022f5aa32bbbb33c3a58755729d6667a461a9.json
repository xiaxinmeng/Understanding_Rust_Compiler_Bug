{"sha": "7fe022f5aa32bbbb33c3a58755729d6667a461a9", "node_id": "C_kwDOAAsO6NoAKDdmZTAyMmY1YWEzMmJiYmIzM2MzYTU4NzU1NzI5ZDY2NjdhNDYxYTk", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-24T18:55:31Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-24T18:55:31Z"}, "message": "Auto merge of #99687 - RalfJung:rollup-bojacrc, r=RalfJung\n\nRollup of 4 pull requests\n\nSuccessful merges:\n\n - #99644 (remove some provenance-related machine hooks that Miri no longer needs)\n - #99657 (Docs - remove unnecessary `mut` that gives a warning)\n - #99672 (Remove Clean trait implementation for more items)\n - #99678 (Update doc comments that refer to config parameter)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "60d5e26b42806961b1a772430a2a294d5a75c7f1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/60d5e26b42806961b1a772430a2a294d5a75c7f1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/7fe022f5aa32bbbb33c3a58755729d6667a461a9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/7fe022f5aa32bbbb33c3a58755729d6667a461a9", "html_url": "https://github.com/rust-lang/rust/commit/7fe022f5aa32bbbb33c3a58755729d6667a461a9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/7fe022f5aa32bbbb33c3a58755729d6667a461a9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2a990f7c0fe4d00042269beb7ee67d0082de4e07", "url": "https://api.github.com/repos/rust-lang/rust/commits/2a990f7c0fe4d00042269beb7ee67d0082de4e07", "html_url": "https://github.com/rust-lang/rust/commit/2a990f7c0fe4d00042269beb7ee67d0082de4e07"}, {"sha": "34d0c0abf66efa76fb8f6639eb0d922ba7844c5a", "url": "https://api.github.com/repos/rust-lang/rust/commits/34d0c0abf66efa76fb8f6639eb0d922ba7844c5a", "html_url": "https://github.com/rust-lang/rust/commit/34d0c0abf66efa76fb8f6639eb0d922ba7844c5a"}], "stats": {"total": 261, "additions": 115, "deletions": 146}, "files": [{"sha": "ba8222dc15218d245af6ab41ceab5d2524ad7e3b", "filename": "compiler/rustc_const_eval/src/const_eval/eval_queries.rs", "status": "modified", "additions": 11, "deletions": 12, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7fe022f5aa32bbbb33c3a58755729d6667a461a9/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fe022f5aa32bbbb33c3a58755729d6667a461a9/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Fconst_eval%2Feval_queries.rs?ref=7fe022f5aa32bbbb33c3a58755729d6667a461a9", "patch": "@@ -173,18 +173,17 @@ pub(super) fn op_to_const<'tcx>(\n             Immediate::ScalarPair(a, b) => {\n                 debug!(\"ScalarPair(a: {:?}, b: {:?})\", a, b);\n                 // We know `offset` is relative to the allocation, so we can use `into_parts`.\n-                let (data, start) =\n-                    match ecx.scalar_to_ptr(a.check_init().unwrap()).unwrap().into_parts() {\n-                        (Some(alloc_id), offset) => {\n-                            (ecx.tcx.global_alloc(alloc_id).unwrap_memory(), offset.bytes())\n-                        }\n-                        (None, _offset) => (\n-                            ecx.tcx.intern_const_alloc(\n-                                Allocation::from_bytes_byte_aligned_immutable(b\"\" as &[u8]),\n-                            ),\n-                            0,\n-                        ),\n-                    };\n+                let (data, start) = match a.to_pointer(ecx).unwrap().into_parts() {\n+                    (Some(alloc_id), offset) => {\n+                        (ecx.tcx.global_alloc(alloc_id).unwrap_memory(), offset.bytes())\n+                    }\n+                    (None, _offset) => (\n+                        ecx.tcx.intern_const_alloc(Allocation::from_bytes_byte_aligned_immutable(\n+                            b\"\" as &[u8],\n+                        )),\n+                        0,\n+                    ),\n+                };\n                 let len = b.to_machine_usize(ecx).unwrap();\n                 let start = start.try_into().unwrap();\n                 let len: usize = len.try_into().unwrap();"}, {"sha": "c97c31eb9dadfb98508feee369e9697a24dbdce8", "filename": "compiler/rustc_const_eval/src/interpret/cast.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7fe022f5aa32bbbb33c3a58755729d6667a461a9/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fe022f5aa32bbbb33c3a58755729d6667a461a9/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fcast.rs?ref=7fe022f5aa32bbbb33c3a58755729d6667a461a9", "patch": "@@ -180,7 +180,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         assert!(cast_ty.is_integral());\n \n         let scalar = src.to_scalar()?;\n-        let ptr = self.scalar_to_ptr(scalar)?;\n+        let ptr = scalar.to_pointer(self)?;\n         match ptr.into_pointer_or_addr() {\n             Ok(ptr) => M::expose_ptr(self, ptr)?,\n             Err(_) => {} // Do nothing, exposing an invalid pointer (`None` provenance) is a NOP.\n@@ -299,7 +299,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             }\n             (&ty::Dynamic(ref data_a, ..), &ty::Dynamic(ref data_b, ..)) => {\n                 let (old_data, old_vptr) = self.read_immediate(src)?.to_scalar_pair()?;\n-                let old_vptr = self.scalar_to_ptr(old_vptr)?;\n+                let old_vptr = old_vptr.to_pointer(self)?;\n                 let (ty, old_trait) = self.get_ptr_vtable(old_vptr)?;\n                 if old_trait != data_a.principal() {\n                     throw_ub_format!(\"upcast on a pointer whose vtable does not match its type\");"}, {"sha": "150d6589b0807e811f38df685f3e4a51993dd41f", "filename": "compiler/rustc_const_eval/src/interpret/eval_context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7fe022f5aa32bbbb33c3a58755729d6667a461a9/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fe022f5aa32bbbb33c3a58755729d6667a461a9/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Feval_context.rs?ref=7fe022f5aa32bbbb33c3a58755729d6667a461a9", "patch": "@@ -629,7 +629,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 Ok(Some((size, align)))\n             }\n             ty::Dynamic(..) => {\n-                let vtable = self.scalar_to_ptr(metadata.unwrap_meta())?;\n+                let vtable = metadata.unwrap_meta().to_pointer(self)?;\n                 // Read size and align from vtable (already checks size).\n                 Ok(Some(self.get_vtable_size_and_align(vtable)?))\n             }"}, {"sha": "376b8872c90ac1be2610e792cadbd844e3b6d60d", "filename": "compiler/rustc_const_eval/src/interpret/intern.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7fe022f5aa32bbbb33c3a58755729d6667a461a9/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fe022f5aa32bbbb33c3a58755729d6667a461a9/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintern.rs?ref=7fe022f5aa32bbbb33c3a58755729d6667a461a9", "patch": "@@ -245,7 +245,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: CompileTimeMachine<'mir, 'tcx, const_eval::Memory\n             if let ty::Dynamic(..) =\n                 tcx.struct_tail_erasing_lifetimes(referenced_ty, self.ecx.param_env).kind()\n             {\n-                let ptr = self.ecx.scalar_to_ptr(mplace.meta.unwrap_meta())?;\n+                let ptr = mplace.meta.unwrap_meta().to_pointer(&tcx)?;\n                 if let Some(alloc_id) = ptr.provenance {\n                     // Explicitly choose const mode here, since vtables are immutable, even\n                     // if the reference of the fat pointer is mutable."}, {"sha": "71ccd1799fa95b19d26a49587ca129575d100dca", "filename": "compiler/rustc_const_eval/src/interpret/machine.rs", "status": "modified", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7fe022f5aa32bbbb33c3a58755729d6667a461a9/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fe022f5aa32bbbb33c3a58755729d6667a461a9/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs?ref=7fe022f5aa32bbbb33c3a58755729d6667a461a9", "patch": "@@ -135,9 +135,6 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     /// Whether to enforce integers and floats being initialized.\n     fn enforce_number_init(ecx: &InterpCx<'mir, 'tcx, Self>) -> bool;\n \n-    /// Whether to enforce integers and floats not having provenance.\n-    fn enforce_number_no_provenance(ecx: &InterpCx<'mir, 'tcx, Self>) -> bool;\n-\n     /// Whether function calls should be [ABI](CallAbi)-checked.\n     fn enforce_abi(_ecx: &InterpCx<'mir, 'tcx, Self>) -> bool {\n         true\n@@ -300,13 +297,6 @@ pub trait Machine<'mir, 'tcx>: Sized {\n         addr: u64,\n     ) -> InterpResult<'tcx, Pointer<Option<Self::Provenance>>>;\n \n-    /// Hook for returning a pointer from a transmute-like operation on an addr.\n-    /// This is only needed to support Miri's (unsound) \"allow-ptr-int-transmute\" flag.\n-    fn ptr_from_addr_transmute(\n-        ecx: &InterpCx<'mir, 'tcx, Self>,\n-        addr: u64,\n-    ) -> Pointer<Option<Self::Provenance>>;\n-\n     /// Marks a pointer as exposed, allowing it's provenance\n     /// to be recovered. \"Pointer-to-int cast\"\n     fn expose_ptr(\n@@ -469,11 +459,6 @@ pub macro compile_time_machine(<$mir: lifetime, $tcx: lifetime>) {\n         true\n     }\n \n-    #[inline(always)]\n-    fn enforce_number_no_provenance(_ecx: &InterpCx<$mir, $tcx, Self>) -> bool {\n-        true\n-    }\n-\n     #[inline(always)]\n     fn checked_binop_checks_overflow(_ecx: &InterpCx<$mir, $tcx, Self>) -> bool {\n         true\n@@ -518,14 +503,6 @@ pub macro compile_time_machine(<$mir: lifetime, $tcx: lifetime>) {\n         ptr\n     }\n \n-    #[inline(always)]\n-    fn ptr_from_addr_transmute(\n-        _ecx: &InterpCx<$mir, $tcx, Self>,\n-        addr: u64,\n-    ) -> Pointer<Option<AllocId>> {\n-        Pointer::from_addr(addr)\n-    }\n-\n     #[inline(always)]\n     fn ptr_from_addr_cast(\n         _ecx: &InterpCx<$mir, $tcx, Self>,"}, {"sha": "ed2c4edf9dd72920e0d634c2ae406cc8f65986e8", "filename": "compiler/rustc_const_eval/src/interpret/memory.rs", "status": "modified", "additions": 1, "deletions": 22, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/7fe022f5aa32bbbb33c3a58755729d6667a461a9/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fe022f5aa32bbbb33c3a58755729d6667a461a9/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs?ref=7fe022f5aa32bbbb33c3a58755729d6667a461a9", "patch": "@@ -9,7 +9,6 @@\n use std::assert_matches::assert_matches;\n use std::borrow::Cow;\n use std::collections::VecDeque;\n-use std::convert::TryFrom;\n use std::fmt;\n use std::ptr;\n \n@@ -1172,34 +1171,14 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n \n /// Machine pointer introspection.\n impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n-    pub fn scalar_to_ptr(\n-        &self,\n-        scalar: Scalar<M::Provenance>,\n-    ) -> InterpResult<'tcx, Pointer<Option<M::Provenance>>> {\n-        // We use `to_bits_or_ptr_internal` since we are just implementing the method people need to\n-        // call to force getting out a pointer.\n-        Ok(\n-            match scalar\n-                .to_bits_or_ptr_internal(self.pointer_size())\n-                .map_err(|s| err_ub!(ScalarSizeMismatch(s)))?\n-            {\n-                Err(ptr) => ptr.into(),\n-                Ok(bits) => {\n-                    let addr = u64::try_from(bits).unwrap();\n-                    M::ptr_from_addr_transmute(&self, addr)\n-                }\n-            },\n-        )\n-    }\n-\n     /// Test if this value might be null.\n     /// If the machine does not support ptr-to-int casts, this is conservative.\n     pub fn scalar_may_be_null(&self, scalar: Scalar<M::Provenance>) -> InterpResult<'tcx, bool> {\n         Ok(match scalar.try_to_int() {\n             Ok(int) => int.is_null(),\n             Err(_) => {\n                 // Can only happen during CTFE.\n-                let ptr = self.scalar_to_ptr(scalar)?;\n+                let ptr = scalar.to_pointer(self)?;\n                 match self.ptr_try_get_alloc_id(ptr) {\n                     Ok((alloc_id, offset, _)) => {\n                         let (size, _align, _kind) = self.get_alloc_info(alloc_id);"}, {"sha": "de284bd3bae3775a9000e3dbae1635d226403bdc", "filename": "compiler/rustc_const_eval/src/interpret/operand.rs", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/7fe022f5aa32bbbb33c3a58755729d6667a461a9/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fe022f5aa32bbbb33c3a58755729d6667a461a9/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Foperand.rs?ref=7fe022f5aa32bbbb33c3a58755729d6667a461a9", "patch": "@@ -14,7 +14,7 @@ use rustc_target::abi::{VariantIdx, Variants};\n use super::{\n     alloc_range, from_known_layout, mir_assign_valid_types, AllocId, ConstValue, Frame, GlobalId,\n     InterpCx, InterpResult, MPlaceTy, Machine, MemPlace, MemPlaceMeta, Place, PlaceTy, Pointer,\n-    PointerArithmetic, Provenance, Scalar, ScalarMaybeUninit,\n+    Provenance, Scalar, ScalarMaybeUninit,\n };\n \n /// An `Immediate` represents a single immediate self-contained Rust value.\n@@ -363,17 +363,11 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             Abi::Scalar(s) if force => Some(s.primitive()),\n             _ => None,\n         };\n-        let read_provenance = |s: abi::Primitive, size| {\n-            // Should be just `s.is_ptr()`, but we support a Miri flag that accepts more\n-            // questionable ptr-int transmutes.\n-            let number_may_have_provenance = !M::enforce_number_no_provenance(self);\n-            s.is_ptr() || (number_may_have_provenance && size == self.pointer_size())\n-        };\n         if let Some(s) = scalar_layout {\n             let size = s.size(self);\n             assert_eq!(size, mplace.layout.size, \"abi::Scalar size does not match layout size\");\n-            let scalar =\n-                alloc.read_scalar(alloc_range(Size::ZERO, size), read_provenance(s, size))?;\n+            let scalar = alloc\n+                .read_scalar(alloc_range(Size::ZERO, size), /*read_provenance*/ s.is_ptr())?;\n             return Ok(Some(ImmTy { imm: scalar.into(), layout: mplace.layout }));\n         }\n         let scalar_pair_layout = match mplace.layout.abi {\n@@ -391,10 +385,12 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             let (a_size, b_size) = (a.size(self), b.size(self));\n             let b_offset = a_size.align_to(b.align(self).abi);\n             assert!(b_offset.bytes() > 0); // in `operand_field` we use the offset to tell apart the fields\n-            let a_val =\n-                alloc.read_scalar(alloc_range(Size::ZERO, a_size), read_provenance(a, a_size))?;\n-            let b_val =\n-                alloc.read_scalar(alloc_range(b_offset, b_size), read_provenance(b, b_size))?;\n+            let a_val = alloc.read_scalar(\n+                alloc_range(Size::ZERO, a_size),\n+                /*read_provenance*/ a.is_ptr(),\n+            )?;\n+            let b_val = alloc\n+                .read_scalar(alloc_range(b_offset, b_size), /*read_provenance*/ b.is_ptr())?;\n             return Ok(Some(ImmTy {\n                 imm: Immediate::ScalarPair(a_val, b_val),\n                 layout: mplace.layout,\n@@ -459,7 +455,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         &self,\n         op: &OpTy<'tcx, M::Provenance>,\n     ) -> InterpResult<'tcx, Pointer<Option<M::Provenance>>> {\n-        self.scalar_to_ptr(self.read_scalar(op)?.check_init()?)\n+        self.read_scalar(op)?.to_pointer(self)\n     }\n \n     /// Turn the wide MPlace into a string (must already be dereferenced!)"}, {"sha": "473da71a0ab9cb570ee88d11d9eb89db16b347bf", "filename": "compiler/rustc_const_eval/src/interpret/place.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7fe022f5aa32bbbb33c3a58755729d6667a461a9/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fe022f5aa32bbbb33c3a58755729d6667a461a9/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs?ref=7fe022f5aa32bbbb33c3a58755729d6667a461a9", "patch": "@@ -331,7 +331,7 @@ where\n             Immediate::Uninit => throw_ub!(InvalidUninitBytes(None)),\n         };\n \n-        let mplace = MemPlace { ptr: self.scalar_to_ptr(ptr.check_init()?)?, meta };\n+        let mplace = MemPlace { ptr: ptr.to_pointer(self)?, meta };\n         // When deref'ing a pointer, the *static* alignment given by the type is what matters.\n         let align = layout.align.abi;\n         Ok(MPlaceTy { mplace, layout, align })\n@@ -889,7 +889,7 @@ where\n         &self,\n         mplace: &MPlaceTy<'tcx, M::Provenance>,\n     ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::Provenance>> {\n-        let vtable = self.scalar_to_ptr(mplace.vtable())?; // also sanity checks the type\n+        let vtable = mplace.vtable().to_pointer(self)?; // also sanity checks the type\n         let (ty, _) = self.get_ptr_vtable(vtable)?;\n         let layout = self.layout_of(ty)?;\n "}, {"sha": "42de0dbdca92868b45a2eb18bb3a15077a675290", "filename": "compiler/rustc_const_eval/src/interpret/terminator.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7fe022f5aa32bbbb33c3a58755729d6667a461a9/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fe022f5aa32bbbb33c3a58755729d6667a461a9/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fterminator.rs?ref=7fe022f5aa32bbbb33c3a58755729d6667a461a9", "patch": "@@ -561,7 +561,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 };\n \n                 // Get the required information from the vtable.\n-                let vptr = self.scalar_to_ptr(receiver_place.meta.unwrap_meta())?;\n+                let vptr = receiver_place.meta.unwrap_meta().to_pointer(self)?;\n                 let (dyn_ty, dyn_trait) = self.get_ptr_vtable(vptr)?;\n                 if dyn_trait != data.principal() {\n                     throw_ub_format!("}, {"sha": "d20f16755c391243cc88facc4960a08f7769c6b5", "filename": "compiler/rustc_const_eval/src/interpret/validity.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/7fe022f5aa32bbbb33c3a58755729d6667a461a9/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fe022f5aa32bbbb33c3a58755729d6667a461a9/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fvalidity.rs?ref=7fe022f5aa32bbbb33c3a58755729d6667a461a9", "patch": "@@ -312,7 +312,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n         let tail = self.ecx.tcx.struct_tail_erasing_lifetimes(pointee.ty, self.ecx.param_env);\n         match tail.kind() {\n             ty::Dynamic(..) => {\n-                let vtable = self.ecx.scalar_to_ptr(meta.unwrap_meta())?;\n+                let vtable = meta.unwrap_meta().to_pointer(self.ecx)?;\n                 // Make sure it is a genuine vtable pointer.\n                 let (_ty, _trait) = try_validation!(\n                     self.ecx.get_ptr_vtable(vtable),\n@@ -517,15 +517,13 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n                             { \"{:x}\", value } expected { \"initialized bytes\" }\n                     );\n                 }\n-                if M::enforce_number_no_provenance(self.ecx) {\n-                    // As a special exception we *do* match on a `Scalar` here, since we truly want\n-                    // to know its underlying representation (and *not* cast it to an integer).\n-                    let is_ptr = value.check_init().map_or(false, |v| matches!(v, Scalar::Ptr(..)));\n-                    if is_ptr {\n-                        throw_validation_failure!(self.path,\n-                            { \"{:x}\", value } expected { \"plain (non-pointer) bytes\" }\n-                        )\n-                    }\n+                // As a special exception we *do* match on a `Scalar` here, since we truly want\n+                // to know its underlying representation (and *not* cast it to an integer).\n+                let is_ptr = value.check_init().map_or(false, |v| matches!(v, Scalar::Ptr(..)));\n+                if is_ptr {\n+                    throw_validation_failure!(self.path,\n+                        { \"{:x}\", value } expected { \"plain (non-pointer) bytes\" }\n+                    )\n                 }\n                 Ok(true)\n             }\n@@ -568,7 +566,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValidityVisitor<'rt, 'mir, '\n \n                 // If we check references recursively, also check that this points to a function.\n                 if let Some(_) = self.ref_tracking {\n-                    let ptr = self.ecx.scalar_to_ptr(value)?;\n+                    let ptr = value.to_pointer(self.ecx)?;\n                     let _fn = try_validation!(\n                         self.ecx.get_ptr_fn(ptr),\n                         self.path,\n@@ -906,7 +904,7 @@ impl<'rt, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> ValueVisitor<'mir, 'tcx, M>\n                 match alloc.check_bytes(\n                     alloc_range(Size::ZERO, size),\n                     /*allow_uninit*/ !M::enforce_number_init(self.ecx),\n-                    /*allow_ptr*/ !M::enforce_number_no_provenance(self.ecx),\n+                    /*allow_ptr*/ false,\n                 ) {\n                     // In the happy case, we needn't check anything else.\n                     Ok(()) => {}"}, {"sha": "834c114ee1c58d9067fc6ef4f161447200f5725a", "filename": "compiler/rustc_middle/src/mir/interpret/value.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/7fe022f5aa32bbbb33c3a58755729d6667a461a9/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fe022f5aa32bbbb33c3a58755729d6667a461a9/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Fvalue.rs?ref=7fe022f5aa32bbbb33c3a58755729d6667a461a9", "patch": "@@ -331,6 +331,19 @@ impl<Prov> Scalar<Prov> {\n }\n \n impl<'tcx, Prov: Provenance> Scalar<Prov> {\n+    pub fn to_pointer(self, cx: &impl HasDataLayout) -> InterpResult<'tcx, Pointer<Option<Prov>>> {\n+        match self\n+            .to_bits_or_ptr_internal(cx.pointer_size())\n+            .map_err(|s| err_ub!(ScalarSizeMismatch(s)))?\n+        {\n+            Err(ptr) => Ok(ptr.into()),\n+            Ok(bits) => {\n+                let addr = u64::try_from(bits).unwrap();\n+                Ok(Pointer::from_addr(addr))\n+            }\n+        }\n+    }\n+\n     /// Fundamental scalar-to-int (cast) operation. Many convenience wrappers exist below, that you\n     /// likely want to use instead.\n     ///\n@@ -546,6 +559,11 @@ impl<Prov> ScalarMaybeUninit<Prov> {\n }\n \n impl<'tcx, Prov: Provenance> ScalarMaybeUninit<Prov> {\n+    #[inline(always)]\n+    pub fn to_pointer(self, cx: &impl HasDataLayout) -> InterpResult<'tcx, Pointer<Option<Prov>>> {\n+        self.check_init()?.to_pointer(cx)\n+    }\n+\n     #[inline(always)]\n     pub fn to_bool(self) -> InterpResult<'tcx, bool> {\n         self.check_init()?.to_bool()"}, {"sha": "261adbfc34671e70c2383b16cea3c5778769e960", "filename": "compiler/rustc_parse/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/7fe022f5aa32bbbb33c3a58755729d6667a461a9/compiler%2Frustc_parse%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fe022f5aa32bbbb33c3a58755729d6667a461a9/compiler%2Frustc_parse%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Flib.rs?ref=7fe022f5aa32bbbb33c3a58755729d6667a461a9", "patch": "@@ -117,12 +117,12 @@ pub fn new_parser_from_file<'a>(sess: &'a ParseSess, path: &Path, sp: Option<Spa\n     source_file_to_parser(sess, file_to_source_file(sess, path, sp))\n }\n \n-/// Given a `source_file` and config, returns a parser.\n+/// Given a session and a `source_file`, returns a parser.\n fn source_file_to_parser(sess: &ParseSess, source_file: Lrc<SourceFile>) -> Parser<'_> {\n     panictry_buffer!(&sess.span_diagnostic, maybe_source_file_to_parser(sess, source_file))\n }\n \n-/// Given a `source_file` and config, return a parser. Returns any buffered errors from lexing the\n+/// Given a session and a `source_file`, return a parser. Returns any buffered errors from lexing the\n /// initial token stream.\n fn maybe_source_file_to_parser(\n     sess: &ParseSess,"}, {"sha": "4d3736f79146c8df36976ba06397e108ef532af7", "filename": "library/std/src/io/stdio.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/7fe022f5aa32bbbb33c3a58755729d6667a461a9/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fe022f5aa32bbbb33c3a58755729d6667a461a9/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fstdio.rs?ref=7fe022f5aa32bbbb33c3a58755729d6667a461a9", "patch": "@@ -220,7 +220,7 @@ fn handle_ebadf<T>(r: io::Result<T>, default: T) -> io::Result<T> {\n ///\n /// fn main() -> io::Result<()> {\n ///     let mut buffer = String::new();\n-///     let mut stdin = io::stdin(); // We get `Stdin` here.\n+///     let stdin = io::stdin(); // We get `Stdin` here.\n ///     stdin.read_line(&mut buffer)?;\n ///     Ok(())\n /// }"}, {"sha": "4b91f7ba096cb4fc9c9c4b11103f9845290178ad", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7fe022f5aa32bbbb33c3a58755729d6667a461a9/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fe022f5aa32bbbb33c3a58755729d6667a461a9/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=7fe022f5aa32bbbb33c3a58755729d6667a461a9", "patch": "@@ -16,8 +16,8 @@ use rustc_span::hygiene::MacroKind;\n use rustc_span::symbol::{kw, sym, Symbol};\n \n use crate::clean::{\n-    self, clean_fn_decl_from_did_and_sig, clean_middle_ty, clean_ty, clean_ty_generics, utils,\n-    Attributes, AttributesExt, Clean, ImplKind, ItemId, Type, Visibility,\n+    self, clean_fn_decl_from_did_and_sig, clean_middle_field, clean_middle_ty, clean_ty,\n+    clean_ty_generics, utils, Attributes, AttributesExt, Clean, ImplKind, ItemId, Type, Visibility,\n };\n use crate::core::DocContext;\n use crate::formats::item_type::ItemType;\n@@ -246,7 +246,7 @@ fn build_struct(cx: &mut DocContext<'_>, did: DefId) -> clean::Struct {\n     clean::Struct {\n         struct_type: variant.ctor_kind,\n         generics: clean_ty_generics(cx, cx.tcx.generics_of(did), predicates),\n-        fields: variant.fields.iter().map(|x| x.clean(cx)).collect(),\n+        fields: variant.fields.iter().map(|x| clean_middle_field(x, cx)).collect(),\n     }\n }\n \n@@ -255,7 +255,7 @@ fn build_union(cx: &mut DocContext<'_>, did: DefId) -> clean::Union {\n     let variant = cx.tcx.adt_def(did).non_enum_variant();\n \n     let generics = clean_ty_generics(cx, cx.tcx.generics_of(did), predicates);\n-    let fields = variant.fields.iter().map(|x| x.clean(cx)).collect();\n+    let fields = variant.fields.iter().map(|x| clean_middle_field(x, cx)).collect();\n     clean::Union { generics, fields }\n }\n "}, {"sha": "c9ef4748a48451619cadda1289bbd09d54d5d97e", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 47, "deletions": 45, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/7fe022f5aa32bbbb33c3a58755729d6667a461a9/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fe022f5aa32bbbb33c3a58755729d6667a461a9/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=7fe022f5aa32bbbb33c3a58755729d6667a461a9", "patch": "@@ -237,13 +237,22 @@ impl<'tcx> Clean<'tcx, Lifetime> for hir::Lifetime {\n     }\n }\n \n-impl<'tcx> Clean<'tcx, Constant> for hir::ConstArg {\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> Constant {\n-        let def_id = cx.tcx.hir().body_owner_def_id(self.value.body).to_def_id();\n-        Constant {\n-            type_: clean_middle_ty(cx.tcx.type_of(def_id), cx, Some(def_id)),\n-            kind: ConstantKind::Anonymous { body: self.value.body },\n-        }\n+pub(crate) fn clean_const<'tcx>(constant: &hir::ConstArg, cx: &mut DocContext<'tcx>) -> Constant {\n+    let def_id = cx.tcx.hir().body_owner_def_id(constant.value.body).to_def_id();\n+    Constant {\n+        type_: clean_middle_ty(cx.tcx.type_of(def_id), cx, Some(def_id)),\n+        kind: ConstantKind::Anonymous { body: constant.value.body },\n+    }\n+}\n+\n+pub(crate) fn clean_middle_const<'tcx>(\n+    constant: ty::Const<'tcx>,\n+    cx: &mut DocContext<'tcx>,\n+) -> Constant {\n+    // FIXME: instead of storing the stringified expression, store `self` directly instead.\n+    Constant {\n+        type_: clean_middle_ty(constant.ty(), cx, None),\n+        kind: ConstantKind::TyConst { expr: constant.to_string() },\n     }\n }\n \n@@ -392,7 +401,7 @@ impl<'tcx> Clean<'tcx, Term> for ty::Term<'tcx> {\n     fn clean(&self, cx: &mut DocContext<'tcx>) -> Term {\n         match self {\n             ty::Term::Ty(ty) => Term::Type(clean_middle_ty(*ty, cx, None)),\n-            ty::Term::Const(c) => Term::Constant(c.clean(cx)),\n+            ty::Term::Const(c) => Term::Constant(clean_middle_const(*c, cx)),\n         }\n     }\n }\n@@ -403,7 +412,7 @@ impl<'tcx> Clean<'tcx, Term> for hir::Term<'tcx> {\n             hir::Term::Ty(ty) => Term::Type(clean_ty(ty, cx)),\n             hir::Term::Const(c) => {\n                 let def_id = cx.tcx.hir().local_def_id(c.hir_id);\n-                Term::Constant(ty::Const::from_anon_const(cx.tcx, def_id).clean(cx))\n+                Term::Constant(clean_middle_const(ty::Const::from_anon_const(cx.tcx, def_id), cx))\n             }\n         }\n     }\n@@ -1468,8 +1477,10 @@ fn maybe_expand_private_type_alias<'tcx>(\n                     _ => None,\n                 });\n                 if let Some(ct) = const_ {\n-                    substs\n-                        .insert(const_param_def_id.to_def_id(), SubstParam::Constant(ct.clean(cx)));\n+                    substs.insert(\n+                        const_param_def_id.to_def_id(),\n+                        SubstParam::Constant(clean_const(ct, cx)),\n+                    );\n                 }\n                 // FIXME(const_generics_defaults)\n                 indices.consts += 1;\n@@ -1764,35 +1775,26 @@ pub(crate) fn clean_middle_ty<'tcx>(\n     }\n }\n \n-impl<'tcx> Clean<'tcx, Constant> for ty::Const<'tcx> {\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> Constant {\n-        // FIXME: instead of storing the stringified expression, store `self` directly instead.\n-        Constant {\n-            type_: clean_middle_ty(self.ty(), cx, None),\n-            kind: ConstantKind::TyConst { expr: self.to_string() },\n-        }\n-    }\n-}\n-\n-impl<'tcx> Clean<'tcx, Item> for hir::FieldDef<'tcx> {\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> Item {\n-        let def_id = cx.tcx.hir().local_def_id(self.hir_id).to_def_id();\n-        clean_field(def_id, self.ident.name, clean_ty(self.ty, cx), cx)\n-    }\n+pub(crate) fn clean_field<'tcx>(field: &hir::FieldDef<'tcx>, cx: &mut DocContext<'tcx>) -> Item {\n+    let def_id = cx.tcx.hir().local_def_id(field.hir_id).to_def_id();\n+    clean_field_with_def_id(def_id, field.ident.name, clean_ty(field.ty, cx), cx)\n }\n \n-impl<'tcx> Clean<'tcx, Item> for ty::FieldDef {\n-    fn clean(&self, cx: &mut DocContext<'tcx>) -> Item {\n-        clean_field(\n-            self.did,\n-            self.name,\n-            clean_middle_ty(cx.tcx.type_of(self.did), cx, Some(self.did)),\n-            cx,\n-        )\n-    }\n+pub(crate) fn clean_middle_field<'tcx>(field: &ty::FieldDef, cx: &mut DocContext<'tcx>) -> Item {\n+    clean_field_with_def_id(\n+        field.did,\n+        field.name,\n+        clean_middle_ty(cx.tcx.type_of(field.did), cx, Some(field.did)),\n+        cx,\n+    )\n }\n \n-fn clean_field(def_id: DefId, name: Symbol, ty: Type, cx: &mut DocContext<'_>) -> Item {\n+pub(crate) fn clean_field_with_def_id(\n+    def_id: DefId,\n+    name: Symbol,\n+    ty: Type,\n+    cx: &mut DocContext<'_>,\n+) -> Item {\n     let what_rustc_thinks =\n         Item::from_def_id_and_parts(def_id, Some(name), StructFieldItem(ty), cx);\n     if is_field_vis_inherited(cx.tcx, def_id) {\n@@ -1830,27 +1832,27 @@ impl<'tcx> Clean<'tcx, VariantStruct> for rustc_hir::VariantData<'tcx> {\n     fn clean(&self, cx: &mut DocContext<'tcx>) -> VariantStruct {\n         VariantStruct {\n             struct_type: CtorKind::from_hir(self),\n-            fields: self.fields().iter().map(|x| x.clean(cx)).collect(),\n+            fields: self.fields().iter().map(|x| clean_field(x, cx)).collect(),\n         }\n     }\n }\n \n impl<'tcx> Clean<'tcx, Vec<Item>> for hir::VariantData<'tcx> {\n     fn clean(&self, cx: &mut DocContext<'tcx>) -> Vec<Item> {\n-        self.fields().iter().map(|x| x.clean(cx)).collect()\n+        self.fields().iter().map(|x| clean_field(x, cx)).collect()\n     }\n }\n \n impl<'tcx> Clean<'tcx, Item> for ty::VariantDef {\n     fn clean(&self, cx: &mut DocContext<'tcx>) -> Item {\n         let kind = match self.ctor_kind {\n             CtorKind::Const => Variant::CLike,\n-            CtorKind::Fn => {\n-                Variant::Tuple(self.fields.iter().map(|field| field.clean(cx)).collect())\n-            }\n+            CtorKind::Fn => Variant::Tuple(\n+                self.fields.iter().map(|field| clean_middle_field(field, cx)).collect(),\n+            ),\n             CtorKind::Fictive => Variant::Struct(VariantStruct {\n                 struct_type: CtorKind::Fictive,\n-                fields: self.fields.iter().map(|field| field.clean(cx)).collect(),\n+                fields: self.fields.iter().map(|field| clean_middle_field(field, cx)).collect(),\n             }),\n         };\n         let what_rustc_thinks =\n@@ -1894,7 +1896,7 @@ impl<'tcx> Clean<'tcx, GenericArgs> for hir::GenericArgs<'tcx> {\n                     }\n                     hir::GenericArg::Lifetime(_) => GenericArg::Lifetime(Lifetime::elided()),\n                     hir::GenericArg::Type(ty) => GenericArg::Type(clean_ty(ty, cx)),\n-                    hir::GenericArg::Const(ct) => GenericArg::Const(Box::new(ct.clean(cx))),\n+                    hir::GenericArg::Const(ct) => GenericArg::Const(Box::new(clean_const(ct, cx))),\n                     hir::GenericArg::Infer(_inf) => GenericArg::Infer,\n                 })\n                 .collect::<Vec<_>>()\n@@ -1970,12 +1972,12 @@ fn clean_maybe_renamed_item<'tcx>(\n             }),\n             ItemKind::Union(ref variant_data, generics) => UnionItem(Union {\n                 generics: generics.clean(cx),\n-                fields: variant_data.fields().iter().map(|x| x.clean(cx)).collect(),\n+                fields: variant_data.fields().iter().map(|x| clean_field(x, cx)).collect(),\n             }),\n             ItemKind::Struct(ref variant_data, generics) => StructItem(Struct {\n                 struct_type: CtorKind::from_hir(variant_data),\n                 generics: generics.clean(cx),\n-                fields: variant_data.fields().iter().map(|x| x.clean(cx)).collect(),\n+                fields: variant_data.fields().iter().map(|x| clean_field(x, cx)).collect(),\n             }),\n             ItemKind::Impl(impl_) => return clean_impl(impl_, item.hir_id(), cx),\n             // proc macros can have a name set by attributes"}, {"sha": "27ecea5cc40bd2a9dac6880247c210477803a2ef", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/7fe022f5aa32bbbb33c3a58755729d6667a461a9/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7fe022f5aa32bbbb33c3a58755729d6667a461a9/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=7fe022f5aa32bbbb33c3a58755729d6667a461a9", "patch": "@@ -2,9 +2,9 @@ use crate::clean::auto_trait::AutoTraitFinder;\n use crate::clean::blanket_impl::BlanketImplFinder;\n use crate::clean::render_macro_matchers::render_macro_matcher;\n use crate::clean::{\n-    clean_middle_ty, inline, Clean, Crate, ExternalCrate, Generic, GenericArg, GenericArgs,\n-    ImportSource, Item, ItemKind, Lifetime, Path, PathSegment, Primitive, PrimitiveType, Type,\n-    TypeBinding, Visibility,\n+    clean_middle_const, clean_middle_ty, inline, Clean, Crate, ExternalCrate, Generic, GenericArg,\n+    GenericArgs, ImportSource, Item, ItemKind, Lifetime, Path, PathSegment, Primitive,\n+    PrimitiveType, Type, TypeBinding, Visibility,\n };\n use crate::core::DocContext;\n use crate::formats::item_type::ItemType;\n@@ -93,7 +93,7 @@ pub(crate) fn substs_to_args<'tcx>(\n             None\n         }\n         GenericArgKind::Type(ty) => Some(GenericArg::Type(clean_middle_ty(ty, cx, None))),\n-        GenericArgKind::Const(ct) => Some(GenericArg::Const(Box::new(ct.clean(cx)))),\n+        GenericArgKind::Const(ct) => Some(GenericArg::Const(Box::new(clean_middle_const(ct, cx)))),\n     }));\n     ret_val\n }"}]}