{"sha": "92df8a9a990ff6794c18c25c4dbc38754540c826", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkyZGY4YTlhOTkwZmY2Nzk0YzE4YzI1YzRkYmMzODc1NDU0MGM4MjY=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-11-09T16:43:55Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-11-20T15:53:58Z"}, "message": "Add E0517, E0518 for repr() errors", "tree": {"sha": "eb600a70355324610d6dee0852ad1d0e1ad22129", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eb600a70355324610d6dee0852ad1d0e1ad22129"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/92df8a9a990ff6794c18c25c4dbc38754540c826", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/92df8a9a990ff6794c18c25c4dbc38754540c826", "html_url": "https://github.com/rust-lang/rust/commit/92df8a9a990ff6794c18c25c4dbc38754540c826", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/92df8a9a990ff6794c18c25c4dbc38754540c826/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2228bacd62ca8970a7a59401e78d0c5a34fc0f87", "url": "https://api.github.com/repos/rust-lang/rust/commits/2228bacd62ca8970a7a59401e78d0c5a34fc0f87", "html_url": "https://github.com/rust-lang/rust/commit/2228bacd62ca8970a7a59401e78d0c5a34fc0f87"}], "stats": {"total": 102, "additions": 87, "deletions": 15}, "files": [{"sha": "a331c7595322bef2c8c123c0cf0302432fd8b606", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/92df8a9a990ff6794c18c25c4dbc38754540c826/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92df8a9a990ff6794c18c25c4dbc38754540c826/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=92df8a9a990ff6794c18c25c4dbc38754540c826", "patch": "@@ -2039,6 +2039,79 @@ It is not possible to use stability attributes outside of the standard library.\n Also, for now, it is not possible to write deprecation messages either.\n \"##,\n \n+E0517: r##\"\n+This error indicates that a `#[repr(..)]` attribute was placed on an unsupported\n+item.\n+\n+Examples of erroneous code:\n+\n+```\n+#[repr(C)]\n+type Foo = u8;\n+\n+#[repr(packed)]\n+enum Foo {Bar, Baz}\n+\n+#[repr(u8)]\n+struct Foo {bar: bool, baz: bool}\n+\n+#[repr(C)]\n+impl Foo {\n+    ...\n+}\n+```\n+\n+ - The `#[repr(C)]` attribute can only be placed on structs and enums\n+ - The `#[repr(packed)]` and `#[repr(simd)]` attributes only work on structs\n+ - The `#[repr(u8)]`, `#[repr(i16)]`, etc attributes only work on enums\n+\n+These attributes do not work on typedefs, since typedefs are just aliases.\n+\n+Representations like `#[repr(u8)]`, `#[repr(i64)]` are for selecting the\n+discriminant size for C-like enums (when there is no associated data, e.g. `enum\n+Color {Red, Blue, Green}`), effectively setting the size of the enum to the size\n+of the provided type. Such an enum can be cast to a value of the same type as\n+well. In short, `#[repr(u8)]` makes the enum behave like an integer with a\n+constrained set of allowed values.\n+\n+Only C-like enums can be cast to numerical primitives, so this attribute will\n+not apply to structs.\n+\n+`#[repr(packed)]` reduces padding to make the struct size smaller. The\n+representation of enums isn't strictly defined in Rust, and this attribute won't\n+work on enums.\n+\n+`#[repr(simd)]` will give a struct consisting of a homogenous series of machine\n+types (i.e. `u8`, `i32`, etc) a representation that permits vectorization via\n+SIMD. This doesn't make much sense for enums since they don't consist of a\n+single list of data.\n+\"##,\n+\n+E0518: r##\"\n+This error indicates that an `#[inline(..)]` attribute was incorrectly placed on\n+something other than a function or method.\n+\n+Examples of erroneous code:\n+\n+```\n+#[inline(always)]\n+struct Foo;\n+\n+#[inline(never)]\n+impl Foo {\n+    ...\n+}\n+```\n+\n+`#[inline]` hints the compiler whether or not to attempt to inline a method or\n+function. By default, the compiler does a pretty good job of figuring this out\n+itself, but if you feel the need for annotations, `#[inline(always)]` and\n+`#[inline(never)]` can override or force the compiler's decision.\n+\n+If you wish to apply this attribute to all methods in an impl, manually annotate\n+each method; it is not possible to annotate the entire impl with an `#[inline]`\n+attribute.\n+\"##,\n }\n \n "}, {"sha": "27785a072a6544a2a07012388d456738bfad3111", "filename": "src/librustc/front/check_attr.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/92df8a9a990ff6794c18c25c4dbc38754540c826/src%2Flibrustc%2Ffront%2Fcheck_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/92df8a9a990ff6794c18c25c4dbc38754540c826/src%2Flibrustc%2Ffront%2Fcheck_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fcheck_attr.rs?ref=92df8a9a990ff6794c18c25c4dbc38754540c826", "patch": "@@ -41,9 +41,7 @@ struct CheckAttrVisitor<'a> {\n impl<'a> CheckAttrVisitor<'a> {\n     fn check_inline(&self, attr: &ast::Attribute, target: Target) {\n         if target != Target::Fn {\n-            self.sess.span_err(\n-                attr.span,\n-                \"attribute should be applied to function\");\n+            span_err!(self.sess, attr.span, E0518, \"attribute should be applied to function\");\n         }\n     }\n \n@@ -56,33 +54,34 @@ impl<'a> CheckAttrVisitor<'a> {\n         };\n         for word in words {\n             let word: &str = &word.name();\n-            match word {\n+            let message = match word {\n                 \"C\" => {\n                     if target != Target::Struct && target != Target::Enum {\n-                        self.sess.span_err(\n-                            attr.span,\n-                            \"attribute should be applied to struct or enum\");\n+                            \"attribute should be applied to struct or enum\"\n+                    } else {\n+                        continue\n                     }\n                 }\n                 \"packed\" |\n                 \"simd\" => {\n                     if target != Target::Struct {\n-                        self.sess.span_err(\n-                            attr.span,\n-                            \"attribute should be applied to struct\");\n+                        \"attribute should be applied to struct\"\n+                    } else {\n+                        continue\n                     }\n                 }\n                 \"i8\" | \"u8\" | \"i16\" | \"u16\" |\n                 \"i32\" | \"u32\" | \"i64\" | \"u64\" |\n                 \"isize\" | \"usize\" => {\n                     if target != Target::Enum {\n-                        self.sess.span_err(\n-                            attr.span,\n-                            \"attribute should be applied to enum\");\n+                            \"attribute should be applied to enum\"\n+                    } else {\n+                        continue\n                     }\n                 }\n-                _ => (),\n-            }\n+                _ => continue,\n+            };\n+            span_err!(self.sess, attr.span, E0517, \"{}\", message);\n         }\n     }\n "}]}