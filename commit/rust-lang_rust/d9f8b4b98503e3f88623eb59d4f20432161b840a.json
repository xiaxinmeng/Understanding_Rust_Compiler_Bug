{"sha": "d9f8b4b98503e3f88623eb59d4f20432161b840a", "node_id": "C_kwDOAAsO6NoAKGQ5ZjhiNGI5ODUwM2UzZjg4NjIzZWI1OWQ0ZjIwNDMyMTYxYjg0MGE", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-04T03:57:50Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-04T03:57:50Z"}, "message": "Auto merge of #102395 - davidtwco:translation-rename-typeck, r=compiler-errors\n\nerrors: rename `typeck.ftl` to `hir_analysis.ftl`\n\nIn #102306, `rustc_typeck` was renamed to `rustc_hir_analysis` but the diagnostic resources were not renamed - which is what this pull request changes.", "tree": {"sha": "652ba2901414bc9103855e2c097409e81295b341", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/652ba2901414bc9103855e2c097409e81295b341"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d9f8b4b98503e3f88623eb59d4f20432161b840a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d9f8b4b98503e3f88623eb59d4f20432161b840a", "html_url": "https://github.com/rust-lang/rust/commit/d9f8b4b98503e3f88623eb59d4f20432161b840a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d9f8b4b98503e3f88623eb59d4f20432161b840a/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1f1defc2f6f5c828e287845d04076cd22e90671e", "url": "https://api.github.com/repos/rust-lang/rust/commits/1f1defc2f6f5c828e287845d04076cd22e90671e", "html_url": "https://github.com/rust-lang/rust/commit/1f1defc2f6f5c828e287845d04076cd22e90671e"}, {"sha": "c4418e194019b429652e32b7169c52163e6e97a6", "url": "https://api.github.com/repos/rust-lang/rust/commits/c4418e194019b429652e32b7169c52163e6e97a6", "html_url": "https://github.com/rust-lang/rust/commit/c4418e194019b429652e32b7169c52163e6e97a6"}], "stats": {"total": 643, "additions": 325, "deletions": 318}, "files": [{"sha": "55061fbce7e4a8a6584e01ce8a03e998eab34e27", "filename": "compiler/rustc_error_messages/locales/en-US/compiletest.ftl", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d9f8b4b98503e3f88623eb59d4f20432161b840a/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcompiletest.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/d9f8b4b98503e3f88623eb59d4f20432161b840a/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcompiletest.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fcompiletest.ftl?ref=d9f8b4b98503e3f88623eb59d4f20432161b840a", "patch": "@@ -0,0 +1,5 @@\n+compiletest_example = this is an example message used in testing\n+    .note = with a note\n+    .help = with a help\n+    .suggestion = with a suggestion\n+    .label = with a label"}, {"sha": "c6a4ff6f0e02fc04b29d3281a9c620fd2dd5f08b", "filename": "compiler/rustc_error_messages/locales/en-US/hir_analysis.ftl", "status": "renamed", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/d9f8b4b98503e3f88623eb59d4f20432161b840a/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fhir_analysis.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/d9f8b4b98503e3f88623eb59d4f20432161b840a/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fhir_analysis.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fhir_analysis.ftl?ref=d9f8b4b98503e3f88623eb59d4f20432161b840a", "patch": "@@ -1,101 +1,101 @@\n-typeck_field_multiply_specified_in_initializer =\n+hir_analysis_field_multiply_specified_in_initializer =\n     field `{$ident}` specified more than once\n     .label = used more than once\n     .previous_use_label = first use of `{$ident}`\n \n-typeck_unrecognized_atomic_operation =\n+hir_analysis_unrecognized_atomic_operation =\n     unrecognized atomic operation function: `{$op}`\n     .label = unrecognized atomic operation\n \n-typeck_wrong_number_of_generic_arguments_to_intrinsic =\n+hir_analysis_wrong_number_of_generic_arguments_to_intrinsic =\n     intrinsic has wrong number of {$descr} parameters: found {$found}, expected {$expected}\n     .label = expected {$expected} {$descr} {$expected ->\n         [one] parameter\n         *[other] parameters\n     }\n \n-typeck_unrecognized_intrinsic_function =\n+hir_analysis_unrecognized_intrinsic_function =\n     unrecognized intrinsic function: `{$name}`\n     .label = unrecognized intrinsic\n \n-typeck_lifetimes_or_bounds_mismatch_on_trait =\n+hir_analysis_lifetimes_or_bounds_mismatch_on_trait =\n     lifetime parameters or bounds on {$item_kind} `{$ident}` do not match the trait declaration\n     .label = lifetimes do not match {$item_kind} in trait\n     .generics_label = lifetimes in impl do not match this {$item_kind} in trait\n \n-typeck_drop_impl_on_wrong_item =\n+hir_analysis_drop_impl_on_wrong_item =\n     the `Drop` trait may only be implemented for local structs, enums, and unions\n     .label = must be a struct, enum, or union in the current crate\n \n-typeck_field_already_declared =\n+hir_analysis_field_already_declared =\n     field `{$field_name}` is already declared\n     .label = field already declared\n     .previous_decl_label = `{$field_name}` first declared here\n \n-typeck_copy_impl_on_type_with_dtor =\n+hir_analysis_copy_impl_on_type_with_dtor =\n     the trait `Copy` may not be implemented for this type; the type has a destructor\n     .label = `Copy` not allowed on types with destructors\n \n-typeck_multiple_relaxed_default_bounds =\n+hir_analysis_multiple_relaxed_default_bounds =\n     type parameter has more than one relaxed default bound, only one is supported\n \n-typeck_copy_impl_on_non_adt =\n+hir_analysis_copy_impl_on_non_adt =\n     the trait `Copy` may not be implemented for this type\n     .label = type is not a structure or enumeration\n \n-typeck_trait_object_declared_with_no_traits =\n+hir_analysis_trait_object_declared_with_no_traits =\n     at least one trait is required for an object type\n     .alias_span = this alias does not contain a trait\n \n-typeck_ambiguous_lifetime_bound =\n+hir_analysis_ambiguous_lifetime_bound =\n     ambiguous lifetime bound, explicit lifetime bound required\n \n-typeck_assoc_type_binding_not_allowed =\n+hir_analysis_assoc_type_binding_not_allowed =\n     associated type bindings are not allowed here\n     .label = associated type not allowed here\n \n-typeck_functional_record_update_on_non_struct =\n+hir_analysis_functional_record_update_on_non_struct =\n     functional record update syntax requires a struct\n \n-typeck_typeof_reserved_keyword_used =\n+hir_analysis_typeof_reserved_keyword_used =\n     `typeof` is a reserved keyword but unimplemented\n     .suggestion = consider replacing `typeof(...)` with an actual type\n     .label = reserved keyword\n \n-typeck_return_stmt_outside_of_fn_body =\n+hir_analysis_return_stmt_outside_of_fn_body =\n     return statement outside of function body\n     .encl_body_label = the return is part of this body...\n     .encl_fn_label = ...not the enclosing function body\n \n-typeck_yield_expr_outside_of_generator =\n+hir_analysis_yield_expr_outside_of_generator =\n     yield expression outside of generator literal\n \n-typeck_struct_expr_non_exhaustive =\n+hir_analysis_struct_expr_non_exhaustive =\n     cannot create non-exhaustive {$what} using struct expression\n \n-typeck_method_call_on_unknown_type =\n+hir_analysis_method_call_on_unknown_type =\n     the type of this value must be known to call a method on a raw pointer on it\n \n-typeck_value_of_associated_struct_already_specified =\n+hir_analysis_value_of_associated_struct_already_specified =\n     the value of the associated type `{$item_name}` (from trait `{$def_path}`) is already specified\n     .label = re-bound here\n     .previous_bound_label = `{$item_name}` bound here first\n \n-typeck_address_of_temporary_taken = cannot take address of a temporary\n+hir_analysis_address_of_temporary_taken = cannot take address of a temporary\n     .label = temporary value\n \n-typeck_add_return_type_add = try adding a return type\n+hir_analysis_add_return_type_add = try adding a return type\n \n-typeck_add_return_type_missing_here = a return type might be missing here\n+hir_analysis_add_return_type_missing_here = a return type might be missing here\n \n-typeck_expected_default_return_type = expected `()` because of default return type\n+hir_analysis_expected_default_return_type = expected `()` because of default return type\n \n-typeck_expected_return_type = expected `{$expected}` because of return type\n+hir_analysis_expected_return_type = expected `{$expected}` because of return type\n \n-typeck_unconstrained_opaque_type = unconstrained opaque type\n+hir_analysis_unconstrained_opaque_type = unconstrained opaque type\n     .note = `{$name}` must be used in combination with a concrete type within the same module\n \n-typeck_missing_type_params =\n+hir_analysis_missing_type_params =\n     the type {$parameterCount ->\n         [one] parameter\n         *[other] parameters\n@@ -117,19 +117,19 @@ typeck_missing_type_params =\n     } to {$parameters}\n     .note = because of the default `Self` reference, type parameters must be specified on object types\n \n-typeck_manual_implementation =\n+hir_analysis_manual_implementation =\n     manual implementations of `{$trait_name}` are experimental\n     .label = manual implementations of `{$trait_name}` are experimental\n     .help = add `#![feature(unboxed_closures)]` to the crate attributes to enable\n \n-typeck_substs_on_overridden_impl = could not resolve substs on overridden impl\n+hir_analysis_substs_on_overridden_impl = could not resolve substs on overridden impl\n \n-typeck_unused_extern_crate =\n+hir_analysis_unused_extern_crate =\n     unused extern crate\n     .suggestion = remove it\n \n-typeck_extern_crate_not_idiomatic =\n+hir_analysis_extern_crate_not_idiomatic =\n     `extern crate` is not idiomatic in the new edition\n     .suggestion = convert it to a `{$msg_code}`\n \n-typeck_expected_used_symbol = expected `used`, `used(compiler)` or `used(linker)`\n+hir_analysis_expected_used_symbol = expected `used`, `used(compiler)` or `used(linker)`", "previous_filename": "compiler/rustc_error_messages/locales/en-US/typeck.ftl"}, {"sha": "18be60975e4eb46a452f71402a475d6096f01f3d", "filename": "compiler/rustc_error_messages/src/lib.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d9f8b4b98503e3f88623eb59d4f20432161b840a/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9f8b4b98503e3f88623eb59d4f20432161b840a/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Fsrc%2Flib.rs?ref=d9f8b4b98503e3f88623eb59d4f20432161b840a", "patch": "@@ -40,28 +40,29 @@ fluent_messages! {\n     attr => \"../locales/en-US/attr.ftl\",\n     borrowck => \"../locales/en-US/borrowck.ftl\",\n     builtin_macros => \"../locales/en-US/builtin_macros.ftl\",\n+    compiletest => \"../locales/en-US/compiletest.ftl\",\n     const_eval => \"../locales/en-US/const_eval.ftl\",\n     codegen_gcc => \"../locales/en-US/codegen_gcc.ftl\",\n     driver => \"../locales/en-US/driver.ftl\",\n     expand => \"../locales/en-US/expand.ftl\",\n-    session => \"../locales/en-US/session.ftl\",\n-    interface => \"../locales/en-US/interface.ftl\",\n+    hir_analysis => \"../locales/en-US/hir_analysis.ftl\",\n     infer => \"../locales/en-US/infer.ftl\",\n+    interface => \"../locales/en-US/interface.ftl\",\n     lint => \"../locales/en-US/lint.ftl\",\n+    metadata => \"../locales/en-US/metadata.ftl\",\n     middle => \"../locales/en-US/middle.ftl\",\n+    mir_dataflow => \"../locales/en-US/mir_dataflow.ftl\",\n     monomorphize => \"../locales/en-US/monomorphize.ftl\",\n-    metadata => \"../locales/en-US/metadata.ftl\",\n     parser => \"../locales/en-US/parser.ftl\",\n     passes => \"../locales/en-US/passes.ftl\",\n     plugin_impl => \"../locales/en-US/plugin_impl.ftl\",\n     privacy => \"../locales/en-US/privacy.ftl\",\n     query_system => \"../locales/en-US/query_system.ftl\",\n-    trait_selection => \"../locales/en-US/trait_selection.ftl\",\n     save_analysis => \"../locales/en-US/save_analysis.ftl\",\n-    ty_utils => \"../locales/en-US/ty_utils.ftl\",\n-    typeck => \"../locales/en-US/typeck.ftl\",\n-    mir_dataflow => \"../locales/en-US/mir_dataflow.ftl\",\n+    session => \"../locales/en-US/session.ftl\",\n     symbol_mangling => \"../locales/en-US/symbol_mangling.ftl\",\n+    trait_selection => \"../locales/en-US/trait_selection.ftl\",\n+    ty_utils => \"../locales/en-US/ty_utils.ftl\",\n }\n \n pub use fluent_generated::{self as fluent, DEFAULT_LOCALE_RESOURCES};"}, {"sha": "d891171b82468f05f5b19cdb9c05ebd1e9728bd6", "filename": "compiler/rustc_hir_analysis/src/errors.rs", "status": "modified", "additions": 45, "deletions": 44, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/d9f8b4b98503e3f88623eb59d4f20432161b840a/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9f8b4b98503e3f88623eb59d4f20432161b840a/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Ferrors.rs?ref=d9f8b4b98503e3f88623eb59d4f20432161b840a", "patch": "@@ -1,23 +1,24 @@\n-//! Errors emitted by typeck.\n+//! Errors emitted by `hir_analysis`.\n+\n use rustc_errors::IntoDiagnostic;\n use rustc_errors::{error_code, Applicability, DiagnosticBuilder, ErrorGuaranteed, Handler};\n use rustc_macros::{Diagnostic, LintDiagnostic, Subdiagnostic};\n use rustc_middle::ty::Ty;\n use rustc_span::{symbol::Ident, Span, Symbol};\n \n #[derive(Diagnostic)]\n-#[diag(typeck::field_multiply_specified_in_initializer, code = \"E0062\")]\n+#[diag(hir_analysis::field_multiply_specified_in_initializer, code = \"E0062\")]\n pub struct FieldMultiplySpecifiedInInitializer {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n-    #[label(typeck::previous_use_label)]\n+    #[label(hir_analysis::previous_use_label)]\n     pub prev_span: Span,\n     pub ident: Ident,\n }\n \n #[derive(Diagnostic)]\n-#[diag(typeck::unrecognized_atomic_operation, code = \"E0092\")]\n+#[diag(hir_analysis::unrecognized_atomic_operation, code = \"E0092\")]\n pub struct UnrecognizedAtomicOperation<'a> {\n     #[primary_span]\n     #[label]\n@@ -26,7 +27,7 @@ pub struct UnrecognizedAtomicOperation<'a> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(typeck::wrong_number_of_generic_arguments_to_intrinsic, code = \"E0094\")]\n+#[diag(hir_analysis::wrong_number_of_generic_arguments_to_intrinsic, code = \"E0094\")]\n pub struct WrongNumberOfGenericArgumentsToIntrinsic<'a> {\n     #[primary_span]\n     #[label]\n@@ -37,7 +38,7 @@ pub struct WrongNumberOfGenericArgumentsToIntrinsic<'a> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(typeck::unrecognized_intrinsic_function, code = \"E0093\")]\n+#[diag(hir_analysis::unrecognized_intrinsic_function, code = \"E0093\")]\n pub struct UnrecognizedIntrinsicFunction {\n     #[primary_span]\n     #[label]\n@@ -46,92 +47,92 @@ pub struct UnrecognizedIntrinsicFunction {\n }\n \n #[derive(Diagnostic)]\n-#[diag(typeck::lifetimes_or_bounds_mismatch_on_trait, code = \"E0195\")]\n+#[diag(hir_analysis::lifetimes_or_bounds_mismatch_on_trait, code = \"E0195\")]\n pub struct LifetimesOrBoundsMismatchOnTrait {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n-    #[label(typeck::generics_label)]\n+    #[label(hir_analysis::generics_label)]\n     pub generics_span: Option<Span>,\n     pub item_kind: &'static str,\n     pub ident: Ident,\n }\n \n #[derive(Diagnostic)]\n-#[diag(typeck::drop_impl_on_wrong_item, code = \"E0120\")]\n+#[diag(hir_analysis::drop_impl_on_wrong_item, code = \"E0120\")]\n pub struct DropImplOnWrongItem {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(typeck::field_already_declared, code = \"E0124\")]\n+#[diag(hir_analysis::field_already_declared, code = \"E0124\")]\n pub struct FieldAlreadyDeclared {\n     pub field_name: Ident,\n     #[primary_span]\n     #[label]\n     pub span: Span,\n-    #[label(typeck::previous_decl_label)]\n+    #[label(hir_analysis::previous_decl_label)]\n     pub prev_span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(typeck::copy_impl_on_type_with_dtor, code = \"E0184\")]\n+#[diag(hir_analysis::copy_impl_on_type_with_dtor, code = \"E0184\")]\n pub struct CopyImplOnTypeWithDtor {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(typeck::multiple_relaxed_default_bounds, code = \"E0203\")]\n+#[diag(hir_analysis::multiple_relaxed_default_bounds, code = \"E0203\")]\n pub struct MultipleRelaxedDefaultBounds {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(typeck::copy_impl_on_non_adt, code = \"E0206\")]\n+#[diag(hir_analysis::copy_impl_on_non_adt, code = \"E0206\")]\n pub struct CopyImplOnNonAdt {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(typeck::trait_object_declared_with_no_traits, code = \"E0224\")]\n+#[diag(hir_analysis::trait_object_declared_with_no_traits, code = \"E0224\")]\n pub struct TraitObjectDeclaredWithNoTraits {\n     #[primary_span]\n     pub span: Span,\n-    #[label(typeck::alias_span)]\n+    #[label(hir_analysis::alias_span)]\n     pub trait_alias_span: Option<Span>,\n }\n \n #[derive(Diagnostic)]\n-#[diag(typeck::ambiguous_lifetime_bound, code = \"E0227\")]\n+#[diag(hir_analysis::ambiguous_lifetime_bound, code = \"E0227\")]\n pub struct AmbiguousLifetimeBound {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(typeck::assoc_type_binding_not_allowed, code = \"E0229\")]\n+#[diag(hir_analysis::assoc_type_binding_not_allowed, code = \"E0229\")]\n pub struct AssocTypeBindingNotAllowed {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(typeck::functional_record_update_on_non_struct, code = \"E0436\")]\n+#[diag(hir_analysis::functional_record_update_on_non_struct, code = \"E0436\")]\n pub struct FunctionalRecordUpdateOnNonStruct {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(typeck::typeof_reserved_keyword_used, code = \"E0516\")]\n+#[diag(hir_analysis::typeof_reserved_keyword_used, code = \"E0516\")]\n pub struct TypeofReservedKeywordUsed<'tcx> {\n     pub ty: Ty<'tcx>,\n     #[primary_span]\n@@ -142,52 +143,52 @@ pub struct TypeofReservedKeywordUsed<'tcx> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(typeck::return_stmt_outside_of_fn_body, code = \"E0572\")]\n+#[diag(hir_analysis::return_stmt_outside_of_fn_body, code = \"E0572\")]\n pub struct ReturnStmtOutsideOfFnBody {\n     #[primary_span]\n     pub span: Span,\n-    #[label(typeck::encl_body_label)]\n+    #[label(hir_analysis::encl_body_label)]\n     pub encl_body_span: Option<Span>,\n-    #[label(typeck::encl_fn_label)]\n+    #[label(hir_analysis::encl_fn_label)]\n     pub encl_fn_span: Option<Span>,\n }\n \n #[derive(Diagnostic)]\n-#[diag(typeck::yield_expr_outside_of_generator, code = \"E0627\")]\n+#[diag(hir_analysis::yield_expr_outside_of_generator, code = \"E0627\")]\n pub struct YieldExprOutsideOfGenerator {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(typeck::struct_expr_non_exhaustive, code = \"E0639\")]\n+#[diag(hir_analysis::struct_expr_non_exhaustive, code = \"E0639\")]\n pub struct StructExprNonExhaustive {\n     #[primary_span]\n     pub span: Span,\n     pub what: &'static str,\n }\n \n #[derive(Diagnostic)]\n-#[diag(typeck::method_call_on_unknown_type, code = \"E0699\")]\n+#[diag(hir_analysis::method_call_on_unknown_type, code = \"E0699\")]\n pub struct MethodCallOnUnknownType {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(typeck::value_of_associated_struct_already_specified, code = \"E0719\")]\n+#[diag(hir_analysis::value_of_associated_struct_already_specified, code = \"E0719\")]\n pub struct ValueOfAssociatedStructAlreadySpecified {\n     #[primary_span]\n     #[label]\n     pub span: Span,\n-    #[label(typeck::previous_bound_label)]\n+    #[label(hir_analysis::previous_bound_label)]\n     pub prev_span: Span,\n     pub item_name: Ident,\n     pub def_path: String,\n }\n \n #[derive(Diagnostic)]\n-#[diag(typeck::address_of_temporary_taken, code = \"E0745\")]\n+#[diag(hir_analysis::address_of_temporary_taken, code = \"E0745\")]\n pub struct AddressOfTemporaryTaken {\n     #[primary_span]\n     #[label]\n@@ -197,7 +198,7 @@ pub struct AddressOfTemporaryTaken {\n #[derive(Subdiagnostic)]\n pub enum AddReturnTypeSuggestion {\n     #[suggestion(\n-        typeck::add_return_type_add,\n+        hir_analysis::add_return_type_add,\n         code = \"-> {found} \",\n         applicability = \"machine-applicable\"\n     )]\n@@ -207,7 +208,7 @@ pub enum AddReturnTypeSuggestion {\n         found: String,\n     },\n     #[suggestion(\n-        typeck::add_return_type_missing_here,\n+        hir_analysis::add_return_type_missing_here,\n         code = \"-> _ \",\n         applicability = \"has-placeholders\"\n     )]\n@@ -219,12 +220,12 @@ pub enum AddReturnTypeSuggestion {\n \n #[derive(Subdiagnostic)]\n pub enum ExpectedReturnTypeLabel<'tcx> {\n-    #[label(typeck::expected_default_return_type)]\n+    #[label(hir_analysis::expected_default_return_type)]\n     Unit {\n         #[primary_span]\n         span: Span,\n     },\n-    #[label(typeck::expected_return_type)]\n+    #[label(hir_analysis::expected_return_type)]\n     Other {\n         #[primary_span]\n         span: Span,\n@@ -233,7 +234,7 @@ pub enum ExpectedReturnTypeLabel<'tcx> {\n }\n \n #[derive(Diagnostic)]\n-#[diag(typeck::unconstrained_opaque_type)]\n+#[diag(hir_analysis::unconstrained_opaque_type)]\n #[note]\n pub struct UnconstrainedOpaqueType {\n     #[primary_span]\n@@ -254,7 +255,7 @@ impl<'a> IntoDiagnostic<'a> for MissingTypeParams {\n     fn into_diagnostic(self, handler: &'a Handler) -> DiagnosticBuilder<'a, ErrorGuaranteed> {\n         let mut err = handler.struct_span_err_with_code(\n             self.span,\n-            rustc_errors::fluent::typeck::missing_type_params,\n+            rustc_errors::fluent::hir_analysis::missing_type_params,\n             error_code!(E0393),\n         );\n         err.set_arg(\"parameterCount\", self.missing_type_params.len());\n@@ -267,7 +268,7 @@ impl<'a> IntoDiagnostic<'a> for MissingTypeParams {\n                 .join(\", \"),\n         );\n \n-        err.span_label(self.def_span, rustc_errors::fluent::typeck::label);\n+        err.span_label(self.def_span, rustc_errors::fluent::hir_analysis::label);\n \n         let mut suggested = false;\n         // Don't suggest setting the type params if there are some already: the order is\n@@ -282,7 +283,7 @@ impl<'a> IntoDiagnostic<'a> for MissingTypeParams {\n                 // least we can clue them to the correct syntax `Iterator<Type>`.\n                 err.span_suggestion(\n                     self.span,\n-                    rustc_errors::fluent::typeck::suggestion,\n+                    rustc_errors::fluent::hir_analysis::suggestion,\n                     format!(\n                         \"{}<{}>\",\n                         snippet,\n@@ -298,16 +299,16 @@ impl<'a> IntoDiagnostic<'a> for MissingTypeParams {\n             }\n         }\n         if !suggested {\n-            err.span_label(self.span, rustc_errors::fluent::typeck::no_suggestion_label);\n+            err.span_label(self.span, rustc_errors::fluent::hir_analysis::no_suggestion_label);\n         }\n \n-        err.note(rustc_errors::fluent::typeck::note);\n+        err.note(rustc_errors::fluent::hir_analysis::note);\n         err\n     }\n }\n \n #[derive(Diagnostic)]\n-#[diag(typeck::manual_implementation, code = \"E0183\")]\n+#[diag(hir_analysis::manual_implementation, code = \"E0183\")]\n #[help]\n pub struct ManualImplementation {\n     #[primary_span]\n@@ -317,21 +318,21 @@ pub struct ManualImplementation {\n }\n \n #[derive(Diagnostic)]\n-#[diag(typeck::substs_on_overridden_impl)]\n+#[diag(hir_analysis::substs_on_overridden_impl)]\n pub struct SubstsOnOverriddenImpl {\n     #[primary_span]\n     pub span: Span,\n }\n \n #[derive(LintDiagnostic)]\n-#[diag(typeck::unused_extern_crate)]\n+#[diag(hir_analysis::unused_extern_crate)]\n pub struct UnusedExternCrate {\n     #[suggestion(applicability = \"machine-applicable\", code = \"\")]\n     pub span: Span,\n }\n \n #[derive(LintDiagnostic)]\n-#[diag(typeck::extern_crate_not_idiomatic)]\n+#[diag(hir_analysis::extern_crate_not_idiomatic)]\n pub struct ExternCrateNotIdiomatic {\n     #[suggestion_short(applicability = \"machine-applicable\", code = \"{suggestion_code}\")]\n     pub span: Span,\n@@ -340,7 +341,7 @@ pub struct ExternCrateNotIdiomatic {\n }\n \n #[derive(Diagnostic)]\n-#[diag(typeck::expected_used_symbol)]\n+#[diag(hir_analysis::expected_used_symbol)]\n pub struct ExpectedUsedSymbol {\n     #[primary_span]\n     pub span: Span,"}, {"sha": "83040a652b18a5d91d833243533855c15b3a809f", "filename": "compiler/rustc_macros/src/diagnostics/diagnostic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d9f8b4b98503e3f88623eb59d4f20432161b840a/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9f8b4b98503e3f88623eb59d4f20432161b840a/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_macros%2Fsrc%2Fdiagnostics%2Fdiagnostic.rs?ref=d9f8b4b98503e3f88623eb59d4f20432161b840a", "patch": "@@ -36,7 +36,7 @@ impl<'a> DiagnosticDerive<'a> {\n                     span_err(builder.span, \"diagnostic slug not specified\")\n                         .help(&format!(\n                             \"specify the slug as the first argument to the `#[diag(...)]` \\\n-                            attribute, such as `#[diag(typeck::example_error)]`\",\n+                            attribute, such as `#[diag(hir_analysis::example_error)]`\",\n                         ))\n                         .emit();\n                     return DiagnosticDeriveError::ErrorHandled.to_compile_error();\n@@ -113,7 +113,7 @@ impl<'a> LintDiagnosticDerive<'a> {\n                     span_err(builder.span, \"diagnostic slug not specified\")\n                         .help(&format!(\n                             \"specify the slug as the first argument to the attribute, such as \\\n-                            `#[diag(typeck::example_error)]`\",\n+                            `#[diag(compiletest::example)]`\",\n                         ))\n                         .emit();\n                     return DiagnosticDeriveError::ErrorHandled.to_compile_error();"}, {"sha": "9a5100ce17f53224d939d6b9567a0320b1b88a01", "filename": "src/test/ui-fulldeps/internal-lints/diagnostics.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d9f8b4b98503e3f88623eb59d4f20432161b840a/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9f8b4b98503e3f88623eb59d4f20432161b840a/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fdiagnostics.rs?ref=d9f8b4b98503e3f88623eb59d4f20432161b840a", "patch": "@@ -19,14 +19,14 @@ use rustc_macros::{Diagnostic, Subdiagnostic};\n use rustc_span::Span;\n \n #[derive(Diagnostic)]\n-#[diag(parser::expect_path)]\n+#[diag(compiletest::example)]\n struct DeriveDiagnostic {\n     #[primary_span]\n     span: Span,\n }\n \n #[derive(Subdiagnostic)]\n-#[note(parser::add_paren)]\n+#[note(compiletest::example)]\n struct Note {\n     #[primary_span]\n     span: Span,\n@@ -45,7 +45,7 @@ pub struct TranslatableInIntoDiagnostic;\n \n impl<'a> IntoDiagnostic<'a, ErrorGuaranteed> for TranslatableInIntoDiagnostic {\n     fn into_diagnostic(self, handler: &'a Handler) -> DiagnosticBuilder<'a, ErrorGuaranteed> {\n-        handler.struct_err(fluent::parser::expect_path)\n+        handler.struct_err(fluent::compiletest::example)\n     }\n }\n \n@@ -62,12 +62,12 @@ pub struct TranslatableInAddToDiagnostic;\n \n impl AddToDiagnostic for TranslatableInAddToDiagnostic {\n     fn add_to_diagnostic(self, diag: &mut Diagnostic) {\n-        diag.note(fluent::typeck::note);\n+        diag.note(fluent::compiletest::note);\n     }\n }\n \n pub fn make_diagnostics<'a>(handler: &'a Handler) {\n-    let _diag = handler.struct_err(fluent::parser::expect_path);\n+    let _diag = handler.struct_err(fluent::compiletest::example);\n     //~^ ERROR diagnostics should only be created in `IntoDiagnostic`/`AddToDiagnostic` impls\n \n     let _diag = handler.struct_err(\"untranslatable diagnostic\");"}, {"sha": "f5f92ac1e7fbe929ec73fef813290311ebdda3cf", "filename": "src/test/ui-fulldeps/internal-lints/diagnostics.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d9f8b4b98503e3f88623eb59d4f20432161b840a/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fdiagnostics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d9f8b4b98503e3f88623eb59d4f20432161b840a/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fdiagnostics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Finternal-lints%2Fdiagnostics.stderr?ref=d9f8b4b98503e3f88623eb59d4f20432161b840a", "patch": "@@ -19,7 +19,7 @@ LL |         diag.note(\"untranslatable diagnostic\");\n error: diagnostics should only be created in `IntoDiagnostic`/`AddToDiagnostic` impls\n   --> $DIR/diagnostics.rs:70:25\n    |\n-LL |     let _diag = handler.struct_err(fluent::parser::expect_path);\n+LL |     let _diag = handler.struct_err(fluent::compiletest::example);\n    |                         ^^^^^^^^^^\n    |\n note: the lint level is defined here"}, {"sha": "1dc71abc104f93d78c6a3f50378d1446845fe92f", "filename": "src/test/ui-fulldeps/session-diagnostic/diagnostic-derive.rs", "status": "modified", "additions": 126, "deletions": 126, "changes": 252, "blob_url": "https://github.com/rust-lang/rust/blob/d9f8b4b98503e3f88623eb59d4f20432161b840a/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d9f8b4b98503e3f88623eb59d4f20432161b840a/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.rs?ref=d9f8b4b98503e3f88623eb59d4f20432161b840a", "patch": "@@ -28,15 +28,15 @@ use rustc_errors::{Applicability, MultiSpan};\n extern crate rustc_session;\n \n #[derive(Diagnostic)]\n-#[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+#[diag(compiletest::example, code = \"E0123\")]\n struct Hello {}\n \n #[derive(Diagnostic)]\n-#[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+#[diag(compiletest::example, code = \"E0123\")]\n struct HelloWarn {}\n \n #[derive(Diagnostic)]\n-#[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+#[diag(compiletest::example, code = \"E0123\")]\n //~^ ERROR unsupported type attribute for diagnostic derive enum\n enum DiagnosticOnEnum {\n     Foo,\n@@ -46,13 +46,13 @@ enum DiagnosticOnEnum {\n }\n \n #[derive(Diagnostic)]\n-#[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+#[diag(compiletest::example, code = \"E0123\")]\n #[diag = \"E0123\"]\n //~^ ERROR `#[diag = ...]` is not a valid attribute\n struct WrongStructAttrStyle {}\n \n #[derive(Diagnostic)]\n-#[nonsense(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+#[nonsense(compiletest::example, code = \"E0123\")]\n //~^ ERROR `#[nonsense(...)]` is not a valid attribute\n //~^^ ERROR diagnostic slug not specified\n //~^^^ ERROR cannot find attribute `nonsense` in this scope\n@@ -90,33 +90,33 @@ struct InvalidNestedStructAttr2 {}\n struct InvalidNestedStructAttr3 {}\n \n #[derive(Diagnostic)]\n-#[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\", slug = \"foo\")]\n+#[diag(compiletest::example, code = \"E0123\", slug = \"foo\")]\n //~^ ERROR `#[diag(slug = ...)]` is not a valid attribute\n struct InvalidNestedStructAttr4 {}\n \n #[derive(Diagnostic)]\n-#[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+#[diag(compiletest::example, code = \"E0123\")]\n struct WrongPlaceField {\n     #[suggestion = \"bar\"]\n     //~^ ERROR `#[suggestion = ...]` is not a valid attribute\n     sp: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n-#[diag(typeck::ambiguous_lifetime_bound, code = \"E0456\")]\n+#[diag(compiletest::example, code = \"E0123\")]\n+#[diag(compiletest::example, code = \"E0456\")]\n //~^ ERROR specified multiple times\n //~^^ ERROR specified multiple times\n struct DiagSpecifiedTwice {}\n \n #[derive(Diagnostic)]\n-#[diag(typeck::ambiguous_lifetime_bound, code = \"E0456\", code = \"E0457\")]\n+#[diag(compiletest::example, code = \"E0456\", code = \"E0457\")]\n //~^ ERROR specified multiple times\n struct CodeSpecifiedTwice {}\n \n #[derive(Diagnostic)]\n-#[diag(typeck::ambiguous_lifetime_bound, typeck::ambiguous_lifetime_bound, code = \"E0456\")]\n-//~^ ERROR `#[diag(typeck::ambiguous_lifetime_bound)]` is not a valid attribute\n+#[diag(compiletest::example, compiletest::example, code = \"E0456\")]\n+//~^ ERROR `#[diag(compiletest::example)]` is not a valid attribute\n struct SlugSpecifiedTwice {}\n \n #[derive(Diagnostic)]\n@@ -128,19 +128,19 @@ struct KindNotProvided {} //~ ERROR diagnostic slug not specified\n struct SlugNotProvided {}\n \n #[derive(Diagnostic)]\n-#[diag(typeck::ambiguous_lifetime_bound)]\n+#[diag(compiletest::example)]\n struct CodeNotProvided {}\n \n #[derive(Diagnostic)]\n-#[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+#[diag(compiletest::example, code = \"E0123\")]\n struct MessageWrongType {\n     #[primary_span]\n     //~^ ERROR `#[primary_span]` attribute can only be applied to fields of type `Span` or `MultiSpan`\n     foo: String,\n }\n \n #[derive(Diagnostic)]\n-#[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+#[diag(compiletest::example, code = \"E0123\")]\n struct InvalidPathFieldAttr {\n     #[nonsense]\n     //~^ ERROR `#[nonsense]` is not a valid attribute\n@@ -149,84 +149,84 @@ struct InvalidPathFieldAttr {\n }\n \n #[derive(Diagnostic)]\n-#[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+#[diag(compiletest::example, code = \"E0123\")]\n struct ErrorWithField {\n     name: String,\n-    #[label(typeck::label)]\n+    #[label(compiletest::label)]\n     span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+#[diag(compiletest::example, code = \"E0123\")]\n struct ErrorWithMessageAppliedToField {\n-    #[label(typeck::label)]\n+    #[label(compiletest::label)]\n     //~^ ERROR the `#[label(...)]` attribute can only be applied to fields of type `Span` or `MultiSpan`\n     name: String,\n }\n \n #[derive(Diagnostic)]\n-#[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+#[diag(compiletest::example, code = \"E0123\")]\n struct ErrorWithNonexistentField {\n-    #[suggestion(typeck::suggestion, code = \"{name}\")]\n+    #[suggestion(compiletest::suggestion, code = \"{name}\")]\n     //~^ ERROR `name` doesn't refer to a field on this type\n     suggestion: (Span, Applicability),\n }\n \n #[derive(Diagnostic)]\n //~^ ERROR invalid format string: expected `'}'`\n-#[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+#[diag(compiletest::example, code = \"E0123\")]\n struct ErrorMissingClosingBrace {\n-    #[suggestion(typeck::suggestion, code = \"{name\")]\n+    #[suggestion(compiletest::suggestion, code = \"{name\")]\n     suggestion: (Span, Applicability),\n     name: String,\n     val: usize,\n }\n \n #[derive(Diagnostic)]\n //~^ ERROR invalid format string: unmatched `}`\n-#[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+#[diag(compiletest::example, code = \"E0123\")]\n struct ErrorMissingOpeningBrace {\n-    #[suggestion(typeck::suggestion, code = \"name}\")]\n+    #[suggestion(compiletest::suggestion, code = \"name}\")]\n     suggestion: (Span, Applicability),\n     name: String,\n     val: usize,\n }\n \n #[derive(Diagnostic)]\n-#[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+#[diag(compiletest::example, code = \"E0123\")]\n struct LabelOnSpan {\n-    #[label(typeck::label)]\n+    #[label(compiletest::label)]\n     sp: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+#[diag(compiletest::example, code = \"E0123\")]\n struct LabelOnNonSpan {\n-    #[label(typeck::label)]\n+    #[label(compiletest::label)]\n     //~^ ERROR the `#[label(...)]` attribute can only be applied to fields of type `Span` or `MultiSpan`\n     id: u32,\n }\n \n #[derive(Diagnostic)]\n-#[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+#[diag(compiletest::example, code = \"E0123\")]\n struct Suggest {\n-    #[suggestion(typeck::suggestion, code = \"This is the suggested code\")]\n-    #[suggestion_short(typeck::suggestion, code = \"This is the suggested code\")]\n-    #[suggestion_hidden(typeck::suggestion, code = \"This is the suggested code\")]\n-    #[suggestion_verbose(typeck::suggestion, code = \"This is the suggested code\")]\n+    #[suggestion(compiletest::suggestion, code = \"This is the suggested code\")]\n+    #[suggestion_short(compiletest::suggestion, code = \"This is the suggested code\")]\n+    #[suggestion_hidden(compiletest::suggestion, code = \"This is the suggested code\")]\n+    #[suggestion_verbose(compiletest::suggestion, code = \"This is the suggested code\")]\n     suggestion: (Span, Applicability),\n }\n \n #[derive(Diagnostic)]\n-#[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+#[diag(compiletest::example, code = \"E0123\")]\n struct SuggestWithoutCode {\n-    #[suggestion(typeck::suggestion)]\n+    #[suggestion(compiletest::suggestion)]\n     //~^ ERROR suggestion without `code = \"...\"`\n     suggestion: (Span, Applicability),\n }\n \n #[derive(Diagnostic)]\n-#[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+#[diag(compiletest::example, code = \"E0123\")]\n struct SuggestWithBadKey {\n     #[suggestion(nonsense = \"bar\")]\n     //~^ ERROR `#[suggestion(nonsense = ...)]` is not a valid attribute\n@@ -235,7 +235,7 @@ struct SuggestWithBadKey {\n }\n \n #[derive(Diagnostic)]\n-#[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+#[diag(compiletest::example, code = \"E0123\")]\n struct SuggestWithShorthandMsg {\n     #[suggestion(msg = \"bar\")]\n     //~^ ERROR `#[suggestion(msg = ...)]` is not a valid attribute\n@@ -244,91 +244,91 @@ struct SuggestWithShorthandMsg {\n }\n \n #[derive(Diagnostic)]\n-#[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+#[diag(compiletest::example, code = \"E0123\")]\n struct SuggestWithoutMsg {\n     #[suggestion(code = \"bar\")]\n     suggestion: (Span, Applicability),\n }\n \n #[derive(Diagnostic)]\n-#[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+#[diag(compiletest::example, code = \"E0123\")]\n struct SuggestWithTypesSwapped {\n-    #[suggestion(typeck::suggestion, code = \"This is suggested code\")]\n+    #[suggestion(compiletest::suggestion, code = \"This is suggested code\")]\n     suggestion: (Applicability, Span),\n }\n \n #[derive(Diagnostic)]\n-#[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+#[diag(compiletest::example, code = \"E0123\")]\n struct SuggestWithWrongTypeApplicabilityOnly {\n-    #[suggestion(typeck::suggestion, code = \"This is suggested code\")]\n+    #[suggestion(compiletest::suggestion, code = \"This is suggested code\")]\n     //~^ ERROR wrong field type for suggestion\n     suggestion: Applicability,\n }\n \n #[derive(Diagnostic)]\n-#[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+#[diag(compiletest::example, code = \"E0123\")]\n struct SuggestWithSpanOnly {\n-    #[suggestion(typeck::suggestion, code = \"This is suggested code\")]\n+    #[suggestion(compiletest::suggestion, code = \"This is suggested code\")]\n     suggestion: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+#[diag(compiletest::example, code = \"E0123\")]\n struct SuggestWithDuplicateSpanAndApplicability {\n-    #[suggestion(typeck::suggestion, code = \"This is suggested code\")]\n+    #[suggestion(compiletest::suggestion, code = \"This is suggested code\")]\n     suggestion: (Span, Span, Applicability),\n     //~^ ERROR specified multiple times\n }\n \n #[derive(Diagnostic)]\n-#[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+#[diag(compiletest::example, code = \"E0123\")]\n struct SuggestWithDuplicateApplicabilityAndSpan {\n-    #[suggestion(typeck::suggestion, code = \"This is suggested code\")]\n+    #[suggestion(compiletest::suggestion, code = \"This is suggested code\")]\n     suggestion: (Applicability, Applicability, Span),\n     //~^ ERROR specified multiple times\n }\n \n #[derive(Diagnostic)]\n-#[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+#[diag(compiletest::example, code = \"E0123\")]\n struct WrongKindOfAnnotation {\n     #[label = \"bar\"]\n     //~^ ERROR `#[label = ...]` is not a valid attribute\n     z: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+#[diag(compiletest::example, code = \"E0123\")]\n struct OptionsInErrors {\n-    #[label(typeck::label)]\n+    #[label(compiletest::label)]\n     label: Option<Span>,\n-    #[suggestion(typeck::suggestion, code = \"...\")]\n+    #[suggestion(compiletest::suggestion, code = \"...\")]\n     opt_sugg: Option<(Span, Applicability)>,\n }\n \n #[derive(Diagnostic)]\n-#[diag(typeck::ambiguous_lifetime_bound, code = \"E0456\")]\n+#[diag(compiletest::example, code = \"E0456\")]\n struct MoveOutOfBorrowError<'tcx> {\n     name: Ident,\n     ty: Ty<'tcx>,\n     #[primary_span]\n-    #[label(typeck::label)]\n+    #[label(compiletest::label)]\n     span: Span,\n-    #[label(typeck::label)]\n+    #[label(compiletest::label)]\n     other_span: Span,\n-    #[suggestion(typeck::suggestion, code = \"{name}.clone()\")]\n+    #[suggestion(compiletest::suggestion, code = \"{name}.clone()\")]\n     opt_sugg: Option<(Span, Applicability)>,\n }\n \n #[derive(Diagnostic)]\n-#[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+#[diag(compiletest::example, code = \"E0123\")]\n struct ErrorWithLifetime<'a> {\n-    #[label(typeck::label)]\n+    #[label(compiletest::label)]\n     span: Span,\n     name: &'a str,\n }\n \n #[derive(Diagnostic)]\n-#[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+#[diag(compiletest::example, code = \"E0123\")]\n struct ErrorWithDefaultLabelAttr<'a> {\n     #[label]\n     span: Span,\n@@ -337,15 +337,15 @@ struct ErrorWithDefaultLabelAttr<'a> {\n \n #[derive(Diagnostic)]\n //~^ ERROR the trait bound `Hello: IntoDiagnosticArg` is not satisfied\n-#[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+#[diag(compiletest::example, code = \"E0123\")]\n struct ArgFieldWithoutSkip {\n     #[primary_span]\n     span: Span,\n     other: Hello,\n }\n \n #[derive(Diagnostic)]\n-#[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+#[diag(compiletest::example, code = \"E0123\")]\n struct ArgFieldWithSkip {\n     #[primary_span]\n     span: Span,\n@@ -356,116 +356,116 @@ struct ArgFieldWithSkip {\n }\n \n #[derive(Diagnostic)]\n-#[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+#[diag(compiletest::example, code = \"E0123\")]\n struct ErrorWithSpannedNote {\n     #[note]\n     span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+#[diag(compiletest::example, code = \"E0123\")]\n struct ErrorWithSpannedNoteCustom {\n-    #[note(typeck::note)]\n+    #[note(compiletest::note)]\n     span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+#[diag(compiletest::example, code = \"E0123\")]\n #[note]\n struct ErrorWithNote {\n     val: String,\n }\n \n #[derive(Diagnostic)]\n-#[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n-#[note(typeck::note)]\n+#[diag(compiletest::example, code = \"E0123\")]\n+#[note(compiletest::note)]\n struct ErrorWithNoteCustom {\n     val: String,\n }\n \n #[derive(Diagnostic)]\n-#[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+#[diag(compiletest::example, code = \"E0123\")]\n struct ErrorWithSpannedHelp {\n     #[help]\n     span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+#[diag(compiletest::example, code = \"E0123\")]\n struct ErrorWithSpannedHelpCustom {\n-    #[help(typeck::help)]\n+    #[help(compiletest::help)]\n     span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+#[diag(compiletest::example, code = \"E0123\")]\n #[help]\n struct ErrorWithHelp {\n     val: String,\n }\n \n #[derive(Diagnostic)]\n-#[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n-#[help(typeck::help)]\n+#[diag(compiletest::example, code = \"E0123\")]\n+#[help(compiletest::help)]\n struct ErrorWithHelpCustom {\n     val: String,\n }\n \n #[derive(Diagnostic)]\n #[help]\n-#[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+#[diag(compiletest::example, code = \"E0123\")]\n struct ErrorWithHelpWrongOrder {\n     val: String,\n }\n \n #[derive(Diagnostic)]\n-#[help(typeck::help)]\n-#[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+#[help(compiletest::help)]\n+#[diag(compiletest::example, code = \"E0123\")]\n struct ErrorWithHelpCustomWrongOrder {\n     val: String,\n }\n \n #[derive(Diagnostic)]\n #[note]\n-#[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+#[diag(compiletest::example, code = \"E0123\")]\n struct ErrorWithNoteWrongOrder {\n     val: String,\n }\n \n #[derive(Diagnostic)]\n-#[note(typeck::note)]\n-#[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+#[note(compiletest::note)]\n+#[diag(compiletest::example, code = \"E0123\")]\n struct ErrorWithNoteCustomWrongOrder {\n     val: String,\n }\n \n #[derive(Diagnostic)]\n-#[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+#[diag(compiletest::example, code = \"E0123\")]\n struct ApplicabilityInBoth {\n-    #[suggestion(typeck::suggestion, code = \"...\", applicability = \"maybe-incorrect\")]\n+    #[suggestion(compiletest::suggestion, code = \"...\", applicability = \"maybe-incorrect\")]\n     //~^ ERROR specified multiple times\n     suggestion: (Span, Applicability),\n }\n \n #[derive(Diagnostic)]\n-#[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+#[diag(compiletest::example, code = \"E0123\")]\n struct InvalidApplicability {\n-    #[suggestion(typeck::suggestion, code = \"...\", applicability = \"batman\")]\n+    #[suggestion(compiletest::suggestion, code = \"...\", applicability = \"batman\")]\n     //~^ ERROR invalid applicability\n     suggestion: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+#[diag(compiletest::example, code = \"E0123\")]\n struct ValidApplicability {\n-    #[suggestion(typeck::suggestion, code = \"...\", applicability = \"maybe-incorrect\")]\n+    #[suggestion(compiletest::suggestion, code = \"...\", applicability = \"maybe-incorrect\")]\n     suggestion: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+#[diag(compiletest::example, code = \"E0123\")]\n struct NoApplicability {\n-    #[suggestion(typeck::suggestion, code = \"...\")]\n+    #[suggestion(compiletest::suggestion, code = \"...\")]\n     suggestion: Span,\n }\n \n@@ -474,180 +474,180 @@ struct NoApplicability {\n struct Note;\n \n #[derive(Diagnostic)]\n-#[diag(typeck::ambiguous_lifetime_bound)]\n+#[diag(compiletest::example)]\n struct Subdiagnostic {\n     #[subdiagnostic]\n     note: Note,\n }\n \n #[derive(Diagnostic)]\n-#[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+#[diag(compiletest::example, code = \"E0123\")]\n struct VecField {\n     #[primary_span]\n     #[label]\n     spans: Vec<Span>,\n }\n \n #[derive(Diagnostic)]\n-#[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+#[diag(compiletest::example, code = \"E0123\")]\n struct UnitField {\n     #[primary_span]\n     spans: Span,\n     #[help]\n     foo: (),\n-    #[help(typeck::help)]\n+    #[help(compiletest::help)]\n     bar: (),\n }\n \n #[derive(Diagnostic)]\n-#[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+#[diag(compiletest::example, code = \"E0123\")]\n struct OptUnitField {\n     #[primary_span]\n     spans: Span,\n     #[help]\n     foo: Option<()>,\n-    #[help(typeck::help)]\n+    #[help(compiletest::help)]\n     bar: Option<()>,\n }\n \n #[derive(Diagnostic)]\n-#[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+#[diag(compiletest::example, code = \"E0123\")]\n struct LabelWithTrailingPath {\n-    #[label(typeck::label, foo)]\n+    #[label(compiletest::label, foo)]\n     //~^ ERROR `#[label(foo)]` is not a valid attribute\n     span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+#[diag(compiletest::example, code = \"E0123\")]\n struct LabelWithTrailingNameValue {\n-    #[label(typeck::label, foo = \"...\")]\n+    #[label(compiletest::label, foo = \"...\")]\n     //~^ ERROR `#[label(foo = ...)]` is not a valid attribute\n     span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+#[diag(compiletest::example, code = \"E0123\")]\n struct LabelWithTrailingList {\n-    #[label(typeck::label, foo(\"...\"))]\n+    #[label(compiletest::label, foo(\"...\"))]\n     //~^ ERROR `#[label(foo(...))]` is not a valid attribute\n     span: Span,\n }\n \n #[derive(LintDiagnostic)]\n-#[diag(typeck::ambiguous_lifetime_bound)]\n+#[diag(compiletest::example)]\n struct LintsGood {\n }\n \n #[derive(LintDiagnostic)]\n-#[diag(typeck::ambiguous_lifetime_bound)]\n+#[diag(compiletest::example)]\n struct PrimarySpanOnLint {\n     #[primary_span]\n     //~^ ERROR `#[primary_span]` is not a valid attribute\n     span: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+#[diag(compiletest::example, code = \"E0123\")]\n struct ErrorWithMultiSpan {\n     #[primary_span]\n     span: MultiSpan,\n }\n \n #[derive(Diagnostic)]\n-#[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+#[diag(compiletest::example, code = \"E0123\")]\n #[warning]\n struct ErrorWithWarn {\n     val: String,\n }\n \n #[derive(Diagnostic)]\n-#[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+#[error(compiletest::example, code = \"E0123\")]\n //~^ ERROR `#[error(...)]` is not a valid attribute\n //~| ERROR diagnostic slug not specified\n //~| ERROR cannot find attribute `error` in this scope\n struct ErrorAttribute {}\n \n #[derive(Diagnostic)]\n-#[warn_(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+#[warn_(compiletest::example, code = \"E0123\")]\n //~^ ERROR `#[warn_(...)]` is not a valid attribute\n //~| ERROR diagnostic slug not specified\n //~| ERROR cannot find attribute `warn_` in this scope\n struct WarnAttribute {}\n \n #[derive(Diagnostic)]\n-#[lint(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+#[lint(compiletest::example, code = \"E0123\")]\n //~^ ERROR `#[lint(...)]` is not a valid attribute\n //~| ERROR diagnostic slug not specified\n //~| ERROR cannot find attribute `lint` in this scope\n struct LintAttributeOnSessionDiag {}\n \n #[derive(LintDiagnostic)]\n-#[lint(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+#[lint(compiletest::example, code = \"E0123\")]\n //~^ ERROR `#[lint(...)]` is not a valid attribute\n //~| ERROR `#[lint(...)]` is not a valid attribute\n //~| ERROR diagnostic slug not specified\n //~| ERROR cannot find attribute `lint` in this scope\n struct LintAttributeOnLintDiag {}\n \n #[derive(Diagnostic)]\n-#[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+#[diag(compiletest::example, code = \"E0123\")]\n struct DuplicatedSuggestionCode {\n-    #[suggestion(typeck::suggestion, code = \"...\", code = \",,,\")]\n+    #[suggestion(compiletest::suggestion, code = \"...\", code = \",,,\")]\n     //~^ ERROR specified multiple times\n     suggestion: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+#[diag(compiletest::example, code = \"E0123\")]\n struct InvalidTypeInSuggestionTuple {\n-    #[suggestion(typeck::suggestion, code = \"...\")]\n+    #[suggestion(compiletest::suggestion, code = \"...\")]\n     suggestion: (Span, usize),\n     //~^ ERROR wrong types for suggestion\n }\n \n #[derive(Diagnostic)]\n-#[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+#[diag(compiletest::example, code = \"E0123\")]\n struct MissingApplicabilityInSuggestionTuple {\n-    #[suggestion(typeck::suggestion, code = \"...\")]\n+    #[suggestion(compiletest::suggestion, code = \"...\")]\n     suggestion: (Span,),\n     //~^ ERROR wrong types for suggestion\n }\n \n #[derive(Diagnostic)]\n-#[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+#[diag(compiletest::example, code = \"E0123\")]\n struct MissingCodeInSuggestion {\n-    #[suggestion(typeck::suggestion)]\n+    #[suggestion(compiletest::suggestion)]\n     //~^ ERROR suggestion without `code = \"...\"`\n     suggestion: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n-#[multipart_suggestion(typeck::suggestion)]\n+#[diag(compiletest::example, code = \"E0123\")]\n+#[multipart_suggestion(compiletest::suggestion)]\n //~^ ERROR `#[multipart_suggestion(...)]` is not a valid attribute\n //~| ERROR cannot find attribute `multipart_suggestion` in this scope\n #[multipart_suggestion()]\n //~^ ERROR `#[multipart_suggestion(...)]` is not a valid attribute\n //~| ERROR cannot find attribute `multipart_suggestion` in this scope\n struct MultipartSuggestion {\n-    #[multipart_suggestion(typeck::suggestion)]\n+    #[multipart_suggestion(compiletest::suggestion)]\n     //~^ ERROR `#[multipart_suggestion(...)]` is not a valid attribute\n     //~| ERROR cannot find attribute `multipart_suggestion` in this scope\n     suggestion: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n-#[suggestion(typeck::suggestion, code = \"...\")]\n+#[diag(compiletest::example, code = \"E0123\")]\n+#[suggestion(compiletest::suggestion, code = \"...\")]\n //~^ ERROR `#[suggestion(...)]` is not a valid attribute\n struct SuggestionOnStruct {\n     #[primary_span]\n     suggestion: Span,\n }\n \n #[derive(Diagnostic)]\n-#[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+#[diag(compiletest::example, code = \"E0123\")]\n #[label]\n //~^ ERROR `#[label]` is not a valid attribute\n struct LabelOnStruct {\n@@ -657,24 +657,24 @@ struct LabelOnStruct {\n \n #[derive(Diagnostic)]\n enum ExampleEnum {\n-    #[diag(typeck::ambiguous_lifetime_bound)]\n+    #[diag(compiletest::example)]\n     Foo {\n         #[primary_span]\n         sp: Span,\n         #[note]\n         note_sp: Span,\n     },\n-    #[diag(typeck::ambiguous_lifetime_bound)]\n+    #[diag(compiletest::example)]\n     Bar {\n         #[primary_span]\n         sp: Span,\n     },\n-    #[diag(typeck::ambiguous_lifetime_bound)]\n+    #[diag(compiletest::example)]\n     Baz,\n }\n \n #[derive(Diagnostic)]\n-#[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+#[diag(compiletest::example, code = \"E0123\")]\n struct RawIdentDiagnosticArg {\n     pub r#type: String,\n }"}, {"sha": "167198b47f20ffd47213e6a9ce7e752e7f51d7a9", "filename": "src/test/ui-fulldeps/session-diagnostic/diagnostic-derive.stderr", "status": "modified", "additions": 101, "deletions": 101, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/d9f8b4b98503e3f88623eb59d4f20432161b840a/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d9f8b4b98503e3f88623eb59d4f20432161b840a/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui-fulldeps%2Fsession-diagnostic%2Fdiagnostic-derive.stderr?ref=d9f8b4b98503e3f88623eb59d4f20432161b840a", "patch": "@@ -1,24 +1,24 @@\n error: unsupported type attribute for diagnostic derive enum\n   --> $DIR/diagnostic-derive.rs:39:1\n    |\n-LL | #[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | #[diag(compiletest::example, code = \"E0123\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: diagnostic slug not specified\n   --> $DIR/diagnostic-derive.rs:42:5\n    |\n LL |     Foo,\n    |     ^^^\n    |\n-   = help: specify the slug as the first argument to the `#[diag(...)]` attribute, such as `#[diag(typeck::example_error)]`\n+   = help: specify the slug as the first argument to the `#[diag(...)]` attribute, such as `#[diag(hir_analysis::example_error)]`\n \n error: diagnostic slug not specified\n   --> $DIR/diagnostic-derive.rs:44:5\n    |\n LL |     Bar,\n    |     ^^^\n    |\n-   = help: specify the slug as the first argument to the `#[diag(...)]` attribute, such as `#[diag(typeck::example_error)]`\n+   = help: specify the slug as the first argument to the `#[diag(...)]` attribute, such as `#[diag(hir_analysis::example_error)]`\n \n error: `#[diag = ...]` is not a valid attribute\n   --> $DIR/diagnostic-derive.rs:50:1\n@@ -29,20 +29,20 @@ LL | #[diag = \"E0123\"]\n error: `#[nonsense(...)]` is not a valid attribute\n   --> $DIR/diagnostic-derive.rs:55:1\n    |\n-LL | #[nonsense(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | #[nonsense(compiletest::example, code = \"E0123\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: diagnostic slug not specified\n   --> $DIR/diagnostic-derive.rs:55:1\n    |\n-LL | / #[nonsense(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+LL | / #[nonsense(compiletest::example, code = \"E0123\")]\n LL | |\n LL | |\n LL | |\n LL | | struct InvalidStructAttr {}\n    | |___________________________^\n    |\n-   = help: specify the slug as the first argument to the `#[diag(...)]` attribute, such as `#[diag(typeck::example_error)]`\n+   = help: specify the slug as the first argument to the `#[diag(...)]` attribute, such as `#[diag(hir_analysis::example_error)]`\n \n error: `#[diag(\"...\")]` is not a valid attribute\n   --> $DIR/diagnostic-derive.rs:62:8\n@@ -61,7 +61,7 @@ LL | |\n LL | | struct InvalidLitNestedAttr {}\n    | |______________________________^\n    |\n-   = help: specify the slug as the first argument to the `#[diag(...)]` attribute, such as `#[diag(typeck::example_error)]`\n+   = help: specify the slug as the first argument to the `#[diag(...)]` attribute, such as `#[diag(hir_analysis::example_error)]`\n \n error: `#[diag(nonsense(...))]` is not a valid attribute\n   --> $DIR/diagnostic-derive.rs:73:8\n@@ -80,7 +80,7 @@ LL | |\n LL | | struct InvalidNestedStructAttr1 {}\n    | |__________________________________^\n    |\n-   = help: specify the slug as the first argument to the `#[diag(...)]` attribute, such as `#[diag(typeck::example_error)]`\n+   = help: specify the slug as the first argument to the `#[diag(...)]` attribute, such as `#[diag(hir_analysis::example_error)]`\n \n error: `#[diag(nonsense = ...)]` is not a valid attribute\n   --> $DIR/diagnostic-derive.rs:79:8\n@@ -108,7 +108,7 @@ LL | |\n LL | | struct InvalidNestedStructAttr2 {}\n    | |__________________________________^\n    |\n-   = help: specify the slug as the first argument to the `#[diag(...)]` attribute, such as `#[diag(typeck::example_error)]`\n+   = help: specify the slug as the first argument to the `#[diag(...)]` attribute, such as `#[diag(hir_analysis::example_error)]`\n \n error: `#[diag(nonsense = ...)]` is not a valid attribute\n   --> $DIR/diagnostic-derive.rs:86:8\n@@ -134,13 +134,13 @@ LL | |\n LL | | struct InvalidNestedStructAttr3 {}\n    | |__________________________________^\n    |\n-   = help: specify the slug as the first argument to the `#[diag(...)]` attribute, such as `#[diag(typeck::example_error)]`\n+   = help: specify the slug as the first argument to the `#[diag(...)]` attribute, such as `#[diag(hir_analysis::example_error)]`\n \n error: `#[diag(slug = ...)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:93:58\n+  --> $DIR/diagnostic-derive.rs:93:46\n    |\n-LL | #[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\", slug = \"foo\")]\n-   |                                                          ^^^^^^^^^^^^\n+LL | #[diag(compiletest::example, code = \"E0123\", slug = \"foo\")]\n+   |                                              ^^^^^^^^^^^^\n    |\n    = help: only `code` is a valid nested attributes following the slug\n \n@@ -153,44 +153,44 @@ LL |     #[suggestion = \"bar\"]\n error: specified multiple times\n   --> $DIR/diagnostic-derive.rs:107:8\n    |\n-LL | #[diag(typeck::ambiguous_lifetime_bound, code = \"E0456\")]\n-   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | #[diag(compiletest::example, code = \"E0456\")]\n+   |        ^^^^^^^^^^^^^^^^^^^^\n    |\n note: previously specified here\n   --> $DIR/diagnostic-derive.rs:106:8\n    |\n-LL | #[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n-   |        ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | #[diag(compiletest::example, code = \"E0123\")]\n+   |        ^^^^^^^^^^^^^^^^^^^^\n \n error: specified multiple times\n-  --> $DIR/diagnostic-derive.rs:107:49\n+  --> $DIR/diagnostic-derive.rs:107:37\n    |\n-LL | #[diag(typeck::ambiguous_lifetime_bound, code = \"E0456\")]\n-   |                                                 ^^^^^^^\n+LL | #[diag(compiletest::example, code = \"E0456\")]\n+   |                                     ^^^^^^^\n    |\n note: previously specified here\n-  --> $DIR/diagnostic-derive.rs:106:49\n+  --> $DIR/diagnostic-derive.rs:106:37\n    |\n-LL | #[diag(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n-   |                                                 ^^^^^^^\n+LL | #[diag(compiletest::example, code = \"E0123\")]\n+   |                                     ^^^^^^^\n \n error: specified multiple times\n-  --> $DIR/diagnostic-derive.rs:113:65\n+  --> $DIR/diagnostic-derive.rs:113:53\n    |\n-LL | #[diag(typeck::ambiguous_lifetime_bound, code = \"E0456\", code = \"E0457\")]\n-   |                                                                 ^^^^^^^\n+LL | #[diag(compiletest::example, code = \"E0456\", code = \"E0457\")]\n+   |                                                     ^^^^^^^\n    |\n note: previously specified here\n-  --> $DIR/diagnostic-derive.rs:113:49\n+  --> $DIR/diagnostic-derive.rs:113:37\n    |\n-LL | #[diag(typeck::ambiguous_lifetime_bound, code = \"E0456\", code = \"E0457\")]\n-   |                                                 ^^^^^^^\n+LL | #[diag(compiletest::example, code = \"E0456\", code = \"E0457\")]\n+   |                                     ^^^^^^^\n \n-error: `#[diag(typeck::ambiguous_lifetime_bound)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:118:42\n+error: `#[diag(compiletest::example)]` is not a valid attribute\n+  --> $DIR/diagnostic-derive.rs:118:30\n    |\n-LL | #[diag(typeck::ambiguous_lifetime_bound, typeck::ambiguous_lifetime_bound, code = \"E0456\")]\n-   |                                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | #[diag(compiletest::example, compiletest::example, code = \"E0456\")]\n+   |                              ^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: diagnostic slug must be the first argument\n \n@@ -200,7 +200,7 @@ error: diagnostic slug not specified\n LL | struct KindNotProvided {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n-   = help: specify the slug as the first argument to the `#[diag(...)]` attribute, such as `#[diag(typeck::example_error)]`\n+   = help: specify the slug as the first argument to the `#[diag(...)]` attribute, such as `#[diag(hir_analysis::example_error)]`\n \n error: diagnostic slug not specified\n   --> $DIR/diagnostic-derive.rs:126:1\n@@ -210,7 +210,7 @@ LL | |\n LL | | struct SlugNotProvided {}\n    | |_________________________^\n    |\n-   = help: specify the slug as the first argument to the `#[diag(...)]` attribute, such as `#[diag(typeck::example_error)]`\n+   = help: specify the slug as the first argument to the `#[diag(...)]` attribute, such as `#[diag(hir_analysis::example_error)]`\n \n error: the `#[primary_span]` attribute can only be applied to fields of type `Span` or `MultiSpan`\n   --> $DIR/diagnostic-derive.rs:137:5\n@@ -227,14 +227,14 @@ LL |     #[nonsense]\n error: the `#[label(...)]` attribute can only be applied to fields of type `Span` or `MultiSpan`\n   --> $DIR/diagnostic-derive.rs:162:5\n    |\n-LL |     #[label(typeck::label)]\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     #[label(compiletest::label)]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: `name` doesn't refer to a field on this type\n-  --> $DIR/diagnostic-derive.rs:170:45\n+  --> $DIR/diagnostic-derive.rs:170:50\n    |\n-LL |     #[suggestion(typeck::suggestion, code = \"{name}\")]\n-   |                                             ^^^^^^^^\n+LL |     #[suggestion(compiletest::suggestion, code = \"{name}\")]\n+   |                                                  ^^^^^^^^\n \n error: invalid format string: expected `'}'` but string was terminated\n   --> $DIR/diagnostic-derive.rs:175:10\n@@ -257,14 +257,14 @@ LL | #[derive(Diagnostic)]\n error: the `#[label(...)]` attribute can only be applied to fields of type `Span` or `MultiSpan`\n   --> $DIR/diagnostic-derive.rs:205:5\n    |\n-LL |     #[label(typeck::label)]\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     #[label(compiletest::label)]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: suggestion without `code = \"...\"`\n   --> $DIR/diagnostic-derive.rs:223:5\n    |\n-LL |     #[suggestion(typeck::suggestion)]\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     #[suggestion(compiletest::suggestion)]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: `#[suggestion(nonsense = ...)]` is not a valid attribute\n   --> $DIR/diagnostic-derive.rs:231:18\n@@ -297,7 +297,7 @@ LL |     #[suggestion(msg = \"bar\")]\n error: wrong field type for suggestion\n   --> $DIR/diagnostic-derive.rs:263:5\n    |\n-LL | /     #[suggestion(typeck::suggestion, code = \"This is suggested code\")]\n+LL | /     #[suggestion(compiletest::suggestion, code = \"This is suggested code\")]\n LL | |\n LL | |     suggestion: Applicability,\n    | |_____________________________^\n@@ -335,10 +335,10 @@ LL |     #[label = \"bar\"]\n    |     ^^^^^^^^^^^^^^^^\n \n error: specified multiple times\n-  --> $DIR/diagnostic-derive.rs:445:52\n+  --> $DIR/diagnostic-derive.rs:445:57\n    |\n-LL |     #[suggestion(typeck::suggestion, code = \"...\", applicability = \"maybe-incorrect\")]\n-   |                                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     #[suggestion(compiletest::suggestion, code = \"...\", applicability = \"maybe-incorrect\")]\n+   |                                                         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n note: previously specified here\n   --> $DIR/diagnostic-derive.rs:447:24\n@@ -347,30 +347,30 @@ LL |     suggestion: (Span, Applicability),\n    |                        ^^^^^^^^^^^^^\n \n error: invalid applicability\n-  --> $DIR/diagnostic-derive.rs:453:52\n+  --> $DIR/diagnostic-derive.rs:453:57\n    |\n-LL |     #[suggestion(typeck::suggestion, code = \"...\", applicability = \"batman\")]\n-   |                                                    ^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     #[suggestion(compiletest::suggestion, code = \"...\", applicability = \"batman\")]\n+   |                                                         ^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: `#[label(foo)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:516:28\n+  --> $DIR/diagnostic-derive.rs:516:33\n    |\n-LL |     #[label(typeck::label, foo)]\n-   |                            ^^^\n+LL |     #[label(compiletest::label, foo)]\n+   |                                 ^^^\n    |\n    = help: a diagnostic slug must be the first argument to the attribute\n \n error: `#[label(foo = ...)]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:524:28\n+  --> $DIR/diagnostic-derive.rs:524:33\n    |\n-LL |     #[label(typeck::label, foo = \"...\")]\n-   |                            ^^^^^^^^^^^\n+LL |     #[label(compiletest::label, foo = \"...\")]\n+   |                                 ^^^^^^^^^^^\n \n error: `#[label(foo(...))]` is not a valid attribute\n-  --> $DIR/diagnostic-derive.rs:532:28\n+  --> $DIR/diagnostic-derive.rs:532:33\n    |\n-LL |     #[label(typeck::label, foo(\"...\"))]\n-   |                            ^^^^^^^^^^\n+LL |     #[label(compiletest::label, foo(\"...\"))]\n+   |                                 ^^^^^^^^^^\n \n error: `#[primary_span]` is not a valid attribute\n   --> $DIR/diagnostic-derive.rs:545:5\n@@ -383,93 +383,93 @@ LL |     #[primary_span]\n error: `#[error(...)]` is not a valid attribute\n   --> $DIR/diagnostic-derive.rs:565:1\n    |\n-LL | #[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | #[error(compiletest::example, code = \"E0123\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: diagnostic slug not specified\n   --> $DIR/diagnostic-derive.rs:565:1\n    |\n-LL | / #[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+LL | / #[error(compiletest::example, code = \"E0123\")]\n LL | |\n LL | |\n LL | |\n LL | | struct ErrorAttribute {}\n    | |________________________^\n    |\n-   = help: specify the slug as the first argument to the `#[diag(...)]` attribute, such as `#[diag(typeck::example_error)]`\n+   = help: specify the slug as the first argument to the `#[diag(...)]` attribute, such as `#[diag(hir_analysis::example_error)]`\n \n error: `#[warn_(...)]` is not a valid attribute\n   --> $DIR/diagnostic-derive.rs:572:1\n    |\n-LL | #[warn_(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | #[warn_(compiletest::example, code = \"E0123\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: diagnostic slug not specified\n   --> $DIR/diagnostic-derive.rs:572:1\n    |\n-LL | / #[warn_(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+LL | / #[warn_(compiletest::example, code = \"E0123\")]\n LL | |\n LL | |\n LL | |\n LL | | struct WarnAttribute {}\n    | |_______________________^\n    |\n-   = help: specify the slug as the first argument to the `#[diag(...)]` attribute, such as `#[diag(typeck::example_error)]`\n+   = help: specify the slug as the first argument to the `#[diag(...)]` attribute, such as `#[diag(hir_analysis::example_error)]`\n \n error: `#[lint(...)]` is not a valid attribute\n   --> $DIR/diagnostic-derive.rs:579:1\n    |\n-LL | #[lint(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | #[lint(compiletest::example, code = \"E0123\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: diagnostic slug not specified\n   --> $DIR/diagnostic-derive.rs:579:1\n    |\n-LL | / #[lint(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+LL | / #[lint(compiletest::example, code = \"E0123\")]\n LL | |\n LL | |\n LL | |\n LL | | struct LintAttributeOnSessionDiag {}\n    | |____________________________________^\n    |\n-   = help: specify the slug as the first argument to the `#[diag(...)]` attribute, such as `#[diag(typeck::example_error)]`\n+   = help: specify the slug as the first argument to the `#[diag(...)]` attribute, such as `#[diag(hir_analysis::example_error)]`\n \n error: `#[lint(...)]` is not a valid attribute\n   --> $DIR/diagnostic-derive.rs:586:1\n    |\n-LL | #[lint(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | #[lint(compiletest::example, code = \"E0123\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: `#[lint(...)]` is not a valid attribute\n   --> $DIR/diagnostic-derive.rs:586:1\n    |\n-LL | #[lint(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | #[lint(compiletest::example, code = \"E0123\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: diagnostic slug not specified\n   --> $DIR/diagnostic-derive.rs:586:1\n    |\n-LL | / #[lint(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+LL | / #[lint(compiletest::example, code = \"E0123\")]\n LL | |\n LL | |\n LL | |\n LL | |\n LL | | struct LintAttributeOnLintDiag {}\n    | |_________________________________^\n    |\n-   = help: specify the slug as the first argument to the attribute, such as `#[diag(typeck::example_error)]`\n+   = help: specify the slug as the first argument to the attribute, such as `#[diag(compiletest::example)]`\n \n error: specified multiple times\n-  --> $DIR/diagnostic-derive.rs:596:52\n+  --> $DIR/diagnostic-derive.rs:596:57\n    |\n-LL |     #[suggestion(typeck::suggestion, code = \"...\", code = \",,,\")]\n-   |                                                    ^^^^^^^^^^^^\n+LL |     #[suggestion(compiletest::suggestion, code = \"...\", code = \",,,\")]\n+   |                                                         ^^^^^^^^^^^^\n    |\n note: previously specified here\n-  --> $DIR/diagnostic-derive.rs:596:38\n+  --> $DIR/diagnostic-derive.rs:596:43\n    |\n-LL |     #[suggestion(typeck::suggestion, code = \"...\", code = \",,,\")]\n-   |                                      ^^^^^^^^^^^^\n+LL |     #[suggestion(compiletest::suggestion, code = \"...\", code = \",,,\")]\n+   |                                           ^^^^^^^^^^^^\n \n error: wrong types for suggestion\n   --> $DIR/diagnostic-derive.rs:605:24\n@@ -490,14 +490,14 @@ LL |     suggestion: (Span,),\n error: suggestion without `code = \"...\"`\n   --> $DIR/diagnostic-derive.rs:620:5\n    |\n-LL |     #[suggestion(typeck::suggestion)]\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     #[suggestion(compiletest::suggestion)]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error: `#[multipart_suggestion(...)]` is not a valid attribute\n   --> $DIR/diagnostic-derive.rs:627:1\n    |\n-LL | #[multipart_suggestion(typeck::suggestion)]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | #[multipart_suggestion(compiletest::suggestion)]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: consider creating a `Subdiagnostic` instead\n \n@@ -512,16 +512,16 @@ LL | #[multipart_suggestion()]\n error: `#[multipart_suggestion(...)]` is not a valid attribute\n   --> $DIR/diagnostic-derive.rs:634:5\n    |\n-LL |     #[multipart_suggestion(typeck::suggestion)]\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL |     #[multipart_suggestion(compiletest::suggestion)]\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: consider creating a `Subdiagnostic` instead\n \n error: `#[suggestion(...)]` is not a valid attribute\n   --> $DIR/diagnostic-derive.rs:642:1\n    |\n-LL | #[suggestion(typeck::suggestion, code = \"...\")]\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+LL | #[suggestion(compiletest::suggestion, code = \"...\")]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: `#[label]` and `#[suggestion]` can only be applied to fields\n \n@@ -536,7 +536,7 @@ LL | #[label]\n error: cannot find attribute `nonsense` in this scope\n   --> $DIR/diagnostic-derive.rs:55:3\n    |\n-LL | #[nonsense(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+LL | #[nonsense(compiletest::example, code = \"E0123\")]\n    |   ^^^^^^^^\n \n error: cannot find attribute `nonsense` in this scope\n@@ -548,31 +548,31 @@ LL |     #[nonsense]\n error: cannot find attribute `error` in this scope\n   --> $DIR/diagnostic-derive.rs:565:3\n    |\n-LL | #[error(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+LL | #[error(compiletest::example, code = \"E0123\")]\n    |   ^^^^^\n \n error: cannot find attribute `warn_` in this scope\n   --> $DIR/diagnostic-derive.rs:572:3\n    |\n-LL | #[warn_(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+LL | #[warn_(compiletest::example, code = \"E0123\")]\n    |   ^^^^^ help: a built-in attribute with a similar name exists: `warn`\n \n error: cannot find attribute `lint` in this scope\n   --> $DIR/diagnostic-derive.rs:579:3\n    |\n-LL | #[lint(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+LL | #[lint(compiletest::example, code = \"E0123\")]\n    |   ^^^^ help: a built-in attribute with a similar name exists: `link`\n \n error: cannot find attribute `lint` in this scope\n   --> $DIR/diagnostic-derive.rs:586:3\n    |\n-LL | #[lint(typeck::ambiguous_lifetime_bound, code = \"E0123\")]\n+LL | #[lint(compiletest::example, code = \"E0123\")]\n    |   ^^^^ help: a built-in attribute with a similar name exists: `link`\n \n error: cannot find attribute `multipart_suggestion` in this scope\n   --> $DIR/diagnostic-derive.rs:627:3\n    |\n-LL | #[multipart_suggestion(typeck::suggestion)]\n+LL | #[multipart_suggestion(compiletest::suggestion)]\n    |   ^^^^^^^^^^^^^^^^^^^^\n \n error: cannot find attribute `multipart_suggestion` in this scope\n@@ -584,7 +584,7 @@ LL | #[multipart_suggestion()]\n error: cannot find attribute `multipart_suggestion` in this scope\n   --> $DIR/diagnostic-derive.rs:634:7\n    |\n-LL |     #[multipart_suggestion(typeck::suggestion)]\n+LL |     #[multipart_suggestion(compiletest::suggestion)]\n    |       ^^^^^^^^^^^^^^^^^^^^\n \n error[E0425]: cannot find value `nonsense` in module `rustc_errors::fluent`"}]}