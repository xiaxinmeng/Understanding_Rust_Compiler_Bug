{"sha": "62c0501be8a0fa5e511a45ed9ffbcef42094e9ad", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYyYzA1MDFiZThhMGZhNWU1MTFhNDVlZDlmZmJjZWY0MjA5NGU5YWQ=", "commit": {"author": {"name": "Oliver Schneider", "email": "git-no-reply-9879165716479413131@oli-obk.de", "date": "2018-04-10T14:25:10Z"}, "committer": {"name": "Oliver Schneider", "email": "git-no-reply-9879165716479413131@oli-obk.de", "date": "2018-04-14T10:21:46Z"}, "message": "Stop referring to statics' AllocIds directly", "tree": {"sha": "3b7ba3361a893581ef4905545903fbd88c765266", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3b7ba3361a893581ef4905545903fbd88c765266"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/62c0501be8a0fa5e511a45ed9ffbcef42094e9ad", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQJgBAABCgBKFiEEvpMjxK4/cnPNfesJHVy0/Fl8MAQFAlrR1josHGdpdC1uby1y\nZXBseS05ODc5MTY1NzE2NDc5NDEzMTMxQG9saS1vYmsuZGUACgkQHVy0/Fl8MASc\nng//fOL4Of4/SBzWUiP1IBf8482KzGwE2JG2oEToXhIfj6J3zUd+9KaQjk7jEHv1\nlztI/5i8YzeOQmwNjL/8bQOMO4ZheWpArH429hVyNWZfBxVQw4iLuoJ6+nyLQLVh\nloLMYits9CdyizFTcEludpcuJ+iVkWd/JkBAt/nT9QR59SJyZbuaIbxBi4hR1cYx\nKehamEPIkVGAEv7ncMPmkW9xqE9dgoL4/BziDKBLFfUuHk16ZX4LML40QwcUbsYS\nosBq2KVqkY6NnUdRysjy9XL+T4U67oLCR6YeI9SGGZkEAwgBHq/ah/VzlO7dVq24\nFLLmn9kVOkru76M+P2ub+E7e91/KqZEAHRCbfLQweRILr2c06ZqrsWTA45sZZrNm\nbicETsniFAcKi+MgBxAb38rad40f04ilXHpOo4baK76BpH66mnCScUYoTd45bac8\nBVVnQMVOqyzS7fEuwB2VFCXqIznrt+EqcBFFsAxfaW5vxcOSNw30M3NZdCAnlyIG\n5XZ1jixfOC/WEkHXxJDnG9Z8QRE2Wp900kEAqxTu95Uh9P79Tz5YIWPpBgy+grey\nRwNLn6pkqh4c2LIlnAMNU6bDO9kXTqwjKXd15/bzcur0Yv5ELc60bFgUrg5RGAFS\nCKPEdM1o8SWQ0+ipoqS9TN8qPkoST1MLD9rh5ckVuqzUIuQ=\n=aJZz\n-----END PGP SIGNATURE-----", "payload": "tree 3b7ba3361a893581ef4905545903fbd88c765266\nparent a67ded06a36b7d758a63d15f0a4c59b9f678f14c\nauthor Oliver Schneider <git-no-reply-9879165716479413131@oli-obk.de> 1523370310 +0200\ncommitter Oliver Schneider <git-no-reply-9879165716479413131@oli-obk.de> 1523701306 +0200\n\nStop referring to statics' AllocIds directly\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/62c0501be8a0fa5e511a45ed9ffbcef42094e9ad", "html_url": "https://github.com/rust-lang/rust/commit/62c0501be8a0fa5e511a45ed9ffbcef42094e9ad", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/62c0501be8a0fa5e511a45ed9ffbcef42094e9ad/comments", "author": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "committer": {"login": "oli-obk", "id": 332036, "node_id": "MDQ6VXNlcjMzMjAzNg==", "avatar_url": "https://avatars.githubusercontent.com/u/332036?v=4", "gravatar_id": "", "url": "https://api.github.com/users/oli-obk", "html_url": "https://github.com/oli-obk", "followers_url": "https://api.github.com/users/oli-obk/followers", "following_url": "https://api.github.com/users/oli-obk/following{/other_user}", "gists_url": "https://api.github.com/users/oli-obk/gists{/gist_id}", "starred_url": "https://api.github.com/users/oli-obk/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/oli-obk/subscriptions", "organizations_url": "https://api.github.com/users/oli-obk/orgs", "repos_url": "https://api.github.com/users/oli-obk/repos", "events_url": "https://api.github.com/users/oli-obk/events{/privacy}", "received_events_url": "https://api.github.com/users/oli-obk/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a67ded06a36b7d758a63d15f0a4c59b9f678f14c", "url": "https://api.github.com/repos/rust-lang/rust/commits/a67ded06a36b7d758a63d15f0a4c59b9f678f14c", "html_url": "https://github.com/rust-lang/rust/commit/a67ded06a36b7d758a63d15f0a4c59b9f678f14c"}], "stats": {"total": 230, "additions": 68, "deletions": 162}, "files": [{"sha": "99ac5869b2969fbf0675edc7efc997cf0e21e04e", "filename": "src/librustc/ich/impls_ty.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/62c0501be8a0fa5e511a45ed9ffbcef42094e9ad/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62c0501be8a0fa5e511a45ed9ffbcef42094e9ad/src%2Flibrustc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_ty.rs?ref=62c0501be8a0fa5e511a45ed9ffbcef42094e9ad", "patch": "@@ -416,8 +416,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for mir::interpret::AllocId {\n         ty::tls::with_opt(|tcx| {\n             trace!(\"hashing {:?}\", *self);\n             let tcx = tcx.expect(\"can't hash AllocIds during hir lowering\");\n-            if let Some(def_id) = tcx.interpret_interner\n-                                     .get_corresponding_static_def_id(*self) {\n+            if let Some(def_id) = tcx.interpret_interner.get_static(*self) {\n                 AllocDiscriminant::Static.hash_stable(hcx, hasher);\n                 trace!(\"hashing {:?} as static {:?}\", *self, def_id);\n                 def_id.hash_stable(hcx, hasher);"}, {"sha": "07768ac3a3b976ef0293b5aee9aea125db614030", "filename": "src/librustc/mir/interpret/mod.rs", "status": "modified", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/62c0501be8a0fa5e511a45ed9ffbcef42094e9ad/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62c0501be8a0fa5e511a45ed9ffbcef42094e9ad/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Finterpret%2Fmod.rs?ref=62c0501be8a0fa5e511a45ed9ffbcef42094e9ad", "patch": "@@ -158,7 +158,7 @@ impl ::rustc_serialize::UseSpecializedDecodable for AllocId {}\n enum AllocKind {\n     Alloc,\n     Fn,\n-    ExternStatic,\n+    Static,\n }\n \n pub fn specialized_encode_alloc_id<\n@@ -173,17 +173,13 @@ pub fn specialized_encode_alloc_id<\n         trace!(\"encoding {:?} with {:#?}\", alloc_id, alloc);\n         AllocKind::Alloc.encode(encoder)?;\n         alloc.encode(encoder)?;\n-        // encode whether this allocation is the root allocation of a static\n-        tcx.interpret_interner\n-            .get_corresponding_static_def_id(alloc_id)\n-            .encode(encoder)?;\n     } else if let Some(fn_instance) = tcx.interpret_interner.get_fn(alloc_id) {\n         trace!(\"encoding {:?} with {:#?}\", alloc_id, fn_instance);\n         AllocKind::Fn.encode(encoder)?;\n         fn_instance.encode(encoder)?;\n-    } else if let Some(did) = tcx.interpret_interner.get_corresponding_static_def_id(alloc_id) {\n-        // extern \"C\" statics don't have allocations, just encode its def_id\n-        AllocKind::ExternStatic.encode(encoder)?;\n+    } else if let Some(did) = tcx.interpret_interner.get_static(alloc_id) {\n+        // referring to statics doesn't need to know about their allocations, just hash the DefId\n+        AllocKind::Static.encode(encoder)?;\n         did.encode(encoder)?;\n     } else {\n         bug!(\"alloc id without corresponding allocation: {}\", alloc_id);\n@@ -212,10 +208,6 @@ pub fn specialized_decode_alloc_id<\n             let allocation = tcx.intern_const_alloc(allocation);\n             tcx.interpret_interner.intern_at_reserved(alloc_id, allocation);\n \n-            if let Some(glob) = Option::<DefId>::decode(decoder)? {\n-                tcx.interpret_interner.cache(glob, alloc_id);\n-            }\n-\n             Ok(alloc_id)\n         },\n         AllocKind::Fn => {\n@@ -227,12 +219,11 @@ pub fn specialized_decode_alloc_id<\n             cache(decoder, id);\n             Ok(id)\n         },\n-        AllocKind::ExternStatic => {\n+        AllocKind::Static => {\n             trace!(\"creating extern static alloc id at\");\n             let did = DefId::decode(decoder)?;\n-            let alloc_id = tcx.interpret_interner.reserve();\n+            let alloc_id = tcx.interpret_interner.cache_static(did);\n             cache(decoder, alloc_id);\n-            tcx.interpret_interner.cache(did, alloc_id);\n             Ok(alloc_id)\n         },\n     }"}, {"sha": "ed3332f32d02fd4648a4611086b25276fd0189a9", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 16, "deletions": 23, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/62c0501be8a0fa5e511a45ed9ffbcef42094e9ad/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62c0501be8a0fa5e511a45ed9ffbcef42094e9ad/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=62c0501be8a0fa5e511a45ed9ffbcef42094e9ad", "patch": "@@ -956,18 +956,16 @@ struct InterpretInternerInner<'tcx> {\n     /// Allows obtaining const allocs via a unique identifier\n     alloc_by_id: FxHashMap<interpret::AllocId, &'tcx interpret::Allocation>,\n \n-    /// Reverse map of `alloc_cache`\n-    global_cache: FxHashMap<interpret::AllocId, DefId>,\n+    /// Allows obtaining static def ids via a unique id\n+    statics: FxHashMap<interpret::AllocId, DefId>,\n \n     /// The AllocId to assign to the next new regular allocation.\n     /// Always incremented, never gets smaller.\n     next_id: interpret::AllocId,\n \n-    /// Allows checking whether a static already has an allocation\n-    ///\n-    /// This is only important for detecting statics referring to themselves\n-    // FIXME(oli-obk) move it to the EvalContext?\n-    alloc_cache: FxHashMap<DefId, interpret::AllocId>,\n+    /// Inverse map of `statics`\n+    /// Used so we don't allocate a new pointer every time we need one\n+    static_cache: FxHashMap<DefId, interpret::AllocId>,\n \n     /// A cache for basic byte allocations keyed by their contents. This is used to deduplicate\n     /// allocations for string and bytestring literals.\n@@ -1001,30 +999,25 @@ impl<'tcx> InterpretInterner<'tcx> {\n         self.inner.borrow().alloc_by_id.get(&id).cloned()\n     }\n \n-    pub fn get_cached(\n-        &self,\n-        static_id: DefId,\n-    ) -> Option<interpret::AllocId> {\n-        self.inner.borrow().alloc_cache.get(&static_id).cloned()\n-    }\n-\n-    pub fn cache(\n+    pub fn cache_static(\n         &self,\n         static_id: DefId,\n-        alloc_id: interpret::AllocId,\n-    ) {\n-        let mut inner = self.inner.borrow_mut();\n-        inner.global_cache.insert(alloc_id, static_id);\n-        if let Some(old) = inner.alloc_cache.insert(static_id, alloc_id) {\n-            bug!(\"tried to cache {:?}, but was already existing as {:#?}\", static_id, old);\n+    ) -> interpret::AllocId {\n+        if let Some(alloc_id) = self.inner.borrow().static_cache.get(&static_id).cloned() {\n+            return alloc_id;\n         }\n+        let alloc_id = self.reserve();\n+        let mut inner = self.inner.borrow_mut();\n+        inner.static_cache.insert(static_id, alloc_id);\n+        inner.statics.insert(alloc_id, static_id);\n+        alloc_id\n     }\n \n-    pub fn get_corresponding_static_def_id(\n+    pub fn get_static(\n         &self,\n         ptr: interpret::AllocId,\n     ) -> Option<DefId> {\n-        self.inner.borrow().global_cache.get(&ptr).cloned()\n+        self.inner.borrow().statics.get(&ptr).cloned()\n     }\n \n     pub fn intern_at_reserved("}, {"sha": "954a3dbe5b9ab0e78224cb1a508925810b4606a5", "filename": "src/librustc_mir/interpret/const_eval.rs", "status": "modified", "additions": 31, "deletions": 105, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/62c0501be8a0fa5e511a45ed9ffbcef42094e9ad/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62c0501be8a0fa5e511a45ed9ffbcef42094e9ad/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fconst_eval.rs?ref=62c0501be8a0fa5e511a45ed9ffbcef42094e9ad", "patch": "@@ -5,7 +5,6 @@ use rustc::mir;\n use rustc::ty::{self, TyCtxt, Ty, Instance};\n use rustc::ty::layout::{self, LayoutOf};\n use rustc::ty::subst::Subst;\n-use rustc::util::nodemap::FxHashSet;\n \n use syntax::ast::Mutability;\n use syntax::codemap::Span;\n@@ -110,53 +109,38 @@ fn eval_body_and_ecx<'a, 'mir, 'tcx>(\n         }\n         span = mir.span;\n         let layout = ecx.layout_of(mir.return_ty().subst(tcx, cid.instance.substs))?;\n-        let alloc = tcx.interpret_interner.get_cached(cid.instance.def_id());\n-        let is_static = tcx.is_static(cid.instance.def_id()).is_some();\n-        let alloc = match alloc {\n-            Some(alloc) => {\n-                assert!(cid.promoted.is_none());\n-                assert!(param_env.caller_bounds.is_empty());\n-                alloc\n-            },\n-            None => {\n-                assert!(!layout.is_unsized());\n-                let ptr = ecx.memory.allocate(\n-                    layout.size.bytes(),\n-                    layout.align,\n-                    None,\n-                )?;\n-                if is_static {\n-                    tcx.interpret_interner.cache(cid.instance.def_id(), ptr.alloc_id);\n-                }\n-                let internally_mutable = !layout.ty.is_freeze(tcx, param_env, mir.span);\n-                let mutability = tcx.is_static(cid.instance.def_id());\n-                let mutability = if mutability == Some(hir::Mutability::MutMutable) || internally_mutable {\n-                    Mutability::Mutable\n-                } else {\n-                    Mutability::Immutable\n-                };\n-                let cleanup = StackPopCleanup::MarkStatic(mutability);\n-                let name = ty::tls::with(|tcx| tcx.item_path_str(cid.instance.def_id()));\n-                let prom = cid.promoted.map_or(String::new(), |p| format!(\"::promoted[{:?}]\", p));\n-                trace!(\"const_eval: pushing stack frame for global: {}{}\", name, prom);\n-                assert!(mir.arg_count == 0);\n-                ecx.push_stack_frame(\n-                    cid.instance,\n-                    mir.span,\n-                    mir,\n-                    Place::from_ptr(ptr, layout.align),\n-                    cleanup,\n-                )?;\n-\n-                while ecx.step()? {}\n-                ptr.alloc_id\n-            }\n+        assert!(!layout.is_unsized());\n+        let ptr = ecx.memory.allocate(\n+            layout.size.bytes(),\n+            layout.align,\n+            None,\n+        )?;\n+        let internally_mutable = !layout.ty.is_freeze(tcx, param_env, mir.span);\n+        let mutability = tcx.is_static(cid.instance.def_id());\n+        let mutability = if mutability == Some(hir::Mutability::MutMutable) || internally_mutable {\n+            Mutability::Mutable\n+        } else {\n+            Mutability::Immutable\n         };\n-        let ptr = MemoryPointer::new(alloc, 0).into();\n+        let cleanup = StackPopCleanup::MarkStatic(mutability);\n+        let name = ty::tls::with(|tcx| tcx.item_path_str(cid.instance.def_id()));\n+        let prom = cid.promoted.map_or(String::new(), |p| format!(\"::promoted[{:?}]\", p));\n+        trace!(\"const_eval: pushing stack frame for global: {}{}\", name, prom);\n+        assert!(mir.arg_count == 0);\n+        ecx.push_stack_frame(\n+            cid.instance,\n+            mir.span,\n+            mir,\n+            Place::from_ptr(ptr, layout.align),\n+            cleanup,\n+        )?;\n+\n+        while ecx.step()? {}\n+        let ptr = ptr.into();\n         // always try to read the value and report errors\n         let value = match ecx.try_read_value(ptr, layout.align, layout.ty)? {\n             // if it's a constant (so it needs no address, directly compute its value)\n-            Some(val) if !is_static => val,\n+            Some(val) if tcx.is_static(cid.instance.def_id()).is_none() => val,\n             // point at the allocation\n             _ => Value::ByRef(ptr, layout.align),\n         };\n@@ -340,21 +324,10 @@ impl<'mir, 'tcx> super::Machine<'mir, 'tcx> for CompileTimeEvaluator {\n         ecx: &mut EvalContext<'a, 'mir, 'tcx, Self>,\n         cid: GlobalId<'tcx>,\n     ) -> EvalResult<'tcx, AllocId> {\n-        let alloc = ecx\n-                    .tcx\n-                    .interpret_interner\n-                    .get_cached(cid.instance.def_id());\n-        // Don't evaluate when already cached to prevent cycles\n-        if let Some(alloc) = alloc {\n-            return Ok(alloc)\n-        }\n-        // ensure the static is computed\n-        ecx.const_eval(cid)?;\n         Ok(ecx\n             .tcx\n             .interpret_interner\n-            .get_cached(cid.instance.def_id())\n-            .expect(\"uncached static\"))\n+            .cache_static(cid.instance.def_id()))\n     }\n \n     fn box_alloc<'a>(\n@@ -460,16 +433,7 @@ pub fn const_eval_provider<'a, 'tcx>(\n     let def_id = cid.instance.def.def_id();\n \n     if tcx.is_foreign_item(def_id) {\n-        let id = tcx.interpret_interner.get_cached(def_id);\n-        let id = match id {\n-            // FIXME: due to caches this shouldn't happen, add some assertions\n-            Some(id) => id,\n-            None => {\n-                let id = tcx.interpret_interner.reserve();\n-                tcx.interpret_interner.cache(def_id, id);\n-                id\n-            },\n-        };\n+        let id = tcx.interpret_interner.cache_static(def_id);\n         let ty = tcx.type_of(def_id);\n         let layout = tcx.layout_of(key.param_env.and(ty)).unwrap();\n         let ptr = MemoryPointer::new(id, 0);\n@@ -505,13 +469,7 @@ pub fn const_eval_provider<'a, 'tcx>(\n     };\n \n     let (res, ecx) = eval_body_and_ecx(tcx, cid, None, key.param_env);\n-    res.map(|(miri_value, ptr, miri_ty)| {\n-        if tcx.is_static(def_id).is_some() {\n-            if let Ok(ptr) = ptr.primval.to_ptr() {\n-                let mut seen = FxHashSet::default();\n-                create_depgraph_edges(tcx, ptr.alloc_id, &mut seen);\n-            }\n-        }\n+    res.map(|(miri_value, _, miri_ty)| {\n         tcx.mk_const(ty::Const {\n             val: ConstVal::Value(miri_value),\n             ty: miri_ty,\n@@ -528,35 +486,3 @@ pub fn const_eval_provider<'a, 'tcx>(\n         }\n     })\n }\n-\n-// This function creates dep graph edges from statics to all referred to statics.\n-// This is necessary, because the `const_eval` query cannot directly call itself\n-// for other statics, because we cannot prevent recursion in queries.\n-//\n-// see test/incremental/static_refering_to_other_static2/issue.rs for an example\n-// where not creating those edges would cause static A, which refers to static B\n-// to point to the old allocation of static B, even though B has changed.\n-//\n-// In the future we will want to remove this funcion in favour of a system that\n-// makes sure that statics don't need to have edges to other statics as long as\n-// they are only referring by reference and not inspecting the other static's body.\n-fn create_depgraph_edges<'a, 'tcx>(\n-    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-    alloc_id: AllocId,\n-    seen: &mut FxHashSet<AllocId>,\n-) {\n-    trace!(\"create_depgraph_edges: {:?}, {:?}\", alloc_id, seen);\n-    if seen.insert(alloc_id) {\n-        trace!(\"seen: {:?}, {:?}\", alloc_id, seen);\n-        if let Some(alloc) = tcx.interpret_interner.get_alloc(alloc_id) {\n-            trace!(\"get_alloc: {:?}, {:?}, {:?}\", alloc_id, seen, alloc);\n-            for (_, &reloc) in &alloc.relocations {\n-                if let Some(did) = tcx.interpret_interner.get_corresponding_static_def_id(reloc) {\n-                    trace!(\"get_corresponding: {:?}, {:?}, {:?}, {:?}, {:?}\", alloc_id, seen, alloc, did, reloc);\n-                    let _ = tcx.maybe_optimized_mir(did);\n-                }\n-                create_depgraph_edges(tcx, reloc, seen);\n-            }\n-        }\n-    }\n-}"}, {"sha": "158d674580b530c954fca19005863b9b6c9ba1be", "filename": "src/librustc_mir/interpret/eval_context.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/62c0501be8a0fa5e511a45ed9ffbcef42094e9ad/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62c0501be8a0fa5e511a45ed9ffbcef42094e9ad/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Feval_context.rs?ref=62c0501be8a0fa5e511a45ed9ffbcef42094e9ad", "patch": "@@ -938,16 +938,14 @@ impl<'a, 'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M\n     }\n \n     pub fn read_global_as_value(&self, gid: GlobalId<'tcx>, ty: Ty<'tcx>) -> EvalResult<'tcx, Value> {\n-        if gid.promoted.is_none() {\n-            let cached = self\n+        if self.tcx.is_static(gid.instance.def_id()).is_some() {\n+            let alloc_id = self\n                 .tcx\n                 .interpret_interner\n-                .get_cached(gid.instance.def_id());\n-            if let Some(alloc_id) = cached {\n-                let layout = self.layout_of(ty)?;\n-                let ptr = MemoryPointer::new(alloc_id, 0);\n-                return Ok(Value::ByRef(ptr.into(), layout.align))\n-            }\n+                .cache_static(gid.instance.def_id());\n+            let layout = self.layout_of(ty)?;\n+            let ptr = MemoryPointer::new(alloc_id, 0);\n+            return Ok(Value::ByRef(ptr.into(), layout.align))\n         }\n         let cv = self.const_eval(gid)?;\n         self.const_to_value(&cv.val, ty)"}, {"sha": "008165f33b2bbc69f23fffa1c9a7aac0ae907c5b", "filename": "src/librustc_mir/monomorphize/collector.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/62c0501be8a0fa5e511a45ed9ffbcef42094e9ad/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62c0501be8a0fa5e511a45ed9ffbcef42094e9ad/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fmonomorphize%2Fcollector.rs?ref=62c0501be8a0fa5e511a45ed9ffbcef42094e9ad", "patch": "@@ -1142,7 +1142,7 @@ fn collect_miri<'a, 'tcx>(\n     alloc_id: AllocId,\n     output: &mut Vec<MonoItem<'tcx>>,\n ) {\n-    if let Some(did) = tcx.interpret_interner.get_corresponding_static_def_id(alloc_id) {\n+    if let Some(did) = tcx.interpret_interner.get_static(alloc_id) {\n         let instance = Instance::mono(tcx, did);\n         if should_monomorphize_locally(tcx, &instance) {\n             trace!(\"collecting static {:?}\", did);"}, {"sha": "6e07b8e73ef22c329ea9c8749ede3d649ae14667", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/62c0501be8a0fa5e511a45ed9ffbcef42094e9ad/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/62c0501be8a0fa5e511a45ed9ffbcef42094e9ad/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=62c0501be8a0fa5e511a45ed9ffbcef42094e9ad", "patch": "@@ -50,7 +50,7 @@ pub fn primval_to_llvm(cx: &CodegenCx,\n                 let static_ = cx\n                     .tcx\n                     .interpret_interner\n-                    .get_corresponding_static_def_id(ptr.alloc_id);\n+                    .get_static(ptr.alloc_id);\n                 let base_addr = if let Some(def_id) = static_ {\n                     assert!(cx.tcx.is_static(def_id).is_some());\n                     consts::get_static(cx, def_id)\n@@ -126,18 +126,17 @@ pub fn trans_static_initializer<'a, 'tcx>(\n         promoted: None\n     };\n     let param_env = ty::ParamEnv::reveal_all();\n-    cx.tcx.const_eval(param_env.and(cid))?;\n+    let static_ = cx.tcx.const_eval(param_env.and(cid))?;\n \n-    let alloc_id = cx\n-        .tcx\n-        .interpret_interner\n-        .get_cached(def_id)\n-        .expect(\"global not cached\");\n+    let ptr = match static_.val {\n+        ConstVal::Value(MiriValue::ByRef(ptr, _)) => ptr,\n+        _ => bug!(\"static const eval returned {:#?}\", static_),\n+    };\n \n     let alloc = cx\n         .tcx\n         .interpret_interner\n-        .get_alloc(alloc_id)\n+        .get_alloc(ptr.primval.to_ptr().expect(\"static has integer pointer\").alloc_id)\n         .expect(\"miri allocation never successfully created\");\n     Ok(global_initializer(cx, alloc))\n }"}]}