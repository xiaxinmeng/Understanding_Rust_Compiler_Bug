{"sha": "98075708dde5b75e69d3294783c1f6abf5236dba", "node_id": "C_kwDOAAsO6NoAKDk4MDc1NzA4ZGRlNWI3NWU2OWQzMjk0NzgzYzFmNmFiZjUyMzZkYmE", "commit": {"author": {"name": "Michael Howell", "email": "michael@notriddle.com", "date": "2022-09-29T17:15:20Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-09-29T17:15:20Z"}, "message": "Rollup merge of #102476 - oli-obk:split_error_path, r=cjgillot\n\nSplit out the error reporting logic into a separate function\n\nI was trying to read the function and got distracted by the huge block of code in the middle of it. Turns out it only reports diagnostics and all paths within it end in an error. The main function is now more readable imo.", "tree": {"sha": "28d6b78e3c1620cd187e8109b118cc46e3e9b047", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/28d6b78e3c1620cd187e8109b118cc46e3e9b047"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/98075708dde5b75e69d3294783c1f6abf5236dba", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJjNdKoCRBK7hj4Ov3rIwAAKW0IAJkY1P7dr+J36fDwJUyIz5zQ\nulMLj3sFUvp4voiM9HigMyKotjrf2MGvsJkjwR2J+FrGvq7Fh2Bz2f+/mVVWB7YB\nkAj+cLtyzYrwYCraJZICQI1GzFbjiGg/m12NJoVZHKt06NBcWKBV4zTs9tumZ57/\nh1kKky8iFbA+u6JUsBmPk/vtG7r+rr/d49/LEpepa0L3VKKsF/dCYhEx05eaXFRJ\nl3UdGaIdis23JJunJDwT9ORTPc/lqvP+9jKYC/MWQnETlKDA2a9s5aYoNHIJ0EU3\nzBOEJ8JmwWrlHJHtxmU8snAuvyLgzOpvwfsCPCalYvpuQkS8HMPNJVOlbT/Tu0o=\n=gfBj\n-----END PGP SIGNATURE-----\n", "payload": "tree 28d6b78e3c1620cd187e8109b118cc46e3e9b047\nparent af33587fc5f603deb774cdf2b3aab5d5337f3467\nparent aa3fbf87950ed764f91222be2f7ec0fc1e9b1c91\nauthor Michael Howell <michael@notriddle.com> 1664471720 -0700\ncommitter GitHub <noreply@github.com> 1664471720 -0700\n\nRollup merge of #102476 - oli-obk:split_error_path, r=cjgillot\n\nSplit out the error reporting logic into a separate function\n\nI was trying to read the function and got distracted by the huge block of code in the middle of it. Turns out it only reports diagnostics and all paths within it end in an error. The main function is now more readable imo.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/98075708dde5b75e69d3294783c1f6abf5236dba", "html_url": "https://github.com/rust-lang/rust/commit/98075708dde5b75e69d3294783c1f6abf5236dba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/98075708dde5b75e69d3294783c1f6abf5236dba/comments", "author": {"login": "notriddle", "id": 1593513, "node_id": "MDQ6VXNlcjE1OTM1MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1593513?v=4", "gravatar_id": "", "url": "https://api.github.com/users/notriddle", "html_url": "https://github.com/notriddle", "followers_url": "https://api.github.com/users/notriddle/followers", "following_url": "https://api.github.com/users/notriddle/following{/other_user}", "gists_url": "https://api.github.com/users/notriddle/gists{/gist_id}", "starred_url": "https://api.github.com/users/notriddle/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/notriddle/subscriptions", "organizations_url": "https://api.github.com/users/notriddle/orgs", "repos_url": "https://api.github.com/users/notriddle/repos", "events_url": "https://api.github.com/users/notriddle/events{/privacy}", "received_events_url": "https://api.github.com/users/notriddle/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "af33587fc5f603deb774cdf2b3aab5d5337f3467", "url": "https://api.github.com/repos/rust-lang/rust/commits/af33587fc5f603deb774cdf2b3aab5d5337f3467", "html_url": "https://github.com/rust-lang/rust/commit/af33587fc5f603deb774cdf2b3aab5d5337f3467"}, {"sha": "aa3fbf87950ed764f91222be2f7ec0fc1e9b1c91", "url": "https://api.github.com/repos/rust-lang/rust/commits/aa3fbf87950ed764f91222be2f7ec0fc1e9b1c91", "html_url": "https://github.com/rust-lang/rust/commit/aa3fbf87950ed764f91222be2f7ec0fc1e9b1c91"}], "stats": {"total": 274, "additions": 140, "deletions": 134}, "files": [{"sha": "080771844a44c4bf40424ef95372a015f7f81d47", "filename": "compiler/rustc_hir_analysis/src/check/callee.rs", "status": "modified", "additions": 140, "deletions": 134, "changes": 274, "blob_url": "https://github.com/rust-lang/rust/blob/98075708dde5b75e69d3294783c1f6abf5236dba/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/98075708dde5b75e69d3294783c1f6abf5236dba/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fcheck%2Fcallee.rs?ref=98075708dde5b75e69d3294783c1f6abf5236dba", "patch": "@@ -394,140 +394,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             }\n             ty::FnPtr(sig) => (sig, None),\n             _ => {\n-                let mut unit_variant = None;\n-                if let hir::ExprKind::Path(qpath) = &callee_expr.kind\n-                    && let Res::Def(def::DefKind::Ctor(kind, def::CtorKind::Const), _)\n-                        = self.typeck_results.borrow().qpath_res(qpath, callee_expr.hir_id)\n-                    // Only suggest removing parens if there are no arguments\n-                    && arg_exprs.is_empty()\n-                {\n-                    let descr = match kind {\n-                        def::CtorOf::Struct => \"struct\",\n-                        def::CtorOf::Variant => \"enum variant\",\n-                    };\n-                    let removal_span =\n-                        callee_expr.span.shrink_to_hi().to(call_expr.span.shrink_to_hi());\n-                    unit_variant =\n-                        Some((removal_span, descr, rustc_hir_pretty::qpath_to_string(qpath)));\n-                }\n-\n-                let callee_ty = self.resolve_vars_if_possible(callee_ty);\n-                let mut err = type_error_struct!(\n-                    self.tcx.sess,\n-                    callee_expr.span,\n-                    callee_ty,\n-                    E0618,\n-                    \"expected function, found {}\",\n-                    match &unit_variant {\n-                        Some((_, kind, path)) => format!(\"{kind} `{path}`\"),\n-                        None => format!(\"`{callee_ty}`\"),\n-                    }\n-                );\n-\n-                self.identify_bad_closure_def_and_call(\n-                    &mut err,\n-                    call_expr.hir_id,\n-                    &callee_expr.kind,\n-                    callee_expr.span,\n-                );\n-\n-                if let Some((removal_span, kind, path)) = &unit_variant {\n-                    err.span_suggestion_verbose(\n-                        *removal_span,\n-                        &format!(\n-                            \"`{path}` is a unit {kind}, and does not take parentheses to be constructed\",\n-                        ),\n-                        \"\",\n-                        Applicability::MachineApplicable,\n-                    );\n-                }\n-\n-                let mut inner_callee_path = None;\n-                let def = match callee_expr.kind {\n-                    hir::ExprKind::Path(ref qpath) => {\n-                        self.typeck_results.borrow().qpath_res(qpath, callee_expr.hir_id)\n-                    }\n-                    hir::ExprKind::Call(ref inner_callee, _) => {\n-                        // If the call spans more than one line and the callee kind is\n-                        // itself another `ExprCall`, that's a clue that we might just be\n-                        // missing a semicolon (Issue #51055)\n-                        let call_is_multiline =\n-                            self.tcx.sess.source_map().is_multiline(call_expr.span);\n-                        if call_is_multiline {\n-                            err.span_suggestion(\n-                                callee_expr.span.shrink_to_hi(),\n-                                \"consider using a semicolon here\",\n-                                \";\",\n-                                Applicability::MaybeIncorrect,\n-                            );\n-                        }\n-                        if let hir::ExprKind::Path(ref inner_qpath) = inner_callee.kind {\n-                            inner_callee_path = Some(inner_qpath);\n-                            self.typeck_results.borrow().qpath_res(inner_qpath, inner_callee.hir_id)\n-                        } else {\n-                            Res::Err\n-                        }\n-                    }\n-                    _ => Res::Err,\n-                };\n-\n-                if !self.maybe_suggest_bad_array_definition(&mut err, call_expr, callee_expr) {\n-                    if let Some((maybe_def, output_ty, _)) = self.extract_callable_info(callee_expr, callee_ty)\n-                        && !self.type_is_sized_modulo_regions(self.param_env, output_ty, callee_expr.span)\n-                    {\n-                        let descr = match maybe_def {\n-                            DefIdOrName::DefId(def_id) => self.tcx.def_kind(def_id).descr(def_id),\n-                            DefIdOrName::Name(name) => name,\n-                        };\n-                        err.span_label(\n-                            callee_expr.span,\n-                            format!(\"this {descr} returns an unsized value `{output_ty}`, so it cannot be called\")\n-                        );\n-                        if let DefIdOrName::DefId(def_id) = maybe_def\n-                            && let Some(def_span) = self.tcx.hir().span_if_local(def_id)\n-                        {\n-                            err.span_label(def_span, \"the callable type is defined here\");\n-                        }\n-                    } else {\n-                        err.span_label(call_expr.span, \"call expression requires function\");\n-                    }\n-                }\n-\n-                if let Some(span) = self.tcx.hir().res_span(def) {\n-                    let callee_ty = callee_ty.to_string();\n-                    let label = match (unit_variant, inner_callee_path) {\n-                        (Some((_, kind, path)), _) => Some(format!(\"{kind} `{path}` defined here\")),\n-                        (_, Some(hir::QPath::Resolved(_, path))) => self\n-                            .tcx\n-                            .sess\n-                            .source_map()\n-                            .span_to_snippet(path.span)\n-                            .ok()\n-                            .map(|p| format!(\"`{p}` defined here returns `{callee_ty}`\")),\n-                        _ => {\n-                            match def {\n-                                // Emit a different diagnostic for local variables, as they are not\n-                                // type definitions themselves, but rather variables *of* that type.\n-                                Res::Local(hir_id) => Some(format!(\n-                                    \"`{}` has type `{}`\",\n-                                    self.tcx.hir().name(hir_id),\n-                                    callee_ty\n-                                )),\n-                                Res::Def(kind, def_id) if kind.ns() == Some(Namespace::ValueNS) => {\n-                                    Some(format!(\n-                                        \"`{}` defined here\",\n-                                        self.tcx.def_path_str(def_id),\n-                                    ))\n-                                }\n-                                _ => Some(format!(\"`{callee_ty}` defined here\")),\n-                            }\n-                        }\n-                    };\n-                    if let Some(label) = label {\n-                        err.span_label(span, label);\n-                    }\n-                }\n-                err.emit();\n+                self.report_invalid_callee(call_expr, callee_expr, callee_ty, arg_exprs);\n \n                 // This is the \"default\" function signature, used in case of error.\n                 // In that case, we check each argument against \"error\" in order to\n@@ -574,6 +441,145 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         fn_sig.output()\n     }\n \n+    fn report_invalid_callee(\n+        &self,\n+        call_expr: &'tcx hir::Expr<'tcx>,\n+        callee_expr: &'tcx hir::Expr<'tcx>,\n+        callee_ty: Ty<'tcx>,\n+        arg_exprs: &'tcx [hir::Expr<'tcx>],\n+    ) {\n+        let mut unit_variant = None;\n+        if let hir::ExprKind::Path(qpath) = &callee_expr.kind\n+            && let Res::Def(def::DefKind::Ctor(kind, def::CtorKind::Const), _)\n+                = self.typeck_results.borrow().qpath_res(qpath, callee_expr.hir_id)\n+            // Only suggest removing parens if there are no arguments\n+            && arg_exprs.is_empty()\n+        {\n+            let descr = match kind {\n+                def::CtorOf::Struct => \"struct\",\n+                def::CtorOf::Variant => \"enum variant\",\n+            };\n+            let removal_span =\n+                callee_expr.span.shrink_to_hi().to(call_expr.span.shrink_to_hi());\n+            unit_variant =\n+                Some((removal_span, descr, rustc_hir_pretty::qpath_to_string(qpath)));\n+        }\n+\n+        let callee_ty = self.resolve_vars_if_possible(callee_ty);\n+        let mut err = type_error_struct!(\n+            self.tcx.sess,\n+            callee_expr.span,\n+            callee_ty,\n+            E0618,\n+            \"expected function, found {}\",\n+            match &unit_variant {\n+                Some((_, kind, path)) => format!(\"{kind} `{path}`\"),\n+                None => format!(\"`{callee_ty}`\"),\n+            }\n+        );\n+\n+        self.identify_bad_closure_def_and_call(\n+            &mut err,\n+            call_expr.hir_id,\n+            &callee_expr.kind,\n+            callee_expr.span,\n+        );\n+\n+        if let Some((removal_span, kind, path)) = &unit_variant {\n+            err.span_suggestion_verbose(\n+                *removal_span,\n+                &format!(\n+                    \"`{path}` is a unit {kind}, and does not take parentheses to be constructed\",\n+                ),\n+                \"\",\n+                Applicability::MachineApplicable,\n+            );\n+        }\n+\n+        let mut inner_callee_path = None;\n+        let def = match callee_expr.kind {\n+            hir::ExprKind::Path(ref qpath) => {\n+                self.typeck_results.borrow().qpath_res(qpath, callee_expr.hir_id)\n+            }\n+            hir::ExprKind::Call(ref inner_callee, _) => {\n+                // If the call spans more than one line and the callee kind is\n+                // itself another `ExprCall`, that's a clue that we might just be\n+                // missing a semicolon (Issue #51055)\n+                let call_is_multiline = self.tcx.sess.source_map().is_multiline(call_expr.span);\n+                if call_is_multiline {\n+                    err.span_suggestion(\n+                        callee_expr.span.shrink_to_hi(),\n+                        \"consider using a semicolon here\",\n+                        \";\",\n+                        Applicability::MaybeIncorrect,\n+                    );\n+                }\n+                if let hir::ExprKind::Path(ref inner_qpath) = inner_callee.kind {\n+                    inner_callee_path = Some(inner_qpath);\n+                    self.typeck_results.borrow().qpath_res(inner_qpath, inner_callee.hir_id)\n+                } else {\n+                    Res::Err\n+                }\n+            }\n+            _ => Res::Err,\n+        };\n+\n+        if !self.maybe_suggest_bad_array_definition(&mut err, call_expr, callee_expr) {\n+            if let Some((maybe_def, output_ty, _)) = self.extract_callable_info(callee_expr, callee_ty)\n+                && !self.type_is_sized_modulo_regions(self.param_env, output_ty, callee_expr.span)\n+            {\n+                let descr = match maybe_def {\n+                    DefIdOrName::DefId(def_id) => self.tcx.def_kind(def_id).descr(def_id),\n+                    DefIdOrName::Name(name) => name,\n+                };\n+                err.span_label(\n+                    callee_expr.span,\n+                    format!(\"this {descr} returns an unsized value `{output_ty}`, so it cannot be called\")\n+                );\n+                if let DefIdOrName::DefId(def_id) = maybe_def\n+                    && let Some(def_span) = self.tcx.hir().span_if_local(def_id)\n+                {\n+                    err.span_label(def_span, \"the callable type is defined here\");\n+                }\n+            } else {\n+                err.span_label(call_expr.span, \"call expression requires function\");\n+            }\n+        }\n+\n+        if let Some(span) = self.tcx.hir().res_span(def) {\n+            let callee_ty = callee_ty.to_string();\n+            let label = match (unit_variant, inner_callee_path) {\n+                (Some((_, kind, path)), _) => Some(format!(\"{kind} `{path}` defined here\")),\n+                (_, Some(hir::QPath::Resolved(_, path))) => self\n+                    .tcx\n+                    .sess\n+                    .source_map()\n+                    .span_to_snippet(path.span)\n+                    .ok()\n+                    .map(|p| format!(\"`{p}` defined here returns `{callee_ty}`\")),\n+                _ => {\n+                    match def {\n+                        // Emit a different diagnostic for local variables, as they are not\n+                        // type definitions themselves, but rather variables *of* that type.\n+                        Res::Local(hir_id) => Some(format!(\n+                            \"`{}` has type `{}`\",\n+                            self.tcx.hir().name(hir_id),\n+                            callee_ty\n+                        )),\n+                        Res::Def(kind, def_id) if kind.ns() == Some(Namespace::ValueNS) => {\n+                            Some(format!(\"`{}` defined here\", self.tcx.def_path_str(def_id),))\n+                        }\n+                        _ => Some(format!(\"`{callee_ty}` defined here\")),\n+                    }\n+                }\n+            };\n+            if let Some(label) = label {\n+                err.span_label(span, label);\n+            }\n+        }\n+        err.emit();\n+    }\n+\n     fn confirm_deferred_closure_call(\n         &self,\n         call_expr: &'tcx hir::Expr<'tcx>,"}]}