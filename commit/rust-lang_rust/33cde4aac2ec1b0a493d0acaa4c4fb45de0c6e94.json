{"sha": "33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMzY2RlNGFhYzJlYzFiMGE0OTNkMGFjYWE0YzRmYjQ1ZGUwYzZlOTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-05-07T22:33:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-05-07T22:33:12Z"}, "message": "Auto merge of #60586 - cramertj:await, r=oli-obk\n\nImplement built-in await syntax\n\nAdds support for .await under the existing async_await feature gate.\nMoves macro-like await! syntax to the await_macro feature gate.\nRemoves support for `await` as a non-keyword under the `async_await`\nfeature.\n\nThis new syntax is not final, but is the consensus solution proposed by the lang team, as explained in https://boats.gitlab.io/blog/post/await-decision/\n\nFix https://github.com/rust-lang/rust/issues/51719\nFix https://github.com/rust-lang/rust/issues/51751\nFix https://github.com/rust-lang/rust/issues/60016", "tree": {"sha": "1f1b841623f31b379613c828f069f31f396fac57", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1f1b841623f31b379613c828f069f31f396fac57"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94", "html_url": "https://github.com/rust-lang/rust/commit/33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cfdc84a009020c59e53e4039beae22eb59e41685", "url": "https://api.github.com/repos/rust-lang/rust/commits/cfdc84a009020c59e53e4039beae22eb59e41685", "html_url": "https://github.com/rust-lang/rust/commit/cfdc84a009020c59e53e4039beae22eb59e41685"}, {"sha": "fe8760cb848d45f5c83b41e689878b893b74e45d", "url": "https://api.github.com/repos/rust-lang/rust/commits/fe8760cb848d45f5c83b41e689878b893b74e45d", "html_url": "https://github.com/rust-lang/rust/commit/fe8760cb848d45f5c83b41e689878b893b74e45d"}], "stats": {"total": 1096, "additions": 931, "deletions": 165}, "files": [{"sha": "a1bfd417566ad7473f93f8c2696af3674503aa6f", "filename": "src/librustc/error_codes.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94/src%2Flibrustc%2Ferror_codes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94/src%2Flibrustc%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ferror_codes.rs?ref=33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94", "patch": "@@ -2205,4 +2205,6 @@ register_diagnostics! {\n     E0711, // a feature has been declared with conflicting stability attributes\n //  E0702, // replaced with a generic attribute input check\n     E0726, // non-explicit (not `'_`) elided lifetime in unsupported position\n+    E0727, // `async` generators are not yet supported\n+    E0728, // `await` must be in an `async` function or block\n }"}, {"sha": "20e016b8b5b1ea59fe1bca158c679d84d0dcfe3e", "filename": "src/librustc/hir/lowering.rs", "status": "modified", "additions": 275, "deletions": 31, "changes": 306, "blob_url": "https://github.com/rust-lang/rust/blob/33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94/src%2Flibrustc%2Fhir%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94/src%2Flibrustc%2Fhir%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Flowering.rs?ref=33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94", "patch": "@@ -95,6 +95,7 @@ pub struct LoweringContext<'a> {\n     modules: BTreeMap<NodeId, hir::ModuleItems>,\n \n     is_generator: bool,\n+    is_async_body: bool,\n \n     catch_scopes: Vec<NodeId>,\n     loop_scopes: Vec<NodeId>,\n@@ -248,6 +249,7 @@ pub fn lower_crate(\n         item_local_id_counters: Default::default(),\n         node_id_to_hir_id: IndexVec::new(),\n         is_generator: false,\n+        is_async_body: false,\n         is_in_trait_impl: false,\n         lifetimes_to_define: Vec::new(),\n         is_collecting_in_band_lifetimes: false,\n@@ -801,8 +803,17 @@ impl<'a> LoweringContext<'a> {\n     }\n \n     fn record_body(&mut self, value: hir::Expr, arguments: HirVec<hir::Arg>) -> hir::BodyId {\n+        if self.is_generator && self.is_async_body {\n+            span_err!(\n+                self.sess,\n+                value.span,\n+                E0727,\n+                \"`async` generators are not yet supported\",\n+            );\n+            self.sess.abort_if_errors();\n+        }\n         let body = hir::Body {\n-            is_generator: self.is_generator,\n+            is_generator: self.is_generator || self.is_async_body,\n             arguments,\n             value,\n         };\n@@ -1124,7 +1135,8 @@ impl<'a> LoweringContext<'a> {\n         span: Span,\n         body: impl FnOnce(&mut LoweringContext<'_>) -> hir::Expr,\n     ) -> hir::ExprKind {\n-        let prev_is_generator = mem::replace(&mut self.is_generator, true);\n+        let prev_is_generator = mem::replace(&mut self.is_generator, false);\n+        let prev_is_async_body = mem::replace(&mut self.is_async_body, true);\n         let output = match ret_ty {\n             Some(ty) => FunctionRetTy::Ty(P(ty.clone())),\n             None => FunctionRetTy::Default(span),\n@@ -1140,6 +1152,7 @@ impl<'a> LoweringContext<'a> {\n         let body_expr = body(self);\n         let body_id = self.record_body(body_expr, arguments);\n         self.is_generator = prev_is_generator;\n+        self.is_async_body = prev_is_async_body;\n \n         let capture_clause = self.lower_capture_clause(capture_clause);\n         let decl = self.lower_fn_decl(&decl, None, /* impl trait allowed */ false, None);\n@@ -1167,11 +1180,13 @@ impl<'a> LoweringContext<'a> {\n     where\n         F: FnOnce(&mut LoweringContext<'_>) -> hir::Expr,\n     {\n-        let prev = mem::replace(&mut self.is_generator, false);\n+        let prev_generator = mem::replace(&mut self.is_generator, false);\n+        let prev_async = mem::replace(&mut self.is_async_body, false);\n         let arguments = self.lower_args(decl);\n         let result = f(self);\n         let r = self.record_body(result, arguments);\n-        self.is_generator = prev;\n+        self.is_generator = prev_generator;\n+        self.is_async_body = prev_async;\n         return r;\n     }\n \n@@ -4205,6 +4220,7 @@ impl<'a> LoweringContext<'a> {\n                     })\n                 })\n             }\n+            ExprKind::Await(_origin, ref expr) => self.lower_await(e.span, expr),\n             ExprKind::Closure(\n                 capture_clause, ref asyncness, movability, ref decl, ref body, fn_decl_span\n             ) => {\n@@ -4326,12 +4342,13 @@ impl<'a> LoweringContext<'a> {\n                 let id = self.next_id();\n                 let e1 = self.lower_expr(e1);\n                 let e2 = self.lower_expr(e2);\n-                let ty_path = P(self.std_path(e.span, &[\"ops\", \"RangeInclusive\"], None, false));\n-                let ty = P(self.ty_path(id, e.span, hir::QPath::Resolved(None, ty_path)));\n-                let new_seg = P(hir::PathSegment::from_ident(Ident::from_str(\"new\")));\n-                let new_path = hir::QPath::TypeRelative(ty, new_seg);\n-                let new = P(self.expr(e.span, hir::ExprKind::Path(new_path), ThinVec::new()));\n-                hir::ExprKind::Call(new, hir_vec![e1, e2])\n+                self.expr_call_std_assoc_fn(\n+                    id,\n+                    e.span,\n+                    &[\"ops\", \"RangeInclusive\"],\n+                    \"new\",\n+                    hir_vec![e1, e2],\n+                )\n             }\n             ExprKind::Range(ref e1, ref e2, lims) => {\n                 use syntax::ast::RangeLimits::*;\n@@ -4468,9 +4485,7 @@ impl<'a> LoweringContext<'a> {\n                 let expr = opt_expr\n                     .as_ref()\n                     .map(|x| self.lower_expr(x))\n-                    .unwrap_or_else(||\n-                    self.expr(e.span, hir::ExprKind::Tup(hir_vec![]), ThinVec::new())\n-                );\n+                    .unwrap_or_else(|| self.expr_unit(e.span));\n                 hir::ExprKind::Yield(P(expr))\n             }\n \n@@ -4503,7 +4518,7 @@ impl<'a> LoweringContext<'a> {\n                     let body = if let Some(else_expr) = wildcard_arm {\n                         P(self.lower_expr(else_expr))\n                     } else {\n-                        self.expr_tuple(e.span, hir_vec![])\n+                        P(self.expr_tuple(e.span, hir_vec![]))\n                     };\n                     arms.push(self.arm(hir_vec![wildcard_pattern], body));\n                 }\n@@ -4651,8 +4666,11 @@ impl<'a> LoweringContext<'a> {\n                     let iter = P(self.expr_ident(head_sp, iter, iter_pat_nid));\n                     let ref_mut_iter = self.expr_mut_addr_of(head_sp, iter);\n                     let next_path = &[\"iter\", \"Iterator\", \"next\"];\n-                    let next_path = P(self.expr_std_path(head_sp, next_path, None, ThinVec::new()));\n-                    let next_expr = P(self.expr_call(head_sp, next_path, hir_vec![ref_mut_iter]));\n+                    let next_expr = P(self.expr_call_std_path(\n+                        head_sp,\n+                        next_path,\n+                        hir_vec![ref_mut_iter],\n+                    ));\n                     let arms = hir_vec![pat_arm, break_arm];\n \n                     P(self.expr(\n@@ -4723,9 +4741,11 @@ impl<'a> LoweringContext<'a> {\n                 // `match ::std::iter::IntoIterator::into_iter(<head>) { ... }`\n                 let into_iter_expr = {\n                     let into_iter_path = &[\"iter\", \"IntoIterator\", \"into_iter\"];\n-                    let into_iter = P(self.expr_std_path(\n-                            head_sp, into_iter_path, None, ThinVec::new()));\n-                    P(self.expr_call(head_sp, into_iter, hir_vec![head]))\n+                    P(self.expr_call_std_path(\n+                        head_sp,\n+                        into_iter_path,\n+                        hir_vec![head],\n+                    ))\n                 };\n \n                 let match_expr = P(self.expr_match(\n@@ -4778,9 +4798,11 @@ impl<'a> LoweringContext<'a> {\n                     let sub_expr = self.lower_expr(sub_expr);\n \n                     let path = &[\"ops\", \"Try\", \"into_result\"];\n-                    let path = P(self.expr_std_path(\n-                            unstable_span, path, None, ThinVec::new()));\n-                    P(self.expr_call(e.span, path, hir_vec![sub_expr]))\n+                    P(self.expr_call_std_path(\n+                        unstable_span,\n+                        path,\n+                        hir_vec![sub_expr],\n+                    ))\n                 };\n \n                 // `#[allow(unreachable_code)]`\n@@ -4817,12 +4839,9 @@ impl<'a> LoweringContext<'a> {\n                     let err_ident = self.str_to_ident(\"err\");\n                     let (err_local, err_local_nid) = self.pat_ident(try_span, err_ident);\n                     let from_expr = {\n-                        let path = &[\"convert\", \"From\", \"from\"];\n-                        let from = P(self.expr_std_path(\n-                                try_span, path, None, ThinVec::new()));\n+                        let from_path = &[\"convert\", \"From\", \"from\"];\n                         let err_expr = self.expr_ident(try_span, err_ident, err_local_nid);\n-\n-                        self.expr_call(try_span, from, hir_vec![err_expr])\n+                        self.expr_call_std_path(try_span, from_path, hir_vec![err_expr])\n                     };\n                     let from_err_expr =\n                         self.wrap_in_try_constructor(\"from_error\", from_expr, unstable_span);\n@@ -5056,6 +5075,42 @@ impl<'a> LoweringContext<'a> {\n         self.expr(span, hir::ExprKind::Call(e, args), ThinVec::new())\n     }\n \n+    // Note: associated functions must use `expr_call_std_path`.\n+    fn expr_call_std_path(\n+        &mut self,\n+        span: Span,\n+        path_components: &[&str],\n+        args: hir::HirVec<hir::Expr>,\n+    ) -> hir::Expr {\n+        let path = P(self.expr_std_path(span, path_components, None, ThinVec::new()));\n+        self.expr_call(span, path, args)\n+    }\n+\n+    // Create an expression calling an associated function of an std type.\n+    //\n+    // Associated functions cannot be resolved through the normal `std_path` function,\n+    // as they are resolved differently and so cannot use `expr_call_std_path`.\n+    //\n+    // This function accepts the path component (`ty_path_components`) separately from\n+    // the name of the associated function (`assoc_fn_name`) in order to facilitate\n+    // separate resolution of the type and creation of a path referring to its associated\n+    // function.\n+    fn expr_call_std_assoc_fn(\n+        &mut self,\n+        ty_path_id: hir::HirId,\n+        span: Span,\n+        ty_path_components: &[&str],\n+        assoc_fn_name: &str,\n+        args: hir::HirVec<hir::Expr>,\n+    ) -> hir::ExprKind {\n+        let ty_path = P(self.std_path(span, ty_path_components, None, false));\n+        let ty = P(self.ty_path(ty_path_id, span, hir::QPath::Resolved(None, ty_path)));\n+        let fn_seg = P(hir::PathSegment::from_ident(Ident::from_str(assoc_fn_name)));\n+        let fn_path = hir::QPath::TypeRelative(ty, fn_seg);\n+        let fn_expr = P(self.expr(span, hir::ExprKind::Path(fn_path), ThinVec::new()));\n+        hir::ExprKind::Call(fn_expr, args)\n+    }\n+\n     fn expr_ident(&mut self, span: Span, ident: Ident, binding: hir::HirId) -> hir::Expr {\n         self.expr_ident_with_attrs(span, ident, binding, ThinVec::new())\n     }\n@@ -5127,8 +5182,12 @@ impl<'a> LoweringContext<'a> {\n         self.expr(b.span, hir::ExprKind::Block(b, None), attrs)\n     }\n \n-    fn expr_tuple(&mut self, sp: Span, exprs: hir::HirVec<hir::Expr>) -> P<hir::Expr> {\n-        P(self.expr(sp, hir::ExprKind::Tup(exprs), ThinVec::new()))\n+    fn expr_unit(&mut self, sp: Span) -> hir::Expr {\n+        self.expr_tuple(sp, hir_vec![])\n+    }\n+\n+    fn expr_tuple(&mut self, sp: Span, exprs: hir::HirVec<hir::Expr>) -> hir::Expr {\n+        self.expr(sp, hir::ExprKind::Tup(exprs), ThinVec::new())\n     }\n \n     fn expr(&mut self, span: Span, node: hir::ExprKind, attrs: ThinVec<Attribute>) -> hir::Expr {\n@@ -5184,6 +5243,23 @@ impl<'a> LoweringContext<'a> {\n         }\n     }\n \n+    fn expr_unsafe(&mut self, expr: P<hir::Expr>) -> hir::Expr {\n+        let hir_id = self.next_id();\n+        let span = expr.span;\n+        self.expr(\n+            span,\n+            hir::ExprKind::Block(P(hir::Block {\n+                stmts: hir_vec![],\n+                expr: Some(expr),\n+                hir_id,\n+                rules: hir::UnsafeBlock(hir::CompilerGenerated),\n+                span,\n+                targeted_by_break: false,\n+            }), None),\n+            ThinVec::new(),\n+        )\n+    }\n+\n     fn pat_ok(&mut self, span: Span, pat: P<hir::Pat>) -> P<hir::Pat> {\n         self.pat_std_enum(span, &[\"result\", \"Result\", \"Ok\"], hir_vec![pat])\n     }\n@@ -5258,13 +5334,12 @@ impl<'a> LoweringContext<'a> {\n         span: Span,\n         components: &[&str],\n         params: Option<P<hir::GenericArgs>>,\n-        is_value: bool\n+        is_value: bool,\n     ) -> hir::Path {\n         let mut path = self.resolver\n             .resolve_str_path(span, self.crate_root, components, is_value);\n         path.segments.last_mut().unwrap().args = params;\n \n-\n         for seg in path.segments.iter_mut() {\n             if seg.hir_id.is_some() {\n                 seg.hir_id = Some(self.next_id());\n@@ -5465,6 +5540,175 @@ impl<'a> LoweringContext<'a> {\n                                             ThinVec::new()));\n         P(self.expr_call(e.span, from_err, hir_vec![e]))\n     }\n+\n+    fn lower_await(\n+        &mut self,\n+        await_span: Span,\n+        expr: &ast::Expr,\n+    ) -> hir::ExprKind {\n+        // to:\n+        //\n+        // {\n+        //     let mut pinned = <expr>;\n+        //     loop {\n+        //         match ::std::future::poll_with_tls_context(unsafe {\n+        //             ::std::pin::Pin::new_unchecked(&mut pinned)\n+        //         }) {\n+        //             ::std::task::Poll::Ready(x) => break x,\n+        //             ::std::task::Poll::Pending => {},\n+        //         }\n+        //         yield ();\n+        //     }\n+        // }\n+        if !self.is_async_body {\n+            span_err!(\n+                self.sess,\n+                await_span,\n+                E0728,\n+                \"`await` is only allowed inside `async` functions and blocks\"\n+            );\n+            self.sess.abort_if_errors();\n+        }\n+        let span = self.mark_span_with_reason(\n+            CompilerDesugaringKind::Await,\n+            await_span,\n+            None,\n+        );\n+        let gen_future_span = self.mark_span_with_reason(\n+            CompilerDesugaringKind::Await,\n+            await_span,\n+            Some(vec![Symbol::intern(\"gen_future\")].into()),\n+        );\n+\n+        // let mut pinned = <expr>;\n+        let expr = P(self.lower_expr(expr));\n+        let pinned_ident = self.str_to_ident(\"pinned\");\n+        let (pinned_pat, pinned_pat_hid) = self.pat_ident_binding_mode(\n+            span,\n+            pinned_ident,\n+            hir::BindingAnnotation::Mutable,\n+        );\n+        let pinned_let = self.stmt_let_pat(\n+            span,\n+            Some(expr),\n+            pinned_pat,\n+            hir::LocalSource::AwaitDesugar,\n+        );\n+\n+        // ::std::future::poll_with_tls_context(unsafe {\n+        //     ::std::pin::Pin::new_unchecked(&mut pinned)\n+        // })`\n+        let poll_expr = {\n+            let pinned = P(self.expr_ident(span, pinned_ident, pinned_pat_hid));\n+            let ref_mut_pinned = self.expr_mut_addr_of(span, pinned);\n+            let pin_ty_id = self.next_id();\n+            let new_unchecked_expr_kind = self.expr_call_std_assoc_fn(\n+                pin_ty_id,\n+                span,\n+                &[\"pin\", \"Pin\"],\n+                \"new_unchecked\",\n+                hir_vec![ref_mut_pinned],\n+            );\n+            let new_unchecked = P(self.expr(span, new_unchecked_expr_kind, ThinVec::new()));\n+            let unsafe_expr = self.expr_unsafe(new_unchecked);\n+            P(self.expr_call_std_path(\n+                gen_future_span,\n+                &[\"future\", \"poll_with_tls_context\"],\n+                hir_vec![unsafe_expr],\n+            ))\n+        };\n+\n+        // `::std::task::Poll::Ready(x) => break x`\n+        let loop_node_id = self.sess.next_node_id();\n+        let loop_hir_id = self.lower_node_id(loop_node_id);\n+        let ready_arm = {\n+            let x_ident = self.str_to_ident(\"x\");\n+            let (x_pat, x_pat_hid) = self.pat_ident(span, x_ident);\n+            let x_expr = P(self.expr_ident(span, x_ident, x_pat_hid));\n+            let ready_pat = self.pat_std_enum(\n+                span,\n+                &[\"task\", \"Poll\", \"Ready\"],\n+                hir_vec![x_pat],\n+            );\n+            let break_x = self.with_loop_scope(loop_node_id, |this| {\n+                let expr_break = hir::ExprKind::Break(\n+                    this.lower_loop_destination(None),\n+                    Some(x_expr),\n+                );\n+                P(this.expr(await_span, expr_break, ThinVec::new()))\n+            });\n+            self.arm(hir_vec![ready_pat], break_x)\n+        };\n+\n+        // `::std::task::Poll::Pending => {}`\n+        let pending_arm = {\n+            let pending_pat = self.pat_std_enum(\n+                span,\n+                &[\"task\", \"Poll\", \"Pending\"],\n+                hir_vec![],\n+            );\n+            let empty_block = P(hir::Block {\n+                stmts: hir_vec![],\n+                expr: None,\n+                hir_id: self.next_id(),\n+                rules: hir::DefaultBlock,\n+                span,\n+                targeted_by_break: false,\n+            });\n+            let empty_block = P(self.expr_block(empty_block, ThinVec::new()));\n+            self.arm(hir_vec![pending_pat], empty_block)\n+        };\n+\n+        let match_stmt = {\n+            let match_expr = P(self.expr_match(\n+                span,\n+                poll_expr,\n+                hir_vec![ready_arm, pending_arm],\n+                hir::MatchSource::AwaitDesugar,\n+            ));\n+            hir::Stmt {\n+                hir_id: self.next_id(),\n+                node: hir::StmtKind::Expr(match_expr),\n+                span,\n+            }\n+        };\n+\n+        let yield_stmt = {\n+            let unit = self.expr_unit(span);\n+            let yield_expr = P(self.expr(\n+                span,\n+                hir::ExprKind::Yield(P(unit)),\n+                ThinVec::new(),\n+            ));\n+            hir::Stmt {\n+                hir_id: self.next_id(),\n+                node: hir::StmtKind::Expr(yield_expr),\n+                span,\n+            }\n+        };\n+\n+        let loop_block = P(self.block_all(\n+            span,\n+            hir_vec![match_stmt, yield_stmt],\n+            None,\n+        ));\n+\n+        let loop_expr = P(hir::Expr {\n+            hir_id: loop_hir_id,\n+            node: hir::ExprKind::Loop(\n+                loop_block,\n+                None,\n+                hir::LoopSource::Loop,\n+            ),\n+            span,\n+            attrs: ThinVec::new(),\n+        });\n+\n+        hir::ExprKind::Block(\n+            P(self.block_all(span, hir_vec![pinned_let], Some(loop_expr))),\n+            None,\n+        )\n+    }\n }\n \n fn body_ids(bodies: &BTreeMap<hir::BodyId, hir::Body>) -> Vec<hir::BodyId> {"}, {"sha": "01de7917e6e238224a7526acd53c46531be7f9bb", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94", "patch": "@@ -1606,6 +1606,8 @@ pub enum LocalSource {\n     /// }\n     /// ```\n     AsyncFn,\n+    /// A desugared `<expr>.await`.\n+    AwaitDesugar,\n }\n \n /// Hints at the original code for a `match _ { .. }`.\n@@ -1624,6 +1626,8 @@ pub enum MatchSource {\n     ForLoopDesugar,\n     /// A desugared `?` operator.\n     TryDesugar,\n+    /// A desugared `<expr>.await`.\n+    AwaitDesugar,\n }\n \n /// The loop type that yielded an `ExprKind::Loop`."}, {"sha": "90dd5099cbfd69d0f0faf21d11ffe19b2eca6d09", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94", "patch": "@@ -396,6 +396,7 @@ impl_stable_hash_for!(enum ::syntax_pos::hygiene::ExpnFormat {\n \n impl_stable_hash_for!(enum ::syntax_pos::hygiene::CompilerDesugaringKind {\n     Async,\n+    Await,\n     QuestionMark,\n     ExistentialReturnType,\n     ForLoop,"}, {"sha": "f7a89271ec55f41659f8dbc197b8aafa25ff0d43", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 5, "deletions": 38, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94", "patch": "@@ -46,7 +46,6 @@ use syntax::symbol::{Symbol, keywords};\n use syntax::errors::{Applicability, DiagnosticBuilder};\n use syntax::print::pprust::expr_to_string;\n use syntax::visit::FnKind;\n-use syntax::struct_span_err;\n \n use rustc::hir::{self, GenericParamKind, PatKind};\n \n@@ -1438,15 +1437,10 @@ impl KeywordIdents {\n                          UnderMacro(under_macro): UnderMacro,\n                          ident: ast::Ident)\n     {\n-        let ident_str = &ident.as_str()[..];\n-        let cur_edition = cx.sess.edition();\n-        let is_raw_ident = |ident: ast::Ident| {\n-            cx.sess.parse_sess.raw_identifier_spans.borrow().contains(&ident.span)\n-        };\n-        let next_edition = match cur_edition {\n+        let next_edition = match cx.sess.edition() {\n             Edition::Edition2015 => {\n-                match ident_str {\n-                    \"async\" | \"try\" => Edition::Edition2018,\n+                match &ident.as_str()[..] {\n+                    \"async\" | \"await\" | \"try\" => Edition::Edition2018,\n \n                     // rust-lang/rust#56327: Conservatively do not\n                     // attempt to report occurrences of `dyn` within\n@@ -1462,43 +1456,16 @@ impl KeywordIdents {\n                     // an identifier.\n                     \"dyn\" if !under_macro => Edition::Edition2018,\n \n-                    // Only issue warnings for `await` if the `async_await`\n-                    // feature isn't being used. Otherwise, users need\n-                    // to keep using `await` for the macro exposed by std.\n-                    \"await\" if !cx.sess.features_untracked().async_await => Edition::Edition2018,\n                     _ => return,\n                 }\n             }\n \n             // There are no new keywords yet for the 2018 edition and beyond.\n-            // However, `await` is a \"false\" keyword in the 2018 edition,\n-            // and can only be used if the `async_await` feature is enabled.\n-            // Otherwise, we emit an error.\n-            _ => {\n-                if \"await\" == ident_str\n-                    && !cx.sess.features_untracked().async_await\n-                    && !is_raw_ident(ident)\n-                {\n-                    let mut err = struct_span_err!(\n-                        cx.sess,\n-                        ident.span,\n-                        E0721,\n-                        \"`await` is a keyword in the {} edition\", cur_edition,\n-                    );\n-                    err.span_suggestion(\n-                        ident.span,\n-                        \"you can use a raw identifier to stay compatible\",\n-                        \"r#await\".to_string(),\n-                        Applicability::MachineApplicable,\n-                    );\n-                    err.emit();\n-                }\n-                return\n-            },\n+            _ => return,\n         };\n \n         // don't lint `r#foo`\n-        if is_raw_ident(ident) {\n+        if cx.sess.parse_sess.raw_identifier_spans.borrow().contains(&ident.span) {\n             return;\n         }\n "}, {"sha": "1a7266859ad9f1a343a4ad1c1099cc4532e08068", "filename": "src/librustc_mir/hair/pattern/check_match.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fhair%2Fpattern%2Fcheck_match.rs?ref=33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94", "patch": "@@ -77,6 +77,7 @@ impl<'a, 'tcx> Visitor<'tcx> for MatchVisitor<'a, 'tcx> {\n             hir::LocalSource::Normal => \"local binding\",\n             hir::LocalSource::ForLoopDesugar => \"`for` loop binding\",\n             hir::LocalSource::AsyncFn => \"async fn binding\",\n+            hir::LocalSource::AwaitDesugar => \"`await` future binding\",\n         });\n \n         // Check legality of move bindings and `@` patterns.\n@@ -412,8 +413,9 @@ fn check_arms<'a, 'tcx>(\n                             err.emit();\n                         }\n \n-                        // Unreachable patterns in try expressions occur when one of the arms\n-                        // are an uninhabited type. Which is OK.\n+                        // Unreachable patterns in try and await expressions occur when one of\n+                        // the arms are an uninhabited type. Which is OK.\n+                        hir::MatchSource::AwaitDesugar |\n                         hir::MatchSource::TryDesugar => {}\n                     }\n                 }"}, {"sha": "af2302d24f5214724715608ca6f26d59ca482112", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94", "patch": "@@ -1065,6 +1065,7 @@ impl Expr {\n             ExprKind::Block(..) => ExprPrecedence::Block,\n             ExprKind::TryBlock(..) => ExprPrecedence::TryBlock,\n             ExprKind::Async(..) => ExprPrecedence::Async,\n+            ExprKind::Await(..) => ExprPrecedence::Await,\n             ExprKind::Assign(..) => ExprPrecedence::Assign,\n             ExprKind::AssignOp(..) => ExprPrecedence::AssignOp,\n             ExprKind::Field(..) => ExprPrecedence::Field,\n@@ -1186,6 +1187,9 @@ pub enum ExprKind {\n     /// created during lowering cannot be made the parent of any other\n     /// preexisting defs.\n     Async(CaptureBy, NodeId, P<Block>),\n+    /// An await expression (`my_future.await`).\n+    Await(AwaitOrigin, P<Expr>),\n+\n     /// A try block (`try { ... }`).\n     TryBlock(P<Block>),\n \n@@ -1287,6 +1291,15 @@ pub enum Movability {\n     Movable,\n }\n \n+/// Whether an `await` comes from `await!` or `.await` syntax.\n+/// FIXME: this should be removed when support for legacy `await!` is removed.\n+/// https://github.com/rust-lang/rust/issues/60610\n+#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy)]\n+pub enum AwaitOrigin {\n+    FieldLike,\n+    MacroLike,\n+}\n+\n pub type Mac = Spanned<Mac_>;\n \n /// Represents a macro invocation. The `Path` indicates which macro"}, {"sha": "c3bad3aba184b06bfb16ab58ccdf5be865866c6c", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94", "patch": "@@ -482,6 +482,10 @@ declare_features! (\n     // Allows async and await syntax.\n     (active, async_await, \"1.28.0\", Some(50547), None),\n \n+    // Allows await! macro-like syntax.\n+    // This will likely be removed prior to stabilization of async/await.\n+    (active, await_macro, \"1.28.0\", Some(50547), None),\n+\n     // Allows reinterpretation of the bits of a value of one type as another type during const eval.\n     (active, const_transmute, \"1.29.0\", Some(53605), None),\n \n@@ -2127,6 +2131,20 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n             ast::ExprKind::Async(..) => {\n                 gate_feature_post!(&self, async_await, e.span, \"async blocks are unstable\");\n             }\n+            ast::ExprKind::Await(origin, _) => {\n+                match origin {\n+                    ast::AwaitOrigin::FieldLike =>\n+                        gate_feature_post!(&self, async_await, e.span, \"async/await is unstable\"),\n+                    ast::AwaitOrigin::MacroLike =>\n+                        gate_feature_post!(\n+                            &self,\n+                            await_macro,\n+                            e.span,\n+                            \"`await!(<expr>)` macro syntax is unstable, and will soon be removed \\\n+                            in favor of `<expr>.await` syntax.\"\n+                        ),\n+                }\n+            }\n             _ => {}\n         }\n         visit::walk_expr(self, e);"}, {"sha": "6eb8b1b5004c96468958756878d0dbcf8a7b7b28", "filename": "src/libsyntax/mut_visit.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94/src%2Flibsyntax%2Fmut_visit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94/src%2Flibsyntax%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fmut_visit.rs?ref=33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94", "patch": "@@ -1185,6 +1185,7 @@ pub fn noop_visit_expr<T: MutVisitor>(Expr { node, id, span, attrs }: &mut Expr,\n             vis.visit_id(node_id);\n             vis.visit_block(body);\n         }\n+        ExprKind::Await(_origin, expr) => vis.visit_expr(expr),\n         ExprKind::Assign(el, er) => {\n             vis.visit_expr(el);\n             vis.visit_expr(er);"}, {"sha": "f3eac71ee7761a5574b06f6c5526b203c7fbc426", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94", "patch": "@@ -2752,6 +2752,14 @@ impl<'a> Parser<'a> {\n                     db.span_label(self.span, \"expected expression\");\n                     db.note(\"variable declaration using `let` is a statement\");\n                     return Err(db);\n+                } else if self.span.rust_2018() && self.eat_keyword(keywords::Await) {\n+                    // FIXME: remove this branch when `await!` is no longer supported\n+                    // https://github.com/rust-lang/rust/issues/60610\n+                    self.expect(&token::Not)?;\n+                    self.expect(&token::OpenDelim(token::Paren))?;\n+                    let expr = self.parse_expr()?;\n+                    self.expect(&token::CloseDelim(token::Paren))?;\n+                    ex = ExprKind::Await(ast::AwaitOrigin::MacroLike, expr);\n                 } else if self.token.is_path_start() {\n                     let path = self.parse_path(PathStyle::Expr)?;\n \n@@ -3015,6 +3023,15 @@ impl<'a> Parser<'a> {\n \n     // Assuming we have just parsed `.`, continue parsing into an expression.\n     fn parse_dot_suffix(&mut self, self_arg: P<Expr>, lo: Span) -> PResult<'a, P<Expr>> {\n+        if self.span.rust_2018() && self.eat_keyword(keywords::Await) {\n+            let span = lo.to(self.prev_span);\n+            let await_expr = self.mk_expr(\n+                span,\n+                ExprKind::Await(ast::AwaitOrigin::FieldLike, self_arg),\n+                ThinVec::new(),\n+            );\n+            return Ok(await_expr);\n+        }\n         let segment = self.parse_path_segment(PathStyle::Expr)?;\n         self.check_trailing_angle_brackets(&segment, token::OpenDelim(token::Paren));\n "}, {"sha": "fd7a39c576daa79407a4650264f284bdd7490fa5", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94", "patch": "@@ -99,6 +99,11 @@ pub(crate) fn ident_can_begin_expr(ident: ast::Ident, is_raw: bool) -> bool {\n     ident_token.is_path_segment_keyword() ||\n     [\n         keywords::Async.name(),\n+\n+        // FIXME: remove when `await!(..)` syntax is removed\n+        // https://github.com/rust-lang/rust/issues/60610\n+        keywords::Await.name(),\n+\n         keywords::Do.name(),\n         keywords::Box.name(),\n         keywords::Break.name(),"}, {"sha": "682621d40ab6583dfd2f2439c8d2d890b0eadc35", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94", "patch": "@@ -2250,6 +2250,18 @@ impl<'a> State<'a> {\n                 self.ibox(0)?;\n                 self.print_block_with_attrs(blk, attrs)?;\n             }\n+            ast::ExprKind::Await(origin, ref expr) => {\n+                match origin {\n+                    ast::AwaitOrigin::MacroLike => {\n+                        self.s.word(\"await!\")?;\n+                        self.print_expr_maybe_paren(expr, parser::PREC_FORCE_PAREN)?;\n+                    }\n+                    ast::AwaitOrigin::FieldLike => {\n+                        self.print_expr_maybe_paren(expr, parser::PREC_POSTFIX)?;\n+                        self.s.word(\".await\")?;\n+                    }\n+                }\n+            }\n             ast::ExprKind::Assign(ref lhs, ref rhs) => {\n                 let prec = AssocOp::Assign.precedence() as i8;\n                 self.print_expr_maybe_paren(lhs, prec + 1)?;"}, {"sha": "80dabffaba9f422414e76dcbdaf1544e121c8f89", "filename": "src/libsyntax/util/parser.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94/src%2Flibsyntax%2Futil%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94/src%2Flibsyntax%2Futil%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Futil%2Fparser.rs?ref=33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94", "patch": "@@ -267,6 +267,7 @@ pub enum ExprPrecedence {\n     TryBlock,\n     Struct,\n     Async,\n+    Await,\n     Err,\n }\n \n@@ -301,6 +302,7 @@ impl ExprPrecedence {\n             ExprPrecedence::Unary => PREC_PREFIX,\n \n             // Unary, postfix\n+            ExprPrecedence::Await |\n             ExprPrecedence::Call |\n             ExprPrecedence::MethodCall |\n             ExprPrecedence::Field |\n@@ -346,6 +348,7 @@ pub fn contains_exterior_struct_lit(value: &ast::Expr) -> bool {\n             // X { y: 1 } + X { y: 2 }\n             contains_exterior_struct_lit(&lhs) || contains_exterior_struct_lit(&rhs)\n         }\n+        ast::ExprKind::Await(_, ref x) |\n         ast::ExprKind::Unary(_, ref x) |\n         ast::ExprKind::Cast(ref x, _) |\n         ast::ExprKind::Type(ref x, _) |"}, {"sha": "0503e5644dbc58112bd6547e974c1c2865b9f6df", "filename": "src/libsyntax/visit.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94/src%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94/src%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fvisit.rs?ref=33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94", "patch": "@@ -768,6 +768,7 @@ pub fn walk_expr<'a, V: Visitor<'a>>(visitor: &mut V, expression: &'a Expr) {\n         ExprKind::Async(_, _, ref body) => {\n             visitor.visit_block(body);\n         }\n+        ExprKind::Await(_, ref expr) => visitor.visit_expr(expr),\n         ExprKind::Assign(ref left_hand_expression, ref right_hand_expression) => {\n             visitor.visit_expr(left_hand_expression);\n             visitor.visit_expr(right_hand_expression);"}, {"sha": "a901afdff43e63ff84e705a0870775907e1c21cf", "filename": "src/libsyntax_pos/hygiene.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94/src%2Flibsyntax_pos%2Fhygiene.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94/src%2Flibsyntax_pos%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fhygiene.rs?ref=33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94", "patch": "@@ -598,13 +598,15 @@ pub enum CompilerDesugaringKind {\n     /// `impl Trait` with `Foo`.\n     ExistentialReturnType,\n     Async,\n+    Await,\n     ForLoop,\n }\n \n impl CompilerDesugaringKind {\n     pub fn name(self) -> Symbol {\n         Symbol::intern(match self {\n             CompilerDesugaringKind::Async => \"async\",\n+            CompilerDesugaringKind::Await => \"await\",\n             CompilerDesugaringKind::QuestionMark => \"?\",\n             CompilerDesugaringKind::TryBlock => \"try block\",\n             CompilerDesugaringKind::ExistentialReturnType => \"existential type\","}, {"sha": "20759217b54a0962f72fdf16511f6b3a8dfa35f0", "filename": "src/libsyntax_pos/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94/src%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94/src%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_pos%2Fsymbol.rs?ref=33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94", "patch": "@@ -84,6 +84,7 @@ symbols! {\n \n         // Edition-specific keywords that are used in unstable Rust or reserved for future use.\n         Async:              \"async\", // >= 2018 Edition only\n+        Await:              \"await\", // >= 2018 Edition only\n         Try:                \"try\", // >= 2018 Edition only\n \n         // Special lifetime names"}, {"sha": "49fd8b8b1ce27031f8111564473cb7b12bb13d92", "filename": "src/test/run-pass/async-await.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94/src%2Ftest%2Frun-pass%2Fasync-await.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94/src%2Ftest%2Frun-pass%2Fasync-await.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fasync-await.rs?ref=33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94", "patch": "@@ -1,7 +1,7 @@\n // edition:2018\n // aux-build:arc_wake.rs\n \n-#![feature(async_await, await_macro)]\n+#![feature(async_await)]\n \n extern crate arc_wake;\n \n@@ -46,58 +46,58 @@ impl Future for WakeOnceThenComplete {\n \n fn async_block(x: u8) -> impl Future<Output = u8> {\n     async move {\n-        await!(wake_and_yield_once());\n+        wake_and_yield_once().await;\n         x\n     }\n }\n \n fn async_block_with_borrow_named_lifetime<'a>(x: &'a u8) -> impl Future<Output = u8> + 'a {\n     async move {\n-        await!(wake_and_yield_once());\n+        wake_and_yield_once().await;\n         *x\n     }\n }\n \n fn async_nonmove_block(x: u8) -> impl Future<Output = u8> {\n     async move {\n         let future = async {\n-            await!(wake_and_yield_once());\n+            wake_and_yield_once().await;\n             x\n         };\n-        await!(future)\n+        future.await\n     }\n }\n \n fn async_closure(x: u8) -> impl Future<Output = u8> {\n     (async move |x: u8| -> u8 {\n-        await!(wake_and_yield_once());\n+        wake_and_yield_once().await;\n         x\n     })(x)\n }\n \n async fn async_fn(x: u8) -> u8 {\n-    await!(wake_and_yield_once());\n+    wake_and_yield_once().await;\n     x\n }\n \n async fn generic_async_fn<T>(x: T) -> T {\n-    await!(wake_and_yield_once());\n+    wake_and_yield_once().await;\n     x\n }\n \n async fn async_fn_with_borrow(x: &u8) -> u8 {\n-    await!(wake_and_yield_once());\n+    wake_and_yield_once().await;\n     *x\n }\n \n async fn async_fn_with_borrow_named_lifetime<'a>(x: &'a u8) -> u8 {\n-    await!(wake_and_yield_once());\n+    wake_and_yield_once().await;\n     *x\n }\n \n fn async_fn_with_impl_future_named_lifetime<'a>(x: &'a u8) -> impl Future<Output = u8> + 'a {\n     async move {\n-        await!(wake_and_yield_once());\n+        wake_and_yield_once().await;\n         *x\n     }\n }\n@@ -110,18 +110,18 @@ async fn async_fn_multiple_args(x: &u8, _y: &u8) -> u8 {\n */\n \n async fn async_fn_multiple_args_named_lifetime<'a>(x: &'a u8, _y: &'a u8) -> u8 {\n-    await!(wake_and_yield_once());\n+    wake_and_yield_once().await;\n     *x\n }\n \n fn async_fn_with_internal_borrow(y: u8) -> impl Future<Output = u8> {\n     async move {\n-        await!(async_fn_with_borrow_named_lifetime(&y))\n+        async_fn_with_borrow_named_lifetime(&y).await\n     }\n }\n \n unsafe async fn unsafe_async_fn(x: u8) -> u8 {\n-    await!(wake_and_yield_once());\n+    wake_and_yield_once().await;\n     x\n }\n \n@@ -134,7 +134,7 @@ trait Bar {\n impl Foo {\n     async fn async_method(x: u8) -> u8 {\n         unsafe {\n-            await!(unsafe_async_fn(x))\n+            unsafe_async_fn(x).await\n         }\n     }\n }\n@@ -165,7 +165,7 @@ fn main() {\n         ($($fn_name:expr,)*) => { $(\n             test_future_yields_once_then_returns(|x| {\n                 async move {\n-                    await!($fn_name(&x))\n+                    $fn_name(&x).await\n                 }\n             });\n         )* }\n@@ -181,7 +181,7 @@ fn main() {\n         Foo::async_method,\n         |x| {\n             async move {\n-                unsafe { await!(unsafe_async_fn(x)) }\n+                unsafe { unsafe_async_fn(x).await }\n             }\n         },\n     }\n@@ -192,7 +192,7 @@ fn main() {\n         async_fn_with_impl_future_named_lifetime,\n         |x| {\n             async move {\n-                await!(async_fn_multiple_args_named_lifetime(x, x))\n+                async_fn_multiple_args_named_lifetime(x, x).await\n             }\n         },\n     }"}, {"sha": "e1b4328debd9a8918e7bea0c3e4aa16326bc31a9", "filename": "src/test/run-pass/await-macro.rs", "status": "added", "additions": 199, "deletions": 0, "changes": 199, "blob_url": "https://github.com/rust-lang/rust/blob/33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94/src%2Ftest%2Frun-pass%2Fawait-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94/src%2Ftest%2Frun-pass%2Fawait-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fawait-macro.rs?ref=33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94", "patch": "@@ -0,0 +1,199 @@\n+// edition:2018\n+// aux-build:arc_wake.rs\n+\n+#![feature(async_await, await_macro)]\n+\n+extern crate arc_wake;\n+\n+use std::pin::Pin;\n+use std::future::Future;\n+use std::sync::{\n+    Arc,\n+    atomic::{self, AtomicUsize},\n+};\n+use std::task::{Context, Poll};\n+use arc_wake::ArcWake;\n+\n+struct Counter {\n+    wakes: AtomicUsize,\n+}\n+\n+impl ArcWake for Counter {\n+    fn wake(self: Arc<Self>) {\n+        Self::wake_by_ref(&self)\n+    }\n+    fn wake_by_ref(arc_self: &Arc<Self>) {\n+        arc_self.wakes.fetch_add(1, atomic::Ordering::SeqCst);\n+    }\n+}\n+\n+struct WakeOnceThenComplete(bool);\n+\n+fn wake_and_yield_once() -> WakeOnceThenComplete { WakeOnceThenComplete(false) }\n+\n+impl Future for WakeOnceThenComplete {\n+    type Output = ();\n+    fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<()> {\n+        if self.0 {\n+            Poll::Ready(())\n+        } else {\n+            cx.waker().wake_by_ref();\n+            self.0 = true;\n+            Poll::Pending\n+        }\n+    }\n+}\n+\n+fn async_block(x: u8) -> impl Future<Output = u8> {\n+    async move {\n+        await!(wake_and_yield_once());\n+        x\n+    }\n+}\n+\n+fn async_block_with_borrow_named_lifetime<'a>(x: &'a u8) -> impl Future<Output = u8> + 'a {\n+    async move {\n+        await!(wake_and_yield_once());\n+        *x\n+    }\n+}\n+\n+fn async_nonmove_block(x: u8) -> impl Future<Output = u8> {\n+    async move {\n+        let future = async {\n+            await!(wake_and_yield_once());\n+            x\n+        };\n+        await!(future)\n+    }\n+}\n+\n+fn async_closure(x: u8) -> impl Future<Output = u8> {\n+    (async move |x: u8| -> u8 {\n+        await!(wake_and_yield_once());\n+        x\n+    })(x)\n+}\n+\n+async fn async_fn(x: u8) -> u8 {\n+    await!(wake_and_yield_once());\n+    x\n+}\n+\n+async fn generic_async_fn<T>(x: T) -> T {\n+    await!(wake_and_yield_once());\n+    x\n+}\n+\n+async fn async_fn_with_borrow(x: &u8) -> u8 {\n+    await!(wake_and_yield_once());\n+    *x\n+}\n+\n+async fn async_fn_with_borrow_named_lifetime<'a>(x: &'a u8) -> u8 {\n+    await!(wake_and_yield_once());\n+    *x\n+}\n+\n+fn async_fn_with_impl_future_named_lifetime<'a>(x: &'a u8) -> impl Future<Output = u8> + 'a {\n+    async move {\n+        await!(wake_and_yield_once());\n+        *x\n+    }\n+}\n+\n+/* FIXME(cramertj) support when `existential type T<'a, 'b>:;` works\n+async fn async_fn_multiple_args(x: &u8, _y: &u8) -> u8 {\n+    await!(wake_and_yield_once());\n+    *x\n+}\n+*/\n+\n+async fn async_fn_multiple_args_named_lifetime<'a>(x: &'a u8, _y: &'a u8) -> u8 {\n+    await!(wake_and_yield_once());\n+    *x\n+}\n+\n+fn async_fn_with_internal_borrow(y: u8) -> impl Future<Output = u8> {\n+    async move {\n+        await!(async_fn_with_borrow_named_lifetime(&y))\n+    }\n+}\n+\n+unsafe async fn unsafe_async_fn(x: u8) -> u8 {\n+    await!(wake_and_yield_once());\n+    x\n+}\n+\n+struct Foo;\n+\n+trait Bar {\n+    fn foo() {}\n+}\n+\n+impl Foo {\n+    async fn async_method(x: u8) -> u8 {\n+        unsafe {\n+            await!(unsafe_async_fn(x))\n+        }\n+    }\n+}\n+\n+fn test_future_yields_once_then_returns<F, Fut>(f: F)\n+where\n+    F: FnOnce(u8) -> Fut,\n+    Fut: Future<Output = u8>,\n+{\n+    let mut fut = Box::pin(f(9));\n+    let counter = Arc::new(Counter { wakes: AtomicUsize::new(0) });\n+    let waker = ArcWake::into_waker(counter.clone());\n+    let mut cx = Context::from_waker(&waker);\n+    assert_eq!(0, counter.wakes.load(atomic::Ordering::SeqCst));\n+    assert_eq!(Poll::Pending, fut.as_mut().poll(&mut cx));\n+    assert_eq!(1, counter.wakes.load(atomic::Ordering::SeqCst));\n+    assert_eq!(Poll::Ready(9), fut.as_mut().poll(&mut cx));\n+}\n+\n+fn main() {\n+    macro_rules! test {\n+        ($($fn_name:expr,)*) => { $(\n+            test_future_yields_once_then_returns($fn_name);\n+        )* }\n+    }\n+\n+    macro_rules! test_with_borrow {\n+        ($($fn_name:expr,)*) => { $(\n+            test_future_yields_once_then_returns(|x| {\n+                async move {\n+                    await!($fn_name(&x))\n+                }\n+            });\n+        )* }\n+    }\n+\n+    test! {\n+        async_block,\n+        async_nonmove_block,\n+        async_closure,\n+        async_fn,\n+        generic_async_fn,\n+        async_fn_with_internal_borrow,\n+        Foo::async_method,\n+        |x| {\n+            async move {\n+                unsafe { await!(unsafe_async_fn(x)) }\n+            }\n+        },\n+    }\n+    test_with_borrow! {\n+        async_block_with_borrow_named_lifetime,\n+        async_fn_with_borrow,\n+        async_fn_with_borrow_named_lifetime,\n+        async_fn_with_impl_future_named_lifetime,\n+        |x| {\n+            async move {\n+                await!(async_fn_multiple_args_named_lifetime(x, x))\n+            }\n+        },\n+    }\n+}"}, {"sha": "b7e60b773b416be29340e2330ab565894996a8c7", "filename": "src/test/run-pass/issue-55809.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94/src%2Ftest%2Frun-pass%2Fissue-55809.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94/src%2Ftest%2Frun-pass%2Fissue-55809.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-55809.rs?ref=33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94", "patch": "@@ -1,7 +1,7 @@\n // edition:2018\n // run-pass\n \n-#![feature(async_await, await_macro)]\n+#![feature(async_await)]\n \n trait Foo { }\n \n@@ -14,15 +14,15 @@ async fn foo_async<T>(_v: T) -> u8 where T: Foo {\n }\n \n async fn bad<T>(v: T) -> u8 where T: Foo {\n-    await!(foo_async(v))\n+    foo_async(v).await\n }\n \n async fn async_main() {\n     let mut v = ();\n \n-    let _ = await!(bad(&mut v));\n-    let _ = await!(foo_async(&mut v));\n-    let _ = await!(bad(v));\n+    let _ = bad(&mut v).await;\n+    let _ = foo_async(&mut v).await;\n+    let _ = bad(v).await;\n }\n \n fn main() {"}, {"sha": "c4f3f3edc486e88b75726ad83d9304f781f50bd7", "filename": "src/test/ui/await-keyword/2015-edition-error-in-non-macro-position.rs", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94/src%2Ftest%2Fui%2Fawait-keyword%2F2015-edition-error-in-non-macro-position.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94/src%2Ftest%2Fui%2Fawait-keyword%2F2015-edition-error-in-non-macro-position.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fawait-keyword%2F2015-edition-error-in-non-macro-position.rs?ref=33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94", "patch": "@@ -0,0 +1,36 @@\n+#![feature(async_await, await_macro)]\n+#![allow(non_camel_case_types)]\n+#![deny(keyword_idents)]\n+\n+mod outer_mod {\n+    pub mod await { //~ ERROR `await` is a keyword in the 2018 edition\n+    //~^ WARN this was previously accepted by the compiler\n+        pub struct await; //~ ERROR `await` is a keyword in the 2018 edition\n+        //~^ WARN this was previously accepted by the compiler\n+    }\n+}\n+use outer_mod::await::await; //~ ERROR `await` is a keyword in the 2018 edition\n+//~^ ERROR `await` is a keyword in the 2018 edition\n+//~^^ WARN this was previously accepted by the compiler\n+//~^^^ WARN this was previously accepted by the compiler\n+\n+struct Foo { await: () }\n+//~^ ERROR `await` is a keyword in the 2018 edition\n+//~^^ WARN this was previously accepted by the compiler\n+\n+impl Foo { fn await() {} }\n+//~^ ERROR `await` is a keyword in the 2018 edition\n+//~^^ WARN this was previously accepted by the compiler\n+\n+macro_rules! await {\n+//~^ ERROR `await` is a keyword in the 2018 edition\n+//~^^ WARN this was previously accepted by the compiler\n+    () => {}\n+}\n+\n+fn main() {\n+    match await { await => {} } //~ ERROR `await` is a keyword in the 2018 edition\n+    //~^ ERROR `await` is a keyword in the 2018 edition\n+    //~^^ WARN this was previously accepted by the compiler\n+    //~^^^ WARN this was previously accepted by the compiler\n+}"}, {"sha": "067ecd6a5138d0313f519d325ede6749b000d870", "filename": "src/test/ui/await-keyword/2015-edition-error-in-non-macro-position.stderr", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94/src%2Ftest%2Fui%2Fawait-keyword%2F2015-edition-error-in-non-macro-position.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94/src%2Ftest%2Fui%2Fawait-keyword%2F2015-edition-error-in-non-macro-position.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fawait-keyword%2F2015-edition-error-in-non-macro-position.stderr?ref=33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94", "patch": "@@ -0,0 +1,88 @@\n+error: `await` is a keyword in the 2018 edition\n+  --> $DIR/2015-edition-error-in-non-macro-position.rs:6:13\n+   |\n+LL |     pub mod await {\n+   |             ^^^^^ help: you can use a raw identifier to stay compatible: `r#await`\n+   |\n+note: lint level defined here\n+  --> $DIR/2015-edition-error-in-non-macro-position.rs:3:9\n+   |\n+LL | #![deny(keyword_idents)]\n+   |         ^^^^^^^^^^^^^^\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in the 2018 edition!\n+   = note: for more information, see issue #49716 <https://github.com/rust-lang/rust/issues/49716>\n+\n+error: `await` is a keyword in the 2018 edition\n+  --> $DIR/2015-edition-error-in-non-macro-position.rs:8:20\n+   |\n+LL |         pub struct await;\n+   |                    ^^^^^ help: you can use a raw identifier to stay compatible: `r#await`\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in the 2018 edition!\n+   = note: for more information, see issue #49716 <https://github.com/rust-lang/rust/issues/49716>\n+\n+error: `await` is a keyword in the 2018 edition\n+  --> $DIR/2015-edition-error-in-non-macro-position.rs:12:16\n+   |\n+LL | use outer_mod::await::await;\n+   |                ^^^^^ help: you can use a raw identifier to stay compatible: `r#await`\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in the 2018 edition!\n+   = note: for more information, see issue #49716 <https://github.com/rust-lang/rust/issues/49716>\n+\n+error: `await` is a keyword in the 2018 edition\n+  --> $DIR/2015-edition-error-in-non-macro-position.rs:12:23\n+   |\n+LL | use outer_mod::await::await;\n+   |                       ^^^^^ help: you can use a raw identifier to stay compatible: `r#await`\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in the 2018 edition!\n+   = note: for more information, see issue #49716 <https://github.com/rust-lang/rust/issues/49716>\n+\n+error: `await` is a keyword in the 2018 edition\n+  --> $DIR/2015-edition-error-in-non-macro-position.rs:17:14\n+   |\n+LL | struct Foo { await: () }\n+   |              ^^^^^ help: you can use a raw identifier to stay compatible: `r#await`\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in the 2018 edition!\n+   = note: for more information, see issue #49716 <https://github.com/rust-lang/rust/issues/49716>\n+\n+error: `await` is a keyword in the 2018 edition\n+  --> $DIR/2015-edition-error-in-non-macro-position.rs:21:15\n+   |\n+LL | impl Foo { fn await() {} }\n+   |               ^^^^^ help: you can use a raw identifier to stay compatible: `r#await`\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in the 2018 edition!\n+   = note: for more information, see issue #49716 <https://github.com/rust-lang/rust/issues/49716>\n+\n+error: `await` is a keyword in the 2018 edition\n+  --> $DIR/2015-edition-error-in-non-macro-position.rs:25:14\n+   |\n+LL | macro_rules! await {\n+   |              ^^^^^ help: you can use a raw identifier to stay compatible: `r#await`\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in the 2018 edition!\n+   = note: for more information, see issue #49716 <https://github.com/rust-lang/rust/issues/49716>\n+\n+error: `await` is a keyword in the 2018 edition\n+  --> $DIR/2015-edition-error-in-non-macro-position.rs:32:11\n+   |\n+LL |     match await { await => {} }\n+   |           ^^^^^ help: you can use a raw identifier to stay compatible: `r#await`\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in the 2018 edition!\n+   = note: for more information, see issue #49716 <https://github.com/rust-lang/rust/issues/49716>\n+\n+error: `await` is a keyword in the 2018 edition\n+  --> $DIR/2015-edition-error-in-non-macro-position.rs:32:19\n+   |\n+LL |     match await { await => {} }\n+   |                   ^^^^^ help: you can use a raw identifier to stay compatible: `r#await`\n+   |\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in the 2018 edition!\n+   = note: for more information, see issue #49716 <https://github.com/rust-lang/rust/issues/49716>\n+\n+error: aborting due to 9 previous errors\n+"}, {"sha": "92c60e7d6eed01a35f9b4a2567e3d42b81ebbaed", "filename": "src/test/ui/await-keyword/2015-edition-no-warnings-with-feature-gate.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cfdc84a009020c59e53e4039beae22eb59e41685/src%2Ftest%2Fui%2Fawait-keyword%2F2015-edition-no-warnings-with-feature-gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdc84a009020c59e53e4039beae22eb59e41685/src%2Ftest%2Fui%2Fawait-keyword%2F2015-edition-no-warnings-with-feature-gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fawait-keyword%2F2015-edition-no-warnings-with-feature-gate.rs?ref=cfdc84a009020c59e53e4039beae22eb59e41685", "patch": "@@ -1,16 +0,0 @@\n-// compile-pass\n-\n-#![feature(async_await)]\n-#![allow(non_camel_case_types)]\n-#![deny(keyword_idents)]\n-\n-mod outer_mod {\n-    pub mod await {\n-        pub struct await;\n-    }\n-}\n-use outer_mod::await::await;\n-\n-fn main() {\n-    match await { await => {} }\n-}"}, {"sha": "b2e8e4be172448ec1992086156e90fd13709e049", "filename": "src/test/ui/await-keyword/2018-edition-error-in-non-macro-position.rs", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94/src%2Ftest%2Fui%2Fawait-keyword%2F2018-edition-error-in-non-macro-position.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94/src%2Ftest%2Fui%2Fawait-keyword%2F2018-edition-error-in-non-macro-position.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fawait-keyword%2F2018-edition-error-in-non-macro-position.rs?ref=33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94", "patch": "@@ -0,0 +1,27 @@\n+// edition:2018\n+\n+#![allow(non_camel_case_types)]\n+#![feature(async_await, await_macro)]\n+\n+mod outer_mod {\n+    pub mod await { //~ ERROR expected identifier, found reserved keyword `await`\n+        pub struct await; //~ ERROR expected identifier, found reserved keyword `await`\n+    }\n+}\n+use self::outer_mod::await::await; //~ ERROR expected identifier, found reserved keyword `await`\n+//~^ ERROR expected identifier, found reserved keyword `await`\n+\n+struct Foo { await: () }\n+//~^ ERROR expected identifier, found reserved keyword `await`\n+\n+impl Foo { fn await() {} }\n+//~^ ERROR expected identifier, found reserved keyword `await`\n+\n+macro_rules! await {\n+//~^ ERROR expected identifier, found reserved keyword `await`\n+    () => {}\n+}\n+\n+fn main() {\n+    match await { await => () } //~ ERROR expected `!`, found `{`\n+}"}, {"sha": "076a31bd9ced67fc1180c74ca2aab2ba2ec182b1", "filename": "src/test/ui/await-keyword/2018-edition-error-in-non-macro-position.stderr", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94/src%2Ftest%2Fui%2Fawait-keyword%2F2018-edition-error-in-non-macro-position.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94/src%2Ftest%2Fui%2Fawait-keyword%2F2018-edition-error-in-non-macro-position.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fawait-keyword%2F2018-edition-error-in-non-macro-position.stderr?ref=33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94", "patch": "@@ -0,0 +1,80 @@\n+error: expected identifier, found reserved keyword `await`\n+  --> $DIR/2018-edition-error-in-non-macro-position.rs:7:13\n+   |\n+LL |     pub mod await {\n+   |             ^^^^^ expected identifier, found reserved keyword\n+help: you can escape reserved keywords to use them as identifiers\n+   |\n+LL |     pub mod r#await {\n+   |             ^^^^^^^\n+\n+error: expected identifier, found reserved keyword `await`\n+  --> $DIR/2018-edition-error-in-non-macro-position.rs:8:20\n+   |\n+LL |         pub struct await;\n+   |                    ^^^^^ expected identifier, found reserved keyword\n+help: you can escape reserved keywords to use them as identifiers\n+   |\n+LL |         pub struct r#await;\n+   |                    ^^^^^^^\n+\n+error: expected identifier, found reserved keyword `await`\n+  --> $DIR/2018-edition-error-in-non-macro-position.rs:11:22\n+   |\n+LL | use self::outer_mod::await::await;\n+   |                      ^^^^^ expected identifier, found reserved keyword\n+help: you can escape reserved keywords to use them as identifiers\n+   |\n+LL | use self::outer_mod::r#await::await;\n+   |                      ^^^^^^^\n+\n+error: expected identifier, found reserved keyword `await`\n+  --> $DIR/2018-edition-error-in-non-macro-position.rs:11:29\n+   |\n+LL | use self::outer_mod::await::await;\n+   |                             ^^^^^ expected identifier, found reserved keyword\n+help: you can escape reserved keywords to use them as identifiers\n+   |\n+LL | use self::outer_mod::await::r#await;\n+   |                             ^^^^^^^\n+\n+error: expected identifier, found reserved keyword `await`\n+  --> $DIR/2018-edition-error-in-non-macro-position.rs:14:14\n+   |\n+LL | struct Foo { await: () }\n+   |              ^^^^^ expected identifier, found reserved keyword\n+help: you can escape reserved keywords to use them as identifiers\n+   |\n+LL | struct Foo { r#await: () }\n+   |              ^^^^^^^\n+\n+error: expected identifier, found reserved keyword `await`\n+  --> $DIR/2018-edition-error-in-non-macro-position.rs:17:15\n+   |\n+LL | impl Foo { fn await() {} }\n+   |               ^^^^^ expected identifier, found reserved keyword\n+help: you can escape reserved keywords to use them as identifiers\n+   |\n+LL | impl Foo { fn r#await() {} }\n+   |               ^^^^^^^\n+\n+error: expected identifier, found reserved keyword `await`\n+  --> $DIR/2018-edition-error-in-non-macro-position.rs:20:14\n+   |\n+LL | macro_rules! await {\n+   |              ^^^^^ expected identifier, found reserved keyword\n+help: you can escape reserved keywords to use them as identifiers\n+   |\n+LL | macro_rules! r#await {\n+   |              ^^^^^^^\n+\n+error: expected `!`, found `{`\n+  --> $DIR/2018-edition-error-in-non-macro-position.rs:26:17\n+   |\n+LL |     match await { await => () }\n+   |     -----       ^ expected `!`\n+   |     |\n+   |     while parsing this match expression\n+\n+error: aborting due to 8 previous errors\n+"}, {"sha": "e0b2962ce9791975acab3dc4bb0d8f7c6c0fd71d", "filename": "src/test/ui/await-keyword/2018-edition-error.rs", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94/src%2Ftest%2Fui%2Fawait-keyword%2F2018-edition-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94/src%2Ftest%2Fui%2Fawait-keyword%2F2018-edition-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fawait-keyword%2F2018-edition-error.rs?ref=33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94", "patch": "@@ -2,14 +2,13 @@\n #![allow(non_camel_case_types)]\n \n mod outer_mod {\n-    pub mod await { //~ ERROR `await` is a keyword\n-        pub struct await; //~ ERROR `await` is a keyword\n+    pub mod await { //~ ERROR expected identifier\n+        pub struct await; //~ ERROR expected identifier\n     }\n }\n-use self::outer_mod::await::await; //~ ERROR `await` is a keyword\n-    //~^ ERROR `await` is a keyword\n+use self::outer_mod::await::await; //~ ERROR expected identifier\n+    //~^ ERROR expected identifier, found reserved keyword `await`\n \n fn main() {\n-    match await { await => () } //~ ERROR `await` is a keyword\n-    //~^ ERROR `await` is a keyword\n+    match await { await => () } //~ ERROR expected `!`, found `{`\n }"}, {"sha": "c8bf9b42ca5459f1b28e86c23135ef44d39659c9", "filename": "src/test/ui/await-keyword/2018-edition-error.stderr", "status": "modified", "additions": 29, "deletions": 17, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94/src%2Ftest%2Fui%2Fawait-keyword%2F2018-edition-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94/src%2Ftest%2Fui%2Fawait-keyword%2F2018-edition-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fawait-keyword%2F2018-edition-error.stderr?ref=33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94", "patch": "@@ -1,38 +1,50 @@\n-error[E0721]: `await` is a keyword in the 2018 edition\n+error: expected identifier, found reserved keyword `await`\n   --> $DIR/2018-edition-error.rs:5:13\n    |\n LL |     pub mod await {\n-   |             ^^^^^ help: you can use a raw identifier to stay compatible: `r#await`\n+   |             ^^^^^ expected identifier, found reserved keyword\n+help: you can escape reserved keywords to use them as identifiers\n+   |\n+LL |     pub mod r#await {\n+   |             ^^^^^^^\n \n-error[E0721]: `await` is a keyword in the 2018 edition\n+error: expected identifier, found reserved keyword `await`\n   --> $DIR/2018-edition-error.rs:6:20\n    |\n LL |         pub struct await;\n-   |                    ^^^^^ help: you can use a raw identifier to stay compatible: `r#await`\n+   |                    ^^^^^ expected identifier, found reserved keyword\n+help: you can escape reserved keywords to use them as identifiers\n+   |\n+LL |         pub struct r#await;\n+   |                    ^^^^^^^\n \n-error[E0721]: `await` is a keyword in the 2018 edition\n+error: expected identifier, found reserved keyword `await`\n   --> $DIR/2018-edition-error.rs:9:22\n    |\n LL | use self::outer_mod::await::await;\n-   |                      ^^^^^ help: you can use a raw identifier to stay compatible: `r#await`\n+   |                      ^^^^^ expected identifier, found reserved keyword\n+help: you can escape reserved keywords to use them as identifiers\n+   |\n+LL | use self::outer_mod::r#await::await;\n+   |                      ^^^^^^^\n \n-error[E0721]: `await` is a keyword in the 2018 edition\n+error: expected identifier, found reserved keyword `await`\n   --> $DIR/2018-edition-error.rs:9:29\n    |\n LL | use self::outer_mod::await::await;\n-   |                             ^^^^^ help: you can use a raw identifier to stay compatible: `r#await`\n-\n-error[E0721]: `await` is a keyword in the 2018 edition\n-  --> $DIR/2018-edition-error.rs:13:11\n+   |                             ^^^^^ expected identifier, found reserved keyword\n+help: you can escape reserved keywords to use them as identifiers\n    |\n-LL |     match await { await => () }\n-   |           ^^^^^ help: you can use a raw identifier to stay compatible: `r#await`\n+LL | use self::outer_mod::await::r#await;\n+   |                             ^^^^^^^\n \n-error[E0721]: `await` is a keyword in the 2018 edition\n-  --> $DIR/2018-edition-error.rs:13:19\n+error: expected `!`, found `{`\n+  --> $DIR/2018-edition-error.rs:13:17\n    |\n LL |     match await { await => () }\n-   |                   ^^^^^ help: you can use a raw identifier to stay compatible: `r#await`\n+   |     -----       ^ expected `!`\n+   |     |\n+   |     while parsing this match expression\n \n-error: aborting due to 6 previous errors\n+error: aborting due to 5 previous errors\n "}, {"sha": "52d32c8351080a4a3328f65f5abaa6fd6e411a12", "filename": "src/test/ui/await-keyword/2018-edition-no-error-with-feature-gate.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cfdc84a009020c59e53e4039beae22eb59e41685/src%2Ftest%2Fui%2Fawait-keyword%2F2018-edition-no-error-with-feature-gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cfdc84a009020c59e53e4039beae22eb59e41685/src%2Ftest%2Fui%2Fawait-keyword%2F2018-edition-no-error-with-feature-gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fawait-keyword%2F2018-edition-no-error-with-feature-gate.rs?ref=cfdc84a009020c59e53e4039beae22eb59e41685", "patch": "@@ -1,16 +0,0 @@\n-// compile-pass\n-// edition:2018\n-\n-#![allow(non_camel_case_types)]\n-#![feature(async_await)]\n-\n-mod outer_mod {\n-    pub mod await {\n-        pub struct await;\n-    }\n-}\n-use self::outer_mod::await::await;\n-\n-fn main() {\n-    match await { await => () }\n-}"}, {"sha": "b4c899b0d0295b6b77b0fd45a5b0640dd51ad754", "filename": "src/test/ui/await-keyword/post_expansion_error.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94/src%2Ftest%2Fui%2Fawait-keyword%2Fpost_expansion_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94/src%2Ftest%2Fui%2Fawait-keyword%2Fpost_expansion_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fawait-keyword%2Fpost_expansion_error.rs?ref=33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94", "patch": "@@ -6,5 +6,5 @@ macro_rules! r#await {\n \n fn main() {\n     await!()\n-    //~^ ERROR `await` is a keyword\n+    //~^ ERROR expected expression, found `)`\n }"}, {"sha": "0996c38b3b6c61f18efcbefa970c498b3457bf8b", "filename": "src/test/ui/await-keyword/post_expansion_error.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94/src%2Ftest%2Fui%2Fawait-keyword%2Fpost_expansion_error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94/src%2Ftest%2Fui%2Fawait-keyword%2Fpost_expansion_error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fawait-keyword%2Fpost_expansion_error.stderr?ref=33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94", "patch": "@@ -1,8 +1,8 @@\n-error[E0721]: `await` is a keyword in the 2018 edition\n-  --> $DIR/post_expansion_error.rs:8:5\n+error: expected expression, found `)`\n+  --> $DIR/post_expansion_error.rs:8:12\n    |\n LL |     await!()\n-   |     ^^^^^ help: you can use a raw identifier to stay compatible: `r#await`\n+   |            ^ expected expression\n \n error: aborting due to previous error\n "}, {"sha": "291db9ba41370637b608f5981a73b3d12b2c50cc", "filename": "src/test/ui/feature-gate/await-macro.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94/src%2Ftest%2Fui%2Ffeature-gate%2Fawait-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94/src%2Ftest%2Fui%2Ffeature-gate%2Fawait-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate%2Fawait-macro.rs?ref=33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94", "patch": "@@ -0,0 +1,12 @@\n+// gate-test-await_macro\n+// edition:2018\n+\n+#![feature(async_await)]\n+\n+async fn bar() {}\n+\n+async fn foo() {\n+    await!(bar()); //~ ERROR `await!(<expr>)` macro syntax is unstable, and will soon be removed\n+}\n+\n+fn main() {}"}, {"sha": "b6833655f6d8aa3462293058494097cc0e5325fc", "filename": "src/test/ui/feature-gate/await-macro.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94/src%2Ftest%2Fui%2Ffeature-gate%2Fawait-macro.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94/src%2Ftest%2Fui%2Ffeature-gate%2Fawait-macro.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gate%2Fawait-macro.stderr?ref=33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94", "patch": "@@ -0,0 +1,12 @@\n+error[E0658]: `await!(<expr>)` macro syntax is unstable, and will soon be removed in favor of `<expr>.await` syntax.\n+  --> $DIR/await-macro.rs:9:5\n+   |\n+LL |     await!(bar());\n+   |     ^^^^^\n+   |\n+   = note: for more information, see https://github.com/rust-lang/rust/issues/50547\n+   = help: add #![feature(await_macro)] to the crate attributes to enable\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "77174b03217829661093ca8b391bd0f7210489be", "filename": "src/test/ui/generator/unresolved_type_param.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94/src%2Ftest%2Fui%2Fgenerator%2Funresolved_type_param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94/src%2Ftest%2Fui%2Fgenerator%2Funresolved_type_param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Funresolved_type_param.rs?ref=33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94", "patch": "@@ -2,13 +2,14 @@\n // Error message should pinpoint the type parameter T as needing to be bound\n // (rather than give a general error message)\n // edition:2018\n-#![feature(futures_api, async_await, await_macro)]\n+#![feature(async_await)]\n async fn bar<T>() -> () {}\n \n async fn foo() {\n-        await!(bar());\n-        //~^ ERROR type inside generator must be known in this context\n-        //~| NOTE cannot infer type for `T`\n-        //~| NOTE the type is part of the generator because of this `yield`\n+    bar().await;\n+    //~^ ERROR type inside generator must be known in this context\n+    //~| NOTE cannot infer type for `T`\n+    //~| NOTE the type is part of the generator because of this `yield`\n+    //~| NOTE in this expansion of desugaring of `await`\n }\n fn main() {}"}, {"sha": "afb9adf4c77cc019005117079f9577d23f90192e", "filename": "src/test/ui/generator/unresolved_type_param.stderr", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94/src%2Ftest%2Fui%2Fgenerator%2Funresolved_type_param.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94/src%2Ftest%2Fui%2Fgenerator%2Funresolved_type_param.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fgenerator%2Funresolved_type_param.stderr?ref=33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94", "patch": "@@ -1,15 +1,14 @@\n error[E0698]: type inside generator must be known in this context\n-  --> $DIR/unresolved_type_param.rs:9:16\n+  --> $DIR/unresolved_type_param.rs:9:5\n    |\n-LL |         await!(bar());\n-   |                ^^^ cannot infer type for `T`\n+LL |     bar().await;\n+   |     ^^^ cannot infer type for `T`\n    |\n note: the type is part of the generator because of this `yield`\n-  --> $DIR/unresolved_type_param.rs:9:9\n+  --> $DIR/unresolved_type_param.rs:9:5\n    |\n-LL |         await!(bar());\n-   |         ^^^^^^^^^^^^^^\n-   = note: this error originates in a macro outside of the current crate (in Nightly builds, run with -Z external-macro-backtrace for more info)\n+LL |     bar().await;\n+   |     ^^^^^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "2c02ac01142bb41bba228045bfae17087e1e9388", "filename": "src/test/ui/issues/issue-51719.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94/src%2Ftest%2Fui%2Fissues%2Fissue-51719.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94/src%2Ftest%2Fui%2Fissues%2Fissue-51719.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-51719.rs?ref=33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94", "patch": "@@ -0,0 +1,11 @@\n+// edition:2018\n+//\n+// Tests that the .await syntax can't be used to make a generator\n+\n+#![feature(async_await)]\n+\n+async fn foo() {}\n+\n+fn make_generator() {\n+    let _gen = || foo.await; //~ ERROR `await` is only allowed inside `async` functions and blocks\n+}"}, {"sha": "768909b66ec7746d566cf387e8c05c0f1c812605", "filename": "src/test/ui/issues/issue-51719.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94/src%2Ftest%2Fui%2Fissues%2Fissue-51719.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94/src%2Ftest%2Fui%2Fissues%2Fissue-51719.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-51719.stderr?ref=33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94", "patch": "@@ -0,0 +1,8 @@\n+error[E0728]: `await` is only allowed inside `async` functions and blocks\n+  --> $DIR/issue-51719.rs:10:19\n+   |\n+LL |     let _gen = || foo.await;\n+   |                   ^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}, {"sha": "7afd7ecc826499b5b8a73738dfe771fb5c09566e", "filename": "src/test/ui/issues/issue-51751.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94/src%2Ftest%2Fui%2Fissues%2Fissue-51751.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94/src%2Ftest%2Fui%2Fissues%2Fissue-51751.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-51751.rs?ref=33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94", "patch": "@@ -0,0 +1,13 @@\n+// edition:2018\n+\n+#![feature(async_await)]\n+\n+async fn inc(limit: i64) -> i64 {\n+    limit + 1\n+}\n+\n+fn main() {\n+    let result = inc(10000);\n+    let finished = result.await;\n+    //~^ ERROR `await` is only allowed inside `async` functions and blocks\n+}"}, {"sha": "0c4cb034a9381df44ccd9a203ef73250ff7776f9", "filename": "src/test/ui/issues/issue-51751.stderr", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94/src%2Ftest%2Fui%2Fissues%2Fissue-51751.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94/src%2Ftest%2Fui%2Fissues%2Fissue-51751.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-51751.stderr?ref=33cde4aac2ec1b0a493d0acaa4c4fb45de0c6e94", "patch": "@@ -0,0 +1,8 @@\n+error[E0728]: `await` is only allowed inside `async` functions and blocks\n+  --> $DIR/issue-51751.rs:11:20\n+   |\n+LL |     let finished = result.await;\n+   |                    ^^^^^^^^^^^^\n+\n+error: aborting due to previous error\n+"}]}