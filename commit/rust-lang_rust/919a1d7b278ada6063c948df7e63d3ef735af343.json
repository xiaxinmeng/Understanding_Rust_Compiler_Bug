{"sha": "919a1d7b278ada6063c948df7e63d3ef735af343", "node_id": "MDY6Q29tbWl0NzI0NzEyOjkxOWExZDdiMjc4YWRhNjA2M2M5NDhkZjdlNjNkM2VmNzM1YWYzNDM=", "commit": {"author": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-01-09T15:59:00Z"}, "committer": {"name": "Lukas Wirth", "email": "lukastw97@gmail.com", "date": "2021-01-09T15:59:00Z"}, "message": "Refactor rename name checking", "tree": {"sha": "ea173bf3754294e1b9dd9836a760d0a90a495d18", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ea173bf3754294e1b9dd9836a760d0a90a495d18"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/919a1d7b278ada6063c948df7e63d3ef735af343", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/919a1d7b278ada6063c948df7e63d3ef735af343", "html_url": "https://github.com/rust-lang/rust/commit/919a1d7b278ada6063c948df7e63d3ef735af343", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/919a1d7b278ada6063c948df7e63d3ef735af343/comments", "author": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Veykril", "id": 3757771, "node_id": "MDQ6VXNlcjM3NTc3NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/3757771?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Veykril", "html_url": "https://github.com/Veykril", "followers_url": "https://api.github.com/users/Veykril/followers", "following_url": "https://api.github.com/users/Veykril/following{/other_user}", "gists_url": "https://api.github.com/users/Veykril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Veykril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Veykril/subscriptions", "organizations_url": "https://api.github.com/users/Veykril/orgs", "repos_url": "https://api.github.com/users/Veykril/repos", "events_url": "https://api.github.com/users/Veykril/events{/privacy}", "received_events_url": "https://api.github.com/users/Veykril/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "939ca83b34f9a5648d196f85e5cc7d844ba22604", "url": "https://api.github.com/repos/rust-lang/rust/commits/939ca83b34f9a5648d196f85e5cc7d844ba22604", "html_url": "https://github.com/rust-lang/rust/commit/939ca83b34f9a5648d196f85e5cc7d844ba22604"}], "stats": {"total": 163, "additions": 104, "deletions": 59}, "files": [{"sha": "88d215129b2d5cc261c11ec56b63e6c387698f4b", "filename": "crates/ide/src/hover.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/919a1d7b278ada6063c948df7e63d3ef735af343/crates%2Fide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/919a1d7b278ada6063c948df7e63d3ef735af343/crates%2Fide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover.rs?ref=919a1d7b278ada6063c948df7e63d3ef735af343", "patch": "@@ -175,12 +175,7 @@ fn show_implementations_action(db: &RootDatabase, def: Definition) -> Option<Hov\n         Definition::SelfType(it) => it.target_ty(db).as_adt(),\n         _ => None,\n     }?;\n-    match adt {\n-        Adt::Struct(it) => it.try_to_nav(db),\n-        Adt::Union(it) => it.try_to_nav(db),\n-        Adt::Enum(it) => it.try_to_nav(db),\n-    }\n-    .map(to_action)\n+    adt.try_to_nav(db).map(to_action)\n }\n \n fn runnable_action("}, {"sha": "dd322631b3539715c225b66d51d40741b75d84aa", "filename": "crates/ide/src/references/rename.rs", "status": "modified", "additions": 103, "deletions": 53, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/919a1d7b278ada6063c948df7e63d3ef735af343/crates%2Fide%2Fsrc%2Freferences%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/919a1d7b278ada6063c948df7e63d3ef735af343/crates%2Fide%2Fsrc%2Freferences%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Freferences%2Frename.rs?ref=919a1d7b278ada6063c948df7e63d3ef735af343", "patch": "@@ -20,10 +20,11 @@ use test_utils::mark;\n use text_edit::TextEdit;\n \n use crate::{\n-    references::find_all_refs, FilePosition, FileSystemEdit, RangeInfo, Reference, ReferenceKind,\n+    FilePosition, FileSystemEdit, RangeInfo, Reference, ReferenceKind, ReferenceSearchResult,\n     SourceChange, SourceFileEdit, TextRange, TextSize,\n };\n \n+type RenameResult<T> = Result<T, RenameError>;\n #[derive(Debug)]\n pub struct RenameError(pub(crate) String);\n \n@@ -38,7 +39,7 @@ impl Error for RenameError {}\n pub(crate) fn prepare_rename(\n     db: &RootDatabase,\n     position: FilePosition,\n-) -> Result<RangeInfo<()>, RenameError> {\n+) -> RenameResult<RangeInfo<()>> {\n     let sema = Semantics::new(db);\n     let source_file = sema.parse(position.file_id);\n     let syntax = source_file.syntax();\n@@ -49,10 +50,7 @@ pub(crate) fn prepare_rename(\n     {\n         rename_self_to_param(&sema, position, self_token, \"dummy\")\n     } else {\n-        let range = match find_all_refs(&sema, position, None) {\n-            Some(RangeInfo { range, .. }) => range,\n-            None => return Err(RenameError(\"No references found at position\".to_string())),\n-        };\n+        let RangeInfo { range, .. } = find_all_refs(&sema, position)?;\n         Ok(RangeInfo::new(range, SourceChange::from(vec![])))\n     }\n     .map(|info| RangeInfo::new(info.range, ()))\n@@ -62,7 +60,7 @@ pub(crate) fn rename(\n     db: &RootDatabase,\n     position: FilePosition,\n     new_name: &str,\n-) -> Result<RangeInfo<SourceChange>, RenameError> {\n+) -> RenameResult<RangeInfo<SourceChange>> {\n     let sema = Semantics::new(db);\n     rename_with_semantics(&sema, position, new_name)\n }\n@@ -71,42 +69,18 @@ pub(crate) fn rename_with_semantics(\n     sema: &Semantics<RootDatabase>,\n     position: FilePosition,\n     new_name: &str,\n-) -> Result<RangeInfo<SourceChange>, RenameError> {\n-    let is_lifetime_name = match lex_single_syntax_kind(new_name) {\n-        Some(res) => match res {\n-            (SyntaxKind::IDENT, _) => false,\n-            (SyntaxKind::UNDERSCORE, _) => false,\n-            (SyntaxKind::SELF_KW, _) => return rename_to_self(&sema, position),\n-            (SyntaxKind::LIFETIME_IDENT, _) if new_name != \"'static\" && new_name != \"'_\" => true,\n-            (SyntaxKind::LIFETIME_IDENT, _) => {\n-                return Err(RenameError(format!(\n-                    \"Invalid name `{0}`: Cannot rename lifetime to {0}\",\n-                    new_name\n-                )))\n-            }\n-            (_, Some(syntax_error)) => {\n-                return Err(RenameError(format!(\"Invalid name `{}`: {}\", new_name, syntax_error)))\n-            }\n-            (_, None) => {\n-                return Err(RenameError(format!(\"Invalid name `{}`: not an identifier\", new_name)))\n-            }\n-        },\n-        None => return Err(RenameError(format!(\"Invalid name `{}`: not an identifier\", new_name))),\n-    };\n-\n+) -> RenameResult<RangeInfo<SourceChange>> {\n     let source_file = sema.parse(position.file_id);\n     let syntax = source_file.syntax();\n-    // this is here to prevent lifetime renames from happening on modules and self\n-    if is_lifetime_name {\n-        rename_reference(&sema, position, new_name, is_lifetime_name)\n-    } else if let Some(module) = find_module_at_offset(&sema, position, syntax) {\n+\n+    if let Some(module) = find_module_at_offset(&sema, position, syntax) {\n         rename_mod(&sema, position, module, new_name)\n     } else if let Some(self_token) =\n         syntax.token_at_offset(position.offset).find(|t| t.kind() == SyntaxKind::SELF_KW)\n     {\n         rename_self_to_param(&sema, position, self_token, new_name)\n     } else {\n-        rename_reference(&sema, position, new_name, is_lifetime_name)\n+        rename_reference(&sema, position, new_name)\n     }\n }\n \n@@ -127,6 +101,36 @@ pub(crate) fn will_rename_file(\n     Some(change)\n }\n \n+#[derive(PartialEq)]\n+enum IdentifierKind {\n+    Ident,\n+    Lifetime,\n+    ToSelf,\n+    Underscore,\n+}\n+\n+fn check_identifier(new_name: &str) -> RenameResult<IdentifierKind> {\n+    match lex_single_syntax_kind(new_name) {\n+        Some(res) => match res {\n+            (SyntaxKind::IDENT, _) => Ok(IdentifierKind::Ident),\n+            (SyntaxKind::UNDERSCORE, _) => Ok(IdentifierKind::Underscore),\n+            (SyntaxKind::SELF_KW, _) => Ok(IdentifierKind::ToSelf),\n+            (SyntaxKind::LIFETIME_IDENT, _) if new_name != \"'static\" && new_name != \"'_\" => {\n+                Ok(IdentifierKind::Lifetime)\n+            }\n+            (SyntaxKind::LIFETIME_IDENT, _) => {\n+                Err(format!(\"Invalid name `{0}`: Cannot rename lifetime to {0}\", new_name))\n+            }\n+            (_, Some(syntax_error)) => {\n+                Err(format!(\"Invalid name `{}`: {}\", new_name, syntax_error))\n+            }\n+            (_, None) => Err(format!(\"Invalid name `{}`: not an identifier\", new_name)),\n+        },\n+        None => Err(format!(\"Invalid name `{}`: not an identifier\", new_name)),\n+    }\n+    .map_err(RenameError)\n+}\n+\n fn find_module_at_offset(\n     sema: &Semantics<RootDatabase>,\n     position: FilePosition,\n@@ -155,6 +159,14 @@ fn find_module_at_offset(\n     Some(module)\n }\n \n+fn find_all_refs(\n+    sema: &Semantics<RootDatabase>,\n+    position: FilePosition,\n+) -> RenameResult<RangeInfo<ReferenceSearchResult>> {\n+    crate::references::find_all_refs(sema, position, None)\n+        .ok_or_else(|| RenameError(\"No references found at position\".to_string()))\n+}\n+\n fn source_edit_from_reference(\n     sema: &Semantics<RootDatabase>,\n     reference: Reference,\n@@ -223,7 +235,13 @@ fn rename_mod(\n     position: FilePosition,\n     module: Module,\n     new_name: &str,\n-) -> Result<RangeInfo<SourceChange>, RenameError> {\n+) -> RenameResult<RangeInfo<SourceChange>> {\n+    if IdentifierKind::Ident != check_identifier(new_name)? {\n+        return Err(RenameError(format!(\n+            \"Invalid name `{0}`: cannot rename module to {0}\",\n+            new_name\n+        )));\n+    }\n     let mut source_file_edits = Vec::new();\n     let mut file_system_edits = Vec::new();\n \n@@ -254,8 +272,7 @@ fn rename_mod(\n         source_file_edits.push(edit);\n     }\n \n-    let RangeInfo { range, info: refs } = find_all_refs(sema, position, None)\n-        .ok_or_else(|| RenameError(\"No references found at position\".to_string()))?;\n+    let RangeInfo { range, info: refs } = find_all_refs(sema, position)?;\n     let ref_edits = refs\n         .references\n         .into_iter()\n@@ -310,8 +327,7 @@ fn rename_to_self(\n         return Err(RenameError(\"Parameter type differs from impl block type\".to_string()));\n     }\n \n-    let RangeInfo { range, info: refs } = find_all_refs(sema, position, None)\n-        .ok_or_else(|| RenameError(\"No reference found at position\".to_string()))?;\n+    let RangeInfo { range, info: refs } = find_all_refs(sema, position)?;\n \n     let (param_ref, usages): (Vec<Reference>, Vec<Reference>) = refs\n         .into_iter()\n@@ -367,6 +383,17 @@ fn rename_self_to_param(\n     self_token: SyntaxToken,\n     new_name: &str,\n ) -> Result<RangeInfo<SourceChange>, RenameError> {\n+    let ident_kind = check_identifier(new_name)?;\n+    match ident_kind {\n+        IdentifierKind::Lifetime => {\n+            return Err(RenameError(format!(\"Invalid name `{}`: not an identifier\", new_name)))\n+        }\n+        IdentifierKind::ToSelf => {\n+            // no-op\n+            return Ok(RangeInfo::new(self_token.text_range(), SourceChange::default()));\n+        }\n+        _ => (),\n+    }\n     let source_file = sema.parse(position.file_id);\n     let syn = source_file.syntax();\n \n@@ -395,6 +422,12 @@ fn rename_self_to_param(\n         }\n     }\n \n+    if edits.len() > 1 && ident_kind == IdentifierKind::Underscore {\n+        return Err(RenameError(format!(\n+            \"Cannot rename reference to `_` as it is being referenced multiple times\",\n+        )));\n+    }\n+\n     let range = ast::SelfParam::cast(self_token.parent())\n         .map_or(self_token.text_range(), |p| p.syntax().text_range());\n \n@@ -405,35 +438,43 @@ fn rename_reference(\n     sema: &Semantics<RootDatabase>,\n     position: FilePosition,\n     new_name: &str,\n-    is_lifetime_name: bool,\n ) -> Result<RangeInfo<SourceChange>, RenameError> {\n-    let RangeInfo { range, info: refs } = match find_all_refs(sema, position, None) {\n-        Some(range_info) => range_info,\n-        None => return Err(RenameError(\"No references found at position\".to_string())),\n-    };\n+    let ident_kind = check_identifier(new_name)?;\n+    let RangeInfo { range, info: refs } = find_all_refs(sema, position)?;\n \n-    match (refs.declaration.kind == ReferenceKind::Lifetime, is_lifetime_name) {\n-        (true, false) => {\n+    match (ident_kind, &refs.declaration.kind) {\n+        (IdentifierKind::ToSelf, ReferenceKind::Lifetime)\n+        | (IdentifierKind::Underscore, ReferenceKind::Lifetime)\n+        | (IdentifierKind::Ident, ReferenceKind::Lifetime) => {\n             return Err(RenameError(format!(\n                 \"Invalid name `{}`: not a lifetime identifier\",\n                 new_name\n             )))\n         }\n-        (false, true) => {\n+        (IdentifierKind::Lifetime, ReferenceKind::Lifetime) => (),\n+        (IdentifierKind::Lifetime, _) => {\n             return Err(RenameError(format!(\"Invalid name `{}`: not an identifier\", new_name)))\n         }\n-        _ => (),\n+        (IdentifierKind::ToSelf, ReferenceKind::SelfKw) => {\n+            //no-op\n+            return Ok(RangeInfo::new(range, SourceChange::default()));\n+        }\n+        (IdentifierKind::ToSelf, _) => {\n+            return rename_to_self(sema, position);\n+        }\n+        (IdentifierKind::Underscore, _) if !refs.references.is_empty() => {\n+            return Err(RenameError(format!(\n+                \"Cannot rename reference to `_` as it is being referenced multiple times\",\n+            )))\n+        }\n+        (IdentifierKind::Ident, _) | (IdentifierKind::Underscore, _) => (),\n     }\n \n     let edit = refs\n         .into_iter()\n         .map(|reference| source_edit_from_reference(sema, reference, new_name))\n         .collect::<Vec<_>>();\n \n-    if edit.is_empty() {\n-        return Err(RenameError(\"No references found at position\".to_string()));\n-    }\n-\n     Ok(RangeInfo::new(range, SourceChange::from(edit)))\n }\n \n@@ -546,6 +587,15 @@ mod tests {\n         );\n     }\n \n+    #[test]\n+    fn test_rename_to_underscore_invalid() {\n+        check(\n+            \"_\",\n+            r#\"fn main(foo$0: ()) {foo;}\"#,\n+            \"error: Cannot rename reference to `_` as it is being referenced multiple times\",\n+        );\n+    }\n+\n     #[test]\n     fn test_rename_for_local() {\n         check("}]}