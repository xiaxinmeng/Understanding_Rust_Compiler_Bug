{"sha": "167e5dcad39cd12596ace6fce1ef06218e559542", "node_id": "C_kwDOAAsO6NoAKDE2N2U1ZGNhZDM5Y2QxMjU5NmFjZTZmY2UxZWYwNjIxOGU1NTk1NDI", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-20T20:11:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-20T20:11:10Z"}, "message": "Auto merge of #2403 - RalfJung:rustup, r=RalfJung\n\nrustup", "tree": {"sha": "1f93f013d93b3af8caf238e79651b16e6c8705d1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1f93f013d93b3af8caf238e79651b16e6c8705d1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/167e5dcad39cd12596ace6fce1ef06218e559542", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/167e5dcad39cd12596ace6fce1ef06218e559542", "html_url": "https://github.com/rust-lang/rust/commit/167e5dcad39cd12596ace6fce1ef06218e559542", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/167e5dcad39cd12596ace6fce1ef06218e559542/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7975391808105565247d876c4efcfb1e07e34fae", "url": "https://api.github.com/repos/rust-lang/rust/commits/7975391808105565247d876c4efcfb1e07e34fae", "html_url": "https://github.com/rust-lang/rust/commit/7975391808105565247d876c4efcfb1e07e34fae"}, {"sha": "ff4666f39cfa48d5a887a62f49c5f0c04b44642a", "url": "https://api.github.com/repos/rust-lang/rust/commits/ff4666f39cfa48d5a887a62f49c5f0c04b44642a", "html_url": "https://github.com/rust-lang/rust/commit/ff4666f39cfa48d5a887a62f49c5f0c04b44642a"}], "stats": {"total": 1147, "additions": 627, "deletions": 520}, "files": [{"sha": "f456ded7f4623b7313353417e34489ea7ab5e4f2", "filename": "rust-version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/167e5dcad39cd12596ace6fce1ef06218e559542/rust-version", "raw_url": "https://github.com/rust-lang/rust/raw/167e5dcad39cd12596ace6fce1ef06218e559542/rust-version", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rust-version?ref=167e5dcad39cd12596ace6fce1ef06218e559542", "patch": "@@ -1 +1 @@\n-29c5a028b0c92aa5da6a8eb6d6585a389fcf1035\n+a7468c60f8dbf5feb23ad840b174d7e57113a846"}, {"sha": "3f05925d343854c93bf2a3c506efed9a78fc5350", "filename": "src/concurrency/data_race.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/167e5dcad39cd12596ace6fce1ef06218e559542/src%2Fconcurrency%2Fdata_race.rs", "raw_url": "https://github.com/rust-lang/rust/raw/167e5dcad39cd12596ace6fce1ef06218e559542/src%2Fconcurrency%2Fdata_race.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconcurrency%2Fdata_race.rs?ref=167e5dcad39cd12596ace6fce1ef06218e559542", "patch": "@@ -439,11 +439,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n     /// Atomic variant of read_scalar_at_offset.\n     fn read_scalar_at_offset_atomic(\n         &self,\n-        op: &OpTy<'tcx, Tag>,\n+        op: &OpTy<'tcx, Provenance>,\n         offset: u64,\n         layout: TyAndLayout<'tcx>,\n         atomic: AtomicReadOrd,\n-    ) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n+    ) -> InterpResult<'tcx, ScalarMaybeUninit<Provenance>> {\n         let this = self.eval_context_ref();\n         let value_place = this.deref_operand_and_offset(op, offset, layout)?;\n         this.read_scalar_atomic(&value_place, atomic)\n@@ -452,9 +452,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n     /// Atomic variant of write_scalar_at_offset.\n     fn write_scalar_at_offset_atomic(\n         &mut self,\n-        op: &OpTy<'tcx, Tag>,\n+        op: &OpTy<'tcx, Provenance>,\n         offset: u64,\n-        value: impl Into<ScalarMaybeUninit<Tag>>,\n+        value: impl Into<ScalarMaybeUninit<Provenance>>,\n         layout: TyAndLayout<'tcx>,\n         atomic: AtomicWriteOrd,\n     ) -> InterpResult<'tcx> {\n@@ -466,9 +466,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n     /// Perform an atomic read operation at the memory location.\n     fn read_scalar_atomic(\n         &self,\n-        place: &MPlaceTy<'tcx, Tag>,\n+        place: &MPlaceTy<'tcx, Provenance>,\n         atomic: AtomicReadOrd,\n-    ) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n+    ) -> InterpResult<'tcx, ScalarMaybeUninit<Provenance>> {\n         let this = self.eval_context_ref();\n         // This will read from the last store in the modification order of this location. In case\n         // weak memory emulation is enabled, this may not be the store we will pick to actually read from and return.\n@@ -485,8 +485,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n     /// Perform an atomic write operation at the memory location.\n     fn write_scalar_atomic(\n         &mut self,\n-        val: ScalarMaybeUninit<Tag>,\n-        dest: &MPlaceTy<'tcx, Tag>,\n+        val: ScalarMaybeUninit<Provenance>,\n+        dest: &MPlaceTy<'tcx, Provenance>,\n         atomic: AtomicWriteOrd,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n@@ -504,12 +504,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n     /// Perform an atomic operation on a memory location.\n     fn atomic_op_immediate(\n         &mut self,\n-        place: &MPlaceTy<'tcx, Tag>,\n-        rhs: &ImmTy<'tcx, Tag>,\n+        place: &MPlaceTy<'tcx, Provenance>,\n+        rhs: &ImmTy<'tcx, Provenance>,\n         op: mir::BinOp,\n         neg: bool,\n         atomic: AtomicRwOrd,\n-    ) -> InterpResult<'tcx, ImmTy<'tcx, Tag>> {\n+    ) -> InterpResult<'tcx, ImmTy<'tcx, Provenance>> {\n         let this = self.eval_context_mut();\n \n         this.validate_overlapping_atomic(place)?;\n@@ -535,10 +535,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n     /// scalar value, the old value is returned.\n     fn atomic_exchange_scalar(\n         &mut self,\n-        place: &MPlaceTy<'tcx, Tag>,\n-        new: ScalarMaybeUninit<Tag>,\n+        place: &MPlaceTy<'tcx, Provenance>,\n+        new: ScalarMaybeUninit<Provenance>,\n         atomic: AtomicRwOrd,\n-    ) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n+    ) -> InterpResult<'tcx, ScalarMaybeUninit<Provenance>> {\n         let this = self.eval_context_mut();\n \n         this.validate_overlapping_atomic(place)?;\n@@ -555,11 +555,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n     /// scalar value, the old value is returned.\n     fn atomic_min_max_scalar(\n         &mut self,\n-        place: &MPlaceTy<'tcx, Tag>,\n-        rhs: ImmTy<'tcx, Tag>,\n+        place: &MPlaceTy<'tcx, Provenance>,\n+        rhs: ImmTy<'tcx, Provenance>,\n         min: bool,\n         atomic: AtomicRwOrd,\n-    ) -> InterpResult<'tcx, ImmTy<'tcx, Tag>> {\n+    ) -> InterpResult<'tcx, ImmTy<'tcx, Provenance>> {\n         let this = self.eval_context_mut();\n \n         this.validate_overlapping_atomic(place)?;\n@@ -595,13 +595,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n     /// identical.\n     fn atomic_compare_exchange_scalar(\n         &mut self,\n-        place: &MPlaceTy<'tcx, Tag>,\n-        expect_old: &ImmTy<'tcx, Tag>,\n-        new: ScalarMaybeUninit<Tag>,\n+        place: &MPlaceTy<'tcx, Provenance>,\n+        expect_old: &ImmTy<'tcx, Provenance>,\n+        new: ScalarMaybeUninit<Provenance>,\n         success: AtomicRwOrd,\n         fail: AtomicReadOrd,\n         can_fail_spuriously: bool,\n-    ) -> InterpResult<'tcx, Immediate<Tag>> {\n+    ) -> InterpResult<'tcx, Immediate<Provenance>> {\n         use rand::Rng as _;\n         let this = self.eval_context_mut();\n \n@@ -651,7 +651,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n     /// associated memory-place and on the current thread.\n     fn validate_atomic_load(\n         &self,\n-        place: &MPlaceTy<'tcx, Tag>,\n+        place: &MPlaceTy<'tcx, Provenance>,\n         atomic: AtomicReadOrd,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_ref();\n@@ -674,7 +674,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n     /// associated memory-place and on the current thread.\n     fn validate_atomic_store(\n         &mut self,\n-        place: &MPlaceTy<'tcx, Tag>,\n+        place: &MPlaceTy<'tcx, Provenance>,\n         atomic: AtomicWriteOrd,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n@@ -697,7 +697,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n     /// at the associated memory place and on the current thread.\n     fn validate_atomic_rmw(\n         &mut self,\n-        place: &MPlaceTy<'tcx, Tag>,\n+        place: &MPlaceTy<'tcx, Provenance>,\n         atomic: AtomicRwOrd,\n     ) -> InterpResult<'tcx> {\n         use AtomicRwOrd::*;\n@@ -1047,7 +1047,7 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: MiriEvalContextExt<'mir, 'tcx> {\n     /// Generic atomic operation implementation\n     fn validate_atomic_op<A: Debug + Copy>(\n         &self,\n-        place: &MPlaceTy<'tcx, Tag>,\n+        place: &MPlaceTy<'tcx, Provenance>,\n         atomic: A,\n         description: &str,\n         mut op: impl FnMut("}, {"sha": "137a9f43d4eeaebe195af6bc00279502e9defda9", "filename": "src/concurrency/weak_memory.rs", "status": "modified", "additions": 29, "deletions": 21, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/167e5dcad39cd12596ace6fce1ef06218e559542/src%2Fconcurrency%2Fweak_memory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/167e5dcad39cd12596ace6fce1ef06218e559542/src%2Fconcurrency%2Fweak_memory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconcurrency%2Fweak_memory.rs?ref=167e5dcad39cd12596ace6fce1ef06218e559542", "patch": "@@ -83,7 +83,8 @@ use rustc_const_eval::interpret::{\n use rustc_data_structures::fx::FxHashMap;\n \n use crate::{\n-    AtomicReadOrd, AtomicRwOrd, AtomicWriteOrd, Tag, ThreadManager, VClock, VTimestamp, VectorIdx,\n+    AtomicReadOrd, AtomicRwOrd, AtomicWriteOrd, Provenance, ThreadManager, VClock, VTimestamp,\n+    VectorIdx,\n };\n \n use super::{\n@@ -127,7 +128,7 @@ struct StoreElement {\n     // FIXME: this means the store is either fully initialized or fully uninitialized;\n     // we will have to change this if we want to support atomics on\n     // partially initialized data.\n-    val: ScalarMaybeUninit<Tag>,\n+    val: ScalarMaybeUninit<Provenance>,\n \n     /// Timestamp of first loads from this store element by each thread\n     /// Behind a RefCell to keep load op take &self\n@@ -174,7 +175,7 @@ impl StoreBufferAlloc {\n     fn get_or_create_store_buffer<'tcx>(\n         &self,\n         range: AllocRange,\n-        init: ScalarMaybeUninit<Tag>,\n+        init: ScalarMaybeUninit<Provenance>,\n     ) -> InterpResult<'tcx, Ref<'_, StoreBuffer>> {\n         let access_type = self.store_buffers.borrow().access_type(range);\n         let pos = match access_type {\n@@ -199,7 +200,7 @@ impl StoreBufferAlloc {\n     fn get_or_create_store_buffer_mut<'tcx>(\n         &mut self,\n         range: AllocRange,\n-        init: ScalarMaybeUninit<Tag>,\n+        init: ScalarMaybeUninit<Provenance>,\n     ) -> InterpResult<'tcx, &mut StoreBuffer> {\n         let buffers = self.store_buffers.get_mut();\n         let access_type = buffers.access_type(range);\n@@ -220,7 +221,7 @@ impl StoreBufferAlloc {\n }\n \n impl<'mir, 'tcx: 'mir> StoreBuffer {\n-    fn new(init: ScalarMaybeUninit<Tag>) -> Self {\n+    fn new(init: ScalarMaybeUninit<Provenance>) -> Self {\n         let mut buffer = VecDeque::new();\n         buffer.reserve(STORE_BUFFER_LIMIT);\n         let mut ret = Self { buffer };\n@@ -253,7 +254,7 @@ impl<'mir, 'tcx: 'mir> StoreBuffer {\n         is_seqcst: bool,\n         rng: &mut (impl rand::Rng + ?Sized),\n         validate: impl FnOnce() -> InterpResult<'tcx>,\n-    ) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n+    ) -> InterpResult<'tcx, ScalarMaybeUninit<Provenance>> {\n         // Having a live borrow to store_buffer while calling validate_atomic_load is fine\n         // because the race detector doesn't touch store_buffer\n \n@@ -278,7 +279,7 @@ impl<'mir, 'tcx: 'mir> StoreBuffer {\n \n     fn buffered_write(\n         &mut self,\n-        val: ScalarMaybeUninit<Tag>,\n+        val: ScalarMaybeUninit<Provenance>,\n         global: &DataRaceState,\n         thread_mgr: &ThreadManager<'_, '_>,\n         is_seqcst: bool,\n@@ -366,7 +367,7 @@ impl<'mir, 'tcx: 'mir> StoreBuffer {\n     /// ATOMIC STORE IMPL in the paper (except we don't need the location's vector clock)\n     fn store_impl(\n         &mut self,\n-        val: ScalarMaybeUninit<Tag>,\n+        val: ScalarMaybeUninit<Provenance>,\n         index: VectorIdx,\n         thread_clock: &VClock,\n         is_seqcst: bool,\n@@ -408,7 +409,11 @@ impl StoreElement {\n     /// buffer regardless of subsequent loads by the same thread; if the earliest load of another\n     /// thread doesn't happen before the current one, then no subsequent load by the other thread\n     /// can happen before the current one.\n-    fn load_impl(&self, index: VectorIdx, clocks: &ThreadClockSet) -> ScalarMaybeUninit<Tag> {\n+    fn load_impl(\n+        &self,\n+        index: VectorIdx,\n+        clocks: &ThreadClockSet,\n+    ) -> ScalarMaybeUninit<Provenance> {\n         let _ = self.loads.borrow_mut().try_insert(index, clocks.clock[index]);\n         self.val\n     }\n@@ -421,7 +426,10 @@ pub(super) trait EvalContextExt<'mir, 'tcx: 'mir>:\n     // If weak memory emulation is enabled, check if this atomic op imperfectly overlaps with a previous\n     // atomic read or write. If it does, then we require it to be ordered (non-racy) with all previous atomic\n     // accesses on all the bytes in range\n-    fn validate_overlapping_atomic(&self, place: &MPlaceTy<'tcx, Tag>) -> InterpResult<'tcx> {\n+    fn validate_overlapping_atomic(\n+        &self,\n+        place: &MPlaceTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx> {\n         let this = self.eval_context_ref();\n         let (alloc_id, base_offset, ..) = this.ptr_get_alloc_id(place.ptr)?;\n         if let crate::AllocExtra {\n@@ -448,10 +456,10 @@ pub(super) trait EvalContextExt<'mir, 'tcx: 'mir>:\n \n     fn buffered_atomic_rmw(\n         &mut self,\n-        new_val: ScalarMaybeUninit<Tag>,\n-        place: &MPlaceTy<'tcx, Tag>,\n+        new_val: ScalarMaybeUninit<Provenance>,\n+        place: &MPlaceTy<'tcx, Provenance>,\n         atomic: AtomicRwOrd,\n-        init: ScalarMaybeUninit<Tag>,\n+        init: ScalarMaybeUninit<Provenance>,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         let (alloc_id, base_offset, ..) = this.ptr_get_alloc_id(place.ptr)?;\n@@ -474,11 +482,11 @@ pub(super) trait EvalContextExt<'mir, 'tcx: 'mir>:\n \n     fn buffered_atomic_read(\n         &self,\n-        place: &MPlaceTy<'tcx, Tag>,\n+        place: &MPlaceTy<'tcx, Provenance>,\n         atomic: AtomicReadOrd,\n-        latest_in_mo: ScalarMaybeUninit<Tag>,\n+        latest_in_mo: ScalarMaybeUninit<Provenance>,\n         validate: impl FnOnce() -> InterpResult<'tcx>,\n-    ) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n+    ) -> InterpResult<'tcx, ScalarMaybeUninit<Provenance>> {\n         let this = self.eval_context_ref();\n         if let Some(global) = &this.machine.data_race {\n             let (alloc_id, base_offset, ..) = this.ptr_get_alloc_id(place.ptr)?;\n@@ -510,10 +518,10 @@ pub(super) trait EvalContextExt<'mir, 'tcx: 'mir>:\n \n     fn buffered_atomic_write(\n         &mut self,\n-        val: ScalarMaybeUninit<Tag>,\n-        dest: &MPlaceTy<'tcx, Tag>,\n+        val: ScalarMaybeUninit<Provenance>,\n+        dest: &MPlaceTy<'tcx, Provenance>,\n         atomic: AtomicWriteOrd,\n-        init: ScalarMaybeUninit<Tag>,\n+        init: ScalarMaybeUninit<Provenance>,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         let (alloc_id, base_offset, ..) = this.ptr_get_alloc_id(dest.ptr)?;\n@@ -555,9 +563,9 @@ pub(super) trait EvalContextExt<'mir, 'tcx: 'mir>:\n     /// to perform load_impl on the latest store element\n     fn perform_read_on_buffered_latest(\n         &self,\n-        place: &MPlaceTy<'tcx, Tag>,\n+        place: &MPlaceTy<'tcx, Provenance>,\n         atomic: AtomicReadOrd,\n-        init: ScalarMaybeUninit<Tag>,\n+        init: ScalarMaybeUninit<Provenance>,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_ref();\n "}, {"sha": "6a692059be92747813658a352637221ed9c4641a", "filename": "src/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/167e5dcad39cd12596ace6fce1ef06218e559542/src%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/167e5dcad39cd12596ace6fce1ef06218e559542/src%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdiagnostics.rs?ref=167e5dcad39cd12596ace6fce1ef06218e559542", "patch": "@@ -65,7 +65,7 @@ pub enum NonHaltingDiagnostic {\n     CreatedPointerTag(NonZeroU64, Option<(AllocId, AllocRange)>),\n     /// This `Item` was popped from the borrow stack, either due to an access with the given tag or\n     /// a deallocation when the second argument is `None`.\n-    PoppedPointerTag(Item, Option<(SbTagExtra, AccessKind)>),\n+    PoppedPointerTag(Item, Option<(ProvenanceExtra, AccessKind)>),\n     CreatedCallId(CallId),\n     CreatedAlloc(AllocId, Size, Align, MemoryKind<MiriMemoryKind>),\n     FreedAlloc(AllocId),"}, {"sha": "0f354aa549494e0a1428e5abe9f0d630c5628857", "filename": "src/eval.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/167e5dcad39cd12596ace6fce1ef06218e559542/src%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/167e5dcad39cd12596ace6fce1ef06218e559542/src%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Feval.rs?ref=167e5dcad39cd12596ace6fce1ef06218e559542", "patch": "@@ -165,7 +165,7 @@ pub fn create_ecx<'mir, 'tcx: 'mir>(\n     entry_id: DefId,\n     entry_type: EntryFnType,\n     config: &MiriConfig,\n-) -> InterpResult<'tcx, (InterpCx<'mir, 'tcx, Evaluator<'mir, 'tcx>>, MPlaceTy<'tcx, Tag>)> {\n+) -> InterpResult<'tcx, (InterpCx<'mir, 'tcx, Evaluator<'mir, 'tcx>>, MPlaceTy<'tcx, Provenance>)> {\n     let param_env = ty::ParamEnv::reveal_all();\n     let layout_cx = LayoutCx { tcx, param_env };\n     let mut ecx = InterpCx::new(\n@@ -202,7 +202,7 @@ pub fn create_ecx<'mir, 'tcx: 'mir>(\n     // Third argument (`argv`): created from `config.args`.\n     let argv = {\n         // Put each argument in memory, collect pointers.\n-        let mut argvs = Vec::<Immediate<Tag>>::new();\n+        let mut argvs = Vec::<Immediate<Provenance>>::new();\n         for arg in config.args.iter() {\n             // Make space for `0` terminator.\n             let size = u64::try_from(arg.len()).unwrap().checked_add(1).unwrap();"}, {"sha": "01fc8e0df3f0ca4f83a68de8ddf6dc9e0ec7611f", "filename": "src/helpers.rs", "status": "modified", "additions": 59, "deletions": 46, "changes": 105, "blob_url": "https://github.com/rust-lang/rust/blob/167e5dcad39cd12596ace6fce1ef06218e559542/src%2Fhelpers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/167e5dcad39cd12596ace6fce1ef06218e559542/src%2Fhelpers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fhelpers.rs?ref=167e5dcad39cd12596ace6fce1ef06218e559542", "patch": "@@ -84,7 +84,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n     /// Evaluates the scalar at the specified path. Returns Some(val)\n     /// if the path could be resolved, and None otherwise\n-    fn eval_path_scalar(&self, path: &[&str]) -> InterpResult<'tcx, Scalar<Tag>> {\n+    fn eval_path_scalar(&self, path: &[&str]) -> InterpResult<'tcx, Scalar<Provenance>> {\n         let this = self.eval_context_ref();\n         let instance = this.resolve_path(path);\n         let cid = GlobalId { instance, promoted: None };\n@@ -94,7 +94,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     }\n \n     /// Helper function to get a `libc` constant as a `Scalar`.\n-    fn eval_libc(&self, name: &str) -> InterpResult<'tcx, Scalar<Tag>> {\n+    fn eval_libc(&self, name: &str) -> InterpResult<'tcx, Scalar<Provenance>> {\n         self.eval_path_scalar(&[\"libc\", name])\n     }\n \n@@ -105,7 +105,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     }\n \n     /// Helper function to get a `windows` constant as a `Scalar`.\n-    fn eval_windows(&self, module: &str, name: &str) -> InterpResult<'tcx, Scalar<Tag>> {\n+    fn eval_windows(&self, module: &str, name: &str) -> InterpResult<'tcx, Scalar<Provenance>> {\n         self.eval_context_ref().eval_path_scalar(&[\"std\", \"sys\", \"windows\", module, name])\n     }\n \n@@ -134,9 +134,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     /// Project to the given *named* field of the mplace (which must be a struct or union type).\n     fn mplace_field_named(\n         &self,\n-        mplace: &MPlaceTy<'tcx, Tag>,\n+        mplace: &MPlaceTy<'tcx, Provenance>,\n         name: &str,\n-    ) -> InterpResult<'tcx, MPlaceTy<'tcx, Tag>> {\n+    ) -> InterpResult<'tcx, MPlaceTy<'tcx, Provenance>> {\n         let this = self.eval_context_ref();\n         let adt = mplace.layout.ty.ty_adt_def().unwrap();\n         for (idx, field) in adt.non_enum_variant().fields.iter().enumerate() {\n@@ -150,7 +150,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     /// Write an int of the appropriate size to `dest`. The target type may be signed or unsigned,\n     /// we try to do the right thing anyway. `i128` can fit all integer types except for `u128` so\n     /// this method is fine for almost all integer types.\n-    fn write_int(&mut self, i: impl Into<i128>, dest: &PlaceTy<'tcx, Tag>) -> InterpResult<'tcx> {\n+    fn write_int(\n+        &mut self,\n+        i: impl Into<i128>,\n+        dest: &PlaceTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx> {\n         assert!(dest.layout.abi.is_scalar(), \"write_int on non-scalar type {}\", dest.layout.ty);\n         let val = if dest.layout.abi.is_signed() {\n             Scalar::from_int(i, dest.layout.size)\n@@ -164,7 +168,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     fn write_int_fields(\n         &mut self,\n         values: &[i128],\n-        dest: &MPlaceTy<'tcx, Tag>,\n+        dest: &MPlaceTy<'tcx, Provenance>,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         for (idx, &val) in values.iter().enumerate() {\n@@ -178,7 +182,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     fn write_int_fields_named(\n         &mut self,\n         values: &[(&str, i128)],\n-        dest: &MPlaceTy<'tcx, Tag>,\n+        dest: &MPlaceTy<'tcx, Provenance>,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         for &(name, val) in values.iter() {\n@@ -189,24 +193,24 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     }\n \n     /// Write a 0 of the appropriate size to `dest`.\n-    fn write_null(&mut self, dest: &PlaceTy<'tcx, Tag>) -> InterpResult<'tcx> {\n+    fn write_null(&mut self, dest: &PlaceTy<'tcx, Provenance>) -> InterpResult<'tcx> {\n         self.write_int(0, dest)\n     }\n \n     /// Test if this pointer equals 0.\n-    fn ptr_is_null(&self, ptr: Pointer<Option<Tag>>) -> InterpResult<'tcx, bool> {\n+    fn ptr_is_null(&self, ptr: Pointer<Option<Provenance>>) -> InterpResult<'tcx, bool> {\n         Ok(ptr.addr().bytes() == 0)\n     }\n \n     /// Get the `Place` for a local\n-    fn local_place(&mut self, local: mir::Local) -> InterpResult<'tcx, PlaceTy<'tcx, Tag>> {\n+    fn local_place(&mut self, local: mir::Local) -> InterpResult<'tcx, PlaceTy<'tcx, Provenance>> {\n         let this = self.eval_context_mut();\n         let place = mir::Place { local, projection: List::empty() };\n         this.eval_place(place)\n     }\n \n     /// Generate some random bytes, and write them to `dest`.\n-    fn gen_random(&mut self, ptr: Pointer<Option<Tag>>, len: u64) -> InterpResult<'tcx> {\n+    fn gen_random(&mut self, ptr: Pointer<Option<Provenance>>, len: u64) -> InterpResult<'tcx> {\n         // Some programs pass in a null pointer and a length of 0\n         // to their platform's random-generation function (e.g. getrandom())\n         // on Linux. For compatibility with these programs, we don't perform\n@@ -240,8 +244,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         &mut self,\n         f: ty::Instance<'tcx>,\n         caller_abi: Abi,\n-        args: &[Immediate<Tag>],\n-        dest: Option<&PlaceTy<'tcx, Tag>>,\n+        args: &[Immediate<Provenance>],\n+        dest: Option<&PlaceTy<'tcx, Provenance>>,\n         stack_pop: StackPopCleanup,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n@@ -285,7 +289,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     /// The range is relative to `place`.\n     fn visit_freeze_sensitive(\n         &self,\n-        place: &MPlaceTy<'tcx, Tag>,\n+        place: &MPlaceTy<'tcx, Provenance>,\n         size: Size,\n         mut action: impl FnMut(AllocRange, bool) -> InterpResult<'tcx>,\n     ) -> InterpResult<'tcx> {\n@@ -304,7 +308,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         let mut cur_addr = start_addr;\n         // Called when we detected an `UnsafeCell` at the given offset and size.\n         // Calls `action` and advances `cur_ptr`.\n-        let mut unsafe_cell_action = |unsafe_cell_ptr: &Pointer<Option<Tag>>,\n+        let mut unsafe_cell_action = |unsafe_cell_ptr: &Pointer<Option<Provenance>>,\n                                       unsafe_cell_size: Size| {\n             // We assume that we are given the fields in increasing offset order,\n             // and nothing else changes.\n@@ -359,7 +363,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         /// whether we are inside an `UnsafeCell` or not.\n         struct UnsafeCellVisitor<'ecx, 'mir, 'tcx, F>\n         where\n-            F: FnMut(&MPlaceTy<'tcx, Tag>) -> InterpResult<'tcx>,\n+            F: FnMut(&MPlaceTy<'tcx, Provenance>) -> InterpResult<'tcx>,\n         {\n             ecx: &'ecx MiriEvalContext<'mir, 'tcx>,\n             unsafe_cell_action: F,\n@@ -368,17 +372,17 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         impl<'ecx, 'mir, 'tcx: 'mir, F> ValueVisitor<'mir, 'tcx, Evaluator<'mir, 'tcx>>\n             for UnsafeCellVisitor<'ecx, 'mir, 'tcx, F>\n         where\n-            F: FnMut(&MPlaceTy<'tcx, Tag>) -> InterpResult<'tcx>,\n+            F: FnMut(&MPlaceTy<'tcx, Provenance>) -> InterpResult<'tcx>,\n         {\n-            type V = MPlaceTy<'tcx, Tag>;\n+            type V = MPlaceTy<'tcx, Provenance>;\n \n             #[inline(always)]\n             fn ecx(&self) -> &MiriEvalContext<'mir, 'tcx> {\n                 self.ecx\n             }\n \n             // Hook to detect `UnsafeCell`.\n-            fn visit_value(&mut self, v: &MPlaceTy<'tcx, Tag>) -> InterpResult<'tcx> {\n+            fn visit_value(&mut self, v: &MPlaceTy<'tcx, Provenance>) -> InterpResult<'tcx> {\n                 trace!(\"UnsafeCellVisitor: {:?} {:?}\", *v, v.layout.ty);\n                 let is_unsafe_cell = match v.layout.ty.kind() {\n                     ty::Adt(adt, _) =>\n@@ -421,8 +425,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             // Make sure we visit aggregrates in increasing offset order.\n             fn visit_aggregate(\n                 &mut self,\n-                place: &MPlaceTy<'tcx, Tag>,\n-                fields: impl Iterator<Item = InterpResult<'tcx, MPlaceTy<'tcx, Tag>>>,\n+                place: &MPlaceTy<'tcx, Provenance>,\n+                fields: impl Iterator<Item = InterpResult<'tcx, MPlaceTy<'tcx, Provenance>>>,\n             ) -> InterpResult<'tcx> {\n                 match place.layout.fields {\n                     FieldsShape::Array { .. } => {\n@@ -432,8 +436,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     }\n                     FieldsShape::Arbitrary { .. } => {\n                         // Gather the subplaces and sort them before visiting.\n-                        let mut places =\n-                            fields.collect::<InterpResult<'tcx, Vec<MPlaceTy<'tcx, Tag>>>>()?;\n+                        let mut places = fields\n+                            .collect::<InterpResult<'tcx, Vec<MPlaceTy<'tcx, Provenance>>>>()?;\n                         // we just compare offsets, the abs. value never matters\n                         places.sort_by_key(|place| place.ptr.addr());\n                         self.walk_aggregate(place, places.into_iter().map(Ok))\n@@ -447,7 +451,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n             fn visit_union(\n                 &mut self,\n-                _v: &MPlaceTy<'tcx, Tag>,\n+                _v: &MPlaceTy<'tcx, Provenance>,\n                 _fields: NonZeroUsize,\n             ) -> InterpResult<'tcx> {\n                 bug!(\"we should have already handled unions in `visit_value`\")\n@@ -511,7 +515,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n     /// Get last error variable as a place, lazily allocating thread-local storage for it if\n     /// necessary.\n-    fn last_error_place(&mut self) -> InterpResult<'tcx, MPlaceTy<'tcx, Tag>> {\n+    fn last_error_place(&mut self) -> InterpResult<'tcx, MPlaceTy<'tcx, Provenance>> {\n         let this = self.eval_context_mut();\n         if let Some(errno_place) = this.active_thread_ref().last_error {\n             Ok(errno_place)\n@@ -526,22 +530,25 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     }\n \n     /// Sets the last error variable.\n-    fn set_last_error(&mut self, scalar: Scalar<Tag>) -> InterpResult<'tcx> {\n+    fn set_last_error(&mut self, scalar: Scalar<Provenance>) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         let errno_place = this.last_error_place()?;\n         this.write_scalar(scalar, &errno_place.into())\n     }\n \n     /// Gets the last error variable.\n-    fn get_last_error(&mut self) -> InterpResult<'tcx, Scalar<Tag>> {\n+    fn get_last_error(&mut self) -> InterpResult<'tcx, Scalar<Provenance>> {\n         let this = self.eval_context_mut();\n         let errno_place = this.last_error_place()?;\n         this.read_scalar(&errno_place.into())?.check_init()\n     }\n \n     /// This function tries to produce the most similar OS error from the `std::io::ErrorKind`\n     /// as a platform-specific errnum.\n-    fn io_error_to_errnum(&self, err_kind: std::io::ErrorKind) -> InterpResult<'tcx, Scalar<Tag>> {\n+    fn io_error_to_errnum(\n+        &self,\n+        err_kind: std::io::ErrorKind,\n+    ) -> InterpResult<'tcx, Scalar<Provenance>> {\n         let this = self.eval_context_ref();\n         let target = &this.tcx.sess.target;\n         if target.families.iter().any(|f| f == \"unix\") {\n@@ -575,7 +582,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     }\n \n     /// The inverse of `io_error_to_errnum`.\n-    fn errnum_to_io_error(&self, errnum: Scalar<Tag>) -> InterpResult<'tcx, std::io::ErrorKind> {\n+    fn errnum_to_io_error(\n+        &self,\n+        errnum: Scalar<Provenance>,\n+    ) -> InterpResult<'tcx, std::io::ErrorKind> {\n         let this = self.eval_context_ref();\n         let target = &this.tcx.sess.target;\n         if target.families.iter().any(|f| f == \"unix\") {\n@@ -621,10 +631,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     /// Calculates the MPlaceTy given the offset and layout of an access on an operand\n     fn deref_operand_and_offset(\n         &self,\n-        op: &OpTy<'tcx, Tag>,\n+        op: &OpTy<'tcx, Provenance>,\n         offset: u64,\n         layout: TyAndLayout<'tcx>,\n-    ) -> InterpResult<'tcx, MPlaceTy<'tcx, Tag>> {\n+    ) -> InterpResult<'tcx, MPlaceTy<'tcx, Provenance>> {\n         let this = self.eval_context_ref();\n         let op_place = this.deref_operand(op)?;\n         let offset = Size::from_bytes(offset);\n@@ -637,20 +647,20 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n     fn read_scalar_at_offset(\n         &self,\n-        op: &OpTy<'tcx, Tag>,\n+        op: &OpTy<'tcx, Provenance>,\n         offset: u64,\n         layout: TyAndLayout<'tcx>,\n-    ) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n+    ) -> InterpResult<'tcx, ScalarMaybeUninit<Provenance>> {\n         let this = self.eval_context_ref();\n         let value_place = this.deref_operand_and_offset(op, offset, layout)?;\n         this.read_scalar(&value_place.into())\n     }\n \n     fn write_scalar_at_offset(\n         &mut self,\n-        op: &OpTy<'tcx, Tag>,\n+        op: &OpTy<'tcx, Provenance>,\n         offset: u64,\n-        value: impl Into<ScalarMaybeUninit<Tag>>,\n+        value: impl Into<ScalarMaybeUninit<Provenance>>,\n         layout: TyAndLayout<'tcx>,\n     ) -> InterpResult<'tcx, ()> {\n         let this = self.eval_context_mut();\n@@ -661,7 +671,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     /// Parse a `timespec` struct and return it as a `std::time::Duration`. It returns `None`\n     /// if the value in the `timespec` struct is invalid. Some libc functions will return\n     /// `EINVAL` in this case.\n-    fn read_timespec(&mut self, tp: &MPlaceTy<'tcx, Tag>) -> InterpResult<'tcx, Option<Duration>> {\n+    fn read_timespec(\n+        &mut self,\n+        tp: &MPlaceTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx, Option<Duration>> {\n         let this = self.eval_context_mut();\n         let seconds_place = this.mplace_field(tp, 0)?;\n         let seconds_scalar = this.read_scalar(&seconds_place.into())?;\n@@ -683,7 +696,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         })\n     }\n \n-    fn read_c_str<'a>(&'a self, ptr: Pointer<Option<Tag>>) -> InterpResult<'tcx, &'a [u8]>\n+    fn read_c_str<'a>(&'a self, ptr: Pointer<Option<Provenance>>) -> InterpResult<'tcx, &'a [u8]>\n     where\n         'tcx: 'a,\n         'mir: 'a,\n@@ -709,7 +722,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         this.read_bytes_ptr(ptr, len)\n     }\n \n-    fn read_wide_str(&self, mut ptr: Pointer<Option<Tag>>) -> InterpResult<'tcx, Vec<u16>> {\n+    fn read_wide_str(&self, mut ptr: Pointer<Option<Provenance>>) -> InterpResult<'tcx, Vec<u16>> {\n         let this = self.eval_context_ref();\n         let size2 = Size::from_bytes(2);\n         let align2 = Align::from_bytes(2).unwrap();\n@@ -801,17 +814,17 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         abi: Abi,\n         exp_abi: Abi,\n         link_name: Symbol,\n-        args: &'a [OpTy<'tcx, Tag>],\n-    ) -> InterpResult<'tcx, &'a [OpTy<'tcx, Tag>; N]>\n+        args: &'a [OpTy<'tcx, Provenance>],\n+    ) -> InterpResult<'tcx, &'a [OpTy<'tcx, Provenance>; N]>\n     where\n-        &'a [OpTy<'tcx, Tag>; N]: TryFrom<&'a [OpTy<'tcx, Tag>]>,\n+        &'a [OpTy<'tcx, Provenance>; N]: TryFrom<&'a [OpTy<'tcx, Provenance>]>,\n     {\n         self.check_abi_and_shim_symbol_clash(abi, exp_abi, link_name)?;\n         check_arg_count(args)\n     }\n \n     /// Mark a machine allocation that was just created as immutable.\n-    fn mark_immutable(&mut self, mplace: &MemPlace<Tag>) {\n+    fn mark_immutable(&mut self, mplace: &MemPlace<Provenance>) {\n         let this = self.eval_context_mut();\n         // This got just allocated, so there definitely is a pointer here.\n         let provenance = mplace.ptr.into_pointer_or_addr().unwrap().provenance;\n@@ -866,10 +879,10 @@ impl<'a, 'mir, 'tcx> CurrentSpan<'a, 'mir, 'tcx> {\n \n /// Check that the number of args is what we expect.\n pub fn check_arg_count<'a, 'tcx, const N: usize>(\n-    args: &'a [OpTy<'tcx, Tag>],\n-) -> InterpResult<'tcx, &'a [OpTy<'tcx, Tag>; N]>\n+    args: &'a [OpTy<'tcx, Provenance>],\n+) -> InterpResult<'tcx, &'a [OpTy<'tcx, Provenance>; N]>\n where\n-    &'a [OpTy<'tcx, Tag>; N]: TryFrom<&'a [OpTy<'tcx, Tag>]>,\n+    &'a [OpTy<'tcx, Provenance>; N]: TryFrom<&'a [OpTy<'tcx, Provenance>]>,\n {\n     if let Ok(ops) = args.try_into() {\n         return Ok(ops);"}, {"sha": "4272966ae6cc3489a31da46e31fae4f900ca9e7e", "filename": "src/intptrcast.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/167e5dcad39cd12596ace6fce1ef06218e559542/src%2Fintptrcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/167e5dcad39cd12596ace6fce1ef06218e559542/src%2Fintptrcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fintptrcast.rs?ref=167e5dcad39cd12596ace6fce1ef06218e559542", "patch": "@@ -109,7 +109,7 @@ impl<'mir, 'tcx> GlobalStateInner {\n     pub fn ptr_from_addr_transmute(\n         _ecx: &MiriEvalContext<'mir, 'tcx>,\n         addr: u64,\n-    ) -> Pointer<Option<Tag>> {\n+    ) -> Pointer<Option<Provenance>> {\n         trace!(\"Transmuting {:#x} to a pointer\", addr);\n \n         // We consider transmuted pointers to be \"invalid\" (`None` provenance).\n@@ -119,7 +119,7 @@ impl<'mir, 'tcx> GlobalStateInner {\n     pub fn ptr_from_addr_cast(\n         ecx: &MiriEvalContext<'mir, 'tcx>,\n         addr: u64,\n-    ) -> InterpResult<'tcx, Pointer<Option<Tag>>> {\n+    ) -> InterpResult<'tcx, Pointer<Option<Provenance>>> {\n         trace!(\"Casting {:#x} to a pointer\", addr);\n \n         let global_state = ecx.machine.intptrcast.borrow();\n@@ -146,7 +146,7 @@ impl<'mir, 'tcx> GlobalStateInner {\n         }\n \n         // This is how wildcard pointers are born.\n-        Ok(Pointer::new(Some(Tag::Wildcard), Size::from_bytes(addr)))\n+        Ok(Pointer::new(Some(Provenance::Wildcard), Size::from_bytes(addr)))\n     }\n \n     fn alloc_base_addr(ecx: &MiriEvalContext<'mir, 'tcx>, alloc_id: AllocId) -> u64 {\n@@ -208,11 +208,11 @@ impl<'mir, 'tcx> GlobalStateInner {\n     /// access is going.\n     pub fn abs_ptr_to_rel(\n         ecx: &MiriEvalContext<'mir, 'tcx>,\n-        ptr: Pointer<Tag>,\n+        ptr: Pointer<Provenance>,\n     ) -> Option<(AllocId, Size)> {\n         let (tag, addr) = ptr.into_parts(); // addr is absolute (Tag provenance)\n \n-        let alloc_id = if let Tag::Concrete { alloc_id, .. } = tag {\n+        let alloc_id = if let Provenance::Concrete { alloc_id, .. } = tag {\n             alloc_id\n         } else {\n             // A wildcard pointer."}, {"sha": "35351664caf4e44ebb30d32a7594779a7f5943ab", "filename": "src/lib.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/167e5dcad39cd12596ace6fce1ef06218e559542/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/167e5dcad39cd12596ace6fce1ef06218e559542/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=167e5dcad39cd12596ace6fce1ef06218e559542", "patch": "@@ -57,7 +57,7 @@ mod vector_clock;\n // Make all those symbols available in the same place as our own.\n pub use rustc_const_eval::interpret::*;\n // Resolve ambiguity.\n-pub use rustc_const_eval::interpret::{self, AllocMap, PlaceTy};\n+pub use rustc_const_eval::interpret::{self, AllocMap, PlaceTy, Provenance as _};\n \n pub use crate::shims::dlsym::{Dlsym, EvalContextExt as _};\n pub use crate::shims::env::{EnvVars, EvalContextExt as _};\n@@ -83,15 +83,14 @@ pub use crate::eval::{\n pub use crate::helpers::{CurrentSpan, EvalContextExt as HelpersEvalContextExt};\n pub use crate::intptrcast::ProvenanceMode;\n pub use crate::machine::{\n-    AllocExtra, Evaluator, FrameData, MiriEvalContext, MiriEvalContextExt, MiriMemoryKind, Tag,\n-    NUM_CPUS, PAGE_SIZE, STACK_ADDR, STACK_SIZE,\n+    AllocExtra, Evaluator, FrameData, MiriEvalContext, MiriEvalContextExt, MiriMemoryKind,\n+    Provenance, ProvenanceExtra, NUM_CPUS, PAGE_SIZE, STACK_ADDR, STACK_SIZE,\n };\n pub use crate::mono_hash_map::MonoHashMap;\n pub use crate::operator::EvalContextExt as OperatorEvalContextExt;\n pub use crate::range_map::RangeMap;\n pub use crate::stacked_borrows::{\n-    CallId, EvalContextExt as StackedBorEvalContextExt, Item, Permission, SbTag, SbTagExtra, Stack,\n-    Stacks,\n+    CallId, EvalContextExt as StackedBorEvalContextExt, Item, Permission, SbTag, Stack, Stacks,\n };\n pub use crate::sync::{CondvarId, EvalContextExt as SyncEvalContextExt, MutexId, RwLockId};\n pub use crate::thread::{"}, {"sha": "1adfb83778116f7d383c5617afd6e84a9753db4f", "filename": "src/machine.rs", "status": "modified", "additions": 89, "deletions": 62, "changes": 151, "blob_url": "https://github.com/rust-lang/rust/blob/167e5dcad39cd12596ace6fce1ef06218e559542/src%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/167e5dcad39cd12596ace6fce1ef06218e559542/src%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmachine.rs?ref=167e5dcad39cd12596ace6fce1ef06218e559542", "patch": "@@ -126,9 +126,9 @@ impl fmt::Display for MiriMemoryKind {\n     }\n }\n \n-/// Pointer provenance (tag).\n+/// Pointer provenance.\n #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub enum Tag {\n+pub enum Provenance {\n     Concrete {\n         alloc_id: AllocId,\n         /// Stacked Borrows tag.\n@@ -137,27 +137,34 @@ pub enum Tag {\n     Wildcard,\n }\n \n+/// The \"extra\" information a pointer has over a regular AllocId.\n+#[derive(Copy, Clone)]\n+pub enum ProvenanceExtra {\n+    Concrete(SbTag),\n+    Wildcard,\n+}\n+\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-static_assert_size!(Pointer<Tag>, 24);\n+static_assert_size!(Pointer<Provenance>, 24);\n // FIXME: this would with in 24bytes but layout optimizations are not smart enough\n // #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-//static_assert_size!(Pointer<Option<Tag>>, 24);\n+//static_assert_size!(Pointer<Option<Provenance>>, 24);\n #[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-static_assert_size!(ScalarMaybeUninit<Tag>, 32);\n+static_assert_size!(ScalarMaybeUninit<Provenance>, 32);\n \n-impl Provenance for Tag {\n-    /// We use absolute addresses in the `offset` of a `Pointer<Tag>`.\n+impl interpret::Provenance for Provenance {\n+    /// We use absolute addresses in the `offset` of a `Pointer<Provenance>`.\n     const OFFSET_IS_ADDR: bool = true;\n \n     /// We cannot err on partial overwrites, it happens too often in practice (due to unions).\n     const ERR_ON_PARTIAL_PTR_OVERWRITE: bool = false;\n \n     fn fmt(ptr: &Pointer<Self>, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let (tag, addr) = ptr.into_parts(); // address is absolute\n+        let (prov, addr) = ptr.into_parts(); // address is absolute\n         write!(f, \"{:#x}\", addr.bytes())?;\n \n-        match tag {\n-            Tag::Concrete { alloc_id, sb } => {\n+        match prov {\n+            Provenance::Concrete { alloc_id, sb } => {\n                 // Forward `alternate` flag to `alloc_id` printing.\n                 if f.alternate() {\n                     write!(f, \"[{:#?}]\", alloc_id)?;\n@@ -167,7 +174,7 @@ impl Provenance for Tag {\n                 // Print Stacked Borrows tag.\n                 write!(f, \"{:?}\", sb)?;\n             }\n-            Tag::Wildcard => {\n+            Provenance::Wildcard => {\n                 write!(f, \"[wildcard]\")?;\n             }\n         }\n@@ -177,8 +184,26 @@ impl Provenance for Tag {\n \n     fn get_alloc_id(self) -> Option<AllocId> {\n         match self {\n-            Tag::Concrete { alloc_id, .. } => Some(alloc_id),\n-            Tag::Wildcard => None,\n+            Provenance::Concrete { alloc_id, .. } => Some(alloc_id),\n+            Provenance::Wildcard => None,\n+        }\n+    }\n+}\n+\n+impl fmt::Debug for ProvenanceExtra {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match self {\n+            ProvenanceExtra::Concrete(pid) => write!(f, \"{pid:?}\"),\n+            ProvenanceExtra::Wildcard => write!(f, \"<wildcard>\"),\n+        }\n+    }\n+}\n+\n+impl ProvenanceExtra {\n+    pub fn and_then<T>(self, f: impl FnOnce(SbTag) -> Option<T>) -> Option<T> {\n+        match self {\n+            ProvenanceExtra::Concrete(pid) => f(pid),\n+            ProvenanceExtra::Wildcard => None,\n         }\n     }\n }\n@@ -244,9 +269,9 @@ pub struct Evaluator<'mir, 'tcx> {\n     /// Program arguments (`Option` because we can only initialize them after creating the ecx).\n     /// These are *pointers* to argc/argv because macOS.\n     /// We also need the full command line as one string because of Windows.\n-    pub(crate) argc: Option<MemPlace<Tag>>,\n-    pub(crate) argv: Option<MemPlace<Tag>>,\n-    pub(crate) cmd_line: Option<MemPlace<Tag>>,\n+    pub(crate) argc: Option<MemPlace<Provenance>>,\n+    pub(crate) argv: Option<MemPlace<Provenance>>,\n+    pub(crate) cmd_line: Option<MemPlace<Provenance>>,\n \n     /// TLS state.\n     pub(crate) tls: TlsData<'tcx>,\n@@ -302,7 +327,7 @@ pub struct Evaluator<'mir, 'tcx> {\n     pub(crate) local_crates: Vec<CrateNum>,\n \n     /// Mapping extern static names to their base pointer.\n-    extern_statics: FxHashMap<Symbol, Pointer<Tag>>,\n+    extern_statics: FxHashMap<Symbol, Pointer<Provenance>>,\n \n     /// The random number generator used for resolving non-determinism.\n     /// Needs to be queried by ptr_to_int, hence needs interior mutability.\n@@ -403,7 +428,7 @@ impl<'mir, 'tcx> Evaluator<'mir, 'tcx> {\n     fn add_extern_static(\n         this: &mut MiriEvalContext<'mir, 'tcx>,\n         name: &str,\n-        ptr: Pointer<Option<Tag>>,\n+        ptr: Pointer<Option<Provenance>>,\n     ) {\n         // This got just allocated, so there definitely is a pointer here.\n         let ptr = ptr.into_pointer_or_addr().unwrap();\n@@ -491,11 +516,13 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n     type FrameExtra = FrameData<'tcx>;\n     type AllocExtra = AllocExtra;\n \n-    type PointerTag = Tag;\n-    type TagExtra = SbTagExtra;\n+    type Provenance = Provenance;\n+    type ProvenanceExtra = ProvenanceExtra;\n \n-    type MemoryMap =\n-        MonoHashMap<AllocId, (MemoryKind<MiriMemoryKind>, Allocation<Tag, Self::AllocExtra>)>;\n+    type MemoryMap = MonoHashMap<\n+        AllocId,\n+        (MemoryKind<MiriMemoryKind>, Allocation<Provenance, Self::AllocExtra>),\n+    >;\n \n     const GLOBAL_KIND: Option<MiriMemoryKind> = Some(MiriMemoryKind::Global);\n \n@@ -541,8 +568,8 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n         ecx: &mut MiriEvalContext<'mir, 'tcx>,\n         instance: ty::Instance<'tcx>,\n         abi: Abi,\n-        args: &[OpTy<'tcx, Tag>],\n-        dest: &PlaceTy<'tcx, Tag>,\n+        args: &[OpTy<'tcx, Provenance>],\n+        dest: &PlaceTy<'tcx, Provenance>,\n         ret: Option<mir::BasicBlock>,\n         unwind: StackPopUnwind,\n     ) -> InterpResult<'tcx, Option<(&'mir mir::Body<'tcx>, ty::Instance<'tcx>)>> {\n@@ -554,8 +581,8 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n         ecx: &mut MiriEvalContext<'mir, 'tcx>,\n         fn_val: Dlsym,\n         abi: Abi,\n-        args: &[OpTy<'tcx, Tag>],\n-        dest: &PlaceTy<'tcx, Tag>,\n+        args: &[OpTy<'tcx, Provenance>],\n+        dest: &PlaceTy<'tcx, Provenance>,\n         ret: Option<mir::BasicBlock>,\n         _unwind: StackPopUnwind,\n     ) -> InterpResult<'tcx> {\n@@ -566,8 +593,8 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n     fn call_intrinsic(\n         ecx: &mut MiriEvalContext<'mir, 'tcx>,\n         instance: ty::Instance<'tcx>,\n-        args: &[OpTy<'tcx, Tag>],\n-        dest: &PlaceTy<'tcx, Tag>,\n+        args: &[OpTy<'tcx, Provenance>],\n+        dest: &PlaceTy<'tcx, Provenance>,\n         ret: Option<mir::BasicBlock>,\n         unwind: StackPopUnwind,\n     ) -> InterpResult<'tcx> {\n@@ -592,23 +619,23 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n     fn binary_ptr_op(\n         ecx: &MiriEvalContext<'mir, 'tcx>,\n         bin_op: mir::BinOp,\n-        left: &ImmTy<'tcx, Tag>,\n-        right: &ImmTy<'tcx, Tag>,\n-    ) -> InterpResult<'tcx, (Scalar<Tag>, bool, ty::Ty<'tcx>)> {\n+        left: &ImmTy<'tcx, Provenance>,\n+        right: &ImmTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx, (Scalar<Provenance>, bool, ty::Ty<'tcx>)> {\n         ecx.binary_ptr_op(bin_op, left, right)\n     }\n \n     fn thread_local_static_base_pointer(\n         ecx: &mut MiriEvalContext<'mir, 'tcx>,\n         def_id: DefId,\n-    ) -> InterpResult<'tcx, Pointer<Tag>> {\n+    ) -> InterpResult<'tcx, Pointer<Provenance>> {\n         ecx.get_or_create_thread_local_alloc(def_id)\n     }\n \n     fn extern_static_base_pointer(\n         ecx: &MiriEvalContext<'mir, 'tcx>,\n         def_id: DefId,\n-    ) -> InterpResult<'tcx, Pointer<Tag>> {\n+    ) -> InterpResult<'tcx, Pointer<Provenance>> {\n         let link_name = ecx.item_link_name(def_id);\n         if let Some(&ptr) = ecx.machine.extern_statics.get(&link_name) {\n             Ok(ptr)\n@@ -621,12 +648,12 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n         }\n     }\n \n-    fn init_allocation_extra<'b>(\n+    fn adjust_allocation<'b>(\n         ecx: &MiriEvalContext<'mir, 'tcx>,\n         id: AllocId,\n         alloc: Cow<'b, Allocation>,\n         kind: Option<MemoryKind<Self::MemoryKind>>,\n-    ) -> InterpResult<'tcx, Cow<'b, Allocation<Self::PointerTag, Self::AllocExtra>>> {\n+    ) -> InterpResult<'tcx, Cow<'b, Allocation<Self::Provenance, Self::AllocExtra>>> {\n         let kind = kind.expect(\"we set our STATIC_KIND so this cannot be None\");\n         if ecx.machine.tracked_alloc_ids.contains(&id) {\n             register_diagnostic(NonHaltingDiagnostic::CreatedAlloc(\n@@ -664,7 +691,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n         } else {\n             None\n         };\n-        let alloc: Allocation<Tag, Self::AllocExtra> = alloc.convert_tag_add_extra(\n+        let alloc: Allocation<Provenance, Self::AllocExtra> = alloc.adjust_from_tcx(\n             &ecx.tcx,\n             AllocExtra {\n                 stacked_borrows: stacks.map(RefCell::new),\n@@ -676,19 +703,19 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n         Ok(Cow::Owned(alloc))\n     }\n \n-    fn tag_alloc_base_pointer(\n+    fn adjust_alloc_base_pointer(\n         ecx: &MiriEvalContext<'mir, 'tcx>,\n         ptr: Pointer<AllocId>,\n-    ) -> Pointer<Tag> {\n+    ) -> Pointer<Provenance> {\n         if cfg!(debug_assertions) {\n             // The machine promises to never call us on thread-local or extern statics.\n             let alloc_id = ptr.provenance;\n             match ecx.tcx.get_global_alloc(alloc_id) {\n                 Some(GlobalAlloc::Static(def_id)) if ecx.tcx.is_thread_local_static(def_id) => {\n-                    panic!(\"tag_alloc_base_pointer called on thread-local static\")\n+                    panic!(\"adjust_alloc_base_pointer called on thread-local static\")\n                 }\n                 Some(GlobalAlloc::Static(def_id)) if ecx.tcx.is_foreign_item(def_id) => {\n-                    panic!(\"tag_alloc_base_pointer called on extern static\")\n+                    panic!(\"adjust_alloc_base_pointer called on extern static\")\n                 }\n                 _ => {}\n             }\n@@ -701,7 +728,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n             SbTag::default()\n         };\n         Pointer::new(\n-            Tag::Concrete { alloc_id: ptr.provenance, sb: sb_tag },\n+            Provenance::Concrete { alloc_id: ptr.provenance, sb: sb_tag },\n             Size::from_bytes(absolute_addr),\n         )\n     }\n@@ -710,27 +737,27 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n     fn ptr_from_addr_cast(\n         ecx: &MiriEvalContext<'mir, 'tcx>,\n         addr: u64,\n-    ) -> InterpResult<'tcx, Pointer<Option<Self::PointerTag>>> {\n+    ) -> InterpResult<'tcx, Pointer<Option<Self::Provenance>>> {\n         intptrcast::GlobalStateInner::ptr_from_addr_cast(ecx, addr)\n     }\n \n     #[inline(always)]\n     fn ptr_from_addr_transmute(\n         ecx: &MiriEvalContext<'mir, 'tcx>,\n         addr: u64,\n-    ) -> Pointer<Option<Self::PointerTag>> {\n+    ) -> Pointer<Option<Self::Provenance>> {\n         intptrcast::GlobalStateInner::ptr_from_addr_transmute(ecx, addr)\n     }\n \n     fn expose_ptr(\n         ecx: &mut InterpCx<'mir, 'tcx, Self>,\n-        ptr: Pointer<Self::PointerTag>,\n+        ptr: Pointer<Self::Provenance>,\n     ) -> InterpResult<'tcx> {\n         match ptr.provenance {\n-            Tag::Concrete { alloc_id, sb } => {\n+            Provenance::Concrete { alloc_id, sb } => {\n                 intptrcast::GlobalStateInner::expose_ptr(ecx, alloc_id, sb);\n             }\n-            Tag::Wildcard => {\n+            Provenance::Wildcard => {\n                 // No need to do anything for wildcard pointers as\n                 // their provenances have already been previously exposed.\n             }\n@@ -742,14 +769,14 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n     /// or a `None` with an absolute address if that conversion is not possible.\n     fn ptr_get_alloc(\n         ecx: &MiriEvalContext<'mir, 'tcx>,\n-        ptr: Pointer<Self::PointerTag>,\n-    ) -> Option<(AllocId, Size, Self::TagExtra)> {\n+        ptr: Pointer<Self::Provenance>,\n+    ) -> Option<(AllocId, Size, Self::ProvenanceExtra)> {\n         let rel = intptrcast::GlobalStateInner::abs_ptr_to_rel(ecx, ptr);\n \n         rel.map(|(alloc_id, size)| {\n             let sb = match ptr.provenance {\n-                Tag::Concrete { sb, .. } => SbTagExtra::Concrete(sb),\n-                Tag::Wildcard => SbTagExtra::Wildcard,\n+                Provenance::Concrete { sb, .. } => ProvenanceExtra::Concrete(sb),\n+                Provenance::Wildcard => ProvenanceExtra::Wildcard,\n             };\n             (alloc_id, size, sb)\n         })\n@@ -760,7 +787,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n         _tcx: TyCtxt<'tcx>,\n         machine: &Self,\n         alloc_extra: &AllocExtra,\n-        (alloc_id, tag): (AllocId, Self::TagExtra),\n+        (alloc_id, prov_extra): (AllocId, Self::ProvenanceExtra),\n         range: AllocRange,\n     ) -> InterpResult<'tcx> {\n         if let Some(data_race) = &alloc_extra.data_race {\n@@ -774,7 +801,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n         if let Some(stacked_borrows) = &alloc_extra.stacked_borrows {\n             stacked_borrows.borrow_mut().memory_read(\n                 alloc_id,\n-                tag,\n+                prov_extra,\n                 range,\n                 machine.stacked_borrows.as_ref().unwrap(),\n                 machine.current_span(),\n@@ -792,7 +819,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n         _tcx: TyCtxt<'tcx>,\n         machine: &mut Self,\n         alloc_extra: &mut AllocExtra,\n-        (alloc_id, tag): (AllocId, Self::TagExtra),\n+        (alloc_id, prov_extra): (AllocId, Self::ProvenanceExtra),\n         range: AllocRange,\n     ) -> InterpResult<'tcx> {\n         if let Some(data_race) = &mut alloc_extra.data_race {\n@@ -806,7 +833,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n         if let Some(stacked_borrows) = &mut alloc_extra.stacked_borrows {\n             stacked_borrows.get_mut().memory_written(\n                 alloc_id,\n-                tag,\n+                prov_extra,\n                 range,\n                 machine.stacked_borrows.as_ref().unwrap(),\n                 machine.current_span(),\n@@ -824,7 +851,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n         _tcx: TyCtxt<'tcx>,\n         machine: &mut Self,\n         alloc_extra: &mut AllocExtra,\n-        (alloc_id, tag): (AllocId, Self::TagExtra),\n+        (alloc_id, prove_extra): (AllocId, Self::ProvenanceExtra),\n         range: AllocRange,\n     ) -> InterpResult<'tcx> {\n         if machine.tracked_alloc_ids.contains(&alloc_id) {\n@@ -841,7 +868,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n         if let Some(stacked_borrows) = &mut alloc_extra.stacked_borrows {\n             stacked_borrows.get_mut().memory_deallocated(\n                 alloc_id,\n-                tag,\n+                prove_extra,\n                 range,\n                 machine.stacked_borrows.as_ref().unwrap(),\n                 &machine.threads,\n@@ -855,16 +882,16 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n     fn retag(\n         ecx: &mut InterpCx<'mir, 'tcx, Self>,\n         kind: mir::RetagKind,\n-        place: &PlaceTy<'tcx, Tag>,\n+        place: &PlaceTy<'tcx, Provenance>,\n     ) -> InterpResult<'tcx> {\n         if ecx.machine.stacked_borrows.is_some() { ecx.retag(kind, place) } else { Ok(()) }\n     }\n \n     #[inline(always)]\n     fn init_frame_extra(\n         ecx: &mut InterpCx<'mir, 'tcx, Self>,\n-        frame: Frame<'mir, 'tcx, Tag>,\n-    ) -> InterpResult<'tcx, Frame<'mir, 'tcx, Tag, FrameData<'tcx>>> {\n+        frame: Frame<'mir, 'tcx, Provenance>,\n+    ) -> InterpResult<'tcx, Frame<'mir, 'tcx, Provenance, FrameData<'tcx>>> {\n         // Start recording our event before doing anything else\n         let timing = if let Some(profiler) = ecx.machine.profiler.as_ref() {\n             let fn_name = frame.instance.to_string();\n@@ -892,13 +919,13 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n \n     fn stack<'a>(\n         ecx: &'a InterpCx<'mir, 'tcx, Self>,\n-    ) -> &'a [Frame<'mir, 'tcx, Self::PointerTag, Self::FrameExtra>] {\n+    ) -> &'a [Frame<'mir, 'tcx, Self::Provenance, Self::FrameExtra>] {\n         ecx.active_thread_stack()\n     }\n \n     fn stack_mut<'a>(\n         ecx: &'a mut InterpCx<'mir, 'tcx, Self>,\n-    ) -> &'a mut Vec<Frame<'mir, 'tcx, Self::PointerTag, Self::FrameExtra>> {\n+    ) -> &'a mut Vec<Frame<'mir, 'tcx, Self::Provenance, Self::FrameExtra>> {\n         ecx.active_thread_stack_mut()\n     }\n \n@@ -925,7 +952,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for Evaluator<'mir, 'tcx> {\n     #[inline(always)]\n     fn after_stack_pop(\n         ecx: &mut InterpCx<'mir, 'tcx, Self>,\n-        mut frame: Frame<'mir, 'tcx, Tag, FrameData<'tcx>>,\n+        mut frame: Frame<'mir, 'tcx, Provenance, FrameData<'tcx>>,\n         unwinding: bool,\n     ) -> InterpResult<'tcx, StackPopJump> {\n         let timing = frame.extra.timing.take();"}, {"sha": "758e747d2786760b8b8f75d6ea140f5674b846cc", "filename": "src/operator.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/167e5dcad39cd12596ace6fce1ef06218e559542/src%2Foperator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/167e5dcad39cd12596ace6fce1ef06218e559542/src%2Foperator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Foperator.rs?ref=167e5dcad39cd12596ace6fce1ef06218e559542", "patch": "@@ -9,18 +9,18 @@ pub trait EvalContextExt<'tcx> {\n     fn binary_ptr_op(\n         &self,\n         bin_op: mir::BinOp,\n-        left: &ImmTy<'tcx, Tag>,\n-        right: &ImmTy<'tcx, Tag>,\n-    ) -> InterpResult<'tcx, (Scalar<Tag>, bool, Ty<'tcx>)>;\n+        left: &ImmTy<'tcx, Provenance>,\n+        right: &ImmTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx, (Scalar<Provenance>, bool, Ty<'tcx>)>;\n }\n \n impl<'mir, 'tcx> EvalContextExt<'tcx> for super::MiriEvalContext<'mir, 'tcx> {\n     fn binary_ptr_op(\n         &self,\n         bin_op: mir::BinOp,\n-        left: &ImmTy<'tcx, Tag>,\n-        right: &ImmTy<'tcx, Tag>,\n-    ) -> InterpResult<'tcx, (Scalar<Tag>, bool, Ty<'tcx>)> {\n+        left: &ImmTy<'tcx, Provenance>,\n+        right: &ImmTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx, (Scalar<Provenance>, bool, Ty<'tcx>)> {\n         use rustc_middle::mir::BinOp::*;\n \n         trace!(\"ptr_op: {:?} {:?} {:?}\", *left, bin_op, *right);"}, {"sha": "3c15165d67be4b77273078b3a3323fdd23848045", "filename": "src/shims/backtrace.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/167e5dcad39cd12596ace6fce1ef06218e559542/src%2Fshims%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/167e5dcad39cd12596ace6fce1ef06218e559542/src%2Fshims%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fbacktrace.rs?ref=167e5dcad39cd12596ace6fce1ef06218e559542", "patch": "@@ -11,8 +11,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         &mut self,\n         abi: Abi,\n         link_name: Symbol,\n-        args: &[OpTy<'tcx, Tag>],\n-        dest: &PlaceTy<'tcx, Tag>,\n+        args: &[OpTy<'tcx, Provenance>],\n+        dest: &PlaceTy<'tcx, Provenance>,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         let [flags] = this.check_shim(abi, Abi::Rust, link_name, args)?;\n@@ -31,8 +31,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         &mut self,\n         abi: Abi,\n         link_name: Symbol,\n-        args: &[OpTy<'tcx, Tag>],\n-        dest: &PlaceTy<'tcx, Tag>,\n+        args: &[OpTy<'tcx, Provenance>],\n+        dest: &PlaceTy<'tcx, Provenance>,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         let tcx = this.tcx;\n@@ -117,7 +117,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n     fn resolve_frame_pointer(\n         &mut self,\n-        ptr: &OpTy<'tcx, Tag>,\n+        ptr: &OpTy<'tcx, Provenance>,\n     ) -> InterpResult<'tcx, (Instance<'tcx>, Loc, String, String)> {\n         let this = self.eval_context_mut();\n \n@@ -145,8 +145,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         &mut self,\n         abi: Abi,\n         link_name: Symbol,\n-        args: &[OpTy<'tcx, Tag>],\n-        dest: &PlaceTy<'tcx, Tag>,\n+        args: &[OpTy<'tcx, Provenance>],\n+        dest: &PlaceTy<'tcx, Provenance>,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         let [ptr, flags] = this.check_shim(abi, Abi::Rust, link_name, args)?;\n@@ -228,7 +228,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         &mut self,\n         abi: Abi,\n         link_name: Symbol,\n-        args: &[OpTy<'tcx, Tag>],\n+        args: &[OpTy<'tcx, Provenance>],\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n "}, {"sha": "5cb3c99e3d194c0773da4fbed9f921c9d67bf033", "filename": "src/shims/dlsym.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/167e5dcad39cd12596ace6fce1ef06218e559542/src%2Fshims%2Fdlsym.rs", "raw_url": "https://github.com/rust-lang/rust/raw/167e5dcad39cd12596ace6fce1ef06218e559542/src%2Fshims%2Fdlsym.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fdlsym.rs?ref=167e5dcad39cd12596ace6fce1ef06218e559542", "patch": "@@ -33,8 +33,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         &mut self,\n         dlsym: Dlsym,\n         abi: Abi,\n-        args: &[OpTy<'tcx, Tag>],\n-        dest: &PlaceTy<'tcx, Tag>,\n+        args: &[OpTy<'tcx, Provenance>],\n+        dest: &PlaceTy<'tcx, Provenance>,\n         ret: Option<mir::BasicBlock>,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();"}, {"sha": "f0818e71b6670e7f7d92c0b6065ff23eb555f33f", "filename": "src/shims/env.rs", "status": "modified", "additions": 26, "deletions": 23, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/167e5dcad39cd12596ace6fce1ef06218e559542/src%2Fshims%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/167e5dcad39cd12596ace6fce1ef06218e559542/src%2Fshims%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fenv.rs?ref=167e5dcad39cd12596ace6fce1ef06218e559542", "patch": "@@ -30,10 +30,10 @@ fn windows_check_buffer_size((success, len): (bool, u64)) -> u32 {\n pub struct EnvVars<'tcx> {\n     /// Stores pointers to the environment variables. These variables must be stored as\n     /// null-terminated target strings (c_str or wide_str) with the `\"{name}={value}\"` format.\n-    map: FxHashMap<OsString, Pointer<Option<Tag>>>,\n+    map: FxHashMap<OsString, Pointer<Option<Provenance>>>,\n \n     /// Place where the `environ` static is stored. Lazily initialized, but then never changes.\n-    pub(crate) environ: Option<MPlaceTy<'tcx, Tag>>,\n+    pub(crate) environ: Option<MPlaceTy<'tcx, Provenance>>,\n }\n \n impl<'tcx> EnvVars<'tcx> {\n@@ -92,7 +92,7 @@ fn alloc_env_var_as_c_str<'mir, 'tcx>(\n     name: &OsStr,\n     value: &OsStr,\n     ecx: &mut InterpCx<'mir, 'tcx, Evaluator<'mir, 'tcx>>,\n-) -> InterpResult<'tcx, Pointer<Option<Tag>>> {\n+) -> InterpResult<'tcx, Pointer<Option<Provenance>>> {\n     let mut name_osstring = name.to_os_string();\n     name_osstring.push(\"=\");\n     name_osstring.push(value);\n@@ -103,7 +103,7 @@ fn alloc_env_var_as_wide_str<'mir, 'tcx>(\n     name: &OsStr,\n     value: &OsStr,\n     ecx: &mut InterpCx<'mir, 'tcx, Evaluator<'mir, 'tcx>>,\n-) -> InterpResult<'tcx, Pointer<Option<Tag>>> {\n+) -> InterpResult<'tcx, Pointer<Option<Provenance>>> {\n     let mut name_osstring = name.to_os_string();\n     name_osstring.push(\"=\");\n     name_osstring.push(value);\n@@ -112,7 +112,10 @@ fn alloc_env_var_as_wide_str<'mir, 'tcx>(\n \n impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n-    fn getenv(&mut self, name_op: &OpTy<'tcx, Tag>) -> InterpResult<'tcx, Pointer<Option<Tag>>> {\n+    fn getenv(\n+        &mut self,\n+        name_op: &OpTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx, Pointer<Option<Provenance>>> {\n         let this = self.eval_context_mut();\n         this.assert_target_os_is_unix(\"getenv\");\n \n@@ -133,9 +136,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     #[allow(non_snake_case)]\n     fn GetEnvironmentVariableW(\n         &mut self,\n-        name_op: &OpTy<'tcx, Tag>, // LPCWSTR\n-        buf_op: &OpTy<'tcx, Tag>,  // LPWSTR\n-        size_op: &OpTy<'tcx, Tag>, // DWORD\n+        name_op: &OpTy<'tcx, Provenance>, // LPCWSTR\n+        buf_op: &OpTy<'tcx, Provenance>,  // LPWSTR\n+        size_op: &OpTy<'tcx, Provenance>, // DWORD\n     ) -> InterpResult<'tcx, u32> {\n         // ^ Returns DWORD (u32 on Windows)\n \n@@ -168,7 +171,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     }\n \n     #[allow(non_snake_case)]\n-    fn GetEnvironmentStringsW(&mut self) -> InterpResult<'tcx, Pointer<Option<Tag>>> {\n+    fn GetEnvironmentStringsW(&mut self) -> InterpResult<'tcx, Pointer<Option<Provenance>>> {\n         let this = self.eval_context_mut();\n         this.assert_target_os(\"windows\", \"GetEnvironmentStringsW\");\n \n@@ -191,7 +194,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     #[allow(non_snake_case)]\n     fn FreeEnvironmentStringsW(\n         &mut self,\n-        env_block_op: &OpTy<'tcx, Tag>,\n+        env_block_op: &OpTy<'tcx, Provenance>,\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n         this.assert_target_os(\"windows\", \"FreeEnvironmentStringsW\");\n@@ -204,8 +207,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n     fn setenv(\n         &mut self,\n-        name_op: &OpTy<'tcx, Tag>,\n-        value_op: &OpTy<'tcx, Tag>,\n+        name_op: &OpTy<'tcx, Provenance>,\n+        value_op: &OpTy<'tcx, Provenance>,\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n         this.assert_target_os_is_unix(\"setenv\");\n@@ -239,8 +242,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     #[allow(non_snake_case)]\n     fn SetEnvironmentVariableW(\n         &mut self,\n-        name_op: &OpTy<'tcx, Tag>,  // LPCWSTR\n-        value_op: &OpTy<'tcx, Tag>, // LPCWSTR\n+        name_op: &OpTy<'tcx, Provenance>,  // LPCWSTR\n+        value_op: &OpTy<'tcx, Provenance>, // LPCWSTR\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n         this.assert_target_os(\"windows\", \"SetEnvironmentVariableW\");\n@@ -276,7 +279,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         }\n     }\n \n-    fn unsetenv(&mut self, name_op: &OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n+    fn unsetenv(&mut self, name_op: &OpTy<'tcx, Provenance>) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n         this.assert_target_os_is_unix(\"unsetenv\");\n \n@@ -304,9 +307,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n     fn getcwd(\n         &mut self,\n-        buf_op: &OpTy<'tcx, Tag>,\n-        size_op: &OpTy<'tcx, Tag>,\n-    ) -> InterpResult<'tcx, Pointer<Option<Tag>>> {\n+        buf_op: &OpTy<'tcx, Provenance>,\n+        size_op: &OpTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx, Pointer<Option<Provenance>>> {\n         let this = self.eval_context_mut();\n         this.assert_target_os_is_unix(\"getcwd\");\n \n@@ -337,8 +340,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     #[allow(non_snake_case)]\n     fn GetCurrentDirectoryW(\n         &mut self,\n-        size_op: &OpTy<'tcx, Tag>, // DWORD\n-        buf_op: &OpTy<'tcx, Tag>,  // LPTSTR\n+        size_op: &OpTy<'tcx, Provenance>, // DWORD\n+        buf_op: &OpTy<'tcx, Provenance>,  // LPTSTR\n     ) -> InterpResult<'tcx, u32> {\n         let this = self.eval_context_mut();\n         this.assert_target_os(\"windows\", \"GetCurrentDirectoryW\");\n@@ -361,7 +364,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         Ok(0)\n     }\n \n-    fn chdir(&mut self, path_op: &OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n+    fn chdir(&mut self, path_op: &OpTy<'tcx, Provenance>) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n         this.assert_target_os_is_unix(\"chdir\");\n \n@@ -386,7 +389,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     #[allow(non_snake_case)]\n     fn SetCurrentDirectoryW(\n         &mut self,\n-        path_op: &OpTy<'tcx, Tag>, // LPCTSTR\n+        path_op: &OpTy<'tcx, Provenance>, // LPCTSTR\n     ) -> InterpResult<'tcx, i32> {\n         // ^ Returns BOOL (i32 on Windows)\n \n@@ -428,7 +431,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         }\n \n         // Collect all the pointers to each variable in a vector.\n-        let mut vars: Vec<Pointer<Option<Tag>>> =\n+        let mut vars: Vec<Pointer<Option<Provenance>>> =\n             this.machine.env_vars.map.values().copied().collect();\n         // Add the trailing null pointer.\n         vars.push(Pointer::null());"}, {"sha": "99f0617162192d9c80d838a60781b8ad77ff53c2", "filename": "src/shims/foreign_items.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/167e5dcad39cd12596ace6fce1ef06218e559542/src%2Fshims%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/167e5dcad39cd12596ace6fce1ef06218e559542/src%2Fshims%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fforeign_items.rs?ref=167e5dcad39cd12596ace6fce1ef06218e559542", "patch": "@@ -74,7 +74,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         size: u64,\n         zero_init: bool,\n         kind: MiriMemoryKind,\n-    ) -> InterpResult<'tcx, Pointer<Option<Tag>>> {\n+    ) -> InterpResult<'tcx, Pointer<Option<Provenance>>> {\n         let this = self.eval_context_mut();\n         if size == 0 {\n             Ok(Pointer::null())\n@@ -89,7 +89,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         }\n     }\n \n-    fn free(&mut self, ptr: Pointer<Option<Tag>>, kind: MiriMemoryKind) -> InterpResult<'tcx> {\n+    fn free(\n+        &mut self,\n+        ptr: Pointer<Option<Provenance>>,\n+        kind: MiriMemoryKind,\n+    ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         if !this.ptr_is_null(ptr)? {\n             this.deallocate_ptr(ptr, None, kind.into())?;\n@@ -99,10 +103,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n     fn realloc(\n         &mut self,\n-        old_ptr: Pointer<Option<Tag>>,\n+        old_ptr: Pointer<Option<Provenance>>,\n         new_size: u64,\n         kind: MiriMemoryKind,\n-    ) -> InterpResult<'tcx, Pointer<Option<Tag>>> {\n+    ) -> InterpResult<'tcx, Pointer<Option<Provenance>>> {\n         let this = self.eval_context_mut();\n         let new_align = this.min_align(new_size, kind);\n         if this.ptr_is_null(old_ptr)? {\n@@ -231,8 +235,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         &mut self,\n         def_id: DefId,\n         abi: Abi,\n-        args: &[OpTy<'tcx, Tag>],\n-        dest: &PlaceTy<'tcx, Tag>,\n+        args: &[OpTy<'tcx, Provenance>],\n+        dest: &PlaceTy<'tcx, Provenance>,\n         ret: Option<mir::BasicBlock>,\n         unwind: StackPopUnwind,\n     ) -> InterpResult<'tcx, Option<(&'mir mir::Body<'tcx>, ty::Instance<'tcx>)>> {\n@@ -353,8 +357,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         &mut self,\n         link_name: Symbol,\n         abi: Abi,\n-        args: &[OpTy<'tcx, Tag>],\n-        dest: &PlaceTy<'tcx, Tag>,\n+        args: &[OpTy<'tcx, Provenance>],\n+        dest: &PlaceTy<'tcx, Provenance>,\n     ) -> InterpResult<'tcx, EmulateByNameResult<'mir, 'tcx>> {\n         let this = self.eval_context_mut();\n "}, {"sha": "8e0bb746e3cd4fae415b43298466b9336a923104", "filename": "src/shims/intrinsics/atomic.rs", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/167e5dcad39cd12596ace6fce1ef06218e559542/src%2Fshims%2Fintrinsics%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/167e5dcad39cd12596ace6fce1ef06218e559542/src%2Fshims%2Fintrinsics%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fintrinsics%2Fatomic.rs?ref=167e5dcad39cd12596ace6fce1ef06218e559542", "patch": "@@ -18,8 +18,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     fn emulate_atomic_intrinsic(\n         &mut self,\n         intrinsic_name: &str,\n-        args: &[OpTy<'tcx, Tag>],\n-        dest: &PlaceTy<'tcx, Tag>,\n+        args: &[OpTy<'tcx, Provenance>],\n+        dest: &PlaceTy<'tcx, Provenance>,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n \n@@ -121,8 +121,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n     fn atomic_load(\n         &mut self,\n-        args: &[OpTy<'tcx, Tag>],\n-        dest: &PlaceTy<'tcx, Tag>,\n+        args: &[OpTy<'tcx, Provenance>],\n+        dest: &PlaceTy<'tcx, Provenance>,\n         atomic: AtomicReadOrd,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n@@ -150,7 +150,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n     fn atomic_store(\n         &mut self,\n-        args: &[OpTy<'tcx, Tag>],\n+        args: &[OpTy<'tcx, Provenance>],\n         atomic: AtomicWriteOrd,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n@@ -177,7 +177,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n     fn compiler_fence(\n         &mut self,\n-        args: &[OpTy<'tcx, Tag>],\n+        args: &[OpTy<'tcx, Provenance>],\n         atomic: AtomicFenceOrd,\n     ) -> InterpResult<'tcx> {\n         let [] = check_arg_count(args)?;\n@@ -188,7 +188,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n     fn atomic_fence(\n         &mut self,\n-        args: &[OpTy<'tcx, Tag>],\n+        args: &[OpTy<'tcx, Provenance>],\n         atomic: AtomicFenceOrd,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n@@ -199,8 +199,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n     fn atomic_op(\n         &mut self,\n-        args: &[OpTy<'tcx, Tag>],\n-        dest: &PlaceTy<'tcx, Tag>,\n+        args: &[OpTy<'tcx, Provenance>],\n+        dest: &PlaceTy<'tcx, Provenance>,\n         atomic_op: AtomicOp,\n         atomic: AtomicRwOrd,\n     ) -> InterpResult<'tcx> {\n@@ -252,8 +252,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n     fn atomic_exchange(\n         &mut self,\n-        args: &[OpTy<'tcx, Tag>],\n-        dest: &PlaceTy<'tcx, Tag>,\n+        args: &[OpTy<'tcx, Provenance>],\n+        dest: &PlaceTy<'tcx, Provenance>,\n         atomic: AtomicRwOrd,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n@@ -280,8 +280,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n     fn atomic_compare_exchange_impl(\n         &mut self,\n-        args: &[OpTy<'tcx, Tag>],\n-        dest: &PlaceTy<'tcx, Tag>,\n+        args: &[OpTy<'tcx, Provenance>],\n+        dest: &PlaceTy<'tcx, Provenance>,\n         success: AtomicRwOrd,\n         fail: AtomicReadOrd,\n         can_fail_spuriously: bool,\n@@ -320,8 +320,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n     fn atomic_compare_exchange(\n         &mut self,\n-        args: &[OpTy<'tcx, Tag>],\n-        dest: &PlaceTy<'tcx, Tag>,\n+        args: &[OpTy<'tcx, Provenance>],\n+        dest: &PlaceTy<'tcx, Provenance>,\n         success: AtomicRwOrd,\n         fail: AtomicReadOrd,\n     ) -> InterpResult<'tcx> {\n@@ -330,8 +330,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n     fn atomic_compare_exchange_weak(\n         &mut self,\n-        args: &[OpTy<'tcx, Tag>],\n-        dest: &PlaceTy<'tcx, Tag>,\n+        args: &[OpTy<'tcx, Provenance>],\n+        dest: &PlaceTy<'tcx, Provenance>,\n         success: AtomicRwOrd,\n         fail: AtomicReadOrd,\n     ) -> InterpResult<'tcx> {"}, {"sha": "c07ed8b294891866c307e450f36c285492584173", "filename": "src/shims/intrinsics/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/167e5dcad39cd12596ace6fce1ef06218e559542/src%2Fshims%2Fintrinsics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/167e5dcad39cd12596ace6fce1ef06218e559542/src%2Fshims%2Fintrinsics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fintrinsics%2Fmod.rs?ref=167e5dcad39cd12596ace6fce1ef06218e559542", "patch": "@@ -20,8 +20,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     fn call_intrinsic(\n         &mut self,\n         instance: ty::Instance<'tcx>,\n-        args: &[OpTy<'tcx, Tag>],\n-        dest: &PlaceTy<'tcx, Tag>,\n+        args: &[OpTy<'tcx, Provenance>],\n+        dest: &PlaceTy<'tcx, Provenance>,\n         ret: Option<mir::BasicBlock>,\n         _unwind: StackPopUnwind,\n     ) -> InterpResult<'tcx> {\n@@ -58,8 +58,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     fn emulate_intrinsic_by_name(\n         &mut self,\n         intrinsic_name: &str,\n-        args: &[OpTy<'tcx, Tag>],\n-        dest: &PlaceTy<'tcx, Tag>,\n+        args: &[OpTy<'tcx, Provenance>],\n+        dest: &PlaceTy<'tcx, Provenance>,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n \n@@ -375,9 +375,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         &self,\n         f: F,\n         dest_ty: ty::Ty<'tcx>,\n-    ) -> InterpResult<'tcx, Scalar<Tag>>\n+    ) -> InterpResult<'tcx, Scalar<Provenance>>\n     where\n-        F: Float + Into<Scalar<Tag>>,\n+        F: Float + Into<Scalar<Provenance>>,\n     {\n         let this = self.eval_context_ref();\n "}, {"sha": "96e97d79358bf84ee823ee18301edb1122d64e1e", "filename": "src/shims/intrinsics/simd.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/167e5dcad39cd12596ace6fce1ef06218e559542/src%2Fshims%2Fintrinsics%2Fsimd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/167e5dcad39cd12596ace6fce1ef06218e559542/src%2Fshims%2Fintrinsics%2Fsimd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fintrinsics%2Fsimd.rs?ref=167e5dcad39cd12596ace6fce1ef06218e559542", "patch": "@@ -12,8 +12,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     fn emulate_simd_intrinsic(\n         &mut self,\n         intrinsic_name: &str,\n-        args: &[OpTy<'tcx, Tag>],\n-        dest: &PlaceTy<'tcx, Tag>,\n+        args: &[OpTy<'tcx, Provenance>],\n+        dest: &PlaceTy<'tcx, Provenance>,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         match intrinsic_name {\n@@ -557,13 +557,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     }\n }\n \n-fn bool_to_simd_element(b: bool, size: Size) -> Scalar<Tag> {\n+fn bool_to_simd_element(b: bool, size: Size) -> Scalar<Provenance> {\n     // SIMD uses all-1 as pattern for \"true\"\n     let val = if b { -1 } else { 0 };\n     Scalar::from_int(val, size)\n }\n \n-fn simd_element_to_bool(elem: ImmTy<'_, Tag>) -> InterpResult<'_, bool> {\n+fn simd_element_to_bool(elem: ImmTy<'_, Provenance>) -> InterpResult<'_, bool> {\n     let val = elem.to_scalar()?.to_int(elem.layout.size)?;\n     Ok(match val {\n         0 => false,\n@@ -581,9 +581,9 @@ fn simd_bitmask_index(idx: u64, vec_len: u64, endianess: Endian) -> u64 {\n }\n \n fn fmax_op<'tcx>(\n-    left: &ImmTy<'tcx, Tag>,\n-    right: &ImmTy<'tcx, Tag>,\n-) -> InterpResult<'tcx, Scalar<Tag>> {\n+    left: &ImmTy<'tcx, Provenance>,\n+    right: &ImmTy<'tcx, Provenance>,\n+) -> InterpResult<'tcx, Scalar<Provenance>> {\n     assert_eq!(left.layout.ty, right.layout.ty);\n     let ty::Float(float_ty) = left.layout.ty.kind() else {\n         bug!(\"fmax operand is not a float\")\n@@ -597,9 +597,9 @@ fn fmax_op<'tcx>(\n }\n \n fn fmin_op<'tcx>(\n-    left: &ImmTy<'tcx, Tag>,\n-    right: &ImmTy<'tcx, Tag>,\n-) -> InterpResult<'tcx, Scalar<Tag>> {\n+    left: &ImmTy<'tcx, Provenance>,\n+    right: &ImmTy<'tcx, Provenance>,\n+) -> InterpResult<'tcx, Scalar<Provenance>> {\n     assert_eq!(left.layout.ty, right.layout.ty);\n     let ty::Float(float_ty) = left.layout.ty.kind() else {\n         bug!(\"fmin operand is not a float\")"}, {"sha": "f5b4de30a5700b7b2383966be63e34b99280a87d", "filename": "src/shims/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/167e5dcad39cd12596ace6fce1ef06218e559542/src%2Fshims%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/167e5dcad39cd12596ace6fce1ef06218e559542/src%2Fshims%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fmod.rs?ref=167e5dcad39cd12596ace6fce1ef06218e559542", "patch": "@@ -27,8 +27,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         &mut self,\n         instance: ty::Instance<'tcx>,\n         abi: Abi,\n-        args: &[OpTy<'tcx, Tag>],\n-        dest: &PlaceTy<'tcx, Tag>,\n+        args: &[OpTy<'tcx, Provenance>],\n+        dest: &PlaceTy<'tcx, Provenance>,\n         ret: Option<mir::BasicBlock>,\n         unwind: StackPopUnwind,\n     ) -> InterpResult<'tcx, Option<(&'mir mir::Body<'tcx>, ty::Instance<'tcx>)>> {\n@@ -62,9 +62,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     /// the actual MIR of `align_offset`.\n     fn align_offset(\n         &mut self,\n-        ptr_op: &OpTy<'tcx, Tag>,\n-        align_op: &OpTy<'tcx, Tag>,\n-        dest: &PlaceTy<'tcx, Tag>,\n+        ptr_op: &OpTy<'tcx, Provenance>,\n+        align_op: &OpTy<'tcx, Provenance>,\n+        dest: &PlaceTy<'tcx, Provenance>,\n         ret: Option<mir::BasicBlock>,\n         unwind: StackPopUnwind,\n     ) -> InterpResult<'tcx, bool> {"}, {"sha": "71824bee346e4f76cf7005e0217d8a66297fff86", "filename": "src/shims/os_str.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/167e5dcad39cd12596ace6fce1ef06218e559542/src%2Fshims%2Fos_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/167e5dcad39cd12596ace6fce1ef06218e559542/src%2Fshims%2Fos_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fos_str.rs?ref=167e5dcad39cd12596ace6fce1ef06218e559542", "patch": "@@ -52,7 +52,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     /// the Unix APIs usually handle.\n     fn read_os_str_from_c_str<'a>(\n         &'a self,\n-        ptr: Pointer<Option<Tag>>,\n+        ptr: Pointer<Option<Provenance>>,\n     ) -> InterpResult<'tcx, &'a OsStr>\n     where\n         'tcx: 'a,\n@@ -67,7 +67,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     /// which is what the Windows APIs usually handle.\n     fn read_os_str_from_wide_str<'a>(\n         &'a self,\n-        ptr: Pointer<Option<Tag>>,\n+        ptr: Pointer<Option<Provenance>>,\n     ) -> InterpResult<'tcx, OsString>\n     where\n         'tcx: 'a,\n@@ -96,7 +96,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     fn write_os_str_to_c_str(\n         &mut self,\n         os_str: &OsStr,\n-        ptr: Pointer<Option<Tag>>,\n+        ptr: Pointer<Option<Provenance>>,\n         size: u64,\n     ) -> InterpResult<'tcx, (bool, u64)> {\n         let bytes = os_str_to_bytes(os_str)?;\n@@ -119,7 +119,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     fn write_os_str_to_wide_str(\n         &mut self,\n         os_str: &OsStr,\n-        ptr: Pointer<Option<Tag>>,\n+        ptr: Pointer<Option<Provenance>>,\n         size: u64,\n     ) -> InterpResult<'tcx, (bool, u64)> {\n         #[cfg(windows)]\n@@ -165,7 +165,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         &mut self,\n         os_str: &OsStr,\n         memkind: MemoryKind<MiriMemoryKind>,\n-    ) -> InterpResult<'tcx, Pointer<Option<Tag>>> {\n+    ) -> InterpResult<'tcx, Pointer<Option<Provenance>>> {\n         let size = u64::try_from(os_str.len()).unwrap().checked_add(1).unwrap(); // Make space for `0` terminator.\n         let this = self.eval_context_mut();\n \n@@ -180,7 +180,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         &mut self,\n         os_str: &OsStr,\n         memkind: MemoryKind<MiriMemoryKind>,\n-    ) -> InterpResult<'tcx, Pointer<Option<Tag>>> {\n+    ) -> InterpResult<'tcx, Pointer<Option<Provenance>>> {\n         let size = u64::try_from(os_str.len()).unwrap().checked_add(1).unwrap(); // Make space for `0x0000` terminator.\n         let this = self.eval_context_mut();\n \n@@ -193,7 +193,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     /// Read a null-terminated sequence of bytes, and perform path separator conversion if needed.\n     fn read_path_from_c_str<'a>(\n         &'a self,\n-        ptr: Pointer<Option<Tag>>,\n+        ptr: Pointer<Option<Provenance>>,\n     ) -> InterpResult<'tcx, Cow<'a, Path>>\n     where\n         'tcx: 'a,\n@@ -209,7 +209,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     }\n \n     /// Read a null-terminated sequence of `u16`s, and perform path separator conversion if needed.\n-    fn read_path_from_wide_str(&self, ptr: Pointer<Option<Tag>>) -> InterpResult<'tcx, PathBuf> {\n+    fn read_path_from_wide_str(\n+        &self,\n+        ptr: Pointer<Option<Provenance>>,\n+    ) -> InterpResult<'tcx, PathBuf> {\n         let this = self.eval_context_ref();\n         let os_str = this.read_os_str_from_wide_str(ptr)?;\n \n@@ -224,7 +227,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     fn write_path_to_c_str(\n         &mut self,\n         path: &Path,\n-        ptr: Pointer<Option<Tag>>,\n+        ptr: Pointer<Option<Provenance>>,\n         size: u64,\n     ) -> InterpResult<'tcx, (bool, u64)> {\n         let this = self.eval_context_mut();\n@@ -238,7 +241,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     fn write_path_to_wide_str(\n         &mut self,\n         path: &Path,\n-        ptr: Pointer<Option<Tag>>,\n+        ptr: Pointer<Option<Provenance>>,\n         size: u64,\n     ) -> InterpResult<'tcx, (bool, u64)> {\n         let this = self.eval_context_mut();"}, {"sha": "362b929eabfee5b78a0030e153293a88a72eaa55", "filename": "src/shims/panic.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/167e5dcad39cd12596ace6fce1ef06218e559542/src%2Fshims%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/167e5dcad39cd12596ace6fce1ef06218e559542/src%2Fshims%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fpanic.rs?ref=167e5dcad39cd12596ace6fce1ef06218e559542", "patch": "@@ -26,11 +26,11 @@ use helpers::check_arg_count;\n #[derive(Debug)]\n pub struct CatchUnwindData<'tcx> {\n     /// The `catch_fn` callback to call in case of a panic.\n-    catch_fn: Scalar<Tag>,\n+    catch_fn: Scalar<Provenance>,\n     /// The `data` argument for that callback.\n-    data: Scalar<Tag>,\n+    data: Scalar<Provenance>,\n     /// The return place from the original call to `try`.\n-    dest: PlaceTy<'tcx, Tag>,\n+    dest: PlaceTy<'tcx, Provenance>,\n     /// The return block from the original call to `try`.\n     ret: mir::BasicBlock,\n }\n@@ -43,7 +43,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         &mut self,\n         abi: Abi,\n         link_name: Symbol,\n-        args: &[OpTy<'tcx, Tag>],\n+        args: &[OpTy<'tcx, Provenance>],\n         unwind: StackPopUnwind,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n@@ -65,8 +65,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     /// Handles the `try` intrinsic, the underlying implementation of `std::panicking::try`.\n     fn handle_try(\n         &mut self,\n-        args: &[OpTy<'tcx, Tag>],\n-        dest: &PlaceTy<'tcx, Tag>,\n+        args: &[OpTy<'tcx, Provenance>],\n+        dest: &PlaceTy<'tcx, Provenance>,\n         ret: mir::BasicBlock,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();"}, {"sha": "a2cbd84bc2dbb9fd9a720111995896bac90f305e", "filename": "src/shims/time.rs", "status": "modified", "additions": 13, "deletions": 10, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/167e5dcad39cd12596ace6fce1ef06218e559542/src%2Fshims%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/167e5dcad39cd12596ace6fce1ef06218e559542/src%2Fshims%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Ftime.rs?ref=167e5dcad39cd12596ace6fce1ef06218e559542", "patch": "@@ -13,8 +13,8 @@ impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mi\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n     fn clock_gettime(\n         &mut self,\n-        clk_id_op: &OpTy<'tcx, Tag>,\n-        tp_op: &OpTy<'tcx, Tag>,\n+        clk_id_op: &OpTy<'tcx, Provenance>,\n+        tp_op: &OpTy<'tcx, Provenance>,\n     ) -> InterpResult<'tcx, i32> {\n         // This clock support is deliberately minimal because a lot of clock types have fiddly\n         // properties (is it possible for Miri to be suspended independently of the host?). If you\n@@ -59,8 +59,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n     fn gettimeofday(\n         &mut self,\n-        tv_op: &OpTy<'tcx, Tag>,\n-        tz_op: &OpTy<'tcx, Tag>,\n+        tv_op: &OpTy<'tcx, Provenance>,\n+        tz_op: &OpTy<'tcx, Provenance>,\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n@@ -85,7 +85,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     }\n \n     #[allow(non_snake_case)]\n-    fn GetSystemTimeAsFileTime(&mut self, LPFILETIME_op: &OpTy<'tcx, Tag>) -> InterpResult<'tcx> {\n+    fn GetSystemTimeAsFileTime(\n+        &mut self,\n+        LPFILETIME_op: &OpTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n \n         this.assert_target_os(\"windows\", \"GetSystemTimeAsFileTime\");\n@@ -115,7 +118,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     #[allow(non_snake_case)]\n     fn QueryPerformanceCounter(\n         &mut self,\n-        lpPerformanceCount_op: &OpTy<'tcx, Tag>,\n+        lpPerformanceCount_op: &OpTy<'tcx, Provenance>,\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n@@ -138,7 +141,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     #[allow(non_snake_case)]\n     fn QueryPerformanceFrequency(\n         &mut self,\n-        lpFrequency_op: &OpTy<'tcx, Tag>,\n+        lpFrequency_op: &OpTy<'tcx, Provenance>,\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n@@ -172,7 +175,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         })\n     }\n \n-    fn mach_timebase_info(&mut self, info_op: &OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n+    fn mach_timebase_info(&mut self, info_op: &OpTy<'tcx, Provenance>) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n         this.assert_target_os(\"macos\", \"mach_timebase_info\");\n@@ -190,8 +193,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n     fn nanosleep(\n         &mut self,\n-        req_op: &OpTy<'tcx, Tag>,\n-        _rem: &OpTy<'tcx, Tag>,\n+        req_op: &OpTy<'tcx, Provenance>,\n+        _rem: &OpTy<'tcx, Provenance>,\n     ) -> InterpResult<'tcx, i32> {\n         // Signal handlers are not supported, so rem will never be written to.\n "}, {"sha": "13af447f76c6751459f5775ef6e5c677a72f9d4d", "filename": "src/shims/tls.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/167e5dcad39cd12596ace6fce1ef06218e559542/src%2Fshims%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/167e5dcad39cd12596ace6fce1ef06218e559542/src%2Fshims%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Ftls.rs?ref=167e5dcad39cd12596ace6fce1ef06218e559542", "patch": "@@ -19,7 +19,7 @@ pub type TlsKey = u128;\n pub struct TlsEntry<'tcx> {\n     /// The data for this key. None is used to represent NULL.\n     /// (We normalize this early to avoid having to do a NULL-ptr-test each time we access the data.)\n-    data: BTreeMap<ThreadId, Scalar<Tag>>,\n+    data: BTreeMap<ThreadId, Scalar<Provenance>>,\n     dtor: Option<ty::Instance<'tcx>>,\n }\n \n@@ -41,7 +41,7 @@ pub struct TlsData<'tcx> {\n \n     /// A single per thread destructor of the thread local storage (that's how\n     /// things work on macOS) with a data argument.\n-    macos_thread_dtors: BTreeMap<ThreadId, (ty::Instance<'tcx>, Scalar<Tag>)>,\n+    macos_thread_dtors: BTreeMap<ThreadId, (ty::Instance<'tcx>, Scalar<Provenance>)>,\n \n     /// State for currently running TLS dtors. If this map contains a key for a\n     /// specific thread, it means that we are in the \"destruct\" phase, during\n@@ -94,7 +94,7 @@ impl<'tcx> TlsData<'tcx> {\n         key: TlsKey,\n         thread_id: ThreadId,\n         cx: &impl HasDataLayout,\n-    ) -> InterpResult<'tcx, Scalar<Tag>> {\n+    ) -> InterpResult<'tcx, Scalar<Provenance>> {\n         match self.keys.get(&key) {\n             Some(TlsEntry { data, .. }) => {\n                 let value = data.get(&thread_id).copied();\n@@ -109,7 +109,7 @@ impl<'tcx> TlsData<'tcx> {\n         &mut self,\n         key: TlsKey,\n         thread_id: ThreadId,\n-        new_data: Scalar<Tag>,\n+        new_data: Scalar<Provenance>,\n         cx: &impl HasDataLayout,\n     ) -> InterpResult<'tcx> {\n         match self.keys.get_mut(&key) {\n@@ -140,7 +140,7 @@ impl<'tcx> TlsData<'tcx> {\n         &mut self,\n         thread: ThreadId,\n         dtor: ty::Instance<'tcx>,\n-        data: Scalar<Tag>,\n+        data: Scalar<Provenance>,\n     ) -> InterpResult<'tcx> {\n         if self.dtors_running.contains_key(&thread) {\n             // UB, according to libstd docs.\n@@ -179,7 +179,7 @@ impl<'tcx> TlsData<'tcx> {\n         &mut self,\n         key: Option<TlsKey>,\n         thread_id: ThreadId,\n-    ) -> Option<(ty::Instance<'tcx>, Scalar<Tag>, TlsKey)> {\n+    ) -> Option<(ty::Instance<'tcx>, Scalar<Provenance>, TlsKey)> {\n         use std::ops::Bound::*;\n \n         let thread_local = &mut self.keys;"}, {"sha": "a806c16e28bbbc768d52ace6c4e1cb085496e0c1", "filename": "src/shims/unix/dlsym.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/167e5dcad39cd12596ace6fce1ef06218e559542/src%2Fshims%2Funix%2Fdlsym.rs", "raw_url": "https://github.com/rust-lang/rust/raw/167e5dcad39cd12596ace6fce1ef06218e559542/src%2Fshims%2Funix%2Fdlsym.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Funix%2Fdlsym.rs?ref=167e5dcad39cd12596ace6fce1ef06218e559542", "patch": "@@ -32,8 +32,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         &mut self,\n         dlsym: Dlsym,\n         abi: Abi,\n-        args: &[OpTy<'tcx, Tag>],\n-        dest: &PlaceTy<'tcx, Tag>,\n+        args: &[OpTy<'tcx, Provenance>],\n+        dest: &PlaceTy<'tcx, Provenance>,\n         ret: Option<mir::BasicBlock>,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();"}, {"sha": "2a051fb77539730dedd2a84ce96755e31c54bdb4", "filename": "src/shims/unix/foreign_items.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/167e5dcad39cd12596ace6fce1ef06218e559542/src%2Fshims%2Funix%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/167e5dcad39cd12596ace6fce1ef06218e559542/src%2Fshims%2Funix%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Funix%2Fforeign_items.rs?ref=167e5dcad39cd12596ace6fce1ef06218e559542", "patch": "@@ -19,8 +19,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         &mut self,\n         link_name: Symbol,\n         abi: Abi,\n-        args: &[OpTy<'tcx, Tag>],\n-        dest: &PlaceTy<'tcx, Tag>,\n+        args: &[OpTy<'tcx, Provenance>],\n+        dest: &PlaceTy<'tcx, Provenance>,\n     ) -> InterpResult<'tcx, EmulateByNameResult<'mir, 'tcx>> {\n         let this = self.eval_context_mut();\n "}, {"sha": "74c322c666d4817be86bb4f2f497b12d9bac35f4", "filename": "src/shims/unix/freebsd/dlsym.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/167e5dcad39cd12596ace6fce1ef06218e559542/src%2Fshims%2Funix%2Ffreebsd%2Fdlsym.rs", "raw_url": "https://github.com/rust-lang/rust/raw/167e5dcad39cd12596ace6fce1ef06218e559542/src%2Fshims%2Funix%2Ffreebsd%2Fdlsym.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Funix%2Ffreebsd%2Fdlsym.rs?ref=167e5dcad39cd12596ace6fce1ef06218e559542", "patch": "@@ -19,8 +19,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     fn call_dlsym(\n         &mut self,\n         dlsym: Dlsym,\n-        _args: &[OpTy<'tcx, Tag>],\n-        _dest: &PlaceTy<'tcx, Tag>,\n+        _args: &[OpTy<'tcx, Provenance>],\n+        _dest: &PlaceTy<'tcx, Provenance>,\n         ret: Option<mir::BasicBlock>,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();"}, {"sha": "658711526d00c67c795bcc104f7d519da7e5bddd", "filename": "src/shims/unix/freebsd/foreign_items.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/167e5dcad39cd12596ace6fce1ef06218e559542/src%2Fshims%2Funix%2Ffreebsd%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/167e5dcad39cd12596ace6fce1ef06218e559542/src%2Fshims%2Funix%2Ffreebsd%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Funix%2Ffreebsd%2Fforeign_items.rs?ref=167e5dcad39cd12596ace6fce1ef06218e559542", "patch": "@@ -11,8 +11,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         &mut self,\n         link_name: Symbol,\n         abi: Abi,\n-        args: &[OpTy<'tcx, Tag>],\n-        dest: &PlaceTy<'tcx, Tag>,\n+        args: &[OpTy<'tcx, Provenance>],\n+        dest: &PlaceTy<'tcx, Provenance>,\n     ) -> InterpResult<'tcx, EmulateByNameResult<'mir, 'tcx>> {\n         let this = self.eval_context_mut();\n         match link_name.as_str() {"}, {"sha": "50a2053078f85504842b953a00774578d6c29945", "filename": "src/shims/unix/fs.rs", "status": "modified", "additions": 64, "deletions": 48, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/167e5dcad39cd12596ace6fce1ef06218e559542/src%2Fshims%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/167e5dcad39cd12596ace6fce1ef06218e559542/src%2Fshims%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Funix%2Ffs.rs?ref=167e5dcad39cd12596ace6fce1ef06218e559542", "patch": "@@ -386,7 +386,7 @@ trait EvalContextExtPrivate<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, '\n     fn macos_stat_write_buf(\n         &mut self,\n         metadata: FileMetadata,\n-        buf_op: &OpTy<'tcx, Tag>,\n+        buf_op: &OpTy<'tcx, Provenance>,\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n@@ -493,7 +493,7 @@ pub struct OpenDir {\n     /// The directory reader on the host.\n     read_dir: ReadDir,\n     /// The most recent entry returned by readdir()\n-    entry: Pointer<Option<Tag>>,\n+    entry: Pointer<Option<Provenance>>,\n }\n \n impl OpenDir {\n@@ -556,7 +556,7 @@ fn maybe_sync_file(\n \n impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n-    fn open(&mut self, args: &[OpTy<'tcx, Tag>]) -> InterpResult<'tcx, i32> {\n+    fn open(&mut self, args: &[OpTy<'tcx, Provenance>]) -> InterpResult<'tcx, i32> {\n         if args.len() < 2 {\n             throw_ub_format!(\n                 \"incorrect number of arguments for `open`: got {}, expected at least 2\",\n@@ -667,7 +667,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         this.try_unwrap_io_result(fd)\n     }\n \n-    fn fcntl(&mut self, args: &[OpTy<'tcx, Tag>]) -> InterpResult<'tcx, i32> {\n+    fn fcntl(&mut self, args: &[OpTy<'tcx, Provenance>]) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n         if args.len() < 2 {\n@@ -741,7 +741,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         }\n     }\n \n-    fn close(&mut self, fd_op: &OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n+    fn close(&mut self, fd_op: &OpTy<'tcx, Provenance>) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n         let fd = this.read_scalar(fd_op)?.to_i32()?;\n@@ -754,7 +754,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         }\n     }\n \n-    fn read(&mut self, fd: i32, buf: Pointer<Option<Tag>>, count: u64) -> InterpResult<'tcx, i64> {\n+    fn read(\n+        &mut self,\n+        fd: i32,\n+        buf: Pointer<Option<Provenance>>,\n+        count: u64,\n+    ) -> InterpResult<'tcx, i64> {\n         let this = self.eval_context_mut();\n \n         // Isolation check is done via `FileDescriptor` trait.\n@@ -802,7 +807,12 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         }\n     }\n \n-    fn write(&mut self, fd: i32, buf: Pointer<Option<Tag>>, count: u64) -> InterpResult<'tcx, i64> {\n+    fn write(\n+        &mut self,\n+        fd: i32,\n+        buf: Pointer<Option<Provenance>>,\n+        count: u64,\n+    ) -> InterpResult<'tcx, i64> {\n         let this = self.eval_context_mut();\n \n         // Isolation check is done via `FileDescriptor` trait.\n@@ -832,9 +842,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n     fn lseek64(\n         &mut self,\n-        fd_op: &OpTy<'tcx, Tag>,\n-        offset_op: &OpTy<'tcx, Tag>,\n-        whence_op: &OpTy<'tcx, Tag>,\n+        fd_op: &OpTy<'tcx, Provenance>,\n+        offset_op: &OpTy<'tcx, Provenance>,\n+        whence_op: &OpTy<'tcx, Provenance>,\n     ) -> InterpResult<'tcx, i64> {\n         let this = self.eval_context_mut();\n \n@@ -867,7 +877,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         }\n     }\n \n-    fn unlink(&mut self, path_op: &OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n+    fn unlink(&mut self, path_op: &OpTy<'tcx, Provenance>) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n         let path = this.read_path_from_c_str(this.read_pointer(path_op)?)?;\n@@ -885,8 +895,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n     fn symlink(\n         &mut self,\n-        target_op: &OpTy<'tcx, Tag>,\n-        linkpath_op: &OpTy<'tcx, Tag>,\n+        target_op: &OpTy<'tcx, Provenance>,\n+        linkpath_op: &OpTy<'tcx, Provenance>,\n     ) -> InterpResult<'tcx, i32> {\n         #[cfg(unix)]\n         fn create_link(src: &Path, dst: &Path) -> std::io::Result<()> {\n@@ -916,8 +926,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n     fn macos_stat(\n         &mut self,\n-        path_op: &OpTy<'tcx, Tag>,\n-        buf_op: &OpTy<'tcx, Tag>,\n+        path_op: &OpTy<'tcx, Provenance>,\n+        buf_op: &OpTy<'tcx, Provenance>,\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n         this.assert_target_os(\"macos\", \"stat\");\n@@ -945,8 +955,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     // `lstat` is used to get symlink metadata.\n     fn macos_lstat(\n         &mut self,\n-        path_op: &OpTy<'tcx, Tag>,\n-        buf_op: &OpTy<'tcx, Tag>,\n+        path_op: &OpTy<'tcx, Provenance>,\n+        buf_op: &OpTy<'tcx, Provenance>,\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n         this.assert_target_os(\"macos\", \"lstat\");\n@@ -972,8 +982,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n     fn macos_fstat(\n         &mut self,\n-        fd_op: &OpTy<'tcx, Tag>,\n-        buf_op: &OpTy<'tcx, Tag>,\n+        fd_op: &OpTy<'tcx, Provenance>,\n+        buf_op: &OpTy<'tcx, Provenance>,\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n@@ -997,11 +1007,11 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n     fn linux_statx(\n         &mut self,\n-        dirfd_op: &OpTy<'tcx, Tag>,    // Should be an `int`\n-        pathname_op: &OpTy<'tcx, Tag>, // Should be a `const char *`\n-        flags_op: &OpTy<'tcx, Tag>,    // Should be an `int`\n-        mask_op: &OpTy<'tcx, Tag>,     // Should be an `unsigned int`\n-        statxbuf_op: &OpTy<'tcx, Tag>, // Should be a `struct statx *`\n+        dirfd_op: &OpTy<'tcx, Provenance>,    // Should be an `int`\n+        pathname_op: &OpTy<'tcx, Provenance>, // Should be a `const char *`\n+        flags_op: &OpTy<'tcx, Provenance>,    // Should be an `int`\n+        mask_op: &OpTy<'tcx, Provenance>,     // Should be an `unsigned int`\n+        statxbuf_op: &OpTy<'tcx, Provenance>, // Should be a `struct statx *`\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n@@ -1188,8 +1198,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n     fn rename(\n         &mut self,\n-        oldpath_op: &OpTy<'tcx, Tag>,\n-        newpath_op: &OpTy<'tcx, Tag>,\n+        oldpath_op: &OpTy<'tcx, Provenance>,\n+        newpath_op: &OpTy<'tcx, Provenance>,\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n@@ -1219,8 +1229,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n     fn mkdir(\n         &mut self,\n-        path_op: &OpTy<'tcx, Tag>,\n-        mode_op: &OpTy<'tcx, Tag>,\n+        path_op: &OpTy<'tcx, Provenance>,\n+        mode_op: &OpTy<'tcx, Provenance>,\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n@@ -1256,7 +1266,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         this.try_unwrap_io_result(result)\n     }\n \n-    fn rmdir(&mut self, path_op: &OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n+    fn rmdir(&mut self, path_op: &OpTy<'tcx, Provenance>) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n         let path = this.read_path_from_c_str(this.read_pointer(path_op)?)?;\n@@ -1273,7 +1283,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         this.try_unwrap_io_result(result)\n     }\n \n-    fn opendir(&mut self, name_op: &OpTy<'tcx, Tag>) -> InterpResult<'tcx, Scalar<Tag>> {\n+    fn opendir(\n+        &mut self,\n+        name_op: &OpTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx, Scalar<Provenance>> {\n         let this = self.eval_context_mut();\n \n         let name = this.read_path_from_c_str(this.read_pointer(name_op)?)?;\n@@ -1304,7 +1317,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         }\n     }\n \n-    fn linux_readdir64(&mut self, dirp_op: &OpTy<'tcx, Tag>) -> InterpResult<'tcx, Scalar<Tag>> {\n+    fn linux_readdir64(\n+        &mut self,\n+        dirp_op: &OpTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx, Scalar<Provenance>> {\n         let this = self.eval_context_mut();\n \n         this.assert_target_os(\"linux\", \"readdir64\");\n@@ -1393,9 +1409,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n     fn macos_readdir_r(\n         &mut self,\n-        dirp_op: &OpTy<'tcx, Tag>,\n-        entry_op: &OpTy<'tcx, Tag>,\n-        result_op: &OpTy<'tcx, Tag>,\n+        dirp_op: &OpTy<'tcx, Provenance>,\n+        entry_op: &OpTy<'tcx, Provenance>,\n+        result_op: &OpTy<'tcx, Provenance>,\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n@@ -1490,7 +1506,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         }\n     }\n \n-    fn closedir(&mut self, dirp_op: &OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n+    fn closedir(&mut self, dirp_op: &OpTy<'tcx, Provenance>) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n         let dirp = this.read_scalar(dirp_op)?.to_machine_usize(this)?;\n@@ -1513,8 +1529,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n     fn ftruncate64(\n         &mut self,\n-        fd_op: &OpTy<'tcx, Tag>,\n-        length_op: &OpTy<'tcx, Tag>,\n+        fd_op: &OpTy<'tcx, Provenance>,\n+        length_op: &OpTy<'tcx, Provenance>,\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n@@ -1551,7 +1567,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         }\n     }\n \n-    fn fsync(&mut self, fd_op: &OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n+    fn fsync(&mut self, fd_op: &OpTy<'tcx, Provenance>) -> InterpResult<'tcx, i32> {\n         // On macOS, `fsync` (unlike `fcntl(F_FULLFSYNC)`) does not wait for the\n         // underlying disk to finish writing. In the interest of host compatibility,\n         // we conservatively implement this with `sync_all`, which\n@@ -1578,7 +1594,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         }\n     }\n \n-    fn fdatasync(&mut self, fd_op: &OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n+    fn fdatasync(&mut self, fd_op: &OpTy<'tcx, Provenance>) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n         let fd = this.read_scalar(fd_op)?.to_i32()?;\n@@ -1602,10 +1618,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n     fn sync_file_range(\n         &mut self,\n-        fd_op: &OpTy<'tcx, Tag>,\n-        offset_op: &OpTy<'tcx, Tag>,\n-        nbytes_op: &OpTy<'tcx, Tag>,\n-        flags_op: &OpTy<'tcx, Tag>,\n+        fd_op: &OpTy<'tcx, Provenance>,\n+        offset_op: &OpTy<'tcx, Provenance>,\n+        nbytes_op: &OpTy<'tcx, Provenance>,\n+        flags_op: &OpTy<'tcx, Provenance>,\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n@@ -1647,9 +1663,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n     fn readlink(\n         &mut self,\n-        pathname_op: &OpTy<'tcx, Tag>,\n-        buf_op: &OpTy<'tcx, Tag>,\n-        bufsize_op: &OpTy<'tcx, Tag>,\n+        pathname_op: &OpTy<'tcx, Provenance>,\n+        buf_op: &OpTy<'tcx, Provenance>,\n+        bufsize_op: &OpTy<'tcx, Provenance>,\n     ) -> InterpResult<'tcx, i64> {\n         let this = self.eval_context_mut();\n \n@@ -1691,7 +1707,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     }\n \n     #[cfg_attr(not(unix), allow(unused))]\n-    fn isatty(&mut self, miri_fd: &OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n+    fn isatty(&mut self, miri_fd: &OpTy<'tcx, Provenance>) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n         #[cfg(unix)]\n         if matches!(this.machine.isolated_op, IsolatedOp::Allow) {\n@@ -1740,7 +1756,7 @@ fn extract_sec_and_nsec<'tcx>(\n /// Stores a file's metadata in order to avoid code duplication in the different metadata related\n /// shims.\n struct FileMetadata {\n-    mode: Scalar<Tag>,\n+    mode: Scalar<Provenance>,\n     size: u64,\n     created: Option<(u64, u32)>,\n     accessed: Option<(u64, u32)>,"}, {"sha": "44d51c4a0b3abfccd1e294ad369ce21294e431e5", "filename": "src/shims/unix/linux/dlsym.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/167e5dcad39cd12596ace6fce1ef06218e559542/src%2Fshims%2Funix%2Flinux%2Fdlsym.rs", "raw_url": "https://github.com/rust-lang/rust/raw/167e5dcad39cd12596ace6fce1ef06218e559542/src%2Fshims%2Funix%2Flinux%2Fdlsym.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Funix%2Flinux%2Fdlsym.rs?ref=167e5dcad39cd12596ace6fce1ef06218e559542", "patch": "@@ -23,8 +23,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     fn call_dlsym(\n         &mut self,\n         dlsym: Dlsym,\n-        _args: &[OpTy<'tcx, Tag>],\n-        _dest: &PlaceTy<'tcx, Tag>,\n+        _args: &[OpTy<'tcx, Provenance>],\n+        _dest: &PlaceTy<'tcx, Provenance>,\n         ret: Option<mir::BasicBlock>,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();"}, {"sha": "bae3780b460c787bb1ff1cada8b9693824a62b91", "filename": "src/shims/unix/linux/foreign_items.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/167e5dcad39cd12596ace6fce1ef06218e559542/src%2Fshims%2Funix%2Flinux%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/167e5dcad39cd12596ace6fce1ef06218e559542/src%2Fshims%2Funix%2Flinux%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Funix%2Flinux%2Fforeign_items.rs?ref=167e5dcad39cd12596ace6fce1ef06218e559542", "patch": "@@ -14,8 +14,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         &mut self,\n         link_name: Symbol,\n         abi: Abi,\n-        args: &[OpTy<'tcx, Tag>],\n-        dest: &PlaceTy<'tcx, Tag>,\n+        args: &[OpTy<'tcx, Provenance>],\n+        dest: &PlaceTy<'tcx, Provenance>,\n     ) -> InterpResult<'tcx, EmulateByNameResult<'mir, 'tcx>> {\n         let this = self.eval_context_mut();\n \n@@ -165,10 +165,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n // Shims the linux `getrandom` syscall.\n fn getrandom<'tcx>(\n     this: &mut MiriEvalContext<'_, 'tcx>,\n-    ptr: &OpTy<'tcx, Tag>,\n-    len: &OpTy<'tcx, Tag>,\n-    flags: &OpTy<'tcx, Tag>,\n-    dest: &PlaceTy<'tcx, Tag>,\n+    ptr: &OpTy<'tcx, Provenance>,\n+    len: &OpTy<'tcx, Provenance>,\n+    flags: &OpTy<'tcx, Provenance>,\n+    dest: &PlaceTy<'tcx, Provenance>,\n ) -> InterpResult<'tcx> {\n     let ptr = this.read_pointer(ptr)?;\n     let len = this.read_scalar(len)?.to_machine_usize(this)?;"}, {"sha": "a11aa8ed849c88d2fd5a22f37c4f258bffbfbd36", "filename": "src/shims/unix/linux/sync.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/167e5dcad39cd12596ace6fce1ef06218e559542/src%2Fshims%2Funix%2Flinux%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/167e5dcad39cd12596ace6fce1ef06218e559542/src%2Fshims%2Funix%2Flinux%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Funix%2Flinux%2Fsync.rs?ref=167e5dcad39cd12596ace6fce1ef06218e559542", "patch": "@@ -7,8 +7,8 @@ use std::time::{Instant, SystemTime};\n /// `args` is the arguments *after* the syscall number.\n pub fn futex<'tcx>(\n     this: &mut MiriEvalContext<'_, 'tcx>,\n-    args: &[OpTy<'tcx, Tag>],\n-    dest: &PlaceTy<'tcx, Tag>,\n+    args: &[OpTy<'tcx, Provenance>],\n+    dest: &PlaceTy<'tcx, Provenance>,\n ) -> InterpResult<'tcx> {\n     // The amount of arguments used depends on the type of futex operation.\n     // The full futex syscall takes six arguments (excluding the syscall"}, {"sha": "f21f1ae9af6dd0c9b0f2d515177bae7b89c6ffe3", "filename": "src/shims/unix/macos/dlsym.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/167e5dcad39cd12596ace6fce1ef06218e559542/src%2Fshims%2Funix%2Fmacos%2Fdlsym.rs", "raw_url": "https://github.com/rust-lang/rust/raw/167e5dcad39cd12596ace6fce1ef06218e559542/src%2Fshims%2Funix%2Fmacos%2Fdlsym.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Funix%2Fmacos%2Fdlsym.rs?ref=167e5dcad39cd12596ace6fce1ef06218e559542", "patch": "@@ -27,8 +27,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     fn call_dlsym(\n         &mut self,\n         dlsym: Dlsym,\n-        args: &[OpTy<'tcx, Tag>],\n-        dest: &PlaceTy<'tcx, Tag>,\n+        args: &[OpTy<'tcx, Provenance>],\n+        dest: &PlaceTy<'tcx, Provenance>,\n         ret: Option<mir::BasicBlock>,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();"}, {"sha": "21c7762c3ca199d82e742dc90678b6f21d724444", "filename": "src/shims/unix/macos/foreign_items.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/167e5dcad39cd12596ace6fce1ef06218e559542/src%2Fshims%2Funix%2Fmacos%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/167e5dcad39cd12596ace6fce1ef06218e559542/src%2Fshims%2Funix%2Fmacos%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Funix%2Fmacos%2Fforeign_items.rs?ref=167e5dcad39cd12596ace6fce1ef06218e559542", "patch": "@@ -12,8 +12,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         &mut self,\n         link_name: Symbol,\n         abi: Abi,\n-        args: &[OpTy<'tcx, Tag>],\n-        dest: &PlaceTy<'tcx, Tag>,\n+        args: &[OpTy<'tcx, Provenance>],\n+        dest: &PlaceTy<'tcx, Provenance>,\n     ) -> InterpResult<'tcx, EmulateByNameResult<'mir, 'tcx>> {\n         let this = self.eval_context_mut();\n "}, {"sha": "18226c2b8cf64948645a73e5bd8b497598d2e7e0", "filename": "src/shims/unix/sync.rs", "status": "modified", "additions": 111, "deletions": 66, "changes": 177, "blob_url": "https://github.com/rust-lang/rust/blob/167e5dcad39cd12596ace6fce1ef06218e559542/src%2Fshims%2Funix%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/167e5dcad39cd12596ace6fce1ef06218e559542/src%2Fshims%2Funix%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Funix%2Fsync.rs?ref=167e5dcad39cd12596ace6fce1ef06218e559542", "patch": "@@ -21,14 +21,14 @@ const PTHREAD_MUTEX_NORMAL_FLAG: i32 = 0x8000000;\n \n fn is_mutex_kind_default<'mir, 'tcx: 'mir>(\n     ecx: &mut MiriEvalContext<'mir, 'tcx>,\n-    kind: Scalar<Tag>,\n+    kind: Scalar<Provenance>,\n ) -> InterpResult<'tcx, bool> {\n     Ok(kind == ecx.eval_libc(\"PTHREAD_MUTEX_DEFAULT\")?)\n }\n \n fn is_mutex_kind_normal<'mir, 'tcx: 'mir>(\n     ecx: &mut MiriEvalContext<'mir, 'tcx>,\n-    kind: Scalar<Tag>,\n+    kind: Scalar<Provenance>,\n ) -> InterpResult<'tcx, bool> {\n     let kind = kind.to_i32()?;\n     let mutex_normal_kind = ecx.eval_libc(\"PTHREAD_MUTEX_NORMAL\")?.to_i32()?;\n@@ -37,15 +37,15 @@ fn is_mutex_kind_normal<'mir, 'tcx: 'mir>(\n \n fn mutexattr_get_kind<'mir, 'tcx: 'mir>(\n     ecx: &MiriEvalContext<'mir, 'tcx>,\n-    attr_op: &OpTy<'tcx, Tag>,\n-) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n+    attr_op: &OpTy<'tcx, Provenance>,\n+) -> InterpResult<'tcx, ScalarMaybeUninit<Provenance>> {\n     ecx.read_scalar_at_offset(attr_op, 0, ecx.machine.layouts.i32)\n }\n \n fn mutexattr_set_kind<'mir, 'tcx: 'mir>(\n     ecx: &mut MiriEvalContext<'mir, 'tcx>,\n-    attr_op: &OpTy<'tcx, Tag>,\n-    kind: impl Into<ScalarMaybeUninit<Tag>>,\n+    attr_op: &OpTy<'tcx, Provenance>,\n+    kind: impl Into<ScalarMaybeUninit<Provenance>>,\n ) -> InterpResult<'tcx, ()> {\n     ecx.write_scalar_at_offset(attr_op, 0, kind, layout_of_maybe_uninit(ecx.tcx, ecx.tcx.types.i32))\n }\n@@ -61,8 +61,8 @@ fn mutexattr_set_kind<'mir, 'tcx: 'mir>(\n \n fn mutex_get_kind<'mir, 'tcx: 'mir>(\n     ecx: &MiriEvalContext<'mir, 'tcx>,\n-    mutex_op: &OpTy<'tcx, Tag>,\n-) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n+    mutex_op: &OpTy<'tcx, Provenance>,\n+) -> InterpResult<'tcx, ScalarMaybeUninit<Provenance>> {\n     let offset = if ecx.pointer_size().bytes() == 8 { 16 } else { 12 };\n     ecx.read_scalar_at_offset_atomic(\n         mutex_op,\n@@ -74,8 +74,8 @@ fn mutex_get_kind<'mir, 'tcx: 'mir>(\n \n fn mutex_set_kind<'mir, 'tcx: 'mir>(\n     ecx: &mut MiriEvalContext<'mir, 'tcx>,\n-    mutex_op: &OpTy<'tcx, Tag>,\n-    kind: impl Into<ScalarMaybeUninit<Tag>>,\n+    mutex_op: &OpTy<'tcx, Provenance>,\n+    kind: impl Into<ScalarMaybeUninit<Provenance>>,\n ) -> InterpResult<'tcx, ()> {\n     let offset = if ecx.pointer_size().bytes() == 8 { 16 } else { 12 };\n     ecx.write_scalar_at_offset_atomic(\n@@ -89,15 +89,15 @@ fn mutex_set_kind<'mir, 'tcx: 'mir>(\n \n fn mutex_get_id<'mir, 'tcx: 'mir>(\n     ecx: &MiriEvalContext<'mir, 'tcx>,\n-    mutex_op: &OpTy<'tcx, Tag>,\n-) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n+    mutex_op: &OpTy<'tcx, Provenance>,\n+) -> InterpResult<'tcx, ScalarMaybeUninit<Provenance>> {\n     ecx.read_scalar_at_offset_atomic(mutex_op, 4, ecx.machine.layouts.u32, AtomicReadOrd::Relaxed)\n }\n \n fn mutex_set_id<'mir, 'tcx: 'mir>(\n     ecx: &mut MiriEvalContext<'mir, 'tcx>,\n-    mutex_op: &OpTy<'tcx, Tag>,\n-    id: impl Into<ScalarMaybeUninit<Tag>>,\n+    mutex_op: &OpTy<'tcx, Provenance>,\n+    id: impl Into<ScalarMaybeUninit<Provenance>>,\n ) -> InterpResult<'tcx, ()> {\n     ecx.write_scalar_at_offset_atomic(\n         mutex_op,\n@@ -110,7 +110,7 @@ fn mutex_set_id<'mir, 'tcx: 'mir>(\n \n fn mutex_get_or_create_id<'mir, 'tcx: 'mir>(\n     ecx: &mut MiriEvalContext<'mir, 'tcx>,\n-    mutex_op: &OpTy<'tcx, Tag>,\n+    mutex_op: &OpTy<'tcx, Provenance>,\n ) -> InterpResult<'tcx, MutexId> {\n     let value_place = ecx.deref_operand_and_offset(mutex_op, 4, ecx.machine.layouts.u32)?;\n \n@@ -145,15 +145,15 @@ fn mutex_get_or_create_id<'mir, 'tcx: 'mir>(\n \n fn rwlock_get_id<'mir, 'tcx: 'mir>(\n     ecx: &MiriEvalContext<'mir, 'tcx>,\n-    rwlock_op: &OpTy<'tcx, Tag>,\n-) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n+    rwlock_op: &OpTy<'tcx, Provenance>,\n+) -> InterpResult<'tcx, ScalarMaybeUninit<Provenance>> {\n     ecx.read_scalar_at_offset_atomic(rwlock_op, 4, ecx.machine.layouts.u32, AtomicReadOrd::Relaxed)\n }\n \n fn rwlock_set_id<'mir, 'tcx: 'mir>(\n     ecx: &mut MiriEvalContext<'mir, 'tcx>,\n-    rwlock_op: &OpTy<'tcx, Tag>,\n-    id: impl Into<ScalarMaybeUninit<Tag>>,\n+    rwlock_op: &OpTy<'tcx, Provenance>,\n+    id: impl Into<ScalarMaybeUninit<Provenance>>,\n ) -> InterpResult<'tcx, ()> {\n     ecx.write_scalar_at_offset_atomic(\n         rwlock_op,\n@@ -166,7 +166,7 @@ fn rwlock_set_id<'mir, 'tcx: 'mir>(\n \n fn rwlock_get_or_create_id<'mir, 'tcx: 'mir>(\n     ecx: &mut MiriEvalContext<'mir, 'tcx>,\n-    rwlock_op: &OpTy<'tcx, Tag>,\n+    rwlock_op: &OpTy<'tcx, Provenance>,\n ) -> InterpResult<'tcx, RwLockId> {\n     let value_place = ecx.deref_operand_and_offset(rwlock_op, 4, ecx.machine.layouts.u32)?;\n \n@@ -200,15 +200,15 @@ fn rwlock_get_or_create_id<'mir, 'tcx: 'mir>(\n \n fn condattr_get_clock_id<'mir, 'tcx: 'mir>(\n     ecx: &MiriEvalContext<'mir, 'tcx>,\n-    attr_op: &OpTy<'tcx, Tag>,\n-) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n+    attr_op: &OpTy<'tcx, Provenance>,\n+) -> InterpResult<'tcx, ScalarMaybeUninit<Provenance>> {\n     ecx.read_scalar_at_offset(attr_op, 0, ecx.machine.layouts.i32)\n }\n \n fn condattr_set_clock_id<'mir, 'tcx: 'mir>(\n     ecx: &mut MiriEvalContext<'mir, 'tcx>,\n-    attr_op: &OpTy<'tcx, Tag>,\n-    clock_id: impl Into<ScalarMaybeUninit<Tag>>,\n+    attr_op: &OpTy<'tcx, Provenance>,\n+    clock_id: impl Into<ScalarMaybeUninit<Provenance>>,\n ) -> InterpResult<'tcx, ()> {\n     ecx.write_scalar_at_offset(\n         attr_op,\n@@ -229,15 +229,15 @@ fn condattr_set_clock_id<'mir, 'tcx: 'mir>(\n \n fn cond_get_id<'mir, 'tcx: 'mir>(\n     ecx: &MiriEvalContext<'mir, 'tcx>,\n-    cond_op: &OpTy<'tcx, Tag>,\n-) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n+    cond_op: &OpTy<'tcx, Provenance>,\n+) -> InterpResult<'tcx, ScalarMaybeUninit<Provenance>> {\n     ecx.read_scalar_at_offset_atomic(cond_op, 4, ecx.machine.layouts.u32, AtomicReadOrd::Relaxed)\n }\n \n fn cond_set_id<'mir, 'tcx: 'mir>(\n     ecx: &mut MiriEvalContext<'mir, 'tcx>,\n-    cond_op: &OpTy<'tcx, Tag>,\n-    id: impl Into<ScalarMaybeUninit<Tag>>,\n+    cond_op: &OpTy<'tcx, Provenance>,\n+    id: impl Into<ScalarMaybeUninit<Provenance>>,\n ) -> InterpResult<'tcx, ()> {\n     ecx.write_scalar_at_offset_atomic(\n         cond_op,\n@@ -250,7 +250,7 @@ fn cond_set_id<'mir, 'tcx: 'mir>(\n \n fn cond_get_or_create_id<'mir, 'tcx: 'mir>(\n     ecx: &mut MiriEvalContext<'mir, 'tcx>,\n-    cond_op: &OpTy<'tcx, Tag>,\n+    cond_op: &OpTy<'tcx, Provenance>,\n ) -> InterpResult<'tcx, CondvarId> {\n     let value_place = ecx.deref_operand_and_offset(cond_op, 4, ecx.machine.layouts.u32)?;\n \n@@ -278,15 +278,15 @@ fn cond_get_or_create_id<'mir, 'tcx: 'mir>(\n \n fn cond_get_clock_id<'mir, 'tcx: 'mir>(\n     ecx: &MiriEvalContext<'mir, 'tcx>,\n-    cond_op: &OpTy<'tcx, Tag>,\n-) -> InterpResult<'tcx, ScalarMaybeUninit<Tag>> {\n+    cond_op: &OpTy<'tcx, Provenance>,\n+) -> InterpResult<'tcx, ScalarMaybeUninit<Provenance>> {\n     ecx.read_scalar_at_offset(cond_op, 8, ecx.machine.layouts.i32)\n }\n \n fn cond_set_clock_id<'mir, 'tcx: 'mir>(\n     ecx: &mut MiriEvalContext<'mir, 'tcx>,\n-    cond_op: &OpTy<'tcx, Tag>,\n-    clock_id: impl Into<ScalarMaybeUninit<Tag>>,\n+    cond_op: &OpTy<'tcx, Provenance>,\n+    clock_id: impl Into<ScalarMaybeUninit<Provenance>>,\n ) -> InterpResult<'tcx, ()> {\n     ecx.write_scalar_at_offset(\n         cond_op,\n@@ -347,7 +347,10 @@ fn release_cond_mutex_and_block<'mir, 'tcx: 'mir>(\n \n impl<'mir, 'tcx> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n-    fn pthread_mutexattr_init(&mut self, attr_op: &OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n+    fn pthread_mutexattr_init(\n+        &mut self,\n+        attr_op: &OpTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n         let default_kind = this.eval_libc(\"PTHREAD_MUTEX_DEFAULT\")?;\n@@ -358,8 +361,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n     fn pthread_mutexattr_settype(\n         &mut self,\n-        attr_op: &OpTy<'tcx, Tag>,\n-        kind_op: &OpTy<'tcx, Tag>,\n+        attr_op: &OpTy<'tcx, Provenance>,\n+        kind_op: &OpTy<'tcx, Provenance>,\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n@@ -397,7 +400,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         Ok(0)\n     }\n \n-    fn pthread_mutexattr_destroy(&mut self, attr_op: &OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n+    fn pthread_mutexattr_destroy(\n+        &mut self,\n+        attr_op: &OpTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n         // Destroying an uninit pthread_mutexattr is UB, so check to make sure it's not uninit.\n@@ -423,8 +429,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n     fn pthread_mutex_init(\n         &mut self,\n-        mutex_op: &OpTy<'tcx, Tag>,\n-        attr_op: &OpTy<'tcx, Tag>,\n+        mutex_op: &OpTy<'tcx, Provenance>,\n+        attr_op: &OpTy<'tcx, Provenance>,\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n@@ -443,7 +449,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         Ok(0)\n     }\n \n-    fn pthread_mutex_lock(&mut self, mutex_op: &OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n+    fn pthread_mutex_lock(&mut self, mutex_op: &OpTy<'tcx, Provenance>) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n         let kind = mutex_get_kind(this, mutex_op)?.check_init()?;\n@@ -480,7 +486,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         }\n     }\n \n-    fn pthread_mutex_trylock(&mut self, mutex_op: &OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n+    fn pthread_mutex_trylock(\n+        &mut self,\n+        mutex_op: &OpTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n         let kind = mutex_get_kind(this, mutex_op)?.check_init()?;\n@@ -513,7 +522,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         }\n     }\n \n-    fn pthread_mutex_unlock(&mut self, mutex_op: &OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n+    fn pthread_mutex_unlock(\n+        &mut self,\n+        mutex_op: &OpTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n         let kind = mutex_get_kind(this, mutex_op)?.check_init()?;\n@@ -545,7 +557,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         }\n     }\n \n-    fn pthread_mutex_destroy(&mut self, mutex_op: &OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n+    fn pthread_mutex_destroy(\n+        &mut self,\n+        mutex_op: &OpTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n         let id = mutex_get_or_create_id(this, mutex_op)?;\n@@ -566,7 +581,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         Ok(0)\n     }\n \n-    fn pthread_rwlock_rdlock(&mut self, rwlock_op: &OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n+    fn pthread_rwlock_rdlock(\n+        &mut self,\n+        rwlock_op: &OpTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n         let id = rwlock_get_or_create_id(this, rwlock_op)?;\n@@ -581,7 +599,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         }\n     }\n \n-    fn pthread_rwlock_tryrdlock(&mut self, rwlock_op: &OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n+    fn pthread_rwlock_tryrdlock(\n+        &mut self,\n+        rwlock_op: &OpTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n         let id = rwlock_get_or_create_id(this, rwlock_op)?;\n@@ -595,7 +616,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         }\n     }\n \n-    fn pthread_rwlock_wrlock(&mut self, rwlock_op: &OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n+    fn pthread_rwlock_wrlock(\n+        &mut self,\n+        rwlock_op: &OpTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n         let id = rwlock_get_or_create_id(this, rwlock_op)?;\n@@ -622,7 +646,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         Ok(0)\n     }\n \n-    fn pthread_rwlock_trywrlock(&mut self, rwlock_op: &OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n+    fn pthread_rwlock_trywrlock(\n+        &mut self,\n+        rwlock_op: &OpTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n         let id = rwlock_get_or_create_id(this, rwlock_op)?;\n@@ -636,7 +663,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         }\n     }\n \n-    fn pthread_rwlock_unlock(&mut self, rwlock_op: &OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n+    fn pthread_rwlock_unlock(\n+        &mut self,\n+        rwlock_op: &OpTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n         let id = rwlock_get_or_create_id(this, rwlock_op)?;\n@@ -652,7 +682,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         }\n     }\n \n-    fn pthread_rwlock_destroy(&mut self, rwlock_op: &OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n+    fn pthread_rwlock_destroy(\n+        &mut self,\n+        rwlock_op: &OpTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n         let id = rwlock_get_or_create_id(this, rwlock_op)?;\n@@ -671,7 +704,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         Ok(0)\n     }\n \n-    fn pthread_condattr_init(&mut self, attr_op: &OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n+    fn pthread_condattr_init(\n+        &mut self,\n+        attr_op: &OpTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n         // The default value of the clock attribute shall refer to the system\n@@ -685,8 +721,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n     fn pthread_condattr_setclock(\n         &mut self,\n-        attr_op: &OpTy<'tcx, Tag>,\n-        clock_id_op: &OpTy<'tcx, Tag>,\n+        attr_op: &OpTy<'tcx, Provenance>,\n+        clock_id_op: &OpTy<'tcx, Provenance>,\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n@@ -705,8 +741,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n     fn pthread_condattr_getclock(\n         &mut self,\n-        attr_op: &OpTy<'tcx, Tag>,\n-        clk_id_op: &OpTy<'tcx, Tag>,\n+        attr_op: &OpTy<'tcx, Provenance>,\n+        clk_id_op: &OpTy<'tcx, Provenance>,\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n@@ -716,7 +752,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         Ok(0)\n     }\n \n-    fn pthread_condattr_destroy(&mut self, attr_op: &OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n+    fn pthread_condattr_destroy(\n+        &mut self,\n+        attr_op: &OpTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n         // Destroying an uninit pthread_condattr is UB, so check to make sure it's not uninit.\n@@ -730,8 +769,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n     fn pthread_cond_init(\n         &mut self,\n-        cond_op: &OpTy<'tcx, Tag>,\n-        attr_op: &OpTy<'tcx, Tag>,\n+        cond_op: &OpTy<'tcx, Provenance>,\n+        attr_op: &OpTy<'tcx, Provenance>,\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n@@ -750,7 +789,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         Ok(0)\n     }\n \n-    fn pthread_cond_signal(&mut self, cond_op: &OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n+    fn pthread_cond_signal(&mut self, cond_op: &OpTy<'tcx, Provenance>) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n         let id = cond_get_or_create_id(this, cond_op)?;\n         if let Some((thread, mutex)) = this.condvar_signal(id) {\n@@ -760,7 +799,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         Ok(0)\n     }\n \n-    fn pthread_cond_broadcast(&mut self, cond_op: &OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n+    fn pthread_cond_broadcast(\n+        &mut self,\n+        cond_op: &OpTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n         let id = cond_get_or_create_id(this, cond_op)?;\n \n@@ -773,8 +815,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n     fn pthread_cond_wait(\n         &mut self,\n-        cond_op: &OpTy<'tcx, Tag>,\n-        mutex_op: &OpTy<'tcx, Tag>,\n+        cond_op: &OpTy<'tcx, Provenance>,\n+        mutex_op: &OpTy<'tcx, Provenance>,\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n@@ -790,10 +832,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n     fn pthread_cond_timedwait(\n         &mut self,\n-        cond_op: &OpTy<'tcx, Tag>,\n-        mutex_op: &OpTy<'tcx, Tag>,\n-        abstime_op: &OpTy<'tcx, Tag>,\n-        dest: &PlaceTy<'tcx, Tag>,\n+        cond_op: &OpTy<'tcx, Provenance>,\n+        mutex_op: &OpTy<'tcx, Provenance>,\n+        abstime_op: &OpTy<'tcx, Provenance>,\n+        dest: &PlaceTy<'tcx, Provenance>,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n \n@@ -852,7 +894,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         Ok(())\n     }\n \n-    fn pthread_cond_destroy(&mut self, cond_op: &OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n+    fn pthread_cond_destroy(\n+        &mut self,\n+        cond_op: &OpTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n         let id = cond_get_or_create_id(this, cond_op)?;"}, {"sha": "1a8531e880474ea7ce9161c2f61db885e6eeb7bf", "filename": "src/shims/unix/thread.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/167e5dcad39cd12596ace6fce1ef06218e559542/src%2Fshims%2Funix%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/167e5dcad39cd12596ace6fce1ef06218e559542/src%2Fshims%2Funix%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Funix%2Fthread.rs?ref=167e5dcad39cd12596ace6fce1ef06218e559542", "patch": "@@ -6,10 +6,10 @@ impl<'mir, 'tcx> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tc\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n     fn pthread_create(\n         &mut self,\n-        thread: &OpTy<'tcx, Tag>,\n-        _attr: &OpTy<'tcx, Tag>,\n-        start_routine: &OpTy<'tcx, Tag>,\n-        arg: &OpTy<'tcx, Tag>,\n+        thread: &OpTy<'tcx, Provenance>,\n+        _attr: &OpTy<'tcx, Provenance>,\n+        start_routine: &OpTy<'tcx, Provenance>,\n+        arg: &OpTy<'tcx, Provenance>,\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n@@ -59,8 +59,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n     fn pthread_join(\n         &mut self,\n-        thread: &OpTy<'tcx, Tag>,\n-        retval: &OpTy<'tcx, Tag>,\n+        thread: &OpTy<'tcx, Provenance>,\n+        retval: &OpTy<'tcx, Provenance>,\n     ) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n@@ -75,7 +75,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         Ok(0)\n     }\n \n-    fn pthread_detach(&mut self, thread: &OpTy<'tcx, Tag>) -> InterpResult<'tcx, i32> {\n+    fn pthread_detach(&mut self, thread: &OpTy<'tcx, Provenance>) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n \n         let thread_id = this.read_scalar(thread)?.to_machine_usize(this)?;\n@@ -84,14 +84,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         Ok(0)\n     }\n \n-    fn pthread_self(&mut self, dest: &PlaceTy<'tcx, Tag>) -> InterpResult<'tcx> {\n+    fn pthread_self(&mut self, dest: &PlaceTy<'tcx, Provenance>) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n \n         let thread_id = this.get_active_thread();\n         this.write_scalar(Scalar::from_uint(thread_id.to_u32(), dest.layout.size), dest)\n     }\n \n-    fn prctl(&mut self, args: &[OpTy<'tcx, Tag>]) -> InterpResult<'tcx, i32> {\n+    fn prctl(&mut self, args: &[OpTy<'tcx, Provenance>]) -> InterpResult<'tcx, i32> {\n         let this = self.eval_context_mut();\n         this.assert_target_os(\"linux\", \"prctl\");\n \n@@ -138,7 +138,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         Ok(0)\n     }\n \n-    fn pthread_setname_np(&mut self, name: Pointer<Option<Tag>>) -> InterpResult<'tcx> {\n+    fn pthread_setname_np(&mut self, name: Pointer<Option<Provenance>>) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         this.assert_target_os(\"macos\", \"pthread_setname_np\");\n "}, {"sha": "ee4f392277721743a0d517096235be1e4247d311", "filename": "src/shims/windows/dlsym.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/167e5dcad39cd12596ace6fce1ef06218e559542/src%2Fshims%2Fwindows%2Fdlsym.rs", "raw_url": "https://github.com/rust-lang/rust/raw/167e5dcad39cd12596ace6fce1ef06218e559542/src%2Fshims%2Fwindows%2Fdlsym.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fwindows%2Fdlsym.rs?ref=167e5dcad39cd12596ace6fce1ef06218e559542", "patch": "@@ -31,8 +31,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         &mut self,\n         dlsym: Dlsym,\n         abi: Abi,\n-        args: &[OpTy<'tcx, Tag>],\n-        dest: &PlaceTy<'tcx, Tag>,\n+        args: &[OpTy<'tcx, Provenance>],\n+        dest: &PlaceTy<'tcx, Provenance>,\n         ret: Option<mir::BasicBlock>,\n     ) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();"}, {"sha": "3f4b8b14002e78d183317995f47ea049159045b3", "filename": "src/shims/windows/foreign_items.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/167e5dcad39cd12596ace6fce1ef06218e559542/src%2Fshims%2Fwindows%2Fforeign_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/167e5dcad39cd12596ace6fce1ef06218e559542/src%2Fshims%2Fwindows%2Fforeign_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fwindows%2Fforeign_items.rs?ref=167e5dcad39cd12596ace6fce1ef06218e559542", "patch": "@@ -15,8 +15,8 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         &mut self,\n         link_name: Symbol,\n         abi: Abi,\n-        args: &[OpTy<'tcx, Tag>],\n-        dest: &PlaceTy<'tcx, Tag>,\n+        args: &[OpTy<'tcx, Provenance>],\n+        dest: &PlaceTy<'tcx, Provenance>,\n     ) -> InterpResult<'tcx, EmulateByNameResult<'mir, 'tcx>> {\n         let this = self.eval_context_mut();\n "}, {"sha": "878b9b94a639c8cc5ad744fbe0355c9a4b2897c7", "filename": "src/shims/windows/sync.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/167e5dcad39cd12596ace6fce1ef06218e559542/src%2Fshims%2Fwindows%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/167e5dcad39cd12596ace6fce1ef06218e559542/src%2Fshims%2Fwindows%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fwindows%2Fsync.rs?ref=167e5dcad39cd12596ace6fce1ef06218e559542", "patch": "@@ -5,7 +5,7 @@ use crate::*;\n \n fn srwlock_get_or_create_id<'mir, 'tcx: 'mir>(\n     ecx: &mut MiriEvalContext<'mir, 'tcx>,\n-    lock_op: &OpTy<'tcx, Tag>,\n+    lock_op: &OpTy<'tcx, Provenance>,\n ) -> InterpResult<'tcx, RwLockId> {\n     let value_place = ecx.deref_operand_and_offset(lock_op, 0, ecx.machine.layouts.u32)?;\n \n@@ -34,7 +34,7 @@ fn srwlock_get_or_create_id<'mir, 'tcx: 'mir>(\n impl<'mir, 'tcx> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n     #[allow(non_snake_case)]\n-    fn AcquireSRWLockExclusive(&mut self, lock_op: &OpTy<'tcx, Tag>) -> InterpResult<'tcx> {\n+    fn AcquireSRWLockExclusive(&mut self, lock_op: &OpTy<'tcx, Provenance>) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         let id = srwlock_get_or_create_id(this, lock_op)?;\n         let active_thread = this.get_active_thread();\n@@ -56,7 +56,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     }\n \n     #[allow(non_snake_case)]\n-    fn TryAcquireSRWLockExclusive(&mut self, lock_op: &OpTy<'tcx, Tag>) -> InterpResult<'tcx, u8> {\n+    fn TryAcquireSRWLockExclusive(\n+        &mut self,\n+        lock_op: &OpTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx, u8> {\n         let this = self.eval_context_mut();\n         let id = srwlock_get_or_create_id(this, lock_op)?;\n         let active_thread = this.get_active_thread();\n@@ -71,7 +74,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     }\n \n     #[allow(non_snake_case)]\n-    fn ReleaseSRWLockExclusive(&mut self, lock_op: &OpTy<'tcx, Tag>) -> InterpResult<'tcx> {\n+    fn ReleaseSRWLockExclusive(&mut self, lock_op: &OpTy<'tcx, Provenance>) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         let id = srwlock_get_or_create_id(this, lock_op)?;\n         let active_thread = this.get_active_thread();\n@@ -87,7 +90,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     }\n \n     #[allow(non_snake_case)]\n-    fn AcquireSRWLockShared(&mut self, lock_op: &OpTy<'tcx, Tag>) -> InterpResult<'tcx> {\n+    fn AcquireSRWLockShared(&mut self, lock_op: &OpTy<'tcx, Provenance>) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         let id = srwlock_get_or_create_id(this, lock_op)?;\n         let active_thread = this.get_active_thread();\n@@ -102,7 +105,10 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     }\n \n     #[allow(non_snake_case)]\n-    fn TryAcquireSRWLockShared(&mut self, lock_op: &OpTy<'tcx, Tag>) -> InterpResult<'tcx, u8> {\n+    fn TryAcquireSRWLockShared(\n+        &mut self,\n+        lock_op: &OpTy<'tcx, Provenance>,\n+    ) -> InterpResult<'tcx, u8> {\n         let this = self.eval_context_mut();\n         let id = srwlock_get_or_create_id(this, lock_op)?;\n         let active_thread = this.get_active_thread();\n@@ -116,7 +122,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     }\n \n     #[allow(non_snake_case)]\n-    fn ReleaseSRWLockShared(&mut self, lock_op: &OpTy<'tcx, Tag>) -> InterpResult<'tcx> {\n+    fn ReleaseSRWLockShared(&mut self, lock_op: &OpTy<'tcx, Provenance>) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         let id = srwlock_get_or_create_id(this, lock_op)?;\n         let active_thread = this.get_active_thread();"}, {"sha": "6521f0772112db62b2a95142f31f56078fc76872", "filename": "src/stacked_borrows/diagnostics.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/167e5dcad39cd12596ace6fce1ef06218e559542/src%2Fstacked_borrows%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/167e5dcad39cd12596ace6fce1ef06218e559542/src%2Fstacked_borrows%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows%2Fdiagnostics.rs?ref=167e5dcad39cd12596ace6fce1ef06218e559542", "patch": "@@ -5,11 +5,8 @@ use rustc_span::{Span, SpanData};\n use rustc_target::abi::Size;\n \n use crate::helpers::CurrentSpan;\n-use crate::stacked_borrows::{err_sb_ub, AccessKind, Permission};\n-use crate::Item;\n-use crate::SbTag;\n-use crate::SbTagExtra;\n-use crate::Stack;\n+use crate::stacked_borrows::{err_sb_ub, AccessKind};\n+use crate::*;\n \n use rustc_middle::mir::interpret::InterpError;\n \n@@ -132,7 +129,7 @@ impl AllocHistory {\n     /// Report a descriptive error when `new` could not be granted from `derived_from`.\n     pub fn grant_error<'tcx>(\n         &self,\n-        derived_from: SbTagExtra,\n+        derived_from: ProvenanceExtra,\n         new: Item,\n         alloc_id: AllocId,\n         alloc_range: AllocRange,\n@@ -155,7 +152,7 @@ impl AllocHistory {\n     pub fn access_error<'tcx>(\n         &self,\n         access: AccessKind,\n-        tag: SbTagExtra,\n+        tag: ProvenanceExtra,\n         alloc_id: AllocId,\n         alloc_range: AllocRange,\n         error_offset: Size,\n@@ -181,8 +178,8 @@ fn operation_summary(\n     format!(\"this error occurs as part of {operation} at {alloc_id:?}{alloc_range:?}\")\n }\n \n-fn error_cause(stack: &Stack, tag: SbTagExtra) -> &'static str {\n-    if let SbTagExtra::Concrete(tag) = tag {\n+fn error_cause(stack: &Stack, prov_extra: ProvenanceExtra) -> &'static str {\n+    if let ProvenanceExtra::Concrete(tag) = prov_extra {\n         if (0..stack.len())\n             .map(|i| stack.get(i).unwrap())\n             .any(|item| item.tag() == tag && item.perm() != Permission::Disabled)"}, {"sha": "c20927013b0b8a916becce3cefd6747c29b4b0f9", "filename": "src/stacked_borrows/mod.rs", "status": "modified", "additions": 24, "deletions": 50, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/167e5dcad39cd12596ace6fce1ef06218e559542/src%2Fstacked_borrows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/167e5dcad39cd12596ace6fce1ef06218e559542/src%2Fstacked_borrows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows%2Fmod.rs?ref=167e5dcad39cd12596ace6fce1ef06218e559542", "patch": "@@ -55,32 +55,6 @@ impl fmt::Debug for SbTag {\n     }\n }\n \n-/// The \"extra\" information an SB pointer has over a regular AllocId.\n-/// Newtype for `Option<SbTag>`.\n-#[derive(Copy, Clone)]\n-pub enum SbTagExtra {\n-    Concrete(SbTag),\n-    Wildcard,\n-}\n-\n-impl fmt::Debug for SbTagExtra {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match self {\n-            SbTagExtra::Concrete(pid) => write!(f, \"{pid:?}\"),\n-            SbTagExtra::Wildcard => write!(f, \"<wildcard>\"),\n-        }\n-    }\n-}\n-\n-impl SbTagExtra {\n-    fn and_then<T>(self, f: impl FnOnce(SbTag) -> Option<T>) -> Option<T> {\n-        match self {\n-            SbTagExtra::Concrete(pid) => f(pid),\n-            SbTagExtra::Wildcard => None,\n-        }\n-    }\n-}\n-\n #[derive(Debug)]\n pub struct FrameExtra {\n     /// The ID of the call this frame corresponds to.\n@@ -311,7 +285,7 @@ impl<'tcx> Stack {\n     /// currently checking.\n     fn item_popped(\n         item: &Item,\n-        provoking_access: Option<(SbTagExtra, AllocRange, Size, AccessKind)>, // just for debug printing and error messages\n+        provoking_access: Option<(ProvenanceExtra, AllocRange, Size, AccessKind)>, // just for debug printing and error messages\n         global: &GlobalStateInner,\n         alloc_history: &mut AllocHistory,\n         threads: &ThreadManager<'_, 'tcx>,\n@@ -322,7 +296,7 @@ impl<'tcx> Stack {\n             #[inline(never)] // cold path\n             fn check_tracked(\n                 item: &Item,\n-                provoking_access: &Option<(SbTagExtra, AllocRange, Size, AccessKind)>,\n+                provoking_access: &Option<(ProvenanceExtra, AllocRange, Size, AccessKind)>,\n                 global: &GlobalStateInner,\n             ) {\n                 if global.tracked_pointer_tags.contains(&item.tag()) {\n@@ -357,7 +331,7 @@ impl<'tcx> Stack {\n             #[inline(never)] // cold path\n             fn protector_error<'tcx>(\n                 item: &Item,\n-                provoking_access: &Option<(SbTagExtra, AllocRange, Size, AccessKind)>,\n+                provoking_access: &Option<(ProvenanceExtra, AllocRange, Size, AccessKind)>,\n                 alloc_history: &mut AllocHistory,\n                 threads: &ThreadManager<'_, 'tcx>,\n             ) -> InterpErrorInfo<'tcx> {\n@@ -410,7 +384,7 @@ impl<'tcx> Stack {\n     fn access(\n         &mut self,\n         access: AccessKind,\n-        tag: SbTagExtra,\n+        tag: ProvenanceExtra,\n         (alloc_id, alloc_range, offset): (AllocId, AllocRange, Size), // just for debug printing and error messages\n         global: &mut GlobalStateInner,\n         current_span: &mut CurrentSpan<'_, '_, 'tcx>,\n@@ -482,7 +456,7 @@ impl<'tcx> Stack {\n         }\n \n         // If this was an approximate action, we now collapse everything into an unknown.\n-        if granting_idx.is_none() || matches!(tag, SbTagExtra::Wildcard) {\n+        if granting_idx.is_none() || matches!(tag, ProvenanceExtra::Wildcard) {\n             // Compute the upper bound of the items that remain.\n             // (This is why we did all the work above: to reduce the items we have to consider here.)\n             let mut max = NonZeroU64::new(1).unwrap();\n@@ -512,7 +486,7 @@ impl<'tcx> Stack {\n     /// active protectors at all because we will remove all items.\n     fn dealloc(\n         &mut self,\n-        tag: SbTagExtra,\n+        tag: ProvenanceExtra,\n         (alloc_id, _alloc_range, _offset): (AllocId, AllocRange, Size), // just for debug printing and error messages\n         global: &GlobalStateInner,\n         alloc_history: &mut AllocHistory,\n@@ -546,7 +520,7 @@ impl<'tcx> Stack {\n     /// `range` that we are currently checking.\n     fn grant(\n         &mut self,\n-        derived_from: SbTagExtra,\n+        derived_from: ProvenanceExtra,\n         new: Item,\n         (alloc_id, alloc_range, offset): (AllocId, AllocRange, Size), // just for debug printing and error messages\n         global: &mut GlobalStateInner,\n@@ -575,7 +549,7 @@ impl<'tcx> Stack {\n                 \"this case only makes sense for stack-like accesses\"\n             );\n \n-            let (Some(granting_idx), SbTagExtra::Concrete(_)) = (granting_idx, derived_from) else {\n+            let (Some(granting_idx), ProvenanceExtra::Concrete(_)) = (granting_idx, derived_from) else {\n                 // The parent is a wildcard pointer or matched the unknown bottom.\n                 // This is approximate. Nobody knows what happened, so forget everything.\n                 // The new thing is SRW anyway, so we cannot push it \"on top of the unkown part\"\n@@ -686,7 +660,7 @@ impl Stacks {\n     pub fn memory_read<'tcx>(\n         &mut self,\n         alloc_id: AllocId,\n-        tag: SbTagExtra,\n+        tag: ProvenanceExtra,\n         range: AllocRange,\n         state: &GlobalState,\n         mut current_span: CurrentSpan<'_, '_, 'tcx>,\n@@ -717,7 +691,7 @@ impl Stacks {\n     pub fn memory_written<'tcx>(\n         &mut self,\n         alloc_id: AllocId,\n-        tag: SbTagExtra,\n+        tag: ProvenanceExtra,\n         range: AllocRange,\n         state: &GlobalState,\n         mut current_span: CurrentSpan<'_, '_, 'tcx>,\n@@ -748,7 +722,7 @@ impl Stacks {\n     pub fn memory_deallocated<'tcx>(\n         &mut self,\n         alloc_id: AllocId,\n-        tag: SbTagExtra,\n+        tag: ProvenanceExtra,\n         range: AllocRange,\n         state: &GlobalState,\n         threads: &ThreadManager<'_, 'tcx>,\n@@ -770,7 +744,7 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     /// happened.\n     fn reborrow(\n         &mut self,\n-        place: &MPlaceTy<'tcx, Tag>,\n+        place: &MPlaceTy<'tcx, Provenance>,\n         size: Size,\n         kind: RefKind,\n         new_tag: SbTag,\n@@ -782,7 +756,7 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         // It is crucial that this gets called on all code paths, to ensure we track tag creation.\n         let log_creation = |this: &MiriEvalContext<'mir, 'tcx>,\n                             current_span: &mut CurrentSpan<'_, 'mir, 'tcx>,\n-                            loc: Option<(AllocId, Size, SbTagExtra)>| // alloc_id, base_offset, orig_tag\n+                            loc: Option<(AllocId, Size, ProvenanceExtra)>| // alloc_id, base_offset, orig_tag\n          -> InterpResult<'tcx> {\n             let global = this.machine.stacked_borrows.as_ref().unwrap().borrow();\n             if global.tracked_pointer_tags.contains(&new_tag) {\n@@ -798,7 +772,7 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             };\n \n             // The SB history tracking needs a parent tag, so skip if we come from a wildcard.\n-            let SbTagExtra::Concrete(orig_tag) = orig_tag else {\n+            let ProvenanceExtra::Concrete(orig_tag) = orig_tag else {\n                 // FIXME: should we log this?\n                 return Ok(())\n             };\n@@ -972,10 +946,10 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     /// `mutbl` can be `None` to make this a raw pointer.\n     fn retag_reference(\n         &mut self,\n-        val: &ImmTy<'tcx, Tag>,\n+        val: &ImmTy<'tcx, Provenance>,\n         kind: RefKind,\n         protect: bool,\n-    ) -> InterpResult<'tcx, ImmTy<'tcx, Tag>> {\n+    ) -> InterpResult<'tcx, ImmTy<'tcx, Provenance>> {\n         let this = self.eval_context_mut();\n         // We want a place for where the ptr *points to*, so we get one.\n         let place = this.ref_to_mplace(val)?;\n@@ -1001,12 +975,12 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                     Some(alloc_id) => {\n                         // If `reborrow` could figure out the AllocId of this ptr, hard-code it into the new one.\n                         // Even if we started out with a wildcard, this newly retagged pointer is tied to that allocation.\n-                        Tag::Concrete { alloc_id, sb: new_tag }\n+                        Provenance::Concrete { alloc_id, sb: new_tag }\n                     }\n                     None => {\n                         // Looks like this has to stay a wildcard pointer.\n-                        assert!(matches!(prov, Tag::Wildcard));\n-                        Tag::Wildcard\n+                        assert!(matches!(prov, Provenance::Wildcard));\n+                        Provenance::Wildcard\n                     }\n                 }\n             })\n@@ -1019,7 +993,7 @@ trait EvalContextPrivExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n \n impl<'mir, 'tcx: 'mir> EvalContextExt<'mir, 'tcx> for crate::MiriEvalContext<'mir, 'tcx> {}\n pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx> {\n-    fn retag(&mut self, kind: RetagKind, place: &PlaceTy<'tcx, Tag>) -> InterpResult<'tcx> {\n+    fn retag(&mut self, kind: RetagKind, place: &PlaceTy<'tcx, Provenance>) -> InterpResult<'tcx> {\n         let this = self.eval_context_mut();\n         let retag_fields = this.machine.stacked_borrows.as_mut().unwrap().get_mut().retag_fields;\n         let mut visitor = RetagVisitor { ecx: this, kind, retag_fields };\n@@ -1057,7 +1031,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n             #[inline(always)] // yes this helps in our benchmarks\n             fn retag_place(\n                 &mut self,\n-                place: &PlaceTy<'tcx, Tag>,\n+                place: &PlaceTy<'tcx, Provenance>,\n                 ref_kind: RefKind,\n                 protector: bool,\n             ) -> InterpResult<'tcx> {\n@@ -1070,14 +1044,14 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n         impl<'ecx, 'mir, 'tcx> MutValueVisitor<'mir, 'tcx, Evaluator<'mir, 'tcx>>\n             for RetagVisitor<'ecx, 'mir, 'tcx>\n         {\n-            type V = PlaceTy<'tcx, Tag>;\n+            type V = PlaceTy<'tcx, Provenance>;\n \n             #[inline(always)]\n             fn ecx(&mut self) -> &mut MiriEvalContext<'mir, 'tcx> {\n                 self.ecx\n             }\n \n-            fn visit_box(&mut self, place: &PlaceTy<'tcx, Tag>) -> InterpResult<'tcx> {\n+            fn visit_box(&mut self, place: &PlaceTy<'tcx, Provenance>) -> InterpResult<'tcx> {\n                 // Boxes do not get a protector: protectors reflect that references outlive the call\n                 // they were passed in to; that's just not the case for boxes.\n                 self.retag_place(\n@@ -1087,7 +1061,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 )\n             }\n \n-            fn visit_value(&mut self, place: &PlaceTy<'tcx, Tag>) -> InterpResult<'tcx> {\n+            fn visit_value(&mut self, place: &PlaceTy<'tcx, Provenance>) -> InterpResult<'tcx> {\n                 if let Some((ref_kind, protector)) = qualify(place.layout.ty, self.kind) {\n                     self.retag_place(place, ref_kind, protector)?;\n                 } else if matches!(place.layout.ty.kind(), ty::RawPtr(..)) {"}, {"sha": "c0d4d0d291f30d3e3aef84dd9bb530c41e12f78c", "filename": "src/stacked_borrows/stack.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/167e5dcad39cd12596ace6fce1ef06218e559542/src%2Fstacked_borrows%2Fstack.rs", "raw_url": "https://github.com/rust-lang/rust/raw/167e5dcad39cd12596ace6fce1ef06218e559542/src%2Fstacked_borrows%2Fstack.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fstacked_borrows%2Fstack.rs?ref=167e5dcad39cd12596ace6fce1ef06218e559542", "patch": "@@ -1,8 +1,11 @@\n-use crate::stacked_borrows::{AccessKind, Item, Permission, SbTag, SbTagExtra};\n-use rustc_data_structures::fx::FxHashSet;\n #[cfg(feature = \"stack-cache\")]\n use std::ops::Range;\n \n+use rustc_data_structures::fx::FxHashSet;\n+\n+use crate::stacked_borrows::{AccessKind, Item, Permission, SbTag};\n+use crate::ProvenanceExtra;\n+\n /// Exactly what cache size we should use is a difficult tradeoff. There will always be some\n /// workload which has a `SbTag` working set which exceeds the size of the cache, and ends up\n /// falling back to linear searches of the borrow stack very often.\n@@ -126,13 +129,13 @@ impl<'tcx> Stack {\n     pub(super) fn find_granting(\n         &mut self,\n         access: AccessKind,\n-        tag: SbTagExtra,\n+        tag: ProvenanceExtra,\n         exposed_tags: &FxHashSet<SbTag>,\n     ) -> Result<Option<usize>, ()> {\n         #[cfg(debug_assertions)]\n         self.verify_cache_consistency();\n \n-        let SbTagExtra::Concrete(tag) = tag else {\n+        let ProvenanceExtra::Concrete(tag) = tag else {\n             // Handle the wildcard case.\n             // Go search the stack for an exposed tag.\n             if let Some(idx) ="}, {"sha": "5571bbd8f2dc577da6257c1e069a617212170edb", "filename": "src/sync.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/167e5dcad39cd12596ace6fce1ef06218e559542/src%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/167e5dcad39cd12596ace6fce1ef06218e559542/src%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fsync.rs?ref=167e5dcad39cd12596ace6fce1ef06218e559542", "patch": "@@ -42,7 +42,7 @@ macro_rules! declare_id {\n         }\n \n         impl $name {\n-            pub fn to_u32_scalar<'tcx>(&self) -> Scalar<Tag> {\n+            pub fn to_u32_scalar<'tcx>(&self) -> Scalar<Provenance> {\n                 Scalar::from_u32(self.0.get())\n             }\n         }"}, {"sha": "683694f482eaab896b441574de2674d727842271", "filename": "src/thread.rs", "status": "modified", "additions": 20, "deletions": 14, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/167e5dcad39cd12596ace6fce1ef06218e559542/src%2Fthread.rs", "raw_url": "https://github.com/rust-lang/rust/raw/167e5dcad39cd12596ace6fce1ef06218e559542/src%2Fthread.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fthread.rs?ref=167e5dcad39cd12596ace6fce1ef06218e559542", "patch": "@@ -70,7 +70,7 @@ impl From<u32> for ThreadId {\n }\n \n impl ThreadId {\n-    pub fn to_u32_scalar(&self) -> Scalar<Tag> {\n+    pub fn to_u32_scalar(&self) -> Scalar<Provenance> {\n         Scalar::from_u32(self.0)\n     }\n }\n@@ -112,18 +112,18 @@ pub struct Thread<'mir, 'tcx> {\n     thread_name: Option<Vec<u8>>,\n \n     /// The virtual call stack.\n-    stack: Vec<Frame<'mir, 'tcx, Tag, FrameData<'tcx>>>,\n+    stack: Vec<Frame<'mir, 'tcx, Provenance, FrameData<'tcx>>>,\n \n     /// The join status.\n     join_status: ThreadJoinStatus,\n \n     /// The temporary used for storing the argument of\n     /// the call to `miri_start_panic` (the panic payload) when unwinding.\n     /// This is pointer-sized, and matches the `Payload` type in `src/libpanic_unwind/miri.rs`.\n-    pub(crate) panic_payload: Option<Scalar<Tag>>,\n+    pub(crate) panic_payload: Option<Scalar<Provenance>>,\n \n     /// Last OS error location in memory. It is a 32-bit integer.\n-    pub(crate) last_error: Option<MPlaceTy<'tcx, Tag>>,\n+    pub(crate) last_error: Option<MPlaceTy<'tcx, Provenance>>,\n }\n \n impl<'mir, 'tcx> Thread<'mir, 'tcx> {\n@@ -227,7 +227,7 @@ pub struct ThreadManager<'mir, 'tcx> {\n     pub(crate) sync: SynchronizationState,\n     /// A mapping from a thread-local static to an allocation id of a thread\n     /// specific allocation.\n-    thread_local_alloc_ids: RefCell<FxHashMap<(DefId, ThreadId), Pointer<Tag>>>,\n+    thread_local_alloc_ids: RefCell<FxHashMap<(DefId, ThreadId), Pointer<Provenance>>>,\n     /// A flag that indicates that we should change the active thread.\n     yield_active_thread: bool,\n     /// Callbacks that are called once the specified time passes.\n@@ -256,32 +256,36 @@ impl<'mir, 'tcx> Default for ThreadManager<'mir, 'tcx> {\n impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n     /// Check if we have an allocation for the given thread local static for the\n     /// active thread.\n-    fn get_thread_local_alloc_id(&self, def_id: DefId) -> Option<Pointer<Tag>> {\n+    fn get_thread_local_alloc_id(&self, def_id: DefId) -> Option<Pointer<Provenance>> {\n         self.thread_local_alloc_ids.borrow().get(&(def_id, self.active_thread)).cloned()\n     }\n \n     /// Set the pointer for the allocation of the given thread local\n     /// static for the active thread.\n     ///\n     /// Panics if a thread local is initialized twice for the same thread.\n-    fn set_thread_local_alloc(&self, def_id: DefId, ptr: Pointer<Tag>) {\n+    fn set_thread_local_alloc(&self, def_id: DefId, ptr: Pointer<Provenance>) {\n         self.thread_local_alloc_ids\n             .borrow_mut()\n             .try_insert((def_id, self.active_thread), ptr)\n             .unwrap();\n     }\n \n     /// Borrow the stack of the active thread.\n-    pub fn active_thread_stack(&self) -> &[Frame<'mir, 'tcx, Tag, FrameData<'tcx>>] {\n+    pub fn active_thread_stack(&self) -> &[Frame<'mir, 'tcx, Provenance, FrameData<'tcx>>] {\n         &self.threads[self.active_thread].stack\n     }\n \n     /// Mutably borrow the stack of the active thread.\n-    fn active_thread_stack_mut(&mut self) -> &mut Vec<Frame<'mir, 'tcx, Tag, FrameData<'tcx>>> {\n+    fn active_thread_stack_mut(\n+        &mut self,\n+    ) -> &mut Vec<Frame<'mir, 'tcx, Provenance, FrameData<'tcx>>> {\n         &mut self.threads[self.active_thread].stack\n     }\n \n-    pub fn all_stacks(&self) -> impl Iterator<Item = &[Frame<'mir, 'tcx, Tag, FrameData<'tcx>>]> {\n+    pub fn all_stacks(\n+        &self,\n+    ) -> impl Iterator<Item = &[Frame<'mir, 'tcx, Provenance, FrameData<'tcx>>]> {\n         self.threads.iter().map(|t| &t.stack[..])\n     }\n \n@@ -468,7 +472,7 @@ impl<'mir, 'tcx: 'mir> ThreadManager<'mir, 'tcx> {\n     fn thread_terminated(\n         &mut self,\n         mut data_race: Option<&mut data_race::GlobalState>,\n-    ) -> Vec<Pointer<Tag>> {\n+    ) -> Vec<Pointer<Provenance>> {\n         let mut free_tls_statics = Vec::new();\n         {\n             let mut thread_local_statics = self.thread_local_alloc_ids.borrow_mut();\n@@ -589,7 +593,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     fn get_or_create_thread_local_alloc(\n         &mut self,\n         def_id: DefId,\n-    ) -> InterpResult<'tcx, Pointer<Tag>> {\n+    ) -> InterpResult<'tcx, Pointer<Provenance>> {\n         let this = self.eval_context_mut();\n         let tcx = this.tcx;\n         if let Some(old_alloc) = this.machine.threads.get_thread_local_alloc_id(def_id) {\n@@ -686,13 +690,15 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n     }\n \n     #[inline]\n-    fn active_thread_stack(&self) -> &[Frame<'mir, 'tcx, Tag, FrameData<'tcx>>] {\n+    fn active_thread_stack(&self) -> &[Frame<'mir, 'tcx, Provenance, FrameData<'tcx>>] {\n         let this = self.eval_context_ref();\n         this.machine.threads.active_thread_stack()\n     }\n \n     #[inline]\n-    fn active_thread_stack_mut(&mut self) -> &mut Vec<Frame<'mir, 'tcx, Tag, FrameData<'tcx>>> {\n+    fn active_thread_stack_mut(\n+        &mut self,\n+    ) -> &mut Vec<Frame<'mir, 'tcx, Provenance, FrameData<'tcx>>> {\n         let this = self.eval_context_mut();\n         this.machine.threads.active_thread_stack_mut()\n     }"}]}