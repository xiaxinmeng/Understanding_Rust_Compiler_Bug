{"sha": "0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBlOWU0MDgzMTAwYWEzZWJmMDliOGYxYWNlMDM0OGNiMzc0NzVlYjk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-29T23:43:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-29T23:43:20Z"}, "message": "Auto merge of #72756 - RalfJung:rollup-tbjmtx2, r=RalfJung\n\nRollup of 9 pull requests\n\nSuccessful merges:\n\n - #67460 (Tweak impl signature mismatch errors involving `RegionKind::ReVar` lifetimes)\n - #71095 (impl From<[T; N]> for Box<[T]>)\n - #71500 (Make pointer offset methods/intrinsics const)\n - #71804 (linker: Support `-static-pie` and `-static -shared`)\n - #71862 (Implement RFC 2585: unsafe blocks in unsafe fn)\n - #72103 (borrowck `DefId` -> `LocalDefId`)\n - #72407 (Various minor improvements to Ipv6Addr::Display)\n - #72413 (impl Step for char (make Range*<char> iterable))\n - #72439 (NVPTX support for new asm!)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "1bb8b3fa49e034b12057f85edfa1e7ac0f5dda74", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1bb8b3fa49e034b12057f85edfa1e7ac0f5dda74"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "html_url": "https://github.com/rust-lang/rust/commit/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4bd32c98047a809ba5fd1fac2aa044638e5f2105", "url": "https://api.github.com/repos/rust-lang/rust/commits/4bd32c98047a809ba5fd1fac2aa044638e5f2105", "html_url": "https://github.com/rust-lang/rust/commit/4bd32c98047a809ba5fd1fac2aa044638e5f2105"}, {"sha": "37894559abd67dd9544f2d66b0e117573e38119c", "url": "https://api.github.com/repos/rust-lang/rust/commits/37894559abd67dd9544f2d66b0e117573e38119c", "html_url": "https://github.com/rust-lang/rust/commit/37894559abd67dd9544f2d66b0e117573e38119c"}], "stats": {"total": 2367, "additions": 1894, "deletions": 473}, "files": [{"sha": "ea560a6d70915a1d51d7bf1cd7e75c29084cceb3", "filename": "src/doc/unstable-book/src/library-features/asm.md", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fasm.md", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fasm.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fasm.md?ref=0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "patch": "@@ -468,12 +468,17 @@ Here is the list of currently supported register classes:\n | ARM | `qreg` | `q[0-15]` | `w` |\n | ARM | `qreg_low8` | `q[0-7]` | `t` |\n | ARM | `qreg_low4` | `q[0-3]` | `x` |\n+| NVPTX | `reg16` | None\\* | `h` |\n+| NVPTX | `reg32` | None\\* | `r` |\n+| NVPTX | `reg64` | None\\* | `l` |\n | RISC-V | `reg` | `x1`, `x[5-7]`, `x[9-15]`, `x[16-31]` (non-RV32E) | `r` |\n | RISC-V | `freg` | `f[0-31]` | `f` |\n \n > **Note**: On x86 we treat `reg_byte` differently from `reg` because the compiler can allocate `al` and `ah` separately whereas `reg` reserves the whole register.\n >\n > Note #2: On x86-64 the high byte registers (e.g. `ah`) are only available when used as an explicit register. Specifying the `reg_byte` register class for an operand will always allocate a low byte register.\n+>\n+> Note #3: NVPTX doesn't have a fixed register set, so named registers are not supported.\n \n Additional register classes may be added in the future based on demand (e.g. MMX, x87, etc).\n \n@@ -495,6 +500,9 @@ Each register class has constraints on which value types they can be used with.\n | ARM | `sreg` | `vfp2` | `i32`, `f32` |\n | ARM | `dreg` | `vfp2` | `i64`, `f64`, `i8x8`, `i16x4`, `i32x2`, `i64x1`, `f32x2` |\n | ARM | `qreg` | `neon` | `i8x16`, `i16x8`, `i32x4`, `i64x2`, `f32x4` |\n+| NVPTX | `reg16` | None | `i8`, `i16` |\n+| NVPTX | `reg32` | None | `i8`, `i16`, `i32`, `f32` |\n+| NVPTX | `reg64` | None | `i8`, `i16`, `i32`, `f32`, `i64`, `f64` |\n | RISC-V32 | `reg` | None | `i8`, `i16`, `i32`, `f32` |\n | RISC-V64 | `reg` | None | `i8`, `i16`, `i32`, `f32`, `i64`, `f64` |\n | RISC-V | `freg` | `f` | `f32` |\n@@ -610,6 +618,9 @@ The supported modifiers are a subset of LLVM's (and GCC's) [asm template argumen\n | ARM | `dreg` | None | `d0` | `P` |\n | ARM | `qreg` | None | `q0` | `q` |\n | ARM | `qreg` | `e` / `f` | `d0` / `d1` | `e` / `f` |\n+| NVPTX | `reg16` | None | `rs0` | None |\n+| NVPTX | `reg32` | None | `r0` | None |\n+| NVPTX | `reg64` | None | `rd0` | None |\n | RISC-V | `reg` | None | `x1` | None |\n | RISC-V | `freg` | None | `f0` | None |\n "}, {"sha": "8cc6f04c0653a401dbb5efdb70b3c745f4403ee1", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "patch": "@@ -865,6 +865,25 @@ impl From<Box<str>> for Box<[u8]> {\n     }\n }\n \n+#[stable(feature = \"box_from_array\", since = \"1.45.0\")]\n+impl<T, const N: usize> From<[T; N]> for Box<[T]>\n+where\n+    [T; N]: LengthAtMost32,\n+{\n+    /// Converts a `[T; N]` into a `Box<[T]>`\n+    ///\n+    /// This conversion moves the array to newly heap-allocated memory.\n+    ///\n+    /// # Examples\n+    /// ```rust\n+    /// let boxed: Box<[u8]> = Box::from([4, 2]);\n+    /// println!(\"{:?}\", boxed);\n+    /// ```\n+    fn from(array: [T; N]) -> Box<[T]> {\n+        box array\n+    }\n+}\n+\n #[stable(feature = \"boxed_slice_try_from\", since = \"1.43.0\")]\n impl<T, const N: usize> TryFrom<Box<[T]>> for Box<[T; N]>\n where"}, {"sha": "2d97fecf8a76673130965c2c52dae989bb0b1ff9", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "patch": "@@ -1314,6 +1314,7 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is\n     /// [`std::pointer::offset`](../../std/primitive.pointer.html#method.offset).\n     #[must_use = \"returns a new pointer rather than modifying its argument\"]\n+    #[rustc_const_unstable(feature = \"const_ptr_offset\", issue = \"71499\")]\n     pub fn offset<T>(dst: *const T, offset: isize) -> *const T;\n \n     /// Calculates the offset from a pointer, potentially wrapping.\n@@ -1331,6 +1332,7 @@ extern \"rust-intrinsic\" {\n     /// The stabilized version of this intrinsic is\n     /// [`std::pointer::wrapping_offset`](../../std/primitive.pointer.html#method.wrapping_offset).\n     #[must_use = \"returns a new pointer rather than modifying its argument\"]\n+    #[rustc_const_unstable(feature = \"const_ptr_offset\", issue = \"71499\")]\n     pub fn arith_offset<T>(dst: *const T, offset: isize) -> *const T;\n \n     /// Equivalent to the appropriate `llvm.memcpy.p0i8.0i8.*` intrinsic, with"}, {"sha": "57e3e8084dd9f3c03b89729c459550cd8e86e390", "filename": "src/libcore/iter/range.rs", "status": "modified", "additions": 73, "deletions": 1, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Flibcore%2Fiter%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Flibcore%2Fiter%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Frange.rs?ref=0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "patch": "@@ -1,3 +1,4 @@\n+use crate::char;\n use crate::convert::TryFrom;\n use crate::mem;\n use crate::ops::{self, Add, Sub, Try};\n@@ -400,6 +401,73 @@ step_integer_impls! {\n     wider than usize: [u32 i32], [u64 i64], [u128 i128];\n }\n \n+#[unstable(feature = \"step_trait\", reason = \"recently redesigned\", issue = \"42168\")]\n+unsafe impl Step for char {\n+    #[inline]\n+    fn steps_between(&start: &char, &end: &char) -> Option<usize> {\n+        let start = start as u32;\n+        let end = end as u32;\n+        if start <= end {\n+            let count = end - start;\n+            if start < 0xD800 && 0xE000 <= end {\n+                usize::try_from(count - 0x800).ok()\n+            } else {\n+                usize::try_from(count).ok()\n+            }\n+        } else {\n+            None\n+        }\n+    }\n+\n+    #[inline]\n+    fn forward_checked(start: char, count: usize) -> Option<char> {\n+        let start = start as u32;\n+        let mut res = Step::forward_checked(start, count)?;\n+        if start < 0xD800 && 0xD800 <= res {\n+            res = Step::forward_checked(res, 0x800)?;\n+        }\n+        if res <= char::MAX as u32 {\n+            // SAFETY: res is a valid unicode scalar\n+            // (below 0x110000 and not in 0xD800..0xE000)\n+            Some(unsafe { char::from_u32_unchecked(res) })\n+        } else {\n+            None\n+        }\n+    }\n+\n+    #[inline]\n+    fn backward_checked(start: char, count: usize) -> Option<char> {\n+        let start = start as u32;\n+        let mut res = Step::backward_checked(start, count)?;\n+        if start >= 0xE000 && 0xE000 > res {\n+            res = Step::backward_checked(res, 0x800)?;\n+        }\n+        // SAFETY: res is a valid unicode scalar\n+        // (below 0x110000 and not in 0xD800..0xE000)\n+        Some(unsafe { char::from_u32_unchecked(res) })\n+    }\n+\n+    #[inline]\n+    unsafe fn forward_unchecked(start: char, count: usize) -> char {\n+        let start = start as u32;\n+        let mut res = Step::forward_unchecked(start, count);\n+        if start < 0xD800 && 0xD800 <= res {\n+            res = Step::forward_unchecked(res, 0x800);\n+        }\n+        char::from_u32_unchecked(res)\n+    }\n+\n+    #[inline]\n+    unsafe fn backward_unchecked(start: char, count: usize) -> char {\n+        let start = start as u32;\n+        let mut res = Step::backward_unchecked(start, count);\n+        if start >= 0xE000 && 0xE000 > res {\n+            res = Step::backward_unchecked(res, 0x800);\n+        }\n+        char::from_u32_unchecked(res)\n+    }\n+}\n+\n macro_rules! range_exact_iter_impl {\n     ($($t:ty)*) => ($(\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -582,7 +650,11 @@ impl<A: Step> Iterator for ops::RangeInclusive<A> {\n         }\n         let is_iterating = self.start < self.end;\n         Some(if is_iterating {\n-            let n = Step::forward(self.start.clone(), 1);\n+            // SAFETY: just checked precondition\n+            // We use the unchecked version here, because\n+            // otherwise `for _ in '\\0'..=char::MAX`\n+            // does not successfully remove panicking code.\n+            let n = unsafe { Step::forward_unchecked(self.start.clone(), 1) };\n             mem::replace(&mut self.start, n)\n         } else {\n             self.exhausted = true;"}, {"sha": "7d21f9a9a66d0479038e91284f0d03fc638e103b", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "patch": "@@ -85,6 +85,7 @@\n #![feature(const_panic)]\n #![feature(const_fn_union)]\n #![feature(const_generics)]\n+#![feature(const_ptr_offset)]\n #![feature(const_ptr_offset_from)]\n #![feature(const_result)]\n #![feature(const_slice_from_raw_parts)]"}, {"sha": "835183d171a794877d1167a2a238c1173f6f6e7a", "filename": "src/libcore/ptr/const_ptr.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Flibcore%2Fptr%2Fconst_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Flibcore%2Fptr%2Fconst_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fconst_ptr.rs?ref=0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "patch": "@@ -151,8 +151,9 @@ impl<T: ?Sized> *const T {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[must_use = \"returns a new pointer rather than modifying its argument\"]\n+    #[rustc_const_unstable(feature = \"const_ptr_offset\", issue = \"71499\")]\n     #[inline]\n-    pub unsafe fn offset(self, count: isize) -> *const T\n+    pub const unsafe fn offset(self, count: isize) -> *const T\n     where\n         T: Sized,\n     {\n@@ -210,8 +211,9 @@ impl<T: ?Sized> *const T {\n     /// ```\n     #[stable(feature = \"ptr_wrapping_offset\", since = \"1.16.0\")]\n     #[must_use = \"returns a new pointer rather than modifying its argument\"]\n+    #[rustc_const_unstable(feature = \"const_ptr_offset\", issue = \"71499\")]\n     #[inline]\n-    pub fn wrapping_offset(self, count: isize) -> *const T\n+    pub const fn wrapping_offset(self, count: isize) -> *const T\n     where\n         T: Sized,\n     {\n@@ -393,8 +395,9 @@ impl<T: ?Sized> *const T {\n     /// ```\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[must_use = \"returns a new pointer rather than modifying its argument\"]\n+    #[rustc_const_unstable(feature = \"const_ptr_offset\", issue = \"71499\")]\n     #[inline]\n-    pub unsafe fn add(self, count: usize) -> Self\n+    pub const unsafe fn add(self, count: usize) -> Self\n     where\n         T: Sized,\n     {\n@@ -455,8 +458,9 @@ impl<T: ?Sized> *const T {\n     /// ```\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[must_use = \"returns a new pointer rather than modifying its argument\"]\n+    #[rustc_const_unstable(feature = \"const_ptr_offset\", issue = \"71499\")]\n     #[inline]\n-    pub unsafe fn sub(self, count: usize) -> Self\n+    pub const unsafe fn sub(self, count: usize) -> Self\n     where\n         T: Sized,\n     {\n@@ -511,8 +515,9 @@ impl<T: ?Sized> *const T {\n     /// ```\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[must_use = \"returns a new pointer rather than modifying its argument\"]\n+    #[rustc_const_unstable(feature = \"const_ptr_offset\", issue = \"71499\")]\n     #[inline]\n-    pub fn wrapping_add(self, count: usize) -> Self\n+    pub const fn wrapping_add(self, count: usize) -> Self\n     where\n         T: Sized,\n     {\n@@ -567,8 +572,9 @@ impl<T: ?Sized> *const T {\n     /// ```\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[must_use = \"returns a new pointer rather than modifying its argument\"]\n+    #[rustc_const_unstable(feature = \"const_ptr_offset\", issue = \"71499\")]\n     #[inline]\n-    pub fn wrapping_sub(self, count: usize) -> Self\n+    pub const fn wrapping_sub(self, count: usize) -> Self\n     where\n         T: Sized,\n     {"}, {"sha": "40b5e4e22340e9844ae05862645811a2c110980b", "filename": "src/libcore/ptr/mut_ptr.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Flibcore%2Fptr%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Flibcore%2Fptr%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fmut_ptr.rs?ref=0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "patch": "@@ -145,8 +145,9 @@ impl<T: ?Sized> *mut T {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[must_use = \"returns a new pointer rather than modifying its argument\"]\n+    #[rustc_const_unstable(feature = \"const_ptr_offset\", issue = \"71499\")]\n     #[inline]\n-    pub unsafe fn offset(self, count: isize) -> *mut T\n+    pub const unsafe fn offset(self, count: isize) -> *mut T\n     where\n         T: Sized,\n     {\n@@ -203,8 +204,9 @@ impl<T: ?Sized> *mut T {\n     /// ```\n     #[stable(feature = \"ptr_wrapping_offset\", since = \"1.16.0\")]\n     #[must_use = \"returns a new pointer rather than modifying its argument\"]\n+    #[rustc_const_unstable(feature = \"const_ptr_offset\", issue = \"71499\")]\n     #[inline]\n-    pub fn wrapping_offset(self, count: isize) -> *mut T\n+    pub const fn wrapping_offset(self, count: isize) -> *mut T\n     where\n         T: Sized,\n     {\n@@ -439,8 +441,9 @@ impl<T: ?Sized> *mut T {\n     /// ```\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[must_use = \"returns a new pointer rather than modifying its argument\"]\n+    #[rustc_const_unstable(feature = \"const_ptr_offset\", issue = \"71499\")]\n     #[inline]\n-    pub unsafe fn add(self, count: usize) -> Self\n+    pub const unsafe fn add(self, count: usize) -> Self\n     where\n         T: Sized,\n     {\n@@ -501,8 +504,9 @@ impl<T: ?Sized> *mut T {\n     /// ```\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[must_use = \"returns a new pointer rather than modifying its argument\"]\n+    #[rustc_const_unstable(feature = \"const_ptr_offset\", issue = \"71499\")]\n     #[inline]\n-    pub unsafe fn sub(self, count: usize) -> Self\n+    pub const unsafe fn sub(self, count: usize) -> Self\n     where\n         T: Sized,\n     {\n@@ -557,8 +561,9 @@ impl<T: ?Sized> *mut T {\n     /// ```\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[must_use = \"returns a new pointer rather than modifying its argument\"]\n+    #[rustc_const_unstable(feature = \"const_ptr_offset\", issue = \"71499\")]\n     #[inline]\n-    pub fn wrapping_add(self, count: usize) -> Self\n+    pub const fn wrapping_add(self, count: usize) -> Self\n     where\n         T: Sized,\n     {\n@@ -613,8 +618,9 @@ impl<T: ?Sized> *mut T {\n     /// ```\n     #[stable(feature = \"pointer_methods\", since = \"1.26.0\")]\n     #[must_use = \"returns a new pointer rather than modifying its argument\"]\n+    #[rustc_const_unstable(feature = \"const_ptr_offset\", issue = \"71499\")]\n     #[inline]\n-    pub fn wrapping_sub(self, count: usize) -> Self\n+    pub const fn wrapping_sub(self, count: usize) -> Self\n     where\n         T: Sized,\n     {"}, {"sha": "ab4f4aa7c73c8b19918ca8481b272beecdd4d2ff", "filename": "src/libcore/tests/iter.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Flibcore%2Ftests%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Flibcore%2Ftests%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fiter.rs?ref=0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "patch": "@@ -1956,6 +1956,18 @@ fn test_range() {\n     );\n }\n \n+#[test]\n+fn test_char_range() {\n+    use std::char;\n+    assert!(('\\0'..=char::MAX).eq((0..=char::MAX as u32).filter_map(char::from_u32)));\n+    assert!(('\\0'..=char::MAX).rev().eq((0..=char::MAX as u32).filter_map(char::from_u32).rev()));\n+\n+    assert_eq!(('\\u{D7FF}'..='\\u{E000}').count(), 2);\n+    assert_eq!(('\\u{D7FF}'..='\\u{E000}').size_hint(), (2, Some(2)));\n+    assert_eq!(('\\u{D7FF}'..'\\u{E000}').count(), 1);\n+    assert_eq!(('\\u{D7FF}'..'\\u{E000}').size_hint(), (1, Some(1)));\n+}\n+\n #[test]\n fn test_range_exhaustion() {\n     let mut r = 10..10;"}, {"sha": "f3b46dd322a39988e31a6d4ab77d80055febc5f5", "filename": "src/librustc_codegen_llvm/asm.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Flibrustc_codegen_llvm%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Flibrustc_codegen_llvm%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fasm.rs?ref=0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "patch": "@@ -254,6 +254,7 @@ impl AsmBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n                     ]);\n                 }\n                 InlineAsmArch::RiscV32 | InlineAsmArch::RiscV64 => {}\n+                InlineAsmArch::Nvptx64 => {}\n             }\n         }\n         if !options.contains(InlineAsmOptions::NOMEM) {\n@@ -410,6 +411,9 @@ fn reg_to_llvm(reg: InlineAsmRegOrRegClass) -> String {\n             | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::qreg_low4) => \"x\",\n             InlineAsmRegClass::Arm(ArmInlineAsmRegClass::dreg)\n             | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::qreg) => \"w\",\n+            InlineAsmRegClass::Nvptx(NvptxInlineAsmRegClass::reg16) => \"h\",\n+            InlineAsmRegClass::Nvptx(NvptxInlineAsmRegClass::reg32) => \"r\",\n+            InlineAsmRegClass::Nvptx(NvptxInlineAsmRegClass::reg64) => \"l\",\n             InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::reg) => \"r\",\n             InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::freg) => \"f\",\n             InlineAsmRegClass::X86(X86InlineAsmRegClass::reg) => \"r\",\n@@ -452,6 +456,7 @@ fn modifier_to_llvm(\n                 modifier\n             }\n         }\n+        InlineAsmRegClass::Nvptx(_) => None,\n         InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::reg)\n         | InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::freg) => None,\n         InlineAsmRegClass::X86(X86InlineAsmRegClass::reg)\n@@ -502,6 +507,9 @@ fn dummy_output_type(cx: &CodegenCx<'ll, 'tcx>, reg: InlineAsmRegClass) -> &'ll\n         | InlineAsmRegClass::Arm(ArmInlineAsmRegClass::qreg_low4) => {\n             cx.type_vector(cx.type_i64(), 2)\n         }\n+        InlineAsmRegClass::Nvptx(NvptxInlineAsmRegClass::reg16) => cx.type_i16(),\n+        InlineAsmRegClass::Nvptx(NvptxInlineAsmRegClass::reg32) => cx.type_i32(),\n+        InlineAsmRegClass::Nvptx(NvptxInlineAsmRegClass::reg64) => cx.type_i64(),\n         InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::reg) => cx.type_i32(),\n         InlineAsmRegClass::RiscV(RiscVInlineAsmRegClass::freg) => cx.type_f32(),\n         InlineAsmRegClass::X86(X86InlineAsmRegClass::reg)"}, {"sha": "dcce1d45298cc5012855b380739d86e07961402a", "filename": "src/librustc_codegen_ssa/back/link.rs", "status": "modified", "additions": 5, "deletions": 24, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flink.rs?ref=0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "patch": "@@ -1194,9 +1194,10 @@ fn link_output_kind(sess: &Session, crate_type: CrateType) -> LinkOutputKind {\n     };\n \n     // Adjust the output kind to target capabilities.\n-    let pic_exe_supported = sess.target.target.options.position_independent_executables;\n-    let static_pic_exe_supported = false; // FIXME: Add this option to target specs.\n-    let static_dylib_supported = sess.target.target.options.crt_static_allows_dylibs;\n+    let opts = &sess.target.target.options;\n+    let pic_exe_supported = opts.position_independent_executables;\n+    let static_pic_exe_supported = opts.static_position_independent_executables;\n+    let static_dylib_supported = opts.crt_static_allows_dylibs;\n     match kind {\n         LinkOutputKind::DynamicPicExe if !pic_exe_supported => LinkOutputKind::DynamicNoPicExe,\n         LinkOutputKind::StaticPicExe if !static_pic_exe_supported => LinkOutputKind::StaticNoPicExe,\n@@ -1580,16 +1581,7 @@ fn linker_with_args<'a, B: ArchiveBuilder<'a>>(\n     }\n \n     // NO-OPT-OUT, OBJECT-FILES-NO, AUDIT-ORDER\n-    // FIXME: Support `StaticPicExe` correctly.\n-    match link_output_kind {\n-        LinkOutputKind::DynamicPicExe | LinkOutputKind::StaticPicExe => {\n-            cmd.position_independent_executable()\n-        }\n-        LinkOutputKind::DynamicNoPicExe | LinkOutputKind::StaticNoPicExe => {\n-            cmd.no_position_independent_executable()\n-        }\n-        _ => {}\n-    }\n+    cmd.set_output_kind(link_output_kind, out_filename);\n \n     // OBJECT-FILES-NO, AUDIT-ORDER\n     add_relro_args(cmd, sess);\n@@ -1618,17 +1610,6 @@ fn linker_with_args<'a, B: ArchiveBuilder<'a>>(\n         tmpdir,\n     );\n \n-    // NO-OPT-OUT, OBJECT-FILES-NO, AUDIT-ORDER\n-    // FIXME: Merge with the previous `link_output_kind` match,\n-    // and support `StaticPicExe` and `StaticDylib` correctly.\n-    match link_output_kind {\n-        LinkOutputKind::StaticNoPicExe | LinkOutputKind::StaticPicExe => {\n-            cmd.build_static_executable()\n-        }\n-        LinkOutputKind::DynamicDylib | LinkOutputKind::StaticDylib => cmd.build_dylib(out_filename),\n-        _ => {}\n-    }\n-\n     // OBJECT-FILES-NO, AUDIT-ORDER\n     if sess.opts.cg.profile_generate.enabled() {\n         cmd.pgo_gen();"}, {"sha": "46c365efdb5fab9470d67ae2537b0512d39ce615", "filename": "src/librustc_codegen_ssa/back/linker.rs", "status": "modified", "additions": 117, "deletions": 110, "changes": 227, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fback%2Flinker.rs?ref=0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "patch": "@@ -17,7 +17,7 @@ use rustc_serialize::{json, Encoder};\n use rustc_session::config::{self, CrateType, DebugInfo, LinkerPluginLto, Lto, OptLevel, Strip};\n use rustc_session::Session;\n use rustc_span::symbol::Symbol;\n-use rustc_target::spec::{LinkerFlavor, LldFlavor};\n+use rustc_target::spec::{LinkOutputKind, LinkerFlavor, LldFlavor};\n \n /// Disables non-English messages from localized linkers.\n /// Such messages may cause issues with text encoding on Windows (#35785)\n@@ -101,6 +101,7 @@ impl LinkerInfo {\n /// MSVC linker (e.g., `link.exe`) is being used.\n pub trait Linker {\n     fn cmd(&mut self) -> &mut Command;\n+    fn set_output_kind(&mut self, output_kind: LinkOutputKind, out_filename: &Path);\n     fn link_dylib(&mut self, lib: Symbol);\n     fn link_rust_dylib(&mut self, lib: Symbol, path: &Path);\n     fn link_framework(&mut self, framework: Symbol);\n@@ -113,8 +114,6 @@ pub trait Linker {\n     fn output_filename(&mut self, path: &Path);\n     fn add_object(&mut self, path: &Path);\n     fn gc_sections(&mut self, keep_metadata: bool);\n-    fn position_independent_executable(&mut self);\n-    fn no_position_independent_executable(&mut self);\n     fn full_relro(&mut self);\n     fn partial_relro(&mut self);\n     fn no_relro(&mut self);\n@@ -124,8 +123,6 @@ pub trait Linker {\n     fn debuginfo(&mut self, strip: Strip);\n     fn no_crt_objects(&mut self);\n     fn no_default_libraries(&mut self);\n-    fn build_dylib(&mut self, out_filename: &Path);\n-    fn build_static_executable(&mut self);\n     fn export_symbols(&mut self, tmpdir: &Path, crate_type: CrateType);\n     fn subsystem(&mut self, subsystem: &str);\n     fn group_start(&mut self);\n@@ -232,12 +229,94 @@ impl<'a> GccLinker<'a> {\n         let target_cpu = self.target_cpu;\n         self.linker_arg(&format!(\"-plugin-opt=mcpu={}\", target_cpu));\n     }\n+\n+    fn build_dylib(&mut self, out_filename: &Path) {\n+        // On mac we need to tell the linker to let this library be rpathed\n+        if self.sess.target.target.options.is_like_osx {\n+            self.cmd.arg(\"-dynamiclib\");\n+            self.linker_arg(\"-dylib\");\n+\n+            // Note that the `osx_rpath_install_name` option here is a hack\n+            // purely to support rustbuild right now, we should get a more\n+            // principled solution at some point to force the compiler to pass\n+            // the right `-Wl,-install_name` with an `@rpath` in it.\n+            if self.sess.opts.cg.rpath || self.sess.opts.debugging_opts.osx_rpath_install_name {\n+                self.linker_arg(\"-install_name\");\n+                let mut v = OsString::from(\"@rpath/\");\n+                v.push(out_filename.file_name().unwrap());\n+                self.linker_arg(&v);\n+            }\n+        } else {\n+            self.cmd.arg(\"-shared\");\n+            if self.sess.target.target.options.is_like_windows {\n+                // The output filename already contains `dll_suffix` so\n+                // the resulting import library will have a name in the\n+                // form of libfoo.dll.a\n+                let implib_name =\n+                    out_filename.file_name().and_then(|file| file.to_str()).map(|file| {\n+                        format!(\n+                            \"{}{}{}\",\n+                            self.sess.target.target.options.staticlib_prefix,\n+                            file,\n+                            self.sess.target.target.options.staticlib_suffix\n+                        )\n+                    });\n+                if let Some(implib_name) = implib_name {\n+                    let implib = out_filename.parent().map(|dir| dir.join(&implib_name));\n+                    if let Some(implib) = implib {\n+                        self.linker_arg(&format!(\"--out-implib,{}\", (*implib).to_str().unwrap()));\n+                    }\n+                }\n+            }\n+        }\n+    }\n }\n \n impl<'a> Linker for GccLinker<'a> {\n     fn cmd(&mut self) -> &mut Command {\n         &mut self.cmd\n     }\n+\n+    fn set_output_kind(&mut self, output_kind: LinkOutputKind, out_filename: &Path) {\n+        match output_kind {\n+            LinkOutputKind::DynamicNoPicExe => {\n+                if !self.is_ld {\n+                    self.cmd.arg(\"-no-pie\");\n+                }\n+            }\n+            LinkOutputKind::DynamicPicExe => {\n+                // `-pie` works for both gcc wrapper and ld.\n+                self.cmd.arg(\"-pie\");\n+            }\n+            LinkOutputKind::StaticNoPicExe => {\n+                // `-static` works for both gcc wrapper and ld.\n+                self.cmd.arg(\"-static\");\n+                if !self.is_ld {\n+                    self.cmd.arg(\"-no-pie\");\n+                }\n+            }\n+            LinkOutputKind::StaticPicExe => {\n+                if !self.is_ld {\n+                    // Note that combination `-static -pie` doesn't work as expected\n+                    // for the gcc wrapper, `-static` in that case suppresses `-pie`.\n+                    self.cmd.arg(\"-static-pie\");\n+                } else {\n+                    // `--no-dynamic-linker` and `-z text` are not strictly necessary for producing\n+                    // a static pie, but currently passed because gcc and clang pass them.\n+                    // The former suppresses the `INTERP` ELF header specifying dynamic linker,\n+                    // which is otherwise implicitly injected by ld (but not lld).\n+                    // The latter doesn't change anything, only ensures that everything is pic.\n+                    self.cmd.args(&[\"-static\", \"-pie\", \"--no-dynamic-linker\", \"-z\", \"text\"]);\n+                }\n+            }\n+            LinkOutputKind::DynamicDylib => self.build_dylib(out_filename),\n+            LinkOutputKind::StaticDylib => {\n+                self.cmd.arg(\"-static\");\n+                self.build_dylib(out_filename);\n+            }\n+        }\n+    }\n+\n     fn link_dylib(&mut self, lib: Symbol) {\n         self.hint_dynamic();\n         self.cmd.arg(format!(\"-l{}\", lib));\n@@ -262,14 +341,6 @@ impl<'a> Linker for GccLinker<'a> {\n     fn add_object(&mut self, path: &Path) {\n         self.cmd.arg(path);\n     }\n-    fn position_independent_executable(&mut self) {\n-        self.cmd.arg(\"-pie\");\n-    }\n-    fn no_position_independent_executable(&mut self) {\n-        if !self.is_ld {\n-            self.cmd.arg(\"-no-pie\");\n-        }\n-    }\n     fn full_relro(&mut self) {\n         self.linker_arg(\"-zrelro\");\n         self.linker_arg(\"-znow\");\n@@ -280,9 +351,6 @@ impl<'a> Linker for GccLinker<'a> {\n     fn no_relro(&mut self) {\n         self.linker_arg(\"-znorelro\");\n     }\n-    fn build_static_executable(&mut self) {\n-        self.cmd.arg(\"-static\");\n-    }\n \n     fn link_rust_dylib(&mut self, lib: Symbol, _path: &Path) {\n         self.hint_dynamic();\n@@ -418,47 +486,6 @@ impl<'a> Linker for GccLinker<'a> {\n         }\n     }\n \n-    fn build_dylib(&mut self, out_filename: &Path) {\n-        // On mac we need to tell the linker to let this library be rpathed\n-        if self.sess.target.target.options.is_like_osx {\n-            self.cmd.arg(\"-dynamiclib\");\n-            self.linker_arg(\"-dylib\");\n-\n-            // Note that the `osx_rpath_install_name` option here is a hack\n-            // purely to support rustbuild right now, we should get a more\n-            // principled solution at some point to force the compiler to pass\n-            // the right `-Wl,-install_name` with an `@rpath` in it.\n-            if self.sess.opts.cg.rpath || self.sess.opts.debugging_opts.osx_rpath_install_name {\n-                self.linker_arg(\"-install_name\");\n-                let mut v = OsString::from(\"@rpath/\");\n-                v.push(out_filename.file_name().unwrap());\n-                self.linker_arg(&v);\n-            }\n-        } else {\n-            self.cmd.arg(\"-shared\");\n-            if self.sess.target.target.options.is_like_windows {\n-                // The output filename already contains `dll_suffix` so\n-                // the resulting import library will have a name in the\n-                // form of libfoo.dll.a\n-                let implib_name =\n-                    out_filename.file_name().and_then(|file| file.to_str()).map(|file| {\n-                        format!(\n-                            \"{}{}{}\",\n-                            self.sess.target.target.options.staticlib_prefix,\n-                            file,\n-                            self.sess.target.target.options.staticlib_suffix\n-                        )\n-                    });\n-                if let Some(implib_name) = implib_name {\n-                    let implib = out_filename.parent().map(|dir| dir.join(&implib_name));\n-                    if let Some(implib) = implib {\n-                        self.linker_arg(&format!(\"--out-implib,{}\", (*implib).to_str().unwrap()));\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n     fn export_symbols(&mut self, tmpdir: &Path, crate_type: CrateType) {\n         // Symbol visibility in object files typically takes care of this.\n         if crate_type == CrateType::Executable\n@@ -582,24 +609,29 @@ impl<'a> Linker for MsvcLinker<'a> {\n     fn cmd(&mut self) -> &mut Command {\n         &mut self.cmd\n     }\n+\n+    fn set_output_kind(&mut self, output_kind: LinkOutputKind, out_filename: &Path) {\n+        match output_kind {\n+            LinkOutputKind::DynamicNoPicExe\n+            | LinkOutputKind::DynamicPicExe\n+            | LinkOutputKind::StaticNoPicExe\n+            | LinkOutputKind::StaticPicExe => {}\n+            LinkOutputKind::DynamicDylib | LinkOutputKind::StaticDylib => {\n+                self.cmd.arg(\"/DLL\");\n+                let mut arg: OsString = \"/IMPLIB:\".into();\n+                arg.push(out_filename.with_extension(\"dll.lib\"));\n+                self.cmd.arg(arg);\n+            }\n+        }\n+    }\n+\n     fn link_rlib(&mut self, lib: &Path) {\n         self.cmd.arg(lib);\n     }\n     fn add_object(&mut self, path: &Path) {\n         self.cmd.arg(path);\n     }\n \n-    fn build_dylib(&mut self, out_filename: &Path) {\n-        self.cmd.arg(\"/DLL\");\n-        let mut arg: OsString = \"/IMPLIB:\".into();\n-        arg.push(out_filename.with_extension(\"dll.lib\"));\n-        self.cmd.arg(arg);\n-    }\n-\n-    fn build_static_executable(&mut self) {\n-        // noop\n-    }\n-\n     fn gc_sections(&mut self, _keep_metadata: bool) {\n         // MSVC's ICF (Identical COMDAT Folding) link optimization is\n         // slow for Rust and thus we disable it by default when not in\n@@ -632,14 +664,6 @@ impl<'a> Linker for MsvcLinker<'a> {\n         self.cmd.arg(&format!(\"{}.lib\", lib));\n     }\n \n-    fn position_independent_executable(&mut self) {\n-        // noop\n-    }\n-\n-    fn no_position_independent_executable(&mut self) {\n-        // noop\n-    }\n-\n     fn full_relro(&mut self) {\n         // noop\n     }\n@@ -817,6 +841,9 @@ impl<'a> Linker for EmLinker<'a> {\n     fn cmd(&mut self) -> &mut Command {\n         &mut self.cmd\n     }\n+\n+    fn set_output_kind(&mut self, _output_kind: LinkOutputKind, _out_filename: &Path) {}\n+\n     fn include_path(&mut self, path: &Path) {\n         self.cmd.arg(\"-L\").arg(path);\n     }\n@@ -856,14 +883,6 @@ impl<'a> Linker for EmLinker<'a> {\n         self.add_object(lib);\n     }\n \n-    fn position_independent_executable(&mut self) {\n-        // noop\n-    }\n-\n-    fn no_position_independent_executable(&mut self) {\n-        // noop\n-    }\n-\n     fn full_relro(&mut self) {\n         // noop\n     }\n@@ -925,14 +944,6 @@ impl<'a> Linker for EmLinker<'a> {\n         self.cmd.args(&[\"-s\", \"DEFAULT_LIBRARY_FUNCS_TO_INCLUDE=[]\"]);\n     }\n \n-    fn build_dylib(&mut self, _out_filename: &Path) {\n-        bug!(\"building dynamic library is unsupported on Emscripten\")\n-    }\n-\n-    fn build_static_executable(&mut self) {\n-        // noop\n-    }\n-\n     fn export_symbols(&mut self, _tmpdir: &Path, crate_type: CrateType) {\n         let symbols = &self.info.exports[&crate_type];\n \n@@ -1031,6 +1042,18 @@ impl<'a> Linker for WasmLd<'a> {\n         &mut self.cmd\n     }\n \n+    fn set_output_kind(&mut self, output_kind: LinkOutputKind, _out_filename: &Path) {\n+        match output_kind {\n+            LinkOutputKind::DynamicNoPicExe\n+            | LinkOutputKind::DynamicPicExe\n+            | LinkOutputKind::StaticNoPicExe\n+            | LinkOutputKind::StaticPicExe => {}\n+            LinkOutputKind::DynamicDylib | LinkOutputKind::StaticDylib => {\n+                self.cmd.arg(\"--no-entry\");\n+            }\n+        }\n+    }\n+\n     fn link_dylib(&mut self, lib: Symbol) {\n         self.cmd.arg(\"-l\").sym_arg(lib);\n     }\n@@ -1059,16 +1082,12 @@ impl<'a> Linker for WasmLd<'a> {\n         self.cmd.arg(path);\n     }\n \n-    fn position_independent_executable(&mut self) {}\n-\n     fn full_relro(&mut self) {}\n \n     fn partial_relro(&mut self) {}\n \n     fn no_relro(&mut self) {}\n \n-    fn build_static_executable(&mut self) {}\n-\n     fn link_rust_dylib(&mut self, lib: Symbol, _path: &Path) {\n         self.cmd.arg(\"-l\").sym_arg(lib);\n     }\n@@ -1124,10 +1143,6 @@ impl<'a> Linker for WasmLd<'a> {\n \n     fn no_default_libraries(&mut self) {}\n \n-    fn build_dylib(&mut self, _out_filename: &Path) {\n-        self.cmd.arg(\"--no-entry\");\n-    }\n-\n     fn export_symbols(&mut self, _tmpdir: &Path, crate_type: CrateType) {\n         for sym in self.info.exports[&crate_type].iter() {\n             self.cmd.arg(\"--export\").arg(&sym);\n@@ -1143,8 +1158,6 @@ impl<'a> Linker for WasmLd<'a> {\n \n     fn subsystem(&mut self, _subsystem: &str) {}\n \n-    fn no_position_independent_executable(&mut self) {}\n-\n     fn finalize(&mut self) {}\n \n     // Not needed for now with LLD\n@@ -1207,6 +1220,8 @@ impl<'a> Linker for PtxLinker<'a> {\n         &mut self.cmd\n     }\n \n+    fn set_output_kind(&mut self, _output_kind: LinkOutputKind, _out_filename: &Path) {}\n+\n     fn link_rlib(&mut self, path: &Path) {\n         self.cmd.arg(\"--rlib\").arg(path);\n     }\n@@ -1273,16 +1288,12 @@ impl<'a> Linker for PtxLinker<'a> {\n         panic!(\"frameworks not supported\")\n     }\n \n-    fn position_independent_executable(&mut self) {}\n-\n     fn full_relro(&mut self) {}\n \n     fn partial_relro(&mut self) {}\n \n     fn no_relro(&mut self) {}\n \n-    fn build_static_executable(&mut self) {}\n-\n     fn gc_sections(&mut self, _keep_metadata: bool) {}\n \n     fn pgo_gen(&mut self) {}\n@@ -1295,14 +1306,10 @@ impl<'a> Linker for PtxLinker<'a> {\n         self.sess.warn(\"Windows Control Flow Guard is not supported by this linker.\");\n     }\n \n-    fn build_dylib(&mut self, _out_filename: &Path) {}\n-\n     fn export_symbols(&mut self, _tmpdir: &Path, _crate_type: CrateType) {}\n \n     fn subsystem(&mut self, _subsystem: &str) {}\n \n-    fn no_position_independent_executable(&mut self) {}\n-\n     fn group_start(&mut self) {}\n \n     fn group_end(&mut self) {}"}, {"sha": "cff83c3d5cda2a7e39e0520b479d8b0f47b93148", "filename": "src/librustc_errors/diagnostic.rs", "status": "modified", "additions": 12, "deletions": 3, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Flibrustc_errors%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Flibrustc_errors%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_errors%2Fdiagnostic.rs?ref=0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "patch": "@@ -193,9 +193,18 @@ impl Diagnostic {\n         expected_extra: &dyn fmt::Display,\n         found_extra: &dyn fmt::Display,\n     ) -> &mut Self {\n-        let expected_label = format!(\"expected {}\", expected_label);\n-\n-        let found_label = format!(\"found {}\", found_label);\n+        let expected_label = expected_label.to_string();\n+        let expected_label = if expected_label.is_empty() {\n+            \"expected\".to_string()\n+        } else {\n+            format!(\"expected {}\", expected_label)\n+        };\n+        let found_label = found_label.to_string();\n+        let found_label = if found_label.is_empty() {\n+            \"found\".to_string()\n+        } else {\n+            format!(\"found {}\", found_label)\n+        };\n         let (found_padding, expected_padding) = if expected_label.len() > found_label.len() {\n             (expected_label.len() - found_label.len(), 0)\n         } else {"}, {"sha": "fd35cb6c3f78557354c2912ff274620eb8dd6d37", "filename": "src/librustc_feature/active.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Flibrustc_feature%2Factive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Flibrustc_feature%2Factive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_feature%2Factive.rs?ref=0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "patch": "@@ -571,6 +571,9 @@ declare_features! (\n     /// Allows the use of `#[ffi_const]` on foreign functions.\n     (active, ffi_const, \"1.45.0\", Some(58328), None),\n \n+    /// No longer treat an unsafe function as an unsafe block.\n+    (active, unsafe_block_in_unsafe_fn, \"1.45.0\", Some(71668), None),\n+\n     // -------------------------------------------------------------------------\n     // feature-group-end: actual feature gates\n     // -------------------------------------------------------------------------"}, {"sha": "ae9019828170f80ebfcc389c34cecb9ada0c2596", "filename": "src/librustc_infer/infer/error_reporting/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fmod.rs?ref=0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "patch": "@@ -987,12 +987,12 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n         }\n \n         fn push_ty_ref<'tcx>(\n-            r: &ty::Region<'tcx>,\n+            region: &ty::Region<'tcx>,\n             ty: Ty<'tcx>,\n             mutbl: hir::Mutability,\n             s: &mut DiagnosticStyledString,\n         ) {\n-            let mut r = r.to_string();\n+            let mut r = region.to_string();\n             if r == \"'_\" {\n                 r.clear();\n             } else {"}, {"sha": "5f14f799fc7aa89868ae29a70191967ce33803ed", "filename": "src/librustc_infer/infer/error_reporting/nice_region_error/trait_impl_difference.rs", "status": "modified", "additions": 99, "deletions": 8, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_infer%2Finfer%2Ferror_reporting%2Fnice_region_error%2Ftrait_impl_difference.rs?ref=0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "patch": "@@ -2,11 +2,16 @@\n \n use crate::infer::error_reporting::nice_region_error::NiceRegionError;\n use crate::infer::lexical_region_resolve::RegionResolutionError;\n-use crate::infer::{Subtype, ValuePairs};\n+use crate::infer::{Subtype, TyCtxtInferExt, ValuePairs};\n use crate::traits::ObligationCauseCode::CompareImplMethodObligation;\n use rustc_errors::ErrorReported;\n-use rustc_middle::ty::Ty;\n-use rustc_span::Span;\n+use rustc_hir as hir;\n+use rustc_hir::def::Res;\n+use rustc_hir::def_id::DefId;\n+use rustc_hir::intravisit::Visitor;\n+use rustc_middle::ty::error::ExpectedFound;\n+use rustc_middle::ty::{self, Ty, TyCtxt};\n+use rustc_span::{MultiSpan, Span};\n \n impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n     /// Print the error message for lifetime errors when the `impl` doesn't conform to the `trait`.\n@@ -36,7 +41,7 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n                                 var_origin.span(),\n                                 sub_expected_found.expected,\n                                 sub_expected_found.found,\n-                                self.tcx().def_span(*trait_item_def_id),\n+                                *trait_item_def_id,\n                             );\n                             return Some(ErrorReported);\n                         }\n@@ -47,14 +52,100 @@ impl<'a, 'tcx> NiceRegionError<'a, 'tcx> {\n         None\n     }\n \n-    fn emit_err(&self, sp: Span, expected: Ty<'tcx>, found: Ty<'tcx>, impl_sp: Span) {\n+    fn emit_err(&self, sp: Span, expected: Ty<'tcx>, found: Ty<'tcx>, trait_def_id: DefId) {\n+        let tcx = self.tcx();\n+        let trait_sp = self.tcx().def_span(trait_def_id);\n         let mut err = self\n             .tcx()\n             .sess\n             .struct_span_err(sp, \"`impl` item signature doesn't match `trait` item signature\");\n-        err.note(&format!(\"expected `{:?}`\\n   found `{:?}`\", expected, found));\n-        err.span_label(sp, &format!(\"found {:?}\", found));\n-        err.span_label(impl_sp, &format!(\"expected {:?}\", expected));\n+        err.span_label(sp, &format!(\"found `{:?}`\", found));\n+        err.span_label(trait_sp, &format!(\"expected `{:?}`\", expected));\n+\n+        // Get the span of all the used type parameters in the method.\n+        let assoc_item = self.tcx().associated_item(trait_def_id);\n+        let mut visitor = TypeParamSpanVisitor { tcx: self.tcx(), types: vec![] };\n+        match assoc_item.kind {\n+            ty::AssocKind::Fn => {\n+                let hir = self.tcx().hir();\n+                if let Some(hir_id) = assoc_item.def_id.as_local().map(|id| hir.as_local_hir_id(id))\n+                {\n+                    if let Some(decl) = hir.fn_decl_by_hir_id(hir_id) {\n+                        visitor.visit_fn_decl(decl);\n+                    }\n+                }\n+            }\n+            _ => {}\n+        }\n+        let mut type_param_span: MultiSpan =\n+            visitor.types.iter().cloned().collect::<Vec<_>>().into();\n+        for &span in &visitor.types {\n+            type_param_span.push_span_label(\n+                span,\n+                \"consider borrowing this type parameter in the trait\".to_string(),\n+            );\n+        }\n+\n+        if let Some((expected, found)) = tcx\n+            .infer_ctxt()\n+            .enter(|infcx| infcx.expected_found_str_ty(&ExpectedFound { expected, found }))\n+        {\n+            // Highlighted the differences when showing the \"expected/found\" note.\n+            err.note_expected_found(&\"\", expected, &\"\", found);\n+        } else {\n+            // This fallback shouldn't be necessary, but let's keep it in just in case.\n+            err.note(&format!(\"expected `{:?}`\\n   found `{:?}`\", expected, found));\n+        }\n+        err.span_help(\n+            type_param_span,\n+            \"the lifetime requirements from the `impl` do not correspond to the requirements in \\\n+             the `trait`\",\n+        );\n+        if visitor.types.is_empty() {\n+            err.help(\n+                \"verify the lifetime relationships in the `trait` and `impl` between the `self` \\\n+                 argument, the other inputs and its output\",\n+            );\n+        }\n         err.emit();\n     }\n }\n+\n+struct TypeParamSpanVisitor<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    types: Vec<Span>,\n+}\n+\n+impl Visitor<'tcx> for TypeParamSpanVisitor<'tcx> {\n+    type Map = rustc_middle::hir::map::Map<'tcx>;\n+\n+    fn nested_visit_map(&mut self) -> hir::intravisit::NestedVisitorMap<Self::Map> {\n+        hir::intravisit::NestedVisitorMap::OnlyBodies(self.tcx.hir())\n+    }\n+\n+    fn visit_ty(&mut self, arg: &'tcx hir::Ty<'tcx>) {\n+        match arg.kind {\n+            hir::TyKind::Rptr(_, ref mut_ty) => {\n+                // We don't want to suggest looking into borrowing `&T` or `&Self`.\n+                hir::intravisit::walk_ty(self, mut_ty.ty);\n+                return;\n+            }\n+            hir::TyKind::Path(hir::QPath::Resolved(None, path)) => match &path.segments {\n+                [segment]\n+                    if segment\n+                        .res\n+                        .map(|res| match res {\n+                            Res::SelfTy(_, _) | Res::Def(hir::def::DefKind::TyParam, _) => true,\n+                            _ => false,\n+                        })\n+                        .unwrap_or(false) =>\n+                {\n+                    self.types.push(path.span);\n+                }\n+                _ => {}\n+            },\n+            _ => {}\n+        }\n+        hir::intravisit::walk_ty(self, arg);\n+    }\n+}"}, {"sha": "3d2ddf12a0a1f933042a88f7765d8e1740906163", "filename": "src/librustc_lint/levels.rs", "status": "modified", "additions": 19, "deletions": 2, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Flibrustc_lint%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Flibrustc_lint%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flevels.rs?ref=0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "patch": "@@ -14,11 +14,11 @@ use rustc_middle::lint::LintDiagnosticBuilder;\n use rustc_middle::lint::{struct_lint_level, LintLevelMap, LintLevelSets, LintSet, LintSource};\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::TyCtxt;\n-use rustc_session::lint::{builtin, Level, Lint};\n+use rustc_session::lint::{builtin, Level, Lint, LintId};\n use rustc_session::parse::feature_err;\n use rustc_session::Session;\n-use rustc_span::source_map::MultiSpan;\n use rustc_span::symbol::{sym, Symbol};\n+use rustc_span::{source_map::MultiSpan, Span, DUMMY_SP};\n \n use std::cmp;\n \n@@ -80,11 +80,13 @@ impl<'s> LintLevelsBuilder<'s> {\n             let level = cmp::min(level, self.sets.lint_cap);\n \n             let lint_flag_val = Symbol::intern(lint_name);\n+\n             let ids = match store.find_lints(&lint_name) {\n                 Ok(ids) => ids,\n                 Err(_) => continue, // errors handled in check_lint_name_cmdline above\n             };\n             for id in ids {\n+                self.check_gated_lint(id, DUMMY_SP);\n                 let src = LintSource::CommandLine(lint_flag_val);\n                 specs.insert(id, (level, src));\n             }\n@@ -213,6 +215,7 @@ impl<'s> LintLevelsBuilder<'s> {\n                     CheckLintNameResult::Ok(ids) => {\n                         let src = LintSource::Node(name, li.span(), reason);\n                         for id in ids {\n+                            self.check_gated_lint(*id, attr.span);\n                             specs.insert(*id, (level, src));\n                         }\n                     }\n@@ -383,6 +386,20 @@ impl<'s> LintLevelsBuilder<'s> {\n         BuilderPush { prev, changed: prev != self.cur }\n     }\n \n+    fn check_gated_lint(&self, id: LintId, span: Span) {\n+        if id == LintId::of(builtin::UNSAFE_OP_IN_UNSAFE_FN)\n+            && !self.sess.features_untracked().unsafe_block_in_unsafe_fn\n+        {\n+            feature_err(\n+                &self.sess.parse_sess,\n+                sym::unsafe_block_in_unsafe_fn,\n+                span,\n+                \"the `unsafe_op_in_unsafe_fn` lint is unstable\",\n+            )\n+            .emit();\n+        }\n+    }\n+\n     /// Called after `push` when the scope of a set of attributes are exited.\n     pub fn pop(&mut self, push: BuilderPush) {\n         self.cur = push.prev;"}, {"sha": "061bc9750e1c27d033961bc17cc400e60237719a", "filename": "src/librustc_middle/mir/interpret/mod.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fmod.rs?ref=0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "patch": "@@ -598,3 +598,12 @@ pub fn truncate(value: u128, size: Size) -> u128 {\n     // Truncate (shift left to drop out leftover values, shift right to fill with zeroes).\n     (value << shift) >> shift\n }\n+\n+/// Computes the unsigned absolute value without wrapping or panicking.\n+#[inline]\n+pub fn uabs(value: i64) -> u64 {\n+    // The only tricky part here is if value == i64::MIN. In that case,\n+    // wrapping_abs() returns i64::MIN == -2^63. Casting this value to a u64\n+    // gives 2^63, the correct value.\n+    value.wrapping_abs() as u64\n+}"}, {"sha": "ccad4f0a135a16d3557c7d5603b6222d39149709", "filename": "src/librustc_middle/mir/interpret/pointer.rs", "status": "modified", "additions": 17, "deletions": 9, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fpointer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fpointer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Finterpret%2Fpointer.rs?ref=0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "patch": "@@ -1,4 +1,4 @@\n-use super::{AllocId, InterpResult};\n+use super::{uabs, AllocId, InterpResult};\n \n use rustc_macros::HashStable;\n use rustc_target::abi::{HasDataLayout, Size};\n@@ -24,6 +24,12 @@ pub trait PointerArithmetic: HasDataLayout {\n         u64::try_from(max_usize_plus_1 - 1).unwrap()\n     }\n \n+    #[inline]\n+    fn machine_isize_min(&self) -> i64 {\n+        let max_isize_plus_1 = 1i128 << (self.pointer_size().bits() - 1);\n+        i64::try_from(-max_isize_plus_1).unwrap()\n+    }\n+\n     #[inline]\n     fn machine_isize_max(&self) -> i64 {\n         let max_isize_plus_1 = 1u128 << (self.pointer_size().bits() - 1);\n@@ -42,21 +48,23 @@ pub trait PointerArithmetic: HasDataLayout {\n \n     #[inline]\n     fn overflowing_offset(&self, val: u64, i: u64) -> (u64, bool) {\n+        // We do not need to check if i fits in a machine usize. If it doesn't,\n+        // either the wrapping_add will wrap or res will not fit in a pointer.\n         let res = val.overflowing_add(i);\n         self.truncate_to_ptr(res)\n     }\n \n     #[inline]\n     fn overflowing_signed_offset(&self, val: u64, i: i64) -> (u64, bool) {\n-        if i < 0 {\n-            // Trickery to ensure that `i64::MIN` works fine: compute `n = -i`.\n-            // This formula only works for true negative values; it overflows for zero!\n-            let n = u64::MAX - (i as u64) + 1;\n-            let res = val.overflowing_sub(n);\n-            self.truncate_to_ptr(res)\n+        // We need to make sure that i fits in a machine isize.\n+        let n = uabs(i);\n+        if i >= 0 {\n+            let (val, over) = self.overflowing_offset(val, n);\n+            (val, over || i > self.machine_isize_max())\n         } else {\n-            // `i >= 0`, so the cast is safe.\n-            self.overflowing_offset(val, i as u64)\n+            let res = val.overflowing_sub(n);\n+            let (val, over) = self.truncate_to_ptr(res);\n+            (val, over || i < self.machine_isize_min())\n         }\n     }\n "}, {"sha": "20c64d40fabbd5b4cd9cc4936347087481eef384", "filename": "src/librustc_middle/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Flibrustc_middle%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Flibrustc_middle%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fmod.rs?ref=0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "patch": "@@ -408,7 +408,7 @@ impl<'tcx> Body<'tcx> {\n     }\n }\n \n-#[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable, HashStable)]\n+#[derive(Copy, Clone, PartialEq, Eq, Debug, RustcEncodable, RustcDecodable, HashStable)]\n pub enum Safety {\n     Safe,\n     /// Unsafe because of a PushUnsafeBlock"}, {"sha": "99bfb74c243b47c7742c4d30bd57764d92c0b126", "filename": "src/librustc_middle/mir/query.rs", "status": "modified", "additions": 13, "deletions": 1, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Flibrustc_middle%2Fmir%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Flibrustc_middle%2Fmir%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_middle%2Fmir%2Fquery.rs?ref=0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "patch": "@@ -15,15 +15,27 @@ use super::{Field, SourceInfo};\n \n #[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, HashStable)]\n pub enum UnsafetyViolationKind {\n+    /// Only permitted in regular `fn`s, prohibitted in `const fn`s.\n     General,\n     /// Permitted both in `const fn`s and regular `fn`s.\n     GeneralAndConstFn,\n-    BorrowPacked(hir::HirId),\n+    /// Borrow of packed field.\n+    /// Has to be handled as a lint for backwards compatibility.\n+    BorrowPacked,\n+    /// Unsafe operation in an `unsafe fn` but outside an `unsafe` block.\n+    /// Has to be handled as a lint for backwards compatibility.\n+    /// Should stay gated under `#![feature(unsafe_block_in_unsafe_fn)]`.\n+    UnsafeFn,\n+    /// Borrow of packed field in an `unsafe fn` but outside an `unsafe` block.\n+    /// Has to be handled as a lint for backwards compatibility.\n+    /// Should stay gated under `#![feature(unsafe_block_in_unsafe_fn)]`.\n+    UnsafeFnBorrowPacked,\n }\n \n #[derive(Copy, Clone, PartialEq, RustcEncodable, RustcDecodable, HashStable)]\n pub struct UnsafetyViolation {\n     pub source_info: SourceInfo,\n+    pub lint_root: hir::HirId,\n     pub description: Symbol,\n     pub details: Symbol,\n     pub kind: UnsafetyViolationKind,"}, {"sha": "d0050f801fc6bbdd72ddbba27e8b018b255e247c", "filename": "src/librustc_mir/borrow_check/diagnostics/conflict_errors.rs", "status": "modified", "additions": 42, "deletions": 47, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fconflict_errors.rs?ref=0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "patch": "@@ -214,7 +214,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     let generics = tcx.generics_of(self.mir_def_id);\n                     let param = generics.type_param(&param_ty, tcx);\n                     if let Some(generics) =\n-                        tcx.hir().get_generics(tcx.closure_base_def_id(self.mir_def_id))\n+                        tcx.hir().get_generics(tcx.closure_base_def_id(self.mir_def_id.to_def_id()))\n                     {\n                         suggest_constraining_type_param(\n                             tcx,\n@@ -865,49 +865,42 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 format!(\"`{}` would have to be valid for `{}`...\", name, region_name),\n             );\n \n-            if let Some(def_id) = self.mir_def_id.as_local() {\n-                let fn_hir_id = self.infcx.tcx.hir().as_local_hir_id(def_id);\n-                err.span_label(\n-                    drop_span,\n-                    format!(\n-                        \"...but `{}` will be dropped here, when the {} returns\",\n-                        name,\n-                        self.infcx\n-                            .tcx\n-                            .hir()\n-                            .opt_name(fn_hir_id)\n-                            .map(|name| format!(\"function `{}`\", name))\n-                            .unwrap_or_else(|| {\n-                                match &self\n-                                    .infcx\n-                                    .tcx\n-                                    .typeck_tables_of(def_id)\n-                                    .node_type(fn_hir_id)\n-                                    .kind\n-                                {\n-                                    ty::Closure(..) => \"enclosing closure\",\n-                                    ty::Generator(..) => \"enclosing generator\",\n-                                    kind => bug!(\"expected closure or generator, found {:?}\", kind),\n-                                }\n-                                .to_string()\n-                            })\n-                    ),\n-                );\n+            let fn_hir_id = self.infcx.tcx.hir().as_local_hir_id(self.mir_def_id);\n+            err.span_label(\n+                drop_span,\n+                format!(\n+                    \"...but `{}` will be dropped here, when the {} returns\",\n+                    name,\n+                    self.infcx\n+                        .tcx\n+                        .hir()\n+                        .opt_name(fn_hir_id)\n+                        .map(|name| format!(\"function `{}`\", name))\n+                        .unwrap_or_else(|| {\n+                            match &self\n+                                .infcx\n+                                .tcx\n+                                .typeck_tables_of(self.mir_def_id)\n+                                .node_type(fn_hir_id)\n+                                .kind\n+                            {\n+                                ty::Closure(..) => \"enclosing closure\",\n+                                ty::Generator(..) => \"enclosing generator\",\n+                                kind => bug!(\"expected closure or generator, found {:?}\", kind),\n+                            }\n+                            .to_string()\n+                        })\n+                ),\n+            );\n \n-                err.note(\n-                    \"functions cannot return a borrow to data owned within the function's scope, \\\n-                     functions can only return borrows to data passed as arguments\",\n-                );\n-                err.note(\n-                    \"to learn more, visit <https://doc.rust-lang.org/book/ch04-02-\\\n-                     references-and-borrowing.html#dangling-references>\",\n-                );\n-            } else {\n-                err.span_label(\n-                    drop_span,\n-                    format!(\"...but `{}` dropped here while still borrowed\", name),\n-                );\n-            }\n+            err.note(\n+                \"functions cannot return a borrow to data owned within the function's scope, \\\n+                    functions can only return borrows to data passed as arguments\",\n+            );\n+            err.note(\n+                \"to learn more, visit <https://doc.rust-lang.org/book/ch04-02-\\\n+                    references-and-borrowing.html#dangling-references>\",\n+            );\n \n             if let BorrowExplanation::MustBeValidFor { .. } = explanation {\n             } else {\n@@ -1237,7 +1230,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     ) -> DiagnosticBuilder<'cx> {\n         let tcx = self.infcx.tcx;\n \n-        let (_, escapes_from) = tcx.article_and_description(self.mir_def_id);\n+        let (_, escapes_from) = tcx.article_and_description(self.mir_def_id.to_def_id());\n \n         let mut err =\n             borrowck_errors::borrowed_data_escapes_closure(tcx, escape_span, escapes_from);\n@@ -1572,14 +1565,16 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n     ) -> Option<AnnotatedBorrowFnSignature<'tcx>> {\n         // Define a fallback for when we can't match a closure.\n         let fallback = || {\n-            let is_closure = self.infcx.tcx.is_closure(self.mir_def_id);\n+            let is_closure = self.infcx.tcx.is_closure(self.mir_def_id.to_def_id());\n             if is_closure {\n                 None\n             } else {\n                 let ty = self.infcx.tcx.type_of(self.mir_def_id);\n                 match ty.kind {\n-                    ty::FnDef(_, _) | ty::FnPtr(_) => self\n-                        .annotate_fn_sig(self.mir_def_id, self.infcx.tcx.fn_sig(self.mir_def_id)),\n+                    ty::FnDef(_, _) | ty::FnPtr(_) => self.annotate_fn_sig(\n+                        self.mir_def_id.to_def_id(),\n+                        self.infcx.tcx.fn_sig(self.mir_def_id),\n+                    ),\n                     _ => None,\n                 }\n             }"}, {"sha": "b49e4187fb81070124337a95064b142081274184", "filename": "src/librustc_mir/borrow_check/diagnostics/move_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmove_errors.rs?ref=0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "patch": "@@ -331,7 +331,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 self.cannot_move_out_of_interior_noncopy(span, ty, None)\n             }\n             ty::Closure(def_id, closure_substs)\n-                if def_id == self.mir_def_id && upvar_field.is_some() =>\n+                if def_id.as_local() == Some(self.mir_def_id) && upvar_field.is_some() =>\n             {\n                 let closure_kind_ty = closure_substs.as_closure().kind_ty();\n                 let closure_kind = closure_kind_ty.to_opt_closure_kind();"}, {"sha": "e04ed8b83debd94509c692098c517f03abb96de4", "filename": "src/librustc_mir/borrow_check/diagnostics/mutability_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fmutability_errors.rs?ref=0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "patch": "@@ -492,7 +492,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         err.span_label(sp, format!(\"cannot {}\", act));\n \n         let hir = self.infcx.tcx.hir();\n-        let closure_id = hir.as_local_hir_id(self.mir_def_id.expect_local());\n+        let closure_id = hir.as_local_hir_id(self.mir_def_id);\n         let fn_call_id = hir.get_parent_node(closure_id);\n         let node = hir.get(fn_call_id);\n         let item_id = hir.get_parent_item(fn_call_id);"}, {"sha": "727c4d0605e124939a1a9c53886d713332f49549", "filename": "src/librustc_mir/borrow_check/diagnostics/region_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs?ref=0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "patch": "@@ -498,7 +498,7 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n         let mut diag =\n             self.infcx.tcx.sess.struct_span_err(*span, \"lifetime may not live long enough\");\n \n-        let (_, mir_def_name) = self.infcx.tcx.article_and_description(self.mir_def_id);\n+        let (_, mir_def_name) = self.infcx.tcx.article_and_description(self.mir_def_id.to_def_id());\n \n         let fr_name = self.give_region_a_name(*fr).unwrap();\n         fr_name.highlight_region_name(&mut diag);"}, {"sha": "2240eb81e1fa778aae5d63abc338b6582e11ec39", "filename": "src/librustc_mir/borrow_check/diagnostics/region_name.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fdiagnostics%2Fregion_name.rs?ref=0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "patch": "@@ -237,8 +237,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n                 }\n \n                 ty::BoundRegion::BrEnv => {\n-                    let mir_hir_id =\n-                        self.infcx.tcx.hir().as_local_hir_id(self.mir_def_id.expect_local());\n+                    let mir_hir_id = self.infcx.tcx.hir().as_local_hir_id(self.mir_def_id);\n                     let def_ty = self.regioncx.universal_regions().defining_ty;\n \n                     if let DefiningTy::Closure(_, substs) = def_ty {\n@@ -323,7 +322,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n         argument_ty: Ty<'tcx>,\n         argument_index: usize,\n     ) -> Option<RegionName> {\n-        let mir_hir_id = self.infcx.tcx.hir().as_local_hir_id(self.mir_def_id.as_local()?);\n+        let mir_hir_id = self.infcx.tcx.hir().as_local_hir_id(self.mir_def_id);\n         let fn_decl = self.infcx.tcx.hir().fn_decl_by_hir_id(mir_hir_id)?;\n         let argument_hir_ty: &hir::Ty<'_> = fn_decl.inputs.get(argument_index)?;\n         match argument_hir_ty.kind {\n@@ -634,7 +633,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n         highlight.highlighting_region_vid(fr, *self.next_region_name.try_borrow().unwrap());\n         let type_name = self.infcx.extract_type_name(&return_ty, Some(highlight)).0;\n \n-        let mir_hir_id = tcx.hir().as_local_hir_id(self.mir_def_id.expect_local());\n+        let mir_hir_id = tcx.hir().as_local_hir_id(self.mir_def_id);\n \n         let (return_span, mir_description) = match tcx.hir().get(mir_hir_id) {\n             hir::Node::Expr(hir::Expr {\n@@ -686,7 +685,7 @@ impl<'tcx> MirBorrowckCtxt<'_, 'tcx> {\n         highlight.highlighting_region_vid(fr, *self.next_region_name.try_borrow().unwrap());\n         let type_name = self.infcx.extract_type_name(&yield_ty, Some(highlight)).0;\n \n-        let mir_hir_id = tcx.hir().as_local_hir_id(self.mir_def_id.expect_local());\n+        let mir_hir_id = tcx.hir().as_local_hir_id(self.mir_def_id);\n \n         let yield_span = match tcx.hir().get(mir_hir_id) {\n             hir::Node::Expr(hir::Expr {"}, {"sha": "e3098fc1cfc54943a0d7f268bcb6610870cd852e", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "patch": "@@ -4,10 +4,8 @@ use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::graph::dominators::Dominators;\n use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, ErrorReported};\n use rustc_hir as hir;\n-use rustc_hir::{\n-    def_id::{DefId, LocalDefId},\n-    HirId, Node,\n-};\n+use rustc_hir::def_id::LocalDefId;\n+use rustc_hir::{HirId, Node};\n use rustc_index::bit_set::BitSet;\n use rustc_index::vec::IndexVec;\n use rustc_infer::infer::{InferCtxt, TyCtxtInferExt};\n@@ -174,7 +172,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n     let mut body = input_body.clone();\n     let mut promoted = input_promoted.clone();\n     let free_regions =\n-        nll::replace_regions_in_mir(infcx, def_id.to_def_id(), param_env, &mut body, &mut promoted);\n+        nll::replace_regions_in_mir(infcx, def_id, param_env, &mut body, &mut promoted);\n     let body = &body; // no further changes\n \n     let location_table = &LocationTable::new(&body);\n@@ -275,7 +273,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n             let mut promoted_mbcx = MirBorrowckCtxt {\n                 infcx,\n                 body: promoted_body,\n-                mir_def_id: def_id.to_def_id(),\n+                mir_def_id: def_id,\n                 move_data: &move_data,\n                 location_table: &LocationTable::new(promoted_body),\n                 movable_generator,\n@@ -307,7 +305,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n     let mut mbcx = MirBorrowckCtxt {\n         infcx,\n         body,\n-        mir_def_id: def_id.to_def_id(),\n+        mir_def_id: def_id,\n         move_data: &mdpe.move_data,\n         location_table,\n         movable_generator,\n@@ -459,7 +457,7 @@ fn do_mir_borrowck<'a, 'tcx>(\n crate struct MirBorrowckCtxt<'cx, 'tcx> {\n     crate infcx: &'cx InferCtxt<'cx, 'tcx>,\n     body: &'cx Body<'tcx>,\n-    mir_def_id: DefId,\n+    mir_def_id: LocalDefId,\n     move_data: &'cx MoveData<'tcx>,\n \n     /// Map from MIR `Location` to `LocationIndex`; created"}, {"sha": "1d3733371473b109cfe1518d81af2f17f1282044", "filename": "src/librustc_mir/borrow_check/nll.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Flibrustc_mir%2Fborrow_check%2Fnll.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Flibrustc_mir%2Fborrow_check%2Fnll.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll.rs?ref=0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "patch": "@@ -58,20 +58,20 @@ crate struct NllOutput<'tcx> {\n /// `compute_regions`.\n pub(in crate::borrow_check) fn replace_regions_in_mir<'cx, 'tcx>(\n     infcx: &InferCtxt<'cx, 'tcx>,\n-    def_id: DefId,\n+    def_id: LocalDefId,\n     param_env: ty::ParamEnv<'tcx>,\n     body: &mut Body<'tcx>,\n     promoted: &mut IndexVec<Promoted, Body<'tcx>>,\n ) -> UniversalRegions<'tcx> {\n     debug!(\"replace_regions_in_mir(def_id={:?})\", def_id);\n \n     // Compute named region information. This also renumbers the inputs/outputs.\n-    let universal_regions = UniversalRegions::new(infcx, def_id.expect_local(), param_env);\n+    let universal_regions = UniversalRegions::new(infcx, def_id, param_env);\n \n     // Replace all remaining regions with fresh inference variables.\n     renumber::renumber_mir(infcx, body, promoted);\n \n-    let source = MirSource::item(def_id);\n+    let source = MirSource::item(def_id.to_def_id());\n     mir_util::dump_mir(infcx.tcx, None, \"renumber\", &0, source, body, |_, _| Ok(()));\n \n     universal_regions"}, {"sha": "55f254f57326159992af8525e22d346daa243c96", "filename": "src/librustc_mir/interpret/intrinsics.rs", "status": "modified", "additions": 54, "deletions": 3, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fintrinsics.rs?ref=0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "patch": "@@ -2,19 +2,21 @@\n //! looking at their MIR. Intrinsics/functions supported here are shared by CTFE\n //! and miri.\n \n+use std::convert::TryFrom;\n+\n use rustc_hir::def_id::DefId;\n use rustc_middle::mir::{\n     self,\n-    interpret::{ConstValue, GlobalId, InterpResult, Scalar},\n+    interpret::{uabs, ConstValue, GlobalId, InterpResult, Scalar},\n     BinOp,\n };\n use rustc_middle::ty;\n use rustc_middle::ty::subst::SubstsRef;\n-use rustc_middle::ty::TyCtxt;\n+use rustc_middle::ty::{Ty, TyCtxt};\n use rustc_span::symbol::{sym, Symbol};\n use rustc_target::abi::{Abi, LayoutOf as _, Primitive, Size};\n \n-use super::{ImmTy, InterpCx, Machine, OpTy, PlaceTy};\n+use super::{CheckInAllocMsg, ImmTy, InterpCx, Machine, OpTy, PlaceTy};\n \n mod caller_location;\n mod type_name;\n@@ -279,7 +281,24 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n                 let result = Scalar::from_uint(truncated_bits, layout.size);\n                 self.write_scalar(result, dest)?;\n             }\n+            sym::offset => {\n+                let ptr = self.read_scalar(args[0])?.not_undef()?;\n+                let offset_count = self.read_scalar(args[1])?.to_machine_isize(self)?;\n+                let pointee_ty = substs.type_at(0);\n+\n+                let offset_ptr = self.ptr_offset_inbounds(ptr, pointee_ty, offset_count)?;\n+                self.write_scalar(offset_ptr, dest)?;\n+            }\n+            sym::arith_offset => {\n+                let ptr = self.read_scalar(args[0])?.not_undef()?;\n+                let offset_count = self.read_scalar(args[1])?.to_machine_isize(self)?;\n+                let pointee_ty = substs.type_at(0);\n \n+                let pointee_size = i64::try_from(self.layout_of(pointee_ty)?.size.bytes()).unwrap();\n+                let offset_bytes = offset_count.wrapping_mul(pointee_size);\n+                let offset_ptr = ptr.ptr_wrapping_signed_offset(offset_bytes, self);\n+                self.write_scalar(offset_ptr, dest)?;\n+            }\n             sym::ptr_offset_from => {\n                 let a = self.read_immediate(args[0])?.to_scalar()?;\n                 let b = self.read_immediate(args[1])?.to_scalar()?;\n@@ -409,4 +428,36 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         // `Rem` says this is all right, so we can let `Div` do its job.\n         self.binop_ignore_overflow(BinOp::Div, a, b, dest)\n     }\n+\n+    /// Offsets a pointer by some multiple of its type, returning an error if the pointer leaves its\n+    /// allocation. For integer pointers, we consider each of them their own tiny allocation of size\n+    /// 0, so offset-by-0 (and only 0) is okay -- except that NULL cannot be offset by _any_ value.\n+    pub fn ptr_offset_inbounds(\n+        &self,\n+        ptr: Scalar<M::PointerTag>,\n+        pointee_ty: Ty<'tcx>,\n+        offset_count: i64,\n+    ) -> InterpResult<'tcx, Scalar<M::PointerTag>> {\n+        // We cannot overflow i64 as a type's size must be <= isize::MAX.\n+        let pointee_size = i64::try_from(self.layout_of(pointee_ty)?.size.bytes()).unwrap();\n+        // The computed offset, in bytes, cannot overflow an isize.\n+        let offset_bytes =\n+            offset_count.checked_mul(pointee_size).ok_or(err_ub!(PointerArithOverflow))?;\n+        // The offset being in bounds cannot rely on \"wrapping around\" the address space.\n+        // So, first rule out overflows in the pointer arithmetic.\n+        let offset_ptr = ptr.ptr_signed_offset(offset_bytes, self)?;\n+        // ptr and offset_ptr must be in bounds of the same allocated object. This means all of the\n+        // memory between these pointers must be accessible. Note that we do not require the\n+        // pointers to be properly aligned (unlike a read/write operation).\n+        let min_ptr = if offset_bytes >= 0 { ptr } else { offset_ptr };\n+        let size: u64 = uabs(offset_bytes);\n+        // This call handles checking for integer/NULL pointers.\n+        self.memory.check_ptr_access_align(\n+            min_ptr,\n+            Size::from_bytes(size),\n+            None,\n+            CheckInAllocMsg::InboundsTest,\n+        )?;\n+        Ok(offset_ptr)\n+    }\n }"}, {"sha": "1f01bc0e19513456c81cf95f1bed5dfd63f6c3f7", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 117, "deletions": 23, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "patch": "@@ -2,14 +2,16 @@ use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::struct_span_err;\n use rustc_hir as hir;\n use rustc_hir::def_id::{DefId, LocalDefId};\n+use rustc_hir::hir_id::HirId;\n use rustc_hir::intravisit;\n use rustc_hir::Node;\n use rustc_middle::mir::visit::{MutatingUseContext, PlaceContext, Visitor};\n use rustc_middle::mir::*;\n use rustc_middle::ty::cast::CastTy;\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{self, TyCtxt};\n-use rustc_session::lint::builtin::{SAFE_PACKED_BORROWS, UNUSED_UNSAFE};\n+use rustc_session::lint::builtin::{SAFE_PACKED_BORROWS, UNSAFE_OP_IN_UNSAFE_FN, UNUSED_UNSAFE};\n+use rustc_session::lint::Level;\n use rustc_span::symbol::{sym, Symbol};\n \n use std::ops::Bound;\n@@ -202,25 +204,30 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n \n         if context.is_borrow() {\n             if util::is_disaligned(self.tcx, self.body, self.param_env, *place) {\n-                let source_info = self.source_info;\n-                let lint_root = self.body.source_scopes[source_info.scope]\n-                    .local_data\n-                    .as_ref()\n-                    .assert_crate_local()\n-                    .lint_root;\n                 self.require_unsafe(\n                     \"borrow of packed field\",\n                     \"fields of packed structs might be misaligned: dereferencing a \\\n                     misaligned pointer or even just creating a misaligned reference \\\n                     is undefined behavior\",\n-                    UnsafetyViolationKind::BorrowPacked(lint_root),\n+                    UnsafetyViolationKind::BorrowPacked,\n                 );\n             }\n         }\n \n         for (i, elem) in place.projection.iter().enumerate() {\n             let proj_base = &place.projection[..i];\n-            let old_source_info = self.source_info;\n+            if context.is_borrow() {\n+                if util::is_disaligned(self.tcx, self.body, self.param_env, *place) {\n+                    self.require_unsafe(\n+                        \"borrow of packed field\",\n+                        \"fields of packed structs might be misaligned: dereferencing a \\\n+                        misaligned pointer or even just creating a misaligned reference \\\n+                        is undefined behavior\",\n+                        UnsafetyViolationKind::BorrowPacked,\n+                    );\n+                }\n+            }\n+            let source_info = self.source_info;\n             if let [] = proj_base {\n                 let decl = &self.body.local_decls[place.local];\n                 if decl.internal {\n@@ -301,7 +308,7 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                 }\n                 _ => {}\n             }\n-            self.source_info = old_source_info;\n+            self.source_info = source_info;\n         }\n     }\n }\n@@ -314,9 +321,15 @@ impl<'a, 'tcx> UnsafetyChecker<'a, 'tcx> {\n         kind: UnsafetyViolationKind,\n     ) {\n         let source_info = self.source_info;\n+        let lint_root = self.body.source_scopes[self.source_info.scope]\n+            .local_data\n+            .as_ref()\n+            .assert_crate_local()\n+            .lint_root;\n         self.register_violations(\n             &[UnsafetyViolation {\n                 source_info,\n+                lint_root,\n                 description: Symbol::intern(description),\n                 details: Symbol::intern(details),\n                 kind,\n@@ -343,22 +356,42 @@ impl<'a, 'tcx> UnsafetyChecker<'a, 'tcx> {\n                     match violation.kind {\n                         UnsafetyViolationKind::GeneralAndConstFn\n                         | UnsafetyViolationKind::General => {}\n-                        UnsafetyViolationKind::BorrowPacked(_) => {\n+                        UnsafetyViolationKind::BorrowPacked => {\n                             if self.min_const_fn {\n                                 // const fns don't need to be backwards compatible and can\n                                 // emit these violations as a hard error instead of a backwards\n                                 // compat lint\n                                 violation.kind = UnsafetyViolationKind::General;\n                             }\n                         }\n+                        UnsafetyViolationKind::UnsafeFn\n+                        | UnsafetyViolationKind::UnsafeFnBorrowPacked => {\n+                            bug!(\"`UnsafetyViolationKind::UnsafeFn` in an `Safe` context\")\n+                        }\n+                    }\n+                    if !self.violations.contains(&violation) {\n+                        self.violations.push(violation)\n+                    }\n+                }\n+                false\n+            }\n+            // With the RFC 2585, no longer allow `unsafe` operations in `unsafe fn`s\n+            Safety::FnUnsafe if self.tcx.features().unsafe_block_in_unsafe_fn => {\n+                for violation in violations {\n+                    let mut violation = *violation;\n+\n+                    if violation.kind == UnsafetyViolationKind::BorrowPacked {\n+                        violation.kind = UnsafetyViolationKind::UnsafeFnBorrowPacked;\n+                    } else {\n+                        violation.kind = UnsafetyViolationKind::UnsafeFn;\n                     }\n                     if !self.violations.contains(&violation) {\n                         self.violations.push(violation)\n                     }\n                 }\n                 false\n             }\n-            // `unsafe` function bodies allow unsafe without additional unsafe blocks\n+            // `unsafe` function bodies allow unsafe without additional unsafe blocks (before RFC 2585)\n             Safety::BuiltinUnsafe | Safety::FnUnsafe => true,\n             Safety::ExplicitUnsafe(hir_id) => {\n                 // mark unsafe block as used if there are any unsafe operations inside\n@@ -373,7 +406,7 @@ impl<'a, 'tcx> UnsafetyChecker<'a, 'tcx> {\n                             UnsafetyViolationKind::GeneralAndConstFn => {}\n                             // these things are forbidden in const fns\n                             UnsafetyViolationKind::General\n-                            | UnsafetyViolationKind::BorrowPacked(_) => {\n+                            | UnsafetyViolationKind::BorrowPacked => {\n                                 let mut violation = *violation;\n                                 // const fns don't need to be backwards compatible and can\n                                 // emit these violations as a hard error instead of a backwards\n@@ -383,6 +416,10 @@ impl<'a, 'tcx> UnsafetyChecker<'a, 'tcx> {\n                                     self.violations.push(violation)\n                                 }\n                             }\n+                            UnsafetyViolationKind::UnsafeFn\n+                            | UnsafetyViolationKind::UnsafeFnBorrowPacked => bug!(\n+                                \"`UnsafetyViolationKind::UnsafeFn` in an `ExplicitUnsafe` context\"\n+                            ),\n                         }\n                     }\n                 }\n@@ -575,9 +612,12 @@ fn is_enclosed(\n             kind: hir::ItemKind::Fn(ref sig, _, _), ..\n         })) = tcx.hir().find(parent_id)\n         {\n-            match sig.header.unsafety {\n-                hir::Unsafety::Unsafe => Some((\"fn\".to_string(), parent_id)),\n-                hir::Unsafety::Normal => None,\n+            if sig.header.unsafety == hir::Unsafety::Unsafe\n+                && !tcx.features().unsafe_block_in_unsafe_fn\n+            {\n+                Some((\"fn\".to_string(), parent_id))\n+            } else {\n+                None\n             }\n         } else {\n             is_enclosed(tcx, used_unsafe, parent_id)\n@@ -630,40 +670,90 @@ pub fn check_unsafety(tcx: TyCtxt<'_>, def_id: DefId) {\n     let UnsafetyCheckResult { violations, unsafe_blocks } =\n         tcx.unsafety_check_result(def_id.expect_local());\n \n-    for &UnsafetyViolation { source_info, description, details, kind } in violations.iter() {\n+    for &UnsafetyViolation { source_info, lint_root, description, details, kind } in\n+        violations.iter()\n+    {\n         // Report an error.\n+        let unsafe_fn_msg =\n+            if unsafe_op_in_unsafe_fn_allowed(tcx, lint_root) { \" function or\" } else { \"\" };\n+\n         match kind {\n             UnsafetyViolationKind::GeneralAndConstFn | UnsafetyViolationKind::General => {\n+                // once\n                 struct_span_err!(\n                     tcx.sess,\n                     source_info.span,\n                     E0133,\n-                    \"{} is unsafe and requires unsafe function or block\",\n-                    description\n+                    \"{} is unsafe and requires unsafe{} block\",\n+                    description,\n+                    unsafe_fn_msg,\n                 )\n                 .span_label(source_info.span, &*description.as_str())\n                 .note(&details.as_str())\n                 .emit();\n             }\n-            UnsafetyViolationKind::BorrowPacked(lint_hir_id) => {\n+            UnsafetyViolationKind::BorrowPacked => {\n                 if let Some(impl_def_id) = builtin_derive_def_id(tcx, def_id) {\n                     tcx.ensure().unsafe_derive_on_repr_packed(impl_def_id);\n                 } else {\n                     tcx.struct_span_lint_hir(\n                         SAFE_PACKED_BORROWS,\n-                        lint_hir_id,\n+                        lint_root,\n                         source_info.span,\n                         |lint| {\n                             lint.build(&format!(\n-                                \"{} is unsafe and requires unsafe function or block (error E0133)\",\n-                                description\n+                                \"{} is unsafe and requires unsafe{} block (error E0133)\",\n+                                description, unsafe_fn_msg,\n                             ))\n                             .note(&details.as_str())\n                             .emit()\n                         },\n                     )\n                 }\n             }\n+            UnsafetyViolationKind::UnsafeFn => tcx.struct_span_lint_hir(\n+                UNSAFE_OP_IN_UNSAFE_FN,\n+                lint_root,\n+                source_info.span,\n+                |lint| {\n+                    lint.build(&format!(\n+                        \"{} is unsafe and requires unsafe block (error E0133)\",\n+                        description,\n+                    ))\n+                    .span_label(source_info.span, &*description.as_str())\n+                    .note(&details.as_str())\n+                    .emit();\n+                },\n+            ),\n+            UnsafetyViolationKind::UnsafeFnBorrowPacked => {\n+                // When `unsafe_op_in_unsafe_fn` is disallowed, the behavior of safe and unsafe functions\n+                // should be the same in terms of warnings and errors. Therefore, with `#[warn(safe_packed_borrows)]`,\n+                // a safe packed borrow should emit a warning *but not an error* in an unsafe function,\n+                // just like in a safe function, even if `unsafe_op_in_unsafe_fn` is `deny`.\n+                //\n+                // Also, `#[warn(unsafe_op_in_unsafe_fn)]` can't cause any new errors. Therefore, with\n+                // `#[deny(safe_packed_borrows)]` and `#[warn(unsafe_op_in_unsafe_fn)]`, a packed borrow\n+                // should only issue a warning for the sake of backwards compatibility.\n+                //\n+                // The solution those 2 expectations is to always take the minimum of both lints.\n+                // This prevent any new errors (unless both lints are explicitely set to `deny`).\n+                let lint = if tcx.lint_level_at_node(SAFE_PACKED_BORROWS, lint_root).0\n+                    <= tcx.lint_level_at_node(UNSAFE_OP_IN_UNSAFE_FN, lint_root).0\n+                {\n+                    SAFE_PACKED_BORROWS\n+                } else {\n+                    UNSAFE_OP_IN_UNSAFE_FN\n+                };\n+                tcx.struct_span_lint_hir(&lint, lint_root, source_info.span, |lint| {\n+                    lint.build(&format!(\n+                        \"{} is unsafe and requires unsafe block (error E0133)\",\n+                        description,\n+                    ))\n+                    .span_label(source_info.span, &*description.as_str())\n+                    .note(&details.as_str())\n+                    .emit();\n+                })\n+            }\n         }\n     }\n \n@@ -683,3 +773,7 @@ pub fn check_unsafety(tcx: TyCtxt<'_>, def_id: DefId) {\n         report_unused_unsafe(tcx, &unsafe_used, block_id);\n     }\n }\n+\n+fn unsafe_op_in_unsafe_fn_allowed(tcx: TyCtxt<'_>, id: HirId) -> bool {\n+    tcx.lint_level_at_node(UNSAFE_OP_IN_UNSAFE_FN, id).0 == Level::Allow\n+}"}, {"sha": "4e4f0dc74cb7ce0230b401f257185f6463b12af1", "filename": "src/librustc_mir_build/build/block.rs", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Flibrustc_mir_build%2Fbuild%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Flibrustc_mir_build%2Fbuild%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir_build%2Fbuild%2Fblock.rs?ref=0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "patch": "@@ -4,6 +4,8 @@ use crate::build::{BlockAnd, BlockAndExtension, BlockFrame, Builder};\n use crate::hair::*;\n use rustc_hir as hir;\n use rustc_middle::mir::*;\n+use rustc_session::lint::builtin::UNSAFE_OP_IN_UNSAFE_FN;\n+use rustc_session::lint::Level;\n use rustc_span::Span;\n \n impl<'a, 'tcx> Builder<'a, 'tcx> {\n@@ -217,6 +219,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 assert_eq!(self.push_unsafe_count, 0);\n                 match self.unpushed_unsafe {\n                     Safety::Safe => {}\n+                    // no longer treat `unsafe fn`s as `unsafe` contexts (see RFC #2585)\n+                    Safety::FnUnsafe\n+                        if self.hir.tcx().lint_level_at_node(UNSAFE_OP_IN_UNSAFE_FN, hir_id).0\n+                            != Level::Allow => {}\n                     _ => return,\n                 }\n                 self.unpushed_unsafe = Safety::ExplicitUnsafe(hir_id);\n@@ -231,7 +237,11 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                     .push_unsafe_count\n                     .checked_sub(1)\n                     .unwrap_or_else(|| span_bug!(span, \"unsafe count underflow\"));\n-                if self.push_unsafe_count == 0 { Some(self.unpushed_unsafe) } else { None }\n+                if self.push_unsafe_count == 0 {\n+                    Some(self.unpushed_unsafe)\n+                } else {\n+                    None\n+                }\n             }\n         };\n "}, {"sha": "7112ac35b082b8f66a06f4e5b8d2b3f84009689e", "filename": "src/librustc_session/lint/builtin.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Flibrustc_session%2Flint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Flibrustc_session%2Flint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_session%2Flint%2Fbuiltin.rs?ref=0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "patch": "@@ -526,6 +526,12 @@ declare_lint! {\n     \"using only a subset of a register for inline asm inputs\",\n }\n \n+declare_lint! {\n+    pub UNSAFE_OP_IN_UNSAFE_FN,\n+    Allow,\n+    \"unsafe operations in unsafe functions without an explicit unsafe block are deprecated\",\n+}\n+\n declare_lint_pass! {\n     /// Does nothing as a lint pass, but registers some `Lint`s\n     /// that are used by other parts of the compiler.\n@@ -597,6 +603,7 @@ declare_lint_pass! {\n         SOFT_UNSTABLE,\n         INLINE_NO_SANITIZE,\n         ASM_SUB_REGISTER,\n+        UNSAFE_OP_IN_UNSAFE_FN,\n     ]\n }\n "}, {"sha": "0f2d52c2264fd91cd5c5bc2cae7c568f7f3c8a6c", "filename": "src/librustc_span/symbol.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Flibrustc_span%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Flibrustc_span%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_span%2Fsymbol.rs?ref=0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "patch": "@@ -147,6 +147,7 @@ symbols! {\n         Arc,\n         Arguments,\n         ArgumentV1,\n+        arith_offset,\n         arm_target_feature,\n         asm,\n         assert,\n@@ -516,6 +517,7 @@ symbols! {\n         not,\n         note,\n         object_safe_for_dispatch,\n+        offset,\n         Ok,\n         omit_gdb_pretty_printer_section,\n         on,\n@@ -806,6 +808,7 @@ symbols! {\n         unmarked_api,\n         unreachable_code,\n         unrestricted_attribute_tokens,\n+        unsafe_block_in_unsafe_fn,\n         unsafe_no_drop_flag,\n         unsized_locals,\n         unsized_tuple_coercion,"}, {"sha": "a18a4dbd3e214f9a764fac279df862e3f5373981", "filename": "src/librustc_target/asm/mod.rs", "status": "modified", "additions": 26, "deletions": 3, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Flibrustc_target%2Fasm%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Flibrustc_target%2Fasm%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fasm%2Fmod.rs?ref=0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "patch": "@@ -60,6 +60,7 @@ macro_rules! def_regs {\n             #error = [$($bad_reg:literal),+] => $error:literal,\n         )*\n     }) => {\n+        #[allow(unreachable_code)]\n         #[derive(Copy, Clone, RustcEncodable, RustcDecodable, Debug, Eq, PartialEq, Hash, HashStable_Generic)]\n         #[allow(non_camel_case_types)]\n         pub enum $arch_reg {\n@@ -102,19 +103,20 @@ macro_rules! def_regs {\n         pub(super) fn fill_reg_map(\n             _arch: super::InlineAsmArch,\n             mut _has_feature: impl FnMut(&str) -> bool,\n-            map: &mut rustc_data_structures::fx::FxHashMap<\n+            _map: &mut rustc_data_structures::fx::FxHashMap<\n                 super::InlineAsmRegClass,\n                 rustc_data_structures::fx::FxHashSet<super::InlineAsmReg>,\n             >,\n         ) {\n+            #[allow(unused_imports)]\n             use super::{InlineAsmReg, InlineAsmRegClass};\n             $(\n                 if $($filter(_arch, &mut _has_feature, true).is_ok() &&)? true {\n-                    if let Some(set) = map.get_mut(&InlineAsmRegClass::$arch($arch_regclass::$class)) {\n+                    if let Some(set) = _map.get_mut(&InlineAsmRegClass::$arch($arch_regclass::$class)) {\n                         set.insert(InlineAsmReg::$arch($arch_reg::$reg));\n                     }\n                     $(\n-                        if let Some(set) = map.get_mut(&InlineAsmRegClass::$arch($arch_regclass::$extra_class)) {\n+                        if let Some(set) = _map.get_mut(&InlineAsmRegClass::$arch($arch_regclass::$extra_class)) {\n                             set.insert(InlineAsmReg::$arch($arch_reg::$reg));\n                         }\n                     )*\n@@ -146,11 +148,13 @@ macro_rules! types {\n \n mod aarch64;\n mod arm;\n+mod nvptx;\n mod riscv;\n mod x86;\n \n pub use aarch64::{AArch64InlineAsmReg, AArch64InlineAsmRegClass};\n pub use arm::{ArmInlineAsmReg, ArmInlineAsmRegClass};\n+pub use nvptx::{NvptxInlineAsmReg, NvptxInlineAsmRegClass};\n pub use riscv::{RiscVInlineAsmReg, RiscVInlineAsmRegClass};\n pub use x86::{X86InlineAsmReg, X86InlineAsmRegClass};\n \n@@ -162,6 +166,7 @@ pub enum InlineAsmArch {\n     AArch64,\n     RiscV32,\n     RiscV64,\n+    Nvptx64,\n }\n \n impl FromStr for InlineAsmArch {\n@@ -175,6 +180,7 @@ impl FromStr for InlineAsmArch {\n             \"aarch64\" => Ok(Self::AArch64),\n             \"riscv32\" => Ok(Self::RiscV32),\n             \"riscv64\" => Ok(Self::RiscV64),\n+            \"nvptx64\" => Ok(Self::Nvptx64),\n             _ => Err(()),\n         }\n     }\n@@ -196,6 +202,7 @@ pub enum InlineAsmReg {\n     Arm(ArmInlineAsmReg),\n     AArch64(AArch64InlineAsmReg),\n     RiscV(RiscVInlineAsmReg),\n+    Nvptx(NvptxInlineAsmReg),\n }\n \n impl InlineAsmReg {\n@@ -236,6 +243,9 @@ impl InlineAsmReg {\n             InlineAsmArch::RiscV32 | InlineAsmArch::RiscV64 => {\n                 Self::RiscV(RiscVInlineAsmReg::parse(arch, has_feature, &name)?)\n             }\n+            InlineAsmArch::Nvptx64 => {\n+                Self::Nvptx(NvptxInlineAsmReg::parse(arch, has_feature, &name)?)\n+            }\n         })\n     }\n \n@@ -281,6 +291,7 @@ pub enum InlineAsmRegClass {\n     Arm(ArmInlineAsmRegClass),\n     AArch64(AArch64InlineAsmRegClass),\n     RiscV(RiscVInlineAsmRegClass),\n+    Nvptx(NvptxInlineAsmRegClass),\n }\n \n impl InlineAsmRegClass {\n@@ -290,6 +301,7 @@ impl InlineAsmRegClass {\n             Self::Arm(r) => r.name(),\n             Self::AArch64(r) => r.name(),\n             Self::RiscV(r) => r.name(),\n+            Self::Nvptx(r) => r.name(),\n         }\n     }\n \n@@ -302,6 +314,7 @@ impl InlineAsmRegClass {\n             Self::Arm(r) => r.suggest_class(arch, ty).map(InlineAsmRegClass::Arm),\n             Self::AArch64(r) => r.suggest_class(arch, ty).map(InlineAsmRegClass::AArch64),\n             Self::RiscV(r) => r.suggest_class(arch, ty).map(InlineAsmRegClass::RiscV),\n+            Self::Nvptx(r) => r.suggest_class(arch, ty).map(InlineAsmRegClass::Nvptx),\n         }\n     }\n \n@@ -321,6 +334,7 @@ impl InlineAsmRegClass {\n             Self::Arm(r) => r.suggest_modifier(arch, ty),\n             Self::AArch64(r) => r.suggest_modifier(arch, ty),\n             Self::RiscV(r) => r.suggest_modifier(arch, ty),\n+            Self::Nvptx(r) => r.suggest_modifier(arch, ty),\n         }\n     }\n \n@@ -336,6 +350,7 @@ impl InlineAsmRegClass {\n             Self::Arm(r) => r.default_modifier(arch),\n             Self::AArch64(r) => r.default_modifier(arch),\n             Self::RiscV(r) => r.default_modifier(arch),\n+            Self::Nvptx(r) => r.default_modifier(arch),\n         }\n     }\n \n@@ -350,6 +365,7 @@ impl InlineAsmRegClass {\n             Self::Arm(r) => r.supported_types(arch),\n             Self::AArch64(r) => r.supported_types(arch),\n             Self::RiscV(r) => r.supported_types(arch),\n+            Self::Nvptx(r) => r.supported_types(arch),\n         }\n     }\n \n@@ -367,6 +383,7 @@ impl InlineAsmRegClass {\n                 InlineAsmArch::RiscV32 | InlineAsmArch::RiscV64 => {\n                     Self::RiscV(RiscVInlineAsmRegClass::parse(arch, name)?)\n                 }\n+                InlineAsmArch::Nvptx64 => Self::Nvptx(NvptxInlineAsmRegClass::parse(arch, name)?),\n             })\n         })\n     }\n@@ -379,6 +396,7 @@ impl InlineAsmRegClass {\n             Self::Arm(r) => r.valid_modifiers(arch),\n             Self::AArch64(r) => r.valid_modifiers(arch),\n             Self::RiscV(r) => r.valid_modifiers(arch),\n+            Self::Nvptx(r) => r.valid_modifiers(arch),\n         }\n     }\n }\n@@ -518,5 +536,10 @@ pub fn allocatable_registers(\n             riscv::fill_reg_map(arch, has_feature, &mut map);\n             map\n         }\n+        InlineAsmArch::Nvptx64 => {\n+            let mut map = nvptx::regclass_map();\n+            nvptx::fill_reg_map(arch, has_feature, &mut map);\n+            map\n+        }\n     }\n }"}, {"sha": "43d16ae0f5d102a51db4d16691e503c8f1b7fc3f", "filename": "src/librustc_target/asm/nvptx.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Flibrustc_target%2Fasm%2Fnvptx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Flibrustc_target%2Fasm%2Fnvptx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fasm%2Fnvptx.rs?ref=0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "patch": "@@ -0,0 +1,49 @@\n+use super::{InlineAsmArch, InlineAsmType};\n+use rustc_macros::HashStable_Generic;\n+\n+def_reg_class! {\n+    Nvptx NvptxInlineAsmRegClass {\n+        reg16,\n+        reg32,\n+        reg64,\n+    }\n+}\n+\n+impl NvptxInlineAsmRegClass {\n+    pub fn valid_modifiers(self, _arch: InlineAsmArch) -> &'static [char] {\n+        &[]\n+    }\n+\n+    pub fn suggest_class(self, _arch: InlineAsmArch, _ty: InlineAsmType) -> Option<Self> {\n+        None\n+    }\n+\n+    pub fn suggest_modifier(\n+        self,\n+        _arch: InlineAsmArch,\n+        _ty: InlineAsmType,\n+    ) -> Option<(char, &'static str)> {\n+        None\n+    }\n+\n+    pub fn default_modifier(self, _arch: InlineAsmArch) -> Option<(char, &'static str)> {\n+        None\n+    }\n+\n+    pub fn supported_types(\n+        self,\n+        _arch: InlineAsmArch,\n+    ) -> &'static [(InlineAsmType, Option<&'static str>)] {\n+        match self {\n+            Self::reg16 => types! { _: I8, I16; },\n+            Self::reg32 => types! { _: I8, I16, I32, F32; },\n+            Self::reg64 => types! { _: I8, I16, I32, F32, I64, F64; },\n+        }\n+    }\n+}\n+\n+def_regs! {\n+    // Registers in PTX are declared in the assembly.\n+    // There are no predefined registers that one can use.\n+    Nvptx NvptxInlineAsmReg NvptxInlineAsmRegClass {}\n+}"}, {"sha": "c9558879a1c6ec621a620a18c9df07f4d5c2416d", "filename": "src/librustc_target/spec/mod.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Flibrustc_target%2Fspec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Flibrustc_target%2Fspec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_target%2Fspec%2Fmod.rs?ref=0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "patch": "@@ -856,6 +856,8 @@ pub struct TargetOptions {\n     /// the functions in the executable are not randomized and can be used\n     /// during an exploit of a vulnerability in any code.\n     pub position_independent_executables: bool,\n+    /// Executables that are both statically linked and position-independent are supported.\n+    pub static_position_independent_executables: bool,\n     /// Determines if the target always requires using the PLT for indirect\n     /// library calls or not. This controls the default value of the `-Z plt` flag.\n     pub needs_plt: bool,\n@@ -1029,6 +1031,7 @@ impl Default for TargetOptions {\n             has_rpath: false,\n             no_default_libraries: true,\n             position_independent_executables: false,\n+            static_position_independent_executables: false,\n             needs_plt: false,\n             relro_level: RelroLevel::None,\n             pre_link_objects: Default::default(),\n@@ -1433,6 +1436,7 @@ impl Target {\n         key!(has_rpath, bool);\n         key!(no_default_libraries, bool);\n         key!(position_independent_executables, bool);\n+        key!(static_position_independent_executables, bool);\n         key!(needs_plt, bool);\n         key!(relro_level, RelroLevel)?;\n         key!(archive_format);\n@@ -1664,6 +1668,7 @@ impl ToJson for Target {\n         target_option_val!(has_rpath);\n         target_option_val!(no_default_libraries);\n         target_option_val!(position_independent_executables);\n+        target_option_val!(static_position_independent_executables);\n         target_option_val!(needs_plt);\n         target_option_val!(relro_level);\n         target_option_val!(archive_format);"}, {"sha": "99ca7084c30dd099c206155c39d1d04cb5030ebd", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "patch": "@@ -226,6 +226,11 @@ where\n {\n     let warnings_lint_name = lint::builtin::WARNINGS.name;\n \n+    // Whitelist feature-gated lints to avoid feature errors when trying to\n+    // allow all lints.\n+    // FIXME(#72694): handle feature-gated lints properly.\n+    let unsafe_op_in_unsafe_fn_name = rustc_lint::builtin::UNSAFE_OP_IN_UNSAFE_FN.name;\n+\n     whitelisted_lints.push(warnings_lint_name.to_owned());\n     whitelisted_lints.extend(lint_opts.iter().map(|(lint, _)| lint).cloned());\n \n@@ -236,7 +241,13 @@ where\n     };\n \n     let lint_opts = lints()\n-        .filter_map(|lint| if lint.name == warnings_lint_name { None } else { filter_call(lint) })\n+        .filter_map(|lint| {\n+            if lint.name == warnings_lint_name || lint.name == unsafe_op_in_unsafe_fn_name {\n+                None\n+            } else {\n+                filter_call(lint)\n+            }\n+        })\n         .chain(lint_opts.into_iter())\n         .collect::<Vec<_>>();\n "}, {"sha": "0f0be2c4883149d60a4add91d583c6d712cf6f5f", "filename": "src/libstd/net/ip.rs", "status": "modified", "additions": 78, "deletions": 80, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Flibstd%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Flibstd%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fip.rs?ref=0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "patch": "@@ -7,9 +7,9 @@\n )]\n \n use crate::cmp::Ordering;\n-use crate::fmt;\n+use crate::fmt::{self, Write as FmtWrite};\n use crate::hash;\n-use crate::io::Write;\n+use crate::io::Write as IoWrite;\n use crate::sys::net::netc as c;\n use crate::sys_common::{AsInner, FromInner};\n \n@@ -1532,102 +1532,100 @@ impl Ipv6Addr {\n     }\n }\n \n+/// Write an Ipv6Addr, conforming to the canonical style described by\n+/// [RFC 5952](https://tools.ietf.org/html/rfc5952).\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Display for Ipv6Addr {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        // Note: The calls to write should never fail, hence the unwraps in the function\n-        // Long enough for the longest possible IPv6: 39\n-        const IPV6_BUF_LEN: usize = 39;\n-        let mut buf = [0u8; IPV6_BUF_LEN];\n-        let mut buf_slice = &mut buf[..];\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        // If there are no alignment requirements, write out the IP address to\n+        // f. Otherwise, write it to a local buffer, then use f.pad.\n+        if f.precision().is_none() && f.width().is_none() {\n+            let segments = self.segments();\n+\n+            // Special case for :: and ::1; otherwise they get written with the\n+            // IPv4 formatter\n+            if self.is_unspecified() {\n+                f.write_str(\"::\")\n+            } else if self.is_loopback() {\n+                f.write_str(\"::1\")\n+            } else if let Some(ipv4) = self.to_ipv4() {\n+                match segments[5] {\n+                    // IPv4 Compatible address\n+                    0 => write!(f, \"::{}\", ipv4),\n+                    // IPv4 Mapped address\n+                    0xffff => write!(f, \"::ffff:{}\", ipv4),\n+                    _ => unreachable!(),\n+                }\n+            } else {\n+                #[derive(Copy, Clone, Default)]\n+                struct Span {\n+                    start: usize,\n+                    len: usize,\n+                }\n \n-        match self.segments() {\n-            // We need special cases for :: and ::1, otherwise they're formatted\n-            // as ::0.0.0.[01]\n-            [0, 0, 0, 0, 0, 0, 0, 0] => write!(buf_slice, \"::\").unwrap(),\n-            [0, 0, 0, 0, 0, 0, 0, 1] => write!(buf_slice, \"::1\").unwrap(),\n-            // Ipv4 Compatible address\n-            [0, 0, 0, 0, 0, 0, g, h] => {\n-                write!(\n-                    buf_slice,\n-                    \"::{}.{}.{}.{}\",\n-                    (g >> 8) as u8,\n-                    g as u8,\n-                    (h >> 8) as u8,\n-                    h as u8\n-                )\n-                .unwrap();\n-            }\n-            // Ipv4-Mapped address\n-            [0, 0, 0, 0, 0, 0xffff, g, h] => {\n-                write!(\n-                    buf_slice,\n-                    \"::ffff:{}.{}.{}.{}\",\n-                    (g >> 8) as u8,\n-                    g as u8,\n-                    (h >> 8) as u8,\n-                    h as u8\n-                )\n-                .unwrap();\n-            }\n-            _ => {\n-                fn find_zero_slice(segments: &[u16; 8]) -> (usize, usize) {\n-                    let mut longest_span_len = 0;\n-                    let mut longest_span_at = 0;\n-                    let mut cur_span_len = 0;\n-                    let mut cur_span_at = 0;\n-\n-                    for i in 0..8 {\n-                        if segments[i] == 0 {\n-                            if cur_span_len == 0 {\n-                                cur_span_at = i;\n+                // Find the inner 0 span\n+                let zeroes = {\n+                    let mut longest = Span::default();\n+                    let mut current = Span::default();\n+\n+                    for (i, &segment) in segments.iter().enumerate() {\n+                        if segment == 0 {\n+                            if current.len == 0 {\n+                                current.start = i;\n                             }\n \n-                            cur_span_len += 1;\n+                            current.len += 1;\n \n-                            if cur_span_len > longest_span_len {\n-                                longest_span_len = cur_span_len;\n-                                longest_span_at = cur_span_at;\n+                            if current.len > longest.len {\n+                                longest = current;\n                             }\n                         } else {\n-                            cur_span_len = 0;\n-                            cur_span_at = 0;\n+                            current = Span::default();\n                         }\n                     }\n \n-                    (longest_span_at, longest_span_len)\n-                }\n-\n-                let (zeros_at, zeros_len) = find_zero_slice(&self.segments());\n-\n-                if zeros_len > 1 {\n-                    fn fmt_subslice(segments: &[u16], buf: &mut &mut [u8]) {\n-                        if !segments.is_empty() {\n-                            write!(*buf, \"{:x}\", segments[0]).unwrap();\n-                            for &seg in &segments[1..] {\n-                                write!(*buf, \":{:x}\", seg).unwrap();\n-                            }\n+                    longest\n+                };\n+\n+                /// Write a colon-separated part of the address\n+                #[inline]\n+                fn fmt_subslice(f: &mut fmt::Formatter<'_>, chunk: &[u16]) -> fmt::Result {\n+                    if let Some(first) = chunk.first() {\n+                        fmt::LowerHex::fmt(first, f)?;\n+                        for segment in &chunk[1..] {\n+                            f.write_char(':')?;\n+                            fmt::LowerHex::fmt(segment, f)?;\n                         }\n                     }\n+                    Ok(())\n+                }\n \n-                    fmt_subslice(&self.segments()[..zeros_at], &mut buf_slice);\n-                    write!(buf_slice, \"::\").unwrap();\n-                    fmt_subslice(&self.segments()[zeros_at + zeros_len..], &mut buf_slice);\n+                if zeroes.len > 1 {\n+                    fmt_subslice(f, &segments[..zeroes.start])?;\n+                    f.write_str(\"::\")?;\n+                    fmt_subslice(f, &segments[zeroes.start + zeroes.len..])\n                 } else {\n-                    let &[a, b, c, d, e, f, g, h] = &self.segments();\n-                    write!(\n-                        buf_slice,\n-                        \"{:x}:{:x}:{:x}:{:x}:{:x}:{:x}:{:x}:{:x}\",\n-                        a, b, c, d, e, f, g, h\n-                    )\n-                    .unwrap();\n+                    fmt_subslice(f, &segments)\n                 }\n             }\n+        } else {\n+            // Slow path: write the address to a local buffer, the use f.pad.\n+            // Defined recursively by using the fast path to write to the\n+            // buffer.\n+\n+            // This is the largest possible size of an IPv6 address\n+            const IPV6_BUF_LEN: usize = (4 * 8) + 7;\n+            let mut buf = [0u8; IPV6_BUF_LEN];\n+            let mut buf_slice = &mut buf[..];\n+\n+            // Note: This call to write should never fail, so unwrap is okay.\n+            write!(buf_slice, \"{}\", self).unwrap();\n+            let len = IPV6_BUF_LEN - buf_slice.len();\n+\n+            // This is safe because we know exactly what can be in this buffer\n+            let buf = unsafe { crate::str::from_utf8_unchecked(&buf[..len]) };\n+            f.pad(buf)\n         }\n-        let len = IPV6_BUF_LEN - buf_slice.len();\n-        // This is safe because we know exactly what can be in this buffer\n-        let buf = unsafe { crate::str::from_utf8_unchecked(&buf[..len]) };\n-        fmt.pad(buf)\n     }\n }\n "}, {"sha": "4ee79d1bcc8396a92ef766553288cdcf894d0316", "filename": "src/test/assembly/asm/nvptx-types.rs", "status": "added", "additions": 133, "deletions": 0, "changes": 133, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fassembly%2Fasm%2Fnvptx-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fassembly%2Fasm%2Fnvptx-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fassembly%2Fasm%2Fnvptx-types.rs?ref=0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "patch": "@@ -0,0 +1,133 @@\n+// no-system-llvm\n+// assembly-output: emit-asm\n+// compile-flags: --target nvptx64-nvidia-cuda\n+// compile-flags: --crate-type cdylib\n+\n+#![feature(no_core, lang_items, rustc_attrs)]\n+#![no_core]\n+\n+#[rustc_builtin_macro]\n+macro_rules! asm {\n+    () => {};\n+}\n+#[rustc_builtin_macro]\n+macro_rules! concat {\n+    () => {};\n+}\n+\n+#[lang = \"sized\"]\n+trait Sized {}\n+#[lang = \"copy\"]\n+trait Copy {}\n+\n+type ptr = *mut u8;\n+\n+impl Copy for i8 {}\n+impl Copy for i16 {}\n+impl Copy for i32 {}\n+impl Copy for f32 {}\n+impl Copy for i64 {}\n+impl Copy for f64 {}\n+impl Copy for ptr {}\n+\n+// NVPTX does not support static variables\n+#[no_mangle]\n+fn extern_func() {}\n+\n+// CHECK-LABEL: .visible .func sym_fn()\n+// CHECK: // begin inline asm\n+// CHECK: call extern_func;\n+// CHECK: // end inline asm\n+#[no_mangle]\n+pub unsafe fn sym_fn() {\n+    asm!(\"call {};\", sym extern_func);\n+}\n+\n+macro_rules! check {\n+    ($func:ident $ty:ident $class:ident $mov:literal) => {\n+        #[no_mangle]\n+        pub unsafe fn $func(x: $ty) -> $ty {\n+            let y;\n+            asm!(concat!($mov, \" {}, {};\"), out($class) y, in($class) x);\n+            y\n+        }\n+    };\n+}\n+\n+// CHECK-LABEL: .visible .func (.param .b32 func_retval0) reg16_i8\n+// CHECK: // begin inline asm\n+// CHECK: mov.i16 %{{[a-z0-9]+}}, %{{[a-z0-9]+}};\n+// CHECK: // end inline asm\n+check!(reg16_i8 i8 reg16 \"mov.i16\");\n+\n+// CHECK-LABEL: .visible .func (.param .b32 func_retval0) reg16_i16\n+// CHECK: // begin inline asm\n+// CHECK: mov.i16 %{{[a-z0-9]+}}, %{{[a-z0-9]+}};\n+// CHECK: // end inline asm\n+check!(reg16_i16 i16 reg16 \"mov.i16\");\n+\n+// CHECK-LABEL: .visible .func (.param .b32 func_retval0) reg32_i8\n+// CHECK: // begin inline asm\n+// CHECK: mov.i32 %{{[a-z0-9]+}}, %{{[a-z0-9]+}};\n+// CHECK: // end inline asm\n+check!(reg32_i8 i8 reg32 \"mov.i32\");\n+\n+// CHECK-LABEL: .visible .func (.param .b32 func_retval0) reg32_i16\n+// CHECK: // begin inline asm\n+// CHECK: mov.i32 %{{[a-z0-9]+}}, %{{[a-z0-9]+}};\n+// CHECK: // end inline asm\n+check!(reg32_i16 i16 reg32 \"mov.i32\");\n+\n+// CHECK-LABEL: .visible .func (.param .b32 func_retval0) reg32_i32\n+// CHECK: // begin inline asm\n+// CHECK: mov.i32 %{{[a-z0-9]+}}, %{{[a-z0-9]+}};\n+// CHECK: // end inline asm\n+check!(reg32_i32 i32 reg32 \"mov.i32\");\n+\n+// CHECK-LABEL: .visible .func (.param .b32 func_retval0) reg32_f32\n+// CHECK: // begin inline asm\n+// CHECK: mov.i32 %{{[a-z0-9]+}}, %{{[a-z0-9]+}};\n+// CHECK: // end inline asm\n+check!(reg32_f32 f32 reg32 \"mov.i32\");\n+\n+// CHECK-LABEL: .visible .func (.param .b32 func_retval0) reg64_i8\n+// CHECK: // begin inline asm\n+// CHECK: mov.i64 %{{[a-z0-9]+}}, %{{[a-z0-9]+}};\n+// CHECK: // end inline asm\n+check!(reg64_i8 i8 reg64 \"mov.i64\");\n+\n+// CHECK-LABEL: .visible .func (.param .b32 func_retval0) reg64_i16\n+// CHECK: // begin inline asm\n+// CHECK: mov.i64 %{{[a-z0-9]+}}, %{{[a-z0-9]+}};\n+// CHECK: // end inline asm\n+check!(reg64_i16 i16 reg64 \"mov.i64\");\n+\n+// CHECK-LABEL: .visible .func (.param .b32 func_retval0) reg64_i32\n+// CHECK: // begin inline asm\n+// CHECK: mov.i64 %{{[a-z0-9]+}}, %{{[a-z0-9]+}};\n+// CHECK: // end inline asm\n+check!(reg64_i32 i32 reg64 \"mov.i64\");\n+\n+// CHECK-LABEL: .visible .func (.param .b32 func_retval0) reg64_f32\n+// CHECK: // begin inline asm\n+// CHECK: mov.i64 %{{[a-z0-9]+}}, %{{[a-z0-9]+}};\n+// CHECK: // end inline asm\n+check!(reg64_f32 f32 reg64 \"mov.i64\");\n+\n+// CHECK-LABEL: .visible .func (.param .b64 func_retval0) reg64_i64\n+// CHECK: // begin inline asm\n+// CHECK: mov.i64 %{{[a-z0-9]+}}, %{{[a-z0-9]+}};\n+// CHECK: // end inline asm\n+check!(reg64_i64 i64 reg64 \"mov.i64\");\n+\n+// CHECK-LABEL: .visible .func (.param .b64 func_retval0) reg64_f64\n+// CHECK: // begin inline asm\n+// CHECK: mov.i64 %{{[a-z0-9]+}}, %{{[a-z0-9]+}};\n+// CHECK: // end inline asm\n+check!(reg64_f64 f64 reg64 \"mov.i64\");\n+\n+// CHECK-LABEL: .visible .func (.param .b64 func_retval0) reg64_ptr\n+// CHECK: // begin inline asm\n+// CHECK: mov.i64 %{{[a-z0-9]+}}, %{{[a-z0-9]+}};\n+// CHECK: // end inline asm\n+check!(reg64_ptr ptr reg64 \"mov.i64\");"}, {"sha": "137cb83ccd32704f6e8b2920e80fb6067e68cd16", "filename": "src/test/ui/associated-types/cache/project-fn-ret-invariant.transmute.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-invariant.transmute.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-invariant.transmute.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fcache%2Fproject-fn-ret-invariant.transmute.stderr?ref=0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "patch": "@@ -14,16 +14,16 @@ note: ...so that the expression is assignable\n    |\n LL |    bar(foo, x)\n    |             ^\n-   = note: expected  `Type<'_>`\n-              found  `Type<'a>`\n+   = note: expected `Type<'_>`\n+              found `Type<'a>`\n    = note: but, the lifetime must be valid for the static lifetime...\n note: ...so that the expression is assignable\n   --> $DIR/project-fn-ret-invariant.rs:48:4\n    |\n LL |    bar(foo, x)\n    |    ^^^^^^^^^^^\n-   = note: expected  `Type<'static>`\n-              found  `Type<'_>`\n+   = note: expected `Type<'static>`\n+              found `Type<'_>`\n \n error: aborting due to previous error\n "}, {"sha": "b4a083636b64fc237670e8ebc8f2ffa6142b1bdb", "filename": "src/test/ui/const-generics/array-impls/alloc-traits-impls-length-32.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Fconst-generics%2Farray-impls%2Falloc-traits-impls-length-32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Fconst-generics%2Farray-impls%2Falloc-traits-impls-length-32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Farray-impls%2Falloc-traits-impls-length-32.rs?ref=0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "patch": "@@ -18,6 +18,10 @@ pub fn yes_array_into_vec<T>() -> Vec<T> {\n     [].into()\n }\n \n+pub fn yes_array_into_box<T>() -> Box<[T]> {\n+    [].into()\n+}\n+\n use std::collections::VecDeque;\n \n pub fn yes_vecdeque_partial_eq_array<A, B>() -> impl PartialEq<[B; 32]>"}, {"sha": "48cf21d489adacdbf6001245e2f10fa22fa71ee7", "filename": "src/test/ui/const-generics/array-impls/alloc-types-no-impls-length-33.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Fconst-generics%2Farray-impls%2Falloc-types-no-impls-length-33.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Fconst-generics%2Farray-impls%2Falloc-types-no-impls-length-33.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Farray-impls%2Falloc-types-no-impls-length-33.rs?ref=0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "patch": "@@ -12,6 +12,8 @@ pub fn no_box() {\n     let boxed_array = <Box<[i32; 33]>>::try_from(boxed_slice);\n     //~^ ERROR the trait bound `std::boxed::Box<[i32; 33]>: std::convert::From<std::boxed::Box<[i32]>>` is not satisfied\n     //~^^ ERROR the trait bound `std::boxed::Box<[i32; 33]>: std::convert::TryFrom<std::boxed::Box<[i32]>>` is not satisfied\n+    let boxed_slice = <Box<[i32]>>::from([0; 33]);\n+    //~^ 15:42: 15:49: arrays only have std trait implementations for lengths 0..=32 [E0277]\n }\n \n pub fn no_rc() {"}, {"sha": "5c01603ab881c116310d13f0d4384c1505d30a55", "filename": "src/test/ui/const-generics/array-impls/alloc-types-no-impls-length-33.stderr", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Fconst-generics%2Farray-impls%2Falloc-types-no-impls-length-33.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Fconst-generics%2Farray-impls%2Falloc-types-no-impls-length-33.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Farray-impls%2Falloc-types-no-impls-length-33.stderr?ref=0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "patch": "@@ -18,10 +18,23 @@ LL |     let boxed_array = <Box<[i32; 33]>>::try_from(boxed_slice);\n              <std::boxed::Box<(dyn std::error::Error + 'static)> as std::convert::From<&str>>\n              <std::boxed::Box<(dyn std::error::Error + 'static)> as std::convert::From<std::borrow::Cow<'a, str>>>\n              <std::boxed::Box<(dyn std::error::Error + 'static)> as std::convert::From<std::string::String>>\n-           and 21 others\n+           and 22 others\n    = note: required because of the requirements on the impl of `std::convert::Into<std::boxed::Box<[i32; 33]>>` for `std::boxed::Box<[i32]>`\n    = note: required because of the requirements on the impl of `std::convert::TryFrom<std::boxed::Box<[i32]>>` for `std::boxed::Box<[i32; 33]>`\n \n+error[E0277]: arrays only have std trait implementations for lengths 0..=32\n+  --> $DIR/alloc-types-no-impls-length-33.rs:15:42\n+   |\n+LL |     let boxed_slice = <Box<[i32]>>::from([0; 33]);\n+   |                                          ^^^^^^^\n+   |                                          |\n+   |                                          expected an implementor of trait `std::convert::From<[{integer}; 33]>`\n+   |                                          help: consider borrowing here: `&[0; 33]`\n+   |\n+   = note: the trait bound `[i32; 33]: std::convert::From<[{integer}; 33]>` is not satisfied\n+   = note: required because of the requirements on the impl of `std::convert::From<[i32; 33]>` for `std::boxed::Box<[i32]>`\n+   = note: required by `std::convert::From::from`\n+\n error[E0277]: the trait bound `std::boxed::Box<[i32; 33]>: std::convert::TryFrom<std::boxed::Box<[i32]>>` is not satisfied\n   --> $DIR/alloc-types-no-impls-length-33.rs:12:23\n    |\n@@ -32,7 +45,7 @@ LL |     let boxed_array = <Box<[i32; 33]>>::try_from(boxed_slice);\n              <std::boxed::Box<[T; N]> as std::convert::TryFrom<std::boxed::Box<[T]>>>\n \n error[E0277]: the trait bound `std::rc::Rc<[i32; 33]>: std::convert::From<std::rc::Rc<[i32]>>` is not satisfied\n-  --> $DIR/alloc-types-no-impls-length-33.rs:19:23\n+  --> $DIR/alloc-types-no-impls-length-33.rs:21:23\n    |\n LL |     let boxed_array = <Rc<[i32; 33]>>::try_from(boxed_slice);\n    |                       ^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::convert::From<std::rc::Rc<[i32]>>` is not implemented for `std::rc::Rc<[i32; 33]>`\n@@ -47,7 +60,7 @@ LL |     let boxed_array = <Rc<[i32; 33]>>::try_from(boxed_slice);\n    = note: required because of the requirements on the impl of `std::convert::TryFrom<std::rc::Rc<[i32]>>` for `std::rc::Rc<[i32; 33]>`\n \n error[E0277]: the trait bound `std::rc::Rc<[i32; 33]>: std::convert::TryFrom<std::rc::Rc<[i32]>>` is not satisfied\n-  --> $DIR/alloc-types-no-impls-length-33.rs:19:23\n+  --> $DIR/alloc-types-no-impls-length-33.rs:21:23\n    |\n LL |     let boxed_array = <Rc<[i32; 33]>>::try_from(boxed_slice);\n    |                       ^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::convert::TryFrom<std::rc::Rc<[i32]>>` is not implemented for `std::rc::Rc<[i32; 33]>`\n@@ -56,7 +69,7 @@ LL |     let boxed_array = <Rc<[i32; 33]>>::try_from(boxed_slice);\n              <std::rc::Rc<[T; N]> as std::convert::TryFrom<std::rc::Rc<[T]>>>\n \n error[E0277]: the trait bound `std::sync::Arc<[i32; 33]>: std::convert::From<std::sync::Arc<[i32]>>` is not satisfied\n-  --> $DIR/alloc-types-no-impls-length-33.rs:26:23\n+  --> $DIR/alloc-types-no-impls-length-33.rs:28:23\n    |\n LL |     let boxed_array = <Arc<[i32; 33]>>::try_from(boxed_slice);\n    |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::convert::From<std::sync::Arc<[i32]>>` is not implemented for `std::sync::Arc<[i32; 33]>`\n@@ -71,14 +84,14 @@ LL |     let boxed_array = <Arc<[i32; 33]>>::try_from(boxed_slice);\n    = note: required because of the requirements on the impl of `std::convert::TryFrom<std::sync::Arc<[i32]>>` for `std::sync::Arc<[i32; 33]>`\n \n error[E0277]: the trait bound `std::sync::Arc<[i32; 33]>: std::convert::TryFrom<std::sync::Arc<[i32]>>` is not satisfied\n-  --> $DIR/alloc-types-no-impls-length-33.rs:26:23\n+  --> $DIR/alloc-types-no-impls-length-33.rs:28:23\n    |\n LL |     let boxed_array = <Arc<[i32; 33]>>::try_from(boxed_slice);\n    |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^ the trait `std::convert::TryFrom<std::sync::Arc<[i32]>>` is not implemented for `std::sync::Arc<[i32; 33]>`\n    |\n    = help: the following implementations were found:\n              <std::sync::Arc<[T; N]> as std::convert::TryFrom<std::sync::Arc<[T]>>>\n \n-error: aborting due to 7 previous errors\n+error: aborting due to 8 previous errors\n \n For more information about this error, try `rustc --explain E0277`."}, {"sha": "65fc49c0b27a6b44a8bb1c765c23b3aca130e1dd", "filename": "src/test/ui/consts/miri_unleashed/ptr_arith.rs", "status": "modified", "additions": 1, "deletions": 9, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fptr_arith.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fptr_arith.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fptr_arith.rs?ref=0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "patch": "@@ -2,8 +2,7 @@\n #![feature(core_intrinsics)]\n #![allow(const_err)]\n \n-// A test demonstrating that we prevent doing even trivial\n-// pointer arithmetic or comparison during CTFE.\n+// During CTFE, we prevent pointer comparison and pointer-to-int casts.\n \n static CMP: () = {\n     let x = &0 as *const _;\n@@ -19,11 +18,4 @@ static INT_PTR_ARITH: () = unsafe {\n     //~| NOTE pointer-to-integer cast\n };\n \n-static PTR_ARITH: () = unsafe {\n-    let x = &0 as *const _;\n-    let _v = core::intrinsics::offset(x, 0);\n-    //~^ ERROR could not evaluate static initializer\n-    //~| NOTE calling intrinsic `offset`\n-};\n-\n fn main() {}"}, {"sha": "805ba9c6b0307f724a1d31e746a3e780a7c27054", "filename": "src/test/ui/consts/miri_unleashed/ptr_arith.stderr", "status": "modified", "additions": 5, "deletions": 16, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fptr_arith.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fptr_arith.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmiri_unleashed%2Fptr_arith.stderr?ref=0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "patch": "@@ -1,39 +1,28 @@\n error[E0080]: could not evaluate static initializer\n-  --> $DIR/ptr_arith.rs:10:14\n+  --> $DIR/ptr_arith.rs:9:14\n    |\n LL |     let _v = x == x;\n    |              ^^^^^^ \"pointer arithmetic or comparison\" needs an rfc before being allowed inside constants\n \n error[E0080]: could not evaluate static initializer\n-  --> $DIR/ptr_arith.rs:17:14\n+  --> $DIR/ptr_arith.rs:16:14\n    |\n LL |     let _v = x + 0;\n    |              ^^^^^ \"pointer-to-integer cast\" needs an rfc before being allowed inside constants\n \n-error[E0080]: could not evaluate static initializer\n-  --> $DIR/ptr_arith.rs:24:14\n-   |\n-LL |     let _v = core::intrinsics::offset(x, 0);\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ \"calling intrinsic `offset`\" needs an rfc before being allowed inside constants\n-\n warning: skipping const checks\n    |\n help: skipping check for `const_compare_raw_pointers` feature\n-  --> $DIR/ptr_arith.rs:10:14\n+  --> $DIR/ptr_arith.rs:9:14\n    |\n LL |     let _v = x == x;\n    |              ^^^^^^\n help: skipping check that does not even have a feature gate\n-  --> $DIR/ptr_arith.rs:16:20\n+  --> $DIR/ptr_arith.rs:15:20\n    |\n LL |     let x: usize = std::mem::transmute(&0);\n    |                    ^^^^^^^^^^^^^^^^^^^^^^^\n-help: skipping check that does not even have a feature gate\n-  --> $DIR/ptr_arith.rs:24:14\n-   |\n-LL |     let _v = core::intrinsics::offset(x, 0);\n-   |              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n-error: aborting due to 3 previous errors; 1 warning emitted\n+error: aborting due to 2 previous errors; 1 warning emitted\n \n For more information about this error, try `rustc --explain E0080`."}, {"sha": "f64242d568e318a8b43cfb945030877e74788ae6", "filename": "src/test/ui/consts/offset.rs", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Fconsts%2Foffset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Fconsts%2Foffset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Foffset.rs?ref=0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "patch": "@@ -0,0 +1,115 @@\n+// run-pass\n+#![feature(const_ptr_offset)]\n+#![feature(const_ptr_offset_from)]\n+#![feature(ptr_offset_from)]\n+use std::ptr;\n+\n+#[repr(C)]\n+struct Struct {\n+    a: u32,\n+    b: u32,\n+    c: u32,\n+}\n+static S: Struct = Struct { a: 0, b: 0, c: 0 };\n+\n+// For these tests we use offset_from to check that two pointers are equal.\n+// Rust doesn't currently support comparing pointers in const fn.\n+\n+static OFFSET_NO_CHANGE: bool = unsafe {\n+    let p1 = &S.b as *const u32;\n+    let p2 = p1.offset(2).offset(-2);\n+    p1.offset_from(p2) == 0\n+};\n+static OFFSET_MIDDLE: bool = unsafe {\n+    let p1 = (&S.a as *const u32).offset(1);\n+    let p2 = (&S.c as *const u32).offset(-1);\n+    p1.offset_from(p2) == 0\n+};\n+// Pointing to the end of the allocation is OK\n+static OFFSET_END: bool = unsafe {\n+    let p1 = (&S.a as *const u32).offset(3);\n+    let p2 = (&S.c as *const u32).offset(1);\n+    p1.offset_from(p2) == 0\n+};\n+// Casting though a differently sized type is OK\n+static OFFSET_U8_PTR: bool = unsafe {\n+    let p1 = (&S.a as *const u32 as *const u8).offset(5);\n+    let p2 = (&S.c as *const u32 as *const u8).offset(-3);\n+    p1.offset_from(p2) == 0\n+};\n+// Any offset with a ZST does nothing\n+const OFFSET_ZST: bool = unsafe {\n+    let pz = &() as *const ();\n+    // offset_from can't work with ZSTs, so cast to u8 ptr\n+    let p1 = pz.offset(5) as *const u8;\n+    let p2 = pz.offset(isize::MIN) as *const u8;\n+    p1.offset_from(p2) == 0\n+};\n+const OFFSET_ZERO: bool = unsafe {\n+    let p = [0u8; 0].as_ptr();\n+    p.offset(0).offset_from(p) == 0\n+};\n+const OFFSET_ONE: bool = unsafe {\n+    let p = &42u32 as *const u32;\n+    p.offset(1).offset_from(p) == 1\n+};\n+const OFFSET_DANGLING: bool = unsafe {\n+    let p = ptr::NonNull::<u8>::dangling().as_ptr();\n+    p.offset(0).offset_from(p) == 0\n+};\n+const OFFSET_UNALIGNED: bool = unsafe {\n+    let arr = [0u8; 32];\n+    let p1 = arr.as_ptr();\n+    let p2 = (p1.offset(2) as *const u32).offset(1);\n+    (p2 as *const u8).offset_from(p1) == 6\n+};\n+\n+const WRAP_OFFSET_NO_CHANGE: bool = unsafe {\n+    let p1 = &42u32 as *const u32;\n+    let p2 = p1.wrapping_offset(1000).wrapping_offset(-1000);\n+    let p3 = p1.wrapping_offset(-1000).wrapping_offset(1000);\n+    (p1.offset_from(p2) == 0) & (p1.offset_from(p3) == 0)\n+};\n+const WRAP_ADDRESS_SPACE: bool = unsafe {\n+    let p1 = &42u8 as *const u8;\n+    let p2 = p1.wrapping_offset(isize::MIN).wrapping_offset(isize::MIN);\n+    p1.offset_from(p2) == 0\n+};\n+// Wrap on the count*size_of::<T>() calculation.\n+const WRAP_SIZE_OF: bool = unsafe {\n+    // Make sure that if p1 moves backwards, we are still in range\n+    let arr = [0u32; 2];\n+    let p = &arr[1] as *const u32;\n+    // With wrapping arithmetic, isize::MAX * 4 == -4\n+    let wrapped = p.wrapping_offset(isize::MAX);\n+    let backward = p.wrapping_offset(-1);\n+    wrapped.offset_from(backward) == 0\n+};\n+const WRAP_INTEGER_POINTER: bool = unsafe {\n+    let p1 = (0x42 as *const u32).wrapping_offset(4);\n+    let p2 = 0x52 as *const u32;\n+    p1.offset_from(p2) == 0\n+};\n+const WRAP_NULL: bool = unsafe {\n+    let p1 = ptr::null::<u32>().wrapping_offset(1);\n+    let p2 = 0x4 as *const u32;\n+    p1.offset_from(p2) == 0\n+};\n+\n+fn main() {\n+    assert!(OFFSET_NO_CHANGE);\n+    assert!(OFFSET_MIDDLE);\n+    assert!(OFFSET_END);\n+    assert!(OFFSET_U8_PTR);\n+    assert!(OFFSET_ZST);\n+    assert!(OFFSET_ZERO);\n+    assert!(OFFSET_ONE);\n+    assert!(OFFSET_DANGLING);\n+    assert!(OFFSET_UNALIGNED);\n+\n+    assert!(WRAP_OFFSET_NO_CHANGE);\n+    assert!(WRAP_ADDRESS_SPACE);\n+    assert!(WRAP_SIZE_OF);\n+    assert!(WRAP_INTEGER_POINTER);\n+    assert!(WRAP_NULL);\n+}"}, {"sha": "4f943ed9ad194867f4d96894b0a5d762fb0bd602", "filename": "src/test/ui/consts/offset_ub.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Fconsts%2Foffset_ub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Fconsts%2Foffset_ub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Foffset_ub.rs?ref=0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "patch": "@@ -0,0 +1,25 @@\n+// ignore-tidy-linelength\n+#![feature(const_ptr_offset)]\n+use std::ptr;\n+\n+// normalize-stderr-test \"alloc\\d+\" -> \"allocN\"\n+\n+pub const BEFORE_START: *const u8 = unsafe { (&0u8 as *const u8).offset(-1) }; //~NOTE\n+pub const AFTER_END: *const u8 = unsafe { (&0u8 as *const u8).offset(2) }; //~NOTE\n+pub const AFTER_ARRAY: *const u8 = unsafe { [0u8; 100].as_ptr().offset(101) }; //~NOTE\n+\n+pub const OVERFLOW: *const u16 = unsafe { [0u16; 1].as_ptr().offset(isize::MAX) }; //~NOTE\n+pub const UNDERFLOW: *const u16 = unsafe { [0u16; 1].as_ptr().offset(isize::MIN) }; //~NOTE\n+pub const OVERFLOW_ADDRESS_SPACE: *const u8 = unsafe { (usize::MAX as *const u8).offset(2) }; //~NOTE\n+pub const UNDERFLOW_ADDRESS_SPACE: *const u8 = unsafe { (1 as *const u8).offset(-2) }; //~NOTE\n+\n+pub const ZERO_SIZED_ALLOC: *const u8 = unsafe { [0u8; 0].as_ptr().offset(1) }; //~NOTE\n+pub const DANGLING: *const u8 = unsafe { ptr::NonNull::<u8>::dangling().as_ptr().offset(4) }; //~NOTE\n+\n+// Right now, a zero offset from null is UB\n+pub const NULL_OFFSET_ZERO: *const u8 = unsafe { ptr::null::<u8>().offset(0) }; //~NOTE\n+\n+// Make sure that we don't panic when computing abs(offset*size_of::<T>())\n+pub const UNDERFLOW_ABS: *const u8 = unsafe { (usize::MAX as *const u8).offset(isize::MIN) }; //~NOTE\n+\n+fn main() {}"}, {"sha": "0ab81cc0c5b31bd5af05f6e90f62a2d65b34a864", "filename": "src/test/ui/consts/offset_ub.stderr", "status": "added", "additions": 169, "deletions": 0, "changes": 169, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Fconsts%2Foffset_ub.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Fconsts%2Foffset_ub.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Foffset_ub.stderr?ref=0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "patch": "@@ -0,0 +1,169 @@\n+error: any use of this value will cause an error\n+  --> $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n+   |\n+LL |         intrinsics::offset(self, count)\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |         |\n+   |         overflowing in-bounds pointer arithmetic\n+   |         inside `std::ptr::const_ptr::<impl *const u8>::offset` at $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n+   |         inside `BEFORE_START` at $DIR/offset_ub.rs:7:46\n+   | \n+  ::: $DIR/offset_ub.rs:7:1\n+   |\n+LL | pub const BEFORE_START: *const u8 = unsafe { (&0u8 as *const u8).offset(-1) };\n+   | ------------------------------------------------------------------------------\n+   |\n+   = note: `#[deny(const_err)]` on by default\n+\n+error: any use of this value will cause an error\n+  --> $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n+   |\n+LL |         intrinsics::offset(self, count)\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |         |\n+   |         inbounds test failed: pointer must be in-bounds at offset 2, but is outside bounds of allocN which has size 1\n+   |         inside `std::ptr::const_ptr::<impl *const u8>::offset` at $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n+   |         inside `AFTER_END` at $DIR/offset_ub.rs:8:43\n+   | \n+  ::: $DIR/offset_ub.rs:8:1\n+   |\n+LL | pub const AFTER_END: *const u8 = unsafe { (&0u8 as *const u8).offset(2) };\n+   | --------------------------------------------------------------------------\n+\n+error: any use of this value will cause an error\n+  --> $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n+   |\n+LL |         intrinsics::offset(self, count)\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |         |\n+   |         inbounds test failed: pointer must be in-bounds at offset 101, but is outside bounds of allocN which has size 100\n+   |         inside `std::ptr::const_ptr::<impl *const u8>::offset` at $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n+   |         inside `AFTER_ARRAY` at $DIR/offset_ub.rs:9:45\n+   | \n+  ::: $DIR/offset_ub.rs:9:1\n+   |\n+LL | pub const AFTER_ARRAY: *const u8 = unsafe { [0u8; 100].as_ptr().offset(101) };\n+   | ------------------------------------------------------------------------------\n+\n+error: any use of this value will cause an error\n+  --> $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n+   |\n+LL |         intrinsics::offset(self, count)\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |         |\n+   |         overflowing in-bounds pointer arithmetic\n+   |         inside `std::ptr::const_ptr::<impl *const u16>::offset` at $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n+   |         inside `OVERFLOW` at $DIR/offset_ub.rs:11:43\n+   | \n+  ::: $DIR/offset_ub.rs:11:1\n+   |\n+LL | pub const OVERFLOW: *const u16 = unsafe { [0u16; 1].as_ptr().offset(isize::MAX) };\n+   | ----------------------------------------------------------------------------------\n+\n+error: any use of this value will cause an error\n+  --> $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n+   |\n+LL |         intrinsics::offset(self, count)\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |         |\n+   |         overflowing in-bounds pointer arithmetic\n+   |         inside `std::ptr::const_ptr::<impl *const u16>::offset` at $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n+   |         inside `UNDERFLOW` at $DIR/offset_ub.rs:12:44\n+   | \n+  ::: $DIR/offset_ub.rs:12:1\n+   |\n+LL | pub const UNDERFLOW: *const u16 = unsafe { [0u16; 1].as_ptr().offset(isize::MIN) };\n+   | -----------------------------------------------------------------------------------\n+\n+error: any use of this value will cause an error\n+  --> $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n+   |\n+LL |         intrinsics::offset(self, count)\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |         |\n+   |         overflowing in-bounds pointer arithmetic\n+   |         inside `std::ptr::const_ptr::<impl *const u8>::offset` at $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n+   |         inside `OVERFLOW_ADDRESS_SPACE` at $DIR/offset_ub.rs:13:56\n+   | \n+  ::: $DIR/offset_ub.rs:13:1\n+   |\n+LL | pub const OVERFLOW_ADDRESS_SPACE: *const u8 = unsafe { (usize::MAX as *const u8).offset(2) };\n+   | ---------------------------------------------------------------------------------------------\n+\n+error: any use of this value will cause an error\n+  --> $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n+   |\n+LL |         intrinsics::offset(self, count)\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |         |\n+   |         overflowing in-bounds pointer arithmetic\n+   |         inside `std::ptr::const_ptr::<impl *const u8>::offset` at $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n+   |         inside `UNDERFLOW_ADDRESS_SPACE` at $DIR/offset_ub.rs:14:57\n+   | \n+  ::: $DIR/offset_ub.rs:14:1\n+   |\n+LL | pub const UNDERFLOW_ADDRESS_SPACE: *const u8 = unsafe { (1 as *const u8).offset(-2) };\n+   | --------------------------------------------------------------------------------------\n+\n+error: any use of this value will cause an error\n+  --> $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n+   |\n+LL |         intrinsics::offset(self, count)\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |         |\n+   |         inbounds test failed: pointer must be in-bounds at offset 1, but is outside bounds of allocN which has size 0\n+   |         inside `std::ptr::const_ptr::<impl *const u8>::offset` at $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n+   |         inside `ZERO_SIZED_ALLOC` at $DIR/offset_ub.rs:16:50\n+   | \n+  ::: $DIR/offset_ub.rs:16:1\n+   |\n+LL | pub const ZERO_SIZED_ALLOC: *const u8 = unsafe { [0u8; 0].as_ptr().offset(1) };\n+   | -------------------------------------------------------------------------------\n+\n+error: any use of this value will cause an error\n+  --> $SRC_DIR/libcore/ptr/mut_ptr.rs:LL:COL\n+   |\n+LL |         intrinsics::offset(self, count) as *mut T\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |         |\n+   |         unable to turn bytes into a pointer\n+   |         inside `std::ptr::mut_ptr::<impl *mut u8>::offset` at $SRC_DIR/libcore/ptr/mut_ptr.rs:LL:COL\n+   |         inside `DANGLING` at $DIR/offset_ub.rs:17:42\n+   | \n+  ::: $DIR/offset_ub.rs:17:1\n+   |\n+LL | pub const DANGLING: *const u8 = unsafe { ptr::NonNull::<u8>::dangling().as_ptr().offset(4) };\n+   | ---------------------------------------------------------------------------------------------\n+\n+error: any use of this value will cause an error\n+  --> $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n+   |\n+LL |         intrinsics::offset(self, count)\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |         |\n+   |         inbounds test failed: 0x0 is not a valid pointer\n+   |         inside `std::ptr::const_ptr::<impl *const u8>::offset` at $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n+   |         inside `NULL_OFFSET_ZERO` at $DIR/offset_ub.rs:20:50\n+   | \n+  ::: $DIR/offset_ub.rs:20:1\n+   |\n+LL | pub const NULL_OFFSET_ZERO: *const u8 = unsafe { ptr::null::<u8>().offset(0) };\n+   | -------------------------------------------------------------------------------\n+\n+error: any use of this value will cause an error\n+  --> $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n+   |\n+LL |         intrinsics::offset(self, count)\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |         |\n+   |         unable to turn bytes into a pointer\n+   |         inside `std::ptr::const_ptr::<impl *const u8>::offset` at $SRC_DIR/libcore/ptr/const_ptr.rs:LL:COL\n+   |         inside `UNDERFLOW_ABS` at $DIR/offset_ub.rs:23:47\n+   | \n+  ::: $DIR/offset_ub.rs:23:1\n+   |\n+LL | pub const UNDERFLOW_ABS: *const u8 = unsafe { (usize::MAX as *const u8).offset(isize::MIN) };\n+   | ---------------------------------------------------------------------------------------------\n+\n+error: aborting due to 11 previous errors\n+"}, {"sha": "9ba5bc330ea936f9831f4730b2953e6b67b9e4b5", "filename": "src/test/ui/error-codes/E0490.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Ferror-codes%2FE0490.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Ferror-codes%2FE0490.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0490.stderr?ref=0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "patch": "@@ -58,8 +58,8 @@ note: ...so that the expression is assignable\n    |\n LL |     let x: &'a _ = &y;\n    |                    ^^\n-   = note: expected  `&'a &()`\n-              found  `&'a &'b ()`\n+   = note: expected `&'a &()`\n+              found `&'a &'b ()`\n note: but, the lifetime must be valid for the lifetime `'a` as defined on the function body at 1:6...\n   --> $DIR/E0490.rs:1:6\n    |"}, {"sha": "61e512a12a18d117e3a05c326fe3e20acf3a1853", "filename": "src/test/ui/feature-gates/feature-gate-unsafe_block_in_unsafe_fn.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unsafe_block_in_unsafe_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unsafe_block_in_unsafe_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unsafe_block_in_unsafe_fn.rs?ref=0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "patch": "@@ -0,0 +1,6 @@\n+#![deny(unsafe_op_in_unsafe_fn)]\n+//~^ ERROR the `unsafe_op_in_unsafe_fn` lint is unstable\n+//~| ERROR the `unsafe_op_in_unsafe_fn` lint is unstable\n+//~| ERROR the `unsafe_op_in_unsafe_fn` lint is unstable\n+\n+fn main() {}"}, {"sha": "c5cad4a98d9ca29172af13b5a6a539831f1e010e", "filename": "src/test/ui/feature-gates/feature-gate-unsafe_block_in_unsafe_fn.stderr", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unsafe_block_in_unsafe_fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unsafe_block_in_unsafe_fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-unsafe_block_in_unsafe_fn.stderr?ref=0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "patch": "@@ -0,0 +1,30 @@\n+error[E0658]: the `unsafe_op_in_unsafe_fn` lint is unstable\n+  --> $DIR/feature-gate-unsafe_block_in_unsafe_fn.rs:1:1\n+   |\n+LL | #![deny(unsafe_op_in_unsafe_fn)]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #71668 <https://github.com/rust-lang/rust/issues/71668> for more information\n+   = help: add `#![feature(unsafe_block_in_unsafe_fn)]` to the crate attributes to enable\n+\n+error[E0658]: the `unsafe_op_in_unsafe_fn` lint is unstable\n+  --> $DIR/feature-gate-unsafe_block_in_unsafe_fn.rs:1:1\n+   |\n+LL | #![deny(unsafe_op_in_unsafe_fn)]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #71668 <https://github.com/rust-lang/rust/issues/71668> for more information\n+   = help: add `#![feature(unsafe_block_in_unsafe_fn)]` to the crate attributes to enable\n+\n+error[E0658]: the `unsafe_op_in_unsafe_fn` lint is unstable\n+  --> $DIR/feature-gate-unsafe_block_in_unsafe_fn.rs:1:1\n+   |\n+LL | #![deny(unsafe_op_in_unsafe_fn)]\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #71668 <https://github.com/rust-lang/rust/issues/71668> for more information\n+   = help: add `#![feature(unsafe_block_in_unsafe_fn)]` to the crate attributes to enable\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "268008c211129e704f6a5412c127a1aa1a9bf573", "filename": "src/test/ui/impl-header-lifetime-elision/dyn-trait.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Fimpl-header-lifetime-elision%2Fdyn-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Fimpl-header-lifetime-elision%2Fdyn-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-header-lifetime-elision%2Fdyn-trait.stderr?ref=0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "patch": "@@ -14,16 +14,16 @@ note: ...so that the expression is assignable\n    |\n LL |     static_val(x);\n    |                ^\n-   = note: expected  `std::boxed::Box<dyn std::fmt::Debug>`\n-              found  `std::boxed::Box<(dyn std::fmt::Debug + 'a)>`\n+   = note: expected `std::boxed::Box<dyn std::fmt::Debug>`\n+              found `std::boxed::Box<(dyn std::fmt::Debug + 'a)>`\n    = note: but, the lifetime must be valid for the static lifetime...\n note: ...so that the types are compatible\n   --> $DIR/dyn-trait.rs:20:5\n    |\n LL |     static_val(x);\n    |     ^^^^^^^^^^\n-   = note: expected  `StaticTrait`\n-              found  `StaticTrait`\n+   = note: expected `StaticTrait`\n+              found `StaticTrait`\n \n error: aborting due to previous error\n "}, {"sha": "b93d98ca39f4716f7ed978f6d64d5d4e02565321", "filename": "src/test/ui/in-band-lifetimes/mismatched_trait_impl-2.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Fin-band-lifetimes%2Fmismatched_trait_impl-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Fin-band-lifetimes%2Fmismatched_trait_impl-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fin-band-lifetimes%2Fmismatched_trait_impl-2.stderr?ref=0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "patch": "@@ -2,15 +2,17 @@ error: `impl` item signature doesn't match `trait` item signature\n   --> $DIR/mismatched_trait_impl-2.rs:8:5\n    |\n LL |     fn deref(&self) -> &dyn Trait {\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ found fn(&Struct) -> &dyn Trait\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ found `fn(&Struct) -> &dyn Trait`\n    | \n   ::: $SRC_DIR/libcore/ops/deref.rs:LL:COL\n    |\n LL |     fn deref(&self) -> &Self::Target;\n-   |     --------------------------------- expected fn(&Struct) -> &(dyn Trait + 'static)\n+   |     --------------------------------- expected `fn(&Struct) -> &(dyn Trait + 'static)`\n    |\n    = note: expected `fn(&Struct) -> &(dyn Trait + 'static)`\n               found `fn(&Struct) -> &dyn Trait`\n+   = help: the lifetime requirements from the `impl` do not correspond to the requirements in the `trait`\n+   = help: verify the lifetime relationships in the `trait` and `impl` between the `self` argument, the other inputs and its output\n \n error: aborting due to previous error\n "}, {"sha": "149c2aeb958c0712ce8f8c4d10ca7b8a3fc16e0e", "filename": "src/test/ui/in-band-lifetimes/mismatched_trait_impl.nll.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Fin-band-lifetimes%2Fmismatched_trait_impl.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Fin-band-lifetimes%2Fmismatched_trait_impl.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fin-band-lifetimes%2Fmismatched_trait_impl.nll.stderr?ref=0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "patch": "@@ -2,13 +2,15 @@ error: `impl` item signature doesn't match `trait` item signature\n   --> $DIR/mismatched_trait_impl.rs:9:5\n    |\n LL |     fn foo(&self, x: &'a u32, y: &u32) -> &'a u32;\n-   |     ---------------------------------------------- expected fn(&i32, &'a u32, &u32) -> &'a u32\n+   |     ---------------------------------------------- expected `fn(&i32, &'a u32, &u32) -> &'a u32`\n ...\n LL |     fn foo(&self, x: &u32, y: &'a u32) -> &'a u32 {\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ found fn(&i32, &u32, &u32) -> &u32\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ found `fn(&i32, &u32, &u32) -> &u32`\n    |\n    = note: expected `fn(&i32, &'a u32, &u32) -> &'a u32`\n               found `fn(&i32, &u32, &u32) -> &u32`\n+   = help: the lifetime requirements from the `impl` do not correspond to the requirements in the `trait`\n+   = help: verify the lifetime relationships in the `trait` and `impl` between the `self` argument, the other inputs and its output\n \n error: aborting due to previous error\n "}, {"sha": "9a0bd827850cf5f0c59e307cb4e4c5cc2c47135f", "filename": "src/test/ui/in-band-lifetimes/mismatched_trait_impl.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Fin-band-lifetimes%2Fmismatched_trait_impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Fin-band-lifetimes%2Fmismatched_trait_impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fin-band-lifetimes%2Fmismatched_trait_impl.stderr?ref=0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "patch": "@@ -2,13 +2,15 @@ error: `impl` item signature doesn't match `trait` item signature\n   --> $DIR/mismatched_trait_impl.rs:9:5\n    |\n LL |     fn foo(&self, x: &'a u32, y: &u32) -> &'a u32;\n-   |     ---------------------------------------------- expected fn(&i32, &'a u32, &u32) -> &'a u32\n+   |     ---------------------------------------------- expected `fn(&i32, &'a u32, &u32) -> &'a u32`\n ...\n LL |     fn foo(&self, x: &u32, y: &'a u32) -> &'a u32 {\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ found fn(&i32, &u32, &u32) -> &u32\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ found `fn(&i32, &u32, &u32) -> &u32`\n    |\n    = note: expected `fn(&i32, &'a u32, &u32) -> &'a u32`\n               found `fn(&i32, &u32, &u32) -> &u32`\n+   = help: the lifetime requirements from the `impl` do not correspond to the requirements in the `trait`\n+   = help: verify the lifetime relationships in the `trait` and `impl` between the `self` argument, the other inputs and its output\n \n error[E0623]: lifetime mismatch\n   --> $DIR/mismatched_trait_impl.rs:10:9"}, {"sha": "4f658330758141f7b842dd7fd1f9c8037267c4b1", "filename": "src/test/ui/issues/issue-16683.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Fissues%2Fissue-16683.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Fissues%2Fissue-16683.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-16683.stderr?ref=0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "patch": "@@ -26,8 +26,8 @@ note: ...so that the types are compatible\n    |\n LL |         self.a();\n    |              ^\n-   = note: expected  `&'a Self`\n-              found  `&Self`\n+   = note: expected `&'a Self`\n+              found `&Self`\n \n error: aborting due to previous error\n "}, {"sha": "31788cfa61c4cf262ebb3f3628363134e65bb503", "filename": "src/test/ui/issues/issue-17758.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Fissues%2Fissue-17758.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Fissues%2Fissue-17758.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-17758.stderr?ref=0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "patch": "@@ -27,8 +27,8 @@ note: ...so that the types are compatible\n    |\n LL |         self.foo();\n    |              ^^^\n-   = note: expected  `&'a Self`\n-              found  `&Self`\n+   = note: expected `&'a Self`\n+              found `&Self`\n \n error: aborting due to previous error\n "}, {"sha": "e7c1dcc5d698c9e35da163ee206b903601665fd2", "filename": "src/test/ui/issues/issue-20831-debruijn.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Fissues%2Fissue-20831-debruijn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Fissues%2Fissue-20831-debruijn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-20831-debruijn.stderr?ref=0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "patch": "@@ -87,8 +87,8 @@ note: ...so that the types are compatible\n    |\n LL |     fn subscribe(&mut self, t : Box<dyn Subscriber<Input=<Self as Publisher>::Output> + 'a>) {\n    |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: expected  `Publisher<'_>`\n-              found  `Publisher<'_>`\n+   = note: expected `Publisher<'_>`\n+              found `Publisher<'_>`\n \n error[E0495]: cannot infer an appropriate lifetime for lifetime parameter `'a` due to conflicting requirements\n   --> $DIR/issue-20831-debruijn.rs:28:33\n@@ -117,8 +117,8 @@ note: ...so that the types are compatible\n    |\n LL |     fn subscribe(&mut self, t : Box<dyn Subscriber<Input=<Self as Publisher>::Output> + 'a>) {\n    |                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: expected  `Publisher<'_>`\n-              found  `Publisher<'_>`\n+   = note: expected `Publisher<'_>`\n+              found `Publisher<'_>`\n \n error: aborting due to 4 previous errors\n "}, {"sha": "7463af9332a7627c3588c7fc62a163f60e920c2a", "filename": "src/test/ui/issues/issue-52213.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Fissues%2Fissue-52213.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Fissues%2Fissue-52213.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-52213.stderr?ref=0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "patch": "@@ -14,8 +14,8 @@ note: ...so that the types are compatible\n    |\n LL |     match (&t,) {\n    |           ^^^^^\n-   = note: expected  `(&&(T,),)`\n-              found  `(&&'a (T,),)`\n+   = note: expected `(&&(T,),)`\n+              found `(&&'a (T,),)`\n note: but, the lifetime must be valid for the lifetime `'b` as defined on the function body at 1:27...\n   --> $DIR/issue-52213.rs:1:27\n    |"}, {"sha": "6bfb7af54446df8f04f79caba90c281307028c15", "filename": "src/test/ui/issues/issue-55796.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Fissues%2Fissue-55796.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Fissues%2Fissue-55796.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-55796.stderr?ref=0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "patch": "@@ -20,8 +20,8 @@ note: ...so that the expression is assignable\n    |\n LL |         Box::new(self.out_edges(u).map(|e| e.target()))\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: expected  `std::boxed::Box<(dyn std::iter::Iterator<Item = <Self as Graph<'a>>::Node> + 'static)>`\n-              found  `std::boxed::Box<dyn std::iter::Iterator<Item = <Self as Graph<'a>>::Node>>`\n+   = note: expected `std::boxed::Box<(dyn std::iter::Iterator<Item = <Self as Graph<'a>>::Node> + 'static)>`\n+              found `std::boxed::Box<dyn std::iter::Iterator<Item = <Self as Graph<'a>>::Node>>`\n \n error[E0495]: cannot infer an appropriate lifetime due to conflicting requirements\n   --> $DIR/issue-55796.rs:21:9\n@@ -45,8 +45,8 @@ note: ...so that the expression is assignable\n    |\n LL |         Box::new(self.in_edges(u).map(|e| e.target()))\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: expected  `std::boxed::Box<(dyn std::iter::Iterator<Item = <Self as Graph<'a>>::Node> + 'static)>`\n-              found  `std::boxed::Box<dyn std::iter::Iterator<Item = <Self as Graph<'a>>::Node>>`\n+   = note: expected `std::boxed::Box<(dyn std::iter::Iterator<Item = <Self as Graph<'a>>::Node> + 'static)>`\n+              found `std::boxed::Box<dyn std::iter::Iterator<Item = <Self as Graph<'a>>::Node>>`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "060e6954403c0f3a8f0ddf8410bce301d7e3f564", "filename": "src/test/ui/lifetimes/lifetime-mismatch-between-trait-and-impl.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Flifetimes%2Flifetime-mismatch-between-trait-and-impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Flifetimes%2Flifetime-mismatch-between-trait-and-impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flifetimes%2Flifetime-mismatch-between-trait-and-impl.stderr?ref=0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "patch": "@@ -2,13 +2,15 @@ error: `impl` item signature doesn't match `trait` item signature\n   --> $DIR/lifetime-mismatch-between-trait-and-impl.rs:6:5\n    |\n LL |     fn foo<'a>(x: &i32, y: &'a i32) -> &'a i32;\n-   |     ------------------------------------------- expected fn(&i32, &'a i32) -> &'a i32\n+   |     ------------------------------------------- expected `fn(&i32, &'a i32) -> &'a i32`\n ...\n LL |     fn foo<'a>(x: &'a i32, y: &'a i32) -> &'a i32 {\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ found fn(&i32, &i32) -> &i32\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ found `fn(&i32, &i32) -> &i32`\n    |\n    = note: expected `fn(&i32, &'a i32) -> &'a i32`\n               found `fn(&i32, &i32) -> &i32`\n+   = help: the lifetime requirements from the `impl` do not correspond to the requirements in the `trait`\n+   = help: verify the lifetime relationships in the `trait` and `impl` between the `self` argument, the other inputs and its output\n \n error: aborting due to previous error\n "}, {"sha": "ba8d91b8455bfab7a77a05b319372f28cc83a3ed", "filename": "src/test/ui/nll/issue-55394.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Fnll%2Fissue-55394.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Fnll%2Fissue-55394.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fissue-55394.stderr?ref=0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "patch": "@@ -26,8 +26,8 @@ note: ...so that the expression is assignable\n    |\n LL |         Foo { bar }\n    |         ^^^^^^^^^^^\n-   = note: expected  `Foo<'_>`\n-              found  `Foo<'_>`\n+   = note: expected `Foo<'_>`\n+              found `Foo<'_>`\n \n error: aborting due to previous error\n "}, {"sha": "d003acd879a77407d9d161ee6345381fe0944893", "filename": "src/test/ui/nll/normalization-bounds-error.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Fnll%2Fnormalization-bounds-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Fnll%2Fnormalization-bounds-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fnormalization-bounds-error.stderr?ref=0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "patch": "@@ -19,8 +19,8 @@ note: ...so that the types are compatible\n    |\n LL | fn visit_seq<'d, 'a: 'd>() -> <&'a () as Visitor<'d>>::Value {}\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: expected  `Visitor<'d>`\n-              found  `Visitor<'_>`\n+   = note: expected `Visitor<'d>`\n+              found `Visitor<'_>`\n \n error: aborting due to previous error\n "}, {"sha": "3317aae83bb08a2e621e552d0d573b0c0e9dcdb0", "filename": "src/test/ui/nll/type-alias-free-regions.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Fnll%2Ftype-alias-free-regions.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Fnll%2Ftype-alias-free-regions.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Ftype-alias-free-regions.stderr?ref=0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "patch": "@@ -16,8 +16,8 @@ note: ...so that the expression is assignable\n    |\n LL |         C { f: b }\n    |                ^\n-   = note: expected  `std::boxed::Box<std::boxed::Box<&isize>>`\n-              found  `std::boxed::Box<std::boxed::Box<&isize>>`\n+   = note: expected `std::boxed::Box<std::boxed::Box<&isize>>`\n+              found `std::boxed::Box<std::boxed::Box<&isize>>`\n note: but, the lifetime must be valid for the lifetime `'a` as defined on the impl at 15:6...\n   --> $DIR/type-alias-free-regions.rs:15:6\n    |\n@@ -28,8 +28,8 @@ note: ...so that the expression is assignable\n    |\n LL |         C { f: b }\n    |         ^^^^^^^^^^\n-   = note: expected  `C<'a>`\n-              found  `C<'_>`\n+   = note: expected `C<'a>`\n+              found `C<'_>`\n \n error[E0495]: cannot infer an appropriate lifetime due to conflicting requirements\n   --> $DIR/type-alias-free-regions.rs:27:16\n@@ -49,8 +49,8 @@ note: ...so that the expression is assignable\n    |\n LL |         C { f: Box::new(b.0) }\n    |                         ^^^\n-   = note: expected  `std::boxed::Box<&isize>`\n-              found  `std::boxed::Box<&isize>`\n+   = note: expected `std::boxed::Box<&isize>`\n+              found `std::boxed::Box<&isize>`\n note: but, the lifetime must be valid for the lifetime `'a` as defined on the impl at 25:6...\n   --> $DIR/type-alias-free-regions.rs:25:6\n    |\n@@ -61,8 +61,8 @@ note: ...so that the expression is assignable\n    |\n LL |         C { f: Box::new(b.0) }\n    |         ^^^^^^^^^^^^^^^^^^^^^^\n-   = note: expected  `C<'a>`\n-              found  `C<'_>`\n+   = note: expected `C<'a>`\n+              found `C<'_>`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "8421dc1d0c1303921e0981db1c908c9c8e4aa4e9", "filename": "src/test/ui/nll/user-annotations/constant-in-expr-inherent-1.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fconstant-in-expr-inherent-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fconstant-in-expr-inherent-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fconstant-in-expr-inherent-1.stderr?ref=0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "patch": "@@ -14,8 +14,8 @@ note: ...so that the types are compatible\n    |\n LL |     <Foo<'a>>::C\n    |     ^^^^^^^^^^^^\n-   = note: expected  `Foo<'_>`\n-              found  `Foo<'a>`\n+   = note: expected `Foo<'_>`\n+              found `Foo<'a>`\n    = note: but, the lifetime must be valid for the static lifetime...\n note: ...so that reference does not outlive borrowed content\n   --> $DIR/constant-in-expr-inherent-1.rs:8:5"}, {"sha": "ba0a1748c5e9fd7e2676a0035809b5b783b05da8", "filename": "src/test/ui/nll/user-annotations/constant-in-expr-trait-item-3.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fconstant-in-expr-trait-item-3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fconstant-in-expr-trait-item-3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fuser-annotations%2Fconstant-in-expr-trait-item-3.stderr?ref=0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "patch": "@@ -14,8 +14,8 @@ note: ...so that the types are compatible\n    |\n LL |     T::C\n    |     ^^^^\n-   = note: expected  `Foo<'_>`\n-              found  `Foo<'a>`\n+   = note: expected `Foo<'_>`\n+              found `Foo<'a>`\n    = note: but, the lifetime must be valid for the static lifetime...\n note: ...so that reference does not outlive borrowed content\n   --> $DIR/constant-in-expr-trait-item-3.rs:10:5"}, {"sha": "79ded5fc875a2d41c97b53c761bf26d9efb5b10b", "filename": "src/test/ui/object-lifetime/object-lifetime-default-elision.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-elision.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-elision.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fobject-lifetime%2Fobject-lifetime-default-elision.stderr?ref=0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "patch": "@@ -24,8 +24,8 @@ note: ...so that the expression is assignable\n    |\n LL |     ss\n    |     ^^\n-   = note: expected  `&'b (dyn SomeTrait + 'b)`\n-              found  `&dyn SomeTrait`\n+   = note: expected `&'b (dyn SomeTrait + 'b)`\n+              found `&dyn SomeTrait`\n \n error[E0495]: cannot infer an appropriate lifetime due to conflicting requirements\n   --> $DIR/object-lifetime-default-elision.rs:71:5\n@@ -53,8 +53,8 @@ note: ...so that the expression is assignable\n    |\n LL |     ss\n    |     ^^\n-   = note: expected  `&'b (dyn SomeTrait + 'b)`\n-              found  `&dyn SomeTrait`\n+   = note: expected `&'b (dyn SomeTrait + 'b)`\n+              found `&dyn SomeTrait`\n \n error: aborting due to 2 previous errors\n "}, {"sha": "069b897603cb916ac32b458f3fae5ed10e9fcebd", "filename": "src/test/ui/regions/region-object-lifetime-in-coercion.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Fregions%2Fregion-object-lifetime-in-coercion.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Fregions%2Fregion-object-lifetime-in-coercion.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregion-object-lifetime-in-coercion.stderr?ref=0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "patch": "@@ -39,8 +39,8 @@ note: ...so that the expression is assignable\n    |\n LL |     Box::new(v)\n    |              ^\n-   = note: expected  `&[u8]`\n-              found  `&'a [u8]`\n+   = note: expected `&[u8]`\n+              found `&'a [u8]`\n note: but, the lifetime must be valid for the lifetime `'b` as defined on the function body at 25:9...\n   --> $DIR/region-object-lifetime-in-coercion.rs:25:9\n    |\n@@ -51,8 +51,8 @@ note: ...so that the expression is assignable\n    |\n LL |     Box::new(v)\n    |     ^^^^^^^^^^^\n-   = note: expected  `std::boxed::Box<(dyn Foo + 'b)>`\n-              found  `std::boxed::Box<dyn Foo>`\n+   = note: expected `std::boxed::Box<(dyn Foo + 'b)>`\n+              found `std::boxed::Box<dyn Foo>`\n \n error: aborting due to 4 previous errors\n "}, {"sha": "c134b3b3ed554a01598e561b9d75b8de8e698d6c", "filename": "src/test/ui/regions/regions-assoc-type-region-bound-in-trait-not-met.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Fregions%2Fregions-assoc-type-region-bound-in-trait-not-met.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Fregions%2Fregions-assoc-type-region-bound-in-trait-not-met.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-assoc-type-region-bound-in-trait-not-met.stderr?ref=0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "patch": "@@ -14,8 +14,8 @@ note: ...so that the types are compatible\n    |\n LL | impl<'a> Foo<'static> for &'a i32 {\n    |          ^^^^^^^^^^^^\n-   = note: expected  `Foo<'static>`\n-              found  `Foo<'static>`\n+   = note: expected `Foo<'static>`\n+              found `Foo<'static>`\n    = note: but, the lifetime must be valid for the static lifetime...\n note: ...so that the type `&i32` will meet its required lifetime bounds\n   --> $DIR/regions-assoc-type-region-bound-in-trait-not-met.rs:14:10\n@@ -39,8 +39,8 @@ note: ...so that the types are compatible\n    |\n LL | impl<'a,'b> Foo<'b> for &'a i64 {\n    |             ^^^^^^^\n-   = note: expected  `Foo<'b>`\n-              found  `Foo<'_>`\n+   = note: expected `Foo<'b>`\n+              found `Foo<'_>`\n note: but, the lifetime must be valid for the lifetime `'b` as defined on the impl at 19:9...\n   --> $DIR/regions-assoc-type-region-bound-in-trait-not-met.rs:19:9\n    |"}, {"sha": "ac8c55ccc8fd4c679f2ee9a22fc0e514d973860d", "filename": "src/test/ui/regions/regions-assoc-type-static-bound-in-trait-not-met.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Fregions%2Fregions-assoc-type-static-bound-in-trait-not-met.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Fregions%2Fregions-assoc-type-static-bound-in-trait-not-met.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-assoc-type-static-bound-in-trait-not-met.stderr?ref=0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "patch": "@@ -14,8 +14,8 @@ note: ...so that the types are compatible\n    |\n LL | impl<'a> Foo for &'a i32 {\n    |          ^^^\n-   = note: expected  `Foo`\n-              found  `Foo`\n+   = note: expected `Foo`\n+              found `Foo`\n    = note: but, the lifetime must be valid for the static lifetime...\n note: ...so that the type `&i32` will meet its required lifetime bounds\n   --> $DIR/regions-assoc-type-static-bound-in-trait-not-met.rs:9:10"}, {"sha": "147f7f3541816c0b0ffca03bf433a4bbc73ca6e4", "filename": "src/test/ui/regions/regions-close-object-into-object-2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Fregions%2Fregions-close-object-into-object-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Fregions%2Fregions-close-object-into-object-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-close-object-into-object-2.stderr?ref=0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "patch": "@@ -20,8 +20,8 @@ note: ...so that the expression is assignable\n    |\n LL |     box B(&*v) as Box<dyn X>\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: expected  `std::boxed::Box<(dyn X + 'static)>`\n-              found  `std::boxed::Box<dyn X>`\n+   = note: expected `std::boxed::Box<(dyn X + 'static)>`\n+              found `std::boxed::Box<dyn X>`\n \n error: aborting due to previous error\n "}, {"sha": "6e7d6152cd09a28cfef15cbaeebb8caa8ab6879c", "filename": "src/test/ui/regions/regions-close-object-into-object-4.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Fregions%2Fregions-close-object-into-object-4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Fregions%2Fregions-close-object-into-object-4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-close-object-into-object-4.stderr?ref=0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "patch": "@@ -20,8 +20,8 @@ note: ...so that the expression is assignable\n    |\n LL |     box B(&*v) as Box<dyn X>\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: expected  `std::boxed::Box<(dyn X + 'static)>`\n-              found  `std::boxed::Box<dyn X>`\n+   = note: expected `std::boxed::Box<(dyn X + 'static)>`\n+              found `std::boxed::Box<dyn X>`\n \n error: aborting due to previous error\n "}, {"sha": "2070ce257b18d37a1802b4f35f93037f52e9a892", "filename": "src/test/ui/regions/regions-close-over-type-parameter-multiple.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Fregions%2Fregions-close-over-type-parameter-multiple.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Fregions%2Fregions-close-over-type-parameter-multiple.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-close-over-type-parameter-multiple.stderr?ref=0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "patch": "@@ -24,8 +24,8 @@ note: ...so that the expression is assignable\n    |\n LL |     box v as Box<dyn SomeTrait + 'a>\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: expected  `std::boxed::Box<(dyn SomeTrait + 'c)>`\n-              found  `std::boxed::Box<dyn SomeTrait>`\n+   = note: expected `std::boxed::Box<(dyn SomeTrait + 'c)>`\n+              found `std::boxed::Box<dyn SomeTrait>`\n \n error: aborting due to previous error\n "}, {"sha": "b24db1df18b0a9451470eac54ca3790da439be36", "filename": "src/test/ui/regions/regions-creating-enums4.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Fregions%2Fregions-creating-enums4.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Fregions%2Fregions-creating-enums4.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-creating-enums4.stderr?ref=0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "patch": "@@ -14,8 +14,8 @@ note: ...so that the expression is assignable\n    |\n LL |     Ast::Add(x, y)\n    |              ^\n-   = note: expected  `&Ast<'_>`\n-              found  `&Ast<'a>`\n+   = note: expected `&Ast<'_>`\n+              found `&Ast<'a>`\n note: but, the lifetime must be valid for the lifetime `'b` as defined on the function body at 6:19...\n   --> $DIR/regions-creating-enums4.rs:6:19\n    |\n@@ -26,8 +26,8 @@ note: ...so that the expression is assignable\n    |\n LL |     Ast::Add(x, y)\n    |     ^^^^^^^^^^^^^^\n-   = note: expected  `Ast<'b>`\n-              found  `Ast<'_>`\n+   = note: expected `Ast<'b>`\n+              found `Ast<'_>`\n \n error: aborting due to previous error\n "}, {"sha": "9e405d83140d8d2b66f18d8ae9828f179d6ee787", "filename": "src/test/ui/regions/regions-nested-fns.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Fregions%2Fregions-nested-fns.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Fregions%2Fregions-nested-fns.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-nested-fns.stderr?ref=0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "patch": "@@ -39,8 +39,8 @@ LL | |         if false { return ay; }\n LL | |         return z;\n LL | |     }));\n    | |_____^\n-   = note: expected  `&isize`\n-              found  `&isize`\n+   = note: expected `&isize`\n+              found `&isize`\n \n error[E0312]: lifetime of reference outlives lifetime of borrowed content...\n   --> $DIR/regions-nested-fns.rs:14:27"}, {"sha": "dc93d620ca637b454afe60af8e8b5db111251c8c", "filename": "src/test/ui/regions/regions-normalize-in-where-clause-list.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Fregions%2Fregions-normalize-in-where-clause-list.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Fregions%2Fregions-normalize-in-where-clause-list.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-normalize-in-where-clause-list.stderr?ref=0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "patch": "@@ -29,8 +29,8 @@ LL | |     where <() as Project<'a, 'b>>::Item : Eq\n LL | | {\n LL | | }\n    | |_^\n-   = note: expected  `Project<'a, 'b>`\n-              found  `Project<'_, '_>`\n+   = note: expected `Project<'a, 'b>`\n+              found `Project<'_, '_>`\n \n error[E0495]: cannot infer an appropriate lifetime for lifetime parameter `'a` due to conflicting requirements\n   --> $DIR/regions-normalize-in-where-clause-list.rs:22:1\n@@ -63,8 +63,8 @@ LL | |     where <() as Project<'a, 'b>>::Item : Eq\n LL | | {\n LL | | }\n    | |_^\n-   = note: expected  `Project<'a, 'b>`\n-              found  `Project<'_, '_>`\n+   = note: expected `Project<'a, 'b>`\n+              found `Project<'_, '_>`\n \n error[E0495]: cannot infer an appropriate lifetime for lifetime parameter `'a` due to conflicting requirements\n   --> $DIR/regions-normalize-in-where-clause-list.rs:22:4\n@@ -87,8 +87,8 @@ note: ...so that the types are compatible\n    |\n LL | fn bar<'a, 'b>()\n    |    ^^^\n-   = note: expected  `Project<'a, 'b>`\n-              found  `Project<'_, '_>`\n+   = note: expected `Project<'a, 'b>`\n+              found `Project<'_, '_>`\n \n error: aborting due to 3 previous errors\n "}, {"sha": "2c4769d8e37516e996192a5141f9e8eabf65b25c", "filename": "src/test/ui/regions/regions-ret-borrowed-1.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Fregions%2Fregions-ret-borrowed-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Fregions%2Fregions-ret-borrowed-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-ret-borrowed-1.stderr?ref=0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "patch": "@@ -14,8 +14,8 @@ note: ...so that the expression is assignable\n    |\n LL |     with(|o| o)\n    |              ^\n-   = note: expected  `&isize`\n-              found  `&isize`\n+   = note: expected `&isize`\n+              found `&isize`\n note: but, the lifetime must be valid for the lifetime `'a` as defined on the function body at 9:14...\n   --> $DIR/regions-ret-borrowed-1.rs:9:14\n    |"}, {"sha": "da560107cea997ef81166664786b9ba0b26ddb3c", "filename": "src/test/ui/regions/regions-ret-borrowed.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Fregions%2Fregions-ret-borrowed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Fregions%2Fregions-ret-borrowed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-ret-borrowed.stderr?ref=0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "patch": "@@ -14,8 +14,8 @@ note: ...so that the expression is assignable\n    |\n LL |     with(|o| o)\n    |              ^\n-   = note: expected  `&isize`\n-              found  `&isize`\n+   = note: expected `&isize`\n+              found `&isize`\n note: but, the lifetime must be valid for the lifetime `'a` as defined on the function body at 12:14...\n   --> $DIR/regions-ret-borrowed.rs:12:14\n    |"}, {"sha": "7478b53bd3ccc02c7097f35f8aef4bad0918e205", "filename": "src/test/ui/regions/regions-trait-object-subtyping.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Fregions%2Fregions-trait-object-subtyping.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Fregions%2Fregions-trait-object-subtyping.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fregions%2Fregions-trait-object-subtyping.stderr?ref=0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "patch": "@@ -41,8 +41,8 @@ note: ...so that the expression is assignable\n    |\n LL |     x\n    |     ^\n-   = note: expected  `&'b mut (dyn Dummy + 'b)`\n-              found  `&mut (dyn Dummy + 'b)`\n+   = note: expected `&'b mut (dyn Dummy + 'b)`\n+              found `&mut (dyn Dummy + 'b)`\n \n error[E0308]: mismatched types\n   --> $DIR/regions-trait-object-subtyping.rs:22:5"}, {"sha": "f819faa27899565c9a33b8a68de659aa05f91eb5", "filename": "src/test/ui/reject-specialized-drops-8142.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Freject-specialized-drops-8142.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Freject-specialized-drops-8142.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Freject-specialized-drops-8142.stderr?ref=0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "patch": "@@ -118,8 +118,8 @@ note: ...so that the types are compatible\n    |\n LL | impl<'lw>         Drop for W<'lw,'lw>     { fn drop(&mut self) { } } // REJECT\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-   = note: expected  `W<'l1, 'l2>`\n-              found  `W<'_, '_>`\n+   = note: expected `W<'l1, 'l2>`\n+              found `W<'_, '_>`\n \n error[E0367]: `Drop` impl requires `AddsBnd: Bound` but the enum it is implemented for does not\n   --> $DIR/reject-specialized-drops-8142.rs:61:14"}, {"sha": "99013d32ab8d09891a1a13df118826baee0e5864", "filename": "src/test/ui/traits/self-without-lifetime-constraint.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Ftraits%2Fself-without-lifetime-constraint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Ftraits%2Fself-without-lifetime-constraint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fself-without-lifetime-constraint.rs?ref=0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "patch": "@@ -0,0 +1,53 @@\n+use std::error::Error;\n+use std::fmt;\n+\n+#[derive(Copy, Clone, Debug, PartialEq)]\n+pub enum ValueRef<'a> {\n+    Null,\n+    Integer(i64),\n+    Real(f64),\n+    Text(&'a [u8]),\n+    Blob(&'a [u8]),\n+}\n+\n+impl<'a> ValueRef<'a> {\n+    pub fn as_str(&self) -> FromSqlResult<&'a str, &'a &'a str> {\n+        match *self {\n+            ValueRef::Text(t) => {\n+                std::str::from_utf8(t).map_err(|_| FromSqlError::InvalidType).map(|x| (x, &x))\n+            }\n+            _ => Err(FromSqlError::InvalidType),\n+        }\n+    }\n+}\n+\n+#[derive(Debug)]\n+#[non_exhaustive]\n+pub enum FromSqlError {\n+    InvalidType\n+}\n+\n+impl fmt::Display for FromSqlError {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        write!(f, \"InvalidType\")\n+    }\n+}\n+\n+impl Error for FromSqlError {}\n+\n+pub type FromSqlResult<T, K> = Result<(T, K), FromSqlError>;\n+\n+pub trait FromSql: Sized {\n+    fn column_result(value: ValueRef<'_>) -> FromSqlResult<Self, &Self>;\n+}\n+\n+impl FromSql for &str {\n+    fn column_result(value: ValueRef<'_>) -> FromSqlResult<&str, &&str> {\n+    //~^ ERROR `impl` item signature doesn't match `trait` item signature\n+        value.as_str()\n+    }\n+}\n+\n+pub fn main() {\n+    println!(\"{}\", \"Hello World\");\n+}"}, {"sha": "6c7abe753e2bf254d7265234a6f39103cc33e7b8", "filename": "src/test/ui/traits/self-without-lifetime-constraint.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Ftraits%2Fself-without-lifetime-constraint.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Ftraits%2Fself-without-lifetime-constraint.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Fself-without-lifetime-constraint.stderr?ref=0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "patch": "@@ -0,0 +1,19 @@\n+error: `impl` item signature doesn't match `trait` item signature\n+  --> $DIR/self-without-lifetime-constraint.rs:45:5\n+   |\n+LL |     fn column_result(value: ValueRef<'_>) -> FromSqlResult<Self, &Self>;\n+   |     -------------------------------------------------------------------- expected `fn(ValueRef<'_>) -> std::result::Result<(&str, &&str), FromSqlError>`\n+...\n+LL |     fn column_result(value: ValueRef<'_>) -> FromSqlResult<&str, &&str> {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ found `fn(ValueRef<'_>) -> std::result::Result<(&str, &&str), FromSqlError>`\n+   |\n+   = note: expected `fn(ValueRef<'_>) -> std::result::Result<(&str, &&str), _>`\n+              found `fn(ValueRef<'_>) -> std::result::Result<(&str, &&str), _>`\n+help: the lifetime requirements from the `impl` do not correspond to the requirements in the `trait`\n+  --> $DIR/self-without-lifetime-constraint.rs:41:60\n+   |\n+LL |     fn column_result(value: ValueRef<'_>) -> FromSqlResult<Self, &Self>;\n+   |                                                            ^^^^ consider borrowing this type parameter in the trait\n+\n+error: aborting due to previous error\n+"}, {"sha": "46aa7db967ad4bb6aca754e3e9fe7a7ab4ac9988", "filename": "src/test/ui/traits/trait-impl-of-supertrait-has-wrong-lifetime-parameters.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Ftraits%2Ftrait-impl-of-supertrait-has-wrong-lifetime-parameters.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Ftraits%2Ftrait-impl-of-supertrait-has-wrong-lifetime-parameters.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-impl-of-supertrait-has-wrong-lifetime-parameters.stderr?ref=0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "patch": "@@ -19,8 +19,8 @@ note: ...so that the types are compatible\n    |\n LL | impl<'a,'b> T2<'a, 'b> for S<'a, 'b> {\n    |             ^^^^^^^^^^\n-   = note: expected  `T1<'a>`\n-              found  `T1<'_>`\n+   = note: expected `T1<'a>`\n+              found `T1<'_>`\n \n error: aborting due to previous error\n "}, {"sha": "a79b74dcddead0cba82cf036ebddc215c55b3632", "filename": "src/test/ui/traits/trait-param-without-lifetime-constraint.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Ftraits%2Ftrait-param-without-lifetime-constraint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Ftraits%2Ftrait-param-without-lifetime-constraint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-param-without-lifetime-constraint.rs?ref=0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "patch": "@@ -0,0 +1,20 @@\n+struct Article {\n+    proof_reader: ProofReader,\n+}\n+\n+struct ProofReader {\n+    name: String,\n+}\n+\n+pub trait HaveRelationship<To> {\n+    fn get_relation(&self) -> To;\n+}\n+\n+impl HaveRelationship<&ProofReader> for Article {\n+    fn get_relation(&self) -> &ProofReader {\n+    //~^ ERROR `impl` item signature doesn't match `trait` item signature\n+        &self.proof_reader\n+    }\n+}\n+\n+fn main() {}"}, {"sha": "4942dbe480ba3c73faf208c2aade8f9b51da40cb", "filename": "src/test/ui/traits/trait-param-without-lifetime-constraint.stderr", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Ftraits%2Ftrait-param-without-lifetime-constraint.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Ftraits%2Ftrait-param-without-lifetime-constraint.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftraits%2Ftrait-param-without-lifetime-constraint.stderr?ref=0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "patch": "@@ -0,0 +1,19 @@\n+error: `impl` item signature doesn't match `trait` item signature\n+  --> $DIR/trait-param-without-lifetime-constraint.rs:14:5\n+   |\n+LL |     fn get_relation(&self) -> To;\n+   |     ----------------------------- expected `fn(&Article) -> &ProofReader`\n+...\n+LL |     fn get_relation(&self) -> &ProofReader {\n+   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ found `fn(&Article) -> &ProofReader`\n+   |\n+   = note: expected `fn(&Article) -> &ProofReader`\n+              found `fn(&Article) -> &ProofReader`\n+help: the lifetime requirements from the `impl` do not correspond to the requirements in the `trait`\n+  --> $DIR/trait-param-without-lifetime-constraint.rs:10:31\n+   |\n+LL |     fn get_relation(&self) -> To;\n+   |                               ^^ consider borrowing this type parameter in the trait\n+\n+error: aborting due to previous error\n+"}, {"sha": "e3c9d50dfe5b31b291c7841a40a00a7c97316404", "filename": "src/test/ui/underscore-lifetime/dyn-trait-underscore.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Funderscore-lifetime%2Fdyn-trait-underscore.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Funderscore-lifetime%2Fdyn-trait-underscore.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funderscore-lifetime%2Fdyn-trait-underscore.stderr?ref=0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "patch": "@@ -23,8 +23,8 @@ note: ...so that the expression is assignable\n    |\n LL |     Box::new(items.iter())\n    |     ^^^^^^^^^^^^^^^^^^^^^^\n-   = note: expected  `std::boxed::Box<(dyn std::iter::Iterator<Item = &T> + 'static)>`\n-              found  `std::boxed::Box<dyn std::iter::Iterator<Item = &T>>`\n+   = note: expected `std::boxed::Box<(dyn std::iter::Iterator<Item = &T> + 'static)>`\n+              found `std::boxed::Box<dyn std::iter::Iterator<Item = &T>>`\n \n error: aborting due to previous error\n "}, {"sha": "540612a7dce0576777c6ae080928f2a3fc9c4778", "filename": "src/test/ui/unsafe/rfc-2585-safe_packed_borrows-in-unsafe-fn.rs", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Funsafe%2Frfc-2585-safe_packed_borrows-in-unsafe-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Funsafe%2Frfc-2585-safe_packed_borrows-in-unsafe-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsafe%2Frfc-2585-safe_packed_borrows-in-unsafe-fn.rs?ref=0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "patch": "@@ -0,0 +1,67 @@\n+#![feature(unsafe_block_in_unsafe_fn)]\n+\n+#[repr(packed)]\n+pub struct Packed {\n+    data: &'static u32,\n+}\n+\n+const PACKED: Packed = Packed { data: &0 };\n+\n+#[allow(safe_packed_borrows)]\n+#[allow(unsafe_op_in_unsafe_fn)]\n+unsafe fn allow_allow() {\n+    &PACKED.data; // allowed\n+}\n+\n+#[allow(safe_packed_borrows)]\n+#[warn(unsafe_op_in_unsafe_fn)]\n+unsafe fn allow_warn() {\n+    &PACKED.data; // allowed\n+}\n+\n+#[allow(safe_packed_borrows)]\n+#[deny(unsafe_op_in_unsafe_fn)]\n+unsafe fn allow_deny() {\n+    &PACKED.data; // allowed\n+}\n+\n+#[warn(safe_packed_borrows)]\n+#[allow(unsafe_op_in_unsafe_fn)]\n+unsafe fn warn_allow() {\n+    &PACKED.data; // allowed\n+}\n+\n+#[warn(safe_packed_borrows)]\n+#[warn(unsafe_op_in_unsafe_fn)]\n+unsafe fn warn_warn() {\n+    &PACKED.data; //~ WARN\n+    //~| WARNING this was previously accepted by the compiler but is being phased out\n+}\n+\n+#[warn(safe_packed_borrows)]\n+#[deny(unsafe_op_in_unsafe_fn)]\n+unsafe fn warn_deny() {\n+    &PACKED.data; //~ WARN\n+    //~| WARNING this was previously accepted by the compiler but is being phased out\n+}\n+\n+#[deny(safe_packed_borrows)]\n+#[allow(unsafe_op_in_unsafe_fn)]\n+unsafe fn deny_allow() {\n+    &PACKED.data; // allowed\n+}\n+\n+#[deny(safe_packed_borrows)]\n+#[warn(unsafe_op_in_unsafe_fn)]\n+unsafe fn deny_warn() {\n+    &PACKED.data; //~ WARN\n+}\n+\n+#[deny(safe_packed_borrows)]\n+#[deny(unsafe_op_in_unsafe_fn)]\n+unsafe fn deny_deny() {\n+    &PACKED.data; //~ ERROR\n+    //~| WARNING this was previously accepted by the compiler but is being phased out\n+}\n+\n+fn main() {}"}, {"sha": "fda15159643b6ec2526a547a8d25ba49e244c882", "filename": "src/test/ui/unsafe/rfc-2585-safe_packed_borrows-in-unsafe-fn.stderr", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Funsafe%2Frfc-2585-safe_packed_borrows-in-unsafe-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Funsafe%2Frfc-2585-safe_packed_borrows-in-unsafe-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsafe%2Frfc-2585-safe_packed_borrows-in-unsafe-fn.stderr?ref=0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "patch": "@@ -0,0 +1,60 @@\n+warning: borrow of packed field is unsafe and requires unsafe block (error E0133)\n+  --> $DIR/rfc-2585-safe_packed_borrows-in-unsafe-fn.rs:37:5\n+   |\n+LL |     &PACKED.data;\n+   |     ^^^^^^^^^^^^ borrow of packed field\n+   |\n+note: the lint level is defined here\n+  --> $DIR/rfc-2585-safe_packed_borrows-in-unsafe-fn.rs:34:8\n+   |\n+LL | #[warn(safe_packed_borrows)]\n+   |        ^^^^^^^^^^^^^^^^^^^\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #46043 <https://github.com/rust-lang/rust/issues/46043>\n+   = note: fields of packed structs might be misaligned: dereferencing a misaligned pointer or even just creating a misaligned reference is undefined behavior\n+\n+warning: borrow of packed field is unsafe and requires unsafe block (error E0133)\n+  --> $DIR/rfc-2585-safe_packed_borrows-in-unsafe-fn.rs:44:5\n+   |\n+LL |     &PACKED.data;\n+   |     ^^^^^^^^^^^^ borrow of packed field\n+   |\n+note: the lint level is defined here\n+  --> $DIR/rfc-2585-safe_packed_borrows-in-unsafe-fn.rs:41:8\n+   |\n+LL | #[warn(safe_packed_borrows)]\n+   |        ^^^^^^^^^^^^^^^^^^^\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #46043 <https://github.com/rust-lang/rust/issues/46043>\n+   = note: fields of packed structs might be misaligned: dereferencing a misaligned pointer or even just creating a misaligned reference is undefined behavior\n+\n+warning: borrow of packed field is unsafe and requires unsafe block (error E0133)\n+  --> $DIR/rfc-2585-safe_packed_borrows-in-unsafe-fn.rs:57:5\n+   |\n+LL |     &PACKED.data;\n+   |     ^^^^^^^^^^^^ borrow of packed field\n+   |\n+note: the lint level is defined here\n+  --> $DIR/rfc-2585-safe_packed_borrows-in-unsafe-fn.rs:55:8\n+   |\n+LL | #[warn(unsafe_op_in_unsafe_fn)]\n+   |        ^^^^^^^^^^^^^^^^^^^^^^\n+   = note: fields of packed structs might be misaligned: dereferencing a misaligned pointer or even just creating a misaligned reference is undefined behavior\n+\n+error: borrow of packed field is unsafe and requires unsafe block (error E0133)\n+  --> $DIR/rfc-2585-safe_packed_borrows-in-unsafe-fn.rs:63:5\n+   |\n+LL |     &PACKED.data;\n+   |     ^^^^^^^^^^^^ borrow of packed field\n+   |\n+note: the lint level is defined here\n+  --> $DIR/rfc-2585-safe_packed_borrows-in-unsafe-fn.rs:60:8\n+   |\n+LL | #[deny(safe_packed_borrows)]\n+   |        ^^^^^^^^^^^^^^^^^^^\n+   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n+   = note: for more information, see issue #46043 <https://github.com/rust-lang/rust/issues/46043>\n+   = note: fields of packed structs might be misaligned: dereferencing a misaligned pointer or even just creating a misaligned reference is undefined behavior\n+\n+error: aborting due to previous error; 3 warnings emitted\n+"}, {"sha": "1e57b03ced48bf1698be7dd94729538b5ebfcc66", "filename": "src/test/ui/unsafe/rfc-2585-unsafe_op_in_unsafe_fn.rs", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Funsafe%2Frfc-2585-unsafe_op_in_unsafe_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Funsafe%2Frfc-2585-unsafe_op_in_unsafe_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsafe%2Frfc-2585-unsafe_op_in_unsafe_fn.rs?ref=0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "patch": "@@ -0,0 +1,76 @@\n+#![feature(unsafe_block_in_unsafe_fn)]\n+#![deny(unsafe_op_in_unsafe_fn)]\n+#![deny(unused_unsafe)]\n+\n+unsafe fn unsf() {}\n+const PTR: *const () = std::ptr::null();\n+static mut VOID: () = ();\n+\n+unsafe fn deny_level() {\n+    unsf();\n+    //~^ ERROR call to unsafe function is unsafe and requires unsafe block\n+    *PTR;\n+    //~^ ERROR dereference of raw pointer is unsafe and requires unsafe block\n+    VOID = ();\n+    //~^ ERROR use of mutable static is unsafe and requires unsafe block\n+}\n+\n+// Check that `unsafe_op_in_unsafe_fn` works starting from the `warn` level.\n+#[warn(unsafe_op_in_unsafe_fn)]\n+#[deny(warnings)]\n+unsafe fn warning_level() {\n+    unsf();\n+    //~^ ERROR call to unsafe function is unsafe and requires unsafe block\n+    *PTR;\n+    //~^ ERROR dereference of raw pointer is unsafe and requires unsafe block\n+    VOID = ();\n+    //~^ ERROR use of mutable static is unsafe and requires unsafe block\n+}\n+\n+unsafe fn explicit_block() {\n+    // no error\n+    unsafe {\n+        unsf();\n+        *PTR;\n+        VOID = ();\n+    }\n+}\n+\n+unsafe fn two_explicit_blocks() {\n+    unsafe { unsafe { unsf() } }\n+    //~^ ERROR unnecessary `unsafe` block\n+}\n+\n+#[allow(unsafe_op_in_unsafe_fn)]\n+unsafe fn allow_level() {\n+    // lint allowed -> no error\n+    unsf();\n+    *PTR;\n+    VOID = ();\n+\n+    unsafe { unsf() }\n+    //~^ ERROR unnecessary `unsafe` block\n+}\n+\n+unsafe fn nested_allow_level() {\n+    #[allow(unsafe_op_in_unsafe_fn)]\n+    {\n+        // lint allowed -> no error\n+        unsf();\n+        *PTR;\n+        VOID = ();\n+\n+        unsafe { unsf() }\n+        //~^ ERROR unnecessary `unsafe` block\n+    }\n+}\n+\n+fn main() {\n+    unsf();\n+    //~^ ERROR call to unsafe function is unsafe and requires unsafe block\n+    #[allow(unsafe_op_in_unsafe_fn)]\n+    {\n+        unsf();\n+        //~^ ERROR call to unsafe function is unsafe and requires unsafe function or block\n+    }\n+}"}, {"sha": "cc595df12cc446069182a04ee078d6fe837d1c22", "filename": "src/test/ui/unsafe/rfc-2585-unsafe_op_in_unsafe_fn.stderr", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Funsafe%2Frfc-2585-unsafe_op_in_unsafe_fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/0e9e4083100aa3ebf09b8f1ace0348cb37475eb9/src%2Ftest%2Fui%2Funsafe%2Frfc-2585-unsafe_op_in_unsafe_fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsafe%2Frfc-2585-unsafe_op_in_unsafe_fn.stderr?ref=0e9e4083100aa3ebf09b8f1ace0348cb37475eb9", "patch": "@@ -0,0 +1,104 @@\n+error: call to unsafe function is unsafe and requires unsafe block (error E0133)\n+  --> $DIR/rfc-2585-unsafe_op_in_unsafe_fn.rs:10:5\n+   |\n+LL |     unsf();\n+   |     ^^^^^^ call to unsafe function\n+   |\n+note: the lint level is defined here\n+  --> $DIR/rfc-2585-unsafe_op_in_unsafe_fn.rs:2:9\n+   |\n+LL | #![deny(unsafe_op_in_unsafe_fn)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^\n+   = note: consult the function's documentation for information on how to avoid undefined behavior\n+\n+error: dereference of raw pointer is unsafe and requires unsafe block (error E0133)\n+  --> $DIR/rfc-2585-unsafe_op_in_unsafe_fn.rs:12:5\n+   |\n+LL |     *PTR;\n+   |     ^^^^ dereference of raw pointer\n+   |\n+   = note: raw pointers may be NULL, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior\n+\n+error: use of mutable static is unsafe and requires unsafe block (error E0133)\n+  --> $DIR/rfc-2585-unsafe_op_in_unsafe_fn.rs:14:5\n+   |\n+LL |     VOID = ();\n+   |     ^^^^^^^^^ use of mutable static\n+   |\n+   = note: mutable statics can be mutated by multiple threads: aliasing violations or data races will cause undefined behavior\n+\n+error: call to unsafe function is unsafe and requires unsafe block (error E0133)\n+  --> $DIR/rfc-2585-unsafe_op_in_unsafe_fn.rs:22:5\n+   |\n+LL |     unsf();\n+   |     ^^^^^^ call to unsafe function\n+   |\n+note: the lint level is defined here\n+  --> $DIR/rfc-2585-unsafe_op_in_unsafe_fn.rs:20:8\n+   |\n+LL | #[deny(warnings)]\n+   |        ^^^^^^^^\n+   = note: `#[deny(unsafe_op_in_unsafe_fn)]` implied by `#[deny(warnings)]`\n+   = note: consult the function's documentation for information on how to avoid undefined behavior\n+\n+error: dereference of raw pointer is unsafe and requires unsafe block (error E0133)\n+  --> $DIR/rfc-2585-unsafe_op_in_unsafe_fn.rs:24:5\n+   |\n+LL |     *PTR;\n+   |     ^^^^ dereference of raw pointer\n+   |\n+   = note: raw pointers may be NULL, dangling or unaligned; they can violate aliasing rules and cause data races: all of these are undefined behavior\n+\n+error: use of mutable static is unsafe and requires unsafe block (error E0133)\n+  --> $DIR/rfc-2585-unsafe_op_in_unsafe_fn.rs:26:5\n+   |\n+LL |     VOID = ();\n+   |     ^^^^^^^^^ use of mutable static\n+   |\n+   = note: mutable statics can be mutated by multiple threads: aliasing violations or data races will cause undefined behavior\n+\n+error: unnecessary `unsafe` block\n+  --> $DIR/rfc-2585-unsafe_op_in_unsafe_fn.rs:40:14\n+   |\n+LL |     unsafe { unsafe { unsf() } }\n+   |     ------   ^^^^^^ unnecessary `unsafe` block\n+   |     |\n+   |     because it's nested under this `unsafe` block\n+   |\n+note: the lint level is defined here\n+  --> $DIR/rfc-2585-unsafe_op_in_unsafe_fn.rs:3:9\n+   |\n+LL | #![deny(unused_unsafe)]\n+   |         ^^^^^^^^^^^^^\n+\n+error: unnecessary `unsafe` block\n+  --> $DIR/rfc-2585-unsafe_op_in_unsafe_fn.rs:51:5\n+   |\n+LL |     unsafe { unsf() }\n+   |     ^^^^^^ unnecessary `unsafe` block\n+\n+error: unnecessary `unsafe` block\n+  --> $DIR/rfc-2585-unsafe_op_in_unsafe_fn.rs:63:9\n+   |\n+LL |         unsafe { unsf() }\n+   |         ^^^^^^ unnecessary `unsafe` block\n+\n+error[E0133]: call to unsafe function is unsafe and requires unsafe block\n+  --> $DIR/rfc-2585-unsafe_op_in_unsafe_fn.rs:69:5\n+   |\n+LL |     unsf();\n+   |     ^^^^^^ call to unsafe function\n+   |\n+   = note: consult the function's documentation for information on how to avoid undefined behavior\n+\n+error[E0133]: call to unsafe function is unsafe and requires unsafe function or block\n+  --> $DIR/rfc-2585-unsafe_op_in_unsafe_fn.rs:73:9\n+   |\n+LL |         unsf();\n+   |         ^^^^^^ call to unsafe function\n+   |\n+   = note: consult the function's documentation for information on how to avoid undefined behavior\n+\n+error: aborting due to 11 previous errors\n+\n+For more information about this error, try `rustc --explain E0133`."}]}