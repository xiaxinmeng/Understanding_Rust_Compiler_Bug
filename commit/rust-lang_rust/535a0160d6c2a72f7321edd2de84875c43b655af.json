{"sha": "535a0160d6c2a72f7321edd2de84875c43b655af", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUzNWEwMTYwZDZjMmE3MmY3MzIxZWRkMmRlODQ4NzVjNDNiNjU1YWY=", "commit": {"author": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2017-06-01T03:42:16Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-06-01T03:42:16Z"}, "message": "Merge pull request #1616 from topecongiro/nested-closure\n\nUse block indent style when visual indent style fails", "tree": {"sha": "cc9d56e75e05fe53d16717d7f5acca136b7e26c5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cc9d56e75e05fe53d16717d7f5acca136b7e26c5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/535a0160d6c2a72f7321edd2de84875c43b655af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/535a0160d6c2a72f7321edd2de84875c43b655af", "html_url": "https://github.com/rust-lang/rust/commit/535a0160d6c2a72f7321edd2de84875c43b655af", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/535a0160d6c2a72f7321edd2de84875c43b655af/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f6e8e9facc5b64a426ca7b95d69459c56035d7b4", "url": "https://api.github.com/repos/rust-lang/rust/commits/f6e8e9facc5b64a426ca7b95d69459c56035d7b4", "html_url": "https://github.com/rust-lang/rust/commit/f6e8e9facc5b64a426ca7b95d69459c56035d7b4"}, {"sha": "10c3632078b986e1712f40ce5d39801a7e76b511", "url": "https://api.github.com/repos/rust-lang/rust/commits/10c3632078b986e1712f40ce5d39801a7e76b511", "html_url": "https://github.com/rust-lang/rust/commit/10c3632078b986e1712f40ce5d39801a7e76b511"}], "stats": {"total": 179, "additions": 133, "deletions": 46}, "files": [{"sha": "8e0a5aca9846fcbab45a26ae2a2797e92d94d088", "filename": "src/expr.rs", "status": "modified", "additions": 55, "deletions": 29, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/535a0160d6c2a72f7321edd2de84875c43b655af/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/535a0160d6c2a72f7321edd2de84875c43b655af/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=535a0160d6c2a72f7321edd2de84875c43b655af", "patch": "@@ -599,11 +599,14 @@ fn rewrite_closure(capture: ast::CaptureBy,\n                              -> Option<String> {\n         // Start with visual indent, then fall back to block indent if the\n         // closure is large.\n-        if let Some(block_str) = block.rewrite(&context, shape) {\n-            let block_threshold = context.config.closure_block_indent_threshold();\n-            if block_threshold < 0 || block_str.matches('\\n').count() <= block_threshold as usize {\n-                if let Some(block_str) = block_str.rewrite(context, shape) {\n-                    return Some(format!(\"{} {}\", prefix, block_str));\n+        let block_threshold = context.config.closure_block_indent_threshold();\n+        if block_threshold >= 0 {\n+            if let Some(block_str) = block.rewrite(&context, shape) {\n+                if block_str.matches('\\n').count() <= block_threshold as usize &&\n+                   !need_block_indent(&block_str, shape) {\n+                    if let Some(block_str) = block_str.rewrite(context, shape) {\n+                        return Some(format!(\"{} {}\", prefix, block_str));\n+                    }\n                 }\n             }\n         }\n@@ -965,13 +968,15 @@ impl<'a> Rewrite for ControlFlow<'a> {\n         };\n \n         // for event in event\n-        let between_kwd_cond = mk_sp(context.codemap.span_after(self.span, self.keyword.trim()),\n-                                     self.pat\n-                                         .map_or(cond_span.lo, |p| if self.matcher.is_empty() {\n-            p.span.lo\n-        } else {\n-            context.codemap.span_before(self.span, self.matcher.trim())\n-        }));\n+        let between_kwd_cond = mk_sp(\n+            context.codemap.span_after(self.span, self.keyword.trim()),\n+            self.pat\n+                .map_or(cond_span.lo, |p| if self.matcher.is_empty() {\n+                    p.span.lo\n+                } else {\n+                    context.codemap.span_before(self.span, self.matcher.trim())\n+                }),\n+        );\n \n         let between_kwd_cond_comment = extract_comment(between_kwd_cond, context, shape);\n \n@@ -1676,20 +1681,40 @@ fn rewrite_call_inner(context: &RewriteContext,\n         .ok_or(Ordering::Greater)?;\n \n     let span_lo = context.codemap.span_after(span, \"(\");\n-    let span = mk_sp(span_lo, span.hi);\n+    let new_span = mk_sp(span_lo, span.hi);\n \n     let (extendable, list_str) = rewrite_call_args(context,\n                                                    args,\n-                                                   span,\n+                                                   new_span,\n                                                    nested_shape,\n                                                    one_line_width,\n                                                    force_trailing_comma)\n         .ok_or(Ordering::Less)?;\n+\n+    if !use_block_indent(context) && need_block_indent(&list_str, nested_shape) && !extendable {\n+        println!(\"here\");\n+        let mut new_context = context.clone();\n+        new_context.use_block = true;\n+        return rewrite_call_inner(&new_context,\n+                                  callee_str,\n+                                  args,\n+                                  span,\n+                                  shape,\n+                                  force_trailing_comma);\n+    }\n+\n     Ok(format!(\"{}{}\",\n                callee_str,\n                wrap_args_with_parens(context, &list_str, extendable, shape, nested_shape)))\n }\n \n+fn need_block_indent(s: &str, shape: Shape) -> bool {\n+    s.lines().skip(1).any(|s| {\n+                              s.find(|c| !char::is_whitespace(c))\n+                                  .map_or(false, |w| w + 1 < shape.indent.width())\n+                          })\n+}\n+\n fn rewrite_call_args(context: &RewriteContext,\n                      args: &[ptr::P<ast::Expr>],\n                      span: Span,\n@@ -1720,8 +1745,7 @@ fn rewrite_call_args(context: &RewriteContext,\n     // Replace the last item with its first line to see if it fits with\n     // first arguments.\n     if overflow_last {\n-        let arg_shape = if context.config.fn_call_style() == IndentStyle::Block &&\n-                           is_extendable(args) {\n+        let arg_shape = if use_block_indent(context) && is_extendable(args) {\n             Shape {\n                 width: context.config.fn_call_width(),\n                 indent: shape.block().indent.block_unindent(context.config),\n@@ -1799,8 +1823,7 @@ fn rewrite_call_args(context: &RewriteContext,\n         // If arguments do not fit in a single line and do not contain newline,\n         // try to put it on the next line. Try this only when we are in block mode\n         // and not rewriting macro.\n-        Some(ref s) if context.config.fn_call_style() == IndentStyle::Block &&\n-                       !context.inside_macro &&\n+        Some(ref s) if use_block_indent(context) && !context.inside_macro &&\n                        ((!can_be_overflowed(context, args) && last_char_is_not_comma &&\n                          s.contains('\\n')) ||\n                         first_line_width(s) > one_line_budget) => {\n@@ -1814,23 +1837,25 @@ fn rewrite_call_args(context: &RewriteContext,\n     }\n }\n \n+fn use_block_indent(context: &RewriteContext) -> bool {\n+    context.config.fn_call_style() == IndentStyle::Block || context.use_block\n+}\n+\n fn can_be_overflowed(context: &RewriteContext, args: &[ptr::P<ast::Expr>]) -> bool {\n     match args.last().map(|x| &x.node) {\n         Some(&ast::ExprKind::Match(..)) => {\n-            (context.config.fn_call_style() == IndentStyle::Block && args.len() == 1) ||\n+            (use_block_indent(context) && args.len() == 1) ||\n             (context.config.fn_call_style() == IndentStyle::Visual && args.len() > 1)\n         }\n         Some(&ast::ExprKind::Block(..)) |\n         Some(&ast::ExprKind::Closure(..)) => {\n-            context.config.fn_call_style() == IndentStyle::Block ||\n+            use_block_indent(context) ||\n             context.config.fn_call_style() == IndentStyle::Visual && args.len() > 1\n         }\n         Some(&ast::ExprKind::Call(..)) |\n         Some(&ast::ExprKind::Mac(..)) |\n-        Some(&ast::ExprKind::Struct(..)) => {\n-            context.config.fn_call_style() == IndentStyle::Block && args.len() == 1\n-        }\n-        Some(&ast::ExprKind::Tup(..)) => context.config.fn_call_style() == IndentStyle::Block,\n+        Some(&ast::ExprKind::Struct(..)) => use_block_indent(context) && args.len() == 1,\n+        Some(&ast::ExprKind::Tup(..)) => use_block_indent(context),\n         _ => false,\n     }\n }\n@@ -1865,8 +1890,8 @@ fn wrap_args_with_parens(context: &RewriteContext,\n                          shape: Shape,\n                          nested_shape: Shape)\n                          -> String {\n-    if context.config.fn_call_style() == IndentStyle::Visual ||\n-       (context.inside_macro && !args_str.contains('\\n')) || is_extendable {\n+    if !use_block_indent(context) || (context.inside_macro && !args_str.contains('\\n')) ||\n+       is_extendable {\n         if context.config.spaces_within_parens() && args_str.len() > 0 {\n             format!(\"( {} )\", args_str)\n         } else {\n@@ -2062,9 +2087,10 @@ fn shape_from_fn_call_style(context: &RewriteContext,\n                             overhead: usize,\n                             offset: usize)\n                             -> Option<Shape> {\n-    match context.config.fn_call_style() {\n-        IndentStyle::Block => Some(shape.block().block_indent(context.config.tab_spaces())),\n-        IndentStyle::Visual => shape.visual_indent(offset).sub_width(overhead),\n+    if use_block_indent(context) {\n+        Some(shape.block().block_indent(context.config.tab_spaces()))\n+    } else {\n+        shape.visual_indent(offset).sub_width(overhead)\n     }\n }\n "}, {"sha": "e89235631fb33afbae94b35b35b22613f9b23e9f", "filename": "src/lib.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/535a0160d6c2a72f7321edd2de84875c43b655af/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/535a0160d6c2a72f7321edd2de84875c43b655af/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=535a0160d6c2a72f7321edd2de84875c43b655af", "patch": "@@ -610,22 +610,24 @@ pub fn format_input<T: Write>(input: Input,\n \n     let mut report = FormatReport::new();\n \n-    match format_ast(&krate,\n-                     &parse_session,\n-                     &main_file,\n-                     config,\n-                     |file_name, file| {\n-        // For some reason, the codemap does not include terminating\n-        // newlines so we must add one on for each file. This is sad.\n-        filemap::append_newline(file);\n-\n-        format_lines(file, file_name, config, &mut report);\n-\n-        if let Some(ref mut out) = out {\n-            return filemap::write_file(file, file_name, out, config);\n+    match format_ast(\n+        &krate,\n+        &parse_session,\n+        &main_file,\n+        config,\n+        |file_name, file| {\n+            // For some reason, the codemap does not include terminating\n+            // newlines so we must add one on for each file. This is sad.\n+            filemap::append_newline(file);\n+\n+            format_lines(file, file_name, config, &mut report);\n+\n+            if let Some(ref mut out) = out {\n+                return filemap::write_file(file, file_name, out, config);\n+            }\n+            Ok(false)\n         }\n-        Ok(false)\n-    }) {\n+    ) {\n         Ok((file_map, has_diff)) => {\n             if report.has_warnings() {\n                 summary.add_formatting_error();"}, {"sha": "1193e4819eb857e449a730e93a030fb91dadc8d4", "filename": "src/macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/535a0160d6c2a72f7321edd2de84875c43b655af/src%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/535a0160d6c2a72f7321edd2de84875c43b655af/src%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmacros.rs?ref=535a0160d6c2a72f7321edd2de84875c43b655af", "patch": "@@ -205,10 +205,10 @@ pub fn rewrite_macro(mac: &ast::Mac,\n                         context\n                             .codemap\n                             .span_after(mac.span, original_style.opener()),\n-                        mac.span.hi - BytePos(1)\n+                        mac.span.hi - BytePos(1),\n                     ),\n                     context,\n-                    mac_shape\n+                    mac_shape,\n                 ));\n \n                 Some(format!(\"{}{}\", macro_name, rewrite))"}, {"sha": "272e67756abb7b4e572919520147c14c20978cac", "filename": "src/rewrite.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/535a0160d6c2a72f7321edd2de84875c43b655af/src%2Frewrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/535a0160d6c2a72f7321edd2de84875c43b655af/src%2Frewrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frewrite.rs?ref=535a0160d6c2a72f7321edd2de84875c43b655af", "patch": "@@ -27,6 +27,7 @@ pub struct RewriteContext<'a> {\n     pub codemap: &'a CodeMap,\n     pub config: &'a Config,\n     pub inside_macro: bool,\n+    pub use_block: bool,\n }\n \n impl<'a> RewriteContext<'a> {"}, {"sha": "affcbf6b082dbf9d977fa9315875a43307213e06", "filename": "src/visitor.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/535a0160d6c2a72f7321edd2de84875c43b655af/src%2Fvisitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/535a0160d6c2a72f7321edd2de84875c43b655af/src%2Fvisitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fvisitor.rs?ref=535a0160d6c2a72f7321edd2de84875c43b655af", "patch": "@@ -610,6 +610,7 @@ impl<'a> FmtVisitor<'a> {\n             codemap: self.codemap,\n             config: self.config,\n             inside_macro: false,\n+            use_block: false,\n         }\n     }\n }"}, {"sha": "7dd75c52891fae82f13634ecf6e1ad0fe51b1aa7", "filename": "tests/target/nested-visual-block.rs", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/535a0160d6c2a72f7321edd2de84875c43b655af/tests%2Ftarget%2Fnested-visual-block.rs", "raw_url": "https://github.com/rust-lang/rust/raw/535a0160d6c2a72f7321edd2de84875c43b655af/tests%2Ftarget%2Fnested-visual-block.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fnested-visual-block.rs?ref=535a0160d6c2a72f7321edd2de84875c43b655af", "patch": "@@ -0,0 +1,57 @@\n+fn main() {\n+    // #1078\n+    let items = itemize_list(\n+        context.codemap,\n+        field_iter,\n+        \"}\",\n+        |item| match *item {\n+            StructLitField::Regular(ref field) => field.span.lo,\n+            StructLitField::Base(ref expr) => {\n+                let last_field_hi = fields.last().map_or(span.lo, |field| field.span.hi);\n+                let snippet = context.snippet(mk_sp(last_field_hi, expr.span.lo));\n+                let pos = snippet.find_uncommented(\"..\").unwrap();\n+                last_field_hi + BytePos(pos as u32)\n+            }\n+        },\n+        |item| match *item {\n+            StructLitField::Regular(ref field) => field.span.hi,\n+            StructLitField::Base(ref expr) => expr.span.hi,\n+        },\n+        |item| {\n+            match *item {\n+                StructLitField::Regular(ref field) => {\n+                    rewrite_field(inner_context,\n+                                  &field,\n+                                  &Constraints::new(v_budget.checked_sub(1).unwrap_or(0), indent))\n+                }\n+                StructLitField::Base(ref expr) => {\n+                    // 2 = ..\n+                    expr.rewrite(inner_context,\n+                                 &Constraints::new(try_opt!(v_budget.checked_sub(2)), indent + 2))\n+                        .map(|s| format!(\"..{}\", s))\n+                }\n+            }\n+        },\n+        context.codemap.span_after(span, \"{\"),\n+        span.hi,\n+    );\n+\n+    // #1580\n+    self.0.pool.execute(move || {\n+        let _timer = segments.0.rotate_timer.time();\n+        if let Err(e) = segments.rotate_async(wal) {\n+            error!(\"error compacting segment storage WAL\", unsafe { error: e.display() });\n+        }\n+    });\n+\n+    // #1581\n+    bootstrap.checks.register(\n+        \"PERSISTED_LOCATIONS\",\n+        move || if locations2.0.inner_mut.lock().poisoned {\n+            Check::new(State::Error,\n+                       \"Persisted location storage is poisoned due to a write failure\")\n+        } else {\n+            Check::new(State::Healthy, \"Persisted location storage is healthy\")\n+        }\n+    );\n+}"}]}