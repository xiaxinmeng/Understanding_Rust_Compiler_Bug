{"sha": "5157c22eba67e0761e6068dac96368b394efcb0c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUxNTdjMjJlYmE2N2UwNzYxZTYwNjhkYWM5NjM2OGIzOTRlZmNiMGM=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2018-12-23T22:09:05Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-12-23T22:09:05Z"}, "message": "Rollup merge of #56953 - oli-obk:dead_const, r=petrochenkov\n\nMark tuple structs as live if their constructors are used\n\nfixes https://github.com/rust-lang/rust/issues/56281", "tree": {"sha": "2af192eb63c775da0972f305e9adee95f4865abb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2af192eb63c775da0972f305e9adee95f4865abb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5157c22eba67e0761e6068dac96368b394efcb0c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJcIAeBCRBK7hj4Ov3rIwAAdHIIAKTw8khVF/5B/dgYc3sZtqmw\nXC6MZI7QVzHsVc3Gd5L05CPcRO5c+B4K7dbV5Vd0IAHr3unLiZgTmSINqjKvk/Ca\n4XZCbK7WfKoV3sS/rD1obKwwVHXmTiCuxRHl6B2pow2IlB6HUcztv6et/Ox2UjhP\n6IkEDPNMCxA/r/u1xigMTixjzfgP1IwX8Gacgj/0gPL7Otnwyuqj2aABZZXHY7D9\nr+bxTMNQgjYB2HEizM4SrKJ8WyZbz7snZP6TwvyQniO48HiTGmPgHOfDwMM0OJsc\n2F1SFs6pHC0Urzfr6CHYlIJeFZJy+fisfr/b3wao/qnQQ/Mne6fkQe2HCl4uFRs=\n=1k3z\n-----END PGP SIGNATURE-----\n", "payload": "tree 2af192eb63c775da0972f305e9adee95f4865abb\nparent 93af1e73696c82de22eb445423f10df35130dded\nparent 405d8b0bb3d749e3baad25f68455873b66b219be\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1545602945 +0100\ncommitter GitHub <noreply@github.com> 1545602945 +0100\n\nRollup merge of #56953 - oli-obk:dead_const, r=petrochenkov\n\nMark tuple structs as live if their constructors are used\n\nfixes https://github.com/rust-lang/rust/issues/56281\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5157c22eba67e0761e6068dac96368b394efcb0c", "html_url": "https://github.com/rust-lang/rust/commit/5157c22eba67e0761e6068dac96368b394efcb0c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5157c22eba67e0761e6068dac96368b394efcb0c/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "93af1e73696c82de22eb445423f10df35130dded", "url": "https://api.github.com/repos/rust-lang/rust/commits/93af1e73696c82de22eb445423f10df35130dded", "html_url": "https://github.com/rust-lang/rust/commit/93af1e73696c82de22eb445423f10df35130dded"}, {"sha": "405d8b0bb3d749e3baad25f68455873b66b219be", "url": "https://api.github.com/repos/rust-lang/rust/commits/405d8b0bb3d749e3baad25f68455873b66b219be", "html_url": "https://github.com/rust-lang/rust/commit/405d8b0bb3d749e3baad25f68455873b66b219be"}], "stats": {"total": 94, "additions": 51, "deletions": 43}, "files": [{"sha": "3f5b614df9dc236ff9f8bb481afbf5568a30509c", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/5157c22eba67e0761e6068dac96368b394efcb0c/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5157c22eba67e0761e6068dac96368b394efcb0c/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=5157c22eba67e0761e6068dac96368b394efcb0c", "patch": "@@ -2119,7 +2119,7 @@ impl StructField {\n /// Id of the whole enum lives in `Item`.\n ///\n /// For structs: `NodeId` represents an Id of the structure's constructor, so it is not actually\n-/// used for `Struct`-structs (but still presents). Structures don't have an analogue of \"Id of\n+/// used for `Struct`-structs (but still present). Structures don't have an analogue of \"Id of\n /// the variant itself\" from enum variants.\n /// Id of the whole struct lives in `Item`.\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]"}, {"sha": "d2175c28309b1093c34a72f7c247bfebf81ced91", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 38, "deletions": 42, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/5157c22eba67e0761e6068dac96368b394efcb0c/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5157c22eba67e0761e6068dac96368b394efcb0c/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=5157c22eba67e0761e6068dac96368b394efcb0c", "patch": "@@ -25,6 +25,8 @@ use middle::privacy;\n use ty::{self, TyCtxt};\n use util::nodemap::FxHashSet;\n \n+use rustc_data_structures::fx::FxHashMap;\n+\n use syntax::{ast, source_map};\n use syntax::attr;\n use syntax_pos;\n@@ -55,12 +57,15 @@ struct MarkSymbolVisitor<'a, 'tcx: 'a> {\n     in_pat: bool,\n     inherited_pub_visibility: bool,\n     ignore_variant_stack: Vec<DefId>,\n+    // maps from tuple struct constructors to tuple struct items\n+    struct_constructors: FxHashMap<ast::NodeId, ast::NodeId>,\n }\n \n impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n     fn check_def_id(&mut self, def_id: DefId) {\n         if let Some(node_id) = self.tcx.hir().as_local_node_id(def_id) {\n-            if should_explore(self.tcx, node_id) {\n+            if should_explore(self.tcx, node_id) ||\n+               self.struct_constructors.contains_key(&node_id) {\n                 self.worklist.push(node_id);\n             }\n             self.live_symbols.insert(node_id);\n@@ -137,19 +142,23 @@ impl<'a, 'tcx> MarkSymbolVisitor<'a, 'tcx> {\n                 continue\n             }\n \n-            if let Some(ref node) = self.tcx.hir().find(id) {\n+            // in the case of tuple struct constructors we want to check the item, not the generated\n+            // tuple struct constructor function\n+            let id = self.struct_constructors.get(&id).cloned().unwrap_or(id);\n+\n+            if let Some(node) = self.tcx.hir().find(id) {\n                 self.live_symbols.insert(id);\n                 self.visit_node(node);\n             }\n         }\n     }\n \n-    fn visit_node(&mut self, node: &Node<'tcx>) {\n+    fn visit_node(&mut self, node: Node<'tcx>) {\n         let had_repr_c = self.repr_has_repr_c;\n         self.repr_has_repr_c = false;\n         let had_inherited_pub_visibility = self.inherited_pub_visibility;\n         self.inherited_pub_visibility = false;\n-        match *node {\n+        match node {\n             Node::Item(item) => {\n                 match item.node {\n                     hir::ItemKind::Struct(..) | hir::ItemKind::Union(..) => {\n@@ -337,6 +346,8 @@ struct LifeSeeder<'k, 'tcx: 'k> {\n     worklist: Vec<ast::NodeId>,\n     krate: &'k hir::Crate,\n     tcx: TyCtxt<'k, 'tcx, 'tcx>,\n+    // see `MarkSymbolVisitor::struct_constructors`\n+    struct_constructors: FxHashMap<ast::NodeId, ast::NodeId>,\n }\n \n impl<'v, 'k, 'tcx> ItemLikeVisitor<'v> for LifeSeeder<'k, 'tcx> {\n@@ -379,6 +390,9 @@ impl<'v, 'k, 'tcx> ItemLikeVisitor<'v> for LifeSeeder<'k, 'tcx> {\n                     }\n                 }\n             }\n+            hir::ItemKind::Struct(ref variant_data, _) => {\n+                self.struct_constructors.insert(variant_data.id(), item.id);\n+            }\n             _ => ()\n         }\n     }\n@@ -392,11 +406,11 @@ impl<'v, 'k, 'tcx> ItemLikeVisitor<'v> for LifeSeeder<'k, 'tcx> {\n     }\n }\n \n-fn create_and_seed_worklist<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n-                                      access_levels: &privacy::AccessLevels,\n-                                      krate: &hir::Crate)\n-                                      -> Vec<ast::NodeId>\n-{\n+fn create_and_seed_worklist<'a, 'tcx>(\n+    tcx: TyCtxt<'a, 'tcx, 'tcx>,\n+    access_levels: &privacy::AccessLevels,\n+    krate: &hir::Crate,\n+) -> (Vec<ast::NodeId>, FxHashMap<ast::NodeId, ast::NodeId>) {\n     let worklist = access_levels.map.iter().filter_map(|(&id, level)| {\n         if level >= &privacy::AccessLevel::Reachable {\n             Some(id)\n@@ -413,17 +427,18 @@ fn create_and_seed_worklist<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         worklist,\n         krate,\n         tcx,\n+        struct_constructors: Default::default(),\n     };\n     krate.visit_all_item_likes(&mut life_seeder);\n \n-    return life_seeder.worklist;\n+    (life_seeder.worklist, life_seeder.struct_constructors)\n }\n \n fn find_live<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n                        access_levels: &privacy::AccessLevels,\n                        krate: &hir::Crate)\n                        -> FxHashSet<ast::NodeId> {\n-    let worklist = create_and_seed_worklist(tcx, access_levels, krate);\n+    let (worklist, struct_constructors) = create_and_seed_worklist(tcx, access_levels, krate);\n     let mut symbol_visitor = MarkSymbolVisitor {\n         worklist,\n         tcx,\n@@ -433,20 +448,12 @@ fn find_live<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         in_pat: false,\n         inherited_pub_visibility: false,\n         ignore_variant_stack: vec![],\n+        struct_constructors,\n     };\n     symbol_visitor.mark_live_symbols();\n     symbol_visitor.live_symbols\n }\n \n-fn get_struct_ctor_id(item: &hir::Item) -> Option<ast::NodeId> {\n-    match item.node {\n-        hir::ItemKind::Struct(ref struct_def, _) if !struct_def.is_struct() => {\n-            Some(struct_def.id())\n-        }\n-        _ => None\n-    }\n-}\n-\n struct DeadVisitor<'a, 'tcx: 'a> {\n     tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     live_symbols: FxHashSet<ast::NodeId>,\n@@ -464,46 +471,35 @@ impl<'a, 'tcx> DeadVisitor<'a, 'tcx> {\n             | hir::ItemKind::Union(..) => true,\n             _ => false\n         };\n-        let ctor_id = get_struct_ctor_id(item);\n-        should_warn && !self.symbol_is_live(item.id, ctor_id)\n+        should_warn && !self.symbol_is_live(item.id)\n     }\n \n     fn should_warn_about_field(&mut self, field: &hir::StructField) -> bool {\n         let field_type = self.tcx.type_of(self.tcx.hir().local_def_id(field.id));\n         !field.is_positional()\n-            && !self.symbol_is_live(field.id, None)\n+            && !self.symbol_is_live(field.id)\n             && !field_type.is_phantom_data()\n             && !has_allow_dead_code_or_lang_attr(self.tcx, field.id, &field.attrs)\n     }\n \n     fn should_warn_about_variant(&mut self, variant: &hir::VariantKind) -> bool {\n-        !self.symbol_is_live(variant.data.id(), None)\n+        !self.symbol_is_live(variant.data.id())\n             && !has_allow_dead_code_or_lang_attr(self.tcx,\n                                                  variant.data.id(),\n                                                  &variant.attrs)\n     }\n \n     fn should_warn_about_foreign_item(&mut self, fi: &hir::ForeignItem) -> bool {\n-        !self.symbol_is_live(fi.id, None)\n+        !self.symbol_is_live(fi.id)\n             && !has_allow_dead_code_or_lang_attr(self.tcx, fi.id, &fi.attrs)\n     }\n \n     // id := node id of an item's definition.\n-    // ctor_id := `Some` if the item is a struct_ctor (tuple struct),\n-    //            `None` otherwise.\n-    // If the item is a struct_ctor, then either its `id` or\n-    // `ctor_id` (unwrapped) is in the live_symbols set. More specifically,\n-    // DefMap maps the ExprKind::Path of a struct_ctor to the node referred by\n-    // `ctor_id`. On the other hand, in a statement like\n-    // `type <ident> <generics> = <ty>;` where <ty> refers to a struct_ctor,\n-    // DefMap maps <ty> to `id` instead.\n-    fn symbol_is_live(&mut self,\n-                      id: ast::NodeId,\n-                      ctor_id: Option<ast::NodeId>)\n-                      -> bool {\n-        if self.live_symbols.contains(&id)\n-           || ctor_id.map_or(false, |ctor| self.live_symbols.contains(&ctor))\n-        {\n+    fn symbol_is_live(\n+        &mut self,\n+        id: ast::NodeId,\n+    ) -> bool {\n+        if self.live_symbols.contains(&id) {\n             return true;\n         }\n         // If it's a type whose items are live, then it's live, too.\n@@ -611,7 +607,7 @@ impl<'a, 'tcx> Visitor<'tcx> for DeadVisitor<'a, 'tcx> {\n     fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem) {\n         match impl_item.node {\n             hir::ImplItemKind::Const(_, body_id) => {\n-                if !self.symbol_is_live(impl_item.id, None) {\n+                if !self.symbol_is_live(impl_item.id) {\n                     self.warn_dead_code(impl_item.id,\n                                         impl_item.span,\n                                         impl_item.ident.name,\n@@ -621,7 +617,7 @@ impl<'a, 'tcx> Visitor<'tcx> for DeadVisitor<'a, 'tcx> {\n                 self.visit_nested_body(body_id)\n             }\n             hir::ImplItemKind::Method(_, body_id) => {\n-                if !self.symbol_is_live(impl_item.id, None) {\n+                if !self.symbol_is_live(impl_item.id) {\n                     let span = self.tcx.sess.source_map().def_span(impl_item.span);\n                     self.warn_dead_code(impl_item.id, span, impl_item.ident.name, \"method\", \"used\");\n                 }"}, {"sha": "496ce4fb378aec933ca76baac9209e2391e38b3a", "filename": "src/test/ui/dead-code-tuple-struct-field.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/5157c22eba67e0761e6068dac96368b394efcb0c/src%2Ftest%2Fui%2Fdead-code-tuple-struct-field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5157c22eba67e0761e6068dac96368b394efcb0c/src%2Ftest%2Fui%2Fdead-code-tuple-struct-field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fdead-code-tuple-struct-field.rs?ref=5157c22eba67e0761e6068dac96368b394efcb0c", "patch": "@@ -0,0 +1,12 @@\n+// compile-pass\n+\n+#![deny(dead_code)]\n+\n+const LEN: usize = 4;\n+\n+#[derive(Debug)]\n+struct Wrapper([u8; LEN]);\n+\n+fn main() {\n+    println!(\"{:?}\", Wrapper([0, 1, 2, 3]));\n+}"}]}