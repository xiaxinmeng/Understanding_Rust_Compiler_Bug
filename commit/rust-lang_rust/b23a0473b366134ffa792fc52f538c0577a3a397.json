{"sha": "b23a0473b366134ffa792fc52f538c0577a3a397", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIyM2EwNDczYjM2NjEzNGZmYTc5MmZjNTJmNTM4YzA1NzdhM2EzOTc=", "commit": {"author": {"name": "Tim Vermeulen", "email": "tvermeulen@me.com", "date": "2019-03-12T16:52:26Z"}, "committer": {"name": "Tim Vermeulen", "email": "tvermeulen@me.com", "date": "2019-03-12T16:52:26Z"}, "message": "Remove the projection part of select_fold1", "tree": {"sha": "a5faf2cc21660b251390c8513f6928bcc17cc402", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a5faf2cc21660b251390c8513f6928bcc17cc402"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b23a0473b366134ffa792fc52f538c0577a3a397", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b23a0473b366134ffa792fc52f538c0577a3a397", "html_url": "https://github.com/rust-lang/rust/commit/b23a0473b366134ffa792fc52f538c0577a3a397", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b23a0473b366134ffa792fc52f538c0577a3a397/comments", "author": {"login": "timvermeulen", "id": 2904179, "node_id": "MDQ6VXNlcjI5MDQxNzk=", "avatar_url": "https://avatars.githubusercontent.com/u/2904179?v=4", "gravatar_id": "", "url": "https://api.github.com/users/timvermeulen", "html_url": "https://github.com/timvermeulen", "followers_url": "https://api.github.com/users/timvermeulen/followers", "following_url": "https://api.github.com/users/timvermeulen/following{/other_user}", "gists_url": "https://api.github.com/users/timvermeulen/gists{/gist_id}", "starred_url": "https://api.github.com/users/timvermeulen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/timvermeulen/subscriptions", "organizations_url": "https://api.github.com/users/timvermeulen/orgs", "repos_url": "https://api.github.com/users/timvermeulen/repos", "events_url": "https://api.github.com/users/timvermeulen/events{/privacy}", "received_events_url": "https://api.github.com/users/timvermeulen/received_events", "type": "User", "site_admin": false}, "committer": {"login": "timvermeulen", "id": 2904179, "node_id": "MDQ6VXNlcjI5MDQxNzk=", "avatar_url": "https://avatars.githubusercontent.com/u/2904179?v=4", "gravatar_id": "", "url": "https://api.github.com/users/timvermeulen", "html_url": "https://github.com/timvermeulen", "followers_url": "https://api.github.com/users/timvermeulen/followers", "following_url": "https://api.github.com/users/timvermeulen/following{/other_user}", "gists_url": "https://api.github.com/users/timvermeulen/gists{/gist_id}", "starred_url": "https://api.github.com/users/timvermeulen/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/timvermeulen/subscriptions", "organizations_url": "https://api.github.com/users/timvermeulen/orgs", "repos_url": "https://api.github.com/users/timvermeulen/repos", "events_url": "https://api.github.com/users/timvermeulen/events{/privacy}", "received_events_url": "https://api.github.com/users/timvermeulen/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8d18e57b8a957bee7de4586eb1aeecac0ed718d3", "url": "https://api.github.com/repos/rust-lang/rust/commits/8d18e57b8a957bee7de4586eb1aeecac0ed718d3", "html_url": "https://github.com/rust-lang/rust/commit/8d18e57b8a957bee7de4586eb1aeecac0ed718d3"}], "stats": {"total": 77, "additions": 21, "deletions": 56}, "files": [{"sha": "199c6cdfa48bedf983d231a58ac9fdead45a8ccb", "filename": "src/libcore/iter/traits/iterator.rs", "status": "modified", "additions": 21, "deletions": 56, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/b23a0473b366134ffa792fc52f538c0577a3a397/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b23a0473b366134ffa792fc52f538c0577a3a397/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs?ref=b23a0473b366134ffa792fc52f538c0577a3a397", "patch": "@@ -2008,12 +2008,8 @@ pub trait Iterator {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn max(self) -> Option<Self::Item> where Self: Sized, Self::Item: Ord\n     {\n-        select_fold1(self,\n-                     |_| (),\n-                     // switch to y even if it is only equal, to preserve\n-                     // stability.\n-                     |_, x, _, y| *x <= *y)\n-            .map(|(_, x)| x)\n+        // switch to y even if it is only equal, to preserve stability.\n+        select_fold1(self, |x, y| x <= y)\n     }\n \n     /// Returns the minimum element of an iterator.\n@@ -2038,12 +2034,8 @@ pub trait Iterator {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn min(self) -> Option<Self::Item> where Self: Sized, Self::Item: Ord\n     {\n-        select_fold1(self,\n-                     |_| (),\n-                     // only switch to y if it is strictly smaller, to\n-                     // preserve stability.\n-                     |_, x, _, y| *x > *y)\n-            .map(|(_, x)| x)\n+        // only switch to y if it is strictly smaller, to preserve stability.\n+        select_fold1(self, |x, y| x > y)\n     }\n \n     /// Returns the element that gives the maximum value from the\n@@ -2062,15 +2054,11 @@ pub trait Iterator {\n     /// ```\n     #[inline]\n     #[stable(feature = \"iter_cmp_by_key\", since = \"1.6.0\")]\n-    fn max_by_key<B: Ord, F>(self, f: F) -> Option<Self::Item>\n+    fn max_by_key<B: Ord, F>(self, mut f: F) -> Option<Self::Item>\n         where Self: Sized, F: FnMut(&Self::Item) -> B,\n     {\n-        select_fold1(self,\n-                     f,\n-                     // switch to y even if it is only equal, to preserve\n-                     // stability.\n-                     |x_p, _, y_p, _| x_p <= y_p)\n-            .map(|(_, x)| x)\n+        // switch to y even if it is only equal, to preserve stability.\n+        select_fold1(self.map(|x| (f(&x), x)), |(x_p, _), (y_p, _)| x_p <= y_p).map(|(_, x)| x)\n     }\n \n     /// Returns the element that gives the maximum value with respect to the\n@@ -2092,12 +2080,8 @@ pub trait Iterator {\n     fn max_by<F>(self, mut compare: F) -> Option<Self::Item>\n         where Self: Sized, F: FnMut(&Self::Item, &Self::Item) -> Ordering,\n     {\n-        select_fold1(self,\n-                     |_| (),\n-                     // switch to y even if it is only equal, to preserve\n-                     // stability.\n-                     |_, x, _, y| Ordering::Greater != compare(x, y))\n-            .map(|(_, x)| x)\n+        // switch to y even if it is only equal, to preserve stability.\n+        select_fold1(self, |x, y| compare(x, y) != Ordering::Greater)\n     }\n \n     /// Returns the element that gives the minimum value from the\n@@ -2115,15 +2099,11 @@ pub trait Iterator {\n     /// assert_eq!(*a.iter().min_by_key(|x| x.abs()).unwrap(), 0);\n     /// ```\n     #[stable(feature = \"iter_cmp_by_key\", since = \"1.6.0\")]\n-    fn min_by_key<B: Ord, F>(self, f: F) -> Option<Self::Item>\n+    fn min_by_key<B: Ord, F>(self, mut f: F) -> Option<Self::Item>\n         where Self: Sized, F: FnMut(&Self::Item) -> B,\n     {\n-        select_fold1(self,\n-                     f,\n-                     // only switch to y if it is strictly smaller, to\n-                     // preserve stability.\n-                     |x_p, _, y_p, _| x_p > y_p)\n-            .map(|(_, x)| x)\n+        // only switch to y if it is strictly smaller, to preserve stability.\n+        select_fold1(self.map(|x| (f(&x), x)), |(x_p, _), (y_p, _)| x_p > y_p).map(|(_, x)| x)\n     }\n \n     /// Returns the element that gives the minimum value with respect to the\n@@ -2145,12 +2125,8 @@ pub trait Iterator {\n     fn min_by<F>(self, mut compare: F) -> Option<Self::Item>\n         where Self: Sized, F: FnMut(&Self::Item, &Self::Item) -> Ordering,\n     {\n-        select_fold1(self,\n-                     |_| (),\n-                     // switch to y even if it is strictly smaller, to\n-                     // preserve stability.\n-                     |_, x, _, y| Ordering::Greater == compare(x, y))\n-            .map(|(_, x)| x)\n+        // switch to y even if it is strictly smaller, to preserve stability.\n+        select_fold1(self, |x, y| compare(x, y) == Ordering::Greater)\n     }\n \n \n@@ -2693,34 +2669,23 @@ pub trait Iterator {\n     }\n }\n \n-/// Select an element from an iterator based on the given \"projection\"\n-/// and \"comparison\" function.\n+/// Select an element from an iterator based on the given \"comparison\"\n+/// function.\n ///\n /// This is an idiosyncratic helper to try to factor out the\n /// commonalities of {max,min}{,_by}. In particular, this avoids\n /// having to implement optimizations several times.\n #[inline]\n-fn select_fold1<I, B, FProj, FCmp>(mut it: I,\n-                                   mut f_proj: FProj,\n-                                   mut f_cmp: FCmp) -> Option<(B, I::Item)>\n-    where I: Iterator,\n-          FProj: FnMut(&I::Item) -> B,\n-          FCmp: FnMut(&B, &I::Item, &B, &I::Item) -> bool\n+fn select_fold1<I, F>(mut it: I, mut f: F) -> Option<I::Item>\n+    where\n+        I: Iterator,\n+        F: FnMut(&I::Item, &I::Item) -> bool,\n {\n     // start with the first element as our selection. This avoids\n     // having to use `Option`s inside the loop, translating to a\n     // sizeable performance gain (6x in one case).\n     it.next().map(|first| {\n-        let first_p = f_proj(&first);\n-\n-        it.fold((first_p, first), |(sel_p, sel), x| {\n-            let x_p = f_proj(&x);\n-            if f_cmp(&sel_p, &sel, &x_p, &x) {\n-                (x_p, x)\n-            } else {\n-                (sel_p, sel)\n-            }\n-        })\n+        it.fold(first, |sel, x| if f(&sel, &x) { x } else { sel })\n     })\n }\n "}]}