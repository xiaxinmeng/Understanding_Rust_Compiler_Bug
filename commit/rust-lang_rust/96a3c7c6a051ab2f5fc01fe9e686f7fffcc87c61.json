{"sha": "96a3c7c6a051ab2f5fc01fe9e686f7fffcc87c61", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk2YTNjN2M2YTA1MWFiMmY1ZmMwMWZlOWU2ODZmN2ZmZmNjODdjNjE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-23T22:21:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-23T22:21:10Z"}, "message": "auto merge of #19758 : tbu-/rust/pr_fp_name, r=alexcrichton\n\nThis is a [breaking-change].", "tree": {"sha": "05688fe976620a03dd2a3ef37f4a82d0dcca3825", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/05688fe976620a03dd2a3ef37f4a82d0dcca3825"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/96a3c7c6a051ab2f5fc01fe9e686f7fffcc87c61", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/96a3c7c6a051ab2f5fc01fe9e686f7fffcc87c61", "html_url": "https://github.com/rust-lang/rust/commit/96a3c7c6a051ab2f5fc01fe9e686f7fffcc87c61", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/96a3c7c6a051ab2f5fc01fe9e686f7fffcc87c61/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d10642ef0f8976b9fb08500acdff84e3990815fa", "url": "https://api.github.com/repos/rust-lang/rust/commits/d10642ef0f8976b9fb08500acdff84e3990815fa", "html_url": "https://github.com/rust-lang/rust/commit/d10642ef0f8976b9fb08500acdff84e3990815fa"}, {"sha": "16f01cc13f6a092873096c44eed546561b88d245", "url": "https://api.github.com/repos/rust-lang/rust/commits/16f01cc13f6a092873096c44eed546561b88d245", "html_url": "https://github.com/rust-lang/rust/commit/16f01cc13f6a092873096c44eed546561b88d245"}], "stats": {"total": 115, "additions": 59, "deletions": 56}, "files": [{"sha": "55a87973e0f5c2d7767182e80f727d9e4a11aa3d", "filename": "src/libcore/fmt/float.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/96a3c7c6a051ab2f5fc01fe9e686f7fffcc87c61/src%2Flibcore%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96a3c7c6a051ab2f5fc01fe9e686f7fffcc87c61/src%2Flibcore%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Ffloat.rs?ref=96a3c7c6a051ab2f5fc01fe9e686f7fffcc87c61", "patch": "@@ -18,8 +18,8 @@ use char;\n use char::Char;\n use fmt;\n use iter::{range, DoubleEndedIteratorExt};\n-use num::{Float, FPNaN, FPInfinite, ToPrimitive};\n-use num::cast;\n+use num::{cast, Float, ToPrimitive};\n+use num::FpCategory as Fp;\n use ops::FnOnce;\n use result::Result::Ok;\n use slice::{mod, SliceExt};\n@@ -109,11 +109,11 @@ pub fn float_to_str_bytes_common<T: Float, U, F>(\n     let _1: T = Float::one();\n \n     match num.classify() {\n-        FPNaN => return f(\"NaN\".as_bytes()),\n-        FPInfinite if num > _0 => {\n+        Fp::Nan => return f(\"NaN\".as_bytes()),\n+        Fp::Infinite if num > _0 => {\n             return f(\"inf\".as_bytes());\n         }\n-        FPInfinite if num < _0 => {\n+        Fp::Infinite if num < _0 => {\n             return f(\"-inf\".as_bytes());\n         }\n         _ => {}"}, {"sha": "d8b22a085aa94da348aa26ead942c511cb1d335c", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/96a3c7c6a051ab2f5fc01fe9e686f7fffcc87c61/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96a3c7c6a051ab2f5fc01fe9e686f7fffcc87c61/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=96a3c7c6a051ab2f5fc01fe9e686f7fffcc87c61", "patch": "@@ -18,7 +18,8 @@\n \n use intrinsics;\n use mem;\n-use num::{Float, FPNormal, FPCategory, FPZero, FPSubnormal, FPInfinite, FPNaN};\n+use num::Float;\n+use num::FpCategory as Fp;\n use num::from_str_radix;\n use option::Option;\n \n@@ -156,23 +157,23 @@ impl Float for f32 {\n     /// Returns `true` if the number is neither zero, infinite, subnormal or NaN.\n     #[inline]\n     fn is_normal(self) -> bool {\n-        self.classify() == FPNormal\n+        self.classify() == Fp::Normal\n     }\n \n     /// Returns the floating point category of the number. If only one property\n     /// is going to be tested, it is generally faster to use the specific\n     /// predicate instead.\n-    fn classify(self) -> FPCategory {\n+    fn classify(self) -> Fp {\n         const EXP_MASK: u32 = 0x7f800000;\n         const MAN_MASK: u32 = 0x007fffff;\n \n         let bits: u32 = unsafe { mem::transmute(self) };\n         match (bits & MAN_MASK, bits & EXP_MASK) {\n-            (0, 0)        => FPZero,\n-            (_, 0)        => FPSubnormal,\n-            (0, EXP_MASK) => FPInfinite,\n-            (_, EXP_MASK) => FPNaN,\n-            _             => FPNormal,\n+            (0, 0)        => Fp::Zero,\n+            (_, 0)        => Fp::Subnormal,\n+            (0, EXP_MASK) => Fp::Infinite,\n+            (_, EXP_MASK) => Fp::Nan,\n+            _             => Fp::Normal,\n         }\n     }\n "}, {"sha": "a3f5c2df91fac8e839cdca30e7d6a4487c1c646e", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/96a3c7c6a051ab2f5fc01fe9e686f7fffcc87c61/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96a3c7c6a051ab2f5fc01fe9e686f7fffcc87c61/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=96a3c7c6a051ab2f5fc01fe9e686f7fffcc87c61", "patch": "@@ -18,7 +18,8 @@\n \n use intrinsics;\n use mem;\n-use num::{Float, FPNormal, FPCategory, FPZero, FPSubnormal, FPInfinite, FPNaN};\n+use num::Float;\n+use num::FpCategory as Fp;\n use num::from_str_radix;\n use option::Option;\n \n@@ -164,23 +165,23 @@ impl Float for f64 {\n     /// Returns `true` if the number is neither zero, infinite, subnormal or NaN.\n     #[inline]\n     fn is_normal(self) -> bool {\n-        self.classify() == FPNormal\n+        self.classify() == Fp::Normal\n     }\n \n     /// Returns the floating point category of the number. If only one property\n     /// is going to be tested, it is generally faster to use the specific\n     /// predicate instead.\n-    fn classify(self) -> FPCategory {\n+    fn classify(self) -> Fp {\n         const EXP_MASK: u64 = 0x7ff0000000000000;\n         const MAN_MASK: u64 = 0x000fffffffffffff;\n \n         let bits: u64 = unsafe { mem::transmute(self) };\n         match (bits & MAN_MASK, bits & EXP_MASK) {\n-            (0, 0)        => FPZero,\n-            (_, 0)        => FPSubnormal,\n-            (0, EXP_MASK) => FPInfinite,\n-            (_, EXP_MASK) => FPNaN,\n-            _             => FPNormal,\n+            (0, 0)        => Fp::Zero,\n+            (_, 0)        => Fp::Subnormal,\n+            (0, EXP_MASK) => Fp::Infinite,\n+            (_, EXP_MASK) => Fp::Nan,\n+            _             => Fp::Normal,\n         }\n     }\n "}, {"sha": "0d2ce4f60718f8faba2e1a961c3e0c9cf8dc2fae", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/96a3c7c6a051ab2f5fc01fe9e686f7fffcc87c61/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96a3c7c6a051ab2f5fc01fe9e686f7fffcc87c61/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=96a3c7c6a051ab2f5fc01fe9e686f7fffcc87c61", "patch": "@@ -15,8 +15,6 @@\n #![stable]\n #![allow(missing_docs)]\n \n-pub use self::FPCategory::*;\n-\n use {int, i8, i16, i32, i64};\n use {uint, u8, u16, u32, u64};\n use {f32, f64};\n@@ -1222,17 +1220,17 @@ impl_num_cast! { f64,   to_f64 }\n /// Used for representing the classification of floating point numbers\n #[deriving(Copy, PartialEq, Show)]\n #[unstable = \"may be renamed\"]\n-pub enum FPCategory {\n+pub enum FpCategory {\n     /// \"Not a Number\", often obtained by dividing by zero\n-    FPNaN,\n+    Nan,\n     /// Positive or negative infinity\n-    FPInfinite ,\n+    Infinite ,\n     /// Positive or negative zero\n-    FPZero,\n-    /// De-normalized floating point representation (less precise than `FPNormal`)\n-    FPSubnormal,\n+    Zero,\n+    /// De-normalized floating point representation (less precise than `Normal`)\n+    Subnormal,\n     /// A regular floating point number\n-    FPNormal,\n+    Normal,\n }\n \n /// A built-in floating point number.\n@@ -1277,7 +1275,7 @@ pub trait Float\n     /// Returns true if this number is neither zero, infinite, denormal, or NaN.\n     fn is_normal(self) -> bool;\n     /// Returns the category that this number falls into.\n-    fn classify(self) -> FPCategory;\n+    fn classify(self) -> FpCategory;\n \n     // FIXME (#5527): These should be associated constants\n "}, {"sha": "830d96fe172bcb5a8688006b24fd68f70d85ad2a", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/96a3c7c6a051ab2f5fc01fe9e686f7fffcc87c61/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96a3c7c6a051ab2f5fc01fe9e686f7fffcc87c61/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=96a3c7c6a051ab2f5fc01fe9e686f7fffcc87c61", "patch": "@@ -201,8 +201,9 @@ use std;\n use std::collections::{HashMap, BTreeMap};\n use std::{char, f64, fmt, io, num, str};\n use std::mem::{swap, transmute};\n-use std::num::{Float, FPNaN, FPInfinite, Int};\n-use std::str::{FromStr};\n+use std::num::{Float, Int};\n+use std::num::FpCategory as Fp;\n+use std::str::FromStr;\n use std::string;\n use std::ops;\n use unicode::str as unicode_str;\n@@ -414,7 +415,7 @@ fn spaces(wr: &mut io::Writer, mut n: uint) -> Result<(), io::IoError> {\n \n fn fmt_number_or_null(v: f64) -> string::String {\n     match v.classify() {\n-        FPNaN | FPInfinite => string::String::from_str(\"null\"),\n+        Fp::Nan | Fp::Infinite => string::String::from_str(\"null\"),\n         _ if v.fract() != 0f64 => f64::to_str_digits(v, 6u),\n         _ => f64::to_str_digits(v, 6u) + \".0\",\n     }\n@@ -2332,7 +2333,7 @@ impl ToJson for f32 {\n impl ToJson for f64 {\n     fn to_json(&self) -> Json {\n         match self.classify() {\n-            FPNaN | FPInfinite => Json::Null,\n+            Fp::Nan | Fp::Infinite => Json::Null,\n             _                  => Json::F64(*self)\n         }\n     }"}, {"sha": "1f76382ce8a41c153b5d6983e8f142a39d717c84", "filename": "src/libstd/num/f32.rs", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/96a3c7c6a051ab2f5fc01fe9e686f7fffcc87c61/src%2Flibstd%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96a3c7c6a051ab2f5fc01fe9e686f7fffcc87c61/src%2Flibstd%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff32.rs?ref=96a3c7c6a051ab2f5fc01fe9e686f7fffcc87c61", "patch": "@@ -351,6 +351,7 @@ pub fn to_str_exp_digits(num: f32, dig: uint, upper: bool) -> String {\n mod tests {\n     use f32::*;\n     use num::*;\n+    use num::FpCategory as Fp;\n \n     #[test]\n     fn test_min_nan() {\n@@ -620,14 +621,14 @@ mod tests {\n         let neg_inf: f32 = Float::neg_infinity();\n         let zero: f32 = Float::zero();\n         let neg_zero: f32 = Float::neg_zero();\n-        assert_eq!(nan.classify(), FPNaN);\n-        assert_eq!(inf.classify(), FPInfinite);\n-        assert_eq!(neg_inf.classify(), FPInfinite);\n-        assert_eq!(zero.classify(), FPZero);\n-        assert_eq!(neg_zero.classify(), FPZero);\n-        assert_eq!(1f32.classify(), FPNormal);\n-        assert_eq!(1e-37f32.classify(), FPNormal);\n-        assert_eq!(1e-38f32.classify(), FPSubnormal);\n+        assert_eq!(nan.classify(), Fp::Nan);\n+        assert_eq!(inf.classify(), Fp::Infinite);\n+        assert_eq!(neg_inf.classify(), Fp::Infinite);\n+        assert_eq!(zero.classify(), Fp::Zero);\n+        assert_eq!(neg_zero.classify(), Fp::Zero);\n+        assert_eq!(1f32.classify(), Fp::Normal);\n+        assert_eq!(1e-37f32.classify(), Fp::Normal);\n+        assert_eq!(1e-38f32.classify(), Fp::Subnormal);\n     }\n \n     #[test]"}, {"sha": "221ecf62c058d999a589e30f9c4c312a37f16892", "filename": "src/libstd/num/f64.rs", "status": "modified", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/96a3c7c6a051ab2f5fc01fe9e686f7fffcc87c61/src%2Flibstd%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96a3c7c6a051ab2f5fc01fe9e686f7fffcc87c61/src%2Flibstd%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Ff64.rs?ref=96a3c7c6a051ab2f5fc01fe9e686f7fffcc87c61", "patch": "@@ -359,6 +359,7 @@ pub fn to_str_exp_digits(num: f64, dig: uint, upper: bool) -> String {\n mod tests {\n     use f64::*;\n     use num::*;\n+    use num::FpCategory as Fp;\n \n     #[test]\n     fn test_min_nan() {\n@@ -623,13 +624,13 @@ mod tests {\n         let neg_inf: f64 = Float::neg_infinity();\n         let zero: f64 = Float::zero();\n         let neg_zero: f64 = Float::neg_zero();\n-        assert_eq!(nan.classify(), FPNaN);\n-        assert_eq!(inf.classify(), FPInfinite);\n-        assert_eq!(neg_inf.classify(), FPInfinite);\n-        assert_eq!(zero.classify(), FPZero);\n-        assert_eq!(neg_zero.classify(), FPZero);\n-        assert_eq!(1e-307f64.classify(), FPNormal);\n-        assert_eq!(1e-308f64.classify(), FPSubnormal);\n+        assert_eq!(nan.classify(), Fp::Nan);\n+        assert_eq!(inf.classify(), Fp::Infinite);\n+        assert_eq!(neg_inf.classify(), Fp::Infinite);\n+        assert_eq!(zero.classify(), Fp::Zero);\n+        assert_eq!(neg_zero.classify(), Fp::Zero);\n+        assert_eq!(1e-307f64.classify(), Fp::Normal);\n+        assert_eq!(1e-308f64.classify(), Fp::Subnormal);\n     }\n \n     #[test]"}, {"sha": "7c8763979bb36e3840491c1ce849f5439a44b41a", "filename": "src/libstd/num/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/96a3c7c6a051ab2f5fc01fe9e686f7fffcc87c61/src%2Flibstd%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96a3c7c6a051ab2f5fc01fe9e686f7fffcc87c61/src%2Flibstd%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fmod.rs?ref=96a3c7c6a051ab2f5fc01fe9e686f7fffcc87c61", "patch": "@@ -31,8 +31,7 @@ pub use core::num::{from_int, from_i8, from_i16, from_i32, from_i64};\n pub use core::num::{from_uint, from_u8, from_u16, from_u32, from_u64};\n pub use core::num::{from_f32, from_f64};\n pub use core::num::{FromStrRadix, from_str_radix};\n-pub use core::num::{FPCategory, FPNaN, FPInfinite, FPZero, FPSubnormal};\n-pub use core::num::{FPNormal, Float};\n+pub use core::num::{FpCategory, Float};\n \n #[experimental = \"may be removed or relocated\"]\n pub mod strconv;"}, {"sha": "b1f4e5acb93f4d28119c24f2974e59ed2a5dbb2f", "filename": "src/libstd/num/strconv.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/96a3c7c6a051ab2f5fc01fe9e686f7fffcc87c61/src%2Flibstd%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/96a3c7c6a051ab2f5fc01fe9e686f7fffcc87c61/src%2Flibstd%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fstrconv.rs?ref=96a3c7c6a051ab2f5fc01fe9e686f7fffcc87c61", "patch": "@@ -17,7 +17,8 @@ use self::SignificantDigits::*;\n use self::SignFormat::*;\n \n use char::{mod, Char};\n-use num::{mod, Int, Float, FPNaN, FPInfinite, ToPrimitive};\n+use num::{mod, Int, Float, ToPrimitive};\n+use num::FpCategory as Fp;\n use ops::FnMut;\n use slice::{SliceExt, CloneSliceExt};\n use str::StrExt;\n@@ -199,14 +200,14 @@ pub fn float_to_str_bytes_common<T: Float>(\n     let _1: T = Float::one();\n \n     match num.classify() {\n-        FPNaN => { return (b\"NaN\".to_vec(), true); }\n-        FPInfinite if num > _0 => {\n+        Fp::Nan => { return (b\"NaN\".to_vec(), true); }\n+        Fp::Infinite if num > _0 => {\n             return match sign {\n                 SignAll => (b\"+inf\".to_vec(), true),\n                 _       => (b\"inf\".to_vec(), true)\n             };\n         }\n-        FPInfinite if num < _0 => {\n+        Fp::Infinite if num < _0 => {\n             return match sign {\n                 SignNone => (b\"inf\".to_vec(), true),\n                 _        => (b\"-inf\".to_vec(), true),"}]}