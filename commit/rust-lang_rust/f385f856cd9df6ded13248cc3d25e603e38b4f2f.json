{"sha": "f385f856cd9df6ded13248cc3d25e603e38b4f2f", "node_id": "C_kwDOAAsO6NoAKGYzODVmODU2Y2Q5ZGY2ZGVkMTMyNDhjYzNkMjVlNjAzZTM4YjRmMmY", "commit": {"author": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-04-07T18:54:13Z"}, "committer": {"name": "Camille GILLOT", "email": "gillot.camille@gmail.com", "date": "2022-04-27T20:00:15Z"}, "message": "Use LifetimeRes during lowering.", "tree": {"sha": "b2ebd8bad7cc069b9e4d215681481663f9b31174", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b2ebd8bad7cc069b9e4d215681481663f9b31174"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f385f856cd9df6ded13248cc3d25e603e38b4f2f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f385f856cd9df6ded13248cc3d25e603e38b4f2f", "html_url": "https://github.com/rust-lang/rust/commit/f385f856cd9df6ded13248cc3d25e603e38b4f2f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f385f856cd9df6ded13248cc3d25e603e38b4f2f/comments", "author": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cjgillot", "id": 1822483, "node_id": "MDQ6VXNlcjE4MjI0ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/1822483?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cjgillot", "html_url": "https://github.com/cjgillot", "followers_url": "https://api.github.com/users/cjgillot/followers", "following_url": "https://api.github.com/users/cjgillot/following{/other_user}", "gists_url": "https://api.github.com/users/cjgillot/gists{/gist_id}", "starred_url": "https://api.github.com/users/cjgillot/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cjgillot/subscriptions", "organizations_url": "https://api.github.com/users/cjgillot/orgs", "repos_url": "https://api.github.com/users/cjgillot/repos", "events_url": "https://api.github.com/users/cjgillot/events{/privacy}", "received_events_url": "https://api.github.com/users/cjgillot/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "69985f0175c34fce2b930683c0b165bea61616db", "url": "https://api.github.com/repos/rust-lang/rust/commits/69985f0175c34fce2b930683c0b165bea61616db", "html_url": "https://github.com/rust-lang/rust/commit/69985f0175c34fce2b930683c0b165bea61616db"}], "stats": {"total": 1506, "additions": 708, "deletions": 798}, "files": [{"sha": "37ae41fabf987bd1658983325b560ec4b650ba68", "filename": "compiler/rustc_ast_lowering/src/expr.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f385f856cd9df6ded13248cc3d25e603e38b4f2f/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f385f856cd9df6ded13248cc3d25e603e38b4f2f/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fexpr.rs?ref=f385f856cd9df6ded13248cc3d25e603e38b4f2f", "patch": "@@ -53,7 +53,6 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                         e.span,\n                         seg,\n                         ParamMode::Optional,\n-                        0,\n                         ParenthesizedGenericArgs::Err,\n                         ImplTraitContext::Disallowed(ImplTraitPosition::Path),\n                     ));"}, {"sha": "5a7ecb47dbeecb0b599a96899e234f67bbae2895", "filename": "compiler/rustc_ast_lowering/src/index.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/f385f856cd9df6ded13248cc3d25e603e38b4f2f/compiler%2Frustc_ast_lowering%2Fsrc%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f385f856cd9df6ded13248cc3d25e603e38b4f2f/compiler%2Frustc_ast_lowering%2Fsrc%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Findex.rs?ref=f385f856cd9df6ded13248cc3d25e603e38b4f2f", "patch": "@@ -30,6 +30,7 @@ pub(super) struct NodeCollector<'a, 'hir> {\n     definitions: &'a definitions::Definitions,\n }\n \n+#[tracing::instrument(level = \"debug\", skip(sess, definitions, bodies))]\n pub(super) fn index_hir<'hir>(\n     sess: &Session,\n     definitions: &definitions::Definitions,\n@@ -65,6 +66,7 @@ pub(super) fn index_hir<'hir>(\n }\n \n impl<'a, 'hir> NodeCollector<'a, 'hir> {\n+    #[tracing::instrument(level = \"debug\", skip(self))]\n     fn insert(&mut self, span: Span, hir_id: HirId, node: Node<'hir>) {\n         debug_assert_eq!(self.owner, hir_id.owner);\n         debug_assert_ne!(hir_id.local_id.as_u32(), 0);\n@@ -138,8 +140,8 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         });\n     }\n \n+    #[tracing::instrument(level = \"debug\", skip(self))]\n     fn visit_item(&mut self, i: &'hir Item<'hir>) {\n-        debug!(\"visit_item: {:?}\", i);\n         debug_assert_eq!(i.def_id, self.owner);\n         self.with_parent(i.hir_id(), |this| {\n             if let ItemKind::Struct(ref struct_def, _) = i.kind {\n@@ -152,6 +154,7 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         });\n     }\n \n+    #[tracing::instrument(level = \"debug\", skip(self))]\n     fn visit_foreign_item(&mut self, fi: &'hir ForeignItem<'hir>) {\n         debug_assert_eq!(fi.def_id, self.owner);\n         self.with_parent(fi.hir_id(), |this| {\n@@ -170,13 +173,15 @@ impl<'a, 'hir> Visitor<'hir> for NodeCollector<'a, 'hir> {\n         })\n     }\n \n+    #[tracing::instrument(level = \"debug\", skip(self))]\n     fn visit_trait_item(&mut self, ti: &'hir TraitItem<'hir>) {\n         debug_assert_eq!(ti.def_id, self.owner);\n         self.with_parent(ti.hir_id(), |this| {\n             intravisit::walk_trait_item(this, ti);\n         });\n     }\n \n+    #[tracing::instrument(level = \"debug\", skip(self))]\n     fn visit_impl_item(&mut self, ii: &'hir ImplItem<'hir>) {\n         debug_assert_eq!(ii.def_id, self.owner);\n         self.with_parent(ii.hir_id(), |this| {"}, {"sha": "80503bd066b2f2d79c88a019d80b862e963deae6", "filename": "compiler/rustc_ast_lowering/src/item.rs", "status": "modified", "additions": 42, "deletions": 60, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/f385f856cd9df6ded13248cc3d25e603e38b4f2f/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f385f856cd9df6ded13248cc3d25e603e38b4f2f/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fitem.rs?ref=f385f856cd9df6ded13248cc3d25e603e38b4f2f", "patch": "@@ -1,5 +1,5 @@\n-use super::{AnonymousLifetimeMode, LoweringContext, ParamMode};\n use super::{AstOwner, ImplTraitContext, ImplTraitPosition, ResolverAstLowering};\n+use super::{LoweringContext, ParamMode};\n use crate::{Arena, FnDeclKind};\n \n use rustc_ast::ptr::P;\n@@ -81,13 +81,13 @@ impl<'a, 'hir> ItemLowerer<'a, 'hir> {\n             is_in_loop_condition: false,\n             is_in_trait_impl: false,\n             is_in_dyn_type: false,\n-            anonymous_lifetime_mode: AnonymousLifetimeMode::PassThrough,\n             generator_kind: None,\n             task_context: None,\n             current_item: None,\n-            lifetimes_to_define: Vec::new(),\n+            lifetimes_to_define: Default::default(),\n             is_collecting_anonymous_lifetimes: None,\n             in_scope_lifetimes: Vec::new(),\n+            captured_lifetimes: None,\n             allow_try_trait: Some([sym::try_trait_v2][..].into()),\n             allow_gen_future: Some([sym::gen_future][..].into()),\n             allow_into_future: Some([sym::into_future][..].into()),\n@@ -143,12 +143,12 @@ impl<'a, 'hir> ItemLowerer<'a, 'hir> {\n             LocalDefId { local_def_index }\n         };\n \n-        let parent_hir = self.lower_node(parent_id).unwrap().node().expect_item();\n+        let parent_hir = self.lower_node(parent_id).unwrap();\n         self.with_lctx(item.id, |lctx| {\n             // Evaluate with the lifetimes in `params` in-scope.\n             // This is used to track which lifetimes have already been defined,\n             // and which need to be replicated when lowering an async fn.\n-            match parent_hir.kind {\n+            match parent_hir.node().expect_item().kind {\n                 hir::ItemKind::Impl(hir::Impl { ref of_trait, ref generics, .. }) => {\n                     lctx.is_in_trait_impl = of_trait.is_some();\n                     lctx.in_scope_lifetimes = generics\n@@ -157,7 +157,12 @@ impl<'a, 'hir> ItemLowerer<'a, 'hir> {\n                         .filter(|param| {\n                             matches!(param.kind, hir::GenericParamKind::Lifetime { .. })\n                         })\n-                        .map(|param| param.name)\n+                        .map(|param| {\n+                            let def_id =\n+                                parent_hir.nodes.local_id_to_def_id[&param.hir_id.local_id];\n+                            let name = param.name;\n+                            (name, def_id)\n+                        })\n                         .collect();\n                 }\n                 hir::ItemKind::Trait(_, _, ref generics, ..) => {\n@@ -167,7 +172,12 @@ impl<'a, 'hir> ItemLowerer<'a, 'hir> {\n                         .filter(|param| {\n                             matches!(param.kind, hir::GenericParamKind::Lifetime { .. })\n                         })\n-                        .map(|param| param.name)\n+                        .map(|param| {\n+                            let def_id =\n+                                parent_hir.nodes.local_id_to_def_id[&param.hir_id.local_id];\n+                            let name = param.name;\n+                            (name, def_id)\n+                        })\n                         .collect();\n                 }\n                 _ => {}\n@@ -288,20 +298,11 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                     let body_id =\n                         this.lower_maybe_async_body(span, &decl, asyncness, body.as_deref());\n \n-                    let (generics, decl) = this.add_in_band_defs(\n-                        generics,\n-                        fn_def_id,\n-                        AnonymousLifetimeMode::PassThrough,\n-                        |this, idty| {\n+                    let (generics, decl) =\n+                        this.add_in_band_defs(generics, fn_def_id, |this, idty| {\n                             let ret_id = asyncness.opt_return_id();\n-                            this.lower_fn_decl(\n-                                &decl,\n-                                Some((fn_def_id, idty)),\n-                                FnDeclKind::Fn,\n-                                ret_id,\n-                            )\n-                        },\n-                    );\n+                            this.lower_fn_decl(&decl, Some((id, idty)), FnDeclKind::Fn, ret_id)\n+                        });\n                     let sig = hir::FnSig {\n                         decl,\n                         header: this.lower_fn_header(header),\n@@ -420,11 +421,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 // lifetime to be added, but rather a reference to a\n                 // parent lifetime.\n                 let lowered_trait_def_id = hir_id.expect_owner();\n-                let (generics, (trait_ref, lowered_ty)) = self.add_in_band_defs(\n-                    ast_generics,\n-                    lowered_trait_def_id,\n-                    AnonymousLifetimeMode::CreateParameter,\n-                    |this, _| {\n+                let (generics, (trait_ref, lowered_ty)) =\n+                    self.add_in_band_defs(ast_generics, lowered_trait_def_id, |this, _| {\n                         let trait_ref = trait_ref.as_ref().map(|trait_ref| {\n                             this.lower_trait_ref(\n                                 trait_ref,\n@@ -436,8 +434,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                             .lower_ty(ty, ImplTraitContext::Disallowed(ImplTraitPosition::Type));\n \n                         (trait_ref, lowered_ty)\n-                    },\n-                );\n+                    });\n \n                 let new_impl_items =\n                     self.with_in_scope_lifetime_defs(&ast_generics.params, |this| {\n@@ -750,18 +747,14 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             kind: match i.kind {\n                 ForeignItemKind::Fn(box Fn { ref sig, ref generics, .. }) => {\n                     let fdec = &sig.decl;\n-                    let (generics, (fn_dec, fn_args)) = self.add_in_band_defs(\n-                        generics,\n-                        def_id,\n-                        AnonymousLifetimeMode::PassThrough,\n-                        |this, _| {\n+                    let (generics, (fn_dec, fn_args)) =\n+                        self.add_in_band_defs(generics, def_id, |this, _| {\n                             (\n                                 // Disallow `impl Trait` in foreign items.\n                                 this.lower_fn_decl(fdec, None, FnDeclKind::ExternFn, None),\n                                 this.lower_fn_params_to_names(fdec),\n                             )\n-                        },\n-                    );\n+                        });\n \n                     hir::ForeignItemKind::Fn(fn_dec, fn_args, generics)\n                 }\n@@ -868,13 +861,8 @@ impl<'hir> LoweringContext<'_, 'hir> {\n             }\n             AssocItemKind::Fn(box Fn { ref sig, ref generics, body: None, .. }) => {\n                 let names = self.lower_fn_params_to_names(&sig.decl);\n-                let (generics, sig) = self.lower_method_sig(\n-                    generics,\n-                    sig,\n-                    trait_item_def_id,\n-                    FnDeclKind::Trait,\n-                    None,\n-                );\n+                let (generics, sig) =\n+                    self.lower_method_sig(generics, sig, i.id, FnDeclKind::Trait, None);\n                 (generics, hir::TraitItemKind::Fn(sig, hir::TraitFn::Required(names)))\n             }\n             AssocItemKind::Fn(box Fn { ref sig, ref generics, body: Some(ref body), .. }) => {\n@@ -884,7 +872,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 let (generics, sig) = self.lower_method_sig(\n                     generics,\n                     sig,\n-                    trait_item_def_id,\n+                    i.id,\n                     FnDeclKind::Trait,\n                     asyncness.opt_return_id(),\n                 );\n@@ -958,8 +946,6 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     }\n \n     fn lower_impl_item(&mut self, i: &AssocItem) -> &'hir hir::ImplItem<'hir> {\n-        let impl_item_def_id = self.resolver.local_def_id(i.id);\n-\n         let (generics, kind) = match &i.kind {\n             AssocItemKind::Const(_, ty, expr) => {\n                 let ty = self.lower_ty(ty, ImplTraitContext::Disallowed(ImplTraitPosition::Type));\n@@ -976,7 +962,7 @@ impl<'hir> LoweringContext<'_, 'hir> {\n                 let (generics, sig) = self.lower_method_sig(\n                     generics,\n                     sig,\n-                    impl_item_def_id,\n+                    i.id,\n                     if self.is_in_trait_impl { FnDeclKind::Impl } else { FnDeclKind::Inherent },\n                     asyncness.opt_return_id(),\n                 );\n@@ -1363,17 +1349,15 @@ impl<'hir> LoweringContext<'_, 'hir> {\n         &mut self,\n         generics: &Generics,\n         sig: &FnSig,\n-        fn_def_id: LocalDefId,\n+        id: NodeId,\n         kind: FnDeclKind,\n         is_async: Option<NodeId>,\n     ) -> (hir::Generics<'hir>, hir::FnSig<'hir>) {\n+        let fn_def_id = self.resolver.local_def_id(id);\n         let header = self.lower_fn_header(sig.header);\n-        let (generics, decl) = self.add_in_band_defs(\n-            generics,\n-            fn_def_id,\n-            AnonymousLifetimeMode::PassThrough,\n-            |this, idty| this.lower_fn_decl(&sig.decl, Some((fn_def_id, idty)), kind, is_async),\n-        );\n+        let (generics, decl) = self.add_in_band_defs(generics, fn_def_id, |this, idty| {\n+            this.lower_fn_decl(&sig.decl, Some((id, idty)), kind, is_async)\n+        });\n         (generics, hir::FnSig { header, decl, span: self.lower_span(sig.span) })\n     }\n \n@@ -1498,14 +1482,12 @@ impl<'hir> LoweringContext<'_, 'hir> {\n     }\n \n     fn lower_where_clause(&mut self, wc: &WhereClause) -> hir::WhereClause<'hir> {\n-        self.with_anonymous_lifetime_mode(AnonymousLifetimeMode::ReportError, |this| {\n-            hir::WhereClause {\n-                predicates: this.arena.alloc_from_iter(\n-                    wc.predicates.iter().map(|predicate| this.lower_where_predicate(predicate)),\n-                ),\n-                span: this.lower_span(wc.span),\n-            }\n-        })\n+        hir::WhereClause {\n+            predicates: self.arena.alloc_from_iter(\n+                wc.predicates.iter().map(|predicate| self.lower_where_predicate(predicate)),\n+            ),\n+            span: self.lower_span(wc.span),\n+        }\n     }\n \n     fn lower_where_predicate(&mut self, pred: &WherePredicate) -> hir::WherePredicate<'hir> {"}, {"sha": "c91e93c6a7638c1e5f4472829378bd9ed8e6fb5f", "filename": "compiler/rustc_ast_lowering/src/lib.rs", "status": "modified", "additions": 409, "deletions": 594, "changes": 1003, "blob_url": "https://github.com/rust-lang/rust/blob/f385f856cd9df6ded13248cc3d25e603e38b4f2f/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f385f856cd9df6ded13248cc3d25e603e38b4f2f/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Flib.rs?ref=f385f856cd9df6ded13248cc3d25e603e38b4f2f", "patch": "@@ -44,7 +44,7 @@ use rustc_ast::{self as ast, *};\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::captures::Captures;\n use rustc_data_structures::fingerprint::Fingerprint;\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap};\n use rustc_data_structures::sorted_map::SortedMap;\n use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n use rustc_data_structures::sync::Lrc;\n@@ -53,7 +53,6 @@ use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Namespace, PartialRes, PerNS, Res};\n use rustc_hir::def_id::{DefId, DefPathHash, LocalDefId, CRATE_DEF_ID};\n use rustc_hir::definitions::{DefKey, DefPathData, Definitions};\n-use rustc_hir::intravisit;\n use rustc_hir::{ConstArg, GenericArg, ItemLocalId, ParamName, TraitCandidate};\n use rustc_index::vec::{Idx, IndexVec};\n use rustc_query_system::ich::StableHashingContext;\n@@ -122,27 +121,38 @@ struct LoweringContext<'a, 'hir: 'a> {\n     is_in_trait_impl: bool,\n     is_in_dyn_type: bool,\n \n-    /// What to do when we encounter an \"anonymous lifetime\n-    /// reference\". The term \"anonymous\" is meant to encompass both\n-    /// `'_` lifetimes as well as fully elided cases where nothing is\n-    /// written at all (e.g., `&T` or `std::cell::Ref<T>`).\n-    anonymous_lifetime_mode: AnonymousLifetimeMode,\n-\n     /// Used to create lifetime definitions for anonymous lifetimes.\n     /// When an anonymous lifetime is encountered in a function or impl header and\n     /// requires to create a fresh lifetime parameter, it is added\n     /// to this list. The results of this list are then added to the list of\n     /// lifetime definitions in the corresponding impl or function generics.\n-    lifetimes_to_define: Vec<(Span, NodeId)>,\n+    lifetimes_to_define: FxIndexMap<NodeId, Span>,\n \n     /// If anonymous lifetimes are being collected, this field holds the parent\n     /// `LocalDefId` to create the fresh lifetime parameters' `LocalDefId`.\n     is_collecting_anonymous_lifetimes: Option<LocalDefId>,\n \n     /// Currently in-scope lifetimes defined in impl headers, fn headers, or HRTB.\n-    /// We always store a `normalize_to_macros_2_0()` version of the param-name in this\n-    /// vector.\n-    in_scope_lifetimes: Vec<ParamName>,\n+    in_scope_lifetimes: Vec<(ParamName, LocalDefId)>,\n+\n+    /// Used to handle lifetimes appearing in impl-traits.  When we lower a lifetime,\n+    /// it is inserted in the `FxHashMap`, and the resolution is modified so to point\n+    /// to the lifetime parameter impl-trait will generate.\n+    /// When traversing `for<...>` binders, they are inserted in the `FxHashSet` so\n+    /// we know *not* to rebind the introduced lifetimes.\n+    captured_lifetimes: Option<(\n+        LocalDefId, // parent def_id for new definitions\n+        FxHashMap<\n+            LocalDefId, // original parameter id\n+            (\n+                Span,        // Span\n+                NodeId,      // synthetized parameter id\n+                ParamName,   // parameter name\n+                LifetimeRes, // original resolution\n+            ),\n+        >,\n+        FxHashSet<NodeId>, // traversed binders, to ignore\n+    )>,\n \n     current_hir_id_owner: LocalDefId,\n     item_local_id_counter: hir::ItemLocalId,\n@@ -157,6 +167,45 @@ struct LoweringContext<'a, 'hir: 'a> {\n     allow_into_future: Option<Lrc<[Symbol]>>,\n }\n \n+/// Resolution for a lifetime appearing in a type.\n+#[derive(Copy, Clone, Debug)]\n+pub enum LifetimeRes {\n+    /// Successfully linked the lifetime to a generic parameter.\n+    Param {\n+        /// Id of the generic parameter that introduced it.\n+        param: LocalDefId,\n+        /// Id of the introducing place. That can be:\n+        /// - an item's id, for the item's generic parameters;\n+        /// - a TraitRef's ref_id, identifying the `for<...>` binder;\n+        /// - a BareFn type's id;\n+        /// - a Path's id when this path has parenthesized generic args.\n+        binder: NodeId,\n+    },\n+    /// Created a generic parameter for an anonymous lifetime.\n+    Fresh {\n+        /// Id of the generic parameter that introduced it.\n+        param: LocalDefId,\n+        /// Id to create the HirId.\n+        introducer: Option<NodeId>,\n+        /// Id of the introducing place. See `Param`.\n+        binder: NodeId,\n+    },\n+    /// This variant is used for anonymous lifetimes that we did not resolve during\n+    /// late resolution.  Shifting the work to the HIR lifetime resolver.\n+    Anonymous {\n+        /// Id of the introducing place. See `Param`.\n+        binder: NodeId,\n+        /// Whether this lifetime was spelled or elided.\n+        elided: bool,\n+    },\n+    /// Explicit `'static` lifetime.\n+    Static,\n+    /// Resolution failure.\n+    Error,\n+    /// HACK: This is used to recover the NodeId of an elided lifetime.\n+    ElidedAnchor { start: NodeId, end: NodeId },\n+}\n+\n pub trait ResolverAstLowering {\n     fn def_key(&self, id: DefId) -> DefKey;\n \n@@ -175,6 +224,9 @@ pub trait ResolverAstLowering {\n     /// Obtains resolution for a label with the given `NodeId`.\n     fn get_label_res(&self, id: NodeId) -> Option<NodeId>;\n \n+    /// Obtains resolution for a lifetime with the given `NodeId`.\n+    fn get_lifetime_res(&self, id: NodeId) -> Option<LifetimeRes>;\n+\n     fn create_stable_hashing_context(&self) -> StableHashingContext<'_>;\n \n     fn definitions(&self) -> &Definitions;\n@@ -238,7 +290,7 @@ enum ImplTraitContext<'b, 'a> {\n         /// parameter from `A`.\n         // FIXME(impl_trait): but `required_region_bounds` will ICE later\n         // anyway.\n-        capturable_lifetimes: &'b mut FxHashSet<hir::LifetimeName>,\n+        capturable_lifetimes: &'b mut FxHashSet<hir::ParamName>,\n     },\n     /// `impl Trait` is not accepted in this position.\n     Disallowed(ImplTraitPosition),\n@@ -453,56 +505,6 @@ enum ParenthesizedGenericArgs {\n     Err,\n }\n \n-/// What to do when we encounter an **anonymous** lifetime\n-/// reference. Anonymous lifetime references come in two flavors. You\n-/// have implicit, or fully elided, references to lifetimes, like the\n-/// one in `&T` or `Ref<T>`, and you have `'_` lifetimes, like `&'_ T`\n-/// or `Ref<'_, T>`. These often behave the same, but not always:\n-///\n-/// - certain usages of implicit references are deprecated, like\n-///   `Ref<T>`, and we sometimes just give hard errors in those cases\n-///   as well.\n-/// - for object bounds there is a difference: `Box<dyn Foo>` is not\n-///   the same as `Box<dyn Foo + '_>`.\n-///\n-/// We describe the effects of the various modes in terms of three cases:\n-///\n-/// - **Modern** -- includes all uses of `'_`, but also the lifetime arg\n-///   of a `&` (e.g., the missing lifetime in something like `&T`)\n-/// - **Dyn Bound** -- if you have something like `Box<dyn Foo>`,\n-///   there is an elided lifetime bound (`Box<dyn Foo + 'X>`). These\n-///   elided bounds follow special rules. Note that this only covers\n-///   cases where *nothing* is written; the `'_` in `Box<dyn Foo +\n-///   '_>` is a case of \"modern\" elision.\n-/// - **Deprecated** -- this covers cases like `Ref<T>`, where the lifetime\n-///   parameter to ref is completely elided. `Ref<'_, T>` would be the modern,\n-///   non-deprecated equivalent.\n-///\n-/// Currently, the handling of lifetime elision is somewhat spread out\n-/// between HIR lowering and -- as described below -- the\n-/// `resolve_lifetime` module. Often we \"fallthrough\" to that code by generating\n-/// an \"elided\" or \"underscore\" lifetime name. In the future, we probably want to move\n-/// everything into HIR lowering.\n-#[derive(Copy, Clone, Debug)]\n-pub enum AnonymousLifetimeMode {\n-    /// For **Modern** cases, create a new anonymous region parameter\n-    /// and reference that.\n-    ///\n-    /// For **Dyn Bound** cases, pass responsibility to\n-    /// `resolve_lifetime` code.\n-    ///\n-    /// For **Deprecated** cases, report an error.\n-    CreateParameter,\n-\n-    /// Give a hard error when either `&` or `'_` is written. Used to\n-    /// rule out things like `where T: Foo<'_>`. Does not imply an\n-    /// error on default object bounds (e.g., `Box<dyn Foo>`).\n-    ReportError,\n-\n-    /// Pass responsibility to `resolve_lifetime` code for all cases.\n-    PassThrough,\n-}\n-\n impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     fn with_hir_id_owner(\n         &mut self,\n@@ -688,26 +690,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         )\n     }\n \n-    fn with_anonymous_lifetime_mode<R>(\n-        &mut self,\n-        anonymous_lifetime_mode: AnonymousLifetimeMode,\n-        op: impl FnOnce(&mut Self) -> R,\n-    ) -> R {\n-        debug!(\n-            \"with_anonymous_lifetime_mode(anonymous_lifetime_mode={:?})\",\n-            anonymous_lifetime_mode,\n-        );\n-        let old_anonymous_lifetime_mode = self.anonymous_lifetime_mode;\n-        self.anonymous_lifetime_mode = anonymous_lifetime_mode;\n-        let result = op(self);\n-        self.anonymous_lifetime_mode = old_anonymous_lifetime_mode;\n-        debug!(\n-            \"with_anonymous_lifetime_mode: restoring anonymous_lifetime_mode={:?}\",\n-            old_anonymous_lifetime_mode\n-        );\n-        result\n-    }\n-\n     /// Intercept all spans entering HIR.\n     /// Mark a span as relative to the current owning item.\n     fn lower_span(&self, span: Span) -> Span {\n@@ -727,23 +709,20 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     /// type parameter encountered while evaluating `f`. Definitions\n     /// are created with the parent provided. If no `parent_id` is\n     /// provided, no definitions will be returned.\n-    ///\n-    /// Presuming that in-band lifetimes are enabled, then\n-    /// `self.anonymous_lifetime_mode` will be updated to match the\n-    /// parameter while `f` is running (and restored afterwards).\n     fn collect_in_band_defs<T>(\n         &mut self,\n         parent_def_id: LocalDefId,\n         f: impl FnOnce(&mut Self) -> T,\n-    ) -> (Vec<(Span, NodeId)>, T) {\n+    ) -> (FxIndexMap<NodeId, Span>, T) {\n+        let lifetime_stash = std::mem::take(&mut self.lifetimes_to_define);\n         let was_collecting =\n             std::mem::replace(&mut self.is_collecting_anonymous_lifetimes, Some(parent_def_id));\n-        let len = self.lifetimes_to_define.len();\n \n         let res = f(self);\n \n-        let lifetimes_to_define = self.lifetimes_to_define.split_off(len);\n         self.is_collecting_anonymous_lifetimes = was_collecting;\n+        let lifetimes_to_define = std::mem::replace(&mut self.lifetimes_to_define, lifetime_stash);\n+\n         (lifetimes_to_define, res)\n     }\n \n@@ -765,31 +744,10 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         }\n     }\n \n-    /// When we have either an elided or `'_` lifetime in an impl\n-    /// header, we convert it to an in-band lifetime.\n-    fn collect_fresh_anonymous_lifetime(&mut self, span: Span) -> ParamName {\n-        let Some(parent_def_id) = self.is_collecting_anonymous_lifetimes else { panic!() };\n-\n-        let node_id = self.resolver.next_node_id();\n-\n-        // Add a definition for the in-band lifetime def.\n-        let param_def_id = self.resolver.create_def(\n-            parent_def_id,\n-            node_id,\n-            DefPathData::LifetimeNs(kw::UnderscoreLifetime),\n-            ExpnId::root(),\n-            span.with_parent(None),\n-        );\n-\n-        let hir_name = ParamName::Fresh(param_def_id);\n-        self.lifetimes_to_define.push((span, node_id));\n-        hir_name\n-    }\n-\n-    // Evaluates `f` with the lifetimes in `params` in-scope.\n-    // This is used to track which lifetimes have already been defined, and\n-    // which are new in-band lifetimes that need to have a definition created\n-    // for them.\n+    /// Evaluates `f` with the lifetimes in `params` in-scope.\n+    /// This is used to track which lifetimes have already been defined, and\n+    /// which are new in-band lifetimes that need to have a definition created\n+    /// for them.\n     fn with_in_scope_lifetime_defs<T>(\n         &mut self,\n         params: &[GenericParam],\n@@ -798,7 +756,9 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         let old_len = self.in_scope_lifetimes.len();\n         let lt_def_names = params.iter().filter_map(|param| match param.kind {\n             GenericParamKind::Lifetime { .. } => {\n-                Some(ParamName::Plain(param.ident.normalize_to_macros_2_0()))\n+                let def_id = self.resolver.local_def_id(param.id);\n+                let name = ParamName::Plain(param.ident);\n+                Some((name, def_id))\n             }\n             _ => None,\n         });\n@@ -812,46 +772,39 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n     /// Appends in-band lifetime defs and argument-position `impl\n     /// Trait` defs to the existing set of generics.\n-    ///\n-    /// Presuming that in-band lifetimes are enabled, then\n-    /// `self.anonymous_lifetime_mode` will be updated to match the\n-    /// parameter while `f` is running (and restored afterwards).\n     fn add_in_band_defs<T>(\n         &mut self,\n         generics: &Generics,\n         parent_def_id: LocalDefId,\n-        anonymous_lifetime_mode: AnonymousLifetimeMode,\n         f: impl FnOnce(&mut Self, &mut Vec<hir::GenericParam<'hir>>) -> T,\n     ) -> (hir::Generics<'hir>, T) {\n         let (lifetimes_to_define, (mut lowered_generics, impl_trait_defs, res)) = self\n             .collect_in_band_defs(parent_def_id, |this| {\n-                this.with_anonymous_lifetime_mode(anonymous_lifetime_mode, |this| {\n-                    this.with_in_scope_lifetime_defs(&generics.params, |this| {\n-                        let mut impl_trait_defs = Vec::new();\n-                        // Note: it is necessary to lower generics *before* calling `f`.\n-                        // When lowering `async fn`, there's a final step when lowering\n-                        // the return type that assumes that all in-scope lifetimes have\n-                        // already been added to either `in_scope_lifetimes` or\n-                        // `lifetimes_to_define`. If we swapped the order of these two,\n-                        // in-band-lifetimes introduced by generics or where-clauses\n-                        // wouldn't have been added yet.\n-                        let generics = this.lower_generics_mut(\n-                            generics,\n-                            ImplTraitContext::Universal(\n-                                &mut impl_trait_defs,\n-                                this.current_hir_id_owner,\n-                            ),\n-                        );\n-                        let res = f(this, &mut impl_trait_defs);\n-                        (generics, impl_trait_defs, res)\n-                    })\n+                this.with_in_scope_lifetime_defs(&generics.params, |this| {\n+                    let mut impl_trait_defs = Vec::new();\n+                    // Note: it is necessary to lower generics *before* calling `f`.\n+                    // When lowering `async fn`, there's a final step when lowering\n+                    // the return type that assumes that all in-scope lifetimes have\n+                    // already been added to either `in_scope_lifetimes` or\n+                    // `lifetimes_to_define`. If we swapped the order of these two,\n+                    // in-band-lifetimes introduced by generics or where-clauses\n+                    // wouldn't have been added yet.\n+                    let generics = this.lower_generics_mut(\n+                        generics,\n+                        ImplTraitContext::Universal(\n+                            &mut impl_trait_defs,\n+                            this.current_hir_id_owner,\n+                        ),\n+                    );\n+                    let res = f(this, &mut impl_trait_defs);\n+                    (generics, impl_trait_defs, res)\n                 })\n             });\n \n         lowered_generics.params.extend(\n             lifetimes_to_define\n                 .into_iter()\n-                .map(|(span, node_id)| self.fresh_lifetime_to_generic_param(span, node_id))\n+                .map(|(node_id, span)| self.fresh_lifetime_to_generic_param(span, node_id))\n                 .chain(impl_trait_defs),\n         );\n \n@@ -1258,26 +1211,40 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             TyKind::Slice(ref ty) => hir::TyKind::Slice(self.lower_ty(ty, itctx)),\n             TyKind::Ptr(ref mt) => hir::TyKind::Ptr(self.lower_mt(mt, itctx)),\n             TyKind::Rptr(ref region, ref mt) => {\n-                let span = self.sess.source_map().next_point(t.span.shrink_to_lo());\n-                let lifetime = match *region {\n-                    Some(ref lt) => self.lower_lifetime(lt),\n-                    None => self.elided_ref_lifetime(span),\n-                };\n+                let region = region.unwrap_or_else(|| {\n+                    let Some(LifetimeRes::ElidedAnchor { start, end }) = self.resolver.get_lifetime_res(t.id) else {\n+                        panic!()\n+                    };\n+                    debug_assert_eq!(start.plus(1), end);\n+                    let span = self.sess.source_map().next_point(t.span.shrink_to_lo());\n+                    Lifetime {\n+                        ident: Ident::new(kw::UnderscoreLifetime, span),\n+                        id: start,\n+                    }\n+                });\n+                let lifetime = self.lower_lifetime(&region);\n                 hir::TyKind::Rptr(lifetime, self.lower_mt(mt, itctx))\n             }\n             TyKind::BareFn(ref f) => self.with_in_scope_lifetime_defs(&f.generic_params, |this| {\n-                this.with_anonymous_lifetime_mode(AnonymousLifetimeMode::PassThrough, |this| {\n-                    hir::TyKind::BareFn(this.arena.alloc(hir::BareFnTy {\n-                        generic_params: this.lower_generic_params(\n-                            &f.generic_params,\n-                            ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n-                        ),\n-                        unsafety: this.lower_unsafety(f.unsafety),\n-                        abi: this.lower_extern(f.ext),\n-                        decl: this.lower_fn_decl(&f.decl, None, FnDeclKind::Pointer, None),\n-                        param_names: this.lower_fn_params_to_names(&f.decl),\n-                    }))\n-                })\n+                if let Some((_, _, binders)) = &mut this.captured_lifetimes {\n+                    binders.insert(t.id);\n+                }\n+\n+                let ret = hir::TyKind::BareFn(this.arena.alloc(hir::BareFnTy {\n+                    generic_params: this.lower_generic_params(\n+                        &f.generic_params,\n+                        ImplTraitContext::Disallowed(ImplTraitPosition::Generic),\n+                    ),\n+                    unsafety: this.lower_unsafety(f.unsafety),\n+                    abi: this.lower_extern(f.ext),\n+                    decl: this.lower_fn_decl(&f.decl, None, FnDeclKind::Pointer, None),\n+                    param_names: this.lower_fn_params_to_names(&f.decl),\n+                }));\n+\n+                if let Some((_, _, binders)) = &mut this.captured_lifetimes {\n+                    binders.remove(&t.id);\n+                }\n+                ret\n             }),\n             TyKind::Never => hir::TyKind::Never,\n             TyKind::Tup(ref tys) => {\n@@ -1421,20 +1388,16 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         hir::Ty { kind, span: self.lower_span(t.span), hir_id: self.lower_node_id(t.id) }\n     }\n \n+    #[tracing::instrument(level = \"debug\", skip(self, lower_bounds))]\n     fn lower_opaque_impl_trait(\n         &mut self,\n         span: Span,\n         fn_def_id: Option<LocalDefId>,\n         origin: hir::OpaqueTyOrigin,\n         opaque_ty_node_id: NodeId,\n-        capturable_lifetimes: Option<&FxHashSet<hir::LifetimeName>>,\n+        capturable_lifetimes: Option<&FxHashSet<hir::ParamName>>,\n         lower_bounds: impl FnOnce(&mut Self) -> hir::GenericBounds<'hir>,\n     ) -> hir::TyKind<'hir> {\n-        debug!(\n-            \"lower_opaque_impl_trait(fn_def_id={:?}, opaque_ty_node_id={:?}, span={:?})\",\n-            fn_def_id, opaque_ty_node_id, span,\n-        );\n-\n         // Make sure we know that some funky desugaring has been going on here.\n         // This is a first: there is code in other places like for loop\n         // desugaring that explicitly states that we don't want to track that.\n@@ -1444,48 +1407,44 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n         let opaque_ty_def_id = self.resolver.local_def_id(opaque_ty_node_id);\n \n-        let mut collected_lifetimes = Vec::new();\n+        let mut collected_lifetimes = FxHashMap::default();\n         self.with_hir_id_owner(opaque_ty_node_id, |lctx| {\n+            let lifetime_stash = std::mem::replace(\n+                &mut lctx.captured_lifetimes,\n+                Some((opaque_ty_def_id, FxHashMap::default(), FxHashSet::default())),\n+            );\n             let hir_bounds = lower_bounds(lctx);\n+            collected_lifetimes =\n+                std::mem::replace(&mut lctx.captured_lifetimes, lifetime_stash).unwrap().1;\n \n-            collected_lifetimes = lifetimes_from_impl_trait_bounds(\n-                opaque_ty_node_id,\n-                &hir_bounds,\n-                capturable_lifetimes,\n-            );\n+            if let Some(capturable_lifetimes) = capturable_lifetimes {\n+                collected_lifetimes.retain(|_, (_, _, p_name, _)| {\n+                    capturable_lifetimes.contains(&p_name.normalize_to_macros_2_0())\n+                });\n+            }\n+            debug!(?collected_lifetimes);\n \n-            let lifetime_defs =\n-                lctx.arena.alloc_from_iter(collected_lifetimes.iter().map(|&(name, span)| {\n-                    let def_node_id = lctx.resolver.next_node_id();\n-                    lctx.resolver.create_def(\n-                        opaque_ty_def_id,\n-                        def_node_id,\n-                        DefPathData::LifetimeNs(name.ident().name),\n-                        ExpnId::root(),\n-                        span.with_parent(None),\n-                    );\n-                    let hir_id = lctx.lower_node_id(def_node_id);\n+            let lifetime_defs = lctx.arena.alloc_from_iter(collected_lifetimes.iter().map(\n+                |(_, &(span, p_id, p_name, _))| {\n+                    let hir_id = lctx.lower_node_id(p_id);\n+                    debug_assert_ne!(lctx.resolver.opt_local_def_id(p_id), None);\n \n-                    let (name, kind) = match name {\n-                        hir::LifetimeName::Underscore => (\n-                            hir::ParamName::Plain(Ident::with_dummy_span(kw::UnderscoreLifetime)),\n-                            hir::LifetimeParamKind::Elided,\n-                        ),\n-                        hir::LifetimeName::Param(param_name) => {\n-                            (param_name, hir::LifetimeParamKind::Explicit)\n-                        }\n-                        _ => panic!(\"expected `LifetimeName::Param` or `ParamName::Plain`\"),\n+                    let kind = if p_name.ident().name == kw::UnderscoreLifetime {\n+                        hir::LifetimeParamKind::Elided\n+                    } else {\n+                        hir::LifetimeParamKind::Explicit\n                     };\n \n                     hir::GenericParam {\n                         hir_id,\n-                        name,\n+                        name: p_name,\n                         span,\n                         pure_wrt_drop: false,\n                         bounds: &[],\n                         kind: hir::GenericParamKind::Lifetime { kind },\n                     }\n-                }));\n+                },\n+            ));\n \n             debug!(\"lower_opaque_impl_trait: lifetime_defs={:#?}\", lifetime_defs);\n \n@@ -1503,10 +1462,14 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             lctx.generate_opaque_type(opaque_ty_def_id, opaque_ty_item, span, opaque_ty_span)\n         });\n \n-        let lifetimes =\n-            self.arena.alloc_from_iter(collected_lifetimes.into_iter().map(|(name, span)| {\n-                hir::GenericArg::Lifetime(hir::Lifetime { hir_id: self.next_id(), span, name })\n-            }));\n+        let lifetimes = self.arena.alloc_from_iter(collected_lifetimes.into_iter().map(\n+            |(_, (span, _, p_name, res))| {\n+                let id = self.resolver.next_node_id();\n+                let ident = Ident::new(p_name.ident().name, span);\n+                let l = self.new_named_lifetime_with_res(id, span, ident, res);\n+                hir::GenericArg::Lifetime(l)\n+            },\n+        ));\n \n         debug!(\"lower_opaque_impl_trait: lifetimes={:#?}\", lifetimes);\n \n@@ -1565,7 +1528,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     fn lower_fn_decl(\n         &mut self,\n         decl: &FnDecl,\n-        mut in_band_ty_params: Option<(LocalDefId, &mut Vec<hir::GenericParam<'hir>>)>,\n+        mut in_band_ty_params: Option<(NodeId, &mut Vec<hir::GenericParam<'hir>>)>,\n         kind: FnDeclKind,\n         make_ret_async: Option<NodeId>,\n     ) -> &'hir hir::FnDecl<'hir> {\n@@ -1577,50 +1540,38 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             make_ret_async: {:?})\",\n             decl, in_band_ty_params, kind, make_ret_async,\n         );\n-        let lt_mode = if make_ret_async.is_some() {\n-            // In `async fn`, argument-position elided lifetimes\n-            // must be transformed into fresh generic parameters so that\n-            // they can be applied to the opaque `impl Trait` return type.\n-            AnonymousLifetimeMode::CreateParameter\n-        } else {\n-            self.anonymous_lifetime_mode\n-        };\n \n         let c_variadic = decl.c_variadic();\n \n-        // Remember how many lifetimes were already around so that we can\n-        // only look at the lifetime parameters introduced by the arguments.\n-        let inputs = self.with_anonymous_lifetime_mode(lt_mode, |this| {\n-            // Skip the `...` (`CVarArgs`) trailing arguments from the AST,\n-            // as they are not explicit in HIR/Ty function signatures.\n-            // (instead, the `c_variadic` flag is set to `true`)\n-            let mut inputs = &decl.inputs[..];\n-            if c_variadic {\n-                inputs = &inputs[..inputs.len() - 1];\n+        // Skip the `...` (`CVarArgs`) trailing arguments from the AST,\n+        // as they are not explicit in HIR/Ty function signatures.\n+        // (instead, the `c_variadic` flag is set to `true`)\n+        let mut inputs = &decl.inputs[..];\n+        if c_variadic {\n+            inputs = &inputs[..inputs.len() - 1];\n+        }\n+        let inputs = self.arena.alloc_from_iter(inputs.iter().map(|param| {\n+            if let Some((_, ibty)) = &mut in_band_ty_params {\n+                self.lower_ty_direct(\n+                    &param.ty,\n+                    ImplTraitContext::Universal(ibty, self.current_hir_id_owner),\n+                )\n+            } else {\n+                self.lower_ty_direct(\n+                    &param.ty,\n+                    ImplTraitContext::Disallowed(match kind {\n+                        FnDeclKind::Fn | FnDeclKind::Inherent => {\n+                            unreachable!(\"fn should allow in-band lifetimes\")\n+                        }\n+                        FnDeclKind::ExternFn => ImplTraitPosition::ExternFnParam,\n+                        FnDeclKind::Closure => ImplTraitPosition::ClosureParam,\n+                        FnDeclKind::Pointer => ImplTraitPosition::PointerParam,\n+                        FnDeclKind::Trait => ImplTraitPosition::TraitParam,\n+                        FnDeclKind::Impl => ImplTraitPosition::ImplParam,\n+                    }),\n+                )\n             }\n-            this.arena.alloc_from_iter(inputs.iter().map(|param| {\n-                if let Some((_, ibty)) = &mut in_band_ty_params {\n-                    this.lower_ty_direct(\n-                        &param.ty,\n-                        ImplTraitContext::Universal(ibty, this.current_hir_id_owner),\n-                    )\n-                } else {\n-                    this.lower_ty_direct(\n-                        &param.ty,\n-                        ImplTraitContext::Disallowed(match kind {\n-                            FnDeclKind::Fn | FnDeclKind::Inherent => {\n-                                unreachable!(\"fn should allow in-band lifetimes\")\n-                            }\n-                            FnDeclKind::ExternFn => ImplTraitPosition::ExternFnParam,\n-                            FnDeclKind::Closure => ImplTraitPosition::ClosureParam,\n-                            FnDeclKind::Pointer => ImplTraitPosition::PointerParam,\n-                            FnDeclKind::Trait => ImplTraitPosition::TraitParam,\n-                            FnDeclKind::Impl => ImplTraitPosition::ImplParam,\n-                        }),\n-                    )\n-                }\n-            }))\n-        });\n+        }));\n \n         let output = if let Some(ret_id) = make_ret_async {\n             self.lower_async_fn_ret_ty(\n@@ -1632,10 +1583,11 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             match decl.output {\n                 FnRetTy::Ty(ref ty) => {\n                     let context = match in_band_ty_params {\n-                        Some((def_id, _)) if kind.impl_trait_return_allowed() => {\n+                        Some((node_id, _)) if kind.impl_trait_return_allowed() => {\n+                            let fn_def_id = self.resolver.local_def_id(node_id);\n                             ImplTraitContext::ReturnPositionOpaqueTy {\n-                                fn_def_id: def_id,\n-                                origin: hir::OpaqueTyOrigin::FnReturn(def_id),\n+                                fn_def_id,\n+                                origin: hir::OpaqueTyOrigin::FnReturn(fn_def_id),\n                             }\n                         }\n                         _ => ImplTraitContext::Disallowed(match kind {\n@@ -1696,25 +1648,19 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n     // `fn_def_id`: `DefId` of the parent function (used to create child impl trait definition)\n     // `opaque_ty_node_id`: `NodeId` of the opaque `impl Trait` type that should be created\n     // `elided_lt_replacement`: replacement for elided lifetimes in the return type\n+    #[tracing::instrument(level = \"debug\", skip(self))]\n     fn lower_async_fn_ret_ty(\n         &mut self,\n         output: &FnRetTy,\n-        fn_def_id: LocalDefId,\n+        fn_node_id: NodeId,\n         opaque_ty_node_id: NodeId,\n     ) -> hir::FnRetTy<'hir> {\n-        debug!(\n-            \"lower_async_fn_ret_ty(\\\n-             output={:?}, \\\n-             fn_def_id={:?}, \\\n-             opaque_ty_node_id={:?})\",\n-            output, fn_def_id, opaque_ty_node_id,\n-        );\n-\n         let span = output.span();\n \n         let opaque_ty_span = self.mark_span_with_reason(DesugaringKind::Async, span, None);\n \n         let opaque_ty_def_id = self.resolver.local_def_id(opaque_ty_node_id);\n+        let fn_def_id = self.resolver.local_def_id(fn_node_id);\n \n         // When we create the opaque type for this async fn, it is going to have\n         // to capture all the lifetimes involved in the signature (including in the\n@@ -1761,59 +1707,68 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         // by the opaque type. This should include all in-scope\n         // lifetime parameters, including those defined in-band.\n         //\n-        // `lifetime_params` is a vector of tuple (span, parameter name, lifetime name).\n-\n-        // Input lifetime like `'a` or `'1`:\n-        let mut lifetime_params: Vec<_> = self\n-            .in_scope_lifetimes\n-            .iter()\n-            .cloned()\n-            .map(|name| (name.ident().span, hir::LifetimeName::Param(name)))\n-            .chain(self.lifetimes_to_define.iter().map(|&(span, node_id)| {\n-                let def_id = self.resolver.local_def_id(node_id);\n-                let name = hir::ParamName::Fresh(def_id);\n-                (span, hir::LifetimeName::Param(name))\n-            }))\n-            .collect();\n \n-        self.with_hir_id_owner(opaque_ty_node_id, |this| {\n-            let mut generic_params: Vec<_> = lifetime_params\n-                .iter()\n-                .map(|&(span, name)| {\n-                    // We can only get lifetime names from the outside.\n-                    let hir::LifetimeName::Param(hir_name) = name else { panic!() };\n-\n-                    let node_id = this.resolver.next_node_id();\n-\n-                    // Add a definition for the in-band lifetime def.\n-                    let def_id = this.resolver.create_def(\n-                        opaque_ty_def_id,\n-                        node_id,\n-                        DefPathData::LifetimeNs(hir_name.ident().name),\n-                        ExpnId::root(),\n-                        span.with_parent(None),\n-                    );\n+        // Input lifetime like `'a`:\n+        let mut captures = FxHashMap::default();\n+        for &(p_name, def_id) in &self.in_scope_lifetimes {\n+            let Ident { name, span } = p_name.ident();\n+            let node_id = self.resolver.next_node_id();\n+\n+            // Add a definition for the in-band lifetime def.\n+            self.resolver.create_def(\n+                opaque_ty_def_id,\n+                node_id,\n+                DefPathData::LifetimeNs(name),\n+                ExpnId::root(),\n+                span.with_parent(None),\n+            );\n \n-                    let (kind, name) = match hir_name {\n-                        ParamName::Plain(ident) => {\n-                            (hir::LifetimeParamKind::Explicit, hir::ParamName::Plain(ident))\n-                        }\n-                        ParamName::Fresh(_) => {\n-                            (hir::LifetimeParamKind::Elided, hir::ParamName::Fresh(def_id))\n-                        }\n-                        ParamName::Error => (hir::LifetimeParamKind::Error, hir::ParamName::Error),\n-                    };\n+            let res = match p_name {\n+                hir::ParamName::Plain(_) => {\n+                    LifetimeRes::Param { param: def_id, binder: fn_node_id }\n+                }\n+                hir::ParamName::Fresh(_) => {\n+                    LifetimeRes::Fresh { param: def_id, introducer: None, binder: fn_node_id }\n+                }\n+                hir::ParamName::Error => LifetimeRes::Error,\n+            };\n \n-                    hir::GenericParam {\n-                        hir_id: this.lower_node_id(node_id),\n-                        name,\n-                        bounds: &[],\n-                        span: this.lower_span(span),\n-                        pure_wrt_drop: false,\n-                        kind: hir::GenericParamKind::Lifetime { kind },\n-                    }\n-                })\n-                .collect();\n+            captures.insert(def_id, (span, node_id, p_name, res));\n+        }\n+\n+        // Input lifetime like `'1`:\n+        for (&node_id, &span) in &self.lifetimes_to_define {\n+            let def_id = self.resolver.local_def_id(node_id);\n+            let new_node_id = self.resolver.next_node_id();\n+\n+            // Add a definition for the in-band lifetime def.\n+            let new_def_id = self.resolver.create_def(\n+                opaque_ty_def_id,\n+                new_node_id,\n+                DefPathData::LifetimeNs(kw::UnderscoreLifetime),\n+                ExpnId::root(),\n+                span.with_parent(None),\n+            );\n+\n+            captures.insert(\n+                def_id,\n+                (\n+                    span,\n+                    new_node_id,\n+                    hir::ParamName::Fresh(new_def_id),\n+                    LifetimeRes::Fresh { param: def_id, introducer: None, binder: fn_node_id },\n+                ),\n+            );\n+        }\n+\n+        debug!(?captures);\n+\n+        self.with_hir_id_owner(opaque_ty_node_id, |this| {\n+            let lifetime_stash = std::mem::replace(\n+                &mut this.captured_lifetimes,\n+                Some((opaque_ty_def_id, std::mem::take(&mut captures), FxHashSet::default())),\n+            );\n+            debug!(\"lower_async_fn_ret_ty: lifetimes_to_define={:#?}\", this.lifetimes_to_define);\n \n             // We have to be careful to get elision right here. The\n             // idea is that we create a lifetime parameter for each\n@@ -1823,23 +1778,32 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             //\n             // Then, we will create `fn foo(..) -> Foo<'_, '_>`, and\n             // hence the elision takes place at the fn site.\n-            let (lifetimes_to_define, future_bound) =\n-                this.with_anonymous_lifetime_mode(AnonymousLifetimeMode::CreateParameter, |this| {\n-                    this.collect_in_band_defs(opaque_ty_def_id, |this| {\n-                        this.lower_async_fn_output_type_to_future_bound(output, fn_def_id, span)\n-                    })\n-                });\n+            let future_bound =\n+                this.lower_async_fn_output_type_to_future_bound(output, fn_def_id, span);\n             debug!(\"lower_async_fn_ret_ty: future_bound={:#?}\", future_bound);\n-            debug!(\"lower_async_fn_ret_ty: lifetimes_to_define={:#?}\", lifetimes_to_define);\n+            captures = std::mem::replace(&mut this.captured_lifetimes, lifetime_stash).unwrap().1;\n+            debug!(\"lower_async_fn_ret_ty: captures={:#?}\", captures);\n \n-            // Output lifetime like `'_`:\n-            for (span, node_id) in lifetimes_to_define {\n-                let param = this.fresh_lifetime_to_generic_param(span, node_id);\n-                lifetime_params.push((span, hir::LifetimeName::Implicit));\n-                generic_params.push(param);\n-            }\n-            let generic_params = this.arena.alloc_from_iter(generic_params);\n-            debug!(\"lower_async_fn_ret_ty: lifetime_params={:#?}\", lifetime_params);\n+            let generic_params =\n+                this.arena.alloc_from_iter(captures.iter().map(|(_, &(span, p_id, p_name, _))| {\n+                    let hir_id = this.lower_node_id(p_id);\n+                    debug_assert_ne!(this.resolver.opt_local_def_id(p_id), None);\n+\n+                    let kind = if p_name.ident().name == kw::UnderscoreLifetime {\n+                        hir::LifetimeParamKind::Elided\n+                    } else {\n+                        hir::LifetimeParamKind::Explicit\n+                    };\n+\n+                    hir::GenericParam {\n+                        hir_id,\n+                        name: p_name,\n+                        span,\n+                        pure_wrt_drop: false,\n+                        bounds: &[],\n+                        kind: hir::GenericParamKind::Lifetime { kind },\n+                    }\n+                }));\n             debug!(\"lower_async_fn_ret_ty: generic_params={:#?}\", generic_params);\n \n             let opaque_ty_item = hir::OpaqueTy {\n@@ -1856,8 +1820,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             this.generate_opaque_type(opaque_ty_def_id, opaque_ty_item, span, opaque_ty_span)\n         });\n \n-        // As documented above on the variable\n-        // `input_lifetimes_count`, we need to create the lifetime\n+        // As documented above, we need to create the lifetime\n         // arguments to our opaque type. Continuing with our example,\n         // we're creating the type arguments for the return type:\n         //\n@@ -1873,12 +1836,11 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         // For the \"output\" lifetime parameters, we just want to\n         // generate `'_`.\n         let generic_args =\n-            self.arena.alloc_from_iter(lifetime_params.into_iter().map(|(span, name)| {\n-                GenericArg::Lifetime(hir::Lifetime {\n-                    hir_id: self.next_id(),\n-                    span: self.lower_span(span),\n-                    name,\n-                })\n+            self.arena.alloc_from_iter(captures.into_iter().map(|(_, (span, _, p_name, res))| {\n+                let id = self.resolver.next_node_id();\n+                let ident = Ident::new(p_name.ident().name, span);\n+                let l = self.new_named_lifetime_with_res(id, span, ident, res);\n+                hir::GenericArg::Lifetime(l)\n             }));\n \n         // Create the `Foo<...>` reference itself. Note that the `type\n@@ -1948,35 +1910,115 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n     fn lower_lifetime(&mut self, l: &Lifetime) -> hir::Lifetime {\n         let span = self.lower_span(l.ident.span);\n-        match l.ident {\n-            ident if ident.name == kw::StaticLifetime => {\n-                self.new_named_lifetime(l.id, span, hir::LifetimeName::Static)\n-            }\n-            ident if ident.name == kw::UnderscoreLifetime => match self.anonymous_lifetime_mode {\n-                AnonymousLifetimeMode::CreateParameter => {\n-                    let fresh_name = self.collect_fresh_anonymous_lifetime(span);\n-                    self.new_named_lifetime(l.id, span, hir::LifetimeName::Param(fresh_name))\n-                }\n-\n-                AnonymousLifetimeMode::PassThrough => {\n-                    self.new_named_lifetime(l.id, span, hir::LifetimeName::Underscore)\n-                }\n-\n-                AnonymousLifetimeMode::ReportError => self.new_error_lifetime(Some(l.id), span),\n-            },\n-            ident => {\n-                let param_name = ParamName::Plain(self.lower_ident(ident));\n-                self.new_named_lifetime(l.id, span, hir::LifetimeName::Param(param_name))\n-            }\n-        }\n+        let ident = self.lower_ident(l.ident);\n+        let res = self\n+            .resolver\n+            .get_lifetime_res(l.id)\n+            .unwrap_or_else(|| panic!(\"Missing resolution for lifetime {:?} at {:?}\", l, span));\n+        self.new_named_lifetime_with_res(l.id, span, ident, res)\n     }\n \n-    fn new_named_lifetime(\n+    #[tracing::instrument(level = \"debug\", skip(self))]\n+    fn new_named_lifetime_with_res(\n         &mut self,\n         id: NodeId,\n         span: Span,\n-        name: hir::LifetimeName,\n+        ident: Ident,\n+        res: LifetimeRes,\n     ) -> hir::Lifetime {\n+        debug!(?self.captured_lifetimes);\n+        let name = match res {\n+            LifetimeRes::Param { param, binder } => {\n+                debug_assert_ne!(ident.name, kw::UnderscoreLifetime);\n+                let p_name = ParamName::Plain(ident);\n+                if let Some((parent_def_id, captures, binders)) = &mut self.captured_lifetimes {\n+                    match captures.entry(param) {\n+                        Entry::Occupied(_) => {}\n+                        Entry::Vacant(v) => {\n+                            if !binders.contains(&binder) {\n+                                let p_id = self.resolver.next_node_id();\n+                                self.resolver.create_def(\n+                                    *parent_def_id,\n+                                    p_id,\n+                                    DefPathData::LifetimeNs(p_name.ident().name),\n+                                    ExpnId::root(),\n+                                    span.with_parent(None),\n+                                );\n+\n+                                v.insert((span, p_id, p_name, res));\n+                            }\n+                        }\n+                    }\n+                }\n+                hir::LifetimeName::Param(p_name)\n+            }\n+            LifetimeRes::Fresh { mut param, introducer, binder } => {\n+                debug_assert_eq!(ident.name, kw::UnderscoreLifetime);\n+                // Only items are allowed to introduce fresh lifetimes,\n+                // so we know `binder` has a `LocalDefId`.\n+                let binder_def_id = self.resolver.local_def_id(binder);\n+                if let Some((parent_def_id, captures, binders)) = &mut self.captured_lifetimes {\n+                    match captures.entry(param) {\n+                        Entry::Occupied(o) => param = self.resolver.local_def_id(o.get().1),\n+                        Entry::Vacant(v) => {\n+                            if !binders.contains(&binder) {\n+                                let p_id = self.resolver.next_node_id();\n+                                let p_def_id = self.resolver.create_def(\n+                                    *parent_def_id,\n+                                    p_id,\n+                                    DefPathData::LifetimeNs(kw::UnderscoreLifetime),\n+                                    ExpnId::root(),\n+                                    span.with_parent(None),\n+                                );\n+\n+                                let p_name = ParamName::Fresh(param);\n+                                v.insert((span, p_id, p_name, res));\n+                                param = p_def_id;\n+                            }\n+                        }\n+                    }\n+                } else if let Some(introducer) = introducer {\n+                    if self.is_collecting_anonymous_lifetimes == Some(binder_def_id)\n+                        && self.resolver.opt_local_def_id(introducer) == Some(param)\n+                    {\n+                        debug!(\n+                            \"lifetime_to_define += id={:?} span={:?} res={:?}\",\n+                            introducer, span, res\n+                        );\n+                        self.lifetimes_to_define.insert(introducer, span);\n+                    }\n+                }\n+                let p_name = ParamName::Fresh(param);\n+                hir::LifetimeName::Param(p_name)\n+            }\n+            LifetimeRes::Anonymous { binder, elided } => {\n+                let l_name = if elided {\n+                    hir::LifetimeName::Implicit\n+                } else {\n+                    hir::LifetimeName::Underscore\n+                };\n+                match &mut self.captured_lifetimes {\n+                    Some((parent_def_id, captures, binders)) if !binders.contains(&binder) => {\n+                        let p_id = self.resolver.next_node_id();\n+                        let p_def_id = self.resolver.create_def(\n+                            *parent_def_id,\n+                            p_id,\n+                            DefPathData::LifetimeNs(kw::UnderscoreLifetime),\n+                            ExpnId::root(),\n+                            span.with_parent(None),\n+                        );\n+                        let p_name = ParamName::Fresh(p_def_id);\n+                        captures.insert(p_def_id, (span, p_id, p_name, res));\n+                        hir::LifetimeName::Param(p_name)\n+                    }\n+                    _ => l_name,\n+                }\n+            }\n+            LifetimeRes::Static => hir::LifetimeName::Static,\n+            LifetimeRes::Error => hir::LifetimeName::Error,\n+            res => panic!(\"Unexpected lifetime resolution {:?} for {:?} at {:?}\", res, ident, span),\n+        };\n+        debug!(?self.captured_lifetimes);\n         hir::Lifetime { hir_id: self.lower_node_id(id), span: self.lower_span(span), name }\n     }\n \n@@ -2001,39 +2043,21 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         param: &GenericParam,\n         mut itctx: ImplTraitContext<'_, 'hir>,\n     ) -> hir::GenericParam<'hir> {\n-        let bounds: Vec<_> = self\n-            .with_anonymous_lifetime_mode(AnonymousLifetimeMode::ReportError, |this| {\n-                this.lower_param_bounds_mut(&param.bounds, itctx.reborrow()).collect()\n-            });\n+        let bounds: Vec<_> = self.lower_param_bounds_mut(&param.bounds, itctx.reborrow()).collect();\n \n         let (name, kind) = match param.kind {\n             GenericParamKind::Lifetime => {\n-                let was_collecting_in_band = self.is_collecting_anonymous_lifetimes;\n-                self.is_collecting_anonymous_lifetimes = None;\n-\n-                let lt = self\n-                    .with_anonymous_lifetime_mode(AnonymousLifetimeMode::ReportError, |this| {\n-                        this.lower_lifetime(&Lifetime { id: param.id, ident: param.ident })\n-                    });\n-                let param_name = match lt.name {\n-                    hir::LifetimeName::Param(param_name) => param_name,\n-                    hir::LifetimeName::Implicit | hir::LifetimeName::Underscore => {\n-                        hir::ParamName::Plain(lt.name.ident())\n-                    }\n-                    hir::LifetimeName::ImplicitObjectLifetimeDefault => {\n-                        self.sess.diagnostic().span_bug(\n-                            param.ident.span,\n-                            \"object-lifetime-default should not occur here\",\n-                        );\n-                    }\n-                    hir::LifetimeName::Static | hir::LifetimeName::Error => ParamName::Error,\n+                let param_name = if param.ident.name == kw::StaticLifetime\n+                    || param.ident.name == kw::UnderscoreLifetime\n+                {\n+                    ParamName::Error\n+                } else {\n+                    let ident = self.lower_ident(param.ident);\n+                    ParamName::Plain(ident)\n                 };\n-\n                 let kind =\n                     hir::GenericParamKind::Lifetime { kind: hir::LifetimeParamKind::Explicit };\n \n-                self.is_collecting_anonymous_lifetimes = was_collecting_in_band;\n-\n                 (param_name, kind)\n             }\n             GenericParamKind::Type { ref default, .. } => {\n@@ -2047,10 +2071,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 (hir::ParamName::Plain(self.lower_ident(param.ident)), kind)\n             }\n             GenericParamKind::Const { ref ty, kw_span: _, ref default } => {\n-                let ty =\n-                    self.with_anonymous_lifetime_mode(AnonymousLifetimeMode::ReportError, |this| {\n-                        this.lower_ty(&ty, ImplTraitContext::Disallowed(ImplTraitPosition::Type))\n-                    });\n+                let ty = self.lower_ty(&ty, ImplTraitContext::Disallowed(ImplTraitPosition::Type));\n                 let default = default.as_ref().map(|def| self.lower_anon_const(def));\n                 (\n                     hir::ParamName::Plain(self.lower_ident(param.ident)),\n@@ -2087,6 +2108,7 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         hir::TraitRef { path, hir_ref_id: self.lower_node_id(p.ref_id) }\n     }\n \n+    #[tracing::instrument(level = \"debug\", skip(self))]\n     fn lower_poly_trait_ref(\n         &mut self,\n         p: &PolyTraitRef,\n@@ -2099,23 +2121,29 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n             // Any impl Trait types defined within this scope can capture\n             // lifetimes bound on this predicate.\n             let lt_def_names = p.bound_generic_params.iter().filter_map(|param| match param.kind {\n-                GenericParamKind::Lifetime { .. } => Some(hir::LifetimeName::Param(\n-                    ParamName::Plain(param.ident.normalize_to_macros_2_0()),\n-                )),\n+                GenericParamKind::Lifetime { .. } => {\n+                    Some(ParamName::Plain(param.ident.normalize_to_macros_2_0()))\n+                }\n                 _ => None,\n             });\n             if let ImplTraitContext::TypeAliasesOpaqueTy { ref mut capturable_lifetimes } = itctx {\n                 capturable_lifetimes.extend(lt_def_names.clone());\n             }\n+            if let Some((_, _, binders)) = &mut this.captured_lifetimes {\n+                binders.insert(p.trait_ref.ref_id);\n+            }\n \n-            let res = this.lower_trait_ref(&p.trait_ref, itctx.reborrow());\n+            let trait_ref = this.lower_trait_ref(&p.trait_ref, itctx.reborrow());\n \n             if let ImplTraitContext::TypeAliasesOpaqueTy { ref mut capturable_lifetimes } = itctx {\n                 for param in lt_def_names {\n                     capturable_lifetimes.remove(&param);\n                 }\n             }\n-            res\n+            if let Some((_, _, binders)) = &mut this.captured_lifetimes {\n+                binders.remove(&p.trait_ref.ref_id);\n+            }\n+            trait_ref\n         });\n \n         hir::PolyTraitRef { bound_generic_params, trait_ref, span: self.lower_span(p.span) }\n@@ -2378,98 +2406,11 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         hir::Ty { hir_id, kind, span: self.lower_span(span) }\n     }\n \n-    /// Invoked to create the lifetime argument for a type `&T`\n-    /// with no explicit lifetime.\n-    fn elided_ref_lifetime(&mut self, span: Span) -> hir::Lifetime {\n-        match self.anonymous_lifetime_mode {\n-            // Intercept when we are in an impl header or async fn and introduce an in-band\n-            // lifetime.\n-            // Hence `impl Foo for &u32` becomes `impl<'f> Foo for &'f u32` for some fresh\n-            // `'f`.\n-            AnonymousLifetimeMode::CreateParameter => {\n-                let fresh_name = self.collect_fresh_anonymous_lifetime(span);\n-                hir::Lifetime {\n-                    hir_id: self.next_id(),\n-                    span: self.lower_span(span),\n-                    name: hir::LifetimeName::Param(fresh_name),\n-                }\n-            }\n-\n-            AnonymousLifetimeMode::ReportError => self.new_error_lifetime(None, span),\n-\n-            AnonymousLifetimeMode::PassThrough => self.new_implicit_lifetime(span),\n-        }\n-    }\n-\n-    /// Report an error on illegal use of `'_` or a `&T` with no explicit lifetime;\n-    /// return an \"error lifetime\".\n-    fn new_error_lifetime(&mut self, id: Option<NodeId>, span: Span) -> hir::Lifetime {\n-        let id = id.unwrap_or_else(|| self.resolver.next_node_id());\n-        self.new_named_lifetime(id, span, hir::LifetimeName::Error)\n-    }\n-\n-    /// Invoked to create the lifetime argument(s) for a path like\n-    /// `std::cell::Ref<T>`; note that implicit lifetimes in these\n-    /// sorts of cases are deprecated. This may therefore report a warning or an\n-    /// error, depending on the mode.\n-    fn elided_path_lifetimes<'s>(\n-        &'s mut self,\n-        span: Span,\n-        count: usize,\n-    ) -> impl Iterator<Item = hir::Lifetime> + Captures<'a> + Captures<'s> + Captures<'hir> {\n-        (0..count).map(move |_| self.elided_path_lifetime(span))\n-    }\n-\n-    fn elided_path_lifetime(&mut self, span: Span) -> hir::Lifetime {\n-        match self.anonymous_lifetime_mode {\n-            AnonymousLifetimeMode::CreateParameter => {\n-                // We should have emitted E0726 when processing this path above\n-                self.sess\n-                    .delay_span_bug(span, \"expected 'implicit elided lifetime not allowed' error\");\n-                let id = self.resolver.next_node_id();\n-                self.new_named_lifetime(id, span, hir::LifetimeName::Error)\n-            }\n-            // `PassThrough` is the normal case.\n-            // `new_error_lifetime`, which would usually be used in the case of `ReportError`,\n-            // is unsuitable here, as these can occur from missing lifetime parameters in a\n-            // `PathSegment`, for which there is no associated `'_` or `&T` with no explicit\n-            // lifetime. Instead, we simply create an implicit lifetime, which will be checked\n-            // later, at which point a suitable error will be emitted.\n-            AnonymousLifetimeMode::PassThrough | AnonymousLifetimeMode::ReportError => {\n-                self.new_implicit_lifetime(span)\n-            }\n-        }\n-    }\n-\n     /// Invoked to create the lifetime argument(s) for an elided trait object\n     /// bound, like the bound in `Box<dyn Debug>`. This method is not invoked\n     /// when the bound is written, even if it is written with `'_` like in\n     /// `Box<dyn Debug + '_>`. In those cases, `lower_lifetime` is invoked.\n     fn elided_dyn_bound(&mut self, span: Span) -> hir::Lifetime {\n-        match self.anonymous_lifetime_mode {\n-            // NB. We intentionally ignore the create-parameter mode here.\n-            // and instead \"pass through\" to resolve-lifetimes, which will apply\n-            // the object-lifetime-defaulting rules. Elided object lifetime defaults\n-            // do not act like other elided lifetimes. In other words, given this:\n-            //\n-            //     impl Foo for Box<dyn Debug>\n-            //\n-            // we do not introduce a fresh `'_` to serve as the bound, but instead\n-            // ultimately translate to the equivalent of:\n-            //\n-            //     impl Foo for Box<dyn Debug + 'static>\n-            //\n-            // `resolve_lifetime` has the code to make that happen.\n-            AnonymousLifetimeMode::CreateParameter => {}\n-\n-            AnonymousLifetimeMode::ReportError => {\n-                // ReportError applies to explicit use of `'_`.\n-            }\n-\n-            // This is the normal case.\n-            AnonymousLifetimeMode::PassThrough => {}\n-        }\n-\n         let r = hir::Lifetime {\n             hir_id: self.next_id(),\n             span: self.lower_span(span),\n@@ -2478,14 +2419,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         debug!(\"elided_dyn_bound: r={:?}\", r);\n         r\n     }\n-\n-    fn new_implicit_lifetime(&mut self, span: Span) -> hir::Lifetime {\n-        hir::Lifetime {\n-            hir_id: self.next_id(),\n-            span: self.lower_span(span),\n-            name: hir::LifetimeName::Implicit,\n-        }\n-    }\n }\n \n /// Helper struct for delayed construction of GenericArgs.\n@@ -2511,121 +2444,3 @@ impl<'hir> GenericArgsCtor<'hir> {\n         this.arena.alloc(ga)\n     }\n }\n-\n-#[tracing::instrument(level = \"debug\")]\n-fn lifetimes_from_impl_trait_bounds(\n-    opaque_ty_id: NodeId,\n-    bounds: hir::GenericBounds<'_>,\n-    lifetimes_to_include: Option<&FxHashSet<hir::LifetimeName>>,\n-) -> Vec<(hir::LifetimeName, Span)> {\n-    // This visitor walks over `impl Trait` bounds and creates defs for all lifetimes that\n-    // appear in the bounds, excluding lifetimes that are created within the bounds.\n-    // E.g., `'a`, `'b`, but not `'c` in `impl for<'c> SomeTrait<'a, 'b, 'c>`.\n-    struct ImplTraitLifetimeCollector<'r> {\n-        collect_elided_lifetimes: bool,\n-        currently_bound_lifetimes: Vec<hir::LifetimeName>,\n-        already_defined_lifetimes: FxHashSet<hir::LifetimeName>,\n-        lifetimes: Vec<(hir::LifetimeName, Span)>,\n-        lifetimes_to_include: Option<&'r FxHashSet<hir::LifetimeName>>,\n-    }\n-\n-    impl<'r, 'v> intravisit::Visitor<'v> for ImplTraitLifetimeCollector<'r> {\n-        fn visit_generic_args(&mut self, span: Span, parameters: &'v hir::GenericArgs<'v>) {\n-            // Don't collect elided lifetimes used inside of `Fn()` syntax.\n-            if parameters.parenthesized {\n-                let old_collect_elided_lifetimes = self.collect_elided_lifetimes;\n-                self.collect_elided_lifetimes = false;\n-                intravisit::walk_generic_args(self, span, parameters);\n-                self.collect_elided_lifetimes = old_collect_elided_lifetimes;\n-            } else {\n-                intravisit::walk_generic_args(self, span, parameters);\n-            }\n-        }\n-\n-        fn visit_ty(&mut self, t: &'v hir::Ty<'v>) {\n-            // Don't collect elided lifetimes used inside of `fn()` syntax.\n-            if let hir::TyKind::BareFn(_) = t.kind {\n-                let old_collect_elided_lifetimes = self.collect_elided_lifetimes;\n-                self.collect_elided_lifetimes = false;\n-\n-                // Record the \"stack height\" of `for<'a>` lifetime bindings\n-                // to be able to later fully undo their introduction.\n-                let old_len = self.currently_bound_lifetimes.len();\n-                intravisit::walk_ty(self, t);\n-                self.currently_bound_lifetimes.truncate(old_len);\n-\n-                self.collect_elided_lifetimes = old_collect_elided_lifetimes;\n-            } else {\n-                intravisit::walk_ty(self, t)\n-            }\n-        }\n-\n-        fn visit_poly_trait_ref(\n-            &mut self,\n-            trait_ref: &'v hir::PolyTraitRef<'v>,\n-            modifier: hir::TraitBoundModifier,\n-        ) {\n-            // Record the \"stack height\" of `for<'a>` lifetime bindings\n-            // to be able to later fully undo their introduction.\n-            let old_len = self.currently_bound_lifetimes.len();\n-            intravisit::walk_poly_trait_ref(self, trait_ref, modifier);\n-            self.currently_bound_lifetimes.truncate(old_len);\n-        }\n-\n-        fn visit_generic_param(&mut self, param: &'v hir::GenericParam<'v>) {\n-            // Record the introduction of 'a in `for<'a> ...`.\n-            if let hir::GenericParamKind::Lifetime { .. } = param.kind {\n-                // Introduce lifetimes one at a time so that we can handle\n-                // cases like `fn foo<'d>() -> impl for<'a, 'b: 'a, 'c: 'b + 'd>`.\n-                let lt_name = hir::LifetimeName::Param(param.name);\n-                self.currently_bound_lifetimes.push(lt_name);\n-            }\n-\n-            intravisit::walk_generic_param(self, param);\n-        }\n-\n-        fn visit_lifetime(&mut self, lifetime: &'v hir::Lifetime) {\n-            let name = match lifetime.name {\n-                hir::LifetimeName::Implicit | hir::LifetimeName::Underscore => {\n-                    if self.collect_elided_lifetimes {\n-                        // Use `'_` for both implicit and underscore lifetimes in\n-                        // `type Foo<'_> = impl SomeTrait<'_>;`.\n-                        hir::LifetimeName::Underscore\n-                    } else {\n-                        return;\n-                    }\n-                }\n-                hir::LifetimeName::Param(_) => lifetime.name,\n-\n-                // Refers to some other lifetime that is \"in\n-                // scope\" within the type.\n-                hir::LifetimeName::ImplicitObjectLifetimeDefault => return,\n-\n-                hir::LifetimeName::Error | hir::LifetimeName::Static => return,\n-            };\n-\n-            if !self.currently_bound_lifetimes.contains(&name)\n-                && !self.already_defined_lifetimes.contains(&name)\n-                && self.lifetimes_to_include.map_or(true, |lifetimes| lifetimes.contains(&name))\n-            {\n-                self.already_defined_lifetimes.insert(name);\n-\n-                self.lifetimes.push((name, lifetime.span));\n-            }\n-        }\n-    }\n-\n-    let mut lifetime_collector = ImplTraitLifetimeCollector {\n-        collect_elided_lifetimes: true,\n-        currently_bound_lifetimes: Vec::new(),\n-        already_defined_lifetimes: FxHashSet::default(),\n-        lifetimes: Vec::new(),\n-        lifetimes_to_include,\n-    };\n-\n-    for bound in bounds {\n-        intravisit::walk_param_bound(&mut lifetime_collector, &bound);\n-    }\n-\n-    lifetime_collector.lifetimes\n-}"}, {"sha": "315e2289b7ad6708986a56ea06974dcf54238fd9", "filename": "compiler/rustc_ast_lowering/src/path.rs", "status": "modified", "additions": 85, "deletions": 91, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/f385f856cd9df6ded13248cc3d25e603e38b4f2f/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f385f856cd9df6ded13248cc3d25e603e38b4f2f/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ast_lowering%2Fsrc%2Fpath.rs?ref=f385f856cd9df6ded13248cc3d25e603e38b4f2f", "patch": "@@ -1,15 +1,14 @@\n use crate::ImplTraitPosition;\n \n-use super::{AnonymousLifetimeMode, ImplTraitContext, LoweringContext, ParamMode};\n-use super::{GenericArgsCtor, ParenthesizedGenericArgs};\n+use super::{GenericArgsCtor, LifetimeRes, ParenthesizedGenericArgs};\n+use super::{ImplTraitContext, LoweringContext, ParamMode};\n \n use rustc_ast::{self as ast, *};\n use rustc_errors::{struct_span_err, Applicability};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, PartialRes, Res};\n-use rustc_hir::def_id::DefId;\n use rustc_hir::GenericArg;\n-use rustc_span::symbol::Ident;\n+use rustc_span::symbol::{kw, Ident};\n use rustc_span::{BytePos, Span, DUMMY_SP};\n \n use smallvec::smallvec;\n@@ -47,30 +46,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         _ => param_mode,\n                     };\n \n-                    // Figure out if this is a type/trait segment,\n-                    // which may need lifetime elision performed.\n-                    let parent_def_id = |this: &mut Self, def_id: DefId| DefId {\n-                        krate: def_id.krate,\n-                        index: this.resolver.def_key(def_id).parent.expect(\"missing parent\"),\n-                    };\n-                    let type_def_id = match partial_res.base_res() {\n-                        Res::Def(DefKind::AssocTy, def_id) if i + 2 == proj_start => {\n-                            Some(parent_def_id(self, def_id))\n-                        }\n-                        Res::Def(DefKind::Variant, def_id) if i + 1 == proj_start => {\n-                            Some(parent_def_id(self, def_id))\n-                        }\n-                        Res::Def(DefKind::Struct, def_id)\n-                        | Res::Def(DefKind::Union, def_id)\n-                        | Res::Def(DefKind::Enum, def_id)\n-                        | Res::Def(DefKind::TyAlias, def_id)\n-                        | Res::Def(DefKind::Trait, def_id)\n-                            if i + 1 == proj_start =>\n-                        {\n-                            Some(def_id)\n-                        }\n-                        _ => None,\n-                    };\n                     let parenthesized_generic_args = match partial_res.base_res() {\n                         // `a::b::Trait(Args)`\n                         Res::Def(DefKind::Trait, _) if i + 1 == proj_start => {\n@@ -90,13 +65,10 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                         _ => ParenthesizedGenericArgs::Err,\n                     };\n \n-                    let num_lifetimes = type_def_id\n-                        .map_or(0, |def_id| self.resolver.item_generics_num_lifetimes(def_id));\n                     self.lower_path_segment(\n                         p.span,\n                         segment,\n                         param_mode,\n-                        num_lifetimes,\n                         parenthesized_generic_args,\n                         itctx.reborrow(),\n                     )\n@@ -143,7 +115,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                 p.span,\n                 segment,\n                 param_mode,\n-                0,\n                 ParenthesizedGenericArgs::Err,\n                 itctx.reborrow(),\n             ));\n@@ -184,7 +155,6 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n                     p.span,\n                     segment,\n                     param_mode,\n-                    0,\n                     ParenthesizedGenericArgs::Err,\n                     ImplTraitContext::Disallowed(ImplTraitPosition::Path),\n                 )\n@@ -209,22 +179,20 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         path_span: Span,\n         segment: &PathSegment,\n         param_mode: ParamMode,\n-        expected_lifetimes: usize,\n         parenthesized_generic_args: ParenthesizedGenericArgs,\n         itctx: ImplTraitContext<'_, 'hir>,\n     ) -> hir::PathSegment<'hir> {\n-        debug!(\n-            \"path_span: {:?}, lower_path_segment(segment: {:?}, expected_lifetimes: {:?})\",\n-            path_span, segment, expected_lifetimes\n-        );\n+        debug!(\"path_span: {:?}, lower_path_segment(segment: {:?})\", path_span, segment,);\n         let (mut generic_args, infer_args) = if let Some(ref generic_args) = segment.args {\n             let msg = \"parenthesized type parameters may only be used with a `Fn` trait\";\n             match **generic_args {\n                 GenericArgs::AngleBracketed(ref data) => {\n                     self.lower_angle_bracketed_parameter_data(data, param_mode, itctx)\n                 }\n                 GenericArgs::Parenthesized(ref data) => match parenthesized_generic_args {\n-                    ParenthesizedGenericArgs::Ok => self.lower_parenthesized_parameter_data(data),\n+                    ParenthesizedGenericArgs::Ok => {\n+                        self.lower_parenthesized_parameter_data(segment.id, data)\n+                    }\n                     ParenthesizedGenericArgs::Err => {\n                         let mut err = struct_span_err!(self.sess, data.span, E0214, \"{}\", msg);\n                         err.span_label(data.span, \"only `Fn` traits may use parentheses\");\n@@ -274,33 +242,13 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n         let has_lifetimes =\n             generic_args.args.iter().any(|arg| matches!(arg, GenericArg::Lifetime(_)));\n-        if !generic_args.parenthesized && !has_lifetimes && expected_lifetimes > 0 {\n-            // Note: these spans are used for diagnostics when they can't be inferred.\n-            // See rustc_resolve::late::lifetimes::LifetimeContext::add_missing_lifetime_specifiers_label\n-            let elided_lifetime_span = if generic_args.span.is_empty() {\n-                // If there are no brackets, use the identifier span.\n-                // HACK: we use find_ancestor_inside to properly suggest elided spans in paths\n-                // originating from macros, since the segment's span might be from a macro arg.\n-                segment.ident.span.find_ancestor_inside(path_span).unwrap_or(path_span)\n-            } else if generic_args.is_empty() {\n-                // If there are brackets, but not generic arguments, then use the opening bracket\n-                generic_args.span.with_hi(generic_args.span.lo() + BytePos(1))\n-            } else {\n-                // Else use an empty span right after the opening bracket.\n-                generic_args.span.with_lo(generic_args.span.lo() + BytePos(1)).shrink_to_lo()\n-            };\n-            generic_args.args = self\n-                .elided_path_lifetimes(elided_lifetime_span, expected_lifetimes)\n-                .map(GenericArg::Lifetime)\n-                .chain(generic_args.args.into_iter())\n-                .collect();\n-            if let (ParamMode::Explicit, AnonymousLifetimeMode::CreateParameter) =\n-                (param_mode, self.anonymous_lifetime_mode)\n-            {\n-                // Late resolver should have issued the error.\n-                self.sess\n-                    .delay_span_bug(elided_lifetime_span, \"implicit lifetime not allowed here\");\n-            }\n+        if !generic_args.parenthesized && !has_lifetimes {\n+            self.maybe_insert_elided_lifetimes_in_path(\n+                path_span,\n+                segment.id,\n+                segment.ident.span,\n+                &mut generic_args,\n+            );\n         }\n \n         let res = self.expect_full_res(segment.id);\n@@ -323,6 +271,49 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n         }\n     }\n \n+    fn maybe_insert_elided_lifetimes_in_path(\n+        &mut self,\n+        path_span: Span,\n+        segment_id: NodeId,\n+        segment_ident_span: Span,\n+        generic_args: &mut GenericArgsCtor<'hir>,\n+    ) {\n+        let (start, end) = match self.resolver.get_lifetime_res(segment_id) {\n+            Some(LifetimeRes::ElidedAnchor { start, end }) => (start, end),\n+            None => return,\n+            Some(_) => panic!(),\n+        };\n+        let expected_lifetimes = end.as_usize() - start.as_usize();\n+        debug!(expected_lifetimes);\n+\n+        // Note: these spans are used for diagnostics when they can't be inferred.\n+        // See rustc_resolve::late::lifetimes::LifetimeContext::add_missing_lifetime_specifiers_label\n+        let elided_lifetime_span = if generic_args.span.is_empty() {\n+            // If there are no brackets, use the identifier span.\n+            // HACK: we use find_ancestor_inside to properly suggest elided spans in paths\n+            // originating from macros, since the segment's span might be from a macro arg.\n+            segment_ident_span.find_ancestor_inside(path_span).unwrap_or(path_span)\n+        } else if generic_args.is_empty() {\n+            // If there are brackets, but not generic arguments, then use the opening bracket\n+            generic_args.span.with_hi(generic_args.span.lo() + BytePos(1))\n+        } else {\n+            // Else use an empty span right after the opening bracket.\n+            generic_args.span.with_lo(generic_args.span.lo() + BytePos(1)).shrink_to_lo()\n+        };\n+\n+        generic_args.args.insert_many(\n+            0,\n+            (start.as_u32()..end.as_u32()).map(|i| {\n+                let id = NodeId::from_u32(i);\n+                let l = self.lower_lifetime(&Lifetime {\n+                    id,\n+                    ident: Ident::new(kw::UnderscoreLifetime, elided_lifetime_span),\n+                });\n+                GenericArg::Lifetime(l)\n+            }),\n+        );\n+    }\n+\n     pub(crate) fn lower_angle_bracketed_parameter_data(\n         &mut self,\n         data: &AngleBracketedArgs,\n@@ -354,38 +345,41 @@ impl<'a, 'hir> LoweringContext<'a, 'hir> {\n \n     fn lower_parenthesized_parameter_data(\n         &mut self,\n+        id: NodeId,\n         data: &ParenthesizedArgs,\n     ) -> (GenericArgsCtor<'hir>, bool) {\n         // Switch to `PassThrough` mode for anonymous lifetimes; this\n         // means that we permit things like `&Ref<T>`, where `Ref` has\n         // a hidden lifetime parameter. This is needed for backwards\n         // compatibility, even in contexts like an impl header where\n         // we generally don't permit such things (see #51008).\n-        self.with_anonymous_lifetime_mode(AnonymousLifetimeMode::PassThrough, |this| {\n-            let ParenthesizedArgs { span, inputs, inputs_span, output } = data;\n-            let inputs = this.arena.alloc_from_iter(inputs.iter().map(|ty| {\n-                this.lower_ty_direct(\n-                    ty,\n-                    ImplTraitContext::Disallowed(ImplTraitPosition::FnTraitParam),\n-                )\n-            }));\n-            let output_ty = match output {\n-                FnRetTy::Ty(ty) => this\n-                    .lower_ty(&ty, ImplTraitContext::Disallowed(ImplTraitPosition::FnTraitReturn)),\n-                FnRetTy::Default(_) => this.arena.alloc(this.ty_tup(*span, &[])),\n-            };\n-            let args = smallvec![GenericArg::Type(this.ty_tup(*inputs_span, inputs))];\n-            let binding = this.output_ty_binding(output_ty.span, output_ty);\n-            (\n-                GenericArgsCtor {\n-                    args,\n-                    bindings: arena_vec![this; binding],\n-                    parenthesized: true,\n-                    span: data.inputs_span,\n-                },\n-                false,\n-            )\n-        })\n+        if let Some((_, _, binders)) = &mut self.captured_lifetimes {\n+            binders.insert(id);\n+        }\n+        let ParenthesizedArgs { span, inputs, inputs_span, output } = data;\n+        let inputs = self.arena.alloc_from_iter(inputs.iter().map(|ty| {\n+            self.lower_ty_direct(ty, ImplTraitContext::Disallowed(ImplTraitPosition::FnTraitParam))\n+        }));\n+        let output_ty = match output {\n+            FnRetTy::Ty(ty) => {\n+                self.lower_ty(&ty, ImplTraitContext::Disallowed(ImplTraitPosition::FnTraitReturn))\n+            }\n+            FnRetTy::Default(_) => self.arena.alloc(self.ty_tup(*span, &[])),\n+        };\n+        let args = smallvec![GenericArg::Type(self.ty_tup(*inputs_span, inputs))];\n+        let binding = self.output_ty_binding(output_ty.span, output_ty);\n+        if let Some((_, _, binders)) = &mut self.captured_lifetimes {\n+            binders.remove(&id);\n+        }\n+        (\n+            GenericArgsCtor {\n+                args,\n+                bindings: arena_vec![self; binding],\n+                parenthesized: true,\n+                span: data.inputs_span,\n+            },\n+            false,\n+        )\n     }\n \n     /// An associated type binding `Output = $ty`."}, {"sha": "432883a11031bd409322f6b4b87e5b20f5c30569", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f385f856cd9df6ded13248cc3d25e603e38b4f2f/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f385f856cd9df6ded13248cc3d25e603e38b4f2f/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=f385f856cd9df6ded13248cc3d25e603e38b4f2f", "patch": "@@ -442,9 +442,6 @@ pub enum GenericBound<'hir> {\n     Outlives(Lifetime),\n }\n \n-#[cfg(all(target_arch = \"x86_64\", target_pointer_width = \"64\"))]\n-rustc_data_structures::static_assert_size!(GenericBound<'_>, 48);\n-\n impl GenericBound<'_> {\n     pub fn trait_ref(&self) -> Option<&TraitRef<'_>> {\n         match self {\n@@ -3347,6 +3344,7 @@ mod size_asserts {\n     rustc_data_structures::static_assert_size!(super::Pat<'static>, 88);\n     rustc_data_structures::static_assert_size!(super::QPath<'static>, 24);\n     rustc_data_structures::static_assert_size!(super::Ty<'static>, 72);\n+    rustc_data_structures::static_assert_size!(super::GenericBound<'_>, 48);\n \n     rustc_data_structures::static_assert_size!(super::Item<'static>, 184);\n     rustc_data_structures::static_assert_size!(super::TraitItem<'static>, 128);"}, {"sha": "0d940c051693290a551de63c80caf4b7d3319440", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 156, "deletions": 46, "changes": 202, "blob_url": "https://github.com/rust-lang/rust/blob/f385f856cd9df6ded13248cc3d25e603e38b4f2f/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f385f856cd9df6ded13248cc3d25e603e38b4f2f/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=f385f856cd9df6ded13248cc3d25e603e38b4f2f", "patch": "@@ -14,13 +14,15 @@ use crate::{ResolutionError, Resolver, Segment, UseError};\n use rustc_ast::ptr::P;\n use rustc_ast::visit::{self, AssocCtxt, FnCtxt, FnKind, Visitor};\n use rustc_ast::*;\n-use rustc_ast_lowering::ResolverAstLowering;\n+use rustc_ast_lowering::{LifetimeRes, ResolverAstLowering};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_errors::DiagnosticId;\n use rustc_hir::def::Namespace::{self, *};\n use rustc_hir::def::{self, CtorKind, DefKind, PartialRes, PerNS};\n use rustc_hir::def_id::{DefId, CRATE_DEF_ID};\n+use rustc_hir::definitions::DefPathData;\n use rustc_hir::{PrimTy, TraitCandidate};\n+use rustc_index::vec::Idx;\n use rustc_middle::ty::DefIdTree;\n use rustc_middle::{bug, span_bug};\n use rustc_session::lint;\n@@ -195,7 +197,7 @@ enum LifetimeRibKind {\n     Item,\n \n     /// This rib declares generic parameters.\n-    Generics { span: Span, kind: LifetimeBinderKind },\n+    Generics { parent: NodeId, span: Span, kind: LifetimeBinderKind },\n \n     /// For **Modern** cases, create a new anonymous region parameter\n     /// and reference that.\n@@ -204,15 +206,15 @@ enum LifetimeRibKind {\n     /// `resolve_lifetime` code.\n     ///\n     /// For **Deprecated** cases, report an error.\n-    AnonymousCreateParameter,\n+    AnonymousCreateParameter(NodeId),\n \n     /// Give a hard error when either `&` or `'_` is written. Used to\n     /// rule out things like `where T: Foo<'_>`. Does not imply an\n     /// error on default object bounds (e.g., `Box<dyn Foo>`).\n     AnonymousReportError,\n \n     /// Pass responsibility to `resolve_lifetime` code for all cases.\n-    AnonymousPassThrough,\n+    AnonymousPassThrough(NodeId),\n }\n \n #[derive(Copy, Clone, Debug)]\n@@ -242,7 +244,7 @@ impl LifetimeBinderKind {\n #[derive(Debug)]\n struct LifetimeRib {\n     kind: LifetimeRibKind,\n-    bindings: IdentMap<()>,\n+    bindings: IdentMap<LifetimeRes>,\n }\n \n impl LifetimeRib {\n@@ -581,12 +583,19 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n                 self.with_generic_param_rib(\n                     &bare_fn.generic_params,\n                     NormalRibKind,\n-                    LifetimeRibKind::Generics { kind: LifetimeBinderKind::BareFnType, span },\n+                    LifetimeRibKind::Generics {\n+                        parent: ty.id,\n+                        kind: LifetimeBinderKind::BareFnType,\n+                        span,\n+                    },\n                     |this| {\n-                        this.with_lifetime_rib(LifetimeRibKind::AnonymousPassThrough, |this| {\n-                            this.visit_generic_param_vec(&bare_fn.generic_params, false);\n-                            visit::walk_fn_decl(this, &bare_fn.decl);\n-                        });\n+                        this.with_lifetime_rib(\n+                            LifetimeRibKind::AnonymousPassThrough(ty.id),\n+                            |this| {\n+                                this.visit_generic_param_vec(&bare_fn.generic_params, false);\n+                                visit::walk_fn_decl(this, &bare_fn.decl);\n+                            },\n+                        );\n                     },\n                 );\n                 self.diagnostic_metadata.current_trait_object = prev;\n@@ -604,7 +613,11 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n         self.with_generic_param_rib(\n             &tref.bound_generic_params,\n             NormalRibKind,\n-            LifetimeRibKind::Generics { kind: LifetimeBinderKind::PolyTrait, span },\n+            LifetimeRibKind::Generics {\n+                parent: tref.trait_ref.ref_id,\n+                kind: LifetimeBinderKind::PolyTrait,\n+                span,\n+            },\n             |this| {\n                 this.visit_generic_param_vec(&tref.bound_generic_params, false);\n                 this.smart_resolve_path(\n@@ -625,6 +638,7 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n                         &generics.params,\n                         ItemRibKind(HasGenericParams::Yes),\n                         LifetimeRibKind::Generics {\n+                            parent: foreign_item.id,\n                             kind: LifetimeBinderKind::Item,\n                             span: generics.span,\n                         },\n@@ -638,6 +652,7 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n                         &generics.params,\n                         ItemRibKind(HasGenericParams::Yes),\n                         LifetimeRibKind::Generics {\n+                            parent: foreign_item.id,\n                             kind: LifetimeBinderKind::Function,\n                             span: generics.span,\n                         },\n@@ -655,13 +670,13 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n             }\n         }\n     }\n-    fn visit_fn(&mut self, fn_kind: FnKind<'ast>, sp: Span, _: NodeId) {\n+    fn visit_fn(&mut self, fn_kind: FnKind<'ast>, sp: Span, fn_id: NodeId) {\n         let rib_kind = match fn_kind {\n             // Bail if the function is foreign, and thus cannot validly have\n             // a body, or if there's no body for some other reason.\n             FnKind::Fn(FnCtxt::Foreign, _, sig, _, generics, _)\n             | FnKind::Fn(_, _, sig, _, generics, None) => {\n-                self.with_lifetime_rib(LifetimeRibKind::AnonymousPassThrough, |this| {\n+                self.with_lifetime_rib(LifetimeRibKind::AnonymousPassThrough(fn_id), |this| {\n                     // We don't need to deal with patterns in parameters, because\n                     // they are not possible for foreign or bodiless functions.\n                     this.visit_fn_header(&sig.header);\n@@ -691,20 +706,24 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n                     this.visit_generics(generics);\n                 }\n \n-                if async_node_id.is_some() {\n+                if let Some(async_node_id) = async_node_id {\n                     // In `async fn`, argument-position elided lifetimes\n                     // must be transformed into fresh generic parameters so that\n                     // they can be applied to the opaque `impl Trait` return type.\n-                    this.with_lifetime_rib(LifetimeRibKind::AnonymousCreateParameter, |this| {\n-                        // Add each argument to the rib.\n-                        this.resolve_params(&declaration.inputs)\n-                    });\n+                    this.with_lifetime_rib(\n+                        LifetimeRibKind::AnonymousCreateParameter(fn_id),\n+                        |this| {\n+                            // Add each argument to the rib.\n+                            this.resolve_params(&declaration.inputs)\n+                        },\n+                    );\n \n-                    this.with_lifetime_rib(LifetimeRibKind::AnonymousPassThrough, |this| {\n-                        visit::walk_fn_ret_ty(this, &declaration.output)\n-                    });\n+                    this.with_lifetime_rib(\n+                        LifetimeRibKind::AnonymousPassThrough(async_node_id),\n+                        |this| visit::walk_fn_ret_ty(this, &declaration.output),\n+                    );\n                 } else {\n-                    this.with_lifetime_rib(LifetimeRibKind::AnonymousPassThrough, |this| {\n+                    this.with_lifetime_rib(LifetimeRibKind::AnonymousPassThrough(fn_id), |this| {\n                         // Add each argument to the rib.\n                         this.resolve_params(&declaration.inputs);\n \n@@ -716,13 +735,12 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n                 // Be sure not to set this until the function signature has been resolved.\n                 let previous_state = replace(&mut this.in_func_body, true);\n                 // Resolve the function body, potentially inside the body of an async closure\n-                this.with_lifetime_rib(\n-                    LifetimeRibKind::AnonymousPassThrough,\n-                    |this| match fn_kind {\n+                this.with_lifetime_rib(LifetimeRibKind::AnonymousPassThrough(fn_id), |this| {\n+                    match fn_kind {\n                         FnKind::Fn(.., body) => walk_list!(this, visit_block, body),\n                         FnKind::Closure(_, body) => this.visit_expr(body),\n-                    },\n-                );\n+                    }\n+                });\n \n                 debug!(\"(resolving function) leaving function\");\n                 this.in_func_body = previous_state;\n@@ -801,10 +819,10 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n         if let Some(ref args) = path_segment.args {\n             match &**args {\n                 GenericArgs::AngleBracketed(..) => visit::walk_generic_args(self, path_span, args),\n-                GenericArgs::Parenthesized(..) => self\n-                    .with_lifetime_rib(LifetimeRibKind::AnonymousPassThrough, |this| {\n-                        visit::walk_generic_args(this, path_span, args)\n-                    }),\n+                GenericArgs::Parenthesized(..) => self.with_lifetime_rib(\n+                    LifetimeRibKind::AnonymousPassThrough(path_segment.id),\n+                    |this| visit::walk_generic_args(this, path_span, args),\n+                ),\n             }\n         }\n     }\n@@ -830,7 +848,11 @@ impl<'a: 'ast, 'ast> Visitor<'ast> for LateResolutionVisitor<'a, '_, 'ast> {\n                 this.with_generic_param_rib(\n                     &bound_generic_params,\n                     NormalRibKind,\n-                    LifetimeRibKind::Generics { kind: LifetimeBinderKind::WhereBound, span },\n+                    LifetimeRibKind::Generics {\n+                        parent: bounded_ty.id,\n+                        kind: LifetimeBinderKind::WhereBound,\n+                        span,\n+                    },\n                     |this| {\n                         this.visit_generic_param_vec(&bound_generic_params, false);\n                         this.visit_ty(bounded_ty);\n@@ -1092,6 +1114,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         let ident = lifetime.ident;\n \n         if ident.name == kw::StaticLifetime {\n+            self.record_lifetime_res(lifetime.id, LifetimeRes::Static);\n             return;\n         }\n \n@@ -1103,7 +1126,8 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         for i in &mut indices {\n             let rib = &self.lifetime_ribs[i];\n             let normalized_ident = ident.normalize_to_macros_2_0();\n-            if let Some(_) = rib.bindings.get_key_value(&normalized_ident) {\n+            if let Some(&region) = rib.bindings.get(&normalized_ident) {\n+                self.record_lifetime_res(lifetime.id, region);\n                 return;\n             }\n \n@@ -1123,6 +1147,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         }\n \n         self.emit_undeclared_lifetime_error(lifetime, outer_res);\n+        self.record_lifetime_res(lifetime.id, LifetimeRes::Error);\n     }\n \n     #[tracing::instrument(level = \"debug\", skip(self))]\n@@ -1132,6 +1157,10 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         for i in (0..self.lifetime_ribs.len()).rev() {\n             let rib = &mut self.lifetime_ribs[i];\n             match rib.kind {\n+                LifetimeRibKind::AnonymousCreateParameter(item_node_id) => {\n+                    self.create_fresh_lifetime(lifetime.id, lifetime.ident, item_node_id);\n+                    return;\n+                }\n                 LifetimeRibKind::AnonymousReportError => {\n                     let (msg, note) = if elided {\n                         (\n@@ -1151,23 +1180,63 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                     .span_label(lifetime.ident.span, note)\n                     .emit();\n \n+                    self.record_lifetime_res(lifetime.id, LifetimeRes::Error);\n                     return;\n                 }\n-                LifetimeRibKind::AnonymousCreateParameter\n-                | LifetimeRibKind::AnonymousPassThrough\n-                | LifetimeRibKind::Item => return,\n+                LifetimeRibKind::AnonymousPassThrough(node_id) => {\n+                    self.record_lifetime_res(\n+                        lifetime.id,\n+                        LifetimeRes::Anonymous { binder: node_id, elided },\n+                    );\n+                    return;\n+                }\n+                LifetimeRibKind::Item => break,\n                 _ => {}\n             }\n         }\n+        // This resolution is wrong, it passes the work to HIR lifetime resolution.\n+        // We cannot use `LifetimeRes::Error` because we do not emit a diagnostic.\n+        self.record_lifetime_res(\n+            lifetime.id,\n+            LifetimeRes::Anonymous { binder: DUMMY_NODE_ID, elided },\n+        );\n     }\n \n     #[tracing::instrument(level = \"debug\", skip(self))]\n     fn resolve_elided_lifetime(&mut self, anchor_id: NodeId, span: Span) {\n         let id = self.r.next_node_id();\n+        self.record_lifetime_res(\n+            anchor_id,\n+            LifetimeRes::ElidedAnchor { start: id, end: NodeId::from_u32(id.as_u32() + 1) },\n+        );\n+\n         let lt = Lifetime { id, ident: Ident::new(kw::UnderscoreLifetime, span) };\n         self.resolve_anonymous_lifetime(&lt, true);\n     }\n \n+    #[tracing::instrument(level = \"debug\", skip(self))]\n+    fn create_fresh_lifetime(&mut self, id: NodeId, ident: Ident, item_node_id: NodeId) {\n+        debug_assert_eq!(ident.name, kw::UnderscoreLifetime);\n+        debug!(?ident.span);\n+        let item_def_id = self.r.local_def_id(item_node_id);\n+        let def_node_id = self.r.next_node_id();\n+        let def_id = self.r.create_def(\n+            item_def_id,\n+            def_node_id,\n+            DefPathData::LifetimeNs(kw::UnderscoreLifetime),\n+            self.parent_scope.expansion.to_expn_id(),\n+            ident.span,\n+        );\n+        debug!(?def_id);\n+\n+        let region = LifetimeRes::Fresh {\n+            param: def_id,\n+            introducer: Some(def_node_id),\n+            binder: item_node_id,\n+        };\n+        self.record_lifetime_res(id, region);\n+    }\n+\n     #[tracing::instrument(level = \"debug\", skip(self))]\n     fn resolve_elided_lifetimes_in_path(\n         &mut self,\n@@ -1231,7 +1300,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                     //\n                     //     impl Foo for std::cell::Ref<u32> // note lack of '_\n                     //     async fn foo(_: std::cell::Ref<u32>) { ... }\n-                    LifetimeRibKind::AnonymousCreateParameter => {\n+                    LifetimeRibKind::AnonymousCreateParameter(_) => {\n                         error = true;\n                         break;\n                     }\n@@ -1241,13 +1310,29 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                     // `PathSegment`, for which there is no associated `'_` or `&T` with no explicit\n                     // lifetime. Instead, we simply create an implicit lifetime, which will be checked\n                     // later, at which point a suitable error will be emitted.\n-                    LifetimeRibKind::AnonymousPassThrough\n+                    LifetimeRibKind::AnonymousPassThrough(..)\n                     | LifetimeRibKind::AnonymousReportError\n                     | LifetimeRibKind::Item => break,\n                     _ => {}\n                 }\n             }\n \n+            let res = if error {\n+                LifetimeRes::Error\n+            } else {\n+                LifetimeRes::Anonymous { binder: segment_id, elided: true }\n+            };\n+\n+            let node_ids = self.r.next_node_ids(expected_lifetimes);\n+            self.record_lifetime_res(\n+                segment_id,\n+                LifetimeRes::ElidedAnchor { start: node_ids.start, end: node_ids.end },\n+            );\n+            for i in 0..expected_lifetimes {\n+                let id = node_ids.start.plus(i);\n+                self.record_lifetime_res(id, res);\n+            }\n+\n             if !missing {\n                 continue;\n             }\n@@ -1296,6 +1381,16 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n         }\n     }\n \n+    #[tracing::instrument(level = \"debug\", skip(self))]\n+    fn record_lifetime_res(&mut self, id: NodeId, res: LifetimeRes) {\n+        if let Some(prev_res) = self.r.lifetimes_res_map.insert(id, res) {\n+            panic!(\n+                \"lifetime {:?} resolved multiple times ({:?} before, {:?} now)\",\n+                id, prev_res, res\n+            )\n+        }\n+    }\n+\n     /// Searches the current set of local scopes for labels. Returns the `NodeId` of the resolved\n     /// label and reports an error if the label is not found or is unreachable.\n     fn resolve_label(&self, mut label: Ident) -> Option<NodeId> {\n@@ -1379,7 +1474,11 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             this.with_generic_param_rib(\n                 &generics.params,\n                 ItemRibKind(HasGenericParams::Yes),\n-                LifetimeRibKind::Generics { kind: LifetimeBinderKind::Item, span: generics.span },\n+                LifetimeRibKind::Generics {\n+                    parent: item.id,\n+                    kind: LifetimeBinderKind::Item,\n+                    span: generics.span,\n+                },\n                 |this| {\n                     let item_def_id = this.r.local_def_id(item.id).to_def_id();\n                     this.with_self_rib(\n@@ -1446,6 +1545,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                     &generics.params,\n                     ItemRibKind(HasGenericParams::Yes),\n                     LifetimeRibKind::Generics {\n+                        parent: item.id,\n                         kind: LifetimeBinderKind::Item,\n                         span: generics.span,\n                     },\n@@ -1458,6 +1558,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                     &generics.params,\n                     ItemRibKind(HasGenericParams::Yes),\n                     LifetimeRibKind::Generics {\n+                        parent: item.id,\n                         kind: LifetimeBinderKind::Function,\n                         span: generics.span,\n                     },\n@@ -1487,6 +1588,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                     &generics.params,\n                     ItemRibKind(HasGenericParams::Yes),\n                     LifetimeRibKind::Generics {\n+                        parent: item.id,\n                         kind: LifetimeBinderKind::Item,\n                         span: generics.span,\n                     },\n@@ -1506,7 +1608,11 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                                         this.with_generic_param_rib(\n                                             &generics.params,\n                                             AssocItemRibKind,\n-                                            LifetimeRibKind::Generics { span: generics.span, kind },\n+                                            LifetimeRibKind::Generics {\n+                                                parent: item.id,\n+                                                span: generics.span,\n+                                                kind,\n+                                            },\n                                             |this| {\n                                                 visit::walk_assoc_item(this, item, AssocCtxt::Trait)\n                                             },\n@@ -1571,6 +1677,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                     &generics.params,\n                     ItemRibKind(HasGenericParams::Yes),\n                     LifetimeRibKind::Generics {\n+                        parent: item.id,\n                         kind: LifetimeBinderKind::Item,\n                         span: generics.span,\n                     },\n@@ -1708,7 +1815,10 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                 GenericParamKind::Type { .. } => (&mut function_type_rib, DefKind::TyParam),\n                 GenericParamKind::Const { .. } => (&mut function_value_rib, DefKind::ConstParam),\n                 GenericParamKind::Lifetime => {\n-                    function_lifetime_rib.bindings.insert(ident, ());\n+                    let LifetimeRibKind::Generics { parent, .. } = lifetime_kind else { panic!() };\n+                    let res = LifetimeRes::Param { param: def_id, binder: parent };\n+                    self.record_lifetime_res(param.id, res);\n+                    function_lifetime_rib.bindings.insert(ident, res);\n                     continue;\n                 }\n             };\n@@ -1849,10 +1959,10 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n     ) {\n         debug!(\"resolve_implementation\");\n         // If applicable, create a rib for the type parameters.\n-        self.with_generic_param_rib(&generics.params, ItemRibKind(HasGenericParams::Yes), LifetimeRibKind::Generics { span: generics.span, kind: LifetimeBinderKind::ImplBlock }, |this| {\n+        self.with_generic_param_rib(&generics.params, ItemRibKind(HasGenericParams::Yes), LifetimeRibKind::Generics { span: generics.span, parent: item_id, kind: LifetimeBinderKind::ImplBlock }, |this| {\n             // Dummy self type for better errors if `Self` is used in the trait path.\n             this.with_self_rib(Res::SelfTy { trait_: None, alias_to: None }, |this| {\n-                this.with_lifetime_rib(LifetimeRibKind::AnonymousCreateParameter, |this| {\n+                this.with_lifetime_rib(LifetimeRibKind::AnonymousCreateParameter(item_id), |this| {\n                     // Resolve the trait reference, if necessary.\n                     this.with_optional_trait_ref(opt_trait_reference.as_ref(), |this, trait_id| {\n                         let item_def_id = this.r.local_def_id(item_id);\n@@ -1876,7 +1986,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                             this.visit_generics(generics);\n \n                             // Resolve the items within the impl.\n-                            this.with_lifetime_rib(LifetimeRibKind::AnonymousPassThrough,\n+                            this.with_lifetime_rib(LifetimeRibKind::AnonymousPassThrough(item_id),\n                                 |this| {\n                                     this.with_current_self_type(self_type, |this| {\n                                         this.with_self_rib_ns(ValueNS, Res::SelfCtor(item_def_id), |this| {\n@@ -1921,7 +2031,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                                                         this.with_generic_param_rib(\n                                                             &generics.params,\n                                                             AssocItemRibKind,\n-                                                            LifetimeRibKind::Generics { span: generics.span, kind: LifetimeBinderKind::Function },\n+                                                            LifetimeRibKind::Generics { parent: item.id, span: generics.span, kind: LifetimeBinderKind::Function },\n                                                             |this| {\n                                                                 // If this is a trait impl, ensure the method\n                                                                 // exists in trait\n@@ -1950,7 +2060,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                                                         this.with_generic_param_rib(\n                                                             &generics.params,\n                                                             AssocItemRibKind,\n-                                                            LifetimeRibKind::Generics { span: generics.span, kind: LifetimeBinderKind::Item },\n+                                                            LifetimeRibKind::Generics { parent: item.id, span: generics.span, kind: LifetimeBinderKind::Item },\n                                                             |this| {\n                                                                 // If this is a trait impl, ensure the type\n                                                                 // exists in trait"}, {"sha": "69f69d5f56686f9874df5078a3e3ae271eb1a68a", "filename": "compiler/rustc_resolve/src/late/diagnostics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/f385f856cd9df6ded13248cc3d25e603e38b4f2f/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f385f856cd9df6ded13248cc3d25e603e38b4f2f/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fdiagnostics.rs?ref=f385f856cd9df6ded13248cc3d25e603e38b4f2f", "patch": "@@ -1824,7 +1824,7 @@ impl<'a: 'ast, 'ast> LateResolutionVisitor<'a, '_, 'ast> {\n \n         for rib in self.lifetime_ribs.iter().rev() {\n             match rib.kind {\n-                LifetimeRibKind::Generics { span, kind } => {\n+                LifetimeRibKind::Generics { parent: _, span, kind } => {\n                     if !span.can_be_used_for_suggestions() && suggest_note {\n                         suggest_note = false; // Avoid displaying the same help multiple times.\n                         err.span_label("}, {"sha": "180198326bbbc5f545d683dfa0a48af84f2c6cb2", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f385f856cd9df6ded13248cc3d25e603e38b4f2f/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f385f856cd9df6ded13248cc3d25e603e38b4f2f/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=f385f856cd9df6ded13248cc3d25e603e38b4f2f", "patch": "@@ -29,7 +29,7 @@ use rustc_arena::{DroplessArena, TypedArena};\n use rustc_ast::node_id::NodeMap;\n use rustc_ast::{self as ast, NodeId, CRATE_NODE_ID};\n use rustc_ast::{AngleBracketedArg, Crate, Expr, ExprKind, GenericArg, GenericArgs, LitKind, Path};\n-use rustc_ast_lowering::ResolverAstLowering;\n+use rustc_ast_lowering::{LifetimeRes, ResolverAstLowering};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexMap};\n use rustc_data_structures::intern::Interned;\n use rustc_data_structures::sync::Lrc;\n@@ -901,6 +901,8 @@ pub struct Resolver<'a> {\n     import_res_map: NodeMap<PerNS<Option<Res>>>,\n     /// Resolutions for labels (node IDs of their corresponding blocks or loops).\n     label_res_map: NodeMap<NodeId>,\n+    /// Resolutions for lifetimes.\n+    lifetimes_res_map: NodeMap<LifetimeRes>,\n \n     /// `CrateNum` resolutions of `extern crate` items.\n     extern_crate_map: FxHashMap<LocalDefId, CrateNum>,\n@@ -1153,6 +1155,10 @@ impl ResolverAstLowering for Resolver<'_> {\n         self.label_res_map.get(&id).cloned()\n     }\n \n+    fn get_lifetime_res(&self, id: NodeId) -> Option<LifetimeRes> {\n+        self.lifetimes_res_map.get(&id).copied()\n+    }\n+\n     fn create_stable_hashing_context(&self) -> StableHashingContext<'_> {\n         StableHashingContext::new(self.session, &self.definitions, self.crate_loader.cstore())\n     }\n@@ -1301,6 +1307,7 @@ impl<'a> Resolver<'a> {\n             partial_res_map: Default::default(),\n             import_res_map: Default::default(),\n             label_res_map: Default::default(),\n+            lifetimes_res_map: Default::default(),\n             extern_crate_map: Default::default(),\n             reexport_map: FxHashMap::default(),\n             trait_map: NodeMap::default(),"}]}