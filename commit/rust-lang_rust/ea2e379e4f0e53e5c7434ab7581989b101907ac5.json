{"sha": "ea2e379e4f0e53e5c7434ab7581989b101907ac5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVhMmUzNzllNGYwZTUzZTVjNzQzNGFiNzU4MTk4OWIxMDE5MDdhYzU=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-03-21T14:42:20Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2012-03-23T09:49:47Z"}, "message": "Implement built-in native modules as an alternative to intrinsics\n\nIssue #1981", "tree": {"sha": "918c6a3b1776d4a3de73f16d7340a3d9008481a7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/918c6a3b1776d4a3de73f16d7340a3d9008481a7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ea2e379e4f0e53e5c7434ab7581989b101907ac5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ea2e379e4f0e53e5c7434ab7581989b101907ac5", "html_url": "https://github.com/rust-lang/rust/commit/ea2e379e4f0e53e5c7434ab7581989b101907ac5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ea2e379e4f0e53e5c7434ab7581989b101907ac5/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "73a0c17d77afecbf6d10b4c91531759e280e169f", "url": "https://api.github.com/repos/rust-lang/rust/commits/73a0c17d77afecbf6d10b4c91531759e280e169f", "html_url": "https://github.com/rust-lang/rust/commit/73a0c17d77afecbf6d10b4c91531759e280e169f"}], "stats": {"total": 252, "additions": 195, "deletions": 57}, "files": [{"sha": "8c991517d88f0ea6deb1e29ec2086a77ec69f5b3", "filename": "src/rustc/front/attr.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ea2e379e4f0e53e5c7434ab7581989b101907ac5/src%2Frustc%2Ffront%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea2e379e4f0e53e5c7434ab7581989b101907ac5/src%2Frustc%2Ffront%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Ffront%2Fattr.rs?ref=ea2e379e4f0e53e5c7434ab7581989b101907ac5", "patch": "@@ -240,6 +240,9 @@ fn native_abi(attrs: [ast::attribute]) -> either<str, ast::native_abi> {\n       option::some(\"rust-intrinsic\") {\n         either::right(ast::native_abi_rust_intrinsic)\n       }\n+      option::some(\"rust-builtin\") {\n+        either::right(ast::native_abi_rust_builtin)\n+      }\n       option::some(\"cdecl\") {\n         either::right(ast::native_abi_cdecl)\n       }"}, {"sha": "9f9b0c986f88faf300a4ba6a59b4e40a30919342", "filename": "src/rustc/metadata/astencode.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ea2e379e4f0e53e5c7434ab7581989b101907ac5/src%2Frustc%2Fmetadata%2Fastencode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea2e379e4f0e53e5c7434ab7581989b101907ac5/src%2Frustc%2Fmetadata%2Fastencode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fastencode.rs?ref=ea2e379e4f0e53e5c7434ab7581989b101907ac5", "patch": "@@ -374,6 +374,9 @@ fn simplify_ast(ii: ast::inlined_item) -> ast::inlined_item {\n       ast::ii_method(d, m) {\n         ast::ii_method(d, fld.fold_method(m))\n       }\n+      ast::ii_native(i) {\n+        ast::ii_native(fld.fold_native_item(i))\n+      }\n     }\n }\n \n@@ -398,6 +401,9 @@ fn renumber_ast(xcx: extended_decode_ctxt, ii: ast::inlined_item)\n       ast::ii_method(d, m) {\n         ast::ii_method(xcx.tr_def_id(d), fld.fold_method(m))\n       }\n+      ast::ii_native(i) {\n+        ast::ii_native(fld.fold_native_item(i))\n+      }\n     }\n }\n "}, {"sha": "69086d4698bf650fe7e52354685516bef80709d8", "filename": "src/rustc/metadata/encoder.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/ea2e379e4f0e53e5c7434ab7581989b101907ac5/src%2Frustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea2e379e4f0e53e5c7434ab7581989b101907ac5/src%2Frustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fencoder.rs?ref=ea2e379e4f0e53e5c7434ab7581989b101907ac5", "patch": "@@ -681,7 +681,12 @@ fn encode_info_for_native_item(ecx: @encode_ctxt, ebml_w: ebml::writer,\n             ebml_w.end_tag();\n         }\n         encode_type(ecx, ebml_w, node_id_to_type(ecx.ccx.tcx, nitem.id));\n-        encode_symbol(ecx, ebml_w, nitem.id);\n+        if abi == native_abi_rust_builtin {\n+            astencode::encode_inlined_item(ecx, ebml_w, path,\n+                                           ii_native(nitem));\n+        } else {\n+            encode_symbol(ecx, ebml_w, nitem.id);\n+        }\n         encode_path(ebml_w, path, ast_map::path_name(nitem.ident));\n       }\n     }"}, {"sha": "7e3de19c4329889d85340546146c4f9301e3d1b1", "filename": "src/rustc/middle/ast_map.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ea2e379e4f0e53e5c7434ab7581989b101907ac5/src%2Frustc%2Fmiddle%2Fast_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea2e379e4f0e53e5c7434ab7581989b101907ac5/src%2Frustc%2Fmiddle%2Fast_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fast_map.rs?ref=ea2e379e4f0e53e5c7434ab7581989b101907ac5", "patch": "@@ -91,6 +91,10 @@ fn map_decoded_item(sess: session, map: map, path: path, ii: inlined_item) {\n     // add it to the table now:\n     alt ii {\n       ii_item(i) { /* fallthrough */ }\n+      ii_native(i) {\n+        cx.map.insert(i.id, node_native_item(i, native_abi_rust_builtin,\n+                                             @path));\n+      }\n       ii_method(impl_did, m) {\n         map_method(impl_did, @path, m, cx);\n       }"}, {"sha": "806237ca59cc4e10b6d95d019b26b52a96b773cd", "filename": "src/rustc/middle/lint.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ea2e379e4f0e53e5c7434ab7581989b101907ac5/src%2Frustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea2e379e4f0e53e5c7434ab7581989b101907ac5/src%2Frustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Flint.rs?ref=ea2e379e4f0e53e5c7434ab7581989b101907ac5", "patch": "@@ -123,7 +123,8 @@ fn check_ctypes(tcx: ty::ctxt, crate: @ast::crate) {\n \n     fn check_item(tcx: ty::ctxt, it: @ast::item) {\n         alt it.node {\n-          ast::item_native_mod(nmod) {\n+          ast::item_native_mod(nmod) if attr::native_abi(it.attrs) !=\n+              either::right(ast::native_abi_rust_builtin) {\n             for ni in nmod.items {\n                 alt ni.node {\n                   ast::native_item_fn(decl, tps) {"}, {"sha": "4d82987ce02bbc379f8dd77a2da8a5ad2c51612d", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 32, "deletions": 27, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/ea2e379e4f0e53e5c7434ab7581989b101907ac5/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea2e379e4f0e53e5c7434ab7581989b101907ac5/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=ea2e379e4f0e53e5c7434ab7581989b101907ac5", "patch": "@@ -337,7 +337,7 @@ fn trans_malloc_boxed_raw(bcx: block, t: ty::t,\n     let llty = type_of(ccx, box_ptr);\n \n     // Get the tydesc for the body:\n-    let {bcx, val: lltydesc} = get_tydesc(bcx, t, static_ti);\n+    let lltydesc = get_tydesc(ccx, t, static_ti);\n     lazily_emit_all_tydesc_glue(ccx, static_ti);\n \n     // Allocate space:\n@@ -358,18 +358,18 @@ fn trans_malloc_boxed(bcx: block, t: ty::t) ->\n \n // Type descriptor and type glue stuff\n \n-fn get_tydesc_simple(bcx: block, t: ty::t) -> result {\n+fn get_tydesc_simple(ccx: @crate_ctxt, t: ty::t) -> ValueRef {\n     let mut ti = none;\n-    get_tydesc(bcx, t, ti)\n+    get_tydesc(ccx, t, ti)\n }\n \n-fn get_tydesc(cx: block, t: ty::t,\n-              &static_ti: option<@tydesc_info>) -> result {\n+fn get_tydesc(ccx: @crate_ctxt, t: ty::t,\n+              &static_ti: option<@tydesc_info>) -> ValueRef {\n     assert !ty::type_has_params(t);\n     // Otherwise, generate a tydesc if necessary, and return it.\n-    let info = get_static_tydesc(cx.ccx(), t);\n+    let info = get_static_tydesc(ccx, t);\n     static_ti = some(info);\n-    ret rslt(cx, info.tydesc);\n+    info.tydesc\n }\n \n fn get_static_tydesc(ccx: @crate_ctxt, t: ty::t) -> @tydesc_info {\n@@ -699,7 +699,7 @@ fn get_res_dtor(ccx: @crate_ctxt, did: ast::def_id, substs: [ty::t])\n         maybe_instantiate_inline(ccx, did)\n     } else { did };\n     assert did.crate == ast::local_crate;\n-    monomorphic_fn(ccx, did, substs, none).val\n+    monomorphic_fn(ccx, did, substs, none, none).val\n }\n \n fn trans_res_drop(bcx: block, rs: ValueRef, did: ast::def_id,\n@@ -1074,10 +1074,10 @@ fn call_tydesc_glue_full(cx: block, v: ValueRef, tydesc: ValueRef,\n fn call_tydesc_glue(cx: block, v: ValueRef, t: ty::t, field: int) ->\n    block {\n     let _icx = cx.insn_ctxt(\"call_tydesc_glue\");\n-    let mut ti: option<@tydesc_info> = none;\n-    let {bcx: bcx, val: td} = get_tydesc(cx, t, ti);\n-    call_tydesc_glue_full(bcx, v, td, field, ti);\n-    ret bcx;\n+    let mut ti = none;\n+    let td = get_tydesc(cx.ccx(), t, ti);\n+    call_tydesc_glue_full(cx, v, td, field, ti);\n+    ret cx;\n }\n \n fn call_cmp_glue(cx: block, lhs: ValueRef, rhs: ValueRef, t: ty::t,\n@@ -1096,11 +1096,9 @@ fn call_cmp_glue(cx: block, lhs: ValueRef, rhs: ValueRef, t: ty::t,\n \n     let llrawlhsptr = BitCast(bcx, lllhs, T_ptr(T_i8()));\n     let llrawrhsptr = BitCast(bcx, llrhs, T_ptr(T_i8()));\n-    let r = get_tydesc_simple(bcx, t);\n-    let lltydesc = r.val;\n-    let bcx = r.bcx;\n-    let lltydescs = GEPi(bcx, lltydesc, [0, abi::tydesc_field_first_param]);\n-    let lltydescs = Load(bcx, lltydescs);\n+    let lltydesc = get_tydesc_simple(bcx.ccx(), t);\n+    let lltydescs =\n+        Load(bcx, GEPi(bcx, lltydesc, [0, abi::tydesc_field_first_param]));\n \n     let llfn = bcx.ccx().upcalls.cmp_type;\n \n@@ -1171,9 +1169,7 @@ fn call_memmove(cx: block, dst: ValueRef, src: ValueRef,\n       session::arch_x86 | session::arch_arm { \"llvm.memmove.p0i8.p0i8.i32\" }\n       session::arch_x86_64 { \"llvm.memmove.p0i8.p0i8.i64\" }\n     };\n-    let i = ccx.intrinsics;\n-    assert (i.contains_key(key));\n-    let memmove = i.get(key);\n+    let memmove = ccx.intrinsics.get(key);\n     let src_ptr = PointerCast(cx, src, T_ptr(T_i8()));\n     let dst_ptr = PointerCast(cx, dst, T_ptr(T_i8()));\n     let size = IntCast(cx, n_bytes, ccx.int_type);\n@@ -1911,7 +1907,8 @@ fn make_mono_id(ccx: @crate_ctxt, item: ast::def_id, substs: [ty::t],\n }\n \n fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id, real_substs: [ty::t],\n-                  vtables: option<typeck::vtable_res>)\n+                  vtables: option<typeck::vtable_res>,\n+                  ref_id: option<ast::node_id>)\n     -> {val: ValueRef, must_cast: bool, intrinsic: bool} {\n     let _icx = ccx.insn_ctxt(\"monomorphic_fn\");\n     let mut must_cast = false;\n@@ -1952,6 +1949,8 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id, real_substs: [ty::t],\n       }\n       ast_map::node_variant(v, _, pt) { (pt, v.node.name) }\n       ast_map::node_method(m, _, pt) { (pt, m.ident) }\n+      ast_map::node_native_item(i, ast::native_abi_rust_builtin, pt)\n+      { (pt, i.ident) }\n       ast_map::node_native_item(_, abi, _) {\n         // Natives don't have to be monomorphized.\n         ret {val: get_item_val(ccx, fn_id.node),\n@@ -1984,6 +1983,10 @@ fn monomorphic_fn(ccx: @crate_ctxt, fn_id: ast::def_id, real_substs: [ty::t],\n       ast_map::node_item(@{node: ast::item_res(d, _, body, d_id, _), _}, _) {\n         trans_fn(ccx, pt, d, body, lldecl, no_self, psubsts, d_id, none);\n       }\n+      ast_map::node_native_item(i, _, _) {\n+        native::trans_builtin(ccx, lldecl, i, pt, option::get(psubsts),\n+                              ref_id);\n+      }\n       ast_map::node_variant(v, enum_item, _) {\n         let tvs = ty::enum_variants(ccx.tcx, local_def(enum_item.id));\n         let this_tv = option::get(vec::find(*tvs, {|tv|\n@@ -2036,6 +2039,10 @@ fn maybe_instantiate_inline(ccx: @crate_ctxt, fn_id: ast::def_id)\n             trans_item(ccx, *item);\n             local_def(item.id)\n           }\n+          csearch::found(ast::ii_native(item)) {\n+            ccx.external.insert(fn_id, some(item.id));\n+            local_def(item.id)\n+          }\n           csearch::found_parent(parent_id, ast::ii_item(item)) {\n             ccx.external.insert(parent_id, some(item.id));\n             let mut my_id = 0;\n@@ -2088,11 +2095,9 @@ fn lval_intrinsic_fn(bcx: block, val: ValueRef, tys: [ty::t],\n     let mut bcx = bcx;\n     let ccx = bcx.ccx();\n     let tds = vec::map(tys, {|t|\n-        let mut ti = none;\n-        let td_res = get_tydesc(bcx, t, ti);\n-        bcx = td_res.bcx;\n+        let mut ti = none, td = get_tydesc(bcx.ccx(), t, ti);\n         lazily_emit_all_tydesc_glue(ccx, ti);\n-        td_res.val\n+        td\n     });\n     let llfty = type_of_fn_from_ty(ccx, node_id_type(bcx, id));\n     let val = PointerCast(bcx, val, T_ptr(add_tydesc_params(\n@@ -2124,7 +2129,7 @@ fn lval_static_fn_inner(bcx: block, fn_id: ast::def_id, id: ast::node_id,\n \n     if fn_id.crate == ast::local_crate && tys.len() > 0u {\n         let mut {val, must_cast, intrinsic} =\n-            monomorphic_fn(ccx, fn_id, tys, vtables);\n+            monomorphic_fn(ccx, fn_id, tys, vtables, some(id));\n         if intrinsic { ret lval_intrinsic_fn(bcx, val, tys, id); }\n         if must_cast {\n             val = PointerCast(bcx, val, T_ptr(type_of_fn_from_ty(\n@@ -3318,7 +3323,7 @@ fn trans_log(lvl: @ast::expr, bcx: block, e: @ast::expr) -> block {\n         with_scope(bcx, \"log\") {|bcx|\n             let {bcx, val, _} = trans_temp_expr(bcx, e);\n             let e_ty = expr_ty(bcx, e);\n-            let {bcx, val: tydesc} = get_tydesc_simple(bcx, e_ty);\n+            let tydesc = get_tydesc_simple(ccx, e_ty);\n             // Call the polymorphic log function.\n             let {bcx, val} = spill_if_immediate(bcx, val, e_ty);\n             let val = PointerCast(bcx, val, T_ptr(T_i8()));"}, {"sha": "153cc079d6b4eeb0af3f93c69bdf2cea316e61ae", "filename": "src/rustc/middle/trans/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ea2e379e4f0e53e5c7434ab7581989b101907ac5/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea2e379e4f0e53e5c7434ab7581989b101907ac5/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fclosure.rs?ref=ea2e379e4f0e53e5c7434ab7581989b101907ac5", "patch": "@@ -164,7 +164,7 @@ fn allocate_cbox(bcx: block,\n                     box: ValueRef,\n                     &ti: option<@tydesc_info>) -> block {\n         let bound_tydesc = GEPi(bcx, box, [0, abi::box_field_tydesc]);\n-        let {bcx, val: td} = base::get_tydesc(bcx, cdata_ty, ti);\n+        let td = base::get_tydesc(bcx.ccx(), cdata_ty, ti);\n         Store(bcx, td, bound_tydesc);\n         bcx\n     }"}, {"sha": "58d11cebee22a8181538a80dde9fe3c0bc0b202f", "filename": "src/rustc/middle/trans/common.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ea2e379e4f0e53e5c7434ab7581989b101907ac5/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea2e379e4f0e53e5c7434ab7581989b101907ac5/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=ea2e379e4f0e53e5c7434ab7581989b101907ac5", "patch": "@@ -804,6 +804,10 @@ fn C_shape(ccx: @crate_ctxt, bytes: [u8]) -> ValueRef {\n     ret llvm::LLVMConstPointerCast(llglobal, T_ptr(T_i8()));\n }\n \n+fn get_param(fndecl: ValueRef, param: uint) -> ValueRef {\n+    llvm::LLVMGetParam(fndecl, param as c_uint)\n+}\n+\n // Used to identify cached monomorphized functions and vtables\n enum mono_param_id {\n     mono_precise(ty::t, option<[mono_id]>),"}, {"sha": "3fa4dfc80b0bc2c3a4e8fc36b018f0d1fa2367a7", "filename": "src/rustc/middle/trans/impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ea2e379e4f0e53e5c7434ab7581989b101907ac5/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea2e379e4f0e53e5c7434ab7581989b101907ac5/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fimpl.rs?ref=ea2e379e4f0e53e5c7434ab7581989b101907ac5", "patch": "@@ -251,7 +251,7 @@ fn make_impl_vtable(ccx: @crate_ctxt, impl_id: ast::def_id, substs: [ty::t],\n         } else {\n             let m_id = method_with_name(ccx, impl_id, im.ident);\n             if has_tps {\n-                monomorphic_fn(ccx, m_id, substs, some(vtables)).val\n+                monomorphic_fn(ccx, m_id, substs, some(vtables), none).val\n             } else if m_id.crate == ast::local_crate {\n                 get_item_val(ccx, m_id.node)\n             } else {"}, {"sha": "049e31325d7ad14e6f97d511d203c30b74bc00d8", "filename": "src/rustc/middle/trans/native.rs", "status": "modified", "additions": 69, "deletions": 20, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/ea2e379e4f0e53e5c7434ab7581989b101907ac5/src%2Frustc%2Fmiddle%2Ftrans%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea2e379e4f0e53e5c7434ab7581989b101907ac5/src%2Frustc%2Fmiddle%2Ftrans%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fnative.rs?ref=ea2e379e4f0e53e5c7434ab7581989b101907ac5", "patch": "@@ -6,16 +6,17 @@ import lib::llvm::{ llvm, TypeRef, ValueRef,\n                     ModuleRef, CallConv, Attribute,\n                     StructRetAttribute, ByValAttribute\n                   };\n-import syntax::ast;\n+import syntax::{ast, ast_util};\n import back::link;\n import common::*;\n import build::*;\n import base::*;\n import type_of::*;\n import std::map::hashmap;\n+import util::ppaux::ty_to_str;\n \n export link_name, trans_native_mod, register_crust_fn, trans_crust_fn,\n-       decl_native_fn;\n+       decl_native_fn, trans_builtin;\n \n enum x86_64_reg_class {\n     no_class,\n@@ -384,7 +385,7 @@ fn decl_x86_64_fn(tys: x86_64_tys,\n     vec::iteri(tys.attrs) {|i, a|\n         alt a {\n             option::some(attr) {\n-                let llarg = llvm::LLVMGetParam(llfn, i as c_uint);\n+                let llarg = get_param(llfn, i);\n                 llvm::LLVMAddAttribute(llarg, attr as c_uint);\n             }\n             _ {}\n@@ -462,7 +463,7 @@ fn build_shim_fn_(ccx: @crate_ctxt,\n     let fcx = new_fn_ctxt(ccx, [], llshimfn, none);\n     let bcx = top_scope_block(fcx, none);\n     let lltop = bcx.llbb;\n-    let llargbundle = llvm::LLVMGetParam(llshimfn, 0 as c_uint);\n+    let llargbundle = get_param(llshimfn, 0u);\n     let llargvals = arg_builder(bcx, tys, llargbundle);\n \n     // Create the call itself and store the return value:\n@@ -683,13 +684,11 @@ fn trans_native_mod(ccx: @crate_ctxt,\n             let n = vec::len(tys.arg_tys);\n             let implicit_args = first_real_arg; // ret + env\n             while i < n {\n-                let llargval = llvm::LLVMGetParam(\n-                    llwrapfn,\n-                    (i + implicit_args) as c_uint);\n+                let llargval = get_param(llwrapfn, i + implicit_args);\n                 store_inbounds(bcx, llargval, llargbundle, [0, i as int]);\n                 i += 1u;\n             }\n-            let llretptr = llvm::LLVMGetParam(llwrapfn, 0 as c_uint);\n+            let llretptr = get_param(llwrapfn, 0u);\n             store_inbounds(bcx, llretptr, llargbundle, [0, n as int]);\n         }\n \n@@ -704,15 +703,15 @@ fn trans_native_mod(ccx: @crate_ctxt,\n                        build_args, build_ret);\n     }\n \n-    let mut cc = lib::llvm::CCallConv;\n-    alt abi {\n+    let mut cc = alt abi {\n       ast::native_abi_rust_intrinsic {\n         for item in native_mod.items { get_item_val(ccx, item.id); }\n         ret;\n       }\n-      ast::native_abi_cdecl { cc = lib::llvm::CCallConv; }\n-      ast::native_abi_stdcall { cc = lib::llvm::X86StdcallCallConv; }\n-    }\n+      ast::native_abi_rust_builtin { ret; }\n+      ast::native_abi_cdecl { lib::llvm::CCallConv }\n+      ast::native_abi_stdcall { lib::llvm::X86StdcallCallConv }\n+    };\n \n     for native_item in native_mod.items {\n       alt native_item.node {\n@@ -727,6 +726,58 @@ fn trans_native_mod(ccx: @crate_ctxt,\n     }\n }\n \n+fn trans_builtin(ccx: @crate_ctxt, decl: ValueRef, item: @ast::native_item,\n+                 path: ast_map::path, substs: param_substs,\n+                 ref_id: option<ast::node_id>) {\n+    let fcx = new_fn_ctxt_w_id(ccx, path, decl, item.id, none,\n+                               some(substs), some(item.span));\n+    let bcx = top_scope_block(fcx, none), lltop = bcx.llbb;\n+    let tp_ty = substs.tys[0], lltp_ty = type_of::type_of(ccx, tp_ty);\n+    alt check item.ident {\n+      \"size_of\" {\n+        Store(bcx, C_uint(ccx, shape::llsize_of_real(ccx, lltp_ty)),\n+              fcx.llretptr);\n+      }\n+      \"align_of\" {\n+        Store(bcx, C_uint(ccx, shape::llalign_of_real(ccx, lltp_ty)),\n+              fcx.llretptr);\n+      }\n+      \"get_tydesc\" {\n+        let td = get_tydesc_simple(ccx, tp_ty);\n+        Store(bcx, PointerCast(bcx, td, T_ptr(T_nil())), fcx.llretptr);\n+      }\n+      \"init\" {\n+        if !ty::type_is_nil(tp_ty) {\n+            Store(bcx, C_null(lltp_ty), fcx.llretptr);\n+        }\n+      }\n+      \"forget\" {}\n+      \"reinterpret_cast\" {\n+        let llout_ty = type_of::type_of(ccx, substs.tys[1]);\n+        if shape::llsize_of_real(ccx, lltp_ty) !=\n+           shape::llsize_of_real(ccx, llout_ty) {\n+            let sp = alt check ccx.tcx.items.get(option::get(ref_id)) {\n+              ast_map::node_expr(e) { e.span }\n+            };\n+            ccx.sess.span_fatal(sp, \"reinterpret_cast called on types \\\n+                                     with different size: \" +\n+                                ty_to_str(ccx.tcx, tp_ty) + \" to \" +\n+                                ty_to_str(ccx.tcx, substs.tys[1]));\n+        }\n+        if !ty::type_is_nil(substs.tys[1]) {\n+            let cast = PointerCast(bcx, get_param(decl, first_real_arg),\n+                                   T_ptr(llout_ty));\n+            Store(bcx, Load(bcx, cast), fcx.llretptr);\n+        }\n+      }\n+      \"addr_of\" {\n+        Store(bcx, get_param(decl, first_real_arg), fcx.llretptr);\n+      }\n+    }\n+    build_return(bcx);\n+    finish_fn(fcx, lltop);\n+}\n+\n fn trans_crust_fn(ccx: @crate_ctxt, path: ast_map::path, decl: ast::fn_decl,\n                   body: ast::blk, llwrapfn: ValueRef, id: ast::node_id) {\n \n@@ -799,7 +850,7 @@ fn trans_crust_fn(ccx: @crate_ctxt, path: ast_map::path, decl: ast::fn_decl,\n                         atys = vec::tail(atys);\n                         attrs = vec::tail(attrs);\n                         j = 1u;\n-                        llvm::LLVMGetParam(llwrapfn, 0 as c_uint)\n+                        get_param(llwrapfn, 0u)\n                     } else if x86_64.ret_ty.cast {\n                         let retptr = alloca(bcx, x86_64.ret_ty.ty);\n                         BitCast(bcx, retptr, T_ptr(tys.ret_ty))\n@@ -810,8 +861,7 @@ fn trans_crust_fn(ccx: @crate_ctxt, path: ast_map::path, decl: ast::fn_decl,\n                     let mut i = 0u;\n                     let n = vec::len(atys);\n                     while i < n {\n-                        let mut argval =\n-                            llvm::LLVMGetParam(llwrapfn, (i + j) as c_uint);\n+                        let mut argval = get_param(llwrapfn, i + j);\n                         if option::is_some(attrs[i]) {\n                             argval = Load(bcx, argval);\n                             store_inbounds(bcx, argval, llargbundle,\n@@ -835,8 +885,7 @@ fn trans_crust_fn(ccx: @crate_ctxt, path: ast_map::path, decl: ast::fn_decl,\n                     let mut i = 0u;\n                     let n = vec::len(tys.arg_tys);\n                     while i < n {\n-                        let llargval = llvm::LLVMGetParam(llwrapfn,\n-                                                          i as c_uint);\n+                        let llargval = get_param(llwrapfn, i);\n                         store_inbounds(bcx, llargval, llargbundle,\n                                                       [0, i as int]);\n                         i += 1u;\n@@ -944,8 +993,8 @@ fn decl_native_fn(ccx: @crate_ctxt, i: @ast::native_item,\n             get_extern_fn(ccx.externs, ccx.llmod, ri_name,\n                           lib::llvm::CCallConv, fn_type)\n           }\n-\n-          ast::native_abi_cdecl | ast::native_abi_stdcall {\n+          ast::native_abi_cdecl | ast::native_abi_stdcall |\n+          ast::native_abi_rust_builtin {\n             // For true external functions: create a rust wrapper\n             // and link to that.  The rust wrapper will handle\n             // switching to the C stack."}, {"sha": "7c58c5c8e54792db9f269f70a0f034bce17c078c", "filename": "src/rustc/middle/trans/tvec.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ea2e379e4f0e53e5c7434ab7581989b101907ac5/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea2e379e4f0e53e5c7434ab7581989b101907ac5/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=ea2e379e4f0e53e5c7434ab7581989b101907ac5", "patch": "@@ -183,10 +183,10 @@ fn trans_append(bcx: block, vec_ty: ty::t, lhsptr: ValueRef,\n fn trans_append_literal(bcx: block, vptrptr: ValueRef, vec_ty: ty::t,\n                         vals: [@ast::expr]) -> block {\n     let _icx = bcx.insn_ctxt(\"tvec::trans_append_literal\");\n-    let ccx = bcx.ccx();\n+    let mut bcx = bcx, ccx = bcx.ccx();\n     let elt_ty = ty::sequence_element_type(bcx.tcx(), vec_ty);\n     let mut ti = none;\n-    let mut {bcx: bcx, val: td} = get_tydesc(bcx, elt_ty, ti);\n+    let td = get_tydesc(ccx, elt_ty, ti);\n     base::lazily_emit_tydesc_glue(ccx, abi::tydesc_field_take_glue, ti);\n     let opaque_v = PointerCast(bcx, vptrptr,\n                                T_ptr(T_ptr(ccx.opaque_vec_type)));"}, {"sha": "73e6d2662bb259e6a593aa5cb33bd5fd0cc8e94d", "filename": "src/rustc/middle/trans/type_use.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ea2e379e4f0e53e5c7434ab7581989b101907ac5/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea2e379e4f0e53e5c7434ab7581989b101907ac5/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Ftype_use.rs?ref=ea2e379e4f0e53e5c7434ab7581989b101907ac5", "patch": "@@ -71,9 +71,17 @@ fn type_uses_for(ccx: @crate_ctxt, fn_id: def_id, n_tps: uint)\n       ast_map::node_variant(_, _, _) {\n         uint::range(0u, n_tps) {|n| cx.uses[n] |= use_repr;}\n       }\n-      ast_map::node_native_item(@{node: native_item_fn(_, _), _}, abi, _) {\n+      ast_map::node_native_item(i@@{node: native_item_fn(_, _), _}, abi, _) {\n         if abi == native_abi_rust_intrinsic {\n             uint::range(0u, n_tps) {|n| cx.uses[n] |= use_tydesc;}\n+        } else if abi == native_abi_rust_builtin {\n+            let flags = alt check i.ident {\n+              \"size_of\" | \"align_of\" | \"init\" |\n+              \"reinterpret_cast\" { use_repr }\n+              \"get_tydesc\" { use_tydesc }\n+              \"forget\" | \"addr_of\" { 0u }\n+            };\n+            uint::range(0u, n_tps) {|n| cx.uses[n] |= flags;}\n         }\n       }\n       ast_map::node_ctor(@{node: item_class(_, _, ctor), _}, _) {"}, {"sha": "38d2ba369ec6d6c18115f567f42f45462a8ed49b", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ea2e379e4f0e53e5c7434ab7581989b101907ac5/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea2e379e4f0e53e5c7434ab7581989b101907ac5/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=ea2e379e4f0e53e5c7434ab7581989b101907ac5", "patch": "@@ -81,7 +81,7 @@ export ty_nil, mk_nil, type_is_nil;\n export ty_iface, mk_iface;\n export ty_res, mk_res;\n export ty_param, mk_param;\n-export ty_ptr, mk_ptr, mk_mut_ptr, mk_nil_ptr, type_is_unsafe_ptr;\n+export ty_ptr, mk_ptr, mk_mut_ptr, mk_imm_ptr, mk_nil_ptr, type_is_unsafe_ptr;\n export ty_rptr, mk_rptr;\n export ty_rec, mk_rec;\n export ty_enum, mk_enum, type_is_enum;\n@@ -492,6 +492,10 @@ fn mk_rptr(cx: ctxt, r: region, tm: mt) -> t { mk_t(cx, ty_rptr(r, tm)) }\n fn mk_mut_ptr(cx: ctxt, ty: t) -> t { mk_ptr(cx, {ty: ty,\n                                                   mutbl: ast::m_mutbl}) }\n \n+fn mk_imm_ptr(cx: ctxt, ty: t) -> t {\n+    mk_ptr(cx, {ty: ty, mutbl: ast::m_imm})\n+}\n+\n fn mk_nil_ptr(cx: ctxt) -> t {\n     mk_ptr(cx, {ty: mk_nil(cx), mutbl: ast::m_imm})\n }"}, {"sha": "4743d6556b50100ce4f39e0759e14ace514d76dd", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 45, "deletions": 1, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/ea2e379e4f0e53e5c7434ab7581989b101907ac5/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea2e379e4f0e53e5c7434ab7581989b101907ac5/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=ea2e379e4f0e53e5c7434ab7581989b101907ac5", "patch": "@@ -945,7 +945,13 @@ mod collect {\n     fn convert(tcx: ty::ctxt, it: @ast::item) {\n         alt it.node {\n           // These don't define types.\n-          ast::item_mod(_) | ast::item_native_mod(_) {}\n+          ast::item_mod(_) {}\n+          ast::item_native_mod(m) {\n+            if front::attr::native_abi(it.attrs) ==\n+               either::right(ast::native_abi_rust_builtin) {\n+                for item in m.items { check_builtin_type(tcx, item); }\n+            }\n+          }\n           ast::item_enum(variants, ty_params) {\n             let tpt = ty_of_item(tcx, m_collect, it);\n             write_ty(tcx, it.id, tpt.ty);\n@@ -1408,6 +1414,44 @@ mod writeback {\n     }\n }\n \n+fn check_builtin_type(tcx: ty::ctxt, it: @ast::native_item) {\n+    fn param(tcx: ty::ctxt, n: uint) -> ty::t {\n+        ty::mk_param(tcx, n, local_def(0))\n+    }\n+    fn arg(m: ast::rmode, ty: ty::t) -> ty::arg {\n+        {mode: ast::expl(m), ty: ty}\n+    }\n+    let (n_tps, inputs, output) = alt it.ident {\n+      \"size_of\" | \"align_of\" { (1u, [], ty::mk_uint(tcx)) }\n+      \"get_tydesc\" { (1u, [], ty::mk_nil_ptr(tcx)) }\n+      \"init\" { (1u, [], param(tcx, 0u)) }\n+      \"forget\" { (1u, [arg(ast::by_move, param(tcx, 0u))],\n+                  ty::mk_nil(tcx)) }\n+      \"reinterpret_cast\" { (2u, [arg(ast::by_ref, param(tcx, 0u))],\n+                            param(tcx, 1u)) }\n+      \"addr_of\" { (1u, [arg(ast::by_ref, param(tcx, 0u))],\n+                   ty::mk_imm_ptr(tcx, param(tcx, 0u))) }\n+      other {\n+        tcx.sess.span_err(it.span, \"unrecognized builtin function: `\" +\n+                          other + \"`\");\n+        ret;\n+      }\n+    };\n+    let fty = ty::mk_fn(tcx, {proto: ast::proto_bare,\n+                              inputs: inputs, output: output,\n+                              ret_style: ast::return_val,\n+                              constraints: []});\n+    let i_ty = ty_of_native_item(tcx, m_collect, it);\n+    let i_n_tps = (*i_ty.bounds).len();\n+    if i_n_tps != n_tps {\n+        tcx.sess.span_err(it.span, #fmt(\"builtin function has wrong number \\\n+                                         of type parameters. found %u, \\\n+                                         expected %u\", i_n_tps, n_tps));\n+    } else if !ty::same_type(tcx, i_ty.ty, fty) {\n+        tcx.sess.span_err(it.span, #fmt(\"builtin function has wrong type. \\\n+                                         expected %s\", ty_to_str(tcx, fty)));\n+    }\n+}\n \n // Local variable gathering. We gather up all locals and create variable IDs\n // for them before typechecking the function."}, {"sha": "0776ec3dfbd84a673212fedd0bed6df1f780cec5", "filename": "src/rustc/syntax/ast.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ea2e379e4f0e53e5c7434ab7581989b101907ac5/src%2Frustc%2Fsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea2e379e4f0e53e5c7434ab7581989b101907ac5/src%2Frustc%2Fsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fsyntax%2Fast.rs?ref=ea2e379e4f0e53e5c7434ab7581989b101907ac5", "patch": "@@ -557,6 +557,7 @@ type _mod = {view_items: [@view_item], items: [@item]};\n #[auto_serialize]\n enum native_abi {\n     native_abi_rust_intrinsic,\n+    native_abi_rust_builtin,\n     native_abi_cdecl,\n     native_abi_stdcall,\n }\n@@ -702,7 +703,8 @@ enum native_item_ {\n #[auto_serialize]\n enum inlined_item {\n     ii_item(@item),\n-    ii_method(def_id /* impl id */, @method)\n+    ii_method(def_id /* impl id */, @method),\n+    ii_native(@native_item),\n }\n \n //"}, {"sha": "57dbfacbfbb346fe8af3fd50d3eb87d01959ff5b", "filename": "src/rustc/syntax/ast_util.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ea2e379e4f0e53e5c7434ab7581989b101907ac5/src%2Frustc%2Fsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea2e379e4f0e53e5c7434ab7581989b101907ac5/src%2Frustc%2Fsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fsyntax%2Fast_util.rs?ref=ea2e379e4f0e53e5c7434ab7581989b101907ac5", "patch": "@@ -454,20 +454,23 @@ impl inlined_item_methods for inlined_item {\n     fn ident() -> ident {\n         alt self {\n           ii_item(i) { i.ident }\n+          ii_native(i) { i.ident }\n           ii_method(_, m) { m.ident }\n         }\n     }\n \n     fn id() -> ast::node_id {\n         alt self {\n           ii_item(i) { i.id }\n+          ii_native(i) { i.id }\n           ii_method(_, m) { m.id }\n         }\n     }\n \n     fn accept<E>(e: E, v: visit::vt<E>) {\n         alt self {\n           ii_item(i) { v.visit_item(i, e, v) }\n+          ii_native(i) { v.visit_native_item(i, e, v) }\n           ii_method(_, m) { visit::visit_method_helper(m, e, v) }\n         }\n     }"}]}