{"sha": "9a60099cc43c8a07abb280be323d1ed9afc27f2c", "node_id": "C_kwDOAAsO6NoAKDlhNjAwOTljYzQzYzhhMDdhYmIyODBiZTMyM2QxZWQ5YWZjMjdmMmM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-13T07:04:56Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-02-13T07:04:56Z"}, "message": "Auto merge of #93956 - matthiaskrgr:rollup-zfk35hb, r=matthiaskrgr\n\nRollup of 9 pull requests\n\nSuccessful merges:\n\n - #89926 (make `Instant::{duration_since, elapsed, sub}` saturating and remove workarounds)\n - #90532 (More informative error message for E0015)\n - #93810 (Improve chalk integration)\n - #93851 (More practical examples for `Option::and_then` & `Result::and_then`)\n - #93885 (bootstrap.py: Suggest disabling download-ci-llvm option if url fails to download)\n - #93886 (Stabilise inherent_ascii_escape (FCP in #77174))\n - #93930 (add link to format_args! when mention it in docs)\n - #93936 (Couple of driver cleanups)\n - #93944 (Don't relabel to a team if there is already a team label)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "443e36bb4c65e2899f2cbb0e6639a152e826b5d8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/443e36bb4c65e2899f2cbb0e6639a152e826b5d8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9a60099cc43c8a07abb280be323d1ed9afc27f2c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9a60099cc43c8a07abb280be323d1ed9afc27f2c", "html_url": "https://github.com/rust-lang/rust/commit/9a60099cc43c8a07abb280be323d1ed9afc27f2c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9a60099cc43c8a07abb280be323d1ed9afc27f2c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3fe229902ecaf1017c931df6ad24cc9d968d8f03", "url": "https://api.github.com/repos/rust-lang/rust/commits/3fe229902ecaf1017c931df6ad24cc9d968d8f03", "html_url": "https://github.com/rust-lang/rust/commit/3fe229902ecaf1017c931df6ad24cc9d968d8f03"}, {"sha": "20ea5c50135fd905ad70c38abaa2a3362cf5561a", "url": "https://api.github.com/repos/rust-lang/rust/commits/20ea5c50135fd905ad70c38abaa2a3362cf5561a", "html_url": "https://github.com/rust-lang/rust/commit/20ea5c50135fd905ad70c38abaa2a3362cf5561a"}], "stats": {"total": 2682, "additions": 1551, "deletions": 1131}, "files": [{"sha": "f6d21f879ff5868e75e09ddd00c9ba47bb9b7cf2", "filename": "compiler/rustc_borrowck/src/diagnostics/conflict_errors.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fconflict_errors.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -1,4 +1,5 @@\n use either::Either;\n+use rustc_const_eval::util::{CallDesugaringKind, CallKind};\n use rustc_data_structures::fx::FxHashSet;\n use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n@@ -26,7 +27,7 @@ use crate::{\n \n use super::{\n     explain_borrow::{BorrowExplanation, LaterUseKind},\n-    FnSelfUseKind, IncludingDowncast, RegionName, RegionNameSource, UseSpans,\n+    IncludingDowncast, RegionName, RegionNameSource, UseSpans,\n };\n \n #[derive(Debug)]\n@@ -195,7 +196,9 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         .map(|n| format!(\"`{}`\", n))\n                         .unwrap_or_else(|| \"value\".to_owned());\n                     match kind {\n-                        FnSelfUseKind::FnOnceCall => {\n+                        CallKind::FnCall { fn_trait_id, .. }\n+                            if Some(fn_trait_id) == self.infcx.tcx.lang_items().fn_once_trait() =>\n+                        {\n                             err.span_label(\n                                 fn_call_span,\n                                 &format!(\n@@ -208,7 +211,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                                 \"this value implements `FnOnce`, which causes it to be moved when called\",\n                             );\n                         }\n-                        FnSelfUseKind::Operator { self_arg } => {\n+                        CallKind::Operator { self_arg, .. } => {\n+                            let self_arg = self_arg.unwrap();\n                             err.span_label(\n                                 fn_call_span,\n                                 &format!(\n@@ -235,12 +239,9 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                                 );\n                             }\n                         }\n-                        FnSelfUseKind::Normal {\n-                            self_arg,\n-                            implicit_into_iter,\n-                            is_option_or_result,\n-                        } => {\n-                            if implicit_into_iter {\n+                        CallKind::Normal { self_arg, desugaring, is_option_or_result } => {\n+                            let self_arg = self_arg.unwrap();\n+                            if let Some((CallDesugaringKind::ForLoopIntoIter, _)) = desugaring {\n                                 err.span_label(\n                                     fn_call_span,\n                                     &format!(\n@@ -305,8 +306,8 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                                     );\n                             }\n                         }\n-                        // Deref::deref takes &self, which cannot cause a move\n-                        FnSelfUseKind::DerefCoercion { .. } => unreachable!(),\n+                        // Other desugarings takes &self, which cannot cause a move\n+                        _ => unreachable!(),\n                     }\n                 } else {\n                     err.span_label(\n@@ -433,7 +434,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n             }\n \n             if let UseSpans::FnSelfUse {\n-                kind: FnSelfUseKind::DerefCoercion { deref_target, deref_target_ty },\n+                kind: CallKind::DerefCoercion { deref_target, deref_target_ty, .. },\n                 ..\n             } = use_spans\n             {"}, {"sha": "4400fed13b741ef8abe5339941f2183f44083747", "filename": "compiler/rustc_borrowck/src/diagnostics/mod.rs", "status": "modified", "additions": 22, "deletions": 93, "changes": 115, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -1,10 +1,10 @@\n //! Borrow checker diagnostics.\n \n+use rustc_const_eval::util::call_kind;\n use rustc_errors::DiagnosticBuilder;\n use rustc_hir as hir;\n use rustc_hir::def::Namespace;\n use rustc_hir::def_id::DefId;\n-use rustc_hir::lang_items::LangItemGroup;\n use rustc_hir::GeneratorKind;\n use rustc_middle::mir::{\n     AggregateKind, Constant, FakeReadCause, Field, Local, LocalInfo, LocalKind, Location, Operand,\n@@ -13,7 +13,7 @@ use rustc_middle::mir::{\n use rustc_middle::ty::print::Print;\n use rustc_middle::ty::{self, DefIdTree, Instance, Ty, TyCtxt};\n use rustc_mir_dataflow::move_paths::{InitLocation, LookupResult};\n-use rustc_span::{hygiene::DesugaringKind, symbol::sym, Span};\n+use rustc_span::{symbol::sym, Span};\n use rustc_target::abi::VariantIdx;\n \n use super::borrow_set::BorrowData;\n@@ -37,7 +37,7 @@ crate use mutability_errors::AccessKind;\n crate use outlives_suggestion::OutlivesSuggestionBuilder;\n crate use region_errors::{ErrorConstraintInfo, RegionErrorKind, RegionErrors};\n crate use region_name::{RegionName, RegionNameSource};\n-use rustc_span::symbol::Ident;\n+crate use rustc_const_eval::util::CallKind;\n \n pub(super) struct IncludingDowncast(pub(super) bool);\n \n@@ -563,46 +563,23 @@ pub(super) enum UseSpans<'tcx> {\n         fn_call_span: Span,\n         /// The definition span of the method being called\n         fn_span: Span,\n-        kind: FnSelfUseKind<'tcx>,\n+        kind: CallKind<'tcx>,\n     },\n     /// This access is caused by a `match` or `if let` pattern.\n     PatUse(Span),\n     /// This access has a single span associated to it: common case.\n     OtherUse(Span),\n }\n \n-#[derive(Copy, Clone, PartialEq, Eq, Debug)]\n-pub(super) enum FnSelfUseKind<'tcx> {\n-    /// A normal method call of the form `receiver.foo(a, b, c)`\n-    Normal {\n-        self_arg: Ident,\n-        implicit_into_iter: bool,\n-        /// Whether the self type of the method call has an `.as_ref()` method.\n-        /// Used for better diagnostics.\n-        is_option_or_result: bool,\n-    },\n-    /// A call to `FnOnce::call_once`, desugared from `my_closure(a, b, c)`\n-    FnOnceCall,\n-    /// A call to an operator trait, desuraged from operator syntax (e.g. `a << b`)\n-    Operator { self_arg: Ident },\n-    DerefCoercion {\n-        /// The `Span` of the `Target` associated type\n-        /// in the `Deref` impl we are using.\n-        deref_target: Span,\n-        /// The type `T::Deref` we are dereferencing to\n-        deref_target_ty: Ty<'tcx>,\n-    },\n-}\n-\n impl UseSpans<'_> {\n     pub(super) fn args_or_use(self) -> Span {\n         match self {\n             UseSpans::ClosureUse { args_span: span, .. }\n             | UseSpans::PatUse(span)\n             | UseSpans::OtherUse(span) => span,\n-            UseSpans::FnSelfUse {\n-                fn_call_span, kind: FnSelfUseKind::DerefCoercion { .. }, ..\n-            } => fn_call_span,\n+            UseSpans::FnSelfUse { fn_call_span, kind: CallKind::DerefCoercion { .. }, .. } => {\n+                fn_call_span\n+            }\n             UseSpans::FnSelfUse { var_span, .. } => var_span,\n         }\n     }\n@@ -613,9 +590,9 @@ impl UseSpans<'_> {\n             UseSpans::ClosureUse { path_span: span, .. }\n             | UseSpans::PatUse(span)\n             | UseSpans::OtherUse(span) => span,\n-            UseSpans::FnSelfUse {\n-                fn_call_span, kind: FnSelfUseKind::DerefCoercion { .. }, ..\n-            } => fn_call_span,\n+            UseSpans::FnSelfUse { fn_call_span, kind: CallKind::DerefCoercion { .. }, .. } => {\n+                fn_call_span\n+            }\n             UseSpans::FnSelfUse { var_span, .. } => var_span,\n         }\n     }\n@@ -626,9 +603,9 @@ impl UseSpans<'_> {\n             UseSpans::ClosureUse { capture_kind_span: span, .. }\n             | UseSpans::PatUse(span)\n             | UseSpans::OtherUse(span) => span,\n-            UseSpans::FnSelfUse {\n-                fn_call_span, kind: FnSelfUseKind::DerefCoercion { .. }, ..\n-            } => fn_call_span,\n+            UseSpans::FnSelfUse { fn_call_span, kind: CallKind::DerefCoercion { .. }, .. } => {\n+                fn_call_span\n+            }\n             UseSpans::FnSelfUse { var_span, .. } => var_span,\n         }\n     }\n@@ -904,67 +881,19 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                 return normal_ret;\n             };\n \n-            let tcx = self.infcx.tcx;\n-            let parent = tcx.parent(method_did);\n-            let is_fn_once = parent == tcx.lang_items().fn_once_trait();\n-            let is_operator = !from_hir_call\n-                && parent.map_or(false, |p| tcx.lang_items().group(LangItemGroup::Op).contains(&p));\n-            let is_deref = !from_hir_call && tcx.is_diagnostic_item(sym::deref_method, method_did);\n-            let fn_call_span = *fn_span;\n-\n-            let self_arg = tcx.fn_arg_names(method_did)[0];\n-\n-            debug!(\n-                \"terminator = {:?} from_hir_call={:?}\",\n-                self.body[location.block].terminator, from_hir_call\n+            let kind = call_kind(\n+                self.infcx.tcx,\n+                self.param_env,\n+                method_did,\n+                method_substs,\n+                *fn_span,\n+                *from_hir_call,\n+                Some(self.infcx.tcx.fn_arg_names(method_did)[0]),\n             );\n \n-            // Check for a 'special' use of 'self' -\n-            // an FnOnce call, an operator (e.g. `<<`), or a\n-            // deref coercion.\n-            let kind = if is_fn_once {\n-                Some(FnSelfUseKind::FnOnceCall)\n-            } else if is_operator {\n-                Some(FnSelfUseKind::Operator { self_arg })\n-            } else if is_deref {\n-                let deref_target =\n-                    tcx.get_diagnostic_item(sym::deref_target).and_then(|deref_target| {\n-                        Instance::resolve(tcx, self.param_env, deref_target, method_substs)\n-                            .transpose()\n-                    });\n-                if let Some(Ok(instance)) = deref_target {\n-                    let deref_target_ty = instance.ty(tcx, self.param_env);\n-                    Some(FnSelfUseKind::DerefCoercion {\n-                        deref_target: tcx.def_span(instance.def_id()),\n-                        deref_target_ty,\n-                    })\n-                } else {\n-                    None\n-                }\n-            } else {\n-                None\n-            };\n-\n-            let kind = kind.unwrap_or_else(|| {\n-                // This isn't a 'special' use of `self`\n-                debug!(\"move_spans: method_did={:?}, fn_call_span={:?}\", method_did, fn_call_span);\n-                let implicit_into_iter = Some(method_did) == tcx.lang_items().into_iter_fn()\n-                    && fn_call_span.desugaring_kind() == Some(DesugaringKind::ForLoop);\n-                let parent_self_ty = parent\n-                    .filter(|did| tcx.def_kind(*did) == rustc_hir::def::DefKind::Impl)\n-                    .and_then(|did| match tcx.type_of(did).kind() {\n-                        ty::Adt(def, ..) => Some(def.did),\n-                        _ => None,\n-                    });\n-                let is_option_or_result = parent_self_ty.map_or(false, |def_id| {\n-                    matches!(tcx.get_diagnostic_name(def_id), Some(sym::Option | sym::Result))\n-                });\n-                FnSelfUseKind::Normal { self_arg, implicit_into_iter, is_option_or_result }\n-            });\n-\n             return FnSelfUse {\n                 var_span: stmt.source_info.span,\n-                fn_call_span,\n+                fn_call_span: *fn_span,\n                 fn_span: self\n                     .infcx\n                     .tcx"}, {"sha": "b33b779eddaddb30f49f6b4fda8d0d112d45595a", "filename": "compiler/rustc_borrowck/src/diagnostics/move_errors.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmove_errors.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -1,3 +1,4 @@\n+use rustc_const_eval::util::CallDesugaringKind;\n use rustc_errors::{Applicability, DiagnosticBuilder};\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_middle::mir::*;\n@@ -8,7 +9,7 @@ use rustc_mir_dataflow::move_paths::{\n use rustc_span::{sym, Span, DUMMY_SP};\n use rustc_trait_selection::traits::type_known_to_meet_bound_modulo_regions;\n \n-use crate::diagnostics::{FnSelfUseKind, UseSpans};\n+use crate::diagnostics::{CallKind, UseSpans};\n use crate::prefixes::PrefixSet;\n use crate::MirBorrowckCtxt;\n \n@@ -410,7 +411,8 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n                 Applicability::MaybeIncorrect,\n             );\n         } else if let Some(UseSpans::FnSelfUse {\n-            kind: FnSelfUseKind::Normal { implicit_into_iter: true, .. },\n+            kind:\n+                CallKind::Normal { desugaring: Some((CallDesugaringKind::ForLoopIntoIter, _)), .. },\n             ..\n         }) = use_spans\n         {"}, {"sha": "095c8f84f41adb28eb8e1c3e97f7651fb1d19f1f", "filename": "compiler/rustc_const_eval/src/transform/check_consts/check.rs", "status": "modified", "additions": 71, "deletions": 25, "changes": 96, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -14,6 +14,7 @@ use rustc_middle::ty::{self, adjustment::PointerCast, Instance, InstanceDef, Ty,\n use rustc_middle::ty::{Binder, TraitPredicate, TraitRef};\n use rustc_mir_dataflow::{self, Analysis};\n use rustc_span::{sym, Span, Symbol};\n+use rustc_trait_selection::traits::error_reporting::InferCtxtExt;\n use rustc_trait_selection::traits::SelectionContext;\n \n use std::mem;\n@@ -293,13 +294,13 @@ impl<'mir, 'tcx> Checker<'mir, 'tcx> {\n     }\n \n     /// Emits an error if an expression cannot be evaluated in the current context.\n-    pub fn check_op(&mut self, op: impl NonConstOp) {\n+    pub fn check_op(&mut self, op: impl NonConstOp<'tcx>) {\n         self.check_op_spanned(op, self.span);\n     }\n \n     /// Emits an error at the given `span` if an expression cannot be evaluated in the current\n     /// context.\n-    pub fn check_op_spanned<O: NonConstOp>(&mut self, op: O, span: Span) {\n+    pub fn check_op_spanned<O: NonConstOp<'tcx>>(&mut self, op: O, span: Span) {\n         let gate = match op.status_in_item(self.ccx) {\n             Status::Allowed => return,\n \n@@ -773,7 +774,7 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n         self.super_terminator(terminator, location);\n \n         match &terminator.kind {\n-            TerminatorKind::Call { func, args, .. } => {\n+            TerminatorKind::Call { func, args, fn_span, from_hir_call, .. } => {\n                 let ConstCx { tcx, body, param_env, .. } = *self.ccx;\n                 let caller = self.def_id().to_def_id();\n \n@@ -797,20 +798,24 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n                 if let Some(trait_id) = tcx.trait_of_item(callee) {\n                     trace!(\"attempting to call a trait method\");\n                     if !self.tcx.features().const_trait_impl {\n-                        self.check_op(ops::FnCallNonConst(Some((callee, substs))));\n+                        self.check_op(ops::FnCallNonConst {\n+                            caller,\n+                            callee,\n+                            substs,\n+                            span: *fn_span,\n+                            from_hir_call: *from_hir_call,\n+                        });\n                         return;\n                     }\n \n                     let trait_ref = TraitRef::from_method(tcx, trait_id, substs);\n-                    let obligation = Obligation::new(\n-                        ObligationCause::dummy(),\n-                        param_env,\n-                        Binder::dummy(TraitPredicate {\n-                            trait_ref,\n-                            constness: ty::BoundConstness::NotConst,\n-                            polarity: ty::ImplPolarity::Positive,\n-                        }),\n-                    );\n+                    let poly_trait_pred = Binder::dummy(TraitPredicate {\n+                        trait_ref,\n+                        constness: ty::BoundConstness::ConstIfConst,\n+                        polarity: ty::ImplPolarity::Positive,\n+                    });\n+                    let obligation =\n+                        Obligation::new(ObligationCause::dummy(), param_env, poly_trait_pred);\n \n                     let implsrc = tcx.infer_ctxt().enter(|infcx| {\n                         let mut selcx = SelectionContext::new(&infcx);\n@@ -826,10 +831,6 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n                             return;\n                         }\n                         Ok(Some(ImplSource::UserDefined(data))) => {\n-                            if let hir::Constness::NotConst = tcx.impl_constness(data.impl_def_id) {\n-                                self.check_op(ops::FnCallNonConst(None));\n-                                return;\n-                            }\n                             let callee_name = tcx.item_name(callee);\n                             if let Some(&did) = tcx\n                                 .associated_item_def_ids(data.impl_def_id)\n@@ -841,22 +842,61 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n                                 substs = InternalSubsts::identity_for_item(tcx, did);\n                                 callee = did;\n                             }\n+\n+                            if let hir::Constness::NotConst = tcx.impl_constness(data.impl_def_id) {\n+                                self.check_op(ops::FnCallNonConst {\n+                                    caller,\n+                                    callee,\n+                                    substs,\n+                                    span: *fn_span,\n+                                    from_hir_call: *from_hir_call,\n+                                });\n+                                return;\n+                            }\n                         }\n                         _ if !tcx.is_const_fn_raw(callee) => {\n                             // At this point, it is only legal when the caller is marked with\n                             // #[default_method_body_is_const], and the callee is in the same\n                             // trait.\n                             let callee_trait = tcx.trait_of_item(callee);\n-                            if callee_trait.is_some() {\n-                                if tcx.has_attr(caller, sym::default_method_body_is_const) {\n-                                    if tcx.trait_of_item(caller) == callee_trait {\n-                                        nonconst_call_permission = true;\n-                                    }\n-                                }\n+                            if callee_trait.is_some()\n+                                && tcx.has_attr(caller, sym::default_method_body_is_const)\n+                                && callee_trait == tcx.trait_of_item(caller)\n+                                // Can only call methods when it's `<Self as TheTrait>::f`.\n+                                && tcx.types.self_param == substs.type_at(0)\n+                            {\n+                                nonconst_call_permission = true;\n                             }\n \n                             if !nonconst_call_permission {\n-                                self.check_op(ops::FnCallNonConst(None));\n+                                let obligation = Obligation::new(\n+                                    ObligationCause::dummy_with_span(*fn_span),\n+                                    param_env,\n+                                    tcx.mk_predicate(\n+                                        poly_trait_pred.map_bound(ty::PredicateKind::Trait),\n+                                    ),\n+                                );\n+\n+                                // improve diagnostics by showing what failed. Our requirements are stricter this time\n+                                // as we are going to error again anyways.\n+                                tcx.infer_ctxt().enter(|infcx| {\n+                                    if let Err(e) = implsrc {\n+                                        infcx.report_selection_error(\n+                                            obligation.clone(),\n+                                            &obligation,\n+                                            &e,\n+                                            false,\n+                                        );\n+                                    }\n+                                });\n+\n+                                self.check_op(ops::FnCallNonConst {\n+                                    caller,\n+                                    callee,\n+                                    substs,\n+                                    span: *fn_span,\n+                                    from_hir_call: *from_hir_call,\n+                                });\n                                 return;\n                             }\n                         }\n@@ -925,7 +965,13 @@ impl<'tcx> Visitor<'tcx> for Checker<'_, 'tcx> {\n                     }\n \n                     if !nonconst_call_permission {\n-                        self.check_op(ops::FnCallNonConst(None));\n+                        self.check_op(ops::FnCallNonConst {\n+                            caller,\n+                            callee,\n+                            substs,\n+                            span: *fn_span,\n+                            from_hir_call: *from_hir_call,\n+                        });\n                         return;\n                     }\n                 }"}, {"sha": "519b4c02b61e6bd75f17241eda852620430526d4", "filename": "compiler/rustc_const_eval/src/transform/check_consts/ops.rs", "status": "modified", "additions": 285, "deletions": 149, "changes": 434, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -3,14 +3,22 @@\n use rustc_errors::{struct_span_err, Applicability, DiagnosticBuilder};\n use rustc_hir as hir;\n use rustc_hir::def_id::DefId;\n+use rustc_infer::infer::TyCtxtInferExt;\n+use rustc_infer::traits::{ImplSource, Obligation, ObligationCause};\n+use rustc_middle::mir;\n+use rustc_middle::ty::print::with_no_trimmed_paths;\n use rustc_middle::ty::subst::{GenericArgKind, SubstsRef};\n-use rustc_middle::{mir, ty::AssocKind};\n+use rustc_middle::ty::{\n+    suggest_constraining_type_param, Adt, Closure, FnDef, FnPtr, Param, TraitPredicate, Ty,\n+};\n+use rustc_middle::ty::{Binder, BoundConstness, ImplPolarity, TraitRef};\n use rustc_session::parse::feature_err;\n use rustc_span::symbol::sym;\n-use rustc_span::{symbol::Ident, Span, Symbol};\n-use rustc_span::{BytePos, Pos};\n+use rustc_span::{BytePos, Pos, Span, Symbol};\n+use rustc_trait_selection::traits::SelectionContext;\n \n use super::ConstCx;\n+use crate::util::{call_kind, CallDesugaringKind, CallKind};\n \n #[derive(Clone, Copy, Debug, PartialEq, Eq)]\n pub enum Status {\n@@ -29,31 +37,31 @@ pub enum DiagnosticImportance {\n }\n \n /// An operation that is not *always* allowed in a const context.\n-pub trait NonConstOp: std::fmt::Debug {\n+pub trait NonConstOp<'tcx>: std::fmt::Debug {\n     /// Returns an enum indicating whether this operation is allowed within the given item.\n-    fn status_in_item(&self, _ccx: &ConstCx<'_, '_>) -> Status {\n+    fn status_in_item(&self, _ccx: &ConstCx<'_, 'tcx>) -> Status {\n         Status::Forbidden\n     }\n \n     fn importance(&self) -> DiagnosticImportance {\n         DiagnosticImportance::Primary\n     }\n \n-    fn build_error<'tcx>(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx>;\n+    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx>;\n }\n \n #[derive(Debug)]\n pub struct FloatingPointOp;\n-impl NonConstOp for FloatingPointOp {\n-    fn status_in_item(&self, ccx: &ConstCx<'_, '_>) -> Status {\n+impl<'tcx> NonConstOp<'tcx> for FloatingPointOp {\n+    fn status_in_item(&self, ccx: &ConstCx<'_, 'tcx>) -> Status {\n         if ccx.const_kind() == hir::ConstContext::ConstFn {\n             Status::Unstable(sym::const_fn_floating_point_arithmetic)\n         } else {\n             Status::Allowed\n         }\n     }\n \n-    fn build_error<'tcx>(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n         feature_err(\n             &ccx.tcx.sess.parse_sess,\n             sym::const_fn_floating_point_arithmetic,\n@@ -66,77 +74,229 @@ impl NonConstOp for FloatingPointOp {\n /// A function call where the callee is a pointer.\n #[derive(Debug)]\n pub struct FnCallIndirect;\n-impl NonConstOp for FnCallIndirect {\n-    fn build_error<'tcx>(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+impl<'tcx> NonConstOp<'tcx> for FnCallIndirect {\n+    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n         ccx.tcx.sess.struct_span_err(span, \"function pointers are not allowed in const fn\")\n     }\n }\n \n /// A function call where the callee is not marked as `const`.\n-#[derive(Debug)]\n-pub struct FnCallNonConst<'tcx>(pub Option<(DefId, SubstsRef<'tcx>)>);\n-impl<'a> NonConstOp for FnCallNonConst<'a> {\n-    fn build_error<'tcx>(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n-        let mut err = struct_span_err!(\n-            ccx.tcx.sess,\n-            span,\n-            E0015,\n-            \"calls in {}s are limited to constant functions, \\\n-             tuple structs and tuple variants\",\n-            ccx.const_kind(),\n-        );\n+#[derive(Debug, Clone, Copy)]\n+pub struct FnCallNonConst<'tcx> {\n+    pub caller: DefId,\n+    pub callee: DefId,\n+    pub substs: SubstsRef<'tcx>,\n+    pub span: Span,\n+    pub from_hir_call: bool,\n+}\n \n-        if let FnCallNonConst(Some((callee, substs))) = *self {\n-            if let Some(trait_def_id) = ccx.tcx.lang_items().eq_trait() {\n-                if let Some(eq_item) = ccx.tcx.associated_items(trait_def_id).find_by_name_and_kind(\n-                    ccx.tcx,\n-                    Ident::with_dummy_span(sym::eq),\n-                    AssocKind::Fn,\n-                    trait_def_id,\n-                ) {\n-                    if callee == eq_item.def_id && substs.len() == 2 {\n-                        match (substs[0].unpack(), substs[1].unpack()) {\n-                            (GenericArgKind::Type(self_ty), GenericArgKind::Type(rhs_ty))\n-                                if self_ty == rhs_ty\n-                                    && self_ty.is_ref()\n-                                    && self_ty.peel_refs().is_primitive() =>\n-                            {\n-                                let mut num_refs = 0;\n-                                let mut tmp_ty = self_ty;\n-                                while let rustc_middle::ty::Ref(_, inner_ty, _) = tmp_ty.kind() {\n-                                    num_refs += 1;\n-                                    tmp_ty = inner_ty;\n-                                }\n-                                let deref = \"*\".repeat(num_refs);\n-\n-                                if let Ok(call_str) =\n-                                    ccx.tcx.sess.source_map().span_to_snippet(span)\n-                                {\n-                                    if let Some(eq_idx) = call_str.find(\"==\") {\n-                                        if let Some(rhs_idx) = call_str[(eq_idx + 2)..]\n-                                            .find(|c: char| !c.is_whitespace())\n-                                        {\n-                                            let rhs_pos = span.lo()\n-                                                + BytePos::from_usize(eq_idx + 2 + rhs_idx);\n-                                            let rhs_span = span.with_lo(rhs_pos).with_hi(rhs_pos);\n-                                            err.multipart_suggestion(\n-                                                \"consider dereferencing here\",\n-                                                vec![\n-                                                    (span.shrink_to_lo(), deref.clone()),\n-                                                    (rhs_span, deref),\n-                                                ],\n-                                                Applicability::MachineApplicable,\n-                                            );\n-                                        }\n+impl<'tcx> NonConstOp<'tcx> for FnCallNonConst<'tcx> {\n+    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, _: Span) -> DiagnosticBuilder<'tcx> {\n+        let FnCallNonConst { caller, callee, substs, span, from_hir_call } = *self;\n+        let ConstCx { tcx, param_env, .. } = *ccx;\n+\n+        let diag_trait = |mut err, self_ty: Ty<'_>, trait_id| {\n+            let trait_ref = TraitRef::from_method(tcx, trait_id, substs);\n+\n+            match self_ty.kind() {\n+                Param(param_ty) => {\n+                    debug!(?param_ty);\n+                    if let Some(generics) = caller\n+                        .as_local()\n+                        .map(|id| tcx.hir().local_def_id_to_hir_id(id))\n+                        .map(|id| tcx.hir().get(id))\n+                        .as_ref()\n+                        .and_then(|node| node.generics())\n+                    {\n+                        let constraint = with_no_trimmed_paths(|| {\n+                            format!(\"~const {}\", trait_ref.print_only_trait_path())\n+                        });\n+                        suggest_constraining_type_param(\n+                            tcx,\n+                            generics,\n+                            &mut err,\n+                            &param_ty.name.as_str(),\n+                            &constraint,\n+                            None,\n+                        );\n+                    }\n+                }\n+                Adt(..) => {\n+                    let obligation = Obligation::new(\n+                        ObligationCause::dummy(),\n+                        param_env,\n+                        Binder::dummy(TraitPredicate {\n+                            trait_ref,\n+                            constness: BoundConstness::NotConst,\n+                            polarity: ImplPolarity::Positive,\n+                        }),\n+                    );\n+\n+                    let implsrc = tcx.infer_ctxt().enter(|infcx| {\n+                        let mut selcx = SelectionContext::new(&infcx);\n+                        selcx.select(&obligation)\n+                    });\n+\n+                    if let Ok(Some(ImplSource::UserDefined(data))) = implsrc {\n+                        let span =\n+                            tcx.sess.source_map().guess_head_span(tcx.def_span(data.impl_def_id));\n+                        err.span_note(span, \"impl defined here, but it is not `const`\");\n+                    }\n+                }\n+                _ => {}\n+            }\n+\n+            err\n+        };\n+\n+        let call_kind = call_kind(tcx, ccx.param_env, callee, substs, span, from_hir_call, None);\n+\n+        debug!(?call_kind);\n+\n+        let mut err = match call_kind {\n+            CallKind::Normal { desugaring: Some((kind, self_ty)), .. } => {\n+                macro_rules! error {\n+                    ($fmt:literal) => {\n+                        struct_span_err!(tcx.sess, span, E0015, $fmt, self_ty, ccx.const_kind())\n+                    };\n+                }\n+\n+                let err = match kind {\n+                    CallDesugaringKind::ForLoopIntoIter => {\n+                        error!(\"cannot convert `{}` into an iterator in {}s\")\n+                    }\n+                    CallDesugaringKind::QuestionBranch => {\n+                        error!(\"`?` cannot determine the branch of `{}` in {}s\")\n+                    }\n+                    CallDesugaringKind::QuestionFromResidual => {\n+                        error!(\"`?` cannot convert from residual of `{}` in {}s\")\n+                    }\n+                    CallDesugaringKind::TryBlockFromOutput => {\n+                        error!(\"`try` block cannot convert `{}` to the result in {}s\")\n+                    }\n+                };\n+\n+                diag_trait(err, self_ty, kind.trait_def_id(tcx))\n+            }\n+            CallKind::FnCall { fn_trait_id, self_ty } => {\n+                let mut err = struct_span_err!(\n+                    tcx.sess,\n+                    span,\n+                    E0015,\n+                    \"cannot call non-const closure in {}s\",\n+                    ccx.const_kind(),\n+                );\n+\n+                match self_ty.kind() {\n+                    FnDef(def_id, ..) => {\n+                        let span = tcx.sess.source_map().guess_head_span(tcx.def_span(*def_id));\n+                        if ccx.tcx.is_const_fn_raw(*def_id) {\n+                            span_bug!(span, \"calling const FnDef errored when it shouldn't\");\n+                        }\n+\n+                        err.span_note(span, \"function defined here, but it is not `const`\");\n+                    }\n+                    FnPtr(..) => {\n+                        err.note(&format!(\n+                            \"function pointers need an RFC before allowed to be called in {}s\",\n+                            ccx.const_kind()\n+                        ));\n+                    }\n+                    Closure(..) => {\n+                        err.note(&format!(\n+                            \"closures need an RFC before allowed to be called in {}s\",\n+                            ccx.const_kind()\n+                        ));\n+                    }\n+                    _ => {}\n+                }\n+\n+                diag_trait(err, self_ty, fn_trait_id)\n+            }\n+            CallKind::Operator { trait_id, self_ty, .. } => {\n+                let mut err = struct_span_err!(\n+                    tcx.sess,\n+                    span,\n+                    E0015,\n+                    \"cannot call non-const operator in {}s\",\n+                    ccx.const_kind()\n+                );\n+\n+                if Some(trait_id) == ccx.tcx.lang_items().eq_trait() {\n+                    match (substs[0].unpack(), substs[1].unpack()) {\n+                        (GenericArgKind::Type(self_ty), GenericArgKind::Type(rhs_ty))\n+                            if self_ty == rhs_ty\n+                                && self_ty.is_ref()\n+                                && self_ty.peel_refs().is_primitive() =>\n+                        {\n+                            let mut num_refs = 0;\n+                            let mut tmp_ty = self_ty;\n+                            while let rustc_middle::ty::Ref(_, inner_ty, _) = tmp_ty.kind() {\n+                                num_refs += 1;\n+                                tmp_ty = inner_ty;\n+                            }\n+                            let deref = \"*\".repeat(num_refs);\n+\n+                            if let Ok(call_str) = ccx.tcx.sess.source_map().span_to_snippet(span) {\n+                                if let Some(eq_idx) = call_str.find(\"==\") {\n+                                    if let Some(rhs_idx) =\n+                                        call_str[(eq_idx + 2)..].find(|c: char| !c.is_whitespace())\n+                                    {\n+                                        let rhs_pos =\n+                                            span.lo() + BytePos::from_usize(eq_idx + 2 + rhs_idx);\n+                                        let rhs_span = span.with_lo(rhs_pos).with_hi(rhs_pos);\n+                                        err.multipart_suggestion(\n+                                            \"consider dereferencing here\",\n+                                            vec![\n+                                                (span.shrink_to_lo(), deref.clone()),\n+                                                (rhs_span, deref),\n+                                            ],\n+                                            Applicability::MachineApplicable,\n+                                        );\n                                     }\n                                 }\n                             }\n-                            _ => {}\n                         }\n+                        _ => {}\n                     }\n                 }\n+\n+                diag_trait(err, self_ty, trait_id)\n             }\n-        }\n+            CallKind::DerefCoercion { deref_target, deref_target_ty, self_ty } => {\n+                let mut err = struct_span_err!(\n+                    tcx.sess,\n+                    span,\n+                    E0015,\n+                    \"cannot perform deref coercion on `{}` in {}s\",\n+                    self_ty,\n+                    ccx.const_kind()\n+                );\n+\n+                err.note(&format!(\"attempting to deref into `{}`\", deref_target_ty));\n+\n+                // Check first whether the source is accessible (issue #87060)\n+                if tcx.sess.source_map().span_to_snippet(deref_target).is_ok() {\n+                    err.span_note(deref_target, \"deref defined here\");\n+                }\n+\n+                diag_trait(err, self_ty, tcx.lang_items().deref_trait().unwrap())\n+            }\n+            _ => struct_span_err!(\n+                ccx.tcx.sess,\n+                span,\n+                E0015,\n+                \"cannot call non-const fn `{}` in {}s\",\n+                ccx.tcx.def_path_str_with_substs(callee, substs),\n+                ccx.const_kind(),\n+            ),\n+        };\n+\n+        err.note(&format!(\n+            \"calls in {}s are limited to constant functions, \\\n+             tuple structs and tuple variants\",\n+            ccx.const_kind(),\n+        ));\n \n         err\n     }\n@@ -148,8 +308,8 @@ impl<'a> NonConstOp for FnCallNonConst<'a> {\n #[derive(Debug)]\n pub struct FnCallUnstable(pub DefId, pub Option<Symbol>);\n \n-impl NonConstOp for FnCallUnstable {\n-    fn build_error<'tcx>(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+impl<'tcx> NonConstOp<'tcx> for FnCallUnstable {\n+    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n         let FnCallUnstable(def_id, feature) = *self;\n \n         let mut err = ccx.tcx.sess.struct_span_err(\n@@ -174,16 +334,16 @@ impl NonConstOp for FnCallUnstable {\n \n #[derive(Debug)]\n pub struct FnPtrCast;\n-impl NonConstOp for FnPtrCast {\n-    fn status_in_item(&self, ccx: &ConstCx<'_, '_>) -> Status {\n+impl<'tcx> NonConstOp<'tcx> for FnPtrCast {\n+    fn status_in_item(&self, ccx: &ConstCx<'_, 'tcx>) -> Status {\n         if ccx.const_kind() != hir::ConstContext::ConstFn {\n             Status::Allowed\n         } else {\n             Status::Unstable(sym::const_fn_fn_ptr_basics)\n         }\n     }\n \n-    fn build_error<'tcx>(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n         feature_err(\n             &ccx.tcx.sess.parse_sess,\n             sym::const_fn_fn_ptr_basics,\n@@ -195,16 +355,16 @@ impl NonConstOp for FnPtrCast {\n \n #[derive(Debug)]\n pub struct Generator(pub hir::GeneratorKind);\n-impl NonConstOp for Generator {\n-    fn status_in_item(&self, _: &ConstCx<'_, '_>) -> Status {\n+impl<'tcx> NonConstOp<'tcx> for Generator {\n+    fn status_in_item(&self, _: &ConstCx<'_, 'tcx>) -> Status {\n         if let hir::GeneratorKind::Async(hir::AsyncGeneratorKind::Block) = self.0 {\n             Status::Unstable(sym::const_async_blocks)\n         } else {\n             Status::Forbidden\n         }\n     }\n \n-    fn build_error<'tcx>(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n         let msg = format!(\"{}s are not allowed in {}s\", self.0, ccx.const_kind());\n         if let hir::GeneratorKind::Async(hir::AsyncGeneratorKind::Block) = self.0 {\n             feature_err(&ccx.tcx.sess.parse_sess, sym::const_async_blocks, span, &msg)\n@@ -216,8 +376,8 @@ impl NonConstOp for Generator {\n \n #[derive(Debug)]\n pub struct HeapAllocation;\n-impl NonConstOp for HeapAllocation {\n-    fn build_error<'tcx>(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+impl<'tcx> NonConstOp<'tcx> for HeapAllocation {\n+    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n         let mut err = struct_span_err!(\n             ccx.tcx.sess,\n             span,\n@@ -240,8 +400,8 @@ impl NonConstOp for HeapAllocation {\n \n #[derive(Debug)]\n pub struct InlineAsm;\n-impl NonConstOp for InlineAsm {\n-    fn build_error<'tcx>(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+impl<'tcx> NonConstOp<'tcx> for InlineAsm {\n+    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n         struct_span_err!(\n             ccx.tcx.sess,\n             span,\n@@ -256,8 +416,8 @@ impl NonConstOp for InlineAsm {\n pub struct LiveDrop {\n     pub dropped_at: Option<Span>,\n }\n-impl NonConstOp for LiveDrop {\n-    fn build_error<'tcx>(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+impl<'tcx> NonConstOp<'tcx> for LiveDrop {\n+    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n         let mut err = struct_span_err!(\n             ccx.tcx.sess,\n             span,\n@@ -276,16 +436,16 @@ impl NonConstOp for LiveDrop {\n /// A borrow of a type that contains an `UnsafeCell` somewhere. The borrow never escapes to\n /// the final value of the constant.\n pub struct TransientCellBorrow;\n-impl NonConstOp for TransientCellBorrow {\n-    fn status_in_item(&self, _: &ConstCx<'_, '_>) -> Status {\n+impl<'tcx> NonConstOp<'tcx> for TransientCellBorrow {\n+    fn status_in_item(&self, _: &ConstCx<'_, 'tcx>) -> Status {\n         Status::Unstable(sym::const_refs_to_cell)\n     }\n     fn importance(&self) -> DiagnosticImportance {\n         // The cases that cannot possibly work will already emit a `CellBorrow`, so we should\n         // not additionally emit a feature gate error if activating the feature gate won't work.\n         DiagnosticImportance::Secondary\n     }\n-    fn build_error<'tcx>(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n         feature_err(\n             &ccx.tcx.sess.parse_sess,\n             sym::const_refs_to_cell,\n@@ -300,8 +460,8 @@ impl NonConstOp for TransientCellBorrow {\n /// the final value of the constant, and thus we cannot allow this (for now). We may allow\n /// it in the future for static items.\n pub struct CellBorrow;\n-impl NonConstOp for CellBorrow {\n-    fn build_error<'tcx>(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+impl<'tcx> NonConstOp<'tcx> for CellBorrow {\n+    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n         let mut err = struct_span_err!(\n             ccx.tcx.sess,\n             span,\n@@ -337,8 +497,8 @@ impl NonConstOp for CellBorrow {\n /// static or const items.\n pub struct MutBorrow(pub hir::BorrowKind);\n \n-impl NonConstOp for MutBorrow {\n-    fn status_in_item(&self, _ccx: &ConstCx<'_, '_>) -> Status {\n+impl<'tcx> NonConstOp<'tcx> for MutBorrow {\n+    fn status_in_item(&self, _ccx: &ConstCx<'_, 'tcx>) -> Status {\n         Status::Forbidden\n     }\n \n@@ -348,7 +508,7 @@ impl NonConstOp for MutBorrow {\n         DiagnosticImportance::Secondary\n     }\n \n-    fn build_error<'tcx>(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n         let raw = match self.0 {\n             hir::BorrowKind::Raw => \"raw \",\n             hir::BorrowKind::Ref => \"\",\n@@ -382,12 +542,12 @@ impl NonConstOp for MutBorrow {\n #[derive(Debug)]\n pub struct TransientMutBorrow(pub hir::BorrowKind);\n \n-impl NonConstOp for TransientMutBorrow {\n-    fn status_in_item(&self, _: &ConstCx<'_, '_>) -> Status {\n+impl<'tcx> NonConstOp<'tcx> for TransientMutBorrow {\n+    fn status_in_item(&self, _: &ConstCx<'_, 'tcx>) -> Status {\n         Status::Unstable(sym::const_mut_refs)\n     }\n \n-    fn build_error<'tcx>(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n         let raw = match self.0 {\n             hir::BorrowKind::Raw => \"raw \",\n             hir::BorrowKind::Ref => \"\",\n@@ -404,8 +564,8 @@ impl NonConstOp for TransientMutBorrow {\n \n #[derive(Debug)]\n pub struct MutDeref;\n-impl NonConstOp for MutDeref {\n-    fn status_in_item(&self, _: &ConstCx<'_, '_>) -> Status {\n+impl<'tcx> NonConstOp<'tcx> for MutDeref {\n+    fn status_in_item(&self, _: &ConstCx<'_, 'tcx>) -> Status {\n         Status::Unstable(sym::const_mut_refs)\n     }\n \n@@ -414,7 +574,7 @@ impl NonConstOp for MutDeref {\n         DiagnosticImportance::Secondary\n     }\n \n-    fn build_error<'tcx>(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n         feature_err(\n             &ccx.tcx.sess.parse_sess,\n             sym::const_mut_refs,\n@@ -427,8 +587,8 @@ impl NonConstOp for MutDeref {\n /// A call to a `panic()` lang item where the first argument is _not_ a `&str`.\n #[derive(Debug)]\n pub struct PanicNonStr;\n-impl NonConstOp for PanicNonStr {\n-    fn build_error<'tcx>(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+impl<'tcx> NonConstOp<'tcx> for PanicNonStr {\n+    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n         ccx.tcx.sess.struct_span_err(\n             span,\n             \"argument to `panic!()` in a const context must have type `&str`\",\n@@ -441,8 +601,8 @@ impl NonConstOp for PanicNonStr {\n /// allocation base addresses that are not known at compile-time.\n #[derive(Debug)]\n pub struct RawPtrComparison;\n-impl NonConstOp for RawPtrComparison {\n-    fn build_error<'tcx>(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+impl<'tcx> NonConstOp<'tcx> for RawPtrComparison {\n+    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n         let mut err = ccx\n             .tcx\n             .sess\n@@ -457,12 +617,12 @@ impl NonConstOp for RawPtrComparison {\n \n #[derive(Debug)]\n pub struct RawMutPtrDeref;\n-impl NonConstOp for RawMutPtrDeref {\n+impl<'tcx> NonConstOp<'tcx> for RawMutPtrDeref {\n     fn status_in_item(&self, _: &ConstCx<'_, '_>) -> Status {\n         Status::Unstable(sym::const_mut_refs)\n     }\n \n-    fn build_error<'tcx>(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n         feature_err(\n             &ccx.tcx.sess.parse_sess,\n             sym::const_mut_refs,\n@@ -477,8 +637,8 @@ impl NonConstOp for RawMutPtrDeref {\n /// allocation base addresses that are not known at compile-time.\n #[derive(Debug)]\n pub struct RawPtrToIntCast;\n-impl NonConstOp for RawPtrToIntCast {\n-    fn build_error<'tcx>(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+impl<'tcx> NonConstOp<'tcx> for RawPtrToIntCast {\n+    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n         let mut err = ccx\n             .tcx\n             .sess\n@@ -494,16 +654,16 @@ impl NonConstOp for RawPtrToIntCast {\n /// An access to a (non-thread-local) `static`.\n #[derive(Debug)]\n pub struct StaticAccess;\n-impl NonConstOp for StaticAccess {\n-    fn status_in_item(&self, ccx: &ConstCx<'_, '_>) -> Status {\n+impl<'tcx> NonConstOp<'tcx> for StaticAccess {\n+    fn status_in_item(&self, ccx: &ConstCx<'_, 'tcx>) -> Status {\n         if let hir::ConstContext::Static(_) = ccx.const_kind() {\n             Status::Allowed\n         } else {\n             Status::Forbidden\n         }\n     }\n \n-    fn build_error<'tcx>(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n         let mut err = struct_span_err!(\n             ccx.tcx.sess,\n             span,\n@@ -528,8 +688,8 @@ impl NonConstOp for StaticAccess {\n /// An access to a thread-local `static`.\n #[derive(Debug)]\n pub struct ThreadLocalAccess;\n-impl NonConstOp for ThreadLocalAccess {\n-    fn build_error<'tcx>(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+impl<'tcx> NonConstOp<'tcx> for ThreadLocalAccess {\n+    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n         struct_span_err!(\n             ccx.tcx.sess,\n             span,\n@@ -546,8 +706,8 @@ pub mod ty {\n \n     #[derive(Debug)]\n     pub struct MutRef(pub mir::LocalKind);\n-    impl NonConstOp for MutRef {\n-        fn status_in_item(&self, _ccx: &ConstCx<'_, '_>) -> Status {\n+    impl<'tcx> NonConstOp<'tcx> for MutRef {\n+        fn status_in_item(&self, _ccx: &ConstCx<'_, 'tcx>) -> Status {\n             Status::Unstable(sym::const_mut_refs)\n         }\n \n@@ -560,11 +720,7 @@ pub mod ty {\n             }\n         }\n \n-        fn build_error<'tcx>(\n-            &self,\n-            ccx: &ConstCx<'_, 'tcx>,\n-            span: Span,\n-        ) -> DiagnosticBuilder<'tcx> {\n+        fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n             feature_err(\n                 &ccx.tcx.sess.parse_sess,\n                 sym::const_mut_refs,\n@@ -576,7 +732,7 @@ pub mod ty {\n \n     #[derive(Debug)]\n     pub struct FnPtr(pub mir::LocalKind);\n-    impl NonConstOp for FnPtr {\n+    impl<'tcx> NonConstOp<'tcx> for FnPtr {\n         fn importance(&self) -> DiagnosticImportance {\n             match self.0 {\n                 mir::LocalKind::Var | mir::LocalKind::Temp => DiagnosticImportance::Secondary,\n@@ -586,19 +742,15 @@ pub mod ty {\n             }\n         }\n \n-        fn status_in_item(&self, ccx: &ConstCx<'_, '_>) -> Status {\n+        fn status_in_item(&self, ccx: &ConstCx<'_, 'tcx>) -> Status {\n             if ccx.const_kind() != hir::ConstContext::ConstFn {\n                 Status::Allowed\n             } else {\n                 Status::Unstable(sym::const_fn_fn_ptr_basics)\n             }\n         }\n \n-        fn build_error<'tcx>(\n-            &self,\n-            ccx: &ConstCx<'_, 'tcx>,\n-            span: Span,\n-        ) -> DiagnosticBuilder<'tcx> {\n+        fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n             feature_err(\n                 &ccx.tcx.sess.parse_sess,\n                 sym::const_fn_fn_ptr_basics,\n@@ -610,16 +762,12 @@ pub mod ty {\n \n     #[derive(Debug)]\n     pub struct ImplTrait;\n-    impl NonConstOp for ImplTrait {\n+    impl<'tcx> NonConstOp<'tcx> for ImplTrait {\n         fn status_in_item(&self, _: &ConstCx<'_, '_>) -> Status {\n             Status::Unstable(sym::const_impl_trait)\n         }\n \n-        fn build_error<'tcx>(\n-            &self,\n-            ccx: &ConstCx<'_, 'tcx>,\n-            span: Span,\n-        ) -> DiagnosticBuilder<'tcx> {\n+        fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n             feature_err(\n                 &ccx.tcx.sess.parse_sess,\n                 sym::const_impl_trait,\n@@ -631,7 +779,7 @@ pub mod ty {\n \n     #[derive(Debug)]\n     pub struct TraitBound(pub mir::LocalKind);\n-    impl NonConstOp for TraitBound {\n+    impl<'tcx> NonConstOp<'tcx> for TraitBound {\n         fn importance(&self) -> DiagnosticImportance {\n             match self.0 {\n                 mir::LocalKind::Var | mir::LocalKind::Temp => DiagnosticImportance::Secondary,\n@@ -641,19 +789,15 @@ pub mod ty {\n             }\n         }\n \n-        fn status_in_item(&self, ccx: &ConstCx<'_, '_>) -> Status {\n+        fn status_in_item(&self, ccx: &ConstCx<'_, 'tcx>) -> Status {\n             if ccx.const_kind() != hir::ConstContext::ConstFn {\n                 Status::Allowed\n             } else {\n                 Status::Unstable(sym::const_fn_trait_bound)\n             }\n         }\n \n-        fn build_error<'tcx>(\n-            &self,\n-            ccx: &ConstCx<'_, 'tcx>,\n-            span: Span,\n-        ) -> DiagnosticBuilder<'tcx> {\n+        fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n             let mut err = feature_err(\n                 &ccx.tcx.sess.parse_sess,\n                 sym::const_fn_trait_bound,\n@@ -674,7 +818,7 @@ pub mod ty {\n \n     #[derive(Debug)]\n     pub struct DynTrait(pub mir::LocalKind);\n-    impl NonConstOp for DynTrait {\n+    impl<'tcx> NonConstOp<'tcx> for DynTrait {\n         fn importance(&self) -> DiagnosticImportance {\n             match self.0 {\n                 mir::LocalKind::Var | mir::LocalKind::Temp => DiagnosticImportance::Secondary,\n@@ -684,19 +828,15 @@ pub mod ty {\n             }\n         }\n \n-        fn status_in_item(&self, ccx: &ConstCx<'_, '_>) -> Status {\n+        fn status_in_item(&self, ccx: &ConstCx<'_, 'tcx>) -> Status {\n             if ccx.const_kind() != hir::ConstContext::ConstFn {\n                 Status::Allowed\n             } else {\n                 Status::Unstable(sym::const_fn_trait_bound)\n             }\n         }\n \n-        fn build_error<'tcx>(\n-            &self,\n-            ccx: &ConstCx<'_, 'tcx>,\n-            span: Span,\n-        ) -> DiagnosticBuilder<'tcx> {\n+        fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n             let mut err = feature_err(\n                 &ccx.tcx.sess.parse_sess,\n                 sym::const_fn_trait_bound,\n@@ -718,16 +858,12 @@ pub mod ty {\n     /// A trait bound with the `?const Trait` opt-out\n     #[derive(Debug)]\n     pub struct TraitBoundNotConst;\n-    impl NonConstOp for TraitBoundNotConst {\n-        fn status_in_item(&self, _: &ConstCx<'_, '_>) -> Status {\n+    impl<'tcx> NonConstOp<'tcx> for TraitBoundNotConst {\n+        fn status_in_item(&self, _: &ConstCx<'_, 'tcx>) -> Status {\n             Status::Unstable(sym::const_trait_bound_opt_out)\n         }\n \n-        fn build_error<'tcx>(\n-            &self,\n-            ccx: &ConstCx<'_, 'tcx>,\n-            span: Span,\n-        ) -> DiagnosticBuilder<'tcx> {\n+        fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n             feature_err(\n                 &ccx.tcx.sess.parse_sess,\n                 sym::const_trait_bound_opt_out,"}, {"sha": "11bb9508a1f8626ac347f33f45d7fb9ab9232630", "filename": "compiler/rustc_const_eval/src/util/call_kind.rs", "status": "added", "additions": 143, "deletions": 0, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fcall_kind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fcall_kind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fcall_kind.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -0,0 +1,143 @@\n+//! Common logic for borrowck use-after-move errors when moved into a `fn(self)`,\n+//! as well as errors when attempting to call a non-const function in a const\n+//! context.\n+\n+use rustc_hir::def_id::DefId;\n+use rustc_hir::lang_items::LangItemGroup;\n+use rustc_middle::ty::subst::SubstsRef;\n+use rustc_middle::ty::{self, AssocItemContainer, DefIdTree, Instance, ParamEnv, Ty, TyCtxt};\n+use rustc_span::symbol::Ident;\n+use rustc_span::{sym, DesugaringKind, Span};\n+\n+#[derive(Clone, Copy, PartialEq, Eq, Debug)]\n+pub enum CallDesugaringKind {\n+    /// for _ in x {} calls x.into_iter()\n+    ForLoopIntoIter,\n+    /// x? calls x.branch()\n+    QuestionBranch,\n+    /// x? calls type_of(x)::from_residual()\n+    QuestionFromResidual,\n+    /// try { ..; x } calls type_of(x)::from_output(x)\n+    TryBlockFromOutput,\n+}\n+\n+impl CallDesugaringKind {\n+    pub fn trait_def_id(self, tcx: TyCtxt<'_>) -> DefId {\n+        match self {\n+            Self::ForLoopIntoIter => tcx.get_diagnostic_item(sym::IntoIterator).unwrap(),\n+            Self::QuestionBranch | Self::TryBlockFromOutput => {\n+                tcx.lang_items().try_trait().unwrap()\n+            }\n+            Self::QuestionFromResidual => tcx.get_diagnostic_item(sym::FromResidual).unwrap(),\n+        }\n+    }\n+}\n+\n+#[derive(Clone, Copy, PartialEq, Eq, Debug)]\n+pub enum CallKind<'tcx> {\n+    /// A normal method call of the form `receiver.foo(a, b, c)`\n+    Normal {\n+        self_arg: Option<Ident>,\n+        desugaring: Option<(CallDesugaringKind, Ty<'tcx>)>,\n+        /// Whether the self type of the method call has an `.as_ref()` method.\n+        /// Used for better diagnostics.\n+        is_option_or_result: bool,\n+    },\n+    /// A call to `Fn(..)::call(..)`, desugared from `my_closure(a, b, c)`\n+    FnCall { fn_trait_id: DefId, self_ty: Ty<'tcx> },\n+    /// A call to an operator trait, desuraged from operator syntax (e.g. `a << b`)\n+    Operator { self_arg: Option<Ident>, trait_id: DefId, self_ty: Ty<'tcx> },\n+    DerefCoercion {\n+        /// The `Span` of the `Target` associated type\n+        /// in the `Deref` impl we are using.\n+        deref_target: Span,\n+        /// The type `T::Deref` we are dereferencing to\n+        deref_target_ty: Ty<'tcx>,\n+        self_ty: Ty<'tcx>,\n+    },\n+}\n+\n+pub fn call_kind<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    param_env: ParamEnv<'tcx>,\n+    method_did: DefId,\n+    method_substs: SubstsRef<'tcx>,\n+    fn_call_span: Span,\n+    from_hir_call: bool,\n+    self_arg: Option<Ident>,\n+) -> CallKind<'tcx> {\n+    let parent = tcx.opt_associated_item(method_did).and_then(|assoc| match assoc.container {\n+        AssocItemContainer::ImplContainer(impl_did) => tcx.trait_id_of_impl(impl_did),\n+        AssocItemContainer::TraitContainer(trait_did) => Some(trait_did),\n+    });\n+\n+    let fn_call = parent\n+        .and_then(|p| tcx.lang_items().group(LangItemGroup::Fn).iter().find(|did| **did == p));\n+\n+    let operator = (!from_hir_call)\n+        .then(|| parent)\n+        .flatten()\n+        .and_then(|p| tcx.lang_items().group(LangItemGroup::Op).iter().find(|did| **did == p));\n+\n+    let is_deref = !from_hir_call && tcx.is_diagnostic_item(sym::deref_method, method_did);\n+\n+    // Check for a 'special' use of 'self' -\n+    // an FnOnce call, an operator (e.g. `<<`), or a\n+    // deref coercion.\n+    let kind = if let Some(&trait_id) = fn_call {\n+        Some(CallKind::FnCall { fn_trait_id: trait_id, self_ty: method_substs.type_at(0) })\n+    } else if let Some(&trait_id) = operator {\n+        Some(CallKind::Operator { self_arg, trait_id, self_ty: method_substs.type_at(0) })\n+    } else if is_deref {\n+        let deref_target = tcx.get_diagnostic_item(sym::deref_target).and_then(|deref_target| {\n+            Instance::resolve(tcx, param_env, deref_target, method_substs).transpose()\n+        });\n+        if let Some(Ok(instance)) = deref_target {\n+            let deref_target_ty = instance.ty(tcx, param_env);\n+            Some(CallKind::DerefCoercion {\n+                deref_target: tcx.def_span(instance.def_id()),\n+                deref_target_ty,\n+                self_ty: method_substs.type_at(0),\n+            })\n+        } else {\n+            None\n+        }\n+    } else {\n+        None\n+    };\n+\n+    kind.unwrap_or_else(|| {\n+        // This isn't a 'special' use of `self`\n+        debug!(?method_did, ?fn_call_span);\n+        let desugaring = if Some(method_did) == tcx.lang_items().into_iter_fn()\n+            && fn_call_span.desugaring_kind() == Some(DesugaringKind::ForLoop)\n+        {\n+            Some((CallDesugaringKind::ForLoopIntoIter, method_substs.type_at(0)))\n+        } else if fn_call_span.desugaring_kind() == Some(DesugaringKind::QuestionMark) {\n+            if Some(method_did) == tcx.lang_items().branch_fn() {\n+                Some((CallDesugaringKind::QuestionBranch, method_substs.type_at(0)))\n+            } else if Some(method_did) == tcx.lang_items().from_residual_fn() {\n+                Some((CallDesugaringKind::QuestionFromResidual, method_substs.type_at(0)))\n+            } else {\n+                None\n+            }\n+        } else if Some(method_did) == tcx.lang_items().from_output_fn()\n+            && fn_call_span.desugaring_kind() == Some(DesugaringKind::TryBlock)\n+        {\n+            Some((CallDesugaringKind::TryBlockFromOutput, method_substs.type_at(0)))\n+        } else {\n+            None\n+        };\n+        let parent_self_ty = tcx\n+            .parent(method_did)\n+            .filter(|did| tcx.def_kind(*did) == rustc_hir::def::DefKind::Impl)\n+            .and_then(|did| match tcx.type_of(did).kind() {\n+                ty::Adt(def, ..) => Some(def.did),\n+                _ => None,\n+            });\n+        let is_option_or_result = parent_self_ty.map_or(false, |def_id| {\n+            matches!(tcx.get_diagnostic_name(def_id), Some(sym::Option | sym::Result))\n+        });\n+        CallKind::Normal { self_arg, desugaring, is_option_or_result }\n+    })\n+}"}, {"sha": "a1876bed83eca4a1bfac1eb0d781e1b707ea50de", "filename": "compiler/rustc_const_eval/src/util/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Futil%2Fmod.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -1,8 +1,10 @@\n pub mod aggregate;\n mod alignment;\n+mod call_kind;\n pub mod collect_writes;\n mod find_self_call;\n \n pub use self::aggregate::expand_aggregate;\n pub use self::alignment::is_disaligned;\n+pub use self::call_kind::{call_kind, CallDesugaringKind, CallKind};\n pub use self::find_self_call::find_self_call;"}, {"sha": "7eeae66d709e9baeab17dfa5d5b36295fe90dcf8", "filename": "compiler/rustc_driver/src/lib.rs", "status": "modified", "additions": 138, "deletions": 151, "changes": 289, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/compiler%2Frustc_driver%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver%2Fsrc%2Flib.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -263,7 +263,7 @@ fn run_compiler(\n                         describe_lints(compiler.session(), &lint_store, registered_lints);\n                         return;\n                     }\n-                    let should_stop = RustcDefaultCalls::print_crate_info(\n+                    let should_stop = print_crate_info(\n                         &***compiler.codegen_backend(),\n                         compiler.session(),\n                         None,\n@@ -292,7 +292,7 @@ fn run_compiler(\n \n     interface::run_compiler(config, |compiler| {\n         let sess = compiler.session();\n-        let should_stop = RustcDefaultCalls::print_crate_info(\n+        let should_stop = print_crate_info(\n             &***compiler.codegen_backend(),\n             sess,\n             Some(compiler.input()),\n@@ -301,13 +301,9 @@ fn run_compiler(\n             compiler.temps_dir(),\n         )\n         .and_then(|| {\n-            RustcDefaultCalls::list_metadata(\n-                sess,\n-                &*compiler.codegen_backend().metadata_loader(),\n-                compiler.input(),\n-            )\n+            list_metadata(sess, &*compiler.codegen_backend().metadata_loader(), compiler.input())\n         })\n-        .and_then(|| RustcDefaultCalls::try_process_rlink(sess, compiler));\n+        .and_then(|| try_process_rlink(sess, compiler));\n \n         if should_stop == Compilation::Stop {\n             return sess.compile_status();\n@@ -512,10 +508,6 @@ impl Compilation {\n     }\n }\n \n-/// CompilerCalls instance for a regular rustc build.\n-#[derive(Copy, Clone)]\n-pub struct RustcDefaultCalls;\n-\n fn handle_explain(registry: Registry, code: &str, output: ErrorOutputType) {\n     let upper_cased_code = code.to_ascii_uppercase();\n     let normalised = if upper_cased_code.starts_with('E') {\n@@ -588,162 +580,157 @@ fn show_content_with_pager(content: &str) {\n     }\n }\n \n-impl RustcDefaultCalls {\n-    pub fn try_process_rlink(sess: &Session, compiler: &interface::Compiler) -> Compilation {\n-        if sess.opts.debugging_opts.link_only {\n-            if let Input::File(file) = compiler.input() {\n-                // FIXME: #![crate_type] and #![crate_name] support not implemented yet\n-                sess.init_crate_types(collect_crate_types(sess, &[]));\n-                let outputs = compiler.build_output_filenames(sess, &[]);\n-                let rlink_data = fs::read(file).unwrap_or_else(|err| {\n-                    sess.fatal(&format!(\"failed to read rlink file: {}\", err));\n-                });\n-                let mut decoder = rustc_serialize::opaque::Decoder::new(&rlink_data, 0);\n-                let codegen_results: CodegenResults =\n-                    rustc_serialize::Decodable::decode(&mut decoder);\n-                let result = compiler.codegen_backend().link(sess, codegen_results, &outputs);\n-                abort_on_err(result, sess);\n-            } else {\n-                sess.fatal(\"rlink must be a file\")\n-            }\n-            Compilation::Stop\n+pub fn try_process_rlink(sess: &Session, compiler: &interface::Compiler) -> Compilation {\n+    if sess.opts.debugging_opts.link_only {\n+        if let Input::File(file) = compiler.input() {\n+            // FIXME: #![crate_type] and #![crate_name] support not implemented yet\n+            sess.init_crate_types(collect_crate_types(sess, &[]));\n+            let outputs = compiler.build_output_filenames(sess, &[]);\n+            let rlink_data = fs::read(file).unwrap_or_else(|err| {\n+                sess.fatal(&format!(\"failed to read rlink file: {}\", err));\n+            });\n+            let mut decoder = rustc_serialize::opaque::Decoder::new(&rlink_data, 0);\n+            let codegen_results: CodegenResults = rustc_serialize::Decodable::decode(&mut decoder);\n+            let result = compiler.codegen_backend().link(sess, codegen_results, &outputs);\n+            abort_on_err(result, sess);\n         } else {\n-            Compilation::Continue\n+            sess.fatal(\"rlink must be a file\")\n         }\n+        Compilation::Stop\n+    } else {\n+        Compilation::Continue\n     }\n+}\n \n-    pub fn list_metadata(\n-        sess: &Session,\n-        metadata_loader: &dyn MetadataLoader,\n-        input: &Input,\n-    ) -> Compilation {\n-        if sess.opts.debugging_opts.ls {\n-            match *input {\n-                Input::File(ref ifile) => {\n-                    let path = &(*ifile);\n-                    let mut v = Vec::new();\n-                    locator::list_file_metadata(&sess.target, path, metadata_loader, &mut v)\n-                        .unwrap();\n-                    println!(\"{}\", String::from_utf8(v).unwrap());\n-                }\n-                Input::Str { .. } => {\n-                    early_error(ErrorOutputType::default(), \"cannot list metadata for stdin\");\n-                }\n+pub fn list_metadata(\n+    sess: &Session,\n+    metadata_loader: &dyn MetadataLoader,\n+    input: &Input,\n+) -> Compilation {\n+    if sess.opts.debugging_opts.ls {\n+        match *input {\n+            Input::File(ref ifile) => {\n+                let path = &(*ifile);\n+                let mut v = Vec::new();\n+                locator::list_file_metadata(&sess.target, path, metadata_loader, &mut v).unwrap();\n+                println!(\"{}\", String::from_utf8(v).unwrap());\n+            }\n+            Input::Str { .. } => {\n+                early_error(ErrorOutputType::default(), \"cannot list metadata for stdin\");\n             }\n-            return Compilation::Stop;\n         }\n-\n-        Compilation::Continue\n+        return Compilation::Stop;\n     }\n \n-    fn print_crate_info(\n-        codegen_backend: &dyn CodegenBackend,\n-        sess: &Session,\n-        input: Option<&Input>,\n-        odir: &Option<PathBuf>,\n-        ofile: &Option<PathBuf>,\n-        temps_dir: &Option<PathBuf>,\n-    ) -> Compilation {\n-        use rustc_session::config::PrintRequest::*;\n-        // NativeStaticLibs and LinkArgs are special - printed during linking\n-        // (empty iterator returns true)\n-        if sess.opts.prints.iter().all(|&p| p == NativeStaticLibs || p == LinkArgs) {\n-            return Compilation::Continue;\n-        }\n+    Compilation::Continue\n+}\n \n-        let attrs = match input {\n-            None => None,\n-            Some(input) => {\n-                let result = parse_crate_attrs(sess, input);\n-                match result {\n-                    Ok(attrs) => Some(attrs),\n-                    Err(mut parse_error) => {\n-                        parse_error.emit();\n-                        return Compilation::Stop;\n-                    }\n+fn print_crate_info(\n+    codegen_backend: &dyn CodegenBackend,\n+    sess: &Session,\n+    input: Option<&Input>,\n+    odir: &Option<PathBuf>,\n+    ofile: &Option<PathBuf>,\n+    temps_dir: &Option<PathBuf>,\n+) -> Compilation {\n+    use rustc_session::config::PrintRequest::*;\n+    // NativeStaticLibs and LinkArgs are special - printed during linking\n+    // (empty iterator returns true)\n+    if sess.opts.prints.iter().all(|&p| p == NativeStaticLibs || p == LinkArgs) {\n+        return Compilation::Continue;\n+    }\n+\n+    let attrs = match input {\n+        None => None,\n+        Some(input) => {\n+            let result = parse_crate_attrs(sess, input);\n+            match result {\n+                Ok(attrs) => Some(attrs),\n+                Err(mut parse_error) => {\n+                    parse_error.emit();\n+                    return Compilation::Stop;\n                 }\n             }\n-        };\n-        for req in &sess.opts.prints {\n-            match *req {\n-                TargetList => {\n-                    let mut targets =\n-                        rustc_target::spec::TARGETS.iter().copied().collect::<Vec<_>>();\n-                    targets.sort_unstable();\n-                    println!(\"{}\", targets.join(\"\\n\"));\n-                }\n-                Sysroot => println!(\"{}\", sess.sysroot.display()),\n-                TargetLibdir => println!(\"{}\", sess.target_tlib_path.dir.display()),\n-                TargetSpec => println!(\"{}\", sess.target.to_json().pretty()),\n-                FileNames | CrateName => {\n-                    let input = input.unwrap_or_else(|| {\n-                        early_error(ErrorOutputType::default(), \"no input file provided\")\n-                    });\n-                    let attrs = attrs.as_ref().unwrap();\n-                    let t_outputs = rustc_interface::util::build_output_filenames(\n-                        input, odir, ofile, temps_dir, attrs, sess,\n-                    );\n-                    let id = rustc_session::output::find_crate_name(sess, attrs, input);\n-                    if *req == PrintRequest::CrateName {\n-                        println!(\"{}\", id);\n-                        continue;\n-                    }\n-                    let crate_types = collect_crate_types(sess, attrs);\n-                    for &style in &crate_types {\n-                        let fname =\n-                            rustc_session::output::filename_for_input(sess, style, &id, &t_outputs);\n-                        println!(\"{}\", fname.file_name().unwrap().to_string_lossy());\n-                    }\n+        }\n+    };\n+    for req in &sess.opts.prints {\n+        match *req {\n+            TargetList => {\n+                let mut targets = rustc_target::spec::TARGETS.iter().copied().collect::<Vec<_>>();\n+                targets.sort_unstable();\n+                println!(\"{}\", targets.join(\"\\n\"));\n+            }\n+            Sysroot => println!(\"{}\", sess.sysroot.display()),\n+            TargetLibdir => println!(\"{}\", sess.target_tlib_path.dir.display()),\n+            TargetSpec => println!(\"{}\", sess.target.to_json().pretty()),\n+            FileNames | CrateName => {\n+                let input = input.unwrap_or_else(|| {\n+                    early_error(ErrorOutputType::default(), \"no input file provided\")\n+                });\n+                let attrs = attrs.as_ref().unwrap();\n+                let t_outputs = rustc_interface::util::build_output_filenames(\n+                    input, odir, ofile, temps_dir, attrs, sess,\n+                );\n+                let id = rustc_session::output::find_crate_name(sess, attrs, input);\n+                if *req == PrintRequest::CrateName {\n+                    println!(\"{}\", id);\n+                    continue;\n                 }\n-                Cfg => {\n-                    let mut cfgs = sess\n-                        .parse_sess\n-                        .config\n-                        .iter()\n-                        .filter_map(|&(name, value)| {\n-                            // Note that crt-static is a specially recognized cfg\n-                            // directive that's printed out here as part of\n-                            // rust-lang/rust#37406, but in general the\n-                            // `target_feature` cfg is gated under\n-                            // rust-lang/rust#29717. For now this is just\n-                            // specifically allowing the crt-static cfg and that's\n-                            // it, this is intended to get into Cargo and then go\n-                            // through to build scripts.\n-                            if (name != sym::target_feature || value != Some(sym::crt_dash_static))\n-                                && !sess.is_nightly_build()\n-                                && find_gated_cfg(|cfg_sym| cfg_sym == name).is_some()\n-                            {\n-                                return None;\n-                            }\n-\n-                            if let Some(value) = value {\n-                                Some(format!(\"{}=\\\"{}\\\"\", name, value))\n-                            } else {\n-                                Some(name.to_string())\n-                            }\n-                        })\n-                        .collect::<Vec<String>>();\n-\n-                    cfgs.sort();\n-                    for cfg in cfgs {\n-                        println!(\"{}\", cfg);\n-                    }\n+                let crate_types = collect_crate_types(sess, attrs);\n+                for &style in &crate_types {\n+                    let fname =\n+                        rustc_session::output::filename_for_input(sess, style, &id, &t_outputs);\n+                    println!(\"{}\", fname.file_name().unwrap().to_string_lossy());\n                 }\n-                RelocationModels\n-                | CodeModels\n-                | TlsModels\n-                | TargetCPUs\n-                | StackProtectorStrategies\n-                | TargetFeatures => {\n-                    codegen_backend.print(*req, sess);\n+            }\n+            Cfg => {\n+                let mut cfgs = sess\n+                    .parse_sess\n+                    .config\n+                    .iter()\n+                    .filter_map(|&(name, value)| {\n+                        // Note that crt-static is a specially recognized cfg\n+                        // directive that's printed out here as part of\n+                        // rust-lang/rust#37406, but in general the\n+                        // `target_feature` cfg is gated under\n+                        // rust-lang/rust#29717. For now this is just\n+                        // specifically allowing the crt-static cfg and that's\n+                        // it, this is intended to get into Cargo and then go\n+                        // through to build scripts.\n+                        if (name != sym::target_feature || value != Some(sym::crt_dash_static))\n+                            && !sess.is_nightly_build()\n+                            && find_gated_cfg(|cfg_sym| cfg_sym == name).is_some()\n+                        {\n+                            return None;\n+                        }\n+\n+                        if let Some(value) = value {\n+                            Some(format!(\"{}=\\\"{}\\\"\", name, value))\n+                        } else {\n+                            Some(name.to_string())\n+                        }\n+                    })\n+                    .collect::<Vec<String>>();\n+\n+                cfgs.sort();\n+                for cfg in cfgs {\n+                    println!(\"{}\", cfg);\n                 }\n-                // Any output here interferes with Cargo's parsing of other printed output\n-                NativeStaticLibs => {}\n-                LinkArgs => {}\n             }\n+            RelocationModels\n+            | CodeModels\n+            | TlsModels\n+            | TargetCPUs\n+            | StackProtectorStrategies\n+            | TargetFeatures => {\n+                codegen_backend.print(*req, sess);\n+            }\n+            // Any output here interferes with Cargo's parsing of other printed output\n+            NativeStaticLibs => {}\n+            LinkArgs => {}\n         }\n-        Compilation::Stop\n     }\n+    Compilation::Stop\n }\n \n /// Prints version information"}, {"sha": "b299e71c9c4c45f4d78fc95f6cba527b6fe07b75", "filename": "compiler/rustc_hir/src/lang_items.rs", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Flang_items.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -21,9 +21,10 @@ use std::lazy::SyncLazy;\n \n pub enum LangItemGroup {\n     Op,\n+    Fn,\n }\n \n-const NUM_GROUPS: usize = 1;\n+const NUM_GROUPS: usize = 2;\n \n macro_rules! expand_group {\n     () => {\n@@ -98,11 +99,12 @@ macro_rules! language_item_table {\n             /// Construct an empty collection of lang items and no missing ones.\n             pub fn new() -> Self {\n                 fn init_none(_: LangItem) -> Option<DefId> { None }\n+                const EMPTY: Vec<DefId> = Vec::new();\n \n                 Self {\n                     items: vec![$(init_none(LangItem::$variant)),*],\n                     missing: Vec::new(),\n-                    groups: [vec![]; NUM_GROUPS],\n+                    groups: [EMPTY; NUM_GROUPS],\n                 }\n             }\n \n@@ -251,9 +253,9 @@ language_item_table! {\n     DerefTarget,             sym::deref_target,        deref_target,               Target::AssocTy,        GenericRequirement::None;\n     Receiver,                sym::receiver,            receiver_trait,             Target::Trait,          GenericRequirement::None;\n \n-    Fn,                      kw::Fn,                   fn_trait,                   Target::Trait,          GenericRequirement::Exact(1);\n-    FnMut,                   sym::fn_mut,              fn_mut_trait,               Target::Trait,          GenericRequirement::Exact(1);\n-    FnOnce,                  sym::fn_once,             fn_once_trait,              Target::Trait,          GenericRequirement::Exact(1);\n+    Fn(Fn),                  kw::Fn,                   fn_trait,                   Target::Trait,          GenericRequirement::Exact(1);\n+    FnMut(Fn),               sym::fn_mut,              fn_mut_trait,               Target::Trait,          GenericRequirement::Exact(1);\n+    FnOnce(Fn),              sym::fn_once,             fn_once_trait,              Target::Trait,          GenericRequirement::Exact(1);\n \n     FnOnceOutput,            sym::fn_once_output,      fn_once_output,             Target::AssocTy,        GenericRequirement::None;\n \n@@ -264,8 +266,8 @@ language_item_table! {\n     Unpin,                   sym::unpin,               unpin_trait,                Target::Trait,          GenericRequirement::None;\n     Pin,                     sym::pin,                 pin_type,                   Target::Struct,         GenericRequirement::None;\n \n-    PartialEq,               sym::eq,                  eq_trait,                   Target::Trait,          GenericRequirement::Exact(1);\n-    PartialOrd,              sym::partial_ord,         partial_ord_trait,          Target::Trait,          GenericRequirement::Exact(1);\n+    PartialEq(Op),           sym::eq,                  eq_trait,                   Target::Trait,          GenericRequirement::Exact(1);\n+    PartialOrd(Op),          sym::partial_ord,         partial_ord_trait,          Target::Trait,          GenericRequirement::Exact(1);\n \n     // A number of panic-related lang items. The `panic` item corresponds to divide-by-zero and\n     // various panic cases with `match`. The `panic_bounds_check` item is for indexing arrays."}, {"sha": "bd5892dba38c7dad46980ba8fec0c78560623895", "filename": "compiler/rustc_infer/src/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 158, "deletions": 17, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -49,6 +49,31 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n         Canonicalizer::canonicalize(value, self, self.tcx, &CanonicalizeAllFreeRegions, query_state)\n     }\n \n+    /// Like [Self::canonicalize_query], but preserves distinct universes. For\n+    /// example, canonicalizing `&'?0: Trait<'?1>`, where `'?0` is in `U1` and\n+    /// `'?1` is in `U3` would be canonicalized to have ?0` in `U1` and `'?1`\n+    /// in `U2`.\n+    ///\n+    /// This is used for Chalk integration.\n+    pub fn canonicalize_query_preserving_universes<V>(\n+        &self,\n+        value: V,\n+        query_state: &mut OriginalQueryValues<'tcx>,\n+    ) -> Canonicalized<'tcx, V>\n+    where\n+        V: TypeFoldable<'tcx>,\n+    {\n+        self.tcx.sess.perf_stats.queries_canonicalized.fetch_add(1, Ordering::Relaxed);\n+\n+        Canonicalizer::canonicalize(\n+            value,\n+            self,\n+            self.tcx,\n+            &CanonicalizeAllFreeRegionsPreservingUniverses,\n+            query_state,\n+        )\n+    }\n+\n     /// Canonicalizes a query *response* `V`. When we canonicalize a\n     /// query response, we only canonicalize unbound inference\n     /// variables, and we leave other free regions alone. So,\n@@ -133,19 +158,22 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n /// maximally general query. But if we are canonicalizing a *query\n /// response*, then we don't typically replace free regions, as they\n /// must have been introduced from other parts of the system.\n-trait CanonicalizeRegionMode {\n+trait CanonicalizeMode {\n     fn canonicalize_free_region<'tcx>(\n         &self,\n         canonicalizer: &mut Canonicalizer<'_, 'tcx>,\n         r: ty::Region<'tcx>,\n     ) -> ty::Region<'tcx>;\n \n     fn any(&self) -> bool;\n+\n+    // Do we preserve universe of variables.\n+    fn preserve_universes(&self) -> bool;\n }\n \n struct CanonicalizeQueryResponse;\n \n-impl CanonicalizeRegionMode for CanonicalizeQueryResponse {\n+impl CanonicalizeMode for CanonicalizeQueryResponse {\n     fn canonicalize_free_region<'tcx>(\n         &self,\n         canonicalizer: &mut Canonicalizer<'_, 'tcx>,\n@@ -198,11 +226,15 @@ impl CanonicalizeRegionMode for CanonicalizeQueryResponse {\n     fn any(&self) -> bool {\n         false\n     }\n+\n+    fn preserve_universes(&self) -> bool {\n+        true\n+    }\n }\n \n struct CanonicalizeUserTypeAnnotation;\n \n-impl CanonicalizeRegionMode for CanonicalizeUserTypeAnnotation {\n+impl CanonicalizeMode for CanonicalizeUserTypeAnnotation {\n     fn canonicalize_free_region<'tcx>(\n         &self,\n         canonicalizer: &mut Canonicalizer<'_, 'tcx>,\n@@ -221,11 +253,15 @@ impl CanonicalizeRegionMode for CanonicalizeUserTypeAnnotation {\n     fn any(&self) -> bool {\n         false\n     }\n+\n+    fn preserve_universes(&self) -> bool {\n+        false\n+    }\n }\n \n struct CanonicalizeAllFreeRegions;\n \n-impl CanonicalizeRegionMode for CanonicalizeAllFreeRegions {\n+impl CanonicalizeMode for CanonicalizeAllFreeRegions {\n     fn canonicalize_free_region<'tcx>(\n         &self,\n         canonicalizer: &mut Canonicalizer<'_, 'tcx>,\n@@ -237,11 +273,39 @@ impl CanonicalizeRegionMode for CanonicalizeAllFreeRegions {\n     fn any(&self) -> bool {\n         true\n     }\n+\n+    fn preserve_universes(&self) -> bool {\n+        false\n+    }\n+}\n+\n+struct CanonicalizeAllFreeRegionsPreservingUniverses;\n+\n+impl CanonicalizeMode for CanonicalizeAllFreeRegionsPreservingUniverses {\n+    fn canonicalize_free_region<'tcx>(\n+        &self,\n+        canonicalizer: &mut Canonicalizer<'_, 'tcx>,\n+        r: ty::Region<'tcx>,\n+    ) -> ty::Region<'tcx> {\n+        let universe = canonicalizer.infcx.universe_of_region(r);\n+        canonicalizer.canonical_var_for_region(\n+            CanonicalVarInfo { kind: CanonicalVarKind::Region(universe) },\n+            r,\n+        )\n+    }\n+\n+    fn any(&self) -> bool {\n+        true\n+    }\n+\n+    fn preserve_universes(&self) -> bool {\n+        true\n+    }\n }\n \n struct CanonicalizeFreeRegionsOtherThanStatic;\n \n-impl CanonicalizeRegionMode for CanonicalizeFreeRegionsOtherThanStatic {\n+impl CanonicalizeMode for CanonicalizeFreeRegionsOtherThanStatic {\n     fn canonicalize_free_region<'tcx>(\n         &self,\n         canonicalizer: &mut Canonicalizer<'_, 'tcx>,\n@@ -257,6 +321,10 @@ impl CanonicalizeRegionMode for CanonicalizeFreeRegionsOtherThanStatic {\n     fn any(&self) -> bool {\n         true\n     }\n+\n+    fn preserve_universes(&self) -> bool {\n+        false\n+    }\n }\n \n struct Canonicalizer<'cx, 'tcx> {\n@@ -267,7 +335,7 @@ struct Canonicalizer<'cx, 'tcx> {\n     // Note that indices is only used once `var_values` is big enough to be\n     // heap-allocated.\n     indices: FxHashMap<GenericArg<'tcx>, BoundVar>,\n-    canonicalize_region_mode: &'cx dyn CanonicalizeRegionMode,\n+    canonicalize_mode: &'cx dyn CanonicalizeMode,\n     needs_canonical_flags: TypeFlags,\n \n     binder_index: ty::DebruijnIndex,\n@@ -311,15 +379,15 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Canonicalizer<'cx, 'tcx> {\n                     vid, r\n                 );\n                 let r = self.tcx.reuse_or_mk_region(r, ty::ReVar(resolved_vid));\n-                self.canonicalize_region_mode.canonicalize_free_region(self, r)\n+                self.canonicalize_mode.canonicalize_free_region(self, r)\n             }\n \n             ty::ReStatic\n             | ty::ReEarlyBound(..)\n             | ty::ReFree(_)\n             | ty::ReEmpty(_)\n             | ty::RePlaceholder(..)\n-            | ty::ReErased => self.canonicalize_region_mode.canonicalize_free_region(self, r),\n+            | ty::ReErased => self.canonicalize_mode.canonicalize_free_region(self, r),\n         }\n     }\n \n@@ -337,8 +405,10 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Canonicalizer<'cx, 'tcx> {\n                     // `TyVar(vid)` is unresolved, track its universe index in the canonicalized\n                     // result.\n                     Err(mut ui) => {\n-                        // FIXME: perf problem described in #55921.\n-                        ui = ty::UniverseIndex::ROOT;\n+                        if !self.canonicalize_mode.preserve_universes() {\n+                            // FIXME: perf problem described in #55921.\n+                            ui = ty::UniverseIndex::ROOT;\n+                        }\n                         self.canonicalize_ty_var(\n                             CanonicalVarInfo {\n                                 kind: CanonicalVarKind::Ty(CanonicalTyVarKind::General(ui)),\n@@ -422,8 +492,10 @@ impl<'cx, 'tcx> TypeFolder<'tcx> for Canonicalizer<'cx, 'tcx> {\n                     // `ConstVar(vid)` is unresolved, track its universe index in the\n                     // canonicalized result\n                     Err(mut ui) => {\n-                        // FIXME: perf problem described in #55921.\n-                        ui = ty::UniverseIndex::ROOT;\n+                        if !self.canonicalize_mode.preserve_universes() {\n+                            // FIXME: perf problem described in #55921.\n+                            ui = ty::UniverseIndex::ROOT;\n+                        }\n                         return self.canonicalize_const_var(\n                             CanonicalVarInfo { kind: CanonicalVarKind::Const(ui, ct.ty) },\n                             ct,\n@@ -462,7 +534,7 @@ impl<'cx, 'tcx> Canonicalizer<'cx, 'tcx> {\n         value: V,\n         infcx: &InferCtxt<'_, 'tcx>,\n         tcx: TyCtxt<'tcx>,\n-        canonicalize_region_mode: &dyn CanonicalizeRegionMode,\n+        canonicalize_region_mode: &dyn CanonicalizeMode,\n         query_state: &mut OriginalQueryValues<'tcx>,\n     ) -> Canonicalized<'tcx, V>\n     where\n@@ -493,7 +565,7 @@ impl<'cx, 'tcx> Canonicalizer<'cx, 'tcx> {\n         let mut canonicalizer = Canonicalizer {\n             infcx,\n             tcx,\n-            canonicalize_region_mode,\n+            canonicalize_mode: canonicalize_region_mode,\n             needs_canonical_flags,\n             variables: SmallVec::new(),\n             query_state,\n@@ -504,10 +576,11 @@ impl<'cx, 'tcx> Canonicalizer<'cx, 'tcx> {\n \n         // Once we have canonicalized `out_value`, it should not\n         // contain anything that ties it to this inference context\n-        // anymore, so it should live in the global arena.\n-        debug_assert!(!out_value.needs_infer());\n+        // anymore.\n+        debug_assert!(!out_value.needs_infer() && !out_value.has_placeholders());\n \n-        let canonical_variables = tcx.intern_canonical_var_infos(&canonicalizer.variables);\n+        let canonical_variables =\n+            tcx.intern_canonical_var_infos(&canonicalizer.universe_canonicalized_variables());\n \n         let max_universe = canonical_variables\n             .iter()\n@@ -527,6 +600,19 @@ impl<'cx, 'tcx> Canonicalizer<'cx, 'tcx> {\n \n         let var_values = &mut query_state.var_values;\n \n+        let universe = info.universe();\n+        if universe != ty::UniverseIndex::ROOT {\n+            assert!(self.canonicalize_mode.preserve_universes());\n+\n+            // Insert universe into the universe map. To preserve the order of the\n+            // universes in the value being canonicalized, we don't update the\n+            // universe in `info` until we have finished canonicalizing.\n+            match query_state.universe_map.binary_search(&universe) {\n+                Err(idx) => query_state.universe_map.insert(idx, universe),\n+                Ok(_) => {}\n+            }\n+        }\n+\n         // This code is hot. `variables` and `var_values` are usually small\n         // (fewer than 8 elements ~95% of the time). They are SmallVec's to\n         // avoid allocations in those cases. We also don't use `indices` to\n@@ -569,6 +655,61 @@ impl<'cx, 'tcx> Canonicalizer<'cx, 'tcx> {\n         }\n     }\n \n+    /// Replaces the universe indexes used in `var_values` with their index in\n+    /// `query_state.universe_map`. This minimizes the maximum universe used in\n+    /// the canonicalized value.\n+    fn universe_canonicalized_variables(self) -> SmallVec<[CanonicalVarInfo<'tcx>; 8]> {\n+        if self.query_state.universe_map.len() == 1 {\n+            return self.variables;\n+        }\n+\n+        let reverse_universe_map: FxHashMap<ty::UniverseIndex, ty::UniverseIndex> = self\n+            .query_state\n+            .universe_map\n+            .iter()\n+            .enumerate()\n+            .map(|(idx, universe)| (*universe, ty::UniverseIndex::from_usize(idx)))\n+            .collect();\n+\n+        self.variables\n+            .iter()\n+            .map(|v| CanonicalVarInfo {\n+                kind: match v.kind {\n+                    CanonicalVarKind::Ty(CanonicalTyVarKind::Int | CanonicalTyVarKind::Float) => {\n+                        return *v;\n+                    }\n+                    CanonicalVarKind::Ty(CanonicalTyVarKind::General(u)) => {\n+                        CanonicalVarKind::Ty(CanonicalTyVarKind::General(reverse_universe_map[&u]))\n+                    }\n+                    CanonicalVarKind::Region(u) => {\n+                        CanonicalVarKind::Region(reverse_universe_map[&u])\n+                    }\n+                    CanonicalVarKind::Const(u, t) => {\n+                        CanonicalVarKind::Const(reverse_universe_map[&u], t)\n+                    }\n+                    CanonicalVarKind::PlaceholderTy(placeholder) => {\n+                        CanonicalVarKind::PlaceholderTy(ty::Placeholder {\n+                            universe: reverse_universe_map[&placeholder.universe],\n+                            ..placeholder\n+                        })\n+                    }\n+                    CanonicalVarKind::PlaceholderRegion(placeholder) => {\n+                        CanonicalVarKind::PlaceholderRegion(ty::Placeholder {\n+                            universe: reverse_universe_map[&placeholder.universe],\n+                            ..placeholder\n+                        })\n+                    }\n+                    CanonicalVarKind::PlaceholderConst(placeholder) => {\n+                        CanonicalVarKind::PlaceholderConst(ty::Placeholder {\n+                            universe: reverse_universe_map[&placeholder.universe],\n+                            ..placeholder\n+                        })\n+                    }\n+                },\n+            })\n+            .collect()\n+    }\n+\n     /// Shorthand helper that creates a canonical region variable for\n     /// `r` (always in the root universe). The reason that we always\n     /// put these variables into the root universe is because this"}, {"sha": "a18e2d1d638879fd264bb87775703e8d390546e7", "filename": "compiler/rustc_interface/src/callbacks.rs", "status": "modified", "additions": 1, "deletions": 14, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/compiler%2Frustc_interface%2Fsrc%2Fcallbacks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/compiler%2Frustc_interface%2Fsrc%2Fcallbacks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Fcallbacks.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -4,7 +4,7 @@\n //! `rustc_data_structures::AtomicRef` type, which allows us to setup a global\n //! static which can then be set in this file at program startup.\n //!\n-//! See `SPAN_DEBUG` for an example of how to set things up.\n+//! See `SPAN_TRACK` for an example of how to set things up.\n //!\n //! The functions in this file should fall back to the default set in their\n //! origin crate when the `TyCtxt` is not present in TLS.\n@@ -13,18 +13,6 @@ use rustc_errors::{Diagnostic, TRACK_DIAGNOSTICS};\n use rustc_middle::ty::tls;\n use std::fmt;\n \n-/// This is a callback from `rustc_ast` as it cannot access the implicit state\n-/// in `rustc_middle` otherwise.\n-fn span_debug(span: rustc_span::Span, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-    tls::with_opt(|tcx| {\n-        if let Some(tcx) = tcx {\n-            rustc_span::debug_with_source_map(span, f, tcx.sess.source_map())\n-        } else {\n-            rustc_span::default_span_debug(span, f)\n-        }\n-    })\n-}\n-\n fn track_span_parent(def_id: rustc_span::def_id::LocalDefId) {\n     tls::with_opt(|tcx| {\n         if let Some(tcx) = tcx {\n@@ -65,7 +53,6 @@ fn def_id_debug(def_id: rustc_hir::def_id::DefId, f: &mut fmt::Formatter<'_>) ->\n /// Sets up the callbacks in prior crates which we want to refer to the\n /// TyCtxt in.\n pub fn setup_callbacks() {\n-    rustc_span::SPAN_DEBUG.swap(&(span_debug as fn(_, &mut fmt::Formatter<'_>) -> _));\n     rustc_span::SPAN_TRACK.swap(&(track_span_parent as fn(_)));\n     rustc_hir::def_id::DEF_ID_DEBUG.swap(&(def_id_debug as fn(_, &mut fmt::Formatter<'_>) -> _));\n     TRACK_DIAGNOSTICS.swap(&(track_diagnostic as fn(&_)));"}, {"sha": "8bd24487b7843dc05ce28bf820e568ab37917288", "filename": "compiler/rustc_interface/src/interface.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/compiler%2Frustc_interface%2Fsrc%2Finterface.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/compiler%2Frustc_interface%2Fsrc%2Finterface.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Finterface.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -186,6 +186,8 @@ pub struct Config {\n }\n \n pub fn create_compiler_and_run<R>(config: Config, f: impl FnOnce(&Compiler) -> R) -> R {\n+    crate::callbacks::setup_callbacks();\n+\n     let registry = &config.registry;\n     let (mut sess, codegen_backend) = util::create_session(\n         config.opts,\n@@ -238,7 +240,7 @@ pub fn create_compiler_and_run<R>(config: Config, f: impl FnOnce(&Compiler) -> R\n pub fn run_compiler<R: Send>(mut config: Config, f: impl FnOnce(&Compiler) -> R + Send) -> R {\n     tracing::trace!(\"run_compiler\");\n     let stderr = config.stderr.take();\n-    util::setup_callbacks_and_run_in_thread_pool_with_globals(\n+    util::run_in_thread_pool_with_globals(\n         config.opts.edition,\n         config.opts.debugging_opts.threads,\n         &stderr,"}, {"sha": "dcad3036cc24d3af834d54eb4d927a89a63b0aa8", "filename": "compiler/rustc_interface/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/compiler%2Frustc_interface%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/compiler%2Frustc_interface%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Flib.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -15,6 +15,7 @@ mod proc_macro_decls;\n mod queries;\n pub mod util;\n \n+pub use callbacks::setup_callbacks;\n pub use interface::{run_compiler, Config};\n pub use passes::{DEFAULT_EXTERN_QUERY_PROVIDERS, DEFAULT_QUERY_PROVIDERS};\n pub use queries::Queries;"}, {"sha": "d206f2644e02a4ae3ac757b1594e8e87f2427f17", "filename": "compiler/rustc_interface/src/util.rs", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/compiler%2Frustc_interface%2Fsrc%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_interface%2Fsrc%2Futil.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -128,7 +128,7 @@ fn scoped_thread<F: FnOnce() -> R + Send, R: Send>(cfg: thread::Builder, f: F) -\n }\n \n #[cfg(not(parallel_compiler))]\n-pub fn setup_callbacks_and_run_in_thread_pool_with_globals<F: FnOnce() -> R + Send, R: Send>(\n+pub fn run_in_thread_pool_with_globals<F: FnOnce() -> R + Send, R: Send>(\n     edition: Edition,\n     _threads: usize,\n     stderr: &Option<Arc<Mutex<Vec<u8>>>>,\n@@ -140,8 +140,6 @@ pub fn setup_callbacks_and_run_in_thread_pool_with_globals<F: FnOnce() -> R + Se\n         cfg = cfg.stack_size(size);\n     }\n \n-    crate::callbacks::setup_callbacks();\n-\n     let main_handler = move || {\n         rustc_span::create_session_globals_then(edition, || {\n             io::set_output_capture(stderr.clone());\n@@ -176,14 +174,12 @@ unsafe fn handle_deadlock() {\n }\n \n #[cfg(parallel_compiler)]\n-pub fn setup_callbacks_and_run_in_thread_pool_with_globals<F: FnOnce() -> R + Send, R: Send>(\n+pub fn run_in_thread_pool_with_globals<F: FnOnce() -> R + Send, R: Send>(\n     edition: Edition,\n     threads: usize,\n     stderr: &Option<Arc<Mutex<Vec<u8>>>>,\n     f: F,\n ) -> R {\n-    crate::callbacks::setup_callbacks();\n-\n     let mut config = rayon::ThreadPoolBuilder::new()\n         .thread_name(|_| \"rustc\".to_string())\n         .acquire_thread_handler(jobserver::acquire_thread)"}, {"sha": "4efe3640dfac62b7e63a44104ed4fea89ebf84f5", "filename": "compiler/rustc_middle/src/infer/canonical.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -64,9 +64,9 @@ pub struct CanonicalVarValues<'tcx> {\n /// result.\n #[derive(Clone, Debug)]\n pub struct OriginalQueryValues<'tcx> {\n-    /// Map from the universes that appear in the query to the\n-    /// universes in the caller context. For the time being, we only\n-    /// ever put ROOT values into the query, so this map is very\n+    /// Map from the universes that appear in the query to the universes in the\n+    /// caller context. For all queries except `evaluate_goal` (used by Chalk),\n+    /// we only ever put ROOT values into the query, so this map is very\n     /// simple.\n     pub universe_map: SmallVec<[ty::UniverseIndex; 4]>,\n "}, {"sha": "3ce9f852c3d0fd9b68ddfb46e9c1ebeabdb387cc", "filename": "compiler/rustc_span/src/lib.rs", "status": "modified", "additions": 12, "deletions": 26, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/compiler%2Frustc_span%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/compiler%2Frustc_span%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Flib.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -1013,37 +1013,25 @@ pub fn with_source_map<T, F: FnOnce() -> T>(source_map: Lrc<SourceMap>, f: F) ->\n     f()\n }\n \n-pub fn debug_with_source_map(\n-    span: Span,\n-    f: &mut fmt::Formatter<'_>,\n-    source_map: &SourceMap,\n-) -> fmt::Result {\n-    write!(f, \"{} ({:?})\", source_map.span_to_diagnostic_string(span), span.ctxt())\n-}\n-\n-pub fn default_span_debug(span: Span, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-    with_session_globals(|session_globals| {\n-        if let Some(source_map) = &*session_globals.source_map.borrow() {\n-            debug_with_source_map(span, f, source_map)\n-        } else {\n-            f.debug_struct(\"Span\")\n-                .field(\"lo\", &span.lo())\n-                .field(\"hi\", &span.hi())\n-                .field(\"ctxt\", &span.ctxt())\n-                .finish()\n-        }\n-    })\n-}\n-\n impl fmt::Debug for Span {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        (*SPAN_DEBUG)(*self, f)\n+        with_session_globals(|session_globals| {\n+            if let Some(source_map) = &*session_globals.source_map.borrow() {\n+                write!(f, \"{} ({:?})\", source_map.span_to_diagnostic_string(*self), self.ctxt())\n+            } else {\n+                f.debug_struct(\"Span\")\n+                    .field(\"lo\", &self.lo())\n+                    .field(\"hi\", &self.hi())\n+                    .field(\"ctxt\", &self.ctxt())\n+                    .finish()\n+            }\n+        })\n     }\n }\n \n impl fmt::Debug for SpanData {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        (*SPAN_DEBUG)(Span::new(self.lo, self.hi, self.ctxt, self.parent), f)\n+        fmt::Debug::fmt(&Span::new(self.lo, self.hi, self.ctxt, self.parent), f)\n     }\n }\n \n@@ -2003,8 +1991,6 @@ pub struct FileLines {\n     pub lines: Vec<LineInfo>,\n }\n \n-pub static SPAN_DEBUG: AtomicRef<fn(Span, &mut fmt::Formatter<'_>) -> fmt::Result> =\n-    AtomicRef::new(&(default_span_debug as fn(_, &mut fmt::Formatter<'_>) -> _));\n pub static SPAN_TRACK: AtomicRef<fn(LocalDefId)> = AtomicRef::new(&((|_| {}) as fn(_)));\n \n // _____________________________________________________________________________"}, {"sha": "2e4515022636639ff158255341df74ff35290fff", "filename": "compiler/rustc_span/src/symbol.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_span%2Fsrc%2Fsymbol.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -184,6 +184,7 @@ symbols! {\n         Formatter,\n         From,\n         FromIterator,\n+        FromResidual,\n         Future,\n         FxHashMap,\n         FxHashSet,"}, {"sha": "93c2f202545f604fbc706073f1b47395182336bf", "filename": "compiler/rustc_trait_selection/src/traits/chalk_fulfill.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fchalk_fulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fchalk_fulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fchalk_fulfill.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -8,7 +8,7 @@ use crate::traits::{\n     PredicateObligation, SelectionError, TraitEngine,\n };\n use rustc_data_structures::fx::{FxHashMap, FxIndexSet};\n-use rustc_middle::ty::{self, Ty};\n+use rustc_middle::ty::{self, Ty, TypeFoldable};\n \n pub struct FulfillmentContext<'tcx> {\n     obligations: FxIndexSet<PredicateObligation<'tcx>>,\n@@ -91,7 +91,12 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentContext<'tcx> {\n                 let environment = obligation.param_env.caller_bounds();\n                 let goal = ChalkEnvironmentAndGoal { environment, goal: obligation.predicate };\n                 let mut orig_values = OriginalQueryValues::default();\n-                let canonical_goal = infcx.canonicalize_query(goal, &mut orig_values);\n+                if goal.references_error() {\n+                    continue;\n+                }\n+\n+                let canonical_goal =\n+                    infcx.canonicalize_query_preserving_universes(goal, &mut orig_values);\n \n                 match infcx.tcx.evaluate_goal(canonical_goal) {\n                     Ok(response) => {"}, {"sha": "0170ab223b0312c33041965d82303646c41d0c91", "filename": "compiler/rustc_traits/src/chalk/db.rs", "status": "modified", "additions": 6, "deletions": 26, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -20,11 +20,10 @@ use rustc_span::symbol::sym;\n use std::fmt;\n use std::sync::Arc;\n \n-use crate::chalk::lowering::{self, LowerInto};\n+use crate::chalk::lowering::LowerInto;\n \n pub struct RustIrDatabase<'tcx> {\n     pub(crate) interner: RustInterner<'tcx>,\n-    pub(crate) reempty_placeholder: ty::Region<'tcx>,\n }\n \n impl fmt::Debug for RustIrDatabase<'_> {\n@@ -40,12 +39,9 @@ impl<'tcx> RustIrDatabase<'tcx> {\n         bound_vars: SubstsRef<'tcx>,\n     ) -> Vec<chalk_ir::QuantifiedWhereClause<RustInterner<'tcx>>> {\n         let predicates = self.interner.tcx.predicates_defined_on(def_id).predicates;\n-        let mut regions_substitutor =\n-            lowering::RegionsSubstitutor::new(self.interner.tcx, self.reempty_placeholder);\n         predicates\n             .iter()\n             .map(|(wc, _)| wc.subst(self.interner.tcx, bound_vars))\n-            .map(|wc| wc.fold_with(&mut regions_substitutor))\n             .filter_map(|wc| LowerInto::<\n                     Option<chalk_ir::QuantifiedWhereClause<RustInterner<'tcx>>>\n                     >::lower_into(wc, self.interner)).collect()\n@@ -287,9 +283,6 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n \n         let trait_ref = self.interner.tcx.impl_trait_ref(def_id).expect(\"not an impl\");\n         let trait_ref = trait_ref.subst(self.interner.tcx, bound_vars);\n-        let mut regions_substitutor =\n-            lowering::RegionsSubstitutor::new(self.interner.tcx, self.reempty_placeholder);\n-        let trait_ref = trait_ref.fold_with(&mut regions_substitutor);\n \n         let where_clauses = self.where_clauses_for(def_id, bound_vars);\n \n@@ -335,9 +328,6 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n \n             let self_ty = trait_ref.self_ty();\n             let self_ty = self_ty.subst(self.interner.tcx, bound_vars);\n-            let mut regions_substitutor =\n-                lowering::RegionsSubstitutor::new(self.interner.tcx, self.reempty_placeholder);\n-            let self_ty = self_ty.fold_with(&mut regions_substitutor);\n             let lowered_ty = self_ty.lower_into(self.interner);\n \n             parameters[0].assert_ty_ref(self.interner).could_match(\n@@ -556,11 +546,11 @@ impl<'tcx> chalk_solve::RustIrDatabase<RustInterner<'tcx>> for RustIrDatabase<'t\n             Fn => lang_items.fn_trait(),\n             FnMut => lang_items.fn_mut_trait(),\n             FnOnce => lang_items.fn_once_trait(),\n+            Generator => lang_items.gen_trait(),\n             Unsize => lang_items.unsize_trait(),\n             Unpin => lang_items.unpin_trait(),\n             CoerceUnsized => lang_items.coerce_unsized_trait(),\n             DiscriminantKind => lang_items.discriminant_kind_trait(),\n-            Generator => lang_items.generator_return(),\n         };\n         def_id.map(chalk_ir::TraitId)\n     }\n@@ -684,28 +674,18 @@ impl<'tcx> chalk_ir::UnificationDatabase<RustInterner<'tcx>> for RustIrDatabase<\n         let variances = self.interner.tcx.variances_of(def_id.0);\n         chalk_ir::Variances::from_iter(\n             self.interner,\n-            variances.iter().map(|v| match v {\n-                ty::Variance::Invariant => chalk_ir::Variance::Invariant,\n-                ty::Variance::Covariant => chalk_ir::Variance::Covariant,\n-                ty::Variance::Contravariant => chalk_ir::Variance::Contravariant,\n-                ty::Variance::Bivariant => unimplemented!(),\n-            }),\n+            variances.iter().map(|v| v.lower_into(self.interner)),\n         )\n     }\n \n     fn adt_variance(\n         &self,\n-        def_id: chalk_ir::AdtId<RustInterner<'tcx>>,\n+        adt_id: chalk_ir::AdtId<RustInterner<'tcx>>,\n     ) -> chalk_ir::Variances<RustInterner<'tcx>> {\n-        let variances = self.interner.tcx.variances_of(def_id.0.did);\n+        let variances = self.interner.tcx.variances_of(adt_id.0.did);\n         chalk_ir::Variances::from_iter(\n             self.interner,\n-            variances.iter().map(|v| match v {\n-                ty::Variance::Invariant => chalk_ir::Variance::Invariant,\n-                ty::Variance::Covariant => chalk_ir::Variance::Covariant,\n-                ty::Variance::Contravariant => chalk_ir::Variance::Contravariant,\n-                ty::Variance::Bivariant => unimplemented!(),\n-            }),\n+            variances.iter().map(|v| v.lower_into(self.interner)),\n         )\n     }\n }"}, {"sha": "6f143c1c607b32adc9702e545b114c5cb47002ab", "filename": "compiler/rustc_traits/src/chalk/lowering.rs", "status": "modified", "additions": 62, "deletions": 44, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -188,12 +188,18 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::GoalData<RustInterner<'tcx>>> for ty::Predi\n                 chalk_ir::DomainGoal::ObjectSafe(chalk_ir::TraitId(t)),\n             ),\n \n+            ty::PredicateKind::Subtype(ty::SubtypePredicate { a, b, a_is_expected: _ }) => {\n+                chalk_ir::GoalData::SubtypeGoal(chalk_ir::SubtypeGoal {\n+                    a: a.lower_into(interner),\n+                    b: b.lower_into(interner),\n+                })\n+            }\n+\n             // FIXME(chalk): other predicates\n             //\n             // We can defer this, but ultimately we'll want to express\n             // some of these in terms of chalk operations.\n             ty::PredicateKind::ClosureKind(..)\n-            | ty::PredicateKind::Subtype(..)\n             | ty::PredicateKind::Coerce(..)\n             | ty::PredicateKind::ConstEvaluatable(..)\n             | ty::PredicateKind::ConstEquate(..) => {\n@@ -464,9 +470,11 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::Lifetime<RustInterner<'tcx>>> for Region<'t\n                 })\n                 .intern(interner)\n             }\n-            ReEmpty(_) => unimplemented!(),\n-            // FIXME(chalk): need to handle ReErased\n-            ReErased => unimplemented!(),\n+            ReEmpty(ui) => {\n+                chalk_ir::LifetimeData::Empty(chalk_ir::UniverseIndex { counter: ui.index() })\n+                    .intern(interner)\n+            }\n+            ReErased => chalk_ir::LifetimeData::Erased.intern(interner),\n         }\n     }\n }\n@@ -488,12 +496,12 @@ impl<'tcx> LowerInto<'tcx, Region<'tcx>> for &chalk_ir::Lifetime<RustInterner<'t\n                     name: ty::BoundRegionKind::BrAnon(p.idx as u32),\n                 })\n             }\n-            chalk_ir::LifetimeData::Static => ty::RegionKind::ReStatic,\n-            chalk_ir::LifetimeData::Phantom(_, _) => unimplemented!(),\n+            chalk_ir::LifetimeData::Static => return interner.tcx.lifetimes.re_static,\n             chalk_ir::LifetimeData::Empty(ui) => {\n-                ty::RegionKind::ReEmpty(ty::UniverseIndex::from_usize(ui.counter))\n+                ty::ReEmpty(ty::UniverseIndex::from_usize(ui.counter))\n             }\n-            chalk_ir::LifetimeData::Erased => ty::RegionKind::ReErased,\n+            chalk_ir::LifetimeData::Erased => return interner.tcx.lifetimes.re_erased,\n+            chalk_ir::LifetimeData::Phantom(void, _) => match *void {},\n         };\n         interner.tcx.mk_region(kind)\n     }\n@@ -788,6 +796,16 @@ impl<'tcx> LowerInto<'tcx, chalk_solve::rust_ir::Polarity> for ty::ImplPolarity\n         }\n     }\n }\n+impl<'tcx> LowerInto<'tcx, chalk_ir::Variance> for ty::Variance {\n+    fn lower_into(self, _interner: RustInterner<'tcx>) -> chalk_ir::Variance {\n+        match self {\n+            ty::Variance::Covariant => chalk_ir::Variance::Covariant,\n+            ty::Variance::Invariant => chalk_ir::Variance::Invariant,\n+            ty::Variance::Contravariant => chalk_ir::Variance::Contravariant,\n+            ty::Variance::Bivariant => unimplemented!(),\n+        }\n+    }\n+}\n \n impl<'tcx> LowerInto<'tcx, chalk_solve::rust_ir::AliasEqBound<RustInterner<'tcx>>>\n     for ty::ProjectionPredicate<'tcx>\n@@ -1016,10 +1034,6 @@ impl<'tcx> TypeFolder<'tcx> for ParamsSubstitutor<'tcx> {\n \n     fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n         match *t.kind() {\n-            // FIXME(chalk): currently we convert params to placeholders starting at\n-            // index `0`. To support placeholders, we'll actually need to do a\n-            // first pass to collect placeholders. Then we can insert params after.\n-            ty::Placeholder(_) => unimplemented!(),\n             ty::Param(param) => match self.list.iter().position(|r| r == &param) {\n                 Some(idx) => self.tcx.mk_ty(ty::Placeholder(ty::PlaceholderType {\n                     universe: ty::UniverseIndex::from_usize(0),\n@@ -1035,15 +1049,15 @@ impl<'tcx> TypeFolder<'tcx> for ParamsSubstitutor<'tcx> {\n                     }))\n                 }\n             },\n-\n             _ => t.super_fold_with(self),\n         }\n     }\n \n     fn fold_region(&mut self, r: Region<'tcx>) -> Region<'tcx> {\n         match r {\n-            // FIXME(chalk) - jackh726 - this currently isn't hit in any tests.\n-            // This covers any region variables in a goal, right?\n+            // FIXME(chalk) - jackh726 - this currently isn't hit in any tests,\n+            // since canonicalization will already change these to canonical\n+            // variables (ty::ReLateBound).\n             ty::ReEarlyBound(_re) => match self.named_regions.get(&_re.def_id) {\n                 Some(idx) => {\n                     let br = ty::BoundRegion {\n@@ -1066,6 +1080,39 @@ impl<'tcx> TypeFolder<'tcx> for ParamsSubstitutor<'tcx> {\n     }\n }\n \n+crate struct ReverseParamsSubstitutor<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    params: rustc_data_structures::fx::FxHashMap<usize, rustc_middle::ty::ParamTy>,\n+}\n+\n+impl<'tcx> ReverseParamsSubstitutor<'tcx> {\n+    crate fn new(\n+        tcx: TyCtxt<'tcx>,\n+        params: rustc_data_structures::fx::FxHashMap<usize, rustc_middle::ty::ParamTy>,\n+    ) -> Self {\n+        Self { tcx, params }\n+    }\n+}\n+\n+impl<'tcx> TypeFolder<'tcx> for ReverseParamsSubstitutor<'tcx> {\n+    fn tcx<'b>(&'b self) -> TyCtxt<'tcx> {\n+        self.tcx\n+    }\n+\n+    fn fold_ty(&mut self, t: Ty<'tcx>) -> Ty<'tcx> {\n+        match *t.kind() {\n+            ty::Placeholder(ty::PlaceholderType { universe: ty::UniverseIndex::ROOT, name }) => {\n+                match self.params.get(&name.as_usize()) {\n+                    Some(param) => self.tcx.mk_ty(ty::Param(*param)),\n+                    None => t,\n+                }\n+            }\n+\n+            _ => t.super_fold_with(self),\n+        }\n+    }\n+}\n+\n /// Used to collect `Placeholder`s.\n crate struct PlaceholdersCollector {\n     universe_index: ty::UniverseIndex,\n@@ -1110,32 +1157,3 @@ impl<'tcx> TypeVisitor<'tcx> for PlaceholdersCollector {\n         r.super_visit_with(self)\n     }\n }\n-\n-/// Used to substitute specific `Regions`s with placeholders.\n-crate struct RegionsSubstitutor<'tcx> {\n-    tcx: TyCtxt<'tcx>,\n-    reempty_placeholder: ty::Region<'tcx>,\n-}\n-\n-impl<'tcx> RegionsSubstitutor<'tcx> {\n-    crate fn new(tcx: TyCtxt<'tcx>, reempty_placeholder: ty::Region<'tcx>) -> Self {\n-        RegionsSubstitutor { tcx, reempty_placeholder }\n-    }\n-}\n-\n-impl<'tcx> TypeFolder<'tcx> for RegionsSubstitutor<'tcx> {\n-    fn tcx<'b>(&'b self) -> TyCtxt<'tcx> {\n-        self.tcx\n-    }\n-\n-    fn fold_region(&mut self, r: Region<'tcx>) -> Region<'tcx> {\n-        match r {\n-            ty::ReEmpty(ui) => {\n-                assert_eq!(ui.as_usize(), 0);\n-                self.reempty_placeholder\n-            }\n-\n-            _ => r.super_fold_with(self),\n-        }\n-    }\n-}"}, {"sha": "3c2a266dab9bcf996a555c754e4ee480b54cc1e6", "filename": "compiler/rustc_traits/src/chalk/mod.rs", "status": "modified", "additions": 7, "deletions": 15, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fmod.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -22,9 +22,8 @@ use rustc_infer::infer::canonical::{\n use rustc_infer::traits::{self, CanonicalChalkEnvironmentAndGoal};\n \n use crate::chalk::db::RustIrDatabase as ChalkRustIrDatabase;\n-use crate::chalk::lowering::{\n-    LowerInto, ParamsSubstitutor, PlaceholdersCollector, RegionsSubstitutor,\n-};\n+use crate::chalk::lowering::LowerInto;\n+use crate::chalk::lowering::{ParamsSubstitutor, PlaceholdersCollector, ReverseParamsSubstitutor};\n \n use chalk_solve::Solution;\n \n@@ -42,19 +41,10 @@ crate fn evaluate_goal<'tcx>(\n     let mut placeholders_collector = PlaceholdersCollector::new();\n     obligation.visit_with(&mut placeholders_collector);\n \n-    let reempty_placeholder = tcx.mk_region(ty::RegionKind::RePlaceholder(ty::Placeholder {\n-        universe: ty::UniverseIndex::ROOT,\n-        name: ty::BoundRegionKind::BrAnon(placeholders_collector.next_anon_region_placeholder + 1),\n-    }));\n-\n     let mut params_substitutor =\n         ParamsSubstitutor::new(tcx, placeholders_collector.next_ty_placeholder);\n     let obligation = obligation.fold_with(&mut params_substitutor);\n-    // FIXME(chalk): we really should be substituting these back in the solution\n-    let _params: FxHashMap<usize, ParamTy> = params_substitutor.params;\n-\n-    let mut regions_substitutor = RegionsSubstitutor::new(tcx, reempty_placeholder);\n-    let obligation = obligation.fold_with(&mut regions_substitutor);\n+    let params: FxHashMap<usize, ParamTy> = params_substitutor.params;\n \n     let max_universe = obligation.max_universe.index();\n \n@@ -96,7 +86,8 @@ crate fn evaluate_goal<'tcx>(\n \n     use chalk_solve::Solver;\n     let mut solver = chalk_engine::solve::SLGSolver::new(32, None);\n-    let db = ChalkRustIrDatabase { interner, reempty_placeholder };\n+    let db = ChalkRustIrDatabase { interner };\n+    debug!(?lowered_goal);\n     let solution = solver.solve(&db, &lowered_goal);\n     debug!(?obligation, ?solution, \"evaluate goal\");\n \n@@ -110,8 +101,9 @@ crate fn evaluate_goal<'tcx>(\n         use rustc_middle::infer::canonical::CanonicalVarInfo;\n \n         let mut var_values: IndexVec<BoundVar, GenericArg<'tcx>> = IndexVec::new();\n+        let mut reverse_param_substitutor = ReverseParamsSubstitutor::new(tcx, params);\n         subst.as_slice(interner).iter().for_each(|p| {\n-            var_values.push(p.lower_into(interner));\n+            var_values.push(p.lower_into(interner).fold_with(&mut reverse_param_substitutor));\n         });\n         let variables: Vec<_> = binders\n             .iter(interner)"}, {"sha": "ce75859f963f65165f575d0aa59ffe9a61eb868f", "filename": "library/alloc/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/library%2Falloc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/library%2Falloc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Flib.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -112,7 +112,6 @@\n #![feature(extend_one)]\n #![feature(fmt_internals)]\n #![feature(fn_traits)]\n-#![feature(inherent_ascii_escape)]\n #![feature(inplace_iteration)]\n #![feature(iter_advance_by)]\n #![feature(layout_for_ptr)]"}, {"sha": "f0397d08f95a8f4e03875c77c9eed85a197aff5c", "filename": "library/alloc/src/slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/library%2Falloc%2Fsrc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/library%2Falloc%2Fsrc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fslice.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -108,7 +108,7 @@ pub use core::slice::ArrayChunks;\n pub use core::slice::ArrayChunksMut;\n #[unstable(feature = \"array_windows\", issue = \"75027\")]\n pub use core::slice::ArrayWindows;\n-#[unstable(feature = \"inherent_ascii_escape\", issue = \"77174\")]\n+#[stable(feature = \"inherent_ascii_escape\", since = \"1.60.0\")]\n pub use core::slice::EscapeAscii;\n #[stable(feature = \"slice_get_slice\", since = \"1.28.0\")]\n pub use core::slice::SliceIndex;"}, {"sha": "628b679236e1d4d879df4e906fcb79cbb5cb13d2", "filename": "library/core/src/macros/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fmacros%2Fmod.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -872,7 +872,7 @@ pub(crate) mod builtin {\n         ($fmt:expr, $($args:tt)*) => {{ /* compiler built-in */ }};\n     }\n \n-    /// Same as `format_args`, but can be used in some const contexts.\n+    /// Same as [`format_args`], but can be used in some const contexts.\n     ///\n     /// This macro is used by the panic macros for the `const_panic` feature.\n     ///\n@@ -886,7 +886,7 @@ pub(crate) mod builtin {\n         ($fmt:expr, $($args:tt)*) => {{ /* compiler built-in */ }};\n     }\n \n-    /// Same as `format_args`, but adds a newline in the end.\n+    /// Same as [`format_args`], but adds a newline in the end.\n     #[unstable(\n         feature = \"format_args_nl\",\n         issue = \"none\","}, {"sha": "72105888f9447f2eac6c277754d157d38dd0b6c3", "filename": "library/core/src/num/mod.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fmod.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -791,7 +791,6 @@ impl u8 {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(inherent_ascii_escape)]\n     ///\n     /// assert_eq!(\"0\", b'0'.escape_ascii().to_string());\n     /// assert_eq!(\"\\\\t\", b'\\t'.escape_ascii().to_string());\n@@ -804,10 +803,10 @@ impl u8 {\n     /// ```\n     #[must_use = \"this returns the escaped byte as an iterator, \\\n                   without modifying the original\"]\n-    #[unstable(feature = \"inherent_ascii_escape\", issue = \"77174\")]\n+    #[stable(feature = \"inherent_ascii_escape\", since = \"1.60.0\")]\n     #[inline]\n-    pub fn escape_ascii(&self) -> ascii::EscapeDefault {\n-        ascii::escape_default(*self)\n+    pub fn escape_ascii(self) -> ascii::EscapeDefault {\n+        ascii::escape_default(self)\n     }\n \n     pub(crate) fn is_utf8_char_boundary(self) -> bool {"}, {"sha": "ba369e7f3aaa0a2af92477588d6e36e4500405d7", "filename": "library/core/src/ops/try_trait.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/library%2Fcore%2Fsrc%2Fops%2Ftry_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/library%2Fcore%2Fsrc%2Fops%2Ftry_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fops%2Ftry_trait.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -302,6 +302,7 @@ pub trait Try: FromResidual {\n         enclosing_scope = \"this function should return `Result` or `Option` to accept `?`\"\n     ),\n )]\n+#[rustc_diagnostic_item = \"FromResidual\"]\n #[unstable(feature = \"try_trait_v2\", issue = \"84277\")]\n pub trait FromResidual<R = <Self as Try>::Residual> {\n     /// Constructs the type from a compatible `Residual` type."}, {"sha": "508837f63c3bee8d7bad27fc71c02b68f8f36e9b", "filename": "library/core/src/option.rs", "status": "modified", "additions": 18, "deletions": 6, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/library%2Fcore%2Fsrc%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/library%2Fcore%2Fsrc%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Foption.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -1207,13 +1207,25 @@ impl<T> Option<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// fn sq(x: u32) -> Option<u32> { Some(x * x) }\n-    /// fn nope(_: u32) -> Option<u32> { None }\n+    /// fn sq_then_to_string(x: u32) -> Option<String> {\n+    ///     x.checked_mul(x).map(|sq| sq.to_string())\n+    /// }\n+    ///\n+    /// assert_eq!(Some(2).and_then(sq_then_to_string), Some(4.to_string()));\n+    /// assert_eq!(Some(1_000_000).and_then(sq_then_to_string), None); // overflowed!\n+    /// assert_eq!(None.and_then(sq_then_to_string), None);\n+    /// ```\n+    ///\n+    /// Often used to chain fallible operations that may return [`None`].\n+    ///\n+    /// ```\n+    /// let arr_2d = [[\"A0\", \"A1\"], [\"B0\", \"B1\"]];\n+    ///\n+    /// let item_0_1 = arr_2d.get(0).and_then(|row| row.get(1));\n+    /// assert_eq!(item_0_1, Some(&\"A1\"));\n     ///\n-    /// assert_eq!(Some(2).and_then(sq).and_then(sq), Some(16));\n-    /// assert_eq!(Some(2).and_then(sq).and_then(nope), None);\n-    /// assert_eq!(Some(2).and_then(nope).and_then(sq), None);\n-    /// assert_eq!(None.and_then(sq).and_then(sq), None);\n+    /// let item_2_0 = arr_2d.get(2).and_then(|row| row.get(0));\n+    /// assert_eq!(item_2_0, None);\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "801e3a0b3a4ccaf34038d70ed286bd3185d7802f", "filename": "library/core/src/result.rs", "status": "modified", "additions": 19, "deletions": 7, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/library%2Fcore%2Fsrc%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/library%2Fcore%2Fsrc%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fresult.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -1281,16 +1281,28 @@ impl<T, E> Result<T, E> {\n     ///\n     /// # Examples\n     ///\n-    /// Basic usage:\n+    /// ```\n+    /// fn sq_then_to_string(x: u32) -> Result<String, &'static str> {\n+    ///     x.checked_mul(x).map(|sq| sq.to_string()).ok_or(\"overflowed\")\n+    /// }\n     ///\n+    /// assert_eq!(Ok(2).and_then(sq_then_to_string), Ok(4.to_string()));\n+    /// assert_eq!(Ok(1_000_000).and_then(sq_then_to_string), Err(\"overflowed\"));\n+    /// assert_eq!(Err(\"not a number\").and_then(sq_then_to_string), Err(\"not a number\"));\n     /// ```\n-    /// fn sq(x: u32) -> Result<u32, u32> { Ok(x * x) }\n-    /// fn err(x: u32) -> Result<u32, u32> { Err(x) }\n     ///\n-    /// assert_eq!(Ok(2).and_then(sq).and_then(sq), Ok(16));\n-    /// assert_eq!(Ok(2).and_then(sq).and_then(err), Err(4));\n-    /// assert_eq!(Ok(2).and_then(err).and_then(sq), Err(2));\n-    /// assert_eq!(Err(3).and_then(sq).and_then(sq), Err(3));\n+    /// Often used to chain fallible operations that may return [`Err`].\n+    ///\n+    /// ```\n+    /// use std::{io::ErrorKind, path::Path};\n+    ///\n+    /// // Note: on Windows \"/\" maps to \"C:\\\"\n+    /// let root_modified_time = Path::new(\"/\").metadata().and_then(|md| md.modified());\n+    /// assert!(root_modified_time.is_ok());\n+    ///\n+    /// let should_fail = Path::new(\"/bad/path\").metadata().and_then(|md| md.modified());\n+    /// assert!(should_fail.is_err());\n+    /// assert_eq!(should_fail.unwrap_err().kind(), ErrorKind::NotFound);\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "304ba7ee5544f9abf264751ba7320372fb470368", "filename": "library/core/src/slice/ascii.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/library%2Fcore%2Fsrc%2Fslice%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/library%2Fcore%2Fsrc%2Fslice%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fascii.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -68,15 +68,14 @@ impl [u8] {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(inherent_ascii_escape)]\n     ///\n     /// let s = b\"0\\t\\r\\n'\\\"\\\\\\x9d\";\n     /// let escaped = s.escape_ascii().to_string();\n     /// assert_eq!(escaped, \"0\\\\t\\\\r\\\\n\\\\'\\\\\\\"\\\\\\\\\\\\x9d\");\n     /// ```\n     #[must_use = \"this returns the escaped bytes as an iterator, \\\n                   without modifying the original\"]\n-    #[unstable(feature = \"inherent_ascii_escape\", issue = \"77174\")]\n+    #[stable(feature = \"inherent_ascii_escape\", since = \"1.60.0\")]\n     pub fn escape_ascii(&self) -> EscapeAscii<'_> {\n         EscapeAscii { inner: self.iter().flat_map(EscapeByte) }\n     }\n@@ -93,13 +92,13 @@ impl_fn_for_zst! {\n ///\n /// This `struct` is created by the [`slice::escape_ascii`] method. See its\n /// documentation for more information.\n-#[unstable(feature = \"inherent_ascii_escape\", issue = \"77174\")]\n+#[stable(feature = \"inherent_ascii_escape\", since = \"1.60.0\")]\n #[derive(Clone)]\n pub struct EscapeAscii<'a> {\n     inner: iter::FlatMap<super::Iter<'a, u8>, ascii::EscapeDefault, EscapeByte>,\n }\n \n-#[unstable(feature = \"inherent_ascii_escape\", issue = \"77174\")]\n+#[stable(feature = \"inherent_ascii_escape\", since = \"1.60.0\")]\n impl<'a> iter::Iterator for EscapeAscii<'a> {\n     type Item = u8;\n     #[inline]\n@@ -131,23 +130,23 @@ impl<'a> iter::Iterator for EscapeAscii<'a> {\n     }\n }\n \n-#[unstable(feature = \"inherent_ascii_escape\", issue = \"77174\")]\n+#[stable(feature = \"inherent_ascii_escape\", since = \"1.60.0\")]\n impl<'a> iter::DoubleEndedIterator for EscapeAscii<'a> {\n     fn next_back(&mut self) -> Option<u8> {\n         self.inner.next_back()\n     }\n }\n-#[unstable(feature = \"inherent_ascii_escape\", issue = \"77174\")]\n+#[stable(feature = \"inherent_ascii_escape\", since = \"1.60.0\")]\n impl<'a> iter::ExactSizeIterator for EscapeAscii<'a> {}\n-#[unstable(feature = \"inherent_ascii_escape\", issue = \"77174\")]\n+#[stable(feature = \"inherent_ascii_escape\", since = \"1.60.0\")]\n impl<'a> iter::FusedIterator for EscapeAscii<'a> {}\n-#[unstable(feature = \"inherent_ascii_escape\", issue = \"77174\")]\n+#[stable(feature = \"inherent_ascii_escape\", since = \"1.60.0\")]\n impl<'a> fmt::Display for EscapeAscii<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         self.clone().try_for_each(|b| f.write_char(b as char))\n     }\n }\n-#[unstable(feature = \"inherent_ascii_escape\", issue = \"77174\")]\n+#[stable(feature = \"inherent_ascii_escape\", since = \"1.60.0\")]\n impl<'a> fmt::Debug for EscapeAscii<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.debug_struct(\"EscapeAscii\").finish_non_exhaustive()"}, {"sha": "cd38c3a75473d4c1393823bb1afab8ef61812654", "filename": "library/core/src/slice/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fmod.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -81,7 +81,7 @@ pub use index::SliceIndex;\n #[unstable(feature = \"slice_range\", issue = \"76393\")]\n pub use index::range;\n \n-#[unstable(feature = \"inherent_ascii_escape\", issue = \"77174\")]\n+#[stable(feature = \"inherent_ascii_escape\", since = \"1.60.0\")]\n pub use ascii::EscapeAscii;\n \n /// Calculates the direction and split point of a one-sided range."}, {"sha": "27173de6307290c6c2edc0d6d45551f0e152b74b", "filename": "library/std/src/sys/hermit/time.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fhermit%2Ftime.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -115,14 +115,6 @@ impl Instant {\n         Instant { t: time }\n     }\n \n-    pub const fn zero() -> Instant {\n-        Instant { t: Timespec::zero() }\n-    }\n-\n-    pub fn actually_monotonic() -> bool {\n-        true\n-    }\n-\n     pub fn checked_sub_instant(&self, other: &Instant) -> Option<Duration> {\n         self.t.sub_timespec(&other.t).ok()\n     }"}, {"sha": "25f13ee441aca60095c9e93ada5808aef5c33952", "filename": "library/std/src/sys/itron/time.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fitron%2Ftime.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -14,15 +14,6 @@ impl Instant {\n         }\n     }\n \n-    pub const fn zero() -> Instant {\n-        Instant(0)\n-    }\n-\n-    pub fn actually_monotonic() -> bool {\n-        // There are ways to change the system time\n-        false\n-    }\n-\n     pub fn checked_sub_instant(&self, other: &Instant) -> Option<Duration> {\n         self.0.checked_sub(other.0).map(|ticks| {\n             // `SYSTIM` is measured in microseconds"}, {"sha": "db4cf2804bf13b111f9eff5bbce46d721bc337f4", "filename": "library/std/src/sys/sgx/time.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fsgx%2Ftime.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -25,14 +25,6 @@ impl Instant {\n     pub fn checked_sub_duration(&self, other: &Duration) -> Option<Instant> {\n         Some(Instant(self.0.checked_sub(*other)?))\n     }\n-\n-    pub fn actually_monotonic() -> bool {\n-        false\n-    }\n-\n-    pub const fn zero() -> Instant {\n-        Instant(Duration::from_secs(0))\n-    }\n }\n \n impl SystemTime {"}, {"sha": "59ddd1aa92f813d91151254fba2d5734ec887b45", "filename": "library/std/src/sys/unix/time.rs", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Ftime.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -154,14 +154,6 @@ mod inner {\n             Instant { t: unsafe { mach_absolute_time() } }\n         }\n \n-        pub const fn zero() -> Instant {\n-            Instant { t: 0 }\n-        }\n-\n-        pub fn actually_monotonic() -> bool {\n-            true\n-        }\n-\n         pub fn checked_sub_instant(&self, other: &Instant) -> Option<Duration> {\n             let diff = self.t.checked_sub(other.t)?;\n             let info = info();\n@@ -296,17 +288,6 @@ mod inner {\n             Instant { t: now(libc::CLOCK_MONOTONIC) }\n         }\n \n-        pub const fn zero() -> Instant {\n-            Instant { t: Timespec::zero() }\n-        }\n-\n-        pub fn actually_monotonic() -> bool {\n-            (cfg!(target_os = \"linux\") && cfg!(target_arch = \"x86_64\"))\n-                || (cfg!(target_os = \"linux\") && cfg!(target_arch = \"x86\"))\n-                || (cfg!(target_os = \"linux\") && cfg!(target_arch = \"aarch64\"))\n-                || cfg!(target_os = \"fuchsia\")\n-        }\n-\n         pub fn checked_sub_instant(&self, other: &Instant) -> Option<Duration> {\n             self.t.sub_timespec(&other.t).ok()\n         }"}, {"sha": "6d67b538a96bf5dfa47f86da629cf3f1736c9e34", "filename": "library/std/src/sys/unsupported/time.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funsupported%2Ftime.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -13,14 +13,6 @@ impl Instant {\n         panic!(\"time not implemented on this platform\")\n     }\n \n-    pub const fn zero() -> Instant {\n-        Instant(Duration::from_secs(0))\n-    }\n-\n-    pub fn actually_monotonic() -> bool {\n-        false\n-    }\n-\n     pub fn checked_sub_instant(&self, other: &Instant) -> Option<Duration> {\n         self.0.checked_sub(other.0)\n     }"}, {"sha": "088585654b948fa2f92a2acefc7e120c3ded648e", "filename": "library/std/src/sys/wasi/time.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwasi%2Ftime.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -25,14 +25,6 @@ impl Instant {\n         Instant(current_time(wasi::CLOCKID_MONOTONIC))\n     }\n \n-    pub const fn zero() -> Instant {\n-        Instant(Duration::from_secs(0))\n-    }\n-\n-    pub fn actually_monotonic() -> bool {\n-        true\n-    }\n-\n     pub fn checked_sub_instant(&self, other: &Instant) -> Option<Duration> {\n         self.0.checked_sub(other.0)\n     }"}, {"sha": "a04908b541cdb58a859eba464d989be62c8ad2df", "filename": "library/std/src/sys/windows/time.rs", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ftime.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -41,14 +41,6 @@ impl Instant {\n         perf_counter::PerformanceCounterInstant::now().into()\n     }\n \n-    pub fn actually_monotonic() -> bool {\n-        false\n-    }\n-\n-    pub const fn zero() -> Instant {\n-        Instant { t: Duration::from_secs(0) }\n-    }\n-\n     pub fn checked_sub_instant(&self, other: &Instant) -> Option<Duration> {\n         // On windows there's a threshold below which we consider two timestamps\n         // equivalent due to measurement error. For more details + doc link,"}, {"sha": "df8a726e64ecb380f13bea12112dc0f03a564336", "filename": "library/std/src/time.rs", "status": "modified", "additions": 54, "deletions": 55, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/library%2Fstd%2Fsrc%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/library%2Fstd%2Fsrc%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ftime.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -31,7 +31,6 @@\n \n #![stable(feature = \"time\", since = \"1.3.0\")]\n \n-mod monotonic;\n #[cfg(test)]\n mod tests;\n \n@@ -50,8 +49,8 @@ pub use core::time::FromFloatSecsError;\n /// A measurement of a monotonically nondecreasing clock.\n /// Opaque and useful only with [`Duration`].\n ///\n-/// Instants are always guaranteed to be no less than any previously measured\n-/// instant when created, and are often useful for tasks such as measuring\n+/// Instants are always guaranteed, barring [platform bugs], to be no less than any previously\n+/// measured instant when created, and are often useful for tasks such as measuring\n /// benchmarks or timing how long an operation takes.\n ///\n /// Note, however, that instants are **not** guaranteed to be **steady**. In other\n@@ -84,6 +83,8 @@ pub use core::time::FromFloatSecsError;\n /// }\n /// ```\n ///\n+/// [platform bugs]: Instant#monotonicity\n+///\n /// # OS-specific behaviors\n ///\n /// An `Instant` is a wrapper around system-specific types and it may behave\n@@ -125,6 +126,26 @@ pub use core::time::FromFloatSecsError;\n /// > structure cannot represent the new point in time.\n ///\n /// [`add`]: Instant::add\n+///\n+/// ## Monotonicity\n+///\n+/// On all platforms `Instant` will try to use an OS API that guarantees monotonic behavior\n+/// if available, which is the case for all [tier 1] platforms.\n+/// In practice such guarantees are \u2013 under rare circumstances \u2013 broken by hardware, virtualization\n+/// or operating system bugs. To work around these bugs and platforms not offering monotonic clocks\n+/// [`duration_since`], [`elapsed`] and [`sub`] saturate to zero. In older Rust versions this\n+/// lead to a panic instead. [`checked_duration_since`] can be used to detect and handle situations\n+/// where monotonicity is violated, or `Instant`s are subtracted in the wrong order.\n+///\n+/// This workaround obscures programming errors where earlier and later instants are accidentally\n+/// swapped. For this reason future rust versions may reintroduce panics.\n+///\n+/// [tier 1]: https://doc.rust-lang.org/rustc/platform-support.html\n+/// [`duration_since`]: Instant::duration_since\n+/// [`elapsed`]: Instant::elapsed\n+/// [`sub`]: Instant::sub\n+/// [`checked_duration_since`]: Instant::checked_duration_since\n+///\n #[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n #[stable(feature = \"time2\", since = \"1.8.0\")]\n pub struct Instant(time::Instant);\n@@ -247,59 +268,19 @@ impl Instant {\n     #[must_use]\n     #[stable(feature = \"time2\", since = \"1.8.0\")]\n     pub fn now() -> Instant {\n-        let os_now = time::Instant::now();\n-\n-        // And here we come upon a sad state of affairs. The whole point of\n-        // `Instant` is that it's monotonically increasing. We've found in the\n-        // wild, however, that it's not actually monotonically increasing for\n-        // one reason or another. These appear to be OS and hardware level bugs,\n-        // and there's not really a whole lot we can do about them. Here's a\n-        // taste of what we've found:\n-        //\n-        // * #48514 - OpenBSD, x86_64\n-        // * #49281 - linux arm64 and s390x\n-        // * #51648 - windows, x86\n-        // * #56560 - windows, x86_64, AWS\n-        // * #56612 - windows, x86, vm (?)\n-        // * #56940 - linux, arm64\n-        // * https://bugzilla.mozilla.org/show_bug.cgi?id=1487778 - a similar\n-        //   Firefox bug\n-        //\n-        // It seems that this just happens a lot in the wild.\n-        // We're seeing panics across various platforms where consecutive calls\n-        // to `Instant::now`, such as via the `elapsed` function, are panicking\n-        // as they're going backwards. Placed here is a last-ditch effort to try\n-        // to fix things up. We keep a global \"latest now\" instance which is\n-        // returned instead of what the OS says if the OS goes backwards.\n-        //\n-        // To hopefully mitigate the impact of this, a few platforms are\n-        // excluded as \"these at least haven't gone backwards yet\".\n-        //\n-        // While issues have been seen on arm64 platforms the Arm architecture\n-        // requires that the counter monotonically increases and that it must\n-        // provide a uniform view of system time (e.g. it must not be possible\n-        // for a core to receive a message from another core with a time stamp\n-        // and observe time going backwards (ARM DDI 0487G.b D11.1.2). While\n-        // there have been a few 64bit SoCs that have bugs which cause time to\n-        // not monoticially increase, these have been fixed in the Linux kernel\n-        // and we shouldn't penalize all Arm SoCs for those who refuse to\n-        // update their kernels:\n-        // SUN50I_ERRATUM_UNKNOWN1 - Allwinner A64 / Pine A64 - fixed in 5.1\n-        // FSL_ERRATUM_A008585 - Freescale LS2080A/LS1043A - fixed in 4.10\n-        // HISILICON_ERRATUM_161010101 - Hisilicon 1610 - fixed in 4.11\n-        // ARM64_ERRATUM_858921 - Cortex A73 - fixed in 4.12\n-        if time::Instant::actually_monotonic() {\n-            return Instant(os_now);\n-        }\n-\n-        Instant(monotonic::monotonize(os_now))\n+        Instant(time::Instant::now())\n     }\n \n-    /// Returns the amount of time elapsed from another instant to this one.\n+    /// Returns the amount of time elapsed from another instant to this one,\n+    /// or zero duration if that instant is later than this one.\n     ///\n     /// # Panics\n     ///\n-    /// This function will panic if `earlier` is later than `self`.\n+    /// Previous rust versions panicked when `earlier` was later than `self`. Currently this\n+    /// method saturates. Future versions may reintroduce the panic in some circumstances.\n+    /// See [Monotonicity].\n+    ///\n+    /// [Monotonicity]: Instant#monotonicity\n     ///\n     /// # Examples\n     ///\n@@ -311,16 +292,22 @@ impl Instant {\n     /// sleep(Duration::new(1, 0));\n     /// let new_now = Instant::now();\n     /// println!(\"{:?}\", new_now.duration_since(now));\n+    /// println!(\"{:?}\", now.duration_since(new_now)); // 0ns\n     /// ```\n     #[must_use]\n     #[stable(feature = \"time2\", since = \"1.8.0\")]\n     pub fn duration_since(&self, earlier: Instant) -> Duration {\n-        self.0.checked_sub_instant(&earlier.0).expect(\"supplied instant is later than self\")\n+        self.checked_duration_since(earlier).unwrap_or_default()\n     }\n \n     /// Returns the amount of time elapsed from another instant to this one,\n     /// or None if that instant is later than this one.\n     ///\n+    /// Due to [monotonicity bugs], even under correct logical ordering of the passed `Instant`s,\n+    /// this method can return `None`.\n+    ///\n+    /// [monotonicity bugs]: Instant#monotonicity\n+    ///\n     /// # Examples\n     ///\n     /// ```no_run\n@@ -364,9 +351,11 @@ impl Instant {\n     ///\n     /// # Panics\n     ///\n-    /// This function may panic if the current time is earlier than this\n-    /// instant, which is something that can happen if an `Instant` is\n-    /// produced synthetically.\n+    /// Previous rust versions panicked when self was earlier than the current time. Currently this\n+    /// method returns a Duration of zero in that case. Future versions may reintroduce the panic.\n+    /// See [Monotonicity].\n+    ///\n+    /// [Monotonicity]: Instant#monotonicity\n     ///\n     /// # Examples\n     ///\n@@ -442,6 +431,16 @@ impl SubAssign<Duration> for Instant {\n impl Sub<Instant> for Instant {\n     type Output = Duration;\n \n+    /// Returns the amount of time elapsed from another instant to this one,\n+    /// or zero duration if that instant is later than this one.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Previous rust versions panicked when `other` was later than `self`. Currently this\n+    /// method saturates. Future versions may reintroduce the panic in some circumstances.\n+    /// See [Monotonicity].\n+    ///\n+    /// [Monotonicity]: Instant#monotonicity\n     fn sub(self, other: Instant) -> Duration {\n         self.duration_since(other)\n     }"}, {"sha": "64f16245c2b1643f902afe8b0b3e67dc1402a5b9", "filename": "library/std/src/time/monotonic.rs", "status": "removed", "additions": 0, "deletions": 116, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/3fe229902ecaf1017c931df6ad24cc9d968d8f03/library%2Fstd%2Fsrc%2Ftime%2Fmonotonic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3fe229902ecaf1017c931df6ad24cc9d968d8f03/library%2Fstd%2Fsrc%2Ftime%2Fmonotonic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ftime%2Fmonotonic.rs?ref=3fe229902ecaf1017c931df6ad24cc9d968d8f03", "patch": "@@ -1,116 +0,0 @@\n-use crate::sys::time;\n-\n-#[inline]\n-pub(super) fn monotonize(raw: time::Instant) -> time::Instant {\n-    inner::monotonize(raw)\n-}\n-\n-#[cfg(any(all(target_has_atomic = \"64\", not(target_has_atomic = \"128\")), target_arch = \"aarch64\"))]\n-pub mod inner {\n-    use crate::sync::atomic::AtomicU64;\n-    use crate::sync::atomic::Ordering::*;\n-    use crate::sys::time;\n-    use crate::time::Duration;\n-\n-    pub(in crate::time) const ZERO: time::Instant = time::Instant::zero();\n-\n-    // bits 30 and 31 are never used since the nanoseconds part never exceeds 10^9\n-    const UNINITIALIZED: u64 = 0b11 << 30;\n-    static MONO: AtomicU64 = AtomicU64::new(UNINITIALIZED);\n-\n-    #[inline]\n-    pub(super) fn monotonize(raw: time::Instant) -> time::Instant {\n-        monotonize_impl(&MONO, raw)\n-    }\n-\n-    #[inline]\n-    pub(in crate::time) fn monotonize_impl(mono: &AtomicU64, raw: time::Instant) -> time::Instant {\n-        let delta = raw.checked_sub_instant(&ZERO).unwrap();\n-        let secs = delta.as_secs();\n-        // occupies no more than 30 bits (10^9 seconds)\n-        let nanos = delta.subsec_nanos() as u64;\n-\n-        // This wraps around every 136 years (2^32 seconds).\n-        // To detect backsliding we use wrapping arithmetic and declare forward steps smaller\n-        // than 2^31 seconds as expected and everything else as a backslide which will be\n-        // monotonized.\n-        // This could be a problem for programs that call instants at intervals greater\n-        // than 68 years. Interstellar probes may want to ensure that actually_monotonic() is true.\n-        let packed = (secs << 32) | nanos;\n-        let updated = mono.fetch_update(Relaxed, Relaxed, |old| {\n-            (old == UNINITIALIZED || packed.wrapping_sub(old) < u64::MAX / 2).then_some(packed)\n-        });\n-        match updated {\n-            Ok(_) => raw,\n-            Err(newer) => {\n-                // Backslide occurred. We reconstruct monotonized time from the upper 32 bit of the\n-                // passed in value and the 64bits loaded from the atomic\n-                let seconds_lower = newer >> 32;\n-                let mut seconds_upper = secs & 0xffff_ffff_0000_0000;\n-                if secs & 0xffff_ffff > seconds_lower {\n-                    // Backslide caused the lower 32bit of the seconds part to wrap.\n-                    // This must be the case because the seconds part is larger even though\n-                    // we are in the backslide branch, i.e. the seconds count should be smaller or equal.\n-                    //\n-                    // We assume that backslides are smaller than 2^32 seconds\n-                    // which means we need to add 1 to the upper half to restore it.\n-                    //\n-                    // Example:\n-                    // most recent observed time: 0xA1_0000_0000_0000_0000u128\n-                    // bits stored in AtomicU64:     0x0000_0000_0000_0000u64\n-                    // backslide by 1s\n-                    // caller time is             0xA0_ffff_ffff_0000_0000u128\n-                    // -> we can fix up the upper half time by adding 1 << 32\n-                    seconds_upper = seconds_upper.wrapping_add(0x1_0000_0000);\n-                }\n-                let secs = seconds_upper | seconds_lower;\n-                let nanos = newer as u32;\n-                ZERO.checked_add_duration(&Duration::new(secs, nanos)).unwrap()\n-            }\n-        }\n-    }\n-}\n-\n-#[cfg(all(target_has_atomic = \"128\", not(target_arch = \"aarch64\")))]\n-pub mod inner {\n-    use crate::sync::atomic::AtomicU128;\n-    use crate::sync::atomic::Ordering::*;\n-    use crate::sys::time;\n-    use crate::time::Duration;\n-\n-    const ZERO: time::Instant = time::Instant::zero();\n-    static MONO: AtomicU128 = AtomicU128::new(0);\n-\n-    #[inline]\n-    pub(super) fn monotonize(raw: time::Instant) -> time::Instant {\n-        let delta = raw.checked_sub_instant(&ZERO).unwrap();\n-        // Split into seconds and nanos since Duration doesn't have a\n-        // constructor that takes a u128\n-        let secs = delta.as_secs() as u128;\n-        let nanos = delta.subsec_nanos() as u128;\n-        let timestamp: u128 = secs << 64 | nanos;\n-        let timestamp = MONO.fetch_max(timestamp, Relaxed).max(timestamp);\n-        let secs = (timestamp >> 64) as u64;\n-        let nanos = timestamp as u32;\n-        ZERO.checked_add_duration(&Duration::new(secs, nanos)).unwrap()\n-    }\n-}\n-\n-#[cfg(not(any(target_has_atomic = \"64\", target_has_atomic = \"128\")))]\n-pub mod inner {\n-    use crate::cmp;\n-    use crate::sys::time;\n-    use crate::sys_common::mutex::StaticMutex;\n-\n-    #[inline]\n-    pub(super) fn monotonize(os_now: time::Instant) -> time::Instant {\n-        static LOCK: StaticMutex = StaticMutex::new();\n-        static mut LAST_NOW: time::Instant = time::Instant::zero();\n-        unsafe {\n-            let _lock = LOCK.lock();\n-            let now = cmp::max(LAST_NOW, os_now);\n-            LAST_NOW = now;\n-            now\n-        }\n-    }\n-}"}, {"sha": "d1a69ff8697c654422b31191a0b5e878fcc828fb", "filename": "library/std/src/time/tests.rs", "status": "modified", "additions": 3, "deletions": 28, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/library%2Fstd%2Fsrc%2Ftime%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/library%2Fstd%2Fsrc%2Ftime%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ftime%2Ftests.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -90,10 +90,9 @@ fn instant_math_is_associative() {\n }\n \n #[test]\n-#[should_panic]\n-fn instant_duration_since_panic() {\n+fn instant_duration_since_saturates() {\n     let a = Instant::now();\n-    let _ = (a - Duration::SECOND).duration_since(a);\n+    assert_eq!((a - Duration::SECOND).duration_since(a), Duration::ZERO);\n }\n \n #[test]\n@@ -109,6 +108,7 @@ fn instant_checked_duration_since_nopanic() {\n #[test]\n fn instant_saturating_duration_since_nopanic() {\n     let a = Instant::now();\n+    #[allow(deprecated, deprecated_in_future)]\n     let ret = (a - Duration::SECOND).saturating_duration_since(a);\n     assert_eq!(ret, Duration::ZERO);\n }\n@@ -192,31 +192,6 @@ fn since_epoch() {\n     assert!(a < hundred_twenty_years);\n }\n \n-#[cfg(all(target_has_atomic = \"64\", not(target_has_atomic = \"128\")))]\n-#[test]\n-fn monotonizer_wrapping_backslide() {\n-    use super::monotonic::inner::{monotonize_impl, ZERO};\n-    use core::sync::atomic::AtomicU64;\n-\n-    let reference = AtomicU64::new(0);\n-\n-    let time = match ZERO.checked_add_duration(&Duration::from_secs(0xffff_ffff)) {\n-        Some(time) => time,\n-        None => {\n-            // platform cannot represent u32::MAX seconds so it won't have to deal with this kind\n-            // of overflow either\n-            return;\n-        }\n-    };\n-\n-    let monotonized = monotonize_impl(&reference, time);\n-    let expected = ZERO.checked_add_duration(&Duration::from_secs(1 << 32)).unwrap();\n-    assert_eq!(\n-        monotonized, expected,\n-        \"64bit monotonizer should handle overflows in the seconds part\"\n-    );\n-}\n-\n macro_rules! bench_instant_threaded {\n     ($bench_name:ident, $thread_count:expr) => {\n         #[bench]"}, {"sha": "6c1128b393fed9207bb2662cdc5beeffa0f69260", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 20, "deletions": 8, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -63,7 +63,7 @@ def support_xz():\n     except tarfile.CompressionError:\n         return False\n \n-def get(base, url, path, checksums, verbose=False, do_verify=True):\n+def get(base, url, path, checksums, verbose=False, do_verify=True, help_on_error=None):\n     with tempfile.NamedTemporaryFile(delete=False) as temp_file:\n         temp_path = temp_file.name\n \n@@ -82,7 +82,7 @@ def get(base, url, path, checksums, verbose=False, do_verify=True):\n                         print(\"ignoring already-download file\",\n                             path, \"due to failed verification\")\n                     os.unlink(path)\n-        download(temp_path, \"{}/{}\".format(base, url), True, verbose)\n+        download(temp_path, \"{}/{}\".format(base, url), True, verbose, help_on_error=help_on_error)\n         if do_verify and not verify(temp_path, sha256, verbose):\n             raise RuntimeError(\"failed verification\")\n         if verbose:\n@@ -95,17 +95,17 @@ def get(base, url, path, checksums, verbose=False, do_verify=True):\n             os.unlink(temp_path)\n \n \n-def download(path, url, probably_big, verbose):\n+def download(path, url, probably_big, verbose, help_on_error=None):\n     for _ in range(0, 4):\n         try:\n-            _download(path, url, probably_big, verbose, True)\n+            _download(path, url, probably_big, verbose, True, help_on_error=help_on_error)\n             return\n         except RuntimeError:\n             print(\"\\nspurious failure, trying again\")\n-    _download(path, url, probably_big, verbose, False)\n+    _download(path, url, probably_big, verbose, False, help_on_error=help_on_error)\n \n \n-def _download(path, url, probably_big, verbose, exception):\n+def _download(path, url, probably_big, verbose, exception, help_on_error=None):\n     if probably_big or verbose:\n         print(\"downloading {}\".format(url))\n     # see https://serverfault.com/questions/301128/how-to-download\n@@ -126,7 +126,8 @@ def _download(path, url, probably_big, verbose, exception):\n              \"--connect-timeout\", \"30\",  # timeout if cannot connect within 30 seconds\n              \"--retry\", \"3\", \"-Sf\", \"-o\", path, url],\n             verbose=verbose,\n-            exception=exception)\n+            exception=exception,\n+            help_on_error=help_on_error)\n \n \n def verify(path, expected, verbose):\n@@ -167,7 +168,7 @@ def unpack(tarball, tarball_suffix, dst, verbose=False, match=None):\n     shutil.rmtree(os.path.join(dst, fname))\n \n \n-def run(args, verbose=False, exception=False, is_bootstrap=False, **kwargs):\n+def run(args, verbose=False, exception=False, is_bootstrap=False, help_on_error=None, **kwargs):\n     \"\"\"Run a child program in a new process\"\"\"\n     if verbose:\n         print(\"running: \" + ' '.join(args))\n@@ -178,6 +179,8 @@ def run(args, verbose=False, exception=False, is_bootstrap=False, **kwargs):\n     code = ret.wait()\n     if code != 0:\n         err = \"failed to run: \" + ' '.join(args)\n+        if help_on_error is not None:\n+            err += \"\\n\" + help_on_error\n         if verbose or exception:\n             raise RuntimeError(err)\n         # For most failures, we definitely do want to print this error, or the user will have no\n@@ -624,13 +627,22 @@ def _download_ci_llvm(self, llvm_sha, llvm_assertions):\n         filename = \"rust-dev-nightly-\" + self.build + tarball_suffix\n         tarball = os.path.join(rustc_cache, filename)\n         if not os.path.exists(tarball):\n+            help_on_error = \"error: failed to download llvm from ci\"\n+            help_on_error += \"\\nhelp: old builds get deleted after a certain time\"\n+            help_on_error += \"\\nhelp: if trying to compile an old commit of rustc,\"\n+            help_on_error += \" disable `download-ci-llvm` in config.toml:\"\n+            help_on_error += \"\\n\"\n+            help_on_error += \"\\n[llvm]\"\n+            help_on_error += \"\\ndownload-ci-llvm = false\"\n+            help_on_error += \"\\n\"\n             get(\n                 base,\n                 \"{}/{}\".format(url, filename),\n                 tarball,\n                 self.checksums_sha256,\n                 verbose=self.verbose,\n                 do_verify=False,\n+                help_on_error=help_on_error,\n             )\n         unpack(tarball, tarball_suffix, self.llvm_root(),\n                 match=\"rust-dev\","}, {"sha": "c3205165040172f787c56af28b3f168e99cfa7b9", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -688,7 +688,7 @@ fn main_args(at_args: &[String]) -> MainResult {\n         Ok(opts) => opts,\n         Err(code) => return if code == 0 { Ok(()) } else { Err(ErrorReported) },\n     };\n-    rustc_interface::util::setup_callbacks_and_run_in_thread_pool_with_globals(\n+    rustc_interface::util::run_in_thread_pool_with_globals(\n         options.edition,\n         1, // this runs single-threaded, even in a parallel compiler\n         &None,"}, {"sha": "d180de9be3bf310896f4f65b601240a691ebb9da", "filename": "src/test/ui/associated-type-bounds/bad-bounds-on-assoc-in-trait.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fbad-bounds-on-assoc-in-trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fbad-bounds-on-assoc-in-trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fbad-bounds-on-assoc-in-trait.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -1,6 +1,5 @@\n // NOTE: rustc cannot currently handle bounds of the form `for<'a> <Foo as Bar<'a>>::Assoc: Baz`.\n // This should hopefully be fixed with Chalk.\n-// ignore-compare-mode-chalk\n \n #![feature(associated_type_bounds)]\n "}, {"sha": "c23e54594ee301f679c2cd46c48929dbc4f55693", "filename": "src/test/ui/associated-type-bounds/bad-bounds-on-assoc-in-trait.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fbad-bounds-on-assoc-in-trait.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fbad-bounds-on-assoc-in-trait.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fbad-bounds-on-assoc-in-trait.stderr?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -1,5 +1,5 @@\n error[E0277]: `<<Self as Case1>::C as Iterator>::Item` cannot be sent between threads safely\n-  --> $DIR/bad-bounds-on-assoc-in-trait.rs:27:36\n+  --> $DIR/bad-bounds-on-assoc-in-trait.rs:26:36\n    |\n LL |     type C: Clone + Iterator<Item: Send + Iterator<Item: for<'a> Lam<&'a u8, App: Debug>> + Sync>;\n    |                                    ^^^^ `<<Self as Case1>::C as Iterator>::Item` cannot be sent between threads safely\n@@ -11,7 +11,7 @@ LL | trait Case1 where <<Self as Case1>::C as Iterator>::Item: Send {\n    |             ++++++++++++++++++++++++++++++++++++++++++++++++++\n \n error[E0277]: `<<Self as Case1>::C as Iterator>::Item` is not an iterator\n-  --> $DIR/bad-bounds-on-assoc-in-trait.rs:27:43\n+  --> $DIR/bad-bounds-on-assoc-in-trait.rs:26:43\n    |\n LL |     type C: Clone + Iterator<Item: Send + Iterator<Item: for<'a> Lam<&'a u8, App: Debug>> + Sync>;\n    |                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ `<<Self as Case1>::C as Iterator>::Item` is not an iterator\n@@ -23,7 +23,7 @@ LL | trait Case1 where <<Self as Case1>::C as Iterator>::Item: Iterator {\n    |             ++++++++++++++++++++++++++++++++++++++++++++++++++++++\n \n error[E0277]: `<<Self as Case1>::C as Iterator>::Item` cannot be shared between threads safely\n-  --> $DIR/bad-bounds-on-assoc-in-trait.rs:27:93\n+  --> $DIR/bad-bounds-on-assoc-in-trait.rs:26:93\n    |\n LL |     type C: Clone + Iterator<Item: Send + Iterator<Item: for<'a> Lam<&'a u8, App: Debug>> + Sync>;\n    |                                                                                             ^^^^ `<<Self as Case1>::C as Iterator>::Item` cannot be shared between threads safely"}, {"sha": "b0703a4ee22b3b35fc792be2e98cd53a4a46c004", "filename": "src/test/ui/associated-type-bounds/trait-params.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fassociated-type-bounds%2Ftrait-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fassociated-type-bounds%2Ftrait-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Ftrait-params.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -1,5 +1,4 @@\n // build-pass (FIXME(62277): could be check-pass?)\n-// ignore-compare-mode-chalk\n \n #![feature(associated_type_bounds)]\n "}, {"sha": "97c5acf1f72ca42129efce0205612dc331f7719d", "filename": "src/test/ui/associated-type-bounds/union-bounds.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fassociated-type-bounds%2Funion-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fassociated-type-bounds%2Funion-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Funion-bounds.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -1,5 +1,4 @@\n // run-pass\n-// ignore-compare-mode-chalk\n \n #![feature(associated_type_bounds)]\n #![feature(untagged_unions)]"}, {"sha": "c9b302b96919fef3c818c780a4e6a9cc9ff2396d", "filename": "src/test/ui/associated-types/associated-types-stream.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-stream.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-stream.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fassociated-types-stream.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -1,8 +1,6 @@\n // run-pass\n // Test references to the trait `Stream` in the bounds for associated\n // types defined on `Stream`. Issue #20551.\n-// ignore-compare-mode-chalk\n-\n \n trait Stream {\n     type Car;"}, {"sha": "f74c5a8590d1d5989766217919f176d4e05b5e9d", "filename": "src/test/ui/associated-types/hr-associated-type-bound-param-2.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-bound-param-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-bound-param-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-bound-param-2.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -1,4 +1,3 @@\n-// ignore-compare-mode-chalk\n trait Z<'a, T: ?Sized>\n where\n     T: Z<'a, u16>,"}, {"sha": "354caef1e41d8e4594e5d1a11fc63813c9f1a4cb", "filename": "src/test/ui/associated-types/hr-associated-type-bound-param-2.stderr", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-bound-param-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-bound-param-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-bound-param-2.stderr?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -1,11 +1,11 @@\n error[E0277]: the trait bound `str: Clone` is not satisfied\n-  --> $DIR/hr-associated-type-bound-param-2.rs:4:8\n+  --> $DIR/hr-associated-type-bound-param-2.rs:3:8\n    |\n LL |     T: Z<'a, u16>,\n    |        ^^^^^^^^^^ the trait `Clone` is not implemented for `str`\n    |\n note: required by a bound in `Z`\n-  --> $DIR/hr-associated-type-bound-param-2.rs:7:35\n+  --> $DIR/hr-associated-type-bound-param-2.rs:6:35\n    |\n LL | trait Z<'a, T: ?Sized>\n    |       - required by a bound in this\n@@ -14,13 +14,13 @@ LL |     for<'b> <T as Z<'b, u16>>::W: Clone,\n    |                                   ^^^^^ required by this bound in `Z`\n \n error[E0277]: the trait bound `str: Clone` is not satisfied\n-  --> $DIR/hr-associated-type-bound-param-2.rs:4:8\n+  --> $DIR/hr-associated-type-bound-param-2.rs:3:8\n    |\n LL |     T: Z<'a, u16>,\n    |        ^^^^^^^^^^ the trait `Clone` is not implemented for `str`\n    |\n note: required by a bound in `Z`\n-  --> $DIR/hr-associated-type-bound-param-2.rs:7:35\n+  --> $DIR/hr-associated-type-bound-param-2.rs:6:35\n    |\n LL | trait Z<'a, T: ?Sized>\n    |       - required by a bound in this\n@@ -29,13 +29,13 @@ LL |     for<'b> <T as Z<'b, u16>>::W: Clone,\n    |                                   ^^^^^ required by this bound in `Z`\n \n error[E0277]: the trait bound `str: Clone` is not satisfied\n-  --> $DIR/hr-associated-type-bound-param-2.rs:16:14\n+  --> $DIR/hr-associated-type-bound-param-2.rs:15:14\n    |\n LL |     type W = str;\n    |              ^^^ the trait `Clone` is not implemented for `str`\n    |\n note: required by a bound in `Z`\n-  --> $DIR/hr-associated-type-bound-param-2.rs:7:35\n+  --> $DIR/hr-associated-type-bound-param-2.rs:6:35\n    |\n LL | trait Z<'a, T: ?Sized>\n    |       - required by a bound in this"}, {"sha": "d7f3151a502ee667dba173f83e5b583e243522a2", "filename": "src/test/ui/associated-types/hr-associated-type-bound-param-5.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-bound-param-5.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-bound-param-5.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-bound-param-5.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -1,4 +1,3 @@\n-// ignore-compare-mode-chalk\n trait Cycle: Sized {\n     type Next: Cycle<Next = Self>;\n }"}, {"sha": "4c04d12a71470d25f0f9b33a88ae6c4bb7c95b02", "filename": "src/test/ui/associated-types/hr-associated-type-bound-param-5.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-bound-param-5.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-bound-param-5.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fhr-associated-type-bound-param-5.stderr?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -1,11 +1,11 @@\n error[E0277]: the trait bound `str: Clone` is not satisfied\n-  --> $DIR/hr-associated-type-bound-param-5.rs:27:14\n+  --> $DIR/hr-associated-type-bound-param-5.rs:26:14\n    |\n LL |     type U = str;\n    |              ^^^ the trait `Clone` is not implemented for `str`\n    |\n note: required by a bound in `X`\n-  --> $DIR/hr-associated-type-bound-param-5.rs:18:45\n+  --> $DIR/hr-associated-type-bound-param-5.rs:17:45\n    |\n LL | trait X<'a, T: Cycle + for<'b> X<'b, T>>\n    |       - required by a bound in this\n@@ -14,13 +14,13 @@ LL |     for<'b> <T::Next as X<'b, T::Next>>::U: Clone,\n    |                                             ^^^^^ required by this bound in `X`\n \n error[E0277]: the trait bound `str: Clone` is not satisfied\n-  --> $DIR/hr-associated-type-bound-param-5.rs:32:14\n+  --> $DIR/hr-associated-type-bound-param-5.rs:31:14\n    |\n LL |     type U = str;\n    |              ^^^ the trait `Clone` is not implemented for `str`\n    |\n note: required by a bound in `X`\n-  --> $DIR/hr-associated-type-bound-param-5.rs:18:45\n+  --> $DIR/hr-associated-type-bound-param-5.rs:17:45\n    |\n LL | trait X<'a, T: Cycle + for<'b> X<'b, T>>\n    |       - required by a bound in this"}, {"sha": "47ee3e7ad70e83a8267515af1f933d6a7095653b", "filename": "src/test/ui/associated-types/issue-50301.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fassociated-types%2Fissue-50301.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fassociated-types%2Fissue-50301.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fissue-50301.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -1,6 +1,5 @@\n // Tests that HRTBs are correctly accepted -- https://github.com/rust-lang/rust/issues/50301\n // check-pass\n-// ignore-compare-mode-chalk\n trait Trait\n where\n     for<'a> &'a Self::IntoIter: IntoIterator<Item = u32>,"}, {"sha": "33d55be5812e78822b18d7e8472195b5b789c9fc", "filename": "src/test/ui/borrowck/issue-64453.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fborrowck%2Fissue-64453.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fborrowck%2Fissue-64453.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-64453.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -2,7 +2,7 @@ struct Project;\n struct Value;\n \n static settings_dir: String = format!(\"\");\n-//~^ ERROR calls in statics are limited to constant functions\n+//~^ ERROR cannot call non-const fn\n //~| ERROR is not yet stable as a const\n \n fn from_string(_: String) -> Value {"}, {"sha": "f3436fbec66a605327139855744a48cc66f327dc", "filename": "src/test/ui/borrowck/issue-64453.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fborrowck%2Fissue-64453.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fborrowck%2Fissue-64453.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fissue-64453.stderr?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -7,12 +7,13 @@ LL | static settings_dir: String = format!(\"\");\n    = help: add `#![feature(const_fmt_arguments_new)]` to the crate attributes to enable\n    = note: this error originates in the macro `$crate::__export::format_args` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error[E0015]: calls in statics are limited to constant functions, tuple structs and tuple variants\n+error[E0015]: cannot call non-const fn `format` in statics\n   --> $DIR/issue-64453.rs:4:31\n    |\n LL | static settings_dir: String = format!(\"\");\n    |                               ^^^^^^^^^^^\n    |\n+   = note: calls in statics are limited to constant functions, tuple structs and tuple variants\n    = note: this error originates in the macro `format` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error[E0507]: cannot move out of static item `settings_dir`"}, {"sha": "f4ebf91924ced1384025f84367366d7af67e70ce", "filename": "src/test/ui/chalkify/assert.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fchalkify%2Fassert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fchalkify%2Fassert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Fassert.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -0,0 +1,6 @@\n+// run-pass\n+// compile-flags: -Z chalk\n+\n+fn main() {\n+    assert_eq!(1, 1);\n+}"}, {"sha": "0f0df29019e7bbc1dbea32322013e0b696abb71e", "filename": "src/test/ui/chalkify/println.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fchalkify%2Fprintln.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fchalkify%2Fprintln.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Fprintln.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -2,6 +2,5 @@\n // compile-flags: -Z chalk\n \n fn main() {\n-    // FIXME(chalk): Require `RegionOutlives`/`TypeOutlives`/`Subtype` support\n-    //println!(\"hello\");\n+    println!(\"hello\");\n }"}, {"sha": "d56abc42bf540c048951ac55830e97e3c50bf309", "filename": "src/test/ui/chalkify/trait-objects.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fchalkify%2Ftrait-objects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fchalkify%2Ftrait-objects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fchalkify%2Ftrait-objects.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -5,8 +5,7 @@ use std::fmt::Display;\n \n fn main() {\n     let d: &dyn Display = &mut 3;\n-    // FIXME(chalk) should be able to call d.to_string() as well, but doing so\n-    // requires Chalk to be able to prove trait object well-formed goals.\n+    d.to_string();\n     (&d).to_string();\n     let f: &dyn Fn(i32) -> _ = &|x| x + x;\n     f(2);"}, {"sha": "eb4ecd8baca965e97ecc4d5fc75c291f7021a2b3", "filename": "src/test/ui/check-static-values-constraints.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fcheck-static-values-constraints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fcheck-static-values-constraints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcheck-static-values-constraints.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -87,7 +87,7 @@ static mut STATIC13: SafeStruct = SafeStruct{field1: SafeEnum::Variant1,\n static mut STATIC14: SafeStruct = SafeStruct {\n     field1: SafeEnum::Variant1,\n     field2: SafeEnum::Variant4(\"str\".to_string())\n-//~^ ERROR calls in statics are limited to constant functions\n+//~^ ERROR cannot call non-const fn\n };\n \n static STATIC15: &'static [Box<MyOwned>] = &["}, {"sha": "b28cf0d6bd0f582808a27f90823e8595d040ee16", "filename": "src/test/ui/check-static-values-constraints.stderr", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fcheck-static-values-constraints.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fcheck-static-values-constraints.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcheck-static-values-constraints.stderr?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -15,11 +15,13 @@ error[E0010]: allocations are not allowed in statics\n LL | static STATIC11: Box<MyOwned> = box MyOwned;\n    |                                 ^^^^^^^^^^^ allocation not allowed in statics\n \n-error[E0015]: calls in statics are limited to constant functions, tuple structs and tuple variants\n-  --> $DIR/check-static-values-constraints.rs:89:32\n+error[E0015]: cannot call non-const fn `<str as ToString>::to_string` in statics\n+  --> $DIR/check-static-values-constraints.rs:89:38\n    |\n LL |     field2: SafeEnum::Variant4(\"str\".to_string())\n-   |                                ^^^^^^^^^^^^^^^^^\n+   |                                      ^^^^^^^^^^^\n+   |\n+   = note: calls in statics are limited to constant functions, tuple structs and tuple variants\n \n error[E0010]: allocations are not allowed in statics\n   --> $DIR/check-static-values-constraints.rs:94:5"}, {"sha": "c1a6bf6e34d0bb643585e58cbeaa4805dd2a4deb", "filename": "src/test/ui/const-generics/issue-93647.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fconst-generics%2Fissue-93647.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fconst-generics%2Fissue-93647.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissue-93647.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -1,6 +1,6 @@\n struct X<const N: usize = {\n     (||1usize)()\n-    //~^ ERROR calls in constants are limited to\n+    //~^ ERROR cannot call\n }>;\n \n fn main() {}"}, {"sha": "e2048ecd60f6d6e6974e136925de0f9f3ba09cfc", "filename": "src/test/ui/const-generics/issue-93647.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fconst-generics%2Fissue-93647.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fconst-generics%2Fissue-93647.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissue-93647.stderr?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -1,8 +1,11 @@\n-error[E0015]: calls in constants are limited to constant functions, tuple structs and tuple variants\n+error[E0015]: cannot call non-const closure in constants\n   --> $DIR/issue-93647.rs:2:5\n    |\n LL |     (||1usize)()\n    |     ^^^^^^^^^^^^\n+   |\n+   = note: closures need an RFC before allowed to be called in constants\n+   = note: calls in constants are limited to constant functions, tuple structs and tuple variants\n \n error: aborting due to previous error\n "}, {"sha": "bebd0c6ac1202d656c67299d2dac1f19a105a02c", "filename": "src/test/ui/const-generics/issues/issue-90318.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-90318.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-90318.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-90318.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -13,15 +13,15 @@ fn consume<T: 'static>(_val: T)\n where\n     If<{ TypeId::of::<T>() != TypeId::of::<()>() }>: True,\n     //~^ ERROR: overly complex generic constant\n-    //~| ERROR: calls in constants are limited to constant functions\n+    //~| ERROR: cannot call non-const operator in constants\n {\n }\n \n fn test<T: 'static>()\n where\n     If<{ TypeId::of::<T>() != TypeId::of::<()>() }>: True,\n     //~^ ERROR: overly complex generic constant\n-    //~| ERROR: calls in constants are limited to constant functions\n+    //~| ERROR: cannot call non-const operator in constants\n {\n }\n "}, {"sha": "c8690ecd0da7e84434306962292eb922f7abe4b8", "filename": "src/test/ui/const-generics/issues/issue-90318.stderr", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-90318.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-90318.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fissues%2Fissue-90318.stderr?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -9,11 +9,19 @@ LL |     If<{ TypeId::of::<T>() != TypeId::of::<()>() }>: True,\n    = help: consider moving this anonymous constant into a `const` function\n    = note: this operation may be supported in the future\n \n-error[E0015]: calls in constants are limited to constant functions, tuple structs and tuple variants\n+error[E0015]: cannot call non-const operator in constants\n   --> $DIR/issue-90318.rs:14:10\n    |\n LL |     If<{ TypeId::of::<T>() != TypeId::of::<()>() }>: True,\n    |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: impl defined here, but it is not `const`\n+  --> $SRC_DIR/core/src/any.rs:LL:COL\n+   |\n+LL | #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]\n+   |                       ^^^^^^^^^\n+   = note: calls in constants are limited to constant functions, tuple structs and tuple variants\n+   = note: this error originates in the derive macro `PartialEq` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: overly complex generic constant\n   --> $DIR/issue-90318.rs:22:8\n@@ -26,11 +34,19 @@ LL |     If<{ TypeId::of::<T>() != TypeId::of::<()>() }>: True,\n    = help: consider moving this anonymous constant into a `const` function\n    = note: this operation may be supported in the future\n \n-error[E0015]: calls in constants are limited to constant functions, tuple structs and tuple variants\n+error[E0015]: cannot call non-const operator in constants\n   --> $DIR/issue-90318.rs:22:10\n    |\n LL |     If<{ TypeId::of::<T>() != TypeId::of::<()>() }>: True,\n    |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+note: impl defined here, but it is not `const`\n+  --> $SRC_DIR/core/src/any.rs:LL:COL\n+   |\n+LL | #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Debug, Hash)]\n+   |                       ^^^^^^^^^\n+   = note: calls in constants are limited to constant functions, tuple structs and tuple variants\n+   = note: this error originates in the derive macro `PartialEq` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to 4 previous errors\n "}, {"sha": "52f1c588258235db49b315efeea2a1034e26887c", "filename": "src/test/ui/const-generics/nested-type.full.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fconst-generics%2Fnested-type.full.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fconst-generics%2Fnested-type.full.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fnested-type.full.stderr?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -1,8 +1,10 @@\n-error[E0015]: calls in constants are limited to constant functions, tuple structs and tuple variants\n+error[E0015]: cannot call non-const fn `Foo::{constant#0}::Foo::<17_usize>::value` in constants\n   --> $DIR/nested-type.rs:15:5\n    |\n LL |     Foo::<17>::value()\n    |     ^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: calls in constants are limited to constant functions, tuple structs and tuple variants\n \n error: aborting due to previous error\n "}, {"sha": "0e3c988ae4d8c9f34e285cc9b188953bffc74d28", "filename": "src/test/ui/const-generics/nested-type.min.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fconst-generics%2Fnested-type.min.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fconst-generics%2Fnested-type.min.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fnested-type.min.stderr?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -14,11 +14,13 @@ LL | | }]>;\n    = note: the only supported types are integers, `bool` and `char`\n    = help: more complex types are supported with `#![feature(adt_const_params)]`\n \n-error[E0015]: calls in constants are limited to constant functions, tuple structs and tuple variants\n+error[E0015]: cannot call non-const fn `Foo::{constant#0}::Foo::<17_usize>::value` in constants\n   --> $DIR/nested-type.rs:15:5\n    |\n LL |     Foo::<17>::value()\n    |     ^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: calls in constants are limited to constant functions, tuple structs and tuple variants\n \n error: aborting due to 2 previous errors\n "}, {"sha": "5240f5c3b0b64b8d4cc3919b3cd167ecdfb3ce15", "filename": "src/test/ui/const-generics/nested-type.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fconst-generics%2Fnested-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fconst-generics%2Fnested-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fnested-type.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -13,7 +13,7 @@ struct Foo<const N: [u8; { //[min]~ ERROR `[u8; _]` is forbidden\n     }\n \n     Foo::<17>::value()\n-    //~^ ERROR calls in constants are limited to constant functions\n+    //~^ ERROR cannot call non-const fn\n }]>;\n \n fn main() {}"}, {"sha": "28e89559fe538653a62da22f7b34313c18828d7e", "filename": "src/test/ui/consts/const-call.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fconsts%2Fconst-call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fconsts%2Fconst-call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-call.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -4,5 +4,5 @@ fn f(x: usize) -> usize {\n \n fn main() {\n     let _ = [0; f(2)];\n-    //~^ ERROR calls in constants are limited to constant functions\n+    //~^ ERROR cannot call non-const fn\n }"}, {"sha": "e46bcad0e1d0ea48dff0ea76cfce951496bdc8aa", "filename": "src/test/ui/consts/const-call.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fconsts%2Fconst-call.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fconsts%2Fconst-call.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-call.stderr?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -1,8 +1,10 @@\n-error[E0015]: calls in constants are limited to constant functions, tuple structs and tuple variants\n+error[E0015]: cannot call non-const fn `f` in constants\n   --> $DIR/const-call.rs:6:17\n    |\n LL |     let _ = [0; f(2)];\n    |                 ^^^^\n+   |\n+   = note: calls in constants are limited to constant functions, tuple structs and tuple variants\n \n error: aborting due to previous error\n "}, {"sha": "2a4b6f3b76f90b7119fae794caf481c1b4187f88", "filename": "src/test/ui/consts/const-eval/ub-nonnull.chalk.64bit.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.chalk.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.chalk.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-nonnull.chalk.64bit.stderr?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -0,0 +1,9 @@\n+error[E0284]: type annotations needed: cannot satisfy `<usize as SliceIndex<[u8]>>::Output == _`\n+  --> $DIR/ub-nonnull.rs:19:30\n+   |\n+LL |     let out_of_bounds_ptr = &ptr[255];\n+   |                              ^^^^^^^^ cannot satisfy `<usize as SliceIndex<[u8]>>::Output == _`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0284`."}, {"sha": "39352ca848a8020cc23b557aaadff070679d03ab", "filename": "src/test/ui/consts/const-eval/ub-wide-ptr.chalk.64bit.stderr", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.chalk.64bit.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.chalk.64bit.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fub-wide-ptr.chalk.64bit.stderr?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -0,0 +1,9 @@\n+error[E0282]: type annotations needed\n+  --> $DIR/ub-wide-ptr.rs:90:67\n+   |\n+LL | const MYSLICE_SUFFIX_BAD: &MySliceBool = &MySlice(true, [unsafe { mem::transmute(3u8) }]);\n+   |                                                                   ^^^^^^^^^^^^^^ cannot infer type for type parameter `U` declared on the function `transmute`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0282`."}, {"sha": "eccda49db3eb54481ffd581cd0c07b0206c00960", "filename": "src/test/ui/consts/const-extern-fn/const-extern-fn-call-extern-fn.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fconsts%2Fconst-extern-fn%2Fconst-extern-fn-call-extern-fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fconsts%2Fconst-extern-fn%2Fconst-extern-fn-call-extern-fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-extern-fn%2Fconst-extern-fn-call-extern-fn.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -7,7 +7,7 @@ extern \"C\" {\n const extern \"C\" fn bar() {\n     unsafe {\n         regular_in_block();\n-        //~^ ERROR: calls in constant functions\n+        //~^ ERROR: cannot call non-const fn\n     }\n }\n \n@@ -16,7 +16,7 @@ extern \"C\" fn regular() {}\n const extern \"C\" fn foo() {\n     unsafe {\n         regular();\n-        //~^ ERROR: calls in constant functions\n+        //~^ ERROR: cannot call non-const fn\n     }\n }\n "}, {"sha": "5acf22e4bc66e3591d94240f25ecee1e4f52b5dc", "filename": "src/test/ui/consts/const-extern-fn/const-extern-fn-call-extern-fn.stderr", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fconsts%2Fconst-extern-fn%2Fconst-extern-fn-call-extern-fn.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fconsts%2Fconst-extern-fn%2Fconst-extern-fn-call-extern-fn.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-extern-fn%2Fconst-extern-fn-call-extern-fn.stderr?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -1,14 +1,18 @@\n-error[E0015]: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n+error[E0015]: cannot call non-const fn `regular_in_block` in constant functions\n   --> $DIR/const-extern-fn-call-extern-fn.rs:9:9\n    |\n LL |         regular_in_block();\n    |         ^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n \n-error[E0015]: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n+error[E0015]: cannot call non-const fn `regular` in constant functions\n   --> $DIR/const-extern-fn-call-extern-fn.rs:18:9\n    |\n LL |         regular();\n    |         ^^^^^^^^^\n+   |\n+   = note: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n \n error: aborting due to 2 previous errors\n "}, {"sha": "abe68c17a0d7f1c0b7062547968dbf2d2db2bdb7", "filename": "src/test/ui/consts/const-fn-error.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fconsts%2Fconst-fn-error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fconsts%2Fconst-fn-error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-fn-error.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -4,8 +4,8 @@ const fn f(x: usize) -> usize {\n     let mut sum = 0;\n     for i in 0..x {\n         //~^ ERROR mutable references\n-        //~| ERROR calls in constant functions\n-        //~| ERROR calls in constant functions\n+        //~| ERROR cannot convert\n+        //~| ERROR cannot call non-const fn\n         //~| ERROR `for` is not allowed in a `const fn`\n         sum += i;\n     }"}, {"sha": "4d53cfc35e1c4ab88db8e8b0bca1e545a23c99b2", "filename": "src/test/ui/consts/const-fn-error.stderr", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fconsts%2Fconst-fn-error.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fconsts%2Fconst-fn-error.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-fn-error.stderr?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -13,11 +13,18 @@ LL | |     }\n    = note: see issue #87575 <https://github.com/rust-lang/rust/issues/87575> for more information\n    = help: add `#![feature(const_for)]` to the crate attributes to enable\n \n-error[E0015]: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n+error[E0015]: cannot convert `std::ops::Range<usize>` into an iterator in constant functions\n   --> $DIR/const-fn-error.rs:5:14\n    |\n LL |     for i in 0..x {\n    |              ^^^^\n+   |\n+note: impl defined here, but it is not `const`\n+  --> $SRC_DIR/core/src/iter/traits/collect.rs:LL:COL\n+   |\n+LL | impl<I: Iterator> IntoIterator for I {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n \n error[E0658]: mutable references are not allowed in constant functions\n   --> $DIR/const-fn-error.rs:5:14\n@@ -28,11 +35,13 @@ LL |     for i in 0..x {\n    = note: see issue #57349 <https://github.com/rust-lang/rust/issues/57349> for more information\n    = help: add `#![feature(const_mut_refs)]` to the crate attributes to enable\n \n-error[E0015]: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n+error[E0015]: cannot call non-const fn `<std::ops::Range<usize> as Iterator>::next` in constant functions\n   --> $DIR/const-fn-error.rs:5:14\n    |\n LL |     for i in 0..x {\n    |              ^^^^\n+   |\n+   = note: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n \n error: aborting due to 4 previous errors\n "}, {"sha": "4c7effc0d158657594810410aa6a1ef27eecbc20", "filename": "src/test/ui/consts/const-fn-not-safe-for-const.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fconsts%2Fconst-fn-not-safe-for-const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fconsts%2Fconst-fn-not-safe-for-const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-fn-not-safe-for-const.stderr?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -1,8 +1,10 @@\n-error[E0015]: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n+error[E0015]: cannot call non-const fn `random` in constant functions\n   --> $DIR/const-fn-not-safe-for-const.rs:14:5\n    |\n LL |     random()\n    |     ^^^^^^^^\n+   |\n+   = note: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n \n error[E0013]: constant functions cannot refer to statics\n   --> $DIR/const-fn-not-safe-for-const.rs:20:5"}, {"sha": "58bcb5f74ccf6254f2e9f538ea35e3a46e94ba12", "filename": "src/test/ui/consts/const-for.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fconsts%2Fconst-for.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fconsts%2Fconst-for.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-for.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -3,8 +3,8 @@\n \n const _: () = {\n     for _ in 0..5 {}\n-    //~^ error: calls in constants are limited to\n-    //~| error: calls in constants are limited to\n+    //~^ error: cannot convert\n+    //~| error: cannot call non-const fn\n };\n \n fn main() {}"}, {"sha": "b0dc43eb8e8508f0d23cb136faa64e168408afb2", "filename": "src/test/ui/consts/const-for.stderr", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fconsts%2Fconst-for.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fconsts%2Fconst-for.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-for.stderr?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -1,14 +1,23 @@\n-error[E0015]: calls in constants are limited to constant functions, tuple structs and tuple variants\n+error[E0015]: cannot convert `std::ops::Range<i32>` into an iterator in constants\n   --> $DIR/const-for.rs:5:14\n    |\n LL |     for _ in 0..5 {}\n    |              ^^^^\n+   |\n+note: impl defined here, but it is not `const`\n+  --> $SRC_DIR/core/src/iter/traits/collect.rs:LL:COL\n+   |\n+LL | impl<I: Iterator> IntoIterator for I {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: calls in constants are limited to constant functions, tuple structs and tuple variants\n \n-error[E0015]: calls in constants are limited to constant functions, tuple structs and tuple variants\n+error[E0015]: cannot call non-const fn `<std::ops::Range<i32> as Iterator>::next` in constants\n   --> $DIR/const-for.rs:5:14\n    |\n LL |     for _ in 0..5 {}\n    |              ^^^^\n+   |\n+   = note: calls in constants are limited to constant functions, tuple structs and tuple variants\n \n error: aborting due to 2 previous errors\n "}, {"sha": "ddddc8505c635102ec743013828870f80be4d7ee", "filename": "src/test/ui/consts/control-flow/issue-46843.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Fissue-46843.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Fissue-46843.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Fissue-46843.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -8,7 +8,7 @@ fn non_const() -> Thing {\n }\n \n pub const Q: i32 = match non_const() {\n-    //~^ ERROR calls in constants are limited to constant functions\n+    //~^ ERROR cannot call non-const fn\n     Thing::This => 1,\n     Thing::That => 0\n };"}, {"sha": "66227f61e35638e985e8d10b59d8d31a9e68e4ee", "filename": "src/test/ui/consts/control-flow/issue-46843.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Fissue-46843.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Fissue-46843.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fcontrol-flow%2Fissue-46843.stderr?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -1,8 +1,10 @@\n-error[E0015]: calls in constants are limited to constant functions, tuple structs and tuple variants\n+error[E0015]: cannot call non-const fn `non_const` in constants\n   --> $DIR/issue-46843.rs:10:26\n    |\n LL | pub const Q: i32 = match non_const() {\n    |                          ^^^^^^^^^^^\n+   |\n+   = note: calls in constants are limited to constant functions, tuple structs and tuple variants\n \n error: aborting due to previous error\n "}, {"sha": "d5f694986fc8997ad7048118407af6b563a86fe5", "filename": "src/test/ui/consts/intrinsic_without_const_stab.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fconsts%2Fintrinsic_without_const_stab.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fconsts%2Fintrinsic_without_const_stab.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fintrinsic_without_const_stab.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -11,7 +11,7 @@ pub const unsafe fn copy<T>(src: *const T, dst: *mut T, count: usize) {\n     }\n \n     unsafe { copy(src, dst, count) }\n-    //~^ ERROR calls in constant functions are limited to constant functions\n+    //~^ ERROR cannot call non-const fn\n }\n \n fn main() {}"}, {"sha": "b32b6398ece62b1e2e2a2892b81dc7c0d496444d", "filename": "src/test/ui/consts/intrinsic_without_const_stab.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fconsts%2Fintrinsic_without_const_stab.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fconsts%2Fintrinsic_without_const_stab.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fintrinsic_without_const_stab.stderr?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -1,8 +1,10 @@\n-error[E0015]: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n+error[E0015]: cannot call non-const fn `copy::copy::<T>` in constant functions\n   --> $DIR/intrinsic_without_const_stab.rs:13:14\n    |\n LL |     unsafe { copy(src, dst, count) }\n    |              ^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n \n error: aborting due to previous error\n "}, {"sha": "8b37268b0b205c5c8e29f276be7bc0ec395bb645", "filename": "src/test/ui/consts/intrinsic_without_const_stab_fail.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fconsts%2Fintrinsic_without_const_stab_fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fconsts%2Fintrinsic_without_const_stab_fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fintrinsic_without_const_stab_fail.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -9,7 +9,7 @@ extern \"rust-intrinsic\" {\n #[rustc_const_unstable(feature = \"const_intrinsic_copy\", issue = \"80697\")]\n #[inline]\n pub const unsafe fn stuff<T>(src: *const T, dst: *mut T, count: usize) {\n-    unsafe { copy(src, dst, count) } //~ ERROR calls in constant functions are limited\n+    unsafe { copy(src, dst, count) } //~ ERROR cannot call non-const fn\n }\n \n fn main() {}"}, {"sha": "fcbb3724567fef5a252657bbc11d7b8030eb9815", "filename": "src/test/ui/consts/intrinsic_without_const_stab_fail.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fconsts%2Fintrinsic_without_const_stab_fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fconsts%2Fintrinsic_without_const_stab_fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fintrinsic_without_const_stab_fail.stderr?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -1,8 +1,10 @@\n-error[E0015]: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n+error[E0015]: cannot call non-const fn `copy::<T>` in constant functions\n   --> $DIR/intrinsic_without_const_stab_fail.rs:12:14\n    |\n LL |     unsafe { copy(src, dst, count) }\n    |              ^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n \n error: aborting due to previous error\n "}, {"sha": "f8131c9f3b717107d5d2530b29490d79adfdc163", "filename": "src/test/ui/consts/issue-28113.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fconsts%2Fissue-28113.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fconsts%2Fissue-28113.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-28113.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -2,7 +2,7 @@\n \n const X: u8 =\n     || -> u8 { 5 }()\n-    //~^ ERROR calls in constants are limited to constant functions\n+    //~^ ERROR cannot call non-const closure\n ;\n \n fn main() {}"}, {"sha": "7ad1f752eb085fd56dececf014f75d64e81fc0fe", "filename": "src/test/ui/consts/issue-28113.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fconsts%2Fissue-28113.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fconsts%2Fissue-28113.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-28113.stderr?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -1,8 +1,11 @@\n-error[E0015]: calls in constants are limited to constant functions, tuple structs and tuple variants\n+error[E0015]: cannot call non-const closure in constants\n   --> $DIR/issue-28113.rs:4:5\n    |\n LL |     || -> u8 { 5 }()\n    |     ^^^^^^^^^^^^^^^^\n+   |\n+   = note: closures need an RFC before allowed to be called in constants\n+   = note: calls in constants are limited to constant functions, tuple structs and tuple variants\n \n error: aborting due to previous error\n "}, {"sha": "d70b5a8c4e13af3e93a90c00e65c03b0a00b49e1", "filename": "src/test/ui/consts/issue-32829-2.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fconsts%2Fissue-32829-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fconsts%2Fissue-32829-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-32829-2.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -8,7 +8,7 @@ const bad : u32 = {\n const bad_two : u32 = {\n     {\n         invalid();\n-        //~^ ERROR: calls in constants are limited to constant functions, tuple structs and tuple variants\n+        //~^ ERROR: cannot call non-const fn `invalid`\n         0\n     }\n };\n@@ -30,7 +30,7 @@ static bad_four : u32 = {\n static bad_five : u32 = {\n     {\n         invalid();\n-        //~^ ERROR: calls in statics are limited to constant functions, tuple structs and tuple variants\n+        //~^ ERROR: cannot call non-const fn `invalid`\n         0\n     }\n };\n@@ -52,7 +52,7 @@ static mut bad_seven : u32 = {\n static mut bad_eight : u32 = {\n     {\n         invalid();\n-        //~^ ERROR: calls in statics are limited to constant functions, tuple structs and tuple variants\n+        //~^ ERROR: cannot call non-const fn `invalid`\n         0\n     }\n };"}, {"sha": "b94bdc0e3df1181f6499be8f5dc9f0c52861d3a8", "filename": "src/test/ui/consts/issue-32829-2.stderr", "status": "modified", "additions": 9, "deletions": 3, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fconsts%2Fissue-32829-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fconsts%2Fissue-32829-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-32829-2.stderr?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -1,20 +1,26 @@\n-error[E0015]: calls in constants are limited to constant functions, tuple structs and tuple variants\n+error[E0015]: cannot call non-const fn `invalid` in constants\n   --> $DIR/issue-32829-2.rs:10:9\n    |\n LL |         invalid();\n    |         ^^^^^^^^^\n+   |\n+   = note: calls in constants are limited to constant functions, tuple structs and tuple variants\n \n-error[E0015]: calls in statics are limited to constant functions, tuple structs and tuple variants\n+error[E0015]: cannot call non-const fn `invalid` in statics\n   --> $DIR/issue-32829-2.rs:32:9\n    |\n LL |         invalid();\n    |         ^^^^^^^^^\n+   |\n+   = note: calls in statics are limited to constant functions, tuple structs and tuple variants\n \n-error[E0015]: calls in statics are limited to constant functions, tuple structs and tuple variants\n+error[E0015]: cannot call non-const fn `invalid` in statics\n   --> $DIR/issue-32829-2.rs:54:9\n    |\n LL |         invalid();\n    |         ^^^^^^^^^\n+   |\n+   = note: calls in statics are limited to constant functions, tuple structs and tuple variants\n \n error: aborting due to 3 previous errors\n "}, {"sha": "cac12b90970fe78b3f1ad19a1cb46c34f061ab00", "filename": "src/test/ui/consts/issue-43105.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fconsts%2Fissue-43105.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fconsts%2Fissue-43105.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-43105.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -1,7 +1,7 @@\n fn xyz() -> u8 { 42 }\n \n const NUM: u8 = xyz();\n-//~^ ERROR calls in constants are limited to constant functions, tuple structs and tuple variants\n+//~^ ERROR cannot call non-const fn\n \n fn main() {\n     match 1 {"}, {"sha": "2d1174af71c86218ccdbb0020539c0a29bfe9ed4", "filename": "src/test/ui/consts/issue-43105.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fconsts%2Fissue-43105.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fconsts%2Fissue-43105.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-43105.stderr?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -1,8 +1,10 @@\n-error[E0015]: calls in constants are limited to constant functions, tuple structs and tuple variants\n+error[E0015]: cannot call non-const fn `xyz` in constants\n   --> $DIR/issue-43105.rs:3:17\n    |\n LL | const NUM: u8 = xyz();\n    |                 ^^^^^\n+   |\n+   = note: calls in constants are limited to constant functions, tuple structs and tuple variants\n \n error: could not evaluate constant pattern\n   --> $DIR/issue-43105.rs:8:9"}, {"sha": "9c673d20b2a9565549532cd4ac1df0d0cab8cfba", "filename": "src/test/ui/consts/issue-56164.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fconsts%2Fissue-56164.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fconsts%2Fissue-56164.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-56164.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -1,7 +1,7 @@\n #![feature(const_fn_fn_ptr_basics)]\n \n const fn foo() { (||{})() }\n-//~^ ERROR calls in constant functions\n+//~^ ERROR cannot call non-const closure\n \n const fn bad(input: fn()) {\n     input()"}, {"sha": "62a7c7db6b83ae0311894706e2ec70bcb2f69f3a", "filename": "src/test/ui/consts/issue-56164.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fconsts%2Fissue-56164.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fconsts%2Fissue-56164.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-56164.stderr?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -1,8 +1,11 @@\n-error[E0015]: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n+error[E0015]: cannot call non-const closure in constant functions\n   --> $DIR/issue-56164.rs:3:18\n    |\n LL | const fn foo() { (||{})() }\n    |                  ^^^^^^^^\n+   |\n+   = note: closures need an RFC before allowed to be called in constant functions\n+   = note: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n \n error: function pointers are not allowed in const fn\n   --> $DIR/issue-56164.rs:7:5"}, {"sha": "37958e7919d64890ddfd2df5d5c9e1ec8949d513", "filename": "src/test/ui/consts/issue-68542-closure-in-array-len.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fconsts%2Fissue-68542-closure-in-array-len.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fconsts%2Fissue-68542-closure-in-array-len.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-68542-closure-in-array-len.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -3,7 +3,7 @@\n // in the length part of an array.\n \n struct Bug {\n-    a: [(); (|| { 0 })()] //~ ERROR calls in constants are limited to\n+    a: [(); (|| { 0 })()] //~ ERROR cannot call non-const closure\n }\n \n fn main() {}"}, {"sha": "74fbbc680f7e413ad6f6a07fdc759260e554e253", "filename": "src/test/ui/consts/issue-68542-closure-in-array-len.stderr", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fconsts%2Fissue-68542-closure-in-array-len.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fconsts%2Fissue-68542-closure-in-array-len.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-68542-closure-in-array-len.stderr?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -1,8 +1,11 @@\n-error[E0015]: calls in constants are limited to constant functions, tuple structs and tuple variants\n+error[E0015]: cannot call non-const closure in constants\n   --> $DIR/issue-68542-closure-in-array-len.rs:6:13\n    |\n LL |     a: [(); (|| { 0 })()]\n    |             ^^^^^^^^^^^^\n+   |\n+   = note: closures need an RFC before allowed to be called in constants\n+   = note: calls in constants are limited to constant functions, tuple structs and tuple variants\n \n error: aborting due to previous error\n "}, {"sha": "0d28e06e53258cc592a104c01be868b0208f1b92", "filename": "src/test/ui/consts/issue-90870.fixed", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fconsts%2Fissue-90870.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fconsts%2Fissue-90870.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-90870.fixed?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -6,20 +6,20 @@\n \n const fn f(a: &u8, b: &u8) -> bool {\n     *a == *b\n-    //~^ ERROR: calls in constant functions are limited to constant functions, tuple structs and tuple variants [E0015]\n+    //~^ ERROR: cannot call non-const operator in constant functions [E0015]\n     //~| HELP: consider dereferencing here\n }\n \n const fn g(a: &&&&i64, b: &&&&i64) -> bool {\n     ****a == ****b\n-    //~^ ERROR: calls in constant functions are limited to constant functions, tuple structs and tuple variants [E0015]\n+    //~^ ERROR: cannot call non-const operator in constant functions [E0015]\n     //~| HELP: consider dereferencing here\n }\n \n const fn h(mut a: &[u8], mut b: &[u8]) -> bool {\n     while let ([l, at @ ..], [r, bt @ ..]) = (a, b) {\n         if *l == *r {\n-        //~^ ERROR: calls in constant functions are limited to constant functions, tuple structs and tuple variants [E0015]\n+        //~^ ERROR: cannot call non-const operator in constant functions [E0015]\n         //~| HELP: consider dereferencing here\n             a = at;\n             b = bt;"}, {"sha": "c6bfffd2c5c1567d17da4213ffbe59143140882f", "filename": "src/test/ui/consts/issue-90870.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fconsts%2Fissue-90870.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fconsts%2Fissue-90870.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-90870.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -6,20 +6,20 @@\n \n const fn f(a: &u8, b: &u8) -> bool {\n     a == b\n-    //~^ ERROR: calls in constant functions are limited to constant functions, tuple structs and tuple variants [E0015]\n+    //~^ ERROR: cannot call non-const operator in constant functions [E0015]\n     //~| HELP: consider dereferencing here\n }\n \n const fn g(a: &&&&i64, b: &&&&i64) -> bool {\n     a == b\n-    //~^ ERROR: calls in constant functions are limited to constant functions, tuple structs and tuple variants [E0015]\n+    //~^ ERROR: cannot call non-const operator in constant functions [E0015]\n     //~| HELP: consider dereferencing here\n }\n \n const fn h(mut a: &[u8], mut b: &[u8]) -> bool {\n     while let ([l, at @ ..], [r, bt @ ..]) = (a, b) {\n         if l == r {\n-        //~^ ERROR: calls in constant functions are limited to constant functions, tuple structs and tuple variants [E0015]\n+        //~^ ERROR: cannot call non-const operator in constant functions [E0015]\n         //~| HELP: consider dereferencing here\n             a = at;\n             b = bt;"}, {"sha": "478445cfb39c5f9c356ee5297636e005210ff5aa", "filename": "src/test/ui/consts/issue-90870.stderr", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fconsts%2Fissue-90870.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fconsts%2Fissue-90870.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-90870.stderr?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -1,31 +1,34 @@\n-error[E0015]: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n+error[E0015]: cannot call non-const operator in constant functions\n   --> $DIR/issue-90870.rs:8:5\n    |\n LL |     a == b\n    |     ^^^^^^\n    |\n+   = note: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n help: consider dereferencing here\n    |\n LL |     *a == *b\n    |     +     +\n \n-error[E0015]: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n+error[E0015]: cannot call non-const operator in constant functions\n   --> $DIR/issue-90870.rs:14:5\n    |\n LL |     a == b\n    |     ^^^^^^\n    |\n+   = note: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n help: consider dereferencing here\n    |\n LL |     ****a == ****b\n    |     ++++     ++++\n \n-error[E0015]: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n+error[E0015]: cannot call non-const operator in constant functions\n   --> $DIR/issue-90870.rs:21:12\n    |\n LL |         if l == r {\n    |            ^^^^^^\n    |\n+   = note: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n help: consider dereferencing here\n    |\n LL |         if *l == *r {"}, {"sha": "258997597ea9d91f8228ac5c61bbaf4e6bbb233e", "filename": "src/test/ui/consts/min_const_fn/bad_const_fn_body_ice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fbad_const_fn_body_ice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fbad_const_fn_body_ice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fbad_const_fn_body_ice.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -1,7 +1,7 @@\n const fn foo(a: i32) -> Vec<i32> {\n     vec![1, 2, 3]\n     //~^ ERROR allocations are not allowed\n-    //~| ERROR calls in constant functions\n+    //~| ERROR cannot call non-const fn\n }\n \n fn main() {}"}, {"sha": "74234108911dd198d40880018decf6baddbc0384", "filename": "src/test/ui/consts/min_const_fn/bad_const_fn_body_ice.stderr", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fbad_const_fn_body_ice.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fbad_const_fn_body_ice.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmin_const_fn%2Fbad_const_fn_body_ice.stderr?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -6,12 +6,13 @@ LL |     vec![1, 2, 3]\n    |\n    = note: this error originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n-error[E0015]: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n+error[E0015]: cannot call non-const fn `slice::<impl [i32]>::into_vec::<std::alloc::Global>` in constant functions\n   --> $DIR/bad_const_fn_body_ice.rs:2:5\n    |\n LL |     vec![1, 2, 3]\n    |     ^^^^^^^^^^^^^\n    |\n+   = note: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n    = note: this error originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace for more info)\n \n error: aborting due to 2 previous errors"}, {"sha": "b6f34b922fae51548a3956459853637246e7a67a", "filename": "src/test/ui/consts/mir_check_nonconst.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fconsts%2Fmir_check_nonconst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fconsts%2Fmir_check_nonconst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmir_check_nonconst.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -6,6 +6,6 @@ fn bar() -> Foo {\n }\n \n static foo: Foo = bar();\n-//~^ ERROR calls in statics are limited to constant functions, tuple structs and tuple variants\n+//~^ ERROR cannot call non-const fn\n \n fn main() {}"}, {"sha": "2bac995eebf090244cd229eb05479cabb795eec3", "filename": "src/test/ui/consts/mir_check_nonconst.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fconsts%2Fmir_check_nonconst.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fconsts%2Fmir_check_nonconst.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fmir_check_nonconst.stderr?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -1,8 +1,10 @@\n-error[E0015]: calls in statics are limited to constant functions, tuple structs and tuple variants\n+error[E0015]: cannot call non-const fn `bar` in statics\n   --> $DIR/mir_check_nonconst.rs:8:19\n    |\n LL | static foo: Foo = bar();\n    |                   ^^^^^\n+   |\n+   = note: calls in statics are limited to constant functions, tuple structs and tuple variants\n \n error: aborting due to previous error\n "}, {"sha": "4ef25bd1334f3b30a85d5a086f270d0435a9acf7", "filename": "src/test/ui/consts/unstable-const-fn-in-libcore.stderr", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fconsts%2Funstable-const-fn-in-libcore.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fconsts%2Funstable-const-fn-in-libcore.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Funstable-const-fn-in-libcore.stderr?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -1,8 +1,14 @@\n-error[E0015]: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n+error[E0015]: cannot call non-const closure in constant functions\n   --> $DIR/unstable-const-fn-in-libcore.rs:24:26\n    |\n LL |             Opt::None => f(),\n    |                          ^^^\n+   |\n+   = note: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n+help: consider further restricting this bound\n+   |\n+LL |     const fn unwrap_or_else<F: FnOnce() -> T + ~const std::ops::FnOnce<()>>(self, f: F) -> T {\n+   |                                              +++++++++++++++++++++++++++++\n \n error[E0493]: destructors cannot be evaluated at compile-time\n   --> $DIR/unstable-const-fn-in-libcore.rs:19:53"}, {"sha": "4b1cbe80c506dabfa6c7432f7d4def8caac36f69", "filename": "src/test/ui/deriving/deriving-associated-types.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fderiving%2Fderiving-associated-types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fderiving%2Fderiving-associated-types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fderiving%2Fderiving-associated-types.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -1,5 +1,4 @@\n // run-pass\n-// ignore-compare-mode-chalk\n pub trait DeclaredTrait {\n     type Type;\n }"}, {"sha": "da45f0d133deb955110f952a392c4acb68efb8dd", "filename": "src/test/ui/impl-trait/example-calendar.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fimpl-trait%2Fexample-calendar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fimpl-trait%2Fexample-calendar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fexample-calendar.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -1,5 +1,4 @@\n // run-pass\n-// ignore-compare-mode-chalk\n \n #![feature(fn_traits,\n            step_trait,"}, {"sha": "17a6a85787442cf8489e2bb712af3a57c4362ac6", "filename": "src/test/ui/impl-trait/issue-55872-2.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-2.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -1,5 +1,4 @@\n // edition:2018\n-// ignore-compare-mode-chalk\n \n #![feature(type_alias_impl_trait)]\n "}, {"sha": "b76b564dfb139352cd83be0a07b8d560c69b0d0d", "filename": "src/test/ui/impl-trait/issue-55872-2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872-2.stderr?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -1,11 +1,11 @@\n error[E0277]: the trait bound `impl Future<Output = [async output]>: Copy` is not satisfied\n-  --> $DIR/issue-55872-2.rs:14:20\n+  --> $DIR/issue-55872-2.rs:13:20\n    |\n LL |     fn foo<T>() -> Self::E {\n    |                    ^^^^^^^ the trait `Copy` is not implemented for `impl Future<Output = [async output]>`\n \n error: type parameter `T` is part of concrete type but not used in parameter list for the `impl Trait` type alias\n-  --> $DIR/issue-55872-2.rs:14:28\n+  --> $DIR/issue-55872-2.rs:13:28\n    |\n LL |       fn foo<T>() -> Self::E {\n    |  ____________________________^"}, {"sha": "183728b0f7f0a5224386c52da030a73c3899ea6d", "filename": "src/test/ui/impl-trait/issue-55872.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -1,4 +1,3 @@\n-// ignore-compare-mode-chalk\n #![feature(type_alias_impl_trait)]\n \n pub trait Bar {"}, {"sha": "39d870dc003bb580de5d2e8f0cc66cd99141bdd3", "filename": "src/test/ui/impl-trait/issue-55872.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissue-55872.stderr?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -1,5 +1,5 @@\n error: type parameter `T` is part of concrete type but not used in parameter list for the `impl Trait` type alias\n-  --> $DIR/issue-55872.rs:13:28\n+  --> $DIR/issue-55872.rs:12:28\n    |\n LL |       fn foo<T>() -> Self::E {\n    |  ____________________________^"}, {"sha": "b947fc1d2396faca035781daa60a7ed5b4dda046", "filename": "src/test/ui/impl-trait/issues/issue-65581.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-65581.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-65581.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fissues%2Fissue-65581.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -1,4 +1,5 @@\n // check-pass\n+// ignore-compare-mode-chalk\n \n #![allow(dead_code)]\n "}, {"sha": "60a2bf1e2d66083485e4539df7124141a9523d69", "filename": "src/test/ui/issues/issue-16538.mir.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fissues%2Fissue-16538.mir.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fissues%2Fissue-16538.mir.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-16538.mir.stderr?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -1,8 +1,10 @@\n-error[E0015]: calls in statics are limited to constant functions, tuple structs and tuple variants\n+error[E0015]: cannot call non-const fn `Y::foo` in statics\n   --> $DIR/issue-16538.rs:15:23\n    |\n LL | static foo: &Y::X = &*Y::foo(Y::x as *const Y::X);\n    |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: calls in statics are limited to constant functions, tuple structs and tuple variants\n \n error[E0133]: use of extern static is unsafe and requires unsafe function or block\n   --> $DIR/issue-16538.rs:15:30"}, {"sha": "2ba9dfa2bc5f844c62d484d8b4b80db45b1e37be", "filename": "src/test/ui/issues/issue-16538.thir.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fissues%2Fissue-16538.thir.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fissues%2Fissue-16538.thir.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-16538.thir.stderr?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -14,11 +14,13 @@ LL | static foo: &Y::X = &*Y::foo(Y::x as *const Y::X);\n    |\n    = note: extern statics are not controlled by the Rust type system: invalid data, aliasing violations or data races will cause undefined behavior\n \n-error[E0015]: calls in statics are limited to constant functions, tuple structs and tuple variants\n+error[E0015]: cannot call non-const fn `Y::foo` in statics\n   --> $DIR/issue-16538.rs:15:23\n    |\n LL | static foo: &Y::X = &*Y::foo(Y::x as *const Y::X);\n    |                       ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: calls in statics are limited to constant functions, tuple structs and tuple variants\n \n error: aborting due to 3 previous errors\n "}, {"sha": "7fe0900ed5fde143d23b9553d1a0208db49b357a", "filename": "src/test/ui/issues/issue-23122-1.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fissues%2Fissue-23122-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fissues%2Fissue-23122-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-23122-1.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -1,10 +1,10 @@\n-// ignore-compare-mode-chalk\n-\n trait Next {\n     type Next: Next;\n }\n \n-struct GetNext<T: Next> { t: T }\n+struct GetNext<T: Next> {\n+    t: T,\n+}\n \n impl<T: Next> Next for GetNext<T> {\n     type Next = <GetNext<T> as Next>::Next;"}, {"sha": "95e1f60d8b029b607d7dacc9a0785ce84f9c534c", "filename": "src/test/ui/issues/issue-23122-2.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fissues%2Fissue-23122-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fissues%2Fissue-23122-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-23122-2.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -1,9 +1,10 @@\n-// ignore-compare-mode-chalk\n trait Next {\n     type Next: Next;\n }\n \n-struct GetNext<T: Next> { t: T }\n+struct GetNext<T: Next> {\n+    t: T,\n+}\n \n impl<T: Next> Next for GetNext<T> {\n     type Next = <GetNext<T::Next> as Next>::Next;"}, {"sha": "7519e632d5446ac10cd64a698b6199bac31214ac", "filename": "src/test/ui/issues/issue-23122-2.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fissues%2Fissue-23122-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fissues%2Fissue-23122-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-23122-2.stderr?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -1,12 +1,12 @@\n error[E0275]: overflow evaluating the requirement `<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<T as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next: Sized`\n-  --> $DIR/issue-23122-2.rs:9:17\n+  --> $DIR/issue-23122-2.rs:10:17\n    |\n LL |     type Next = <GetNext<T::Next> as Next>::Next;\n    |                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n    = help: consider increasing the recursion limit by adding a `#![recursion_limit = \"256\"]` attribute to your crate (`issue_23122_2`)\n note: required because of the requirements on the impl of `Next` for `GetNext<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<T as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next as Next>::Next>`\n-  --> $DIR/issue-23122-2.rs:8:15\n+  --> $DIR/issue-23122-2.rs:9:15\n    |\n LL | impl<T: Next> Next for GetNext<T> {\n    |               ^^^^     ^^^^^^^^^^"}, {"sha": "ba12e1ad0211bffcbd8d9beff612c91d2749cccd", "filename": "src/test/ui/issues/issue-25901.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fissues%2Fissue-25901.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fissues%2Fissue-25901.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-25901.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -2,7 +2,7 @@ struct A;\n struct B;\n \n static S: &'static B = &A;\n-//~^ ERROR calls in statics are limited to constant functions\n+//~^ ERROR cannot perform deref coercion on `A` in statics\n \n use std::ops::Deref;\n "}, {"sha": "5c35250bc3f39e86454a4b4a3ed4f4c0749d39b1", "filename": "src/test/ui/issues/issue-25901.stderr", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fissues%2Fissue-25901.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fissues%2Fissue-25901.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-25901.stderr?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -1,8 +1,21 @@\n-error[E0015]: calls in statics are limited to constant functions, tuple structs and tuple variants\n+error[E0015]: cannot perform deref coercion on `A` in statics\n   --> $DIR/issue-25901.rs:4:24\n    |\n LL | static S: &'static B = &A;\n    |                        ^^\n+   |\n+   = note: attempting to deref into `B`\n+note: deref defined here\n+  --> $DIR/issue-25901.rs:10:5\n+   |\n+LL |     type Target = B;\n+   |     ^^^^^^^^^^^^^^^^\n+note: impl defined here, but it is not `const`\n+  --> $DIR/issue-25901.rs:9:1\n+   |\n+LL | impl Deref for A {\n+   | ^^^^^^^^^^^^^^^^\n+   = note: calls in statics are limited to constant functions, tuple structs and tuple variants\n \n error: aborting due to previous error\n "}, {"sha": "1241fb0b1f85f88bee59636c155911ea3e0fd0f5", "filename": "src/test/ui/issues/issue-28561.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fissues%2Fissue-28561.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fissues%2Fissue-28561.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-28561.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -1,5 +1,4 @@\n // check-pass\n-// ignore-compare-mode-chalk\n #[derive(Debug, Default, Eq, Hash, Ord, PartialEq, PartialOrd)]\n struct Array<T> {\n     f00: [T; 00],"}, {"sha": "8db9e00588564c3ca4c102feb72598ae6eb9429c", "filename": "src/test/ui/issues/issue-33187.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fissues%2Fissue-33187.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fissues%2Fissue-33187.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-33187.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -1,10 +1,15 @@\n // run-pass\n-// ignore-compare-mode-chalk\n+\n struct Foo<A: Repr>(<A as Repr>::Data);\n \n-impl<A> Copy for Foo<A> where <A as Repr>::Data: Copy { }\n-impl<A> Clone for Foo<A> where <A as Repr>::Data: Clone {\n-    fn clone(&self) -> Self { Foo(self.0.clone()) }\n+impl<A> Copy for Foo<A> where <A as Repr>::Data: Copy {}\n+impl<A> Clone for Foo<A>\n+where\n+    <A as Repr>::Data: Clone,\n+{\n+    fn clone(&self) -> Self {\n+        Foo(self.0.clone())\n+    }\n }\n \n trait Repr {\n@@ -15,5 +20,4 @@ impl<A> Repr for A {\n     type Data = u32;\n }\n \n-fn main() {\n-}\n+fn main() {}"}, {"sha": "9cae6cf5e7665ced8faeb73dab67ad3676e0b3c0", "filename": "src/test/ui/issues/issue-37051.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fissues%2Fissue-37051.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fissues%2Fissue-37051.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-37051.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -1,5 +1,4 @@\n // check-pass\n-// ignore-compare-mode-chalk\n \n #![feature(associated_type_defaults)]\n "}, {"sha": "ea27e7bd2508f9ecc26f7bf14dd65577c2dcd5ba", "filename": "src/test/ui/issues/issue-39559-2.stderr", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fissues%2Fissue-39559-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fissues%2Fissue-39559-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-39559-2.stderr?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -1,14 +1,18 @@\n-error[E0015]: calls in constants are limited to constant functions, tuple structs and tuple variants\n+error[E0015]: cannot call non-const fn `<Dim3 as Dim>::dim` in constants\n   --> $DIR/issue-39559-2.rs:14:24\n    |\n LL |     let array: [usize; Dim3::dim()]\n    |                        ^^^^^^^^^^^\n+   |\n+   = note: calls in constants are limited to constant functions, tuple structs and tuple variants\n \n-error[E0015]: calls in constants are limited to constant functions, tuple structs and tuple variants\n+error[E0015]: cannot call non-const fn `<Dim3 as Dim>::dim` in constants\n   --> $DIR/issue-39559-2.rs:16:15\n    |\n LL |         = [0; Dim3::dim()];\n    |               ^^^^^^^^^^^\n+   |\n+   = note: calls in constants are limited to constant functions, tuple structs and tuple variants\n \n error: aborting due to 2 previous errors\n "}, {"sha": "5809a56cd4b6b638d5f6811fd8b72d28aebae0ab", "filename": "src/test/ui/issues/issue-55796.nll.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fissues%2Fissue-55796.nll.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fissues%2Fissue-55796.nll.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-55796.nll.stderr?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -1,5 +1,5 @@\n error: lifetime may not live long enough\n-  --> $DIR/issue-55796.rs:18:9\n+  --> $DIR/issue-55796.rs:16:9\n    |\n LL | pub trait Graph<'a> {\n    |                 -- lifetime `'a` defined here\n@@ -8,7 +8,7 @@ LL |         Box::new(self.out_edges(u).map(|e| e.target()))\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ returning this value requires that `'a` must outlive `'static`\n \n error: lifetime may not live long enough\n-  --> $DIR/issue-55796.rs:23:9\n+  --> $DIR/issue-55796.rs:21:9\n    |\n LL | pub trait Graph<'a> {\n    |                 -- lifetime `'a` defined here"}, {"sha": "d802ce3b6cfbf88f70715c8436d79afd35c34e6a", "filename": "src/test/ui/issues/issue-55796.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fissues%2Fissue-55796.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fissues%2Fissue-55796.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-55796.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -1,5 +1,3 @@\n-// ignore-compare-mode-chalk\n-\n pub trait EdgeTrait<N> {\n     fn target(&self) -> N;\n }\n@@ -16,12 +14,12 @@ pub trait Graph<'a> {\n \n     fn out_neighbors(&'a self, u: &Self::Node) -> Box<dyn Iterator<Item = Self::Node>> {\n         Box::new(self.out_edges(u).map(|e| e.target()))\n-//~^ ERROR cannot infer\n+        //~^ ERROR cannot infer\n     }\n \n     fn in_neighbors(&'a self, u: &Self::Node) -> Box<dyn Iterator<Item = Self::Node>> {\n         Box::new(self.in_edges(u).map(|e| e.target()))\n-//~^ ERROR cannot infer\n+        //~^ ERROR cannot infer\n     }\n }\n "}, {"sha": "569a13f45bce8580fbd013d176e9bdf017e061fe", "filename": "src/test/ui/issues/issue-55796.stderr", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fissues%2Fissue-55796.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fissues%2Fissue-55796.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-55796.stderr?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -1,47 +1,47 @@\n error[E0495]: cannot infer an appropriate lifetime due to conflicting requirements\n-  --> $DIR/issue-55796.rs:18:9\n+  --> $DIR/issue-55796.rs:16:9\n    |\n LL |         Box::new(self.out_edges(u).map(|e| e.target()))\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n note: first, the lifetime cannot outlive the lifetime `'a` as defined here...\n-  --> $DIR/issue-55796.rs:7:17\n+  --> $DIR/issue-55796.rs:5:17\n    |\n LL | pub trait Graph<'a> {\n    |                 ^^\n-note: ...so that the type `Map<<Self as Graph<'a>>::EdgesIter, [closure@$DIR/issue-55796.rs:18:40: 18:54]>` will meet its required lifetime bounds\n-  --> $DIR/issue-55796.rs:18:9\n+note: ...so that the type `Map<<Self as Graph<'a>>::EdgesIter, [closure@$DIR/issue-55796.rs:16:40: 16:54]>` will meet its required lifetime bounds\n+  --> $DIR/issue-55796.rs:16:9\n    |\n LL |         Box::new(self.out_edges(u).map(|e| e.target()))\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: but, the lifetime must be valid for the static lifetime...\n note: ...so that the types are compatible\n-  --> $DIR/issue-55796.rs:18:9\n+  --> $DIR/issue-55796.rs:16:9\n    |\n LL |         Box::new(self.out_edges(u).map(|e| e.target()))\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: expected `Box<(dyn Iterator<Item = <Self as Graph<'a>>::Node> + 'static)>`\n               found `Box<dyn Iterator<Item = <Self as Graph<'a>>::Node>>`\n \n error[E0495]: cannot infer an appropriate lifetime due to conflicting requirements\n-  --> $DIR/issue-55796.rs:23:9\n+  --> $DIR/issue-55796.rs:21:9\n    |\n LL |         Box::new(self.in_edges(u).map(|e| e.target()))\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |\n note: first, the lifetime cannot outlive the lifetime `'a` as defined here...\n-  --> $DIR/issue-55796.rs:7:17\n+  --> $DIR/issue-55796.rs:5:17\n    |\n LL | pub trait Graph<'a> {\n    |                 ^^\n-note: ...so that the type `Map<<Self as Graph<'a>>::EdgesIter, [closure@$DIR/issue-55796.rs:23:39: 23:53]>` will meet its required lifetime bounds\n-  --> $DIR/issue-55796.rs:23:9\n+note: ...so that the type `Map<<Self as Graph<'a>>::EdgesIter, [closure@$DIR/issue-55796.rs:21:39: 21:53]>` will meet its required lifetime bounds\n+  --> $DIR/issue-55796.rs:21:9\n    |\n LL |         Box::new(self.in_edges(u).map(|e| e.target()))\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    = note: but, the lifetime must be valid for the static lifetime...\n note: ...so that the types are compatible\n-  --> $DIR/issue-55796.rs:23:9\n+  --> $DIR/issue-55796.rs:21:9\n    |\n LL |         Box::new(self.in_edges(u).map(|e| e.target()))\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^"}, {"sha": "36e9932602fb035ae668baa819915bbb57b88f7a", "filename": "src/test/ui/issues/issue-74564-if-expr-stack-overflow.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fissues%2Fissue-74564-if-expr-stack-overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fissues%2Fissue-74564-if-expr-stack-overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-74564-if-expr-stack-overflow.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -1,6 +1,5 @@\n // build-pass\n // ignore-tidy-filelength\n-// ignore-compare-mode-chalk\n #![crate_type = \"rlib\"]\n \n fn banana(v: &str) -> u32 {"}, {"sha": "cebcca944af82b9ef1524ed622476f6dc393e080", "filename": "src/test/ui/never_type/issue-52443.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fnever_type%2Fissue-52443.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fnever_type%2Fissue-52443.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Fissue-52443.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -8,7 +8,7 @@ fn main() {\n \n     [(); { for _ in 0usize.. {}; 0}];\n     //~^ ERROR `for` is not allowed in a `const`\n-    //~| ERROR calls in constants are limited to constant functions\n+    //~| ERROR cannot convert\n     //~| ERROR mutable references are not allowed in constants\n-    //~| ERROR calls in constants are limited to constant functions\n+    //~| ERROR cannot call non-const fn\n }"}, {"sha": "8c1755205f0253b82f6026b5d05f2508c4d831f0", "filename": "src/test/ui/never_type/issue-52443.stderr", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fnever_type%2Fissue-52443.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fnever_type%2Fissue-52443.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Fissue-52443.stderr?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -38,11 +38,18 @@ LL |     [(); loop { break }];\n    |                 expected `usize`, found `()`\n    |                 help: give it a value of the expected type: `break 42`\n \n-error[E0015]: calls in constants are limited to constant functions, tuple structs and tuple variants\n+error[E0015]: cannot convert `RangeFrom<usize>` into an iterator in constants\n   --> $DIR/issue-52443.rs:9:21\n    |\n LL |     [(); { for _ in 0usize.. {}; 0}];\n    |                     ^^^^^^^^\n+   |\n+note: impl defined here, but it is not `const`\n+  --> $SRC_DIR/core/src/iter/traits/collect.rs:LL:COL\n+   |\n+LL | impl<I: Iterator> IntoIterator for I {\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: calls in constants are limited to constant functions, tuple structs and tuple variants\n \n error[E0658]: mutable references are not allowed in constants\n   --> $DIR/issue-52443.rs:9:21\n@@ -53,11 +60,13 @@ LL |     [(); { for _ in 0usize.. {}; 0}];\n    = note: see issue #57349 <https://github.com/rust-lang/rust/issues/57349> for more information\n    = help: add `#![feature(const_mut_refs)]` to the crate attributes to enable\n \n-error[E0015]: calls in constants are limited to constant functions, tuple structs and tuple variants\n+error[E0015]: cannot call non-const fn `<RangeFrom<usize> as Iterator>::next` in constants\n   --> $DIR/issue-52443.rs:9:21\n    |\n LL |     [(); { for _ in 0usize.. {}; 0}];\n    |                     ^^^^^^^^\n+   |\n+   = note: calls in constants are limited to constant functions, tuple structs and tuple variants\n \n error: aborting due to 6 previous errors; 1 warning emitted\n "}, {"sha": "5109a0e4a683de41ab74b825f5589f5b709011dc", "filename": "src/test/ui/nll/ty-outlives/issue-53789-2.rs", "status": "modified", "additions": 30, "deletions": 29, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fissue-53789-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fissue-53789-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fissue-53789-2.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -1,16 +1,14 @@\n // Regression test for #53789.\n //\n // check-pass\n-// ignore-compare-mode-chalk\n \n+use std::cmp::Ord;\n use std::collections::BTreeMap;\n use std::ops::Range;\n-use std::cmp::Ord;\n \n macro_rules! valuetree {\n     () => {\n-        type ValueTree =\n-            <Self::Strategy as $crate::Strategy>::Value;\n+        type ValueTree = <Self::Strategy as $crate::Strategy>::Value;\n     };\n }\n \n@@ -41,7 +39,9 @@ macro_rules! product_type {\n macro_rules! default {\n     ($type: ty, $val: expr) => {\n         impl Default for $type {\n-            fn default() -> Self { $val.into() }\n+            fn default() -> Self {\n+                $val.into()\n+            }\n         }\n     };\n }\n@@ -90,21 +90,17 @@ trait ValueTree {\n }\n \n trait Strategy {\n-    type Value : ValueTree;\n+    type Value: ValueTree;\n }\n \n #[derive(Clone)]\n-struct VecStrategy<T : Strategy> {\n+struct VecStrategy<T: Strategy> {\n     element: T,\n     size: Range<usize>,\n }\n \n-fn vec<T : Strategy>(element: T, size: Range<usize>)\n-                     -> VecStrategy<T> {\n-    VecStrategy {\n-        element: element,\n-        size: size,\n-    }\n+fn vec<T: Strategy>(element: T, size: Range<usize>) -> VecStrategy<T> {\n+    VecStrategy { element: element, size: size }\n }\n \n type ValueFor<S> = <<S as Strategy>::Value as ValueTree>::Value;\n@@ -124,7 +120,6 @@ type StrategyType<'a, A> = <A as Arbitrary<'a>>::Strategy;\n struct SizeBounds(Range<usize>);\n default!(SizeBounds, 0..100);\n \n-\n impl From<Range<usize>> for SizeBounds {\n     fn from(high: Range<usize>) -> Self {\n         unimplemented!()\n@@ -137,24 +132,26 @@ impl From<SizeBounds> for Range<usize> {\n     }\n }\n \n-\n-fn any_with<'a, A: Arbitrary<'a>>(args: A::Parameters)\n-                                  -> StrategyType<'a, A> {\n+fn any_with<'a, A: Arbitrary<'a>>(args: A::Parameters) -> StrategyType<'a, A> {\n     unimplemented!()\n }\n \n-impl<K: ValueTree, V: ValueTree> Strategy for (K, V) where\n-    <K as ValueTree>::Value: Ord {\n+impl<K: ValueTree, V: ValueTree> Strategy for (K, V)\n+where\n+    <K as ValueTree>::Value: Ord,\n+{\n     type Value = TupleValueTree<(K, V)>;\n }\n \n-impl<K: ValueTree, V: ValueTree> ValueTree for TupleValueTree<(K, V)> where\n-    <K as ValueTree>::Value: Ord {\n+impl<K: ValueTree, V: ValueTree> ValueTree for TupleValueTree<(K, V)>\n+where\n+    <K as ValueTree>::Value: Ord,\n+{\n     type Value = BTreeMapValueTree<K, V>;\n }\n \n #[derive(Clone)]\n-struct VecValueTree<T : ValueTree> {\n+struct VecValueTree<T: ValueTree> {\n     elements: Vec<T>,\n }\n \n@@ -185,8 +182,8 @@ impl<'a, A, B> Arbitrary<'a> for BTreeMap<A, B>\n where\n     A: Arbitrary<'static> + Ord,\n     B: Arbitrary<'static>,\n-StrategyFor<A>: 'static,\n-StrategyFor<B>: 'static,\n+    StrategyFor<A>: 'static,\n+    StrategyFor<B>: 'static,\n {\n     valuetree!();\n     type Parameters = RangedParams2<A::Parameters, B::Parameters>;\n@@ -208,10 +205,14 @@ mapfn! {\n     }\n }\n \n-fn btree_map<K : Strategy + 'static, V : Strategy + 'static>\n-    (key: K, value: V, size: Range<usize>)\n-     -> BTreeMapStrategy<K, V>\n-where ValueFor<K> : Ord {\n+fn btree_map<K: Strategy + 'static, V: Strategy + 'static>(\n+    key: K,\n+    value: V,\n+    size: Range<usize>,\n+) -> BTreeMapStrategy<K, V>\n+where\n+    ValueFor<K>: Ord,\n+{\n     unimplemented!()\n }\n \n@@ -245,4 +246,4 @@ mod statics {\n     }\n }\n \n-fn main() { }\n+fn main() {}"}, {"sha": "24b9235bb9a76fe28359c1bbaa9604b367e53a44", "filename": "src/test/ui/rfc-2632-const-trait-impl/call-const-trait-method-fail.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fcall-const-trait-method-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fcall-const-trait-method-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fcall-const-trait-method-fail.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -22,7 +22,8 @@ pub const fn add_i32(a: i32, b: i32) -> i32 {\n \n pub const fn add_u32(a: u32, b: u32) -> u32 {\n     a.plus(b)\n-    //~^ ERROR calls in constant functions are limited to constant functions\n+    //~^ ERROR the trait bound\n+    //~| ERROR cannot call non-const fn\n }\n \n fn main() {}"}, {"sha": "1fc9db277610e5a45c483fe8ef6f8e04274816b6", "filename": "src/test/ui/rfc-2632-const-trait-impl/call-const-trait-method-fail.stderr", "status": "modified", "additions": 20, "deletions": 5, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fcall-const-trait-method-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fcall-const-trait-method-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fcall-const-trait-method-fail.stderr?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -1,9 +1,24 @@\n-error[E0015]: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n-  --> $DIR/call-const-trait-method-fail.rs:24:5\n+error[E0277]: the trait bound `u32: ~const Plus` is not satisfied\n+  --> $DIR/call-const-trait-method-fail.rs:24:7\n    |\n LL |     a.plus(b)\n-   |     ^^^^^^^^^\n+   |       ^^^^^^^ the trait `~const Plus` is not implemented for `u32`\n+   |\n+note: the trait `Plus` is implemented for `u32`, but that implementation is not `const`\n+  --> $DIR/call-const-trait-method-fail.rs:24:7\n+   |\n+LL |     a.plus(b)\n+   |       ^^^^^^^\n+\n+error[E0015]: cannot call non-const fn `<u32 as Plus>::plus` in constant functions\n+  --> $DIR/call-const-trait-method-fail.rs:24:7\n+   |\n+LL |     a.plus(b)\n+   |       ^^^^^^^\n+   |\n+   = note: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n \n-error: aborting due to previous error\n+error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0015`.\n+Some errors have detailed explanations: E0015, E0277.\n+For more information about an error, try `rustc --explain E0015`."}, {"sha": "e81e0d1e571c32283e6ad127683f2c8fb97d363c", "filename": "src/test/ui/rfc-2632-const-trait-impl/call-generic-method-fail.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fcall-generic-method-fail.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fcall-generic-method-fail.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fcall-generic-method-fail.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -3,7 +3,8 @@\n \n pub const fn equals_self<T: PartialEq>(t: &T) -> bool {\n     *t == *t\n-    //~^ ERROR calls in constant functions are limited to constant functions\n+    //~^ ERROR can't compare\n+    //~| ERROR cannot call non-const\n }\n \n fn main() {}"}, {"sha": "3963f64ad32b3b90b59cb9f2b9ae9b7588012b38", "filename": "src/test/ui/rfc-2632-const-trait-impl/call-generic-method-fail.stderr", "status": "modified", "additions": 22, "deletions": 3, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fcall-generic-method-fail.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fcall-generic-method-fail.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fcall-generic-method-fail.stderr?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -1,9 +1,28 @@\n-error[E0015]: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n+error[E0277]: can't compare `T` with `T` in const contexts\n+  --> $DIR/call-generic-method-fail.rs:5:5\n+   |\n+LL |     *t == *t\n+   |     ^^^^^^^^ no implementation for `T == T`\n+   |\n+note: the trait `PartialEq` is implemented for `T`, but that implementation is not `const`\n   --> $DIR/call-generic-method-fail.rs:5:5\n    |\n LL |     *t == *t\n    |     ^^^^^^^^\n \n-error: aborting due to previous error\n+error[E0015]: cannot call non-const operator in constant functions\n+  --> $DIR/call-generic-method-fail.rs:5:5\n+   |\n+LL |     *t == *t\n+   |     ^^^^^^^^\n+   |\n+   = note: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n+help: consider further restricting this bound\n+   |\n+LL | pub const fn equals_self<T: PartialEq + ~const std::cmp::PartialEq>(t: &T) -> bool {\n+   |                                       ++++++++++++++++++++++++++++\n+\n+error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0015`.\n+Some errors have detailed explanations: E0015, E0277.\n+For more information about an error, try `rustc --explain E0015`."}, {"sha": "b3e3dd62be804bfa406e7e432f989e2486499cd0", "filename": "src/test/ui/rfc-2632-const-trait-impl/const-check-fns-in-const-impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-check-fns-in-const-impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-check-fns-in-const-impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-check-fns-in-const-impl.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -9,7 +9,7 @@ fn non_const() {}\n \n impl const T for S {\n     fn foo() { non_const() }\n-    //~^ ERROR calls in constant functions\n+    //~^ ERROR cannot call non-const fn\n }\n \n fn main() {}"}, {"sha": "9e49785c589e16516a6aaa5ea2cfe1213de21061", "filename": "src/test/ui/rfc-2632-const-trait-impl/const-check-fns-in-const-impl.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-check-fns-in-const-impl.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-check-fns-in-const-impl.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-check-fns-in-const-impl.stderr?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -1,8 +1,10 @@\n-error[E0015]: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n+error[E0015]: cannot call non-const fn `non_const` in constant functions\n   --> $DIR/const-check-fns-in-const-impl.rs:11:16\n    |\n LL |     fn foo() { non_const() }\n    |                ^^^^^^^^^^^\n+   |\n+   = note: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n \n error: aborting due to previous error\n "}, {"sha": "3e87787a09195aedbdbc0fe420f33aad50a95663", "filename": "src/test/ui/rfc-2632-const-trait-impl/const-default-method-bodies.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-default-method-bodies.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-default-method-bodies.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-default-method-bodies.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -23,7 +23,8 @@ impl const ConstDefaultFn for ConstImpl {\n \n const fn test() {\n     NonConstImpl.a();\n-    //~^ ERROR calls in constant functions are limited to constant functions, tuple structs and tuple variants\n+    //~^ ERROR the trait bound\n+    //~| ERROR cannot call non-const fn\n     ConstImpl.a();\n }\n "}, {"sha": "948830d6def58f7388ccf8d5859f74fe410947cd", "filename": "src/test/ui/rfc-2632-const-trait-impl/const-default-method-bodies.stderr", "status": "modified", "additions": 20, "deletions": 5, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-default-method-bodies.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-default-method-bodies.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fconst-default-method-bodies.stderr?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -1,9 +1,24 @@\n-error[E0015]: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n-  --> $DIR/const-default-method-bodies.rs:25:5\n+error[E0277]: the trait bound `NonConstImpl: ~const ConstDefaultFn` is not satisfied\n+  --> $DIR/const-default-method-bodies.rs:25:18\n    |\n LL |     NonConstImpl.a();\n-   |     ^^^^^^^^^^^^^^^^\n+   |                  ^^^ the trait `~const ConstDefaultFn` is not implemented for `NonConstImpl`\n+   |\n+note: the trait `ConstDefaultFn` is implemented for `NonConstImpl`, but that implementation is not `const`\n+  --> $DIR/const-default-method-bodies.rs:25:18\n+   |\n+LL |     NonConstImpl.a();\n+   |                  ^^^\n+\n+error[E0015]: cannot call non-const fn `<NonConstImpl as ConstDefaultFn>::a` in constant functions\n+  --> $DIR/const-default-method-bodies.rs:25:18\n+   |\n+LL |     NonConstImpl.a();\n+   |                  ^^^\n+   |\n+   = note: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n \n-error: aborting due to previous error\n+error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0015`.\n+Some errors have detailed explanations: E0015, E0277.\n+For more information about an error, try `rustc --explain E0015`."}, {"sha": "3ca9abb139b86e03753ef05983a639b40360af8b", "filename": "src/test/ui/rfc-2632-const-trait-impl/cross-crate.gated.stderr", "status": "modified", "additions": 20, "deletions": 5, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fcross-crate.gated.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fcross-crate.gated.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fcross-crate.gated.stderr?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -1,9 +1,24 @@\n-error[E0015]: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n-  --> $DIR/cross-crate.rs:15:5\n+error[E0277]: the trait bound `cross_crate::NonConst: ~const cross_crate::MyTrait` is not satisfied\n+  --> $DIR/cross-crate.rs:15:14\n    |\n LL |     NonConst.func();\n-   |     ^^^^^^^^^^^^^^^\n+   |              ^^^^^^ the trait `~const cross_crate::MyTrait` is not implemented for `cross_crate::NonConst`\n+   |\n+note: the trait `cross_crate::MyTrait` is implemented for `cross_crate::NonConst`, but that implementation is not `const`\n+  --> $DIR/cross-crate.rs:15:14\n+   |\n+LL |     NonConst.func();\n+   |              ^^^^^^\n+\n+error[E0015]: cannot call non-const fn `<cross_crate::NonConst as cross_crate::MyTrait>::func` in constant functions\n+  --> $DIR/cross-crate.rs:15:14\n+   |\n+LL |     NonConst.func();\n+   |              ^^^^^^\n+   |\n+   = note: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n \n-error: aborting due to previous error\n+error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0015`.\n+Some errors have detailed explanations: E0015, E0277.\n+For more information about an error, try `rustc --explain E0015`."}, {"sha": "fa049ab86ff49c0b1016760e0e3618e7cf4b5463", "filename": "src/test/ui/rfc-2632-const-trait-impl/cross-crate.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fcross-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fcross-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fcross-crate.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -12,10 +12,10 @@ fn non_const_context() {\n }\n \n const fn const_context() {\n-    NonConst.func();\n-    //~^ ERROR: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n+    NonConst.func(); //~ ERROR: cannot call non-const fn\n+    //[gated]~^ ERROR: the trait bound\n     Const.func();\n-    //[stock]~^ ERROR: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n+    //[stock]~^ ERROR: cannot call non-const fn\n }\n \n fn main() {}"}, {"sha": "ea75ad0aeaf8c2eba9b92532aa86fa856f9a9833", "filename": "src/test/ui/rfc-2632-const-trait-impl/cross-crate.stock.stderr", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fcross-crate.stock.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fcross-crate.stock.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fcross-crate.stock.stderr?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -1,14 +1,18 @@\n-error[E0015]: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n-  --> $DIR/cross-crate.rs:15:5\n+error[E0015]: cannot call non-const fn `<cross_crate::NonConst as cross_crate::MyTrait>::func` in constant functions\n+  --> $DIR/cross-crate.rs:15:14\n    |\n LL |     NonConst.func();\n-   |     ^^^^^^^^^^^^^^^\n+   |              ^^^^^^\n+   |\n+   = note: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n \n-error[E0015]: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n-  --> $DIR/cross-crate.rs:17:5\n+error[E0015]: cannot call non-const fn `<cross_crate::Const as cross_crate::MyTrait>::func` in constant functions\n+  --> $DIR/cross-crate.rs:17:11\n    |\n LL |     Const.func();\n-   |     ^^^^^^^^^^^^\n+   |           ^^^^^^\n+   |\n+   = note: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n \n error: aborting due to 2 previous errors\n "}, {"sha": "4d087b5180be4c29cf259a646ecf83181eae0eaf", "filename": "src/test/ui/rfc-2632-const-trait-impl/default-method-body-is-const-same-trait-ck.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fdefault-method-body-is-const-same-trait-ck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fdefault-method-body-is-const-same-trait-ck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fdefault-method-body-is-const-same-trait-ck.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -8,7 +8,8 @@ pub trait Tr {\n     #[default_method_body_is_const]\n     fn b(&self) {\n         ().a()\n-        //~^ ERROR calls in constant functions are limited\n+        //~^ ERROR the trait bound\n+        //~| ERROR cannot call\n     }\n }\n "}, {"sha": "db4d61f88ab2f08a85e66bae320e31da06633aa5", "filename": "src/test/ui/rfc-2632-const-trait-impl/default-method-body-is-const-same-trait-ck.stderr", "status": "modified", "additions": 20, "deletions": 5, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fdefault-method-body-is-const-same-trait-ck.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fdefault-method-body-is-const-same-trait-ck.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fdefault-method-body-is-const-same-trait-ck.stderr?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -1,9 +1,24 @@\n-error[E0015]: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n-  --> $DIR/default-method-body-is-const-same-trait-ck.rs:10:9\n+error[E0277]: the trait bound `(): ~const Tr` is not satisfied\n+  --> $DIR/default-method-body-is-const-same-trait-ck.rs:10:12\n    |\n LL |         ().a()\n-   |         ^^^^^^\n+   |            ^^^ the trait `~const Tr` is not implemented for `()`\n+   |\n+note: the trait `Tr` is implemented for `()`, but that implementation is not `const`\n+  --> $DIR/default-method-body-is-const-same-trait-ck.rs:10:12\n+   |\n+LL |         ().a()\n+   |            ^^^\n+\n+error[E0015]: cannot call non-const fn `<() as Tr>::a` in constant functions\n+  --> $DIR/default-method-body-is-const-same-trait-ck.rs:10:12\n+   |\n+LL |         ().a()\n+   |            ^^^\n+   |\n+   = note: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n \n-error: aborting due to previous error\n+error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0015`.\n+Some errors have detailed explanations: E0015, E0277.\n+For more information about an error, try `rustc --explain E0015`."}, {"sha": "cbe3fe0ce5f3f461be5606e7687de5ef0ce92459", "filename": "src/test/ui/rfc-2632-const-trait-impl/issue-88155.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fissue-88155.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fissue-88155.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fissue-88155.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -7,7 +7,8 @@ pub trait A {\n \n pub const fn foo<T: A>() -> bool {\n     T::assoc()\n-    //~^ ERROR calls in constant functions are limited\n+    //~^ ERROR the trait bound\n+    //~| ERROR cannot call non-const fn\n }\n \n fn main() {}"}, {"sha": "931c0b3658fd9d4f0d26e30a29ca46fbc36b0256", "filename": "src/test/ui/rfc-2632-const-trait-impl/issue-88155.stderr", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fissue-88155.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fissue-88155.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fissue-88155.stderr?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -1,9 +1,24 @@\n-error[E0015]: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n+error[E0277]: the trait bound `T: ~const A` is not satisfied\n+  --> $DIR/issue-88155.rs:9:5\n+   |\n+LL |     T::assoc()\n+   |     ^^^^^^^^^^ the trait `~const A` is not implemented for `T`\n+   |\n+note: the trait `A` is implemented for `T`, but that implementation is not `const`\n+  --> $DIR/issue-88155.rs:9:5\n+   |\n+LL |     T::assoc()\n+   |     ^^^^^^^^^^\n+\n+error[E0015]: cannot call non-const fn `<T as A>::assoc` in constant functions\n   --> $DIR/issue-88155.rs:9:5\n    |\n LL |     T::assoc()\n    |     ^^^^^^^^^^\n+   |\n+   = note: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n \n-error: aborting due to previous error\n+error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0015`.\n+Some errors have detailed explanations: E0015, E0277.\n+For more information about an error, try `rustc --explain E0015`."}, {"sha": "2f54c09e31c9e023d5e31966b3f89f72762e8727", "filename": "src/test/ui/rfc-2632-const-trait-impl/std-impl-gate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fstd-impl-gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fstd-impl-gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fstd-impl-gate.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -11,7 +11,7 @@ fn non_const_context() -> Vec<usize> {\n \n const fn const_context() -> Vec<usize> {\n     Default::default()\n-    //[stock]~^ ERROR calls in constant functions are limited\n+    //[stock]~^ ERROR cannot call non-const fn\n }\n \n fn main() {"}, {"sha": "0b450a9474282bc5502f9ec2333e585b089da1cd", "filename": "src/test/ui/rfc-2632-const-trait-impl/std-impl-gate.stock.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fstd-impl-gate.stock.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fstd-impl-gate.stock.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Frfc-2632-const-trait-impl%2Fstd-impl-gate.stock.stderr?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -1,8 +1,10 @@\n-error[E0015]: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n+error[E0015]: cannot call non-const fn `<Vec<usize> as Default>::default` in constant functions\n   --> $DIR/std-impl-gate.rs:13:5\n    |\n LL |     Default::default()\n    |     ^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: calls in constant functions are limited to constant functions, tuple structs and tuple variants\n \n error: aborting due to previous error\n "}, {"sha": "c043114b565c8945a3ae406553c536775723e63d", "filename": "src/test/ui/specialization/default-associated-type-bound-1.rs", "status": "renamed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fspecialization%2Fdefault-associated-type-bound-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fspecialization%2Fdefault-associated-type-bound-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fdefault-associated-type-bound-1.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -1,6 +1,5 @@\n // Check that we check that default associated types satisfy the required\n // bounds on them.\n-// ignore-compare-mode-chalk\n \n #![feature(specialization)]\n //~^ WARNING `specialization` is incomplete", "previous_filename": "src/test/ui/specialization/deafult-associated-type-bound-1.rs"}, {"sha": "6680a29f94245eb27f5c1aa74230dd4f140c06b2", "filename": "src/test/ui/specialization/default-associated-type-bound-1.stderr", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fspecialization%2Fdefault-associated-type-bound-1.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fspecialization%2Fdefault-associated-type-bound-1.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fdefault-associated-type-bound-1.stderr?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -1,5 +1,5 @@\n warning: the feature `specialization` is incomplete and may not be safe to use and/or cause compiler crashes\n-  --> $DIR/deafult-associated-type-bound-1.rs:5:12\n+  --> $DIR/default-associated-type-bound-1.rs:4:12\n    |\n LL | #![feature(specialization)]\n    |            ^^^^^^^^^^^^^^\n@@ -9,13 +9,13 @@ LL | #![feature(specialization)]\n    = help: consider using `min_specialization` instead, which is more stable and complete\n \n error[E0277]: the trait bound `str: Clone` is not satisfied\n-  --> $DIR/deafult-associated-type-bound-1.rs:19:22\n+  --> $DIR/default-associated-type-bound-1.rs:18:22\n    |\n LL |     default type U = str;\n    |                      ^^^ the trait `Clone` is not implemented for `str`\n    |\n note: required by a bound in `X::U`\n-  --> $DIR/deafult-associated-type-bound-1.rs:9:13\n+  --> $DIR/default-associated-type-bound-1.rs:8:13\n    |\n LL |     type U: Clone;\n    |             ^^^^^ required by this bound in `X::U`", "previous_filename": "src/test/ui/specialization/deafult-associated-type-bound-1.stderr"}, {"sha": "0a21b1f09106ba36feeef0cd479eb277603586ba", "filename": "src/test/ui/specialization/default-associated-type-bound-2.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fspecialization%2Fdefault-associated-type-bound-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fspecialization%2Fdefault-associated-type-bound-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fdefault-associated-type-bound-2.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "previous_filename": "src/test/ui/specialization/deafult-associated-type-bound-2.rs"}, {"sha": "0fd1f65b0a2014709e6290cbca5c92964761853a", "filename": "src/test/ui/specialization/default-associated-type-bound-2.stderr", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fspecialization%2Fdefault-associated-type-bound-2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fspecialization%2Fdefault-associated-type-bound-2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fdefault-associated-type-bound-2.stderr?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -1,5 +1,5 @@\n warning: the feature `specialization` is incomplete and may not be safe to use and/or cause compiler crashes\n-  --> $DIR/deafult-associated-type-bound-2.rs:2:12\n+  --> $DIR/default-associated-type-bound-2.rs:2:12\n    |\n LL | #![feature(specialization)]\n    |            ^^^^^^^^^^^^^^\n@@ -9,14 +9,14 @@ LL | #![feature(specialization)]\n    = help: consider using `min_specialization` instead, which is more stable and complete\n \n error[E0277]: can't compare `&'static B` with `B`\n-  --> $DIR/deafult-associated-type-bound-2.rs:16:22\n+  --> $DIR/default-associated-type-bound-2.rs:16:22\n    |\n LL |     default type U = &'static B;\n    |                      ^^^^^^^^^^ no implementation for `&'static B == B`\n    |\n    = help: the trait `PartialEq<B>` is not implemented for `&'static B`\n note: required by a bound in `X::U`\n-  --> $DIR/deafult-associated-type-bound-2.rs:6:13\n+  --> $DIR/default-associated-type-bound-2.rs:6:13\n    |\n LL |     type U: PartialEq<T>;\n    |             ^^^^^^^^^^^^ required by this bound in `X::U`", "previous_filename": "src/test/ui/specialization/deafult-associated-type-bound-2.stderr"}, {"sha": "0f5714e996a17cef78e0dd3c6112882e72c57db3", "filename": "src/test/ui/specialization/default-generic-associated-type-bound.rs", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fspecialization%2Fdefault-generic-associated-type-bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fspecialization%2Fdefault-generic-associated-type-bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fdefault-generic-associated-type-bound.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "previous_filename": "src/test/ui/specialization/deafult-generic-associated-type-bound.rs"}, {"sha": "58c6667c8c7ad651b525da7ab18729a68df71862", "filename": "src/test/ui/specialization/default-generic-associated-type-bound.stderr", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fspecialization%2Fdefault-generic-associated-type-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fspecialization%2Fdefault-generic-associated-type-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fdefault-generic-associated-type-bound.stderr?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -1,5 +1,5 @@\n warning: the feature `specialization` is incomplete and may not be safe to use and/or cause compiler crashes\n-  --> $DIR/deafult-generic-associated-type-bound.rs:3:12\n+  --> $DIR/default-generic-associated-type-bound.rs:3:12\n    |\n LL | #![feature(specialization)]\n    |            ^^^^^^^^^^^^^^\n@@ -9,14 +9,14 @@ LL | #![feature(specialization)]\n    = help: consider using `min_specialization` instead, which is more stable and complete\n \n error[E0277]: can't compare `T` with `T`\n-  --> $DIR/deafult-generic-associated-type-bound.rs:18:26\n+  --> $DIR/default-generic-associated-type-bound.rs:18:26\n    |\n LL |     default type U<'a> = &'a T;\n    |                          ^^^^^ no implementation for `T == T`\n    |\n    = note: required because of the requirements on the impl of `PartialEq` for `&'a T`\n note: required by a bound in `X::U`\n-  --> $DIR/deafult-generic-associated-type-bound.rs:8:17\n+  --> $DIR/default-generic-associated-type-bound.rs:8:17\n    |\n LL |     type U<'a>: PartialEq<&'a Self> where Self: 'a;\n    |                 ^^^^^^^^^^^^^^^^^^^ required by this bound in `X::U`", "previous_filename": "src/test/ui/specialization/deafult-generic-associated-type-bound.stderr"}, {"sha": "84fc638a973cb58a1b3582138e59e81addc3b7fc", "filename": "src/test/ui/static/static-vec-repeat-not-constant.stderr", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fstatic%2Fstatic-vec-repeat-not-constant.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Fstatic%2Fstatic-vec-repeat-not-constant.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fstatic%2Fstatic-vec-repeat-not-constant.stderr?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -1,8 +1,10 @@\n-error[E0015]: calls in statics are limited to constant functions, tuple structs and tuple variants\n+error[E0015]: cannot call non-const fn `foo` in statics\n   --> $DIR/static-vec-repeat-not-constant.rs:3:25\n    |\n LL | static a: [isize; 2] = [foo(); 2];\n    |                         ^^^^^\n+   |\n+   = note: calls in statics are limited to constant functions, tuple structs and tuple variants\n \n error: aborting due to previous error\n "}, {"sha": "f936dc42f133d0af0fc012b06d855dd54b4be427", "filename": "src/test/ui/type-alias-impl-trait/issue-53598.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-53598.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-53598.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-53598.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -1,4 +1,3 @@\n-// ignore-compare-mode-chalk\n #![feature(type_alias_impl_trait)]\n \n use std::fmt::Debug;"}, {"sha": "9971c7e0e20ee16ee809ebb6318fb454f8233490", "filename": "src/test/ui/type-alias-impl-trait/issue-53598.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-53598.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-53598.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-53598.stderr?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -1,5 +1,5 @@\n error: type parameter `T` is part of concrete type but not used in parameter list for the `impl Trait` type alias\n-  --> $DIR/issue-53598.rs:20:42\n+  --> $DIR/issue-53598.rs:19:42\n    |\n LL |       fn foo<T: Debug>(_: T) -> Self::Item {\n    |  __________________________________________^"}, {"sha": "13a6b7c2f7ceb1706a27be93e232c557bcb26d7f", "filename": "src/test/ui/type-alias-impl-trait/issue-57700.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57700.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57700.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57700.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -1,4 +1,3 @@\n-// ignore-compare-mode-chalk\n #![feature(arbitrary_self_types)]\n #![feature(type_alias_impl_trait)]\n "}, {"sha": "b2e3f46f1f5823bebe23ad90879ee45f5c82c15d", "filename": "src/test/ui/type-alias-impl-trait/issue-57700.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57700.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57700.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-57700.stderr?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -1,5 +1,5 @@\n error: type parameter `impl Deref<Target = Self>` is part of concrete type but not used in parameter list for the `impl Trait` type alias\n-  --> $DIR/issue-57700.rs:16:58\n+  --> $DIR/issue-57700.rs:15:58\n    |\n LL |       fn foo(self: impl Deref<Target = Self>) -> Self::Bar {\n    |  __________________________________________________________^"}, {"sha": "badf35484f3604c737c38b56a64c575f34b4d988", "filename": "src/test/ui/type-alias-impl-trait/issue-60371.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60371.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60371.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60371.rs?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -1,5 +1,3 @@\n-// ignore-compare-mode-chalk\n-\n trait Bug {\n     type Item: Bug;\n "}, {"sha": "dc8a381aece9411300d61c334140986d94a65523", "filename": "src/test/ui/type-alias-impl-trait/issue-60371.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60371.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60371.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-60371.stderr?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -1,5 +1,5 @@\n error[E0658]: `impl Trait` in type aliases is unstable\n-  --> $DIR/issue-60371.rs:10:17\n+  --> $DIR/issue-60371.rs:8:17\n    |\n LL |     type Item = impl Bug;\n    |                 ^^^^^^^^\n@@ -8,7 +8,7 @@ LL |     type Item = impl Bug;\n    = help: add `#![feature(type_alias_impl_trait)]` to the crate attributes to enable\n \n error[E0277]: the trait bound `(): Bug` is not satisfied\n-  --> $DIR/issue-60371.rs:12:40\n+  --> $DIR/issue-60371.rs:10:40\n    |\n LL |     const FUN: fn() -> Self::Item = || ();\n    |                                        ^ the trait `Bug` is not implemented for `()`\n@@ -17,7 +17,7 @@ LL |     const FUN: fn() -> Self::Item = || ();\n              <&() as Bug>\n \n error: non-defining opaque type use in defining scope\n-  --> $DIR/issue-60371.rs:12:37\n+  --> $DIR/issue-60371.rs:10:37\n    |\n LL | impl Bug for &() {\n    |              - cannot use static lifetime; use a bound lifetime instead or remove the lifetime parameter from the opaque type"}, {"sha": "276587e7f13fb44357688411c4a2b3f3316bdcf7", "filename": "triagebot.toml", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/9a60099cc43c8a07abb280be323d1ed9afc27f2c/triagebot.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9a60099cc43c8a07abb280be323d1ed9afc27f2c/triagebot.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/triagebot.toml?ref=9a60099cc43c8a07abb280be323d1ed9afc27f2c", "patch": "@@ -113,6 +113,9 @@ trigger_files = [\n     \"src/tools/rustdoc-js\",\n     \"src/tools/rustdoc-themes\",\n ]\n+exclude_labels = [\n+    \"T-*\",\n+]\n \n [autolabel.\"T-compiler\"]\n trigger_files = [\n@@ -122,6 +125,9 @@ trigger_files = [\n     # Tests\n     \"src/test/ui\",\n ]\n+exclude_labels = [\n+    \"T-*\",\n+]\n \n [notify-zulip.\"I-prioritize\"]\n zulip_stream = 245100 # #t-compiler/wg-prioritization/alerts"}]}