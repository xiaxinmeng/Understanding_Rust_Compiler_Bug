{"sha": "dac73ad3c1b92f51cade8dbac4879ffb951ded3f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRhYzczYWQzYzFiOTJmNTFjYWRlOGRiYWM0ODc5ZmZiOTUxZGVkM2Y=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2014-08-06T15:12:03Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2014-08-07T22:12:36Z"}, "message": "Guide: Traits", "tree": {"sha": "d4e9032bb77bbde309e9036e8b03ebaba876c0ad", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d4e9032bb77bbde309e9036e8b03ebaba876c0ad"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/dac73ad3c1b92f51cade8dbac4879ffb951ded3f", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/dac73ad3c1b92f51cade8dbac4879ffb951ded3f", "html_url": "https://github.com/rust-lang/rust/commit/dac73ad3c1b92f51cade8dbac4879ffb951ded3f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/dac73ad3c1b92f51cade8dbac4879ffb951ded3f/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "057c9ae30ac968e7693d4748294bf0563ee346fa", "url": "https://api.github.com/repos/rust-lang/rust/commits/057c9ae30ac968e7693d4748294bf0563ee346fa", "html_url": "https://github.com/rust-lang/rust/commit/057c9ae30ac968e7693d4748294bf0563ee346fa"}], "stats": {"total": 364, "additions": 339, "deletions": 25}, "files": [{"sha": "c79689edcf1808ca753489527f4e7cee1d36c16a", "filename": "src/doc/guide.md", "status": "modified", "additions": 339, "deletions": 25, "changes": 364, "blob_url": "https://github.com/rust-lang/rust/blob/dac73ad3c1b92f51cade8dbac4879ffb951ded3f/src%2Fdoc%2Fguide.md", "raw_url": "https://github.com/rust-lang/rust/raw/dac73ad3c1b92f51cade8dbac4879ffb951ded3f/src%2Fdoc%2Fguide.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fguide.md?ref=dac73ad3c1b92f51cade8dbac4879ffb951ded3f", "patch": "@@ -3717,43 +3717,43 @@ let x: Result<f64, String> = Ok(2.3f64);\n let y: Result<f64, String> = Err(\"There was an error.\".to_string());\n ```\n \n-This particular Result will return an `int` if there's a success, and a\n+This particular Result will return an `f64` if there's a success, and a\n `String` if there's a failure. Let's write a function that uses `Result<T, E>`:\n \n ```{rust}\n-fn square_root(x: f64) -> Result<f64, String> {\n-    if x < 0.0f64 { return Err(\"x must be positive!\".to_string()); }\n+fn inverse(x: f64) -> Result<f64, String> {\n+    if x == 0.0f64 { return Err(\"x cannot be zero!\".to_string()); }\n \n-    Ok(x * (1.0f64 / 2.0f64))\n+    Ok(1.0f64 / x)\n }\n ```\n \n-We don't want to take the square root of a negative number, so we check\n-to make sure that's true. If it's not, then we return an `Err`, with a\n-message. If it's okay, we return an `Ok`, with the answer.\n+We don't want to take the inverse of zero, so we check to make sure that we\n+weren't passed one. If we weren't, then we return an `Err`, with a message. If\n+it's okay, we return an `Ok`, with the answer.\n \n Why does this matter? Well, remember how `match` does exhaustive matches?\n Here's how this function gets used:\n \n ```{rust}\n-# fn square_root(x: f64) -> Result<f64, String> {\n-#     if x < 0.0f64 { return Err(\"x must be positive!\".to_string()); }\n-#     Ok(x * (1.0f64 / 2.0f64))\n+# fn inverse(x: f64) -> Result<f64, String> {\n+#     if x == 0.0f64 { return Err(\"x cannot be zero!\".to_string()); }\n+#     Ok(1.0f64 / x)\n # }\n-let x = square_root(25.0f64);\n+let x = inverse(25.0f64);\n \n match x {\n-    Ok(x) => println!(\"The square root of 25 is {}\", x),\n+    Ok(x) => println!(\"The inverse of 25 is {}\", x),\n     Err(msg) => println!(\"Error: {}\", msg),\n }\n ```\n \n-The `match enforces that we handle the `Err` case. In addition, because the\n+The `match` enforces that we handle the `Err` case. In addition, because the\n answer is wrapped up in an `Ok`, we can't just use the result without doing\n the match:\n \n ```{rust,ignore}\n-let x = square_root(25.0f64);\n+let x = inverse(25.0f64);\n println!(\"{}\", x + 2.0f64); // error: binary operation `+` cannot be applied \n            // to type `core::result::Result<f64,collections::string::String>`\n ```\n@@ -3763,42 +3763,356 @@ floating point values. What if we wanted to handle 32 bit floating point as\n well? We'd have to write this:\n \n ```{rust}\n-fn square_root32(x: f32) -> Result<f32, String> {\n-    if x < 0.0f32 { return Err(\"x must be positive!\".to_string()); }\n+fn inverse32(x: f32) -> Result<f32, String> {\n+    if x == 0.0f32 { return Err(\"x cannot be zero!\".to_string()); }\n \n-    Ok(x * (1.0f32 / 2.0f32))\n+    Ok(1.0f32 / x)\n }\n ```\n \n Bummer. What we need is a **generic function**. Luckily, we can write one!\n However, it won't _quite_ work yet. Before we get into that, let's talk syntax.\n-A generic version of `square_root` would look something like this:\n+A generic version of `inverse` would look something like this:\n \n ```{rust,ignore}\n-fn square_root<T>(x: T) -> Result<T, String> {\n-    if x < 0.0 { return Err(\"x must be positive!\".to_string()); }\n+fn inverse<T>(x: T) -> Result<T, String> {\n+    if x == 0.0 { return Err(\"x cannot be zero!\".to_string()); }\n \n-    Ok(x * (1.0 / 2.0))\n+    Ok(1.0 / x)\n }\n ```\n \n-Just like how we had `Option<T>`, we use a similar syntax for `square_root<T>`.\n+Just like how we had `Option<T>`, we use a similar syntax for `inverse<T>`.\n We can then use `T` inside the rest of the signature: `x` has type `T`, and half\n of the `Result` has type `T`. However, if we try to compile that example, we'll get\n an error:\n \n ```{notrust,ignore}\n-error: binary operation `<` cannot be applied to type `T`\n+error: binary operation `==` cannot be applied to type `T`\n ```\n \n-Because `T` can be _any_ type, it may be a type that doesn't implement `<`,\n+Because `T` can be _any_ type, it may be a type that doesn't implement `==`,\n and therefore, the first line would be wrong. What do we do?\n \n To fix this example, we need to learn about another Rust feature: traits.\n \n # Traits\n \n-# Operators and built-in Traits\n+Do you remember the `impl` keyword, used to call a function with method\n+syntax?\n+\n+```{rust}\n+struct Circle {\n+    x: f64,\n+    y: f64,\n+    radius: f64,\n+}\n+\n+impl Circle {\n+    fn area(&self) -> f64 {\n+        std::f64::consts::PI * (self.radius * self.radius)\n+    }\n+}\n+```\n+\n+Traits are similar, except that we define a trait with just the method\n+signature, then implement the trait for that struct. Like this:\n+\n+```{rust}\n+struct Circle {\n+    x: f64,\n+    y: f64,\n+    radius: f64,\n+}\n+\n+trait HasArea {\n+    fn area(&self) -> f64;\n+}\n+\n+impl HasArea for Circle {\n+    fn area(&self) -> f64 {\n+        std::f64::consts::PI * (self.radius * self.radius)\n+    }\n+}\n+```\n+\n+As you can see, the `trait` block looks very similar to the `impl` block,\n+but we don't define a body, just a type signature. When we `impl` a trait,\n+we use `impl Trait for Item`, rather than just `impl Item`.\n+\n+So what's the big deal? Remember the error we were getting with our generic\n+`inverse` function?\n+\n+```{notrust,ignore}\n+error: binary operation `==` cannot be applied to type `T`\n+```\n+\n+We can use traits to constrain our generics. Consider this function, which\n+does not compile, and gives us a similar error:\n+\n+```{rust,ignore}\n+fn print_area<T>(shape: T) {\n+    println!(\"This shape has an area of {}\", shape.area());\n+}\n+```\n+\n+Rust complains:\n+\n+```{notrust,ignore}\n+error: type `T` does not implement any method in scope named `area`\n+```\n+\n+Because `T` can be any type, we can't be sure that it implements the `area`\n+method. But we can add a **trait constraint** to our generic `T`, ensuring\n+that it does:\n+\n+```{rust}\n+# trait HasArea {\n+#     fn area(&self) -> f64;\n+# }\n+fn print_area<T: HasArea>(shape: T) {\n+    println!(\"This shape has an area of {}\", shape.area());\n+}\n+```\n+\n+The syntax `<T: HasArea>` means `any type that implements the HasArea trait`.\n+Because traits define function type signatures, we can be sure that any type\n+which implements `HasArea` will have an `.area()` method.\n+\n+Here's an extended example of how this works:\n+\n+```{rust}\n+trait HasArea {\n+    fn area(&self) -> f64;\n+}\n+\n+struct Circle {\n+    x: f64,\n+    y: f64,\n+    radius: f64,\n+}\n+\n+impl HasArea for Circle {\n+    fn area(&self) -> f64 {\n+        std::f64::consts::PI * (self.radius * self.radius)\n+    }\n+}\n+\n+struct Square {\n+    x: f64,\n+    y: f64,\n+    side: f64,\n+}\n+\n+impl HasArea for Square {\n+    fn area(&self) -> f64 {\n+        self.side * self.side\n+    }\n+}\n+\n+fn print_area<T: HasArea>(shape: T) {\n+    println!(\"This shape has an area of {}\", shape.area());\n+}\n+\n+fn main() {\n+    let c = Circle {\n+        x: 0.0f64,\n+        y: 0.0f64,\n+        radius: 1.0f64,\n+    };\n+\n+    let s = Square {\n+        x: 0.0f64,\n+        y: 0.0f64,\n+        side: 1.0f64,\n+    };\n+\n+    print_area(c);\n+    print_area(s);\n+}\n+```\n+\n+This program outputs:\n+\n+```{notrust,ignore}\n+This shape has an area of 3.141593\n+This shape has an area of 1\n+```\n+\n+As you can see, `print_area` is now generic, but also ensures that we\n+have passed in the correct types. If we pass in an incorrect type:\n+\n+```{rust,ignore}\n+print_area(5i);\n+```\n+\n+We get a compile-time error:\n+\n+```{notrust,ignore}\n+error: failed to find an implementation of trait main::HasArea for int\n+```\n+\n+So far, we've only added trait implementations to structs, but you can\n+implement a trait for any type. So technically, we _could_ implement\n+`HasArea` for `int`:\n+\n+```{rust}\n+trait HasArea {\n+    fn area(&self) -> f64;\n+}\n+\n+impl HasArea for int {\n+    fn area(&self) -> f64 {\n+        println!(\"this is silly\");\n+\n+        *self as f64\n+    }\n+}\n+\n+5i.area();\n+```\n+\n+It is considered poor style to implement methods on such primitive types, even\n+though it is possible.\n+\n+This may seem like the Wild West, but there are two other restrictions around\n+implementing traits that prevent this from getting out of hand. First, traits\n+must be `use`d in any scope where you wish to use the trait's method. So for\n+example, this does not work:\n+\n+```{rust,ignore}\n+mod shapes {\n+    use std::f64::consts;\n+\n+    trait HasArea {\n+        fn area(&self) -> f64;\n+    }\n+\n+    struct Circle {\n+        x: f64,\n+        y: f64,\n+        radius: f64,\n+    }\n+\n+    impl HasArea for Circle {\n+        fn area(&self) -> f64 {\n+            consts::PI * (self.radius * self.radius)\n+        }\n+    }\n+}\n+\n+fn main() {\n+    let c = shapes::Circle {\n+        x: 0.0f64,\n+        y: 0.0f64,\n+        radius: 1.0f64,\n+    };\n+\n+    println!(\"{}\", c.area());\n+}\n+```\n+\n+Now that we've moved the structs and traits into their own module, we get an\n+error:\n+\n+```{notrust,ignore}\n+error: type `shapes::Circle` does not implement any method in scope named `area`\n+```\n+\n+If we add a `use` line right above `main` and make the right things public,\n+everything is fine:\n+\n+```{rust}\n+use shapes::HasArea;\n+\n+mod shapes {\n+    use std::f64::consts;\n+\n+    pub trait HasArea {\n+        fn area(&self) -> f64;\n+    }\n+\n+    pub struct Circle {\n+        pub x: f64,\n+        pub y: f64,\n+        pub radius: f64,\n+    }\n+\n+    impl HasArea for Circle {\n+        fn area(&self) -> f64 {\n+            consts::PI * (self.radius * self.radius)\n+        }\n+    }\n+}\n+\n+\n+fn main() {\n+    let c = shapes::Circle {\n+        x: 0.0f64,\n+        y: 0.0f64,\n+        radius: 1.0f64,\n+    };\n+\n+    println!(\"{}\", c.area());\n+}\n+```\n+\n+This means that even if someone does something bad like add methods to `int`,\n+it won't affect you, unless you `use` that trait.\n+\n+There's one more restriction on implementing traits. Either the trait or the\n+type you're writing the `impl` for must be inside your crate. So, we could\n+implement the `HasArea` type for `int`, because `HasArea` is in our crate.  But\n+if we tried to implement `Float`, a trait provided by Rust, for `int`, we could\n+not, because both the trait and the type aren't in our crate.\n+\n+One last thing about traits: generic functions with a trait bound use\n+**monomorphization** (\"mono\": one, \"morph\": form), so they are statically\n+dispatched. What's that mean? Well, let's take a look at `print_area` again:\n+\n+```{rust,ignore}\n+fn print_area<T: HasArea>(shape: T) {\n+    println!(\"This shape has an area of {}\", shape.area());\n+}\n+\n+fn main() {\n+    let c = Circle { ... };\n+\n+    let s = Square { ... };\n+\n+    print_area(c);\n+    print_area(s);\n+}\n+```\n+\n+When we use this trait with `Circle` and `Square`, Rust ends up generating\n+two different functions with the concrete type, and replacing the call sites with\n+calls to the concrete implementations. In other words, you get something like\n+this:\n+\n+```{rust,ignore}\n+fn __print_area_circle(shape: Circle) {\n+    println!(\"This shape has an area of {}\", shape.area());\n+}\n+\n+fn __print_area_square(shape: Square) {\n+    println!(\"This shape has an area of {}\", shape.area());\n+}\n+\n+fn main() {\n+    let c = Circle { ... };\n+\n+    let s = Square { ... };\n+\n+    __print_area_circle(c);\n+    __print_area_square(s);\n+}\n+```\n+\n+The names don't actually change to this, it's just for illustration. But\n+as you can see, there's no overhead of deciding which version to call here,\n+hence 'statically dispatched.' The downside is that we have two copies of\n+the same function, so our binary is a little bit larger.\n \n # Tasks\n "}]}