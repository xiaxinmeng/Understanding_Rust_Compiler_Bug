{"sha": "49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ5Yzc0NTI0ZTJjNWEyYTgxY2U0Y2JlMmM1MGE1MDdjMGJlOWYyNGU=", "commit": {"author": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-06-17T23:43:22Z"}, "committer": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-06-21T07:20:22Z"}, "message": "vec: rm old_iter implementations, except BaseIter\n\nThe removed test for issue #2611 is well covered by the `std::iterator`\nmodule itself.\n\nThis adds the `count` method to `IteratorUtil` to replace `EqIter`.", "tree": {"sha": "441c718864c414bd4f7750c2435edc100e4a1841", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/441c718864c414bd4f7750c2435edc100e4a1841"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "html_url": "https://github.com/rust-lang/rust/commit/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/comments", "author": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "committer": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cbad1da3db7eda0911e988fb6255ac5c16961aa7", "url": "https://api.github.com/repos/rust-lang/rust/commits/cbad1da3db7eda0911e988fb6255ac5c16961aa7", "html_url": "https://github.com/rust-lang/rust/commit/cbad1da3db7eda0911e988fb6255ac5c16961aa7"}], "stats": {"total": 800, "additions": 310, "deletions": 490}, "files": [{"sha": "97c85a5c436c0c2530d997b3cb74db41c0391400", "filename": "doc/tutorial-tasks.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/doc%2Ftutorial-tasks.md", "raw_url": "https://github.com/rust-lang/rust/raw/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/doc%2Ftutorial-tasks.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Ftutorial-tasks.md?ref=49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "patch": "@@ -283,7 +283,7 @@ let ports = do vec::from_fn(3) |init_val| {\n };\n \n // Wait on each port, accumulating the results\n-let result = ports.foldl(0, |accum, port| *accum + port.recv() );\n+let result = ports.iter().fold(0, |accum, port| accum + port.recv() );\n # fn some_expensive_computation(_i: uint) -> int { 42 }\n ~~~\n "}, {"sha": "940c89bb0c682214b36211be63b095f932348ff3", "filename": "src/libextra/bitv.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibextra%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibextra%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbitv.rs?ref=49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "patch": "@@ -639,7 +639,7 @@ impl BitvSet {\n         if self.capacity() < other.capacity() {\n             self.bitv.storage.grow(other.capacity() / uint::bits, &0);\n         }\n-        for other.bitv.storage.eachi |i, &w| {\n+        for other.bitv.storage.iter().enumerate().advance |(i, &w)| {\n             let old = self.bitv.storage[i];\n             let new = f(old, w);\n             self.bitv.storage[i] = new;\n@@ -672,7 +672,7 @@ impl BaseIter<uint> for BitvSet {\n     fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n \n     fn each(&self, blk: &fn(v: &uint) -> bool) -> bool {\n-        for self.bitv.storage.eachi |i, &w| {\n+        for self.bitv.storage.iter().enumerate().advance |(i, &w)| {\n             if !iterate_bits(i * uint::bits, w, |b| blk(&b)) {\n                 return false;\n             }\n@@ -826,7 +826,7 @@ impl BitvSet {\n                    f: &fn(uint, uint, uint) -> bool) -> bool {\n         let min = uint::min(self.bitv.storage.len(),\n                             other.bitv.storage.len());\n-        self.bitv.storage.slice(0, min).eachi(|i, &w| {\n+        self.bitv.storage.slice(0, min).iter().enumerate().advance(|(i, &w)| {\n             f(i * uint::bits, w, other.bitv.storage[i])\n         })\n     }\n@@ -845,12 +845,12 @@ impl BitvSet {\n         let min = uint::min(len1, len2);\n \n         /* only one of these loops will execute and that's the point */\n-        for self.bitv.storage.slice(min, len1).eachi |i, &w| {\n+        for self.bitv.storage.slice(min, len1).iter().enumerate().advance |(i, &w)| {\n             if !f(true, (i + min) * uint::bits, w) {\n                 return false;\n             }\n         }\n-        for other.bitv.storage.slice(min, len2).eachi |i, &w| {\n+        for other.bitv.storage.slice(min, len2).iter().enumerate().advance |(i, &w)| {\n             if !f(false, (i + min) * uint::bits, w) {\n                 return false;\n             }"}, {"sha": "46646e2af5635fbe7612f42560f34dfe05f449f6", "filename": "src/libextra/fileinput.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibextra%2Ffileinput.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibextra%2Ffileinput.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ffileinput.rs?ref=49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "patch": "@@ -448,7 +448,7 @@ mod test {\n             |i| fmt!(\"tmp/lib-fileinput-test-fileinput-read-byte-%u.tmp\", i)), true);\n \n         // 3 files containing 0\\n, 1\\n, and 2\\n respectively\n-        for filenames.eachi |i, &filename| {\n+        for filenames.iter().enumerate().advance |(i, &filename)| {\n             make_file(filename.get_ref(), [fmt!(\"%u\", i)]);\n         }\n \n@@ -478,7 +478,7 @@ mod test {\n             |i| fmt!(\"tmp/lib-fileinput-test-fileinput-read-%u.tmp\", i)), true);\n \n         // 3 files containing 1\\n, 2\\n, and 3\\n respectively\n-        for filenames.eachi |i, &filename| {\n+        for filenames.iter().enumerate().advance |(i, &filename)| {\n             make_file(filename.get_ref(), [fmt!(\"%u\", i)]);\n         }\n \n@@ -498,7 +498,7 @@ mod test {\n             3,\n             |i| fmt!(\"tmp/lib-fileinput-test-input-vec-%u.tmp\", i)), true);\n \n-        for filenames.eachi |i, &filename| {\n+        for filenames.iter().enumerate().advance |(i, &filename)| {\n             let contents =\n                 vec::from_fn(3, |j| fmt!(\"%u %u\", i, j));\n             make_file(filename.get_ref(), contents);\n@@ -518,7 +518,7 @@ mod test {\n             3,\n             |i| fmt!(\"tmp/lib-fileinput-test-input-vec-state-%u.tmp\", i)),true);\n \n-        for filenames.eachi |i, &filename| {\n+        for filenames.iter().enumerate().advance |(i, &filename)| {\n             let contents =\n                 vec::from_fn(3, |j| fmt!(\"%u %u\", i, j + 1));\n             make_file(filename.get_ref(), contents);\n@@ -582,7 +582,7 @@ mod test {\n             3,\n             |i| fmt!(\"tmp/lib-fileinput-test-next-file-%u.tmp\", i)),true);\n \n-        for filenames.eachi |i, &filename| {\n+        for filenames.iter().enumerate().advance |(i, &filename)| {\n             let contents =\n                 vec::from_fn(3, |j| fmt!(\"%u %u\", i, j + 1));\n             make_file(&filename.get(), contents);"}, {"sha": "60fbfdeb62c167cc2bf3eb02ef2e92a42d3f69eb", "filename": "src/libextra/flatpipes.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibextra%2Fflatpipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibextra%2Fflatpipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fflatpipes.rs?ref=49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "patch": "@@ -307,11 +307,11 @@ impl<T,U:Unflattener<T>,P:BytePort> GenericPort<T> for FlatPort<T, U, P> {\n \n impl<T,F:Flattener<T>,C:ByteChan> GenericChan<T> for FlatChan<T, F, C> {\n     fn send(&self, val: T) {\n-        self.byte_chan.send(CONTINUE.to_vec());\n+        self.byte_chan.send(CONTINUE.to_owned());\n         let bytes = self.flattener.flatten(val);\n         let len = bytes.len() as u64;\n         do io::u64_to_be_bytes(len, size_of::<u64>()) |len_bytes| {\n-            self.byte_chan.send(len_bytes.to_vec());\n+            self.byte_chan.send(len_bytes.to_owned());\n         }\n         self.byte_chan.send(bytes);\n     }\n@@ -937,7 +937,7 @@ mod test {\n         fn test_try_recv_none3<P:BytePort>(loader: PortLoader<P>) {\n             static CONTINUE: [u8, ..4] = [0xAA, 0xBB, 0xCC, 0xDD];\n             // The control word is followed by garbage\n-            let bytes = CONTINUE.to_vec() + [0];\n+            let bytes = CONTINUE.to_owned() + [0];\n             let port = loader(bytes);\n             let res: Option<int> = port.try_recv();\n             assert!(res.is_none());\n@@ -959,9 +959,9 @@ mod test {\n                 // then undeserializable garbage\n                 let len_bytes = do io::u64_to_be_bytes(\n                     1, sys::size_of::<u64>()) |len_bytes| {\n-                    len_bytes.to_vec()\n+                    len_bytes.to_owned()\n                 };\n-                let bytes = CONTINUE.to_vec() + len_bytes + [0, 0, 0, 0];\n+                let bytes = CONTINUE.to_owned() + len_bytes + [0, 0, 0, 0];\n \n                 let port = loader(bytes);\n "}, {"sha": "91c357088c98ba335962f7e58327d6ec688d570d", "filename": "src/libextra/net_ip.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibextra%2Fnet_ip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibextra%2Fnet_ip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnet_ip.rs?ref=49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "patch": "@@ -205,7 +205,7 @@ pub mod v4 {\n         }).collect();\n         if parts.len() != 4 {\n             Err(fmt!(\"'%s' doesn't have 4 parts\", ip))\n-        } else if parts.contains(&256) {\n+        } else if parts.iter().any_(|x| *x == 256u) {\n             Err(fmt!(\"invalid octal in addr '%s'\", ip))\n         } else {\n             Ok(Ipv4Rep {"}, {"sha": "d443401217899fb09072c394ccb9d0bce0b656d0", "filename": "src/libextra/net_tcp.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibextra%2Fnet_tcp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibextra%2Fnet_tcp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnet_tcp.rs?ref=49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "patch": "@@ -978,7 +978,7 @@ impl io::Writer for TcpSocketBuf {\n         let w_result = write_common_impl(socket_data_ptr,\n                                          vec::slice(data,\n                                                     0,\n-                                                    data.len()).to_vec());\n+                                                    data.len()).to_owned());\n         if w_result.is_err() {\n             let err_data = w_result.get_err();\n             debug!("}, {"sha": "289f3888f6380cdfa66259263304a7b710978fee", "filename": "src/libextra/net_url.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibextra%2Fnet_url.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibextra%2Fnet_url.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnet_url.rs?ref=49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "patch": "@@ -519,8 +519,9 @@ fn get_authority(rawurl: &str) ->\n     let end = end; // make end immutable so it can be captured\n \n     let host_is_end_plus_one: &fn() -> bool = || {\n+        let xs = ['?', '#', '/'];\n         end+1 == len\n-            && !['?', '#', '/'].contains(&(rawurl[end] as char))\n+            && !xs.iter().any_(|x| *x == (rawurl[end] as char))\n     };\n \n     // finish up"}, {"sha": "7ec2bd8b9b6ffdc8d41f0852fd010db560c760dd", "filename": "src/libextra/num/bigint.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibextra%2Fnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibextra%2Fnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fnum%2Fbigint.rs?ref=49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "patch": "@@ -1175,8 +1175,8 @@ mod biguint_tests {\n     fn test_cmp() {\n         let data = [ &[], &[1], &[2], &[-1], &[0, 1], &[2, 1], &[1, 1, 1]  ]\n             .map(|v| BigUint::from_slice(*v));\n-        for data.eachi |i, ni| {\n-            for vec::slice(data, i, data.len()).eachi |j0, nj| {\n+        for data.iter().enumerate().advance |(i, ni)| {\n+            for vec::slice(data, i, data.len()).iter().enumerate().advance |(j0, nj)| {\n                 let j = j0 + i;\n                 if i == j {\n                     assert_eq!(ni.cmp(nj), Equal);\n@@ -1651,8 +1651,8 @@ mod bigint_tests {\n         nums.push(Zero::zero());\n         nums.push_all_move(vs.map(|s| BigInt::from_slice(Plus, *s)));\n \n-        for nums.eachi |i, ni| {\n-            for vec::slice(nums, i, nums.len()).eachi |j0, nj| {\n+        for nums.iter().enumerate().advance |(i, ni)| {\n+            for vec::slice(nums, i, nums.len()).iter().enumerate().advance |(j0, nj)| {\n                 let j = i + j0;\n                 if i == j {\n                     assert_eq!(ni.cmp(nj), Equal);"}, {"sha": "34fd7e9f1ec12e20777da2043d80081a3d6ee180", "filename": "src/libextra/serialize.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibextra%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibextra%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fserialize.rs?ref=49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "patch": "@@ -432,7 +432,7 @@ impl<D:Decoder,T:Decodable<D>> Decodable<D> for @T {\n impl<'self, S:Encoder,T:Encodable<S>> Encodable<S> for &'self [T] {\n     fn encode(&self, s: &mut S) {\n         do s.emit_seq(self.len()) |s| {\n-            for self.eachi |i, e| {\n+            for self.iter().enumerate().advance |(i, e)| {\n                 s.emit_seq_elt(i, |s| e.encode(s))\n             }\n         }\n@@ -442,7 +442,7 @@ impl<'self, S:Encoder,T:Encodable<S>> Encodable<S> for &'self [T] {\n impl<S:Encoder,T:Encodable<S>> Encodable<S> for ~[T] {\n     fn encode(&self, s: &mut S) {\n         do s.emit_seq(self.len()) |s| {\n-            for self.eachi |i, e| {\n+            for self.iter().enumerate().advance |(i, e)| {\n                 s.emit_seq_elt(i, |s| e.encode(s))\n             }\n         }\n@@ -462,7 +462,7 @@ impl<D:Decoder,T:Decodable<D>> Decodable<D> for ~[T] {\n impl<S:Encoder,T:Encodable<S>> Encodable<S> for @[T] {\n     fn encode(&self, s: &mut S) {\n         do s.emit_seq(self.len()) |s| {\n-            for self.eachi |i, e| {\n+            for self.iter().enumerate().advance |(i, e)| {\n                 s.emit_seq_elt(i, |s| e.encode(s))\n             }\n         }\n@@ -901,7 +901,7 @@ pub trait EncoderHelpers {\n impl<S:Encoder> EncoderHelpers for S {\n     fn emit_from_vec<T>(&mut self, v: &[T], f: &fn(&mut S, &T)) {\n         do self.emit_seq(v.len()) |this| {\n-            for v.eachi |i, e| {\n+            for v.iter().enumerate().advance |(i, e)| {\n                 do this.emit_seq_elt(i) |this| {\n                     f(this, e)\n                 }"}, {"sha": "df5e8b2f176ee93d01e0acdee22c22fc31bed2fa", "filename": "src/libextra/sort.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibextra%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibextra%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fsort.rs?ref=49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "patch": "@@ -731,7 +731,7 @@ fn copy_vec<T:Copy>(dest: &mut [T],\n                     from: &[T]) {\n     assert!(s1+from.len() <= dest.len());\n \n-    for from.eachi |i, v| {\n+    for from.iter().enumerate().advance |(i, v)| {\n         dest[s1+i] = copy *v;\n     }\n }\n@@ -743,7 +743,7 @@ fn shift_vec<T:Copy>(dest: &mut [T],\n                      len: uint) {\n     assert!(s1+len <= dest.len());\n \n-    let tmp = dest.slice(s2, s2+len).to_vec();\n+    let tmp = dest.slice(s2, s2+len).to_owned();\n     copy_vec(dest, s1, tmp);\n }\n "}, {"sha": "123a388900b818f600b1e05f19ed897802a2bdf4", "filename": "src/libextra/terminfo/parser/compiled.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibextra%2Fterminfo%2Fparser%2Fcompiled.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibextra%2Fterminfo%2Fparser%2Fcompiled.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fterminfo%2Fparser%2Fcompiled.rs?ref=49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "patch": "@@ -271,7 +271,7 @@ pub fn parse(file: @Reader, longnames: bool) -> Result<~TermInfo, ~str> {\n             return Err(~\"error: hit EOF before end of string table\");\n         }\n \n-        for string_offsets.eachi |i, v| {\n+        for string_offsets.iter().enumerate().advance |(i, v)| {\n             let offset = *v;\n             if offset == 0xFFFF { // non-entry\n                 loop;"}, {"sha": "97b459bcc9ed8e009ca2c2d51b053d8e20fe4829", "filename": "src/libextra/treemap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibextra%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibextra%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Ftreemap.rs?ref=49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "patch": "@@ -853,7 +853,7 @@ mod test_treemap {\n             for 90.times {\n                 let k = rng.gen();\n                 let v = rng.gen();\n-                if !ctrl.contains(&(k, v)) {\n+                if !ctrl.iter().any_(|x| x == &(k, v)) {\n                     assert!(map.insert(k, v));\n                     ctrl.push((k, v));\n                     check_structure(&map);"}, {"sha": "cf705d722535e8f88935ed3abdb7012406b91b03", "filename": "src/librust/rust.rc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrust%2Frust.rc", "raw_url": "https://github.com/rust-lang/rust/raw/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrust%2Frust.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrust%2Frust.rc?ref=49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "patch": "@@ -135,9 +135,9 @@ fn rustc_help() {\n }\n \n fn find_cmd(command_string: &str) -> Option<Command> {\n-    do commands.find |command| {\n+    do commands.iter().find_ |command| {\n         command.cmd == command_string\n-    }\n+    }.map_consume(|x| copy *x)\n }\n \n fn cmd_help(args: &[~str]) -> ValidUsage {"}, {"sha": "517b3f9ed8579668f3c14545c3e68131020c4a1b", "filename": "src/librustc/front/config.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustc%2Ffront%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustc%2Ffront%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ffront%2Fconfig.rs?ref=49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "patch": "@@ -197,13 +197,13 @@ pub fn metas_in_cfg(cfg: ast::crate_cfg,\n     // which the item is valid\n     let cfg_metas = vec::filter_map(cfg_metas, |i| attr::get_meta_item_list(i));\n \n-    if cfg_metas.all(|c| c.is_empty()) { return true; }\n+    if cfg_metas.iter().all(|c| c.is_empty()) { return true; }\n \n-    cfg_metas.any(|cfg_meta| {\n-        cfg_meta.all(|cfg_mi| {\n+    cfg_metas.iter().any_(|cfg_meta| {\n+        cfg_meta.iter().all(|cfg_mi| {\n             match cfg_mi.node {\n                 ast::meta_list(s, ref it) if \"not\" == s\n-                    => it.all(|mi| !attr::contains(cfg, *mi)),\n+                    => it.iter().all(|mi| !attr::contains(cfg, *mi)),\n                 _ => attr::contains(cfg, *cfg_mi)\n             }\n         })"}, {"sha": "8d6cad62e753d646d159fd35c13ec15f21a62e9a", "filename": "src/librustc/lib/llvm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustc%2Flib%2Fllvm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustc%2Flib%2Fllvm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib%2Fllvm.rs?ref=49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "patch": "@@ -2157,7 +2157,7 @@ pub fn type_to_str_inner(names: @TypeNames, outer0: &[TypeRef], ty: TypeRef)\n           _ => {}\n         }\n \n-        let outer = vec::append_one(outer0.to_vec(), ty);\n+        let outer = vec::append_one(outer0.to_owned(), ty);\n \n         let kind = llvm::LLVMGetTypeKind(ty);\n "}, {"sha": "c8b0f4a488adabe842ff1b33194d74fd36cc8f3c", "filename": "src/librustc/metadata/creader.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustc%2Fmetadata%2Fcreader.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcreader.rs?ref=49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "patch": "@@ -85,16 +85,16 @@ fn warn_if_multiple_versions(e: @mut Env,\n             *crate_cache[crate_cache.len() - 1].metas\n         );\n \n-        let (matches, non_matches) =\n-            partition(crate_cache.map_to_vec(|&entry| {\n-                let othername = loader::crate_name_from_metas(\n-                    copy *entry.metas);\n-                if name == othername {\n-                    Left(entry)\n-                } else {\n-                    Right(entry)\n-                }\n-            }));\n+        let vec: ~[Either<cache_entry, cache_entry>] = crate_cache.iter().transform(|&entry| {\n+            let othername = loader::crate_name_from_metas(\n+                copy *entry.metas);\n+            if name == othername {\n+                Left(entry)\n+            } else {\n+                Right(entry)\n+            }\n+        }).collect();\n+        let (matches, non_matches) = partition(vec);\n \n         assert!(!matches.is_empty());\n "}, {"sha": "399ad215fdb3891935b60bf389d72ecc6e7932fe", "filename": "src/librustc/metadata/cstore.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustc%2Fmetadata%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fcstore.rs?ref=49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "patch": "@@ -104,7 +104,7 @@ pub fn get_used_crate_files(cstore: &CStore) -> ~[Path] {\n pub fn add_used_library(cstore: &mut CStore, lib: @str) -> bool {\n     assert!(!lib.is_empty());\n \n-    if cstore.used_libraries.contains(&lib) { return false; }\n+    if cstore.used_libraries.iter().any_(|x| x == &lib) { return false; }\n     cstore.used_libraries.push(lib);\n     true\n }"}, {"sha": "bc2e95f4d1b107fee834ddcc6bb7a7b14d6a0e08", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "patch": "@@ -1014,7 +1014,8 @@ fn encode_info_for_item(ecx: &EncodeContext,\n         ebml_w.end_tag();\n \n         // Now output the method info for each method.\n-        for ty::trait_method_def_ids(tcx, local_def(item.id)).eachi |i, &method_def_id| {\n+        let r = ty::trait_method_def_ids(tcx, local_def(item.id));\n+        for r.iter().enumerate().advance |(i, &method_def_id)| {\n             assert_eq!(method_def_id.crate, ast::local_crate);\n \n             let method_ty = ty::method(tcx, method_def_id);"}, {"sha": "745e792eec75589bbdd9acb41333ddfaa24880a9", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "patch": "@@ -132,7 +132,7 @@ fn borrowck_fn(fk: &visit::fn_kind,\n                                      LoanDataFlowOperator,\n                                      id_range,\n                                      all_loans.len());\n-            for all_loans.eachi |loan_idx, loan| {\n+            for all_loans.iter().enumerate().advance |(loan_idx, loan)| {\n                 loan_dfcx.add_gen(loan.gen_scope, loan_idx);\n                 loan_dfcx.add_kill(loan.kill_scope, loan_idx);\n             }"}, {"sha": "0ed909b64829572bb6e681025443ad45529b0325", "filename": "src/librustc/middle/borrowck/move_data.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmove_data.rs?ref=49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "patch": "@@ -348,11 +348,11 @@ impl MoveData {\n          * killed by scoping. See `doc.rs` for more details.\n          */\n \n-        for self.moves.eachi |i, move| {\n+        for self.moves.iter().enumerate().advance |(i, move)| {\n             dfcx_moves.add_gen(move.id, i);\n         }\n \n-        for self.var_assignments.eachi |i, assignment| {\n+        for self.var_assignments.iter().enumerate().advance |(i, assignment)| {\n             dfcx_assign.add_gen(assignment.id, i);\n             self.kill_moves(assignment.path, assignment.id, dfcx_moves);\n         }\n@@ -375,7 +375,7 @@ impl MoveData {\n         }\n \n         // Kill all assignments when the variable goes out of scope:\n-        for self.var_assignments.eachi |assignment_index, assignment| {\n+        for self.var_assignments.iter().enumerate().advance |(assignment_index, assignment)| {\n             match *self.path(assignment.path).loan_path {\n                 LpVar(id) => {\n                     let kill_id = tcx.region_maps.encl_scope(id);"}, {"sha": "79fe6420e27879bd1f5201b34314477320fbd4c7", "filename": "src/librustc/middle/check_const.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_const.rs?ref=49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "patch": "@@ -225,7 +225,7 @@ pub fn check_item_recursion(sess: Session,\n     (visitor.visit_item)(it, (env, visitor));\n \n     fn visit_item(it: @item, (env, v): (env, visit::vt<env>)) {\n-        if env.idstack.contains(&(it.id)) {\n+        if env.idstack.iter().any_(|x| x == &(it.id)) {\n             env.sess.span_fatal(env.root_it.span, \"recursive constant\");\n         }\n         env.idstack.push(it.id);"}, {"sha": "4da88981a63575e64db211f29b861e7138803d6f", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "patch": "@@ -155,7 +155,7 @@ pub fn check_exhaustive(cx: @MatchCheckCtxt, sp: span, pats: ~[@pat]) {\n                     };\n                     let variants = ty::enum_variants(cx.tcx, id);\n \n-                    match variants.find(|v| v.id == vid) {\n+                    match variants.iter().find_(|v| v.id == vid) {\n                         Some(v) => Some(cx.tcx.sess.str_of(v.name)),\n                         None => {\n                             fail!(\"check_exhaustive: bad variant in ctor\")\n@@ -208,7 +208,7 @@ pub enum ctor {\n pub fn is_useful(cx: @MatchCheckCtxt, m: &matrix, v: &[@pat]) -> useful {\n     if m.len() == 0u { return useful_; }\n     if m[0].len() == 0u { return not_useful; }\n-    let real_pat = match m.find(|r| r[0].id != 0) {\n+    let real_pat = match m.iter().find_(|r| r[0].id != 0) {\n       Some(r) => r[0], None => v[0]\n     };\n     let left_ty = if real_pat.id == 0 { ty::mk_nil() }\n@@ -372,7 +372,7 @@ pub fn missing_ctor(cx: @MatchCheckCtxt,\n         let variants = ty::enum_variants(cx.tcx, eid);\n         if found.len() != (*variants).len() {\n             for (*variants).each |v| {\n-                if !found.contains(&(variant(v.id))) {\n+                if !found.iter().any_(|x| x == &(variant(v.id))) {\n                     return Some(variant(v.id));\n                 }\n             }\n@@ -613,7 +613,7 @@ pub fn specialize(cx: @MatchCheckCtxt,\n                         if variant(variant_id) == *ctor_id {\n                             // FIXME #4731: Is this right? --pcw\n                             let args = flds.map(|ty_field| {\n-                                match flds.find(|f|\n+                                match flds.iter().find_(|f|\n                                                 f.ident == ty_field.ident) {\n                                     Some(f) => f.pat,\n                                     _ => wild()\n@@ -644,7 +644,7 @@ pub fn specialize(cx: @MatchCheckCtxt,\n                             }\n                         }\n                         let args = vec::map(class_fields, |class_field| {\n-                            match flds.find(|f|\n+                            match flds.iter().find_(|f|\n                                             f.ident == class_field.ident) {\n                                 Some(f) => f.pat,\n                                 _ => wild()\n@@ -806,13 +806,13 @@ pub fn is_refutable(cx: @MatchCheckCtxt, pat: &pat) -> bool {\n       }\n       pat_lit(_) | pat_range(_, _) => { true }\n       pat_struct(_, ref fields, _) => {\n-        fields.any(|f| is_refutable(cx, f.pat))\n+        fields.iter().any_(|f| is_refutable(cx, f.pat))\n       }\n       pat_tup(ref elts) => {\n-        elts.any(|elt| is_refutable(cx, *elt))\n+        elts.iter().any_(|elt| is_refutable(cx, *elt))\n       }\n       pat_enum(_, Some(ref args)) => {\n-        args.any(|a| is_refutable(cx, *a))\n+        args.iter().any_(|a| is_refutable(cx, *a))\n       }\n       pat_enum(_,_) => { false }\n       pat_vec(*) => { true }"}, {"sha": "1e14a558db287f94bdf0c9ab4f6012cd0f1f30a5", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "patch": "@@ -266,7 +266,7 @@ impl<O:DataFlowOperator> DataFlowContext<O> {\n                 f: &fn(uint) -> bool) -> bool {\n         //! Helper for iterating over the bits in a bit set.\n \n-        for words.eachi |word_index, &word| {\n+        for words.iter().enumerate().advance |(word_index, &word)| {\n             if word != 0 {\n                 let base_index = word_index * uint::bits;\n                 for uint::range(0, uint::bits) |offset| {\n@@ -342,14 +342,14 @@ impl<O:DataFlowOperator+Copy+'static> DataFlowContext<O> {\n                 let entry_str = bits_to_str(on_entry);\n \n                 let gens = vec::slice(self.gens, start, end);\n-                let gens_str = if gens.any(|&u| u != 0) {\n+                let gens_str = if gens.iter().any_(|&u| u != 0) {\n                     fmt!(\" gen: %s\", bits_to_str(gens))\n                 } else {\n                     ~\"\"\n                 };\n \n                 let kills = vec::slice(self.kills, start, end);\n-                let kills_str = if kills.any(|&u| u != 0) {\n+                let kills_str = if kills.iter().any_(|&u| u != 0) {\n                     fmt!(\" kill: %s\", bits_to_str(kills))\n                 } else {\n                     ~\"\"\n@@ -503,12 +503,12 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n \n                     // func_bits represents the state when the function\n                     // returns\n-                    let mut func_bits = reslice(in_out).to_vec();\n+                    let mut func_bits = reslice(in_out).to_owned();\n \n                     loop_scopes.push(LoopScope {\n                         loop_id: expr.id,\n                         loop_kind: ForLoop,\n-                        break_bits: reslice(in_out).to_vec()\n+                        break_bits: reslice(in_out).to_owned()\n                     });\n                     for decl.inputs.each |input| {\n                         self.walk_pat(input.pat, func_bits, loop_scopes);\n@@ -547,7 +547,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n                 //\n                 self.walk_expr(cond, in_out, loop_scopes);\n \n-                let mut then_bits = reslice(in_out).to_vec();\n+                let mut then_bits = reslice(in_out).to_owned();\n                 self.walk_block(then, then_bits, loop_scopes);\n \n                 self.walk_opt_expr(els, in_out, loop_scopes);\n@@ -569,11 +569,11 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n \n                 self.walk_expr(cond, in_out, loop_scopes);\n \n-                let mut body_bits = reslice(in_out).to_vec();\n+                let mut body_bits = reslice(in_out).to_owned();\n                 loop_scopes.push(LoopScope {\n                     loop_id: expr.id,\n                     loop_kind: TrueLoop,\n-                    break_bits: reslice(in_out).to_vec()\n+                    break_bits: reslice(in_out).to_owned()\n                 });\n                 self.walk_block(blk, body_bits, loop_scopes);\n                 self.add_to_entry_set(expr.id, body_bits);\n@@ -591,12 +591,12 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n                 //    <--+ (break)\n                 //\n \n-                let mut body_bits = reslice(in_out).to_vec();\n+                let mut body_bits = reslice(in_out).to_owned();\n                 self.reset(in_out);\n                 loop_scopes.push(LoopScope {\n                     loop_id: expr.id,\n                     loop_kind: TrueLoop,\n-                    break_bits: reslice(in_out).to_vec()\n+                    break_bits: reslice(in_out).to_owned()\n                 });\n                 self.walk_block(blk, body_bits, loop_scopes);\n                 self.add_to_entry_set(expr.id, body_bits);\n@@ -620,7 +620,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n                 //\n                 self.walk_expr(discr, in_out, loop_scopes);\n \n-                let mut guards = reslice(in_out).to_vec();\n+                let mut guards = reslice(in_out).to_owned();\n \n                 // We know that exactly one arm will be taken, so we\n                 // can start out with a blank slate and just union\n@@ -633,7 +633,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n \n                     // determine the bits for the body and then union\n                     // them into `in_out`, which reflects all bodies to date\n-                    let mut body = reslice(guards).to_vec();\n+                    let mut body = reslice(guards).to_owned();\n                     self.walk_pat_alternatives(arm.pats, body, loop_scopes);\n                     self.walk_block(&arm.body, body, loop_scopes);\n                     join_bits(&self.dfcx.oper, body, in_out);\n@@ -644,7 +644,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n                 self.walk_opt_expr(o_e, in_out, loop_scopes);\n \n                 // is this a return from a `for`-loop closure?\n-                match loop_scopes.position(|s| s.loop_kind == ForLoop) {\n+                match loop_scopes.iter().position_(|s| s.loop_kind == ForLoop) {\n                     Some(i) => {\n                         // if so, add the in_out bits to the state\n                         // upon exit. Remember that we cannot count\n@@ -735,7 +735,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n \n             ast::expr_binary(_, op, l, r) if ast_util::lazy_binop(op) => {\n                 self.walk_expr(l, in_out, loop_scopes);\n-                let temp = reslice(in_out).to_vec();\n+                let temp = reslice(in_out).to_owned();\n                 self.walk_expr(r, in_out, loop_scopes);\n                 join_bits(&self.dfcx.oper, temp, in_out);\n             }\n@@ -896,7 +896,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n         // In the general case, the patterns in `pats` are\n         // alternatives, so we must treat this like an N-way select\n         // statement.\n-        let initial_state = reslice(in_out).to_vec();\n+        let initial_state = reslice(in_out).to_owned();\n         for pats.each |&pat| {\n             let mut temp = copy initial_state;\n             self.walk_pat(pat, temp, loop_scopes);\n@@ -917,7 +917,7 @@ impl<'self, O:DataFlowOperator> PropagationContext<'self, O> {\n             Some(_) => {\n                 match self.tcx().def_map.find(&expr.id) {\n                     Some(&ast::def_label(loop_id)) => {\n-                        match loop_scopes.position(|l| l.loop_id == loop_id) {\n+                        match loop_scopes.iter().position_(|l| l.loop_id == loop_id) {\n                             Some(i) => i,\n                             None => {\n                                 self.tcx().sess.span_bug("}, {"sha": "6492850b6685f23887b4b5753c1b6ec7a57167d5", "filename": "src/librustc/middle/kind.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustc%2Fmiddle%2Fkind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustc%2Fmiddle%2Fkind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fkind.rs?ref=49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "patch": "@@ -477,7 +477,7 @@ pub fn check_cast_for_escaping_regions(\n     // Check, based on the region associated with the trait, whether it can\n     // possibly escape the enclosing fn item (note that all type parameters\n     // must have been declared on the enclosing fn item).\n-    if target_regions.any(|r| is_re_scope(*r)) {\n+    if target_regions.iter().any_(|r| is_re_scope(*r)) {\n         return; /* case (1) */\n     }\n \n@@ -492,7 +492,7 @@ pub fn check_cast_for_escaping_regions(\n         |_r| {\n             // FIXME(#5723) --- turn this check on once &Objects are usable\n             //\n-            // if !target_regions.any(|t_r| is_subregion_of(cx, *t_r, r)) {\n+            // if !target_regions.iter().any_(|t_r| is_subregion_of(cx, *t_r, r)) {\n             //     cx.tcx.sess.span_err(\n             //         source.span,\n             //         fmt!(\"source contains borrowed pointer with lifetime \\\n@@ -506,7 +506,7 @@ pub fn check_cast_for_escaping_regions(\n         |ty| {\n             match ty::get(ty).sty {\n                 ty::ty_param(source_param) => {\n-                    if target_params.contains(&source_param) {\n+                    if target_params.iter().any_(|x| x == &source_param) {\n                         /* case (2) */\n                     } else {\n                         check_durable(cx.tcx, ty, source.span); /* case (3) */"}, {"sha": "2f66ca0f516c488fef238e146eba54163ce1d8a6", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "patch": "@@ -90,7 +90,7 @@ impl LanguageItems {\n     }\n \n     pub fn each_item(&self, f: &fn(def_id: def_id, i: uint) -> bool) -> bool {\n-        self.items.eachi(|i, &item| f(item.get(), i))\n+        self.items.iter().enumerate().advance(|(i, &item)| f(item.get(), i))\n     }\n \n     pub fn item_name(index: uint) -> &'static str {"}, {"sha": "054498545b7b58a7dc44c94ce7e2b8c304135bc1", "filename": "src/librustc/middle/lint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustc%2Fmiddle%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustc%2Fmiddle%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flint.rs?ref=49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "patch": "@@ -1003,7 +1003,7 @@ fn lint_missing_doc() -> visit::vt<@mut Context> {\n         // If we have doc(hidden), nothing to do\n         if cx.doc_hidden { return }\n         // If we're documented, nothing to do\n-        if attrs.any(|a| a.node.is_sugared_doc) { return }\n+        if attrs.iter().any_(|a| a.node.is_sugared_doc) { return }\n \n         // otherwise, warn!\n         cx.span_lint(missing_doc, sp, msg);"}, {"sha": "297b454bd83a155714694093d4795c36f24068e7", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "patch": "@@ -872,7 +872,7 @@ impl mem_categorization_ctxt {\n                         }\n                     };\n \n-                    for subpats.eachi |i, &subpat| {\n+                    for subpats.iter().enumerate().advance |(i, &subpat)| {\n                         let subpat_ty = self.pat_ty(subpat); // see (*)\n \n                         let subcmt =\n@@ -885,7 +885,7 @@ impl mem_categorization_ctxt {\n                 }\n                 Some(&ast::def_fn(*)) |\n                 Some(&ast::def_struct(*)) => {\n-                    for subpats.eachi |i, &subpat| {\n+                    for subpats.iter().enumerate().advance |(i, &subpat)| {\n                         let subpat_ty = self.pat_ty(subpat); // see (*)\n                         let cmt_field =\n                             self.cat_imm_interior(\n@@ -926,7 +926,7 @@ impl mem_categorization_ctxt {\n \n           ast::pat_tup(ref subpats) => {\n             // (p1, ..., pN)\n-            for subpats.eachi |i, &subpat| {\n+            for subpats.iter().enumerate().advance |(i, &subpat)| {\n                 let subpat_ty = self.pat_ty(subpat); // see (*)\n                 let subcmt =\n                     self.cat_imm_interior("}, {"sha": "8a29a026dc2f7091d44073a965f876d5c48963ee", "filename": "src/librustc/middle/moves.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustc%2Fmiddle%2Fmoves.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmoves.rs?ref=49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "patch": "@@ -370,8 +370,8 @@ impl VisitContext {\n                     // any fields which (1) were not explicitly\n                     // specified and (2) have a type that\n                     // moves-by-default:\n-                    let consume_with = with_fields.any(|tf| {\n-                        !fields.any(|f| f.node.ident == tf.ident) &&\n+                    let consume_with = with_fields.iter().any_(|tf| {\n+                        !fields.iter().any_(|f| f.node.ident == tf.ident) &&\n                             ty::type_moves_by_default(self.tcx, tf.mt.ty)\n                     });\n "}, {"sha": "5cfe44e1554edd102eb13a91e5bb33557fdfe0a1", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "patch": "@@ -252,7 +252,7 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n                                                          method_id.node);\n             if is_private &&\n                     (container_id.crate != local_crate ||\n-                     !privileged_items.contains(&(container_id.node))) {\n+                     !privileged_items.iter().any_(|x| x == &(container_id.node))) {\n                 tcx.sess.span_err(span,\n                                   fmt!(\"method `%s` is private\",\n                                        token::ident_to_str(name)));\n@@ -280,7 +280,7 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n             def_fn(def_id, _) => {\n                 if def_id.crate == local_crate {\n                     if local_item_is_private(span, def_id.node) &&\n-                            !privileged_items.contains(&def_id.node) {\n+                            !privileged_items.iter().any_(|x| x == &def_id.node) {\n                         tcx.sess.span_err(span,\n                                           fmt!(\"function `%s` is private\",\n                                                token::ident_to_str(path.idents.last())));\n@@ -324,8 +324,8 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n                                     match (*methods)[method_num] {\n                                         provided(method)\n                                              if method.vis == private &&\n-                                             !privileged_items\n-                                             .contains(&(trait_id.node)) => {\n+                                             !privileged_items.iter()\n+                                             .any_(|x| x == &(trait_id.node)) => {\n                                             tcx.sess.span_err(span,\n                                                               fmt!(\"method `%s` is private\",\n                                                                    token::ident_to_str(&method\n@@ -409,7 +409,8 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n                     match ty::get(ty::type_autoderef(tcx, ty::expr_ty(tcx,\n                                                           base))).sty {\n                         ty_struct(id, _)\n-                        if id.crate != local_crate || !privileged_items.contains(&(id.node)) => {\n+                        if id.crate != local_crate || !privileged_items.iter()\n+                                .any_(|x| x == &(id.node)) => {\n                             debug!(\"(privacy checking) checking field access\");\n                             check_field(expr.span, id, ident);\n                         }\n@@ -422,7 +423,7 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n                                                           base))).sty {\n                         ty_struct(id, _)\n                         if id.crate != local_crate ||\n-                           !privileged_items.contains(&(id.node)) => {\n+                           !privileged_items.iter().any_(|x| x == &(id.node)) => {\n                             match method_map.find(&expr.id) {\n                                 None => {\n                                     tcx.sess.span_bug(expr.span,\n@@ -448,7 +449,7 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n                     match ty::get(ty::expr_ty(tcx, expr)).sty {\n                         ty_struct(id, _) => {\n                             if id.crate != local_crate ||\n-                                    !privileged_items.contains(&(id.node)) {\n+                                    !privileged_items.iter().any_(|x| x == &(id.node)) {\n                                 for (*fields).each |field| {\n                                         debug!(\"(privacy checking) checking \\\n                                                 field in struct literal\");\n@@ -459,7 +460,7 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n                         }\n                         ty_enum(id, _) => {\n                             if id.crate != local_crate ||\n-                                    !privileged_items.contains(&(id.node)) {\n+                                    !privileged_items.iter().any_(|x| x == &(id.node)) {\n                                 match tcx.def_map.get_copy(&expr.id) {\n                                     def_variant(_, variant_id) => {\n                                         for (*fields).each |field| {\n@@ -496,7 +497,7 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n                     match ty::get(ty::expr_ty(tcx, operand)).sty {\n                         ty_enum(id, _) => {\n                             if id.crate != local_crate ||\n-                                !privileged_items.contains(&(id.node)) {\n+                                !privileged_items.iter().any_(|x| x == &(id.node)) {\n                                 check_variant(expr.span, id);\n                             }\n                         }\n@@ -514,7 +515,7 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n                     match ty::get(ty::pat_ty(tcx, pattern)).sty {\n                         ty_struct(id, _) => {\n                             if id.crate != local_crate ||\n-                                    !privileged_items.contains(&(id.node)) {\n+                                    !privileged_items.iter().any_(|x| x == &(id.node)) {\n                                 for fields.each |field| {\n                                         debug!(\"(privacy checking) checking \\\n                                                 struct pattern\");\n@@ -525,8 +526,7 @@ pub fn check_crate<'mm>(tcx: ty::ctxt,\n                         }\n                         ty_enum(enum_id, _) => {\n                             if enum_id.crate != local_crate ||\n-                                    !privileged_items.contains(\n-                                        &enum_id.node) {\n+                                    !privileged_items.iter().any_(|x| x == &enum_id.node) {\n                                 match tcx.def_map.find(&pattern.id) {\n                                     Some(&def_variant(_, variant_id)) => {\n                                         for fields.each |field| {"}, {"sha": "eef43574c14b7d519468eca91621539be7aead1a", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "patch": "@@ -78,7 +78,7 @@ impl RegionMaps {\n     pub fn relate_free_regions(&mut self, sub: FreeRegion, sup: FreeRegion) {\n         match self.free_region_map.find_mut(&sub) {\n             Some(sups) => {\n-                if !sups.contains(&sup) {\n+                if !sups.iter().any_(|x| x == &sup) {\n                     sups.push(sup);\n                 }\n                 return;\n@@ -202,7 +202,7 @@ impl RegionMaps {\n                             return true;\n                         }\n \n-                        if !queue.contains(parent) {\n+                        if !queue.iter().any_(|x| x == parent) {\n                             queue.push(*parent);\n                         }\n                     }\n@@ -632,7 +632,7 @@ impl DetermineRpCtxt {\n             ambient_variance: self.ambient_variance,\n             id: self.item_id\n         };\n-        if !vec.contains(&dep) { vec.push(dep); }\n+        if !vec.iter().any_(|x| x == &dep) { vec.push(dep); }\n     }\n \n     // Determines whether a reference to a region that appears in the"}, {"sha": "0248a5f43ccea99ee1a319ddd659e96fe35ce57a", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "patch": "@@ -1463,7 +1463,7 @@ impl Resolver {\n                             let path_len = full_path.idents.len();\n                             assert!(path_len != 0);\n \n-                            for full_path.idents.eachi |i, ident| {\n+                            for full_path.idents.iter().enumerate().advance |(i, ident)| {\n                                 if i != path_len - 1 {\n                                     module_path.push(*ident);\n                                 }\n@@ -4033,7 +4033,7 @@ impl Resolver {\n     pub fn check_consistent_bindings(@mut self, arm: &arm) {\n         if arm.pats.len() == 0 { return; }\n         let map_0 = self.binding_mode_map(arm.pats[0]);\n-        for arm.pats.eachi() |i, p| {\n+        for arm.pats.iter().enumerate().advance |(i, p)| {\n             let map_i = self.binding_mode_map(*p);\n \n             for map_0.each |&key, &binding_0| {\n@@ -4605,7 +4605,7 @@ impl Resolver {\n \n     pub fn intern_module_part_of_path(@mut self, path: @Path) -> ~[ident] {\n         let mut module_path_idents = ~[];\n-        for path.idents.eachi |index, ident| {\n+        for path.idents.iter().enumerate().advance |(index, ident)| {\n             if index == path.idents.len() - 1 {\n                 break;\n             }\n@@ -4843,8 +4843,7 @@ impl Resolver {\n         }\n \n         let mut smallest = 0;\n-        for maybes.eachi |i, &other| {\n-\n+        for maybes.iter().enumerate().advance |(i, &other)| {\n             values[i] = name.lev_distance(other);\n \n             if values[i] <= values[smallest] {"}, {"sha": "945f94a0877f5c407419da9ff136ac3081be0337", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 8, "deletions": 9, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "patch": "@@ -388,7 +388,7 @@ pub fn expand_nested_bindings<'r>(bcx: block,\n         match br.pats[col].node {\n             ast::pat_ident(_, path, Some(inner)) => {\n                 let pats = vec::append(\n-                    vec::slice(br.pats, 0u, col).to_vec(),\n+                    vec::slice(br.pats, 0u, col).to_owned(),\n                     vec::append(~[inner],\n                                 vec::slice(br.pats, col + 1u,\n                                            br.pats.len())));\n@@ -581,8 +581,7 @@ pub fn enter_opt<'r>(bcx: block,\n                     let mut reordered_patterns = ~[];\n                     for ty::lookup_struct_fields(tcx, struct_id).each\n                         |field| {\n-                            match field_pats.find(|p|\n-                                                  p.ident == field.ident) {\n+                            match field_pats.iter().find_(|p| p.ident == field.ident) {\n                                 None => reordered_patterns.push(dummy),\n                                 Some(fp) => reordered_patterns.push(fp.pat)\n                             }\n@@ -642,7 +641,7 @@ pub fn enter_rec_or_struct<'r>(bcx: block,\n             ast::pat_struct(_, ref fpats, _) => {\n                 let mut pats = ~[];\n                 for fields.each |fname| {\n-                    match fpats.find(|p| p.ident == *fname) {\n+                    match fpats.iter().find_(|p| p.ident == *fname) {\n                         None => pats.push(dummy),\n                         Some(pat) => pats.push(pat.pat)\n                     }\n@@ -1308,11 +1307,11 @@ pub fn compile_submatch(bcx: block,\n         if has_nested_bindings(m, col) {\n             expand_nested_bindings(bcx, m, col, val)\n         } else {\n-            m.to_vec()\n+            m.to_owned()\n         }\n     };\n \n-    let vals_left = vec::append(vec::slice(vals, 0u, col).to_vec(),\n+    let vals_left = vec::append(vec::slice(vals, 0u, col).to_owned(),\n                                 vec::slice(vals, col + 1u, vals.len()));\n     let ccx = bcx.fcx.ccx;\n     let mut pat_id = 0;\n@@ -1808,7 +1807,7 @@ pub fn bind_irrefutable_pat(bcx: block,\n                                                     vinfo.disr_val,\n                                                     val);\n                     for sub_pats.iter().advance |sub_pat| {\n-                        for args.vals.eachi |i, argval| {\n+                        for args.vals.iter().enumerate().advance |(i, argval)| {\n                             bcx = bind_irrefutable_pat(bcx,\n                                                        sub_pat[i],\n                                                        *argval,\n@@ -1826,7 +1825,7 @@ pub fn bind_irrefutable_pat(bcx: block,\n                         Some(ref elems) => {\n                             // This is the tuple struct case.\n                             let repr = adt::represent_node(bcx, pat.id);\n-                            for elems.eachi |i, elem| {\n+                            for elems.iter().enumerate().advance |(i, elem)| {\n                                 let fldptr = adt::trans_field_ptr(bcx, repr,\n                                                             val, 0, i);\n                                 bcx = bind_irrefutable_pat(bcx,\n@@ -1865,7 +1864,7 @@ pub fn bind_irrefutable_pat(bcx: block,\n         }\n         ast::pat_tup(ref elems) => {\n             let repr = adt::represent_node(bcx, pat.id);\n-            for elems.eachi |i, elem| {\n+            for elems.iter().enumerate().advance |(i, elem)| {\n                 let fldptr = adt::trans_field_ptr(bcx, repr, val, 0, i);\n                 bcx = bind_irrefutable_pat(bcx,\n                                            *elem,"}, {"sha": "79b5aba227c398a5965584aa72e27628c01ecc0d", "filename": "src/librustc/middle/trans/adt.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fadt.rs?ref=49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "patch": "@@ -145,7 +145,7 @@ fn represent_type_uncached(cx: &mut CrateContext, t: ty::t) -> Repr {\n                     mk_struct(cx, self.tys, false).size == 0\n                 }\n                 fn find_ptr(&self) -> Option<uint> {\n-                    self.tys.position(|&ty| mono_data_classify(ty) == MonoNonNull)\n+                    self.tys.iter().position_(|&ty| mono_data_classify(ty) == MonoNonNull)\n                 }\n             }\n \n@@ -161,7 +161,7 @@ fn represent_type_uncached(cx: &mut CrateContext, t: ty::t) -> Repr {\n                 return Univariant(mk_struct(cx, [], false), false);\n             }\n \n-            if cases.all(|c| c.tys.len() == 0) {\n+            if cases.iter().all(|c| c.tys.len() == 0) {\n                 // All bodies empty -> intlike\n                 let discrs = cases.map(|c| c.discr);\n                 return CEnum(*discrs.iter().min().unwrap(), *discrs.iter().max().unwrap());\n@@ -545,7 +545,7 @@ fn build_const_struct(ccx: &mut CrateContext, st: &Struct, vals: &[ValueRef])\n \n     let mut offset = 0;\n     let mut cfields = ~[];\n-    for st.fields.eachi |i, &ty| {\n+    for st.fields.iter().enumerate().advance |(i, &ty)| {\n         let llty = type_of::sizing_type_of(ccx, ty);\n         let type_align = machine::llalign_of_min(ccx, llty)\n             /*bad*/as u64;"}, {"sha": "3814ff319f2dc2885eb4203ee66d5a01ef7fa08c", "filename": "src/librustc/middle/trans/asm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fasm.rs?ref=49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "patch": "@@ -133,7 +133,7 @@ pub fn trans_inline_asm(bcx: block, ia: &ast::inline_asm) -> block {\n         let op = PointerCast(bcx, aoutputs[0], T_ptr(val_ty(outputs[0])));\n         Store(bcx, r, op);\n     } else {\n-        for aoutputs.eachi |i, o| {\n+        for aoutputs.iter().enumerate().advance |(i, o)| {\n             let v = ExtractValue(bcx, r, i);\n             let op = PointerCast(bcx, *o, T_ptr(val_ty(outputs[i])));\n             Store(bcx, v, op);"}, {"sha": "e96a4e1b5ad0d8a83618eca5408710e42d0edc8b", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "patch": "@@ -670,7 +670,7 @@ pub fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n         let tcx = cx.tcx();\n         let mut cx = cx;\n \n-        for variant.args.eachi |i, &arg| {\n+        for variant.args.iter().enumerate().advance |(i, &arg)| {\n             cx = f(cx,\n                    adt::trans_field_ptr(cx, repr, av, variant.disr_val, i),\n                    ty::subst_tps(tcx, tps, None, arg));\n@@ -683,7 +683,7 @@ pub fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n       ty::ty_struct(*) => {\n           let repr = adt::represent_type(cx.ccx(), t);\n           do expr::with_field_tys(cx.tcx(), t, None) |discr, field_tys| {\n-              for field_tys.eachi |i, field_ty| {\n+              for field_tys.iter().enumerate().advance |(i, field_ty)| {\n                   let llfld_a = adt::trans_field_ptr(cx, repr, av, discr, i);\n                   cx = f(cx, llfld_a, field_ty.mt.ty);\n               }\n@@ -696,7 +696,7 @@ pub fn iter_structural_ty(cx: block, av: ValueRef, t: ty::t,\n       }\n       ty::ty_tup(ref args) => {\n           let repr = adt::represent_type(cx.ccx(), t);\n-          for args.eachi |i, arg| {\n+          for args.iter().enumerate().advance |(i, arg)| {\n               let llfld_a = adt::trans_field_ptr(cx, repr, av, 0, i);\n               cx = f(cx, llfld_a, *arg);\n           }\n@@ -2017,7 +2017,7 @@ pub fn trans_enum_variant(ccx: @mut CrateContext,\n            repr, ty_to_str(ccx.tcx, enum_ty));\n \n     adt::trans_start_init(bcx, repr, fcx.llretptr.get(), disr);\n-    for args.eachi |i, va| {\n+    for args.iter().enumerate().advance |(i, va)| {\n         let lldestptr = adt::trans_field_ptr(bcx,\n                                              repr,\n                                              fcx.llretptr.get(),\n@@ -2092,7 +2092,7 @@ pub fn trans_tuple_struct(ccx: @mut CrateContext,\n     let repr = adt::represent_type(ccx, tup_ty);\n     adt::trans_start_init(bcx, repr, fcx.llretptr.get(), 0);\n \n-    for fields.eachi |i, field| {\n+    for fields.iter().enumerate().advance |(i, field)| {\n         let lldestptr = adt::trans_field_ptr(bcx,\n                                              repr,\n                                              fcx.llretptr.get(),"}, {"sha": "582d51c2cbf24c824fb475ecff6f821d76fd5cf7", "filename": "src/librustc/middle/trans/callee.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcallee.rs?ref=49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "patch": "@@ -225,7 +225,7 @@ pub fn trans_fn_ref_with_vtables(\n            type_params.repr(bcx.tcx()),\n            vtables.repr(bcx.tcx()));\n \n-    assert!(type_params.all(|t| !ty::type_needs_infer(*t)));\n+    assert!(type_params.iter().all(|t| !ty::type_needs_infer(*t)));\n \n     // Polytype of the function item (may have type params)\n     let fn_tpt = ty::lookup_item_type(tcx, def_id);\n@@ -706,7 +706,7 @@ pub fn trans_args(cx: block,\n     match args {\n       ArgExprs(arg_exprs) => {\n         let last = arg_exprs.len() - 1u;\n-        for arg_exprs.eachi |i, arg_expr| {\n+        for arg_exprs.iter().enumerate().advance |(i, arg_expr)| {\n             let arg_val = unpack_result!(bcx, {\n                 trans_arg_expr(bcx,\n                                arg_tys[i],"}, {"sha": "fc79c8c23d45a17c03d261ea7927af5fc79e307a", "filename": "src/librustc/middle/trans/common.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fcommon.rs?ref=49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "patch": "@@ -476,7 +476,7 @@ pub fn revoke_clean(cx: block, val: ValueRef) {\n             });\n         for cleanup_pos.iter().advance |i| {\n             scope_info.cleanups =\n-                vec::append(vec::slice(scope_info.cleanups, 0u, *i).to_vec(),\n+                vec::append(vec::slice(scope_info.cleanups, 0u, *i).to_owned(),\n                             vec::slice(scope_info.cleanups,\n                                       *i + 1u,\n                                       scope_info.cleanups.len()));\n@@ -1397,7 +1397,7 @@ pub fn node_id_type_params(bcx: block, id: ast::node_id) -> ~[ty::t] {\n     let tcx = bcx.tcx();\n     let params = ty::node_id_to_type_params(tcx, id);\n \n-    if !params.all(|t| !ty::type_needs_infer(*t)) {\n+    if !params.iter().all(|t| !ty::type_needs_infer(*t)) {\n         bcx.sess().bug(\n             fmt!(\"Type parameters for node %d include inference types: %s\",\n                  id, params.map(|t| bcx.ty_to_str(*t)).connect(\",\")));"}, {"sha": "dcdb53ec532adfd537632205c6f0d1043dc8aac6", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "patch": "@@ -91,7 +91,7 @@ pub fn const_vec(cx: @mut CrateContext, e: @ast::expr, es: &[@ast::expr])\n         let sz = llvm::LLVMConstMul(C_uint(cx, es.len()), unit_sz);\n         let vs = es.map(|e| const_expr(cx, *e));\n         // If the vector contains enums, an LLVM array won't work.\n-        let v = if vs.any(|vi| val_ty(*vi) != llunitty) {\n+        let v = if vs.iter().any_(|vi| val_ty(*vi) != llunitty) {\n             C_struct(vs)\n         } else {\n             C_array(llunitty, vs)\n@@ -487,8 +487,8 @@ fn const_expr_unadjusted(cx: @mut CrateContext, e: @ast::expr) -> ValueRef {\n               do expr::with_field_tys(tcx, ety, Some(e.id))\n                   |discr, field_tys| {\n                   let cs = field_tys.map(|field_ty| {\n-                      match fs.find(|f| field_ty.ident == f.node.ident) {\n-                          Some(ref f) => const_expr(cx, (*f).node.expr),\n+                      match fs.iter().find_(|f| field_ty.ident == f.node.ident) {\n+                          Some(f) => const_expr(cx, (*f).node.expr),\n                           None => {\n                               cx.tcx.sess.span_bug(e.span, \"missing struct field\");\n                           }"}, {"sha": "3cbbd61aed6fafefad9d37631aca1c3e71ae2d0e", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "patch": "@@ -1168,7 +1168,7 @@ fn trans_rec_or_struct(bcx: block,\n         let optbase = match base {\n             Some(base_expr) => {\n                 let mut leftovers = ~[];\n-                for need_base.eachi |i, b| {\n+                for need_base.iter().enumerate().advance |(i, b)| {\n                     if *b {\n                         leftovers.push((i, field_tys[i].mt.ty))\n                     }\n@@ -1177,7 +1177,7 @@ fn trans_rec_or_struct(bcx: block,\n                                      fields: leftovers })\n             }\n             None => {\n-                if need_base.any(|b| *b) {\n+                if need_base.iter().any_(|b| *b) {\n                     tcx.sess.span_bug(expr_span, \"missing fields and no base expr\")\n                 }\n                 None"}, {"sha": "b01c4b50324d01f73cf576461240c73b5f8a9099", "filename": "src/librustc/middle/trans/meth.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmeth.rs?ref=49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "patch": "@@ -345,7 +345,7 @@ pub fn trans_static_method_callee(bcx: block,\n \n     match vtbls[bound_index] {\n         typeck::vtable_static(impl_did, ref rcvr_substs, rcvr_origins) => {\n-            assert!(rcvr_substs.all(|t| !ty::type_needs_infer(*t)));\n+            assert!(rcvr_substs.iter().all(|t| !ty::type_needs_infer(*t)));\n \n             let mth_id = method_with_name_or_default(bcx.ccx(),\n                                                      impl_did,\n@@ -375,7 +375,7 @@ pub fn trans_static_method_callee(bcx: block,\n \n pub fn method_from_methods(ms: &[@ast::method], name: ast::ident)\n     -> Option<ast::def_id> {\n-    ms.find(|m| m.ident == name).map(|m| ast_util::local_def(m.id))\n+    ms.iter().find_(|m| m.ident == name).map(|m| ast_util::local_def(m.id))\n }\n \n pub fn method_with_name_or_default(ccx: @mut CrateContext,\n@@ -535,7 +535,7 @@ pub fn combine_impl_and_methods_tps(bcx: block,\n     let node_substs = node_id_type_params(bcx, callee_id);\n     debug!(\"rcvr_substs=%?\", rcvr_substs.map(|t| bcx.ty_to_str(*t)));\n     let ty_substs\n-        = vec::append(rcvr_substs.to_vec(),\n+        = vec::append(rcvr_substs.to_owned(),\n                       vec::tailn(node_substs,\n                                  node_substs.len() - n_m_tps));\n     debug!(\"n_m_tps=%?\", n_m_tps);"}, {"sha": "368ad0674e1efbfa1901103c76fd10d4f3b23ea9", "filename": "src/librustc/middle/trans/monomorphize.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fmonomorphize.rs?ref=49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "patch": "@@ -60,7 +60,7 @@ pub fn monomorphic_fn(ccx: @mut CrateContext,\n            impl_did_opt.repr(ccx.tcx),\n            ref_id);\n \n-    assert!(real_substs.tps.all(|t| !ty::type_needs_infer(*t)));\n+    assert!(real_substs.tps.iter().all(|t| !ty::type_needs_infer(*t)));\n     let _icx = ccx.insn_ctxt(\"monomorphic_fn\");\n     let mut must_cast = false;\n     let substs = vec::map(real_substs.tps, |t| {"}, {"sha": "16a6d62f176750805b6ff1b7348c90a2cf71b922", "filename": "src/librustc/middle/trans/reflect.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Freflect.rs?ref=49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "patch": "@@ -95,7 +95,7 @@ impl Reflector {\n         let v = self.visitor_val;\n         debug!(\"passing %u args:\", args.len());\n         let bcx = self.bcx;\n-        for args.eachi |i, a| {\n+        for args.iter().enumerate().advance |(i, a)| {\n             debug!(\"arg %u: %s\", i, val_str(bcx.ccx().tn, *a));\n         }\n         let bool_ty = ty::mk_bool();\n@@ -207,7 +207,7 @@ impl Reflector {\n               let extra = ~[self.c_uint(tys.len())]\n                   + self.c_size_and_align(t);\n               do self.bracketed(~\"tup\", extra) |this| {\n-                  for tys.eachi |i, t| {\n+                  for tys.iter().enumerate().advance |(i, t)| {\n                       let extra = ~[this.c_uint(i), this.c_tydesc(*t)];\n                       this.visit(~\"tup_field\", extra);\n                   }\n@@ -252,7 +252,7 @@ impl Reflector {\n               let extra = ~[self.c_uint(fields.len())]\n                   + self.c_size_and_align(t);\n               do self.bracketed(~\"class\", extra) |this| {\n-                  for fields.eachi |i, field| {\n+                  for fields.iter().enumerate().advance |(i, field)| {\n                       let extra = ~[this.c_uint(i),\n                                     this.c_slice(\n                                         bcx.ccx().sess.str_of(field.ident))]\n@@ -310,14 +310,14 @@ impl Reflector {\n             let enum_args = ~[self.c_uint(variants.len()), make_get_disr()]\n                 + self.c_size_and_align(t);\n             do self.bracketed(~\"enum\", enum_args) |this| {\n-                for variants.eachi |i, v| {\n+                for variants.iter().enumerate().advance |(i, v)| {\n                     let name = ccx.sess.str_of(v.name);\n                     let variant_args = ~[this.c_uint(i),\n                                          this.c_int(v.disr_val),\n                                          this.c_uint(v.args.len()),\n                                          this.c_slice(name)];\n                     do this.bracketed(~\"enum_variant\", variant_args) |this| {\n-                        for v.args.eachi |j, a| {\n+                        for v.args.iter().enumerate().advance |(j, a)| {\n                             let bcx = this.bcx;\n                             let null = C_null(llptrty);\n                             let ptr = adt::trans_field_ptr(bcx, repr, null, v.disr_val, j);\n@@ -352,7 +352,7 @@ impl Reflector {\n     }\n \n     pub fn visit_sig(&mut self, retval: uint, sig: &ty::FnSig) {\n-        for sig.inputs.eachi |i, arg| {\n+        for sig.inputs.iter().enumerate().advance |(i, arg)| {\n             let modeval = 5u;   // \"by copy\"\n             let extra = ~[self.c_uint(i),\n                          self.c_uint(modeval),"}, {"sha": "09905a7618795b54e1bd55dbbd0254fc8df8983d", "filename": "src/librustc/middle/trans/tvec.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Ftvec.rs?ref=49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "patch": "@@ -386,7 +386,7 @@ pub fn write_content(bcx: block,\n \n                 SaveIn(lldest) => {\n                     let mut temp_cleanups = ~[];\n-                    for elements.eachi |i, element| {\n+                    for elements.iter().enumerate().advance |(i, element)| {\n                         let lleltptr = GEPi(bcx, lldest, [i]);\n                         debug!(\"writing index %? with lleltptr=%?\",\n                                i, bcx.val_str(lleltptr));"}, {"sha": "a4702808746ef559ab3ec69a2736b9371e45a49f", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 6, "deletions": 7, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "patch": "@@ -2116,7 +2116,7 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n \n             ty_struct(did, ref substs) => {\n                 let flds = struct_fields(cx, did, substs);\n-                let mut res = flds.foldl(\n+                let mut res = flds.iter().fold(\n                     TC_NONE,\n                     |tc, f| tc + tc_mt(cx, f.mt, cache));\n                 if ty::has_dtor(cx, did) {\n@@ -2126,7 +2126,7 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n             }\n \n             ty_tup(ref tys) => {\n-                tys.foldl(TC_NONE, |tc, ty| *tc + tc_ty(cx, *ty, cache))\n+                tys.iter().fold(TC_NONE, |tc, ty| tc + tc_ty(cx, *ty, cache))\n             }\n \n             ty_enum(did, ref substs) => {\n@@ -2136,10 +2136,9 @@ pub fn type_contents(cx: ctxt, ty: t) -> TypeContents {\n                     // are non-copyable\n                     TC_EMPTY_ENUM\n                 } else {\n-                    variants.foldl(TC_NONE, |tc, variant| {\n-                        variant.args.foldl(\n-                            *tc,\n-                            |tc, arg_ty| *tc + tc_ty(cx, *arg_ty, cache))\n+                    variants.iter().fold(TC_NONE, |tc, variant| {\n+                        variant.args.iter().fold(tc,\n+                            |tc, arg_ty| tc + tc_ty(cx, *arg_ty, cache))\n                     })\n                 };\n                 apply_tc_attr(cx, did, res)\n@@ -2365,7 +2364,7 @@ pub fn is_instantiable(cx: ctxt, r_ty: t) -> bool {\n             }\n \n             ty_tup(ref ts) => {\n-                ts.any(|t| type_requires(cx, seen, r_ty, *t))\n+                ts.iter().any_(|t| type_requires(cx, seen, r_ty, *t))\n             }\n \n             ty_enum(ref did, _) if vec::contains(*seen, did) => {"}, {"sha": "660ff83b5b3e6391412b3d21d7283dc36fdc2f07", "filename": "src/librustc/middle/typeck/astconv.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fastconv.rs?ref=49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "patch": "@@ -534,7 +534,7 @@ pub fn bound_lifetimes<AC:AstConv>(\n     let special_idents = [special_idents::statik, special_idents::self_];\n     let mut bound_lifetime_names = opt_vec::Empty;\n     ast_lifetimes.map_to_vec(|ast_lifetime| {\n-        if special_idents.any(|&i| i == ast_lifetime.ident) {\n+        if special_idents.iter().any_(|&i| i == ast_lifetime.ident) {\n             this.tcx().sess.span_err(\n                 ast_lifetime.span,\n                 fmt!(\"illegal lifetime parameter name: `%s`\","}, {"sha": "3a661f74239ae817793a4c3f2c721e00032b715b", "filename": "src/librustc/middle/typeck/check/_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2F_match.rs?ref=49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "patch": "@@ -274,7 +274,7 @@ pub fn check_struct_pat_fields(pcx: &pat_ctxt,\n \n     // Index the class fields.\n     let mut field_map = HashMap::new();\n-    for class_fields.eachi |i, class_field| {\n+    for class_fields.iter().enumerate().advance |(i, class_field)| {\n         field_map.insert(class_field.ident, i);\n     }\n \n@@ -303,7 +303,7 @@ pub fn check_struct_pat_fields(pcx: &pat_ctxt,\n \n     // Report an error if not all the fields were specified.\n     if !etc {\n-        for class_fields.eachi |i, field| {\n+        for class_fields.iter().enumerate().advance |(i, field)| {\n             if found_fields.contains(&i) {\n                 loop;\n             }\n@@ -510,7 +510,7 @@ pub fn check_pat(pcx: &pat_ctxt, pat: @ast::pat, expected: ty::t) {\n         let e_count = elts.len();\n         match s {\n             ty::ty_tup(ref ex_elts) if e_count == ex_elts.len() => {\n-                for elts.eachi |i, elt| {\n+                for elts.iter().enumerate().advance |(i, elt)| {\n                     check_pat(pcx, *elt, ex_elts[i]);\n                 }\n                 fcx.write_ty(pat.id, expected);"}, {"sha": "bdf88cb6df44f81732236f2e2d4b95544f2058e2", "filename": "src/librustc/middle/typeck/check/method.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "patch": "@@ -254,7 +254,7 @@ impl<'self> LookupContext<'self> {\n             ty_enum(did, _) => {\n                 // Watch out for newtype'd enums like \"enum t = @T\".\n                 // See discussion in typeck::check::do_autoderef().\n-                if enum_dids.contains(&did) {\n+                if enum_dids.iter().any_(|x| x == &did) {\n                     return None;\n                 }\n                 enum_dids.push(did);\n@@ -376,7 +376,7 @@ impl<'self> LookupContext<'self> {\n \n             let trait_methods = ty::trait_methods(tcx, bound_trait_ref.def_id);\n             let pos = {\n-                match trait_methods.position(|m| {\n+                match trait_methods.iter().position_(|m| {\n                     m.explicit_self != ast::sty_static &&\n                         m.ident == self.m_name })\n                 {\n@@ -543,7 +543,7 @@ impl<'self> LookupContext<'self> {\n         }\n \n         let idx = {\n-            match impl_info.methods.position(|m| m.ident == self.m_name) {\n+            match impl_info.methods.iter().position_(|m| m.ident == self.m_name) {\n                 Some(idx) => idx,\n                 None => { return; } // No method with the right name.\n             }\n@@ -813,8 +813,9 @@ impl<'self> LookupContext<'self> {\n                                rcvr_ty: ty::t,\n                                candidates: &mut ~[Candidate])\n                                -> Option<method_map_entry> {\n-        let relevant_candidates =\n-            candidates.filter_to_vec(|c| self.is_relevant(rcvr_ty, c));\n+        let relevant_candidates: ~[Candidate] =\n+            candidates.iter().transform(|c| copy *c).\n+                filter(|c| self.is_relevant(rcvr_ty, c)).collect();\n \n         let relevant_candidates = self.merge_candidates(relevant_candidates);\n \n@@ -942,7 +943,7 @@ impl<'self> LookupContext<'self> {\n                      parameters given for this method\");\n                 self.fcx.infcx().next_ty_vars(num_method_tps)\n             } else {\n-                self.supplied_tps.to_vec()\n+                self.supplied_tps.to_owned()\n             }\n         };\n "}, {"sha": "2d8233f8c0aad27ea717371745886aa6aeae2e3e", "filename": "src/librustc/middle/typeck/check/mod.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmod.rs?ref=49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "patch": "@@ -1236,7 +1236,7 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n                 vtable::early_resolve_expr(callee_expr, fcx, true);\n             }\n \n-            for args.eachi |i, arg| {\n+            for args.iter().enumerate().advance |(i, arg)| {\n                 let is_block = match arg.node {\n                     ast::expr_fn_block(*) | ast::expr_loop_body(*) |\n                     ast::expr_do_body(*) => true,\n@@ -2492,13 +2492,13 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         let discrim_ty = fcx.expr_ty(discrim);\n         let arm_tys = arms.map(|a| fcx.node_ty(a.body.node.id));\n         if ty::type_is_error(discrim_ty) ||\n-            arm_tys.any(|t| ty::type_is_error(*t)) {\n+            arm_tys.iter().any_(|t| ty::type_is_error(*t)) {\n             fcx.write_error(id);\n         }\n         // keep in mind that `all` returns true in the empty vec case,\n         // which is what we want\n         else if ty::type_is_bot(discrim_ty) ||\n-            arm_tys.all(|t| ty::type_is_bot(*t)) {\n+            arm_tys.iter().all(|t| ty::type_is_bot(*t)) {\n             fcx.write_bot(id);\n         }\n         else {\n@@ -2561,8 +2561,8 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n       ast::expr_call(f, ref args, sugar) => {\n           check_call(fcx, expr.id, expr, f, *args, sugar);\n           let f_ty = fcx.expr_ty(f);\n-          let (args_bot, args_err) = args.foldl((false, false),\n-             |&(rest_bot, rest_err), a| {\n+          let (args_bot, args_err) = args.iter().fold((false, false),\n+             |(rest_bot, rest_err), a| {\n                  // is this not working?\n                  let a_ty = fcx.expr_ty(*a);\n                  (rest_bot || ty::type_is_bot(a_ty),\n@@ -2578,8 +2578,8 @@ pub fn check_expr_with_unifier(fcx: @mut FnCtxt,\n         check_method_call(fcx, callee_id, expr, rcvr, ident, *args, *tps, sugar);\n         let f_ty = fcx.expr_ty(rcvr);\n         let arg_tys = args.map(|a| fcx.expr_ty(*a));\n-        let (args_bot, args_err) = arg_tys.foldl((false, false),\n-             |&(rest_bot, rest_err), a| {\n+        let (args_bot, args_err) = arg_tys.iter().fold((false, false),\n+             |(rest_bot, rest_err), a| {\n               (rest_bot || ty::type_is_bot(*a),\n                rest_err || ty::type_is_error(*a))});\n         if ty::type_is_error(f_ty) || args_err {\n@@ -3419,7 +3419,7 @@ pub fn check_bounds_are_used(ccx: @mut CrateCtxt,\n             true\n         });\n \n-    for tps_used.eachi |i, b| {\n+    for tps_used.iter().enumerate().advance |(i, b)| {\n         if !*b {\n             ccx.tcx.sess.span_err(\n                 span, fmt!(\"type parameter `%s` is unused\","}, {"sha": "9db873a25b0df8de874b0aca9748f02c4a301ad9", "filename": "src/librustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "patch": "@@ -103,8 +103,8 @@ pub fn replace_bound_regions_in_fn_sig(\n         }\n \n         // For each type `ty` in `tys`...\n-        do tys.foldl(isr) |isr, ty| {\n-            let mut isr = *isr;\n+        do tys.iter().fold(isr) |isr, ty| {\n+            let mut isr = isr;\n \n             // Using fold_regions is inefficient, because it\n             // constructs new types, but it avoids code duplication in"}, {"sha": "e1b9ebf977f8f228eabf6b8a17f2e98d4eb27aa3", "filename": "src/librustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "patch": "@@ -68,7 +68,7 @@ impl VtableContext {\n }\n \n fn has_trait_bounds(type_param_defs: &[ty::TypeParameterDef]) -> bool {\n-    type_param_defs.any(\n+    type_param_defs.iter().any_(\n         |type_param_def| !type_param_def.bounds.trait_bounds.is_empty())\n }\n "}, {"sha": "ef456e9a1f902e49e68b7ecb24310c93845f4392", "filename": "src/librustc/middle/typeck/collect.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fcollect.rs?ref=49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "patch": "@@ -421,7 +421,7 @@ pub fn ensure_supertraits(ccx: &CrateCtxt,\n                                               generics, self_ty);\n \n         // FIXME(#5527) Could have same trait multiple times\n-        if ty_trait_refs.any(|other_trait| other_trait.def_id == trait_ref.def_id) {\n+        if ty_trait_refs.iter().any_(|other_trait| other_trait.def_id == trait_ref.def_id) {\n             // This means a trait inherited from the same supertrait more\n             // than once.\n             tcx.sess.span_err(sp, \"Duplicate supertrait in trait declaration\");\n@@ -515,7 +515,7 @@ pub fn compare_impl_method(tcx: ty::ctxt,\n         return;\n     }\n \n-    for trait_m.generics.type_param_defs.eachi |i, trait_param_def| {\n+    for trait_m.generics.type_param_defs.iter().enumerate().advance |(i, trait_param_def)| {\n         // For each of the corresponding impl ty param's bounds...\n         let impl_param_def = &impl_m.generics.type_param_defs[i];\n \n@@ -687,11 +687,11 @@ pub fn check_methods_against_trait(ccx: &CrateCtxt,\n     // we'll catch it in coherence\n     let trait_ms = ty::trait_methods(tcx, trait_ref.def_id);\n     for impl_ms.each |impl_m| {\n-        match trait_ms.find(|trait_m| trait_m.ident == impl_m.mty.ident) {\n+        match trait_ms.iter().find_(|trait_m| trait_m.ident == impl_m.mty.ident) {\n             Some(trait_m) => {\n                 let num_impl_tps = generics.ty_params.len();\n                 compare_impl_method(\n-                    ccx.tcx, num_impl_tps, impl_m, trait_m,\n+                    ccx.tcx, num_impl_tps, impl_m, *trait_m,\n                     &trait_ref.substs, selfty);\n             }\n             None => {"}, {"sha": "773860ffc64bf369b8c9f433db92827521acc3b7", "filename": "src/librustc/middle/typeck/infer/combine.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fcombine.rs?ref=49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "patch": "@@ -265,7 +265,7 @@ pub fn super_tps<C:Combine>(\n     if vec::same_length(as_, bs) {\n         iter_vec2(as_, bs, |a, b| {\n             eq_tys(this, *a, *b)\n-        }).then(|| Ok(as_.to_vec()) )\n+        }).then(|| Ok(as_.to_owned()) )\n     } else {\n         Err(ty::terr_ty_param_size(\n             expected_found(this, as_.len(), bs.len())))"}, {"sha": "658fd67ee58558c3cec8eaf6d362e8da19595df0", "filename": "src/librustc/middle/typeck/infer/lattice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flattice.rs?ref=49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "patch": "@@ -503,7 +503,7 @@ pub fn var_ids<T:Combine>(this: &T, isr: isr_alist) -> ~[RegionVid] {\n \n pub fn is_var_in_set(new_vars: &[RegionVid], r: ty::Region) -> bool {\n     match r {\n-        ty::re_infer(ty::ReVar(ref v)) => new_vars.contains(v),\n+        ty::re_infer(ty::ReVar(ref v)) => new_vars.iter().any_(|x| x == v),\n         _ => false\n     }\n }"}, {"sha": "213af316549a9575d6a76b4e4961b1d4c7b46c4c", "filename": "src/librustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "patch": "@@ -175,7 +175,7 @@ impl Combine for Lub {\n             // Variables created during LUB computation which are\n             // *related* to regions that pre-date the LUB computation\n             // stay as they are.\n-            if !tainted.all(|r| is_var_in_set(new_vars, *r)) {\n+            if !tainted.iter().all(|r| is_var_in_set(new_vars, *r)) {\n                 debug!(\"generalize_region(r0=%?): \\\n                         non-new-variables found in %?\",\n                        r0, tainted);\n@@ -189,7 +189,7 @@ impl Combine for Lub {\n             // with.\n             for list::each(a_isr) |pair| {\n                 let (a_br, a_r) = *pair;\n-                if tainted.contains(&a_r) {\n+                if tainted.iter().any_(|x| x == &a_r) {\n                     debug!(\"generalize_region(r0=%?): \\\n                             replacing with %?, tainted=%?\",\n                            r0, a_br, tainted);"}, {"sha": "529fc48ebdf4a97483eed37ce1fc37bab9a934c1", "filename": "src/librustc/middle/typeck/infer/region_inference.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference.rs?ref=49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "patch": "@@ -980,7 +980,7 @@ impl RegionVarBindings {\n         {\n             let mut result_set = result_set;\n             if *r == *r1 { // Clearly, this is potentially inefficient.\n-                if !result_set.contains(r2) {\n+                if !result_set.iter().any_(|x| x == r2) {\n                     result_set.push(*r2);\n                 }\n             }"}, {"sha": "b0f055dc77d3595de1499d93c81a855d15d5212a", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "patch": "@@ -203,7 +203,7 @@ impl Combine for Sub {\n                 // or new variables:\n                 match *tainted_region {\n                     ty::re_infer(ty::ReVar(ref vid)) => {\n-                        if new_vars.contains(vid) { loop; }\n+                        if new_vars.iter().any_(|x| x == vid) { loop; }\n                     }\n                     _ => {\n                         if *tainted_region == skol { loop; }"}, {"sha": "99fa745fa8b0b7ded21e58fc9c718c911a750fa6", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "patch": "@@ -198,7 +198,7 @@ pub fn write_substs_to_tcx(tcx: ty::ctxt,\n     if substs.len() > 0u {\n         debug!(\"write_substs_to_tcx(%d, %?)\", node_id,\n                substs.map(|t| ppaux::ty_to_str(tcx, *t)));\n-        assert!(substs.all(|t| !ty::type_needs_infer(*t)));\n+        assert!(substs.iter().all(|t| !ty::type_needs_infer(*t)));\n         tcx.node_type_substs.insert(node_id, substs);\n     }\n }"}, {"sha": "52247d64cdc812aefa3b7fc7f2716e377c06e805", "filename": "src/librustc/rustc.rc", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustc%2Frustc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustc%2Frustc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Frustc.rc?ref=49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "patch": "@@ -216,15 +216,16 @@ pub fn run_compiler(args: &~[~str], demitter: diagnostic::Emitter) {\n     let lint_flags = vec::append(getopts::opt_strs(matches, \"W\"),\n                                  getopts::opt_strs(matches, \"warn\"));\n \n-    let show_lint_options = lint_flags.contains(&~\"help\") ||\n+    let show_lint_options = lint_flags.iter().any_(|x| x == &~\"help\") ||\n         (opt_present(matches, \"W\") && lint_flags.is_empty());\n \n     if show_lint_options {\n         describe_warnings();\n         return;\n     }\n \n-    if getopts::opt_strs(matches, \"Z\").contains(&~\"help\") {\n+    let r = getopts::opt_strs(matches, \"Z\");\n+    if r.iter().any_(|x| x == &~\"help\") {\n         describe_debug_flags();\n         return;\n     }"}, {"sha": "7b5a738f7dd2e74ef4ef91657a0e1f292a5ac445", "filename": "src/librustdoc/attr_parser.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustdoc%2Fattr_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustdoc%2Fattr_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fattr_parser.rs?ref=49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "patch": "@@ -57,15 +57,16 @@ pub fn parse_desc(attrs: ~[ast::attribute]) -> Option<~str> {\n }\n \n pub fn parse_hidden(attrs: ~[ast::attribute]) -> bool {\n-    do doc_metas(attrs).find |meta| {\n+    let r = doc_metas(attrs);\n+    do r.iter().any_ |meta| {\n         match attr::get_meta_item_list(*meta) {\n             Some(metas) => {\n                 let hiddens = attr::find_meta_items_by_name(metas, \"hidden\");\n                 !hiddens.is_empty()\n             }\n             None => false\n         }\n-    }.is_some()\n+    }\n }\n \n #[cfg(test)]"}, {"sha": "1d024d1f8b40386dffab78c62fc5debc3757a1f2", "filename": "src/librustdoc/markdown_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustdoc%2Fmarkdown_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustdoc%2Fmarkdown_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fmarkdown_pass.rs?ref=49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "patch": "@@ -190,7 +190,7 @@ pub fn header_name(doc: doc::ItemTag) -> ~str {\n             };\n             let self_ty = doc.self_ty.get_ref();\n             let mut trait_part = ~\"\";\n-            for doc.trait_types.eachi |i, trait_type| {\n+            for doc.trait_types.iter().enumerate().advance |(i, trait_type)| {\n                 if i == 0 {\n                     trait_part += \" of \";\n                 } else {"}, {"sha": "157f33fb170fe19bcfe50c1bbf17305e4ae6b038", "filename": "src/librustdoc/prune_private_pass.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustdoc%2Fprune_private_pass.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustdoc%2Fprune_private_pass.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fprune_private_pass.rs?ref=49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "patch": "@@ -82,7 +82,7 @@ fn strip_priv_methods(\n     item_vis: ast::visibility\n ) -> doc::ImplDoc {\n     let methods = do (&doc.methods).filtered |method| {\n-        let ast_method = do methods.find |m| {\n+        let ast_method = do methods.iter().find_ |m| {\n             extract::to_str(m.ident) == method.name\n         };\n         assert!(ast_method.is_some());"}, {"sha": "d02620229f5bea1cf9e16326c87829c1feeda879", "filename": "src/librustdoc/rustdoc.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustdoc%2Frustdoc.rc", "raw_url": "https://github.com/rust-lang/rust/raw/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustdoc%2Frustdoc.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Frustdoc.rc?ref=49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "patch": "@@ -78,7 +78,7 @@ mod std {\n pub fn main() {\n     let args = os::args();\n \n-    if args.contains(&~\"-h\") || args.contains(&~\"--help\") {\n+    if args.iter().any_(|x| \"-h\" == *x) || args.iter().any_(|x| \"--help\" == *x) {\n         config::usage();\n         return;\n     }"}, {"sha": "263f5395e51b1f1bf7f4be869b853e2f2e47a140", "filename": "src/librusti/rusti.rc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrusti%2Frusti.rc", "raw_url": "https://github.com/rust-lang/rust/raw/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrusti%2Frusti.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrusti%2Frusti.rc?ref=49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "patch": "@@ -287,7 +287,7 @@ fn compile_crate(src_filename: ~str, binary: ~str) -> Option<bool> {\n         // file, skip compilation and return None.\n         let mut should_compile = true;\n         let dir = os::list_dir_path(&Path(outputs.out_filename.dirname()));\n-        let maybe_lib_path = do dir.find |file| {\n+        let maybe_lib_path = do dir.iter().find_ |file| {\n             // The actual file's name has a hash value and version\n             // number in it which is unknown at this time, so looking\n             // for a file that matches out_filename won't work,\n@@ -381,7 +381,7 @@ fn run_cmd(repl: &mut Repl, _in: @io::Reader, _out: @io::Writer,\n                 let crate_path = Path(*crate);\n                 let crate_dir = crate_path.dirname();\n                 repl.program.record_extern(fmt!(\"extern mod %s;\", *crate));\n-                if !repl.lib_search_paths.contains(&crate_dir) {\n+                if !repl.lib_search_paths.iter().any_(|x| x == &crate_dir) {\n                     repl.lib_search_paths.push(crate_dir);\n                 }\n             }\n@@ -430,7 +430,7 @@ pub fn run_line(repl: &mut Repl, in: @io::Reader, out: @io::Writer, line: ~str,\n \n             if !cmd.is_empty() {\n                 let args = if len > 1 {\n-                    vec::slice(split, 1, len).to_vec()\n+                    vec::slice(split, 1, len).to_owned()\n                 } else { ~[] };\n \n                 match run_cmd(repl, in, out, cmd, args, use_rl) {"}, {"sha": "23fb130941c97b67ccb3aa5ea9a60bceb24eae0b", "filename": "src/librustpkg/package_source.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustpkg%2Fpackage_source.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustpkg%2Fpackage_source.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpackage_source.rs?ref=49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "patch": "@@ -60,9 +60,9 @@ impl PkgSrc {\n         let dir;\n         let dirs = pkgid_src_in_workspace(&self.id, &self.root);\n         debug!(\"Checking dirs: %?\", dirs);\n-        let path = dirs.find(|d| os::path_exists(d));\n+        let path = dirs.iter().find_(|&d| os::path_exists(d));\n         match path {\n-            Some(d) => dir = d,\n+            Some(d) => dir = copy *d,\n             None => dir = match self.fetch_git() {\n                 None => cond.raise((copy self.id, ~\"supplied path for package dir does not \\\n                                       exist, and couldn't interpret it as a URL fragment\")),"}, {"sha": "355cbed9ab5598e454289f0a7484b4d9da6a302c", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "patch": "@@ -570,14 +570,14 @@ fn install_remove() {\n     command_line_test([~\"install\", ~\"bar\"], &dir);\n     command_line_test([~\"install\", ~\"quux\"], &dir);\n     let list_output = command_line_test_output([~\"list\"]);\n-    assert!(list_output.contains(&~\"foo\"));\n-    assert!(list_output.contains(&~\"bar\"));\n-    assert!(list_output.contains(&~\"quux\"));\n+    assert!(list_output.iter().any_(|x| x == &~\"foo\"));\n+    assert!(list_output.iter().any_(|x| x == &~\"bar\"));\n+    assert!(list_output.iter().any_(|x| x == &~\"quux\"));\n     command_line_test([~\"remove\", ~\"foo\"], &dir);\n     let list_output = command_line_test_output([~\"list\"]);\n-    assert!(!list_output.contains(&~\"foo\"));\n-    assert!(list_output.contains(&~\"bar\"));\n-    assert!(list_output.contains(&~\"quux\"));\n+    assert!(!list_output.iter().any_(|x| x == &~\"foo\"));\n+    assert!(list_output.iter().any_(|x| x == &~\"bar\"));\n+    assert!(list_output.iter().any_(|x| x == &~\"quux\"));\n }\n \n #[test]\n@@ -643,7 +643,7 @@ fn test_versions() {\n     command_line_test([~\"install\", ~\"foo#0.1\"], &workspace);\n     let output = command_line_test_output([~\"list\"]);\n     // make sure output includes versions\n-    assert!(!output.contains(&~\"foo#0.2\"));\n+    assert!(!output.iter().any_(|x| x == &~\"foo#0.2\"));\n }\n \n #[test]"}, {"sha": "7a6384421209fcc4a29b5a37d9a9fe0d06024ec4", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "patch": "@@ -56,7 +56,7 @@ pub fn root() -> Path {\n }\n \n pub fn is_cmd(cmd: &str) -> bool {\n-    Commands.any(|&c| c == cmd)\n+    Commands.iter().any_(|&c| c == cmd)\n }\n \n struct ListenerFn {"}, {"sha": "1350751b74cefbf15b2b6fa5d2e1134c11aeaf36", "filename": "src/librustpkg/version.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustpkg%2Fversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibrustpkg%2Fversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fversion.rs?ref=49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "patch": "@@ -155,7 +155,7 @@ fn try_parsing_version(s: &str) -> Option<Version> {\n /// Just an approximation\n fn is_url_like(p: &RemotePath) -> bool {\n     let str = p.to_str();\n-    str.split_iter('/').count() > 2\n+    str.split_iter('/').len_() > 2\n }\n \n /// If s is of the form foo#bar, where bar is a valid version\n@@ -170,7 +170,7 @@ pub fn split_version_general<'a>(s: &'a str, sep: char) -> Option<(&'a str, Vers\n     for s.split_iter(sep).advance |st| {\n         debug!(\"whole = %s part = %s\", s, st);\n     }\n-    if s.split_iter(sep).count() > 2 {\n+    if s.split_iter(sep).len_() > 2 {\n         return None;\n     }\n     match s.rfind(sep) {\n@@ -208,4 +208,4 @@ fn test_split_version() {\n     let s = \"a#1.2\";\n     assert!(split_version(s) == Some((s.slice(0, 1), ExactRevision(~\"1.2\"))));\n     assert!(split_version(\"a#a#3.4\") == None);\n-}\n\\ No newline at end of file\n+}"}, {"sha": "715f2fdabd3b050402f3b6b3bac4c122638a4f9b", "filename": "src/libstd/io.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibstd%2Fio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibstd%2Fio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio.rs?ref=49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "patch": "@@ -65,7 +65,7 @@ use str::StrSlice;\n use to_str::ToStr;\n use uint;\n use vec;\n-use vec::{OwnedVector, OwnedCopyableVector};\n+use vec::{OwnedVector, OwnedCopyableVector, CopyableVector};\n \n #[allow(non_camel_case_types)] // not sure what to do about this\n pub type fd_t = c_int;\n@@ -698,7 +698,7 @@ impl<T:Reader> ReaderUtil for T {\n             // over-read by reading 1-byte per char needed\n             nbread = if ncreq > nbreq { ncreq } else { nbreq };\n             if nbread > 0 {\n-                bytes = vec::slice(bytes, offset, bytes.len()).to_vec();\n+                bytes = vec::slice(bytes, offset, bytes.len()).to_owned();\n             }\n         }\n         chars"}, {"sha": "57f23d8e657c1aea854ab6320c4bfbc64e8e2c7a", "filename": "src/libstd/iterator.rs", "status": "modified", "additions": 30, "deletions": 9, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibstd%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibstd%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fiterator.rs?ref=49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "patch": "@@ -22,7 +22,7 @@ use iter::{FromIter, Times};\n use num::{Zero, One};\n use option::{Option, Some, None};\n use ops::{Add, Mul};\n-use cmp::Ord;\n+use cmp::{Ord, Eq};\n use clone::Clone;\n \n /// An interface for dealing with \"external iterators\". These types of iterators\n@@ -273,17 +273,18 @@ pub trait IteratorUtil<A> {\n     /// ~~~\n     fn fold<B>(&mut self, start: B, f: &fn(B, A) -> B) -> B;\n \n+    // FIXME: #5898: should be called len\n     /// Counts the number of elements in this iterator.\n     ///\n     /// # Example\n     ///\n     /// ~~~ {.rust}\n     /// let a = [1, 2, 3, 4, 5];\n     /// let mut it = a.iter();\n-    /// assert!(it.count() == 5);\n-    /// assert!(it.count() == 0);\n+    /// assert!(it.len_() == 5);\n+    /// assert!(it.len_() == 0);\n     /// ~~~\n-    fn count(&mut self) -> uint;\n+    fn len_(&mut self) -> uint;\n \n     /// Tests whether the predicate holds true for all elements in the iterator.\n     ///\n@@ -314,6 +315,9 @@ pub trait IteratorUtil<A> {\n \n     /// Return the index of the first element satisfying the specified predicate\n     fn position_(&mut self, predicate: &fn(A) -> bool) -> Option<uint>;\n+\n+    /// Count the number of elements satisfying the specified predicate\n+    fn count(&mut self, predicate: &fn(A) -> bool) -> uint;\n }\n \n /// Iterator adaptors provided for every `Iterator` implementation. The adaptor objects are also\n@@ -432,7 +436,7 @@ impl<A, T: Iterator<A>> IteratorUtil<A> for T {\n \n     /// Count the number of items yielded by an iterator\n     #[inline]\n-    fn count(&mut self) -> uint { self.fold(0, |cnt, _x| cnt + 1) }\n+    fn len_(&mut self) -> uint { self.fold(0, |cnt, _x| cnt + 1) }\n \n     #[inline]\n     fn all(&mut self, f: &fn(A) -> bool) -> bool {\n@@ -467,6 +471,15 @@ impl<A, T: Iterator<A>> IteratorUtil<A> for T {\n         }\n         None\n     }\n+\n+    #[inline]\n+    fn count(&mut self, predicate: &fn(A) -> bool) -> uint {\n+        let mut i = 0;\n+        for self.advance |x| {\n+            if predicate(x) { i += 1 }\n+        }\n+        i\n+    }\n }\n \n /// A trait for iterators over elements which can be added together\n@@ -1020,11 +1033,11 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_iterator_count() {\n+    fn test_iterator_len() {\n         let v = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n-        assert_eq!(v.slice(0, 4).iter().count(), 4);\n-        assert_eq!(v.slice(0, 10).iter().count(), 10);\n-        assert_eq!(v.slice(0, 0).iter().count(), 0);\n+        assert_eq!(v.slice(0, 4).iter().len_(), 4);\n+        assert_eq!(v.slice(0, 10).iter().len_(), 10);\n+        assert_eq!(v.slice(0, 0).iter().len_(), 0);\n     }\n \n     #[test]\n@@ -1099,4 +1112,12 @@ mod tests {\n         assert_eq!(v.iter().position_(|x| *x % 3 == 0).unwrap(), 1);\n         assert!(v.iter().position_(|x| *x % 12 == 0).is_none());\n     }\n+\n+    #[test]\n+    fn test_count() {\n+        let xs = &[1, 2, 2, 1, 5, 9, 0, 2];\n+        assert_eq!(xs.iter().count(|x| *x == 2), 3);\n+        assert_eq!(xs.iter().count(|x| *x == 5), 1);\n+        assert_eq!(xs.iter().count(|x| *x == 95), 0);\n+    }\n }"}, {"sha": "9b87d76a309d030d26bc7987d9d6eb9213219f24", "filename": "src/libstd/old_iter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibstd%2Fold_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibstd%2Fold_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fold_iter.rs?ref=49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "patch": "@@ -16,7 +16,7 @@\n \n #[allow(missing_doc)];\n \n-use cmp::{Eq};\n+use cmp::Eq;\n use kinds::Copy;\n use option::{None, Option, Some};\n use vec;"}, {"sha": "fd11b49a00a310afa57f5ee088f8a7e83bec2ba0", "filename": "src/libstd/str.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "patch": "@@ -1317,7 +1317,7 @@ impl<'self> StrSlice<'self> for &'self str {\n     }\n     /// Returns the number of characters that a string holds\n     #[inline]\n-    fn char_len(&self) -> uint { self.iter().count() }\n+    fn char_len(&self) -> uint { self.iter().len_() }\n \n     /**\n      * Returns a slice of the given string from the byte range"}, {"sha": "0956b76c970a5daf67333dd104a247fa50ad620c", "filename": "src/libstd/task/local_data_priv.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibstd%2Ftask%2Flocal_data_priv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibstd%2Ftask%2Flocal_data_priv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftask%2Flocal_data_priv.rs?ref=49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "patch": "@@ -142,7 +142,7 @@ unsafe fn local_data_lookup<T: 'static>(\n     -> Option<(uint, *libc::c_void)> {\n \n     let key_value = key_to_key_value(key);\n-    let map_pos = (*map).position(|entry|\n+    let map_pos = (*map).iter().position_(|entry|\n         match *entry {\n             Some((k,_,_)) => k == key_value,\n             None => false\n@@ -215,7 +215,7 @@ pub unsafe fn local_set<T: 'static>(\n         }\n         None => {\n             // Find an empty slot. If not, grow the vector.\n-            match (*map).position(|x| x.is_none()) {\n+            match (*map).iter().position_(|x| x.is_none()) {\n                 Some(empty_index) => { map[empty_index] = new_entry; }\n                 None => { map.push(new_entry); }\n             }"}, {"sha": "87bd25bdad32257f4985dd1082e693c215319b31", "filename": "src/libstd/unstable/extfmt.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibstd%2Funstable%2Fextfmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibstd%2Funstable%2Fextfmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fextfmt.rs?ref=49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "patch": "@@ -350,7 +350,7 @@ pub mod ct {\n     #[test]\n     fn test_parse_flags() {\n         fn pack(fs: &[Flag]) -> uint {\n-            fs.foldl(0, |&p, &f| p | (1 << f as uint))\n+            fs.iter().fold(0, |p, &f| p | (1 << f as uint))\n         }\n \n         fn test(s: &str, flags: &[Flag], next: uint) {"}, {"sha": "ad03d8fc4a0ba50a9acd7b8da3d16fbe401adbbc", "filename": "src/libstd/vec.rs", "status": "modified", "additions": 12, "deletions": 175, "changes": 187, "blob_url": "https://github.com/rust-lang/rust/blob/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibstd%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibstd%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fvec.rs?ref=49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "patch": "@@ -24,7 +24,6 @@ use iter::FromIter;\n use kinds::Copy;\n use libc;\n use num::Zero;\n-use old_iter::CopyableIter;\n use option::{None, Option, Some};\n use ptr::to_unsafe_ptr;\n use ptr;\n@@ -324,12 +323,12 @@ pub fn split<T:Copy>(v: &[T], f: &fn(t: &T) -> bool) -> ~[~[T]] {\n         match position_between(v, start, ln, f) {\n             None => break,\n             Some(i) => {\n-                result.push(slice(v, start, i).to_vec());\n+                result.push(slice(v, start, i).to_owned());\n                 start = i + 1u;\n             }\n         }\n     }\n-    result.push(slice(v, start, ln).to_vec());\n+    result.push(slice(v, start, ln).to_owned());\n     result\n }\n \n@@ -348,14 +347,14 @@ pub fn splitn<T:Copy>(v: &[T], n: uint, f: &fn(t: &T) -> bool) -> ~[~[T]] {\n         match position_between(v, start, ln, f) {\n             None => break,\n             Some(i) => {\n-                result.push(slice(v, start, i).to_vec());\n+                result.push(slice(v, start, i).to_owned());\n                 // Make sure to skip the separator.\n                 start = i + 1u;\n                 count -= 1u;\n             }\n         }\n     }\n-    result.push(slice(v, start, ln).to_vec());\n+    result.push(slice(v, start, ln).to_owned());\n     result\n }\n \n@@ -373,12 +372,12 @@ pub fn rsplit<T:Copy>(v: &[T], f: &fn(t: &T) -> bool) -> ~[~[T]] {\n         match rposition_between(v, 0, end, f) {\n             None => break,\n             Some(i) => {\n-                result.push(slice(v, i + 1, end).to_vec());\n+                result.push(slice(v, i + 1, end).to_owned());\n                 end = i;\n             }\n         }\n     }\n-    result.push(slice(v, 0u, end).to_vec());\n+    result.push(slice(v, 0u, end).to_owned());\n     reverse(result);\n     result\n }\n@@ -398,14 +397,14 @@ pub fn rsplitn<T:Copy>(v: &[T], n: uint, f: &fn(t: &T) -> bool) -> ~[~[T]] {\n         match rposition_between(v, 0u, end, f) {\n             None => break,\n             Some(i) => {\n-                result.push(slice(v, i + 1u, end).to_vec());\n+                result.push(slice(v, i + 1u, end).to_owned());\n                 // Make sure to skip the separator.\n                 end = i;\n                 count -= 1u;\n             }\n         }\n     }\n-    result.push(slice(v, 0u, end).to_vec());\n+    result.push(slice(v, 0u, end).to_owned());\n     reverse(result);\n     result\n }\n@@ -1792,7 +1791,6 @@ pub trait ImmutableVector<'self, T> {\n     fn initn(&self, n: uint) -> &'self [T];\n     fn last(&self) -> &'self T;\n     fn last_opt(&self) -> Option<&'self T>;\n-    fn position(&self, f: &fn(t: &T) -> bool) -> Option<uint>;\n     fn rposition(&self, f: &fn(t: &T) -> bool) -> Option<uint>;\n     fn map<U>(&self, f: &fn(t: &T) -> U) -> ~[U];\n     fn mapi<U>(&self, f: &fn(uint, t: &T) -> U) -> ~[U];\n@@ -1860,18 +1858,6 @@ impl<'self,T> ImmutableVector<'self, T> for &'self [T] {\n     #[inline]\n     fn last_opt(&self) -> Option<&'self T> { last_opt(*self) }\n \n-    /**\n-     * Find the first index matching some predicate\n-     *\n-     * Apply function `f` to each element of `v`.  When function `f` returns\n-     * true then an option containing the index is returned. If `f` matches no\n-     * elements then none is returned.\n-     */\n-    #[inline]\n-    fn position(&self, f: &fn(t: &T) -> bool) -> Option<uint> {\n-        position(*self, f)\n-    }\n-\n     /**\n      * Find the last index matching some predicate\n      *\n@@ -2434,9 +2420,6 @@ pub mod bytes {\n     }\n }\n \n-// ___________________________________________________________________________\n-// ITERATION TRAIT METHODS\n-\n impl<'self,A> old_iter::BaseIter<A> for &'self [A] {\n     #[inline]\n     fn each<'a>(&'a self, blk: &fn(v: &'a A) -> bool) -> bool {\n@@ -2446,152 +2429,6 @@ impl<'self,A> old_iter::BaseIter<A> for &'self [A] {\n     fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n }\n \n-// FIXME(#4148): This should be redundant\n-impl<A> old_iter::BaseIter<A> for ~[A] {\n-    #[inline]\n-    fn each<'a>(&'a self, blk: &fn(v: &'a A) -> bool) -> bool {\n-        each(*self, blk)\n-    }\n-    #[inline]\n-    fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n-}\n-\n-// FIXME(#4148): This should be redundant\n-impl<A> old_iter::BaseIter<A> for @[A] {\n-    #[inline]\n-    fn each<'a>(&'a self, blk: &fn(v: &'a A) -> bool) -> bool {\n-        each(*self, blk)\n-    }\n-    #[inline]\n-    fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n-}\n-\n-impl<'self,A> old_iter::ExtendedIter<A> for &'self [A] {\n-    pub fn eachi(&self, blk: &fn(uint, v: &A) -> bool) -> bool {\n-        old_iter::eachi(self, blk)\n-    }\n-    pub fn all(&self, blk: &fn(&A) -> bool) -> bool {\n-        old_iter::all(self, blk)\n-    }\n-    pub fn any(&self, blk: &fn(&A) -> bool) -> bool {\n-        old_iter::any(self, blk)\n-    }\n-    pub fn foldl<B>(&self, b0: B, blk: &fn(&B, &A) -> B) -> B {\n-        old_iter::foldl(self, b0, blk)\n-    }\n-    pub fn position(&self, f: &fn(&A) -> bool) -> Option<uint> {\n-        old_iter::position(self, f)\n-    }\n-    fn map_to_vec<B>(&self, op: &fn(&A) -> B) -> ~[B] {\n-        old_iter::map_to_vec(self, op)\n-    }\n-    fn flat_map_to_vec<B,IB:BaseIter<B>>(&self, op: &fn(&A) -> IB)\n-        -> ~[B] {\n-        old_iter::flat_map_to_vec(self, op)\n-    }\n-}\n-\n-// FIXME(#4148): This should be redundant\n-impl<A> old_iter::ExtendedIter<A> for ~[A] {\n-    pub fn eachi(&self, blk: &fn(uint, v: &A) -> bool) -> bool {\n-        old_iter::eachi(self, blk)\n-    }\n-    pub fn all(&self, blk: &fn(&A) -> bool) -> bool {\n-        old_iter::all(self, blk)\n-    }\n-    pub fn any(&self, blk: &fn(&A) -> bool) -> bool {\n-        old_iter::any(self, blk)\n-    }\n-    pub fn foldl<B>(&self, b0: B, blk: &fn(&B, &A) -> B) -> B {\n-        old_iter::foldl(self, b0, blk)\n-    }\n-    pub fn position(&self, f: &fn(&A) -> bool) -> Option<uint> {\n-        old_iter::position(self, f)\n-    }\n-    fn map_to_vec<B>(&self, op: &fn(&A) -> B) -> ~[B] {\n-        old_iter::map_to_vec(self, op)\n-    }\n-    fn flat_map_to_vec<B,IB:BaseIter<B>>(&self, op: &fn(&A) -> IB)\n-        -> ~[B] {\n-        old_iter::flat_map_to_vec(self, op)\n-    }\n-}\n-\n-// FIXME(#4148): This should be redundant\n-impl<A> old_iter::ExtendedIter<A> for @[A] {\n-    pub fn eachi(&self, blk: &fn(uint, v: &A) -> bool) -> bool {\n-        old_iter::eachi(self, blk)\n-    }\n-    pub fn all(&self, blk: &fn(&A) -> bool) -> bool {\n-        old_iter::all(self, blk)\n-    }\n-    pub fn any(&self, blk: &fn(&A) -> bool) -> bool {\n-        old_iter::any(self, blk)\n-    }\n-    pub fn foldl<B>(&self, b0: B, blk: &fn(&B, &A) -> B) -> B {\n-        old_iter::foldl(self, b0, blk)\n-    }\n-    pub fn position(&self, f: &fn(&A) -> bool) -> Option<uint> {\n-        old_iter::position(self, f)\n-    }\n-    fn map_to_vec<B>(&self, op: &fn(&A) -> B) -> ~[B] {\n-        old_iter::map_to_vec(self, op)\n-    }\n-    fn flat_map_to_vec<B,IB:BaseIter<B>>(&self, op: &fn(&A) -> IB)\n-        -> ~[B] {\n-        old_iter::flat_map_to_vec(self, op)\n-    }\n-}\n-\n-impl<'self,A:Eq> old_iter::EqIter<A> for &'self [A] {\n-    pub fn contains(&self, x: &A) -> bool { old_iter::contains(self, x) }\n-    pub fn count(&self, x: &A) -> uint { old_iter::count(self, x) }\n-}\n-\n-// FIXME(#4148): This should be redundant\n-impl<A:Eq> old_iter::EqIter<A> for ~[A] {\n-    pub fn contains(&self, x: &A) -> bool { old_iter::contains(self, x) }\n-    pub fn count(&self, x: &A) -> uint { old_iter::count(self, x) }\n-}\n-\n-// FIXME(#4148): This should be redundant\n-impl<A:Eq> old_iter::EqIter<A> for @[A] {\n-    pub fn contains(&self, x: &A) -> bool { old_iter::contains(self, x) }\n-    pub fn count(&self, x: &A) -> uint { old_iter::count(self, x) }\n-}\n-\n-impl<'self,A:Copy> old_iter::CopyableIter<A> for &'self [A] {\n-    fn filter_to_vec(&self, pred: &fn(&A) -> bool) -> ~[A] {\n-        old_iter::filter_to_vec(self, pred)\n-    }\n-    fn to_vec(&self) -> ~[A] { old_iter::to_vec(self) }\n-    pub fn find(&self, f: &fn(&A) -> bool) -> Option<A> {\n-        old_iter::find(self, f)\n-    }\n-}\n-\n-// FIXME(#4148): This should be redundant\n-impl<A:Copy> old_iter::CopyableIter<A> for ~[A] {\n-    fn filter_to_vec(&self, pred: &fn(&A) -> bool) -> ~[A] {\n-        old_iter::filter_to_vec(self, pred)\n-    }\n-    fn to_vec(&self) -> ~[A] { old_iter::to_vec(self) }\n-    pub fn find(&self, f: &fn(&A) -> bool) -> Option<A> {\n-        old_iter::find(self, f)\n-    }\n-}\n-\n-// FIXME(#4148): This should be redundant\n-impl<A:Copy> old_iter::CopyableIter<A> for @[A] {\n-    fn filter_to_vec(&self, pred: &fn(&A) -> bool) -> ~[A] {\n-        old_iter::filter_to_vec(self, pred)\n-    }\n-    fn to_vec(&self) -> ~[A] { old_iter::to_vec(self) }\n-    pub fn find(&self, f: &fn(&A) -> bool) -> Option<A> {\n-        old_iter::find(self, f)\n-    }\n-}\n-\n impl<A:Clone> Clone for ~[A] {\n     #[inline]\n     fn clone(&self) -> ~[A] {\n@@ -2916,30 +2753,30 @@ mod tests {\n     fn test_slice() {\n         // Test fixed length vector.\n         let vec_fixed = [1, 2, 3, 4];\n-        let v_a = slice(vec_fixed, 1u, vec_fixed.len()).to_vec();\n+        let v_a = slice(vec_fixed, 1u, vec_fixed.len()).to_owned();\n         assert_eq!(v_a.len(), 3u);\n         assert_eq!(v_a[0], 2);\n         assert_eq!(v_a[1], 3);\n         assert_eq!(v_a[2], 4);\n \n         // Test on stack.\n         let vec_stack = &[1, 2, 3];\n-        let v_b = slice(vec_stack, 1u, 3u).to_vec();\n+        let v_b = slice(vec_stack, 1u, 3u).to_owned();\n         assert_eq!(v_b.len(), 2u);\n         assert_eq!(v_b[0], 2);\n         assert_eq!(v_b[1], 3);\n \n         // Test on managed heap.\n         let vec_managed = @[1, 2, 3, 4, 5];\n-        let v_c = slice(vec_managed, 0u, 3u).to_vec();\n+        let v_c = slice(vec_managed, 0u, 3u).to_owned();\n         assert_eq!(v_c.len(), 3u);\n         assert_eq!(v_c[0], 1);\n         assert_eq!(v_c[1], 2);\n         assert_eq!(v_c[2], 3);\n \n         // Test on exchange heap.\n         let vec_unique = ~[1, 2, 3, 4, 5, 6];\n-        let v_d = slice(vec_unique, 1u, 6u).to_vec();\n+        let v_d = slice(vec_unique, 1u, 6u).to_owned();\n         assert_eq!(v_d.len(), 5u);\n         assert_eq!(v_d[0], 2);\n         assert_eq!(v_d[1], 3);"}, {"sha": "943a38a337ff1ec6b774b65ce8b179b378a6e198", "filename": "src/libsyntax/abi.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibsyntax%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibsyntax%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fabi.rs?ref=49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "patch": "@@ -211,7 +211,7 @@ impl AbiSet {\n         let mut abis = ~[];\n         for self.each |abi| { abis.push(abi); }\n \n-        for abis.eachi |i, abi| {\n+        for abis.iter().enumerate().advance |(i, abi)| {\n             let data = abi.data();\n             for abis.slice(0, i).each |other_abi| {\n                 let other_data = other_abi.data();\n@@ -374,7 +374,7 @@ fn abi_to_str_rust() {\n \n #[test]\n fn indices_are_correct() {\n-    for AbiDatas.eachi |i, abi_data| {\n+    for AbiDatas.iter().enumerate().advance |(i, abi_data)| {\n         assert!(i == abi_data.abi.index());\n     }\n "}, {"sha": "96e05fd2beb40389efa27df4f8262edf0c6847de", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "patch": "@@ -194,7 +194,7 @@ fn eq(a: @ast::meta_item, b: @ast::meta_item) -> bool {\n             ast::meta_list(ref nb, ref misb) => {\n                 if na != nb { return false; }\n                 for misa.each |mi| {\n-                    if !misb.contains(mi) { return false; }\n+                    if !misb.iter().any_(|x| x == mi) { return false; }\n                 }\n                 true\n             }"}, {"sha": "249c1c79a377212597b0625a8c5302ccbbac870c", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "patch": "@@ -246,7 +246,7 @@ fn highlight_lines(cm: @codemap::CodeMap,\n     let mut elided = false;\n     let mut display_lines = /* FIXME (#2543) */ copy lines.lines;\n     if display_lines.len() > max_lines {\n-        display_lines = vec::slice(display_lines, 0u, max_lines).to_vec();\n+        display_lines = vec::slice(display_lines, 0u, max_lines).to_owned();\n         elided = true;\n     }\n     // Print the offending lines"}, {"sha": "e7fb15fbd51cd18bb30b0e454f6393c3658aa3a5", "filename": "src/libsyntax/ext/concat_idents.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibsyntax%2Fext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fconcat_idents.rs?ref=49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "patch": "@@ -20,7 +20,7 @@ use parse::token::{str_to_ident};\n pub fn expand_syntax_ext(cx: @ExtCtxt, sp: span, tts: &[ast::token_tree])\n     -> base::MacResult {\n     let mut res_str = ~\"\";\n-    for tts.eachi |i, e| {\n+    for tts.iter().enumerate().advance |(i, e)| {\n         if i & 1 == 1 {\n             match *e {\n                 ast::tt_tok(_, token::COMMA) => (),"}, {"sha": "7d17f436a41d86f463856d00439d1a1128f9f6f2", "filename": "src/libsyntax/ext/deriving/decodable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs?ref=49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "patch": "@@ -111,7 +111,7 @@ fn decodable_substructure(cx: @ExtCtxt, span: span,\n             let mut variants = ~[];\n             let rvariant_arg = cx.ident_of(\"read_enum_variant_arg\");\n \n-            for fields.eachi |i, f| {\n+            for fields.iter().enumerate().advance |(i, f)| {\n                 let (name, parts) = match *f { (i, ref p) => (i, p) };\n                 variants.push(cx.expr_str(span, cx.str_of(name)));\n "}, {"sha": "2b73dc24d33a1ba54cad82a388b2969a0a73021f", "filename": "src/libsyntax/ext/deriving/encodable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs?ref=49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "patch": "@@ -124,7 +124,7 @@ fn encodable_substructure(cx: @ExtCtxt, span: span,\n         Struct(ref fields) => {\n             let emit_struct_field = cx.ident_of(\"emit_struct_field\");\n             let mut stmts = ~[];\n-            for fields.eachi |i, f| {\n+            for fields.iter().enumerate().advance |(i, f)| {\n                 let (name, val) = match *f {\n                     (Some(id), e, _) => (cx.str_of(id), e),\n                     (None, e, _) => (fmt!(\"_field%u\", i).to_managed(), e)\n@@ -155,7 +155,7 @@ fn encodable_substructure(cx: @ExtCtxt, span: span,\n             let encoder = cx.expr_ident(span, blkarg);\n             let emit_variant_arg = cx.ident_of(\"emit_enum_variant_arg\");\n             let mut stmts = ~[];\n-            for fields.eachi |i, f| {\n+            for fields.iter().enumerate().advance |(i, f)| {\n                 let val = match *f { (_, e, _) => e };\n                 let enc = cx.expr_method_call(span, val, encode, ~[blkencoder]);\n                 let lambda = cx.lambda_expr_1(span, enc, blkarg);"}, {"sha": "d44d466829944a911639574b15470f5ae48ff173", "filename": "src/libsyntax/ext/deriving/generic.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric.rs?ref=49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "patch": "@@ -487,7 +487,7 @@ impl<'self> MethodDef<'self> {\n             None => respan(span, ast::sty_static),\n         };\n \n-        for self.args.eachi |i, ty| {\n+        for self.args.iter().enumerate().advance |(i, ty)| {\n             let ast_ty = ty.to_ty(cx, span, type_ident, generics);\n             let ident = cx.ident_of(fmt!(\"__arg_%u\", i));\n             arg_tys.push((ident, ast_ty));\n@@ -741,7 +741,7 @@ impl<'self> MethodDef<'self> {\n                     let mut enum_matching_fields = vec::from_elem(self_vec.len(), ~[]);\n \n                     for matches_so_far.tail().each |&(_, _, other_fields)| {\n-                        for other_fields.eachi |i, &(_, other_field)| {\n+                        for other_fields.iter().enumerate().advance |(i, &(_, other_field))| {\n                             enum_matching_fields[i].push(other_field);\n                         }\n                     }\n@@ -809,7 +809,7 @@ impl<'self> MethodDef<'self> {\n                 }\n             } else {\n                 // create an arm matching on each variant\n-                for enum_def.variants.eachi |index, variant| {\n+                for enum_def.variants.iter().enumerate().advance |(index, variant)| {\n                     let (pattern, idents) = create_enum_variant_pattern(cx, span,\n                                                                        variant,\n                                                                        current_match_str,\n@@ -923,7 +923,7 @@ fn create_struct_pattern(cx: @ExtCtxt,\n     let mut ident_expr = ~[];\n     let mut struct_type = Unknown;\n \n-    for struct_def.fields.eachi |i, struct_field| {\n+    for struct_def.fields.iter().enumerate().advance |(i, struct_field)| {\n         let opt_id = match struct_field.node.kind {\n             ast::named_field(ident, _) if (struct_type == Unknown ||\n                                            struct_type == Record) => {"}, {"sha": "f6504e85b43b11acec2854c2d8554fd1cb519cd8", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "patch": "@@ -200,7 +200,7 @@ pub fn expand_item(extsbox: @mut SyntaxEnv,\n \n // does this attribute list contain \"macro_escape\" ?\n pub fn contains_macro_escape (attrs: &[ast::attribute]) -> bool {\n-    attrs.any(|attr| \"macro_escape\" == attr::get_attr_name(attr))\n+    attrs.iter().any_(|attr| \"macro_escape\" == attr::get_attr_name(attr))\n }\n \n // Support for item-position macro invocations, exactly the same\n@@ -425,8 +425,8 @@ fn renames_to_fold(renames : @mut ~[(ast::ident,ast::Name)]) -> @ast_fold {\n         fold_ident: |id,_| {\n             // the individual elements are memoized... it would\n             // also be possible to memoize on the whole list at once.\n-            let new_ctxt = renames.foldl(id.ctxt,|ctxt,&(from,to)| {\n-                new_rename(from,to,*ctxt)\n+            let new_ctxt = renames.iter().fold(id.ctxt,|ctxt,&(from,to)| {\n+                new_rename(from,to,ctxt)\n             });\n             ast::ident{name:id.name,ctxt:new_ctxt}\n         },"}, {"sha": "8b044bd14e117c5bf060ee974f2e3be43e58c2e3", "filename": "src/libsyntax/ext/pipes/liveness.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibsyntax%2Fext%2Fpipes%2Fliveness.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibsyntax%2Fext%2Fpipes%2Fliveness.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fliveness.rs?ref=49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "patch": "@@ -47,21 +47,21 @@ use extra::bitv::Bitv;\n pub fn analyze(proto: @mut protocol_, _cx: @ExtCtxt) {\n     debug!(\"initializing colive analysis\");\n     let num_states = proto.num_states();\n-    let mut colive = do (copy proto.states).map_to_vec |state| {\n+    let mut colive: ~[~Bitv] = do (copy proto.states).iter().transform() |state| {\n         let mut bv = ~Bitv::new(num_states, false);\n         for state.reachable |s| {\n             bv.set(s.id, true);\n         }\n         bv\n-    };\n+    }.collect();\n \n     let mut i = 0;\n     let mut changed = true;\n     while changed {\n         changed = false;\n         debug!(\"colive iteration %?\", i);\n         let mut new_colive = ~[];\n-        for colive.eachi |i, this_colive| {\n+        for colive.iter().enumerate().advance |(i, this_colive)| {\n             let mut result = this_colive.clone();\n             let this = proto.get_state_by_id(i);\n             for this_colive.ones |j| {\n@@ -80,7 +80,7 @@ pub fn analyze(proto: @mut protocol_, _cx: @ExtCtxt) {\n \n     // Determine if we're bounded\n     let mut self_live = ~[];\n-    for colive.eachi |i, bv| {\n+    for colive.iter().enumerate().advance |(i, bv)| {\n         if bv.get(i) {\n             self_live.push(proto.get_state_by_id(i))\n         }"}, {"sha": "083386fe720cce0dfcd7add324ac9bf89b37edcf", "filename": "src/libsyntax/ext/pipes/pipec.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fpipec.rs?ref=49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "patch": "@@ -333,14 +333,14 @@ impl gen_init for protocol {\n             dummy_sp(),\n             path(~[ext_cx.ident_of(\"__Buffer\")],\n                  dummy_sp()),\n-            self.states.map_to_vec(|s| {\n+            self.states.iter().transform(|s| {\n                 let fty = s.to_ty(ext_cx);\n                 ext_cx.field_imm(dummy_sp(),\n                                  ext_cx.ident_of(s.name),\n                                  quote_expr!(\n                                      ::std::pipes::mk_packet::<$fty>()\n                                  ))\n-            }))\n+            }).collect())\n     }\n \n     fn gen_init_bounded(&self, ext_cx: @ExtCtxt) -> @ast::expr {\n@@ -354,10 +354,10 @@ impl gen_init for protocol {\n         let entangle_body = ext_cx.expr_blk(\n             ext_cx.blk(\n                 dummy_sp(),\n-                self.states.map_to_vec(\n+                self.states.iter().transform(\n                     |s| ext_cx.parse_stmt(\n                         fmt!(\"data.%s.set_buffer(buffer)\",\n-                             s.name).to_managed())),\n+                             s.name).to_managed())).collect(),\n                 Some(ext_cx.parse_expr(fmt!(\n                     \"::std::ptr::to_mut_unsafe_ptr(&mut (data.%s))\",\n                     self.states[0].name).to_managed()))));\n@@ -390,7 +390,7 @@ impl gen_init for protocol {\n     fn gen_buffer_type(&self, cx: @ExtCtxt) -> @ast::item {\n         let ext_cx = cx;\n         let mut params: OptVec<ast::TyParam> = opt_vec::Empty;\n-        let fields = do (copy self.states).map_to_vec |s| {\n+        let fields = do (copy self.states).iter().transform |s| {\n             for s.generics.ty_params.each |tp| {\n                 match params.find(|tpp| tp.ident == tpp.ident) {\n                   None => params.push(*tp),\n@@ -411,7 +411,7 @@ impl gen_init for protocol {\n                 },\n                 span: dummy_sp()\n             }\n-        };\n+        }.collect();\n \n         let generics = Generics {\n             lifetimes: opt_vec::Empty,"}, {"sha": "3df19ed0a76eb875b9c5659ef65ee339958448cd", "filename": "src/libsyntax/ext/pipes/proto.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fpipes%2Fproto.rs?ref=49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "patch": "@@ -146,13 +146,13 @@ pub struct protocol_ {\n impl protocol_ {\n     /// Get a state.\n     pub fn get_state(&self, name: &str) -> state {\n-        self.states.find(|i| name == i.name).get()\n+        *self.states.iter().find_(|i| name == i.name).get()\n     }\n \n     pub fn get_state_by_id(&self, id: uint) -> state { self.states[id] }\n \n     pub fn has_state(&self, name: &str) -> bool {\n-        self.states.find(|i| name == i.name).is_some()\n+        self.states.iter().find_(|i| name == i.name).is_some()\n     }\n \n     pub fn filename(&self) -> ~str {\n@@ -216,12 +216,12 @@ pub fn visit<Tproto, Tstate, Tmessage, V: visitor<Tproto, Tstate, Tmessage>>(\n     proto: protocol, visitor: V) -> Tproto {\n \n     // the copy keywords prevent recursive use of dvec\n-    let states = do (copy proto.states).map_to_vec |&s| {\n-        let messages = do (copy s.messages).map_to_vec |&m| {\n+    let states: ~[Tstate] = do (copy proto.states).iter().transform |&s| {\n+        let messages: ~[Tmessage] = do (copy s.messages).iter().transform |&m| {\n             let message(name, span, tys, this, next) = m;\n             visitor.visit_message(name, span, tys, this, next)\n-        };\n+        }.collect();\n         visitor.visit_state(s, messages)\n-    };\n+    }.collect();\n     visitor.visit_proto(proto, states)\n }"}, {"sha": "2b65e6599f66701579d9968d72efb653f966683e", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "patch": "@@ -94,7 +94,7 @@ pub fn add_new_extension(cx: @ExtCtxt,\n \n         let s_d = cx.parse_sess().span_diagnostic;\n \n-        for lhses.eachi |i, lhs| { // try each arm's matchers\n+        for lhses.iter().enumerate().advance |(i, lhs)| { // try each arm's matchers\n             match *lhs {\n               @matched_nonterminal(nt_matchers(ref mtcs)) => {\n                 // `none` is because we're not interpolating"}, {"sha": "d73c5240a1c02af71d9c7cf7735d56bcd6d2c1a2", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "patch": "@@ -592,7 +592,7 @@ pub fn print_item(s: @ps, item: @ast::item) {\n         print_generics(s, generics);\n         if traits.len() != 0u {\n             word(s.s, \":\");\n-            for traits.eachi |i, trait_| {\n+            for traits.iter().enumerate().advance |(i, trait_)| {\n                 nbsp(s);\n                 if i != 0 {\n                     word_space(s, \"+\");\n@@ -758,7 +758,7 @@ pub fn print_tt(s: @ps, tt: &ast::token_tree) {\n \n pub fn print_tts(s: @ps, tts: &[ast::token_tree]) {\n     ibox(s, 0);\n-    for tts.eachi |i, tt| {\n+    for tts.iter().enumerate().advance |(i, tt)| {\n         if i != 0 {\n             space(s.s);\n         }\n@@ -1229,7 +1229,7 @@ pub fn print_expr(s: @ps, expr: @ast::expr) {\n         space(s.s);\n         bopen(s);\n         let len = arms.len();\n-        for arms.eachi |i, arm| {\n+        for arms.iter().enumerate().advance |(i, arm)| {\n             space(s.s);\n             cbox(s, indent_unit);\n             ibox(s, 0u);"}, {"sha": "4b5880de8a52e291dc790aac33e8d8b1a6726c51", "filename": "src/test/bench/core-std.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Ftest%2Fbench%2Fcore-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Ftest%2Fbench%2Fcore-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fcore-std.rs?ref=49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "patch": "@@ -44,7 +44,7 @@ fn maybe_run_test(argv: &[~str], name: ~str, test: &fn()) {\n     if os::getenv(~\"RUST_BENCH\").is_some() {\n         run_test = true\n     } else if argv.len() > 0 {\n-        run_test = argv.contains(&~\"all\") || argv.contains(&name)\n+        run_test = argv.iter().any_(|x| x == &~\"all\") || argv.iter().any_(|x| x == &name)\n     }\n \n     if !run_test {"}, {"sha": "a2edc1efa66a7bb1bd3e0a3e801ed778dee9eeac", "filename": "src/test/bench/graph500-bfs.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Ftest%2Fbench%2Fgraph500-bfs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fgraph500-bfs.rs?ref=49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "patch": "@@ -378,7 +378,7 @@ fn validate(edges: ~[(node_id, node_id)],\n \n     info!(~\"Verifying graph edges...\");\n \n-    let status = do edges.all() |e| {\n+    let status = do edges.iter().all |e| {\n         let (u, v) = *e;\n \n         abs(level[u] - level[v]) <= 1\n@@ -402,7 +402,7 @@ fn validate(edges: ~[(node_id, node_id)],\n             if *v == -1i64 || u == root {\n                 true\n             } else {\n-                edges.contains(&(u, *v)) || edges.contains(&(*v, u))\n+                edges.iter().any_(|x| x == &(u, *v)) || edges.iter().any_(|x| x == &(*v, u))\n             }\n         };\n         result"}, {"sha": "81a3482b4f88a2439e436e1bd52df6e3f07907c8", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "patch": "@@ -90,7 +90,7 @@ fn find(mm: &HashMap<~[u8], uint>, key: ~str) -> uint {\n \n // given a map, increment the counter for a key\n fn update_freq(mm: &mut HashMap<~[u8], uint>, key: &[u8]) {\n-    let key = vec::slice(key, 0, key.len()).to_vec();\n+    let key = vec::slice(key, 0, key.len()).to_owned();\n     let newval = match mm.pop(&key) {\n         Some(v) => v + 1,\n         None => 1\n@@ -111,7 +111,7 @@ fn windows_with_carry(bb: &[u8], nn: uint,\n       ii += 1u;\n    }\n \n-   return vec::slice(bb, len - (nn - 1u), len).to_vec();\n+   return vec::slice(bb, len - (nn - 1u), len).to_owned();\n }\n \n fn make_sequence_processor(sz: uint,\n@@ -211,7 +211,7 @@ fn main() {\n          (_, true) => {\n             let line_bytes = line.as_bytes();\n \n-           for sizes.eachi |ii, _sz| {\n+           for sizes.iter().enumerate().advance |(ii, _sz)| {\n                let mut lb = line_bytes.to_owned();\n                to_child[ii].send(lb);\n             }\n@@ -223,12 +223,12 @@ fn main() {\n    }\n \n    // finish...\n-    for sizes.eachi |ii, _sz| {\n+    for sizes.iter().enumerate().advance |(ii, _sz)| {\n       to_child[ii].send(~[]);\n    }\n \n    // now fetch and print result messages\n-    for sizes.eachi |ii, _sz| {\n+    for sizes.iter().enumerate().advance |(ii, _sz)| {\n       io::println(from_child[ii].recv());\n    }\n }"}, {"sha": "534df512a48109796a23517f9b3beef952436cd6", "filename": "src/test/bench/shootout-spectralnorm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-spectralnorm.rs?ref=49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "patch": "@@ -10,7 +10,7 @@ fn A(i: i32, j: i32) -> i32 {\n \n fn dot(v: &[f64], u: &[f64]) -> f64 {\n     let mut sum = 0.0;\n-    for v.eachi |i, &v_i| {\n+    for v.iter().enumerate().advance |(i, &v_i)| {\n         sum += v_i * u[i];\n     }\n     sum"}, {"sha": "e5cf15367719a065809ce4a6f4eff48e1eca1ffa", "filename": "src/test/run-pass/deriving-cmp-generic-enum.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-enum.rs?ref=49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "patch": "@@ -25,8 +25,8 @@ pub fn main() {\n     // in order for both Ord and TotalOrd\n     let es = [e0, e11, e12, e21, e22];\n \n-    for es.eachi |i, e1| {\n-        for es.eachi |j, e2| {\n+    for es.iter().enumerate().advance |(i, e1)| {\n+        for es.iter().enumerate().advance |(j, e2)| {\n             let ord = i.cmp(&j);\n \n             let eq = i == j;"}, {"sha": "426bfd7eb2f191a02fb64f8bcf195625d321167e", "filename": "src/test/run-pass/deriving-cmp-generic-struct.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-struct.rs?ref=49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "patch": "@@ -21,8 +21,8 @@ pub fn main() {\n     // in order for both Ord and TotalOrd\n     let ss = [s1, s2];\n \n-    for ss.eachi |i, s1| {\n-        for ss.eachi |j, s2| {\n+    for ss.iter().enumerate().advance |(i, s1)| {\n+        for ss.iter().enumerate().advance |(j, s2)| {\n             let ord = i.cmp(&j);\n \n             let eq = i == j;"}, {"sha": "0acebdf05f4e38851ae03e642bc55870c623e78a", "filename": "src/test/run-pass/deriving-cmp-generic-tuple-struct.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-tuple-struct.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-tuple-struct.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fderiving-cmp-generic-tuple-struct.rs?ref=49c74524e2c5a2a81ce4cbe2c50a507c0be9f24e", "patch": "@@ -19,8 +19,8 @@ pub fn main() {\n     // in order for both Ord and TotalOrd\n     let tss = [ts1, ts2];\n \n-    for tss.eachi |i, ts1| {\n-        for tss.eachi |j, ts2| {\n+    for tss.iter().enumerate().advance |(i, ts1)| {\n+        for tss.iter().enumerate().advance |(j, ts2)| {\n             let ord = i.cmp(&j);\n \n             let eq = i == j;"}, {"sha": "d7508bca41e1fa6b7506f40d7dcff99f991ee151", "filename": "src/test/run-pass/issue-2611.rs", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/cbad1da3db7eda0911e988fb6255ac5c16961aa7/src%2Ftest%2Frun-pass%2Fissue-2611.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbad1da3db7eda0911e988fb6255ac5c16961aa7/src%2Ftest%2Frun-pass%2Fissue-2611.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-2611.rs?ref=cbad1da3db7eda0911e988fb6255ac5c16961aa7", "patch": "@@ -1,24 +0,0 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-use std::old_iter::BaseIter;\n-use std::old_iter;\n-\n-trait FlatMapToVec<A> {\n-  fn flat_map_to_vec<B, IB:BaseIter<B>>(&self, op: &fn(&A) -> IB) -> ~[B];\n-}\n-\n-impl<A:Copy> FlatMapToVec<A> for ~[A] {\n-   fn flat_map_to_vec<B, IB:BaseIter<B>>(&self, op: &fn(&A) -> IB) -> ~[B] {\n-     old_iter::flat_map_to_vec(self, op)\n-   }\n-}\n-\n-pub fn main() {}"}, {"sha": "aaf232f2046549c7cf5a0d87f649fa0319d6c9ed", "filename": "src/test/run-pass/vec-position.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/cbad1da3db7eda0911e988fb6255ac5c16961aa7/src%2Ftest%2Frun-pass%2Fvec-position.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbad1da3db7eda0911e988fb6255ac5c16961aa7/src%2Ftest%2Frun-pass%2Fvec-position.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fvec-position.rs?ref=cbad1da3db7eda0911e988fb6255ac5c16961aa7", "patch": "@@ -1,16 +0,0 @@\n-// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-pub fn main() {\n-    let mut v = ~[1, 2, 3];\n-    assert!(v.position(|x| *x == 1) == Some(0));\n-    assert!(v.position(|x| *x == 3) == Some(2));\n-    assert!(v.position(|x| *x == 17) == None);\n-}"}]}