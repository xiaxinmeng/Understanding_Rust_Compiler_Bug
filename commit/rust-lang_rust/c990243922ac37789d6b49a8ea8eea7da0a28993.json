{"sha": "c990243922ac37789d6b49a8ea8eea7da0a28993", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM5OTAyNDM5MjJhYzM3Nzg5ZDZiNDlhOGVhOGVlYTdkYTBhMjg5OTM=", "commit": {"author": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2019-09-17T23:25:41Z"}, "committer": {"name": "Dylan MacKenzie", "email": "ecstaticmorse@gmail.com", "date": "2019-09-28T14:06:52Z"}, "message": "Run new validator in compare mode", "tree": {"sha": "4ad1ea0b941276142b00de87b67b8fcc72c80612", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4ad1ea0b941276142b00de87b67b8fcc72c80612"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c990243922ac37789d6b49a8ea8eea7da0a28993", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c990243922ac37789d6b49a8ea8eea7da0a28993", "html_url": "https://github.com/rust-lang/rust/commit/c990243922ac37789d6b49a8ea8eea7da0a28993", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c990243922ac37789d6b49a8ea8eea7da0a28993/comments", "author": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ecstatic-morse", "id": 29463364, "node_id": "MDQ6VXNlcjI5NDYzMzY0", "avatar_url": "https://avatars.githubusercontent.com/u/29463364?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ecstatic-morse", "html_url": "https://github.com/ecstatic-morse", "followers_url": "https://api.github.com/users/ecstatic-morse/followers", "following_url": "https://api.github.com/users/ecstatic-morse/following{/other_user}", "gists_url": "https://api.github.com/users/ecstatic-morse/gists{/gist_id}", "starred_url": "https://api.github.com/users/ecstatic-morse/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ecstatic-morse/subscriptions", "organizations_url": "https://api.github.com/users/ecstatic-morse/orgs", "repos_url": "https://api.github.com/users/ecstatic-morse/repos", "events_url": "https://api.github.com/users/ecstatic-morse/events{/privacy}", "received_events_url": "https://api.github.com/users/ecstatic-morse/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fc92d3b8202874c52328fbc3b7816f999586045a", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc92d3b8202874c52328fbc3b7816f999586045a", "html_url": "https://github.com/rust-lang/rust/commit/fc92d3b8202874c52328fbc3b7816f999586045a"}], "stats": {"total": 125, "additions": 97, "deletions": 28}, "files": [{"sha": "54cc63c929cc7bd38b589aea1bbfa07411215c31", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 97, "deletions": 28, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/c990243922ac37789d6b49a8ea8eea7da0a28993/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c990243922ac37789d6b49a8ea8eea7da0a28993/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=c990243922ac37789d6b49a8ea8eea7da0a28993", "patch": "@@ -34,6 +34,7 @@ use std::usize;\n use rustc::hir::HirId;\n use crate::transform::{MirPass, MirSource};\n use super::promote_consts::{self, Candidate, TempState};\n+use crate::transform::check_consts::validation::{ops, NonConstOp};\n \n /// What kind of item we are in.\n #[derive(Copy, Clone, Debug, PartialEq, Eq)]\n@@ -673,12 +674,14 @@ struct Checker<'a, 'tcx> {\n \n     temp_promotion_state: IndexVec<Local, TempState>,\n     promotion_candidates: Vec<Candidate>,\n+    errors: Vec<(Span, String)>,\n+    suppress_errors: bool,\n }\n \n macro_rules! unleash_miri {\n     ($this:expr) => {{\n         if $this.tcx.sess.opts.debugging_opts.unleash_the_miri_inside_of_you {\n-            if $this.mode.requires_const_checking() {\n+            if $this.mode.requires_const_checking() && !$this.suppress_errors {\n                 $this.tcx.sess.span_warn($this.span, \"skipping const checks\");\n             }\n             return;\n@@ -736,16 +739,19 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n             def_id,\n             rpo,\n             temp_promotion_state: temps,\n-            promotion_candidates: vec![]\n+            promotion_candidates: vec![],\n+            errors: vec![],\n+            suppress_errors: false,\n         }\n     }\n \n     // FIXME(eddyb) we could split the errors into meaningful\n     // categories, but enabling full miri would make that\n     // slightly pointless (even with feature-gating).\n-    fn not_const(&mut self) {\n+    fn not_const(&mut self, op: impl NonConstOp + fmt::Debug) {\n         unleash_miri!(self);\n-        if self.mode.requires_const_checking() {\n+        if self.mode.requires_const_checking() && !self.suppress_errors {\n+            self.record_error(op);\n             let mut err = struct_span_err!(\n                 self.tcx.sess,\n                 self.span,\n@@ -763,6 +769,14 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n         }\n     }\n \n+    fn record_error(&mut self, op: impl NonConstOp + fmt::Debug) {\n+        self.record_error_spanned(op, self.span);\n+    }\n+\n+    fn record_error_spanned(&mut self, op: impl NonConstOp + fmt::Debug, span: Span) {\n+        self.errors.push((span, format!(\"{:?}\", op)));\n+    }\n+\n     /// Assigns an rvalue/call qualification to the given destination.\n     fn assign(&mut self, dest: &Place<'tcx>, source: ValueSource<'_, 'tcx>, location: Location) {\n         trace!(\"assign: {:?} <- {:?}\", dest, source);\n@@ -781,8 +795,10 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n                     qualifs[HasMutInterior] = false;\n                     qualifs[IsNotPromotable] = true;\n \n-                    if self.mode.requires_const_checking() {\n+                    debug!(\"suppress_errors: {}\", self.suppress_errors);\n+                    if self.mode.requires_const_checking() && !self.suppress_errors {\n                         if !self.tcx.sess.opts.debugging_opts.unleash_the_miri_inside_of_you {\n+                            self.record_error(ops::MutBorrow(kind));\n                             if let BorrowKind::Mut { .. } = kind {\n                                 let mut err = struct_span_err!(self.tcx.sess,  self.span, E0017,\n                                                                \"references in {}s may only refer \\\n@@ -927,8 +943,23 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n \n     /// Check a whole const, static initializer or const fn.\n     fn check_const(&mut self) -> (u8, &'tcx BitSet<Local>) {\n+        use crate::transform::check_consts as new_checker;\n+\n         debug!(\"const-checking {} {:?}\", self.mode, self.def_id);\n \n+        // FIXME: Also use the new validator when features that require it (e.g. `const_if`) are\n+        // enabled.\n+        let use_new_validator = self.tcx.sess.opts.debugging_opts.unleash_the_miri_inside_of_you;\n+        if use_new_validator {\n+            debug!(\"Using dataflow-based const validator\");\n+        }\n+\n+        let item = new_checker::Item::new(self.tcx, self.def_id, self.body);\n+        let mut validator = new_checker::validation::Validator::new(&item);\n+\n+        validator.suppress_errors = !use_new_validator;\n+        self.suppress_errors = use_new_validator;\n+\n         let body = self.body;\n \n         let mut seen_blocks = BitSet::new_empty(body.basic_blocks().len());\n@@ -937,6 +968,7 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n             seen_blocks.insert(bb.index());\n \n             self.visit_basic_block_data(bb, &body[bb]);\n+            validator.visit_basic_block_data(bb, &body[bb]);\n \n             let target = match body[bb].terminator().kind {\n                 TerminatorKind::Goto { target } |\n@@ -972,12 +1004,27 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n                     bb = target;\n                 }\n                 _ => {\n-                    self.not_const();\n+                    self.not_const(ops::Loop);\n+                    validator.check_op(ops::Loop);\n                     break;\n                 }\n             }\n         }\n \n+        // The new validation pass should agree with the old when running on simple const bodies\n+        // (e.g. no `if` or `loop`).\n+        if !use_new_validator {\n+            let mut new_errors = validator.take_errors();\n+\n+            // FIXME: each checker sometimes emits the same error with the same span twice in a row.\n+            self.errors.dedup();\n+            new_errors.dedup();\n+            if self.errors != new_errors {\n+                error!(\"old validator: {:?}\", self.errors);\n+                error!(\"new validator: {:?}\", new_errors);\n+                panic!(\"disagreement between validators:\");\n+            }\n+        }\n \n         // Collect all the temps we need to promote.\n         let mut promoted_temps = BitSet::new_empty(self.temp_promotion_state.len());\n@@ -1043,7 +1090,8 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                         .get_attrs(*def_id)\n                         .iter()\n                         .any(|attr| attr.check_name(sym::thread_local)) {\n-                    if self.mode.requires_const_checking() {\n+                    if self.mode.requires_const_checking() && !self.suppress_errors {\n+                        self.record_error(ops::ThreadLocalAccess);\n                         span_err!(self.tcx.sess, self.span, E0625,\n                                     \"thread-local statics cannot be \\\n                                     accessed at compile-time\");\n@@ -1053,7 +1101,10 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n \n                 // Only allow statics (not consts) to refer to other statics.\n                 if self.mode == Mode::Static || self.mode == Mode::StaticMut {\n-                    if self.mode == Mode::Static && context.is_mutating_use() {\n+                    if self.mode == Mode::Static\n+                        && context.is_mutating_use()\n+                        && !self.suppress_errors\n+                    {\n                         // this is not strictly necessary as miri will also bail out\n                         // For interior mutability we can't really catch this statically as that\n                         // goes through raw pointers and intermediate temporaries, so miri has\n@@ -1067,7 +1118,8 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                 }\n                 unleash_miri!(self);\n \n-                if self.mode.requires_const_checking() {\n+                if self.mode.requires_const_checking() && !self.suppress_errors {\n+                    self.record_error(ops::StaticAccess);\n                     let mut err = struct_span_err!(self.tcx.sess, self.span, E0013,\n                                                     \"{}s cannot refer to statics, use \\\n                                                     a constant instead\", self.mode);\n@@ -1104,14 +1156,16 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                 ProjectionElem::Deref => {\n                     if context.is_mutating_use() {\n                         // `not_const` errors out in const contexts\n-                        self.not_const()\n+                        self.not_const(ops::MutDeref)\n                     }\n                     let base_ty = Place::ty_from(place_base, proj_base, self.body, self.tcx).ty;\n                     match self.mode {\n-                        Mode::NonConstFn => {},\n+                        Mode::NonConstFn => {}\n+                        _ if self.suppress_errors => {}\n                         _ => {\n                             if let ty::RawPtr(_) = base_ty.kind {\n                                 if !self.tcx.features().const_raw_ptr_deref {\n+                                    self.record_error(ops::RawPtrDeref);\n                                     emit_feature_err(\n                                         &self.tcx.sess.parse_sess, sym::const_raw_ptr_deref,\n                                         self.span, GateIssue::Language,\n@@ -1135,7 +1189,10 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                         if def.is_union() {\n                             match self.mode {\n                                 Mode::ConstFn => {\n-                                    if !self.tcx.features().const_fn_union {\n+                                    if !self.tcx.features().const_fn_union\n+                                        && !self.suppress_errors\n+                                    {\n+                                        self.record_error(ops::UnionAccess);\n                                         emit_feature_err(\n                                             &self.tcx.sess.parse_sess, sym::const_fn_union,\n                                             self.span, GateIssue::Language,\n@@ -1155,7 +1212,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                 }\n \n                 ProjectionElem::Downcast(..) => {\n-                    self.not_const()\n+                    self.not_const(ops::Downcast)\n                 }\n             }\n         }\n@@ -1241,9 +1298,12 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                     (CastTy::Ptr(_), CastTy::Int(_)) |\n                     (CastTy::FnPtr, CastTy::Int(_)) if self.mode != Mode::NonConstFn => {\n                         unleash_miri!(self);\n-                        if !self.tcx.features().const_raw_ptr_to_usize_cast {\n+                        if !self.tcx.features().const_raw_ptr_to_usize_cast\n+                            && !self.suppress_errors\n+                        {\n                             // in const fn and constants require the feature gate\n                             // FIXME: make it unsafe inside const fn and constants\n+                            self.record_error(ops::RawPtrToIntCast);\n                             emit_feature_err(\n                                 &self.tcx.sess.parse_sess, sym::const_raw_ptr_to_usize_cast,\n                                 self.span, GateIssue::Language,\n@@ -1267,8 +1327,10 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n \n                     unleash_miri!(self);\n                     if self.mode.requires_const_checking() &&\n-                        !self.tcx.features().const_compare_raw_pointers\n+                        !self.tcx.features().const_compare_raw_pointers &&\n+                        !self.suppress_errors\n                     {\n+                        self.record_error(ops::RawPtrComparison);\n                         // require the feature gate inside constants and const fn\n                         // FIXME: make it unsafe to use these operations\n                         emit_feature_err(\n@@ -1284,7 +1346,8 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n \n             Rvalue::NullaryOp(NullOp::Box, _) => {\n                 unleash_miri!(self);\n-                if self.mode.requires_const_checking() {\n+                if self.mode.requires_const_checking() && !self.suppress_errors {\n+                    self.record_error(ops::HeapAllocation);\n                     let mut err = struct_span_err!(self.tcx.sess, self.span, E0010,\n                                                    \"allocations are not allowed in {}s\", self.mode);\n                     err.span_label(self.span, format!(\"allocation not allowed in {}s\", self.mode));\n@@ -1329,9 +1392,12 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                                 // special intrinsic that can be called diretly without an intrinsic\n                                 // feature gate needs a language feature gate\n                                 \"transmute\" => {\n-                                    if self.mode.requires_const_checking() {\n+                                    if self.mode.requires_const_checking()\n+                                        && !self.suppress_errors\n+                                    {\n                                         // const eval transmute calls only with the feature gate\n                                         if !self.tcx.features().const_transmute {\n+                                            self.record_error(ops::Transmute);\n                                             emit_feature_err(\n                                                 &self.tcx.sess.parse_sess, sym::const_transmute,\n                                                 self.span, GateIssue::Language,\n@@ -1359,7 +1425,10 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                                     .opts\n                                     .debugging_opts\n                                     .unleash_the_miri_inside_of_you;\n-                                if self.tcx.is_const_fn(def_id) || unleash_miri {\n+                                if self.tcx.is_const_fn(def_id)\n+                                    || unleash_miri\n+                                    || self.suppress_errors\n+                                {\n                                     // stable const fns or unstable const fns\n                                     // with their feature gate active\n                                     // FIXME(eddyb) move stability checks from `is_const_fn` here.\n@@ -1370,6 +1439,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                                     // since the macro is marked with the attribute.\n                                     if !self.tcx.features().const_panic {\n                                         // Don't allow panics in constants without the feature gate.\n+                                        self.record_error(ops::Panic);\n                                         emit_feature_err(\n                                             &self.tcx.sess.parse_sess,\n                                             sym::const_panic,\n@@ -1384,6 +1454,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                                     // functions without the feature gate active in this crate in\n                                     // order to report a better error message than the one below.\n                                     if !self.span.allows_unstable(feature) {\n+                                        self.record_error(ops::FnCallUnstable(def_id, feature));\n                                         let mut err = self.tcx.sess.struct_span_err(self.span,\n                                             &format!(\"`{}` is not yet stable as a const fn\",\n                                                     self.tcx.def_path_str(def_id)));\n@@ -1396,6 +1467,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                                         err.emit();\n                                     }\n                                 } else {\n+                                    self.record_error(ops::FnCallNonConst(def_id));\n                                     let mut err = struct_span_err!(\n                                         self.tcx.sess,\n                                         self.span,\n@@ -1411,13 +1483,9 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                     }\n                 }\n                 ty::FnPtr(_) => {\n-                    let unleash_miri = self\n-                        .tcx\n-                        .sess\n-                        .opts\n-                        .debugging_opts\n-                        .unleash_the_miri_inside_of_you;\n-                    if self.mode.requires_const_checking() && !unleash_miri {\n+                    unleash_miri!(self);\n+                    if self.mode.requires_const_checking() && !self.suppress_errors {\n+                        self.record_error(ops::FnCallIndirect);\n                         let mut err = self.tcx.sess.struct_span_err(\n                             self.span,\n                             \"function pointers are not allowed in const fn\"\n@@ -1426,7 +1494,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                     }\n                 }\n                 _ => {\n-                    self.not_const();\n+                    self.not_const(ops::FnCallOther);\n                 }\n             }\n \n@@ -1484,7 +1552,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n             }\n \n             // Deny *any* live drops anywhere other than functions.\n-            if self.mode.requires_const_checking() {\n+            if self.mode.requires_const_checking() && !self.suppress_errors {\n                 unleash_miri!(self);\n                 // HACK(eddyb): emulate a bit of dataflow analysis,\n                 // conservatively, that drop elaboration will do.\n@@ -1505,6 +1573,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                     // Double-check the type being dropped, to minimize false positives.\n                     let ty = place.ty(self.body, self.tcx).ty;\n                     if ty.needs_drop(self.tcx, self.param_env) {\n+                        self.record_error_spanned(ops::LiveDrop, span);\n                         struct_span_err!(self.tcx.sess, span, E0493,\n                                          \"destructors cannot be evaluated at compile-time\")\n                             .span_label(span, format!(\"{}s cannot evaluate destructors\",\n@@ -1549,7 +1618,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                 self.super_statement(statement, location);\n             }\n             StatementKind::FakeRead(FakeReadCause::ForMatchedPlace, _) => {\n-                self.not_const();\n+                self.not_const(ops::IfOrMatch);\n             }\n             // FIXME(eddyb) should these really do nothing?\n             StatementKind::FakeRead(..) |"}]}