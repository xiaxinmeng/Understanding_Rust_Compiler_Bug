{"sha": "64eb9ab869bc3f9ef3645302fbf22e706eea16cf", "node_id": "C_kwDOAAsO6NoAKDY0ZWI5YWI4NjliYzNmOWVmMzY0NTMwMmZiZjIyZTcwNmVlYTE2Y2Y", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-28T06:25:19Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-06-28T06:25:19Z"}, "message": "Auto merge of #98324 - conradludgate:write-vectored-vec, r=Mark-Simulacrum\n\nattempt to optimise vectored write\n\nbenchmarked:\n\nold:\n```\ntest io::cursor::tests::bench_write_vec                     ... bench:          68 ns/iter (+/- 2)\ntest io::cursor::tests::bench_write_vec_vectored            ... bench:         913 ns/iter (+/- 31)\n```\n\nnew:\n```\ntest io::cursor::tests::bench_write_vec                     ... bench:          64 ns/iter (+/- 0)\ntest io::cursor::tests::bench_write_vec_vectored            ... bench:         747 ns/iter (+/- 27)\n```\n\nMore unsafe than I wanted (and less gains) in the end, but it still does the job", "tree": {"sha": "bd112207f145742a05f838f527681ce1faf7b168", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/bd112207f145742a05f838f527681ce1faf7b168"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/64eb9ab869bc3f9ef3645302fbf22e706eea16cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/64eb9ab869bc3f9ef3645302fbf22e706eea16cf", "html_url": "https://github.com/rust-lang/rust/commit/64eb9ab869bc3f9ef3645302fbf22e706eea16cf", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/64eb9ab869bc3f9ef3645302fbf22e706eea16cf/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5ffa8f67b75be56cf829bfc9d055082c8382c0cf", "url": "https://api.github.com/repos/rust-lang/rust/commits/5ffa8f67b75be56cf829bfc9d055082c8382c0cf", "html_url": "https://github.com/rust-lang/rust/commit/5ffa8f67b75be56cf829bfc9d055082c8382c0cf"}, {"sha": "803083a9d9142aa841be710d3aa03c9c6dff543d", "url": "https://api.github.com/repos/rust-lang/rust/commits/803083a9d9142aa841be710d3aa03c9c6dff543d", "html_url": "https://github.com/rust-lang/rust/commit/803083a9d9142aa841be710d3aa03c9c6dff543d"}], "stats": {"total": 174, "additions": 149, "deletions": 25}, "files": [{"sha": "f3fbfc44789519b8db15901cb8fdd1fd11d17bf2", "filename": "library/std/src/io/cursor.rs", "status": "modified", "additions": 101, "deletions": 25, "changes": 126, "blob_url": "https://github.com/rust-lang/rust/blob/64eb9ab869bc3f9ef3645302fbf22e706eea16cf/library%2Fstd%2Fsrc%2Fio%2Fcursor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64eb9ab869bc3f9ef3645302fbf22e706eea16cf/library%2Fstd%2Fsrc%2Fio%2Fcursor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fcursor.rs?ref=64eb9ab869bc3f9ef3645302fbf22e706eea16cf", "patch": "@@ -396,38 +396,99 @@ fn slice_write_vectored(\n     Ok(nwritten)\n }\n \n-// Resizing write implementation\n-fn vec_write<A>(pos_mut: &mut u64, vec: &mut Vec<u8, A>, buf: &[u8]) -> io::Result<usize>\n-where\n-    A: Allocator,\n-{\n+/// Reserves the required space, and pads the vec with 0s if necessary.\n+fn reserve_and_pad<A: Allocator>(\n+    pos_mut: &mut u64,\n+    vec: &mut Vec<u8, A>,\n+    buf_len: usize,\n+) -> io::Result<usize> {\n     let pos: usize = (*pos_mut).try_into().map_err(|_| {\n         io::const_io_error!(\n             ErrorKind::InvalidInput,\n             \"cursor position exceeds maximum possible vector length\",\n         )\n     })?;\n-    // Make sure the internal buffer is as least as big as where we\n-    // currently are\n-    let len = vec.len();\n-    if len < pos {\n-        // use `resize` so that the zero filling is as efficient as possible\n-        vec.resize(pos, 0);\n-    }\n-    // Figure out what bytes will be used to overwrite what's currently\n-    // there (left), and what will be appended on the end (right)\n-    {\n-        let space = vec.len() - pos;\n-        let (left, right) = buf.split_at(cmp::min(space, buf.len()));\n-        vec[pos..pos + left.len()].copy_from_slice(left);\n-        vec.extend_from_slice(right);\n+\n+    // For safety reasons, we don't want these numbers to overflow\n+    // otherwise our allocation won't be enough\n+    let desired_cap = pos.saturating_add(buf_len);\n+    if desired_cap > vec.capacity() {\n+        // We want our vec's total capacity\n+        // to have room for (pos+buf_len) bytes. Reserve allocates\n+        // based on additional elements from the length, so we need to\n+        // reserve the difference\n+        vec.reserve(desired_cap - vec.len());\n+    }\n+    // Pad if pos is above the current len.\n+    if pos > vec.len() {\n+        let diff = pos - vec.len();\n+        // Unfortunately, `resize()` would suffice but the optimiser does not\n+        // realise the `reserve` it does can be eliminated. So we do it manually\n+        // to eliminate that extra branch\n+        let spare = vec.spare_capacity_mut();\n+        debug_assert!(spare.len() >= diff);\n+        // Safety: we have allocated enough capacity for this.\n+        // And we are only writing, not reading\n+        unsafe {\n+            spare.get_unchecked_mut(..diff).fill(core::mem::MaybeUninit::new(0));\n+            vec.set_len(pos);\n+        }\n     }\n \n+    Ok(pos)\n+}\n+\n+/// Writes the slice to the vec without allocating\n+/// # Safety: vec must have buf.len() spare capacity\n+unsafe fn vec_write_unchecked<A>(pos: usize, vec: &mut Vec<u8, A>, buf: &[u8]) -> usize\n+where\n+    A: Allocator,\n+{\n+    debug_assert!(vec.capacity() >= pos + buf.len());\n+    vec.as_mut_ptr().add(pos).copy_from(buf.as_ptr(), buf.len());\n+    pos + buf.len()\n+}\n+\n+/// Resizing write implementation for [`Cursor`]\n+///\n+/// Cursor is allowed to have a pre-allocated and initialised\n+/// vector body, but with a position of 0. This means the [`Write`]\n+/// will overwrite the contents of the vec.\n+///\n+/// This also allows for the vec body to be empty, but with a position of N.\n+/// This means that [`Write`] will pad the vec with 0 initially,\n+/// before writing anything from that point\n+fn vec_write<A>(pos_mut: &mut u64, vec: &mut Vec<u8, A>, buf: &[u8]) -> io::Result<usize>\n+where\n+    A: Allocator,\n+{\n+    let buf_len = buf.len();\n+    let mut pos = reserve_and_pad(pos_mut, vec, buf_len)?;\n+\n+    // Write the buf then progress the vec forward if necessary\n+    // Safety: we have ensured that the capacity is available\n+    // and that all bytes get written up to pos\n+    unsafe {\n+        pos = vec_write_unchecked(pos, vec, buf);\n+        if pos > vec.len() {\n+            vec.set_len(pos);\n+        }\n+    };\n+\n     // Bump us forward\n-    *pos_mut = (pos + buf.len()) as u64;\n-    Ok(buf.len())\n+    *pos_mut += buf_len as u64;\n+    Ok(buf_len)\n }\n \n+/// Resizing write_vectored implementation for [`Cursor`]\n+///\n+/// Cursor is allowed to have a pre-allocated and initialised\n+/// vector body, but with a position of 0. This means the [`Write`]\n+/// will overwrite the contents of the vec.\n+///\n+/// This also allows for the vec body to be empty, but with a position of N.\n+/// This means that [`Write`] will pad the vec with 0 initially,\n+/// before writing anything from that point\n fn vec_write_vectored<A>(\n     pos_mut: &mut u64,\n     vec: &mut Vec<u8, A>,\n@@ -436,11 +497,26 @@ fn vec_write_vectored<A>(\n where\n     A: Allocator,\n {\n-    let mut nwritten = 0;\n-    for buf in bufs {\n-        nwritten += vec_write(pos_mut, vec, buf)?;\n+    // For safety reasons, we don't want this sum to overflow ever.\n+    // If this saturates, the reserve should panic to avoid any unsound writing.\n+    let buf_len = bufs.iter().fold(0usize, |a, b| a.saturating_add(b.len()));\n+    let mut pos = reserve_and_pad(pos_mut, vec, buf_len)?;\n+\n+    // Write the buf then progress the vec forward if necessary\n+    // Safety: we have ensured that the capacity is available\n+    // and that all bytes get written up to the last pos\n+    unsafe {\n+        for buf in bufs {\n+            pos = vec_write_unchecked(pos, vec, buf);\n+        }\n+        if pos > vec.len() {\n+            vec.set_len(pos);\n+        }\n     }\n-    Ok(nwritten)\n+\n+    // Bump us forward\n+    *pos_mut += buf_len as u64;\n+    Ok(buf_len)\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "d7c203c297fe6dc4f62fd3302ac9259e5721f694", "filename": "library/std/src/io/cursor/tests.rs", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/64eb9ab869bc3f9ef3645302fbf22e706eea16cf/library%2Fstd%2Fsrc%2Fio%2Fcursor%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/64eb9ab869bc3f9ef3645302fbf22e706eea16cf/library%2Fstd%2Fsrc%2Fio%2Fcursor%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Fcursor%2Ftests.rs?ref=64eb9ab869bc3f9ef3645302fbf22e706eea16cf", "patch": "@@ -20,6 +20,7 @@ fn test_vec_writer() {\n #[test]\n fn test_mem_writer() {\n     let mut writer = Cursor::new(Vec::new());\n+    writer.set_position(10);\n     assert_eq!(writer.write(&[0]).unwrap(), 1);\n     assert_eq!(writer.write(&[1, 2, 3]).unwrap(), 3);\n     assert_eq!(writer.write(&[4, 5, 6, 7]).unwrap(), 4);\n@@ -30,6 +31,17 @@ fn test_mem_writer() {\n         3\n     );\n     let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n+    assert_eq!(&writer.get_ref()[..10], &[0; 10]);\n+    assert_eq!(&writer.get_ref()[10..], b);\n+}\n+\n+#[test]\n+fn test_mem_writer_preallocated() {\n+    let mut writer = Cursor::new(vec![0, 0, 0, 0, 0, 0, 0, 0, 8, 9, 10]);\n+    assert_eq!(writer.write(&[0]).unwrap(), 1);\n+    assert_eq!(writer.write(&[1, 2, 3]).unwrap(), 3);\n+    assert_eq!(writer.write(&[4, 5, 6, 7]).unwrap(), 4);\n+    let b: &[_] = &[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];\n     assert_eq!(&writer.get_ref()[..], b);\n }\n \n@@ -517,3 +529,39 @@ fn const_cursor() {\n     const _: &&[u8] = CURSOR.get_ref();\n     const _: u64 = CURSOR.position();\n }\n+\n+#[bench]\n+fn bench_write_vec(b: &mut test::Bencher) {\n+    let slice = &[1; 128];\n+\n+    b.iter(|| {\n+        let mut buf = b\"some random data to overwrite\".to_vec();\n+        let mut cursor = Cursor::new(&mut buf);\n+\n+        let _ = cursor.write_all(slice);\n+        test::black_box(&cursor);\n+    })\n+}\n+\n+#[bench]\n+fn bench_write_vec_vectored(b: &mut test::Bencher) {\n+    let slices = [\n+        IoSlice::new(&[1; 128]),\n+        IoSlice::new(&[2; 256]),\n+        IoSlice::new(&[3; 512]),\n+        IoSlice::new(&[4; 1024]),\n+        IoSlice::new(&[5; 2048]),\n+        IoSlice::new(&[6; 4096]),\n+        IoSlice::new(&[7; 8192]),\n+        IoSlice::new(&[8; 8192 * 2]),\n+    ];\n+\n+    b.iter(|| {\n+        let mut buf = b\"some random data to overwrite\".to_vec();\n+        let mut cursor = Cursor::new(&mut buf);\n+\n+        let mut slices = slices;\n+        let _ = cursor.write_all_vectored(&mut slices);\n+        test::black_box(&cursor);\n+    })\n+}"}]}