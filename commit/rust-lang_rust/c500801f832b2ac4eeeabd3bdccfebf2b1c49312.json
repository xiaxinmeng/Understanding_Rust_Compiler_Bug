{"sha": "c500801f832b2ac4eeeabd3bdccfebf2b1c49312", "node_id": "MDY6Q29tbWl0NzI0NzEyOmM1MDA4MDFmODMyYjJhYzRlZWVhYmQzYmRjY2ZlYmYyYjFjNDkzMTI=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-01-20T00:59:25Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-01-20T00:59:25Z"}, "message": "Fix typos in section 6; point out that prove expressions are unsupported", "tree": {"sha": "7d16a0224fc8bc0ee06d947646e54e525510ca77", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7d16a0224fc8bc0ee06d947646e54e525510ca77"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c500801f832b2ac4eeeabd3bdccfebf2b1c49312", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c500801f832b2ac4eeeabd3bdccfebf2b1c49312", "html_url": "https://github.com/rust-lang/rust/commit/c500801f832b2ac4eeeabd3bdccfebf2b1c49312", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c500801f832b2ac4eeeabd3bdccfebf2b1c49312/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "704210ef7c691a797a11cc4be20fb72ccc69108c", "url": "https://api.github.com/repos/rust-lang/rust/commits/704210ef7c691a797a11cc4be20fb72ccc69108c", "html_url": "https://github.com/rust-lang/rust/commit/704210ef7c691a797a11cc4be20fb72ccc69108c"}], "stats": {"total": 42, "additions": 22, "deletions": 20}, "files": [{"sha": "7279be7ac4f2b528659de6b6d1bc41da4d5a13e3", "filename": "doc/rust.md", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/c500801f832b2ac4eeeabd3bdccfebf2b1c49312/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/c500801f832b2ac4eeeabd3bdccfebf2b1c49312/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=c500801f832b2ac4eeeabd3bdccfebf2b1c49312", "patch": "@@ -1293,7 +1293,7 @@ A declaration serves to introduce a *name* that can be used in the block\n name, from the previous opening curly-brace (`{`) up to the next closing\n curly-brace (`}`).\n \n-An expression serves the dual roles of causing side effects and producing a\n+An expression plays the dual roles of causing side effects and producing a\n *value*. Expressions are said to *evaluate to* a value, and the side effects\n are caused during *evaluation*. Many expressions contain sub-expressions as\n operands; the definition of each kind of expression dictates whether or not,\n@@ -1345,7 +1345,7 @@ The former form, with no type annotation, causes the compiler to infer the\n static type of the slot through unification with the types of values assigned\n to the slot in the remaining code in the block scope. Inference only occurs on\n frame-local slots, not argument slots. Function signatures must\n-always declared types for all argument slots.\n+always declare types for all argument slots.\n \n \n ### Expression statements\n@@ -1372,8 +1372,8 @@ string, boolean value, or the nil value.\n ### Tuple expressions\n \n Tuples are written by enclosing two or more comma-separated\n-expressions in parentheses. They are used to create [tuple\n-typed](#tuple-types) values.\n+expressions in parentheses. They are used to create [tuple-typed](#tuple-types)\n+values.\n \n ~~~~~~~~ {.tuple}\n (0f, 4.5f);\n@@ -1398,9 +1398,9 @@ The order of the fields in a record expression is significant, and\n determines the type of the resulting value. `{a: u8, b: u8}` and `{b:\n u8, a: u8}` are two different fields.\n \n-A record expression can be ended with the word `with` followed by an\n+A record expression can terminate with the word `with` followed by an\n expression to denote a functional update. The expression following\n-`with` (the base) be of a record type that includes at least all the\n+`with` (the base) must be of a record type that includes at least all the\n fields mentioned in the record expression. A new record will be\n created, of the same type as the base expression, with the given\n values for the fields that were explicitly specified, and the values\n@@ -1469,7 +1469,7 @@ task in a _failing state_.\n \n ### Unary operator expressions\n \n-Rust defines five unary operators. They are all written a prefix\n+Rust defines five unary operators. They are all written as prefix\n operators, before the expression they apply to.\n \n `-`\n@@ -1536,7 +1536,7 @@ type. The first performs the 'or' operation, and the second the 'and'\n operation. They differ from `|` and `&` in that the right-hand operand\n is only evaluated when the left-hand operand does not already\n determine the outcome of the expression. That is, `||` only evaluates\n-it right-hand operand when the left-hand operand evaluates to `false`,\n+its right-hand operand when the left-hand operand evaluates to `false`,\n and `&&` only when it evaluates to `true`.\n \n #### Comparison operators\n@@ -1588,15 +1588,15 @@ types.\n \n #### Binary move expressions\n \n-A _binary move experssion_ consists of an *lval* followed by a left-pointing\n+A _binary move expression_ consists of an *lval* followed by a left-pointing\n arrow (`<-`) and an *rval* expression.\n \n Evaluating a move expression causes, as a side effect, the *rval* to be\n *moved* into the *lval*. If the *rval* was itself an *lval*, it must be a\n local variable, as it will be de-initialized in the process.\n \n-Evaluating a move expression does not effect reference counts nor does it\n-cause a deep copy of any unique structure pointed-to by the moved\n+Evaluating a move expression does not change reference counts, nor does it\n+cause a deep copy of any unique structure pointed to by the moved\n *rval*. Instead, the move expression represents an indivisible *transfer of\n ownership* from the right-hand-side to the left-hand-side of the\n expression. No allocation or destruction is entailed.\n@@ -1611,14 +1611,14 @@ x.y <- c;\n \n #### Swap expressions\n \n-A _swap experssion_ consists of an *lval* followed by a bi-directional arrow\n+A _swap expression_ consists of an *lval* followed by a bi-directional arrow\n (`<->`) and another *lval* expression.\n \n Evaluating a swap expression causes, as a side effect, the vales held in the\n left-hand-side and right-hand-side *lvals* to be exchanged indivisibly.\n \n-Evaluating a move expression does not effect reference counts nor does it\n-cause a deep copy of any unique structure pointed-to by the moved\n+Evaluating a move expression does not change reference counts, nor does it\n+cause a deep copy of any unique structure pointed to by the moved\n *rval*. Instead, the move expression represents an indivisible *exchange of\n ownership* between the right-hand-side to the left-hand-side of the\n expression. No allocation or destruction is entailed.\n@@ -1635,7 +1635,7 @@ x.y <-> a.b;\n #### Assignment expressions\n \n An _assignment expression_ consists of an *lval* expression followed by an\n-equals-sign (`=`) and an *rval* expression.\n+equals sign (`=`) and an *rval* expression.\n \n Evaluating an assignment expression is equivalent to evaluating a [binary move\n expression](#binary-move-expressions) applied to a [unary copy\n@@ -1680,16 +1680,16 @@ A _unary copy expression_ consists of the unary `copy` operator applied to\n some argument expression.\n \n Evaluating a copy expression first evaluates the argument expression, then\n-performs a copy of the resulting value, allocating any memory necessary to\n-hold the new copy.\n+copies the resulting value, allocating any memory necessary to hold the new\n+copy.\n \n [Shared boxes](#shared-box-types) (type `@`) are, as usual, shallow-copied, as\n they may be cyclic. [Unique boxes](unique-box-types), [vectors](#vector-types)\n and similar unique types are deep-copied.\n \n Since the binary [assignment operator](#assignment-operator) `=` performs a\n copy implicitly, the unary copy operator is typically only used to cause an\n-argument to a function should be copied, and the copy passed by-value.\n+argument to a function to be copied and passed by value.\n \n An example of a copy expression:\n \n@@ -1709,7 +1709,7 @@ assert v[0] == 1; // Original was not modified\n \n This is used to indicate that the referenced _lval_ must be moved out,\n rather than copied, when evaluating this expression. It will only have\n-effect when the expression is _stored_ somewhere or passed to a\n+an effect when the expression is _stored_ somewhere or passed to a\n function that takes ownership of it.\n \n ~~~~\n@@ -1777,7 +1777,7 @@ assert (add(4,5) == add5(4));\n \n ~~~~\n \n-A `bind` expression generally stores a copy of the bound arguments in the\n+A `bind` expression generally stores a copy of the bound arguments in a\n hidden, boxed tuple, owned by the resulting first-class function. For each\n bound slot in the bound function's signature, space is allocated in the hidden\n tuple and populated with a copy of the bound value.\n@@ -2132,6 +2132,8 @@ fn test() {\n \n ### Prove expressions\n \n+**Note: Prove expressions are not yet supported by the compiler.**\n+\n A `prove` expression has no run-time effect. Its purpose is to statically\n check (and document) that its argument constraint holds at its expression\n entry point. If its argument typestate does not hold, under the typestate"}]}