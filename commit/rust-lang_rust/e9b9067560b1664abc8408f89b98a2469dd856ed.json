{"sha": "e9b9067560b1664abc8408f89b98a2469dd856ed", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU5YjkwNjc1NjBiMTY2NGFiYzg0MDhmODliOThhMjQ2OWRkODU2ZWQ=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-02-07T22:28:56Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-02-09T00:41:43Z"}, "message": "Make &mut borrows restrict aliasing\n\nFixes #11913", "tree": {"sha": "61d6dc2d0392ff6fb25145026c7264c7ce713ef7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/61d6dc2d0392ff6fb25145026c7264c7ce713ef7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e9b9067560b1664abc8408f89b98a2469dd856ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e9b9067560b1664abc8408f89b98a2469dd856ed", "html_url": "https://github.com/rust-lang/rust/commit/e9b9067560b1664abc8408f89b98a2469dd856ed", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e9b9067560b1664abc8408f89b98a2469dd856ed/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3df1eb2c2bad4e11406657204db9326663f61416", "url": "https://api.github.com/repos/rust-lang/rust/commits/3df1eb2c2bad4e11406657204db9326663f61416", "html_url": "https://github.com/rust-lang/rust/commit/3df1eb2c2bad4e11406657204db9326663f61416"}], "stats": {"total": 280, "additions": 159, "deletions": 121}, "files": [{"sha": "4abfedb87228eded779d68f6b3a66e14e8ae06bb", "filename": "src/librustc/metadata/encoder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e9b9067560b1664abc8408f89b98a2469dd856ed/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b9067560b1664abc8408f89b98a2469dd856ed/src%2Flibrustc%2Fmetadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmetadata%2Fencoder.rs?ref=e9b9067560b1664abc8408f89b98a2469dd856ed", "patch": "@@ -681,7 +681,7 @@ fn encode_explicit_self(ebml_w: &mut writer::Encoder, explicit_self: ast::Explic\n \n     ebml_w.end_tag();\n \n-    fn encode_mutability(ebml_w: &writer::Encoder,\n+    fn encode_mutability(ebml_w: &mut writer::Encoder,\n                          m: ast::Mutability) {\n         match m {\n             MutImmutable => { ebml_w.writer.write(&[ 'i' as u8 ]); }"}, {"sha": "cfd2c0719b09b4ef1799453a152484cc5cc80bbf", "filename": "src/librustc/middle/borrowck/check_loans.rs", "status": "modified", "additions": 15, "deletions": 41, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/e9b9067560b1664abc8408f89b98a2469dd856ed/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b9067560b1664abc8408f89b98a2469dd856ed/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fcheck_loans.rs?ref=e9b9067560b1664abc8408f89b98a2469dd856ed", "patch": "@@ -22,7 +22,6 @@ use mc = middle::mem_categorization;\n use middle::borrowck::*;\n use middle::moves;\n use middle::ty;\n-use syntax::ast::{MutImmutable, MutMutable};\n use syntax::ast;\n use syntax::ast_map;\n use syntax::ast_util;\n@@ -220,8 +219,8 @@ impl<'a> CheckLoanCtxt<'a> {\n \n         // Restrictions that would cause the new loan to be illegal:\n         let illegal_if = match loan2.mutbl {\n-            MutableMutability   => RESTR_ALIAS | RESTR_FREEZE | RESTR_CLAIM,\n-            ImmutableMutability => RESTR_ALIAS | RESTR_FREEZE,\n+            MutableMutability   => RESTR_FREEZE | RESTR_CLAIM,\n+            ImmutableMutability => RESTR_FREEZE,\n         };\n         debug!(\"illegal_if={:?}\", illegal_if);\n \n@@ -423,7 +422,7 @@ impl<'a> CheckLoanCtxt<'a> {\n             debug!(\"check_for_aliasable_mutable_writes(cmt={}, guarantor={})\",\n                    cmt.repr(this.tcx()), guarantor.repr(this.tcx()));\n             match guarantor.cat {\n-                mc::cat_deref(b, _, mc::region_ptr(MutMutable, _)) => {\n+                mc::cat_deref(b, _, mc::region_ptr(ast::MutMutable, _)) => {\n                     // Statically prohibit writes to `&mut` when aliasable\n \n                     check_for_aliasability_violation(this, expr, b);\n@@ -437,43 +436,18 @@ impl<'a> CheckLoanCtxt<'a> {\n \n         fn check_for_aliasability_violation(this: &CheckLoanCtxt,\n                                             expr: &ast::Expr,\n-                                            cmt: mc::cmt) -> bool {\n-            let mut cmt = cmt;\n-\n-            loop {\n-                match cmt.cat {\n-                    mc::cat_deref(b, _, mc::region_ptr(MutMutable, _)) |\n-                    mc::cat_downcast(b) |\n-                    mc::cat_stack_upvar(b) |\n-                    mc::cat_deref(b, _, mc::uniq_ptr) |\n-                    mc::cat_interior(b, _) |\n-                    mc::cat_discr(b, _) => {\n-                        // Aliasability depends on base cmt\n-                        cmt = b;\n-                    }\n-\n-                    mc::cat_copied_upvar(_) |\n-                    mc::cat_rvalue(..) |\n-                    mc::cat_local(..) |\n-                    mc::cat_arg(_) |\n-                    mc::cat_deref(_, _, mc::unsafe_ptr(..)) |\n-                    mc::cat_static_item(..) |\n-                    mc::cat_deref(_, _, mc::gc_ptr) |\n-                    mc::cat_deref(_, _, mc::region_ptr(MutImmutable, _)) => {\n-                        // Aliasability is independent of base cmt\n-                        match cmt.freely_aliasable() {\n-                            None => {\n-                                return true;\n-                            }\n-                            Some(cause) => {\n-                                this.bccx.report_aliasability_violation(\n-                                    expr.span,\n-                                    MutabilityViolation,\n-                                    cause);\n-                                return false;\n-                            }\n-                        }\n-                    }\n+                                            cmt: mc::cmt)\n+                                            -> bool {\n+            match cmt.freely_aliasable() {\n+                None => {\n+                    return true;\n+                }\n+                Some(cause) => {\n+                    this.bccx.report_aliasability_violation(\n+                        expr.span,\n+                        MutabilityViolation,\n+                        cause);\n+                    return false;\n                 }\n             }\n         }"}, {"sha": "ffc269f8cc8ddeada56531732fb1477822789d5e", "filename": "src/librustc/middle/borrowck/doc.rs", "status": "modified", "additions": 55, "deletions": 13, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/e9b9067560b1664abc8408f89b98a2469dd856ed/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b9067560b1664abc8408f89b98a2469dd856ed/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fdoc.rs?ref=e9b9067560b1664abc8408f89b98a2469dd856ed", "patch": "@@ -151,14 +151,13 @@ that the value `(*x).f` may be mutated via the newly created reference\n restrictions `RS` that accompany the loan.\n \n The first restriction `((*x).f, [MUTATE, CLAIM, FREEZE])` states that\n-the lender may not mutate nor freeze `(*x).f`. Mutation is illegal\n-because `(*x).f` is only supposed to be mutated via the new reference,\n-not by mutating the original path `(*x).f`. Freezing is\n+the lender may not mutate, freeze, nor alias `(*x).f`. Mutation is\n+illegal because `(*x).f` is only supposed to be mutated via the new\n+reference, not by mutating the original path `(*x).f`. Freezing is\n illegal because the path now has an `&mut` alias; so even if we the\n lender were to consider `(*x).f` to be immutable, it might be mutated\n-via this alias. Both of these restrictions are temporary. They will be\n-enforced for the lifetime `'a` of the loan. After the loan expires,\n-the restrictions no longer apply.\n+via this alias. They will be enforced for the lifetime `'a` of the\n+loan. After the loan expires, the restrictions no longer apply.\n \n The second restriction on `*x` is interesting because it does not\n apply to the path that was lent (`(*x).f`) but rather to a prefix of\n@@ -188,11 +187,9 @@ The kinds of expressions which in-scope loans can render illegal are:\n   against mutating `lv`;\n - *moves*: illegal if there is any in-scope restriction on `lv` at all;\n - *mutable borrows* (`&mut lv`): illegal there is an in-scope restriction\n-  against mutating `lv` or aliasing `lv`;\n+  against claiming `lv`;\n - *immutable borrows* (`&lv`): illegal there is an in-scope restriction\n-  against freezing `lv` or aliasing `lv`;\n-- *read-only borrows* (`&const lv`): illegal there is an in-scope restriction\n-  against aliasing `lv`.\n+  against freezing `lv`.\n \n ## Formal rules\n \n@@ -238,19 +235,23 @@ live. (This is done via restrictions, read on.)\n We start with the `gather_loans` pass, which walks the AST looking for\n borrows.  For each borrow, there are three bits of information: the\n lvalue `LV` being borrowed and the mutability `MQ` and lifetime `LT`\n-of the resulting pointer. Given those, `gather_loans` applies three\n+of the resulting pointer. Given those, `gather_loans` applies four\n validity tests:\n \n 1. `MUTABILITY(LV, MQ)`: The mutability of the reference is\n compatible with the mutability of `LV` (i.e., not borrowing immutable\n data as mutable).\n \n-2. `LIFETIME(LV, LT, MQ)`: The lifetime of the borrow does not exceed\n+2. `ALIASABLE(LV, MQ)`: The aliasability of the reference is\n+compatible with the aliasability of `LV`. The goal is to prevent\n+`&mut` borrows of aliasability data.\n+\n+3. `LIFETIME(LV, LT, MQ)`: The lifetime of the borrow does not exceed\n the lifetime of the value being borrowed. This pass is also\n responsible for inserting root annotations to keep managed values\n alive.\n \n-3. `RESTRICTIONS(LV, LT, ACTIONS) = RS`: This pass checks and computes the\n+4. `RESTRICTIONS(LV, LT, ACTIONS) = RS`: This pass checks and computes the\n restrictions to maintain memory safety. These are the restrictions\n that will go into the final loan. We'll discuss in more detail below.\n \n@@ -313,6 +314,47 @@ be borrowed if MQ is immutable or const:\n     MUTABILITY(*LV, MQ)                 // M-Deref-Borrowed-Mut\n       TYPE(LV) = &mut Ty\n \n+## Checking aliasability\n+\n+The goal of the aliasability check is to ensure that we never permit\n+`&mut` borrows of aliasable data. Formally we define a predicate\n+`ALIASABLE(LV, MQ)` which if defined means that\n+\"borrowing `LV` with mutability `MQ` is ok\". The\n+Rust code corresponding to this predicate is the function\n+`check_aliasability()` in `middle::borrowck::gather_loans`.\n+\n+### Checking aliasability of variables\n+\n+Local variables are never aliasable as they are accessible only within\n+the stack frame.\n+\n+    ALIASABLE(X, MQ)                   // M-Var-Mut\n+\n+### Checking aliasable of owned content\n+\n+Owned content is aliasable if it is found in an aliasable location:\n+\n+    ALIASABLE(LV.f, MQ)                // M-Field\n+      ALIASABLE(LV, MQ)\n+\n+    ALIASABLE(*LV, MQ)                 // M-Deref-Unique\n+      ALIASABLE(LV, MQ)\n+\n+### Checking mutability of immutable pointer types\n+\n+Immutable pointer types like `&T` are aliasable, and hence can only be\n+borrowed immutably:\n+\n+    ALIASABLE(*LV, imm)                // M-Deref-Borrowed-Imm\n+      TYPE(LV) = &Ty\n+\n+### Checking mutability of mutable pointer types\n+\n+`&mut T` can be frozen, so it is acceptable to borrow it as either imm or mut:\n+\n+    ALIASABLE(*LV, MQ)                 // M-Deref-Borrowed-Mut\n+      TYPE(LV) = &mut Ty\n+\n ## Checking lifetime\n \n These rules aim to ensure that no data is borrowed for a scope that exceeds"}, {"sha": "957073ac392bdf5a0149c0b3fe78e683c43c5923", "filename": "src/librustc/middle/borrowck/gather_loans/mod.rs", "status": "modified", "additions": 47, "deletions": 4, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/e9b9067560b1664abc8408f89b98a2469dd856ed/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b9067560b1664abc8408f89b98a2469dd856ed/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Fmod.rs?ref=e9b9067560b1664abc8408f89b98a2469dd856ed", "patch": "@@ -460,6 +460,11 @@ impl<'a> GatherLoanCtxt<'a> {\n             return; // reported an error, no sense in reporting more.\n         }\n \n+        // Check that we don't allow mutable borrows of aliasable data.\n+        if check_aliasability(self.bccx, borrow_span, cmt, req_mutbl).is_err() {\n+            return; // reported an error, no sense in reporting more.\n+        }\n+\n         // Compute the restrictions that are required to enforce the\n         // loan is safe.\n         let restr = restrictions::compute_restrictions(\n@@ -586,15 +591,53 @@ impl<'a> GatherLoanCtxt<'a> {\n                 }\n             }\n         }\n+\n+        fn check_aliasability(bccx: &BorrowckCtxt,\n+                              borrow_span: Span,\n+                              cmt: mc::cmt,\n+                              req_mutbl: LoanMutability) -> Result<(),()> {\n+            //! Implements the A-* rules in doc.rs.\n+\n+            match req_mutbl {\n+                ImmutableMutability => {\n+                    // both imm and mut data can be lent as imm;\n+                    // for mutable data, this is a freeze\n+                    Ok(())\n+                }\n+\n+                MutableMutability => {\n+                    // Check for those cases where we cannot control\n+                    // the aliasing and make sure that we are not\n+                    // being asked to.\n+                    match cmt.freely_aliasable() {\n+                        None => {\n+                            Ok(())\n+                        }\n+                        Some(mc::AliasableStaticMut) => {\n+                            // This is nasty, but we ignore the\n+                            // aliasing rules if the data is based in\n+                            // a `static mut`, since those are always\n+                            // unsafe. At your own peril and all that.\n+                            Ok(())\n+                        }\n+                        Some(cause) => {\n+                            bccx.report_aliasability_violation(\n+                                borrow_span,\n+                                BorrowViolation,\n+                                cause);\n+                            Err(())\n+                        }\n+                    }\n+                }\n+            }\n+        }\n     }\n \n     pub fn restriction_set(&self, req_mutbl: LoanMutability)\n                            -> RestrictionSet {\n         match req_mutbl {\n-            ImmutableMutability => RESTR_EMPTY | RESTR_MUTATE | RESTR_CLAIM,\n-            MutableMutability => {\n-                RESTR_EMPTY | RESTR_MUTATE | RESTR_CLAIM | RESTR_FREEZE\n-            }\n+            ImmutableMutability => RESTR_MUTATE | RESTR_CLAIM,\n+            MutableMutability => RESTR_MUTATE | RESTR_CLAIM | RESTR_FREEZE,\n         }\n     }\n "}, {"sha": "60e0baa3534bab5d3ab979c2e858a1ffca84ad3b", "filename": "src/librustc/middle/borrowck/gather_loans/restrictions.rs", "status": "modified", "additions": 0, "deletions": 34, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/e9b9067560b1664abc8408f89b98a2469dd856ed/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b9067560b1664abc8408f89b98a2469dd856ed/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fgather_loans%2Frestrictions.rs?ref=e9b9067560b1664abc8408f89b98a2469dd856ed", "patch": "@@ -53,16 +53,6 @@ impl<'a> RestrictionsContext<'a> {\n     fn restrict(&self,\n                 cmt: mc::cmt,\n                 restrictions: RestrictionSet) -> RestrictionResult {\n-\n-        // Check for those cases where we cannot control the aliasing\n-        // and make sure that we are not being asked to.\n-        match cmt.freely_aliasable() {\n-            None => {}\n-            Some(cause) => {\n-                self.check_aliasing_permitted(cause, restrictions);\n-            }\n-        }\n-\n         match cmt.cat {\n             mc::cat_rvalue(..) => {\n                 // Effectively, rvalues are stored into a\n@@ -179,28 +169,4 @@ impl<'a> RestrictionsContext<'a> {\n             }\n         }\n     }\n-\n-    fn check_aliasing_permitted(&self,\n-                                cause: mc::AliasableReason,\n-                                restrictions: RestrictionSet) {\n-        //! This method is invoked when the current `cmt` is something\n-        //! where aliasing cannot be controlled. It reports an error if\n-        //! the restrictions required that it not be aliased; currently\n-        //! this only occurs when re-borrowing an `&mut` pointer.\n-        //!\n-        //! NB: To be 100% consistent, we should report an error if\n-        //! RESTR_FREEZE is found, because we cannot prevent freezing,\n-        //! nor would we want to. However, we do not report such an\n-        //! error, because this restriction only occurs when the user\n-        //! is creating an `&mut` pointer to immutable or read-only\n-        //! data, and there is already another piece of code that\n-        //! checks for this condition.\n-\n-        if restrictions.intersects(RESTR_ALIAS) {\n-            self.bccx.report_aliasability_violation(\n-                self.span,\n-                BorrowViolation,\n-                cause);\n-        }\n-    }\n }"}, {"sha": "6a3e2fc63b08f21fde4427a9cfed1248d63b5051", "filename": "src/librustc/middle/borrowck/mod.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/e9b9067560b1664abc8408f89b98a2469dd856ed/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b9067560b1664abc8408f89b98a2469dd856ed/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fborrowck%2Fmod.rs?ref=e9b9067560b1664abc8408f89b98a2469dd856ed", "patch": "@@ -316,7 +316,6 @@ pub fn opt_loan_path(cmt: mc::cmt) -> Option<@LoanPath> {\n // - `RESTR_MUTATE`: The lvalue may not be modified.\n // - `RESTR_CLAIM`: `&mut` borrows of the lvalue are forbidden.\n // - `RESTR_FREEZE`: `&` borrows of the lvalue are forbidden.\n-// - `RESTR_ALIAS`: All borrows of the lvalue are forbidden.\n //\n // In addition, no value which is restricted may be moved. Therefore,\n // restrictions are meaningful even if the RestrictionSet is empty,\n@@ -336,7 +335,6 @@ pub static RESTR_EMPTY: RestrictionSet  = RestrictionSet {bits: 0b0000};\n pub static RESTR_MUTATE: RestrictionSet = RestrictionSet {bits: 0b0001};\n pub static RESTR_CLAIM: RestrictionSet  = RestrictionSet {bits: 0b0010};\n pub static RESTR_FREEZE: RestrictionSet = RestrictionSet {bits: 0b0100};\n-pub static RESTR_ALIAS: RestrictionSet  = RestrictionSet {bits: 0b1000};\n \n impl RestrictionSet {\n     pub fn intersects(&self, restr: RestrictionSet) -> bool {\n@@ -661,8 +659,8 @@ impl BorrowckCtxt {\n                                          kind: AliasableViolationKind,\n                                          cause: mc::AliasableReason) {\n         let prefix = match kind {\n-            MutabilityViolation => \"cannot assign to an `&mut`\",\n-            BorrowViolation => \"cannot borrow an `&mut`\"\n+            MutabilityViolation => \"cannot assign to data\",\n+            BorrowViolation => \"cannot borrow data mutably\"\n         };\n \n         match cause {\n@@ -671,17 +669,21 @@ impl BorrowckCtxt {\n                     span,\n                     format!(\"{} in an aliasable location\", prefix));\n             }\n+            mc::AliasableStatic |\n+            mc::AliasableStaticMut => {\n+                self.tcx.sess.span_err(\n+                    span,\n+                    format!(\"{} in a static location\", prefix));\n+            }\n             mc::AliasableManaged => {\n-                self.tcx.sess.span_err(span, format!(\"{} in a `@` pointer\",\n-                                                     prefix))\n+                self.tcx.sess.span_err(\n+                    span,\n+                    format!(\"{} in a `@` pointer\", prefix));\n             }\n-            mc::AliasableBorrowed(m) => {\n+            mc::AliasableBorrowed(_) => {\n                 self.tcx.sess.span_err(\n                     span,\n-                    format!(\"{} in a `&{}` pointer; \\\n-                          try an `&mut` instead\",\n-                         prefix,\n-                         self.mut_to_keyword(m)));\n+                    format!(\"{} in a `&` reference\", prefix));\n             }\n         }\n     }"}, {"sha": "93f439b653c59e1df0dc1a5a22d211c205e0fdb6", "filename": "src/librustc/middle/mem_categorization.rs", "status": "modified", "additions": 23, "deletions": 17, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/e9b9067560b1664abc8408f89b98a2469dd856ed/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b9067560b1664abc8408f89b98a2469dd856ed/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fmem_categorization.rs?ref=e9b9067560b1664abc8408f89b98a2469dd856ed", "patch": "@@ -1100,7 +1100,9 @@ pub fn field_mutbl(tcx: ty::ctxt,\n pub enum AliasableReason {\n     AliasableManaged,\n     AliasableBorrowed(ast::Mutability),\n-    AliasableOther\n+    AliasableOther,\n+    AliasableStatic,\n+    AliasableStaticMut,\n }\n \n impl cmt_ {\n@@ -1130,10 +1132,6 @@ impl cmt_ {\n         }\n     }\n \n-    pub fn is_freely_aliasable(&self) -> bool {\n-        self.freely_aliasable().is_some()\n-    }\n-\n     pub fn freely_aliasable(&self) -> Option<AliasableReason> {\n         /*!\n          * Returns `Some(_)` if this lvalue represents a freely aliasable\n@@ -1145,35 +1143,43 @@ impl cmt_ {\n         // aliased and eventually recused.\n \n         match self.cat {\n+            cat_deref(b, _, region_ptr(MutMutable, _)) |\n+            cat_downcast(b) |\n+            cat_stack_upvar(b) |\n+            cat_deref(b, _, uniq_ptr) |\n+            cat_interior(b, _) |\n+            cat_discr(b, _) => {\n+                // Aliasability depends on base cmt\n+                b.freely_aliasable()\n+            }\n+\n             cat_copied_upvar(CopiedUpvar {onceness: ast::Once, ..}) |\n             cat_rvalue(..) |\n             cat_local(..) |\n             cat_arg(_) |\n-            cat_deref(_, _, unsafe_ptr(..)) | // of course it is aliasable, but...\n-            cat_deref(_, _, region_ptr(MutMutable, _)) => {\n+            cat_deref(_, _, unsafe_ptr(..)) => { // yes, it's aliasable, but...\n                 None\n             }\n \n-            cat_copied_upvar(CopiedUpvar {onceness: ast::Many, ..}) |\n-            cat_static_item(..) => {\n+            cat_copied_upvar(CopiedUpvar {onceness: ast::Many, ..}) => {\n                 Some(AliasableOther)\n             }\n \n+            cat_static_item(..) => {\n+                if self.mutbl.is_mutable() {\n+                    Some(AliasableStaticMut)\n+                } else {\n+                    Some(AliasableStatic)\n+                }\n+            }\n+\n             cat_deref(_, _, gc_ptr) => {\n                 Some(AliasableManaged)\n             }\n \n             cat_deref(_, _, region_ptr(m @ MutImmutable, _)) => {\n                 Some(AliasableBorrowed(m))\n             }\n-\n-            cat_downcast(..) |\n-            cat_stack_upvar(..) |\n-            cat_deref(_, _, uniq_ptr) |\n-            cat_interior(..) |\n-            cat_discr(..) => {\n-                None\n-            }\n         }\n     }\n }"}, {"sha": "d19538c5d362b26d687fce143a2ad86e01fb96cb", "filename": "src/test/compile-fail/borrowck-borrow-mut-base-ptr-in-aliasable-loc.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e9b9067560b1664abc8408f89b98a2469dd856ed/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-mut-base-ptr-in-aliasable-loc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e9b9067560b1664abc8408f89b98a2469dd856ed/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-mut-base-ptr-in-aliasable-loc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fborrowck-borrow-mut-base-ptr-in-aliasable-loc.rs?ref=e9b9067560b1664abc8408f89b98a2469dd856ed", "patch": "@@ -27,5 +27,10 @@ fn foo3(t0: &mut &mut int) {\n     **t1 = 22;\n }\n \n+fn foo4(t0: & &mut int) {\n+    let x:  &mut int = &mut **t0; //~ ERROR cannot borrow\n+    *x += 1;\n+}\n+\n fn main() {\n }"}]}