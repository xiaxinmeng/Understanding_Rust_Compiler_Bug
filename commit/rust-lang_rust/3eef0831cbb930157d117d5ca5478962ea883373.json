{"sha": "3eef0831cbb930157d117d5ca5478962ea883373", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNlZWYwODMxY2JiOTMwMTU3ZDExN2Q1Y2E1NDc4OTYyZWE4ODMzNzM=", "commit": {"author": {"name": "Georg Brandl", "email": "georg@python.org", "date": "2016-05-01T10:01:12Z"}, "committer": {"name": "Georg Brandl", "email": "georg@python.org", "date": "2016-05-01T10:26:34Z"}, "message": "libsyntax/pp: minor modernizations\n\n* implement Display on Token instead of custom tok_str() fn\n* use expression returns\n* remove redundant parens in asserts\n* remove \"/* bad */\" comments that appear to be related to early\n  changes in memory management\n* and a few individual idiomatic changes", "tree": {"sha": "5f60b1844f6c216c0e12b494b9eb683d28ca7d76", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5f60b1844f6c216c0e12b494b9eb683d28ca7d76"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3eef0831cbb930157d117d5ca5478962ea883373", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3eef0831cbb930157d117d5ca5478962ea883373", "html_url": "https://github.com/rust-lang/rust/commit/3eef0831cbb930157d117d5ca5478962ea883373", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3eef0831cbb930157d117d5ca5478962ea883373/comments", "author": {"login": "birkenfeld", "id": 144359, "node_id": "MDQ6VXNlcjE0NDM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/144359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/birkenfeld", "html_url": "https://github.com/birkenfeld", "followers_url": "https://api.github.com/users/birkenfeld/followers", "following_url": "https://api.github.com/users/birkenfeld/following{/other_user}", "gists_url": "https://api.github.com/users/birkenfeld/gists{/gist_id}", "starred_url": "https://api.github.com/users/birkenfeld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/birkenfeld/subscriptions", "organizations_url": "https://api.github.com/users/birkenfeld/orgs", "repos_url": "https://api.github.com/users/birkenfeld/repos", "events_url": "https://api.github.com/users/birkenfeld/events{/privacy}", "received_events_url": "https://api.github.com/users/birkenfeld/received_events", "type": "User", "site_admin": false}, "committer": {"login": "birkenfeld", "id": 144359, "node_id": "MDQ6VXNlcjE0NDM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/144359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/birkenfeld", "html_url": "https://github.com/birkenfeld", "followers_url": "https://api.github.com/users/birkenfeld/followers", "following_url": "https://api.github.com/users/birkenfeld/following{/other_user}", "gists_url": "https://api.github.com/users/birkenfeld/gists{/gist_id}", "starred_url": "https://api.github.com/users/birkenfeld/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/birkenfeld/subscriptions", "organizations_url": "https://api.github.com/users/birkenfeld/orgs", "repos_url": "https://api.github.com/users/birkenfeld/repos", "events_url": "https://api.github.com/users/birkenfeld/events{/privacy}", "received_events_url": "https://api.github.com/users/birkenfeld/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2a815a26c8ce70e1aede585827c020d9775a8faf", "url": "https://api.github.com/repos/rust-lang/rust/commits/2a815a26c8ce70e1aede585827c020d9775a8faf", "html_url": "https://github.com/rust-lang/rust/commit/2a815a26c8ce70e1aede585827c020d9775a8faf"}], "stats": {"total": 72, "additions": 32, "deletions": 40}, "files": [{"sha": "a1fa126818f6acc4394c6e99094d3b9e2466df29", "filename": "src/libsyntax/print/pp.rs", "status": "modified", "additions": 32, "deletions": 40, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/3eef0831cbb930157d117d5ca5478962ea883373/src%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3eef0831cbb930157d117d5ca5478962ea883373/src%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpp.rs?ref=3eef0831cbb930157d117d5ca5478962ea883373", "patch": "@@ -61,8 +61,8 @@\n //! line (which it can't) and so naturally place the content on its own line to\n //! avoid combining it with other lines and making matters even worse.\n \n+use std::fmt;\n use std::io;\n-use std::string;\n \n #[derive(Clone, Copy, PartialEq)]\n pub enum Breaks {\n@@ -112,35 +112,30 @@ impl Token {\n     }\n }\n \n-pub fn tok_str(token: &Token) -> String {\n-    match *token {\n-        Token::String(ref s, len) => format!(\"STR({},{})\", s, len),\n-        Token::Break(_) => \"BREAK\".to_string(),\n-        Token::Begin(_) => \"BEGIN\".to_string(),\n-        Token::End => \"END\".to_string(),\n-        Token::Eof => \"EOF\".to_string()\n+impl fmt::Display for Token {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            Token::String(ref s, len) => write!(f, \"STR({},{})\", s, len),\n+            Token::Break(_) => f.write_str(\"BREAK\"),\n+            Token::Begin(_) => f.write_str(\"BEGIN\"),\n+            Token::End => f.write_str(\"END\"),\n+            Token::Eof => f.write_str(\"EOF\"),\n+        }\n     }\n }\n \n-pub fn buf_str(toks: &[Token],\n-               szs: &[isize],\n-               left: usize,\n-               right: usize,\n-               lim: usize)\n-               -> String {\n+fn buf_str(toks: &[Token], szs: &[isize], left: usize, right: usize, lim: usize) -> String {\n     let n = toks.len();\n     assert_eq!(n, szs.len());\n     let mut i = left;\n     let mut l = lim;\n-    let mut s = string::String::from(\"[\");\n+    let mut s = String::from(\"[\");\n     while i != right && l != 0 {\n         l -= 1;\n         if i != left {\n             s.push_str(\", \");\n         }\n-        s.push_str(&format!(\"{}={}\",\n-                           szs[i],\n-                           tok_str(&toks[i])));\n+        s.push_str(&format!(\"{}={}\", szs[i], &toks[i]));\n         i += 1;\n         i %= n;\n     }\n@@ -413,38 +408,38 @@ impl<'a> Printer<'a> {\n         } else {\n             self.top += 1;\n             self.top %= self.buf_len;\n-            assert!((self.top != self.bottom));\n+            assert!(self.top != self.bottom);\n         }\n         self.scan_stack[self.top] = x;\n     }\n     pub fn scan_pop(&mut self) -> usize {\n-        assert!((!self.scan_stack_empty));\n+        assert!(!self.scan_stack_empty);\n         let x = self.scan_stack[self.top];\n         if self.top == self.bottom {\n             self.scan_stack_empty = true;\n         } else {\n             self.top += self.buf_len - 1; self.top %= self.buf_len;\n         }\n-        return x;\n+        x\n     }\n     pub fn scan_top(&mut self) -> usize {\n-        assert!((!self.scan_stack_empty));\n-        return self.scan_stack[self.top];\n+        assert!(!self.scan_stack_empty);\n+        self.scan_stack[self.top]\n     }\n     pub fn scan_pop_bottom(&mut self) -> usize {\n-        assert!((!self.scan_stack_empty));\n+        assert!(!self.scan_stack_empty);\n         let x = self.scan_stack[self.bottom];\n         if self.top == self.bottom {\n             self.scan_stack_empty = true;\n         } else {\n             self.bottom += 1; self.bottom %= self.buf_len;\n         }\n-        return x;\n+        x\n     }\n     pub fn advance_right(&mut self) {\n         self.right += 1;\n         self.right %= self.buf_len;\n-        assert!((self.right != self.left));\n+        assert!(self.right != self.left);\n     }\n     pub fn advance_left(&mut self) -> io::Result<()> {\n         debug!(\"advance_left Vec<{},{}>, sizeof({})={}\", self.left, self.right,\n@@ -512,19 +507,16 @@ impl<'a> Printer<'a> {\n         let ret = write!(self.out, \"\\n\");\n         self.pending_indentation = 0;\n         self.indent(amount);\n-        return ret;\n+        ret\n     }\n     pub fn indent(&mut self, amount: isize) {\n         debug!(\"INDENT {}\", amount);\n         self.pending_indentation += amount;\n     }\n     pub fn get_top(&mut self) -> PrintStackElem {\n-        let print_stack = &mut self.print_stack;\n-        let n = print_stack.len();\n-        if n != 0 {\n-            (*print_stack)[n - 1]\n-        } else {\n-            PrintStackElem {\n+        match self.print_stack.last() {\n+            Some(el) => *el,\n+            None => PrintStackElem {\n                 offset: 0,\n                 pbreak: PrintStackBreak::Broken(Breaks::Inconsistent)\n             }\n@@ -538,7 +530,7 @@ impl<'a> Printer<'a> {\n         write!(self.out, \"{}\", s)\n     }\n     pub fn print(&mut self, token: Token, l: isize) -> io::Result<()> {\n-        debug!(\"print {} {} (remaining line space={})\", tok_str(&token), l,\n+        debug!(\"print {} {} (remaining line space={})\", token, l,\n                self.space);\n         debug!(\"{}\", buf_str(&self.token,\n                              &self.size,\n@@ -566,7 +558,7 @@ impl<'a> Printer<'a> {\n           Token::End => {\n             debug!(\"print End -> pop End\");\n             let print_stack = &mut self.print_stack;\n-            assert!((!print_stack.is_empty()));\n+            assert!(!print_stack.is_empty());\n             print_stack.pop().unwrap();\n             Ok(())\n           }\n@@ -603,12 +595,12 @@ impl<'a> Printer<'a> {\n               }\n             }\n           }\n-          Token::String(s, len) => {\n+          Token::String(ref s, len) => {\n             debug!(\"print String({})\", s);\n             assert_eq!(l, len);\n             // assert!(l <= space);\n             self.space -= len;\n-            self.print_str(&s[..])\n+            self.print_str(s)\n           }\n           Token::Eof => {\n             // Eof should never get here.\n@@ -652,15 +644,15 @@ pub fn eof(p: &mut Printer) -> io::Result<()> {\n }\n \n pub fn word(p: &mut Printer, wrd: &str) -> io::Result<()> {\n-    p.pretty_print(Token::String(/* bad */ wrd.to_string(), wrd.len() as isize))\n+    p.pretty_print(Token::String(wrd.to_string(), wrd.len() as isize))\n }\n \n pub fn huge_word(p: &mut Printer, wrd: &str) -> io::Result<()> {\n-    p.pretty_print(Token::String(/* bad */ wrd.to_string(), SIZE_INFINITY))\n+    p.pretty_print(Token::String(wrd.to_string(), SIZE_INFINITY))\n }\n \n pub fn zero_word(p: &mut Printer, wrd: &str) -> io::Result<()> {\n-    p.pretty_print(Token::String(/* bad */ wrd.to_string(), 0))\n+    p.pretty_print(Token::String(wrd.to_string(), 0))\n }\n \n pub fn spaces(p: &mut Printer, n: usize) -> io::Result<()> {"}]}