{"sha": "ba54ef8110db16475b19ff9a1eaa46c696fa9584", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJhNTRlZjgxMTBkYjE2NDc1YjE5ZmY5YTFlYWE0NmM2OTZmYTk1ODQ=", "commit": {"author": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2019-10-02T01:44:13Z"}, "committer": {"name": "Aaron Hill", "email": "aa1ronham@gmail.com", "date": "2019-10-02T01:44:13Z"}, "message": "Add comments, rename variable", "tree": {"sha": "385bc5f3ec982a819764cd107640d318b06c5ed4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/385bc5f3ec982a819764cd107640d318b06c5ed4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ba54ef8110db16475b19ff9a1eaa46c696fa9584", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIzBAABCAAdFiEE7J9Gc3TfBwj2K399tAh+UQ6YsWQFAl2UAO0ACgkQtAh+UQ6Y\nsWT1gw/+N4/TN+B8rAJxkYogx5KHs4XH5nquHQiMd/WyJa/oKqPYonhzaQ/lxeWt\n220fmwYF51zVstA9sVOxCaUJuCXwxPgEolPP/C3RDIEVoO4xMr6bi7icgS0S4A4Q\nIHLzXOE3qNKTQyqkB0z83dloA3DLWtk2JAZlwhiy8CUGXFeztFhpgB63MSfl0Ora\nvQd2OGHOuuOrxgroMCS5vqCiqDR6DBWWx5MuK6pfW4U/pit+YRBD4ZAVIZWMtJBC\nph1FTpqEG4MKAjmhBLWWIe6ZBHP59XeGj+PWvM6dxk2cAIpP3neYPxjgRZe5xZ9D\n5A3W/5aolZR+jq9NmAViF+AQb2aBmYfvVVQq2HP30EA/Jr4AcmwjDgwd43/K4KCK\n099j6oDdNPWsUd9eDfcJD8SS9LPE8GE+GVkJt9hOQECBAdtDfsQUfhQNdErtnd7P\nHbHFUqmQFkqIlneIHSoX/msMiaYRZjVTXVHhXcMDUjp6IB6YqCSK7mI2o0kaBMfs\nqvlkc799o3QMvcJQyci5iBLQfeIkZ/oxomXiIZflMY+jMWa4hBshgyASsCVTz9xW\nv/OWSgukhJ3rnJ/2/kJaYO0GqE+q9NH1/+GWFAr7t5/gR4UxdC3V645CNTpA046z\nMfySVaeiiNywmocKn1nvacX5K5j+YhWlc8aN97zZ94/aEanP5o8=\n=NQUE\n-----END PGP SIGNATURE-----", "payload": "tree 385bc5f3ec982a819764cd107640d318b06c5ed4\nparent 9c5a5c471aa9229b82bafa8ec18e55722d9ba8c3\nauthor Aaron Hill <aa1ronham@gmail.com> 1569980653 -0400\ncommitter Aaron Hill <aa1ronham@gmail.com> 1569980653 -0400\n\nAdd comments, rename variable\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ba54ef8110db16475b19ff9a1eaa46c696fa9584", "html_url": "https://github.com/rust-lang/rust/commit/ba54ef8110db16475b19ff9a1eaa46c696fa9584", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ba54ef8110db16475b19ff9a1eaa46c696fa9584/comments", "author": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Aaron1011", "id": 1408859, "node_id": "MDQ6VXNlcjE0MDg4NTk=", "avatar_url": "https://avatars.githubusercontent.com/u/1408859?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Aaron1011", "html_url": "https://github.com/Aaron1011", "followers_url": "https://api.github.com/users/Aaron1011/followers", "following_url": "https://api.github.com/users/Aaron1011/following{/other_user}", "gists_url": "https://api.github.com/users/Aaron1011/gists{/gist_id}", "starred_url": "https://api.github.com/users/Aaron1011/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Aaron1011/subscriptions", "organizations_url": "https://api.github.com/users/Aaron1011/orgs", "repos_url": "https://api.github.com/users/Aaron1011/repos", "events_url": "https://api.github.com/users/Aaron1011/events{/privacy}", "received_events_url": "https://api.github.com/users/Aaron1011/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9c5a5c471aa9229b82bafa8ec18e55722d9ba8c3", "url": "https://api.github.com/repos/rust-lang/rust/commits/9c5a5c471aa9229b82bafa8ec18e55722d9ba8c3", "html_url": "https://github.com/rust-lang/rust/commit/9c5a5c471aa9229b82bafa8ec18e55722d9ba8c3"}], "stats": {"total": 45, "additions": 40, "deletions": 5}, "files": [{"sha": "984da4432861e20c0e513c448baa7a3e092e3817", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting/mod.rs", "status": "modified", "additions": 40, "deletions": 5, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/ba54ef8110db16475b19ff9a1eaa46c696fa9584/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ba54ef8110db16475b19ff9a1eaa46c696fa9584/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting%2Fmod.rs?ref=ba54ef8110db16475b19ff9a1eaa46c696fa9584", "patch": "@@ -157,7 +157,42 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         let target_scc = self.constraint_sccs.scc(target_region);\n         let mut range = 0..path.len();\n \n-        let should_reverse = match from_region_origin {\n+        // As noted above, when reporting an error, there is typically a chain of constraints\n+        // leading from some \"source\" region which must outlive some \"target\" region.\n+        // In most cases, we prefer to \"blame\" the constraints closer to the target --\n+        // but there is one exception. When constraints arise from higher-ranked subtyping,\n+        // we generally prefer to blame the source value,\n+        // as the \"target\" in this case tends to be some type annotation that the user gave.\n+        // Therefore, if we find that the region origin is some instantiation\n+        // of a higher-ranked region, we start our search from the \"source\" point\n+        // rather than the \"target\", and we also tweak a few other things.\n+        //\n+        // An example might be this bit of Rust code:\n+        //\n+        // ```rust\n+        // let x: fn(&'static ()) = |_| {};\n+        // let y: for<'a> fn(&'a ()) = x;\n+        // ```\n+        //\n+        // In MIR, this will be converted into a combination of assignments and type ascriptions.\n+        // In particular, the 'static is imposed through a type ascription:\n+        //\n+        // ```rust\n+        // x = ...;\n+        // AscribeUserType(x, fn(&'static ())\n+        // y = x;\n+        // ```\n+        //\n+        // We wind up ultimately with constraints like\n+        //\n+        // ```rust\n+        // !a: 'temp1 // from the `y = x` statement\n+        // 'temp1: 'temp2\n+        // 'temp2: 'static // from the AscribeUserType\n+        // ```\n+        //\n+        // and here we prefer to blame the source (the y = x statement).\n+        let blame_source = match from_region_origin {\n             NLLRegionVariableOrigin::FreeRegion\n                 | NLLRegionVariableOrigin::Existential { from_forall: false  } => {\n                     true\n@@ -173,7 +208,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n             let constraint_sup_scc = self.constraint_sccs.scc(constraint.sup);\n \n-            if should_reverse {\n+            if blame_source {\n                 match categorized_path[*i].0 {\n                     ConstraintCategory::OpaqueType | ConstraintCategory::Boring |\n                     ConstraintCategory::BoringNoLocation | ConstraintCategory::Internal => false,\n@@ -190,14 +225,14 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             }\n         };\n \n-        let best_choice = if should_reverse {\n+        let best_choice = if blame_source {\n             range.rev().find(find_region)\n         } else {\n             range.find(find_region)\n         };\n \n-        debug!(\"best_blame_constraint: best_choice={:?} should_reverse={}\",\n-            best_choice, should_reverse);\n+        debug!(\"best_blame_constraint: best_choice={:?} blame_source={}\",\n+            best_choice, blame_source);\n \n         if let Some(i) = best_choice {\n             if let Some(next) = categorized_path.get(i + 1) {"}]}