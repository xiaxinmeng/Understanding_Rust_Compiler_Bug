{"sha": "600237fa1962027e281383709691475d44e048aa", "node_id": "MDY6Q29tbWl0NzI0NzEyOjYwMDIzN2ZhMTk2MjAyN2UyODEzODM3MDk2OTE0NzVkNDRlMDQ4YWE=", "commit": {"author": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2017-05-29T22:37:11Z"}, "committer": {"name": "Nick Cameron", "email": "ncameron@mozilla.com", "date": "2017-06-12T02:14:23Z"}, "message": "Add a sig module to save-analysis\n\nGenerates signatures for use in Rustdoc and similar tools.", "tree": {"sha": "1016e24961128ecaf4f01b061e137ed4f8874aa1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1016e24961128ecaf4f01b061e137ed4f8874aa1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/600237fa1962027e281383709691475d44e048aa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/600237fa1962027e281383709691475d44e048aa", "html_url": "https://github.com/rust-lang/rust/commit/600237fa1962027e281383709691475d44e048aa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/600237fa1962027e281383709691475d44e048aa/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e2eaef8497bd212694840515a568d592b17d0e07", "url": "https://api.github.com/repos/rust-lang/rust/commits/e2eaef8497bd212694840515a568d592b17d0e07", "html_url": "https://github.com/rust-lang/rust/commit/e2eaef8497bd212694840515a568d592b17d0e07"}], "stats": {"total": 588, "additions": 581, "deletions": 7}, "files": [{"sha": "655901aa8591cc9bba79574aea9678dbbefdce32", "filename": "src/librustc_save_analysis/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/600237fa1962027e281383709691475d44e048aa/src%2Flibrustc_save_analysis%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/600237fa1962027e281383709691475d44e048aa/src%2Flibrustc_save_analysis%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Flib.rs?ref=600237fa1962027e281383709691475d44e048aa", "patch": "@@ -44,6 +44,7 @@ mod dump_visitor;\n pub mod external_data;\n #[macro_use]\n pub mod span_utils;\n+mod sig;\n \n use rustc::hir;\n use rustc::hir::def::Def;"}, {"sha": "945f405659d539ad125c549d9033068b880c30ff", "filename": "src/librustc_save_analysis/sig.rs", "status": "added", "additions": 560, "deletions": 0, "changes": 560, "blob_url": "https://github.com/rust-lang/rust/blob/600237fa1962027e281383709691475d44e048aa/src%2Flibrustc_save_analysis%2Fsig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/600237fa1962027e281383709691475d44e048aa/src%2Flibrustc_save_analysis%2Fsig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_save_analysis%2Fsig.rs?ref=600237fa1962027e281383709691475d44e048aa", "patch": "@@ -0,0 +1,560 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// FIXME? None of these include visibility info.\n+// Large outstanding things - where clauses, defs/refs for generics\n+// paresable - each sig ends with `;` of ` {}`\n+\n+use SaveContext;\n+\n+use rls_data::{Signature, SigElement, Id};\n+\n+use rustc::hir::def::Def;\n+use rustc::hir::def_id::DefId;\n+use syntax::ast::{self, NodeId};\n+use syntax::print::pprust;\n+\n+\n+// TODO dup from json_dumper\n+fn id_from_def_id(id: DefId) -> Id {\n+    Id {\n+        krate: id.krate.as_u32(),\n+        index: id.index.as_u32(),\n+    }\n+}\n+\n+fn id_from_node_id(id: NodeId, scx: &SaveContext) -> Id {\n+    let def_id = scx.tcx.hir.local_def_id(id);\n+    id_from_def_id(def_id)\n+}\n+\n+type Result = ::std::result::Result<Signature, &'static str>;\n+\n+trait Sig {\n+    fn make(&self, offset: usize, id: Option<NodeId>, scx: &SaveContext) -> Result;\n+}\n+\n+fn extend_sig(mut sig: Signature,\n+              text: String,\n+              defs: Vec<SigElement>,\n+              refs: Vec<SigElement>)\n+              -> Signature {\n+    sig.text = text;\n+    sig.defs.extend(defs.into_iter());\n+    sig.refs.extend(refs.into_iter());\n+    sig\n+}\n+\n+fn replace_text(mut sig: Signature, text: String) -> Signature {\n+    sig.text = text;\n+    sig\n+}\n+\n+fn merge_sigs(text: String, sigs: Vec<Signature>) -> Signature {\n+    let mut result = Signature {\n+        text,\n+        defs: vec![],\n+        refs: vec![],\n+    };\n+\n+    let (defs, refs): (Vec<_>, Vec<_>) = sigs.into_iter().map(|s| (s.defs, s.refs)).unzip();\n+\n+    result.defs.extend(defs.into_iter().flat_map(|ds| ds.into_iter()));\n+    result.refs.extend(refs.into_iter().flat_map(|rs| rs.into_iter()));\n+\n+    result\n+}\n+\n+fn text_sig(text: String) -> Signature {\n+    Signature {\n+        text: text,\n+        defs: vec![],\n+        refs: vec![],\n+    }\n+}\n+\n+impl Sig for ast::Ty {\n+    fn make(&self, offset: usize, _parent_id: Option<NodeId>, scx: &SaveContext) -> Result {\n+        let id = Some(self.id);\n+        match self.node {\n+            ast::TyKind::Slice(ref ty) => {\n+                let nested = ty.make(offset + 1, id, scx)?;\n+                let text = format!(\"[{}]\", nested.text);\n+                Ok(replace_text(nested, text))\n+            }\n+            ast::TyKind::Ptr(ref mt) => {\n+                let prefix = match mt.mutbl {\n+                    ast::Mutability::Mutable => \"*mut \",\n+                    ast::Mutability::Immutable => \"*const \",\n+                };\n+                let nested = mt.ty.make(offset + prefix.len(), id, scx)?;\n+                let text = format!(\"{}{}\", prefix, nested.text);\n+                Ok(replace_text(nested, text))\n+            }\n+            ast::TyKind::Rptr(ref lifetime, ref mt) => {\n+                let mut prefix = \"&\".to_owned();\n+                if let &Some(ref l) = lifetime {\n+                    prefix.push_str(&l.ident.to_string());\n+                    prefix.push(' ');\n+                }\n+                if let ast::Mutability::Mutable = mt.mutbl {\n+                    prefix.push_str(\"mut \");\n+                };\n+\n+                let nested = mt.ty.make(offset + prefix.len(), id, scx)?;\n+                let text = format!(\"{}{}\", prefix, nested.text);\n+                Ok(replace_text(nested, text))\n+            }\n+            ast::TyKind::Never => {\n+                Ok(text_sig(\"!\".to_owned()))\n+            },\n+            ast::TyKind::Tup(ref ts) => {\n+                let mut text = \"(\".to_owned();\n+                let mut defs = vec![];\n+                let mut refs = vec![];\n+                for t in ts {\n+                    let nested = t.make(offset + text.len(), id, scx)?;\n+                    text.push_str(&nested.text);\n+                    text.push(',');\n+                    defs.extend(nested.defs.into_iter());\n+                    refs.extend(nested.refs.into_iter());\n+                }\n+                text.push(')');\n+                Ok(Signature { text, defs, refs })\n+            }\n+            ast::TyKind::Paren(ref ty) => {\n+                let nested = ty.make(offset + 1, id, scx)?;\n+                let text = format!(\"({})\", nested.text);\n+                Ok(replace_text(nested, text))\n+            }\n+            ast::TyKind::BareFn(ref f) => {\n+                let mut text = String::new();\n+                if !f.lifetimes.is_empty() {\n+                    // FIXME defs, bounds on lifetimes\n+                    text.push_str(\"for<\");\n+                    text.push_str(&f.lifetimes.iter().map(|l|\n+                        l.lifetime.ident.to_string()).collect::<Vec<_>>().join(\", \"));\n+                    text.push('>');\n+                }\n+\n+                if f.unsafety == ast::Unsafety::Unsafe {\n+                    text.push_str(\"unsafe \");\n+                }\n+                if f.abi != ::syntax::abi::Abi::Rust {\n+                    text.push_str(\"extern\");\n+                    text.push_str(&f.abi.to_string());\n+                    text.push(' ');\n+                }\n+                text.push_str(\"fn(\");\n+\n+                let mut defs = vec![];\n+                let mut refs = vec![];\n+                for i in &f.decl.inputs {\n+                    let nested = i.ty.make(offset + text.len(), Some(i.id), scx)?;\n+                    text.push_str(&nested.text);\n+                    text.push(',');\n+                    defs.extend(nested.defs.into_iter());\n+                    refs.extend(nested.refs.into_iter());\n+                }\n+                text.push(')');\n+                if let ast::FunctionRetTy::Ty(ref t) = f.decl.output {\n+                    text.push_str(\" -> \");\n+                    let nested = t.make(offset + text.len(), None, scx)?;\n+                    text.push_str(&nested.text);\n+                    text.push(',');\n+                    defs.extend(nested.defs.into_iter());\n+                    refs.extend(nested.refs.into_iter());\n+                }\n+\n+                Ok(Signature { text, defs, refs })\n+            }\n+            ast::TyKind::Path(None, ref path) => {\n+                path.make(offset, id, scx)\n+            }\n+            ast::TyKind::Path(Some(ref qself), ref path) => {\n+                let nested_ty = qself.ty.make(offset + 1, id, scx)?;\n+                let prefix = if qself.position == 0 {\n+                    format!(\"<{}>::\", nested_ty.text)\n+                } else if qself.position == 1 {\n+                    let first = pprust::path_segment_to_string(&path.segments[0]);\n+                    format!(\"<{} as {}>::\", nested_ty.text, first)\n+                } else {\n+                    // FIXME handle path instead of elipses.\n+                    format!(\"<{} as ...>::\", nested_ty.text)                    \n+                };\n+\n+                let name = pprust::path_segment_to_string(path.segments.last().ok_or(\"Bad path\")?);\n+                let def = scx.get_path_def(id.ok_or(\"Missing id for Path\")?);\n+                let id = id_from_def_id(def.def_id());\n+                if path.segments.len() - qself.position == 1 {\n+                    let start = offset + prefix.len();\n+                    let end = start + name.len();\n+\n+                    Ok(Signature {\n+                        text: prefix + &name,\n+                        defs: vec![],\n+                        refs: vec![SigElement { id, start, end }],\n+                    })\n+                } else {\n+                    let start = offset + prefix.len() + 5;\n+                    let end = start + name.len();\n+                    // FIXME should put the proper path in there, not elipses.\n+                    Ok(Signature {\n+                        text: prefix + \"...::\" + &name,\n+                        defs: vec![],\n+                        refs: vec![SigElement { id, start, end }],\n+                    })\n+                }\n+            }\n+            ast::TyKind::TraitObject(ref bounds) => {\n+                // FIXME recurse into bounds\n+                let nested = pprust::bounds_to_string(bounds);\n+                Ok(text_sig(nested))\n+            }\n+            ast::TyKind::ImplTrait(ref bounds) => {\n+                // FIXME recurse into bounds\n+                let nested = pprust::bounds_to_string(bounds);\n+                Ok(text_sig(format!(\"impl {}\", nested)))\n+            }\n+            ast::TyKind::Array(ref ty, ref v) => {\n+                let nested_ty = ty.make(offset + 1, id, scx)?;\n+                let expr = pprust::expr_to_string(v).replace('\\n', \" \");\n+                let text = format!(\"[{}; {}]\", nested_ty.text, expr);\n+                Ok(replace_text(nested_ty, text))\n+            }\n+            ast::TyKind::Typeof(_) |\n+            ast::TyKind::Infer |\n+            ast::TyKind::Err |\n+            ast::TyKind::ImplicitSelf |\n+            ast::TyKind::Mac(_) => Err(\"Ty\"),\n+        }\n+    }    \n+}\n+\n+impl Sig for ast::Item {\n+    fn make(&self, offset: usize, _parent_id: Option<NodeId>, scx: &SaveContext) -> Result {\n+        let id = Some(self.id);\n+\n+        let name_and_generics = |mut text: String, generics: &ast::Generics| -> Result {\n+            let name = self.ident.to_string();\n+            let def = SigElement {\n+                id: id_from_node_id(self.id, scx),\n+                start: offset + 5,\n+                end: offset + 5 + name.len(),\n+            };\n+            text.push_str(&name);\n+            let generics: Signature = generics.make(offset + text.len(), id, scx)?;\n+            // FIXME where clause\n+            let text = format!(\"{}{}\", text, generics.text);\n+            Ok(extend_sig(generics, text, vec![def], vec![]))\n+        };\n+\n+        match self.node {\n+            ast::ItemKind::Static(ref ty, m, ref expr) => {\n+                let mut text = \"static \".to_owned();\n+                if m == ast::Mutability::Mutable {\n+                    text.push_str(\"mut \");\n+                }\n+                let name = self.ident.to_string();\n+                let defs = vec![SigElement {\n+                    id: id_from_node_id(self.id, scx),\n+                    start: offset + text.len(),\n+                    end: offset + text.len() + name.len(),\n+                }];\n+                text.push_str(&name);\n+                text.push_str(\": \");\n+\n+                let ty = ty.make(offset + text.len(), id, scx)?;\n+                text.push_str(&ty.text);\n+                text.push_str(\" = \");\n+\n+                let expr = pprust::expr_to_string(expr).replace('\\n', \" \");\n+                text.push_str(&expr);\n+                text.push(';');\n+\n+                Ok(extend_sig(ty, text, defs, vec![]))\n+            }\n+            ast::ItemKind::Const(ref ty, ref expr) => {\n+                let mut text = \"const \".to_owned();\n+                let name = self.ident.to_string();\n+                let defs = vec![SigElement {\n+                    id: id_from_node_id(self.id, scx),\n+                    start: offset + text.len(),\n+                    end: offset + text.len() + name.len(),\n+                }];\n+                text.push_str(&name);\n+                text.push_str(\": \");\n+\n+                let ty = ty.make(offset + text.len(), id, scx)?;\n+                text.push_str(&ty.text);\n+                text.push_str(\" = \");\n+\n+                let expr = pprust::expr_to_string(expr).replace('\\n', \" \");\n+                text.push_str(&expr);\n+                text.push(';');\n+\n+                Ok(extend_sig(ty, text, defs, vec![]))\n+            }\n+            ast::ItemKind::Fn(ref decl, unsafety, constness, abi, ref generics, _) => {\n+                let mut text = String::new();\n+                if constness.node == ast::Constness::Const {\n+                    text.push_str(\"const \");\n+                }\n+                if unsafety == ast::Unsafety::Unsafe {\n+                    text.push_str(\"unsafe \");\n+                }\n+                if abi != ::syntax::abi::Abi::Rust {\n+                    text.push_str(\"extern\");\n+                    text.push_str(&abi.to_string());\n+                    text.push(' ');\n+                }\n+                text.push_str(\"fn \");\n+\n+                let mut sig = name_and_generics(text, generics)?;\n+\n+                sig.text.push('(');\n+                for i in &decl.inputs {\n+                    // FIXME shoudl descend into patterns to add defs.\n+                    sig.text.push_str(&pprust::pat_to_string(&i.pat));\n+                    sig.text.push_str(\": \");\n+                    let nested = i.ty.make(offset + sig.text.len(), Some(i.id), scx)?;\n+                    sig.text.push_str(&nested.text);\n+                    sig.text.push(',');\n+                    sig.defs.extend(nested.defs.into_iter());\n+                    sig.refs.extend(nested.refs.into_iter());\n+                }\n+                sig.text.push(')');\n+\n+                if let ast::FunctionRetTy::Ty(ref t) = decl.output {\n+                    sig.text.push_str(\" -> \");\n+                    let nested = t.make(offset + sig.text.len(), None, scx)?;\n+                    sig.text.push_str(&nested.text);\n+                    sig.text.push(',');\n+                    sig.defs.extend(nested.defs.into_iter());\n+                    sig.refs.extend(nested.refs.into_iter());\n+                }\n+\n+                Ok(sig)\n+            }\n+            ast::ItemKind::Mod(ref _mod) => {\n+                let mut text = \"mod \".to_owned();\n+                let name = self.ident.to_string();\n+                let defs = vec![SigElement {\n+                    id: id_from_node_id(self.id, scx),\n+                    start: offset + text.len(),\n+                    end: offset + text.len() + name.len(),\n+                }];\n+                text.push_str(&name);\n+                // Could be either `mod foo;` or `mod foo { ... }`, but we'll just puck one.\n+                text.push(';');\n+\n+                Ok(Signature {\n+                    text,\n+                    defs,\n+                    refs: vec![],\n+                })\n+            }\n+            ast::ItemKind::Ty(ref ty, ref generics) => {\n+                let text = \"type \".to_owned();\n+                let mut sig = name_and_generics(text, generics)?;\n+\n+                sig.text.push_str(\" = \");\n+                let ty = ty.make(offset + sig.text.len(), id, scx)?;\n+                sig.text.push_str(&ty.text);\n+                sig.text.push(';');\n+\n+                Ok(merge_sigs(sig.text.clone(), vec![sig, ty]))\n+            }\n+            ast::ItemKind::Enum(_, ref generics) => {\n+                let text = \"enum \".to_owned();\n+                let mut sig = name_and_generics(text, generics)?;\n+                sig.text.push_str(\" {}\");\n+                Ok(sig)\n+            }\n+            ast::ItemKind::Struct(_, ref generics) => {\n+                let text = \"struct \".to_owned();\n+                let mut sig = name_and_generics(text, generics)?;\n+                sig.text.push_str(\" {}\");\n+                Ok(sig)\n+            }\n+            ast::ItemKind::Union(_, ref generics) => {\n+                let text = \"union \".to_owned();\n+                let mut sig = name_and_generics(text, generics)?;\n+                sig.text.push_str(\" {}\");\n+                Ok(sig)\n+            }\n+            ast::ItemKind::Trait(unsafety, ref generics, ref bounds, _) => {\n+                let mut text = String::new();\n+                if unsafety == ast::Unsafety::Unsafe {\n+                    text.push_str(\"unsafe \");\n+                }\n+                text.push_str(\"trait \");\n+                let mut sig = name_and_generics(text, generics)?;\n+\n+                if !bounds.is_empty() {\n+                    sig.text.push_str(\": \");\n+                    sig.text.push_str(&pprust::bounds_to_string(bounds));\n+                }\n+                // FIXME where clause\n+                sig.text.push_str(\" {}\");\n+\n+                Ok(sig)\n+            }\n+            ast::ItemKind::DefaultImpl(unsafety, ref trait_ref) => {\n+                let mut text = String::new();\n+                if unsafety == ast::Unsafety::Unsafe {\n+                    text.push_str(\"unsafe \");\n+                }\n+                text.push_str(\"impl \");\n+                let trait_sig = trait_ref.path.make(offset + text.len(), id, scx)?;\n+                text.push_str(&trait_sig.text);\n+                text.push_str(\" for .. {}\");\n+                Ok(replace_text(trait_sig, text))\n+            }\n+            ast::ItemKind::Impl(unsafety,\n+                                polarity,\n+                                defaultness,\n+                                ref generics,\n+                                ref opt_trait,\n+                                ref ty,\n+                                _) => {\n+                let mut text = String::new();\n+                if let ast::Defaultness::Default = defaultness {\n+                    text.push_str(\"default \");\n+                }\n+                if unsafety == ast::Unsafety::Unsafe {\n+                    text.push_str(\"unsafe \");\n+                }\n+                text.push_str(\"impl\");\n+\n+                let generics_sig = generics.make(offset + text.len(), id, scx)?;\n+                text.push_str(&generics_sig.text);\n+\n+                text.push(' ');\n+\n+                let trait_sig = if let Some(ref t) = *opt_trait {\n+                    if polarity == ast::ImplPolarity::Negative {\n+                        text.push('!');\n+                    }\n+                    let trait_sig = t.path.make(offset + text.len(), id, scx)?;\n+                    text.push_str(&trait_sig.text);\n+                    text.push_str(\" for \");\n+                    trait_sig\n+                } else {\n+                    text_sig(String::new())\n+                };\n+\n+                let ty_sig = ty.make(offset + text.len(), id, scx)?;\n+                text.push_str(&ty_sig.text);\n+                \n+                text.push_str(\" {}\");\n+\n+                Ok(merge_sigs(text, vec![generics_sig, trait_sig, ty_sig]))\n+\n+                // FIXME where clause\n+            }\n+            ast::ItemKind::ForeignMod(_) => Err(\"extern mod\"),\n+            ast::ItemKind::GlobalAsm(_) => Err(\"glboal asm\"),\n+            ast::ItemKind::ExternCrate(_) => Err(\"extern crate\"),\n+            // FIXME should implement this (e.g., pub use).\n+            ast::ItemKind::Use(_) => Err(\"import\"),\n+            ast::ItemKind::Mac(..) |\n+            ast::ItemKind::MacroDef(_) => Err(\"Macro\"),\n+        }\n+    }\n+}\n+\n+impl Sig for ast::Path {\n+    fn make(&self, offset: usize, id: Option<NodeId>, scx: &SaveContext) -> Result {\n+        let def = scx.get_path_def(id.ok_or(\"Missing id for Path\")?);\n+        let id = id_from_def_id(def.def_id());\n+\n+        let (name, start, end) = match def {\n+            Def::AssociatedConst(..) |\n+            Def::Variant(..) |\n+            Def::VariantCtor(..) => {\n+                let len = self.segments.len();\n+                if len < 2 {\n+                    return Err(\"Bad path\");\n+                }\n+                // FIXME: really we should descend into the generics here and add SigElements for\n+                // them.\n+                // FIXME: would be nice to have a def for the first path segment.\n+                let seg1 = pprust::path_segment_to_string(&self.segments[len - 2]);\n+                let seg2 = pprust::path_segment_to_string(&self.segments[len - 1]);\n+                let start = offset + seg1.len() + 2;\n+                (format!(\"{}::{}\", seg1, seg2), start, start + seg2.len())\n+            }\n+            _ => {\n+                let name = pprust::path_segment_to_string(self.segments.last().ok_or(\"Bad path\")?);\n+                let end = offset + name.len();\n+                (name, offset, end)\n+            }\n+        };\n+\n+        Ok(Signature {\n+            text: name,\n+            defs: vec![],\n+            refs: vec![SigElement { id, start, end }],\n+        })\n+    }\n+}\n+\n+// This does not cover the where clause, which must be processed separately.\n+impl Sig for ast::Generics {\n+    fn make(&self, offset: usize, _parent_id: Option<NodeId>, scx: &SaveContext) -> Result {\n+        let total = self.lifetimes.len() + self.ty_params.len();\n+        if total == 0 {\n+            return Ok(text_sig(String::new()));\n+        }\n+\n+        let mut text = \"<\".to_owned();\n+\n+        let mut defs = vec![];\n+        for l in &self.lifetimes {\n+            let mut l_text = l.lifetime.ident.to_string();\n+            defs.push(SigElement {\n+                id: id_from_node_id(l.lifetime.id, scx),\n+                start: offset + text.len(),\n+                end: offset + text.len() + l_text.len(),\n+            });\n+\n+            if !l.bounds.is_empty() {\n+                l_text.push_str(\": \");\n+                let bounds = l.bounds.iter().map(|l| l.ident.to_string()).collect::<Vec<_>>().join(\" + \");\n+                l_text.push_str(&bounds);\n+                // FIXME add lifetime bounds refs.\n+            }\n+            text.push_str(&l_text);\n+            text.push(',');\n+        }\n+        for t in &self.ty_params {\n+            let mut t_text = t.ident.to_string();\n+            defs.push(SigElement {\n+                id: id_from_node_id(t.id, scx),\n+                start: offset + text.len(),\n+                end: offset + text.len() + t_text.len(),\n+            });\n+\n+            if !t.bounds.is_empty() {\n+                t_text.push_str(\": \");\n+                t_text.push_str(&pprust::bounds_to_string(&t.bounds));\n+                // FIXME descend properly into bounds.\n+            }\n+            text.push_str(&t_text);\n+            text.push(',');\n+        }\n+\n+        text.push('>');\n+        Ok(Signature {text, defs, refs: vec![] })\n+    }\n+}\n+\n+// TODO impl items, trait items"}, {"sha": "34cda433d5250ee9c1b0bb47671372b7e695a095", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/600237fa1962027e281383709691475d44e048aa/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/600237fa1962027e281383709691475d44e048aa/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=600237fa1962027e281383709691475d44e048aa", "patch": "@@ -370,6 +370,10 @@ pub fn path_to_string(p: &ast::Path) -> String {\n     to_string(|s| s.print_path(p, false, 0, false))\n }\n \n+pub fn path_segment_to_string(p: &ast::PathSegment) -> String {\n+    to_string(|s| s.print_path_segment(p, false))\n+}\n+\n pub fn ident_to_string(id: ast::Ident) -> String {\n     to_string(|s| s.print_ident(id))\n }\n@@ -2359,18 +2363,27 @@ impl<'a> State<'a> {\n             if i > 0 {\n                 word(&mut self.s, \"::\")?\n             }\n-            if segment.identifier.name != keywords::CrateRoot.name() &&\n-               segment.identifier.name != \"$crate\" {\n-                self.print_ident(segment.identifier)?;\n-                if let Some(ref parameters) = segment.parameters {\n-                    self.print_path_parameters(parameters, colons_before_params)?;\n-                }\n-            }\n+            self.print_path_segment(segment, colons_before_params)?;\n         }\n \n         Ok(())\n     }\n \n+    fn print_path_segment(&mut self,\n+                          segment: &ast::PathSegment,\n+                          colons_before_params: bool)\n+                          -> io::Result<()>\n+    {\n+        if segment.identifier.name != keywords::CrateRoot.name() &&\n+           segment.identifier.name != \"$crate\" {\n+            self.print_ident(segment.identifier)?;\n+            if let Some(ref parameters) = segment.parameters {\n+                self.print_path_parameters(parameters, colons_before_params)?;\n+            }\n+        }\n+        Ok(())\n+    }\n+\n     fn print_qpath(&mut self,\n                    path: &ast::Path,\n                    qself: &ast::QSelf,"}]}