{"sha": "efb5a9a9f03016b8d3d3c13f940bbbfeac2cdfa6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVmYjVhOWE5ZjAzMDE2YjhkM2QzYzEzZjk0MGJiYmZlYWMyY2RmYTY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-12-30T16:07:08Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-12-30T16:07:08Z"}, "message": "Auto merge of #30640 - steveklabnik:rollup, r=steveklabnik\n\n- Successful merges: #30373, #30502, #30511, #30546, #30556, #30620\n- Failed merges:", "tree": {"sha": "b0f93c0d1e3be477e20bcc5d162708207fb5200f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b0f93c0d1e3be477e20bcc5d162708207fb5200f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/efb5a9a9f03016b8d3d3c13f940bbbfeac2cdfa6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/efb5a9a9f03016b8d3d3c13f940bbbfeac2cdfa6", "html_url": "https://github.com/rust-lang/rust/commit/efb5a9a9f03016b8d3d3c13f940bbbfeac2cdfa6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/efb5a9a9f03016b8d3d3c13f940bbbfeac2cdfa6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "85fb3b6fc0a6698a001ad8b26b26d389645c3507", "url": "https://api.github.com/repos/rust-lang/rust/commits/85fb3b6fc0a6698a001ad8b26b26d389645c3507", "html_url": "https://github.com/rust-lang/rust/commit/85fb3b6fc0a6698a001ad8b26b26d389645c3507"}, {"sha": "a73df6bf24bc6f55cf3d2fa60f397bc7a0cb7024", "url": "https://api.github.com/repos/rust-lang/rust/commits/a73df6bf24bc6f55cf3d2fa60f397bc7a0cb7024", "html_url": "https://github.com/rust-lang/rust/commit/a73df6bf24bc6f55cf3d2fa60f397bc7a0cb7024"}], "stats": {"total": 136, "additions": 82, "deletions": 54}, "files": [{"sha": "eb033f5401d3c8a54f41b94e9e46723d44044612", "filename": ".gitmodules", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/efb5a9a9f03016b8d3d3c13f940bbbfeac2cdfa6/.gitmodules", "raw_url": "https://github.com/rust-lang/rust/raw/efb5a9a9f03016b8d3d3c13f940bbbfeac2cdfa6/.gitmodules", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitmodules?ref=efb5a9a9f03016b8d3d3c13f940bbbfeac2cdfa6", "patch": "@@ -13,7 +13,7 @@\n \turl = https://github.com/rust-lang/jemalloc.git\n [submodule \"src/rust-installer\"]\n \tpath = src/rust-installer\n-\turl = https://github.com/rust-lang/rust-installer\n+\turl = https://github.com/rust-lang/rust-installer.git\n [submodule \"src/liblibc\"]\n \tpath = src/liblibc\n-\turl = https://github.com/rust-lang/libc\n+\turl = https://github.com/rust-lang-nursery/libc.git"}, {"sha": "edf5e2ff738187aaeb9302e024b76d95c9b907c1", "filename": "src/doc/book/choosing-your-guarantees.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/efb5a9a9f03016b8d3d3c13f940bbbfeac2cdfa6/src%2Fdoc%2Fbook%2Fchoosing-your-guarantees.md", "raw_url": "https://github.com/rust-lang/rust/raw/efb5a9a9f03016b8d3d3c13f940bbbfeac2cdfa6/src%2Fdoc%2Fbook%2Fchoosing-your-guarantees.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fchoosing-your-guarantees.md?ref=efb5a9a9f03016b8d3d3c13f940bbbfeac2cdfa6", "patch": "@@ -340,11 +340,11 @@ With the former, the `RefCell<T>` is wrapping the `Vec<T>`, so the `Vec<T>` in i\n mutable. At the same time, there can only be one mutable borrow of the whole `Vec` at a given time.\n This means that your code cannot simultaneously work on different elements of the vector from\n different `Rc` handles. However, we are able to push and pop from the `Vec<T>` at will. This is\n-similar to an `&mut Vec<T>` with the borrow checking done at runtime.\n+similar to a `&mut Vec<T>` with the borrow checking done at runtime.\n \n With the latter, the borrowing is of individual elements, but the overall vector is immutable. Thus,\n we can independently borrow separate elements, but we cannot push or pop from the vector. This is\n-similar to an `&mut [T]`[^3], but, again, the borrow checking is at runtime.\n+similar to a `&mut [T]`[^3], but, again, the borrow checking is at runtime.\n \n In concurrent programs, we have a similar situation with `Arc<Mutex<T>>`, which provides shared\n mutability and ownership."}, {"sha": "86c07f9cf6c18673d70361c9a3b067e19b8bcf77", "filename": "src/doc/book/documentation.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/efb5a9a9f03016b8d3d3c13f940bbbfeac2cdfa6/src%2Fdoc%2Fbook%2Fdocumentation.md", "raw_url": "https://github.com/rust-lang/rust/raw/efb5a9a9f03016b8d3d3c13f940bbbfeac2cdfa6/src%2Fdoc%2Fbook%2Fdocumentation.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fdocumentation.md?ref=efb5a9a9f03016b8d3d3c13f940bbbfeac2cdfa6", "patch": "@@ -73,7 +73,7 @@ hello.rs:4 }\n ```\n \n This [unfortunate error](https://github.com/rust-lang/rust/issues/22547) is\n-correct: documentation comments apply to the thing after them, and there's\n+correct; documentation comments apply to the thing after them, and there's\n nothing after that last comment.\n \n [rc-new]: https://doc.rust-lang.org/nightly/std/rc/struct.Rc.html#method.new\n@@ -385,7 +385,7 @@ error handling. Lets say you want the following,\n \n ```rust,ignore\n /// use std::io;\n-/// let mut input = String::new(); \n+/// let mut input = String::new();\n /// try!(io::stdin().read_line(&mut input));\n ```\n \n@@ -398,7 +398,7 @@ don't return anything so this will give a mismatched types error.\n /// ```\n /// use std::io;\n /// # fn foo() -> io::Result<()> {\n-/// let mut input = String::new(); \n+/// let mut input = String::new();\n /// try!(io::stdin().read_line(&mut input));\n /// # Ok(())\n /// # }"}, {"sha": "2d418786e9a1ecbdced56712107249c77c91a714", "filename": "src/doc/book/lifetimes.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/efb5a9a9f03016b8d3d3c13f940bbbfeac2cdfa6/src%2Fdoc%2Fbook%2Flifetimes.md", "raw_url": "https://github.com/rust-lang/rust/raw/efb5a9a9f03016b8d3d3c13f940bbbfeac2cdfa6/src%2Fdoc%2Fbook%2Flifetimes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Flifetimes.md?ref=efb5a9a9f03016b8d3d3c13f940bbbfeac2cdfa6", "patch": "@@ -103,7 +103,7 @@ Then in our parameter list, we use the lifetimes we\u2019ve named:\n ...(x: &'a i32)\n ```\n \n-If we wanted an `&mut` reference, we\u2019d do this:\n+If we wanted a `&mut` reference, we\u2019d do this:\n \n ```rust,ignore\n ...(x: &'a mut i32)"}, {"sha": "acffaf4544b10182466cc619365a42d62015969e", "filename": "src/doc/book/match.md", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/efb5a9a9f03016b8d3d3c13f940bbbfeac2cdfa6/src%2Fdoc%2Fbook%2Fmatch.md", "raw_url": "https://github.com/rust-lang/rust/raw/efb5a9a9f03016b8d3d3c13f940bbbfeac2cdfa6/src%2Fdoc%2Fbook%2Fmatch.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fmatch.md?ref=efb5a9a9f03016b8d3d3c13f940bbbfeac2cdfa6", "patch": "@@ -23,26 +23,24 @@ match x {\n `match` takes an expression and then branches based on its value. Each \u2018arm\u2019 of\n the branch is of the form `val => expression`. When the value matches, that arm\u2019s\n expression will be evaluated. It\u2019s called `match` because of the term \u2018pattern\n-matching\u2019, which `match` is an implementation of. There\u2019s an [entire section on\n+matching\u2019, which `match` is an implementation of. There\u2019s a [separate section on\n patterns][patterns] that covers all the patterns that are possible here.\n \n [patterns]: patterns.html\n \n-So what\u2019s the big advantage? Well, there are a few. First of all, `match`\n-enforces \u2018exhaustiveness checking\u2019. Do you see that last arm, the one with the\n-underscore (`_`)? If we remove that arm, Rust will give us an error:\n+One of the many advantages of `match` is it enforces \u2018exhaustiveness checking\u2019. \n+For example if we remove the last arm with the underscore `_`, the compiler will \n+give us an error:\n \n ```text\n error: non-exhaustive patterns: `_` not covered\n ```\n \n-In other words, Rust is trying to tell us we forgot a value. Because `x` is an\n-integer, Rust knows that it can have a number of different values \u2013 for\n-example, `6`. Without the `_`, however, there is no arm that could match, and\n-so Rust refuses to compile the code. `_` acts like a \u2018catch-all arm\u2019. If none\n-of the other arms match, the arm with `_` will, and since we have this\n-catch-all arm, we now have an arm for every possible value of `x`, and so our\n-program will compile successfully.\n+Rust is telling us that we forgot a value. The compiler infers from `x` that it\n+can have any positive 32bit value; for example 1 to 2,147,483,647. The `_` acts \n+as a 'catch-all', and will catch all possible values that *aren't* specified in \n+an arm of `match`. As you can see with the previous example, we provide `match` \n+arms for integers 1-5, if `x` is 6 or any other value, then it is caught by `_`.\n \n `match` is also an expression, which means we can use it on the right-hand\n side of a `let` binding or directly where an expression is used:\n@@ -60,7 +58,8 @@ let number = match x {\n };\n ```\n \n-Sometimes it\u2019s a nice way of converting something from one type to another.\n+Sometimes it\u2019s a nice way of converting something from one type to another; in \n+this example the integers are converted to `String`.\n \n # Matching on enums\n \n@@ -91,7 +90,8 @@ fn process_message(msg: Message) {\n \n Again, the Rust compiler checks exhaustiveness, so it demands that you\n have a match arm for every variant of the enum. If you leave one off, it\n-will give you a compile-time error unless you use `_`.\n+will give you a compile-time error unless you use `_` or provide all possible \n+arms.\n \n Unlike the previous uses of `match`, you can\u2019t use the normal `if`\n statement to do this. You can use the [`if let`][if-let] statement,"}, {"sha": "a172390a02126a6a4ffde7c15b72594b0fdc57fd", "filename": "src/doc/book/references-and-borrowing.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/efb5a9a9f03016b8d3d3c13f940bbbfeac2cdfa6/src%2Fdoc%2Fbook%2Freferences-and-borrowing.md", "raw_url": "https://github.com/rust-lang/rust/raw/efb5a9a9f03016b8d3d3c13f940bbbfeac2cdfa6/src%2Fdoc%2Fbook%2Freferences-and-borrowing.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Freferences-and-borrowing.md?ref=efb5a9a9f03016b8d3d3c13f940bbbfeac2cdfa6", "patch": "@@ -126,7 +126,7 @@ the thing `y` points at. You\u2019ll notice that `x` had to be marked `mut` as well\n If it wasn\u2019t, we couldn\u2019t take a mutable borrow to an immutable value.\n \n You'll also notice we added an asterisk (`*`) in front of `y`, making it `*y`,\n-this is because `y` is an `&mut` reference. You'll also need to use them for\n+this is because `y` is a `&mut` reference. You'll also need to use them for\n accessing the contents of a reference as well.\n \n Otherwise, `&mut` references are just like references. There _is_ a large"}, {"sha": "6f052f964c675a67f1995a0a1543fdfbf01b868d", "filename": "src/libcore/iter.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/efb5a9a9f03016b8d3d3c13f940bbbfeac2cdfa6/src%2Flibcore%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efb5a9a9f03016b8d3d3c13f940bbbfeac2cdfa6/src%2Flibcore%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter.rs?ref=efb5a9a9f03016b8d3d3c13f940bbbfeac2cdfa6", "patch": "@@ -1113,16 +1113,22 @@ pub trait Iterator {\n         Take{iter: self, n: n}\n     }\n \n-    /// An iterator similar to `fold()`, with internal state.\n-    ///\n-    /// `scan()` accumulates a final value, similar to [`fold()`], but instead\n-    /// of passing along an accumulator, it maintains the accumulator internally.\n+    /// An iterator adaptor similar to [`fold()`] that holds internal state and\n+    /// produces a new iterator.\n     ///\n     /// [`fold()`]: #method.fold\n     ///\n-    /// On each iteraton of `scan()`, you can assign to the internal state, and\n-    /// a mutable reference to the state is passed as the first argument to the\n-    /// closure, allowing you to modify it on each iteration.\n+    /// `scan()` takes two arguments: an initial value which seeds the internal\n+    /// state, and a closure with two arguments, the first being a mutable\n+    /// reference to the internal state and the second an iterator element.\n+    /// The closure can assign to the internal state to share state between\n+    /// iterations.\n+    ///\n+    /// On iteration, the closure will be applied to each element of the\n+    /// iterator and the return value from the closure, an [`Option`], is\n+    /// yielded by the iterator.\n+    ///\n+    /// [`Option`]: ../option/enum.Option.html\n     ///\n     /// # Examples\n     ///"}, {"sha": "863e84be093d2d011fdcb717c9896c382f615a38", "filename": "src/libstd/io/stdio.rs", "status": "modified", "additions": 36, "deletions": 15, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/efb5a9a9f03016b8d3d3c13f940bbbfeac2cdfa6/src%2Flibstd%2Fio%2Fstdio.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efb5a9a9f03016b8d3d3c13f940bbbfeac2cdfa6/src%2Flibstd%2Fio%2Fstdio.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fio%2Fstdio.rs?ref=efb5a9a9f03016b8d3d3c13f940bbbfeac2cdfa6", "patch": "@@ -133,23 +133,30 @@ fn handle_ebadf<T>(r: io::Result<T>, default: T) -> io::Result<T> {\n /// A handle to the standard input stream of a process.\n ///\n /// Each handle is a shared reference to a global buffer of input data to this\n-/// process. A handle can be `lock`'d to gain full access to `BufRead` methods\n+/// process. A handle can be `lock`'d to gain full access to [`BufRead`] methods\n /// (e.g. `.lines()`). Writes to this handle are otherwise locked with respect\n /// to other writes.\n ///\n /// This handle implements the `Read` trait, but beware that concurrent reads\n /// of `Stdin` must be executed with care.\n ///\n-/// Created by the function `io::stdin()`.\n+/// Created by the [`io::stdin`] method.\n+///\n+/// [`io::stdin`]: fn.stdin.html\n+/// [`BufRead`]: trait.BufRead.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Stdin {\n     inner: Arc<Mutex<BufReader<Maybe<StdinRaw>>>>,\n }\n \n /// A locked reference to the `Stdin` handle.\n ///\n-/// This handle implements both the `Read` and `BufRead` traits and is\n-/// constructed via the `lock` method on `Stdin`.\n+/// This handle implements both the [`Read`] and [`BufRead`] traits, and\n+/// is constructed via the [`Stdin::lock`] method.\n+///\n+/// [`Read`]: trait.Read.html\n+/// [`BufRead`]: trait.BufRead.html\n+/// [`Stdin::lock`]: struct.Stdin.html#method.lock\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct StdinLock<'a> {\n     inner: MutexGuard<'a, BufReader<Maybe<StdinRaw>>>,\n@@ -159,7 +166,7 @@ pub struct StdinLock<'a> {\n ///\n /// Each handle returned is a reference to a shared global buffer whose access\n /// is synchronized via a mutex. If you need more explicit control over\n-/// locking, see the [lock() method][lock].\n+/// locking, see the [`lock() method`][lock].\n ///\n /// [lock]: struct.Stdin.html#method.lock\n ///\n@@ -221,8 +228,11 @@ impl Stdin {\n     /// guard.\n     ///\n     /// The lock is released when the returned lock goes out of scope. The\n-    /// returned guard also implements the `Read` and `BufRead` traits for\n+    /// returned guard also implements the [`Read`] and [`BufRead`] traits for\n     /// accessing the underlying data.\n+    ///\n+    /// [Read]: trait.Read.html\n+    /// [BufRead]: trait.BufRead.html\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn lock(&self) -> StdinLock {\n         StdinLock { inner: self.inner.lock().unwrap_or_else(|e| e.into_inner()) }\n@@ -231,7 +241,9 @@ impl Stdin {\n     /// Locks this handle and reads a line of input into the specified buffer.\n     ///\n     /// For detailed semantics of this method, see the documentation on\n-    /// `BufRead::read_line`.\n+    /// [`BufRead::read_line`].\n+    ///\n+    /// [`BufRead::read_line`]: trait.BufRead.html#method.read_line\n     ///\n     /// # Examples\n     ///\n@@ -314,7 +326,9 @@ const OUT_MAX: usize = ::usize::MAX;\n /// output stream. Access is also synchronized via a lock and explicit control\n /// over locking is available via the `lock` method.\n ///\n-/// Created by the function `io::stdout()`.\n+/// Created by the [`io::stdout`] method.\n+///\n+/// [`io::stdout`]: fn.stdout.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Stdout {\n     // FIXME: this should be LineWriter or BufWriter depending on the state of\n@@ -325,8 +339,11 @@ pub struct Stdout {\n \n /// A locked reference to the `Stdout` handle.\n ///\n-/// This handle implements the `Write` trait and is constructed via the `lock`\n-/// method on `Stdout`.\n+/// This handle implements the [`Write`] trait, and is constructed via\n+/// the [`Stdout::lock`] method.\n+///\n+/// [`Write`]: trait.Write.html\n+/// [`Stdout::lock`]: struct.Stdout.html#method.lock\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct StdoutLock<'a> {\n     inner: ReentrantMutexGuard<'a, RefCell<LineWriter<Maybe<StdoutRaw>>>>,\n@@ -336,9 +353,9 @@ pub struct StdoutLock<'a> {\n ///\n /// Each handle returned is a reference to a shared global buffer whose access\n /// is synchronized via a mutex. If you need more explicit control over\n-/// locking, see the [lock() method][lock].\n+/// locking, see the [Stdout::lock] method.\n ///\n-/// [lock]: struct.Stdout.html#method.lock\n+/// [Stdout::lock]: struct.Stdout.html#method.lock\n ///\n /// # Examples\n ///\n@@ -424,16 +441,20 @@ impl<'a> Write for StdoutLock<'a> {\n \n /// A handle to the standard error stream of a process.\n ///\n-/// For more information, see `stderr`\n+/// For more information, see the [`io::stderr`] method.\n+///\n+/// [`io::stderr`]: fn.stderr.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Stderr {\n     inner: Arc<ReentrantMutex<RefCell<Maybe<StderrRaw>>>>,\n }\n \n /// A locked reference to the `Stderr` handle.\n ///\n-/// This handle implements the `Write` trait and is constructed via the `lock`\n-/// method on `Stderr`.\n+/// This handle implements the `Write` trait and is constructed via\n+/// the [`Stderr::lock`] method.\n+///\n+/// [`Stderr::lock`]: struct.Stderr.html#method.lock\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct StderrLock<'a> {\n     inner: ReentrantMutexGuard<'a, RefCell<Maybe<StderrRaw>>>,"}, {"sha": "29ac991a547dc9b4925b854c0b1ea1a0a316c96f", "filename": "src/libstd/net/udp.rs", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/efb5a9a9f03016b8d3d3c13f940bbbfeac2cdfa6/src%2Flibstd%2Fnet%2Fudp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/efb5a9a9f03016b8d3d3c13f940bbbfeac2cdfa6/src%2Flibstd%2Fnet%2Fudp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fudp.rs?ref=efb5a9a9f03016b8d3d3c13f940bbbfeac2cdfa6", "patch": "@@ -27,18 +27,19 @@ use time::Duration;\n /// use std::net::UdpSocket;\n ///\n /// # fn foo() -> std::io::Result<()> {\n-/// let mut socket = try!(UdpSocket::bind(\"127.0.0.1:34254\"));\n+/// {\n+///     let mut socket = try!(UdpSocket::bind(\"127.0.0.1:34254\"));\n ///\n-/// let mut buf = [0; 10];\n-/// let (amt, src) = try!(socket.recv_from(&mut buf));\n+///     // read from the socket\n+///     let mut buf = [0; 10];\n+///     let (amt, src) = try!(socket.recv_from(&mut buf));\n ///\n-/// // Send a reply to the socket we received data from\n-/// let buf = &mut buf[..amt];\n-/// buf.reverse();\n-/// try!(socket.send_to(buf, &src));\n-///\n-/// drop(socket); // close the socket\n-/// # Ok(())\n+///     // send a reply to the socket we received data from\n+///     let buf = &mut buf[..amt];\n+///     buf.reverse();\n+///     try!(socket.send_to(buf, &src));\n+///     # Ok(())\n+/// } // the socket is closed here\n /// # }\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}]}