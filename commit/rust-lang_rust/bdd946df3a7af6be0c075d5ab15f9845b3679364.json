{"sha": "bdd946df3a7af6be0c075d5ab15f9845b3679364", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJkZDk0NmRmM2E3YWY2YmUwYzA3NWQ1YWIxNWY5ODQ1YjM2NzkzNjQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-03T13:06:44Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-02-03T13:06:44Z"}, "message": "Auto merge of #68665 - eddyb:debuginfo-early-create-var, r=nagisa\n\ncodegen: create DIVariables ahead of using them with llvm.dbg.declare.\n\nInstead of having `rustc_codegen_llvm` bundle creation of a `DIVariable` and `llvm.dbg.declare` into a single operation, they are now two separate methods, and the `DIVariable` is created earlier, specifically when `mir::VarDebugInfo`s are being partitioned into locals.\n\nWhile this isn't currently needed, it's a prerequisite for #48300, which adds fragmented debuginfo, where one `mir::VarDebugInfo` has multiple parts of itself mapped to different `mir::Place`s.\nFor debuggers to see one composite variable instead of several ones with the same name, we need to create a single `DIVariable` and share it between multiple `llvm.dbg.declare` calls, which are likely pointing to different MIR locals.\nThat makes the `per_local_var_debug_info` partitioning a good spot to do this in, as we can create *exactly* one `DIVariable` per `mir::VarDebugInfo`, and refer to it as many things as needed.\n\nI'm opening this PR separately because I want to test its perf impact in isolation (see https://github.com/rust-lang/rust/pull/48300#issuecomment-580121438).\n\nr? @nagisa or @oli-obk cc @michaelwoerister @nikomatsakis", "tree": {"sha": "9d9f2aa1e2d3ffa53f1986753eee97e8823c7553", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9d9f2aa1e2d3ffa53f1986753eee97e8823c7553"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bdd946df3a7af6be0c075d5ab15f9845b3679364", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bdd946df3a7af6be0c075d5ab15f9845b3679364", "html_url": "https://github.com/rust-lang/rust/commit/bdd946df3a7af6be0c075d5ab15f9845b3679364", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bdd946df3a7af6be0c075d5ab15f9845b3679364/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c58e09f138075ce6b3079f41f9c2f192a15b896c", "url": "https://api.github.com/repos/rust-lang/rust/commits/c58e09f138075ce6b3079f41f9c2f192a15b896c", "html_url": "https://github.com/rust-lang/rust/commit/c58e09f138075ce6b3079f41f9c2f192a15b896c"}, {"sha": "e35dfad5b8cfe12555c6b7459c75d4b78280bfb2", "url": "https://api.github.com/repos/rust-lang/rust/commits/e35dfad5b8cfe12555c6b7459c75d4b78280bfb2", "html_url": "https://github.com/rust-lang/rust/commit/e35dfad5b8cfe12555c6b7459c75d4b78280bfb2"}], "stats": {"total": 303, "additions": 209, "deletions": 94}, "files": [{"sha": "342ac437d3c247f60773d16cc07c6cfee1bcb4c8", "filename": "src/librustc_codegen_llvm/builder.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bdd946df3a7af6be0c075d5ab15f9845b3679364/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdd946df3a7af6be0c075d5ab15f9845b3679364/src%2Flibrustc_codegen_llvm%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fbuilder.rs?ref=bdd946df3a7af6be0c075d5ab15f9845b3679364", "patch": "@@ -57,6 +57,7 @@ impl BackendTypes for Builder<'_, 'll, 'tcx> {\n     type Funclet = <CodegenCx<'ll, 'tcx> as BackendTypes>::Funclet;\n \n     type DIScope = <CodegenCx<'ll, 'tcx> as BackendTypes>::DIScope;\n+    type DIVariable = <CodegenCx<'ll, 'tcx> as BackendTypes>::DIVariable;\n }\n \n impl ty::layout::HasDataLayout for Builder<'_, '_, '_> {"}, {"sha": "1d6bfb321598c9b5b1a92320044e7345d780c73c", "filename": "src/librustc_codegen_llvm/common.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bdd946df3a7af6be0c075d5ab15f9845b3679364/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdd946df3a7af6be0c075d5ab15f9845b3679364/src%2Flibrustc_codegen_llvm%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fcommon.rs?ref=bdd946df3a7af6be0c075d5ab15f9845b3679364", "patch": "@@ -91,6 +91,7 @@ impl BackendTypes for CodegenCx<'ll, 'tcx> {\n     type Funclet = Funclet<'ll>;\n \n     type DIScope = &'ll llvm::debuginfo::DIScope;\n+    type DIVariable = &'ll llvm::debuginfo::DIVariable;\n }\n \n impl CodegenCx<'ll, 'tcx> {"}, {"sha": "c4a52a73e25d9f6cd655bb32a633ea3aa6b23bd0", "filename": "src/librustc_codegen_llvm/debuginfo/mod.rs", "status": "modified", "additions": 52, "deletions": 34, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/bdd946df3a7af6be0c075d5ab15f9845b3679364/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdd946df3a7af6be0c075d5ab15f9845b3679364/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fdebuginfo%2Fmod.rs?ref=bdd946df3a7af6be0c075d5ab15f9845b3679364", "patch": "@@ -11,7 +11,7 @@ use self::utils::{create_DIArray, is_node_local_to_unit, span_start, DIB};\n \n use crate::llvm;\n use crate::llvm::debuginfo::{\n-    DIArray, DIBuilder, DIFile, DIFlags, DILexicalBlock, DISPFlags, DIScope, DIType,\n+    DIArray, DIBuilder, DIFile, DIFlags, DILexicalBlock, DISPFlags, DIScope, DIType, DIVariable,\n };\n use rustc::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use rustc::ty::subst::{GenericArgKind, SubstsRef};\n@@ -143,33 +143,23 @@ pub fn finalize(cx: &CodegenCx<'_, '_>) {\n     };\n }\n \n-impl DebugInfoBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n-    fn declare_local(\n+impl DebugInfoBuilderMethods for Builder<'a, 'll, 'tcx> {\n+    // FIXME(eddyb) find a common convention for all of the debuginfo-related\n+    // names (choose between `dbg`, `debug`, `debuginfo`, `debug_info` etc.).\n+    fn dbg_var_addr(\n         &mut self,\n         dbg_context: &FunctionDebugContext<&'ll DIScope>,\n-        variable_name: ast::Name,\n-        variable_type: Ty<'tcx>,\n+        dbg_var: &'ll DIVariable,\n         scope_metadata: &'ll DIScope,\n         variable_alloca: Self::Value,\n         direct_offset: Size,\n         indirect_offsets: &[Size],\n-        variable_kind: VariableKind,\n         span: Span,\n     ) {\n         assert!(!dbg_context.source_locations_enabled);\n         let cx = self.cx();\n \n-        let file = span_start(cx, span).file;\n-        let file_metadata = file_metadata(cx, &file.name, dbg_context.defining_crate);\n-\n         let loc = span_start(cx, span);\n-        let type_metadata = type_metadata(cx, variable_type, span);\n-\n-        let (argument_index, dwarf_tag) = match variable_kind {\n-            ArgumentVariable(index) => (index as c_uint, DW_TAG_arg_variable),\n-            LocalVariable => (0, DW_TAG_auto_variable),\n-        };\n-        let align = cx.align_of(variable_type);\n \n         // Convert the direct and indirect offsets to address ops.\n         let op_deref = || unsafe { llvm::LLVMRustDIBuilderCreateOpDeref() };\n@@ -188,32 +178,19 @@ impl DebugInfoBuilderMethods<'tcx> for Builder<'a, 'll, 'tcx> {\n             }\n         }\n \n-        let name = SmallCStr::new(&variable_name.as_str());\n-        let metadata = unsafe {\n-            llvm::LLVMRustDIBuilderCreateVariable(\n-                DIB(cx),\n-                dwarf_tag,\n-                scope_metadata,\n-                name.as_ptr(),\n-                file_metadata,\n-                loc.line as c_uint,\n-                type_metadata,\n-                cx.sess().opts.optimize != config::OptLevel::No,\n-                DIFlags::FlagZero,\n-                argument_index,\n-                align.bytes() as u32,\n-            )\n-        };\n+        // FIXME(eddyb) maybe this information could be extracted from `var`,\n+        // to avoid having to pass it down in both places?\n         source_loc::set_debug_location(\n             self,\n             InternalDebugLocation::new(scope_metadata, loc.line, loc.col.to_usize()),\n         );\n         unsafe {\n             let debug_loc = llvm::LLVMGetCurrentDebugLocation(self.llbuilder);\n+            // FIXME(eddyb) replace `llvm.dbg.declare` with `llvm.dbg.addr`.\n             let instr = llvm::LLVMRustDIBuilderInsertDeclareAtEnd(\n                 DIB(cx),\n                 variable_alloca,\n-                metadata,\n+                dbg_var,\n                 addr_ops.as_ptr(),\n                 addr_ops.len() as c_uint,\n                 debug_loc,\n@@ -313,7 +290,8 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         // Get the linkage_name, which is just the symbol name\n         let linkage_name = mangled_name_of_instance(self, instance);\n \n-        let scope_line = span_start(self, span).line;\n+        // FIXME(eddyb) does this need to be separate from `loc.line` for some reason?\n+        let scope_line = loc.line;\n \n         let function_name = CString::new(name).unwrap();\n         let linkage_name = SmallCStr::new(&linkage_name.name.as_str());\n@@ -558,4 +536,44 @@ impl DebugInfoMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n     fn debuginfo_finalize(&self) {\n         finalize(self)\n     }\n+\n+    // FIXME(eddyb) find a common convention for all of the debuginfo-related\n+    // names (choose between `dbg`, `debug`, `debuginfo`, `debug_info` etc.).\n+    fn create_dbg_var(\n+        &self,\n+        dbg_context: &FunctionDebugContext<&'ll DIScope>,\n+        variable_name: ast::Name,\n+        variable_type: Ty<'tcx>,\n+        scope_metadata: &'ll DIScope,\n+        variable_kind: VariableKind,\n+        span: Span,\n+    ) -> &'ll DIVariable {\n+        let loc = span_start(self, span);\n+        let file_metadata = file_metadata(self, &loc.file.name, dbg_context.defining_crate);\n+\n+        let type_metadata = type_metadata(self, variable_type, span);\n+\n+        let (argument_index, dwarf_tag) = match variable_kind {\n+            ArgumentVariable(index) => (index as c_uint, DW_TAG_arg_variable),\n+            LocalVariable => (0, DW_TAG_auto_variable),\n+        };\n+        let align = self.align_of(variable_type);\n+\n+        let name = SmallCStr::new(&variable_name.as_str());\n+        unsafe {\n+            llvm::LLVMRustDIBuilderCreateVariable(\n+                DIB(self),\n+                dwarf_tag,\n+                scope_metadata,\n+                name.as_ptr(),\n+                file_metadata,\n+                loc.line as c_uint,\n+                type_metadata,\n+                self.sess().opts.optimize != config::OptLevel::No,\n+                DIFlags::FlagZero,\n+                argument_index,\n+                align.bytes() as u32,\n+            )\n+        }\n+    }\n }"}, {"sha": "f66496d10fb166fc6c9fb4767c640d926954ead8", "filename": "src/librustc_codegen_ssa/mir/debuginfo.rs", "status": "modified", "additions": 125, "deletions": 49, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/bdd946df3a7af6be0c075d5ab15f9845b3679364/src%2Flibrustc_codegen_ssa%2Fmir%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdd946df3a7af6be0c075d5ab15f9845b3679364/src%2Flibrustc_codegen_ssa%2Fmir%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fdebuginfo.rs?ref=bdd946df3a7af6be0c075d5ab15f9845b3679364", "patch": "@@ -1,12 +1,12 @@\n use crate::traits::*;\n use rustc::mir;\n use rustc::session::config::DebugInfo;\n+use rustc::ty;\n use rustc::ty::layout::{LayoutOf, Size};\n-use rustc::ty::TyCtxt;\n use rustc_hir::def_id::CrateNum;\n use rustc_index::vec::IndexVec;\n \n-use rustc_span::symbol::kw;\n+use rustc_span::symbol::{kw, Symbol};\n use rustc_span::{BytePos, Span};\n \n use super::OperandValue;\n@@ -24,6 +24,19 @@ pub enum VariableKind {\n     LocalVariable,\n }\n \n+/// Like `mir::VarDebugInfo`, but within a `mir::Local`.\n+#[derive(Copy, Clone)]\n+pub struct PerLocalVarDebugInfo<'tcx, D> {\n+    pub name: Symbol,\n+    pub source_info: mir::SourceInfo,\n+\n+    /// `DIVariable` returned by `create_dbg_var`.\n+    pub dbg_var: Option<D>,\n+\n+    /// `.place.projection` from `mir::VarDebugInfo`.\n+    pub projection: &'tcx ty::List<mir::PlaceElem<'tcx>>,\n+}\n+\n #[derive(Clone, Copy, Debug)]\n pub struct DebugScope<D> {\n     pub scope_metadata: Option<D>,\n@@ -103,6 +116,8 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     // FIXME(eddyb) use `llvm.dbg.value` (which would work for operands),\n     // not just `llvm.dbg.declare` (which requires `alloca`).\n     pub fn debug_introduce_local(&self, bx: &mut Bx, local: mir::Local) {\n+        let full_debug_info = bx.sess().opts.debuginfo == DebugInfo::Full;\n+\n         // FIXME(eddyb) maybe name the return place as `_0` or `return`?\n         if local == mir::RETURN_PLACE {\n             return;\n@@ -112,35 +127,63 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             Some(per_local) => &per_local[local],\n             None => return,\n         };\n-        let whole_local_var = vars.iter().copied().find(|var| var.place.projection.is_empty());\n-        let has_proj = || vars.iter().any(|var| !var.place.projection.is_empty());\n+        let whole_local_var = vars.iter().find(|var| var.projection.is_empty()).copied();\n+        let has_proj = || vars.iter().any(|var| !var.projection.is_empty());\n \n-        let (fallback_var, kind) = if self.mir.local_kind(local) == mir::LocalKind::Arg {\n+        let fallback_var = if self.mir.local_kind(local) == mir::LocalKind::Arg {\n             let arg_index = local.index() - 1;\n \n             // Add debuginfo even to unnamed arguments.\n             // FIXME(eddyb) is this really needed?\n-            let var = if arg_index == 0 && has_proj() {\n+            if arg_index == 0 && has_proj() {\n                 // Hide closure environments from debuginfo.\n                 // FIXME(eddyb) shouldn't `ArgumentVariable` indices\n                 // be offset to account for the hidden environment?\n                 None\n+            } else if whole_local_var.is_some() {\n+                // No need to make up anything, there is a `mir::VarDebugInfo`\n+                // covering the whole local.\n+                // FIXME(eddyb) take `whole_local_var.source_info.scope` into\n+                // account, just in case it doesn't use `ArgumentVariable`\n+                // (after #67586 gets fixed).\n+                None\n             } else {\n-                Some(mir::VarDebugInfo {\n-                    name: kw::Invalid,\n-                    source_info: self.mir.local_decls[local].source_info,\n-                    place: local.into(),\n+                let name = kw::Invalid;\n+                let decl = &self.mir.local_decls[local];\n+                let (scope, span) = if full_debug_info {\n+                    self.debug_loc(decl.source_info)\n+                } else {\n+                    (None, decl.source_info.span)\n+                };\n+                let dbg_var = scope.map(|scope| {\n+                    // FIXME(eddyb) is this `+ 1` needed at all?\n+                    let kind = VariableKind::ArgumentVariable(arg_index + 1);\n+\n+                    self.cx.create_dbg_var(\n+                        self.debug_context.as_ref().unwrap(),\n+                        name,\n+                        self.monomorphize(&decl.ty),\n+                        scope,\n+                        kind,\n+                        span,\n+                    )\n+                });\n+\n+                Some(PerLocalVarDebugInfo {\n+                    name,\n+                    source_info: decl.source_info,\n+                    dbg_var,\n+                    projection: ty::List::empty(),\n                 })\n-            };\n-            (var, VariableKind::ArgumentVariable(arg_index + 1))\n+            }\n         } else {\n-            (None, VariableKind::LocalVariable)\n+            None\n         };\n \n         let local_ref = &self.locals[local];\n \n         if !bx.sess().fewer_names() {\n-            let name = match whole_local_var.or(fallback_var.as_ref()) {\n+            let name = match whole_local_var.or(fallback_var) {\n                 Some(var) if var.name != kw::Invalid => var.name.to_string(),\n                 _ => format!(\"{:?}\", local),\n             };\n@@ -163,7 +206,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             }\n         }\n \n-        if bx.sess().opts.debuginfo != DebugInfo::Full {\n+        if !full_debug_info {\n             return;\n         }\n \n@@ -178,22 +221,15 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             _ => return,\n         };\n \n-        let vars = vars.iter().copied().chain(if whole_local_var.is_none() {\n-            fallback_var.as_ref()\n-        } else {\n-            None\n-        });\n+        let vars = vars.iter().copied().chain(fallback_var);\n \n         for var in vars {\n             let mut layout = base.layout;\n             let mut direct_offset = Size::ZERO;\n             // FIXME(eddyb) use smallvec here.\n             let mut indirect_offsets = vec![];\n \n-            let kind =\n-                if var.place.projection.is_empty() { kind } else { VariableKind::LocalVariable };\n-\n-            for elem in &var.place.projection[..] {\n+            for elem in &var.projection[..] {\n                 match *elem {\n                     mir::ProjectionElem::Deref => {\n                         indirect_offsets.push(Size::ZERO);\n@@ -202,7 +238,7 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                                 .ty\n                                 .builtin_deref(true)\n                                 .unwrap_or_else(|| {\n-                                    span_bug!(var.source_info.span, \"cannot deref `{}`\", layout.ty,)\n+                                    span_bug!(var.source_info.span, \"cannot deref `{}`\", layout.ty)\n                                 })\n                                 .ty,\n                         );\n@@ -219,24 +255,24 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     _ => span_bug!(\n                         var.source_info.span,\n                         \"unsupported var debuginfo place `{:?}`\",\n-                        var.place,\n+                        mir::Place { local, projection: var.projection },\n                     ),\n                 }\n             }\n \n             let (scope, span) = self.debug_loc(var.source_info);\n             if let Some(scope) = scope {\n-                bx.declare_local(\n-                    debug_context,\n-                    var.name,\n-                    layout.ty,\n-                    scope,\n-                    base.llval,\n-                    direct_offset,\n-                    &indirect_offsets,\n-                    kind,\n-                    span,\n-                );\n+                if let Some(dbg_var) = var.dbg_var {\n+                    bx.dbg_var_addr(\n+                        debug_context,\n+                        dbg_var,\n+                        scope,\n+                        base.llval,\n+                        direct_offset,\n+                        &indirect_offsets,\n+                        span,\n+                    );\n+                }\n             }\n         }\n     }\n@@ -248,20 +284,60 @@ impl<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n             }\n         }\n     }\n-}\n \n-/// Partition all `VarDebuginfo` in `body`, by their base `Local`.\n-pub fn per_local_var_debug_info(\n-    tcx: TyCtxt<'tcx>,\n-    body: &'a mir::Body<'tcx>,\n-) -> Option<IndexVec<mir::Local, Vec<&'a mir::VarDebugInfo<'tcx>>>> {\n-    if tcx.sess.opts.debuginfo == DebugInfo::Full || !tcx.sess.fewer_names() {\n-        let mut per_local = IndexVec::from_elem(vec![], &body.local_decls);\n-        for var in &body.var_debug_info {\n-            per_local[var.place.local].push(var);\n+    /// Partition all `VarDebugInfo` in `self.mir`, by their base `Local`.\n+    pub fn compute_per_local_var_debug_info(\n+        &self,\n+    ) -> Option<IndexVec<mir::Local, Vec<PerLocalVarDebugInfo<'tcx, Bx::DIVariable>>>> {\n+        let full_debug_info = self.cx.sess().opts.debuginfo == DebugInfo::Full;\n+\n+        if !(full_debug_info || !self.cx.sess().fewer_names()) {\n+            return None;\n+        }\n+\n+        let mut per_local = IndexVec::from_elem(vec![], &self.mir.local_decls);\n+        for var in &self.mir.var_debug_info {\n+            let (scope, span) = if full_debug_info {\n+                self.debug_loc(var.source_info)\n+            } else {\n+                (None, var.source_info.span)\n+            };\n+            let dbg_var = scope.map(|scope| {\n+                let place = var.place;\n+                let var_ty = self.monomorphized_place_ty(place.as_ref());\n+                let var_kind = if self.mir.local_kind(place.local) == mir::LocalKind::Arg\n+                    && place.projection.is_empty()\n+                {\n+                    // FIXME(eddyb, #67586) take `var.source_info.scope` into\n+                    // account to avoid using `ArgumentVariable` more than once\n+                    // per argument local.\n+\n+                    let arg_index = place.local.index() - 1;\n+\n+                    // FIXME(eddyb) shouldn't `ArgumentVariable` indices be\n+                    // offset in closures to account for the hidden environment?\n+                    // Also, is this `+ 1` needed at all?\n+                    VariableKind::ArgumentVariable(arg_index + 1)\n+                } else {\n+                    VariableKind::LocalVariable\n+                };\n+                self.cx.create_dbg_var(\n+                    self.debug_context.as_ref().unwrap(),\n+                    var.name,\n+                    var_ty,\n+                    scope,\n+                    var_kind,\n+                    span,\n+                )\n+            });\n+\n+            per_local[var.place.local].push(PerLocalVarDebugInfo {\n+                name: var.name,\n+                source_info: var.source_info,\n+                dbg_var,\n+                projection: var.place.projection,\n+            });\n         }\n         Some(per_local)\n-    } else {\n-        None\n     }\n }"}, {"sha": "8a6284479c722160ac48562c44b8308013c4658f", "filename": "src/librustc_codegen_ssa/mir/mod.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/bdd946df3a7af6be0c075d5ab15f9845b3679364/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdd946df3a7af6be0c075d5ab15f9845b3679364/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fmod.rs?ref=bdd946df3a7af6be0c075d5ab15f9845b3679364", "patch": "@@ -11,7 +11,7 @@ use rustc_index::bit_set::BitSet;\n use rustc_index::vec::IndexVec;\n \n use self::analyze::CleanupKind;\n-use self::debuginfo::FunctionDebugContext;\n+use self::debuginfo::{FunctionDebugContext, PerLocalVarDebugInfo};\n use self::place::PlaceRef;\n use rustc::mir::traversal;\n \n@@ -74,9 +74,10 @@ pub struct FunctionCx<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>> {\n     /// notably `expect`.\n     locals: IndexVec<mir::Local, LocalRef<'tcx, Bx::Value>>,\n \n-    /// All `VarDebuginfo` from the MIR body, partitioned by `Local`.\n-    /// This is `None` if no variable debuginfo/names are needed.\n-    per_local_var_debug_info: Option<IndexVec<mir::Local, Vec<&'tcx mir::VarDebugInfo<'tcx>>>>,\n+    /// All `VarDebugInfo` from the MIR body, partitioned by `Local`.\n+    /// This is `None` if no var`#[non_exhaustive]`iable debuginfo/names are needed.\n+    per_local_var_debug_info:\n+        Option<IndexVec<mir::Local, Vec<PerLocalVarDebugInfo<'tcx, Bx::DIVariable>>>>,\n \n     /// Caller location propagated if this function has `#[track_caller]`.\n     caller_location: Option<OperandRef<'tcx, Bx::Value>>,\n@@ -178,10 +179,12 @@ pub fn codegen_mir<'a, 'tcx, Bx: BuilderMethods<'a, 'tcx>>(\n         funclets,\n         locals: IndexVec::new(),\n         debug_context,\n-        per_local_var_debug_info: debuginfo::per_local_var_debug_info(cx.tcx(), mir_body),\n+        per_local_var_debug_info: None,\n         caller_location: None,\n     };\n \n+    fx.per_local_var_debug_info = fx.compute_per_local_var_debug_info();\n+\n     let memory_locals = analyze::non_ssa_locals(&fx);\n \n     // Allocate variable and temp allocas"}, {"sha": "7b22961cd46e2797db0ab7611d8b37dfca0b3a8b", "filename": "src/librustc_codegen_ssa/traits/backend.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/bdd946df3a7af6be0c075d5ab15f9845b3679364/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbackend.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdd946df3a7af6be0c075d5ab15f9845b3679364/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbackend.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbackend.rs?ref=bdd946df3a7af6be0c075d5ab15f9845b3679364", "patch": "@@ -21,7 +21,10 @@ pub trait BackendTypes {\n     type Type: CodegenObject;\n     type Funclet;\n \n+    // FIXME(eddyb) find a common convention for all of the debuginfo-related\n+    // names (choose between `Dbg`, `Debug`, `DebugInfo`, `DI` etc.).\n     type DIScope: Copy;\n+    type DIVariable: Copy;\n }\n \n pub trait Backend<'tcx>:"}, {"sha": "b3c830eef86980e2c3253f5bfb75718a03e4fc28", "filename": "src/librustc_codegen_ssa/traits/builder.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bdd946df3a7af6be0c075d5ab15f9845b3679364/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdd946df3a7af6be0c075d5ab15f9845b3679364/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fbuilder.rs?ref=bdd946df3a7af6be0c075d5ab15f9845b3679364", "patch": "@@ -28,7 +28,7 @@ pub enum OverflowOp {\n \n pub trait BuilderMethods<'a, 'tcx>:\n     HasCodegen<'tcx>\n-    + DebugInfoBuilderMethods<'tcx>\n+    + DebugInfoBuilderMethods\n     + ArgAbiMethods<'tcx>\n     + AbiBuilderMethods<'tcx>\n     + IntrinsicCallMethods<'tcx>"}, {"sha": "22a4e96b9e4bf2fb8bb8ea3fc35d167bab791376", "filename": "src/librustc_codegen_ssa/traits/debuginfo.rs", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/bdd946df3a7af6be0c075d5ab15f9845b3679364/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdebuginfo.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdd946df3a7af6be0c075d5ab15f9845b3679364/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdebuginfo.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fdebuginfo.rs?ref=bdd946df3a7af6be0c075d5ab15f9845b3679364", "patch": "@@ -30,20 +30,32 @@ pub trait DebugInfoMethods<'tcx>: BackendTypes {\n         defining_crate: CrateNum,\n     ) -> Self::DIScope;\n     fn debuginfo_finalize(&self);\n-}\n \n-pub trait DebugInfoBuilderMethods<'tcx>: BackendTypes {\n-    fn declare_local(\n-        &mut self,\n+    // FIXME(eddyb) find a common convention for all of the debuginfo-related\n+    // names (choose between `dbg`, `debug`, `debuginfo`, `debug_info` etc.).\n+    fn create_dbg_var(\n+        &self,\n         dbg_context: &FunctionDebugContext<Self::DIScope>,\n         variable_name: Name,\n         variable_type: Ty<'tcx>,\n         scope_metadata: Self::DIScope,\n+        variable_kind: VariableKind,\n+        span: Span,\n+    ) -> Self::DIVariable;\n+}\n+\n+pub trait DebugInfoBuilderMethods: BackendTypes {\n+    // FIXME(eddyb) find a common convention for all of the debuginfo-related\n+    // names (choose between `dbg`, `debug`, `debuginfo`, `debug_info` etc.).\n+    fn dbg_var_addr(\n+        &mut self,\n+        dbg_context: &FunctionDebugContext<Self::DIScope>,\n+        dbg_var: Self::DIVariable,\n+        scope_metadata: Self::DIScope,\n         variable_alloca: Self::Value,\n         direct_offset: Size,\n         // NB: each offset implies a deref (i.e. they're steps in a pointer chain).\n         indirect_offsets: &[Size],\n-        variable_kind: VariableKind,\n         span: Span,\n     );\n     fn set_source_location("}, {"sha": "b8afadaadef38b163a2e5a6445bb9879a1bf2826", "filename": "src/librustc_codegen_ssa/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/bdd946df3a7af6be0c075d5ab15f9845b3679364/src%2Flibrustc_codegen_ssa%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bdd946df3a7af6be0c075d5ab15f9845b3679364/src%2Flibrustc_codegen_ssa%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Ftraits%2Fmod.rs?ref=bdd946df3a7af6be0c075d5ab15f9845b3679364", "patch": "@@ -93,5 +93,6 @@ pub trait HasCodegen<'tcx>:\n             Type = Self::Type,\n             Funclet = Self::Funclet,\n             DIScope = Self::DIScope,\n+            DIVariable = Self::DIVariable,\n         >;\n }"}]}