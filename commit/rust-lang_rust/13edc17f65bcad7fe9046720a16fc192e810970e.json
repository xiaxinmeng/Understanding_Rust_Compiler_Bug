{"sha": "13edc17f65bcad7fe9046720a16fc192e810970e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEzZWRjMTdmNjViY2FkN2ZlOTA0NjcyMGExNmZjMTkyZTgxMDk3MGU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-30T07:54:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-08-30T07:54:11Z"}, "message": "Auto merge of #88281 - asquared31415:asm-docs, r=Amanieu\n\nUpdate unstable docs for `asm!` macro\n\nThis adds documentation that SPIR-V is supported, expands on the restrictions for labels, and has some minor cleanups or clarifications.\n\nr? `@joshtriplett`", "tree": {"sha": "dbf21b28efc774339ca632975adfac65dcb7e3f9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/dbf21b28efc774339ca632975adfac65dcb7e3f9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/13edc17f65bcad7fe9046720a16fc192e810970e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/13edc17f65bcad7fe9046720a16fc192e810970e", "html_url": "https://github.com/rust-lang/rust/commit/13edc17f65bcad7fe9046720a16fc192e810970e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/13edc17f65bcad7fe9046720a16fc192e810970e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "dbb0fe9d803f7fa8688b33306266a6b054c2c3f4", "url": "https://api.github.com/repos/rust-lang/rust/commits/dbb0fe9d803f7fa8688b33306266a6b054c2c3f4", "html_url": "https://github.com/rust-lang/rust/commit/dbb0fe9d803f7fa8688b33306266a6b054c2c3f4"}, {"sha": "8769b99ef098f3e7e899800f9dcf5accd5e1320a", "url": "https://api.github.com/repos/rust-lang/rust/commits/8769b99ef098f3e7e899800f9dcf5accd5e1320a", "html_url": "https://github.com/rust-lang/rust/commit/8769b99ef098f3e7e899800f9dcf5accd5e1320a"}], "stats": {"total": 39, "additions": 20, "deletions": 19}, "files": [{"sha": "4715388408fed9e05a041f845b60a8fb67f2c0c9", "filename": "src/doc/unstable-book/src/library-features/asm.md", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/13edc17f65bcad7fe9046720a16fc192e810970e/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fasm.md", "raw_url": "https://github.com/rust-lang/rust/raw/13edc17f65bcad7fe9046720a16fc192e810970e/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fasm.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fasm.md?ref=13edc17f65bcad7fe9046720a16fc192e810970e", "patch": "@@ -31,6 +31,7 @@ Inline assembly is currently supported on the following architectures:\n - MIPS32r2 and MIPS64r2\n - wasm32\n - BPF\n+- SPIR-V\n \n ## Basic usage\n \n@@ -188,8 +189,7 @@ As you can see, this assembly fragment will still work correctly if `a` and `b`\n \n Some instructions require that the operands be in a specific register.\n Therefore, Rust inline assembly provides some more specific constraint specifiers.\n-While `reg` is generally available on any architecture, these are highly architecture specific. E.g. for x86 the general purpose registers `eax`, `ebx`, `ecx`, `edx`, `ebp`, `esi`, and `edi`\n-among others can be addressed by their name.\n+While `reg` is generally available on any architecture, explicit registers are highly architecture specific. E.g. for x86 the general purpose registers `eax`, `ebx`, `ecx`, `edx`, `ebp`, `esi`, and `edi` among others can be addressed by their name.\n \n ```rust,allow_fail,no_run\n #![feature(asm)]\n@@ -199,11 +199,9 @@ unsafe {\n }\n ```\n \n-In this example we call the `out` instruction to output the content of the `cmd` variable\n-to port `0x64`. Since the `out` instruction only accepts `eax` (and its sub registers) as operand\n-we had to use the `eax` constraint specifier.\n+In this example we call the `out` instruction to output the content of the `cmd` variable to port `0x64`. Since the `out` instruction only accepts `eax` (and its sub registers) as operand we had to use the `eax` constraint specifier.\n \n-Note that unlike other operand types, explicit register operands cannot be used in the template string: you can't use `{}` and should write the register name directly instead. Also, they must appear at the end of the operand list after all other operand types.\n+> **Note**: unlike other operand types, explicit register operands cannot be used in the template string: you can't use `{}` and should write the register name directly instead. Also, they must appear at the end of the operand list after all other operand types.\n \n Consider this example which uses the x86 `mul` instruction:\n \n@@ -237,11 +235,9 @@ The higher 64 bits are stored in `rdx` from which we fill the variable `hi`.\n ## Clobbered registers\n \n In many cases inline assembly will modify state that is not needed as an output.\n-Usually this is either because we have to use a scratch register in the assembly,\n-or instructions modify state that we don't need to further examine.\n+Usually this is either because we have to use a scratch register in the assembly or because instructions modify state that we don't need to further examine.\n This state is generally referred to as being \"clobbered\".\n-We need to tell the compiler about this since it may need to save and restore this state\n-around the inline assembly block.\n+We need to tell the compiler about this since it may need to save and restore this state around the inline assembly block.\n \n ```rust,allow_fail\n #![feature(asm)]\n@@ -321,8 +317,7 @@ fn call_foo(arg: i32) -> i32 {\n }\n ```\n \n-Note that the `fn` or `static` item does not need to be public or `#[no_mangle]`:\n-the compiler will automatically insert the appropriate mangled symbol name into the assembly code.\n+Note that the `fn` or `static` item does not need to be public or `#[no_mangle]`: the compiler will automatically insert the appropriate mangled symbol name into the assembly code.\n \n By default, `asm!` assumes that any register not specified as an output will have its contents preserved by the assembly code. The [`clobber_abi`](#abi-clobbers) argument to `asm!` tells the compiler to automatically insert the necessary clobber operands according to the given calling convention ABI: any register which is not fully preserved in that ABI will be treated as clobbered.\n \n@@ -355,9 +350,8 @@ If you use a smaller data type (e.g. `u16`) with an operand and forget the use t\n ## Memory address operands\n \n Sometimes assembly instructions require operands passed via memory addresses/memory locations.\n-You have to manually use the memory address syntax specified by the respectively architectures.\n-For example, in x86/x86_64 and intel assembly syntax, you should wrap inputs/outputs in `[]`\n-to indicate they are memory operands:\n+You have to manually use the memory address syntax specified by the target architecture.\n+For example, on x86/x86_64 using intel assembly syntax, you should wrap inputs/outputs in `[]` to indicate they are memory operands:\n \n ```rust,allow_fail\n #![feature(asm, llvm_asm)]\n@@ -373,9 +367,15 @@ unsafe {\n \n ## Labels\n \n-The compiler is allowed to instantiate multiple copies an `asm!` block, for example when the function containing it is inlined in multiple places. As a consequence, you should only use GNU assembler [local labels] inside inline assembly code. Defining symbols in assembly code may lead to assembler and/or linker errors due to duplicate symbol definitions.\n+Any reuse of a named label, local or otherwise, can result in a assembler or linker error or may cause other strange behavior. Reuse of a named label can happen in a variety of ways including:\n \n-Moreover, due to [an llvm bug], you shouldn't use labels exclusively made of `0` and `1` digits, e.g. `0`, `11` or `101010`, as they may end up being interpreted as binary values.\n+-   explicitly: using a label more than once in one `asm!` block, or multiple times across blocks\n+-   implicitly via inlining: the compiler is allowed to instantiate multiple copies of an `asm!` block, for example when the function containing it is inlined in multiple places.\n+-   implicitly via LTO: LTO can cause code from *other crates* to be placed in the same codegen unit, and so could bring in arbitrary labels\n+\n+As a consequence, you should only use GNU assembler **numeric** [local labels] inside inline assembly code. Defining symbols in assembly code may lead to assembler and/or linker errors due to duplicate symbol definitions.\n+\n+Moreover, on x86 when using the default intel syntax, due to [an llvm bug], you shouldn't use labels exclusively made of `0` and `1` digits, e.g. `0`, `11` or `101010`, as they may end up being interpreted as binary values. Using `option(att_syntax)` will avoid any ambiguity, but that affects the syntax of the _entire_ `asm!` block.\n \n ```rust,allow_fail\n #![feature(asm)]\n@@ -410,7 +410,7 @@ Second, that when a numeric label is used as a reference (as an instruction oper\n \n ## Options\n \n-By default, an inline assembly block is treated the same way as an external FFI function call with a custom calling convention: it may read/write memory, have observable side effects, etc. However in many cases, it is desirable to give the compiler more information about what the assembly code is actually doing so that it can optimize better.\n+By default, an inline assembly block is treated the same way as an external FFI function call with a custom calling convention: it may read/write memory, have observable side effects, etc. However, in many cases it is desirable to give the compiler more information about what the assembly code is actually doing so that it can optimize better.\n \n Let's take our previous example of an `add` instruction:\n \n@@ -470,6 +470,7 @@ Inline assembly is currently supported on the following architectures:\n - MIPS32r2 and MIPS64r2\n - wasm32\n - BPF\n+- SPIR-V\n \n Support for more targets may be added in the future. The compiler will emit an error if `asm!` is used on an unsupported target.\n \n@@ -836,7 +837,7 @@ The compiler performs some additional checks on options:\n   - Note that a `lateout` may be allocated to the same register as an `in`, in which case this rule does not apply. Code should not rely on this however since it depends on the results of register allocation.\n - Behavior is undefined if execution unwinds out of an asm block.\n   - This also applies if the assembly code calls a function which then unwinds.\n-- The set of memory locations that assembly code is allowed the read and write are the same as those allowed for an FFI function.\n+- The set of memory locations that assembly code is allowed to read and write are the same as those allowed for an FFI function.\n   - Refer to the unsafe code guidelines for the exact rules.\n   - If the `readonly` option is set, then only memory reads are allowed.\n   - If the `nomem` option is set then no reads or writes to memory are allowed."}]}