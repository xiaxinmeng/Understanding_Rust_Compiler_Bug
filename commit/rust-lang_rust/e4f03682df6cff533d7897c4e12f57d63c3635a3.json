{"sha": "e4f03682df6cff533d7897c4e12f57d63c3635a3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU0ZjAzNjgyZGY2Y2ZmNTMzZDc4OTdjNGUxMmY1N2Q2M2MzNjM1YTM=", "commit": {"author": {"name": "Eh2406", "email": "YeomanYaacov@gmail.com", "date": "2018-06-27T20:25:41Z"}, "committer": {"name": "Eh2406", "email": "YeomanYaacov@gmail.com", "date": "2018-06-28T14:18:25Z"}, "message": "use the type system to ensure we dedup from the start", "tree": {"sha": "b9d3bdb30f40c43db0a1c6fce9bb7b2bb433e10f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b9d3bdb30f40c43db0a1c6fce9bb7b2bb433e10f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e4f03682df6cff533d7897c4e12f57d63c3635a3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e4f03682df6cff533d7897c4e12f57d63c3635a3", "html_url": "https://github.com/rust-lang/rust/commit/e4f03682df6cff533d7897c4e12f57d63c3635a3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e4f03682df6cff533d7897c4e12f57d63c3635a3/comments", "author": {"login": "Eh2406", "id": 3709504, "node_id": "MDQ6VXNlcjM3MDk1MDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3709504?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Eh2406", "html_url": "https://github.com/Eh2406", "followers_url": "https://api.github.com/users/Eh2406/followers", "following_url": "https://api.github.com/users/Eh2406/following{/other_user}", "gists_url": "https://api.github.com/users/Eh2406/gists{/gist_id}", "starred_url": "https://api.github.com/users/Eh2406/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Eh2406/subscriptions", "organizations_url": "https://api.github.com/users/Eh2406/orgs", "repos_url": "https://api.github.com/users/Eh2406/repos", "events_url": "https://api.github.com/users/Eh2406/events{/privacy}", "received_events_url": "https://api.github.com/users/Eh2406/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Eh2406", "id": 3709504, "node_id": "MDQ6VXNlcjM3MDk1MDQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3709504?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Eh2406", "html_url": "https://github.com/Eh2406", "followers_url": "https://api.github.com/users/Eh2406/followers", "following_url": "https://api.github.com/users/Eh2406/following{/other_user}", "gists_url": "https://api.github.com/users/Eh2406/gists{/gist_id}", "starred_url": "https://api.github.com/users/Eh2406/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Eh2406/subscriptions", "organizations_url": "https://api.github.com/users/Eh2406/orgs", "repos_url": "https://api.github.com/users/Eh2406/repos", "events_url": "https://api.github.com/users/Eh2406/events{/privacy}", "received_events_url": "https://api.github.com/users/Eh2406/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0119669711af204d1205cf64fed11f5ad3c1bbdd", "url": "https://api.github.com/repos/rust-lang/rust/commits/0119669711af204d1205cf64fed11f5ad3c1bbdd", "html_url": "https://github.com/rust-lang/rust/commit/0119669711af204d1205cf64fed11f5ad3c1bbdd"}], "stats": {"total": 103, "additions": 60, "deletions": 43}, "files": [{"sha": "4b0a0c9bce9aad5671728a7764911e88ba2271e7", "filename": "src/librustc_mir/borrow_check/nll/constraint_set.rs", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/e4f03682df6cff533d7897c4e12f57d63c3635a3/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4f03682df6cff533d7897c4e12f57d63c3635a3/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_set.rs?ref=e4f03682df6cff533d7897c4e12f57d63c3635a3", "patch": "@@ -0,0 +1,33 @@\n+use borrow_check::nll::region_infer::{ConstraintIndex, OutlivesConstraint};\n+use rustc_data_structures::indexed_vec::IndexVec;\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc::ty::RegionVid;\n+\n+#[derive(Clone, Default)]\n+crate struct ConstraintSet {\n+    constraints: IndexVec<ConstraintIndex, OutlivesConstraint>,\n+    seen_constraints: FxHashSet<(RegionVid, RegionVid)>,\n+}\n+\n+impl ConstraintSet {\n+    pub fn push(&mut self, outlives_constraint: OutlivesConstraint) {\n+        debug!(\"add_outlives({:?}: {:?} @ {:?}\", outlives_constraint.sup, outlives_constraint.sub, outlives_constraint.point);\n+        if outlives_constraint.sup == outlives_constraint.sub {\n+            // 'a: 'a is pretty uninteresting\n+            return;\n+        }\n+        if self.seen_constraints.insert(outlives_constraint.dedup_key()) {\n+            self.constraints.push(outlives_constraint);\n+        }\n+    }\n+\n+    pub fn iner(&self) -> &IndexVec<ConstraintIndex, OutlivesConstraint> {\n+        &self.constraints\n+    }\n+\n+    /// Do Not use this to add nor remove items to the Vec, nor change the `sup`, nor `sub` of the data.\n+    pub fn iner_mut(&mut self) -> &mut IndexVec<ConstraintIndex, OutlivesConstraint> {\n+        &mut self.constraints\n+    }\n+}\n+"}, {"sha": "07b160ed66f8ac9da1573dbdb7aacdbb23e75459", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4f03682df6cff533d7897c4e12f57d63c3635a3/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4f03682df6cff533d7897c4e12f57d63c3635a3/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=e4f03682df6cff533d7897c4e12f57d63c3635a3", "patch": "@@ -45,6 +45,8 @@ mod renumber;\n crate mod type_check;\n mod universal_regions;\n \n+crate mod constraint_set;\n+\n use self::facts::AllFacts;\n use self::region_infer::RegionInferenceContext;\n use self::universal_regions::UniversalRegions;"}, {"sha": "7c17f6a1aeb89e340899af1bcde23b5be8b09ab8", "filename": "src/librustc_mir/borrow_check/nll/region_infer/dump_mir.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4f03682df6cff533d7897c4e12f57d63c3635a3/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdump_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4f03682df6cff533d7897c4e12f57d63c3635a3/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdump_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fdump_mir.rs?ref=e4f03682df6cff533d7897c4e12f57d63c3635a3", "patch": "@@ -76,7 +76,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             }\n         }\n \n-        let mut constraints: Vec<_> = self.constraints.iter().collect();\n+        let mut constraints: Vec<_> = self.constraints.iner().iter().collect();\n         constraints.sort();\n         for constraint in &constraints {\n             let OutlivesConstraint {"}, {"sha": "ad15a4353593288c666d3e9860c8b1ccdcace628", "filename": "src/librustc_mir/borrow_check/nll/region_infer/graphviz.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e4f03682df6cff533d7897c4e12f57d63c3635a3/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4f03682df6cff533d7897c4e12f57d63c3635a3/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fgraphviz.rs?ref=e4f03682df6cff533d7897c4e12f57d63c3635a3", "patch": "@@ -55,7 +55,7 @@ impl<'this, 'tcx> dot::GraphWalk<'this> for RegionInferenceContext<'tcx> {\n         vids.into_cow()\n     }\n     fn edges(&'this self) -> dot::Edges<'this, OutlivesConstraint> {\n-        (&self.constraints.raw[..]).into_cow()\n+        (&self.constraints.iner().raw[..]).into_cow()\n     }\n \n     // Render `a: b` as `a <- b`, indicating the flow"}, {"sha": "5da486815e16176003b8a21d02dc63f9248dc1b6", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 17, "deletions": 37, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/e4f03682df6cff533d7897c4e12f57d63c3635a3/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4f03682df6cff533d7897c4e12f57d63c3635a3/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=e4f03682df6cff533d7897c4e12f57d63c3635a3", "patch": "@@ -10,6 +10,7 @@\n \n use super::universal_regions::UniversalRegions;\n use borrow_check::nll::region_infer::values::ToElementIndex;\n+use borrow_check::nll::constraint_set::ConstraintSet;\n use rustc::hir::def_id::DefId;\n use rustc::infer::canonical::QueryRegionConstraint;\n use rustc::infer::error_reporting::nice_region_error::NiceRegionError;\n@@ -24,7 +25,6 @@ use rustc::mir::{\n use rustc::ty::{self, RegionVid, Ty, TyCtxt, TypeFoldable};\n use rustc::util::common::{self, ErrorReported};\n use rustc_data_structures::bitvec::BitVector;\n-use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use std::fmt;\n use std::rc::Rc;\n@@ -66,8 +66,7 @@ pub struct RegionInferenceContext<'tcx> {\n     dependency_map: Option<IndexVec<RegionVid, Option<ConstraintIndex>>>,\n \n     /// The constraints we have accumulated and used during solving.\n-    constraints: IndexVec<ConstraintIndex, OutlivesConstraint>,\n-    seen_constraints: FxHashSet<(RegionVid, RegionVid)>,\n+    constraints: ConstraintSet,\n \n     /// Type constraints that we check after solving.\n     type_tests: Vec<TypeTest<'tcx>>,\n@@ -146,7 +145,7 @@ pub struct OutlivesConstraint {\n }\n \n impl OutlivesConstraint {\n-    fn dedup_key(&self) -> (RegionVid, RegionVid) {\n+    pub fn dedup_key(&self) -> (RegionVid, RegionVid) {\n         (self.sup, self.sub)\n     }\n }\n@@ -251,11 +250,11 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         var_infos: VarInfos,\n         universal_regions: UniversalRegions<'tcx>,\n         mir: &Mir<'tcx>,\n-        mut outlives_constraints: Vec<OutlivesConstraint>,\n+        outlives_constraints: ConstraintSet,\n         type_tests: Vec<TypeTest<'tcx>>,\n     ) -> Self {\n         // The `next` field should not yet have been initialized:\n-        debug_assert!(outlives_constraints.iter().all(|c| c.next.is_none()));\n+        debug_assert!(outlives_constraints.iner().iter().all(|c| c.next.is_none()));\n \n         let num_region_variables = var_infos.len();\n         let num_universal_regions = universal_regions.len();\n@@ -268,18 +267,13 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             .map(|info| RegionDefinition::new(info.origin))\n             .collect();\n \n-        let mut seen_constraints: FxHashSet<(RegionVid, RegionVid)> = Default::default();\n-\n-        outlives_constraints.retain(|c| c.sup != c.sub && seen_constraints.insert(c.dedup_key()));\n-\n         let mut result = Self {\n             definitions,\n             elements: elements.clone(),\n             liveness_constraints: RegionValues::new(elements, num_region_variables),\n             inferred_values: None,\n             dependency_map: None,\n-            constraints: IndexVec::from_raw(outlives_constraints),\n-            seen_constraints,\n+            constraints: outlives_constraints,\n             type_tests,\n             universal_regions,\n         };\n@@ -405,7 +399,8 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         sub: RegionVid,\n         point: Location,\n     ) {\n-        self.add_outlives_iner(OutlivesConstraint {\n+        assert!(self.inferred_values.is_none(), \"values already inferred\");\n+        self.constraints.push(OutlivesConstraint {\n             span,\n             sup,\n             sub,\n@@ -414,22 +409,6 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         })\n     }\n \n-    /// Indicates that the region variable `sup` must outlive `sub` is live at the point `point`.\n-    fn add_outlives_iner(\n-        &mut self,\n-        outlives_constraint: OutlivesConstraint\n-    ) {\n-        debug!(\"add_outlives({:?}: {:?} @ {:?}\", outlives_constraint.sup, outlives_constraint.sub, outlives_constraint.point);\n-        assert!(self.inferred_values.is_none(), \"values already inferred\");\n-        if outlives_constraint.sup == outlives_constraint.sub {\n-            // 'a: 'a is pretty uninteresting\n-            return;\n-        }\n-        if self.seen_constraints.insert(outlives_constraint.dedup_key()) {\n-            self.constraints.push(outlives_constraint);\n-        }\n-    }\n-\n     /// Perform region inference and report errors if we see any\n     /// unsatisfiable constraints. If this is a closure, returns the\n     /// region requirements to propagate to our creator, if any.\n@@ -497,7 +476,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     fn compute_region_values(&self, _mir: &Mir<'tcx>) -> RegionValues {\n         debug!(\"compute_region_values()\");\n         debug!(\"compute_region_values: constraints={:#?}\", {\n-            let mut constraints: Vec<_> = self.constraints.iter().collect();\n+            let mut constraints: Vec<_> = self.constraints.iner().iter().collect();\n             constraints.sort();\n             constraints\n         });\n@@ -509,7 +488,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         let dependency_map = self.dependency_map.as_ref().unwrap();\n \n         // Constraints that may need to be repropagated (initially all):\n-        let mut dirty_list: Vec<_> = self.constraints.indices().collect();\n+        let mut dirty_list: Vec<_> = self.constraints.iner().indices().collect();\n \n         // Set to 0 for each constraint that is on the dirty list:\n         let mut clean_bit_vec = BitVector::new(dirty_list.len());\n@@ -518,7 +497,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         while let Some(constraint_idx) = dirty_list.pop() {\n             clean_bit_vec.insert(constraint_idx.index());\n \n-            let constraint = &self.constraints[constraint_idx];\n+            let constraint = &self.constraints.iner()[constraint_idx];\n             debug!(\"propagate_constraints: constraint={:?}\", constraint);\n \n             if inferred_values.add_region(constraint.sup, constraint.sub) {\n@@ -530,7 +509,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                     if clean_bit_vec.remove(dep_idx.index()) {\n                         dirty_list.push(dep_idx);\n                     }\n-                    opt_dep_idx = self.constraints[dep_idx].next;\n+                    opt_dep_idx = self.constraints.iner()[dep_idx].next;\n                 }\n             }\n \n@@ -547,7 +526,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     fn build_dependency_map(&mut self) -> IndexVec<RegionVid, Option<ConstraintIndex>> {\n         let mut map = IndexVec::from_elem(None, &self.definitions);\n \n-        for (idx, constraint) in self.constraints.iter_enumerated_mut().rev() {\n+        for (idx, constraint) in self.constraints.iner_mut().iter_enumerated_mut().rev() {\n             let mut head = &mut map[constraint.sub];\n             debug_assert!(constraint.next.is_none());\n             constraint.next = *head;\n@@ -995,7 +974,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             );\n \n             let blame_index = self.blame_constraint(longer_fr, shorter_fr);\n-            let blame_span = self.constraints[blame_index].span;\n+            let blame_span = self.constraints.iner()[blame_index].span;\n \n             if let Some(propagated_outlives_requirements) = propagated_outlives_requirements {\n                 // Shrink `fr` until we find a non-local region (if we do).\n@@ -1086,7 +1065,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // - `fr1: X` transitively\n         // - and `Y` is live at `elem`\n         let index = self.blame_constraint(fr1, elem);\n-        let region_sub = self.constraints[index].sub;\n+        let region_sub = self.constraints.iner()[index].sub;\n \n         // then return why `Y` was live at `elem`\n         self.liveness_constraints.cause(region_sub, elem)\n@@ -1107,6 +1086,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // of dependencies, which doesn't account for the locations of\n         // contraints at all. But it will do for now.\n         let relevant_constraint = self.constraints\n+            .iner()\n             .iter_enumerated()\n             .filter_map(|(i, constraint)| {\n                 if !self.liveness_constraints.contains(constraint.sub, elem) {\n@@ -1142,7 +1122,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         while changed {\n             changed = false;\n-            for constraint in &self.constraints {\n+            for constraint in self.constraints.iner() {\n                 if let Some(n) = result_set[constraint.sup] {\n                     let m = n + 1;\n                     if result_set[constraint.sub]"}, {"sha": "263dd334e785e57bcd914cccc39f56f23b37615c", "filename": "src/librustc_mir/borrow_check/nll/type_check/constraint_conversion.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e4f03682df6cff533d7897c4e12f57d63c3635a3/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4f03682df6cff533d7897c4e12f57d63c3635a3/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fconstraint_conversion.rs?ref=e4f03682df6cff533d7897c4e12f57d63c3635a3", "patch": "@@ -13,6 +13,7 @@ use borrow_check::nll::facts::AllFacts;\n use borrow_check::nll::region_infer::{OutlivesConstraint, RegionTest, TypeTest};\n use borrow_check::nll::type_check::Locations;\n use borrow_check::nll::universal_regions::UniversalRegions;\n+use borrow_check::nll::constraint_set::ConstraintSet;\n use rustc::infer::canonical::QueryRegionConstraint;\n use rustc::infer::outlives::obligations::{TypeOutlives, TypeOutlivesDelegate};\n use rustc::infer::region_constraints::{GenericKind, VerifyBound};\n@@ -31,7 +32,7 @@ crate struct ConstraintConversion<'a, 'gcx: 'tcx, 'tcx: 'a> {\n     implicit_region_bound: Option<ty::Region<'tcx>>,\n     param_env: ty::ParamEnv<'tcx>,\n     locations: Locations,\n-    outlives_constraints: &'a mut Vec<OutlivesConstraint>,\n+    outlives_constraints: &'a mut ConstraintSet,\n     type_tests: &'a mut Vec<TypeTest<'tcx>>,\n     all_facts: &'a mut Option<AllFacts>,\n }\n@@ -46,7 +47,7 @@ impl<'a, 'gcx, 'tcx> ConstraintConversion<'a, 'gcx, 'tcx> {\n         implicit_region_bound: Option<ty::Region<'tcx>>,\n         param_env: ty::ParamEnv<'tcx>,\n         locations: Locations,\n-        outlives_constraints: &'a mut Vec<OutlivesConstraint>,\n+        outlives_constraints: &'a mut ConstraintSet,\n         type_tests: &'a mut Vec<TypeTest<'tcx>>,\n         all_facts: &'a mut Option<AllFacts>,\n     ) -> Self {"}, {"sha": "ee607ccae89744defcd16647e7d9045f5e9efc49", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/e4f03682df6cff533d7897c4e12f57d63c3635a3/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4f03682df6cff533d7897c4e12f57d63c3635a3/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=e4f03682df6cff533d7897c4e12f57d63c3635a3", "patch": "@@ -12,9 +12,10 @@\n #![allow(unreachable_code)]\n \n use borrow_check::location::LocationTable;\n+use borrow_check::nll::constraint_set::ConstraintSet;\n use borrow_check::nll::facts::AllFacts;\n use borrow_check::nll::region_infer::Cause;\n-use borrow_check::nll::region_infer::{ClosureRegionRequirementsExt, OutlivesConstraint, TypeTest};\n+use borrow_check::nll::region_infer::{ClosureRegionRequirementsExt, TypeTest};\n use borrow_check::nll::universal_regions::UniversalRegions;\n use dataflow::move_paths::MoveData;\n use dataflow::FlowAtLocation;\n@@ -621,7 +622,7 @@ crate struct MirTypeckRegionConstraints<'tcx> {\n     /// hence it must report on their liveness constraints.\n     crate liveness_set: Vec<(ty::Region<'tcx>, Location, Cause)>,\n \n-    crate outlives_constraints: Vec<OutlivesConstraint>,\n+    crate outlives_constraints: ConstraintSet,\n \n     crate type_tests: Vec<TypeTest<'tcx>>,\n }"}]}