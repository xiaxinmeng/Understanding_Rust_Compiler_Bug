{"sha": "03c660633fbac0492f891aed6c47731be90f23ca", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAzYzY2MDYzM2ZiYWMwNDkyZjg5MWFlZDZjNDc3MzFiZTkwZjIzY2E=", "commit": {"author": {"name": "Marcus Klaas", "email": "mail@marcusklaas.nl", "date": "2015-09-09T21:17:31Z"}, "committer": {"name": "Marcus Klaas", "email": "mail@marcusklaas.nl", "date": "2015-09-10T22:53:01Z"}, "message": "Refine chain breaking heuristics\n\nDon't make a single line chain when it is was multi line in the source; allow overflow of the last chain element onto the next lines without breaking the chain.", "tree": {"sha": "ac75b88327aede5814f4afaab1da72a446a8362f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ac75b88327aede5814f4afaab1da72a446a8362f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/03c660633fbac0492f891aed6c47731be90f23ca", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/03c660633fbac0492f891aed6c47731be90f23ca", "html_url": "https://github.com/rust-lang/rust/commit/03c660633fbac0492f891aed6c47731be90f23ca", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/03c660633fbac0492f891aed6c47731be90f23ca/comments", "author": {"login": "marcusklaas", "id": 1255413, "node_id": "MDQ6VXNlcjEyNTU0MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1255413?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marcusklaas", "html_url": "https://github.com/marcusklaas", "followers_url": "https://api.github.com/users/marcusklaas/followers", "following_url": "https://api.github.com/users/marcusklaas/following{/other_user}", "gists_url": "https://api.github.com/users/marcusklaas/gists{/gist_id}", "starred_url": "https://api.github.com/users/marcusklaas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marcusklaas/subscriptions", "organizations_url": "https://api.github.com/users/marcusklaas/orgs", "repos_url": "https://api.github.com/users/marcusklaas/repos", "events_url": "https://api.github.com/users/marcusklaas/events{/privacy}", "received_events_url": "https://api.github.com/users/marcusklaas/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marcusklaas", "id": 1255413, "node_id": "MDQ6VXNlcjEyNTU0MTM=", "avatar_url": "https://avatars.githubusercontent.com/u/1255413?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marcusklaas", "html_url": "https://github.com/marcusklaas", "followers_url": "https://api.github.com/users/marcusklaas/followers", "following_url": "https://api.github.com/users/marcusklaas/following{/other_user}", "gists_url": "https://api.github.com/users/marcusklaas/gists{/gist_id}", "starred_url": "https://api.github.com/users/marcusklaas/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marcusklaas/subscriptions", "organizations_url": "https://api.github.com/users/marcusklaas/orgs", "repos_url": "https://api.github.com/users/marcusklaas/repos", "events_url": "https://api.github.com/users/marcusklaas/events{/privacy}", "received_events_url": "https://api.github.com/users/marcusklaas/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "48d17f54d34c5457e88ef7ffa234601c6e342a70", "url": "https://api.github.com/repos/rust-lang/rust/commits/48d17f54d34c5457e88ef7ffa234601c6e342a70", "html_url": "https://github.com/rust-lang/rust/commit/48d17f54d34c5457e88ef7ffa234601c6e342a70"}], "stats": {"total": 563, "additions": 356, "deletions": 207}, "files": [{"sha": "bd9f302824bed9d17352ffef4f0913faec92369e", "filename": "src/chains.rs", "status": "modified", "additions": 69, "deletions": 20, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/03c660633fbac0492f891aed6c47731be90f23ca/src%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03c660633fbac0492f891aed6c47731be90f23ca/src%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fchains.rs?ref=03c660633fbac0492f891aed6c47731be90f23ca", "patch": "@@ -20,7 +20,7 @@\n // argument function argument strategy.\n \n use rewrite::{Rewrite, RewriteContext};\n-use utils::make_indent;\n+use utils::{first_line_width, make_indent};\n use expr::rewrite_call;\n \n use syntax::{ast, ptr};\n@@ -51,19 +51,67 @@ pub fn rewrite_chain(mut expr: &ast::Expr,\n     let indent = offset + extra_indent;\n \n     let max_width = try_opt!(width.checked_sub(extra_indent));\n-    let rewrites = try_opt!(subexpr_list.into_iter()\n-                                        .rev()\n-                                        .map(|e| {\n-                                            rewrite_chain_expr(e,\n-                                                               total_span,\n-                                                               context,\n-                                                               max_width,\n-                                                               indent)\n-                                        })\n-                                        .collect::<Option<Vec<_>>>());\n-\n-    let total_width = rewrites.iter().fold(0, |a, b| a + b.len()) + parent_rewrite.len();\n-    let fits_single_line = total_width <= width && rewrites.iter().all(|s| !s.contains('\\n'));\n+    let mut rewrites = try_opt!(subexpr_list.iter()\n+                                            .rev()\n+                                            .map(|e| {\n+                                                rewrite_chain_expr(e,\n+                                                                   total_span,\n+                                                                   context,\n+                                                                   max_width,\n+                                                                   indent)\n+                                            })\n+                                            .collect::<Option<Vec<_>>>());\n+\n+    // Total of all items excluding the last.\n+    let almost_total = rewrites.split_last()\n+                               .unwrap()\n+                               .1\n+                               .iter()\n+                               .fold(0, |a, b| a + first_line_width(b)) +\n+                       parent_rewrite.len();\n+    let total_width = almost_total + first_line_width(rewrites.last().unwrap());\n+    let veto_single_line = if context.config.take_source_hints && subexpr_list.len() > 1 {\n+        // Look at the source code. Unless all chain elements start on the same\n+        // line, we won't consider putting them on a single line either.\n+        let first_line_no = context.codemap.lookup_char_pos(subexpr_list[0].span.lo).line;\n+\n+        subexpr_list[1..]\n+            .iter()\n+            .any(|ex| context.codemap.lookup_char_pos(ex.span.hi).line != first_line_no)\n+    } else {\n+        false\n+    };\n+\n+    let fits_single_line = !veto_single_line &&\n+                           match subexpr_list[0].node {\n+        ast::Expr_::ExprMethodCall(ref method_name, ref types, ref expressions)\n+            if context.config.chains_overflow_last => {\n+            let (last, init) = rewrites.split_last_mut().unwrap();\n+\n+            if init.iter().all(|s| !s.contains('\\n')) && total_width <= width {\n+                let last_rewrite = width.checked_sub(almost_total)\n+                                        .and_then(|inner_width| {\n+                                            rewrite_method_call(method_name.node,\n+                                                                types,\n+                                                                expressions,\n+                                                                total_span,\n+                                                                context,\n+                                                                inner_width,\n+                                                                offset + almost_total)\n+                                        });\n+                match last_rewrite {\n+                    Some(mut string) => {\n+                        ::std::mem::swap(&mut string, last);\n+                        true\n+                    }\n+                    None => false,\n+                }\n+            } else {\n+                false\n+            }\n+        }\n+        _ => total_width <= width && rewrites.iter().all(|s| !s.contains('\\n')),\n+    };\n \n     let connector = if fits_single_line {\n         String::new()\n@@ -101,7 +149,11 @@ fn rewrite_chain_expr(expr: &ast::Expr,\n                       -> Option<String> {\n     match expr.node {\n         ast::Expr_::ExprMethodCall(ref method_name, ref types, ref expressions) => {\n-            rewrite_method_call(method_name.node, types, expressions, span, context, width, offset)\n+            let inner = &RewriteContext {\n+                block_indent: offset,\n+                ..*context\n+            };\n+            rewrite_method_call(method_name.node, types, expressions, span, inner, width, offset)\n         }\n         ast::Expr_::ExprField(_, ref field) => {\n             Some(format!(\".{}\", field.node))\n@@ -137,10 +189,7 @@ fn rewrite_method_call(method_name: ast::Ident,\n     };\n \n     let callee_str = format!(\".{}{}\", method_name, type_str);\n-    let inner_context = &RewriteContext {\n-        block_indent: offset,\n-        ..*context\n-    };\n+    let span = mk_sp(args[0].span.hi, span.hi);\n \n-    rewrite_call(inner_context, &callee_str, args, span, width, offset)\n+    rewrite_call(context, &callee_str, &args[1..], span, width, offset)\n }"}, {"sha": "d45f184051fc003a9f371b4f8892f7ace6dde37f", "filename": "src/config.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/03c660633fbac0492f891aed6c47731be90f23ca/src%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03c660633fbac0492f891aed6c47731be90f23ca/src%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fconfig.rs?ref=03c660633fbac0492f891aed6c47731be90f23ca", "patch": "@@ -133,8 +133,8 @@ create_config! {\n     fn_args_density: Density,\n     fn_args_layout: StructLitStyle,\n     fn_arg_indent: BlockIndentStyle,\n-    where_density: Density, // Should we at least try to put the where clause on the same line as\n-                            // the rest of the function decl?\n+    where_density: Density, // Should we at least try to put the where clause on\n+                            // the same line as the rest of the function decl?\n     where_indent: BlockIndentStyle, // Visual will be treated like Tabbed\n     where_layout: ListTactic,\n     where_pred_indent: BlockIndentStyle,\n@@ -147,14 +147,14 @@ create_config! {\n     report_todo: ReportTactic,\n     report_fixme: ReportTactic,\n     reorder_imports: bool, // Alphabetically, case sensitive.\n-    expr_indent_style: BlockIndentStyle,\n-    closure_indent_style: BlockIndentStyle,\n     single_line_if_else: bool,\n     format_strings: bool,\n+    chains_overflow_last: bool,\n+    take_source_hints: bool, // Retain some formatting characteristics from\n+                             // the source code.\n }\n \n impl Default for Config {\n-\n     fn default() -> Config {\n         Config {\n             max_width: 100,\n@@ -181,11 +181,10 @@ impl Default for Config {\n             report_todo: ReportTactic::Always,\n             report_fixme: ReportTactic::Never,\n             reorder_imports: false,\n-            expr_indent_style: BlockIndentStyle::Tabbed,\n-            closure_indent_style: BlockIndentStyle::Visual,\n             single_line_if_else: false,\n             format_strings: true,\n+            chains_overflow_last: true,\n+            take_source_hints: true,\n         }\n     }\n-\n }"}, {"sha": "98b93a5faa7a2bca56c4f1d4dd5592ab93174021", "filename": "src/expr.rs", "status": "modified", "additions": 15, "deletions": 8, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/03c660633fbac0492f891aed6c47731be90f23ca/src%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03c660633fbac0492f891aed6c47731be90f23ca/src%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fexpr.rs?ref=03c660633fbac0492f891aed6c47731be90f23ca", "patch": "@@ -40,6 +40,12 @@ impl Rewrite for ast::Expr {\n                 }\n             }\n             ast::Expr_::ExprCall(ref callee, ref args) => {\n+                // FIXME using byte lens instead of char lens (and probably all over the place too)\n+                // 2 is for parens\n+                let max_callee_width = try_opt!(width.checked_sub(2));\n+                let callee_str = try_opt!(callee.rewrite(context, max_callee_width, offset));\n+                let span = mk_sp(callee.span.hi, self.span.hi);\n+\n                 rewrite_call(context, &**callee, args, self.span, width, offset)\n             }\n             ast::Expr_::ExprParen(ref subexpr) => {\n@@ -284,8 +290,10 @@ impl Rewrite for ast::Block {\n                 };\n \n                 if is_simple_block(self, context.codemap) && prefix.len() < width {\n-                    let body =\n-                        self.expr.as_ref().unwrap().rewrite(context, width - prefix.len(), offset);\n+                    let body = self.expr\n+                                   .as_ref()\n+                                   .unwrap()\n+                                   .rewrite(context, width - prefix.len(), offset);\n                     if let Some(ref expr_str) = body {\n                         let result = format!(\"{}{{ {} }}\", prefix, expr_str);\n                         if result.len() <= width && !result.contains('\\n') {\n@@ -677,15 +685,13 @@ impl Rewrite for ast::Arm {\n         total_width += (pat_strs.len() - 1) * 3;\n \n         let mut vertical = total_width > pat_budget || pat_strs.iter().any(|p| p.contains('\\n'));\n-        if !vertical {\n+        if !vertical && context.config.take_source_hints {\n             // If the patterns were previously stacked, keep them stacked.\n-            // FIXME should be an option.\n             let pat_span = mk_sp(pats[0].span.lo, pats[pats.len() - 1].span.hi);\n             let pat_str = context.snippet(pat_span);\n             vertical = pat_str.find('\\n').is_some();\n         }\n \n-\n         let pats_width = if vertical {\n             pat_strs[pat_strs.len() - 1].len()\n         } else {\n@@ -1015,9 +1021,10 @@ fn rewrite_struct_lit<'a>(context: &RewriteContext,\n                                  match *item {\n                                      StructLitField::Regular(ref field) => field.span.lo,\n                                      StructLitField::Base(ref expr) => {\n-                                         let last_field_hi = fields.last()\n-                                                                   .map_or(span.lo,\n-                                                                           |field| field.span.hi);\n+                                         let last_field_hi = fields.last().map_or(span.lo,\n+                                                                                  |field| {\n+                                                                                      field.span.hi\n+                                                                                  });\n                                          let snippet = context.snippet(mk_sp(last_field_hi,\n                                                                              expr.span.lo));\n                                          let pos = snippet.find_uncommented(\"..\").unwrap();"}, {"sha": "2547e8f5dd575b67b6bf933e085e2b3f1a8a3f39", "filename": "src/items.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/03c660633fbac0492f891aed6c47731be90f23ca/src%2Fitems.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03c660633fbac0492f891aed6c47731be90f23ca/src%2Fitems.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fitems.rs?ref=03c660633fbac0492f891aed6c47731be90f23ca", "patch": "@@ -512,8 +512,9 @@ impl<'a> FmtVisitor<'a> {\n                                              |arg| arg.ty.span.hi,\n                                              |arg| {\n                                                  // FIXME silly width, indent\n-                                                 arg.ty.rewrite(&self.get_context(), 1000, 0)\n-                                                       .unwrap()\n+                                                 arg.ty\n+                                                    .rewrite(&self.get_context(), 1000, 0)\n+                                                    .unwrap()\n                                              },\n                                              span_after(field.span, \"(\", self.codemap),\n                                              next_span_start);\n@@ -810,15 +811,14 @@ impl<'a> FmtVisitor<'a> {\n                          .map(|ty_param| ty_param.rewrite(&context, h_budget, offset).unwrap());\n \n         // Extract comments between generics.\n-        let lt_spans = lifetimes.iter()\n-                                .map(|l| {\n-                                    let hi = if l.bounds.is_empty() {\n-                                        l.lifetime.span.hi\n-                                    } else {\n-                                        l.bounds[l.bounds.len() - 1].span.hi\n-                                    };\n-                                    codemap::mk_sp(l.lifetime.span.lo, hi)\n-                                });\n+        let lt_spans = lifetimes.iter().map(|l| {\n+            let hi = if l.bounds.is_empty() {\n+                l.lifetime.span.hi\n+            } else {\n+                l.bounds[l.bounds.len() - 1].span.hi\n+            };\n+            codemap::mk_sp(l.lifetime.span.lo, hi)\n+        });\n         let ty_spans = tys.iter().map(span_for_ty_param);\n \n         let items = itemize_list(self.codemap,"}, {"sha": "3f8900d67134c8464ab8b142aef9a92fa2c7124b", "filename": "src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/03c660633fbac0492f891aed6c47731be90f23ca/src%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03c660633fbac0492f891aed6c47731be90f23ca/src%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flib.rs?ref=03c660633fbac0492f891aed6c47731be90f23ca", "patch": "@@ -10,6 +10,7 @@\n \n #![feature(rustc_private)]\n #![feature(custom_attribute)]\n+#![feature(slice_splits)]\n #![allow(unused_attributes)]\n \n // TODO we're going to allocate a whole bunch of temp Strings, is it worth"}, {"sha": "678c84c199a75bb5416e606747d81b558bdfbc54", "filename": "src/lists.rs", "status": "modified", "additions": 97, "deletions": 99, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/03c660633fbac0492f891aed6c47731be90f23ca/src%2Flists.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03c660633fbac0492f891aed6c47731be90f23ca/src%2Flists.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flists.rs?ref=03c660633fbac0492f891aed6c47731be90f23ca", "patch": "@@ -269,109 +269,107 @@ impl<'a, T, I, F1, F2, F3> Iterator for ListItems<'a, I, F1, F2, F3>\n     fn next(&mut self) -> Option<Self::Item> {\n         let white_space: &[_] = &[' ', '\\t'];\n \n-        self.inner\n-            .next()\n-            .map(|item| {\n-                let mut new_lines = false;\n-                // Pre-comment\n-                let pre_snippet = self.codemap\n-                                      .span_to_snippet(codemap::mk_sp(self.prev_span_end,\n-                                                                      (self.get_lo)(&item)))\n-                                      .unwrap();\n-                let trimmed_pre_snippet = pre_snippet.trim();\n-                let pre_comment = if !trimmed_pre_snippet.is_empty() {\n-                    Some(trimmed_pre_snippet.to_owned())\n-                } else {\n-                    None\n-                };\n-\n-                // Post-comment\n-                let next_start = match self.inner.peek() {\n-                    Some(ref next_item) => (self.get_lo)(next_item),\n-                    None => self.next_span_start,\n-                };\n-                let post_snippet = self.codemap\n-                                       .span_to_snippet(codemap::mk_sp((self.get_hi)(&item),\n-                                                                       next_start))\n-                                       .unwrap();\n-\n-                let comment_end = match self.inner.peek() {\n-                    Some(..) => {\n-                        let block_open_index = post_snippet.find(\"/*\");\n-                        let newline_index = post_snippet.find('\\n');\n-                        let separator_index = post_snippet.find_uncommented(\",\").unwrap();\n-\n-                        match (block_open_index, newline_index) {\n-                            // Separator before comment, with the next item on same line.\n-                            // Comment belongs to next item.\n-                            (Some(i), None) if i > separator_index => {\n-                                separator_index + 1\n-                            }\n-                            // Block-style post-comment before the separator.\n-                            (Some(i), None) => {\n-                                cmp::max(find_comment_end(&post_snippet[i..]).unwrap() + i,\n-                                         separator_index + 1)\n-                            }\n-                            // Block-style post-comment. Either before or after the separator.\n-                            (Some(i), Some(j)) if i < j => {\n-                                cmp::max(find_comment_end(&post_snippet[i..]).unwrap() + i,\n-                                         separator_index + 1)\n-                            }\n-                            // Potential *single* line comment.\n-                            (_, Some(j)) => j + 1,\n-                            _ => post_snippet.len(),\n+        self.inner.next().map(|item| {\n+            let mut new_lines = false;\n+            // Pre-comment\n+            let pre_snippet = self.codemap\n+                                  .span_to_snippet(codemap::mk_sp(self.prev_span_end,\n+                                                                  (self.get_lo)(&item)))\n+                                  .unwrap();\n+            let trimmed_pre_snippet = pre_snippet.trim();\n+            let pre_comment = if !trimmed_pre_snippet.is_empty() {\n+                Some(trimmed_pre_snippet.to_owned())\n+            } else {\n+                None\n+            };\n+\n+            // Post-comment\n+            let next_start = match self.inner.peek() {\n+                Some(ref next_item) => (self.get_lo)(next_item),\n+                None => self.next_span_start,\n+            };\n+            let post_snippet = self.codemap\n+                                   .span_to_snippet(codemap::mk_sp((self.get_hi)(&item),\n+                                                                   next_start))\n+                                   .unwrap();\n+\n+            let comment_end = match self.inner.peek() {\n+                Some(..) => {\n+                    let block_open_index = post_snippet.find(\"/*\");\n+                    let newline_index = post_snippet.find('\\n');\n+                    let separator_index = post_snippet.find_uncommented(\",\").unwrap();\n+\n+                    match (block_open_index, newline_index) {\n+                        // Separator before comment, with the next item on same line.\n+                        // Comment belongs to next item.\n+                        (Some(i), None) if i > separator_index => {\n+                            separator_index + 1\n                         }\n-                    }\n-                    None => {\n-                        post_snippet.find_uncommented(self.terminator).unwrap_or(post_snippet.len())\n-                    }\n-                };\n-\n-                if !post_snippet.is_empty() && comment_end > 0 {\n-                    // Account for extra whitespace between items. This is fiddly\n-                    // because of the way we divide pre- and post- comments.\n-\n-                    // Everything from the separator to the next item.\n-                    let test_snippet = &post_snippet[comment_end-1..];\n-                    let first_newline = test_snippet.find('\\n').unwrap_or(test_snippet.len());\n-                    // From the end of the first line of comments.\n-                    let test_snippet = &test_snippet[first_newline..];\n-                    let first = test_snippet.find(|c: char| !c.is_whitespace())\n-                                            .unwrap_or(test_snippet.len());\n-                    // From the end of the first line of comments to the next non-whitespace char.\n-                    let test_snippet = &test_snippet[..first];\n-\n-                    if test_snippet.chars().filter(|c| c == &'\\n').count() > 1 {\n-                        // There were multiple line breaks which got trimmed to nothing.\n-                        new_lines = true;\n+                        // Block-style post-comment before the separator.\n+                        (Some(i), None) => {\n+                            cmp::max(find_comment_end(&post_snippet[i..]).unwrap() + i,\n+                                     separator_index + 1)\n+                        }\n+                        // Block-style post-comment. Either before or after the separator.\n+                        (Some(i), Some(j)) if i < j => {\n+                            cmp::max(find_comment_end(&post_snippet[i..]).unwrap() + i,\n+                                     separator_index + 1)\n+                        }\n+                        // Potential *single* line comment.\n+                        (_, Some(j)) => j + 1,\n+                        _ => post_snippet.len(),\n                     }\n                 }\n-\n-                // Cleanup post-comment: strip separators and whitespace.\n-                self.prev_span_end = (self.get_hi)(&item) + BytePos(comment_end as u32);\n-                let post_snippet = post_snippet[..comment_end].trim();\n-\n-                let post_snippet_trimmed = if post_snippet.starts_with(',') {\n-                    post_snippet[1..].trim_matches(white_space)\n-                } else if post_snippet.ends_with(\",\") {\n-                    post_snippet[..(post_snippet.len() - 1)].trim_matches(white_space)\n-                } else {\n-                    post_snippet\n-                };\n-\n-                let post_comment = if !post_snippet_trimmed.is_empty() {\n-                    Some(post_snippet_trimmed.to_owned())\n-                } else {\n-                    None\n-                };\n-\n-                ListItem {\n-                    pre_comment: pre_comment,\n-                    item: (self.get_item_string)(&item),\n-                    post_comment: post_comment,\n-                    new_lines: new_lines,\n+                None => {\n+                    post_snippet.find_uncommented(self.terminator).unwrap_or(post_snippet.len())\n+                }\n+            };\n+\n+            if !post_snippet.is_empty() && comment_end > 0 {\n+                // Account for extra whitespace between items. This is fiddly\n+                // because of the way we divide pre- and post- comments.\n+\n+                // Everything from the separator to the next item.\n+                let test_snippet = &post_snippet[comment_end-1..];\n+                let first_newline = test_snippet.find('\\n').unwrap_or(test_snippet.len());\n+                // From the end of the first line of comments.\n+                let test_snippet = &test_snippet[first_newline..];\n+                let first = test_snippet.find(|c: char| !c.is_whitespace())\n+                                        .unwrap_or(test_snippet.len());\n+                // From the end of the first line of comments to the next non-whitespace char.\n+                let test_snippet = &test_snippet[..first];\n+\n+                if test_snippet.chars().filter(|c| c == &'\\n').count() > 1 {\n+                    // There were multiple line breaks which got trimmed to nothing.\n+                    new_lines = true;\n                 }\n-            })\n+            }\n+\n+            // Cleanup post-comment: strip separators and whitespace.\n+            self.prev_span_end = (self.get_hi)(&item) + BytePos(comment_end as u32);\n+            let post_snippet = post_snippet[..comment_end].trim();\n+\n+            let post_snippet_trimmed = if post_snippet.starts_with(',') {\n+                post_snippet[1..].trim_matches(white_space)\n+            } else if post_snippet.ends_with(\",\") {\n+                post_snippet[..(post_snippet.len() - 1)].trim_matches(white_space)\n+            } else {\n+                post_snippet\n+            };\n+\n+            let post_comment = if !post_snippet_trimmed.is_empty() {\n+                Some(post_snippet_trimmed.to_owned())\n+            } else {\n+                None\n+            };\n+\n+            ListItem {\n+                pre_comment: pre_comment,\n+                item: (self.get_item_string)(&item),\n+                post_comment: post_comment,\n+                new_lines: new_lines,\n+            }\n+        })\n     }\n }\n "}, {"sha": "e0f3140d4d919b14bdef14efadb56cf01d05f561", "filename": "src/types.rs", "status": "modified", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/03c660633fbac0492f891aed6c47731be90f23ca/src%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03c660633fbac0492f891aed6c47731be90f23ca/src%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftypes.rs?ref=03c660633fbac0492f891aed6c47731be90f23ca", "patch": "@@ -130,16 +130,16 @@ impl<'a> Rewrite for SegmentParam<'a> {\n     // FIXME doesn't always use width, offset\n     fn rewrite(&self, context: &RewriteContext, width: usize, offset: usize) -> Option<String> {\n         Some(match *self {\n-                SegmentParam::LifeTime(ref lt) => {\n-                    pprust::lifetime_to_string(lt)\n-                }\n-                SegmentParam::Type(ref ty) => {\n-                    try_opt!(ty.rewrite(context, width, offset))\n-                }\n-                SegmentParam::Binding(ref binding) => {\n-                    format!(\"{} = {}\", binding.ident, try_opt!(binding.ty.rewrite(context, width, offset)))\n-                }\n-            })\n+            SegmentParam::LifeTime(ref lt) => {\n+                pprust::lifetime_to_string(lt)\n+            }\n+            SegmentParam::Type(ref ty) => {\n+                try_opt!(ty.rewrite(context, width, offset))\n+            }\n+            SegmentParam::Binding(ref binding) => {\n+                format!(\"{} = {}\", binding.ident, try_opt!(binding.ty.rewrite(context, width, offset)))\n+            }\n+        })\n     }\n }\n \n@@ -368,8 +368,9 @@ impl Rewrite for ast::TyParamBound {\n \n impl Rewrite for ast::TyParamBounds {\n     fn rewrite(&self, context: &RewriteContext, width: usize, offset: usize) -> Option<String> {\n-        let strs: Vec<_> =\n-            self.iter().map(|b| b.rewrite(context, width, offset).unwrap()).collect();\n+        let strs: Vec<_> = self.iter()\n+                               .map(|b| b.rewrite(context, width, offset).unwrap())\n+                               .collect();\n         Some(strs.join(\" + \"))\n     }\n }"}, {"sha": "754cde57cd9c91e41ccec0f334b7b6a884505c6c", "filename": "tests/config/small_tabs.toml", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/03c660633fbac0492f891aed6c47731be90f23ca/tests%2Fconfig%2Fsmall_tabs.toml", "raw_url": "https://github.com/rust-lang/rust/raw/03c660633fbac0492f891aed6c47731be90f23ca/tests%2Fconfig%2Fsmall_tabs.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fconfig%2Fsmall_tabs.toml?ref=03c660633fbac0492f891aed6c47731be90f23ca", "patch": "@@ -21,7 +21,7 @@ enum_trailing_comma = true\n report_todo = \"Always\"\n report_fixme = \"Never\"\n reorder_imports = false\n-expr_indent_style = \"Tabbed\"\n-closure_indent_style = \"Visual\"\n single_line_if_else = false\n format_strings = true\n+chains_overflow_last = true\n+take_source_hints = true"}, {"sha": "fa2c66524fc8e4bc8bbd74dd469c9ccf517a1b63", "filename": "tests/source/chains-no-overflow.rs", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/03c660633fbac0492f891aed6c47731be90f23ca/tests%2Fsource%2Fchains-no-overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03c660633fbac0492f891aed6c47731be90f23ca/tests%2Fsource%2Fchains-no-overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fchains-no-overflow.rs?ref=03c660633fbac0492f891aed6c47731be90f23ca", "patch": "@@ -0,0 +1,38 @@\n+// rustfmt-chains_overflow_last: false\n+// Test chain formatting without overflowing the last item.\n+\n+fn main() {\n+    bbbbbbbbbbbbbbbbbbb.ccccccccccccccccccccccccccccccccccccc\n+                       .ddddddddddddddddddddddddddd();\n+\n+    bbbbbbbbbbbbbbbbbbb.ccccccccccccccccccccccccccccccccccccc.ddddddddddddddddddddddddddd.eeeeeeee();\n+\n+    x()\n+        .y(|| match cond() { true => (), false => () });\n+\n+    loong_func()\n+        .quux(move || if true {\n+            1\n+        } else {\n+            2\n+        });\n+\n+    fffffffffffffffffffffffffffffffffff(a,\n+                                        {\n+                                            SCRIPT_TASK_ROOT\n+                                            .with(|root| {\n+                                                                // Another case of write_list failing us.\n+                                                *root.borrow_mut()  =   Some(&script_task);\n+                                            });\n+                                        });                                        \n+\n+    let suuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuum = xxxxxxx\n+        .map(|x| x + 5)\n+        .map(|x| x / 2)\n+        .fold(0, |acc, x| acc + x);\n+\n+    aaaaaaaaaaaaaaaa.map(|x| {\n+                         x += 1;\n+                         x\n+                     }).filter(some_mod::some_filter)\n+}"}, {"sha": "d2f11f1dcbee413d0934330ee6fb2966ef3eb74f", "filename": "tests/source/chains.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/03c660633fbac0492f891aed6c47731be90f23ca/tests%2Fsource%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03c660633fbac0492f891aed6c47731be90f23ca/tests%2Fsource%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fchains.rs?ref=03c660633fbac0492f891aed6c47731be90f23ca", "patch": "@@ -1,10 +1,10 @@\n // Test chain formatting.\n \n fn main() {\n-    let a = b.c\n-             .d\n-             .1\n-             .foo(|x| x + 1);\n+    // Don't put chains on a single list if it wasn't so in source.\n+    let a = b .c\n+    .d.1\n+                .foo(|x| x + 1);\n \n     bbbbbbbbbbbbbbbbbbb.ccccccccccccccccccccccccccccccccccccc\n                        .ddddddddddddddddddddddddddd();\n@@ -25,7 +25,6 @@ fn main() {\n                                         {\n                                             SCRIPT_TASK_ROOT\n                                             .with(|root| {\n-                                                                // Another case of write_list failing us.\n                                                 *root.borrow_mut()  =   Some(&script_task);\n                                             });\n                                         });                                        "}, {"sha": "7329a742bac1277a8f602c1b520eea0cda03f2a4", "filename": "tests/source/expr-no-hints.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/03c660633fbac0492f891aed6c47731be90f23ca/tests%2Fsource%2Fexpr-no-hints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03c660633fbac0492f891aed6c47731be90f23ca/tests%2Fsource%2Fexpr-no-hints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fexpr-no-hints.rs?ref=03c660633fbac0492f891aed6c47731be90f23ca", "patch": "@@ -0,0 +1,8 @@\n+// rustfmt-take_source_hints: false\n+// We know best!\n+\n+fn main() {\n+    a.b\n+     .c\n+     .d();\n+}"}, {"sha": "3d7c1b92be8030a4be6f0293dd9ed4aa033eacd3", "filename": "tests/source/expr-visual-indent.rs", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/48d17f54d34c5457e88ef7ffa234601c6e342a70/tests%2Fsource%2Fexpr-visual-indent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48d17f54d34c5457e88ef7ffa234601c6e342a70/tests%2Fsource%2Fexpr-visual-indent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fexpr-visual-indent.rs?ref=48d17f54d34c5457e88ef7ffa234601c6e342a70", "patch": "@@ -1,9 +0,0 @@\n-// rustfmt-expr_indent_style: Visual\n-\n-// Visual level block indentation.\n-\n-fn matcher() {\n-    Some(while true {\n-        test();\n-    })\n-}\n\\ No newline at end of file"}, {"sha": "d0b6ae78faacbf7d61139eb18b53de9e9bc68f79", "filename": "tests/system.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/03c660633fbac0492f891aed6c47731be90f23ca/tests%2Fsystem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03c660633fbac0492f891aed6c47731be90f23ca/tests%2Fsystem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsystem.rs?ref=03c660633fbac0492f891aed6c47731be90f23ca", "patch": "@@ -165,12 +165,10 @@ fn read_significant_comments(file_name: &str) -> HashMap<String, String> {\n           .map(|line| line.ok().expect(\"Failed getting line.\"))\n           .take_while(|line| line_regex.is_match(&line))\n           .filter_map(|line| {\n-              regex.captures_iter(&line)\n-                   .next()\n-                   .map(|capture| {\n-                       (capture.at(1).expect(\"Couldn\\'t unwrap capture.\").to_owned(),\n-                        capture.at(2).expect(\"Couldn\\'t unwrap capture.\").to_owned())\n-                   })\n+              regex.captures_iter(&line).next().map(|capture| {\n+                  (capture.at(1).expect(\"Couldn\\'t unwrap capture.\").to_owned(),\n+                   capture.at(2).expect(\"Couldn\\'t unwrap capture.\").to_owned())\n+              })\n           })\n           .collect()\n }"}, {"sha": "b4fdb9f99ceedf7be653b596b450c5888b47ec8d", "filename": "tests/target/chains-no-overflow.rs", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/03c660633fbac0492f891aed6c47731be90f23ca/tests%2Ftarget%2Fchains-no-overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03c660633fbac0492f891aed6c47731be90f23ca/tests%2Ftarget%2Fchains-no-overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fchains-no-overflow.rs?ref=03c660633fbac0492f891aed6c47731be90f23ca", "patch": "@@ -0,0 +1,45 @@\n+// rustfmt-chains_overflow_last: false\n+// Test chain formatting without overflowing the last item.\n+\n+fn main() {\n+    bbbbbbbbbbbbbbbbbbb.ccccccccccccccccccccccccccccccccccccc.ddddddddddddddddddddddddddd();\n+\n+    bbbbbbbbbbbbbbbbbbb.ccccccccccccccccccccccccccccccccccccc\n+                       .ddddddddddddddddddddddddddd\n+                       .eeeeeeee();\n+\n+    x().y(|| {\n+           match cond() {\n+               true => (),\n+               false => (),\n+           }\n+       });\n+\n+    loong_func()\n+        .quux(move || {\n+            if true {\n+                1\n+            } else {\n+                2\n+            }\n+        });\n+\n+    fffffffffffffffffffffffffffffffffff(a,\n+                                        {\n+                                            SCRIPT_TASK_ROOT.with(|root| {\n+                                                                // Another case of write_list failing us.\n+                                                                *root.borrow_mut() = Some(&script_task);\n+                                                            });\n+                                        });\n+\n+    let suuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuum = xxxxxxx.map(|x| x + 5)\n+                                                                          .map(|x| x / 2)\n+                                                                          .fold(0,\n+                                                                                |acc, x| acc + x);\n+\n+    aaaaaaaaaaaaaaaa.map(|x| {\n+                        x += 1;\n+                        x\n+                    })\n+                    .filter(some_mod::some_filter)\n+}"}, {"sha": "d795fa2f961a8928645814938651e56ed7c680cb", "filename": "tests/target/chains-no-overlow-2.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/03c660633fbac0492f891aed6c47731be90f23ca/tests%2Ftarget%2Fchains-no-overlow-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03c660633fbac0492f891aed6c47731be90f23ca/tests%2Ftarget%2Fchains-no-overlow-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fchains-no-overlow-2.rs?ref=03c660633fbac0492f891aed6c47731be90f23ca", "patch": "@@ -0,0 +1,16 @@\n+// rustfmt-chains_overflow_last: false\n+\n+fn main() {\n+    reader.lines()\n+          .map(|line| line.ok().expect(\"Failed getting line.\"))\n+          .take_while(|line| line_regex.is_match(&line))\n+          .filter_map(|line| {\n+              regex.captures_iter(&line)\n+                   .next()\n+                   .map(|capture| {\n+                       (capture.at(1).expect(\"Couldn\\'t unwrap capture.\").to_owned(),\n+                        capture.at(2).expect(\"Couldn\\'t unwrap capture.\").to_owned())\n+                   })\n+          })\n+          .collect();\n+}"}, {"sha": "e49233e22a2093072706a7c0199d889a87ed9be6", "filename": "tests/target/chains.rs", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/03c660633fbac0492f891aed6c47731be90f23ca/tests%2Ftarget%2Fchains.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03c660633fbac0492f891aed6c47731be90f23ca/tests%2Ftarget%2Fchains.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fchains.rs?ref=03c660633fbac0492f891aed6c47731be90f23ca", "patch": "@@ -1,7 +1,11 @@\n // Test chain formatting.\n \n fn main() {\n-    let a = b.c.d.1.foo(|x| x + 1);\n+    // Don't put chains on a single list if it wasn't so in source.\n+    let a = b.c\n+             .d\n+             .1\n+             .foo(|x| x + 1);\n \n     bbbbbbbbbbbbbbbbbbb.ccccccccccccccccccccccccccccccccccccc.ddddddddddddddddddddddddddd();\n \n@@ -10,27 +14,25 @@ fn main() {\n                        .eeeeeeee();\n \n     x().y(|| {\n-           match cond() {\n-               true => (),\n-               false => (),\n-           }\n-       });\n-\n-    loong_func()\n-        .quux(move || {\n-            if true {\n-                1\n-            } else {\n-                2\n-            }\n-        });\n+        match cond() {\n+            true => (),\n+            false => (),\n+        }\n+    });\n+\n+    loong_func().quux(move || {\n+        if true {\n+            1\n+        } else {\n+            2\n+        }\n+    });\n \n     fffffffffffffffffffffffffffffffffff(a,\n                                         {\n                                             SCRIPT_TASK_ROOT.with(|root| {\n-                                                                // Another case of write_list failing us.\n-                                                                *root.borrow_mut() = Some(&script_task);\n-                                                            });\n+                                                *root.borrow_mut() = Some(&script_task);\n+                                            });\n                                         });\n \n     let suuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuuum = xxxxxxx.map(|x| x + 5)"}, {"sha": "62dd64c28a610b6087aa58b0aca3986a4a8a6819", "filename": "tests/target/expr-no-hints.rs", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/03c660633fbac0492f891aed6c47731be90f23ca/tests%2Ftarget%2Fexpr-no-hints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/03c660633fbac0492f891aed6c47731be90f23ca/tests%2Ftarget%2Fexpr-no-hints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fexpr-no-hints.rs?ref=03c660633fbac0492f891aed6c47731be90f23ca", "patch": "@@ -0,0 +1,6 @@\n+// rustfmt-take_source_hints: false\n+// We know best!\n+\n+fn main() {\n+    a.b.c.d();\n+}"}, {"sha": "f5b79d74fcb6bb6a8d8d858e40d86e439662b188", "filename": "tests/target/expr-visual-indent.rs", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/48d17f54d34c5457e88ef7ffa234601c6e342a70/tests%2Ftarget%2Fexpr-visual-indent.rs", "raw_url": "https://github.com/rust-lang/rust/raw/48d17f54d34c5457e88ef7ffa234601c6e342a70/tests%2Ftarget%2Fexpr-visual-indent.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fexpr-visual-indent.rs?ref=48d17f54d34c5457e88ef7ffa234601c6e342a70", "patch": "@@ -1,9 +0,0 @@\n-// rustfmt-expr_indent_style: Visual\n-\n-// Visual level block indentation.\n-\n-fn matcher() {\n-    Some(while true {\n-        test();\n-    })\n-}"}]}