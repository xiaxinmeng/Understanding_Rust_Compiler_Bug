{"sha": "79131ecfd33c1f5782a0f9f61aa764717e4a2ddd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc5MTMxZWNmZDMzYzFmNTc4MmEwZjlmNjFhYTc2NDcxN2U0YTJkZGQ=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2012-09-20T01:52:49Z"}, "committer": {"name": "Graydon Hoare", "email": "graydon@mozilla.com", "date": "2012-09-26T23:20:25Z"}, "message": "replace resolve::Atom with ast::ident.", "tree": {"sha": "58fde18efdfb07821ecc4de67a80ca51719b28db", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/58fde18efdfb07821ecc4de67a80ca51719b28db"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/79131ecfd33c1f5782a0f9f61aa764717e4a2ddd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/79131ecfd33c1f5782a0f9f61aa764717e4a2ddd", "html_url": "https://github.com/rust-lang/rust/commit/79131ecfd33c1f5782a0f9f61aa764717e4a2ddd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/79131ecfd33c1f5782a0f9f61aa764717e4a2ddd/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "graydon", "id": 14097, "node_id": "MDQ6VXNlcjE0MDk3", "avatar_url": "https://avatars.githubusercontent.com/u/14097?v=4", "gravatar_id": "", "url": "https://api.github.com/users/graydon", "html_url": "https://github.com/graydon", "followers_url": "https://api.github.com/users/graydon/followers", "following_url": "https://api.github.com/users/graydon/following{/other_user}", "gists_url": "https://api.github.com/users/graydon/gists{/gist_id}", "starred_url": "https://api.github.com/users/graydon/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/graydon/subscriptions", "organizations_url": "https://api.github.com/users/graydon/orgs", "repos_url": "https://api.github.com/users/graydon/repos", "events_url": "https://api.github.com/users/graydon/events{/privacy}", "received_events_url": "https://api.github.com/users/graydon/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b96af7315951dcc69567c2f3432a46ff71ecddf3", "url": "https://api.github.com/repos/rust-lang/rust/commits/b96af7315951dcc69567c2f3432a46ff71ecddf3", "html_url": "https://github.com/rust-lang/rust/commit/b96af7315951dcc69567c2f3432a46ff71ecddf3"}], "stats": {"total": 271, "additions": 129, "deletions": 142}, "files": [{"sha": "7380a217ebe9a14c99cbc985c84e336a15a054e3", "filename": "src/rustc/middle/resolve.rs", "status": "modified", "additions": 129, "deletions": 142, "changes": 271, "blob_url": "https://github.com/rust-lang/rust/blob/79131ecfd33c1f5782a0f9f61aa764717e4a2ddd/src%2Frustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/79131ecfd33c1f5782a0f9f61aa764717e4a2ddd/src%2Frustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fresolve.rs?ref=79131ecfd33c1f5782a0f9f61aa764717e4a2ddd", "patch": "@@ -191,7 +191,7 @@ impl ImportDirectiveNS : cmp::Eq {\n \n /// Contains data for specific types of import directives.\n enum ImportDirectiveSubclass {\n-    SingleImport(Atom /* target */, Atom /* source */, ImportDirectiveNS),\n+    SingleImport(ident /* target */, ident /* source */, ImportDirectiveNS),\n     GlobImport\n }\n \n@@ -303,29 +303,15 @@ enum EnumVariantOrConstResolution {\n     EnumVariantOrConstNotFound\n }\n \n-// FIXME (issue #2550): Should be a class but then it becomes not implicitly\n-// copyable due to a kind bug.\n-\n-type Atom = uint;\n-\n-fn Atom(n: uint) -> Atom {\n-    return n;\n-}\n-\n-/// Creates a hash table of atoms.\n-fn atom_hashmap<V:Copy>() -> HashMap<Atom,V> {\n-  HashMap()\n-}\n-\n /// One local scope.\n struct Rib {\n-    bindings: HashMap<Atom,def_like>,\n+    bindings: HashMap<ident,def_like>,\n     kind: RibKind,\n }\n \n fn Rib(kind: RibKind) -> Rib {\n     Rib {\n-        bindings: atom_hashmap(),\n+        bindings: HashMap(),\n         kind: kind\n     }\n }\n@@ -334,13 +320,13 @@ fn Rib(kind: RibKind) -> Rib {\n /// One import directive.\n struct ImportDirective {\n     privacy: Privacy,\n-    module_path: @DVec<Atom>,\n+    module_path: @DVec<ident>,\n     subclass: @ImportDirectiveSubclass,\n     span: span,\n }\n \n fn ImportDirective(privacy: Privacy,\n-                   module_path: @DVec<Atom>,\n+                   module_path: @DVec<ident>,\n                    subclass: @ImportDirectiveSubclass,\n                    span: span) -> ImportDirective {\n     ImportDirective {\n@@ -407,7 +393,7 @@ impl ImportResolution {\n /// The link from a module up to its nearest parent node.\n enum ParentLink {\n     NoParentLink,\n-    ModuleParentLink(@Module, Atom),\n+    ModuleParentLink(@Module, ident),\n     BlockParentLink(@Module, node_id)\n }\n \n@@ -416,7 +402,7 @@ struct Module {\n     parent_link: ParentLink,\n     mut def_id: Option<def_id>,\n \n-    children: HashMap<Atom,@NameBindings>,\n+    children: HashMap<ident,@NameBindings>,\n     imports: DVec<@ImportDirective>,\n \n     // The anonymous children of this node. Anonymous children are pseudo-\n@@ -439,10 +425,10 @@ struct Module {\n     // XXX: This is about to be reworked so that exports are on individual\n     // items, not names.\n     //\n-    // The atom is the name of the exported item, while the node ID is the\n+    // The ident is the name of the exported item, while the node ID is the\n     // ID of the export path.\n \n-    exported_names: HashMap<Atom,node_id>,\n+    exported_names: HashMap<ident,node_id>,\n \n     // XXX: This is a transition measure to let us switch export-evaluation\n     // logic when compiling modules that have transitioned to listing their\n@@ -452,7 +438,7 @@ struct Module {\n     legacy_exports: bool,\n \n     // The status of resolving each import in this module.\n-    import_resolutions: HashMap<Atom,@ImportResolution>,\n+    import_resolutions: HashMap<ident,@ImportResolution>,\n \n     // The number of unresolved globs that this module exports.\n     mut glob_count: uint,\n@@ -467,12 +453,12 @@ fn Module(parent_link: ParentLink,\n     Module {\n         parent_link: parent_link,\n         def_id: def_id,\n-        children: atom_hashmap(),\n+        children: HashMap(),\n         imports: DVec(),\n         anonymous_children: HashMap(),\n-        exported_names: atom_hashmap(),\n+        exported_names: HashMap(),\n         legacy_exports: legacy_exports,\n-        import_resolutions: atom_hashmap(),\n+        import_resolutions: HashMap(),\n         glob_count: 0u,\n         resolved_import_count: 0u\n     }\n@@ -648,20 +634,20 @@ fn NameBindings() -> NameBindings {\n \n /// Interns the names of the primitive types.\n struct PrimitiveTypeTable {\n-    primitive_types: HashMap<Atom,prim_ty>,\n+    primitive_types: HashMap<ident,prim_ty>,\n }\n \n impl PrimitiveTypeTable {\n     fn intern(intr: @ident_interner, string: @~str,\n               primitive_type: prim_ty) {\n-        let atom = intr.intern(string);\n-        self.primitive_types.insert(atom, primitive_type);\n+        let ident = intr.intern(string);\n+        self.primitive_types.insert(ident, primitive_type);\n     }\n }\n \n fn PrimitiveTypeTable(intr: @ident_interner) -> PrimitiveTypeTable {\n     let table = PrimitiveTypeTable {\n-        primitive_types: atom_hashmap()\n+        primitive_types: HashMap()\n     };\n \n     table.intern(intr, @~\"bool\",    ty_bool);\n@@ -743,7 +729,7 @@ fn Resolver(session: session, lang_items: LanguageItems,\n         xray_context: NoXray,\n         current_trait_refs: None,\n \n-        self_atom: syntax::parse::token::special_idents::self_,\n+        self_ident: syntax::parse::token::special_idents::self_,\n         primitive_type_table: @PrimitiveTypeTable(session.\n                                                   parse_sess.interner),\n \n@@ -771,7 +757,7 @@ struct Resolver {\n \n     unused_import_lint_level: level,\n \n-    trait_info: HashMap<def_id,@HashMap<Atom,()>>,\n+    trait_info: HashMap<def_id,@HashMap<ident,()>>,\n     structs: HashMap<def_id,bool>,\n \n     // The number of imports that are currently unresolved.\n@@ -797,10 +783,10 @@ struct Resolver {\n     // The trait that the current context can refer to.\n     mut current_trait_refs: Option<@DVec<def_id>>,\n \n-    // The atom for the keyword \"self\".\n-    self_atom: Atom,\n+    // The ident for the keyword \"self\".\n+    self_ident: ident,\n \n-    // The atoms for the primitive types.\n+    // The idents for the primitive types.\n     primitive_type_table: @PrimitiveTypeTable,\n \n     // The four namespaces.\n@@ -899,7 +885,7 @@ impl Resolver {\n      * If this node does not have a module definition and we are not inside\n      * a block, fails.\n      */\n-    fn add_child(name: Atom,\n+    fn add_child(name: ident,\n                  reduced_graph_parent: ReducedGraphParent,\n                  // Pass in the namespaces for the child item so that we can\n                  // check for duplicate items in the same namespace\n@@ -981,7 +967,8 @@ impl Resolver {\n         return false;\n     }\n \n-    fn get_parent_link(parent: ReducedGraphParent, name: Atom) -> ParentLink {\n+    fn get_parent_link(parent: ReducedGraphParent,\n+                       name: ident) -> ParentLink {\n         match parent {\n             ModuleReducedGraphParent(module_) => {\n                 return ModuleParentLink(module_, name);\n@@ -994,7 +981,7 @@ impl Resolver {\n                                     parent: ReducedGraphParent,\n                                     &&visitor: vt<ReducedGraphParent>) {\n \n-        let atom = item.ident;\n+        let ident = item.ident;\n         let sp = item.span;\n         let legacy = match parent {\n           ModuleReducedGraphParent(m) => m.legacy_exports\n@@ -1004,10 +991,10 @@ impl Resolver {\n         match item.node {\n             item_mod(module_) => {\n               let legacy = has_legacy_export_attr(item.attrs);\n-              let (name_bindings, new_parent) = self.add_child(atom, parent,\n+              let (name_bindings, new_parent) = self.add_child(ident, parent,\n                                                        ~[ModuleNS], sp);\n \n-                let parent_link = self.get_parent_link(new_parent, atom);\n+                let parent_link = self.get_parent_link(new_parent, ident);\n                 let def_id = { crate: 0, node: item.id };\n               (*name_bindings).define_module(privacy, parent_link,\n                                              Some(def_id), legacy, sp);\n@@ -1021,10 +1008,10 @@ impl Resolver {\n               let legacy = has_legacy_export_attr(item.attrs);\n               let new_parent = match fm.sort {\n                 named => {\n-                  let (name_bindings, new_parent) = self.add_child(atom,\n+                  let (name_bindings, new_parent) = self.add_child(ident,\n                      parent, ~[ModuleNS], sp);\n \n-                  let parent_link = self.get_parent_link(new_parent, atom);\n+                  let parent_link = self.get_parent_link(new_parent, ident);\n                   let def_id = { crate: 0, node: item.id };\n                   (*name_bindings).define_module(privacy, parent_link,\n                                                  Some(def_id), legacy, sp);\n@@ -1041,14 +1028,14 @@ impl Resolver {\n \n             // These items live in the value namespace.\n             item_const(*) => {\n-              let (name_bindings, _) = self.add_child(atom, parent,\n+              let (name_bindings, _) = self.add_child(ident, parent,\n                                                       ~[ValueNS], sp);\n \n                 (*name_bindings).define_value\n                     (privacy, def_const(local_def(item.id)), sp);\n             }\n             item_fn(_, purity, _, _) => {\n-              let (name_bindings, new_parent) = self.add_child(atom, parent,\n+              let (name_bindings, new_parent) = self.add_child(ident, parent,\n                                                         ~[ValueNS], sp);\n \n                 let def = def_fn(local_def(item.id), purity);\n@@ -1058,7 +1045,7 @@ impl Resolver {\n \n             // These items live in the type namespace.\n             item_ty(*) => {\n-              let (name_bindings, _) = self.add_child(atom, parent,\n+              let (name_bindings, _) = self.add_child(ident, parent,\n                                                       ~[TypeNS], sp);\n \n                 (*name_bindings).define_type\n@@ -1067,7 +1054,7 @@ impl Resolver {\n \n             item_enum(enum_definition, _) => {\n \n-              let (name_bindings, new_parent) = self.add_child(atom, parent,\n+              let (name_bindings, new_parent) = self.add_child(ident, parent,\n                                                                ~[TypeNS], sp);\n \n                 (*name_bindings).define_type\n@@ -1087,15 +1074,15 @@ impl Resolver {\n                     match struct_definition.ctor {\n                     None => {\n                         let (name_bindings, new_parent) =\n-                            self.add_child(atom, parent, ~[TypeNS], sp);\n+                            self.add_child(ident, parent, ~[TypeNS], sp);\n \n                         (*name_bindings).define_type\n                             (privacy, def_ty(local_def(item.id)), sp);\n                         new_parent\n                     }\n                     Some(ctor) => {\n                         let (name_bindings, new_parent) =\n-                            self.add_child(atom, parent, ~[ValueNS, TypeNS],\n+                            self.add_child(ident, parent, ~[ValueNS, TypeNS],\n                                            sp);\n \n                         (*name_bindings).define_type\n@@ -1121,30 +1108,30 @@ impl Resolver {\n             }\n \n             item_trait(_, _, methods) => {\n-              let (name_bindings, new_parent) = self.add_child(atom, parent,\n+              let (name_bindings, new_parent) = self.add_child(ident, parent,\n                                                                ~[TypeNS], sp);\n \n                 // Add the names of all the methods to the trait info.\n-                let method_names = @atom_hashmap();\n+                let method_names = @HashMap();\n                 for methods.each |method| {\n                     let ty_m = trait_method_to_ty_method(*method);\n \n-                    let atom = ty_m.ident;\n+                    let ident = ty_m.ident;\n                     // Add it to the trait info if not static,\n                     // add it as a name in the enclosing module otherwise.\n                     match ty_m.self_ty.node {\n                       sty_static => {\n                         // which parent to use??\n                         let (method_name_bindings, _) =\n-                            self.add_child(atom, new_parent, ~[ValueNS],\n+                            self.add_child(ident, new_parent, ~[ValueNS],\n                                            ty_m.span);\n                         let def = def_static_method(local_def(ty_m.id),\n                                                     ty_m.purity);\n                         (*method_name_bindings).define_value\n                             (Public, def, ty_m.span);\n                       }\n                       _ => {\n-                        (*method_names).insert(atom, ());\n+                        (*method_names).insert(ident, ());\n                       }\n                     }\n                 }\n@@ -1176,8 +1163,8 @@ impl Resolver {\n           ModuleReducedGraphParent(m) => m.legacy_exports\n         };\n \n-        let atom = variant.node.name;\n-        let (child, _) = self.add_child(atom, parent, ~[ValueNS],\n+        let ident = variant.node.name;\n+        let (child, _) = self.add_child(ident, parent, ~[ValueNS],\n                                         variant.span);\n         let privacy = self.visibility_to_privacy(variant.node.vis, legacy);\n \n@@ -1338,9 +1325,9 @@ impl Resolver {\n                                 }\n \n                                 for path_list_idents.each |path_list_ident| {\n-                                    let atom = path_list_ident.node.name;\n+                                    let ident = path_list_ident.node.name;\n                                     let id = path_list_ident.node.id;\n-                                    module_.exported_names.insert(atom, id);\n+                                    module_.exported_names.insert(ident, id);\n                                 }\n                             }\n                         }\n@@ -1433,15 +1420,15 @@ impl Resolver {\n     fn handle_external_def(def: def, modules: HashMap<def_id, @Module>,\n                            child_name_bindings: @NameBindings,\n                            final_ident: ~str,\n-                           atom: Atom, new_parent: ReducedGraphParent) {\n+                           ident: ident, new_parent: ReducedGraphParent) {\n         match def {\n           def_mod(def_id) | def_foreign_mod(def_id) => {\n             match copy child_name_bindings.module_def {\n               NoModuleDef => {\n                 debug!(\"(building reduced graph for \\\n                         external crate) building module \\\n                         %s\", final_ident);\n-                let parent_link = self.get_parent_link(new_parent, atom);\n+                let parent_link = self.get_parent_link(new_parent, ident);\n \n                 match modules.find(def_id) {\n                   None => {\n@@ -1466,9 +1453,9 @@ impl Resolver {\n                       BlockParentLink(*) => {\n                         fail ~\"can't happen\";\n                       }\n-                      ModuleParentLink(parent_module, atom) => {\n+                      ModuleParentLink(parent_module, ident) => {\n \n-                        let name_bindings = parent_module.children.get(atom);\n+                        let name_bindings = parent_module.children.get(ident);\n \n                         resolution.module_target =\n                             Some(Target(parent_module, name_bindings));\n@@ -1478,7 +1465,7 @@ impl Resolver {\n                     debug!(\"(building reduced graph for external crate) \\\n                             ... creating import resolution\");\n \n-                    new_parent.import_resolutions.insert(atom, resolution);\n+                    new_parent.import_resolutions.insert(ident, resolution);\n                   }\n                 }\n               }\n@@ -1510,7 +1497,7 @@ impl Resolver {\n                 // Nothing to do.\n               }\n               Some(method_names) => {\n-                let interned_method_names = @atom_hashmap();\n+                let interned_method_names = @HashMap();\n                 for method_names.each |method_data| {\n                     let (method_name, self_ty) = *method_data;\n                     debug!(\"(building reduced graph for \\\n@@ -1634,7 +1621,7 @@ impl Resolver {\n     /// Creates and adds an import directive to the given module.\n     fn build_import_directive(privacy: Privacy,\n                               module_: @Module,\n-                              module_path: @DVec<Atom>,\n+                              module_path: @DVec<ident>,\n                               subclass: @ImportDirectiveSubclass,\n                               span: span) {\n \n@@ -1764,17 +1751,17 @@ impl Resolver {\n         }\n     }\n \n-    fn atoms_to_str(atoms: ~[Atom]) -> ~str {\n+    fn idents_to_str(idents: ~[ident]) -> ~str {\n         // XXX: str::connect should do this.\n         let mut result = ~\"\";\n         let mut first = true;\n-        for atoms.each() |atom| {\n+        for idents.each() |ident| {\n             if first {\n                 first = false;\n             } else {\n                 result += ~\"::\";\n             }\n-            result += self.session.str_of(*atom);\n+            result += self.session.str_of(*ident);\n         }\n         // XXX: Shouldn't copy here. We need string builder functionality.\n         return result;\n@@ -1795,7 +1782,7 @@ impl Resolver {\n \n         debug!(\"(resolving import for module) resolving import `%s::...` in \\\n                 `%s`\",\n-               self.atoms_to_str((*module_path).get()),\n+               self.idents_to_str((*module_path).get()),\n                self.module_to_str(module_));\n \n         // One-level renaming imports of the form `import foo = bar;` are\n@@ -1882,8 +1869,8 @@ impl Resolver {\n \n     fn resolve_single_import(module_: @Module,\n                              containing_module: @Module,\n-                             target: Atom,\n-                             source: Atom)\n+                             target: ident,\n+                             source: ident)\n                           -> ResolveResult<()> {\n \n         debug!(\"(resolving single import) resolving `%s` = `%s::%s` from \\\n@@ -2072,8 +2059,8 @@ impl Resolver {\n \n     fn resolve_single_module_import(module_: @Module,\n                                     containing_module: @Module,\n-                                    target: Atom,\n-                                    source: Atom)\n+                                    target: ident,\n+                                    source: ident)\n                                  -> ResolveResult<()> {\n \n         debug!(\"(resolving single module import) resolving `%s` = `%s::%s` \\\n@@ -2229,11 +2216,11 @@ impl Resolver {\n \n         // Add all resolved imports from the containing module.\n         for containing_module.import_resolutions.each\n-                |atom, target_import_resolution| {\n+                |ident, target_import_resolution| {\n \n-            if !self.name_is_exported(containing_module, atom) {\n+            if !self.name_is_exported(containing_module, ident) {\n                 debug!(\"(resolving glob import) name `%s` is unexported\",\n-                       self.session.str_of(atom));\n+                       self.session.str_of(ident));\n                 loop;\n             }\n \n@@ -2243,7 +2230,7 @@ impl Resolver {\n                    self.module_to_str(module_));\n \n             // Here we merge two import resolutions.\n-            match module_.import_resolutions.find(atom) {\n+            match module_.import_resolutions.find(ident) {\n                 None => {\n                     // Simple: just copy the old import resolution.\n                     let new_import_resolution =\n@@ -2257,7 +2244,7 @@ impl Resolver {\n                         copy target_import_resolution.type_target;\n \n                     module_.import_resolutions.insert\n-                        (atom, new_import_resolution);\n+                        (ident, new_import_resolution);\n                 }\n                 Some(dest_import_resolution) => {\n                     // Merge the two import resolutions at a finer-grained\n@@ -2295,21 +2282,21 @@ impl Resolver {\n         }\n \n         // Add all children from the containing module.\n-        for containing_module.children.each |atom, name_bindings| {\n-            if !self.name_is_exported(containing_module, atom) {\n+        for containing_module.children.each |ident, name_bindings| {\n+            if !self.name_is_exported(containing_module, ident) {\n                 debug!(\"(resolving glob import) name `%s` is unexported\",\n-                       self.session.str_of(atom));\n+                       self.session.str_of(ident));\n                 loop;\n             }\n \n             let mut dest_import_resolution;\n-            match module_.import_resolutions.find(atom) {\n+            match module_.import_resolutions.find(ident) {\n                 None => {\n                     // Create a new import resolution from this child.\n                     dest_import_resolution = @ImportResolution(privacy,\n                                                                span);\n                     module_.import_resolutions.insert\n-                        (atom, dest_import_resolution);\n+                        (ident, dest_import_resolution);\n                 }\n                 Some(existing_import_resolution) => {\n                     dest_import_resolution = existing_import_resolution;\n@@ -2319,7 +2306,7 @@ impl Resolver {\n \n             debug!(\"(resolving glob import) writing resolution `%s` in `%s` \\\n                     to `%s`\",\n-                   self.session.str_of(atom),\n+                   self.session.str_of(ident),\n                    self.module_to_str(containing_module),\n                    self.module_to_str(module_));\n \n@@ -2346,7 +2333,7 @@ impl Resolver {\n     }\n \n     fn resolve_module_path_from_root(module_: @Module,\n-                                     module_path: @DVec<Atom>,\n+                                     module_path: @DVec<ident>,\n                                      index: uint,\n                                      xray: XrayFlag,\n                                      span: span)\n@@ -2403,7 +2390,7 @@ impl Resolver {\n      * the given module.\n      */\n     fn resolve_module_path_for_import(module_: @Module,\n-                                      module_path: @DVec<Atom>,\n+                                      module_path: @DVec<ident>,\n                                       xray: XrayFlag,\n                                       span: span)\n                                    -> ResolveResult<@Module> {\n@@ -2413,7 +2400,7 @@ impl Resolver {\n \n         debug!(\"(resolving module path for import) processing `%s` rooted at \\\n                `%s`\",\n-               self.atoms_to_str((*module_path).get()),\n+               self.idents_to_str((*module_path).get()),\n                self.module_to_str(module_));\n \n         // The first element of the module path must be in the current scope\n@@ -2444,7 +2431,7 @@ impl Resolver {\n     }\n \n     fn resolve_item_in_lexical_scope(module_: @Module,\n-                                     name: Atom,\n+                                     name: ident,\n                                      namespace: Namespace)\n                                   -> ResolveResult<Target> {\n \n@@ -2530,7 +2517,7 @@ impl Resolver {\n         }\n     }\n \n-    fn resolve_module_in_lexical_scope(module_: @Module, name: Atom)\n+    fn resolve_module_in_lexical_scope(module_: @Module, name: ident)\n                                     -> ResolveResult<@Module> {\n \n         match self.resolve_item_in_lexical_scope(module_, name, ModuleNS) {\n@@ -2559,7 +2546,7 @@ impl Resolver {\n         }\n     }\n \n-    fn name_is_exported(module_: @Module, name: Atom) -> bool {\n+    fn name_is_exported(module_: @Module, name: ident) -> bool {\n         return !module_.legacy_exports ||\n             module_.exported_names.size() == 0u ||\n             module_.exported_names.contains_key(name);\n@@ -2571,7 +2558,7 @@ impl Resolver {\n      * the name.\n      */\n     fn resolve_name_in_module(module_: @Module,\n-                              name: Atom,\n+                              name: ident,\n                               namespace: Namespace,\n                               xray: XrayFlag)\n                            -> ResolveResult<Target> {\n@@ -2863,7 +2850,7 @@ impl Resolver {\n \n         self.record_exports_for_module(module_);\n \n-        for module_.children.each |_atom, child_name_bindings| {\n+        for module_.children.each |_ident, child_name_bindings| {\n             match child_name_bindings.get_module_if_available() {\n                 None => {\n                     // Nothing to do.\n@@ -2899,7 +2886,7 @@ impl Resolver {\n \n \n     fn add_exports_of_namebindings(exports2: &mut ~[Export2],\n-                                   atom: Atom,\n+                                   ident: ident,\n                                    namebindings: @NameBindings,\n                                    reexport: bool) {\n         for [ModuleNS, TypeNS, ValueNS].each |ns| {\n@@ -2908,11 +2895,11 @@ impl Resolver {\n                     debug!(\"(computing exports) YES: %s '%s' \\\n                             => %?\",\n                            if reexport { ~\"reexport\" } else { ~\"export\"},\n-                           self.session.str_of(atom),\n+                           self.session.str_of(ident),\n                            def_id_of_def(d.def));\n                     vec::push(*exports2,  Export2 {\n                         reexport: reexport,\n-                        name: self.session.str_of(atom),\n+                        name: self.session.str_of(ident),\n                         def_id: def_id_of_def(d.def)\n                     });\n                 }\n@@ -2923,20 +2910,20 @@ impl Resolver {\n \n     fn add_exports_for_module(exports2: &mut ~[Export2], module_: @Module) {\n \n-        for module_.children.each_ref |atom, namebindings| {\n+        for module_.children.each_ref |ident, namebindings| {\n             debug!(\"(computing exports) maybe export '%s'\",\n-                   self.session.str_of(*atom));\n-            self.add_exports_of_namebindings(exports2, *atom,\n+                   self.session.str_of(*ident));\n+            self.add_exports_of_namebindings(exports2, *ident,\n                                              *namebindings, false)\n         }\n \n-        for module_.import_resolutions.each_ref |atom, importresolution| {\n+        for module_.import_resolutions.each_ref |ident, importresolution| {\n             for [ModuleNS, TypeNS, ValueNS].each |ns| {\n                 match importresolution.target_for_namespace(*ns) {\n                     Some(target) => {\n                         debug!(\"(computing exports) maybe reexport '%s'\",\n-                               self.session.str_of(*atom));\n-                        self.add_exports_of_namebindings(exports2, *atom,\n+                               self.session.str_of(*ident));\n+                        self.add_exports_of_namebindings(exports2, *ident,\n                                                          target.bindings,\n                                                          true)\n                     }\n@@ -3002,7 +2989,7 @@ impl Resolver {\n     // generate a fake \"implementation scope\" containing all the\n     // implementations thus found, for compatibility with old resolve pass.\n \n-    fn with_scope(name: Option<Atom>, f: fn()) {\n+    fn with_scope(name: Option<ident>, f: fn()) {\n         let orig_module = self.current_module;\n \n         // Move down in the graph.\n@@ -3142,7 +3129,7 @@ impl Resolver {\n         return Some(dl_def(def));\n     }\n \n-    fn search_ribs(ribs: @DVec<@Rib>, name: Atom, span: span,\n+    fn search_ribs(ribs: @DVec<@Rib>, name: ident, span: span,\n                    allow_capturing_self: AllowCapturingSelfFlag)\n                 -> Option<def_like> {\n \n@@ -3223,7 +3210,7 @@ impl Resolver {\n                 // Create a new rib for the self type.\n                 let self_type_rib = @Rib(NormalRibKind);\n                 (*self.type_ribs).push(self_type_rib);\n-                self_type_rib.bindings.insert(self.self_atom,\n+                self_type_rib.bindings.insert(self.self_ident,\n                                               dl_def(def_self(item.id)));\n \n                 // Create a new rib for the trait-wide type parameters.\n@@ -3483,7 +3470,7 @@ impl Resolver {\n                 }\n                 HasSelfBinding(self_node_id) => {\n                     let def_like = dl_def(def_self(self_node_id));\n-                    (*function_value_rib).bindings.insert(self.self_atom,\n+                    (*function_value_rib).bindings.insert(self.self_ident,\n                                                           def_like);\n                 }\n             }\n@@ -3818,7 +3805,7 @@ impl Resolver {\n     fn resolve_arm(arm: arm, visitor: ResolveVisitor) {\n         (*self.value_ribs).push(@Rib(NormalRibKind));\n \n-        let bindings_list = atom_hashmap();\n+        let bindings_list = HashMap();\n         for arm.pats.each |pattern| {\n             self.resolve_pattern(*pattern, RefutableMode, Immutable,\n                                  Some(bindings_list), visitor);\n@@ -3937,7 +3924,7 @@ impl Resolver {\n                        mutability: Mutability,\n                        // Maps idents to the node ID for the (outermost)\n                        // pattern that binds them\n-                       bindings_list: Option<HashMap<Atom,node_id>>,\n+                       bindings_list: Option<HashMap<ident,node_id>>,\n                        visitor: ResolveVisitor) {\n \n         let pat_id = pattern.id;\n@@ -3954,13 +3941,13 @@ impl Resolver {\n                     // matching such a variant is simply disallowed (since\n                     // it's rarely what you want).\n \n-                    let atom = path.idents[0];\n+                    let ident = path.idents[0];\n \n-                    match self.resolve_enum_variant_or_const(atom) {\n+                    match self.resolve_enum_variant_or_const(ident) {\n                         FoundEnumVariant(def) if mode == RefutableMode => {\n                             debug!(\"(resolving pattern) resolving `%s` to \\\n                                     enum variant\",\n-                                    self.session.str_of(atom));\n+                                    self.session.str_of(ident));\n \n                             self.record_def(pattern.id, def);\n                         }\n@@ -3970,7 +3957,7 @@ impl Resolver {\n                                                         shadows an enum \\\n                                                         that's in scope\",\n                                                         self.session\n-                                                        .str_of(atom)));\n+                                                        .str_of(ident)));\n                         }\n                         FoundConst => {\n                             self.session.span_err(pattern.span,\n@@ -3980,7 +3967,7 @@ impl Resolver {\n                         }\n                         EnumVariantOrConstNotFound => {\n                             debug!(\"(resolving pattern) binding `%s`\",\n-                                   self.session.str_of(atom));\n+                                   self.session.str_of(ident));\n \n                             let is_mutable = mutability == Mutable;\n \n@@ -4011,14 +3998,14 @@ impl Resolver {\n \n                             match bindings_list {\n                                 Some(bindings_list)\n-                                if !bindings_list.contains_key(atom) => {\n+                                if !bindings_list.contains_key(ident) => {\n                                     let last_rib = (*self.value_ribs).last();\n-                                    last_rib.bindings.insert(atom,\n+                                    last_rib.bindings.insert(ident,\n                                                              dl_def(def));\n-                                    bindings_list.insert(atom, pat_id);\n+                                    bindings_list.insert(ident, pat_id);\n                                 }\n                                 Some(b) => {\n-                                  if b.find(atom) == Some(pat_id) {\n+                                  if b.find(ident) == Some(pat_id) {\n                                       // Then this is a duplicate variable\n                                       // in the same disjunct, which is an\n                                       // error\n@@ -4032,7 +4019,7 @@ impl Resolver {\n                                 }\n                                 None => {\n                                     let last_rib = (*self.value_ribs).last();\n-                                    last_rib.bindings.insert(atom,\n+                                    last_rib.bindings.insert(ident,\n                                                              dl_def(def));\n                                 }\n                             }\n@@ -4110,7 +4097,7 @@ impl Resolver {\n         }\n     }\n \n-    fn resolve_enum_variant_or_const(name: Atom)\n+    fn resolve_enum_variant_or_const(name: ident)\n                                   -> EnumVariantOrConstResolution {\n \n         match self.resolve_item_in_lexical_scope(self.current_module,\n@@ -4205,7 +4192,7 @@ impl Resolver {\n \n     // XXX: Merge me with resolve_name_in_module?\n     fn resolve_definition_of_name_in_module(containing_module: @Module,\n-                                            name: Atom,\n+                                            name: ident,\n                                             namespace: Namespace,\n                                             xray: XrayFlag)\n                                          -> NameDefinition {\n@@ -4266,37 +4253,37 @@ impl Resolver {\n         }\n     }\n \n-    fn intern_module_part_of_path(path: @path) -> @DVec<Atom> {\n-        let module_path_atoms = @DVec();\n+    fn intern_module_part_of_path(path: @path) -> @DVec<ident> {\n+        let module_path_idents = @DVec();\n         for path.idents.eachi |index, ident| {\n             if index == path.idents.len() - 1u {\n                 break;\n             }\n \n-            (*module_path_atoms).push(*ident);\n+            (*module_path_idents).push(*ident);\n         }\n \n-        return module_path_atoms;\n+        return module_path_idents;\n     }\n \n     fn resolve_module_relative_path(path: @path,\n                                     +xray: XrayFlag,\n                                     namespace: Namespace)\n                                  -> Option<def> {\n \n-        let module_path_atoms = self.intern_module_part_of_path(path);\n+        let module_path_idents = self.intern_module_part_of_path(path);\n \n         let mut containing_module;\n         match self.resolve_module_path_for_import(self.current_module,\n-                                                module_path_atoms,\n+                                                module_path_idents,\n                                                 xray,\n                                                 path.span) {\n \n             Failed => {\n                 self.session.span_err(path.span,\n                                       fmt!(\"use of undeclared module `%s`\",\n-                                           self.atoms_to_str(\n-                                               (*module_path_atoms).get())));\n+                                           self.idents_to_str(\n+                                               (*module_path_idents).get())));\n                 return None;\n             }\n \n@@ -4329,22 +4316,22 @@ impl Resolver {\n                                    namespace: Namespace)\n                                 -> Option<def> {\n \n-        let module_path_atoms = self.intern_module_part_of_path(path);\n+        let module_path_idents = self.intern_module_part_of_path(path);\n \n         let root_module = (*self.graph_root).get_module();\n \n         let mut containing_module;\n         match self.resolve_module_path_from_root(root_module,\n-                                               module_path_atoms,\n+                                               module_path_idents,\n                                                0u,\n                                                xray,\n                                                path.span) {\n \n             Failed => {\n                 self.session.span_err(path.span,\n                                       fmt!(\"use of undeclared module `::%s`\",\n-                                            self.atoms_to_str\n-                                              ((*module_path_atoms).get())));\n+                                            self.idents_to_str\n+                                              ((*module_path_idents).get())));\n                 return None;\n             }\n \n@@ -4676,7 +4663,7 @@ impl Resolver {\n         }\n     }\n \n-    fn search_for_traits_containing_method(name: Atom) -> @DVec<def_id> {\n+    fn search_for_traits_containing_method(name: ident) -> @DVec<def_id> {\n         let found_traits = @DVec();\n         let mut search_module = self.current_module;\n         loop {\n@@ -4715,7 +4702,7 @@ impl Resolver {\n \n             // Look for imports.\n             for search_module.import_resolutions.each\n-                    |_atom, import_resolution| {\n+                    |_ident, import_resolution| {\n \n                 match import_resolution.target_for_namespace(TypeNS) {\n                     None => {\n@@ -4761,7 +4748,7 @@ impl Resolver {\n \n     fn add_trait_info_if_containing_method(found_traits: @DVec<def_id>,\n                                            trait_def_id: def_id,\n-                                           name: Atom) {\n+                                           name: ident) {\n \n         match self.trait_info.find(trait_def_id) {\n             Some(trait_info) if trait_info.contains_key(name) => {\n@@ -4827,7 +4814,7 @@ impl Resolver {\n \n         self.check_for_unused_imports_in_module(module_);\n \n-        for module_.children.each |_atom, child_name_bindings| {\n+        for module_.children.each |_ident, child_name_bindings| {\n             match (*child_name_bindings).get_module_if_available() {\n                 None => {\n                     // Nothing to do.\n@@ -4876,35 +4863,35 @@ impl Resolver {\n \n     /// A somewhat inefficient routine to print out the name of a module.\n     fn module_to_str(module_: @Module) -> ~str {\n-        let atoms = DVec();\n+        let idents = DVec();\n         let mut current_module = module_;\n         loop {\n             match current_module.parent_link {\n                 NoParentLink => {\n                     break;\n                 }\n                 ModuleParentLink(module_, name) => {\n-                    atoms.push(name);\n+                    idents.push(name);\n                     current_module = module_;\n                 }\n                 BlockParentLink(module_, _) => {\n-                    atoms.push(syntax::parse::token::special_idents::opaque);\n+                    idents.push(syntax::parse::token::special_idents::opaque);\n                     current_module = module_;\n                 }\n             }\n         }\n \n-        if atoms.len() == 0u {\n+        if idents.len() == 0u {\n             return ~\"???\";\n         }\n \n         let mut string = ~\"\";\n-        let mut i = atoms.len() - 1u;\n+        let mut i = idents.len() - 1u;\n         loop {\n-            if i < atoms.len() - 1u {\n+            if i < idents.len() - 1u {\n                 string += ~\"::\";\n             }\n-            string += self.session.str_of(atoms.get_elt(i));\n+            string += self.session.str_of(idents.get_elt(i));\n \n             if i == 0u {\n                 break;"}]}