{"sha": "55f052d9c927699e0f69b937ac93701442155d39", "node_id": "C_kwDOAAsO6NoAKDU1ZjA1MmQ5YzkyNzY5OWUwZjY5YjkzN2FjOTM3MDE0NDIxNTVkMzk", "commit": {"author": {"name": "Nika Layzell", "email": "nika@thelayzells.com", "date": "2021-06-29T18:49:54Z"}, "committer": {"name": "Nika Layzell", "email": "nika@thelayzells.com", "date": "2022-06-25T14:28:11Z"}, "message": "proc_macro: cache static spans in client's thread-local state\n\nThis greatly improves the performance of the very frequently called\n`call_site()` macro when running in a cross-thread configuration.", "tree": {"sha": "d44691a0cd7196b680a08679943c97ed7fc1de8d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d44691a0cd7196b680a08679943c97ed7fc1de8d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/55f052d9c927699e0f69b937ac93701442155d39", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/55f052d9c927699e0f69b937ac93701442155d39", "html_url": "https://github.com/rust-lang/rust/commit/55f052d9c927699e0f69b937ac93701442155d39", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/55f052d9c927699e0f69b937ac93701442155d39/comments", "author": {"login": "mystor", "id": 1261662, "node_id": "MDQ6VXNlcjEyNjE2NjI=", "avatar_url": "https://avatars.githubusercontent.com/u/1261662?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mystor", "html_url": "https://github.com/mystor", "followers_url": "https://api.github.com/users/mystor/followers", "following_url": "https://api.github.com/users/mystor/following{/other_user}", "gists_url": "https://api.github.com/users/mystor/gists{/gist_id}", "starred_url": "https://api.github.com/users/mystor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mystor/subscriptions", "organizations_url": "https://api.github.com/users/mystor/orgs", "repos_url": "https://api.github.com/users/mystor/repos", "events_url": "https://api.github.com/users/mystor/events{/privacy}", "received_events_url": "https://api.github.com/users/mystor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mystor", "id": 1261662, "node_id": "MDQ6VXNlcjEyNjE2NjI=", "avatar_url": "https://avatars.githubusercontent.com/u/1261662?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mystor", "html_url": "https://github.com/mystor", "followers_url": "https://api.github.com/users/mystor/followers", "following_url": "https://api.github.com/users/mystor/following{/other_user}", "gists_url": "https://api.github.com/users/mystor/gists{/gist_id}", "starred_url": "https://api.github.com/users/mystor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mystor/subscriptions", "organizations_url": "https://api.github.com/users/mystor/orgs", "repos_url": "https://api.github.com/users/mystor/repos", "events_url": "https://api.github.com/users/mystor/events{/privacy}", "received_events_url": "https://api.github.com/users/mystor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1aabd8a4a6e1871f14e804302bd60dfcbffd5761", "url": "https://api.github.com/repos/rust-lang/rust/commits/1aabd8a4a6e1871f14e804302bd60dfcbffd5761", "html_url": "https://github.com/rust-lang/rust/commit/1aabd8a4a6e1871f14e804302bd60dfcbffd5761"}], "stats": {"total": 291, "additions": 190, "deletions": 101}, "files": [{"sha": "eace22d63f4ffae055345e3aaadc853466608a59", "filename": "compiler/rustc_expand/src/proc_macro_server.rs", "status": "modified", "additions": 20, "deletions": 15, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/55f052d9c927699e0f69b937ac93701442155d39/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55f052d9c927699e0f69b937ac93701442155d39/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs?ref=55f052d9c927699e0f69b937ac93701442155d39", "patch": "@@ -370,7 +370,10 @@ impl<'a, 'b> Rustc<'a, 'b> {\n     }\n \n     fn lit(&mut self, kind: token::LitKind, symbol: Symbol, suffix: Option<Symbol>) -> Literal {\n-        Literal { lit: token::Lit::new(kind, symbol, suffix), span: server::Span::call_site(self) }\n+        Literal {\n+            lit: token::Lit::new(kind, symbol, suffix),\n+            span: server::Context::call_site(self),\n+        }\n     }\n }\n \n@@ -547,7 +550,7 @@ impl server::Group for Rustc<'_, '_> {\n         Group {\n             delimiter,\n             stream: stream.unwrap_or_default(),\n-            span: DelimSpan::from_single(server::Span::call_site(self)),\n+            span: DelimSpan::from_single(server::Context::call_site(self)),\n             flatten: false,\n         }\n     }\n@@ -579,7 +582,7 @@ impl server::Group for Rustc<'_, '_> {\n \n impl server::Punct for Rustc<'_, '_> {\n     fn new(&mut self, ch: char, spacing: Spacing) -> Self::Punct {\n-        Punct::new(ch, spacing == Spacing::Joint, server::Span::call_site(self))\n+        Punct::new(ch, spacing == Spacing::Joint, server::Context::call_site(self))\n     }\n \n     fn as_char(&mut self, punct: Self::Punct) -> char {\n@@ -829,18 +832,6 @@ impl server::Span for Rustc<'_, '_> {\n         }\n     }\n \n-    fn def_site(&mut self) -> Self::Span {\n-        self.def_site\n-    }\n-\n-    fn call_site(&mut self) -> Self::Span {\n-        self.call_site\n-    }\n-\n-    fn mixed_site(&mut self) -> Self::Span {\n-        self.mixed_site\n-    }\n-\n     fn source_file(&mut self, span: Self::Span) -> Self::SourceFile {\n         self.sess().source_map().lookup_char_pos(span.lo()).file\n     }\n@@ -926,3 +917,17 @@ impl server::Span for Rustc<'_, '_> {\n         })\n     }\n }\n+\n+impl server::Context for Rustc<'_, '_> {\n+    fn def_site(&mut self) -> Self::Span {\n+        self.def_site\n+    }\n+\n+    fn call_site(&mut self) -> Self::Span {\n+        self.call_site\n+    }\n+\n+    fn mixed_site(&mut self) -> Self::Span {\n+        self.mixed_site\n+    }\n+}"}, {"sha": "f1f8ae338985745826f728567afa77ea1deba878", "filename": "library/proc_macro/src/bridge/client.rs", "status": "modified", "additions": 85, "deletions": 55, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/55f052d9c927699e0f69b937ac93701442155d39/library%2Fproc_macro%2Fsrc%2Fbridge%2Fclient.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55f052d9c927699e0f69b937ac93701442155d39/library%2Fproc_macro%2Fsrc%2Fbridge%2Fclient.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Fbridge%2Fclient.rs?ref=55f052d9c927699e0f69b937ac93701442155d39", "patch": "@@ -230,6 +230,20 @@ impl Clone for SourceFile {\n     }\n }\n \n+impl Span {\n+    pub(crate) fn def_site() -> Span {\n+        Bridge::with(|bridge| bridge.context.def_site)\n+    }\n+\n+    pub(crate) fn call_site() -> Span {\n+        Bridge::with(|bridge| bridge.context.call_site)\n+    }\n+\n+    pub(crate) fn mixed_site() -> Span {\n+        Bridge::with(|bridge| bridge.context.mixed_site)\n+    }\n+}\n+\n impl fmt::Debug for Span {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         f.write_str(&self.debug())\n@@ -263,6 +277,21 @@ macro_rules! define_client_side {\n }\n with_api!(self, self, define_client_side);\n \n+struct Bridge<'a> {\n+    /// Reusable buffer (only `clear`-ed, never shrunk), primarily\n+    /// used for making requests.\n+    cached_buffer: Buffer,\n+\n+    /// Server-side function that the client uses to make requests.\n+    dispatch: closure::Closure<'a, Buffer, Buffer>,\n+\n+    /// Provided context for this macro expansion.\n+    context: ExpnContext<Span>,\n+}\n+\n+impl<'a> !Send for Bridge<'a> {}\n+impl<'a> !Sync for Bridge<'a> {}\n+\n enum BridgeState<'a> {\n     /// No server is currently connected to this client.\n     NotConnected,\n@@ -305,34 +334,6 @@ impl BridgeState<'_> {\n }\n \n impl Bridge<'_> {\n-    pub(crate) fn is_available() -> bool {\n-        BridgeState::with(|state| match state {\n-            BridgeState::Connected(_) | BridgeState::InUse => true,\n-            BridgeState::NotConnected => false,\n-        })\n-    }\n-\n-    fn enter<R>(self, f: impl FnOnce() -> R) -> R {\n-        let force_show_panics = self.force_show_panics;\n-        // Hide the default panic output within `proc_macro` expansions.\n-        // NB. the server can't do this because it may use a different libstd.\n-        static HIDE_PANICS_DURING_EXPANSION: Once = Once::new();\n-        HIDE_PANICS_DURING_EXPANSION.call_once(|| {\n-            let prev = panic::take_hook();\n-            panic::set_hook(Box::new(move |info| {\n-                let show = BridgeState::with(|state| match state {\n-                    BridgeState::NotConnected => true,\n-                    BridgeState::Connected(_) | BridgeState::InUse => force_show_panics,\n-                });\n-                if show {\n-                    prev(info)\n-                }\n-            }));\n-        });\n-\n-        BRIDGE_STATE.with(|state| state.set(BridgeState::Connected(self), f))\n-    }\n-\n     fn with<R>(f: impl FnOnce(&mut Bridge<'_>) -> R) -> R {\n         BridgeState::with(|state| match state {\n             BridgeState::NotConnected => {\n@@ -346,6 +347,13 @@ impl Bridge<'_> {\n     }\n }\n \n+pub(crate) fn is_available() -> bool {\n+    BridgeState::with(|state| match state {\n+        BridgeState::Connected(_) | BridgeState::InUse => true,\n+        BridgeState::NotConnected => false,\n+    })\n+}\n+\n /// A client-side RPC entry-point, which may be using a different `proc_macro`\n /// from the one used by the server, but can be invoked compatibly.\n ///\n@@ -363,7 +371,7 @@ pub struct Client<I, O> {\n     // a wrapper `fn` pointer, once `const fn` can reference `static`s.\n     pub(super) get_handle_counters: extern \"C\" fn() -> &'static HandleCounters,\n \n-    pub(super) run: extern \"C\" fn(Bridge<'_>) -> Buffer,\n+    pub(super) run: extern \"C\" fn(BridgeConfig<'_>) -> Buffer,\n \n     pub(super) _marker: PhantomData<fn(I) -> O>,\n }\n@@ -375,40 +383,62 @@ impl<I, O> Clone for Client<I, O> {\n     }\n }\n \n+fn maybe_install_panic_hook(force_show_panics: bool) {\n+    // Hide the default panic output within `proc_macro` expansions.\n+    // NB. the server can't do this because it may use a different libstd.\n+    static HIDE_PANICS_DURING_EXPANSION: Once = Once::new();\n+    HIDE_PANICS_DURING_EXPANSION.call_once(|| {\n+        let prev = panic::take_hook();\n+        panic::set_hook(Box::new(move |info| {\n+            let show = BridgeState::with(|state| match state {\n+                BridgeState::NotConnected => true,\n+                BridgeState::Connected(_) | BridgeState::InUse => force_show_panics,\n+            });\n+            if show {\n+                prev(info)\n+            }\n+        }));\n+    });\n+}\n+\n /// Client-side helper for handling client panics, entering the bridge,\n /// deserializing input and serializing output.\n // FIXME(eddyb) maybe replace `Bridge::enter` with this?\n fn run_client<A: for<'a, 's> DecodeMut<'a, 's, ()>, R: Encode<()>>(\n-    mut bridge: Bridge<'_>,\n+    config: BridgeConfig<'_>,\n     f: impl FnOnce(A) -> R,\n ) -> Buffer {\n-    // The initial `cached_buffer` contains the input.\n-    let mut buf = bridge.cached_buffer.take();\n+    let BridgeConfig { input: mut buf, dispatch, force_show_panics, .. } = config;\n \n     panic::catch_unwind(panic::AssertUnwindSafe(|| {\n-        bridge.enter(|| {\n-            let reader = &mut &buf[..];\n-            let input = A::decode(reader, &mut ());\n-\n-            // Put the `cached_buffer` back in the `Bridge`, for requests.\n-            Bridge::with(|bridge| bridge.cached_buffer = buf.take());\n-\n-            let output = f(input);\n-\n-            // Take the `cached_buffer` back out, for the output value.\n-            buf = Bridge::with(|bridge| bridge.cached_buffer.take());\n-\n-            // HACK(eddyb) Separate encoding a success value (`Ok(output)`)\n-            // from encoding a panic (`Err(e: PanicMessage)`) to avoid\n-            // having handles outside the `bridge.enter(|| ...)` scope, and\n-            // to catch panics that could happen while encoding the success.\n-            //\n-            // Note that panics should be impossible beyond this point, but\n-            // this is defensively trying to avoid any accidental panicking\n-            // reaching the `extern \"C\"` (which should `abort` but might not\n-            // at the moment, so this is also potentially preventing UB).\n-            buf.clear();\n-            Ok::<_, ()>(output).encode(&mut buf, &mut ());\n+        maybe_install_panic_hook(force_show_panics);\n+\n+        let reader = &mut &buf[..];\n+        let (input, context) = <(A, ExpnContext<Span>)>::decode(reader, &mut ());\n+\n+        // Put the buffer we used for input back in the `Bridge` for requests.\n+        let new_state =\n+            BridgeState::Connected(Bridge { cached_buffer: buf.take(), dispatch, context });\n+\n+        BRIDGE_STATE.with(|state| {\n+            state.set(new_state, || {\n+                let output = f(input);\n+\n+                // Take the `cached_buffer` back out, for the output value.\n+                buf = Bridge::with(|bridge| bridge.cached_buffer.take());\n+\n+                // HACK(eddyb) Separate encoding a success value (`Ok(output)`)\n+                // from encoding a panic (`Err(e: PanicMessage)`) to avoid\n+                // having handles outside the `bridge.enter(|| ...)` scope, and\n+                // to catch panics that could happen while encoding the success.\n+                //\n+                // Note that panics should be impossible beyond this point, but\n+                // this is defensively trying to avoid any accidental panicking\n+                // reaching the `extern \"C\"` (which should `abort` but might not\n+                // at the moment, so this is also potentially preventing UB).\n+                buf.clear();\n+                Ok::<_, ()>(output).encode(&mut buf, &mut ());\n+            })\n         })\n     }))\n     .map_err(PanicMessage::from)"}, {"sha": "91d2d0f3ccc9fcedf8aafba309a0c2f2b1f9caf3", "filename": "library/proc_macro/src/bridge/mod.rs", "status": "modified", "additions": 39, "deletions": 11, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/55f052d9c927699e0f69b937ac93701442155d39/library%2Fproc_macro%2Fsrc%2Fbridge%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55f052d9c927699e0f69b937ac93701442155d39/library%2Fproc_macro%2Fsrc%2Fbridge%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Fbridge%2Fmod.rs?ref=55f052d9c927699e0f69b937ac93701442155d39", "patch": "@@ -151,9 +151,6 @@ macro_rules! with_api {\n             },\n             Span {\n                 fn debug($self: $S::Span) -> String;\n-                fn def_site() -> $S::Span;\n-                fn call_site() -> $S::Span;\n-                fn mixed_site() -> $S::Span;\n                 fn source_file($self: $S::Span) -> $S::SourceFile;\n                 fn parent($self: $S::Span) -> Option<$S::Span>;\n                 fn source($self: $S::Span) -> $S::Span;\n@@ -213,16 +210,15 @@ use buffer::Buffer;\n pub use rpc::PanicMessage;\n use rpc::{Decode, DecodeMut, Encode, Reader, Writer};\n \n-/// An active connection between a server and a client.\n-/// The server creates the bridge (`Bridge::run_server` in `server.rs`),\n-/// then passes it to the client through the function pointer in the `run`\n-/// field of `client::Client`. The client holds its copy of the `Bridge`\n+/// Configuration for establishing an active connection between a server and a\n+/// client.  The server creates the bridge config (`run_server` in `server.rs`),\n+/// then passes it to the client through the function pointer in the `run` field\n+/// of `client::Client`. The client constructs a local `Bridge` from the config\n /// in TLS during its execution (`Bridge::{enter, with}` in `client.rs`).\n #[repr(C)]\n-pub struct Bridge<'a> {\n-    /// Reusable buffer (only `clear`-ed, never shrunk), primarily\n-    /// used for making requests, but also for passing input to client.\n-    cached_buffer: Buffer,\n+pub struct BridgeConfig<'a> {\n+    /// Buffer used to pass initial input to the client.\n+    input: Buffer,\n \n     /// Server-side function that the client uses to make requests.\n     dispatch: closure::Closure<'a, Buffer, Buffer>,\n@@ -379,6 +375,25 @@ rpc_encode_decode!(\n );\n \n macro_rules! mark_compound {\n+    (struct $name:ident <$($T:ident),+> { $($field:ident),* $(,)? }) => {\n+        impl<$($T: Mark),+> Mark for $name <$($T),+> {\n+            type Unmarked = $name <$($T::Unmarked),+>;\n+            fn mark(unmarked: Self::Unmarked) -> Self {\n+                $name {\n+                    $($field: Mark::mark(unmarked.$field)),*\n+                }\n+            }\n+        }\n+\n+        impl<$($T: Unmark),+> Unmark for $name <$($T),+> {\n+            type Unmarked = $name <$($T::Unmarked),+>;\n+            fn unmark(self) -> Self::Unmarked {\n+                $name {\n+                    $($field: Unmark::unmark(self.$field)),*\n+                }\n+            }\n+        }\n+    };\n     (enum $name:ident <$($T:ident),+> { $($variant:ident $(($field:ident))?),* $(,)? }) => {\n         impl<$($T: Mark),+> Mark for $name <$($T),+> {\n             type Unmarked = $name <$($T::Unmarked),+>;\n@@ -449,3 +464,16 @@ compound_traits!(\n         Literal(tt),\n     }\n );\n+\n+/// Context provided alongside the initial inputs for a macro expansion.\n+/// Provides values such as spans which are used frequently to avoid RPC.\n+#[derive(Clone)]\n+struct ExpnContext<S> {\n+    def_site: S,\n+    call_site: S,\n+    mixed_site: S,\n+}\n+\n+compound_traits!(\n+    struct ExpnContext<Sp> { def_site, call_site, mixed_site }\n+);"}, {"sha": "907ad256e4b432683671ffdb7158b71e2f774b7b", "filename": "library/proc_macro/src/bridge/selfless_reify.rs", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/55f052d9c927699e0f69b937ac93701442155d39/library%2Fproc_macro%2Fsrc%2Fbridge%2Fselfless_reify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55f052d9c927699e0f69b937ac93701442155d39/library%2Fproc_macro%2Fsrc%2Fbridge%2Fselfless_reify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Fbridge%2Fselfless_reify.rs?ref=55f052d9c927699e0f69b937ac93701442155d39", "patch": "@@ -75,9 +75,10 @@ macro_rules! define_reify_functions {\n define_reify_functions! {\n     fn _reify_to_extern_c_fn_unary<A, R> for extern \"C\" fn(arg: A) -> R;\n \n-    // HACK(eddyb) this abstraction is used with `for<'a> fn(Bridge<'a>) -> T`\n-    // but that doesn't work with just `reify_to_extern_c_fn_unary` because of\n-    // the `fn` pointer type being \"higher-ranked\" (i.e. the `for<'a>` binder).\n-    // FIXME(eddyb) try to remove the lifetime from `Bridge`, that'd help.\n-    fn reify_to_extern_c_fn_hrt_bridge<R> for extern \"C\" fn(bridge: super::Bridge<'_>) -> R;\n+    // HACK(eddyb) this abstraction is used with `for<'a> fn(BridgeConfig<'a>)\n+    // -> T` but that doesn't work with just `reify_to_extern_c_fn_unary`\n+    // because of the `fn` pointer type being \"higher-ranked\" (i.e. the\n+    // `for<'a>` binder).\n+    // FIXME(eddyb) try to remove the lifetime from `BridgeConfig`, that'd help.\n+    fn reify_to_extern_c_fn_hrt_bridge<R> for extern \"C\" fn(bridge: super::BridgeConfig<'_>) -> R;\n }"}, {"sha": "d9a6ce81e4e7c8ef12d579c5b32b9918561a620f", "filename": "library/proc_macro/src/bridge/server.rs", "status": "modified", "additions": 39, "deletions": 14, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/55f052d9c927699e0f69b937ac93701442155d39/library%2Fproc_macro%2Fsrc%2Fbridge%2Fserver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55f052d9c927699e0f69b937ac93701442155d39/library%2Fproc_macro%2Fsrc%2Fbridge%2Fserver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Fbridge%2Fserver.rs?ref=55f052d9c927699e0f69b937ac93701442155d39", "patch": "@@ -30,6 +30,13 @@ macro_rules! associated_fn {\n     ($($item:tt)*) => ($($item)*;)\n }\n \n+/// Helper methods defined by `Server` types not invoked over RPC.\n+pub trait Context: Types {\n+    fn def_site(&mut self) -> Self::Span;\n+    fn call_site(&mut self) -> Self::Span;\n+    fn mixed_site(&mut self) -> Self::Span;\n+}\n+\n macro_rules! declare_server_traits {\n     ($($name:ident {\n         $(fn $method:ident($($arg:ident: $arg_ty:ty),* $(,)?) $(-> $ret_ty:ty)?;)*\n@@ -38,14 +45,26 @@ macro_rules! declare_server_traits {\n             $(associated_fn!(fn $method(&mut self, $($arg: $arg_ty),*) $(-> $ret_ty)?);)*\n         })*\n \n-        pub trait Server: Types $(+ $name)* {}\n-        impl<S: Types $(+ $name)*> Server for S {}\n+        pub trait Server: Types + Context $(+ $name)* {}\n+        impl<S: Types + Context $(+ $name)*> Server for S {}\n     }\n }\n with_api!(Self, self_, declare_server_traits);\n \n pub(super) struct MarkedTypes<S: Types>(S);\n \n+impl<S: Context> Context for MarkedTypes<S> {\n+    fn def_site(&mut self) -> Self::Span {\n+        <_>::mark(Context::def_site(&mut self.0))\n+    }\n+    fn call_site(&mut self) -> Self::Span {\n+        <_>::mark(Context::call_site(&mut self.0))\n+    }\n+    fn mixed_site(&mut self) -> Self::Span {\n+        <_>::mark(Context::mixed_site(&mut self.0))\n+    }\n+}\n+\n macro_rules! define_mark_types_impls {\n     ($($name:ident {\n         $(fn $method:ident($($arg:ident: $arg_ty:ty),* $(,)?) $(-> $ret_ty:ty)?;)*\n@@ -120,7 +139,7 @@ pub trait ExecutionStrategy {\n         &self,\n         dispatcher: &mut impl DispatcherTrait,\n         input: Buffer,\n-        run_client: extern \"C\" fn(Bridge<'_>) -> Buffer,\n+        run_client: extern \"C\" fn(BridgeConfig<'_>) -> Buffer,\n         force_show_panics: bool,\n     ) -> Buffer;\n }\n@@ -132,13 +151,13 @@ impl ExecutionStrategy for SameThread {\n         &self,\n         dispatcher: &mut impl DispatcherTrait,\n         input: Buffer,\n-        run_client: extern \"C\" fn(Bridge<'_>) -> Buffer,\n+        run_client: extern \"C\" fn(BridgeConfig<'_>) -> Buffer,\n         force_show_panics: bool,\n     ) -> Buffer {\n         let mut dispatch = |buf| dispatcher.dispatch(buf);\n \n-        run_client(Bridge {\n-            cached_buffer: input,\n+        run_client(BridgeConfig {\n+            input,\n             dispatch: (&mut dispatch).into(),\n             force_show_panics,\n             _marker: marker::PhantomData,\n@@ -156,7 +175,7 @@ impl ExecutionStrategy for CrossThread1 {\n         &self,\n         dispatcher: &mut impl DispatcherTrait,\n         input: Buffer,\n-        run_client: extern \"C\" fn(Bridge<'_>) -> Buffer,\n+        run_client: extern \"C\" fn(BridgeConfig<'_>) -> Buffer,\n         force_show_panics: bool,\n     ) -> Buffer {\n         use std::sync::mpsc::channel;\n@@ -170,8 +189,8 @@ impl ExecutionStrategy for CrossThread1 {\n                 res_rx.recv().unwrap()\n             };\n \n-            run_client(Bridge {\n-                cached_buffer: input,\n+            run_client(BridgeConfig {\n+                input,\n                 dispatch: (&mut dispatch).into(),\n                 force_show_panics,\n                 _marker: marker::PhantomData,\n@@ -193,7 +212,7 @@ impl ExecutionStrategy for CrossThread2 {\n         &self,\n         dispatcher: &mut impl DispatcherTrait,\n         input: Buffer,\n-        run_client: extern \"C\" fn(Bridge<'_>) -> Buffer,\n+        run_client: extern \"C\" fn(BridgeConfig<'_>) -> Buffer,\n         force_show_panics: bool,\n     ) -> Buffer {\n         use std::sync::{Arc, Mutex};\n@@ -219,8 +238,8 @@ impl ExecutionStrategy for CrossThread2 {\n                 }\n             };\n \n-            let r = run_client(Bridge {\n-                cached_buffer: input,\n+            let r = run_client(BridgeConfig {\n+                input,\n                 dispatch: (&mut dispatch).into(),\n                 force_show_panics,\n                 _marker: marker::PhantomData,\n@@ -258,14 +277,20 @@ fn run_server<\n     handle_counters: &'static client::HandleCounters,\n     server: S,\n     input: I,\n-    run_client: extern \"C\" fn(Bridge<'_>) -> Buffer,\n+    run_client: extern \"C\" fn(BridgeConfig<'_>) -> Buffer,\n     force_show_panics: bool,\n ) -> Result<O, PanicMessage> {\n     let mut dispatcher =\n         Dispatcher { handle_store: HandleStore::new(handle_counters), server: MarkedTypes(server) };\n \n+    let expn_context = ExpnContext {\n+        def_site: dispatcher.server.def_site(),\n+        call_site: dispatcher.server.call_site(),\n+        mixed_site: dispatcher.server.mixed_site(),\n+    };\n+\n     let mut buf = Buffer::new();\n-    input.encode(&mut buf, &mut dispatcher.handle_store);\n+    (input, expn_context).encode(&mut buf, &mut dispatcher.handle_store);\n \n     buf = strategy.run_bridge_and_client(&mut dispatcher, buf, run_client, force_show_panics);\n "}, {"sha": "771ee50e138617fc1528b680664f04b3b9f15bc5", "filename": "library/proc_macro/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/55f052d9c927699e0f69b937ac93701442155d39/library%2Fproc_macro%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/55f052d9c927699e0f69b937ac93701442155d39/library%2Fproc_macro%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fproc_macro%2Fsrc%2Flib.rs?ref=55f052d9c927699e0f69b937ac93701442155d39", "patch": "@@ -60,7 +60,7 @@ use std::{error, fmt, iter};\n /// inside of a procedural macro, false if invoked from any other binary.\n #[stable(feature = \"proc_macro_is_available\", since = \"1.57.0\")]\n pub fn is_available() -> bool {\n-    bridge::Bridge::is_available()\n+    bridge::client::is_available()\n }\n \n /// The main type provided by this crate, representing an abstract stream of"}]}