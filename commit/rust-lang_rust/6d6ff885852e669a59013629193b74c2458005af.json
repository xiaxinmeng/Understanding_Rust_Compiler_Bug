{"sha": "6d6ff885852e669a59013629193b74c2458005af", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZkNmZmODg1ODUyZTY2OWE1OTAxMzYyOTE5M2I3NGMyNDU4MDA1YWY=", "commit": {"author": {"name": "Shotaro Yamada", "email": "sinkuu@sinkuu.xyz", "date": "2018-10-25T13:02:46Z"}, "committer": {"name": "Shotaro Yamada", "email": "sinkuu@sinkuu.xyz", "date": "2018-10-25T16:16:14Z"}, "message": "Refactor", "tree": {"sha": "98d9177cfe368166d02f76bd0bae14d2f5f81809", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/98d9177cfe368166d02f76bd0bae14d2f5f81809"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6d6ff885852e669a59013629193b74c2458005af", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6d6ff885852e669a59013629193b74c2458005af", "html_url": "https://github.com/rust-lang/rust/commit/6d6ff885852e669a59013629193b74c2458005af", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6d6ff885852e669a59013629193b74c2458005af/comments", "author": {"login": "sinkuu", "id": 7091080, "node_id": "MDQ6VXNlcjcwOTEwODA=", "avatar_url": "https://avatars.githubusercontent.com/u/7091080?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sinkuu", "html_url": "https://github.com/sinkuu", "followers_url": "https://api.github.com/users/sinkuu/followers", "following_url": "https://api.github.com/users/sinkuu/following{/other_user}", "gists_url": "https://api.github.com/users/sinkuu/gists{/gist_id}", "starred_url": "https://api.github.com/users/sinkuu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sinkuu/subscriptions", "organizations_url": "https://api.github.com/users/sinkuu/orgs", "repos_url": "https://api.github.com/users/sinkuu/repos", "events_url": "https://api.github.com/users/sinkuu/events{/privacy}", "received_events_url": "https://api.github.com/users/sinkuu/received_events", "type": "User", "site_admin": false}, "committer": {"login": "sinkuu", "id": 7091080, "node_id": "MDQ6VXNlcjcwOTEwODA=", "avatar_url": "https://avatars.githubusercontent.com/u/7091080?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sinkuu", "html_url": "https://github.com/sinkuu", "followers_url": "https://api.github.com/users/sinkuu/followers", "following_url": "https://api.github.com/users/sinkuu/following{/other_user}", "gists_url": "https://api.github.com/users/sinkuu/gists{/gist_id}", "starred_url": "https://api.github.com/users/sinkuu/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sinkuu/subscriptions", "organizations_url": "https://api.github.com/users/sinkuu/orgs", "repos_url": "https://api.github.com/users/sinkuu/repos", "events_url": "https://api.github.com/users/sinkuu/events{/privacy}", "received_events_url": "https://api.github.com/users/sinkuu/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9a150b4aa123a6d67fbf8819fe67f2ef1015b726", "url": "https://api.github.com/repos/rust-lang/rust/commits/9a150b4aa123a6d67fbf8819fe67f2ef1015b726", "html_url": "https://github.com/rust-lang/rust/commit/9a150b4aa123a6d67fbf8819fe67f2ef1015b726"}], "stats": {"total": 146, "additions": 67, "deletions": 79}, "files": [{"sha": "85f8b525677be506f9cde1d34bd72971facaa06b", "filename": "clippy_lints/src/redundant_clone.rs", "status": "modified", "additions": 67, "deletions": 79, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/6d6ff885852e669a59013629193b74c2458005af/clippy_lints%2Fsrc%2Fredundant_clone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d6ff885852e669a59013629193b74c2458005af/clippy_lints%2Fsrc%2Fredundant_clone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/clippy_lints%2Fsrc%2Fredundant_clone.rs?ref=6d6ff885852e669a59013629193b74c2458005af", "patch": "@@ -29,6 +29,15 @@ use crate::utils::{\n use if_chain::if_chain;\n use std::convert::TryFrom;\n \n+macro_rules! unwrap_or_continue {\n+    ($x:expr) => {\n+        match $x {\n+            Some(x) => x,\n+            None => continue,\n+        }\n+    };\n+}\n+\n /// **What it does:** Checks for a redudant `clone()` (and its relatives) which clones an owned\n /// value that is going to be dropped without further use.\n ///\n@@ -87,40 +96,15 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for RedundantClone {\n         let def_id = cx.tcx.hir.body_owner_def_id(body.id());\n         let mir = cx.tcx.optimized_mir(def_id);\n \n-        // Looks for `call(x: &T)` where `T: !Copy`\n-        let call = |kind: &mir::TerminatorKind<'tcx>| -> Option<(def_id::DefId, mir::Local, ty::Ty<'tcx>)> {\n-            if_chain! {\n-                if let TerminatorKind::Call { func, args, .. } = kind;\n-                if args.len() == 1;\n-                if let mir::Operand::Move(mir::Place::Local(local)) = &args[0];\n-                if let ty::FnDef(def_id, _) = func.ty(&*mir, cx.tcx).sty;\n-                if let (inner_ty, 1) = walk_ptrs_ty_depth(args[0].ty(&*mir, cx.tcx));\n-                if !is_copy(cx, inner_ty);\n-                then {\n-                    Some((def_id, *local, inner_ty))\n-                } else {\n-                    None\n-                }\n-            }\n-        };\n-\n         for (bb, bbdata) in mir.basic_blocks().iter_enumerated() {\n-            let terminator = if let Some(terminator) = &bbdata.terminator {\n-                terminator\n-            } else {\n-                continue;\n-            };\n+            let terminator = unwrap_or_continue!(&bbdata.terminator);\n \n             // Give up on loops\n             if terminator.successors().any(|s| *s == bb) {\n                 continue;\n             }\n \n-            let (fn_def_id, arg, arg_ty) = if let Some(t) = call(&terminator.kind) {\n-                t\n-            } else {\n-                continue;\n-            };\n+            let (fn_def_id, arg, arg_ty, _) = unwrap_or_continue!(is_call_with_ref_arg(cx, mir, &terminator.kind));\n \n             let from_borrow = match_def_path(cx.tcx, fn_def_id, &paths::CLONE_TRAIT_METHOD)\n                 || match_def_path(cx.tcx, fn_def_id, &paths::TO_OWNED_METHOD)\n@@ -135,43 +119,23 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for RedundantClone {\n                 continue;\n             }\n \n-            // _1 in MIR `{ _2 = &_1; clone(move _2); }` or `{ _2 = _1; to_path_buf(_2); }\n-            let cloned = if let Some(referent) = bbdata\n-                .statements\n-                .iter()\n-                .rev()\n-                .filter_map(|stmt| {\n-                    if let mir::StatementKind::Assign(mir::Place::Local(local), v) = &stmt.kind {\n-                        if *local == arg {\n-                            if from_deref {\n-                                // `r` is already a reference.\n-                                if let mir::Rvalue::Use(mir::Operand::Copy(mir::Place::Local(r))) = **v {\n-                                    return Some(r);\n-                                }\n-                            } else if let mir::Rvalue::Ref(_, _, mir::Place::Local(r)) = **v {\n-                                return Some(r);\n-                            }\n-                        }\n-                    }\n-\n-                    None\n-                })\n-                .next()\n-            {\n-                referent\n-            } else {\n-                continue;\n-            };\n+            // _1 in MIR `{ _2 = &_1; clone(move _2); }` or `{ _2 = _1; to_path_buf(_2); } (from_deref)\n+            // In case of `from_deref`, `arg` is already a reference since it is `deref`ed in the previous\n+            // block.\n+            let cloned = unwrap_or_continue!(find_stmt_assigns_to(arg, from_borrow, bbdata.statements.iter().rev()));\n \n             // _1 in MIR `{ _2 = &_1; _3 = deref(move _2); } -> { _4 = _3; to_path_buf(move _4); }`\n             let referent = if from_deref {\n                 let ps = mir.predecessors_for(bb);\n+                if ps.len() != 1 {\n+                    continue;\n+                }\n+                let pred_terminator = unwrap_or_continue!(&mir[ps[0]].terminator);\n+\n                 let pred_arg = if_chain! {\n-                    if ps.len() == 1;\n-                    if let Some(pred_terminator) = &mir[ps[0]].terminator;\n-                    if let mir::TerminatorKind::Call { destination: Some((res, _)), .. } = &pred_terminator.kind;\n+                    if let Some((pred_fn_def_id, pred_arg, pred_arg_ty, Some(res))) =\n+                        is_call_with_ref_arg(cx, mir, &pred_terminator.kind);\n                     if *res == mir::Place::Local(cloned);\n-                    if let Some((pred_fn_def_id, pred_arg, pred_arg_ty)) = call(&pred_terminator.kind);\n                     if match_def_path(cx.tcx, pred_fn_def_id, &paths::DEREF_TRAIT_METHOD);\n                     if match_type(cx, pred_arg_ty, &paths::PATH_BUF)\n                         || match_type(cx, pred_arg_ty, &paths::OS_STRING);\n@@ -182,27 +146,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for RedundantClone {\n                     }\n                 };\n \n-                if let Some(referent) = mir[ps[0]]\n-                    .statements\n-                    .iter()\n-                    .rev()\n-                    .filter_map(|stmt| {\n-                        if let mir::StatementKind::Assign(mir::Place::Local(l), v) = &stmt.kind {\n-                            if *l == pred_arg {\n-                                if let mir::Rvalue::Ref(_, _, mir::Place::Local(referent)) = **v {\n-                                    return Some(referent);\n-                                }\n-                            }\n-                        }\n-\n-                        None\n-                    })\n-                    .next()\n-                {\n-                    referent\n-                } else {\n-                    continue;\n-                }\n+                unwrap_or_continue!(find_stmt_assigns_to(pred_arg, true, mir[ps[0]].statements.iter().rev()))\n             } else {\n                 cloned\n             };\n@@ -261,6 +205,50 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for RedundantClone {\n     }\n }\n \n+/// If `kind` is `y = func(x: &T)` where `T: !Copy`, returns `(DefId of func, x, T, y)`.\n+fn is_call_with_ref_arg<'tcx>(\n+    cx: &LateContext<'_, 'tcx>,\n+    mir: &'tcx mir::Mir<'tcx>,\n+    kind: &'tcx mir::TerminatorKind<'tcx>,\n+) -> Option<(def_id::DefId, mir::Local, ty::Ty<'tcx>, Option<&'tcx mir::Place<'tcx>>)> {\n+    if_chain! {\n+        if let TerminatorKind::Call { func, args, destination, .. } = kind;\n+        if args.len() == 1;\n+        if let mir::Operand::Move(mir::Place::Local(local)) = &args[0];\n+        if let ty::FnDef(def_id, _) = func.ty(&*mir, cx.tcx).sty;\n+        if let (inner_ty, 1) = walk_ptrs_ty_depth(args[0].ty(&*mir, cx.tcx));\n+        if !is_copy(cx, inner_ty);\n+        then {\n+            Some((def_id, *local, inner_ty, destination.as_ref().map(|(dest, _)| dest)))\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+/// Finds the first `to = (&)from`, and returns `Some(from)`.\n+fn find_stmt_assigns_to<'a, 'tcx: 'a>(\n+    to: mir::Local,\n+    by_ref: bool,\n+    mut stmts: impl Iterator<Item = &'a mir::Statement<'tcx>>,\n+) -> Option<mir::Local> {\n+    stmts.find_map(|stmt| {\n+        if let mir::StatementKind::Assign(mir::Place::Local(local), v) = &stmt.kind {\n+            if *local == to {\n+                if by_ref {\n+                    if let mir::Rvalue::Ref(_, _, mir::Place::Local(r)) = **v {\n+                        return Some(r);\n+                    }\n+                } else if let mir::Rvalue::Use(mir::Operand::Copy(mir::Place::Local(r))) = **v {\n+                    return Some(r);\n+                }\n+            }\n+        }\n+\n+        None\n+    })\n+}\n+\n struct LocalUseVisitor {\n     local: mir::Local,\n     used_other_than_drop: bool,"}]}