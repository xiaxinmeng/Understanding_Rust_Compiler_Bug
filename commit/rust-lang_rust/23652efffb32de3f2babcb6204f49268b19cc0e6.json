{"sha": "23652efffb32de3f2babcb6204f49268b19cc0e6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIzNjUyZWZmZmIzMmRlM2YyYmFiY2I2MjA0ZjQ5MjY4YjE5Y2MwZTY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-11-15T21:22:22Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2014-11-18T17:26:30Z"}, "message": "Pull out the fn-sig sub/lub/glb code and generalize it into a `higher_ranked` module. Also moves the docs to a more suitable place.", "tree": {"sha": "9ea85f126e40a4d61d6b2df3fbc501cc3e6d85cd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9ea85f126e40a4d61d6b2df3fbc501cc3e6d85cd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/23652efffb32de3f2babcb6204f49268b19cc0e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/23652efffb32de3f2babcb6204f49268b19cc0e6", "html_url": "https://github.com/rust-lang/rust/commit/23652efffb32de3f2babcb6204f49268b19cc0e6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/23652efffb32de3f2babcb6204f49268b19cc0e6/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "058abcc2094f7657063748f038470076b1e73a63", "url": "https://api.github.com/repos/rust-lang/rust/commits/058abcc2094f7657063748f038470076b1e73a63", "html_url": "https://github.com/rust-lang/rust/commit/058abcc2094f7657063748f038470076b1e73a63"}], "stats": {"total": 1578, "additions": 877, "deletions": 701}, "files": [{"sha": "6012fa43eb55fdf28d23e19948b4fb67ac80f291", "filename": "src/librustc/middle/typeck/infer/error_reporting.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/23652efffb32de3f2babcb6204f49268b19cc0e6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23652efffb32de3f2babcb6204f49268b19cc0e6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Ferror_reporting.rs?ref=23652efffb32de3f2babcb6204f49268b19cc0e6", "patch": "@@ -1460,8 +1460,8 @@ impl<'a, 'tcx> ErrorReportingHelpers for InferCtxt<'a, 'tcx> {\n                 format!(\" for {}in function call\",\n                         bound_region_to_string(self.tcx, \"lifetime parameter \", true, br))\n             }\n-            infer::LateBoundRegion(_, br, infer::FnType) => {\n-                format!(\" for {}in function type\",\n+            infer::LateBoundRegion(_, br, infer::HigherRankedType) => {\n+                format!(\" for {}in generic type\",\n                         bound_region_to_string(self.tcx, \"lifetime parameter \", true, br))\n             }\n             infer::EarlyBoundRegion(_, name) => {"}, {"sha": "bb8c59f0259776dd4cf735af4c87cf10d186ab2f", "filename": "src/librustc/middle/typeck/infer/glb.rs", "status": "modified", "additions": 3, "deletions": 141, "changes": 144, "blob_url": "https://github.com/rust-lang/rust/blob/23652efffb32de3f2babcb6204f49268b19cc0e6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23652efffb32de3f2babcb6204f49268b19cc0e6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fglb.rs?ref=23652efffb32de3f2babcb6204f49268b19cc0e6", "patch": "@@ -10,23 +10,18 @@\n \n \n use middle::ty::{BuiltinBounds};\n-use middle::ty::RegionVid;\n use middle::ty;\n use middle::typeck::infer::combine::*;\n use middle::typeck::infer::lattice::*;\n use middle::typeck::infer::equate::Equate;\n-use middle::typeck::infer::fold_regions_in_sig;\n-use middle::typeck::infer::LateBoundRegionConversionTime::FnType;\n+use middle::typeck::infer::higher_ranked::HigherRankedRelations;\n use middle::typeck::infer::lub::Lub;\n-use middle::typeck::infer::region_inference::RegionMark;\n use middle::typeck::infer::sub::Sub;\n use middle::typeck::infer::{cres, InferCtxt};\n use middle::typeck::infer::{TypeTrace, Subtype};\n use syntax::ast::{Many, Once, MutImmutable, MutMutable};\n-use syntax::ast::{NormalFn, UnsafeFn, NodeId};\n+use syntax::ast::{NormalFn, UnsafeFn};\n use syntax::ast::{Onceness, FnStyle};\n-use util::common::{indenter};\n-use util::nodemap::FnvHashMap;\n use util::ppaux::mt_to_string;\n use util::ppaux::Repr;\n \n@@ -128,139 +123,6 @@ impl<'f, 'tcx> Combine<'tcx> for Glb<'f, 'tcx> {\n     }\n \n     fn fn_sigs(&self, a: &ty::FnSig, b: &ty::FnSig) -> cres<ty::FnSig> {\n-        // Note: this is a subtle algorithm.  For a full explanation,\n-        // please see the large comment in `region_inference.rs`.\n-\n-        debug!(\"{}.fn_sigs({}, {})\",\n-               self.tag(), a.repr(self.fields.infcx.tcx), b.repr(self.fields.infcx.tcx));\n-        let _indenter = indenter();\n-\n-        // Make a mark so we can examine \"all bindings that were\n-        // created as part of this type comparison\".\n-        let mark = self.fields.infcx.region_vars.mark();\n-\n-        // Instantiate each bound region with a fresh region variable.\n-        let (a_with_fresh, a_map) =\n-            self.fields.infcx.replace_late_bound_regions_with_fresh_var(\n-                a.binder_id, self.trace().span(), FnType, a);\n-        let a_vars = var_ids(self, &a_map);\n-        let (b_with_fresh, b_map) =\n-            self.fields.infcx.replace_late_bound_regions_with_fresh_var(\n-                b.binder_id, self.trace().span(), FnType, b);\n-        let b_vars = var_ids(self, &b_map);\n-\n-        // Collect constraints.\n-        let sig0 = try!(super_fn_sigs(self, &a_with_fresh, &b_with_fresh));\n-        debug!(\"sig0 = {}\", sig0.repr(self.fields.infcx.tcx));\n-\n-        // Generalize the regions appearing in fn_ty0 if possible\n-        let new_vars =\n-            self.fields.infcx.region_vars.vars_created_since_mark(mark);\n-        let sig1 =\n-            fold_regions_in_sig(\n-                self.fields.infcx.tcx,\n-                &sig0,\n-                |r| {\n-                generalize_region(self,\n-                                  mark,\n-                                  new_vars.as_slice(),\n-                                  sig0.binder_id,\n-                                  &a_map,\n-                                  a_vars.as_slice(),\n-                                  b_vars.as_slice(),\n-                                  r)\n-            });\n-        debug!(\"sig1 = {}\", sig1.repr(self.fields.infcx.tcx));\n-        return Ok(sig1);\n-\n-        fn generalize_region(this: &Glb,\n-                             mark: RegionMark,\n-                             new_vars: &[RegionVid],\n-                             new_binder_id: NodeId,\n-                             a_map: &FnvHashMap<ty::BoundRegion, ty::Region>,\n-                             a_vars: &[RegionVid],\n-                             b_vars: &[RegionVid],\n-                             r0: ty::Region) -> ty::Region {\n-            if !is_var_in_set(new_vars, r0) {\n-                assert!(!r0.is_bound());\n-                return r0;\n-            }\n-\n-            let tainted = this.fields.infcx.region_vars.tainted(mark, r0);\n-\n-            let mut a_r = None;\n-            let mut b_r = None;\n-            let mut only_new_vars = true;\n-            for r in tainted.iter() {\n-                if is_var_in_set(a_vars, *r) {\n-                    if a_r.is_some() {\n-                        return fresh_bound_variable(this, new_binder_id);\n-                    } else {\n-                        a_r = Some(*r);\n-                    }\n-                } else if is_var_in_set(b_vars, *r) {\n-                    if b_r.is_some() {\n-                        return fresh_bound_variable(this, new_binder_id);\n-                    } else {\n-                        b_r = Some(*r);\n-                    }\n-                } else if !is_var_in_set(new_vars, *r) {\n-                    only_new_vars = false;\n-                }\n-            }\n-\n-            // NB---I do not believe this algorithm computes\n-            // (necessarily) the GLB.  As written it can\n-            // spuriously fail. In particular, if there is a case\n-            // like: |fn(&a)| and fn(fn(&b)), where a and b are\n-            // free, it will return fn(&c) where c = GLB(a,b).  If\n-            // however this GLB is not defined, then the result is\n-            // an error, even though something like\n-            // \"fn<X>(fn(&X))\" where X is bound would be a\n-            // subtype of both of those.\n-            //\n-            // The problem is that if we were to return a bound\n-            // variable, we'd be computing a lower-bound, but not\n-            // necessarily the *greatest* lower-bound.\n-            //\n-            // Unfortunately, this problem is non-trivial to solve,\n-            // because we do not know at the time of computing the GLB\n-            // whether a GLB(a,b) exists or not, because we haven't\n-            // run region inference (or indeed, even fully computed\n-            // the region hierarchy!). The current algorithm seems to\n-            // works ok in practice.\n-\n-            if a_r.is_some() && b_r.is_some() && only_new_vars {\n-                // Related to exactly one bound variable from each fn:\n-                return rev_lookup(this, a_map, new_binder_id, a_r.unwrap());\n-            } else if a_r.is_none() && b_r.is_none() {\n-                // Not related to bound variables from either fn:\n-                assert!(!r0.is_bound());\n-                return r0;\n-            } else {\n-                // Other:\n-                return fresh_bound_variable(this, new_binder_id);\n-            }\n-        }\n-\n-        fn rev_lookup(this: &Glb,\n-                      a_map: &FnvHashMap<ty::BoundRegion, ty::Region>,\n-                      new_binder_id: NodeId,\n-                      r: ty::Region) -> ty::Region\n-        {\n-            for (a_br, a_r) in a_map.iter() {\n-                if *a_r == r {\n-                    return ty::ReLateBound(new_binder_id, *a_br);\n-                }\n-            }\n-            this.fields.infcx.tcx.sess.span_bug(\n-                this.fields.trace.origin.span(),\n-                format!(\"could not find original bound region for {}\",\n-                        r).as_slice())\n-        }\n-\n-        fn fresh_bound_variable(this: &Glb, binder_id: NodeId) -> ty::Region {\n-            this.fields.infcx.region_vars.new_bound(binder_id)\n-        }\n+        self.higher_ranked_glb(a, b)\n     }\n }"}, {"sha": "4c4452ac892361e4af91dd6eb450e044135d2f1d", "filename": "src/librustc/middle/typeck/infer/higher_ranked/doc.rs", "status": "added", "additions": 415, "deletions": 0, "changes": 415, "blob_url": "https://github.com/rust-lang/rust/blob/23652efffb32de3f2babcb6204f49268b19cc0e6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fhigher_ranked%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23652efffb32de3f2babcb6204f49268b19cc0e6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fhigher_ranked%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fhigher_ranked%2Fdoc.rs?ref=23652efffb32de3f2babcb6204f49268b19cc0e6", "patch": "@@ -0,0 +1,415 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+\n+# Skolemization and functions\n+\n+One of the trickiest and most subtle aspects of regions is dealing\n+with higher-ranked things which include bound region variables, such\n+as function types. I strongly suggest that if you want to understand\n+the situation, you read this paper (which is, admittedly, very long,\n+but you don't have to read the whole thing):\n+\n+http://research.microsoft.com/en-us/um/people/simonpj/papers/higher-rank/\n+\n+Although my explanation will never compete with SPJ's (for one thing,\n+his is approximately 100 pages), I will attempt to explain the basic\n+problem and also how we solve it. Note that the paper only discusses\n+subtyping, not the computation of LUB/GLB.\n+\n+The problem we are addressing is that there is a kind of subtyping\n+between functions with bound region parameters. Consider, for\n+example, whether the following relation holds:\n+\n+    for<'a> fn(&'a int) <: for<'b> fn(&'b int)? (Yes, a => b)\n+\n+The answer is that of course it does. These two types are basically\n+the same, except that in one we used the name `a` and one we used\n+the name `b`.\n+\n+In the examples that follow, it becomes very important to know whether\n+a lifetime is bound in a function type (that is, is a lifetime\n+parameter) or appears free (is defined in some outer scope).\n+Therefore, from now on I will always write the bindings explicitly,\n+using the Rust syntax `for<'a> fn(&'a int)` to indicate that `a` is a\n+lifetime parameter.\n+\n+Now let's consider two more function types. Here, we assume that the\n+`'b` lifetime is defined somewhere outside and hence is not a lifetime\n+parameter bound by the function type (it \"appears free\"):\n+\n+    for<'a> fn(&'a int) <: fn(&'b int)? (Yes, a => b)\n+\n+This subtyping relation does in fact hold. To see why, you have to\n+consider what subtyping means. One way to look at `T1 <: T2` is to\n+say that it means that it is always ok to treat an instance of `T1` as\n+if it had the type `T2`. So, with our functions, it is always ok to\n+treat a function that can take pointers with any lifetime as if it\n+were a function that can only take a pointer with the specific\n+lifetime `'b`. After all, `'b` is a lifetime, after all, and\n+the function can take values of any lifetime.\n+\n+You can also look at subtyping as the *is a* relationship. This amounts\n+to the same thing: a function that accepts pointers with any lifetime\n+*is a* function that accepts pointers with some specific lifetime.\n+\n+So, what if we reverse the order of the two function types, like this:\n+\n+    fn(&'b int) <: for<'a> fn(&'a int)? (No)\n+\n+Does the subtyping relationship still hold?  The answer of course is\n+no. In this case, the function accepts *only the lifetime `'b`*,\n+so it is not reasonable to treat it as if it were a function that\n+accepted any lifetime.\n+\n+What about these two examples:\n+\n+    for<'a,'b> fn(&'a int, &'b int) <: for<'a>    fn(&'a int, &'a int)? (Yes)\n+    for<'a>    fn(&'a int, &'a int) <: for<'a,'b> fn(&'a int, &'b int)? (No)\n+\n+Here, it is true that functions which take two pointers with any two\n+lifetimes can be treated as if they only accepted two pointers with\n+the same lifetime, but not the reverse.\n+\n+## The algorithm\n+\n+Here is the algorithm we use to perform the subtyping check:\n+\n+1. Replace all bound regions in the subtype with new variables\n+2. Replace all bound regions in the supertype with skolemized\n+   equivalents. A \"skolemized\" region is just a new fresh region\n+   name.\n+3. Check that the parameter and return types match as normal\n+4. Ensure that no skolemized regions 'leak' into region variables\n+   visible from \"the outside\"\n+\n+Let's walk through some examples and see how this algorithm plays out.\n+\n+#### First example\n+\n+We'll start with the first example, which was:\n+\n+    1. for<'a> fn(&'a T) <: for<'b> fn(&'b T)?        Yes: a -> b\n+\n+After steps 1 and 2 of the algorithm we will have replaced the types\n+like so:\n+\n+    1. fn(&'A T) <: fn(&'x T)?\n+\n+Here the upper case `&A` indicates a *region variable*, that is, a\n+region whose value is being inferred by the system. I also replaced\n+`&b` with `&x`---I'll use letters late in the alphabet (`x`, `y`, `z`)\n+to indicate skolemized region names. We can assume they don't appear\n+elsewhere. Note that neither the sub- nor the supertype bind any\n+region names anymore (as indicated by the absence of `<` and `>`).\n+\n+The next step is to check that the parameter types match. Because\n+parameters are contravariant, this means that we check whether:\n+\n+    &'x T <: &'A T\n+\n+Region pointers are contravariant so this implies that\n+\n+    &A <= &x\n+\n+must hold, where `<=` is the subregion relationship. Processing\n+*this* constrain simply adds a constraint into our graph that `&A <=\n+&x` and is considered successful (it can, for example, be satisfied by\n+choosing the value `&x` for `&A`).\n+\n+So far we have encountered no error, so the subtype check succeeds.\n+\n+#### The third example\n+\n+Now let's look first at the third example, which was:\n+\n+    3. fn(&'a T)    <: for<'b> fn(&'b T)?        No!\n+\n+After steps 1 and 2 of the algorithm we will have replaced the types\n+like so:\n+\n+    3. fn(&'a T) <: fn(&'x T)?\n+\n+This looks pretty much the same as before, except that on the LHS\n+`'a` was not bound, and hence was left as-is and not replaced with\n+a variable. The next step is again to check that the parameter types\n+match. This will ultimately require (as before) that `'a` <= `&x`\n+must hold: but this does not hold. `self` and `x` are both distinct\n+free regions. So the subtype check fails.\n+\n+#### Checking for skolemization leaks\n+\n+You may be wondering about that mysterious last step in the algorithm.\n+So far it has not been relevant. The purpose of that last step is to\n+catch something like *this*:\n+\n+    for<'a> fn() -> fn(&'a T) <: fn() -> for<'b> fn(&'b T)?   No.\n+\n+Here the function types are the same but for where the binding occurs.\n+The subtype returns a function that expects a value in precisely one\n+region. The supertype returns a function that expects a value in any\n+region. If we allow an instance of the subtype to be used where the\n+supertype is expected, then, someone could call the fn and think that\n+the return value has type `fn<b>(&'b T)` when it really has type\n+`fn(&'a T)` (this is case #3, above). Bad.\n+\n+So let's step through what happens when we perform this subtype check.\n+We first replace the bound regions in the subtype (the supertype has\n+no bound regions). This gives us:\n+\n+    fn() -> fn(&'A T) <: fn() -> for<'b> fn(&'b T)?\n+\n+Now we compare the return types, which are covariant, and hence we have:\n+\n+    fn(&'A T) <: for<'b> fn(&'b T)?\n+\n+Here we skolemize the bound region in the supertype to yield:\n+\n+    fn(&'A T) <: fn(&'x T)?\n+\n+And then proceed to compare the argument types:\n+\n+    &'x T <: &'A T\n+    'A <= 'x\n+\n+Finally, this is where it gets interesting!  This is where an error\n+*should* be reported. But in fact this will not happen. The reason why\n+is that `A` is a variable: we will infer that its value is the fresh\n+region `x` and think that everything is happy. In fact, this behavior\n+is *necessary*, it was key to the first example we walked through.\n+\n+The difference between this example and the first one is that the variable\n+`A` already existed at the point where the skolemization occurred. In\n+the first example, you had two functions:\n+\n+    for<'a> fn(&'a T) <: for<'b> fn(&'b T)\n+\n+and hence `&A` and `&x` were created \"together\". In general, the\n+intention of the skolemized names is that they are supposed to be\n+fresh names that could never be equal to anything from the outside.\n+But when inference comes into play, we might not be respecting this\n+rule.\n+\n+So the way we solve this is to add a fourth step that examines the\n+constraints that refer to skolemized names. Basically, consider a\n+non-directed verison of the constraint graph. Let `Tainted(x)` be the\n+set of all things reachable from a skolemized variable `x`.\n+`Tainted(x)` should not contain any regions that existed before the\n+step at which the skolemization was performed. So this case here\n+would fail because `&x` was created alone, but is relatable to `&A`.\n+\n+## Computing the LUB and GLB\n+\n+The paper I pointed you at is written for Haskell. It does not\n+therefore considering subtyping and in particular does not consider\n+LUB or GLB computation. We have to consider this. Here is the\n+algorithm I implemented.\n+\n+First though, let's discuss what we are trying to compute in more\n+detail. The LUB is basically the \"common supertype\" and the GLB is\n+\"common subtype\"; one catch is that the LUB should be the\n+*most-specific* common supertype and the GLB should be *most general*\n+common subtype (as opposed to any common supertype or any common\n+subtype).\n+\n+Anyway, to help clarify, here is a table containing some function\n+pairs and their LUB/GLB (for conciseness, in this table, I'm just\n+including the lifetimes here, not the rest of the types, and I'm\n+writing `fn<>` instead of `for<> fn`):\n+\n+```\n+Type 1                Type 2                LUB                    GLB\n+fn<'a>('a)            fn('X)                fn('X)                 fn<'a>('a)\n+fn('a)                fn('X)                --                     fn<'a>('a)\n+fn<'a,'b>('a, 'b)     fn<'x>('x, 'x)        fn<'a>('a, 'a)         fn<'a,'b>('a, 'b)\n+fn<'a,'b>('a, 'b, 'a) fn<'x,'y>('x, 'y, 'y) fn<'a>('a, 'a, 'a)     fn<'a,'b,'c>('a,'b,'c)\n+```\n+\n+### Conventions\n+\n+I use lower-case letters (e.g., `&a`) for bound regions and upper-case\n+letters for free regions (`&A`).  Region variables written with a\n+dollar-sign (e.g., `$a`).  I will try to remember to enumerate the\n+bound-regions on the fn type as well (e.g., `for<'a> fn(&a)`).\n+\n+### High-level summary\n+\n+Both the LUB and the GLB algorithms work in a similar fashion.  They\n+begin by replacing all bound regions (on both sides) with fresh region\n+inference variables.  Therefore, both functions are converted to types\n+that contain only free regions.  We can then compute the LUB/GLB in a\n+straightforward way, as described in `combine.rs`.  This results in an\n+interim type T.  The algorithms then examine the regions that appear\n+in T and try to, in some cases, replace them with bound regions to\n+yield the final result.\n+\n+To decide whether to replace a region `R` that appears in `T` with a\n+bound region, the algorithms make use of two bits of information.\n+First is a set `V` that contains all region variables created as part\n+of the LUB/GLB computation. `V` will contain the region variables\n+created to replace the bound regions in the input types, but it also\n+contains 'intermediate' variables created to represent the LUB/GLB of\n+individual regions.  Basically, when asked to compute the LUB/GLB of a\n+region variable with another region, the inferencer cannot oblige\n+immediately since the values of that variables are not known.\n+Therefore, it creates a new variable that is related to the two\n+regions.  For example, the LUB of two variables `$x` and `$y` is a\n+fresh variable `$z` that is constrained such that `$x <= $z` and `$y\n+<= $z`.  So `V` will contain these intermediate variables as well.\n+\n+The other important factor in deciding how to replace a region in T is\n+the function `Tainted($r)` which, for a region variable, identifies\n+all regions that the region variable is related to in some way\n+(`Tainted()` made an appearance in the subtype computation as well).\n+\n+### LUB\n+\n+The LUB algorithm proceeds in three steps:\n+\n+1. Replace all bound regions (on both sides) with fresh region\n+   inference variables.\n+2. Compute the LUB \"as normal\", meaning compute the GLB of each\n+   pair of argument types and the LUB of the return types and\n+   so forth.  Combine those to a new function type `F`.\n+3. Replace each region `R` that appears in `F` as follows:\n+   - Let `V` be the set of variables created during the LUB\n+     computational steps 1 and 2, as described in the previous section.\n+   - If `R` is not in `V`, replace `R` with itself.\n+   - If `Tainted(R)` contains a region that is not in `V`,\n+     replace `R` with itself.\n+   - Otherwise, select the earliest variable in `Tainted(R)` that originates\n+     from the left-hand side and replace `R` with the bound region that\n+     this variable was a replacement for.\n+\n+So, let's work through the simplest example: `fn(&A)` and `for<'a> fn(&a)`.\n+In this case, `&a` will be replaced with `$a` and the interim LUB type\n+`fn($b)` will be computed, where `$b=GLB(&A,$a)`.  Therefore, `V =\n+{$a, $b}` and `Tainted($b) = { $b, $a, &A }`.  When we go to replace\n+`$b`, we find that since `&A \\in Tainted($b)` is not a member of `V`,\n+we leave `$b` as is.  When region inference happens, `$b` will be\n+resolved to `&A`, as we wanted.\n+\n+Let's look at a more complex one: `fn(&a, &b)` and `fn(&x, &x)`.  In\n+this case, we'll end up with a (pre-replacement) LUB type of `fn(&g,\n+&h)` and a graph that looks like:\n+\n+```\n+     $a        $b     *--$x\n+       \\        \\    /  /\n+        \\        $h-*  /\n+         $g-----------*\n+```\n+\n+Here `$g` and `$h` are fresh variables that are created to represent\n+the LUB/GLB of things requiring inference.  This means that `V` and\n+`Tainted` will look like:\n+\n+```\n+V = {$a, $b, $g, $h, $x}\n+Tainted($g) = Tainted($h) = { $a, $b, $h, $g, $x }\n+```\n+\n+Therefore we replace both `$g` and `$h` with `$a`, and end up\n+with the type `fn(&a, &a)`.\n+\n+### GLB\n+\n+The procedure for computing the GLB is similar.  The difference lies\n+in computing the replacements for the various variables. For each\n+region `R` that appears in the type `F`, we again compute `Tainted(R)`\n+and examine the results:\n+\n+1. If `R` is not in `V`, it is not replaced.\n+2. Else, if `Tainted(R)` contains only variables in `V`, and it\n+   contains exactly one variable from the LHS and one variable from\n+   the RHS, then `R` can be mapped to the bound version of the\n+   variable from the LHS.\n+3. Else, if `Tainted(R)` contains no variable from the LHS and no\n+   variable from the RHS, then `R` can be mapped to itself.\n+4. Else, `R` is mapped to a fresh bound variable.\n+\n+These rules are pretty complex.  Let's look at some examples to see\n+how they play out.\n+\n+Out first example was `fn(&a)` and `fn(&X)`.  In this case, `&a` will\n+be replaced with `$a` and we will ultimately compute a\n+(pre-replacement) GLB type of `fn($g)` where `$g=LUB($a,&X)`.\n+Therefore, `V={$a,$g}` and `Tainted($g)={$g,$a,&X}.  To find the\n+replacement for `$g` we consult the rules above:\n+- Rule (1) does not apply because `$g \\in V`\n+- Rule (2) does not apply because `&X \\in Tainted($g)`\n+- Rule (3) does not apply because `$a \\in Tainted($g)`\n+- Hence, by rule (4), we replace `$g` with a fresh bound variable `&z`.\n+So our final result is `fn(&z)`, which is correct.\n+\n+The next example is `fn(&A)` and `fn(&Z)`. In this case, we will again\n+have a (pre-replacement) GLB of `fn(&g)`, where `$g = LUB(&A,&Z)`.\n+Therefore, `V={$g}` and `Tainted($g) = {$g, &A, &Z}`.  In this case,\n+by rule (3), `$g` is mapped to itself, and hence the result is\n+`fn($g)`.  This result is correct (in this case, at least), but it is\n+indicative of a case that *can* lead us into concluding that there is\n+no GLB when in fact a GLB does exist.  See the section \"Questionable\n+Results\" below for more details.\n+\n+The next example is `fn(&a, &b)` and `fn(&c, &c)`. In this case, as\n+before, we'll end up with `F=fn($g, $h)` where `Tainted($g) =\n+Tainted($h) = {$g, $h, $a, $b, $c}`.  Only rule (4) applies and hence\n+we'll select fresh bound variables `y` and `z` and wind up with\n+`fn(&y, &z)`.\n+\n+For the last example, let's consider what may seem trivial, but is\n+not: `fn(&a, &a)` and `fn(&b, &b)`.  In this case, we'll get `F=fn($g,\n+$h)` where `Tainted($g) = {$g, $a, $x}` and `Tainted($h) = {$h, $a,\n+$x}`.  Both of these sets contain exactly one bound variable from each\n+side, so we'll map them both to `&a`, resulting in `fn(&a, &a)`, which\n+is the desired result.\n+\n+### Shortcomings and correctness\n+\n+You may be wondering whether this algorithm is correct.  The answer is\n+\"sort of\".  There are definitely cases where they fail to compute a\n+result even though a correct result exists.  I believe, though, that\n+if they succeed, then the result is valid, and I will attempt to\n+convince you.  The basic argument is that the \"pre-replacement\" step\n+computes a set of constraints.  The replacements, then, attempt to\n+satisfy those constraints, using bound identifiers where needed.\n+\n+For now I will briefly go over the cases for LUB/GLB and identify\n+their intent:\n+\n+- LUB:\n+  - The region variables that are substituted in place of bound regions\n+    are intended to collect constraints on those bound regions.\n+  - If Tainted(R) contains only values in V, then this region is unconstrained\n+    and can therefore be generalized, otherwise it cannot.\n+- GLB:\n+  - The region variables that are substituted in place of bound regions\n+    are intended to collect constraints on those bound regions.\n+  - If Tainted(R) contains exactly one variable from each side, and\n+    only variables in V, that indicates that those two bound regions\n+    must be equated.\n+  - Otherwise, if Tainted(R) references any variables from left or right\n+    side, then it is trying to combine a bound region with a free one or\n+    multiple bound regions, so we need to select fresh bound regions.\n+\n+Sorry this is more of a shorthand to myself.  I will try to write up something\n+more convincing in the future.\n+\n+#### Where are the algorithms wrong?\n+\n+- The pre-replacement computation can fail even though using a\n+  bound-region would have succeeded.\n+- We will compute GLB(fn(fn($a)), fn(fn($b))) as fn($c) where $c is the\n+  GLB of $a and $b.  But if inference finds that $a and $b must be mapped\n+  to regions without a GLB, then this is effectively a failure to compute\n+  the GLB.  However, the result `fn<$c>(fn($c))` is a valid GLB.\n+\n+ */"}, {"sha": "09f0bbb2254ade3c9119f0d3f2c3ccc84f0b086b", "filename": "src/librustc/middle/typeck/infer/higher_ranked/mod.rs", "status": "added", "additions": 445, "deletions": 0, "changes": 445, "blob_url": "https://github.com/rust-lang/rust/blob/23652efffb32de3f2babcb6204f49268b19cc0e6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23652efffb32de3f2babcb6204f49268b19cc0e6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=23652efffb32de3f2babcb6204f49268b19cc0e6", "patch": "@@ -0,0 +1,445 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/*!\n+ * Helper routines for higher-ranked things. See the `doc` module at\n+ * the end of the file for details.\n+ */\n+\n+use middle::ty;\n+use middle::ty::replace_late_bound_regions;\n+use middle::typeck::infer::{mod, combine, cres, InferCtxt};\n+use middle::typeck::infer::combine::Combine;\n+use middle::typeck::infer::region_inference::{RegionMark};\n+use middle::ty_fold::{mod, HigherRankedFoldable, TypeFoldable};\n+use syntax::codemap::Span;\n+use util::nodemap::FnvHashMap;\n+use util::ppaux::{bound_region_to_string, Repr};\n+\n+pub trait HigherRankedCombineable : HigherRankedFoldable + TypeFoldable + Repr {\n+    fn super_combine<'tcx,C:Combine<'tcx>>(combiner: &C, a: &Self, b: &Self) -> cres<Self>;\n+}\n+\n+pub trait HigherRankedRelations {\n+    fn higher_ranked_sub<T>(&self, a: &T, b: &T) -> cres<T>\n+        where T : HigherRankedCombineable;\n+\n+    fn higher_ranked_lub<T>(&self, a: &T, b: &T) -> cres<T>\n+        where T : HigherRankedCombineable;\n+\n+    fn higher_ranked_glb<T>(&self, a: &T, b: &T) -> cres<T>\n+        where T : HigherRankedCombineable;\n+}\n+\n+impl<'tcx,C> HigherRankedRelations for C\n+    where C : Combine<'tcx>\n+{\n+    fn higher_ranked_sub<T>(&self, a: &T, b: &T) -> cres<T>\n+        where T : HigherRankedCombineable\n+    {\n+        debug!(\"higher_ranked_sub(a={}, b={})\",\n+               a.repr(self.tcx()), b.repr(self.tcx()));\n+\n+        // Rather than checking the subtype relationship between `a` and `b`\n+        // as-is, we need to do some extra work here in order to make sure\n+        // that function subtyping works correctly with respect to regions\n+        //\n+        // Note: this is a subtle algorithm.  For a full explanation,\n+        // please see the large comment at the end of the file in the (inlined) module\n+        // `doc`.\n+\n+        // Make a mark so we can examine \"all bindings that were\n+        // created as part of this type comparison\".\n+        let mark = self.infcx().region_vars.mark();\n+\n+        // First, we instantiate each bound region in the subtype with a fresh\n+        // region variable.\n+        let (a_prime, _) =\n+            self.infcx().replace_late_bound_regions_with_fresh_var(\n+                self.trace().origin.span(),\n+                infer::HigherRankedType,\n+                a);\n+\n+        // Second, we instantiate each bound region in the supertype with a\n+        // fresh concrete region.\n+        let (b_prime, skol_map) = {\n+            replace_late_bound_regions(self.tcx(), b, |br, _| {\n+                let skol = self.infcx().region_vars.new_skolemized(br);\n+                debug!(\"Bound region {} skolemized to {}\",\n+                       bound_region_to_string(self.tcx(), \"\", false, br),\n+                       skol);\n+                skol\n+            })\n+        };\n+\n+        debug!(\"a_prime={}\", a_prime.repr(self.tcx()));\n+        debug!(\"b_prime={}\", b_prime.repr(self.tcx()));\n+\n+        // Compare types now that bound regions have been replaced.\n+        let result = try!(HigherRankedCombineable::super_combine(self, &a_prime, &b_prime));\n+\n+        // Presuming type comparison succeeds, we need to check\n+        // that the skolemized regions do not \"leak\".\n+        let new_vars =\n+            self.infcx().region_vars.vars_created_since_mark(mark);\n+        for (&skol_br, &skol) in skol_map.iter() {\n+            let tainted = self.infcx().region_vars.tainted(mark, skol);\n+            for tainted_region in tainted.iter() {\n+                // Each skolemized should only be relatable to itself\n+                // or new variables:\n+                match *tainted_region {\n+                    ty::ReInfer(ty::ReVar(ref vid)) => {\n+                        if new_vars.iter().any(|x| x == vid) { continue; }\n+                    }\n+                    _ => {\n+                        if *tainted_region == skol { continue; }\n+                    }\n+                };\n+\n+                // A is not as polymorphic as B:\n+                if self.a_is_expected() {\n+                    debug!(\"Not as polymorphic!\");\n+                    return Err(ty::terr_regions_insufficiently_polymorphic(\n+                        skol_br, *tainted_region));\n+                } else {\n+                    debug!(\"Overly polymorphic!\");\n+                    return Err(ty::terr_regions_overly_polymorphic(\n+                        skol_br, *tainted_region));\n+                }\n+            }\n+        }\n+\n+        debug!(\"higher_ranked_sub: OK result={}\",\n+               result.repr(self.tcx()));\n+\n+        return Ok(result);\n+    }\n+\n+    fn higher_ranked_lub<T>(&self, a: &T, b: &T) -> cres<T>\n+        where T : HigherRankedCombineable\n+    {\n+        // Make a mark so we can examine \"all bindings that were\n+        // created as part of this type comparison\".\n+        let mark = self.infcx().region_vars.mark();\n+\n+        // Instantiate each bound region with a fresh region variable.\n+        let span = self.trace().origin.span();\n+        let (a_with_fresh, a_map) =\n+            self.infcx().replace_late_bound_regions_with_fresh_var(\n+                span, infer::HigherRankedType, a);\n+        let (b_with_fresh, _) =\n+            self.infcx().replace_late_bound_regions_with_fresh_var(\n+                span, infer::HigherRankedType, b);\n+\n+        // Collect constraints.\n+        let result0 =\n+            try!(HigherRankedCombineable::super_combine(self, &a_with_fresh, &b_with_fresh));\n+        debug!(\"lub result0 = {}\", result0.repr(self.tcx()));\n+\n+        // Generalize the regions appearing in result0 if possible\n+        let new_vars = self.infcx().region_vars.vars_created_since_mark(mark);\n+        let span = self.trace().origin.span();\n+        let result1 =\n+            fold_regions_in(\n+                self.tcx(),\n+                &result0,\n+                |r, debruijn| generalize_region(self.infcx(), span, mark, debruijn,\n+                                                new_vars.as_slice(), &a_map, r));\n+\n+        debug!(\"lub({},{}) = {}\",\n+               a.repr(self.tcx()),\n+               b.repr(self.tcx()),\n+               result1.repr(self.tcx()));\n+\n+        return Ok(result1);\n+\n+        fn generalize_region(infcx: &InferCtxt,\n+                             span: Span,\n+                             mark: RegionMark,\n+                             debruijn: ty::DebruijnIndex,\n+                             new_vars: &[ty::RegionVid],\n+                             a_map: &FnvHashMap<ty::BoundRegion, ty::Region>,\n+                             r0: ty::Region)\n+                             -> ty::Region {\n+            // Regions that pre-dated the LUB computation stay as they are.\n+            if !is_var_in_set(new_vars, r0) {\n+                assert!(!r0.is_bound());\n+                debug!(\"generalize_region(r0={}): not new variable\", r0);\n+                return r0;\n+            }\n+\n+            let tainted = infcx.region_vars.tainted(mark, r0);\n+\n+            // Variables created during LUB computation which are\n+            // *related* to regions that pre-date the LUB computation\n+            // stay as they are.\n+            if !tainted.iter().all(|r| is_var_in_set(new_vars, *r)) {\n+                debug!(\"generalize_region(r0={}): \\\n+                        non-new-variables found in {}\",\n+                       r0, tainted);\n+                assert!(!r0.is_bound());\n+                return r0;\n+            }\n+\n+            // Otherwise, the variable must be associated with at\n+            // least one of the variables representing bound regions\n+            // in both A and B.  Replace the variable with the \"first\"\n+            // bound region from A that we find it to be associated\n+            // with.\n+            for (a_br, a_r) in a_map.iter() {\n+                if tainted.iter().any(|x| x == a_r) {\n+                    debug!(\"generalize_region(r0={}): \\\n+                            replacing with {}, tainted={}\",\n+                           r0, *a_br, tainted);\n+                    return ty::ReLateBound(debruijn, *a_br);\n+                }\n+            }\n+\n+            infcx.tcx.sess.span_bug(\n+                span,\n+                format!(\"region {} is not associated with \\\n+                         any bound region from A!\",\n+                        r0).as_slice())\n+        }\n+    }\n+\n+    fn higher_ranked_glb<T>(&self, a: &T, b: &T) -> cres<T>\n+        where T : HigherRankedCombineable\n+    {\n+        debug!(\"{}.higher_ranked_glb({}, {})\",\n+               self.tag(), a.repr(self.tcx()), b.repr(self.tcx()));\n+\n+        // Make a mark so we can examine \"all bindings that were\n+        // created as part of this type comparison\".\n+        let mark = self.infcx().region_vars.mark();\n+\n+        // Instantiate each bound region with a fresh region variable.\n+        let (a_with_fresh, a_map) =\n+            self.infcx().replace_late_bound_regions_with_fresh_var(\n+                self.trace().origin.span(), infer::HigherRankedType, a);\n+        let (b_with_fresh, b_map) =\n+            self.infcx().replace_late_bound_regions_with_fresh_var(\n+                self.trace().origin.span(), infer::HigherRankedType, b);\n+        let a_vars = var_ids(self, &a_map);\n+        let b_vars = var_ids(self, &b_map);\n+\n+        // Collect constraints.\n+        let result0 =\n+            try!(HigherRankedCombineable::super_combine(self, &a_with_fresh, &b_with_fresh));\n+        debug!(\"glb result0 = {}\", result0.repr(self.tcx()));\n+\n+        // Generalize the regions appearing in fn_ty0 if possible\n+        let new_vars = self.infcx().region_vars.vars_created_since_mark(mark);\n+        let span = self.trace().origin.span();\n+        let result1 =\n+            fold_regions_in(\n+                self.tcx(),\n+                &result0,\n+                |r, debruijn| generalize_region(self.infcx(), span, mark, debruijn,\n+                                                new_vars.as_slice(),\n+                                                &a_map, a_vars.as_slice(), b_vars.as_slice(),\n+                                                r));\n+\n+        debug!(\"glb({},{}) = {}\",\n+               a.repr(self.tcx()),\n+               b.repr(self.tcx()),\n+               result1.repr(self.tcx()));\n+\n+        return Ok(result1);\n+\n+        fn generalize_region(infcx: &InferCtxt,\n+                             span: Span,\n+                             mark: RegionMark,\n+                             debruijn: ty::DebruijnIndex,\n+                             new_vars: &[ty::RegionVid],\n+                             a_map: &FnvHashMap<ty::BoundRegion, ty::Region>,\n+                             a_vars: &[ty::RegionVid],\n+                             b_vars: &[ty::RegionVid],\n+                             r0: ty::Region) -> ty::Region {\n+            if !is_var_in_set(new_vars, r0) {\n+                assert!(!r0.is_bound());\n+                return r0;\n+            }\n+\n+            let tainted = infcx.region_vars.tainted(mark, r0);\n+\n+            let mut a_r = None;\n+            let mut b_r = None;\n+            let mut only_new_vars = true;\n+            for r in tainted.iter() {\n+                if is_var_in_set(a_vars, *r) {\n+                    if a_r.is_some() {\n+                        return fresh_bound_variable(infcx, debruijn);\n+                    } else {\n+                        a_r = Some(*r);\n+                    }\n+                } else if is_var_in_set(b_vars, *r) {\n+                    if b_r.is_some() {\n+                        return fresh_bound_variable(infcx, debruijn);\n+                    } else {\n+                        b_r = Some(*r);\n+                    }\n+                } else if !is_var_in_set(new_vars, *r) {\n+                    only_new_vars = false;\n+                }\n+            }\n+\n+            // NB---I do not believe this algorithm computes\n+            // (necessarily) the GLB.  As written it can\n+            // spuriously fail. In particular, if there is a case\n+            // like: |fn(&a)| and fn(fn(&b)), where a and b are\n+            // free, it will return fn(&c) where c = GLB(a,b).  If\n+            // however this GLB is not defined, then the result is\n+            // an error, even though something like\n+            // \"fn<X>(fn(&X))\" where X is bound would be a\n+            // subtype of both of those.\n+            //\n+            // The problem is that if we were to return a bound\n+            // variable, we'd be computing a lower-bound, but not\n+            // necessarily the *greatest* lower-bound.\n+            //\n+            // Unfortunately, this problem is non-trivial to solve,\n+            // because we do not know at the time of computing the GLB\n+            // whether a GLB(a,b) exists or not, because we haven't\n+            // run region inference (or indeed, even fully computed\n+            // the region hierarchy!). The current algorithm seems to\n+            // works ok in practice.\n+\n+            if a_r.is_some() && b_r.is_some() && only_new_vars {\n+                // Related to exactly one bound variable from each fn:\n+                return rev_lookup(infcx, span, a_map, a_r.unwrap());\n+            } else if a_r.is_none() && b_r.is_none() {\n+                // Not related to bound variables from either fn:\n+                assert!(!r0.is_bound());\n+                return r0;\n+            } else {\n+                // Other:\n+                return fresh_bound_variable(infcx, debruijn);\n+            }\n+        }\n+\n+        fn rev_lookup(infcx: &InferCtxt,\n+                      span: Span,\n+                      a_map: &FnvHashMap<ty::BoundRegion, ty::Region>,\n+                      r: ty::Region) -> ty::Region\n+        {\n+            for (a_br, a_r) in a_map.iter() {\n+                if *a_r == r {\n+                    return ty::ReLateBound(ty::DebruijnIndex::new(1), *a_br);\n+                }\n+            }\n+            infcx.tcx.sess.span_bug(\n+                span,\n+                format!(\"could not find original bound region for {}\", r)[]);\n+        }\n+\n+        fn fresh_bound_variable(infcx: &InferCtxt, debruijn: ty::DebruijnIndex) -> ty::Region {\n+            infcx.region_vars.new_bound(debruijn)\n+        }\n+    }\n+}\n+\n+impl HigherRankedCombineable for ty::FnSig {\n+    fn super_combine<'tcx,C:Combine<'tcx>>(combiner: &C, a: &ty::FnSig, b: &ty::FnSig)\n+                                           -> cres<ty::FnSig>\n+    {\n+        if a.variadic != b.variadic {\n+            return Err(ty::terr_variadic_mismatch(\n+                combine::expected_found(combiner, a.variadic, b.variadic)));\n+        }\n+\n+        let inputs = try!(argvecs(combiner,\n+                                  a.inputs.as_slice(),\n+                                  b.inputs.as_slice()));\n+\n+        let output = try!(match (a.output, b.output) {\n+            (ty::FnConverging(a_ty), ty::FnConverging(b_ty)) =>\n+                Ok(ty::FnConverging(try!(combiner.tys(a_ty, b_ty)))),\n+            (ty::FnDiverging, ty::FnDiverging) =>\n+                Ok(ty::FnDiverging),\n+            (a, b) =>\n+                Err(ty::terr_convergence_mismatch(\n+                    combine::expected_found(combiner, a != ty::FnDiverging, b != ty::FnDiverging))),\n+        });\n+\n+        return Ok(ty::FnSig {inputs: inputs,\n+                             output: output,\n+                             variadic: a.variadic});\n+\n+\n+        fn argvecs<'tcx, C: Combine<'tcx>>(combiner: &C,\n+                                           a_args: &[ty::t],\n+                                           b_args: &[ty::t])\n+                                           -> cres<Vec<ty::t>>\n+        {\n+            if a_args.len() == b_args.len() {\n+                a_args.iter().zip(b_args.iter())\n+                    .map(|(a, b)| combiner.args(*a, *b)).collect()\n+            } else {\n+                Err(ty::terr_arg_count)\n+            }\n+        }\n+    }\n+}\n+\n+impl HigherRankedCombineable for ty::TraitRef {\n+    fn super_combine<'tcx,C:Combine<'tcx>>(combiner: &C, a: &ty::TraitRef, b: &ty::TraitRef)\n+                                           -> cres<ty::TraitRef>\n+    {\n+        // Different traits cannot be related\n+        if a.def_id != b.def_id {\n+            Err(ty::terr_traits(\n+                combine::expected_found(combiner, a.def_id, b.def_id)))\n+        } else {\n+            let substs = try!(combiner.substs(a.def_id, &a.substs, &b.substs));\n+            Ok(ty::TraitRef { def_id: a.def_id,\n+                              substs: substs })\n+        }\n+    }\n+}\n+\n+fn var_ids<'tcx, T: Combine<'tcx>>(combiner: &T,\n+                                   map: &FnvHashMap<ty::BoundRegion, ty::Region>)\n+                                   -> Vec<ty::RegionVid> {\n+    map.iter().map(|(_, r)| match *r {\n+            ty::ReInfer(ty::ReVar(r)) => { r }\n+            r => {\n+                combiner.infcx().tcx.sess.span_bug(\n+                    combiner.trace().origin.span(),\n+                    format!(\"found non-region-vid: {}\", r).as_slice());\n+            }\n+        }).collect()\n+}\n+\n+fn is_var_in_set(new_vars: &[ty::RegionVid], r: ty::Region) -> bool {\n+    match r {\n+        ty::ReInfer(ty::ReVar(ref v)) => new_vars.iter().any(|x| x == v),\n+        _ => false\n+    }\n+}\n+\n+fn fold_regions_in<T:HigherRankedFoldable>(tcx: &ty::ctxt,\n+                                           value: &T,\n+                                           fldr: |ty::Region, ty::DebruijnIndex| -> ty::Region)\n+                                           -> T\n+{\n+    value.fold_contents(&mut ty_fold::RegionFolder::new(tcx, |region, current_depth| {\n+        // we should only be encountering \"escaping\" late-bound regions here,\n+        // because the ones at the current level should have been replaced\n+        // with fresh variables\n+        assert!(match region {\n+            ty::ReLateBound(..) => false,\n+            _ => true\n+        });\n+\n+        fldr(region, ty::DebruijnIndex::new(current_depth))\n+    }))\n+}\n+"}, {"sha": "492ac5e92d3cf97777a1c5e5754cd8cb5eaadffb", "filename": "src/librustc/middle/typeck/infer/lub.rs", "status": "modified", "additions": 3, "deletions": 83, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/23652efffb32de3f2babcb6204f49268b19cc0e6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23652efffb32de3f2babcb6204f49268b19cc0e6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Flub.rs?ref=23652efffb32de3f2babcb6204f49268b19cc0e6", "patch": "@@ -9,23 +9,19 @@\n // except according to those terms.\n \n use middle::ty::{BuiltinBounds};\n-use middle::ty::RegionVid;\n use middle::ty;\n use middle::typeck::infer::combine::*;\n use middle::typeck::infer::equate::Equate;\n use middle::typeck::infer::glb::Glb;\n+use middle::typeck::infer::higher_ranked::HigherRankedRelations;\n use middle::typeck::infer::lattice::*;\n-use middle::typeck::infer::LateBoundRegionConversionTime::FnType;\n use middle::typeck::infer::sub::Sub;\n use middle::typeck::infer::{cres, InferCtxt};\n-use middle::typeck::infer::fold_regions_in_sig;\n use middle::typeck::infer::{TypeTrace, Subtype};\n-use middle::typeck::infer::region_inference::RegionMark;\n-use syntax::ast::{Many, Once, NodeId};\n+use syntax::ast::{Many, Once};\n use syntax::ast::{NormalFn, UnsafeFn};\n use syntax::ast::{Onceness, FnStyle};\n use syntax::ast::{MutMutable, MutImmutable};\n-use util::nodemap::FnvHashMap;\n use util::ppaux::mt_to_string;\n use util::ppaux::Repr;\n \n@@ -118,83 +114,7 @@ impl<'f, 'tcx> Combine<'tcx> for Lub<'f, 'tcx> {\n     }\n \n     fn fn_sigs(&self, a: &ty::FnSig, b: &ty::FnSig) -> cres<ty::FnSig> {\n-        // Note: this is a subtle algorithm.  For a full explanation,\n-        // please see the large comment in `region_inference.rs`.\n-\n-        // Make a mark so we can examine \"all bindings that were\n-        // created as part of this type comparison\".\n-        let mark = self.fields.infcx.region_vars.mark();\n-\n-        // Instantiate each bound region with a fresh region variable.\n-        let (a_with_fresh, a_map) =\n-            self.fields.infcx.replace_late_bound_regions_with_fresh_var(\n-                a.binder_id, self.trace().span(), FnType, a);\n-        let (b_with_fresh, _) =\n-            self.fields.infcx.replace_late_bound_regions_with_fresh_var(\n-                b.binder_id, self.trace().span(), FnType, b);\n-\n-        // Collect constraints.\n-        let sig0 = try!(super_fn_sigs(self, &a_with_fresh, &b_with_fresh));\n-        debug!(\"sig0 = {}\", sig0.repr(self.fields.infcx.tcx));\n-\n-        // Generalize the regions appearing in sig0 if possible\n-        let new_vars =\n-            self.fields.infcx.region_vars.vars_created_since_mark(mark);\n-        let sig1 =\n-            fold_regions_in_sig(\n-                self.fields.infcx.tcx,\n-                &sig0,\n-                |r| generalize_region(self, mark, new_vars.as_slice(),\n-                                      sig0.binder_id, &a_map, r));\n-        return Ok(sig1);\n-\n-        fn generalize_region(this: &Lub,\n-                             mark: RegionMark,\n-                             new_vars: &[RegionVid],\n-                             new_scope: NodeId,\n-                             a_map: &FnvHashMap<ty::BoundRegion, ty::Region>,\n-                             r0: ty::Region)\n-                             -> ty::Region {\n-            // Regions that pre-dated the LUB computation stay as they are.\n-            if !is_var_in_set(new_vars, r0) {\n-                assert!(!r0.is_bound());\n-                debug!(\"generalize_region(r0={}): not new variable\", r0);\n-                return r0;\n-            }\n-\n-            let tainted = this.fields.infcx.region_vars.tainted(mark, r0);\n-\n-            // Variables created during LUB computation which are\n-            // *related* to regions that pre-date the LUB computation\n-            // stay as they are.\n-            if !tainted.iter().all(|r| is_var_in_set(new_vars, *r)) {\n-                debug!(\"generalize_region(r0={}): \\\n-                        non-new-variables found in {}\",\n-                       r0, tainted);\n-                assert!(!r0.is_bound());\n-                return r0;\n-            }\n-\n-            // Otherwise, the variable must be associated with at\n-            // least one of the variables representing bound regions\n-            // in both A and B.  Replace the variable with the \"first\"\n-            // bound region from A that we find it to be associated\n-            // with.\n-            for (a_br, a_r) in a_map.iter() {\n-                if tainted.iter().any(|x| x == a_r) {\n-                    debug!(\"generalize_region(r0={}): \\\n-                            replacing with {}, tainted={}\",\n-                           r0, *a_br, tainted);\n-                    return ty::ReLateBound(new_scope, *a_br);\n-                }\n-            }\n-\n-            this.fields.infcx.tcx.sess.span_bug(\n-                this.fields.trace.origin.span(),\n-                format!(\"region {} is not associated with \\\n-                         any bound region from A!\",\n-                        r0).as_slice())\n-        }\n+        self.higher_ranked_lub(a, b)\n     }\n \n     fn tys(&self, a: ty::t, b: ty::t) -> cres<ty::t> {"}, {"sha": "12807f9050e49a4b781c2a327095f515d369fdb4", "filename": "src/librustc/middle/typeck/infer/mod.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/23652efffb32de3f2babcb6204f49268b19cc0e6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23652efffb32de3f2babcb6204f49268b19cc0e6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fmod.rs?ref=23652efffb32de3f2babcb6204f49268b19cc0e6", "patch": "@@ -61,6 +61,7 @@ pub mod doc;\n pub mod equate;\n pub mod error_reporting;\n pub mod glb;\n+pub mod higher_ranked;\n pub mod lattice;\n pub mod lub;\n pub mod region_inference;\n@@ -233,8 +234,8 @@ pub enum LateBoundRegionConversionTime {\n     /// when a fn is called\n     FnCall,\n \n-    /// when two fn types are compared\n-    FnType,\n+    /// when two higher-ranked types are compared\n+    HigherRankedType,\n }\n \n /// Reasons to create a region inference variable"}, {"sha": "40b41deeb2b66096cf78ddd979c994846d543224", "filename": "src/librustc/middle/typeck/infer/region_inference/doc.rs", "status": "modified", "additions": 3, "deletions": 398, "changes": 401, "blob_url": "https://github.com/rust-lang/rust/blob/23652efffb32de3f2babcb6204f49268b19cc0e6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23652efffb32de3f2babcb6204f49268b19cc0e6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fregion_inference%2Fdoc.rs?ref=23652efffb32de3f2babcb6204f49268b19cc0e6", "patch": "@@ -370,404 +370,9 @@ address this problem somehow and make region inference somewhat more\n efficient. Note that this is solely a matter of performance, not\n expressiveness.\n \n-# Skolemization and functions\n+### Skolemization\n \n-One of the trickiest and most subtle aspects of regions is dealing\n-with the fact that region variables are bound in function types.  I\n-strongly suggest that if you want to understand the situation, you\n-read this paper (which is, admittedly, very long, but you don't have\n-to read the whole thing):\n-\n-http://research.microsoft.com/en-us/um/people/simonpj/papers/higher-rank/\n-\n-Although my explanation will never compete with SPJ's (for one thing,\n-his is approximately 100 pages), I will attempt to explain the basic\n-problem and also how we solve it.  Note that the paper only discusses\n-subtyping, not the computation of LUB/GLB.\n-\n-The problem we are addressing is that there is a kind of subtyping\n-between functions with bound region parameters.  Consider, for\n-example, whether the following relation holds:\n-\n-    fn(&'a int) <: |&'b int|? (Yes, a => b)\n-\n-The answer is that of course it does.  These two types are basically\n-the same, except that in one we used the name `a` and one we used\n-the name `b`.\n-\n-In the examples that follow, it becomes very important to know whether\n-a lifetime is bound in a function type (that is, is a lifetime\n-parameter) or appears free (is defined in some outer scope).\n-Therefore, from now on I will write the bindings explicitly, using a\n-notation like `fn<a>(&'a int)` to indicate that `a` is a lifetime\n-parameter.\n-\n-Now let's consider two more function types.  Here, we assume that the\n-`self` lifetime is defined somewhere outside and hence is not a\n-lifetime parameter bound by the function type (it \"appears free\"):\n-\n-    fn<a>(&'a int) <: |&'a int|? (Yes, a => self)\n-\n-This subtyping relation does in fact hold.  To see why, you have to\n-consider what subtyping means.  One way to look at `T1 <: T2` is to\n-say that it means that it is always ok to treat an instance of `T1` as\n-if it had the type `T2`.  So, with our functions, it is always ok to\n-treat a function that can take pointers with any lifetime as if it\n-were a function that can only take a pointer with the specific\n-lifetime `&self`.  After all, `&self` is a lifetime, after all, and\n-the function can take values of any lifetime.\n-\n-You can also look at subtyping as the *is a* relationship.  This amounts\n-to the same thing: a function that accepts pointers with any lifetime\n-*is a* function that accepts pointers with some specific lifetime.\n-\n-So, what if we reverse the order of the two function types, like this:\n-\n-    fn(&'a int) <: <a>|&'a int|? (No)\n-\n-Does the subtyping relationship still hold?  The answer of course is\n-no.  In this case, the function accepts *only the lifetime `&self`*,\n-so it is not reasonable to treat it as if it were a function that\n-accepted any lifetime.\n-\n-What about these two examples:\n-\n-    fn<a,b>(&'a int, &'b int) <: <a>|&'a int, &'a int|? (Yes)\n-    fn<a>(&'a int, &'a int) <: <a,b>|&'a int, &'b int|? (No)\n-\n-Here, it is true that functions which take two pointers with any two\n-lifetimes can be treated as if they only accepted two pointers with\n-the same lifetime, but not the reverse.\n-\n-## The algorithm\n-\n-Here is the algorithm we use to perform the subtyping check:\n-\n-1. Replace all bound regions in the subtype with new variables\n-2. Replace all bound regions in the supertype with skolemized\n-   equivalents.  A \"skolemized\" region is just a new fresh region\n-   name.\n-3. Check that the parameter and return types match as normal\n-4. Ensure that no skolemized regions 'leak' into region variables\n-   visible from \"the outside\"\n-\n-Let's walk through some examples and see how this algorithm plays out.\n-\n-#### First example\n-\n-We'll start with the first example, which was:\n-\n-    1. fn<a>(&'a T) <: <b>|&'b T|?        Yes: a -> b\n-\n-After steps 1 and 2 of the algorithm we will have replaced the types\n-like so:\n-\n-    1. fn(&'A T) <: |&'x T|?\n-\n-Here the upper case `&A` indicates a *region variable*, that is, a\n-region whose value is being inferred by the system.  I also replaced\n-`&b` with `&x`---I'll use letters late in the alphabet (`x`, `y`, `z`)\n-to indicate skolemized region names.  We can assume they don't appear\n-elsewhere.  Note that neither the sub- nor the supertype bind any\n-region names anymore (as indicated by the absence of `<` and `>`).\n-\n-The next step is to check that the parameter types match.  Because\n-parameters are contravariant, this means that we check whether:\n-\n-    &'x T <: &'A T\n-\n-Region pointers are contravariant so this implies that\n-\n-    &A <= &x\n-\n-must hold, where `<=` is the subregion relationship.  Processing\n-*this* constrain simply adds a constraint into our graph that `&A <=\n-&x` and is considered successful (it can, for example, be satisfied by\n-choosing the value `&x` for `&A`).\n-\n-So far we have encountered no error, so the subtype check succeeds.\n-\n-#### The third example\n-\n-Now let's look first at the third example, which was:\n-\n-    3. fn(&'a T)    <: <b>|&'b T|?        No!\n-\n-After steps 1 and 2 of the algorithm we will have replaced the types\n-like so:\n-\n-    3. fn(&'a T) <: |&'x T|?\n-\n-This looks pretty much the same as before, except that on the LHS\n-`&self` was not bound, and hence was left as-is and not replaced with\n-a variable.  The next step is again to check that the parameter types\n-match.  This will ultimately require (as before) that `&self` <= `&x`\n-must hold: but this does not hold.  `self` and `x` are both distinct\n-free regions.  So the subtype check fails.\n-\n-#### Checking for skolemization leaks\n-\n-You may be wondering about that mysterious last step in the algorithm.\n-So far it has not been relevant.  The purpose of that last step is to\n-catch something like *this*:\n-\n-    fn<a>() -> fn(&'a T) <: || -> fn<b>(&'b T)?   No.\n-\n-Here the function types are the same but for where the binding occurs.\n-The subtype returns a function that expects a value in precisely one\n-region.  The supertype returns a function that expects a value in any\n-region.  If we allow an instance of the subtype to be used where the\n-supertype is expected, then, someone could call the fn and think that\n-the return value has type `fn<b>(&'b T)` when it really has type\n-`fn(&'a T)` (this is case #3, above).  Bad.\n-\n-So let's step through what happens when we perform this subtype check.\n-We first replace the bound regions in the subtype (the supertype has\n-no bound regions).  This gives us:\n-\n-    fn() -> fn(&'A T) <: || -> fn<b>(&'b T)?\n-\n-Now we compare the return types, which are covariant, and hence we have:\n-\n-    fn(&'A T) <: <b>|&'b T|?\n-\n-Here we skolemize the bound region in the supertype to yield:\n-\n-    fn(&'A T) <: |&'x T|?\n-\n-And then proceed to compare the argument types:\n-\n-    &'x T <: &'A T\n-    &A <= &x\n-\n-Finally, this is where it gets interesting!  This is where an error\n-*should* be reported.  But in fact this will not happen.  The reason why\n-is that `A` is a variable: we will infer that its value is the fresh\n-region `x` and think that everything is happy.  In fact, this behavior\n-is *necessary*, it was key to the first example we walked through.\n-\n-The difference between this example and the first one is that the variable\n-`A` already existed at the point where the skolemization occurred.  In\n-the first example, you had two functions:\n-\n-    fn<a>(&'a T) <: <b>|&'b T|\n-\n-and hence `&A` and `&x` were created \"together\".  In general, the\n-intention of the skolemized names is that they are supposed to be\n-fresh names that could never be equal to anything from the outside.\n-But when inference comes into play, we might not be respecting this\n-rule.\n-\n-So the way we solve this is to add a fourth step that examines the\n-constraints that refer to skolemized names.  Basically, consider a\n-non-directed verison of the constraint graph.  Let `Tainted(x)` be the\n-set of all things reachable from a skolemized variable `x`.\n-`Tainted(x)` should not contain any regions that existed before the\n-step at which the skolemization was performed.  So this case here\n-would fail because `&x` was created alone, but is relatable to `&A`.\n-\n-## Computing the LUB and GLB\n-\n-The paper I pointed you at is written for Haskell.  It does not\n-therefore considering subtyping and in particular does not consider\n-LUB or GLB computation.  We have to consider this.  Here is the\n-algorithm I implemented.\n-\n-First though, let's discuss what we are trying to compute in more\n-detail.  The LUB is basically the \"common supertype\" and the GLB is\n-\"common subtype\"; one catch is that the LUB should be the\n-*most-specific* common supertype and the GLB should be *most general*\n-common subtype (as opposed to any common supertype or any common\n-subtype).\n-\n-Anyway, to help clarify, here is a table containing some\n-function pairs and their LUB/GLB:\n-\n-```\n-Type 1              Type 2              LUB               GLB\n-fn<a>(&a)           fn(&X)              fn(&X)            fn<a>(&a)\n-fn(&A)              fn(&X)              --                fn<a>(&a)\n-fn<a,b>(&a, &b)     fn<x>(&x, &x)       fn<a>(&a, &a)     fn<a,b>(&a, &b)\n-fn<a,b>(&a, &b, &a) fn<x,y>(&x, &y, &y) fn<a>(&a, &a, &a) fn<a,b,c>(&a,&b,&c)\n-```\n-\n-### Conventions\n-\n-I use lower-case letters (e.g., `&a`) for bound regions and upper-case\n-letters for free regions (`&A`).  Region variables written with a\n-dollar-sign (e.g., `$a`).  I will try to remember to enumerate the\n-bound-regions on the fn type as well (e.g., `fn<a>(&a)`).\n-\n-### High-level summary\n-\n-Both the LUB and the GLB algorithms work in a similar fashion.  They\n-begin by replacing all bound regions (on both sides) with fresh region\n-inference variables.  Therefore, both functions are converted to types\n-that contain only free regions.  We can then compute the LUB/GLB in a\n-straightforward way, as described in `combine.rs`.  This results in an\n-interim type T.  The algorithms then examine the regions that appear\n-in T and try to, in some cases, replace them with bound regions to\n-yield the final result.\n-\n-To decide whether to replace a region `R` that appears in `T` with a\n-bound region, the algorithms make use of two bits of information.\n-First is a set `V` that contains all region variables created as part\n-of the LUB/GLB computation. `V` will contain the region variables\n-created to replace the bound regions in the input types, but it also\n-contains 'intermediate' variables created to represent the LUB/GLB of\n-individual regions.  Basically, when asked to compute the LUB/GLB of a\n-region variable with another region, the inferencer cannot oblige\n-immediately since the values of that variables are not known.\n-Therefore, it creates a new variable that is related to the two\n-regions.  For example, the LUB of two variables `$x` and `$y` is a\n-fresh variable `$z` that is constrained such that `$x <= $z` and `$y\n-<= $z`.  So `V` will contain these intermediate variables as well.\n-\n-The other important factor in deciding how to replace a region in T is\n-the function `Tainted($r)` which, for a region variable, identifies\n-all regions that the region variable is related to in some way\n-(`Tainted()` made an appearance in the subtype computation as well).\n-\n-### LUB\n-\n-The LUB algorithm proceeds in three steps:\n-\n-1. Replace all bound regions (on both sides) with fresh region\n-   inference variables.\n-2. Compute the LUB \"as normal\", meaning compute the GLB of each\n-   pair of argument types and the LUB of the return types and\n-   so forth.  Combine those to a new function type `F`.\n-3. Replace each region `R` that appears in `F` as follows:\n-   - Let `V` be the set of variables created during the LUB\n-     computational steps 1 and 2, as described in the previous section.\n-   - If `R` is not in `V`, replace `R` with itself.\n-   - If `Tainted(R)` contains a region that is not in `V`,\n-     replace `R` with itself.\n-   - Otherwise, select the earliest variable in `Tainted(R)` that originates\n-     from the left-hand side and replace `R` with the bound region that\n-     this variable was a replacement for.\n-\n-So, let's work through the simplest example: `fn(&A)` and `fn<a>(&a)`.\n-In this case, `&a` will be replaced with `$a` and the interim LUB type\n-`fn($b)` will be computed, where `$b=GLB(&A,$a)`.  Therefore, `V =\n-{$a, $b}` and `Tainted($b) = { $b, $a, &A }`.  When we go to replace\n-`$b`, we find that since `&A \\in Tainted($b)` is not a member of `V`,\n-we leave `$b` as is.  When region inference happens, `$b` will be\n-resolved to `&A`, as we wanted.\n-\n-Let's look at a more complex one: `fn(&a, &b)` and `fn(&x, &x)`.  In\n-this case, we'll end up with a (pre-replacement) LUB type of `fn(&g,\n-&h)` and a graph that looks like:\n-\n-```\n-     $a        $b     *--$x\n-       \\        \\    /  /\n-        \\        $h-*  /\n-         $g-----------*\n-```\n-\n-Here `$g` and `$h` are fresh variables that are created to represent\n-the LUB/GLB of things requiring inference.  This means that `V` and\n-`Tainted` will look like:\n-\n-```\n-V = {$a, $b, $g, $h, $x}\n-Tainted($g) = Tainted($h) = { $a, $b, $h, $g, $x }\n-```\n-\n-Therefore we replace both `$g` and `$h` with `$a`, and end up\n-with the type `fn(&a, &a)`.\n-\n-### GLB\n-\n-The procedure for computing the GLB is similar.  The difference lies\n-in computing the replacements for the various variables. For each\n-region `R` that appears in the type `F`, we again compute `Tainted(R)`\n-and examine the results:\n-\n-1. If `R` is not in `V`, it is not replaced.\n-2. Else, if `Tainted(R)` contains only variables in `V`, and it\n-   contains exactly one variable from the LHS and one variable from\n-   the RHS, then `R` can be mapped to the bound version of the\n-   variable from the LHS.\n-3. Else, if `Tainted(R)` contains no variable from the LHS and no\n-   variable from the RHS, then `R` can be mapped to itself.\n-4. Else, `R` is mapped to a fresh bound variable.\n-\n-These rules are pretty complex.  Let's look at some examples to see\n-how they play out.\n-\n-Out first example was `fn(&a)` and `fn(&X)`.  In this case, `&a` will\n-be replaced with `$a` and we will ultimately compute a\n-(pre-replacement) GLB type of `fn($g)` where `$g=LUB($a,&X)`.\n-Therefore, `V={$a,$g}` and `Tainted($g)={$g,$a,&X}.  To find the\n-replacement for `$g` we consult the rules above:\n-- Rule (1) does not apply because `$g \\in V`\n-- Rule (2) does not apply because `&X \\in Tainted($g)`\n-- Rule (3) does not apply because `$a \\in Tainted($g)`\n-- Hence, by rule (4), we replace `$g` with a fresh bound variable `&z`.\n-So our final result is `fn(&z)`, which is correct.\n-\n-The next example is `fn(&A)` and `fn(&Z)`. In this case, we will again\n-have a (pre-replacement) GLB of `fn(&g)`, where `$g = LUB(&A,&Z)`.\n-Therefore, `V={$g}` and `Tainted($g) = {$g, &A, &Z}`.  In this case,\n-by rule (3), `$g` is mapped to itself, and hence the result is\n-`fn($g)`.  This result is correct (in this case, at least), but it is\n-indicative of a case that *can* lead us into concluding that there is\n-no GLB when in fact a GLB does exist.  See the section \"Questionable\n-Results\" below for more details.\n-\n-The next example is `fn(&a, &b)` and `fn(&c, &c)`. In this case, as\n-before, we'll end up with `F=fn($g, $h)` where `Tainted($g) =\n-Tainted($h) = {$g, $h, $a, $b, $c}`.  Only rule (4) applies and hence\n-we'll select fresh bound variables `y` and `z` and wind up with\n-`fn(&y, &z)`.\n-\n-For the last example, let's consider what may seem trivial, but is\n-not: `fn(&a, &a)` and `fn(&b, &b)`.  In this case, we'll get `F=fn($g,\n-$h)` where `Tainted($g) = {$g, $a, $x}` and `Tainted($h) = {$h, $a,\n-$x}`.  Both of these sets contain exactly one bound variable from each\n-side, so we'll map them both to `&a`, resulting in `fn(&a, &a)`, which\n-is the desired result.\n-\n-### Shortcomings and correctness\n-\n-You may be wondering whether this algorithm is correct.  The answer is\n-\"sort of\".  There are definitely cases where they fail to compute a\n-result even though a correct result exists.  I believe, though, that\n-if they succeed, then the result is valid, and I will attempt to\n-convince you.  The basic argument is that the \"pre-replacement\" step\n-computes a set of constraints.  The replacements, then, attempt to\n-satisfy those constraints, using bound identifiers where needed.\n-\n-For now I will briefly go over the cases for LUB/GLB and identify\n-their intent:\n-\n-- LUB:\n-  - The region variables that are substituted in place of bound regions\n-    are intended to collect constraints on those bound regions.\n-  - If Tainted(R) contains only values in V, then this region is unconstrained\n-    and can therefore be generalized, otherwise it cannot.\n-- GLB:\n-  - The region variables that are substituted in place of bound regions\n-    are intended to collect constraints on those bound regions.\n-  - If Tainted(R) contains exactly one variable from each side, and\n-    only variables in V, that indicates that those two bound regions\n-    must be equated.\n-  - Otherwise, if Tainted(R) references any variables from left or right\n-    side, then it is trying to combine a bound region with a free one or\n-    multiple bound regions, so we need to select fresh bound regions.\n-\n-Sorry this is more of a shorthand to myself.  I will try to write up something\n-more convincing in the future.\n-\n-#### Where are the algorithms wrong?\n-\n-- The pre-replacement computation can fail even though using a\n-  bound-region would have succeeded.\n-- We will compute GLB(fn(fn($a)), fn(fn($b))) as fn($c) where $c is the\n-  GLB of $a and $b.  But if inference finds that $a and $b must be mapped\n-  to regions without a GLB, then this is effectively a failure to compute\n-  the GLB.  However, the result `fn<$c>(fn($c))` is a valid GLB.\n+For a discussion on skolemization and higher-ranked subtyping, please\n+see the module `middle::typeck::infer::higher_ranked::doc`.\n \n */"}, {"sha": "f3df33f7b0e6d953ccce5ea102f4a007b84c2e97", "filename": "src/librustc/middle/typeck/infer/sub.rs", "status": "modified", "additions": 3, "deletions": 75, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/23652efffb32de3f2babcb6204f49268b19cc0e6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/23652efffb32de3f2babcb6204f49268b19cc0e6/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Finfer%2Fsub.rs?ref=23652efffb32de3f2babcb6204f49268b19cc0e6", "patch": "@@ -12,18 +12,16 @@\n use middle::ty::{BuiltinBounds};\n use middle::ty;\n use middle::ty::TyVar;\n-use middle::typeck::check::regionmanip::replace_late_bound_regions;\n use middle::typeck::infer::combine::*;\n use middle::typeck::infer::{cres, CresCompare};\n use middle::typeck::infer::equate::Equate;\n-use middle::typeck::infer::LateBoundRegionConversionTime::FnType;\n use middle::typeck::infer::glb::Glb;\n+use middle::typeck::infer::higher_ranked::HigherRankedRelations;\n use middle::typeck::infer::InferCtxt;\n use middle::typeck::infer::lub::Lub;\n use middle::typeck::infer::{TypeTrace, Subtype};\n use middle::typeck::infer::type_variable::{SubtypeOf, SupertypeOf};\n-use util::common::{indenter};\n-use util::ppaux::{bound_region_to_string, Repr};\n+use util::ppaux::{Repr};\n \n use syntax::ast::{Onceness, FnStyle, MutImmutable, MutMutable};\n \n@@ -158,77 +156,7 @@ impl<'f, 'tcx> Combine<'tcx> for Sub<'f, 'tcx> {\n     }\n \n     fn fn_sigs(&self, a: &ty::FnSig, b: &ty::FnSig) -> cres<ty::FnSig> {\n-        debug!(\"fn_sigs(a={}, b={})\",\n-               a.repr(self.fields.infcx.tcx), b.repr(self.fields.infcx.tcx));\n-        let _indenter = indenter();\n-\n-        // Rather than checking the subtype relationship between `a` and `b`\n-        // as-is, we need to do some extra work here in order to make sure\n-        // that function subtyping works correctly with respect to regions\n-        //\n-        // Note: this is a subtle algorithm.  For a full explanation,\n-        // please see the large comment in `region_inference.rs`.\n-\n-        // Make a mark so we can examine \"all bindings that were\n-        // created as part of this type comparison\".\n-        let mark = self.fields.infcx.region_vars.mark();\n-\n-        // First, we instantiate each bound region in the subtype with a fresh\n-        // region variable.\n-        let (a_sig, _) =\n-            self.fields.infcx.replace_late_bound_regions_with_fresh_var(\n-                a.binder_id, self.trace().span(), FnType, a);\n-\n-        // Second, we instantiate each bound region in the supertype with a\n-        // fresh concrete region.\n-        let (skol_map, b_sig) = {\n-            replace_late_bound_regions(self.fields.infcx.tcx, b.binder_id, b, |br| {\n-                let skol = self.fields.infcx.region_vars.new_skolemized(br);\n-                debug!(\"Bound region {} skolemized to {}\",\n-                       bound_region_to_string(self.fields.infcx.tcx, \"\", false, br),\n-                       skol);\n-                skol\n-            })\n-        };\n-\n-        debug!(\"a_sig={}\", a_sig.repr(self.fields.infcx.tcx));\n-        debug!(\"b_sig={}\", b_sig.repr(self.fields.infcx.tcx));\n-\n-        // Compare types now that bound regions have been replaced.\n-        let sig = try!(super_fn_sigs(self, &a_sig, &b_sig));\n-\n-        // Presuming type comparison succeeds, we need to check\n-        // that the skolemized regions do not \"leak\".\n-        let new_vars =\n-            self.fields.infcx.region_vars.vars_created_since_mark(mark);\n-        for (&skol_br, &skol) in skol_map.iter() {\n-            let tainted = self.fields.infcx.region_vars.tainted(mark, skol);\n-            for tainted_region in tainted.iter() {\n-                // Each skolemized should only be relatable to itself\n-                // or new variables:\n-                match *tainted_region {\n-                    ty::ReInfer(ty::ReVar(ref vid)) => {\n-                        if new_vars.iter().any(|x| x == vid) { continue; }\n-                    }\n-                    _ => {\n-                        if *tainted_region == skol { continue; }\n-                    }\n-                };\n-\n-                // A is not as polymorphic as B:\n-                if self.a_is_expected() {\n-                    debug!(\"Not as polymorphic!\");\n-                    return Err(ty::terr_regions_insufficiently_polymorphic(\n-                        skol_br, *tainted_region));\n-                } else {\n-                    debug!(\"Overly polymorphic!\");\n-                    return Err(ty::terr_regions_overly_polymorphic(\n-                        skol_br, *tainted_region));\n-                }\n-            }\n-        }\n-\n-        return Ok(sig);\n+        self.higher_ranked_sub(a, b)\n     }\n }\n "}]}