{"sha": "017b3a543182006fa64bdc8c721969ae38c125f9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAxN2IzYTU0MzE4MjAwNmZhNjRiZGM4YzcyMTk2OWFlMzhjMTI1Zjk=", "commit": {"author": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-01-29T04:56:49Z"}, "committer": {"name": "Steve Klabnik", "email": "steve@steveklabnik.com", "date": "2015-01-29T06:16:54Z"}, "message": "Pull configs out into individual repositories\n\nAs we grow, these don't belong in-tree.\n\nhttp://internals.rust-lang.org/t/moving-editor-highlighting-into-their-own-repos/1395\n\n* https://github.com/rust-lang/rust.vim\n* https://github.com/rust-lang/rust-mode\n* https://github.com/rust-lang/gedit-config\n* https://github.com/rust-lang/kate-config\n* https://github.com/rust-lang/nano-config\n* https://github.com/rust-lang/zsh-config", "tree": {"sha": "68bbf55bb769b0d330e6577cba1fe8fc940316bf", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/68bbf55bb769b0d330e6577cba1fe8fc940316bf"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/017b3a543182006fa64bdc8c721969ae38c125f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/017b3a543182006fa64bdc8c721969ae38c125f9", "html_url": "https://github.com/rust-lang/rust/commit/017b3a543182006fa64bdc8c721969ae38c125f9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/017b3a543182006fa64bdc8c721969ae38c125f9/comments", "author": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "committer": {"login": "steveklabnik", "id": 27786, "node_id": "MDQ6VXNlcjI3Nzg2", "avatar_url": "https://avatars.githubusercontent.com/u/27786?v=4", "gravatar_id": "", "url": "https://api.github.com/users/steveklabnik", "html_url": "https://github.com/steveklabnik", "followers_url": "https://api.github.com/users/steveklabnik/followers", "following_url": "https://api.github.com/users/steveklabnik/following{/other_user}", "gists_url": "https://api.github.com/users/steveklabnik/gists{/gist_id}", "starred_url": "https://api.github.com/users/steveklabnik/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/steveklabnik/subscriptions", "organizations_url": "https://api.github.com/users/steveklabnik/orgs", "repos_url": "https://api.github.com/users/steveklabnik/repos", "events_url": "https://api.github.com/users/steveklabnik/events{/privacy}", "received_events_url": "https://api.github.com/users/steveklabnik/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c5961ad06d45689b44ff305c15d6ec7ec65755a9", "url": "https://api.github.com/repos/rust-lang/rust/commits/c5961ad06d45689b44ff305c15d6ec7ec65755a9", "html_url": "https://github.com/rust-lang/rust/commit/c5961ad06d45689b44ff305c15d6ec7ec65755a9"}], "stats": {"total": 3617, "additions": 0, "deletions": 3617}, "files": [{"sha": "24470c258b375a2f7113df38568811a8aa98b102", "filename": "src/etc/emacs/README.md", "status": "removed", "additions": 0, "deletions": 79, "changes": 79, "blob_url": "https://github.com/rust-lang/rust/blob/c5961ad06d45689b44ff305c15d6ec7ec65755a9/src%2Fetc%2Femacs%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/c5961ad06d45689b44ff305c15d6ec7ec65755a9/src%2Fetc%2Femacs%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Femacs%2FREADME.md?ref=c5961ad06d45689b44ff305c15d6ec7ec65755a9", "patch": "@@ -1,79 +0,0 @@\n-`rust-mode`: A major Emacs mode for editing Rust source code\n-============================================================\n-\n-`rust-mode` makes editing [Rust](http://rust-lang.org) code with Emacs\n-enjoyable.\n-\n-\n-### Manual Installation\n-\n-To install manually, check out this repository and add this to your\n-`.emacs` file:\n-\n-```lisp\n-(add-to-list 'load-path \"/path/to/rust-mode/\")\n-(autoload 'rust-mode \"rust-mode\" nil t)\n-(add-to-list 'auto-mode-alist '(\"\\\\.rs\\\\'\" . rust-mode))\n-```\n-\n-This associates `rust-mode` with `.rs` files. To enable it explicitly, do\n-<kbd>M-x rust-mode</kbd>.\n-\n-### `package.el` installation via Marmalade or MELPA\n-\n-It can be more convenient to use Emacs's package manager to handle\n-installation for you if you use many elisp libraries. If you have\n-`package.el` but haven't added Marmalade or MELPA, the community\n-package source, yet, add this to `~/.emacs.d/init.el`:\n-\n-Using Marmalade:\n-\n-```lisp\n-(require 'package)\n-(add-to-list 'package-archives\n-             '(\"marmalade\" . \"http://marmalade-repo.org/packages/\"))\n-(package-initialize)\n-```\n-\n-Using MELPA:\n-\n-```lisp\n-(require 'package)\n-(add-to-list 'package-archives\n-             '(\"melpa\" . \"http://melpa.milkbox.net/packages/\") t)\n-(package-initialize)\n-```\n-\n-Then do this to load the package listing:\n-\n-* <kbd>M-x eval-buffer</kbd>\n-* <kbd>M-x package-refresh-contents</kbd>\n-\n-If you use a version of Emacs prior to 24 that doesn't include\n-`package.el`, you can get it from [here](http://bit.ly/pkg-el23).\n-\n-If you have an older ELPA `package.el` installed from tromey.com, you\n-should upgrade in order to support installation from multiple sources.\n-The ELPA archive is deprecated and no longer accepting new packages,\n-so the version there (1.7.1) is very outdated.\n-\n-#### Install `rust-mode`\n-\n-One you have `package.el`, you can install `rust-mode` or any other\n-modes by choosing them from a list:\n-\n-* <kbd>M-x package-list-packages</kbd>\n-\n-Now, to install packages, move your cursor to them and press\n-<kbd>i</kbd>. This will mark the packages for installation. When\n-you're done with marking, press <kbd>x</kbd>, and ELPA will install\n-the packages for you (under `~/.emacs.d/elpa/`).\n-\n-* or using <kbd>M-x package-install rust-mode</kbd>\n-\n-### Tests via ERT\n-\n-The file `rust-mode-tests.el` contains tests that can be run via\n-[ERT](http://www.gnu.org/software/emacs/manual/html_node/ert/index.html).\n-You can use `run_rust_emacs_tests.sh` to run them in batch mode, if\n-Emacs is somewhere in your `$PATH`."}, {"sha": "b35fcf870c4d36f4ae7eb499edd31eef4968bb59", "filename": "src/etc/emacs/run_rust_emacs_tests.sh", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c5961ad06d45689b44ff305c15d6ec7ec65755a9/src%2Fetc%2Femacs%2Frun_rust_emacs_tests.sh", "raw_url": "https://github.com/rust-lang/rust/raw/c5961ad06d45689b44ff305c15d6ec7ec65755a9/src%2Fetc%2Femacs%2Frun_rust_emacs_tests.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Femacs%2Frun_rust_emacs_tests.sh?ref=c5961ad06d45689b44ff305c15d6ec7ec65755a9", "patch": "@@ -1,14 +0,0 @@\n-#!/bin/sh\n-# Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n-# file at the top-level directory of this distribution and at\n-# http://rust-lang.org/COPYRIGHT.\n-#\n-# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-# option. This file may not be copied, modified, or distributed\n-# except according to those terms.\n-#\n-# This runs the test for emacs rust-mode.\n-# It must be possible to find emacs via PATH.\n-emacs -batch -l rust-mode.el -l rust-mode-tests.el -f ert-run-tests-batch-and-exit"}, {"sha": "f255dbf15071b6dc3852bace3c21aa7d706ab759", "filename": "src/etc/emacs/rust-mode-tests.el", "status": "removed", "additions": 0, "deletions": 896, "changes": 896, "blob_url": "https://github.com/rust-lang/rust/blob/c5961ad06d45689b44ff305c15d6ec7ec65755a9/src%2Fetc%2Femacs%2Frust-mode-tests.el", "raw_url": "https://github.com/rust-lang/rust/raw/c5961ad06d45689b44ff305c15d6ec7ec65755a9/src%2Fetc%2Femacs%2Frust-mode-tests.el", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Femacs%2Frust-mode-tests.el?ref=c5961ad06d45689b44ff305c15d6ec7ec65755a9", "patch": "@@ -1,896 +0,0 @@\n-;;; rust-mode-tests.el --- ERT tests for rust-mode.el\n-\n-(require 'rust-mode)\n-(require 'ert)\n-(require 'cl)\n-\n-(setq rust-test-fill-column 32)\n-\n-(defun rust-compare-code-after-manip (original point-pos manip-func expected got)\n-  (equal expected got))\n-\n-(defun rust-test-explain-bad-manip (original point-pos manip-func expected got)\n-  (if (equal expected got)\n-      nil\n-    (list\n-     ;; The (goto-char) and (insert) business here is just for\n-     ;; convenience--after an error, you can copy-paste that into emacs eval to\n-     ;; insert the bare strings into a buffer\n-     \"Rust code was manipulated wrong after:\"\n-     `(insert ,original)\n-     `(goto-char ,point-pos)\n-     'expected `(insert ,expected)\n-     'got `(insert ,got)\n-     (loop for i from 0 to (max (length original) (length expected))\n-           for oi = (if (< i (length got)) (elt got i))\n-           for ei = (if (< i (length expected)) (elt expected i))\n-           while (equal oi ei)\n-           finally return `(first-difference-at\n-                            (goto-char ,(+ 1 i))\n-                            expected ,(char-to-string ei)\n-                            got ,(char-to-string oi))))))\n-(put 'rust-compare-code-after-manip 'ert-explainer\n-     'rust-test-explain-bad-manip)\n-\n-(defun rust-test-manip-code (original point-pos manip-func expected)\n-  (with-temp-buffer\n-    (rust-mode)\n-    (insert original)\n-    (goto-char point-pos)\n-    (funcall manip-func)\n-    (should (rust-compare-code-after-manip\n-             original point-pos manip-func expected (buffer-string)))))\n-\n-(defun test-fill-paragraph (unfilled expected &optional start-pos end-pos)\n-  \"We're going to run through many scenarios here--the point should be able to be anywhere from the start-pos (defaults to 1) through end-pos (defaults to the length of what was passed in) and (fill-paragraph) should return the same result.\n-\n-Also, the result should be the same regardless of whether the code is at the beginning or end of the file.  (If you're not careful, that can make a difference.)  So we test each position given above with the passed code at the beginning, the end, neither and both.  So we do this a total of (end-pos - start-pos)*4 times.  Oy.\"\n-  (let* ((start-pos (or start-pos 1))\n-         (end-pos (or end-pos (length unfilled)))\n-         (padding \"\\n     \\n\")\n-         (padding-len (length padding)))\n-    (loop\n-     for pad-at-beginning from 0 to 1\n-     do (loop for pad-at-end from 0 to 1\n-              with padding-beginning = (if (= 0 pad-at-beginning) \"\" padding)\n-              with padding-end = (if (= 0 pad-at-end) \"\" padding)\n-              with padding-adjust = (* padding-len pad-at-beginning)\n-              with padding-beginning = (if (= 0 pad-at-beginning) \"\" padding)\n-              with padding-end = (if (= 0 pad-at-end) \"\" padding)\n-              ;; If we're adding space to the beginning, and our start position\n-              ;; is at the very beginning, we want to test within the added space.\n-              ;; Otherwise adjust the start and end for the beginning padding.\n-              with start-pos = (if (= 1 start-pos) 1 (+ padding-adjust start-pos))\n-              with end-pos = (+ end-pos padding-adjust)\n-              do (loop for pos from start-pos to end-pos\n-                       do (rust-test-manip-code\n-                           (concat padding-beginning unfilled padding-end)\n-                           pos\n-                           (lambda ()\n-                             (let ((fill-column rust-test-fill-column))\n-                               (fill-paragraph)))\n-                           (concat padding-beginning expected padding-end)))))))\n-\n-(ert-deftest fill-paragraph-top-level-multi-line-style-doc-comment-second-line ()\n-  (test-fill-paragraph\n-   \"/**\n- * This is a very very very very very very very long string\n- */\"\n-   \"/**\n- * This is a very very very very\n- * very very very long string\n- */\"))\n-\n-\n-(ert-deftest fill-paragraph-top-level-multi-line-style-doc-comment-first-line ()\n-  (test-fill-paragraph\n-   \"/** This is a very very very very very very very long string\n- */\"\n-   \"/** This is a very very very\n- * very very very very long\n- * string\n- */\"))\n-\n-(ert-deftest fill-paragraph-multi-paragraph-multi-line-style-doc-comment ()\n-  (let\n-      ((multi-paragraph-unfilled\n-        \"/**\n- * This is the first really really really really really really really long paragraph\n- *\n- * This is the second really really really really really really long paragraph\n- */\"))\n-    (test-fill-paragraph\n-     multi-paragraph-unfilled\n-     \"/**\n- * This is the first really\n- * really really really really\n- * really really long paragraph\n- *\n- * This is the second really really really really really really long paragraph\n- */\"\n-     1 89)\n-    (test-fill-paragraph\n-     multi-paragraph-unfilled\n-     \"/**\n- * This is the first really really really really really really really long paragraph\n- *\n- * This is the second really\n- * really really really really\n- * really long paragraph\n- */\"\n-     90)))\n-\n-(ert-deftest fill-paragraph-multi-paragraph-single-line-style-doc-comment ()\n-  (let\n-      ((multi-paragraph-unfilled\n-        \"/// This is the first really really really really really really really long paragraph\n-///\n-/// This is the second really really really really really really long paragraph\"))\n-    (test-fill-paragraph\n-     multi-paragraph-unfilled\n-     \"/// This is the first really\n-/// really really really really\n-/// really really long paragraph\n-///\n-/// This is the second really really really really really really long paragraph\"\n-     1 86)\n-    (test-fill-paragraph\n-     multi-paragraph-unfilled\n-     \"/// This is the first really really really really really really really long paragraph\n-///\n-/// This is the second really\n-/// really really really really\n-/// really long paragraph\"\n-     87)))\n-\n-(ert-deftest fill-paragraph-multi-paragraph-single-line-style-indented ()\n-  (test-fill-paragraph\n-   \"     // This is the first really really really really really really really long paragraph\n-     //\n-     // This is the second really really really really really really long paragraph\"\n-   \"     // This is the first really\n-     // really really really\n-     // really really really\n-     // long paragraph\n-     //\n-     // This is the second really really really really really really long paragraph\" 1 89))\n-\n-(ert-deftest fill-paragraph-multi-line-style-inner-doc-comment ()\n-  (test-fill-paragraph\n-   \"/*! This is a very very very very very very very long string\n- */\"\n-   \"/*! This is a very very very\n- * very very very very long\n- * string\n- */\"))\n-\n-(ert-deftest fill-paragraph-single-line-style-inner-doc-comment ()\n-  (test-fill-paragraph\n-   \"//! This is a very very very very very very very long string\"\n-   \"//! This is a very very very\n-//! very very very very long\n-//! string\"))\n-\n-(ert-deftest fill-paragraph-prefixless-multi-line-doc-comment ()\n-  (test-fill-paragraph\n-   \"/**\n-This is my summary. Blah blah blah blah blah. Dilly dally dilly dally dilly dally doo.\n-\n-This is some more text.  Fee fie fo fum.  Humpty dumpty sat on a wall.\n-*/\"\n-   \"/**\n-This is my summary. Blah blah\n-blah blah blah. Dilly dally\n-dilly dally dilly dally doo.\n-\n-This is some more text.  Fee fie fo fum.  Humpty dumpty sat on a wall.\n-*/\" 4 90))\n-\n-(ert-deftest fill-paragraph-with-no-space-after-star-prefix ()\n-  (test-fill-paragraph\n-   \"/**\n- *This is a very very very very very very very long string\n- */\"\n-   \"/**\n- *This is a very very very very\n- *very very very long string\n- */\"))\n-\n-(ert-deftest fill-paragraph-single-line-style-with-code-before ()\n-  (test-fill-paragraph\n-   \"fn foo() { }\n-/// This is my comment.  This is more of my comment.  This is even more.\"\n-   \"fn foo() { }\n-/// This is my comment.  This is\n-/// more of my comment.  This is\n-/// even more.\" 14))\n-\n-(ert-deftest fill-paragraph-single-line-style-with-code-after ()\n-  (test-fill-paragraph\n-   \"/// This is my comment.  This is more of my comment.  This is even more.\n-fn foo() { }\"\n-   \"/// This is my comment.  This is\n-/// more of my comment.  This is\n-/// even more.\n-fn foo() { }\" 1 73))\n-\n-(ert-deftest fill-paragraph-single-line-style-code-before-and-after ()\n-  (test-fill-paragraph\n-   \"fn foo() { }\n-/// This is my comment.  This is more of my comment.  This is even more.\n-fn bar() { }\"\n-   \"fn foo() { }\n-/// This is my comment.  This is\n-/// more of my comment.  This is\n-/// even more.\n-fn bar() { }\" 14 67))\n-\n-(defun test-auto-fill (initial position inserted expected)\n-  (rust-test-manip-code\n-   initial\n-   position\n-   (lambda ()\n-     (unwind-protect\n-         (progn\n-           (let ((fill-column rust-test-fill-column))\n-             (auto-fill-mode)\n-             (goto-char position)\n-             (insert inserted)\n-             (syntax-ppss-flush-cache 1)\n-             (funcall auto-fill-function)))\n-       (auto-fill-mode t)))\n-   expected))\n-\n-(ert-deftest auto-fill-multi-line-doc-comment ()\n-  (test-auto-fill\n-   \"/**\n- *\n- */\"\n-   8\n-   \"This is a very very very very very very very long string\"\n-   \"/**\n- * This is a very very very very\n- * very very very long string\n- */\"))\n-\n-(ert-deftest auto-fill-single-line-doc-comment ()\n-  (test-auto-fill\n-   \"/// This is the first really\n-/// really really really really\n-/// really really long paragraph\n-///\n-/// \"\n-   103\n-   \"This is the second really really really really really really long paragraph\"\n-   \"/// This is the first really\n-/// really really really really\n-/// really really long paragraph\n-///\n-/// This is the second really\n-/// really really really really\n-/// really long paragraph\"\n-   ))\n-\n-(ert-deftest auto-fill-multi-line-prefixless ()\n-  (test-auto-fill\n-   \"/*\n-\n- */\"\n-   4\n-   \"This is a very very very very very very very long string\"\n-   \"/*\n-This is a very very very very\n-very very very long string\n- */\"\n-   ))\n-\n-(defun test-indent (indented)\n-  (let ((deindented (replace-regexp-in-string \"^[[:blank:]]*\" \"      \" indented)))\n-    (rust-test-manip-code\n-     deindented\n-     1\n-     (lambda () (indent-region 1 (buffer-size)))\n-     indented)))\n-\n-\n-(ert-deftest indent-struct-fields-aligned ()\n-  (test-indent\n-   \"\n-struct Foo { bar: int,\n-             baz: int }\n-\n-struct Blah {x:int,\n-             y:int,\n-             z:String\"))\n-\n-(ert-deftest indent-doc-comments ()\n-  (test-indent\n-   \"\n-/**\n- * This is a doc comment\n- *\n- */\n-\n-/// So is this\n-\n-fn foo() {\n-    /*!\n-     * this is a nested doc comment\n-     */\n-\n-    //! And so is this\n-}\"))\n-\n-(ert-deftest indent-inside-braces ()\n-  (test-indent\n-   \"\n-// struct fields out one level:\n-struct foo {\n-    a:int,\n-    // comments too\n-    b:char\n-}\n-\n-fn bar(x:Box<int>) {   // comment here should not affect the next indent\n-    bla();\n-    bla();\n-}\"))\n-\n-(ert-deftest indent-top-level ()\n-  (test-indent\n-   \"\n-// Everything here is at the top level and should not be indented\n-#[attrib]\n-mod foo;\n-\n-pub static bar = Quux{a: b()}\n-\n-use foo::bar::baz;\n-\n-fn foo() { }\n-\"))\n-\n-(ert-deftest indent-params-no-align ()\n-  (test-indent\n-   \"\n-// Indent out one level because no params appear on the first line\n-fn xyzzy(\n-    a:int,\n-    b:char) { }\n-\n-fn abcdef(\n-    a:int,\n-    b:char)\n-    -> char\n-{ }\"))\n-\n-(ert-deftest indent-params-align ()\n-  (test-indent\n-   \"\n-// Align the second line of params to the first\n-fn foo(a:int,\n-       b:char) { }\n-\n-fn bar(   a:int,\n-          b:char)\n-          -> int\n-{ }\n-\n-fn baz(   a:int,  // should work with a comment here\n-          b:char)\n-          -> int\n-{ }\n-\"))\n-\n-(ert-deftest indent-square-bracket-alignment ()\n-  (test-indent\n-   \"\n-fn args_on_the_next_line( // with a comment\n-    a:int,\n-    b:String) {\n-    let aaaaaa = [\n-        1,\n-        2,\n-        3];\n-    let bbbbbbb = [1, 2, 3,\n-                   4, 5, 6];\n-    let ccc = [   10, 9, 8,\n-                  7, 6, 5];\n-}\n-\"))\n-\n-(ert-deftest indent-nested-fns ()\n-  (test-indent\n-   \"\n-fn nexted_fns(a: fn(b:int,\n-                    c:char)\n-                    -> int,\n-              d: int)\n-              -> uint\n-{\n-    0\n-}\n-\"\n-   ))\n-\n-(ert-deftest indent-multi-line-expr ()\n-  (test-indent\n-   \"\n-fn foo()\n-{\n-    x();\n-    let a =\n-        b();\n-}\n-\"\n-   ))\n-\n-(ert-deftest indent-match ()\n-  (test-indent\n-   \"\n-fn foo() {\n-    match blah {\n-        Pattern => stuff(),\n-        _ => whatever\n-    }\n-}\n-\"\n-   ))\n-\n-(ert-deftest indent-match-multiline-pattern ()\n-  (test-indent\n-   \"\n-fn foo() {\n-    match blah {\n-        Pattern |\n-        Pattern2 => {\n-            hello()\n-        },\n-        _ => whatever\n-    }\n-}\n-\"\n-   ))\n-\n-(ert-deftest indent-indented-match ()\n-  (test-indent\n-   \"\n-fn foo() {\n-    let x =\n-        match blah {\n-            Pattern |\n-            Pattern2 => {\n-                hello()\n-            },\n-            _ => whatever\n-        };\n-    y();\n-}\n-\"\n-   ))\n-\n-(ert-deftest indent-curly-braces-within-parens ()\n-  (test-indent\n-   \"\n-fn foo() {\n-    let x =\n-        foo(bar(|x| {\n-            only_one_indent_here();\n-        }));\n-    y();\n-}\n-\"\n-   ))\n-\n-(ert-deftest indent-weirdly-indented-block ()\n-  (rust-test-manip-code\n-   \"\n-fn foo() {\n- {\n-this_block_is_over_to_the_left_for_some_reason();\n- }\n-\n-}\n-\"\n-   16\n-   #'indent-for-tab-command\n-   \"\n-fn foo() {\n- {\n-     this_block_is_over_to_the_left_for_some_reason();\n- }\n-\n-}\n-\"\n-   ))\n-\n-(ert-deftest indent-multi-line-attrib ()\n-  (test-indent\n-   \"\n-#[attrib(\n-    this,\n-    that,\n-    theotherthing)]\n-fn function_with_multiline_attribute() {}\n-\"\n-   ))\n-\n-\n-;; Make sure that in effort to cover match patterns we don't mistreat || or expressions\n-(ert-deftest indent-nonmatch-or-expression ()\n-  (test-indent\n-   \"\n-fn foo() {\n-    let x = foo() ||\n-        bar();\n-}\n-\"\n-   ))\n-\n-(setq rust-test-motion-string\n-      \"\n-fn fn1(arg: int) -> bool {\n-    let x = 5;\n-    let y = b();\n-    true\n-}\n-\n-fn fn2(arg: int) -> bool {\n-    let x = 5;\n-    let y = b();\n-    true\n-}\n-\n-pub fn fn3(arg: int) -> bool {\n-    let x = 5;\n-    let y = b();\n-    true\n-}\n-\n-struct Foo {\n-    x: int\n-}\n-\"\n-      rust-test-region-string rust-test-motion-string\n-      rust-test-indent-motion-string\n-      \"\n-fn blank_line(arg:int) -> bool {\n-\n-}\n-\n-fn indenting_closing_brace() {\n-    if(true) {\n-}\n-}\n-\n-fn indenting_middle_of_line() {\n-    if(true) {\n- push_me_out();\n-} else {\n-               pull_me_back_in();\n-}\n-}\n-\n-fn indented_already() {\n-\n-    // The previous line already has its spaces\n-}\n-\"\n-\n-      ;; Symbol -> (line column)\n-      rust-test-positions-alist '((start-of-fn1 (2 0))\n-                                  (start-of-fn1-middle-of-line (2 15))\n-                                  (middle-of-fn1 (3 7))\n-                                  (end-of-fn1 (6 0))\n-                                  (between-fn1-fn2 (7 0))\n-                                  (start-of-fn2 (8 0))\n-                                  (middle-of-fn2 (10 4))\n-                                  (before-start-of-fn1 (1 0))\n-                                  (after-end-of-fn2 (13 0))\n-                                  (beginning-of-fn3 (14 0))\n-                                  (middle-of-fn3 (16 4))\n-                                  (middle-of-struct (21 10))\n-                                  (before-start-of-struct (19 0))\n-                                  (after-end-of-struct (23 0))\n-                                  (blank-line-indent-start (3 0))\n-                                  (blank-line-indent-target (3 4))\n-                                  (closing-brace-indent-start (8 1))\n-                                  (closing-brace-indent-target (8 5))\n-                                  (middle-push-indent-start (13 2))\n-                                  (middle-push-indent-target (13 9))\n-                                  (after-whitespace-indent-start (13 1))\n-                                  (after-whitespace-indent-target (13 8))\n-                                  (middle-pull-indent-start (15 19))\n-                                  (middle-pull-indent-target (15 12))\n-                                  (blank-line-indented-already-bol-start (20 0))\n-                                  (blank-line-indented-already-bol-target (20 4))\n-                                  (blank-line-indented-already-middle-start (20 2))\n-                                  (blank-line-indented-already-middle-target (20 4))\n-                                  (nonblank-line-indented-already-bol-start (21 0))\n-                                  (nonblank-line-indented-already-bol-target (21 4))\n-                                  (nonblank-line-indented-already-middle-start (21 2))\n-                                  (nonblank-line-indented-already-middle-target (21 4))))\n-\n-(defun rust-get-buffer-pos (pos-symbol)\n-  \"Get buffer position from POS-SYMBOL.\n-\n-POS-SYMBOL is a symbol found in `rust-test-positions-alist'.\n-Convert the line-column information from that list into a buffer position value.\"\n-  (interactive \"P\")\n-  (pcase-let ((`(,line ,column) (cadr (assoc pos-symbol rust-test-positions-alist))))\n-    (save-excursion\n-      (goto-line line)\n-      (move-to-column column)\n-      (point))))\n-\n-;;; FIXME: Maybe add an ERT explainer function (something that shows the\n-;;; surrounding code of the final point, not just the position).\n-(defun rust-test-motion (source-code init-pos final-pos manip-func &optional &rest args)\n-  \"Test that MANIP-FUNC moves point from INIT-POS to FINAL-POS.\n-\n-If ARGS are provided, send them to MANIP-FUNC.\n-\n-INIT-POS, FINAL-POS are position symbols found in `rust-test-positions-alist'.\"\n-  (with-temp-buffer\n-    (rust-mode)\n-    (insert source-code)\n-    (goto-char (rust-get-buffer-pos init-pos))\n-    (apply manip-func args)\n-    (should (equal (point) (rust-get-buffer-pos final-pos)))))\n-\n-(defun rust-test-region (source-code init-pos reg-beg reg-end manip-func &optional &rest args)\n-  \"Test that MANIP-FUNC marks region from REG-BEG to REG-END.\n-\n-INIT-POS is the initial position of point.\n-If ARGS are provided, send them to MANIP-FUNC.\n-All positions are position symbols found in `rust-test-positions-alist'.\"\n-  (with-temp-buffer\n-    (rust-mode)\n-    (insert source-code)\n-    (goto-char (rust-get-buffer-pos init-pos))\n-    (apply manip-func args)\n-    (should (equal (list (region-beginning) (region-end))\n-                   (list (rust-get-buffer-pos reg-beg)\n-                         (rust-get-buffer-pos reg-end))))))\n-\n-(ert-deftest rust-beginning-of-defun-from-middle-of-fn ()\n-  (rust-test-motion\n-   rust-test-motion-string\n-   'middle-of-fn1\n-   'start-of-fn1\n-   #'beginning-of-defun))\n-\n-(ert-deftest rust-beginning-of-defun-from-end ()\n-  (rust-test-motion\n-   rust-test-motion-string\n-   'end-of-fn1\n-   'start-of-fn1\n-   #'beginning-of-defun))\n-\n-(ert-deftest rust-beginning-of-defun-before-open-brace ()\n-  (rust-test-motion\n-   rust-test-motion-string\n-   'start-of-fn1-middle-of-line\n-   'start-of-fn1\n-   #'beginning-of-defun))\n-\n-(ert-deftest rust-beginning-of-defun-between-fns ()\n-  (rust-test-motion\n-   rust-test-motion-string\n-   'between-fn1-fn2\n-   'start-of-fn1\n-   #'beginning-of-defun))\n-\n-(ert-deftest rust-beginning-of-defun-with-arg ()\n-  (rust-test-motion\n-   rust-test-motion-string\n-   'middle-of-fn2\n-   'start-of-fn1\n-   #'beginning-of-defun 2))\n-\n-(ert-deftest rust-beginning-of-defun-with-negative-arg ()\n-  (rust-test-motion\n-   rust-test-motion-string\n-   'middle-of-fn1\n-   'beginning-of-fn3\n-   #'beginning-of-defun -2))\n-\n-(ert-deftest rust-beginning-of-defun-pub-fn ()\n-  (rust-test-motion\n-   rust-test-motion-string\n-   'middle-of-fn3\n-   'beginning-of-fn3\n-   #'beginning-of-defun))\n-\n-(ert-deftest rust-end-of-defun-from-middle-of-fn ()\n-  (rust-test-motion\n-   rust-test-motion-string\n-   'middle-of-fn1\n-   'between-fn1-fn2\n-   #'end-of-defun))\n-\n-(ert-deftest rust-end-of-defun-from-beg ()\n-  (rust-test-motion\n-   rust-test-motion-string\n-   'start-of-fn1\n-   'between-fn1-fn2\n-   #'end-of-defun))\n-\n-(ert-deftest rust-end-of-defun-before-open-brace ()\n-  (rust-test-motion\n-   rust-test-motion-string\n-   'start-of-fn1-middle-of-line\n-   'between-fn1-fn2\n-   #'end-of-defun))\n-\n-(ert-deftest rust-end-of-defun-between-fns ()\n-  (rust-test-motion\n-   rust-test-motion-string\n-   'between-fn1-fn2\n-   'after-end-of-fn2\n-   #'end-of-defun))\n-\n-(ert-deftest rust-end-of-defun-with-arg ()\n-  (rust-test-motion\n-   rust-test-motion-string\n-   'middle-of-fn1\n-   'after-end-of-fn2\n-   #'end-of-defun 2))\n-\n-(ert-deftest rust-end-of-defun-with-negative-arg ()\n-  (rust-test-motion\n-   rust-test-motion-string\n-   'middle-of-fn3\n-   'between-fn1-fn2\n-   #'end-of-defun -2))\n-\n-(ert-deftest rust-mark-defun-from-middle-of-fn ()\n-  (rust-test-region\n-   rust-test-region-string\n-   'middle-of-fn2\n-   'between-fn1-fn2 'after-end-of-fn2\n-   #'mark-defun))\n-\n-(ert-deftest rust-mark-defun-from-end ()\n-  (rust-test-region\n-   rust-test-region-string\n-   'end-of-fn1\n-   'before-start-of-fn1 'between-fn1-fn2\n-   #'mark-defun))\n-\n-(ert-deftest rust-mark-defun-start-of-defun ()\n-  (rust-test-region\n-   rust-test-region-string\n-   'start-of-fn2\n-   'between-fn1-fn2 'after-end-of-fn2\n-   #'mark-defun))\n-\n-(ert-deftest rust-mark-defun-from-middle-of-struct ()\n-  (rust-test-region\n-   rust-test-region-string\n-   'middle-of-struct\n-   'before-start-of-struct 'after-end-of-struct\n-   #'mark-defun))\n-\n-(ert-deftest indent-line-blank-line-motion ()\n-  (rust-test-motion\n-   rust-test-indent-motion-string\n-   'blank-line-indent-start\n-   'blank-line-indent-target\n-   #'indent-for-tab-command))\n-\n-(ert-deftest indent-line-closing-brace-motion ()\n-  (rust-test-motion\n-   rust-test-indent-motion-string\n-   'closing-brace-indent-start\n-   'closing-brace-indent-target\n-   #'indent-for-tab-command))\n-\n-(ert-deftest indent-line-middle-push-motion ()\n-  (rust-test-motion\n-   rust-test-indent-motion-string\n-   'middle-push-indent-start\n-   'middle-push-indent-target\n-   #'indent-for-tab-command))\n-\n-(ert-deftest indent-line-after-whitespace-motion ()\n-  (rust-test-motion\n-   rust-test-indent-motion-string\n-   'after-whitespace-indent-start\n-   'after-whitespace-indent-target\n-   #'indent-for-tab-command))\n-\n-(ert-deftest indent-line-middle-pull-motion ()\n-  (rust-test-motion\n-   rust-test-indent-motion-string\n-   'middle-pull-indent-start\n-   'middle-pull-indent-target\n-   #'indent-for-tab-command))\n-\n-(ert-deftest indent-line-blank-line-indented-already-bol ()\n-  (rust-test-motion\n-   rust-test-indent-motion-string\n-   'blank-line-indented-already-bol-start\n-   'blank-line-indented-already-bol-target\n-   #'indent-for-tab-command))\n-\n-(ert-deftest indent-line-blank-line-indented-already-middle ()\n-  (rust-test-motion\n-   rust-test-indent-motion-string\n-   'blank-line-indented-already-middle-start\n-   'blank-line-indented-already-middle-target\n-   #'indent-for-tab-command))\n-\n-(ert-deftest indent-line-nonblank-line-indented-already-bol ()\n-  (rust-test-motion\n-   rust-test-indent-motion-string\n-   'nonblank-line-indented-already-bol-start\n-   'nonblank-line-indented-already-bol-target\n-   #'indent-for-tab-command))\n-\n-(ert-deftest indent-line-nonblank-line-indented-already-middle ()\n-  (rust-test-motion\n-   rust-test-indent-motion-string\n-   'nonblank-line-indented-already-middle-start\n-   'nonblank-line-indented-already-middle-target\n-   #'indent-for-tab-command))\n-\n-(defun rust-test-fontify-string (str)\n-  (with-temp-buffer\n-    (rust-mode)\n-    (insert str)\n-    (font-lock-fontify-buffer)\n-    (buffer-string)))\n-\n-(defun rust-test-group-str-by-face (str)\n-  \"Fontify `STR' in rust-mode and group it by face, returning a\n-list of substrings of `STR' each followed by its face.\"\n-  (cl-loop with fontified = (rust-test-fontify-string str)\n-           for start = 0 then end\n-           while start\n-           for end   = (next-single-property-change start 'face fontified)\n-           for prop  = (get-text-property start 'face fontified)\n-           for text  = (substring-no-properties fontified start end)\n-           if prop\n-           append (list text prop)))\n-\n-(defun rust-test-font-lock (source face-groups)\n-  \"Test that `SOURCE' fontifies to the expected `FACE-GROUPS'\"\n-  (should (equal (rust-test-group-str-by-face source)\n-                 face-groups)))\n-\n-(ert-deftest font-lock-attribute-simple ()\n-  (rust-test-font-lock\n-   \"#[foo]\"\n-   '(\"#[foo]\" font-lock-preprocessor-face)))\n-\n-(ert-deftest font-lock-attribute-inner ()\n-  (rust-test-font-lock\n-   \"#![foo]\"\n-   '(\"#![foo]\" font-lock-preprocessor-face)))\n-\n-(ert-deftest font-lock-attribute-key-value ()\n-  (rust-test-font-lock\n-   \"#[foo = \\\"bar\\\"]\"\n-   '(\"#[foo = \" font-lock-preprocessor-face\n-     \"\\\"bar\\\"\" font-lock-string-face\n-     \"]\" font-lock-preprocessor-face)))\n-\n-(ert-deftest font-lock-attribute-around-comment ()\n-  (rust-test-font-lock\n-   \"#[foo /* bar */]\"\n-   '(\"#[foo \" font-lock-preprocessor-face\n-     \"/* \" font-lock-comment-delimiter-face\n-     \"bar */\" font-lock-comment-face\n-     \"]\" font-lock-preprocessor-face)))\n-\n-(ert-deftest font-lock-attribute-inside-string ()\n-  (rust-test-font-lock\n-   \"\\\"#[foo]\\\"\"\n-   '(\"\\\"#[foo]\\\"\" font-lock-string-face)))\n-\n-(ert-deftest font-lock-attribute-inside-comment ()\n-  (rust-test-font-lock\n-   \"/* #[foo] */\"\n-   '(\"/* \" font-lock-comment-delimiter-face\n-     \"#[foo] */\" font-lock-comment-face)))"}, {"sha": "dae685f3a540a63dc1185304c4710e7f42547673", "filename": "src/etc/emacs/rust-mode.el", "status": "removed", "additions": 0, "deletions": 520, "changes": 520, "blob_url": "https://github.com/rust-lang/rust/blob/c5961ad06d45689b44ff305c15d6ec7ec65755a9/src%2Fetc%2Femacs%2Frust-mode.el", "raw_url": "https://github.com/rust-lang/rust/raw/c5961ad06d45689b44ff305c15d6ec7ec65755a9/src%2Fetc%2Femacs%2Frust-mode.el", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Femacs%2Frust-mode.el?ref=c5961ad06d45689b44ff305c15d6ec7ec65755a9", "patch": "@@ -1,520 +0,0 @@\n-;;; rust-mode.el --- A major emacs mode for editing Rust source code\n-\n-;; Version: 0.2.0\n-;; Author: Mozilla\n-;; Url: https://github.com/rust-lang/rust\n-;; Keywords: languages\n-\n-;;; Commentary:\n-;;\n-\n-;;; Code:\n-\n-(eval-when-compile (require 'misc))\n-\n-;; for GNU Emacs < 24.3\n-(eval-when-compile\n-  (unless (fboundp 'setq-local)\n-    (defmacro setq-local (var val)\n-      \"Set variable VAR to value VAL in current buffer.\"\n-      (list 'set (list 'make-local-variable (list 'quote var)) val))))\n-\n-;; Syntax definitions and helpers\n-(defvar rust-mode-syntax-table\n-  (let ((table (make-syntax-table)))\n-\n-    ;; Operators\n-    (dolist (i '(?+ ?- ?* ?/ ?& ?| ?^ ?! ?< ?> ?~ ?@))\n-      (modify-syntax-entry i \".\" table))\n-\n-    ;; Strings\n-    (modify-syntax-entry ?\\\" \"\\\"\" table)\n-    (modify-syntax-entry ?\\\\ \"\\\\\" table)\n-\n-    ;; mark _ as a word constituent so that identifiers\n-    ;; such as xyz_type don't cause type to be highlighted\n-    ;; as a keyword\n-    (modify-syntax-entry ?_ \"w\" table)\n-\n-    ;; Comments\n-    (modify-syntax-entry ?/  \". 124b\" table)\n-    (modify-syntax-entry ?*  \". 23\"   table)\n-    (modify-syntax-entry ?\\n \"> b\"    table)\n-    (modify-syntax-entry ?\\^m \"> b\"   table)\n-\n-    table))\n-\n-(defgroup rust-mode nil\n-  \"Support for Rust code.\"\n-  :link '(url-link \"http://www.rust-lang.org/\")\n-  :group 'languages)\n-\n-(defcustom rust-indent-offset 4\n-  \"Indent Rust code by this number of spaces.\"\n-  :type 'integer\n-  :group 'rust-mode)\n-\n-(defcustom rust-indent-method-chain nil\n-  \"Indent Rust method chains, aligned by the '.' operators\"\n-  :type 'boolean\n-  :group 'rust-mode)\n-\n-(defun rust-paren-level () (nth 0 (syntax-ppss)))\n-(defun rust-in-str-or-cmnt () (nth 8 (syntax-ppss)))\n-(defun rust-rewind-past-str-cmnt () (goto-char (nth 8 (syntax-ppss))))\n-(defun rust-rewind-irrelevant ()\n-  (let ((starting (point)))\n-    (skip-chars-backward \"[:space:]\\n\")\n-    (if (looking-back \"\\\\*/\") (backward-char))\n-    (if (rust-in-str-or-cmnt)\n-        (rust-rewind-past-str-cmnt))\n-    (if (/= starting (point))\n-        (rust-rewind-irrelevant))))\n-\n-(defun rust-align-to-expr-after-brace ()\n-  (save-excursion\n-    (forward-char)\n-    ;; We don't want to indent out to the open bracket if the\n-    ;; open bracket ends the line\n-    (when (not (looking-at \"[[:blank:]]*\\\\(?://.*\\\\)?$\"))\n-      (when (looking-at \"[[:space:]]\")\n-    (forward-word 1)\n-    (backward-word 1))\n-      (current-column))))\n-\n-(defun rust-align-to-method-chain ()\n-  (save-excursion\n-    (previous-line)\n-    (end-of-line)\n-    (backward-word 1)\n-    (backward-char)\n-    (when (looking-at \"\\\\..+\\(.*\\)\\n\")\n-      (- (current-column) rust-indent-offset))))\n-\n-(defun rust-rewind-to-beginning-of-current-level-expr ()\n-  (let ((current-level (rust-paren-level)))\n-    (back-to-indentation)\n-    (while (> (rust-paren-level) current-level)\n-      (backward-up-list)\n-      (back-to-indentation))))\n-\n-(defun rust-mode-indent-line ()\n-  (interactive)\n-  (let ((indent\n-         (save-excursion\n-           (back-to-indentation)\n-           ;; Point is now at beginning of current line\n-           (let* ((level (rust-paren-level))\n-                  (baseline\n-                   ;; Our \"baseline\" is one level out from the indentation of the expression\n-                   ;; containing the innermost enclosing opening bracket.  That\n-                   ;; way if we are within a block that has a different\n-                   ;; indentation than this mode would give it, we still indent\n-                   ;; the inside of it correctly relative to the outside.\n-                   (if (= 0 level)\n-                       0\n-                     (or\n-                      (when rust-indent-method-chain\n-                        (rust-align-to-method-chain))\n-                     (save-excursion\n-                       (backward-up-list)\n-                       (rust-rewind-to-beginning-of-current-level-expr)\n-                       (+ (current-column) rust-indent-offset))))))\n-             (cond\n-              ;; A function return type is indented to the corresponding function arguments\n-              ((looking-at \"->\")\n-               (save-excursion\n-                 (backward-list)\n-                 (or (rust-align-to-expr-after-brace)\n-                     (+ baseline rust-indent-offset))))\n-\n-              ;; A closing brace is 1 level unindended\n-              ((looking-at \"}\") (- baseline rust-indent-offset))\n-\n-              ;;Line up method chains by their .'s\n-              ((when (and rust-indent-method-chain\n-                          (looking-at \"\\..+\\(.*\\);?\\n\"))\n-                 (or\n-                  (let ((method-indent (rust-align-to-method-chain)))\n-                    (when method-indent\n-                      (+ method-indent rust-indent-offset)))\n-                  (+ baseline rust-indent-offset))))\n-\n-              \n-              ;; Doc comments in /** style with leading * indent to line up the *s\n-              ((and (nth 4 (syntax-ppss)) (looking-at \"*\"))\n-               (+ 1 baseline))\n-\n-              ;; If we're in any other token-tree / sexp, then:\n-              (t\n-               (or\n-                ;; If we are inside a pair of braces, with something after the\n-                ;; open brace on the same line and ending with a comma, treat\n-                ;; it as fields and align them.\n-                (when (> level 0)\n-                  (save-excursion\n-                    (rust-rewind-irrelevant)\n-                    (backward-up-list)\n-                    ;; Point is now at the beginning of the containing set of braces\n-                    (rust-align-to-expr-after-brace)))\n-\n-                (progn\n-                  (back-to-indentation)\n-                  ;; Point is now at the beginning of the current line\n-                  (if (or\n-                       ;; If this line begins with \"else\" or \"{\", stay on the\n-                       ;; baseline as well (we are continuing an expression,\n-                       ;; but the \"else\" or \"{\" should align with the beginning\n-                       ;; of the expression it's in.)\n-                       (looking-at \"\\\\<else\\\\>\\\\|{\")\n-\n-                       (save-excursion\n-                         (rust-rewind-irrelevant)\n-                         ;; Point is now at the end of the previous ine\n-                         (or\n-                          ;; If we are at the first line, no indentation is needed, so stay at baseline...\n-                          (= 1 (line-number-at-pos (point)))\n-                          ;; ..or if the previous line ends with any of these:\n-                          ;;     { ? : ( , ; [ }\n-                          ;; then we are at the beginning of an expression, so stay on the baseline...\n-                          (looking-back \"[(,:;?[{}]\\\\|[^|]|\")\n-                          ;; or if the previous line is the end of an attribute, stay at the baseline...\n-                          (progn (rust-rewind-to-beginning-of-current-level-expr) (looking-at \"#\")))))\n-                      baseline\n-\n-                    ;; Otherwise, we are continuing the same expression from the previous line,\n-                    ;; so add one additional indent level\n-                    (+ baseline rust-indent-offset))))))))))\n-\n-    ;; If we're at the beginning of the line (before or at the current\n-    ;; indentation), jump with the indentation change.  Otherwise, save the\n-    ;; excursion so that adding the indentations will leave us at the\n-    ;; equivalent position within the line to where we were before.\n-    (if (<= (current-column) (current-indentation))\n-        (indent-line-to indent)\n-      (save-excursion (indent-line-to indent)))))\n-\n-\n-;; Font-locking definitions and helpers\n-(defconst rust-mode-keywords\n-  '(\"as\"\n-    \"box\" \"break\"\n-    \"const\" \"continue\" \"crate\"\n-    \"do\"\n-    \"else\" \"enum\" \"extern\"\n-    \"false\" \"fn\" \"for\"\n-    \"if\" \"impl\" \"in\"\n-    \"let\" \"loop\"\n-    \"match\" \"mod\" \"move\" \"mut\"\n-    \"priv\" \"pub\"\n-    \"ref\" \"return\"\n-    \"self\" \"static\" \"struct\" \"super\"\n-    \"true\" \"trait\" \"type\"\n-    \"unsafe\" \"use\"\n-    \"virtual\"\n-    \"where\" \"while\"))\n-\n-(defconst rust-special-types\n-  '(\"u8\" \"i8\"\n-    \"u16\" \"i16\"\n-    \"u32\" \"i32\"\n-    \"u64\" \"i64\"\n-\n-    \"f32\" \"f64\"\n-    \"float\" \"int\" \"uint\" \"isize\" \"usize\"\n-    \"bool\"\n-    \"str\" \"char\"))\n-\n-(defconst rust-re-ident \"[[:word:][:multibyte:]_][[:word:][:multibyte:]_[:digit:]]*\")\n-(defconst rust-re-CamelCase \"[[:upper:]][[:word:][:multibyte:]_[:digit:]]*\")\n-(defun rust-re-word (inner) (concat \"\\\\<\" inner \"\\\\>\"))\n-(defun rust-re-grab (inner) (concat \"\\\\(\" inner \"\\\\)\"))\n-(defun rust-re-grabword (inner) (rust-re-grab (rust-re-word inner)))\n-(defun rust-re-item-def (itype)\n-  (concat (rust-re-word itype) \"[[:space:]]+\" (rust-re-grab rust-re-ident)))\n-\n-(defvar rust-mode-font-lock-keywords\n-  (append\n-   `(\n-     ;; Keywords proper\n-     (,(regexp-opt rust-mode-keywords 'words) . font-lock-keyword-face)\n-\n-     ;; Special types\n-     (,(regexp-opt rust-special-types 'words) . font-lock-type-face)\n-\n-     ;; Attributes like `#[bar(baz)]` or `#![bar(baz)]` or `#[bar = \"baz\"]`\n-     (,(rust-re-grab (concat \"#\\\\!?\\\\[\" rust-re-ident \"[^]]*\\\\]\"))\n-      1 font-lock-preprocessor-face keep)\n-\n-     ;; Syntax extension invocations like `foo!`, highlight including the !\n-     (,(concat (rust-re-grab (concat rust-re-ident \"!\")) \"[({[:space:][]\")\n-      1 font-lock-preprocessor-face)\n-\n-     ;; Field names like `foo:`, highlight excluding the :\n-     (,(concat (rust-re-grab rust-re-ident) \":[^:]\") 1 font-lock-variable-name-face)\n-\n-     ;; Module names like `foo::`, highlight including the ::\n-     (,(rust-re-grab (concat rust-re-ident \"::\")) 1 font-lock-type-face)\n-\n-     ;; Lifetimes like `'foo`\n-     (,(concat \"'\" (rust-re-grab rust-re-ident) \"[^']\") 1 font-lock-variable-name-face)\n-\n-     ;; Character constants, since they're not treated as strings\n-     ;; in order to have sufficient leeway to parse 'lifetime above.\n-     (,(rust-re-grab \"'[^']'\") 1 font-lock-string-face)\n-     (,(rust-re-grab \"'\\\\\\\\[nrt]'\") 1 font-lock-string-face)\n-     (,(rust-re-grab \"'\\\\\\\\x[[:xdigit:]]\\\\{2\\\\}'\") 1 font-lock-string-face)\n-     (,(rust-re-grab \"'\\\\\\\\u[[:xdigit:]]\\\\{4\\\\}'\") 1 font-lock-string-face)\n-     (,(rust-re-grab \"'\\\\\\\\U[[:xdigit:]]\\\\{8\\\\}'\") 1 font-lock-string-face)\n-\n-     ;; CamelCase Means Type Or Constructor\n-     (,(rust-re-grabword rust-re-CamelCase) 1 font-lock-type-face)\n-     )\n-\n-   ;; Item definitions\n-   (mapcar #'(lambda (x)\n-               (list (rust-re-item-def (car x))\n-                     1 (cdr x)))\n-           '((\"enum\" . font-lock-type-face)\n-             (\"struct\" . font-lock-type-face)\n-             (\"type\" . font-lock-type-face)\n-             (\"mod\" . font-lock-type-face)\n-             (\"use\" . font-lock-type-face)\n-             (\"fn\" . font-lock-function-name-face)\n-             (\"static\" . font-lock-constant-face)))))\n-\n-(defun rust-fill-prefix-for-comment-start (line-start)\n-  \"Determine what to use for `fill-prefix' based on what is at the beginning of a line.\"\n-  (let ((result\n-         ;; Replace /* with same number of spaces\n-         (replace-regexp-in-string\n-          \"\\\\(?:/\\\\*+\\\\)[!*]\"\n-          (lambda (s)\n-            ;; We want the * to line up with the first * of the comment start\n-            (concat (make-string (- (length s) 2) ?\\x20) \"*\"))\n-          line-start)))\n-    ;; Make sure we've got at least one space at the end\n-    (if (not (= (aref result (- (length result) 1)) ?\\x20))\n-        (setq result (concat result \" \")))\n-    result))\n-\n-(defun rust-in-comment-paragraph (body)\n-  ;; We might move the point to fill the next comment, but we don't want it\n-  ;; seeming to jump around on the user\n-  (save-excursion\n-    ;; If we're outside of a comment, with only whitespace and then a comment\n-    ;; in front, jump to the comment and prepare to fill it.\n-    (when (not (nth 4 (syntax-ppss)))\n-      (beginning-of-line)\n-      (when (looking-at (concat \"[[:space:]\\n]*\" comment-start-skip))\n-        (goto-char (match-end 0))))\n-\n-    ;; We need this when we're moving the point around and then checking syntax\n-    ;; while doing paragraph fills, because the cache it uses isn't always\n-    ;; invalidated during this.\n-    (syntax-ppss-flush-cache 1)\n-    ;; If we're at the beginning of a comment paragraph with nothing but\n-    ;; whitespace til the next line, jump to the next line so that we use the\n-    ;; existing prefix to figure out what the new prefix should be, rather than\n-    ;; inferring it from the comment start.\n-    (let ((next-bol (line-beginning-position 2)))\n-      (while (save-excursion\n-               (end-of-line)\n-               (syntax-ppss-flush-cache 1)\n-               (and (nth 4 (syntax-ppss))\n-                    (save-excursion\n-                      (beginning-of-line)\n-                      (looking-at paragraph-start))\n-                    (looking-at \"[[:space:]]*$\")\n-                    (nth 4 (syntax-ppss next-bol))))\n-        (goto-char next-bol)))\n-\n-    (syntax-ppss-flush-cache 1)\n-    ;; If we're on the last line of a multiline-style comment that started\n-    ;; above, back up one line so we don't mistake the * of the */ that ends\n-    ;; the comment for a prefix.\n-    (when (save-excursion\n-            (and (nth 4 (syntax-ppss (line-beginning-position 1)))\n-                 (looking-at \"[[:space:]]*\\\\*/\")))\n-      (goto-char (line-end-position 0)))\n-    (funcall body)))\n-\n-(defun rust-with-comment-fill-prefix (body)\n-  (let*\n-      ((line-string (buffer-substring-no-properties\n-                     (line-beginning-position) (line-end-position)))\n-       (line-comment-start\n-        (when (nth 4 (syntax-ppss))\n-          (cond\n-           ;; If we're inside the comment and see a * prefix, use it\n-           ((string-match \"^\\\\([[:space:]]*\\\\*+[[:space:]]*\\\\)\"\n-                          line-string)\n-            (match-string 1 line-string))\n-           ;; If we're at the start of a comment, figure out what prefix\n-           ;; to use for the subsequent lines after it\n-           ((string-match (concat \"[[:space:]]*\" comment-start-skip) line-string)\n-            (rust-fill-prefix-for-comment-start\n-             (match-string 0 line-string))))))\n-       (fill-prefix\n-        (or line-comment-start\n-            fill-prefix)))\n-    (funcall body)))\n-\n-(defun rust-find-fill-prefix ()\n-  (rust-with-comment-fill-prefix (lambda () fill-prefix)))\n-\n-(defun rust-fill-paragraph (&rest args)\n-  \"Special wrapping for `fill-paragraph' to handle multi-line comments with a * prefix on each line.\"\n-  (rust-in-comment-paragraph\n-   (lambda ()\n-     (rust-with-comment-fill-prefix\n-      (lambda ()\n-        (let\n-            ((fill-paragraph-function\n-              (if (not (eq fill-paragraph-function 'rust-fill-paragraph))\n-                  fill-paragraph-function))\n-             (fill-paragraph-handle-comment t))\n-          (apply 'fill-paragraph args)\n-          t))))))\n-\n-(defun rust-do-auto-fill (&rest args)\n-  \"Special wrapping for `do-auto-fill' to handle multi-line comments with a * prefix on each line.\"\n-  (rust-with-comment-fill-prefix\n-   (lambda ()\n-     (apply 'do-auto-fill args)\n-     t)))\n-\n-(defun rust-fill-forward-paragraph (arg)\n-  ;; This is to work around some funny behavior when a paragraph separator is\n-  ;; at the very top of the file and there is a fill prefix.\n-  (let ((fill-prefix nil)) (forward-paragraph arg)))\n-\n-(defun rust-comment-indent-new-line (&optional arg)\n-  (rust-with-comment-fill-prefix\n-   (lambda () (comment-indent-new-line arg))))\n-\n-;;; Imenu support\n-(defvar rust-imenu-generic-expression\n-  (append (mapcar #'(lambda (x)\n-                      (list nil (rust-re-item-def x) 1))\n-                  '(\"enum\" \"struct\" \"type\" \"mod\" \"fn\" \"trait\"))\n-          `((\"Impl\" ,(rust-re-item-def \"impl\") 1)))\n-  \"Value for `imenu-generic-expression' in Rust mode.\n-\n-Create a flat index of the item definitions in a Rust file.\n-\n-Imenu will show all the enums, structs, etc. at the same level.\n-Implementations will be shown under the `Impl` subheading.  Use\n-idomenu (imenu with `ido-mode') for best mileage.\")\n-\n-;;; Defun Motions\n-\n-;;; Start of a Rust item\n-(defvar rust-top-item-beg-re\n-  (concat \"^\\\\s-*\\\\(?:priv\\\\|pub\\\\)?\\\\s-*\"\n-          (regexp-opt\n-           '(\"enum\" \"struct\" \"type\" \"mod\" \"use\" \"fn\" \"static\" \"impl\"\n-             \"extern\" \"impl\" \"static\" \"trait\"))))\n-\n-(defun rust-beginning-of-defun (&optional arg)\n-  \"Move backward to the beginning of the current defun.\n-\n-With ARG, move backward multiple defuns.  Negative ARG means\n-move forward.\n-\n-This is written mainly to be used as `beginning-of-defun-function' for Rust.\n-Don't move to the beginning of the line. `beginning-of-defun',\n-which calls this, does that afterwards.\"\n-  (interactive \"p\")\n-  (re-search-backward (concat \"^\\\\(\" rust-top-item-beg-re \"\\\\)\\\\_>\")\n-                      nil 'move (or arg 1)))\n-\n-(defun rust-end-of-defun ()\n-  \"Move forward to the next end of defun.\n-\n-With argument, do it that many times.\n-Negative argument -N means move back to Nth preceding end of defun.\n-\n-Assume that this is called after beginning-of-defun. So point is\n-at the beginning of the defun body.\n-\n-This is written mainly to be used as `end-of-defun-function' for Rust.\"\n-  (interactive \"p\")\n-  ;; Find the opening brace\n-  (re-search-forward \"[{]\" nil t)\n-  (goto-char (match-beginning 0))\n-  ;; Go to the closing brace\n-  (forward-sexp))\n-\n-;; For compatibility with Emacs < 24, derive conditionally\n-(defalias 'rust-parent-mode\n-  (if (fboundp 'prog-mode) 'prog-mode 'fundamental-mode))\n-\n-\n-;;;###autoload\n-(define-derived-mode rust-mode rust-parent-mode \"Rust\"\n-  \"Major mode for Rust code.\"\n-  :group 'rust-mode\n-  :syntax-table rust-mode-syntax-table\n-\n-  ;; Indentation\n-  (setq-local indent-line-function 'rust-mode-indent-line)\n-\n-  ;; Fonts\n-  (setq-local font-lock-defaults '(rust-mode-font-lock-keywords nil nil nil nil))\n-\n-  ;; Misc\n-  (setq-local comment-start \"// \")\n-  (setq-local comment-end   \"\")\n-  (setq-local indent-tabs-mode nil)\n-\n-  ;; Allow paragraph fills for comments\n-  (setq-local comment-start-skip \"\\\\(?://[/!]*\\\\|/\\\\*[*!]?\\\\)[[:space:]]*\")\n-  (setq-local paragraph-start\n-       (concat \"[[:space:]]*\\\\(?:\" comment-start-skip \"\\\\|\\\\*/?[[:space:]]*\\\\|\\\\)$\"))\n-  (setq-local paragraph-separate paragraph-start)\n-  (setq-local normal-auto-fill-function 'rust-do-auto-fill)\n-  (setq-local fill-paragraph-function 'rust-fill-paragraph)\n-  (setq-local fill-forward-paragraph-function 'rust-fill-forward-paragraph)\n-  (setq-local adaptive-fill-function 'rust-find-fill-prefix)\n-  (setq-local comment-multi-line t)\n-  (setq-local comment-line-break-function 'rust-comment-indent-new-line)\n-  (setq-local imenu-generic-expression rust-imenu-generic-expression)\n-  (setq-local beginning-of-defun-function 'rust-beginning-of-defun)\n-  (setq-local end-of-defun-function 'rust-end-of-defun))\n-\n-;;;###autoload\n-(add-to-list 'auto-mode-alist '(\"\\\\.rs\\\\'\" . rust-mode))\n-\n-(defun rust-mode-reload ()\n-  (interactive)\n-  (unload-feature 'rust-mode)\n-  (require 'rust-mode)\n-  (rust-mode))\n-\n-;; Issue #6887: Rather than inheriting the 'gnu compilation error\n-;; regexp (which is broken on a few edge cases), add our own 'rust\n-;; compilation error regexp and use it instead.\n-(defvar rustc-compilation-regexps\n-  (let ((file \"\\\\([^\\n]+\\\\)\")\n-        (start-line \"\\\\([0-9]+\\\\)\")\n-        (start-col  \"\\\\([0-9]+\\\\)\")\n-        (end-line   \"\\\\([0-9]+\\\\)\")\n-        (end-col    \"\\\\([0-9]+\\\\)\")\n-        (error-or-warning \"\\\\(?:[Ee]rror\\\\|\\\\([Ww]arning\\\\)\\\\)\"))\n-    (let ((re (concat \"^\" file \":\" start-line \":\" start-col\n-                      \": \" end-line \":\" end-col\n-                      \" \\\\(?:[Ee]rror\\\\|\\\\([Ww]arning\\\\)\\\\):\")))\n-      (cons re '(1 (2 . 4) (3 . 5) (6)))))\n-  \"Specifications for matching errors in rustc invocations.\n-See `compilation-error-regexp-alist for help on their format.\")\n-\n-(eval-after-load 'compile\n-  '(progn\n-     (add-to-list 'compilation-error-regexp-alist-alist\n-                  (cons 'rustc rustc-compilation-regexps))\n-     (add-to-list 'compilation-error-regexp-alist 'rustc)))\n-\n-(provide 'rust-mode)\n-\n-;;; rust-mode.el ends here"}, {"sha": "e394f1916088f081c36505288f8b30f500b08307", "filename": "src/etc/gedit/readme.txt", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c5961ad06d45689b44ff305c15d6ec7ec65755a9/src%2Fetc%2Fgedit%2Freadme.txt", "raw_url": "https://github.com/rust-lang/rust/raw/c5961ad06d45689b44ff305c15d6ec7ec65755a9/src%2Fetc%2Fgedit%2Freadme.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgedit%2Freadme.txt?ref=c5961ad06d45689b44ff305c15d6ec7ec65755a9", "patch": "@@ -1,10 +0,0 @@\n-Add syntax highlighting for Mozilla Rust in GtkSourceView (used by GEdit).\n-\n-\n-Instructions for Ubuntu Linux 12.04+\n-\n-1) Close all instances of GEdit\n-\n-2) Copy the included \"share\" folder into \"~/.local/\"\n-\n-3) Open a shell in \"~/.local/share/\" and run \"update-mime-database mime\""}, {"sha": "8291b38a9bd0b94b8c970ba648d0d3db7ef1b819", "filename": "src/etc/gedit/share/gtksourceview-3.0/language-specs/rust.lang", "status": "removed", "additions": 0, "deletions": 340, "changes": 340, "blob_url": "https://github.com/rust-lang/rust/blob/c5961ad06d45689b44ff305c15d6ec7ec65755a9/src%2Fetc%2Fgedit%2Fshare%2Fgtksourceview-3.0%2Flanguage-specs%2Frust.lang", "raw_url": "https://github.com/rust-lang/rust/raw/c5961ad06d45689b44ff305c15d6ec7ec65755a9/src%2Fetc%2Fgedit%2Fshare%2Fgtksourceview-3.0%2Flanguage-specs%2Frust.lang", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgedit%2Fshare%2Fgtksourceview-3.0%2Flanguage-specs%2Frust.lang?ref=c5961ad06d45689b44ff305c15d6ec7ec65755a9", "patch": "@@ -1,340 +0,0 @@\n-<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n-\n-<!-- Syntax highlighting for the under-development Mozilla Rust language -->\n-\n-<language id=\"rust\" _name=\"Rust\" version=\"2.0\" _section=\"Sources\">\n-  <metadata>\n-    <property name=\"mimetypes\">text/x-rust</property>\n-    <property name=\"globs\">*.rs</property>\n-    <property name=\"line-comment-start\">//</property>\n-    <property name=\"block-comment-start\">/*</property>\n-    <property name=\"block-comment-end\">*/</property>\n-  </metadata>\n-\n-  <styles>\n-    <style id=\"comment\" _name=\"Comment\" map-to=\"def:comment\"/>\n-    <style id=\"string\" _name=\"String\" map-to=\"def:string\"/>\n-    <style id=\"char\" _name=\"Character\" map-to=\"def:character\"/>\n-    <style id=\"keyword\" _name=\"Keyword\" map-to=\"def:keyword\"/>\n-    <style id=\"type\" _name=\"Data Type\" map-to=\"def:type\"/>\n-    <style id=\"constant\" _name=\"Constant\" map-to=\"def:constant\"/>\n-    <style id=\"identifier\" _name=\"Identifier\" map-to=\"def:identifier\"/>\n-    <style id=\"number\" _name=\"Number\" map-to=\"def:number\"/>\n-    <style id=\"scope\" _name=\"Scope\" map-to=\"def:preprocessor\"/>\n-    <style id=\"attribute\" _name=\"Attribute\" map-to=\"def:preprocessor\"/>\n-    <style id=\"macro\" _name=\"Macro\" map-to=\"def:preprocessor\"/>\n-  </styles>\n-\n-  <definitions>\n-\n-    <context id=\"function\" style-ref=\"keyword\">\n-\t\t<keyword>fn</keyword>\n-    </context>\n-\n-    <context id=\"type\" style-ref=\"keyword\">\n-\t\t<keyword>type</keyword>\n-    </context>\n-\n-    <context id=\"keywords\" style-ref=\"keyword\">\n-\t\t<keyword>as</keyword>\n-\t\t<keyword>assert</keyword>\n-\t\t<keyword>break</keyword>\n-\t\t<keyword>box</keyword>\n-\t\t<keyword>const</keyword>\n-\t\t<keyword>continue</keyword>\n-\t\t<keyword>crate</keyword>\n-\t\t<keyword>do</keyword>\n-\t\t<keyword>drop</keyword>\n-\t\t<keyword>else</keyword>\n-\t\t<keyword>enum</keyword>\n-\t\t<keyword>export</keyword>\n-\t\t<keyword>extern</keyword>\n-\t\t<keyword>fail</keyword>\n-\t\t<keyword>for</keyword>\n-\t\t<keyword>if</keyword>\n-\t\t<keyword>impl</keyword>\n-\t\t<keyword>in</keyword>\n-\t\t<keyword>let</keyword>\n-\t\t<keyword>log</keyword>\n-\t\t<keyword>loop</keyword>\n-\t\t<keyword>match</keyword>\n-\t\t<keyword>mod</keyword>\n-\t\t<keyword>move</keyword>\n-\t\t<keyword>mut</keyword>\n-\t\t<keyword>priv</keyword>\n-\t\t<keyword>pub</keyword>\n-\t\t<keyword>pure</keyword>\n-\t\t<keyword>ref</keyword>\n-\t\t<keyword>return</keyword>\n-\t\t<keyword>static</keyword>\n-\t\t<keyword>struct</keyword>\n-\t\t<keyword>trait</keyword>\n-\t\t<keyword>unsafe</keyword>\n-\t\t<keyword>use</keyword>\n-\t\t<keyword>virtual</keyword>\n-\t\t<keyword>where</keyword>\n-\t\t<keyword>while</keyword>\n-    </context>\n-\n-    <context id=\"types\" style-ref=\"type\">\n-\t\t<keyword>bool</keyword>\n-\t\t<keyword>int</keyword>\n-\t\t<keyword>isize</keyword>\n-\t\t<keyword>uint</keyword>\n-\t\t<keyword>usize</keyword>\n-\t\t<keyword>i8</keyword>\n-\t\t<keyword>i16</keyword>\n-\t\t<keyword>i32</keyword>\n-\t\t<keyword>i64</keyword>\n-\t\t<keyword>u8</keyword>\n-\t\t<keyword>u16</keyword>\n-\t\t<keyword>u32</keyword>\n-\t\t<keyword>u64</keyword>\n-\t\t<keyword>f32</keyword>\n-\t\t<keyword>f64</keyword>\n-\t\t<keyword>char</keyword>\n-\t\t<keyword>str</keyword>\n-\t\t<keyword>Option</keyword>\n-\t\t<keyword>Result</keyword>\n-    </context>\n-\n-    <context id=\"ctypes\" style-ref=\"type\">\n-\t\t<keyword>c_float</keyword>\n-\t\t<keyword>c_double</keyword>\n-\t\t<keyword>c_void</keyword>\n-\t\t<keyword>FILE</keyword>\n-\t\t<keyword>fpos_t</keyword>\n-\t\t<keyword>DIR</keyword>\n-\t\t<keyword>dirent</keyword>\n-\t\t<keyword>c_char</keyword>\n-\t\t<keyword>c_schar</keyword>\n-\t\t<keyword>c_uchar</keyword>\n-\t\t<keyword>c_short</keyword>\n-\t\t<keyword>c_ushort</keyword>\n-\t\t<keyword>c_int</keyword>\n-\t\t<keyword>c_uint</keyword>\n-\t\t<keyword>c_long</keyword>\n-\t\t<keyword>c_ulong</keyword>\n-\t\t<keyword>size_t</keyword>\n-\t\t<keyword>ptrdiff_t</keyword>\n-\t\t<keyword>clock_t</keyword>\n-\t\t<keyword>time_t</keyword>\n-\t\t<keyword>c_longlong</keyword>\n-\t\t<keyword>c_ulonglong</keyword>\n-\t\t<keyword>intptr_t</keyword>\n-\t\t<keyword>uintptr_t</keyword>\n-\t\t<keyword>off_t</keyword>\n-\t\t<keyword>dev_t</keyword>\n-\t\t<keyword>ino_t</keyword>\n-\t\t<keyword>pid_t</keyword>\n-\t\t<keyword>mode_t</keyword>\n-\t\t<keyword>ssize_t</keyword>\n-    </context>\n-\n-    <context id=\"self\" style-ref=\"identifier\">\n-\t\t<keyword>self</keyword>\n-    </context>\n-\n-    <context id=\"constants\" style-ref=\"constant\">\n-\t\t<keyword>true</keyword>\n-\t\t<keyword>false</keyword>\n-\t\t<keyword>Some</keyword>\n-\t\t<keyword>None</keyword>\n-\t\t<keyword>Ok</keyword>\n-\t\t<keyword>Err</keyword>\n-\t\t<keyword>Success</keyword>\n-\t\t<keyword>Failure</keyword>\n-\t\t<keyword>Cons</keyword>\n-\t\t<keyword>Nil</keyword>\n-    </context>\n-\n-    <context id=\"cconstants\" style-ref=\"constant\">\n-\t\t<keyword>EXIT_FAILURE</keyword>\n-\t\t<keyword>EXIT_SUCCESS</keyword>\n-\t\t<keyword>RAND_MAX</keyword>\n-\t\t<keyword>EOF</keyword>\n-\t\t<keyword>SEEK_SET</keyword>\n-\t\t<keyword>SEEK_CUR</keyword>\n-\t\t<keyword>SEEK_END</keyword>\n-\t\t<keyword>_IOFBF</keyword>\n-\t\t<keyword>_IONBF</keyword>\n-\t\t<keyword>_IOLBF</keyword>\n-\t\t<keyword>BUFSIZ</keyword>\n-\t\t<keyword>FOPEN_MAX</keyword>\n-\t\t<keyword>FILENAME_MAX</keyword>\n-\t\t<keyword>L_tmpnam</keyword>\n-\t\t<keyword>TMP_MAX</keyword>\n-\t\t<keyword>O_RDONLY</keyword>\n-\t\t<keyword>O_WRONLY</keyword>\n-\t\t<keyword>O_RDWR</keyword>\n-\t\t<keyword>O_APPEND</keyword>\n-\t\t<keyword>O_CREAT</keyword>\n-\t\t<keyword>O_EXCL</keyword>\n-\t\t<keyword>O_TRUNC</keyword>\n-\t\t<keyword>S_IFIFO</keyword>\n-\t\t<keyword>S_IFCHR</keyword>\n-\t\t<keyword>S_IFBLK</keyword>\n-\t\t<keyword>S_IFDIR</keyword>\n-\t\t<keyword>S_IFREG</keyword>\n-\t\t<keyword>S_IFMT</keyword>\n-\t\t<keyword>S_IEXEC</keyword>\n-\t\t<keyword>S_IWRITE</keyword>\n-\t\t<keyword>S_IREAD</keyword>\n-\t\t<keyword>S_IRWXU</keyword>\n-\t\t<keyword>S_IXUSR</keyword>\n-\t\t<keyword>S_IWUSR</keyword>\n-\t\t<keyword>S_IRUSR</keyword>\n-\t\t<keyword>F_OK</keyword>\n-\t\t<keyword>R_OK</keyword>\n-\t\t<keyword>W_OK</keyword>\n-\t\t<keyword>X_OK</keyword>\n-\t\t<keyword>STDIN_FILENO</keyword>\n-\t\t<keyword>STDOUT_FILENO</keyword>\n-\t\t<keyword>STDERR_FILENO</keyword>\n-    </context>\n-\n-    <context id=\"line-comment\" style-ref=\"comment\" end-at-line-end=\"true\" class=\"comment\" class-disabled=\"no-spell-check\">\n-      <start>//</start>\n-      <include>\n-        <context ref=\"def:in-line-comment\"/>\n-      </include>\n-    </context>\n-\n-    <context id=\"block-comment\" style-ref=\"comment\" class=\"comment\" class-disabled=\"no-spell-check\">\n-      <start>/\\*</start>\n-      <end>\\*/</end>\n-      <include>\n-        <context ref=\"def:in-comment\"/>\n-      </include>\n-    </context>\n-\n-    <define-regex id=\"int_suffix\" extended=\"true\">\n-      (i8|i16|i32|i64|i|u8|u16|u32|u64|u)\n-    </define-regex>\n-\n-    <define-regex id=\"exponent\" extended=\"true\">\n-      ([eE][+-]?[0-9_]+)\n-    </define-regex>\n-\n-    <define-regex id=\"float_suffix\" extended=\"true\">\n-      (\\%{exponent}?(f32|f64)?)|(\\.[0-9][0-9_]*\\%{exponent}?)?(f32|f64)?|\\.\n-    </define-regex>\n-\n-    <define-regex id=\"num_suffix\" extended=\"true\">\n-      \\%{int_suffix}|\\%{float_suffix}\n-    </define-regex>\n-\n-    <define-regex id=\"hex_digit\" extended=\"true\">\n-      [0-9a-fA-F]\n-    </define-regex>\n-\n-    <define-regex id=\"oct_digit\" extended=\"true\">\n-      [0-7]\n-    </define-regex>\n-\n-    <context id=\"number\" style-ref=\"number\">\n-      <match extended=\"true\">\n-        ((?&lt;=\\.\\.)|(?&lt;![\\w\\.]))\n-        (\n-        [1-9][0-9_]*\\%{num_suffix}?|\n-        0[0-9_]*\\%{num_suffix}?|\n-        0b[01_]+\\%{int_suffix}?|\n-        0o(\\%{oct_digit}|_)+\\%{int_suffix}?|\n-        0x(\\%{hex_digit}|_)+\\%{int_suffix}?\n-        )\n-        ((?![\\w\\.].)|(?=\\.\\.))\n-      </match>\n-    </context>\n-\n-    <define-regex id=\"ident\" extended=\"true\">\n-      ([^[:cntrl:][:space:][:punct:][:digit:]]|_)([^[:cntrl:][:punct:][:space:]]|_)*\n-    </define-regex>\n-\n-    <context id=\"scope\" style-ref=\"scope\">\n-      <match extended=\"true\">\n-        \\%{ident}::\n-      </match>\n-    </context>\n-\n-    <context id=\"macro\" style-ref=\"macro\">\n-      <match extended=\"true\">\n-        \\%{ident}!\n-      </match>\n-    </context>\n-\n-    <context id=\"lifetime\" style-ref=\"keyword\">\n-      <match extended=\"true\">\n-        '\\%{ident}\n-      </match>\n-    </context>\n-\n-    <define-regex id=\"common_escape\" extended=\"true\">\n-      '|\"|\n-      \\\\|n|r|t|0|\n-      x\\%{hex_digit}{2}|\n-      u{\\%{hex_digit}{1,6}}|\n-      u\\%{hex_digit}{4}|\n-      U\\%{hex_digit}{8}\n-    </define-regex>\n-\n-    <context id=\"string_escape\" style-ref=\"def:special-char\">\n-      <match>\\\\\\%{common_escape}</match>\n-    </context>\n-\n-    <context id=\"raw-string\" style-ref=\"string\" class=\"string\" class-disabled=\"no-spell-check\">\n-      <start>r(#*)\"</start>\n-      <end>\"\\%{1@start}</end>\n-      <include>\n-        <context ref=\"def:line-continue\"/>\n-      </include>\n-    </context>\n-\n-    <context id=\"string\" style-ref=\"string\" class=\"string\" class-disabled=\"no-spell-check\">\n-      <start>\"</start>\n-      <end>\"</end>\n-      <include>\n-        <context ref=\"string_escape\"/>\n-        <context ref=\"def:line-continue\"/>\n-      </include>\n-    </context>\n-\n-    <context id=\"char\" style-ref=\"char\">\n-      <match extended=\"true\">'([^\\\\']|\\\\\\%{common_escape})'</match>\n-    </context>\n-\n-    <context id=\"attribute\" style-ref=\"attribute\" class=\"attribute\">\n-      <start extended=\"true\">\\#!?\\[</start>\n-      <end>\\]</end>\n-      <include>\n-        <context ref=\"def:in-comment\"/>\n-        <context ref=\"string\"/>\n-        <context ref=\"raw-string\"/>\n-      </include>\n-    </context>\n-\n-    <context id=\"rust\" class=\"no-spell-check\">\n-      <include>\n-        <context ref=\"function\"/>\n-        <context ref=\"type\"/>\n-        <context ref=\"keywords\"/>\n-        <context ref=\"types\"/>\n-        <context ref=\"ctypes\"/>\n-        <context ref=\"self\"/>\n-        <context ref=\"macro\"/>\n-        <context ref=\"constants\"/>\n-        <context ref=\"cconstants\"/>\n-        <context ref=\"line-comment\"/>\n-        <context ref=\"block-comment\"/>\n-        <context ref=\"number\"/>\n-        <context ref=\"scope\"/>\n-        <context ref=\"string\"/>\n-        <context ref=\"raw-string\"/>\n-        <context ref=\"char\"/>\n-        <context ref=\"lifetime\"/>\n-        <context ref=\"attribute\"/>\n-      </include>\n-    </context>\n-\n-  </definitions>\n-\n-</language>"}, {"sha": "ede1c14907c8ba2905d49f0b0ebfbf010f878a3d", "filename": "src/etc/gedit/share/mime/packages/rust.xml", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c5961ad06d45689b44ff305c15d6ec7ec65755a9/src%2Fetc%2Fgedit%2Fshare%2Fmime%2Fpackages%2Frust.xml", "raw_url": "https://github.com/rust-lang/rust/raw/c5961ad06d45689b44ff305c15d6ec7ec65755a9/src%2Fetc%2Fgedit%2Fshare%2Fmime%2Fpackages%2Frust.xml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgedit%2Fshare%2Fmime%2Fpackages%2Frust.xml?ref=c5961ad06d45689b44ff305c15d6ec7ec65755a9", "patch": "@@ -1,6 +0,0 @@\n-<mime-info xmlns='http://www.freedesktop.org/standards/shared-mime-info'>\n-  <mime-type type=\"text/x-rust\">\n-    <comment>Rust Source</comment>\n-    <glob pattern=\"*.rs\"/>\n-  </mime-type>\n-</mime-info>"}, {"sha": "3ceec0f250a33a3d06b9573baba2fa73aa76c706", "filename": "src/etc/kate/rust.xml", "status": "removed", "additions": 0, "deletions": 304, "changes": 304, "blob_url": "https://github.com/rust-lang/rust/blob/c5961ad06d45689b44ff305c15d6ec7ec65755a9/src%2Fetc%2Fkate%2Frust.xml", "raw_url": "https://github.com/rust-lang/rust/raw/c5961ad06d45689b44ff305c15d6ec7ec65755a9/src%2Fetc%2Fkate%2Frust.xml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fkate%2Frust.xml?ref=c5961ad06d45689b44ff305c15d6ec7ec65755a9", "patch": "@@ -1,304 +0,0 @@\n-<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n-<!DOCTYPE language SYSTEM \"language.dtd\"\n-[\n-\t<!-- FIXME: Kate's regex engine has very limited support for\n-\tpredefined char classes, so making rustIdent consistent with actual\n-\tRust identifiers will be a bit difficult -->\n-\t<!ENTITY rustIdent \"[a-zA-Z_][a-zA-Z_0-9]*\">\n-\t<!ENTITY rustIntSuf \"([iu](8|16|32|64)?)?\">\n-]>\n-<language name=\"Rust\" version=\"1.0.0\" kateversion=\"2.4\" section=\"Sources\" extensions=\"*.rs\" mimetype=\"text/x-rust\" priority=\"15\">\n-<highlighting>\n-\t<list name=\"fn\">\n-\t\t<item> fn </item>\n-\t</list>\n-\t<list name=\"type\">\n-\t\t<item> type </item>\n-\t</list>\n-\t<list name=\"reserved\">\n-\t\t<item> abstract </item>\n-\t\t<item> alignof </item>\n-\t\t<item> be </item>\n-\t\t<item> do </item>\n-\t\t<item> final </item>\n-\t\t<item> offsetof </item>\n-\t\t<item> override </item>\n-\t\t<item> priv </item>\n-\t\t<item> pure </item>\n-\t\t<item> sizeof </item>\n-\t\t<item> typeof </item>\n-\t\t<item> unsized </item>\n-\t\t<item> yield </item>\n-\t</list>\n-\t<list name=\"keywords\">\n-\t\t<item> as </item>\n-\t\t<item> box </item>\n-\t\t<item> break </item>\n-\t\t<item> const </item>\n-\t\t<item> continue </item>\n-\t\t<item> crate </item>\n-\t\t<item> else </item>\n-\t\t<item> enum </item>\n-\t\t<item> extern </item>\n-\t\t<item> for </item>\n-\t\t<item> if </item>\n-\t\t<item> impl </item>\n-\t\t<item> in </item>\n-\t\t<item> let </item>\n-\t\t<item> loop </item>\n-\t\t<item> match </item>\n-\t\t<item> mod </item>\n-\t\t<item> move </item>\n-\t\t<item> mut </item>\n-\t\t<item> pub </item>\n-\t\t<item> ref </item>\n-\t\t<item> return </item>\n-\t\t<item> static </item>\n-\t\t<item> struct </item>\n-\t\t<item> super </item>\n-\t\t<item> trait </item>\n-\t\t<item> unsafe </item>\n-\t\t<item> use </item>\n-\t\t<item> virtual </item>\n-\t\t<item> where </item>\n-\t\t<item> while </item>\n-\t</list>\n-\t<list name=\"traits\">\n-\t\t<item> Const </item>\n-\t\t<item> Copy </item>\n-\t\t<item> Send </item>\n-\t\t<item> Owned </item>\n-\t\t<item> Sized </item>\n-\t\t<item> Eq </item>\n-\t\t<item> Ord </item>\n-\t\t<item> Num </item>\n-\t\t<item> Ptr </item>\n-\t\t<item> Drop </item>\n-\t\t<item> Add </item>\n-\t\t<item> Sub </item>\n-\t\t<item> Mul </item>\n-\t\t<item> Quot </item>\n-\t\t<item> Rem </item>\n-\t\t<item> Neg </item>\n-\t\t<item> BitAnd </item>\n-\t\t<item> BitOr </item>\n-\t\t<item> BitXor </item>\n-\t\t<item> Shl </item>\n-\t\t<item> Shr </item>\n-\t\t<item> Index </item>\n-\t\t<item> Not </item>\n-\t</list>\n-\t<list name=\"types\">\n-\t\t<item> bool </item>\n-\t\t<item> int </item>\n-\t\t<item> isize </item>\n-\t\t<item> uint </item>\n-\t\t<item> usize </item>\n-\t\t<item> i8 </item>\n-\t\t<item> i16 </item>\n-\t\t<item> i32 </item>\n-\t\t<item> i64 </item>\n-\t\t<item> u8 </item>\n-\t\t<item> u16 </item>\n-\t\t<item> u32 </item>\n-\t\t<item> u64 </item>\n-\t\t<item> f32 </item>\n-\t\t<item> f64 </item>\n-\t\t<item> float </item>\n-\t\t<item> char </item>\n-\t\t<item> str </item>\n-\t\t<item> Option </item>\n-\t\t<item> Result </item>\n-\t\t<item> Self </item>\n-\t</list>\n-\t<list name=\"ctypes\">\n-\t\t<item> c_float </item>\n-\t\t<item> c_double </item>\n-\t\t<item> c_void </item>\n-\t\t<item> FILE </item>\n-\t\t<item> fpos_t </item>\n-\t\t<item> DIR </item>\n-\t\t<item> dirent </item>\n-\t\t<item> c_char </item>\n-\t\t<item> c_schar </item>\n-\t\t<item> c_uchar </item>\n-\t\t<item> c_short </item>\n-\t\t<item> c_ushort </item>\n-\t\t<item> c_int </item>\n-\t\t<item> c_uint </item>\n-\t\t<item> c_long </item>\n-\t\t<item> c_ulong </item>\n-\t\t<item> size_t </item>\n-\t\t<item> ptrdiff_t </item>\n-\t\t<item> clock_t </item>\n-\t\t<item> time_t </item>\n-\t\t<item> c_longlong </item>\n-\t\t<item> c_ulonglong </item>\n-\t\t<item> intptr_t </item>\n-\t\t<item> uintptr_t </item>\n-\t\t<item> off_t </item>\n-\t\t<item> dev_t </item>\n-\t\t<item> ino_t </item>\n-\t\t<item> pid_t </item>\n-\t\t<item> mode_t </item>\n-\t\t<item> ssize_t </item>\n-\t</list>\n-\t<list name=\"self\">\n-\t\t<item> self </item>\n-\t</list>\n-\t<list name=\"constants\">\n-\t\t<item> true </item>\n-\t\t<item> false </item>\n-\t\t<item> Some </item>\n-\t\t<item> None </item>\n-\t\t<item> Ok </item>\n-\t\t<item> Err </item>\n-\t\t<item> Success </item>\n-\t\t<item> Failure </item>\n-\t\t<item> Cons </item>\n-\t\t<item> Nil </item>\n-\t</list>\n-\t<list name=\"cconstants\">\n-\t\t<item> EXIT_FAILURE </item>\n-\t\t<item> EXIT_SUCCESS </item>\n-\t\t<item> RAND_MAX </item>\n-\t\t<item> EOF </item>\n-\t\t<item> SEEK_SET </item>\n-\t\t<item> SEEK_CUR </item>\n-\t\t<item> SEEK_END </item>\n-\t\t<item> _IOFBF </item>\n-\t\t<item> _IONBF </item>\n-\t\t<item> _IOLBF </item>\n-\t\t<item> BUFSIZ </item>\n-\t\t<item> FOPEN_MAX </item>\n-\t\t<item> FILENAME_MAX </item>\n-\t\t<item> L_tmpnam </item>\n-\t\t<item> TMP_MAX </item>\n-\t\t<item> O_RDONLY </item>\n-\t\t<item> O_WRONLY </item>\n-\t\t<item> O_RDWR </item>\n-\t\t<item> O_APPEND </item>\n-\t\t<item> O_CREAT </item>\n-\t\t<item> O_EXCL </item>\n-\t\t<item> O_TRUNC </item>\n-\t\t<item> S_IFIFO </item>\n-\t\t<item> S_IFCHR </item>\n-\t\t<item> S_IFBLK </item>\n-\t\t<item> S_IFDIR </item>\n-\t\t<item> S_IFREG </item>\n-\t\t<item> S_IFMT </item>\n-\t\t<item> S_IEXEC </item>\n-\t\t<item> S_IWRITE </item>\n-\t\t<item> S_IREAD </item>\n-\t\t<item> S_IRWXU </item>\n-\t\t<item> S_IXUSR </item>\n-\t\t<item> S_IWUSR </item>\n-\t\t<item> S_IRUSR </item>\n-\t\t<item> F_OK </item>\n-\t\t<item> R_OK </item>\n-\t\t<item> W_OK </item>\n-\t\t<item> X_OK </item>\n-\t\t<item> STDIN_FILENO </item>\n-\t\t<item> STDOUT_FILENO </item>\n-\t\t<item> STDERR_FILENO </item>\n-\t</list>\n-\t<contexts>\n-\t\t<context attribute=\"Normal Text\" lineEndContext=\"#stay\" name=\"Normal\">\n-\t\t\t<DetectSpaces/>\n-\t\t\t<keyword String=\"fn\" attribute=\"Keyword\" context=\"Function\"/>\n-\t\t\t<keyword String=\"type\" attribute=\"Keyword\" context=\"Type\"/>\n-\t\t\t<keyword String=\"reserved\" attribute=\"Keyword\" context=\"#stay\"/>\n-\t\t\t<keyword String=\"keywords\" attribute=\"Keyword\" context=\"#stay\"/>\n-\t\t\t<keyword String=\"types\" attribute=\"Type\" context=\"#stay\"/>\n-\t\t\t<keyword String=\"traits\" attribute=\"Trait\" context=\"#stay\"/>\n-\t\t\t<keyword String=\"ctypes\" attribute=\"CType\" context=\"#stay\"/>\n-\t\t\t<keyword String=\"self\" attribute=\"Self\" context=\"#stay\"/>\n-\t\t\t<keyword String=\"constants\" attribute=\"Constant\" context=\"#stay\"/>\n-\t\t\t<keyword String=\"cconstants\" attribute=\"CConstant\" context=\"#stay\"/>\n-\t\t\t<Detect2Chars char=\"/\" char1=\"/\" attribute=\"Comment\" context=\"Commentar 1\"/>\n-\t\t\t<Detect2Chars char=\"/\" char1=\"*\" attribute=\"Comment\" context=\"Commentar 2\" beginRegion=\"Comment\"/>\n-\t\t\t<RegExpr String=\"0x[0-9a-fA-F_]+&rustIntSuf;\" attribute=\"Number\" context=\"#stay\"/>\n-\t\t\t<RegExpr String=\"0o[0-7_]+&rustIntSuf;\" attribute=\"Number\" context=\"#stay\"/>\n-\t\t\t<RegExpr String=\"0b[0-1_]+&rustIntSuf;\" attribute=\"Number\" context=\"#stay\"/>\n-\t\t\t<RegExpr String=\"[0-9][0-9_]*\\.[0-9_]*([eE][+-]?[0-9_]+)?(f32|f64|f)?\" attribute=\"Number\" context=\"#stay\"/>\n-\t\t\t<RegExpr String=\"[0-9][0-9_]*&rustIntSuf;\" attribute=\"Number\" context=\"#stay\"/>\n-\t\t\t<Detect2Chars char=\"#\" char1=\"[\" attribute=\"Attribute\" context=\"Attribute\" beginRegion=\"Attribute\"/>\n-\t\t\t<StringDetect String=\"#![\" attribute=\"Attribute\" context=\"Attribute\" beginRegion=\"Attribute\"/>\n-\t\t\t<RegExpr String=\"&rustIdent;::\" attribute=\"Scope\"/>\n-\t\t\t<RegExpr String=\"&rustIdent;!\" attribute=\"Macro\"/>\n-\t\t\t<RegExpr String=\"&apos;&rustIdent;(?!&apos;)\" attribute=\"Lifetime\"/>\n-\t\t\t<DetectChar char=\"{\" attribute=\"Symbol\" context=\"#stay\" beginRegion=\"Brace\" />\n-\t\t\t<DetectChar char=\"}\" attribute=\"Symbol\" context=\"#stay\" endRegion=\"Brace\" />\n-\t\t\t<DetectChar char=\"&quot;\" attribute=\"String\" context=\"String\"/>\n-\t\t\t<DetectChar char=\"&apos;\" attribute=\"Character\" context=\"Character\"/>\n-\t\t\t<DetectChar char=\"[\" attribute=\"Symbol\" context=\"#stay\" beginRegion=\"Bracket\" />\n-\t\t\t<DetectChar char=\"]\" attribute=\"Symbol\" context=\"#stay\" endRegion=\"Bracket\" />\n-\t\t\t<DetectIdentifier/>\n-\t\t</context>\n-\t\t<context attribute=\"Attribute\" lineEndContext=\"#stay\" name=\"Attribute\">\n-\t\t\t<DetectChar char=\"]\" attribute=\"Attribute\" context=\"#pop\" endRegion=\"Attribute\"/>\n-\t\t\t<IncludeRules context=\"Normal\"/>\n-\t\t</context>\n-\t\t<context attribute=\"Definition\" lineEndContext=\"#stay\" name=\"Function\">\n-\t\t\t<DetectSpaces/>\n-\t\t\t<DetectChar char=\"(\" attribute=\"Normal Text\" context=\"#pop\"/>\n-\t\t\t<DetectChar char=\"&lt;\" attribute=\"Normal Text\" context=\"#pop\"/>\n-\t\t</context>\n-\t\t<context attribute=\"Definition\" lineEndContext=\"#stay\" name=\"Type\">\n-\t\t\t<DetectSpaces/>\n-\t\t\t<DetectChar char=\"=\" attribute=\"Normal Text\" context=\"#pop\"/>\n-\t\t\t<DetectChar char=\"&lt;\" attribute=\"Normal Text\" context=\"#pop\"/>\n-\t\t</context>\n-\t\t<context attribute=\"String\" lineEndContext=\"#pop\" name=\"String\">\n-\t\t\t<LineContinue attribute=\"String\" context=\"#stay\"/>\n-\t\t\t<DetectChar char=\"\\\" attribute=\"CharEscape\" context=\"CharEscape\"/>\n-\t\t\t<DetectChar attribute=\"String\" context=\"#pop\" char=\"&quot;\"/>\n-\t\t</context>\n-\t\t<context attribute=\"Character\" lineEndContext=\"#pop\" name=\"Character\">\n-\t\t\t<DetectChar char=\"\\\" attribute=\"CharEscape\" context=\"CharEscape\"/>\n-\t\t\t<DetectChar attribute=\"Character\" context=\"#pop\" char=\"&apos;\"/>\n-\t\t</context>\n-\t\t<context attribute=\"CharEscape\" lineEndContext=\"#pop\" name=\"CharEscape\">\n-\t\t\t<AnyChar String=\"nrt\\&apos;&quot;\" attribute=\"CharEscape\" context=\"#pop\"/>\n-\t\t\t<RegExpr String=\"x[0-9a-fA-F]{2}\" attribute=\"CharEscape\" context=\"#pop\"/>\n-\t\t\t<RegExpr String=\"u\\{[0-9a-fA-F]{1,6}\\}\" attribute=\"CharEscape\" context=\"#pop\"/>\n-\t\t\t<RegExpr String=\"u[0-9a-fA-F]{4}\" attribute=\"CharEscape\" context=\"#pop\"/>\n-\t\t\t<RegExpr String=\"U[0-9a-fA-F]{8}\" attribute=\"CharEscape\" context=\"#pop\"/>\n-\t\t\t<RegExpr String=\".\" attribute=\"Error\" context=\"#pop\"/>\n-\t\t</context>\n-\t\t<context attribute=\"Comment\" lineEndContext=\"#pop\" name=\"Commentar 1\"/>\n-\t\t<context attribute=\"Comment\" lineEndContext=\"#stay\" name=\"Commentar 2\">\n-\t\t\t<DetectSpaces/>\n-\t\t\t<Detect2Chars char=\"*\" char1=\"/\" attribute=\"Comment\" context=\"#pop\" endRegion=\"Comment\"/>\n-\t\t</context>\n-\t</contexts>\n-\t<itemDatas>\n-\t\t<itemData name=\"Normal Text\"  defStyleNum=\"dsNormal\"/>\n-\t\t<itemData name=\"Keyword\"      defStyleNum=\"dsKeyword\" color=\"#770088\" bold=\"1\"/>\n-\t\t<itemData name=\"Self\"         defStyleNum=\"dsKeyword\" color=\"#FF0000\" bold=\"1\"/>\n-\t\t<itemData name=\"Type\"         defStyleNum=\"dsKeyword\" color=\"#4e9a06\" bold=\"1\"/>\n-\t\t<itemData name=\"Trait\"        defStyleNum=\"dsKeyword\" color=\"#4e9a06\" bold=\"1\"/>\n-\t\t<itemData name=\"CType\"        defStyleNum=\"dsNormal\" color=\"#4e9a06\"/>\n-\t\t<itemData name=\"Constant\"     defStyleNum=\"dsKeyword\" color=\"#116644\"/>\n-\t\t<itemData name=\"CConstant\"    defStyleNum=\"dsNormal\" color=\"#116644\"/>\n-\t\t<itemData name=\"Definition\"   defStyleNum=\"dsNormal\" color=\"#0000FF\"/>\n-\t\t<itemData name=\"Comment\"      defStyleNum=\"dsComment\" color=\"#AA5500\"/>\n-\t\t<itemData name=\"Scope\"        defStyleNum=\"dsNormal\" color=\"#0055AA\"/>\n-\t\t<itemData name=\"Number\"       defStyleNum=\"dsDecVal\" color=\"#116644\"/>\n-\t\t<itemData name=\"String\"       defStyleNum=\"dsString\" color=\"#FF0000\"/>\n-\t\t<itemData name=\"CharEscape\"   defStyleNum=\"dsChar\" color=\"#FF0000\" bold=\"1\"/>\n-\t\t<itemData name=\"Character\"    defStyleNum=\"dsChar\" color=\"#FF0000\"/>\n-\t\t<itemData name=\"Macro\"        defStyleNum=\"dsOthers\"/>\n-\t\t<itemData name=\"Attribute\"    defStyleNum=\"dsOthers\"/>\n-\t\t<itemData name=\"Lifetime\"     defStyleNum=\"dsOthers\" bold=\"1\"/>\n-\t\t<itemData name=\"Error\"        defStyleNum=\"dsError\"/>\n-\t</itemDatas>\n-</highlighting>\n-<general>\n-\t<comments>\n-\t\t<comment name=\"singleLine\" start=\"//\" />\n-\t\t<comment name=\"multiLine\" start=\"/*\" end=\"*/\" region=\"Comment\"/>\n-\t</comments>\n-\t<keywords casesensitive=\"1\" />\n-</general>\n-</language>"}, {"sha": "1217769096df0be2e12aca1937f8a899501c687e", "filename": "src/etc/nano/rust.nanorc", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/c5961ad06d45689b44ff305c15d6ec7ec65755a9/src%2Fetc%2Fnano%2Frust.nanorc", "raw_url": "https://github.com/rust-lang/rust/raw/c5961ad06d45689b44ff305c15d6ec7ec65755a9/src%2Fetc%2Fnano%2Frust.nanorc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fnano%2Frust.nanorc?ref=c5961ad06d45689b44ff305c15d6ec7ec65755a9", "patch": "@@ -1,35 +0,0 @@\n-# Nano configuration for Rust\n-# Copyright 2015 The Rust Project Developers.\n-#\n-# NOTE: Rules are applied in order: later rules re-colorize matching text.\n-syntax \"rust\" \"\\.rs\"\n-\n-# function definition\n-color magenta \"fn [a-z0-9_]+\"\n-\n-# Reserved words\n-color yellow \"\\<(abstract|alignof|as|be|box|break|const|continue|crate|do|else|enum|extern|false|final|fn|for|if|impl|in|let|loop|macro|match|mod|move|mut|offsetof|override|priv|pub|pure|ref|return|sizeof|static|self|struct|super|true|trait|type|typeof|unsafe|unsized|use|virtual|where|while|yield)\\>\"\n-\n-# macros\n-color red \"[a-z_]+!\"\n-\n-# Constants\n-color magenta \"[A-Z][A-Z_]+\"\n-\n-# Traits/Enums/Structs/Types/etc.\n-color magenta \"[A-Z][a-z]+\"\n-\n-# Strings\n-color green \"\\\".*\\\"\"\n-color green start=\"\\\".*\\\\$\" end=\".*\\\"\"\n-# NOTE: This isn't accurate but matching \"#{0,} for the end of the string is too liberal\n-color green start=\"r#+\\\"\" end=\"\\\"#+\"\n-\n-# Comments\n-color blue \"//.*\"\n-\n-# Attributes\n-color magenta start=\"#!\\[\" end=\"\\]\"\n-\n-# Some common markers\n-color brightcyan \"(XXX|TODO|FIXME|\\?\\?\\?)\""}, {"sha": "735c1e153a60dc070662d424cfcf1eef2714f6d4", "filename": "src/etc/vim/after/syntax/rust.vim", "status": "removed", "additions": 0, "deletions": 31, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/c5961ad06d45689b44ff305c15d6ec7ec65755a9/src%2Fetc%2Fvim%2Fafter%2Fsyntax%2Frust.vim", "raw_url": "https://github.com/rust-lang/rust/raw/c5961ad06d45689b44ff305c15d6ec7ec65755a9/src%2Fetc%2Fvim%2Fafter%2Fsyntax%2Frust.vim", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fvim%2Fafter%2Fsyntax%2Frust.vim?ref=c5961ad06d45689b44ff305c15d6ec7ec65755a9", "patch": "@@ -1,31 +0,0 @@\n-if !exists('g:rust_conceal') || !has('conceal') || &enc != 'utf-8'\n-\tfinish\n-endif\n-\n-\" For those who don't want to see `::`...\n-if exists('g:rust_conceal_mod_path')\n-\tsyn match rustNiceOperator \"::\" conceal cchar=\u318d\n-endif\n-\n-syn match rustRightArrowHead contained \">\" conceal cchar=\u2000\n-syn match rustRightArrowTail contained \"-\" conceal cchar=\u27f6\n-syn match rustNiceOperator \"->\" contains=rustRightArrowHead,rustRightArrowTail\n-\n-syn match rustFatRightArrowHead contained \">\" conceal cchar=\u2000\n-syn match rustFatRightArrowTail contained \"=\" conceal cchar=\u27f9\n-syn match rustNiceOperator \"=>\" contains=rustFatRightArrowHead,rustFatRightArrowTail\n-\n-syn match rustNiceOperator /\\<\\@!_\\(_*\\>\\)\\@=/ conceal cchar=\u2032\n-\n-\" For those who don't want to see `pub`...\n-if exists('g:rust_conceal_pub')\n-    syn match rustPublicSigil contained \"pu\" conceal cchar=\uff0a\n-    syn match rustPublicRest contained \"b\" conceal cchar=\u2000\n-    syn match rustNiceOperator \"pub \" contains=rustPublicSigil,rustPublicRest\n-endif\n-\n-hi link rustNiceOperator Operator\n-\n-if !exists('g:rust_conceal_mod_path')\n-    hi! link Conceal Operator\n-endif"}, {"sha": "fe8e743e7826dae0055ed476667fd304a9588b73", "filename": "src/etc/vim/autoload/rust.vim", "status": "removed", "additions": 0, "deletions": 225, "changes": 225, "blob_url": "https://github.com/rust-lang/rust/blob/c5961ad06d45689b44ff305c15d6ec7ec65755a9/src%2Fetc%2Fvim%2Fautoload%2Frust.vim", "raw_url": "https://github.com/rust-lang/rust/raw/c5961ad06d45689b44ff305c15d6ec7ec65755a9/src%2Fetc%2Fvim%2Fautoload%2Frust.vim", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fvim%2Fautoload%2Frust.vim?ref=c5961ad06d45689b44ff305c15d6ec7ec65755a9", "patch": "@@ -1,225 +0,0 @@\n-\" Author: Kevin Ballard\n-\" Description: Helper functions for Rust commands/mappings\n-\" Last Modified: May 27, 2014\n-\n-\" Jump {{{1\n-\n-function! rust#Jump(mode, function) range\n-\tlet cnt = v:count1\n-\tnormal! m'\n-\tif a:mode ==# 'v'\n-\t\tnorm! gv\n-\tendif\n-\tlet foldenable = &foldenable\n-\tset nofoldenable\n-\twhile cnt > 0\n-\t\texecute \"call <SID>Jump_\" . a:function . \"()\"\n-\t\tlet cnt = cnt - 1\n-\tendwhile\n-\tlet &foldenable = foldenable\n-endfunction\n-\n-function! s:Jump_Back()\n-\tcall search('{', 'b')\n-\tkeepjumps normal! w99[{\n-endfunction\n-\n-function! s:Jump_Forward()\n-\tnormal! j0\n-\tcall search('{', 'b')\n-\tkeepjumps normal! w99[{%\n-\tcall search('{')\n-endfunction\n-\n-\" Run {{{1\n-\n-function! rust#Run(bang, args)\n-\tif a:bang\n-\t\tlet idx = index(a:args, '--')\n-\t\tif idx != -1\n-\t\t\tlet rustc_args = idx == 0 ? [] : a:args[:idx-1]\n-\t\t\tlet args = a:args[idx+1:]\n-\t\telse\n-\t\t\tlet rustc_args = a:args\n-\t\t\tlet args = []\n-\t\tendif\n-\telse\n-\t\tlet rustc_args = []\n-\t\tlet args = a:args\n-\tendif\n-\n-\tlet b:rust_last_rustc_args = rustc_args\n-\tlet b:rust_last_args = args\n-\n-\tcall s:WithPath(function(\"s:Run\"), rustc_args, args)\n-endfunction\n-\n-function! s:Run(path, rustc_args, args)\n-\ttry\n-\t\tlet exepath = tempname()\n-\t\tif has('win32')\n-\t\t\tlet exepath .= '.exe'\n-\t\tendif\n-\n-\t\tlet rustc_args = [a:path, '-o', exepath] + a:rustc_args\n-\n-\t\tlet rustc = exists(\"g:rustc_path\") ? g:rustc_path : \"rustc\"\n-\n-\t\tlet output = system(shellescape(rustc) . \" \" . join(map(rustc_args, 'shellescape(v:val)')))\n-\t\tif output != ''\n-\t\t\techohl WarningMsg\n-\t\t\techo output\n-\t\t\techohl None\n-\t\tendif\n-\t\tif !v:shell_error\n-\t\t\texe '!' . shellescape(exepath) . \" \" . join(map(a:args, 'shellescape(v:val)'))\n-\t\tendif\n-\tfinally\n-\t\tif exists(\"exepath\")\n-\t\t\tsilent! call delete(exepath)\n-\t\tendif\n-\tendtry\n-endfunction\n-\n-\" Expand {{{1\n-\n-function! rust#Expand(bang, args)\n-\tif a:bang && !empty(a:args)\n-\t\tlet pretty = a:args[0]\n-\t\tlet args = a:args[1:]\n-\telse\n-\t\tlet pretty = \"expanded\"\n-\t\tlet args = a:args\n-\tendif\n-\tcall s:WithPath(function(\"s:Expand\"), pretty, args)\n-endfunction\n-\n-function! s:Expand(path, pretty, args)\n-\ttry\n-\t\tlet rustc = exists(\"g:rustc_path\") ? g:rustc_path : \"rustc\"\n-\n-\t\tlet args = [a:path, '--pretty', a:pretty] + a:args\n-\t\tlet output = system(shellescape(rustc) . \" \" . join(map(args, \"shellescape(v:val)\")))\n-\t\tif v:shell_error\n-\t\t\techohl WarningMsg\n-\t\t\techo output\n-\t\t\techohl None\n-\t\telse\n-\t\t\tnew\n-\t\t\tsilent put =output\n-\t\t\t1\n-\t\t\td\n-\t\t\tsetl filetype=rust\n-\t\t\tsetl buftype=nofile\n-\t\t\tsetl bufhidden=hide\n-\t\t\tsetl noswapfile\n-\t\tendif\n-\tendtry\n-endfunction\n-\n-function! rust#CompleteExpand(lead, line, pos)\n-\tif a:line[: a:pos-1] =~ '^RustExpand!\\s*\\S*$'\n-\t\t\" first argument and it has a !\n-\t\tlet list = [\"normal\", \"expanded\", \"typed\", \"expanded,identified\", \"flowgraph=\"]\n-\t\tif !empty(a:lead)\n-\t\t\tcall filter(list, \"v:val[:len(a:lead)-1] == a:lead\")\n-\t\tendif\n-\t\treturn list\n-\tendif\n-\n-\treturn glob(escape(a:lead, \"*?[\") . '*', 0, 1)\n-endfunction\n-\n-\" Emit {{{1\n-\n-function! rust#Emit(type, args)\n-\tcall s:WithPath(function(\"s:Emit\"), a:type, a:args)\n-endfunction\n-\n-function! s:Emit(path, type, args)\n-\ttry\n-\t\tlet rustc = exists(\"g:rustc_path\") ? g:rustc_path : \"rustc\"\n-\n-\t\tlet args = [a:path, '--emit', a:type, '-o', '-'] + a:args\n-\t\tlet output = system(shellescape(rustc) . \" \" . join(map(args, \"shellescape(v:val)\")))\n-\t\tif v:shell_error\n-\t\t\techohl WarningMsg\n-\t\t\techo output\n-\t\t\techohl None\n-\t\telse\n-\t\t\tnew\n-\t\t\tsilent put =output\n-\t\t\t1\n-\t\t\td\n-\t\t\tif a:type == \"ir\"\n-\t\t\t\tsetl filetype=llvm\n-\t\t\telseif a:type == \"asm\"\n-\t\t\t\tsetl filetype=asm\n-\t\t\tendif\n-\t\t\tsetl buftype=nofile\n-\t\t\tsetl bufhidden=hide\n-\t\t\tsetl noswapfile\n-\t\tendif\n-\tendtry\n-endfunction\n-\n-\" Utility functions {{{1\n-\n-function! s:WithPath(func, ...)\n-\ttry\n-\t\tlet save_write = &write\n-\t\tset write\n-\t\tlet path = expand('%')\n-\t\tlet pathisempty = empty(path)\n-\t\tif pathisempty || !save_write\n-\t\t\t\" use a temporary file named 'unnamed.rs' inside a temporary\n-\t\t\t\" directory. This produces better error messages\n-\t\t\tlet tmpdir = tempname()\n-\t\t\tcall mkdir(tmpdir)\n-\n-\t\t\tlet save_cwd = getcwd()\n-\t\t\tsilent exe 'lcd' fnameescape(tmpdir)\n-\n-\t\t\tlet path = 'unnamed.rs'\n-\n-\t\t\tlet save_mod = &mod\n-\t\t\tset nomod\n-\n-\t\t\tsilent exe 'keepalt write! ' . fnameescape(path)\n-\t\t\tif pathisempty\n-\t\t\t\tsilent keepalt 0file\n-\t\t\tendif\n-\t\telse\n-\t\t\tupdate\n-\t\tendif\n-\n-\t\tcall call(a:func, [path] + a:000)\n-\tfinally\n-\t\tif exists(\"save_mod\")   | let &mod = save_mod                    | endif\n-\t\tif exists(\"save_write\") | let &write = save_write                | endif\n-\t\tif exists(\"save_cwd\")   | silent exe 'lcd' fnameescape(save_cwd) | endif\n-\t\tif exists(\"tmpdir\")     | silent call s:RmDir(tmpdir)            | endif\n-\tendtry\n-endfunction\n-\n-function! rust#AppendCmdLine(text)\n-\tcall setcmdpos(getcmdpos())\n-\tlet cmd = getcmdline() . a:text\n-\treturn cmd\n-endfunction\n-\n-function! s:RmDir(path)\n-\t\" sanity check; make sure it's not empty, /, or $HOME\n-\tif empty(a:path)\n-\t\techoerr 'Attempted to delete empty path'\n-\t\treturn 0\n-\telseif a:path == '/' || a:path == $HOME\n-\t\techoerr 'Attempted to delete protected path: ' . a:path\n-\t\treturn 0\n-\tendif\n-\tsilent exe \"!rm -rf \" . shellescape(a:path)\n-endfunction\n-\n-\" }}}1\n-\n-\" vim: set noet sw=4 ts=4:"}, {"sha": "ed487a308e199d6a3d19fdfe8f16b0c1d3ebe6cf", "filename": "src/etc/vim/compiler/cargo.vim", "status": "removed", "additions": 0, "deletions": 65, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/c5961ad06d45689b44ff305c15d6ec7ec65755a9/src%2Fetc%2Fvim%2Fcompiler%2Fcargo.vim", "raw_url": "https://github.com/rust-lang/rust/raw/c5961ad06d45689b44ff305c15d6ec7ec65755a9/src%2Fetc%2Fvim%2Fcompiler%2Fcargo.vim", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fvim%2Fcompiler%2Fcargo.vim?ref=c5961ad06d45689b44ff305c15d6ec7ec65755a9", "patch": "@@ -1,65 +0,0 @@\n-\" Vim compiler file\n-\" Compiler:         Cargo Compiler\n-\" Maintainer:       Damien Radtke <damienradtke@gmail.com>\n-\" Latest Revision:  2014 Sep 24\n-\n-if exists('current_compiler')\n-  finish\n-endif\n-runtime compiler/rustc.vim\n-let current_compiler = \"cargo\"\n-\n-if exists(':CompilerSet') != 2\n-    command -nargs=* CompilerSet setlocal <args>\n-endif\n-\n-if exists('g:cargo_makeprg_params')\n-    execute 'CompilerSet makeprg=cargo\\ '.escape(g:cargo_makeprg_params, ' \\|\"').'\\ $*'\n-else\n-    CompilerSet makeprg=cargo\\ $*\n-endif\n-\n-\" Allow a configurable global Cargo.toml name. This makes it easy to\n-\" support variations like 'cargo.toml'.\n-let s:cargo_manifest_name = get(g:, 'cargo_manifest_name', 'Cargo.toml')\n-\n-function! s:is_absolute(path)\n-    return a:path[0] == '/' || a:path =~ '[A-Z]\\+:'\n-endfunction\n-\n-let s:local_manifest = findfile(s:cargo_manifest_name, '.;')\n-if s:local_manifest != ''\n-    let s:local_manifest = fnamemodify(s:local_manifest, ':p:h').'/'\n-    augroup cargo\n-        au!\n-        au QuickfixCmdPost make call s:FixPaths()\n-    augroup END\n-\n-    \" FixPaths() is run after Cargo, and is used to change the file paths\n-    \" to be relative to the current directory instead of Cargo.toml.\n-    function! s:FixPaths()\n-        let qflist = getqflist()\n-        let manifest = s:local_manifest\n-        for qf in qflist\n-            if !qf.valid\n-                let m = matchlist(qf.text, '(file://\\(.*\\))$')\n-                if !empty(m)\n-                    let manifest = m[1].'/'\n-                    \" Manually strip another slash if needed; usually just an\n-                    \" issue on Windows.\n-                    if manifest =~ '^/[A-Z]\\+:/'\n-                        let manifest = manifest[1:]\n-                    endif\n-                endif\n-                continue\n-            endif\n-            let filename = bufname(qf.bufnr)\n-            if s:is_absolute(filename)\n-                continue\n-            endif\n-            let qf.filename = simplify(manifest.filename)\n-            call remove(qf, 'bufnr')\n-        endfor\n-        call setqflist(qflist, 'r')\n-    endfunction\n-endif"}, {"sha": "f9b854ed0491398b2364912a2f3c4598f5ad8e34", "filename": "src/etc/vim/compiler/rustc.vim", "status": "removed", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/c5961ad06d45689b44ff305c15d6ec7ec65755a9/src%2Fetc%2Fvim%2Fcompiler%2Frustc.vim", "raw_url": "https://github.com/rust-lang/rust/raw/c5961ad06d45689b44ff305c15d6ec7ec65755a9/src%2Fetc%2Fvim%2Fcompiler%2Frustc.vim", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fvim%2Fcompiler%2Frustc.vim?ref=c5961ad06d45689b44ff305c15d6ec7ec65755a9", "patch": "@@ -1,33 +0,0 @@\n-\" Vim compiler file\n-\" Compiler:         Rust Compiler\n-\" Maintainer:       Chris Morgan <me@chrismorgan.info>\n-\" Latest Revision:  2013 Jul 12\n-\n-if exists(\"current_compiler\")\n-  finish\n-endif\n-let current_compiler = \"rustc\"\n-\n-let s:cpo_save = &cpo\n-set cpo&vim\n-\n-if exists(\":CompilerSet\") != 2\n-\tcommand -nargs=* CompilerSet setlocal <args>\n-endif\n-\n-if exists(\"g:rustc_makeprg_no_percent\") && g:rustc_makeprg_no_percent == 1\n-\tCompilerSet makeprg=rustc\n-else\n-\tCompilerSet makeprg=rustc\\ \\%\n-endif\n-\n-CompilerSet errorformat=\n-\t\t\t\\%f:%l:%c:\\ %t%*[^:]:\\ %m,\n-\t\t\t\\%f:%l:%c:\\ %*\\\\d:%*\\\\d\\ %t%*[^:]:\\ %m,\n-\t\t\t\\%-G%f:%l\\ %s,\n-\t\t\t\\%-G%*[\\ ]^,\n-\t\t\t\\%-G%*[\\ ]^%*[~],\n-\t\t\t\\%-G%*[\\ ]...\n-\n-let &cpo = s:cpo_save\n-unlet s:cpo_save"}, {"sha": "e117b0c155b762d979ae96324ee1991b338737ef", "filename": "src/etc/vim/doc/rust.txt", "status": "removed", "additions": 0, "deletions": 178, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/c5961ad06d45689b44ff305c15d6ec7ec65755a9/src%2Fetc%2Fvim%2Fdoc%2Frust.txt", "raw_url": "https://github.com/rust-lang/rust/raw/c5961ad06d45689b44ff305c15d6ec7ec65755a9/src%2Fetc%2Fvim%2Fdoc%2Frust.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fvim%2Fdoc%2Frust.txt?ref=c5961ad06d45689b44ff305c15d6ec7ec65755a9", "patch": "@@ -1,178 +0,0 @@\n-*rust.txt*      Filetype plugin for Rust\n-\n-==============================================================================\n-CONTENTS                                                      *rust* *ft-rust*\n-\n-1. Introduction                                                   |rust-intro|\n-2. Settings                                                    |rust-settings|\n-3. Commands                                                    |rust-commands|\n-4. Mappings                                                    |rust-mappings|\n-\n-==============================================================================\n-INTRODUCTION                                                      *rust-intro*\n-\n-This plugin provides syntax and supporting functionality for the Rust\n-filetype.\n-\n-==============================================================================\n-SETTINGS                                                       *rust-settings*\n-\n-This plugin has a few variables you can define in your vimrc that change the\n-behavior of the plugin.\n-\n-                                                                *g:rustc_path*\n-g:rustc_path~\n-\tSet this option to the path to rustc for use in the |:RustRun| and\n-\t|:RustExpand| commands. If unset, \"rustc\" will be located in $PATH: >\n-\t    let g:rustc_path = $HOME.\"/bin/rustc\"\n-<\n-\n-                                                  *g:rustc_makeprg_no_percent*\n-g:rustc_makeprg_no_percent~\n-\tSet this option to 1 to have 'makeprg' default to \"rustc\" instead of\n-\t\"rustc %\": >\n-\t    let g:rustc_makeprg_no_percent = 1\n-<\n-\n-                                                              *g:rust_conceal*\n-g:rust_conceal~\n-\tSet this option to turn on the basic |conceal| support: >\n-\t    let g:rust_conceal = 1\n-<\n-\n-                                                     *g:rust_conceal_mod_path*\n-g:rust_conceal_mod_path~\n-\tSet this option to turn on |conceal| for the path connecting token\n-\t\"::\": >\n-\t    let g:rust_conceal_mod_path = 1\n-<\n-\n-                                                          *g:rust_conceal_pub*\n-g:rust_conceal_pub~\n-\tSet this option to turn on |conceal| for the \"pub\" token: >\n-\t    let g:rust_conceal_pub = 1\n-<\n-\n-                                                     *g:rust_recommended_style*\n-g:rust_recommended_style~\n-        Set this option to enable vim indentation and textwidth settings to\n-        conform to style conventions of the rust standard library (i.e. use 4\n-        spaces for indents and sets 'textwidth' to 99). This option is enabled\n-\tby default. To disable it: >\n-\t    let g:rust_recommended_style = 0\n-<\n-\n-                                                                 *g:rust_fold*\n-g:rust_fold~\n-\tSet this option to turn on |folding|: >\n-\t    let g:rust_fold = 1\n-<\n-\tValue\t\tEffect ~\n-\t0\t\tNo folding\n-\t1\t\tBraced blocks are folded. All folds are open by\n-\t\t\tdefault.\n-\t2\t\tBraced blocks are folded. 'foldlevel' is left at the\n-\t\t\tglobal value (all folds are closed by default).\n-\n-                                                  *g:rust_bang_comment_leader*\n-g:rust_bang_comment_leader~\n-\tSet this option to 1 to preserve the leader on multi-line doc comments\n-\tusing the /*! syntax: >\n-\t    let g:rust_bang_comment_leader = 1\n-<\n-\n-                                                 *g:ftplugin_rust_source_path*\n-g:ftplugin_rust_source_path~\n-\tSet this option to a path that should be prepended to 'path' for Rust\n-\tsource files: >\n-\t    let g:ftplugin_rust_source_path = $HOME.'/dev/rust'\n-<\n-\n-                                                       *g:cargo_manifest_name*\n-g:cargo_manifest_name~\n-\tSet this option to the name of the manifest file for your projects. If\n-\tnot specified it defaults to 'Cargo.toml' : >\n-\t    let g:cargo_manifest_name = 'Cargo.toml'\n-<\n-\n-==============================================================================\n-COMMANDS                                                       *rust-commands*\n-\n-:RustRun  [args]                                                    *:RustRun*\n-:RustRun! [rustc-args] [--] [args]\n-\t\tCompiles and runs the current file. If it has unsaved changes,\n-\t\tit will be saved first using |:update|. If the current file is\n-\t\tan unnamed buffer, it will be written to a temporary file\n-\t\tfirst. The compiled binary is always placed in a temporary\n-\t\tdirectory, but is run from the current directory.\n-\n-\t\tThe arguments given to |:RustRun| will be passed to the\n-\t\tcompiled binary.\n-\n-\t\tIf ! is specified, the arguments are passed to rustc instead.\n-\t\tA \"--\" argument will separate the rustc arguments from the\n-\t\targuments passed to the binary.\n-\n-\t\tIf |g:rustc_path| is defined, it is used as the path to rustc.\n-\t\tOtherwise it is assumed rustc can be found in $PATH.\n-\n-:RustExpand  [args]                                              *:RustExpand*\n-:RustExpand! [TYPE] [args]\n-\t\tExpands the current file using --pretty and displays the\n-\t\tresults in a new split. If the current file has unsaved\n-\t\tchanges, it will be saved first using |:update|. If the\n-\t\tcurrent file is an unnamed buffer, it will be written to a\n-\t\ttemporary file first.\n-\n-\t\tThe arguments given to |:RustExpand| will be passed to rustc.\n-\t\tThis is largely intended for specifying various --cfg\n-\t\tconfigurations.\n-\n-\t\tIf ! is specified, the first argument is the expansion type to\n-\t\tpass to rustc --pretty. Otherwise it will default to\n-\t\t\"expanded\".\n-\n-\t\tIf |g:rustc_path| is defined, it is used as the path to rustc.\n-\t\tOtherwise it is assumed rustc can be found in $PATH.\n-\n-:RustEmitIr [args]                                               *:RustEmitIr*\n-\t\tCompiles the current file to LLVM IR and displays the results\n-\t\tin a new split. If the current file has unsaved changes, it\n-\t\twill be saved first using |:update|. If the current file is an\n-\t\tunnamed buffer, it will be written to a temporary file first.\n-\n-\t\tThe arguments given to |:RustEmitIr| will be passed to rustc.\n-\n-\t\tIf |g:rustc_path| is defined, it is used as the path to rustc.\n-\t\tOtherwise it is assumed rustc can be found in $PATH.\n-\n-:RustEmitAsm [args]                                             *:RustEmitAsm*\n-\t\tCompiles the current file to assembly and displays the results\n-\t\tin a new split. If the current file has unsaved changes, it\n-\t\twill be saved first using |:update|. If the current file is an\n-\t\tunnamed buffer, it will be written to a temporary file first.\n-\n-\t\tThe arguments given to |:RustEmitAsm| will be passed to rustc.\n-\n-\t\tIf |g:rustc_path| is defined, it is used as the path to rustc.\n-\t\tOtherwise it is assumed rustc can be found in $PATH.\n-\n-==============================================================================\n-MAPPINGS                                                       *rust-mappings*\n-\n-This plugin defines mappings for |[[| and |]]| to support hanging indents.\n-\n-It also has a few other mappings:\n-\n-\t\t\t\t\t\t\t*rust_<D-r>*\n-<D-r>\t\t\tExecutes |:RustRun| with no arguments.\n-\t\t\tNote: This binding is only available in MacVim.\n-\n-\t\t\t\t\t\t\t*rust_<D-R>*\n-<D-R>\t\t\tPopulates the command line with |:RustRun|! using the\n-\t\t\targuments given to the last invocation, but does not\n-\t\t\texecute it.\n-\t\t\tNote: This binding is only available in MacVim.\n-\n-==============================================================================\n- vim:tw=78:sw=4:noet:ts=8:ft=help:norl:"}, {"sha": "bf685d43243cc4553155ac50d32f0b8c9243e0cc", "filename": "src/etc/vim/ftdetect/rust.vim", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c5961ad06d45689b44ff305c15d6ec7ec65755a9/src%2Fetc%2Fvim%2Fftdetect%2Frust.vim", "raw_url": "https://github.com/rust-lang/rust/raw/c5961ad06d45689b44ff305c15d6ec7ec65755a9/src%2Fetc%2Fvim%2Fftdetect%2Frust.vim", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fvim%2Fftdetect%2Frust.vim?ref=c5961ad06d45689b44ff305c15d6ec7ec65755a9", "patch": "@@ -1 +0,0 @@\n-au BufRead,BufNewFile *.rs set filetype=rust"}, {"sha": "5d5569945f581bc435c4e0971ab0e2fcb12e0c6e", "filename": "src/etc/vim/ftplugin/rust.vim", "status": "removed", "additions": 0, "deletions": 150, "changes": 150, "blob_url": "https://github.com/rust-lang/rust/blob/c5961ad06d45689b44ff305c15d6ec7ec65755a9/src%2Fetc%2Fvim%2Fftplugin%2Frust.vim", "raw_url": "https://github.com/rust-lang/rust/raw/c5961ad06d45689b44ff305c15d6ec7ec65755a9/src%2Fetc%2Fvim%2Fftplugin%2Frust.vim", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fvim%2Fftplugin%2Frust.vim?ref=c5961ad06d45689b44ff305c15d6ec7ec65755a9", "patch": "@@ -1,150 +0,0 @@\n-\" Language:     Rust\n-\" Description:  Vim syntax file for Rust\n-\" Maintainer:   Chris Morgan <me@chrismorgan.info>\n-\" Maintainer:   Kevin Ballard <kevin@sb.org>\n-\" Last Change:  Jul 07, 2014\n-\n-if exists(\"b:did_ftplugin\")\n-\tfinish\n-endif\n-let b:did_ftplugin = 1\n-\n-let s:save_cpo = &cpo\n-set cpo&vim\n-\n-\" Variables {{{1\n-\n-\" The rust source code at present seems to typically omit a leader on /*!\n-\" comments, so we'll use that as our default, but make it easy to switch.\n-\" This does not affect indentation at all (I tested it with and without\n-\" leader), merely whether a leader is inserted by default or not.\n-if exists(\"g:rust_bang_comment_leader\") && g:rust_bang_comment_leader == 1\n-\t\" Why is the `,s0:/*,mb:\\ ,ex:*/` there, you ask? I don't understand why,\n-\t\" but without it, */ gets indented one space even if there were no\n-\t\" leaders. I'm fairly sure that's a Vim bug.\n-\tsetlocal comments=s1:/*,mb:*,ex:*/,s0:/*,mb:\\ ,ex:*/,:///,://!,://\n-else\n-\tsetlocal comments=s0:/*!,m:\\ ,ex:*/,s1:/*,mb:*,ex:*/,:///,://!,://\n-endif\n-setlocal commentstring=//%s\n-setlocal formatoptions-=t formatoptions+=croqnl\n-\" j was only added in 7.3.541, so stop complaints about its nonexistence\n-silent! setlocal formatoptions+=j\n-\n-\" smartindent will be overridden by indentexpr if filetype indent is on, but\n-\" otherwise it's better than nothing.\n-setlocal smartindent nocindent\n-\n-if !exists(\"g:rust_recommended_style\") || g:rust_recommended_style == 1\n-\tsetlocal tabstop=4 shiftwidth=4 softtabstop=4 expandtab\n-\tsetlocal textwidth=99\n-endif\n-\n-\" This includeexpr isn't perfect, but it's a good start\n-setlocal includeexpr=substitute(v:fname,'::','/','g')\n-\n-\" NOT adding .rc as it's being phased out (0.7)\n-setlocal suffixesadd=.rs\n-\n-if exists(\"g:ftplugin_rust_source_path\")\n-    let &l:path=g:ftplugin_rust_source_path . ',' . &l:path\n-endif\n-\n-if exists(\"g:loaded_delimitMate\")\n-\tif exists(\"b:delimitMate_excluded_regions\")\n-\t\tlet b:rust_original_delimitMate_excluded_regions = b:delimitMate_excluded_regions\n-\tendif\n-\tlet b:delimitMate_excluded_regions = delimitMate#Get(\"excluded_regions\") . ',rustLifetimeCandidate,rustGenericLifetimeCandidate'\n-endif\n-\n-if has(\"folding\") && exists('g:rust_fold') && g:rust_fold != 0\n-\tlet b:rust_set_foldmethod=1\n-\tsetlocal foldmethod=syntax\n-\tif g:rust_fold == 2\n-\t\tsetlocal foldlevel<\n-\telse\n-\t\tsetlocal foldlevel=99\n-\tendif\n-endif\n-\n-if has('conceal') && exists('g:rust_conceal')\n-\tlet b:rust_set_conceallevel=1\n-\tsetlocal conceallevel=2\n-endif\n-\n-\" Motion Commands {{{1\n-\n-\" Bind motion commands to support hanging indents\n-nnoremap <silent> <buffer> [[ :call rust#Jump('n', 'Back')<CR>\n-nnoremap <silent> <buffer> ]] :call rust#Jump('n', 'Forward')<CR>\n-xnoremap <silent> <buffer> [[ :call rust#Jump('v', 'Back')<CR>\n-xnoremap <silent> <buffer> ]] :call rust#Jump('v', 'Forward')<CR>\n-onoremap <silent> <buffer> [[ :call rust#Jump('o', 'Back')<CR>\n-onoremap <silent> <buffer> ]] :call rust#Jump('o', 'Forward')<CR>\n-\n-\" Commands {{{1\n-\n-\" See |:RustRun| for docs\n-command! -nargs=* -complete=file -bang -bar -buffer RustRun call rust#Run(<bang>0, [<f-args>])\n-\n-\" See |:RustExpand| for docs\n-command! -nargs=* -complete=customlist,rust#CompleteExpand -bang -bar -buffer RustExpand call rust#Expand(<bang>0, [<f-args>])\n-\n-\" See |:RustEmitIr| for docs\n-command! -nargs=* -bar -buffer RustEmitIr call rust#Emit(\"ir\", [<f-args>])\n-\n-\" See |:RustEmitAsm| for docs\n-command! -nargs=* -bar -buffer RustEmitAsm call rust#Emit(\"asm\", [<f-args>])\n-\n-\" Mappings {{{1\n-\n-\" Bind \u2318R in MacVim to :RustRun\n-nnoremap <silent> <buffer> <D-r> :RustRun<CR>\n-\" Bind \u2318\u21e7R in MacVim to :RustRun! pre-filled with the last args\n-nnoremap <buffer> <D-R> :RustRun! <C-r>=join(b:rust_last_rustc_args)<CR><C-\\>erust#AppendCmdLine(' -- ' . join(b:rust_last_args))<CR>\n-\n-if !exists(\"b:rust_last_rustc_args\") || !exists(\"b:rust_last_args\")\n-\tlet b:rust_last_rustc_args = []\n-\tlet b:rust_last_args = []\n-endif\n-\n-\" Cleanup {{{1\n-\n-let b:undo_ftplugin = \"\n-\t\t\\ setlocal formatoptions< comments< commentstring< includeexpr< suffixesadd<\n-\t\t\\|setlocal tabstop< shiftwidth< softtabstop< expandtab< textwidth<\n-\t\t\\|if exists('b:rust_original_delimitMate_excluded_regions')\n-\t\t  \\|let b:delimitMate_excluded_regions = b:rust_original_delimitMate_excluded_regions\n-\t\t  \\|unlet b:rust_original_delimitMate_excluded_regions\n-\t\t\\|else\n-\t\t  \\|unlet! b:delimitMate_excluded_regions\n-\t\t\\|endif\n-\t\t\\|if exists('b:rust_set_foldmethod')\n-\t\t  \\|setlocal foldmethod< foldlevel<\n-\t\t  \\|unlet b:rust_set_foldmethod\n-\t\t\\|endif\n-\t\t\\|if exists('b:rust_set_conceallevel')\n-\t\t  \\|setlocal conceallevel<\n-\t\t  \\|unlet b:rust_set_conceallevel\n-\t\t\\|endif\n-\t\t\\|unlet! b:rust_last_rustc_args b:rust_last_args\n-\t\t\\|delcommand RustRun\n-\t\t\\|delcommand RustExpand\n-\t\t\\|delcommand RustEmitIr\n-\t\t\\|delcommand RustEmitAsm\n-\t\t\\|nunmap <buffer> <D-r>\n-\t\t\\|nunmap <buffer> <D-R>\n-\t\t\\|nunmap <buffer> [[\n-\t\t\\|nunmap <buffer> ]]\n-\t\t\\|xunmap <buffer> [[\n-\t\t\\|xunmap <buffer> ]]\n-\t\t\\|ounmap <buffer> [[\n-\t\t\\|ounmap <buffer> ]]\n-\t\t\\\"\n-\n-\" }}}1\n-\n-let &cpo = s:save_cpo\n-unlet s:save_cpo\n-\n-\" vim: set noet sw=4 ts=4:"}, {"sha": "300d7dacfa9ae57c3b119470448f7e91f6a7d992", "filename": "src/etc/vim/indent/rust.vim", "status": "removed", "additions": 0, "deletions": 196, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/c5961ad06d45689b44ff305c15d6ec7ec65755a9/src%2Fetc%2Fvim%2Findent%2Frust.vim", "raw_url": "https://github.com/rust-lang/rust/raw/c5961ad06d45689b44ff305c15d6ec7ec65755a9/src%2Fetc%2Fvim%2Findent%2Frust.vim", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fvim%2Findent%2Frust.vim?ref=c5961ad06d45689b44ff305c15d6ec7ec65755a9", "patch": "@@ -1,196 +0,0 @@\n-\" Vim indent file\n-\" Language:         Rust\n-\" Author:           Chris Morgan <me@chrismorgan.info>\n-\" Last Change:      2014 Sep 13\n-\n-\" Only load this indent file when no other was loaded.\n-if exists(\"b:did_indent\")\n-  finish\n-endif\n-let b:did_indent = 1\n-\n-setlocal cindent\n-setlocal cinoptions=L0,(0,Ws,J1,j1\n-setlocal cinkeys=0{,0},!^F,o,O,0[,0]\n-\" Don't think cinwords will actually do anything at all... never mind\n-setlocal cinwords=for,if,else,while,loop,impl,mod,unsafe,trait,struct,enum,fn,extern\n-\n-\" Some preliminary settings\n-setlocal nolisp\t\t\" Make sure lisp indenting doesn't supersede us\n-setlocal autoindent\t\" indentexpr isn't much help otherwise\n-\" Also do indentkeys, otherwise # gets shoved to column 0 :-/\n-setlocal indentkeys=0{,0},!^F,o,O,0[,0]\n-\n-setlocal indentexpr=GetRustIndent(v:lnum)\n-\n-\" Only define the function once.\n-if exists(\"*GetRustIndent\")\n-  finish\n-endif\n-\n-\" Come here when loading the script the first time.\n-\n-function! s:get_line_trimmed(lnum)\n-\t\" Get the line and remove a trailing comment.\n-\t\" Use syntax highlighting attributes when possible.\n-\t\" NOTE: this is not accurate; /* */ or a line continuation could trick it\n-\tlet line = getline(a:lnum)\n-\tlet line_len = strlen(line)\n-\tif has('syntax_items')\n-\t\t\" If the last character in the line is a comment, do a binary search for\n-\t\t\" the start of the comment.  synID() is slow, a linear search would take\n-\t\t\" too long on a long line.\n-\t\tif synIDattr(synID(a:lnum, line_len, 1), \"name\") =~ 'Comment\\|Todo'\n-\t\t\tlet min = 1\n-\t\t\tlet max = line_len\n-\t\t\twhile min < max\n-\t\t\t\tlet col = (min + max) / 2\n-\t\t\t\tif synIDattr(synID(a:lnum, col, 1), \"name\") =~ 'Comment\\|Todo'\n-\t\t\t\t\tlet max = col\n-\t\t\t\telse\n-\t\t\t\t\tlet min = col + 1\n-\t\t\t\tendif\n-\t\t\tendwhile\n-\t\t\tlet line = strpart(line, 0, min - 1)\n-\t\tendif\n-\t\treturn substitute(line, \"\\s*$\", \"\", \"\")\n-\telse\n-\t\t\" Sorry, this is not complete, nor fully correct (e.g. string \"//\").\n-\t\t\" Such is life.\n-\t\treturn substitute(line, \"\\s*//.*$\", \"\", \"\")\n-\tendif\n-endfunction\n-\n-function! s:is_string_comment(lnum, col)\n-\tif has('syntax_items')\n-\t\tfor id in synstack(a:lnum, a:col)\n-\t\t\tlet synname = synIDattr(id, \"name\")\n-\t\t\tif synname == \"rustString\" || synname =~ \"^rustComment\"\n-\t\t\t\treturn 1\n-\t\t\tendif\n-\t\tendfor\n-\telse\n-\t\t\" without syntax, let's not even try\n-\t\treturn 0\n-\tendif\n-endfunction\n-\n-function GetRustIndent(lnum)\n-\n-\t\" Starting assumption: cindent (called at the end) will do it right\n-\t\" normally. We just want to fix up a few cases.\n-\n-\tlet line = getline(a:lnum)\n-\n-\tif has('syntax_items')\n-\t\tlet synname = synIDattr(synID(a:lnum, 1, 1), \"name\")\n-\t\tif synname == \"rustString\"\n-\t\t\t\" If the start of the line is in a string, don't change the indent\n-\t\t\treturn -1\n-\t\telseif synname =~ '\\(Comment\\|Todo\\)'\n-\t\t\t\t\t\\ && line !~ '^\\s*/\\*'  \" not /* opening line\n-\t\t\tif synname =~ \"CommentML\" \" multi-line\n-\t\t\t\tif line !~ '^\\s*\\*' && getline(a:lnum - 1) =~ '^\\s*/\\*'\n-\t\t\t\t\t\" This is (hopefully) the line after a /*, and it has no\n-\t\t\t\t\t\" leader, so the correct indentation is that of the\n-\t\t\t\t\t\" previous line.\n-\t\t\t\t\treturn GetRustIndent(a:lnum - 1)\n-\t\t\t\tendif\n-\t\t\tendif\n-\t\t\t\" If it's in a comment, let cindent take care of it now. This is\n-\t\t\t\" for cases like \"/*\" where the next line should start \" * \", not\n-\t\t\t\" \"* \" as the code below would otherwise cause for module scope\n-\t\t\t\" Fun fact: \"  /*\\n*\\n*/\" takes two calls to get right!\n-\t\t\treturn cindent(a:lnum)\n-\t\tendif\n-\tendif\n-\n-\t\" cindent gets second and subsequent match patterns/struct members wrong,\n-\t\" as it treats the comma as indicating an unfinished statement::\n-\t\"\n-\t\" match a {\n-\t\"     b => c,\n-\t\"         d => e,\n-\t\"         f => g,\n-\t\" };\n-\n-\t\" Search backwards for the previous non-empty line.\n-\tlet prevlinenum = prevnonblank(a:lnum - 1)\n-\tlet prevline = s:get_line_trimmed(prevlinenum)\n-\twhile prevlinenum > 1 && prevline !~ '[^[:blank:]]'\n-\t\tlet prevlinenum = prevnonblank(prevlinenum - 1)\n-\t\tlet prevline = s:get_line_trimmed(prevlinenum)\n-\tendwhile\n-\tif prevline[len(prevline) - 1] == \",\"\n-\t\t\t\t\\ && s:get_line_trimmed(a:lnum) !~ '^\\s*[\\[\\]{}]'\n-\t\t\t\t\\ && prevline !~ '^\\s*fn\\s'\n-\t\t\t\t\\ && prevline !~ '([^()]\\+,$'\n-\t\t\" Oh ho! The previous line ended in a comma! I bet cindent will try to\n-\t\t\" take this too far... For now, let's normally use the previous line's\n-\t\t\" indent.\n-\n-\t\t\" One case where this doesn't work out is where *this* line contains\n-\t\t\" square or curly brackets; then we normally *do* want to be indenting\n-\t\t\" further.\n-\t\t\"\n-\t\t\" Another case where we don't want to is one like a function\n-\t\t\" definition with arguments spread over multiple lines:\n-\t\t\"\n-\t\t\" fn foo(baz: Baz,\n-\t\t\"        baz: Baz) // <-- cindent gets this right by itself\n-\t\t\"\n-\t\t\" Another case is similar to the previous, except calling a function\n-\t\t\" instead of defining it, or any conditional expression that leaves\n-\t\t\" an open paren:\n-\t\t\"\n-\t\t\" foo(baz,\n-\t\t\"     baz);\n-\t\t\"\n-\t\t\" if baz && (foo ||\n-\t\t\"            bar) {\n-\t\t\"\n-\t\t\" There are probably other cases where we don't want to do this as\n-\t\t\" well. Add them as needed.\n-\t\treturn indent(prevlinenum)\n-\tendif\n-\n-\tif !has(\"patch-7.4.355\")\n-\t\t\" cindent before 7.4.355 doesn't do the module scope well at all; e.g.::\n-\t\t\"\n-\t\t\" static FOO : &'static [bool] = [\n-\t\t\" true,\n-\t\t\"\t false,\n-\t\t\"\t false,\n-\t\t\"\t true,\n-\t\t\"\t ];\n-\t\t\"\n-\t\t\"\t uh oh, next statement is indented further!\n-\n-\t\t\" Note that this does *not* apply the line continuation pattern properly;\n-\t\t\" that's too hard to do correctly for my liking at present, so I'll just\n-\t\t\" start with these two main cases (square brackets and not returning to\n-\t\t\" column zero)\n-\n-\t\tcall cursor(a:lnum, 1)\n-\t\tif searchpair('{\\|(', '', '}\\|)', 'nbW',\n-\t\t\t\t\t\\ 's:is_string_comment(line(\".\"), col(\".\"))') == 0\n-\t\t\tif searchpair('\\[', '', '\\]', 'nbW',\n-\t\t\t\t\t\t\\ 's:is_string_comment(line(\".\"), col(\".\"))') == 0\n-\t\t\t\t\" Global scope, should be zero\n-\t\t\t\treturn 0\n-\t\t\telse\n-\t\t\t\t\" At the module scope, inside square brackets only\n-\t\t\t\t\"if getline(a:lnum)[0] == ']' || search('\\[', '', '\\]', 'nW') == a:lnum\n-\t\t\t\tif line =~ \"^\\\\s*]\"\n-\t\t\t\t\t\" It's the closing line, dedent it\n-\t\t\t\t\treturn 0\n-\t\t\t\telse\n-\t\t\t\t\treturn &shiftwidth\n-\t\t\t\tendif\n-\t\t\tendif\n-\t\tendif\n-\tendif\n-\n-\t\" Fall back on cindent, which does it mostly right\n-\treturn cindent(a:lnum)\n-endfunction"}, {"sha": "4ec4f33d54559c991b196305e6c7af0a2dfe0b16", "filename": "src/etc/vim/plugin/rust.vim", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/c5961ad06d45689b44ff305c15d6ec7ec65755a9/src%2Fetc%2Fvim%2Fplugin%2Frust.vim", "raw_url": "https://github.com/rust-lang/rust/raw/c5961ad06d45689b44ff305c15d6ec7ec65755a9/src%2Fetc%2Fvim%2Fplugin%2Frust.vim", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fvim%2Fplugin%2Frust.vim?ref=c5961ad06d45689b44ff305c15d6ec7ec65755a9", "patch": "@@ -1,22 +0,0 @@\n-\" Vim syntastic plugin helper\n-\" Language:     Rust\n-\" Maintainer:   Andrew Gallant <jamslam@gmail.com>\n-\n-if exists(\"g:loaded_syntastic_rust_filetype\")\n-  finish\n-endif\n-let g:loaded_syntastic_rust_filetype = 1\n-let s:save_cpo = &cpo\n-set cpo&vim\n-\n-\" This is to let Syntastic know about the Rust filetype.\n-\" It enables tab completion for the 'SyntasticInfo' command.\n-\" (This does not actually register the syntax checker.)\n-if exists('g:syntastic_extra_filetypes')\n-    call add(g:syntastic_extra_filetypes, 'rust')\n-else\n-    let g:syntastic_extra_filetypes = ['rust']\n-endif\n-\n-let &cpo = s:save_cpo\n-unlet s:save_cpo"}, {"sha": "a37b7b6d57dbfe0e129c91fa01a7b621b7d63131", "filename": "src/etc/vim/syntax/rust.vim", "status": "removed", "additions": 0, "deletions": 262, "changes": 262, "blob_url": "https://github.com/rust-lang/rust/blob/c5961ad06d45689b44ff305c15d6ec7ec65755a9/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim", "raw_url": "https://github.com/rust-lang/rust/raw/c5961ad06d45689b44ff305c15d6ec7ec65755a9/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fvim%2Fsyntax%2Frust.vim?ref=c5961ad06d45689b44ff305c15d6ec7ec65755a9", "patch": "@@ -1,262 +0,0 @@\n-\" Vim syntax file\n-\" Language:     Rust\n-\" Maintainer:   Patrick Walton <pcwalton@mozilla.com>\n-\" Maintainer:   Ben Blum <bblum@cs.cmu.edu>\n-\" Maintainer:   Chris Morgan <me@chrismorgan.info>\n-\" Last Change:  January 5, 2015\n-\n-if version < 600\n-  syntax clear\n-elseif exists(\"b:current_syntax\")\n-  finish\n-endif\n-\n-\" Syntax definitions {{{1\n-\" Basic keywords {{{2\n-syn keyword   rustConditional match if else\n-syn keyword   rustOperator    as\n-\n-syn match     rustAssert      \"\\<assert\\(\\w\\)*!\" contained\n-syn match     rustPanic       \"\\<panic\\(\\w\\)*!\" contained\n-syn keyword   rustKeyword     break\n-syn keyword   rustKeyword     box nextgroup=rustBoxPlacement skipwhite skipempty\n-syn keyword   rustKeyword     continue\n-syn keyword   rustKeyword     extern nextgroup=rustExternCrate,rustObsoleteExternMod skipwhite skipempty\n-syn keyword   rustKeyword     fn nextgroup=rustFuncName skipwhite skipempty\n-syn keyword   rustKeyword     for in if impl let\n-syn keyword   rustKeyword     loop once pub\n-syn keyword   rustKeyword     return super\n-syn keyword   rustKeyword     unsafe virtual where while\n-syn keyword   rustKeyword     use nextgroup=rustModPath skipwhite skipempty\n-\" FIXME: Scoped impl's name is also fallen in this category\n-syn keyword   rustKeyword     mod trait struct enum type nextgroup=rustIdentifier skipwhite skipempty\n-syn keyword   rustStorage     move mut ref static const\n-\n-syn keyword   rustInvalidBareKeyword crate\n-\n-syn keyword   rustExternCrate crate contained nextgroup=rustIdentifier,rustExternCrateString skipwhite skipempty\n-\" This is to get the `bar` part of `extern crate \"foo\" as bar;` highlighting.\n-syn match   rustExternCrateString /\".*\"\\_s*as/ contained nextgroup=rustIdentifier skipwhite transparent skipempty contains=rustString,rustOperator\n-syn keyword   rustObsoleteExternMod mod contained nextgroup=rustIdentifier skipwhite skipempty\n-\n-syn match     rustIdentifier  contains=rustIdentifierPrime \"\\%([^[:cntrl:][:space:][:punct:][:digit:]]\\|_\\)\\%([^[:cntrl:][:punct:][:space:]]\\|_\\)*\" display contained\n-syn match     rustFuncName    \"\\%([^[:cntrl:][:space:][:punct:][:digit:]]\\|_\\)\\%([^[:cntrl:][:punct:][:space:]]\\|_\\)*\" display contained\n-\n-syn region    rustBoxPlacement matchgroup=rustBoxPlacementParens start=\"(\" end=\")\" contains=TOP contained\n-syn keyword   rustBoxPlacementExpr GC containedin=rustBoxPlacement\n-\" Ideally we'd have syntax rules set up to match arbitrary expressions. Since\n-\" we don't, we'll just define temporary contained rules to handle balancing\n-\" delimiters.\n-syn region    rustBoxPlacementBalance start=\"(\" end=\")\" containedin=rustBoxPlacement transparent\n-syn region    rustBoxPlacementBalance start=\"\\[\" end=\"\\]\" containedin=rustBoxPlacement transparent\n-\" {} are handled by rustFoldBraces\n-\n-syn region rustMacroRepeat matchgroup=rustMacroRepeatDelimiters start=\"$(\" end=\")\" contains=TOP nextgroup=rustMacroRepeatCount\n-syn match rustMacroRepeatCount \".\\?[*+]\" contained\n-syn match rustMacroVariable \"$\\w\\+\"\n-\n-\" Reserved (but not yet used) keywords {{{2\n-syn keyword   rustReservedKeyword alignof be do offsetof priv pure sizeof typeof unsized yield abstract final override macro\n-\n-\" Built-in types {{{2\n-syn keyword   rustType        isize usize float char bool u8 u16 u32 u64 f32\n-syn keyword   rustType        f64 i8 i16 i32 i64 str Self\n-\n-\" Things from the prelude (src/libstd/prelude.rs) {{{2\n-\" This section is just straight transformation of the contents of the prelude,\n-\" to make it easy to update.\n-\n-\" Reexported core operators {{{3\n-syn keyword   rustTrait       Copy Send Sized Sync\n-syn keyword   rustTrait       Drop Fn FnMut FnOnce\n-\n-\" Reexported functions {{{3\n-syn keyword rustFunction drop\n-\n-\" Reexported types and traits {{{3\n-syn keyword rustTrait Box\n-syn keyword rustTrait CharExt\n-syn keyword rustTrait Clone\n-syn keyword rustTrait PartialEq PartialOrd Eq Ord\n-syn keyword rustTrait DoubleEndedIterator\n-syn keyword rustTrait ExactSizeIterator\n-syn keyword rustTrait Iterator IteratorExt Extend\n-syn keyword rustEnum Option\n-syn keyword rustEnumVariant Some None\n-syn keyword rustTrait PtrExt MutPtrExt\n-syn keyword rustEnum Result\n-syn keyword rustEnumVariant Ok Err\n-syn keyword rustTrait AsSlice\n-syn keyword rustTrait SliceExt SliceConcatExt\n-syn keyword rustTrait Str StrExt\n-syn keyword rustTrait String ToString\n-syn keyword rustTrait Vec\n-\" FIXME: remove when path reform lands\n-syn keyword rustTrait Path GenericPath\n-\" FIXME: remove when I/O reform lands\n-syn keyword rustTrait Buffer Writer Reader Seek BufferPrelude\n-\n-\" Other syntax {{{2\n-syn keyword   rustSelf        self\n-syn keyword   rustBoolean     true false\n-\n-\" If foo::bar changes to foo.bar, change this (\"::\" to \"\\.\").\n-\" If foo::bar changes to Foo::bar, change this (first \"\\w\" to \"\\u\").\n-syn match     rustModPath     \"\\w\\(\\w\\)*::[^<]\"he=e-3,me=e-3\n-syn match     rustModPathSep  \"::\"\n-\n-syn match     rustFuncCall    \"\\w\\(\\w\\)*(\"he=e-1,me=e-1\n-syn match     rustFuncCall    \"\\w\\(\\w\\)*::<\"he=e-3,me=e-3 \" foo::<T>();\n-\n-\" This is merely a convention; note also the use of [A-Z], restricting it to\n-\" latin identifiers rather than the full Unicode uppercase. I have not used\n-\" [:upper:] as it depends upon 'noignorecase'\n-\"syn match     rustCapsIdent    display \"[A-Z]\\w\\(\\w\\)*\"\n-\n-syn match     rustOperator     display \"\\%(+\\|-\\|/\\|*\\|=\\|\\^\\|&\\||\\|!\\|>\\|<\\|%\\)=\\?\"\n-\" This one isn't *quite* right, as we could have binary-& with a reference\n-syn match     rustSigil        display /&\\s\\+[&~@*][^)= \\t\\r\\n]/he=e-1,me=e-1\n-syn match     rustSigil        display /[&~@*][^)= \\t\\r\\n]/he=e-1,me=e-1\n-\" This isn't actually correct; a closure with no arguments can be `|| { }`.\n-\" Last, because the & in && isn't a sigil\n-syn match     rustOperator     display \"&&\\|||\"\n-\n-syn match     rustMacro       '\\w\\(\\w\\)*!' contains=rustAssert,rustPanic\n-syn match     rustMacro       '#\\w\\(\\w\\)*' contains=rustAssert,rustPanic\n-\n-syn match     rustEscapeError   display contained /\\\\./\n-syn match     rustEscape        display contained /\\\\\\([nrt0\\\\'\"]\\|x\\x\\{2}\\)/\n-syn match     rustEscapeUnicode display contained /\\\\\\(u\\x\\{4}\\|U\\x\\{8}\\)/\n-syn match     rustEscapeUnicode display contained /\\\\u{\\x\\{1,6}}/\n-syn match     rustStringContinuation display contained /\\\\\\n\\s*/\n-syn region    rustString      start=+b\"+ skip=+\\\\\\\\\\|\\\\\"+ end=+\"+ contains=rustEscape,rustEscapeError,rustStringContinuation\n-syn region    rustString      start=+\"+ skip=+\\\\\\\\\\|\\\\\"+ end=+\"+ contains=rustEscape,rustEscapeUnicode,rustEscapeError,rustStringContinuation,@Spell\n-syn region    rustString      start='b\\?r\\z(#*\\)\"' end='\"\\z1' contains=@Spell\n-\n-syn region    rustAttribute   start=\"#!\\?\\[\" end=\"\\]\" contains=rustString,rustDerive\n-syn region    rustDerive      start=\"derive(\" end=\")\" contained contains=rustTrait\n-\n-\" Number literals\n-syn match     rustDecNumber   display \"\\<[0-9][0-9_]*\\%([iu]\\%(s\\|8\\|16\\|32\\|64\\)\\)\\=\"\n-syn match     rustHexNumber   display \"\\<0x[a-fA-F0-9_]\\+\\%([iu]\\%(s\\|8\\|16\\|32\\|64\\)\\)\\=\"\n-syn match     rustOctNumber   display \"\\<0o[0-7_]\\+\\%([iu]\\%(s\\|8\\|16\\|32\\|64\\)\\)\\=\"\n-syn match     rustBinNumber   display \"\\<0b[01_]\\+\\%([iu]\\%(s\\|8\\|16\\|32\\|64\\)\\)\\=\"\n-\n-\" Special case for numbers of the form \"1.\" which are float literals, unless followed by\n-\" an identifier, which makes them integer literals with a method call or field access,\n-\" or by another \".\", which makes them integer literals followed by the \"..\" token.\n-\" (This must go first so the others take precedence.)\n-syn match     rustFloat       display \"\\<[0-9][0-9_]*\\.\\%([^[:cntrl:][:space:][:punct:][:digit:]]\\|_\\|\\.\\)\\@!\"\n-\" To mark a number as a normal float, it must have at least one of the three things integral values don't have:\n-\" a decimal point and more numbers; an exponent; and a type suffix.\n-syn match     rustFloat       display \"\\<[0-9][0-9_]*\\%(\\.[0-9][0-9_]*\\)\\%([eE][+-]\\=[0-9_]\\+\\)\\=\\(f32\\|f64\\)\\=\"\n-syn match     rustFloat       display \"\\<[0-9][0-9_]*\\%(\\.[0-9][0-9_]*\\)\\=\\%([eE][+-]\\=[0-9_]\\+\\)\\(f32\\|f64\\)\\=\"\n-syn match     rustFloat       display \"\\<[0-9][0-9_]*\\%(\\.[0-9][0-9_]*\\)\\=\\%([eE][+-]\\=[0-9_]\\+\\)\\=\\(f32\\|f64\\)\"\n-\n-\" For the benefit of delimitMate\n-syn region rustLifetimeCandidate display start=/&'\\%(\\([^'\\\\]\\|\\\\\\(['nrt0\\\\\\\"]\\|x\\x\\{2}\\|u\\x\\{4}\\|U\\x\\{8}\\)\\)'\\)\\@!/ end=/[[:cntrl:][:space:][:punct:]]\\@=\\|$/ contains=rustSigil,rustLifetime\n-syn region rustGenericRegion display start=/<\\%('\\|[^[cntrl:][:space:][:punct:]]\\)\\@=')\\S\\@=/ end=/>/ contains=rustGenericLifetimeCandidate\n-syn region rustGenericLifetimeCandidate display start=/\\%(<\\|,\\s*\\)\\@<='/ end=/[[:cntrl:][:space:][:punct:]]\\@=\\|$/ contains=rustSigil,rustLifetime\n-\n-\"rustLifetime must appear before rustCharacter, or chars will get the lifetime highlighting\n-syn match     rustLifetime    display \"\\'\\%([^[:cntrl:][:space:][:punct:][:digit:]]\\|_\\)\\%([^[:cntrl:][:punct:][:space:]]\\|_\\)*\"\n-syn match   rustCharacterInvalid   display contained /b\\?'\\zs[\\n\\r\\t']\\ze'/\n-\" The groups negated here add up to 0-255 but nothing else (they do not seem to go beyond ASCII).\n-syn match   rustCharacterInvalidUnicode   display contained /b'\\zs[^[:cntrl:][:graph:][:alnum:][:space:]]\\ze'/\n-syn match   rustCharacter   /b'\\([^\\\\]\\|\\\\\\(.\\|x\\x\\{2}\\)\\)'/ contains=rustEscape,rustEscapeError,rustCharacterInvalid,rustCharacterInvalidUnicode\n-syn match   rustCharacter   /'\\([^\\\\]\\|\\\\\\(.\\|x\\x\\{2}\\|u\\x\\{4}\\|U\\x\\{8}\\|u{\\x\\{1,6}}\\)\\)'/ contains=rustEscape,rustEscapeUnicode,rustEscapeError,rustCharacterInvalid\n-\n-syn region rustCommentLine                                        start=\"//\"                      end=\"$\"   contains=rustTodo,@Spell\n-syn region rustCommentLineDoc                                     start=\"//\\%(//\\@!\\|!\\)\"         end=\"$\"   contains=rustTodo,@Spell\n-syn region rustCommentBlock    matchgroup=rustCommentBlock        start=\"/\\*\\%(!\\|\\*[*/]\\@!\\)\\@!\" end=\"\\*/\" contains=rustTodo,rustCommentBlockNest,@Spell\n-syn region rustCommentBlockDoc matchgroup=rustCommentBlockDoc     start=\"/\\*\\%(!\\|\\*[*/]\\@!\\)\"    end=\"\\*/\" contains=rustTodo,rustCommentBlockDocNest,@Spell\n-syn region rustCommentBlockNest matchgroup=rustCommentBlock       start=\"/\\*\"                     end=\"\\*/\" contains=rustTodo,rustCommentBlockNest,@Spell contained transparent\n-syn region rustCommentBlockDocNest matchgroup=rustCommentBlockDoc start=\"/\\*\"                     end=\"\\*/\" contains=rustTodo,rustCommentBlockDocNest,@Spell contained transparent\n-\" FIXME: this is a really ugly and not fully correct implementation. Most\n-\" importantly, a case like ``/* */*`` should have the final ``*`` not being in\n-\" a comment, but in practice at present it leaves comments open two levels\n-\" deep. But as long as you stay away from that particular case, I *believe*\n-\" the highlighting is correct. Due to the way Vim's syntax engine works\n-\" (greedy for start matches, unlike Rust's tokeniser which is searching for\n-\" the earliest-starting match, start or end), I believe this cannot be solved.\n-\" Oh you who would fix it, don't bother with things like duplicating the Block\n-\" rules and putting ``\\*\\@<!`` at the start of them; it makes it worse, as\n-\" then you must deal with cases like ``/*/**/*/``. And don't try making it\n-\" worse with ``\\%(/\\@<!\\*\\)\\@<!``, either...\n-\n-syn keyword rustTodo contained TODO FIXME XXX NB NOTE\n-\n-\" Folding rules {{{2\n-\" Trivial folding rules to begin with.\n-\" FIXME: use the AST to make really good folding\n-syn region rustFoldBraces start=\"{\" end=\"}\" transparent fold\n-\n-\" Default highlighting {{{1\n-hi def link rustDecNumber       rustNumber\n-hi def link rustHexNumber       rustNumber\n-hi def link rustOctNumber       rustNumber\n-hi def link rustBinNumber       rustNumber\n-hi def link rustIdentifierPrime rustIdentifier\n-hi def link rustTrait           rustType\n-\n-hi def link rustMacroRepeatCount   rustMacroRepeatDelimiters\n-hi def link rustMacroRepeatDelimiters   Macro\n-hi def link rustMacroVariable Define\n-hi def link rustSigil         StorageClass\n-hi def link rustEscape        Special\n-hi def link rustEscapeUnicode rustEscape\n-hi def link rustEscapeError   Error\n-hi def link rustStringContinuation Special\n-hi def link rustString        String\n-hi def link rustCharacterInvalid Error\n-hi def link rustCharacterInvalidUnicode rustCharacterInvalid\n-hi def link rustCharacter     Character\n-hi def link rustNumber        Number\n-hi def link rustBoolean       Boolean\n-hi def link rustEnum          rustType\n-hi def link rustEnumVariant   rustConstant\n-hi def link rustConstant      Constant\n-hi def link rustSelf          Constant\n-hi def link rustFloat         Float\n-hi def link rustOperator      Operator\n-hi def link rustKeyword       Keyword\n-hi def link rustReservedKeyword Error\n-hi def link rustConditional   Conditional\n-hi def link rustIdentifier    Identifier\n-hi def link rustCapsIdent     rustIdentifier\n-hi def link rustModPath       Include\n-hi def link rustModPathSep    Delimiter\n-hi def link rustFunction      Function\n-hi def link rustFuncName      Function\n-hi def link rustFuncCall      Function\n-hi def link rustCommentLine   Comment\n-hi def link rustCommentLineDoc SpecialComment\n-hi def link rustCommentBlock  rustCommentLine\n-hi def link rustCommentBlockDoc rustCommentLineDoc\n-hi def link rustAssert        PreCondit\n-hi def link rustPanic         PreCondit\n-hi def link rustMacro         Macro\n-hi def link rustType          Type\n-hi def link rustTodo          Todo\n-hi def link rustAttribute     PreProc\n-hi def link rustDerive        PreProc\n-hi def link rustStorage       StorageClass\n-hi def link rustObsoleteStorage Error\n-hi def link rustLifetime      Special\n-hi def link rustInvalidBareKeyword Error\n-hi def link rustExternCrate   rustKeyword\n-hi def link rustObsoleteExternMod Error\n-hi def link rustBoxPlacementParens Delimiter\n-hi def link rustBoxPlacementExpr rustKeyword\n-\n-\" Other Suggestions:\n-\" hi rustAttribute ctermfg=cyan\n-\" hi rustDerive ctermfg=cyan\n-\" hi rustAssert ctermfg=yellow\n-\" hi rustPanic ctermfg=red\n-\" hi rustMacro ctermfg=magenta\n-\n-syn sync minlines=200\n-syn sync maxlines=500\n-\n-let b:current_syntax = \"rust\""}, {"sha": "5d196086168df91b84be9fa2de07ad878f5ea804", "filename": "src/etc/vim/syntax_checkers/rust/rustc.vim", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/c5961ad06d45689b44ff305c15d6ec7ec65755a9/src%2Fetc%2Fvim%2Fsyntax_checkers%2Frust%2Frustc.vim", "raw_url": "https://github.com/rust-lang/rust/raw/c5961ad06d45689b44ff305c15d6ec7ec65755a9/src%2Fetc%2Fvim%2Fsyntax_checkers%2Frust%2Frustc.vim", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fvim%2Fsyntax_checkers%2Frust%2Frustc.vim?ref=c5961ad06d45689b44ff305c15d6ec7ec65755a9", "patch": "@@ -1,35 +0,0 @@\n-\" Vim syntastic plugin\n-\" Language:     Rust\n-\" Maintainer:   Andrew Gallant <jamslam@gmail.com>\n-\"\n-\" See for details on how to add an external Syntastic checker:\n-\" https://github.com/scrooloose/syntastic/wiki/Syntax-Checker-Guide#external\n-\n-if exists(\"g:loaded_syntastic_rust_rustc_checker\")\n-    finish\n-endif\n-let g:loaded_syntastic_rust_rustc_checker = 1\n-\n-let s:save_cpo = &cpo\n-set cpo&vim\n-\n-function! SyntaxCheckers_rust_rustc_GetLocList() dict\n-    let makeprg = self.makeprgBuild({ 'args': '-Zparse-only' })\n-\n-    let errorformat  =\n-        \\ '%E%f:%l:%c: %\\d%#:%\\d%# %.%\\{-}error:%.%\\{-} %m,'   .\n-        \\ '%W%f:%l:%c: %\\d%#:%\\d%# %.%\\{-}warning:%.%\\{-} %m,' .\n-        \\ '%C%f:%l %m,' .\n-        \\ '%-Z%.%#'\n-\n-    return SyntasticMake({\n-        \\ 'makeprg': makeprg,\n-        \\ 'errorformat': errorformat })\n-endfunction\n-\n-call g:SyntasticRegistry.CreateAndRegisterChecker({\n-    \\ 'filetype': 'rust',\n-    \\ 'name': 'rustc'})\n-\n-let &cpo = s:save_cpo\n-unlet s:save_cpo"}, {"sha": "404f622f970c37f237bed5fd51a79964889b192b", "filename": "src/etc/zsh/_rust", "status": "removed", "additions": 0, "deletions": 215, "changes": 215, "blob_url": "https://github.com/rust-lang/rust/blob/c5961ad06d45689b44ff305c15d6ec7ec65755a9/src%2Fetc%2Fzsh%2F_rust", "raw_url": "https://github.com/rust-lang/rust/raw/c5961ad06d45689b44ff305c15d6ec7ec65755a9/src%2Fetc%2Fzsh%2F_rust", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fzsh%2F_rust?ref=c5961ad06d45689b44ff305c15d6ec7ec65755a9", "patch": "@@ -1,215 +0,0 @@\n-#compdef rustc\n-\n-local -a _rustc_opts_switches _rustc_opts_lint _rustc_opts_debug\n-\n-typeset -A opt_args\n-\n-_rustc_debuginfo_levels=(\n-    \"0[no debug info]\"\n-    \"1[line-tables only (for stacktraces and breakpoints)]\"\n-    \"2[full debug info with variable and type information (same as -g)]\"\n-)\n-\n-_rustc_crate_types=(\n-    'bin'\n-    'lib'\n-    'rlib'\n-    'dylib'\n-    'staticlib'\n-)\n-\n-_rustc_emit_types=(\n-    'asm'\n-    'llvm-bc'\n-    'llvm-ir'\n-    'obj'\n-    'link'\n-    'dep-info'\n-)\n-_rustc_pretty_types=(\n-    'normal[un-annotated source]'\n-    'expanded[crates expanded]'\n-    'typed[crates  expanded,  with  type  annotations]'\n-    'identified[fully parenthesized, AST nodes and blocks with IDs]'\n-    'flowgraph[graphviz formatted flowgraph for node]:NODEID:'\n-)\n-_rustc_color_types=(\n-    'auto[colorize, if output goes to a tty (default)]'\n-    'always[always colorize output]'\n-    'never[never colorize output]'\n-)\n-_rustc_info_types=(\n-    'crate-name[Output the crate name and exit]'\n-    'file-names[Output the file(s) that would be written if compilation continued and exited]'\n-    'sysroot[Output the sysroot and exit]'\n-)\n-\n-_rustc_opts_vals=(\n-    --crate-name='[Specify the name of the crate being built]'\n-    --crate-type='[Comma separated list of types of crates for the compiler to emit]:TYPES:_values -s \",\" \"Crate types\"  \"$_rustc_crate_types[@]\"'\n-    --emit='[Comma separated list of types of output for the compiler to emit]:TYPES:_values -s \",\" \"Emit Targets\" \"$_rustc_emit_types[@]\"'\n-    --cfg='[Configure the compilation environment]:SPEC:'\n-    --out-dir='[Write output to compiler-chosen filename in <dir>.  Ignored  if  -o  is  specified. (default the current directory)]:DIR:_files -/'\n-    -o'[Write output to <filename>. Ignored if more than one --emit is specified.]:FILENAME:_files'\n-    --pretty='[Pretty-print the input instead of compiling]::TYPE:_values \"TYPES\" \"$_rustc_pretty_types[@]\"'\n-    -L'[Add a directory to the library search path]:DIR:_files -/'\n-    --target='[Target triple cpu-manufacturer-kernel\\[-os\\] to compile]:TRIPLE:'\n-    --color='[Configure coloring of output]:CONF:_values \"COLORS\" \"$_rustc_color_types[@]\"'\n-    {-v,--version}'[Print version info and exit]::VERBOSE:(verbose)'\n-    --explain='[Provide a detailed explanation of an error message]:OPT:'\n-    --extern'[Specify where an external rust library is located]:ARG:'\n-    --print='[Comma separated list of compiler information to print on stdout]:TYPES:_values -s \",\" \"Compiler Information\" \"$_rustc_info_types[@]\"'\n-)\n-\n-_rustc_opts_switches=(\n-    -g'[Equivalent to -C debuginfo=2]'\n-    {-h,--help}'[Display the help message]'\n-    {-V,--verbose}'[use verbose output]'\n-    -O'[Equivalent to -C opt-level=2]'\n-    --test'[Build a test harness]'\n-)\n-\n-\n-_rustc_opts_link=(\n-    'static[Path to the library to link statically]:PATH:_files -/'\n-    'dylib[Path to the library to link dynamically]:PATH:_files -/'\n-    'framework[Path to the library to link as a framework]:PATH:_files -/'\n-)\n-\n-_rustc_opts_codegen=(\n-    'ar[Path to the archive utility to use when assembling archives.]:BIN:_path_files'\n-    'linker[Path to the linker utility to use when linking libraries, executables, and objects.]:BIN:_path_files'\n-    'link-args[A space-separated list of extra arguments to pass to the linker when the linker is invoked.]:ARGS:'\n-    'lto[Perform LLVM link-time optimizations]'\n-    'target-cpu[Selects a target processor. If the value is \"help\", then a list of  available  CPUs is printed.]:CPU:'\n-    'target-feature[A space-separated list of features to enable or disable for the target. A preceding \"+\" enables a feature while a preceding \"-\" disables it. Available features can be discovered through target-cpu=help.]:FEATURE:'\n-    'passes[A space-separated list of extra LLVM passes to run. A value of \"list\" will cause rustc to print all known passes and exit. The passes specified are appended at the end of the normal pass manager.]:LIST:'\n-    'llvm-args[A space-separated list of arguments to pass through to LLVM.]:ARGS:'\n-    'save-temps[If specified, the compiler will save more files (.bc, .o, .no-opt.bc) generated throughout compilation in the output directory.]'\n-    'rpath[If specified, then the rpath value for dynamic libraries will be set in either dynamic library or executable outputs.]'\n-    'no-prepopulate-passes[Suppresses pre-population of the LLVM pass manager that is run over the module.]'\n-    'no-vectorize-loops[Suppresses running the loop vectorization LLVM pass, regardless of optimization level.]'\n-    'no-vectorize-slp[Suppresses running the LLVM SLP vectorization pass, regardless of optimization level.]'\n-    'soft-float[Generates software floating point library calls instead of hardware instructions.]'\n-    'prefer-dynamic[Prefers dynamic linking to static linking.]'\n-    \"no-integrated-as[Force usage of an external assembler rather than LLVM's integrated one.]\"\n-    'no-redzone[disable the use of the redzone]'\n-    'relocation-model[The relocation model to use. (default: pic)]:MODEL:(pic static dynamic-no-pic)'\n-    'code-model[choose the code model to use (llc -code-model for details)]:MODEL:'\n-    'metadata[metadata to mangle symbol names with]:VAL:'\n-    'extra-filenames[extra data to put in each output filename]:VAL:'\n-    'codegen-units[divide crate into N units to optimize in parallel]:N:'\n-    'remark[print remarks for these optimization passes (space separated, or \"all\")]:TYPE:'\n-    'debuginfo[debug info emission level, 0 = no debug info, 1 = line tables only, 2 = full debug info with variable and type information]:LEVEL:_values \"Debug Levels\" \"$_rustc_debuginfo_levels[@]\"'\n-    'opt-level[Optimize with possible levels 0-3]:LEVEL:(0 1 2 3)'\n-    'help[Show all codegen options]'\n-)\n-\n-_rustc_opts_lint=(\n-    'help[Show a list of all lints]'\n-    'box-pointers[(default: allow) use of owned (Box type) heap memory]'\n-    'experimental[(default: allow) detects use of #\\[experimental\\] items]'\n-    'fat-ptr-transmutes[(default: allow) detects transmutes of fat pointers]'\n-    'missing-docs[(default: allow) detects missing documentation for public members]'\n-    'unsafe-blocks[(default: allow) usage of an \"unsafe\" block]'\n-    'unstable[(default: allow) detects use of #\\[unstable\\] items (incl. items with no stability attribute)]'\n-    'unused-extern-crates[(default: allow) extern crates that are never used]'\n-    'unused-import-braces[(default: allow) unnecessary braces around an imported item]'\n-    'unused-qualifications[(default: allow) detects unnecessarily qualified names]'\n-    'unused-results[(default: allow) unused result of an expression in a statement]'\n-    'unused-typecasts[(default: allow) detects unnecessary type casts that can be removed]'\n-    'variant-size-differences[(default: allow) detects enums with widely varying variant sizes]'\n-    'dead-code[(default: warn) detect unused, unexported items]'\n-    'deprecated[(default: warn) detects use of #\\[deprecated\\] items]'\n-    'improper-ctypes[(default: warn) proper use of libc types in foreign modules]'\n-    'missing-copy-implementations[(default: warn) detects potentially-forgotten implementations of \"Copy\"]'\n-    'non-camel-case-types[(default: warn) types, variants, traits and type parameters should have camel case names]'\n-    'non-shorthand-field-patterns[(default: warn) using \"Struct { x: x }\" instead of \"Struct { x }\"]'\n-    'non-snake-case[(default: warn) methods, functions, lifetime parameters and modules should have snake case names]'\n-    'non-upper-case-globals[(default: warn) static constants should have uppercase identifiers]'\n-    'overflowing-literals[(default: warn) literal out of range for its type]'\n-    'path-statements[(default: warn) path statements with no effect]'\n-    'raw-pointer-deriving[(default: warn) uses of #\\[derive\\] with raw pointers are rarely correct]'\n-    'unknown-lints[(default: warn) unrecognized lint attribute]'\n-    'unreachable-code[(default: warn) detects unreachable code paths]'\n-    'unsigned-negation[(default: warn) using an unary minus operator on unsigned type]'\n-    'unused-allocation[(default: warn) detects unnecessary allocations that can be eliminated]'\n-    'unused-assignments[(default: warn) detect assignments that will never be read]'\n-    'unused-attributes[(default: warn) detects attributes that were not used by the compiler]'\n-    'unused-comparisons[(default: warn) comparisons made useless by limits of the types involved]'\n-    'unused-imports[(default: warn) imports that are never used]'\n-    'unused-must-use[(default: warn) unused result of a type flagged as must_use]'\n-    \"unused-mut[(default: warn) detect mut variables which don't need to be mutable]\"\n-    'unused-parens[(default: warn) \"if\", \"match\", \"while\" and \"return\" do not need parentheses]'\n-    'unused-unsafe[(default: warn) unnecessary use of an \"unsafe\" block]'\n-    'unused-variables[(default: warn) detect variables which are not used in any way]'\n-    'warnings[(default: warn) mass-change the level for lints which produce warnings]'\n-    'while-true[(default: warn) suggest using \"loop { }\" instead of \"while true { }\"]'\n-    \"exceeding-bitshifts[(default: deny) shift exceeds the type's number of bits]\"\n-    'unknown-crate-types[(default: deny) unknown crate type found in #\\[crate_type\\] directive]'\n-    'unknown-features[(default: deny) unknown features found in crate-level #\\[feature\\] directives]'\n-    'bad-style[non-camel-case-types, non-snake-case, non-upper-case-globals]'\n-    'unused[unused-imports, unused-variables, unused-assignments, dead-code, unused-mut, unreachable-code, unused-must-use, unused-unsafe, path-statements]'\n-)\n-\n-_rustc_opts_debug=(\n-    'verbose[in general, enable more debug printouts]'\n-    'time-passes[measure time of each rustc pass]'\n-    'count-llvm-insns[count where LLVM instrs originate]'\n-    'time-llvm-passes[measure time of each LLVM pass]'\n-    'trans-stats[gather trans statistics]'\n-    'asm-comments[generate comments into the assembly (may change behavior)]'\n-    'no-verify[skip LLVM verification]'\n-    'borrowck-stats[gather borrowck statistics]'\n-    'no-landing-pads[omit landing pads for unwinding]'\n-    'debug-llvm[enable debug output from LLVM]'\n-    'show-span[show spans for compiler debugging]'\n-    'count-type-sizes[count the sizes of aggregate types]'\n-    'meta-stats[gather metadata statistics]'\n-    'print-link-args[Print the arguments passed to the linker]'\n-    'gc[Garbage collect shared data (experimental)]'\n-    'print-llvm-passes[Prints the llvm optimization passes being run]'\n-    'ast-json[Print the AST as JSON and halt]'\n-    'ast-json-noexpand[Print the pre-expansion AST as JSON and halt]'\n-    'ls[List the symbols defined by a library crate]'\n-    'save-analysis[Write syntax and type analysis information in addition to normal output]'\n-    'flowgraph-print-loans[Include loan analysis data in --pretty flowgraph output]'\n-    'flowgraph-print-moves[Include move analysis data in --pretty flowgraph output]'\n-    'flowgraph-print-assigns[Include assignment analysis data in --pretty flowgraph output]'\n-    'flowgraph-print-all[Include all dataflow analysis data in --pretty flowgraph output]'\n-    'print-regiion-graph[Prints region inference graph. Use with RUST_REGION_GRAPH=help for more info]'\n-    'parse-only[Parse only; do not compile, assemble, or link]'\n-    'no-trans[Run all passes except translation; no output]'\n-    'no-analysis[Parse and expand the source, but run no analysis]'\n-    'unstable-options[Adds unstable command line options to rustc interface]'\n-    'print-enum-sizes[Print the size of enums and their variants]'\n-)\n-\n-_rustc_opts_fun_lint(){\n-    _values -s , 'options' \\\n-        \"$_rustc_opts_lint[@]\"\n-}\n-\n-_rustc_opts_fun_debug(){\n-    _values 'options' \"$_rustc_opts_debug[@]\"\n-}\n-\n-_rustc_opts_fun_codegen(){\n-    _values 'options' \"$_rustc_opts_codegen[@]\"\n-}\n-\n-_rustc_opts_fun_link(){\n-    _values 'options' \"$_rustc_opts_link[@]\"\n-}\n-\n-_arguments -s :  \\\n-    '(-W --warn)'{-W,--warn=}'[Set lint warnings]:lint options:_rustc_opts_fun_lint' \\\n-    '(-A --allow)'{-A,--allow=}'[Set lint allowed]:lint options:_rustc_opts_fun_lint' \\\n-    '(-D --deny)'{-D,--deny=}'[Set lint denied]:lint options:_rustc_opts_fun_lint' \\\n-    '(-F --forbid)'{-F,--forbid=}'[Set lint forbidden]:lint options:_rustc_opts_fun_lint' \\\n-    '*-Z[Set internal debugging options]:debug options:_rustc_opts_fun_debug' \\\n-    '(-C --codegen)'{-C,--codegen}'[Set internal Codegen options]:codegen options:_rustc_opts_fun_codegen' \\\n-    '*-l[Link the generated crates to the specified native library NAME. the optional KIND can be one of, static, dylib, or framework. If omitted, dylib is assumed.]:ARG:_rustc_opts_fun_link' \\\n-    \"$_rustc_opts_switches[@]\" \\\n-    \"$_rustc_opts_vals[@]\" \\\n-    '::files:_files -g \"*.rs\"'"}]}