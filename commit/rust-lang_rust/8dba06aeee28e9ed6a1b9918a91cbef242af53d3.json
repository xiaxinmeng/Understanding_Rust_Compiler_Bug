{"sha": "8dba06aeee28e9ed6a1b9918a91cbef242af53d3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhkYmEwNmFlZWUyOGU5ZWQ2YTFiOTkxOGE5MWNiZWYyNDJhZjUzZDM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-08-27T23:25:38Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-08-27T23:25:38Z"}, "message": "Auto merge of #28052 - Manishearth:rollup, r=Manishearth\n\n- Successful merges: #28010, #28013, #28022, #28029, #28033, #28039, #28045, #28048\n- Failed merges:", "tree": {"sha": "3eafdb047257f17e55f56408801e9df45cbbf5f4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3eafdb047257f17e55f56408801e9df45cbbf5f4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8dba06aeee28e9ed6a1b9918a91cbef242af53d3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8dba06aeee28e9ed6a1b9918a91cbef242af53d3", "html_url": "https://github.com/rust-lang/rust/commit/8dba06aeee28e9ed6a1b9918a91cbef242af53d3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8dba06aeee28e9ed6a1b9918a91cbef242af53d3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "79dd92fc1638463ab8af1d275686c4751ce91465", "url": "https://api.github.com/repos/rust-lang/rust/commits/79dd92fc1638463ab8af1d275686c4751ce91465", "html_url": "https://github.com/rust-lang/rust/commit/79dd92fc1638463ab8af1d275686c4751ce91465"}, {"sha": "a63cd9b5a165ca86529e678b9fea642bdae2e156", "url": "https://api.github.com/repos/rust-lang/rust/commits/a63cd9b5a165ca86529e678b9fea642bdae2e156", "html_url": "https://github.com/rust-lang/rust/commit/a63cd9b5a165ca86529e678b9fea642bdae2e156"}], "stats": {"total": 575, "additions": 430, "deletions": 145}, "files": [{"sha": "587f60343c344ade265760671c737a344bcd5a33", "filename": "src/doc/trpl/testing.md", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/8dba06aeee28e9ed6a1b9918a91cbef242af53d3/src%2Fdoc%2Ftrpl%2Ftesting.md", "raw_url": "https://github.com/rust-lang/rust/raw/8dba06aeee28e9ed6a1b9918a91cbef242af53d3/src%2Fdoc%2Ftrpl%2Ftesting.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Ftrpl%2Ftesting.md?ref=8dba06aeee28e9ed6a1b9918a91cbef242af53d3", "patch": "@@ -120,13 +120,26 @@ And that's reflected in the summary line:\n test result: FAILED. 0 passed; 1 failed; 0 ignored; 0 measured\n ```\n \n-We also get a non-zero status code:\n+We also get a non-zero status code. We can use `$?` on OS X and Linux:\n \n ```bash\n $ echo $?\n 101\n ```\n \n+On Windows, if you\u2019re using `cmd`:\n+\n+```bash\n+> echo %ERRORLEVEL%\n+```\n+\n+And if you\u2019re using PowerShell:\n+\n+```bash\n+> echo $LASTEXITCODE # the code itself\n+> echo $? # a boolean, fail or succeed\n+```\n+\n This is useful if you want to integrate `cargo test` into other tooling.\n \n We can invert our test's failure with another attribute: `should_panic`:"}, {"sha": "21038f25be3cf3ab05ee7fd8231caa14e358bfaa", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/8dba06aeee28e9ed6a1b9918a91cbef242af53d3/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dba06aeee28e9ed6a1b9918a91cbef242af53d3/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=8dba06aeee28e9ed6a1b9918a91cbef242af53d3", "patch": "@@ -254,6 +254,51 @@ macro_rules! unreachable {\n \n /// A standardised placeholder for marking unfinished code. It panics with the\n /// message `\"not yet implemented\"` when executed.\n+///\n+/// This can be useful if you are prototyping and are just looking to have your\n+/// code typecheck, or if you're implementing a trait that requires multiple\n+/// methods, and you're only planning on using one of them.\n+///\n+/// # Examples\n+///\n+/// Here's an example of some in-progress code. We have a trait `Foo`:\n+///\n+/// ```\n+/// trait Foo {\n+///     fn bar(&self);\n+///     fn baz(&self);\n+/// }\n+/// ```\n+///\n+/// We want to implement `Foo` on one of our types, but we also want to work on\n+/// just `bar()` first. In order for our code to compile, we need to implement\n+/// `baz()`, so we can use `unimplemented!`:\n+///\n+/// ```\n+/// # trait Foo {\n+/// #     fn foo(&self);\n+/// #     fn bar(&self);\n+/// # }\n+/// struct MyStruct;\n+///\n+/// impl Foo for MyStruct {\n+///     fn foo(&self) {\n+///         // implementation goes here\n+///     }\n+///\n+///     fn bar(&self) {\n+///         // let's not worry about implementing bar() for now\n+///         unimplemented!();\n+///     }\n+/// }\n+///\n+/// fn main() {\n+///     let s = MyStruct;\n+///     s.foo();\n+///\n+///     // we aren't even using bar() yet, so this is fine.\n+/// }\n+/// ```\n #[macro_export]\n #[unstable(feature = \"core\",\n            reason = \"relationship with panic is unclear\")]"}, {"sha": "a36a120689cc6845132d1283457ac0b79c97eb9c", "filename": "src/libcore/option.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8dba06aeee28e9ed6a1b9918a91cbef242af53d3/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dba06aeee28e9ed6a1b9918a91cbef242af53d3/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=8dba06aeee28e9ed6a1b9918a91cbef242af53d3", "patch": "@@ -779,6 +779,26 @@ impl<T> IntoIterator for Option<T> {\n     }\n }\n \n+#[stable(since = \"1.4.0\", feature = \"option_iter\")]\n+impl<'a, T> IntoIterator for &'a Option<T> {\n+    type Item = &'a T;\n+    type IntoIter = Iter<'a, T>;\n+\n+    fn into_iter(self) -> Iter<'a, T> {\n+        self.iter()\n+    }\n+}\n+\n+#[stable(since = \"1.4.0\", feature = \"option_iter\")]\n+impl<'a, T> IntoIterator for &'a mut Option<T> {\n+    type Item = &'a mut T;\n+    type IntoIter = IterMut<'a, T>;\n+\n+    fn into_iter(mut self) -> IterMut<'a, T> {\n+        self.iter_mut()\n+    }\n+}\n+\n /////////////////////////////////////////////////////////////////////////////\n // The Option Iterators\n /////////////////////////////////////////////////////////////////////////////"}, {"sha": "2546d9cd63d8365b4fd7f85217a757e0b0b6d680", "filename": "src/libcore/result.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8dba06aeee28e9ed6a1b9918a91cbef242af53d3/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dba06aeee28e9ed6a1b9918a91cbef242af53d3/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=8dba06aeee28e9ed6a1b9918a91cbef242af53d3", "patch": "@@ -815,6 +815,26 @@ impl<T, E> IntoIterator for Result<T, E> {\n     }\n }\n \n+#[stable(since = \"1.4.0\", feature = \"result_iter\")]\n+impl<'a, T, E> IntoIterator for &'a Result<T, E> {\n+    type Item = &'a T;\n+    type IntoIter = Iter<'a, T>;\n+\n+    fn into_iter(self) -> Iter<'a, T> {\n+        self.iter()\n+    }\n+}\n+\n+#[stable(since = \"1.4.0\", feature = \"result_iter\")]\n+impl<'a, T, E> IntoIterator for &'a mut Result<T, E> {\n+    type Item = &'a mut T;\n+    type IntoIter = IterMut<'a, T>;\n+\n+    fn into_iter(mut self) -> IterMut<'a, T> {\n+        self.iter_mut()\n+    }\n+}\n+\n /////////////////////////////////////////////////////////////////////////////\n // The Result Iterators\n /////////////////////////////////////////////////////////////////////////////"}, {"sha": "9def44191db0599fec4e861ccc245c981a74a214", "filename": "src/libcoretest/iter.rs", "status": "modified", "additions": 26, "deletions": 27, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/8dba06aeee28e9ed6a1b9918a91cbef242af53d3/src%2Flibcoretest%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dba06aeee28e9ed6a1b9918a91cbef242af53d3/src%2Flibcoretest%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fiter.rs?ref=8dba06aeee28e9ed6a1b9918a91cbef242af53d3", "patch": "@@ -9,7 +9,6 @@\n // except according to those terms.\n \n use core::iter::*;\n-use core::iter::order::*;\n use core::{i8, i16, isize};\n use core::usize;\n \n@@ -21,51 +20,51 @@ fn test_lt() {\n     let xs = [1,2,3];\n     let ys = [1,2,0];\n \n-    assert!(!lt(xs.iter(), ys.iter()));\n-    assert!(!le(xs.iter(), ys.iter()));\n-    assert!( gt(xs.iter(), ys.iter()));\n-    assert!( ge(xs.iter(), ys.iter()));\n+    assert!(!xs.iter().lt(ys.iter()));\n+    assert!(!xs.iter().le(ys.iter()));\n+    assert!( xs.iter().gt(ys.iter()));\n+    assert!( xs.iter().ge(ys.iter()));\n \n-    assert!( lt(ys.iter(), xs.iter()));\n-    assert!( le(ys.iter(), xs.iter()));\n-    assert!(!gt(ys.iter(), xs.iter()));\n-    assert!(!ge(ys.iter(), xs.iter()));\n+    assert!( ys.iter().lt(xs.iter()));\n+    assert!( ys.iter().le(xs.iter()));\n+    assert!(!ys.iter().gt(xs.iter()));\n+    assert!(!ys.iter().ge(xs.iter()));\n \n-    assert!( lt(empty.iter(), xs.iter()));\n-    assert!( le(empty.iter(), xs.iter()));\n-    assert!(!gt(empty.iter(), xs.iter()));\n-    assert!(!ge(empty.iter(), xs.iter()));\n+    assert!( empty.iter().lt(xs.iter()));\n+    assert!( empty.iter().le(xs.iter()));\n+    assert!(!empty.iter().gt(xs.iter()));\n+    assert!(!empty.iter().ge(xs.iter()));\n \n     // Sequence with NaN\n     let u = [1.0f64, 2.0];\n     let v = [0.0f64/0.0, 3.0];\n \n-    assert!(!lt(u.iter(), v.iter()));\n-    assert!(!le(u.iter(), v.iter()));\n-    assert!(!gt(u.iter(), v.iter()));\n-    assert!(!ge(u.iter(), v.iter()));\n+    assert!(!u.iter().lt(v.iter()));\n+    assert!(!u.iter().le(v.iter()));\n+    assert!(!u.iter().gt(v.iter()));\n+    assert!(!u.iter().ge(v.iter()));\n \n     let a = [0.0f64/0.0];\n     let b = [1.0f64];\n     let c = [2.0f64];\n \n-    assert!(lt(a.iter(), b.iter()) == (a[0] <  b[0]));\n-    assert!(le(a.iter(), b.iter()) == (a[0] <= b[0]));\n-    assert!(gt(a.iter(), b.iter()) == (a[0] >  b[0]));\n-    assert!(ge(a.iter(), b.iter()) == (a[0] >= b[0]));\n+    assert!(a.iter().lt(b.iter()) == (a[0] <  b[0]));\n+    assert!(a.iter().le(b.iter()) == (a[0] <= b[0]));\n+    assert!(a.iter().gt(b.iter()) == (a[0] >  b[0]));\n+    assert!(a.iter().ge(b.iter()) == (a[0] >= b[0]));\n \n-    assert!(lt(c.iter(), b.iter()) == (c[0] <  b[0]));\n-    assert!(le(c.iter(), b.iter()) == (c[0] <= b[0]));\n-    assert!(gt(c.iter(), b.iter()) == (c[0] >  b[0]));\n-    assert!(ge(c.iter(), b.iter()) == (c[0] >= b[0]));\n+    assert!(c.iter().lt(b.iter()) == (c[0] <  b[0]));\n+    assert!(c.iter().le(b.iter()) == (c[0] <= b[0]));\n+    assert!(c.iter().gt(b.iter()) == (c[0] >  b[0]));\n+    assert!(c.iter().ge(b.iter()) == (c[0] >= b[0]));\n }\n \n #[test]\n fn test_multi_iter() {\n     let xs = [1,2,3,4];\n     let ys = [4,3,2,1];\n-    assert!(eq(xs.iter(), ys.iter().rev()));\n-    assert!(lt(xs.iter(), xs.iter().skip(2)));\n+    assert!(xs.iter().eq(ys.iter().rev()));\n+    assert!(xs.iter().lt(xs.iter().skip(2)));\n }\n \n #[test]"}, {"sha": "3e564cf197061fc7cebdda72e2d2aea034aeb708", "filename": "src/libcoretest/option.rs", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8dba06aeee28e9ed6a1b9918a91cbef242af53d3/src%2Flibcoretest%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dba06aeee28e9ed6a1b9918a91cbef242af53d3/src%2Flibcoretest%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Foption.rs?ref=8dba06aeee28e9ed6a1b9918a91cbef242af53d3", "patch": "@@ -180,11 +180,14 @@ fn test_iter() {\n     assert_eq!(it.next(), Some(&val));\n     assert_eq!(it.size_hint(), (0, Some(0)));\n     assert!(it.next().is_none());\n+\n+    let mut it = (&x).into_iter();\n+    assert_eq!(it.next(), Some(&val));\n }\n \n #[test]\n fn test_mut_iter() {\n-    let val = 5;\n+    let mut val = 5;\n     let new_val = 11;\n \n     let mut x = Some(val);\n@@ -205,6 +208,10 @@ fn test_mut_iter() {\n         assert!(it.next().is_none());\n     }\n     assert_eq!(x, Some(new_val));\n+\n+    let mut y = Some(val);\n+    let mut it = (&mut y).into_iter();\n+    assert_eq!(it.next(), Some(&mut val));\n }\n \n #[test]"}, {"sha": "6e9f653dcd8ac16b6948d1969e984caedeccdb0a", "filename": "src/libcoretest/result.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/8dba06aeee28e9ed6a1b9918a91cbef242af53d3/src%2Flibcoretest%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dba06aeee28e9ed6a1b9918a91cbef242af53d3/src%2Flibcoretest%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fresult.rs?ref=8dba06aeee28e9ed6a1b9918a91cbef242af53d3", "patch": "@@ -150,3 +150,36 @@ pub fn test_expect_err() {\n     let err: Result<isize, &'static str> = Err(\"All good\");\n     err.expect(\"Got expected error\");\n }\n+\n+#[test]\n+pub fn test_iter() {\n+    let ok: Result<isize, &'static str> = Ok(100);\n+    let mut it = ok.iter();\n+    assert_eq!(it.size_hint(), (1, Some(1)));\n+    assert_eq!(it.next(), Some(&100));\n+    assert_eq!(it.size_hint(), (0, Some(0)));\n+    assert!(it.next().is_none());\n+    assert_eq!((&ok).into_iter().next(), Some(&100));\n+\n+    let err: Result<isize, &'static str> = Err(\"error\");\n+    assert_eq!(err.iter().next(), None);\n+}\n+\n+#[test]\n+pub fn test_iter_mut() {\n+    let mut ok: Result<isize, &'static str> = Ok(100);\n+    for loc in ok.iter_mut() {\n+        *loc = 200;\n+    }\n+    assert_eq!(ok, Ok(200));\n+    for loc in &mut ok {\n+        *loc = 300;\n+    }\n+    assert_eq!(ok, Ok(300));\n+\n+    let mut err: Result<isize, &'static str> = Err(\"error\");\n+    for loc in err.iter_mut() {\n+        *loc = 200;\n+    }\n+    assert_eq!(err, Err(\"error\"));\n+}"}, {"sha": "0dbfffe5c644abba7c246926b7044e6e2fbe7dca", "filename": "src/librustc_typeck/diagnostics.rs", "status": "modified", "additions": 174, "deletions": 41, "changes": 215, "blob_url": "https://github.com/rust-lang/rust/blob/8dba06aeee28e9ed6a1b9918a91cbef242af53d3/src%2Flibrustc_typeck%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dba06aeee28e9ed6a1b9918a91cbef242af53d3/src%2Flibrustc_typeck%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fdiagnostics.rs?ref=8dba06aeee28e9ed6a1b9918a91cbef242af53d3", "patch": "@@ -73,10 +73,39 @@ the enum.\n \"##,\n \n E0025: r##\"\n-Each field of a struct can only be bound once in a pattern. Each occurrence of a\n-field name binds the value of that field, so to fix this error you will have to\n-remove or alter the duplicate uses of the field name. Perhaps you misspelt\n-another field name?\n+Each field of a struct can only be bound once in a pattern. Erroneous code\n+example:\n+\n+```\n+struct Foo {\n+    a: u8,\n+    b: u8,\n+}\n+\n+fn main(){\n+    let x = Foo { a:1, b:2 };\n+\n+    let Foo { a: x, a: y } = x;\n+    // error: field `a` bound multiple times in the pattern\n+}\n+```\n+\n+Each occurrence of a field name binds the value of that field, so to fix this\n+error you will have to remove or alter the duplicate uses of the field name.\n+Perhaps you misspelled another field name? Example:\n+\n+```\n+struct Foo {\n+    a: u8,\n+    b: u8,\n+}\n+\n+fn main(){\n+    let x = Foo { a:1, b:2 };\n+\n+    let Foo { a: x, b: y } = x; // ok!\n+}\n+```\n \"##,\n \n E0026: r##\"\n@@ -401,10 +430,35 @@ extern \"C\" {\n \"##,\n \n E0046: r##\"\n+Items are missing in a trait implementation. Erroneous code example:\n+\n+```\n+trait Foo {\n+    fn foo();\n+}\n+\n+struct Bar;\n+\n+impl Foo for Bar {}\n+// error: not all trait items implemented, missing: `foo`\n+```\n+\n When trying to make some type implement a trait `Foo`, you must, at minimum,\n provide implementations for all of `Foo`'s required methods (meaning the\n methods that do not have default implementations), as well as any required\n-trait items like associated types or constants.\n+trait items like associated types or constants. Example:\n+\n+```\n+trait Foo {\n+    fn foo();\n+}\n+\n+struct Bar;\n+\n+impl Foo for Bar {\n+    fn foo() {} // ok!\n+}\n+```\n \"##,\n \n E0049: r##\"\n@@ -615,14 +669,62 @@ variadic functions (except for its C-FFI).\n \n E0062: r##\"\n This error indicates that during an attempt to build a struct or struct-like\n-enum variant, one of the fields was specified more than once. Each field should\n-be specified exactly one time.\n+enum variant, one of the fields was specified more than once. Erroneous code\n+example:\n+\n+```\n+struct Foo {\n+    x: i32\n+}\n+\n+fn main() {\n+    let x = Foo {\n+                x: 0,\n+                x: 0, // error: field `x` specified more than once\n+            };\n+}\n+```\n+\n+Each field should be specified exactly one time. Example:\n+\n+```\n+struct Foo {\n+    x: i32\n+}\n+\n+fn main() {\n+    let x = Foo { x: 0 }; // ok!\n+}\n+```\n \"##,\n \n E0063: r##\"\n This error indicates that during an attempt to build a struct or struct-like\n-enum variant, one of the fields was not provided. Each field should be\n-specified exactly once.\n+enum variant, one of the fields was not provided. Erroneous code example:\n+\n+```\n+struct Foo {\n+    x: i32,\n+    y: i32\n+}\n+\n+fn main() {\n+    let x = Foo { x: 0 }; // error: missing field: `y`\n+}\n+```\n+\n+Each field should be specified exactly once. Example:\n+\n+```\n+struct Foo {\n+    x: i32,\n+    y: i32\n+}\n+\n+fn main() {\n+    let x = Foo { x: 0, y: 0 }; // ok!\n+}\n+```\n \"##,\n \n E0066: r##\"\n@@ -1025,7 +1127,7 @@ fn main() {\n }\n ```\n \n-The number of supplied parameters much exactly match the number of defined type\n+The number of supplied parameters must exactly match the number of defined type\n parameters.\n \"##,\n \n@@ -1620,14 +1722,20 @@ extern {\n E0131: r##\"\n It is not possible to define `main` with type parameters, or even with function\n parameters. When `main` is present, it must take no arguments and return `()`.\n+Erroneous code example:\n+\n+```\n+fn main<T>() { // error: main function is not allowed to have type parameters\n+}\n+```\n \"##,\n \n E0132: r##\"\n It is not possible to declare type parameters on a function that has the `start`\n attribute. Such a function must have the following type signature:\n \n ```\n-fn(isize, *const *const u8) -> isize\n+fn(isize, *const *const u8) -> isize;\n ```\n \"##,\n \n@@ -1779,7 +1887,7 @@ rfcs/blob/master/text/0019-opt-in-builtin-traits.md).\n \n E0193: r##\"\n `where` clauses must use generic type parameters: it does not make sense to use\n-them otherwise.  An example causing this error:\n+them otherwise. An example causing this error:\n \n ```\n trait Foo {\n@@ -1881,7 +1989,6 @@ unsafe impl Foo { }\n // converting it to this will fix it\n impl Foo { }\n ```\n-\n \"##,\n \n E0198: r##\"\n@@ -1898,7 +2005,6 @@ unsafe impl !Clone for Foo { }\n // this will compile\n impl !Clone for Foo { }\n ```\n-\n \"##,\n \n E0199: r##\"\n@@ -1916,7 +2022,6 @@ unsafe impl Bar for Foo { }\n // this will compile\n impl Bar for Foo { }\n ```\n-\n \"##,\n \n E0200: r##\"\n@@ -1934,7 +2039,6 @@ impl Bar for Foo { }\n // this will compile\n unsafe impl Bar for Foo { }\n ```\n-\n \"##,\n \n E0201: r##\"\n@@ -2717,6 +2821,36 @@ It is also possible to overload most operators for your own type by\n implementing traits from `std::ops`.\n \"##,\n \n+E0370: r##\"\n+The maximum value of an enum was reached, so it cannot be automatically\n+set in the next enum value. Erroneous code example:\n+\n+```\n+enum Foo {\n+    X = 0x7fffffffffffffff,\n+    Y // error: enum discriminant overflowed on value after\n+      //        9223372036854775807: i64; set explicitly via\n+      //        Y = -9223372036854775808 if that is desired outcome\n+}\n+```\n+\n+To fix this, please set manually the next enum value or put the enum variant\n+with the maximum value at the end of the enum. Examples:\n+\n+```\n+enum Foo {\n+    X = 0x7fffffffffffffff,\n+    Y = 0, // ok!\n+}\n+\n+// or:\n+enum Foo {\n+    Y = 0, // ok!\n+    X = 0x7fffffffffffffff,\n+}\n+```\n+\"##,\n+\n E0371: r##\"\n When `Trait2` is a subtrait of `Trait1` (for example, when `Trait2` has a\n definition like `trait Trait2: Trait1 { ... }`), it is not allowed to implement\n@@ -2869,44 +3003,44 @@ https://doc.rust-lang.org/std/marker/struct.PhantomData.html\n }\n \n register_diagnostics! {\n-    E0068,\n-    E0085,\n-    E0086,\n+//  E0068,\n+//  E0085,\n+//  E0086,\n     E0090,\n     E0103, // @GuillaumeGomez: I was unable to get this error, try your best!\n     E0104,\n     E0118,\n     E0122,\n-    E0123,\n-    E0127,\n-    E0129,\n-    E0141,\n+//  E0123,\n+//  E0127,\n+//  E0129,\n+//  E0141,\n //  E0159, // use of trait `{}` as struct constructor\n     E0163,\n     E0164,\n     E0167,\n //  E0168,\n-    E0173, // manual implementations of unboxed closure traits are experimental\n+//  E0173, // manual implementations of unboxed closure traits are experimental\n     E0174, // explicit use of unboxed closure methods are experimental\n     E0182,\n     E0183,\n-    E0187, // can't infer the kind of the closure\n-    E0188, // can not cast a immutable reference to a mutable pointer\n-    E0189, // deprecated: can only cast a boxed pointer to a boxed object\n-    E0190, // deprecated: can only cast a &-pointer to an &-object\n+//  E0187, // can't infer the kind of the closure\n+//  E0188, // can not cast a immutable reference to a mutable pointer\n+//  E0189, // deprecated: can only cast a boxed pointer to a boxed object\n+//  E0190, // deprecated: can only cast a &-pointer to an &-object\n     E0196, // cannot determine a type for this closure\n     E0203, // type parameter has more than one relaxed default bound,\n            // and only one is supported\n     E0208,\n-    E0209, // builtin traits can only be implemented on structs or enums\n+//  E0209, // builtin traits can only be implemented on structs or enums\n     E0212, // cannot extract an associated type from a higher-ranked trait bound\n-    E0213, // associated types are not accepted in this context\n+//  E0213, // associated types are not accepted in this context\n     E0214, // parenthesized parameters may only be used with a trait\n //  E0215, // angle-bracket notation is not stable with `Fn`\n //  E0216, // parenthetical notation is only stable with `Fn`\n-    E0217, // ambiguous associated type, defined in multiple supertraits\n-    E0218, // no associated type defined\n-    E0219, // associated type defined in higher-ranked supertrait\n+//  E0217, // ambiguous associated type, defined in multiple supertraits\n+//  E0218, // no associated type defined\n+//  E0219, // associated type defined in higher-ranked supertrait\n //  E0222, // Error code E0045 (variadic function must have C calling\n            // convention) duplicate\n     E0224, // at least one non-builtin train is required for an object type\n@@ -2916,25 +3050,24 @@ register_diagnostics! {\n     E0229, // associated type bindings are not allowed here\n     E0230, // there is no type parameter on trait\n     E0231, // only named substitution parameters are allowed\n-    E0233,\n-    E0234,\n+//  E0233,\n+//  E0234,\n //  E0235, // structure constructor specifies a structure of type but\n     E0236, // no lang item for range syntax\n     E0237, // no lang item for range syntax\n     E0238, // parenthesized parameters may only be used with a trait\n-    E0239, // `next` method of `Iterator` trait has unexpected type\n-    E0240,\n-    E0241,\n+//  E0239, // `next` method of `Iterator` trait has unexpected type\n+//  E0240,\n+//  E0241,\n     E0242, // internal error looking up a definition\n     E0245, // not a trait\n-    E0246, // invalid recursive type\n+//  E0246, // invalid recursive type\n     E0247, // found module name used as a type\n-    E0319, // trait impls for defaulted traits allowed just for structs/enums\n+//  E0319, // trait impls for defaulted traits allowed just for structs/enums\n     E0320, // recursive overflow during dropck\n     E0321, // extended coherence rules for defaulted traits violated\n     E0328, // cannot implement Unsize explicitly\n     E0329, // associated const depends on type parameter or Self.\n-    E0370, // discriminant overflow\n     E0374, // the trait `CoerceUnsized` may only be implemented for a coercion\n            // between structures with one field being coerced, none found\n     E0375, // the trait `CoerceUnsized` may only be implemented for a coercion"}, {"sha": "66893ffd33071d755c62d1d864993be49c1733ad", "filename": "src/libstd/path.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8dba06aeee28e9ed6a1b9918a91cbef242af53d3/src%2Flibstd%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dba06aeee28e9ed6a1b9918a91cbef242af53d3/src%2Flibstd%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath.rs?ref=8dba06aeee28e9ed6a1b9918a91cbef242af53d3", "patch": "@@ -598,8 +598,11 @@ impl<'a> Components<'a> {\n     /// how much of the prefix is left from the point of view of iteration?\n     #[inline]\n     fn prefix_remaining(&self) -> usize {\n-        if self.front == State::Prefix { self.prefix_len() }\n-        else { 0 }\n+        if self.front == State::Prefix {\n+            self.prefix_len()\n+        } else {\n+            0\n+        }\n     }\n \n     // Given the iteration so far, how much of the pre-State::Body path is left?"}, {"sha": "e07cd7b5847e89ad6f812a92287012c1b18b0cf2", "filename": "src/libsyntax/codemap.rs", "status": "modified", "additions": 36, "deletions": 7, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/8dba06aeee28e9ed6a1b9918a91cbef242af53d3/src%2Flibsyntax%2Fcodemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dba06aeee28e9ed6a1b9918a91cbef242af53d3/src%2Flibsyntax%2Fcodemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fcodemap.rs?ref=8dba06aeee28e9ed6a1b9918a91cbef242af53d3", "patch": "@@ -29,6 +29,8 @@ use std::io::{self, Read};\n \n use serialize::{Encodable, Decodable, Encoder, Decoder};\n \n+use parse::token::intern;\n+use ast::Name;\n \n // _____________________________________________________________________________\n // Pos, BytePos, CharPos\n@@ -257,21 +259,38 @@ pub struct FileMapAndBytePos { pub fm: Rc<FileMap>, pub pos: BytePos }\n //\n \n /// The source of expansion.\n-#[derive(Clone, Copy, Hash, Debug, PartialEq, Eq)]\n+#[derive(Clone, Hash, Debug, PartialEq, Eq)]\n pub enum ExpnFormat {\n     /// e.g. #[derive(...)] <item>\n-    MacroAttribute,\n+    MacroAttribute(Name),\n     /// e.g. `format!()`\n-    MacroBang,\n+    MacroBang(Name),\n     /// Syntax sugar expansion performed by the compiler (libsyntax::expand).\n-    CompilerExpansion,\n+    CompilerExpansion(CompilerExpansionFormat),\n+}\n+\n+#[derive(Clone, Copy, Hash, Debug, PartialEq, Eq)]\n+pub enum CompilerExpansionFormat {\n+    IfLet,\n+    PlacementIn,\n+    WhileLet,\n+    ForLoop,\n+    Closure,\n }\n \n+impl CompilerExpansionFormat {\n+    pub fn name(self) -> &'static str {\n+        match self {\n+            CompilerExpansionFormat::IfLet => \"if let expansion\",\n+            CompilerExpansionFormat::PlacementIn => \"placement-in expansion\",\n+            CompilerExpansionFormat::WhileLet => \"while let expansion\",\n+            CompilerExpansionFormat::ForLoop => \"for loop expansion\",\n+            CompilerExpansionFormat::Closure => \"closure expansion\",\n+        }\n+    }\n+}\n #[derive(Clone, Hash, Debug)]\n pub struct NameAndSpan {\n-    /// The name of the macro that was invoked to create the thing\n-    /// with this Span.\n-    pub name: String,\n     /// The format with which the macro was invoked.\n     pub format: ExpnFormat,\n     /// Whether the macro is allowed to use #[unstable]/feature-gated\n@@ -284,6 +303,16 @@ pub struct NameAndSpan {\n     pub span: Option<Span>\n }\n \n+impl NameAndSpan {\n+    pub fn name(&self) -> Name {\n+        match self.format {\n+            ExpnFormat::MacroAttribute(s) => s,\n+            ExpnFormat::MacroBang(s) => s,\n+            ExpnFormat::CompilerExpansion(ce) => intern(ce.name()),\n+        }\n+    }\n+}\n+\n /// Extra information for tracking spans of macro and syntax sugar expansion\n #[derive(Hash, Debug)]\n pub struct ExpnInfo {"}, {"sha": "067e3fff3eb299a1ca6ab403069d191126871fe6", "filename": "src/libsyntax/diagnostic.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8dba06aeee28e9ed6a1b9918a91cbef242af53d3/src%2Flibsyntax%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dba06aeee28e9ed6a1b9918a91cbef242af53d3/src%2Flibsyntax%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fdiagnostic.rs?ref=8dba06aeee28e9ed6a1b9918a91cbef242af53d3", "patch": "@@ -733,14 +733,14 @@ impl EmitterWriter {\n                     let ss = ei.callee.span.map_or(String::new(),\n                                                    |span| cm.span_to_string(span));\n                     let (pre, post) = match ei.callee.format {\n-                        codemap::MacroAttribute => (\"#[\", \"]\"),\n-                        codemap::MacroBang => (\"\", \"!\"),\n-                        codemap::CompilerExpansion => (\"\", \"\"),\n+                        codemap::MacroAttribute(..) => (\"#[\", \"]\"),\n+                        codemap::MacroBang(..) => (\"\", \"!\"),\n+                        codemap::CompilerExpansion(..) => (\"\", \"\"),\n                     };\n                     try!(self.print_diagnostic(&ss, Note,\n                                                &format!(\"in expansion of {}{}{}\",\n                                                         pre,\n-                                                        ei.callee.name,\n+                                                        ei.callee.name(),\n                                                         post),\n                                                None));\n                     let ss = cm.span_to_string(ei.call_site);"}, {"sha": "c48b740d83ae5b3e4830e6e91725c9d755a3b2a0", "filename": "src/libsyntax/ext/asm.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8dba06aeee28e9ed6a1b9918a91cbef242af53d3/src%2Flibsyntax%2Fext%2Fasm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dba06aeee28e9ed6a1b9918a91cbef242af53d3/src%2Flibsyntax%2Fext%2Fasm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fasm.rs?ref=8dba06aeee28e9ed6a1b9918a91cbef242af53d3", "patch": "@@ -19,7 +19,7 @@ use codemap::Span;\n use ext::base;\n use ext::base::*;\n use feature_gate;\n-use parse::token::InternedString;\n+use parse::token::{intern, InternedString};\n use parse::token;\n use ptr::P;\n \n@@ -211,8 +211,7 @@ pub fn expand_asm<'cx>(cx: &'cx mut ExtCtxt, sp: Span, tts: &[ast::TokenTree])\n     let expn_id = cx.codemap().record_expansion(codemap::ExpnInfo {\n         call_site: sp,\n         callee: codemap::NameAndSpan {\n-            name: \"asm\".to_string(),\n-            format: codemap::MacroBang,\n+            format: codemap::MacroBang(intern(\"asm\")),\n             span: None,\n             allow_internal_unstable: false,\n         },"}, {"sha": "ef49ef11497fc585509e6ebbb408fbbe5f44ce3e", "filename": "src/libsyntax/ext/base.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/8dba06aeee28e9ed6a1b9918a91cbef242af53d3/src%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dba06aeee28e9ed6a1b9918a91cbef242af53d3/src%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbase.rs?ref=8dba06aeee28e9ed6a1b9918a91cbef242af53d3", "patch": "@@ -714,13 +714,14 @@ impl<'a> ExtCtxt<'a> {\n         loop {\n             if self.codemap().with_expn_info(expn_id, |info| {\n                 info.map_or(None, |i| {\n-                    if i.callee.name == \"include\" {\n+                    if i.callee.name() == \"include\" {\n                         // Stop going up the backtrace once include! is encountered\n                         return None;\n                     }\n                     expn_id = i.call_site.expn_id;\n-                    if i.callee.format != CompilerExpansion {\n-                        last_macro = Some(i.call_site)\n+                    match i.callee.format {\n+                        CompilerExpansion(..) => (),\n+                        _ => last_macro = Some(i.call_site),\n                     }\n                     return Some(());\n                 })\n@@ -744,7 +745,7 @@ impl<'a> ExtCtxt<'a> {\n         if self.recursion_count > self.ecfg.recursion_limit {\n             panic!(self.span_fatal(ei.call_site,\n                             &format!(\"recursion limit reached while expanding the macro `{}`\",\n-                                    ei.callee.name)));\n+                                    ei.callee.name())));\n         }\n \n         let mut call_site = ei.call_site;"}, {"sha": "3196380ec6c36797805a458da22b4f50fc298501", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/8dba06aeee28e9ed6a1b9918a91cbef242af53d3/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dba06aeee28e9ed6a1b9918a91cbef242af53d3/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=8dba06aeee28e9ed6a1b9918a91cbef242af53d3", "patch": "@@ -205,7 +205,7 @@ use codemap::Span;\n use diagnostic::SpanHandler;\n use fold::MoveMap;\n use owned_slice::OwnedSlice;\n-use parse::token::InternedString;\n+use parse::token::{intern, InternedString};\n use parse::token::special_idents;\n use ptr::P;\n \n@@ -1436,8 +1436,7 @@ impl<'a> TraitDef<'a> {\n         to_set.expn_id = cx.codemap().record_expansion(codemap::ExpnInfo {\n             call_site: to_set,\n             callee: codemap::NameAndSpan {\n-                name: format!(\"derive({})\", trait_name),\n-                format: codemap::MacroAttribute,\n+                format: codemap::MacroAttribute(intern(&format!(\"derive({})\", trait_name))),\n                 span: Some(self.span),\n                 allow_internal_unstable: false,\n             }"}, {"sha": "3459caecb260a21c5c9aa06e7e806f28f989e116", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 26, "deletions": 34, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/8dba06aeee28e9ed6a1b9918a91cbef242af53d3/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dba06aeee28e9ed6a1b9918a91cbef242af53d3/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=8dba06aeee28e9ed6a1b9918a91cbef242af53d3", "patch": "@@ -19,7 +19,8 @@ use ext::build::AstBuilder;\n use attr;\n use attr::AttrMetaMethods;\n use codemap;\n-use codemap::{Span, Spanned, ExpnInfo, NameAndSpan, MacroBang, MacroAttribute, CompilerExpansion};\n+use codemap::{Span, Spanned, ExpnInfo, NameAndSpan, MacroBang, MacroAttribute};\n+use codemap::{CompilerExpansion, CompilerExpansionFormat};\n use ext::base::*;\n use feature_gate::{self, Features, GatedCfg};\n use fold;\n@@ -43,12 +44,12 @@ fn mk_core_path(fld: &mut MacroExpander,\n }\n \n pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n-    fn push_compiler_expansion(fld: &mut MacroExpander, span: Span, expansion_desc: &str) {\n+    fn push_compiler_expansion(fld: &mut MacroExpander, span: Span,\n+                               expansion_type: CompilerExpansionFormat) {\n         fld.cx.bt_push(ExpnInfo {\n             call_site: span,\n             callee: NameAndSpan {\n-                name: expansion_desc.to_string(),\n-                format: CompilerExpansion,\n+                format: CompilerExpansion(expansion_type),\n \n                 // This does *not* mean code generated after\n                 // `push_compiler_expansion` is automatically exempt\n@@ -111,7 +112,7 @@ pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n                 &fld.cx.parse_sess.span_diagnostic,\n                 expr_span);\n \n-            push_compiler_expansion(fld, expr_span, \"placement-in expansion\");\n+            push_compiler_expansion(fld, expr_span, CompilerExpansionFormat::PlacementIn);\n \n             let value_span = value_expr.span;\n             let placer_span = placer.span;\n@@ -223,7 +224,7 @@ pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n             //     }\n             //   }\n \n-            push_compiler_expansion(fld, span, \"while let expansion\");\n+            push_compiler_expansion(fld, span, CompilerExpansionFormat::WhileLet);\n \n             // `<pat> => <body>`\n             let pat_arm = {\n@@ -262,7 +263,7 @@ pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n             //     _ => [<elseopt> | ()]\n             //   }\n \n-            push_compiler_expansion(fld, span, \"if let expansion\");\n+            push_compiler_expansion(fld, span, CompilerExpansionFormat::IfLet);\n \n             // `<pat> => <body>`\n             let pat_arm = {\n@@ -334,7 +335,7 @@ pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n         ast::ExprIf(cond, blk, elseopt) => {\n             let elseopt = elseopt.map(|els| els.and_then(|els| match els.node {\n                 ast::ExprIfLet(..) => {\n-                    push_compiler_expansion(fld, span, \"if let expansion\");\n+                    push_compiler_expansion(fld, span, CompilerExpansionFormat::IfLet);\n                     // wrap the if-let expr in a block\n                     let span = els.span;\n                     let blk = P(ast::Block {\n@@ -378,7 +379,7 @@ pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n             //     result\n             //   }\n \n-            push_compiler_expansion(fld, span, \"for loop expansion\");\n+            push_compiler_expansion(fld, span, CompilerExpansionFormat::ForLoop);\n \n             let span = fld.new_span(span);\n \n@@ -458,7 +459,7 @@ pub fn expand_expr(e: P<ast::Expr>, fld: &mut MacroExpander) -> P<ast::Expr> {\n         }\n \n         ast::ExprClosure(capture_clause, fn_decl, block) => {\n-            push_compiler_expansion(fld, span, \"closure expansion\");\n+            push_compiler_expansion(fld, span, CompilerExpansionFormat::Closure);\n             let (rewritten_fn_decl, rewritten_block)\n                 = expand_and_rename_fn_decl_and_block(fn_decl, block, fld);\n             let new_node = ast::ExprClosure(capture_clause,\n@@ -542,8 +543,7 @@ fn expand_mac_invoc<T, F, G>(mac: ast::Mac,\n                         fld.cx.bt_push(ExpnInfo {\n                                 call_site: span,\n                                 callee: NameAndSpan {\n-                                    name: extname.to_string(),\n-                                    format: MacroBang,\n+                                    format: MacroBang(extname),\n                                     span: exp_span,\n                                     allow_internal_unstable: allow_internal_unstable,\n                                 },\n@@ -721,8 +721,7 @@ pub fn expand_item_mac(it: P<ast::Item>,\n                     fld.cx.bt_push(ExpnInfo {\n                         call_site: it.span,\n                         callee: NameAndSpan {\n-                            name: extname.to_string(),\n-                            format: MacroBang,\n+                            format: MacroBang(extname),\n                             span: span,\n                             allow_internal_unstable: allow_internal_unstable,\n                         }\n@@ -741,8 +740,7 @@ pub fn expand_item_mac(it: P<ast::Item>,\n                     fld.cx.bt_push(ExpnInfo {\n                         call_site: it.span,\n                         callee: NameAndSpan {\n-                            name: extname.to_string(),\n-                            format: MacroBang,\n+                            format: MacroBang(extname),\n                             span: span,\n                             allow_internal_unstable: allow_internal_unstable,\n                         }\n@@ -762,8 +760,7 @@ pub fn expand_item_mac(it: P<ast::Item>,\n                     fld.cx.bt_push(ExpnInfo {\n                         call_site: it.span,\n                         callee: NameAndSpan {\n-                            name: extname.to_string(),\n-                            format: MacroBang,\n+                            format: MacroBang(extname),\n                             span: None,\n                             // `macro_rules!` doesn't directly allow\n                             // unstable (this is orthogonal to whether\n@@ -1090,8 +1087,7 @@ fn expand_pat(p: P<ast::Pat>, fld: &mut MacroExpander) -> P<ast::Pat> {\n                     fld.cx.bt_push(ExpnInfo {\n                         call_site: span,\n                         callee: NameAndSpan {\n-                            name: extname.to_string(),\n-                            format: MacroBang,\n+                            format: MacroBang(extname),\n                             span: tt_span,\n                             allow_internal_unstable: allow_internal_unstable,\n                         }\n@@ -1293,17 +1289,16 @@ fn expand_decorators(a: Annotatable,\n                      new_attrs: &mut Vec<ast::Attribute>)\n {\n     for attr in a.attrs() {\n-        let mname = attr.name();\n-        match fld.cx.syntax_env.find(&intern(&mname)) {\n+        let mname = intern(&attr.name());\n+        match fld.cx.syntax_env.find(&mname) {\n             Some(rc) => match *rc {\n                 Decorator(ref dec) => {\n                     attr::mark_used(&attr);\n \n                     fld.cx.bt_push(ExpnInfo {\n                         call_site: attr.span,\n                         callee: NameAndSpan {\n-                            name: mname.to_string(),\n-                            format: MacroAttribute,\n+                            format: MacroAttribute(mname),\n                             span: Some(attr.span),\n                             // attributes can do whatever they like,\n                             // for now.\n@@ -1330,8 +1325,7 @@ fn expand_decorators(a: Annotatable,\n                     fld.cx.bt_push(ExpnInfo {\n                         call_site: attr.span,\n                         callee: NameAndSpan {\n-                            name: mname.to_string(),\n-                            format: MacroAttribute,\n+                            format: MacroAttribute(mname),\n                             span: Some(attr.span),\n                             // attributes can do whatever they like,\n                             // for now.\n@@ -1372,17 +1366,16 @@ fn expand_item_multi_modifier(mut it: Annotatable,\n     }\n \n     for attr in &modifiers {\n-        let mname = attr.name();\n+        let mname = intern(&attr.name());\n \n-        match fld.cx.syntax_env.find(&intern(&mname)) {\n+        match fld.cx.syntax_env.find(&mname) {\n             Some(rc) => match *rc {\n                 MultiModifier(ref mac) => {\n                     attr::mark_used(attr);\n                     fld.cx.bt_push(ExpnInfo {\n                         call_site: attr.span,\n                         callee: NameAndSpan {\n-                            name: mname.to_string(),\n-                            format: MacroAttribute,\n+                            format: MacroAttribute(mname),\n                             span: Some(attr.span),\n                             // attributes can do whatever they like,\n                             // for now\n@@ -1421,17 +1414,16 @@ fn expand_item_modifiers(mut it: P<ast::Item>,\n     }\n \n     for attr in &modifiers {\n-        let mname = attr.name();\n+        let mname = intern(&attr.name());\n \n-        match fld.cx.syntax_env.find(&intern(&mname)) {\n+        match fld.cx.syntax_env.find(&mname) {\n             Some(rc) => match *rc {\n                 Modifier(ref mac) => {\n                     attr::mark_used(attr);\n                     fld.cx.bt_push(ExpnInfo {\n                         call_site: attr.span,\n                         callee: NameAndSpan {\n-                            name: mname.to_string(),\n-                            format: MacroAttribute,\n+                            format: MacroAttribute(mname),\n                             span: Some(attr.span),\n                             // attributes can do whatever they like,\n                             // for now"}, {"sha": "d6974abd394f9bdaa9788b8c83b4912e26b51a60", "filename": "src/libsyntax/std_inject.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8dba06aeee28e9ed6a1b9918a91cbef242af53d3/src%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dba06aeee28e9ed6a1b9918a91cbef242af53d3/src%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fstd_inject.rs?ref=8dba06aeee28e9ed6a1b9918a91cbef242af53d3", "patch": "@@ -14,8 +14,7 @@ use codemap::{DUMMY_SP, Span, ExpnInfo, NameAndSpan, MacroAttribute};\n use codemap;\n use fold::Folder;\n use fold;\n-use parse::token::InternedString;\n-use parse::token::special_idents;\n+use parse::token::{intern, InternedString, special_idents};\n use parse::{token, ParseSess};\n use ptr::P;\n use util::small_vector::SmallVector;\n@@ -27,8 +26,7 @@ fn ignored_span(sess: &ParseSess, sp: Span) -> Span {\n     let info = ExpnInfo {\n         call_site: DUMMY_SP,\n         callee: NameAndSpan {\n-            name: \"std_inject\".to_string(),\n-            format: MacroAttribute,\n+            format: MacroAttribute(intern(\"std_inject\")),\n             span: None,\n             allow_internal_unstable: true,\n         }"}, {"sha": "7cd44e5fb4eff2d82a7fc1226fe9d6e8e5fac678", "filename": "src/libsyntax/test.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8dba06aeee28e9ed6a1b9918a91cbef242af53d3/src%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dba06aeee28e9ed6a1b9918a91cbef242af53d3/src%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ftest.rs?ref=8dba06aeee28e9ed6a1b9918a91cbef242af53d3", "patch": "@@ -32,7 +32,7 @@ use ext::expand::ExpansionConfig;\n use fold::{Folder, MoveMap};\n use fold;\n use owned_slice::OwnedSlice;\n-use parse::token::InternedString;\n+use parse::token::{intern, InternedString};\n use parse::{token, ParseSess};\n use print::pprust;\n use {ast, ast_util};\n@@ -298,8 +298,7 @@ fn generate_test_harness(sess: &ParseSess,\n     cx.ext_cx.bt_push(ExpnInfo {\n         call_site: DUMMY_SP,\n         callee: NameAndSpan {\n-            name: \"test\".to_string(),\n-            format: MacroAttribute,\n+            format: MacroAttribute(intern(\"test\")),\n             span: None,\n             allow_internal_unstable: false,\n         }\n@@ -331,8 +330,7 @@ fn ignored_span(cx: &TestCtxt, sp: Span) -> Span {\n     let info = ExpnInfo {\n         call_site: DUMMY_SP,\n         callee: NameAndSpan {\n-            name: \"test\".to_string(),\n-            format: MacroAttribute,\n+            format: MacroAttribute(intern(\"test\")),\n             span: None,\n             allow_internal_unstable: true,\n         }"}, {"sha": "6b9e7aa58f247ce9122ed5ff897a1407957a6f30", "filename": "src/rustbook/static/rustbook.css", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8dba06aeee28e9ed6a1b9918a91cbef242af53d3/src%2Frustbook%2Fstatic%2Frustbook.css", "raw_url": "https://github.com/rust-lang/rust/raw/8dba06aeee28e9ed6a1b9918a91cbef242af53d3/src%2Frustbook%2Fstatic%2Frustbook.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustbook%2Fstatic%2Frustbook.css?ref=8dba06aeee28e9ed6a1b9918a91cbef242af53d3", "patch": "@@ -27,7 +27,7 @@ h1, h2, h3, h4, h5, h6 {\n \n @media only screen {\n     #toc {\n-        position: absolute;\n+        position: fixed;\n         left: 0px;\n         top: 0px;\n         bottom: 0px;\n@@ -44,11 +44,9 @@ h1, h2, h3, h4, h5, h6 {\n \n     #page-wrapper {\n         position: absolute;\n-        overflow-y: auto;\n         left: 310px;\n         right: 0px;\n         top: 0px;\n-        bottom: 0px;\n         box-sizing: border-box;\n         background: none repeat scroll 0% 0% #FFF;\n         -webkit-overflow-scrolling: touch;"}, {"sha": "7ffbbe69c3d6bd503148d7d65a6cf5e2968d4922", "filename": "src/test/compile-fail-fulldeps/qquote.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8dba06aeee28e9ed6a1b9918a91cbef242af53d3/src%2Ftest%2Fcompile-fail-fulldeps%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dba06aeee28e9ed6a1b9918a91cbef242af53d3/src%2Ftest%2Fcompile-fail-fulldeps%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail-fulldeps%2Fqquote.rs?ref=8dba06aeee28e9ed6a1b9918a91cbef242af53d3", "patch": "@@ -27,8 +27,7 @@ fn main() {\n     cx.bt_push(syntax::codemap::ExpnInfo {\n         call_site: DUMMY_SP,\n         callee: syntax::codemap::NameAndSpan {\n-            name: \"\".to_string(),\n-            format: syntax::codemap::MacroBang,\n+            format: syntax::codemap::MacroBang(parse::token::intern(\"\")),\n             allow_internal_unstable: false,\n             span: None,\n         }"}, {"sha": "d42a777a019a30bd03d797aa7ae0f6eb981fa89f", "filename": "src/test/run-fail-fulldeps/qquote.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/8dba06aeee28e9ed6a1b9918a91cbef242af53d3/src%2Ftest%2Frun-fail-fulldeps%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dba06aeee28e9ed6a1b9918a91cbef242af53d3/src%2Ftest%2Frun-fail-fulldeps%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail-fulldeps%2Fqquote.rs?ref=8dba06aeee28e9ed6a1b9918a91cbef242af53d3", "patch": "@@ -31,8 +31,7 @@ fn main() {\n     cx.bt_push(syntax::codemap::ExpnInfo {\n         call_site: DUMMY_SP,\n         callee: syntax::codemap::NameAndSpan {\n-            name: \"\".to_string(),\n-            format: syntax::codemap::MacroBang,\n+            format: syntax::codemap::MacroBang(parse::token::intern(\"\")),\n             allow_internal_unstable: false,\n             span: None,\n         }"}, {"sha": "ba713bb98f8547a71e8728b08fe14f78ccc9a8e0", "filename": "src/test/run-pass-fulldeps/qquote.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8dba06aeee28e9ed6a1b9918a91cbef242af53d3/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dba06aeee28e9ed6a1b9918a91cbef242af53d3/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fqquote.rs?ref=8dba06aeee28e9ed6a1b9918a91cbef242af53d3", "patch": "@@ -16,6 +16,7 @@ extern crate syntax;\n \n use syntax::codemap::DUMMY_SP;\n use syntax::print::pprust::*;\n+use syntax::parse::token::intern;\n \n fn main() {\n     let ps = syntax::parse::ParseSess::new();\n@@ -27,8 +28,7 @@ fn main() {\n     cx.bt_push(syntax::codemap::ExpnInfo {\n         call_site: DUMMY_SP,\n         callee: syntax::codemap::NameAndSpan {\n-            name: \"\".to_string(),\n-            format: syntax::codemap::MacroBang,\n+            format: syntax::codemap::MacroBang(intern(\"\")),\n             allow_internal_unstable: false,\n             span: None,\n         }"}]}