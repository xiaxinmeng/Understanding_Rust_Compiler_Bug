{"sha": "c24844048ff023aeaf47080634507677ffbe7001", "node_id": "C_kwDOAAsO6NoAKGMyNDg0NDA0OGZmMDIzYWVhZjQ3MDgwNjM0NTA3Njc3ZmZiZTcwMDE", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-01-23T23:56:54Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2023-01-30T19:11:01Z"}, "message": "Trait upcasting support in new solver", "tree": {"sha": "3816ea32f8711c47c1fc41638a67652d2be89a41", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3816ea32f8711c47c1fc41638a67652d2be89a41"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c24844048ff023aeaf47080634507677ffbe7001", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c24844048ff023aeaf47080634507677ffbe7001", "html_url": "https://github.com/rust-lang/rust/commit/c24844048ff023aeaf47080634507677ffbe7001", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c24844048ff023aeaf47080634507677ffbe7001/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "085a48e7983d2b3b1f6d6fbeb127dd90b2a1377c", "url": "https://api.github.com/repos/rust-lang/rust/commits/085a48e7983d2b3b1f6d6fbeb127dd90b2a1377c", "html_url": "https://github.com/rust-lang/rust/commit/085a48e7983d2b3b1f6d6fbeb127dd90b2a1377c"}], "stats": {"total": 207, "additions": 148, "deletions": 59}, "files": [{"sha": "1c4e498c57e432e7a8d88c90c08c22eebfb312a9", "filename": "compiler/rustc_trait_selection/src/solve/assembly.rs", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/c24844048ff023aeaf47080634507677ffbe7001/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c24844048ff023aeaf47080634507677ffbe7001/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fassembly.rs?ref=c24844048ff023aeaf47080634507677ffbe7001", "patch": "@@ -174,13 +174,20 @@ pub(super) trait GoalKind<'tcx>: TypeFoldable<'tcx> + Copy + Eq {\n         goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx>;\n \n-    // Implement unsizing. The most common forms of unsizing are array to slice,\n-    // and concrete (Sized) type into a `dyn Trait`. ADTs and Tuples can also\n-    // have their final field unsized if it's generic.\n+    // The most common forms of unsizing are array to slice, and concrete (Sized)\n+    // type into a `dyn Trait`. ADTs and Tuples can also have their final field\n+    // unsized if it's generic.\n     fn consider_builtin_unsize_candidate(\n         ecx: &mut EvalCtxt<'_, 'tcx>,\n         goal: Goal<'tcx, Self>,\n     ) -> QueryResult<'tcx>;\n+\n+    // `dyn Trait1` can be unsized to `dyn Trait2` if they are the same trait, or\n+    // if `Trait2` is a (transitive) supertrait of `Trait2`.\n+    fn consider_builtin_dyn_unsize_candidates(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> Vec<CanonicalResponse<'tcx>>;\n }\n \n impl<'tcx> EvalCtxt<'_, 'tcx> {\n@@ -323,6 +330,14 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n             }\n             Err(NoSolution) => (),\n         }\n+\n+        // There may be multiple unsize candidates for a trait with several supertraits:\n+        // `trait Foo: Bar<A> + Bar<B>` and `dyn Foo: Unsize<dyn Bar<_>>`\n+        if lang_items.unsize_trait() == Some(trait_def_id) {\n+            for result in G::consider_builtin_dyn_unsize_candidates(self, goal) {\n+                candidates.push(Candidate { source: CandidateSource::BuiltinImpl, result });\n+            }\n+        }\n     }\n \n     fn assemble_param_env_candidates<G: GoalKind<'tcx>>("}, {"sha": "f9506446aba6d3a99f0dd74e4f3f6ac95dc96547", "filename": "compiler/rustc_trait_selection/src/solve/project_goals.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/c24844048ff023aeaf47080634507677ffbe7001/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c24844048ff023aeaf47080634507677ffbe7001/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fproject_goals.rs?ref=c24844048ff023aeaf47080634507677ffbe7001", "patch": "@@ -561,6 +561,13 @@ impl<'tcx> assembly::GoalKind<'tcx> for ProjectionPredicate<'tcx> {\n     ) -> QueryResult<'tcx> {\n         bug!(\"`Unsize` does not have an associated type: {:?}\", goal);\n     }\n+\n+    fn consider_builtin_dyn_unsize_candidates(\n+        _ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> Vec<super::CanonicalResponse<'tcx>> {\n+        bug!(\"`Unsize` does not have an associated type: {:?}\", goal);\n+    }\n }\n \n /// This behavior is also implemented in `rustc_ty_utils` and in the old `project` code."}, {"sha": "c79f1f055122ae8a05542ffa7fa97447f706d459", "filename": "compiler/rustc_trait_selection/src/solve/trait_goals.rs", "status": "modified", "additions": 82, "deletions": 56, "changes": 138, "blob_url": "https://github.com/rust-lang/rust/blob/c24844048ff023aeaf47080634507677ffbe7001/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c24844048ff023aeaf47080634507677ffbe7001/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ftrait_goals.rs?ref=c24844048ff023aeaf47080634507677ffbe7001", "patch": "@@ -4,7 +4,7 @@ use std::iter;\n \n use super::assembly::{self, Candidate, CandidateSource};\n use super::infcx_ext::InferCtxtExt;\n-use super::{Certainty, EvalCtxt, Goal, QueryResult};\n+use super::{CanonicalResponse, Certainty, EvalCtxt, Goal, QueryResult};\n use rustc_hir::def_id::DefId;\n use rustc_infer::infer::InferCtxt;\n use rustc_infer::traits::query::NoSolution;\n@@ -253,57 +253,11 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n         ecx.infcx.probe(|_| {\n             match (a_ty.kind(), b_ty.kind()) {\n                 // Trait upcasting, or `dyn Trait + Auto + 'a` -> `dyn Trait + 'b`\n-                (\n-                    &ty::Dynamic(a_data, a_region, ty::Dyn),\n-                    &ty::Dynamic(b_data, b_region, ty::Dyn),\n-                ) => {\n-                    // All of a's auto traits need to be in b's auto traits.\n-                    let auto_traits_compatible = b_data\n-                        .auto_traits()\n-                        .all(|b| a_data.auto_traits().any(|a| a == b));\n-                    if !auto_traits_compatible {\n-                        return Err(NoSolution);\n-                    }\n-\n-                    // If the principal def ids match (or are both none), then we're not doing\n-                    // trait upcasting. We're just removing auto traits (or shortening the lifetime).\n-                    if a_data.principal_def_id() == b_data.principal_def_id() {\n-                        // Require that all of the trait predicates from A match B, except for\n-                        // the auto traits. We do this by constructing a new A type with B's\n-                        // auto traits, and equating these types.\n-                        let new_a_data = a_data\n-                            .iter()\n-                            .filter(|a| {\n-                                matches!(\n-                                    a.skip_binder(),\n-                                    ty::ExistentialPredicate::Trait(_) | ty::ExistentialPredicate::Projection(_)\n-                                )\n-                            })\n-                            .chain(\n-                                b_data\n-                                    .auto_traits()\n-                                    .map(ty::ExistentialPredicate::AutoTrait)\n-                                    .map(ty::Binder::dummy),\n-                            );\n-                        let new_a_data = tcx.mk_poly_existential_predicates(new_a_data);\n-                        let new_a_ty = tcx.mk_dynamic(new_a_data, b_region, ty::Dyn);\n-\n-                        // We also require that A's lifetime outlives B's lifetime.\n-                        let mut nested_obligations = ecx.infcx.eq(goal.param_env, new_a_ty, b_ty)?;\n-                        nested_obligations.push(goal.with(tcx, ty::Binder::dummy(ty::OutlivesPredicate(a_region, b_region))));\n-\n-                        ecx.evaluate_all_and_make_canonical_response(nested_obligations)\n-                    } else if let Some(a_principal) = a_data.principal()\n-                        && let Some(b_principal) = b_data.principal()\n-                        && supertraits(tcx, a_principal.with_self_ty(tcx, a_ty))\n-                            .any(|trait_ref| trait_ref.def_id() == b_principal.def_id())\n-                    {\n-                        // FIXME: Intentionally ignoring `need_migrate_deref_output_trait_object` here for now.\n-                        // Confirm upcasting candidate\n-                        todo!()\n-                    } else {\n-                        Err(NoSolution)\n-                    }\n+                (&ty::Dynamic(_, _, ty::Dyn), &ty::Dynamic(_, _, ty::Dyn)) => {\n+                    // Dyn upcasting is handled separately, since due to upcasting,\n+                    // when there are two supertraits that differ by substs, we\n+                    // may return more than one query response.\n+                    return Err(NoSolution);\n                 }\n                 // `T` -> `dyn Trait` unsizing\n                 (_, &ty::Dynamic(data, region, ty::Dyn)) => {\n@@ -332,10 +286,7 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n                                 ty::Binder::dummy(tcx.mk_trait_ref(sized_def_id, [a_ty])),\n                             ),\n                             // The type must outlive the lifetime of the `dyn` we're unsizing into.\n-                            goal.with(\n-                                tcx,\n-                                ty::Binder::dummy(ty::OutlivesPredicate(a_ty, region)),\n-                            ),\n+                            goal.with(tcx, ty::Binder::dummy(ty::OutlivesPredicate(a_ty, region))),\n                         ])\n                         .collect();\n \n@@ -413,6 +364,81 @@ impl<'tcx> assembly::GoalKind<'tcx> for TraitPredicate<'tcx> {\n             }\n         })\n     }\n+\n+    fn consider_builtin_dyn_unsize_candidates(\n+        ecx: &mut EvalCtxt<'_, 'tcx>,\n+        goal: Goal<'tcx, Self>,\n+    ) -> Vec<CanonicalResponse<'tcx>> {\n+        let tcx = ecx.tcx();\n+\n+        let a_ty = goal.predicate.self_ty();\n+        let b_ty = goal.predicate.trait_ref.substs.type_at(1);\n+        let ty::Dynamic(a_data, a_region, ty::Dyn) = *a_ty.kind() else {\n+            return vec![];\n+        };\n+        let ty::Dynamic(b_data, b_region, ty::Dyn) = *b_ty.kind() else {\n+            return vec![];\n+        };\n+\n+        // All of a's auto traits need to be in b's auto traits.\n+        let auto_traits_compatible =\n+            b_data.auto_traits().all(|b| a_data.auto_traits().any(|a| a == b));\n+        if !auto_traits_compatible {\n+            return vec![];\n+        }\n+\n+        let mut responses = vec![];\n+        let mut unsize_dyn_to_principal = |principal: Option<ty::PolyExistentialTraitRef<'tcx>>| {\n+            let _ = ecx.infcx.probe(|_| -> Result<(), NoSolution> {\n+                // Require that all of the trait predicates from A match B, except for\n+                // the auto traits. We do this by constructing a new A type with B's\n+                // auto traits, and equating these types.\n+                let new_a_data = principal\n+                    .into_iter()\n+                    .map(|trait_ref| trait_ref.map_bound(ty::ExistentialPredicate::Trait))\n+                    .chain(a_data.iter().filter(|a| {\n+                        matches!(a.skip_binder(), ty::ExistentialPredicate::Projection(_))\n+                    }))\n+                    .chain(\n+                        b_data\n+                            .auto_traits()\n+                            .map(ty::ExistentialPredicate::AutoTrait)\n+                            .map(ty::Binder::dummy),\n+                    );\n+                let new_a_data = tcx.mk_poly_existential_predicates(new_a_data);\n+                let new_a_ty = tcx.mk_dynamic(new_a_data, b_region, ty::Dyn);\n+\n+                // We also require that A's lifetime outlives B's lifetime.\n+                let mut nested_obligations = ecx.infcx.eq(goal.param_env, new_a_ty, b_ty)?;\n+                nested_obligations.push(\n+                    goal.with(tcx, ty::Binder::dummy(ty::OutlivesPredicate(a_region, b_region))),\n+                );\n+\n+                responses.push(ecx.evaluate_all_and_make_canonical_response(nested_obligations)?);\n+\n+                Ok(())\n+            });\n+        };\n+\n+        // If the principal def ids match (or are both none), then we're not doing\n+        // trait upcasting. We're just removing auto traits (or shortening the lifetime).\n+        if a_data.principal_def_id() == b_data.principal_def_id() {\n+            unsize_dyn_to_principal(a_data.principal());\n+        } else if let Some(a_principal) = a_data.principal()\n+            && let Some(b_principal) = b_data.principal()\n+        {\n+            for super_trait_ref in supertraits(tcx, a_principal.with_self_ty(tcx, a_ty)) {\n+                if super_trait_ref.def_id() != b_principal.def_id() {\n+                    continue;\n+                }\n+                let erased_trait_ref = super_trait_ref\n+                    .map_bound(|trait_ref| ty::ExistentialTraitRef::erase_self_ty(tcx, trait_ref));\n+                unsize_dyn_to_principal(Some(erased_trait_ref));\n+            }\n+        }\n+\n+        responses\n+    }\n }\n \n impl<'tcx> EvalCtxt<'_, 'tcx> {"}, {"sha": "c19c82acf24ffd690b2cd9b23ccc8d29f2a7af49", "filename": "tests/ui/traits/new-solver/upcast-right-substs.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c24844048ff023aeaf47080634507677ffbe7001/tests%2Fui%2Ftraits%2Fnew-solver%2Fupcast-right-substs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c24844048ff023aeaf47080634507677ffbe7001/tests%2Fui%2Ftraits%2Fnew-solver%2Fupcast-right-substs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Fupcast-right-substs.rs?ref=c24844048ff023aeaf47080634507677ffbe7001", "patch": "@@ -0,0 +1,14 @@\n+// compile-flags: -Ztrait-solver=next\n+// check-pass\n+\n+#![feature(trait_upcasting)]\n+\n+trait Foo: Bar<i32> + Bar<u32> {}\n+\n+trait Bar<T> {}\n+\n+fn main() {\n+    let x: &dyn Foo = todo!();\n+    let y: &dyn Bar<i32> = x;\n+    let z: &dyn Bar<u32> = x;\n+}"}, {"sha": "f2d04d932bbcbf9efb6b3f8aa6b4e5c4927673aa", "filename": "tests/ui/traits/new-solver/upcast-wrong-substs.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/c24844048ff023aeaf47080634507677ffbe7001/tests%2Fui%2Ftraits%2Fnew-solver%2Fupcast-wrong-substs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c24844048ff023aeaf47080634507677ffbe7001/tests%2Fui%2Ftraits%2Fnew-solver%2Fupcast-wrong-substs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Fupcast-wrong-substs.rs?ref=c24844048ff023aeaf47080634507677ffbe7001", "patch": "@@ -0,0 +1,13 @@\n+// compile-flags: -Ztrait-solver=next\n+\n+#![feature(trait_upcasting)]\n+\n+trait Foo: Bar<i32> + Bar<u32> {}\n+\n+trait Bar<T> {}\n+\n+fn main() {\n+    let x: &dyn Foo = todo!();\n+    let y: &dyn Bar<usize> = x;\n+    //~^ ERROR mismatched types\n+}"}, {"sha": "8623f395f5978e8b71d29571f623a2203bc86870", "filename": "tests/ui/traits/new-solver/upcast-wrong-substs.stderr", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/c24844048ff023aeaf47080634507677ffbe7001/tests%2Fui%2Ftraits%2Fnew-solver%2Fupcast-wrong-substs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/c24844048ff023aeaf47080634507677ffbe7001/tests%2Fui%2Ftraits%2Fnew-solver%2Fupcast-wrong-substs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Fupcast-wrong-substs.stderr?ref=c24844048ff023aeaf47080634507677ffbe7001", "patch": "@@ -0,0 +1,14 @@\n+error[E0308]: mismatched types\n+  --> $DIR/upcast-wrong-substs.rs:11:30\n+   |\n+LL |     let y: &dyn Bar<usize> = x;\n+   |            ---------------   ^ expected trait `Bar`, found trait `Foo`\n+   |            |\n+   |            expected due to this\n+   |\n+   = note: expected reference `&dyn Bar<usize>`\n+              found reference `&dyn Foo`\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0308`."}]}