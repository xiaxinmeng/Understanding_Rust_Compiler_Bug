{"sha": "c836c24994f0113effd0409d8d063b4f4e68f5b6", "node_id": "C_kwDOAAsO6NoAKGM4MzZjMjQ5OTRmMDExM2VmZmQwNDA5ZDhkMDYzYjRmNGU2OGY1YjY", "commit": {"author": {"name": "Josh Stone", "email": "jistone@redhat.com", "date": "2023-05-05T00:20:49Z"}, "committer": {"name": "Josh Stone", "email": "jistone@redhat.com", "date": "2023-05-08T17:34:15Z"}, "message": "Remove the ThinLTO CU hack\n\nThis reverts #46722, commit e0ab5d5feb4eb2d8af11b8dd9446c2b45fada8af.\n\nSince #111167, commit 10b69dde3fd15334ea2382d2dc9e9a261de1afaf, we are\ngenerating DWARF subprograms in a way that is meant to be more compatible\nwith LLVM's expectations, so hopefully we don't need this workaround\nrewriting CUs anymore.", "tree": {"sha": "98adc471f646fdd5cac81949bb2de89fa0f99986", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/98adc471f646fdd5cac81949bb2de89fa0f99986"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c836c24994f0113effd0409d8d063b4f4e68f5b6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c836c24994f0113effd0409d8d063b4f4e68f5b6", "html_url": "https://github.com/rust-lang/rust/commit/c836c24994f0113effd0409d8d063b4f4e68f5b6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c836c24994f0113effd0409d8d063b4f4e68f5b6/comments", "author": {"login": "cuviper", "id": 36186, "node_id": "MDQ6VXNlcjM2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/36186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cuviper", "html_url": "https://github.com/cuviper", "followers_url": "https://api.github.com/users/cuviper/followers", "following_url": "https://api.github.com/users/cuviper/following{/other_user}", "gists_url": "https://api.github.com/users/cuviper/gists{/gist_id}", "starred_url": "https://api.github.com/users/cuviper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cuviper/subscriptions", "organizations_url": "https://api.github.com/users/cuviper/orgs", "repos_url": "https://api.github.com/users/cuviper/repos", "events_url": "https://api.github.com/users/cuviper/events{/privacy}", "received_events_url": "https://api.github.com/users/cuviper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cuviper", "id": 36186, "node_id": "MDQ6VXNlcjM2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/36186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cuviper", "html_url": "https://github.com/cuviper", "followers_url": "https://api.github.com/users/cuviper/followers", "following_url": "https://api.github.com/users/cuviper/following{/other_user}", "gists_url": "https://api.github.com/users/cuviper/gists{/gist_id}", "starred_url": "https://api.github.com/users/cuviper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cuviper/subscriptions", "organizations_url": "https://api.github.com/users/cuviper/orgs", "repos_url": "https://api.github.com/users/cuviper/repos", "events_url": "https://api.github.com/users/cuviper/events{/privacy}", "received_events_url": "https://api.github.com/users/cuviper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ce042889f7f0d687368a9704eff64cf9542bac6d", "url": "https://api.github.com/repos/rust-lang/rust/commits/ce042889f7f0d687368a9704eff64cf9542bac6d", "html_url": "https://github.com/rust-lang/rust/commit/ce042889f7f0d687368a9704eff64cf9542bac6d"}], "stats": {"total": 112, "additions": 0, "deletions": 112}, "files": [{"sha": "604f68eb6a47e06735ba1d2cedf1426332023564", "filename": "compiler/rustc_codegen_llvm/src/back/lto.rs", "status": "modified", "additions": 0, "deletions": 49, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/c836c24994f0113effd0409d8d063b4f4e68f5b6/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c836c24994f0113effd0409d8d063b4f4e68f5b6/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fback%2Flto.rs?ref=c836c24994f0113effd0409d8d063b4f4e68f5b6", "patch": "@@ -25,7 +25,6 @@ use std::fs::File;\n use std::io;\n use std::iter;\n use std::path::Path;\n-use std::ptr;\n use std::slice;\n use std::sync::Arc;\n \n@@ -709,17 +708,6 @@ pub unsafe fn optimize_thin_module(\n         let llmod = module.module_llvm.llmod();\n         save_temp_bitcode(cgcx, &module, \"thin-lto-input\");\n \n-        // Before we do much else find the \"main\" `DICompileUnit` that we'll be\n-        // using below. If we find more than one though then rustc has changed\n-        // in a way we're not ready for, so generate an ICE by returning\n-        // an error.\n-        let mut cu1 = ptr::null_mut();\n-        let mut cu2 = ptr::null_mut();\n-        llvm::LLVMRustThinLTOGetDICompileUnit(llmod, &mut cu1, &mut cu2);\n-        if !cu2.is_null() {\n-            return Err(write::llvm_err(&diag_handler, LlvmError::MultipleSourceDiCompileUnit));\n-        }\n-\n         // Up next comes the per-module local analyses that we do for Thin LTO.\n         // Each of these functions is basically copied from the LLVM\n         // implementation and then tailored to suit this implementation. Ideally\n@@ -766,43 +754,6 @@ pub unsafe fn optimize_thin_module(\n             save_temp_bitcode(cgcx, &module, \"thin-lto-after-import\");\n         }\n \n-        // Ok now this is a bit unfortunate. This is also something you won't\n-        // find upstream in LLVM's ThinLTO passes! This is a hack for now to\n-        // work around bugs in LLVM.\n-        //\n-        // First discovered in #45511 it was found that as part of ThinLTO\n-        // importing passes LLVM will import `DICompileUnit` metadata\n-        // information across modules. This means that we'll be working with one\n-        // LLVM module that has multiple `DICompileUnit` instances in it (a\n-        // bunch of `llvm.dbg.cu` members). Unfortunately there's a number of\n-        // bugs in LLVM's backend which generates invalid DWARF in a situation\n-        // like this:\n-        //\n-        //  https://bugs.llvm.org/show_bug.cgi?id=35212\n-        //  https://bugs.llvm.org/show_bug.cgi?id=35562\n-        //\n-        // While the first bug there is fixed the second ended up causing #46346\n-        // which was basically a resurgence of #45511 after LLVM's bug 35212 was\n-        // fixed.\n-        //\n-        // This function below is a huge hack around this problem. The function\n-        // below is defined in `PassWrapper.cpp` and will basically \"merge\"\n-        // all `DICompileUnit` instances in a module. Basically it'll take all\n-        // the objects, rewrite all pointers of `DISubprogram` to point to the\n-        // first `DICompileUnit`, and then delete all the other units.\n-        //\n-        // This is probably mangling to the debug info slightly (but hopefully\n-        // not too much) but for now at least gets LLVM to emit valid DWARF (or\n-        // so it appears). Hopefully we can remove this once upstream bugs are\n-        // fixed in LLVM.\n-        {\n-            let _timer = cgcx\n-                .prof\n-                .generic_activity_with_arg(\"LLVM_thin_lto_patch_debuginfo\", thin_module.name());\n-            llvm::LLVMRustThinLTOPatchDICompileUnit(llmod, cu1);\n-            save_temp_bitcode(cgcx, &module, \"thin-lto-after-patch\");\n-        }\n-\n         // Alright now that we've done everything related to the ThinLTO\n         // analysis it's time to run some optimizations! Here we use the same\n         // `run_pass_manager` as the \"fat\" LTO above except that we tell it to"}, {"sha": "d5be678c1bb1fe12615fbced18ba67091206eb66", "filename": "compiler/rustc_codegen_llvm/src/llvm/ffi.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c836c24994f0113effd0409d8d063b4f4e68f5b6/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c836c24994f0113effd0409d8d063b4f4e68f5b6/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fllvm%2Fffi.rs?ref=c836c24994f0113effd0409d8d063b4f4e68f5b6", "patch": "@@ -2480,12 +2480,6 @@ extern \"C\" {\n         len: usize,\n         out_len: &mut usize,\n     ) -> *const u8;\n-    pub fn LLVMRustThinLTOGetDICompileUnit(\n-        M: &Module,\n-        CU1: &mut *mut c_void,\n-        CU2: &mut *mut c_void,\n-    );\n-    pub fn LLVMRustThinLTOPatchDICompileUnit(M: &Module, CU: *mut c_void);\n \n     pub fn LLVMRustLinkerNew(M: &Module) -> &mut Linker<'_>;\n     pub fn LLVMRustLinkerAdd("}, {"sha": "fc28f6efa4478fa3110fb0810d6271ad2c895130", "filename": "compiler/rustc_llvm/llvm-wrapper/PassWrapper.cpp", "status": "modified", "additions": 0, "deletions": 57, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/c836c24994f0113effd0409d8d063b4f4e68f5b6/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/c836c24994f0113effd0409d8d063b4f4e68f5b6/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FPassWrapper.cpp?ref=c836c24994f0113effd0409d8d063b4f4e68f5b6", "patch": "@@ -1460,63 +1460,6 @@ LLVMRustGetBitcodeSliceFromObjectData(const char *data,\n   return BitcodeOrError->getBufferStart();\n }\n \n-// Rewrite all `DICompileUnit` pointers to the `DICompileUnit` specified. See\n-// the comment in `back/lto.rs` for why this exists.\n-extern \"C\" void\n-LLVMRustThinLTOGetDICompileUnit(LLVMModuleRef Mod,\n-                                DICompileUnit **A,\n-                                DICompileUnit **B) {\n-  Module *M = unwrap(Mod);\n-  DICompileUnit **Cur = A;\n-  DICompileUnit **Next = B;\n-  for (DICompileUnit *CU : M->debug_compile_units()) {\n-    *Cur = CU;\n-    Cur = Next;\n-    Next = nullptr;\n-    if (Cur == nullptr)\n-      break;\n-  }\n-}\n-\n-// Rewrite all `DICompileUnit` pointers to the `DICompileUnit` specified. See\n-// the comment in `back/lto.rs` for why this exists.\n-extern \"C\" void\n-LLVMRustThinLTOPatchDICompileUnit(LLVMModuleRef Mod, DICompileUnit *Unit) {\n-  Module *M = unwrap(Mod);\n-\n-  // If the original source module didn't have a `DICompileUnit` then try to\n-  // merge all the existing compile units. If there aren't actually any though\n-  // then there's not much for us to do so return.\n-  if (Unit == nullptr) {\n-    for (DICompileUnit *CU : M->debug_compile_units()) {\n-      Unit = CU;\n-      break;\n-    }\n-    if (Unit == nullptr)\n-      return;\n-  }\n-\n-  // Use LLVM's built-in `DebugInfoFinder` to find a bunch of debuginfo and\n-  // process it recursively. Note that we used to specifically iterate over\n-  // instructions to ensure we feed everything into it, but `processModule`\n-  // started doing this the same way in LLVM 7 (commit d769eb36ab2b8).\n-  DebugInfoFinder Finder;\n-  Finder.processModule(*M);\n-\n-  // After we've found all our debuginfo, rewrite all subprograms to point to\n-  // the same `DICompileUnit`.\n-  for (auto &F : Finder.subprograms()) {\n-    F->replaceUnit(Unit);\n-  }\n-\n-  // Erase any other references to other `DICompileUnit` instances, the verifier\n-  // will later ensure that we don't actually have any other stale references to\n-  // worry about.\n-  auto *MD = M->getNamedMetadata(\"llvm.dbg.cu\");\n-  MD->clearOperands();\n-  MD->addOperand(Unit);\n-}\n-\n // Computes the LTO cache key for the provided 'ModId' in the given 'Data',\n // storing the result in 'KeyOut'.\n // Currently, this cache key is a SHA-1 hash of anything that could affect"}]}