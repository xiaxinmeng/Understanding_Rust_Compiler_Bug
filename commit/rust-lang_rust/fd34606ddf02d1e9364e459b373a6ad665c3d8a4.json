{"sha": "fd34606ddf02d1e9364e459b373a6ad665c3d8a4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZkMzQ2MDZkZGYwMmQxZTkzNjRlNDU5YjM3M2E2YWQ2NjVjM2Q4YTQ=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-01-10T10:48:55Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-01-10T10:48:55Z"}, "message": "Auto merge of #80391 - ssomers:btree_cleanup_slices_3, r=Mark-Simulacrum\n\nBTreeMap: tougher checking on most uses of copy_nonoverlapping\n\nMiri checks pointer provenance and destination, but we can check it in debug builds already.\nAlso, we can let Miri confirm we don't mistake imprints of moved keys and values as genuine.\nr? `@Mark-Simulacrum`", "tree": {"sha": "a546fa4592e9a006be840f815165d21645fd4395", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a546fa4592e9a006be840f815165d21645fd4395"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fd34606ddf02d1e9364e459b373a6ad665c3d8a4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fd34606ddf02d1e9364e459b373a6ad665c3d8a4", "html_url": "https://github.com/rust-lang/rust/commit/fd34606ddf02d1e9364e459b373a6ad665c3d8a4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fd34606ddf02d1e9364e459b373a6ad665c3d8a4/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "34628e5b533d35840b61c5db0665cf7633ed3c5a", "url": "https://api.github.com/repos/rust-lang/rust/commits/34628e5b533d35840b61c5db0665cf7633ed3c5a", "html_url": "https://github.com/rust-lang/rust/commit/34628e5b533d35840b61c5db0665cf7633ed3c5a"}, {"sha": "26b94626a13a1deb6363163c3987dad51c397f06", "url": "https://api.github.com/repos/rust-lang/rust/commits/26b94626a13a1deb6363163c3987dad51c397f06", "html_url": "https://github.com/rust-lang/rust/commit/26b94626a13a1deb6363163c3987dad51c397f06"}], "stats": {"total": 58, "additions": 32, "deletions": 26}, "files": [{"sha": "bef6850f06f9555b39cf8f64920e49e5cafc2ad9", "filename": "library/alloc/src/collections/btree/node.rs", "status": "modified", "additions": 32, "deletions": 26, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/fd34606ddf02d1e9364e459b373a6ad665c3d8a4/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fd34606ddf02d1e9364e459b373a6ad665c3d8a4/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Fbtree%2Fnode.rs?ref=fd34606ddf02d1e9364e459b373a6ad665c3d8a4", "patch": "@@ -1124,21 +1124,20 @@ impl<'a, K: 'a, V: 'a, NodeType> Handle<NodeRef<marker::Mut<'a>, K, V, NodeType>\n     /// by taking care of leaf data.\n     fn split_leaf_data(&mut self, new_node: &mut LeafNode<K, V>) -> (K, V) {\n         debug_assert!(self.idx < self.node.len());\n-        let new_len = self.node.len() - self.idx - 1;\n+        let old_len = self.node.len();\n+        let new_len = old_len - self.idx - 1;\n         new_node.len = new_len as u16;\n         unsafe {\n             let k = self.node.key_area_mut(self.idx).assume_init_read();\n             let v = self.node.val_area_mut(self.idx).assume_init_read();\n \n-            ptr::copy_nonoverlapping(\n-                self.node.key_area_mut(self.idx + 1..).as_ptr(),\n-                new_node.keys.as_mut_ptr(),\n-                new_len,\n+            move_to_slice(\n+                self.node.key_area_mut(self.idx + 1..old_len),\n+                &mut new_node.keys[..new_len],\n             );\n-            ptr::copy_nonoverlapping(\n-                self.node.val_area_mut(self.idx + 1..).as_ptr(),\n-                new_node.vals.as_mut_ptr(),\n-                new_len,\n+            move_to_slice(\n+                self.node.val_area_mut(self.idx + 1..old_len),\n+                &mut new_node.vals[..new_len],\n             );\n \n             *self.node.len_mut() = self.idx as u16;\n@@ -1190,20 +1189,20 @@ impl<'a, K: 'a, V: 'a> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>,\n     /// - All the edges and key-value pairs to the right of this handle are put into\n     ///   a newly allocated node.\n     pub fn split(mut self) -> SplitResult<'a, K, V, marker::Internal> {\n+        let old_len = self.node.len();\n         unsafe {\n             let mut new_node = Box::new(InternalNode::new());\n             let kv = self.split_leaf_data(&mut new_node.data);\n             let new_len = usize::from(new_node.data.len);\n-            ptr::copy_nonoverlapping(\n-                self.node.edge_area_mut(self.idx + 1..).as_ptr(),\n-                new_node.edges.as_mut_ptr(),\n-                new_len + 1,\n+            move_to_slice(\n+                self.node.edge_area_mut(self.idx + 1..old_len + 1),\n+                &mut new_node.edges[..new_len + 1],\n             );\n \n             let height = self.node.height;\n             let mut right = NodeRef::from_new_internal(new_node, height);\n \n-            right.borrow_mut().correct_childrens_parent_links(0..=new_len);\n+            right.borrow_mut().correct_childrens_parent_links(0..new_len + 1);\n \n             SplitResult { left: self.node, kv, right }\n         }\n@@ -1323,18 +1322,16 @@ impl<'a, K: 'a, V: 'a> BalancingContext<'a, K, V> {\n \n             let parent_key = slice_remove(parent_node.key_area_mut(..old_parent_len), parent_idx);\n             left_node.key_area_mut(old_left_len).write(parent_key);\n-            ptr::copy_nonoverlapping(\n-                right_node.key_area_mut(..).as_ptr(),\n-                left_node.key_area_mut(old_left_len + 1..).as_mut_ptr(),\n-                right_len,\n+            move_to_slice(\n+                right_node.key_area_mut(..right_len),\n+                left_node.key_area_mut(old_left_len + 1..new_left_len),\n             );\n \n             let parent_val = slice_remove(parent_node.val_area_mut(..old_parent_len), parent_idx);\n             left_node.val_area_mut(old_left_len).write(parent_val);\n-            ptr::copy_nonoverlapping(\n-                right_node.val_area_mut(..).as_ptr(),\n-                left_node.val_area_mut(old_left_len + 1..).as_mut_ptr(),\n-                right_len,\n+            move_to_slice(\n+                right_node.val_area_mut(..right_len),\n+                left_node.val_area_mut(old_left_len + 1..new_left_len),\n             );\n \n             slice_remove(&mut parent_node.edge_area_mut(..old_parent_len + 1), parent_idx + 1);\n@@ -1346,10 +1343,9 @@ impl<'a, K: 'a, V: 'a> BalancingContext<'a, K, V> {\n                 // of the node of this edge, thus above zero, so they are internal.\n                 let mut left_node = left_node.reborrow_mut().cast_to_internal_unchecked();\n                 let mut right_node = right_node.cast_to_internal_unchecked();\n-                ptr::copy_nonoverlapping(\n-                    right_node.edge_area_mut(..).as_ptr(),\n-                    left_node.edge_area_mut(old_left_len + 1..).as_mut_ptr(),\n-                    right_len + 1,\n+                move_to_slice(\n+                    right_node.edge_area_mut(..right_len + 1),\n+                    left_node.edge_area_mut(old_left_len + 1..new_left_len + 1),\n                 );\n \n                 left_node.correct_childrens_parent_links(old_left_len + 1..new_left_len + 1);\n@@ -1741,5 +1737,15 @@ unsafe fn slice_remove<T>(slice: &mut [MaybeUninit<T>], idx: usize) -> T {\n     }\n }\n \n+/// Moves all values from a slice of initialized elements to a slice\n+/// of uninitialized elements, leaving behind `src` as all uninitialized.\n+/// Works like `dst.copy_from_slice(src)` but does not require `T` to be `Copy`.\n+fn move_to_slice<T>(src: &mut [MaybeUninit<T>], dst: &mut [MaybeUninit<T>]) {\n+    assert!(src.len() == dst.len());\n+    unsafe {\n+        ptr::copy_nonoverlapping(src.as_ptr(), dst.as_mut_ptr(), src.len());\n+    }\n+}\n+\n #[cfg(test)]\n mod tests;"}]}