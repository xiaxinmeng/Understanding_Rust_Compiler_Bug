{"sha": "053ccf4121797e4e559e3225d46d3f23cb1ad70b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA1M2NjZjQxMjE3OTdlNGU1NTllMzIyNWQ0NmQzZjIzY2IxYWQ3MGI=", "commit": {"author": {"name": "Veetaha", "email": "gerzoh1@gmail.com", "date": "2020-02-18T00:11:16Z"}, "committer": {"name": "Veetaha", "email": "gerzoh1@gmail.com", "date": "2020-02-18T00:11:16Z"}, "message": "ra_syntax: fix reparsing merging errors, also now reparse_token() reports errors", "tree": {"sha": "8037fccd14a1d8961d3996af9276484cb617e472", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8037fccd14a1d8961d3996af9276484cb617e472"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/053ccf4121797e4e559e3225d46d3f23cb1ad70b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/053ccf4121797e4e559e3225d46d3f23cb1ad70b", "html_url": "https://github.com/rust-lang/rust/commit/053ccf4121797e4e559e3225d46d3f23cb1ad70b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/053ccf4121797e4e559e3225d46d3f23cb1ad70b/comments", "author": null, "committer": null, "parents": [{"sha": "fc5e7b8807f6d438028389b030dfae00965a8cd5", "url": "https://api.github.com/repos/rust-lang/rust/commits/fc5e7b8807f6d438028389b030dfae00965a8cd5", "html_url": "https://github.com/rust-lang/rust/commit/fc5e7b8807f6d438028389b030dfae00965a8cd5"}], "stats": {"total": 57, "additions": 50, "deletions": 7}, "files": [{"sha": "aad70d0151a151226bab12d95470dcd8eeb7b7bb", "filename": "crates/ra_syntax/src/parsing/reparsing.rs", "status": "modified", "additions": 50, "deletions": 7, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/053ccf4121797e4e559e3225d46d3f23cb1ad70b/crates%2Fra_syntax%2Fsrc%2Fparsing%2Freparsing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/053ccf4121797e4e559e3225d46d3f23cb1ad70b/crates%2Fra_syntax%2Fsrc%2Fparsing%2Freparsing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fparsing%2Freparsing.rs?ref=053ccf4121797e4e559e3225d46d3f23cb1ad70b", "patch": "@@ -27,8 +27,8 @@ pub(crate) fn incremental_reparse(\n     edit: &AtomTextEdit,\n     errors: Vec<SyntaxError>,\n ) -> Option<(GreenNode, Vec<SyntaxError>, TextRange)> {\n-    if let Some((green, old_range)) = reparse_token(node, &edit) {\n-        return Some((green, merge_errors(errors, Vec::new(), old_range, edit), old_range));\n+    if let Some((green, new_errors, old_range)) = reparse_token(node, &edit) {\n+        return Some((green, merge_errors(errors, new_errors, old_range, edit), old_range));\n     }\n \n     if let Some((green, new_errors, old_range)) = reparse_block(node, &edit) {\n@@ -40,7 +40,7 @@ pub(crate) fn incremental_reparse(\n fn reparse_token<'node>(\n     root: &'node SyntaxNode,\n     edit: &AtomTextEdit,\n-) -> Option<(GreenNode, TextRange)> {\n+) -> Option<(GreenNode, Vec<SyntaxError>, TextRange)> {\n     let prev_token = algo::find_covering_element(root, edit.delete).as_token()?.clone();\n     let prev_token_kind = prev_token.kind();\n     match prev_token_kind {\n@@ -54,7 +54,7 @@ fn reparse_token<'node>(\n             }\n \n             let mut new_text = get_text_after_edit(prev_token.clone().into(), &edit);\n-            let (new_token_kind, _error) = lex_single_syntax_kind(&new_text)?;\n+            let (new_token_kind, new_err) = lex_single_syntax_kind(&new_text)?;\n \n             if new_token_kind != prev_token_kind\n                 || (new_token_kind == IDENT && is_contextual_kw(&new_text))\n@@ -76,7 +76,11 @@ fn reparse_token<'node>(\n \n             let new_token =\n                 GreenToken::new(rowan::SyntaxKind(prev_token_kind.into()), new_text.into());\n-            Some((prev_token.replace_with(new_token), prev_token.text_range()))\n+            Some((\n+                prev_token.replace_with(new_token),\n+                new_err.into_iter().collect(),\n+                prev_token.text_range(),\n+            ))\n         }\n         _ => None,\n     }\n@@ -200,9 +204,9 @@ mod tests {\n \n         let fully_reparsed = SourceFile::parse(&after);\n         let incrementally_reparsed: Parse<SourceFile> = {\n-            let f = SourceFile::parse(&before);\n+            let before = SourceFile::parse(&before);\n             let (green, new_errors, range) =\n-                incremental_reparse(f.tree().syntax(), &edit, f.errors.to_vec()).unwrap();\n+                incremental_reparse(before.tree().syntax(), &edit, before.errors.to_vec()).unwrap();\n             assert_eq!(range.len(), reparsed_len.into(), \"reparsed fragment has wrong length\");\n             Parse::new(green, new_errors)\n         };\n@@ -211,6 +215,7 @@ mod tests {\n             &format!(\"{:#?}\", fully_reparsed.tree().syntax()),\n             &format!(\"{:#?}\", incrementally_reparsed.tree().syntax()),\n         );\n+        assert_eq!(fully_reparsed.errors(), incrementally_reparsed.errors());\n     }\n \n     #[test] // FIXME: some test here actually test token reparsing\n@@ -409,4 +414,42 @@ enum Foo {\n             4,\n         );\n     }\n+\n+    #[test]\n+    fn reparse_str_token_with_error_unchanged() {\n+        do_check(r#\"\"<|>Unclosed<|> string literal\"#, \"Still unclosed\", 24);\n+    }\n+\n+    #[test]\n+    fn reparse_str_token_with_error_fixed() {\n+        do_check(r#\"\"unterinated<|><|>\"#, \"\\\"\", 12);\n+    }\n+\n+    #[test]\n+    fn reparse_block_with_error_in_middle_unchanged() {\n+        do_check(\n+            r#\"fn main() {\n+                if {}\n+                32 + 4<|><|>\n+                return\n+                if {}\n+            }\"#,\n+            \"23\",\n+            105,\n+        )\n+    }\n+\n+    #[test]\n+    fn reparse_block_with_error_in_middle_fixed() {\n+        do_check(\n+            r#\"fn main() {\n+                if {}\n+                32 + 4<|><|>\n+                return\n+                if {}\n+            }\"#,\n+            \";\",\n+            105,\n+        )\n+    }\n }"}]}