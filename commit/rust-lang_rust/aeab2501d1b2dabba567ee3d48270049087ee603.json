{"sha": "aeab2501d1b2dabba567ee3d48270049087ee603", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFlYWIyNTAxZDFiMmRhYmJhNTY3ZWUzZDQ4MjcwMDQ5MDg3ZWU2MDM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-11T15:56:38Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-07-11T15:56:38Z"}, "message": "auto merge of #15503 : pnkfelix/rust/fsk-linear-deriving-partialord, r=huonw\n\nInstead of generating a separate case (albeit trivial) for each of the N*N cases when comparing two instances of an enum with N variants, this `deriving` uses the strategy outlined here: https://github.com/rust-lang/rust/issues/15375#issuecomment-47994007\r\n\r\nIn particular, it generates code that looks more like this:\r\n\r\n```rust\r\n    match (this, that, ...) {\r\n      (Variant1, Variant1, Variant1) => ... // delegate Matching on Variant1\r\n      (Variant2, Variant2, Variant2) => ... // delegate Matching on Variant2\r\n      ...\r\n      _ => {\r\n        let index_tup = {\r\n          let idx_this = match this { Variant1 => 0u, Variant2 => 1u, ... };\r\n          let idx_that = match that { Variant1 => 0u, Variant2 => 1u, ... };\r\n          ...\r\n          (idx_this, idx_that, ...)\r\n        };\r\n        ... // delegate to catch-all; it can inspect `index_tup` for its logic\r\n      }\r\n    }\r\n```\r\n\r\nWhile adding a new variant to the `const_nonmatching` flag (and renaming it to `on_nonmatching`) to allow expressing the above (while still allowing one to opt back into the old `O(N^2)` and in general `O(N^K)` (where `K` is the number of self arguments) code generation behavior), I had two realizations:\r\n\r\n 1. Observation: Nothing except for the comparison derivings (`PartialOrd`, `Ord`, `PartialEq`, `Eq`) were even using the old `O(N^K)` code generator.  So after this hypothetically lands, *nothing* needs to use them, and thus that code generation strategy could be removed, under the assumption that it is very unlikely that any `deriving` mode will actually need that level of generality.\r\n 2. Observation: The new code generator I am adding can actually be unified with all of the other code generators that just dispatch on the variant tag (they all assume that there is only one self argument).\r\n\r\nThese two observations mean that one can get rid of the `const_nonmatching` (aka `on_nonmatching`) entirely.  So I did that too in this PR.\r\n\r\nThe question is: Do we actually want to follow through on both of the above observations?  I'm pretty sure the second observation is a pure win.  But there *might* be someone out there with an example that invalidates the reasoning in the first observation.  That is, there might be a client out there with an example of hypothetical deriving mode that wants to opt into the `O(N^K)` behavior.  So, if that is true, then I can revise this PR to resurrect the `on_nonmatching` flag and provide a way to access the `O(N^K)` behavior.\r\n\r\nThe manner in which I choose to squash these commits during a post-review rebase depends on the answer to the above question.\r\n\r\nFix #15375.", "tree": {"sha": "33b1934f8427650286c61b7b1fab122eaf700b17", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/33b1934f8427650286c61b7b1fab122eaf700b17"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/aeab2501d1b2dabba567ee3d48270049087ee603", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/aeab2501d1b2dabba567ee3d48270049087ee603", "html_url": "https://github.com/rust-lang/rust/commit/aeab2501d1b2dabba567ee3d48270049087ee603", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/aeab2501d1b2dabba567ee3d48270049087ee603/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b8059f730e07c46c9f89d30c609d1e70ed1a7d82", "url": "https://api.github.com/repos/rust-lang/rust/commits/b8059f730e07c46c9f89d30c609d1e70ed1a7d82", "html_url": "https://github.com/rust-lang/rust/commit/b8059f730e07c46c9f89d30c609d1e70ed1a7d82"}, {"sha": "5cee57869c527ee798c8aeb0e17e82fb36848c4f", "url": "https://api.github.com/repos/rust-lang/rust/commits/5cee57869c527ee798c8aeb0e17e82fb36848c4f", "html_url": "https://github.com/rust-lang/rust/commit/5cee57869c527ee798c8aeb0e17e82fb36848c4f"}], "stats": {"total": 692, "additions": 399, "deletions": 293}, "files": [{"sha": "bbe96018f4b3ddbd080bee76e71ffc5eaddd0b74", "filename": "src/libsyntax/ext/deriving/clone.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/aeab2501d1b2dabba567ee3d48270049087ee603/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aeab2501d1b2dabba567ee3d48270049087ee603/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fclone.rs?ref=aeab2501d1b2dabba567ee3d48270049087ee603", "patch": "@@ -39,7 +39,6 @@ pub fn expand_deriving_clone(cx: &mut ExtCtxt,\n                 args: Vec::new(),\n                 ret_ty: Self,\n                 attributes: attrs,\n-                const_nonmatching: false,\n                 combine_substructure: combine_substructure(|c, s, sub| {\n                     cs_clone(\"Clone\", c, s, sub)\n                 }),\n@@ -69,7 +68,7 @@ fn cs_clone(\n             ctor_ident = variant.node.name;\n             all_fields = af;\n         },\n-        EnumNonMatching(..) => {\n+        EnumNonMatchingCollapsed (..) => {\n             cx.span_bug(trait_span,\n                         format!(\"non-matching enum variants in \\\n                                  `deriving({})`\","}, {"sha": "19a979a5655ba060912d52838fa8b6faabc1701e", "filename": "src/libsyntax/ext/deriving/cmp/eq.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aeab2501d1b2dabba567ee3d48270049087ee603/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aeab2501d1b2dabba567ee3d48270049087ee603/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Feq.rs?ref=aeab2501d1b2dabba567ee3d48270049087ee603", "patch": "@@ -45,7 +45,6 @@ pub fn expand_deriving_eq(cx: &mut ExtCtxt,\n                 args: vec!(borrowed_self()),\n                 ret_ty: Literal(Path::new(vec!(\"bool\"))),\n                 attributes: attrs,\n-                const_nonmatching: true,\n                 combine_substructure: combine_substructure(|a, b, c| {\n                     $f(a, b, c)\n                 })"}, {"sha": "dcf59ba820e4cc39c0a81dd85844e00890fed6de", "filename": "src/libsyntax/ext/deriving/cmp/ord.rs", "status": "modified", "additions": 35, "deletions": 34, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/aeab2501d1b2dabba567ee3d48270049087ee603/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aeab2501d1b2dabba567ee3d48270049087ee603/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ford.rs?ref=aeab2501d1b2dabba567ee3d48270049087ee603", "patch": "@@ -35,7 +35,6 @@ pub fn expand_deriving_ord(cx: &mut ExtCtxt,\n                 args: vec!(borrowed_self()),\n                 ret_ty: Literal(Path::new(vec!(\"bool\"))),\n                 attributes: attrs,\n-                const_nonmatching: false,\n                 combine_substructure: combine_substructure(|cx, span, substr| {\n                     cs_op($op, $equal, cx, span, substr)\n                 })\n@@ -59,7 +58,6 @@ pub fn expand_deriving_ord(cx: &mut ExtCtxt,\n         args: vec![borrowed_self()],\n         ret_ty: ret_ty,\n         attributes: attrs,\n-        const_nonmatching: false,\n         combine_substructure: combine_substructure(|cx, span, substr| {\n             cs_partial_cmp(cx, span, substr)\n         })\n@@ -82,24 +80,33 @@ pub fn expand_deriving_ord(cx: &mut ExtCtxt,\n     trait_def.expand(cx, mitem, item, push)\n }\n \n-pub fn some_ordering_const(cx: &mut ExtCtxt, span: Span, cnst: Ordering) -> Gc<ast::Expr> {\n-    let cnst = match cnst {\n-        Less => \"Less\",\n-        Equal => \"Equal\",\n-        Greater => \"Greater\"\n+pub enum OrderingOp {\n+    PartialCmpOp, LtOp, LeOp, GtOp, GeOp,\n+}\n+\n+pub fn some_ordering_collapsed(cx: &mut ExtCtxt,\n+                               span: Span,\n+                               op: OrderingOp,\n+                               self_arg_tags: &[ast::Ident]) -> Gc<ast::Expr> {\n+    let lft = cx.expr_ident(span, self_arg_tags[0]);\n+    let rgt = cx.expr_addr_of(span, cx.expr_ident(span, self_arg_tags[1]));\n+    let op_str = match op {\n+        PartialCmpOp => \"partial_cmp\",\n+        LtOp => \"lt\", LeOp => \"le\",\n+        GtOp => \"gt\", GeOp => \"ge\",\n     };\n-    let ordering = cx.path_global(span,\n-                                  vec!(cx.ident_of(\"std\"),\n-                                       cx.ident_of(\"cmp\"),\n-                                       cx.ident_of(cnst)));\n-    let ordering = cx.expr_path(ordering);\n-    cx.expr_some(span, ordering)\n+    cx.expr_method_call(span, lft, cx.ident_of(op_str), vec![rgt])\n }\n \n pub fn cs_partial_cmp(cx: &mut ExtCtxt, span: Span,\n               substr: &Substructure) -> Gc<Expr> {\n     let test_id = cx.ident_of(\"__test\");\n-    let equals_expr = some_ordering_const(cx, span, Equal);\n+    let ordering = cx.path_global(span,\n+                                  vec!(cx.ident_of(\"std\"),\n+                                       cx.ident_of(\"cmp\"),\n+                                       cx.ident_of(\"Equal\")));\n+    let ordering = cx.expr_path(ordering);\n+    let equals_expr = cx.expr_some(span, ordering);\n \n     /*\n     Builds:\n@@ -141,13 +148,11 @@ pub fn cs_partial_cmp(cx: &mut ExtCtxt, span: Span,\n             cx.expr_block(cx.block(span, vec!(assign), Some(if_)))\n         },\n         equals_expr.clone(),\n-        |cx, span, list, _| {\n-            match list {\n-                // an earlier nonmatching variant is Less than a\n-                // later one.\n-                [(self_var, _, _), (other_var, _, _)] =>\n-                     some_ordering_const(cx, span, self_var.cmp(&other_var)),\n-                _ => cx.span_bug(span, \"not exactly 2 arguments in `deriving(Ord)`\")\n+        |cx, span, (self_args, tag_tuple), _non_self_args| {\n+            if self_args.len() != 2 {\n+                cx.span_bug(span, \"not exactly 2 arguments in `deriving(Ord)`\")\n+            } else {\n+                some_ordering_collapsed(cx, span, PartialCmpOp, tag_tuple)\n             }\n         },\n         cx, span, substr)\n@@ -191,19 +196,15 @@ fn cs_op(less: bool, equal: bool, cx: &mut ExtCtxt, span: Span,\n             cx.expr_binary(span, ast::BiOr, cmp, and)\n         },\n         cx.expr_bool(span, equal),\n-        |cx, span, args, _| {\n-            // nonmatching enums, order by the order the variants are\n-            // written\n-            match args {\n-                [(self_var, _, _),\n-                 (other_var, _, _)] =>\n-                    cx.expr_bool(span,\n-                                 if less {\n-                                     self_var < other_var\n-                                 } else {\n-                                     self_var > other_var\n-                                 }),\n-                _ => cx.span_bug(span, \"not exactly 2 arguments in `deriving(Ord)`\")\n+        |cx, span, (self_args, tag_tuple), _non_self_args| {\n+            if self_args.len() != 2 {\n+                cx.span_bug(span, \"not exactly 2 arguments in `deriving(Ord)`\")\n+            } else {\n+                let op = match (less, equal) {\n+                    (true,  true) => LeOp, (true,  false) => LtOp,\n+                    (false, true) => GeOp, (false, false) => GtOp,\n+                };\n+                some_ordering_collapsed(cx, span, op, tag_tuple)\n             }\n         },\n         cx, span, substr)"}, {"sha": "42365936c9d4f5e56507ef736b2ea6bb8d8ff5bc", "filename": "src/libsyntax/ext/deriving/cmp/totaleq.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aeab2501d1b2dabba567ee3d48270049087ee603/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aeab2501d1b2dabba567ee3d48270049087ee603/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotaleq.rs?ref=aeab2501d1b2dabba567ee3d48270049087ee603", "patch": "@@ -57,7 +57,6 @@ pub fn expand_deriving_totaleq(cx: &mut ExtCtxt,\n                 args: vec!(),\n                 ret_ty: nil_ty(),\n                 attributes: attrs,\n-                const_nonmatching: true,\n                 combine_substructure: combine_substructure(|a, b, c| {\n                     cs_total_eq_assert(a, b, c)\n                 })"}, {"sha": "e010b635fe41a666244d7c82fd45458fceefdcea", "filename": "src/libsyntax/ext/deriving/cmp/totalord.rs", "status": "modified", "additions": 15, "deletions": 23, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/aeab2501d1b2dabba567ee3d48270049087ee603/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aeab2501d1b2dabba567ee3d48270049087ee603/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fcmp%2Ftotalord.rs?ref=aeab2501d1b2dabba567ee3d48270049087ee603", "patch": "@@ -17,7 +17,6 @@ use ext::deriving::generic::*;\n use ext::deriving::generic::ty::*;\n use parse::token::InternedString;\n \n-use std::cmp::{Ordering, Equal, Less, Greater};\n use std::gc::Gc;\n \n pub fn expand_deriving_totalord(cx: &mut ExtCtxt,\n@@ -41,7 +40,6 @@ pub fn expand_deriving_totalord(cx: &mut ExtCtxt,\n                 args: vec!(borrowed_self()),\n                 ret_ty: Literal(Path::new(vec!(\"std\", \"cmp\", \"Ordering\"))),\n                 attributes: attrs,\n-                const_nonmatching: false,\n                 combine_substructure: combine_substructure(|a, b, c| {\n                     cs_cmp(a, b, c)\n                 }),\n@@ -53,22 +51,21 @@ pub fn expand_deriving_totalord(cx: &mut ExtCtxt,\n }\n \n \n-pub fn ordering_const(cx: &mut ExtCtxt, span: Span, cnst: Ordering) -> ast::Path {\n-    let cnst = match cnst {\n-        Less => \"Less\",\n-        Equal => \"Equal\",\n-        Greater => \"Greater\"\n-    };\n-    cx.path_global(span,\n-                   vec!(cx.ident_of(\"std\"),\n-                     cx.ident_of(\"cmp\"),\n-                     cx.ident_of(cnst)))\n+pub fn ordering_collapsed(cx: &mut ExtCtxt,\n+                          span: Span,\n+                          self_arg_tags: &[ast::Ident]) -> Gc<ast::Expr> {\n+    let lft = cx.expr_ident(span, self_arg_tags[0]);\n+    let rgt = cx.expr_addr_of(span, cx.expr_ident(span, self_arg_tags[1]));\n+    cx.expr_method_call(span, lft, cx.ident_of(\"cmp\"), vec![rgt])\n }\n \n pub fn cs_cmp(cx: &mut ExtCtxt, span: Span,\n               substr: &Substructure) -> Gc<Expr> {\n     let test_id = cx.ident_of(\"__test\");\n-    let equals_path = ordering_const(cx, span, Equal);\n+    let equals_path = cx.path_global(span,\n+                                     vec!(cx.ident_of(\"std\"),\n+                                          cx.ident_of(\"cmp\"),\n+                                          cx.ident_of(\"Equal\")));\n \n     /*\n     Builds:\n@@ -110,16 +107,11 @@ pub fn cs_cmp(cx: &mut ExtCtxt, span: Span,\n             cx.expr_block(cx.block(span, vec!(assign), Some(if_)))\n         },\n         cx.expr_path(equals_path.clone()),\n-        |cx, span, list, _| {\n-            match list {\n-                // an earlier nonmatching variant is Less than a\n-                // later one.\n-                [(self_var, _, _),\n-                 (other_var, _, _)] => {\n-                    let order = ordering_const(cx, span, self_var.cmp(&other_var));\n-                    cx.expr_path(order)\n-                }\n-                _ => cx.span_bug(span, \"not exactly 2 arguments in `deriving(Ord)`\")\n+        |cx, span, (self_args, tag_tuple), _non_self_args| {\n+            if self_args.len() != 2 {\n+                cx.span_bug(span, \"not exactly 2 arguments in `deriving(TotalOrd)`\")\n+            } else {\n+                ordering_collapsed(cx, span, tag_tuple)\n             }\n         },\n         cx, span, substr)"}, {"sha": "d909ffd2b49fb56aa24361e419641ab1113b5642", "filename": "src/libsyntax/ext/deriving/decodable.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aeab2501d1b2dabba567ee3d48270049087ee603/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aeab2501d1b2dabba567ee3d48270049087ee603/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdecodable.rs?ref=aeab2501d1b2dabba567ee3d48270049087ee603", "patch": "@@ -54,7 +54,6 @@ pub fn expand_deriving_decodable(cx: &mut ExtCtxt,\n                                           vec!(box Self,\n                                                box Literal(Path::new_local(\"__E\"))), true)),\n                 attributes: Vec::new(),\n-                const_nonmatching: true,\n                 combine_substructure: combine_substructure(|a, b, c| {\n                     decodable_substructure(a, b, c)\n                 }),"}, {"sha": "f7d0308e1bd21d52cd1b1a401d878c8d9b22e142", "filename": "src/libsyntax/ext/deriving/default.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aeab2501d1b2dabba567ee3d48270049087ee603/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aeab2501d1b2dabba567ee3d48270049087ee603/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fdefault.rs?ref=aeab2501d1b2dabba567ee3d48270049087ee603", "patch": "@@ -39,7 +39,6 @@ pub fn expand_deriving_default(cx: &mut ExtCtxt,\n                 args: Vec::new(),\n                 ret_ty: Self,\n                 attributes: attrs,\n-                const_nonmatching: false,\n                 combine_substructure: combine_substructure(|a, b, c| {\n                     default_substructure(a, b, c)\n                 })"}, {"sha": "7e289e7676aa92c908353371364c142bf173de71", "filename": "src/libsyntax/ext/deriving/encodable.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aeab2501d1b2dabba567ee3d48270049087ee603/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aeab2501d1b2dabba567ee3d48270049087ee603/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fencodable.rs?ref=aeab2501d1b2dabba567ee3d48270049087ee603", "patch": "@@ -121,7 +121,6 @@ pub fn expand_deriving_encodable(cx: &mut ExtCtxt,\n                                                 box Literal(Path::new_local(\"__E\"))),\n                                            true)),\n                 attributes: Vec::new(),\n-                const_nonmatching: true,\n                 combine_substructure: combine_substructure(|a, b, c| {\n                     encodable_substructure(a, b, c)\n                 }),"}, {"sha": "7d454016d602d3f118adec1126dfba0e1e7e85cc", "filename": "src/libsyntax/ext/deriving/generic/mod.rs", "status": "modified", "additions": 347, "deletions": 220, "changes": 567, "blob_url": "https://github.com/rust-lang/rust/blob/aeab2501d1b2dabba567ee3d48270049087ee603/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aeab2501d1b2dabba567ee3d48270049087ee603/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fgeneric%2Fmod.rs?ref=aeab2501d1b2dabba567ee3d48270049087ee603", "patch": "@@ -37,18 +37,19 @@\n //!   `struct T(int, char)`).\n //! - `EnumMatching`, when `Self` is an enum and all the arguments are the\n //!   same variant of the enum (e.g. `Some(1)`, `Some(3)` and `Some(4)`)\n-//! - `EnumNonMatching` when `Self` is an enum and the arguments are not\n-//!   the same variant (e.g. `None`, `Some(1)` and `None`). If\n-//!   `const_nonmatching` is true, this will contain an empty list.\n+//! - `EnumNonMatchingCollapsed` when `Self` is an enum and the arguments\n+//!   are not the same variant (e.g. `None`, `Some(1)` and `None`).\n //! - `StaticEnum` and `StaticStruct` for static methods, where the type\n //!   being derived upon is either an enum or struct respectively. (Any\n //!   argument with type Self is just grouped among the non-self\n //!   arguments.)\n //!\n //! In the first two cases, the values from the corresponding fields in\n-//! all the arguments are grouped together. In the `EnumNonMatching` case\n+//! all the arguments are grouped together. For `EnumNonMatchingCollapsed`\n //! this isn't possible (different variants have different fields), so the\n-//! fields are grouped by which argument they come from. There are no\n+//! fields are inaccessible. (Previous versions of the deriving infrastructure\n+//! had a way to expand into code that could access them, at the cost of\n+//! generating exponential amounts of code; see issue #15375). There are no\n //! fields with values in the static cases, so these are treated entirely\n //! differently.\n //!\n@@ -150,14 +151,20 @@\n //! For `C0(a)` and `C1 {x}` ,\n //!\n //! ~~~text\n-//! EnumNonMatching(~[(0, <ast::Variant for B0>,\n-//!                    ~[(<span of int>, None, <expr for &a>)]),\n-//!                   (1, <ast::Variant for B1>,\n-//!                    ~[(<span of x>, Some(<ident of x>),\n-//!                       <expr for &other.x>)])])\n+//! EnumNonMatchingCollapsed(\n+//!     ~[<ident of self>, <ident of __arg_1>],\n+//!     &[<ast::Variant for C0>, <ast::Variant for C1>],\n+//!     &[<ident for self index value>, <ident of __arg_1 index value>])\n //! ~~~\n //!\n-//! (and vice versa, but with the order of the outermost list flipped.)\n+//! It is the same for when the arguments are flipped to `C1 {x}` and\n+//! `C0(a)`; the only difference is what the values of the identifiers\n+//! <ident for self index value> and <ident of __arg_1 index value> will\n+//! be in the generated code.\n+//!\n+//! `EnumNonMatchingCollapsed` deliberately provides far less information\n+//! than is generally available for a given pair of variants; see #15375\n+//! for discussion.\n //!\n //! ## Static\n //!\n@@ -232,10 +239,6 @@ pub struct MethodDef<'a> {\n \n     pub attributes: Vec<ast::Attribute>,\n \n-    /// if the value of the nonmatching enums is independent of the\n-    /// actual enum variants, i.e. can use _ => .. match.\n-    pub const_nonmatching: bool,\n-\n     pub combine_substructure: RefCell<CombineSubstructureFunc<'a>>,\n }\n \n@@ -286,12 +289,14 @@ pub enum SubstructureFields<'a> {\n     EnumMatching(uint, &'a ast::Variant, Vec<FieldInfo>),\n \n     /**\n-    non-matching variants of the enum, [(variant index, ast::Variant,\n-    [field span, field ident, fields])] \\(i.e. all fields for self are in the\n-    first tuple, for other1 are in the second tuple, etc.)\n+    non-matching variants of the enum, but with all state hidden from\n+    the consequent code.  The first component holds Idents for all of\n+    the Self arguments; the second component is a slice of all of the\n+    variants for the enum itself, and the third component is a list of\n+    Idents bound to the variant index values for each of the actual\n+    input Self arguments.\n     */\n-    EnumNonMatching(&'a [(uint, P<ast::Variant>,\n-                          Vec<(Span, Option<Ident>, Gc<Expr>)>)]),\n+    EnumNonMatchingCollapsed(Vec<Ident>, &'a [Gc<ast::Variant>], &'a [Ident]),\n \n     /// A static method where Self is a struct.\n     StaticStruct(&'a ast::StructDef, StaticFields),\n@@ -309,14 +314,16 @@ pub type CombineSubstructureFunc<'a> =\n     |&mut ExtCtxt, Span, &Substructure|: 'a -> Gc<Expr>;\n \n /**\n-Deal with non-matching enum variants, the arguments are a list\n-representing each variant: (variant index, ast::Variant instance,\n-[variant fields]), and a list of the nonself args of the type\n+Deal with non-matching enum variants.  The tuple is a list of\n+identifiers (one for each Self argument, which could be any of the\n+variants since they have been collapsed together) and the identifiers\n+holding the variant index value for each of the Self arguments.  The\n+last argument is all the non-Self args of the method being derived.\n */\n-pub type EnumNonMatchFunc<'a> =\n+pub type EnumNonMatchCollapsedFunc<'a> =\n     |&mut ExtCtxt,\n            Span,\n-           &[(uint, P<ast::Variant>, Vec<(Span, Option<Ident>, Gc<Expr>)>)],\n+           (&[Ident], &[Ident]),\n            &[Gc<Expr>]|: 'a\n            -> Gc<Expr>;\n \n@@ -516,6 +523,15 @@ impl<'a> TraitDef<'a> {\n     }\n }\n \n+fn variant_to_pat(cx: &mut ExtCtxt, sp: Span, variant: &ast::Variant)\n+                  -> Gc<ast::Pat> {\n+    let ident = cx.path_ident(sp, variant.node.name);\n+    cx.pat(sp, match variant.node.kind {\n+        ast::TupleVariantKind(..) => ast::PatEnum(ident, None),\n+        ast::StructVariantKind(..) => ast::PatStruct(ident, Vec::new(), true),\n+    })\n+}\n+\n impl<'a> MethodDef<'a> {\n     fn call_substructure_method(&self,\n                                 cx: &mut ExtCtxt,\n@@ -754,27 +770,32 @@ impl<'a> MethodDef<'a> {\n    ~~~\n     #[deriving(PartialEq)]\n     enum A {\n-        A1\n+        A1,\n         A2(int)\n     }\n \n-    // is equivalent to (with const_nonmatching == false)\n+    // is equivalent to\n \n     impl PartialEq for A {\n-        fn eq(&self, __arg_1: &A) {\n-            match *self {\n-                A1 => match *__arg_1 {\n-                    A1 => true\n-                    A2(ref __arg_1_1) => false\n-                },\n-                A2(self_1) => match *__arg_1 {\n-                    A1 => false,\n-                    A2(ref __arg_1_1) => self_1.eq(__arg_1_1)\n+        fn eq(&self, __arg_1: &A) -> ::bool {\n+            match (&*self, &*__arg_1) {\n+                (&A1, &A1) => true,\n+                (&A2(ref __self_0),\n+                 &A2(ref __arg_1_0)) => (*__self_0).eq(&(*__arg_1_0)),\n+                _ => {\n+                    let __self_vi = match *self { A1(..) => 0u, A2(..) => 1u };\n+                    let __arg_1_vi = match *__arg_1 { A1(..) => 0u, A2(..) => 1u };\n+                    false\n                 }\n             }\n         }\n     }\n    ~~~\n+\n+    (Of course `__self_vi` and `__arg_1_vi` are unused for\n+     `PartialEq`, and those subcomputations will hopefully be removed\n+     as their results are unused.  The point of `__self_vi` and\n+     `__arg_1_vi` is for `PartialOrd`; see #15503.)\n     */\n     fn expand_enum_method_body(&self,\n                                cx: &mut ExtCtxt,\n@@ -784,190 +805,296 @@ impl<'a> MethodDef<'a> {\n                                self_args: &[Gc<Expr>],\n                                nonself_args: &[Gc<Expr>])\n                                -> Gc<Expr> {\n-        let mut matches = Vec::new();\n-        self.build_enum_match(cx, trait_, enum_def, type_ident,\n-                              self_args, nonself_args,\n-                              None, &mut matches, 0)\n+        self.build_enum_match_tuple(\n+            cx, trait_, enum_def, type_ident, self_args, nonself_args)\n     }\n \n \n     /**\n-    Creates the nested matches for an enum definition recursively, i.e.\n-\n-   ~~~text\n-    match self {\n-       Variant1 => match other { Variant1 => matching, Variant2 => nonmatching, ... },\n-       Variant2 => match other { Variant1 => nonmatching, Variant2 => matching, ... },\n-       ...\n+    Creates a match for a tuple of all `self_args`, where either all\n+    variants match, or it falls into a catch-all for when one variant\n+    does not match.\n+\n+    There are N + 1 cases because is a case for each of the N\n+    variants where all of the variants match, and one catch-all for\n+    when one does not match.\n+\n+    The catch-all handler is provided access the variant index values\n+    for each of the self-args, carried in precomputed variables. (Nota\n+    bene: the variant index values are not necessarily the\n+    discriminant values.  See issue #15523.)\n+\n+    ~~~text\n+    match (this, that, ...) {\n+      (Variant1, Variant1, Variant1) => ... // delegate Matching on Variant1\n+      (Variant2, Variant2, Variant2) => ... // delegate Matching on Variant2\n+      ...\n+      _ => {\n+        let __this_vi = match this { Variant1 => 0u, Variant2 => 1u, ... };\n+        let __that_vi = match that { Variant1 => 0u, Variant2 => 1u, ... };\n+        ... // catch-all remainder can inspect above variant index values.\n+      }\n     }\n-   ~~~\n-\n-    It acts in the most naive way, so every branch (and subbranch,\n-    subsubbranch, etc) exists, not just the ones where all the variants in\n-    the tree are the same. Hopefully the optimisers get rid of any\n-    repetition, otherwise derived methods with many Self arguments will be\n-    exponentially large.\n-\n-    `matching` is Some(n) if all branches in the tree above the\n-    current position are variant `n`, `None` otherwise (including on\n-    the first call).\n+    ~~~\n     */\n-    fn build_enum_match(&self,\n-                        cx: &mut ExtCtxt,\n-                        trait_: &TraitDef,\n-                        enum_def: &EnumDef,\n-                        type_ident: Ident,\n-                        self_args: &[Gc<Expr>],\n-                        nonself_args: &[Gc<Expr>],\n-                        matching: Option<uint>,\n-                        matches_so_far: &mut Vec<(uint, P<ast::Variant>,\n-                                              Vec<(Span, Option<Ident>, Gc<Expr>)>)> ,\n-                        match_count: uint) -> Gc<Expr> {\n-        if match_count == self_args.len() {\n-            // we've matched against all arguments, so make the final\n-            // expression at the bottom of the match tree\n-            if matches_so_far.len() == 0 {\n-                cx.span_bug(trait_.span,\n-                                \"no self match on an enum in \\\n-                                generic `deriving`\");\n-            }\n-\n-            // `ref` inside let matches is buggy. Causes havoc with rusc.\n-            // let (variant_index, ref self_vec) = matches_so_far[0];\n-            let (variant, self_vec) = match matches_so_far.get(0) {\n-                &(_, v, ref s) => (v, s)\n-            };\n-\n-            // we currently have a vec of vecs, where each\n-            // subvec is the fields of one of the arguments,\n-            // but if the variants all match, we want this as\n-            // vec of tuples, where each tuple represents a\n-            // field.\n-\n-            // most arms don't have matching variants, so do a\n-            // quick check to see if they match (even though\n-            // this means iterating twice) instead of being\n-            // optimistic and doing a pile of allocations etc.\n-            let substructure = match matching {\n-                Some(variant_index) => {\n-                    let mut enum_matching_fields = Vec::from_elem(self_vec.len(), Vec::new());\n-\n-                    for triple in matches_so_far.tail().iter() {\n-                        match triple {\n-                            &(_, _, ref other_fields) => {\n-                                for (i, &(_, _, e)) in other_fields.iter().enumerate() {\n-                                    enum_matching_fields.get_mut(i).push(e);\n-                                }\n-                            }\n-                        }\n-                    }\n-                    let field_tuples =\n-                        self_vec.iter()\n-                                .zip(enum_matching_fields.iter())\n-                                .map(|(&(span, id, self_f), other)| {\n-                        FieldInfo {\n-                            span: span,\n-                            name: id,\n-                            self_: self_f,\n-                            other: (*other).clone()\n-                        }\n-                    }).collect();\n-                    EnumMatching(variant_index, &*variant, field_tuples)\n-                }\n-                None => {\n-                    EnumNonMatching(matches_so_far.as_slice())\n+    fn build_enum_match_tuple(\n+        &self,\n+        cx: &mut ExtCtxt,\n+        trait_: &TraitDef,\n+        enum_def: &EnumDef,\n+        type_ident: Ident,\n+        self_args: &[Gc<Expr>],\n+        nonself_args: &[Gc<Expr>]) -> Gc<Expr> {\n+\n+        let sp = trait_.span;\n+        let variants = &enum_def.variants;\n+\n+        let self_arg_names = self_args.iter().enumerate()\n+            .map(|(arg_count, _self_arg)| {\n+                if arg_count == 0 {\n+                    \"__self\".to_string()\n+                } else {\n+                    format!(\"__arg_{}\", arg_count)\n                 }\n-            };\n-            self.call_substructure_method(cx, trait_, type_ident,\n-                                          self_args, nonself_args,\n-                                          &substructure)\n+            })\n+            .collect::<Vec<String>>();\n+\n+        let self_arg_idents = self_arg_names.iter()\n+            .map(|name|cx.ident_of(name.as_slice()))\n+            .collect::<Vec<ast::Ident>>();\n+\n+        // The `vi_idents` will be bound, solely in the catch-all, to\n+        // a series of let statements mapping each self_arg to a uint\n+        // corresponding to its variant index.\n+        let vi_idents : Vec<ast::Ident> = self_arg_names.iter()\n+            .map(|name| { let vi_suffix = format!(\"{:s}_vi\", name.as_slice());\n+                          cx.ident_of(vi_suffix.as_slice()) })\n+            .collect::<Vec<ast::Ident>>();\n+\n+        // Builds, via callback to call_substructure_method, the\n+        // delegated expression that handles the catch-all case,\n+        // using `__variants_tuple` to drive logic if necessary.\n+        let catch_all_substructure = EnumNonMatchingCollapsed(\n+            self_arg_idents, variants.as_slice(), vi_idents.as_slice());\n+\n+        // These arms are of the form:\n+        // (Variant1, Variant1, ...) => Body1\n+        // (Variant2, Variant2, ...) => Body2\n+        // ...\n+        // where each tuple has length = self_args.len()\n+        let mut match_arms : Vec<ast::Arm> = variants.iter().enumerate()\n+            .map(|(index, &variant)| {\n+\n+                // These self_pats have form Variant1, Variant2, ...\n+                let self_pats : Vec<(Gc<ast::Pat>,\n+                                     Vec<(Span, Option<Ident>, Gc<Expr>)>)>;\n+                self_pats = self_arg_names.iter()\n+                    .map(|self_arg_name|\n+                         trait_.create_enum_variant_pattern(\n+                             cx, &*variant, self_arg_name.as_slice(),\n+                             ast::MutImmutable))\n+                    .collect();\n+\n+                // A single arm has form (&VariantK, &VariantK, ...) => BodyK\n+                // (see \"Final wrinkle\" note below for why.)\n+                let subpats = self_pats.iter()\n+                    .map(|&(p, ref _idents)| cx.pat(sp, ast::PatRegion(p)))\n+                    .collect::<Vec<Gc<ast::Pat>>>();\n+\n+                // Here is the pat = `(&VariantK, &VariantK, ...)`\n+                let single_pat = cx.pat(sp, ast::PatTup(subpats));\n+\n+                // For the BodyK, we need to delegate to our caller,\n+                // passing it an EnumMatching to indicate which case\n+                // we are in.\n+\n+                // All of the Self args have the same variant in these\n+                // cases.  So we transpose the info in self_pats to\n+                // gather the getter expressions together, in the form\n+                // that EnumMatching expects.\n+\n+                // The transposition is driven by walking across the\n+                // arg fields of the variant for the first self pat.\n+                let &(_, ref self_arg_fields) = self_pats.get(0);\n+\n+                let field_tuples : Vec<FieldInfo>;\n+\n+                field_tuples = self_arg_fields.iter().enumerate()\n+                    // For each arg field of self, pull out its getter expr ...\n+                    .map(|(field_index, &(sp, opt_ident, self_getter_expr))| {\n+                        // ... but FieldInfo also wants getter expr\n+                        // for matching other arguments of Self type;\n+                        // so walk across the *other* self_pats and\n+                        // pull out getter for same field in each of\n+                        // them (using `field_index` tracked above).\n+                        // That is the heart of the transposition.\n+                        let others = self_pats.tail().iter()\n+                            .map(|&(_pat, ref fields)| {\n+\n+                                let &(_, _opt_ident, other_getter_expr) =\n+                                    fields.get(field_index);\n+\n+                                // All Self args have same variant, so\n+                                // opt_idents are the same.  (Assert\n+                                // here to make it self-evident that\n+                                // it is okay to ignore `_opt_ident`.)\n+                                assert!(opt_ident == _opt_ident);\n+\n+                                other_getter_expr\n+                            }).collect::<Vec<Gc<Expr>>>();\n+\n+                        FieldInfo { span: sp,\n+                                    name: opt_ident,\n+                                    self_: self_getter_expr,\n+                                    other: others,\n+                        }\n+                    }).collect::<Vec<FieldInfo>>();\n+\n+                // Now, for some given VariantK, we have built up\n+                // expressions for referencing every field of every\n+                // Self arg, assuming all are instances of VariantK.\n+                // Build up code associated with such a case.\n+                let substructure = EnumMatching(index, variant, field_tuples);\n+                let arm_expr = self.call_substructure_method(\n+                    cx, trait_, type_ident, self_args, nonself_args,\n+                    &substructure);\n+\n+                cx.arm(sp, vec![single_pat], arm_expr)\n+            }).collect();\n \n-        } else {  // there are still matches to create\n-            let current_match_str = if match_count == 0 {\n-                \"__self\".to_string()\n-            } else {\n-                format!(\"__arg_{}\", match_count)\n-            };\n+        // We will usually need the catch-all after matching the\n+        // tuples `(VariantK, VariantK, ...)` for each VariantK of the\n+        // enum.  But:\n+        //\n+        // * when there is only one Self arg, the arms above suffice\n+        // (and the deriving we call back into may not be prepared to\n+        // handle EnumNonMatchCollapsed), and,\n+        //\n+        // * when the enum has only one variant, the single arm that\n+        // is already present always suffices.\n+        //\n+        // * In either of the two cases above, if we *did* add a\n+        //   catch-all `_` match, it would trigger the\n+        //   unreachable-pattern error.\n+        //\n+        if variants.len() > 1 && self_args.len() > 1 {\n+            let arms : Vec<ast::Arm> = variants.iter().enumerate()\n+                .map(|(index, &variant)| {\n+                    let pat = variant_to_pat(cx, sp, &*variant);\n+                    let lit = ast::LitUint(index as u64, ast::TyU);\n+                    cx.arm(sp, vec![pat], cx.expr_lit(sp, lit))\n+                }).collect();\n \n-            let mut arms = Vec::new();\n-\n-            // the code for nonmatching variants only matters when\n-            // we've seen at least one other variant already\n-            if self.const_nonmatching && match_count > 0 {\n-                // make a matching-variant match, and a _ match.\n-                let index = match matching {\n-                    Some(i) => i,\n-                    None => cx.span_bug(trait_.span,\n-                                        \"non-matching variants when required to \\\n-                                        be matching in generic `deriving`\")\n-                };\n-\n-                // matching-variant match\n-                let variant = *enum_def.variants.get(index);\n-                let (pattern, idents) = trait_.create_enum_variant_pattern(\n-                    cx,\n-                    &*variant,\n-                    current_match_str.as_slice(),\n-                    ast::MutImmutable);\n-\n-                matches_so_far.push((index, variant, idents));\n-                let arm_expr = self.build_enum_match(cx,\n-                                                     trait_,\n-                                                     enum_def,\n-                                                     type_ident,\n-                                                     self_args, nonself_args,\n-                                                     matching,\n-                                                     matches_so_far,\n-                                                     match_count + 1);\n-                matches_so_far.pop().unwrap();\n-                arms.push(cx.arm(trait_.span, vec!( pattern ), arm_expr));\n-\n-                if enum_def.variants.len() > 1 {\n-                    let e = &EnumNonMatching(&[]);\n-                    let wild_expr = self.call_substructure_method(cx, trait_, type_ident,\n-                                                                  self_args, nonself_args,\n-                                                                  e);\n-                    let wild_arm = cx.arm(\n-                        trait_.span,\n-                        vec!( cx.pat_wild(trait_.span) ),\n-                        wild_expr);\n-                    arms.push(wild_arm);\n-                }\n-            } else {\n-                // create an arm matching on each variant\n-                for (index, &variant) in enum_def.variants.iter().enumerate() {\n-                    let (pattern, idents) =\n-                        trait_.create_enum_variant_pattern(\n-                            cx,\n-                            &*variant,\n-                            current_match_str.as_slice(),\n-                            ast::MutImmutable);\n-\n-                    matches_so_far.push((index, variant, idents));\n-                    let new_matching =\n-                        match matching {\n-                            _ if match_count == 0 => Some(index),\n-                            Some(i) if index == i => Some(i),\n-                            _ => None\n-                        };\n-                    let arm_expr = self.build_enum_match(cx,\n-                                                         trait_,\n-                                                         enum_def,\n-                                                         type_ident,\n-                                                         self_args, nonself_args,\n-                                                         new_matching,\n-                                                         matches_so_far,\n-                                                         match_count + 1);\n-                    matches_so_far.pop().unwrap();\n-\n-                    let arm = cx.arm(trait_.span, vec!( pattern ), arm_expr);\n-                    arms.push(arm);\n-                }\n+            // Build a series of let statements mapping each self_arg\n+            // to a uint corresponding to its variant index.\n+            // i.e. for `enum E<T> { A, B(1), C(T, T) }`, and a deriving\n+            // with three Self args, builds three statements:\n+            //\n+            // ```\n+            // let __self0_vi = match   self {\n+            //     A => 0u, B(..) => 1u, C(..) => 2u\n+            // };\n+            // let __self1_vi = match __arg1 {\n+            //     A => 0u, B(..) => 1u, C(..) => 2u\n+            // };\n+            // let __self2_vi = match __arg2 {\n+            //     A => 0u, B(..) => 1u, C(..) => 2u\n+            // };\n+            // ```\n+            let mut index_let_stmts : Vec<Gc<ast::Stmt>> = Vec::new();\n+            for (&ident, &self_arg) in vi_idents.iter().zip(self_args.iter()) {\n+                let variant_idx = cx.expr_match(sp, self_arg, arms.clone());\n+                let let_stmt = cx.stmt_let(sp, false, ident, variant_idx);\n+                index_let_stmts.push(let_stmt);\n             }\n \n-            // match foo { arm, arm, arm, ... }\n-            cx.expr_match(trait_.span, self_args[match_count], arms)\n+            let arm_expr = self.call_substructure_method(\n+                cx, trait_, type_ident, self_args, nonself_args,\n+                &catch_all_substructure);\n+\n+            // Builds the expression:\n+            // {\n+            //   let __self0_vi = ...;\n+            //   let __self1_vi = ...;\n+            //   ...\n+            //   <delegated expression referring to __self0_vi, et al.>\n+            // }\n+            let arm_expr = cx.expr_block(\n+                cx.block_all(sp, Vec::new(), index_let_stmts, Some(arm_expr)));\n+\n+            // Builds arm:\n+            // _ => { let __self0_vi = ...;\n+            //        let __self1_vi = ...;\n+            //        ...\n+            //        <delegated expression as above> }\n+            let catch_all_match_arm =\n+                cx.arm(sp, vec![cx.pat_wild(sp)], arm_expr);\n+\n+            match_arms.push(catch_all_match_arm);\n+\n+        } else if variants.len() == 0 {\n+            // As an additional wrinkle, For a zero-variant enum A,\n+            // currently the compiler\n+            // will accept `fn (a: &Self) { match   *a   { } }`\n+            // but rejects `fn (a: &Self) { match (&*a,) { } }`\n+            // as well as  `fn (a: &Self) { match ( *a,) { } }`\n+            //\n+            // This means that the strategy of building up a tuple of\n+            // all Self arguments fails when Self is a zero variant\n+            // enum: rustc rejects the expanded program, even though\n+            // the actual code tends to be impossible to execute (at\n+            // least safely), according to the type system.\n+            //\n+            // The most expedient fix for this is to just let the\n+            // code fall through to the catch-all.  But even this is\n+            // error-prone, since the catch-all as defined above would\n+            // generate code like this:\n+            //\n+            //     _ => { let __self0 = match *self { };\n+            //            let __self1 = match *__arg_0 { };\n+            //            <catch-all-expr> }\n+            //\n+            // Which is yields bindings for variables which type\n+            // inference cannot resolve to unique types.\n+            //\n+            // One option to the above might be to add explicit type\n+            // annotations.  But the *only* reason to go down that path\n+            // would be to try to make the expanded output consistent\n+            // with the case when the number of enum variants >= 1.\n+            //\n+            // That just isn't worth it.  In fact, trying to generate\n+            // sensible code for *any* deriving on a zero-variant enum\n+            // does not make sense.  But at the same time, for now, we\n+            // do not want to cause a compile failure just because the\n+            // user happened to attach a deriving to their\n+            // zero-variant enum.\n+            //\n+            // Instead, just generate a failing expression for the\n+            // zero variant case, skipping matches and also skipping\n+            // delegating back to the end user code entirely.\n+            //\n+            // (See also #4499 and #12609; note that some of the\n+            // discussions there influence what choice we make here;\n+            // e.g. if we feature-gate `match x { ... }` when x refers\n+            // to an uninhabited type (e.g. a zero-variant enum or a\n+            // type holding such an enum), but do not feature-gate\n+            // zero-variant enums themselves, then attempting to\n+            // derive Show on such a type could here generate code\n+            // that needs the feature gate enabled.)\n+\n+            return cx.expr_unreachable(sp);\n         }\n+\n+        // Final wrinkle: the self_args are expressions that deref\n+        // down to desired l-values, but we cannot actually deref\n+        // them when they are fed as r-values into a tuple\n+        // expression; here add a layer of borrowing, turning\n+        // `(*self, *__arg_0, ...)` into `(&*self, &*__arg_0, ...)`.\n+        let borrowed_self_args = self_args.iter()\n+            .map(|&self_arg| cx.expr_addr_of(sp, self_arg))\n+            .collect::<Vec<Gc<ast::Expr>>>();\n+        let match_arg = cx.expr(sp, ast::ExprTup(borrowed_self_args));\n+        cx.expr_match(sp, match_arg, match_arms)\n     }\n \n     fn expand_static_enum_method_body(&self,\n@@ -1168,7 +1295,7 @@ left-to-right (`true`) or right-to-left (`false`).\n pub fn cs_fold(use_foldl: bool,\n                f: |&mut ExtCtxt, Span, Gc<Expr>, Gc<Expr>, &[Gc<Expr>]| -> Gc<Expr>,\n                base: Gc<Expr>,\n-               enum_nonmatch_f: EnumNonMatchFunc,\n+               enum_nonmatch_f: EnumNonMatchCollapsedFunc,\n                cx: &mut ExtCtxt,\n                trait_span: Span,\n                substructure: &Substructure)\n@@ -1193,9 +1320,9 @@ pub fn cs_fold(use_foldl: bool,\n                 })\n             }\n         },\n-        EnumNonMatching(ref all_enums) => enum_nonmatch_f(cx, trait_span,\n-                                                          *all_enums,\n-                                                          substructure.nonself_args),\n+        EnumNonMatchingCollapsed(ref all_args, _, tuple) =>\n+            enum_nonmatch_f(cx, trait_span, (all_args.as_slice(), tuple),\n+                            substructure.nonself_args),\n         StaticEnum(..) | StaticStruct(..) => {\n             cx.span_bug(trait_span, \"static function in `deriving`\")\n         }\n@@ -1214,7 +1341,7 @@ f(cx, span, ~[self_1.method(__arg_1_1, __arg_2_1),\n */\n #[inline]\n pub fn cs_same_method(f: |&mut ExtCtxt, Span, Vec<Gc<Expr>>| -> Gc<Expr>,\n-                      enum_nonmatch_f: EnumNonMatchFunc,\n+                      enum_nonmatch_f: EnumNonMatchCollapsedFunc,\n                       cx: &mut ExtCtxt,\n                       trait_span: Span,\n                       substructure: &Substructure)\n@@ -1233,9 +1360,9 @@ pub fn cs_same_method(f: |&mut ExtCtxt, Span, Vec<Gc<Expr>>| -> Gc<Expr>,\n \n             f(cx, trait_span, called)\n         },\n-        EnumNonMatching(ref all_enums) => enum_nonmatch_f(cx, trait_span,\n-                                                          *all_enums,\n-                                                          substructure.nonself_args),\n+        EnumNonMatchingCollapsed(ref all_self_args, _, tuple) =>\n+            enum_nonmatch_f(cx, trait_span, (all_self_args.as_slice(), tuple),\n+                            substructure.nonself_args),\n         StaticEnum(..) | StaticStruct(..) => {\n             cx.span_bug(trait_span, \"static function in `deriving`\")\n         }\n@@ -1251,7 +1378,7 @@ fields. `use_foldl` controls whether this is done left-to-right\n pub fn cs_same_method_fold(use_foldl: bool,\n                            f: |&mut ExtCtxt, Span, Gc<Expr>, Gc<Expr>| -> Gc<Expr>,\n                            base: Gc<Expr>,\n-                           enum_nonmatch_f: EnumNonMatchFunc,\n+                           enum_nonmatch_f: EnumNonMatchCollapsedFunc,\n                            cx: &mut ExtCtxt,\n                            trait_span: Span,\n                            substructure: &Substructure)\n@@ -1278,7 +1405,7 @@ on all the fields.\n */\n #[inline]\n pub fn cs_binop(binop: ast::BinOp, base: Gc<Expr>,\n-                enum_nonmatch_f: EnumNonMatchFunc,\n+                enum_nonmatch_f: EnumNonMatchCollapsedFunc,\n                 cx: &mut ExtCtxt, trait_span: Span,\n                 substructure: &Substructure) -> Gc<Expr> {\n     cs_same_method_fold(\n@@ -1296,7 +1423,7 @@ pub fn cs_binop(binop: ast::BinOp, base: Gc<Expr>,\n \n /// cs_binop with binop == or\n #[inline]\n-pub fn cs_or(enum_nonmatch_f: EnumNonMatchFunc,\n+pub fn cs_or(enum_nonmatch_f: EnumNonMatchCollapsedFunc,\n              cx: &mut ExtCtxt, span: Span,\n              substructure: &Substructure) -> Gc<Expr> {\n     cs_binop(ast::BiOr, cx.expr_bool(span, false),\n@@ -1306,7 +1433,7 @@ pub fn cs_or(enum_nonmatch_f: EnumNonMatchFunc,\n \n /// cs_binop with binop == and\n #[inline]\n-pub fn cs_and(enum_nonmatch_f: EnumNonMatchFunc,\n+pub fn cs_and(enum_nonmatch_f: EnumNonMatchCollapsedFunc,\n               cx: &mut ExtCtxt, span: Span,\n               substructure: &Substructure) -> Gc<Expr> {\n     cs_binop(ast::BiAnd, cx.expr_bool(span, true),"}, {"sha": "f469139177a0b24e8ebb2551a036faf4897e797a", "filename": "src/libsyntax/ext/deriving/hash.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aeab2501d1b2dabba567ee3d48270049087ee603/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aeab2501d1b2dabba567ee3d48270049087ee603/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fhash.rs?ref=aeab2501d1b2dabba567ee3d48270049087ee603", "patch": "@@ -54,7 +54,6 @@ pub fn expand_deriving_hash(cx: &mut ExtCtxt,\n                 args: vec!(Ptr(box Literal(args), Borrowed(None, MutMutable))),\n                 ret_ty: nil_ty(),\n                 attributes: attrs,\n-                const_nonmatching: false,\n                 combine_substructure: combine_substructure(|a, b, c| {\n                     hash_substructure(a, b, c)\n                 })"}, {"sha": "30dd8e9683ad51b320d3e36d8c462d4d145205c0", "filename": "src/libsyntax/ext/deriving/primitive.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aeab2501d1b2dabba567ee3d48270049087ee603/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aeab2501d1b2dabba567ee3d48270049087ee603/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fprimitive.rs?ref=aeab2501d1b2dabba567ee3d48270049087ee603", "patch": "@@ -45,7 +45,6 @@ pub fn expand_deriving_from_primitive(cx: &mut ExtCtxt,\n                                            true)),\n                 // #[inline] liable to cause code-bloat\n                 attributes: attrs.clone(),\n-                const_nonmatching: false,\n                 combine_substructure: combine_substructure(|c, s, sub| {\n                     cs_from(\"i64\", c, s, sub)\n                 }),\n@@ -62,7 +61,6 @@ pub fn expand_deriving_from_primitive(cx: &mut ExtCtxt,\n                                            true)),\n                 // #[inline] liable to cause code-bloat\n                 attributes: attrs,\n-                const_nonmatching: false,\n                 combine_substructure: combine_substructure(|c, s, sub| {\n                     cs_from(\"u64\", c, s, sub)\n                 }),"}, {"sha": "c652b5a5bed9a60c223ee7b6839927c98759d727", "filename": "src/libsyntax/ext/deriving/rand.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/aeab2501d1b2dabba567ee3d48270049087ee603/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aeab2501d1b2dabba567ee3d48270049087ee603/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Frand.rs?ref=aeab2501d1b2dabba567ee3d48270049087ee603", "patch": "@@ -45,7 +45,6 @@ pub fn expand_deriving_rand(cx: &mut ExtCtxt,\n                 ),\n                 ret_ty: Self,\n                 attributes: Vec::new(),\n-                const_nonmatching: false,\n                 combine_substructure: combine_substructure(|a, b, c| {\n                     rand_substructure(a, b, c)\n                 })"}, {"sha": "e0dfbb232f554fcf0c7343f29ef89f608f4a4ed0", "filename": "src/libsyntax/ext/deriving/show.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/aeab2501d1b2dabba567ee3d48270049087ee603/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aeab2501d1b2dabba567ee3d48270049087ee603/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fshow.rs?ref=aeab2501d1b2dabba567ee3d48270049087ee603", "patch": "@@ -45,7 +45,6 @@ pub fn expand_deriving_show(cx: &mut ExtCtxt,\n                 args: vec!(fmtr),\n                 ret_ty: Literal(Path::new(vec!(\"std\", \"fmt\", \"Result\"))),\n                 attributes: Vec::new(),\n-                const_nonmatching: false,\n                 combine_substructure: combine_substructure(|a, b, c| {\n                     show_substructure(a, b, c)\n                 })\n@@ -66,8 +65,7 @@ fn show_substructure(cx: &mut ExtCtxt, span: Span,\n     let name = match *substr.fields {\n         Struct(_) => substr.type_ident,\n         EnumMatching(_, v, _) => v.node.name,\n-\n-        EnumNonMatching(..) | StaticStruct(..) | StaticEnum(..) => {\n+        EnumNonMatchingCollapsed(..) | StaticStruct(..) | StaticEnum(..) => {\n             cx.span_bug(span, \"nonsensical .fields in `#[deriving(Show)]`\")\n         }\n     };"}, {"sha": "973f9d518cd70563c373cce5e0d9e2c50f26c450", "filename": "src/libsyntax/ext/deriving/zero.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/aeab2501d1b2dabba567ee3d48270049087ee603/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/aeab2501d1b2dabba567ee3d48270049087ee603/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fderiving%2Fzero.rs?ref=aeab2501d1b2dabba567ee3d48270049087ee603", "patch": "@@ -39,7 +39,6 @@ pub fn expand_deriving_zero(cx: &mut ExtCtxt,\n                 args: Vec::new(),\n                 ret_ty: Self,\n                 attributes: attrs.clone(),\n-                const_nonmatching: false,\n                 combine_substructure: combine_substructure(|a, b, c| {\n                     zero_substructure(a, b, c)\n                 })\n@@ -51,7 +50,6 @@ pub fn expand_deriving_zero(cx: &mut ExtCtxt,\n                 args: Vec::new(),\n                 ret_ty: Literal(Path::new(vec!(\"bool\"))),\n                 attributes: attrs,\n-                const_nonmatching: false,\n                 combine_substructure: combine_substructure(|cx, span, substr| {\n                     cs_and(|cx, span, _, _| cx.span_bug(span,\n                                                         \"Non-matching enum \\"}]}