{"sha": "2f9f097cb8b6c27a7e0d7a916e6911fc1f5ecd81", "node_id": "C_kwDOAAsO6NoAKDJmOWYwOTdjYjhiNmMyN2E3ZTBkN2E5MTZlNjkxMWZjMWY1ZWNkODE", "commit": {"author": {"name": "nils", "email": "48135649+Nilstrieb@users.noreply.github.com", "date": "2022-11-15T13:24:33Z"}, "committer": {"name": "Nilstrieb", "email": "48135649+Nilstrieb@users.noreply.github.com", "date": "2022-12-10T10:02:41Z"}, "message": "Migrate parts of `rustc_expand` to session diagnostics\n\nThis migrates everything but the `mbe` and `proc_macro` modules. It also\ncontains a few cleanups and drive-by/accidental diagnostic improvements\nwhich can be seen in the diff for the UI tests.", "tree": {"sha": "3f5b890f89761f43f7d3071718491dcf72c4d285", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3f5b890f89761f43f7d3071718491dcf72c4d285"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2f9f097cb8b6c27a7e0d7a916e6911fc1f5ecd81", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2f9f097cb8b6c27a7e0d7a916e6911fc1f5ecd81", "html_url": "https://github.com/rust-lang/rust/commit/2f9f097cb8b6c27a7e0d7a916e6911fc1f5ecd81", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2f9f097cb8b6c27a7e0d7a916e6911fc1f5ecd81/comments", "author": {"login": "Nilstrieb", "id": 48135649, "node_id": "MDQ6VXNlcjQ4MTM1NjQ5", "avatar_url": "https://avatars.githubusercontent.com/u/48135649?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nilstrieb", "html_url": "https://github.com/Nilstrieb", "followers_url": "https://api.github.com/users/Nilstrieb/followers", "following_url": "https://api.github.com/users/Nilstrieb/following{/other_user}", "gists_url": "https://api.github.com/users/Nilstrieb/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nilstrieb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nilstrieb/subscriptions", "organizations_url": "https://api.github.com/users/Nilstrieb/orgs", "repos_url": "https://api.github.com/users/Nilstrieb/repos", "events_url": "https://api.github.com/users/Nilstrieb/events{/privacy}", "received_events_url": "https://api.github.com/users/Nilstrieb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nilstrieb", "id": 48135649, "node_id": "MDQ6VXNlcjQ4MTM1NjQ5", "avatar_url": "https://avatars.githubusercontent.com/u/48135649?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nilstrieb", "html_url": "https://github.com/Nilstrieb", "followers_url": "https://api.github.com/users/Nilstrieb/followers", "following_url": "https://api.github.com/users/Nilstrieb/following{/other_user}", "gists_url": "https://api.github.com/users/Nilstrieb/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nilstrieb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nilstrieb/subscriptions", "organizations_url": "https://api.github.com/users/Nilstrieb/orgs", "repos_url": "https://api.github.com/users/Nilstrieb/repos", "events_url": "https://api.github.com/users/Nilstrieb/events{/privacy}", "received_events_url": "https://api.github.com/users/Nilstrieb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a000811405e6a3ca9b0b129c1177e78564e09666", "url": "https://api.github.com/repos/rust-lang/rust/commits/a000811405e6a3ca9b0b129c1177e78564e09666", "html_url": "https://github.com/rust-lang/rust/commit/a000811405e6a3ca9b0b129c1177e78564e09666"}], "stats": {"total": 876, "additions": 640, "deletions": 236}, "files": [{"sha": "9ae65c641fd624bb82aeeea2f05db155ac3ce7af", "filename": "compiler/rustc_builtin_macros/src/concat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f9f097cb8b6c27a7e0d7a916e6911fc1f5ecd81/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f9f097cb8b6c27a7e0d7a916e6911fc1f5ecd81/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat.rs?ref=2f9f097cb8b6c27a7e0d7a916e6911fc1f5ecd81", "patch": "@@ -11,7 +11,7 @@ pub fn expand_concat(\n     sp: rustc_span::Span,\n     tts: TokenStream,\n ) -> Box<dyn base::MacResult + 'static> {\n-    let Some(es) = base::get_exprs_from_tts(cx, sp, tts) else {\n+    let Some(es) = base::get_exprs_from_tts(cx, tts) else {\n         return DummyResult::any(sp);\n     };\n     let mut accumulator = String::new();"}, {"sha": "70ce5a6c41929ebc87afe228579426766ee46daf", "filename": "compiler/rustc_builtin_macros/src/concat_bytes.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f9f097cb8b6c27a7e0d7a916e6911fc1f5ecd81/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat_bytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f9f097cb8b6c27a7e0d7a916e6911fc1f5ecd81/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat_bytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fconcat_bytes.rs?ref=2f9f097cb8b6c27a7e0d7a916e6911fc1f5ecd81", "patch": "@@ -137,7 +137,7 @@ pub fn expand_concat_bytes(\n     sp: rustc_span::Span,\n     tts: TokenStream,\n ) -> Box<dyn base::MacResult + 'static> {\n-    let Some(es) = base::get_exprs_from_tts(cx, sp, tts) else {\n+    let Some(es) = base::get_exprs_from_tts(cx, tts) else {\n         return DummyResult::any(sp);\n     };\n     let mut accumulator = Vec::new();"}, {"sha": "a7283ea601b19e4c20a846beb76663562001da0f", "filename": "compiler/rustc_builtin_macros/src/env.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f9f097cb8b6c27a7e0d7a916e6911fc1f5ecd81/compiler%2Frustc_builtin_macros%2Fsrc%2Fenv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f9f097cb8b6c27a7e0d7a916e6911fc1f5ecd81/compiler%2Frustc_builtin_macros%2Fsrc%2Fenv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fenv.rs?ref=2f9f097cb8b6c27a7e0d7a916e6911fc1f5ecd81", "patch": "@@ -52,7 +52,7 @@ pub fn expand_env<'cx>(\n     sp: Span,\n     tts: TokenStream,\n ) -> Box<dyn base::MacResult + 'cx> {\n-    let mut exprs = match get_exprs_from_tts(cx, sp, tts) {\n+    let mut exprs = match get_exprs_from_tts(cx, tts) {\n         Some(exprs) if exprs.is_empty() => {\n             cx.span_err(sp, \"env! takes 1 or 2 arguments\");\n             return DummyResult::any(sp);"}, {"sha": "df0e8ae5dd8f5d11bb0577d502ef388e44d132e3", "filename": "compiler/rustc_error_messages/locales/en-US/expand.ftl", "status": "modified", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/2f9f097cb8b6c27a7e0d7a916e6911fc1f5ecd81/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fexpand.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/2f9f097cb8b6c27a7e0d7a916e6911fc1f5ecd81/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fexpand.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Fexpand.ftl?ref=2f9f097cb8b6c27a7e0d7a916e6911fc1f5ecd81", "patch": "@@ -20,3 +20,110 @@ expand_var_still_repeating =\n     variable '{$ident}' is still repeating at this depth\n \n expand_meta_var_dif_seq_matchers = {$msg}\n+\n+expand_macro_const_stability =\n+    macros cannot have const stability attributes\n+    .label = invalid const stability attribute\n+    .label2 = const stability attribute affects this macro\n+\n+expand_macro_body_stability =\n+    macros cannot have body stability attributes\n+    .label = invalid body stability attribute\n+    .label2 = body stability attribute affects this macro\n+\n+expand_resolve_relative_path =\n+    cannot resolve relative path in non-file source `{$path}`\n+\n+expand_attr_no_arguments =\n+    attribute must have either one or two arguments\n+\n+expand_not_a_meta_item =\n+    not a meta item\n+\n+expand_only_one_word =\n+    must only be one word\n+\n+expand_cannot_be_name_of_macro =\n+    `{$trait_ident}` cannot be a name of {$macro_type} macro\n+\n+expand_arg_not_attributes =\n+    second argument must be `attributes`\n+\n+expand_attributes_wrong_form =\n+    attribute must be of form: `attributes(foo, bar)`\n+\n+expand_attribute_meta_item =\n+    attribute must be a meta item, not a literal\n+\n+expand_attribute_single_word =\n+    attribute must only be a single word\n+\n+expand_helper_attribute_name_invalid =\n+    `{$name}` cannot be a name of derive helper attribute\n+\n+expand_expected_comma_in_list =\n+    expected token: `,`\n+\n+expand_only_one_argument =\n+    {$name} takes 1 argument\n+\n+expand_takes_no_arguments =\n+    {$name} takes no arguments\n+\n+expand_feature_included_in_edition =\n+    the feature `{$feature}` is included in the Rust {$edition} edition\n+\n+expand_feature_removed =\n+    feature has been removed\n+    .label = feature has been removed\n+    .reason = {$reason}\n+\n+expand_feature_not_allowed =\n+    the feature `{$name}` is not in the list of allowed features\n+\n+expand_recursion_limit_reached =\n+    recursion limit reached while expanding `{$descr}`\n+    .help = consider increasing the recursion limit by adding a `#![recursion_limit = \"{$suggested_limit}\"]` attribute to your crate (`{$crate_name}`)\n+\n+expand_malformed_feature_attribute =\n+    malformed `feature` attribute input\n+    .expected = expected just one word\n+\n+expand_remove_expr_not_supported =\n+    removing an expression is not supported in this position\n+\n+expand_invalid_cfg_no_parens = `cfg` is not followed by parentheses\n+expand_invalid_cfg_no_predicate = `cfg` predicate is not specified\n+expand_invalid_cfg_multiple_predicates = multiple `cfg` predicates are specified\n+expand_invalid_cfg_predicate_literal = `cfg` predicate key cannot be a literal\n+expand_invalid_cfg_expected_syntax = expected syntax is\n+\n+expand_wrong_fragment_kind =\n+    non-{$kind} macro in {$kind} position: {$name}\n+\n+expand_unsupported_key_value =\n+    key-value macro attributes are not supported\n+\n+expand_incomplete_parse =\n+    macro expansion ignores token `{$token}` and any following\n+    .label = caused by the macro expansion here\n+    .note = the usage of `{$macro_path}!` is likely invalid in {$kind_name} context\n+    .suggestion_add_semi = you might be missing a semicolon here\n+\n+expand_remove_node_not_supported =\n+    removing {$descr} is not supported in this position\n+\n+expand_module_circular =\n+    circular modules: {$modules}\n+\n+expand_module_in_block =\n+    cannot declare a non-inline module inside a block unless it has a path attribute\n+    .note = maybe `use` the module `{$name}` instead of redeclaring it\n+\n+expand_module_file_not_found =\n+    file not found for module `{$name}`\n+    .help = to create the module `{$name}`, create file \"{$default_path}\" or \"{$secondary_path}\"\n+\n+expand_module_multiple_candidates =\n+    file for module `{$name}` found at both \"{$default_path}\" and \"{$secondary_path}\"\n+    .help = delete or rename one of them to remove the ambiguity"}, {"sha": "cb39e997436e065948694c1536d35ac1737f3b04", "filename": "compiler/rustc_errors/src/diagnostic_impls.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2f9f097cb8b6c27a7e0d7a916e6911fc1f5ecd81/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f9f097cb8b6c27a7e0d7a916e6911fc1f5ecd81/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic_impls.rs?ref=2f9f097cb8b6c27a7e0d7a916e6911fc1f5ecd81", "patch": "@@ -152,6 +152,12 @@ impl IntoDiagnosticArg for ast::Path {\n     }\n }\n \n+impl IntoDiagnosticArg for &ast::Path {\n+    fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n+        DiagnosticArgValue::Str(Cow::Owned(pprust::path_to_string(self)))\n+    }\n+}\n+\n impl IntoDiagnosticArg for ast::token::Token {\n     fn into_diagnostic_arg(self) -> DiagnosticArgValue<'static> {\n         DiagnosticArgValue::Str(pprust::token_to_string(&self))"}, {"sha": "6f159663e80cfffd37e1be7866b7bdca8d78a694", "filename": "compiler/rustc_expand/src/base.rs", "status": "modified", "additions": 39, "deletions": 51, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/2f9f097cb8b6c27a7e0d7a916e6911fc1f5ecd81/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f9f097cb8b6c27a7e0d7a916e6911fc1f5ecd81/compiler%2Frustc_expand%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fbase.rs?ref=2f9f097cb8b6c27a7e0d7a916e6911fc1f5ecd81", "patch": "@@ -1,3 +1,11 @@\n+#![deny(rustc::untranslatable_diagnostic)]\n+\n+use crate::errors::{\n+    ArgumentNotAttributes, AttrNoArguments, AttributeMetaItem, AttributeSingleWord,\n+    AttributesWrongForm, CannotBeNameOfMacro, ExpectedCommaInList, HelperAttributeNameInvalid,\n+    MacroBodyStability, MacroConstStability, NotAMetaItem, OnlyOneArgument, OnlyOneWord,\n+    ResolveRelativePath, TakesNoArguments,\n+};\n use crate::expand::{self, AstFragment, Invocation};\n use crate::module::DirOwnership;\n \n@@ -789,26 +797,16 @@ impl SyntaxExtension {\n             .unwrap_or_else(|| (None, helper_attrs));\n         let (stability, const_stability, body_stability) = attr::find_stability(&sess, attrs, span);\n         if let Some((_, sp)) = const_stability {\n-            sess.parse_sess\n-                .span_diagnostic\n-                .struct_span_err(sp, \"macros cannot have const stability attributes\")\n-                .span_label(sp, \"invalid const stability attribute\")\n-                .span_label(\n-                    sess.source_map().guess_head_span(span),\n-                    \"const stability attribute affects this macro\",\n-                )\n-                .emit();\n+            sess.emit_err(MacroConstStability {\n+                span: sp,\n+                head_span: sess.source_map().guess_head_span(span),\n+            });\n         }\n         if let Some((_, sp)) = body_stability {\n-            sess.parse_sess\n-                .span_diagnostic\n-                .struct_span_err(sp, \"macros cannot have body stability attributes\")\n-                .span_label(sp, \"invalid body stability attribute\")\n-                .span_label(\n-                    sess.source_map().guess_head_span(span),\n-                    \"body stability attribute affects this macro\",\n-                )\n-                .emit();\n+            sess.emit_err(MacroBodyStability {\n+                span: sp,\n+                head_span: sess.source_map().guess_head_span(span),\n+            });\n         }\n \n         SyntaxExtension {\n@@ -1200,13 +1198,11 @@ pub fn resolve_path(\n                 .expect(\"attempting to resolve a file path in an external file\"),\n             FileName::DocTest(path, _) => path,\n             other => {\n-                return Err(parse_sess.span_diagnostic.struct_span_err(\n+                return Err(ResolveRelativePath {\n                     span,\n-                    &format!(\n-                        \"cannot resolve relative path in non-file source `{}`\",\n-                        parse_sess.source_map().filename_for_diagnostics(&other)\n-                    ),\n-                ));\n+                    path: parse_sess.source_map().filename_for_diagnostics(&other).to_string(),\n+                }\n+                .into_diagnostic(&parse_sess.span_diagnostic));\n             }\n         };\n         result.pop();\n@@ -1222,6 +1218,8 @@ pub fn resolve_path(\n /// The returned bool indicates whether an applicable suggestion has already been\n /// added to the diagnostic to avoid emitting multiple suggestions. `Err(None)`\n /// indicates that an ast error was encountered.\n+// FIXME(Nilstrieb) Make this function setup translatable\n+#[allow(rustc::untranslatable_diagnostic)]\n pub fn expr_to_spanned_string<'a>(\n     cx: &'a mut ExtCtxt<'_>,\n     expr: P<ast::Expr>,\n@@ -1280,9 +1278,9 @@ pub fn expr_to_string(\n /// compilation should call\n /// `cx.parse_sess.span_diagnostic.abort_if_errors()` (this should be\n /// done as rarely as possible).\n-pub fn check_zero_tts(cx: &ExtCtxt<'_>, sp: Span, tts: TokenStream, name: &str) {\n+pub fn check_zero_tts(cx: &ExtCtxt<'_>, span: Span, tts: TokenStream, name: &str) {\n     if !tts.is_empty() {\n-        cx.span_err(sp, &format!(\"{} takes no arguments\", name));\n+        cx.emit_err(TakesNoArguments { span, name });\n     }\n }\n \n@@ -1304,31 +1302,27 @@ pub fn parse_expr(p: &mut parser::Parser<'_>) -> Option<P<ast::Expr>> {\n /// expect exactly one string literal, or emit an error and return `None`.\n pub fn get_single_str_from_tts(\n     cx: &mut ExtCtxt<'_>,\n-    sp: Span,\n+    span: Span,\n     tts: TokenStream,\n     name: &str,\n ) -> Option<Symbol> {\n     let mut p = cx.new_parser_from_tts(tts);\n     if p.token == token::Eof {\n-        cx.span_err(sp, &format!(\"{} takes 1 argument\", name));\n+        cx.emit_err(OnlyOneArgument { span, name });\n         return None;\n     }\n     let ret = parse_expr(&mut p)?;\n     let _ = p.eat(&token::Comma);\n \n     if p.token != token::Eof {\n-        cx.span_err(sp, &format!(\"{} takes 1 argument\", name));\n+        cx.emit_err(OnlyOneArgument { span, name });\n     }\n     expr_to_string(cx, ret, \"argument must be a string literal\").map(|(s, _)| s)\n }\n \n /// Extracts comma-separated expressions from `tts`.\n /// On error, emit it, and return `None`.\n-pub fn get_exprs_from_tts(\n-    cx: &mut ExtCtxt<'_>,\n-    sp: Span,\n-    tts: TokenStream,\n-) -> Option<Vec<P<ast::Expr>>> {\n+pub fn get_exprs_from_tts(cx: &mut ExtCtxt<'_>, tts: TokenStream) -> Option<Vec<P<ast::Expr>>> {\n     let mut p = cx.new_parser_from_tts(tts);\n     let mut es = Vec::new();\n     while p.token != token::Eof {\n@@ -1343,7 +1337,7 @@ pub fn get_exprs_from_tts(\n             continue;\n         }\n         if p.token != token::Eof {\n-            cx.span_err(sp, \"expected token: `,`\");\n+            cx.emit_err(ExpectedCommaInList { span: p.token.span });\n             return None;\n         }\n     }\n@@ -1353,64 +1347,58 @@ pub fn get_exprs_from_tts(\n pub fn parse_macro_name_and_helper_attrs(\n     diag: &rustc_errors::Handler,\n     attr: &Attribute,\n-    descr: &str,\n+    macro_type: &str,\n ) -> Option<(Symbol, Vec<Symbol>)> {\n     // Once we've located the `#[proc_macro_derive]` attribute, verify\n     // that it's of the form `#[proc_macro_derive(Foo)]` or\n     // `#[proc_macro_derive(Foo, attributes(A, ..))]`\n     let list = attr.meta_item_list()?;\n     if list.len() != 1 && list.len() != 2 {\n-        diag.span_err(attr.span, \"attribute must have either one or two arguments\");\n+        diag.emit_err(AttrNoArguments { span: attr.span });\n         return None;\n     }\n     let Some(trait_attr) = list[0].meta_item() else {\n-        diag.span_err(list[0].span(), \"not a meta item\");\n+        diag.emit_err(NotAMetaItem {span: list[0].span()});\n         return None;\n     };\n     let trait_ident = match trait_attr.ident() {\n         Some(trait_ident) if trait_attr.is_word() => trait_ident,\n         _ => {\n-            diag.span_err(trait_attr.span, \"must only be one word\");\n+            diag.emit_err(OnlyOneWord { span: trait_attr.span });\n             return None;\n         }\n     };\n \n     if !trait_ident.name.can_be_raw() {\n-        diag.span_err(\n-            trait_attr.span,\n-            &format!(\"`{}` cannot be a name of {} macro\", trait_ident, descr),\n-        );\n+        diag.emit_err(CannotBeNameOfMacro { span: trait_attr.span, trait_ident, macro_type });\n     }\n \n     let attributes_attr = list.get(1);\n     let proc_attrs: Vec<_> = if let Some(attr) = attributes_attr {\n         if !attr.has_name(sym::attributes) {\n-            diag.span_err(attr.span(), \"second argument must be `attributes`\");\n+            diag.emit_err(ArgumentNotAttributes { span: attr.span() });\n         }\n         attr.meta_item_list()\n             .unwrap_or_else(|| {\n-                diag.span_err(attr.span(), \"attribute must be of form: `attributes(foo, bar)`\");\n+                diag.emit_err(AttributesWrongForm { span: attr.span() });\n                 &[]\n             })\n             .iter()\n             .filter_map(|attr| {\n                 let Some(attr) = attr.meta_item() else {\n-                    diag.span_err(attr.span(), \"not a meta item\");\n+                    diag.emit_err(AttributeMetaItem { span: attr.span() });\n                     return None;\n                 };\n \n                 let ident = match attr.ident() {\n                     Some(ident) if attr.is_word() => ident,\n                     _ => {\n-                        diag.span_err(attr.span, \"must only be one word\");\n+                        diag.emit_err(AttributeSingleWord { span: attr.span });\n                         return None;\n                     }\n                 };\n                 if !ident.name.can_be_raw() {\n-                    diag.span_err(\n-                        attr.span,\n-                        &format!(\"`{}` cannot be a name of derive helper attribute\", ident),\n-                    );\n+                    diag.emit_err(HelperAttributeNameInvalid { span: attr.span, name: ident });\n                 }\n \n                 Some(ident.name)"}, {"sha": "f4c6f3386ade23ce244e629ce715ce72a37d83e7", "filename": "compiler/rustc_expand/src/config.rs", "status": "modified", "additions": 47, "deletions": 59, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/2f9f097cb8b6c27a7e0d7a916e6911fc1f5ecd81/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f9f097cb8b6c27a7e0d7a916e6911fc1f5ecd81/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fconfig.rs?ref=2f9f097cb8b6c27a7e0d7a916e6911fc1f5ecd81", "patch": "@@ -1,5 +1,9 @@\n //! Conditional compilation stripping.\n \n+use crate::errors::{\n+    FeatureIncludedInEdition, FeatureNotAllowed, FeatureRemoved, FeatureRemovedReason, InvalidCfg,\n+    MalformedFeatureAttribute, MalformedFeatureAttributeHelp, RemoveExprNotSupported,\n+};\n use rustc_ast::ptr::P;\n use rustc_ast::token::{Delimiter, Token, TokenKind};\n use rustc_ast::tokenstream::{AttrTokenStream, AttrTokenTree};\n@@ -10,7 +14,6 @@ use rustc_ast::{self as ast, AttrStyle, Attribute, HasAttrs, HasTokens, MetaItem\n use rustc_attr as attr;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::map_in_place::MapInPlace;\n-use rustc_errors::{error_code, struct_span_err, Applicability, Handler};\n use rustc_feature::{Feature, Features, State as FeatureState};\n use rustc_feature::{\n     ACCEPTED_FEATURES, ACTIVE_FEATURES, REMOVED_FEATURES, STABLE_REMOVED_FEATURES,\n@@ -33,18 +36,12 @@ pub struct StripUnconfigured<'a> {\n     pub lint_node_id: NodeId,\n }\n \n-fn get_features(\n-    sess: &Session,\n-    span_handler: &Handler,\n-    krate_attrs: &[ast::Attribute],\n-) -> Features {\n-    fn feature_removed(span_handler: &Handler, span: Span, reason: Option<&str>) {\n-        let mut err = struct_span_err!(span_handler, span, E0557, \"feature has been removed\");\n-        err.span_label(span, \"feature has been removed\");\n-        if let Some(reason) = reason {\n-            err.note(reason);\n-        }\n-        err.emit();\n+fn get_features(sess: &Session, krate_attrs: &[ast::Attribute]) -> Features {\n+    fn feature_removed(sess: &Session, span: Span, reason: Option<&str>) {\n+        sess.emit_err(FeatureRemoved {\n+            span,\n+            reason: reason.map(|reason| FeatureRemovedReason { reason }),\n+        });\n     }\n \n     fn active_features_up_to(edition: Edition) -> impl Iterator<Item = &'static Feature> {\n@@ -117,34 +114,34 @@ fn get_features(\n             continue;\n         };\n \n-        let bad_input = |span| {\n-            struct_span_err!(span_handler, span, E0556, \"malformed `feature` attribute input\")\n-        };\n-\n         for mi in list {\n             let name = match mi.ident() {\n                 Some(ident) if mi.is_word() => ident.name,\n                 Some(ident) => {\n-                    bad_input(mi.span())\n-                        .span_suggestion(\n-                            mi.span(),\n-                            \"expected just one word\",\n-                            ident.name,\n-                            Applicability::MaybeIncorrect,\n-                        )\n-                        .emit();\n+                    sess.emit_err(MalformedFeatureAttribute {\n+                        span: mi.span(),\n+                        help: MalformedFeatureAttributeHelp::Suggestion {\n+                            span: mi.span(),\n+                            suggestion: ident.name,\n+                        },\n+                    });\n                     continue;\n                 }\n                 None => {\n-                    bad_input(mi.span()).span_label(mi.span(), \"expected just one word\").emit();\n+                    sess.emit_err(MalformedFeatureAttribute {\n+                        span: mi.span(),\n+                        help: MalformedFeatureAttributeHelp::Label { span: mi.span() },\n+                    });\n                     continue;\n                 }\n             };\n \n-            if let Some(edition) = edition_enabled_features.get(&name) {\n-                let msg =\n-                    &format!(\"the feature `{}` is included in the Rust {} edition\", name, edition);\n-                span_handler.struct_span_warn_with_code(mi.span(), msg, error_code!(E0705)).emit();\n+            if let Some(&edition) = edition_enabled_features.get(&name) {\n+                sess.emit_warning(FeatureIncludedInEdition {\n+                    span: mi.span(),\n+                    feature: name,\n+                    edition,\n+                });\n                 continue;\n             }\n \n@@ -159,7 +156,7 @@ fn get_features(\n                 if let FeatureState::Removed { reason } | FeatureState::Stabilized { reason } =\n                     state\n                 {\n-                    feature_removed(span_handler, mi.span(), *reason);\n+                    feature_removed(sess, mi.span(), *reason);\n                     continue;\n                 }\n             }\n@@ -173,14 +170,7 @@ fn get_features(\n \n             if let Some(allowed) = sess.opts.unstable_opts.allow_features.as_ref() {\n                 if allowed.iter().all(|f| name.as_str() != f) {\n-                    struct_span_err!(\n-                        span_handler,\n-                        mi.span(),\n-                        E0725,\n-                        \"the feature `{}` is not in the list of allowed features\",\n-                        name\n-                    )\n-                    .emit();\n+                    sess.emit_err(FeatureNotAllowed { span: mi.span(), name });\n                     continue;\n                 }\n             }\n@@ -221,7 +211,7 @@ pub fn features(\n         }\n         Some(attrs) => {\n             krate.attrs = attrs;\n-            let features = get_features(sess, diag, &krate.attrs);\n+            let features = get_features(sess, &krate.attrs);\n             if err_count == diag.err_count() {\n                 // Avoid reconfiguring malformed `cfg_attr`s.\n                 strip_unconfigured.features = Some(&features);\n@@ -503,8 +493,7 @@ impl<'a> StripUnconfigured<'a> {\n         // N.B., this is intentionally not part of the visit_expr() function\n         //     in order for filter_map_expr() to be able to avoid this check\n         if let Some(attr) = expr.attrs().iter().find(|a| is_cfg(*a)) {\n-            let msg = \"removing an expression is not supported in this position\";\n-            self.sess.parse_sess.span_diagnostic.span_err(attr.span, msg);\n+            self.sess.emit_err(RemoveExprNotSupported { span: attr.span });\n         }\n \n         self.process_cfg_attrs(expr);\n@@ -513,27 +502,26 @@ impl<'a> StripUnconfigured<'a> {\n }\n \n pub fn parse_cfg<'a>(meta_item: &'a MetaItem, sess: &Session) -> Option<&'a MetaItem> {\n-    let error = |span, msg, suggestion: &str| {\n-        let mut err = sess.parse_sess.span_diagnostic.struct_span_err(span, msg);\n-        if !suggestion.is_empty() {\n-            err.span_suggestion(\n-                span,\n-                \"expected syntax is\",\n-                suggestion,\n-                Applicability::HasPlaceholders,\n-            );\n-        }\n-        err.emit();\n-        None\n-    };\n     let span = meta_item.span;\n     match meta_item.meta_item_list() {\n-        None => error(span, \"`cfg` is not followed by parentheses\", \"cfg(/* predicate */)\"),\n-        Some([]) => error(span, \"`cfg` predicate is not specified\", \"\"),\n-        Some([_, .., l]) => error(l.span(), \"multiple `cfg` predicates are specified\", \"\"),\n+        None => {\n+            sess.emit_err(InvalidCfg::NotFollowedByParens { span });\n+            None\n+        }\n+        Some([]) => {\n+            sess.emit_err(InvalidCfg::NoPredicate { span });\n+            None\n+        }\n+        Some([_, .., l]) => {\n+            sess.emit_err(InvalidCfg::MultiplePredicates { span: l.span() });\n+            None\n+        }\n         Some([single]) => match single.meta_item() {\n             Some(meta_item) => Some(meta_item),\n-            None => error(single.span(), \"`cfg` predicate key cannot be a literal\", \"\"),\n+            None => {\n+                sess.emit_err(InvalidCfg::PredicateLiteral { span: single.span() });\n+                None\n+            }\n         },\n     }\n }"}, {"sha": "afe5169d3f5c0b616754ddf8ac7fa80ebd12b894", "filename": "compiler/rustc_expand/src/errors.rs", "status": "modified", "additions": 324, "deletions": 2, "changes": 326, "blob_url": "https://github.com/rust-lang/rust/blob/2f9f097cb8b6c27a7e0d7a916e6911fc1f5ecd81/compiler%2Frustc_expand%2Fsrc%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f9f097cb8b6c27a7e0d7a916e6911fc1f5ecd81/compiler%2Frustc_expand%2Fsrc%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Ferrors.rs?ref=2f9f097cb8b6c27a7e0d7a916e6911fc1f5ecd81", "patch": "@@ -1,6 +1,10 @@\n+use rustc_ast::ast;\n use rustc_macros::Diagnostic;\n-use rustc_span::symbol::MacroRulesNormalizedIdent;\n-use rustc_span::Span;\n+use rustc_session::Limit;\n+use rustc_span::edition::Edition;\n+use rustc_span::symbol::{Ident, MacroRulesNormalizedIdent};\n+use rustc_span::{Span, Symbol};\n+use std::borrow::Cow;\n \n #[derive(Diagnostic)]\n #[diag(expand_expr_repeat_no_syntax_vars)]\n@@ -46,3 +50,321 @@ pub(crate) struct MetaVarsDifSeqMatchers {\n     pub span: Span,\n     pub msg: String,\n }\n+\n+#[derive(Diagnostic)]\n+#[diag(expand_resolve_relative_path)]\n+pub(crate) struct ResolveRelativePath {\n+    #[primary_span]\n+    pub span: Span,\n+    pub path: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(expand_macro_const_stability)]\n+pub(crate) struct MacroConstStability {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    #[label(label2)]\n+    pub head_span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(expand_macro_body_stability)]\n+pub(crate) struct MacroBodyStability {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    #[label(label2)]\n+    pub head_span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(expand_attr_no_arguments)]\n+pub(crate) struct AttrNoArguments {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(expand_not_a_meta_item)]\n+pub(crate) struct NotAMetaItem {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(expand_only_one_word)]\n+pub(crate) struct OnlyOneWord {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(expand_cannot_be_name_of_macro)]\n+pub(crate) struct CannotBeNameOfMacro<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub trait_ident: Ident,\n+    pub macro_type: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(expand_arg_not_attributes)]\n+pub(crate) struct ArgumentNotAttributes {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(expand_attributes_wrong_form)]\n+pub(crate) struct AttributesWrongForm {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(expand_attribute_meta_item)]\n+pub(crate) struct AttributeMetaItem {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(expand_attribute_single_word)]\n+pub(crate) struct AttributeSingleWord {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(expand_helper_attribute_name_invalid)]\n+pub(crate) struct HelperAttributeNameInvalid {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Ident,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(expand_expected_comma_in_list)]\n+pub(crate) struct ExpectedCommaInList {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(expand_only_one_argument)]\n+pub(crate) struct OnlyOneArgument<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(expand_takes_no_arguments)]\n+pub(crate) struct TakesNoArguments<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(expand_feature_included_in_edition, code = \"E0705\")]\n+pub(crate) struct FeatureIncludedInEdition {\n+    #[primary_span]\n+    pub span: Span,\n+    pub feature: Symbol,\n+    pub edition: Edition,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(expand_feature_removed, code = \"E0557\")]\n+pub(crate) struct FeatureRemoved<'a> {\n+    #[primary_span]\n+    #[label]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub reason: Option<FeatureRemovedReason<'a>>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[note(reason)]\n+pub(crate) struct FeatureRemovedReason<'a> {\n+    pub reason: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(expand_feature_not_allowed, code = \"E0725\")]\n+pub(crate) struct FeatureNotAllowed {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Symbol,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(expand_recursion_limit_reached)]\n+#[help]\n+pub(crate) struct RecursionLimitReached<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub descr: String,\n+    pub suggested_limit: Limit,\n+    pub crate_name: &'a str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(expand_malformed_feature_attribute, code = \"E0556\")]\n+pub(crate) struct MalformedFeatureAttribute {\n+    #[primary_span]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub help: MalformedFeatureAttributeHelp,\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub(crate) enum MalformedFeatureAttributeHelp {\n+    #[label(expected)]\n+    Label {\n+        #[primary_span]\n+        span: Span,\n+    },\n+    #[suggestion(expected, code = \"{suggestion}\", applicability = \"maybe-incorrect\")]\n+    Suggestion {\n+        #[primary_span]\n+        span: Span,\n+        suggestion: Symbol,\n+    },\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(expand_remove_expr_not_supported)]\n+pub(crate) struct RemoveExprNotSupported {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+pub(crate) enum InvalidCfg {\n+    #[diag(expand_invalid_cfg_no_parens)]\n+    NotFollowedByParens {\n+        #[primary_span]\n+        #[suggestion(\n+            expand_invalid_cfg_expected_syntax,\n+            code = \"cfg(/* predicate */)\",\n+            applicability = \"has-placeholders\"\n+        )]\n+        span: Span,\n+    },\n+    #[diag(expand_invalid_cfg_no_predicate)]\n+    NoPredicate {\n+        #[primary_span]\n+        #[suggestion(\n+            expand_invalid_cfg_expected_syntax,\n+            code = \"cfg(/* predicate */)\",\n+            applicability = \"has-placeholders\"\n+        )]\n+        span: Span,\n+    },\n+    #[diag(expand_invalid_cfg_multiple_predicates)]\n+    MultiplePredicates {\n+        #[primary_span]\n+        span: Span,\n+    },\n+    #[diag(expand_invalid_cfg_predicate_literal)]\n+    PredicateLiteral {\n+        #[primary_span]\n+        span: Span,\n+    },\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(expand_wrong_fragment_kind)]\n+pub(crate) struct WrongFragmentKind<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub kind: &'a str,\n+    pub name: &'a ast::Path,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(expand_unsupported_key_value)]\n+pub(crate) struct UnsupportedKeyValue {\n+    #[primary_span]\n+    pub span: Span,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(expand_incomplete_parse)]\n+#[note]\n+pub(crate) struct IncompleteParse<'a> {\n+    #[primary_span]\n+    pub span: Span,\n+    pub token: Cow<'a, str>,\n+    #[label]\n+    pub label_span: Span,\n+    pub macro_path: &'a ast::Path,\n+    pub kind_name: &'a str,\n+\n+    #[suggestion(\n+        suggestion_add_semi,\n+        style = \"verbose\",\n+        code = \";\",\n+        applicability = \"maybe-incorrect\"\n+    )]\n+    pub add_semicolon: Option<Span>,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(expand_remove_node_not_supported)]\n+pub(crate) struct RemoveNodeNotSupported {\n+    #[primary_span]\n+    pub span: Span,\n+    pub descr: &'static str,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(expand_module_circular)]\n+pub(crate) struct ModuleCircular {\n+    #[primary_span]\n+    pub span: Span,\n+    pub modules: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(expand_module_in_block)]\n+pub(crate) struct ModuleInBlock {\n+    #[primary_span]\n+    pub span: Span,\n+    #[subdiagnostic]\n+    pub name: Option<ModuleInBlockName>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+#[note(note)]\n+pub(crate) struct ModuleInBlockName {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Ident,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(expand_module_file_not_found, code = \"E0583\")]\n+#[help]\n+pub(crate) struct ModuleFileNotFound {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Ident,\n+    pub default_path: String,\n+    pub secondary_path: String,\n+}\n+\n+#[derive(Diagnostic)]\n+#[diag(expand_module_multiple_candidates, code = \"E0761\")]\n+#[help]\n+pub(crate) struct ModuleMultipleCandidates {\n+    #[primary_span]\n+    pub span: Span,\n+    pub name: Ident,\n+    pub default_path: String,\n+    pub secondary_path: String,\n+}"}, {"sha": "e26c16dcd7ee7784e4597cddbb6f073c9ea56657", "filename": "compiler/rustc_expand/src/expand.rs", "status": "modified", "additions": 37, "deletions": 49, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/2f9f097cb8b6c27a7e0d7a916e6911fc1f5ecd81/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f9f097cb8b6c27a7e0d7a916e6911fc1f5ecd81/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fexpand.rs?ref=2f9f097cb8b6c27a7e0d7a916e6911fc1f5ecd81", "patch": "@@ -1,5 +1,9 @@\n use crate::base::*;\n use crate::config::StripUnconfigured;\n+use crate::errors::{\n+    IncompleteParse, RecursionLimitReached, RemoveExprNotSupported, RemoveNodeNotSupported,\n+    UnsupportedKeyValue, WrongFragmentKind,\n+};\n use crate::hygiene::SyntaxContext;\n use crate::mbe::diagnostics::annotate_err_with_kind;\n use crate::module::{mod_dir_path, parse_external_mod, DirOwnership, ParsedExternalMod};\n@@ -18,7 +22,7 @@ use rustc_ast::{NestedMetaItem, NodeId, PatKind, StmtKind, TyKind};\n use rustc_ast_pretty::pprust;\n use rustc_data_structures::map_in_place::MapInPlace;\n use rustc_data_structures::sync::Lrc;\n-use rustc_errors::{Applicability, PResult};\n+use rustc_errors::PResult;\n use rustc_feature::Features;\n use rustc_parse::parser::{\n     AttemptLocalParseRecovery, CommaRecoveryMode, ForceCollect, Parser, RecoverColon, RecoverComma,\n@@ -606,29 +610,22 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             Limit(0) => Limit(2),\n             limit => limit * 2,\n         };\n-        self.cx\n-            .struct_span_err(\n-                expn_data.call_site,\n-                &format!(\"recursion limit reached while expanding `{}`\", expn_data.kind.descr()),\n-            )\n-            .help(&format!(\n-                \"consider increasing the recursion limit by adding a \\\n-                 `#![recursion_limit = \\\"{}\\\"]` attribute to your crate (`{}`)\",\n-                suggested_limit, self.cx.ecfg.crate_name,\n-            ))\n-            .emit();\n+\n+        self.cx.emit_err(RecursionLimitReached {\n+            span: expn_data.call_site,\n+            descr: expn_data.kind.descr(),\n+            suggested_limit,\n+            crate_name: &self.cx.ecfg.crate_name,\n+        });\n+\n         self.cx.trace_macros_diag();\n     }\n \n     /// A macro's expansion does not fit in this fragment kind.\n     /// For example, a non-type macro in a type position.\n     fn error_wrong_fragment_kind(&mut self, kind: AstFragmentKind, mac: &ast::MacCall, span: Span) {\n-        let msg = format!(\n-            \"non-{kind} macro in {kind} position: {path}\",\n-            kind = kind.name(),\n-            path = pprust::path_to_string(&mac.path),\n-        );\n-        self.cx.span_err(span, &msg);\n+        self.cx.emit_err(WrongFragmentKind { span, kind: kind.name(), name: &mac.path });\n+\n         self.cx.trace_macros_diag();\n     }\n \n@@ -707,7 +704,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                     };\n                     let attr_item = attr.unwrap_normal_item();\n                     if let AttrArgs::Eq(..) = attr_item.args {\n-                        self.cx.span_err(span, \"key-value macro attributes are not supported\");\n+                        self.cx.emit_err(UnsupportedKeyValue { span });\n                     }\n                     let inner_tokens = attr_item.args.inner_tokens();\n                     let Ok(tok_result) = expander.expand(self.cx, span, inner_tokens, tokens) else {\n@@ -729,9 +726,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n                                 }\n                             };\n                             if fragment_kind == AstFragmentKind::Expr && items.is_empty() {\n-                                let msg =\n-                                    \"removing an expression is not supported in this position\";\n-                                self.cx.span_err(span, msg);\n+                                self.cx.emit_err(RemoveExprNotSupported { span });\n                                 fragment_kind.dummy(span)\n                             } else {\n                                 fragment_kind.expect_from_annotatables(items)\n@@ -939,38 +934,32 @@ pub fn parse_ast_fragment<'a>(\n }\n \n pub fn ensure_complete_parse<'a>(\n-    this: &mut Parser<'a>,\n+    parser: &mut Parser<'a>,\n     macro_path: &ast::Path,\n     kind_name: &str,\n     span: Span,\n ) {\n-    if this.token != token::Eof {\n-        let token = pprust::token_to_string(&this.token);\n-        let msg = format!(\"macro expansion ignores token `{}` and any following\", token);\n+    if parser.token != token::Eof {\n+        let token = pprust::token_to_string(&parser.token);\n         // Avoid emitting backtrace info twice.\n-        let def_site_span = this.token.span.with_ctxt(SyntaxContext::root());\n-        let mut err = this.struct_span_err(def_site_span, &msg);\n-        err.span_label(span, \"caused by the macro expansion here\");\n-        let msg = format!(\n-            \"the usage of `{}!` is likely invalid in {} context\",\n-            pprust::path_to_string(macro_path),\n-            kind_name,\n-        );\n-        err.note(&msg);\n+        let def_site_span = parser.token.span.with_ctxt(SyntaxContext::root());\n \n-        let semi_span = this.sess.source_map().next_point(span);\n-        match this.sess.source_map().span_to_snippet(semi_span) {\n+        let semi_span = parser.sess.source_map().next_point(span);\n+        let add_semicolon = match parser.sess.source_map().span_to_snippet(semi_span) {\n             Ok(ref snippet) if &snippet[..] != \";\" && kind_name == \"expression\" => {\n-                err.span_suggestion(\n-                    span.shrink_to_hi(),\n-                    \"you might be missing a semicolon here\",\n-                    \";\",\n-                    Applicability::MaybeIncorrect,\n-                );\n+                Some(span.shrink_to_hi())\n             }\n-            _ => {}\n-        }\n-        err.emit();\n+            _ => None,\n+        };\n+\n+        parser.sess.emit_err(IncompleteParse {\n+            span: def_site_span,\n+            token,\n+            label_span: span,\n+            macro_path,\n+            kind_name,\n+            add_semicolon,\n+        });\n     }\n }\n \n@@ -1766,9 +1755,8 @@ impl<'a, 'b> InvocationCollector<'a, 'b> {\n                         if self.expand_cfg_true(node, attr, pos) {\n                             continue;\n                         }\n-                        let msg =\n-                            format!(\"removing {} is not supported in this position\", Node::descr());\n-                        self.cx.span_err(span, &msg);\n+\n+                        self.cx.emit_err(RemoveNodeNotSupported { span, descr: Node::descr() });\n                         continue;\n                     }\n                     sym::cfg_attr => {"}, {"sha": "897268566358a5b0fae9d68c08e4c6655a3e57b5", "filename": "compiler/rustc_expand/src/lib.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2f9f097cb8b6c27a7e0d7a916e6911fc1f5ecd81/compiler%2Frustc_expand%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f9f097cb8b6c27a7e0d7a916e6911fc1f5ecd81/compiler%2Frustc_expand%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Flib.rs?ref=2f9f097cb8b6c27a7e0d7a916e6911fc1f5ecd81", "patch": "@@ -10,6 +10,7 @@\n #![feature(rustc_attrs)]\n #![feature(try_blocks)]\n #![recursion_limit = \"256\"]\n+#![deny(rustc::untranslatable_diagnostic)]\n \n #[macro_use]\n extern crate rustc_macros;\n@@ -31,8 +32,13 @@ pub mod config;\n pub mod errors;\n pub mod expand;\n pub mod module;\n+\n+// FIXME(Nilstrieb) Translate proc_macro diagnostics\n+#[allow(rustc::untranslatable_diagnostic)]\n pub mod proc_macro;\n \n+// FIXME(Nilstrieb) Translate macro_rules diagnostics\n+#[allow(rustc::untranslatable_diagnostic)]\n pub(crate) mod mbe;\n \n // HACK(Centril, #64197): These shouldn't really be here."}, {"sha": "07f47a9c3a4f2c80f9097d22e55b2581440f5135", "filename": "compiler/rustc_expand/src/module.rs", "status": "modified", "additions": 34, "deletions": 46, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/2f9f097cb8b6c27a7e0d7a916e6911fc1f5ecd81/compiler%2Frustc_expand%2Fsrc%2Fmodule.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f9f097cb8b6c27a7e0d7a916e6911fc1f5ecd81/compiler%2Frustc_expand%2Fsrc%2Fmodule.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmodule.rs?ref=2f9f097cb8b6c27a7e0d7a916e6911fc1f5ecd81", "patch": "@@ -1,13 +1,17 @@\n use crate::base::ModuleData;\n+use crate::errors::{\n+    ModuleCircular, ModuleFileNotFound, ModuleInBlock, ModuleInBlockName, ModuleMultipleCandidates,\n+};\n use rustc_ast::ptr::P;\n use rustc_ast::{token, AttrVec, Attribute, Inline, Item, ModSpans};\n-use rustc_errors::{struct_span_err, DiagnosticBuilder, ErrorGuaranteed};\n+use rustc_errors::{DiagnosticBuilder, ErrorGuaranteed};\n use rustc_parse::new_parser_from_file;\n use rustc_parse::validate_attr;\n use rustc_session::parse::ParseSess;\n use rustc_session::Session;\n use rustc_span::symbol::{sym, Ident};\n use rustc_span::Span;\n+use std::iter::once;\n \n use std::path::{self, Path, PathBuf};\n \n@@ -242,57 +246,41 @@ pub fn default_submod_path<'a>(\n \n impl ModError<'_> {\n     fn report(self, sess: &Session, span: Span) -> ErrorGuaranteed {\n-        let diag = &sess.parse_sess.span_diagnostic;\n         match self {\n             ModError::CircularInclusion(file_paths) => {\n-                let mut msg = String::from(\"circular modules: \");\n-                for file_path in &file_paths {\n-                    msg.push_str(&file_path.display().to_string());\n-                    msg.push_str(\" -> \");\n-                }\n-                msg.push_str(&file_paths[0].display().to_string());\n-                diag.struct_span_err(span, &msg)\n-            }\n-            ModError::ModInBlock(ident) => {\n-                let msg = \"cannot declare a non-inline module inside a block unless it has a path attribute\";\n-                let mut err = diag.struct_span_err(span, msg);\n-                if let Some(ident) = ident {\n-                    let note =\n-                        format!(\"maybe `use` the module `{}` instead of redeclaring it\", ident);\n-                    err.span_note(span, &note);\n-                }\n-                err\n+                let path_to_string = |path: &PathBuf| path.display().to_string();\n+\n+                let paths = file_paths\n+                    .iter()\n+                    .map(path_to_string)\n+                    .chain(once(path_to_string(&file_paths[0])))\n+                    .collect::<Vec<_>>();\n+\n+                let modules = paths.join(\" -> \");\n+\n+                sess.emit_err(ModuleCircular { span, modules })\n             }\n-            ModError::FileNotFound(ident, default_path, secondary_path) => {\n-                let mut err = struct_span_err!(\n-                    diag,\n+            ModError::ModInBlock(ident) => sess.emit_err(ModuleInBlock {\n+                span,\n+                name: ident.map(|name| ModuleInBlockName { span, name }),\n+            }),\n+            ModError::FileNotFound(name, default_path, secondary_path) => {\n+                sess.emit_err(ModuleFileNotFound {\n                     span,\n-                    E0583,\n-                    \"file not found for module `{}`\",\n-                    ident,\n-                );\n-                err.help(&format!(\n-                    \"to create the module `{}`, create file \\\"{}\\\" or \\\"{}\\\"\",\n-                    ident,\n-                    default_path.display(),\n-                    secondary_path.display(),\n-                ));\n-                err\n+                    name,\n+                    default_path: default_path.display().to_string(),\n+                    secondary_path: secondary_path.display().to_string(),\n+                })\n             }\n-            ModError::MultipleCandidates(ident, default_path, secondary_path) => {\n-                let mut err = struct_span_err!(\n-                    diag,\n+            ModError::MultipleCandidates(name, default_path, secondary_path) => {\n+                sess.emit_err(ModuleMultipleCandidates {\n                     span,\n-                    E0761,\n-                    \"file for module `{}` found at both \\\"{}\\\" and \\\"{}\\\"\",\n-                    ident,\n-                    default_path.display(),\n-                    secondary_path.display(),\n-                );\n-                err.help(\"delete or rename one of them to remove the ambiguity\");\n-                err\n+                    name,\n+                    default_path: default_path.display().to_string(),\n+                    secondary_path: secondary_path.display().to_string(),\n+                })\n             }\n-            ModError::ParserError(err) => err,\n-        }.emit()\n+            ModError::ParserError(mut err) => err.emit(),\n+        }\n     }\n }"}, {"sha": "8f3bea29ffd2897ee30178c82969f485fcb9c8b3", "filename": "compiler/rustc_expand/src/tests.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2f9f097cb8b6c27a7e0d7a916e6911fc1f5ecd81/compiler%2Frustc_expand%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f9f097cb8b6c27a7e0d7a916e6911fc1f5ecd81/compiler%2Frustc_expand%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Ftests.rs?ref=2f9f097cb8b6c27a7e0d7a916e6911fc1f5ecd81", "patch": "@@ -154,6 +154,7 @@ fn test_harness(file_text: &str, span_labels: Vec<SpanLabel>, expected_output: &\n             false,\n         );\n         let handler = Handler::with_emitter(true, None, Box::new(emitter));\n+        #[allow(rustc::untranslatable_diagnostic)]\n         handler.span_err(msp, \"foo\");\n \n         assert!("}, {"sha": "14b7b17e04d3af476d66cc25a0c917976f8b0e53", "filename": "src/test/rustdoc-ui/doc-cfg.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2f9f097cb8b6c27a7e0d7a916e6911fc1f5ecd81/src%2Ftest%2Frustdoc-ui%2Fdoc-cfg.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f9f097cb8b6c27a7e0d7a916e6911fc1f5ecd81/src%2Ftest%2Frustdoc-ui%2Fdoc-cfg.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fdoc-cfg.stderr?ref=2f9f097cb8b6c27a7e0d7a916e6911fc1f5ecd81", "patch": "@@ -2,7 +2,7 @@ error: `cfg` predicate is not specified\n   --> $DIR/doc-cfg.rs:3:7\n    |\n LL | #[doc(cfg(), cfg(foo, bar))]\n-   |       ^^^^^\n+   |       ^^^^^ help: expected syntax is: `cfg(/* predicate */)`\n \n error: multiple `cfg` predicates are specified\n   --> $DIR/doc-cfg.rs:3:23\n@@ -14,7 +14,7 @@ error: `cfg` predicate is not specified\n   --> $DIR/doc-cfg.rs:7:7\n    |\n LL | #[doc(cfg())]\n-   |       ^^^^^\n+   |       ^^^^^ help: expected syntax is: `cfg(/* predicate */)`\n \n error: multiple `cfg` predicates are specified\n   --> $DIR/doc-cfg.rs:8:16"}, {"sha": "d5b4349c00f6f090078578a84fefd5fffa3fb040", "filename": "src/test/ui/conditional-compilation/cfg-attr-syntax-validation.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2f9f097cb8b6c27a7e0d7a916e6911fc1f5ecd81/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-attr-syntax-validation.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f9f097cb8b6c27a7e0d7a916e6911fc1f5ecd81/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-attr-syntax-validation.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-attr-syntax-validation.stderr?ref=2f9f097cb8b6c27a7e0d7a916e6911fc1f5ecd81", "patch": "@@ -14,7 +14,7 @@ error: `cfg` predicate is not specified\n   --> $DIR/cfg-attr-syntax-validation.rs:7:1\n    |\n LL | #[cfg()]\n-   | ^^^^^^^^\n+   | ^^^^^^^^ help: expected syntax is: `cfg(/* predicate */)`\n \n error: multiple `cfg` predicates are specified\n   --> $DIR/cfg-attr-syntax-validation.rs:10:10"}, {"sha": "36aba8aa08a0b18a95c35a0187a8c569e2e55f8c", "filename": "src/test/ui/macros/macro-in-expression-context.stderr", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2f9f097cb8b6c27a7e0d7a916e6911fc1f5ecd81/src%2Ftest%2Fui%2Fmacros%2Fmacro-in-expression-context.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f9f097cb8b6c27a7e0d7a916e6911fc1f5ecd81/src%2Ftest%2Fui%2Fmacros%2Fmacro-in-expression-context.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmacros%2Fmacro-in-expression-context.stderr?ref=2f9f097cb8b6c27a7e0d7a916e6911fc1f5ecd81", "patch": "@@ -5,11 +5,13 @@ LL |         assert_eq!(\"B\", \"B\");\n    |         ^^^^^^^^^\n ...\n LL |     foo!()\n-   |     ------- help: you might be missing a semicolon here: `;`\n-   |     |\n-   |     caused by the macro expansion here\n+   |     ------ caused by the macro expansion here\n    |\n    = note: the usage of `foo!` is likely invalid in expression context\n+help: you might be missing a semicolon here\n+   |\n+LL |     foo!();\n+   |           +\n \n warning: trailing semicolon in macro used in expression position\n   --> $DIR/macro-in-expression-context.rs:5:29"}, {"sha": "f96939bb6efcee107a0ebd29246c9fcbdb0cd2e4", "filename": "src/test/ui/proc-macro/attr-invalid-exprs.stderr", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2f9f097cb8b6c27a7e0d7a916e6911fc1f5ecd81/src%2Ftest%2Fui%2Fproc-macro%2Fattr-invalid-exprs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f9f097cb8b6c27a7e0d7a916e6911fc1f5ecd81/src%2Ftest%2Fui%2Fproc-macro%2Fattr-invalid-exprs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fattr-invalid-exprs.stderr?ref=2f9f097cb8b6c27a7e0d7a916e6911fc1f5ecd81", "patch": "@@ -8,21 +8,25 @@ error: macro expansion ignores token `,` and any following\n   --> $DIR/attr-invalid-exprs.rs:15:13\n    |\n LL |     let _ = #[duplicate] \"Hello, world!\";\n-   |             ^^^^^^^^^^^^- help: you might be missing a semicolon here: `;`\n-   |             |\n-   |             caused by the macro expansion here\n+   |             ^^^^^^^^^^^^ caused by the macro expansion here\n    |\n    = note: the usage of `duplicate!` is likely invalid in expression context\n+help: you might be missing a semicolon here\n+   |\n+LL |     let _ = #[duplicate]; \"Hello, world!\";\n+   |                         +\n \n error: macro expansion ignores token `,` and any following\n   --> $DIR/attr-invalid-exprs.rs:24:9\n    |\n LL |         #[duplicate]\n-   |         ^^^^^^^^^^^^- help: you might be missing a semicolon here: `;`\n-   |         |\n-   |         caused by the macro expansion here\n+   |         ^^^^^^^^^^^^ caused by the macro expansion here\n    |\n    = note: the usage of `duplicate!` is likely invalid in expression context\n+help: you might be missing a semicolon here\n+   |\n+LL |         #[duplicate];\n+   |                     +\n \n error: aborting due to 3 previous errors\n "}, {"sha": "9e40e4d9ba63e92d243403451274948859aa7ea0", "filename": "src/test/ui/proc-macro/attribute.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2f9f097cb8b6c27a7e0d7a916e6911fc1f5ecd81/src%2Ftest%2Fui%2Fproc-macro%2Fattribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f9f097cb8b6c27a7e0d7a916e6911fc1f5ecd81/src%2Ftest%2Fui%2Fproc-macro%2Fattribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fattribute.rs?ref=2f9f097cb8b6c27a7e0d7a916e6911fc1f5ecd81", "patch": "@@ -53,19 +53,19 @@ pub fn foo11(input: TokenStream) -> TokenStream { input }\n pub fn foo12(input: TokenStream) -> TokenStream { input }\n \n #[proc_macro_derive(d13, attributes(\"a\"))]\n-//~^ ERROR: not a meta item\n+//~^ ERROR: attribute must be a meta item, not a literal\n pub fn foo13(input: TokenStream) -> TokenStream { input }\n \n #[proc_macro_derive(d14, attributes(a = \"\"))]\n-//~^ ERROR: must only be one word\n+//~^ ERROR: attribute must only be a single word\n pub fn foo14(input: TokenStream) -> TokenStream { input }\n \n #[proc_macro_derive(d15, attributes(m::a))]\n-//~^ ERROR: must only be one word\n+//~^ ERROR: attribute must only be a single word\n pub fn foo15(input: TokenStream) -> TokenStream { input }\n \n #[proc_macro_derive(d16, attributes(a(b)))]\n-//~^ ERROR: must only be one word\n+//~^ ERROR: attribute must only be a single word\n pub fn foo16(input: TokenStream) -> TokenStream { input }\n \n #[proc_macro_derive(d17, attributes(self))]"}, {"sha": "3269aaf7f917eff367e0ac424f85b0aa802e04ec", "filename": "src/test/ui/proc-macro/attribute.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/2f9f097cb8b6c27a7e0d7a916e6911fc1f5ecd81/src%2Ftest%2Fui%2Fproc-macro%2Fattribute.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f9f097cb8b6c27a7e0d7a916e6911fc1f5ecd81/src%2Ftest%2Fui%2Fproc-macro%2Fattribute.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fattribute.stderr?ref=2f9f097cb8b6c27a7e0d7a916e6911fc1f5ecd81", "patch": "@@ -70,25 +70,25 @@ error: attribute must be of form: `attributes(foo, bar)`\n LL | #[proc_macro_derive(d12, attributes)]\n    |                          ^^^^^^^^^^\n \n-error: not a meta item\n+error: attribute must be a meta item, not a literal\n   --> $DIR/attribute.rs:55:37\n    |\n LL | #[proc_macro_derive(d13, attributes(\"a\"))]\n    |                                     ^^^\n \n-error: must only be one word\n+error: attribute must only be a single word\n   --> $DIR/attribute.rs:59:37\n    |\n LL | #[proc_macro_derive(d14, attributes(a = \"\"))]\n    |                                     ^^^^^^\n \n-error: must only be one word\n+error: attribute must only be a single word\n   --> $DIR/attribute.rs:63:37\n    |\n LL | #[proc_macro_derive(d15, attributes(m::a))]\n    |                                     ^^^^\n \n-error: must only be one word\n+error: attribute must only be a single word\n   --> $DIR/attribute.rs:67:37\n    |\n LL | #[proc_macro_derive(d16, attributes(a(b)))]"}, {"sha": "0004f2fe17f01ebfb65aaabbd86b376482eee382", "filename": "src/test/ui/proc-macro/expand-expr.stderr", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/2f9f097cb8b6c27a7e0d7a916e6911fc1f5ecd81/src%2Ftest%2Fui%2Fproc-macro%2Fexpand-expr.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2f9f097cb8b6c27a7e0d7a916e6911fc1f5ecd81/src%2Ftest%2Fui%2Fproc-macro%2Fexpand-expr.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fproc-macro%2Fexpand-expr.stderr?ref=2f9f097cb8b6c27a7e0d7a916e6911fc1f5ecd81", "patch": "@@ -26,21 +26,25 @@ error: macro expansion ignores token `hello` and any following\n   --> $DIR/expand-expr.rs:115:47\n    |\n LL | expand_expr_is!(\"string\", echo_tts!(\"string\"; hello));\n-   |                           --------------------^^^^^-- help: you might be missing a semicolon here: `;`\n-   |                           |\n-   |                           caused by the macro expansion here\n+   |                           --------------------^^^^^- caused by the macro expansion here\n    |\n    = note: the usage of `echo_tts!` is likely invalid in expression context\n+help: you might be missing a semicolon here\n+   |\n+LL | expand_expr_is!(\"string\", echo_tts!(\"string\"; hello););\n+   |                                                     +\n \n error: macro expansion ignores token `;` and any following\n   --> $DIR/expand-expr.rs:116:44\n    |\n LL | expand_expr_is!(\"string\", echo_pm!(\"string\"; hello));\n-   |                           -----------------^-------- help: you might be missing a semicolon here: `;`\n-   |                           |\n-   |                           caused by the macro expansion here\n+   |                           -----------------^------- caused by the macro expansion here\n    |\n    = note: the usage of `echo_pm!` is likely invalid in expression context\n+help: you might be missing a semicolon here\n+   |\n+LL | expand_expr_is!(\"string\", echo_pm!(\"string\"; hello););\n+   |                                                    +\n \n error: recursion limit reached while expanding `recursive_expand!`\n   --> $DIR/expand-expr.rs:124:16"}]}