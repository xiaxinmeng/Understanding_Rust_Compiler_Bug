{"sha": "9b8b8c6aebcc581bf2e74d9a0d3bf65a0ebb2742", "node_id": "MDY6Q29tbWl0NzI0NzEyOjliOGI4YzZhZWJjYzU4MWJmMmU3NGQ5YTBkM2JmNjVhMGViYjI3NDI=", "commit": {"author": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2017-07-04T13:12:11Z"}, "committer": {"name": "Felix S. Klock II", "email": "pnkfelix@pnkfx.org", "date": "2017-08-16T13:53:27Z"}, "message": "Move `DataFlowState::{each_bit,interpret_set}` method definitions to parent module.\n\nRefactored `each_bit`, which traverses a `IdxSet`, so that the bulk of\nits implementation lives in `rustc_data_structures`.", "tree": {"sha": "8f8537b30c2e5771a6608ae0b31f00f5c465cdff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8f8537b30c2e5771a6608ae0b31f00f5c465cdff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9b8b8c6aebcc581bf2e74d9a0d3bf65a0ebb2742", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9b8b8c6aebcc581bf2e74d9a0d3bf65a0ebb2742", "html_url": "https://github.com/rust-lang/rust/commit/9b8b8c6aebcc581bf2e74d9a0d3bf65a0ebb2742", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9b8b8c6aebcc581bf2e74d9a0d3bf65a0ebb2742/comments", "author": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pnkfelix", "id": 173127, "node_id": "MDQ6VXNlcjE3MzEyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/173127?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pnkfelix", "html_url": "https://github.com/pnkfelix", "followers_url": "https://api.github.com/users/pnkfelix/followers", "following_url": "https://api.github.com/users/pnkfelix/following{/other_user}", "gists_url": "https://api.github.com/users/pnkfelix/gists{/gist_id}", "starred_url": "https://api.github.com/users/pnkfelix/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pnkfelix/subscriptions", "organizations_url": "https://api.github.com/users/pnkfelix/orgs", "repos_url": "https://api.github.com/users/pnkfelix/repos", "events_url": "https://api.github.com/users/pnkfelix/events{/privacy}", "received_events_url": "https://api.github.com/users/pnkfelix/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3ef1afcf6b76cca826e5611ed218656b408e7aaa", "url": "https://api.github.com/repos/rust-lang/rust/commits/3ef1afcf6b76cca826e5611ed218656b408e7aaa", "html_url": "https://github.com/rust-lang/rust/commit/3ef1afcf6b76cca826e5611ed218656b408e7aaa"}], "stats": {"total": 106, "additions": 56, "deletions": 50}, "files": [{"sha": "4189089e20d11520c3693c70f2cbef17ee5d7630", "filename": "src/librustc_data_structures/indexed_set.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/9b8b8c6aebcc581bf2e74d9a0d3bf65a0ebb2742/src%2Flibrustc_data_structures%2Findexed_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b8b8c6aebcc581bf2e74d9a0d3bf65a0ebb2742/src%2Flibrustc_data_structures%2Findexed_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Findexed_set.rs?ref=9b8b8c6aebcc581bf2e74d9a0d3bf65a0ebb2742", "patch": "@@ -153,4 +153,38 @@ impl<T: Idx> IdxSet<T> {\n     pub fn subtract(&mut self, other: &IdxSet<T>) -> bool {\n         bitwise(self.words_mut(), other.words(), &Subtract)\n     }\n+\n+    /// Calls `f` on each index value held in this set, up to the\n+    /// bound `max_bits` on the size of universe of indexes.\n+    pub fn each_bit<F>(&self, max_bits: usize, f: F) where F: FnMut(T) {\n+        each_bit(self, max_bits, f)\n+    }\n+}\n+\n+fn each_bit<T: Idx, F>(words: &IdxSet<T>, max_bits: usize, mut f: F) where F: FnMut(T) {\n+    let usize_bits: usize = mem::size_of::<usize>() * 8;\n+\n+    for (word_index, &word) in words.words().iter().enumerate() {\n+        if word != 0 {\n+            let base_index = word_index * usize_bits;\n+            for offset in 0..usize_bits {\n+                let bit = 1 << offset;\n+                if (word & bit) != 0 {\n+                    // NB: we round up the total number of bits\n+                    // that we store in any given bit set so that\n+                    // it is an even multiple of usize::BITS. This\n+                    // means that there may be some stray bits at\n+                    // the end that do not correspond to any\n+                    // actual value; that's why we first check\n+                    // that we are in range of bits_per_block.\n+                    let bit_index = base_index + offset as usize;\n+                    if bit_index >= max_bits {\n+                        return;\n+                    } else {\n+                        f(Idx::new(bit_index));\n+                    }\n+                }\n+            }\n+        }\n+    }\n }"}, {"sha": "7ff4fbcf199e0fc19381942050e7597c7af0e5fe", "filename": "src/librustc_mir/dataflow/graphviz.rs", "status": "modified", "additions": 0, "deletions": 50, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/9b8b8c6aebcc581bf2e74d9a0d3bf65a0ebb2742/src%2Flibrustc_mir%2Fdataflow%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b8b8c6aebcc581bf2e74d9a0d3bf65a0ebb2742/src%2Flibrustc_mir%2Fdataflow%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fgraphviz.rs?ref=9b8b8c6aebcc581bf2e74d9a0d3bf65a0ebb2742", "patch": "@@ -13,7 +13,6 @@\n use syntax::ast::NodeId;\n use rustc::mir::{BasicBlock, Mir};\n use rustc_data_structures::bitslice::bits_to_string;\n-use rustc_data_structures::indexed_set::{IdxSet};\n use rustc_data_structures::indexed_vec::Idx;\n \n use dot;\n@@ -24,62 +23,13 @@ use std::fs::File;\n use std::io;\n use std::io::prelude::*;\n use std::marker::PhantomData;\n-use std::mem;\n use std::path::Path;\n \n use util;\n \n use super::{BitDenotation, DataflowState};\n use super::DataflowBuilder;\n \n-impl<O: BitDenotation> DataflowState<O> {\n-    fn each_bit<F>(&self, words: &IdxSet<O::Idx>, mut f: F)\n-        where F: FnMut(O::Idx) {\n-        //! Helper for iterating over the bits in a bitvector.\n-\n-        let bits_per_block = self.operator.bits_per_block();\n-        let usize_bits: usize = mem::size_of::<usize>() * 8;\n-\n-        for (word_index, &word) in words.words().iter().enumerate() {\n-            if word != 0 {\n-                let base_index = word_index * usize_bits;\n-                for offset in 0..usize_bits {\n-                    let bit = 1 << offset;\n-                    if (word & bit) != 0 {\n-                        // NB: we round up the total number of bits\n-                        // that we store in any given bit set so that\n-                        // it is an even multiple of usize::BITS. This\n-                        // means that there may be some stray bits at\n-                        // the end that do not correspond to any\n-                        // actual value; that's why we first check\n-                        // that we are in range of bits_per_block.\n-                        let bit_index = base_index + offset as usize;\n-                        if bit_index >= bits_per_block {\n-                            return;\n-                        } else {\n-                            f(O::Idx::new(bit_index));\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    pub fn interpret_set<'c, P>(&self,\n-                                o: &'c O,\n-                                words: &IdxSet<O::Idx>,\n-                                render_idx: &P)\n-                                -> Vec<&'c Debug>\n-        where P: Fn(&O, O::Idx) -> &Debug\n-    {\n-        let mut v = Vec::new();\n-        self.each_bit(words, |i| {\n-            v.push(render_idx(o, i));\n-        });\n-        v\n-    }\n-}\n-\n pub trait MirWithFlowState<'tcx> {\n     type BD: BitDenotation;\n     fn node_id(&self) -> NodeId;"}, {"sha": "08b8d332fa1a65bac7b465cc0b02b5eee0de09ba", "filename": "src/librustc_mir/dataflow/mod.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/9b8b8c6aebcc581bf2e74d9a0d3bf65a0ebb2742/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9b8b8c6aebcc581bf2e74d9a0d3bf65a0ebb2742/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmod.rs?ref=9b8b8c6aebcc581bf2e74d9a0d3bf65a0ebb2742", "patch": "@@ -293,6 +293,28 @@ pub struct DataflowState<O: BitDenotation>\n     pub(crate) operator: O,\n }\n \n+impl<O: BitDenotation> DataflowState<O> {\n+    pub fn each_bit<F>(&self, words: &IdxSet<O::Idx>, f: F) where F: FnMut(O::Idx)\n+    {\n+        let bits_per_block = self.operator.bits_per_block();\n+        words.each_bit(bits_per_block, f)\n+    }\n+\n+    pub fn interpret_set<'c, P>(&self,\n+                                o: &'c O,\n+                                words: &IdxSet<O::Idx>,\n+                                render_idx: &P)\n+                                -> Vec<&'c Debug>\n+        where P: Fn(&O, O::Idx) -> &Debug\n+    {\n+        let mut v = Vec::new();\n+        self.each_bit(words, |i| {\n+            v.push(render_idx(o, i));\n+        });\n+        v\n+    }\n+}\n+\n #[derive(Debug)]\n pub struct AllSets<E: Idx> {\n     /// Analysis bitwidth for each block."}]}