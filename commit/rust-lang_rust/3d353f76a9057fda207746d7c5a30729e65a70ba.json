{"sha": "3d353f76a9057fda207746d7c5a30729e65a70ba", "node_id": "MDY6Q29tbWl0NzI0NzEyOjNkMzUzZjc2YTkwNTdmZGEyMDc3NDZkN2M1YTMwNzI5ZTY1YTcwYmE=", "commit": {"author": {"name": "Rafael \u00c1vila de Esp\u00edndola", "email": "respindola@mozilla.com", "date": "2011-07-13T23:37:19Z"}, "committer": {"name": "Rafael \u00c1vila de Esp\u00edndola", "email": "respindola@mozilla.com", "date": "2011-07-13T23:37:19Z"}, "message": "First step in the typesystem rewrite:\nCreate the typedesc type in one place. That is where it will be named.", "tree": {"sha": "13e86243fdaee57ab8eb9f8e463c565243cba2d1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/13e86243fdaee57ab8eb9f8e463c565243cba2d1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3d353f76a9057fda207746d7c5a30729e65a70ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3d353f76a9057fda207746d7c5a30729e65a70ba", "html_url": "https://github.com/rust-lang/rust/commit/3d353f76a9057fda207746d7c5a30729e65a70ba", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3d353f76a9057fda207746d7c5a30729e65a70ba/comments", "author": null, "committer": null, "parents": [{"sha": "39151f2ad8d18554af1d6787bae0b02345e1d90b", "url": "https://api.github.com/repos/rust-lang/rust/commits/39151f2ad8d18554af1d6787bae0b02345e1d90b", "html_url": "https://github.com/rust-lang/rust/commit/39151f2ad8d18554af1d6787bae0b02345e1d90b"}], "stats": {"total": 168, "additions": 84, "deletions": 84}, "files": [{"sha": "5ab6e662fae49dadcf49abb7dc6ffa3e68baf0b1", "filename": "src/comp/back/upcall.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/3d353f76a9057fda207746d7c5a30729e65a70ba/src%2Fcomp%2Fback%2Fupcall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d353f76a9057fda207746d7c5a30729e65a70ba/src%2Fcomp%2Fback%2Fupcall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fback%2Fupcall.rs?ref=3d353f76a9057fda207746d7c5a30729e65a70ba", "patch": "@@ -17,7 +17,6 @@ import trans::T_ptr;\n import trans::T_size_t;\n import trans::T_str;\n import trans::T_taskptr;\n-import trans::T_tydesc;\n import trans::T_void;\n import lib::llvm::type_names;\n import lib::llvm::llvm::ModuleRef;\n@@ -62,16 +61,17 @@ type upcalls =\n         ValueRef ivec_resize_shared,\n         ValueRef ivec_spill_shared);\n \n-fn declare_upcalls(type_names tn, ModuleRef llmod) -> @upcalls {\n-    fn decl(type_names tn, ModuleRef llmod, str name, vec[TypeRef] tys,\n-            TypeRef rv) -> ValueRef {\n+fn declare_upcalls(type_names tn, TypeRef tydesc_type, ModuleRef llmod)\n+   -> @upcalls {\n+    fn decl(type_names tn, TypeRef tydesc_type, ModuleRef llmod, str name,\n+            vec[TypeRef] tys, TypeRef rv) -> ValueRef {\n         let TypeRef[] arg_tys = ~[T_taskptr(tn)];\n         for (TypeRef t in tys) { arg_tys += ~[t]; }\n         auto fn_ty = T_fn(arg_tys, rv);\n         ret trans::decl_cdecl_fn(llmod, \"upcall_\" + name, fn_ty);\n     }\n-    auto dv = bind decl(tn, llmod, _, _, T_void());\n-    auto d = bind decl(tn, llmod, _, _, _);\n+    auto dv = bind decl(tn, tydesc_type, llmod, _, _, T_void());\n+    auto d = bind decl(tn, tydesc_type, llmod, _, _, _);\n     // FIXME: Sigh:.. remove this when I fix the typechecker pushdown.\n     // --pcwalton\n \n@@ -98,27 +98,27 @@ fn declare_upcalls(type_names tn, ModuleRef llmod) -> @upcalls {\n              _fail=dv(\"fail\", [T_ptr(T_i8()), T_ptr(T_i8()), T_size_t()]),\n              kill=dv(\"kill\", [T_taskptr(tn)]),\n              exit=dv(\"exit\", empty_vec),\n-             malloc=d(\"malloc\", [T_size_t(), T_ptr(T_tydesc(tn))],\n+             malloc=d(\"malloc\", [T_size_t(), T_ptr(tydesc_type)],\n                       T_ptr(T_i8())),\n              free=dv(\"free\", [T_ptr(T_i8()), T_int()]),\n              shared_malloc=d(\"shared_malloc\",\n-                      [T_size_t(), T_ptr(T_tydesc(tn))], T_ptr(T_i8())),\n+                      [T_size_t(), T_ptr(tydesc_type)], T_ptr(T_i8())),\n              shared_free=dv(\"shared_free\", [T_ptr(T_i8())]),\n              mark=d(\"mark\", [T_ptr(T_i8())], T_int()),\n              new_str=d(\"new_str\", [T_ptr(T_i8()), T_size_t()],\n                        T_ptr(T_str())),\n-             dup_str=d(\"dup_str\", [T_taskptr(tn), T_ptr(T_str())],\n+                     dup_str=d(\"dup_str\", [T_taskptr(tn), T_ptr(T_str())],\n                        T_ptr(T_str())),\n-             new_vec=d(\"new_vec\", [T_size_t(), T_ptr(T_tydesc(tn))],\n+             new_vec=d(\"new_vec\", [T_size_t(), T_ptr(tydesc_type)],\n                        T_opaque_vec_ptr()),\n              vec_append=d(\"vec_append\",\n-                          [T_ptr(T_tydesc(tn)), T_ptr(T_tydesc(tn)),\n+                          [T_ptr(tydesc_type), T_ptr(tydesc_type),\n                            T_ptr(T_opaque_vec_ptr()), T_opaque_vec_ptr(),\n                            T_bool()], T_void()),\n              get_type_desc=d(\"get_type_desc\",\n                              [T_ptr(T_nil()), T_size_t(), T_size_t(),\n-                              T_size_t(), T_ptr(T_ptr(T_tydesc(tn)))],\n-                             T_ptr(T_tydesc(tn))),\n+                              T_size_t(), T_ptr(T_ptr(tydesc_type))],\n+                             T_ptr(tydesc_type)),\n              new_task=d(\"new_task\", [T_ptr(T_str())], T_taskptr(tn)),\n              start_task=d(\"start_task\",\n                           [T_taskptr(tn), T_int(), T_int(), T_size_t()],"}, {"sha": "758b2982d69de00da6bf15f20012ff5d6626d469", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 71, "deletions": 71, "changes": 142, "blob_url": "https://github.com/rust-lang/rust/blob/3d353f76a9057fda207746d7c5a30729e65a70ba/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3d353f76a9057fda207746d7c5a30729e65a70ba/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=3d353f76a9057fda207746d7c5a30729e65a70ba", "patch": "@@ -146,7 +146,8 @@ type crate_ctxt =\n         hashmap[ty::t, str] type_short_names,\n         ty::ctxt tcx,\n         stats stats,\n-        @upcall::upcalls upcalls);\n+        @upcall::upcalls upcalls,\n+        TypeRef tydesc_type);\n \n type local_ctxt =\n     rec(str[] path,\n@@ -463,8 +464,8 @@ fn T_fn(&TypeRef[] inputs, TypeRef output) -> TypeRef {\n                                std::ivec::len[TypeRef](inputs), False);\n }\n \n-fn T_fn_pair(&type_names tn, TypeRef tfn) -> TypeRef {\n-    ret T_struct(~[T_ptr(tfn), T_opaque_closure_ptr(tn)]);\n+fn T_fn_pair(&crate_ctxt cx, TypeRef tfn) -> TypeRef {\n+    ret T_struct(~[T_ptr(tfn), T_opaque_closure_ptr(cx)]);\n }\n \n fn T_ptr(TypeRef t) -> TypeRef { ret llvm::LLVMPointerType(t, 0u); }\n@@ -494,22 +495,22 @@ fn T_task(&type_names tn) -> TypeRef {\n     ret t;\n }\n \n-fn T_tydesc_field(&type_names tn, int field) -> TypeRef {\n+fn T_tydesc_field(&crate_ctxt cx, int field) -> TypeRef {\n     // Bit of a kludge: pick the fn typeref out of the tydesc..\n \n     let TypeRef[] tydesc_elts =\n         std::ivec::init_elt[TypeRef](T_nil(), abi::n_tydesc_fields as uint);\n-    llvm::LLVMGetStructElementTypes(T_tydesc(tn),\n+    llvm::LLVMGetStructElementTypes(cx.tydesc_type,\n                                     std::ivec::to_ptr[TypeRef](tydesc_elts));\n     auto t = llvm::LLVMGetElementType(tydesc_elts.(field));\n     ret t;\n }\n \n-fn T_glue_fn(&type_names tn) -> TypeRef {\n+fn T_glue_fn(&crate_ctxt cx) -> TypeRef {\n     auto s = \"glue_fn\";\n-    if (tn.name_has_type(s)) { ret tn.get_type(s); }\n-    auto t = T_tydesc_field(tn, abi::tydesc_field_drop_glue);\n-    tn.associate(s, t);\n+    if (cx.tn.name_has_type(s)) { ret cx.tn.get_type(s); }\n+    auto t = T_tydesc_field(cx, abi::tydesc_field_drop_glue);\n+    cx.tn.associate(s, t);\n     ret t;\n }\n \n@@ -518,17 +519,15 @@ fn T_dtor(&@crate_ctxt ccx, &span sp, TypeRef llself_ty) -> TypeRef {\n                         ~[], ty::mk_nil(ccx.tcx), 0u);\n }\n \n-fn T_cmp_glue_fn(&type_names tn) -> TypeRef {\n+fn T_cmp_glue_fn(&crate_ctxt cx) -> TypeRef {\n     auto s = \"cmp_glue_fn\";\n-    if (tn.name_has_type(s)) { ret tn.get_type(s); }\n-    auto t = T_tydesc_field(tn, abi::tydesc_field_cmp_glue);\n-    tn.associate(s, t);\n+    if (cx.tn.name_has_type(s)) { ret cx.tn.get_type(s); }\n+    auto t = T_tydesc_field(cx, abi::tydesc_field_cmp_glue);\n+    cx.tn.associate(s, t);\n     ret t;\n }\n \n fn T_tydesc(&type_names tn) -> TypeRef {\n-    auto s = \"tydesc\";\n-    if (tn.name_has_type(s)) { ret tn.get_type(s); }\n     auto th = mk_type_handle();\n     auto abs_tydesc = llvm::LLVMResolveTypeHandle(th.llth);\n     auto tydescpp = T_ptr(T_ptr(abs_tydesc));\n@@ -554,7 +553,6 @@ fn T_tydesc(&type_names tn) -> TypeRef {\n \n     llvm::LLVMRefineType(abs_tydesc, tydesc);\n     auto t = llvm::LLVMResolveTypeHandle(th.llth);\n-    tn.associate(s, t);\n     ret t;\n }\n \n@@ -649,26 +647,26 @@ fn T_typaram(&type_names tn) -> TypeRef {\n \n fn T_typaram_ptr(&type_names tn) -> TypeRef { ret T_ptr(T_typaram(tn)); }\n \n-fn T_closure_ptr(&type_names tn, TypeRef lltarget_ty, TypeRef llbindings_ty,\n+fn T_closure_ptr(&crate_ctxt cx, TypeRef lltarget_ty, TypeRef llbindings_ty,\n                  uint n_ty_params) -> TypeRef {\n     // NB: keep this in sync with code in trans_bind; we're making\n     // an LLVM typeref structure that has the same \"shape\" as the ty::t\n     // it constructs.\n \n-    ret T_ptr(T_box(T_struct(~[T_ptr(T_tydesc(tn)), lltarget_ty,\n+    ret T_ptr(T_box(T_struct(~[T_ptr(cx.tydesc_type), lltarget_ty,\n                                llbindings_ty,\n-                               T_captured_tydescs(tn, n_ty_params)])));\n+                               T_captured_tydescs(cx, n_ty_params)])));\n }\n \n-fn T_opaque_closure_ptr(&type_names tn) -> TypeRef {\n+fn T_opaque_closure_ptr(&crate_ctxt cx) -> TypeRef {\n     auto s = \"*closure\";\n-    if (tn.name_has_type(s)) { ret tn.get_type(s); }\n+    if (cx.tn.name_has_type(s)) { ret cx.tn.get_type(s); }\n     auto t =\n-        T_closure_ptr(tn,\n+        T_closure_ptr(cx,\n                       T_struct(~[T_ptr(T_nil()), T_ptr(T_nil())]),\n                       T_nil(),\n                       0u);\n-    tn.associate(s, t);\n+    cx.tn.associate(s, t);\n     ret t;\n }\n \n@@ -692,22 +690,22 @@ fn T_opaque_tag_ptr(&type_names tn) -> TypeRef {\n     ret T_ptr(T_opaque_tag(tn));\n }\n \n-fn T_captured_tydescs(&type_names tn, uint n) -> TypeRef {\n-    ret T_struct(std::ivec::init_elt[TypeRef](T_ptr(T_tydesc(tn)), n));\n+fn T_captured_tydescs(&crate_ctxt cx, uint n) -> TypeRef {\n+    ret T_struct(std::ivec::init_elt[TypeRef](T_ptr(cx.tydesc_type), n));\n }\n \n-fn T_obj_ptr(&type_names tn, uint n_captured_tydescs) -> TypeRef {\n+fn T_obj_ptr(&crate_ctxt cx, uint n_captured_tydescs) -> TypeRef {\n     // This function is not publicly exposed because it returns an incomplete\n     // type. The dynamically-sized fields follow the captured tydescs.\n \n-    fn T_obj(type_names tn, uint n_captured_tydescs) -> TypeRef {\n-        ret T_struct(~[T_ptr(T_tydesc(tn)),\n-                       T_captured_tydescs(tn, n_captured_tydescs)]);\n+    fn T_obj(&crate_ctxt cx, uint n_captured_tydescs) -> TypeRef {\n+        ret T_struct(~[T_ptr(cx.tydesc_type),\n+                       T_captured_tydescs(cx, n_captured_tydescs)]);\n     }\n-    ret T_ptr(T_box(T_obj(tn, n_captured_tydescs)));\n+    ret T_ptr(T_box(T_obj(cx, n_captured_tydescs)));\n }\n \n-fn T_opaque_obj_ptr(&type_names tn) -> TypeRef { ret T_obj_ptr(tn, 0u); }\n+fn T_opaque_obj_ptr(&crate_ctxt cx) -> TypeRef { ret T_obj_ptr(cx, 0u); }\n \n fn T_opaque_port_ptr() -> TypeRef { ret T_ptr(T_i8()); }\n \n@@ -773,14 +771,14 @@ fn type_of_fn_full(&@crate_ctxt cx, &span sp, ast::proto proto,\n     // Arg 2: Env (closure-bindings / self-obj)\n     alt (obj_self) {\n         case (some(?t)) { assert (t as int != 0); atys += ~[t]; }\n-        case (_) { atys += ~[T_opaque_closure_ptr(cx.tn)]; }\n+        case (_) { atys += ~[T_opaque_closure_ptr(*cx)]; }\n     }\n \n     // Args >3: ty params, if not acquired via capture...\n     if (obj_self == none[TypeRef]) {\n         auto i = 0u;\n         while (i < ty_param_count) {\n-            atys += ~[T_ptr(T_tydesc(cx.tn))];\n+            atys += ~[T_ptr(cx.tydesc_type)];\n             i += 1u;\n         }\n     }\n@@ -789,7 +787,7 @@ fn type_of_fn_full(&@crate_ctxt cx, &span sp, ast::proto proto,\n         // *input* type of the function we're given as our iter-block\n         // argument.\n         atys +=\n-            ~[T_fn_pair(cx.tn,\n+            ~[T_fn_pair(*cx,\n                         type_of_fn_full(cx, sp, ast::proto_fn, none[TypeRef],\n                                         ~[rec(mode=ty::mo_alias(false),\n                                              ty=output)], ty::mk_nil(cx.tcx),\n@@ -816,7 +814,7 @@ fn type_of_native_fn(&@crate_ctxt cx, &span sp, ast::native_abi abi,\n         atys += ~[T_taskptr(cx.tn)];\n         auto i = 0u;\n         while (i < ty_param_count) {\n-            atys += ~[T_ptr(T_tydesc(cx.tn))];\n+            atys += ~[T_ptr(cx.tydesc_type)];\n             i += 1u;\n         }\n     }\n@@ -892,11 +890,11 @@ fn type_of_inner(&@crate_ctxt cx, &span sp, &ty::t t) -> TypeRef {\n             llty = T_struct(tys);\n         }\n         case (ty::ty_fn(?proto, ?args, ?out, _, _)) {\n-            llty = T_fn_pair(cx.tn, type_of_fn(cx, sp, proto, args, out, 0u));\n+            llty = T_fn_pair(*cx, type_of_fn(cx, sp, proto, args, out, 0u));\n         }\n         case (ty::ty_native_fn(?abi, ?args, ?out)) {\n             auto nft = native_fn_wrapper_type(cx, sp, 0u, t);\n-            llty = T_fn_pair(cx.tn, nft);\n+            llty = T_fn_pair(*cx, nft);\n         }\n         case (ty::ty_obj(?meths)) {\n             auto th = mk_type_handle();\n@@ -910,7 +908,7 @@ fn type_of_inner(&@crate_ctxt cx, &span sp, &ty::t t) -> TypeRef {\n             }\n             let TypeRef vtbl = T_struct(mtys);\n             let TypeRef pair =\n-                T_struct(~[T_ptr(vtbl), T_opaque_obj_ptr(cx.tn)]);\n+                T_struct(~[T_ptr(vtbl), T_opaque_obj_ptr(*cx)]);\n             auto abs_pair = llvm::LLVMResolveTypeHandle(th.llth);\n             llvm::LLVMRefineType(abs_pair, pair);\n             abs_pair = llvm::LLVMResolveTypeHandle(th.llth);\n@@ -924,7 +922,7 @@ fn type_of_inner(&@crate_ctxt cx, &span sp, &ty::t t) -> TypeRef {\n             cx.tcx.sess.span_fatal(sp, \"trans::type_of called on ty_var\");\n         }\n         case (ty::ty_param(_)) { llty = T_i8(); }\n-        case (ty::ty_type) { llty = T_ptr(T_tydesc(cx.tn)); }\n+        case (ty::ty_type) { llty = T_ptr(cx.tydesc_type); }\n     }\n     assert (llty as int != 0);\n     if (cx.sess.get_opts().save_temps) {\n@@ -974,7 +972,7 @@ fn type_of_ty_param_count_and_ty(@local_ctxt lcx, &span sp,\n         case (ty::ty_fn(?proto, ?inputs, ?output, _, _)) {\n             auto llfnty =\n                 type_of_fn(lcx.ccx, sp, proto, inputs, output, tpt._0);\n-            ret T_fn_pair(lcx.ccx.tn, llfnty);\n+            ret T_fn_pair(*lcx.ccx, llfnty);\n         }\n         case (_) {\n             // fall through\n@@ -1600,7 +1598,7 @@ fn trans_raw_malloc(&@block_ctxt cx, TypeRef llptr_ty, ValueRef llsize) ->\n    result {\n     // FIXME: need a table to collect tydesc globals.\n \n-    auto tydesc = C_null(T_ptr(T_tydesc(cx.fcx.lcx.ccx.tn)));\n+    auto tydesc = C_null(T_ptr(cx.fcx.lcx.ccx.tydesc_type));\n     auto rval =\n         cx.build.Call(cx.fcx.lcx.ccx.upcalls.malloc,\n                       ~[cx.fcx.lltaskptr, llsize, tydesc]);\n@@ -1613,7 +1611,7 @@ fn trans_shared_malloc(&@block_ctxt cx, TypeRef llptr_ty, ValueRef llsize) ->\n    result {\n     // FIXME: need a table to collect tydesc globals.\n \n-    auto tydesc = C_null(T_ptr(T_tydesc(cx.fcx.lcx.ccx.tn)));\n+    auto tydesc = C_null(T_ptr(cx.fcx.lcx.ccx.tydesc_type));\n     auto rval =\n         cx.build.Call(cx.fcx.lcx.ccx.upcalls.shared_malloc,\n                       ~[cx.fcx.lltaskptr, llsize, tydesc]);\n@@ -1694,7 +1692,7 @@ fn linearize_ty_params(&@block_ctxt cx, &ty::t t) -> tup(uint[], ValueRef[]) {\n fn trans_stack_local_derived_tydesc(&@block_ctxt cx, ValueRef llsz,\n                                     ValueRef llalign, ValueRef llroottydesc,\n                                     ValueRef llparamtydescs) -> ValueRef {\n-    auto llmyroottydesc = alloca(cx, T_tydesc(cx.fcx.lcx.ccx.tn));\n+    auto llmyroottydesc = alloca(cx, cx.fcx.lcx.ccx.tydesc_type);\n     // By convention, desc 0 is the root descriptor.\n \n     llroottydesc = cx.build.Load(llroottydesc);\n@@ -1740,7 +1738,7 @@ fn get_derived_tydesc(&@block_ctxt cx, &ty::t t, bool escapes,\n         auto tydescs =\n             alloca(bcx, /* for root*/\n \n-                   T_array(T_ptr(T_tydesc(bcx.fcx.lcx.ccx.tn)),\n+                   T_array(T_ptr(bcx.fcx.lcx.ccx.tydesc_type),\n                            1u + n_params));\n         auto i = 0;\n         auto tdp = bcx.build.GEP(tydescs, ~[C_int(0), C_int(i)]);\n@@ -1753,7 +1751,7 @@ fn get_derived_tydesc(&@block_ctxt cx, &ty::t t, bool escapes,\n         }\n         auto lltydescsptr =\n             bcx.build.PointerCast(tydescs,\n-                                  T_ptr(T_ptr(T_tydesc(bcx.fcx.lcx.ccx.tn))));\n+                                  T_ptr(T_ptr(bcx.fcx.lcx.ccx.tydesc_type)));\n         auto td_val =\n             bcx.build.Call(bcx.fcx.lcx.ccx.upcalls.get_type_desc,\n                            ~[bcx.fcx.lltaskptr, C_null(T_ptr(T_nil())),\n@@ -1763,7 +1761,7 @@ fn get_derived_tydesc(&@block_ctxt cx, &ty::t t, bool escapes,\n     } else {\n         auto llparamtydescs =\n             alloca(bcx,\n-                   T_array(T_ptr(T_tydesc(bcx.fcx.lcx.ccx.tn)), n_params));\n+                   T_array(T_ptr(bcx.fcx.lcx.ccx.tydesc_type), n_params));\n         auto i = 0;\n         for (ValueRef td in tys._1) {\n             auto tdp = bcx.build.GEP(llparamtydescs, ~[C_int(0), C_int(i)]);\n@@ -1862,7 +1860,7 @@ fn declare_tydesc(&@local_ctxt cx, &span sp, &ty::t t, &uint[] ty_params)\n         name = sanitize(name);\n     } else { name = mangle_internal_name_by_seq(cx.ccx, \"tydesc\"); }\n     auto gvar =\n-        llvm::LLVMAddGlobal(ccx.llmod, T_tydesc(ccx.tn), str::buf(name));\n+        llvm::LLVMAddGlobal(ccx.llmod, ccx.tydesc_type, str::buf(name));\n     auto info =\n         @rec(ty=t,\n              tydesc=gvar,\n@@ -1947,8 +1945,8 @@ fn make_generic_glue(&@local_ctxt cx, &span sp, &ty::t t, ValueRef llfn,\n \n fn emit_tydescs(&@crate_ctxt ccx) {\n     for each (@tup(ty::t, @tydesc_info) pair in ccx.tydescs.items()) {\n-        auto glue_fn_ty = T_ptr(T_glue_fn(ccx.tn));\n-        auto cmp_fn_ty = T_ptr(T_cmp_glue_fn(ccx.tn));\n+        auto glue_fn_ty = T_ptr(T_glue_fn(*ccx));\n+        auto cmp_fn_ty = T_ptr(T_cmp_glue_fn(*ccx));\n         auto ti = pair._1;\n         auto copy_glue =\n             alt ({ ti.copy_glue }) {\n@@ -1983,7 +1981,7 @@ fn emit_tydescs(&@crate_ctxt ccx) {\n                 case (some(?v)) { ccx.stats.n_real_glues += 1u; v }\n             };\n         auto tydesc =\n-            C_struct(~[C_null(T_ptr(T_ptr(T_tydesc(ccx.tn)))), ti.size,\n+            C_struct(~[C_null(T_ptr(T_ptr(ccx.tydesc_type))), ti.size,\n                        ti.align, copy_glue, // copy_glue\n                        drop_glue, // drop_glue\n                        free_glue, // free_glue\n@@ -2220,7 +2218,7 @@ fn trans_res_drop(@block_ctxt cx, ValueRef rs, &ast::def_id did,\n                               ty::mk_nil(ccx.tcx), params);\n         get_extern_const(ccx.externs, ccx.llmod,\n                          csearch::get_symbol(ccx.sess.get_cstore(), did),\n-                         T_fn_pair(ccx.tn, f_t))\n+                         T_fn_pair(*ccx, f_t))\n     };\n     auto dtor_addr = cx.build.Load\n         (cx.build.GEP(dtor_pair, ~[C_int(0), C_int(abi::fn_field_code)]));\n@@ -2984,7 +2982,7 @@ fn lazily_emit_tydesc_glue(&@block_ctxt cx, int field,\n                         auto lcx = cx.fcx.lcx;\n                         auto glue_fn =\n                             declare_generic_glue(lcx, ti.ty,\n-                                                 T_glue_fn(lcx.ccx.tn),\n+                                                 T_glue_fn(*lcx.ccx),\n                                                  \"copy\");\n                         ti.copy_glue = some[ValueRef](glue_fn);\n                         auto tg = make_copy_glue;\n@@ -3003,7 +3001,7 @@ fn lazily_emit_tydesc_glue(&@block_ctxt cx, int field,\n                         auto lcx = cx.fcx.lcx;\n                         auto glue_fn =\n                             declare_generic_glue(lcx, ti.ty,\n-                                                 T_glue_fn(lcx.ccx.tn),\n+                                                 T_glue_fn(*lcx.ccx),\n                                                  \"drop\");\n                         ti.drop_glue = some[ValueRef](glue_fn);\n                         make_generic_glue(lcx, cx.sp, ti.ty, glue_fn,\n@@ -3022,7 +3020,7 @@ fn lazily_emit_tydesc_glue(&@block_ctxt cx, int field,\n                         auto lcx = cx.fcx.lcx;\n                         auto glue_fn =\n                             declare_generic_glue(lcx, ti.ty,\n-                                                 T_glue_fn(lcx.ccx.tn),\n+                                                 T_glue_fn(*lcx.ccx),\n                                                  \"free\");\n                         ti.free_glue = some[ValueRef](glue_fn);\n                         auto dg = make_free_glue;\n@@ -3041,7 +3039,7 @@ fn lazily_emit_tydesc_glue(&@block_ctxt cx, int field,\n                         auto lcx = cx.fcx.lcx;\n                         auto glue_fn =\n                             declare_generic_glue(lcx, ti.ty,\n-                                                 T_cmp_glue_fn(lcx.ccx.tn),\n+                                                 T_cmp_glue_fn(*lcx.ccx),\n                                                  \"cmp\");\n                         ti.cmp_glue = some[ValueRef](glue_fn);\n                         make_generic_glue(lcx, cx.sp, ti.ty, glue_fn,\n@@ -4537,7 +4535,7 @@ fn build_environment(&@block_ctxt cx, &ast::node_id[] upvars) ->\n     // Create an environment and populate it with the bindings.\n     auto tydesc_count = std::ivec::len[ValueRef](cx.fcx.lltydescs);\n     auto llenvptrty =\n-        T_closure_ptr(cx.fcx.lcx.ccx.tn, T_ptr(T_nil()),\n+        T_closure_ptr(*cx.fcx.lcx.ccx, T_ptr(T_nil()),\n                       val_ty(llbindingsptr), tydesc_count);\n     auto llenvptr = alloca(cx, llvm::LLVMGetElementType(llenvptrty));\n     auto llbindingsptrptr =\n@@ -4691,15 +4689,15 @@ fn trans_for_each(&@block_ctxt cx, &@ast::local local, &@ast::expr seq,\n     // Step 3: Call iter passing [lliterbody, llenv], plus other args.\n     alt (seq.node) {\n         case (ast::expr_call(?f, ?args)) {\n-            auto pair = alloca(cx, T_fn_pair(lcx.ccx.tn, iter_body_llty));\n+            auto pair = alloca(cx, T_fn_pair(*lcx.ccx, iter_body_llty));\n             auto code_cell =\n                 cx.build.GEP(pair, ~[C_int(0), C_int(abi::fn_field_code)]);\n             cx.build.Store(lliterbody, code_cell);\n             auto env_cell =\n                 cx.build.GEP(pair, ~[C_int(0), C_int(abi::fn_field_box)]);\n             auto llenvblobptr =\n                 cx.build.PointerCast(llenvptr,\n-                                     T_opaque_closure_ptr(lcx.ccx.tn));\n+                                     T_opaque_closure_ptr(*lcx.ccx));\n             cx.build.Store(llenvblobptr, env_cell);\n             // log \"lliterbody: \" + val_str(lcx.ccx.tn, lliterbody);\n \n@@ -5468,7 +5466,7 @@ fn trans_bind_1(&@block_ctxt cx, &@ast::expr f, &lval_result f_res,\n                            ty::ty_fn_args(bcx.fcx.lcx.ccx.tcx, outgoing_fty),\n                            ty::ty_fn_ret(bcx.fcx.lcx.ccx.tcx, outgoing_fty),\n                            ty_param_count);\n-            auto llclosurety = T_ptr(T_fn_pair(bcx.fcx.lcx.ccx.tn, llfnty));\n+            auto llclosurety = T_ptr(T_fn_pair(*bcx.fcx.lcx.ccx, llfnty));\n \n             // Store thunk-target.\n             auto bound_target =\n@@ -5525,11 +5523,11 @@ fn trans_bind_1(&@block_ctxt cx, &@ast::expr f, &lval_result f_res,\n             bcx.build.Store(llthunk, pair_code);\n \n             // Store box ptr in outer pair's box slot.\n-            auto tn = bcx.fcx.lcx.ccx.tn;\n+            auto ccx = *bcx.fcx.lcx.ccx;\n             auto pair_box =\n                 bcx.build.GEP(pair_v, ~[C_int(0), C_int(abi::fn_field_box)]);\n             bcx.build.Store(bcx.build.PointerCast(box,\n-                                                  T_opaque_closure_ptr(tn)),\n+                                                  T_opaque_closure_ptr(ccx)),\n                             pair_box);\n             add_clean_temp(cx, pair_v, pair_ty);\n             ret rslt(bcx, pair_v);\n@@ -5716,7 +5714,7 @@ fn trans_call(&@block_ctxt cx, &@ast::expr f, &option::t[ValueRef] lliterbody,\n     auto bcx = f_res.res.bcx;\n \n     auto faddr = f_res.res.val;\n-    auto llenv = C_null(T_opaque_closure_ptr(cx.fcx.lcx.ccx.tn));\n+    auto llenv = C_null(T_opaque_closure_ptr(*cx.fcx.lcx.ccx));\n     alt (f_res.llobj) {\n         case (some(_)) {\n             // It's a vtbl entry.\n@@ -5818,7 +5816,7 @@ fn trans_vec(&@block_ctxt cx, &(@ast::expr)[] args, ast::node_id id) ->\n     auto vec_val =\n         bcx.build.Call(bcx.fcx.lcx.ccx.upcalls.new_vec,\n                        ~[bcx.fcx.lltaskptr, data_sz,\n-                         C_null(T_ptr(T_tydesc(bcx.fcx.lcx.ccx.tn)))]);\n+                         C_null(T_ptr(bcx.fcx.lcx.ccx.tydesc_type))]);\n     auto llty = type_of(bcx.fcx.lcx.ccx, bcx.sp, t);\n     vec_val = bcx.build.PointerCast(vec_val, llty);\n     add_clean_temp(bcx, vec_val, t);\n@@ -6960,7 +6958,7 @@ fn trans_anon_obj(@block_ctxt bcx, &span sp, &ast::anon_obj anon_obj,\n     auto pair =\n         alloca(bcx,\n                T_struct(~[val_ty(vtbl),\n-                          T_obj_ptr(ccx.tn, std::ivec::len(ty_params))]));\n+                          T_obj_ptr(*ccx, std::ivec::len(ty_params))]));\n \n     // Take care of cleanups.\n     auto t = node_id_type(ccx, id);\n@@ -6979,7 +6977,7 @@ fn trans_anon_obj(@block_ctxt bcx, &span sp, &ast::anon_obj anon_obj,\n     // Next we have to take care of the other half of the pair we're\n     // returning: a boxed (reference-counted) tuple containing a tydesc,\n     // typarams, fields, and a pointer to our with_obj.\n-    let TypeRef llbox_ty = T_opaque_obj_ptr(ccx.tn);\n+    let TypeRef llbox_ty = T_opaque_obj_ptr(*ccx);\n \n     if (std::ivec::len[ast::ty_param](ty_params) == 0u &&\n         std::ivec::len[ast::anon_obj_field](additional_fields) == 0u &&\n@@ -7623,7 +7621,7 @@ fn populate_fn_ctxt_from_llself(@fn_ctxt fcx, val_self_pair llself) {\n \n     auto fields_tup_ty = ty::mk_imm_tup(fcx.lcx.ccx.tcx, field_tys);\n     auto n_typarams = std::ivec::len[ast::ty_param](bcx.fcx.lcx.obj_typarams);\n-    let TypeRef llobj_box_ty = T_obj_ptr(bcx.fcx.lcx.ccx.tn, n_typarams);\n+    let TypeRef llobj_box_ty = T_obj_ptr(*bcx.fcx.lcx.ccx, n_typarams);\n     auto box_cell =\n         bcx.build.GEP(llself.v, ~[C_int(0), C_int(abi::obj_field_box)]);\n     auto box_ptr = bcx.build.Load(box_cell);\n@@ -8209,7 +8207,7 @@ fn trans_obj(@local_ctxt cx, &span sp, &ast::_obj ob, ast::node_id ctor_id,\n     // FIXME: What about with_obj?  Do we have to think about it here?\n     // (Pertains to issues #538/#539/#540/#543.)\n \n-    let TypeRef llbox_ty = T_opaque_obj_ptr(ccx.tn);\n+    let TypeRef llbox_ty = T_opaque_obj_ptr(*ccx);\n \n     // FIXME: we should probably also allocate a box for empty objs that have\n     // a dtor, since otherwise they are never dropped, and the dtor never\n@@ -8620,8 +8618,8 @@ fn decl_fn_and_pair_full(&@crate_ctxt ccx, &span sp, &str[] path, str flav,\n fn create_fn_pair(&@crate_ctxt cx, str ps, TypeRef llfnty, ValueRef llfn,\n                   bool external) -> ValueRef {\n     auto gvar =\n-        llvm::LLVMAddGlobal(cx.llmod, T_fn_pair(cx.tn, llfnty), str::buf(ps));\n-    auto pair = C_struct(~[llfn, C_null(T_opaque_closure_ptr(cx.tn))]);\n+        llvm::LLVMAddGlobal(cx.llmod, T_fn_pair(*cx, llfnty), str::buf(ps));\n+    auto pair = C_struct(~[llfn, C_null(T_opaque_closure_ptr(*cx))]);\n     llvm::LLVMSetInitializer(gvar, pair);\n     llvm::LLVMSetGlobalConstant(gvar, True);\n     if (!external) {\n@@ -9002,7 +9000,7 @@ fn i2p(ValueRef v, TypeRef t) -> ValueRef {\n \n fn create_typedefs(&@crate_ctxt cx) {\n     llvm::LLVMAddTypeName(cx.llmod, str::buf(\"task\"), T_task(cx.tn));\n-    llvm::LLVMAddTypeName(cx.llmod, str::buf(\"tydesc\"), T_tydesc(cx.tn));\n+    llvm::LLVMAddTypeName(cx.llmod, str::buf(\"tydesc\"), cx.tydesc_type);\n }\n \n fn declare_intrinsics(ModuleRef llmod) -> hashmap[str, ValueRef] {\n@@ -9181,6 +9179,7 @@ fn trans_crate(&session::session sess, &@ast::crate crate, &ty::ctxt tcx,\n     auto sha1s = map::mk_hashmap[ty::t, str](hasher, eqer);\n     auto short_names = map::mk_hashmap[ty::t, str](hasher, eqer);\n     auto sha = std::sha1::mk_sha1();\n+    auto tydesc_type = T_tydesc(tn);\n     auto ccx =\n         @rec(sess=sess,\n              llmod=llmod,\n@@ -9213,7 +9212,8 @@ fn trans_crate(&session::session sess, &@ast::crate crate, &ty::ctxt tcx,\n                        mutable n_glues_created=0u,\n                        mutable n_null_glues=0u,\n                        mutable n_real_glues=0u),\n-             upcalls=upcall::declare_upcalls(tn, llmod));\n+             upcalls=upcall::declare_upcalls(tn, tydesc_type, llmod),\n+             tydesc_type=tydesc_type);\n     auto cx = new_local_ctxt(ccx);\n     create_typedefs(ccx);\n     collect_items(ccx, crate);"}]}