{"sha": "8dddc8647731efb6d7f40b176bccdba5cebe46f2", "node_id": "C_kwDOAAsO6NoAKDhkZGRjODY0NzczMWVmYjZkN2Y0MGIxNzZiY2NkYmE1Y2ViZTQ2ZjI", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2022-01-25T04:51:11Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-01-25T04:51:11Z"}, "message": "Rollup merge of #93144 - wesleywiser:uninhabited_type_code_cov2, r=tmandry\n\nWork around missing code coverage data causing llvm-cov failures\n\nIf we do not add code coverage instrumentation to the `Body` of a\nfunction, then when we go to generate the function record for it, we\nwon't write any data and this later causes llvm-cov to fail when\nprocessing data for the entire coverage report.\n\nI've identified two main cases where we do not currently add code\ncoverage instrumentation to the `Body` of a function:\n\n  1. If the function has a single `BasicBlock` and it ends with a\n     `TerminatorKind::Unreachable`.\n\n  2. If the function is created using a proc macro of some kind.\n\nFor case 1, this is typically not important as this most often occurs as\na result of function definitions that take or return uninhabited\ntypes. These kinds of functions, by definition, cannot even be called so\nthey logically should not be counted in code coverage statistics.\n\nFor case 2, I haven't looked into this very much but I've noticed while\ntesting this patch that (other than functions which are covered by case\n1) the skipped function coverage debug message is occasionally triggered\nin large crate graphs by functions generated from a proc macro. This may\nhave something to do with weird spans being generated by the proc macro\nbut this is just a guess.\n\nI think it's reasonable to land this change since currently, we fail to\ngenerate *any* results from llvm-cov when a function has no coverage\ninstrumentation applied to it. With this change, we get coverage data\nfor all functions other than the two cases discussed above.\n\nFixes #93054 which occurs because of uncallable functions which shouldn't\nhave code coverage anyway.\n\nI will open an issue for missing code coverage of proc macro generated\nfunctions and leave a link here once I have a more minimal repro.\n\nr? ``@tmandry``\ncc ``@richkadel``", "tree": {"sha": "6ea91de61a8fa173f5824ef3d15bd646e3e9ad11", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/6ea91de61a8fa173f5824ef3d15bd646e3e9ad11"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8dddc8647731efb6d7f40b176bccdba5cebe46f2", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJh74G/CRBK7hj4Ov3rIwAAfPkIAC7Qrh0QwOl0AvL9Oggi265P\nb/VbH5zEFVevvTasUowGtDCIMO26ZT7wzGeOyjUR0cJYMeR+gIjiH6YB4MNwLjuy\nD8sSsYHZwCSTsKYYGnk6F8gGItqAe9Fb85oyefxm8Y41iQvMEN0YfxLYxoREhmwq\nD5LCzDpGqZ+9T0XCrK+bUT5iOaqb5LJTgu2hIiE4Y2XUq+1oXo8z5uRgBA+M8mX/\nKQvbnsEDQZEqiizUq0EtMyHx1cie30peURerKdxDgh2ag465JDx31Cf4yz+R9ZiO\nTUxUF73DPdEnLNBjb9z78JapIeOwt9wloSTJHhUZNtNUyWHApzM6C6bV0l+tRYI=\n=jnsW\n-----END PGP SIGNATURE-----\n", "payload": "tree 6ea91de61a8fa173f5824ef3d15bd646e3e9ad11\nparent c8ede152a522fcf139b35700b36ec3e788617857\nparent 1a0278e1d17f66ddc5975f38387746f85c6602ce\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1643086271 +0100\ncommitter GitHub <noreply@github.com> 1643086271 +0100\n\nRollup merge of #93144 - wesleywiser:uninhabited_type_code_cov2, r=tmandry\n\nWork around missing code coverage data causing llvm-cov failures\n\nIf we do not add code coverage instrumentation to the `Body` of a\nfunction, then when we go to generate the function record for it, we\nwon't write any data and this later causes llvm-cov to fail when\nprocessing data for the entire coverage report.\n\nI've identified two main cases where we do not currently add code\ncoverage instrumentation to the `Body` of a function:\n\n  1. If the function has a single `BasicBlock` and it ends with a\n     `TerminatorKind::Unreachable`.\n\n  2. If the function is created using a proc macro of some kind.\n\nFor case 1, this is typically not important as this most often occurs as\na result of function definitions that take or return uninhabited\ntypes. These kinds of functions, by definition, cannot even be called so\nthey logically should not be counted in code coverage statistics.\n\nFor case 2, I haven't looked into this very much but I've noticed while\ntesting this patch that (other than functions which are covered by case\n1) the skipped function coverage debug message is occasionally triggered\nin large crate graphs by functions generated from a proc macro. This may\nhave something to do with weird spans being generated by the proc macro\nbut this is just a guess.\n\nI think it's reasonable to land this change since currently, we fail to\ngenerate *any* results from llvm-cov when a function has no coverage\ninstrumentation applied to it. With this change, we get coverage data\nfor all functions other than the two cases discussed above.\n\nFixes #93054 which occurs because of uncallable functions which shouldn't\nhave code coverage anyway.\n\nI will open an issue for missing code coverage of proc macro generated\nfunctions and leave a link here once I have a more minimal repro.\n\nr? ``@tmandry``\ncc ``@richkadel``\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8dddc8647731efb6d7f40b176bccdba5cebe46f2", "html_url": "https://github.com/rust-lang/rust/commit/8dddc8647731efb6d7f40b176bccdba5cebe46f2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8dddc8647731efb6d7f40b176bccdba5cebe46f2/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c8ede152a522fcf139b35700b36ec3e788617857", "url": "https://api.github.com/repos/rust-lang/rust/commits/c8ede152a522fcf139b35700b36ec3e788617857", "html_url": "https://github.com/rust-lang/rust/commit/c8ede152a522fcf139b35700b36ec3e788617857"}, {"sha": "1a0278e1d17f66ddc5975f38387746f85c6602ce", "url": "https://api.github.com/repos/rust-lang/rust/commits/1a0278e1d17f66ddc5975f38387746f85c6602ce", "html_url": "https://github.com/rust-lang/rust/commit/1a0278e1d17f66ddc5975f38387746f85c6602ce"}], "stats": {"total": 74, "additions": 70, "deletions": 4}, "files": [{"sha": "3014d2f1930eef5210cf4d4f9e0ccf1c4ea270cb", "filename": "compiler/rustc_codegen_llvm/src/coverageinfo/mapgen.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8dddc8647731efb6d7f40b176bccdba5cebe46f2/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dddc8647731efb6d7f40b176bccdba5cebe46f2/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcoverageinfo%2Fmapgen.rs?ref=8dddc8647731efb6d7f40b176bccdba5cebe46f2", "patch": "@@ -9,6 +9,7 @@ use rustc_data_structures::fx::FxIndexSet;\n use rustc_hir::def::DefKind;\n use rustc_hir::def_id::DefIdSet;\n use rustc_llvm::RustString;\n+use rustc_middle::bug;\n use rustc_middle::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use rustc_middle::mir::coverage::CodeRegion;\n use rustc_middle::ty::TyCtxt;\n@@ -76,10 +77,18 @@ pub fn finalize<'ll, 'tcx>(cx: &CodegenCx<'ll, 'tcx>) {\n         let coverage_mapping_buffer = llvm::build_byte_buffer(|coverage_mapping_buffer| {\n             mapgen.write_coverage_mapping(expressions, counter_regions, coverage_mapping_buffer);\n         });\n-        debug_assert!(\n-            !coverage_mapping_buffer.is_empty(),\n-            \"Every `FunctionCoverage` should have at least one counter\"\n-        );\n+\n+        if coverage_mapping_buffer.is_empty() {\n+            if function_coverage.is_used() {\n+                bug!(\n+                    \"A used function should have had coverage mapping data but did not: {}\",\n+                    mangled_function_name\n+                );\n+            } else {\n+                debug!(\"unused function had no coverage mapping data: {}\", mangled_function_name);\n+                continue;\n+            }\n+        }\n \n         function_data.push((mangled_function_name, source_hash, is_used, coverage_mapping_buffer));\n     }"}, {"sha": "a1655adedd44705fd962eb6b3cd5fee940a8ffe3", "filename": "src/test/run-make-fulldeps/coverage-reports/expected_show_coverage.issue-93054.txt", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/8dddc8647731efb6d7f40b176bccdba5cebe46f2/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.issue-93054.txt", "raw_url": "https://github.com/rust-lang/rust/raw/8dddc8647731efb6d7f40b176bccdba5cebe46f2/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.issue-93054.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage-reports%2Fexpected_show_coverage.issue-93054.txt?ref=8dddc8647731efb6d7f40b176bccdba5cebe46f2", "patch": "@@ -0,0 +1,29 @@\n+    1|       |// Regression test for #93054: Functions using uninhabited types often only have a single,\n+    2|       |// unreachable basic block which doesn't get instrumented. This should not cause llvm-cov to fail.\n+    3|       |// Since these kinds functions can't be invoked anyway, it's ok to not have coverage data for them.\n+    4|       |\n+    5|       |// compile-flags: --edition=2021\n+    6|       |\n+    7|       |enum Never { }\n+    8|       |\n+    9|       |impl Never {\n+   10|       |    fn foo(self) {\n+   11|       |        match self { }\n+   12|       |        make().map(|never| match never { });\n+   13|       |    }\n+   14|       |\n+   15|       |    fn bar(&self) {\n+   16|       |        match *self { }\n+   17|       |    }\n+   18|       |}\n+   19|       |\n+   20|      0|async fn foo2(never: Never) {\n+   21|       |    match never { }\n+   22|       |}\n+   23|       |\n+   24|      0|fn make() -> Option<Never> {\n+   25|      0|    None\n+   26|      0|}\n+   27|       |\n+   28|      1|fn main() { }\n+"}, {"sha": "c160b3db03f8e49e35dd704fd247ca90b53c766c", "filename": "src/test/run-make-fulldeps/coverage/issue-93054.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8dddc8647731efb6d7f40b176bccdba5cebe46f2/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fissue-93054.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8dddc8647731efb6d7f40b176bccdba5cebe46f2/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fissue-93054.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make-fulldeps%2Fcoverage%2Fissue-93054.rs?ref=8dddc8647731efb6d7f40b176bccdba5cebe46f2", "patch": "@@ -0,0 +1,28 @@\n+// Regression test for #93054: Functions using uninhabited types often only have a single,\n+// unreachable basic block which doesn't get instrumented. This should not cause llvm-cov to fail.\n+// Since these kinds functions can't be invoked anyway, it's ok to not have coverage data for them.\n+\n+// compile-flags: --edition=2021\n+\n+enum Never { }\n+\n+impl Never {\n+    fn foo(self) {\n+        match self { }\n+        make().map(|never| match never { });\n+    }\n+\n+    fn bar(&self) {\n+        match *self { }\n+    }\n+}\n+\n+async fn foo2(never: Never) {\n+    match never { }\n+}\n+\n+fn make() -> Option<Never> {\n+    None\n+}\n+\n+fn main() { }"}]}