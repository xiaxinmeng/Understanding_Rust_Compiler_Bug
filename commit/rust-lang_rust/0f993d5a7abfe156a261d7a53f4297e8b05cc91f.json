{"sha": "0f993d5a7abfe156a261d7a53f4297e8b05cc91f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBmOTkzZDVhN2FiZmUxNTZhMjYxZDdhNTNmNDI5N2U4YjA1Y2M5MWY=", "commit": {"author": {"name": "Santiago Pastorino", "email": "spastorino@gmail.com", "date": "2019-02-22T04:24:03Z"}, "committer": {"name": "Santiago Pastorino", "email": "spastorino@gmail.com", "date": "2019-03-01T04:02:00Z"}, "message": "Put Local, Static and Promoted as one Base variant of Place", "tree": {"sha": "948dd422e29bed5d02b6f821840696c16753ecf5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/948dd422e29bed5d02b6f821840696c16753ecf5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0f993d5a7abfe156a261d7a53f4297e8b05cc91f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0f993d5a7abfe156a261d7a53f4297e8b05cc91f", "html_url": "https://github.com/rust-lang/rust/commit/0f993d5a7abfe156a261d7a53f4297e8b05cc91f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/comments", "author": {"login": "spastorino", "id": 52642, "node_id": "MDQ6VXNlcjUyNjQy", "avatar_url": "https://avatars.githubusercontent.com/u/52642?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spastorino", "html_url": "https://github.com/spastorino", "followers_url": "https://api.github.com/users/spastorino/followers", "following_url": "https://api.github.com/users/spastorino/following{/other_user}", "gists_url": "https://api.github.com/users/spastorino/gists{/gist_id}", "starred_url": "https://api.github.com/users/spastorino/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spastorino/subscriptions", "organizations_url": "https://api.github.com/users/spastorino/orgs", "repos_url": "https://api.github.com/users/spastorino/repos", "events_url": "https://api.github.com/users/spastorino/events{/privacy}", "received_events_url": "https://api.github.com/users/spastorino/received_events", "type": "User", "site_admin": false}, "committer": {"login": "spastorino", "id": 52642, "node_id": "MDQ6VXNlcjUyNjQy", "avatar_url": "https://avatars.githubusercontent.com/u/52642?v=4", "gravatar_id": "", "url": "https://api.github.com/users/spastorino", "html_url": "https://github.com/spastorino", "followers_url": "https://api.github.com/users/spastorino/followers", "following_url": "https://api.github.com/users/spastorino/following{/other_user}", "gists_url": "https://api.github.com/users/spastorino/gists{/gist_id}", "starred_url": "https://api.github.com/users/spastorino/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/spastorino/subscriptions", "organizations_url": "https://api.github.com/users/spastorino/orgs", "repos_url": "https://api.github.com/users/spastorino/repos", "events_url": "https://api.github.com/users/spastorino/events{/privacy}", "received_events_url": "https://api.github.com/users/spastorino/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1999a2288123173b2e487865c9a04386173025f7", "url": "https://api.github.com/repos/rust-lang/rust/commits/1999a2288123173b2e487865c9a04386173025f7", "html_url": "https://github.com/rust-lang/rust/commit/1999a2288123173b2e487865c9a04386173025f7"}], "stats": {"total": 793, "additions": 441, "deletions": 352}, "files": [{"sha": "41b78ee50965506a071430575a5024d79f5bac8c", "filename": "src/librustc/ich/impls_mir.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc%2Fich%2Fimpls_mir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_mir.rs?ref=0f993d5a7abfe156a261d7a53f4297e8b05cc91f", "patch": "@@ -209,13 +209,13 @@ impl<'a, 'gcx> HashStable<StableHashingContext<'a>> for mir::Place<'gcx> {\n                                           hasher: &mut StableHasher<W>) {\n         mem::discriminant(self).hash_stable(hcx, hasher);\n         match *self {\n-            mir::Place::Local(ref local) => {\n+            mir::Place::Base(mir::PlaceBase::Local(ref local)) => {\n                 local.hash_stable(hcx, hasher);\n             }\n-            mir::Place::Static(ref statik) => {\n+            mir::Place::Base(mir::PlaceBase::Static(ref statik)) => {\n                 statik.hash_stable(hcx, hasher);\n             }\n-            mir::Place::Promoted(ref promoted) => {\n+            mir::Place::Base(mir::PlaceBase::Promoted(ref promoted)) => {\n                 promoted.hash_stable(hcx, hasher);\n             }\n             mir::Place::Projection(ref place_projection) => {"}, {"sha": "b6f5ff25c8fb87b41536a4d48fb78f1ee8112320", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 22, "deletions": 10, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=0f993d5a7abfe156a261d7a53f4297e8b05cc91f", "patch": "@@ -1896,6 +1896,14 @@ impl<'tcx> Debug for Statement<'tcx> {\n /// changing or disturbing program state.\n #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n pub enum Place<'tcx> {\n+    Base(PlaceBase<'tcx>),\n+\n+    /// projection out of a place (access a field, deref a pointer, etc)\n+    Projection(Box<PlaceProjection<'tcx>>),\n+}\n+\n+#[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, RustcEncodable, RustcDecodable)]\n+pub enum PlaceBase<'tcx> {\n     /// local variable\n     Local(Local),\n \n@@ -1904,9 +1912,6 @@ pub enum Place<'tcx> {\n \n     /// Constant code promoted to an injected static\n     Promoted(Box<(Promoted, Ty<'tcx>)>),\n-\n-    /// projection out of a place (access a field, deref a pointer, etc)\n-    Projection(Box<PlaceProjection<'tcx>>),\n }\n \n /// The `DefId` of a static, along with its normalized type (which is\n@@ -1994,6 +1999,8 @@ newtype_index! {\n }\n \n impl<'tcx> Place<'tcx> {\n+    pub const RETURN_PLACE: Place<'tcx> = Place::Base(PlaceBase::Local(RETURN_PLACE));\n+\n     pub fn field(self, f: Field, ty: Ty<'tcx>) -> Place<'tcx> {\n         self.elem(ProjectionElem::Field(f, ty))\n     }\n@@ -2020,9 +2027,9 @@ impl<'tcx> Place<'tcx> {\n     // FIXME: can we safely swap the semantics of `fn base_local` below in here instead?\n     pub fn local(&self) -> Option<Local> {\n         match self {\n-            Place::Local(local) |\n+            Place::Base(PlaceBase::Local(local)) |\n             Place::Projection(box Projection {\n-                base: Place::Local(local),\n+                base: Place::Base(PlaceBase::Local(local)),\n                 elem: ProjectionElem::Deref,\n             }) => Some(*local),\n             _ => None,\n@@ -2032,9 +2039,9 @@ impl<'tcx> Place<'tcx> {\n     /// Finds the innermost `Local` from this `Place`.\n     pub fn base_local(&self) -> Option<Local> {\n         match self {\n-            Place::Local(local) => Some(*local),\n+            Place::Base(PlaceBase::Local(local)) => Some(*local),\n             Place::Projection(box Projection { base, elem: _ }) => base.base_local(),\n-            Place::Promoted(..) | Place::Static(..) => None,\n+            Place::Base(PlaceBase::Promoted(..)) | Place::Base(PlaceBase::Static(..)) => None,\n         }\n     }\n }\n@@ -2044,14 +2051,19 @@ impl<'tcx> Debug for Place<'tcx> {\n         use self::Place::*;\n \n         match *self {\n-            Local(id) => write!(fmt, \"{:?}\", id),\n-            Static(box self::Static { def_id, ty }) => write!(\n+            Base(PlaceBase::Local(id)) => write!(fmt, \"{:?}\", id),\n+            Base(PlaceBase::Static(box self::Static { def_id, ty })) => write!(\n                 fmt,\n                 \"({}: {:?})\",\n                 ty::tls::with(|tcx| tcx.item_path_str(def_id)),\n                 ty\n             ),\n-            Promoted(ref promoted) => write!(fmt, \"({:?}: {:?})\", promoted.0, promoted.1),\n+            Base(PlaceBase::Promoted(ref promoted)) => write!(\n+                fmt,\n+                \"({:?}: {:?})\",\n+                promoted.0,\n+                promoted.1\n+            ),\n             Projection(ref data) => match data.elem {\n                 ProjectionElem::Downcast(ref adt_def, index) => {\n                     write!(fmt, \"({:?} as {})\", data.base, adt_def.variants[index].ident)"}, {"sha": "a6f153eaf6461e5c0772c8f18b7188f2bbfb82e8", "filename": "src/librustc/mir/tcx.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc%2Fmir%2Ftcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc%2Fmir%2Ftcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Ftcx.rs?ref=0f993d5a7abfe156a261d7a53f4297e8b05cc91f", "patch": "@@ -158,10 +158,10 @@ impl<'tcx> Place<'tcx> {\n         where D: HasLocalDecls<'tcx>\n     {\n         match *self {\n-            Place::Local(index) =>\n+            Place::Base(PlaceBase::Local(index)) =>\n                 PlaceTy::Ty { ty: local_decls.local_decls()[index].ty },\n-            Place::Promoted(ref data) => PlaceTy::Ty { ty: data.1 },\n-            Place::Static(ref data) =>\n+            Place::Base(PlaceBase::Promoted(ref data)) => PlaceTy::Ty { ty: data.1 },\n+            Place::Base(PlaceBase::Static(ref data)) =>\n                 PlaceTy::Ty { ty: data.ty },\n             Place::Projection(ref proj) =>\n                 proj.base.ty(local_decls, tcx).projection_ty(tcx, &proj.elem),"}, {"sha": "28e816f134365518cb7950834b7b9ef4c9083c2f", "filename": "src/librustc/mir/visit.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc%2Fmir%2Fvisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc%2Fmir%2Fvisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fvisit.rs?ref=0f993d5a7abfe156a261d7a53f4297e8b05cc91f", "patch": "@@ -733,13 +733,13 @@ macro_rules! make_mir_visitor {\n                             context: PlaceContext<'tcx>,\n                             location: Location) {\n                 match place {\n-                    Place::Local(local) => {\n+                    Place::Base(PlaceBase::Local(local)) => {\n                         self.visit_local(local, context, location);\n                     }\n-                    Place::Static(static_) => {\n+                    Place::Base(PlaceBase::Static(static_)) => {\n                         self.visit_static(static_, context, location);\n                     }\n-                    Place::Promoted(promoted) => {\n+                    Place::Base(PlaceBase::Promoted(promoted)) => {\n                         self.visit_ty(& $($mutability)? promoted.1, TyContext::Location(location));\n                     },\n                     Place::Projection(proj) => {"}, {"sha": "facae9a9797065e843d8ee724e7c11ac5cfa0c1e", "filename": "src/librustc_codegen_ssa/mir/analyze.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fanalyze.rs?ref=0f993d5a7abfe156a261d7a53f4297e8b05cc91f", "patch": "@@ -103,7 +103,7 @@ impl<'mir, 'a: 'mir, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> Visitor<'tcx>\n                     location: Location) {\n         debug!(\"visit_assign(block={:?}, place={:?}, rvalue={:?})\", block, place, rvalue);\n \n-        if let mir::Place::Local(index) = *place {\n+        if let mir::Place::Base(mir::PlaceBase::Local(index)) = *place {\n             self.assign(index, location);\n             if !self.fx.rvalue_creates_operand(rvalue) {\n                 self.not_ssa(index);\n@@ -245,7 +245,8 @@ impl<'mir, 'a: 'mir, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> Visitor<'tcx>\n             }\n \n             PlaceContext::MutatingUse(MutatingUseContext::Drop) => {\n-                let ty = mir::Place::Local(local).ty(self.fx.mir, self.fx.cx.tcx());\n+                let ty = mir::Place::Base(mir::PlaceBase::Local(local)).ty(self.fx.mir,\n+                                                                           self.fx.cx.tcx());\n                 let ty = self.fx.monomorphize(&ty.to_ty(self.fx.cx.tcx()));\n \n                 // Only need the place if we're actually dropping it."}, {"sha": "02086c7730cee15b0c2c2d9ed5d68a7f10bec124", "filename": "src/librustc_codegen_ssa/mir/block.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fblock.rs?ref=0f993d5a7abfe156a261d7a53f4297e8b05cc91f", "patch": "@@ -249,7 +249,7 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n             PassMode::Direct(_) | PassMode::Pair(..) => {\n                 let op =\n-                    self.codegen_consume(&mut bx, &mir::Place::Local(mir::RETURN_PLACE));\n+                    self.codegen_consume(&mut bx, &mir::Place::RETURN_PLACE);\n                 if let Ref(llval, _, align) = op.val {\n                     bx.load(llval, align)\n                 } else {\n@@ -615,8 +615,12 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         // The shuffle array argument is usually not an explicit constant,\n                         // but specified directly in the code. This means it gets promoted\n                         // and we can then extract the value by evaluating the promoted.\n-                        mir::Operand::Copy(mir::Place::Promoted(box(index, ty))) |\n-                        mir::Operand::Move(mir::Place::Promoted(box(index, ty))) => {\n+                        mir::Operand::Copy(\n+                            mir::Place::Base(mir::PlaceBase::Promoted(box(index, ty)))\n+                        ) |\n+                        mir::Operand::Move(\n+                            mir::Place::Base(mir::PlaceBase::Promoted(box(index, ty)))\n+                        ) => {\n                             let param_env = ty::ParamEnv::reveal_all();\n                             let cid = mir::interpret::GlobalId {\n                                 instance: self.instance,\n@@ -1106,7 +1110,7 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         if fn_ret.is_ignore() {\n             return ReturnDest::Nothing;\n         }\n-        let dest = if let mir::Place::Local(index) = *dest {\n+        let dest = if let mir::Place::Base(mir::PlaceBase::Local(index)) = *dest {\n             match self.locals[index] {\n                 LocalRef::Place(dest) => dest,\n                 LocalRef::UnsizedPlace(_) => bug!(\"return type must be sized\"),\n@@ -1161,7 +1165,7 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         src: &mir::Operand<'tcx>,\n         dst: &mir::Place<'tcx>\n     ) {\n-        if let mir::Place::Local(index) = *dst {\n+        if let mir::Place::Base(mir::PlaceBase::Local(index)) = *dst {\n             match self.locals[index] {\n                 LocalRef::Place(place) => self.codegen_transmute_into(bx, src, place),\n                 LocalRef::UnsizedPlace(_) => bug!(\"transmute must not involve unsized locals\"),"}, {"sha": "0a6549851f4462a03f92173cbd0d157f6d84a065", "filename": "src/librustc_codegen_ssa/mir/operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Foperand.rs?ref=0f993d5a7abfe156a261d7a53f4297e8b05cc91f", "patch": "@@ -378,7 +378,7 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n \n         // watch out for locals that do not have an\n         // alloca; they are handled somewhat differently\n-        if let mir::Place::Local(index) = *place {\n+        if let mir::Place::Base(mir::PlaceBase::Local(index)) = *place {\n             match self.locals[index] {\n                 LocalRef::Operand(Some(o)) => {\n                     return Some(o);"}, {"sha": "0408ccf039f340093dde20b6a4979e4cdebde86d", "filename": "src/librustc_codegen_ssa/mir/place.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fplace.rs?ref=0f993d5a7abfe156a261d7a53f4297e8b05cc91f", "patch": "@@ -392,7 +392,7 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         let cx = self.cx;\n         let tcx = self.cx.tcx();\n \n-        if let mir::Place::Local(index) = *place {\n+        if let mir::Place::Base(mir::PlaceBase::Local(index)) = *place {\n             match self.locals[index] {\n                 LocalRef::Place(place) => {\n                     return place;\n@@ -407,8 +407,8 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         }\n \n         let result = match *place {\n-            mir::Place::Local(_) => bug!(), // handled above\n-            mir::Place::Promoted(box (index, ty)) => {\n+            mir::Place::Base(mir::PlaceBase::Local(_)) => bug!(), // handled above\n+            mir::Place::Base(mir::PlaceBase::Promoted(box (index, ty))) => {\n                 let param_env = ty::ParamEnv::reveal_all();\n                 let cid = mir::interpret::GlobalId {\n                     instance: self.instance,\n@@ -435,7 +435,7 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                     }\n                 }\n             }\n-            mir::Place::Static(box mir::Static { def_id, ty }) => {\n+            mir::Place::Base(mir::PlaceBase::Static(box mir::Static { def_id, ty })) => {\n                 // NB: The layout of a static may be unsized as is the case when working\n                 // with a static that is an extern_type.\n                 let layout = cx.layout_of(self.monomorphize(&ty));\n@@ -457,7 +457,9 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n                         cg_base.project_field(bx, field.index())\n                     }\n                     mir::ProjectionElem::Index(index) => {\n-                        let index = &mir::Operand::Copy(mir::Place::Local(index));\n+                        let index = &mir::Operand::Copy(\n+                            mir::Place::Base(mir::PlaceBase::Local(index))\n+                        );\n                         let index = self.codegen_operand(bx, index);\n                         let llindex = index.immediate();\n                         cg_base.project_index(bx, llindex)"}, {"sha": "b0c667a965daa3c79e071a107dac6c532daf5bad", "filename": "src/librustc_codegen_ssa/mir/rvalue.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Frvalue.rs?ref=0f993d5a7abfe156a261d7a53f4297e8b05cc91f", "patch": "@@ -534,7 +534,7 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n     ) -> Bx::Value {\n         // ZST are passed as operands and require special handling\n         // because codegen_place() panics if Local is operand.\n-        if let mir::Place::Local(index) = *place {\n+        if let mir::Place::Base(mir::PlaceBase::Local(index)) = *place {\n             if let LocalRef::Operand(Some(op)) = self.locals[index] {\n                 if let ty::Array(_, n) = op.layout.ty.sty {\n                     let n = n.unwrap_usize(bx.cx().tcx());"}, {"sha": "97729e8aeb35fce44b4e627120dcdcc16be7a1e5", "filename": "src/librustc_codegen_ssa/mir/statement.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_codegen_ssa%2Fmir%2Fstatement.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_codegen_ssa%2Fmir%2Fstatement.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_ssa%2Fmir%2Fstatement.rs?ref=0f993d5a7abfe156a261d7a53f4297e8b05cc91f", "patch": "@@ -17,7 +17,7 @@ impl<'a, 'tcx: 'a, Bx: BuilderMethods<'a, 'tcx>> FunctionCx<'a, 'tcx, Bx> {\n         self.set_debug_loc(&mut bx, statement.source_info);\n         match statement.kind {\n             mir::StatementKind::Assign(ref place, ref rvalue) => {\n-                if let mir::Place::Local(index) = *place {\n+                if let mir::Place::Base(mir::PlaceBase::Local(index)) = *place {\n                     match self.locals[index] {\n                         LocalRef::Place(cg_dest) => {\n                             self.codegen_rvalue(bx, cg_dest, rvalue)"}, {"sha": "cbef7a7f6c481326bbc90bf6e6b1f27289ca6633", "filename": "src/librustc_mir/borrow_check/borrow_set.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fborrow_set.rs?ref=0f993d5a7abfe156a261d7a53f4297e8b05cc91f", "patch": "@@ -333,7 +333,7 @@ impl<'a, 'gcx, 'tcx> GatherBorrows<'a, 'gcx, 'tcx> {\n         //    TEMP = &foo\n         //\n         // so extract `temp`.\n-        let temp = if let &mir::Place::Local(temp) = assigned_place {\n+        let temp = if let &mir::Place::Base(mir::PlaceBase::Local(temp)) = assigned_place {\n             temp\n         } else {\n             span_bug!("}, {"sha": "dc1979b6380b1d92a345557df28e5b6acb72b4f9", "filename": "src/librustc_mir/borrow_check/error_reporting.rs", "status": "modified", "additions": 28, "deletions": 21, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Ferror_reporting.rs?ref=0f993d5a7abfe156a261d7a53f4297e8b05cc91f", "patch": "@@ -8,7 +8,7 @@ use rustc::middle::region::ScopeTree;\n use rustc::mir::{\n     self, AggregateKind, BindingForm, BorrowKind, ClearCrossCrate, Constant,\n     ConstraintCategory, Field, Local, LocalDecl, LocalKind, Location, Operand,\n-    Place, PlaceProjection, ProjectionElem, Rvalue, Statement, StatementKind,\n+    Place, PlaceBase, PlaceProjection, ProjectionElem, Rvalue, Statement, StatementKind,\n     TerminatorKind, VarBindingForm,\n };\n use rustc::ty::{self, DefIdTree};\n@@ -220,7 +220,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                         );\n                     }\n                 }\n-                if let Place::Local(local) = place {\n+                if let Place::Base(PlaceBase::Local(local)) = place {\n                     let decl = &self.mir.local_decls[*local];\n                     err.span_label(\n                         decl.source_info.span,\n@@ -679,7 +679,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         let borrow_span = borrow_spans.var_or_use();\n \n         let proper_span = match *root_place {\n-            Place::Local(local) => self.mir.local_decls[local].source_info.span,\n+            Place::Base(PlaceBase::Local(local)) => self.mir.local_decls[local].source_info.span,\n             _ => drop_span,\n         };\n \n@@ -1061,7 +1061,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n         let (place_desc, note) = if let Some(place_desc) = opt_place_desc {\n             let local_kind = match borrow.borrowed_place {\n-                Place::Local(local) => {\n+                Place::Base(PlaceBase::Local(local)) => {\n                     match self.mir.local_kind(local) {\n                         LocalKind::ReturnPointer\n                         | LocalKind::Temp => bug!(\"temporary or return pointer with a name\"),\n@@ -1086,7 +1086,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             let root_place = self.prefixes(&borrow.borrowed_place, PrefixSet::All)\n                 .last()\n                 .unwrap();\n-            let local = if let Place::Local(local) = *root_place {\n+            let local = if let Place::Base(PlaceBase::Local(local)) = *root_place {\n                 local\n             } else {\n                 bug!(\"report_cannot_return_reference_to_local: not a local\")\n@@ -1385,7 +1385,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         assigned_span: Span,\n         err_place: &Place<'tcx>,\n     ) {\n-        let (from_arg, local_decl) = if let Place::Local(local) = *err_place {\n+        let (from_arg, local_decl) = if let Place::Base(PlaceBase::Local(local)) = *err_place {\n             if let LocalKind::Arg = self.mir.local_kind(local) {\n                 (true, Some(&self.mir.local_decls[local]))\n             } else {\n@@ -1600,13 +1600,13 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         including_downcast: &IncludingDowncast,\n     ) -> Result<(), ()> {\n         match *place {\n-            Place::Promoted(_) => {\n+            Place::Base(PlaceBase::Promoted(_)) => {\n                 buf.push_str(\"promoted\");\n             }\n-            Place::Local(local) => {\n+            Place::Base(PlaceBase::Local(local)) => {\n                 self.append_local_to_string(local, buf)?;\n             }\n-            Place::Static(ref static_) => {\n+            Place::Base(PlaceBase::Static(ref static_)) => {\n                 buf.push_str(&self.infcx.tcx.item_name(static_.def_id).to_string());\n             }\n             Place::Projection(ref proj) => {\n@@ -1630,7 +1630,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                                     autoderef,\n                                     &including_downcast,\n                                 )?;\n-                            } else if let Place::Local(local) = proj.base {\n+                            } else if let Place::Base(PlaceBase::Local(local)) = proj.base {\n                                 if let Some(ClearCrossCrate::Set(BindingForm::RefForGuard)) =\n                                     self.mir.local_decls[local].is_user_variable\n                                 {\n@@ -1742,12 +1742,14 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     /// End-user visible description of the `field`nth field of `base`\n     fn describe_field(&self, base: &Place<'_>, field: Field) -> String {\n         match *base {\n-            Place::Local(local) => {\n+            Place::Base(PlaceBase::Local(local)) => {\n                 let local = &self.mir.local_decls[local];\n                 self.describe_field_from_ty(&local.ty, field)\n             }\n-            Place::Promoted(ref prom) => self.describe_field_from_ty(&prom.1, field),\n-            Place::Static(ref static_) => self.describe_field_from_ty(&static_.ty, field),\n+            Place::Base(PlaceBase::Promoted(ref prom)) =>\n+                self.describe_field_from_ty(&prom.1, field),\n+            Place::Base(PlaceBase::Static(ref static_)) =>\n+                self.describe_field_from_ty(&static_.ty, field),\n             Place::Projection(ref proj) => match proj.elem {\n                 ProjectionElem::Deref => self.describe_field(&proj.base, field),\n                 ProjectionElem::Downcast(def, variant_index) =>\n@@ -1809,7 +1811,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n \n     /// Checks if a place is a thread-local static.\n     pub fn is_place_thread_local(&self, place: &Place<'tcx>) -> bool {\n-        if let Place::Static(statik) = place {\n+        if let Place::Base(PlaceBase::Static(statik)) = place {\n             let attrs = self.infcx.tcx.get_attrs(statik.def_id);\n             let is_thread_local = attrs.iter().any(|attr| attr.check_name(\"thread_local\"));\n \n@@ -1827,7 +1829,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     fn classify_drop_access_kind(&self, place: &Place<'tcx>) -> StorageDeadOrDrop<'tcx> {\n         let tcx = self.infcx.tcx;\n         match place {\n-            Place::Local(_) | Place::Static(_) | Place::Promoted(_) => {\n+            Place::Base(PlaceBase::Local(_)) |\n+            Place::Base(PlaceBase::Static(_)) |\n+            Place::Base(PlaceBase::Promoted(_)) => {\n                 StorageDeadOrDrop::LocalStorageDead\n             }\n             Place::Projection(box PlaceProjection { base, elem }) => {\n@@ -1912,7 +1916,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             );\n             // Check that the initial assignment of the reserve location is into a temporary.\n             let mut target = *match reservation {\n-                Place::Local(local) if self.mir.local_kind(*local) == LocalKind::Temp => local,\n+                Place::Base(PlaceBase::Local(local))\n+                    if self.mir.local_kind(*local) == LocalKind::Temp => local,\n                 _ => return None,\n             };\n \n@@ -1924,8 +1929,10 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     \"annotate_argument_and_return_for_borrow: target={:?} stmt={:?}\",\n                     target, stmt\n                 );\n-                if let StatementKind::Assign(Place::Local(assigned_to), box rvalue) = &stmt.kind\n-                {\n+                if let StatementKind::Assign(\n+                    Place::Base(PlaceBase::Local(assigned_to)),\n+                    box rvalue\n+                ) = &stmt.kind {\n                     debug!(\n                         \"annotate_argument_and_return_for_borrow: assigned_to={:?} \\\n                          rvalue={:?}\",\n@@ -2048,7 +2055,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 target, terminator\n             );\n             if let TerminatorKind::Call {\n-                destination: Some((Place::Local(assigned_to), _)),\n+                destination: Some((Place::Base(PlaceBase::Local(assigned_to)), _)),\n                 args,\n                 ..\n             } = &terminator.kind\n@@ -2496,7 +2503,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             .get(location.statement_index)\n         {\n             Some(&Statement {\n-                kind: StatementKind::Assign(Place::Local(local), _),\n+                kind: StatementKind::Assign(Place::Base(PlaceBase::Local(local)), _),\n                 ..\n             }) => local,\n             _ => return OtherUse(use_span),\n@@ -2522,7 +2529,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     def_id, is_generator, places\n                 );\n                 if let Some((args_span, var_span)) = self.closure_span(\n-                    *def_id, &Place::Local(target), places\n+                    *def_id, &Place::Base(PlaceBase::Local(target)), places\n                 ) {\n                     return ClosureUse {\n                         is_generator,"}, {"sha": "715ee856a7a6268975885fbec4a89417d3824ead", "filename": "src/librustc_mir/borrow_check/mod.rs", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmod.rs?ref=0f993d5a7abfe156a261d7a53f4297e8b05cc91f", "patch": "@@ -8,7 +8,7 @@ use rustc::infer::InferCtxt;\n use rustc::lint::builtin::UNUSED_MUT;\n use rustc::middle::borrowck::SignalledError;\n use rustc::mir::{AggregateKind, BasicBlock, BorrowCheckResult, BorrowKind};\n-use rustc::mir::{ClearCrossCrate, Local, Location, Mir, Mutability, Operand, Place};\n+use rustc::mir::{ClearCrossCrate, Local, Location, Mir, Mutability, Operand, Place, PlaceBase};\n use rustc::mir::{Field, Projection, ProjectionElem, Rvalue, Statement, StatementKind};\n use rustc::mir::{Terminator, TerminatorKind};\n use rustc::ty::query::Providers;\n@@ -588,7 +588,7 @@ impl<'cx, 'gcx, 'tcx> DataflowResultsConsumer<'cx, 'tcx> for MirBorrowckCtxt<'cx\n             StatementKind::StorageDead(local) => {\n                 self.access_place(\n                     ContextKind::StorageDead.new(location),\n-                    (&Place::Local(local), span),\n+                    (&Place::Base(PlaceBase::Local(local)), span),\n                     (Shallow(None), Write(WriteKind::StorageDeadOrDrop)),\n                     LocalMutationIsAllowed::Yes,\n                     flow_state,\n@@ -1104,7 +1104,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         // Special case: you can assign a immutable local variable\n         // (e.g., `x = ...`) so long as it has never been initialized\n         // before (at this point in the flow).\n-        if let &Place::Local(local) = place_span.0 {\n+        if let &Place::Base(PlaceBase::Local(local)) = place_span.0 {\n             if let Mutability::Not = self.mir.local_decls[local].mutability {\n                 // check for reassignments to immutable local variables\n                 self.check_if_reassignment_to_immutable_state(\n@@ -1231,8 +1231,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                             // captures of a closure are copied/moved directly\n                             // when generating MIR.\n                             match operands[field.index()] {\n-                                Operand::Move(Place::Local(local))\n-                                | Operand::Copy(Place::Local(local)) => {\n+                                Operand::Move(Place::Base(PlaceBase::Local(local)))\n+                                | Operand::Copy(Place::Base(PlaceBase::Local(local))) => {\n                                     self.used_mut.insert(local);\n                                 }\n                                 Operand::Move(ref place @ Place::Projection(_))\n@@ -1242,10 +1242,10 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                                         self.used_mut_upvars.push(field);\n                                     }\n                                 }\n-                                Operand::Move(Place::Static(..))\n-                                | Operand::Copy(Place::Static(..))\n-                                | Operand::Move(Place::Promoted(..))\n-                                | Operand::Copy(Place::Promoted(..))\n+                                Operand::Move(Place::Base(PlaceBase::Static(..)))\n+                                | Operand::Copy(Place::Base(PlaceBase::Static(..)))\n+                                | Operand::Move(Place::Base(PlaceBase::Promoted(..)))\n+                                | Operand::Copy(Place::Base(PlaceBase::Promoted(..)))\n                                 | Operand::Constant(..) => {}\n                             }\n                         }\n@@ -1328,14 +1328,14 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         //\n         // FIXME: allow thread-locals to borrow other thread locals?\n         let (might_be_alive, will_be_dropped) = match root_place {\n-            Place::Promoted(_) => (true, false),\n-            Place::Static(_) => {\n+            Place::Base(PlaceBase::Promoted(_)) => (true, false),\n+            Place::Base(PlaceBase::Static(_)) => {\n                 // Thread-locals might be dropped after the function exits, but\n                 // \"true\" statics will never be.\n                 let is_thread_local = self.is_place_thread_local(&root_place);\n                 (true, is_thread_local)\n             }\n-            Place::Local(_) => {\n+            Place::Base(PlaceBase::Local(_)) => {\n                 // Locals are always dropped at function exit, and if they\n                 // have a destructor it would've been called already.\n                 (false, self.locals_are_invalidated_at_exit)\n@@ -1594,10 +1594,10 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             last_prefix = prefix;\n         }\n         match *last_prefix {\n-            Place::Local(_) => panic!(\"should have move path for every Local\"),\n+            Place::Base(PlaceBase::Local(_)) => panic!(\"should have move path for every Local\"),\n             Place::Projection(_) => panic!(\"PrefixSet::All meant don't stop for Projection\"),\n-            Place::Promoted(_) |\n-            Place::Static(_) => Err(NoMovePathFound::ReachedStatic),\n+            Place::Base(PlaceBase::Promoted(_)) |\n+            Place::Base(PlaceBase::Static(_)) => Err(NoMovePathFound::ReachedStatic),\n         }\n     }\n \n@@ -1623,8 +1623,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         let mut place = place;\n         loop {\n             match *place {\n-                Place::Promoted(_) |\n-                Place::Local(_) | Place::Static(_) => {\n+                Place::Base(PlaceBase::Promoted(_)) |\n+                Place::Base(PlaceBase::Local(_)) | Place::Base(PlaceBase::Static(_)) => {\n                     // assigning to `x` does not require `x` be initialized.\n                     break;\n                 }\n@@ -1947,7 +1947,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n     ) {\n         match root_place {\n             RootPlace {\n-                place: Place::Local(local),\n+                place: Place::Base(PlaceBase::Local(local)),\n                 is_local_mutation_allowed,\n             } => {\n                 // If the local may have been initialized, and it is now currently being\n@@ -1972,11 +1972,11 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 }\n             }\n             RootPlace {\n-                place: Place::Promoted(..),\n+                place: Place::Base(PlaceBase::Promoted(..)),\n                 is_local_mutation_allowed: _,\n             } => {}\n             RootPlace {\n-                place: Place::Static(..),\n+                place: Place::Base(PlaceBase::Static(..)),\n                 is_local_mutation_allowed: _,\n             } => {}\n         }\n@@ -1990,7 +1990,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         is_local_mutation_allowed: LocalMutationIsAllowed,\n     ) -> Result<RootPlace<'d, 'tcx>, &'d Place<'tcx>> {\n         match *place {\n-            Place::Local(local) => {\n+            Place::Base(PlaceBase::Local(local)) => {\n                 let local = &self.mir.local_decls[local];\n                 match local.mutability {\n                     Mutability::Not => match is_local_mutation_allowed {\n@@ -2012,11 +2012,11 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             }\n             // The rules for promotion are made by `qualify_consts`, there wouldn't even be a\n             // `Place::Promoted` if the promotion weren't 100% legal. So we just forward this\n-            Place::Promoted(_) => Ok(RootPlace {\n+            Place::Base(PlaceBase::Promoted(_)) => Ok(RootPlace {\n                 place,\n                 is_local_mutation_allowed,\n             }),\n-            Place::Static(ref static_) => {\n+            Place::Base(PlaceBase::Static(ref static_)) => {\n                 if self.infcx.tcx.is_static(static_.def_id) != Some(hir::Mutability::MutMutable) {\n                     Err(place)\n                 } else {"}, {"sha": "bd4bf67d0b154b3856c71fcae5c4dd8b9fffa462", "filename": "src/librustc_mir/borrow_check/move_errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmove_errors.rs?ref=0f993d5a7abfe156a261d7a53f4297e8b05cc91f", "patch": "@@ -111,7 +111,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                 // If that ever stops being the case, then the ever initialized\n                 // flow could be used.\n                 if let Some(StatementKind::Assign(\n-                    Place::Local(local),\n+                    Place::Base(PlaceBase::Local(local)),\n                     box Rvalue::Use(Operand::Move(move_from)),\n                 )) = self.mir.basic_blocks()[location.block]\n                     .statements"}, {"sha": "f68ed4422bca08eaaa8be21f5d6579b10e0d0b60", "filename": "src/librustc_mir/borrow_check/mutability_errors.rs", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fmutability_errors.rs?ref=0f993d5a7abfe156a261d7a53f4297e8b05cc91f", "patch": "@@ -1,8 +1,8 @@\n use rustc::hir;\n use rustc::hir::Node;\n use rustc::mir::{self, BindingForm, Constant, ClearCrossCrate, Local, Location, Mir};\n-use rustc::mir::{Mutability, Operand, Place, Projection, ProjectionElem, Static, Terminator};\n-use rustc::mir::TerminatorKind;\n+use rustc::mir::{Mutability, Operand, Place, PlaceBase, Projection, ProjectionElem, Static};\n+use rustc::mir::{Terminator, TerminatorKind};\n use rustc::ty::{self, Const, DefIdTree, TyS, TyKind, TyCtxt};\n use rustc_data_structures::indexed_vec::Idx;\n use syntax_pos::Span;\n@@ -45,9 +45,9 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n         debug!(\"report_mutability_error: access_place_desc={:?}\", access_place_desc);\n \n         match the_place_err {\n-            Place::Local(local) => {\n+            Place::Base(PlaceBase::Local(local)) => {\n                 item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n-                if let Place::Local(_) = access_place {\n+                if let Place::Base(PlaceBase::Local(_)) = access_place {\n                     reason = \", as it is not declared as mutable\".to_string();\n                 } else {\n                     let name = self.mir.local_decls[*local]\n@@ -78,7 +78,8 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                 base,\n                 elem: ProjectionElem::Deref,\n             }) => {\n-                if *base == Place::Local(Local::new(1)) && !self.mir.upvar_decls.is_empty() {\n+                if *base == Place::Base(PlaceBase::Local(Local::new(1))) &&\n+                    !self.mir.upvar_decls.is_empty() {\n                     item_msg = format!(\"`{}`\", access_place_desc.unwrap());\n                     debug_assert!(self.mir.local_decls[Local::new(1)].ty.is_region_ptr());\n                     debug_assert!(is_closure_or_generator(\n@@ -92,7 +93,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                         \", as `Fn` closures cannot mutate their captured variables\".to_string()\n                     }\n                 } else if {\n-                    if let Place::Local(local) = *base {\n+                    if let Place::Base(PlaceBase::Local(local)) = *base {\n                         if let Some(ClearCrossCrate::Set(BindingForm::RefForGuard))\n                             = self.mir.local_decls[local].is_user_variable {\n                                 true\n@@ -128,10 +129,10 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n                 }\n             }\n \n-            Place::Promoted(_) => unreachable!(),\n+            Place::Base(PlaceBase::Promoted(_)) => unreachable!(),\n \n-            Place::Static(box Static { def_id, ty: _ }) => {\n-                if let Place::Static(_) = access_place {\n+            Place::Base(PlaceBase::Static(box Static { def_id, ty: _ })) => {\n+                if let Place::Base(PlaceBase::Static(_)) = access_place {\n                     item_msg = format!(\"immutable static item `{}`\", access_place_desc.unwrap());\n                     reason = String::new();\n                 } else {\n@@ -241,7 +242,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n             },\n \n             // Suggest removing a `&mut` from the use of a mutable reference.\n-            Place::Local(local)\n+            Place::Base(PlaceBase::Local(local))\n                 if {\n                     self.mir.local_decls.get(*local).map(|local_decl| {\n                         if let ClearCrossCrate::Set(\n@@ -276,7 +277,8 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n \n             // We want to suggest users use `let mut` for local (user\n             // variable) mutations...\n-            Place::Local(local) if self.mir.local_decls[*local].can_be_made_mutable() => {\n+            Place::Base(PlaceBase::Local(local))\n+                if self.mir.local_decls[*local].can_be_made_mutable() => {\n                 // ... but it doesn't make sense to suggest it on\n                 // variables that are `ref x`, `ref mut x`, `&self`,\n                 // or `&mut self` (such variables are simply not\n@@ -330,7 +332,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n             // complete hack to approximate old AST-borrowck\n             // diagnostic: if the span starts with a mutable borrow of\n             // a local variable, then just suggest the user remove it.\n-            Place::Local(_)\n+            Place::Base(PlaceBase::Local(_))\n                 if {\n                     if let Ok(snippet) = self.infcx.tcx.sess.source_map().span_to_snippet(span) {\n                         snippet.starts_with(\"&mut \")\n@@ -344,7 +346,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n             }\n \n             Place::Projection(box Projection {\n-                base: Place::Local(local),\n+                base: Place::Base(PlaceBase::Local(local)),\n                 elem: ProjectionElem::Deref,\n             }) if {\n                 if let Some(ClearCrossCrate::Set(BindingForm::RefForGuard)) =\n@@ -368,7 +370,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n             // FIXME: can this case be generalized to work for an\n             // arbitrary base for the projection?\n             Place::Projection(box Projection {\n-                base: Place::Local(local),\n+                base: Place::Base(PlaceBase::Local(local)),\n                 elem: ProjectionElem::Deref,\n             }) if self.mir.local_decls[*local].is_user_variable.is_some() =>\n             {\n@@ -447,7 +449,8 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n             Place::Projection(box Projection {\n                 base,\n                 elem: ProjectionElem::Deref,\n-            }) if *base == Place::Local(Local::new(1)) && !self.mir.upvar_decls.is_empty() =>\n+            }) if *base == Place::Base(PlaceBase::Local(Local::new(1))) &&\n+                  !self.mir.upvar_decls.is_empty() =>\n             {\n                 err.span_label(span, format!(\"cannot {ACT}\", ACT = act));\n                 err.span_help(\n@@ -457,7 +460,7 @@ impl<'a, 'gcx, 'tcx> MirBorrowckCtxt<'a, 'gcx, 'tcx> {\n             }\n \n             Place::Projection(box Projection {\n-                base: Place::Local(local),\n+                base: Place::Base(PlaceBase::Local(local)),\n                 elem: ProjectionElem::Deref,\n             })  if error_access == AccessKind::MutableBorrow => {\n                 err.span_label(span, format!(\"cannot {ACT}\", ACT = act));"}, {"sha": "375dd6e97f1a29511f3a418fb587719687cd16cd", "filename": "src/librustc_mir/borrow_check/nll/constraint_generation.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fconstraint_generation.rs?ref=0f993d5a7abfe156a261d7a53f4297e8b05cc91f", "patch": "@@ -6,7 +6,7 @@ use crate::borrow_check::nll::region_infer::values::LivenessValues;\n use rustc::infer::InferCtxt;\n use rustc::mir::visit::TyContext;\n use rustc::mir::visit::Visitor;\n-use rustc::mir::{BasicBlock, BasicBlockData, Location, Mir, Place, Rvalue};\n+use rustc::mir::{BasicBlock, BasicBlockData, Location, Mir, Place, PlaceBase, Rvalue};\n use rustc::mir::{SourceInfo, Statement, Terminator};\n use rustc::mir::UserTypeProjection;\n use rustc::ty::fold::TypeFoldable;\n@@ -130,7 +130,7 @@ impl<'cg, 'cx, 'gcx, 'tcx> Visitor<'tcx> for ConstraintGeneration<'cg, 'cx, 'gcx\n         // When we see `X = ...`, then kill borrows of\n         // `(*X).foo` and so forth.\n         if let Some(all_facts) = self.all_facts {\n-            if let Place::Local(temp) = place {\n+            if let Place::Base(PlaceBase::Local(temp)) = place {\n                 if let Some(borrow_indices) = self.borrow_set.local_map.get(temp) {\n                     all_facts.killed.reserve(borrow_indices.len());\n                     for &borrow_index in borrow_indices {"}, {"sha": "17f8c23f4fddc0cdf43c686e97f8f3bc0558a725", "filename": "src/librustc_mir/borrow_check/nll/explain_borrow/mod.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fexplain_borrow%2Fmod.rs?ref=0f993d5a7abfe156a261d7a53f4297e8b05cc91f", "patch": "@@ -6,8 +6,8 @@ use crate::borrow_check::nll::region_infer::{Cause, RegionName};\n use crate::borrow_check::nll::ConstraintDescription;\n use crate::borrow_check::{Context, MirBorrowckCtxt, WriteKind};\n use rustc::mir::{\n-    CastKind, ConstraintCategory, FakeReadCause, Local, Location, Mir, Operand, Place, Projection,\n-    ProjectionElem, Rvalue, Statement, StatementKind, TerminatorKind,\n+    CastKind, ConstraintCategory, FakeReadCause, Local, Location, Mir, Operand, Place, PlaceBase,\n+    Projection, ProjectionElem, Rvalue, Statement, StatementKind, TerminatorKind,\n };\n use rustc::ty::{self, TyCtxt};\n use rustc_data_structures::fx::FxHashSet;\n@@ -245,7 +245,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n             Some(Cause::LiveVar(local, location)) => {\n                 let span = mir.source_info(location).span;\n                 let spans = self\n-                    .move_spans(&Place::Local(local), location)\n+                    .move_spans(&Place::Base(PlaceBase::Local(local)), location)\n                     .or_else(|| self.borrow_spans(span, location));\n \n                 let borrow_location = context.loc;\n@@ -265,7 +265,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 let mut should_note_order = false;\n                 if mir.local_decls[local].name.is_some() {\n                     if let Some((WriteKind::StorageDeadOrDrop, place)) = kind_place {\n-                        if let Place::Local(borrowed_local) = place {\n+                        if let Place::Base(PlaceBase::Local(borrowed_local)) = place {\n                             let dropped_local_scope = mir.local_decls[local].visibility_scope;\n                             let borrowed_local_scope =\n                                 mir.local_decls[*borrowed_local].visibility_scope;\n@@ -481,7 +481,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                         // Just point to the function, to reduce the chance of overlapping spans.\n                         let function_span = match func {\n                             Operand::Constant(c) => c.span,\n-                            Operand::Copy(Place::Local(l)) | Operand::Move(Place::Local(l)) => {\n+                            Operand::Copy(Place::Base(PlaceBase::Local(l))) |\n+                            Operand::Move(Place::Base(PlaceBase::Local(l))) => {\n                                 let local_decl = &self.mir.local_decls[*l];\n                                 if local_decl.name.is_none() {\n                                     local_decl.source_info.span\n@@ -522,7 +523,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n         // it which simplifies the termination logic.\n         let mut queue = vec![location];\n         let mut target = if let Some(&Statement {\n-            kind: StatementKind::Assign(Place::Local(local), _),\n+            kind: StatementKind::Assign(Place::Base(PlaceBase::Local(local)), _),\n             ..\n         }) = stmt\n         {\n@@ -547,9 +548,9 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 // The only kind of statement that we care about is assignments...\n                 if let StatementKind::Assign(place, box rvalue) = &stmt.kind {\n                     let into = match place {\n-                        Place::Local(into) => into,\n+                        Place::Base(PlaceBase::Local(into)) => into,\n                         Place::Projection(box Projection {\n-                            base: Place::Local(into),\n+                            base: Place::Base(PlaceBase::Local(into)),\n                             elem: ProjectionElem::Deref,\n                         }) => into,\n                         _ => {\n@@ -563,8 +564,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                         // If we see a use, we should check whether it is our data, and if so\n                         // update the place that we're looking for to that new place.\n                         Rvalue::Use(operand) => match operand {\n-                            Operand::Copy(Place::Local(from))\n-                            | Operand::Move(Place::Local(from))\n+                            Operand::Copy(Place::Base(PlaceBase::Local(from)))\n+                            | Operand::Move(Place::Base(PlaceBase::Local(from)))\n                                 if *from == target =>\n                             {\n                                 target = *into;\n@@ -574,8 +575,8 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                         // If we see a unsized cast, then if it is our data we should check\n                         // whether it is being cast to a trait object.\n                         Rvalue::Cast(CastKind::Unsize, operand, ty) => match operand {\n-                            Operand::Copy(Place::Local(from))\n-                            | Operand::Move(Place::Local(from))\n+                            Operand::Copy(Place::Base(PlaceBase::Local(from)))\n+                            | Operand::Move(Place::Base(PlaceBase::Local(from)))\n                                 if *from == target =>\n                             {\n                                 debug!(\"was_captured_by_trait_object: ty={:?}\", ty);\n@@ -605,7 +606,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                 debug!(\"was_captured_by_trait_object: terminator={:?}\", terminator);\n \n                 if let TerminatorKind::Call {\n-                    destination: Some((Place::Local(dest), block)),\n+                    destination: Some((Place::Base(PlaceBase::Local(dest)), block)),\n                     args,\n                     ..\n                 } = &terminator.kind\n@@ -616,7 +617,7 @@ impl<'cx, 'gcx, 'tcx> MirBorrowckCtxt<'cx, 'gcx, 'tcx> {\n                     );\n                     // Check if one of the arguments to this function is the target place.\n                     let found_target = args.iter().any(|arg| {\n-                        if let Operand::Move(Place::Local(potential)) = arg {\n+                        if let Operand::Move(Place::Base(PlaceBase::Local(potential))) = arg {\n                             *potential == target\n                         } else {\n                             false"}, {"sha": "aafbff35776475a91d47624ba015b9b078e59906", "filename": "src/librustc_mir/borrow_check/nll/invalidation.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Finvalidation.rs?ref=0f993d5a7abfe156a261d7a53f4297e8b05cc91f", "patch": "@@ -12,7 +12,7 @@ use crate::borrow_check::path_utils::*;\n use crate::dataflow::move_paths::indexes::BorrowIndex;\n use rustc::ty::TyCtxt;\n use rustc::mir::visit::Visitor;\n-use rustc::mir::{BasicBlock, Location, Mir, Place, Rvalue};\n+use rustc::mir::{BasicBlock, Location, Mir, Place, PlaceBase, Rvalue};\n use rustc::mir::{Statement, StatementKind};\n use rustc::mir::{Terminator, TerminatorKind};\n use rustc::mir::{Operand, BorrowKind};\n@@ -131,7 +131,7 @@ impl<'cx, 'tcx, 'gcx> Visitor<'tcx> for InvalidationGenerator<'cx, 'tcx, 'gcx> {\n             StatementKind::StorageDead(local) => {\n                 self.access_place(\n                     ContextKind::StorageDead.new(location),\n-                    &Place::Local(local),\n+                    &Place::Base(PlaceBase::Local(local)),\n                     (Shallow(None), Write(WriteKind::StorageDeadOrDrop)),\n                     LocalMutationIsAllowed::Yes,\n                 );"}, {"sha": "cf054c2d05505d73586b92d33403bed420f46318", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=0f993d5a7abfe156a261d7a53f4297e8b05cc91f", "patch": "@@ -451,10 +451,10 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n     ) -> PlaceTy<'tcx> {\n         debug!(\"sanitize_place: {:?}\", place);\n         let place_ty = match *place {\n-            Place::Local(index) => PlaceTy::Ty {\n+            Place::Base(PlaceBase::Local(index)) => PlaceTy::Ty {\n                 ty: self.mir.local_decls[index].ty,\n             },\n-            Place::Promoted(box (_index, sty)) => {\n+            Place::Base(PlaceBase::Promoted(box (_index, sty))) => {\n                 let sty = self.sanitize_type(place, sty);\n                 // FIXME -- promoted MIR return types reference\n                 // various \"free regions\" (e.g., scopes and things)\n@@ -469,7 +469,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                 // promoted_mir.return_ty()\n                 PlaceTy::Ty { ty: sty }\n             }\n-            Place::Static(box Static { def_id, ty: sty }) => {\n+            Place::Base(PlaceBase::Static(box Static { def_id, ty: sty })) => {\n                 let sty = self.sanitize_type(place, sty);\n                 let ty = self.tcx().type_of(def_id);\n                 let ty = self.cx.normalize(ty, location);\n@@ -553,7 +553,7 @@ impl<'a, 'b, 'gcx, 'tcx> TypeVerifier<'a, 'b, 'gcx, 'tcx> {\n                 }\n             }\n             ProjectionElem::Index(i) => {\n-                let index_ty = Place::Local(i).ty(self.mir, tcx).to_ty(tcx);\n+                let index_ty = Place::Base(PlaceBase::Local(i)).ty(self.mir, tcx).to_ty(tcx);\n                 if index_ty != tcx.types.usize {\n                     PlaceTy::Ty {\n                         ty: span_mirbug_and_err!(self, i, \"index by non-usize {:?}\", i),\n@@ -1234,7 +1234,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                 // of lowering. Assignments to other sorts of places *are* interesting\n                 // though.\n                 let category = match *place {\n-                    Place::Local(RETURN_PLACE) => if let Some(BorrowCheckContext {\n+                    Place::Base(PlaceBase::Local(RETURN_PLACE)) => if let Some(BorrowCheckContext {\n                         universal_regions:\n                             UniversalRegions {\n                                 defining_ty: DefiningTy::Const(def_id, _),\n@@ -1251,7 +1251,8 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                     } else {\n                         ConstraintCategory::Return\n                     },\n-                    Place::Local(l) if !mir.local_decls[l].is_user_variable.is_some() => {\n+                    Place::Base(PlaceBase::Local(l))\n+                        if !mir.local_decls[l].is_user_variable.is_some() => {\n                         ConstraintCategory::Boring\n                     }\n                     _ => ConstraintCategory::Assignment,\n@@ -1537,7 +1538,7 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n             Some((ref dest, _target_block)) => {\n                 let dest_ty = dest.ty(mir, tcx).to_ty(tcx);\n                 let category = match *dest {\n-                    Place::Local(RETURN_PLACE) => {\n+                    Place::Base(PlaceBase::Local(RETURN_PLACE)) => {\n                         if let Some(BorrowCheckContext {\n                             universal_regions:\n                                 UniversalRegions {\n@@ -1556,7 +1557,8 @@ impl<'a, 'gcx, 'tcx> TypeChecker<'a, 'gcx, 'tcx> {\n                             ConstraintCategory::Return\n                         }\n                     }\n-                    Place::Local(l) if !mir.local_decls[l].is_user_variable.is_some() => {\n+                    Place::Base(PlaceBase::Local(l))\n+                        if !mir.local_decls[l].is_user_variable.is_some() => {\n                         ConstraintCategory::Boring\n                     }\n                     _ => ConstraintCategory::Assignment,"}, {"sha": "9e0bb93c33a5d5fd0362875adc49b7e8b8c035c5", "filename": "src/librustc_mir/borrow_check/path_utils.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fpath_utils.rs?ref=0f993d5a7abfe156a261d7a53f4297e8b05cc91f", "patch": "@@ -3,7 +3,7 @@ use crate::borrow_check::places_conflict;\n use crate::borrow_check::Context;\n use crate::borrow_check::AccessDepth;\n use crate::dataflow::indexes::BorrowIndex;\n-use rustc::mir::{BasicBlock, Location, Mir, Place};\n+use rustc::mir::{BasicBlock, Location, Mir, Place, PlaceBase};\n use rustc::mir::{ProjectionElem, BorrowKind};\n use rustc::ty::TyCtxt;\n use rustc_data_structures::graph::dominators::Dominators;\n@@ -138,9 +138,9 @@ pub(super) fn is_active<'tcx>(\n /// This is called for all Yield statements on movable generators\n pub(super) fn borrow_of_local_data<'tcx>(place: &Place<'tcx>) -> bool {\n     match place {\n-        Place::Promoted(_) |\n-        Place::Static(..) => false,\n-        Place::Local(..) => true,\n+        Place::Base(PlaceBase::Promoted(_)) |\n+        Place::Base(PlaceBase::Static(..)) => false,\n+        Place::Base(PlaceBase::Local(..)) => true,\n         Place::Projection(box proj) => {\n             match proj.elem {\n                 // Reborrow of already borrowed data is ignored"}, {"sha": "c05ee3cf65b36447f48fb53fd11322dbfdd9c8f7", "filename": "src/librustc_mir/borrow_check/place_ext.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplace_ext.rs?ref=0f993d5a7abfe156a261d7a53f4297e8b05cc91f", "patch": "@@ -1,6 +1,6 @@\n use rustc::hir;\n use rustc::mir::ProjectionElem;\n-use rustc::mir::{Local, Mir, Place, Mutability};\n+use rustc::mir::{Local, Mir, Place, PlaceBase, Mutability};\n use rustc::ty::{self, TyCtxt};\n use crate::borrow_check::borrow_set::LocalsStateAtExit;\n \n@@ -30,7 +30,7 @@ impl<'tcx> PlaceExt<'tcx> for Place<'tcx> {\n         locals_state_at_exit: &LocalsStateAtExit,\n     ) -> bool {\n         match self {\n-            Place::Promoted(_) => false,\n+            Place::Base(PlaceBase::Promoted(_)) => false,\n \n             // If a local variable is immutable, then we only need to track borrows to guard\n             // against two kinds of errors:\n@@ -40,7 +40,7 @@ impl<'tcx> PlaceExt<'tcx> for Place<'tcx> {\n             //\n             // In particular, the variable cannot be mutated -- the \"access checks\" will fail --\n             // so we don't have to worry about mutation while borrowed.\n-            Place::Local(index) => {\n+            Place::Base(PlaceBase::Local(index)) => {\n                 match locals_state_at_exit {\n                     LocalsStateAtExit::AllAreInvalidated => false,\n                     LocalsStateAtExit::SomeAreInvalidated { has_storage_dead_or_moved } => {\n@@ -51,7 +51,7 @@ impl<'tcx> PlaceExt<'tcx> for Place<'tcx> {\n                     }\n                 }\n             }\n-            Place::Static(static_) => {\n+            Place::Base(PlaceBase::Static(static_)) => {\n                 tcx.is_static(static_.def_id) == Some(hir::Mutability::MutMutable)\n             }\n             Place::Projection(proj) => match proj.elem {\n@@ -88,9 +88,9 @@ impl<'tcx> PlaceExt<'tcx> for Place<'tcx> {\n         loop {\n             match p {\n                 Place::Projection(pi) => p = &pi.base,\n-                Place::Promoted(_) |\n-                Place::Static(_) => return None,\n-                Place::Local(l) => return Some(*l),\n+                Place::Base(PlaceBase::Promoted(_)) |\n+                Place::Base(PlaceBase::Static(_)) => return None,\n+                Place::Base(PlaceBase::Local(l)) => return Some(*l),\n             }\n         }\n     }"}, {"sha": "1d18ada1fb69c97dad8b7ace197d65bf6d729d5b", "filename": "src/librustc_mir/borrow_check/places_conflict.rs", "status": "modified", "additions": 14, "deletions": 12, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fplaces_conflict.rs?ref=0f993d5a7abfe156a261d7a53f4297e8b05cc91f", "patch": "@@ -2,8 +2,7 @@ use crate::borrow_check::ArtificialField;\n use crate::borrow_check::Overlap;\n use crate::borrow_check::{Deep, Shallow, AccessDepth};\n use rustc::hir;\n-use rustc::mir::{BorrowKind, Mir, Place};\n-use rustc::mir::{Projection, ProjectionElem};\n+use rustc::mir::{BorrowKind, Mir, Place, PlaceBase, Projection, ProjectionElem};\n use rustc::ty::{self, TyCtxt};\n use std::cmp::max;\n \n@@ -60,8 +59,8 @@ pub(super) fn borrow_conflicts_with_place<'gcx, 'tcx>(\n \n     // This Local/Local case is handled by the more general code below, but\n     // it's so common that it's a speed win to check for it first.\n-    if let Place::Local(l1) = borrow_place {\n-        if let Place::Local(l2) = access_place {\n+    if let Place::Base(PlaceBase::Local(l1)) = borrow_place {\n+        if let Place::Base(PlaceBase::Local(l2)) = access_place {\n             return l1 == l2;\n         }\n     }\n@@ -339,8 +338,8 @@ fn unroll_place<'tcx, R>(\n             op,\n         ),\n \n-        Place::Promoted(_) |\n-        Place::Local(_) | Place::Static(_) => {\n+        Place::Base(PlaceBase::Promoted(_)) |\n+        Place::Base(PlaceBase::Local(_)) | Place::Base(PlaceBase::Static(_)) => {\n             let list = PlaceComponents {\n                 component: place,\n                 next,\n@@ -361,7 +360,7 @@ fn place_element_conflict<'a, 'gcx: 'tcx, 'tcx>(\n     bias: PlaceConflictBias,\n ) -> Overlap {\n     match (elem1, elem2) {\n-        (Place::Local(l1), Place::Local(l2)) => {\n+        (Place::Base(PlaceBase::Local(l1)), Place::Base(PlaceBase::Local(l2))) => {\n             if l1 == l2 {\n                 // the same local - base case, equal\n                 debug!(\"place_element_conflict: DISJOINT-OR-EQ-LOCAL\");\n@@ -372,7 +371,7 @@ fn place_element_conflict<'a, 'gcx: 'tcx, 'tcx>(\n                 Overlap::Disjoint\n             }\n         }\n-        (Place::Static(static1), Place::Static(static2)) => {\n+        (Place::Base(PlaceBase::Static(static1)), Place::Base(PlaceBase::Static(static2))) => {\n             if static1.def_id != static2.def_id {\n                 debug!(\"place_element_conflict: DISJOINT-STATIC\");\n                 Overlap::Disjoint\n@@ -385,7 +384,7 @@ fn place_element_conflict<'a, 'gcx: 'tcx, 'tcx>(\n                 Overlap::EqualOrDisjoint\n             }\n         }\n-        (Place::Promoted(p1), Place::Promoted(p2)) => {\n+        (Place::Base(PlaceBase::Promoted(p1)), Place::Base(PlaceBase::Promoted(p2))) => {\n             if p1.0 == p2.0 {\n                 if let ty::Array(_, size) = p1.1.sty {\n                     if size.unwrap_usize(tcx) == 0 {\n@@ -403,9 +402,12 @@ fn place_element_conflict<'a, 'gcx: 'tcx, 'tcx>(\n                 Overlap::Disjoint\n             }\n         }\n-        (Place::Local(_), Place::Promoted(_)) | (Place::Promoted(_), Place::Local(_)) |\n-        (Place::Promoted(_), Place::Static(_)) | (Place::Static(_), Place::Promoted(_)) |\n-        (Place::Local(_), Place::Static(_)) | (Place::Static(_), Place::Local(_)) => {\n+        (Place::Base(PlaceBase::Local(_)), Place::Base(PlaceBase::Promoted(_))) |\n+        (Place::Base(PlaceBase::Promoted(_)), Place::Base(PlaceBase::Local(_))) |\n+        (Place::Base(PlaceBase::Promoted(_)), Place::Base(PlaceBase::Static(_))) |\n+        (Place::Base(PlaceBase::Static(_)), Place::Base(PlaceBase::Promoted(_))) |\n+        (Place::Base(PlaceBase::Local(_)), Place::Base(PlaceBase::Static(_))) |\n+        (Place::Base(PlaceBase::Static(_)), Place::Base(PlaceBase::Local(_))) => {\n             debug!(\"place_element_conflict: DISJOINT-STATIC-LOCAL-PROMOTED\");\n             Overlap::Disjoint\n         }"}, {"sha": "384fd5c9987b8a325103bec4fa2c79fd473c37bd", "filename": "src/librustc_mir/borrow_check/prefixes.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fprefixes.rs?ref=0f993d5a7abfe156a261d7a53f4297e8b05cc91f", "patch": "@@ -11,7 +11,7 @@ use super::MirBorrowckCtxt;\n \n use rustc::hir;\n use rustc::ty::{self, TyCtxt};\n-use rustc::mir::{Mir, Place, ProjectionElem};\n+use rustc::mir::{Mir, Place, PlaceBase, ProjectionElem};\n \n pub trait IsPrefixOf<'tcx> {\n     fn is_prefix_of(&self, other: &Place<'tcx>) -> bool;\n@@ -26,8 +26,9 @@ impl<'tcx> IsPrefixOf<'tcx> for Place<'tcx> {\n             }\n \n             match *cursor {\n-                Place::Promoted(_) |\n-                Place::Local(_) | Place::Static(_) => return false,\n+                Place::Base(PlaceBase::Promoted(_)) |\n+                Place::Base(PlaceBase::Local(_)) |\n+                Place::Base(PlaceBase::Static(_)) => return false,\n                 Place::Projection(ref proj) => {\n                     cursor = &proj.base;\n                 }\n@@ -86,9 +87,9 @@ impl<'cx, 'gcx, 'tcx> Iterator for Prefixes<'cx, 'gcx, 'tcx> {\n \n         'cursor: loop {\n             let proj = match *cursor {\n-                Place::Promoted(_) |\n-                Place::Local(_) | // search yielded this leaf\n-                Place::Static(_) => {\n+                Place::Base(PlaceBase::Promoted(_)) |\n+                Place::Base(PlaceBase::Local(_)) | // search yielded this leaf\n+                Place::Base(PlaceBase::Static(_)) => {\n                     self.next = None;\n                     return Some(cursor);\n                 }"}, {"sha": "b102bced0e335e18822f3a7d7019d464ae5297e3", "filename": "src/librustc_mir/borrow_check/used_muts.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Fborrow_check%2Fused_muts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Fborrow_check%2Fused_muts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fused_muts.rs?ref=0f993d5a7abfe156a261d7a53f4297e8b05cc91f", "patch": "@@ -1,5 +1,7 @@\n use rustc::mir::visit::{PlaceContext, Visitor};\n-use rustc::mir::{BasicBlock, Local, Location, Place, Statement, StatementKind, TerminatorKind};\n+use rustc::mir::{\n+    BasicBlock, Local, Location, Place, PlaceBase, Statement, StatementKind, TerminatorKind\n+};\n \n use rustc_data_structures::fx::FxHashSet;\n \n@@ -114,7 +116,7 @@ impl<'visit, 'cx, 'gcx, 'tcx> Visitor<'tcx> for GatherUsedMutsVisitor<'visit, 'c\n                     \"assignment of {:?} to {:?}, adding {:?} to used mutable set\",\n                     path.place, local, path.place\n                 );\n-                if let Place::Local(user_local) = path.place {\n+                if let Place::Base(PlaceBase::Local(user_local)) = path.place {\n                     self.mbcx.used_mut.insert(user_local);\n                 }\n             }"}, {"sha": "e354a2ee8160b47f1f17c40b8561df9eb14e82e4", "filename": "src/librustc_mir/build/expr/as_operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_operand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_operand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_operand.rs?ref=0f993d5a7abfe156a261d7a53f4297e8b05cc91f", "patch": "@@ -74,7 +74,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             }\n             Category::Place | Category::Rvalue(..) => {\n                 let operand = unpack!(block = this.as_temp(block, scope, expr, Mutability::Mut));\n-                block.and(Operand::Move(Place::Local(operand)))\n+                block.and(Operand::Move(Place::Base(PlaceBase::Local(operand))))\n             }\n         }\n     }"}, {"sha": "3bea88024b3f93e11f319f40e4dcfa18e543c558", "filename": "src/librustc_mir/build/expr/as_place.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_place.rs?ref=0f993d5a7abfe156a261d7a53f4297e8b05cc91f", "patch": "@@ -98,37 +98,37 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     &lt,\n                     Rvalue::BinaryOp(\n                         BinOp::Lt,\n-                        Operand::Copy(Place::Local(idx)),\n+                        Operand::Copy(Place::Base(PlaceBase::Local(idx))),\n                         Operand::Copy(len.clone()),\n                     ),\n                 );\n \n                 let msg = BoundsCheck {\n                     len: Operand::Move(len),\n-                    index: Operand::Copy(Place::Local(idx)),\n+                    index: Operand::Copy(Place::Base(PlaceBase::Local(idx))),\n                 };\n                 let success = this.assert(block, Operand::Move(lt), true, msg, expr_span);\n                 success.and(slice.index(idx))\n             }\n-            ExprKind::SelfRef => block.and(Place::Local(Local::new(1))),\n+            ExprKind::SelfRef => block.and(Place::Base(PlaceBase::Local(Local::new(1)))),\n             ExprKind::VarRef { id } => {\n                 let place = if this.is_bound_var_in_guard(id) && this\n                     .hir\n                     .tcx()\n                     .all_pat_vars_are_implicit_refs_within_guards()\n                 {\n                     let index = this.var_local_id(id, RefWithinGuard);\n-                    Place::Local(index).deref()\n+                    Place::Base(PlaceBase::Local(index)).deref()\n                 } else {\n                     let index = this.var_local_id(id, OutsideGuard);\n-                    Place::Local(index)\n+                    Place::Base(PlaceBase::Local(index))\n                 };\n                 block.and(place)\n             }\n-            ExprKind::StaticRef { id } => block.and(Place::Static(Box::new(Static {\n+            ExprKind::StaticRef { id } => block.and(Place::Base(PlaceBase::Static(Box::new(Static {\n                 def_id: id,\n                 ty: expr.ty,\n-            }))),\n+            })))),\n \n             ExprKind::PlaceTypeAscription { source, user_ty } => {\n                 let place = unpack!(block = this.as_place(block, source));\n@@ -172,14 +172,14 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                         Statement {\n                             source_info,\n                             kind: StatementKind::AscribeUserType(\n-                                Place::Local(temp.clone()),\n+                                Place::Base(PlaceBase::Local(temp.clone())),\n                                 Variance::Invariant,\n                                 box UserTypeProjection { base: annotation_index, projs: vec![], },\n                             ),\n                         },\n                     );\n                 }\n-                block.and(Place::Local(temp))\n+                block.and(Place::Base(PlaceBase::Local(temp)))\n             }\n \n             ExprKind::Array { .. }\n@@ -219,7 +219,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 });\n                 let temp =\n                     unpack!(block = this.as_temp(block, expr.temp_lifetime, expr, mutability));\n-                block.and(Place::Local(temp))\n+                block.and(Place::Base(PlaceBase::Local(temp)))\n             }\n         }\n     }"}, {"sha": "b00d1c612edf38c0bee77e94c7e79f6ef38a951a", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=0f993d5a7abfe156a261d7a53f4297e8b05cc91f", "patch": "@@ -127,19 +127,24 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     this.schedule_drop_storage_and_value(\n                         expr_span,\n                         scope,\n-                        &Place::Local(result),\n+                        &Place::Base(PlaceBase::Local(result)),\n                         value.ty,\n                     );\n                 }\n \n                 // malloc some memory of suitable type (thus far, uninitialized):\n                 let box_ = Rvalue::NullaryOp(NullOp::Box, value.ty);\n                 this.cfg\n-                    .push_assign(block, source_info, &Place::Local(result), box_);\n+                    .push_assign(block, source_info, &Place::Base(PlaceBase::Local(result)), box_);\n \n                 // initialize the box contents:\n-                unpack!(block = this.into(&Place::Local(result).deref(), block, value));\n-                block.and(Rvalue::Use(Operand::Move(Place::Local(result))))\n+                unpack!(\n+                    block = this.into(\n+                        &Place::Base(PlaceBase::Local(result)).deref(),\n+                        block, value\n+                    )\n+                );\n+                block.and(Rvalue::Use(Operand::Move(Place::Base(PlaceBase::Local(result)))))\n             }\n             ExprKind::Cast { source } => {\n                 let source = this.hir.mirror(source);\n@@ -522,9 +527,9 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         let arg_place = unpack!(block = this.as_place(block, arg));\n \n         let mutability = match arg_place {\n-            Place::Local(local) => this.local_decls[local].mutability,\n+            Place::Base(PlaceBase::Local(local)) => this.local_decls[local].mutability,\n             Place::Projection(box Projection {\n-                base: Place::Local(local),\n+                base: Place::Base(PlaceBase::Local(local)),\n                 elem: ProjectionElem::Deref,\n             }) => {\n                 debug_assert!(\n@@ -554,11 +559,11 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 // Not projected from the implicit `self` in a closure.\n                 debug_assert!(\n                     match *base {\n-                        Place::Local(local) => local == Local::new(1),\n+                        Place::Base(PlaceBase::Local(local)) => local == Local::new(1),\n                         Place::Projection(box Projection {\n                             ref base,\n                             elem: ProjectionElem::Deref,\n-                        }) => *base == Place::Local(Local::new(1)),\n+                        }) => *base == Place::Base(PlaceBase::Local(Local::new(1))),\n                         _ => false,\n                     },\n                     \"Unexpected capture place\"\n@@ -583,7 +588,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         this.cfg.push_assign(\n             block,\n             source_info,\n-            &Place::Local(temp),\n+            &Place::Base(PlaceBase::Local(temp)),\n             Rvalue::Ref(this.hir.tcx().types.re_erased, borrow_kind, arg_place),\n         );\n \n@@ -594,12 +599,12 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             this.schedule_drop_storage_and_value(\n                 upvar_span,\n                 temp_lifetime,\n-                &Place::Local(temp),\n+                &Place::Base(PlaceBase::Local(temp)),\n                 upvar_ty,\n             );\n         }\n \n-        block.and(Operand::Move(Place::Local(temp)))\n+        block.and(Operand::Move(Place::Base(PlaceBase::Local(temp))))\n     }\n \n     // Helper to get a `-1` value of the appropriate type"}, {"sha": "cba771f27065d93cd6649f94ee44bfccfd3a2a43", "filename": "src/librustc_mir/build/expr/as_temp.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_temp.rs?ref=0f993d5a7abfe156a261d7a53f4297e8b05cc91f", "patch": "@@ -73,7 +73,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             );\n         }\n \n-        unpack!(block = this.into(&Place::Local(temp), block, expr));\n+        unpack!(block = this.into(&Place::Base(PlaceBase::Local(temp)), block, expr));\n \n         // In constants, temp_lifetime is None for temporaries that live for the\n         // 'static lifetime. Thus we do not drop these temporaries and simply leak them.\n@@ -88,7 +88,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             this.schedule_drop_storage_and_value(\n                 expr_span,\n                 temp_lifetime,\n-                &Place::Local(temp),\n+                &Place::Base(PlaceBase::Local(temp)),\n                 expr_ty,\n             );\n         }"}, {"sha": "d9839e0c6ec5a88871f146d3999637869062067c", "filename": "src/librustc_mir/build/expr/into.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Finto.rs?ref=0f993d5a7abfe156a261d7a53f4297e8b05cc91f", "patch": "@@ -295,7 +295,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                         is_user_variable: None,\n                         is_block_tail: None,\n                     });\n-                    let ptr_temp = Place::Local(ptr_temp);\n+                    let ptr_temp = Place::Base(PlaceBase::Local(ptr_temp));\n                     let block = unpack!(this.into(&ptr_temp, block, ptr));\n                     this.into(&ptr_temp.deref(), block, val)\n                 } else {"}, {"sha": "9527a23279570a060ec8fe07c23998b993f9fb9f", "filename": "src/librustc_mir/build/expr/stmt.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fstmt.rs?ref=0f993d5a7abfe156a261d7a53f4297e8b05cc91f", "patch": "@@ -139,13 +139,22 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     Some(value) => {\n                         debug!(\"stmt_expr Return val block_context.push(SubExpr) : {:?}\", expr2);\n                         this.block_context.push(BlockFrame::SubExpr);\n-                        let result = unpack!(this.into(&Place::Local(RETURN_PLACE), block, value));\n+                        let result = unpack!(\n+                            this.into(\n+                                &Place::RETURN_PLACE,\n+                                block,\n+                                value\n+                            )\n+                        );\n                         this.block_context.pop();\n                         result\n                     }\n                     None => {\n-                        this.cfg\n-                            .push_assign_unit(block, source_info, &Place::Local(RETURN_PLACE));\n+                        this.cfg.push_assign_unit(\n+                            block,\n+                            source_info,\n+                            &Place::RETURN_PLACE,\n+                        );\n                         block\n                     }\n                 };\n@@ -226,7 +235,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                         }\n                     }\n                     let temp = this.local_decls.push(local_decl);\n-                    let place = Place::Local(temp);\n+                    let place = Place::Base(PlaceBase::Local(temp));\n                     debug!(\"created temp {:?} for expr {:?} in block_context: {:?}\",\n                            temp, expr, this.block_context);\n                     place"}, {"sha": "8f1301b743e9d52c1394f6e1c7916562ae214922", "filename": "src/librustc_mir/build/matches/mod.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmatches%2Fmod.rs?ref=0f993d5a7abfe156a261d7a53f4297e8b05cc91f", "patch": "@@ -543,7 +543,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 kind: StatementKind::StorageLive(local_id),\n             },\n         );\n-        let place = Place::Local(local_id);\n+        let place = Place::Base(PlaceBase::Local(local_id));\n         let var_ty = self.local_decls[local_id].ty;\n         let hir_id = self.hir.tcx().hir().node_to_hir_id(var);\n         let region_scope = self.hir.region_scope_tree.var_scope(hir_id.local_id);\n@@ -559,7 +559,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         self.schedule_drop(\n             span,\n             region_scope,\n-            &Place::Local(local_id),\n+            &Place::Base(PlaceBase::Local(local_id)),\n             var_ty,\n             DropKind::Value {\n                 cached_block: CachedBlock::default(),\n@@ -1452,7 +1452,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 self.cfg.push_assign(\n                     block,\n                     scrutinee_source_info,\n-                    &Place::Local(temp),\n+                    &Place::Base(PlaceBase::Local(temp)),\n                     borrow,\n                 );\n             }\n@@ -1478,7 +1478,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     source_info: guard_end,\n                     kind: StatementKind::FakeRead(\n                         FakeReadCause::ForMatchGuard,\n-                        Place::Local(temp),\n+                        Place::Base(PlaceBase::Local(temp)),\n                     ),\n                 });\n             }\n@@ -1529,7 +1529,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                 // place they refer to can't be modified by the guard.\n                 for binding in by_value_bindings.clone() {\n                     let local_id = self.var_local_id(binding.var_id, RefWithinGuard);\n-                    let place = Place::Local(local_id);\n+                    let place = Place::Base(PlaceBase::Local(local_id));\n                     self.cfg.push(\n                         block,\n                         Statement {"}, {"sha": "2692c24806ff7c861371e34b83c0f5691f98eba2", "filename": "src/librustc_mir/build/misc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs?ref=0f993d5a7abfe156a261d7a53f4297e8b05cc91f", "patch": "@@ -16,7 +16,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n     /// call `schedule_drop` once the temporary is initialized.\n     pub fn temp(&mut self, ty: Ty<'tcx>, span: Span) -> Place<'tcx> {\n         let temp = self.local_decls.push(LocalDecl::new_temp(ty, span));\n-        let place = Place::Local(temp);\n+        let place = Place::Base(PlaceBase::Local(temp));\n         debug!(\"temp: created temp {:?} with type {:?}\",\n                place, self.local_decls[temp].ty);\n         place"}, {"sha": "e4f85887841ebcc4f488ecb7f0860f028c326fb0", "filename": "src/librustc_mir/build/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmod.rs?ref=0f993d5a7abfe156a261d7a53f4297e8b05cc91f", "patch": "@@ -741,7 +741,7 @@ fn construct_const<'a, 'gcx, 'tcx>(\n \n     let mut block = START_BLOCK;\n     let expr = builder.hir.mirror(ast_expr);\n-    unpack!(block = builder.into_expr(&Place::Local(RETURN_PLACE), block, expr));\n+    unpack!(block = builder.into_expr(&Place::RETURN_PLACE, block, expr));\n \n     let source_info = builder.source_info(span);\n     builder.cfg.terminate(block, source_info, TerminatorKind::Return);\n@@ -887,7 +887,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         for (index, arg_info) in arguments.iter().enumerate() {\n             // Function arguments always get the first Local indices after the return place\n             let local = Local::new(index + 1);\n-            let place = Place::Local(local);\n+            let place = Place::Base(PlaceBase::Local(local));\n             let &ArgInfo(ty, opt_ty_info, pattern, ref self_binding) = arg_info;\n \n             // Make sure we drop (parts of) the argument even when not matched on.\n@@ -936,7 +936,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         }\n \n         let body = self.hir.mirror(ast_body);\n-        self.into(&Place::Local(RETURN_PLACE), block, body)\n+        self.into(&Place::RETURN_PLACE, block, body)\n     }\n \n     fn get_unit_temp(&mut self) -> Place<'tcx> {"}, {"sha": "4189e3e7ddbb6f92bca0a4eed7b2a7da65068396", "filename": "src/librustc_mir/build/scope.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Fbuild%2Fscope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fscope.rs?ref=0f993d5a7abfe156a261d7a53f4297e8b05cc91f", "patch": "@@ -662,7 +662,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n             DropKind::Value { .. } => if !needs_drop { return },\n             DropKind::Storage => {\n                 match *place {\n-                    Place::Local(index) => if index.index() <= self.arg_count {\n+                    Place::Base(PlaceBase::Local(index)) => if index.index() <= self.arg_count {\n                         span_bug!(\n                             span, \"`schedule_drop` called with index {} and arg_count {}\",\n                             index.index(),\n@@ -936,7 +936,7 @@ fn build_scope_drops<'tcx>(\n                 // Drop the storage for both value and storage drops.\n                 // Only temps and vars need their storage dead.\n                 match drop_data.location {\n-                    Place::Local(index) if index.index() > arg_count => {\n+                    Place::Base(PlaceBase::Local(index)) if index.index() > arg_count => {\n                         cfg.push(block, Statement {\n                             source_info,\n                             kind: StatementKind::StorageDead(index)"}, {"sha": "f78c82a93020ce3bb7bf891864c93e47b079f00c", "filename": "src/librustc_mir/dataflow/drop_flag_effects.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fdrop_flag_effects.rs?ref=0f993d5a7abfe156a261d7a53f4297e8b05cc91f", "patch": "@@ -163,7 +163,7 @@ pub(crate) fn drop_flag_effects_for_function_entry<'a, 'gcx, 'tcx, F>(\n {\n     let move_data = &ctxt.move_data;\n     for arg in mir.args_iter() {\n-        let place = mir::Place::Local(arg);\n+        let place = mir::Place::Base(mir::PlaceBase::Local(arg));\n         let lookup_result = move_data.rev_lookup.find(&place);\n         on_lookup_result_bits(tcx, mir, move_data,\n                               lookup_result,"}, {"sha": "b9c8879b3c36429c5317bbba2607b3b536acecf1", "filename": "src/librustc_mir/dataflow/impls/borrowed_locals.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrowed_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrowed_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrowed_locals.rs?ref=0f993d5a7abfe156a261d7a53f4297e8b05cc91f", "patch": "@@ -92,9 +92,9 @@ struct BorrowedLocalsVisitor<'b, 'c: 'b> {\n \n fn find_local<'tcx>(place: &Place<'tcx>) -> Option<Local> {\n     match *place {\n-        Place::Local(l) => Some(l),\n-        Place::Promoted(_) |\n-        Place::Static(..) => None,\n+        Place::Base(PlaceBase::Local(l)) => Some(l),\n+        Place::Base(PlaceBase::Promoted(_)) |\n+        Place::Base(PlaceBase::Static(..)) => None,\n         Place::Projection(ref proj) => {\n             match proj.elem {\n                 ProjectionElem::Deref => None,"}, {"sha": "b47aff3a4f8557ea19bd6174bcf53ff83193fcf0", "filename": "src/librustc_mir/dataflow/impls/borrows.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fborrows.rs?ref=0f993d5a7abfe156a261d7a53f4297e8b05cc91f", "patch": "@@ -1,7 +1,7 @@\n use crate::borrow_check::borrow_set::{BorrowSet, BorrowData};\n use crate::borrow_check::place_ext::PlaceExt;\n \n-use rustc::mir::{self, Location, Place, Mir};\n+use rustc::mir::{self, Location, Place, PlaceBase, Mir};\n use rustc::ty::TyCtxt;\n use rustc::ty::RegionVid;\n \n@@ -189,7 +189,7 @@ impl<'a, 'gcx, 'tcx> Borrows<'a, 'gcx, 'tcx> {\n     ) {\n         debug!(\"kill_borrows_on_place: place={:?}\", place);\n         // Handle the `Place::Local(..)` case first and exit early.\n-        if let Place::Local(local) = place {\n+        if let Place::Base(PlaceBase::Local(local)) = place {\n             if let Some(borrow_indices) = self.borrow_set.local_map.get(&local) {\n                 debug!(\"kill_borrows_on_place: borrow_indices={:?}\", borrow_indices);\n                 sets.kill_all(borrow_indices);\n@@ -285,7 +285,7 @@ impl<'a, 'gcx, 'tcx> BitDenotation<'tcx> for Borrows<'a, 'gcx, 'tcx> {\n             mir::StatementKind::StorageDead(local) => {\n                 // Make sure there are no remaining borrows for locals that\n                 // are gone out of scope.\n-                self.kill_borrows_on_place(sets, &Place::Local(local));\n+                self.kill_borrows_on_place(sets, &Place::Base(PlaceBase::Local(local)));\n             }\n \n             mir::StatementKind::InlineAsm { ref outputs, ref asm, .. } => {"}, {"sha": "4dcfb3f1a7fc32a9d01dda14d6bc64848ab451b3", "filename": "src/librustc_mir/dataflow/impls/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fimpls%2Fmod.rs?ref=0f993d5a7abfe156a261d7a53f4297e8b05cc91f", "patch": "@@ -493,7 +493,8 @@ impl<'a, 'gcx, 'tcx> BitDenotation<'tcx> for EverInitializedPlaces<'a, 'gcx, 'tc\n                 // storagedeads after everything ends, so if we don't regard the\n                 // storagelive as killing storage, we would have a multiple assignment\n                 // to immutable data error.\n-                if let LookupResult::Exact(mpi) = rev_lookup.find(&mir::Place::Local(local)) {\n+                if let LookupResult::Exact(mpi) =\n+                    rev_lookup.find(&mir::Place::Base(mir::PlaceBase::Local(local))) {\n                     debug!(\"stmt {:?} at loc {:?} clears the ever initialized status of {:?}\",\n                            stmt, location, &init_path_map[mpi]);\n                     sets.kill_all(&init_path_map[mpi]);"}, {"sha": "7a9140bce6288f3faef7fe6f1bcd2b5a3463da1f", "filename": "src/librustc_mir/dataflow/move_paths/builder.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fbuilder.rs?ref=0f993d5a7abfe156a261d7a53f4297e8b05cc91f", "patch": "@@ -33,13 +33,13 @@ impl<'a, 'gcx, 'tcx> MoveDataBuilder<'a, 'gcx, 'tcx> {\n                 moves: IndexVec::new(),\n                 loc_map: LocationMap::new(mir),\n                 rev_lookup: MovePathLookup {\n-                    locals: mir.local_decls.indices().map(Place::Local).map(|v| {\n+                    locals: mir.local_decls.indices().map(PlaceBase::Local).map(|v| {\n                         Self::new_move_path(\n                             &mut move_paths,\n                             &mut path_map,\n                             &mut init_path_map,\n                             None,\n-                            v,\n+                            Place::Base(v),\n                         )\n                     }).collect(),\n                     projections: Default::default(),\n@@ -96,9 +96,9 @@ impl<'b, 'a, 'gcx, 'tcx> Gatherer<'b, 'a, 'gcx, 'tcx> {\n     {\n         debug!(\"lookup({:?})\", place);\n         match *place {\n-            Place::Local(local) => Ok(self.builder.data.rev_lookup.locals[local]),\n-            Place::Promoted(..) |\n-            Place::Static(..) => {\n+            Place::Base(PlaceBase::Local(local)) => Ok(self.builder.data.rev_lookup.locals[local]),\n+            Place::Base(PlaceBase::Promoted(..)) |\n+            Place::Base(PlaceBase::Static(..)) => {\n                 Err(MoveError::cannot_move_out_of(self.loc, Static))\n             }\n             Place::Projection(ref proj) => {\n@@ -285,7 +285,7 @@ impl<'b, 'a, 'gcx, 'tcx> Gatherer<'b, 'a, 'gcx, 'tcx> {\n             }\n             StatementKind::StorageLive(_) => {}\n             StatementKind::StorageDead(local) => {\n-                self.gather_move(&Place::Local(local));\n+                self.gather_move(&Place::Base(PlaceBase::Local(local)));\n             }\n             StatementKind::SetDiscriminant{ .. } => {\n                 span_bug!(stmt.source_info.span,\n@@ -345,7 +345,7 @@ impl<'b, 'a, 'gcx, 'tcx> Gatherer<'b, 'a, 'gcx, 'tcx> {\n             TerminatorKind::Unreachable => { }\n \n             TerminatorKind::Return => {\n-                self.gather_move(&Place::Local(RETURN_PLACE));\n+                self.gather_move(&Place::RETURN_PLACE);\n             }\n \n             TerminatorKind::Assert { ref cond, .. } => {"}, {"sha": "0c29ea8ab4afac8c53dd1a89ac90bea0ee70e955", "filename": "src/librustc_mir/dataflow/move_paths/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fmove_paths%2Fmod.rs?ref=0f993d5a7abfe156a261d7a53f4297e8b05cc91f", "patch": "@@ -273,9 +273,9 @@ impl<'tcx> MovePathLookup<'tcx> {\n     // parent.\n     pub fn find(&self, place: &Place<'tcx>) -> LookupResult {\n         match *place {\n-            Place::Local(local) => LookupResult::Exact(self.locals[local]),\n-            Place::Promoted(_) |\n-            Place::Static(..) => LookupResult::Parent(None),\n+            Place::Base(PlaceBase::Local(local)) => LookupResult::Exact(self.locals[local]),\n+            Place::Base(PlaceBase::Promoted(_)) |\n+            Place::Base(PlaceBase::Static(..)) => LookupResult::Parent(None),\n             Place::Projection(ref proj) => {\n                 match self.find(&proj.base) {\n                     LookupResult::Exact(base_path) => {\n@@ -347,7 +347,7 @@ impl<'a, 'gcx, 'tcx> MoveData<'tcx> {\n     pub fn base_local(&self, mut mpi: MovePathIndex) -> Option<Local> {\n         loop {\n             let path = &self.move_paths[mpi];\n-            if let Place::Local(l) = path.place { return Some(l); }\n+            if let Place::Base(PlaceBase::Local(l)) = path.place { return Some(l); }\n             if let Some(parent) = path.parent { mpi = parent; continue } else { return None }\n         }\n     }"}, {"sha": "979595d6c00095b5b40631aad1c199bc02abac18", "filename": "src/librustc_mir/interpret/operand.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Finterpret%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Foperand.rs?ref=0f993d5a7abfe156a261d7a53f4297e8b05cc91f", "patch": "@@ -515,9 +515,10 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n         layout: Option<TyLayout<'tcx>>,\n     ) -> EvalResult<'tcx, OpTy<'tcx, M::PointerTag>> {\n         use rustc::mir::Place::*;\n+        use rustc::mir::PlaceBase;\n         let op = match *mir_place {\n-            Local(mir::RETURN_PLACE) => return err!(ReadFromReturnPointer),\n-            Local(local) => self.access_local(self.frame(), local, layout)?,\n+            Base(PlaceBase::Local(mir::RETURN_PLACE)) => return err!(ReadFromReturnPointer),\n+            Base(PlaceBase::Local(local)) => self.access_local(self.frame(), local, layout)?,\n \n             Projection(ref proj) => {\n                 let op = self.eval_place_to_op(&proj.base, None)?;"}, {"sha": "4df274bc9df97409db818583209e3706f7db4953", "filename": "src/librustc_mir/interpret/place.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fplace.rs?ref=0f993d5a7abfe156a261d7a53f4297e8b05cc91f", "patch": "@@ -581,16 +581,17 @@ where\n         mir_place: &mir::Place<'tcx>\n     ) -> EvalResult<'tcx, MPlaceTy<'tcx, M::PointerTag>> {\n         use rustc::mir::Place::*;\n+        use rustc::mir::PlaceBase;\n         Ok(match *mir_place {\n-            Promoted(ref promoted) => {\n+            Base(PlaceBase::Promoted(ref promoted)) => {\n                 let instance = self.frame().instance;\n                 self.const_eval_raw(GlobalId {\n                     instance,\n                     promoted: Some(promoted.0),\n                 })?\n             }\n \n-            Static(ref static_) => {\n+            Base(PlaceBase::Static(ref static_)) => {\n                 assert!(!static_.ty.needs_subst());\n                 let layout = self.layout_of(static_.ty)?;\n                 let instance = ty::Instance::mono(*self.tcx, static_.def_id);\n@@ -624,8 +625,9 @@ where\n         mir_place: &mir::Place<'tcx>\n     ) -> EvalResult<'tcx, PlaceTy<'tcx, M::PointerTag>> {\n         use rustc::mir::Place::*;\n+        use rustc::mir::PlaceBase;\n         let place = match *mir_place {\n-            Local(mir::RETURN_PLACE) => match self.frame().return_place {\n+            Base(PlaceBase::Local(mir::RETURN_PLACE)) => match self.frame().return_place {\n                 Some(return_place) =>\n                     // We use our layout to verify our assumption; caller will validate\n                     // their layout on return.\n@@ -635,7 +637,7 @@ where\n                     },\n                 None => return err!(InvalidNullPointerUsage),\n             },\n-            Local(local) => PlaceTy {\n+            Base(PlaceBase::Local(local)) => PlaceTy {\n                 place: Place::Local {\n                     frame: self.cur_frame(),\n                     local,"}, {"sha": "83469d749870fc669c45dd4f5e14ea4333065f3c", "filename": "src/librustc_mir/interpret/terminator.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Finterpret%2Fterminator.rs?ref=0f993d5a7abfe156a261d7a53f4297e8b05cc91f", "patch": "@@ -352,7 +352,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                     // not advance `caller_iter` for ZSTs.\n                     let mut locals_iter = mir.args_iter();\n                     while let Some(local) = locals_iter.next() {\n-                        let dest = self.eval_place(&mir::Place::Local(local))?;\n+                        let dest = self.eval_place(\n+                            &mir::Place::Base(mir::PlaceBase::Local(local))\n+                        )?;\n                         if Some(local) == mir.spread_arg {\n                             // Must be a tuple\n                             for i in 0..dest.layout.fields.count() {\n@@ -371,7 +373,9 @@ impl<'a, 'mir, 'tcx, M: Machine<'a, 'mir, 'tcx>> EvalContext<'a, 'mir, 'tcx, M>\n                     }\n                     // Don't forget to check the return type!\n                     if let Some(caller_ret) = dest {\n-                        let callee_ret = self.eval_place(&mir::Place::Local(mir::RETURN_PLACE))?;\n+                        let callee_ret = self.eval_place(\n+                            &mir::Place::RETURN_PLACE\n+                        )?;\n                         if !Self::check_argument_compat(\n                             rust_abi,\n                             caller_ret.layout,"}, {"sha": "adc328f1033ecaf0ed68217a56abf21318de0109", "filename": "src/librustc_mir/shim.rs", "status": "modified", "additions": 29, "deletions": 25, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Fshim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Fshim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fshim.rs?ref=0f993d5a7abfe156a261d7a53f4297e8b05cc91f", "patch": "@@ -221,7 +221,7 @@ fn build_drop_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     if let Some(..) = ty {\n         // The first argument (index 0), but add 1 for the return value.\n-        let dropee_ptr = Place::Local(Local::new(1+0));\n+        let dropee_ptr = Place::Base(PlaceBase::Local(Local::new(1+0)));\n         if tcx.sess.opts.debugging_opts.mir_emit_retag {\n             // Function arguments should be retagged, and we make this one raw.\n             mir.basic_blocks_mut()[START_BLOCK].statements.insert(0, Statement {\n@@ -317,8 +317,8 @@ fn build_clone_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let mut builder = CloneShimBuilder::new(tcx, def_id, self_ty);\n     let is_copy = self_ty.is_copy_modulo_regions(tcx, tcx.param_env(def_id), builder.span);\n \n-    let dest = Place::Local(RETURN_PLACE);\n-    let src = Place::Local(Local::new(1+0)).deref();\n+    let dest = Place::RETURN_PLACE;\n+    let src = Place::Base(PlaceBase::Local(Local::new(1+0))).deref();\n \n     match self_ty.sty {\n         _ if is_copy => builder.copy_shim(),\n@@ -424,10 +424,10 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n     }\n \n     fn copy_shim(&mut self) {\n-        let rcvr = Place::Local(Local::new(1+0)).deref();\n+        let rcvr = Place::Base(PlaceBase::Local(Local::new(1+0))).deref();\n         let ret_statement = self.make_statement(\n             StatementKind::Assign(\n-                Place::Local(RETURN_PLACE),\n+                Place::RETURN_PLACE,\n                 box Rvalue::Use(Operand::Copy(rcvr))\n             )\n         );\n@@ -436,9 +436,9 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n \n     fn make_place(&mut self, mutability: Mutability, ty: Ty<'tcx>) -> Place<'tcx> {\n         let span = self.span;\n-        Place::Local(\n+        Place::Base(PlaceBase::Local(\n             self.local_decls.push(temp_decl(mutability, ty, span))\n-        )\n+        ))\n     }\n \n     fn make_clone_call(\n@@ -546,7 +546,7 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n         let inits = vec![\n             self.make_statement(\n                 StatementKind::Assign(\n-                    Place::Local(beg),\n+                    Place::Base(PlaceBase::Local(beg)),\n                     box Rvalue::Use(Operand::Constant(self.make_usize(0)))\n                 )\n             ),\n@@ -564,7 +564,11 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n         //     BB #3;\n         // }\n         // BB #4;\n-        self.loop_header(Place::Local(beg), end, BasicBlock::new(2), BasicBlock::new(4), false);\n+        self.loop_header(Place::Base(PlaceBase::Local(beg)),\n+                         end,\n+                         BasicBlock::new(2),\n+                         BasicBlock::new(4),\n+                         false);\n \n         // BB #2\n         // `dest[i] = Clone::clone(src[beg])`;\n@@ -580,10 +584,10 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n         let statements = vec![\n             self.make_statement(\n                 StatementKind::Assign(\n-                    Place::Local(beg),\n+                    Place::Base(PlaceBase::Local(beg)),\n                     box Rvalue::BinaryOp(\n                         BinOp::Add,\n-                        Operand::Copy(Place::Local(beg)),\n+                        Operand::Copy(Place::Base(PlaceBase::Local(beg))),\n                         Operand::Constant(self.make_usize(1))\n                     )\n                 )\n@@ -603,7 +607,7 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n         let beg = self.local_decls.push(temp_decl(Mutability::Mut, tcx.types.usize, span));\n         let init = self.make_statement(\n             StatementKind::Assign(\n-                Place::Local(beg),\n+                Place::Base(PlaceBase::Local(beg)),\n                 box Rvalue::Use(Operand::Constant(self.make_usize(0)))\n             )\n         );\n@@ -614,7 +618,7 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n         //     BB #8;\n         // }\n         // BB #9;\n-        self.loop_header(Place::Local(beg), Place::Local(end),\n+        self.loop_header(Place::Base(PlaceBase::Local(beg)), Place::Base(PlaceBase::Local(end)),\n                          BasicBlock::new(7), BasicBlock::new(9), true);\n \n         // BB #7 (cleanup)\n@@ -630,10 +634,10 @@ impl<'a, 'tcx> CloneShimBuilder<'a, 'tcx> {\n         // `goto #6;`\n         let statement = self.make_statement(\n             StatementKind::Assign(\n-                Place::Local(beg),\n+                Place::Base(PlaceBase::Local(beg)),\n                 box Rvalue::BinaryOp(\n                     BinOp::Add,\n-                    Operand::Copy(Place::Local(beg)),\n+                    Operand::Copy(Place::Base(PlaceBase::Local(beg))),\n                     Operand::Constant(self.make_usize(1))\n                 )\n             )\n@@ -718,7 +722,7 @@ fn build_call_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     let source_info = SourceInfo { span, scope: OUTERMOST_SOURCE_SCOPE };\n \n     let rcvr_arg = Local::new(1+0);\n-    let rcvr_l = Place::Local(rcvr_arg);\n+    let rcvr_l = Place::Base(PlaceBase::Local(rcvr_arg));\n     let mut statements = vec![];\n \n     let rcvr = match rcvr_adjustment {\n@@ -748,11 +752,11 @@ fn build_call_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             statements.push(Statement {\n                 source_info,\n                 kind: StatementKind::Assign(\n-                    Place::Local(ref_rcvr),\n+                    Place::Base(PlaceBase::Local(ref_rcvr)),\n                     box Rvalue::Ref(tcx.types.re_erased, borrow_kind, rcvr_l)\n                 )\n             });\n-            Operand::Move(Place::Local(ref_rcvr))\n+            Operand::Move(Place::Base(PlaceBase::Local(ref_rcvr)))\n         }\n     };\n \n@@ -774,12 +778,12 @@ fn build_call_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n \n     if let Some(untuple_args) = untuple_args {\n         args.extend(untuple_args.iter().enumerate().map(|(i, ity)| {\n-            let arg_place = Place::Local(Local::new(1+1));\n+            let arg_place = Place::Base(PlaceBase::Local(Local::new(1+1)));\n             Operand::Move(arg_place.field(Field::new(i), *ity))\n         }));\n     } else {\n         args.extend((1..sig.inputs().len()).map(|i| {\n-            Operand::Move(Place::Local(Local::new(1+i)))\n+            Operand::Move(Place::Base(PlaceBase::Local(Local::new(1+i))))\n         }));\n     }\n \n@@ -797,7 +801,7 @@ fn build_call_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     block(&mut blocks, statements, TerminatorKind::Call {\n         func: callee,\n         args,\n-        destination: Some((Place::Local(RETURN_PLACE),\n+        destination: Some((Place::RETURN_PLACE,\n                            BasicBlock::new(1))),\n         cleanup: if let Adjustment::RefMut = rcvr_adjustment {\n             Some(BasicBlock::new(3))\n@@ -810,7 +814,7 @@ fn build_call_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     if let Adjustment::RefMut = rcvr_adjustment {\n         // BB #1 - drop for Self\n         block(&mut blocks, vec![], TerminatorKind::Drop {\n-            location: Place::Local(rcvr_arg),\n+            location: Place::Base(PlaceBase::Local(rcvr_arg)),\n             target: BasicBlock::new(2),\n             unwind: None\n         }, false);\n@@ -820,7 +824,7 @@ fn build_call_shim<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     if let Adjustment::RefMut = rcvr_adjustment {\n         // BB #3 - drop if closure panics\n         block(&mut blocks, vec![], TerminatorKind::Drop {\n-            location: Place::Local(rcvr_arg),\n+            location: Place::Base(PlaceBase::Local(rcvr_arg)),\n             target: BasicBlock::new(4),\n             unwind: None\n         }, true);\n@@ -892,11 +896,11 @@ pub fn build_adt_ctor<'a, 'gcx, 'tcx>(infcx: &infer::InferCtxt<'a, 'gcx, 'tcx>,\n         statements: vec![Statement {\n             source_info,\n             kind: StatementKind::Assign(\n-                Place::Local(RETURN_PLACE),\n+                Place::RETURN_PLACE,\n                 box Rvalue::Aggregate(\n                     box AggregateKind::Adt(adt_def, variant_no, substs, None, None),\n                     (1..sig.inputs().len()+1).map(|i| {\n-                        Operand::Move(Place::Local(Local::new(i)))\n+                        Operand::Move(Place::Base(PlaceBase::Local(Local::new(i))))\n                     }).collect()\n                 )\n             )"}, {"sha": "e8528eee0bcab28d3d63f0217475a39ba2938bfc", "filename": "src/librustc_mir/transform/add_moves_for_packed_drops.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Ftransform%2Fadd_moves_for_packed_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Ftransform%2Fadd_moves_for_packed_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_moves_for_packed_drops.rs?ref=0f993d5a7abfe156a261d7a53f4297e8b05cc91f", "patch": "@@ -121,10 +121,10 @@ fn add_move_for_packed_drop<'a, 'tcx>(\n \n     patch.add_statement(\n         loc, StatementKind::StorageLive(temp));\n-    patch.add_assign(loc, Place::Local(temp),\n+    patch.add_assign(loc, Place::Base(PlaceBase::Local(temp)),\n                      Rvalue::Use(Operand::Move(location.clone())));\n     patch.patch_terminator(loc.block, TerminatorKind::Drop {\n-        location: Place::Local(temp),\n+        location: Place::Base(PlaceBase::Local(temp)),\n         target: storage_dead_block,\n         unwind\n     });"}, {"sha": "20b75c5586794e94f67afeee8af46f0c247cb252", "filename": "src/librustc_mir/transform/add_retag.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fadd_retag.rs?ref=0f993d5a7abfe156a261d7a53f4297e8b05cc91f", "patch": "@@ -21,9 +21,9 @@ fn is_stable<'tcx>(\n \n     match *place {\n         // Locals and statics have stable addresses, for sure\n-        Local { .. } |\n-        Promoted { .. } |\n-        Static { .. } =>\n+        Base(PlaceBase::Local { .. }) |\n+        Base(PlaceBase::Promoted { .. }) |\n+        Base(PlaceBase::Static { .. }) =>\n             true,\n         // Recurse for projections\n         Projection(ref proj) => {\n@@ -101,7 +101,7 @@ impl MirPass for AddRetag {\n             };\n             // Gather all arguments, skip return value.\n             let places = local_decls.iter_enumerated().skip(1).take(arg_count)\n-                    .map(|(local, _)| Place::Local(local))\n+                    .map(|(local, _)| Place::Base(PlaceBase::Local(local)))\n                     .filter(needs_retag)\n                     .collect::<Vec<_>>();\n             // Emit their retags."}, {"sha": "ceef15091b5f0396f047f58d4ab1d85248a7e6c4", "filename": "src/librustc_mir/transform/check_unsafety.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcheck_unsafety.rs?ref=0f993d5a7abfe156a261d7a53f4297e8b05cc91f", "patch": "@@ -241,7 +241,7 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                     );\n                 }\n                 let old_source_info = self.source_info;\n-                if let &Place::Local(local) = base {\n+                if let &Place::Base(PlaceBase::Local(local)) = base {\n                     if self.mir.local_decls[local].internal {\n                         // Internal locals are used in the `move_val_init` desugaring.\n                         // We want to check unsafety against the source info of the\n@@ -297,13 +297,13 @@ impl<'a, 'tcx> Visitor<'tcx> for UnsafetyChecker<'a, 'tcx> {\n                 }\n                 self.source_info = old_source_info;\n             }\n-            &Place::Local(..) => {\n+            &Place::Base(PlaceBase::Local(..)) => {\n                 // locals are safe\n             }\n-            &Place::Promoted(_) => {\n+            &Place::Base(PlaceBase::Promoted(_)) => {\n                 bug!(\"unsafety checking should happen before promotion\")\n             }\n-            &Place::Static(box Static { def_id, ty: _ }) => {\n+            &Place::Base(PlaceBase::Static(box Static { def_id, ty: _ })) => {\n                 if self.tcx.is_static(def_id) == Some(hir::Mutability::MutMutable) {\n                     self.require_unsafe(\"use of mutable static\",\n                         \"mutable statics can be mutated by multiple threads: aliasing violations \\"}, {"sha": "25dee3ec95566a0d435e6b746069923e3fe1d798", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=0f993d5a7abfe156a261d7a53f4297e8b05cc91f", "patch": "@@ -3,7 +3,7 @@\n \n \n use rustc::hir::def::Def;\n-use rustc::mir::{Constant, Location, Place, Mir, Operand, Rvalue, Local};\n+use rustc::mir::{Constant, Location, Place, PlaceBase, Mir, Operand, Rvalue, Local};\n use rustc::mir::{NullOp, UnOp, StatementKind, Statement, BasicBlock, LocalKind};\n use rustc::mir::{TerminatorKind, ClearCrossCrate, SourceInfo, BinOp, ProjectionElem};\n use rustc::mir::visit::{Visitor, PlaceContext, MutatingUseContext, NonMutatingUseContext};\n@@ -267,7 +267,7 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n \n     fn eval_place(&mut self, place: &Place<'tcx>, source_info: SourceInfo) -> Option<Const<'tcx>> {\n         match *place {\n-            Place::Local(loc) => self.places[loc].clone(),\n+            Place::Base(PlaceBase::Local(loc)) => self.places[loc].clone(),\n             Place::Projection(ref proj) => match proj.elem {\n                 ProjectionElem::Field(field, _) => {\n                     trace!(\"field proj on {:?}\", proj.base);\n@@ -282,7 +282,7 @@ impl<'a, 'mir, 'tcx> ConstPropagator<'a, 'mir, 'tcx> {\n                 // an `Index` projection would throw us off-track.\n                 _ => None,\n             },\n-            Place::Promoted(ref promoted) => {\n+            Place::Base(PlaceBase::Promoted(ref promoted)) => {\n                 let generics = self.tcx.generics_of(self.source.def_id());\n                 if generics.requires_monomorphization(self.tcx) {\n                     // FIXME: can't handle code with generics\n@@ -556,7 +556,7 @@ impl<'b, 'a, 'tcx> Visitor<'tcx> for ConstPropagator<'b, 'a, 'tcx> {\n                 .to_ty(self.tcx);\n             if let Ok(place_layout) = self.tcx.layout_of(self.param_env.and(place_ty)) {\n                 if let Some(value) = self.const_prop(rval, place_layout, statement.source_info) {\n-                    if let Place::Local(local) = *place {\n+                    if let Place::Base(PlaceBase::Local(local)) = *place {\n                         trace!(\"checking whether {:?} can be stored to {:?}\", value, local);\n                         if self.can_const_prop[local] {\n                             trace!(\"storing {:?} to {:?}\", value, local);\n@@ -591,7 +591,7 @@ impl<'b, 'a, 'tcx> Visitor<'tcx> for ConstPropagator<'b, 'a, 'tcx> {\n                             while let Place::Projection(ref proj) = *place {\n                                 place = &proj.base;\n                             }\n-                            if let Place::Local(local) = *place {\n+                            if let Place::Base(PlaceBase::Local(local)) = *place {\n                                 self.places[local] = None;\n                             }\n                         },"}, {"sha": "817a2f31c07361859eb358db6e87506901b4813e", "filename": "src/librustc_mir/transform/copy_prop.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fcopy_prop.rs?ref=0f993d5a7abfe156a261d7a53f4297e8b05cc91f", "patch": "@@ -19,7 +19,9 @@\n //! (non-mutating) use of `SRC`. These restrictions are conservative and may be relaxed in the\n //! future.\n \n-use rustc::mir::{Constant, Local, LocalKind, Location, Place, Mir, Operand, Rvalue, StatementKind};\n+use rustc::mir::{\n+    Constant, Local, LocalKind, Location, Place, PlaceBase, Mir, Operand, Rvalue, StatementKind\n+};\n use rustc::mir::visit::MutVisitor;\n use rustc::ty::TyCtxt;\n use crate::transform::{MirPass, MirSource};\n@@ -94,8 +96,10 @@ impl MirPass for CopyPropagation {\n \n                     // That use of the source must be an assignment.\n                     match statement.kind {\n-                        StatementKind::Assign(Place::Local(local), box Rvalue::Use(ref operand)) if\n-                                local == dest_local => {\n+                        StatementKind::Assign(\n+                            Place::Base(PlaceBase::Local(local)),\n+                            box Rvalue::Use(ref operand)\n+                        ) if local == dest_local => {\n                             let maybe_action = match *operand {\n                                 Operand::Copy(ref src_place) |\n                                 Operand::Move(ref src_place) => {\n@@ -144,12 +148,12 @@ fn eliminate_self_assignments<'tcx>(\n             if let Some(stmt) = mir[location.block].statements.get(location.statement_index) {\n                 match stmt.kind {\n                     StatementKind::Assign(\n-                        Place::Local(local),\n-                        box Rvalue::Use(Operand::Copy(Place::Local(src_local))),\n+                        Place::Base(PlaceBase::Local(local)),\n+                        box Rvalue::Use(Operand::Copy(Place::Base(PlaceBase::Local(src_local)))),\n                     ) |\n                     StatementKind::Assign(\n-                        Place::Local(local),\n-                        box Rvalue::Use(Operand::Move(Place::Local(src_local))),\n+                        Place::Base(PlaceBase::Local(local)),\n+                        box Rvalue::Use(Operand::Move(Place::Base(PlaceBase::Local(src_local)))),\n                     ) if local == dest_local && dest_local == src_local => {}\n                     _ => {\n                         continue;\n@@ -176,7 +180,7 @@ impl<'tcx> Action<'tcx> {\n     fn local_copy(mir: &Mir<'tcx>, def_use_analysis: &DefUseAnalysis<'_>, src_place: &Place<'tcx>)\n                   -> Option<Action<'tcx>> {\n         // The source must be a local.\n-        let src_local = if let Place::Local(local) = *src_place {\n+        let src_local = if let Place::Base(PlaceBase::Local(local)) = *src_place {\n             local\n         } else {\n             debug!(\"  Can't copy-propagate local: source is not a local\");\n@@ -330,8 +334,8 @@ impl<'tcx> MutVisitor<'tcx> for ConstantPropagationVisitor<'tcx> {\n         self.super_operand(operand, location);\n \n         match *operand {\n-            Operand::Copy(Place::Local(local)) |\n-            Operand::Move(Place::Local(local)) if local == self.dest_local => {}\n+            Operand::Copy(Place::Base(PlaceBase::Local(local))) |\n+            Operand::Move(Place::Base(PlaceBase::Local(local))) if local == self.dest_local => {}\n             _ => return,\n         }\n "}, {"sha": "74175d0149ff481bab145930472726873c61d4dd", "filename": "src/librustc_mir/transform/elaborate_drops.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Felaborate_drops.rs?ref=0f993d5a7abfe156a261d7a53f4297e8b05cc91f", "patch": "@@ -330,7 +330,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n     }\n \n     fn drop_flag(&mut self, index: MovePathIndex) -> Option<Place<'tcx>> {\n-        self.drop_flags.get(&index).map(|t| Place::Local(*t))\n+        self.drop_flags.get(&index).map(|t| Place::Base(PlaceBase::Local(*t)))\n     }\n \n     /// create a patch that elaborates all drops in the input\n@@ -543,7 +543,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n         if let Some(&flag) = self.drop_flags.get(&path) {\n             let span = self.patch.source_info_for_location(self.mir, loc).span;\n             let val = self.constant_bool(span, val.value());\n-            self.patch.add_assign(loc, Place::Local(flag), val);\n+            self.patch.add_assign(loc, Place::Base(PlaceBase::Local(flag)), val);\n         }\n     }\n \n@@ -552,7 +552,7 @@ impl<'b, 'tcx> ElaborateDropsCtxt<'b, 'tcx> {\n         let span = self.patch.source_info_for_location(self.mir, loc).span;\n         let false_ = self.constant_bool(span, false);\n         for flag in self.drop_flags.values() {\n-            self.patch.add_assign(loc, Place::Local(*flag), false_.clone());\n+            self.patch.add_assign(loc, Place::Base(PlaceBase::Local(*flag)), false_.clone());\n         }\n     }\n "}, {"sha": "c455d38cebce85fff4b824b8325372e6ddc585d6", "filename": "src/librustc_mir/transform/generator.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fgenerator.rs?ref=0f993d5a7abfe156a261d7a53f4297e8b05cc91f", "patch": "@@ -102,7 +102,7 @@ impl<'tcx> MutVisitor<'tcx> for DerefArgVisitor {\n                     place: &mut Place<'tcx>,\n                     context: PlaceContext<'tcx>,\n                     location: Location) {\n-        if *place == Place::Local(self_arg()) {\n+        if *place == Place::Base(PlaceBase::Local(self_arg())) {\n             *place = Place::Projection(Box::new(Projection {\n                 base: place.clone(),\n                 elem: ProjectionElem::Deref,\n@@ -129,7 +129,7 @@ impl<'tcx> MutVisitor<'tcx> for PinArgVisitor<'tcx> {\n                     place: &mut Place<'tcx>,\n                     context: PlaceContext<'tcx>,\n                     location: Location) {\n-        if *place == Place::Local(self_arg()) {\n+        if *place == Place::Base(PlaceBase::Local(self_arg())) {\n             *place = Place::Projection(Box::new(Projection {\n                 base: place.clone(),\n                 elem: ProjectionElem::Field(Field::new(0), self.ref_gen_ty),\n@@ -183,7 +183,7 @@ impl<'a, 'tcx> TransformVisitor<'a, 'tcx> {\n \n     // Create a Place referencing a generator struct field\n     fn make_field(&self, idx: usize, ty: Ty<'tcx>) -> Place<'tcx> {\n-        let base = Place::Local(self_arg());\n+        let base = Place::Base(PlaceBase::Local(self_arg()));\n         let field = Projection {\n             base: base,\n             elem: ProjectionElem::Field(Field::new(idx), ty),\n@@ -223,7 +223,7 @@ impl<'a, 'tcx> MutVisitor<'tcx> for TransformVisitor<'a, 'tcx> {\n                     place: &mut Place<'tcx>,\n                     context: PlaceContext<'tcx>,\n                     location: Location) {\n-        if let Place::Local(l) = *place {\n+        if let Place::Base(PlaceBase::Local(l)) = *place {\n             // Replace an Local in the remap with a generator struct access\n             if let Some(&(ty, idx)) = self.remap.get(&l) {\n                 *place = self.make_field(idx, ty);\n@@ -249,7 +249,7 @@ impl<'a, 'tcx> MutVisitor<'tcx> for TransformVisitor<'a, 'tcx> {\n         let ret_val = match data.terminator().kind {\n             TerminatorKind::Return => Some((VariantIdx::new(1),\n                 None,\n-                Operand::Move(Place::Local(self.new_ret_local)),\n+                Operand::Move(Place::Base(PlaceBase::Local(self.new_ret_local))),\n                 None)),\n             TerminatorKind::Yield { ref value, resume, drop } => Some((VariantIdx::new(0),\n                 Some(resume),\n@@ -263,7 +263,7 @@ impl<'a, 'tcx> MutVisitor<'tcx> for TransformVisitor<'a, 'tcx> {\n             // We must assign the value first in case it gets declared dead below\n             data.statements.push(Statement {\n                 source_info,\n-                kind: StatementKind::Assign(Place::Local(RETURN_PLACE),\n+                kind: StatementKind::Assign(Place::RETURN_PLACE,\n                                             box self.make_state(state_idx, v)),\n             });\n             let state = if let Some(resume) = resume { // Yield\n@@ -597,7 +597,7 @@ fn elaborate_generator_drops<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             &Terminator {\n                 source_info,\n                 kind: TerminatorKind::Drop {\n-                    location: Place::Local(local),\n+                    location: Place::Base(PlaceBase::Local(local)),\n                     target,\n                     unwind\n                 }\n@@ -619,7 +619,7 @@ fn elaborate_generator_drops<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n             elaborate_drop(\n                 &mut elaborator,\n                 source_info,\n-                &Place::Local(gen),\n+                &Place::Base(PlaceBase::Local(gen)),\n                 (),\n                 target,\n                 unwind,\n@@ -693,7 +693,7 @@ fn create_generator_drop_shim<'a, 'tcx>(\n         // Alias tracking must know we changed the type\n         mir.basic_blocks_mut()[START_BLOCK].statements.insert(0, Statement {\n             source_info,\n-            kind: StatementKind::Retag(RetagKind::Raw, Place::Local(self_arg())),\n+            kind: StatementKind::Retag(RetagKind::Raw, Place::Base(PlaceBase::Local(self_arg()))),\n         })\n     }\n \n@@ -809,7 +809,7 @@ fn insert_clean_drop<'a, 'tcx>(mir: &mut Mir<'tcx>) -> BasicBlock {\n     // Create a block to destroy an unresumed generators. This can only destroy upvars.\n     let drop_clean = BasicBlock::new(mir.basic_blocks().len());\n     let term = TerminatorKind::Drop {\n-        location: Place::Local(self_arg()),\n+        location: Place::Base(PlaceBase::Local(self_arg())),\n         target: return_block,\n         unwind: None,\n     };"}, {"sha": "4cdef015b53ff0697aee3e7bd0ca74045e950d02", "filename": "src/librustc_mir/transform/inline.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Ftransform%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finline.rs?ref=0f993d5a7abfe156a261d7a53f4297e8b05cc91f", "patch": "@@ -449,7 +449,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n                         }\n                         // Static variables need a borrow because the callee\n                         // might modify the same static.\n-                        Place::Static(_) => true,\n+                        Place::Base(PlaceBase::Static(_)) => true,\n                         _ => false\n                     }\n                 }\n@@ -466,7 +466,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n                     let temp = LocalDecl::new_temp(ty, callsite.location.span);\n \n                     let tmp = caller_mir.local_decls.push(temp);\n-                    let tmp = Place::Local(tmp);\n+                    let tmp = Place::Base(PlaceBase::Local(tmp));\n \n                     let stmt = Statement {\n                         source_info: callsite.location,\n@@ -560,7 +560,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n             let tuple = self.create_temp_if_necessary(args.next().unwrap(), callsite, caller_mir);\n             assert!(args.next().is_none());\n \n-            let tuple = Place::Local(tuple);\n+            let tuple = Place::Base(PlaceBase::Local(tuple));\n             let tuple_tys = if let ty::Tuple(s) = tuple.ty(caller_mir, tcx).to_ty(tcx).sty {\n                 s\n             } else {\n@@ -599,7 +599,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n         // FIXME: Analysis of the usage of the arguments to avoid\n         // unnecessary temporaries.\n \n-        if let Operand::Move(Place::Local(local)) = arg {\n+        if let Operand::Move(Place::Base(PlaceBase::Local(local))) = arg {\n             if caller_mir.local_kind(local) == LocalKind::Temp {\n                 // Reuse the operand if it's a temporary already\n                 return local;\n@@ -617,7 +617,7 @@ impl<'a, 'tcx> Inliner<'a, 'tcx> {\n \n         let stmt = Statement {\n             source_info: callsite.location,\n-            kind: StatementKind::Assign(Place::Local(arg_tmp), box arg),\n+            kind: StatementKind::Assign(Place::Base(PlaceBase::Local(arg_tmp)), box arg),\n         };\n         caller_mir[callsite.bb].statements.push(stmt);\n         arg_tmp\n@@ -665,7 +665,7 @@ impl<'a, 'tcx> MutVisitor<'tcx> for Integrator<'a, 'tcx> {\n                    _location: Location) {\n         if *local == RETURN_PLACE {\n             match self.destination {\n-                Place::Local(l) => {\n+                Place::Base(PlaceBase::Local(l)) => {\n                     *local = l;\n                     return;\n                 },\n@@ -686,11 +686,11 @@ impl<'a, 'tcx> MutVisitor<'tcx> for Integrator<'a, 'tcx> {\n                     _location: Location) {\n \n         match place {\n-            Place::Local(RETURN_PLACE) => {\n+            Place::Base(PlaceBase::Local(RETURN_PLACE)) => {\n                 // Return pointer; update the place itself\n                 *place = self.destination.clone();\n             },\n-            Place::Promoted(ref mut promoted) => {\n+            Place::Base(PlaceBase::Promoted(ref mut promoted)) => {\n                 if let Some(p) = self.promoted_map.get(promoted.0).cloned() {\n                     promoted.0 = p;\n                 }"}, {"sha": "e0e64fd1f9b5422b26201bb44bfbb70b7f541b32", "filename": "src/librustc_mir/transform/instcombine.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Finstcombine.rs?ref=0f993d5a7abfe156a261d7a53f4297e8b05cc91f", "patch": "@@ -1,6 +1,6 @@\n //! Performs various peephole optimizations.\n \n-use rustc::mir::{Constant, Location, Place, Mir, Operand, ProjectionElem, Rvalue, Local};\n+use rustc::mir::{Constant, Location, Place, PlaceBase, Mir, Operand, ProjectionElem, Rvalue, Local};\n use rustc::mir::visit::{MutVisitor, Visitor};\n use rustc::ty::{TyCtxt, TyKind};\n use rustc::util::nodemap::{FxHashMap, FxHashSet};\n@@ -45,7 +45,7 @@ impl<'tcx> MutVisitor<'tcx> for InstCombineVisitor<'tcx> {\n             let new_place = match *rvalue {\n                 Rvalue::Ref(_, _, Place::Projection(ref mut projection)) => {\n                     // Replace with dummy\n-                    mem::replace(&mut projection.base, Place::Local(Local::new(0)))\n+                    mem::replace(&mut projection.base, Place::Base(PlaceBase::Local(Local::new(0))))\n                 }\n                 _ => bug!(\"Detected `&*` but didn't find `&*`!\"),\n             };"}, {"sha": "ad108587247fb678989cbf983decba1d1d7afbf7", "filename": "src/librustc_mir/transform/lower_128bit.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Ftransform%2Flower_128bit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Ftransform%2Flower_128bit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Flower_128bit.rs?ref=0f993d5a7abfe156a261d7a53f4297e8b05cc91f", "patch": "@@ -86,13 +86,13 @@ impl Lower128Bit {\n                     block.statements.push(Statement {\n                         source_info: source_info,\n                         kind: StatementKind::Assign(\n-                            Place::Local(local),\n+                            Place::Base(PlaceBase::Local(local)),\n                             box Rvalue::Cast(\n                                 CastKind::Misc,\n                                 rhs,\n                                 rhs_override_ty.unwrap())),\n                     });\n-                    rhs = Operand::Move(Place::Local(local));\n+                    rhs = Operand::Move(Place::Base(PlaceBase::Local(local)));\n                 }\n \n                 let call_did = check_lang_item_type("}, {"sha": "831d8b46a65c3a8ad2681abb9be92fc4cab5cda2", "filename": "src/librustc_mir/transform/promote_consts.rs", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fpromote_consts.rs?ref=0f993d5a7abfe156a261d7a53f4297e8b05cc91f", "patch": "@@ -178,7 +178,7 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n                 span,\n                 scope: OUTERMOST_SOURCE_SCOPE\n             },\n-            kind: StatementKind::Assign(Place::Local(dest), box rvalue)\n+            kind: StatementKind::Assign(Place::Base(PlaceBase::Local(dest)), box rvalue)\n         });\n     }\n \n@@ -268,7 +268,9 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n                             func,\n                             args,\n                             cleanup: None,\n-                            destination: Some((Place::Local(new_temp), new_target)),\n+                            destination: Some(\n+                                (Place::Base(PlaceBase::Local(new_temp)), new_target)\n+                            ),\n                             from_hir_call,\n                         },\n                         ..terminator\n@@ -292,7 +294,7 @@ impl<'a, 'tcx> Promoter<'a, 'tcx> {\n                 promoted.span = span;\n                 promoted.local_decls[RETURN_PLACE] =\n                     LocalDecl::new_return_place(ty, span);\n-                Place::Promoted(box (promoted_id, ty))\n+                Place::Base(PlaceBase::Promoted(box (promoted_id, ty)))\n             };\n             let (blocks, local_decls) = self.source.basic_blocks_and_local_decls_mut();\n             match candidate {\n@@ -373,7 +375,7 @@ pub fn promote_candidates<'a, 'tcx>(mir: &mut Mir<'tcx>,\n         match candidate {\n             Candidate::Ref(Location { block, statement_index }) => {\n                 match mir[block].statements[statement_index].kind {\n-                    StatementKind::Assign(Place::Local(local), _) => {\n+                    StatementKind::Assign(Place::Base(PlaceBase::Local(local)), _) => {\n                         if temps[local] == TempState::PromotedOut {\n                             // Already promoted.\n                             continue;\n@@ -420,7 +422,7 @@ pub fn promote_candidates<'a, 'tcx>(mir: &mut Mir<'tcx>,\n     for block in mir.basic_blocks_mut() {\n         block.statements.retain(|statement| {\n             match statement.kind {\n-                StatementKind::Assign(Place::Local(index), _) |\n+                StatementKind::Assign(Place::Base(PlaceBase::Local(index)), _) |\n                 StatementKind::StorageLive(index) |\n                 StatementKind::StorageDead(index) => {\n                     !promoted(index)\n@@ -430,7 +432,7 @@ pub fn promote_candidates<'a, 'tcx>(mir: &mut Mir<'tcx>,\n         });\n         let terminator = block.terminator_mut();\n         match terminator.kind {\n-            TerminatorKind::Drop { location: Place::Local(index), target, .. } => {\n+            TerminatorKind::Drop { location: Place::Base(PlaceBase::Local(index)), target, .. } => {\n                 if promoted(index) {\n                     terminator.kind = TerminatorKind::Goto {\n                         target,"}, {"sha": "d41098e2881a63cf7ce7d967e6ab2ac185a6c9b7", "filename": "src/librustc_mir/transform/qualify_consts.rs", "status": "modified", "additions": 22, "deletions": 14, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_consts.rs?ref=0f993d5a7abfe156a261d7a53f4297e8b05cc91f", "patch": "@@ -186,9 +186,9 @@ trait Qualif {\n \n     fn in_place(cx: &ConstCx<'_, 'tcx>, place: &Place<'tcx>) -> bool {\n         match *place {\n-            Place::Local(local) => Self::in_local(cx, local),\n-            Place::Promoted(_) => bug!(\"qualifying already promoted MIR\"),\n-            Place::Static(ref static_) => Self::in_static(cx, static_),\n+            Place::Base(PlaceBase::Local(local)) => Self::in_local(cx, local),\n+            Place::Base(PlaceBase::Promoted(_)) => bug!(\"qualifying already promoted MIR\"),\n+            Place::Base(PlaceBase::Static(ref static_)) => Self::in_static(cx, static_),\n             Place::Projection(ref proj) => Self::in_projection(cx, proj),\n         }\n     }\n@@ -730,7 +730,7 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n                     place = &proj.base;\n                 }\n                 debug!(\"qualify_consts: promotion candidate: place={:?}\", place);\n-                if let Place::Local(local) = *place {\n+                if let Place::Base(PlaceBase::Local(local)) = *place {\n                     if self.mir.local_kind(local) == LocalKind::Temp {\n                         debug!(\"qualify_consts: promotion candidate: local={:?}\", local);\n                         // The borrowed place doesn't have `HasMutInterior`\n@@ -754,7 +754,7 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n         let index = loop {\n             match dest {\n                 // We treat all locals equal in constants\n-                Place::Local(index) => break *index,\n+                Place::Base(PlaceBase::Local(index)) => break *index,\n                 // projections are transparent for assignments\n                 // we qualify the entire destination at once, even if just a field would have\n                 // stricter qualification\n@@ -768,8 +768,9 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n                     );\n                     dest = &proj.base;\n                 },\n-                Place::Promoted(..) => bug!(\"promoteds don't exist yet during promotion\"),\n-                Place::Static(..) => {\n+                Place::Base(PlaceBase::Promoted(..)) =>\n+                    bug!(\"promoteds don't exist yet during promotion\"),\n+                Place::Base(PlaceBase::Static(..)) => {\n                     // Catch more errors in the destination. `visit_place` also checks that we\n                     // do not try to access statics from constants or try to mutate statics\n                     self.visit_place(\n@@ -878,7 +879,10 @@ impl<'a, 'tcx> Checker<'a, 'tcx> {\n             match *candidate {\n                 Candidate::Ref(Location { block: bb, statement_index: stmt_idx }) => {\n                     match self.mir[bb].statements[stmt_idx].kind {\n-                        StatementKind::Assign(_, box Rvalue::Ref(_, _, Place::Local(index))) => {\n+                        StatementKind::Assign(\n+                            _,\n+                            box Rvalue::Ref(_, _, Place::Base(PlaceBase::Local(index)))\n+                        ) => {\n                             promoted_temps.insert(index);\n                         }\n                         _ => {}\n@@ -915,9 +919,9 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n         debug!(\"visit_place: place={:?} context={:?} location={:?}\", place, context, location);\n         self.super_place(place, context, location);\n         match *place {\n-            Place::Local(_) |\n-            Place::Promoted(_) => {}\n-            Place::Static(ref global) => {\n+            Place::Base(PlaceBase::Local(_)) |\n+            Place::Base(PlaceBase::Promoted(_)) => {}\n+            Place::Base(PlaceBase::Static(ref global)) => {\n                 if self.tcx\n                        .get_attrs(global.def_id)\n                        .iter()\n@@ -1032,7 +1036,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n         match *operand {\n             Operand::Move(ref place) => {\n                 // Mark the consumed locals to indicate later drops are noops.\n-                if let Place::Local(local) = *place {\n+                if let Place::Base(PlaceBase::Local(local)) = *place {\n                     self.cx.per_local[NeedsDrop].remove(local);\n                 }\n             }\n@@ -1335,7 +1339,7 @@ impl<'a, 'tcx> Visitor<'tcx> for Checker<'a, 'tcx> {\n                 unleash_miri!(self);\n                 // HACK(eddyb): emulate a bit of dataflow analysis,\n                 // conservatively, that drop elaboration will do.\n-                let needs_drop = if let Place::Local(local) = *place {\n+                let needs_drop = if let Place::Base(PlaceBase::Local(local)) = *place {\n                     if NeedsDrop::in_local(self, local) {\n                         Some(self.mir.local_decls[local].source_info.span)\n                     } else {\n@@ -1565,7 +1569,11 @@ impl MirPass for QualifyAndPromoteConstants {\n                 });\n                 let terminator = block.terminator_mut();\n                 match terminator.kind {\n-                    TerminatorKind::Drop { location: Place::Local(index), target, .. } => {\n+                    TerminatorKind::Drop {\n+                        location: Place::Base(PlaceBase::Local(index)),\n+                        target,\n+                        ..\n+                    } => {\n                         if promoted_temps.contains(index) {\n                             terminator.kind = TerminatorKind::Goto {\n                                 target,"}, {"sha": "6c44fac10f59de98e9f4acdd736bd27d55baa4f2", "filename": "src/librustc_mir/transform/qualify_min_const_fn.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fqualify_min_const_fn.rs?ref=0f993d5a7abfe156a261d7a53f4297e8b05cc91f", "patch": "@@ -252,10 +252,11 @@ fn check_place(\n     span: Span,\n ) -> McfResult {\n     match place {\n-        Place::Local(_) => Ok(()),\n+        Place::Base(PlaceBase::Local(_)) => Ok(()),\n         // promoteds are always fine, they are essentially constants\n-        Place::Promoted(_) => Ok(()),\n-        Place::Static(_) => Err((span, \"cannot access `static` items in const fn\".into())),\n+        Place::Base(PlaceBase::Promoted(_)) => Ok(()),\n+        Place::Base(PlaceBase::Static(_)) =>\n+            Err((span, \"cannot access `static` items in const fn\".into())),\n         Place::Projection(proj) => {\n             match proj.elem {\n                 | ProjectionElem::ConstantIndex { .. } | ProjectionElem::Subslice { .. }"}, {"sha": "b7493b25d46503826b4ddebfb87aa0015e1d2ffe", "filename": "src/librustc_mir/transform/remove_noop_landing_pads.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fremove_noop_landing_pads.rs?ref=0f993d5a7abfe156a261d7a53f4297e8b05cc91f", "patch": "@@ -47,7 +47,7 @@ impl RemoveNoopLandingPads {\n                     // These are all nops in a landing pad\n                 }\n \n-                StatementKind::Assign(Place::Local(_), box Rvalue::Use(_)) => {\n+                StatementKind::Assign(Place::Base(PlaceBase::Local(_)), box Rvalue::Use(_)) => {\n                     // Writing to a local (e.g., a drop flag) does not\n                     // turn a landing pad to a non-nop\n                 }"}, {"sha": "a44ec526f9ddc852c832f773b3ef5392998851ab", "filename": "src/librustc_mir/transform/rustc_peek.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Frustc_peek.rs?ref=0f993d5a7abfe156a261d7a53f4297e8b05cc91f", "patch": "@@ -115,8 +115,8 @@ fn each_block<'a, 'tcx, O>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     };\n     assert!(args.len() == 1);\n     let peek_arg_place = match args[0] {\n-        mir::Operand::Copy(ref place @ mir::Place::Local(_)) |\n-        mir::Operand::Move(ref place @ mir::Place::Local(_)) => Some(place),\n+        mir::Operand::Copy(ref place @ mir::Place::Base(mir::PlaceBase::Local(_))) |\n+        mir::Operand::Move(ref place @ mir::Place::Base(mir::PlaceBase::Local(_))) => Some(place),\n         _ => None,\n     };\n "}, {"sha": "b1d898bb5b0263d672887bb99c46fc20b55ef9c0", "filename": "src/librustc_mir/transform/uniform_array_move_out.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Funiform_array_move_out.rs?ref=0f993d5a7abfe156a261d7a53f4297e8b05cc91f", "patch": "@@ -101,7 +101,7 @@ impl<'a, 'tcx> UniformArrayMoveOutVisitor<'a, 'tcx> {\n                     let temp = self.patch.new_temp(item_ty, self.mir.source_info(location).span);\n                     self.patch.add_statement(location, StatementKind::StorageLive(temp));\n                     self.patch.add_assign(location,\n-                                          Place::Local(temp),\n+                                          Place::Base(PlaceBase::Local(temp)),\n                                           Rvalue::Use(\n                                               Operand::Move(\n                                                   Place::Projection(box PlaceProjection{\n@@ -113,12 +113,16 @@ impl<'a, 'tcx> UniformArrayMoveOutVisitor<'a, 'tcx> {\n                                                   }))));\n                     temp\n                 }).collect();\n-                self.patch.add_assign(location,\n-                                      dst_place.clone(),\n-                                      Rvalue::Aggregate(box AggregateKind::Array(item_ty),\n-                                      temps.iter().map(\n-                                          |x| Operand::Move(Place::Local(*x))).collect()\n-                                      ));\n+                self.patch.add_assign(\n+                    location,\n+                    dst_place.clone(),\n+                    Rvalue::Aggregate(\n+                        box AggregateKind::Array(item_ty),\n+                        temps.iter().map(\n+                            |x| Operand::Move(Place::Base(PlaceBase::Local(*x)))\n+                        ).collect()\n+                    )\n+                );\n                 for temp in temps {\n                     self.patch.add_statement(location, StatementKind::StorageDead(temp));\n                 }\n@@ -176,7 +180,7 @@ impl MirPass for RestoreSubsliceArrayMoveOut {\n                 if let StatementKind::Assign(ref dst_place, ref rval) = statement.kind {\n                     if let Rvalue::Aggregate(box AggregateKind::Array(_), ref items) = **rval {\n                         let items : Vec<_> = items.iter().map(|item| {\n-                            if let Operand::Move(Place::Local(local)) = item {\n+                            if let Operand::Move(Place::Base(PlaceBase::Local(local))) = item {\n                                 let local_use = &visitor.locals_use[*local];\n                                 let opt_index_and_place = Self::try_get_item_source(local_use, mir);\n                                 // each local should be used twice:\n@@ -257,7 +261,7 @@ impl RestoreSubsliceArrayMoveOut {\n             if block.statements.len() > location.statement_index {\n                 let statement = &block.statements[location.statement_index];\n                 if let StatementKind::Assign(\n-                    Place::Local(_),\n+                    Place::Base(PlaceBase::Local(_)),\n                     box Rvalue::Use(Operand::Move(Place::Projection(box PlaceProjection{\n                         ref base, elem: ProjectionElem::ConstantIndex{\n                             offset, min_length: _, from_end: false}})))) = statement.kind {"}, {"sha": "26fa8d6d1f0bf98eee4a282b6deecc5661116f71", "filename": "src/librustc_mir/util/elaborate_drops.rs", "status": "modified", "additions": 21, "deletions": 18, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Felaborate_drops.rs?ref=0f993d5a7abfe156a261d7a53f4297e8b05cc91f", "patch": "@@ -486,7 +486,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n         // discriminant after it is free-ed, because that\n         // way lies only trouble.\n         let discr_ty = adt.repr.discr_type().to_ty(self.tcx());\n-        let discr = Place::Local(self.new_temp(discr_ty));\n+        let discr = Place::Base(PlaceBase::Local(self.new_temp(discr_ty)));\n         let discr_rv = Rvalue::Discriminant(self.place.clone());\n         let switch_block = BasicBlockData {\n             statements: vec![self.assign(&discr, discr_rv)],\n@@ -520,11 +520,11 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n             mutbl: hir::Mutability::MutMutable\n         });\n         let ref_place = self.new_temp(ref_ty);\n-        let unit_temp = Place::Local(self.new_temp(tcx.mk_unit()));\n+        let unit_temp = Place::Base(PlaceBase::Local(self.new_temp(tcx.mk_unit())));\n \n         let result = BasicBlockData {\n             statements: vec![self.assign(\n-                &Place::Local(ref_place),\n+                &Place::Base(PlaceBase::Local(ref_place)),\n                 Rvalue::Ref(tcx.types.re_erased,\n                             BorrowKind::Mut { allow_two_phase_borrow: false },\n                             self.place.clone())\n@@ -533,7 +533,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n                 kind: TerminatorKind::Call {\n                     func: Operand::function_handle(tcx, drop_fn.def_id, substs,\n                                                    self.source_info.span),\n-                    args: vec![Operand::Move(Place::Local(ref_place))],\n+                    args: vec![Operand::Move(Place::Base(PlaceBase::Local(ref_place)))],\n                     destination: Some((unit_temp, succ)),\n                     cleanup: unwind.into_option(),\n                     from_hir_call: true,\n@@ -578,32 +578,32 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n             ty: ety,\n             mutbl: hir::Mutability::MutMutable\n         });\n-        let ptr = &Place::Local(self.new_temp(ref_ty));\n-        let can_go = &Place::Local(self.new_temp(tcx.types.bool));\n+        let ptr = &Place::Base(PlaceBase::Local(self.new_temp(ref_ty)));\n+        let can_go = &Place::Base(PlaceBase::Local(self.new_temp(tcx.types.bool)));\n \n         let one = self.constant_usize(1);\n         let (ptr_next, cur_next) = if ptr_based {\n             (Rvalue::Ref(\n                 tcx.types.re_erased,\n                 BorrowKind::Mut { allow_two_phase_borrow: false },\n                 Place::Projection(Box::new(Projection {\n-                    base: Place::Local(cur),\n+                    base: Place::Base(PlaceBase::Local(cur)),\n                     elem: ProjectionElem::Deref,\n                 }))\n              ),\n-             Rvalue::BinaryOp(BinOp::Offset, copy(&Place::Local(cur)), one))\n+             Rvalue::BinaryOp(BinOp::Offset, copy(&Place::Base(PlaceBase::Local(cur))), one))\n         } else {\n             (Rvalue::Ref(\n                  tcx.types.re_erased,\n                  BorrowKind::Mut { allow_two_phase_borrow: false },\n                  self.place.clone().index(cur)),\n-             Rvalue::BinaryOp(BinOp::Add, copy(&Place::Local(cur)), one))\n+             Rvalue::BinaryOp(BinOp::Add, copy(&Place::Base(PlaceBase::Local(cur))), one))\n         };\n \n         let drop_block = BasicBlockData {\n             statements: vec![\n                 self.assign(ptr, ptr_next),\n-                self.assign(&Place::Local(cur), cur_next)\n+                self.assign(&Place::Base(PlaceBase::Local(cur)), cur_next)\n             ],\n             is_cleanup: unwind.is_cleanup(),\n             terminator: Some(Terminator {\n@@ -617,7 +617,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n         let loop_block = BasicBlockData {\n             statements: vec![\n                 self.assign(can_go, Rvalue::BinaryOp(BinOp::Eq,\n-                                                     copy(&Place::Local(cur)),\n+                                                     copy(&Place::Base(PlaceBase::Local(cur))),\n                                                      copy(length_or_end)))\n             ],\n             is_cleanup: unwind.is_cleanup(),\n@@ -667,8 +667,8 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n \n         let move_ = |place: &Place<'tcx>| Operand::Move(place.clone());\n         let tcx = self.tcx();\n-        let size = &Place::Local(self.new_temp(tcx.types.usize));\n-        let size_is_zero = &Place::Local(self.new_temp(tcx.types.bool));\n+        let size = &Place::Base(PlaceBase::Local(self.new_temp(tcx.types.usize)));\n+        let size_is_zero = &Place::Base(PlaceBase::Local(self.new_temp(tcx.types.bool)));\n         let base_block = BasicBlockData {\n             statements: vec![\n                 self.assign(size, Rvalue::NullaryOp(NullOp::SizeOf, ety)),\n@@ -703,9 +703,12 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n         };\n \n         let cur = self.new_temp(iter_ty);\n-        let length = Place::Local(self.new_temp(tcx.types.usize));\n+        let length = Place::Base(PlaceBase::Local(self.new_temp(tcx.types.usize)));\n         let length_or_end = if ptr_based {\n-            Place::Local(self.new_temp(iter_ty))\n+            // FIXME check if we want to make it return a `Place` directly\n+            // if all use sites want a `Place::Base` anyway.\n+            let temp = self.new_temp(iter_ty);\n+            Place::Base(PlaceBase::Local(temp))\n         } else {\n             length.clone()\n         };\n@@ -728,13 +731,13 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n             unwind,\n             ptr_based);\n \n-        let cur = Place::Local(cur);\n+        let cur = Place::Base(PlaceBase::Local(cur));\n         let zero = self.constant_usize(0);\n         let mut drop_block_stmts = vec![];\n         drop_block_stmts.push(self.assign(&length, Rvalue::Len(self.place.clone())));\n         if ptr_based {\n             let tmp_ty = tcx.mk_mut_ptr(self.place_ty(self.place));\n-            let tmp = Place::Local(self.new_temp(tmp_ty));\n+            let tmp = Place::Base(PlaceBase::Local(self.new_temp(tmp_ty)));\n             // tmp = &mut P;\n             // cur = tmp as *mut T;\n             // end = Offset(cur, len);\n@@ -883,7 +886,7 @@ impl<'l, 'b, 'tcx, D> DropCtxt<'l, 'b, 'tcx, D>\n         unwind: Unwind\n     ) -> BasicBlock {\n         let tcx = self.tcx();\n-        let unit_temp = Place::Local(self.new_temp(tcx.mk_unit()));\n+        let unit_temp = Place::Base(PlaceBase::Local(self.new_temp(tcx.mk_unit())));\n         let free_func = tcx.require_lang_item(lang_items::BoxFreeFnLangItem);\n         let args = adt.variants[VariantIdx::new(0)].fields.iter().enumerate().map(|(i, f)| {\n             let field = Field::new(i);"}, {"sha": "5d495fc04588b21e64156f036570f62fb7a577a5", "filename": "src/librustc_mir/util/graphviz.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Futil%2Fgraphviz.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Futil%2Fgraphviz.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fgraphviz.rs?ref=0f993d5a7abfe156a261d7a53f4297e8b05cc91f", "patch": "@@ -134,7 +134,11 @@ fn write_graph_label<'a, 'gcx, 'tcx, W: Write>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n         if i > 0 {\n             write!(w, \", \")?;\n         }\n-        write!(w, \"{:?}: {}\", Place::Local(arg), escape(&mir.local_decls[arg].ty))?;\n+        write!(w,\n+               \"{:?}: {}\",\n+               Place::Base(PlaceBase::Local(arg)),\n+               escape(&mir.local_decls[arg].ty)\n+        )?;\n     }\n \n     write!(w, \") -&gt; {}\", escape(mir.return_ty()))?;\n@@ -150,10 +154,10 @@ fn write_graph_label<'a, 'gcx, 'tcx, W: Write>(tcx: TyCtxt<'a, 'gcx, 'tcx>,\n \n         if let Some(name) = decl.name {\n             write!(w, r#\"{:?}: {}; // {}<br align=\"left\"/>\"#,\n-                   Place::Local(local), escape(&decl.ty), name)?;\n+                   Place::Base(PlaceBase::Local(local)), escape(&decl.ty), name)?;\n         } else {\n             write!(w, r#\"let mut {:?}: {};<br align=\"left\"/>\"#,\n-                   Place::Local(local), escape(&decl.ty))?;\n+                   Place::Base(PlaceBase::Local(local)), escape(&decl.ty))?;\n         }\n     }\n "}, {"sha": "c3fbee3a2a6e5747e31f804dd053a9a5ceb9f3fa", "filename": "src/librustc_mir/util/pretty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0f993d5a7abfe156a261d7a53f4297e8b05cc91f/src%2Flibrustc_mir%2Futil%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Futil%2Fpretty.rs?ref=0f993d5a7abfe156a261d7a53f4297e8b05cc91f", "patch": "@@ -625,7 +625,7 @@ fn write_mir_sig(\n             if i != 0 {\n                 write!(w, \", \")?;\n             }\n-            write!(w, \"{:?}: {}\", Place::Local(arg), mir.local_decls[arg].ty)?;\n+            write!(w, \"{:?}: {}\", Place::Base(PlaceBase::Local(arg)), mir.local_decls[arg].ty)?;\n         }\n \n         write!(w, \") -> {}\", mir.return_ty())?;"}]}