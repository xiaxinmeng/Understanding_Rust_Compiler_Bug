{"sha": "f9ecc680f0317bc56e661d7b41e7edcf52b2f995", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY5ZWNjNjgwZjAzMTdiYzU2ZTY2MWQ3YjQxZTdlZGNmNTJiMmY5OTU=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2018-02-02T20:24:14Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2018-02-02T20:24:14Z"}, "message": "Merge #35\n\n35: Move use r=matklad a=matklad", "tree": {"sha": "c15234d193badb99117c3f4a4b53a4d76c243f90", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c15234d193badb99117c3f4a4b53a4d76c243f90"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f9ecc680f0317bc56e661d7b41e7edcf52b2f995", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f9ecc680f0317bc56e661d7b41e7edcf52b2f995", "html_url": "https://github.com/rust-lang/rust/commit/f9ecc680f0317bc56e661d7b41e7edcf52b2f995", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f9ecc680f0317bc56e661d7b41e7edcf52b2f995/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "a1fcead680b0f52036dd48dd1781606e7a7339db", "url": "https://api.github.com/repos/rust-lang/rust/commits/a1fcead680b0f52036dd48dd1781606e7a7339db", "html_url": "https://github.com/rust-lang/rust/commit/a1fcead680b0f52036dd48dd1781606e7a7339db"}, {"sha": "be20b014d9fd4df64a8b6b88aaf6950d44ca6f39", "url": "https://api.github.com/repos/rust-lang/rust/commits/be20b014d9fd4df64a8b6b88aaf6950d44ca6f39", "html_url": "https://github.com/rust-lang/rust/commit/be20b014d9fd4df64a8b6b88aaf6950d44ca6f39"}], "stats": {"total": 299, "additions": 153, "deletions": 146}, "files": [{"sha": "35825e7c4d861d05adb836472eadb089bf0d77ce", "filename": "src/parser/event_parser/grammar/items/mod.rs", "status": "modified", "additions": 2, "deletions": 141, "changes": 143, "blob_url": "https://github.com/rust-lang/rust/blob/f9ecc680f0317bc56e661d7b41e7edcf52b2f995/src%2Fparser%2Fevent_parser%2Fgrammar%2Fitems%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9ecc680f0317bc56e661d7b41e7edcf52b2f995/src%2Fparser%2Fevent_parser%2Fgrammar%2Fitems%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fparser%2Fevent_parser%2Fgrammar%2Fitems%2Fmod.rs?ref=f9ecc680f0317bc56e661d7b41e7edcf52b2f995", "patch": "@@ -1,6 +1,7 @@\n use super::*;\n \n mod structs;\n+mod use_item;\n \n pub(super) fn mod_contents(p: &mut Parser, stop_on_r_curly: bool) {\n     attributes::inner_attributes(p);\n@@ -20,7 +21,7 @@ fn item(p: &mut Parser) {\n     let la = p.nth(1);\n     let item_kind = match p.current() {\n         USE_KW => {\n-            use_item(p);\n+            use_item::use_item(p);\n             USE_ITEM\n         }\n         EXTERN_KW if la == CRATE_KW => {\n@@ -82,76 +83,6 @@ fn item(p: &mut Parser) {\n     item.complete(p, item_kind);\n }\n \n-fn type_param_list(p: &mut Parser) {\n-    if !p.at(L_ANGLE) {\n-        return;\n-    }\n-    let m = p.start();\n-    p.bump();\n-\n-    while !p.at(EOF) && !p.at(R_ANGLE) {\n-        match p.current() {\n-            LIFETIME => lifetime_param(p),\n-            IDENT => type_param(p),\n-            _ => p.err_and_bump(\"expected type parameter\"),\n-        }\n-        if !p.at(R_ANGLE) && !p.expect(COMMA) {\n-            break;\n-        }\n-    }\n-    p.expect(R_ANGLE);\n-    m.complete(p, TYPE_PARAM_LIST);\n-\n-    fn lifetime_param(p: &mut Parser) {\n-        assert!(p.at(LIFETIME));\n-        let m = p.start();\n-        p.bump();\n-        if p.eat(COLON) {\n-            while p.at(LIFETIME) {\n-                p.bump();\n-                if !p.eat(PLUS) {\n-                    break;\n-                }\n-            }\n-        }\n-        m.complete(p, LIFETIME_PARAM);\n-    }\n-\n-    fn type_param(p: &mut Parser) {\n-        assert!(p.at(IDENT));\n-        let m = p.start();\n-        p.bump();\n-        if p.eat(COLON) {\n-            loop {\n-                let has_paren = p.eat(L_PAREN);\n-                p.eat(QUESTION);\n-                if p.at(FOR_KW) {\n-                    //TODO\n-                }\n-                if p.at(LIFETIME) {\n-                    p.bump();\n-                } else if paths::is_path_start(p) {\n-                    paths::type_path(p);\n-                } else {\n-                    break;\n-                }\n-                if has_paren {\n-                    p.expect(R_PAREN);\n-                }\n-                if !p.eat(PLUS) {\n-                    break;\n-                }\n-            }\n-        }\n-        if p.at(EQ) {\n-            types::type_ref(p)\n-        }\n-        m.complete(p, TYPE_PARAM);\n-    }\n-}\n-\n-fn where_clause(_: &mut Parser) {}\n-\n fn extern_crate_item(p: &mut Parser) {\n     assert!(p.at(EXTERN_KW));\n     p.bump();\n@@ -179,76 +110,6 @@ fn extern_block(p: &mut Parser) {\n     p.expect(R_CURLY);\n }\n \n-pub(super) fn is_use_tree_start(kind: SyntaxKind) -> bool {\n-    kind == STAR || kind == L_CURLY\n-}\n-\n-fn use_item(p: &mut Parser) {\n-    assert!(p.at(USE_KW));\n-    p.bump();\n-\n-    use_tree(p);\n-    p.expect(SEMI);\n-\n-    fn use_tree(p: &mut Parser) {\n-        let la = p.nth(1);\n-        let m = p.start();\n-        match (p.current(), la) {\n-            (STAR, _) => p.bump(),\n-            (COLONCOLON, STAR) => {\n-                p.bump();\n-                p.bump();\n-            }\n-            (L_CURLY, _) | (COLONCOLON, L_CURLY) => {\n-                if p.at(COLONCOLON) {\n-                    p.bump();\n-                }\n-                nested_trees(p);\n-            }\n-            _ if paths::is_path_start(p) => {\n-                paths::use_path(p);\n-                match p.current() {\n-                    AS_KW => {\n-                        alias(p);\n-                    }\n-                    COLONCOLON => {\n-                        p.bump();\n-                        match p.current() {\n-                            STAR => {\n-                                p.bump();\n-                            }\n-                            L_CURLY => nested_trees(p),\n-                            _ => {\n-                                // is this unreachable?\n-                                p.error().message(\"expected `{` or `*`\").emit();\n-                            }\n-                        }\n-                    }\n-                    _ => (),\n-                }\n-            }\n-            _ => {\n-                m.abandon(p);\n-                p.err_and_bump(\"expected one of `*`, `::`, `{`, `self`, `super`, `indent`\");\n-                return;\n-            }\n-        }\n-        m.complete(p, USE_TREE);\n-    }\n-\n-    fn nested_trees(p: &mut Parser) {\n-        assert!(p.at(L_CURLY));\n-        p.bump();\n-        while !p.at(EOF) && !p.at(R_CURLY) {\n-            use_tree(p);\n-            if !p.at(R_CURLY) {\n-                p.expect(COMMA);\n-            }\n-        }\n-        p.expect(R_CURLY);\n-    }\n-}\n-\n fn abi(p: &mut Parser) {\n     assert!(p.at(EXTERN_KW));\n     let abi = p.start();"}, {"sha": "69d95c698f0ff0dbc5398b72959b31af11dd3750", "filename": "src/parser/event_parser/grammar/items/structs.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/f9ecc680f0317bc56e661d7b41e7edcf52b2f995/src%2Fparser%2Fevent_parser%2Fgrammar%2Fitems%2Fstructs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9ecc680f0317bc56e661d7b41e7edcf52b2f995/src%2Fparser%2Fevent_parser%2Fgrammar%2Fitems%2Fstructs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fparser%2Fevent_parser%2Fgrammar%2Fitems%2Fstructs.rs?ref=f9ecc680f0317bc56e661d7b41e7edcf52b2f995", "patch": "@@ -7,10 +7,10 @@ pub(super) fn struct_item(p: &mut Parser) {\n     if !p.expect(IDENT) {\n         return;\n     }\n-    type_param_list(p);\n+    type_params::list(p);\n     match p.current() {\n         WHERE_KW => {\n-            where_clause(p);\n+            type_params::where_clause(p);\n             match p.current() {\n                 SEMI => {\n                     p.bump();\n@@ -44,8 +44,8 @@ pub(super) fn enum_item(p: &mut Parser) {\n     assert!(p.at(ENUM_KW));\n     p.bump();\n     p.expect(IDENT);\n-    type_param_list(p);\n-    where_clause(p);\n+    type_params::list(p);\n+    type_params::where_clause(p);\n     if p.expect(L_CURLY) {\n         while !p.at(EOF) && !p.at(R_CURLY) {\n             let var = p.start();"}, {"sha": "38e7b3f8a521e23b90699f1d4f5718a66384cc65", "filename": "src/parser/event_parser/grammar/items/use_item.rs", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/f9ecc680f0317bc56e661d7b41e7edcf52b2f995/src%2Fparser%2Fevent_parser%2Fgrammar%2Fitems%2Fuse_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9ecc680f0317bc56e661d7b41e7edcf52b2f995/src%2Fparser%2Fevent_parser%2Fgrammar%2Fitems%2Fuse_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fparser%2Fevent_parser%2Fgrammar%2Fitems%2Fuse_item.rs?ref=f9ecc680f0317bc56e661d7b41e7edcf52b2f995", "patch": "@@ -0,0 +1,66 @@\n+use super::*;\n+\n+pub(super) fn use_item(p: &mut Parser) {\n+    assert!(p.at(USE_KW));\n+    p.bump();\n+    use_tree(p);\n+    p.expect(SEMI);\n+}\n+\n+fn use_tree(p: &mut Parser) {\n+    let la = p.nth(1);\n+    let m = p.start();\n+    match (p.current(), la) {\n+        (STAR, _) => p.bump(),\n+        (COLONCOLON, STAR) => {\n+            p.bump();\n+            p.bump();\n+        }\n+        (L_CURLY, _) | (COLONCOLON, L_CURLY) => {\n+            if p.at(COLONCOLON) {\n+                p.bump();\n+            }\n+            nested_trees(p);\n+        }\n+        _ if paths::is_path_start(p) => {\n+            paths::use_path(p);\n+            match p.current() {\n+                AS_KW => {\n+                    alias(p);\n+                }\n+                COLONCOLON => {\n+                    p.bump();\n+                    match p.current() {\n+                        STAR => {\n+                            p.bump();\n+                        }\n+                        L_CURLY => nested_trees(p),\n+                        _ => {\n+                            // is this unreachable?\n+                            p.error().message(\"expected `{` or `*`\").emit();\n+                        }\n+                    }\n+                }\n+                _ => (),\n+            }\n+        }\n+        _ => {\n+            m.abandon(p);\n+            p.err_and_bump(\"expected one of `*`, `::`, `{`, `self`, `super`, `indent`\");\n+            return;\n+        }\n+    }\n+    m.complete(p, USE_TREE);\n+}\n+\n+fn nested_trees(p: &mut Parser) {\n+    assert!(p.at(L_CURLY));\n+    p.bump();\n+    while !p.at(EOF) && !p.at(R_CURLY) {\n+        use_tree(p);\n+        if !p.at(R_CURLY) {\n+            p.expect(COMMA);\n+        }\n+    }\n+    p.expect(R_CURLY);\n+}"}, {"sha": "afce308d0ce9e137ebc1a19184b4d68cc5e04c6e", "filename": "src/parser/event_parser/grammar/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/f9ecc680f0317bc56e661d7b41e7edcf52b2f995/src%2Fparser%2Fevent_parser%2Fgrammar%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9ecc680f0317bc56e661d7b41e7edcf52b2f995/src%2Fparser%2Fevent_parser%2Fgrammar%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fparser%2Fevent_parser%2Fgrammar%2Fmod.rs?ref=f9ecc680f0317bc56e661d7b41e7edcf52b2f995", "patch": "@@ -7,6 +7,7 @@ mod attributes;\n mod expressions;\n mod types;\n mod paths;\n+mod type_params;\n \n pub(crate) fn file(p: &mut Parser) {\n     let file = p.start();"}, {"sha": "6efac26103789507381095638c7f9e590446848b", "filename": "src/parser/event_parser/grammar/paths.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f9ecc680f0317bc56e661d7b41e7edcf52b2f995/src%2Fparser%2Fevent_parser%2Fgrammar%2Fpaths.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9ecc680f0317bc56e661d7b41e7edcf52b2f995/src%2Fparser%2Fevent_parser%2Fgrammar%2Fpaths.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fparser%2Fevent_parser%2Fgrammar%2Fpaths.rs?ref=f9ecc680f0317bc56e661d7b41e7edcf52b2f995", "patch": "@@ -20,7 +20,11 @@ fn path(p: &mut Parser) {\n     path_segment(p, true);\n     let mut qual = path.complete(p, PATH);\n     loop {\n-        if p.at(COLONCOLON) && !items::is_use_tree_start(p.nth(1)) {\n+        let use_tree = match p.nth(1) {\n+            STAR | L_CURLY => true,\n+            _ => false,\n+        };\n+        if p.at(COLONCOLON) && !use_tree {\n             let path = qual.precede(p);\n             p.bump();\n             path_segment(p, false);"}, {"sha": "12c9a53627e827f34bdd46eb80c5e09bbd383630", "filename": "src/parser/event_parser/grammar/type_params.rs", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/rust-lang/rust/blob/f9ecc680f0317bc56e661d7b41e7edcf52b2f995/src%2Fparser%2Fevent_parser%2Fgrammar%2Ftype_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f9ecc680f0317bc56e661d7b41e7edcf52b2f995/src%2Fparser%2Fevent_parser%2Fgrammar%2Ftype_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fparser%2Fevent_parser%2Fgrammar%2Ftype_params.rs?ref=f9ecc680f0317bc56e661d7b41e7edcf52b2f995", "patch": "@@ -0,0 +1,75 @@\n+use super::*;\n+\n+pub(super) fn list(p: &mut Parser) {\n+    if !p.at(L_ANGLE) {\n+        return;\n+    }\n+    let m = p.start();\n+    p.bump();\n+\n+    while !p.at(EOF) && !p.at(R_ANGLE) {\n+        match p.current() {\n+            LIFETIME => lifetime_param(p),\n+            IDENT => type_param(p),\n+            _ => p.err_and_bump(\"expected type parameter\"),\n+        }\n+        if !p.at(R_ANGLE) && !p.expect(COMMA) {\n+            break;\n+        }\n+    }\n+    p.expect(R_ANGLE);\n+    m.complete(p, TYPE_PARAM_LIST);\n+\n+    fn lifetime_param(p: &mut Parser) {\n+        assert!(p.at(LIFETIME));\n+        let m = p.start();\n+        p.bump();\n+        if p.eat(COLON) {\n+            while p.at(LIFETIME) {\n+                p.bump();\n+                if !p.eat(PLUS) {\n+                    break;\n+                }\n+            }\n+        }\n+        m.complete(p, LIFETIME_PARAM);\n+    }\n+\n+    fn type_param(p: &mut Parser) {\n+        assert!(p.at(IDENT));\n+        let m = p.start();\n+        p.bump();\n+        if p.eat(COLON) {\n+            loop {\n+                let has_paren = p.eat(L_PAREN);\n+                p.eat(QUESTION);\n+                if p.at(FOR_KW) {\n+                    //TODO\n+                }\n+                if p.at(LIFETIME) {\n+                    p.bump();\n+                } else if paths::is_path_start(p) {\n+                    paths::type_path(p);\n+                } else {\n+                    break;\n+                }\n+                if has_paren {\n+                    p.expect(R_PAREN);\n+                }\n+                if !p.eat(PLUS) {\n+                    break;\n+                }\n+            }\n+        }\n+        if p.at(EQ) {\n+            types::type_ref(p)\n+        }\n+        m.complete(p, TYPE_PARAM);\n+    }\n+}\n+\n+pub(super) fn where_clause(p: &mut Parser) {\n+    if p.at(WHERE_KW) {\n+        p.bump();\n+    }\n+}"}]}