{"sha": "9814e830942dcc65e69a0d077cb2e013b5948795", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk4MTRlODMwOTQyZGNjNjVlNjlhMGQwNzdjYjJlMDEzYjU5NDg3OTU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-27T04:08:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-05-27T04:08:20Z"}, "message": "Auto merge of #84124 - 12101111:libunwind, r=petrochenkov\n\nlibunwind fix and cleanup\n\nFix:\n\n1. \"system-llvm-libunwind\" now only skip build-script for linux target\n2. workaround from https://github.com/rust-lang/rust/pull/65972 is not needed, upstream fix it in https://github.com/llvm/llvm-project/commit/68c50708d1f2b9aee3f10ec710df0b1387f701e5 ( LLVM 11 )\n3. remove code for MSCV and Apple in `compile()`, as they are not used\n4. fix https://github.com/rust-lang/rust/issues/69222 , compile c files and cpp files in different config\n5. fix conditional compilation for musl target.\n6. fix that x86_64-fortanix-unknown-sgx don't link libunwind built in build-script into rlib", "tree": {"sha": "84d3630e3b0135f146ace121dcc0457f0a976ded", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/84d3630e3b0135f146ace121dcc0457f0a976ded"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9814e830942dcc65e69a0d077cb2e013b5948795", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9814e830942dcc65e69a0d077cb2e013b5948795", "html_url": "https://github.com/rust-lang/rust/commit/9814e830942dcc65e69a0d077cb2e013b5948795", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9814e830942dcc65e69a0d077cb2e013b5948795/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c4ec606606850a5a3eba31da88ccd338ee8e8da5", "url": "https://api.github.com/repos/rust-lang/rust/commits/c4ec606606850a5a3eba31da88ccd338ee8e8da5", "html_url": "https://github.com/rust-lang/rust/commit/c4ec606606850a5a3eba31da88ccd338ee8e8da5"}, {"sha": "52a33655be8f2afc1ac666d24b5850badb23b3e7", "url": "https://api.github.com/repos/rust-lang/rust/commits/52a33655be8f2afc1ac666d24b5850badb23b3e7", "html_url": "https://github.com/rust-lang/rust/commit/52a33655be8f2afc1ac666d24b5850badb23b3e7"}], "stats": {"total": 182, "additions": 106, "deletions": 76}, "files": [{"sha": "df2fb448b7d4dc9b437636fe6ff40f69e3c8257d", "filename": "config.toml.example", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/9814e830942dcc65e69a0d077cb2e013b5948795/config.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/9814e830942dcc65e69a0d077cb2e013b5948795/config.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.toml.example?ref=9814e830942dcc65e69a0d077cb2e013b5948795", "patch": "@@ -563,6 +563,14 @@ changelog-seen = 2\n \n # Use LLVM libunwind as the implementation for Rust's unwinder.\n # Accepted values are 'in-tree' (formerly true), 'system' or 'no' (formerly false).\n+# This option only applies for Linux and Fuchsia targets.\n+# On Linux target, if crt-static is not enabled, 'no' means dynamic link to\n+# `libgcc_s.so`, 'in-tree' means static link to the in-tree build of llvm libunwind\n+# and 'system' means dynamic link to `libunwind.so`. If crt-static is enabled,\n+# the behavior is depend on the libc. On musl target, 'no' and 'in-tree' both \n+# means static link to the in-tree build of llvm libunwind, and 'system' means \n+# static link to `libunwind.a` provided by system. Due to the limitation of glibc,\n+# it must link to `libgcc_eh.a` to get a working output, and this option have no effect.\n #llvm-libunwind = 'no'\n \n # Enable Windows Control Flow Guard checks in the standard library."}, {"sha": "c76ba7667d4e67d874414b7fc1e58d7eb9063869", "filename": "library/unwind/Cargo.toml", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/9814e830942dcc65e69a0d077cb2e013b5948795/library%2Funwind%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/9814e830942dcc65e69a0d077cb2e013b5948795/library%2Funwind%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Funwind%2FCargo.toml?ref=9814e830942dcc65e69a0d077cb2e013b5948795", "patch": "@@ -24,5 +24,12 @@ cfg-if = \"0.1.8\"\n cc = \"1.0.68\"\n \n [features]\n+\n+# Only applies for Linux and Fuchsia targets\n+# Static link to the in-tree build of llvm libunwind\n llvm-libunwind = []\n+\n+# Only applies for Linux and Fuchsia targets\n+# If crt-static is enabled, static link to `libunwind.a` provided by system\n+# If crt-static is disabled, dynamic link to `libunwind.so` provided by system\n system-llvm-libunwind = []"}, {"sha": "96df3fc5ac4c8351980da712da87705cfac19324", "filename": "library/unwind/build.rs", "status": "modified", "additions": 74, "deletions": 72, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/9814e830942dcc65e69a0d077cb2e013b5948795/library%2Funwind%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9814e830942dcc65e69a0d077cb2e013b5948795/library%2Funwind%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Funwind%2Fbuild.rs?ref=9814e830942dcc65e69a0d077cb2e013b5948795", "patch": "@@ -4,7 +4,8 @@ fn main() {\n     println!(\"cargo:rerun-if-changed=build.rs\");\n     let target = env::var(\"TARGET\").expect(\"TARGET was not set\");\n \n-    if cfg!(feature = \"system-llvm-libunwind\") {\n+    if cfg!(target_os = \"linux\") && cfg!(feature = \"system-llvm-libunwind\") {\n+        // linking for Linux is handled in lib.rs\n         return;\n     }\n \n@@ -57,101 +58,102 @@ mod llvm_libunwind {\n     pub fn compile() {\n         let target = env::var(\"TARGET\").expect(\"TARGET was not set\");\n         let target_env = env::var(\"CARGO_CFG_TARGET_ENV\").unwrap();\n-        let target_vendor = env::var(\"CARGO_CFG_TARGET_VENDOR\").unwrap();\n-        let target_endian_little = env::var(\"CARGO_CFG_TARGET_ENDIAN\").unwrap() != \"big\";\n-        let cfg = &mut cc::Build::new();\n-\n-        cfg.cpp(true);\n-        cfg.cpp_set_stdlib(None);\n-        cfg.warnings(false);\n+        let mut cc_cfg = cc::Build::new();\n+        let mut cpp_cfg = cc::Build::new();\n+        let root = Path::new(\"../../src/llvm-project/libunwind\");\n \n-        // libunwind expects a __LITTLE_ENDIAN__ macro to be set for LE archs, cf. #65765\n-        if target_endian_little {\n-            cfg.define(\"__LITTLE_ENDIAN__\", Some(\"1\"));\n+        cpp_cfg.cpp(true);\n+        cpp_cfg.cpp_set_stdlib(None);\n+        cpp_cfg.flag(\"-nostdinc++\");\n+        cpp_cfg.flag(\"-fno-exceptions\");\n+        cpp_cfg.flag(\"-fno-rtti\");\n+        cpp_cfg.flag_if_supported(\"-fvisibility-global-new-delete-hidden\");\n+\n+        // Don't set this for clang\n+        // By default, Clang builds C code in GNU C17 mode.\n+        // By default, Clang builds C++ code according to the C++98 standard,\n+        // with many C++11 features accepted as extensions.\n+        if cpp_cfg.get_compiler().is_like_gnu() {\n+            cpp_cfg.flag(\"-std=c++11\");\n+            cc_cfg.flag(\"-std=c99\");\n         }\n \n-        if target_env == \"msvc\" {\n-            // Don't pull in extra libraries on MSVC\n-            cfg.flag(\"/Zl\");\n-            cfg.flag(\"/EHsc\");\n-            cfg.define(\"_CRT_SECURE_NO_WARNINGS\", None);\n-            cfg.define(\"_LIBUNWIND_DISABLE_VISIBILITY_ANNOTATIONS\", None);\n-        } else if target.contains(\"x86_64-fortanix-unknown-sgx\") {\n-            cfg.cpp(false);\n-\n-            cfg.static_flag(true);\n-            cfg.opt_level(3);\n-\n-            cfg.flag(\"-nostdinc++\");\n-            cfg.flag(\"-fno-exceptions\");\n-            cfg.flag(\"-fno-rtti\");\n-            cfg.flag(\"-fstrict-aliasing\");\n-            cfg.flag(\"-funwind-tables\");\n-            cfg.flag(\"-fvisibility=hidden\");\n-            cfg.flag(\"-fno-stack-protector\");\n-            cfg.flag(\"-ffreestanding\");\n-            cfg.flag(\"-fexceptions\");\n-\n-            // easiest way to undefine since no API available in cc::Build to undefine\n-            cfg.flag(\"-U_FORTIFY_SOURCE\");\n-            cfg.define(\"_FORTIFY_SOURCE\", \"0\");\n-\n-            cfg.flag_if_supported(\"-fvisibility-global-new-delete-hidden\");\n+        if target.contains(\"x86_64-fortanix-unknown-sgx\") || target_env == \"musl\" {\n+            // use the same GCC C compiler command to compile C++ code so we do not need to setup the\n+            // C++ compiler env variables on the builders.\n+            // Don't set this for clang++, as clang++ is able to compile this without libc++.\n+            if cpp_cfg.get_compiler().is_like_gnu() {\n+                cpp_cfg.cpp(false);\n+            }\n+        }\n \n-            cfg.define(\"_LIBUNWIND_DISABLE_VISIBILITY_ANNOTATIONS\", None);\n-            cfg.define(\"RUST_SGX\", \"1\");\n-            cfg.define(\"__NO_STRING_INLINES\", None);\n-            cfg.define(\"__NO_MATH_INLINES\", None);\n-            cfg.define(\"_LIBUNWIND_IS_BAREMETAL\", None);\n-            cfg.define(\"__LIBUNWIND_IS_NATIVE_ONLY\", None);\n-            cfg.define(\"NDEBUG\", None);\n-        } else {\n-            cfg.flag(\"-std=c99\");\n-            cfg.flag(\"-std=c++11\");\n-            cfg.flag(\"-nostdinc++\");\n-            cfg.flag(\"-fno-exceptions\");\n-            cfg.flag(\"-fno-rtti\");\n+        for cfg in [&mut cc_cfg, &mut cpp_cfg].iter_mut() {\n+            cfg.warnings(false);\n             cfg.flag(\"-fstrict-aliasing\");\n             cfg.flag(\"-funwind-tables\");\n             cfg.flag(\"-fvisibility=hidden\");\n-            cfg.flag_if_supported(\"-fvisibility-global-new-delete-hidden\");\n             cfg.define(\"_LIBUNWIND_DISABLE_VISIBILITY_ANNOTATIONS\", None);\n+            cfg.include(root.join(\"include\"));\n+            cfg.cargo_metadata(false);\n+\n+            if target.contains(\"x86_64-fortanix-unknown-sgx\") {\n+                cfg.static_flag(true);\n+                cfg.opt_level(3);\n+                cfg.flag(\"-fno-stack-protector\");\n+                cfg.flag(\"-ffreestanding\");\n+                cfg.flag(\"-fexceptions\");\n+\n+                // easiest way to undefine since no API available in cc::Build to undefine\n+                cfg.flag(\"-U_FORTIFY_SOURCE\");\n+                cfg.define(\"_FORTIFY_SOURCE\", \"0\");\n+                cfg.define(\"RUST_SGX\", \"1\");\n+                cfg.define(\"__NO_STRING_INLINES\", None);\n+                cfg.define(\"__NO_MATH_INLINES\", None);\n+                cfg.define(\"_LIBUNWIND_IS_BAREMETAL\", None);\n+                cfg.define(\"__LIBUNWIND_IS_NATIVE_ONLY\", None);\n+                cfg.define(\"NDEBUG\", None);\n+            }\n         }\n \n-        let mut unwind_sources = vec![\n-            \"Unwind-EHABI.cpp\",\n-            \"Unwind-seh.cpp\",\n+        let mut c_sources = vec![\n             \"Unwind-sjlj.c\",\n             \"UnwindLevel1-gcc-ext.c\",\n             \"UnwindLevel1.c\",\n             \"UnwindRegistersRestore.S\",\n             \"UnwindRegistersSave.S\",\n-            \"libunwind.cpp\",\n         ];\n \n-        if target_vendor == \"apple\" {\n-            unwind_sources.push(\"Unwind_AppleExtras.cpp\");\n-        }\n+        let cpp_sources = vec![\"Unwind-EHABI.cpp\", \"Unwind-seh.cpp\", \"libunwind.cpp\"];\n+        let cpp_len = cpp_sources.len();\n \n         if target.contains(\"x86_64-fortanix-unknown-sgx\") {\n-            unwind_sources.push(\"UnwindRustSgx.c\");\n+            c_sources.push(\"UnwindRustSgx.c\");\n         }\n \n-        let root = Path::new(\"../../src/llvm-project/libunwind\");\n-        cfg.include(root.join(\"include\"));\n-        for src in unwind_sources {\n-            cfg.file(root.join(\"src\").join(src));\n+        for src in c_sources {\n+            cc_cfg.file(root.join(\"src\").join(src).canonicalize().unwrap());\n         }\n \n-        if target_env == \"musl\" {\n-            // use the same C compiler command to compile C++ code so we do not need to setup the\n-            // C++ compiler env variables on the builders\n-            cfg.cpp(false);\n-            // linking for musl is handled in lib.rs\n-            cfg.cargo_metadata(false);\n-            println!(\"cargo:rustc-link-search=native={}\", env::var(\"OUT_DIR\").unwrap());\n+        for src in cpp_sources {\n+            cpp_cfg.file(root.join(\"src\").join(src).canonicalize().unwrap());\n         }\n \n-        cfg.compile(\"unwind\");\n+        let out_dir = env::var(\"OUT_DIR\").unwrap();\n+        println!(\"cargo:rustc-link-search=native={}\", &out_dir);\n+\n+        cpp_cfg.compile(\"unwind-cpp\");\n+\n+        let mut count = 0;\n+        for entry in std::fs::read_dir(&out_dir).unwrap() {\n+            let obj = entry.unwrap().path().canonicalize().unwrap();\n+            if let Some(ext) = obj.extension() {\n+                if ext == \"o\" {\n+                    cc_cfg.object(&obj);\n+                    count += 1;\n+                }\n+            }\n+        }\n+        assert_eq!(cpp_len, count, \"Can't get object files from {:?}\", &out_dir);\n+        cc_cfg.compile(\"unwind\");\n     }\n }"}, {"sha": "eaeec72fbb55b473230e5100cff49ec2c33aa3b1", "filename": "library/unwind/src/lib.rs", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/9814e830942dcc65e69a0d077cb2e013b5948795/library%2Funwind%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9814e830942dcc65e69a0d077cb2e013b5948795/library%2Funwind%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Funwind%2Fsrc%2Flib.rs?ref=9814e830942dcc65e69a0d077cb2e013b5948795", "patch": "@@ -37,9 +37,22 @@ cfg_if::cfg_if! {\n }\n \n #[cfg(target_env = \"musl\")]\n-#[link(name = \"unwind\", kind = \"static\", cfg(target_feature = \"crt-static\"))]\n-#[link(name = \"gcc_s\", cfg(not(target_feature = \"crt-static\")))]\n-extern \"C\" {}\n+cfg_if::cfg_if! {\n+    if #[cfg(all(feature = \"llvm-libunwind\", feature = \"system-llvm-libunwind\"))] {\n+        compile_error!(\"`llvm-libunwind` and `system-llvm-libunwind` cannot be enabled at the same time\");\n+    } else if #[cfg(feature = \"llvm-libunwind\")] {\n+        #[link(name = \"unwind\", kind = \"static\")]\n+        extern \"C\" {}\n+    } else if #[cfg(feature = \"system-llvm-libunwind\")] {\n+        #[link(name = \"unwind\", kind = \"static-nobundle\", cfg(target_feature = \"crt-static\"))]\n+        #[link(name = \"unwind\", cfg(not(target_feature = \"crt-static\")))]\n+        extern \"C\" {}\n+    } else {\n+        #[link(name = \"unwind\", kind = \"static\", cfg(target_feature = \"crt-static\"))]\n+        #[link(name = \"gcc_s\", cfg(not(target_feature = \"crt-static\")))]\n+        extern \"C\" {}\n+    }\n+}\n \n // When building with crt-static, we get `gcc_eh` from the `libc` crate, since\n // glibc needs it, and needs it listed later on the linker command line. We\n@@ -68,5 +81,5 @@ extern \"C\" {}\n extern \"C\" {}\n \n #[cfg(all(target_vendor = \"fortanix\", target_env = \"sgx\"))]\n-#[link(name = \"unwind\", kind = \"static-nobundle\")]\n+#[link(name = \"unwind\", kind = \"static\")]\n extern \"C\" {}"}]}