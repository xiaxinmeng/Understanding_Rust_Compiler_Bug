{"sha": "12f50a6e7502bce9726a5d900780f3d57361b63c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEyZjUwYTZlNzUwMmJjZTk3MjZhNWQ5MDA3ODBmM2Q1NzM2MWI2M2M=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-08-12T17:07:14Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-08-27T17:57:55Z"}, "message": "implement liveness tracing, remove old liveness system", "tree": {"sha": "3a583038648d0cd1d0f25ac644eebdd4563182f8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3a583038648d0cd1d0f25ac644eebdd4563182f8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/12f50a6e7502bce9726a5d900780f3d57361b63c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/12f50a6e7502bce9726a5d900780f3d57361b63c", "html_url": "https://github.com/rust-lang/rust/commit/12f50a6e7502bce9726a5d900780f3d57361b63c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/12f50a6e7502bce9726a5d900780f3d57361b63c/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f1a675a4676e9f9820576609cfb9be534b732f99", "url": "https://api.github.com/repos/rust-lang/rust/commits/f1a675a4676e9f9820576609cfb9be534b732f99", "html_url": "https://github.com/rust-lang/rust/commit/f1a675a4676e9f9820576609cfb9be534b732f99"}], "stats": {"total": 1301, "additions": 963, "deletions": 338}, "files": [{"sha": "0840f333c876b1ec6e95af8074a5bc8bf1e7889a", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/12f50a6e7502bce9726a5d900780f3d57361b63c/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12f50a6e7502bce9726a5d900780f3d57361b63c/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=12f50a6e7502bce9726a5d900780f3d57361b63c", "patch": "@@ -194,12 +194,12 @@ impl<'tcx> Mir<'tcx> {\n     }\n \n     #[inline]\n-    pub fn predecessors(&self) -> ReadGuard<IndexVec<BasicBlock, Vec<BasicBlock>>> {\n+    pub fn predecessors(&self) -> ReadGuard<'_, IndexVec<BasicBlock, Vec<BasicBlock>>> {\n         self.cache.predecessors(self)\n     }\n \n     #[inline]\n-    pub fn predecessors_for(&self, bb: BasicBlock) -> ReadGuard<Vec<BasicBlock>> {\n+    pub fn predecessors_for(&self, bb: BasicBlock) -> ReadGuard<'_, Vec<BasicBlock>> {\n         ReadGuard::map(self.predecessors(), |p| &p[bb])\n     }\n \n@@ -328,6 +328,14 @@ impl<'tcx> Mir<'tcx> {\n     pub fn return_ty(&self) -> Ty<'tcx> {\n         self.local_decls[RETURN_PLACE].ty\n     }\n+\n+    /// Get the location of the terminator for the given block\n+    pub fn terminator_loc(&self, bb: BasicBlock) -> Location {\n+        Location {\n+            block: bb,\n+            statement_index: self[bb].statements.len(),\n+        }\n+    }\n }\n \n #[derive(Copy, Clone, Debug, RustcEncodable, RustcDecodable)]"}, {"sha": "2e8d97252344ef35201fd5dbb028bed5424cd54a", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12f50a6e7502bce9726a5d900780f3d57361b63c/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12f50a6e7502bce9726a5d900780f3d57361b63c/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=12f50a6e7502bce9726a5d900780f3d57361b63c", "patch": "@@ -20,6 +20,7 @@\n       html_favicon_url = \"https://www.rust-lang.org/favicon.ico\",\n       html_root_url = \"https://doc.rust-lang.org/nightly/\")]\n \n+#![feature(in_band_lifetimes)]\n #![feature(unboxed_closures)]\n #![feature(fn_traits)]\n #![feature(unsize)]\n@@ -85,6 +86,7 @@ pub mod thin_vec;\n pub mod transitive_relation;\n pub mod tuple_slice;\n pub use ena::unify;\n+pub mod vec_linked_list;\n pub mod work_queue;\n pub mod fingerprint;\n "}, {"sha": "390dca6b9055fe252ab45892a787ba82ac69ba6f", "filename": "src/librustc_data_structures/vec_linked_list.rs", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/12f50a6e7502bce9726a5d900780f3d57361b63c/src%2Flibrustc_data_structures%2Fvec_linked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12f50a6e7502bce9726a5d900780f3d57361b63c/src%2Flibrustc_data_structures%2Fvec_linked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fvec_linked_list.rs?ref=12f50a6e7502bce9726a5d900780f3d57361b63c", "patch": "@@ -0,0 +1,83 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use indexed_vec::{Idx, IndexVec};\n+\n+pub fn iter<Ls>(\n+    first: Option<Ls::LinkIndex>,\n+    links: &'a Ls,\n+) -> impl Iterator<Item = Ls::LinkIndex> + 'a\n+where\n+    Ls: Links,\n+{\n+    VecLinkedListIterator {\n+        links: links,\n+        current: first,\n+    }\n+}\n+\n+pub struct VecLinkedListIterator<Ls>\n+where\n+    Ls: Links,\n+{\n+    links: Ls,\n+    current: Option<Ls::LinkIndex>,\n+}\n+\n+impl<Ls> Iterator for VecLinkedListIterator<Ls>\n+where\n+    Ls: Links,\n+{\n+    type Item = Ls::LinkIndex;\n+\n+    fn next(&mut self) -> Option<Ls::LinkIndex> {\n+        if let Some(c) = self.current {\n+            self.current = <Ls as Links>::next(&self.links, c);\n+            Some(c)\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+pub trait Links {\n+    type LinkIndex: Copy;\n+\n+    fn next(links: &Self, index: Self::LinkIndex) -> Option<Self::LinkIndex>;\n+}\n+\n+impl<Ls> Links for &Ls\n+where\n+    Ls: Links,\n+{\n+    type LinkIndex = Ls::LinkIndex;\n+\n+    fn next(links: &Self, index: Ls::LinkIndex) -> Option<Ls::LinkIndex> {\n+        <Ls as Links>::next(links, index)\n+    }\n+}\n+\n+pub trait LinkElem {\n+    type LinkIndex: Copy;\n+\n+    fn next(elem: &Self) -> Option<Self::LinkIndex>;\n+}\n+\n+impl<L, E> Links for IndexVec<L, E>\n+where\n+    E: LinkElem<LinkIndex = L>,\n+    L: Idx,\n+{\n+    type LinkIndex = L;\n+\n+    fn next(links: &Self, index: L) -> Option<L> {\n+        <E as LinkElem>::next(&links[index])\n+    }\n+}"}, {"sha": "192fa2b9eeaf7238dd9c22da42d287d61504262b", "filename": "src/librustc_mir/borrow_check/flows.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12f50a6e7502bce9726a5d900780f3d57361b63c/src%2Flibrustc_mir%2Fborrow_check%2Fflows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12f50a6e7502bce9726a5d900780f3d57361b63c/src%2Flibrustc_mir%2Fborrow_check%2Fflows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fflows.rs?ref=12f50a6e7502bce9726a5d900780f3d57361b63c", "patch": "@@ -89,6 +89,10 @@ impl<'b, 'gcx, 'tcx> FlowsAtLocation for Flows<'b, 'gcx, 'tcx> {\n         each_flow!(self, reset_to_entry_of(bb));\n     }\n \n+    fn reset_to_exit_of(&mut self, bb: BasicBlock) {\n+        each_flow!(self, reset_to_exit_of(bb));\n+    }\n+\n     fn reconstruct_statement_effect(&mut self, location: Location) {\n         each_flow!(self, reconstruct_statement_effect(location));\n     }"}, {"sha": "b80f9784d6f8757879ecff6571036725c581fe8b", "filename": "src/librustc_mir/borrow_check/nll/mod.rs", "status": "modified", "additions": 4, "deletions": 87, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/12f50a6e7502bce9726a5d900780f3d57361b63c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12f50a6e7502bce9726a5d900780f3d57361b63c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fmod.rs?ref=12f50a6e7502bce9726a5d900780f3d57361b63c", "patch": "@@ -12,7 +12,7 @@ use borrow_check::borrow_set::BorrowSet;\n use borrow_check::location::{LocationIndex, LocationTable};\n use borrow_check::nll::facts::AllFactsExt;\n use borrow_check::nll::type_check::{MirTypeckResults, MirTypeckRegionConstraints};\n-use borrow_check::nll::type_check::liveness::liveness_map::{NllLivenessMap, LocalWithRegion};\n+use borrow_check::nll::type_check::liveness::liveness_map::NllLivenessMap;\n use borrow_check::nll::region_infer::values::RegionValueElements;\n use dataflow::indexes::BorrowIndex;\n use dataflow::move_paths::MoveData;\n@@ -22,22 +22,19 @@ use rustc::hir::def_id::DefId;\n use rustc::infer::InferCtxt;\n use rustc::mir::{ClosureOutlivesSubject, ClosureRegionRequirements, Mir};\n use rustc::ty::{self, RegionKind, RegionVid};\n-use rustc::util::nodemap::FxHashMap;\n use rustc_errors::Diagnostic;\n-use std::collections::BTreeSet;\n use std::fmt::Debug;\n use std::env;\n use std::io;\n use std::path::PathBuf;\n use std::rc::Rc;\n use std::str::FromStr;\n use transform::MirSource;\n-use util::liveness::{LivenessResults, LiveVarSet};\n \n use self::mir_util::PassWhere;\n use polonius_engine::{Algorithm, Output};\n use util as mir_util;\n-use util::pretty::{self, ALIGN};\n+use util::pretty;\n \n mod constraint_generation;\n pub mod explain_borrow;\n@@ -111,8 +108,6 @@ pub(in borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n     let MirTypeckResults {\n         constraints,\n         universal_region_relations,\n-        liveness,\n-        liveness_map,\n     } = type_check::type_check(\n         infcx,\n         param_env,\n@@ -205,8 +200,6 @@ pub(in borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n     // write unit-tests, as well as helping with debugging.\n     dump_mir_results(\n         infcx,\n-        &liveness,\n-        &liveness_map,\n         MirSource::item(def_id),\n         &mir,\n         &regioncx,\n@@ -222,8 +215,6 @@ pub(in borrow_check) fn compute_regions<'cx, 'gcx, 'tcx>(\n \n fn dump_mir_results<'a, 'gcx, 'tcx>(\n     infcx: &InferCtxt<'a, 'gcx, 'tcx>,\n-    liveness: &LivenessResults<LocalWithRegion>,\n-    liveness_map: &NllLivenessMap,\n     source: MirSource,\n     mir: &Mir<'tcx>,\n     regioncx: &RegionInferenceContext,\n@@ -233,34 +224,6 @@ fn dump_mir_results<'a, 'gcx, 'tcx>(\n         return;\n     }\n \n-    let regular_liveness_per_location: FxHashMap<_, _> = mir\n-        .basic_blocks()\n-        .indices()\n-        .flat_map(|bb| {\n-            let mut results = vec![];\n-            liveness\n-                .regular\n-                .simulate_block(&mir, bb, liveness_map, |location, local_set| {\n-                    results.push((location, local_set.clone()));\n-                });\n-            results\n-        })\n-        .collect();\n-\n-    let drop_liveness_per_location: FxHashMap<_, _> = mir\n-        .basic_blocks()\n-        .indices()\n-        .flat_map(|bb| {\n-            let mut results = vec![];\n-            liveness\n-                .drop\n-                .simulate_block(&mir, bb, liveness_map, |location, local_set| {\n-                    results.push((location, local_set.clone()));\n-                });\n-            results\n-        })\n-        .collect();\n-\n     mir_util::dump_mir(\n         infcx.tcx,\n         None,\n@@ -283,26 +246,10 @@ fn dump_mir_results<'a, 'gcx, 'tcx>(\n                     }\n                 }\n \n-                PassWhere::BeforeLocation(location) => {\n-                    let s = live_variable_set(\n-                        &regular_liveness_per_location[&location],\n-                        &drop_liveness_per_location[&location],\n-                    );\n-                    writeln!(\n-                        out,\n-                        \"{:ALIGN$} | Live variables on entry to {:?}: {}\",\n-                        \"\",\n-                        location,\n-                        s,\n-                        ALIGN = ALIGN\n-                    )?;\n+                PassWhere::BeforeLocation(_) => {\n                 }\n \n-                // After each basic block, dump out the values\n-                // that are live on exit from the basic block.\n-                PassWhere::AfterTerminator(bb) => {\n-                    let s = live_variable_set(&liveness.regular.outs[bb], &liveness.drop.outs[bb]);\n-                    writeln!(out, \"    | Live variables on exit from {:?}: {}\", bb, s)?;\n+                PassWhere::AfterTerminator(_) => {\n                 }\n \n                 PassWhere::BeforeBlock(_) | PassWhere::AfterLocation(_) | PassWhere::AfterCFG => {}\n@@ -420,33 +367,3 @@ impl ToRegionVid for RegionVid {\n         self\n     }\n }\n-\n-fn live_variable_set(\n-    regular: &LiveVarSet<LocalWithRegion>,\n-    drops: &LiveVarSet<LocalWithRegion>\n-) -> String {\n-    // sort and deduplicate:\n-    let all_locals: BTreeSet<_> = regular.iter().chain(drops.iter()).collect();\n-\n-    // construct a string with each local, including `(drop)` if it is\n-    // only dropped, versus a regular use.\n-    let mut string = String::new();\n-    for local in all_locals {\n-        string.push_str(&format!(\"{:?}\", local));\n-\n-        if !regular.contains(&local) {\n-            assert!(drops.contains(&local));\n-            string.push_str(\" (drop)\");\n-        }\n-\n-        string.push_str(\", \");\n-    }\n-\n-    let len = if string.is_empty() {\n-        0\n-    } else {\n-        string.len() - 2\n-    };\n-\n-    format!(\"[{}]\", &string[..len])\n-}"}, {"sha": "166281fd33199f39a57908c2232dde85db3c3102", "filename": "src/librustc_mir/borrow_check/nll/region_infer/values.rs", "status": "modified", "additions": 41, "deletions": 2, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/12f50a6e7502bce9726a5d900780f3d57361b63c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12f50a6e7502bce9726a5d900780f3d57361b63c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fvalues.rs?ref=12f50a6e7502bce9726a5d900780f3d57361b63c", "patch": "@@ -10,7 +10,7 @@\n \n use rustc::mir::{BasicBlock, Location, Mir};\n use rustc::ty::{self, RegionVid};\n-use rustc_data_structures::bitvec::SparseBitMatrix;\n+use rustc_data_structures::bitvec::{BitArray, SparseBitMatrix};\n use rustc_data_structures::indexed_vec::Idx;\n use rustc_data_structures::indexed_vec::IndexVec;\n use std::fmt::Debug;\n@@ -47,8 +47,13 @@ impl RegionValueElements {\n         }\n     }\n \n+    /// Total number of point indices\n+    crate fn num_points(&self) -> usize {\n+        self.num_points\n+    }\n+\n     /// Converts a `Location` into a `PointIndex`. O(1).\n-    fn point_from_location(&self, location: Location) -> PointIndex {\n+    crate fn point_from_location(&self, location: Location) -> PointIndex {\n         let Location {\n             block,\n             statement_index,\n@@ -57,6 +62,12 @@ impl RegionValueElements {\n         PointIndex::new(start_index + statement_index)\n     }\n \n+    /// Converts a `Location` into a `PointIndex`. O(1).\n+    crate fn entry_point(&self, block: BasicBlock) -> PointIndex {\n+        let start_index = self.statements_before_block[block];\n+        PointIndex::new(start_index)\n+    }\n+\n     /// Converts a `PointIndex` back to a location. O(N) where N is\n     /// the number of blocks; could be faster if we ever cared.\n     crate fn to_location(&self, i: PointIndex) -> Location {\n@@ -92,6 +103,15 @@ impl RegionValueElements {\n             statement_index: point_index - first_index,\n         }\n     }\n+\n+    /// Returns an iterator of each basic block and the first point\n+    /// index within the block; the point indices for all statements\n+    /// within the block follow afterwards.\n+    crate fn head_indices(&self) -> impl Iterator<Item = (BasicBlock, PointIndex)> + '_ {\n+        self.statements_before_block\n+            .iter_enumerated()\n+            .map(move |(bb, &first_index)| (bb, PointIndex::new(first_index)))\n+    }\n }\n \n /// A single integer representing a `Location` in the MIR control-flow\n@@ -151,6 +171,13 @@ impl<N: Idx> LivenessValues<N> {\n         self.points.add(row, index)\n     }\n \n+    /// Adds all the elements in the given bit array into the given\n+    /// region. Returns true if any of them are newly added.\n+    crate fn add_elements(&mut self, row: N, locations: &BitArray<PointIndex>) -> bool {\n+        debug!(\"LivenessValues::add_elements(row={:?}, locations={:?})\", row, locations);\n+        self.points.merge_into(row, locations)\n+    }\n+\n     /// Adds all the control-flow points to the values for `r`.\n     crate fn add_all_points(&mut self, row: N) {\n         self.points.add_all(row);\n@@ -366,6 +393,18 @@ impl ToElementIndex for ty::UniverseIndex {\n     }\n }\n \n+crate fn location_set_str(\n+    elements: &RegionValueElements,\n+    points: impl IntoIterator<Item = PointIndex>,\n+) -> String {\n+    region_value_str(\n+        points\n+            .into_iter()\n+            .map(|p| elements.to_location(p))\n+            .map(RegionElement::Location),\n+    )\n+}\n+\n fn region_value_str(elements: impl IntoIterator<Item = RegionElement>) -> String {\n     let mut result = String::new();\n     result.push_str(\"{\");"}, {"sha": "b63c43d825b5c7f04925e82b9a67ec2c3ef8c7b7", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness/local_use_map.rs", "status": "added", "additions": 158, "deletions": 0, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/12f50a6e7502bce9726a5d900780f3d57361b63c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Flocal_use_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12f50a6e7502bce9726a5d900780f3d57361b63c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Flocal_use_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Flocal_use_map.rs?ref=12f50a6e7502bce9726a5d900780f3d57361b63c", "patch": "@@ -0,0 +1,158 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use borrow_check::nll::region_infer::values::{PointIndex, RegionValueElements};\n+use borrow_check::nll::type_check::liveness::liveness_map::{LocalWithRegion, NllLivenessMap};\n+use rustc::mir::visit::{PlaceContext, Visitor};\n+use rustc::mir::{Local, Location, Mir};\n+use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n+use rustc_data_structures::vec_linked_list as vll;\n+use util::liveness::{categorize, DefUse, LiveVariableMap};\n+\n+/// A map that cross references each local with the locations where it\n+/// is defined (assigned), used, or dropped. Used during liveness\n+/// computation.\n+crate struct LocalUseMap<'me> {\n+    liveness_map: &'me NllLivenessMap,\n+\n+    /// Head of a linked list of **definitions** of each variable --\n+    /// definition in this context means assignment, e.g. `x` is\n+    /// defined in `x = y` but not `y`; that first def is the head of\n+    /// a linked list that lets you enumerate all places the variable\n+    /// is assigned.\n+    first_def_at: IndexVec<LocalWithRegion, Option<AppearanceIndex>>,\n+\n+    /// Head of a linked list of **uses** of each variable -- use in\n+    /// this context means that the existing value of the variable is\n+    /// read or modified. e.g., `y` is used in `x = y` but not `x`.\n+    first_use_at: IndexVec<LocalWithRegion, Option<AppearanceIndex>>,\n+\n+    /// Head of a linked list of **uses** of each variable -- use in\n+    /// this context means that the existing value of the variable is\n+    /// read or modified. e.g., `y` is used in `x = y` but not `x`.\n+    first_drop_at: IndexVec<LocalWithRegion, Option<AppearanceIndex>>,\n+\n+    appearances: IndexVec<AppearanceIndex, Appearance>,\n+}\n+\n+struct Appearance {\n+    point_index: PointIndex,\n+    next: Option<AppearanceIndex>,\n+}\n+\n+newtype_index!(AppearanceIndex);\n+\n+impl vll::LinkElem for Appearance {\n+    type LinkIndex = AppearanceIndex;\n+\n+    fn next(elem: &Self) -> Option<AppearanceIndex> {\n+        elem.next\n+    }\n+}\n+\n+impl LocalUseMap<'me> {\n+    crate fn build(\n+        liveness_map: &'me NllLivenessMap,\n+        elements: &RegionValueElements,\n+        mir: &Mir<'_>,\n+    ) -> Self {\n+        let nones = IndexVec::from_elem_n(None, liveness_map.num_variables());\n+        let mut local_use_map = LocalUseMap {\n+            liveness_map,\n+            first_def_at: nones.clone(),\n+            first_use_at: nones.clone(),\n+            first_drop_at: nones,\n+            appearances: IndexVec::new(),\n+        };\n+\n+        LocalUseMapBuild {\n+            local_use_map: &mut local_use_map,\n+            elements,\n+        }.visit_mir(mir);\n+\n+        local_use_map\n+    }\n+\n+    crate fn defs(&self, local: LocalWithRegion) -> impl Iterator<Item = PointIndex> + '_ {\n+        vll::iter(self.first_def_at[local], &self.appearances)\n+            .map(move |aa| self.appearances[aa].point_index)\n+    }\n+\n+    crate fn uses(&self, local: LocalWithRegion) -> impl Iterator<Item = PointIndex> + '_ {\n+        vll::iter(self.first_use_at[local], &self.appearances)\n+            .map(move |aa| self.appearances[aa].point_index)\n+    }\n+\n+    crate fn drops(&self, local: LocalWithRegion) -> impl Iterator<Item = PointIndex> + '_ {\n+        vll::iter(self.first_drop_at[local], &self.appearances)\n+            .map(move |aa| self.appearances[aa].point_index)\n+    }\n+}\n+\n+struct LocalUseMapBuild<'me, 'map> {\n+    local_use_map: &'me mut LocalUseMap<'map>,\n+    elements: &'me RegionValueElements,\n+}\n+\n+impl LocalUseMapBuild<'_, '_> {\n+    fn insert_def(&mut self, local: LocalWithRegion, location: Location) {\n+        Self::insert(\n+            self.elements,\n+            &mut self.local_use_map.first_def_at[local],\n+            &mut self.local_use_map.appearances,\n+            location,\n+        );\n+    }\n+\n+    fn insert_use(&mut self, local: LocalWithRegion, location: Location) {\n+        Self::insert(\n+            self.elements,\n+            &mut self.local_use_map.first_use_at[local],\n+            &mut self.local_use_map.appearances,\n+            location,\n+        );\n+    }\n+\n+    fn insert_drop(&mut self, local: LocalWithRegion, location: Location) {\n+        Self::insert(\n+            self.elements,\n+            &mut self.local_use_map.first_drop_at[local],\n+            &mut self.local_use_map.appearances,\n+            location,\n+        );\n+    }\n+\n+    fn insert(\n+        elements: &RegionValueElements,\n+        first_appearance: &mut Option<AppearanceIndex>,\n+        appearances: &mut IndexVec<AppearanceIndex, Appearance>,\n+        location: Location,\n+    ) {\n+        let point_index = elements.point_from_location(location);\n+        let appearance_index = appearances.push(Appearance {\n+            point_index,\n+            next: *first_appearance,\n+        });\n+        *first_appearance = Some(appearance_index);\n+    }\n+}\n+\n+impl Visitor<'tcx> for LocalUseMapBuild<'_, '_> {\n+    fn visit_local(&mut self, &local: &Local, context: PlaceContext<'tcx>, location: Location) {\n+        if let Some(local_with_region) = self.local_use_map.liveness_map.from_local(local) {\n+            match categorize(context) {\n+                Some(DefUse::Def) => self.insert_def(local_with_region, location),\n+                Some(DefUse::Use) => self.insert_use(local_with_region, location),\n+                Some(DefUse::Drop) => self.insert_drop(local_with_region, location),\n+                _ => (),\n+            }\n+        }\n+    }\n+}"}, {"sha": "d6fdd1c849c6922b6616678052c242bf2445c8ab", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness/mod.rs", "status": "modified", "additions": 18, "deletions": 232, "changes": 250, "blob_url": "https://github.com/rust-lang/rust/blob/12f50a6e7502bce9726a5d900780f3d57361b63c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12f50a6e7502bce9726a5d900780f3d57361b63c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fmod.rs?ref=12f50a6e7502bce9726a5d900780f3d57361b63c", "patch": "@@ -8,26 +8,24 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use borrow_check::nll::region_infer::values::RegionValueElements;\n use borrow_check::nll::constraints::ConstraintSet;\n-use borrow_check::nll::type_check::AtLocation;\n-use borrow_check::nll::{LocalWithRegion, NllLivenessMap};\n+use borrow_check::nll::NllLivenessMap;\n use borrow_check::nll::universal_regions::UniversalRegions;\n-use dataflow::move_paths::{HasMoveData, MoveData};\n+use dataflow::move_paths::MoveData;\n use dataflow::MaybeInitializedPlaces;\n-use dataflow::{FlowAtLocation, FlowsAtLocation};\n-use rustc::infer::canonical::QueryRegionConstraint;\n-use rustc::mir::{BasicBlock, Location, Mir};\n-use rustc::traits::query::dropck_outlives::DropckOutlivesResult;\n-use rustc::traits::query::type_op::outlives::DropckOutlives;\n-use rustc::traits::query::type_op::TypeOp;\n-use rustc::ty::{RegionVid, Ty, TypeFoldable};\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use dataflow::FlowAtLocation;\n+use rustc::mir::Mir;\n+use rustc::ty::RegionVid;\n+use rustc_data_structures::fx::FxHashSet;\n use std::rc::Rc;\n-use util::liveness::{LiveVariableMap, LivenessResults};\n \n use super::TypeChecker;\n \n crate mod liveness_map;\n+mod local_use_map;\n+mod point_index_map;\n+mod trace;\n \n /// Combines liveness analysis with initialization analysis to\n /// determine which variables are live at which points, both due to\n@@ -38,40 +36,23 @@ crate mod liveness_map;\n /// NB. This computation requires normalization; therefore, it must be\n /// performed before\n pub(super) fn generate<'gcx, 'tcx>(\n-    cx: &mut TypeChecker<'_, 'gcx, 'tcx>,\n+    typeck: &mut TypeChecker<'_, 'gcx, 'tcx>,\n     mir: &Mir<'tcx>,\n+    elements: &Rc<RegionValueElements>,\n     flow_inits: &mut FlowAtLocation<MaybeInitializedPlaces<'_, 'gcx, 'tcx>>,\n     move_data: &MoveData<'tcx>,\n-) -> (LivenessResults<LocalWithRegion>, NllLivenessMap) {\n+) {\n+    debug!(\"liveness::generate\");\n     let free_regions = {\n-        let borrowck_context = cx.borrowck_context.as_ref().unwrap();\n+        let borrowck_context = typeck.borrowck_context.as_ref().unwrap();\n         regions_that_outlive_free_regions(\n-            cx.infcx.num_region_vars(),\n+            typeck.infcx.num_region_vars(),\n             &borrowck_context.universal_regions,\n             &borrowck_context.constraints.outlives_constraints,\n         )\n     };\n-    let liveness_map = NllLivenessMap::compute(cx.tcx(), &free_regions, mir);\n-    let liveness = LivenessResults::compute(mir, &liveness_map);\n-\n-    // For everything else, it is only live where it is actually used.\n-    if !liveness_map.is_empty() {\n-        let mut generator = TypeLivenessGenerator {\n-            cx,\n-            mir,\n-            liveness: &liveness,\n-            flow_inits,\n-            move_data,\n-            drop_data: FxHashMap(),\n-            map: &liveness_map,\n-        };\n-\n-        for bb in mir.basic_blocks().indices() {\n-            generator.add_liveness_constraints(bb);\n-        }\n-    }\n-\n-    (liveness, liveness_map)\n+    let liveness_map = NllLivenessMap::compute(typeck.tcx(), &free_regions, mir);\n+    trace::trace(typeck, mir, elements, flow_inits, move_data, &liveness_map);\n }\n \n /// Compute all regions that are (currently) known to outlive free\n@@ -112,198 +93,3 @@ fn regions_that_outlive_free_regions(\n     // Return the final set of things we visited.\n     outlives_free_region\n }\n-\n-struct TypeLivenessGenerator<'gen, 'typeck, 'flow, 'gcx, 'tcx>\n-where\n-    'typeck: 'gen,\n-    'flow: 'gen,\n-    'tcx: 'typeck + 'flow,\n-    'gcx: 'tcx,\n-{\n-    cx: &'gen mut TypeChecker<'typeck, 'gcx, 'tcx>,\n-    mir: &'gen Mir<'tcx>,\n-    liveness: &'gen LivenessResults<LocalWithRegion>,\n-    flow_inits: &'gen mut FlowAtLocation<MaybeInitializedPlaces<'flow, 'gcx, 'tcx>>,\n-    move_data: &'gen MoveData<'tcx>,\n-    drop_data: FxHashMap<Ty<'tcx>, DropData<'tcx>>,\n-    map: &'gen NllLivenessMap,\n-}\n-\n-struct DropData<'tcx> {\n-    dropck_result: DropckOutlivesResult<'tcx>,\n-    region_constraint_data: Option<Rc<Vec<QueryRegionConstraint<'tcx>>>>,\n-}\n-\n-impl<'gen, 'typeck, 'flow, 'gcx, 'tcx> TypeLivenessGenerator<'gen, 'typeck, 'flow, 'gcx, 'tcx> {\n-    /// Liveness constraints:\n-    ///\n-    /// > If a variable V is live at point P, then all regions R in the type of V\n-    /// > must include the point P.\n-    fn add_liveness_constraints(&mut self, bb: BasicBlock) {\n-        debug!(\"add_liveness_constraints(bb={:?})\", bb);\n-\n-        self.liveness\n-            .regular\n-            .simulate_block(self.mir, bb, self.map, |location, live_locals| {\n-                for live_local in live_locals.iter() {\n-                    let local = self.map.from_live_var(live_local);\n-                    let live_local_ty = self.mir.local_decls[local].ty;\n-                    Self::push_type_live_constraint(&mut self.cx, live_local_ty, location);\n-                }\n-            });\n-\n-        let mut all_live_locals: Vec<(Location, Vec<LocalWithRegion>)> = vec![];\n-        self.liveness\n-            .drop\n-            .simulate_block(self.mir, bb, self.map, |location, live_locals| {\n-                all_live_locals.push((location, live_locals.iter().collect()));\n-            });\n-        debug!(\n-            \"add_liveness_constraints: all_live_locals={:#?}\",\n-            all_live_locals\n-        );\n-\n-        let terminator_index = self.mir.basic_blocks()[bb].statements.len();\n-        self.flow_inits.reset_to_entry_of(bb);\n-        while let Some((location, live_locals)) = all_live_locals.pop() {\n-            for live_local in live_locals {\n-                debug!(\n-                    \"add_liveness_constraints: location={:?} live_local={:?}\",\n-                    location, live_local\n-                );\n-\n-                if log_enabled!(::log::Level::Debug) {\n-                    self.flow_inits.each_state_bit(|mpi_init| {\n-                        debug!(\n-                            \"add_liveness_constraints: location={:?} initialized={:?}\",\n-                            location,\n-                            &self.flow_inits.operator().move_data().move_paths[mpi_init]\n-                        );\n-                    });\n-                }\n-\n-                let local = self.map.from_live_var(live_local);\n-                let mpi = self.move_data.rev_lookup.find_local(local);\n-                if let Some(initialized_child) = self.flow_inits.has_any_child_of(mpi) {\n-                    debug!(\n-                        \"add_liveness_constraints: mpi={:?} has initialized child {:?}\",\n-                        self.move_data.move_paths[mpi],\n-                        self.move_data.move_paths[initialized_child]\n-                    );\n-\n-                    let local = self.map.from_live_var(live_local);\n-                    let live_local_ty = self.mir.local_decls[local].ty;\n-                    self.add_drop_live_constraint(live_local, live_local_ty, location);\n-                }\n-            }\n-\n-            if location.statement_index == terminator_index {\n-                debug!(\n-                    \"add_liveness_constraints: reconstruct_terminator_effect from {:#?}\",\n-                    location\n-                );\n-                self.flow_inits.reconstruct_terminator_effect(location);\n-            } else {\n-                debug!(\n-                    \"add_liveness_constraints: reconstruct_statement_effect from {:#?}\",\n-                    location\n-                );\n-                self.flow_inits.reconstruct_statement_effect(location);\n-            }\n-            self.flow_inits.apply_local_effect(location);\n-        }\n-    }\n-\n-    /// Some variable with type `live_ty` is \"regular live\" at\n-    /// `location` -- i.e., it may be used later. This means that all\n-    /// regions appearing in the type `live_ty` must be live at\n-    /// `location`.\n-    fn push_type_live_constraint<T>(\n-        cx: &mut TypeChecker<'_, 'gcx, 'tcx>,\n-        value: T,\n-        location: Location,\n-    ) where\n-        T: TypeFoldable<'tcx>,\n-    {\n-        debug!(\n-            \"push_type_live_constraint(live_ty={:?}, location={:?})\",\n-            value, location\n-        );\n-\n-        cx.tcx().for_each_free_region(&value, |live_region| {\n-            if let Some(ref mut borrowck_context) = cx.borrowck_context {\n-                let region_vid = borrowck_context\n-                    .universal_regions\n-                    .to_region_vid(live_region);\n-                borrowck_context\n-                    .constraints\n-                    .liveness_constraints\n-                    .add_element(region_vid, location);\n-\n-                if let Some(all_facts) = borrowck_context.all_facts {\n-                    let start_index = borrowck_context.location_table.start_index(location);\n-                    all_facts.region_live_at.push((region_vid, start_index));\n-\n-                    let mid_index = borrowck_context.location_table.mid_index(location);\n-                    all_facts.region_live_at.push((region_vid, mid_index));\n-                }\n-            }\n-        });\n-    }\n-\n-    /// Some variable with type `live_ty` is \"drop live\" at `location`\n-    /// -- i.e., it may be dropped later. This means that *some* of\n-    /// the regions in its type must be live at `location`. The\n-    /// precise set will depend on the dropck constraints, and in\n-    /// particular this takes `#[may_dangle]` into account.\n-    fn add_drop_live_constraint(\n-        &mut self,\n-        dropped_local: LocalWithRegion,\n-        dropped_ty: Ty<'tcx>,\n-        location: Location,\n-    ) {\n-        debug!(\n-            \"add_drop_live_constraint(dropped_local={:?}, dropped_ty={:?}, location={:?})\",\n-            dropped_local, dropped_ty, location\n-        );\n-\n-        let drop_data = self.drop_data.entry(dropped_ty).or_insert_with({\n-            let cx = &mut self.cx;\n-            move || Self::compute_drop_data(cx, dropped_ty)\n-        });\n-\n-        if let Some(data) = &drop_data.region_constraint_data {\n-            self.cx.push_region_constraints(location.boring(), data);\n-        }\n-\n-        drop_data.dropck_result.report_overflows(\n-            self.cx.infcx.tcx,\n-            self.mir.source_info(location).span,\n-            dropped_ty,\n-        );\n-\n-        // All things in the `outlives` array may be touched by\n-        // the destructor and must be live at this point.\n-        for &kind in &drop_data.dropck_result.kinds {\n-            Self::push_type_live_constraint(&mut self.cx, kind, location);\n-        }\n-    }\n-\n-    fn compute_drop_data(\n-        cx: &mut TypeChecker<'_, 'gcx, 'tcx>,\n-        dropped_ty: Ty<'tcx>,\n-    ) -> DropData<'tcx> {\n-        debug!(\"compute_drop_data(dropped_ty={:?})\", dropped_ty,);\n-\n-        let param_env = cx.param_env;\n-        let (dropck_result, region_constraint_data) = param_env\n-            .and(DropckOutlives::new(dropped_ty))\n-            .fully_perform(cx.infcx)\n-            .unwrap();\n-\n-        DropData {\n-            dropck_result,\n-            region_constraint_data,\n-        }\n-    }\n-}"}, {"sha": "c2c21aa0d8de9393a9b76c83b0b2ab4058b43a37", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness/point_index_map.rs", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/12f50a6e7502bce9726a5d900780f3d57361b63c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fpoint_index_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12f50a6e7502bce9726a5d900780f3d57361b63c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fpoint_index_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Fpoint_index_map.rs?ref=12f50a6e7502bce9726a5d900780f3d57361b63c", "patch": "@@ -0,0 +1,78 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use borrow_check::nll::region_infer::values::PointIndex;\n+use borrow_check::nll::region_infer::values::RegionValueElements;\n+use rustc::mir::{BasicBlock, Location, Mir};\n+use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n+use std::rc::Rc;\n+\n+/// A little data structure that makes it more efficient to find the\n+/// predecessors of each point.\n+crate struct PointIndexMap<'me, 'tcx> {\n+    elements: &'me Rc<RegionValueElements>,\n+    mir: &'me Mir<'tcx>,\n+    basic_block_heads: IndexVec<PointIndex, Option<BasicBlock>>,\n+}\n+\n+impl PointIndexMap<'m, 'tcx> {\n+    crate fn new(elements: &'m Rc<RegionValueElements>, mir: &'m Mir<'tcx>) -> Self {\n+        let mut basic_block_heads = IndexVec::from_elem_n(None, elements.num_points());\n+\n+        for (bb, first_point) in elements.head_indices() {\n+            basic_block_heads[first_point] = Some(bb);\n+        }\n+\n+        PointIndexMap {\n+            elements,\n+            mir,\n+            basic_block_heads,\n+        }\n+    }\n+\n+    crate fn num_points(&self) -> usize {\n+        self.elements.num_points()\n+    }\n+\n+    crate fn location_of(&self, index: PointIndex) -> Location {\n+        let mut statement_index = 0;\n+\n+        for &opt_bb in self.basic_block_heads.raw[..= index.index()].iter().rev() {\n+            if let Some(block) = opt_bb {\n+                return Location { block, statement_index };\n+            }\n+\n+            statement_index += 1;\n+        }\n+\n+        bug!(\"did not find basic block as expected for index = {:?}\", index)\n+    }\n+\n+    crate fn push_predecessors(&self, index: PointIndex, stack: &mut Vec<PointIndex>) {\n+        match self.basic_block_heads[index] {\n+            // If this is a basic block head, then the predecessors are\n+            // the the terminators of other basic blocks\n+            Some(bb_head) => {\n+                stack.extend(\n+                    self.mir\n+                        .predecessors_for(bb_head)\n+                        .iter()\n+                        .map(|&pred_bb| self.mir.terminator_loc(pred_bb))\n+                        .map(|pred_loc| self.elements.point_from_location(pred_loc)),\n+                );\n+            }\n+\n+            // Otherwise, the pred is just the previous statement\n+            None => {\n+                stack.push(PointIndex::new(index.index() - 1));\n+            }\n+        }\n+    }\n+}"}, {"sha": "e8d22827117d1edb58cd488dc3fd96e3a065187e", "filename": "src/librustc_mir/borrow_check/nll/type_check/liveness/trace.rs", "status": "added", "additions": 544, "deletions": 0, "changes": 544, "blob_url": "https://github.com/rust-lang/rust/blob/12f50a6e7502bce9726a5d900780f3d57361b63c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Ftrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12f50a6e7502bce9726a5d900780f3d57361b63c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Ftrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fliveness%2Ftrace.rs?ref=12f50a6e7502bce9726a5d900780f3d57361b63c", "patch": "@@ -0,0 +1,544 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use borrow_check::nll::region_infer::values::{self, PointIndex, RegionValueElements};\n+use borrow_check::nll::type_check::liveness::liveness_map::{LocalWithRegion, NllLivenessMap};\n+use borrow_check::nll::type_check::liveness::local_use_map::LocalUseMap;\n+use borrow_check::nll::type_check::liveness::point_index_map::PointIndexMap;\n+use borrow_check::nll::type_check::AtLocation;\n+use borrow_check::nll::type_check::TypeChecker;\n+use dataflow::move_paths::indexes::MovePathIndex;\n+use dataflow::move_paths::MoveData;\n+use dataflow::{FlowAtLocation, FlowsAtLocation, MaybeInitializedPlaces};\n+use rustc::infer::canonical::QueryRegionConstraint;\n+use rustc::mir::{BasicBlock, Local, Location, Mir};\n+use rustc::traits::query::dropck_outlives::DropckOutlivesResult;\n+use rustc::traits::query::type_op::outlives::DropckOutlives;\n+use rustc::traits::query::type_op::TypeOp;\n+use rustc::ty::{Ty, TypeFoldable};\n+use rustc_data_structures::bitvec::BitArray;\n+use rustc_data_structures::fx::FxHashMap;\n+use std::rc::Rc;\n+use util::liveness::LiveVariableMap;\n+\n+pub(super) fn trace(\n+    typeck: &mut TypeChecker<'_, 'gcx, 'tcx>,\n+    mir: &Mir<'tcx>,\n+    elements: &Rc<RegionValueElements>,\n+    flow_inits: &mut FlowAtLocation<MaybeInitializedPlaces<'_, 'gcx, 'tcx>>,\n+    move_data: &MoveData<'tcx>,\n+    liveness_map: &NllLivenessMap,\n+) {\n+    debug!(\"trace()\");\n+\n+    if liveness_map.is_empty() {\n+        return;\n+    }\n+\n+    let local_use_map = &LocalUseMap::build(liveness_map, elements, mir);\n+    let point_index_map = &PointIndexMap::new(elements, mir);\n+\n+    let cx = LivenessContext {\n+        typeck,\n+        mir,\n+        flow_inits,\n+        elements,\n+        local_use_map,\n+        move_data,\n+        liveness_map,\n+        point_index_map,\n+        drop_data: FxHashMap::default(),\n+    };\n+\n+    LivenessResults::new(cx).compute_for_all_locals();\n+}\n+\n+/// Contextual state for the type-liveness generator.\n+struct LivenessContext<'me, 'typeck, 'flow, 'gcx, 'tcx>\n+where\n+    'typeck: 'me,\n+    'flow: 'me,\n+    'tcx: 'typeck + 'flow,\n+    'gcx: 'tcx,\n+{\n+    /// Current type-checker, giving us our inference context etc.\n+    typeck: &'me mut TypeChecker<'typeck, 'gcx, 'tcx>,\n+\n+    /// Defines the `PointIndex` mapping\n+    elements: &'me RegionValueElements,\n+\n+    /// MIR we are analyzing.\n+    mir: &'me Mir<'tcx>,\n+\n+    /// Mapping to/from the various indices used for initialization tracking.\n+    move_data: &'me MoveData<'tcx>,\n+\n+    /// Cache for the results of `dropck_outlives` query.\n+    drop_data: FxHashMap<Ty<'tcx>, DropData<'tcx>>,\n+\n+    /// Results of dataflow tracking which variables (and paths) have been\n+    /// initialized.\n+    flow_inits: &'me mut FlowAtLocation<MaybeInitializedPlaces<'flow, 'gcx, 'tcx>>,\n+\n+    /// Index indicating where each variable is assigned, used, or\n+    /// dropped.\n+    local_use_map: &'me LocalUseMap<'me>,\n+\n+    point_index_map: &'me PointIndexMap<'me, 'tcx>,\n+\n+    /// Map tracking which variables need liveness computation.\n+    liveness_map: &'me NllLivenessMap,\n+}\n+\n+struct DropData<'tcx> {\n+    dropck_result: DropckOutlivesResult<'tcx>,\n+    region_constraint_data: Option<Rc<Vec<QueryRegionConstraint<'tcx>>>>,\n+}\n+\n+struct LivenessResults<'me, 'typeck, 'flow, 'gcx, 'tcx>\n+where\n+    'typeck: 'me,\n+    'flow: 'me,\n+    'tcx: 'typeck + 'flow,\n+    'gcx: 'tcx,\n+{\n+    cx: LivenessContext<'me, 'typeck, 'flow, 'gcx, 'tcx>,\n+\n+    /// Set of points that define the current local.\n+    defs: BitArray<PointIndex>,\n+\n+    /// Points where the current variable is \"use live\" -- meaning\n+    /// that there is a future \"full use\" that may use its value.\n+    use_live_at: BitArray<PointIndex>,\n+\n+    /// Points where the current variable is \"drop live\" -- meaning\n+    /// that there is no future \"full use\" that may use its value, but\n+    /// there is a future drop.\n+    drop_live_at: BitArray<PointIndex>,\n+\n+    /// Locations where drops may occur.\n+    drop_locations: Vec<Location>,\n+\n+    /// Stack used when doing (reverse) DFS.\n+    stack: Vec<PointIndex>,\n+}\n+\n+impl LivenessResults<'me, 'typeck, 'flow, 'gcx, 'tcx> {\n+    fn new(cx: LivenessContext<'me, 'typeck, 'flow, 'gcx, 'tcx>) -> Self {\n+        let num_points = cx.point_index_map.num_points();\n+        LivenessResults {\n+            cx,\n+            defs: BitArray::new(num_points),\n+            use_live_at: BitArray::new(num_points),\n+            drop_live_at: BitArray::new(num_points),\n+            drop_locations: vec![],\n+            stack: vec![],\n+        }\n+    }\n+\n+    fn compute_for_all_locals(&mut self) {\n+        for live_local in self.cx.liveness_map.to_local.indices() {\n+            let local = self.cx.liveness_map.from_live_var(live_local);\n+            debug!(\"local={:?} live_local={:?}\", local, live_local);\n+\n+            self.reset_local_state();\n+            self.add_defs_for(live_local);\n+            self.compute_use_live_points_for(live_local);\n+            self.compute_drop_live_points_for(live_local);\n+\n+            let local_ty = self.cx.mir.local_decls[local].ty;\n+\n+            if !self.use_live_at.is_empty() {\n+                self.cx.add_use_live_facts_for(local_ty, &self.use_live_at);\n+            }\n+\n+            if !self.drop_live_at.is_empty() {\n+                self.cx.add_drop_live_facts_for(\n+                    local,\n+                    local_ty,\n+                    &self.drop_locations,\n+                    &self.drop_live_at,\n+                );\n+            }\n+        }\n+    }\n+\n+    /// Clear the value of fields that are \"per local variable\".\n+    fn reset_local_state(&mut self) {\n+        self.defs.clear();\n+        self.use_live_at.clear();\n+        self.drop_live_at.clear();\n+        self.drop_locations.clear();\n+        assert!(self.stack.is_empty());\n+    }\n+\n+    /// Adds the definitions of `local` into `self.defs`.\n+    fn add_defs_for(&mut self, live_local: LocalWithRegion) {\n+        for def in self.cx.local_use_map.defs(live_local) {\n+            debug!(\"- defined at {:?}\", def);\n+            self.defs.insert(def);\n+        }\n+    }\n+\n+    /// Compute all points where local is \"use live\" -- meaning its\n+    /// current value may be used later (except by a drop). This is\n+    /// done by walking backwards from each use of `live_local` until we\n+    /// find a `def` of local.\n+    ///\n+    /// Requires `add_defs_for(live_local)` to have been executed.\n+    fn compute_use_live_points_for(&mut self, live_local: LocalWithRegion) {\n+        debug!(\"compute_use_live_points_for(live_local={:?})\", live_local);\n+\n+        self.stack.extend(self.cx.local_use_map.uses(live_local));\n+        while let Some(p) = self.stack.pop() {\n+            if self.defs.contains(p) {\n+                continue;\n+            }\n+\n+            if self.use_live_at.insert(p) {\n+                self.cx\n+                    .point_index_map\n+                    .push_predecessors(p, &mut self.stack)\n+            }\n+        }\n+    }\n+\n+    /// Compute all points where local is \"drop live\" -- meaning its\n+    /// current value may be dropped later (but not used). This is\n+    /// done by iterating over the drops of `local` where `local` (or\n+    /// some subpart of `local`) is initialized. For each such drop,\n+    /// we walk backwards until we find a point where `local` is\n+    /// either defined or use-live.\n+    ///\n+    /// Requires `compute_use_live_points_for` and `add_defs_for` to\n+    /// have been executed.\n+    fn compute_drop_live_points_for(&mut self, live_local: LocalWithRegion) {\n+        debug!(\"compute_drop_live_points_for(live_local={:?})\", live_local);\n+\n+        let local = self.cx.liveness_map.from_live_var(live_local);\n+        let mpi = self.cx.move_data.rev_lookup.find_local(local);\n+        debug!(\"compute_drop_live_points_for: mpi = {:?}\", mpi);\n+\n+        // Find the drops where `local` is initialized.\n+        for drop_point in self.cx.local_use_map.drops(live_local) {\n+            let location = self.cx.point_index_map.location_of(drop_point);\n+            debug_assert_eq!(self.cx.mir.terminator_loc(location.block), location,);\n+\n+            if self.cx.initialized_at_terminator(location.block, mpi) {\n+                if self.drop_live_at.insert(drop_point) {\n+                    self.drop_locations.push(location);\n+                    self.stack.push(drop_point);\n+                }\n+            }\n+        }\n+\n+        debug!(\n+            \"compute_drop_live_points_for: drop_locations={:?}\",\n+            self.drop_locations\n+        );\n+\n+        // Reverse DFS. But for drops, we do it a bit differently.\n+        // The stack only ever stores *terminators of blocks*. Within\n+        // a block, we walk back the statements in an inner loop.\n+        'next_block: while let Some(term_point) = self.stack.pop() {\n+            self.compute_drop_live_points_for_block(mpi, term_point);\n+        }\n+    }\n+\n+    /// Executes one iteration of the drop-live analysis loop.\n+    ///\n+    /// The parameter `mpi` is the `MovePathIndex` of the local variable\n+    /// we are currently analyzing.\n+    ///\n+    /// The point `term_point` represents some terminator in the MIR,\n+    /// where the local `mpi` is drop-live on entry to that terminator.\n+    ///\n+    /// This method adds all drop-live points within the block and --\n+    /// where applicable -- pushes the terminators of preceding blocks\n+    /// onto `self.stack`.\n+    fn compute_drop_live_points_for_block(&mut self, mpi: MovePathIndex, term_point: PointIndex) {\n+        debug!(\n+            \"compute_drop_live_points_for_block(mpi={:?}, term_point={:?})\",\n+            self.cx.move_data.move_paths[mpi].place,\n+            self.cx.point_index_map.location_of(term_point),\n+        );\n+\n+        // We are only invoked with terminators where `mpi` is\n+        // drop-live on entry.\n+        debug_assert!(self.drop_live_at.contains(term_point));\n+\n+        // Otherwise, scan backwards through the statements in the\n+        // block.  One of them may be either a definition or use\n+        // live point.\n+        let term_location = self.cx.elements.to_location(term_point);\n+        debug_assert_eq!(\n+            self.cx.mir.terminator_loc(term_location.block),\n+            term_location,\n+        );\n+        let block = term_location.block;\n+        let entry_point = self.cx.elements.entry_point(term_location.block);\n+        for p in (entry_point..term_point).rev() {\n+            debug!(\n+                \"compute_drop_live_points_for_block: p = {:?}\",\n+                self.cx.point_index_map.location_of(p),\n+            );\n+\n+            if self.defs.contains(p) {\n+                debug!(\"compute_drop_live_points_for_block: def site\");\n+                return;\n+            }\n+\n+            if self.use_live_at.contains(p) {\n+                debug!(\"compute_drop_live_points_for_block: use-live at {:?}\", p);\n+                return;\n+            }\n+\n+            if !self.drop_live_at.insert(p) {\n+                debug!(\"compute_drop_live_points_for_block: already drop-live\");\n+                return;\n+            }\n+        }\n+\n+        for &pred_block in self.cx.mir.predecessors_for(block).iter() {\n+            debug!(\n+                \"compute_drop_live_points_for_block: pred_block = {:?}\",\n+                pred_block,\n+            );\n+\n+            // Check whether the variable is (at least partially)\n+            // initialized at the exit of this predecessor. If so, we\n+            // want to enqueue it on our list. If not, go check the\n+            // next block.\n+            //\n+            // Note that we only need to check whether `live_local`\n+            // became de-initialized at basic block boundaries. If it\n+            // were to become de-initialized within the block, that\n+            // would have been a \"use-live\" transition in the earlier\n+            // loop, and we'd have returned already.\n+            //\n+            // NB. It's possible that the pred-block ends in a call\n+            // which stores to the variable; in that case, the\n+            // variable may be uninitialized \"at exit\" because this\n+            // call only considers the *unconditional effects* of the\n+            // terminator. *But*, in that case, the terminator is also\n+            // a *definition* of the variable, in which case we want\n+            // to stop the search anyhow. (But see Note 1 below.)\n+            if !self.cx.initialized_at_exit(pred_block, mpi) {\n+                debug!(\"compute_drop_live_points_for_block: not initialized\");\n+                continue;\n+            }\n+\n+            let pred_term_loc = self.cx.mir.terminator_loc(pred_block);\n+            let pred_term_point = self.cx.elements.point_from_location(pred_term_loc);\n+\n+            // If the terminator of this predecessor either *assigns*\n+            // our value or is a \"normal use\", then stop.\n+            if self.defs.contains(pred_term_point) {\n+                debug!(\n+                    \"compute_drop_live_points_for_block: defined at {:?}\",\n+                    pred_term_loc\n+                );\n+                continue;\n+            }\n+\n+            if self.use_live_at.contains(pred_term_point) {\n+                debug!(\n+                    \"compute_drop_live_points_for_block: use-live at {:?}\",\n+                    pred_term_loc\n+                );\n+                continue;\n+            }\n+\n+            // Otherwise, we are drop-live on entry to the terminator,\n+            // so walk it.\n+            if self.drop_live_at.insert(pred_term_point) {\n+                debug!(\"compute_drop_live_points_for_block: pushed to stack\");\n+                self.stack.push(pred_term_point);\n+            }\n+        }\n+\n+        // Note 1. There is a weird scenario that you might imagine\n+        // being problematic here, but which actually cannot happen.\n+        // The problem would be if we had a variable that *is* initialized\n+        // (but dead) on entry to the terminator, and where the current value\n+        // will be dropped in the case of unwind. In that case, we ought to\n+        // consider `X` to be drop-live in between the last use and call.\n+        // Here is the example:\n+        //\n+        // ```\n+        // BB0 {\n+        //   X = ...\n+        //   use(X); // last use\n+        //   ...     // <-- X ought to be drop-live here\n+        //   X = call() goto BB1 unwind BB2\n+        // }\n+        //\n+        // BB1 {\n+        //   DROP(X)\n+        // }\n+        //\n+        // BB2 {\n+        //   DROP(X)\n+        // }\n+        // ```\n+        //\n+        // However, the current code would, when walking back from BB2,\n+        // simply stop and never explore BB0. This seems bad! But it turns\n+        // out this code is flawed anyway -- note that the existing value of\n+        // `X` would leak in the case where unwinding did *not* occur.\n+        //\n+        // What we *actually* generate is a store to a temporary\n+        // for the call (`TMP = call()...`) and then a\n+        // `DropAndReplace` to swap that with `X`\n+        // (`DropAndReplace` has very particular semantics).\n+    }\n+}\n+\n+impl LivenessContext<'_, '_, '_, '_, 'tcx> {\n+    /// True if the local variable (or some part of it) is initialized in\n+    /// the terminator of `block`. We need to check this to determine if a\n+    /// DROP of some local variable will have an effect -- note that\n+    /// drops, as they may unwind, are always terminators.\n+    fn initialized_at_terminator(&mut self, block: BasicBlock, mpi: MovePathIndex) -> bool {\n+        // Compute the set of initialized paths at terminator of block\n+        // by resetting to the start of the block and then applying\n+        // the effects of all statements. This is the only way to get\n+        // \"just ahead\" of a terminator.\n+        self.flow_inits.reset_to_entry_of(block);\n+        for statement_index in 0..self.mir[block].statements.len() {\n+            let location = Location {\n+                block,\n+                statement_index,\n+            };\n+            self.flow_inits.reconstruct_statement_effect(location);\n+            self.flow_inits.apply_local_effect(location);\n+        }\n+\n+        self.flow_inits.has_any_child_of(mpi).is_some()\n+    }\n+\n+    /// True if the path `mpi` (or some part of it) is initialized at\n+    /// the exit of `block`.\n+    ///\n+    /// **Warning:** Does not account for the result of `Call`\n+    /// instructions.\n+    fn initialized_at_exit(&mut self, block: BasicBlock, mpi: MovePathIndex) -> bool {\n+        self.flow_inits.reset_to_exit_of(block);\n+        self.flow_inits.has_any_child_of(mpi).is_some()\n+    }\n+\n+    /// Store the result that all regions in `value` are live for the\n+    /// points `live_at`.\n+    fn add_use_live_facts_for(\n+        &mut self,\n+        value: impl TypeFoldable<'tcx>,\n+        live_at: &BitArray<PointIndex>,\n+    ) {\n+        debug!(\"add_use_live_facts_for(value={:?})\", value);\n+\n+        Self::make_all_regions_live(self.elements, &mut self.typeck, value, live_at)\n+    }\n+\n+    /// Some variable with type `live_ty` is \"drop live\" at `location`\n+    /// -- i.e., it may be dropped later. This means that *some* of\n+    /// the regions in its type must be live at `location`. The\n+    /// precise set will depend on the dropck constraints, and in\n+    /// particular this takes `#[may_dangle]` into account.\n+    fn add_drop_live_facts_for(\n+        &mut self,\n+        dropped_local: Local,\n+        dropped_ty: Ty<'tcx>,\n+        drop_locations: &[Location],\n+        live_at: &BitArray<PointIndex>,\n+    ) {\n+        debug!(\n+            \"add_drop_live_constraint(\\\n+             dropped_local={:?}, \\\n+             dropped_ty={:?}, \\\n+             drop_locations={:?}, \\\n+             live_at={:?})\",\n+            dropped_local,\n+            dropped_ty,\n+            drop_locations,\n+            values::location_set_str(self.elements, live_at.iter()),\n+        );\n+\n+        let drop_data = self.drop_data.entry(dropped_ty).or_insert_with({\n+            let typeck = &mut self.typeck;\n+            move || Self::compute_drop_data(typeck, dropped_ty)\n+        });\n+\n+        if let Some(data) = &drop_data.region_constraint_data {\n+            for &drop_location in drop_locations {\n+                self.typeck\n+                    .push_region_constraints(drop_location.boring(), data);\n+            }\n+        }\n+\n+        drop_data.dropck_result.report_overflows(\n+            self.typeck.infcx.tcx,\n+            self.mir.source_info(*drop_locations.first().unwrap()).span,\n+            dropped_ty,\n+        );\n+\n+        // All things in the `outlives` array may be touched by\n+        // the destructor and must be live at this point.\n+        for &kind in &drop_data.dropck_result.kinds {\n+            Self::make_all_regions_live(self.elements, &mut self.typeck, kind, live_at);\n+        }\n+    }\n+\n+    fn make_all_regions_live(\n+        elements: &RegionValueElements,\n+        typeck: &mut TypeChecker<'_, '_, 'tcx>,\n+        value: impl TypeFoldable<'tcx>,\n+        live_at: &BitArray<PointIndex>,\n+    ) {\n+        debug!(\"make_all_regions_live(value={:?})\", value);\n+        debug!(\n+            \"make_all_regions_live: live_at={}\",\n+            values::location_set_str(elements, live_at.iter()),\n+        );\n+\n+        let tcx = typeck.tcx();\n+        tcx.for_each_free_region(&value, |live_region| {\n+            let borrowck_context = typeck.borrowck_context.as_mut().unwrap();\n+            let live_region_vid = borrowck_context\n+                .universal_regions\n+                .to_region_vid(live_region);\n+            borrowck_context\n+                .constraints\n+                .liveness_constraints\n+                .add_elements(live_region_vid, live_at);\n+\n+            if let Some(_) = borrowck_context.all_facts {\n+                bug!(\"polonius liveness facts not implemented yet\")\n+            }\n+        });\n+    }\n+\n+    fn compute_drop_data(\n+        typeck: &mut TypeChecker<'_, 'gcx, 'tcx>,\n+        dropped_ty: Ty<'tcx>,\n+    ) -> DropData<'tcx> {\n+        debug!(\"compute_drop_data(dropped_ty={:?})\", dropped_ty,);\n+\n+        let param_env = typeck.param_env;\n+        let (dropck_result, region_constraint_data) = param_env\n+            .and(DropckOutlives::new(dropped_ty))\n+            .fully_perform(typeck.infcx)\n+            .unwrap();\n+\n+        DropData {\n+            dropck_result,\n+            region_constraint_data,\n+        }\n+    }\n+}"}, {"sha": "3a5857f775fa458b1be915c99cf2130a1fb5aee2", "filename": "src/librustc_mir/borrow_check/nll/type_check/mod.rs", "status": "modified", "additions": 4, "deletions": 11, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/12f50a6e7502bce9726a5d900780f3d57361b63c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12f50a6e7502bce9726a5d900780f3d57361b63c/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Ftype_check%2Fmod.rs?ref=12f50a6e7502bce9726a5d900780f3d57361b63c", "patch": "@@ -18,9 +18,7 @@ use borrow_check::nll::facts::AllFacts;\n use borrow_check::nll::region_infer::values::{LivenessValues, RegionValueElements};\n use borrow_check::nll::region_infer::{ClosureRegionRequirementsExt, TypeTest};\n use borrow_check::nll::type_check::free_region_relations::{CreateResult, UniversalRegionRelations};\n-use borrow_check::nll::type_check::liveness::liveness_map::NllLivenessMap;\n use borrow_check::nll::universal_regions::UniversalRegions;\n-use borrow_check::nll::LocalWithRegion;\n use borrow_check::nll::ToRegionVid;\n use dataflow::move_paths::MoveData;\n use dataflow::FlowAtLocation;\n@@ -43,7 +41,6 @@ use std::fmt;\n use std::rc::Rc;\n use syntax_pos::{Span, DUMMY_SP};\n use transform::{MirPass, MirSource};\n-use util::liveness::LivenessResults;\n \n use rustc_data_structures::fx::FxHashSet;\n use rustc_data_structures::indexed_vec::Idx;\n@@ -143,7 +140,7 @@ pub(crate) fn type_check<'gcx, 'tcx>(\n         all_facts,\n     );\n \n-    let (liveness, liveness_map) = {\n+    {\n         let mut borrowck_context = BorrowCheckContext {\n             universal_regions,\n             location_table,\n@@ -169,16 +166,14 @@ pub(crate) fn type_check<'gcx, 'tcx>(\n                     &universal_region_relations,\n                     &normalized_inputs_and_output,\n                 );\n-                liveness::generate(cx, mir, flow_inits, move_data)\n+                liveness::generate(cx, mir, elements, flow_inits, move_data);\n             },\n-        )\n-    };\n+        );\n+    }\n \n     MirTypeckResults {\n         constraints,\n         universal_region_relations,\n-        liveness,\n-        liveness_map,\n     }\n }\n \n@@ -672,8 +667,6 @@ struct BorrowCheckContext<'a, 'tcx: 'a> {\n crate struct MirTypeckResults<'tcx> {\n     crate constraints: MirTypeckRegionConstraints<'tcx>,\n     crate universal_region_relations: Rc<UniversalRegionRelations<'tcx>>,\n-    crate liveness: LivenessResults<LocalWithRegion>,\n-    crate liveness_map: NllLivenessMap,\n }\n \n /// A collection of region constraints that must be satisfied for the"}, {"sha": "d97c0c9b430197a53b800cfc2e6f573b15e9b6d8", "filename": "src/librustc_mir/dataflow/at_location.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/12f50a6e7502bce9726a5d900780f3d57361b63c/src%2Flibrustc_mir%2Fdataflow%2Fat_location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12f50a6e7502bce9726a5d900780f3d57361b63c/src%2Flibrustc_mir%2Fdataflow%2Fat_location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fdataflow%2Fat_location.rs?ref=12f50a6e7502bce9726a5d900780f3d57361b63c", "patch": "@@ -28,6 +28,15 @@ pub trait FlowsAtLocation {\n     /// Reset the state bitvector to represent the entry to block `bb`.\n     fn reset_to_entry_of(&mut self, bb: BasicBlock);\n \n+    /// Reset the state bitvector to represent the exit of the\n+    /// terminator of block `bb`.\n+    ///\n+    /// **Important:** In the case of a `Call` terminator, these\n+    /// effects do *not* include the result of storing the destination\n+    /// of the call, since that is edge-dependent (in other words, the\n+    /// effects don't apply to the unwind edge).\n+    fn reset_to_exit_of(&mut self, bb: BasicBlock);\n+\n     /// Build gen + kill sets for statement at `loc`.\n     ///\n     /// Note that invoking this method alone does not change the\n@@ -142,6 +151,12 @@ impl<BD> FlowsAtLocation for FlowAtLocation<BD>\n         self.curr_state.overwrite(self.base_results.sets().on_entry_set_for(bb.index()));\n     }\n \n+    fn reset_to_exit_of(&mut self, bb: BasicBlock) {\n+        self.reset_to_entry_of(bb);\n+        self.curr_state.union(self.base_results.sets().gen_set_for(bb.index()));\n+        self.curr_state.subtract(self.base_results.sets().kill_set_for(bb.index()));\n+    }\n+\n     fn reconstruct_statement_effect(&mut self, loc: Location) {\n         self.stmt_gen.clear();\n         self.stmt_kill.clear();"}, {"sha": "808114f3fa9b4f64e900a615a7a27d118107fe17", "filename": "src/test/ui/nll/maybe-initialized-drop-implicit-fragment-drop.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/12f50a6e7502bce9726a5d900780f3d57361b63c/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-implicit-fragment-drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/12f50a6e7502bce9726a5d900780f3d57361b63c/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-implicit-fragment-drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-implicit-fragment-drop.rs?ref=12f50a6e7502bce9726a5d900780f3d57361b63c", "patch": "@@ -8,10 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//compile-flags: -Z emit-end-regions -Zborrowck=mir\n-\n-\n #![allow(warnings)]\n+#![feature(nll)]\n \n struct Wrap<'p> { p: &'p mut i32 }\n "}, {"sha": "6fc26d502d30de8b7edea00c4c60ab90c8c2c4ea", "filename": "src/test/ui/nll/maybe-initialized-drop-implicit-fragment-drop.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/12f50a6e7502bce9726a5d900780f3d57361b63c/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-implicit-fragment-drop.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/12f50a6e7502bce9726a5d900780f3d57361b63c/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-implicit-fragment-drop.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fmaybe-initialized-drop-implicit-fragment-drop.stderr?ref=12f50a6e7502bce9726a5d900780f3d57361b63c", "patch": "@@ -1,5 +1,5 @@\n error[E0506]: cannot assign to `x` because it is borrowed\n-  --> $DIR/maybe-initialized-drop-implicit-fragment-drop.rs:32:5\n+  --> $DIR/maybe-initialized-drop-implicit-fragment-drop.rs:30:5\n    |\n LL |     let wrap = Wrap { p: &mut x };\n    |                          ------ borrow of `x` occurs here"}]}