{"sha": "b14785d3d0e3093983f6d6e266b754e1b536da10", "node_id": "MDY6Q29tbWl0NzI0NzEyOmIxNDc4NWQzZDBlMzA5Mzk4M2Y2ZDZlMjY2Yjc1NGUxYjUzNmRhMTA=", "commit": {"author": {"name": "Seo Sanghyeon", "email": "sanxiyn@gmail.com", "date": "2017-01-01T03:40:10Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-01-01T03:40:10Z"}, "message": "Merge branch 'master' into sparc64", "tree": {"sha": "37e6e5bb194c6f1a6721d928c63ba4c06b9de126", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/37e6e5bb194c6f1a6721d928c63ba4c06b9de126"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b14785d3d0e3093983f6d6e266b754e1b536da10", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b14785d3d0e3093983f6d6e266b754e1b536da10", "html_url": "https://github.com/rust-lang/rust/commit/b14785d3d0e3093983f6d6e266b754e1b536da10", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b14785d3d0e3093983f6d6e266b754e1b536da10/comments", "author": {"login": "sanxiyn", "id": 45249, "node_id": "MDQ6VXNlcjQ1MjQ5", "avatar_url": "https://avatars.githubusercontent.com/u/45249?v=4", "gravatar_id": "", "url": "https://api.github.com/users/sanxiyn", "html_url": "https://github.com/sanxiyn", "followers_url": "https://api.github.com/users/sanxiyn/followers", "following_url": "https://api.github.com/users/sanxiyn/following{/other_user}", "gists_url": "https://api.github.com/users/sanxiyn/gists{/gist_id}", "starred_url": "https://api.github.com/users/sanxiyn/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/sanxiyn/subscriptions", "organizations_url": "https://api.github.com/users/sanxiyn/orgs", "repos_url": "https://api.github.com/users/sanxiyn/repos", "events_url": "https://api.github.com/users/sanxiyn/events{/privacy}", "received_events_url": "https://api.github.com/users/sanxiyn/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "728ec85e9af04784263acaf2993b2dbf4c07519f", "url": "https://api.github.com/repos/rust-lang/rust/commits/728ec85e9af04784263acaf2993b2dbf4c07519f", "html_url": "https://github.com/rust-lang/rust/commit/728ec85e9af04784263acaf2993b2dbf4c07519f"}, {"sha": "07412c8d253121ee912014021a1dd7308b7154a1", "url": "https://api.github.com/repos/rust-lang/rust/commits/07412c8d253121ee912014021a1dd7308b7154a1", "html_url": "https://github.com/rust-lang/rust/commit/07412c8d253121ee912014021a1dd7308b7154a1"}], "stats": {"total": 7222, "additions": 4826, "deletions": 2396}, "files": [{"sha": "26cabf92bdac81d98ced0ba6cee456f199092458", "filename": ".travis.yml", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/.travis.yml", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/.travis.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.travis.yml?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -19,12 +19,14 @@ matrix:\n     - env: IMAGE=i686-gnu-nopt\n     - env: IMAGE=x86_64-freebsd\n     - env: IMAGE=x86_64-gnu\n-    - env: IMAGE=x86_64-gnu-cargotest\n+    - env: IMAGE=x86_64-gnu-full-bootstrap\n+    - env: IMAGE=x86_64-gnu-aux\n     - env: IMAGE=x86_64-gnu-debug\n     - env: IMAGE=x86_64-gnu-nopt\n     - env: IMAGE=x86_64-gnu-make\n     - env: IMAGE=x86_64-gnu-llvm-3.7 ALLOW_PR=1 RUST_BACKTRACE=1\n     - env: IMAGE=x86_64-musl\n+    - env: IMAGE=x86_64-gnu-distcheck\n \n     # OSX builders\n     - env: >\n@@ -66,10 +68,10 @@ script:\n       if [ \"$ALLOW_PR\" = \"\" ] && [ \"$TRAVIS_BRANCH\" != \"auto\" ]; then\n           echo skipping, not a full build;\n       elif [ \"$TRAVIS_OS_NAME\" = \"osx\" ]; then\n-          git submodule update --init;\n+          git submodule update --init &&\n           src/ci/run.sh;\n       else\n-          git submodule update --init;\n+          git submodule update --init &&\n           src/ci/docker/run.sh $IMAGE;\n       fi\n \n@@ -78,7 +80,7 @@ before_cache:\n   - docker history -q rust-ci |\n     grep -v missing |\n     xargs docker save |\n-    gzip -9 > $HOME/docker/rust-ci.tar.gz\n+    gzip > $HOME/docker/rust-ci.tar.gz\n before_install:\n   - zcat $HOME/docker/rust-ci.tar.gz | docker load || true\n "}, {"sha": "c1218e9c600ce772e82b053083393e84ad44f47c", "filename": "README.md", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -82,8 +82,9 @@ build.\n    # Install build tools needed for Rust. If you're building a 32-bit compiler,\n    # then replace \"x86_64\" below with \"i686\". If you've already got git, python,\n    # or CMake installed and in PATH you can remove them from this list. Note\n-   # that it is important that the `python2` and `cmake` packages **not** used.\n-   # The build has historically been known to fail with these packages.\n+   # that it is important that you do **not** use the 'python2' and 'cmake'\n+   # packages from the 'msys2' subsystem. The build has historically been known\n+   # to fail with these packages.\n    $ pacman -S git \\\n                make \\\n                diffutils \\"}, {"sha": "a4b5cbc115253f6a1edef11c8a0fc3bd6ad510e7", "filename": "appveyor.yml", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/appveyor.yml", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/appveyor.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/appveyor.yml?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -21,7 +21,7 @@ environment:\n   # MSVC cargotest\n   - MSYS_BITS: 64\n     NO_VENDOR: 1\n-    RUST_CHECK_TARGET: check-cargotest\n+    RUST_CHECK_TARGET: check-aux\n     RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc\n \n   # 32/64-bit MinGW builds.\n@@ -96,6 +96,13 @@ install:\n   - 7z x -y sccache.tar > nul\n   - set PATH=%PATH%;%CD%\\sccache2\n \n+  # Help debug some handle issues on AppVeyor\n+  - ps: Invoke-WebRequest -Uri https://download.sysinternals.com/files/Handle.zip -OutFile handle.zip\n+  - mkdir handle\n+  - ps: Expand-Archive handle.zip -dest handle\n+  - set PATH=%PATH%;%CD%\\handle\n+  - handle.exe -accepteula -help\n+\n test_script:\n   - git submodule update --init\n   - set SRC=."}, {"sha": "beb0a9d43a0cf4cd87b2a48da157c64e5589cbfc", "filename": "configure", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/configure", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/configure", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/configure?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -693,6 +693,7 @@ opt_nosave manage-submodules 1 \"let the build manage the git submodules\"\n opt_nosave clang 0 \"prefer clang to gcc for building the runtime\"\n opt_nosave jemalloc 1 \"build liballoc with jemalloc\"\n opt elf-tls 1 \"elf thread local storage on platforms where supported\"\n+opt full-bootstrap 0 \"build three compilers instead of two\"\n \n valopt_nosave prefix \"/usr/local\" \"set installation prefix\"\n valopt_nosave local-rust-root \"/usr/local\" \"set prefix for local rust binary\""}, {"sha": "9624a51dda01b3a0fd2f88858dc1755c4f73f38a", "filename": "mk/crates.mk", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/mk%2Fcrates.mk", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/mk%2Fcrates.mk", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/mk%2Fcrates.mk?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -54,7 +54,7 @@ TARGET_CRATES := libc std term \\\n                  compiler_builtins core alloc \\\n                  std_unicode rustc_bitflags \\\n \t\t alloc_system alloc_jemalloc \\\n-\t\t panic_abort panic_unwind unwind\n+\t\t panic_abort panic_unwind unwind rustc_i128\n RUSTC_CRATES := rustc rustc_typeck rustc_mir rustc_borrowck rustc_resolve rustc_driver \\\n                 rustc_trans rustc_back rustc_llvm rustc_privacy rustc_lint \\\n                 rustc_data_structures rustc_platform_intrinsics rustc_errors \\\n@@ -92,23 +92,26 @@ DEPS_getopts := std\n DEPS_graphviz := std\n DEPS_log := std\n DEPS_num := std\n-DEPS_serialize := std log\n+DEPS_serialize := std log rustc_i128\n DEPS_term := std\n DEPS_test := std getopts term native:rust_test_helpers\n+DEPS_rustc_i128 = std\n \n-DEPS_syntax := std term serialize log arena libc rustc_bitflags std_unicode rustc_errors syntax_pos rustc_data_structures\n+DEPS_syntax := std term serialize log arena libc rustc_bitflags std_unicode rustc_errors \\\n+\t\t\tsyntax_pos rustc_data_structures rustc_i128\n DEPS_syntax_ext := syntax syntax_pos rustc_errors fmt_macros proc_macro\n+DEPS_proc_macro := syntax syntax_pos rustc_plugin log\n DEPS_syntax_pos := serialize\n DEPS_proc_macro_tokens := syntax syntax_pos log\n DEPS_proc_macro_plugin := syntax syntax_pos rustc_plugin log proc_macro_tokens\n \n-DEPS_rustc_const_math := std syntax log serialize\n+DEPS_rustc_const_math := std syntax log serialize rustc_i128\n DEPS_rustc_const_eval := rustc_const_math rustc syntax log serialize \\\n-\t\t\t     rustc_back graphviz syntax_pos\n+\t\t\t     rustc_back graphviz syntax_pos rustc_i128\n \n DEPS_rustc := syntax fmt_macros flate arena serialize getopts \\\n               log graphviz rustc_llvm rustc_back rustc_data_structures\\\n-\t      rustc_const_math syntax_pos rustc_errors\n+\t      rustc_const_math syntax_pos rustc_errors rustc_i128\n DEPS_rustc_back := std syntax flate log libc\n DEPS_rustc_borrowck := rustc log graphviz syntax syntax_pos rustc_errors rustc_mir\n DEPS_rustc_data_structures := std log serialize libc\n@@ -119,19 +122,20 @@ DEPS_rustc_driver := arena flate getopts graphviz libc rustc rustc_back rustc_bo\n                      rustc_passes rustc_save_analysis rustc_const_eval \\\n                      rustc_incremental syntax_pos rustc_errors proc_macro rustc_data_structures\n DEPS_rustc_errors := log libc serialize syntax_pos\n-DEPS_rustc_lint := rustc log syntax syntax_pos rustc_const_eval\n+DEPS_rustc_lint := rustc log syntax syntax_pos rustc_const_eval rustc_i128\n DEPS_rustc_llvm := native:rustllvm libc std rustc_bitflags\n DEPS_proc_macro := std syntax\n DEPS_rustc_metadata := rustc syntax syntax_pos rustc_errors rustc_const_math \\\n-\t\t\tproc_macro syntax_ext\n+\t\t\tproc_macro syntax_ext rustc_i128\n DEPS_rustc_passes := syntax syntax_pos rustc core rustc_const_eval rustc_errors\n-DEPS_rustc_mir := rustc syntax syntax_pos rustc_const_math rustc_const_eval rustc_bitflags\n+DEPS_rustc_mir := rustc syntax syntax_pos rustc_const_math rustc_const_eval rustc_bitflags \\\n+\t\t\t\t\trustc_i128\n DEPS_rustc_resolve := arena rustc log syntax syntax_pos rustc_errors\n DEPS_rustc_platform_intrinsics := std\n DEPS_rustc_plugin := rustc rustc_metadata syntax syntax_pos rustc_errors\n DEPS_rustc_privacy := rustc log syntax syntax_pos\n DEPS_rustc_trans := arena flate getopts graphviz libc rustc rustc_back \\\n-                    log syntax serialize rustc_llvm rustc_platform_intrinsics \\\n+                    log syntax serialize rustc_llvm rustc_platform_intrinsics rustc_i128 \\\n                     rustc_const_math rustc_const_eval rustc_incremental rustc_errors syntax_pos\n DEPS_rustc_incremental := rustc syntax_pos serialize rustc_data_structures\n DEPS_rustc_save_analysis := rustc log syntax syntax_pos serialize\n@@ -159,6 +163,7 @@ ONLY_RLIB_alloc := 1\n ONLY_RLIB_rand := 1\n ONLY_RLIB_collections := 1\n ONLY_RLIB_std_unicode := 1\n+ONLY_RLIB_rustc_i128 := 1\n ONLY_RLIB_rustc_bitflags := 1\n ONLY_RLIB_alloc_system := 1\n ONLY_RLIB_alloc_jemalloc := 1"}, {"sha": "3da29933c812e7a4615ccea8b8300ea72d354d9c", "filename": "src/Cargo.lock", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -89,7 +89,7 @@ version = \"0.0.0\"\n dependencies = [\n  \"env_logger 0.3.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"log 0.3.6 (registry+https://github.com/rust-lang/crates.io-index)\",\n- \"serialize 0.0.0\",\n+ \"rustc-serialize 0.3.19 (registry+https://github.com/rust-lang/crates.io-index)\",\n ]\n \n [[package]]\n@@ -249,6 +249,7 @@ dependencies = [\n  \"rustc_const_math 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n  \"rustc_errors 0.0.0\",\n+ \"rustc_i128 0.0.0\",\n  \"rustc_llvm 0.0.0\",\n  \"serialize 0.0.0\",\n  \"syntax 0.0.0\",\n@@ -308,6 +309,7 @@ dependencies = [\n  \"rustc_const_math 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n  \"rustc_errors 0.0.0\",\n+ \"rustc_i128 0.0.0\",\n  \"serialize 0.0.0\",\n  \"syntax 0.0.0\",\n  \"syntax_pos 0.0.0\",\n@@ -318,6 +320,7 @@ name = \"rustc_const_math\"\n version = \"0.0.0\"\n dependencies = [\n  \"log 0.0.0\",\n+ \"rustc_i128 0.0.0\",\n  \"serialize 0.0.0\",\n  \"syntax 0.0.0\",\n ]\n@@ -327,6 +330,7 @@ name = \"rustc_data_structures\"\n version = \"0.0.0\"\n dependencies = [\n  \"log 0.0.0\",\n+ \"rustc_i128 0.0.0\",\n  \"serialize 0.0.0\",\n ]\n \n@@ -372,6 +376,10 @@ dependencies = [\n  \"syntax_pos 0.0.0\",\n ]\n \n+[[package]]\n+name = \"rustc_i128\"\n+version = \"0.0.0\"\n+\n [[package]]\n name = \"rustc_incremental\"\n version = \"0.0.0\"\n@@ -380,6 +388,7 @@ dependencies = [\n  \"log 0.0.0\",\n  \"rustc 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n+ \"rustc_i128 0.0.0\",\n  \"serialize 0.0.0\",\n  \"syntax 0.0.0\",\n  \"syntax_pos 0.0.0\",\n@@ -393,6 +402,7 @@ dependencies = [\n  \"rustc 0.0.0\",\n  \"rustc_back 0.0.0\",\n  \"rustc_const_eval 0.0.0\",\n+ \"rustc_i128 0.0.0\",\n  \"syntax 0.0.0\",\n  \"syntax_pos 0.0.0\",\n ]\n@@ -418,6 +428,7 @@ dependencies = [\n  \"rustc_const_math 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n  \"rustc_errors 0.0.0\",\n+ \"rustc_i128 0.0.0\",\n  \"rustc_llvm 0.0.0\",\n  \"serialize 0.0.0\",\n  \"syntax 0.0.0\",\n@@ -437,6 +448,7 @@ dependencies = [\n  \"rustc_const_eval 0.0.0\",\n  \"rustc_const_math 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n+ \"rustc_i128 0.0.0\",\n  \"syntax 0.0.0\",\n  \"syntax_pos 0.0.0\",\n ]\n@@ -519,6 +531,7 @@ dependencies = [\n  \"rustc_const_math 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n  \"rustc_errors 0.0.0\",\n+ \"rustc_i128 0.0.0\",\n  \"rustc_incremental 0.0.0\",\n  \"rustc_llvm 0.0.0\",\n  \"rustc_platform_intrinsics 0.0.0\",\n@@ -574,6 +587,7 @@ name = \"serialize\"\n version = \"0.0.0\"\n dependencies = [\n  \"log 0.0.0\",\n+ \"rustc_i128 0.0.0\",\n ]\n \n [[package]]\n@@ -619,6 +633,7 @@ dependencies = [\n  \"rustc_bitflags 0.0.0\",\n  \"rustc_data_structures 0.0.0\",\n  \"rustc_errors 0.0.0\",\n+ \"rustc_i128 0.0.0\",\n  \"serialize 0.0.0\",\n  \"syntax_pos 0.0.0\",\n ]"}, {"sha": "90fd31ecbdd732d963b4ccfce6b8478418a32292", "filename": "src/bootstrap/bin/rustc.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Fbootstrap%2Fbin%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Fbootstrap%2Fbin%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustc.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -89,7 +89,9 @@ fn main() {\n         // When we build Rust dylibs they're all intended for intermediate\n         // usage, so make sure we pass the -Cprefer-dynamic flag instead of\n         // linking all deps statically into the dylib.\n-        cmd.arg(\"-Cprefer-dynamic\");\n+        if env::var_os(\"RUSTC_NO_PREFER_DYNAMIC\").is_none() {\n+            cmd.arg(\"-Cprefer-dynamic\");\n+        }\n \n         // Help the libc crate compile by assisting it in finding the MUSL\n         // native libraries."}, {"sha": "6db1afa54a625493c868ca3c419744c5ccc1124c", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 35, "deletions": 16, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -62,9 +62,9 @@ impl fmt::Display for TestKind {\n ///\n /// This tool in `src/tools` will verify the validity of all our links in the\n /// documentation to ensure we don't have a bunch of dead ones.\n-pub fn linkcheck(build: &Build, stage: u32, host: &str) {\n-    println!(\"Linkcheck stage{} ({})\", stage, host);\n-    let compiler = Compiler::new(stage, host);\n+pub fn linkcheck(build: &Build, host: &str) {\n+    println!(\"Linkcheck ({})\", host);\n+    let compiler = Compiler::new(0, host);\n \n     let _time = util::timeit();\n     build.run(build.tool_cmd(&compiler, \"linkchecker\")\n@@ -93,20 +93,21 @@ pub fn cargotest(build: &Build, stage: u32, host: &str) {\n     t!(fs::create_dir_all(&out_dir));\n \n     let _time = util::timeit();\n-    build.run(build.tool_cmd(compiler, \"cargotest\")\n-                   .env(\"PATH\", newpath)\n-                   .arg(&build.cargo)\n-                   .arg(&out_dir));\n+    let mut cmd = Command::new(build.tool(&Compiler::new(0, host), \"cargotest\"));\n+    build.prepare_tool_cmd(compiler, &mut cmd);\n+    build.run(cmd.env(\"PATH\", newpath)\n+                 .arg(&build.cargo)\n+                 .arg(&out_dir));\n }\n \n /// Runs the `tidy` tool as compiled in `stage` by the `host` compiler.\n ///\n /// This tool in `src/tools` checks up on various bits and pieces of style and\n /// otherwise just implements a few lint-like checks that are specific to the\n /// compiler itself.\n-pub fn tidy(build: &Build, stage: u32, host: &str) {\n-    println!(\"tidy check stage{} ({})\", stage, host);\n-    let compiler = Compiler::new(stage, host);\n+pub fn tidy(build: &Build, host: &str) {\n+    println!(\"tidy check ({})\", host);\n+    let compiler = Compiler::new(0, host);\n     build.run(build.tool_cmd(&compiler, \"tidy\")\n                    .arg(build.src.join(\"src\")));\n }\n@@ -127,7 +128,9 @@ pub fn compiletest(build: &Build,\n                    suite: &str) {\n     println!(\"Check compiletest suite={} mode={} ({} -> {})\",\n              suite, mode, compiler.host, target);\n-    let mut cmd = build.tool_cmd(compiler, \"compiletest\");\n+    let mut cmd = Command::new(build.tool(&Compiler::new(0, compiler.host),\n+                                          \"compiletest\"));\n+    build.prepare_tool_cmd(compiler, &mut cmd);\n \n     // compiletest currently has... a lot of arguments, so let's just pass all\n     // of them!\n@@ -287,7 +290,8 @@ pub fn error_index(build: &Build, compiler: &Compiler) {\n     let output = dir.join(\"error-index.md\");\n \n     let _time = util::timeit();\n-    build.run(build.tool_cmd(compiler, \"error_index_generator\")\n+    build.run(build.tool_cmd(&Compiler::new(0, compiler.host),\n+                             \"error_index_generator\")\n                    .arg(\"markdown\")\n                    .arg(&output)\n                    .env(\"CFG_BUILD\", &build.config.build));\n@@ -341,12 +345,22 @@ pub fn krate(build: &Build,\n     println!(\"{} {} stage{} ({} -> {})\", test_kind, name, compiler.stage,\n              compiler.host, target);\n \n+    // If we're not doing a full bootstrap but we're testing a stage2 version of\n+    // libstd, then what we're actually testing is the libstd produced in\n+    // stage1. Reflect that here by updating the compiler that we're working\n+    // with automatically.\n+    let compiler = if build.force_use_stage1(compiler, target) {\n+        Compiler::new(1, compiler.host)\n+    } else {\n+        compiler.clone()\n+    };\n+\n     // Build up the base `cargo test` command.\n     //\n     // Pass in some standard flags then iterate over the graph we've discovered\n     // in `cargo metadata` with the maps above and figure out what `-p`\n     // arguments need to get passed.\n-    let mut cargo = build.cargo(compiler, mode, target, test_kind.subcommand());\n+    let mut cargo = build.cargo(&compiler, mode, target, test_kind.subcommand());\n     cargo.arg(\"--manifest-path\")\n          .arg(build.src.join(path).join(\"Cargo.toml\"))\n          .arg(\"--features\").arg(features);\n@@ -380,7 +394,7 @@ pub fn krate(build: &Build,\n     // Note that to run the compiler we need to run with the *host* libraries,\n     // but our wrapper scripts arrange for that to be the case anyway.\n     let mut dylib_path = dylib_path();\n-    dylib_path.insert(0, build.sysroot_libdir(compiler, target));\n+    dylib_path.insert(0, build.sysroot_libdir(&compiler, target));\n     cargo.env(dylib_path_var(), env::join_paths(&dylib_path).unwrap());\n \n     if target.contains(\"android\") {\n@@ -399,10 +413,10 @@ pub fn krate(build: &Build,\n \n     if target.contains(\"android\") {\n         build.run(&mut cargo);\n-        krate_android(build, compiler, target, mode);\n+        krate_android(build, &compiler, target, mode);\n     } else if target.contains(\"emscripten\") {\n         build.run(&mut cargo);\n-        krate_emscripten(build, compiler, target, mode);\n+        krate_emscripten(build, &compiler, target, mode);\n     } else {\n         cargo.args(&build.flags.cmd.test_args());\n         build.run(&mut cargo);\n@@ -497,6 +511,10 @@ fn find_tests(dir: &Path,\n pub fn android_copy_libs(build: &Build,\n                          compiler: &Compiler,\n                          target: &str) {\n+    if !target.contains(\"android\") {\n+        return\n+    }\n+\n     println!(\"Android copy libs to emulator ({})\", target);\n     build.run(Command::new(\"adb\").arg(\"remount\"));\n     build.run(Command::new(\"adb\").args(&[\"shell\", \"rm\", \"-r\", ADB_TEST_DIR]));\n@@ -544,6 +562,7 @@ pub fn distcheck(build: &Build) {\n        .current_dir(&dir);\n     build.run(&mut cmd);\n     build.run(Command::new(\"./configure\")\n+                     .args(&build.config.configure_args)\n                      .current_dir(&dir));\n     build.run(Command::new(build_helper::make(&build.config.build))\n                      .arg(\"check\")"}, {"sha": "a7633998aad8bc484235233c2d11d94e24958751", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 66, "deletions": 53, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -33,17 +33,12 @@ use {Build, Compiler, Mode};\n /// This will build the standard library for a particular stage of the build\n /// using the `compiler` targeting the `target` architecture. The artifacts\n /// created will also be linked into the sysroot directory.\n-pub fn std<'a>(build: &'a Build, target: &str, compiler: &Compiler<'a>) {\n-    println!(\"Building stage{} std artifacts ({} -> {})\", compiler.stage,\n-             compiler.host, target);\n-\n+pub fn std(build: &Build, target: &str, compiler: &Compiler) {\n     let libdir = build.sysroot_libdir(compiler, target);\n-    let _ = fs::remove_dir_all(&libdir);\n     t!(fs::create_dir_all(&libdir));\n \n-    // Some platforms have startup objects that may be required to produce the\n-    // libstd dynamic library, for example.\n-    build_startup_objects(build, target, &libdir);\n+    println!(\"Building stage{} std artifacts ({} -> {})\", compiler.stage,\n+             compiler.host, target);\n \n     let out_dir = build.cargo_out(compiler, Mode::Libstd, target);\n     build.clear_if_dirty(&out_dir, &build.compiler_path(compiler));\n@@ -65,29 +60,30 @@ pub fn std<'a>(build: &'a Build, target: &str, compiler: &Compiler<'a>) {\n \n     build.run(&mut cargo);\n     update_mtime(&libstd_stamp(build, &compiler, target));\n-    std_link(build, target, compiler.stage, compiler.host);\n }\n \n /// Link all libstd rlibs/dylibs into the sysroot location.\n ///\n-/// Links those artifacts generated in the given `stage` for `target` produced\n-/// by `compiler` into `host`'s sysroot.\n+/// Links those artifacts generated by `compiler` to a the `stage` compiler's\n+/// sysroot for the specified `host` and `target`.\n+///\n+/// Note that this assumes that `compiler` has already generated the libstd\n+/// libraries for `target`, and this method will find them in the relevant\n+/// output directory.\n pub fn std_link(build: &Build,\n-                target: &str,\n-                stage: u32,\n-                host: &str) {\n-    let compiler = Compiler::new(stage, &build.config.build);\n-    let target_compiler = Compiler::new(compiler.stage, host);\n+                compiler: &Compiler,\n+                target_compiler: &Compiler,\n+                target: &str) {\n+    println!(\"Copying stage{} std from stage{} ({} -> {} / {})\",\n+             target_compiler.stage,\n+             compiler.stage,\n+             compiler.host,\n+             target_compiler.host,\n+             target);\n     let libdir = build.sysroot_libdir(&target_compiler, target);\n     let out_dir = build.cargo_out(&compiler, Mode::Libstd, target);\n \n-    // If we're linking one compiler host's output into another, then we weren't\n-    // called from the `std` method above. In that case we clean out what's\n-    // already there.\n-    if host != compiler.host {\n-        let _ = fs::remove_dir_all(&libdir);\n-        t!(fs::create_dir_all(&libdir));\n-    }\n+    t!(fs::create_dir_all(&libdir));\n     add_to_sysroot(&out_dir, &libdir);\n \n     if target.contains(\"musl\") && !target.contains(\"mips\") {\n@@ -110,20 +106,23 @@ fn copy_musl_third_party_objects(build: &Build, target: &str, into: &Path) {\n /// They don't require any library support as they're just plain old object\n /// files, so we just use the nightly snapshot compiler to always build them (as\n /// no other compilers are guaranteed to be available).\n-fn build_startup_objects(build: &Build, target: &str, into: &Path) {\n+pub fn build_startup_objects(build: &Build, for_compiler: &Compiler, target: &str) {\n     if !target.contains(\"pc-windows-gnu\") {\n         return\n     }\n+\n     let compiler = Compiler::new(0, &build.config.build);\n     let compiler_path = build.compiler_path(&compiler);\n+    let into = build.sysroot_libdir(for_compiler, target);\n+    t!(fs::create_dir_all(&into));\n \n     for file in t!(fs::read_dir(build.src.join(\"src/rtstartup\"))) {\n         let file = t!(file);\n         let mut cmd = Command::new(&compiler_path);\n         build.run(cmd.env(\"RUSTC_BOOTSTRAP\", \"1\")\n                      .arg(\"--target\").arg(target)\n                      .arg(\"--emit=obj\")\n-                     .arg(\"--out-dir\").arg(into)\n+                     .arg(\"--out-dir\").arg(&into)\n                      .arg(file.path()));\n     }\n \n@@ -137,7 +136,7 @@ fn build_startup_objects(build: &Build, target: &str, into: &Path) {\n /// This will build libtest and supporting libraries for a particular stage of\n /// the build using the `compiler` targeting the `target` architecture. The\n /// artifacts created will also be linked into the sysroot directory.\n-pub fn test<'a>(build: &'a Build, target: &str, compiler: &Compiler<'a>) {\n+pub fn test(build: &Build, target: &str, compiler: &Compiler) {\n     println!(\"Building stage{} test artifacts ({} -> {})\", compiler.stage,\n              compiler.host, target);\n     let out_dir = build.cargo_out(compiler, Mode::Libtest, target);\n@@ -147,19 +146,19 @@ pub fn test<'a>(build: &'a Build, target: &str, compiler: &Compiler<'a>) {\n          .arg(build.src.join(\"src/rustc/test_shim/Cargo.toml\"));\n     build.run(&mut cargo);\n     update_mtime(&libtest_stamp(build, compiler, target));\n-    test_link(build, target, compiler.stage, compiler.host);\n }\n \n-/// Link all libtest rlibs/dylibs into the sysroot location.\n-///\n-/// Links those artifacts generated in the given `stage` for `target` produced\n-/// by `compiler` into `host`'s sysroot.\n+/// Same as `std_link`, only for libtest\n pub fn test_link(build: &Build,\n-                 target: &str,\n-                 stage: u32,\n-                 host: &str) {\n-    let compiler = Compiler::new(stage, &build.config.build);\n-    let target_compiler = Compiler::new(compiler.stage, host);\n+                 compiler: &Compiler,\n+                 target_compiler: &Compiler,\n+                 target: &str) {\n+    println!(\"Copying stage{} test from stage{} ({} -> {} / {})\",\n+             target_compiler.stage,\n+             compiler.stage,\n+             compiler.host,\n+             target_compiler.host,\n+             target);\n     let libdir = build.sysroot_libdir(&target_compiler, target);\n     let out_dir = build.cargo_out(&compiler, Mode::Libtest, target);\n     add_to_sysroot(&out_dir, &libdir);\n@@ -170,7 +169,7 @@ pub fn test_link(build: &Build,\n /// This will build the compiler for a particular stage of the build using\n /// the `compiler` targeting the `target` architecture. The artifacts\n /// created will also be linked into the sysroot directory.\n-pub fn rustc<'a>(build: &'a Build, target: &str, compiler: &Compiler<'a>) {\n+pub fn rustc(build: &Build, target: &str, compiler: &Compiler) {\n     println!(\"Building stage{} compiler artifacts ({} -> {})\",\n              compiler.stage, compiler.host, target);\n \n@@ -222,20 +221,19 @@ pub fn rustc<'a>(build: &'a Build, target: &str, compiler: &Compiler<'a>) {\n         cargo.env(\"CFG_DEFAULT_AR\", s);\n     }\n     build.run(&mut cargo);\n-\n-    rustc_link(build, target, compiler.stage, compiler.host);\n }\n \n-/// Link all librustc rlibs/dylibs into the sysroot location.\n-///\n-/// Links those artifacts generated in the given `stage` for `target` produced\n-/// by `compiler` into `host`'s sysroot.\n+/// Same as `std_link`, only for librustc\n pub fn rustc_link(build: &Build,\n-                  target: &str,\n-                  stage: u32,\n-                  host: &str) {\n-    let compiler = Compiler::new(stage, &build.config.build);\n-    let target_compiler = Compiler::new(compiler.stage, host);\n+                  compiler: &Compiler,\n+                  target_compiler: &Compiler,\n+                  target: &str) {\n+    println!(\"Copying stage{} rustc from stage{} ({} -> {} / {})\",\n+             target_compiler.stage,\n+             compiler.stage,\n+             compiler.host,\n+             target_compiler.host,\n+             target);\n     let libdir = build.sysroot_libdir(&target_compiler, target);\n     let out_dir = build.cargo_out(&compiler, Mode::Librustc, target);\n     add_to_sysroot(&out_dir, &libdir);\n@@ -259,6 +257,17 @@ fn compiler_file(compiler: &Path, file: &str) -> PathBuf {\n     PathBuf::from(out.trim())\n }\n \n+pub fn create_sysroot(build: &Build, compiler: &Compiler) {\n+    // nothing to do in stage0\n+    if compiler.stage == 0 {\n+        return\n+    }\n+\n+    let sysroot = build.sysroot(compiler);\n+    let _ = fs::remove_dir_all(&sysroot);\n+    t!(fs::create_dir_all(&sysroot));\n+}\n+\n /// Prepare a new compiler from the artifacts in `stage`\n ///\n /// This will assemble a compiler in `build/$host/stage$stage`. The compiler\n@@ -269,18 +278,17 @@ pub fn assemble_rustc(build: &Build, stage: u32, host: &str) {\n     if stage == 0 {\n         return\n     }\n+\n+    println!(\"Copying stage{} compiler ({})\", stage, host);\n+\n     // The compiler that we're assembling\n     let target_compiler = Compiler::new(stage, host);\n \n     // The compiler that compiled the compiler we're assembling\n     let build_compiler = Compiler::new(stage - 1, &build.config.build);\n \n-    // Clear out old files\n-    let sysroot = build.sysroot(&target_compiler);\n-    let _ = fs::remove_dir_all(&sysroot);\n-    t!(fs::create_dir_all(&sysroot));\n-\n     // Link in all dylibs to the libdir\n+    let sysroot = build.sysroot(&target_compiler);\n     let sysroot_libdir = sysroot.join(libdir(host));\n     t!(fs::create_dir_all(&sysroot_libdir));\n     let src_libdir = build.sysroot_libdir(&build_compiler, host);\n@@ -371,6 +379,11 @@ pub fn tool(build: &Build, stage: u32, host: &str, tool: &str) {\n     let mut cargo = build.cargo(&compiler, Mode::Tool, host, \"build\");\n     cargo.arg(\"--manifest-path\")\n          .arg(build.src.join(format!(\"src/tools/{}/Cargo.toml\", tool)));\n+\n+    // We don't want to build tools dynamically as they'll be running across\n+    // stages and such and it's just easier if they're not dynamically linked.\n+    cargo.env(\"RUSTC_NO_PREFER_DYNAMIC\", \"1\");\n+\n     build.run(&mut cargo);\n }\n "}, {"sha": "11c5b374ed9654d821f3e908387b32637bc24d47", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -46,6 +46,7 @@ pub struct Config {\n     pub docs: bool,\n     pub vendor: bool,\n     pub target_config: HashMap<String, Target>,\n+    pub full_bootstrap: bool,\n \n     // llvm codegen options\n     pub llvm_assertions: bool,\n@@ -54,6 +55,7 @@ pub struct Config {\n     pub llvm_version_check: bool,\n     pub llvm_static_stdcpp: bool,\n     pub llvm_link_shared: bool,\n+    pub llvm_targets: Option<String>,\n \n     // rust codegen options\n     pub rust_optimize: bool,\n@@ -92,6 +94,7 @@ pub struct Config {\n     pub nodejs: Option<PathBuf>,\n     pub gdb: Option<PathBuf>,\n     pub python: Option<PathBuf>,\n+    pub configure_args: Vec<String>,\n }\n \n /// Per-target configuration stored in the global configuration structure.\n@@ -134,6 +137,7 @@ struct Build {\n     vendor: Option<bool>,\n     nodejs: Option<String>,\n     python: Option<String>,\n+    full_bootstrap: Option<bool>,\n }\n \n /// TOML representation of various global install decisions.\n@@ -152,6 +156,7 @@ struct Llvm {\n     release_debuginfo: Option<bool>,\n     version_check: Option<bool>,\n     static_libstdcpp: Option<bool>,\n+    targets: Option<String>,\n }\n \n #[derive(RustcDecodable)]\n@@ -264,6 +269,7 @@ impl Config {\n         set(&mut config.docs, build.docs);\n         set(&mut config.submodules, build.submodules);\n         set(&mut config.vendor, build.vendor);\n+        set(&mut config.full_bootstrap, build.full_bootstrap);\n \n         if let Some(ref install) = toml.install {\n             config.prefix = install.prefix.clone();\n@@ -285,6 +291,7 @@ impl Config {\n             set(&mut config.llvm_release_debuginfo, llvm.release_debuginfo);\n             set(&mut config.llvm_version_check, llvm.version_check);\n             set(&mut config.llvm_static_stdcpp, llvm.static_libstdcpp);\n+            config.llvm_targets = llvm.targets.clone();\n         }\n \n         if let Some(ref rust) = toml.rust {\n@@ -393,6 +400,7 @@ impl Config {\n                 (\"NINJA\", self.ninja),\n                 (\"CODEGEN_TESTS\", self.codegen_tests),\n                 (\"VENDOR\", self.vendor),\n+                (\"FULL_BOOTSTRAP\", self.full_bootstrap),\n             }\n \n             match key {\n@@ -512,6 +520,11 @@ impl Config {\n                 \"CFG_ENABLE_SCCACHE\" if value == \"1\" => {\n                     self.ccache = Some(\"sccache\".to_string());\n                 }\n+                \"CFG_CONFIGURE_ARGS\" if value.len() > 0 => {\n+                    self.configure_args = value.split_whitespace()\n+                                               .map(|s| s.to_string())\n+                                               .collect();\n+                }\n                 _ => {}\n             }\n         }"}, {"sha": "69210c4959b921e2e649bd62be3b40cbf8afaa51", "filename": "src/bootstrap/config.toml.example", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Fbootstrap%2Fconfig.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Fbootstrap%2Fconfig.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.toml.example?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -42,6 +42,17 @@\n # example.\n #ninja = false\n \n+# LLVM targets to build support for.\n+# Note: this is NOT related to Rust compilation targets. However, as Rust is\n+# dependent on LLVM for code generation, turning targets off here WILL lead to\n+# the resulting rustc being unable to compile for the disabled architectures.\n+# Also worth pointing out is that, in case support for new targets are added to\n+# LLVM, enabling them here doesn't mean Rust is automatically gaining said\n+# support. You'll need to write a target specification at least, and most\n+# likely, teach rustc about the C ABI of the target. Get in touch with the\n+# Rust team and file an issue if you need assistance in porting!\n+#targets = \"X86;ARM;AArch64;Mips;PowerPC;SystemZ;JSBackend;MSP430;Sparc;NVPTX\"\n+\n # =============================================================================\n # General build configuration options\n # =============================================================================\n@@ -100,6 +111,13 @@\n # Indicate whether the vendored sources are used for Rust dependencies or not\n #vendor = false\n \n+# Typically the build system will build the rust compiler twice. The second\n+# compiler, however, will simply use its own libraries to link against. If you\n+# would rather to perform a full bootstrap, compiling the compiler three times,\n+# then you can set this option to true. You shouldn't ever need to set this\n+# option to true.\n+#full-bootstrap = false\n+\n # =============================================================================\n # General install configuration options\n # ============================================================================="}, {"sha": "428c3da77648ca762df9690121b36afaddd8cd8a", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -397,6 +397,13 @@ pub fn rust_src(build: &Build, host: &str) {\n             }\n         }\n \n+        // If we're inside the vendor directory then we need to preserve\n+        // everything as Cargo's vendoring support tracks all checksums and we\n+        // want to be sure we don't accidentally leave out a file.\n+        if spath.contains(\"vendor\") {\n+            return true\n+        }\n+\n         let excludes = [\n             \"CVS\", \"RCS\", \"SCCS\", \".git\", \".gitignore\", \".gitmodules\",\n             \".gitattributes\", \".cvsignore\", \".svn\", \".arch-ids\", \"{arch}\","}, {"sha": "bbbf5cba8a1ab23782d87347abb702f48683f07a", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -29,19 +29,19 @@ use util::{up_to_date, cp_r};\n ///\n /// This will not actually generate any documentation if the documentation has\n /// already been generated.\n-pub fn rustbook(build: &Build, stage: u32, target: &str, name: &str) {\n+pub fn rustbook(build: &Build, target: &str, name: &str) {\n     let out = build.doc_out(target);\n     t!(fs::create_dir_all(&out));\n \n     let out = out.join(name);\n-    let compiler = Compiler::new(stage, &build.config.build);\n+    let compiler = Compiler::new(0, &build.config.build);\n     let src = build.src.join(\"src/doc\").join(name);\n     let index = out.join(\"index.html\");\n     let rustbook = build.tool(&compiler, \"rustbook\");\n     if up_to_date(&src, &index) && up_to_date(&rustbook, &index) {\n         return\n     }\n-    println!(\"Rustbook stage{} ({}) - {}\", stage, target, name);\n+    println!(\"Rustbook ({}) - {}\", target, name);\n     let _ = fs::remove_dir_all(&out);\n     build.run(build.tool_cmd(&compiler, \"rustbook\")\n                    .arg(\"build\")\n@@ -137,6 +137,11 @@ pub fn std(build: &Build, stage: u32, target: &str) {\n     let out = build.doc_out(target);\n     t!(fs::create_dir_all(&out));\n     let compiler = Compiler::new(stage, &build.config.build);\n+    let compiler = if build.force_use_stage1(&compiler, target) {\n+        Compiler::new(1, compiler.host)\n+    } else {\n+        compiler\n+    };\n     let out_dir = build.stage_out(&compiler, Mode::Libstd)\n                        .join(target).join(\"doc\");\n     let rustdoc = build.rustdoc(&compiler);\n@@ -146,7 +151,8 @@ pub fn std(build: &Build, stage: u32, target: &str) {\n     let mut cargo = build.cargo(&compiler, Mode::Libstd, target, \"doc\");\n     cargo.arg(\"--manifest-path\")\n          .arg(build.src.join(\"src/rustc/std_shim/Cargo.toml\"))\n-         .arg(\"--features\").arg(build.std_features());\n+         .arg(\"--features\").arg(build.std_features())\n+         .arg(\"-p\").arg(\"std\");\n     build.run(&mut cargo);\n     cp_r(&out_dir, &out)\n }\n@@ -160,6 +166,11 @@ pub fn test(build: &Build, stage: u32, target: &str) {\n     let out = build.doc_out(target);\n     t!(fs::create_dir_all(&out));\n     let compiler = Compiler::new(stage, &build.config.build);\n+    let compiler = if build.force_use_stage1(&compiler, target) {\n+        Compiler::new(1, compiler.host)\n+    } else {\n+        compiler\n+    };\n     let out_dir = build.stage_out(&compiler, Mode::Libtest)\n                        .join(target).join(\"doc\");\n     let rustdoc = build.rustdoc(&compiler);\n@@ -182,6 +193,11 @@ pub fn rustc(build: &Build, stage: u32, target: &str) {\n     let out = build.doc_out(target);\n     t!(fs::create_dir_all(&out));\n     let compiler = Compiler::new(stage, &build.config.build);\n+    let compiler = if build.force_use_stage1(&compiler, target) {\n+        Compiler::new(1, compiler.host)\n+    } else {\n+        compiler\n+    };\n     let out_dir = build.stage_out(&compiler, Mode::Librustc)\n                        .join(target).join(\"doc\");\n     let rustdoc = build.rustdoc(&compiler);\n@@ -198,11 +214,11 @@ pub fn rustc(build: &Build, stage: u32, target: &str) {\n \n /// Generates the HTML rendered error-index by running the\n /// `error_index_generator` tool.\n-pub fn error_index(build: &Build, stage: u32, target: &str) {\n-    println!(\"Documenting stage{} error index ({})\", stage, target);\n+pub fn error_index(build: &Build, target: &str) {\n+    println!(\"Documenting error index ({})\", target);\n     let out = build.doc_out(target);\n     t!(fs::create_dir_all(&out));\n-    let compiler = Compiler::new(stage, &build.config.build);\n+    let compiler = Compiler::new(0, &build.config.build);\n     let mut index = build.tool_cmd(&compiler, \"error_index_generator\");\n     index.arg(\"html\");\n     index.arg(out.join(\"error-index.html\"));"}, {"sha": "6b2b6ad5c02b13a19a7ac8057952d9b88b5da7f4", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 45, "deletions": 6, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -521,7 +521,7 @@ impl Build {\n                  .env(format!(\"CFLAGS_{}\", target), self.cflags(target).join(\" \"));\n         }\n \n-        if self.config.channel == \"nightly\" && compiler.stage == 2 {\n+        if self.config.channel == \"nightly\" && compiler.is_final_stage(self) {\n             cargo.env(\"RUSTC_SAVE_ANALYSIS\", \"api\".to_string());\n         }\n \n@@ -570,11 +570,18 @@ impl Build {\n     /// `host`.\n     fn tool_cmd(&self, compiler: &Compiler, tool: &str) -> Command {\n         let mut cmd = Command::new(self.tool(&compiler, tool));\n+        self.prepare_tool_cmd(compiler, &mut cmd);\n+        return cmd\n+    }\n+\n+    /// Prepares the `cmd` provided to be able to run the `compiler` provided.\n+    ///\n+    /// Notably this munges the dynamic library lookup path to point to the\n+    /// right location to run `compiler`.\n+    fn prepare_tool_cmd(&self, compiler: &Compiler, cmd: &mut Command) {\n         let host = compiler.host;\n         let mut paths = vec![\n-            self.cargo_out(compiler, Mode::Libstd, host).join(\"deps\"),\n-            self.cargo_out(compiler, Mode::Libtest, host).join(\"deps\"),\n-            self.cargo_out(compiler, Mode::Librustc, host).join(\"deps\"),\n+            self.sysroot_libdir(compiler, compiler.host),\n             self.cargo_out(compiler, Mode::Tool, host).join(\"deps\"),\n         ];\n \n@@ -595,8 +602,7 @@ impl Build {\n                 }\n             }\n         }\n-        add_lib_path(paths, &mut cmd);\n-        return cmd\n+        add_lib_path(paths, cmd);\n     }\n \n     /// Get the space-separated set of activated features for the standard\n@@ -880,6 +886,30 @@ impl Build {\n     fn python(&self) -> &Path {\n         self.config.python.as_ref().unwrap()\n     }\n+\n+    /// Tests whether the `compiler` compiling for `target` should be forced to\n+    /// use a stage1 compiler instead.\n+    ///\n+    /// Currently, by default, the build system does not perform a \"full\n+    /// bootstrap\" by default where we compile the compiler three times.\n+    /// Instead, we compile the compiler two times. The final stage (stage2)\n+    /// just copies the libraries from the previous stage, which is what this\n+    /// method detects.\n+    ///\n+    /// Here we return `true` if:\n+    ///\n+    /// * The build isn't performing a full bootstrap\n+    /// * The `compiler` is in the final stage, 2\n+    /// * We're not cross-compiling, so the artifacts are already available in\n+    ///   stage1\n+    ///\n+    /// When all of these conditions are met the build will lift artifacts from\n+    /// the previous stage forward.\n+    fn force_use_stage1(&self, compiler: &Compiler, target: &str) -> bool {\n+        !self.config.full_bootstrap &&\n+            compiler.stage >= 2 &&\n+            self.config.host.iter().any(|h| h == target)\n+    }\n }\n \n impl<'a> Compiler<'a> {\n@@ -892,4 +922,13 @@ impl<'a> Compiler<'a> {\n     fn is_snapshot(&self, build: &Build) -> bool {\n         self.stage == 0 && self.host == build.config.build\n     }\n+\n+    /// Returns if this compiler should be treated as a final stage one in the\n+    /// current build session.\n+    /// This takes into account whether we're performing a full bootstrap or\n+    /// not; don't directly compare the stage with `2`!\n+    fn is_final_stage(&self, build: &Build) -> bool {\n+        let final_stage = if build.config.full_bootstrap { 2 } else { 1 };\n+        self.stage >= final_stage\n+    }\n }"}, {"sha": "d6f6a7772c9d98fee667753b77a486d8a8473d78", "filename": "src/bootstrap/mk/Makefile.in", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Fbootstrap%2Fmk%2FMakefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Fbootstrap%2Fmk%2FMakefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fmk%2FMakefile.in?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -51,8 +51,16 @@ standalone-docs:\n \t$(Q)$(BOOTSTRAP) doc src/doc $(BOOTSTRAP_ARGS)\n check:\n \t$(Q)$(BOOTSTRAP) test $(BOOTSTRAP_ARGS)\n-check-cargotest:\n-\t$(Q)$(BOOTSTRAP) test src/tools/cargotest $(BOOTSTRAP_ARGS)\n+check-aux:\n+\t$(Q)$(BOOTSTRAP) test \\\n+\t\tsrc/tools/cargotest \\\n+\t\tsrc/test/pretty \\\n+\t\tsrc/test/run-pass/pretty \\\n+\t\tsrc/test/run-fail/pretty \\\n+\t\tsrc/test/run-pass-valgrind/pretty \\\n+\t\tsrc/test/run-pass-fulldeps/pretty \\\n+\t\tsrc/test/run-fail-fulldeps/pretty \\\n+\t\t$(BOOTSTRAP_ARGS)\n dist:\n \t$(Q)$(BOOTSTRAP) dist $(BOOTSTRAP_ARGS)\n distcheck:\n@@ -61,7 +69,7 @@ distcheck:\n install:\n \t$(Q)$(BOOTSTRAP) dist --install $(BOOTSTRAP_ARGS)\n tidy:\n-\t$(Q)$(BOOTSTRAP) test src/tools/tidy $(BOOTSTRAP_ARGS) --stage 0\n+\t$(Q)$(BOOTSTRAP) test src/tools/tidy $(BOOTSTRAP_ARGS)\n \n check-stage2-T-arm-linux-androideabi-H-x86_64-unknown-linux-gnu:\n \t$(Q)$(BOOTSTRAP) test --target arm-linux-androideabi"}, {"sha": "4b6fef8edc17f9e4465bbc549cb4ccacfafc9037", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -75,13 +75,18 @@ pub fn llvm(build: &Build, target: &str) {\n         (true, true) => \"RelWithDebInfo\",\n     };\n \n+    // NOTE: remember to also update `config.toml.example` when changing the defaults!\n+    let llvm_targets = match build.config.llvm_targets {\n+        Some(ref s) => s,\n+        None => \"X86;ARM;AArch64;Mips;PowerPC;SystemZ;JSBackend;MSP430;Sparc;NVPTX\",\n+    };\n+\n     cfg.target(target)\n        .host(&build.config.build)\n        .out_dir(&dst)\n        .profile(profile)\n        .define(\"LLVM_ENABLE_ASSERTIONS\", assertions)\n-       .define(\"LLVM_TARGETS_TO_BUILD\",\n-               \"X86;ARM;AArch64;Mips;PowerPC;SystemZ;JSBackend;MSP430;Sparc\")\n+       .define(\"LLVM_TARGETS_TO_BUILD\", llvm_targets)\n        .define(\"LLVM_INCLUDE_EXAMPLES\", \"OFF\")\n        .define(\"LLVM_INCLUDE_TESTS\", \"OFF\")\n        .define(\"LLVM_INCLUDE_DOCS\", \"OFF\")"}, {"sha": "6a81f759dc73f8e93203d8093dadbf14b68f1f75", "filename": "src/bootstrap/step.rs", "status": "modified", "additions": 179, "deletions": 102, "changes": 281, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Fbootstrap%2Fstep.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Fbootstrap%2Fstep.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fstep.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -44,7 +44,7 @@ pub fn run(build: &Build) {\n     rules.run(&steps);\n }\n \n-pub fn build_rules(build: &Build) -> Rules {\n+pub fn build_rules<'a>(build: &'a Build) -> Rules {\n     let mut rules = Rules::new(build);\n \n     // This is the first rule that we're going to define for rustbuild, which is\n@@ -117,6 +117,7 @@ pub fn build_rules(build: &Build) -> Rules {\n \n     // the compiler with no target libraries ready to go\n     rules.build(\"rustc\", \"src/rustc\")\n+         .dep(|s| s.name(\"create-sysroot\").target(s.host))\n          .dep(move |s| {\n              if s.stage == 0 {\n                  Step::noop()\n@@ -151,91 +152,153 @@ pub fn build_rules(build: &Build) -> Rules {\n     // Crate compilations\n     //\n     // Tools used during the build system but not shipped\n+    rules.build(\"create-sysroot\", \"path/to/nowhere\")\n+         .run(move |s| compile::create_sysroot(build, &s.compiler()));\n+\n+    // These rules are \"pseudo rules\" that don't actually do any work\n+    // themselves, but represent a complete sysroot with the relevant compiler\n+    // linked into place.\n+    //\n+    // That is, depending on \"libstd\" means that when the rule is completed then\n+    // the `stage` sysroot for the compiler `host` will be available with a\n+    // standard library built for `target` linked in place. Not all rules need\n+    // the compiler itself to be available, just the standard library, so\n+    // there's a distinction between the two.\n     rules.build(\"libstd\", \"src/libstd\")\n-         .dep(|s| s.name(\"build-crate-std_shim\"));\n+         .dep(|s| s.name(\"rustc\").target(s.host))\n+         .dep(|s| s.name(\"libstd-link\"));\n     rules.build(\"libtest\", \"src/libtest\")\n-         .dep(|s| s.name(\"build-crate-test_shim\"));\n+         .dep(|s| s.name(\"libstd\"))\n+         .dep(|s| s.name(\"libtest-link\"))\n+         .default(true);\n     rules.build(\"librustc\", \"src/librustc\")\n-         .dep(|s| s.name(\"build-crate-rustc-main\"));\n+         .dep(|s| s.name(\"libtest\"))\n+         .dep(|s| s.name(\"librustc-link\"))\n+         .host(true)\n+         .default(true);\n+\n+    // Helper method to define the rules to link a crate into its place in the\n+    // sysroot.\n+    //\n+    // The logic here is a little subtle as there's a few cases to consider.\n+    // Not all combinations of (stage, host, target) actually require something\n+    // to be compiled, but rather libraries could get propagated from a\n+    // different location. For example:\n+    //\n+    // * Any crate with a `host` that's not the build triple will not actually\n+    //   compile something. A different `host` means that the build triple will\n+    //   actually compile the libraries, and then we'll copy them over from the\n+    //   build triple to the `host` directory.\n+    //\n+    // * Some crates aren't even compiled by the build triple, but may be copied\n+    //   from previous stages. For example if we're not doing a full bootstrap\n+    //   then we may just depend on the stage1 versions of libraries to be\n+    //   available to get linked forward.\n+    //\n+    // * Finally, there are some cases, however, which do indeed comiple crates\n+    //   and link them into place afterwards.\n+    //\n+    // The rule definition below mirrors these three cases. The `dep` method\n+    // calculates the correct dependency which either comes from stage1, a\n+    // different compiler, or from actually building the crate itself (the `dep`\n+    // rule). The `run` rule then mirrors these three cases and links the cases\n+    // forward into the compiler sysroot specified from the correct location.\n+    fn crate_rule<'a, 'b>(build: &'a Build,\n+                          rules: &'b mut Rules<'a>,\n+                          krate: &'a str,\n+                          dep: &'a str,\n+                          link: fn(&Build, &Compiler, &Compiler, &str))\n+                          -> RuleBuilder<'a, 'b> {\n+        let mut rule = rules.build(&krate, \"path/to/nowhere\");\n+        rule.dep(move |s| {\n+                if build.force_use_stage1(&s.compiler(), s.target) {\n+                    s.host(&build.config.build).stage(1)\n+                } else if s.host == build.config.build {\n+                    s.name(dep)\n+                } else {\n+                    s.host(&build.config.build)\n+                }\n+            })\n+            .run(move |s| {\n+                if build.force_use_stage1(&s.compiler(), s.target) {\n+                    link(build,\n+                         &s.stage(1).host(&build.config.build).compiler(),\n+                         &s.compiler(),\n+                         s.target)\n+                } else if s.host == build.config.build {\n+                    link(build, &s.compiler(), &s.compiler(), s.target)\n+                } else {\n+                    link(build,\n+                         &s.host(&build.config.build).compiler(),\n+                         &s.compiler(),\n+                         s.target)\n+                }\n+            });\n+            return rule\n+    }\n+\n+    // Similar to the `libstd`, `libtest`, and `librustc` rules above, except\n+    // these rules only represent the libraries being available in the sysroot,\n+    // not the compiler itself. This is done as not all rules need a compiler in\n+    // the sysroot, but may just need the libraries.\n+    //\n+    // All of these rules use the helper definition above.\n+    crate_rule(build,\n+               &mut rules,\n+               \"libstd-link\",\n+               \"build-crate-std_shim\",\n+               compile::std_link)\n+        .dep(|s| s.name(\"startup-objects\"))\n+        .dep(|s| s.name(\"create-sysroot\").target(s.host));\n+    crate_rule(build,\n+               &mut rules,\n+               \"libtest-link\",\n+               \"build-crate-test_shim\",\n+               compile::test_link)\n+        .dep(|s| s.name(\"libstd-link\"));\n+    crate_rule(build,\n+               &mut rules,\n+               \"librustc-link\",\n+               \"build-crate-rustc-main\",\n+               compile::rustc_link)\n+        .dep(|s| s.name(\"libtest-link\"));\n+\n     for (krate, path, _default) in krates(\"std_shim\") {\n         rules.build(&krate.build_step, path)\n+             .dep(|s| s.name(\"startup-objects\"))\n              .dep(move |s| s.name(\"rustc\").host(&build.config.build).target(s.host))\n-             .dep(move |s| {\n-                 if s.host == build.config.build {\n-                     Step::noop()\n-                 } else {\n-                    s.host(&build.config.build)\n-                 }\n-             })\n-             .run(move |s| {\n-                 if s.host == build.config.build {\n-                    compile::std(build, s.target, &s.compiler())\n-                 } else {\n-                    compile::std_link(build, s.target, s.stage, s.host)\n-                 }\n-             });\n+             .run(move |s| compile::std(build, s.target, &s.compiler()));\n     }\n-    for (krate, path, default) in krates(\"test_shim\") {\n+    for (krate, path, _default) in krates(\"test_shim\") {\n         rules.build(&krate.build_step, path)\n-             .dep(|s| s.name(\"libstd\"))\n-             .dep(move |s| {\n-                 if s.host == build.config.build {\n-                    Step::noop()\n-                 } else {\n-                    s.host(&build.config.build)\n-                 }\n-             })\n-             .default(default)\n-             .run(move |s| {\n-                 if s.host == build.config.build {\n-                    compile::test(build, s.target, &s.compiler())\n-                 } else {\n-                    compile::test_link(build, s.target, s.stage, s.host)\n-                 }\n-             });\n+             .dep(|s| s.name(\"libstd-link\"))\n+             .run(move |s| compile::test(build, s.target, &s.compiler()));\n     }\n-    for (krate, path, default) in krates(\"rustc-main\") {\n+    for (krate, path, _default) in krates(\"rustc-main\") {\n         rules.build(&krate.build_step, path)\n-             .dep(|s| s.name(\"libtest\"))\n+             .dep(|s| s.name(\"libtest-link\"))\n              .dep(move |s| s.name(\"llvm\").host(&build.config.build).stage(0))\n-             .dep(move |s| {\n-                 if s.host == build.config.build {\n-                    Step::noop()\n-                 } else {\n-                    s.host(&build.config.build)\n-                 }\n-             })\n-             .host(true)\n-             .default(default)\n-             .run(move |s| {\n-                 if s.host == build.config.build {\n-                    compile::rustc(build, s.target, &s.compiler())\n-                 } else {\n-                    compile::rustc_link(build, s.target, s.stage, s.host)\n-                 }\n-             });\n+             .run(move |s| compile::rustc(build, s.target, &s.compiler()));\n     }\n \n+    rules.build(\"startup-objects\", \"src/rtstartup\")\n+         .dep(|s| s.name(\"create-sysroot\").target(s.host))\n+         .run(move |s| compile::build_startup_objects(build, &s.compiler(), s.target));\n+\n     // ========================================================================\n     // Test targets\n     //\n     // Various unit tests and tests suites we can run\n     {\n-        let mut suite = |name, path, dir, mode| {\n+        let mut suite = |name, path, mode, dir| {\n             rules.test(name, path)\n                  .dep(|s| s.name(\"libtest\"))\n-                 .dep(|s| s.name(\"tool-compiletest\").target(s.host))\n+                 .dep(|s| s.name(\"tool-compiletest\").target(s.host).stage(0))\n                  .dep(|s| s.name(\"test-helpers\"))\n-                 .dep(move |s| {\n-                     if s.target.contains(\"android\") {\n-                         s.name(\"android-copy-libs\")\n-                     } else {\n-                         Step::noop()\n-                     }\n-                 })\n-                 .default(true)\n+                 .dep(|s| s.name(\"android-copy-libs\"))\n+                 .default(mode != \"pretty\") // pretty tests don't run everywhere\n                  .run(move |s| {\n-                     check::compiletest(build, &s.compiler(), s.target, dir, mode)\n+                     check::compiletest(build, &s.compiler(), s.target, mode, dir)\n                  });\n         };\n \n@@ -254,50 +317,49 @@ pub fn build_rules(build: &Build) -> Rules {\n         suite(\"check-incremental\", \"src/test/incremental\", \"incremental\",\n               \"incremental\");\n         suite(\"check-ui\", \"src/test/ui\", \"ui\", \"ui\");\n-        suite(\"check-pretty\", \"src/test/pretty\", \"pretty\", \"pretty\");\n-        suite(\"check-pretty-rpass\", \"src/test/run-pass/pretty\", \"pretty\",\n-              \"run-pass\");\n-        suite(\"check-pretty-rfail\", \"src/test/run-pass/pretty\", \"pretty\",\n-              \"run-fail\");\n-        suite(\"check-pretty-valgrind\", \"src/test/run-pass-valgrind\", \"pretty\",\n-              \"run-pass-valgrind\");\n     }\n \n     if build.config.build.contains(\"msvc\") {\n         // nothing to do for debuginfo tests\n-    } else if build.config.build.contains(\"apple\") {\n-        rules.test(\"check-debuginfo\", \"src/test/debuginfo\")\n-             .default(true)\n+    } else {\n+        rules.test(\"check-debuginfo-lldb\", \"src/test/debuginfo-lldb\")\n              .dep(|s| s.name(\"libtest\"))\n-             .dep(|s| s.name(\"tool-compiletest\").target(s.host))\n+             .dep(|s| s.name(\"tool-compiletest\").target(s.host).stage(0))\n              .dep(|s| s.name(\"test-helpers\"))\n              .dep(|s| s.name(\"debugger-scripts\"))\n              .run(move |s| check::compiletest(build, &s.compiler(), s.target,\n                                          \"debuginfo-lldb\", \"debuginfo\"));\n-    } else {\n-        rules.test(\"check-debuginfo\", \"src/test/debuginfo\")\n-             .default(true)\n+        rules.test(\"check-debuginfo-gdb\", \"src/test/debuginfo-gdb\")\n              .dep(|s| s.name(\"libtest\"))\n-             .dep(|s| s.name(\"tool-compiletest\").target(s.host))\n+             .dep(|s| s.name(\"tool-compiletest\").target(s.host).stage(0))\n              .dep(|s| s.name(\"test-helpers\"))\n              .dep(|s| s.name(\"debugger-scripts\"))\n+             .dep(|s| s.name(\"android-copy-libs\"))\n              .run(move |s| check::compiletest(build, &s.compiler(), s.target,\n                                          \"debuginfo-gdb\", \"debuginfo\"));\n+        let mut rule = rules.test(\"check-debuginfo\", \"src/test/debuginfo\");\n+        rule.default(true);\n+        if build.config.build.contains(\"apple\") {\n+            rule.dep(|s| s.name(\"check-debuginfo-lldb\"));\n+        } else {\n+            rule.dep(|s| s.name(\"check-debuginfo-gdb\"));\n+        }\n     }\n \n     rules.test(\"debugger-scripts\", \"src/etc/lldb_batchmode.py\")\n          .run(move |s| dist::debugger_scripts(build, &build.sysroot(&s.compiler()),\n                                          s.target));\n \n     {\n-        let mut suite = |name, path, dir, mode| {\n+        let mut suite = |name, path, mode, dir| {\n             rules.test(name, path)\n                  .dep(|s| s.name(\"librustc\"))\n-                 .dep(|s| s.name(\"tool-compiletest\").target(s.host))\n-                 .default(true)\n+                 .dep(|s| s.name(\"test-helpers\"))\n+                 .dep(|s| s.name(\"tool-compiletest\").target(s.host).stage(0))\n+                 .default(mode != \"pretty\")\n                  .host(true)\n                  .run(move |s| {\n-                     check::compiletest(build, &s.compiler(), s.target, dir, mode)\n+                     check::compiletest(build, &s.compiler(), s.target, mode, dir)\n                  });\n         };\n \n@@ -307,21 +369,30 @@ pub fn build_rules(build: &Build) -> Rules {\n               \"compile-fail\", \"compile-fail-fulldeps\");\n         suite(\"check-rmake\", \"src/test/run-make\", \"run-make\", \"run-make\");\n         suite(\"check-rustdoc\", \"src/test/rustdoc\", \"rustdoc\", \"rustdoc\");\n-        suite(\"check-pretty-rpass-full\", \"src/test/run-pass-fulldeps\",\n+        suite(\"check-pretty\", \"src/test/pretty\", \"pretty\", \"pretty\");\n+        suite(\"check-pretty-rpass\", \"src/test/run-pass/pretty\", \"pretty\",\n+              \"run-pass\");\n+        suite(\"check-pretty-rfail\", \"src/test/run-fail/pretty\", \"pretty\",\n+              \"run-fail\");\n+        suite(\"check-pretty-valgrind\", \"src/test/run-pass-valgrind/pretty\", \"pretty\",\n+              \"run-pass-valgrind\");\n+        suite(\"check-pretty-rpass-full\", \"src/test/run-pass-fulldeps/pretty\",\n               \"pretty\", \"run-pass-fulldeps\");\n-        suite(\"check-pretty-rfail-full\", \"src/test/run-fail-fulldeps\",\n+        suite(\"check-pretty-rfail-full\", \"src/test/run-fail-fulldeps/pretty\",\n               \"pretty\", \"run-fail-fulldeps\");\n     }\n \n     for (krate, path, _default) in krates(\"std_shim\") {\n         rules.test(&krate.test_step, path)\n              .dep(|s| s.name(\"libtest\"))\n+             .dep(|s| s.name(\"android-copy-libs\"))\n              .run(move |s| check::krate(build, &s.compiler(), s.target,\n                                         Mode::Libstd, TestKind::Test,\n                                         Some(&krate.name)));\n     }\n     rules.test(\"check-std-all\", \"path/to/nowhere\")\n          .dep(|s| s.name(\"libtest\"))\n+         .dep(|s| s.name(\"android-copy-libs\"))\n          .default(true)\n          .run(move |s| check::krate(build, &s.compiler(), s.target,\n                                     Mode::Libstd, TestKind::Test, None));\n@@ -330,62 +401,68 @@ pub fn build_rules(build: &Build) -> Rules {\n     for (krate, path, _default) in krates(\"std_shim\") {\n         rules.bench(&krate.bench_step, path)\n              .dep(|s| s.name(\"libtest\"))\n+             .dep(|s| s.name(\"android-copy-libs\"))\n              .run(move |s| check::krate(build, &s.compiler(), s.target,\n                                         Mode::Libstd, TestKind::Bench,\n                                         Some(&krate.name)));\n     }\n     rules.bench(\"bench-std-all\", \"path/to/nowhere\")\n          .dep(|s| s.name(\"libtest\"))\n+         .dep(|s| s.name(\"android-copy-libs\"))\n          .default(true)\n          .run(move |s| check::krate(build, &s.compiler(), s.target,\n                                     Mode::Libstd, TestKind::Bench, None));\n \n     for (krate, path, _default) in krates(\"test_shim\") {\n         rules.test(&krate.test_step, path)\n              .dep(|s| s.name(\"libtest\"))\n+             .dep(|s| s.name(\"android-copy-libs\"))\n              .run(move |s| check::krate(build, &s.compiler(), s.target,\n                                         Mode::Libtest, TestKind::Test,\n                                         Some(&krate.name)));\n     }\n     rules.test(\"check-test-all\", \"path/to/nowhere\")\n          .dep(|s| s.name(\"libtest\"))\n+         .dep(|s| s.name(\"android-copy-libs\"))\n          .default(true)\n          .run(move |s| check::krate(build, &s.compiler(), s.target,\n                                     Mode::Libtest, TestKind::Test, None));\n     for (krate, path, _default) in krates(\"rustc-main\") {\n         rules.test(&krate.test_step, path)\n              .dep(|s| s.name(\"librustc\"))\n+             .dep(|s| s.name(\"android-copy-libs\"))\n              .host(true)\n              .run(move |s| check::krate(build, &s.compiler(), s.target,\n                                         Mode::Librustc, TestKind::Test,\n                                         Some(&krate.name)));\n     }\n     rules.test(\"check-rustc-all\", \"path/to/nowhere\")\n          .dep(|s| s.name(\"librustc\"))\n+         .dep(|s| s.name(\"android-copy-libs\"))\n          .default(true)\n          .host(true)\n          .run(move |s| check::krate(build, &s.compiler(), s.target,\n                                     Mode::Librustc, TestKind::Test, None));\n \n     rules.test(\"check-linkchecker\", \"src/tools/linkchecker\")\n-         .dep(|s| s.name(\"tool-linkchecker\"))\n+         .dep(|s| s.name(\"tool-linkchecker\").stage(0))\n          .dep(|s| s.name(\"default:doc\"))\n          .default(true)\n          .host(true)\n-         .run(move |s| check::linkcheck(build, s.stage, s.target));\n+         .run(move |s| check::linkcheck(build, s.target));\n     rules.test(\"check-cargotest\", \"src/tools/cargotest\")\n-         .dep(|s| s.name(\"tool-cargotest\"))\n+         .dep(|s| s.name(\"tool-cargotest\").stage(0))\n          .dep(|s| s.name(\"librustc\"))\n          .host(true)\n          .run(move |s| check::cargotest(build, s.stage, s.target));\n     rules.test(\"check-tidy\", \"src/tools/tidy\")\n          .dep(|s| s.name(\"tool-tidy\").stage(0))\n          .default(true)\n          .host(true)\n-         .run(move |s| check::tidy(build, 0, s.target));\n+         .run(move |s| check::tidy(build, s.target));\n     rules.test(\"check-error-index\", \"src/tools/error_index_generator\")\n          .dep(|s| s.name(\"libstd\"))\n-         .dep(|s| s.name(\"tool-error-index\").host(s.host))\n+         .dep(|s| s.name(\"tool-error-index\").host(s.host).stage(0))\n          .default(true)\n          .host(true)\n          .run(move |s| check::error_index(build, &s.compiler()));\n@@ -431,38 +508,38 @@ pub fn build_rules(build: &Build) -> Rules {\n     // ========================================================================\n     // Documentation targets\n     rules.doc(\"doc-book\", \"src/doc/book\")\n-         .dep(move |s| s.name(\"tool-rustbook\").target(&build.config.build))\n+         .dep(move |s| s.name(\"tool-rustbook\").target(&build.config.build).stage(0))\n          .default(build.config.docs)\n-         .run(move |s| doc::rustbook(build, s.stage, s.target, \"book\"));\n+         .run(move |s| doc::rustbook(build, s.target, \"book\"));\n     rules.doc(\"doc-nomicon\", \"src/doc/nomicon\")\n-         .dep(move |s| s.name(\"tool-rustbook\").target(&build.config.build))\n+         .dep(move |s| s.name(\"tool-rustbook\").target(&build.config.build).stage(0))\n          .default(build.config.docs)\n-         .run(move |s| doc::rustbook(build, s.stage, s.target, \"nomicon\"));\n+         .run(move |s| doc::rustbook(build, s.target, \"nomicon\"));\n     rules.doc(\"doc-standalone\", \"src/doc\")\n          .dep(move |s| s.name(\"rustc\").host(&build.config.build).target(&build.config.build))\n          .default(build.config.docs)\n          .run(move |s| doc::standalone(build, s.stage, s.target));\n     rules.doc(\"doc-error-index\", \"src/tools/error_index_generator\")\n-         .dep(move |s| s.name(\"tool-error-index\").target(&build.config.build))\n-         .dep(move |s| s.name(\"librustc\"))\n+         .dep(move |s| s.name(\"tool-error-index\").target(&build.config.build).stage(0))\n+         .dep(move |s| s.name(\"librustc-link\").stage(0))\n          .default(build.config.docs)\n          .host(true)\n-         .run(move |s| doc::error_index(build, s.stage, s.target));\n+         .run(move |s| doc::error_index(build, s.target));\n     for (krate, path, default) in krates(\"std_shim\") {\n         rules.doc(&krate.doc_step, path)\n-             .dep(|s| s.name(\"libstd\"))\n+             .dep(|s| s.name(\"libstd-link\"))\n              .default(default && build.config.docs)\n              .run(move |s| doc::std(build, s.stage, s.target));\n     }\n     for (krate, path, default) in krates(\"test_shim\") {\n         rules.doc(&krate.doc_step, path)\n-             .dep(|s| s.name(\"libtest\"))\n+             .dep(|s| s.name(\"libtest-link\"))\n              .default(default && build.config.compiler_docs)\n              .run(move |s| doc::test(build, s.stage, s.target));\n     }\n     for (krate, path, default) in krates(\"rustc-main\") {\n         rules.doc(&krate.doc_step, path)\n-             .dep(|s| s.name(\"librustc\"))\n+             .dep(|s| s.name(\"librustc-link\"))\n              .host(true)\n              .default(default && build.config.compiler_docs)\n              .run(move |s| doc::rustc(build, s.stage, s.target));\n@@ -481,9 +558,9 @@ pub fn build_rules(build: &Build) -> Rules {\n              // for the `rust-std` package, so if this is a host target we\n              // depend on librustc and otherwise we just depend on libtest.\n              if build.config.host.iter().any(|t| t == s.target) {\n-                 s.name(\"librustc\")\n+                 s.name(\"librustc-link\")\n              } else {\n-                 s.name(\"libtest\")\n+                 s.name(\"libtest-link\")\n              }\n          })\n          .default(true)"}, {"sha": "2ab3776ada0966061561d00ba983b30011863a08", "filename": "src/bootstrap/util.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Fbootstrap%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Fbootstrap%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Futil.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -76,9 +76,9 @@ pub fn cp_r(src: &Path, dst: &Path) {\n /// Copies the `src` directory recursively to `dst`. Both are assumed to exist\n /// when this function is called. Unwanted files or directories can be skipped\n /// by returning `false` from the filter function.\n-pub fn cp_filtered<F: Fn(&Path) -> bool>(src: &Path, dst: &Path, filter: &F) {\n+pub fn cp_filtered(src: &Path, dst: &Path, filter: &Fn(&Path) -> bool) {\n     // Inner function does the actual work\n-    fn recurse<F: Fn(&Path) -> bool>(src: &Path, dst: &Path, relative: &Path, filter: &F) {\n+    fn recurse(src: &Path, dst: &Path, relative: &Path, filter: &Fn(&Path) -> bool) {\n         for f in t!(fs::read_dir(src)) {\n             let f = t!(f);\n             let path = f.path();"}, {"sha": "a40e76839eccd8349938fe296bb3a67a0935f564", "filename": "src/ci/docker/arm-android/Dockerfile", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Fci%2Fdocker%2Farm-android%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Fci%2Fdocker%2Farm-android%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Farm-android%2FDockerfile?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -11,7 +11,6 @@ RUN dpkg --add-architecture i386 && \\\n   python2.7 \\\n   git \\\n   cmake \\\n-  ccache \\\n   unzip \\\n   expect \\\n   openjdk-9-jre \\\n@@ -50,5 +49,3 @@ ENV RUST_CONFIGURE_ARGS \\\n       --i686-linux-android-ndk=/android/ndk-x86-9 \\\n       --aarch64-linux-android-ndk=/android/ndk-aarch64\n ENV XPY_CHECK test --target arm-linux-androideabi\n-RUN mkdir /tmp/obj\n-RUN chmod 777 /tmp/obj"}, {"sha": "c5aa323f50cd281adbe462f1f8196f20a6b5cb1c", "filename": "src/ci/docker/cross/Dockerfile", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Fci%2Fdocker%2Fcross%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Fci%2Fdocker%2Fcross%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fcross%2FDockerfile?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -9,7 +9,6 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   python2.7 \\\n   git \\\n   cmake \\\n-  ccache \\\n   sudo \\\n   gcc-aarch64-linux-gnu libc6-dev-arm64-cross \\\n   gcc-arm-linux-gnueabi libc6-dev-armel-cross \\\n@@ -70,6 +69,3 @@ ENV AR_s390x_unknown_linux_gnu=s390x-linux-gnu-ar \\\n \n # FIXME(rust-lang/rust#36150): powerpc unfortunately aborts right now\n ENV NO_LLVM_ASSERTIONS=1\n-\n-RUN mkdir /tmp/obj\n-RUN chmod 777 /tmp/obj"}, {"sha": "1ffb24981c59aaa55d501dd3703057f1d12d3a3b", "filename": "src/ci/docker/i686-gnu-nopt/Dockerfile", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Fci%2Fdocker%2Fi686-gnu-nopt%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Fci%2Fdocker%2Fi686-gnu-nopt%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fi686-gnu-nopt%2FDockerfile?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -9,7 +9,6 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   python2.7 \\\n   git \\\n   cmake \\\n-  ccache \\\n   sudo \\\n   gdb \\\n   xz-utils\n@@ -25,5 +24,3 @@ ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n \n ENV RUST_CONFIGURE_ARGS --build=i686-unknown-linux-gnu --disable-optimize-tests\n ENV RUST_CHECK_TARGET check\n-RUN mkdir /tmp/obj\n-RUN chmod 777 /tmp/obj"}, {"sha": "e4310232d78cf48382fd7b80bdaca5fd4767e296", "filename": "src/ci/docker/i686-gnu/Dockerfile", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Fci%2Fdocker%2Fi686-gnu%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Fci%2Fdocker%2Fi686-gnu%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fi686-gnu%2FDockerfile?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -9,7 +9,6 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   python2.7 \\\n   git \\\n   cmake \\\n-  ccache \\\n   sudo \\\n   gdb \\\n   xz-utils\n@@ -25,5 +24,3 @@ ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n \n ENV RUST_CONFIGURE_ARGS --build=i686-unknown-linux-gnu\n ENV RUST_CHECK_TARGET check\n-RUN mkdir /tmp/obj\n-RUN chmod 777 /tmp/obj"}, {"sha": "86efa74ba3b6f16c6d216ca0b5f158c0c29307be", "filename": "src/ci/docker/x86_64-freebsd/Dockerfile", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Fci%2Fdocker%2Fx86_64-freebsd%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Fci%2Fdocker%2Fx86_64-freebsd%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-freebsd%2FDockerfile?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -9,7 +9,6 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   python2.7 \\\n   git \\\n   cmake \\\n-  ccache \\\n   sudo \\\n   bzip2 \\\n   xz-utils \\\n@@ -33,5 +32,3 @@ ENV \\\n \n ENV RUST_CONFIGURE_ARGS --target=x86_64-unknown-freebsd\n ENV RUST_CHECK_TARGET \"\"\n-RUN mkdir /tmp/obj\n-RUN chmod 777 /tmp/obj"}, {"sha": "0ec0bfd18972516508906b7cc0ddbe6031ae93e6", "filename": "src/ci/docker/x86_64-gnu-aux/Dockerfile", "status": "renamed", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Fci%2Fdocker%2Fx86_64-gnu-aux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Fci%2Fdocker%2Fx86_64-gnu-aux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-aux%2FDockerfile?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -9,7 +9,6 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   python2.7 \\\n   git \\\n   cmake \\\n-  ccache \\\n   libssl-dev \\\n   sudo \\\n   xz-utils \\\n@@ -25,7 +24,5 @@ RUN curl -OL https://github.com/Yelp/dumb-init/releases/download/v1.2.0/dumb-ini\n ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n \n ENV RUST_CONFIGURE_ARGS --build=x86_64-unknown-linux-gnu\n-ENV RUST_CHECK_TARGET check-cargotest\n+ENV RUST_CHECK_TARGET check-aux\n ENV NO_VENDOR 1\n-RUN mkdir /tmp/obj\n-RUN chmod 777 /tmp/obj", "previous_filename": "src/ci/docker/x86_64-gnu-cargotest/Dockerfile"}, {"sha": "9ec8c6059ec31b801319d35af804777af9b0682a", "filename": "src/ci/docker/x86_64-gnu-debug/Dockerfile", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Fci%2Fdocker%2Fx86_64-gnu-debug%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Fci%2Fdocker%2Fx86_64-gnu-debug%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-debug%2FDockerfile?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -9,7 +9,6 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   python2.7 \\\n   git \\\n   cmake \\\n-  ccache \\\n   sudo \\\n   gdb \\\n   xz-utils\n@@ -28,5 +27,3 @@ ENV RUST_CONFIGURE_ARGS \\\n       --enable-debug \\\n       --enable-optimize\n ENV RUST_CHECK_TARGET \"\"\n-RUN mkdir /tmp/obj\n-RUN chmod 777 /tmp/obj"}, {"sha": "880c70866b0f46148aefd4b6e7989054cc66fd4d", "filename": "src/ci/docker/x86_64-gnu-distcheck/Dockerfile", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Fci%2Fdocker%2Fx86_64-gnu-distcheck%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Fci%2Fdocker%2Fx86_64-gnu-distcheck%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-distcheck%2FDockerfile?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -0,0 +1,26 @@\n+FROM ubuntu:16.04\n+\n+RUN apt-get update && apt-get install -y --no-install-recommends \\\n+  g++ \\\n+  make \\\n+  file \\\n+  curl \\\n+  ca-certificates \\\n+  python2.7 \\\n+  git \\\n+  cmake \\\n+  sudo \\\n+  gdb \\\n+  xz-utils\n+\n+ENV SCCACHE_DIGEST=7237e38e029342fa27b7ac25412cb9d52554008b12389727320bd533fd7f05b6a96d55485f305caf95e5c8f5f97c3313e10012ccad3e752aba2518f3522ba783\n+RUN curl -L https://api.pub.build.mozilla.org/tooltool/sha512/$SCCACHE_DIGEST | \\\n+      tar xJf - -C /usr/local/bin --strip-components=1\n+\n+RUN curl -OL https://github.com/Yelp/dumb-init/releases/download/v1.2.0/dumb-init_1.2.0_amd64.deb && \\\n+    dpkg -i dumb-init_*.deb && \\\n+    rm dumb-init_*.deb\n+ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n+\n+ENV RUST_CONFIGURE_ARGS --build=x86_64-unknown-linux-gnu\n+ENV XPY_RUN test distcheck"}, {"sha": "7c079e45751c1acbdf878693be048e8418656fc8", "filename": "src/ci/docker/x86_64-gnu-full-bootstrap/Dockerfile", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Fci%2Fdocker%2Fx86_64-gnu-full-bootstrap%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Fci%2Fdocker%2Fx86_64-gnu-full-bootstrap%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-full-bootstrap%2FDockerfile?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -0,0 +1,28 @@\n+FROM ubuntu:16.04\n+\n+RUN apt-get update && apt-get install -y --no-install-recommends \\\n+  g++ \\\n+  make \\\n+  file \\\n+  curl \\\n+  ca-certificates \\\n+  python2.7 \\\n+  git \\\n+  cmake \\\n+  sudo \\\n+  gdb \\\n+  xz-utils\n+\n+ENV SCCACHE_DIGEST=7237e38e029342fa27b7ac25412cb9d52554008b12389727320bd533fd7f05b6a96d55485f305caf95e5c8f5f97c3313e10012ccad3e752aba2518f3522ba783\n+RUN curl -L https://api.pub.build.mozilla.org/tooltool/sha512/$SCCACHE_DIGEST | \\\n+      tar xJf - -C /usr/local/bin --strip-components=1\n+\n+RUN curl -OL https://github.com/Yelp/dumb-init/releases/download/v1.2.0/dumb-init_1.2.0_amd64.deb && \\\n+    dpkg -i dumb-init_*.deb && \\\n+    rm dumb-init_*.deb\n+ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n+\n+ENV RUST_CONFIGURE_ARGS \\\n+      --build=x86_64-unknown-linux-gnu \\\n+      --enable-full-bootstrap\n+ENV RUST_CHECK_TARGET \"\""}, {"sha": "aabfc0cd1bd8f2067f7b4ea13d18b56bc738a430", "filename": "src/ci/docker/x86_64-gnu-llvm-3.7/Dockerfile", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Fci%2Fdocker%2Fx86_64-gnu-llvm-3.7%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Fci%2Fdocker%2Fx86_64-gnu-llvm-3.7%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-llvm-3.7%2FDockerfile?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -9,7 +9,6 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   python2.7 \\\n   git \\\n   cmake \\\n-  ccache \\\n   sudo \\\n   gdb \\\n   llvm-3.7-tools \\\n@@ -30,5 +29,3 @@ ENV RUST_CONFIGURE_ARGS \\\n       --build=x86_64-unknown-linux-gnu \\\n       --llvm-root=/usr/lib/llvm-3.7\n ENV RUST_CHECK_TARGET check\n-RUN mkdir /tmp/obj\n-RUN chmod 777 /tmp/obj"}, {"sha": "c6071d704f5f6b7cc66ae6ddded1622e2115690a", "filename": "src/ci/docker/x86_64-gnu-make/Dockerfile", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Fci%2Fdocker%2Fx86_64-gnu-make%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Fci%2Fdocker%2Fx86_64-gnu-make%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-make%2FDockerfile?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -9,7 +9,6 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   python2.7 \\\n   git \\\n   cmake \\\n-  ccache \\\n   sudo \\\n   gdb \\\n   xz-utils\n@@ -25,5 +24,3 @@ ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n \n ENV RUST_CONFIGURE_ARGS --build=x86_64-unknown-linux-gnu --disable-rustbuild\n ENV RUST_CHECK_TARGET check\n-RUN mkdir /tmp/obj\n-RUN chmod 777 /tmp/obj"}, {"sha": "d28dc3de1b494bdbfca54481019549f78cd82163", "filename": "src/ci/docker/x86_64-gnu-nopt/Dockerfile", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Fci%2Fdocker%2Fx86_64-gnu-nopt%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Fci%2Fdocker%2Fx86_64-gnu-nopt%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-nopt%2FDockerfile?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -9,7 +9,6 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   python2.7 \\\n   git \\\n   cmake \\\n-  ccache \\\n   sudo \\\n   gdb \\\n   xz-utils\n@@ -25,5 +24,3 @@ ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n \n ENV RUST_CONFIGURE_ARGS --build=x86_64-unknown-linux-gnu --disable-optimize-tests\n ENV RUST_CHECK_TARGET check\n-RUN mkdir /tmp/obj\n-RUN chmod 777 /tmp/obj"}, {"sha": "9d8b75c80c7f242d312b6404800fd968b314d923", "filename": "src/ci/docker/x86_64-gnu/Dockerfile", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Fci%2Fdocker%2Fx86_64-gnu%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Fci%2Fdocker%2Fx86_64-gnu%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu%2FDockerfile?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -9,7 +9,6 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   python2.7 \\\n   git \\\n   cmake \\\n-  ccache \\\n   sudo \\\n   gdb \\\n   xz-utils\n@@ -25,5 +24,3 @@ ENTRYPOINT [\"/usr/bin/dumb-init\", \"--\"]\n \n ENV RUST_CONFIGURE_ARGS --build=x86_64-unknown-linux-gnu\n ENV RUST_CHECK_TARGET check\n-RUN mkdir /tmp/obj\n-RUN chmod 777 /tmp/obj"}, {"sha": "49954157ec023a539dbd87332180dc321741dcaf", "filename": "src/ci/docker/x86_64-musl/Dockerfile", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Fci%2Fdocker%2Fx86_64-musl%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Fci%2Fdocker%2Fx86_64-musl%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-musl%2FDockerfile?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -9,7 +9,6 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   python2.7 \\\n   git \\\n   cmake \\\n-  ccache \\\n   xz-utils \\\n   sudo \\\n   gdb\n@@ -33,6 +32,3 @@ ENV RUST_CONFIGURE_ARGS \\\n ENV RUST_CHECK_TARGET check-stage2-T-x86_64-unknown-linux-musl-H-x86_64-unknown-linux-gnu\n ENV PATH=$PATH:/musl-x86_64/bin\n ENV XPY_CHECK test --target x86_64-unknown-linux-musl\n-\n-RUN mkdir /tmp/obj\n-RUN chmod 777 /tmp/obj"}, {"sha": "3dc3cf915019341036f8dcf910a54d1f355e13e3", "filename": "src/ci/run.sh", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Fci%2Frun.sh", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Fci%2Frun.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Frun.sh?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -43,10 +43,14 @@ else\n     ncpus=$(nproc)\n fi\n \n-make -j $ncpus tidy\n-make -j $ncpus\n-if [ ! -z \"$XPY_CHECK\" ]; then\n-  exec python2.7 $SRC/x.py $XPY_CHECK\n+if [ ! -z \"$XPY_RUN\" ]; then\n+  exec python2.7 $SRC/x.py $XPY_RUN\n else\n-  exec make $RUST_CHECK_TARGET -j $ncpus\n+  make -j $ncpus tidy\n+  make -j $ncpus\n+  if [ ! -z \"$XPY_CHECK\" ]; then\n+    exec python2.7 $SRC/x.py $XPY_CHECK\n+  else\n+    exec make $RUST_CHECK_TARGET -j $ncpus\n+  fi\n fi"}, {"sha": "115fe1f7662322e56d03dc59395ad208ad4eee08", "filename": "src/doc/book/closures.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Fdoc%2Fbook%2Fclosures.md", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Fdoc%2Fbook%2Fclosures.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fclosures.md?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -283,7 +283,7 @@ fn call_with_one<F>(some_closure: F) -> i32\n #    some_closure(1) }\n ```\n \n-We take one parameter, and it has the type `F`. We also return a `i32`. This part\n+We take one parameter, and it has the type `F`. We also return an `i32`. This part\n isn\u2019t interesting. The next part is:\n \n ```rust\n@@ -293,7 +293,7 @@ isn\u2019t interesting. The next part is:\n ```\n \n Because `Fn` is a trait, we can use it as a bound for our generic type. In\n-this case, our closure takes a `i32` as an argument and returns an `i32`, and\n+this case, our closure takes an `i32` as an argument and returns an `i32`, and\n so the generic bound we use is `Fn(i32) -> i32`.\n \n There\u2019s one other key point here: because we\u2019re bounding a generic with a"}, {"sha": "41457ee67a5fdb2d1fe44c7780d1a4ef58c06fbd", "filename": "src/doc/book/ffi.md", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Fdoc%2Fbook%2Fffi.md", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Fdoc%2Fbook%2Fffi.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fffi.md?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -574,6 +574,31 @@ The [`libc` crate on crates.io][libc] includes type aliases and function\n definitions for the C standard library in the `libc` module, and Rust links\n against `libc` and `libm` by default.\n \n+# Variadic functions\n+\n+In C, functions can be 'variadic', meaning they accept a variable number of arguments. This can\n+be achieved in Rust by specifying `...` within the argument list of a foreign function declaration:\n+\n+```no_run\n+extern {\n+    fn foo(x: i32, ...);\n+}\n+\n+fn main() {\n+    unsafe {\n+        foo(10, 20, 30, 40, 50);\n+    }\n+}\n+```\n+\n+Normal Rust functions can *not* be variadic:\n+\n+```ignore\n+// This will not compile\n+\n+fn foo(x: i32, ...) { }\n+```\n+\n # The \"nullable pointer optimization\"\n \n Certain Rust types are defined to never be `null`. This includes references (`&T`,"}, {"sha": "546e66fc8ac02bb7efa753720db987c500fdfef4", "filename": "src/doc/book/lifetimes.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Fdoc%2Fbook%2Flifetimes.md", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Fdoc%2Fbook%2Flifetimes.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Flifetimes.md?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -128,7 +128,7 @@ _descriptive_, not _prescriptive_. This means that how long a reference is valid\n is determined by the code, not by the annotations. The annotations, however,\n give information about lifetimes to the compiler that uses them to check the\n validity of references. The compiler can do so without annotations in simple\n-cases, but needs the programmers support in complex scenarios.\n+cases, but needs the programmer's support in complex scenarios.\n \n [traits]: traits.html\n "}, {"sha": "e1947310a9a28de758bae61f0c35add5f8450dd9", "filename": "src/doc/book/variable-bindings.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Fdoc%2Fbook%2Fvariable-bindings.md", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Fdoc%2Fbook%2Fvariable-bindings.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook%2Fvariable-bindings.md?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -102,7 +102,7 @@ mutation, then the solution is quite easy: add `mut`.\n There are other good reasons to avoid mutable state when possible, but they\u2019re\n out of the scope of this guide. In general, you can often avoid explicit\n mutation, and so it is preferable in Rust. That said, sometimes, mutation is\n-what you need, so it\u2019s not verboten.\n+what you need, so it\u2019s not forbidden.\n \n # Initializing bindings\n "}, {"sha": "9898c31282c34949aa13db715c5b6b27ed12c907", "filename": "src/doc/reference.md", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Fdoc%2Freference.md", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Fdoc%2Freference.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference.md?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -1657,6 +1657,15 @@ Functions within external blocks may be called by Rust code, just like\n functions defined in Rust. The Rust compiler automatically translates between\n the Rust ABI and the foreign ABI.\n \n+Functions within external blocks may be variadic by specifying `...` after one\n+or more named arguments in the argument list:\n+\n+```ignore\n+extern {\n+    fn foo(x: i32, ...);\n+}\n+```\n+\n A number of [attributes](#ffi-attributes) control the behavior of external blocks.\n \n By default external blocks assume that the library they are calling uses the"}, {"sha": "1beaaeb5d8718161e5ceba4a42d9d3fe3b903c07", "filename": "src/etc/platform-intrinsics/nvptx/cuda.json", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Fetc%2Fplatform-intrinsics%2Fnvptx%2Fcuda.json", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Fetc%2Fplatform-intrinsics%2Fnvptx%2Fcuda.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fplatform-intrinsics%2Fnvptx%2Fcuda.json?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -0,0 +1,13 @@\n+{\n+    \"intrinsic_prefix\": \"_\",\n+    \"llvm_prefix\": \"llvm.cuda.\",\n+    \"intrinsics\": [\n+        {\n+            \"intrinsic\": \"syncthreads\",\n+            \"width\": [\"0\"],\n+            \"llvm\": \"syncthreads\",\n+            \"ret\": \"V\",\n+            \"args\": []\n+        }\n+    ]\n+}"}, {"sha": "80332c54e04141dff0866ad6a104fd6225214418", "filename": "src/etc/platform-intrinsics/nvptx/info.json", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Fetc%2Fplatform-intrinsics%2Fnvptx%2Finfo.json", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Fetc%2Fplatform-intrinsics%2Fnvptx%2Finfo.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fplatform-intrinsics%2Fnvptx%2Finfo.json?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -0,0 +1,7 @@\n+{\n+  \"platform\": \"nvptx\",\n+  \"number_info\": {\n+    \"signed\": {}\n+  },\n+  \"width_info\": {}\n+}"}, {"sha": "33d97f2694699d0069d54266135347efe88acaf4", "filename": "src/etc/platform-intrinsics/nvptx/sreg.json", "status": "added", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Fetc%2Fplatform-intrinsics%2Fnvptx%2Fsreg.json", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Fetc%2Fplatform-intrinsics%2Fnvptx%2Fsreg.json", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fplatform-intrinsics%2Fnvptx%2Fsreg.json?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -0,0 +1,90 @@\n+{\n+    \"intrinsic_prefix\": \"_\",\n+    \"llvm_prefix\": \"llvm.nvvm.read.ptx.sreg.\",\n+    \"intrinsics\": [\n+        {\n+            \"intrinsic\": \"block_dim_x\",\n+            \"width\": [\"0\"],\n+            \"llvm\": \"ntid.x\",\n+            \"ret\": \"S32\",\n+            \"args\": []\n+        },\n+        {\n+            \"intrinsic\": \"block_dim_y\",\n+            \"width\": [\"0\"],\n+            \"llvm\": \"ntid.y\",\n+            \"ret\": \"S32\",\n+            \"args\": []\n+        },\n+        {\n+            \"intrinsic\": \"block_dim_z\",\n+            \"width\": [\"0\"],\n+            \"llvm\": \"ntid.z\",\n+            \"ret\": \"S32\",\n+            \"args\": []\n+        },\n+        {\n+            \"intrinsic\": \"block_idx_x\",\n+            \"width\": [\"0\"],\n+            \"llvm\": \"ctaid.x\",\n+            \"ret\": \"S32\",\n+            \"args\": []\n+        },\n+        {\n+            \"intrinsic\": \"block_idx_y\",\n+            \"width\": [\"0\"],\n+            \"llvm\": \"ctaid.y\",\n+            \"ret\": \"S32\",\n+            \"args\": []\n+        },\n+        {\n+            \"intrinsic\": \"block_idx_z\",\n+            \"width\": [\"0\"],\n+            \"llvm\": \"ctaid.z\",\n+            \"ret\": \"S32\",\n+            \"args\": []\n+        },\n+        {\n+            \"intrinsic\": \"grid_dim_x\",\n+            \"width\": [\"0\"],\n+            \"llvm\": \"nctaid.x\",\n+            \"ret\": \"S32\",\n+            \"args\": []\n+        },\n+        {\n+            \"intrinsic\": \"grid_dim_y\",\n+            \"width\": [\"0\"],\n+            \"llvm\": \"nctaid.y\",\n+            \"ret\": \"S32\",\n+            \"args\": []\n+        },\n+        {\n+            \"intrinsic\": \"grid_dim_z\",\n+            \"width\": [\"0\"],\n+            \"llvm\": \"nctaid.z\",\n+            \"ret\": \"S32\",\n+            \"args\": []\n+        },\n+        {\n+            \"intrinsic\": \"thread_idx_x\",\n+            \"width\": [\"0\"],\n+            \"llvm\": \"tid.x\",\n+            \"ret\": \"S32\",\n+            \"args\": []\n+        },\n+        {\n+            \"intrinsic\": \"thread_idx_y\",\n+            \"width\": [\"0\"],\n+            \"llvm\": \"tid.y\",\n+            \"ret\": \"S32\",\n+            \"args\": []\n+        },\n+        {\n+            \"intrinsic\": \"thread_idx_z\",\n+            \"width\": [\"0\"],\n+            \"llvm\": \"tid.z\",\n+            \"ret\": \"S32\",\n+            \"args\": []\n+        }\n+    ]\n+}"}, {"sha": "e1a240a0d2ebad258669f4b17edc5614bca190b9", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -55,24 +55,24 @@ const MAX_REFCOUNT: usize = (isize::MAX) as usize;\n /// [`RwLock`][rwlock], or one of the [`Atomic`][atomic] types.\n ///\n /// `Arc` uses atomic operations for reference counting, so `Arc`s can be\n-/// sent between threads. In other words, `Arc<T>` implements [`Send`][send]\n-/// as long as `T` implements `Send` and [`Sync`][sync]. The disadvantage is\n+/// sent between threads. In other words, `Arc<T>` implements [`Send`]\n+/// as long as `T` implements [`Send`] and [`Sync`][sync]. The disadvantage is\n /// that atomic operations are more expensive than ordinary memory accesses.\n /// If you are not sharing reference-counted values between threads, consider\n-/// using [`rc::Rc`][rc] for lower overhead. `Rc` is a safe default, because\n-/// the compiler will catch any attempt to send an `Rc` between threads.\n+/// using [`rc::Rc`] for lower overhead. [`Rc`] is a safe default, because\n+/// the compiler will catch any attempt to send an [`Rc`] between threads.\n /// However, a library might choose `Arc` in order to give library consumers\n /// more flexibility.\n ///\n /// The [`downgrade`][downgrade] method can be used to create a non-owning\n-/// [`Weak`][weak] pointer. A `Weak` pointer can be [`upgrade`][upgrade]d\n-/// to an `Arc`, but this will return [`None`][option] if the value has\n-/// already been dropped.\n+/// [`Weak`][weak] pointer. A [`Weak`][weak] pointer can be [`upgrade`][upgrade]d\n+/// to an `Arc`, but this will return [`None`] if the value has already been\n+/// dropped.\n ///\n /// A cycle between `Arc` pointers will never be deallocated. For this reason,\n-/// `Weak` is used to break cycles. For example, a tree could have strong\n-/// `Arc` pointers from parent nodes to children, and `Weak` pointers from\n-/// children back to their parents.\n+/// [`Weak`][weak] is used to break cycles. For example, a tree could have\n+/// strong `Arc` pointers from parent nodes to children, and [`Weak`][weak]\n+/// pointers from children back to their parents.\n ///\n /// `Arc<T>` automatically dereferences to `T` (via the [`Deref`][deref] trait),\n /// so you can call `T`'s methods on a value of type `Arc<T>`. To avoid name\n@@ -86,22 +86,22 @@ const MAX_REFCOUNT: usize = (isize::MAX) as usize;\n /// Arc::downgrade(&my_arc);\n /// ```\n ///\n-/// `Weak<T>` does not auto-dereference to `T`, because the value may have\n+/// [`Weak<T>`][weak] does not auto-dereference to `T`, because the value may have\n /// already been destroyed.\n ///\n /// [arc]: struct.Arc.html\n /// [weak]: struct.Weak.html\n-/// [rc]: ../../std/rc/struct.Rc.html\n+/// [`Rc`]: ../../std/rc/struct.Rc.html\n /// [clone]: ../../std/clone/trait.Clone.html#tymethod.clone\n /// [mutex]: ../../std/sync/struct.Mutex.html\n /// [rwlock]: ../../std/sync/struct.RwLock.html\n /// [atomic]: ../../std/sync/atomic/index.html\n-/// [send]: ../../std/marker/trait.Send.html\n+/// [`Send`]: ../../std/marker/trait.Send.html\n /// [sync]: ../../std/marker/trait.Sync.html\n /// [deref]: ../../std/ops/trait.Deref.html\n /// [downgrade]: struct.Arc.html#method.downgrade\n /// [upgrade]: struct.Weak.html#method.upgrade\n-/// [option]: ../../std/option/enum.Option.html\n+/// [`None`]: ../../std/option/enum.Option.html#variant.None\n /// [assoc]: ../../book/method-syntax.html#associated-functions\n ///\n /// # Examples\n@@ -127,7 +127,9 @@ const MAX_REFCOUNT: usize = (isize::MAX) as usize;\n /// }\n /// ```\n ///\n-/// Sharing a mutable `AtomicUsize`:\n+/// Sharing a mutable [`AtomicUsize`]:\n+///\n+/// [`AtomicUsize`]: ../../std/sync/atomic/struct.AtomicUsize.html\n ///\n /// ```no_run\n /// use std::sync::Arc;"}, {"sha": "01393be9949ae2f9cdc5a2c7b4e5a8b3e6a1a3cb", "filename": "src/liballoc_jemalloc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Fliballoc_jemalloc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Fliballoc_jemalloc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_jemalloc%2FCargo.toml?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -9,6 +9,7 @@ links = \"jemalloc\"\n name = \"alloc_jemalloc\"\n path = \"lib.rs\"\n test = false\n+doc = false\n \n [dependencies]\n core = { path = \"../libcore\" }"}, {"sha": "8e3c2c0b9cc66695c58a3a31fca886d42a22e9b4", "filename": "src/liballoc_system/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Fliballoc_system%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Fliballoc_system%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_system%2FCargo.toml?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -7,6 +7,7 @@ version = \"0.0.0\"\n name = \"alloc_system\"\n path = \"lib.rs\"\n test = false\n+doc = false\n \n [dependencies]\n core = { path = \"../libcore\" }"}, {"sha": "1a549ae823ac540e8f9e119dd2164d972a652feb", "filename": "src/libcompiler_builtins/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibcompiler_builtins%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibcompiler_builtins%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcompiler_builtins%2FCargo.toml?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -9,6 +9,7 @@ name = \"compiler_builtins\"\n path = \"lib.rs\"\n test = false\n bench = false\n+doc = false\n \n [dependencies]\n core = { path = \"../libcore\" }"}, {"sha": "1bc9b660001242f04769f22eb500dbe82b92cfb0", "filename": "src/libcompiler_builtins/lib.rs", "status": "modified", "additions": 784, "deletions": 1, "changes": 785, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibcompiler_builtins%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibcompiler_builtins%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcompiler_builtins%2Flib.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -16,4 +16,787 @@\n             issue = \"0\")]\n #![crate_name = \"compiler_builtins\"]\n #![crate_type = \"rlib\"]\n-#![feature(staged_api)]\n+#![allow(unused_features)]\n+#![feature(staged_api, core_intrinsics, repr_simd,\n+           i128_type, core_float, abi_unadjusted, associated_consts)]\n+#![allow(non_camel_case_types, unused_variables, unused_imports)]\n+#![cfg_attr(stage0, allow(dead_code))]\n+\n+#[cfg(any(target_pointer_width=\"32\", target_pointer_width=\"16\", target_os=\"windows\",\n+          target_arch=\"mips64\"))]\n+pub mod reimpls {\n+\n+    #![allow(unused_comparisons)]\n+\n+    use core::intrinsics::unchecked_div;\n+    use core::intrinsics::unchecked_rem;\n+    use core::ptr;\n+\n+    // C API is expected to tolerate some amount of size mismatch in ABI. Hopefully the amount of\n+    // handling is sufficient for bootstrapping.\n+    #[cfg(stage0)]\n+    type u128_ = u64;\n+    #[cfg(stage0)]\n+    type i128_ = i64;\n+    #[cfg(not(stage0))]\n+    type u128_ = u128;\n+    #[cfg(not(stage0))]\n+    type i128_ = i128;\n+\n+    macro_rules! ashl {\n+        ($a:expr, $b:expr, $ty:ty) => {{\n+            let (a, b) = ($a, $b);\n+            let bits = (::core::mem::size_of::<$ty>() * 8) as $ty;\n+            let half_bits = bits >> 1;\n+            if b & half_bits != 0 {\n+                <$ty>::from_parts(0, a.low().wrapping_shl(\n+                                        b.wrapping_sub(half_bits) as u32))\n+            } else if b == 0 {\n+                a\n+            } else {\n+                <$ty>::from_parts(a.low().wrapping_shl(b as u32),\n+                                  a.high().wrapping_shl(b as u32)\n+                                  | a.low()\n+                                     .wrapping_shr(half_bits.wrapping_sub(b) as u32))\n+            }\n+        }}\n+    }\n+\n+    #[export_name=\"__ashlti3\"]\n+    pub extern \"C\" fn shl(a: u128_, b: u128_) -> u128_ {\n+        ashl!(a, b, u128_)\n+    }\n+\n+    macro_rules! ashr {\n+        ($a: expr, $b: expr, $ty:ty) => {{\n+            let (a, b) = ($a, $b);\n+            let bits = (::core::mem::size_of::<$ty>() * 8) as $ty;\n+            let half_bits = bits >> 1;\n+            if b & half_bits != 0 {\n+                <$ty>::from_parts(a.high().wrapping_shr(b.wrapping_sub(half_bits) as u32)\n+                                  as <$ty as LargeInt>::LowHalf,\n+                                  a.high().wrapping_shr(half_bits.wrapping_sub(1) as u32))\n+            } else if b == 0 {\n+                a\n+            } else {\n+                let high_unsigned = a.high() as <$ty as LargeInt>::LowHalf;\n+                <$ty>::from_parts(high_unsigned.wrapping_shl(half_bits.wrapping_sub(b) as u32)\n+                                  | a.low().wrapping_shr(b as u32),\n+                                  a.high().wrapping_shr(b as u32))\n+            }\n+        }}\n+    }\n+\n+    #[export_name=\"__ashrti3\"]\n+    pub extern \"C\" fn shr(a: i128_, b: i128_) -> i128_ {\n+        ashr!(a, b, i128_)\n+    }\n+\n+    macro_rules! lshr {\n+        ($a: expr, $b: expr, $ty:ty) => {{\n+            let (a, b) = ($a, $b);\n+            let bits = (::core::mem::size_of::<$ty>() * 8) as $ty;\n+            let half_bits = bits >> 1;\n+            if b & half_bits != 0 {\n+                <$ty>::from_parts(a.high().wrapping_shr(b.wrapping_sub(half_bits) as u32), 0)\n+            } else if b == 0 {\n+                a\n+            } else {\n+                <$ty>::from_parts(a.high().wrapping_shl(half_bits.wrapping_sub(b) as u32)\n+                                  | a.low().wrapping_shr(b as u32),\n+                                  a.high().wrapping_shr(b as u32))\n+            }\n+        }}\n+    }\n+\n+\n+    #[export_name=\"__lshrti3\"]\n+    pub extern \"C\" fn lshr(a: u128_, b: u128_) -> u128_ {\n+        lshr!(a, b, u128_)\n+    }\n+\n+    #[cfg(stage0)]\n+    pub extern \"C\" fn u128_div_mod(n: u128_, d: u128_, rem: *mut u128_) -> u128_ {\n+        unsafe {\n+        if !rem.is_null() {\n+            *rem = unchecked_rem(n, d);\n+        }\n+        unchecked_div(n, d)\n+        }\n+    }\n+\n+    #[cfg(not(stage0))]\n+    pub extern \"C\" fn u128_div_mod(n: u128_, d: u128_, rem: *mut u128_) -> u128_ {\n+        // Translated from Figure 3-40 of The PowerPC Compiler Writer's Guide\n+        unsafe {\n+        // special cases, X is unknown, K != 0\n+        if n.high() == 0 {\n+            if d.high() == 0 {\n+                // 0 X\n+                // ---\n+                // 0 X\n+                if !rem.is_null() {\n+                    *rem = u128::from(unchecked_rem(n.low(), d.low()));\n+                }\n+                return u128::from(unchecked_div(n.low(), d.low()));\n+            } else {\n+                // 0 X\n+                // ---\n+                // K X\n+                if !rem.is_null() {\n+                    *rem = n;\n+                }\n+                return 0;\n+            };\n+        }\n+\n+        let mut sr;\n+        let mut q;\n+        let mut r;\n+\n+        if d.low() == 0 {\n+            if d.high() == 0 {\n+                // K X\n+                // ---\n+                // 0 0\n+                if !rem.is_null() {\n+                    *rem = u128::from(unchecked_rem(n.high(), d.low()));\n+                }\n+                return u128::from(unchecked_div(n.high(), d.low()));\n+            }\n+\n+            if n.low() == 0 {\n+                // K 0\n+                // ---\n+                // K 0\n+                if !rem.is_null() {\n+                    *rem = u128::from_parts(0, unchecked_rem(n.high(), d.high()));\n+                }\n+                return u128::from(unchecked_div(n.high(), d.high()));\n+            }\n+\n+            // K K\n+            // ---\n+            // K 0\n+\n+            if d.high().is_power_of_two() {\n+                if !rem.is_null() {\n+                    *rem = u128::from_parts(n.low(),\n+                                            n.high() & (d.high().wrapping_sub(1)));\n+                }\n+                return u128::from(n.high().wrapping_shr(d.high().trailing_zeros()));\n+            }\n+\n+            // K K\n+            // ---\n+            // K 0\n+            sr = d.high().leading_zeros().wrapping_sub(n.high().leading_zeros());\n+\n+            // D > N\n+            if sr > 64 - 2 {\n+                if !rem.is_null() {\n+                    *rem = n;\n+                }\n+                return 0;\n+            }\n+\n+            sr = sr.wrapping_add(1);\n+\n+            // 1 <= sr <= u64::bits() - 1\n+            q = n.wrapping_shl(64u32.wrapping_sub(sr));\n+            r = n.wrapping_shr(sr);\n+        } else {\n+            if d.high() == 0 {\n+                // K X\n+                // ---\n+                // 0 K\n+                if d.low().is_power_of_two() {\n+                    if !rem.is_null() {\n+                        *rem = u128::from(n.low() & (d.low().wrapping_sub(1)));\n+                    }\n+\n+                    if d.low() == 1 {\n+                        return n;\n+                    } else {\n+                        let sr = d.low().trailing_zeros();\n+                        return n.wrapping_shr(sr);\n+                    };\n+                }\n+\n+                sr = (1 + 64u32)\n+                    .wrapping_add(d.low().leading_zeros())\n+                    .wrapping_sub(n.high().leading_zeros());\n+\n+                // 2 <= sr <= u64::bits() - 1\n+                q = n.wrapping_shl(128u32.wrapping_sub(sr));\n+                r = n.wrapping_shr(sr);\n+                // FIXME the C compiler-rt implementation has something here\n+                // that looks like a speed optimisation.\n+                // It would be worth a try to port it to Rust too and\n+                // compare the speed.\n+            } else {\n+                // K X\n+                // ---\n+                // K K\n+                sr = d.high().leading_zeros().wrapping_sub(n.high().leading_zeros());\n+\n+                // D > N\n+                if sr > 64 - 1 {\n+                    if !rem.is_null() {\n+                        *rem = n;\n+                    }\n+                    return 0;\n+                }\n+\n+                sr = sr.wrapping_add(1);\n+\n+                // 1 <= sr <= u32::bits()\n+                q = n.wrapping_shl(128u32.wrapping_sub(sr));\n+                r = n.wrapping_shr(sr);\n+            }\n+        }\n+\n+        // Not a special case\n+        // q and r are initialized with\n+        // q = n << (u64::bits() - sr)\n+        // r = n >> sr\n+        // 1 <= sr <= u64::bits() - 1\n+        let mut carry = 0;\n+\n+        // FIXME: replace this with a for loop\n+        // (atm not doable as this generates call to\n+        // eh_personality when optimisations are turned off,\n+        // which in turn gives a linker error in later\n+        // compilation steps)\n+        while sr > 0 {\n+            // r:q = ((r:q) << 1) | carry\n+            r = r.wrapping_shl(1) | q.wrapping_shr(128 - 1);\n+            q = q.wrapping_shl(1) | carry as u128;\n+\n+            // carry = 0\n+            // if r >= d {\n+            //     r -= d;\n+            //     carry = 1;\n+            // }\n+            let s = ((d.wrapping_sub(r).wrapping_sub(1)) as i128).wrapping_shr(128 - 1);\n+            carry = (s & 1) as u64;\n+            r = r.wrapping_sub(d & s as u128);\n+            sr = sr.wrapping_sub(1);\n+        }\n+\n+        if !rem.is_null() {\n+            *rem = r;\n+        }\n+        (q.wrapping_shl(1)) | carry as u128\n+        }\n+    }\n+\n+    fn i128_mod(a: i128_, b: i128_) -> i128_ {\n+        let b = b.uabs();\n+        let sa = a.signum();\n+        let a = a.uabs();\n+        unsafe {\n+            let mut r = ::core::mem::zeroed();\n+            u128_div_mod(a, b, &mut r);\n+            if sa == -1 { (r as i128_).unchecked_neg() } else { r as i128_ }\n+        }\n+    }\n+\n+    fn i128_div(a: i128_, b: i128_) -> i128_ {\n+        let sa = a.signum();\n+        let sb = b.signum();\n+        let a = a.uabs();\n+        let b = b.uabs();\n+        let sr = sa.wrapping_mul(sb); // sign of quotient\n+        (if sr == -1 {\n+            (u128_div_mod(a, b, ptr::null_mut()) as i128_).unchecked_neg()\n+        } else {\n+            u128_div_mod(a, b, ptr::null_mut()) as i128_\n+        })\n+    }\n+\n+    #[cfg(stage0)]\n+    #[export_name=\"__udivti3\"]\n+    pub extern \"C\" fn u128_div(a: u128_, b: u128_) -> u128_ {\n+        (a / b)\n+    }\n+\n+    macro_rules! mulo {\n+        ($a:expr, $b:expr, $o: expr, $ty: ty) => {{\n+            let (a, b, overflow) = ($a, $b, $o);\n+            *overflow = 0;\n+            let result = a.wrapping_mul(b);\n+            if a == <$ty>::min_value() {\n+                if b != 0 && b != 1 {\n+                    *overflow = 1;\n+                }\n+                return result;\n+            }\n+            if b == <$ty>::min_value() {\n+                if a != 0 && a != 1 {\n+                    *overflow = 1;\n+                }\n+                return result;\n+            }\n+\n+            let sa = a.signum();\n+            let abs_a = a.iabs();\n+            let sb = b.signum();\n+            let abs_b = b.iabs();\n+            if abs_a < 2 || abs_b < 2 {\n+                return result;\n+            }\n+            if sa == sb {\n+                if abs_a > unchecked_div(<$ty>::max_value(), abs_b) {\n+                    *overflow = 1;\n+                }\n+            } else {\n+                if abs_a > unchecked_div(<$ty>::min_value(), abs_b.unchecked_neg()) {\n+                    *overflow = 1;\n+                }\n+            }\n+            result\n+        }}\n+    }\n+\n+    pub trait LargeInt {\n+        type LowHalf;\n+        type HighHalf;\n+\n+        fn low(self) -> Self::LowHalf;\n+        fn high(self) -> Self::HighHalf;\n+        fn from_parts(low: Self::LowHalf, high: Self::HighHalf) -> Self;\n+    }\n+    impl LargeInt for u64 {\n+        type LowHalf = u32;\n+        type HighHalf = u32;\n+\n+        fn low(self) -> u32 {\n+            self as u32\n+        }\n+        fn high(self) -> u32 {\n+            (self.wrapping_shr(32)) as u32\n+        }\n+        fn from_parts(low: u32, high: u32) -> u64 {\n+            low as u64 | (high as u64).wrapping_shl(32)\n+        }\n+    }\n+    impl LargeInt for i64 {\n+        type LowHalf = u32;\n+        type HighHalf = i32;\n+\n+        fn low(self) -> u32 {\n+            self as u32\n+        }\n+        fn high(self) -> i32 {\n+            self.wrapping_shr(32) as i32\n+        }\n+        fn from_parts(low: u32, high: i32) -> i64 {\n+            low as i64 | (high as i64).wrapping_shl(32)\n+        }\n+    }\n+    #[cfg(not(stage0))]\n+    impl LargeInt for u128 {\n+        type LowHalf = u64;\n+        type HighHalf = u64;\n+\n+        fn low(self) -> u64 {\n+            self as u64\n+        }\n+        fn high(self) -> u64 {\n+            unsafe { *(&self as *const u128 as *const u64).offset(1) }\n+        }\n+        fn from_parts(low: u64, high: u64) -> u128 {\n+            #[repr(C, packed)] struct Parts(u64, u64);\n+            unsafe { ::core::mem::transmute(Parts(low, high)) }\n+        }\n+    }\n+    #[cfg(not(stage0))]\n+    impl LargeInt for i128 {\n+        type LowHalf = u64;\n+        type HighHalf = i64;\n+\n+        fn low(self) -> u64 {\n+            self as u64\n+        }\n+        fn high(self) -> i64 {\n+            unsafe { *(&self as *const i128 as *const i64).offset(1) }\n+        }\n+        fn from_parts(low: u64, high: i64) -> i128 {\n+            u128::from_parts(low, high as u64) as i128\n+        }\n+    }\n+\n+    macro_rules! mul {\n+        ($a:expr, $b:expr, $ty: ty, $tyh: ty) => {{\n+            let (a, b) = ($a, $b);\n+            let half_bits = ((::core::mem::size_of::<$tyh>() * 8) / 2) as u32;\n+            let lower_mask = (!0u64).wrapping_shr(half_bits);\n+            let mut low = (a.low() & lower_mask).wrapping_mul(b.low() & lower_mask);\n+            let mut t = low.wrapping_shr(half_bits);\n+            low &= lower_mask;\n+            t = t.wrapping_add(a.low().wrapping_shr(half_bits)\n+                                      .wrapping_mul(b.low() & lower_mask));\n+            low = low.wrapping_add((t & lower_mask).wrapping_shl(half_bits));\n+            let mut high = t.wrapping_shr(half_bits) as $tyh;\n+            t = low.wrapping_shr(half_bits);\n+            low &= lower_mask;\n+            t = t.wrapping_add(b.low().wrapping_shr(half_bits)\n+                                      .wrapping_mul(a.low() & lower_mask));\n+            low = low.wrapping_add((t & lower_mask).wrapping_shl(half_bits));\n+            high = high.wrapping_add(t.wrapping_shr(half_bits) as $tyh);\n+            high = high.wrapping_add(a.low().wrapping_shr(half_bits)\n+                           .wrapping_mul(b.low().wrapping_shr(half_bits)) as $tyh);\n+            high = high\n+                .wrapping_add(a.high()\n+                .wrapping_mul(b.low() as $tyh))\n+                .wrapping_add((a.low() as $tyh)\n+                .wrapping_mul(b.high()));\n+            <$ty>::from_parts(low, high)\n+        }}\n+    }\n+\n+    #[cfg(stage0)]\n+    #[export_name=\"__multi3\"]\n+    pub extern \"C\" fn u128_mul(a: i128_, b: i128_) -> i128_ {\n+        ((a as i64).wrapping_mul(b as i64) as i128_)\n+    }\n+\n+    #[cfg(not(stage0))]\n+    #[export_name=\"__multi3\"]\n+    pub extern \"C\" fn u128_mul(a: i128_, b: i128_) -> i128_ {\n+        mul!(a, b, i128_, i64)\n+    }\n+\n+    trait AbsExt: Sized {\n+        fn uabs(self) -> u128_ {\n+            self.iabs() as u128_\n+        }\n+        fn iabs(self) -> i128_;\n+    }\n+\n+    #[cfg(stage0)]\n+    impl AbsExt for i128_ {\n+        fn iabs(self) -> i128_ {\n+            let s = self >> 63;\n+            ((self ^ s).wrapping_sub(s))\n+        }\n+    }\n+\n+    #[cfg(not(stage0))]\n+    impl AbsExt for i128_ {\n+        fn iabs(self) -> i128_ {\n+            let s = self >> 127;\n+            ((self ^ s).wrapping_sub(s))\n+        }\n+    }\n+\n+    trait NegExt: Sized {\n+        fn unchecked_neg(self) -> i128_;\n+    }\n+\n+    impl NegExt for i128_ {\n+        fn unchecked_neg(self) -> i128_ {\n+            (!self).wrapping_add(1)\n+        }\n+    }\n+\n+    trait FloatStuff: Sized {\n+        type ToBytes;\n+\n+        const MANTISSA_BITS: u32;\n+        const MAX_EXP: i32;\n+        const EXP_MASK: Self::ToBytes;\n+        const MANTISSA_MASK: Self::ToBytes;\n+        const MANTISSA_LEAD_BIT: Self::ToBytes;\n+\n+        fn to_bytes(self) -> Self::ToBytes;\n+        fn get_exponent(self) -> i32;\n+    }\n+\n+    impl FloatStuff for f32 {\n+        type ToBytes = u32;\n+        const MANTISSA_BITS: u32 = 23;\n+        const MAX_EXP: i32 = 127;\n+        const EXP_MASK: u32 = 0x7F80_0000;\n+        const MANTISSA_MASK: u32 = 0x007F_FFFF;\n+        const MANTISSA_LEAD_BIT: u32 = 0x0080_0000;\n+\n+        fn to_bytes(self) -> u32 { unsafe { ::core::mem::transmute(self) } }\n+        fn get_exponent(self) -> i32 {\n+            ((self.to_bytes() & Self::EXP_MASK).wrapping_shr(Self::MANTISSA_BITS) as i32)\n+            .wrapping_sub(Self::MAX_EXP)\n+        }\n+    }\n+\n+    impl FloatStuff for f64 {\n+        type ToBytes = u64;\n+        const MANTISSA_BITS: u32 = 52;\n+        const MAX_EXP: i32 = 1023;\n+        const EXP_MASK: u64 = 0x7FF0_0000_0000_0000;\n+        const MANTISSA_MASK: u64 = 0x000F_FFFF_FFFF_FFFF;\n+        const MANTISSA_LEAD_BIT: u64 = 0x0010_0000_0000_0000;\n+\n+        fn to_bytes(self) -> u64 { unsafe { ::core::mem::transmute(self) } }\n+        fn get_exponent(self) -> i32 {\n+            ((self.to_bytes() & Self::EXP_MASK).wrapping_shr(Self::MANTISSA_BITS) as i32)\n+            .wrapping_sub(Self::MAX_EXP)\n+        }\n+    }\n+\n+    macro_rules! float_as_unsigned {\n+        ($from: expr, $fromty: ty, $outty: ty) => { {\n+            use core::num::Float;\n+            let repr = $from.to_bytes();\n+            let sign = $from.signum();\n+            let exponent = $from.get_exponent();\n+            let mantissa_fraction = repr & <$fromty as FloatStuff>::MANTISSA_MASK;\n+            let mantissa = mantissa_fraction | <$fromty as FloatStuff>::MANTISSA_LEAD_BIT;\n+            if sign == -1.0 || exponent < 0 { return 0 as u128_; }\n+            if exponent > ::core::mem::size_of::<$outty>() as i32 * 8 {\n+                return !(0 as u128_);\n+            }\n+            (if exponent < (<$fromty as FloatStuff>::MANTISSA_BITS) as i32 {\n+                (mantissa as $outty)\n+                    .wrapping_shr((<$fromty as FloatStuff>::MANTISSA_BITS as i32)\n+                                  .wrapping_sub(exponent) as u32)\n+            } else {\n+                (mantissa as $outty)\n+                    .wrapping_shl(exponent.wrapping_sub(\n+                        <$fromty as FloatStuff>::MANTISSA_BITS as i32) as u32)\n+            })\n+        } }\n+    }\n+\n+    macro_rules! float_as_signed {\n+        ($from: expr, $fromty: ty, $outty: ty) => {{\n+            use core::num::Float;\n+            let repr = $from.to_bytes();\n+            let sign = $from.signum();\n+            let exponent = $from.get_exponent();\n+            let mantissa_fraction = repr & <$fromty as FloatStuff>::MANTISSA_MASK;\n+            let mantissa = mantissa_fraction | <$fromty as FloatStuff>::MANTISSA_LEAD_BIT;\n+\n+            if exponent < 0 { return 0 as i128_; }\n+            if exponent > ::core::mem::size_of::<$outty>() as i32 * 8 {\n+                let ret = if sign > 0.0 { <$outty>::max_value() } else { <$outty>::min_value() };\n+                return ret\n+            }\n+            let r = if exponent < (<$fromty as FloatStuff>::MANTISSA_BITS) as i32 {\n+                (mantissa as $outty)\n+                    .wrapping_shr((<$fromty as FloatStuff>::MANTISSA_BITS as i32)\n+                                  .wrapping_sub(exponent) as u32)\n+            } else {\n+                (mantissa as $outty)\n+                    .wrapping_shl(exponent.wrapping_sub(\n+                        <$fromty as FloatStuff>::MANTISSA_BITS as i32) as u32)\n+            };\n+            (if sign >= 0.0 { r } else { r.unchecked_neg() })\n+        }}\n+    }\n+\n+\n+    fn i128_as_f64(a: i128_) -> f64 {\n+        match a.signum() {\n+            1 => u128_as_f64(a.uabs()),\n+            0 => 0.0,\n+            _ => -u128_as_f64(a.uabs()),\n+        }\n+    }\n+\n+    fn i128_as_f32(a: i128_) -> f32 {\n+        match a.signum() {\n+            1 => u128_as_f32(a.uabs()),\n+            0 => 0.0,\n+            _ => -u128_as_f32(a.uabs()),\n+        }\n+    }\n+\n+    fn u128_as_f64(mut a: u128_) -> f64 {\n+        use ::core::f64::MANTISSA_DIGITS;\n+        if a == 0 { return 0.0; }\n+        let sd = 128u32.wrapping_sub(a.leading_zeros());\n+        let mut e = sd.wrapping_sub(1);\n+        const MD1 : u32 = MANTISSA_DIGITS + 1;\n+        const MD2 : u32 = MANTISSA_DIGITS + 2;\n+\n+        // SNAP: replace this with !0u128\n+        let negn :u128_ = !0;\n+\n+        if sd > MANTISSA_DIGITS {\n+            a = match sd {\n+                MD1 => a.wrapping_shl(1),\n+                MD2 => a,\n+                _ => a.wrapping_shr(sd.wrapping_sub(MANTISSA_DIGITS + 2)) |\n+                     (if (a & (negn.wrapping_shr(128 + MANTISSA_DIGITS + 2)\n+                                   .wrapping_sub(sd as u128_))) == 0 { 0 } else { 1 })\n+            };\n+            a |= if (a & 4) == 0 { 0 } else { 1 };\n+            a = a.wrapping_add(1);\n+            a = a.wrapping_shr(2);\n+            if a & (1 << MANTISSA_DIGITS) != 0 {\n+                a = a.wrapping_shr(1);\n+                e = e.wrapping_add(1);\n+            }\n+        } else {\n+            a = a.wrapping_shl(MANTISSA_DIGITS.wrapping_sub(sd));\n+        }\n+        unsafe {\n+            ::core::mem::transmute((e as u64).wrapping_add(1023).wrapping_shl(52)\n+                                   | (a as u64 & 0x000f_ffff_ffff_ffff))\n+        }\n+    }\n+\n+    fn u128_as_f32(mut a: u128_) -> f32 {\n+        use ::core::f32::MANTISSA_DIGITS;\n+        if a == 0 { return 0.0; }\n+        let sd = 128u32.wrapping_sub(a.leading_zeros());\n+        let mut e = sd.wrapping_sub(1);\n+        const MD1 : u32 = MANTISSA_DIGITS + 1;\n+        const MD2 : u32 = MANTISSA_DIGITS + 2;\n+\n+        // SNAP: replace this with !0u128\n+        let negn :u128_ = !0;\n+\n+        if sd > MANTISSA_DIGITS {\n+            a = match sd {\n+                MD1 => a.wrapping_shl(1),\n+                MD2 => a,\n+                _ => a.wrapping_shr(sd.wrapping_sub(MANTISSA_DIGITS + 2)) |\n+                     (if (a & (negn.wrapping_shr(128 + MANTISSA_DIGITS + 2)\n+                                   .wrapping_sub(sd as u128_))) == 0 { 0 } else { 1 })\n+            };\n+            a |= if (a & 4) == 0 { 0 } else { 1 };\n+            a = a.wrapping_add(1);\n+            a = a.wrapping_shr(2);\n+            if a & (1 << MANTISSA_DIGITS) != 0 {\n+                a = a.wrapping_shr(1);\n+                e = e.wrapping_add(1);\n+            }\n+        } else {\n+            a = a.wrapping_shl(MANTISSA_DIGITS.wrapping_sub(sd));\n+        }\n+        unsafe {\n+            ::core::mem::transmute((e as u32).wrapping_add(127).wrapping_shl(23)\n+                                   | (a as u32 & 0x007f_ffff))\n+        }\n+    }\n+\n+\n+    macro_rules! why_are_abi_strings_checked_by_parser { ($cret:ty, $conv:expr, $unadj:tt) => {\n+    mod imp {\n+        use super::{i128_, u128_, LargeInt, FloatStuff, NegExt, AbsExt};\n+        use super::{i128_as_f64, i128_as_f32, u128_as_f64, u128_as_f32,\n+                    i128_div, i128_mod, u128_div_mod, unchecked_div, ptr};\n+        // For x64\n+        // rdx:rcx, r9:r8, stack -> rdx:rax\n+        // aka.\n+        // define i128 @__muloti4(i128, i128, i32*)\n+        #[export_name=\"__muloti4\"]\n+        pub unsafe extern $unadj fn i128_mul_oflow(a: i128_, b: i128_, o: *mut i32) -> i128_ {\n+            mulo!(a, b, o, i128_)\n+        }\n+\n+        // For x64\n+        // rdx:rax -> xmm0\n+        // aka.\n+        // define double @__muloti4(i128)\n+        #[export_name=\"__floattidf\"]\n+        pub extern $unadj fn i128_as_f64_(a: i128_) -> f64 {\n+            i128_as_f64(a)\n+        }\n+        #[export_name=\"__floattisf\"]\n+        pub extern $unadj fn i128_as_f32_(a: i128_) -> f32 {\n+            i128_as_f32(a)\n+        }\n+        #[export_name=\"__floatuntidf\"]\n+        pub extern $unadj fn u128_as_f64_(a: u128_) -> f64 {\n+            u128_as_f64(a)\n+        }\n+        #[export_name=\"__floatuntisf\"]\n+        pub extern $unadj fn u128_as_f32_(a: u128_) -> f32 {\n+            u128_as_f32(a)\n+        }\n+\n+        // For x64\n+        // xmm0 -> rdx:rax\n+        // aka.\n+        // define i128 @stuff(double)\n+        #[export_name=\"__fixunsdfti\"]\n+        pub extern $unadj fn f64_as_u128(a: f64) -> u128_ {\n+            float_as_unsigned!(a, f64, u128_)\n+        }\n+\n+        #[export_name=\"__fixunssfti\"]\n+        pub extern \"unadjusted\" fn f32_as_u128(a: f32) -> u128_ {\n+            float_as_unsigned!(a, f32, u128_)\n+        }\n+\n+        #[export_name=\"__fixdfti\"]\n+        pub extern \"unadjusted\" fn f64_as_i128(a: f64) -> i128_ {\n+            float_as_signed!(a, f64, i128_)\n+        }\n+\n+        #[export_name=\"__fixsfti\"]\n+        pub extern \"unadjusted\" fn f32_as_i128(a: f32) -> i128_ {\n+            float_as_signed!(a, f32, i128_)\n+        }\n+\n+        #[repr(simd)]\n+        pub struct u64x2(u64, u64);\n+\n+        // For x64\n+        // pointers -> xmm0\n+        // aka.\n+        // define <2 x u64> @stuff(i128*, i128*, i128*)\n+        //\n+        // That almost matches the C ABI, so we simply use the C ABI\n+        #[export_name=\"__udivmodti4\"]\n+        pub extern \"C\" fn u128_div_mod_(n: u128_, d: u128_, rem: *mut u128_) -> $cret {\n+            let x = u128_div_mod(n, d, rem);\n+            ($conv)(x)\n+        }\n+\n+        #[export_name=\"__udivti3\"]\n+        pub extern \"C\" fn u128_div_(a: u128_, b: u128_) -> $cret {\n+            let x = u128_div_mod(a, b, ptr::null_mut());\n+            ($conv)(x)\n+        }\n+\n+        #[export_name=\"__umodti3\"]\n+        pub extern \"C\" fn u128_mod_(a: u128_, b: u128_) -> $cret {\n+            unsafe {\n+                let mut r = ::core::mem::zeroed();\n+                u128_div_mod(a, b, &mut r);\n+                ($conv)(r)\n+            }\n+        }\n+\n+        #[export_name=\"__divti3\"]\n+        pub extern \"C\" fn i128_div_(a: i128_, b: i128_) -> $cret {\n+            let x = i128_div(a, b);\n+            ($conv)(x as u128_)\n+        }\n+\n+        #[export_name=\"__modti3\"]\n+        pub extern \"C\" fn i128_mod_(a: i128_, b: i128_) -> $cret {\n+            let x = i128_mod(a, b);\n+            ($conv)(x as u128_)\n+        }\n+    }\n+    } }\n+\n+    // LLVM expectations for ABI on windows x64 are pure madness.\n+    #[cfg(not(stage0))]\n+    #[cfg(all(windows, target_pointer_width=\"64\"))]\n+    why_are_abi_strings_checked_by_parser!(u64x2,\n+                                           |i: u128_| u64x2(i.low(), i.high()),\n+                                           \"unadjusted\");\n+\n+    #[cfg(not(stage0))]\n+    #[cfg(not(all(windows, target_pointer_width=\"64\")))]\n+    why_are_abi_strings_checked_by_parser!(u128_, |i|{ i }, \"C\");\n+\n+    #[cfg(not(stage0))]\n+    pub use self::imp::*;\n+}"}, {"sha": "cd2e8f101814199224c64f1a663c145a96e77bbf", "filename": "src/libcore/clone.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibcore%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibcore%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fclone.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -153,12 +153,16 @@ clone_impl! { i8 }\n clone_impl! { i16 }\n clone_impl! { i32 }\n clone_impl! { i64 }\n+#[cfg(not(stage0))]\n+clone_impl! { i128 }\n \n clone_impl! { usize }\n clone_impl! { u8 }\n clone_impl! { u16 }\n clone_impl! { u32 }\n clone_impl! { u64 }\n+#[cfg(not(stage0))]\n+clone_impl! { u128 }\n \n clone_impl! { f32 }\n clone_impl! { f64 }"}, {"sha": "a78d27ea3afc1ea251a73e202ee669ed5ffc0158", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -429,7 +429,7 @@ impl PartialOrd for Ordering {\n /// This trait can be used with `#[derive]`. When `derive`d, it will produce a lexicographic\n /// ordering based on the top-to-bottom declaration order of the struct's members.\n ///\n-/// ## How can I implement `Ord`?\n+/// ## How can I implement `PartialOrd`?\n ///\n /// PartialOrd only requires implementation of the `partial_cmp` method, with the others generated\n /// from default implementations.\n@@ -681,6 +681,8 @@ mod impls {\n     partial_eq_impl! {\n         bool char usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64\n     }\n+    #[cfg(not(stage0))]\n+    partial_eq_impl! { u128 i128 }\n \n     macro_rules! eq_impl {\n         ($($t:ty)*) => ($(\n@@ -690,6 +692,8 @@ mod impls {\n     }\n \n     eq_impl! { () bool char usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n+    #[cfg(not(stage0))]\n+    eq_impl! { u128 i128 }\n \n     macro_rules! partial_ord_impl {\n         ($($t:ty)*) => ($(\n@@ -779,6 +783,8 @@ mod impls {\n     }\n \n     ord_impl! { char usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n+    #[cfg(not(stage0))]\n+    ord_impl! { u128 i128 }\n \n     #[unstable(feature = \"never_type_impls\", issue = \"35121\")]\n     impl PartialEq for ! {"}, {"sha": "ccd4343336f5ecde65dab99ea48a7eca99d361b3", "filename": "src/libcore/default.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibcore%2Fdefault.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibcore%2Fdefault.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fdefault.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -144,12 +144,16 @@ default_impl! { u8, 0 }\n default_impl! { u16, 0 }\n default_impl! { u32, 0 }\n default_impl! { u64, 0 }\n+#[cfg(not(stage0))]\n+default_impl! { u128, 0 }\n \n default_impl! { isize, 0 }\n default_impl! { i8, 0 }\n default_impl! { i16, 0 }\n default_impl! { i32, 0 }\n default_impl! { i64, 0 }\n+#[cfg(not(stage0))]\n+default_impl! { i128, 0 }\n \n default_impl! { f32, 0.0f32 }\n default_impl! { f64, 0.0f64 }"}, {"sha": "cd725392b665ffcd9ed583a90f6c9aff1cb89901", "filename": "src/libcore/fmt/num.rs", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -30,6 +30,8 @@ trait Int: Zero + PartialEq + PartialOrd + Div<Output=Self> + Rem<Output=Self> +\n     fn to_u16(&self) -> u16;\n     fn to_u32(&self) -> u32;\n     fn to_u64(&self) -> u64;\n+    #[cfg(not(stage0))]\n+    fn to_u128(&self) -> u128;\n }\n \n macro_rules! doit {\n@@ -39,9 +41,13 @@ macro_rules! doit {\n         fn to_u16(&self) -> u16 { *self as u16 }\n         fn to_u32(&self) -> u32 { *self as u32 }\n         fn to_u64(&self) -> u64 { *self as u64 }\n+        #[cfg(not(stage0))]\n+        fn to_u128(&self) -> u128 { *self as u128 }\n     })*)\n }\n doit! { i8 i16 i32 i64 isize u8 u16 u32 u64 usize }\n+#[cfg(not(stage0))]\n+doit! { i128 u128 }\n \n /// A type that represents a specific radix\n #[doc(hidden)]\n@@ -59,11 +65,11 @@ trait GenericRadix {\n \n     /// Format an integer using the radix using a formatter.\n     fn fmt_int<T: Int>(&self, mut x: T, f: &mut fmt::Formatter) -> fmt::Result {\n-        // The radix can be as low as 2, so we need a buffer of at least 64\n+        // The radix can be as low as 2, so we need a buffer of at least 128\n         // characters for a base 2 number.\n         let zero = T::zero();\n         let is_nonnegative = x >= zero;\n-        let mut buf = [0; 64];\n+        let mut buf = [0; 128];\n         let mut curr = buf.len();\n         let base = T::from_u8(self.base());\n         if is_nonnegative {\n@@ -182,6 +188,8 @@ integer! { i8, u8 }\n integer! { i16, u16 }\n integer! { i32, u32 }\n integer! { i64, u64 }\n+#[cfg(not(stage0))]\n+integer! { i128, u128 }\n \n const DEC_DIGITS_LUT: &'static[u8] =\n     b\"0001020304050607080910111213141516171819\\\n@@ -203,14 +211,15 @@ macro_rules! impl_Display {\n                 // convert the negative num to positive by summing 1 to it's 2 complement\n                 (!self.$conv_fn()).wrapping_add(1)\n             };\n-            let mut buf: [u8; 20] = unsafe { mem::uninitialized() };\n+            let mut buf: [u8; 39] = unsafe { mem::uninitialized() };\n             let mut curr = buf.len() as isize;\n             let buf_ptr = buf.as_mut_ptr();\n             let lut_ptr = DEC_DIGITS_LUT.as_ptr();\n \n             unsafe {\n-                // eagerly decode 4 characters at a time\n-                if <$t>::max_value() as u64 >= 10000 {\n+                // need at least 16 bits for the 4-characters-at-a-time to work.\n+                if ::mem::size_of::<$t>() >= 2 {\n+                    // eagerly decode 4 characters at a time\n                     while n >= 10000 {\n                         let rem = (n % 10000) as isize;\n                         n /= 10000;\n@@ -256,6 +265,8 @@ macro_rules! impl_Display {\n \n impl_Display!(i8, u8, i16, u16, i32, u32: to_u32);\n impl_Display!(i64, u64: to_u64);\n+#[cfg(not(stage0))]\n+impl_Display!(i128, u128: to_u128);\n #[cfg(target_pointer_width = \"16\")]\n impl_Display!(isize, usize: to_u16);\n #[cfg(target_pointer_width = \"32\")]"}, {"sha": "92657a6d0b1ca3d3a49bf762d0a629f7a1fc42a8", "filename": "src/libcore/hash/mod.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibcore%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibcore%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fmod.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -186,6 +186,13 @@ pub trait Hasher {\n     fn write_u64(&mut self, i: u64) {\n         self.write(&unsafe { mem::transmute::<_, [u8; 8]>(i) })\n     }\n+    #[cfg(not(stage0))]\n+    /// Writes a single `u128` into this hasher.\n+    #[inline]\n+    #[unstable(feature = \"i128\", issue = \"35118\")]\n+    fn write_u128(&mut self, i: u128) {\n+        self.write(&unsafe { mem::transmute::<_, [u8; 16]>(i) })\n+    }\n     /// Writes a single `usize` into this hasher.\n     #[inline]\n     #[stable(feature = \"hasher_write\", since = \"1.3.0\")]\n@@ -220,6 +227,13 @@ pub trait Hasher {\n     fn write_i64(&mut self, i: i64) {\n         self.write_u64(i as u64)\n     }\n+    #[cfg(not(stage0))]\n+    /// Writes a single `i128` into this hasher.\n+    #[inline]\n+    #[unstable(feature = \"i128\", issue = \"35118\")]\n+    fn write_i128(&mut self, i: i128) {\n+        self.write_u128(i as u128)\n+    }\n     /// Writes a single `isize` into this hasher.\n     #[inline]\n     #[stable(feature = \"hasher_write\", since = \"1.3.0\")]\n@@ -362,6 +376,11 @@ mod impls {\n         (i64, write_i64),\n         (isize, write_isize),\n     }\n+    #[cfg(not(stage0))]\n+    impl_write! {\n+        (u128, write_u128),\n+        (i128, write_i128),\n+    }\n \n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     impl Hash for bool {"}, {"sha": "9d22037882f214248c79e71f20e7d157caeb1ea1", "filename": "src/libcore/iter/range.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibcore%2Fiter%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibcore%2Fiter%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Frange.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -242,6 +242,8 @@ step_impl_signed!(i64);\n // assume here that it is less than 64-bits.\n #[cfg(not(target_pointer_width = \"64\"))]\n step_impl_no_between!(u64 i64);\n+#[cfg(not(stage0))]\n+step_impl_no_between!(u128 i128);\n \n /// An adapter for stepping range iterators by a custom amount.\n ///"}, {"sha": "2cb2f81fcffb55da39892a369b2b63cb208e0fd3", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -90,6 +90,7 @@\n #![feature(staged_api)]\n #![feature(unboxed_closures)]\n #![feature(never_type)]\n+#![cfg_attr(not(stage0), feature(i128_type))]\n #![feature(prelude_import)]\n \n #[prelude_import]\n@@ -120,12 +121,20 @@ mod uint_macros;\n #[path = \"num/i32.rs\"]   pub mod i32;\n #[path = \"num/i64.rs\"]   pub mod i64;\n \n+// SNAP\n+#[cfg(not(stage0))]\n+#[path = \"num/i128.rs\"]   pub mod i128;\n+\n #[path = \"num/usize.rs\"] pub mod usize;\n #[path = \"num/u8.rs\"]    pub mod u8;\n #[path = \"num/u16.rs\"]   pub mod u16;\n #[path = \"num/u32.rs\"]   pub mod u32;\n #[path = \"num/u64.rs\"]   pub mod u64;\n \n+// SNAP\n+#[cfg(not(stage0))]\n+#[path = \"num/u128.rs\"]   pub mod u128;\n+\n #[path = \"num/f32.rs\"]   pub mod f32;\n #[path = \"num/f64.rs\"]   pub mod f64;\n "}, {"sha": "539ad00bd30e039b2df991c346358452c8dd7f4b", "filename": "src/libcore/nonzero.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibcore%2Fnonzero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibcore%2Fnonzero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnonzero.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -30,6 +30,10 @@ unsafe impl Zeroable for i32 {}\n unsafe impl Zeroable for u32 {}\n unsafe impl Zeroable for i64 {}\n unsafe impl Zeroable for u64 {}\n+#[cfg(not(stage0))]\n+unsafe impl Zeroable for i128 {}\n+#[cfg(not(stage0))]\n+unsafe impl Zeroable for u128 {}\n \n /// A wrapper type for raw pointers and integers that will never be\n /// NULL or 0 that might allow certain optimizations."}, {"sha": "6268271a1dcc57728d75864e94c06c3e1babf993", "filename": "src/libcore/num/i128.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibcore%2Fnum%2Fi128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibcore%2Fnum%2Fi128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fi128.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! The 128-bit signed integer type.\n+//!\n+//! *[See also the `i128` primitive type](../../std/primitive.i128.html).*\n+\n+#![unstable(feature = \"i128\", issue=\"35118\")]\n+\n+int_module! { i128 }"}, {"sha": "0f3a5baa2dd9ea85c9d5590e5b8ac72f82e66994", "filename": "src/libcore/num/i16.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibcore%2Fnum%2Fi16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibcore%2Fnum%2Fi16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fi16.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -14,4 +14,4 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-int_module! { i16, 16 }\n+int_module! { i16 }"}, {"sha": "ea8b3a9145c6e94bddf791917d64288d2d04eefc", "filename": "src/libcore/num/i32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibcore%2Fnum%2Fi32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibcore%2Fnum%2Fi32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fi32.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -14,4 +14,4 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-int_module! { i32, 32 }\n+int_module! { i32 }"}, {"sha": "aa21b1190aef568f252342cfed8f3dcd965fc7ad", "filename": "src/libcore/num/i64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibcore%2Fnum%2Fi64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibcore%2Fnum%2Fi64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fi64.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -14,4 +14,4 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-int_module! { i64, 64 }\n+int_module! { i64 }"}, {"sha": "1bed4861594c91bcec80ba9e600bf137c88cc5ac", "filename": "src/libcore/num/i8.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibcore%2Fnum%2Fi8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibcore%2Fnum%2Fi8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fi8.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -14,4 +14,4 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-int_module! { i8, 8 }\n+int_module! { i8 }"}, {"sha": "630fac9d92f0f1ec440978a1464ae1207ec98bc8", "filename": "src/libcore/num/int_macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibcore%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibcore%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint_macros.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -10,7 +10,7 @@\n \n #![doc(hidden)]\n \n-macro_rules! int_module { ($T:ident, $bits:expr) => (\n+macro_rules! int_module { ($T:ident) => (\n \n /// The smallest value that can be represented by this integer type.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "e0917f79c43dc83a976e6f8ee45d6a85a2a95706", "filename": "src/libcore/num/isize.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibcore%2Fnum%2Fisize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibcore%2Fnum%2Fisize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fisize.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -14,9 +14,4 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-#[cfg(target_pointer_width = \"16\")]\n-int_module! { isize, 16 }\n-#[cfg(target_pointer_width = \"32\")]\n-int_module! { isize, 32 }\n-#[cfg(target_pointer_width = \"64\")]\n-int_module! { isize, 64 }\n+int_module! { isize }"}, {"sha": "61c687313dcb66e28277addff7edf755128305d8", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 119, "deletions": 12, "changes": 131, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -145,6 +145,8 @@ macro_rules! zero_one_impl {\n     )*)\n }\n zero_one_impl! { u8 u16 u32 u64 usize i8 i16 i32 i64 isize }\n+#[cfg(not(stage0))]\n+zero_one_impl! { u128 i128 }\n \n macro_rules! zero_one_impl_float {\n     ($($t:ty)*) => ($(\n@@ -191,7 +193,7 @@ macro_rules! int_impl {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n         #[inline]\n         pub const fn min_value() -> Self {\n-            (-1 as Self) << ($BITS - 1)\n+            !0 ^ ((!0 as $UnsignedT) >> 1) as Self\n         }\n \n         /// Returns the largest value that can be represented by this integer type.\n@@ -1298,6 +1300,16 @@ impl i64 {\n         intrinsics::mul_with_overflow }\n }\n \n+// SNAP\n+#[cfg(not(stage0))]\n+#[lang = \"i128\"]\n+impl i128 {\n+    int_impl! { i128, u128, 128,\n+        intrinsics::add_with_overflow,\n+        intrinsics::sub_with_overflow,\n+        intrinsics::mul_with_overflow }\n+}\n+\n #[cfg(target_pointer_width = \"16\")]\n #[lang = \"isize\"]\n impl isize {\n@@ -2330,6 +2342,20 @@ impl u64 {\n         intrinsics::mul_with_overflow }\n }\n \n+// SNAP\n+#[cfg(not(stage0))]\n+#[lang = \"u128\"]\n+impl u128 {\n+    uint_impl! { u128, 128,\n+        intrinsics::ctpop,\n+        intrinsics::ctlz,\n+        intrinsics::cttz,\n+        intrinsics::bswap,\n+        intrinsics::add_with_overflow,\n+        intrinsics::sub_with_overflow,\n+        intrinsics::mul_with_overflow }\n+}\n+\n #[cfg(target_pointer_width = \"16\")]\n #[lang = \"usize\"]\n impl usize {\n@@ -2543,6 +2569,8 @@ macro_rules! from_str_radix_int_impl {\n     )*}\n }\n from_str_radix_int_impl! { isize i8 i16 i32 i64 usize u8 u16 u32 u64 }\n+#[cfg(not(stage0))]\n+from_str_radix_int_impl! { u128 i128 }\n \n /// The error type returned when a checked integral type conversion fails.\n #[unstable(feature = \"try_from\", issue = \"33417\")]\n@@ -2567,7 +2595,7 @@ impl fmt::Display for TryFromIntError {\n     }\n }\n \n-macro_rules! same_sign_from_int_impl {\n+macro_rules! same_sign_try_from_int_impl {\n     ($storage:ty, $target:ty, $($source:ty),*) => {$(\n         #[unstable(feature = \"try_from\", issue = \"33417\")]\n         impl TryFrom<$source> for $target {\n@@ -2586,16 +2614,51 @@ macro_rules! same_sign_from_int_impl {\n     )*}\n }\n \n-same_sign_from_int_impl!(u64, u8, u8, u16, u32, u64, usize);\n-same_sign_from_int_impl!(i64, i8, i8, i16, i32, i64, isize);\n-same_sign_from_int_impl!(u64, u16, u8, u16, u32, u64, usize);\n-same_sign_from_int_impl!(i64, i16, i8, i16, i32, i64, isize);\n-same_sign_from_int_impl!(u64, u32, u8, u16, u32, u64, usize);\n-same_sign_from_int_impl!(i64, i32, i8, i16, i32, i64, isize);\n-same_sign_from_int_impl!(u64, u64, u8, u16, u32, u64, usize);\n-same_sign_from_int_impl!(i64, i64, i8, i16, i32, i64, isize);\n-same_sign_from_int_impl!(u64, usize, u8, u16, u32, u64, usize);\n-same_sign_from_int_impl!(i64, isize, i8, i16, i32, i64, isize);\n+#[cfg(stage0)]\n+same_sign_try_from_int_impl!(u64, u8, u8, u16, u32, u64, usize);\n+#[cfg(stage0)]\n+same_sign_try_from_int_impl!(i64, i8, i8, i16, i32, i64, isize);\n+#[cfg(stage0)]\n+same_sign_try_from_int_impl!(u64, u16, u8, u16, u32, u64, usize);\n+#[cfg(stage0)]\n+same_sign_try_from_int_impl!(i64, i16, i8, i16, i32, i64, isize);\n+#[cfg(stage0)]\n+same_sign_try_from_int_impl!(u64, u32, u8, u16, u32, u64, usize);\n+#[cfg(stage0)]\n+same_sign_try_from_int_impl!(i64, i32, i8, i16, i32, i64, isize);\n+#[cfg(stage0)]\n+same_sign_try_from_int_impl!(u64, u64, u8, u16, u32, u64, usize);\n+#[cfg(stage0)]\n+same_sign_try_from_int_impl!(i64, i64, i8, i16, i32, i64, isize);\n+#[cfg(stage0)]\n+same_sign_try_from_int_impl!(u64, usize, u8, u16, u32, u64, usize);\n+#[cfg(stage0)]\n+same_sign_try_from_int_impl!(i64, isize, i8, i16, i32, i64, isize);\n+\n+#[cfg(not(stage0))]\n+same_sign_try_from_int_impl!(u128, u8, u8, u16, u32, u64, u128, usize);\n+#[cfg(not(stage0))]\n+same_sign_try_from_int_impl!(i128, i8, i8, i16, i32, i64, i128, isize);\n+#[cfg(not(stage0))]\n+same_sign_try_from_int_impl!(u128, u16, u8, u16, u32, u64, u128, usize);\n+#[cfg(not(stage0))]\n+same_sign_try_from_int_impl!(i128, i16, i8, i16, i32, i64, i128, isize);\n+#[cfg(not(stage0))]\n+same_sign_try_from_int_impl!(u128, u32, u8, u16, u32, u64, u128, usize);\n+#[cfg(not(stage0))]\n+same_sign_try_from_int_impl!(i128, i32, i8, i16, i32, i64, i128, isize);\n+#[cfg(not(stage0))]\n+same_sign_try_from_int_impl!(u128, u64, u8, u16, u32, u64, u128, usize);\n+#[cfg(not(stage0))]\n+same_sign_try_from_int_impl!(i128, i64, i8, i16, i32, i64, i128, isize);\n+#[cfg(not(stage0))]\n+same_sign_try_from_int_impl!(u128, u128, u8, u16, u32, u64, u128, usize);\n+#[cfg(not(stage0))]\n+same_sign_try_from_int_impl!(i128, i128, i8, i16, i32, i64, i128, isize);\n+#[cfg(not(stage0))]\n+same_sign_try_from_int_impl!(u128, usize, u8, u16, u32, u64, u128, usize);\n+#[cfg(not(stage0))]\n+same_sign_try_from_int_impl!(i128, isize, i8, i16, i32, i64, i128, isize);\n \n macro_rules! cross_sign_from_int_impl {\n     ($unsigned:ty, $($signed:ty),*) => {$(\n@@ -2629,12 +2692,30 @@ macro_rules! cross_sign_from_int_impl {\n     )*}\n }\n \n+#[cfg(stage0)]\n cross_sign_from_int_impl!(u8, i8, i16, i32, i64, isize);\n+#[cfg(stage0)]\n cross_sign_from_int_impl!(u16, i8, i16, i32, i64, isize);\n+#[cfg(stage0)]\n cross_sign_from_int_impl!(u32, i8, i16, i32, i64, isize);\n+#[cfg(stage0)]\n cross_sign_from_int_impl!(u64, i8, i16, i32, i64, isize);\n+#[cfg(stage0)]\n cross_sign_from_int_impl!(usize, i8, i16, i32, i64, isize);\n \n+#[cfg(not(stage0))]\n+cross_sign_from_int_impl!(u8, i8, i16, i32, i64, i128, isize);\n+#[cfg(not(stage0))]\n+cross_sign_from_int_impl!(u16, i8, i16, i32, i64, i128, isize);\n+#[cfg(not(stage0))]\n+cross_sign_from_int_impl!(u32, i8, i16, i32, i64, i128, isize);\n+#[cfg(not(stage0))]\n+cross_sign_from_int_impl!(u64, i8, i16, i32, i64, i128, isize);\n+#[cfg(not(stage0))]\n+cross_sign_from_int_impl!(u128, i8, i16, i32, i64, i128, isize);\n+#[cfg(not(stage0))]\n+cross_sign_from_int_impl!(usize, i8, i16, i32, i64, i128, isize);\n+\n #[doc(hidden)]\n trait FromStrRadixHelper: PartialOrd + Copy {\n     fn min_value() -> Self;\n@@ -2662,6 +2743,8 @@ macro_rules! doit {\n     })*)\n }\n doit! { i8 i16 i32 i64 isize u8 u16 u32 u64 usize }\n+#[cfg(not(stage0))]\n+doit! { i128 u128 }\n \n fn from_str_radix<T: FromStrRadixHelper>(src: &str, radix: u32) -> Result<T, ParseIntError> {\n     use self::IntErrorKind::*;\n@@ -2795,27 +2878,51 @@ macro_rules! impl_from {\n impl_from! { u8, u16 }\n impl_from! { u8, u32 }\n impl_from! { u8, u64 }\n+#[cfg(not(stage0))]\n+impl_from! { u8, u128 }\n impl_from! { u8, usize }\n impl_from! { u16, u32 }\n impl_from! { u16, u64 }\n+#[cfg(not(stage0))]\n+impl_from! { u16, u128 }\n impl_from! { u32, u64 }\n+#[cfg(not(stage0))]\n+impl_from! { u32, u128 }\n+#[cfg(not(stage0))]\n+impl_from! { u64, u128 }\n \n // Signed -> Signed\n impl_from! { i8, i16 }\n impl_from! { i8, i32 }\n impl_from! { i8, i64 }\n+#[cfg(not(stage0))]\n+impl_from! { i8, i128 }\n impl_from! { i8, isize }\n impl_from! { i16, i32 }\n impl_from! { i16, i64 }\n+#[cfg(not(stage0))]\n+impl_from! { i16, i128 }\n impl_from! { i32, i64 }\n+#[cfg(not(stage0))]\n+impl_from! { i32, i128 }\n+#[cfg(not(stage0))]\n+impl_from! { i64, i128 }\n \n // Unsigned -> Signed\n impl_from! { u8, i16 }\n impl_from! { u8, i32 }\n impl_from! { u8, i64 }\n+#[cfg(not(stage0))]\n+impl_from! { u8, i128 }\n impl_from! { u16, i32 }\n impl_from! { u16, i64 }\n+#[cfg(not(stage0))]\n+impl_from! { u16, i128 }\n impl_from! { u32, i64 }\n+#[cfg(not(stage0))]\n+impl_from! { u32, i128 }\n+#[cfg(not(stage0))]\n+impl_from! { u64, i128 }\n \n // Note: integers can only be represented with full precision in a float if\n // they fit in the significand, which is 24 bits in f32 and 53 bits in f64."}, {"sha": "77291f687255e9fbd2961aa3911a27af4e509394", "filename": "src/libcore/num/u128.rs", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibcore%2Fnum%2Fu128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibcore%2Fnum%2Fu128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fu128.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+//! The 128-bit unsigned integer type.\n+//!\n+//! *[See also the `u128` primitive type](../../std/primitive.u128.html).*\n+\n+#![unstable(feature = \"i128\", issue=\"35118\")]\n+uint_module! { u128 }"}, {"sha": "9c318216f1fbaf1bcdee03934e30faf5eae60eee", "filename": "src/libcore/num/u16.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibcore%2Fnum%2Fu16.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibcore%2Fnum%2Fu16.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fu16.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -14,4 +14,4 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-uint_module! { u16, 16 }\n+uint_module! { u16 }"}, {"sha": "84367c2073833c3c5e55d23214c3e7d751414e2b", "filename": "src/libcore/num/u32.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibcore%2Fnum%2Fu32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibcore%2Fnum%2Fu32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fu32.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -14,4 +14,4 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-uint_module! { u32, 32 }\n+uint_module! { u32 }"}, {"sha": "cc48a28b22f69fb79fcb795fd1f6c1392c4063d3", "filename": "src/libcore/num/u64.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibcore%2Fnum%2Fu64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibcore%2Fnum%2Fu64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fu64.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -14,4 +14,4 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-uint_module! { u64, 64 }\n+uint_module! { u64 }"}, {"sha": "6c0daa7763ae1ed45ed46ae997e76115710b704d", "filename": "src/libcore/num/u8.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibcore%2Fnum%2Fu8.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibcore%2Fnum%2Fu8.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fu8.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -14,4 +14,4 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-uint_module! { u8, 8 }\n+uint_module! { u8 }"}, {"sha": "a3a2dc73e9c8e2ee70604b1e2c7ccdaae25901a5", "filename": "src/libcore/num/uint_macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibcore%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibcore%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint_macros.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -10,7 +10,7 @@\n \n #![doc(hidden)]\n \n-macro_rules! uint_module { ($T:ident, $bits:expr) => (\n+macro_rules! uint_module { ($T:ident) => (\n \n /// The smallest value that can be represented by this integer type.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]"}, {"sha": "0b6f1c73c5834c32e496b31d0ad096b7cce02fc4", "filename": "src/libcore/num/usize.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibcore%2Fnum%2Fusize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibcore%2Fnum%2Fusize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fusize.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -14,9 +14,4 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n-#[cfg(target_pointer_width = \"16\")]\n-uint_module! { usize, 16 }\n-#[cfg(target_pointer_width = \"32\")]\n-uint_module! { usize, 32 }\n-#[cfg(target_pointer_width = \"64\")]\n-uint_module! { usize, 64 }\n+uint_module! { usize }"}, {"sha": "b3c2c25551e0d4b9d0b773b34445f388498872b5", "filename": "src/libcore/num/wrapping.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibcore%2Fnum%2Fwrapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibcore%2Fnum%2Fwrapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fwrapping.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -298,6 +298,8 @@ macro_rules! wrapping_impl {\n }\n \n wrapping_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n+#[cfg(not(stage0))]\n+wrapping_impl! { u128 i128 }\n \n mod shift_max {\n     #![allow(non_upper_case_globals)]"}, {"sha": "40d941a8b27e03d84e34cf8fbc06663439718e7d", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -268,6 +268,8 @@ macro_rules! add_impl {\n }\n \n add_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 }\n+#[cfg(not(stage0))]\n+add_impl! { u128 i128 }\n \n /// The `Sub` trait is used to specify the functionality of `-`.\n ///\n@@ -341,6 +343,8 @@ macro_rules! sub_impl {\n }\n \n sub_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 }\n+#[cfg(not(stage0))]\n+sub_impl! { u128 i128 }\n \n /// The `Mul` trait is used to specify the functionality of `*`.\n ///\n@@ -463,6 +467,8 @@ macro_rules! mul_impl {\n }\n \n mul_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 }\n+#[cfg(not(stage0))]\n+mul_impl! { u128 i128 }\n \n /// The `Div` trait is used to specify the functionality of `/`.\n ///\n@@ -592,6 +598,8 @@ macro_rules! div_impl_integer {\n }\n \n div_impl_integer! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n+#[cfg(not(stage0))]\n+div_impl_integer! { u128 i128 }\n \n macro_rules! div_impl_float {\n     ($($t:ty)*) => ($(\n@@ -671,6 +679,9 @@ macro_rules! rem_impl_integer {\n }\n \n rem_impl_integer! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n+#[cfg(not(stage0))]\n+rem_impl_integer! { u128 i128 }\n+\n \n macro_rules! rem_impl_float {\n     ($($t:ty)*) => ($(\n@@ -766,6 +777,8 @@ macro_rules! neg_impl_unsigned {\n \n // neg_impl_unsigned! { usize u8 u16 u32 u64 }\n neg_impl_numeric! { isize i8 i16 i32 i64 f32 f64 }\n+#[cfg(not(stage0))]\n+neg_impl_numeric! { i128 }\n \n /// The `Not` trait is used to specify the functionality of unary `!`.\n ///\n@@ -824,6 +837,8 @@ macro_rules! not_impl {\n }\n \n not_impl! { bool usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n+#[cfg(not(stage0))]\n+not_impl! { u128 i128 }\n \n /// The `BitAnd` trait is used to specify the functionality of `&`.\n ///\n@@ -907,6 +922,8 @@ macro_rules! bitand_impl {\n }\n \n bitand_impl! { bool usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n+#[cfg(not(stage0))]\n+bitand_impl! { u128 i128 }\n \n /// The `BitOr` trait is used to specify the functionality of `|`.\n ///\n@@ -990,6 +1007,8 @@ macro_rules! bitor_impl {\n }\n \n bitor_impl! { bool usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n+#[cfg(not(stage0))]\n+bitor_impl! { u128 i128 }\n \n /// The `BitXor` trait is used to specify the functionality of `^`.\n ///\n@@ -1076,6 +1095,8 @@ macro_rules! bitxor_impl {\n }\n \n bitxor_impl! { bool usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n+#[cfg(not(stage0))]\n+bitxor_impl! { u128 i128 }\n \n /// The `Shl` trait is used to specify the functionality of `<<`.\n ///\n@@ -1166,17 +1187,23 @@ macro_rules! shl_impl_all {\n         shl_impl! { $t, u16 }\n         shl_impl! { $t, u32 }\n         shl_impl! { $t, u64 }\n+        #[cfg(not(stage0))]\n+        shl_impl! { $t, u128 }\n         shl_impl! { $t, usize }\n \n         shl_impl! { $t, i8 }\n         shl_impl! { $t, i16 }\n         shl_impl! { $t, i32 }\n         shl_impl! { $t, i64 }\n+        #[cfg(not(stage0))]\n+        shl_impl! { $t, i128 }\n         shl_impl! { $t, isize }\n     )*)\n }\n \n shl_impl_all! { u8 u16 u32 u64 usize i8 i16 i32 i64 isize }\n+#[cfg(not(stage0))]\n+shl_impl_all! { u128 i128 }\n \n /// The `Shr` trait is used to specify the functionality of `>>`.\n ///\n@@ -1267,17 +1294,23 @@ macro_rules! shr_impl_all {\n         shr_impl! { $t, u16 }\n         shr_impl! { $t, u32 }\n         shr_impl! { $t, u64 }\n+        #[cfg(not(stage0))]\n+        shr_impl! { $t, u128 }\n         shr_impl! { $t, usize }\n \n         shr_impl! { $t, i8 }\n         shr_impl! { $t, i16 }\n         shr_impl! { $t, i32 }\n         shr_impl! { $t, i64 }\n+        #[cfg(not(stage0))]\n+        shr_impl! { $t, i128 }\n         shr_impl! { $t, isize }\n     )*)\n }\n \n shr_impl_all! { u8 u16 u32 u64 usize i8 i16 i32 i64 isize }\n+#[cfg(not(stage0))]\n+shr_impl_all! { u128 i128 }\n \n /// The `AddAssign` trait is used to specify the functionality of `+=`.\n ///\n@@ -1334,6 +1367,8 @@ macro_rules! add_assign_impl {\n }\n \n add_assign_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 }\n+#[cfg(not(stage0))]\n+add_assign_impl! { u128 i128 }\n \n /// The `SubAssign` trait is used to specify the functionality of `-=`.\n ///\n@@ -1390,6 +1425,8 @@ macro_rules! sub_assign_impl {\n }\n \n sub_assign_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 }\n+#[cfg(not(stage0))]\n+sub_assign_impl! { u128 i128 }\n \n /// The `MulAssign` trait is used to specify the functionality of `*=`.\n ///\n@@ -1435,6 +1472,8 @@ macro_rules! mul_assign_impl {\n }\n \n mul_assign_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 }\n+#[cfg(not(stage0))]\n+mul_assign_impl! { u128 i128 }\n \n /// The `DivAssign` trait is used to specify the functionality of `/=`.\n ///\n@@ -1479,6 +1518,8 @@ macro_rules! div_assign_impl {\n }\n \n div_assign_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 }\n+#[cfg(not(stage0))]\n+div_assign_impl! { u128 i128 }\n \n /// The `RemAssign` trait is used to specify the functionality of `%=`.\n ///\n@@ -1523,6 +1564,8 @@ macro_rules! rem_assign_impl {\n }\n \n rem_assign_impl! { usize u8 u16 u32 u64 isize i8 i16 i32 i64 f32 f64 }\n+#[cfg(not(stage0))]\n+rem_assign_impl! { u128 i128 }\n \n /// The `BitAndAssign` trait is used to specify the functionality of `&=`.\n ///\n@@ -1609,6 +1652,8 @@ macro_rules! bitand_assign_impl {\n }\n \n bitand_assign_impl! { bool usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n+#[cfg(not(stage0))]\n+bitand_assign_impl! { u128 i128 }\n \n /// The `BitOrAssign` trait is used to specify the functionality of `|=`.\n ///\n@@ -1653,6 +1698,8 @@ macro_rules! bitor_assign_impl {\n }\n \n bitor_assign_impl! { bool usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n+#[cfg(not(stage0))]\n+bitor_assign_impl! { u128 i128 }\n \n /// The `BitXorAssign` trait is used to specify the functionality of `^=`.\n ///\n@@ -1697,6 +1744,8 @@ macro_rules! bitxor_assign_impl {\n }\n \n bitxor_assign_impl! { bool usize u8 u16 u32 u64 isize i8 i16 i32 i64 }\n+#[cfg(not(stage0))]\n+bitxor_assign_impl! { u128 i128 }\n \n /// The `ShlAssign` trait is used to specify the functionality of `<<=`.\n ///\n@@ -1749,17 +1798,23 @@ macro_rules! shl_assign_impl_all {\n         shl_assign_impl! { $t, u16 }\n         shl_assign_impl! { $t, u32 }\n         shl_assign_impl! { $t, u64 }\n+        #[cfg(not(stage0))]\n+        shl_assign_impl! { $t, u128 }\n         shl_assign_impl! { $t, usize }\n \n         shl_assign_impl! { $t, i8 }\n         shl_assign_impl! { $t, i16 }\n         shl_assign_impl! { $t, i32 }\n         shl_assign_impl! { $t, i64 }\n+        #[cfg(not(stage0))]\n+        shl_assign_impl! { $t, i128 }\n         shl_assign_impl! { $t, isize }\n     )*)\n }\n \n shl_assign_impl_all! { u8 u16 u32 u64 usize i8 i16 i32 i64 isize }\n+#[cfg(not(stage0))]\n+shl_assign_impl_all! { u128 i128 }\n \n /// The `ShrAssign` trait is used to specify the functionality of `>>=`.\n ///\n@@ -1812,17 +1867,23 @@ macro_rules! shr_assign_impl_all {\n         shr_assign_impl! { $t, u16 }\n         shr_assign_impl! { $t, u32 }\n         shr_assign_impl! { $t, u64 }\n+        #[cfg(not(stage0))]\n+        shr_assign_impl! { $t, u128 }\n         shr_assign_impl! { $t, usize }\n \n         shr_assign_impl! { $t, i8 }\n         shr_assign_impl! { $t, i16 }\n         shr_assign_impl! { $t, i32 }\n         shr_assign_impl! { $t, i64 }\n+        #[cfg(not(stage0))]\n+        shr_assign_impl! { $t, i128 }\n         shr_assign_impl! { $t, isize }\n     )*)\n }\n \n shr_assign_impl_all! { u8 u16 u32 u64 usize i8 i16 i32 i64 isize }\n+#[cfg(not(stage0))]\n+shr_assign_impl_all! { u128 i128 }\n \n /// The `Index` trait is used to specify the functionality of indexing operations\n /// like `container[index]` when used in an immutable context."}, {"sha": "752057944715214aa02fbb84308cadb893b04b46", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 123, "deletions": 52, "changes": 175, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -237,11 +237,16 @@ impl AtomicBool {\n \n     /// Loads a value from the bool.\n     ///\n-    /// `load` takes an `Ordering` argument which describes the memory ordering of this operation.\n+    /// `load` takes an [`Ordering`] argument which describes the memory ordering\n+    /// of this operation.\n     ///\n     /// # Panics\n     ///\n-    /// Panics if `order` is `Release` or `AcqRel`.\n+    /// Panics if `order` is [`Release`] or [`AcqRel`].\n+    ///\n+    /// [`Ordering`]: enum.Ordering.html\n+    /// [`Release`]: enum.Ordering.html#variant.Release\n+    /// [`AcqRel`]: enum.Ordering.html#variant.Release\n     ///\n     /// # Examples\n     ///\n@@ -260,7 +265,10 @@ impl AtomicBool {\n \n     /// Stores a value into the bool.\n     ///\n-    /// `store` takes an `Ordering` argument which describes the memory ordering of this operation.\n+    /// `store` takes an [`Ordering`] argument which describes the memory ordering\n+    /// of this operation.\n+    ///\n+    /// [`Ordering`]: enum.Ordering.html\n     ///\n     /// # Examples\n     ///\n@@ -286,7 +294,10 @@ impl AtomicBool {\n \n     /// Stores a value into the bool, returning the old value.\n     ///\n-    /// `swap` takes an `Ordering` argument which describes the memory ordering of this operation.\n+    /// `swap` takes an [`Ordering`] argument which describes the memory ordering\n+    /// of this operation.\n+    ///\n+    /// [`Ordering`]: enum.Ordering.html\n     ///\n     /// # Examples\n     ///\n@@ -309,8 +320,10 @@ impl AtomicBool {\n     /// The return value is always the previous value. If it is equal to `current`, then the value\n     /// was updated.\n     ///\n-    /// `compare_and_swap` also takes an `Ordering` argument which describes the memory ordering of\n-    /// this operation.\n+    /// `compare_and_swap` also takes an [`Ordering`] argument which describes the memory\n+    /// ordering of this operation.\n+    ///\n+    /// [`Ordering`]: enum.Ordering.html\n     ///\n     /// # Examples\n     ///\n@@ -339,10 +352,15 @@ impl AtomicBool {\n     /// The return value is a result indicating whether the new value was written and containing\n     /// the previous value. On success this value is guaranteed to be equal to `current`.\n     ///\n-    /// `compare_exchange` takes two `Ordering` arguments to describe the memory ordering of this\n-    /// operation. The first describes the required ordering if the operation succeeds while the\n-    /// second describes the required ordering when the operation fails. The failure ordering can't\n-    /// be `Release` or `AcqRel` and must be equivalent or weaker than the success ordering.\n+    /// `compare_exchange` takes two [`Ordering`] arguments to describe the memory\n+    /// ordering of this operation. The first describes the required ordering if the\n+    /// operation succeeds while the second describes the required ordering when the\n+    /// operation fails. The failure ordering can't be [`Release`] or [`AcqRel`] and must\n+    /// be equivalent or weaker than the success ordering.\n+    ///\n+    /// [`Ordering`]: enum.Ordering.html\n+    /// [`Release`]: enum.Ordering.html#variant.Release\n+    /// [`AcqRel`]: enum.Ordering.html#variant.Release\n     ///\n     /// # Examples\n     ///\n@@ -387,11 +405,15 @@ impl AtomicBool {\n     /// return value is a result indicating whether the new value was written and containing the\n     /// previous value.\n     ///\n-    /// `compare_exchange_weak` takes two `Ordering` arguments to describe the memory\n+    /// `compare_exchange_weak` takes two [`Ordering`] arguments to describe the memory\n     /// ordering of this operation. The first describes the required ordering if the operation\n     /// succeeds while the second describes the required ordering when the operation fails. The\n-    /// failure ordering can't be `Release` or `AcqRel` and must be equivalent or weaker than the\n-    /// success ordering.\n+    /// failure ordering can't be [`Release`] or [`AcqRel`] and must be equivalent or\n+    /// weaker than the success ordering.\n+    ///\n+    /// [`Ordering`]: enum.Ordering.html\n+    /// [`Release`]: enum.Ordering.html#variant.Release\n+    /// [`AcqRel`]: enum.Ordering.html#variant.Release\n     ///\n     /// # Examples\n     ///\n@@ -619,11 +641,16 @@ impl<T> AtomicPtr<T> {\n \n     /// Loads a value from the pointer.\n     ///\n-    /// `load` takes an `Ordering` argument which describes the memory ordering of this operation.\n+    /// `load` takes an [`Ordering`] argument which describes the memory ordering\n+    /// of this operation.\n     ///\n     /// # Panics\n     ///\n-    /// Panics if `order` is `Release` or `AcqRel`.\n+    /// Panics if `order` is [`Release`] or [`AcqRel`].\n+    ///\n+    /// [`Ordering`]: enum.Ordering.html\n+    /// [`Release`]: enum.Ordering.html#variant.Release\n+    /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n     ///\n     /// # Examples\n     ///\n@@ -643,7 +670,10 @@ impl<T> AtomicPtr<T> {\n \n     /// Stores a value into the pointer.\n     ///\n-    /// `store` takes an `Ordering` argument which describes the memory ordering of this operation.\n+    /// `store` takes an [`Ordering`] argument which describes the memory ordering\n+    /// of this operation.\n+    ///\n+    /// [`Ordering`]: enum.Ordering.html\n     ///\n     /// # Examples\n     ///\n@@ -671,7 +701,10 @@ impl<T> AtomicPtr<T> {\n \n     /// Stores a value into the pointer, returning the old value.\n     ///\n-    /// `swap` takes an `Ordering` argument which describes the memory ordering of this operation.\n+    /// `swap` takes an [`Ordering`] argument which describes the memory ordering\n+    /// of this operation.\n+    ///\n+    /// [`Ordering`]: enum.Ordering.html\n     ///\n     /// # Examples\n     ///\n@@ -696,8 +729,10 @@ impl<T> AtomicPtr<T> {\n     /// The return value is always the previous value. If it is equal to `current`, then the value\n     /// was updated.\n     ///\n-    /// `compare_and_swap` also takes an `Ordering` argument which describes the memory ordering of\n-    /// this operation.\n+    /// `compare_and_swap` also takes an [`Ordering`] argument which describes the memory\n+    /// ordering of this operation.\n+    ///\n+    /// [`Ordering`]: enum.Ordering.html\n     ///\n     /// # Examples\n     ///\n@@ -726,10 +761,15 @@ impl<T> AtomicPtr<T> {\n     /// The return value is a result indicating whether the new value was written and containing\n     /// the previous value. On success this value is guaranteed to be equal to `current`.\n     ///\n-    /// `compare_exchange` takes two `Ordering` arguments to describe the memory ordering of this\n-    /// operation. The first describes the required ordering if the operation succeeds while the\n-    /// second describes the required ordering when the operation fails. The failure ordering can't\n-    /// be `Release` or `AcqRel` and must be equivalent or weaker than the success ordering.\n+    /// `compare_exchange` takes two [`Ordering`] arguments to describe the memory\n+    /// ordering of this operation. The first describes the required ordering if\n+    /// the operation succeeds while the second describes the required ordering when\n+    /// the operation fails. The failure ordering can't be [`Release`] or [`AcqRel`]\n+    /// and must be equivalent or weaker than the success ordering.\n+    ///\n+    /// [`Ordering`]: enum.Ordering.html\n+    /// [`Release`]: enum.Ordering.html#variant.Release\n+    /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n     ///\n     /// # Examples\n     ///\n@@ -768,16 +808,21 @@ impl<T> AtomicPtr<T> {\n \n     /// Stores a value into the pointer if the current value is the same as the `current` value.\n     ///\n-    /// Unlike `compare_exchange`, this function is allowed to spuriously fail even when the\n+    /// Unlike [`compare_exchange`], this function is allowed to spuriously fail even when the\n     /// comparison succeeds, which can result in more efficient code on some platforms. The\n     /// return value is a result indicating whether the new value was written and containing the\n     /// previous value.\n     ///\n-    /// `compare_exchange_weak` takes two `Ordering` arguments to describe the memory\n+    /// `compare_exchange_weak` takes two [`Ordering`] arguments to describe the memory\n     /// ordering of this operation. The first describes the required ordering if the operation\n     /// succeeds while the second describes the required ordering when the operation fails. The\n-    /// failure ordering can't be `Release` or `AcqRel` and must be equivalent or weaker than the\n-    /// success ordering.\n+    /// failure ordering can't be [`Release`] or [`AcqRel`] and must be equivalent or\n+    /// weaker than the success ordering.\n+    ///\n+    /// [`compare_exchange`]: #method.compare_exchange\n+    /// [`Ordering`]: enum.Ordering.html\n+    /// [`Release`]: enum.Ordering.html#variant.Release\n+    /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n     ///\n     /// # Examples\n     ///\n@@ -913,12 +958,16 @@ macro_rules! atomic_int {\n \n             /// Loads a value from the atomic integer.\n             ///\n-            /// `load` takes an `Ordering` argument which describes the memory ordering of this\n+            /// `load` takes an [`Ordering`] argument which describes the memory ordering of this\n             /// operation.\n             ///\n             /// # Panics\n             ///\n-            /// Panics if `order` is `Release` or `AcqRel`.\n+            /// Panics if `order` is [`Release`] or [`AcqRel`].\n+            ///\n+            /// [`Ordering`]: enum.Ordering.html\n+            /// [`Release`]: enum.Ordering.html#variant.Release\n+            /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n             ///\n             /// # Examples\n             ///\n@@ -937,9 +986,11 @@ macro_rules! atomic_int {\n \n             /// Stores a value into the atomic integer.\n             ///\n-            /// `store` takes an `Ordering` argument which describes the memory ordering of this\n+            /// `store` takes an [`Ordering`] argument which describes the memory ordering of this\n             /// operation.\n             ///\n+            /// [`Ordering`]: enum.Ordering.html\n+            ///\n             /// # Examples\n             ///\n             /// ```\n@@ -962,9 +1013,11 @@ macro_rules! atomic_int {\n \n             /// Stores a value into the atomic integer, returning the old value.\n             ///\n-            /// `swap` takes an `Ordering` argument which describes the memory ordering of this\n+            /// `swap` takes an [`Ordering`] argument which describes the memory ordering of this\n             /// operation.\n             ///\n+            /// [`Ordering`]: enum.Ordering.html\n+            ///\n             /// # Examples\n             ///\n             /// ```\n@@ -986,9 +1039,11 @@ macro_rules! atomic_int {\n             /// The return value is always the previous value. If it is equal to `current`, then the\n             /// value was updated.\n             ///\n-            /// `compare_and_swap` also takes an `Ordering` argument which describes the memory\n+            /// `compare_and_swap` also takes an [`Ordering`] argument which describes the memory\n             /// ordering of this operation.\n             ///\n+            /// [`Ordering`]: enum.Ordering.html\n+            ///\n             /// # Examples\n             ///\n             /// ```\n@@ -1024,11 +1079,15 @@ macro_rules! atomic_int {\n             /// containing the previous value. On success this value is guaranteed to be equal to\n             /// `current`.\n             ///\n-            /// `compare_exchange` takes two `Ordering` arguments to describe the memory ordering of\n-            /// this operation. The first describes the required ordering if the operation succeeds\n-            /// while the second describes the required ordering when the operation fails. The\n-            /// failure ordering can't be `Release` or `AcqRel` and must be equivalent or weaker\n-            /// than the success ordering.\n+            /// `compare_exchange` takes two [`Ordering`] arguments to describe the memory\n+            /// ordering of this operation. The first describes the required ordering if\n+            /// the operation succeeds while the second describes the required ordering when\n+            /// the operation fails. The failure ordering can't be [`Release`] or [`AcqRel`] and\n+            /// must be equivalent or weaker than the success ordering.\n+            ///\n+            /// [`Ordering`]: enum.Ordering.html\n+            /// [`Release`]: enum.Ordering.html#variant.Release\n+            /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n             ///\n             /// # Examples\n             ///\n@@ -1062,16 +1121,21 @@ macro_rules! atomic_int {\n             /// Stores a value into the atomic integer if the current value is the same as the\n             /// `current` value.\n             ///\n-            /// Unlike `compare_exchange`, this function is allowed to spuriously fail even when the\n-            /// comparison succeeds, which can result in more efficient code on some platforms. The\n-            /// return value is a result indicating whether the new value was written and containing\n-            /// the previous value.\n+            /// Unlike [`compare_exchange`], this function is allowed to spuriously fail even\n+            /// when the comparison succeeds, which can result in more efficient code on some\n+            /// platforms. The return value is a result indicating whether the new value was\n+            /// written and containing the previous value.\n             ///\n-            /// `compare_exchange_weak` takes two `Ordering` arguments to describe the memory\n+            /// `compare_exchange_weak` takes two [`Ordering`] arguments to describe the memory\n             /// ordering of this operation. The first describes the required ordering if the\n             /// operation succeeds while the second describes the required ordering when the\n-            /// operation fails. The failure ordering can't be `Release` or `AcqRel` and must be\n-            /// equivalent or weaker than the success ordering.\n+            /// operation fails. The failure ordering can't be [`Release`] or [`AcqRel`] and\n+            /// must be equivalent or weaker than the success ordering.\n+            ///\n+            /// [`compare_exchange`]: #method.compare_exchange\n+            /// [`Ordering`]: enum.Ordering.html\n+            /// [`Release`]: enum.Ordering.html#variant.Release\n+            /// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n             ///\n             /// # Examples\n             ///\n@@ -1431,24 +1495,31 @@ unsafe fn atomic_xor<T>(dst: *mut T, val: T, order: Ordering) -> T {\n \n /// An atomic fence.\n ///\n-/// A fence 'A' which has `Release` ordering semantics, synchronizes with a\n-/// fence 'B' with (at least) `Acquire` semantics, if and only if there exists\n+/// A fence 'A' which has [`Release`] ordering semantics, synchronizes with a\n+/// fence 'B' with (at least) [`Acquire`] semantics, if and only if there exists\n /// atomic operations X and Y, both operating on some atomic object 'M' such\n /// that A is sequenced before X, Y is synchronized before B and Y observes\n /// the change to M. This provides a happens-before dependence between A and B.\n ///\n-/// Atomic operations with `Release` or `Acquire` semantics can also synchronize\n+/// Atomic operations with [`Release`] or [`Acquire`] semantics can also synchronize\n /// with a fence.\n ///\n-/// A fence which has `SeqCst` ordering, in addition to having both `Acquire`\n-/// and `Release` semantics, participates in the global program order of the\n-/// other `SeqCst` operations and/or fences.\n+/// A fence which has [`SeqCst`] ordering, in addition to having both [`Acquire`]\n+/// and [`Release`] semantics, participates in the global program order of the\n+/// other [`SeqCst`] operations and/or fences.\n ///\n-/// Accepts `Acquire`, `Release`, `AcqRel` and `SeqCst` orderings.\n+/// Accepts [`Acquire`], [`Release`], [`AcqRel`] and [`SeqCst`] orderings.\n ///\n /// # Panics\n ///\n-/// Panics if `order` is `Relaxed`.\n+/// Panics if `order` is [`Relaxed`].\n+///\n+/// [`Ordering`]: enum.Ordering.html\n+/// [`Acquire`]: enum.Ordering.html#variant.Acquire\n+/// [`SeqCst`]: enum.Ordering.html#variant.SeqCst\n+/// [`Release`]: enum.Ordering.html#variant.Release\n+/// [`AcqRel`]: enum.Ordering.html#variant.AcqRel\n+/// [`Relaxed`]: enum.Ordering.html#variant.Relaxed\n #[inline]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub fn fence(order: Ordering) {"}, {"sha": "e0eac41f49ec92b1ada6f8c0c027e811161fcd2a", "filename": "src/libpanic_abort/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibpanic_abort%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibpanic_abort%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_abort%2FCargo.toml?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -7,6 +7,7 @@ version = \"0.0.0\"\n path = \"lib.rs\"\n test = false\n bench = false\n+doc = false\n \n [dependencies]\n core = { path = \"../libcore\" }"}, {"sha": "a978ea16e9e74245ecd355fe6dab581c6d005463", "filename": "src/libpanic_unwind/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibpanic_unwind%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibpanic_unwind%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibpanic_unwind%2FCargo.toml?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -7,6 +7,7 @@ version = \"0.0.0\"\n path = \"lib.rs\"\n test = false\n bench = false\n+doc = false\n \n [dependencies]\n alloc = { path = \"../liballoc\" }"}, {"sha": "eda5f217565de80a1876fc146ff4d925fa63a159", "filename": "src/librand/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrand%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrand%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrand%2FCargo.toml?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -6,6 +6,7 @@ version = \"0.0.0\"\n [lib]\n name = \"rand\"\n path = \"lib.rs\"\n+doc = false\n \n [dependencies]\n core = { path = \"../libcore\" }"}, {"sha": "51494885e73696addcd84337051035bbbfdbef5f", "filename": "src/librustc/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2FCargo.toml?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -20,6 +20,7 @@ rustc_const_math = { path = \"../librustc_const_math\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_errors = { path = \"../librustc_errors\" }\n rustc_llvm = { path = \"../librustc_llvm\" }\n+rustc_i128 = { path = \"../librustc_i128\" }\n serialize = { path = \"../libserialize\" }\n syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }"}, {"sha": "73ec9d8f8c8805ee0f56350277a48ed0515fb5a0", "filename": "src/librustc/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flib.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -62,6 +62,9 @@ extern crate rustc_errors as errors;\n \n extern crate serialize as rustc_serialize; // used by deriving\n \n+// SNAP:\n+extern crate rustc_i128;\n+\n #[cfg(test)]\n extern crate test;\n "}, {"sha": "cd7859af8ee7b526a96e1d1776d4ef4a3641f89a", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -260,11 +260,13 @@ language_item_table! {\n     I16ImplItem,                     \"i16\",                     i16_impl;\n     I32ImplItem,                     \"i32\",                     i32_impl;\n     I64ImplItem,                     \"i64\",                     i64_impl;\n+    I128ImplItem,                     \"i128\",                   i128_impl;\n     IsizeImplItem,                   \"isize\",                   isize_impl;\n     U8ImplItem,                      \"u8\",                      u8_impl;\n     U16ImplItem,                     \"u16\",                     u16_impl;\n     U32ImplItem,                     \"u32\",                     u32_impl;\n     U64ImplItem,                     \"u64\",                     u64_impl;\n+    U128ImplItem,                    \"u128\",                    u128_impl;\n     UsizeImplItem,                   \"usize\",                   usize_impl;\n     F32ImplItem,                     \"f32\",                     f32_impl;\n     F64ImplItem,                     \"f64\",                     f64_impl;"}, {"sha": "380c5b0eb6f3b5bca9cd6ee080c1fc07b88c073b", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -194,11 +194,13 @@ pub struct CommonTypes<'tcx> {\n     pub i16: Ty<'tcx>,\n     pub i32: Ty<'tcx>,\n     pub i64: Ty<'tcx>,\n+    pub i128: Ty<'tcx>,\n     pub usize: Ty<'tcx>,\n     pub u8: Ty<'tcx>,\n     pub u16: Ty<'tcx>,\n     pub u32: Ty<'tcx>,\n     pub u64: Ty<'tcx>,\n+    pub u128: Ty<'tcx>,\n     pub f32: Ty<'tcx>,\n     pub f64: Ty<'tcx>,\n     pub never: Ty<'tcx>,\n@@ -359,11 +361,13 @@ impl<'tcx> CommonTypes<'tcx> {\n             i16: mk(TyInt(ast::IntTy::I16)),\n             i32: mk(TyInt(ast::IntTy::I32)),\n             i64: mk(TyInt(ast::IntTy::I64)),\n+            i128: mk(TyInt(ast::IntTy::I128)),\n             usize: mk(TyUint(ast::UintTy::Us)),\n             u8: mk(TyUint(ast::UintTy::U8)),\n             u16: mk(TyUint(ast::UintTy::U16)),\n             u32: mk(TyUint(ast::UintTy::U32)),\n             u64: mk(TyUint(ast::UintTy::U64)),\n+            u128: mk(TyUint(ast::UintTy::U128)),\n             f32: mk(TyFloat(ast::FloatTy::F32)),\n             f64: mk(TyFloat(ast::FloatTy::F64)),\n         }\n@@ -1304,6 +1308,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             ast::IntTy::I16  => self.types.i16,\n             ast::IntTy::I32  => self.types.i32,\n             ast::IntTy::I64  => self.types.i64,\n+            ast::IntTy::I128  => self.types.i128,\n         }\n     }\n \n@@ -1314,6 +1319,7 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             ast::UintTy::U16  => self.types.u16,\n             ast::UintTy::U32  => self.types.u32,\n             ast::UintTy::U64  => self.types.u64,\n+            ast::UintTy::U128  => self.types.u128,\n         }\n     }\n "}, {"sha": "ff95554dbbfcd6a36fac3b77c6c2f1ce0c590ee9", "filename": "src/librustc/ty/layout.rs", "status": "modified", "additions": 58, "deletions": 23, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Flayout.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -20,6 +20,8 @@ use ty::{self, Ty, TyCtxt, TypeFoldable};\n use syntax::ast::{FloatTy, IntTy, UintTy};\n use syntax::attr;\n use syntax_pos::DUMMY_SP;\n+use rustc_i128::u128;\n+use rustc_const_math::ConstInt;\n \n use std::cmp;\n use std::fmt;\n@@ -35,6 +37,7 @@ pub struct TargetDataLayout {\n     pub i16_align: Align,\n     pub i32_align: Align,\n     pub i64_align: Align,\n+    pub i128_align: Align,\n     pub f32_align: Align,\n     pub f64_align: Align,\n     pub pointer_size: Size,\n@@ -55,6 +58,7 @@ impl Default for TargetDataLayout {\n             i16_align: Align::from_bits(16, 16).unwrap(),\n             i32_align: Align::from_bits(32, 32).unwrap(),\n             i64_align: Align::from_bits(32, 64).unwrap(),\n+            i128_align: Align::from_bits(32, 64).unwrap(),\n             f32_align: Align::from_bits(32, 32).unwrap(),\n             f64_align: Align::from_bits(64, 64).unwrap(),\n             pointer_size: Size::from_bits(64),\n@@ -99,6 +103,7 @@ impl TargetDataLayout {\n         };\n \n         let mut dl = TargetDataLayout::default();\n+        let mut i128_align_src = 64;\n         for spec in sess.target.target.data_layout.split(\"-\") {\n             match &spec.split(\":\").collect::<Vec<_>>()[..] {\n                 &[\"e\"] => dl.endian = Endian::Little,\n@@ -111,19 +116,28 @@ impl TargetDataLayout {\n                     dl.pointer_align = align(a, p);\n                 }\n                 &[s, ref a..] if s.starts_with(\"i\") => {\n-                    let ty_align = match s[1..].parse::<u64>() {\n-                        Ok(1) => &mut dl.i8_align,\n-                        Ok(8) => &mut dl.i8_align,\n-                        Ok(16) => &mut dl.i16_align,\n-                        Ok(32) => &mut dl.i32_align,\n-                        Ok(64) => &mut dl.i64_align,\n-                        Ok(_) => continue,\n+                    let bits = match s[1..].parse::<u64>() {\n+                        Ok(bits) => bits,\n                         Err(_) => {\n                             size(&s[1..], \"i\"); // For the user error.\n                             continue;\n                         }\n                     };\n-                    *ty_align = align(a, s);\n+                    let a = align(a, s);\n+                    match bits {\n+                        1 => dl.i1_align = a,\n+                        8 => dl.i8_align = a,\n+                        16 => dl.i16_align = a,\n+                        32 => dl.i32_align = a,\n+                        64 => dl.i64_align = a,\n+                        _ => {}\n+                    }\n+                    if bits >= i128_align_src && bits <= 128 {\n+                        // Default alignment for i128 is decided by taking the alignment of\n+                        // largest-sized i{64...128}.\n+                        i128_align_src = bits;\n+                        dl.i128_align = a;\n+                    }\n                 }\n                 &[s, ref a..] if s.starts_with(\"v\") => {\n                     let v_size = size(&s[1..], \"v\");\n@@ -325,7 +339,8 @@ pub enum Integer {\n     I8,\n     I16,\n     I32,\n-    I64\n+    I64,\n+    I128,\n }\n \n impl Integer {\n@@ -336,6 +351,7 @@ impl Integer {\n             I16 => Size::from_bytes(2),\n             I32 => Size::from_bytes(4),\n             I64  => Size::from_bytes(8),\n+            I128  => Size::from_bytes(16),\n         }\n     }\n \n@@ -346,6 +362,7 @@ impl Integer {\n             I16 => dl.i16_align,\n             I32 => dl.i32_align,\n             I64 => dl.i64_align,\n+            I128 => dl.i128_align,\n         }\n     }\n \n@@ -357,33 +374,37 @@ impl Integer {\n             (I16, false) => tcx.types.u16,\n             (I32, false) => tcx.types.u32,\n             (I64, false) => tcx.types.u64,\n+            (I128, false) => tcx.types.u128,\n             (I1, true) => tcx.types.i8,\n             (I8, true) => tcx.types.i8,\n             (I16, true) => tcx.types.i16,\n             (I32, true) => tcx.types.i32,\n             (I64, true) => tcx.types.i64,\n+            (I128, true) => tcx.types.i128,\n         }\n     }\n \n     /// Find the smallest Integer type which can represent the signed value.\n     pub fn fit_signed(x: i64) -> Integer {\n         match x {\n-            -0x0000_0001...0x0000_0000 => I1,\n-            -0x0000_0080...0x0000_007f => I8,\n-            -0x0000_8000...0x0000_7fff => I16,\n-            -0x8000_0000...0x7fff_ffff => I32,\n-            _ => I64\n+            -0x0000_0000_0000_0001...0x0000_0000_0000_0000 => I1,\n+            -0x0000_0000_0000_0080...0x0000_0000_0000_007f => I8,\n+            -0x0000_0000_0000_8000...0x0000_0000_0000_7fff => I16,\n+            -0x0000_0000_8000_0000...0x0000_0000_7fff_ffff => I32,\n+            -0x8000_0000_0000_0000...0x7fff_ffff_ffff_ffff => I64,\n+            _ => I128\n         }\n     }\n \n     /// Find the smallest Integer type which can represent the unsigned value.\n     pub fn fit_unsigned(x: u64) -> Integer {\n         match x {\n-            0...0x0000_0001 => I1,\n-            0...0x0000_00ff => I8,\n-            0...0x0000_ffff => I16,\n-            0...0xffff_ffff => I32,\n-            _ => I64\n+            0...0x0000_0000_0000_0001 => I1,\n+            0...0x0000_0000_0000_00ff => I8,\n+            0...0x0000_0000_0000_ffff => I16,\n+            0...0x0000_0000_ffff_ffff => I32,\n+            0...0xffff_ffff_ffff_ffff => I64,\n+            _ => I128,\n         }\n     }\n \n@@ -406,6 +427,7 @@ impl Integer {\n             attr::SignedInt(IntTy::I16) | attr::UnsignedInt(UintTy::U16) => I16,\n             attr::SignedInt(IntTy::I32) | attr::UnsignedInt(UintTy::U32) => I32,\n             attr::SignedInt(IntTy::I64) | attr::UnsignedInt(UintTy::U64) => I64,\n+            attr::SignedInt(IntTy::I128) | attr::UnsignedInt(UintTy::U128) => I128,\n             attr::SignedInt(IntTy::Is) | attr::UnsignedInt(UintTy::Us) => {\n                 dl.ptr_sized_integer()\n             }\n@@ -486,6 +508,7 @@ impl Primitive {\n             Int(I16) => Size::from_bits(16),\n             Int(I32) | F32 => Size::from_bits(32),\n             Int(I64) | F64 => Size::from_bits(64),\n+            Int(I128) => Size::from_bits(128),\n             Pointer => dl.pointer_size\n         }\n     }\n@@ -497,6 +520,7 @@ impl Primitive {\n             Int(I16) => dl.i16_align,\n             Int(I32) => dl.i32_align,\n             Int(I64) => dl.i64_align,\n+            Int(I128) => dl.i128_align,\n             F32 => dl.f32_align,\n             F64 => dl.f64_align,\n             Pointer => dl.pointer_align\n@@ -1175,19 +1199,30 @@ impl<'a, 'gcx, 'tcx> Layout {\n \n                 if def.is_enum() && def.variants.iter().all(|v| v.fields.is_empty()) {\n                     // All bodies empty -> intlike\n-                    let (mut min, mut max, mut non_zero) = (i64::MAX, i64::MIN, true);\n+                    let (mut min, mut max, mut non_zero) = (i64::max_value(),\n+                                                            i64::min_value(),\n+                                                            true);\n                     for v in &def.variants {\n-                        let x = v.disr_val.to_u64_unchecked() as i64;\n+                        let x = match v.disr_val.erase_type() {\n+                            ConstInt::InferSigned(i) => i as i64,\n+                            ConstInt::Infer(i) => i as u64 as i64,\n+                            _ => bug!()\n+                        };\n                         if x == 0 { non_zero = false; }\n                         if x < min { min = x; }\n                         if x > max { max = x; }\n                     }\n \n-                    let (discr, signed) = Integer::repr_discr(tcx, ty, &hints[..], min, max);\n+                    // FIXME: should handle i128? signed-value based impl is weird and hard to\n+                    // grok.\n+                    let (discr, signed) = Integer::repr_discr(tcx, ty, &hints[..],\n+                                                              min,\n+                                                              max);\n                     return success(CEnum {\n                         discr: discr,\n                         signed: signed,\n                         non_zero: non_zero,\n+                        // FIXME: should be u128?\n                         min: min as u64,\n                         max: max as u64\n                     });\n@@ -1232,7 +1267,7 @@ impl<'a, 'gcx, 'tcx> Layout {\n                 // non-empty body, explicit discriminants should have\n                 // been rejected by a checker before this point.\n                 for (i, v) in def.variants.iter().enumerate() {\n-                    if i as u64 != v.disr_val.to_u64_unchecked() {\n+                    if i as u128 != v.disr_val.to_u128_unchecked() {\n                         bug!(\"non-C-like enum {} with specified discriminants\",\n                             tcx.item_path_str(def.did));\n                     }"}, {"sha": "0b45ff94a93123bffad6a5c2f6ba43626a3bd439", "filename": "src/librustc/ty/util.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Futil.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -51,11 +51,13 @@ impl IntTypeExt for attr::IntType {\n             SignedInt(ast::IntTy::I16)     => tcx.types.i16,\n             SignedInt(ast::IntTy::I32)     => tcx.types.i32,\n             SignedInt(ast::IntTy::I64)     => tcx.types.i64,\n+            SignedInt(ast::IntTy::I128)     => tcx.types.i128,\n             SignedInt(ast::IntTy::Is)   => tcx.types.isize,\n             UnsignedInt(ast::UintTy::U8)    => tcx.types.u8,\n             UnsignedInt(ast::UintTy::U16)   => tcx.types.u16,\n             UnsignedInt(ast::UintTy::U32)   => tcx.types.u32,\n             UnsignedInt(ast::UintTy::U64)   => tcx.types.u64,\n+            UnsignedInt(ast::UintTy::U128)   => tcx.types.u128,\n             UnsignedInt(ast::UintTy::Us) => tcx.types.usize,\n         }\n     }\n@@ -66,6 +68,7 @@ impl IntTypeExt for attr::IntType {\n             SignedInt(ast::IntTy::I16)   => ConstInt::I16(0),\n             SignedInt(ast::IntTy::I32)   => ConstInt::I32(0),\n             SignedInt(ast::IntTy::I64)   => ConstInt::I64(0),\n+            SignedInt(ast::IntTy::I128)   => ConstInt::I128(0),\n             SignedInt(ast::IntTy::Is) => match tcx.sess.target.int_type {\n                 ast::IntTy::I16 => ConstInt::Isize(ConstIsize::Is16(0)),\n                 ast::IntTy::I32 => ConstInt::Isize(ConstIsize::Is32(0)),\n@@ -76,6 +79,7 @@ impl IntTypeExt for attr::IntType {\n             UnsignedInt(ast::UintTy::U16) => ConstInt::U16(0),\n             UnsignedInt(ast::UintTy::U32) => ConstInt::U32(0),\n             UnsignedInt(ast::UintTy::U64) => ConstInt::U64(0),\n+            UnsignedInt(ast::UintTy::U128) => ConstInt::U128(0),\n             UnsignedInt(ast::UintTy::Us) => match tcx.sess.target.uint_type {\n                 ast::UintTy::U16 => ConstInt::Usize(ConstUsize::Us16(0)),\n                 ast::UintTy::U32 => ConstInt::Usize(ConstUsize::Us32(0)),\n@@ -91,11 +95,13 @@ impl IntTypeExt for attr::IntType {\n             (SignedInt(ast::IntTy::I16), ConstInt::I16(_)) => {},\n             (SignedInt(ast::IntTy::I32), ConstInt::I32(_)) => {},\n             (SignedInt(ast::IntTy::I64), ConstInt::I64(_)) => {},\n+            (SignedInt(ast::IntTy::I128), ConstInt::I128(_)) => {},\n             (SignedInt(ast::IntTy::Is), ConstInt::Isize(_)) => {},\n             (UnsignedInt(ast::UintTy::U8), ConstInt::U8(_)) => {},\n             (UnsignedInt(ast::UintTy::U16), ConstInt::U16(_)) => {},\n             (UnsignedInt(ast::UintTy::U32), ConstInt::U32(_)) => {},\n             (UnsignedInt(ast::UintTy::U64), ConstInt::U64(_)) => {},\n+            (UnsignedInt(ast::UintTy::U128), ConstInt::U128(_)) => {},\n             (UnsignedInt(ast::UintTy::Us), ConstInt::Usize(_)) => {},\n             _ => bug!(\"disr type mismatch: {:?} vs {:?}\", self, val),\n         }"}, {"sha": "2dbaeaf26e970f68cf15d27859324e6c94b88245", "filename": "src/librustc_back/target/asmjs_unknown_emscripten.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_back%2Ftarget%2Fasmjs_unknown_emscripten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_back%2Ftarget%2Fasmjs_unknown_emscripten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fasmjs_unknown_emscripten.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -9,11 +9,12 @@\n // except according to those terms.\n \n use super::{Target, TargetOptions};\n+use super::emscripten_base::{cmd};\n \n pub fn target() -> Result<Target, String> {\n     let opts = TargetOptions {\n-        linker: \"emcc\".to_string(),\n-        ar: \"emar\".to_string(),\n+        linker: cmd(\"emcc\"),\n+        ar: cmd(\"emar\"),\n \n         dynamic_linking: false,\n         executables: true,"}, {"sha": "bacada3f5ab02c6f666234a112340d1428b3710b", "filename": "src/librustc_back/target/emscripten_base.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_back%2Ftarget%2Femscripten_base.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_back%2Ftarget%2Femscripten_base.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Femscripten_base.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2014-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub fn cmd(name: &str) -> String {\n+    if cfg!(windows) {\n+        format!(\"{}.bat\", name)\n+    } else {\n+        name.to_string()\n+    }\n+}"}, {"sha": "5afa85d155279e17a905edf5885a32d677209914", "filename": "src/librustc_back/target/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_back%2Ftarget%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fmod.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -58,6 +58,7 @@ mod apple_ios_base;\n mod arm_base;\n mod bitrig_base;\n mod dragonfly_base;\n+mod emscripten_base;\n mod freebsd_base;\n mod haiku_base;\n mod linux_base;"}, {"sha": "a06980767fd75cd58baded41b2fabe298191e15a", "filename": "src/librustc_back/target/wasm32_unknown_emscripten.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_back%2Ftarget%2Fwasm32_unknown_emscripten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_back%2Ftarget%2Fwasm32_unknown_emscripten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_back%2Ftarget%2Fwasm32_unknown_emscripten.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -9,11 +9,12 @@\n // except according to those terms.\n \n use super::{Target, TargetOptions};\n+use super::emscripten_base::{cmd};\n \n pub fn target() -> Result<Target, String> {\n     let opts = TargetOptions {\n-        linker: \"emcc\".to_string(),\n-        ar: \"emar\".to_string(),\n+        linker: cmd(\"emcc\"),\n+        ar: cmd(\"emar\"),\n \n         dynamic_linking: false,\n         executables: true,"}, {"sha": "7148e181bbd6d8aa0f8be0f0748b71f7bade0681", "filename": "src/librustc_const_eval/Cargo.toml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_const_eval%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_const_eval%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2FCargo.toml?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -19,4 +19,5 @@ rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_errors = { path = \"../librustc_errors\" }\n syntax = { path = \"../libsyntax\" }\n graphviz = { path = \"../libgraphviz\" }\n-syntax_pos = { path = \"../libsyntax_pos\" }\n\\ No newline at end of file\n+syntax_pos = { path = \"../libsyntax_pos\" }\n+rustc_i128 = { path = \"../librustc_i128\" }"}, {"sha": "c736b4865e73834ac605581ae7f5d4f89f5b39d6", "filename": "src/librustc_const_eval/eval.rs", "status": "modified", "additions": 52, "deletions": 37, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_const_eval%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_const_eval%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Feval.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -43,6 +43,8 @@ use std::cmp::Ordering;\n use rustc_const_math::*;\n use rustc_errors::DiagnosticBuilder;\n \n+use rustc_i128::{i128, u128};\n+\n macro_rules! math {\n     ($e:expr, $op:expr) => {\n         match $op {\n@@ -588,38 +590,43 @@ pub fn eval_const_expr_partial<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         if let hir::ExprLit(ref lit) = inner.node {\n             use syntax::ast::*;\n             use syntax::ast::LitIntType::*;\n-            const I8_OVERFLOW: u64 = ::std::i8::MAX as u64 + 1;\n-            const I16_OVERFLOW: u64 = ::std::i16::MAX as u64 + 1;\n-            const I32_OVERFLOW: u64 = ::std::i32::MAX as u64 + 1;\n-            const I64_OVERFLOW: u64 = ::std::i64::MAX as u64 + 1;\n+            const I8_OVERFLOW: u128 = i8::max_value() as u128 + 1;\n+            const I16_OVERFLOW: u128 = i16::max_value() as u128 + 1;\n+            const I32_OVERFLOW: u128 = i32::max_value() as u128 + 1;\n+            const I64_OVERFLOW: u128 = i64::max_value() as u128 + 1;\n+            const I128_OVERFLOW: u128 = i128::max_value() as u128 + 1;\n             match (&lit.node, ety.map(|t| &t.sty)) {\n                 (&LitKind::Int(I8_OVERFLOW, Unsuffixed), Some(&ty::TyInt(IntTy::I8))) |\n                 (&LitKind::Int(I8_OVERFLOW, Signed(IntTy::I8)), _) => {\n-                    return Ok(Integral(I8(::std::i8::MIN)))\n+                    return Ok(Integral(I8(i8::min_value())))\n                 },\n                 (&LitKind::Int(I16_OVERFLOW, Unsuffixed), Some(&ty::TyInt(IntTy::I16))) |\n                 (&LitKind::Int(I16_OVERFLOW, Signed(IntTy::I16)), _) => {\n-                    return Ok(Integral(I16(::std::i16::MIN)))\n+                    return Ok(Integral(I16(i16::min_value())))\n                 },\n                 (&LitKind::Int(I32_OVERFLOW, Unsuffixed), Some(&ty::TyInt(IntTy::I32))) |\n                 (&LitKind::Int(I32_OVERFLOW, Signed(IntTy::I32)), _) => {\n-                    return Ok(Integral(I32(::std::i32::MIN)))\n+                    return Ok(Integral(I32(i32::min_value())))\n                 },\n                 (&LitKind::Int(I64_OVERFLOW, Unsuffixed), Some(&ty::TyInt(IntTy::I64))) |\n                 (&LitKind::Int(I64_OVERFLOW, Signed(IntTy::I64)), _) => {\n-                    return Ok(Integral(I64(::std::i64::MIN)))\n+                    return Ok(Integral(I64(i64::min_value())))\n+                },\n+                (&LitKind::Int(I128_OVERFLOW, Unsuffixed), Some(&ty::TyInt(IntTy::I128))) |\n+                (&LitKind::Int(I128_OVERFLOW, Signed(IntTy::I128)), _) => {\n+                    return Ok(Integral(I128(i128::min_value())))\n                 },\n                 (&LitKind::Int(n, Unsuffixed), Some(&ty::TyInt(IntTy::Is))) |\n                 (&LitKind::Int(n, Signed(IntTy::Is)), _) => {\n                     match tcx.sess.target.int_type {\n                         IntTy::I16 => if n == I16_OVERFLOW {\n-                            return Ok(Integral(Isize(Is16(::std::i16::MIN))));\n+                            return Ok(Integral(Isize(Is16(i16::min_value()))));\n                         },\n                         IntTy::I32 => if n == I32_OVERFLOW {\n-                            return Ok(Integral(Isize(Is32(::std::i32::MIN))));\n+                            return Ok(Integral(Isize(Is32(i32::min_value()))));\n                         },\n                         IntTy::I64 => if n == I64_OVERFLOW {\n-                            return Ok(Integral(Isize(Is64(::std::i64::MIN))));\n+                            return Ok(Integral(Isize(Is64(i64::min_value()))));\n                         },\n                         _ => bug!(),\n                     }\n@@ -973,34 +980,39 @@ fn infer<'a, 'tcx>(i: ConstInt,\n         (&ty::TyInt(IntTy::I16), result @ I16(_)) => Ok(result),\n         (&ty::TyInt(IntTy::I32), result @ I32(_)) => Ok(result),\n         (&ty::TyInt(IntTy::I64), result @ I64(_)) => Ok(result),\n+        (&ty::TyInt(IntTy::I128), result @ I128(_)) => Ok(result),\n         (&ty::TyInt(IntTy::Is), result @ Isize(_)) => Ok(result),\n \n         (&ty::TyUint(UintTy::U8), result @ U8(_)) => Ok(result),\n         (&ty::TyUint(UintTy::U16), result @ U16(_)) => Ok(result),\n         (&ty::TyUint(UintTy::U32), result @ U32(_)) => Ok(result),\n         (&ty::TyUint(UintTy::U64), result @ U64(_)) => Ok(result),\n+        (&ty::TyUint(UintTy::U128), result @ U128(_)) => Ok(result),\n         (&ty::TyUint(UintTy::Us), result @ Usize(_)) => Ok(result),\n \n-        (&ty::TyInt(IntTy::I8), Infer(i)) => Ok(I8(i as i64 as i8)),\n-        (&ty::TyInt(IntTy::I16), Infer(i)) => Ok(I16(i as i64 as i16)),\n-        (&ty::TyInt(IntTy::I32), Infer(i)) => Ok(I32(i as i64 as i32)),\n-        (&ty::TyInt(IntTy::I64), Infer(i)) => Ok(I64(i as i64)),\n+        (&ty::TyInt(IntTy::I8), Infer(i)) => Ok(I8(i as i128 as i8)),\n+        (&ty::TyInt(IntTy::I16), Infer(i)) => Ok(I16(i as i128 as i16)),\n+        (&ty::TyInt(IntTy::I32), Infer(i)) => Ok(I32(i as i128 as i32)),\n+        (&ty::TyInt(IntTy::I64), Infer(i)) => Ok(I64(i as i128 as i64)),\n+        (&ty::TyInt(IntTy::I128), Infer(i)) => Ok(I128(i as i128)),\n         (&ty::TyInt(IntTy::Is), Infer(i)) => {\n-            Ok(Isize(ConstIsize::new_truncating(i as i64, tcx.sess.target.int_type)))\n+            Ok(Isize(ConstIsize::new_truncating(i as i128, tcx.sess.target.int_type)))\n         },\n \n         (&ty::TyInt(IntTy::I8), InferSigned(i)) => Ok(I8(i as i8)),\n         (&ty::TyInt(IntTy::I16), InferSigned(i)) => Ok(I16(i as i16)),\n         (&ty::TyInt(IntTy::I32), InferSigned(i)) => Ok(I32(i as i32)),\n-        (&ty::TyInt(IntTy::I64), InferSigned(i)) => Ok(I64(i)),\n+        (&ty::TyInt(IntTy::I64), InferSigned(i)) => Ok(I64(i as i64)),\n+        (&ty::TyInt(IntTy::I128), InferSigned(i)) => Ok(I128(i)),\n         (&ty::TyInt(IntTy::Is), InferSigned(i)) => {\n             Ok(Isize(ConstIsize::new_truncating(i, tcx.sess.target.int_type)))\n         },\n \n         (&ty::TyUint(UintTy::U8), Infer(i)) => Ok(U8(i as u8)),\n         (&ty::TyUint(UintTy::U16), Infer(i)) => Ok(U16(i as u16)),\n         (&ty::TyUint(UintTy::U32), Infer(i)) => Ok(U32(i as u32)),\n-        (&ty::TyUint(UintTy::U64), Infer(i)) => Ok(U64(i)),\n+        (&ty::TyUint(UintTy::U64), Infer(i)) => Ok(U64(i as u64)),\n+        (&ty::TyUint(UintTy::U128), Infer(i)) => Ok(U128(i)),\n         (&ty::TyUint(UintTy::Us), Infer(i)) => {\n             Ok(Usize(ConstUsize::new_truncating(i, tcx.sess.target.uint_type)))\n         },\n@@ -1071,21 +1083,23 @@ fn resolve_trait_associated_const<'a, 'tcx: 'a>(\n }\n \n fn cast_const_int<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, val: ConstInt, ty: ty::Ty) -> CastResult {\n-    let v = val.to_u64_unchecked();\n+    let v = val.to_u128_unchecked();\n     match ty.sty {\n         ty::TyBool if v == 0 => Ok(Bool(false)),\n         ty::TyBool if v == 1 => Ok(Bool(true)),\n-        ty::TyInt(ast::IntTy::I8) => Ok(Integral(I8(v as i64 as i8))),\n-        ty::TyInt(ast::IntTy::I16) => Ok(Integral(I16(v as i64 as i16))),\n-        ty::TyInt(ast::IntTy::I32) => Ok(Integral(I32(v as i64 as i32))),\n-        ty::TyInt(ast::IntTy::I64) => Ok(Integral(I64(v as i64))),\n+        ty::TyInt(ast::IntTy::I8) => Ok(Integral(I8(v as i128 as i8))),\n+        ty::TyInt(ast::IntTy::I16) => Ok(Integral(I16(v as i128 as i16))),\n+        ty::TyInt(ast::IntTy::I32) => Ok(Integral(I32(v as i128 as i32))),\n+        ty::TyInt(ast::IntTy::I64) => Ok(Integral(I64(v as i128 as i64))),\n+        ty::TyInt(ast::IntTy::I128) => Ok(Integral(I128(v as i128))),\n         ty::TyInt(ast::IntTy::Is) => {\n-            Ok(Integral(Isize(ConstIsize::new_truncating(v as i64, tcx.sess.target.int_type))))\n+            Ok(Integral(Isize(ConstIsize::new_truncating(v as i128, tcx.sess.target.int_type))))\n         },\n         ty::TyUint(ast::UintTy::U8) => Ok(Integral(U8(v as u8))),\n         ty::TyUint(ast::UintTy::U16) => Ok(Integral(U16(v as u16))),\n         ty::TyUint(ast::UintTy::U32) => Ok(Integral(U32(v as u32))),\n-        ty::TyUint(ast::UintTy::U64) => Ok(Integral(U64(v))),\n+        ty::TyUint(ast::UintTy::U64) => Ok(Integral(U64(v as u64))),\n+        ty::TyUint(ast::UintTy::U128) => Ok(Integral(U128(v as u128))),\n         ty::TyUint(ast::UintTy::Us) => {\n             Ok(Integral(Usize(ConstUsize::new_truncating(v, tcx.sess.target.uint_type))))\n         },\n@@ -1115,13 +1129,13 @@ fn cast_const_float<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n     match ty.sty {\n         ty::TyInt(_) | ty::TyUint(_) => {\n             let i = match val {\n-                F32(f) if f >= 0.0 => Infer(f as u64),\n+                F32(f) if f >= 0.0 => Infer(f as u128),\n                 FInfer { f64: f, .. } |\n-                F64(f) if f >= 0.0 => Infer(f as u64),\n+                F64(f) if f >= 0.0 => Infer(f as u128),\n \n-                F32(f) => InferSigned(f as i64),\n+                F32(f) => InferSigned(f as i128),\n                 FInfer { f64: f, .. } |\n-                F64(f) => InferSigned(f as i64)\n+                F64(f) => InferSigned(f as i128)\n             };\n \n             if let (InferSigned(_), &ty::TyUint(_)) = (i, &ty.sty) {\n@@ -1145,9 +1159,9 @@ fn cast_const_float<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n fn cast_const<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>, val: ConstVal, ty: ty::Ty) -> CastResult {\n     match val {\n         Integral(i) => cast_const_int(tcx, i, ty),\n-        Bool(b) => cast_const_int(tcx, Infer(b as u64), ty),\n+        Bool(b) => cast_const_int(tcx, Infer(b as u128), ty),\n         Float(f) => cast_const_float(tcx, f, ty),\n-        Char(c) => cast_const_int(tcx, Infer(c as u64), ty),\n+        Char(c) => cast_const_int(tcx, Infer(c as u128), ty),\n         Function(_) => Err(UnimplementedConstVal(\"casting fn pointers\")),\n         ByteStr(b) => match ty.sty {\n             ty::TyRawPtr(_) => {\n@@ -1185,28 +1199,29 @@ fn lit_to_const<'a, 'tcx>(lit: &ast::LitKind,\n         LitKind::ByteStr(ref data) => Ok(ByteStr(data.clone())),\n         LitKind::Byte(n) => Ok(Integral(U8(n))),\n         LitKind::Int(n, Signed(ity)) => {\n-            infer(InferSigned(n as i64), tcx, &ty::TyInt(ity)).map(Integral)\n+            infer(InferSigned(n as i128), tcx, &ty::TyInt(ity)).map(Integral)\n         },\n \n+        // FIXME: this should become u128.\n         LitKind::Int(n, Unsuffixed) => {\n             match ty_hint.map(|t| &t.sty) {\n                 Some(&ty::TyInt(ity)) => {\n-                    infer(InferSigned(n as i64), tcx, &ty::TyInt(ity)).map(Integral)\n+                    infer(InferSigned(n as i128), tcx, &ty::TyInt(ity)).map(Integral)\n                 },\n                 Some(&ty::TyUint(uty)) => {\n-                    infer(Infer(n), tcx, &ty::TyUint(uty)).map(Integral)\n+                    infer(Infer(n as u128), tcx, &ty::TyUint(uty)).map(Integral)\n                 },\n-                None => Ok(Integral(Infer(n))),\n+                None => Ok(Integral(Infer(n as u128))),\n                 Some(&ty::TyAdt(adt, _)) => {\n                     let hints = tcx.lookup_repr_hints(adt.did);\n                     let int_ty = tcx.enum_repr_type(hints.iter().next());\n-                    infer(Infer(n), tcx, &int_ty.to_ty(tcx).sty).map(Integral)\n+                    infer(Infer(n as u128), tcx, &int_ty.to_ty(tcx).sty).map(Integral)\n                 },\n                 Some(ty_hint) => bug!(\"bad ty_hint: {:?}, {:?}\", ty_hint, lit),\n             }\n         },\n         LitKind::Int(n, Unsigned(ity)) => {\n-            infer(Infer(n), tcx, &ty::TyUint(ity)).map(Integral)\n+            infer(Infer(n as u128), tcx, &ty::TyUint(ity)).map(Integral)\n         },\n \n         LitKind::Float(n, fty) => {"}, {"sha": "67b4efdbd1f4474518860ae445b7cdaa5bd20408", "filename": "src/librustc_const_eval/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_const_eval%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_const_eval%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_eval%2Flib.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -28,6 +28,7 @@\n #![feature(slice_patterns)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n+#![feature(const_fn)]\n \n extern crate arena;\n #[macro_use] extern crate syntax;\n@@ -41,6 +42,8 @@ extern crate graphviz;\n extern crate syntax_pos;\n extern crate serialize as rustc_serialize; // used by deriving\n \n+extern crate rustc_i128;\n+\n // NB: This module needs to be declared first so diagnostics are\n // registered before they are used.\n pub mod diagnostics;"}, {"sha": "3d7a4865e45af62fe436b883dd409b0a8ec3dff0", "filename": "src/librustc_const_math/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_const_math%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_const_math%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_math%2FCargo.toml?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -12,3 +12,4 @@ crate-type = [\"dylib\"]\n log = { path = \"../liblog\" }\n serialize = { path = \"../libserialize\" }\n syntax = { path = \"../libsyntax\" }\n+rustc_i128 = { path = \"../librustc_i128\" }"}, {"sha": "1e9c2badd686096be1a1269c42b8b7c5bf6ce1a3", "filename": "src/librustc_const_math/err.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_const_math%2Ferr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_const_math%2Ferr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_math%2Ferr.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -74,11 +74,13 @@ impl ConstMathErr {\n             ULitOutOfRange(ast::UintTy::U16) => \"literal out of range for u16\",\n             ULitOutOfRange(ast::UintTy::U32) => \"literal out of range for u32\",\n             ULitOutOfRange(ast::UintTy::U64) => \"literal out of range for u64\",\n+            ULitOutOfRange(ast::UintTy::U128) => \"literal out of range for u128\",\n             ULitOutOfRange(ast::UintTy::Us) => \"literal out of range for usize\",\n             LitOutOfRange(ast::IntTy::I8) => \"literal out of range for i8\",\n             LitOutOfRange(ast::IntTy::I16) => \"literal out of range for i16\",\n             LitOutOfRange(ast::IntTy::I32) => \"literal out of range for i32\",\n             LitOutOfRange(ast::IntTy::I64) => \"literal out of range for i64\",\n+            LitOutOfRange(ast::IntTy::I128) => \"literal out of range for i128\",\n             LitOutOfRange(ast::IntTy::Is) => \"literal out of range for isize\",\n         }\n     }"}, {"sha": "59eb4b70aa8ff4eba799748a6af0718cae9c57b7", "filename": "src/librustc_const_math/int.rs", "status": "modified", "additions": 213, "deletions": 126, "changes": 339, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_const_math%2Fint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_const_math%2Fint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_math%2Fint.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -11,6 +11,7 @@\n use std::cmp::Ordering;\n use syntax::attr::IntType;\n use syntax::ast::{IntTy, UintTy};\n+use rustc_i128::{i128, u128};\n \n use super::is::*;\n use super::us::*;\n@@ -22,92 +23,153 @@ pub enum ConstInt {\n     I16(i16),\n     I32(i32),\n     I64(i64),\n+    I128(i128),\n     Isize(ConstIsize),\n     U8(u8),\n     U16(u16),\n     U32(u32),\n     U64(u64),\n+    U128(u128),\n     Usize(ConstUsize),\n-    Infer(u64),\n-    InferSigned(i64),\n+    Infer(u128),\n+    InferSigned(i128),\n }\n pub use self::ConstInt::*;\n \n \n macro_rules! bounds {\n-    ($($t:ident $min:ident $max:ident)*) => {\n-        mod as_u64 {\n-            $(\n-                #[allow(dead_code)]\n-                pub const $min: u64 = ::std::$t::MIN as u64;\n-                #[allow(dead_code)]\n-                pub const $max: u64 = ::std::$t::MAX as u64;\n-            )*\n-        }\n-        mod as_i64 {\n-            $(\n-                #[allow(dead_code)]\n-                pub const $min: i64 = ::std::$t::MIN as i64;\n-                #[allow(dead_code)]\n-                pub const $max: i64 = ::std::$t::MAX as i64;\n-            )*\n-        }\n+    ($ct: ty, $($t:ident $min:ident $max:ident)*) => {\n+        $(\n+            pub const $min: $ct = $t::min_value() as $ct;\n+            pub const $max: $ct = $t::max_value() as $ct;\n+        )*\n+    };\n+    ($ct: ty: $min_val: expr, $($t:ident $min:ident $max:ident)*) => {\n+        $(\n+            pub const $min: $ct = $min_val;\n+            pub const $max: $ct = $t::max_value() as $ct;\n+        )*\n+    }\n+}\n+\n+mod ubounds {\n+    #![allow(dead_code)]\n+    use rustc_i128::{u128, i128};\n+    bounds!{u128: 0,\n+        i8 I8MIN I8MAX i16 I16MIN I16MAX i32 I32MIN I32MAX i64 I64MIN I64MAX i128 I128MIN I128MAX\n+        u8 U8MIN U8MAX u16 U16MIN U16MAX u32 U32MIN U32MAX u64 U64MIN U64MAX u128 U128MIN U128MAX\n+        // do not add constants for isize/usize, because these are guaranteed to be wrong for\n+        // arbitrary host/target combinations\n     }\n }\n \n-bounds!{\n-    i8 I8MIN I8MAX i16 I16MIN I16MAX i32 I32MIN I32MAX i64 I64MIN I64MAX isize IMIN IMAX\n-    u8 U8MIN U8MAX u16 U16MIN U16MAX u32 U32MIN U32MAX u64 U64MIN U64MAX usize UMIN UMAX\n+mod ibounds {\n+    #![allow(dead_code)]\n+    use rustc_i128::i128;\n+    #[cfg(stage0)]\n+    pub const U64MIN: i128 = 0;\n+    #[cfg(stage0)]\n+    pub const U64MAX: i128 = i128::max_value();\n+    #[cfg(not(stage0))]\n+    bounds!(i128, u64 U64MIN U64MAX);\n+\n+    pub const U128MIN: i128 = 0;\n+    pub const U128MAX: i128 = i128::max_value();\n+\n+    bounds!{i128,\n+        i8 I8MIN I8MAX i16 I16MIN I16MAX i32 I32MIN I32MAX i64 I64MIN I64MAX i128 I128MIN I128MAX\n+        u8 U8MIN U8MAX u16 U16MIN U16MAX u32 U32MIN U32MAX\n+        // do not add constants for isize/usize, because these are guaranteed to be wrong for\n+        // arbitrary host/target combinations\n+    }\n }\n \n impl ConstInt {\n+    /// Creates a new unsigned ConstInt with matching type while also checking that overflow does\n+    /// not happen.\n+    pub fn new_unsigned(val: u128, ty: UintTy, usize_ty: UintTy) -> Option<ConstInt> {\n+        match ty {\n+            UintTy::U8 if val <= ubounds::U8MAX => Some(U8(val as u8)),\n+            UintTy::U16 if val <= ubounds::U16MAX => Some(U16(val as u16)),\n+            UintTy::U32 if val <= ubounds::U32MAX => Some(U32(val as u32)),\n+            UintTy::U64 if val <= ubounds::U64MAX => Some(U64(val as u64)),\n+            UintTy::Us if val <= ubounds::U64MAX => ConstUsize::new(val as u64, usize_ty).ok()\n+                .map(Usize),\n+            UintTy::U128 => Some(U128(val)),\n+            _ => None\n+        }\n+    }\n+\n+    /// Creates a new unsigned ConstInt with matching type while also checking that overflow does\n+    /// not happen.\n+    pub fn new_signed(val: i128, ty: IntTy, isize_ty: IntTy) -> Option<ConstInt> {\n+        match ty {\n+            IntTy::I8 if val <= ibounds::I8MAX => Some(I8(val as i8)),\n+            IntTy::I16 if val <= ibounds::I16MAX => Some(I16(val as i16)),\n+            IntTy::I32 if val <= ibounds::I32MAX => Some(I32(val as i32)),\n+            IntTy::I64 if val <= ibounds::I64MAX => Some(I64(val as i64)),\n+            IntTy::Is if val <= ibounds::I64MAX => ConstIsize::new(val as i64, isize_ty).ok()\n+                .map(Isize),\n+            IntTy::I128 => Some(I128(val)),\n+            _ => None\n+        }\n+    }\n+\n     /// If either value is `Infer` or `InferSigned`, try to turn the value into the type of\n     /// the other value. If both values have no type, don't do anything\n     pub fn infer(self, other: Self) -> Result<(Self, Self), ConstMathErr> {\n         let inferred = match (self, other) {\n             (InferSigned(_), InferSigned(_))\n             | (Infer(_), Infer(_)) => self, // no inference possible\n             // kindof wrong, you could have had values > I64MAX during computation of a\n-            (Infer(a @ 0...as_u64::I64MAX), InferSigned(_)) => InferSigned(a as i64),\n+            (Infer(a @ 0...ubounds::I64MAX), InferSigned(_)) => InferSigned(a as i128),\n             (Infer(_), InferSigned(_)) => return Err(ConstMathErr::NotInRange),\n             (_, InferSigned(_))\n             | (_, Infer(_)) => return other.infer(self).map(|(b, a)| (a, b)),\n \n-            (Infer(a @ 0...as_u64::I8MAX), I8(_)) => I8(a as i64 as i8),\n-            (Infer(a @ 0...as_u64::I16MAX), I16(_)) => I16(a as i64 as i16),\n-            (Infer(a @ 0...as_u64::I32MAX), I32(_)) => I32(a as i64 as i32),\n-            (Infer(a @ 0...as_u64::I64MAX), I64(_)) => I64(a as i64),\n-            (Infer(a @ 0...as_u64::I16MAX), Isize(Is16(_))) => Isize(Is16(a as i64 as i16)),\n-            (Infer(a @ 0...as_u64::I32MAX), Isize(Is32(_))) => Isize(Is32(a as i64 as i32)),\n-            (Infer(a @ 0...as_u64::I64MAX), Isize(Is64(_))) => Isize(Is64(a as i64)),\n-            (Infer(a @ 0...as_u64::U8MAX), U8(_)) => U8(a as u8),\n-            (Infer(a @ 0...as_u64::U16MAX), U16(_)) => U16(a as u16),\n-            (Infer(a @ 0...as_u64::U32MAX), U32(_)) => U32(a as u32),\n-            (Infer(a), U64(_)) => U64(a),\n-            (Infer(a @ 0...as_u64::U16MAX), Usize(Us16(_))) => Usize(Us16(a as u16)),\n-            (Infer(a @ 0...as_u64::U32MAX), Usize(Us32(_))) => Usize(Us32(a as u32)),\n-            (Infer(a), Usize(Us64(_))) => Usize(Us64(a)),\n+            (Infer(a @ 0...ubounds::I8MAX), I8(_)) => I8(a as i64 as i8),\n+            (Infer(a @ 0...ubounds::I16MAX), I16(_)) => I16(a as i64 as i16),\n+            (Infer(a @ 0...ubounds::I32MAX), I32(_)) => I32(a as i64 as i32),\n+            (Infer(a @ 0...ubounds::I64MAX), I64(_)) => I64(a as i64),\n+            (Infer(a @ 0...ubounds::I128MAX), I128(_)) => I128(a as i128),\n+            (Infer(a @ 0...ubounds::I16MAX), Isize(Is16(_))) => Isize(Is16(a as i64 as i16)),\n+            (Infer(a @ 0...ubounds::I32MAX), Isize(Is32(_))) => Isize(Is32(a as i64 as i32)),\n+            (Infer(a @ 0...ubounds::I64MAX), Isize(Is64(_))) => Isize(Is64(a as i64)),\n+            (Infer(a @ 0...ubounds::U8MAX), U8(_)) => U8(a as u8),\n+            (Infer(a @ 0...ubounds::U16MAX), U16(_)) => U16(a as u16),\n+            (Infer(a @ 0...ubounds::U32MAX), U32(_)) => U32(a as u32),\n+            (Infer(a @ 0...ubounds::U64MAX), U64(_)) => U64(a as u64),\n+            (Infer(a @ 0...ubounds::U128MAX), U128(_)) => U128(a as u128),\n+            (Infer(a @ 0...ubounds::U16MAX), Usize(Us16(_))) => Usize(Us16(a as u16)),\n+            (Infer(a @ 0...ubounds::U32MAX), Usize(Us32(_))) => Usize(Us32(a as u32)),\n+            (Infer(a @ 0...ubounds::U64MAX), Usize(Us64(_))) => Usize(Us64(a as u64)),\n \n             (Infer(_), _) => return Err(ConstMathErr::NotInRange),\n \n-            (InferSigned(a @ as_i64::I8MIN...as_i64::I8MAX), I8(_)) => I8(a as i8),\n-            (InferSigned(a @ as_i64::I16MIN...as_i64::I16MAX), I16(_)) => I16(a as i16),\n-            (InferSigned(a @ as_i64::I32MIN...as_i64::I32MAX), I32(_)) => I32(a as i32),\n-            (InferSigned(a), I64(_)) => I64(a),\n-            (InferSigned(a @ as_i64::I16MIN...as_i64::I16MAX), Isize(Is16(_))) => {\n+            (InferSigned(a @ ibounds::I8MIN...ibounds::I8MAX), I8(_)) => I8(a as i8),\n+            (InferSigned(a @ ibounds::I16MIN...ibounds::I16MAX), I16(_)) => I16(a as i16),\n+            (InferSigned(a @ ibounds::I32MIN...ibounds::I32MAX), I32(_)) => I32(a as i32),\n+            (InferSigned(a @ ibounds::I64MIN...ibounds::I64MAX), I64(_)) => I64(a as i64),\n+            (InferSigned(a @ ibounds::I128MIN...ibounds::I128MAX), I128(_)) => I128(a as i128),\n+            (InferSigned(a @ ibounds::I16MIN...ibounds::I16MAX), Isize(Is16(_))) => {\n                 Isize(Is16(a as i16))\n             },\n-            (InferSigned(a @ as_i64::I32MIN...as_i64::I32MAX), Isize(Is32(_))) => {\n+            (InferSigned(a @ ibounds::I32MIN...ibounds::I32MAX), Isize(Is32(_))) => {\n                 Isize(Is32(a as i32))\n             },\n-            (InferSigned(a), Isize(Is64(_))) => Isize(Is64(a)),\n-            (InferSigned(a @ 0...as_i64::U8MAX), U8(_)) => U8(a as u8),\n-            (InferSigned(a @ 0...as_i64::U16MAX), U16(_)) => U16(a as u16),\n-            (InferSigned(a @ 0...as_i64::U32MAX), U32(_)) => U32(a as u32),\n-            (InferSigned(a @ 0...as_i64::I64MAX), U64(_)) => U64(a as u64),\n-            (InferSigned(a @ 0...as_i64::U16MAX), Usize(Us16(_))) => Usize(Us16(a as u16)),\n-            (InferSigned(a @ 0...as_i64::U32MAX), Usize(Us32(_))) => Usize(Us32(a as u32)),\n-            (InferSigned(a @ 0...as_i64::I64MAX), Usize(Us64(_))) => Usize(Us64(a as u64)),\n+            (InferSigned(a @ ibounds::I64MIN...ibounds::I64MAX), Isize(Is64(_))) => {\n+                Isize(Is64(a as i64))\n+            },\n+            (InferSigned(a @ 0...ibounds::U8MAX), U8(_)) => U8(a as u8),\n+            (InferSigned(a @ 0...ibounds::U16MAX), U16(_)) => U16(a as u16),\n+            (InferSigned(a @ 0...ibounds::U32MAX), U32(_)) => U32(a as u32),\n+            // SNAP: replace with U64MAX\n+            (InferSigned(a @ 0...ibounds::I64MAX), U64(_)) => U64(a as u64),\n+            (InferSigned(a @ 0...ibounds::I128MAX), U128(_)) => U128(a as u128),\n+            (InferSigned(a @ 0...ibounds::U16MAX), Usize(Us16(_))) => Usize(Us16(a as u16)),\n+            (InferSigned(a @ 0...ibounds::U32MAX), Usize(Us32(_))) => Usize(Us32(a as u32)),\n+            // SNAP: replace with U64MAX\n+            (InferSigned(a @ 0...ibounds::I64MAX), Usize(Us64(_))) => Usize(Us64(a as u64)),\n             (InferSigned(_), _) => return Err(ConstMathErr::NotInRange),\n             _ => self, // already known types\n         };\n@@ -119,28 +181,31 @@ impl ConstInt {\n         match self {\n             Infer(i) => Infer(i),\n             InferSigned(i) if i < 0 => InferSigned(i),\n-            I8(i) if i < 0 => InferSigned(i as i64),\n-            I16(i) if i < 0 => InferSigned(i as i64),\n-            I32(i) if i < 0 => InferSigned(i as i64),\n-            I64(i) if i < 0 => InferSigned(i as i64),\n-            Isize(Is16(i)) if i < 0 => InferSigned(i as i64),\n-            Isize(Is32(i)) if i < 0 => InferSigned(i as i64),\n-            Isize(Is64(i)) if i < 0 => InferSigned(i as i64),\n-            InferSigned(i) => Infer(i as u64),\n-            I8(i) => Infer(i as u64),\n-            I16(i) => Infer(i as u64),\n-            I32(i) => Infer(i as u64),\n-            I64(i) => Infer(i as u64),\n-            Isize(Is16(i)) => Infer(i as u64),\n-            Isize(Is32(i)) => Infer(i as u64),\n-            Isize(Is64(i)) => Infer(i as u64),\n-            U8(i) => Infer(i as u64),\n-            U16(i) => Infer(i as u64),\n-            U32(i) => Infer(i as u64),\n-            U64(i) => Infer(i as u64),\n-            Usize(Us16(i)) => Infer(i as u64),\n-            Usize(Us32(i)) => Infer(i as u64),\n-            Usize(Us64(i)) => Infer(i),\n+            I8(i) if i < 0 => InferSigned(i as i128),\n+            I16(i) if i < 0 => InferSigned(i as i128),\n+            I32(i) if i < 0 => InferSigned(i as i128),\n+            I64(i) if i < 0 => InferSigned(i as i128),\n+            I128(i) if i < 0 => InferSigned(i as i128),\n+            Isize(Is16(i)) if i < 0 => InferSigned(i as i128),\n+            Isize(Is32(i)) if i < 0 => InferSigned(i as i128),\n+            Isize(Is64(i)) if i < 0 => InferSigned(i as i128),\n+            InferSigned(i) => Infer(i as u128),\n+            I8(i) => Infer(i as u128),\n+            I16(i) => Infer(i as u128),\n+            I32(i) => Infer(i as u128),\n+            I64(i) => Infer(i as u128),\n+            I128(i) => Infer(i as u128),\n+            Isize(Is16(i)) => Infer(i as u128),\n+            Isize(Is32(i)) => Infer(i as u128),\n+            Isize(Is64(i)) => Infer(i as u128),\n+            U8(i) => Infer(i as u128),\n+            U16(i) => Infer(i as u128),\n+            U32(i) => Infer(i as u128),\n+            U64(i) => Infer(i as u128),\n+            U128(i) => Infer(i as u128),\n+            Usize(Us16(i)) => Infer(i as u128),\n+            Usize(Us32(i)) => Infer(i as u128),\n+            Usize(Us64(i)) => Infer(i as u128),\n         }\n     }\n \n@@ -153,67 +218,66 @@ impl ConstInt {\n             I16(_) => \"i16\",\n             I32(_) => \"i32\",\n             I64(_) => \"i64\",\n+            I128(_) => \"i128\",\n             Isize(_) => \"isize\",\n             U8(_) => \"u8\",\n             U16(_) => \"u16\",\n             U32(_) => \"u32\",\n             U64(_) => \"u64\",\n+            U128(_) => \"u128\",\n             Usize(_) => \"usize\",\n         }\n     }\n \n-    /// Erases the type and returns a u64.\n-    /// This is not the same as `-5i8 as u64` but as `-5i8 as i64 as u64`\n-    pub fn to_u64_unchecked(self) -> u64 {\n+    /// Erases the type and returns a u128.\n+    /// This is not the same as `-5i8 as u128` but as `-5i8 as i128 as u128`\n+    pub fn to_u128_unchecked(self) -> u128 {\n         match self.erase_type() {\n             ConstInt::Infer(i) => i,\n-            ConstInt::InferSigned(i) => i as u64,\n+            ConstInt::InferSigned(i) => i as u128,\n             _ => unreachable!(),\n         }\n     }\n \n     /// Converts the value to a `u32` if it's in the range 0...std::u32::MAX\n     pub fn to_u32(&self) -> Option<u32> {\n-        match *self {\n-            I8(v) if v >= 0 => Some(v as u32),\n-            I16(v) if v >= 0 => Some(v as u32),\n-            I32(v) if v >= 0 => Some(v as u32),\n-            InferSigned(v)\n-            | Isize(Is64(v))\n-            | I64(v) if v >= 0 && v <= ::std::u32::MAX as i64 => Some(v as u32),\n-            Isize(Is32(v)) if v >= 0 => Some(v as u32),\n-            Isize(Is16(v)) if v >= 0 => Some(v as u32),\n-            U8(v) => Some(v as u32),\n-            U16(v) => Some(v as u32),\n-            U32(v) => Some(v),\n-            Infer(v)\n-            | Usize(Us64(v))\n-            | U64(v) if v <= ::std::u32::MAX as u64 => Some(v as u32),\n-            Usize(Us32(v)) => Some(v),\n-            Usize(Us16(v)) => Some(v as u32),\n-            _ => None,\n-        }\n+        self.to_u128().and_then(|v| if v <= u32::max_value() as u128 {\n+            Some(v as u32)\n+        } else {\n+            None\n+        })\n     }\n \n-    /// Converts the value to a `u64` if it's >= 0\n+    /// Converts the value to a `u64` if it's in the range 0...std::u64::MAX\n     pub fn to_u64(&self) -> Option<u64> {\n+        self.to_u128().and_then(|v| if v <= u64::max_value() as u128 {\n+            Some(v as u64)\n+        } else {\n+            None\n+        })\n+    }\n+\n+    /// Converts the value to a `u128` if it's in the range 0...std::u128::MAX\n+    pub fn to_u128(&self) -> Option<u128> {\n         match *self {\n             Infer(v) => Some(v),\n-            InferSigned(v) if v >= 0 => Some(v as u64),\n-            I8(v) if v >= 0 => Some(v as u64),\n-            I16(v) if v >= 0 => Some(v as u64),\n-            I32(v) if v >= 0 => Some(v as u64),\n-            I64(v) if v >= 0 => Some(v as u64),\n-            Isize(Is16(v)) if v >= 0 => Some(v as u64),\n-            Isize(Is32(v)) if v >= 0 => Some(v as u64),\n-            Isize(Is64(v)) if v >= 0 => Some(v as u64),\n-            U8(v) => Some(v as u64),\n-            U16(v) => Some(v as u64),\n-            U32(v) => Some(v as u64),\n-            U64(v) => Some(v),\n-            Usize(Us16(v)) => Some(v as u64),\n-            Usize(Us32(v)) => Some(v as u64),\n-            Usize(Us64(v)) => Some(v),\n+            InferSigned(v) if v >= 0 => Some(v as u128),\n+            I8(v) if v >= 0 => Some(v as u128),\n+            I16(v) if v >= 0 => Some(v as u128),\n+            I32(v) if v >= 0 => Some(v as u128),\n+            I64(v) if v >= 0 => Some(v as u128),\n+            I128(v) if v >= 0 => Some(v as u128),\n+            Isize(Is16(v)) if v >= 0 => Some(v as u128),\n+            Isize(Is32(v)) if v >= 0 => Some(v as u128),\n+            Isize(Is64(v)) if v >= 0 => Some(v as u128),\n+            U8(v) => Some(v as u128),\n+            U16(v) => Some(v as u128),\n+            U32(v) => Some(v as u128),\n+            U64(v) => Some(v as u128),\n+            U128(v) => Some(v as u128),\n+            Usize(Us16(v)) => Some(v as u128),\n+            Usize(Us32(v)) => Some(v as u128),\n+            Usize(Us64(v)) => Some(v as u128),\n             _ => None,\n         }\n     }\n@@ -224,6 +288,7 @@ impl ConstInt {\n             I16(v) => v < 0,\n             I32(v) => v < 0,\n             I64(v) => v < 0,\n+            I128(v) => v < 0,\n             Isize(Is16(v)) => v < 0,\n             Isize(Is32(v)) => v < 0,\n             Isize(Is64(v)) => v < 0,\n@@ -239,13 +304,15 @@ impl ConstInt {\n             (I16(a), I16(b)) => Ok(a.cmp(&b)),\n             (I32(a), I32(b)) => Ok(a.cmp(&b)),\n             (I64(a), I64(b)) => Ok(a.cmp(&b)),\n+            (I128(a), I128(b)) => Ok(a.cmp(&b)),\n             (Isize(Is16(a)), Isize(Is16(b))) => Ok(a.cmp(&b)),\n             (Isize(Is32(a)), Isize(Is32(b))) => Ok(a.cmp(&b)),\n             (Isize(Is64(a)), Isize(Is64(b))) => Ok(a.cmp(&b)),\n             (U8(a), U8(b)) => Ok(a.cmp(&b)),\n             (U16(a), U16(b)) => Ok(a.cmp(&b)),\n             (U32(a), U32(b)) => Ok(a.cmp(&b)),\n             (U64(a), U64(b)) => Ok(a.cmp(&b)),\n+            (U128(a), U128(b)) => Ok(a.cmp(&b)),\n             (Usize(Us16(a)), Usize(Us16(b))) => Ok(a.cmp(&b)),\n             (Usize(Us32(a)), Usize(Us32(b))) => Ok(a.cmp(&b)),\n             (Usize(Us64(a)), Usize(Us64(b))) => Ok(a.cmp(&b)),\n@@ -265,13 +332,15 @@ impl ConstInt {\n             ConstInt::I16(i) => ConstInt::I16(add1!(i)),\n             ConstInt::I32(i) => ConstInt::I32(add1!(i)),\n             ConstInt::I64(i) => ConstInt::I64(add1!(i)),\n+            ConstInt::I128(i) => ConstInt::I128(add1!(i)),\n             ConstInt::Isize(ConstIsize::Is16(i)) => ConstInt::Isize(ConstIsize::Is16(add1!(i))),\n             ConstInt::Isize(ConstIsize::Is32(i)) => ConstInt::Isize(ConstIsize::Is32(add1!(i))),\n             ConstInt::Isize(ConstIsize::Is64(i)) => ConstInt::Isize(ConstIsize::Is64(add1!(i))),\n             ConstInt::U8(i) => ConstInt::U8(add1!(i)),\n             ConstInt::U16(i) => ConstInt::U16(add1!(i)),\n             ConstInt::U32(i) => ConstInt::U32(add1!(i)),\n             ConstInt::U64(i) => ConstInt::U64(add1!(i)),\n+            ConstInt::U128(i) => ConstInt::U128(add1!(i)),\n             ConstInt::Usize(ConstUsize::Us16(i)) => ConstInt::Usize(ConstUsize::Us16(add1!(i))),\n             ConstInt::Usize(ConstUsize::Us32(i)) => ConstInt::Usize(ConstUsize::Us32(add1!(i))),\n             ConstInt::Usize(ConstUsize::Us64(i)) => ConstInt::Usize(ConstUsize::Us64(add1!(i))),\n@@ -285,11 +354,13 @@ impl ConstInt {\n             ConstInt::I16(_) => Some(IntType::SignedInt(IntTy::I16)),\n             ConstInt::I32(_) => Some(IntType::SignedInt(IntTy::I32)),\n             ConstInt::I64(_) => Some(IntType::SignedInt(IntTy::I64)),\n+            ConstInt::I128(_) => Some(IntType::SignedInt(IntTy::I128)),\n             ConstInt::Isize(_) => Some(IntType::SignedInt(IntTy::Is)),\n             ConstInt::U8(_) => Some(IntType::UnsignedInt(UintTy::U8)),\n             ConstInt::U16(_) => Some(IntType::UnsignedInt(UintTy::U16)),\n             ConstInt::U32(_) => Some(IntType::UnsignedInt(UintTy::U32)),\n             ConstInt::U64(_) => Some(IntType::UnsignedInt(UintTy::U64)),\n+            ConstInt::U128(_) => Some(IntType::UnsignedInt(UintTy::U128)),\n             ConstInt::Usize(_) => Some(IntType::UnsignedInt(UintTy::Us)),\n             _ => None,\n         }\n@@ -317,13 +388,15 @@ impl ::std::fmt::Display for ConstInt {\n             I16(i) => write!(fmt, \"{}i16\", i),\n             I32(i) => write!(fmt, \"{}i32\", i),\n             I64(i) => write!(fmt, \"{}i64\", i),\n+            I128(i) => write!(fmt, \"{}i128\", i),\n             Isize(ConstIsize::Is64(i)) => write!(fmt, \"{}isize\", i),\n             Isize(ConstIsize::Is32(i)) => write!(fmt, \"{}isize\", i),\n             Isize(ConstIsize::Is16(i)) => write!(fmt, \"{}isize\", i),\n             U8(i) => write!(fmt, \"{}u8\", i),\n             U16(i) => write!(fmt, \"{}u16\", i),\n             U32(i) => write!(fmt, \"{}u32\", i),\n             U64(i) => write!(fmt, \"{}u64\", i),\n+            U128(i) => write!(fmt, \"{}u128\", i),\n             Usize(ConstUsize::Us64(i)) => write!(fmt, \"{}usize\", i),\n             Usize(ConstUsize::Us32(i)) => write!(fmt, \"{}usize\", i),\n             Usize(ConstUsize::Us16(i)) => write!(fmt, \"{}usize\", i),\n@@ -351,13 +424,15 @@ macro_rules! impl_binop {\n                     (I16(a), I16(b)) => a.$checked_func(b).map(I16),\n                     (I32(a), I32(b)) => a.$checked_func(b).map(I32),\n                     (I64(a), I64(b)) => a.$checked_func(b).map(I64),\n+                    (I128(a), I128(b)) => a.$checked_func(b).map(I128),\n                     (Isize(Is16(a)), Isize(Is16(b))) => a.$checked_func(b).map(Is16).map(Isize),\n                     (Isize(Is32(a)), Isize(Is32(b))) => a.$checked_func(b).map(Is32).map(Isize),\n                     (Isize(Is64(a)), Isize(Is64(b))) => a.$checked_func(b).map(Is64).map(Isize),\n                     (U8(a), U8(b)) => a.$checked_func(b).map(U8),\n                     (U16(a), U16(b)) => a.$checked_func(b).map(U16),\n                     (U32(a), U32(b)) => a.$checked_func(b).map(U32),\n                     (U64(a), U64(b)) => a.$checked_func(b).map(U64),\n+                    (U128(a), U128(b)) => a.$checked_func(b).map(U128),\n                     (Usize(Us16(a)), Usize(Us16(b))) => a.$checked_func(b).map(Us16).map(Usize),\n                     (Usize(Us32(a)), Usize(Us32(b))) => a.$checked_func(b).map(Us32).map(Usize),\n                     (Usize(Us64(a)), Usize(Us64(b))) => a.$checked_func(b).map(Us64).map(Usize),\n@@ -380,13 +455,15 @@ macro_rules! derive_binop {\n                     (I16(a), I16(b)) => Ok(I16(a.$func(b))),\n                     (I32(a), I32(b)) => Ok(I32(a.$func(b))),\n                     (I64(a), I64(b)) => Ok(I64(a.$func(b))),\n+                    (I128(a), I128(b)) => Ok(I128(a.$func(b))),\n                     (Isize(Is16(a)), Isize(Is16(b))) => Ok(Isize(Is16(a.$func(b)))),\n                     (Isize(Is32(a)), Isize(Is32(b))) => Ok(Isize(Is32(a.$func(b)))),\n                     (Isize(Is64(a)), Isize(Is64(b))) => Ok(Isize(Is64(a.$func(b)))),\n                     (U8(a), U8(b)) => Ok(U8(a.$func(b))),\n                     (U16(a), U16(b)) => Ok(U16(a.$func(b))),\n                     (U32(a), U32(b)) => Ok(U32(a.$func(b))),\n                     (U64(a), U64(b)) => Ok(U64(a.$func(b))),\n+                    (U128(a), U128(b)) => Ok(U128(a.$func(b))),\n                     (Usize(Us16(a)), Usize(Us16(b))) => Ok(Usize(Us16(a.$func(b)))),\n                     (Usize(Us32(a)), Usize(Us32(b))) => Ok(Usize(Us32(a.$func(b)))),\n                     (Usize(Us64(a)), Usize(Us64(b))) => Ok(Usize(Us64(a.$func(b)))),\n@@ -406,6 +483,11 @@ derive_binop!(BitAnd, bitand);\n derive_binop!(BitOr, bitor);\n derive_binop!(BitXor, bitxor);\n \n+#[cfg(not(stage0))]\n+const I128_MIN: i128 = ::std::i128::MIN;\n+#[cfg(stage0)]\n+const I128_MIN: i128 = ::std::i64::MIN;\n+\n fn check_division(\n     lhs: ConstInt,\n     rhs: ConstInt,\n@@ -417,6 +499,7 @@ fn check_division(\n         (I16(_), I16(0)) => Err(zerr),\n         (I32(_), I32(0)) => Err(zerr),\n         (I64(_), I64(0)) => Err(zerr),\n+        (I128(_), I128(0)) => Err(zerr),\n         (Isize(_), Isize(Is16(0))) => Err(zerr),\n         (Isize(_), Isize(Is32(0))) => Err(zerr),\n         (Isize(_), Isize(Is64(0))) => Err(zerr),\n@@ -426,6 +509,7 @@ fn check_division(\n         (U16(_), U16(0)) => Err(zerr),\n         (U32(_), U32(0)) => Err(zerr),\n         (U64(_), U64(0)) => Err(zerr),\n+        (U128(_), U128(0)) => Err(zerr),\n         (Usize(_), Usize(Us16(0))) => Err(zerr),\n         (Usize(_), Usize(Us32(0))) => Err(zerr),\n         (Usize(_), Usize(Us64(0))) => Err(zerr),\n@@ -435,10 +519,11 @@ fn check_division(\n         (I16(::std::i16::MIN), I16(-1)) => Err(Overflow(op)),\n         (I32(::std::i32::MIN), I32(-1)) => Err(Overflow(op)),\n         (I64(::std::i64::MIN), I64(-1)) => Err(Overflow(op)),\n+        (I128(I128_MIN), I128(-1)) => Err(Overflow(op)),\n         (Isize(Is16(::std::i16::MIN)), Isize(Is16(-1))) => Err(Overflow(op)),\n         (Isize(Is32(::std::i32::MIN)), Isize(Is32(-1))) => Err(Overflow(op)),\n         (Isize(Is64(::std::i64::MIN)), Isize(Is64(-1))) => Err(Overflow(op)),\n-        (InferSigned(::std::i64::MIN), InferSigned(-1)) => Err(Overflow(op)),\n+        (InferSigned(I128_MIN), InferSigned(-1)) => Err(Overflow(op)),\n \n         _ => Ok(()),\n     }\n@@ -454,6 +539,7 @@ impl ::std::ops::Div for ConstInt {\n             (I16(a), I16(b)) => Ok(I16(a/b)),\n             (I32(a), I32(b)) => Ok(I32(a/b)),\n             (I64(a), I64(b)) => Ok(I64(a/b)),\n+            (I128(a), I128(b)) => Ok(I128(a/b)),\n             (Isize(Is16(a)), Isize(Is16(b))) => Ok(Isize(Is16(a/b))),\n             (Isize(Is32(a)), Isize(Is32(b))) => Ok(Isize(Is32(a/b))),\n             (Isize(Is64(a)), Isize(Is64(b))) => Ok(Isize(Is64(a/b))),\n@@ -463,6 +549,7 @@ impl ::std::ops::Div for ConstInt {\n             (U16(a), U16(b)) => Ok(U16(a/b)),\n             (U32(a), U32(b)) => Ok(U32(a/b)),\n             (U64(a), U64(b)) => Ok(U64(a/b)),\n+            (U128(a), U128(b)) => Ok(U128(a/b)),\n             (Usize(Us16(a)), Usize(Us16(b))) => Ok(Usize(Us16(a/b))),\n             (Usize(Us32(a)), Usize(Us32(b))) => Ok(Usize(Us32(a/b))),\n             (Usize(Us64(a)), Usize(Us64(b))) => Ok(Usize(Us64(a/b))),\n@@ -484,6 +571,7 @@ impl ::std::ops::Rem for ConstInt {\n             (I16(a), I16(b)) => Ok(I16(a%b)),\n             (I32(a), I32(b)) => Ok(I32(a%b)),\n             (I64(a), I64(b)) => Ok(I64(a%b)),\n+            (I128(a), I128(b)) => Ok(I128(a%b)),\n             (Isize(Is16(a)), Isize(Is16(b))) => Ok(Isize(Is16(a%b))),\n             (Isize(Is32(a)), Isize(Is32(b))) => Ok(Isize(Is32(a%b))),\n             (Isize(Is64(a)), Isize(Is64(b))) => Ok(Isize(Is64(a%b))),\n@@ -493,6 +581,7 @@ impl ::std::ops::Rem for ConstInt {\n             (U16(a), U16(b)) => Ok(U16(a%b)),\n             (U32(a), U32(b)) => Ok(U32(a%b)),\n             (U64(a), U64(b)) => Ok(U64(a%b)),\n+            (U128(a), U128(b)) => Ok(U128(a%b)),\n             (Usize(Us16(a)), Usize(Us16(b))) => Ok(Usize(Us16(a%b))),\n             (Usize(Us32(a)), Usize(Us32(b))) => Ok(Usize(Us32(a%b))),\n             (Usize(Us64(a)), Usize(Us64(b))) => Ok(Usize(Us64(a%b))),\n@@ -512,13 +601,15 @@ impl ::std::ops::Shl<ConstInt> for ConstInt {\n             I16(a) => Ok(I16(overflowing!(a.overflowing_shl(b), Op::Shl))),\n             I32(a) => Ok(I32(overflowing!(a.overflowing_shl(b), Op::Shl))),\n             I64(a) => Ok(I64(overflowing!(a.overflowing_shl(b), Op::Shl))),\n+            I128(a) => Ok(I128(overflowing!(a.overflowing_shl(b), Op::Shl))),\n             Isize(Is16(a)) => Ok(Isize(Is16(overflowing!(a.overflowing_shl(b), Op::Shl)))),\n             Isize(Is32(a)) => Ok(Isize(Is32(overflowing!(a.overflowing_shl(b), Op::Shl)))),\n             Isize(Is64(a)) => Ok(Isize(Is64(overflowing!(a.overflowing_shl(b), Op::Shl)))),\n             U8(a) => Ok(U8(overflowing!(a.overflowing_shl(b), Op::Shl))),\n             U16(a) => Ok(U16(overflowing!(a.overflowing_shl(b), Op::Shl))),\n             U32(a) => Ok(U32(overflowing!(a.overflowing_shl(b), Op::Shl))),\n             U64(a) => Ok(U64(overflowing!(a.overflowing_shl(b), Op::Shl))),\n+            U128(a) => Ok(U128(overflowing!(a.overflowing_shl(b), Op::Shl))),\n             Usize(Us16(a)) => Ok(Usize(Us16(overflowing!(a.overflowing_shl(b), Op::Shl)))),\n             Usize(Us32(a)) => Ok(Usize(Us32(overflowing!(a.overflowing_shl(b), Op::Shl)))),\n             Usize(Us64(a)) => Ok(Usize(Us64(overflowing!(a.overflowing_shl(b), Op::Shl)))),\n@@ -537,13 +628,15 @@ impl ::std::ops::Shr<ConstInt> for ConstInt {\n             I16(a) => Ok(I16(overflowing!(a.overflowing_shr(b), Op::Shr))),\n             I32(a) => Ok(I32(overflowing!(a.overflowing_shr(b), Op::Shr))),\n             I64(a) => Ok(I64(overflowing!(a.overflowing_shr(b), Op::Shr))),\n+            I128(a) => Ok(I128(overflowing!(a.overflowing_shr(b), Op::Shr))),\n             Isize(Is16(a)) => Ok(Isize(Is16(overflowing!(a.overflowing_shr(b), Op::Shr)))),\n             Isize(Is32(a)) => Ok(Isize(Is32(overflowing!(a.overflowing_shr(b), Op::Shr)))),\n             Isize(Is64(a)) => Ok(Isize(Is64(overflowing!(a.overflowing_shr(b), Op::Shr)))),\n             U8(a) => Ok(U8(overflowing!(a.overflowing_shr(b), Op::Shr))),\n             U16(a) => Ok(U16(overflowing!(a.overflowing_shr(b), Op::Shr))),\n             U32(a) => Ok(U32(overflowing!(a.overflowing_shr(b), Op::Shr))),\n             U64(a) => Ok(U64(overflowing!(a.overflowing_shr(b), Op::Shr))),\n+            U128(a) => Ok(U128(overflowing!(a.overflowing_shr(b), Op::Shr))),\n             Usize(Us16(a)) => Ok(Usize(Us16(overflowing!(a.overflowing_shr(b), Op::Shr)))),\n             Usize(Us32(a)) => Ok(Usize(Us32(overflowing!(a.overflowing_shr(b), Op::Shr)))),\n             Usize(Us64(a)) => Ok(Usize(Us64(overflowing!(a.overflowing_shr(b), Op::Shr)))),\n@@ -561,22 +654,14 @@ impl ::std::ops::Neg for ConstInt {\n             I16(a) => Ok(I16(overflowing!(a.overflowing_neg(), Op::Neg))),\n             I32(a) => Ok(I32(overflowing!(a.overflowing_neg(), Op::Neg))),\n             I64(a) => Ok(I64(overflowing!(a.overflowing_neg(), Op::Neg))),\n+            I128(a) => Ok(I128(overflowing!(a.overflowing_neg(), Op::Neg))),\n             Isize(Is16(a)) => Ok(Isize(Is16(overflowing!(a.overflowing_neg(), Op::Neg)))),\n             Isize(Is32(a)) => Ok(Isize(Is32(overflowing!(a.overflowing_neg(), Op::Neg)))),\n             Isize(Is64(a)) => Ok(Isize(Is64(overflowing!(a.overflowing_neg(), Op::Neg)))),\n-            U8(0) => Ok(U8(0)),\n-            U16(0) => Ok(U16(0)),\n-            U32(0) => Ok(U32(0)),\n-            U64(0) => Ok(U64(0)),\n-            Usize(Us16(0)) => Ok(Usize(Us16(0))),\n-            Usize(Us32(0)) => Ok(Usize(Us32(0))),\n-            Usize(Us64(0)) => Ok(Usize(Us64(0))),\n-            U8(_) => Err(UnsignedNegation),\n-            U16(_) => Err(UnsignedNegation),\n-            U32(_) => Err(UnsignedNegation),\n-            U64(_) => Err(UnsignedNegation),\n-            Usize(_) => Err(UnsignedNegation),\n-            Infer(a @ 0...as_u64::I64MAX) => Ok(InferSigned(-(a as i64))),\n+            a@U8(0) | a@U16(0) | a@U32(0) | a@U64(0) | a@U128(0) |\n+            a@Usize(Us16(0)) | a@Usize(Us32(0)) | a@Usize(Us64(0)) => Ok(a),\n+            U8(_) | U16(_) | U32(_) | U64(_) | U128(_) | Usize(_) => Err(UnsignedNegation),\n+            Infer(a @ 0...ubounds::I64MAX) => Ok(InferSigned(-(a as i128))),\n             Infer(_) => Err(Overflow(Op::Neg)),\n             InferSigned(a) => Ok(InferSigned(overflowing!(a.overflowing_neg(), Op::Neg))),\n         }\n@@ -591,13 +676,15 @@ impl ::std::ops::Not for ConstInt {\n             I16(a) => Ok(I16(!a)),\n             I32(a) => Ok(I32(!a)),\n             I64(a) => Ok(I64(!a)),\n+            I128(a) => Ok(I128(!a)),\n             Isize(Is16(a)) => Ok(Isize(Is16(!a))),\n             Isize(Is32(a)) => Ok(Isize(Is32(!a))),\n             Isize(Is64(a)) => Ok(Isize(Is64(!a))),\n             U8(a) => Ok(U8(!a)),\n             U16(a) => Ok(U16(!a)),\n             U32(a) => Ok(U32(!a)),\n             U64(a) => Ok(U64(!a)),\n+            U128(a) => Ok(U128(!a)),\n             Usize(Us16(a)) => Ok(Usize(Us16(!a))),\n             Usize(Us32(a)) => Ok(Usize(Us32(!a))),\n             Usize(Us64(a)) => Ok(Usize(Us64(!a))),"}, {"sha": "19ae0c91fc5f9b2ddd435178c9abaf0afaef5341", "filename": "src/librustc_const_math/is.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_const_math%2Fis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_const_math%2Fis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_math%2Fis.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -10,6 +10,7 @@\n \n use syntax::ast;\n use super::err::*;\n+use rustc_i128::i128;\n \n /// Depending on the target only one variant is ever used in a compilation.\n /// Anything else is an error. This invariant is checked at several locations\n@@ -41,11 +42,11 @@ impl ConstIsize {\n             _ => unreachable!(),\n         }\n     }\n-    pub fn new_truncating(i: i64, target_int_ty: ast::IntTy) -> Self {\n+    pub fn new_truncating(i: i128, target_int_ty: ast::IntTy) -> Self {\n         match target_int_ty {\n             ast::IntTy::I16 => Is16(i as i16),\n             ast::IntTy::I32 => Is32(i as i32),\n-            ast::IntTy::I64 => Is64(i),\n+            ast::IntTy::I64 => Is64(i as i64),\n             _ => unreachable!(),\n         }\n     }"}, {"sha": "597344a2c82d01b9f675bf668fdae0a6ae56ba13", "filename": "src/librustc_const_math/lib.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_const_math%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_const_math%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_math%2Flib.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -25,10 +25,14 @@\n \n #![feature(rustc_private)]\n #![feature(staged_api)]\n+#![feature(const_fn)]\n \n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;\n \n+// SNAP: remove use of this crate\n+extern crate rustc_i128;\n+\n extern crate serialize as rustc_serialize; // used by deriving\n \n mod float;"}, {"sha": "9ebf5cab6bb06000a18d4125e3fb3942ddc9c365", "filename": "src/librustc_const_math/us.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_const_math%2Fus.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_const_math%2Fus.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_const_math%2Fus.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -10,6 +10,7 @@\n \n use syntax::ast;\n use super::err::*;\n+use rustc_i128::u128;\n \n /// Depending on the target only one variant is ever used in a compilation.\n /// Anything else is an error. This invariant is checked at several locations\n@@ -41,11 +42,11 @@ impl ConstUsize {\n             _ => unreachable!(),\n         }\n     }\n-    pub fn new_truncating(i: u64, target_uint_ty: ast::UintTy) -> Self {\n+    pub fn new_truncating(i: u128, target_uint_ty: ast::UintTy) -> Self {\n         match target_uint_ty {\n             ast::UintTy::U16 => Us16(i as u16),\n             ast::UintTy::U32 => Us32(i as u32),\n-            ast::UintTy::U64 => Us64(i),\n+            ast::UintTy::U64 => Us64(i as u64),\n             _ => unreachable!(),\n         }\n     }"}, {"sha": "bb6103748102de1a49d1cd376b8d497039805d18", "filename": "src/librustc_data_structures/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_data_structures%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_data_structures%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2FCargo.toml?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -11,3 +11,4 @@ crate-type = [\"dylib\"]\n [dependencies]\n log = { path = \"../liblog\" }\n serialize = { path = \"../libserialize\" }\n+rustc_i128 = { path = \"../librustc_i128\" }"}, {"sha": "d3ec674daed4da97d90fa62cfc6d2b5dd4289741", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -44,6 +44,8 @@ extern crate serialize as rustc_serialize; // used by deriving\n #[cfg(unix)]\n extern crate libc;\n \n+extern crate rustc_i128;\n+\n pub use rustc_serialize::hex::ToHex;\n \n pub mod array_vec;"}, {"sha": "87048eff5b78b9fcc3af0d37be46da11cc29ab65", "filename": "src/librustc_data_structures/stable_hasher.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_data_structures%2Fstable_hasher.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_data_structures%2Fstable_hasher.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fstable_hasher.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -13,13 +13,14 @@ use std::marker::PhantomData;\n use std::mem;\n use blake2b::Blake2bHasher;\n use rustc_serialize::leb128;\n+use rustc_i128::{u128,i128};\n \n fn write_unsigned_leb128_to_buf(buf: &mut [u8; 16], value: u64) -> usize {\n-    leb128::write_unsigned_leb128_to(value, |i, v| buf[i] = v)\n+    leb128::write_unsigned_leb128_to(value as u128, |i, v| buf[i] = v)\n }\n \n fn write_signed_leb128_to_buf(buf: &mut [u8; 16], value: i64) -> usize {\n-    leb128::write_signed_leb128_to(value, |i, v| buf[i] = v)\n+    leb128::write_signed_leb128_to(value as i128, |i, v| buf[i] = v)\n }\n \n /// When hashing something that ends up affecting properties like symbol names. We"}, {"sha": "6fd67637db7e6f27fdbc9c77e64a649ef9cda858", "filename": "src/librustc_i128/Cargo.toml", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_i128%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_i128%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_i128%2FCargo.toml?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -0,0 +1,8 @@\n+[package]\n+authors = [\"The Rust Project Developers\"]\n+name = \"rustc_i128\"\n+version = \"0.0.0\"\n+\n+[lib]\n+name = \"rustc_i128\"\n+path = \"lib.rs\""}, {"sha": "80f550c7f50e2089bd2388c1f593fa2a3499466f", "filename": "src/librustc_i128/lib.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_i128%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_i128%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_i128%2Flib.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+#![allow(non_camel_case_types)]\n+#![cfg_attr(not(stage0), feature(i128_type))]\n+#![no_std]\n+#![crate_type=\"rlib\"]\n+#![crate_name=\"rustc_i128\"]\n+\n+#[cfg(stage0)]\n+pub type i128 = i64;\n+#[cfg(stage0)]\n+pub type u128 = u64;\n+\n+#[cfg(not(stage0))]\n+pub type i128 = int::_i128;\n+#[cfg(not(stage0))]\n+pub type u128 = int::_u128;\n+#[cfg(not(stage0))]\n+mod int {\n+    pub type _i128 = i128;\n+    pub type _u128 = u128;\n+}"}, {"sha": "8a38f36a5d1335699f64429bc041eca9bfe9c41c", "filename": "src/librustc_incremental/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_incremental%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_incremental%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2FCargo.toml?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -16,3 +16,4 @@ serialize = { path = \"../libserialize\" }\n log = { path = \"../liblog\" }\n syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }\n+rustc_i128 = { path = \"../librustc_i128\" }"}, {"sha": "d02e4f9b165d8e4986cbd3ef68b9e3654dc24c25", "filename": "src/librustc_incremental/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_incremental%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_incremental%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_incremental%2Flib.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -33,6 +33,8 @@ extern crate serialize as rustc_serialize;\n #[macro_use] extern crate syntax;\n extern crate syntax_pos;\n \n+extern crate rustc_i128;\n+\n const ATTR_DIRTY: &'static str = \"rustc_dirty\";\n const ATTR_CLEAN: &'static str = \"rustc_clean\";\n const ATTR_DIRTY_METADATA: &'static str = \"rustc_metadata_dirty\";"}, {"sha": "272f8b4f64dbd65ef1ec6e291b40389a65904770", "filename": "src/librustc_lint/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_lint%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_lint%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2FCargo.toml?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -14,5 +14,6 @@ log = { path = \"../liblog\" }\n rustc = { path = \"../librustc\" }\n rustc_back = { path = \"../librustc_back\" }\n rustc_const_eval = { path = \"../librustc_const_eval\" }\n+rustc_i128 = { path = \"../librustc_i128\" }\n syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }"}, {"sha": "a24edfaaac1c2fa3689aab276ab2f8bb47ecc0d3", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -47,6 +47,8 @@ extern crate rustc_back;\n extern crate rustc_const_eval;\n extern crate syntax_pos;\n \n+extern crate rustc_i128;\n+\n pub use rustc::lint;\n pub use rustc::middle;\n pub use rustc::session;"}, {"sha": "95e955bd6833e85edf233bfd16d339b57c6b0815", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 33, "deletions": 26, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -33,6 +33,8 @@ use syntax::codemap;\n \n use rustc::hir;\n \n+use rustc_i128::{i128, u128};\n+\n register_long_diagnostics! {\n E0519: r##\"\n It is not allowed to negate an unsigned integer.\n@@ -147,7 +149,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                     if let Some(bits) = opt_ty_bits {\n                         let exceeding = if let hir::ExprLit(ref lit) = r.node {\n                             if let ast::LitKind::Int(shift, _) = lit.node {\n-                                shift >= bits\n+                                shift as u64 >= bits\n                             } else {\n                                 false\n                             }\n@@ -182,12 +184,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                                     t\n                                 };\n                                 let (_, max) = int_ty_range(int_type);\n+                                let max = max as u128;\n                                 let negative = self.negated_expr_id == e.id;\n \n                                 // Detect literal value out of range [min, max] inclusive\n                                 // avoiding use of -min to prevent overflow/panic\n-                                if (negative && v > max as u64 + 1) ||\n-                                   (!negative && v > max as u64) {\n+                                if (negative && v > max + 1) ||\n+                                   (!negative && v > max) {\n                                     cx.span_lint(OVERFLOWING_LITERALS,\n                                                  e.span,\n                                                  &format!(\"literal out of range for {:?}\", t));\n@@ -204,7 +207,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                             t\n                         };\n                         let (min, max) = uint_ty_range(uint_type);\n-                        let lit_val: u64 = match lit.node {\n+                        let lit_val: u128 = match lit.node {\n                             // _v is u8, within range by definition\n                             ast::LitKind::Byte(_v) => return,\n                             ast::LitKind::Int(v, _) => v,\n@@ -264,23 +267,25 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n \n         // for isize & usize, be conservative with the warnings, so that the\n         // warnings are consistent between 32- and 64-bit platforms\n-        fn int_ty_range(int_ty: ast::IntTy) -> (i64, i64) {\n+        fn int_ty_range(int_ty: ast::IntTy) -> (i128, i128) {\n             match int_ty {\n-                ast::IntTy::Is => (i64::MIN, i64::MAX),\n-                ast::IntTy::I8 => (i8::MIN as i64, i8::MAX as i64),\n-                ast::IntTy::I16 => (i16::MIN as i64, i16::MAX as i64),\n-                ast::IntTy::I32 => (i32::MIN as i64, i32::MAX as i64),\n-                ast::IntTy::I64 => (i64::MIN, i64::MAX),\n+                ast::IntTy::Is => (i64::min_value() as i128, i64::max_value() as i128),\n+                ast::IntTy::I8 => (i8::min_value() as i64 as i128, i8::max_value() as i128),\n+                ast::IntTy::I16 => (i16::min_value() as i64 as i128, i16::max_value() as i128),\n+                ast::IntTy::I32 => (i32::min_value() as i64 as i128, i32::max_value() as i128),\n+                ast::IntTy::I64 => (i64::min_value() as i128, i64::max_value() as i128),\n+                ast::IntTy::I128 =>(i128::min_value() as i128, i128::max_value()),\n             }\n         }\n \n-        fn uint_ty_range(uint_ty: ast::UintTy) -> (u64, u64) {\n+        fn uint_ty_range(uint_ty: ast::UintTy) -> (u128, u128) {\n             match uint_ty {\n-                ast::UintTy::Us => (u64::MIN, u64::MAX),\n-                ast::UintTy::U8 => (u8::MIN as u64, u8::MAX as u64),\n-                ast::UintTy::U16 => (u16::MIN as u64, u16::MAX as u64),\n-                ast::UintTy::U32 => (u32::MIN as u64, u32::MAX as u64),\n-                ast::UintTy::U64 => (u64::MIN, u64::MAX),\n+                ast::UintTy::Us => (u64::min_value() as u128, u64::max_value() as u128),\n+                ast::UintTy::U8 => (u8::min_value() as u128, u8::max_value() as u128),\n+                ast::UintTy::U16 => (u16::min_value() as u128, u16::max_value() as u128),\n+                ast::UintTy::U32 => (u32::min_value() as u128, u32::max_value() as u128),\n+                ast::UintTy::U64 => (u64::min_value() as u128, u64::max_value() as u128),\n+                ast::UintTy::U128 => (u128::min_value(), u128::max_value()),\n             }\n         }\n \n@@ -298,6 +303,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                 ast::IntTy::I16 => 16 as u64,\n                 ast::IntTy::I32 => 32,\n                 ast::IntTy::I64 => 64,\n+                ast::IntTy::I128 => 128,\n             }\n         }\n \n@@ -308,6 +314,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n                 ast::UintTy::U16 => 16,\n                 ast::UintTy::U32 => 32,\n                 ast::UintTy::U64 => 64,\n+                ast::UintTy::U128 => 128,\n             }\n         }\n \n@@ -327,28 +334,28 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n             match tcx.tables().node_id_to_type(expr.id).sty {\n                 ty::TyInt(int_ty) => {\n                     let (min, max) = int_ty_range(int_ty);\n-                    let lit_val: i64 = match lit.node {\n+                    let lit_val: i128 = match lit.node {\n                         hir::ExprLit(ref li) => {\n                             match li.node {\n                                 ast::LitKind::Int(v, ast::LitIntType::Signed(_)) |\n-                                ast::LitKind::Int(v, ast::LitIntType::Unsuffixed) => v as i64,\n-                                _ => return true,\n+                                ast::LitKind::Int(v, ast::LitIntType::Unsuffixed) => v as i128,\n+                                _ => return true\n                             }\n-                        }\n-                        _ => bug!(),\n+                        },\n+                        _ => bug!()\n                     };\n                     is_valid(norm_binop, lit_val, min, max)\n                 }\n                 ty::TyUint(uint_ty) => {\n-                    let (min, max): (u64, u64) = uint_ty_range(uint_ty);\n-                    let lit_val: u64 = match lit.node {\n+                    let (min, max) :(u128, u128) = uint_ty_range(uint_ty);\n+                    let lit_val: u128 = match lit.node {\n                         hir::ExprLit(ref li) => {\n                             match li.node {\n                                 ast::LitKind::Int(v, _) => v,\n-                                _ => return true,\n+                                _ => return true\n                             }\n-                        }\n-                        _ => bug!(),\n+                        },\n+                        _ => bug!()\n                     };\n                     is_valid(norm_binop, lit_val, min, max)\n                 }"}, {"sha": "2ee4cc49435611316e1a7e1d3b717dae609c8574", "filename": "src/librustc_llvm/build.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_llvm%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_llvm%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fbuild.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -96,7 +96,7 @@ fn main() {\n \n     let optional_components =\n         [\"x86\", \"arm\", \"aarch64\", \"mips\", \"powerpc\", \"pnacl\", \"systemz\", \"jsbackend\", \"msp430\",\n-         \"sparc\"];\n+         \"sparc\", \"nvptx\"];\n \n     // FIXME: surely we don't need all these components, right? Stuff like mcjit\n     //        or interpreter the compiler itself never uses."}, {"sha": "6815da4cc20fdecdcd08c2240a4b9f50e485c2a8", "filename": "src/librustc_llvm/ffi.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_llvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_llvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fffi.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -33,7 +33,7 @@ pub enum LLVMRustResult {\n // Consts for the LLVM CallConv type, pre-cast to usize.\n \n /// LLVM CallingConv::ID. Should we wrap this?\n-#[derive(Copy, Clone, PartialEq)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n #[repr(C)]\n pub enum CallConv {\n     CCallConv = 0,\n@@ -42,6 +42,7 @@ pub enum CallConv {\n     X86StdcallCallConv = 64,\n     X86FastcallCallConv = 65,\n     ArmAapcsCallConv = 67,\n+    PtxKernel = 71,\n     X86_64_SysV = 78,\n     X86_64_Win64 = 79,\n     X86_VectorCall = 80,\n@@ -577,9 +578,12 @@ extern \"C\" {\n \n     // Operations on scalar constants\n     pub fn LLVMConstInt(IntTy: TypeRef, N: c_ulonglong, SignExtend: Bool) -> ValueRef;\n+    pub fn LLVMConstIntOfArbitraryPrecision(IntTy: TypeRef, Wn: c_uint, Ws: *const u64) -> ValueRef;\n     pub fn LLVMConstReal(RealTy: TypeRef, N: f64) -> ValueRef;\n     pub fn LLVMConstIntGetZExtValue(ConstantVal: ValueRef) -> c_ulonglong;\n     pub fn LLVMConstIntGetSExtValue(ConstantVal: ValueRef) -> c_longlong;\n+    pub fn LLVMRustConstInt128Get(ConstantVal: ValueRef, SExt: bool,\n+                                  high: *mut u64, low: *mut u64) -> bool;\n \n \n     // Operations on composite constants"}, {"sha": "1e45ea083c9e011046d33475e8e0df4852d48161", "filename": "src/librustc_llvm/lib.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_llvm%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_llvm%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Flib.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -376,6 +376,11 @@ pub fn initialize_available_targets() {\n                  LLVMInitializeSparcTargetMC,\n                  LLVMInitializeSparcAsmPrinter,\n                  LLVMInitializeSparcAsmParser);\n+    init_target!(llvm_component = \"nvptx\",\n+                 LLVMInitializeNVPTXTargetInfo,\n+                 LLVMInitializeNVPTXTarget,\n+                 LLVMInitializeNVPTXTargetMC,\n+                 LLVMInitializeNVPTXAsmPrinter);\n }\n \n pub fn last_error() -> Option<String> {"}, {"sha": "4bd98c087f5171bcfc6c00a85665113cc575b39e", "filename": "src/librustc_metadata/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_metadata%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_metadata%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2FCargo.toml?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -18,6 +18,7 @@ rustc_const_math = { path = \"../librustc_const_math\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_errors = { path = \"../librustc_errors\" }\n rustc_llvm = { path = \"../librustc_llvm\" }\n+rustc_i128 = { path = \"../librustc_i128\" }\n serialize = { path = \"../libserialize\" }\n syntax = { path = \"../libsyntax\" }\n syntax_ext = { path = \"../libsyntax_ext\" }"}, {"sha": "dad956afb5e60ebbe8e505e2f70dde6c2ffc745f", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -43,6 +43,7 @@ use syntax::attr;\n use syntax::ast::{self, NodeId};\n use syntax::codemap;\n use syntax_pos::{self, Span, BytePos, Pos, DUMMY_SP};\n+use rustc_i128::{u128, i128};\n \n pub struct DecodeContext<'a, 'tcx: 'a> {\n     opaque: opaque::Decoder<'a>,\n@@ -211,12 +212,14 @@ impl<'doc, 'tcx> Decoder for DecodeContext<'doc, 'tcx> {\n     decoder_methods! {\n         read_nil -> ();\n \n+        read_u128 -> u128;\n         read_u64 -> u64;\n         read_u32 -> u32;\n         read_u16 -> u16;\n         read_u8 -> u8;\n         read_usize -> usize;\n \n+        read_i128 -> i128;\n         read_i64 -> i64;\n         read_i32 -> i32;\n         read_i16 -> i16;"}, {"sha": "c3bcdf42d4edecca53c1d750fddea3943bdda989", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -43,6 +43,8 @@ use rustc::hir::itemlikevisit::ItemLikeVisitor;\n use rustc::hir::intravisit::{Visitor, NestedVisitorMap};\n use rustc::hir::intravisit;\n \n+use rustc_i128::{u128, i128};\n+\n use super::index_builder::{FromId, IndexBuilder, Untracked};\n \n pub struct EncodeContext<'a, 'tcx: 'a> {\n@@ -75,12 +77,14 @@ impl<'a, 'tcx> Encoder for EncodeContext<'a, 'tcx> {\n \n     encoder_methods! {\n         emit_usize(usize);\n+        emit_u128(u128);\n         emit_u64(u64);\n         emit_u32(u32);\n         emit_u16(u16);\n         emit_u8(u8);\n \n         emit_isize(isize);\n+        emit_i128(i128);\n         emit_i64(i64);\n         emit_i32(i32);\n         emit_i16(i16);\n@@ -259,7 +263,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         let data = VariantData {\n             ctor_kind: variant.ctor_kind,\n-            disr: variant.disr_val.to_u64_unchecked(),\n+            disr: variant.disr_val.to_u128_unchecked(),\n             struct_ctor: None,\n         };\n \n@@ -386,7 +390,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n         let data = VariantData {\n             ctor_kind: variant.ctor_kind,\n-            disr: variant.disr_val.to_u64_unchecked(),\n+            disr: variant.disr_val.to_u128_unchecked(),\n             struct_ctor: Some(def_id.index),\n         };\n \n@@ -648,7 +652,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n                 };\n                 EntryKind::Struct(self.lazy(&VariantData {\n                     ctor_kind: variant.ctor_kind,\n-                    disr: variant.disr_val.to_u64_unchecked(),\n+                    disr: variant.disr_val.to_u128_unchecked(),\n                     struct_ctor: struct_ctor,\n                 }))\n             }\n@@ -657,7 +661,7 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n \n                 EntryKind::Union(self.lazy(&VariantData {\n                     ctor_kind: variant.ctor_kind,\n-                    disr: variant.disr_val.to_u64_unchecked(),\n+                    disr: variant.disr_val.to_u128_unchecked(),\n                     struct_ctor: None,\n                 }))\n             }"}, {"sha": "f4ccc01544aa660a045ab396d0361440ff013da4", "filename": "src/librustc_metadata/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_metadata%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_metadata%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Flib.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -45,9 +45,12 @@ extern crate rustc_back;\n extern crate rustc_const_math;\n extern crate rustc_data_structures;\n extern crate rustc_llvm;\n+extern crate rustc_i128;\n \n mod diagnostics;\n \n+pub use rustc::middle;\n+\n mod astencode;\n mod index_builder;\n mod index;"}, {"sha": "74825a5c6e3f676325a2419ee782aca90cead7ef", "filename": "src/librustc_metadata/schema.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_metadata%2Fschema.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_metadata%2Fschema.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fschema.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -27,6 +27,8 @@ use syntax_pos::{self, Span};\n \n use std::marker::PhantomData;\n \n+use rustc_i128::u128;\n+\n pub fn rustc_version() -> String {\n     format!(\"rustc {}\",\n             option_env!(\"CFG_VERSION\").unwrap_or(\"unknown version\"))\n@@ -264,7 +266,7 @@ pub struct FnData {\n #[derive(RustcEncodable, RustcDecodable)]\n pub struct VariantData {\n     pub ctor_kind: CtorKind,\n-    pub disr: u64,\n+    pub disr: u128,\n \n     /// If this is a struct's only variant, this\n     /// is the index of the \"struct ctor\" item."}, {"sha": "7e26aa9a57bf57cfd09ac9a473aa5e2116535f3d", "filename": "src/librustc_mir/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_mir%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_mir%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2FCargo.toml?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -17,5 +17,6 @@ rustc_const_eval = { path = \"../librustc_const_eval\" }\n rustc_const_math = { path = \"../librustc_const_math\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_bitflags = { path = \"../librustc_bitflags\" }\n+rustc_i128 = { path = \"../librustc_i128\" }\n syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }"}, {"sha": "8199a08c852de872c8f96e39ff7a3b8c39cc4990", "filename": "src/librustc_mir/build/expr/as_rvalue.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -15,6 +15,7 @@ use std;\n use rustc_const_math::{ConstMathErr, Op};\n use rustc_data_structures::fx::FxHashMap;\n use rustc_data_structures::indexed_vec::Idx;\n+use rustc_i128::i128;\n \n use build::{BlockAnd, BlockAndExtension, Builder};\n use build::expr::category::{Category, RvalueFunc};\n@@ -347,6 +348,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     ast::IntTy::I16 => ConstInt::I16(-1),\n                     ast::IntTy::I32 => ConstInt::I32(-1),\n                     ast::IntTy::I64 => ConstInt::I64(-1),\n+                    ast::IntTy::I128 => ConstInt::I128(-1),\n                     ast::IntTy::Is => {\n                         let int_ty = self.hir.tcx().sess.target.int_type;\n                         let val = ConstIsize::new(-1, int_ty).unwrap();\n@@ -369,10 +371,11 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n         let literal = match ty.sty {\n             ty::TyInt(ity) => {\n                 let val = match ity {\n-                    ast::IntTy::I8  => ConstInt::I8(std::i8::MIN),\n-                    ast::IntTy::I16 => ConstInt::I16(std::i16::MIN),\n-                    ast::IntTy::I32 => ConstInt::I32(std::i32::MIN),\n-                    ast::IntTy::I64 => ConstInt::I64(std::i64::MIN),\n+                    ast::IntTy::I8  => ConstInt::I8(i8::min_value()),\n+                    ast::IntTy::I16 => ConstInt::I16(i16::min_value()),\n+                    ast::IntTy::I32 => ConstInt::I32(i32::min_value()),\n+                    ast::IntTy::I64 => ConstInt::I64(i64::min_value()),\n+                    ast::IntTy::I128 => ConstInt::I128(i128::min_value()),\n                     ast::IntTy::Is => {\n                         let int_ty = self.hir.tcx().sess.target.int_type;\n                         let min = match int_ty {"}, {"sha": "99aa5cb0fa86eb1f5d735cd1b945f4f17d5937a2", "filename": "src/librustc_mir/build/misc.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fbuild%2Fmisc.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -66,6 +66,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     ast::UintTy::U16 => ConstInt::U16(0),\n                     ast::UintTy::U32 => ConstInt::U32(0),\n                     ast::UintTy::U64 => ConstInt::U64(0),\n+                    ast::UintTy::U128 => ConstInt::U128(0),\n                     ast::UintTy::Us => {\n                         let uint_ty = self.hir.tcx().sess.target.uint_type;\n                         let val = ConstUsize::new(0, uint_ty).unwrap();\n@@ -81,6 +82,7 @@ impl<'a, 'gcx, 'tcx> Builder<'a, 'gcx, 'tcx> {\n                     ast::IntTy::I16 => ConstInt::I16(0),\n                     ast::IntTy::I32 => ConstInt::I32(0),\n                     ast::IntTy::I64 => ConstInt::I64(0),\n+                    ast::IntTy::I128 => ConstInt::I128(0),\n                     ast::IntTy::Is => {\n                         let int_ty = self.hir.tcx().sess.target.int_type;\n                         let val = ConstIsize::new(0, int_ty).unwrap();"}, {"sha": "a608275cefa0610da7d763139c3ec4159e7740fd", "filename": "src/librustc_mir/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_mir%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_mir%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Flib.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -41,6 +41,8 @@ extern crate syntax_pos;\n extern crate rustc_const_math;\n extern crate rustc_const_eval;\n \n+extern crate rustc_i128;\n+\n pub mod diagnostics;\n \n pub mod build;"}, {"sha": "e814050e9609771a0d859249dcd95c173ed7c703", "filename": "src/librustc_platform_intrinsics/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_platform_intrinsics%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_platform_intrinsics%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_platform_intrinsics%2Flib.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -95,6 +95,7 @@ static VOID: Type = Type::Void;\n mod x86;\n mod arm;\n mod aarch64;\n+mod nvptx;\n \n impl Intrinsic {\n     pub fn find(name: &str) -> Option<Intrinsic> {\n@@ -104,6 +105,8 @@ impl Intrinsic {\n             arm::find(name)\n         } else if name.starts_with(\"aarch64_\") {\n             aarch64::find(name)\n+        } else if name.starts_with(\"nvptx_\") {\n+            nvptx::find(name)\n         } else {\n             None\n         }"}, {"sha": "82408723ebe6fafe8cf342b58514c1c62cec63b5", "filename": "src/librustc_platform_intrinsics/nvptx.rs", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_platform_intrinsics%2Fnvptx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_platform_intrinsics%2Fnvptx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_platform_intrinsics%2Fnvptx.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -0,0 +1,92 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// DO NOT EDIT: autogenerated by etc/platform-intrinsics/generator.py\n+// ignore-tidy-linelength\n+\n+#![allow(unused_imports)]\n+\n+use {Intrinsic, Type};\n+use IntrinsicDef::Named;\n+\n+// The default inlining settings trigger a pathological behaviour in\n+// LLVM, which causes makes compilation very slow. See #28273.\n+#[inline(never)]\n+pub fn find(name: &str) -> Option<Intrinsic> {\n+    if !name.starts_with(\"nvptx\") { return None }\n+    Some(match &name[\"nvptx\".len()..] {\n+        \"_syncthreads\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 0] = []; &INPUTS },\n+            output: &::VOID,\n+            definition: Named(\"llvm.cuda.syncthreads\")\n+        },\n+        \"_block_dim_x\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 0] = []; &INPUTS },\n+            output: &::I32,\n+            definition: Named(\"llvm.nvvm.read.ptx.sreg.ntid.x\")\n+        },\n+        \"_block_dim_y\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 0] = []; &INPUTS },\n+            output: &::I32,\n+            definition: Named(\"llvm.nvvm.read.ptx.sreg.ntid.y\")\n+        },\n+        \"_block_dim_z\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 0] = []; &INPUTS },\n+            output: &::I32,\n+            definition: Named(\"llvm.nvvm.read.ptx.sreg.ntid.z\")\n+        },\n+        \"_block_idx_x\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 0] = []; &INPUTS },\n+            output: &::I32,\n+            definition: Named(\"llvm.nvvm.read.ptx.sreg.ctaid.x\")\n+        },\n+        \"_block_idx_y\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 0] = []; &INPUTS },\n+            output: &::I32,\n+            definition: Named(\"llvm.nvvm.read.ptx.sreg.ctaid.y\")\n+        },\n+        \"_block_idx_z\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 0] = []; &INPUTS },\n+            output: &::I32,\n+            definition: Named(\"llvm.nvvm.read.ptx.sreg.ctaid.z\")\n+        },\n+        \"_grid_dim_x\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 0] = []; &INPUTS },\n+            output: &::I32,\n+            definition: Named(\"llvm.nvvm.read.ptx.sreg.nctaid.x\")\n+        },\n+        \"_grid_dim_y\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 0] = []; &INPUTS },\n+            output: &::I32,\n+            definition: Named(\"llvm.nvvm.read.ptx.sreg.nctaid.y\")\n+        },\n+        \"_grid_dim_z\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 0] = []; &INPUTS },\n+            output: &::I32,\n+            definition: Named(\"llvm.nvvm.read.ptx.sreg.nctaid.z\")\n+        },\n+        \"_thread_idx_x\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 0] = []; &INPUTS },\n+            output: &::I32,\n+            definition: Named(\"llvm.nvvm.read.ptx.sreg.tid.x\")\n+        },\n+        \"_thread_idx_y\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 0] = []; &INPUTS },\n+            output: &::I32,\n+            definition: Named(\"llvm.nvvm.read.ptx.sreg.tid.y\")\n+        },\n+        \"_thread_idx_z\" => Intrinsic {\n+            inputs: { static INPUTS: [&'static Type; 0] = []; &INPUTS },\n+            output: &::I32,\n+            definition: Named(\"llvm.nvvm.read.ptx.sreg.tid.z\")\n+        },\n+        _ => return None,\n+    })\n+}"}, {"sha": "b7908f0c0edded5a92e26cd17a00ab01062d7914", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 16, "deletions": 2, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -61,6 +61,7 @@ use syntax::ast::{FnDecl, ForeignItem, ForeignItemKind, Generics};\n use syntax::ast::{Item, ItemKind, ImplItem, ImplItemKind};\n use syntax::ast::{Local, Mutability, Pat, PatKind, Path};\n use syntax::ast::{QSelf, TraitItemKind, TraitRef, Ty, TyKind};\n+use syntax::feature_gate::{emit_feature_err, GateIssue};\n \n use syntax_pos::{Span, DUMMY_SP, MultiSpan};\n use errors::DiagnosticBuilder;\n@@ -1005,13 +1006,14 @@ impl PrimitiveTypeTable {\n         table.intern(\"i16\", TyInt(IntTy::I16));\n         table.intern(\"i32\", TyInt(IntTy::I32));\n         table.intern(\"i64\", TyInt(IntTy::I64));\n+        table.intern(\"i128\", TyInt(IntTy::I128));\n         table.intern(\"str\", TyStr);\n         table.intern(\"usize\", TyUint(UintTy::Us));\n         table.intern(\"u8\", TyUint(UintTy::U8));\n         table.intern(\"u16\", TyUint(UintTy::U16));\n         table.intern(\"u32\", TyUint(UintTy::U32));\n         table.intern(\"u64\", TyUint(UintTy::U64));\n-\n+        table.intern(\"u128\", TyUint(UintTy::U128));\n         table\n     }\n \n@@ -2308,8 +2310,20 @@ impl<'a> Resolver<'a> {\n             PathResult::Module(..) | PathResult::Failed(..)\n                     if (ns == TypeNS || path.len() > 1) &&\n                        self.primitive_type_table.primitive_types.contains_key(&path[0].name) => {\n+                let prim = self.primitive_type_table.primitive_types[&path[0].name];\n+                match prim {\n+                    TyUint(UintTy::U128) | TyInt(IntTy::I128) => {\n+                        if !self.session.features.borrow().i128_type {\n+                            emit_feature_err(&self.session.parse_sess,\n+                                                \"i128_type\", span, GateIssue::Language,\n+                                                \"128-bit type is unstable\");\n+\n+                        }\n+                    }\n+                    _ => {}\n+                }\n                 PathResolution {\n-                    base_def: Def::PrimTy(self.primitive_type_table.primitive_types[&path[0].name]),\n+                    base_def: Def::PrimTy(prim),\n                     depth: path.len() - 1,\n                 }\n             }"}, {"sha": "47033f74e0e33628fa51fc8b98ae39129af77828", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -28,7 +28,7 @@ use syntax::ext::expand::{Expansion, mark_tts};\n use syntax::ext::hygiene::Mark;\n use syntax::ext::tt::macro_rules;\n use syntax::feature_gate::{emit_feature_err, GateIssue};\n-use syntax::fold::Folder;\n+use syntax::fold::{self, Folder};\n use syntax::ptr::P;\n use syntax::symbol::keywords;\n use syntax::util::lev_distance::find_best_match_for_name;\n@@ -117,6 +117,10 @@ impl<'a> base::Resolver for Resolver<'a> {\n                 }\n                 path\n             }\n+\n+            fn fold_mac(&mut self, mac: ast::Mac) -> ast::Mac {\n+                fold::noop_fold_mac(mac, self)\n+            }\n         }\n \n         EliminateCrateVar(self).fold_item(item).expect_one(\"\")"}, {"sha": "93e2e472b75f13d22d4561c06df1165f4658418e", "filename": "src/librustc_trans/Cargo.toml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_trans%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_trans%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2FCargo.toml?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -23,7 +23,8 @@ rustc_data_structures = { path = \"../librustc_data_structures\" }\n rustc_errors = { path = \"../librustc_errors\" }\n rustc_incremental = { path = \"../librustc_incremental\" }\n rustc_llvm = { path = \"../librustc_llvm\" }\n+rustc_i128 = { path = \"../librustc_i128\" }\n rustc_platform_intrinsics = { path = \"../librustc_platform_intrinsics\" }\n serialize = { path = \"../libserialize\" }\n syntax = { path = \"../libsyntax\" }\n-syntax_pos = { path = \"../libsyntax_pos\" }\n\\ No newline at end of file\n+syntax_pos = { path = \"../libsyntax_pos\" }"}, {"sha": "b3eec5d66c4683c9dac02d81f6216200e20810b9", "filename": "src/librustc_trans/abi.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_trans%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_trans%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fabi.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -26,6 +26,8 @@ use cabi_asmjs;\n use cabi_msp430;\n use cabi_sparc;\n use cabi_sparc64;\n+use cabi_nvptx;\n+use cabi_nvptx64;\n use machine::{llalign_of_min, llsize_of, llsize_of_alloc};\n use type_::Type;\n use type_of;\n@@ -312,7 +314,7 @@ impl ArgType {\n ///\n /// I will do my best to describe this structure, but these\n /// comments are reverse-engineered and may be inaccurate. -NDM\n-#[derive(Clone)]\n+#[derive(Clone, Debug)]\n pub struct FnType {\n     /// The LLVM types of each argument.\n     pub args: Vec<ArgType>,\n@@ -351,9 +353,11 @@ impl FnType {\n             Fastcall => llvm::X86FastcallCallConv,\n             Vectorcall => llvm::X86_VectorCall,\n             C => llvm::CCallConv,\n+            Unadjusted => llvm::CCallConv,\n             Win64 => llvm::X86_64_Win64,\n             SysV64 => llvm::X86_64_SysV,\n             Aapcs => llvm::ArmAapcsCallConv,\n+            PtxKernel => llvm::PtxKernel,\n \n             // These API constants ought to be more specific...\n             Cdecl => llvm::CCallConv,\n@@ -526,6 +530,8 @@ impl FnType {\n                                     ccx: &CrateContext<'a, 'tcx>,\n                                     abi: Abi,\n                                     sig: &ty::FnSig<'tcx>) {\n+        if abi == Abi::Unadjusted { return }\n+\n         if abi == Abi::Rust || abi == Abi::RustCall ||\n            abi == Abi::RustIntrinsic || abi == Abi::PlatformIntrinsic {\n             let fixup = |arg: &mut ArgType| {\n@@ -610,6 +616,8 @@ impl FnType {\n             \"msp430\" => cabi_msp430::compute_abi_info(ccx, self),\n             \"sparc\" => cabi_sparc::compute_abi_info(ccx, self),\n             \"sparc64\" => cabi_sparc64::compute_abi_info(ccx, self),\n+            \"nvptx\" => cabi_nvptx::compute_abi_info(ccx, self),\n+            \"nvptx64\" => cabi_nvptx64::compute_abi_info(ccx, self),\n             a => ccx.sess().fatal(&format!(\"unrecognized arch \\\"{}\\\" in target specification\", a))\n         }\n "}, {"sha": "5ece19f764a8ac2572f9161815e7f62a9040c22e", "filename": "src/librustc_trans/cabi_nvptx.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_trans%2Fcabi_nvptx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_trans%2Fcabi_nvptx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_nvptx.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -0,0 +1,53 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Reference: PTX Writer's Guide to Interoperability\n+// http://docs.nvidia.com/cuda/ptx-writers-guide-to-interoperability\n+\n+#![allow(non_upper_case_globals)]\n+\n+use llvm::Struct;\n+\n+use abi::{self, ArgType, FnType};\n+use context::CrateContext;\n+use type_::Type;\n+\n+fn ty_size(ty: Type) -> usize {\n+    abi::ty_size(ty, 4)\n+}\n+\n+fn classify_ret_ty(ccx: &CrateContext, ret: &mut ArgType) {\n+    if ret.ty.kind() == Struct && ty_size(ret.ty) > 32 {\n+        ret.make_indirect(ccx);\n+    } else {\n+        ret.extend_integer_width_to(32);\n+    }\n+}\n+\n+fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType) {\n+    if arg.ty.kind() == Struct && ty_size(arg.ty) > 32 {\n+        arg.make_indirect(ccx);\n+    } else {\n+        arg.extend_integer_width_to(32);\n+    }\n+}\n+\n+pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n+    if !fty.ret.is_ignore() {\n+        classify_ret_ty(ccx, &mut fty.ret);\n+    }\n+\n+    for arg in &mut fty.args {\n+        if arg.is_ignore() {\n+            continue;\n+        }\n+        classify_arg_ty(ccx, arg);\n+    }\n+}"}, {"sha": "880c6cfd7a8ac24387c183f97ef9848bb577ec89", "filename": "src/librustc_trans/cabi_nvptx64.rs", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_trans%2Fcabi_nvptx64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_trans%2Fcabi_nvptx64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_nvptx64.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -0,0 +1,53 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// Reference: PTX Writer's Guide to Interoperability\n+// http://docs.nvidia.com/cuda/ptx-writers-guide-to-interoperability\n+\n+#![allow(non_upper_case_globals)]\n+\n+use llvm::Struct;\n+\n+use abi::{self, ArgType, FnType};\n+use context::CrateContext;\n+use type_::Type;\n+\n+fn ty_size(ty: Type) -> usize {\n+    abi::ty_size(ty, 8)\n+}\n+\n+fn classify_ret_ty(ccx: &CrateContext, ret: &mut ArgType) {\n+    if ret.ty.kind() == Struct && ty_size(ret.ty) > 64 {\n+        ret.make_indirect(ccx);\n+    } else {\n+        ret.extend_integer_width_to(64);\n+    }\n+}\n+\n+fn classify_arg_ty(ccx: &CrateContext, arg: &mut ArgType) {\n+    if arg.ty.kind() == Struct && ty_size(arg.ty) > 64 {\n+        arg.make_indirect(ccx);\n+    } else {\n+        arg.extend_integer_width_to(64);\n+    }\n+}\n+\n+pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n+    if !fty.ret.is_ignore() {\n+        classify_ret_ty(ccx, &mut fty.ret);\n+    }\n+\n+    for arg in &mut fty.args {\n+        if arg.is_ignore() {\n+            continue;\n+        }\n+        classify_arg_ty(ccx, arg);\n+    }\n+}"}, {"sha": "a849f38247380d1dd7e808a77aaa7d2b2bd2cacc", "filename": "src/librustc_trans/cabi_x86_win64.rs", "status": "modified", "additions": 14, "deletions": 10, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_trans%2Fcabi_x86_win64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_trans%2Fcabi_x86_win64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcabi_x86_win64.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -18,16 +18,20 @@ use type_::Type;\n \n pub fn compute_abi_info(ccx: &CrateContext, fty: &mut FnType) {\n     let fixup = |a: &mut ArgType| {\n-        if a.ty.kind() == Struct {\n-            match llsize_of_alloc(ccx, a.ty) {\n-                1 => a.cast = Some(Type::i8(ccx)),\n-                2 => a.cast = Some(Type::i16(ccx)),\n-                4 => a.cast = Some(Type::i32(ccx)),\n-                8 => a.cast = Some(Type::i64(ccx)),\n-                _ => a.make_indirect(ccx)\n-            }\n-        } else {\n-            a.extend_integer_width_to(32);\n+        match a.ty.kind() {\n+            Struct => match llsize_of_alloc(ccx, a.ty) {\n+                          1 => a.cast = Some(Type::i8(ccx)),\n+                          2 => a.cast = Some(Type::i16(ccx)),\n+                          4 => a.cast = Some(Type::i32(ccx)),\n+                          8 => a.cast = Some(Type::i64(ccx)),\n+                          _ => a.make_indirect(ccx)\n+                      },\n+            Integer => match llsize_of_alloc(ccx, a.ty) {\n+                           1 ... 8 => a.extend_integer_width_to(32),\n+                           16 => a.make_indirect(ccx),\n+                           _ => bug!(),\n+            },\n+            _ => (),\n         }\n     };\n "}, {"sha": "7e7bd15dc6e5ad6730fd5e96a4a6b5a16bd46c81", "filename": "src/librustc_trans/common.rs", "status": "modified", "additions": 32, "deletions": 10, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_trans%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_trans%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcommon.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -44,6 +44,8 @@ use syntax::ast;\n use syntax::symbol::{Symbol, InternedString};\n use syntax_pos::Span;\n \n+use rustc_i128::u128;\n+\n pub use context::{CrateContext, SharedCrateContext};\n \n pub fn type_is_fat_ptr<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>, ty: Ty<'tcx>) -> bool {\n@@ -425,6 +427,17 @@ pub fn C_integral(t: Type, u: u64, sign_extend: bool) -> ValueRef {\n     }\n }\n \n+pub fn C_big_integral(t: Type, u: u128, sign_extend: bool) -> ValueRef {\n+    if ::std::mem::size_of::<u128>() == 16 {\n+        unsafe {\n+            llvm::LLVMConstIntOfArbitraryPrecision(t.to_ref(), 2, &u as *const u128 as *const u64)\n+        }\n+    } else {\n+        // SNAP: remove after snapshot\n+        C_integral(t, u as u64, sign_extend)\n+    }\n+}\n+\n pub fn C_floating_f64(f: f64, t: Type) -> ValueRef {\n     unsafe {\n         llvm::LLVMConstReal(t.to_ref(), f)\n@@ -580,20 +593,29 @@ fn is_const_integral(v: ValueRef) -> bool {\n     }\n }\n \n-pub fn const_to_opt_int(v: ValueRef) -> Option<i64> {\n-    unsafe {\n-        if is_const_integral(v) {\n-            Some(llvm::LLVMConstIntGetSExtValue(v))\n-        } else {\n-            None\n-        }\n-    }\n+#[inline]\n+#[cfg(stage0)]\n+fn hi_lo_to_u128(lo: u64, _: u64) -> u128 {\n+    lo as u128\n }\n \n-pub fn const_to_opt_uint(v: ValueRef) -> Option<u64> {\n+#[inline]\n+#[cfg(not(stage0))]\n+fn hi_lo_to_u128(lo: u64, hi: u64) -> u128 {\n+    ((hi as u128) << 64) | (lo as u128)\n+}\n+\n+pub fn const_to_opt_u128(v: ValueRef, sign_ext: bool) -> Option<u128> {\n     unsafe {\n         if is_const_integral(v) {\n-            Some(llvm::LLVMConstIntGetZExtValue(v))\n+            let (mut lo, mut hi) = (0u64, 0u64);\n+            let success = llvm::LLVMRustConstInt128Get(v, sign_ext,\n+                                                       &mut hi as *mut u64, &mut lo as *mut u64);\n+            if success {\n+                Some(hi_lo_to_u128(lo, hi))\n+            } else {\n+                None\n+            }\n         } else {\n             None\n         }"}, {"sha": "413b643740861a1cf047fe8de836a7bfcf69b9bf", "filename": "src/librustc_trans/context.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_trans%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_trans%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fcontext.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -1022,6 +1022,7 @@ fn declare_intrinsic(ccx: &CrateContext, key: &str) -> Option<ValueRef> {\n     let t_i16 = Type::i16(ccx);\n     let t_i32 = Type::i32(ccx);\n     let t_i64 = Type::i64(ccx);\n+    let t_i128 = Type::i128(ccx);\n     let t_f32 = Type::f32(ccx);\n     let t_f64 = Type::f64(ccx);\n \n@@ -1088,50 +1089,60 @@ fn declare_intrinsic(ccx: &CrateContext, key: &str) -> Option<ValueRef> {\n     ifn!(\"llvm.ctpop.i16\", fn(t_i16) -> t_i16);\n     ifn!(\"llvm.ctpop.i32\", fn(t_i32) -> t_i32);\n     ifn!(\"llvm.ctpop.i64\", fn(t_i64) -> t_i64);\n+    ifn!(\"llvm.ctpop.i128\", fn(t_i128) -> t_i128);\n \n     ifn!(\"llvm.ctlz.i8\", fn(t_i8 , i1) -> t_i8);\n     ifn!(\"llvm.ctlz.i16\", fn(t_i16, i1) -> t_i16);\n     ifn!(\"llvm.ctlz.i32\", fn(t_i32, i1) -> t_i32);\n     ifn!(\"llvm.ctlz.i64\", fn(t_i64, i1) -> t_i64);\n+    ifn!(\"llvm.ctlz.i128\", fn(t_i128, i1) -> t_i128);\n \n     ifn!(\"llvm.cttz.i8\", fn(t_i8 , i1) -> t_i8);\n     ifn!(\"llvm.cttz.i16\", fn(t_i16, i1) -> t_i16);\n     ifn!(\"llvm.cttz.i32\", fn(t_i32, i1) -> t_i32);\n     ifn!(\"llvm.cttz.i64\", fn(t_i64, i1) -> t_i64);\n+    ifn!(\"llvm.cttz.i128\", fn(t_i128, i1) -> t_i128);\n \n     ifn!(\"llvm.bswap.i16\", fn(t_i16) -> t_i16);\n     ifn!(\"llvm.bswap.i32\", fn(t_i32) -> t_i32);\n     ifn!(\"llvm.bswap.i64\", fn(t_i64) -> t_i64);\n+    ifn!(\"llvm.bswap.i128\", fn(t_i128) -> t_i128);\n \n     ifn!(\"llvm.sadd.with.overflow.i8\", fn(t_i8, t_i8) -> mk_struct!{t_i8, i1});\n     ifn!(\"llvm.sadd.with.overflow.i16\", fn(t_i16, t_i16) -> mk_struct!{t_i16, i1});\n     ifn!(\"llvm.sadd.with.overflow.i32\", fn(t_i32, t_i32) -> mk_struct!{t_i32, i1});\n     ifn!(\"llvm.sadd.with.overflow.i64\", fn(t_i64, t_i64) -> mk_struct!{t_i64, i1});\n+    ifn!(\"llvm.sadd.with.overflow.i128\", fn(t_i128, t_i128) -> mk_struct!{t_i128, i1});\n \n     ifn!(\"llvm.uadd.with.overflow.i8\", fn(t_i8, t_i8) -> mk_struct!{t_i8, i1});\n     ifn!(\"llvm.uadd.with.overflow.i16\", fn(t_i16, t_i16) -> mk_struct!{t_i16, i1});\n     ifn!(\"llvm.uadd.with.overflow.i32\", fn(t_i32, t_i32) -> mk_struct!{t_i32, i1});\n     ifn!(\"llvm.uadd.with.overflow.i64\", fn(t_i64, t_i64) -> mk_struct!{t_i64, i1});\n+    ifn!(\"llvm.uadd.with.overflow.i128\", fn(t_i128, t_i128) -> mk_struct!{t_i128, i1});\n \n     ifn!(\"llvm.ssub.with.overflow.i8\", fn(t_i8, t_i8) -> mk_struct!{t_i8, i1});\n     ifn!(\"llvm.ssub.with.overflow.i16\", fn(t_i16, t_i16) -> mk_struct!{t_i16, i1});\n     ifn!(\"llvm.ssub.with.overflow.i32\", fn(t_i32, t_i32) -> mk_struct!{t_i32, i1});\n     ifn!(\"llvm.ssub.with.overflow.i64\", fn(t_i64, t_i64) -> mk_struct!{t_i64, i1});\n+    ifn!(\"llvm.ssub.with.overflow.i128\", fn(t_i128, t_i128) -> mk_struct!{t_i128, i1});\n \n     ifn!(\"llvm.usub.with.overflow.i8\", fn(t_i8, t_i8) -> mk_struct!{t_i8, i1});\n     ifn!(\"llvm.usub.with.overflow.i16\", fn(t_i16, t_i16) -> mk_struct!{t_i16, i1});\n     ifn!(\"llvm.usub.with.overflow.i32\", fn(t_i32, t_i32) -> mk_struct!{t_i32, i1});\n     ifn!(\"llvm.usub.with.overflow.i64\", fn(t_i64, t_i64) -> mk_struct!{t_i64, i1});\n+    ifn!(\"llvm.usub.with.overflow.i128\", fn(t_i128, t_i128) -> mk_struct!{t_i128, i1});\n \n     ifn!(\"llvm.smul.with.overflow.i8\", fn(t_i8, t_i8) -> mk_struct!{t_i8, i1});\n     ifn!(\"llvm.smul.with.overflow.i16\", fn(t_i16, t_i16) -> mk_struct!{t_i16, i1});\n     ifn!(\"llvm.smul.with.overflow.i32\", fn(t_i32, t_i32) -> mk_struct!{t_i32, i1});\n     ifn!(\"llvm.smul.with.overflow.i64\", fn(t_i64, t_i64) -> mk_struct!{t_i64, i1});\n+    ifn!(\"llvm.smul.with.overflow.i128\", fn(t_i128, t_i128) -> mk_struct!{t_i128, i1});\n \n     ifn!(\"llvm.umul.with.overflow.i8\", fn(t_i8, t_i8) -> mk_struct!{t_i8, i1});\n     ifn!(\"llvm.umul.with.overflow.i16\", fn(t_i16, t_i16) -> mk_struct!{t_i16, i1});\n     ifn!(\"llvm.umul.with.overflow.i32\", fn(t_i32, t_i32) -> mk_struct!{t_i32, i1});\n     ifn!(\"llvm.umul.with.overflow.i64\", fn(t_i64, t_i64) -> mk_struct!{t_i64, i1});\n+    ifn!(\"llvm.umul.with.overflow.i128\", fn(t_i128, t_i128) -> mk_struct!{t_i128, i1});\n \n     ifn!(\"llvm.lifetime.start\", fn(t_i64,i8p) -> void);\n     ifn!(\"llvm.lifetime.end\", fn(t_i64, i8p) -> void);"}, {"sha": "b2d12c7e7d0f2a323130bdcefd4f74bdb2029b48", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -1460,7 +1460,8 @@ fn prepare_enum_metadata<'a, 'tcx>(cx: &CrateContext<'a, 'tcx>,\n                 llvm::LLVMRustDIBuilderCreateEnumerator(\n                     DIB(cx),\n                     name.as_ptr(),\n-                    v.disr_val.to_u64_unchecked())\n+                    // FIXME: what if enumeration has i128 discriminant?\n+                    v.disr_val.to_u128_unchecked() as u64)\n             }\n         })\n         .collect();"}, {"sha": "c5737c6e5f12c38a267e60f2937d6093fbd3e004", "filename": "src/librustc_trans/disr.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_trans%2Fdisr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_trans%2Fdisr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdisr.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -26,7 +26,8 @@ impl ::std::ops::BitAnd for Disr {\n \n impl From<::rustc::ty::Disr> for Disr {\n     fn from(i: ::rustc::ty::Disr) -> Disr {\n-        Disr(i.to_u64_unchecked())\n+        // FIXME: what if discr has 128 bit discr?\n+        Disr(i.to_u128_unchecked() as u64)\n     }\n }\n "}, {"sha": "62141369caec1cf11a3644e8fef37e6d02ccbc06", "filename": "src/librustc_trans/glue.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_trans%2Fglue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_trans%2Fglue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fglue.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -346,11 +346,12 @@ pub fn size_and_align_of_dst<'a, 'tcx>(bcx: &BlockAndBuilder<'a, 'tcx>,\n \n             // Choose max of two known alignments (combined value must\n             // be aligned according to more restrictive of the two).\n-            let align = match (const_to_opt_uint(sized_align), const_to_opt_uint(unsized_align)) {\n+            let align = match (const_to_opt_u128(sized_align, false),\n+                               const_to_opt_u128(unsized_align, false)) {\n                 (Some(sized_align), Some(unsized_align)) => {\n                     // If both alignments are constant, (the sized_align should always be), then\n                     // pick the correct alignment statically.\n-                    C_uint(ccx, std::cmp::max(sized_align, unsized_align))\n+                    C_uint(ccx, std::cmp::max(sized_align, unsized_align) as u64)\n                 }\n                 _ => bcx.select(bcx.icmp(llvm::IntUGT, sized_align, unsized_align),\n                                 sized_align,"}, {"sha": "c4129b346e409b4dca0d2a4762ae2035a2e5ca25", "filename": "src/librustc_trans/intrinsic.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_trans%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_trans%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fintrinsic.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -32,6 +32,8 @@ use syntax::symbol::Symbol;\n use rustc::session::Session;\n use syntax_pos::Span;\n \n+use rustc_i128::u128;\n+\n use std::cmp::Ordering;\n use std::iter;\n \n@@ -1019,15 +1021,15 @@ fn generic_simd_intrinsic<'a, 'tcx>(\n                  in_elem, in_ty,\n                  ret_ty, ret_ty.simd_type(tcx));\n \n-        let total_len = in_len as u64 * 2;\n+        let total_len = in_len as u128 * 2;\n \n         let vector = llargs[2];\n \n         let indices: Option<Vec<_>> = (0..n)\n             .map(|i| {\n                 let arg_idx = i;\n                 let val = const_get_elt(vector, &[i as libc::c_uint]);\n-                match const_to_opt_uint(val) {\n+                match const_to_opt_u128(val, true) {\n                     None => {\n                         emit_error!(\"shuffle index #{} is not a constant\", arg_idx);\n                         None\n@@ -1167,6 +1169,8 @@ fn generic_simd_intrinsic<'a, 'tcx>(\n \n // Returns the width of an int TypeVariant, and if it's signed or not\n // Returns None if the type is not an integer\n+// FIXME: there\u2019s multiple of this functions, investigate using some of the already existing\n+// stuffs.\n fn int_type_width_signed<'tcx>(sty: &ty::TypeVariants<'tcx>, ccx: &CrateContext)\n         -> Option<(u64, bool)> {\n     use rustc::ty::{TyInt, TyUint};\n@@ -1184,6 +1188,7 @@ fn int_type_width_signed<'tcx>(sty: &ty::TypeVariants<'tcx>, ccx: &CrateContext)\n             ast::IntTy::I16 => 16,\n             ast::IntTy::I32 => 32,\n             ast::IntTy::I64 => 64,\n+            ast::IntTy::I128 => 128,\n         }, true)),\n         TyUint(t) => Some((match t {\n             ast::UintTy::Us => {\n@@ -1198,6 +1203,7 @@ fn int_type_width_signed<'tcx>(sty: &ty::TypeVariants<'tcx>, ccx: &CrateContext)\n             ast::UintTy::U16 => 16,\n             ast::UintTy::U32 => 32,\n             ast::UintTy::U64 => 64,\n+            ast::UintTy::U128 => 128,\n         }, false)),\n         _ => None,\n     }"}, {"sha": "3a4171e1d0ec6fcb0f3b728c1d62083248730712", "filename": "src/librustc_trans/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_trans%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_trans%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Flib.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -57,6 +57,7 @@ extern crate rustc_const_eval;\n #[macro_use]\n #[no_link]\n extern crate rustc_bitflags;\n+extern crate rustc_i128;\n \n #[macro_use] extern crate log;\n #[macro_use] extern crate syntax;\n@@ -103,6 +104,8 @@ mod cabi_asmjs;\n mod cabi_mips;\n mod cabi_mips64;\n mod cabi_msp430;\n+mod cabi_nvptx;\n+mod cabi_nvptx64;\n mod cabi_powerpc;\n mod cabi_powerpc64;\n mod cabi_s390x;"}, {"sha": "ecedcd68382d167ad44ef8d6d852472ab8cb112b", "filename": "src/librustc_trans/mir/block.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_trans%2Fmir%2Fblock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fblock.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -269,7 +269,7 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n \n             mir::TerminatorKind::Assert { ref cond, expected, ref msg, target, cleanup } => {\n                 let cond = self.trans_operand(&bcx, cond).immediate();\n-                let mut const_cond = common::const_to_opt_uint(cond).map(|c| c == 1);\n+                let mut const_cond = common::const_to_opt_u128(cond, false).map(|c| c == 1);\n \n                 // This case can currently arise only from functions marked\n                 // with #[rustc_inherit_overflow_checks] and inlined from\n@@ -322,14 +322,12 @@ impl<'a, 'tcx> MirContext<'a, 'tcx> {\n                         let len = self.trans_operand(&mut bcx, len).immediate();\n                         let index = self.trans_operand(&mut bcx, index).immediate();\n \n-                        let const_err = common::const_to_opt_uint(len).and_then(|len| {\n-                            common::const_to_opt_uint(index).map(|index| {\n-                                ErrKind::IndexOutOfBounds {\n-                                    len: len,\n-                                    index: index\n-                                }\n-                            })\n-                        });\n+                        let const_err = common::const_to_opt_u128(len, false)\n+                            .and_then(|len| common::const_to_opt_u128(index, false)\n+                                .map(|index| ErrKind::IndexOutOfBounds {\n+                                    len: len as u64,\n+                                    index: index as u64\n+                                }));\n \n                         let file_line = C_struct(bcx.ccx, &[filename, line], false);\n                         let align = llalign_of_min(bcx.ccx, common::val_ty(file_line));"}, {"sha": "700894c255da68de83680cd580a2ce7c92f00502", "filename": "src/librustc_trans/mir/constant.rs", "status": "modified", "additions": 17, "deletions": 49, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_trans%2Fmir%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fconstant.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -13,7 +13,7 @@ use rustc::middle::const_val::ConstVal;\n use rustc_const_eval::{ErrKind, ConstEvalErr, report_const_eval_err};\n use rustc_const_math::ConstInt::*;\n use rustc_const_math::ConstFloat::*;\n-use rustc_const_math::{ConstInt, ConstIsize, ConstUsize, ConstMathErr};\n+use rustc_const_math::{ConstInt, ConstMathErr};\n use rustc::hir::def_id::DefId;\n use rustc::infer::TransNormalize;\n use rustc::mir;\n@@ -25,16 +25,15 @@ use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n use {abi, adt, base, Disr, machine};\n use callee::Callee;\n use common::{self, BlockAndBuilder, CrateContext, const_get_elt, val_ty};\n-use common::{C_array, C_bool, C_bytes, C_floating_f64, C_integral};\n+use common::{C_array, C_bool, C_bytes, C_floating_f64, C_integral, C_big_integral};\n use common::{C_null, C_struct, C_str_slice, C_undef, C_uint};\n-use common::{const_to_opt_int, const_to_opt_uint};\n+use common::{const_to_opt_u128};\n use consts;\n use monomorphize::{self, Instance};\n use type_of;\n use type_::Type;\n use value::Value;\n \n-use syntax::ast;\n use syntax_pos::Span;\n \n use std::fmt;\n@@ -43,6 +42,8 @@ use std::ptr;\n use super::operand::{OperandRef, OperandValue};\n use super::MirContext;\n \n+use rustc_i128::{u128, i128};\n+\n /// A sized constant rvalue.\n /// The LLVM type might not be the same for a single Rust type,\n /// e.g. each enum variant would have its own LLVM struct type.\n@@ -75,6 +76,7 @@ impl<'tcx> Const<'tcx> {\n             ConstVal::Integral(I16(v)) => C_integral(Type::i16(ccx), v as u64, true),\n             ConstVal::Integral(I32(v)) => C_integral(Type::i32(ccx), v as u64, true),\n             ConstVal::Integral(I64(v)) => C_integral(Type::i64(ccx), v as u64, true),\n+            ConstVal::Integral(I128(v)) => C_big_integral(Type::i128(ccx), v as u128, true),\n             ConstVal::Integral(Isize(v)) => {\n                 let i = v.as_i64(ccx.tcx().sess.target.int_type);\n                 C_integral(Type::int(ccx), i as u64, true)\n@@ -83,6 +85,7 @@ impl<'tcx> Const<'tcx> {\n             ConstVal::Integral(U16(v)) => C_integral(Type::i16(ccx), v as u64, false),\n             ConstVal::Integral(U32(v)) => C_integral(Type::i32(ccx), v as u64, false),\n             ConstVal::Integral(U64(v)) => C_integral(Type::i64(ccx), v, false),\n+            ConstVal::Integral(U128(v)) => C_big_integral(Type::i128(ccx), v, false),\n             ConstVal::Integral(Usize(v)) => {\n                 let u = v.as_u64(ccx.tcx().sess.target.uint_type);\n                 C_integral(Type::int(ccx), u, false)\n@@ -428,15 +431,15 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n                     mir::ProjectionElem::Index(ref index) => {\n                         let llindex = self.const_operand(index, span)?.llval;\n \n-                        let iv = if let Some(iv) = common::const_to_opt_uint(llindex) {\n+                        let iv = if let Some(iv) = common::const_to_opt_u128(llindex, false) {\n                             iv\n                         } else {\n                             span_bug!(span, \"index is not an integer-constant expression\")\n                         };\n \n                         // Produce an undef instead of a LLVM assertion on OOB.\n                         let len = common::const_to_uint(tr_base.len(self.ccx));\n-                        let llelem = if iv < len {\n+                        let llelem = if iv < len as u128 {\n                             const_get_elt(base.llval, &[iv as u32])\n                         } else {\n                             C_undef(type_of::type_of(self.ccx, projected_ty))\n@@ -794,49 +797,14 @@ impl<'a, 'tcx> MirConstContext<'a, 'tcx> {\n \n fn to_const_int(value: ValueRef, t: Ty, tcx: TyCtxt) -> Option<ConstInt> {\n     match t.sty {\n-        ty::TyInt(int_type) => const_to_opt_int(value).and_then(|input| match int_type {\n-            ast::IntTy::I8 => {\n-                assert_eq!(input as i8 as i64, input);\n-                Some(ConstInt::I8(input as i8))\n-            },\n-            ast::IntTy::I16 => {\n-                assert_eq!(input as i16 as i64, input);\n-                Some(ConstInt::I16(input as i16))\n-            },\n-            ast::IntTy::I32 => {\n-                assert_eq!(input as i32 as i64, input);\n-                Some(ConstInt::I32(input as i32))\n-            },\n-            ast::IntTy::I64 => {\n-                Some(ConstInt::I64(input))\n-            },\n-            ast::IntTy::Is => {\n-                ConstIsize::new(input, tcx.sess.target.int_type)\n-                    .ok().map(ConstInt::Isize)\n-            },\n-        }),\n-        ty::TyUint(uint_type) => const_to_opt_uint(value).and_then(|input| match uint_type {\n-            ast::UintTy::U8 => {\n-                assert_eq!(input as u8 as u64, input);\n-                Some(ConstInt::U8(input as u8))\n-            },\n-            ast::UintTy::U16 => {\n-                assert_eq!(input as u16 as u64, input);\n-                Some(ConstInt::U16(input as u16))\n-            },\n-            ast::UintTy::U32 => {\n-                assert_eq!(input as u32 as u64, input);\n-                Some(ConstInt::U32(input as u32))\n-            },\n-            ast::UintTy::U64 => {\n-                Some(ConstInt::U64(input))\n-            },\n-            ast::UintTy::Us => {\n-                ConstUsize::new(input, tcx.sess.target.uint_type)\n-                    .ok().map(ConstInt::Usize)\n-            },\n-        }),\n-        _ => None,\n+        ty::TyInt(int_type) => const_to_opt_u128(value, true)\n+            .and_then(|input| ConstInt::new_signed(input as i128, int_type,\n+                                                   tcx.sess.target.int_type)),\n+        ty::TyUint(uint_type) => const_to_opt_u128(value, false)\n+            .and_then(|input| ConstInt::new_unsigned(input, uint_type,\n+                                                     tcx.sess.target.uint_type)),\n+        _ => None\n+\n     }\n }\n "}, {"sha": "a1373cb9482b7b17861a5a008c2e708c700c83b5", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -205,6 +205,7 @@ pub fn trans_mir<'a, 'tcx: 'a>(\n     sig: &ty::FnSig<'tcx>,\n     abi: Abi,\n ) {\n+    debug!(\"fn_ty: {:?}\", fn_ty);\n     let debug_context =\n         debuginfo::create_function_debug_context(fcx.ccx, instance, sig, abi, fcx.llfn, mir);\n     let bcx = fcx.get_entry_block();"}, {"sha": "526155655af2778b45fd62bbed866992ae43a752", "filename": "src/librustc_trans/mir/operand.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_trans%2Fmir%2Foperand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Foperand.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -79,7 +79,7 @@ impl<'a, 'tcx> OperandRef<'tcx> {\n     pub fn immediate(self) -> ValueRef {\n         match self.val {\n             OperandValue::Immediate(s) => s,\n-            _ => bug!()\n+            _ => bug!(\"not immediate: {:?}\", self)\n         }\n     }\n "}, {"sha": "cca48737bb963e7d6dbb703c6e85c5c76fd50bcb", "filename": "src/librustc_trans/mir/rvalue.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_trans%2Fmir%2Frvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Frvalue.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -711,11 +711,13 @@ fn get_overflow_intrinsic(oop: OverflowOp, bcx: &BlockAndBuilder, ty: Ty) -> Val\n             TyInt(I16) => \"llvm.sadd.with.overflow.i16\",\n             TyInt(I32) => \"llvm.sadd.with.overflow.i32\",\n             TyInt(I64) => \"llvm.sadd.with.overflow.i64\",\n+            TyInt(I128) => \"llvm.sadd.with.overflow.i128\",\n \n             TyUint(U8) => \"llvm.uadd.with.overflow.i8\",\n             TyUint(U16) => \"llvm.uadd.with.overflow.i16\",\n             TyUint(U32) => \"llvm.uadd.with.overflow.i32\",\n             TyUint(U64) => \"llvm.uadd.with.overflow.i64\",\n+            TyUint(U128) => \"llvm.uadd.with.overflow.i128\",\n \n             _ => unreachable!(),\n         },\n@@ -724,11 +726,13 @@ fn get_overflow_intrinsic(oop: OverflowOp, bcx: &BlockAndBuilder, ty: Ty) -> Val\n             TyInt(I16) => \"llvm.ssub.with.overflow.i16\",\n             TyInt(I32) => \"llvm.ssub.with.overflow.i32\",\n             TyInt(I64) => \"llvm.ssub.with.overflow.i64\",\n+            TyInt(I128) => \"llvm.ssub.with.overflow.i128\",\n \n             TyUint(U8) => \"llvm.usub.with.overflow.i8\",\n             TyUint(U16) => \"llvm.usub.with.overflow.i16\",\n             TyUint(U32) => \"llvm.usub.with.overflow.i32\",\n             TyUint(U64) => \"llvm.usub.with.overflow.i64\",\n+            TyUint(U128) => \"llvm.usub.with.overflow.i128\",\n \n             _ => unreachable!(),\n         },\n@@ -737,11 +741,13 @@ fn get_overflow_intrinsic(oop: OverflowOp, bcx: &BlockAndBuilder, ty: Ty) -> Val\n             TyInt(I16) => \"llvm.smul.with.overflow.i16\",\n             TyInt(I32) => \"llvm.smul.with.overflow.i32\",\n             TyInt(I64) => \"llvm.smul.with.overflow.i64\",\n+            TyInt(I128) => \"llvm.smul.with.overflow.i128\",\n \n             TyUint(U8) => \"llvm.umul.with.overflow.i8\",\n             TyUint(U16) => \"llvm.umul.with.overflow.i16\",\n             TyUint(U32) => \"llvm.umul.with.overflow.i32\",\n             TyUint(U64) => \"llvm.umul.with.overflow.i64\",\n+            TyUint(U128) => \"llvm.umul.with.overflow.i128\",\n \n             _ => unreachable!(),\n         },"}, {"sha": "f6f91411225d9b0ecad02567763aa85b9aec5936", "filename": "src/librustc_trans/trans_item.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_trans%2Ftrans_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_trans%2Ftrans_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans_item.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -397,11 +397,13 @@ impl<'a, 'tcx> DefPathBasedNames<'a, 'tcx> {\n             ty::TyInt(ast::IntTy::I16)   => output.push_str(\"i16\"),\n             ty::TyInt(ast::IntTy::I32)   => output.push_str(\"i32\"),\n             ty::TyInt(ast::IntTy::I64)   => output.push_str(\"i64\"),\n+            ty::TyInt(ast::IntTy::I128)   => output.push_str(\"i128\"),\n             ty::TyUint(ast::UintTy::Us)   => output.push_str(\"usize\"),\n             ty::TyUint(ast::UintTy::U8)   => output.push_str(\"u8\"),\n             ty::TyUint(ast::UintTy::U16)  => output.push_str(\"u16\"),\n             ty::TyUint(ast::UintTy::U32)  => output.push_str(\"u32\"),\n             ty::TyUint(ast::UintTy::U64)  => output.push_str(\"u64\"),\n+            ty::TyUint(ast::UintTy::U128)  => output.push_str(\"u128\"),\n             ty::TyFloat(ast::FloatTy::F32) => output.push_str(\"f32\"),\n             ty::TyFloat(ast::FloatTy::F64) => output.push_str(\"f64\"),\n             ty::TyAdt(adt_def, substs) => {"}, {"sha": "f68acab911317c5935920cc32f7f13cb823b9297", "filename": "src/librustc_trans/type_.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_trans%2Ftype_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_trans%2Ftype_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftype_.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -94,6 +94,10 @@ impl Type {\n         ty!(llvm::LLVMInt64TypeInContext(ccx.llcx()))\n     }\n \n+    pub fn i128(ccx: &CrateContext) -> Type {\n+        ty!(llvm::LLVMIntTypeInContext(ccx.llcx(), 128))\n+    }\n+\n     // Creates an integer type with the given number of bits, e.g. i24\n     pub fn ix(ccx: &CrateContext, num_bits: u64) -> Type {\n         ty!(llvm::LLVMIntTypeInContext(ccx.llcx(), num_bits as c_uint))\n@@ -134,7 +138,8 @@ impl Type {\n             ast::IntTy::I8 => Type::i8(ccx),\n             ast::IntTy::I16 => Type::i16(ccx),\n             ast::IntTy::I32 => Type::i32(ccx),\n-            ast::IntTy::I64 => Type::i64(ccx)\n+            ast::IntTy::I64 => Type::i64(ccx),\n+            ast::IntTy::I128 => Type::i128(ccx),\n         }\n     }\n \n@@ -144,7 +149,8 @@ impl Type {\n             ast::UintTy::U8 => Type::i8(ccx),\n             ast::UintTy::U16 => Type::i16(ccx),\n             ast::UintTy::U32 => Type::i32(ccx),\n-            ast::UintTy::U64 => Type::i64(ccx)\n+            ast::UintTy::U64 => Type::i64(ccx),\n+            ast::UintTy::U128 => Type::i128(ccx),\n         }\n     }\n \n@@ -307,6 +313,7 @@ impl Type {\n             I16 => Type::i16(cx),\n             I32 => Type::i32(cx),\n             I64 => Type::i64(cx),\n+            I128 => Type::i128(cx),\n         }\n     }\n "}, {"sha": "4f41bbe9924b0f54fd37da4d9833625b27984aca", "filename": "src/librustc_typeck/check/intrinsic.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fintrinsic.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -432,7 +432,9 @@ fn match_intrinsic_type_to_type<'tcx, 'a>(\n             (true,  32, &ty::TyInt(ast::IntTy::I32)) |\n             (false, 32, &ty::TyUint(ast::UintTy::U32)) |\n             (true,  64, &ty::TyInt(ast::IntTy::I64)) |\n-            (false, 64, &ty::TyUint(ast::UintTy::U64)) => {},\n+            (false, 64, &ty::TyUint(ast::UintTy::U64)) |\n+            (true,  128, &ty::TyInt(ast::IntTy::I128)) |\n+            (false, 128, &ty::TyUint(ast::UintTy::U128)) => {},\n             _ => simple_error(&format!(\"`{}`\", t),\n                               &format!(\"`{}{n}`\",\n                                        if signed {\"i\"} else {\"u\"},"}, {"sha": "5c3da4237bef261e6f7c8c91799e103083a374d0", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -435,6 +435,10 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                 let lang_def_id = self.tcx.lang_items.i64_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n+            ty::TyInt(ast::IntTy::I128) => {\n+                let lang_def_id = self.tcx.lang_items.i128_impl();\n+                self.assemble_inherent_impl_for_primitive(lang_def_id);\n+            }\n             ty::TyInt(ast::IntTy::Is) => {\n                 let lang_def_id = self.tcx.lang_items.isize_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n@@ -455,6 +459,10 @@ impl<'a, 'gcx, 'tcx> ProbeContext<'a, 'gcx, 'tcx> {\n                 let lang_def_id = self.tcx.lang_items.u64_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);\n             }\n+            ty::TyUint(ast::UintTy::U128) => {\n+                let lang_def_id = self.tcx.lang_items.u128_impl();\n+                self.assemble_inherent_impl_for_primitive(lang_def_id);\n+            }\n             ty::TyUint(ast::UintTy::Us) => {\n                 let lang_def_id = self.tcx.lang_items.usize_impl();\n                 self.assemble_inherent_impl_for_primitive(lang_def_id);"}, {"sha": "26dd53fecb243e306626a2ecd57ca7a2bf5ebb74", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -1330,6 +1330,13 @@ pub fn check_enum_variants<'a,'tcx>(ccx: &CrateCtxt<'a,'tcx>,\n     }\n \n     let repr_type_ty = ccx.tcx.enum_repr_type(Some(&hint)).to_ty(ccx.tcx);\n+    if repr_type_ty == ccx.tcx.types.i128 || repr_type_ty == ccx.tcx.types.u128 {\n+        if !ccx.tcx.sess.features.borrow().i128_type {\n+            emit_feature_err(&ccx.tcx.sess.parse_sess,\n+                             \"i128_type\", sp, GateIssue::Language, \"128-bit type is unstable\");\n+        }\n+    }\n+\n     for v in vs {\n         if let Some(e) = v.node.disr_expr {\n             check_const_with_type(ccx, e, repr_type_ty, e.node_id);"}, {"sha": "2b5a4515cd0d8d63c576253a3f3e9ad57e87d10d", "filename": "src/librustc_typeck/coherence/orphan.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcoherence%2Forphan.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -160,6 +160,13 @@ impl<'cx, 'tcx, 'v> ItemLikeVisitor<'v> for OrphanChecker<'cx, 'tcx> {\n                                                   \"i64\",\n                                                   item.span);\n                     }\n+                    ty::TyInt(ast::IntTy::I128) => {\n+                        self.check_primitive_impl(def_id,\n+                                                  self.tcx.lang_items.i128_impl(),\n+                                                  \"i128\",\n+                                                  \"i128\",\n+                                                  item.span);\n+                    }\n                     ty::TyInt(ast::IntTy::Is) => {\n                         self.check_primitive_impl(def_id,\n                                                   self.tcx.lang_items.isize_impl(),\n@@ -195,6 +202,13 @@ impl<'cx, 'tcx, 'v> ItemLikeVisitor<'v> for OrphanChecker<'cx, 'tcx> {\n                                                   \"u64\",\n                                                   item.span);\n                     }\n+                    ty::TyUint(ast::UintTy::U128) => {\n+                        self.check_primitive_impl(def_id,\n+                                                  self.tcx.lang_items.u128_impl(),\n+                                                  \"u128\",\n+                                                  \"u128\",\n+                                                  item.span);\n+                    }\n                     ty::TyUint(ast::UintTy::Us) => {\n                         self.check_primitive_impl(def_id,\n                                                   self.tcx.lang_items.usize_impl(),"}, {"sha": "7ddf10375bf2384be2a361d3177219986e457d86", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -1060,11 +1060,13 @@ fn convert_union_def<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                     (attr::SignedInt(ast::IntTy::I16), ConstInt::I16(_)) |\n                     (attr::SignedInt(ast::IntTy::I32), ConstInt::I32(_)) |\n                     (attr::SignedInt(ast::IntTy::I64), ConstInt::I64(_)) |\n+                    (attr::SignedInt(ast::IntTy::I128), ConstInt::I128(_)) |\n                     (attr::SignedInt(ast::IntTy::Is), ConstInt::Isize(_)) |\n                     (attr::UnsignedInt(ast::UintTy::U8), ConstInt::U8(_)) |\n                     (attr::UnsignedInt(ast::UintTy::U16), ConstInt::U16(_)) |\n                     (attr::UnsignedInt(ast::UintTy::U32), ConstInt::U32(_)) |\n                     (attr::UnsignedInt(ast::UintTy::U64), ConstInt::U64(_)) |\n+                    (attr::UnsignedInt(ast::UintTy::U128), ConstInt::U128(_)) |\n                     (attr::UnsignedInt(ast::UintTy::Us), ConstInt::Usize(_)) => Some(i),\n                     (_, i) => {\n                         print_err(ConstVal::Integral(i));"}, {"sha": "93854193762fbcf2d2ef7a63e9f2c02250d846c2", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -268,11 +268,13 @@ pub fn build_impls(cx: &DocContext, did: DefId) -> Vec<clean::Item> {\n         tcx.lang_items.i16_impl(),\n         tcx.lang_items.i32_impl(),\n         tcx.lang_items.i64_impl(),\n+        tcx.lang_items.i128_impl(),\n         tcx.lang_items.usize_impl(),\n         tcx.lang_items.u8_impl(),\n         tcx.lang_items.u16_impl(),\n         tcx.lang_items.u32_impl(),\n         tcx.lang_items.u64_impl(),\n+        tcx.lang_items.u128_impl(),\n         tcx.lang_items.f32_impl(),\n         tcx.lang_items.f64_impl(),\n         tcx.lang_items.char_impl(),"}, {"sha": "e0a26ca318189e8226374a2f37f4e3761c8428c0", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 50, "deletions": 40, "changes": 90, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -1513,8 +1513,8 @@ pub enum Type {\n \n #[derive(Clone, RustcEncodable, RustcDecodable, PartialEq, Eq, Hash, Copy, Debug)]\n pub enum PrimitiveType {\n-    Isize, I8, I16, I32, I64,\n-    Usize, U8, U16, U32, U64,\n+    Isize, I8, I16, I32, I64, I128,\n+    Usize, U8, U16, U32, U64, U128,\n     F32, F64,\n     Char,\n     Bool,\n@@ -1595,11 +1595,13 @@ impl PrimitiveType {\n             \"i16\" => Some(PrimitiveType::I16),\n             \"i32\" => Some(PrimitiveType::I32),\n             \"i64\" => Some(PrimitiveType::I64),\n+            \"i128\" => Some(PrimitiveType::I128),\n             \"usize\" => Some(PrimitiveType::Usize),\n             \"u8\" => Some(PrimitiveType::U8),\n             \"u16\" => Some(PrimitiveType::U16),\n             \"u32\" => Some(PrimitiveType::U32),\n             \"u64\" => Some(PrimitiveType::U64),\n+            \"u128\" => Some(PrimitiveType::U128),\n             \"bool\" => Some(PrimitiveType::Bool),\n             \"char\" => Some(PrimitiveType::Char),\n             \"str\" => Some(PrimitiveType::Str),\n@@ -1614,26 +1616,29 @@ impl PrimitiveType {\n     }\n \n     pub fn as_str(&self) -> &'static str {\n+        use self::PrimitiveType::*;\n         match *self {\n-            PrimitiveType::Isize => \"isize\",\n-            PrimitiveType::I8 => \"i8\",\n-            PrimitiveType::I16 => \"i16\",\n-            PrimitiveType::I32 => \"i32\",\n-            PrimitiveType::I64 => \"i64\",\n-            PrimitiveType::Usize => \"usize\",\n-            PrimitiveType::U8 => \"u8\",\n-            PrimitiveType::U16 => \"u16\",\n-            PrimitiveType::U32 => \"u32\",\n-            PrimitiveType::U64 => \"u64\",\n-            PrimitiveType::F32 => \"f32\",\n-            PrimitiveType::F64 => \"f64\",\n-            PrimitiveType::Str => \"str\",\n-            PrimitiveType::Bool => \"bool\",\n-            PrimitiveType::Char => \"char\",\n-            PrimitiveType::Array => \"array\",\n-            PrimitiveType::Slice => \"slice\",\n-            PrimitiveType::Tuple => \"tuple\",\n-            PrimitiveType::RawPointer => \"pointer\",\n+            Isize => \"isize\",\n+            I8 => \"i8\",\n+            I16 => \"i16\",\n+            I32 => \"i32\",\n+            I64 => \"i64\",\n+            I128 => \"i128\",\n+            Usize => \"usize\",\n+            U8 => \"u8\",\n+            U16 => \"u16\",\n+            U32 => \"u32\",\n+            U64 => \"u64\",\n+            U128 => \"u128\",\n+            F32 => \"f32\",\n+            F64 => \"f64\",\n+            Str => \"str\",\n+            Bool => \"bool\",\n+            Char => \"char\",\n+            Array => \"array\",\n+            Slice => \"slice\",\n+            Tuple => \"tuple\",\n+            RawPointer => \"pointer\",\n         }\n     }\n \n@@ -1650,6 +1655,7 @@ impl From<ast::IntTy> for PrimitiveType {\n             ast::IntTy::I16 => PrimitiveType::I16,\n             ast::IntTy::I32 => PrimitiveType::I32,\n             ast::IntTy::I64 => PrimitiveType::I64,\n+            ast::IntTy::I128 => PrimitiveType::I128,\n         }\n     }\n }\n@@ -1662,6 +1668,7 @@ impl From<ast::UintTy> for PrimitiveType {\n             ast::UintTy::U16 => PrimitiveType::U16,\n             ast::UintTy::U32 => PrimitiveType::U32,\n             ast::UintTy::U64 => PrimitiveType::U64,\n+            ast::UintTy::U128 => PrimitiveType::U128,\n         }\n     }\n }\n@@ -2486,6 +2493,7 @@ impl Clean<Vec<Item>> for doctree::Impl {\n fn build_deref_target_impls(cx: &DocContext,\n                             items: &[Item],\n                             ret: &mut Vec<Item>) {\n+    use self::PrimitiveType::*;\n     let tcx = cx.tcx;\n \n     for item in items {\n@@ -2505,25 +2513,27 @@ fn build_deref_target_impls(cx: &DocContext,\n             }\n         };\n         let did = match primitive {\n-            PrimitiveType::Isize => tcx.lang_items.isize_impl(),\n-            PrimitiveType::I8 => tcx.lang_items.i8_impl(),\n-            PrimitiveType::I16 => tcx.lang_items.i16_impl(),\n-            PrimitiveType::I32 => tcx.lang_items.i32_impl(),\n-            PrimitiveType::I64 => tcx.lang_items.i64_impl(),\n-            PrimitiveType::Usize => tcx.lang_items.usize_impl(),\n-            PrimitiveType::U8 => tcx.lang_items.u8_impl(),\n-            PrimitiveType::U16 => tcx.lang_items.u16_impl(),\n-            PrimitiveType::U32 => tcx.lang_items.u32_impl(),\n-            PrimitiveType::U64 => tcx.lang_items.u64_impl(),\n-            PrimitiveType::F32 => tcx.lang_items.f32_impl(),\n-            PrimitiveType::F64 => tcx.lang_items.f64_impl(),\n-            PrimitiveType::Char => tcx.lang_items.char_impl(),\n-            PrimitiveType::Bool => None,\n-            PrimitiveType::Str => tcx.lang_items.str_impl(),\n-            PrimitiveType::Slice => tcx.lang_items.slice_impl(),\n-            PrimitiveType::Array => tcx.lang_items.slice_impl(),\n-            PrimitiveType::Tuple => None,\n-            PrimitiveType::RawPointer => tcx.lang_items.const_ptr_impl(),\n+            Isize => tcx.lang_items.isize_impl(),\n+            I8 => tcx.lang_items.i8_impl(),\n+            I16 => tcx.lang_items.i16_impl(),\n+            I32 => tcx.lang_items.i32_impl(),\n+            I64 => tcx.lang_items.i64_impl(),\n+            I128 => tcx.lang_items.i128_impl(),\n+            Usize => tcx.lang_items.usize_impl(),\n+            U8 => tcx.lang_items.u8_impl(),\n+            U16 => tcx.lang_items.u16_impl(),\n+            U32 => tcx.lang_items.u32_impl(),\n+            U64 => tcx.lang_items.u64_impl(),\n+            U128 => tcx.lang_items.u128_impl(),\n+            F32 => tcx.lang_items.f32_impl(),\n+            F64 => tcx.lang_items.f64_impl(),\n+            Char => tcx.lang_items.char_impl(),\n+            Bool => None,\n+            Str => tcx.lang_items.str_impl(),\n+            Slice => tcx.lang_items.slice_impl(),\n+            Array => tcx.lang_items.slice_impl(),\n+            Tuple => None,\n+            RawPointer => tcx.lang_items.const_ptr_impl(),\n         };\n         if let Some(did) = did {\n             if !did.is_local() {"}, {"sha": "ff7133f5d0c971efec75047d85e6e961eb1a5c19", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -2057,10 +2057,9 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n         let item_type = m.type_();\n         let id = derive_id(format!(\"{}.{}\", item_type, name));\n         let ns_id = derive_id(format!(\"{}.{}\", name, item_type.name_space()));\n-        write!(w, \"<h3 id='{id}' class='method stab {stab}'>\\\n+        write!(w, \"<h3 id='{id}' class='method'>\\\n                    <span id='{ns_id}' class='invisible'><code>\",\n                id = id,\n-               stab = m.stability_class(),\n                ns_id = ns_id)?;\n         render_assoc_item(w, m, AssocItemLink::Anchor(Some(&id)), ItemType::Impl)?;\n         write!(w, \"</code>\")?;"}, {"sha": "3213b4e4208be91e1240ecec4219ad6511d2a75b", "filename": "src/libserialize/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibserialize%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibserialize%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2FCargo.toml?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -10,3 +10,4 @@ crate-type = [\"dylib\", \"rlib\"]\n \n [dependencies]\n log = { path = \"../liblog\" }\n+rustc_i128 = { path = \"../librustc_i128\" }"}, {"sha": "3e62026f512195d23069b64ff38b12c54e33998c", "filename": "src/libserialize/json.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibserialize%2Fjson.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibserialize%2Fjson.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fjson.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -211,6 +211,8 @@ use std::string;\n use std::{char, f64, fmt, str};\n use std;\n \n+use rustc_i128::{i128, u128};\n+\n use Encodable;\n \n /// Represents a json value\n@@ -494,12 +496,14 @@ impl<'a> ::Encoder for Encoder<'a> {\n     }\n \n     fn emit_usize(&mut self, v: usize) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n+    fn emit_u128(&mut self, v: u128) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n     fn emit_u64(&mut self, v: u64) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n     fn emit_u32(&mut self, v: u32) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n     fn emit_u16(&mut self, v: u16) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n     fn emit_u8(&mut self, v: u8) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n \n     fn emit_isize(&mut self, v: isize) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n+    fn emit_i128(&mut self, v: i128) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n     fn emit_i64(&mut self, v: i64) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n     fn emit_i32(&mut self, v: i32) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n     fn emit_i16(&mut self, v: i16) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n@@ -742,12 +746,14 @@ impl<'a> ::Encoder for PrettyEncoder<'a> {\n     }\n \n     fn emit_usize(&mut self, v: usize) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n+    fn emit_u128(&mut self, v: u128) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n     fn emit_u64(&mut self, v: u64) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n     fn emit_u32(&mut self, v: u32) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n     fn emit_u16(&mut self, v: u16) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n     fn emit_u8(&mut self, v: u8) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n \n     fn emit_isize(&mut self, v: isize) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n+    fn emit_i128(&mut self, v: i128) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n     fn emit_i64(&mut self, v: i64) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n     fn emit_i32(&mut self, v: i32) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n     fn emit_i16(&mut self, v: i16) -> EncodeResult { emit_enquoted_if_mapkey!(self, v) }\n@@ -2138,11 +2144,13 @@ impl ::Decoder for Decoder {\n     read_primitive! { read_u16, u16 }\n     read_primitive! { read_u32, u32 }\n     read_primitive! { read_u64, u64 }\n+    read_primitive! { read_u128, u128 }\n     read_primitive! { read_isize, isize }\n     read_primitive! { read_i8, i8 }\n     read_primitive! { read_i16, i16 }\n     read_primitive! { read_i32, i32 }\n     read_primitive! { read_i64, i64 }\n+    read_primitive! { read_i128, i128 }\n \n     fn read_f32(&mut self) -> DecodeResult<f32> { self.read_f64().map(|x| x as f32) }\n "}, {"sha": "392f332d508dd64e1979579531023b19066cb0cc", "filename": "src/libserialize/leb128.rs", "status": "modified", "additions": 13, "deletions": 21, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibserialize%2Fleb128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibserialize%2Fleb128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fleb128.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use rustc_i128::{i128, u128};\n+\n #[inline]\n fn write_to_vec(vec: &mut Vec<u8>, position: usize, byte: u8) {\n     if position == vec.len() {\n@@ -24,11 +26,10 @@ fn write_to_vec(vec: &mut Vec<u8>, position: usize, byte: u8) {\n /// The callback `write` is called once for each position\n /// that is to be written to with the byte to be encoded\n /// at that position.\n-pub fn write_unsigned_leb128_to<W>(mut value: u64, mut write: W) -> usize\n+pub fn write_unsigned_leb128_to<W>(mut value: u128, mut write: W) -> usize\n     where W: FnMut(usize, u8)\n {\n     let mut position = 0;\n-\n     loop {\n         let mut byte = (value & 0x7F) as u8;\n         value >>= 7;\n@@ -47,19 +48,19 @@ pub fn write_unsigned_leb128_to<W>(mut value: u64, mut write: W) -> usize\n     position\n }\n \n-pub fn write_unsigned_leb128(out: &mut Vec<u8>, start_position: usize, value: u64) -> usize {\n+pub fn write_unsigned_leb128(out: &mut Vec<u8>, start_position: usize, value: u128) -> usize {\n     write_unsigned_leb128_to(value, |i, v| write_to_vec(out, start_position+i, v))\n }\n \n #[inline]\n-pub fn read_unsigned_leb128(data: &[u8], start_position: usize) -> (u64, usize) {\n+pub fn read_unsigned_leb128(data: &[u8], start_position: usize) -> (u128, usize) {\n     let mut result = 0;\n     let mut shift = 0;\n     let mut position = start_position;\n     loop {\n         let byte = data[position];\n         position += 1;\n-        result |= ((byte & 0x7F) as u64) << shift;\n+        result |= ((byte & 0x7F) as u128) << shift;\n         if (byte & 0x80) == 0 {\n             break;\n         }\n@@ -76,7 +77,7 @@ pub fn read_unsigned_leb128(data: &[u8], start_position: usize) -> (u64, usize)\n /// The callback `write` is called once for each position\n /// that is to be written to with the byte to be encoded\n /// at that position.\n-pub fn write_signed_leb128_to<W>(mut value: i64, mut write: W) -> usize\n+pub fn write_signed_leb128_to<W>(mut value: i128, mut write: W) -> usize\n     where W: FnMut(usize, u8)\n {\n     let mut position = 0;\n@@ -86,6 +87,7 @@ pub fn write_signed_leb128_to<W>(mut value: i64, mut write: W) -> usize\n         value >>= 7;\n         let more = !((((value == 0) && ((byte & 0x40) == 0)) ||\n                       ((value == -1) && ((byte & 0x40) != 0))));\n+\n         if more {\n             byte |= 0x80; // Mark this byte to show that more bytes will follow.\n         }\n@@ -97,16 +99,15 @@ pub fn write_signed_leb128_to<W>(mut value: i64, mut write: W) -> usize\n             break;\n         }\n     }\n-\n     position\n }\n \n-pub fn write_signed_leb128(out: &mut Vec<u8>, start_position: usize, value: i64) -> usize {\n+pub fn write_signed_leb128(out: &mut Vec<u8>, start_position: usize, value: i128) -> usize {\n     write_signed_leb128_to(value, |i, v| write_to_vec(out, start_position+i, v))\n }\n \n #[inline]\n-pub fn read_signed_leb128(data: &[u8], start_position: usize) -> (i64, usize) {\n+pub fn read_signed_leb128(data: &[u8], start_position: usize) -> (i128, usize) {\n     let mut result = 0;\n     let mut shift = 0;\n     let mut position = start_position;\n@@ -115,7 +116,7 @@ pub fn read_signed_leb128(data: &[u8], start_position: usize) -> (i64, usize) {\n     loop {\n         byte = data[position];\n         position += 1;\n-        result |= ((byte & 0x7F) as i64) << shift;\n+        result |= ((byte & 0x7F) as i128) << shift;\n         shift += 7;\n \n         if (byte & 0x80) == 0 {\n@@ -125,7 +126,7 @@ pub fn read_signed_leb128(data: &[u8], start_position: usize) -> (i64, usize) {\n \n     if (shift < 64) && ((byte & 0x40) != 0) {\n         // sign extend\n-        result |= -(1i64 << shift);\n+        result |= -(1 << shift);\n     }\n \n     (result, position - start_position)\n@@ -153,22 +154,13 @@ fn test_unsigned_leb128() {\n \n #[test]\n fn test_signed_leb128() {\n-    let mut values = Vec::new();\n-\n-    let mut i = -500;\n-    while i < 500 {\n-        values.push(i * 123457i64);\n-        i += 1;\n-    }\n-\n+    let values: Vec<_> = (-500..500).map(|i| i * 0x12345789ABCDEF).collect();\n     let mut stream = Vec::new();\n-\n     for &x in &values {\n         let pos = stream.len();\n         let bytes_written = write_signed_leb128(&mut stream, pos, x);\n         assert_eq!(stream.len(), pos + bytes_written);\n     }\n-\n     let mut pos = 0;\n     for &x in &values {\n         let (value, bytes_read) = read_signed_leb128(&mut stream, pos);"}, {"sha": "0979860189ca1d5973406733755f650044e22b8f", "filename": "src/libserialize/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibserialize%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibserialize%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Flib.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -44,6 +44,8 @@ Core encoding and decoding interfaces.\n extern crate std_unicode;\n extern crate collections;\n \n+extern crate rustc_i128;\n+\n pub use self::serialize::{Decoder, Encoder, Decodable, Encodable};\n \n pub use self::serialize::{SpecializationError, SpecializedEncoder, SpecializedDecoder};"}, {"sha": "8a0648d5851a18b988ee74c08d6fb711a1de9284", "filename": "src/libserialize/opaque.rs", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibserialize%2Fopaque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibserialize%2Fopaque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fopaque.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -13,6 +13,8 @@ use std::borrow::Cow;\n use std::io::{self, Write};\n use serialize;\n \n+use rustc_i128::{i128, u128};\n+\n // -----------------------------------------------------------------------------\n // Encoder\n // -----------------------------------------------------------------------------\n@@ -33,7 +35,7 @@ impl<'a> Encoder<'a> {\n macro_rules! write_uleb128 {\n     ($enc:expr, $value:expr) => {{\n         let pos = $enc.cursor.position() as usize;\n-        let bytes_written = write_unsigned_leb128($enc.cursor.get_mut(), pos, $value as u64);\n+        let bytes_written = write_unsigned_leb128($enc.cursor.get_mut(), pos, $value as u128);\n         $enc.cursor.set_position((pos + bytes_written) as u64);\n         Ok(())\n     }}\n@@ -42,7 +44,7 @@ macro_rules! write_uleb128 {\n macro_rules! write_sleb128 {\n     ($enc:expr, $value:expr) => {{\n         let pos = $enc.cursor.position() as usize;\n-        let bytes_written = write_signed_leb128($enc.cursor.get_mut(), pos, $value as i64);\n+        let bytes_written = write_signed_leb128($enc.cursor.get_mut(), pos, $value as i128);\n         $enc.cursor.set_position((pos + bytes_written) as u64);\n         Ok(())\n     }}\n@@ -59,6 +61,10 @@ impl<'a> serialize::Encoder for Encoder<'a> {\n         write_uleb128!(self, v)\n     }\n \n+    fn emit_u128(&mut self, v: u128) -> EncodeResult {\n+        write_uleb128!(self, v)\n+    }\n+\n     fn emit_u64(&mut self, v: u64) -> EncodeResult {\n         write_uleb128!(self, v)\n     }\n@@ -80,6 +86,10 @@ impl<'a> serialize::Encoder for Encoder<'a> {\n         write_sleb128!(self, v)\n     }\n \n+    fn emit_i128(&mut self, v: i128) -> EncodeResult {\n+        write_sleb128!(self, v)\n+    }\n+\n     fn emit_i64(&mut self, v: i64) -> EncodeResult {\n         write_sleb128!(self, v)\n     }\n@@ -184,6 +194,11 @@ impl<'a> serialize::Decoder for Decoder<'a> {\n         Ok(())\n     }\n \n+    #[inline]\n+    fn read_u128(&mut self) -> Result<u128, Self::Error> {\n+        read_uleb128!(self, u128)\n+    }\n+\n     #[inline]\n     fn read_u64(&mut self) -> Result<u64, Self::Error> {\n         read_uleb128!(self, u64)\n@@ -211,6 +226,11 @@ impl<'a> serialize::Decoder for Decoder<'a> {\n         read_uleb128!(self, usize)\n     }\n \n+    #[inline]\n+    fn read_i128(&mut self) -> Result<i128, Self::Error> {\n+        read_sleb128!(self, i128)\n+    }\n+\n     #[inline]\n     fn read_i64(&mut self) -> Result<i64, Self::Error> {\n         read_sleb128!(self, i64)"}, {"sha": "395f2ccbe6d28ef166780479f8b9f1c538dc4df1", "filename": "src/libserialize/serialize.rs", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibserialize%2Fserialize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibserialize%2Fserialize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibserialize%2Fserialize.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -20,18 +20,21 @@ use std::path;\n use std::rc::Rc;\n use std::cell::{Cell, RefCell};\n use std::sync::Arc;\n+use rustc_i128::{i128, u128};\n \n pub trait Encoder {\n     type Error;\n \n     // Primitive types:\n     fn emit_nil(&mut self) -> Result<(), Self::Error>;\n     fn emit_usize(&mut self, v: usize) -> Result<(), Self::Error>;\n+    fn emit_u128(&mut self, v: u128) -> Result<(), Self::Error>;\n     fn emit_u64(&mut self, v: u64) -> Result<(), Self::Error>;\n     fn emit_u32(&mut self, v: u32) -> Result<(), Self::Error>;\n     fn emit_u16(&mut self, v: u16) -> Result<(), Self::Error>;\n     fn emit_u8(&mut self, v: u8) -> Result<(), Self::Error>;\n     fn emit_isize(&mut self, v: isize) -> Result<(), Self::Error>;\n+    fn emit_i128(&mut self, v: i128) -> Result<(), Self::Error>;\n     fn emit_i64(&mut self, v: i64) -> Result<(), Self::Error>;\n     fn emit_i32(&mut self, v: i32) -> Result<(), Self::Error>;\n     fn emit_i16(&mut self, v: i16) -> Result<(), Self::Error>;\n@@ -144,11 +147,13 @@ pub trait Decoder {\n     // Primitive types:\n     fn read_nil(&mut self) -> Result<(), Self::Error>;\n     fn read_usize(&mut self) -> Result<usize, Self::Error>;\n+    fn read_u128(&mut self) -> Result<u128, Self::Error>;\n     fn read_u64(&mut self) -> Result<u64, Self::Error>;\n     fn read_u32(&mut self) -> Result<u32, Self::Error>;\n     fn read_u16(&mut self) -> Result<u16, Self::Error>;\n     fn read_u8(&mut self) -> Result<u8, Self::Error>;\n     fn read_isize(&mut self) -> Result<isize, Self::Error>;\n+    fn read_i128(&mut self) -> Result<i128, Self::Error>;\n     fn read_i64(&mut self) -> Result<i64, Self::Error>;\n     fn read_i32(&mut self) -> Result<i32, Self::Error>;\n     fn read_i16(&mut self) -> Result<i16, Self::Error>;\n@@ -328,6 +333,20 @@ impl Decodable for u64 {\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl Encodable for u128 {\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+        s.emit_u128(*self)\n+    }\n+}\n+\n+#[cfg(not(stage0))]\n+impl Decodable for u128 {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<u128, D::Error> {\n+        d.read_u128()\n+    }\n+}\n+\n impl Encodable for isize {\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_isize(*self)\n@@ -388,6 +407,20 @@ impl Decodable for i64 {\n     }\n }\n \n+#[cfg(not(stage0))]\n+impl Encodable for i128 {\n+    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n+        s.emit_i128(*self)\n+    }\n+}\n+\n+#[cfg(not(stage0))]\n+impl Decodable for i128 {\n+    fn decode<D: Decoder>(d: &mut D) -> Result<i128, D::Error> {\n+        d.read_i128()\n+    }\n+}\n+\n impl Encodable for str {\n     fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n         s.emit_str(self)"}, {"sha": "f1e3996e825bfee7444d6fa777b265091e320540", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -301,6 +301,7 @@\n #![feature(unwind_attributes)]\n #![feature(vec_push_all)]\n #![feature(zero_one)]\n+#![feature(i128)]\n #![cfg_attr(test, feature(update_panic_count))]\n \n // Explicitly import the prelude. The compiler uses this same unstable attribute\n@@ -395,6 +396,9 @@ pub use core::i16;\n pub use core::i32;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::i64;\n+#[unstable(feature = \"i128\", issue = \"35118\")]\n+#[cfg(not(stage0))]\n+pub use core::i128;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::usize;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -423,6 +427,9 @@ pub use core_collections::string;\n pub use core_collections::vec;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use std_unicode::char;\n+#[unstable(feature = \"i128\", issue = \"35118\")]\n+#[cfg(not(stage0))]\n+pub use core::u128;\n \n pub mod f32;\n pub mod f64;"}, {"sha": "5981b482a972897546c35bd45b2a5dbfd23a0494", "filename": "src/libstd/primitive_docs.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibstd%2Fprimitive_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibstd%2Fprimitive_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprimitive_docs.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -597,6 +597,17 @@ mod prim_i32 { }\n ///\n mod prim_i64 { }\n \n+#[doc(primitive = \"i128\")]\n+//\n+/// The 128-bit signed integer type.\n+///\n+/// *[See also the `std::i128` module](i128/index.html).*\n+///\n+/// However, please note that examples are shared between primitive integer\n+/// types. So it's normal if you see usage of types like `i8` in there.\n+///\n+mod prim_i128 { }\n+\n #[doc(primitive = \"u8\")]\n //\n /// The 8-bit unsigned integer type.\n@@ -641,6 +652,17 @@ mod prim_u32 { }\n ///\n mod prim_u64 { }\n \n+#[doc(primitive = \"u128\")]\n+//\n+/// The 128-bit unsigned integer type.\n+///\n+/// *[See also the `std::u128` module](u128/index.html).*\n+///\n+/// However, please note that examples are shared between primitive integer\n+/// types. So it's normal if you see usage of types like `u8` in there.\n+///\n+mod prim_u128 { }\n+\n #[doc(primitive = \"isize\")]\n //\n /// The pointer-sized signed integer type."}, {"sha": "dcab30aad8385b9c9ed38929c3531007a1740b6d", "filename": "src/libstd/sys/unix/fd.rs", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibstd%2Fsys%2Funix%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibstd%2Fsys%2Funix%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffd.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -10,8 +10,9 @@\n \n #![unstable(reason = \"not public\", issue = \"0\", feature = \"fd\")]\n \n+use cmp;\n use io::{self, Read};\n-use libc::{self, c_int, c_void};\n+use libc::{self, c_int, c_void, ssize_t};\n use mem;\n use sync::atomic::{AtomicBool, Ordering};\n use sys::cvt;\n@@ -23,6 +24,22 @@ pub struct FileDesc {\n     fd: c_int,\n }\n \n+fn max_len() -> usize {\n+    // The maximum read limit on most posix-like systems is `SSIZE_MAX`,\n+    // with the man page quoting that if the count of bytes to read is\n+    // greater than `SSIZE_MAX` the result is \"unspecified\".\n+    //\n+    // On OSX, however, apparently the 64-bit libc is either buggy or\n+    // intentionally showing odd behavior by rejecting any read with a size\n+    // larger than or equal to INT_MAX. To handle both of these the read\n+    // size is capped on both platforms.\n+    if cfg!(target_os = \"macos\") {\n+        <c_int>::max_value() as usize - 1\n+    } else {\n+        <ssize_t>::max_value() as usize\n+    }\n+}\n+\n impl FileDesc {\n     pub fn new(fd: c_int) -> FileDesc {\n         FileDesc { fd: fd }\n@@ -41,7 +58,7 @@ impl FileDesc {\n         let ret = cvt(unsafe {\n             libc::read(self.fd,\n                        buf.as_mut_ptr() as *mut c_void,\n-                       buf.len())\n+                       cmp::min(buf.len(), max_len()))\n         })?;\n         Ok(ret as usize)\n     }\n@@ -69,7 +86,7 @@ impl FileDesc {\n         unsafe {\n             cvt_pread64(self.fd,\n                         buf.as_mut_ptr() as *mut c_void,\n-                        buf.len(),\n+                        cmp::min(buf.len(), max_len()),\n                         offset as i64)\n                 .map(|n| n as usize)\n         }\n@@ -79,7 +96,7 @@ impl FileDesc {\n         let ret = cvt(unsafe {\n             libc::write(self.fd,\n                         buf.as_ptr() as *const c_void,\n-                        buf.len())\n+                        cmp::min(buf.len(), max_len()))\n         })?;\n         Ok(ret as usize)\n     }\n@@ -102,7 +119,7 @@ impl FileDesc {\n         unsafe {\n             cvt_pwrite64(self.fd,\n                          buf.as_ptr() as *const c_void,\n-                         buf.len(),\n+                         cmp::min(buf.len(), max_len()),\n                          offset as i64)\n                 .map(|n| n as usize)\n         }"}, {"sha": "fdb9483fe1c8b0ed0aab3d708b194460591486ca", "filename": "src/libstd/sys/windows/handle.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibstd%2Fsys%2Fwindows%2Fhandle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibstd%2Fsys%2Fwindows%2Fhandle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Fwindows%2Fhandle.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -19,7 +19,6 @@ use ptr;\n use sys::c;\n use sys::cvt;\n use sys_common::io::read_to_end_uninitialized;\n-use u32;\n \n /// An owned container for `HANDLE` object, closing them on Drop.\n ///\n@@ -83,9 +82,7 @@ impl RawHandle {\n \n     pub fn read(&self, buf: &mut [u8]) -> io::Result<usize> {\n         let mut read = 0;\n-        // ReadFile takes a DWORD (u32) for the length so it only supports\n-        // reading u32::MAX bytes at a time.\n-        let len = cmp::min(buf.len(), u32::MAX as usize) as c::DWORD;\n+        let len = cmp::min(buf.len(), <c::DWORD>::max_value() as usize) as c::DWORD;\n         let res = cvt(unsafe {\n             c::ReadFile(self.0, buf.as_mut_ptr() as c::LPVOID,\n                         len, &mut read, ptr::null_mut())\n@@ -181,9 +178,7 @@ impl RawHandle {\n \n     pub fn write(&self, buf: &[u8]) -> io::Result<usize> {\n         let mut amt = 0;\n-        // WriteFile takes a DWORD (u32) for the length so it only supports\n-        // writing u32::MAX bytes at a time.\n-        let len = cmp::min(buf.len(), u32::MAX as usize) as c::DWORD;\n+        let len = cmp::min(buf.len(), <c::DWORD>::max_value() as usize) as c::DWORD;\n         cvt(unsafe {\n             c::WriteFile(self.0, buf.as_ptr() as c::LPVOID,\n                          len, &mut amt, ptr::null_mut())"}, {"sha": "81979fd41a6bf6f16ed820eb705973831b46328c", "filename": "src/libstd/thread/mod.rs", "status": "modified", "additions": 58, "deletions": 3, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibstd%2Fthread%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibstd%2Fthread%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fthread%2Fmod.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -216,6 +216,20 @@ pub use self::local::{LocalKey, LocalKeyState};\n \n /// Thread configuration. Provides detailed control over the properties\n /// and behavior of new threads.\n+///\n+/// # Examples\n+///\n+/// ```\n+/// use std::thread;\n+///\n+/// let builder = thread::Builder::new();\n+///\n+/// let handler = builder.spawn(|| {\n+///     // thread code\n+/// }).unwrap();\n+///\n+/// handler.join().unwrap();\n+/// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[derive(Debug)]\n pub struct Builder {\n@@ -228,6 +242,22 @@ pub struct Builder {\n impl Builder {\n     /// Generates the base configuration for spawning a thread, from which\n     /// configuration methods can be chained.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::thread;\n+    ///\n+    /// let builder = thread::Builder::new()\n+    ///                               .name(\"foo\".into())\n+    ///                               .stack_size(10);\n+    ///\n+    /// let handler = builder.spawn(|| {\n+    ///     // thread code\n+    /// }).unwrap();\n+    ///\n+    /// handler.join().unwrap();\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new() -> Builder {\n         Builder {\n@@ -241,7 +271,7 @@ impl Builder {\n     ///\n     /// # Examples\n     ///\n-    /// ```rust\n+    /// ```\n     /// use std::thread;\n     ///\n     /// let builder = thread::Builder::new()\n@@ -260,6 +290,14 @@ impl Builder {\n     }\n \n     /// Sets the size of the stack for the new thread.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::thread;\n+    ///\n+    /// let builder = thread::Builder::new().stack_size(10);\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn stack_size(mut self, size: usize) -> Builder {\n         self.stack_size = Some(size);\n@@ -275,9 +313,26 @@ impl Builder {\n     ///\n     /// # Errors\n     ///\n-    /// Unlike the `spawn` free function, this method yields an\n-    /// `io::Result` to capture any failure to create the thread at\n+    /// Unlike the [`spawn`] free function, this method yields an\n+    /// [`io::Result`] to capture any failure to create the thread at\n     /// the OS level.\n+    ///\n+    /// [`spawn`]: ../../std/thread/fn.spawn.html\n+    /// [`io::Result`]: ../../std/io/type.Result.html\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::thread;\n+    ///\n+    /// let builder = thread::Builder::new();\n+    ///\n+    /// let handler = builder.spawn(|| {\n+    ///     // thread code\n+    /// }).unwrap();\n+    ///\n+    /// handler.join().unwrap();\n+    /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn spawn<F, T>(self, f: F) -> io::Result<JoinHandle<T>> where\n         F: FnOnce() -> T, F: Send + 'static, T: Send + 'static"}, {"sha": "a200da6c293eae0ccd1d764d043e86ae5e877104", "filename": "src/libsyntax/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibsyntax%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibsyntax%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2FCargo.toml?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -15,3 +15,4 @@ rustc_bitflags = { path = \"../librustc_bitflags\" }\n syntax_pos = { path = \"../libsyntax_pos\" }\n rustc_errors = { path = \"../librustc_errors\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n+rustc_i128 = { path = \"../librustc_i128\" }"}, {"sha": "75554f20effeea2bda313212ce18d4c923b9111f", "filename": "src/libsyntax/abi.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibsyntax%2Fabi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibsyntax%2Fabi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fabi.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -41,6 +41,7 @@ pub enum Abi {\n     Aapcs,\n     Win64,\n     SysV64,\n+    PtxKernel,\n \n     // Multiplatform / generic ABIs\n     Rust,\n@@ -49,6 +50,7 @@ pub enum Abi {\n     RustIntrinsic,\n     RustCall,\n     PlatformIntrinsic,\n+    Unadjusted\n }\n \n #[allow(non_camel_case_types)]\n@@ -82,6 +84,7 @@ const AbiDatas: &'static [AbiData] = &[\n     AbiData {abi: Abi::Aapcs, name: \"aapcs\", generic: false },\n     AbiData {abi: Abi::Win64, name: \"win64\", generic: false },\n     AbiData {abi: Abi::SysV64, name: \"sysv64\", generic: false },\n+    AbiData {abi: Abi::PtxKernel, name: \"ptx-kernel\", generic: false },\n \n     // Cross-platform ABIs\n     AbiData {abi: Abi::Rust, name: \"Rust\", generic: true },\n@@ -90,6 +93,7 @@ const AbiDatas: &'static [AbiData] = &[\n     AbiData {abi: Abi::RustIntrinsic, name: \"rust-intrinsic\", generic: true },\n     AbiData {abi: Abi::RustCall, name: \"rust-call\", generic: true },\n     AbiData {abi: Abi::PlatformIntrinsic, name: \"platform-intrinsic\", generic: true },\n+    AbiData {abi: Abi::Unadjusted, name: \"unadjusted\", generic: true },\n ];\n \n /// Returns the ABI with the given name (if any)."}, {"sha": "da4b787160fb2b921bdc2977ed19d335157abdb5", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 16, "deletions": 26, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -33,6 +33,8 @@ use std::u32;\n \n use serialize::{self, Encodable, Decodable, Encoder, Decoder};\n \n+use rustc_i128::{u128, i128};\n+\n /// An identifier contains a Name (index into the interner\n /// table) and a SyntaxContext to track renaming and\n /// macro expansion per Flatt et al., \"Macros That Work Together\"\n@@ -1062,7 +1064,7 @@ pub enum LitKind {\n     /// A character literal (`'a'`)\n     Char(char),\n     /// An integer literal (`1`)\n-    Int(u64, LitIntType),\n+    Int(u128, LitIntType),\n     /// A float literal (`1f64` or `1E10f64`)\n     Float(Symbol, FloatTy),\n     /// A float literal without a suffix (`1.0 or 1.0E10`)\n@@ -1171,6 +1173,7 @@ pub enum IntTy {\n     I16,\n     I32,\n     I64,\n+    I128,\n }\n \n impl fmt::Debug for IntTy {\n@@ -1192,24 +1195,16 @@ impl IntTy {\n             IntTy::I8 => \"i8\",\n             IntTy::I16 => \"i16\",\n             IntTy::I32 => \"i32\",\n-            IntTy::I64 => \"i64\"\n+            IntTy::I64 => \"i64\",\n+            IntTy::I128 => \"i128\",\n         }\n     }\n \n-    pub fn val_to_string(&self, val: i64) -> String {\n-        // cast to a u64 so we can correctly print INT64_MIN. All integral types\n-        // are parsed as u64, so we wouldn't want to print an extra negative\n+    pub fn val_to_string(&self, val: i128) -> String {\n+        // cast to a u128 so we can correctly print INT128_MIN. All integral types\n+        // are parsed as u128, so we wouldn't want to print an extra negative\n         // sign.\n-        format!(\"{}{}\", val as u64, self.ty_to_string())\n-    }\n-\n-    pub fn ty_max(&self) -> u64 {\n-        match *self {\n-            IntTy::I8 => 0x80,\n-            IntTy::I16 => 0x8000,\n-            IntTy::Is | IntTy::I32 => 0x80000000, // FIXME: actually ni about Is\n-            IntTy::I64 => 0x8000000000000000\n-        }\n+        format!(\"{}{}\", val as u128, self.ty_to_string())\n     }\n \n     pub fn bit_width(&self) -> Option<usize> {\n@@ -1219,6 +1214,7 @@ impl IntTy {\n             IntTy::I16 => 16,\n             IntTy::I32 => 32,\n             IntTy::I64 => 64,\n+            IntTy::I128 => 128,\n         })\n     }\n }\n@@ -1230,6 +1226,7 @@ pub enum UintTy {\n     U16,\n     U32,\n     U64,\n+    U128,\n }\n \n impl UintTy {\n@@ -1239,30 +1236,23 @@ impl UintTy {\n             UintTy::U8 => \"u8\",\n             UintTy::U16 => \"u16\",\n             UintTy::U32 => \"u32\",\n-            UintTy::U64 => \"u64\"\n+            UintTy::U64 => \"u64\",\n+            UintTy::U128 => \"u128\",\n         }\n     }\n \n-    pub fn val_to_string(&self, val: u64) -> String {\n+    pub fn val_to_string(&self, val: u128) -> String {\n         format!(\"{}{}\", val, self.ty_to_string())\n     }\n \n-    pub fn ty_max(&self) -> u64 {\n-        match *self {\n-            UintTy::U8 => 0xff,\n-            UintTy::U16 => 0xffff,\n-            UintTy::Us | UintTy::U32 => 0xffffffff, // FIXME: actually ni about Us\n-            UintTy::U64 => 0xffffffffffffffff\n-        }\n-    }\n-\n     pub fn bit_width(&self) -> Option<usize> {\n         Some(match *self {\n             UintTy::Us => return None,\n             UintTy::U8 => 8,\n             UintTy::U16 => 16,\n             UintTy::U32 => 32,\n             UintTy::U64 => 64,\n+            UintTy::U128 => 128,\n         })\n     }\n }"}, {"sha": "ab8a49b41f25ec876cdeb6a150eceaddf7086ab0", "filename": "src/libsyntax/attr.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibsyntax%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibsyntax%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fattr.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -899,6 +899,8 @@ fn int_type_of_word(s: &str) -> Option<IntType> {\n         \"u32\" => Some(UnsignedInt(ast::UintTy::U32)),\n         \"i64\" => Some(SignedInt(ast::IntTy::I64)),\n         \"u64\" => Some(UnsignedInt(ast::UintTy::U64)),\n+        \"i128\" => Some(SignedInt(ast::IntTy::I128)),\n+        \"u128\" => Some(UnsignedInt(ast::UintTy::U128)),\n         \"isize\" => Some(SignedInt(ast::IntTy::Is)),\n         \"usize\" => Some(UnsignedInt(ast::UintTy::Us)),\n         _ => None\n@@ -945,7 +947,8 @@ impl IntType {\n             SignedInt(ast::IntTy::I8) | UnsignedInt(ast::UintTy::U8) |\n             SignedInt(ast::IntTy::I16) | UnsignedInt(ast::UintTy::U16) |\n             SignedInt(ast::IntTy::I32) | UnsignedInt(ast::UintTy::U32) |\n-            SignedInt(ast::IntTy::I64) | UnsignedInt(ast::UintTy::U64) => true,\n+            SignedInt(ast::IntTy::I64) | UnsignedInt(ast::UintTy::U64) |\n+            SignedInt(ast::IntTy::I128) | UnsignedInt(ast::UintTy::U128) => true,\n             SignedInt(ast::IntTy::Is) | UnsignedInt(ast::UintTy::Us) => false\n         }\n     }"}, {"sha": "28f0c297303e38f590c9775cd9f1990d2e26afdf", "filename": "src/libsyntax/ext/build.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbuild.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -16,6 +16,7 @@ use codemap::{dummy_spanned, respan, Spanned};\n use ext::base::ExtCtxt;\n use ptr::P;\n use symbol::{Symbol, keywords};\n+use rustc_i128::u128;\n \n // Transitional reexports so qquote can find the paths it is looking for\n mod syntax {\n@@ -712,23 +713,26 @@ impl<'a> AstBuilder for ExtCtxt<'a> {\n         self.expr(sp, ast::ExprKind::Lit(P(respan(sp, lit))))\n     }\n     fn expr_usize(&self, span: Span, i: usize) -> P<ast::Expr> {\n-        self.expr_lit(span, ast::LitKind::Int(i as u64, ast::LitIntType::Unsigned(ast::UintTy::Us)))\n+        self.expr_lit(span, ast::LitKind::Int(i as u128,\n+                                              ast::LitIntType::Unsigned(ast::UintTy::Us)))\n     }\n     fn expr_isize(&self, sp: Span, i: isize) -> P<ast::Expr> {\n         if i < 0 {\n-            let i = (-i) as u64;\n+            let i = (-i) as u128;\n             let lit_ty = ast::LitIntType::Signed(ast::IntTy::Is);\n             let lit = self.expr_lit(sp, ast::LitKind::Int(i, lit_ty));\n             self.expr_unary(sp, ast::UnOp::Neg, lit)\n         } else {\n-            self.expr_lit(sp, ast::LitKind::Int(i as u64, ast::LitIntType::Signed(ast::IntTy::Is)))\n+            self.expr_lit(sp, ast::LitKind::Int(i as u128,\n+                                                ast::LitIntType::Signed(ast::IntTy::Is)))\n         }\n     }\n     fn expr_u32(&self, sp: Span, u: u32) -> P<ast::Expr> {\n-        self.expr_lit(sp, ast::LitKind::Int(u as u64, ast::LitIntType::Unsigned(ast::UintTy::U32)))\n+        self.expr_lit(sp, ast::LitKind::Int(u as u128,\n+                                            ast::LitIntType::Unsigned(ast::UintTy::U32)))\n     }\n     fn expr_u8(&self, sp: Span, u: u8) -> P<ast::Expr> {\n-        self.expr_lit(sp, ast::LitKind::Int(u as u64, ast::LitIntType::Unsigned(ast::UintTy::U8)))\n+        self.expr_lit(sp, ast::LitKind::Int(u as u128, ast::LitIntType::Unsigned(ast::UintTy::U8)))\n     }\n     fn expr_bool(&self, sp: Span, value: bool) -> P<ast::Expr> {\n         self.expr_lit(sp, ast::LitKind::Bool(value))"}, {"sha": "d2eb2636e6b31deaff6bab62a6623e278efb3e16", "filename": "src/libsyntax/ext/quote.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibsyntax%2Fext%2Fquote.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibsyntax%2Fext%2Fquote.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fquote.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -19,6 +19,7 @@ use parse::token;\n use ptr::P;\n use tokenstream::{self, TokenTree};\n \n+\n /// Quasiquoting works via token trees.\n ///\n /// This is registered as a set of expression syntax extension called quote!\n@@ -40,6 +41,7 @@ pub mod rt {\n     pub use parse::new_parser_from_tts;\n     pub use syntax_pos::{BytePos, Span, DUMMY_SP};\n     pub use codemap::{dummy_spanned};\n+    use rustc_i128::{u128};\n \n     pub trait ToTokens {\n         fn to_tokens(&self, _cx: &ExtCtxt) -> Vec<TokenTree>;\n@@ -288,7 +290,7 @@ pub mod rt {\n                     } else {\n                         *self\n                     };\n-                    let lit = ast::LitKind::Int(val as u64, ast::LitIntType::Signed($tag));\n+                    let lit = ast::LitKind::Int(val as u128, ast::LitIntType::Signed($tag));\n                     let lit = P(ast::Expr {\n                         id: ast::DUMMY_NODE_ID,\n                         node: ast::ExprKind::Lit(P(dummy_spanned(lit))),\n@@ -310,7 +312,7 @@ pub mod rt {\n         (unsigned, $t:ty, $tag:expr) => (\n             impl ToTokens for $t {\n                 fn to_tokens(&self, cx: &ExtCtxt) -> Vec<TokenTree> {\n-                    let lit = ast::LitKind::Int(*self as u64, ast::LitIntType::Unsigned($tag));\n+                    let lit = ast::LitKind::Int(*self as u128, ast::LitIntType::Unsigned($tag));\n                     dummy_spanned(lit).to_tokens(cx)\n                 }\n             }"}, {"sha": "e7df454cf6a50220783c7c533d8934a8ff5250b3", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 38, "deletions": 1, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -318,6 +318,15 @@ declare_features! (\n \n     // Allow safe suggestions for potential type conversions.\n     (active, safe_suggestion, \"1.0.0\", Some(37384)),\n+\n+    // `extern \"ptx-*\" fn()`\n+    (active, abi_ptx, \"1.15.0\", None),\n+\n+    // The `i128` type\n+    (active, i128_type, \"1.16.0\", Some(35118)),\n+\n+    // The `unadjusted` ABI. Perma unstable.\n+    (active, abi_unadjusted, \"1.16.0\", None),\n );\n \n declare_features! (\n@@ -986,7 +995,23 @@ impl<'a> PostExpansionVisitor<'a> {\n                 gate_feature_post!(&self, abi_sysv64, span,\n                                    \"sysv64 ABI is experimental and subject to change\");\n             },\n-            _ => {}\n+            Abi::PtxKernel => {\n+                gate_feature_post!(&self, abi_ptx, span,\n+                                   \"PTX ABIs are experimental and subject to change\");\n+            },\n+            Abi::Unadjusted => {\n+                gate_feature_post!(&self, abi_unadjusted, span,\n+                                   \"unadjusted ABI is an implementation detail and perma-unstable\");\n+            },\n+            // Stable\n+            Abi::Cdecl |\n+            Abi::Stdcall |\n+            Abi::Fastcall |\n+            Abi::Aapcs |\n+            Abi::Win64 |\n+            Abi::Rust |\n+            Abi::C |\n+            Abi::System => {}\n         }\n     }\n }\n@@ -1200,6 +1225,18 @@ impl<'a> Visitor<'a> for PostExpansionVisitor<'a> {\n                 gate_feature_post!(&self, loop_break_value, e.span,\n                                    \"`break` with a value is experimental\");\n             }\n+            ast::ExprKind::Lit(ref lit) => {\n+                if let ast::LitKind::Int(_, ref ty) = lit.node {\n+                    match *ty {\n+                        ast::LitIntType::Signed(ast::IntTy::I128) |\n+                        ast::LitIntType::Unsigned(ast::UintTy::U128) => {\n+                            gate_feature_post!(&self, i128_type, e.span,\n+                                               \"128-bit integers are not stable\");\n+                        }\n+                        _ => {}\n+                    }\n+                }\n+            }\n             _ => {}\n         }\n         visit::walk_expr(self, e);"}, {"sha": "5d6808284f67edba031f3e3d15812035392fb706", "filename": "src/libsyntax/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Flib.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -46,8 +46,9 @@ pub extern crate rustc_errors as errors;\n extern crate syntax_pos;\n extern crate rustc_data_structures;\n \n-extern crate serialize as rustc_serialize; // used by deriving\n+extern crate rustc_i128;\n \n+extern crate serialize as rustc_serialize; // used by deriving\n \n // A variant of 'try!' that panics on an Err. This is used as a crutch on the\n // way towards a non-panic!-prone parser. It should be used for fatal parsing"}, {"sha": "32b61a88ac17f78c94b46a7390f7ab36e2030a6c", "filename": "src/libsyntax/parse/mod.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fmod.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -28,6 +28,8 @@ use std::path::{Path, PathBuf};\n use std::rc::Rc;\n use std::str;\n \n+use rustc_i128::u128;\n+\n pub type PResult<'a, T> = Result<T, DiagnosticBuilder<'a>>;\n \n #[macro_use]\n@@ -557,18 +559,20 @@ pub fn integer_lit(s: &str, suffix: Option<Symbol>, sd: &Handler, sp: Span) -> a\n             \"i16\" => ast::LitIntType::Signed(ast::IntTy::I16),\n             \"i32\" => ast::LitIntType::Signed(ast::IntTy::I32),\n             \"i64\" => ast::LitIntType::Signed(ast::IntTy::I64),\n+            \"i128\" => ast::LitIntType::Signed(ast::IntTy::I128),\n             \"usize\" => ast::LitIntType::Unsigned(ast::UintTy::Us),\n             \"u8\"  => ast::LitIntType::Unsigned(ast::UintTy::U8),\n             \"u16\" => ast::LitIntType::Unsigned(ast::UintTy::U16),\n             \"u32\" => ast::LitIntType::Unsigned(ast::UintTy::U32),\n             \"u64\" => ast::LitIntType::Unsigned(ast::UintTy::U64),\n+            \"u128\" => ast::LitIntType::Unsigned(ast::UintTy::U128),\n             suf => {\n                 // i<digits> and u<digits> look like widths, so lets\n                 // give an error message along those lines\n                 if looks_like_width_suffix(&['i', 'u'], suf) {\n                     sd.struct_span_err(sp, &format!(\"invalid width `{}` for integer literal\",\n                                              &suf[1..]))\n-                      .help(\"valid widths are 8, 16, 32 and 64\")\n+                      .help(\"valid widths are 8, 16, 32, 64 and 128\")\n                       .emit();\n                 } else {\n                     sd.struct_span_err(sp, &format!(\"invalid suffix `{}` for numeric literal\", suf))\n@@ -585,7 +589,7 @@ pub fn integer_lit(s: &str, suffix: Option<Symbol>, sd: &Handler, sp: Span) -> a\n     debug!(\"integer_lit: the type is {:?}, base {:?}, the new string is {:?}, the original \\\n            string was {:?}, the original suffix was {:?}\", ty, base, s, orig, suffix);\n \n-    match u64::from_str_radix(s, base) {\n+    match u128::from_str_radix(s, base) {\n         Ok(r) => ast::LitKind::Int(r, ty),\n         Err(_) => {\n             // small bases are lexed as if they were base 10, e.g, the string"}, {"sha": "2bb38433a26efc47e5c5ce0f8070c8bfb8093796", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -64,6 +64,8 @@ use std::path::{Path, PathBuf};\n use std::rc::Rc;\n use std::slice;\n \n+use rustc_i128::u128;\n+\n bitflags! {\n     flags Restrictions: u8 {\n         const RESTRICTION_STMT_EXPR         = 1 << 0,\n@@ -2044,7 +2046,7 @@ impl<'a> Parser<'a> {\n     pub fn mk_lit_u32(&mut self, i: u32, attrs: ThinVec<Attribute>) -> P<Expr> {\n         let span = &self.span;\n         let lv_lit = P(codemap::Spanned {\n-            node: LitKind::Int(i as u64, ast::LitIntType::Unsigned(UintTy::U32)),\n+            node: LitKind::Int(i as u128, ast::LitIntType::Unsigned(UintTy::U32)),\n             span: *span\n         });\n "}, {"sha": "60e1882fcf582c4ad36f4f423ce3c2b29405641c", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -30,6 +30,8 @@ use std_inject;\n use symbol::{Symbol, keywords};\n use tokenstream::{self, TokenTree};\n \n+use rustc_i128::i128;\n+\n use std::ascii;\n use std::io::{self, Write, Read};\n use std::iter;\n@@ -647,8 +649,7 @@ pub trait PrintState<'a> {\n             ast::LitKind::Int(i, t) => {\n                 match t {\n                     ast::LitIntType::Signed(st) => {\n-                        word(self.writer(),\n-                             &st.val_to_string(i as i64))\n+                        word(self.writer(), &st.val_to_string(i as i128))\n                     }\n                     ast::LitIntType::Unsigned(ut) => {\n                         word(self.writer(), &ut.val_to_string(i))"}, {"sha": "64ec460a5246042bab26d3b5c6c8c910b513a60e", "filename": "src/libsyntax_ext/deriving/custom.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fcustom.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -12,7 +12,7 @@ use std::panic;\n \n use errors::FatalError;\n use proc_macro::{TokenStream, __internal};\n-use syntax::ast::{self, ItemKind, Attribute};\n+use syntax::ast::{self, ItemKind, Attribute, Mac};\n use syntax::attr::{mark_used, mark_known};\n use syntax::codemap::Span;\n use syntax::ext::base::*;\n@@ -28,6 +28,8 @@ impl<'a> Visitor<'a> for MarkAttrs<'a> {\n             mark_known(attr);\n         }\n     }\n+\n+    fn visit_mac(&mut self, _mac: &Mac) {}\n }\n \n pub struct CustomDerive {"}, {"sha": "0d2f4eaaffda3097a903bef2745c247feee035db", "filename": "src/libsyntax_ext/deriving/generic/mod.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -782,12 +782,14 @@ fn find_repr_type_name(diagnostic: &Handler, type_attrs: &[ast::Attribute]) -> &\n                 attr::ReprInt(attr::SignedInt(ast::IntTy::I16)) => \"i16\",\n                 attr::ReprInt(attr::SignedInt(ast::IntTy::I32)) => \"i32\",\n                 attr::ReprInt(attr::SignedInt(ast::IntTy::I64)) => \"i64\",\n+                attr::ReprInt(attr::SignedInt(ast::IntTy::I128)) => \"i128\",\n \n                 attr::ReprInt(attr::UnsignedInt(ast::UintTy::Us)) => \"usize\",\n                 attr::ReprInt(attr::UnsignedInt(ast::UintTy::U8)) => \"u8\",\n                 attr::ReprInt(attr::UnsignedInt(ast::UintTy::U16)) => \"u16\",\n                 attr::ReprInt(attr::UnsignedInt(ast::UintTy::U32)) => \"u32\",\n                 attr::ReprInt(attr::UnsignedInt(ast::UintTy::U64)) => \"u64\",\n+                attr::ReprInt(attr::UnsignedInt(ast::UintTy::U128)) => \"u128\",\n             }\n         }\n     }"}, {"sha": "68cfc7033ef5afa9938e483b13e6603a29e99954", "filename": "src/libterm/terminfo/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibterm%2Fterminfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibterm%2Fterminfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fmod.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -190,7 +190,7 @@ impl<T: Write + Send> Terminal for TerminfoTerminal<T> {\n     fn reset(&mut self) -> io::Result<bool> {\n         // are there any terminals that have color/attrs and not sgr0?\n         // Try falling back to sgr, then op\n-        let cmd = match [\"sg0\", \"sgr\", \"op\"]\n+        let cmd = match [\"sgr0\", \"sgr\", \"op\"]\n                             .iter()\n                             .filter_map(|cap| self.ti.strings.get(*cap))\n                             .next() {"}, {"sha": "fbd9789d2f52d16c98aa91319664b707cb9c2ad8", "filename": "src/libunwind/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibunwind%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Flibunwind%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibunwind%2FCargo.toml?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -9,6 +9,7 @@ name = \"unwind\"\n path = \"lib.rs\"\n test = false\n bench = false\n+doc = false\n \n [dependencies]\n core = { path = \"../libcore\" }"}, {"sha": "39df3528be369adac52e033e8dedc53edd8d9f6a", "filename": "src/rustc/libc_shim/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Frustc%2Flibc_shim%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Frustc%2Flibc_shim%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Flibc_shim%2FCargo.toml?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -17,6 +17,7 @@ name = \"libc\"\n path = \"../../liblibc/src/lib.rs\"\n test = false\n bench = false\n+doc = false\n \n [dependencies]\n core = { path = \"../../libcore\" }"}, {"sha": "1fa917724353628ce1e981c6b2d61186016de45f", "filename": "src/rustc/std_shim/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Frustc%2Fstd_shim%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Frustc%2Fstd_shim%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fstd_shim%2FCargo.toml?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -27,6 +27,7 @@ authors = [\"The Rust Project Developers\"]\n [lib]\n name = \"std_shim\"\n path = \"lib.rs\"\n+doc = false\n \n [dependencies]\n std = { path = \"../../libstd\" }"}, {"sha": "6ff06b56bc412e79c8769c20ea60b19ea815c655", "filename": "src/rustllvm/ArchiveWrapper.cpp", "status": "modified", "additions": 139, "deletions": 129, "changes": 268, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Frustllvm%2FArchiveWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Frustllvm%2FArchiveWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FArchiveWrapper.cpp?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -21,49 +21,51 @@ struct RustArchiveMember {\n   const char *name;\n   Archive::Child child;\n \n-  RustArchiveMember(): filename(NULL), name(NULL),\n+  RustArchiveMember()\n+      : filename(nullptr), name(nullptr),\n #if LLVM_VERSION_GE(3, 8)\n-    child(NULL, NULL, NULL)\n+        child(nullptr, nullptr, nullptr)\n #else\n-    child(NULL, NULL)\n+        child(nullptr, nullptr)\n #endif\n-  {}\n+  {\n+  }\n   ~RustArchiveMember() {}\n };\n \n-\n struct RustArchiveIterator {\n-    Archive::child_iterator cur;\n-    Archive::child_iterator end;\n+  bool first;\n+  Archive::child_iterator cur;\n+  Archive::child_iterator end;\n #if LLVM_VERSION_GE(3, 9)\n-    Error err;\n+  Error err;\n \n-    RustArchiveIterator() : err(Error::success()) { }\n+  RustArchiveIterator() : first(true), err(Error::success()) {}\n+#else\n+  RustArchiveIterator() : first(true) {}\n #endif\n };\n \n enum class LLVMRustArchiveKind {\n-    Other,\n-    GNU,\n-    MIPS64,\n-    BSD,\n-    COFF,\n+  Other,\n+  GNU,\n+  MIPS64,\n+  BSD,\n+  COFF,\n };\n \n-static Archive::Kind\n-from_rust(LLVMRustArchiveKind kind)\n-{\n-    switch (kind) {\n-    case LLVMRustArchiveKind::GNU:\n-        return Archive::K_GNU;\n-    case LLVMRustArchiveKind::MIPS64:\n-        return Archive::K_MIPS64;\n-    case LLVMRustArchiveKind::BSD:\n-        return Archive::K_BSD;\n-    case LLVMRustArchiveKind::COFF:\n-        return Archive::K_COFF;\n-    default:\n-      llvm_unreachable(\"Bad ArchiveKind.\");\n+static Archive::Kind from_rust(LLVMRustArchiveKind kind) {\n+  switch (kind) {\n+  case LLVMRustArchiveKind::GNU:\n+    return Archive::K_GNU;\n+  case LLVMRustArchiveKind::MIPS64:\n+    return Archive::K_MIPS64;\n+  case LLVMRustArchiveKind::BSD:\n+    return Archive::K_BSD;\n+  case LLVMRustArchiveKind::COFF:\n+    return Archive::K_COFF;\n+  default:\n+    llvm_unreachable(\"Bad ArchiveKind.\");\n   }\n }\n \n@@ -73,160 +75,166 @@ typedef Archive::Child *LLVMRustArchiveChildRef;\n typedef Archive::Child const *LLVMRustArchiveChildConstRef;\n typedef RustArchiveIterator *LLVMRustArchiveIteratorRef;\n \n-extern \"C\" LLVMRustArchiveRef\n-LLVMRustOpenArchive(char *path) {\n-    ErrorOr<std::unique_ptr<MemoryBuffer>> buf_or = MemoryBuffer::getFile(path,\n-                                                                          -1,\n-                                                                          false);\n-    if (!buf_or) {\n-        LLVMRustSetLastError(buf_or.getError().message().c_str());\n-        return nullptr;\n-    }\n+extern \"C\" LLVMRustArchiveRef LLVMRustOpenArchive(char *path) {\n+  ErrorOr<std::unique_ptr<MemoryBuffer>> buf_or =\n+      MemoryBuffer::getFile(path, -1, false);\n+  if (!buf_or) {\n+    LLVMRustSetLastError(buf_or.getError().message().c_str());\n+    return nullptr;\n+  }\n \n #if LLVM_VERSION_LE(3, 8)\n-    ErrorOr<std::unique_ptr<Archive>> archive_or =\n+  ErrorOr<std::unique_ptr<Archive>> archive_or =\n #else\n-    Expected<std::unique_ptr<Archive>> archive_or =\n+  Expected<std::unique_ptr<Archive>> archive_or =\n #endif\n-        Archive::create(buf_or.get()->getMemBufferRef());\n+      Archive::create(buf_or.get()->getMemBufferRef());\n \n-    if (!archive_or) {\n+  if (!archive_or) {\n #if LLVM_VERSION_LE(3, 8)\n-        LLVMRustSetLastError(archive_or.getError().message().c_str());\n+    LLVMRustSetLastError(archive_or.getError().message().c_str());\n #else\n-        LLVMRustSetLastError(toString(archive_or.takeError()).c_str());\n+    LLVMRustSetLastError(toString(archive_or.takeError()).c_str());\n #endif\n-        return nullptr;\n-    }\n+    return nullptr;\n+  }\n \n-    OwningBinary<Archive> *ret = new OwningBinary<Archive>(\n-            std::move(archive_or.get()), std::move(buf_or.get()));\n+  OwningBinary<Archive> *ret = new OwningBinary<Archive>(\n+      std::move(archive_or.get()), std::move(buf_or.get()));\n \n-    return ret;\n+  return ret;\n }\n \n-extern \"C\" void\n-LLVMRustDestroyArchive(LLVMRustArchiveRef ar) {\n-    delete ar;\n-}\n+extern \"C\" void LLVMRustDestroyArchive(LLVMRustArchiveRef ar) { delete ar; }\n \n extern \"C\" LLVMRustArchiveIteratorRef\n LLVMRustArchiveIteratorNew(LLVMRustArchiveRef ra) {\n-    Archive *ar = ra->getBinary();\n-    RustArchiveIterator *rai = new RustArchiveIterator();\n+  Archive *ar = ra->getBinary();\n+  RustArchiveIterator *rai = new RustArchiveIterator();\n #if LLVM_VERSION_LE(3, 8)\n-    rai->cur = ar->child_begin();\n+  rai->cur = ar->child_begin();\n #else\n-    rai->cur = ar->child_begin(rai->err);\n-    if (rai->err) {\n-        LLVMRustSetLastError(toString(std::move(rai->err)).c_str());\n-        return NULL;\n-    }\n+  rai->cur = ar->child_begin(rai->err);\n+  if (rai->err) {\n+    LLVMRustSetLastError(toString(std::move(rai->err)).c_str());\n+    delete rai;\n+    return nullptr;\n+  }\n #endif\n-    rai->end = ar->child_end();\n-    return rai;\n+  rai->end = ar->child_end();\n+  return rai;\n }\n \n extern \"C\" LLVMRustArchiveChildConstRef\n LLVMRustArchiveIteratorNext(LLVMRustArchiveIteratorRef rai) {\n+  if (rai->cur == rai->end)\n+    return nullptr;\n+\n+  // Advancing the iterator validates the next child, and this can\n+  // uncover an error. LLVM requires that we check all Errors,\n+  // so we only advance the iterator if we actually need to fetch\n+  // the next child.\n+  // This means we must not advance the iterator in the *first* call,\n+  // but instead advance it *before* fetching the child in all later calls.\n+  if (!rai->first) {\n+    ++rai->cur;\n #if LLVM_VERSION_GE(3, 9)\n     if (rai->err) {\n-        LLVMRustSetLastError(toString(std::move(rai->err)).c_str());\n-        return NULL;\n+      LLVMRustSetLastError(toString(std::move(rai->err)).c_str());\n+      return nullptr;\n     }\n #endif\n-    if (rai->cur == rai->end)\n-        return NULL;\n+  } else {\n+    rai->first = false;\n+  }\n+\n+  if (rai->cur == rai->end)\n+    return nullptr;\n+\n #if LLVM_VERSION_EQ(3, 8)\n-    const ErrorOr<Archive::Child>* cur = rai->cur.operator->();\n-    if (!*cur) {\n-        LLVMRustSetLastError(cur->getError().message().c_str());\n-        return NULL;\n-    }\n-    const Archive::Child &child = cur->get();\n+  const ErrorOr<Archive::Child> *cur = rai->cur.operator->();\n+  if (!*cur) {\n+    LLVMRustSetLastError(cur->getError().message().c_str());\n+    return nullptr;\n+  }\n+  const Archive::Child &child = cur->get();\n #else\n-    const Archive::Child &child = *rai->cur.operator->();\n+  const Archive::Child &child = *rai->cur.operator->();\n #endif\n-    Archive::Child *ret = new Archive::Child(child);\n+  Archive::Child *ret = new Archive::Child(child);\n \n-    ++rai->cur;\n-    return ret;\n+  return ret;\n }\n \n-extern \"C\" void\n-LLVMRustArchiveChildFree(LLVMRustArchiveChildRef child) {\n-    delete child;\n+extern \"C\" void LLVMRustArchiveChildFree(LLVMRustArchiveChildRef child) {\n+  delete child;\n }\n \n-extern \"C\" void\n-LLVMRustArchiveIteratorFree(LLVMRustArchiveIteratorRef rai) {\n-    delete rai;\n+extern \"C\" void LLVMRustArchiveIteratorFree(LLVMRustArchiveIteratorRef rai) {\n+  delete rai;\n }\n \n-extern \"C\" const char*\n+extern \"C\" const char *\n LLVMRustArchiveChildName(LLVMRustArchiveChildConstRef child, size_t *size) {\n #if LLVM_VERSION_GE(4, 0)\n-    Expected<StringRef> name_or_err = child->getName();\n-    if (!name_or_err) {\n-        // rustc_llvm currently doesn't use this error string, but it might be useful\n-        // in the future, and in the mean time this tells LLVM that the error was\n-        // not ignored and that it shouldn't abort the process.\n-        LLVMRustSetLastError(toString(name_or_err.takeError()).c_str());\n-        return NULL;\n-    }\n+  Expected<StringRef> name_or_err = child->getName();\n+  if (!name_or_err) {\n+    // rustc_llvm currently doesn't use this error string, but it might be useful\n+    // in the future, and in the mean time this tells LLVM that the error was\n+    // not ignored and that it shouldn't abort the process.\n+    LLVMRustSetLastError(toString(name_or_err.takeError()).c_str());\n+    return nullptr;\n+  }\n #else\n-    ErrorOr<StringRef> name_or_err = child->getName();\n-    if (name_or_err.getError())\n-        return NULL;\n+  ErrorOr<StringRef> name_or_err = child->getName();\n+  if (name_or_err.getError())\n+    return nullptr;\n #endif\n-    StringRef name = name_or_err.get();\n-    *size = name.size();\n-    return name.data();\n+  StringRef name = name_or_err.get();\n+  *size = name.size();\n+  return name.data();\n }\n \n-extern \"C\" const char*\n-LLVMRustArchiveChildData(LLVMRustArchiveChildRef child, size_t *size) {\n-    StringRef buf;\n+extern \"C\" const char *LLVMRustArchiveChildData(LLVMRustArchiveChildRef child,\n+                                                size_t *size) {\n+  StringRef buf;\n #if LLVM_VERSION_GE(4, 0)\n-    Expected<StringRef> buf_or_err = child->getBuffer();\n-    if (!buf_or_err) {\n-      LLVMRustSetLastError(toString(buf_or_err.takeError()).c_str());\n-      return NULL;\n-    }\n+  Expected<StringRef> buf_or_err = child->getBuffer();\n+  if (!buf_or_err) {\n+    LLVMRustSetLastError(toString(buf_or_err.takeError()).c_str());\n+    return nullptr;\n+  }\n #else\n-    ErrorOr<StringRef> buf_or_err = child->getBuffer();\n-    if (buf_or_err.getError()) {\n-      LLVMRustSetLastError(buf_or_err.getError().message().c_str());\n-      return NULL;\n-    }\n+  ErrorOr<StringRef> buf_or_err = child->getBuffer();\n+  if (buf_or_err.getError()) {\n+    LLVMRustSetLastError(buf_or_err.getError().message().c_str());\n+    return nullptr;\n+  }\n #endif\n-    buf = buf_or_err.get();\n-    *size = buf.size();\n-    return buf.data();\n+  buf = buf_or_err.get();\n+  *size = buf.size();\n+  return buf.data();\n }\n \n extern \"C\" LLVMRustArchiveMemberRef\n LLVMRustArchiveMemberNew(char *Filename, char *Name,\n-\t\t\t LLVMRustArchiveChildRef child) {\n-    RustArchiveMember *Member = new RustArchiveMember;\n-    Member->filename = Filename;\n-    Member->name = Name;\n-    if (child)\n-        Member->child = *child;\n-    return Member;\n+                         LLVMRustArchiveChildRef child) {\n+  RustArchiveMember *Member = new RustArchiveMember;\n+  Member->filename = Filename;\n+  Member->name = Name;\n+  if (child)\n+    Member->child = *child;\n+  return Member;\n }\n \n-extern \"C\" void\n-LLVMRustArchiveMemberFree(LLVMRustArchiveMemberRef Member) {\n-    delete Member;\n+extern \"C\" void LLVMRustArchiveMemberFree(LLVMRustArchiveMemberRef Member) {\n+  delete Member;\n }\n \n extern \"C\" LLVMRustResult\n-LLVMRustWriteArchive(char *Dst,\n-                     size_t NumMembers,\n+LLVMRustWriteArchive(char *Dst, size_t NumMembers,\n                      const LLVMRustArchiveMemberRef *NewMembers,\n-                     bool WriteSymbtab,\n-                     LLVMRustArchiveKind rust_kind) {\n+                     bool WriteSymbtab, LLVMRustArchiveKind rust_kind) {\n \n #if LLVM_VERSION_LE(3, 8)\n   std::vector<NewArchiveIterator> Members;\n@@ -240,7 +248,8 @@ LLVMRustWriteArchive(char *Dst,\n     assert(Member->name);\n     if (Member->filename) {\n #if LLVM_VERSION_GE(3, 9)\n-      Expected<NewArchiveMember> MOrErr = NewArchiveMember::getFile(Member->filename, true);\n+      Expected<NewArchiveMember> MOrErr =\n+          NewArchiveMember::getFile(Member->filename, true);\n       if (!MOrErr) {\n         LLVMRustSetLastError(toString(MOrErr.takeError()).c_str());\n         return LLVMRustResult::Failure;\n@@ -255,7 +264,8 @@ LLVMRustWriteArchive(char *Dst,\n #if LLVM_VERSION_LE(3, 8)\n       Members.push_back(NewArchiveIterator(Member->child, Member->name));\n #else\n-      Expected<NewArchiveMember> MOrErr = NewArchiveMember::getOldMember(Member->child, true);\n+      Expected<NewArchiveMember> MOrErr =\n+          NewArchiveMember::getOldMember(Member->child, true);\n       if (!MOrErr) {\n         LLVMRustSetLastError(toString(MOrErr.takeError()).c_str());\n         return LLVMRustResult::Failure;"}, {"sha": "7bc6e8b0ecb11ef656a0004d5e8f3af09b7a7851", "filename": "src/rustllvm/PassWrapper.cpp", "status": "modified", "additions": 306, "deletions": 350, "changes": 656, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Frustllvm%2FPassWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Frustllvm%2FPassWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FPassWrapper.cpp?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -12,12 +12,12 @@\n \n #include \"rustllvm.h\"\n \n-#include \"llvm/Support/CBindingWrapping.h\"\n-#include \"llvm/Support/FileSystem.h\"\n-#include \"llvm/Support/Host.h\"\n #include \"llvm/Analysis/TargetLibraryInfo.h\"\n #include \"llvm/Analysis/TargetTransformInfo.h\"\n #include \"llvm/IR/AutoUpgrade.h\"\n+#include \"llvm/Support/CBindingWrapping.h\"\n+#include \"llvm/Support/FileSystem.h\"\n+#include \"llvm/Support/Host.h\"\n #include \"llvm/Target/TargetMachine.h\"\n #include \"llvm/Target/TargetSubtargetInfo.h\"\n #include \"llvm/Transforms/IPO/PassManagerBuilder.h\"\n@@ -38,10 +38,10 @@ typedef struct LLVMOpaqueTargetMachine *LLVMTargetMachineRef;\n \n DEFINE_STDCXX_CONVERSION_FUNCTIONS(Pass, LLVMPassRef)\n DEFINE_STDCXX_CONVERSION_FUNCTIONS(TargetMachine, LLVMTargetMachineRef)\n-DEFINE_STDCXX_CONVERSION_FUNCTIONS(PassManagerBuilder, LLVMPassManagerBuilderRef)\n+DEFINE_STDCXX_CONVERSION_FUNCTIONS(PassManagerBuilder,\n+                                   LLVMPassManagerBuilderRef)\n \n-extern \"C\" void\n-LLVMInitializePasses() {\n+extern \"C\" void LLVMInitializePasses() {\n   PassRegistry &Registry = *PassRegistry::getPassRegistry();\n   initializeCore(Registry);\n   initializeCodeGen(Registry);\n@@ -64,44 +64,39 @@ enum class LLVMRustPassKind {\n   Module,\n };\n \n-static LLVMRustPassKind\n-to_rust(PassKind kind)\n-{\n+static LLVMRustPassKind to_rust(PassKind kind) {\n   switch (kind) {\n   case PT_Function:\n-      return LLVMRustPassKind::Function;\n+    return LLVMRustPassKind::Function;\n   case PT_Module:\n-      return LLVMRustPassKind::Module;\n+    return LLVMRustPassKind::Module;\n   default:\n-      return LLVMRustPassKind::Other;\n+    return LLVMRustPassKind::Other;\n   }\n }\n \n-extern \"C\" LLVMPassRef\n-LLVMRustFindAndCreatePass(const char *PassName) {\n-    StringRef SR(PassName);\n-    PassRegistry *PR = PassRegistry::getPassRegistry();\n+extern \"C\" LLVMPassRef LLVMRustFindAndCreatePass(const char *PassName) {\n+  StringRef SR(PassName);\n+  PassRegistry *PR = PassRegistry::getPassRegistry();\n \n-    const PassInfo *PI = PR->getPassInfo(SR);\n-    if (PI) {\n-      return wrap(PI->createPass());\n-    }\n-    return NULL;\n+  const PassInfo *PI = PR->getPassInfo(SR);\n+  if (PI) {\n+    return wrap(PI->createPass());\n+  }\n+  return nullptr;\n }\n \n-extern \"C\" LLVMRustPassKind\n-LLVMRustPassKind(LLVMPassRef rust_pass) {\n-    assert(rust_pass);\n-    Pass *pass = unwrap(rust_pass);\n-    return to_rust(pass->getPassKind());\n+extern \"C\" LLVMRustPassKind LLVMRustPassKind(LLVMPassRef rust_pass) {\n+  assert(rust_pass);\n+  Pass *pass = unwrap(rust_pass);\n+  return to_rust(pass->getPassKind());\n }\n \n-extern \"C\" void\n-LLVMRustAddPass(LLVMPassManagerRef PM, LLVMPassRef rust_pass) {\n-    assert(rust_pass);\n-    Pass *pass = unwrap(rust_pass);\n-    PassManagerBase *pm = unwrap(PM);\n-    pm->add(pass);\n+extern \"C\" void LLVMRustAddPass(LLVMPassManagerRef PM, LLVMPassRef rust_pass) {\n+  assert(rust_pass);\n+  Pass *pass = unwrap(rust_pass);\n+  PassManagerBase *pm = unwrap(PM);\n+  pm->add(pass);\n }\n \n #ifdef LLVM_COMPONENT_X86\n@@ -152,101 +147,95 @@ LLVMRustAddPass(LLVMPassManagerRef PM, LLVMPassRef rust_pass) {\n #define SUBTARGET_SPARC\n #endif\n \n-#define GEN_SUBTARGETS    \\\n-        SUBTARGET_X86     \\\n-        SUBTARGET_ARM     \\\n-        SUBTARGET_AARCH64 \\\n-        SUBTARGET_MIPS    \\\n-        SUBTARGET_PPC     \\\n-        SUBTARGET_SYSTEMZ \\\n-        SUBTARGET_MSP430  \\\n-        SUBTARGET_SPARC\n-\n-#define SUBTARGET(x) namespace llvm {                \\\n-    extern const SubtargetFeatureKV x##FeatureKV[];  \\\n-    extern const SubtargetFeatureKV x##SubTypeKV[];  \\\n+#define GEN_SUBTARGETS                                                         \\\n+  SUBTARGET_X86                                                                \\\n+  SUBTARGET_ARM                                                                \\\n+  SUBTARGET_AARCH64                                                            \\\n+  SUBTARGET_MIPS                                                               \\\n+  SUBTARGET_PPC                                                                \\\n+  SUBTARGET_SYSTEMZ                                                            \\\n+  SUBTARGET_MSP430                                                             \\\n+  SUBTARGET_SPARC\n+\n+#define SUBTARGET(x)                                                           \\\n+  namespace llvm {                                                             \\\n+  extern const SubtargetFeatureKV x##FeatureKV[];                              \\\n+  extern const SubtargetFeatureKV x##SubTypeKV[];                              \\\n   }\n \n GEN_SUBTARGETS\n #undef SUBTARGET\n \n-extern \"C\" bool\n-LLVMRustHasFeature(LLVMTargetMachineRef TM,\n-\t\t   const char *feature) {\n-    TargetMachine *Target = unwrap(TM);\n-    const MCSubtargetInfo *MCInfo = Target->getMCSubtargetInfo();\n-    const FeatureBitset &Bits = MCInfo->getFeatureBits();\n-    const llvm::SubtargetFeatureKV *FeatureEntry;\n-\n-#define SUBTARGET(x)                                        \\\n-    if (MCInfo->isCPUStringValid(x##SubTypeKV[0].Key)) {    \\\n-        FeatureEntry = x##FeatureKV;                       \\\n-    } else\n-\n-    GEN_SUBTARGETS {\n-        return false;\n-    }\n+extern \"C\" bool LLVMRustHasFeature(LLVMTargetMachineRef TM,\n+                                   const char *feature) {\n+  TargetMachine *Target = unwrap(TM);\n+  const MCSubtargetInfo *MCInfo = Target->getMCSubtargetInfo();\n+  const FeatureBitset &Bits = MCInfo->getFeatureBits();\n+  const llvm::SubtargetFeatureKV *FeatureEntry;\n+\n+#define SUBTARGET(x)                                                           \\\n+  if (MCInfo->isCPUStringValid(x##SubTypeKV[0].Key)) {                         \\\n+    FeatureEntry = x##FeatureKV;                                               \\\n+  } else\n+\n+  GEN_SUBTARGETS { return false; }\n #undef SUBTARGET\n \n-    while (strcmp(feature, FeatureEntry->Key) != 0)\n-        FeatureEntry++;\n+  while (strcmp(feature, FeatureEntry->Key) != 0)\n+    FeatureEntry++;\n \n-    return (Bits & FeatureEntry->Value) == FeatureEntry->Value;\n+  return (Bits & FeatureEntry->Value) == FeatureEntry->Value;\n }\n \n enum class LLVMRustCodeModel {\n-    Other,\n-    Default,\n-    JITDefault,\n-    Small,\n-    Kernel,\n-    Medium,\n-    Large,\n+  Other,\n+  Default,\n+  JITDefault,\n+  Small,\n+  Kernel,\n+  Medium,\n+  Large,\n };\n \n-static CodeModel::Model\n-from_rust(LLVMRustCodeModel model)\n-{\n-    switch (model) {\n-    case LLVMRustCodeModel::Default:\n-        return CodeModel::Default;\n-    case LLVMRustCodeModel::JITDefault:\n-        return CodeModel::JITDefault;\n-    case LLVMRustCodeModel::Small:\n-        return CodeModel::Small;\n-    case LLVMRustCodeModel::Kernel:\n-        return CodeModel::Kernel;\n-    case LLVMRustCodeModel::Medium:\n-        return CodeModel::Medium;\n-    case LLVMRustCodeModel::Large:\n-        return CodeModel::Large;\n-    default:\n-        llvm_unreachable(\"Bad CodeModel.\");\n+static CodeModel::Model from_rust(LLVMRustCodeModel model) {\n+  switch (model) {\n+  case LLVMRustCodeModel::Default:\n+    return CodeModel::Default;\n+  case LLVMRustCodeModel::JITDefault:\n+    return CodeModel::JITDefault;\n+  case LLVMRustCodeModel::Small:\n+    return CodeModel::Small;\n+  case LLVMRustCodeModel::Kernel:\n+    return CodeModel::Kernel;\n+  case LLVMRustCodeModel::Medium:\n+    return CodeModel::Medium;\n+  case LLVMRustCodeModel::Large:\n+    return CodeModel::Large;\n+  default:\n+    llvm_unreachable(\"Bad CodeModel.\");\n   }\n }\n \n enum class LLVMRustCodeGenOptLevel {\n-    Other,\n-    None,\n-    Less,\n-    Default,\n-    Aggressive,\n+  Other,\n+  None,\n+  Less,\n+  Default,\n+  Aggressive,\n };\n \n-static CodeGenOpt::Level\n-from_rust(LLVMRustCodeGenOptLevel level)\n-{\n-    switch (level) {\n-    case LLVMRustCodeGenOptLevel::None:\n-        return CodeGenOpt::None;\n-    case LLVMRustCodeGenOptLevel::Less:\n-        return CodeGenOpt::Less;\n-    case LLVMRustCodeGenOptLevel::Default:\n-        return CodeGenOpt::Default;\n-    case LLVMRustCodeGenOptLevel::Aggressive:\n-        return CodeGenOpt::Aggressive;\n-    default:\n-        llvm_unreachable(\"Bad CodeGenOptLevel.\");\n+static CodeGenOpt::Level from_rust(LLVMRustCodeGenOptLevel level) {\n+  switch (level) {\n+  case LLVMRustCodeGenOptLevel::None:\n+    return CodeGenOpt::None;\n+  case LLVMRustCodeGenOptLevel::Less:\n+    return CodeGenOpt::Less;\n+  case LLVMRustCodeGenOptLevel::Default:\n+    return CodeGenOpt::Default;\n+  case LLVMRustCodeGenOptLevel::Aggressive:\n+    return CodeGenOpt::Aggressive;\n+  default:\n+    llvm_unreachable(\"Bad CodeGenOptLevel.\");\n   }\n }\n \n@@ -260,234 +249,209 @@ static size_t getLongestEntryLength(ArrayRef<SubtargetFeatureKV> Table) {\n   return MaxLen;\n }\n \n-extern \"C\" void\n-LLVMRustPrintTargetCPUs(LLVMTargetMachineRef TM) {\n-    const TargetMachine *Target = unwrap(TM);\n-    const MCSubtargetInfo *MCInfo = Target->getMCSubtargetInfo();\n-    const ArrayRef<SubtargetFeatureKV> CPUTable = MCInfo->getCPUTable();\n-    unsigned MaxCPULen = getLongestEntryLength(CPUTable);\n-\n-    printf(\"Available CPUs for this target:\\n\");\n-    for (auto &CPU : CPUTable)\n-        printf(\"    %-*s - %s.\\n\", MaxCPULen, CPU.Key, CPU.Desc);\n-    printf(\"\\n\");\n+extern \"C\" void LLVMRustPrintTargetCPUs(LLVMTargetMachineRef TM) {\n+  const TargetMachine *Target = unwrap(TM);\n+  const MCSubtargetInfo *MCInfo = Target->getMCSubtargetInfo();\n+  const ArrayRef<SubtargetFeatureKV> CPUTable = MCInfo->getCPUTable();\n+  unsigned MaxCPULen = getLongestEntryLength(CPUTable);\n+\n+  printf(\"Available CPUs for this target:\\n\");\n+  for (auto &CPU : CPUTable)\n+    printf(\"    %-*s - %s.\\n\", MaxCPULen, CPU.Key, CPU.Desc);\n+  printf(\"\\n\");\n }\n \n-extern \"C\" void\n-LLVMRustPrintTargetFeatures(LLVMTargetMachineRef TM) {\n-    const TargetMachine *Target = unwrap(TM);\n-    const MCSubtargetInfo *MCInfo = Target->getMCSubtargetInfo();\n-    const ArrayRef<SubtargetFeatureKV> FeatTable = MCInfo->getFeatureTable();\n-    unsigned MaxFeatLen = getLongestEntryLength(FeatTable);\n-\n-    printf(\"Available features for this target:\\n\");\n-    for (auto &Feature : FeatTable)\n-        printf(\"    %-*s - %s.\\n\", MaxFeatLen, Feature.Key, Feature.Desc);\n-    printf(\"\\n\");\n-\n-    printf(\"Use +feature to enable a feature, or -feature to disable it.\\n\"\n-            \"For example, rustc -C -target-cpu=mycpu -C target-feature=+feature1,-feature2\\n\\n\");\n+extern \"C\" void LLVMRustPrintTargetFeatures(LLVMTargetMachineRef TM) {\n+  const TargetMachine *Target = unwrap(TM);\n+  const MCSubtargetInfo *MCInfo = Target->getMCSubtargetInfo();\n+  const ArrayRef<SubtargetFeatureKV> FeatTable = MCInfo->getFeatureTable();\n+  unsigned MaxFeatLen = getLongestEntryLength(FeatTable);\n+\n+  printf(\"Available features for this target:\\n\");\n+  for (auto &Feature : FeatTable)\n+    printf(\"    %-*s - %s.\\n\", MaxFeatLen, Feature.Key, Feature.Desc);\n+  printf(\"\\n\");\n+\n+  printf(\"Use +feature to enable a feature, or -feature to disable it.\\n\"\n+         \"For example, rustc -C -target-cpu=mycpu -C \"\n+         \"target-feature=+feature1,-feature2\\n\\n\");\n }\n \n #else\n \n-extern \"C\" void\n-LLVMRustPrintTargetCPUs(LLVMTargetMachineRef) {\n-    printf(\"Target CPU help is not supported by this LLVM version.\\n\\n\");\n+extern \"C\" void LLVMRustPrintTargetCPUs(LLVMTargetMachineRef) {\n+  printf(\"Target CPU help is not supported by this LLVM version.\\n\\n\");\n }\n \n-extern \"C\" void\n-LLVMRustPrintTargetFeatures(LLVMTargetMachineRef) {\n-    printf(\"Target features help is not supported by this LLVM version.\\n\\n\");\n+extern \"C\" void LLVMRustPrintTargetFeatures(LLVMTargetMachineRef) {\n+  printf(\"Target features help is not supported by this LLVM version.\\n\\n\");\n }\n #endif\n \n-extern \"C\" LLVMTargetMachineRef\n-LLVMRustCreateTargetMachine(const char *triple,\n-                            const char *cpu,\n-                            const char *feature,\n-                            LLVMRustCodeModel rust_CM,\n-                            LLVMRelocMode Reloc,\n-                            LLVMRustCodeGenOptLevel rust_OptLevel,\n-                            bool UseSoftFloat,\n-                            bool PositionIndependentExecutable,\n-                            bool FunctionSections,\n-                            bool DataSections) {\n+extern \"C\" LLVMTargetMachineRef LLVMRustCreateTargetMachine(\n+    const char *triple, const char *cpu, const char *feature,\n+    LLVMRustCodeModel rust_CM, LLVMRelocMode Reloc,\n+    LLVMRustCodeGenOptLevel rust_OptLevel, bool UseSoftFloat,\n+    bool PositionIndependentExecutable, bool FunctionSections,\n+    bool DataSections) {\n \n #if LLVM_VERSION_LE(3, 8)\n-    Reloc::Model RM;\n+  Reloc::Model RM;\n #else\n-    Optional<Reloc::Model> RM;\n+  Optional<Reloc::Model> RM;\n #endif\n-    auto CM = from_rust(rust_CM);\n-    auto OptLevel = from_rust(rust_OptLevel);\n-\n-    switch (Reloc){\n-        case LLVMRelocStatic:\n-            RM = Reloc::Static;\n-            break;\n-        case LLVMRelocPIC:\n-            RM = Reloc::PIC_;\n-            break;\n-        case LLVMRelocDynamicNoPic:\n-            RM = Reloc::DynamicNoPIC;\n-            break;\n-        default:\n+  auto CM = from_rust(rust_CM);\n+  auto OptLevel = from_rust(rust_OptLevel);\n+\n+  switch (Reloc) {\n+  case LLVMRelocStatic:\n+    RM = Reloc::Static;\n+    break;\n+  case LLVMRelocPIC:\n+    RM = Reloc::PIC_;\n+    break;\n+  case LLVMRelocDynamicNoPic:\n+    RM = Reloc::DynamicNoPIC;\n+    break;\n+  default:\n #if LLVM_VERSION_LE(3, 8)\n-            RM = Reloc::Default;\n+    RM = Reloc::Default;\n #endif\n-            break;\n-    }\n+    break;\n+  }\n \n-    std::string Error;\n-    Triple Trip(Triple::normalize(triple));\n-    const llvm::Target *TheTarget = TargetRegistry::lookupTarget(Trip.getTriple(),\n-                                                                 Error);\n-    if (TheTarget == NULL) {\n-        LLVMRustSetLastError(Error.c_str());\n-        return NULL;\n-    }\n+  std::string Error;\n+  Triple Trip(Triple::normalize(triple));\n+  const llvm::Target *TheTarget =\n+      TargetRegistry::lookupTarget(Trip.getTriple(), Error);\n+  if (TheTarget == nullptr) {\n+    LLVMRustSetLastError(Error.c_str());\n+    return nullptr;\n+  }\n \n-    StringRef real_cpu = cpu;\n-    if (real_cpu == \"native\") {\n-        real_cpu = sys::getHostCPUName();\n-    }\n+  StringRef real_cpu = cpu;\n+  if (real_cpu == \"native\") {\n+    real_cpu = sys::getHostCPUName();\n+  }\n \n-    TargetOptions Options;\n+  TargetOptions Options;\n #if LLVM_VERSION_LE(3, 8)\n-    Options.PositionIndependentExecutable = PositionIndependentExecutable;\n+  Options.PositionIndependentExecutable = PositionIndependentExecutable;\n #endif\n \n-    Options.FloatABIType = FloatABI::Default;\n-    if (UseSoftFloat) {\n-        Options.FloatABIType = FloatABI::Soft;\n-    }\n-    Options.DataSections = DataSections;\n-    Options.FunctionSections = FunctionSections;\n-\n-    TargetMachine *TM = TheTarget->createTargetMachine(Trip.getTriple(),\n-                                                       real_cpu,\n-                                                       feature,\n-                                                       Options,\n-                                                       RM,\n-                                                       CM,\n-                                                       OptLevel);\n-    return wrap(TM);\n+  Options.FloatABIType = FloatABI::Default;\n+  if (UseSoftFloat) {\n+    Options.FloatABIType = FloatABI::Soft;\n+  }\n+  Options.DataSections = DataSections;\n+  Options.FunctionSections = FunctionSections;\n+\n+  TargetMachine *TM = TheTarget->createTargetMachine(\n+      Trip.getTriple(), real_cpu, feature, Options, RM, CM, OptLevel);\n+  return wrap(TM);\n }\n \n-extern \"C\" void\n-LLVMRustDisposeTargetMachine(LLVMTargetMachineRef TM) {\n-    delete unwrap(TM);\n+extern \"C\" void LLVMRustDisposeTargetMachine(LLVMTargetMachineRef TM) {\n+  delete unwrap(TM);\n }\n \n // Unfortunately, LLVM doesn't expose a C API to add the corresponding analysis\n // passes for a target to a pass manager. We export that functionality through\n // this function.\n-extern \"C\" void\n-LLVMRustAddAnalysisPasses(LLVMTargetMachineRef TM,\n-                          LLVMPassManagerRef PMR,\n-                          LLVMModuleRef M) {\n-    PassManagerBase *PM = unwrap(PMR);\n-    PM->add(createTargetTransformInfoWrapperPass(\n-          unwrap(TM)->getTargetIRAnalysis()));\n+extern \"C\" void LLVMRustAddAnalysisPasses(LLVMTargetMachineRef TM,\n+                                          LLVMPassManagerRef PMR,\n+                                          LLVMModuleRef M) {\n+  PassManagerBase *PM = unwrap(PMR);\n+  PM->add(\n+      createTargetTransformInfoWrapperPass(unwrap(TM)->getTargetIRAnalysis()));\n }\n \n-extern \"C\" void\n-LLVMRustConfigurePassManagerBuilder(LLVMPassManagerBuilderRef PMB,\n-\t\t\t\t    LLVMRustCodeGenOptLevel OptLevel,\n-                                    bool MergeFunctions,\n-                                    bool SLPVectorize,\n-                                    bool LoopVectorize) {\n-    // Ignore mergefunc for now as enabling it causes crashes.\n-    //unwrap(PMB)->MergeFunctions = MergeFunctions;\n-    unwrap(PMB)->SLPVectorize = SLPVectorize;\n-    unwrap(PMB)->OptLevel = from_rust(OptLevel);\n-    unwrap(PMB)->LoopVectorize = LoopVectorize;\n+extern \"C\" void LLVMRustConfigurePassManagerBuilder(\n+    LLVMPassManagerBuilderRef PMB, LLVMRustCodeGenOptLevel OptLevel,\n+    bool MergeFunctions, bool SLPVectorize, bool LoopVectorize) {\n+  // Ignore mergefunc for now as enabling it causes crashes.\n+  // unwrap(PMB)->MergeFunctions = MergeFunctions;\n+  unwrap(PMB)->SLPVectorize = SLPVectorize;\n+  unwrap(PMB)->OptLevel = from_rust(OptLevel);\n+  unwrap(PMB)->LoopVectorize = LoopVectorize;\n }\n \n // Unfortunately, the LLVM C API doesn't provide a way to set the `LibraryInfo`\n // field of a PassManagerBuilder, we expose our own method of doing so.\n-extern \"C\" void\n-LLVMRustAddBuilderLibraryInfo(LLVMPassManagerBuilderRef PMB,\n-                              LLVMModuleRef M,\n-                              bool DisableSimplifyLibCalls) {\n-    Triple TargetTriple(unwrap(M)->getTargetTriple());\n-    TargetLibraryInfoImpl *TLI = new TargetLibraryInfoImpl(TargetTriple);\n-    if (DisableSimplifyLibCalls)\n-      TLI->disableAllFunctions();\n-    unwrap(PMB)->LibraryInfo = TLI;\n+extern \"C\" void LLVMRustAddBuilderLibraryInfo(LLVMPassManagerBuilderRef PMB,\n+                                              LLVMModuleRef M,\n+                                              bool DisableSimplifyLibCalls) {\n+  Triple TargetTriple(unwrap(M)->getTargetTriple());\n+  TargetLibraryInfoImpl *TLI = new TargetLibraryInfoImpl(TargetTriple);\n+  if (DisableSimplifyLibCalls)\n+    TLI->disableAllFunctions();\n+  unwrap(PMB)->LibraryInfo = TLI;\n }\n \n // Unfortunately, the LLVM C API doesn't provide a way to create the\n // TargetLibraryInfo pass, so we use this method to do so.\n-extern \"C\" void\n-LLVMRustAddLibraryInfo(LLVMPassManagerRef PMB,\n-                       LLVMModuleRef M,\n-                       bool DisableSimplifyLibCalls) {\n-    Triple TargetTriple(unwrap(M)->getTargetTriple());\n-    TargetLibraryInfoImpl TLII(TargetTriple);\n-    if (DisableSimplifyLibCalls)\n-      TLII.disableAllFunctions();\n-    unwrap(PMB)->add(new TargetLibraryInfoWrapperPass(TLII));\n+extern \"C\" void LLVMRustAddLibraryInfo(LLVMPassManagerRef PMB, LLVMModuleRef M,\n+                                       bool DisableSimplifyLibCalls) {\n+  Triple TargetTriple(unwrap(M)->getTargetTriple());\n+  TargetLibraryInfoImpl TLII(TargetTriple);\n+  if (DisableSimplifyLibCalls)\n+    TLII.disableAllFunctions();\n+  unwrap(PMB)->add(new TargetLibraryInfoWrapperPass(TLII));\n }\n \n // Unfortunately, the LLVM C API doesn't provide an easy way of iterating over\n // all the functions in a module, so we do that manually here. You'll find\n // similar code in clang's BackendUtil.cpp file.\n-extern \"C\" void\n-LLVMRustRunFunctionPassManager(LLVMPassManagerRef PM, LLVMModuleRef M) {\n-    llvm::legacy::FunctionPassManager *P = unwrap<llvm::legacy::FunctionPassManager>(PM);\n-    P->doInitialization();\n-\n-    // Upgrade all calls to old intrinsics first.\n-    for (Module::iterator I = unwrap(M)->begin(),\n-         E = unwrap(M)->end(); I != E;)\n-        UpgradeCallsToIntrinsic(&*I++); // must be post-increment, as we remove\n-\n-    for (Module::iterator I = unwrap(M)->begin(),\n-         E = unwrap(M)->end(); I != E; ++I)\n-        if (!I->isDeclaration())\n-            P->run(*I);\n-\n-    P->doFinalization();\n+extern \"C\" void LLVMRustRunFunctionPassManager(LLVMPassManagerRef PM,\n+                                               LLVMModuleRef M) {\n+  llvm::legacy::FunctionPassManager *P =\n+      unwrap<llvm::legacy::FunctionPassManager>(PM);\n+  P->doInitialization();\n+\n+  // Upgrade all calls to old intrinsics first.\n+  for (Module::iterator I = unwrap(M)->begin(), E = unwrap(M)->end(); I != E;)\n+    UpgradeCallsToIntrinsic(&*I++); // must be post-increment, as we remove\n+\n+  for (Module::iterator I = unwrap(M)->begin(), E = unwrap(M)->end(); I != E;\n+       ++I)\n+    if (!I->isDeclaration())\n+      P->run(*I);\n+\n+  P->doFinalization();\n }\n \n-extern \"C\" void\n-LLVMRustSetLLVMOptions(int Argc, char **Argv) {\n-    // Initializing the command-line options more than once is not allowed. So,\n-    // check if they've already been initialized.  (This could happen if we're\n-    // being called from rustpkg, for example). If the arguments change, then\n-    // that's just kinda unfortunate.\n-    static bool initialized = false;\n-    if (initialized) return;\n-    initialized = true;\n-    cl::ParseCommandLineOptions(Argc, Argv);\n+extern \"C\" void LLVMRustSetLLVMOptions(int Argc, char **Argv) {\n+  // Initializing the command-line options more than once is not allowed. So,\n+  // check if they've already been initialized.  (This could happen if we're\n+  // being called from rustpkg, for example). If the arguments change, then\n+  // that's just kinda unfortunate.\n+  static bool initialized = false;\n+  if (initialized)\n+    return;\n+  initialized = true;\n+  cl::ParseCommandLineOptions(Argc, Argv);\n }\n \n enum class LLVMRustFileType {\n-    Other,\n-    AssemblyFile,\n-    ObjectFile,\n+  Other,\n+  AssemblyFile,\n+  ObjectFile,\n };\n \n-static TargetMachine::CodeGenFileType\n-from_rust(LLVMRustFileType type)\n-{\n-    switch (type) {\n-    case LLVMRustFileType::AssemblyFile:\n-        return TargetMachine::CGFT_AssemblyFile;\n-    case LLVMRustFileType::ObjectFile:\n-        return TargetMachine::CGFT_ObjectFile;\n-    default:\n-        llvm_unreachable(\"Bad FileType.\");\n+static TargetMachine::CodeGenFileType from_rust(LLVMRustFileType type) {\n+  switch (type) {\n+  case LLVMRustFileType::AssemblyFile:\n+    return TargetMachine::CGFT_AssemblyFile;\n+  case LLVMRustFileType::ObjectFile:\n+    return TargetMachine::CGFT_ObjectFile;\n+  default:\n+    llvm_unreachable(\"Bad FileType.\");\n   }\n }\n \n extern \"C\" LLVMRustResult\n-LLVMRustWriteOutputFile(LLVMTargetMachineRef Target,\n-                        LLVMPassManagerRef PMR,\n-                        LLVMModuleRef M,\n-                        const char *path,\n+LLVMRustWriteOutputFile(LLVMTargetMachineRef Target, LLVMPassManagerRef PMR,\n+                        LLVMModuleRef M, const char *path,\n                         LLVMRustFileType rust_FileType) {\n   llvm::legacy::PassManager *PM = unwrap<llvm::legacy::PassManager>(PMR);\n   auto FileType = from_rust(rust_FileType);\n@@ -512,10 +476,8 @@ LLVMRustWriteOutputFile(LLVMTargetMachineRef Target,\n   return LLVMRustResult::Success;\n }\n \n-extern \"C\" void\n-LLVMRustPrintModule(LLVMPassManagerRef PMR,\n-                    LLVMModuleRef M,\n-                    const char* path) {\n+extern \"C\" void LLVMRustPrintModule(LLVMPassManagerRef PMR, LLVMModuleRef M,\n+                                    const char *path) {\n   llvm::legacy::PassManager *PM = unwrap<llvm::legacy::PassManager>(PMR);\n   std::string ErrorInfo;\n \n@@ -531,102 +493,96 @@ LLVMRustPrintModule(LLVMPassManagerRef PMR,\n   PM->run(*unwrap(M));\n }\n \n-extern \"C\" void\n-LLVMRustPrintPasses() {\n-    LLVMInitializePasses();\n-    struct MyListener : PassRegistrationListener {\n-        void passEnumerate(const PassInfo *info) {\n+extern \"C\" void LLVMRustPrintPasses() {\n+  LLVMInitializePasses();\n+  struct MyListener : PassRegistrationListener {\n+    void passEnumerate(const PassInfo *info) {\n #if LLVM_VERSION_GE(4, 0)\n-            StringRef PassArg = info->getPassArgument();\n-            StringRef PassName = info->getPassName();\n-            if (!PassArg.empty()) {\n-                // These unsigned->signed casts could theoretically overflow, but\n-                // realistically never will (and even if, the result is implementation\n-                // defined rather plain UB).\n-                printf(\"%15.*s - %.*s\\n\", (int)PassArg.size(), PassArg.data(),\n-                       (int)PassName.size(), PassName.data());\n-            }\n+      StringRef PassArg = info->getPassArgument();\n+      StringRef PassName = info->getPassName();\n+      if (!PassArg.empty()) {\n+        // These unsigned->signed casts could theoretically overflow, but\n+        // realistically never will (and even if, the result is implementation\n+        // defined rather plain UB).\n+        printf(\"%15.*s - %.*s\\n\", (int)PassArg.size(), PassArg.data(),\n+               (int)PassName.size(), PassName.data());\n+      }\n #else\n-            if (info->getPassArgument() && *info->getPassArgument()) {\n-                printf(\"%15s - %s\\n\", info->getPassArgument(),\n-                       info->getPassName());\n-            }\n+      if (info->getPassArgument() && *info->getPassArgument()) {\n+        printf(\"%15s - %s\\n\", info->getPassArgument(), info->getPassName());\n+      }\n #endif\n-        }\n-    } listener;\n+    }\n+  } listener;\n \n-    PassRegistry *PR = PassRegistry::getPassRegistry();\n-    PR->enumerateWith(&listener);\n+  PassRegistry *PR = PassRegistry::getPassRegistry();\n+  PR->enumerateWith(&listener);\n }\n \n-extern \"C\" void\n-LLVMRustAddAlwaysInlinePass(LLVMPassManagerBuilderRef PMB, bool AddLifetimes) {\n+extern \"C\" void LLVMRustAddAlwaysInlinePass(LLVMPassManagerBuilderRef PMB,\n+                                            bool AddLifetimes) {\n #if LLVM_VERSION_GE(4, 0)\n-    unwrap(PMB)->Inliner = llvm::createAlwaysInlinerLegacyPass(AddLifetimes);\n+  unwrap(PMB)->Inliner = llvm::createAlwaysInlinerLegacyPass(AddLifetimes);\n #else\n-    unwrap(PMB)->Inliner = createAlwaysInlinerPass(AddLifetimes);\n+  unwrap(PMB)->Inliner = createAlwaysInlinerPass(AddLifetimes);\n #endif\n }\n \n-extern \"C\" void\n-LLVMRustRunRestrictionPass(LLVMModuleRef M, char **symbols, size_t len) {\n-    llvm::legacy::PassManager passes;\n+extern \"C\" void LLVMRustRunRestrictionPass(LLVMModuleRef M, char **symbols,\n+                                           size_t len) {\n+  llvm::legacy::PassManager passes;\n \n #if LLVM_VERSION_LE(3, 8)\n-    ArrayRef<const char*> ref(symbols, len);\n-    passes.add(llvm::createInternalizePass(ref));\n+  ArrayRef<const char *> ref(symbols, len);\n+  passes.add(llvm::createInternalizePass(ref));\n #else\n-    auto PreserveFunctions = [=](const GlobalValue &GV) {\n-        for (size_t i=0; i<len; i++) {\n-            if (GV.getName() == symbols[i]) {\n-                return true;\n-            }\n-        }\n-        return false;\n-    };\n+  auto PreserveFunctions = [=](const GlobalValue &GV) {\n+    for (size_t i = 0; i < len; i++) {\n+      if (GV.getName() == symbols[i]) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  };\n \n-    passes.add(llvm::createInternalizePass(PreserveFunctions));\n+  passes.add(llvm::createInternalizePass(PreserveFunctions));\n #endif\n \n-    passes.run(*unwrap(M));\n+  passes.run(*unwrap(M));\n }\n \n-extern \"C\" void\n-LLVMRustMarkAllFunctionsNounwind(LLVMModuleRef M) {\n-    for (Module::iterator GV = unwrap(M)->begin(),\n-         E = unwrap(M)->end(); GV != E; ++GV) {\n-        GV->setDoesNotThrow();\n-        Function *F = dyn_cast<Function>(GV);\n-        if (F == NULL)\n-            continue;\n-\n-        for (Function::iterator B = F->begin(), BE = F->end(); B != BE; ++B) {\n-            for (BasicBlock::iterator I = B->begin(), IE = B->end();\n-                 I != IE; ++I) {\n-                if (isa<InvokeInst>(I)) {\n-                    InvokeInst *CI = cast<InvokeInst>(I);\n-                    CI->setDoesNotThrow();\n-                }\n-            }\n+extern \"C\" void LLVMRustMarkAllFunctionsNounwind(LLVMModuleRef M) {\n+  for (Module::iterator GV = unwrap(M)->begin(), E = unwrap(M)->end(); GV != E;\n+       ++GV) {\n+    GV->setDoesNotThrow();\n+    Function *F = dyn_cast<Function>(GV);\n+    if (F == nullptr)\n+      continue;\n+\n+    for (Function::iterator B = F->begin(), BE = F->end(); B != BE; ++B) {\n+      for (BasicBlock::iterator I = B->begin(), IE = B->end(); I != IE; ++I) {\n+        if (isa<InvokeInst>(I)) {\n+          InvokeInst *CI = cast<InvokeInst>(I);\n+          CI->setDoesNotThrow();\n         }\n+      }\n     }\n+  }\n }\n \n extern \"C\" void\n LLVMRustSetDataLayoutFromTargetMachine(LLVMModuleRef Module,\n                                        LLVMTargetMachineRef TMR) {\n-    TargetMachine *Target = unwrap(TMR);\n-    unwrap(Module)->setDataLayout(Target->createDataLayout());\n+  TargetMachine *Target = unwrap(TMR);\n+  unwrap(Module)->setDataLayout(Target->createDataLayout());\n }\n \n-extern \"C\" LLVMTargetDataRef\n-LLVMRustGetModuleDataLayout(LLVMModuleRef M) {\n-    return wrap(&unwrap(M)->getDataLayout());\n+extern \"C\" LLVMTargetDataRef LLVMRustGetModuleDataLayout(LLVMModuleRef M) {\n+  return wrap(&unwrap(M)->getDataLayout());\n }\n \n-extern \"C\" void\n-LLVMRustSetModulePIELevel(LLVMModuleRef M) {\n+extern \"C\" void LLVMRustSetModulePIELevel(LLVMModuleRef M) {\n #if LLVM_VERSION_GE(3, 9)\n-    unwrap(M)->setPIELevel(PIELevel::Level::Large);\n+  unwrap(M)->setPIELevel(PIELevel::Level::Large);\n #endif\n }"}, {"sha": "e87d2b53995b9f28ea6fa8d8fa6737a97c80b1d3", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 810, "deletions": 1004, "changes": 1814, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -9,11 +9,11 @@\n // except according to those terms.\n \n #include \"rustllvm.h\"\n-#include \"llvm/Object/Archive.h\"\n-#include \"llvm/Object/ObjectFile.h\"\n #include \"llvm/IR/DiagnosticInfo.h\"\n #include \"llvm/IR/DiagnosticPrinter.h\"\n #include \"llvm/IR/Instructions.h\"\n+#include \"llvm/Object/Archive.h\"\n+#include \"llvm/Object/ObjectFile.h\"\n \n #include \"llvm/IR/CallSite.h\"\n \n@@ -32,269 +32,246 @@ using namespace llvm::object;\n // one.\n static AtomicOrdering from_rust(LLVMAtomicOrdering Ordering) {\n   switch (Ordering) {\n-    case LLVMAtomicOrderingNotAtomic:\n-        return AtomicOrdering::NotAtomic;\n-    case LLVMAtomicOrderingUnordered:\n-        return AtomicOrdering::Unordered;\n-    case LLVMAtomicOrderingMonotonic:\n-        return AtomicOrdering::Monotonic;\n-    case LLVMAtomicOrderingAcquire:\n-        return AtomicOrdering::Acquire;\n-    case LLVMAtomicOrderingRelease:\n-        return AtomicOrdering::Release;\n-    case LLVMAtomicOrderingAcquireRelease:\n-        return AtomicOrdering::AcquireRelease;\n-    case LLVMAtomicOrderingSequentiallyConsistent:\n-        return AtomicOrdering::SequentiallyConsistent;\n+  case LLVMAtomicOrderingNotAtomic:\n+    return AtomicOrdering::NotAtomic;\n+  case LLVMAtomicOrderingUnordered:\n+    return AtomicOrdering::Unordered;\n+  case LLVMAtomicOrderingMonotonic:\n+    return AtomicOrdering::Monotonic;\n+  case LLVMAtomicOrderingAcquire:\n+    return AtomicOrdering::Acquire;\n+  case LLVMAtomicOrderingRelease:\n+    return AtomicOrdering::Release;\n+  case LLVMAtomicOrderingAcquireRelease:\n+    return AtomicOrdering::AcquireRelease;\n+  case LLVMAtomicOrderingSequentiallyConsistent:\n+    return AtomicOrdering::SequentiallyConsistent;\n   }\n \n   llvm_unreachable(\"Invalid LLVMAtomicOrdering value!\");\n }\n \n-\n static char *LastError;\n \n extern \"C\" LLVMMemoryBufferRef\n LLVMRustCreateMemoryBufferWithContentsOfFile(const char *Path) {\n-  ErrorOr<std::unique_ptr<MemoryBuffer>> buf_or = MemoryBuffer::getFile(Path,\n-                                                                        -1,\n-                                                                        false);\n+  ErrorOr<std::unique_ptr<MemoryBuffer>> buf_or =\n+      MemoryBuffer::getFile(Path, -1, false);\n   if (!buf_or) {\n-      LLVMRustSetLastError(buf_or.getError().message().c_str());\n-      return nullptr;\n+    LLVMRustSetLastError(buf_or.getError().message().c_str());\n+    return nullptr;\n   }\n   return wrap(buf_or.get().release());\n }\n \n extern \"C\" char *LLVMRustGetLastError(void) {\n   char *ret = LastError;\n-  LastError = NULL;\n+  LastError = nullptr;\n   return ret;\n }\n \n void LLVMRustSetLastError(const char *err) {\n-  free((void*) LastError);\n+  free((void *)LastError);\n   LastError = strdup(err);\n }\n \n-extern \"C\" void\n-LLVMRustSetNormalizedTarget(LLVMModuleRef M, const char *triple) {\n-    unwrap(M)->setTargetTriple(Triple::normalize(triple));\n+extern \"C\" void LLVMRustSetNormalizedTarget(LLVMModuleRef M,\n+                                            const char *triple) {\n+  unwrap(M)->setTargetTriple(Triple::normalize(triple));\n }\n \n extern \"C\" void LLVMRustPrintPassTimings() {\n-  raw_fd_ostream OS (2, false); // stderr.\n+  raw_fd_ostream OS(2, false); // stderr.\n   TimerGroup::printAll(OS);\n }\n \n extern \"C\" LLVMValueRef LLVMRustGetNamedValue(LLVMModuleRef M,\n-\t\t\t\t\t      const char* Name) {\n-    return wrap(unwrap(M)->getNamedValue(Name));\n+                                              const char *Name) {\n+  return wrap(unwrap(M)->getNamedValue(Name));\n }\n \n extern \"C\" LLVMValueRef LLVMRustGetOrInsertFunction(LLVMModuleRef M,\n-\t\t\t\t\t\t    const char* Name,\n-\t\t\t\t\t\t    LLVMTypeRef FunctionTy) {\n-  return wrap(unwrap(M)->getOrInsertFunction(Name,\n-                                             unwrap<FunctionType>(FunctionTy)));\n+                                                    const char *Name,\n+                                                    LLVMTypeRef FunctionTy) {\n+  return wrap(\n+      unwrap(M)->getOrInsertFunction(Name, unwrap<FunctionType>(FunctionTy)));\n }\n \n-extern \"C\" LLVMValueRef LLVMRustGetOrInsertGlobal(LLVMModuleRef M,\n-\t\t\t\t\t\t  const char* Name,\n-\t\t\t\t\t\t  LLVMTypeRef Ty) {\n+extern \"C\" LLVMValueRef\n+LLVMRustGetOrInsertGlobal(LLVMModuleRef M, const char *Name, LLVMTypeRef Ty) {\n   return wrap(unwrap(M)->getOrInsertGlobal(Name, unwrap(Ty)));\n }\n \n extern \"C\" LLVMTypeRef LLVMRustMetadataTypeInContext(LLVMContextRef C) {\n   return wrap(Type::getMetadataTy(*unwrap(C)));\n }\n \n-static Attribute::AttrKind\n-from_rust(LLVMRustAttribute kind) {\n+static Attribute::AttrKind from_rust(LLVMRustAttribute kind) {\n   switch (kind) {\n-    case AlwaysInline:\n-      return Attribute::AlwaysInline;\n-    case ByVal:\n-      return Attribute::ByVal;\n-    case Cold:\n-      return Attribute::Cold;\n-    case InlineHint:\n-      return Attribute::InlineHint;\n-    case MinSize:\n-      return Attribute::MinSize;\n-    case Naked:\n-      return Attribute::Naked;\n-    case NoAlias:\n-      return Attribute::NoAlias;\n-    case NoCapture:\n-      return Attribute::NoCapture;\n-    case NoInline:\n-      return Attribute::NoInline;\n-    case NonNull:\n-      return Attribute::NonNull;\n-    case NoRedZone:\n-      return Attribute::NoRedZone;\n-    case NoReturn:\n-      return Attribute::NoReturn;\n-    case NoUnwind:\n-      return Attribute::NoUnwind;\n-    case OptimizeForSize:\n-      return Attribute::OptimizeForSize;\n-    case ReadOnly:\n-      return Attribute::ReadOnly;\n-    case SExt:\n-      return Attribute::SExt;\n-    case StructRet:\n-      return Attribute::StructRet;\n-    case UWTable:\n-      return Attribute::UWTable;\n-    case ZExt:\n-      return Attribute::ZExt;\n-    case InReg:\n-      return Attribute::InReg;\n-    default:\n-      llvm_unreachable(\"bad AttributeKind\");\n+  case AlwaysInline:\n+    return Attribute::AlwaysInline;\n+  case ByVal:\n+    return Attribute::ByVal;\n+  case Cold:\n+    return Attribute::Cold;\n+  case InlineHint:\n+    return Attribute::InlineHint;\n+  case MinSize:\n+    return Attribute::MinSize;\n+  case Naked:\n+    return Attribute::Naked;\n+  case NoAlias:\n+    return Attribute::NoAlias;\n+  case NoCapture:\n+    return Attribute::NoCapture;\n+  case NoInline:\n+    return Attribute::NoInline;\n+  case NonNull:\n+    return Attribute::NonNull;\n+  case NoRedZone:\n+    return Attribute::NoRedZone;\n+  case NoReturn:\n+    return Attribute::NoReturn;\n+  case NoUnwind:\n+    return Attribute::NoUnwind;\n+  case OptimizeForSize:\n+    return Attribute::OptimizeForSize;\n+  case ReadOnly:\n+    return Attribute::ReadOnly;\n+  case SExt:\n+    return Attribute::SExt;\n+  case StructRet:\n+    return Attribute::StructRet;\n+  case UWTable:\n+    return Attribute::UWTable;\n+  case ZExt:\n+    return Attribute::ZExt;\n+  case InReg:\n+    return Attribute::InReg;\n+  default:\n+    llvm_unreachable(\"bad AttributeKind\");\n   }\n }\n \n-extern \"C\" void LLVMRustAddCallSiteAttribute(LLVMValueRef Instr, unsigned index, LLVMRustAttribute attr) {\n+extern \"C\" void LLVMRustAddCallSiteAttribute(LLVMValueRef Instr, unsigned index,\n+                                             LLVMRustAttribute attr) {\n   CallSite Call = CallSite(unwrap<Instruction>(Instr));\n   Attribute Attr = Attribute::get(Call->getContext(), from_rust(attr));\n   AttrBuilder B(Attr);\n-  Call.setAttributes(\n-    Call.getAttributes().addAttributes(Call->getContext(), index,\n-                                       AttributeSet::get(Call->getContext(),\n-                                                         index, B)));\n+  Call.setAttributes(Call.getAttributes().addAttributes(\n+      Call->getContext(), index,\n+      AttributeSet::get(Call->getContext(), index, B)));\n }\n \n extern \"C\" void LLVMRustAddDereferenceableCallSiteAttr(LLVMValueRef Instr,\n-                                                      unsigned index,\n-                                                      uint64_t bytes)\n-{\n+                                                       unsigned index,\n+                                                       uint64_t bytes) {\n   CallSite Call = CallSite(unwrap<Instruction>(Instr));\n   AttrBuilder B;\n   B.addDereferenceableAttr(bytes);\n-  Call.setAttributes(\n-    Call.getAttributes().addAttributes(Call->getContext(), index,\n-                                       AttributeSet::get(Call->getContext(),\n-                                                         index, B)));\n+  Call.setAttributes(Call.getAttributes().addAttributes(\n+      Call->getContext(), index,\n+      AttributeSet::get(Call->getContext(), index, B)));\n }\n \n-extern \"C\" void LLVMRustAddFunctionAttribute(LLVMValueRef Fn,\n-\t\t\t\t\t     unsigned index,\n-\t\t\t\t\t     LLVMRustAttribute attr)\n-{\n+extern \"C\" void LLVMRustAddFunctionAttribute(LLVMValueRef Fn, unsigned index,\n+                                             LLVMRustAttribute attr) {\n   Function *A = unwrap<Function>(Fn);\n   Attribute Attr = Attribute::get(A->getContext(), from_rust(attr));\n   AttrBuilder B(Attr);\n   A->addAttributes(index, AttributeSet::get(A->getContext(), index, B));\n }\n \n-extern \"C\" void LLVMRustAddDereferenceableAttr(LLVMValueRef Fn,\n-\t\t\t\t\t       unsigned index,\n-\t\t\t\t\t       uint64_t bytes)\n-{\n+extern \"C\" void LLVMRustAddDereferenceableAttr(LLVMValueRef Fn, unsigned index,\n+                                               uint64_t bytes) {\n   Function *A = unwrap<Function>(Fn);\n   AttrBuilder B;\n   B.addDereferenceableAttr(bytes);\n   A->addAttributes(index, AttributeSet::get(A->getContext(), index, B));\n }\n \n extern \"C\" void LLVMRustAddFunctionAttrStringValue(LLVMValueRef Fn,\n-\t\t\t\t\t\t   unsigned index,\n-\t\t\t\t\t\t   const char *Name,\n-\t\t\t\t\t\t   const char *Value) {\n+                                                   unsigned index,\n+                                                   const char *Name,\n+                                                   const char *Value) {\n   Function *F = unwrap<Function>(Fn);\n   AttrBuilder B;\n   B.addAttribute(Name, Value);\n   F->addAttributes(index, AttributeSet::get(F->getContext(), index, B));\n }\n \n extern \"C\" void LLVMRustRemoveFunctionAttributes(LLVMValueRef Fn,\n-\t\t\t\t\t\t unsigned index,\n-\t\t\t\t\t\t LLVMRustAttribute attr)\n-{\n+                                                 unsigned index,\n+                                                 LLVMRustAttribute attr) {\n   Function *F = unwrap<Function>(Fn);\n   const AttributeSet PAL = F->getAttributes();\n   Attribute Attr = Attribute::get(F->getContext(), from_rust(attr));\n   AttrBuilder B(Attr);\n-  const AttributeSet PALnew =\n-    PAL.removeAttributes(F->getContext(), index,\n-                         AttributeSet::get(F->getContext(), index, B));\n+  const AttributeSet PALnew = PAL.removeAttributes(\n+      F->getContext(), index, AttributeSet::get(F->getContext(), index, B));\n   F->setAttributes(PALnew);\n }\n \n // enable fpmath flag UnsafeAlgebra\n extern \"C\" void LLVMRustSetHasUnsafeAlgebra(LLVMValueRef V) {\n-    if (auto I = dyn_cast<Instruction>(unwrap<Value>(V))) {\n-        I->setHasUnsafeAlgebra(true);\n-    }\n+  if (auto I = dyn_cast<Instruction>(unwrap<Value>(V))) {\n+    I->setHasUnsafeAlgebra(true);\n+  }\n }\n \n-extern \"C\" LLVMValueRef LLVMRustBuildAtomicLoad(LLVMBuilderRef B,\n-\t\t\t\t\t\tLLVMValueRef source,\n-\t\t\t\t\t\tconst char* Name,\n-\t\t\t\t\t\tLLVMAtomicOrdering order,\n-\t\t\t\t\t\tunsigned alignment) {\n-    LoadInst* li = new LoadInst(unwrap(source),0);\n-    li->setAtomic(from_rust(order));\n-    li->setAlignment(alignment);\n-    return wrap(unwrap(B)->Insert(li, Name));\n+extern \"C\" LLVMValueRef\n+LLVMRustBuildAtomicLoad(LLVMBuilderRef B, LLVMValueRef source, const char *Name,\n+                        LLVMAtomicOrdering order, unsigned alignment) {\n+  LoadInst *li = new LoadInst(unwrap(source), 0);\n+  li->setAtomic(from_rust(order));\n+  li->setAlignment(alignment);\n+  return wrap(unwrap(B)->Insert(li, Name));\n }\n \n extern \"C\" LLVMValueRef LLVMRustBuildAtomicStore(LLVMBuilderRef B,\n-\t\t\t\t\t\t LLVMValueRef val,\n-\t\t\t\t\t\t LLVMValueRef target,\n-\t\t\t\t\t\t LLVMAtomicOrdering order,\n-\t\t\t\t\t\t unsigned alignment) {\n-    StoreInst* si = new StoreInst(unwrap(val),unwrap(target));\n-    si->setAtomic(from_rust(order));\n-    si->setAlignment(alignment);\n-    return wrap(unwrap(B)->Insert(si));\n-}\n-\n-extern \"C\" LLVMValueRef LLVMRustBuildAtomicCmpXchg(LLVMBuilderRef B,\n-                                               LLVMValueRef target,\n-                                               LLVMValueRef old,\n-                                               LLVMValueRef source,\n-                                               LLVMAtomicOrdering order,\n-                                               LLVMAtomicOrdering failure_order,\n-                                               LLVMBool weak) {\n-    AtomicCmpXchgInst* acxi = unwrap(B)->CreateAtomicCmpXchg(\n-        unwrap(target),\n-        unwrap(old),\n-        unwrap(source),\n-        from_rust(order),\n-\tfrom_rust(failure_order));\n-    acxi->setWeak(weak);\n-    return wrap(acxi);\n+                                                 LLVMValueRef val,\n+                                                 LLVMValueRef target,\n+                                                 LLVMAtomicOrdering order,\n+                                                 unsigned alignment) {\n+  StoreInst *si = new StoreInst(unwrap(val), unwrap(target));\n+  si->setAtomic(from_rust(order));\n+  si->setAlignment(alignment);\n+  return wrap(unwrap(B)->Insert(si));\n+}\n+\n+extern \"C\" LLVMValueRef\n+LLVMRustBuildAtomicCmpXchg(LLVMBuilderRef B, LLVMValueRef target,\n+                           LLVMValueRef old, LLVMValueRef source,\n+                           LLVMAtomicOrdering order,\n+                           LLVMAtomicOrdering failure_order, LLVMBool weak) {\n+  AtomicCmpXchgInst *acxi = unwrap(B)->CreateAtomicCmpXchg(\n+      unwrap(target), unwrap(old), unwrap(source), from_rust(order),\n+      from_rust(failure_order));\n+  acxi->setWeak(weak);\n+  return wrap(acxi);\n }\n \n enum class LLVMRustSynchronizationScope {\n-    Other,\n-    SingleThread,\n-    CrossThread,\n+  Other,\n+  SingleThread,\n+  CrossThread,\n };\n \n-static SynchronizationScope\n-from_rust(LLVMRustSynchronizationScope scope)\n-{\n-    switch (scope) {\n-    case LLVMRustSynchronizationScope::SingleThread:\n-        return SingleThread;\n-    case LLVMRustSynchronizationScope::CrossThread:\n-        return CrossThread;\n-    default:\n-        llvm_unreachable(\"bad SynchronizationScope.\");\n-    }\n+static SynchronizationScope from_rust(LLVMRustSynchronizationScope scope) {\n+  switch (scope) {\n+  case LLVMRustSynchronizationScope::SingleThread:\n+    return SingleThread;\n+  case LLVMRustSynchronizationScope::CrossThread:\n+    return CrossThread;\n+  default:\n+    llvm_unreachable(\"bad SynchronizationScope.\");\n+  }\n }\n \n-extern \"C\" LLVMValueRef LLVMRustBuildAtomicFence(\n-    LLVMBuilderRef B,\n-    LLVMAtomicOrdering order,\n-    LLVMRustSynchronizationScope scope)\n-{\n-    return wrap(unwrap(B)->CreateFence(from_rust(order), from_rust(scope)));\n+extern \"C\" LLVMValueRef\n+LLVMRustBuildAtomicFence(LLVMBuilderRef B, LLVMAtomicOrdering order,\n+                         LLVMRustSynchronizationScope scope) {\n+  return wrap(unwrap(B)->CreateFence(from_rust(order), from_rust(scope)));\n }\n \n extern \"C\" void LLVMRustSetDebug(int Enabled) {\n@@ -304,50 +281,45 @@ extern \"C\" void LLVMRustSetDebug(int Enabled) {\n }\n \n enum class LLVMRustAsmDialect {\n-    Other,\n-    Att,\n-    Intel,\n+  Other,\n+  Att,\n+  Intel,\n };\n \n-static InlineAsm::AsmDialect\n-from_rust(LLVMRustAsmDialect dialect)\n-{\n-    switch (dialect) {\n-    case LLVMRustAsmDialect::Att:\n-        return InlineAsm::AD_ATT;\n-    case LLVMRustAsmDialect::Intel:\n-        return InlineAsm::AD_Intel;\n-    default:\n-        llvm_unreachable(\"bad AsmDialect.\");\n-    }\n+static InlineAsm::AsmDialect from_rust(LLVMRustAsmDialect dialect) {\n+  switch (dialect) {\n+  case LLVMRustAsmDialect::Att:\n+    return InlineAsm::AD_ATT;\n+  case LLVMRustAsmDialect::Intel:\n+    return InlineAsm::AD_Intel;\n+  default:\n+    llvm_unreachable(\"bad AsmDialect.\");\n+  }\n }\n \n-extern \"C\" LLVMValueRef LLVMRustInlineAsm(LLVMTypeRef Ty,\n-\t\t\t\t\t  char *AsmString,\n-\t\t\t\t\t  char *Constraints,\n-\t\t\t\t\t  LLVMBool HasSideEffects,\n-\t\t\t\t\t  LLVMBool IsAlignStack,\n-\t\t\t\t\t  LLVMRustAsmDialect Dialect) {\n-    return wrap(InlineAsm::get(unwrap<FunctionType>(Ty), AsmString,\n-                               Constraints, HasSideEffects,\n-                               IsAlignStack, from_rust(Dialect)));\n+extern \"C\" LLVMValueRef LLVMRustInlineAsm(LLVMTypeRef Ty, char *AsmString,\n+                                          char *Constraints,\n+                                          LLVMBool HasSideEffects,\n+                                          LLVMBool IsAlignStack,\n+                                          LLVMRustAsmDialect Dialect) {\n+  return wrap(InlineAsm::get(unwrap<FunctionType>(Ty), AsmString, Constraints,\n+                             HasSideEffects, IsAlignStack, from_rust(Dialect)));\n }\n \n-typedef DIBuilder* LLVMRustDIBuilderRef;\n+typedef DIBuilder *LLVMRustDIBuilderRef;\n \n typedef struct LLVMOpaqueMetadata *LLVMRustMetadataRef;\n \n namespace llvm {\n DEFINE_ISA_CONVERSION_FUNCTIONS(Metadata, LLVMRustMetadataRef)\n \n inline Metadata **unwrap(LLVMRustMetadataRef *Vals) {\n-  return reinterpret_cast<Metadata**>(Vals);\n+  return reinterpret_cast<Metadata **>(Vals);\n }\n }\n \n-template<typename DIT>\n-DIT* unwrapDIptr(LLVMRustMetadataRef ref) {\n-    return (DIT*) (ref ? unwrap<MDNode>(ref) : NULL);\n+template <typename DIT> DIT *unwrapDIptr(LLVMRustMetadataRef ref) {\n+  return (DIT *)(ref ? unwrap<MDNode>(ref) : nullptr);\n }\n \n #define DIDescriptor DIScope\n@@ -358,614 +330,482 @@ DIT* unwrapDIptr(LLVMRustMetadataRef ref) {\n // to match LLVM, but that isn't required as we do giant sets of\n // matching below. The value shouldn't be directly passed to LLVM.\n enum class LLVMRustDIFlags : uint32_t {\n-    FlagZero                = 0,\n-    FlagPrivate             = 1,\n-    FlagProtected           = 2,\n-    FlagPublic              = 3,\n-    FlagFwdDecl             = (1 << 2),\n-    FlagAppleBlock          = (1 << 3),\n-    FlagBlockByrefStruct    = (1 << 4),\n-    FlagVirtual             = (1 << 5),\n-    FlagArtificial          = (1 << 6),\n-    FlagExplicit            = (1 << 7),\n-    FlagPrototyped          = (1 << 8),\n-    FlagObjcClassComplete   = (1 << 9),\n-    FlagObjectPointer       = (1 << 10),\n-    FlagVector              = (1 << 11),\n-    FlagStaticMember        = (1 << 12),\n-    FlagLValueReference     = (1 << 13),\n-    FlagRValueReference     = (1 << 14),\n-    // Do not add values that are not supported by the minimum LLVM\n-    // version we support!\n+  FlagZero = 0,\n+  FlagPrivate = 1,\n+  FlagProtected = 2,\n+  FlagPublic = 3,\n+  FlagFwdDecl = (1 << 2),\n+  FlagAppleBlock = (1 << 3),\n+  FlagBlockByrefStruct = (1 << 4),\n+  FlagVirtual = (1 << 5),\n+  FlagArtificial = (1 << 6),\n+  FlagExplicit = (1 << 7),\n+  FlagPrototyped = (1 << 8),\n+  FlagObjcClassComplete = (1 << 9),\n+  FlagObjectPointer = (1 << 10),\n+  FlagVector = (1 << 11),\n+  FlagStaticMember = (1 << 12),\n+  FlagLValueReference = (1 << 13),\n+  FlagRValueReference = (1 << 14),\n+  // Do not add values that are not supported by the minimum LLVM\n+  // version we support!\n };\n \n-inline LLVMRustDIFlags operator& (LLVMRustDIFlags a, LLVMRustDIFlags b) {\n-    return static_cast<LLVMRustDIFlags>(static_cast<uint32_t>(a) & static_cast<uint32_t>(b));\n+inline LLVMRustDIFlags operator&(LLVMRustDIFlags a, LLVMRustDIFlags b) {\n+  return static_cast<LLVMRustDIFlags>(static_cast<uint32_t>(a) &\n+                                      static_cast<uint32_t>(b));\n }\n \n-inline LLVMRustDIFlags operator| (LLVMRustDIFlags a, LLVMRustDIFlags b) {\n-    return static_cast<LLVMRustDIFlags>(static_cast<uint32_t>(a) | static_cast<uint32_t>(b));\n+inline LLVMRustDIFlags operator|(LLVMRustDIFlags a, LLVMRustDIFlags b) {\n+  return static_cast<LLVMRustDIFlags>(static_cast<uint32_t>(a) |\n+                                      static_cast<uint32_t>(b));\n }\n \n-inline LLVMRustDIFlags& operator|= (LLVMRustDIFlags& a, LLVMRustDIFlags b) {\n-    return a = a | b;\n+inline LLVMRustDIFlags &operator|=(LLVMRustDIFlags &a, LLVMRustDIFlags b) {\n+  return a = a | b;\n }\n \n-inline bool is_set(LLVMRustDIFlags f) {\n-    return f != LLVMRustDIFlags::FlagZero;\n-}\n+inline bool is_set(LLVMRustDIFlags f) { return f != LLVMRustDIFlags::FlagZero; }\n \n inline LLVMRustDIFlags visibility(LLVMRustDIFlags f) {\n-    return static_cast<LLVMRustDIFlags>(static_cast<uint32_t>(f) & 0x3);\n+  return static_cast<LLVMRustDIFlags>(static_cast<uint32_t>(f) & 0x3);\n }\n \n #if LLVM_VERSION_GE(4, 0)\n static DINode::DIFlags from_rust(LLVMRustDIFlags flags) {\n-    DINode::DIFlags result = DINode::DIFlags::FlagZero;\n+  DINode::DIFlags result = DINode::DIFlags::FlagZero;\n #else\n static unsigned from_rust(LLVMRustDIFlags flags) {\n-    unsigned result = 0;\n+  unsigned result = 0;\n #endif\n \n-    switch (visibility(flags)) {\n-    case LLVMRustDIFlags::FlagPrivate:\n-        result |= DINode::DIFlags::FlagPrivate;\n-        break;\n-    case LLVMRustDIFlags::FlagProtected:\n-        result |= DINode::DIFlags::FlagProtected;\n-        break;\n-    case LLVMRustDIFlags::FlagPublic:\n-        result |= DINode::DIFlags::FlagPublic;\n-        break;\n-    default:\n-        // The rest are handled below\n-        break;\n-    }\n+  switch (visibility(flags)) {\n+  case LLVMRustDIFlags::FlagPrivate:\n+    result |= DINode::DIFlags::FlagPrivate;\n+    break;\n+  case LLVMRustDIFlags::FlagProtected:\n+    result |= DINode::DIFlags::FlagProtected;\n+    break;\n+  case LLVMRustDIFlags::FlagPublic:\n+    result |= DINode::DIFlags::FlagPublic;\n+    break;\n+  default:\n+    // The rest are handled below\n+    break;\n+  }\n \n-    if (is_set(flags & LLVMRustDIFlags::FlagFwdDecl))             { result |= DINode::DIFlags::FlagFwdDecl; }\n-    if (is_set(flags & LLVMRustDIFlags::FlagAppleBlock))          { result |= DINode::DIFlags::FlagAppleBlock; }\n-    if (is_set(flags & LLVMRustDIFlags::FlagBlockByrefStruct))    { result |= DINode::DIFlags::FlagBlockByrefStruct; }\n-    if (is_set(flags & LLVMRustDIFlags::FlagVirtual))             { result |= DINode::DIFlags::FlagVirtual; }\n-    if (is_set(flags & LLVMRustDIFlags::FlagArtificial))          { result |= DINode::DIFlags::FlagArtificial; }\n-    if (is_set(flags & LLVMRustDIFlags::FlagExplicit))            { result |= DINode::DIFlags::FlagExplicit; }\n-    if (is_set(flags & LLVMRustDIFlags::FlagPrototyped))          { result |= DINode::DIFlags::FlagPrototyped; }\n-    if (is_set(flags & LLVMRustDIFlags::FlagObjcClassComplete))   { result |= DINode::DIFlags::FlagObjcClassComplete; }\n-    if (is_set(flags & LLVMRustDIFlags::FlagObjectPointer))       { result |= DINode::DIFlags::FlagObjectPointer; }\n-    if (is_set(flags & LLVMRustDIFlags::FlagVector))              { result |= DINode::DIFlags::FlagVector; }\n-    if (is_set(flags & LLVMRustDIFlags::FlagStaticMember))        { result |= DINode::DIFlags::FlagStaticMember; }\n-    if (is_set(flags & LLVMRustDIFlags::FlagLValueReference))     { result |= DINode::DIFlags::FlagLValueReference; }\n-    if (is_set(flags & LLVMRustDIFlags::FlagRValueReference))     { result |= DINode::DIFlags::FlagRValueReference; }\n+  if (is_set(flags & LLVMRustDIFlags::FlagFwdDecl)) {\n+    result |= DINode::DIFlags::FlagFwdDecl;\n+  }\n+  if (is_set(flags & LLVMRustDIFlags::FlagAppleBlock)) {\n+    result |= DINode::DIFlags::FlagAppleBlock;\n+  }\n+  if (is_set(flags & LLVMRustDIFlags::FlagBlockByrefStruct)) {\n+    result |= DINode::DIFlags::FlagBlockByrefStruct;\n+  }\n+  if (is_set(flags & LLVMRustDIFlags::FlagVirtual)) {\n+    result |= DINode::DIFlags::FlagVirtual;\n+  }\n+  if (is_set(flags & LLVMRustDIFlags::FlagArtificial)) {\n+    result |= DINode::DIFlags::FlagArtificial;\n+  }\n+  if (is_set(flags & LLVMRustDIFlags::FlagExplicit)) {\n+    result |= DINode::DIFlags::FlagExplicit;\n+  }\n+  if (is_set(flags & LLVMRustDIFlags::FlagPrototyped)) {\n+    result |= DINode::DIFlags::FlagPrototyped;\n+  }\n+  if (is_set(flags & LLVMRustDIFlags::FlagObjcClassComplete)) {\n+    result |= DINode::DIFlags::FlagObjcClassComplete;\n+  }\n+  if (is_set(flags & LLVMRustDIFlags::FlagObjectPointer)) {\n+    result |= DINode::DIFlags::FlagObjectPointer;\n+  }\n+  if (is_set(flags & LLVMRustDIFlags::FlagVector)) {\n+    result |= DINode::DIFlags::FlagVector;\n+  }\n+  if (is_set(flags & LLVMRustDIFlags::FlagStaticMember)) {\n+    result |= DINode::DIFlags::FlagStaticMember;\n+  }\n+  if (is_set(flags & LLVMRustDIFlags::FlagLValueReference)) {\n+    result |= DINode::DIFlags::FlagLValueReference;\n+  }\n+  if (is_set(flags & LLVMRustDIFlags::FlagRValueReference)) {\n+    result |= DINode::DIFlags::FlagRValueReference;\n+  }\n \n-    return result;\n+  return result;\n }\n \n extern \"C\" uint32_t LLVMRustDebugMetadataVersion() {\n-    return DEBUG_METADATA_VERSION;\n+  return DEBUG_METADATA_VERSION;\n }\n \n-extern \"C\" uint32_t LLVMRustVersionMinor() {\n-  return LLVM_VERSION_MINOR;\n-}\n+extern \"C\" uint32_t LLVMRustVersionMinor() { return LLVM_VERSION_MINOR; }\n \n-extern \"C\" uint32_t LLVMRustVersionMajor() {\n-  return LLVM_VERSION_MAJOR;\n-}\n+extern \"C\" uint32_t LLVMRustVersionMajor() { return LLVM_VERSION_MAJOR; }\n \n-extern \"C\" void LLVMRustAddModuleFlag(LLVMModuleRef M,\n-                                      const char *name,\n+extern \"C\" void LLVMRustAddModuleFlag(LLVMModuleRef M, const char *name,\n                                       uint32_t value) {\n-    unwrap(M)->addModuleFlag(Module::Warning, name, value);\n+  unwrap(M)->addModuleFlag(Module::Warning, name, value);\n }\n \n extern \"C\" LLVMRustDIBuilderRef LLVMRustDIBuilderCreate(LLVMModuleRef M) {\n-    return new DIBuilder(*unwrap(M));\n+  return new DIBuilder(*unwrap(M));\n }\n \n extern \"C\" void LLVMRustDIBuilderDispose(LLVMRustDIBuilderRef Builder) {\n-    delete Builder;\n+  delete Builder;\n }\n \n extern \"C\" void LLVMRustDIBuilderFinalize(LLVMRustDIBuilderRef Builder) {\n-    Builder->finalize();\n+  Builder->finalize();\n }\n \n extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreateCompileUnit(\n-    LLVMRustDIBuilderRef Builder,\n-    unsigned Lang,\n-    const char* File,\n-    const char* Dir,\n-    const char* Producer,\n-    bool isOptimized,\n-    const char* Flags,\n-    unsigned RuntimeVer,\n-    const char* SplitName) {\n-    return wrap(Builder->createCompileUnit(Lang,\n-                                           File,\n-                                           Dir,\n-                                           Producer,\n-                                           isOptimized,\n-                                           Flags,\n-                                           RuntimeVer,\n-                                           SplitName));\n-}\n-\n-extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreateFile(\n-    LLVMRustDIBuilderRef Builder,\n-    const char* Filename,\n-    const char* Directory) {\n-    return wrap(Builder->createFile(Filename, Directory));\n-}\n-\n-extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreateSubroutineType(\n-    LLVMRustDIBuilderRef Builder,\n-    LLVMRustMetadataRef File,\n-    LLVMRustMetadataRef ParameterTypes) {\n-    return wrap(Builder->createSubroutineType(\n+    LLVMRustDIBuilderRef Builder, unsigned Lang, const char *File,\n+    const char *Dir, const char *Producer, bool isOptimized, const char *Flags,\n+    unsigned RuntimeVer, const char *SplitName) {\n+  return wrap(Builder->createCompileUnit(Lang, File, Dir, Producer, isOptimized,\n+                                         Flags, RuntimeVer, SplitName));\n+}\n+\n+extern \"C\" LLVMRustMetadataRef\n+LLVMRustDIBuilderCreateFile(LLVMRustDIBuilderRef Builder, const char *Filename,\n+                            const char *Directory) {\n+  return wrap(Builder->createFile(Filename, Directory));\n+}\n+\n+extern \"C\" LLVMRustMetadataRef\n+LLVMRustDIBuilderCreateSubroutineType(LLVMRustDIBuilderRef Builder,\n+                                      LLVMRustMetadataRef File,\n+                                      LLVMRustMetadataRef ParameterTypes) {\n+  return wrap(Builder->createSubroutineType(\n #if LLVM_VERSION_EQ(3, 7)\n-        unwrapDI<DIFile>(File),\n+      unwrapDI<DIFile>(File),\n #endif\n-        DITypeRefArray(unwrap<MDTuple>(ParameterTypes))));\n+      DITypeRefArray(unwrap<MDTuple>(ParameterTypes))));\n }\n \n extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreateFunction(\n-    LLVMRustDIBuilderRef Builder,\n-    LLVMRustMetadataRef Scope,\n-    const char* Name,\n-    const char* LinkageName,\n-    LLVMRustMetadataRef File,\n-    unsigned LineNo,\n-    LLVMRustMetadataRef Ty,\n-    bool isLocalToUnit,\n-    bool isDefinition,\n-    unsigned ScopeLine,\n-    LLVMRustDIFlags Flags,\n-    bool isOptimized,\n-    LLVMValueRef Fn,\n-    LLVMRustMetadataRef TParam,\n-    LLVMRustMetadataRef Decl) {\n+    LLVMRustDIBuilderRef Builder, LLVMRustMetadataRef Scope, const char *Name,\n+    const char *LinkageName, LLVMRustMetadataRef File, unsigned LineNo,\n+    LLVMRustMetadataRef Ty, bool isLocalToUnit, bool isDefinition,\n+    unsigned ScopeLine, LLVMRustDIFlags Flags, bool isOptimized,\n+    LLVMValueRef Fn, LLVMRustMetadataRef TParam, LLVMRustMetadataRef Decl) {\n #if LLVM_VERSION_GE(3, 8)\n-    DITemplateParameterArray TParams =\n-        DITemplateParameterArray(unwrap<MDTuple>(TParam));\n-    DISubprogram *Sub = Builder->createFunction(\n-        unwrapDI<DIScope>(Scope), Name, LinkageName,\n-        unwrapDI<DIFile>(File), LineNo,\n-        unwrapDI<DISubroutineType>(Ty), isLocalToUnit, isDefinition, ScopeLine,\n-        from_rust(Flags), isOptimized,\n-        TParams,\n-        unwrapDIptr<DISubprogram>(Decl));\n-    unwrap<Function>(Fn)->setSubprogram(Sub);\n-    return wrap(Sub);\n+  DITemplateParameterArray TParams =\n+      DITemplateParameterArray(unwrap<MDTuple>(TParam));\n+  DISubprogram *Sub = Builder->createFunction(\n+      unwrapDI<DIScope>(Scope), Name, LinkageName, unwrapDI<DIFile>(File),\n+      LineNo, unwrapDI<DISubroutineType>(Ty), isLocalToUnit, isDefinition,\n+      ScopeLine, from_rust(Flags), isOptimized, TParams,\n+      unwrapDIptr<DISubprogram>(Decl));\n+  unwrap<Function>(Fn)->setSubprogram(Sub);\n+  return wrap(Sub);\n #else\n-    return wrap(Builder->createFunction(\n-        unwrapDI<DIScope>(Scope), Name, LinkageName,\n-        unwrapDI<DIFile>(File), LineNo,\n-        unwrapDI<DISubroutineType>(Ty), isLocalToUnit, isDefinition, ScopeLine,\n-        from_rust(Flags), isOptimized,\n-        unwrap<Function>(Fn),\n-        unwrapDIptr<MDNode>(TParam),\n-        unwrapDIptr<MDNode>(Decl)));\n+  return wrap(Builder->createFunction(\n+      unwrapDI<DIScope>(Scope), Name, LinkageName, unwrapDI<DIFile>(File),\n+      LineNo, unwrapDI<DISubroutineType>(Ty), isLocalToUnit, isDefinition,\n+      ScopeLine, from_rust(Flags), isOptimized, unwrap<Function>(Fn),\n+      unwrapDIptr<MDNode>(TParam), unwrapDIptr<MDNode>(Decl)));\n #endif\n }\n \n-extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreateBasicType(\n-    LLVMRustDIBuilderRef Builder,\n-    const char* Name,\n-    uint64_t SizeInBits,\n-    uint64_t AlignInBits,\n-    unsigned Encoding) {\n-    return wrap(Builder->createBasicType(\n-        Name,\n-        SizeInBits,\n+extern \"C\" LLVMRustMetadataRef\n+LLVMRustDIBuilderCreateBasicType(LLVMRustDIBuilderRef Builder, const char *Name,\n+                                 uint64_t SizeInBits, uint64_t AlignInBits,\n+                                 unsigned Encoding) {\n+  return wrap(Builder->createBasicType(Name, SizeInBits,\n #if LLVM_VERSION_LE(3, 9)\n-        AlignInBits,\n+                                       AlignInBits,\n #endif\n-        Encoding\n-    ));\n+                                       Encoding));\n }\n \n extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreatePointerType(\n-    LLVMRustDIBuilderRef Builder,\n-    LLVMRustMetadataRef PointeeTy,\n-    uint64_t SizeInBits,\n-    uint64_t AlignInBits,\n-    const char* Name) {\n-    return wrap(Builder->createPointerType(\n-        unwrapDI<DIType>(PointeeTy), SizeInBits, AlignInBits, Name));\n+    LLVMRustDIBuilderRef Builder, LLVMRustMetadataRef PointeeTy,\n+    uint64_t SizeInBits, uint64_t AlignInBits, const char *Name) {\n+  return wrap(Builder->createPointerType(unwrapDI<DIType>(PointeeTy),\n+                                         SizeInBits, AlignInBits, Name));\n }\n \n extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreateStructType(\n-    LLVMRustDIBuilderRef Builder,\n-    LLVMRustMetadataRef Scope,\n-    const char* Name,\n-    LLVMRustMetadataRef File,\n-    unsigned LineNumber,\n-    uint64_t SizeInBits,\n-    uint64_t AlignInBits,\n-    LLVMRustDIFlags Flags,\n-    LLVMRustMetadataRef DerivedFrom,\n-    LLVMRustMetadataRef Elements,\n-    unsigned RunTimeLang,\n-    LLVMRustMetadataRef VTableHolder,\n+    LLVMRustDIBuilderRef Builder, LLVMRustMetadataRef Scope, const char *Name,\n+    LLVMRustMetadataRef File, unsigned LineNumber, uint64_t SizeInBits,\n+    uint64_t AlignInBits, LLVMRustDIFlags Flags,\n+    LLVMRustMetadataRef DerivedFrom, LLVMRustMetadataRef Elements,\n+    unsigned RunTimeLang, LLVMRustMetadataRef VTableHolder,\n     const char *UniqueId) {\n-    return wrap(Builder->createStructType(\n-        unwrapDI<DIDescriptor>(Scope),\n-        Name,\n-        unwrapDI<DIFile>(File),\n-        LineNumber,\n-        SizeInBits,\n-        AlignInBits,\n-        from_rust(Flags),\n-        unwrapDI<DIType>(DerivedFrom),\n-        DINodeArray(unwrapDI<MDTuple>(Elements)),\n-        RunTimeLang,\n-        unwrapDI<DIType>(VTableHolder),\n-        UniqueId\n-        ));\n+  return wrap(Builder->createStructType(\n+      unwrapDI<DIDescriptor>(Scope), Name, unwrapDI<DIFile>(File), LineNumber,\n+      SizeInBits, AlignInBits, from_rust(Flags), unwrapDI<DIType>(DerivedFrom),\n+      DINodeArray(unwrapDI<MDTuple>(Elements)), RunTimeLang,\n+      unwrapDI<DIType>(VTableHolder), UniqueId));\n }\n \n extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreateMemberType(\n-    LLVMRustDIBuilderRef Builder,\n-    LLVMRustMetadataRef Scope,\n-    const char* Name,\n-    LLVMRustMetadataRef File,\n-    unsigned LineNo,\n-    uint64_t SizeInBits,\n-    uint64_t AlignInBits,\n-    uint64_t OffsetInBits,\n-    LLVMRustDIFlags Flags,\n+    LLVMRustDIBuilderRef Builder, LLVMRustMetadataRef Scope, const char *Name,\n+    LLVMRustMetadataRef File, unsigned LineNo, uint64_t SizeInBits,\n+    uint64_t AlignInBits, uint64_t OffsetInBits, LLVMRustDIFlags Flags,\n     LLVMRustMetadataRef Ty) {\n-    return wrap(Builder->createMemberType(\n-        unwrapDI<DIDescriptor>(Scope), Name,\n-        unwrapDI<DIFile>(File), LineNo,\n-        SizeInBits, AlignInBits, OffsetInBits, from_rust(Flags),\n-        unwrapDI<DIType>(Ty)));\n+  return wrap(Builder->createMemberType(\n+      unwrapDI<DIDescriptor>(Scope), Name, unwrapDI<DIFile>(File), LineNo,\n+      SizeInBits, AlignInBits, OffsetInBits, from_rust(Flags),\n+      unwrapDI<DIType>(Ty)));\n }\n \n extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreateLexicalBlock(\n-    LLVMRustDIBuilderRef Builder,\n-    LLVMRustMetadataRef Scope,\n-    LLVMRustMetadataRef File,\n-    unsigned Line,\n-    unsigned Col) {\n-    return wrap(Builder->createLexicalBlock(\n-        unwrapDI<DIDescriptor>(Scope),\n-        unwrapDI<DIFile>(File), Line, Col\n-        ));\n+    LLVMRustDIBuilderRef Builder, LLVMRustMetadataRef Scope,\n+    LLVMRustMetadataRef File, unsigned Line, unsigned Col) {\n+  return wrap(Builder->createLexicalBlock(unwrapDI<DIDescriptor>(Scope),\n+                                          unwrapDI<DIFile>(File), Line, Col));\n }\n \n-extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreateLexicalBlockFile(\n-    LLVMRustDIBuilderRef Builder,\n-    LLVMRustMetadataRef Scope,\n-    LLVMRustMetadataRef File) {\n-    return wrap(Builder->createLexicalBlockFile(\n-        unwrapDI<DIDescriptor>(Scope),\n-        unwrapDI<DIFile>(File)));\n+extern \"C\" LLVMRustMetadataRef\n+LLVMRustDIBuilderCreateLexicalBlockFile(LLVMRustDIBuilderRef Builder,\n+                                        LLVMRustMetadataRef Scope,\n+                                        LLVMRustMetadataRef File) {\n+  return wrap(Builder->createLexicalBlockFile(unwrapDI<DIDescriptor>(Scope),\n+                                              unwrapDI<DIFile>(File)));\n }\n \n extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreateStaticVariable(\n-    LLVMRustDIBuilderRef Builder,\n-    LLVMRustMetadataRef Context,\n-    const char* Name,\n-    const char* LinkageName,\n-    LLVMRustMetadataRef File,\n-    unsigned LineNo,\n-    LLVMRustMetadataRef Ty,\n-    bool isLocalToUnit,\n-    LLVMValueRef Val,\n-    LLVMRustMetadataRef Decl = NULL,\n-    uint64_t AlignInBits = 0) {\n-    Constant *InitVal = cast<Constant>(unwrap(Val));\n+    LLVMRustDIBuilderRef Builder, LLVMRustMetadataRef Context, const char *Name,\n+    const char *LinkageName, LLVMRustMetadataRef File, unsigned LineNo,\n+    LLVMRustMetadataRef Ty, bool isLocalToUnit, LLVMValueRef Val,\n+    LLVMRustMetadataRef Decl = nullptr, uint64_t AlignInBits = 0) {\n+  Constant *InitVal = cast<Constant>(unwrap(Val));\n \n #if LLVM_VERSION_GE(4, 0)\n-    llvm::DIExpression *InitExpr = nullptr;\n-    if (llvm::ConstantInt *IntVal = llvm::dyn_cast<llvm::ConstantInt>(InitVal)) {\n-      InitExpr = Builder->createConstantValueExpression(\n-          IntVal->getValue().getSExtValue());\n-    } else if (llvm::ConstantFP *FPVal = llvm::dyn_cast<llvm::ConstantFP>(InitVal)) {\n-        InitExpr = Builder->createConstantValueExpression(\n-                FPVal->getValueAPF().bitcastToAPInt().getZExtValue());\n-    }\n+  llvm::DIExpression *InitExpr = nullptr;\n+  if (llvm::ConstantInt *IntVal = llvm::dyn_cast<llvm::ConstantInt>(InitVal)) {\n+    InitExpr = Builder->createConstantValueExpression(\n+        IntVal->getValue().getSExtValue());\n+  } else if (llvm::ConstantFP *FPVal =\n+                 llvm::dyn_cast<llvm::ConstantFP>(InitVal)) {\n+    InitExpr = Builder->createConstantValueExpression(\n+        FPVal->getValueAPF().bitcastToAPInt().getZExtValue());\n+  }\n #endif\n \n-    return wrap(Builder->createGlobalVariable(unwrapDI<DIDescriptor>(Context),\n-        Name,\n-        LinkageName,\n-        unwrapDI<DIFile>(File),\n-        LineNo,\n-        unwrapDI<DIType>(Ty),\n-        isLocalToUnit,\n+  return wrap(Builder->createGlobalVariable(\n+      unwrapDI<DIDescriptor>(Context), Name, LinkageName,\n+      unwrapDI<DIFile>(File), LineNo, unwrapDI<DIType>(Ty), isLocalToUnit,\n #if LLVM_VERSION_GE(4, 0)\n-        InitExpr,\n+      InitExpr,\n #else\n-        InitVal,\n+      InitVal,\n #endif\n-        unwrapDIptr<MDNode>(Decl)\n+      unwrapDIptr<MDNode>(Decl)\n #if LLVM_VERSION_GE(4, 0)\n-        , AlignInBits\n+          ,\n+      AlignInBits\n #endif\n-    ));\n+      ));\n }\n \n extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreateVariable(\n-    LLVMRustDIBuilderRef Builder,\n-    unsigned Tag,\n-    LLVMRustMetadataRef Scope,\n-    const char* Name,\n-    LLVMRustMetadataRef File,\n-    unsigned LineNo,\n-    LLVMRustMetadataRef Ty,\n-    bool AlwaysPreserve,\n-    LLVMRustDIFlags Flags,\n-    unsigned ArgNo,\n-    uint64_t AlignInBits)\n-{\n+    LLVMRustDIBuilderRef Builder, unsigned Tag, LLVMRustMetadataRef Scope,\n+    const char *Name, LLVMRustMetadataRef File, unsigned LineNo,\n+    LLVMRustMetadataRef Ty, bool AlwaysPreserve, LLVMRustDIFlags Flags,\n+    unsigned ArgNo, uint64_t AlignInBits) {\n #if LLVM_VERSION_GE(3, 8)\n-    if (Tag == 0x100) { // DW_TAG_auto_variable\n-        return wrap(Builder->createAutoVariable(\n-            unwrapDI<DIDescriptor>(Scope),\n-            Name,\n-            unwrapDI<DIFile>(File),\n-            LineNo,\n-            unwrapDI<DIType>(Ty),\n-            AlwaysPreserve,\n-            from_rust(Flags)\n-#if LLVM_VERSION_GE(4,0)\n-            , AlignInBits\n+  if (Tag == 0x100) { // DW_TAG_auto_variable\n+    return wrap(Builder->createAutoVariable(\n+        unwrapDI<DIDescriptor>(Scope), Name, unwrapDI<DIFile>(File), LineNo,\n+        unwrapDI<DIType>(Ty), AlwaysPreserve, from_rust(Flags)\n+#if LLVM_VERSION_GE(4, 0)\n+                                                  ,\n+        AlignInBits\n #endif\n         ));\n-    } else {\n-        return wrap(Builder->createParameterVariable(\n-            unwrapDI<DIDescriptor>(Scope), Name, ArgNo,\n-            unwrapDI<DIFile>(File),\n-            LineNo,\n-            unwrapDI<DIType>(Ty), AlwaysPreserve, from_rust(Flags)));\n-    }\n+  } else {\n+    return wrap(Builder->createParameterVariable(\n+        unwrapDI<DIDescriptor>(Scope), Name, ArgNo, unwrapDI<DIFile>(File),\n+        LineNo, unwrapDI<DIType>(Ty), AlwaysPreserve, from_rust(Flags)));\n+  }\n #else\n-    return wrap(Builder->createLocalVariable(Tag,\n-        unwrapDI<DIDescriptor>(Scope), Name,\n-        unwrapDI<DIFile>(File),\n-        LineNo,\n-        unwrapDI<DIType>(Ty), AlwaysPreserve, from_rust(Flags), ArgNo));\n+  return wrap(Builder->createLocalVariable(\n+      Tag, unwrapDI<DIDescriptor>(Scope), Name, unwrapDI<DIFile>(File), LineNo,\n+      unwrapDI<DIType>(Ty), AlwaysPreserve, from_rust(Flags), ArgNo));\n #endif\n }\n \n-extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreateArrayType(\n-    LLVMRustDIBuilderRef Builder,\n-    uint64_t Size,\n-    uint64_t AlignInBits,\n-    LLVMRustMetadataRef Ty,\n-    LLVMRustMetadataRef Subscripts) {\n-    return wrap(Builder->createArrayType(Size, AlignInBits,\n-        unwrapDI<DIType>(Ty),\n-        DINodeArray(unwrapDI<MDTuple>(Subscripts))\n-    ));\n+extern \"C\" LLVMRustMetadataRef\n+LLVMRustDIBuilderCreateArrayType(LLVMRustDIBuilderRef Builder, uint64_t Size,\n+                                 uint64_t AlignInBits, LLVMRustMetadataRef Ty,\n+                                 LLVMRustMetadataRef Subscripts) {\n+  return wrap(\n+      Builder->createArrayType(Size, AlignInBits, unwrapDI<DIType>(Ty),\n+                               DINodeArray(unwrapDI<MDTuple>(Subscripts))));\n }\n \n-extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreateVectorType(\n-    LLVMRustDIBuilderRef Builder,\n-    uint64_t Size,\n-    uint64_t AlignInBits,\n-    LLVMRustMetadataRef Ty,\n-    LLVMRustMetadataRef Subscripts) {\n-    return wrap(Builder->createVectorType(Size, AlignInBits,\n-        unwrapDI<DIType>(Ty),\n-        DINodeArray(unwrapDI<MDTuple>(Subscripts))\n-    ));\n+extern \"C\" LLVMRustMetadataRef\n+LLVMRustDIBuilderCreateVectorType(LLVMRustDIBuilderRef Builder, uint64_t Size,\n+                                  uint64_t AlignInBits, LLVMRustMetadataRef Ty,\n+                                  LLVMRustMetadataRef Subscripts) {\n+  return wrap(\n+      Builder->createVectorType(Size, AlignInBits, unwrapDI<DIType>(Ty),\n+                                DINodeArray(unwrapDI<MDTuple>(Subscripts))));\n }\n \n-extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderGetOrCreateSubrange(\n-    LLVMRustDIBuilderRef Builder,\n-    int64_t Lo,\n-    int64_t Count) {\n-    return wrap(Builder->getOrCreateSubrange(Lo, Count));\n+extern \"C\" LLVMRustMetadataRef\n+LLVMRustDIBuilderGetOrCreateSubrange(LLVMRustDIBuilderRef Builder, int64_t Lo,\n+                                     int64_t Count) {\n+  return wrap(Builder->getOrCreateSubrange(Lo, Count));\n }\n \n-extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderGetOrCreateArray(\n-    LLVMRustDIBuilderRef Builder,\n-    LLVMRustMetadataRef* Ptr,\n-    unsigned Count) {\n-    Metadata **DataValue = unwrap(Ptr);\n-    return wrap(Builder->getOrCreateArray(\n-        ArrayRef<Metadata*>(DataValue, Count)).get());\n+extern \"C\" LLVMRustMetadataRef\n+LLVMRustDIBuilderGetOrCreateArray(LLVMRustDIBuilderRef Builder,\n+                                  LLVMRustMetadataRef *Ptr, unsigned Count) {\n+  Metadata **DataValue = unwrap(Ptr);\n+  return wrap(\n+      Builder->getOrCreateArray(ArrayRef<Metadata *>(DataValue, Count)).get());\n }\n \n extern \"C\" LLVMValueRef LLVMRustDIBuilderInsertDeclareAtEnd(\n-    LLVMRustDIBuilderRef Builder,\n-    LLVMValueRef Val,\n-    LLVMRustMetadataRef VarInfo,\n-    int64_t* AddrOps,\n-    unsigned AddrOpsCount,\n-    LLVMValueRef DL,\n+    LLVMRustDIBuilderRef Builder, LLVMValueRef Val, LLVMRustMetadataRef VarInfo,\n+    int64_t *AddrOps, unsigned AddrOpsCount, LLVMValueRef DL,\n     LLVMBasicBlockRef InsertAtEnd) {\n-    return wrap(Builder->insertDeclare(\n-        unwrap(Val),\n-        unwrap<DILocalVariable>(VarInfo),\n-        Builder->createExpression(\n-          llvm::ArrayRef<int64_t>(AddrOps, AddrOpsCount)),\n-        DebugLoc(cast<MDNode>(unwrap<MetadataAsValue>(DL)->getMetadata())),\n-        unwrap(InsertAtEnd)));\n-}\n-\n-extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreateEnumerator(\n-    LLVMRustDIBuilderRef Builder,\n-    const char* Name,\n-    uint64_t Val)\n-{\n-    return wrap(Builder->createEnumerator(Name, Val));\n+  return wrap(Builder->insertDeclare(\n+      unwrap(Val), unwrap<DILocalVariable>(VarInfo),\n+      Builder->createExpression(llvm::ArrayRef<int64_t>(AddrOps, AddrOpsCount)),\n+      DebugLoc(cast<MDNode>(unwrap<MetadataAsValue>(DL)->getMetadata())),\n+      unwrap(InsertAtEnd)));\n+}\n+\n+extern \"C\" LLVMRustMetadataRef\n+LLVMRustDIBuilderCreateEnumerator(LLVMRustDIBuilderRef Builder,\n+                                  const char *Name, uint64_t Val) {\n+  return wrap(Builder->createEnumerator(Name, Val));\n }\n \n extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreateEnumerationType(\n-    LLVMRustDIBuilderRef Builder,\n-    LLVMRustMetadataRef Scope,\n-    const char* Name,\n-    LLVMRustMetadataRef File,\n-    unsigned LineNumber,\n-    uint64_t SizeInBits,\n-    uint64_t AlignInBits,\n-    LLVMRustMetadataRef Elements,\n-    LLVMRustMetadataRef ClassType)\n-{\n-    return wrap(Builder->createEnumerationType(\n-        unwrapDI<DIDescriptor>(Scope),\n-        Name,\n-        unwrapDI<DIFile>(File),\n-        LineNumber,\n-        SizeInBits,\n-        AlignInBits,\n-        DINodeArray(unwrapDI<MDTuple>(Elements)),\n-        unwrapDI<DIType>(ClassType)));\n+    LLVMRustDIBuilderRef Builder, LLVMRustMetadataRef Scope, const char *Name,\n+    LLVMRustMetadataRef File, unsigned LineNumber, uint64_t SizeInBits,\n+    uint64_t AlignInBits, LLVMRustMetadataRef Elements,\n+    LLVMRustMetadataRef ClassType) {\n+  return wrap(Builder->createEnumerationType(\n+      unwrapDI<DIDescriptor>(Scope), Name, unwrapDI<DIFile>(File), LineNumber,\n+      SizeInBits, AlignInBits, DINodeArray(unwrapDI<MDTuple>(Elements)),\n+      unwrapDI<DIType>(ClassType)));\n }\n \n extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreateUnionType(\n-    LLVMRustDIBuilderRef Builder,\n-    LLVMRustMetadataRef Scope,\n-    const char* Name,\n-    LLVMRustMetadataRef File,\n-    unsigned LineNumber,\n-    uint64_t SizeInBits,\n-    uint64_t AlignInBits,\n-    LLVMRustDIFlags Flags,\n-    LLVMRustMetadataRef Elements,\n-    unsigned RunTimeLang,\n-    const char* UniqueId)\n-{\n-    return wrap(Builder->createUnionType(\n-        unwrapDI<DIDescriptor>(Scope),\n-        Name,\n-        unwrapDI<DIFile>(File),\n-        LineNumber,\n-        SizeInBits,\n-        AlignInBits,\n-        from_rust(Flags),\n-        DINodeArray(unwrapDI<MDTuple>(Elements)),\n-        RunTimeLang,\n-        UniqueId\n-        ));\n+    LLVMRustDIBuilderRef Builder, LLVMRustMetadataRef Scope, const char *Name,\n+    LLVMRustMetadataRef File, unsigned LineNumber, uint64_t SizeInBits,\n+    uint64_t AlignInBits, LLVMRustDIFlags Flags, LLVMRustMetadataRef Elements,\n+    unsigned RunTimeLang, const char *UniqueId) {\n+  return wrap(Builder->createUnionType(\n+      unwrapDI<DIDescriptor>(Scope), Name, unwrapDI<DIFile>(File), LineNumber,\n+      SizeInBits, AlignInBits, from_rust(Flags),\n+      DINodeArray(unwrapDI<MDTuple>(Elements)), RunTimeLang, UniqueId));\n }\n \n extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreateTemplateTypeParameter(\n-    LLVMRustDIBuilderRef Builder,\n-    LLVMRustMetadataRef Scope,\n-    const char* Name,\n-    LLVMRustMetadataRef Ty,\n-    LLVMRustMetadataRef File,\n-    unsigned LineNo,\n-    unsigned ColumnNo)\n-{\n-    return wrap(Builder->createTemplateTypeParameter(\n-      unwrapDI<DIDescriptor>(Scope),\n-      Name,\n-      unwrapDI<DIType>(Ty)\n-      ));\n-}\n-\n-extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreateNameSpace(\n-    LLVMRustDIBuilderRef Builder,\n-    LLVMRustMetadataRef Scope,\n-    const char* Name,\n-    LLVMRustMetadataRef File,\n-    unsigned LineNo)\n-{\n-    return wrap(Builder->createNameSpace(\n-        unwrapDI<DIDescriptor>(Scope),\n-        Name,\n-        unwrapDI<DIFile>(File),\n-        LineNo\n+    LLVMRustDIBuilderRef Builder, LLVMRustMetadataRef Scope, const char *Name,\n+    LLVMRustMetadataRef Ty, LLVMRustMetadataRef File, unsigned LineNo,\n+    unsigned ColumnNo) {\n+  return wrap(Builder->createTemplateTypeParameter(\n+      unwrapDI<DIDescriptor>(Scope), Name, unwrapDI<DIType>(Ty)));\n+}\n+\n+extern \"C\" LLVMRustMetadataRef\n+LLVMRustDIBuilderCreateNameSpace(LLVMRustDIBuilderRef Builder,\n+                                 LLVMRustMetadataRef Scope, const char *Name,\n+                                 LLVMRustMetadataRef File, unsigned LineNo) {\n+  return wrap(Builder->createNameSpace(\n+      unwrapDI<DIDescriptor>(Scope), Name, unwrapDI<DIFile>(File), LineNo\n #if LLVM_VERSION_GE(4, 0)\n-        , false // ExportSymbols (only relevant for C++ anonymous namespaces)\n+      ,\n+      false // ExportSymbols (only relevant for C++ anonymous namespaces)\n #endif\n-    ));\n+      ));\n }\n \n-extern \"C\" void LLVMRustDICompositeTypeSetTypeArray(\n-    LLVMRustDIBuilderRef Builder,\n-    LLVMRustMetadataRef CompositeType,\n-    LLVMRustMetadataRef TypeArray)\n-{\n-    DICompositeType *tmp = unwrapDI<DICompositeType>(CompositeType);\n-    Builder->replaceArrays(tmp, DINodeArray(unwrap<MDTuple>(TypeArray)));\n+extern \"C\" void\n+LLVMRustDICompositeTypeSetTypeArray(LLVMRustDIBuilderRef Builder,\n+                                    LLVMRustMetadataRef CompositeType,\n+                                    LLVMRustMetadataRef TypeArray) {\n+  DICompositeType *tmp = unwrapDI<DICompositeType>(CompositeType);\n+  Builder->replaceArrays(tmp, DINodeArray(unwrap<MDTuple>(TypeArray)));\n }\n \n-extern \"C\" LLVMValueRef LLVMRustDIBuilderCreateDebugLocation(\n-  LLVMContextRef Context,\n-  unsigned Line,\n-  unsigned Column,\n-  LLVMRustMetadataRef Scope,\n-  LLVMRustMetadataRef InlinedAt)\n-{\n-    LLVMContext& context = *unwrap(Context);\n+extern \"C\" LLVMValueRef\n+LLVMRustDIBuilderCreateDebugLocation(LLVMContextRef Context, unsigned Line,\n+                                     unsigned Column, LLVMRustMetadataRef Scope,\n+                                     LLVMRustMetadataRef InlinedAt) {\n+  LLVMContext &context = *unwrap(Context);\n \n-    DebugLoc debug_loc = DebugLoc::get(Line,\n-                                       Column,\n-                                       unwrapDIptr<MDNode>(Scope),\n-                                       unwrapDIptr<MDNode>(InlinedAt));\n+  DebugLoc debug_loc = DebugLoc::get(Line, Column, unwrapDIptr<MDNode>(Scope),\n+                                     unwrapDIptr<MDNode>(InlinedAt));\n \n-    return wrap(MetadataAsValue::get(context, debug_loc.getAsMDNode()));\n+  return wrap(MetadataAsValue::get(context, debug_loc.getAsMDNode()));\n }\n \n-extern \"C\" int64_t LLVMRustDIBuilderCreateOpDeref()\n-{\n-    return dwarf::DW_OP_deref;\n+extern \"C\" int64_t LLVMRustDIBuilderCreateOpDeref() {\n+  return dwarf::DW_OP_deref;\n }\n \n-extern \"C\" int64_t LLVMRustDIBuilderCreateOpPlus()\n-{\n-    return dwarf::DW_OP_plus;\n-}\n+extern \"C\" int64_t LLVMRustDIBuilderCreateOpPlus() { return dwarf::DW_OP_plus; }\n \n extern \"C\" void LLVMRustWriteTypeToString(LLVMTypeRef Type, RustStringRef str) {\n-    raw_rust_string_ostream os(str);\n-    unwrap<llvm::Type>(Type)->print(os);\n+  raw_rust_string_ostream os(str);\n+  unwrap<llvm::Type>(Type)->print(os);\n }\n \n-extern \"C\" void LLVMRustWriteValueToString(LLVMValueRef Value, RustStringRef str) {\n-    raw_rust_string_ostream os(str);\n-    os << \"(\";\n-    unwrap<llvm::Value>(Value)->getType()->print(os);\n-    os << \":\";\n-    unwrap<llvm::Value>(Value)->print(os);\n-    os << \")\";\n+extern \"C\" void LLVMRustWriteValueToString(LLVMValueRef Value,\n+                                           RustStringRef str) {\n+  raw_rust_string_ostream os(str);\n+  os << \"(\";\n+  unwrap<llvm::Value>(Value)->getType()->print(os);\n+  os << \":\";\n+  unwrap<llvm::Value>(Value)->print(os);\n+  os << \")\";\n }\n \n-extern \"C\" bool\n-LLVMRustLinkInExternalBitcode(LLVMModuleRef dst, char *bc, size_t len) {\n-    Module *Dst = unwrap(dst);\n+extern \"C\" bool LLVMRustLinkInExternalBitcode(LLVMModuleRef dst, char *bc,\n+                                              size_t len) {\n+  Module *Dst = unwrap(dst);\n \n-    std::unique_ptr<MemoryBuffer> buf = MemoryBuffer::getMemBufferCopy(StringRef(bc, len));\n+  std::unique_ptr<MemoryBuffer> buf =\n+      MemoryBuffer::getMemBufferCopy(StringRef(bc, len));\n \n #if LLVM_VERSION_GE(4, 0)\n-    Expected<std::unique_ptr<Module>> SrcOrError =\n-        llvm::getLazyBitcodeModule(buf->getMemBufferRef(), Dst->getContext());\n-    if (!SrcOrError) {\n-        LLVMRustSetLastError(toString(SrcOrError.takeError()).c_str());\n-        return false;\n-    }\n+  Expected<std::unique_ptr<Module>> SrcOrError =\n+      llvm::getLazyBitcodeModule(buf->getMemBufferRef(), Dst->getContext());\n+  if (!SrcOrError) {\n+    LLVMRustSetLastError(toString(SrcOrError.takeError()).c_str());\n+    return false;\n+  }\n \n-    auto Src = std::move(*SrcOrError);\n+  auto Src = std::move(*SrcOrError);\n #else\n-    ErrorOr<std::unique_ptr<Module>> Src =\n-        llvm::getLazyBitcodeModule(std::move(buf), Dst->getContext());\n-    if (!Src) {\n-        LLVMRustSetLastError(Src.getError().message().c_str());\n-        return false;\n-    }\n+  ErrorOr<std::unique_ptr<Module>> Src =\n+      llvm::getLazyBitcodeModule(std::move(buf), Dst->getContext());\n+  if (!Src) {\n+    LLVMRustSetLastError(Src.getError().message().c_str());\n+    return false;\n+  }\n #endif\n \n-    std::string Err;\n+  std::string Err;\n \n-    raw_string_ostream Stream(Err);\n-    DiagnosticPrinterRawOStream DP(Stream);\n+  raw_string_ostream Stream(Err);\n+  DiagnosticPrinterRawOStream DP(Stream);\n #if LLVM_VERSION_GE(4, 0)\n-    if (Linker::linkModules(*Dst, std::move(Src))) {\n+  if (Linker::linkModules(*Dst, std::move(Src))) {\n #elif LLVM_VERSION_GE(3, 8)\n-    if (Linker::linkModules(*Dst, std::move(Src.get()))) {\n+  if (Linker::linkModules(*Dst, std::move(Src.get()))) {\n #else\n-    if (Linker::LinkModules(Dst, Src->get(), [&](const DiagnosticInfo &DI) { DI.print(DP); })) {\n+  if (Linker::LinkModules(Dst, Src->get(),\n+                          [&](const DiagnosticInfo &DI) { DI.print(DP); })) {\n #endif\n-        LLVMRustSetLastError(Err.c_str());\n-        return false;\n-    }\n-    return true;\n+    LLVMRustSetLastError(Err.c_str());\n+    return false;\n+  }\n+  return true;\n }\n \n // Note that the two following functions look quite similar to the\n@@ -980,127 +820,118 @@ LLVMRustLinkInExternalBitcode(LLVMModuleRef dst, char *bc, size_t len) {\n // that's returned.\n \n inline section_iterator *unwrap(LLVMSectionIteratorRef SI) {\n-    return reinterpret_cast<section_iterator*>(SI);\n+  return reinterpret_cast<section_iterator *>(SI);\n }\n \n-extern \"C\" size_t\n-LLVMRustGetSectionName(LLVMSectionIteratorRef SI, const char **ptr) {\n-    StringRef ret;\n-    if (std::error_code ec = (*unwrap(SI))->getName(ret))\n-      report_fatal_error(ec.message());\n-    *ptr = ret.data();\n-    return ret.size();\n+extern \"C\" size_t LLVMRustGetSectionName(LLVMSectionIteratorRef SI,\n+                                         const char **ptr) {\n+  StringRef ret;\n+  if (std::error_code ec = (*unwrap(SI))->getName(ret))\n+    report_fatal_error(ec.message());\n+  *ptr = ret.data();\n+  return ret.size();\n }\n \n // LLVMArrayType function does not support 64-bit ElementCount\n-extern \"C\" LLVMTypeRef\n-LLVMRustArrayType(LLVMTypeRef ElementType, uint64_t ElementCount) {\n-    return wrap(ArrayType::get(unwrap(ElementType), ElementCount));\n+extern \"C\" LLVMTypeRef LLVMRustArrayType(LLVMTypeRef ElementType,\n+                                         uint64_t ElementCount) {\n+  return wrap(ArrayType::get(unwrap(ElementType), ElementCount));\n }\n \n DEFINE_SIMPLE_CONVERSION_FUNCTIONS(Twine, LLVMTwineRef)\n DEFINE_SIMPLE_CONVERSION_FUNCTIONS(DebugLoc, LLVMDebugLocRef)\n \n-extern \"C\" void\n-LLVMRustWriteTwineToString(LLVMTwineRef T, RustStringRef str) {\n-    raw_rust_string_ostream os(str);\n-    unwrap(T)->print(os);\n+extern \"C\" void LLVMRustWriteTwineToString(LLVMTwineRef T, RustStringRef str) {\n+  raw_rust_string_ostream os(str);\n+  unwrap(T)->print(os);\n }\n \n-extern \"C\" void\n-LLVMRustUnpackOptimizationDiagnostic(\n-    LLVMDiagnosticInfoRef di,\n-    RustStringRef pass_name_out,\n-    LLVMValueRef *function_out,\n-    LLVMDebugLocRef *debugloc_out,\n-    RustStringRef message_out)\n-{\n-    // Undefined to call this not on an optimization diagnostic!\n-    llvm::DiagnosticInfoOptimizationBase *opt\n-        = static_cast<llvm::DiagnosticInfoOptimizationBase*>(unwrap(di));\n+extern \"C\" void LLVMRustUnpackOptimizationDiagnostic(\n+    LLVMDiagnosticInfoRef di, RustStringRef pass_name_out,\n+    LLVMValueRef *function_out, LLVMDebugLocRef *debugloc_out,\n+    RustStringRef message_out) {\n+  // Undefined to call this not on an optimization diagnostic!\n+  llvm::DiagnosticInfoOptimizationBase *opt =\n+      static_cast<llvm::DiagnosticInfoOptimizationBase *>(unwrap(di));\n \n-    raw_rust_string_ostream pass_name_os(pass_name_out);\n-    pass_name_os << opt->getPassName();\n-    *function_out = wrap(&opt->getFunction());\n-    *debugloc_out = wrap(&opt->getDebugLoc());\n-    raw_rust_string_ostream message_os(message_out);\n-    message_os << opt->getMsg();\n+  raw_rust_string_ostream pass_name_os(pass_name_out);\n+  pass_name_os << opt->getPassName();\n+  *function_out = wrap(&opt->getFunction());\n+  *debugloc_out = wrap(&opt->getDebugLoc());\n+  raw_rust_string_ostream message_os(message_out);\n+  message_os << opt->getMsg();\n }\n \n-extern \"C\" void\n-LLVMRustUnpackInlineAsmDiagnostic(\n-    LLVMDiagnosticInfoRef di,\n-    unsigned *cookie_out,\n-    LLVMTwineRef *message_out,\n-    LLVMValueRef *instruction_out)\n-{\n-    // Undefined to call this not on an inline assembly diagnostic!\n-    llvm::DiagnosticInfoInlineAsm *ia\n-        = static_cast<llvm::DiagnosticInfoInlineAsm*>(unwrap(di));\n+extern \"C\" void LLVMRustUnpackInlineAsmDiagnostic(\n+    LLVMDiagnosticInfoRef di, unsigned *cookie_out, LLVMTwineRef *message_out,\n+    LLVMValueRef *instruction_out) {\n+  // Undefined to call this not on an inline assembly diagnostic!\n+  llvm::DiagnosticInfoInlineAsm *ia =\n+      static_cast<llvm::DiagnosticInfoInlineAsm *>(unwrap(di));\n \n-    *cookie_out = ia->getLocCookie();\n-    *message_out = wrap(&ia->getMsgStr());\n-    *instruction_out = wrap(ia->getInstruction());\n+  *cookie_out = ia->getLocCookie();\n+  *message_out = wrap(&ia->getMsgStr());\n+  *instruction_out = wrap(ia->getInstruction());\n }\n \n-extern \"C\" void LLVMRustWriteDiagnosticInfoToString(LLVMDiagnosticInfoRef di, RustStringRef str) {\n-    raw_rust_string_ostream os(str);\n-    DiagnosticPrinterRawOStream dp(os);\n-    unwrap(di)->print(dp);\n+extern \"C\" void LLVMRustWriteDiagnosticInfoToString(LLVMDiagnosticInfoRef di,\n+                                                    RustStringRef str) {\n+  raw_rust_string_ostream os(str);\n+  DiagnosticPrinterRawOStream dp(os);\n+  unwrap(di)->print(dp);\n }\n \n enum class LLVMRustDiagnosticKind {\n-    Other,\n-    InlineAsm,\n-    StackSize,\n-    DebugMetadataVersion,\n-    SampleProfile,\n-    OptimizationRemark,\n-    OptimizationRemarkMissed,\n-    OptimizationRemarkAnalysis,\n-    OptimizationRemarkAnalysisFPCommute,\n-    OptimizationRemarkAnalysisAliasing,\n-    OptimizationRemarkOther,\n-    OptimizationFailure,\n+  Other,\n+  InlineAsm,\n+  StackSize,\n+  DebugMetadataVersion,\n+  SampleProfile,\n+  OptimizationRemark,\n+  OptimizationRemarkMissed,\n+  OptimizationRemarkAnalysis,\n+  OptimizationRemarkAnalysisFPCommute,\n+  OptimizationRemarkAnalysisAliasing,\n+  OptimizationRemarkOther,\n+  OptimizationFailure,\n };\n \n-static LLVMRustDiagnosticKind\n-to_rust(DiagnosticKind kind)\n-{\n-    switch (kind) {\n-    case DK_InlineAsm:\n-        return LLVMRustDiagnosticKind::InlineAsm;\n-    case DK_StackSize:\n-        return LLVMRustDiagnosticKind::StackSize;\n-    case DK_DebugMetadataVersion:\n-        return LLVMRustDiagnosticKind::DebugMetadataVersion;\n-    case DK_SampleProfile:\n-        return LLVMRustDiagnosticKind::SampleProfile;\n-    case DK_OptimizationRemark:\n-        return LLVMRustDiagnosticKind::OptimizationRemark;\n-    case DK_OptimizationRemarkMissed:\n-        return LLVMRustDiagnosticKind::OptimizationRemarkMissed;\n-    case DK_OptimizationRemarkAnalysis:\n-        return LLVMRustDiagnosticKind::OptimizationRemarkAnalysis;\n+static LLVMRustDiagnosticKind to_rust(DiagnosticKind kind) {\n+  switch (kind) {\n+  case DK_InlineAsm:\n+    return LLVMRustDiagnosticKind::InlineAsm;\n+  case DK_StackSize:\n+    return LLVMRustDiagnosticKind::StackSize;\n+  case DK_DebugMetadataVersion:\n+    return LLVMRustDiagnosticKind::DebugMetadataVersion;\n+  case DK_SampleProfile:\n+    return LLVMRustDiagnosticKind::SampleProfile;\n+  case DK_OptimizationRemark:\n+    return LLVMRustDiagnosticKind::OptimizationRemark;\n+  case DK_OptimizationRemarkMissed:\n+    return LLVMRustDiagnosticKind::OptimizationRemarkMissed;\n+  case DK_OptimizationRemarkAnalysis:\n+    return LLVMRustDiagnosticKind::OptimizationRemarkAnalysis;\n #if LLVM_VERSION_GE(3, 8)\n-    case DK_OptimizationRemarkAnalysisFPCommute:\n-        return LLVMRustDiagnosticKind::OptimizationRemarkAnalysisFPCommute;\n-    case DK_OptimizationRemarkAnalysisAliasing:\n-        return LLVMRustDiagnosticKind::OptimizationRemarkAnalysisAliasing;\n+  case DK_OptimizationRemarkAnalysisFPCommute:\n+    return LLVMRustDiagnosticKind::OptimizationRemarkAnalysisFPCommute;\n+  case DK_OptimizationRemarkAnalysisAliasing:\n+    return LLVMRustDiagnosticKind::OptimizationRemarkAnalysisAliasing;\n #endif\n-    default:\n+  default:\n #if LLVM_VERSION_GE(3, 9)\n-        return (kind >= DK_FirstRemark && kind <= DK_LastRemark) ?\n-            LLVMRustDiagnosticKind::OptimizationRemarkOther :\n-            LLVMRustDiagnosticKind::Other;\n+    return (kind >= DK_FirstRemark && kind <= DK_LastRemark)\n+               ? LLVMRustDiagnosticKind::OptimizationRemarkOther\n+               : LLVMRustDiagnosticKind::Other;\n #else\n-        return LLVMRustDiagnosticKind::Other;\n+    return LLVMRustDiagnosticKind::Other;\n #endif\n   }\n }\n \n-extern \"C\" LLVMRustDiagnosticKind LLVMRustGetDiagInfoKind(LLVMDiagnosticInfoRef di) {\n-    return to_rust((DiagnosticKind) unwrap(di)->getKind());\n+extern \"C\" LLVMRustDiagnosticKind\n+LLVMRustGetDiagInfoKind(LLVMDiagnosticInfoRef di) {\n+  return to_rust((DiagnosticKind)unwrap(di)->getKind());\n }\n // This is kept distinct from LLVMGetTypeKind, because when\n // a new type kind is added, the Rust-side enum must be\n@@ -1147,359 +978,334 @@ extern \"C\" LLVMTypeKind LLVMRustGetTypeKind(LLVMTypeRef Ty) {\n   llvm_unreachable(\"Unhandled TypeID.\");\n }\n \n-extern \"C\" void LLVMRustWriteDebugLocToString(\n-    LLVMContextRef C,\n-    LLVMDebugLocRef dl,\n-    RustStringRef str)\n-{\n-    raw_rust_string_ostream os(str);\n-    unwrap(dl)->print(os);\n+extern \"C\" void LLVMRustWriteDebugLocToString(LLVMContextRef C,\n+                                              LLVMDebugLocRef dl,\n+                                              RustStringRef str) {\n+  raw_rust_string_ostream os(str);\n+  unwrap(dl)->print(os);\n }\n \n DEFINE_SIMPLE_CONVERSION_FUNCTIONS(SMDiagnostic, LLVMSMDiagnosticRef)\n \n extern \"C\" void LLVMRustSetInlineAsmDiagnosticHandler(\n-    LLVMContextRef C,\n-    LLVMContext::InlineAsmDiagHandlerTy H,\n-    void *CX)\n-{\n-    unwrap(C)->setInlineAsmDiagnosticHandler(H, CX);\n+    LLVMContextRef C, LLVMContext::InlineAsmDiagHandlerTy H, void *CX) {\n+  unwrap(C)->setInlineAsmDiagnosticHandler(H, CX);\n }\n \n extern \"C\" void LLVMRustWriteSMDiagnosticToString(LLVMSMDiagnosticRef d,\n-\t\t\t\t\t\t  RustStringRef str) {\n-    raw_rust_string_ostream os(str);\n-    unwrap(d)->print(\"\", os);\n+                                                  RustStringRef str) {\n+  raw_rust_string_ostream os(str);\n+  unwrap(d)->print(\"\", os);\n }\n \n extern \"C\" LLVMValueRef\n-LLVMRustBuildLandingPad(LLVMBuilderRef Builder,\n-                        LLVMTypeRef Ty,\n-                        LLVMValueRef PersFn,\n-                        unsigned NumClauses,\n-                        const char* Name,\n-                        LLVMValueRef F) {\n-    return LLVMBuildLandingPad(Builder, Ty, PersFn, NumClauses, Name);\n+LLVMRustBuildLandingPad(LLVMBuilderRef Builder, LLVMTypeRef Ty,\n+                        LLVMValueRef PersFn, unsigned NumClauses,\n+                        const char *Name, LLVMValueRef F) {\n+  return LLVMBuildLandingPad(Builder, Ty, PersFn, NumClauses, Name);\n }\n \n-extern \"C\" LLVMValueRef\n-LLVMRustBuildCleanupPad(LLVMBuilderRef Builder,\n-                        LLVMValueRef ParentPad,\n-                        unsigned ArgCnt,\n-                        LLVMValueRef *LLArgs,\n-                        const char *Name) {\n+extern \"C\" LLVMValueRef LLVMRustBuildCleanupPad(LLVMBuilderRef Builder,\n+                                                LLVMValueRef ParentPad,\n+                                                unsigned ArgCnt,\n+                                                LLVMValueRef *LLArgs,\n+                                                const char *Name) {\n #if LLVM_VERSION_GE(3, 8)\n-    Value **Args = unwrap(LLArgs);\n-    if (ParentPad == NULL) {\n-        Type *Ty = Type::getTokenTy(unwrap(Builder)->getContext());\n-        ParentPad = wrap(Constant::getNullValue(Ty));\n-    }\n-    return wrap(unwrap(Builder)->CreateCleanupPad(unwrap(ParentPad),\n-                                                  ArrayRef<Value*>(Args, ArgCnt),\n-                                                  Name));\n+  Value **Args = unwrap(LLArgs);\n+  if (ParentPad == nullptr) {\n+    Type *Ty = Type::getTokenTy(unwrap(Builder)->getContext());\n+    ParentPad = wrap(Constant::getNullValue(Ty));\n+  }\n+  return wrap(unwrap(Builder)->CreateCleanupPad(\n+      unwrap(ParentPad), ArrayRef<Value *>(Args, ArgCnt), Name));\n #else\n-    return NULL;\n+  return nullptr;\n #endif\n }\n \n-extern \"C\" LLVMValueRef\n-LLVMRustBuildCleanupRet(LLVMBuilderRef Builder,\n-                        LLVMValueRef CleanupPad,\n-                        LLVMBasicBlockRef UnwindBB) {\n+extern \"C\" LLVMValueRef LLVMRustBuildCleanupRet(LLVMBuilderRef Builder,\n+                                                LLVMValueRef CleanupPad,\n+                                                LLVMBasicBlockRef UnwindBB) {\n #if LLVM_VERSION_GE(3, 8)\n-    CleanupPadInst *Inst = cast<CleanupPadInst>(unwrap(CleanupPad));\n-    return wrap(unwrap(Builder)->CreateCleanupRet(Inst, unwrap(UnwindBB)));\n+  CleanupPadInst *Inst = cast<CleanupPadInst>(unwrap(CleanupPad));\n+  return wrap(unwrap(Builder)->CreateCleanupRet(Inst, unwrap(UnwindBB)));\n #else\n-    return NULL;\n+  return nullptr;\n #endif\n }\n \n extern \"C\" LLVMValueRef\n-LLVMRustBuildCatchPad(LLVMBuilderRef Builder,\n-                      LLVMValueRef ParentPad,\n-                      unsigned ArgCnt,\n-                      LLVMValueRef *LLArgs,\n-                      const char *Name) {\n+LLVMRustBuildCatchPad(LLVMBuilderRef Builder, LLVMValueRef ParentPad,\n+                      unsigned ArgCnt, LLVMValueRef *LLArgs, const char *Name) {\n #if LLVM_VERSION_GE(3, 8)\n-    Value **Args = unwrap(LLArgs);\n-    return wrap(unwrap(Builder)->CreateCatchPad(unwrap(ParentPad),\n-                                                ArrayRef<Value*>(Args, ArgCnt),\n-                                                Name));\n+  Value **Args = unwrap(LLArgs);\n+  return wrap(unwrap(Builder)->CreateCatchPad(\n+      unwrap(ParentPad), ArrayRef<Value *>(Args, ArgCnt), Name));\n #else\n-    return NULL;\n+  return nullptr;\n #endif\n }\n \n-extern \"C\" LLVMValueRef\n-LLVMRustBuildCatchRet(LLVMBuilderRef Builder,\n-                      LLVMValueRef Pad,\n-                      LLVMBasicBlockRef BB) {\n+extern \"C\" LLVMValueRef LLVMRustBuildCatchRet(LLVMBuilderRef Builder,\n+                                              LLVMValueRef Pad,\n+                                              LLVMBasicBlockRef BB) {\n #if LLVM_VERSION_GE(3, 8)\n-    return wrap(unwrap(Builder)->CreateCatchRet(cast<CatchPadInst>(unwrap(Pad)),\n-                                                unwrap(BB)));\n+  return wrap(unwrap(Builder)->CreateCatchRet(cast<CatchPadInst>(unwrap(Pad)),\n+                                              unwrap(BB)));\n #else\n-    return NULL;\n+  return nullptr;\n #endif\n }\n \n-extern \"C\" LLVMValueRef\n-LLVMRustBuildCatchSwitch(LLVMBuilderRef Builder,\n-                         LLVMValueRef ParentPad,\n-                         LLVMBasicBlockRef BB,\n-                         unsigned NumHandlers,\n-                         const char *Name) {\n+extern \"C\" LLVMValueRef LLVMRustBuildCatchSwitch(LLVMBuilderRef Builder,\n+                                                 LLVMValueRef ParentPad,\n+                                                 LLVMBasicBlockRef BB,\n+                                                 unsigned NumHandlers,\n+                                                 const char *Name) {\n #if LLVM_VERSION_GE(3, 8)\n-    if (ParentPad == NULL) {\n-        Type *Ty = Type::getTokenTy(unwrap(Builder)->getContext());\n-        ParentPad = wrap(Constant::getNullValue(Ty));\n-    }\n-    return wrap(unwrap(Builder)->CreateCatchSwitch(unwrap(ParentPad),\n-                                                   unwrap(BB),\n-                                                   NumHandlers,\n-                                                   Name));\n+  if (ParentPad == nullptr) {\n+    Type *Ty = Type::getTokenTy(unwrap(Builder)->getContext());\n+    ParentPad = wrap(Constant::getNullValue(Ty));\n+  }\n+  return wrap(unwrap(Builder)->CreateCatchSwitch(unwrap(ParentPad), unwrap(BB),\n+                                                 NumHandlers, Name));\n #else\n-    return NULL;\n+  return nullptr;\n #endif\n }\n \n-extern \"C\" void\n-LLVMRustAddHandler(LLVMValueRef CatchSwitchRef,\n-                   LLVMBasicBlockRef Handler) {\n+extern \"C\" void LLVMRustAddHandler(LLVMValueRef CatchSwitchRef,\n+                                   LLVMBasicBlockRef Handler) {\n #if LLVM_VERSION_GE(3, 8)\n-    Value *CatchSwitch = unwrap(CatchSwitchRef);\n-    cast<CatchSwitchInst>(CatchSwitch)->addHandler(unwrap(Handler));\n+  Value *CatchSwitch = unwrap(CatchSwitchRef);\n+  cast<CatchSwitchInst>(CatchSwitch)->addHandler(unwrap(Handler));\n #endif\n }\n \n-extern \"C\" void\n-LLVMRustSetPersonalityFn(LLVMBuilderRef B,\n-                         LLVMValueRef Personality) {\n+extern \"C\" void LLVMRustSetPersonalityFn(LLVMBuilderRef B,\n+                                         LLVMValueRef Personality) {\n #if LLVM_VERSION_GE(3, 8)\n-    unwrap(B)->GetInsertBlock()\n-             ->getParent()\n-             ->setPersonalityFn(cast<Function>(unwrap(Personality)));\n+  unwrap(B)->GetInsertBlock()->getParent()->setPersonalityFn(\n+      cast<Function>(unwrap(Personality)));\n #endif\n }\n \n #if LLVM_VERSION_GE(3, 8)\n-extern \"C\" OperandBundleDef*\n-LLVMRustBuildOperandBundleDef(const char *Name,\n-                              LLVMValueRef *Inputs,\n-                              unsigned NumInputs) {\n+extern \"C\" OperandBundleDef *LLVMRustBuildOperandBundleDef(const char *Name,\n+                                                           LLVMValueRef *Inputs,\n+                                                           unsigned NumInputs) {\n   return new OperandBundleDef(Name, makeArrayRef(unwrap(Inputs), NumInputs));\n }\n \n-extern \"C\" void\n-LLVMRustFreeOperandBundleDef(OperandBundleDef* Bundle) {\n+extern \"C\" void LLVMRustFreeOperandBundleDef(OperandBundleDef *Bundle) {\n   delete Bundle;\n }\n \n-extern \"C\" LLVMValueRef\n-LLVMRustBuildCall(LLVMBuilderRef B,\n-                    LLVMValueRef Fn,\n-                    LLVMValueRef *Args,\n-                    unsigned NumArgs,\n-                    OperandBundleDef *Bundle,\n-                    const char *Name) {\n-    unsigned len = Bundle ? 1 : 0;\n-    ArrayRef<OperandBundleDef> Bundles = makeArrayRef(Bundle, len);\n-    return wrap(unwrap(B)->CreateCall(unwrap(Fn),\n-                                      makeArrayRef(unwrap(Args), NumArgs),\n-                                      Bundles,\n-                                      Name));\n+extern \"C\" LLVMValueRef LLVMRustBuildCall(LLVMBuilderRef B, LLVMValueRef Fn,\n+                                          LLVMValueRef *Args, unsigned NumArgs,\n+                                          OperandBundleDef *Bundle,\n+                                          const char *Name) {\n+  unsigned len = Bundle ? 1 : 0;\n+  ArrayRef<OperandBundleDef> Bundles = makeArrayRef(Bundle, len);\n+  return wrap(unwrap(B)->CreateCall(\n+      unwrap(Fn), makeArrayRef(unwrap(Args), NumArgs), Bundles, Name));\n }\n \n extern \"C\" LLVMValueRef\n-LLVMRustBuildInvoke(LLVMBuilderRef B,\n-                    LLVMValueRef Fn,\n-                    LLVMValueRef *Args,\n-                    unsigned NumArgs,\n-                    LLVMBasicBlockRef Then,\n-                    LLVMBasicBlockRef Catch,\n-                    OperandBundleDef *Bundle,\n+LLVMRustBuildInvoke(LLVMBuilderRef B, LLVMValueRef Fn, LLVMValueRef *Args,\n+                    unsigned NumArgs, LLVMBasicBlockRef Then,\n+                    LLVMBasicBlockRef Catch, OperandBundleDef *Bundle,\n                     const char *Name) {\n-    unsigned len = Bundle ? 1 : 0;\n-    ArrayRef<OperandBundleDef> Bundles = makeArrayRef(Bundle, len);\n-    return wrap(unwrap(B)->CreateInvoke(unwrap(Fn), unwrap(Then), unwrap(Catch),\n-                                        makeArrayRef(unwrap(Args), NumArgs),\n-                                        Bundles,\n-                                        Name));\n+  unsigned len = Bundle ? 1 : 0;\n+  ArrayRef<OperandBundleDef> Bundles = makeArrayRef(Bundle, len);\n+  return wrap(unwrap(B)->CreateInvoke(unwrap(Fn), unwrap(Then), unwrap(Catch),\n+                                      makeArrayRef(unwrap(Args), NumArgs),\n+                                      Bundles, Name));\n }\n #else\n-extern \"C\" void*\n-LLVMRustBuildOperandBundleDef(const char *Name,\n-                              LLVMValueRef *Inputs,\n-                              unsigned NumInputs) {\n-  return NULL;\n+extern \"C\" void *LLVMRustBuildOperandBundleDef(const char *Name,\n+                                               LLVMValueRef *Inputs,\n+                                               unsigned NumInputs) {\n+  return nullptr;\n }\n \n-extern \"C\" void\n-LLVMRustFreeOperandBundleDef(void* Bundle) {\n-}\n+extern \"C\" void LLVMRustFreeOperandBundleDef(void *Bundle) {}\n \n-extern \"C\" LLVMValueRef\n-LLVMRustBuildCall(LLVMBuilderRef B,\n-                    LLVMValueRef Fn,\n-                    LLVMValueRef *Args,\n-                    unsigned NumArgs,\n-                    void *Bundle,\n-                    const char *Name) {\n-    return LLVMBuildCall(B, Fn, Args, NumArgs, Name);\n+extern \"C\" LLVMValueRef LLVMRustBuildCall(LLVMBuilderRef B, LLVMValueRef Fn,\n+                                          LLVMValueRef *Args, unsigned NumArgs,\n+                                          void *Bundle, const char *Name) {\n+  return LLVMBuildCall(B, Fn, Args, NumArgs, Name);\n }\n \n extern \"C\" LLVMValueRef\n-LLVMRustBuildInvoke(LLVMBuilderRef B,\n-                    LLVMValueRef Fn,\n-                    LLVMValueRef *Args,\n-                    unsigned NumArgs,\n-                    LLVMBasicBlockRef Then,\n-                    LLVMBasicBlockRef Catch,\n-                    void *Bundle,\n-                    const char *Name) {\n-    return LLVMBuildInvoke(B, Fn, Args, NumArgs, Then, Catch, Name);\n+LLVMRustBuildInvoke(LLVMBuilderRef B, LLVMValueRef Fn, LLVMValueRef *Args,\n+                    unsigned NumArgs, LLVMBasicBlockRef Then,\n+                    LLVMBasicBlockRef Catch, void *Bundle, const char *Name) {\n+  return LLVMBuildInvoke(B, Fn, Args, NumArgs, Then, Catch, Name);\n }\n #endif\n \n-extern \"C\" void LLVMRustPositionBuilderAtStart(LLVMBuilderRef B, LLVMBasicBlockRef BB) {\n-    auto point = unwrap(BB)->getFirstInsertionPt();\n-    unwrap(B)->SetInsertPoint(unwrap(BB), point);\n+extern \"C\" void LLVMRustPositionBuilderAtStart(LLVMBuilderRef B,\n+                                               LLVMBasicBlockRef BB) {\n+  auto point = unwrap(BB)->getFirstInsertionPt();\n+  unwrap(B)->SetInsertPoint(unwrap(BB), point);\n }\n \n-extern \"C\" void LLVMRustSetComdat(LLVMModuleRef M, LLVMValueRef V, const char *Name) {\n-    Triple TargetTriple(unwrap(M)->getTargetTriple());\n-    GlobalObject *GV = unwrap<GlobalObject>(V);\n-    if (!TargetTriple.isOSBinFormatMachO()) {\n-        GV->setComdat(unwrap(M)->getOrInsertComdat(Name));\n-    }\n+extern \"C\" void LLVMRustSetComdat(LLVMModuleRef M, LLVMValueRef V,\n+                                  const char *Name) {\n+  Triple TargetTriple(unwrap(M)->getTargetTriple());\n+  GlobalObject *GV = unwrap<GlobalObject>(V);\n+  if (!TargetTriple.isOSBinFormatMachO()) {\n+    GV->setComdat(unwrap(M)->getOrInsertComdat(Name));\n+  }\n }\n \n extern \"C\" void LLVMRustUnsetComdat(LLVMValueRef V) {\n-    GlobalObject *GV = unwrap<GlobalObject>(V);\n-    GV->setComdat(nullptr);\n+  GlobalObject *GV = unwrap<GlobalObject>(V);\n+  GV->setComdat(nullptr);\n }\n \n enum class LLVMRustLinkage {\n-    ExternalLinkage = 0,\n-    AvailableExternallyLinkage = 1,\n-    LinkOnceAnyLinkage = 2,\n-    LinkOnceODRLinkage = 3,\n-    WeakAnyLinkage = 4,\n-    WeakODRLinkage = 5,\n-    AppendingLinkage = 6,\n-    InternalLinkage = 7,\n-    PrivateLinkage = 8,\n-    ExternalWeakLinkage = 9,\n-    CommonLinkage = 10,\n+  ExternalLinkage = 0,\n+  AvailableExternallyLinkage = 1,\n+  LinkOnceAnyLinkage = 2,\n+  LinkOnceODRLinkage = 3,\n+  WeakAnyLinkage = 4,\n+  WeakODRLinkage = 5,\n+  AppendingLinkage = 6,\n+  InternalLinkage = 7,\n+  PrivateLinkage = 8,\n+  ExternalWeakLinkage = 9,\n+  CommonLinkage = 10,\n };\n \n static LLVMRustLinkage to_rust(LLVMLinkage linkage) {\n-    switch (linkage) {\n-        case LLVMExternalLinkage:\n-            return LLVMRustLinkage::ExternalLinkage;\n-        case LLVMAvailableExternallyLinkage:\n-            return LLVMRustLinkage::AvailableExternallyLinkage;\n-        case LLVMLinkOnceAnyLinkage:\n-            return LLVMRustLinkage::LinkOnceAnyLinkage;\n-        case LLVMLinkOnceODRLinkage:\n-            return LLVMRustLinkage::LinkOnceODRLinkage;\n-        case LLVMWeakAnyLinkage:\n-            return LLVMRustLinkage::WeakAnyLinkage;\n-        case LLVMWeakODRLinkage:\n-            return LLVMRustLinkage::WeakODRLinkage;\n-        case LLVMAppendingLinkage:\n-            return LLVMRustLinkage::AppendingLinkage;\n-        case LLVMInternalLinkage:\n-            return LLVMRustLinkage::InternalLinkage;\n-        case LLVMPrivateLinkage:\n-            return LLVMRustLinkage::PrivateLinkage;\n-        case LLVMExternalWeakLinkage:\n-            return LLVMRustLinkage::ExternalWeakLinkage;\n-        case LLVMCommonLinkage:\n-            return LLVMRustLinkage::CommonLinkage;\n-        default:\n-            llvm_unreachable(\"Invalid LLVMRustLinkage value!\");\n-    }\n+  switch (linkage) {\n+  case LLVMExternalLinkage:\n+    return LLVMRustLinkage::ExternalLinkage;\n+  case LLVMAvailableExternallyLinkage:\n+    return LLVMRustLinkage::AvailableExternallyLinkage;\n+  case LLVMLinkOnceAnyLinkage:\n+    return LLVMRustLinkage::LinkOnceAnyLinkage;\n+  case LLVMLinkOnceODRLinkage:\n+    return LLVMRustLinkage::LinkOnceODRLinkage;\n+  case LLVMWeakAnyLinkage:\n+    return LLVMRustLinkage::WeakAnyLinkage;\n+  case LLVMWeakODRLinkage:\n+    return LLVMRustLinkage::WeakODRLinkage;\n+  case LLVMAppendingLinkage:\n+    return LLVMRustLinkage::AppendingLinkage;\n+  case LLVMInternalLinkage:\n+    return LLVMRustLinkage::InternalLinkage;\n+  case LLVMPrivateLinkage:\n+    return LLVMRustLinkage::PrivateLinkage;\n+  case LLVMExternalWeakLinkage:\n+    return LLVMRustLinkage::ExternalWeakLinkage;\n+  case LLVMCommonLinkage:\n+    return LLVMRustLinkage::CommonLinkage;\n+  default:\n+    llvm_unreachable(\"Invalid LLVMRustLinkage value!\");\n+  }\n }\n \n static LLVMLinkage from_rust(LLVMRustLinkage linkage) {\n-    switch (linkage) {\n-        case LLVMRustLinkage::ExternalLinkage:\n-            return LLVMExternalLinkage;\n-        case LLVMRustLinkage::AvailableExternallyLinkage:\n-            return LLVMAvailableExternallyLinkage;\n-        case LLVMRustLinkage::LinkOnceAnyLinkage:\n-            return LLVMLinkOnceAnyLinkage;\n-        case LLVMRustLinkage::LinkOnceODRLinkage:\n-            return LLVMLinkOnceODRLinkage;\n-        case LLVMRustLinkage::WeakAnyLinkage:\n-            return LLVMWeakAnyLinkage;\n-        case LLVMRustLinkage::WeakODRLinkage:\n-            return LLVMWeakODRLinkage;\n-        case LLVMRustLinkage::AppendingLinkage:\n-            return LLVMAppendingLinkage;\n-        case LLVMRustLinkage::InternalLinkage:\n-            return LLVMInternalLinkage;\n-        case LLVMRustLinkage::PrivateLinkage:\n-            return LLVMPrivateLinkage;\n-        case LLVMRustLinkage::ExternalWeakLinkage:\n-            return LLVMExternalWeakLinkage;\n-        case LLVMRustLinkage::CommonLinkage:\n-            return LLVMCommonLinkage;\n-        default:\n-            llvm_unreachable(\"Invalid LLVMRustLinkage value!\");\n-    }\n+  switch (linkage) {\n+  case LLVMRustLinkage::ExternalLinkage:\n+    return LLVMExternalLinkage;\n+  case LLVMRustLinkage::AvailableExternallyLinkage:\n+    return LLVMAvailableExternallyLinkage;\n+  case LLVMRustLinkage::LinkOnceAnyLinkage:\n+    return LLVMLinkOnceAnyLinkage;\n+  case LLVMRustLinkage::LinkOnceODRLinkage:\n+    return LLVMLinkOnceODRLinkage;\n+  case LLVMRustLinkage::WeakAnyLinkage:\n+    return LLVMWeakAnyLinkage;\n+  case LLVMRustLinkage::WeakODRLinkage:\n+    return LLVMWeakODRLinkage;\n+  case LLVMRustLinkage::AppendingLinkage:\n+    return LLVMAppendingLinkage;\n+  case LLVMRustLinkage::InternalLinkage:\n+    return LLVMInternalLinkage;\n+  case LLVMRustLinkage::PrivateLinkage:\n+    return LLVMPrivateLinkage;\n+  case LLVMRustLinkage::ExternalWeakLinkage:\n+    return LLVMExternalWeakLinkage;\n+  case LLVMRustLinkage::CommonLinkage:\n+    return LLVMCommonLinkage;\n+  default:\n+    llvm_unreachable(\"Invalid LLVMRustLinkage value!\");\n+  }\n }\n \n extern \"C\" LLVMRustLinkage LLVMRustGetLinkage(LLVMValueRef V) {\n-    return to_rust(LLVMGetLinkage(V));\n+  return to_rust(LLVMGetLinkage(V));\n+}\n+\n+extern \"C\" void LLVMRustSetLinkage(LLVMValueRef V,\n+                                   LLVMRustLinkage RustLinkage) {\n+  LLVMSetLinkage(V, from_rust(RustLinkage));\n }\n \n-extern \"C\" void LLVMRustSetLinkage(LLVMValueRef V, LLVMRustLinkage RustLinkage) {\n-    LLVMSetLinkage(V, from_rust(RustLinkage));\n+// Returns true if both high and low were successfully set. Fails in case constant wasn\u2019t any of\n+// the common sizes (1, 8, 16, 32, 64, 128 bits)\n+extern \"C\" bool LLVMRustConstInt128Get(LLVMValueRef CV, bool sext, uint64_t *high, uint64_t *low)\n+{\n+    auto C = unwrap<llvm::ConstantInt>(CV);\n+    if (C->getBitWidth() > 128) { return false; }\n+    APInt AP;\n+    if (sext) {\n+        AP = C->getValue().sextOrSelf(128);\n+    } else {\n+        AP = C->getValue().zextOrSelf(128);\n+    }\n+    *low = AP.getLoBits(64).getZExtValue();\n+    *high = AP.getHiBits(64).getZExtValue();\n+    return true;\n }\n \n extern \"C\" LLVMContextRef LLVMRustGetValueContext(LLVMValueRef V) {\n-    return wrap(&unwrap(V)->getContext());\n+  return wrap(&unwrap(V)->getContext());\n }\n \n enum class LLVMRustVisibility {\n-    Default = 0,\n-    Hidden = 1,\n-    Protected = 2,\n+  Default = 0,\n+  Hidden = 1,\n+  Protected = 2,\n };\n \n static LLVMRustVisibility to_rust(LLVMVisibility vis) {\n-    switch (vis) {\n-        case LLVMDefaultVisibility:\n-            return LLVMRustVisibility::Default;\n-        case LLVMHiddenVisibility:\n-            return LLVMRustVisibility::Hidden;\n-        case LLVMProtectedVisibility:\n-            return LLVMRustVisibility::Protected;\n-\n-        default:\n-            llvm_unreachable(\"Invalid LLVMRustVisibility value!\");\n-    }\n+  switch (vis) {\n+  case LLVMDefaultVisibility:\n+    return LLVMRustVisibility::Default;\n+  case LLVMHiddenVisibility:\n+    return LLVMRustVisibility::Hidden;\n+  case LLVMProtectedVisibility:\n+    return LLVMRustVisibility::Protected;\n+\n+  default:\n+    llvm_unreachable(\"Invalid LLVMRustVisibility value!\");\n+  }\n }\n \n static LLVMVisibility from_rust(LLVMRustVisibility vis) {\n-    switch (vis) {\n-        case LLVMRustVisibility::Default:\n-            return LLVMDefaultVisibility;\n-        case LLVMRustVisibility::Hidden:\n-            return LLVMHiddenVisibility;\n-        case LLVMRustVisibility::Protected:\n-            return LLVMProtectedVisibility;\n-\n-        default:\n-            llvm_unreachable(\"Invalid LLVMRustVisibility value!\");\n-    }\n+  switch (vis) {\n+  case LLVMRustVisibility::Default:\n+    return LLVMDefaultVisibility;\n+  case LLVMRustVisibility::Hidden:\n+    return LLVMHiddenVisibility;\n+  case LLVMRustVisibility::Protected:\n+    return LLVMProtectedVisibility;\n+\n+  default:\n+    llvm_unreachable(\"Invalid LLVMRustVisibility value!\");\n+  }\n }\n \n extern \"C\" LLVMRustVisibility LLVMRustGetVisibility(LLVMValueRef V) {\n-    return to_rust(LLVMGetVisibility(V));\n+  return to_rust(LLVMGetVisibility(V));\n }\n \n-extern \"C\" void LLVMRustSetVisibility(LLVMValueRef V, LLVMRustVisibility RustVisibility) {\n-    LLVMSetVisibility(V, from_rust(RustVisibility));\n+extern \"C\" void LLVMRustSetVisibility(LLVMValueRef V,\n+                                      LLVMRustVisibility RustVisibility) {\n+  LLVMSetVisibility(V, from_rust(RustVisibility));\n }"}, {"sha": "d296266be0f0f1672a972d30f83bdc12d0b7c673", "filename": "src/rustllvm/rustllvm.h", "status": "modified", "additions": 68, "deletions": 72, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Frustllvm%2Frustllvm.h", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Frustllvm%2Frustllvm.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2Frustllvm.h?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -8,50 +8,52 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+#include \"llvm-c/BitReader.h\"\n+#include \"llvm-c/Core.h\"\n+#include \"llvm-c/ExecutionEngine.h\"\n+#include \"llvm-c/Object.h\"\n+#include \"llvm/ADT/ArrayRef.h\"\n+#include \"llvm/ADT/DenseSet.h\"\n+#include \"llvm/ADT/Triple.h\"\n+#include \"llvm/Analysis/Lint.h\"\n+#include \"llvm/Analysis/Passes.h\"\n+#include \"llvm/ExecutionEngine/ExecutionEngine.h\"\n+#include \"llvm/ExecutionEngine/Interpreter.h\"\n+#include \"llvm/ExecutionEngine/MCJIT.h\"\n #include \"llvm/IR/IRBuilder.h\"\n #include \"llvm/IR/InlineAsm.h\"\n-#include \"llvm/IR/LLVMContext.h\"\n-#include \"llvm/IR/Module.h\"\n #include \"llvm/IR/InlineAsm.h\"\n #include \"llvm/IR/LLVMContext.h\"\n-#include \"llvm/Analysis/Passes.h\"\n-#include \"llvm/Analysis/Lint.h\"\n-#include \"llvm/ADT/ArrayRef.h\"\n-#include \"llvm/ADT/Triple.h\"\n-#include \"llvm/ADT/DenseSet.h\"\n+#include \"llvm/IR/LLVMContext.h\"\n+#include \"llvm/IR/Module.h\"\n #include \"llvm/Support/CommandLine.h\"\n-#include \"llvm/Support/FormattedStream.h\"\n-#include \"llvm/Support/Timer.h\"\n-#include \"llvm/Support/raw_ostream.h\"\n-#include \"llvm/Support/TargetSelect.h\"\n-#include \"llvm/Support/TargetRegistry.h\"\n-#include \"llvm/Support/SourceMgr.h\"\n-#include \"llvm/Support/Host.h\"\n #include \"llvm/Support/Debug.h\"\n #include \"llvm/Support/DynamicLibrary.h\"\n+#include \"llvm/Support/FormattedStream.h\"\n+#include \"llvm/Support/Host.h\"\n #include \"llvm/Support/Memory.h\"\n-#include \"llvm/ExecutionEngine/ExecutionEngine.h\"\n-#include \"llvm/ExecutionEngine/MCJIT.h\"\n-#include \"llvm/ExecutionEngine/Interpreter.h\"\n+#include \"llvm/Support/SourceMgr.h\"\n+#include \"llvm/Support/TargetRegistry.h\"\n+#include \"llvm/Support/TargetSelect.h\"\n+#include \"llvm/Support/Timer.h\"\n+#include \"llvm/Support/raw_ostream.h\"\n #include \"llvm/Target/TargetMachine.h\"\n #include \"llvm/Target/TargetOptions.h\"\n-#include \"llvm/Transforms/Scalar.h\"\n #include \"llvm/Transforms/IPO.h\"\n #include \"llvm/Transforms/Instrumentation.h\"\n+#include \"llvm/Transforms/Scalar.h\"\n #include \"llvm/Transforms/Vectorize.h\"\n-#include \"llvm-c/Core.h\"\n-#include \"llvm-c/BitReader.h\"\n-#include \"llvm-c/ExecutionEngine.h\"\n-#include \"llvm-c/Object.h\"\n \n-#define LLVM_VERSION_GE(major, minor) \\\n-  (LLVM_VERSION_MAJOR > (major) || LLVM_VERSION_MAJOR == (major) && LLVM_VERSION_MINOR >= (minor))\n+#define LLVM_VERSION_GE(major, minor)                                          \\\n+  (LLVM_VERSION_MAJOR > (major) ||                                             \\\n+   LLVM_VERSION_MAJOR == (major) && LLVM_VERSION_MINOR >= (minor))\n \n-#define LLVM_VERSION_EQ(major, minor) \\\n+#define LLVM_VERSION_EQ(major, minor)                                          \\\n   (LLVM_VERSION_MAJOR == (major) && LLVM_VERSION_MINOR == (minor))\n \n-#define LLVM_VERSION_LE(major, minor) \\\n-  (LLVM_VERSION_MAJOR < (major) || LLVM_VERSION_MAJOR == (major) && LLVM_VERSION_MINOR <= (minor))\n+#define LLVM_VERSION_LE(major, minor)                                          \\\n+  (LLVM_VERSION_MAJOR < (major) ||                                             \\\n+   LLVM_VERSION_MAJOR == (major) && LLVM_VERSION_MINOR <= (minor))\n \n #if LLVM_VERSION_GE(3, 7)\n #include \"llvm/IR/LegacyPassManager.h\"\n@@ -66,39 +68,36 @@\n #include \"llvm/Bitcode/ReaderWriter.h\"\n #endif\n \n-#include \"llvm/IR/IRPrintingPasses.h\"\n-#include \"llvm/IR/DebugInfo.h\"\n #include \"llvm/IR/DIBuilder.h\"\n+#include \"llvm/IR/DebugInfo.h\"\n+#include \"llvm/IR/IRPrintingPasses.h\"\n #include \"llvm/Linker/Linker.h\"\n \n-void LLVMRustSetLastError(const char*);\n+void LLVMRustSetLastError(const char *);\n \n-enum class LLVMRustResult {\n-    Success,\n-    Failure\n-};\n+enum class LLVMRustResult { Success, Failure };\n \n enum LLVMRustAttribute {\n-    AlwaysInline    = 0,\n-    ByVal           = 1,\n-    Cold            = 2,\n-    InlineHint      = 3,\n-    MinSize         = 4,\n-    Naked           = 5,\n-    NoAlias         = 6,\n-    NoCapture       = 7,\n-    NoInline        = 8,\n-    NonNull         = 9,\n-    NoRedZone       = 10,\n-    NoReturn        = 11,\n-    NoUnwind        = 12,\n-    OptimizeForSize = 13,\n-    ReadOnly        = 14,\n-    SExt            = 15,\n-    StructRet       = 16,\n-    UWTable         = 17,\n-    ZExt            = 18,\n-    InReg           = 19,\n+  AlwaysInline = 0,\n+  ByVal = 1,\n+  Cold = 2,\n+  InlineHint = 3,\n+  MinSize = 4,\n+  Naked = 5,\n+  NoAlias = 6,\n+  NoCapture = 7,\n+  NoInline = 8,\n+  NonNull = 9,\n+  NoRedZone = 10,\n+  NoReturn = 11,\n+  NoUnwind = 12,\n+  OptimizeForSize = 13,\n+  ReadOnly = 14,\n+  SExt = 15,\n+  StructRet = 16,\n+  UWTable = 17,\n+  ZExt = 18,\n+  InReg = 19,\n };\n \n typedef struct OpaqueRustString *RustStringRef;\n@@ -107,28 +106,25 @@ typedef struct LLVMOpaqueDebugLoc *LLVMDebugLocRef;\n typedef struct LLVMOpaqueSMDiagnostic *LLVMSMDiagnosticRef;\n typedef struct LLVMOpaqueRustJITMemoryManager *LLVMRustJITMemoryManagerRef;\n \n-extern \"C\" void\n-rust_llvm_string_write_impl(RustStringRef str, const char *ptr, size_t size);\n+extern \"C\" void rust_llvm_string_write_impl(RustStringRef str, const char *ptr,\n+                                            size_t size);\n \n-class raw_rust_string_ostream : public llvm::raw_ostream  {\n-    RustStringRef str;\n-    uint64_t pos;\n+class raw_rust_string_ostream : public llvm::raw_ostream {\n+  RustStringRef str;\n+  uint64_t pos;\n \n-    void write_impl(const char *ptr, size_t size) override {\n-        rust_llvm_string_write_impl(str, ptr, size);\n-        pos += size;\n-    }\n+  void write_impl(const char *ptr, size_t size) override {\n+    rust_llvm_string_write_impl(str, ptr, size);\n+    pos += size;\n+  }\n \n-    uint64_t current_pos() const override {\n-        return pos;\n-    }\n+  uint64_t current_pos() const override { return pos; }\n \n public:\n-    explicit raw_rust_string_ostream(RustStringRef str)\n-        : str(str), pos(0) { }\n+  explicit raw_rust_string_ostream(RustStringRef str) : str(str), pos(0) {}\n \n-    ~raw_rust_string_ostream() {\n-        // LLVM requires this.\n-        flush();\n-    }\n+  ~raw_rust_string_ostream() {\n+    // LLVM requires this.\n+    flush();\n+  }\n };"}, {"sha": "f3fb92e2b2206f5ddf47770edeed7d91531a3797", "filename": "src/test/compile-fail/const-tup-index-span.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Ftest%2Fcompile-fail%2Fconst-tup-index-span.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Ftest%2Fcompile-fail%2Fconst-tup-index-span.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fconst-tup-index-span.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -10,7 +10,7 @@\n \n // Test spans of errors\n \n-const TUP: (usize,) = 5 << 64;\n+const TUP: (usize,) = 5usize << 64;\n //~^ ERROR E0080\n //~| attempt to shift left with overflow\n const ARR: [i32; TUP.0] = [];"}, {"sha": "4a76d39921842b563377c01527e703052d99af26", "filename": "src/test/compile-fail/i128-feature-2.rs", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Ftest%2Fcompile-fail%2Fi128-feature-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Ftest%2Fcompile-fail%2Fi128-feature-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fi128-feature-2.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -0,0 +1,29 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+fn test1() -> i128 { //~ ERROR 128-bit type is unstable\n+    0\n+}\n+\n+fn test1_2() -> u128 { //~ ERROR 128-bit type is unstable\n+    0\n+}\n+\n+fn test3() {\n+    let x: i128 = 0; //~ ERROR 128-bit type is unstable\n+}\n+\n+fn test3_2() {\n+    let x: u128 = 0; //~ ERROR 128-bit type is unstable\n+}\n+\n+#[repr(u128)]\n+enum A { //~ ERROR 128-bit type is unstable\n+    A(u64)\n+}"}, {"sha": "87dda469f93900a29076c0b5f2661f80c8f46aa4", "filename": "src/test/compile-fail/i128-feature.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Ftest%2Fcompile-fail%2Fi128-feature.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Ftest%2Fcompile-fail%2Fi128-feature.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fi128-feature.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+fn test2() {\n+    0i128; //~ ERROR 128-bit integers are not stable\n+}\n+\n+fn test2_2() {\n+    0u128; //~ ERROR 128-bit integers are not stable\n+}\n+"}, {"sha": "501f4451ed8d51b6982f001ec10ddc214210001c", "filename": "src/test/compile-fail/unadjusted-unstable.rs", "status": "renamed", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Ftest%2Fcompile-fail%2Funadjusted-unstable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Ftest%2Fcompile-fail%2Funadjusted-unstable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Funadjusted-unstable.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2012 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -8,6 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+extern \"unadjusted\" fn foo() {\n+//~^ ERROR: unadjusted ABI is an implementation detail and perma-unstable\n+}\n+\n fn main() {\n-    println!(\"{}\", 18446744073709551616u64);  //~ error: int literal is too large\n+    foo();\n }", "previous_filename": "src/test/compile-fail/oversized-literal.rs"}, {"sha": "1af8df7d2f64441f3a56e64d700d9dd90c6bb5bd", "filename": "src/test/parse-fail/int-literal-too-large-span.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Ftest%2Fparse-fail%2Fint-literal-too-large-span.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Ftest%2Fparse-fail%2Fint-literal-too-large-span.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fint-literal-too-large-span.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -13,7 +13,7 @@\n // issue #17123\n \n fn main() {\n-    100000000000000000000000000000000 //~ ERROR int literal is too large\n-\n+    9999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999999\n+    //~^ ERROR int literal is too large\n         ; // the span shouldn't point to this.\n }"}, {"sha": "cf1500e34d874ad279ac6e81fde6392d8144e916", "filename": "src/test/parse-fail/issue-5544-a.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Ftest%2Fparse-fail%2Fissue-5544-a.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Ftest%2Fparse-fail%2Fissue-5544-a.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fissue-5544-a.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -11,6 +11,6 @@\n // compile-flags: -Z parse-only\n \n fn main() {\n-    let __isize = 18446744073709551616; // 2^64\n+    let __isize = 340282366920938463463374607431768211456; // 2^128\n     //~^ ERROR int literal is too large\n }"}, {"sha": "8c0b6741cb80428c63546fff07f0ac3a31f8dcea", "filename": "src/test/parse-fail/issue-5544-b.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Ftest%2Fparse-fail%2Fissue-5544-b.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Ftest%2Fparse-fail%2Fissue-5544-b.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Fissue-5544-b.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -11,6 +11,6 @@\n // compile-flags: -Z parse-only\n \n fn main() {\n-    let __isize = 0xff_ffff_ffff_ffff_ffff;\n+    let __isize = 0xffff_ffff_ffff_ffff_ffff_ffff_ffff_ffff_ff;\n     //~^ ERROR int literal is too large\n }"}, {"sha": "d495a8edd09a4c2d393cc3de7505be9d52accf33", "filename": "src/test/parse-fail/lex-bad-numeric-literals.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Ftest%2Fparse-fail%2Flex-bad-numeric-literals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Ftest%2Fparse-fail%2Flex-bad-numeric-literals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fparse-fail%2Flex-bad-numeric-literals.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -23,8 +23,8 @@ fn main() {\n     0o; //~ ERROR: no valid digits\n     1e+; //~ ERROR: expected at least one digit in exponent\n     0x539.0; //~ ERROR: hexadecimal float literal is not supported\n-    99999999999999999999999999999999; //~ ERROR: int literal is too large\n-    99999999999999999999999999999999; //~ ERROR: int literal is too large\n+    9900000000000000000000000000999999999999999999999999999999; //~ ERROR: int literal is too large\n+    9900000000000000000000000000999999999999999999999999999999; //~ ERROR: int literal is too large\n     0x; //~ ERROR: no valid digits\n     0xu32; //~ ERROR: no valid digits\n     0ou32; //~ ERROR: no valid digits"}, {"sha": "a9257cb4c8b789f9c08119172be6baffe4a6f75c", "filename": "src/test/run-pass-fulldeps/proc-macro/auxiliary/derive-nothing.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fderive-nothing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fderive-nothing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fauxiliary%2Fderive-nothing.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// no-prefer-dynamic\n+\n+#![crate_type = \"proc-macro\"]\n+#![feature(proc_macro)]\n+#![feature(proc_macro_lib)]\n+\n+extern crate proc_macro;\n+\n+use proc_macro::TokenStream;\n+\n+#[proc_macro_derive(Nothing)]\n+pub fn nothing(input: TokenStream) -> TokenStream {\n+    \"\".parse().unwrap()\n+}"}, {"sha": "818308b05a44e7170bf5ace803b6cd3b29cfd8af", "filename": "src/test/run-pass-fulldeps/proc-macro/struct-field-macro.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fstruct-field-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fstruct-field-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass-fulldeps%2Fproc-macro%2Fstruct-field-macro.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// aux-build:derive-nothing.rs\n+// ignore-stage1\n+\n+#![feature(proc_macro)]\n+\n+#[macro_use]\n+extern crate derive_nothing;\n+\n+macro_rules! int {\n+    () => { i32 }\n+}\n+\n+#[derive(Nothing)]\n+struct S {\n+    x: int!(),\n+}\n+\n+fn main() {}"}, {"sha": "b7aeb21229ccb6f33528473140368d0c8b4afc8e", "filename": "src/test/run-pass/i128.rs", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Ftest%2Frun-pass%2Fi128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Ftest%2Frun-pass%2Fi128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fi128.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -0,0 +1,99 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-stage0\n+// ignore-stage1\n+#![feature(i128_type, test)]\n+\n+extern crate test;\n+use test::black_box as b;\n+\n+fn main() {\n+    let x: i128 = -1;\n+    assert_eq!(0, !x);\n+    let y: i128 = -2;\n+    assert_eq!(!1, y);\n+    let z: i128 = 0xABCD_EF;\n+    assert_eq!(z * z, 0x734C_C2F2_A521);\n+    assert_eq!(z * z * z * z, 0x33EE_0E2A_54E2_59DA_A0E7_8E41);\n+    assert_eq!(-z * -z, 0x734C_C2F2_A521);\n+    assert_eq!(-z * -z * -z * -z, 0x33EE_0E2A_54E2_59DA_A0E7_8E41);\n+    assert_eq!(-z + -z + -z + -z, -0x2AF3_7BC);\n+    let k: i128 = -0x1234_5678_9ABC_DEFF_EDCB_A987_6543_210;\n+    assert_eq!(k + k, -0x2468_ACF1_3579_BDFF_DB97_530E_CA86_420);\n+    assert_eq!(0, k - k);\n+    assert_eq!(-0x1234_5678_9ABC_DEFF_EDCB_A987_5A86_421, k + z);\n+    assert_eq!(-0x1000_0000_0000_0000_0000_0000_0000_000,\n+               k + 0x234_5678_9ABC_DEFF_EDCB_A987_6543_210);\n+    assert_eq!(-0x6EF5_DE4C_D3BC_2AAA_3BB4_CC5D_D6EE_8, k / 42);\n+    assert_eq!(-k, k / -1);\n+    assert_eq!(-0x91A2_B3C4_D5E6_F8, k >> 65);\n+    assert_eq!(-0xFDB9_7530_ECA8_6420_0000_0000_0000_0000, k << 65);\n+    assert!(k < z);\n+    assert!(y > k);\n+    assert!(y < x);\n+    assert_eq!(x as i64, -1);\n+    assert_eq!(z as i64, 0xABCD_EF);\n+    assert_eq!(k as i64, -0xFEDC_BA98_7654_3210);\n+    assert_eq!(k as u128, 0xFEDC_BA98_7654_3210_0123_4567_89AB_CDF0);\n+    assert_eq!(-k as u128, 0x1234_5678_9ABC_DEFF_EDCB_A987_6543_210);\n+    assert_eq!((-z as f64) as i128, -z);\n+    assert_eq!((-z as f32) as i128, -z);\n+    assert_eq!((-z as f64 * 16.0) as i128, -z * 16);\n+    assert_eq!((-z as f32 * 16.0) as i128, -z * 16);\n+    // Same stuff as above, but blackboxed, to force use of intrinsics\n+    let x: i128 = b(-1);\n+    assert_eq!(0, !x);\n+    let y: i128 = b(-2);\n+    assert_eq!(!1, y);\n+    let z: i128 = b(0xABCD_EF);\n+    assert_eq!(z * z, 0x734C_C2F2_A521);\n+    assert_eq!(z * z * z * z, 0x33EE_0E2A_54E2_59DA_A0E7_8E41);\n+    assert_eq!(-z * -z, 0x734C_C2F2_A521);\n+    assert_eq!(-z * -z * -z * -z, 0x33EE_0E2A_54E2_59DA_A0E7_8E41);\n+    assert_eq!(-z + -z + -z + -z, -0x2AF3_7BC);\n+    let k: i128 = b(-0x1234_5678_9ABC_DEFF_EDCB_A987_6543_210);\n+    assert_eq!(k + k, -0x2468_ACF1_3579_BDFF_DB97_530E_CA86_420);\n+    assert_eq!(0, k - k);\n+    assert_eq!(-0x1234_5678_9ABC_DEFF_EDCB_A987_5A86_421, k + z);\n+    assert_eq!(-0x1000_0000_0000_0000_0000_0000_0000_000,\n+               k + 0x234_5678_9ABC_DEFF_EDCB_A987_6543_210);\n+    assert_eq!(-0x6EF5_DE4C_D3BC_2AAA_3BB4_CC5D_D6EE_8, k / 42);\n+    assert_eq!(-k, k / -1);\n+    assert_eq!(-0x91A2_B3C4_D5E6_F8, k >> 65);\n+    assert_eq!(-0xFDB9_7530_ECA8_6420_0000_0000_0000_0000, k << 65);\n+    assert!(k < z);\n+    assert!(y > k);\n+    assert!(y < x);\n+    assert_eq!(x as i64, -1);\n+    assert_eq!(z as i64, 0xABCD_EF);\n+    assert_eq!(k as i64, -0xFEDC_BA98_7654_3210);\n+    assert_eq!(k as u128, 0xFEDC_BA98_7654_3210_0123_4567_89AB_CDF0);\n+    assert_eq!(-k as u128, 0x1234_5678_9ABC_DEFF_EDCB_A987_6543_210);\n+    assert_eq!((-z as f64) as i128, -z);\n+    assert_eq!((-z as f32) as i128, -z);\n+    assert_eq!((-z as f64 * 16.0) as i128, -z * 16);\n+    assert_eq!((-z as f32 * 16.0) as i128, -z * 16);\n+    // formatting\n+    let j: i128 = -(1 << 67);\n+    assert_eq!(\"-147573952589676412928\", format!(\"{}\", j));\n+    assert_eq!(\"fffffffffffffff80000000000000000\", format!(\"{:x}\", j));\n+    assert_eq!(\"3777777777777777777760000000000000000000000\", format!(\"{:o}\", j));\n+    assert_eq!(\"1111111111111111111111111111111111111111111111111111111111111\\\n+                0000000000000000000000000000000000000000000000000000000000000000000\",\n+               format!(\"{:b}\", j));\n+    assert_eq!(\"-147573952589676412928\", format!(\"{:?}\", j));\n+    // common traits\n+    assert_eq!(x, b(x.clone()));\n+    // overflow checks\n+    assert_eq!((-z).checked_mul(-z), Some(0x734C_C2F2_A521));\n+    assert_eq!((z).checked_mul(z), Some(0x734C_C2F2_A521));\n+    assert_eq!((k).checked_mul(k), None);\n+}"}, {"sha": "d138e09318bfe3ce1b1ae681041cc658f0732b24", "filename": "src/test/run-pass/u128.rs", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Ftest%2Frun-pass%2Fu128.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Ftest%2Frun-pass%2Fu128.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fu128.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -0,0 +1,67 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-stage0\n+// ignore-stage1\n+#![feature(i128_type)]\n+\n+fn main() {\n+    let x: u128 = 0xFFFF_FFFF_FFFF_FFFF__FFFF_FFFF_FFFF_FFFF;\n+    assert_eq!(0, !x);\n+    assert_eq!(0, !x);\n+    let y: u128 = 0xFFFF_FFFF_FFFF_FFFF__FFFF_FFFF_FFFF_FFFE;\n+    assert_eq!(!1, y);\n+    assert_eq!(x, y | 1);\n+    assert_eq!(0xFAFF_0000_FF8F_0000__FFFF_0000_FFFF_FFFE,\n+               y &\n+               0xFAFF_0000_FF8F_0000__FFFF_0000_FFFF_FFFF);\n+    let z: u128 = 0xABCD_EF;\n+    assert_eq!(z * z, 0x734C_C2F2_A521);\n+    assert_eq!(z * z * z * z, 0x33EE_0E2A_54E2_59DA_A0E7_8E41);\n+    assert_eq!(z + z + z + z, 0x2AF3_7BC);\n+    let k: u128 = 0x1234_5678_9ABC_DEFF_EDCB_A987_6543_210;\n+    assert_eq!(k + k, 0x2468_ACF1_3579_BDFF_DB97_530E_CA86_420);\n+    assert_eq!(0, k - k);\n+    assert_eq!(0x1234_5678_9ABC_DEFF_EDCB_A987_5A86_421, k - z);\n+    assert_eq!(0x1000_0000_0000_0000_0000_0000_0000_000,\n+               k - 0x234_5678_9ABC_DEFF_EDCB_A987_6543_210);\n+    assert_eq!(0x6EF5_DE4C_D3BC_2AAA_3BB4_CC5D_D6EE_8, k / 42);\n+    assert_eq!(0, k % 42);\n+    assert_eq!(15, z % 42);\n+    assert_eq!(0x169D_A8020_CEC18, k % 0x3ACB_FE49_FF24_AC);\n+    assert_eq!(0x91A2_B3C4_D5E6_F7, k >> 65);\n+    assert_eq!(0xFDB9_7530_ECA8_6420_0000_0000_0000_0000, k << 65);\n+    assert!(k > z);\n+    assert!(y > k);\n+    assert!(y < x);\n+    assert_eq!(x as u64, !0);\n+    assert_eq!(z as u64, 0xABCD_EF);\n+    assert_eq!(k as u64, 0xFEDC_BA98_7654_3210);\n+    assert_eq!(k as i128, 0x1234_5678_9ABC_DEFF_EDCB_A987_6543_210);\n+    assert_eq!((z as f64) as u128, z);\n+    assert_eq!((z as f32) as u128, z);\n+    assert_eq!((z as f64 * 16.0) as u128, z * 16);\n+    assert_eq!((z as f32 * 16.0) as u128, z * 16);\n+    let l :u128 = 432 << 100;\n+    assert_eq!((l as f32) as u128, l);\n+    assert_eq!((l as f64) as u128, l);\n+    // formatting\n+    let j: u128 = 1 << 67;\n+    assert_eq!(\"147573952589676412928\", format!(\"{}\", j));\n+    assert_eq!(\"80000000000000000\", format!(\"{:x}\", j));\n+    assert_eq!(\"20000000000000000000000\", format!(\"{:o}\", j));\n+    assert_eq!(\"10000000000000000000000000000000000000000000000000000000000000000000\",\n+               format!(\"{:b}\", j));\n+    assert_eq!(\"340282366920938463463374607431768211455\",\n+        format!(\"{}\", u128::max_value()));\n+    assert_eq!(\"147573952589676412928\", format!(\"{:?}\", j));\n+    // common traits\n+    x.clone();\n+}"}, {"sha": "f71ef126b64d9556914558d4ffb6c2b9316b0d6b", "filename": "src/test/ui/codemap_tests/unicode.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Ftest%2Fui%2Fcodemap_tests%2Funicode.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Ftest%2Fui%2Fcodemap_tests%2Funicode.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcodemap_tests%2Funicode.stderr?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -1,4 +1,4 @@\n-error: invalid ABI: expected one of [cdecl, stdcall, fastcall, vectorcall, aapcs, win64, sysv64, Rust, C, system, rust-intrinsic, rust-call, platform-intrinsic], found `\u8def\u6feb\u72fc\u00e1\u0301\u0301`\n+error: invalid ABI: expected one of [cdecl, stdcall, fastcall, vectorcall, aapcs, win64, sysv64, ptx-kernel, Rust, C, system, rust-intrinsic, rust-call, platform-intrinsic, unadjusted], found `\u8def\u6feb\u72fc\u00e1\u0301\u0301`\n   --> $DIR/unicode.rs:11:8\n    |\n 11 | extern \"\u8def\u6feb\u72fc\u00e1\u0301\u0301\" fn foo() {}"}, {"sha": "8a891d624f4028f884fa6c35ea1f7cd0addaad1a", "filename": "src/tools/cargotest/main.rs", "status": "modified", "additions": 38, "deletions": 13, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Ftools%2Fcargotest%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Ftools%2Fcargotest%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcargotest%2Fmain.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -21,19 +21,44 @@ struct Test {\n     lock: Option<&'static str>,\n }\n \n-const TEST_REPOS: &'static [Test] = &[Test {\n-                                          name: \"cargo\",\n-                                          repo: \"https://github.com/rust-lang/cargo\",\n-                                          sha: \"b7be4f2ef2cf743492edc6dfb55d087ed88f2d76\",\n-                                          lock: None,\n-                                      },\n-                                      Test {\n-                                          name: \"iron\",\n-                                          repo: \"https://github.com/iron/iron\",\n-                                          sha: \"16c858ec2901e2992fe5e529780f59fa8ed12903\",\n-                                          lock: Some(include_str!(\"lockfiles/iron-Cargo.lock\")),\n-                                      }];\n-\n+const TEST_REPOS: &'static [Test] = &[\n+    Test {\n+        name: \"cargo\",\n+        repo: \"https://github.com/rust-lang/cargo\",\n+        sha: \"b7be4f2ef2cf743492edc6dfb55d087ed88f2d76\",\n+        lock: None,\n+    },\n+    Test {\n+        name: \"iron\",\n+        repo: \"https://github.com/iron/iron\",\n+        sha: \"16c858ec2901e2992fe5e529780f59fa8ed12903\",\n+        lock: Some(include_str!(\"lockfiles/iron-Cargo.lock\")),\n+    },\n+    Test {\n+        name: \"ripgrep\",\n+        repo: \"https://github.com/BurntSushi/ripgrep\",\n+        sha: \"b65bb37b14655e1a89c7cd19c8b011ef3e312791\",\n+        lock: None,\n+    },\n+    Test {\n+        name: \"tokei\",\n+        repo: \"https://github.com/Aaronepower/tokei\",\n+        sha: \"5e11c4852fe4aa086b0e4fe5885822fbe57ba928\",\n+        lock: None,\n+    },\n+    Test {\n+        name: \"treeify\",\n+        repo: \"https://github.com/dzamlo/treeify\",\n+        sha: \"999001b223152441198f117a68fb81f57bc086dd\",\n+        lock: None,\n+    },\n+    Test {\n+        name: \"xsv\",\n+        repo: \"https://github.com/BurntSushi/xsv\",\n+        sha: \"a9a7163f2a2953cea426fee1216bec914fe2f56a\",\n+        lock: None,\n+    },\n+];\n \n fn main() {\n     // One of the projects being tested here is Cargo, and when being tested"}, {"sha": "2982f29f931c326087a89540866dc2e084a4819e", "filename": "src/tools/compiletest/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Ftools%2Fcompiletest%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Ftools%2Fcompiletest%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2FCargo.toml?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -7,4 +7,4 @@ build = \"build.rs\"\n [dependencies]\n log = \"0.3\"\n env_logger = { version = \"0.3.5\", default-features = false }\n-serialize = { path = \"../../libserialize\" }\n+rustc-serialize = \"0.3\""}, {"sha": "f6c8393ac215432cdd83c3437a19331288d3b37f", "filename": "src/tools/compiletest/src/main.rs", "status": "modified", "additions": 21, "deletions": 1, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fmain.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -21,6 +21,10 @@\n extern crate libc;\n extern crate test;\n extern crate getopts;\n+\n+#[cfg(cargobuild)]\n+extern crate rustc_serialize;\n+#[cfg(not(cargobuild))]\n extern crate serialize as rustc_serialize;\n \n #[macro_use]\n@@ -261,7 +265,23 @@ pub fn run_tests(config: &Config) {\n         // android debug-info test uses remote debugger\n         // so, we test 1 thread at once.\n         // also trying to isolate problems with adb_run_wrapper.sh ilooping\n-        env::set_var(\"RUST_TEST_THREADS\",\"1\");\n+        match config.mode {\n+            // These tests don't actually run code or don't run for android, so\n+            // we don't need to limit ourselves there\n+            Mode::Ui |\n+            Mode::CompileFail |\n+            Mode::ParseFail |\n+            Mode::RunMake |\n+            Mode::Codegen |\n+            Mode::CodegenUnits |\n+            Mode::Pretty |\n+            Mode::Rustdoc => {}\n+\n+            _ => {\n+                env::set_var(\"RUST_TEST_THREADS\", \"1\");\n+            }\n+\n+        }\n     }\n \n     match config.mode {"}, {"sha": "05f9beca3d11aa1948284a08c5cc92384bab55a1", "filename": "src/tools/compiletest/src/runtest.rs", "status": "modified", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fcompiletest%2Fsrc%2Fruntest.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -1619,10 +1619,48 @@ actual:\\n\\\n     }\n \n     fn fatal_proc_rec(&self, err: &str, proc_res: &ProcRes) -> ! {\n+        self.try_print_open_handles();\n         self.error(err);\n         proc_res.fatal(None);\n     }\n \n+    // This function is a poor man's attempt to debug rust-lang/rust#38620, if\n+    // that's closed then this should be deleted\n+    //\n+    // This is a very \"opportunistic\" debugging attempt, so we ignore all\n+    // errors here.\n+    fn try_print_open_handles(&self) {\n+        if !cfg!(windows) {\n+            return\n+        }\n+        if self.config.mode != Incremental {\n+            return\n+        }\n+\n+        let filename = match self.testpaths.file.file_stem() {\n+            Some(path) => path,\n+            None => return,\n+        };\n+\n+        let mut cmd = Command::new(\"handle.exe\");\n+        cmd.arg(\"-a\").arg(\"-u\");\n+        cmd.arg(filename);\n+        cmd.arg(\"-nobanner\");\n+        let output = match cmd.output() {\n+            Ok(output) => output,\n+            Err(_) => return,\n+        };\n+        println!(\"---------------------------------------------------\");\n+        println!(\"ran extra command to debug rust-lang/rust#38620: \");\n+        println!(\"{:?}\", cmd);\n+        println!(\"result: {}\", output.status);\n+        println!(\"--- stdout ----------------------------------------\");\n+        println!(\"{}\", String::from_utf8_lossy(&output.stdout));\n+        println!(\"--- stderr ----------------------------------------\");\n+        println!(\"{}\", String::from_utf8_lossy(&output.stderr));\n+        println!(\"---------------------------------------------------\");\n+    }\n+\n     fn _arm_exec_compiled_test(&self, env: Vec<(String, String)>) -> ProcRes {\n         let args = self.make_run_args();\n         let cmdline = self.make_cmdline(\"\", &args.prog, &args.args);"}, {"sha": "3808c05c6b9398a95f86db47e493db3a26a29206", "filename": "src/tools/tidy/src/pal.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b14785d3d0e3093983f6d6e266b754e1b536da10/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Ftidy%2Fsrc%2Fpal.rs?ref=b14785d3d0e3093983f6d6e266b754e1b536da10", "patch": "@@ -26,6 +26,7 @@\n //! exceptions:\n //!\n //! - core may not have platform-specific code\n+//! - libcompiler_builtins may have platform-specific code\n //! - liballoc_system may have platform-specific code\n //! - liballoc_jemalloc may have platform-specific code\n //! - libpanic_abort may have platform-specific code\n@@ -53,6 +54,7 @@ const EXCEPTION_PATHS: &'static [&'static str] = &[\n     // std crates\n     \"src/liballoc_jemalloc\",\n     \"src/liballoc_system\",\n+    \"src/libcompiler_builtins\",\n     \"src/liblibc\",\n     \"src/libpanic_abort\",\n     \"src/libpanic_unwind\","}]}