{"sha": "5486a860f1d9cf5862beacf3ceace9e84e170f85", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU0ODZhODYwZjFkOWNmNTg2MmJlYWNmM2NlYWNlOWU4NGUxNzBmODU=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2019-06-10T15:46:53Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2019-06-11T23:07:32Z"}, "message": "propagate depth that was reached, not just whether there was a cycle\n\nI tried to propagate this information with the return value, but I\nfound a curiosity (actually, something that I'm not keen on in\ngeneral) -- in particular, the candidate cache urrently invokes\nevaluation, which may detect a cycle, but the \"depth\" that results\nfrom that are is easily propagated back out. This probably means that\nthe candidate caching mechanism *itself* is sort of problematic, but\nI'm choosing to ignore that in favor of a more ambitious rewrite\nlater.", "tree": {"sha": "b0ec1605726ccd3b54e9971d52d91c439250d181", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b0ec1605726ccd3b54e9971d52d91c439250d181"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5486a860f1d9cf5862beacf3ceace9e84e170f85", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5486a860f1d9cf5862beacf3ceace9e84e170f85", "html_url": "https://github.com/rust-lang/rust/commit/5486a860f1d9cf5862beacf3ceace9e84e170f85", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5486a860f1d9cf5862beacf3ceace9e84e170f85/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e64a7bf64b70a9630d1ba8741665158d91f4cca7", "url": "https://api.github.com/repos/rust-lang/rust/commits/e64a7bf64b70a9630d1ba8741665158d91f4cca7", "html_url": "https://github.com/rust-lang/rust/commit/e64a7bf64b70a9630d1ba8741665158d91f4cca7"}], "stats": {"total": 61, "additions": 43, "deletions": 18}, "files": [{"sha": "7f9a7aaebf39cb6d855ec8514eec24a14833eb41", "filename": "src/librustc/traits/select.rs", "status": "modified", "additions": 43, "deletions": 18, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/5486a860f1d9cf5862beacf3ceace9e84e170f85/src%2Flibrustc%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5486a860f1d9cf5862beacf3ceace9e84e170f85/src%2Flibrustc%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fselect.rs?ref=5486a860f1d9cf5862beacf3ceace9e84e170f85", "patch": "@@ -154,12 +154,12 @@ struct TraitObligationStack<'prev, 'tcx: 'prev> {\n     /// selection-context's freshener. Used to check for recursion.\n     fresh_trait_ref: ty::PolyTraitRef<'tcx>,\n \n-    /// Starts out as false -- if, during evaluation, we encounter a\n-    /// cycle, then we will set this flag to true for all participants\n-    /// in the cycle (apart from the \"head\" node). These participants\n-    /// will then forego caching their results. This is not the most\n-    /// efficient solution, but it addresses #60010. The problem we\n-    /// are trying to prevent:\n+    /// Starts out equal to `depth` -- if, during evaluation, we\n+    /// encounter a cycle, then we will set this flag to the minimum\n+    /// depth of that cycle for all participants in the cycle. These\n+    /// participants will then forego caching their results. This is\n+    /// not the most efficient solution, but it addresses #60010. The\n+    /// problem we are trying to prevent:\n     ///\n     /// - If you have `A: AutoTrait` requires `B: AutoTrait` and `C: NonAutoTrait`\n     /// - `B: AutoTrait` requires `A: AutoTrait` (coinductive cycle, ok)\n@@ -182,7 +182,7 @@ struct TraitObligationStack<'prev, 'tcx: 'prev> {\n     /// evaluate each member of a cycle up to N times, where N is the\n     /// length of the cycle. This means the performance impact is\n     /// bounded and we shouldn't have any terrible worst-cases.\n-    in_cycle: Cell<bool>,\n+    reached_depth: Cell<usize>,\n \n     previous: TraitObligationStackList<'prev, 'tcx>,\n \n@@ -877,14 +877,17 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         let (result, dep_node) = self.in_task(|this| this.evaluate_stack(&stack));\n         let result = result?;\n \n-        if !stack.in_cycle.get() {\n+        let reached_depth = stack.reached_depth.get();\n+        if reached_depth >= stack.depth {\n             debug!(\"CACHE MISS: EVAL({:?})={:?}\", fresh_trait_ref, result);\n             self.insert_evaluation_cache(obligation.param_env, fresh_trait_ref, dep_node, result);\n         } else {\n             debug!(\n                 \"evaluate_trait_predicate_recursively: skipping cache because {:?} \\\n-                 is a cycle participant\",\n+                 is a cycle participant (at depth {}, reached depth {})\",\n                 fresh_trait_ref,\n+                stack.depth,\n+                reached_depth,\n             );\n         }\n \n@@ -986,10 +989,11 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         // affect the inferencer state and (b) that if we see two\n         // fresh regions with the same index, they refer to the same\n         // unbound type variable.\n-        if let Some(rec_index) = stack.iter()\n-                 .skip(1) // skip top-most frame\n-                 .position(|prev| stack.obligation.param_env == prev.obligation.param_env &&\n-                                  stack.fresh_trait_ref == prev.fresh_trait_ref)\n+        if let Some(cycle_depth) = stack.iter()\n+            .skip(1) // skip top-most frame\n+            .find(|prev| stack.obligation.param_env == prev.obligation.param_env &&\n+                  stack.fresh_trait_ref == prev.fresh_trait_ref)\n+            .map(|stack| stack.depth)\n         {\n             debug!(\"evaluate_stack({:?}) --> recursive\", stack.fresh_trait_ref);\n \n@@ -999,17 +1003,17 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             // from the cycle head. We mark them as participating in a\n             // cycle. This suppresses caching for those nodes. See\n             // `in_cycle` field for more details.\n-            for item in stack.iter().take(rec_index + 1) {\n+            for item in stack.iter().take_while(|s| s.depth > cycle_depth) {\n                 debug!(\"evaluate_stack: marking {:?} as cycle participant\", item.fresh_trait_ref);\n-                item.in_cycle.set(true);\n+                item.update_reached_depth(cycle_depth);\n             }\n \n             // Subtle: when checking for a coinductive cycle, we do\n             // not compare using the \"freshened trait refs\" (which\n             // have erased regions) but rather the fully explicit\n             // trait refs. This is important because it's only a cycle\n             // if the regions match exactly.\n-            let cycle = stack.iter().skip(1).take(rec_index + 1);\n+            let cycle = stack.iter().skip(1).take_while(|s| s.depth >= cycle_depth);\n             let cycle = cycle.map(|stack| ty::Predicate::Trait(stack.obligation.predicate));\n             if self.coinductive_match(cycle) {\n                 debug!(\n@@ -1228,6 +1232,11 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n         }\n \n         // If no match, compute result and insert into cache.\n+        //\n+        // FIXME(nikomatsakis) -- this cache is not taking into\n+        // account cycles that may have occurred in forming the\n+        // candidate. I don't know of any specific problems that\n+        // result but it seems awfully suspicious.\n         let (candidate, dep_node) =\n             self.in_task(|this| this.candidate_from_obligation_no_cache(stack));\n \n@@ -3743,12 +3752,13 @@ impl<'cx, 'gcx, 'tcx> SelectionContext<'cx, 'gcx, 'tcx> {\n             .to_poly_trait_ref()\n             .fold_with(&mut self.freshener);\n \n+        let depth = previous_stack.depth() + 1;\n         TraitObligationStack {\n             obligation,\n             fresh_trait_ref,\n-            in_cycle: Cell::new(false),\n+            reached_depth: Cell::new(depth),\n             previous: previous_stack,\n-            depth: previous_stack.depth() + 1,\n+            depth,\n         }\n     }\n \n@@ -3944,6 +3954,21 @@ impl<'o, 'tcx> TraitObligationStack<'o, 'tcx> {\n     fn iter(&'o self) -> TraitObligationStackList<'o, 'tcx> {\n         self.list()\n     }\n+\n+    /// Indicates that attempting to evaluate this stack entry\n+    /// required accessing something from the stack at depth `reached_depth`.\n+    fn update_reached_depth(&self, reached_depth: usize) {\n+        assert!(\n+            self.depth > reached_depth,\n+            \"invoked `update_reached_depth` with something under this stack: \\\n+             self.depth={} reached_depth={}\",\n+            self.depth,\n+            reached_depth,\n+        );\n+        debug!(\"update_reached_depth(reached_depth={})\", reached_depth);\n+        let v = self.reached_depth.get();\n+        self.reached_depth.set(v.min(reached_depth));\n+    }\n }\n \n #[derive(Copy, Clone)]"}]}