{"sha": "4dbef017dd2bdc34a6ddfb0914244946c01f9d97", "node_id": "MDY6Q29tbWl0NzI0NzEyOjRkYmVmMDE3ZGQyYmRjMzRhNmRkZmIwOTE0MjQ0OTQ2YzAxZjlkOTc=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-10-03T01:17:46Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-10-19T01:36:23Z"}, "message": "rustc: Check that the output file is writeable before linking\n\nThis is because on Linux, the linker will silently overwrite\na read-only file.", "tree": {"sha": "cac76cd770eb6246d2d502e78c6203a5328f9346", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cac76cd770eb6246d2d502e78c6203a5328f9346"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4dbef017dd2bdc34a6ddfb0914244946c01f9d97", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4dbef017dd2bdc34a6ddfb0914244946c01f9d97", "html_url": "https://github.com/rust-lang/rust/commit/4dbef017dd2bdc34a6ddfb0914244946c01f9d97", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4dbef017dd2bdc34a6ddfb0914244946c01f9d97/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1cf029c229660efeca92cf88350bba77b5b7d902", "url": "https://api.github.com/repos/rust-lang/rust/commits/1cf029c229660efeca92cf88350bba77b5b7d902", "html_url": "https://github.com/rust-lang/rust/commit/1cf029c229660efeca92cf88350bba77b5b7d902"}], "stats": {"total": 71, "additions": 45, "deletions": 26}, "files": [{"sha": "7028d8c42196ddd9cc3fad1cf595c78057551d8d", "filename": "src/librustc/back/link.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/4dbef017dd2bdc34a6ddfb0914244946c01f9d97/src%2Flibrustc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4dbef017dd2bdc34a6ddfb0914244946c01f9d97/src%2Flibrustc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fback%2Flink.rs?ref=4dbef017dd2bdc34a6ddfb0914244946c01f9d97", "patch": "@@ -959,6 +959,16 @@ pub fn link_binary(sess: Session,\n     }\n }\n \n+fn is_writeable(p: &Path) -> bool {\n+    use std::libc::consts::os::posix88::S_IWUSR;\n+\n+    !os::path_exists(p) ||\n+        (match p.get_mode() {\n+            None => false,\n+            Some(m) => m & S_IWUSR as uint == S_IWUSR as uint\n+        })\n+}\n+\n pub fn link_args(sess: Session,\n                  obj_filename: &Path,\n                  out_filename: &Path,\n@@ -982,6 +992,21 @@ pub fn link_args(sess: Session,\n         out_filename.clone()\n     };\n \n+    // Make sure the output and obj_filename are both writeable.\n+    // Mac, FreeBSD, and Windows system linkers check this already --\n+    // however, the Linux linker will happily overwrite a read-only file.\n+    // We should be consistent.\n+    let obj_is_writeable = is_writeable(obj_filename);\n+    let out_is_writeable = is_writeable(&output);\n+    if !out_is_writeable {\n+        sess.fatal(format!(\"Output file {} is not writeable -- check its permissions.\",\n+                           output.display()));\n+    }\n+    else if !obj_is_writeable {\n+        sess.fatal(format!(\"Object file {} is not writeable -- check its permissions.\",\n+                           obj_filename.display()));\n+    }\n+\n     // The default library location, we need this to find the runtime.\n     // The location of crates will be determined as needed.\n     // FIXME (#9639): This needs to handle non-utf8 paths"}, {"sha": "e806e515c80e8809f33484a9e85b0fe55200cec9", "filename": "src/librustpkg/rustpkg.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4dbef017dd2bdc34a6ddfb0914244946c01f9d97/src%2Flibrustpkg%2Frustpkg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4dbef017dd2bdc34a6ddfb0914244946c01f9d97/src%2Flibrustpkg%2Frustpkg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rs?ref=4dbef017dd2bdc34a6ddfb0914244946c01f9d97", "patch": "@@ -556,7 +556,7 @@ impl CtxMethods for BuildContext {\n         debug2!(\"In declare inputs for {}\", id.to_str());\n         for cs in to_do.iter() {\n             for c in cs.iter() {\n-                let path = pkg_src.start_dir.join(&c.file).normalize();\n+                let path = pkg_src.start_dir.join(&c.file);\n                 debug2!(\"Recording input: {}\", path.display());\n                 // FIXME (#9639): This needs to handle non-utf8 paths\n                 inputs.push((~\"file\", path.as_str().unwrap().to_owned()));\n@@ -623,19 +623,19 @@ impl CtxMethods for BuildContext {\n                 // Declare all the *inputs* to the declared input too, as inputs\n                 for executable in subex.iter() {\n                     exe_thing.discover_input(\"binary\",\n-                                             executable.to_str(),\n+                                             executable.as_str().unwrap().to_owned(),\n                                              workcache_support::digest_only_date(executable));\n                 }\n                 for library in sublib.iter() {\n                     exe_thing.discover_input(\"binary\",\n-                                             library.to_str(),\n+                                             library.as_str().unwrap().to_owned(),\n                                              workcache_support::digest_only_date(library));\n                 }\n \n                 for transitive_dependency in sub_build_inputs.iter() {\n                     exe_thing.discover_input(\n                         \"file\",\n-                        transitive_dependency.to_str(),\n+                        transitive_dependency.as_str().unwrap().to_owned(),\n                         workcache_support::digest_file_with_date(transitive_dependency));\n                 }\n "}, {"sha": "8722a638c456d3d3f3f2f1388a3c7ee5bc7de3f9", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4dbef017dd2bdc34a6ddfb0914244946c01f9d97/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4dbef017dd2bdc34a6ddfb0914244946c01f9d97/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=4dbef017dd2bdc34a6ddfb0914244946c01f9d97", "patch": "@@ -516,7 +516,7 @@ fn touch_source_file(workspace: &Path, pkgid: &PkgId) {\n             // should be able to do this w/o a process\n             // FIXME (#9639): This needs to handle non-utf8 paths\n             // n.b. Bumps time up by 2 seconds to get around granularity issues\n-            if run::process_output(\"touch\", [~\"-A\", ~\"02\", p.to_str()]).status != 0 {\n+            if run::process_output(\"touch\", [~\"-A\", ~\"02\", p.as_str().unwrap().to_owned()]).status != 0 {\n                 let _ = cond.raise((pkg_src_dir.clone(), ~\"Bad path\"));\n             }\n         }"}, {"sha": "345518eddc7bb6b6f761b2150c55168a066e2872", "filename": "src/librustpkg/util.rs", "status": "modified", "additions": 15, "deletions": 21, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/4dbef017dd2bdc34a6ddfb0914244946c01f9d97/src%2Flibrustpkg%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4dbef017dd2bdc34a6ddfb0914244946c01f9d97/src%2Flibrustpkg%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Futil.rs?ref=4dbef017dd2bdc34a6ddfb0914244946c01f9d97", "patch": "@@ -441,8 +441,8 @@ impl<'self> Visitor<()> for ViewItemVisitor<'self> {\n                         // Now we know that this crate has a discovered dependency on\n                         // installed_path\n                         // FIXME (#9639): This needs to handle non-utf8 paths\n-                        add_dep(self.deps, self.parent_crate.to_str(),\n-                                (~\"binary\", installed_path.to_str()));\n+                        add_dep(self.deps, self.parent_crate.as_str().unwrap().to_owned(),\n+                                (~\"binary\", installed_path.as_str().unwrap().to_owned()));\n                         self.exec.discover_input(\"binary\",\n                                                  installed_path.as_str().unwrap(),\n                                                  digest_only_date(installed_path));\n@@ -492,6 +492,10 @@ impl<'self> Visitor<()> for ViewItemVisitor<'self> {\n                             self.exec.discover_input(\"binary\",\n                                                      dep.as_str().unwrap(),\n                                                      digest_only_date(dep));\n+                            add_dep(self.deps,\n+                                    self.parent_crate.as_str().unwrap().to_owned(),\n+                                    (~\"binary\", dep.as_str().unwrap().to_owned()));\n+\n                             // Also, add an additional search path\n                             let dep_dir = dep.dir_path();\n                             debug2!(\"Installed {} into {}\", dep.display(), dep_dir.display());\n@@ -502,41 +506,31 @@ impl<'self> Visitor<()> for ViewItemVisitor<'self> {\n                                 lib_name, outputs_disc.len(), inputs_disc.len());\n                         // It must have installed *something*...\n                         assert!(!outputs_disc.is_empty());\n-                        let target_workspace = outputs_disc[0].pop();\n-                        for dep in outputs_disc.iter() {\n-                            debug2!(\"Discovering a binary input: {}\", dep.to_str());\n-                            self.exec.discover_input(\"binary\", dep.to_str(),\n-                                                     digest_only_date(dep));\n-                            add_dep(self.deps,\n-                                    self.parent_crate.to_str(),\n-                                    (~\"binary\", dep.to_str()));\n-                        }\n+                        let mut target_workspace = outputs_disc[0].clone();\n+                        target_workspace.pop();\n                         for &(ref what, ref dep) in inputs_disc.iter() {\n                             if *what == ~\"file\" {\n                                 add_dep(self.deps,\n-                                        self.parent_crate.to_str(),\n-                                        (~\"file\", dep.to_str()));\n-\n+                                        self.parent_crate.as_str().unwrap().to_owned(),\n+                                        (~\"file\", dep.clone()));\n                                 self.exec.discover_input(*what,\n                                                          *dep,\n                                                          digest_file_with_date(\n                                                              &Path::new(dep.as_slice())));\n-                            }\n-                                else if *what == ~\"binary\" {\n+                            } else if *what == ~\"binary\" {\n                                 add_dep(self.deps,\n-                                        self.parent_crate.to_str(),\n-                                        (~\"binary\", dep.to_str()));\n+                                        self.parent_crate.as_str().unwrap().to_owned(),\n+                                        (~\"binary\", dep.clone()));\n                                 self.exec.discover_input(*what,\n                                                          *dep,\n                                                          digest_only_date(\n                                                              &Path::new(dep.as_slice())));\n-                            }\n-                                else {\n+                            } else {\n                                 fail2!(\"Bad kind: {}\", *what);\n                             }\n                             // Also, add an additional search path\n                             debug2!(\"Installed {} into {}\",\n-                                    lib_name, target_workspace.to_str());\n+                                    lib_name, target_workspace.as_str().unwrap().to_owned());\n                             (self.save)(target_workspace.clone());\n                         }\n                     }"}]}