{"sha": "0b820cacab020993b6e1667f491289122f03de04", "node_id": "MDY6Q29tbWl0NzI0NzEyOjBiODIwY2FjYWIwMjA5OTNiNmUxNjY3ZjQ5MTI4OTEyMmYwM2RlMDQ=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-03-26T11:40:34Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2019-03-26T11:42:28Z"}, "message": "move source_id to a separate file", "tree": {"sha": "51bca0fffff48bc0124b35f4091738f03e651688", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/51bca0fffff48bc0124b35f4091738f03e651688"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0b820cacab020993b6e1667f491289122f03de04", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0b820cacab020993b6e1667f491289122f03de04", "html_url": "https://github.com/rust-lang/rust/commit/0b820cacab020993b6e1667f491289122f03de04", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0b820cacab020993b6e1667f491289122f03de04/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8254244e4970b085809d42a34282649b4a4e16a2", "url": "https://api.github.com/repos/rust-lang/rust/commits/8254244e4970b085809d42a34282649b4a4e16a2", "html_url": "https://github.com/rust-lang/rust/commit/8254244e4970b085809d42a34282649b4a4e16a2"}], "stats": {"total": 248, "additions": 128, "deletions": 120}, "files": [{"sha": "3296b9b31dbbb73c131fd3e4e24578cd08091546", "filename": "crates/ra_hir/src/db.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b820cacab020993b6e1667f491289122f03de04/crates%2Fra_hir%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b820cacab020993b6e1667f491289122f03de04/crates%2Fra_hir%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fdb.rs?ref=0b820cacab020993b6e1667f491289122f03de04", "patch": "@@ -34,10 +34,10 @@ pub trait DefDatabase: SourceDatabase + AsRef<HirInterner> {\n     #[salsa::invoke(crate::traits::TraitData::trait_data_query)]\n     fn trait_data(&self, t: Trait) -> Arc<TraitData>;\n \n-    #[salsa::invoke(crate::ids::SourceFileItems::file_items_query)]\n+    #[salsa::invoke(crate::source_id::SourceFileItems::file_items_query)]\n     fn file_items(&self, file_id: HirFileId) -> Arc<SourceFileItems>;\n \n-    #[salsa::invoke(crate::ids::SourceFileItems::file_item_query)]\n+    #[salsa::invoke(crate::source_id::SourceFileItems::file_item_query)]\n     fn file_item(&self, source_item_id: SourceItemId) -> TreeArc<SyntaxNode>;\n \n     #[salsa::invoke(RawItems::raw_items_query)]"}, {"sha": "e73dd5d21d6e76e09662efb8db5f5d1416809df2", "filename": "crates/ra_hir/src/ids.rs", "status": "modified", "additions": 3, "deletions": 111, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/0b820cacab020993b6e1667f491289122f03de04/crates%2Fra_hir%2Fsrc%2Fids.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b820cacab020993b6e1667f491289122f03de04/crates%2Fra_hir%2Fsrc%2Fids.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fids.rs?ref=0b820cacab020993b6e1667f491289122f03de04", "patch": "@@ -5,13 +5,12 @@ use std::{\n };\n \n use ra_db::{LocationInterner, FileId};\n-use ra_syntax::{TreeArc, SyntaxNode, SourceFile, AstNode, SyntaxNodePtr, ast};\n-use ra_arena::{Arena, RawId, ArenaId, impl_arena_id};\n+use ra_syntax::{TreeArc, SourceFile, AstNode, ast};\n+use ra_arena::{RawId, ArenaId, impl_arena_id};\n use mbe::MacroRules;\n \n use crate::{\n-    Module,\n-    DefDatabase,\n+    Module, DefDatabase, SourceItemId, SourceFileItemId,\n };\n \n #[derive(Debug, Default)]\n@@ -304,110 +303,3 @@ impl AstItemDef<ast::TypeAliasDef> for TypeId {\n         &interner.types\n     }\n }\n-\n-/// Identifier of item within a specific file. This is stable over reparses, so\n-/// it's OK to use it as a salsa key/value.\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n-pub struct SourceFileItemId(RawId);\n-impl_arena_id!(SourceFileItemId);\n-\n-impl SourceFileItemId {\n-    pub(crate) fn with_file_id(self, file_id: HirFileId) -> SourceItemId {\n-        SourceItemId { file_id, item_id: self }\n-    }\n-}\n-\n-#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n-pub struct SourceItemId {\n-    pub(crate) file_id: HirFileId,\n-    pub(crate) item_id: SourceFileItemId,\n-}\n-\n-/// Maps items' `SyntaxNode`s to `SourceFileItemId`s and back.\n-#[derive(Debug, PartialEq, Eq)]\n-pub struct SourceFileItems {\n-    file_id: HirFileId,\n-    arena: Arena<SourceFileItemId, SyntaxNodePtr>,\n-}\n-\n-impl SourceFileItems {\n-    pub(crate) fn file_items_query(\n-        db: &impl DefDatabase,\n-        file_id: HirFileId,\n-    ) -> Arc<SourceFileItems> {\n-        let source_file = db.hir_parse(file_id);\n-        Arc::new(SourceFileItems::from_source_file(&source_file, file_id))\n-    }\n-\n-    pub(crate) fn file_item_query(\n-        db: &impl DefDatabase,\n-        source_item_id: SourceItemId,\n-    ) -> TreeArc<SyntaxNode> {\n-        let source_file = db.hir_parse(source_item_id.file_id);\n-        db.file_items(source_item_id.file_id)[source_item_id.item_id]\n-            .to_node(&source_file)\n-            .to_owned()\n-    }\n-\n-    pub(crate) fn from_source_file(\n-        source_file: &SourceFile,\n-        file_id: HirFileId,\n-    ) -> SourceFileItems {\n-        let mut res = SourceFileItems { file_id, arena: Arena::default() };\n-        // By walking the tree in bread-first order we make sure that parents\n-        // get lower ids then children. That is, adding a new child does not\n-        // change parent's id. This means that, say, adding a new function to a\n-        // trait does not change ids of top-level items, which helps caching.\n-        bfs(source_file.syntax(), |it| {\n-            if let Some(module_item) = ast::ModuleItem::cast(it) {\n-                res.alloc(module_item.syntax());\n-            } else if let Some(macro_call) = ast::MacroCall::cast(it) {\n-                res.alloc(macro_call.syntax());\n-            }\n-        });\n-        res\n-    }\n-\n-    fn alloc(&mut self, item: &SyntaxNode) -> SourceFileItemId {\n-        self.arena.alloc(SyntaxNodePtr::new(item))\n-    }\n-    pub(crate) fn id_of(&self, file_id: HirFileId, item: &SyntaxNode) -> SourceFileItemId {\n-        assert_eq!(\n-            self.file_id, file_id,\n-            \"SourceFileItems: wrong file, expected {:?}, got {:?}\",\n-            self.file_id, file_id\n-        );\n-        self.id_of_unchecked(item)\n-    }\n-    pub(crate) fn id_of_unchecked(&self, item: &SyntaxNode) -> SourceFileItemId {\n-        let ptr = SyntaxNodePtr::new(item);\n-        if let Some((id, _)) = self.arena.iter().find(|(_id, i)| **i == ptr) {\n-            return id;\n-        }\n-        panic!(\n-            \"Can't find {:?} in SourceFileItems:\\n{:?}\",\n-            item,\n-            self.arena.iter().map(|(_id, i)| i).collect::<Vec<_>>(),\n-        );\n-    }\n-}\n-\n-impl std::ops::Index<SourceFileItemId> for SourceFileItems {\n-    type Output = SyntaxNodePtr;\n-    fn index(&self, idx: SourceFileItemId) -> &SyntaxNodePtr {\n-        &self.arena[idx]\n-    }\n-}\n-\n-/// Walks the subtree in bfs order, calling `f` for each node.\n-fn bfs(node: &SyntaxNode, mut f: impl FnMut(&SyntaxNode)) {\n-    let mut curr_layer = vec![node];\n-    let mut next_layer = vec![];\n-    while !curr_layer.is_empty() {\n-        curr_layer.drain(..).for_each(|node| {\n-            next_layer.extend(node.children());\n-            f(node);\n-        });\n-        std::mem::swap(&mut curr_layer, &mut next_layer);\n-    }\n-}"}, {"sha": "ac2585de0fed1eb9b096b4144a17d7f6c6670af5", "filename": "crates/ra_hir/src/lib.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b820cacab020993b6e1667f491289122f03de04/crates%2Fra_hir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b820cacab020993b6e1667f491289122f03de04/crates%2Fra_hir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Flib.rs?ref=0b820cacab020993b6e1667f491289122f03de04", "patch": "@@ -23,6 +23,7 @@ pub mod mock;\n mod path;\n pub mod source_binder;\n \n+mod source_id;\n mod ids;\n mod name;\n mod nameres;\n@@ -47,12 +48,13 @@ mod marks;\n use crate::{\n     db::{HirDatabase, DefDatabase},\n     name::{AsName, KnownName},\n-    ids::{SourceItemId, SourceFileItems},\n+    source_id::SourceFileItemId,\n };\n \n pub use self::{\n     path::{Path, PathKind},\n     name::Name,\n+    source_id::{SourceFileItems, SourceItemId},\n     ids::{HirFileId, MacroDefId, MacroCallId, MacroCallLoc, HirInterner},\n     nameres::{PerNs, Namespace},\n     ty::{Ty, ApplicationTy, TypeCtor, Substs, display::HirDisplay},"}, {"sha": "d8fa2383f5283696db075b53e85544f659a16981", "filename": "crates/ra_hir/src/nameres.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/0b820cacab020993b6e1667f491289122f03de04/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b820cacab020993b6e1667f491289122f03de04/crates%2Fra_hir%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres.rs?ref=0b820cacab020993b6e1667f491289122f03de04", "patch": "@@ -63,7 +63,8 @@ use test_utils::tested_by;\n use crate::{\n     ModuleDef, Name, Crate, Module,\n     DefDatabase, Path, PathKind, HirFileId, Trait,\n-    ids::{SourceItemId, SourceFileItemId, MacroCallId, MacroDefId},\n+    SourceItemId, SourceFileItemId,\n+    ids::{MacroCallId, MacroDefId},\n     diagnostics::DiagnosticSink,\n     nameres::diagnostics::DefDiagnostic,\n };"}, {"sha": "4fb29815507d85bb7cce29e791d3eeee77040279", "filename": "crates/ra_hir/src/nameres/collector.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b820cacab020993b6e1667f491289122f03de04/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b820cacab020993b6e1667f491289122f03de04/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Fcollector.rs?ref=0b820cacab020993b6e1667f491289122f03de04", "patch": "@@ -6,15 +6,15 @@ use ra_db::FileId;\n \n use crate::{\n     Function, Module, Struct, Enum, Const, Static, Trait, TypeAlias,\n-    DefDatabase, HirFileId, Name, Path,\n+    DefDatabase, HirFileId, Name, Path, SourceItemId,\n     KnownName,\n     nameres::{\n         Resolution, PerNs, ModuleDef, ReachedFixedPoint, ResolveMode,\n         CrateDefMap, CrateModuleId, ModuleData,\n         diagnostics::DefDiagnostic,\n         raw,\n     },\n-    ids::{AstItemDef, LocationCtx, MacroCallLoc, SourceItemId, MacroCallId, MacroDefId},\n+    ids::{AstItemDef, LocationCtx, MacroCallLoc, MacroCallId, MacroDefId},\n };\n \n pub(super) fn collect_defs(db: &impl DefDatabase, mut def_map: CrateDefMap) -> CrateDefMap {"}, {"sha": "f32004601074b4c889d051d9b7531584d7765d58", "filename": "crates/ra_hir/src/nameres/raw.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/0b820cacab020993b6e1667f491289122f03de04/crates%2Fra_hir%2Fsrc%2Fnameres%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b820cacab020993b6e1667f491289122f03de04/crates%2Fra_hir%2Fsrc%2Fnameres%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fnameres%2Fraw.rs?ref=0b820cacab020993b6e1667f491289122f03de04", "patch": "@@ -12,7 +12,7 @@ use ra_syntax::{\n \n use crate::{\n     DefDatabase, Name, AsName, Path, HirFileId, ModuleSource,\n-    ids::{SourceFileItemId, SourceFileItems},\n+    SourceFileItemId, SourceFileItems,\n };\n \n /// `RawItems` is a set of top-level items in a file (except for impls)."}, {"sha": "6e157007f468d63b8364f7d81c37af6fc49e2c26", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/0b820cacab020993b6e1667f491289122f03de04/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b820cacab020993b6e1667f491289122f03de04/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=0b820cacab020993b6e1667f491289122f03de04", "patch": "@@ -13,9 +13,9 @@ use ra_syntax::{\n };\n \n use crate::{\n-    HirDatabase, Function, Struct, Enum,\n+    HirDatabase, Function, Struct, Enum, SourceFileItemId,\n     AsName, Module, HirFileId, Crate, Trait, Resolver,\n-    ids::{LocationCtx, SourceFileItemId},\n+    ids::LocationCtx,\n     expr\n };\n "}, {"sha": "f961adf8bd716ef3647f6dae0125b41c2d53855b", "filename": "crates/ra_hir/src/source_id.rs", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/rust-lang/rust/blob/0b820cacab020993b6e1667f491289122f03de04/crates%2Fra_hir%2Fsrc%2Fsource_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0b820cacab020993b6e1667f491289122f03de04/crates%2Fra_hir%2Fsrc%2Fsource_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_id.rs?ref=0b820cacab020993b6e1667f491289122f03de04", "patch": "@@ -0,0 +1,113 @@\n+use std::sync::Arc;\n+\n+use ra_arena::{Arena, RawId, impl_arena_id};\n+use ra_syntax::{SyntaxNodePtr, TreeArc, SyntaxNode, SourceFile, AstNode, ast};\n+\n+use crate::{HirFileId, DefDatabase};\n+\n+/// Identifier of item within a specific file. This is stable over reparses, so\n+/// it's OK to use it as a salsa key/value.\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash)]\n+pub struct SourceFileItemId(RawId);\n+impl_arena_id!(SourceFileItemId);\n+\n+impl SourceFileItemId {\n+    pub(crate) fn with_file_id(self, file_id: HirFileId) -> SourceItemId {\n+        SourceItemId { file_id, item_id: self }\n+    }\n+}\n+\n+#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]\n+pub struct SourceItemId {\n+    pub(crate) file_id: HirFileId,\n+    pub(crate) item_id: SourceFileItemId,\n+}\n+\n+/// Maps items' `SyntaxNode`s to `SourceFileItemId`s and back.\n+#[derive(Debug, PartialEq, Eq)]\n+pub struct SourceFileItems {\n+    file_id: HirFileId,\n+    arena: Arena<SourceFileItemId, SyntaxNodePtr>,\n+}\n+\n+impl SourceFileItems {\n+    pub(crate) fn file_items_query(\n+        db: &impl DefDatabase,\n+        file_id: HirFileId,\n+    ) -> Arc<SourceFileItems> {\n+        let source_file = db.hir_parse(file_id);\n+        Arc::new(SourceFileItems::from_source_file(&source_file, file_id))\n+    }\n+\n+    pub(crate) fn file_item_query(\n+        db: &impl DefDatabase,\n+        source_item_id: SourceItemId,\n+    ) -> TreeArc<SyntaxNode> {\n+        let source_file = db.hir_parse(source_item_id.file_id);\n+        db.file_items(source_item_id.file_id)[source_item_id.item_id]\n+            .to_node(&source_file)\n+            .to_owned()\n+    }\n+\n+    pub(crate) fn from_source_file(\n+        source_file: &SourceFile,\n+        file_id: HirFileId,\n+    ) -> SourceFileItems {\n+        let mut res = SourceFileItems { file_id, arena: Arena::default() };\n+        // By walking the tree in bread-first order we make sure that parents\n+        // get lower ids then children. That is, adding a new child does not\n+        // change parent's id. This means that, say, adding a new function to a\n+        // trait does not change ids of top-level items, which helps caching.\n+        bfs(source_file.syntax(), |it| {\n+            if let Some(module_item) = ast::ModuleItem::cast(it) {\n+                res.alloc(module_item.syntax());\n+            } else if let Some(macro_call) = ast::MacroCall::cast(it) {\n+                res.alloc(macro_call.syntax());\n+            }\n+        });\n+        res\n+    }\n+\n+    fn alloc(&mut self, item: &SyntaxNode) -> SourceFileItemId {\n+        self.arena.alloc(SyntaxNodePtr::new(item))\n+    }\n+    pub(crate) fn id_of(&self, file_id: HirFileId, item: &SyntaxNode) -> SourceFileItemId {\n+        assert_eq!(\n+            self.file_id, file_id,\n+            \"SourceFileItems: wrong file, expected {:?}, got {:?}\",\n+            self.file_id, file_id\n+        );\n+        self.id_of_unchecked(item)\n+    }\n+    pub(crate) fn id_of_unchecked(&self, item: &SyntaxNode) -> SourceFileItemId {\n+        let ptr = SyntaxNodePtr::new(item);\n+        if let Some((id, _)) = self.arena.iter().find(|(_id, i)| **i == ptr) {\n+            return id;\n+        }\n+        panic!(\n+            \"Can't find {:?} in SourceFileItems:\\n{:?}\",\n+            item,\n+            self.arena.iter().map(|(_id, i)| i).collect::<Vec<_>>(),\n+        );\n+    }\n+}\n+\n+impl std::ops::Index<SourceFileItemId> for SourceFileItems {\n+    type Output = SyntaxNodePtr;\n+    fn index(&self, idx: SourceFileItemId) -> &SyntaxNodePtr {\n+        &self.arena[idx]\n+    }\n+}\n+\n+/// Walks the subtree in bfs order, calling `f` for each node.\n+fn bfs(node: &SyntaxNode, mut f: impl FnMut(&SyntaxNode)) {\n+    let mut curr_layer = vec![node];\n+    let mut next_layer = vec![];\n+    while !curr_layer.is_empty() {\n+        curr_layer.drain(..).for_each(|node| {\n+            next_layer.extend(node.children());\n+            f(node);\n+        });\n+        std::mem::swap(&mut curr_layer, &mut next_layer);\n+    }\n+}"}]}