{"sha": "09df51dab89340bcf4b8ede95c02c32b0c8eb2bc", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA5ZGY1MWRhYjg5MzQwYmNmNGI4ZWRlOTVjMDJjMzJiMGM4ZWIyYmM=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2020-05-31T10:50:11Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-05-31T10:50:11Z"}, "message": "Merge #4664\n\n4664: Generate feature documentation from code r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>", "tree": {"sha": "0240c629fe96243e1a1c91ccd679947bfb1ecb03", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0240c629fe96243e1a1c91ccd679947bfb1ecb03"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/09df51dab89340bcf4b8ede95c02c32b0c8eb2bc", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe04vjCRBK7hj4Ov3rIwAAdHIIAF9YABjXScYdlkyhbw1cWBa4\nlte2T/2dWpaleAwO44tMtHeg76kagbm5psBilaPax3TF8DllyIxBSz/3iDD+Dq6z\nY3Nn5svvUj7T1D+ndBrk1BNWg/Sw6BQUjKs5M+pVxBwaWuoKPytnq+DWpmAVbZcG\nBMVpoNYwrEbSSYurvSV/6iYp+6TAsC6s2bETUBUO6ke7LrrMwexm3aWhQF9Kc3JV\n+eT33dvlTrqlc4NH3kbr85ESHWeQD4meTzObCnXs46Sd/Tt3QlXGBLjeNkISHWAa\nIf45Pfot2VeBP11Q9SXJtgq/mob77AxX7f11OG21Io6FRUp2+f+6orYIE4uCrOM=\n=iAaV\n-----END PGP SIGNATURE-----\n", "payload": "tree 0240c629fe96243e1a1c91ccd679947bfb1ecb03\nparent 5f7225446e75509ae0d971a6f3e2b9d3e37d6f2a\nparent 13a996f3b68c175f6e6ad8d89081e45850dc5583\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1590922211 +0000\ncommitter GitHub <noreply@github.com> 1590922211 +0000\n\nMerge #4664\n\n4664: Generate feature documentation from code r=matklad a=matklad\n\n\n\nCo-authored-by: Aleksey Kladov <aleksey.kladov@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/09df51dab89340bcf4b8ede95c02c32b0c8eb2bc", "html_url": "https://github.com/rust-lang/rust/commit/09df51dab89340bcf4b8ede95c02c32b0c8eb2bc", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/09df51dab89340bcf4b8ede95c02c32b0c8eb2bc/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5f7225446e75509ae0d971a6f3e2b9d3e37d6f2a", "url": "https://api.github.com/repos/rust-lang/rust/commits/5f7225446e75509ae0d971a6f3e2b9d3e37d6f2a", "html_url": "https://github.com/rust-lang/rust/commit/5f7225446e75509ae0d971a6f3e2b9d3e37d6f2a"}, {"sha": "13a996f3b68c175f6e6ad8d89081e45850dc5583", "url": "https://api.github.com/repos/rust-lang/rust/commits/13a996f3b68c175f6e6ad8d89081e45850dc5583", "html_url": "https://github.com/rust-lang/rust/commit/13a996f3b68c175f6e6ad8d89081e45850dc5583"}], "stats": {"total": 1271, "additions": 859, "deletions": 412}, "files": [{"sha": "dab51647db70b41da27cccceeaeedbbf580f4833", "filename": ".gitignore", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/09df51dab89340bcf4b8ede95c02c32b0c8eb2bc/.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/09df51dab89340bcf4b8ede95c02c32b0c8eb2bc/.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitignore?ref=09df51dab89340bcf4b8ede95c02c32b0c8eb2bc", "patch": "@@ -7,4 +7,4 @@ crates/*/target\n *.log\n *.iml\n .vscode/settings.json\n-cargo-timing*.html\n+*.html"}, {"sha": "776bddf918a9188209eb4989046b8ecbd07c8261", "filename": "crates/ra_assists/src/handlers/add_from_impl_for_enum.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/09df51dab89340bcf4b8ede95c02c32b0c8eb2bc/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_from_impl_for_enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09df51dab89340bcf4b8ede95c02c32b0c8eb2bc/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_from_impl_for_enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Fhandlers%2Fadd_from_impl_for_enum.rs?ref=09df51dab89340bcf4b8ede95c02c32b0c8eb2bc", "patch": "@@ -4,9 +4,9 @@ use test_utils::mark;\n \n use crate::{utils::FamousDefs, AssistContext, AssistId, Assists};\n \n-// Assist add_from_impl_for_enum\n+// Assist: add_from_impl_for_enum\n //\n-// Adds a From impl for an enum variant with one tuple field\n+// Adds a From impl for an enum variant with one tuple field.\n //\n // ```\n // enum A { <|>One(u32) }"}, {"sha": "73d43283d4ee17f10effc60a21bcf0ea7419123e", "filename": "crates/ra_assists/src/tests/generated.rs", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/09df51dab89340bcf4b8ede95c02c32b0c8eb2bc/crates%2Fra_assists%2Fsrc%2Ftests%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09df51dab89340bcf4b8ede95c02c32b0c8eb2bc/crates%2Fra_assists%2Fsrc%2Ftests%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_assists%2Fsrc%2Ftests%2Fgenerated.rs?ref=09df51dab89340bcf4b8ede95c02c32b0c8eb2bc", "patch": "@@ -58,6 +58,25 @@ fn main() {\n     )\n }\n \n+#[test]\n+fn doctest_add_from_impl_for_enum() {\n+    check_doc_test(\n+        \"add_from_impl_for_enum\",\n+        r#####\"\n+enum A { <|>One(u32) }\n+\"#####,\n+        r#####\"\n+enum A { One(u32) }\n+\n+impl From<u32> for A {\n+    fn from(v: u32) -> Self {\n+        A::One(v)\n+    }\n+}\n+\"#####,\n+    )\n+}\n+\n #[test]\n fn doctest_add_function() {\n     check_doc_test("}, {"sha": "d890b69d26fa914fe21009a97ac4807b605f3921", "filename": "crates/ra_ide/src/completion.rs", "status": "modified", "additions": 45, "deletions": 2, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/09df51dab89340bcf4b8ede95c02c32b0c8eb2bc/crates%2Fra_ide%2Fsrc%2Fcompletion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09df51dab89340bcf4b8ede95c02c32b0c8eb2bc/crates%2Fra_ide%2Fsrc%2Fcompletion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion.rs?ref=09df51dab89340bcf4b8ede95c02c32b0c8eb2bc", "patch": "@@ -1,5 +1,3 @@\n-//! FIXME: write short doc here\n-\n mod completion_config;\n mod completion_item;\n mod completion_context;\n@@ -35,6 +33,51 @@ pub use crate::completion::{\n     completion_item::{CompletionItem, CompletionItemKind, CompletionScore, InsertTextFormat},\n };\n \n+//FIXME: split the following feature into fine-grained features.\n+\n+// Feature: Magic Completions\n+//\n+// In addition to usual reference completion, rust-analyzer provides some \u2728magic\u2728\n+// completions as well:\n+//\n+// Keywords like `if`, `else` `while`, `loop` are completed with braces, and cursor\n+// is placed at the appropriate position. Even though `if` is easy to type, you\n+// still want to complete it, to get ` { }` for free! `return` is inserted with a\n+// space or `;` depending on the return type of the function.\n+//\n+// When completing a function call, `()` are automatically inserted. If a function\n+// takes arguments, the cursor is positioned inside the parenthesis.\n+//\n+// There are postfix completions, which can be triggered by typing something like\n+// `foo().if`. The word after `.` determines postfix completion. Possible variants are:\n+//\n+// - `expr.if` -> `if expr {}` or `if let ... {}` for `Option` or `Result`\n+// - `expr.match` -> `match expr {}`\n+// - `expr.while` -> `while expr {}` or `while let ... {}` for `Option` or `Result`\n+// - `expr.ref` -> `&expr`\n+// - `expr.refm` -> `&mut expr`\n+// - `expr.not` -> `!expr`\n+// - `expr.dbg` -> `dbg!(expr)`\n+//\n+// There also snippet completions:\n+//\n+// .Expressions\n+// - `pd` -> `println!(\"{:?}\")`\n+// - `ppd` -> `println!(\"{:#?}\")`\n+//\n+// .Items\n+// - `tfn` -> `#[test] fn f(){}`\n+// - `tmod` ->\n+// ```rust\n+// #[cfg(test)]\n+// mod tests {\n+//     use super::*;\n+//\n+//     #[test]\n+//     fn test_fn() {}\n+// }\n+// ```\n+\n /// Main entry point for completion. We run completion as a two-phase process.\n ///\n /// First, we look at the position and collect a so-called `CompletionContext."}, {"sha": "59b58bf98b6b5282466190326f2c9431569429df", "filename": "crates/ra_ide/src/completion/complete_postfix.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/09df51dab89340bcf4b8ede95c02c32b0c8eb2bc/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_postfix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09df51dab89340bcf4b8ede95c02c32b0c8eb2bc/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_postfix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fcomplete_postfix.rs?ref=09df51dab89340bcf4b8ede95c02c32b0c8eb2bc", "patch": "@@ -1,20 +1,20 @@\n //! FIXME: write short doc here\n-\n+use ra_assists::utils::TryEnum;\n use ra_syntax::{\n     ast::{self, AstNode},\n     TextRange, TextSize,\n };\n use ra_text_edit::TextEdit;\n \n-use super::completion_config::SnippetCap;\n use crate::{\n     completion::{\n         completion_context::CompletionContext,\n         completion_item::{Builder, CompletionKind, Completions},\n     },\n     CompletionItem,\n };\n-use ra_assists::utils::TryEnum;\n+\n+use super::completion_config::SnippetCap;\n \n pub(super) fn complete_postfix(acc: &mut Completions, ctx: &CompletionContext) {\n     if !ctx.config.enable_postfix_completions {"}, {"sha": "aad5a8e4db69b5d4b57a7b4c0ca8567abaa6b9cb", "filename": "crates/ra_ide/src/display/structure.rs", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/09df51dab89340bcf4b8ede95c02c32b0c8eb2bc/crates%2Fra_ide%2Fsrc%2Fdisplay%2Fstructure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09df51dab89340bcf4b8ede95c02c32b0c8eb2bc/crates%2Fra_ide%2Fsrc%2Fdisplay%2Fstructure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fdisplay%2Fstructure.rs?ref=09df51dab89340bcf4b8ede95c02c32b0c8eb2bc", "patch": "@@ -1,10 +1,6 @@\n-//! FIXME: write short doc here\n-\n-use crate::TextRange;\n-\n use ra_syntax::{\n     ast::{self, AttrsOwner, NameOwner, TypeAscriptionOwner, TypeParamsOwner},\n-    match_ast, AstNode, SourceFile, SyntaxKind, SyntaxNode, WalkEvent,\n+    match_ast, AstNode, SourceFile, SyntaxKind, SyntaxNode, TextRange, WalkEvent,\n };\n \n #[derive(Debug, Clone)]\n@@ -18,6 +14,19 @@ pub struct StructureNode {\n     pub deprecated: bool,\n }\n \n+// Feature: File Structure\n+//\n+// Provides a tree of the symbols defined in the file. Can be used to\n+//\n+// * fuzzy search symbol in a file (super useful)\n+// * draw breadcrumbs to describe the context around the cursor\n+// * draw outline of the file\n+//\n+// |===\n+// | Editor  | Shortcut\n+//\n+// | VS Code | kbd:[Ctrl+Shift+O]\n+// |===\n pub fn file_structure(file: &SourceFile) -> Vec<StructureNode> {\n     let mut res = Vec::new();\n     let mut stack = Vec::new();"}, {"sha": "54a47aac0684e0df4a89bd90464722df98cdbc4d", "filename": "crates/ra_ide/src/expand_macro.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/09df51dab89340bcf4b8ede95c02c32b0c8eb2bc/crates%2Fra_ide%2Fsrc%2Fexpand_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09df51dab89340bcf4b8ede95c02c32b0c8eb2bc/crates%2Fra_ide%2Fsrc%2Fexpand_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fexpand_macro.rs?ref=09df51dab89340bcf4b8ede95c02c32b0c8eb2bc", "patch": "@@ -1,5 +1,3 @@\n-//! This modules implements \"expand macro\" functionality in the IDE\n-\n use hir::Semantics;\n use ra_ide_db::RootDatabase;\n use ra_syntax::{\n@@ -14,6 +12,15 @@ pub struct ExpandedMacro {\n     pub expansion: String,\n }\n \n+// Feature: Expand Macro Recursively\n+//\n+// Shows the full macro expansion of the macro at current cursor.\n+//\n+// |===\n+// | Editor  | Action Name\n+//\n+// | VS Code | **Rust Analyzer: Expand macro recursively**\n+// |===\n pub(crate) fn expand_macro(db: &RootDatabase, position: FilePosition) -> Option<ExpandedMacro> {\n     let sema = Semantics::new(db);\n     let file = sema.parse(position.file_id);"}, {"sha": "a4bc93cdbaa74722a70469fe1290fb557a20d1e2", "filename": "crates/ra_ide/src/extend_selection.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/09df51dab89340bcf4b8ede95c02c32b0c8eb2bc/crates%2Fra_ide%2Fsrc%2Fextend_selection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09df51dab89340bcf4b8ede95c02c32b0c8eb2bc/crates%2Fra_ide%2Fsrc%2Fextend_selection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fextend_selection.rs?ref=09df51dab89340bcf4b8ede95c02c32b0c8eb2bc", "patch": "@@ -1,5 +1,3 @@\n-//! FIXME: write short doc here\n-\n use std::iter::successors;\n \n use hir::Semantics;\n@@ -14,6 +12,16 @@ use ra_syntax::{\n \n use crate::FileRange;\n \n+// Feature: Extend Selection\n+//\n+// Extends the current selection to the encompassing syntactic construct\n+// (expression, statement, item, module, etc). It works with multiple cursors.\n+//\n+// |===\n+// | Editor  | Shortcut\n+//\n+// | VS Code | kbd:[Ctrl+Shift+\u2192]\n+// |===\n pub(crate) fn extend_selection(db: &RootDatabase, frange: FileRange) -> TextRange {\n     let sema = Semantics::new(db);\n     let src = sema.parse(frange.file_id);"}, {"sha": "a6c86e99c95eb9fc60355c23cd11eeb5ed6acf8d", "filename": "crates/ra_ide/src/goto_definition.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/09df51dab89340bcf4b8ede95c02c32b0c8eb2bc/crates%2Fra_ide%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09df51dab89340bcf4b8ede95c02c32b0c8eb2bc/crates%2Fra_ide%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fgoto_definition.rs?ref=09df51dab89340bcf4b8ede95c02c32b0c8eb2bc", "patch": "@@ -1,5 +1,3 @@\n-//! FIXME: write short doc here\n-\n use hir::Semantics;\n use ra_ide_db::{\n     defs::{classify_name, classify_name_ref},\n@@ -17,6 +15,15 @@ use crate::{\n     FilePosition, NavigationTarget, RangeInfo,\n };\n \n+// Feature: Go to Definition\n+//\n+// Navigates to the definition of an identifier.\n+//\n+// |===\n+// | Editor  | Shortcut\n+//\n+// | VS Code | kbd:[F12]\n+// |===\n pub(crate) fn goto_definition(\n     db: &RootDatabase,\n     position: FilePosition,"}, {"sha": "0cec0657e416073fccde1255caf6720d7de5f098", "filename": "crates/ra_ide/src/goto_implementation.rs", "status": "renamed", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/09df51dab89340bcf4b8ede95c02c32b0c8eb2bc/crates%2Fra_ide%2Fsrc%2Fgoto_implementation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09df51dab89340bcf4b8ede95c02c32b0c8eb2bc/crates%2Fra_ide%2Fsrc%2Fgoto_implementation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fgoto_implementation.rs?ref=09df51dab89340bcf4b8ede95c02c32b0c8eb2bc", "patch": "@@ -1,11 +1,18 @@\n-//! FIXME: write short doc here\n-\n use hir::{Crate, ImplDef, Semantics};\n use ra_ide_db::RootDatabase;\n use ra_syntax::{algo::find_node_at_offset, ast, AstNode};\n \n use crate::{display::ToNav, FilePosition, NavigationTarget, RangeInfo};\n \n+// Feature: Go to Implementation\n+//\n+// Navigates to the impl block of structs, enums or traits. Also implemented as a code lens.\n+//\n+// |===\n+// | Editor  | Shortcut\n+//\n+// | VS Code | kbd:[Ctrl+F12]\n+// |===\n pub(crate) fn goto_implementation(\n     db: &RootDatabase,\n     position: FilePosition,", "previous_filename": "crates/ra_ide/src/impls.rs"}, {"sha": "91a3097fbb3697141eec5fa6d8b023560f618ffa", "filename": "crates/ra_ide/src/goto_type_definition.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/09df51dab89340bcf4b8ede95c02c32b0c8eb2bc/crates%2Fra_ide%2Fsrc%2Fgoto_type_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09df51dab89340bcf4b8ede95c02c32b0c8eb2bc/crates%2Fra_ide%2Fsrc%2Fgoto_type_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fgoto_type_definition.rs?ref=09df51dab89340bcf4b8ede95c02c32b0c8eb2bc", "patch": "@@ -1,10 +1,17 @@\n-//! FIXME: write short doc here\n-\n use ra_ide_db::RootDatabase;\n use ra_syntax::{ast, match_ast, AstNode, SyntaxKind::*, SyntaxToken, TokenAtOffset};\n \n use crate::{display::ToNav, FilePosition, NavigationTarget, RangeInfo};\n \n+// Feature: Go to Type Definition\n+//\n+// Navigates to the type of an identifier.\n+//\n+// |===\n+// | Editor  | Action Name\n+//\n+// | VS Code | **Go to Type Definition*\n+// |===\n pub(crate) fn goto_type_definition(\n     db: &RootDatabase,\n     position: FilePosition,"}, {"sha": "d96cb55969180c582b76c36ebce2ae6eafb049fc", "filename": "crates/ra_ide/src/hover.rs", "status": "modified", "additions": 59, "deletions": 57, "changes": 116, "blob_url": "https://github.com/rust-lang/rust/blob/09df51dab89340bcf4b8ede95c02c32b0c8eb2bc/crates%2Fra_ide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09df51dab89340bcf4b8ede95c02c32b0c8eb2bc/crates%2Fra_ide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fhover.rs?ref=09df51dab89340bcf4b8ede95c02c32b0c8eb2bc", "patch": "@@ -1,10 +1,10 @@\n-//! Logic for computing info that is displayed when the user hovers over any\n-//! source code items (e.g. function call, struct field, variable symbol...)\n+use std::iter::once;\n \n use hir::{\n     Adt, AsAssocItem, AssocItemContainer, FieldSource, HasSource, HirDisplay, ModuleDef,\n     ModuleSource, Semantics,\n };\n+use itertools::Itertools;\n use ra_db::SourceDatabase;\n use ra_ide_db::{\n     defs::{classify_name, classify_name_ref, Definition},\n@@ -21,8 +21,6 @@ use crate::{\n     display::{macro_label, rust_code_markup, rust_code_markup_with_doc, ShortLabel},\n     FilePosition, RangeInfo,\n };\n-use itertools::Itertools;\n-use std::iter::once;\n \n /// Contains the results when hovering over an item\n #[derive(Debug, Default)]\n@@ -62,6 +60,63 @@ impl HoverResult {\n     }\n }\n \n+// Feature: Hover\n+//\n+// Shows additional information, like type of an expression or documentation for definition when \"focusing\" code.\n+// Focusing is usually hovering with a mouse, but can also be triggered with a shortcut.\n+pub(crate) fn hover(db: &RootDatabase, position: FilePosition) -> Option<RangeInfo<HoverResult>> {\n+    let sema = Semantics::new(db);\n+    let file = sema.parse(position.file_id).syntax().clone();\n+    let token = pick_best(file.token_at_offset(position.offset))?;\n+    let token = sema.descend_into_macros(token);\n+\n+    let mut res = HoverResult::new();\n+\n+    if let Some((node, name_kind)) = match_ast! {\n+        match (token.parent()) {\n+            ast::NameRef(name_ref) => {\n+                classify_name_ref(&sema, &name_ref).map(|d| (name_ref.syntax().clone(), d.definition()))\n+            },\n+            ast::Name(name) => {\n+                classify_name(&sema, &name).map(|d| (name.syntax().clone(), d.definition()))\n+            },\n+            _ => None,\n+        }\n+    } {\n+        let range = sema.original_range(&node).range;\n+        res.extend(hover_text_from_name_kind(db, name_kind));\n+\n+        if !res.is_empty() {\n+            return Some(RangeInfo::new(range, res));\n+        }\n+    }\n+\n+    let node = token\n+        .ancestors()\n+        .find(|n| ast::Expr::cast(n.clone()).is_some() || ast::Pat::cast(n.clone()).is_some())?;\n+\n+    let ty = match_ast! {\n+        match node {\n+            ast::MacroCall(_it) => {\n+                // If this node is a MACRO_CALL, it means that `descend_into_macros` failed to resolve.\n+                // (e.g expanding a builtin macro). So we give up here.\n+                return None;\n+            },\n+            ast::Expr(it) => {\n+                sema.type_of_expr(&it)\n+            },\n+            ast::Pat(it) => {\n+                sema.type_of_pat(&it)\n+            },\n+            _ => None,\n+        }\n+    }?;\n+\n+    res.extend(Some(rust_code_markup(&ty.display(db))));\n+    let range = sema.original_range(&node).range;\n+    Some(RangeInfo::new(range, res))\n+}\n+\n fn hover_text(\n     docs: Option<String>,\n     desc: Option<String>,\n@@ -160,59 +215,6 @@ fn hover_text_from_name_kind(db: &RootDatabase, def: Definition) -> Option<Strin\n     }\n }\n \n-pub(crate) fn hover(db: &RootDatabase, position: FilePosition) -> Option<RangeInfo<HoverResult>> {\n-    let sema = Semantics::new(db);\n-    let file = sema.parse(position.file_id).syntax().clone();\n-    let token = pick_best(file.token_at_offset(position.offset))?;\n-    let token = sema.descend_into_macros(token);\n-\n-    let mut res = HoverResult::new();\n-\n-    if let Some((node, name_kind)) = match_ast! {\n-        match (token.parent()) {\n-            ast::NameRef(name_ref) => {\n-                classify_name_ref(&sema, &name_ref).map(|d| (name_ref.syntax().clone(), d.definition()))\n-            },\n-            ast::Name(name) => {\n-                classify_name(&sema, &name).map(|d| (name.syntax().clone(), d.definition()))\n-            },\n-            _ => None,\n-        }\n-    } {\n-        let range = sema.original_range(&node).range;\n-        res.extend(hover_text_from_name_kind(db, name_kind));\n-\n-        if !res.is_empty() {\n-            return Some(RangeInfo::new(range, res));\n-        }\n-    }\n-\n-    let node = token\n-        .ancestors()\n-        .find(|n| ast::Expr::cast(n.clone()).is_some() || ast::Pat::cast(n.clone()).is_some())?;\n-\n-    let ty = match_ast! {\n-        match node {\n-            ast::MacroCall(_it) => {\n-                // If this node is a MACRO_CALL, it means that `descend_into_macros` failed to resolve.\n-                // (e.g expanding a builtin macro). So we give up here.\n-                return None;\n-            },\n-            ast::Expr(it) => {\n-                sema.type_of_expr(&it)\n-            },\n-            ast::Pat(it) => {\n-                sema.type_of_pat(&it)\n-            },\n-            _ => None,\n-        }\n-    }?;\n-\n-    res.extend(Some(rust_code_markup(&ty.display(db))));\n-    let range = sema.original_range(&node).range;\n-    Some(RangeInfo::new(range, res))\n-}\n-\n fn pick_best(tokens: TokenAtOffset<SyntaxToken>) -> Option<SyntaxToken> {\n     return tokens.max_by_key(priority);\n     fn priority(n: &SyntaxToken) -> usize {"}, {"sha": "75bd3c96bb1fc841d6fc4473c7248913e871e492", "filename": "crates/ra_ide/src/inlay_hints.rs", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/09df51dab89340bcf4b8ede95c02c32b0c8eb2bc/crates%2Fra_ide%2Fsrc%2Finlay_hints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09df51dab89340bcf4b8ede95c02c32b0c8eb2bc/crates%2Fra_ide%2Fsrc%2Finlay_hints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Finlay_hints.rs?ref=09df51dab89340bcf4b8ede95c02c32b0c8eb2bc", "patch": "@@ -1,5 +1,3 @@\n-//! This module defines multiple types of inlay hints and their visibility\n-\n use hir::{Adt, HirDisplay, Semantics, Type};\n use ra_ide_db::RootDatabase;\n use ra_prof::profile;\n@@ -39,6 +37,26 @@ pub struct InlayHint {\n     pub label: SmolStr,\n }\n \n+// Feature: Inlay Hints\n+//\n+// rust-analyzer shows additional information inline with the source code.\n+// Editors usually render this using read-only virtual text snippets interspersed with code.\n+//\n+// rust-analyzer shows hits for\n+//\n+// * types of local variables\n+// * names of function arguments\n+// * types of chained expressions\n+//\n+// **Note:** VS Code does not have native support for inlay hints https://github.com/microsoft/vscode/issues/16221[yet] and the hints are implemented using decorations.\n+// This approach has limitations, the caret movement and bracket highlighting near the edges of the hint may be weird:\n+// https://github.com/rust-analyzer/rust-analyzer/issues/1623[1], https://github.com/rust-analyzer/rust-analyzer/issues/3453[2].\n+//\n+// |===\n+// | Editor  | Action Name\n+//\n+// | VS Code | **Rust Analyzer: Toggle inlay hints*\n+// |===\n pub(crate) fn inlay_hints(\n     db: &RootDatabase,\n     file_id: FileId,"}, {"sha": "5036c1fb0c62ee4dea5847d416884d91e3d0a804", "filename": "crates/ra_ide/src/join_lines.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/09df51dab89340bcf4b8ede95c02c32b0c8eb2bc/crates%2Fra_ide%2Fsrc%2Fjoin_lines.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09df51dab89340bcf4b8ede95c02c32b0c8eb2bc/crates%2Fra_ide%2Fsrc%2Fjoin_lines.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fjoin_lines.rs?ref=09df51dab89340bcf4b8ede95c02c32b0c8eb2bc", "patch": "@@ -1,5 +1,3 @@\n-//! FIXME: write short doc here\n-\n use itertools::Itertools;\n use ra_fmt::{compute_ws, extract_trivial_expression};\n use ra_syntax::{\n@@ -11,6 +9,15 @@ use ra_syntax::{\n };\n use ra_text_edit::{TextEdit, TextEditBuilder};\n \n+// Feature: Join Lines\n+//\n+// Join selected lines into one, smartly fixing up whitespace, trailing commas, and braces.\n+//\n+// |===\n+// | Editor  | Action Name\n+//\n+// | VS Code | **Rust Analyzer: Join lines**\n+// |===\n pub fn join_lines(file: &SourceFile, range: TextRange) -> TextEdit {\n     let range = if range.is_empty() {\n         let syntax = file.syntax();"}, {"sha": "12d5716e83598ac3c02ef74c70040de4ff1b0cbc", "filename": "crates/ra_ide/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/09df51dab89340bcf4b8ede95c02c32b0c8eb2bc/crates%2Fra_ide%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09df51dab89340bcf4b8ede95c02c32b0c8eb2bc/crates%2Fra_ide%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Flib.rs?ref=09df51dab89340bcf4b8ede95c02c32b0c8eb2bc", "patch": "@@ -23,14 +23,14 @@ mod completion;\n mod runnables;\n mod goto_definition;\n mod goto_type_definition;\n+mod goto_implementation;\n mod extend_selection;\n mod hover;\n mod call_hierarchy;\n mod call_info;\n mod syntax_highlighting;\n mod parent_module;\n mod references;\n-mod impls;\n mod diagnostics;\n mod syntax_tree;\n mod folding_ranges;\n@@ -373,7 +373,7 @@ impl Analysis {\n         &self,\n         position: FilePosition,\n     ) -> Cancelable<Option<RangeInfo<Vec<NavigationTarget>>>> {\n-        self.with_db(|db| impls::goto_implementation(db, position))\n+        self.with_db(|db| goto_implementation::goto_implementation(db, position))\n     }\n \n     /// Returns the type definitions for the symbol at `position`."}, {"sha": "407a9636d1d1f7de837ac0dfe053a9556a435f32", "filename": "crates/ra_ide/src/matching_brace.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/09df51dab89340bcf4b8ede95c02c32b0c8eb2bc/crates%2Fra_ide%2Fsrc%2Fmatching_brace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09df51dab89340bcf4b8ede95c02c32b0c8eb2bc/crates%2Fra_ide%2Fsrc%2Fmatching_brace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fmatching_brace.rs?ref=09df51dab89340bcf4b8ede95c02c32b0c8eb2bc", "patch": "@@ -1,7 +1,16 @@\n-//! FIXME: write short doc here\n-\n use ra_syntax::{ast::AstNode, SourceFile, SyntaxKind, TextSize, T};\n \n+// Feature: Matching Brace\n+//\n+// If the cursor is on any brace (`<>(){}[]`) which is a part of a brace-pair,\n+// moves cursor to the matching brace. It uses the actual parser to determine\n+// braces, so it won't confuse generics with comparisons.\n+//\n+// |===\n+// | Editor  | Action Name\n+//\n+// | VS Code | **Rust Analyzer: Find matching brace**\n+// |===\n pub fn matching_brace(file: &SourceFile, offset: TextSize) -> Option<TextSize> {\n     const BRACES: &[SyntaxKind] =\n         &[T!['{'], T!['}'], T!['['], T![']'], T!['('], T![')'], T![<], T![>]];"}, {"sha": "fa1535da5b0a95147316277071b1c13b40cf8c5d", "filename": "crates/ra_ide/src/parent_module.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/09df51dab89340bcf4b8ede95c02c32b0c8eb2bc/crates%2Fra_ide%2Fsrc%2Fparent_module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09df51dab89340bcf4b8ede95c02c32b0c8eb2bc/crates%2Fra_ide%2Fsrc%2Fparent_module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fparent_module.rs?ref=09df51dab89340bcf4b8ede95c02c32b0c8eb2bc", "patch": "@@ -1,5 +1,3 @@\n-//! FIXME: write short doc here\n-\n use hir::Semantics;\n use ra_db::{CrateId, FileId, FilePosition};\n use ra_ide_db::RootDatabase;\n@@ -11,6 +9,16 @@ use test_utils::mark;\n \n use crate::NavigationTarget;\n \n+// Feature: Parent Module\n+//\n+// Navigates to the parent module of the current module.\n+//\n+// |===\n+// | Editor  | Action Name\n+//\n+// | VS Code | **Rust Analyzer: Locate parent module**\n+// |===\n+\n /// This returns `Vec` because a module may be included from several places. We\n /// don't handle this case yet though, so the Vec has length at most one.\n pub(crate) fn parent_module(db: &RootDatabase, position: FilePosition) -> Vec<NavigationTarget> {"}, {"sha": "286d45eee952c55cbad03be06791cc942590af65", "filename": "crates/ra_ide/src/runnables.rs", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/09df51dab89340bcf4b8ede95c02c32b0c8eb2bc/crates%2Fra_ide%2Fsrc%2Frunnables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09df51dab89340bcf4b8ede95c02c32b0c8eb2bc/crates%2Fra_ide%2Fsrc%2Frunnables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Frunnables.rs?ref=09df51dab89340bcf4b8ede95c02c32b0c8eb2bc", "patch": "@@ -1,5 +1,3 @@\n-//! FIXME: write short doc here\n-\n use hir::{AsAssocItem, Attrs, HirFileId, InFile, Semantics};\n use itertools::Itertools;\n use ra_ide_db::RootDatabase;\n@@ -44,6 +42,17 @@ pub enum RunnableKind {\n     Bin,\n }\n \n+// Feature: Run\n+//\n+// Shows a popup suggesting to run a test/benchmark/binary **at the current cursor\n+// location**. Super useful for repeatedly running just a single test. Do bind this\n+// to a shortcut!\n+//\n+// |===\n+// | Editor  | Action Name\n+//\n+// | VS Code | **Rust Analyzer: Run**\n+// |===\n pub(crate) fn runnables(db: &RootDatabase, file_id: FileId) -> Vec<Runnable> {\n     let sema = Semantics::new(db);\n     let source_file = sema.parse(file_id);"}, {"sha": "93e9aee1d01e47ca8db25bef13bef269f91ce4f1", "filename": "crates/ra_ide/src/ssr.rs", "status": "modified", "additions": 22, "deletions": 2, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/09df51dab89340bcf4b8ede95c02c32b0c8eb2bc/crates%2Fra_ide%2Fsrc%2Fssr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09df51dab89340bcf4b8ede95c02c32b0c8eb2bc/crates%2Fra_ide%2Fsrc%2Fssr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fssr.rs?ref=09df51dab89340bcf4b8ede95c02c32b0c8eb2bc", "patch": "@@ -1,5 +1,3 @@\n-//!  structural search replace\n-\n use std::{collections::HashMap, iter::once, str::FromStr};\n \n use ra_db::{SourceDatabase, SourceDatabaseExt};\n@@ -25,6 +23,28 @@ impl std::fmt::Display for SsrError {\n \n impl std::error::Error for SsrError {}\n \n+// Feature: Structural Seach and Replace\n+//\n+// Search and replace with named wildcards that will match any expression.\n+// The syntax for a structural search replace command is `<search_pattern> ==>> <replace_pattern>`.\n+// A `$<name>:expr` placeholder in the search pattern will match any expression and `$<name>` will reference it in the replacement.\n+// Available via the command `rust-analyzer.ssr`.\n+//\n+// ```rust\n+// // Using structural search replace command [foo($a:expr, $b:expr) ==>> ($a).foo($b)]\n+//\n+// // BEFORE\n+// String::from(foo(y + 5, z))\n+//\n+// // AFTER\n+// String::from((y + 5).foo(z))\n+// ```\n+//\n+// |===\n+// | Editor  | Action Name\n+//\n+// | VS Code | **Rust Analyzer: Structural Search Replace**\n+// |===\n pub fn parse_search_replace(\n     query: &str,\n     parse_only: bool,"}, {"sha": "5b7992920071d5f3e335555e98d37cdfdbc3cc5b", "filename": "crates/ra_ide/src/status.rs", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/09df51dab89340bcf4b8ede95c02c32b0c8eb2bc/crates%2Fra_ide%2Fsrc%2Fstatus.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09df51dab89340bcf4b8ede95c02c32b0c8eb2bc/crates%2Fra_ide%2Fsrc%2Fstatus.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fstatus.rs?ref=09df51dab89340bcf4b8ede95c02c32b0c8eb2bc", "patch": "@@ -1,5 +1,3 @@\n-//! FIXME: write short doc here\n-\n use std::{fmt, iter::FromIterator, sync::Arc};\n \n use hir::MacroFile;\n@@ -26,6 +24,15 @@ fn macro_syntax_tree_stats(db: &RootDatabase) -> SyntaxTreeStats {\n     db.query(hir::db::ParseMacroQuery).entries::<SyntaxTreeStats>()\n }\n \n+// Feature: Status\n+//\n+// Shows internal statistic about memory usage of rust-analyzer.\n+//\n+// |===\n+// | Editor  | Action Name\n+//\n+// | VS Code | **Rust Analyzer: Status**\n+// |===\n pub(crate) fn status(db: &RootDatabase) -> String {\n     let files_stats = db.query(FileTextQuery).entries::<FilesStats>();\n     let syntax_tree_stats = syntax_tree_stats(db);"}, {"sha": "0b53ebe69563806fb96fae778ff800b76631d44c", "filename": "crates/ra_ide/src/syntax_highlighting.rs", "status": "modified", "additions": 84, "deletions": 77, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/09df51dab89340bcf4b8ede95c02c32b0c8eb2bc/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09df51dab89340bcf4b8ede95c02c32b0c8eb2bc/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsyntax_highlighting.rs?ref=09df51dab89340bcf4b8ede95c02c32b0c8eb2bc", "patch": "@@ -1,5 +1,3 @@\n-//! Implements syntax highlighting.\n-\n mod tags;\n mod html;\n #[cfg(test)]\n@@ -32,81 +30,15 @@ pub struct HighlightedRange {\n     pub binding_hash: Option<u64>,\n }\n \n-#[derive(Debug)]\n-struct HighlightedRangeStack {\n-    stack: Vec<Vec<HighlightedRange>>,\n-}\n-\n-/// We use a stack to implement the flattening logic for the highlighted\n-/// syntax ranges.\n-impl HighlightedRangeStack {\n-    fn new() -> Self {\n-        Self { stack: vec![Vec::new()] }\n-    }\n-\n-    fn push(&mut self) {\n-        self.stack.push(Vec::new());\n-    }\n-\n-    /// Flattens the highlighted ranges.\n-    ///\n-    /// For example `#[cfg(feature = \"foo\")]` contains the nested ranges:\n-    /// 1) parent-range: Attribute [0, 23)\n-    /// 2) child-range: String [16, 21)\n-    ///\n-    /// The following code implements the flattening, for our example this results to:\n-    /// `[Attribute [0, 16), String [16, 21), Attribute [21, 23)]`\n-    fn pop(&mut self) {\n-        let children = self.stack.pop().unwrap();\n-        let prev = self.stack.last_mut().unwrap();\n-        let needs_flattening = !children.is_empty()\n-            && !prev.is_empty()\n-            && prev.last().unwrap().range.contains_range(children.first().unwrap().range);\n-        if !needs_flattening {\n-            prev.extend(children);\n-        } else {\n-            let mut parent = prev.pop().unwrap();\n-            for ele in children {\n-                assert!(parent.range.contains_range(ele.range));\n-                let mut cloned = parent.clone();\n-                parent.range = TextRange::new(parent.range.start(), ele.range.start());\n-                cloned.range = TextRange::new(ele.range.end(), cloned.range.end());\n-                if !parent.range.is_empty() {\n-                    prev.push(parent);\n-                }\n-                prev.push(ele);\n-                parent = cloned;\n-            }\n-            if !parent.range.is_empty() {\n-                prev.push(parent);\n-            }\n-        }\n-    }\n-\n-    fn add(&mut self, range: HighlightedRange) {\n-        self.stack\n-            .last_mut()\n-            .expect(\"during DFS traversal, the stack must not be empty\")\n-            .push(range)\n-    }\n-\n-    fn flattened(mut self) -> Vec<HighlightedRange> {\n-        assert_eq!(\n-            self.stack.len(),\n-            1,\n-            \"after DFS traversal, the stack should only contain a single element\"\n-        );\n-        let mut res = self.stack.pop().unwrap();\n-        res.sort_by_key(|range| range.range.start());\n-        // Check that ranges are sorted and disjoint\n-        assert!(res\n-            .iter()\n-            .zip(res.iter().skip(1))\n-            .all(|(left, right)| left.range.end() <= right.range.start()));\n-        res\n-    }\n-}\n-\n+// Feature: Semantic Syntax Highlighting\n+//\n+// rust-analyzer highlights the code semantically.\n+// For example, `bar` in `foo::Bar` might be colored differently depending on whether `Bar` is an enum or a trait.\n+// rust-analyzer does not specify colors directly, instead it assigns tag (like `struct`) and a set of modifiers (like `declaration`) to each token.\n+// It's up to the client to map those to specific colors.\n+//\n+// The general rule is that a reference to an entity gets colored the same way as the entity itself.\n+// We also give special modifier for `mut` and `&mut` local variables.\n pub(crate) fn highlight(\n     db: &RootDatabase,\n     file_id: FileId,\n@@ -291,6 +223,81 @@ pub(crate) fn highlight(\n     stack.flattened()\n }\n \n+#[derive(Debug)]\n+struct HighlightedRangeStack {\n+    stack: Vec<Vec<HighlightedRange>>,\n+}\n+\n+/// We use a stack to implement the flattening logic for the highlighted\n+/// syntax ranges.\n+impl HighlightedRangeStack {\n+    fn new() -> Self {\n+        Self { stack: vec![Vec::new()] }\n+    }\n+\n+    fn push(&mut self) {\n+        self.stack.push(Vec::new());\n+    }\n+\n+    /// Flattens the highlighted ranges.\n+    ///\n+    /// For example `#[cfg(feature = \"foo\")]` contains the nested ranges:\n+    /// 1) parent-range: Attribute [0, 23)\n+    /// 2) child-range: String [16, 21)\n+    ///\n+    /// The following code implements the flattening, for our example this results to:\n+    /// `[Attribute [0, 16), String [16, 21), Attribute [21, 23)]`\n+    fn pop(&mut self) {\n+        let children = self.stack.pop().unwrap();\n+        let prev = self.stack.last_mut().unwrap();\n+        let needs_flattening = !children.is_empty()\n+            && !prev.is_empty()\n+            && prev.last().unwrap().range.contains_range(children.first().unwrap().range);\n+        if !needs_flattening {\n+            prev.extend(children);\n+        } else {\n+            let mut parent = prev.pop().unwrap();\n+            for ele in children {\n+                assert!(parent.range.contains_range(ele.range));\n+                let mut cloned = parent.clone();\n+                parent.range = TextRange::new(parent.range.start(), ele.range.start());\n+                cloned.range = TextRange::new(ele.range.end(), cloned.range.end());\n+                if !parent.range.is_empty() {\n+                    prev.push(parent);\n+                }\n+                prev.push(ele);\n+                parent = cloned;\n+            }\n+            if !parent.range.is_empty() {\n+                prev.push(parent);\n+            }\n+        }\n+    }\n+\n+    fn add(&mut self, range: HighlightedRange) {\n+        self.stack\n+            .last_mut()\n+            .expect(\"during DFS traversal, the stack must not be empty\")\n+            .push(range)\n+    }\n+\n+    fn flattened(mut self) -> Vec<HighlightedRange> {\n+        assert_eq!(\n+            self.stack.len(),\n+            1,\n+            \"after DFS traversal, the stack should only contain a single element\"\n+        );\n+        let mut res = self.stack.pop().unwrap();\n+        res.sort_by_key(|range| range.range.start());\n+        // Check that ranges are sorted and disjoint\n+        assert!(res\n+            .iter()\n+            .zip(res.iter().skip(1))\n+            .all(|(left, right)| left.range.end() <= right.range.start()));\n+        res\n+    }\n+}\n+\n fn highlight_format_specifier(kind: FormatSpecifier) -> Option<HighlightTag> {\n     Some(match kind {\n         FormatSpecifier::Open"}, {"sha": "a341684fda203cf697c758a438d36ba144c75684", "filename": "crates/ra_ide/src/syntax_tree.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/09df51dab89340bcf4b8ede95c02c32b0c8eb2bc/crates%2Fra_ide%2Fsrc%2Fsyntax_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09df51dab89340bcf4b8ede95c02c32b0c8eb2bc/crates%2Fra_ide%2Fsrc%2Fsyntax_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fsyntax_tree.rs?ref=09df51dab89340bcf4b8ede95c02c32b0c8eb2bc", "patch": "@@ -1,15 +1,21 @@\n-//! FIXME: write short doc here\n-\n-use ra_db::SourceDatabase;\n+use ra_db::{FileId, SourceDatabase};\n use ra_ide_db::RootDatabase;\n use ra_syntax::{\n     algo, AstNode, NodeOrToken, SourceFile,\n     SyntaxKind::{RAW_STRING, STRING},\n     SyntaxToken, TextRange, TextSize,\n };\n \n-pub use ra_db::FileId;\n-\n+// Feature: Show Syntax Tree\n+//\n+// Shows the parse tree of the current file. It exists mostly for debugging\n+// rust-analyzer itself.\n+//\n+// |===\n+// | Editor  | Action Name\n+//\n+// | VS Code | **Rust Analyzer: Show Syntax Tree**\n+// |===\n pub(crate) fn syntax_tree(\n     db: &RootDatabase,\n     file_id: FileId,"}, {"sha": "67e2c33a000ed95ba9f28855923e37ee7cadfe11", "filename": "crates/ra_ide/src/typing.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/09df51dab89340bcf4b8ede95c02c32b0c8eb2bc/crates%2Fra_ide%2Fsrc%2Ftyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09df51dab89340bcf4b8ede95c02c32b0c8eb2bc/crates%2Fra_ide%2Fsrc%2Ftyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Ftyping.rs?ref=09df51dab89340bcf4b8ede95c02c32b0c8eb2bc", "patch": "@@ -32,6 +32,13 @@ pub(crate) use on_enter::on_enter;\n \n pub(crate) const TRIGGER_CHARS: &str = \".=>\";\n \n+// Feature: On Typing Assists\n+//\n+// Some features trigger on typing certain characters:\n+//\n+// - typing `let =` tries to smartly add `;` if `=` is followed by an existing expression\n+// - Enter inside comments automatically inserts `///`\n+// - typing `.` in a chain method call auto-indents\n pub(crate) fn on_char_typed(\n     db: &RootDatabase,\n     position: FilePosition,"}, {"sha": "acc31fe3b51bd2b1b538e308cbf1124148a1b8ff", "filename": "crates/ra_ide_db/src/symbol_index.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/09df51dab89340bcf4b8ede95c02c32b0c8eb2bc/crates%2Fra_ide_db%2Fsrc%2Fsymbol_index.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09df51dab89340bcf4b8ede95c02c32b0c8eb2bc/crates%2Fra_ide_db%2Fsrc%2Fsymbol_index.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_db%2Fsrc%2Fsymbol_index.rs?ref=09df51dab89340bcf4b8ede95c02c32b0c8eb2bc", "patch": "@@ -110,6 +110,27 @@ fn file_symbols(db: &impl SymbolsDatabase, file_id: FileId) -> Arc<SymbolIndex>\n     Arc::new(SymbolIndex::new(symbols))\n }\n \n+// Feature: Workspace Symbol\n+//\n+// Uses fuzzy-search to find types, modules and functions by name across your\n+// project and dependencies. This is **the** most useful feature, which improves code\n+// navigation tremendously. It mostly works on top of the built-in LSP\n+// functionality, however `#` and `*` symbols can be used to narrow down the\n+// search. Specifically,\n+//\n+// - `Foo` searches for `Foo` type in the current workspace\n+// - `foo#` searches for `foo` function in the current workspace\n+// - `Foo*` searches for `Foo` type among dependencies, including `stdlib`\n+// - `foo#*` searches for `foo` function among dependencies\n+//\n+// That is, `#` switches from \"types\" to all symbols, `*` switches from the current\n+// workspace to dependencies.\n+//\n+// |===\n+// | Editor  | Shortcut\n+//\n+// | VS Code | kbd:[Ctrl+T]\n+// |===\n pub fn world_symbols(db: &RootDatabase, query: Query) -> Vec<FileSymbol> {\n     /// Need to wrap Snapshot to provide `Clone` impl for `map_with`\n     struct Snap(salsa::Snapshot<RootDatabase>);"}, {"sha": "04387e3b0ee2c7c0e74c717938aa07c2eba9911e", "filename": "docs/user/assists.md", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/09df51dab89340bcf4b8ede95c02c32b0c8eb2bc/docs%2Fuser%2Fassists.md", "raw_url": "https://github.com/rust-lang/rust/raw/09df51dab89340bcf4b8ede95c02c32b0c8eb2bc/docs%2Fuser%2Fassists.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fuser%2Fassists.md?ref=09df51dab89340bcf4b8ede95c02c32b0c8eb2bc", "patch": "@@ -56,6 +56,24 @@ fn main() {\n }\n ```\n \n+## `add_from_impl_for_enum`\n+\n+Adds a From impl for an enum variant with one tuple field.\n+\n+```rust\n+// BEFORE\n+enum A { \u2503One(u32) }\n+\n+// AFTER\n+enum A { One(u32) }\n+\n+impl From<u32> for A {\n+    fn from(v: u32) -> Self {\n+        A::One(v)\n+    }\n+}\n+```\n+\n ## `add_function`\n \n Adds a stub function with a signature matching the function under the cursor."}, {"sha": "12ecdec136a2a1fc6119c6661af9b0035b814ba2", "filename": "docs/user/features.md", "status": "removed", "additions": 0, "deletions": 218, "changes": 218, "blob_url": "https://github.com/rust-lang/rust/blob/5f7225446e75509ae0d971a6f3e2b9d3e37d6f2a/docs%2Fuser%2Ffeatures.md", "raw_url": "https://github.com/rust-lang/rust/raw/5f7225446e75509ae0d971a6f3e2b9d3e37d6f2a/docs%2Fuser%2Ffeatures.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fuser%2Ffeatures.md?ref=5f7225446e75509ae0d971a6f3e2b9d3e37d6f2a", "patch": "@@ -1,218 +0,0 @@\n-This document is an index of features that the rust-analyzer language server\n-provides. Shortcuts are for the default VS Code layout. If there's no shortcut,\n-you can use <kbd>Ctrl+Shift+P</kbd> to search for the corresponding action.\n-\n-### Workspace Symbol <kbd>ctrl+t</kbd>\n-\n-Uses fuzzy-search to find types, modules and functions by name across your\n-project and dependencies. This is **the** most useful feature, which improves code\n-navigation tremendously. It mostly works on top of the built-in LSP\n-functionality, however `#` and `*` symbols can be used to narrow down the\n-search. Specifically,\n-\n-- `Foo` searches for `Foo` type in the current workspace\n-- `foo#` searches for `foo` function in the current workspace\n-- `Foo*` searches for `Foo` type among dependencies, including `stdlib`\n-- `foo#*` searches for `foo` function among dependencies\n-\n-That is, `#` switches from \"types\" to all symbols, `*` switches from the current\n-workspace to dependencies.\n-\n-### Document Symbol <kbd>ctrl+shift+o</kbd>\n-\n-Provides a tree of the symbols defined in the file. Can be used to\n-\n-* fuzzy search symbol in a file (super useful)\n-* draw breadcrumbs to describe the context around the cursor\n-* draw outline of the file\n-\n-### On Typing Assists\n-\n-Some features trigger on typing certain characters:\n-\n-- typing `let =` tries to smartly add `;` if `=` is followed by an existing expression\n-- Enter inside comments automatically inserts `///`\n-- typing `.` in a chain method call auto-indents\n-\n-### Extend Selection\n-\n-Extends the current selection to the encompassing syntactic construct\n-(expression, statement, item, module, etc). It works with multiple cursors. This\n-is a relatively new feature of LSP:\n-https://github.com/Microsoft/language-server-protocol/issues/613, check your\n-editor's LSP library to see if this feature is supported.\n-\n-### Go to Definition\n-\n-Navigates to the definition of an identifier.\n-\n-### Go to Implementation\n-\n-Navigates to the impl block of structs, enums or traits. Also implemented as a code lens.\n-\n-### Go to Type Defintion\n-\n-Navigates to the type of an identifier.\n-\n-### Commands <kbd>ctrl+shift+p</kbd>\n-\n-#### Run\n-\n-Shows a popup suggesting to run a test/benchmark/binary **at the current cursor\n-location**. Super useful for repeatedly running just a single test. Do bind this\n-to a shortcut!\n-\n-#### Parent Module\n-\n-Navigates to the parent module of the current module.\n-\n-#### Matching Brace\n-\n-If the cursor is on any brace (`<>(){}[]`) which is a part of a brace-pair,\n-moves cursor to the matching brace. It uses the actual parser to determine\n-braces, so it won't confuse generics with comparisons.\n-\n-#### Join Lines\n-\n-Join selected lines into one, smartly fixing up whitespace and trailing commas.\n-\n-#### Show Syntax Tree\n-\n-Shows the parse tree of the current file. It exists mostly for debugging\n-rust-analyzer itself.\n-\n-#### Expand Macro Recursively\n-\n-Shows the full macro expansion of the macro at current cursor.\n-\n-#### Status\n-\n-Shows internal statistic about memory usage of rust-analyzer.\n-\n-#### Show RA Version\n-\n-Show current rust-analyzer version.\n-\n-#### Toggle inlay hints\n-\n-Toggle inlay hints view for the current workspace.\n-It is recommended to assign a shortcut for this command to quickly turn off\n-inlay hints when they prevent you from reading/writing the code.\n-\n-#### Run Garbage Collection\n-\n-Manually triggers GC.\n-\n-#### Start Cargo Watch\n-\n-Start `cargo watch` for live error highlighting. Will prompt to install if it's not already installed.\n-\n-#### Stop Cargo Watch\n-\n-Stop `cargo watch`.\n-\n-#### Structural Seach and Replace\n-\n-Search and replace with named wildcards that will match any expression.\n-The syntax for a structural search replace command is `<search_pattern> ==>> <replace_pattern>`. A `$<name>:expr` placeholder in the search pattern will match any expression and `$<name>` will reference it in the replacement. Available via the command `rust-analyzer.ssr`.\n-\n-```rust\n-// Using structural search replace command [foo($a:expr, $b:expr) ==>> ($a).foo($b)]\n-\n-// BEFORE\n-String::from(foo(y + 5, z))\n-\n-// AFTER\n-String::from((y + 5).foo(z))\n-```\n-\n-### Assists (Code Actions)\n-\n-Assists, or code actions, are small local refactorings, available in a particular context.\n-They are usually triggered by a shortcut or by clicking a light bulb icon in the editor.\n-\n-See [assists.md](./assists.md) for the list of available assists.\n-\n-### Magic Completions\n-\n-In addition to usual reference completion, rust-analyzer provides some \u2728magic\u2728\n-completions as well:\n-\n-Keywords like `if`, `else` `while`, `loop` are completed with braces, and cursor\n-is placed at the appropriate position. Even though `if` is easy to type, you\n-still want to complete it, to get ` { }` for free! `return` is inserted with a\n-space or `;` depending on the return type of the function.\n-\n-When completing a function call, `()` are automatically inserted. If a function\n-takes arguments, the cursor is positioned inside the parenthesis.\n-\n-There are postfix completions, which can be triggered by typing something like\n-`foo().if`. The word after `.` determines postfix completion. Possible variants are:\n-\n-- `expr.if` -> `if expr {}` or `if let ... {}` for `Option` or `Result`\n-- `expr.match` -> `match expr {}`\n-- `expr.while` -> `while expr {}` or `while let ... {}` for `Option` or `Result`\n-- `expr.ref` -> `&expr`\n-- `expr.refm` -> `&mut expr`\n-- `expr.not` -> `!expr`\n-- `expr.dbg` -> `dbg!(expr)`\n-\n-There also snippet completions:\n-\n-#### Inside Expressions\n-\n-- `pd` -> `println!(\"{:?}\")`\n-- `ppd` -> `println!(\"{:#?}\")`\n-\n-#### Inside Modules\n-\n-- `tfn` -> `#[test] fn f(){}`\n-- `tmod` ->\n-```rust\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-\n-    #[test]\n-    fn test_fn() {}\n-}\n-```\n-\n-### Code Highlighting\n-\n-Experimental feature to let rust-analyzer highlight Rust code instead of using the\n-default highlighter.\n-\n-#### Rainbow Highlighting\n-\n-Experimental feature that, given code highlighting using rust-analyzer is\n-active, will pick unique colors for identifiers.\n-\n-### Code hints\n-\n-Rust-analyzer has two types of hints to show the information about the code:\n-\n-* hover hints, appearing on hover on any element.\n-\n-These contain extended information on the hovered language item.\n-\n-* inlay hints, shown near the element hinted directly in the editor.\n-\n-Two types of inlay hints are displayed currently:\n-\n-* type hints, displaying the minimal information on the type of the expression (if the information is available)\n-* method chaining hints, type information for multi-line method chains\n-* parameter name hints, displaying the names of the parameters in the corresponding methods\n-\n-#### VS Code\n-\n-In VS Code, the following settings can be used to configure the inlay hints:\n-\n-* `rust-analyzer.inlayHints.typeHints` - enable hints for inferred types.\n-* `rust-analyzer.inlayHints.chainingHints` - enable hints for inferred types on method chains.\n-* `rust-analyzer.inlayHints.parameterHints` - enable hints for function parameters.\n-* `rust-analyzer.inlayHints.maxLength` \u2014\u00a0shortens the hints if their length exceeds the value specified. If no value is specified (`null`), no shortening is applied.\n-\n-**Note:** VS Code does not have native support for inlay hints [yet](https://github.com/microsoft/vscode/issues/16221) and the hints are implemented using decorations.\n-This approach has limitations, the caret movement and bracket highlighting near the edges of the hint may be weird:\n-[1](https://github.com/rust-analyzer/rust-analyzer/issues/1623), [2](https://github.com/rust-analyzer/rust-analyzer/issues/3453)."}, {"sha": "803073d550fc18f98a590d129488ca7e3dd25cfd", "filename": "docs/user/generated_features.adoc", "status": "added", "additions": 298, "deletions": 0, "changes": 298, "blob_url": "https://github.com/rust-lang/rust/blob/09df51dab89340bcf4b8ede95c02c32b0c8eb2bc/docs%2Fuser%2Fgenerated_features.adoc", "raw_url": "https://github.com/rust-lang/rust/raw/09df51dab89340bcf4b8ede95c02c32b0c8eb2bc/docs%2Fuser%2Fgenerated_features.adoc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fuser%2Fgenerated_features.adoc?ref=09df51dab89340bcf4b8ede95c02c32b0c8eb2bc", "patch": "@@ -0,0 +1,298 @@\n+=== Expand Macro Recursively\n+**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_ide/src/expand_macro.rs[expand_macro.rs]\n+\n+Shows the full macro expansion of the macro at current cursor.\n+\n+|===\n+| Editor  | Action Name\n+\n+| VS Code | **Rust Analyzer: Expand macro recursively**\n+|===\n+\n+\n+=== Extend Selection\n+**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_ide/src/extend_selection.rs[extend_selection.rs]\n+\n+Extends the current selection to the encompassing syntactic construct\n+(expression, statement, item, module, etc). It works with multiple cursors.\n+\n+|===\n+| Editor  | Shortcut\n+\n+| VS Code | kbd:[Ctrl+Shift+\u2192]\n+|===\n+\n+\n+=== File Structure\n+**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_ide/src/display/structure.rs[structure.rs]\n+\n+Provides a tree of the symbols defined in the file. Can be used to\n+\n+* fuzzy search symbol in a file (super useful)\n+* draw breadcrumbs to describe the context around the cursor\n+* draw outline of the file\n+\n+|===\n+| Editor  | Shortcut\n+\n+| VS Code | kbd:[Ctrl+Shift+O]\n+|===\n+\n+\n+=== Go to Definition\n+**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_ide/src/goto_definition.rs[goto_definition.rs]\n+\n+Navigates to the definition of an identifier.\n+\n+|===\n+| Editor  | Shortcut\n+\n+| VS Code | kbd:[F12]\n+|===\n+\n+\n+=== Go to Implementation\n+**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_ide/src/goto_implementation.rs[goto_implementation.rs]\n+\n+Navigates to the impl block of structs, enums or traits. Also implemented as a code lens.\n+\n+|===\n+| Editor  | Shortcut\n+\n+| VS Code | kbd:[Ctrl+F12]\n+|===\n+\n+\n+=== Go to Type Definition\n+**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_ide/src/goto_type_definition.rs[goto_type_definition.rs]\n+\n+Navigates to the type of an identifier.\n+\n+|===\n+| Editor  | Action Name\n+\n+| VS Code | **Go to Type Definition*\n+|===\n+\n+\n+=== Hover\n+**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_ide/src/hover.rs[hover.rs]\n+\n+Shows additional information, like type of an expression or documentation for definition when \"focusing\" code.\n+Focusing is usually hovering with a mouse, but can also be triggered with a shortcut.\n+\n+\n+=== Inlay Hints\n+**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_ide/src/inlay_hints.rs[inlay_hints.rs]\n+\n+rust-analyzer shows additional information inline with the source code.\n+Editors usually render this using read-only virtual text snippets interspersed with code.\n+\n+rust-analyzer shows hits for\n+\n+* types of local variables\n+* names of function arguments\n+* types of chained expressions\n+\n+**Note:** VS Code does not have native support for inlay hints https://github.com/microsoft/vscode/issues/16221[yet] and the hints are implemented using decorations.\n+This approach has limitations, the caret movement and bracket highlighting near the edges of the hint may be weird:\n+https://github.com/rust-analyzer/rust-analyzer/issues/1623[1], https://github.com/rust-analyzer/rust-analyzer/issues/3453[2].\n+\n+|===\n+| Editor  | Action Name\n+\n+| VS Code | **Rust Analyzer: Toggle inlay hints*\n+|===\n+\n+\n+=== Join Lines\n+**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_ide/src/join_lines.rs[join_lines.rs]\n+\n+Join selected lines into one, smartly fixing up whitespace, trailing commas, and braces.\n+\n+|===\n+| Editor  | Action Name\n+\n+| VS Code | **Rust Analyzer: Join lines**\n+|===\n+\n+\n+=== Magic Completions\n+**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_ide/src/completion.rs[completion.rs]\n+\n+In addition to usual reference completion, rust-analyzer provides some \u2728magic\u2728\n+completions as well:\n+\n+Keywords like `if`, `else` `while`, `loop` are completed with braces, and cursor\n+is placed at the appropriate position. Even though `if` is easy to type, you\n+still want to complete it, to get ` { }` for free! `return` is inserted with a\n+space or `;` depending on the return type of the function.\n+\n+When completing a function call, `()` are automatically inserted. If a function\n+takes arguments, the cursor is positioned inside the parenthesis.\n+\n+There are postfix completions, which can be triggered by typing something like\n+`foo().if`. The word after `.` determines postfix completion. Possible variants are:\n+\n+- `expr.if` -> `if expr {}` or `if let ... {}` for `Option` or `Result`\n+- `expr.match` -> `match expr {}`\n+- `expr.while` -> `while expr {}` or `while let ... {}` for `Option` or `Result`\n+- `expr.ref` -> `&expr`\n+- `expr.refm` -> `&mut expr`\n+- `expr.not` -> `!expr`\n+- `expr.dbg` -> `dbg!(expr)`\n+\n+There also snippet completions:\n+\n+.Expressions\n+- `pd` -> `println!(\"{:?}\")`\n+- `ppd` -> `println!(\"{:#?}\")`\n+\n+.Items\n+- `tfn` -> `#[test] fn f(){}`\n+- `tmod` ->\n+```rust\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    #[test]\n+    fn test_fn() {}\n+}\n+```\n+\n+\n+=== Matching Brace\n+**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_ide/src/matching_brace.rs[matching_brace.rs]\n+\n+If the cursor is on any brace (`<>(){}[]`) which is a part of a brace-pair,\n+moves cursor to the matching brace. It uses the actual parser to determine\n+braces, so it won't confuse generics with comparisons.\n+\n+|===\n+| Editor  | Action Name\n+\n+| VS Code | **Rust Analyzer: Find matching brace**\n+|===\n+\n+\n+=== On Typing Assists\n+**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_ide/src/typing.rs[typing.rs]\n+\n+Some features trigger on typing certain characters:\n+\n+- typing `let =` tries to smartly add `;` if `=` is followed by an existing expression\n+- Enter inside comments automatically inserts `///`\n+- typing `.` in a chain method call auto-indents\n+\n+\n+=== Parent Module\n+**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_ide/src/parent_module.rs[parent_module.rs]\n+\n+Navigates to the parent module of the current module.\n+\n+|===\n+| Editor  | Action Name\n+\n+| VS Code | **Rust Analyzer: Locate parent module**\n+|===\n+\n+\n+=== Run\n+**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_ide/src/runnables.rs[runnables.rs]\n+\n+Shows a popup suggesting to run a test/benchmark/binary **at the current cursor\n+location**. Super useful for repeatedly running just a single test. Do bind this\n+to a shortcut!\n+\n+|===\n+| Editor  | Action Name\n+\n+| VS Code | **Rust Analyzer: Run**\n+|===\n+\n+\n+=== Semantic Syntax Highlighting\n+**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_ide/src/syntax_highlighting.rs[syntax_highlighting.rs]\n+\n+rust-analyzer highlights the code semantically.\n+For example, `bar` in `foo::Bar` might be colored differently depending on whether `Bar` is an enum or a trait.\n+rust-analyzer does not specify colors directly, instead it assigns tag (like `struct`) and a set of modifiers (like `declaration`) to each token.\n+It's up to the client to map those to specific colors.\n+\n+The general rule is that a reference to an entity gets colored the same way as the entity itself.\n+We also give special modifier for `mut` and `&mut` local variables.\n+\n+\n+=== Show Syntax Tree\n+**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_ide/src/syntax_tree.rs[syntax_tree.rs]\n+\n+Shows the parse tree of the current file. It exists mostly for debugging\n+rust-analyzer itself.\n+\n+|===\n+| Editor  | Action Name\n+\n+| VS Code | **Rust Analyzer: Show Syntax Tree**\n+|===\n+\n+\n+=== Status\n+**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_ide/src/status.rs[status.rs]\n+\n+Shows internal statistic about memory usage of rust-analyzer.\n+\n+|===\n+| Editor  | Action Name\n+\n+| VS Code | **Rust Analyzer: Status**\n+|===\n+\n+\n+=== Structural Seach and Replace\n+**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_ide/src/ssr.rs[ssr.rs]\n+\n+Search and replace with named wildcards that will match any expression.\n+The syntax for a structural search replace command is `<search_pattern> ==>> <replace_pattern>`.\n+A `$<name>:expr` placeholder in the search pattern will match any expression and `$<name>` will reference it in the replacement.\n+Available via the command `rust-analyzer.ssr`.\n+\n+```rust\n+// Using structural search replace command [foo($a:expr, $b:expr) ==>> ($a).foo($b)]\n+\n+// BEFORE\n+String::from(foo(y + 5, z))\n+\n+// AFTER\n+String::from((y + 5).foo(z))\n+```\n+\n+|===\n+| Editor  | Action Name\n+\n+| VS Code | **Rust Analyzer: Structural Search Replace**\n+|===\n+\n+\n+=== Workspace Symbol\n+**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/crates/ra_ide_db/src/symbol_index.rs[symbol_index.rs]\n+\n+Uses fuzzy-search to find types, modules and functions by name across your\n+project and dependencies. This is **the** most useful feature, which improves code\n+navigation tremendously. It mostly works on top of the built-in LSP\n+functionality, however `#` and `*` symbols can be used to narrow down the\n+search. Specifically,\n+\n+- `Foo` searches for `Foo` type in the current workspace\n+- `foo#` searches for `foo` function in the current workspace\n+- `Foo*` searches for `Foo` type among dependencies, including `stdlib`\n+- `foo#*` searches for `foo` function among dependencies\n+\n+That is, `#` switches from \"types\" to all symbols, `*` switches from the current\n+workspace to dependencies.\n+\n+|===\n+| Editor  | Shortcut\n+\n+| VS Code | kbd:[Ctrl+T]\n+|==="}, {"sha": "12def732710c2643b89e704bdc99c2eb7a66e869", "filename": "docs/user/readme.adoc", "status": "modified", "additions": 11, "deletions": 2, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/09df51dab89340bcf4b8ede95c02c32b0c8eb2bc/docs%2Fuser%2Freadme.adoc", "raw_url": "https://github.com/rust-lang/rust/raw/09df51dab89340bcf4b8ede95c02c32b0c8eb2bc/docs%2Fuser%2Freadme.adoc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/docs%2Fuser%2Freadme.adoc?ref=09df51dab89340bcf4b8ede95c02c32b0c8eb2bc", "patch": "@@ -8,6 +8,8 @@\n :important-caption: :heavy_exclamation_mark:\n :caution-caption: :fire:\n :warning-caption: :warning:\n+:source-highlighter: rouge\n+:experimental:\n \n // Master copy of this document lives in the https://github.com/rust-analyzer/rust-analyzer repository\n \n@@ -268,6 +270,13 @@ Gnome Builder currently has support for RLS, and there's no way to configure the\n 1. Rename, symlink or copy the `rust-analyzer` binary to `rls` and place it somewhere Builder can find (in `PATH`, or under `~/.cargo/bin`).\n 2. Enable the Rust Builder plugin.\n \n-== Usage\n+== Features\n \n-See https://github.com/rust-analyzer/rust-analyzer/blob/master/docs/user/features.md[features.md].\n+include::./generated_features.adoc[]\n+\n+== Assists (Code Actions)\n+\n+Assists, or code actions, are small local refactorings, available in a particular context.\n+They are usually triggered by a shortcut or by clicking a light bulb icon in the editor.\n+\n+See [assists.md](./assists.md) for the list of available assists."}, {"sha": "f47d54125f35359dd9d9351b707009d551c0296c", "filename": "xtask/src/codegen.rs", "status": "modified", "additions": 22, "deletions": 5, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/09df51dab89340bcf4b8ede95c02c32b0c8eb2bc/xtask%2Fsrc%2Fcodegen.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09df51dab89340bcf4b8ede95c02c32b0c8eb2bc/xtask%2Fsrc%2Fcodegen.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fcodegen.rs?ref=09df51dab89340bcf4b8ede95c02c32b0c8eb2bc", "patch": "@@ -8,14 +8,15 @@\n mod gen_syntax;\n mod gen_parser_tests;\n mod gen_assists_docs;\n+mod gen_feature_docs;\n \n use std::{mem, path::Path};\n \n use crate::{not_bash::fs2, Result};\n \n pub use self::{\n-    gen_assists_docs::generate_assists_docs, gen_parser_tests::generate_parser_tests,\n-    gen_syntax::generate_syntax,\n+    gen_assists_docs::generate_assists_docs, gen_feature_docs::generate_feature_docs,\n+    gen_parser_tests::generate_parser_tests, gen_syntax::generate_syntax,\n };\n \n const GRAMMAR_DIR: &str = \"crates/ra_parser/src/grammar\";\n@@ -40,7 +41,7 @@ pub enum Mode {\n /// With verify = false,\n fn update(path: &Path, contents: &str, mode: Mode) -> Result<()> {\n     match fs2::read_to_string(path) {\n-        Ok(ref old_contents) if normalize(old_contents) == normalize(contents) => {\n+        Ok(old_contents) if normalize(&old_contents) == normalize(contents) => {\n             return Ok(());\n         }\n         _ => (),\n@@ -61,8 +62,24 @@ fn extract_comment_blocks(text: &str) -> Vec<Vec<String>> {\n     do_extract_comment_blocks(text, false)\n }\n \n-fn extract_comment_blocks_with_empty_lines(text: &str) -> Vec<Vec<String>> {\n-    do_extract_comment_blocks(text, true)\n+fn extract_comment_blocks_with_empty_lines(tag: &str, text: &str) -> Vec<CommentBlock> {\n+    assert!(tag.starts_with(char::is_uppercase));\n+    let tag = format!(\"{}:\", tag);\n+    let mut res = Vec::new();\n+    for mut block in do_extract_comment_blocks(text, true) {\n+        let first = block.remove(0);\n+        if first.starts_with(&tag) {\n+            let id = first[tag.len()..].trim().to_string();\n+            let block = CommentBlock { id, contents: block };\n+            res.push(block);\n+        }\n+    }\n+    res\n+}\n+\n+struct CommentBlock {\n+    id: String,\n+    contents: Vec<String>,\n }\n \n fn do_extract_comment_blocks(text: &str, allow_blocks_with_empty_lines: bool) -> Vec<Vec<String>> {"}, {"sha": "6ebeb8aea4e7a53b2af7db60d78a60c428da8c8c", "filename": "xtask/src/codegen/gen_assists_docs.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/09df51dab89340bcf4b8ede95c02c32b0c8eb2bc/xtask%2Fsrc%2Fcodegen%2Fgen_assists_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09df51dab89340bcf4b8ede95c02c32b0c8eb2bc/xtask%2Fsrc%2Fcodegen%2Fgen_assists_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fcodegen%2Fgen_assists_docs.rs?ref=09df51dab89340bcf4b8ede95c02c32b0c8eb2bc", "patch": "@@ -33,22 +33,18 @@ impl Assist {\n \n         fn collect_file(acc: &mut Vec<Assist>, path: &Path) -> Result<()> {\n             let text = fs::read_to_string(path)?;\n-            let comment_blocks = extract_comment_blocks_with_empty_lines(&text);\n+            let comment_blocks = extract_comment_blocks_with_empty_lines(\"Assist\", &text);\n \n             for block in comment_blocks {\n                 // FIXME: doesn't support blank lines yet, need to tweak\n                 // `extract_comment_blocks` for that.\n-                let mut lines = block.iter();\n-                let first_line = lines.next().unwrap();\n-                if !first_line.starts_with(\"Assist: \") {\n-                    continue;\n-                }\n-                let id = first_line[\"Assist: \".len()..].to_string();\n+                let id = block.id;\n                 assert!(\n                     id.chars().all(|it| it.is_ascii_lowercase() || it == '_'),\n                     \"invalid assist id: {:?}\",\n                     id\n                 );\n+                let mut lines = block.contents.iter();\n \n                 let doc = take_until(lines.by_ref(), \"```\").trim().to_string();\n                 assert!("}, {"sha": "dbe583e8e4f704ccc9879fef1abc657713ac7eaf", "filename": "xtask/src/codegen/gen_feature_docs.rs", "status": "added", "additions": 88, "deletions": 0, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/09df51dab89340bcf4b8ede95c02c32b0c8eb2bc/xtask%2Fsrc%2Fcodegen%2Fgen_feature_docs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09df51dab89340bcf4b8ede95c02c32b0c8eb2bc/xtask%2Fsrc%2Fcodegen%2Fgen_feature_docs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fcodegen%2Fgen_feature_docs.rs?ref=09df51dab89340bcf4b8ede95c02c32b0c8eb2bc", "patch": "@@ -0,0 +1,88 @@\n+//! Generates `assists.md` documentation.\n+\n+use std::{fmt, fs, path::PathBuf};\n+\n+use crate::{\n+    codegen::{self, extract_comment_blocks_with_empty_lines, Mode},\n+    project_root, rust_files, Result,\n+};\n+\n+pub fn generate_feature_docs(mode: Mode) -> Result<()> {\n+    let features = Feature::collect()?;\n+    let contents = features.into_iter().map(|it| it.to_string()).collect::<Vec<_>>().join(\"\\n\\n\");\n+    let contents = contents.trim().to_string() + \"\\n\";\n+    let dst = project_root().join(\"docs/user/generated_features.adoc\");\n+    codegen::update(&dst, &contents, mode)?;\n+    Ok(())\n+}\n+\n+#[derive(Debug)]\n+struct Feature {\n+    id: String,\n+    path: PathBuf,\n+    doc: String,\n+}\n+\n+impl Feature {\n+    fn collect() -> Result<Vec<Feature>> {\n+        let mut res = Vec::new();\n+        for path in rust_files(&project_root()) {\n+            collect_file(&mut res, path)?;\n+        }\n+        res.sort_by(|lhs, rhs| lhs.id.cmp(&rhs.id));\n+        return Ok(res);\n+\n+        fn collect_file(acc: &mut Vec<Feature>, path: PathBuf) -> Result<()> {\n+            let text = fs::read_to_string(&path)?;\n+            let comment_blocks = extract_comment_blocks_with_empty_lines(\"Feature\", &text);\n+\n+            for block in comment_blocks {\n+                let id = block.id;\n+                assert!(is_valid_feature_name(&id), \"invalid feature name: {:?}\", id);\n+                let doc = block.contents.join(\"\\n\");\n+                acc.push(Feature { id, path: path.clone(), doc })\n+            }\n+\n+            Ok(())\n+        }\n+    }\n+}\n+\n+fn is_valid_feature_name(feature: &str) -> bool {\n+    'word: for word in feature.split_whitespace() {\n+        for &short in [\"to\", \"and\"].iter() {\n+            if word == short {\n+                continue 'word;\n+            }\n+        }\n+        for &short in [\"To\", \"And\"].iter() {\n+            if word == short {\n+                return false;\n+            }\n+        }\n+        if !word.starts_with(char::is_uppercase) {\n+            return false;\n+        }\n+    }\n+    true\n+}\n+\n+impl fmt::Display for Feature {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        writeln!(f, \"=== {}\", self.id)?;\n+        let path = self.path.strip_prefix(&project_root()).unwrap().display().to_string();\n+        let path = path.replace('\\\\', \"/\");\n+        let name = self.path.file_name().unwrap();\n+\n+        //FIXME: generate line number as well\n+        writeln!(\n+            f,\n+            \"**Source:** https://github.com/rust-analyzer/rust-analyzer/blob/master/{}[{}]\",\n+            path,\n+            name.to_str().unwrap(),\n+        )?;\n+\n+        writeln!(f, \"{}\", self.doc)?;\n+        Ok(())\n+    }\n+}"}, {"sha": "9d7cdd1145ae1e29094cc8dc6392e17bac8d9312", "filename": "xtask/src/main.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/09df51dab89340bcf4b8ede95c02c32b0c8eb2bc/xtask%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09df51dab89340bcf4b8ede95c02c32b0c8eb2bc/xtask%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Fsrc%2Fmain.rs?ref=09df51dab89340bcf4b8ede95c02c32b0c8eb2bc", "patch": "@@ -75,6 +75,7 @@ FLAGS:\n             codegen::generate_syntax(Mode::Overwrite)?;\n             codegen::generate_parser_tests(Mode::Overwrite)?;\n             codegen::generate_assists_docs(Mode::Overwrite)?;\n+            codegen::generate_feature_docs(Mode::Overwrite)?;\n             Ok(())\n         }\n         \"format\" => {"}, {"sha": "4ac5d929fc6b6f7b2c0285755379769adcccfde4", "filename": "xtask/tests/tidy.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/09df51dab89340bcf4b8ede95c02c32b0c8eb2bc/xtask%2Ftests%2Ftidy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/09df51dab89340bcf4b8ede95c02c32b0c8eb2bc/xtask%2Ftests%2Ftidy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/xtask%2Ftests%2Ftidy.rs?ref=09df51dab89340bcf4b8ede95c02c32b0c8eb2bc", "patch": "@@ -30,6 +30,13 @@ fn generated_assists_are_fresh() {\n     }\n }\n \n+#[test]\n+fn generated_features_are_fresh() {\n+    if let Err(error) = codegen::generate_feature_docs(Mode::Verify) {\n+        panic!(\"{}. Please update features by running `cargo xtask codegen`\", error);\n+    }\n+}\n+\n #[test]\n fn check_code_formatting() {\n     if let Err(error) = run_rustfmt(Mode::Verify) {\n@@ -95,7 +102,7 @@ impl TidyDocs {\n     fn visit(&mut self, path: &Path, text: &str) {\n         // Test hopefully don't really need comments, and for assists we already\n         // have special comments which are source of doc tests and user docs.\n-        if is_exclude_dir(path, &[\"tests\", \"test_data\", \"handlers\"]) {\n+        if is_exclude_dir(path, &[\"tests\", \"test_data\"]) {\n             return;\n         }\n \n@@ -110,9 +117,12 @@ impl TidyDocs {\n \n         if first_line.starts_with(\"//!\") {\n             if first_line.contains(\"FIXME\") {\n-                self.contains_fixme.push(path.to_path_buf())\n+                self.contains_fixme.push(path.to_path_buf());\n             }\n         } else {\n+            if text.contains(\"// Feature:\") || text.contains(\"// Assist:\") {\n+                return;\n+            }\n             self.missing_docs.push(path.display().to_string());\n         }\n "}]}