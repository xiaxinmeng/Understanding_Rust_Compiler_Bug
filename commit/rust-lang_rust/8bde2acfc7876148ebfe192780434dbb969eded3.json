{"sha": "8bde2acfc7876148ebfe192780434dbb969eded3", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhiZGUyYWNmYzc4NzYxNDhlYmZlMTkyNzgwNDM0ZGJiOTY5ZWRlZDM=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2018-01-16T23:02:31Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2018-01-23T22:13:47Z"}, "message": "rustc: Add `-C lto=val` option\n\nThis commit primarily adds the ability to control what kind of LTO happens when\nrustc performs LTO, namely allowing values to be specified to the `-C lto`\noption, such as `-C lto=thin` and `-C lto=fat`. (where \"fat\" is the previous\nkind of LTO, throw everything in one giant module)\n\nAlong the way this also refactors a number of fields which store information\nabout whether LTO/ThinLTO are enabled to unify them all into one field through\nwhich everything is dispatched, hopefully removing a number of special cases\nthroughout.\n\nThis is intended to help mitigate #47409 but will require a backport as well,\nand this would unfortunately need to be an otherwise insta-stable option.", "tree": {"sha": "214b953ac0b69b6185e8de690f7c4f8588287f95", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/214b953ac0b69b6185e8de690f7c4f8588287f95"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8bde2acfc7876148ebfe192780434dbb969eded3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8bde2acfc7876148ebfe192780434dbb969eded3", "html_url": "https://github.com/rust-lang/rust/commit/8bde2acfc7876148ebfe192780434dbb969eded3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8bde2acfc7876148ebfe192780434dbb969eded3/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4e3901d35f6a8652f67111e7272263c9e62ab3e1", "url": "https://api.github.com/repos/rust-lang/rust/commits/4e3901d35f6a8652f67111e7272263c9e62ab3e1", "html_url": "https://github.com/rust-lang/rust/commit/4e3901d35f6a8652f67111e7272263c9e62ab3e1"}], "stats": {"total": 336, "additions": 221, "deletions": 115}, "files": [{"sha": "3fac9ce41f1397e1fed9a6b41c1108665e2f7b4b", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 45, "deletions": 11, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/8bde2acfc7876148ebfe192780434dbb969eded3/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bde2acfc7876148ebfe192780434dbb969eded3/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=8bde2acfc7876148ebfe192780434dbb969eded3", "patch": "@@ -72,6 +72,26 @@ pub enum OptLevel {\n     SizeMin, // -Oz\n }\n \n+#[derive(Clone, Copy, PartialEq, Hash)]\n+pub enum Lto {\n+    /// Don't do any LTO whatsoever\n+    No,\n+\n+    /// Do a full crate graph LTO. The flavor is determined by the compiler\n+    /// (currently the default is \"fat\").\n+    Yes,\n+\n+    /// Do a full crate graph LTO with ThinLTO\n+    Thin,\n+\n+    /// Do a local graph LTO with ThinLTO (only relevant for multiple codegen\n+    /// units).\n+    ThinLocal,\n+\n+    /// Do a full crate graph LTO with \"fat\" LTO\n+    Fat,\n+}\n+\n #[derive(Clone, Copy, PartialEq, Hash)]\n pub enum DebugInfoLevel {\n     NoDebugInfo,\n@@ -389,7 +409,7 @@ top_level_options!(\n         // commands like `--emit llvm-ir` which they're often incompatible with\n         // if we otherwise use the defaults of rustc.\n         cli_forced_codegen_units: Option<usize> [UNTRACKED],\n-        cli_forced_thinlto: Option<bool> [UNTRACKED],\n+        cli_forced_thinlto_off: bool [UNTRACKED],\n     }\n );\n \n@@ -590,7 +610,7 @@ pub fn basic_options() -> Options {\n         debug_assertions: true,\n         actually_rustdoc: false,\n         cli_forced_codegen_units: None,\n-        cli_forced_thinlto: None,\n+        cli_forced_thinlto_off: false,\n     }\n }\n \n@@ -780,11 +800,13 @@ macro_rules! options {\n             Some(\"crate=integer\");\n         pub const parse_unpretty: Option<&'static str> =\n             Some(\"`string` or `string=string`\");\n+        pub const parse_lto: Option<&'static str> =\n+            Some(\"one of `thin`, `fat`, or omitted\");\n     }\n \n     #[allow(dead_code)]\n     mod $mod_set {\n-        use super::{$struct_name, Passes, SomePasses, AllPasses, Sanitizer};\n+        use super::{$struct_name, Passes, SomePasses, AllPasses, Sanitizer, Lto};\n         use rustc_back::{LinkerFlavor, PanicStrategy, RelroLevel};\n         use std::path::PathBuf;\n \n@@ -978,6 +1000,16 @@ macro_rules! options {\n                 _ => false,\n             }\n         }\n+\n+        fn parse_lto(slot: &mut Lto, v: Option<&str>) -> bool {\n+            *slot = match v {\n+                None => Lto::Yes,\n+                Some(\"thin\") => Lto::Thin,\n+                Some(\"fat\") => Lto::Fat,\n+                Some(_) => return false,\n+            };\n+            true\n+        }\n     }\n ) }\n \n@@ -994,7 +1026,7 @@ options! {CodegenOptions, CodegenSetter, basic_codegen_options,\n         \"extra arguments to append to the linker invocation (space separated)\"),\n     link_dead_code: bool = (false, parse_bool, [UNTRACKED],\n         \"don't let linker strip dead code (turning it on can be used for code coverage)\"),\n-    lto: bool = (false, parse_bool, [TRACKED],\n+    lto: Lto = (Lto::No, parse_lto, [TRACKED],\n         \"perform LLVM link-time optimizations\"),\n     target_cpu: Option<String> = (None, parse_opt_string, [TRACKED],\n         \"select target processor (rustc --print target-cpus for details)\"),\n@@ -1677,7 +1709,7 @@ pub fn build_session_options_and_crate_config(matches: &getopts::Matches)\n \n     let mut cg = build_codegen_options(matches, error_format);\n     let mut codegen_units = cg.codegen_units;\n-    let mut thinlto = None;\n+    let mut disable_thinlto = false;\n \n     // Issue #30063: if user requests llvm-related output to one\n     // particular path, disable codegen-units.\n@@ -1699,12 +1731,12 @@ pub fn build_session_options_and_crate_config(matches: &getopts::Matches)\n                     }\n                     early_warn(error_format, \"resetting to default -C codegen-units=1\");\n                     codegen_units = Some(1);\n-                    thinlto = Some(false);\n+                    disable_thinlto = true;\n                 }\n             }\n             _ => {\n                 codegen_units = Some(1);\n-                thinlto = Some(false);\n+                disable_thinlto = true;\n             }\n         }\n     }\n@@ -1734,7 +1766,7 @@ pub fn build_session_options_and_crate_config(matches: &getopts::Matches)\n         (&None, &None) => None,\n     }.map(|m| PathBuf::from(m));\n \n-    if cg.lto && incremental.is_some() {\n+    if cg.lto != Lto::No && incremental.is_some() {\n         early_error(error_format, \"can't perform LTO when compiling incrementally\");\n     }\n \n@@ -1934,7 +1966,7 @@ pub fn build_session_options_and_crate_config(matches: &getopts::Matches)\n         debug_assertions,\n         actually_rustdoc: false,\n         cli_forced_codegen_units: codegen_units,\n-        cli_forced_thinlto: thinlto,\n+        cli_forced_thinlto_off: disable_thinlto,\n     },\n     cfg)\n }\n@@ -2052,7 +2084,7 @@ mod dep_tracking {\n     use std::hash::Hash;\n     use std::path::PathBuf;\n     use std::collections::hash_map::DefaultHasher;\n-    use super::{Passes, CrateType, OptLevel, DebugInfoLevel,\n+    use super::{Passes, CrateType, OptLevel, DebugInfoLevel, Lto,\n                 OutputTypes, Externs, ErrorOutputType, Sanitizer};\n     use syntax::feature_gate::UnstableFeatures;\n     use rustc_back::{PanicStrategy, RelroLevel};\n@@ -2107,6 +2139,7 @@ mod dep_tracking {\n     impl_dep_tracking_hash_via_hash!(RelroLevel);\n     impl_dep_tracking_hash_via_hash!(Passes);\n     impl_dep_tracking_hash_via_hash!(OptLevel);\n+    impl_dep_tracking_hash_via_hash!(Lto);\n     impl_dep_tracking_hash_via_hash!(DebugInfoLevel);\n     impl_dep_tracking_hash_via_hash!(UnstableFeatures);\n     impl_dep_tracking_hash_via_hash!(Externs);\n@@ -2180,6 +2213,7 @@ mod tests {\n     use lint;\n     use middle::cstore;\n     use session::config::{build_configuration, build_session_options_and_crate_config};\n+    use session::config::Lto;\n     use session::build_session;\n     use std::collections::{BTreeMap, BTreeSet};\n     use std::iter::FromIterator;\n@@ -2656,7 +2690,7 @@ mod tests {\n \n         // Make sure changing a [TRACKED] option changes the hash\n         opts = reference.clone();\n-        opts.cg.lto = true;\n+        opts.cg.lto = Lto::Fat;\n         assert!(reference.dep_tracking_hash() != opts.dep_tracking_hash());\n \n         opts = reference.clone();"}, {"sha": "02cd6a92eb7618b43847978e80eb6cc40c76ce51", "filename": "src/librustc/session/mod.rs", "status": "modified", "additions": 58, "deletions": 34, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/8bde2acfc7876148ebfe192780434dbb969eded3/src%2Flibrustc%2Fsession%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bde2acfc7876148ebfe192780434dbb969eded3/src%2Flibrustc%2Fsession%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fmod.rs?ref=8bde2acfc7876148ebfe192780434dbb969eded3", "patch": "@@ -498,9 +498,65 @@ impl Session {\n             self.use_mir()\n     }\n \n-    pub fn lto(&self) -> bool {\n-        self.opts.cg.lto || self.target.target.options.requires_lto\n+    /// Calculates the flavor of LTO to use for this compilation.\n+    pub fn lto(&self) -> config::Lto {\n+        // If our target has codegen requirements ignore the command line\n+        if self.target.target.options.requires_lto {\n+            return config::Lto::Fat\n+        }\n+\n+        // If the user specified something, return that. If they only said `-C\n+        // lto` and we've for whatever reason forced off ThinLTO via the CLI,\n+        // then ensure we can't use a ThinLTO.\n+        match self.opts.cg.lto {\n+            config::Lto::No => {}\n+            config::Lto::Yes if self.opts.cli_forced_thinlto_off => {\n+                return config::Lto::Fat\n+            }\n+            other => return other,\n+        }\n+\n+        // Ok at this point the target doesn't require anything and the user\n+        // hasn't asked for anything. Our next decision is whether or not\n+        // we enable \"auto\" ThinLTO where we use multiple codegen units and\n+        // then do ThinLTO over those codegen units. The logic below will\n+        // either return `No` or `ThinLocal`.\n+\n+        // If processing command line options determined that we're incompatible\n+        // with ThinLTO (e.g. `-C lto --emit llvm-ir`) then return that option.\n+        if self.opts.cli_forced_thinlto_off {\n+            return config::Lto::No\n+        }\n+\n+        // If `-Z thinlto` specified process that, but note that this is mostly\n+        // a deprecated option now that `-C lto=thin` exists.\n+        if let Some(enabled) = self.opts.debugging_opts.thinlto {\n+            if enabled {\n+                return config::Lto::ThinLocal\n+            } else {\n+                return config::Lto::No\n+            }\n+        }\n+\n+        // If there's only one codegen unit and LTO isn't enabled then there's\n+        // no need for ThinLTO so just return false.\n+        if self.codegen_units() == 1 {\n+            return config::Lto::No\n+        }\n+\n+        // Right now ThinLTO isn't compatible with incremental compilation.\n+        if self.opts.incremental.is_some() {\n+            return config::Lto::No\n+        }\n+\n+        // Now we're in \"defaults\" territory. By default we enable ThinLTO for\n+        // optimized compiles (anything greater than O0).\n+        match self.opts.optimize {\n+            config::OptLevel::No => config::Lto::No,\n+            _ => config::Lto::ThinLocal,\n+        }\n     }\n+\n     /// Returns the panic strategy for this compile session. If the user explicitly selected one\n     /// using '-C panic', use that, otherwise use the panic strategy defined by the target.\n     pub fn panic_strategy(&self) -> PanicStrategy {\n@@ -804,38 +860,6 @@ impl Session {\n         // scientific.\n         16\n     }\n-\n-    /// Returns whether ThinLTO is enabled for this compilation\n-    pub fn thinlto(&self) -> bool {\n-        // If processing command line options determined that we're incompatible\n-        // with ThinLTO (e.g. `-C lto --emit llvm-ir`) then return that option.\n-        if let Some(enabled) = self.opts.cli_forced_thinlto {\n-            return enabled\n-        }\n-\n-        // If explicitly specified, use that with the next highest priority\n-        if let Some(enabled) = self.opts.debugging_opts.thinlto {\n-            return enabled\n-        }\n-\n-        // If there's only one codegen unit and LTO isn't enabled then there's\n-        // no need for ThinLTO so just return false.\n-        if self.codegen_units() == 1 && !self.lto() {\n-            return false\n-        }\n-\n-        // Right now ThinLTO isn't compatible with incremental compilation.\n-        if self.opts.incremental.is_some() {\n-            return false\n-        }\n-\n-        // Now we're in \"defaults\" territory. By default we enable ThinLTO for\n-        // optimized compiles (anything greater than O0).\n-        match self.opts.optimize {\n-            config::OptLevel::No => false,\n-            _ => true,\n-        }\n-    }\n }\n \n pub fn build_session(sopts: config::Options,"}, {"sha": "f050edcd513b918167fd49355050327a64716b8e", "filename": "src/librustc_trans/back/link.rs", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/8bde2acfc7876148ebfe192780434dbb969eded3/src%2Flibrustc_trans%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bde2acfc7876148ebfe192780434dbb969eded3/src%2Flibrustc_trans%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flink.rs?ref=8bde2acfc7876148ebfe192780434dbb969eded3", "patch": "@@ -16,7 +16,7 @@ use super::rpath::RPathConfig;\n use super::rpath;\n use metadata::METADATA_FILENAME;\n use rustc::session::config::{self, NoDebugInfo, OutputFilenames, OutputType, PrintRequest};\n-use rustc::session::config::RUST_CGU_EXT;\n+use rustc::session::config::{RUST_CGU_EXT, Lto};\n use rustc::session::filesearch;\n use rustc::session::search_paths::PathKind;\n use rustc::session::Session;\n@@ -503,7 +503,8 @@ fn link_staticlib(sess: &Session,\n         });\n         ab.add_rlib(path,\n                     &name.as_str(),\n-                    sess.lto() && !ignored_for_lto(sess, &trans.crate_info, cnum),\n+                    is_full_lto_enabled(sess) &&\n+                        !ignored_for_lto(sess, &trans.crate_info, cnum),\n                     skip_object_files).unwrap();\n \n         all_native_libs.extend(trans.crate_info.native_libraries[&cnum].iter().cloned());\n@@ -1211,7 +1212,8 @@ fn add_upstream_rust_crates(cmd: &mut Linker,\n             lib.kind == NativeLibraryKind::NativeStatic && !relevant_lib(sess, lib)\n         });\n \n-        if (!sess.lto() || ignored_for_lto(sess, &trans.crate_info, cnum)) &&\n+        if (!is_full_lto_enabled(sess) ||\n+            ignored_for_lto(sess, &trans.crate_info, cnum)) &&\n            crate_type != config::CrateTypeDylib &&\n            !skip_native {\n             cmd.link_rlib(&fix_windows_verbatim_for_gcc(cratepath));\n@@ -1264,7 +1266,7 @@ fn add_upstream_rust_crates(cmd: &mut Linker,\n                 // file, then we don't need the object file as it's part of the\n                 // LTO module. Note that `#![no_builtins]` is excluded from LTO,\n                 // though, so we let that object file slide.\n-                let skip_because_lto = sess.lto() &&\n+                let skip_because_lto = is_full_lto_enabled(sess) &&\n                     is_rust_object &&\n                     (sess.target.target.options.no_builtins ||\n                      !trans.crate_info.is_no_builtins.contains(&cnum));\n@@ -1301,7 +1303,7 @@ fn add_upstream_rust_crates(cmd: &mut Linker,\n     fn add_dynamic_crate(cmd: &mut Linker, sess: &Session, cratepath: &Path) {\n         // If we're performing LTO, then it should have been previously required\n         // that all upstream rust dependencies were available in an rlib format.\n-        assert!(!sess.lto());\n+        assert!(!is_full_lto_enabled(sess));\n \n         // Just need to tell the linker about where the library lives and\n         // what its name is\n@@ -1409,3 +1411,13 @@ fn link_binaryen(sess: &Session,\n                             e));\n     }\n }\n+\n+fn is_full_lto_enabled(sess: &Session) -> bool {\n+    match sess.lto() {\n+        Lto::Yes |\n+        Lto::Thin |\n+        Lto::Fat => true,\n+        Lto::No |\n+        Lto::ThinLocal => false,\n+    }\n+}"}, {"sha": "9ff5bcf7a33caaa5772aaf8e822ef673e6e6f281", "filename": "src/librustc_trans/back/lto.rs", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/8bde2acfc7876148ebfe192780434dbb969eded3/src%2Flibrustc_trans%2Fback%2Flto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bde2acfc7876148ebfe192780434dbb969eded3/src%2Flibrustc_trans%2Fback%2Flto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Flto.rs?ref=8bde2acfc7876148ebfe192780434dbb969eded3", "patch": "@@ -18,7 +18,7 @@ use llvm::{ModuleRef, TargetMachineRef, True, False};\n use llvm;\n use rustc::hir::def_id::LOCAL_CRATE;\n use rustc::middle::exported_symbols::SymbolExportLevel;\n-use rustc::session::config;\n+use rustc::session::config::{self, Lto};\n use rustc::util::common::time;\n use time_graph::Timeline;\n use {ModuleTranslation, ModuleLlvm, ModuleKind, ModuleSource};\n@@ -95,25 +95,22 @@ impl LtoModuleTranslation {\n     }\n }\n \n-pub enum LTOMode {\n-    WholeCrateGraph,\n-    JustThisCrate,\n-}\n-\n pub(crate) fn run(cgcx: &CodegenContext,\n-           modules: Vec<ModuleTranslation>,\n-           mode: LTOMode,\n-           timeline: &mut Timeline)\n+                  modules: Vec<ModuleTranslation>,\n+                  timeline: &mut Timeline)\n     -> Result<Vec<LtoModuleTranslation>, FatalError>\n {\n     let diag_handler = cgcx.create_diag_handler();\n-    let export_threshold = match mode {\n-        LTOMode::WholeCrateGraph => {\n+    let export_threshold = match cgcx.lto {\n+        // We're just doing LTO for our one crate\n+        Lto::ThinLocal => SymbolExportLevel::Rust,\n+\n+        // We're doing LTO for the entire crate graph\n+        Lto::Yes | Lto::Fat | Lto::Thin => {\n             symbol_export::crates_export_threshold(&cgcx.crate_types)\n         }\n-        LTOMode::JustThisCrate => {\n-            SymbolExportLevel::Rust\n-        }\n+\n+        Lto::No => panic!(\"didn't request LTO but we're doing LTO\"),\n     };\n \n     let symbol_filter = &|&(ref name, _, level): &(String, _, SymbolExportLevel)| {\n@@ -140,7 +137,7 @@ pub(crate) fn run(cgcx: &CodegenContext,\n     // We save off all the bytecode and LLVM module ids for later processing\n     // with either fat or thin LTO\n     let mut upstream_modules = Vec::new();\n-    if let LTOMode::WholeCrateGraph = mode {\n+    if cgcx.lto != Lto::ThinLocal {\n         if cgcx.opts.cg.prefer_dynamic {\n             diag_handler.struct_err(\"cannot prefer dynamic linking when performing LTO\")\n                         .note(\"only 'staticlib', 'bin', and 'cdylib' outputs are \\\n@@ -186,13 +183,16 @@ pub(crate) fn run(cgcx: &CodegenContext,\n     }\n \n     let arr = symbol_white_list.iter().map(|c| c.as_ptr()).collect::<Vec<_>>();\n-    match mode {\n-        LTOMode::WholeCrateGraph if !cgcx.thinlto => {\n+    match cgcx.lto {\n+        Lto::Yes | // `-C lto` == fat LTO by default\n+        Lto::Fat => {\n             fat_lto(cgcx, &diag_handler, modules, upstream_modules, &arr, timeline)\n         }\n-        _ => {\n+        Lto::Thin |\n+        Lto::ThinLocal => {\n             thin_lto(&diag_handler, modules, upstream_modules, &arr, timeline)\n         }\n+        Lto::No => unreachable!(),\n     }\n }\n "}, {"sha": "a4af080ebf7e6f7e6d0effc2687e51aa5c9aef4c", "filename": "src/librustc_trans/back/write.rs", "status": "modified", "additions": 45, "deletions": 43, "changes": 88, "blob_url": "https://github.com/rust-lang/rust/blob/8bde2acfc7876148ebfe192780434dbb969eded3/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bde2acfc7876148ebfe192780434dbb969eded3/src%2Flibrustc_trans%2Fback%2Fwrite.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fback%2Fwrite.rs?ref=8bde2acfc7876148ebfe192780434dbb969eded3", "patch": "@@ -19,7 +19,7 @@ use rustc_incremental::{save_trans_partition, in_incr_comp_dir};\n use rustc::dep_graph::{DepGraph, WorkProductFileKind};\n use rustc::middle::cstore::{LinkMeta, EncodedMetadata};\n use rustc::session::config::{self, OutputFilenames, OutputType, OutputTypes, Passes, SomePasses,\n-                             AllPasses, Sanitizer};\n+                             AllPasses, Sanitizer, Lto};\n use rustc::session::Session;\n use rustc::util::nodemap::FxHashMap;\n use rustc_back::LinkerFlavor;\n@@ -318,8 +318,7 @@ impl ModuleConfig {\n pub struct CodegenContext {\n     // Resouces needed when running LTO\n     pub time_passes: bool,\n-    pub lto: bool,\n-    pub thinlto: bool,\n+    pub lto: Lto,\n     pub no_landing_pads: bool,\n     pub save_temps: bool,\n     pub fewer_names: bool,\n@@ -576,12 +575,7 @@ fn generate_lto_work(cgcx: &CodegenContext,\n                  TRANS_WORK_PACKAGE_KIND,\n                  \"generate lto\")\n     }).unwrap_or(Timeline::noop());\n-    let mode = if cgcx.lto {\n-        lto::LTOMode::WholeCrateGraph\n-    } else {\n-        lto::LTOMode::JustThisCrate\n-    };\n-    let lto_modules = lto::run(cgcx, modules, mode, &mut timeline)\n+    let lto_modules = lto::run(cgcx, modules, &mut timeline)\n         .unwrap_or_else(|e| panic!(e));\n \n     lto_modules.into_iter().map(|module| {\n@@ -1280,28 +1274,51 @@ fn execute_work_item(cgcx: &CodegenContext,\n         unsafe {\n             optimize(cgcx, &diag_handler, &mtrans, config, timeline)?;\n \n-            let lto = cgcx.lto;\n+            // After we've done the initial round of optimizations we need to\n+            // decide whether to synchronously codegen this module or ship it\n+            // back to the coordinator thread for further LTO processing (which\n+            // has to wait for all the initial modules to be optimized).\n+            //\n+            // Here we dispatch based on the `cgcx.lto` and kind of module we're\n+            // translating...\n+            let needs_lto = match cgcx.lto {\n+                Lto::No => false,\n+\n+                // Here we've got a full crate graph LTO requested. We ignore\n+                // this, however, if the crate type is only an rlib as there's\n+                // no full crate graph to process, that'll happen later.\n+                //\n+                // This use case currently comes up primarily for targets that\n+                // require LTO so the request for LTO is always unconditionally\n+                // passed down to the backend, but we don't actually want to do\n+                // anything about it yet until we've got a final product.\n+                Lto::Yes | Lto::Fat | Lto::Thin => {\n+                    cgcx.crate_types.len() != 1 ||\n+                        cgcx.crate_types[0] != config::CrateTypeRlib\n+                }\n \n-            let auto_thin_lto =\n-                cgcx.thinlto &&\n-                cgcx.total_cgus > 1 &&\n-                mtrans.kind != ModuleKind::Allocator;\n+                // When we're automatically doing ThinLTO for multi-codegen-unit\n+                // builds we don't actually want to LTO the allocator modules if\n+                // it shows up. This is due to various linker shenanigans that\n+                // we'll encounter later.\n+                //\n+                // Additionally here's where we also factor in the current LLVM\n+                // version. If it doesn't support ThinLTO we skip this.\n+                Lto::ThinLocal => {\n+                    mtrans.kind != ModuleKind::Allocator &&\n+                        llvm::LLVMRustThinLTOAvailable()\n+                }\n+            };\n \n-            // If we're a metadata module we never participate in LTO.\n-            //\n-            // If LTO was explicitly requested on the command line, we always\n-            // LTO everything else.\n-            //\n-            // If LTO *wasn't* explicitly requested and we're not a metdata\n-            // module, then we may automatically do ThinLTO if we've got\n-            // multiple codegen units. Note, however, that the allocator module\n-            // doesn't participate here automatically because of linker\n-            // shenanigans later on.\n-            if mtrans.kind == ModuleKind::Metadata || (!lto && !auto_thin_lto) {\n+            // Metadata modules never participate in LTO regardless of the lto\n+            // settings.\n+            let needs_lto = needs_lto && mtrans.kind != ModuleKind::Metadata;\n+\n+            if needs_lto {\n+                Ok(WorkItemResult::NeedsLTO(mtrans))\n+            } else {\n                 let module = codegen(cgcx, &diag_handler, mtrans, config, timeline)?;\n                 Ok(WorkItemResult::Compiled(module))\n-            } else {\n-                Ok(WorkItemResult::NeedsLTO(mtrans))\n             }\n         }\n     }\n@@ -1377,28 +1394,13 @@ fn start_executing_work(tcx: TyCtxt,\n         each_linked_rlib_for_lto.push((cnum, path.to_path_buf()));\n     }));\n \n-    let crate_types = sess.crate_types.borrow();\n-    let only_rlib = crate_types.len() == 1 &&\n-        crate_types[0] == config::CrateTypeRlib;\n-\n     let wasm_import_memory =\n         attr::contains_name(&tcx.hir.krate().attrs, \"wasm_import_memory\");\n \n     let cgcx = CodegenContext {\n         crate_types: sess.crate_types.borrow().clone(),\n         each_linked_rlib_for_lto,\n-        // If we're only building an rlibc then allow the LTO flag to be passed\n-        // but don't actually do anything, the full LTO will happen later\n-        lto: sess.lto() && !only_rlib,\n-\n-        // Enable ThinLTO if requested, but only if the target we're compiling\n-        // for doesn't require full LTO. Some targets require one LLVM module\n-        // (they effectively don't have a linker) so it's up to us to use LTO to\n-        // link everything together.\n-        thinlto: sess.thinlto() &&\n-            !sess.target.target.options.requires_lto &&\n-            unsafe { llvm::LLVMRustThinLTOAvailable() },\n-\n+        lto: sess.lto(),\n         no_landing_pads: sess.no_landing_pads(),\n         fewer_names: sess.fewer_names(),\n         save_temps: sess.opts.cg.save_temps,"}, {"sha": "fda96a8b1fb5eb0bad399e2cbe0d971161c01ece", "filename": "src/test/run-make/codegen-options-parsing/Makefile", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8bde2acfc7876148ebfe192780434dbb969eded3/src%2Ftest%2Frun-make%2Fcodegen-options-parsing%2FMakefile", "raw_url": "https://github.com/rust-lang/rust/raw/8bde2acfc7876148ebfe192780434dbb969eded3/src%2Ftest%2Frun-make%2Fcodegen-options-parsing%2FMakefile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-make%2Fcodegen-options-parsing%2FMakefile?ref=8bde2acfc7876148ebfe192780434dbb969eded3", "patch": "@@ -16,11 +16,11 @@ all:\n \t$(RUSTC) -C extra-filename=foo dummy.rs 2>&1\n \t#Option taking no argument\n \t$(RUSTC) -C lto= dummy.rs 2>&1 | \\\n-\t\t$(CGREP) 'codegen option `lto` takes no value'\n+\t\t$(CGREP) 'codegen option `lto` - one of `thin`, `fat`, or'\n \t$(RUSTC) -C lto=1 dummy.rs 2>&1 | \\\n-\t\t$(CGREP) 'codegen option `lto` takes no value'\n+\t\t$(CGREP) 'codegen option `lto` - one of `thin`, `fat`, or'\n \t$(RUSTC) -C lto=foo dummy.rs 2>&1 | \\\n-\t\t$(CGREP) 'codegen option `lto` takes no value'\n+\t\t$(CGREP) 'codegen option `lto` - one of `thin`, `fat`, or'\n \t$(RUSTC) -C lto dummy.rs\n \n \t# Should not link dead code..."}, {"sha": "453eede261cc084f2252e2ca56af513744467a7f", "filename": "src/test/run-pass/fat-lto.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8bde2acfc7876148ebfe192780434dbb969eded3/src%2Ftest%2Frun-pass%2Ffat-lto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bde2acfc7876148ebfe192780434dbb969eded3/src%2Ftest%2Frun-pass%2Ffat-lto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffat-lto.rs?ref=8bde2acfc7876148ebfe192780434dbb969eded3", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -Clto=fat\n+// no-prefer-dynamic\n+\n+fn main() {\n+    println!(\"hello!\");\n+}\n+"}, {"sha": "772a9ec8293e4becbb76955de1d059473206ee70", "filename": "src/test/run-pass/thinlto/all-crates.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/8bde2acfc7876148ebfe192780434dbb969eded3/src%2Ftest%2Frun-pass%2Fthinlto%2Fall-crates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bde2acfc7876148ebfe192780434dbb969eded3/src%2Ftest%2Frun-pass%2Fthinlto%2Fall-crates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fthinlto%2Fall-crates.rs?ref=8bde2acfc7876148ebfe192780434dbb969eded3", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags: -Clto=thin\n+// no-prefer-dynamic\n+// min-llvm-version 4.0\n+\n+fn main() {\n+    println!(\"hello!\");\n+}"}, {"sha": "6020f72415dad2740d2d543a8ec2c4fef1a7d29e", "filename": "src/test/run-pass/thinlto/thin-lto-inlines2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8bde2acfc7876148ebfe192780434dbb969eded3/src%2Ftest%2Frun-pass%2Fthinlto%2Fthin-lto-inlines2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8bde2acfc7876148ebfe192780434dbb969eded3/src%2Ftest%2Frun-pass%2Fthinlto%2Fthin-lto-inlines2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fthinlto%2Fthin-lto-inlines2.rs?ref=8bde2acfc7876148ebfe192780434dbb969eded3", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// compile-flags: -Z thinlto -C codegen-units=8 -O -C lto\n+// compile-flags: -C codegen-units=8 -O -C lto=thin\n // aux-build:thin-lto-inlines-aux.rs\n // min-llvm-version 4.0\n // no-prefer-dynamic"}]}