{"sha": "e4d560b9148e62de6adb30bc0aa31c8432dabc54", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU0ZDU2MGI5MTQ4ZTYyZGU2YWRiMzBiYzBhYTMxYzg0MzJkYWJjNTQ=", "commit": {"author": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2018-08-06T07:36:03Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-08-06T07:36:03Z"}, "message": "Merge pull request #2897 from topecongiro/issue-2896\n\nIgnore comment in wrap_str", "tree": {"sha": "758c9519ff56b9260f6309507dd1badf74fcb5b3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/758c9519ff56b9260f6309507dd1badf74fcb5b3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e4d560b9148e62de6adb30bc0aa31c8432dabc54", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJbZ/pjCRBK7hj4Ov3rIwAAdHIIADCZz8lpTta7SvuOvdGRmrQy\nUad5abYcS9b93FBIr74eMdKDOy5VrMk13ULybrVyMb4CNqCmW9Dzms+lvzaw7sDt\nKrQDLFwWQDerfS+IO12LN1NVHcHFO5HfQWGunGmyKsslobSsTHjfEfiL3O+DYUl1\nbwzCSTcd8YWPj9G2M+ogiT9U7gJkbo7PBbEpSrVq7UlXxmpGzacD3xThGPKoGTuF\nzpB8JSMYLcrirFUyIr1+JOy9bluT19yTKuKZKxzhYV1tUQ5mn1p5tc7Fbs512tuB\n5ViyCMJSkQ/sYl+n9a1J8pkh1vT9Ibxs17UPfzaciQiGwHq4XuruJxg5+0qpdDs=\n=WcSC\n-----END PGP SIGNATURE-----\n", "payload": "tree 758c9519ff56b9260f6309507dd1badf74fcb5b3\nparent 8cd6633499a17f861c79952887754864081cfa29\nparent 2eeb3663116df5dbf2ed7291277d79c5ff201b89\nauthor Nick Cameron <nrc@ncameron.org> 1533540963 +1200\ncommitter GitHub <noreply@github.com> 1533540963 +1200\n\nMerge pull request #2897 from topecongiro/issue-2896\n\nIgnore comment in wrap_str"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e4d560b9148e62de6adb30bc0aa31c8432dabc54", "html_url": "https://github.com/rust-lang/rust/commit/e4d560b9148e62de6adb30bc0aa31c8432dabc54", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e4d560b9148e62de6adb30bc0aa31c8432dabc54/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8cd6633499a17f861c79952887754864081cfa29", "url": "https://api.github.com/repos/rust-lang/rust/commits/8cd6633499a17f861c79952887754864081cfa29", "html_url": "https://github.com/rust-lang/rust/commit/8cd6633499a17f861c79952887754864081cfa29"}, {"sha": "2eeb3663116df5dbf2ed7291277d79c5ff201b89", "url": "https://api.github.com/repos/rust-lang/rust/commits/2eeb3663116df5dbf2ed7291277d79c5ff201b89", "html_url": "https://github.com/rust-lang/rust/commit/2eeb3663116df5dbf2ed7291277d79c5ff201b89"}], "stats": {"total": 359, "additions": 358, "deletions": 1}, "files": [{"sha": "d979bf5c4b77108569d1bbd55c2c9cb62e2e9334", "filename": "src/comment.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/e4d560b9148e62de6adb30bc0aa31c8432dabc54/src%2Fcomment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4d560b9148e62de6adb30bc0aa31c8432dabc54/src%2Fcomment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomment.rs?ref=e4d560b9148e62de6adb30bc0aa31c8432dabc54", "patch": "@@ -1139,6 +1139,21 @@ pub fn recover_comment_removed(\n     }\n }\n \n+pub fn filter_normal_code(code: &str) -> String {\n+    let mut buffer = String::with_capacity(code.len());\n+    LineClasses::new(code).for_each(|(kind, line)| match kind {\n+        FullCodeCharKind::Normal | FullCodeCharKind::InString => {\n+            buffer.push_str(&line);\n+            buffer.push('\\n');\n+        }\n+        _ => (),\n+    });\n+    if !code.ends_with(\"\\n\") && buffer.ends_with(\"\\n\") {\n+        buffer.pop();\n+    }\n+    buffer\n+}\n+\n /// Return true if the two strings of code have the same payload of comments.\n /// The payload of comments is everything in the string except:\n ///     - actual code (not comments)\n@@ -1392,4 +1407,21 @@ mod test {\n         let s = format!(\"    r#\\\"\\n        test\\n    \\\"#\");\n         assert_eq!(remove_trailing_white_spaces(&s), s);\n     }\n+\n+    #[test]\n+    fn test_filter_normal_code() {\n+        let s = r#\"\n+fn main() {\n+    println!(\"hello, world\");\n+}\n+\"#;\n+        assert_eq!(s, filter_normal_code(s));\n+        let s_with_comment = r#\"\n+fn main() {\n+    // hello, world\n+    println!(\"hello, world\");\n+}\n+\"#;\n+        assert_eq!(s, filter_normal_code(s_with_comment));\n+    }\n }"}, {"sha": "9eac3fd4f0ddd76d730f7ec91346c43ec153924d", "filename": "src/utils.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e4d560b9148e62de6adb30bc0aa31c8432dabc54/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4d560b9148e62de6adb30bc0aa31c8432dabc54/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=e4d560b9148e62de6adb30bc0aa31c8432dabc54", "patch": "@@ -18,6 +18,7 @@ use syntax::ast::{\n use syntax::codemap::{BytePos, Span, NO_EXPANSION};\n use syntax::ptr;\n \n+use comment::filter_normal_code;\n use rewrite::RewriteContext;\n use shape::Shape;\n \n@@ -350,7 +351,7 @@ macro_rules! skip_out_of_file_lines_range_visitor {\n // Wraps String in an Option. Returns Some when the string adheres to the\n // Rewrite constraints defined for the Rewrite trait and None otherwise.\n pub fn wrap_str(s: String, max_width: usize, shape: Shape) -> Option<String> {\n-    if is_valid_str(&s, max_width, shape) {\n+    if is_valid_str(&filter_normal_code(&s), max_width, shape) {\n         Some(s)\n     } else {\n         None"}, {"sha": "f648e64b1e3731da06bb12ca5abcc3cdeaa2909e", "filename": "tests/source/issue-2896.rs", "status": "added", "additions": 161, "deletions": 0, "changes": 161, "blob_url": "https://github.com/rust-lang/rust/blob/e4d560b9148e62de6adb30bc0aa31c8432dabc54/tests%2Fsource%2Fissue-2896.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4d560b9148e62de6adb30bc0aa31c8432dabc54/tests%2Fsource%2Fissue-2896.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fissue-2896.rs?ref=e4d560b9148e62de6adb30bc0aa31c8432dabc54", "patch": "@@ -0,0 +1,161 @@\n+extern crate rand;\n+extern crate timely;\n+extern crate differential_dataflow;\n+\n+use rand::{Rng, SeedableRng, StdRng};\n+\n+use timely::dataflow::operators::*;\n+\n+use differential_dataflow::AsCollection;\n+use differential_dataflow::operators::*;\n+use differential_dataflow::input::InputSession;\n+\n+// mod loglikelihoodratio;\n+\n+fn main() {\n+\n+  // define a new timely dataflow computation. \n+  timely::execute_from_args(std::env::args().skip(6), move |worker| {\n+\n+    // capture parameters of the experiment.\n+    let users: usize = std::env::args().nth(1).unwrap().parse().unwrap();\n+    let items: usize = std::env::args().nth(2).unwrap().parse().unwrap();\n+    let scale: usize = std::env::args().nth(3).unwrap().parse().unwrap();\n+    let batch: usize = std::env::args().nth(4).unwrap().parse().unwrap();\n+    let noisy: bool = std::env::args().nth(5).unwrap() == \"noisy\";\n+\n+    let index = worker.index();\n+    let peers = worker.peers();\n+\n+    let (input, probe) = worker.dataflow(|scope| {\n+\n+      // input of (user, item) collection.\n+      let (input, occurrences) = scope.new_input();\n+      let occurrences = occurrences.as_collection();\n+\n+      //TODO adjust code to only work with upper triangular half of cooccurrence matrix\n+\n+      /* Compute the cooccurrence matrix C = A'A from the binary interaction matrix A. */\n+      let cooccurrences = \n+      occurrences\n+        .join_map(&occurrences, |_user, &item_a, &item_b| (item_a, item_b))\n+        .filter(|&(item_a, item_b)| item_a != item_b)\n+        .count();\n+\n+      /* compute the rowsums of C indicating how often we encounter individual items. */\n+      let row_sums = \n+      occurrences\n+        .map(|(_user, item)| item)\n+        .count();\n+\n+      // row_sums.inspect(|record| println!(\"[row_sums] {:?}\", record));\n+\n+      /* Join the cooccurrence pairs with the corresponding row sums. */\n+      let mut cooccurrences_with_row_sums = cooccurrences\n+        .map(|((item_a, item_b), num_cooccurrences)| (item_a, (item_b, num_cooccurrences)))\n+        .join_map(&row_sums, |&item_a, &(item_b, num_cooccurrences), &row_sum_a| {\n+          assert!(row_sum_a > 0);\n+          (item_b, (item_a, num_cooccurrences, row_sum_a))\n+        })\n+        .join_map(&row_sums, |&item_b, &(item_a, num_cooccurrences, row_sum_a), &row_sum_b| {\n+          assert!(row_sum_a > 0);\n+          assert!(row_sum_b > 0);\n+          (item_a, (item_b, num_cooccurrences, row_sum_a, row_sum_b))\n+        });\n+\n+      // cooccurrences_with_row_sums\n+      //     .inspect(|record| println!(\"[cooccurrences_with_row_sums] {:?}\", record));\n+\n+      // //TODO compute top-k \"similar items\" per item\n+      // /* Compute LLR scores for each item pair. */\n+      // let llr_scores = cooccurrences_with_row_sums.map(\n+      //   |(item_a, (item_b, num_cooccurrences, row_sum_a, row_sum_b))| {\n+\n+      //     println!(\n+      //       \"[llr_scores] item_a={} item_b={}, num_cooccurrences={} row_sum_a={} row_sum_b={}\",\n+      //       item_a, item_b, num_cooccurrences, row_sum_a, row_sum_b);\n+\n+      //     let k11: isize = num_cooccurrences;\n+      //     let k12: isize = row_sum_a as isize - k11;\n+      //     let k21: isize = row_sum_b as isize - k11;\n+      //     let k22: isize = 10000 - k12 - k21 + k11;\n+\n+      //     let llr_score = loglikelihoodratio::log_likelihood_ratio(k11, k12, k21, k22);\n+\n+      //     ((item_a, item_b), llr_score)\n+      //   });\n+\n+      if noisy {\n+        cooccurrences_with_row_sums = \n+        cooccurrences_with_row_sums\n+          .inspect(|x| println!(\"change: {:?}\", x));\n+      }\n+\n+      let probe = \n+      cooccurrences_with_row_sums\n+          .probe();\n+/*\n+      // produce the (item, item) collection\n+      let cooccurrences = occurrences\n+        .join_map(&occurrences, |_user, &item_a, &item_b| (item_a, item_b));\n+      // count the occurrences of each item.\n+      let counts = cooccurrences\n+        .map(|(item_a,_)| item_a)\n+        .count();\n+      // produce ((item1, item2), count1, count2, count12) tuples\n+      let cooccurrences_with_counts = cooccurrences\n+        .join_map(&counts, |&item_a, &item_b, &count_item_a| (item_b, (item_a, count_item_a)))\n+        .join_map(&counts, |&item_b, &(item_a, count_item_a), &count_item_b| {\n+          ((item_a, item_b), count_item_a, count_item_b)\n+        });\n+      let probe = cooccurrences_with_counts\n+        .inspect(|x| println!(\"change: {:?}\", x))\n+        .probe();\n+*/\n+      (input, probe)\n+    });\n+\n+    let seed: &[_] = &[1, 2, 3, index];\n+    let mut rng1: StdRng = SeedableRng::from_seed(seed);  // rng for edge additions\n+    let mut rng2: StdRng = SeedableRng::from_seed(seed);  // rng for edge deletions\n+\n+    let mut input = InputSession::from(input);\n+\n+    for count in 0 .. scale {\n+      if count % peers == index {\n+        let user = rng1.gen_range(0, users);\n+        let item = rng1.gen_range(0, items);\n+        // println!(\"[INITIAL INPUT] ({}, {})\", user, item);\n+        input.insert((user, item));\n+      }\n+    }\n+\n+    // load the initial data up!\n+    while probe.less_than(input.time()) { worker.step(); }\n+\n+    for round in 1 .. {\n+\n+      for element in (round * batch) .. ((round + 1) * batch) {\n+        if element % peers == index {\n+          // advance the input timestamp.\n+          input.advance_to(round * batch);\n+          // insert a new item.\n+          let user = rng1.gen_range(0, users);\n+          let item = rng1.gen_range(0, items);\n+          if noisy { println!(\"[INPUT: insert] ({}, {})\", user, item); }\n+          input.insert((user, item));\n+          // remove an old item.\n+          let user = rng2.gen_range(0, users);\n+          let item = rng2.gen_range(0, items);\n+          if noisy { println!(\"[INPUT: remove] ({}, {})\", user, item); }\n+          input.remove((user, item));\n+        }\n+      }\n+\n+      input.advance_to(round * batch);\n+      input.flush();\n+\n+      while probe.less_than(input.time()) { worker.step(); }\n+    }\n+  }).unwrap();\n+}"}, {"sha": "c750d96aa67c2d54f167df080c6f90e362c7e34e", "filename": "tests/target/issue-2896.rs", "status": "added", "additions": 163, "deletions": 0, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/e4d560b9148e62de6adb30bc0aa31c8432dabc54/tests%2Ftarget%2Fissue-2896.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e4d560b9148e62de6adb30bc0aa31c8432dabc54/tests%2Ftarget%2Fissue-2896.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fissue-2896.rs?ref=e4d560b9148e62de6adb30bc0aa31c8432dabc54", "patch": "@@ -0,0 +1,163 @@\n+extern crate differential_dataflow;\n+extern crate rand;\n+extern crate timely;\n+\n+use rand::{Rng, SeedableRng, StdRng};\n+\n+use timely::dataflow::operators::*;\n+\n+use differential_dataflow::input::InputSession;\n+use differential_dataflow::operators::*;\n+use differential_dataflow::AsCollection;\n+\n+// mod loglikelihoodratio;\n+\n+fn main() {\n+    // define a new timely dataflow computation.\n+    timely::execute_from_args(std::env::args().skip(6), move |worker| {\n+        // capture parameters of the experiment.\n+        let users: usize = std::env::args().nth(1).unwrap().parse().unwrap();\n+        let items: usize = std::env::args().nth(2).unwrap().parse().unwrap();\n+        let scale: usize = std::env::args().nth(3).unwrap().parse().unwrap();\n+        let batch: usize = std::env::args().nth(4).unwrap().parse().unwrap();\n+        let noisy: bool = std::env::args().nth(5).unwrap() == \"noisy\";\n+\n+        let index = worker.index();\n+        let peers = worker.peers();\n+\n+        let (input, probe) = worker.dataflow(|scope| {\n+            // input of (user, item) collection.\n+            let (input, occurrences) = scope.new_input();\n+            let occurrences = occurrences.as_collection();\n+\n+            //TODO adjust code to only work with upper triangular half of cooccurrence matrix\n+\n+            /* Compute the cooccurrence matrix C = A'A from the binary interaction matrix A. */\n+            let cooccurrences = occurrences\n+                .join_map(&occurrences, |_user, &item_a, &item_b| (item_a, item_b))\n+                .filter(|&(item_a, item_b)| item_a != item_b)\n+                .count();\n+\n+            /* compute the rowsums of C indicating how often we encounter individual items. */\n+            let row_sums = occurrences.map(|(_user, item)| item).count();\n+\n+            // row_sums.inspect(|record| println!(\"[row_sums] {:?}\", record));\n+\n+            /* Join the cooccurrence pairs with the corresponding row sums. */\n+            let mut cooccurrences_with_row_sums = cooccurrences\n+                .map(|((item_a, item_b), num_cooccurrences)| (item_a, (item_b, num_cooccurrences)))\n+                .join_map(\n+                    &row_sums,\n+                    |&item_a, &(item_b, num_cooccurrences), &row_sum_a| {\n+                        assert!(row_sum_a > 0);\n+                        (item_b, (item_a, num_cooccurrences, row_sum_a))\n+                    },\n+                ).join_map(\n+                    &row_sums,\n+                    |&item_b, &(item_a, num_cooccurrences, row_sum_a), &row_sum_b| {\n+                        assert!(row_sum_a > 0);\n+                        assert!(row_sum_b > 0);\n+                        (item_a, (item_b, num_cooccurrences, row_sum_a, row_sum_b))\n+                    },\n+                );\n+\n+            // cooccurrences_with_row_sums\n+            //     .inspect(|record| println!(\"[cooccurrences_with_row_sums] {:?}\", record));\n+\n+            // //TODO compute top-k \"similar items\" per item\n+            // /* Compute LLR scores for each item pair. */\n+            // let llr_scores = cooccurrences_with_row_sums.map(\n+            //   |(item_a, (item_b, num_cooccurrences, row_sum_a, row_sum_b))| {\n+\n+            //     println!(\n+            //       \"[llr_scores] item_a={} item_b={}, num_cooccurrences={} row_sum_a={} row_sum_b={}\",\n+            //       item_a, item_b, num_cooccurrences, row_sum_a, row_sum_b);\n+\n+            //     let k11: isize = num_cooccurrences;\n+            //     let k12: isize = row_sum_a as isize - k11;\n+            //     let k21: isize = row_sum_b as isize - k11;\n+            //     let k22: isize = 10000 - k12 - k21 + k11;\n+\n+            //     let llr_score = loglikelihoodratio::log_likelihood_ratio(k11, k12, k21, k22);\n+\n+            //     ((item_a, item_b), llr_score)\n+            //   });\n+\n+            if noisy {\n+                cooccurrences_with_row_sums =\n+                    cooccurrences_with_row_sums.inspect(|x| println!(\"change: {:?}\", x));\n+            }\n+\n+            let probe = cooccurrences_with_row_sums.probe();\n+            /*\n+      // produce the (item, item) collection\n+      let cooccurrences = occurrences\n+        .join_map(&occurrences, |_user, &item_a, &item_b| (item_a, item_b));\n+      // count the occurrences of each item.\n+      let counts = cooccurrences\n+        .map(|(item_a,_)| item_a)\n+        .count();\n+      // produce ((item1, item2), count1, count2, count12) tuples\n+      let cooccurrences_with_counts = cooccurrences\n+        .join_map(&counts, |&item_a, &item_b, &count_item_a| (item_b, (item_a, count_item_a)))\n+        .join_map(&counts, |&item_b, &(item_a, count_item_a), &count_item_b| {\n+          ((item_a, item_b), count_item_a, count_item_b)\n+        });\n+      let probe = cooccurrences_with_counts\n+        .inspect(|x| println!(\"change: {:?}\", x))\n+        .probe();\n+*/\n+            (input, probe)\n+        });\n+\n+        let seed: &[_] = &[1, 2, 3, index];\n+        let mut rng1: StdRng = SeedableRng::from_seed(seed); // rng for edge additions\n+        let mut rng2: StdRng = SeedableRng::from_seed(seed); // rng for edge deletions\n+\n+        let mut input = InputSession::from(input);\n+\n+        for count in 0..scale {\n+            if count % peers == index {\n+                let user = rng1.gen_range(0, users);\n+                let item = rng1.gen_range(0, items);\n+                // println!(\"[INITIAL INPUT] ({}, {})\", user, item);\n+                input.insert((user, item));\n+            }\n+        }\n+\n+        // load the initial data up!\n+        while probe.less_than(input.time()) {\n+            worker.step();\n+        }\n+\n+        for round in 1.. {\n+            for element in (round * batch)..((round + 1) * batch) {\n+                if element % peers == index {\n+                    // advance the input timestamp.\n+                    input.advance_to(round * batch);\n+                    // insert a new item.\n+                    let user = rng1.gen_range(0, users);\n+                    let item = rng1.gen_range(0, items);\n+                    if noisy {\n+                        println!(\"[INPUT: insert] ({}, {})\", user, item);\n+                    }\n+                    input.insert((user, item));\n+                    // remove an old item.\n+                    let user = rng2.gen_range(0, users);\n+                    let item = rng2.gen_range(0, items);\n+                    if noisy {\n+                        println!(\"[INPUT: remove] ({}, {})\", user, item);\n+                    }\n+                    input.remove((user, item));\n+                }\n+            }\n+\n+            input.advance_to(round * batch);\n+            input.flush();\n+\n+            while probe.less_than(input.time()) {\n+                worker.step();\n+            }\n+        }\n+    }).unwrap();\n+}"}]}