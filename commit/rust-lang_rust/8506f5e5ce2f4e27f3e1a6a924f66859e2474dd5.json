{"sha": "8506f5e5ce2f4e27f3e1a6a924f66859e2474dd5", "node_id": "MDY6Q29tbWl0NzI0NzEyOjg1MDZmNWU1Y2UyZjRlMjdmM2UxYTZhOTI0ZjY2ODU5ZTI0NzRkZDU=", "commit": {"author": {"name": "Nick Cameron", "email": "nrc@ncameron.org", "date": "2018-10-31T01:33:11Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2018-10-31T01:33:11Z"}, "message": "Merge pull request #3159 from scampi/issue-3132\n\nThe method trim_left_preserve_layout didn't handle tabs properly.", "tree": {"sha": "90c46678dd1d7b0187b49a74271c67febd98d880", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/90c46678dd1d7b0187b49a74271c67febd98d880"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8506f5e5ce2f4e27f3e1a6a924f66859e2474dd5", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJb2QZXCRBK7hj4Ov3rIwAAdHIIAIFCh34eqJX8xviu2Ded2pjS\nB0dsfQxTUZkPjbIV5Nf87KaM3n+nzG6z6DroMAcrAHJvdAc44EnFw4Akhv/5A55R\nQXFZCXB0SayxDbeY1IlsdsMSAR/OUL6d8M03jzgUH66YS68dVTII8/8+1RUqMG4f\nCXjxh0tIGC0UupwW6mybUtuwF2EhOllec9oOTc7S4pSdTYUS7f3C5T6SWjDr4C6y\nKe5SjxdswsdiVK7LHYd3hgOlf3zCGMYhGywaOwQoUVJpMQz7YRjgf4CXtgeiRSe8\ne/mTuSfSOKYu4Qk8PVcKrLi2+BJv8sRzDt614hUTJ8AvEaCCuf/eKJAFq9CxhAQ=\n=dqx1\n-----END PGP SIGNATURE-----\n", "payload": "tree 90c46678dd1d7b0187b49a74271c67febd98d880\nparent 2c471a559f7f78b25923ad69a12ff7dc178b1048\nparent 2d718a3fc23fbe9a27c71709c54128b5305609c7\nauthor Nick Cameron <nrc@ncameron.org> 1540949591 +1300\ncommitter GitHub <noreply@github.com> 1540949591 +1300\n\nMerge pull request #3159 from scampi/issue-3132\n\nThe method trim_left_preserve_layout didn't handle tabs properly."}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8506f5e5ce2f4e27f3e1a6a924f66859e2474dd5", "html_url": "https://github.com/rust-lang/rust/commit/8506f5e5ce2f4e27f3e1a6a924f66859e2474dd5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8506f5e5ce2f4e27f3e1a6a924f66859e2474dd5/comments", "author": {"login": "nrc", "id": 762626, "node_id": "MDQ6VXNlcjc2MjYyNg==", "avatar_url": "https://avatars.githubusercontent.com/u/762626?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nrc", "html_url": "https://github.com/nrc", "followers_url": "https://api.github.com/users/nrc/followers", "following_url": "https://api.github.com/users/nrc/following{/other_user}", "gists_url": "https://api.github.com/users/nrc/gists{/gist_id}", "starred_url": "https://api.github.com/users/nrc/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nrc/subscriptions", "organizations_url": "https://api.github.com/users/nrc/orgs", "repos_url": "https://api.github.com/users/nrc/repos", "events_url": "https://api.github.com/users/nrc/events{/privacy}", "received_events_url": "https://api.github.com/users/nrc/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2c471a559f7f78b25923ad69a12ff7dc178b1048", "url": "https://api.github.com/repos/rust-lang/rust/commits/2c471a559f7f78b25923ad69a12ff7dc178b1048", "html_url": "https://github.com/rust-lang/rust/commit/2c471a559f7f78b25923ad69a12ff7dc178b1048"}, {"sha": "2d718a3fc23fbe9a27c71709c54128b5305609c7", "url": "https://api.github.com/repos/rust-lang/rust/commits/2d718a3fc23fbe9a27c71709c54128b5305609c7", "html_url": "https://github.com/rust-lang/rust/commit/2d718a3fc23fbe9a27c71709c54128b5305609c7"}], "stats": {"total": 290, "additions": 147, "deletions": 143}, "files": [{"sha": "eaed5e1d41eb6dd60eb74fc1d396ffb460f76a20", "filename": "src/comment.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/8506f5e5ce2f4e27f3e1a6a924f66859e2474dd5/src%2Fcomment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8506f5e5ce2f4e27f3e1a6a924f66859e2474dd5/src%2Fcomment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomment.rs?ref=8506f5e5ce2f4e27f3e1a6a924f66859e2474dd5", "patch": "@@ -332,7 +332,7 @@ fn identify_comment(\n     let (first_group, rest) = orig.split_at(first_group_ending);\n     let rewritten_first_group =\n         if !config.normalize_comments() && has_bare_lines && style.is_block_comment() {\n-            trim_left_preserve_layout(first_group, &shape.indent, config)\n+            trim_left_preserve_layout(first_group, &shape.indent, config)?\n         } else if !config.normalize_comments()\n             && !config.wrap_comments()\n             && !config.format_doc_comments()"}, {"sha": "20592beaf17b88e9142128845bccbf44519d96da", "filename": "src/macros.rs", "status": "modified", "additions": 5, "deletions": 104, "changes": 109, "blob_url": "https://github.com/rust-lang/rust/blob/8506f5e5ce2f4e27f3e1a6a924f66859e2474dd5/src%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8506f5e5ce2f4e27f3e1a6a924f66859e2474dd5/src%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fmacros.rs?ref=8506f5e5ce2f4e27f3e1a6a924f66859e2474dd5", "patch": "@@ -40,7 +40,10 @@ use rewrite::{Rewrite, RewriteContext};\n use shape::{Indent, Shape};\n use source_map::SpanUtils;\n use spanned::Spanned;\n-use utils::{format_visibility, mk_sp, remove_trailing_white_spaces, rewrite_ident, wrap_str};\n+use utils::{\n+    format_visibility, is_empty_line, mk_sp, remove_trailing_white_spaces, rewrite_ident,\n+    trim_left_preserve_layout, wrap_str,\n+};\n use visitor::FmtVisitor;\n \n const FORCED_BRACKET_MACROS: &[&str] = &[\"vec!\"];\n@@ -373,7 +376,7 @@ pub fn rewrite_macro_inner(\n         }\n         DelimToken::Brace => {\n             // Skip macro invocations with braces, for now.\n-            indent_macro_snippet(context, context.snippet(mac.span), shape.indent)\n+            trim_left_preserve_layout(context.snippet(mac.span), &shape.indent, &context.config)\n         }\n         _ => unreachable!(),\n     }\n@@ -1101,108 +1104,6 @@ fn macro_style(mac: &ast::Mac, context: &RewriteContext) -> DelimToken {\n     }\n }\n \n-/// Indent each line according to the specified `indent`.\n-/// e.g.\n-///\n-/// ```rust,ignore\n-/// foo!{\n-/// x,\n-/// y,\n-/// foo(\n-///     a,\n-///     b,\n-///     c,\n-/// ),\n-/// }\n-/// ```\n-///\n-/// will become\n-///\n-/// ```rust,ignore\n-/// foo!{\n-///     x,\n-///     y,\n-///     foo(\n-///         a,\n-///         b,\n-///         c,\n-///     ),\n-/// }\n-/// ```\n-fn indent_macro_snippet(\n-    context: &RewriteContext,\n-    macro_str: &str,\n-    indent: Indent,\n-) -> Option<String> {\n-    let mut lines = LineClasses::new(macro_str);\n-    let first_line = lines.next().map(|(_, s)| s.trim_right().to_owned())?;\n-    let mut trimmed_lines = Vec::with_capacity(16);\n-\n-    let mut veto_trim = false;\n-    let min_prefix_space_width = lines\n-        .filter_map(|(kind, line)| {\n-            let mut trimmed = true;\n-            let prefix_space_width = if is_empty_line(&line) {\n-                None\n-            } else {\n-                Some(get_prefix_space_width(context, &line))\n-            };\n-\n-            let line = if veto_trim || (kind.is_string() && !line.ends_with('\\\\')) {\n-                veto_trim = kind.is_string() && !line.ends_with('\\\\');\n-                trimmed = false;\n-                line\n-            } else {\n-                line.trim().to_owned()\n-            };\n-            trimmed_lines.push((trimmed, line, prefix_space_width));\n-\n-            // when computing the minimum, do not consider lines within a string\n-            match kind {\n-                FullCodeCharKind::InString | FullCodeCharKind::EndString => None,\n-                _ => prefix_space_width,\n-            }\n-        })\n-        .min()?;\n-\n-    Some(\n-        first_line\n-            + \"\\n\"\n-            + &trimmed_lines\n-                .iter()\n-                .map(\n-                    |&(trimmed, ref line, prefix_space_width)| match prefix_space_width {\n-                        _ if !trimmed => line.to_owned(),\n-                        Some(original_indent_width) => {\n-                            let new_indent_width = indent.width()\n-                                + original_indent_width.saturating_sub(min_prefix_space_width);\n-                            let new_indent = Indent::from_width(context.config, new_indent_width);\n-                            format!(\"{}{}\", new_indent.to_string(context.config), line)\n-                        }\n-                        None => String::new(),\n-                    },\n-                )\n-                .collect::<Vec<_>>()\n-                .join(\"\\n\"),\n-    )\n-}\n-\n-fn get_prefix_space_width(context: &RewriteContext, s: &str) -> usize {\n-    let mut width = 0;\n-    for c in s.chars() {\n-        match c {\n-            ' ' => width += 1,\n-            '\\t' => width += context.config.tab_spaces(),\n-            _ => return width,\n-        }\n-    }\n-    width\n-}\n-\n-fn is_empty_line(s: &str) -> bool {\n-    s.is_empty() || s.chars().all(char::is_whitespace)\n-}\n-\n // A very simple parser that just parses a macros 2.0 definition into its branches.\n // Currently we do not attempt to parse any further than that.\n #[derive(new)]"}, {"sha": "86c01af39fba5bda8f7841e027555ecaba4efe9b", "filename": "src/utils.rs", "status": "modified", "additions": 115, "deletions": 38, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/8506f5e5ce2f4e27f3e1a6a924f66859e2474dd5/src%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8506f5e5ce2f4e27f3e1a6a924f66859e2474dd5/src%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Futils.rs?ref=8506f5e5ce2f4e27f3e1a6a924f66859e2474dd5", "patch": "@@ -20,7 +20,7 @@ use syntax::ast::{\n use syntax::ptr;\n use syntax::source_map::{BytePos, Span, NO_EXPANSION};\n \n-use comment::{filter_normal_code, CharClasses, FullCodeCharKind};\n+use comment::{filter_normal_code, CharClasses, FullCodeCharKind, LineClasses};\n use config::Config;\n use rewrite::RewriteContext;\n use shape::{Indent, Shape};\n@@ -483,46 +483,123 @@ pub fn remove_trailing_white_spaces(text: &str) -> String {\n     buffer\n }\n \n-/// Trims a minimum of leading whitespaces so that the content layout is kept and aligns to indent.\n-pub fn trim_left_preserve_layout(orig: &str, indent: &Indent, config: &Config) -> String {\n-    let prefix_whitespace_min = orig\n-        .lines()\n-        // skip the line with the starting sigil since the leading whitespace is removed\n-        // otherwise, the minimum would always be zero\n-        .skip(1)\n-        .filter(|line| !line.is_empty())\n-        .map(|line| {\n-            let mut width = 0;\n-            for c in line.chars() {\n-                match c {\n-                    ' ' => width += 1,\n-                    '\\t' => width += config.tab_spaces(),\n-                    _ => break,\n-                }\n-            }\n-            width\n-        })\n-        .min()\n-        .unwrap_or(0);\n-\n-    let indent_str = indent.to_string(config);\n-    let mut lines = orig.lines();\n-    let first_line = lines.next().unwrap();\n-    let rest = lines\n-        .map(|line| {\n-            if line.is_empty() {\n-                String::from(\"\\n\")\n+/// Indent each line according to the specified `indent`.\n+/// e.g.\n+///\n+/// ```rust,ignore\n+/// foo!{\n+/// x,\n+/// y,\n+/// foo(\n+///     a,\n+///     b,\n+///     c,\n+/// ),\n+/// }\n+/// ```\n+///\n+/// will become\n+///\n+/// ```rust,ignore\n+/// foo!{\n+///     x,\n+///     y,\n+///     foo(\n+///         a,\n+///         b,\n+///         c,\n+///     ),\n+/// }\n+/// ```\n+pub fn trim_left_preserve_layout(orig: &str, indent: &Indent, config: &Config) -> Option<String> {\n+    let mut lines = LineClasses::new(orig);\n+    let first_line = lines.next().map(|(_, s)| s.trim_right().to_owned())?;\n+    let mut trimmed_lines = Vec::with_capacity(16);\n+\n+    let mut veto_trim = false;\n+    let min_prefix_space_width = lines\n+        .filter_map(|(kind, line)| {\n+            let mut trimmed = true;\n+            let prefix_space_width = if is_empty_line(&line) {\n+                None\n             } else {\n-                format!(\"\\n{}{}\", indent_str, &line[prefix_whitespace_min..])\n+                Some(get_prefix_space_width(config, &line))\n+            };\n+\n+            let line = if veto_trim || (kind.is_string() && !line.ends_with('\\\\')) {\n+                veto_trim = kind.is_string() && !line.ends_with('\\\\');\n+                trimmed = false;\n+                line\n+            } else {\n+                line.trim().to_owned()\n+            };\n+            trimmed_lines.push((trimmed, line, prefix_space_width));\n+\n+            // When computing the minimum, do not consider lines within a string.\n+            // The reason is there is a veto against trimming and indenting such lines\n+            match kind {\n+                FullCodeCharKind::InString | FullCodeCharKind::EndString => None,\n+                _ => prefix_space_width,\n             }\n         })\n-        .collect::<Vec<String>>()\n-        .concat();\n-    format!(\"{}{}\", first_line, rest)\n+        .min()?;\n+\n+    Some(\n+        first_line\n+            + \"\\n\"\n+            + &trimmed_lines\n+                .iter()\n+                .map(\n+                    |&(trimmed, ref line, prefix_space_width)| match prefix_space_width {\n+                        _ if !trimmed => line.to_owned(),\n+                        Some(original_indent_width) => {\n+                            let new_indent_width = indent.width()\n+                                + original_indent_width.saturating_sub(min_prefix_space_width);\n+                            let new_indent = Indent::from_width(config, new_indent_width);\n+                            format!(\"{}{}\", new_indent.to_string(config), line)\n+                        }\n+                        None => String::new(),\n+                    },\n+                )\n+                .collect::<Vec<_>>()\n+                .join(\"\\n\"),\n+    )\n+}\n+\n+pub fn is_empty_line(s: &str) -> bool {\n+    s.is_empty() || s.chars().all(char::is_whitespace)\n+}\n+\n+fn get_prefix_space_width(config: &Config, s: &str) -> usize {\n+    let mut width = 0;\n+    for c in s.chars() {\n+        match c {\n+            ' ' => width += 1,\n+            '\\t' => width += config.tab_spaces(),\n+            _ => return width,\n+        }\n+    }\n+    width\n }\n \n-#[test]\n-fn test_remove_trailing_white_spaces() {\n-    let s = \"    r#\\\"\\n        test\\n    \\\"#\";\n-    assert_eq!(remove_trailing_white_spaces(&s), s);\n+#[cfg(test)]\n+mod test {\n+    use super::*;\n+\n+    #[test]\n+    fn test_remove_trailing_white_spaces() {\n+        let s = \"    r#\\\"\\n        test\\n    \\\"#\";\n+        assert_eq!(remove_trailing_white_spaces(&s), s);\n+    }\n+\n+    #[test]\n+    fn test_trim_left_preserve_layout() {\n+        let s = \"aaa\\n\\tbbb\\n    ccc\";\n+        let config = Config::default();\n+        let indent = Indent::new(4, 0);\n+        assert_eq!(\n+            trim_left_preserve_layout(&s, &indent, &config),\n+            Some(\"aaa\\n    bbb\\n    ccc\".to_string())\n+        );\n+    }\n }"}, {"sha": "a43b83223e23547ffc0b329a50e11bed04e18d4d", "filename": "tests/source/issue-3132.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8506f5e5ce2f4e27f3e1a6a924f66859e2474dd5/tests%2Fsource%2Fissue-3132.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8506f5e5ce2f4e27f3e1a6a924f66859e2474dd5/tests%2Fsource%2Fissue-3132.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fsource%2Fissue-3132.rs?ref=8506f5e5ce2f4e27f3e1a6a924f66859e2474dd5", "patch": "@@ -0,0 +1,13 @@\n+fn test() {\n+    /*\n+    a\n+\t*/\n+    let x = 42;\n+    /*\n+    aaa\n+    \"line 1\n+  line 2\n+        line 3\"\n+    */\n+    let x = 42;\n+}"}, {"sha": "42388e09f74647ed7928b7e7ff3b65aaa4f5e828", "filename": "tests/target/issue-3132.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/8506f5e5ce2f4e27f3e1a6a924f66859e2474dd5/tests%2Ftarget%2Fissue-3132.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8506f5e5ce2f4e27f3e1a6a924f66859e2474dd5/tests%2Ftarget%2Fissue-3132.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Ftarget%2Fissue-3132.rs?ref=8506f5e5ce2f4e27f3e1a6a924f66859e2474dd5", "patch": "@@ -0,0 +1,13 @@\n+fn test() {\n+    /*\n+    a\n+    */\n+    let x = 42;\n+    /*\n+      aaa\n+      \"line 1\n+    line 2\n+          line 3\"\n+      */\n+    let x = 42;\n+}"}]}