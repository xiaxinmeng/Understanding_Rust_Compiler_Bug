{"sha": "de2e67836e23405e5bdc27cefa510fa562c5298f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRlMmU2NzgzNmUyMzQwNWU1YmRjMjdjZWZhNTEwZmE1NjJjNTI5OGY=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-08-27T05:27:59Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-09-05T04:53:20Z"}, "message": "Add `Invocation` and `Expansion`, remove `MacroGenerable`.", "tree": {"sha": "750f07f824dcf6bf917145c029023146a5b0d9c2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/750f07f824dcf6bf917145c029023146a5b0d9c2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/de2e67836e23405e5bdc27cefa510fa562c5298f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/de2e67836e23405e5bdc27cefa510fa562c5298f", "html_url": "https://github.com/rust-lang/rust/commit/de2e67836e23405e5bdc27cefa510fa562c5298f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/de2e67836e23405e5bdc27cefa510fa562c5298f/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9b3bc7a9e9e35537823bc2a10fc078c1222ee7fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/9b3bc7a9e9e35537823bc2a10fc078c1222ee7fd", "html_url": "https://github.com/rust-lang/rust/commit/9b3bc7a9e9e35537823bc2a10fc078c1222ee7fd"}], "stats": {"total": 452, "additions": 240, "deletions": 212}, "files": [{"sha": "485bd3ce10b4b23ea15ab139ab10437185e061ed", "filename": "src/libsyntax/ext/expand.rs", "status": "modified", "additions": 240, "deletions": 212, "changes": 452, "blob_url": "https://github.com/rust-lang/rust/blob/de2e67836e23405e5bdc27cefa510fa562c5298f/src%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de2e67836e23405e5bdc27cefa510fa562c5298f/src%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fexpand.rs?ref=de2e67836e23405e5bdc27cefa510fa562c5298f", "patch": "@@ -30,249 +30,230 @@ use std_inject;\n \n use std::path::PathBuf;\n \n-// A trait for AST nodes and AST node lists into which macro invocations may expand.\n-trait MacroGenerable: Sized {\n-    // Expand the given MacResult using its appropriate `make_*` method.\n-    fn make_with<'a>(result: Box<MacResult + 'a>) -> Option<Self>;\n-\n-    // Fold this node or list of nodes using the given folder.\n-    fn fold_with<F: Folder>(self, folder: &mut F) -> Self;\n-    fn visit_with<V: Visitor>(&self, visitor: &mut V);\n+macro_rules! expansions {\n+    ($($kind:ident: $ty:ty, $kind_name:expr, .$make:ident,\n+            $(.$fold:ident)*  $(lift .$fold_elt:ident)*,\n+            $(.$visit:ident)* $(lift .$visit_elt:ident)*;)*) => {\n+        #[derive(Copy, Clone)]\n+        enum ExpansionKind { OptExpr, $( $kind, )*  }\n+        enum Expansion { OptExpr(Option<P<ast::Expr>>), $( $kind($ty), )* }\n+\n+        impl ExpansionKind {\n+            fn name(self) -> &'static str {\n+                match self {\n+                    ExpansionKind::OptExpr => \"expression\",\n+                    $( ExpansionKind::$kind => $kind_name, )*\n+                }\n+            }\n \n-    // The user-friendly name of the node type (e.g. \"expression\", \"item\", etc.) for diagnostics.\n-    fn kind_name() -> &'static str;\n+            fn make_from<'a>(self, result: Box<MacResult + 'a>) -> Option<Expansion> {\n+                match self {\n+                    ExpansionKind::OptExpr => result.make_expr().map(Some).map(Expansion::OptExpr),\n+                    $( ExpansionKind::$kind => result.$make().map(Expansion::$kind), )*\n+                }\n+            }\n+        }\n \n-    // Return a placeholder expansion to allow compilation to continue after an erroring expansion.\n-    fn dummy(span: Span) -> Self {\n-        Self::make_with(DummyResult::any(span)).unwrap()\n-    }\n-}\n+        impl Expansion {\n+            fn make_opt_expr(self) -> Option<P<ast::Expr>> {\n+                match self {\n+                    Expansion::OptExpr(expr) => expr,\n+                    _ => panic!(\"Expansion::make_* called on the wrong kind of expansion\"),\n+                }\n+            }\n+            $( fn $make(self) -> $ty {\n+                match self {\n+                    Expansion::$kind(ast) => ast,\n+                    _ => panic!(\"Expansion::make_* called on the wrong kind of expansion\"),\n+                }\n+            } )*\n \n-macro_rules! impl_macro_generable {\n-    ($($ty:ty: $kind_name:expr, .$make:ident,\n-               $(.$fold:ident)*  $(lift .$fold_elt:ident)*,\n-               $(.$visit:ident)* $(lift .$visit_elt:ident)*;)*) => { $(\n-        impl MacroGenerable for $ty {\n-            fn kind_name() -> &'static str { $kind_name }\n-            fn make_with<'a>(result: Box<MacResult + 'a>) -> Option<Self> { result.$make() }\n             fn fold_with<F: Folder>(self, folder: &mut F) -> Self {\n-                $( folder.$fold(self) )*\n-                $( self.into_iter().flat_map(|item| folder. $fold_elt (item)).collect() )*\n+                use self::Expansion::*;\n+                match self {\n+                    OptExpr(expr) => OptExpr(expr.and_then(|expr| folder.fold_opt_expr(expr))),\n+                    $($( $kind(ast) => $kind(folder.$fold(ast)), )*)*\n+                    $($( $kind(ast) => {\n+                        $kind(ast.into_iter().flat_map(|ast| folder.$fold_elt(ast)).collect())\n+                    }, )*)*\n+                }\n             }\n+\n             fn visit_with<V: Visitor>(&self, visitor: &mut V) {\n-                $( visitor.$visit(self) )*\n-                $( for item in self.as_slice() { visitor. $visit_elt (item) } )*\n+                match *self {\n+                    Expansion::OptExpr(Some(ref expr)) => visitor.visit_expr(expr),\n+                    $($( Expansion::$kind(ref ast) => visitor.$visit(ast), )*)*\n+                    $($( Expansion::$kind(ref ast) => for ast in ast.as_slice() {\n+                        visitor.$visit_elt(ast);\n+                    }, )*)*\n+                    _ => {}\n+                }\n             }\n         }\n-    )* }\n+    }\n }\n \n-impl_macro_generable! {\n-    P<ast::Expr>: \"expression\", .make_expr, .fold_expr, .visit_expr;\n-    P<ast::Pat>:  \"pattern\",    .make_pat,  .fold_pat,  .visit_pat;\n-    P<ast::Ty>:   \"type\",       .make_ty,   .fold_ty,   .visit_ty;\n-    SmallVector<ast::Stmt>: \"statement\", .make_stmts, lift .fold_stmt, lift .visit_stmt;\n-    SmallVector<P<ast::Item>>: \"item\",   .make_items, lift .fold_item, lift .visit_item;\n-    SmallVector<ast::TraitItem>:\n+expansions! {\n+    Expr: P<ast::Expr>, \"expression\", .make_expr, .fold_expr, .visit_expr;\n+    Pat: P<ast::Pat>,   \"pattern\",    .make_pat,  .fold_pat,  .visit_pat;\n+    Ty: P<ast::Ty>,     \"type\",       .make_ty,   .fold_ty,   .visit_ty;\n+    Stmts: SmallVector<ast::Stmt>, \"statement\", .make_stmts, lift .fold_stmt, lift .visit_stmt;\n+    Items: SmallVector<P<ast::Item>>, \"item\",   .make_items, lift .fold_item, lift .visit_item;\n+    TraitItems: SmallVector<ast::TraitItem>,\n         \"trait item\", .make_trait_items, lift .fold_trait_item, lift .visit_trait_item;\n-    SmallVector<ast::ImplItem>:\n+    ImplItems: SmallVector<ast::ImplItem>,\n         \"impl item\",  .make_impl_items,  lift .fold_impl_item,  lift .visit_impl_item;\n }\n \n-impl MacroGenerable for Option<P<ast::Expr>> {\n-    fn kind_name() -> &'static str { \"expression\" }\n-    fn make_with<'a>(result: Box<MacResult + 'a>) -> Option<Self> {\n-        result.make_expr().map(Some)\n-    }\n-    fn fold_with<F: Folder>(self, folder: &mut F) -> Self {\n-        self.and_then(|expr| folder.fold_opt_expr(expr))\n-    }\n-    fn visit_with<V: Visitor>(&self, visitor: &mut V) {\n-        self.as_ref().map(|expr| visitor.visit_expr(expr));\n+impl ExpansionKind {\n+    fn dummy(self, span: Span) -> Expansion {\n+        self.make_from(DummyResult::any(span)).unwrap()\n     }\n }\n \n-pub fn expand_expr(expr: ast::Expr, fld: &mut MacroExpander) -> P<ast::Expr> {\n-    match expr.node {\n-        // expr_mac should really be expr_ext or something; it's the\n-        // entry-point for all syntax extensions.\n-        ast::ExprKind::Mac(mac) => {\n-            return expand_mac_invoc(mac, None, expr.attrs.into(), expr.span, fld);\n-        }\n-        _ => P(noop_fold_expr(expr, fld)),\n-    }\n+pub struct Invocation {\n+    span: Span,\n+    attrs: Vec<ast::Attribute>,\n+    mac: ast::Mac,\n+    ident: Option<Ident>,\n+    mark: Mark,\n+    kind: ExpansionKind,\n }\n \n-struct MacroScopePlaceholder;\n-impl MacResult for MacroScopePlaceholder {\n-    fn make_items(self: Box<Self>) -> Option<SmallVector<P<ast::Item>>> {\n-        Some(SmallVector::one(P(ast::Item {\n-            ident: keywords::Invalid.ident(),\n-            attrs: Vec::new(),\n-            id: ast::DUMMY_NODE_ID,\n-            node: ast::ItemKind::Mac(dummy_spanned(ast::Mac_ {\n-                path: ast::Path { span: syntax_pos::DUMMY_SP, global: false, segments: Vec::new() },\n-                tts: Vec::new(),\n-            })),\n-            vis: ast::Visibility::Inherited,\n-            span: syntax_pos::DUMMY_SP,\n-        })))\n+pub fn expand_expr(expr: ast::Expr, fld: &mut MacroExpander) -> P<ast::Expr> {\n+    if let ast::ExprKind::Mac(mac) = expr.node {\n+        let invoc = fld.new_invoc(mac, expr.attrs.into(), expr.span, ExpansionKind::Expr);\n+        expand_mac_invoc(invoc, fld).make_expr()\n+    } else {\n+        P(noop_fold_expr(expr, fld))\n     }\n }\n \n /// Expand a macro invocation. Returns the result of expansion.\n-fn expand_mac_invoc<T>(mac: ast::Mac, ident: Option<Ident>, attrs: Vec<ast::Attribute>, span: Span,\n-                       fld: &mut MacroExpander) -> T\n-    where T: MacroGenerable,\n-{\n-    // It would almost certainly be cleaner to pass the whole macro invocation in,\n-    // rather than pulling it apart and marking the tts and the ctxt separately.\n+fn expand_mac_invoc(invoc: Invocation, fld: &mut MacroExpander) -> Expansion {\n+    let Invocation { span, attrs, mac, ident, mark, kind } = invoc;\n     let Mac_ { path, tts, .. } = mac.node;\n-    let mark = Mark::fresh();\n-\n-    fn mac_result<'a>(path: &ast::Path, ident: Option<Ident>, tts: Vec<TokenTree>, mark: Mark,\n-                      attrs: Vec<ast::Attribute>, call_site: Span, fld: &'a mut MacroExpander)\n-                      -> Option<Box<MacResult + 'a>> {\n-        // Detect use of feature-gated or invalid attributes on macro invoations\n-        // since they will not be detected after macro expansion.\n-        for attr in attrs.iter() {\n-            feature_gate::check_attribute(&attr, &fld.cx.parse_sess.span_diagnostic,\n-                                          &fld.cx.parse_sess.codemap(),\n-                                          &fld.cx.ecfg.features.unwrap());\n-        }\n-\n-        if path.segments.len() > 1 || path.global || !path.segments[0].parameters.is_empty() {\n-            fld.cx.span_err(path.span, \"expected macro name without module separators\");\n-            return None;\n-        }\n \n-        let extname = path.segments[0].identifier.name;\n-        let extension = if let Some(extension) = fld.cx.syntax_env.find(extname) {\n-            extension\n-        } else {\n-            let mut err = fld.cx.struct_span_err(path.span,\n-                                                 &format!(\"macro undefined: '{}!'\", &extname));\n-            fld.cx.suggest_macro_name(&extname.as_str(), &mut err);\n-            err.emit();\n-            return None;\n-        };\n+    // Detect use of feature-gated or invalid attributes on macro invoations\n+    // since they will not be detected after macro expansion.\n+    for attr in attrs.iter() {\n+        feature_gate::check_attribute(&attr, &fld.cx.parse_sess.span_diagnostic,\n+                                      &fld.cx.parse_sess.codemap(),\n+                                      &fld.cx.ecfg.features.unwrap());\n+    }\n \n-        let ident = ident.unwrap_or(keywords::Invalid.ident());\n-        let marked_tts = mark_tts(&tts, mark);\n-        match *extension {\n-            NormalTT(ref expandfun, exp_span, allow_internal_unstable) => {\n-                if ident.name != keywords::Invalid.name() {\n-                    let msg =\n-                        format!(\"macro {}! expects no ident argument, given '{}'\", extname, ident);\n-                    fld.cx.span_err(path.span, &msg);\n-                    return None;\n-                }\n+    if path.segments.len() > 1 || path.global || !path.segments[0].parameters.is_empty() {\n+        fld.cx.span_err(path.span, \"expected macro name without module separators\");\n+        return kind.dummy(span);\n+    }\n \n-                fld.cx.bt_push(ExpnInfo {\n-                    call_site: call_site,\n-                    callee: NameAndSpan {\n-                        format: MacroBang(extname),\n-                        span: exp_span,\n-                        allow_internal_unstable: allow_internal_unstable,\n-                    },\n-                });\n+    let extname = path.segments[0].identifier.name;\n+    let extension = if let Some(extension) = fld.cx.syntax_env.find(extname) {\n+        extension\n+    } else {\n+        let mut err =\n+            fld.cx.struct_span_err(path.span, &format!(\"macro undefined: '{}!'\", &extname));\n+        fld.cx.suggest_macro_name(&extname.as_str(), &mut err);\n+        err.emit();\n+        return kind.dummy(span);\n+    };\n \n-                Some(expandfun.expand(fld.cx, call_site, &marked_tts))\n+    let ident = ident.unwrap_or(keywords::Invalid.ident());\n+    let marked_tts = mark_tts(&tts, mark);\n+    let opt_expanded = match *extension {\n+        NormalTT(ref expandfun, exp_span, allow_internal_unstable) => {\n+            if ident.name != keywords::Invalid.name() {\n+                let msg =\n+                    format!(\"macro {}! expects no ident argument, given '{}'\", extname, ident);\n+                fld.cx.span_err(path.span, &msg);\n+                return kind.dummy(span);\n             }\n \n-            IdentTT(ref expander, tt_span, allow_internal_unstable) => {\n-                if ident.name == keywords::Invalid.name() {\n-                    fld.cx.span_err(path.span,\n-                                    &format!(\"macro {}! expects an ident argument\", extname));\n-                    return None;\n-                };\n+            fld.cx.bt_push(ExpnInfo {\n+                call_site: span,\n+                callee: NameAndSpan {\n+                    format: MacroBang(extname),\n+                    span: exp_span,\n+                    allow_internal_unstable: allow_internal_unstable,\n+                },\n+            });\n \n-                fld.cx.bt_push(ExpnInfo {\n-                    call_site: call_site,\n-                    callee: NameAndSpan {\n-                        format: MacroBang(extname),\n-                        span: tt_span,\n-                        allow_internal_unstable: allow_internal_unstable,\n-                    }\n-                });\n+            kind.make_from(expandfun.expand(fld.cx, span, &marked_tts))\n+        }\n \n-                Some(expander.expand(fld.cx, call_site, ident, marked_tts))\n-            }\n+        IdentTT(ref expander, tt_span, allow_internal_unstable) => {\n+            if ident.name == keywords::Invalid.name() {\n+                fld.cx.span_err(path.span,\n+                                &format!(\"macro {}! expects an ident argument\", extname));\n+                return kind.dummy(span);\n+            };\n \n-            MacroRulesTT => {\n-                if ident.name == keywords::Invalid.name() {\n-                    fld.cx.span_err(path.span,\n-                                    &format!(\"macro {}! expects an ident argument\", extname));\n-                    return None;\n-                };\n+            fld.cx.bt_push(ExpnInfo {\n+                call_site: span,\n+                callee: NameAndSpan {\n+                    format: MacroBang(extname),\n+                    span: tt_span,\n+                    allow_internal_unstable: allow_internal_unstable,\n+                }\n+            });\n \n-                fld.cx.bt_push(ExpnInfo {\n-                    call_site: call_site,\n-                    callee: NameAndSpan {\n-                        format: MacroBang(extname),\n-                        span: None,\n-                        // `macro_rules!` doesn't directly allow unstable\n-                        // (this is orthogonal to whether the macro it creates allows it)\n-                        allow_internal_unstable: false,\n-                    }\n-                });\n+            kind.make_from(expander.expand(fld.cx, span, ident, marked_tts))\n+        }\n \n-                let def = ast::MacroDef {\n-                    ident: ident,\n-                    id: ast::DUMMY_NODE_ID,\n-                    span: call_site,\n-                    imported_from: None,\n-                    use_locally: true,\n-                    body: marked_tts,\n-                    export: attr::contains_name(&attrs, \"macro_export\"),\n-                    allow_internal_unstable: attr::contains_name(&attrs, \"allow_internal_unstable\"),\n-                    attrs: attrs,\n-                };\n+        MacroRulesTT => {\n+            if ident.name == keywords::Invalid.name() {\n+                fld.cx.span_err(path.span,\n+                                &format!(\"macro {}! expects an ident argument\", extname));\n+                return kind.dummy(span);\n+            };\n \n-                fld.cx.insert_macro(def.clone());\n-\n-                // macro_rules! has a side effect, but expands to nothing.\n-                // If keep_macs is true, expands to a MacEager::items instead.\n-                if fld.keep_macs {\n-                    Some(MacEager::items(SmallVector::one(P(ast::Item {\n-                        ident: def.ident,\n-                        attrs: def.attrs.clone(),\n-                        id: ast::DUMMY_NODE_ID,\n-                        node: ast::ItemKind::Mac(ast::Mac {\n-                            span: def.span,\n-                            node: ast::Mac_ {\n-                                path: path.clone(),\n-                                tts: def.body.clone(),\n-                            }\n-                        }),\n-                        vis: ast::Visibility::Inherited,\n-                        span: def.span,\n-                    }))))\n-                } else {\n-                    Some(Box::new(MacroScopePlaceholder))\n+            fld.cx.bt_push(ExpnInfo {\n+                call_site: span,\n+                callee: NameAndSpan {\n+                    format: MacroBang(extname),\n+                    span: None,\n+                    // `macro_rules!` doesn't directly allow unstable\n+                    // (this is orthogonal to whether the macro it creates allows it)\n+                    allow_internal_unstable: false,\n                 }\n-            }\n+            });\n \n-            MultiDecorator(..) | MultiModifier(..) => {\n-                fld.cx.span_err(path.span,\n-                                &format!(\"`{}` can only be used in attributes\", extname));\n-                None\n+            let def = ast::MacroDef {\n+                ident: ident,\n+                id: ast::DUMMY_NODE_ID,\n+                span: span,\n+                imported_from: None,\n+                use_locally: true,\n+                body: marked_tts,\n+                export: attr::contains_name(&attrs, \"macro_export\"),\n+                allow_internal_unstable: attr::contains_name(&attrs, \"allow_internal_unstable\"),\n+                attrs: attrs,\n+            };\n+\n+            fld.cx.insert_macro(def.clone());\n+\n+            // If keep_macs is true, expands to a MacEager::items instead.\n+            if fld.keep_macs {\n+                Some(reconstruct_macro_rules(&def, &path))\n+            } else {\n+                Some(macro_scope_placeholder())\n             }\n         }\n-    }\n \n-    let opt_expanded = T::make_with(match mac_result(&path, ident, tts, mark, attrs, span, fld) {\n-        Some(result) => result,\n-        None => return T::dummy(span),\n-    });\n+        MultiDecorator(..) | MultiModifier(..) => {\n+            fld.cx.span_err(path.span,\n+                            &format!(\"`{}` can only be used in attributes\", extname));\n+            return kind.dummy(span);\n+        }\n+    };\n \n     let expanded = if let Some(expanded) = opt_expanded {\n         expanded\n     } else {\n         let msg = format!(\"non-{kind} macro in {kind} position: {name}\",\n-                          name = path.segments[0].identifier.name, kind = T::kind_name());\n+                          name = path.segments[0].identifier.name, kind = kind.name());\n         fld.cx.span_err(path.span, &msg);\n-        return T::dummy(span);\n+        return kind.dummy(span);\n     };\n \n     let marked = expanded.fold_with(&mut Marker { mark: mark, expn_id: Some(fld.cx.backtrace()) });\n@@ -342,8 +323,8 @@ fn expand_stmt(stmt: Stmt, fld: &mut MacroExpander) -> SmallVector<Stmt> {\n         _ => return noop_fold_stmt(stmt, fld)\n     };\n \n-    let mut fully_expanded: SmallVector<ast::Stmt> =\n-        expand_mac_invoc(mac, None, attrs.into(), stmt.span, fld);\n+    let invoc = fld.new_invoc(mac, attrs.into(), stmt.span, ExpansionKind::Stmts);\n+    let mut fully_expanded = expand_mac_invoc(invoc, fld).make_stmts();\n \n     // If this is a macro invocation with a semicolon, then apply that\n     // semicolon to the final statement produced by expansion.\n@@ -361,11 +342,12 @@ fn expand_pat(p: P<ast::Pat>, fld: &mut MacroExpander) -> P<ast::Pat> {\n         PatKind::Mac(_) => {}\n         _ => return noop_fold_pat(p, fld)\n     }\n-    p.and_then(|ast::Pat {node, span, ..}| {\n-        match node {\n-            PatKind::Mac(mac) => expand_mac_invoc(mac, None, Vec::new(), span, fld),\n-            _ => unreachable!()\n+    p.and_then(|p| match p.node {\n+        PatKind::Mac(mac) => {\n+            let invoc = fld.new_invoc(mac, Vec::new(), p.span, ExpansionKind::Pat);\n+            expand_mac_invoc(invoc, fld).make_pat()\n         }\n+        _ => unreachable!(),\n     })\n }\n \n@@ -380,8 +362,11 @@ fn expand_multi_modified(a: Annotatable, fld: &mut MacroExpander) -> SmallVector\n                     return SmallVector::one(Annotatable::Item(it));\n                 }\n                 it.and_then(|it| match it.node {\n-                    ItemKind::Mac(mac) =>\n-                        expand_mac_invoc(mac, Some(it.ident), it.attrs, it.span, fld),\n+                    ItemKind::Mac(mac) => {\n+                        let mut invoc = fld.new_invoc(mac, it.attrs, it.span, ExpansionKind::Items);\n+                        invoc.ident = Some(it.ident);\n+                        expand_mac_invoc(invoc, fld).make_items()\n+                    }\n                     _ => unreachable!(),\n                 })\n             }\n@@ -472,7 +457,8 @@ fn expand_impl_item(ii: ast::ImplItem, fld: &mut MacroExpander)\n                  -> SmallVector<ast::ImplItem> {\n     match ii.node {\n         ast::ImplItemKind::Macro(mac) => {\n-            expand_mac_invoc(mac, None, ii.attrs, ii.span, fld)\n+            let invoc = fld.new_invoc(mac, ii.attrs, ii.span, ExpansionKind::ImplItems);\n+            expand_mac_invoc(invoc, fld).make_impl_items()\n         }\n         _ => fold::noop_fold_impl_item(ii, fld)\n     }\n@@ -482,7 +468,8 @@ fn expand_trait_item(ti: ast::TraitItem, fld: &mut MacroExpander)\n                      -> SmallVector<ast::TraitItem> {\n     match ti.node {\n         ast::TraitItemKind::Macro(mac) => {\n-            expand_mac_invoc(mac, None, ti.attrs, ti.span, fld)\n+            let invoc = fld.new_invoc(mac, ti.attrs, ti.span, ExpansionKind::TraitItems);\n+            expand_mac_invoc(invoc, fld).make_trait_items()\n         }\n         _ => fold::noop_fold_trait_item(ti, fld)\n     }\n@@ -496,7 +483,8 @@ pub fn expand_type(t: P<ast::Ty>, fld: &mut MacroExpander) -> P<ast::Ty> {\n \n     match t.node {\n         ast::TyKind::Mac(mac) => {\n-            expand_mac_invoc(mac, None, Vec::new(), t.span, fld)\n+            let invoc = fld.new_invoc(mac, Vec::new(), t.span, ExpansionKind::Ty);\n+            expand_mac_invoc(invoc, fld).make_ty()\n         }\n         _ => unreachable!(),\n     }\n@@ -529,7 +517,7 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n         }\n     }\n \n-    fn load_macros<T: MacroGenerable>(&mut self, node: &T) {\n+    fn load_macros(&mut self, node: &Expansion) {\n         struct MacroLoadingVisitor<'a, 'b: 'a>{\n             cx: &'a mut ExtCtxt<'b>,\n             at_crate_root: bool,\n@@ -567,6 +555,12 @@ impl<'a, 'b> MacroExpander<'a, 'b> {\n             cx: self.cx,\n         });\n     }\n+\n+    fn new_invoc(&self, mac: ast::Mac, attrs: Vec<ast::Attribute>, span: Span, kind: ExpansionKind)\n+                 -> Invocation {\n+        let mark = Mark::fresh();\n+        Invocation { span: span, attrs: attrs, mac: mac, mark: mark, kind: kind, ident: None }\n+    }\n }\n \n impl<'a, 'b> Folder for MacroExpander<'a, 'b> {\n@@ -583,8 +577,11 @@ impl<'a, 'b> Folder for MacroExpander<'a, 'b> {\n \n     fn fold_opt_expr(&mut self, expr: P<ast::Expr>) -> Option<P<ast::Expr>> {\n         expr.and_then(|expr| match expr.node {\n-            ast::ExprKind::Mac(mac) =>\n-                expand_mac_invoc(mac, None, expr.attrs.into(), expr.span, self),\n+            ast::ExprKind::Mac(mac) => {\n+                let invoc =\n+                    self.new_invoc(mac, expr.attrs.into(), expr.span, ExpansionKind::OptExpr);\n+                expand_mac_invoc(invoc, self).make_opt_expr()\n+            }\n             _ => Some(expand_expr(expr, self)),\n         })\n     }\n@@ -647,6 +644,37 @@ impl<'a, 'b> Folder for MacroExpander<'a, 'b> {\n     }\n }\n \n+fn macro_scope_placeholder() -> Expansion {\n+    Expansion::Items(SmallVector::one(P(ast::Item {\n+        ident: keywords::Invalid.ident(),\n+        attrs: Vec::new(),\n+        id: ast::DUMMY_NODE_ID,\n+        node: ast::ItemKind::Mac(dummy_spanned(ast::Mac_ {\n+            path: ast::Path { span: syntax_pos::DUMMY_SP, global: false, segments: Vec::new() },\n+            tts: Vec::new(),\n+        })),\n+        vis: ast::Visibility::Inherited,\n+        span: syntax_pos::DUMMY_SP,\n+    })))\n+}\n+\n+fn reconstruct_macro_rules(def: &ast::MacroDef, path: &ast::Path) -> Expansion {\n+    Expansion::Items(SmallVector::one(P(ast::Item {\n+        ident: def.ident,\n+        attrs: def.attrs.clone(),\n+        id: ast::DUMMY_NODE_ID,\n+        node: ast::ItemKind::Mac(ast::Mac {\n+            span: def.span,\n+            node: ast::Mac_ {\n+                path: path.clone(),\n+                tts: def.body.clone(),\n+            }\n+        }),\n+        vis: ast::Visibility::Inherited,\n+        span: def.span,\n+    })))\n+}\n+\n pub struct ExpansionConfig<'feat> {\n     pub crate_name: String,\n     pub features: Option<&'feat Features>,\n@@ -718,10 +746,10 @@ pub fn expand_crate_with_expander(expander: &mut MacroExpander,\n         expander.cx.syntax_env.insert(name, extension);\n     }\n \n-    let items = SmallVector::many(c.module.items);\n+    let items = Expansion::Items(SmallVector::many(c.module.items));\n     let configured = items.fold_with(&mut expander.strip_unconfigured());\n     expander.load_macros(&configured);\n-    c.module.items = configured.into();\n+    c.module.items = configured.make_items().into();\n \n     let err_count = expander.cx.parse_sess.span_diagnostic.err_count();\n     let mut ret = expander.fold_crate(c);"}]}