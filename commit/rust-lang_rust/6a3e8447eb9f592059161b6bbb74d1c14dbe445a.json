{"sha": "6a3e8447eb9f592059161b6bbb74d1c14dbe445a", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZhM2U4NDQ3ZWI5ZjU5MjA1OTE2MWI2YmJiNzRkMWMxNGRiZTQ0NWE=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-04-01T19:10:39Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2015-04-01T19:10:39Z"}, "message": "Rollup merge of #23924 - nrc:unqual-assoc3, r=alexcrichton\n\nBasically stuff I did for unqualified assoc types which is worth landing by itself.", "tree": {"sha": "63014c950f6f2fdaa52dbcd31bba2c4bda003c89", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/63014c950f6f2fdaa52dbcd31bba2c4bda003c89"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6a3e8447eb9f592059161b6bbb74d1c14dbe445a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6a3e8447eb9f592059161b6bbb74d1c14dbe445a", "html_url": "https://github.com/rust-lang/rust/commit/6a3e8447eb9f592059161b6bbb74d1c14dbe445a", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6a3e8447eb9f592059161b6bbb74d1c14dbe445a/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "debac97a10ce7fec71ab16101889f7ec5ea17e71", "url": "https://api.github.com/repos/rust-lang/rust/commits/debac97a10ce7fec71ab16101889f7ec5ea17e71", "html_url": "https://github.com/rust-lang/rust/commit/debac97a10ce7fec71ab16101889f7ec5ea17e71"}, {"sha": "0dd0925f5777122460ee84acf0b6dae76b58b25a", "url": "https://api.github.com/repos/rust-lang/rust/commits/0dd0925f5777122460ee84acf0b6dae76b58b25a", "html_url": "https://github.com/rust-lang/rust/commit/0dd0925f5777122460ee84acf0b6dae76b58b25a"}], "stats": {"total": 295, "additions": 171, "deletions": 124}, "files": [{"sha": "7e436d95192f5da4b12c9965d3513cac86e5872e", "filename": "src/librustc/middle/dataflow.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a3e8447eb9f592059161b6bbb74d1c14dbe445a/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a3e8447eb9f592059161b6bbb74d1c14dbe445a/src%2Flibrustc%2Fmiddle%2Fdataflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdataflow.rs?ref=6a3e8447eb9f592059161b6bbb74d1c14dbe445a", "patch": "@@ -108,7 +108,7 @@ impl<'a, 'tcx, O:DataFlowOperator> pprust::PpAnn for DataFlowContext<'a, 'tcx, O\n             pprust::NodeIdent(_) | pprust::NodeName(_) => 0,\n             pprust::NodeExpr(expr) => expr.id,\n             pprust::NodeBlock(blk) => blk.id,\n-            pprust::NodeItem(_) => 0,\n+            pprust::NodeItem(_) | pprust::NodeSubItem(_) => 0,\n             pprust::NodePat(pat) => pat.id\n         };\n "}, {"sha": "c60bb229be142aba8a94353ea6dac1ce6efde82c", "filename": "src/librustc/middle/def.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6a3e8447eb9f592059161b6bbb74d1c14dbe445a/src%2Flibrustc%2Fmiddle%2Fdef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a3e8447eb9f592059161b6bbb74d1c14dbe445a/src%2Flibrustc%2Fmiddle%2Fdef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdef.rs?ref=6a3e8447eb9f592059161b6bbb74d1c14dbe445a", "patch": "@@ -65,7 +65,7 @@ pub enum Def {\n ///     <T as Trait>::AssocX::AssocY::MethodOrAssocType\n ///           ^~~~~~~~~~~~~~  ^~~~~~~~~~~~~~~~~~~~~~~~~\n ///           base_def        depth = 2\n-#[derive(Copy, Debug)]\n+#[derive(Copy, Clone, Debug)]\n pub struct PathResolution {\n     pub base_def: Def,\n     pub last_private: LastPrivate,\n@@ -85,6 +85,17 @@ impl PathResolution {\n     pub fn def_id(&self) -> ast::DefId {\n         self.full_def().def_id()\n     }\n+\n+    pub fn new(base_def: Def,\n+               last_private: LastPrivate,\n+               depth: usize)\n+               -> PathResolution {\n+        PathResolution {\n+            base_def: base_def,\n+            last_private: last_private,\n+            depth: depth,\n+        }\n+    }\n }\n \n // Definition mapping"}, {"sha": "d8efb5655aaabc2c62ade363978214b7183ecc9a", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6a3e8447eb9f592059161b6bbb74d1c14dbe445a/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a3e8447eb9f592059161b6bbb74d1c14dbe445a/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=6a3e8447eb9f592059161b6bbb74d1c14dbe445a", "patch": "@@ -32,7 +32,7 @@ pub type ExternalExports = DefIdSet;\n /// reexporting a public struct doesn't inline the doc).\n pub type PublicItems = NodeSet;\n \n-#[derive(Copy, Debug)]\n+#[derive(Copy, Clone, Debug)]\n pub enum LastPrivate {\n     LastMod(PrivateDep),\n     // `use` directives (imports) can refer to two separate definitions in the\n@@ -46,14 +46,14 @@ pub enum LastPrivate {\n                type_used: ImportUse},\n }\n \n-#[derive(Copy, Debug)]\n+#[derive(Copy, Clone, Debug)]\n pub enum PrivateDep {\n     AllPublic,\n     DependsOn(ast::DefId),\n }\n \n // How an import is used.\n-#[derive(Copy, PartialEq, Debug)]\n+#[derive(Copy, Clone, PartialEq, Debug)]\n pub enum ImportUse {\n     Unused,       // The import is not used.\n     Used,         // The import is used."}, {"sha": "37c9647c92b77df43fcdb94aaab1d5d5d270028b", "filename": "src/librustc_driver/pretty.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a3e8447eb9f592059161b6bbb74d1c14dbe445a/src%2Flibrustc_driver%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a3e8447eb9f592059161b6bbb74d1c14dbe445a/src%2Flibrustc_driver%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fpretty.rs?ref=6a3e8447eb9f592059161b6bbb74d1c14dbe445a", "patch": "@@ -226,6 +226,10 @@ impl<'ast> pprust::PpAnn for IdentifiedAnnotation<'ast> {\n                 try!(pp::space(&mut s.s));\n                 s.synth_comment(item.id.to_string())\n             }\n+            pprust::NodeSubItem(id) => {\n+                try!(pp::space(&mut s.s));\n+                s.synth_comment(id.to_string())\n+            }\n             pprust::NodeBlock(blk) => {\n                 try!(pp::space(&mut s.s));\n                 s.synth_comment(format!(\"block {}\", blk.id))"}, {"sha": "ece83b578d25774a9653d13fe6a0b61274f05028", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 41, "deletions": 53, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/6a3e8447eb9f592059161b6bbb74d1c14dbe445a/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a3e8447eb9f592059161b6bbb74d1c14dbe445a/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=6a3e8447eb9f592059161b6bbb74d1c14dbe445a", "patch": "@@ -162,9 +162,12 @@ impl NamespaceResult {\n }\n \n enum NameDefinition {\n-    NoNameDefinition,           //< The name was unbound.\n-    ChildNameDefinition(Def, LastPrivate), //< The name identifies an immediate child.\n-    ImportNameDefinition(Def, LastPrivate) //< The name identifies an import.\n+    // The name was unbound.\n+    NoNameDefinition,\n+    // The name identifies an immediate child.\n+    ChildNameDefinition(Def, LastPrivate),\n+    // The name identifies an import.\n+    ImportNameDefinition(Def, LastPrivate),\n }\n \n impl<'a, 'v, 'tcx> Visitor<'v> for Resolver<'a, 'tcx> {\n@@ -795,11 +798,6 @@ pub struct Resolver<'a, 'tcx:'a> {\n     // The current self type if inside an impl (used for better errors).\n     current_self_type: Option<Ty>,\n \n-    // The ident for the keyword \"self\".\n-    self_name: Name,\n-    // The ident for the non-keyword \"Self\".\n-    type_self_name: Name,\n-\n     // The idents for the primitive types.\n     primitive_type_table: PrimitiveTypeTable,\n \n@@ -869,9 +867,6 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n             current_trait_ref: None,\n             current_self_type: None,\n \n-            self_name: special_names::self_,\n-            type_self_name: special_names::type_self,\n-\n             primitive_type_table: PrimitiveTypeTable::new(),\n \n             def_map: RefCell::new(NodeMap()),\n@@ -1822,7 +1817,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 let mut self_type_rib = Rib::new(ItemRibKind);\n \n                 // plain insert (no renaming, types are not currently hygienic....)\n-                let name = self.type_self_name;\n+                let name = special_names::type_self;\n                 self_type_rib.bindings.insert(name, DlDef(DefSelfTy(item.id)));\n                 self.type_ribs.push(self_type_rib);\n \n@@ -2047,8 +2042,9 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n     fn with_optional_trait_ref<T, F>(&mut self,\n                                      opt_trait_ref: Option<&TraitRef>,\n-                                     f: F) -> T where\n-        F: FnOnce(&mut Resolver) -> T,\n+                                     f: F)\n+                                     -> T\n+        where F: FnOnce(&mut Resolver) -> T,\n     {\n         let mut new_val = None;\n         if let Some(trait_ref) = opt_trait_ref {\n@@ -2585,11 +2581,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n         let span = path.span;\n         let segments = &path.segments[..path.segments.len()-path_depth];\n \n-        let mk_res = |(def, lp)| PathResolution {\n-            base_def: def,\n-            last_private: lp,\n-            depth: path_depth\n-        };\n+        let mk_res = |(def, lp)| PathResolution::new(def, lp, path_depth);\n \n         if path.global {\n             let def = self.resolve_crate_relative_path(span, segments, namespace);\n@@ -2603,25 +2595,25 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                         check_ribs,\n                                         span);\n \n-        if segments.len() > 1 {\n-            let def = self.resolve_module_relative_path(span, segments, namespace);\n-            match (def, unqualified_def) {\n-                (Some((ref d, _)), Some((ref ud, _))) if *d == *ud => {\n-                    self.session\n-                        .add_lint(lint::builtin::UNUSED_QUALIFICATIONS,\n-                                  id, span,\n-                                  \"unnecessary qualification\".to_string());\n-                }\n-                _ => ()\n-            }\n+        if segments.len() <= 1 {\n+            return unqualified_def.map(mk_res);\n+        }\n \n-            def.map(mk_res)\n-        } else {\n-            unqualified_def.map(mk_res)\n+        let def = self.resolve_module_relative_path(span, segments, namespace);\n+        match (def, unqualified_def) {\n+            (Some((ref d, _)), Some((ref ud, _))) if *d == *ud => {\n+                self.session\n+                    .add_lint(lint::builtin::UNUSED_QUALIFICATIONS,\n+                              id, span,\n+                              \"unnecessary qualification\".to_string());\n+            }\n+            _ => {}\n         }\n+\n+        def.map(mk_res)\n     }\n \n-    // resolve a single identifier (used as a varref)\n+    // Resolve a single identifier.\n     fn resolve_identifier(&mut self,\n                           identifier: Ident,\n                           namespace: Namespace,\n@@ -2662,8 +2654,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 match child_name_bindings.def_for_namespace(namespace) {\n                     Some(def) => {\n                         // Found it. Stop the search here.\n-                        let p = child_name_bindings.defined_in_public_namespace(\n-                                        namespace);\n+                        let p = child_name_bindings.defined_in_public_namespace(namespace);\n                         let lp = if p {LastMod(AllPublic)} else {\n                             LastMod(DependsOn(def.def_id()))\n                         };\n@@ -2734,8 +2725,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n         let containing_module;\n         let last_private;\n-        let module = self.current_module.clone();\n-        match self.resolve_module_path(module,\n+        let current_module = self.current_module.clone();\n+        match self.resolve_module_path(current_module,\n                                        &module_path[..],\n                                        UseLexicalScope,\n                                        span,\n@@ -2858,8 +2849,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n         match search_result {\n             Some(DlDef(def)) => {\n-                debug!(\"(resolving path in local ribs) resolved `{}` to \\\n-                        local: {:?}\",\n+                debug!(\"(resolving path in local ribs) resolved `{}` to local: {:?}\",\n                        token::get_ident(ident),\n                        def);\n                 Some(def)\n@@ -2904,15 +2894,13 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 panic!(\"unexpected indeterminate result\");\n             }\n             Failed(err) => {\n-                match err {\n-                    Some((span, msg)) =>\n-                        self.resolve_error(span, &format!(\"failed to resolve. {}\",\n-                                                         msg)),\n-                    None => ()\n-                }\n-\n                 debug!(\"(resolving item path by identifier in lexical scope) \\\n                          failed to resolve {}\", token::get_name(name));\n+\n+                if let Some((span, msg)) = err {\n+                    self.resolve_error(span, &format!(\"failed to resolve. {}\", msg))\n+                }\n+\n                 return None;\n             }\n         }\n@@ -2964,10 +2952,10 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                 }\n             } else {\n                 match this.resolve_module_path(root,\n-                                                &name_path[..],\n-                                                UseLexicalScope,\n-                                                span,\n-                                                PathSearch) {\n+                                               &name_path[..],\n+                                               UseLexicalScope,\n+                                               span,\n+                                               PathSearch) {\n                     Success((module, _)) => Some(module),\n                     _ => None\n                 }\n@@ -3203,8 +3191,8 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                                 false // Stop advancing\n                             });\n \n-                            if method_scope && &token::get_name(self.self_name)[..]\n-                                                                == path_name {\n+                            if method_scope &&\n+                               &token::get_name(special_names::self_)[..] == path_name {\n                                     self.resolve_error(\n                                         expr.span,\n                                         \"`self` is not available \\"}, {"sha": "939142cff1c32b6d7aba9d61bf675e7fc75c0cdd", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 93, "deletions": 56, "changes": 149, "blob_url": "https://github.com/rust-lang/rust/blob/6a3e8447eb9f592059161b6bbb74d1c14dbe445a/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a3e8447eb9f592059161b6bbb74d1c14dbe445a/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=6a3e8447eb9f592059161b6bbb74d1c14dbe445a", "patch": "@@ -140,13 +140,7 @@ pub trait AstConv<'tcx> {\n                     span: Span,\n                     _trait_ref: Rc<ty::TraitRef<'tcx>>,\n                     _item_name: ast::Name)\n-                    -> Ty<'tcx>\n-    {\n-        span_err!(self.tcx().sess, span, E0213,\n-            \"associated types are not accepted in this context\");\n-\n-        self.tcx().types.err\n-    }\n+                    -> Ty<'tcx>;\n }\n \n pub fn ast_region_to_region(tcx: &ty::ctxt, lifetime: &ast::Lifetime)\n@@ -924,9 +918,12 @@ fn ast_path_to_ty<'tcx>(\n         }\n     };\n \n-    let substs = ast_path_substs_for_ty(this, rscope,\n-                                        span, param_mode,\n-                                        &generics, item_segment);\n+    let substs = ast_path_substs_for_ty(this,\n+                                        rscope,\n+                                        span,\n+                                        param_mode,\n+                                        &generics,\n+                                        item_segment);\n \n     // FIXME(#12938): This is a hack until we have full support for DST.\n     if Some(did) == this.tcx().lang_items.owned_box() {\n@@ -1044,6 +1041,12 @@ fn report_ambiguous_associated_type(tcx: &ty::ctxt,\n               type_str, trait_str, name);\n }\n \n+// Create a type from a a path to an associated type.\n+// For a path A::B::C::D, ty and ty_path_def are the type and def for A::B::C\n+// and item_segment is the path segment for D. We return a type and a def for\n+// the whole path.\n+// Will fail except for T::A and Self::A; i.e., if ty/ty_path_def are not a type\n+// parameter or Self.\n fn associated_path_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n                                    span: Span,\n                                    ty: Ty<'tcx>,\n@@ -1052,35 +1055,43 @@ fn associated_path_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n                                    -> (Ty<'tcx>, def::Def)\n {\n     let tcx = this.tcx();\n-    check_path_args(tcx, slice::ref_slice(item_segment), NO_TPS | NO_REGIONS);\n     let assoc_name = item_segment.identifier.name;\n \n-    let is_param = match (&ty.sty, ty_path_def) {\n-        (&ty::ty_param(_), def::DefTyParam(..)) |\n-        (&ty::ty_param(_), def::DefSelfTy(_)) => true,\n-        _ => false\n-    };\n+    debug!(\"associated_path_def_to_ty: {}::{}\", ty.repr(tcx), token::get_name(assoc_name));\n \n-    let ty_param_node_id = if is_param {\n-        ty_path_def.local_node_id()\n-    } else {\n-        report_ambiguous_associated_type(\n-            tcx, span, &ty.user_string(tcx), \"Trait\", &token::get_name(assoc_name));\n-        return (tcx.types.err, ty_path_def);\n-    };\n+    check_path_args(tcx, slice::ref_slice(item_segment), NO_TPS | NO_REGIONS);\n+\n+    // Check that the path prefix given by ty/ty_path_def is a type parameter/Self.\n+    match (&ty.sty, ty_path_def) {\n+        (&ty::ty_param(_), def::DefTyParam(..)) |\n+        (&ty::ty_param(_), def::DefSelfTy(_)) => {}\n+        _ => {\n+            report_ambiguous_associated_type(tcx,\n+                                             span,\n+                                             &ty.user_string(tcx),\n+                                             \"Trait\",\n+                                             &token::get_name(assoc_name));\n+            return (tcx.types.err, ty_path_def);\n+        }\n+    }\n \n+    let ty_param_node_id = ty_path_def.local_node_id();\n     let ty_param_name = tcx.ty_param_defs.borrow().get(&ty_param_node_id).unwrap().name;\n \n     let bounds = match this.get_type_parameter_bounds(span, ty_param_node_id) {\n         Ok(v) => v,\n-        Err(ErrorReported) => { return (tcx.types.err, ty_path_def); }\n+        Err(ErrorReported) => {\n+            return (tcx.types.err, ty_path_def);\n+        }\n     };\n \n-    // ensure the super predicates and stop if we encountered an error\n+    // Ensure the super predicates and stop if we encountered an error.\n     if bounds.iter().any(|b| this.ensure_super_predicates(span, b.def_id()).is_err()) {\n         return (this.tcx().types.err, ty_path_def);\n     }\n \n+    // Check that there is exactly one way to find an associated type with the\n+    // correct name.\n     let mut suitable_bounds: Vec<_> =\n         traits::transitive_bounds(tcx, &bounds)\n         .filter(|b| this.trait_defines_associated_type_named(b.def_id(), assoc_name))\n@@ -1118,7 +1129,8 @@ fn associated_path_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n         // by type collection, which may be in progress at this point.\n         match this.tcx().map.expect_item(trait_did.node).node {\n             ast::ItemTrait(_, _, _, ref trait_items) => {\n-                let item = trait_items.iter().find(|i| i.ident.name == assoc_name)\n+                let item = trait_items.iter()\n+                                      .find(|i| i.ident.name == assoc_name)\n                                       .expect(\"missing associated type\");\n                 ast_util::local_def(item.id)\n             }\n@@ -1129,6 +1141,7 @@ fn associated_path_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n         let item = trait_items.iter().find(|i| i.name() == assoc_name);\n         item.expect(\"missing associated type\").def_id()\n     };\n+\n     (ty, def::DefAssociatedTy(trait_did, item_did))\n }\n \n@@ -1150,8 +1163,11 @@ fn qpath_to_ty<'tcx>(this: &AstConv<'tcx>,\n         ty\n     } else {\n         let path_str = ty::item_path_str(tcx, trait_def_id);\n-        report_ambiguous_associated_type(\n-            tcx, span, \"Type\", &path_str, &token::get_ident(item_segment.identifier));\n+        report_ambiguous_associated_type(tcx,\n+                                         span,\n+                                         \"Type\",\n+                                         &path_str,\n+                                         &token::get_ident(item_segment.identifier));\n         return tcx.types.err;\n     };\n \n@@ -1204,13 +1220,15 @@ pub fn ast_ty_arg_to_ty<'tcx>(this: &AstConv<'tcx>,\n     }\n }\n \n+// Note that both base_segments and assoc_segments may be empty, although not at\n+// the same time.\n pub fn finish_resolving_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n                                         rscope: &RegionScope,\n                                         span: Span,\n                                         param_mode: PathParamMode,\n-                                        def: &mut def::Def,\n+                                        def: &def::Def,\n                                         opt_self_ty: Option<Ty<'tcx>>,\n-                                        segments: &[ast::PathSegment],\n+                                        base_segments: &[ast::PathSegment],\n                                         assoc_segments: &[ast::PathSegment])\n                                         -> Ty<'tcx> {\n     let tcx = this.tcx();\n@@ -1226,52 +1244,64 @@ pub fn finish_resolving_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n                                                           span,\n                                                           param_mode,\n                                                           trait_def_id,\n-                                                          segments.last().unwrap(),\n+                                                          base_segments.last().unwrap(),\n                                                           &mut projection_bounds);\n \n-            check_path_args(tcx, segments.init(), NO_TPS | NO_REGIONS);\n-            trait_ref_to_object_type(this, rscope, span, trait_ref,\n-                                     projection_bounds, &[])\n+            check_path_args(tcx, base_segments.init(), NO_TPS | NO_REGIONS);\n+            trait_ref_to_object_type(this,\n+                                     rscope,\n+                                     span,\n+                                     trait_ref,\n+                                     projection_bounds,\n+                                     &[])\n         }\n         def::DefTy(did, _) | def::DefStruct(did) => {\n-            check_path_args(tcx, segments.init(), NO_TPS | NO_REGIONS);\n+            check_path_args(tcx, base_segments.init(), NO_TPS | NO_REGIONS);\n             ast_path_to_ty(this, rscope, span,\n                            param_mode, did,\n-                           segments.last().unwrap())\n+                           base_segments.last().unwrap())\n         }\n         def::DefTyParam(space, index, _, name) => {\n-            check_path_args(tcx, segments, NO_TPS | NO_REGIONS);\n+            check_path_args(tcx, base_segments, NO_TPS | NO_REGIONS);\n             ty::mk_param(tcx, space, index, name)\n         }\n         def::DefSelfTy(_) => {\n-            // n.b.: resolve guarantees that the this type only appears in a\n+            // N.b.: resolve guarantees that the this type only appears in a\n             // trait, which we rely upon in various places when creating\n-            // substs\n-            check_path_args(tcx, segments, NO_TPS | NO_REGIONS);\n+            // substs.\n+            check_path_args(tcx, base_segments, NO_TPS | NO_REGIONS);\n             ty::mk_self_type(tcx)\n         }\n         def::DefAssociatedTy(trait_did, _) => {\n-            check_path_args(tcx, &segments[..segments.len()-2], NO_TPS | NO_REGIONS);\n-            qpath_to_ty(this, rscope, span, param_mode,\n-                        opt_self_ty, trait_did,\n-                        &segments[segments.len()-2],\n-                        segments.last().unwrap())\n+            check_path_args(tcx, &base_segments[..base_segments.len()-2], NO_TPS | NO_REGIONS);\n+            qpath_to_ty(this,\n+                        rscope,\n+                        span,\n+                        param_mode,\n+                        opt_self_ty,\n+                        trait_did,\n+                        &base_segments[base_segments.len()-2],\n+                        base_segments.last().unwrap())\n         }\n         def::DefMod(id) => {\n             // Used as sentinel by callers to indicate the `<T>::A::B::C` form.\n             // FIXME(#22519) This part of the resolution logic should be\n             // avoided entirely for that form, once we stop needed a Def\n             // for `associated_path_def_to_ty`.\n-            if segments.is_empty() {\n-                opt_self_ty.expect(\"missing T in <T>::a::b::c\")\n-            } else {\n-                span_err!(tcx.sess, span, E0247, \"found module name used as a type: {}\",\n+\n+            if !base_segments.is_empty() {\n+                span_err!(tcx.sess,\n+                          span,\n+                          E0247,\n+                          \"found module name used as a type: {}\",\n                           tcx.map.node_to_string(id.node));\n                 return this.tcx().types.err;\n             }\n+\n+            opt_self_ty.expect(\"missing T in <T>::a::b::c\")\n         }\n         def::DefPrimTy(prim_ty) => {\n-            prim_ty_to_ty(tcx, segments, prim_ty)\n+            prim_ty_to_ty(tcx, base_segments, prim_ty)\n         }\n         _ => {\n             span_err!(tcx.sess, span, E0248,\n@@ -1282,15 +1312,19 @@ pub fn finish_resolving_def_to_ty<'tcx>(this: &AstConv<'tcx>,\n \n     // If any associated type segments remain, attempt to resolve them.\n     let mut ty = base_ty;\n+    let mut def = *def;\n     for segment in assoc_segments {\n         if ty.sty == ty::ty_err {\n             break;\n         }\n         // This is pretty bad (it will fail except for T::A and Self::A).\n-        let (a_ty, a_def) = associated_path_def_to_ty(this, span,\n-                                                      ty, *def, segment);\n+        let (a_ty, a_def) = associated_path_def_to_ty(this,\n+                                                      span,\n+                                                      ty,\n+                                                      def,\n+                                                      segment);\n         ty = a_ty;\n-        *def = a_def;\n+        def = a_def;\n     }\n     ty\n }\n@@ -1378,13 +1412,16 @@ pub fn ast_ty_to_ty<'tcx>(this: &AstConv<'tcx>,\n                 tcx.sess.span_bug(ast_ty.span,\n                                   &format!(\"unbound path {}\", ast_ty.repr(tcx)))\n             };\n-            let mut def = path_res.base_def;\n+            let def = path_res.base_def;\n             let base_ty_end = path.segments.len() - path_res.depth;\n             let opt_self_ty = maybe_qself.as_ref().map(|qself| {\n                 ast_ty_to_ty(this, rscope, &qself.ty)\n             });\n-            let ty = finish_resolving_def_to_ty(this, rscope, ast_ty.span,\n-                                                PathParamMode::Explicit, &mut def,\n+            let ty = finish_resolving_def_to_ty(this,\n+                                                rscope,\n+                                                ast_ty.span,\n+                                                PathParamMode::Explicit,\n+                                                &def,\n                                                 opt_self_ty,\n                                                 &path.segments[..base_ty_end],\n                                                 &path.segments[base_ty_end..]);"}, {"sha": "b9a0070f205be88a8c13ee04790774564fed509c", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6a3e8447eb9f592059161b6bbb74d1c14dbe445a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a3e8447eb9f592059161b6bbb74d1c14dbe445a/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=6a3e8447eb9f592059161b6bbb74d1c14dbe445a", "patch": "@@ -3329,7 +3329,7 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n                                 &format!(\"unbound path {}\", expr.repr(tcx)))\n           };\n \n-          let mut def = path_res.base_def;\n+          let def = path_res.base_def;\n           if path_res.depth == 0 {\n               let (scheme, predicates) =\n                   type_scheme_and_predicates_for_def(fcx, expr.span, def);\n@@ -3339,9 +3339,11 @@ fn check_expr_with_unifier<'a, 'tcx, F>(fcx: &FnCtxt<'a, 'tcx>,\n           } else {\n               let ty_segments = path.segments.init();\n               let base_ty_end = path.segments.len() - path_res.depth;\n-              let ty = astconv::finish_resolving_def_to_ty(fcx, fcx, expr.span,\n+              let ty = astconv::finish_resolving_def_to_ty(fcx,\n+                                                           fcx,\n+                                                           expr.span,\n                                                            PathParamMode::Optional,\n-                                                           &mut def,\n+                                                           &def,\n                                                            opt_self_ty,\n                                                            &ty_segments[..base_ty_end],\n                                                            &ty_segments[base_ty_end..]);"}, {"sha": "c2f323f98afc56d5a3808ac1db1bdf3ff1b0482d", "filename": "src/libsyntax/print/pprust.rs", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/6a3e8447eb9f592059161b6bbb74d1c14dbe445a/src%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a3e8447eb9f592059161b6bbb74d1c14dbe445a/src%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fprint%2Fpprust.rs?ref=6a3e8447eb9f592059161b6bbb74d1c14dbe445a", "patch": "@@ -37,6 +37,7 @@ pub enum AnnNode<'a> {\n     NodeName(&'a ast::Name),\n     NodeBlock(&'a ast::Block),\n     NodeItem(&'a ast::Item),\n+    NodeSubItem(ast::NodeId),\n     NodeExpr(&'a ast::Expr),\n     NodePat(&'a ast::Pat),\n }\n@@ -1264,6 +1265,7 @@ impl<'a> State<'a> {\n \n     pub fn print_trait_item(&mut self, ti: &ast::TraitItem)\n                             -> io::Result<()> {\n+        try!(self.ann.pre(self, NodeSubItem(ti.id)));\n         try!(self.hardbreak_if_not_bol());\n         try!(self.maybe_print_comment(ti.span.lo));\n         try!(self.print_outer_attributes(&ti.attrs));\n@@ -1275,19 +1277,21 @@ impl<'a> State<'a> {\n                 try!(self.print_method_sig(ti.ident, sig, ast::Inherited));\n                 if let Some(ref body) = *body {\n                     try!(self.nbsp());\n-                    self.print_block_with_attrs(body, &ti.attrs)\n+                    try!(self.print_block_with_attrs(body, &ti.attrs));\n                 } else {\n-                    word(&mut self.s, \";\")\n+                    try!(word(&mut self.s, \";\"));\n                 }\n             }\n             ast::TypeTraitItem(ref bounds, ref default) => {\n-                self.print_associated_type(ti.ident, Some(bounds),\n-                                           default.as_ref().map(|ty| &**ty))\n+                try!(self.print_associated_type(ti.ident, Some(bounds),\n+                                                default.as_ref().map(|ty| &**ty)));\n             }\n         }\n+        self.ann.post(self, NodeSubItem(ti.id))\n     }\n \n     pub fn print_impl_item(&mut self, ii: &ast::ImplItem) -> io::Result<()> {\n+        try!(self.ann.pre(self, NodeSubItem(ii.id)));\n         try!(self.hardbreak_if_not_bol());\n         try!(self.maybe_print_comment(ii.span.lo));\n         try!(self.print_outer_attributes(&ii.attrs));\n@@ -1296,10 +1300,10 @@ impl<'a> State<'a> {\n                 try!(self.head(\"\"));\n                 try!(self.print_method_sig(ii.ident, sig, ii.vis));\n                 try!(self.nbsp());\n-                self.print_block_with_attrs(body, &ii.attrs)\n+                try!(self.print_block_with_attrs(body, &ii.attrs));\n             }\n             ast::TypeImplItem(ref ty) => {\n-                self.print_associated_type(ii.ident, None, Some(ty))\n+                try!(self.print_associated_type(ii.ident, None, Some(ty)));\n             }\n             ast::MacImplItem(codemap::Spanned { node: ast::MacInvocTT(ref pth, ref tts, _),\n                                                 ..}) => {\n@@ -1311,9 +1315,10 @@ impl<'a> State<'a> {\n                 try!(self.print_tts(&tts[..]));\n                 try!(self.pclose());\n                 try!(word(&mut self.s, \";\"));\n-                self.end()\n+                try!(self.end())\n             }\n         }\n+        self.ann.post(self, NodeSubItem(ii.id))\n     }\n \n     pub fn print_outer_attributes(&mut self,"}]}