{"sha": "c7de289e1c8d24bd55aaa33813e509920a00c364", "node_id": "C_kwDOAAsO6NoAKGM3ZGUyODllMWM4ZDI0YmQ1NWFhYTMzODEzZTUwOTkyMGEwMGMzNjQ", "commit": {"author": {"name": "Aria Beingessner", "email": "a.beingessner@gmail.com", "date": "2022-03-22T05:24:55Z"}, "committer": {"name": "Aria Beingessner", "email": "a.beingessner@gmail.com", "date": "2022-03-30T00:18:21Z"}, "message": "Make the stdlib largely conform to strict provenance.\n\nSome things like the unwinders and system APIs are not fully conformant,\nthis only covers a lot of low-hanging fruit.", "tree": {"sha": "b8dcd314558cc77fe1353c890c39c7026b7414b8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b8dcd314558cc77fe1353c890c39c7026b7414b8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c7de289e1c8d24bd55aaa33813e509920a00c364", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c7de289e1c8d24bd55aaa33813e509920a00c364", "html_url": "https://github.com/rust-lang/rust/commit/c7de289e1c8d24bd55aaa33813e509920a00c364", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c7de289e1c8d24bd55aaa33813e509920a00c364/comments", "author": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Gankra", "id": 1136864, "node_id": "MDQ6VXNlcjExMzY4NjQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1136864?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Gankra", "html_url": "https://github.com/Gankra", "followers_url": "https://api.github.com/users/Gankra/followers", "following_url": "https://api.github.com/users/Gankra/following{/other_user}", "gists_url": "https://api.github.com/users/Gankra/gists{/gist_id}", "starred_url": "https://api.github.com/users/Gankra/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Gankra/subscriptions", "organizations_url": "https://api.github.com/users/Gankra/orgs", "repos_url": "https://api.github.com/users/Gankra/repos", "events_url": "https://api.github.com/users/Gankra/events{/privacy}", "received_events_url": "https://api.github.com/users/Gankra/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5167b6891ccf05aa7a2191675e6c3da95d84374a", "url": "https://api.github.com/repos/rust-lang/rust/commits/5167b6891ccf05aa7a2191675e6c3da95d84374a", "html_url": "https://github.com/rust-lang/rust/commit/5167b6891ccf05aa7a2191675e6c3da95d84374a"}], "stats": {"total": 181, "additions": 100, "deletions": 81}, "files": [{"sha": "7e90d77b8f289b124e997e4bf0afe011116b4f2d", "filename": "library/alloc/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c7de289e1c8d24bd55aaa33813e509920a00c364/library%2Falloc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7de289e1c8d24bd55aaa33813e509920a00c364/library%2Falloc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Flib.rs?ref=c7de289e1c8d24bd55aaa33813e509920a00c364", "patch": "@@ -158,6 +158,7 @@\n #![feature(rustc_allow_const_fn_unstable)]\n #![feature(rustc_attrs)]\n #![feature(staged_api)]\n+#![feature(strict_provenance)]\n #![cfg_attr(test, feature(test))]\n #![feature(unboxed_closures)]\n #![feature(unsized_fn_params)]"}, {"sha": "0b57c36247e431a86b8ea947bfa5f1e65ae1e722", "filename": "library/alloc/src/rc.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/c7de289e1c8d24bd55aaa33813e509920a00c364/library%2Falloc%2Fsrc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7de289e1c8d24bd55aaa33813e509920a00c364/library%2Falloc%2Fsrc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Frc.rs?ref=c7de289e1c8d24bd55aaa33813e509920a00c364", "patch": "@@ -2115,13 +2115,12 @@ impl<T> Weak<T> {\n     #[rustc_const_unstable(feature = \"const_weak_new\", issue = \"95091\", reason = \"recently added\")]\n     #[must_use]\n     pub const fn new() -> Weak<T> {\n-        Weak { ptr: unsafe { NonNull::new_unchecked(usize::MAX as *mut RcBox<T>) } }\n+        Weak { ptr: unsafe { NonNull::new_unchecked(ptr::invalid_mut::<RcBox<T>>(usize::MAX)) } }\n     }\n }\n \n pub(crate) fn is_dangling<T: ?Sized>(ptr: *mut T) -> bool {\n-    let address = ptr as *mut () as usize;\n-    address == usize::MAX\n+    (ptr as *mut ()).addr() == usize::MAX\n }\n \n /// Helper type to allow accessing the reference counts without"}, {"sha": "7c892f03bfb7828cd12155154cc977ba19b36667", "filename": "library/alloc/src/slice.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7de289e1c8d24bd55aaa33813e509920a00c364/library%2Falloc%2Fsrc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7de289e1c8d24bd55aaa33813e509920a00c364/library%2Falloc%2Fsrc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fslice.rs?ref=c7de289e1c8d24bd55aaa33813e509920a00c364", "patch": "@@ -1044,7 +1044,7 @@ where\n     impl<T> Drop for MergeHole<T> {\n         fn drop(&mut self) {\n             // `T` is not a zero-sized type, so it's okay to divide by its size.\n-            let len = (self.end as usize - self.start as usize) / mem::size_of::<T>();\n+            let len = (self.end.addr() - self.start.addr()) / mem::size_of::<T>();\n             unsafe {\n                 ptr::copy_nonoverlapping(self.start, self.dest, len);\n             }"}, {"sha": "f8b4d46ac105dec22f53adac86078c7aa87c2b19", "filename": "library/alloc/src/sync.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7de289e1c8d24bd55aaa33813e509920a00c364/library%2Falloc%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7de289e1c8d24bd55aaa33813e509920a00c364/library%2Falloc%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fsync.rs?ref=c7de289e1c8d24bd55aaa33813e509920a00c364", "patch": "@@ -1746,7 +1746,7 @@ impl<T> Weak<T> {\n     #[rustc_const_unstable(feature = \"const_weak_new\", issue = \"95091\", reason = \"recently added\")]\n     #[must_use]\n     pub const fn new() -> Weak<T> {\n-        Weak { ptr: unsafe { NonNull::new_unchecked(usize::MAX as *mut ArcInner<T>) } }\n+        Weak { ptr: unsafe { NonNull::new_unchecked(ptr::invalid_mut::<ArcInner<T>>(usize::MAX)) } }\n     }\n }\n "}, {"sha": "cc6dfb0e330176b43a2455d89e949076546456a7", "filename": "library/alloc/src/vec/into_iter.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7de289e1c8d24bd55aaa33813e509920a00c364/library%2Falloc%2Fsrc%2Fvec%2Finto_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7de289e1c8d24bd55aaa33813e509920a00c364/library%2Falloc%2Fsrc%2Fvec%2Finto_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fvec%2Finto_iter.rs?ref=c7de289e1c8d24bd55aaa33813e509920a00c364", "patch": "@@ -159,7 +159,7 @@ impl<T, A: Allocator> Iterator for IntoIter<T, A> {\n     #[inline]\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         let exact = if mem::size_of::<T>() == 0 {\n-            (self.end as usize).wrapping_sub(self.ptr as usize)\n+            self.end.addr().wrapping_sub(self.ptr.addr())\n         } else {\n             unsafe { self.end.offset_from(self.ptr) as usize }\n         };"}, {"sha": "0639d6eed62a540cec06f536c1061158ce01becc", "filename": "library/core/src/alloc/layout.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7de289e1c8d24bd55aaa33813e509920a00c364/library%2Fcore%2Fsrc%2Falloc%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7de289e1c8d24bd55aaa33813e509920a00c364/library%2Fcore%2Fsrc%2Falloc%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Falloc%2Flayout.rs?ref=c7de289e1c8d24bd55aaa33813e509920a00c364", "patch": "@@ -194,7 +194,7 @@ impl Layout {\n     #[inline]\n     pub const fn dangling(&self) -> NonNull<u8> {\n         // SAFETY: align is guaranteed to be non-zero\n-        unsafe { NonNull::new_unchecked(self.align() as *mut u8) }\n+        unsafe { NonNull::new_unchecked(crate::ptr::invalid_mut::<u8>(self.align())) }\n     }\n \n     /// Creates a layout describing the record that can hold a value"}, {"sha": "0e2e869a920eeba148e86c08976d5b66eed2a7a0", "filename": "library/core/src/fmt/mod.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c7de289e1c8d24bd55aaa33813e509920a00c364/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7de289e1c8d24bd55aaa33813e509920a00c364/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs?ref=c7de289e1c8d24bd55aaa33813e509920a00c364", "patch": "@@ -352,7 +352,11 @@ impl<'a> ArgumentV1<'a> {\n     }\n \n     fn as_usize(&self) -> Option<usize> {\n-        if self.formatter as usize == USIZE_MARKER as usize {\n+        // We are type punning a bit here: USIZE_MARKER only takes an &usize but\n+        // formatter takes an &Opaque. Rust understandably doesn't think we should compare\n+        // the function pointers if they don't have the same signature, so we cast to\n+        // pointers to convince it that we know what we're doing.\n+        if self.formatter as *mut u8 == USIZE_MARKER as *mut u8 {\n             // SAFETY: The `formatter` field is only set to USIZE_MARKER if\n             // the value is a usize, so this is safe\n             Some(unsafe { *(self.value as *const _ as *const usize) })\n@@ -2246,7 +2250,7 @@ impl<T: ?Sized> Pointer for *const T {\n             }\n             f.flags |= 1 << (FlagV1::Alternate as u32);\n \n-            let ret = LowerHex::fmt(&(ptr as usize), f);\n+            let ret = LowerHex::fmt(&(ptr.addr()), f);\n \n             f.width = old_width;\n             f.flags = old_flags;"}, {"sha": "45c9df0c930b900baca7c161504ea2b0f794703a", "filename": "library/core/src/hash/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c7de289e1c8d24bd55aaa33813e509920a00c364/library%2Fcore%2Fsrc%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7de289e1c8d24bd55aaa33813e509920a00c364/library%2Fcore%2Fsrc%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fhash%2Fmod.rs?ref=c7de289e1c8d24bd55aaa33813e509920a00c364", "patch": "@@ -793,7 +793,7 @@ mod impls {\n         #[inline]\n         fn hash<H: Hasher>(&self, state: &mut H) {\n             let (address, metadata) = self.to_raw_parts();\n-            state.write_usize(address as usize);\n+            state.write_usize(address.addr());\n             metadata.hash(state);\n         }\n     }\n@@ -803,7 +803,7 @@ mod impls {\n         #[inline]\n         fn hash<H: Hasher>(&self, state: &mut H) {\n             let (address, metadata) = self.to_raw_parts();\n-            state.write_usize(address as usize);\n+            state.write_usize(address.addr());\n             metadata.hash(state);\n         }\n     }"}, {"sha": "8ad4317c145ac7d78bbf6ea46b18dfd64639253a", "filename": "library/core/src/intrinsics.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c7de289e1c8d24bd55aaa33813e509920a00c364/library%2Fcore%2Fsrc%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7de289e1c8d24bd55aaa33813e509920a00c364/library%2Fcore%2Fsrc%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fintrinsics.rs?ref=c7de289e1c8d24bd55aaa33813e509920a00c364", "patch": "@@ -1972,15 +1972,15 @@ extern \"rust-intrinsic\" {\n /// Checks whether `ptr` is properly aligned with respect to\n /// `align_of::<T>()`.\n pub(crate) fn is_aligned_and_not_null<T>(ptr: *const T) -> bool {\n-    !ptr.is_null() && ptr as usize % mem::align_of::<T>() == 0\n+    !ptr.is_null() && ptr.addr() % mem::align_of::<T>() == 0\n }\n \n /// Checks whether the regions of memory starting at `src` and `dst` of size\n /// `count * size_of::<T>()` do *not* overlap.\n #[cfg(debug_assertions)]\n pub(crate) fn is_nonoverlapping<T>(src: *const T, dst: *const T, count: usize) -> bool {\n-    let src_usize = src as usize;\n-    let dst_usize = dst as usize;\n+    let src_usize = src.addr();\n+    let dst_usize = dst.addr();\n     let size = mem::size_of::<T>().checked_mul(count).unwrap();\n     let diff = if src_usize > dst_usize { src_usize - dst_usize } else { dst_usize - src_usize };\n     // If the absolute distance between the ptrs is at least as big as the size of the buffer,"}, {"sha": "c1b19895f006cf25af904765e4f7a5b9975b7ed4", "filename": "library/core/src/ptr/non_null.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c7de289e1c8d24bd55aaa33813e509920a00c364/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7de289e1c8d24bd55aaa33813e509920a00c364/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fnon_null.rs?ref=c7de289e1c8d24bd55aaa33813e509920a00c364", "patch": "@@ -90,7 +90,7 @@ impl<T: Sized> NonNull<T> {\n         // to a *mut T. Therefore, `ptr` is not null and the conditions for\n         // calling new_unchecked() are respected.\n         unsafe {\n-            let ptr = mem::align_of::<T>() as *mut T;\n+            let ptr = crate::ptr::invalid_mut::<T>(mem::align_of::<T>());\n             NonNull::new_unchecked(ptr)\n         }\n     }\n@@ -469,7 +469,7 @@ impl<T> NonNull<[T]> {\n     /// use std::ptr::NonNull;\n     ///\n     /// let slice: NonNull<[i8]> = NonNull::slice_from_raw_parts(NonNull::dangling(), 3);\n-    /// assert_eq!(slice.as_non_null_ptr(), NonNull::new(1 as *mut i8).unwrap());\n+    /// assert_eq!(slice.as_non_null_ptr(), NonNull::<i8>::dangling());\n     /// ```\n     #[inline]\n     #[must_use]\n@@ -489,7 +489,7 @@ impl<T> NonNull<[T]> {\n     /// use std::ptr::NonNull;\n     ///\n     /// let slice: NonNull<[i8]> = NonNull::slice_from_raw_parts(NonNull::dangling(), 3);\n-    /// assert_eq!(slice.as_mut_ptr(), 1 as *mut i8);\n+    /// assert_eq!(slice.as_mut_ptr(), NonNull::<i8>::dangling().as_ptr());\n     /// ```\n     #[inline]\n     #[must_use]"}, {"sha": "29398cbeb238dbeee8bd49f0e9285bd02e7792af", "filename": "library/core/src/ptr/unique.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7de289e1c8d24bd55aaa33813e509920a00c364/library%2Fcore%2Fsrc%2Fptr%2Funique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7de289e1c8d24bd55aaa33813e509920a00c364/library%2Fcore%2Fsrc%2Fptr%2Funique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Funique.rs?ref=c7de289e1c8d24bd55aaa33813e509920a00c364", "patch": "@@ -73,7 +73,7 @@ impl<T: Sized> Unique<T> {\n     pub const fn dangling() -> Self {\n         // SAFETY: mem::align_of() returns a valid, non-null pointer. The\n         // conditions to call new_unchecked() are thus respected.\n-        unsafe { Unique::new_unchecked(mem::align_of::<T>() as *mut T) }\n+        unsafe { Unique::new_unchecked(crate::ptr::invalid_mut::<T>(mem::align_of::<T>())) }\n     }\n }\n "}, {"sha": "63d761d3c02d6579c13c21ea65feb91267333e2d", "filename": "library/core/src/slice/ascii.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c7de289e1c8d24bd55aaa33813e509920a00c364/library%2Fcore%2Fsrc%2Fslice%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7de289e1c8d24bd55aaa33813e509920a00c364/library%2Fcore%2Fsrc%2Fslice%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fascii.rs?ref=c7de289e1c8d24bd55aaa33813e509920a00c364", "patch": "@@ -294,17 +294,17 @@ fn is_ascii(s: &[u8]) -> bool {\n     // Paranoia check about alignment, since we're about to do a bunch of\n     // unaligned loads. In practice this should be impossible barring a bug in\n     // `align_offset` though.\n-    debug_assert_eq!((word_ptr as usize) % mem::align_of::<usize>(), 0);\n+    debug_assert_eq!((word_ptr.addr()) % mem::align_of::<usize>(), 0);\n \n     // Read subsequent words until the last aligned word, excluding the last\n     // aligned word by itself to be done in tail check later, to ensure that\n     // tail is always one `usize` at most to extra branch `byte_pos == len`.\n     while byte_pos < len - USIZE_SIZE {\n         debug_assert!(\n             // Sanity check that the read is in bounds\n-            (word_ptr as usize + USIZE_SIZE) <= (start.wrapping_add(len) as usize) &&\n+            (word_ptr.addr() + USIZE_SIZE) <= (start.wrapping_add(len).addr()) &&\n             // And that our assumptions about `byte_pos` hold.\n-            (word_ptr as usize) - (start as usize) == byte_pos\n+            (word_ptr.addr()) - (start.addr()) == byte_pos\n         );\n \n         // SAFETY: We know `word_ptr` is properly aligned (because of"}, {"sha": "96ead49dd6aaf626a1eeb41ea3508d1ed288b39c", "filename": "library/core/src/slice/iter/macros.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c7de289e1c8d24bd55aaa33813e509920a00c364/library%2Fcore%2Fsrc%2Fslice%2Fiter%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7de289e1c8d24bd55aaa33813e509920a00c364/library%2Fcore%2Fsrc%2Fslice%2Fiter%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fiter%2Fmacros.rs?ref=c7de289e1c8d24bd55aaa33813e509920a00c364", "patch": "@@ -20,13 +20,13 @@ macro_rules! len {\n         if size == 0 {\n             // This _cannot_ use `unchecked_sub` because we depend on wrapping\n             // to represent the length of long ZST slice iterators.\n-            ($self.end as usize).wrapping_sub(start.as_ptr() as usize)\n+            ($self.end.addr()).wrapping_sub(start.as_ptr().addr())\n         } else {\n             // We know that `start <= end`, so can do better than `offset_from`,\n             // which needs to deal in signed.  By setting appropriate flags here\n             // we can tell LLVM this, which helps it remove bounds checks.\n             // SAFETY: By the type invariant, `start <= end`\n-            let diff = unsafe { unchecked_sub($self.end as usize, start.as_ptr() as usize) };\n+            let diff = unsafe { unchecked_sub($self.end.addr(), start.as_ptr().addr()) };\n             // By also telling LLVM that the pointers are apart by an exact\n             // multiple of the type size, it can optimize `len() == 0` down to\n             // `start == end` instead of `(end - start) < size`."}, {"sha": "5cf08b5740e82d9946c45afac29049c000a16277", "filename": "library/core/src/slice/sort.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7de289e1c8d24bd55aaa33813e509920a00c364/library%2Fcore%2Fsrc%2Fslice%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7de289e1c8d24bd55aaa33813e509920a00c364/library%2Fcore%2Fsrc%2Fslice%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fsort.rs?ref=c7de289e1c8d24bd55aaa33813e509920a00c364", "patch": "@@ -269,7 +269,7 @@ where\n     // Returns the number of elements between pointers `l` (inclusive) and `r` (exclusive).\n     fn width<T>(l: *mut T, r: *mut T) -> usize {\n         assert!(mem::size_of::<T>() > 0);\n-        (r as usize - l as usize) / mem::size_of::<T>()\n+        (r.addr() - l.addr()) / mem::size_of::<T>()\n     }\n \n     loop {"}, {"sha": "fded482095a4626b717f2ca3abe52bc6b293d1a3", "filename": "library/std/src/backtrace.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c7de289e1c8d24bd55aaa33813e509920a00c364/library%2Fstd%2Fsrc%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7de289e1c8d24bd55aaa33813e509920a00c364/library%2Fstd%2Fsrc%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fbacktrace.rs?ref=c7de289e1c8d24bd55aaa33813e509920a00c364", "patch": "@@ -293,7 +293,7 @@ impl Backtrace {\n         if !Backtrace::enabled() {\n             return Backtrace { inner: Inner::Disabled };\n         }\n-        Backtrace::create(Backtrace::capture as usize)\n+        Backtrace::create((Backtrace::capture as *mut ()).addr())\n     }\n \n     /// Forcibly captures a full backtrace, regardless of environment variable\n@@ -308,7 +308,7 @@ impl Backtrace {\n     /// parts of code.\n     #[inline(never)] // want to make sure there's a frame here to remove\n     pub fn force_capture() -> Backtrace {\n-        Backtrace::create(Backtrace::force_capture as usize)\n+        Backtrace::create((Backtrace::force_capture as *mut ()).addr())\n     }\n \n     /// Forcibly captures a disabled backtrace, regardless of environment\n@@ -330,7 +330,7 @@ impl Backtrace {\n                     frame: RawFrame::Actual(frame.clone()),\n                     symbols: Vec::new(),\n                 });\n-                if frame.symbol_address() as usize == ip && actual_start.is_none() {\n+                if frame.symbol_address().addr() == ip && actual_start.is_none() {\n                     actual_start = Some(frames.len());\n                 }\n                 true\n@@ -493,7 +493,7 @@ impl RawFrame {\n         match self {\n             RawFrame::Actual(frame) => frame.ip(),\n             #[cfg(test)]\n-            RawFrame::Fake => 1 as *mut c_void,\n+            RawFrame::Fake => ptr::invalid_mut(1),\n         }\n     }\n }"}, {"sha": "7cc1c701064c582c161d3cff43d304bc0e66693b", "filename": "library/std/src/io/error/repr_bitpacked.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/c7de289e1c8d24bd55aaa33813e509920a00c364/library%2Fstd%2Fsrc%2Fio%2Ferror%2Frepr_bitpacked.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7de289e1c8d24bd55aaa33813e509920a00c364/library%2Fstd%2Fsrc%2Fio%2Ferror%2Frepr_bitpacked.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fio%2Ferror%2Frepr_bitpacked.rs?ref=c7de289e1c8d24bd55aaa33813e509920a00c364", "patch": "@@ -106,7 +106,7 @@ use super::{Custom, ErrorData, ErrorKind, SimpleMessage};\n use alloc::boxed::Box;\n use core::marker::PhantomData;\n use core::mem::{align_of, size_of};\n-use core::ptr::NonNull;\n+use core::ptr::{self, NonNull};\n \n // The 2 least-significant bits are used as tag.\n const TAG_MASK: usize = 0b11;\n@@ -136,7 +136,7 @@ impl Repr {\n         let p = Box::into_raw(b).cast::<u8>();\n         // Should only be possible if an allocator handed out a pointer with\n         // wrong alignment.\n-        debug_assert_eq!((p as usize & TAG_MASK), 0);\n+        debug_assert_eq!((p.addr() & TAG_MASK), 0);\n         // Note: We know `TAG_CUSTOM <= size_of::<Custom>()` (static_assert at\n         // end of file), and both the start and end of the expression must be\n         // valid without address space wraparound due to `Box`'s semantics.\n@@ -166,7 +166,7 @@ impl Repr {\n     pub(super) fn new_os(code: i32) -> Self {\n         let utagged = ((code as usize) << 32) | TAG_OS;\n         // Safety: `TAG_OS` is not zero, so the result of the `|` is not 0.\n-        let res = Self(unsafe { NonNull::new_unchecked(utagged as *mut ()) }, PhantomData);\n+        let res = Self(unsafe { NonNull::new_unchecked(ptr::invalid_mut(utagged)) }, PhantomData);\n         // quickly smoke-check we encoded the right thing (This generally will\n         // only run in libstd's tests, unless the user uses -Zbuild-std)\n         debug_assert!(\n@@ -180,7 +180,7 @@ impl Repr {\n     pub(super) fn new_simple(kind: ErrorKind) -> Self {\n         let utagged = ((kind as usize) << 32) | TAG_SIMPLE;\n         // Safety: `TAG_SIMPLE` is not zero, so the result of the `|` is not 0.\n-        let res = Self(unsafe { NonNull::new_unchecked(utagged as *mut ()) }, PhantomData);\n+        let res = Self(unsafe { NonNull::new_unchecked(ptr::invalid_mut(utagged)) }, PhantomData);\n         // quickly smoke-check we encoded the right thing (This generally will\n         // only run in libstd's tests, unless the user uses -Zbuild-std)\n         debug_assert!(\n@@ -238,7 +238,7 @@ unsafe fn decode_repr<C, F>(ptr: NonNull<()>, make_custom: F) -> ErrorData<C>\n where\n     F: FnOnce(*mut Custom) -> C,\n {\n-    let bits = ptr.as_ptr() as usize;\n+    let bits = ptr.as_ptr().addr();\n     match bits & TAG_MASK {\n         TAG_OS => {\n             let code = ((bits as i64) >> 32) as i32;"}, {"sha": "133ced5f26cfbdbf5df83d3cd011929503f925ee", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c7de289e1c8d24bd55aaa33813e509920a00c364/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7de289e1c8d24bd55aaa33813e509920a00c364/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=c7de289e1c8d24bd55aaa33813e509920a00c364", "patch": "@@ -275,6 +275,7 @@\n #![feature(extend_one)]\n #![feature(float_minimum_maximum)]\n #![feature(format_args_nl)]\n+#![feature(strict_provenance)]\n #![feature(get_mut_unchecked)]\n #![feature(hashmap_internals)]\n #![feature(int_error_internals)]"}, {"sha": "ee30cc8be6b57c442c6114d9918aa9bbdc66d0e5", "filename": "library/std/src/os/windows/io/handle.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/c7de289e1c8d24bd55aaa33813e509920a00c364/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fhandle.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7de289e1c8d24bd55aaa33813e509920a00c364/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fhandle.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fhandle.rs?ref=c7de289e1c8d24bd55aaa33813e509920a00c364", "patch": "@@ -9,6 +9,7 @@ use crate::fs;\n use crate::io;\n use crate::marker::PhantomData;\n use crate::mem::forget;\n+use crate::ptr;\n use crate::sys::c;\n use crate::sys::cvt;\n use crate::sys_common::{AsInner, FromInner, IntoInner};\n@@ -182,7 +183,7 @@ impl OwnedHandle {\n             return unsafe { Ok(Self::from_raw_handle(handle)) };\n         }\n \n-        let mut ret = 0 as c::HANDLE;\n+        let mut ret = ptr::null_mut();\n         cvt(unsafe {\n             let cur_proc = c::GetCurrentProcess();\n             c::DuplicateHandle("}, {"sha": "db93cd15d4ab77abe708d1a063b6e63cfadeb8f1", "filename": "library/std/src/os/windows/io/socket.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/c7de289e1c8d24bd55aaa33813e509920a00c364/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fsocket.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7de289e1c8d24bd55aaa33813e509920a00c364/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fsocket.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Fwindows%2Fio%2Fsocket.rs?ref=c7de289e1c8d24bd55aaa33813e509920a00c364", "patch": "@@ -129,6 +129,7 @@ impl OwnedSocket {\n         }\n     }\n \n+    // FIXME(strict_provenance_magic): we defined RawSocket to be a u64 ;-;\n     #[cfg(not(target_vendor = \"uwp\"))]\n     pub(crate) fn set_no_inherit(&self) -> io::Result<()> {\n         cvt(unsafe {"}, {"sha": "8ecea8ce07f6b7aa7560788f3945c05bfc71d6f4", "filename": "library/std/src/path.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c7de289e1c8d24bd55aaa33813e509920a00c364/library%2Fstd%2Fsrc%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7de289e1c8d24bd55aaa33813e509920a00c364/library%2Fstd%2Fsrc%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpath.rs?ref=c7de289e1c8d24bd55aaa33813e509920a00c364", "patch": "@@ -1449,8 +1449,8 @@ impl PathBuf {\n         };\n \n         // truncate until right after the file stem\n-        let end_file_stem = file_stem[file_stem.len()..].as_ptr() as usize;\n-        let start = os_str_as_u8_slice(&self.inner).as_ptr() as usize;\n+        let end_file_stem = file_stem[file_stem.len()..].as_ptr().addr();\n+        let start = os_str_as_u8_slice(&self.inner).as_ptr().addr();\n         let v = self.as_mut_vec();\n         v.truncate(end_file_stem.wrapping_sub(start));\n "}, {"sha": "d2dd4c075d2a942eadb4f626ba96d3b003628b0b", "filename": "library/std/src/sync/once.rs", "status": "modified", "additions": 28, "deletions": 21, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/c7de289e1c8d24bd55aaa33813e509920a00c364/library%2Fstd%2Fsrc%2Fsync%2Fonce.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7de289e1c8d24bd55aaa33813e509920a00c364/library%2Fstd%2Fsrc%2Fsync%2Fonce.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsync%2Fonce.rs?ref=c7de289e1c8d24bd55aaa33813e509920a00c364", "patch": "@@ -91,9 +91,12 @@ use crate::cell::Cell;\n use crate::fmt;\n use crate::marker;\n use crate::panic::{RefUnwindSafe, UnwindSafe};\n-use crate::sync::atomic::{AtomicBool, AtomicUsize, Ordering};\n+use crate::ptr;\n+use crate::sync::atomic::{AtomicBool, AtomicPtr, Ordering};\n use crate::thread::{self, Thread};\n \n+type Masked = ();\n+\n /// A synchronization primitive which can be used to run a one-time global\n /// initialization. Useful for one-time initialization for FFI or related\n /// functionality. This type can only be constructed with [`Once::new()`].\n@@ -113,7 +116,7 @@ use crate::thread::{self, Thread};\n pub struct Once {\n     // `state_and_queue` is actually a pointer to a `Waiter` with extra state\n     // bits, so we add the `PhantomData` appropriately.\n-    state_and_queue: AtomicUsize,\n+    state_and_queue: AtomicPtr<Masked>,\n     _marker: marker::PhantomData<*const Waiter>,\n }\n \n@@ -136,7 +139,7 @@ impl RefUnwindSafe for Once {}\n #[derive(Debug)]\n pub struct OnceState {\n     poisoned: bool,\n-    set_state_on_drop_to: Cell<usize>,\n+    set_state_on_drop_to: Cell<*mut Masked>,\n }\n \n /// Initialization value for static [`Once`] values.\n@@ -184,8 +187,8 @@ struct Waiter {\n // Every node is a struct on the stack of a waiting thread.\n // Will wake up the waiters when it gets dropped, i.e. also on panic.\n struct WaiterQueue<'a> {\n-    state_and_queue: &'a AtomicUsize,\n-    set_state_on_drop_to: usize,\n+    state_and_queue: &'a AtomicPtr<Masked>,\n+    set_state_on_drop_to: *mut Masked,\n }\n \n impl Once {\n@@ -195,7 +198,10 @@ impl Once {\n     #[rustc_const_stable(feature = \"const_once_new\", since = \"1.32.0\")]\n     #[must_use]\n     pub const fn new() -> Once {\n-        Once { state_and_queue: AtomicUsize::new(INCOMPLETE), _marker: marker::PhantomData }\n+        Once {\n+            state_and_queue: AtomicPtr::new(ptr::invalid_mut(INCOMPLETE)),\n+            _marker: marker::PhantomData,\n+        }\n     }\n \n     /// Performs an initialization routine once and only once. The given closure\n@@ -376,7 +382,7 @@ impl Once {\n         // operations visible to us, and, this being a fast path, weaker\n         // ordering helps with performance. This `Acquire` synchronizes with\n         // `Release` operations on the slow path.\n-        self.state_and_queue.load(Ordering::Acquire) == COMPLETE\n+        self.state_and_queue.load(Ordering::Acquire).addr() == COMPLETE\n     }\n \n     // This is a non-generic function to reduce the monomorphization cost of\n@@ -395,7 +401,7 @@ impl Once {\n     fn call_inner(&self, ignore_poisoning: bool, init: &mut dyn FnMut(&OnceState)) {\n         let mut state_and_queue = self.state_and_queue.load(Ordering::Acquire);\n         loop {\n-            match state_and_queue {\n+            match state_and_queue.addr() {\n                 COMPLETE => break,\n                 POISONED if !ignore_poisoning => {\n                     // Panic to propagate the poison.\n@@ -405,7 +411,7 @@ impl Once {\n                     // Try to register this thread as the one RUNNING.\n                     let exchange_result = self.state_and_queue.compare_exchange(\n                         state_and_queue,\n-                        RUNNING,\n+                        ptr::invalid_mut(RUNNING),\n                         Ordering::Acquire,\n                         Ordering::Acquire,\n                     );\n@@ -417,13 +423,13 @@ impl Once {\n                     // wake them up on drop.\n                     let mut waiter_queue = WaiterQueue {\n                         state_and_queue: &self.state_and_queue,\n-                        set_state_on_drop_to: POISONED,\n+                        set_state_on_drop_to: ptr::invalid_mut(POISONED),\n                     };\n                     // Run the initialization function, letting it know if we're\n                     // poisoned or not.\n                     let init_state = OnceState {\n-                        poisoned: state_and_queue == POISONED,\n-                        set_state_on_drop_to: Cell::new(COMPLETE),\n+                        poisoned: state_and_queue.addr() == POISONED,\n+                        set_state_on_drop_to: Cell::new(ptr::invalid_mut(COMPLETE)),\n                     };\n                     init(&init_state);\n                     waiter_queue.set_state_on_drop_to = init_state.set_state_on_drop_to.get();\n@@ -432,7 +438,7 @@ impl Once {\n                 _ => {\n                     // All other values must be RUNNING with possibly a\n                     // pointer to the waiter queue in the more significant bits.\n-                    assert!(state_and_queue & STATE_MASK == RUNNING);\n+                    assert!(state_and_queue.addr() & STATE_MASK == RUNNING);\n                     wait(&self.state_and_queue, state_and_queue);\n                     state_and_queue = self.state_and_queue.load(Ordering::Acquire);\n                 }\n@@ -441,29 +447,29 @@ impl Once {\n     }\n }\n \n-fn wait(state_and_queue: &AtomicUsize, mut current_state: usize) {\n+fn wait(state_and_queue: &AtomicPtr<Masked>, mut current_state: *mut Masked) {\n     // Note: the following code was carefully written to avoid creating a\n     // mutable reference to `node` that gets aliased.\n     loop {\n         // Don't queue this thread if the status is no longer running,\n         // otherwise we will not be woken up.\n-        if current_state & STATE_MASK != RUNNING {\n+        if current_state.addr() & STATE_MASK != RUNNING {\n             return;\n         }\n \n         // Create the node for our current thread.\n         let node = Waiter {\n             thread: Cell::new(Some(thread::current())),\n             signaled: AtomicBool::new(false),\n-            next: (current_state & !STATE_MASK) as *const Waiter,\n+            next: current_state.with_addr(current_state.addr() & !STATE_MASK) as *const Waiter,\n         };\n-        let me = &node as *const Waiter as usize;\n+        let me = &node as *const Waiter as *const Masked as *mut Masked;\n \n         // Try to slide in the node at the head of the linked list, making sure\n         // that another thread didn't just replace the head of the linked list.\n         let exchange_result = state_and_queue.compare_exchange(\n             current_state,\n-            me | RUNNING,\n+            me.with_addr(me.addr() | RUNNING),\n             Ordering::Release,\n             Ordering::Relaxed,\n         );\n@@ -502,7 +508,7 @@ impl Drop for WaiterQueue<'_> {\n             self.state_and_queue.swap(self.set_state_on_drop_to, Ordering::AcqRel);\n \n         // We should only ever see an old state which was RUNNING.\n-        assert_eq!(state_and_queue & STATE_MASK, RUNNING);\n+        assert_eq!(state_and_queue.addr() & STATE_MASK, RUNNING);\n \n         // Walk the entire linked list of waiters and wake them up (in lifo\n         // order, last to register is first to wake up).\n@@ -511,7 +517,8 @@ impl Drop for WaiterQueue<'_> {\n             // free `node` if there happens to be has a spurious wakeup.\n             // So we have to take out the `thread` field and copy the pointer to\n             // `next` first.\n-            let mut queue = (state_and_queue & !STATE_MASK) as *const Waiter;\n+            let mut queue =\n+                state_and_queue.with_addr(state_and_queue.addr() & !STATE_MASK) as *const Waiter;\n             while !queue.is_null() {\n                 let next = (*queue).next;\n                 let thread = (*queue).thread.take().unwrap();\n@@ -568,6 +575,6 @@ impl OnceState {\n     /// Poison the associated [`Once`] without explicitly panicking.\n     // NOTE: This is currently only exposed for the `lazy` module\n     pub(crate) fn poison(&self) {\n-        self.set_state_on_drop_to.set(POISONED);\n+        self.set_state_on_drop_to.set(ptr::invalid_mut(POISONED));\n     }\n }"}, {"sha": "fdc81cdea7dec36fcb690dabffb4d88dc4d6f246", "filename": "library/std/src/sys/windows/alloc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7de289e1c8d24bd55aaa33813e509920a00c364/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7de289e1c8d24bd55aaa33813e509920a00c364/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Falloc.rs?ref=c7de289e1c8d24bd55aaa33813e509920a00c364", "patch": "@@ -159,7 +159,7 @@ unsafe fn allocate(layout: Layout, zeroed: bool) -> *mut u8 {\n         // Create a correctly aligned pointer offset from the start of the allocated block,\n         // and write a header before it.\n \n-        let offset = layout.align() - (ptr as usize & (layout.align() - 1));\n+        let offset = layout.align() - (ptr.addr() & (layout.align() - 1));\n         // SAFETY: `MIN_ALIGN` <= `offset` <= `layout.align()` and the size of the allocated\n         // block is `layout.align() + layout.size()`. `aligned` will thus be a correctly aligned\n         // pointer inside the allocated block with at least `layout.size()` bytes after it and at"}, {"sha": "0edf43e5d9dd5f2993aad353665c894c81bcb256", "filename": "library/std/src/sys/windows/c.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7de289e1c8d24bd55aaa33813e509920a00c364/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7de289e1c8d24bd55aaa33813e509920a00c364/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fc.rs?ref=c7de289e1c8d24bd55aaa33813e509920a00c364", "patch": "@@ -173,7 +173,7 @@ pub const PROGRESS_CONTINUE: DWORD = 0;\n \n pub const E_NOTIMPL: HRESULT = 0x80004001u32 as HRESULT;\n \n-pub const INVALID_HANDLE_VALUE: HANDLE = !0 as HANDLE;\n+pub const INVALID_HANDLE_VALUE: HANDLE = ptr::invalid_mut(!0);\n \n pub const FACILITY_NT_BIT: DWORD = 0x1000_0000;\n "}, {"sha": "a914a3bcc120be35b45ee7cecd6c9b7b71c4720c", "filename": "library/std/src/sys/windows/compat.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7de289e1c8d24bd55aaa33813e509920a00c364/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fcompat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7de289e1c8d24bd55aaa33813e509920a00c364/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fcompat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fcompat.rs?ref=c7de289e1c8d24bd55aaa33813e509920a00c364", "patch": "@@ -88,7 +88,7 @@ macro_rules! compat_fn {\n                 let symbol_name: *const u8 = concat!(stringify!($symbol), \"\\0\").as_ptr();\n                 let module_handle = $crate::sys::c::GetModuleHandleA(module_name as *const i8);\n                 if !module_handle.is_null() {\n-                    match $crate::sys::c::GetProcAddress(module_handle, symbol_name as *const i8) as usize {\n+                    match $crate::sys::c::GetProcAddress(module_handle, symbol_name as *const i8).addr() {\n                         0 => {}\n                         n => {\n                             PTR = Some(mem::transmute::<usize, F>(n));"}, {"sha": "95903899297b601a8ad84679c8699b21d492c497", "filename": "library/std/src/sys/windows/fs.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/c7de289e1c8d24bd55aaa33813e509920a00c364/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7de289e1c8d24bd55aaa33813e509920a00c364/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Ffs.rs?ref=c7de289e1c8d24bd55aaa33813e509920a00c364", "patch": "@@ -57,6 +57,9 @@ pub struct DirEntry {\n     data: c::WIN32_FIND_DATAW,\n }\n \n+unsafe impl Send for OpenOptions {}\n+unsafe impl Sync for OpenOptions {}\n+\n #[derive(Clone, Debug)]\n pub struct OpenOptions {\n     // generic\n@@ -72,7 +75,7 @@ pub struct OpenOptions {\n     attributes: c::DWORD,\n     share_mode: c::DWORD,\n     security_qos_flags: c::DWORD,\n-    security_attributes: usize, // FIXME: should be a reference\n+    security_attributes: c::LPSECURITY_ATTRIBUTES,\n }\n \n #[derive(Clone, PartialEq, Eq, Debug)]\n@@ -187,7 +190,7 @@ impl OpenOptions {\n             share_mode: c::FILE_SHARE_READ | c::FILE_SHARE_WRITE | c::FILE_SHARE_DELETE,\n             attributes: 0,\n             security_qos_flags: 0,\n-            security_attributes: 0,\n+            security_attributes: ptr::null_mut(),\n         }\n     }\n \n@@ -228,7 +231,7 @@ impl OpenOptions {\n         self.security_qos_flags = flags | c::SECURITY_SQOS_PRESENT;\n     }\n     pub fn security_attributes(&mut self, attrs: c::LPSECURITY_ATTRIBUTES) {\n-        self.security_attributes = attrs as usize;\n+        self.security_attributes = attrs;\n     }\n \n     fn get_access_mode(&self) -> io::Result<c::DWORD> {\n@@ -289,7 +292,7 @@ impl File {\n                 path.as_ptr(),\n                 opts.get_access_mode()?,\n                 opts.share_mode,\n-                opts.security_attributes as *mut _,\n+                opts.security_attributes,\n                 opts.get_creation_mode()?,\n                 opts.get_flags_and_attributes(),\n                 ptr::null_mut(),"}, {"sha": "87e3fec6353f9e7e72fe0ea69c9ab5785bdd9005", "filename": "library/std/src/sys/windows/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/c7de289e1c8d24bd55aaa33813e509920a00c364/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7de289e1c8d24bd55aaa33813e509920a00c364/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fmod.rs?ref=c7de289e1c8d24bd55aaa33813e509920a00c364", "patch": "@@ -136,7 +136,7 @@ pub fn unrolled_find_u16s(needle: u16, haystack: &[u16]) -> Option<usize> {\n             ($($n:literal,)+) => {\n                 $(\n                     if start[$n] == needle {\n-                        return Some((&start[$n] as *const u16 as usize - ptr as usize) / 2);\n+                        return Some(((&start[$n] as *const u16).addr() - ptr.addr()) / 2);\n                     }\n                 )+\n             }\n@@ -149,7 +149,7 @@ pub fn unrolled_find_u16s(needle: u16, haystack: &[u16]) -> Option<usize> {\n \n     for c in start {\n         if *c == needle {\n-            return Some((c as *const u16 as usize - ptr as usize) / 2);\n+            return Some(((c as *const u16).addr() - ptr.addr()) / 2);\n         }\n     }\n     None"}, {"sha": "bcac996c024ec34fe84d70b249b22082e68a44ac", "filename": "library/std/src/sys/windows/os.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/c7de289e1c8d24bd55aaa33813e509920a00c364/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7de289e1c8d24bd55aaa33813e509920a00c364/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fos.rs?ref=c7de289e1c8d24bd55aaa33813e509920a00c364", "patch": "@@ -134,7 +134,7 @@ impl Drop for Env {\n pub fn env() -> Env {\n     unsafe {\n         let ch = c::GetEnvironmentStringsW();\n-        if ch as usize == 0 {\n+        if ch.is_null() {\n             panic!(\"failure getting env string from OS: {}\", io::Error::last_os_error());\n         }\n         Env { base: ch, cur: ch }"}, {"sha": "3497da51deeda54d9d391bfc9064abafed912418", "filename": "library/std/src/sys/windows/thread_parker.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c7de289e1c8d24bd55aaa33813e509920a00c364/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fthread_parker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7de289e1c8d24bd55aaa33813e509920a00c364/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fthread_parker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Fwindows%2Fthread_parker.rs?ref=c7de289e1c8d24bd55aaa33813e509920a00c364", "patch": "@@ -60,7 +60,7 @@\n use crate::convert::TryFrom;\n use crate::ptr;\n use crate::sync::atomic::{\n-    AtomicI8, AtomicUsize,\n+    AtomicI8, AtomicPtr,\n     Ordering::{Acquire, Relaxed, Release},\n };\n use crate::sys::{c, dur2timeout};\n@@ -217,8 +217,8 @@ impl Parker {\n }\n \n fn keyed_event_handle() -> c::HANDLE {\n-    const INVALID: usize = !0;\n-    static HANDLE: AtomicUsize = AtomicUsize::new(INVALID);\n+    const INVALID: c::HANDLE = ptr::invalid_mut(!0);\n+    static HANDLE: AtomicPtr<libc::c_void> = AtomicPtr::new(INVALID);\n     match HANDLE.load(Relaxed) {\n         INVALID => {\n             let mut handle = c::INVALID_HANDLE_VALUE;\n@@ -233,18 +233,18 @@ fn keyed_event_handle() -> c::HANDLE {\n                     r => panic!(\"Unable to create keyed event handle: error {r}\"),\n                 }\n             }\n-            match HANDLE.compare_exchange(INVALID, handle as usize, Relaxed, Relaxed) {\n+            match HANDLE.compare_exchange(INVALID, handle, Relaxed, Relaxed) {\n                 Ok(_) => handle,\n                 Err(h) => {\n                     // Lost the race to another thread initializing HANDLE before we did.\n                     // Closing our handle and using theirs instead.\n                     unsafe {\n                         c::CloseHandle(handle);\n                     }\n-                    h as c::HANDLE\n+                    h\n                 }\n             }\n         }\n-        handle => handle as c::HANDLE,\n+        handle => handle,\n     }\n }"}, {"sha": "7671850ac55b8502d7c8187399baecec2520576e", "filename": "library/std/src/sys_common/condvar/check.rs", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/c7de289e1c8d24bd55aaa33813e509920a00c364/library%2Fstd%2Fsrc%2Fsys_common%2Fcondvar%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7de289e1c8d24bd55aaa33813e509920a00c364/library%2Fstd%2Fsrc%2Fsys_common%2Fcondvar%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Fcondvar%2Fcheck.rs?ref=c7de289e1c8d24bd55aaa33813e509920a00c364", "patch": "@@ -1,4 +1,5 @@\n-use crate::sync::atomic::{AtomicUsize, Ordering};\n+use crate::ptr;\n+use crate::sync::atomic::{AtomicPtr, Ordering};\n use crate::sys::locks as imp;\n use crate::sys_common::mutex::MovableMutex;\n \n@@ -13,17 +14,18 @@ impl CondvarCheck for Box<imp::Mutex> {\n }\n \n pub struct SameMutexCheck {\n-    addr: AtomicUsize,\n+    addr: AtomicPtr<()>,\n }\n \n #[allow(dead_code)]\n impl SameMutexCheck {\n     pub const fn new() -> Self {\n-        Self { addr: AtomicUsize::new(0) }\n+        Self { addr: AtomicPtr::new(ptr::null_mut()) }\n     }\n     pub fn verify(&self, mutex: &MovableMutex) {\n-        let addr = mutex.raw() as *const imp::Mutex as usize;\n-        match self.addr.compare_exchange(0, addr, Ordering::SeqCst, Ordering::SeqCst) {\n+        let addr = mutex.raw() as *const imp::Mutex as *const () as *mut _;\n+        match self.addr.compare_exchange(ptr::null_mut(), addr, Ordering::SeqCst, Ordering::SeqCst)\n+        {\n             Ok(_) => {}               // Stored the address\n             Err(n) if n == addr => {} // Lost a race to store the same address\n             _ => panic!(\"attempted to use a condition variable with two mutexes\"),"}, {"sha": "ca29261b1c98d05082d1fe3d50aae3a532672736", "filename": "library/std/src/thread/local.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/c7de289e1c8d24bd55aaa33813e509920a00c364/library%2Fstd%2Fsrc%2Fthread%2Flocal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c7de289e1c8d24bd55aaa33813e509920a00c364/library%2Fstd%2Fsrc%2Fthread%2Flocal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fthread%2Flocal.rs?ref=c7de289e1c8d24bd55aaa33813e509920a00c364", "patch": "@@ -1071,7 +1071,7 @@ pub mod os {\n         pub unsafe fn get(&'static self, init: impl FnOnce() -> T) -> Option<&'static T> {\n             // SAFETY: See the documentation for this method.\n             let ptr = unsafe { self.os.get() as *mut Value<T> };\n-            if ptr as usize > 1 {\n+            if ptr.addr() > 1 {\n                 // SAFETY: the check ensured the pointer is safe (its destructor\n                 // is not running) + it is coming from a trusted source (self).\n                 if let Some(ref value) = unsafe { (*ptr).inner.get() } {\n@@ -1090,7 +1090,7 @@ pub mod os {\n             // SAFETY: No mutable references are ever handed out meaning getting\n             // the value is ok.\n             let ptr = unsafe { self.os.get() as *mut Value<T> };\n-            if ptr as usize == 1 {\n+            if ptr.addr() == 1 {\n                 // destructor is running\n                 return None;\n             }\n@@ -1130,7 +1130,7 @@ pub mod os {\n         unsafe {\n             let ptr = Box::from_raw(ptr as *mut Value<T>);\n             let key = ptr.key;\n-            key.os.set(1 as *mut u8);\n+            key.os.set(ptr::invalid_mut(1));\n             drop(ptr);\n             key.os.set(ptr::null_mut());\n         }"}]}