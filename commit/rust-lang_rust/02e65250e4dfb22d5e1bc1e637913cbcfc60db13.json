{"sha": "02e65250e4dfb22d5e1bc1e637913cbcfc60db13", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAyZTY1MjUwZTRkZmIyMmQ1ZTFiYzFlNjM3OTEzY2JjZmM2MGRiMTM=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-12-04T09:47:59Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2017-12-15T15:27:49Z"}, "message": "mild refactors of the control flow (no functional changes)\n\nIn the future, `check_type_tests` will also potentially propagate\nconstriants to its caller.", "tree": {"sha": "59092ce1fa04c9138af5731e514c8cb93479f586", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/59092ce1fa04c9138af5731e514c8cb93479f586"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/02e65250e4dfb22d5e1bc1e637913cbcfc60db13", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/02e65250e4dfb22d5e1bc1e637913cbcfc60db13", "html_url": "https://github.com/rust-lang/rust/commit/02e65250e4dfb22d5e1bc1e637913cbcfc60db13", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/02e65250e4dfb22d5e1bc1e637913cbcfc60db13/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "47c1921b9adb7c6e783ef4ec2a5f1dbe312b3da7", "url": "https://api.github.com/repos/rust-lang/rust/commits/47c1921b9adb7c6e783ef4ec2a5f1dbe312b3da7", "html_url": "https://github.com/rust-lang/rust/commit/47c1921b9adb7c6e783ef4ec2a5f1dbe312b3da7"}], "stats": {"total": 72, "additions": 44, "deletions": 28}, "files": [{"sha": "efa0734b0168485ba246e9d10dc08cfeae005051", "filename": "src/librustc_mir/borrow_check/nll/region_infer/mod.rs", "status": "modified", "additions": 44, "deletions": 28, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/02e65250e4dfb22d5e1bc1e637913cbcfc60db13/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/02e65250e4dfb22d5e1bc1e637913cbcfc60db13/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Fmod.rs?ref=02e65250e4dfb22d5e1bc1e637913cbcfc60db13", "patch": "@@ -349,9 +349,22 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n         self.propagate_constraints(mir);\n \n+        // If this is a closure, we can propagate unsatisfied\n+        // `outlives_requirements` to our creator, so create a vector\n+        // to store those. Otherwise, we'll pass in `None` to the\n+        // functions below, which will trigger them to report errors\n+        // eagerly.\n+        let mut outlives_requirements = if infcx.tcx.is_closure(mir_def_id) {\n+            Some(vec![])\n+        } else {\n+            None\n+        };\n+\n         self.check_type_tests(infcx, mir);\n \n-        let outlives_requirements = self.check_universal_regions(infcx, mir_def_id);\n+        self.check_universal_regions(infcx, outlives_requirements.as_mut());\n+\n+        let outlives_requirements = outlives_requirements.unwrap_or(vec![]);\n \n         if outlives_requirements.is_empty() {\n             None\n@@ -429,18 +442,20 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         for type_test in &self.type_tests {\n             debug!(\"check_type_test: {:?}\", type_test);\n \n-            if !self.eval_region_test(\n+            if self.eval_region_test(\n                 mir,\n                 type_test.point,\n                 type_test.lower_bound,\n                 &type_test.test,\n             ) {\n-                // Oh the humanity. Obviously we will do better than this error eventually.\n-                infcx.tcx.sess.span_err(\n-                    type_test.span,\n-                    &format!(\"failed type test: {:?}\", type_test),\n-                );\n+                continue;\n             }\n+\n+            // Oh the humanity. Obviously we will do better than this error eventually.\n+            infcx.tcx.sess.span_err(\n+                type_test.span,\n+                &format!(\"failed type test: {:?}\", type_test),\n+            );\n         }\n     }\n \n@@ -538,11 +553,15 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// therefore add `end('a)` into the region for `'b` -- but we\n     /// have no evidence that `'b` outlives `'a`, so we want to report\n     /// an error.\n+    ///\n+    /// If `propagated_outlives_requirements` is `Some`, then we will\n+    /// push unsatisfied obligations into there. Otherwise, we'll\n+    /// report them as errors.\n     fn check_universal_regions(\n         &self,\n         infcx: &InferCtxt<'_, '_, 'tcx>,\n-        mir_def_id: DefId,\n-    ) -> Vec<ClosureOutlivesRequirement> {\n+        mut propagated_outlives_requirements: Option<&mut Vec<ClosureOutlivesRequirement>>,\n+    ) {\n         // The universal regions are always found in a prefix of the\n         // full list.\n         let universal_definitions = self.definitions\n@@ -555,25 +574,22 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         let mut outlives_requirements = vec![];\n         for (fr, _) in universal_definitions {\n             self.check_universal_region(infcx, fr, &mut outlives_requirements);\n-        }\n-\n-        // If this is a closure, we can propagate unsatisfied\n-        // `outlives_requirements` to our creator. Otherwise, we have\n-        // to report a hard error here.\n-        if infcx.tcx.is_closure(mir_def_id) {\n-            return outlives_requirements;\n-        }\n \n-        for outlives_requirement in outlives_requirements {\n-            self.report_error(\n-                infcx,\n-                outlives_requirement.free_region,\n-                outlives_requirement.outlived_free_region,\n-                outlives_requirement.blame_span,\n-            );\n+            // Propagate unsatisfied requirements if possible, else\n+            // report them.\n+            if let Some(propagated_outlives_requirements) = &mut propagated_outlives_requirements {\n+                propagated_outlives_requirements.extend(outlives_requirements.drain(..));\n+            } else {\n+                for outlives_requirement in outlives_requirements.drain(..) {\n+                    self.report_error(\n+                        infcx,\n+                        outlives_requirement.free_region,\n+                        outlives_requirement.outlived_free_region,\n+                        outlives_requirement.blame_span,\n+                    );\n+                }\n+            }\n         }\n-\n-        vec![]\n     }\n \n     /// Check the final value for the free region `fr` to see if it\n@@ -588,7 +604,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         &self,\n         infcx: &InferCtxt<'_, '_, 'tcx>,\n         longer_fr: RegionVid,\n-        outlives_requirements: &mut Vec<ClosureOutlivesRequirement>,\n+        propagated_outlives_requirements: &mut Vec<ClosureOutlivesRequirement>,\n     ) {\n         let inferred_values = self.inferred_values.as_ref().unwrap();\n \n@@ -626,7 +642,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 );\n \n                 // Push the constraint `fr-: shorter_fr+`\n-                outlives_requirements.push(ClosureOutlivesRequirement {\n+                propagated_outlives_requirements.push(ClosureOutlivesRequirement {\n                     free_region: fr_minus,\n                     outlived_free_region: shorter_fr_plus,\n                     blame_span: blame_span,"}]}