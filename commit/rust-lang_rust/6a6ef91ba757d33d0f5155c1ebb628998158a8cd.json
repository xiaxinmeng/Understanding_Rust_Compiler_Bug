{"sha": "6a6ef91ba757d33d0f5155c1ebb628998158a8cd", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZhNmVmOTFiYTc1N2QzM2QwZjUxNTVjMWViYjYyODk5ODE1OGE4Y2Q=", "commit": {"author": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-10-16T02:38:08Z"}, "committer": {"name": "Jeffrey Seyfried", "email": "jeffrey.seyfried@gmail.com", "date": "2016-10-19T09:58:08Z"}, "message": "nit: Import `Ident` in `resolve`.", "tree": {"sha": "134f588be81bbeb4ba785f6fb2e58a1f2529de6f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/134f588be81bbeb4ba785f6fb2e58a1f2529de6f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6a6ef91ba757d33d0f5155c1ebb628998158a8cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6a6ef91ba757d33d0f5155c1ebb628998158a8cd", "html_url": "https://github.com/rust-lang/rust/commit/6a6ef91ba757d33d0f5155c1ebb628998158a8cd", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6a6ef91ba757d33d0f5155c1ebb628998158a8cd/comments", "author": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jseyfried", "id": 8652869, "node_id": "MDQ6VXNlcjg2NTI4Njk=", "avatar_url": "https://avatars.githubusercontent.com/u/8652869?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jseyfried", "html_url": "https://github.com/jseyfried", "followers_url": "https://api.github.com/users/jseyfried/followers", "following_url": "https://api.github.com/users/jseyfried/following{/other_user}", "gists_url": "https://api.github.com/users/jseyfried/gists{/gist_id}", "starred_url": "https://api.github.com/users/jseyfried/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jseyfried/subscriptions", "organizations_url": "https://api.github.com/users/jseyfried/orgs", "repos_url": "https://api.github.com/users/jseyfried/repos", "events_url": "https://api.github.com/users/jseyfried/events{/privacy}", "received_events_url": "https://api.github.com/users/jseyfried/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0c429872a32c3005cf2b347025163361218634a4", "url": "https://api.github.com/repos/rust-lang/rust/commits/0c429872a32c3005cf2b347025163361218634a4", "html_url": "https://github.com/rust-lang/rust/commit/0c429872a32c3005cf2b347025163361218634a4"}], "stats": {"total": 28, "additions": 14, "deletions": 14}, "files": [{"sha": "a89f8cffba146269a1cd76f5a6a0e61c3e651e7c", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/6a6ef91ba757d33d0f5155c1ebb628998158a8cd/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a6ef91ba757d33d0f5155c1ebb628998158a8cd/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=6a6ef91ba757d33d0f5155c1ebb628998158a8cd", "patch": "@@ -55,7 +55,7 @@ use rustc::util::nodemap::{NodeMap, NodeSet, FnvHashMap, FnvHashSet};\n \n use syntax::ext::hygiene::Mark;\n use syntax::ast::{self, FloatTy};\n-use syntax::ast::{CRATE_NODE_ID, Name, NodeId, IntTy, UintTy};\n+use syntax::ast::{CRATE_NODE_ID, Name, NodeId, Ident, IntTy, UintTy};\n use syntax::ext::base::SyntaxExtension;\n use syntax::parse::token::{self, keywords};\n use syntax::util::lev_distance::find_best_match_for_name;\n@@ -509,7 +509,7 @@ struct BindingInfo {\n }\n \n // Map from the name in a pattern to its binding mode.\n-type BindingMap = FnvHashMap<ast::Ident, BindingInfo>;\n+type BindingMap = FnvHashMap<Ident, BindingInfo>;\n \n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n enum PatternSource {\n@@ -714,7 +714,7 @@ enum ModulePrefixResult<'a> {\n /// One local scope.\n #[derive(Debug)]\n struct Rib<'a> {\n-    bindings: FnvHashMap<ast::Ident, Def>,\n+    bindings: FnvHashMap<Ident, Def>,\n     kind: RibKind<'a>,\n }\n \n@@ -1479,7 +1479,7 @@ impl<'a> Resolver<'a> {\n                         // This is not a crate-relative path. We resolve the\n                         // first component of the path in the current lexical\n                         // scope and then proceed to resolve below that.\n-                        let ident = ast::Ident::with_empty_ctxt(module_path[0]);\n+                        let ident = Ident::with_empty_ctxt(module_path[0]);\n                         let lexical_binding =\n                             self.resolve_ident_in_lexical_scope(ident, TypeNS, span);\n                         if let Some(binding) = lexical_binding.and_then(LexicalScopeBinding::item) {\n@@ -1525,12 +1525,12 @@ impl<'a> Resolver<'a> {\n     /// Invariant: This must only be called during main resolution, not during\n     /// import resolution.\n     fn resolve_ident_in_lexical_scope(&mut self,\n-                                      mut ident: ast::Ident,\n+                                      mut ident: Ident,\n                                       ns: Namespace,\n                                       record_used: Option<Span>)\n                                       -> Option<LexicalScopeBinding<'a>> {\n         if ns == TypeNS {\n-            ident = ast::Ident::with_empty_ctxt(ident.name);\n+            ident = Ident::with_empty_ctxt(ident.name);\n         }\n \n         // Walk backwards up the ribs in scope.\n@@ -1649,7 +1649,7 @@ impl<'a> Resolver<'a> {\n \n     /// Searches the current set of local scopes for labels.\n     /// Stops after meeting a closure.\n-    fn search_label(&self, mut ident: ast::Ident) -> Option<Def> {\n+    fn search_label(&self, mut ident: Ident) -> Option<Def> {\n         for rib in self.label_ribs.iter().rev() {\n             match rib.kind {\n                 NormalRibKind => {\n@@ -1813,7 +1813,7 @@ impl<'a> Resolver<'a> {\n                     // plain insert (no renaming)\n                     let def_id = self.definitions.local_def_id(type_parameter.id);\n                     let def = Def::TyParam(def_id);\n-                    function_type_rib.bindings.insert(ast::Ident::with_empty_ctxt(name), def);\n+                    function_type_rib.bindings.insert(Ident::with_empty_ctxt(name), def);\n                     self.record_def(type_parameter.id, PathResolution::new(def));\n                 }\n                 self.type_ribs.push(function_type_rib);\n@@ -2271,7 +2271,7 @@ impl<'a> Resolver<'a> {\n                      pat_id: NodeId,\n                      outer_pat_id: NodeId,\n                      pat_src: PatternSource,\n-                     bindings: &mut FnvHashMap<ast::Ident, NodeId>)\n+                     bindings: &mut FnvHashMap<Ident, NodeId>)\n                      -> PathResolution {\n         // Add the binding to the local ribs, if it\n         // doesn't already exist in the bindings map. (We\n@@ -2372,7 +2372,7 @@ impl<'a> Resolver<'a> {\n                        pat_src: PatternSource,\n                        // Maps idents to the node ID for the\n                        // outermost pattern that binds them.\n-                       bindings: &mut FnvHashMap<ast::Ident, NodeId>) {\n+                       bindings: &mut FnvHashMap<Ident, NodeId>) {\n         // Visit all direct subpatterns of this pattern.\n         let outer_pat_id = pat.id;\n         pat.walk(&mut |pat| {\n@@ -2573,7 +2573,7 @@ impl<'a> Resolver<'a> {\n \n     // Resolve a single identifier\n     fn resolve_identifier(&mut self,\n-                          identifier: ast::Ident,\n+                          identifier: Ident,\n                           namespace: Namespace,\n                           record_used: Option<Span>)\n                           -> Option<LocalDef> {\n@@ -2835,7 +2835,7 @@ impl<'a> Resolver<'a> {\n         } SuggestionType::NotFound\n     }\n \n-    fn resolve_labeled_block(&mut self, label: Option<ast::Ident>, id: NodeId, block: &Block) {\n+    fn resolve_labeled_block(&mut self, label: Option<Ident>, id: NodeId, block: &Block) {\n         if let Some(label) = label {\n             let def = Def::Label(id);\n             self.with_label_rib(|this| {\n@@ -3237,7 +3237,7 @@ impl<'a> Resolver<'a> {\n                 if name == lookup_name && ns == namespace {\n                     if filter_fn(name_binding.def()) {\n                         // create the path\n-                        let ident = ast::Ident::with_empty_ctxt(name);\n+                        let ident = Ident::with_empty_ctxt(name);\n                         let params = PathParameters::none();\n                         let segment = PathSegment {\n                             identifier: ident,\n@@ -3271,7 +3271,7 @@ impl<'a> Resolver<'a> {\n                         _ if module.parent.is_none() => path_segments.clone(),\n                         ModuleKind::Def(_, name) => {\n                             let mut paths = path_segments.clone();\n-                            let ident = ast::Ident::with_empty_ctxt(name);\n+                            let ident = Ident::with_empty_ctxt(name);\n                             let params = PathParameters::none();\n                             let segm = PathSegment {\n                                 identifier: ident,"}]}