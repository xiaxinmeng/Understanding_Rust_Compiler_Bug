{"sha": "69f45b78608c1ddef9994b013461dcb7584d7072", "node_id": "C_kwDOAAsO6NoAKDY5ZjQ1Yjc4NjA4YzFkZGVmOTk5NGIwMTM0NjFkY2I3NTg0ZDcwNzI", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-06-20T03:52:48Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-06-20T03:52:48Z"}, "message": "Add blank lines between methods in `proc_macro_server.rs`.\n\nBecause that's the standard way of doing it.", "tree": {"sha": "68879681f296fe16ac56e7ddc0caf526c552778d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/68879681f296fe16ac56e7ddc0caf526c552778d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/69f45b78608c1ddef9994b013461dcb7584d7072", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/69f45b78608c1ddef9994b013461dcb7584d7072", "html_url": "https://github.com/rust-lang/rust/commit/69f45b78608c1ddef9994b013461dcb7584d7072", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/69f45b78608c1ddef9994b013461dcb7584d7072/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2a5487afb47aa01c7ee1446bae616bd2e34ec6ad", "url": "https://api.github.com/repos/rust-lang/rust/commits/2a5487afb47aa01c7ee1446bae616bd2e34ec6ad", "html_url": "https://github.com/rust-lang/rust/commit/2a5487afb47aa01c7ee1446bae616bd2e34ec6ad"}], "stats": {"total": 54, "additions": 54, "deletions": 0}, "files": [{"sha": "1e4193a5a16cc6cc7f360cb09ef4a91277e2bbbd", "filename": "compiler/rustc_expand/src/proc_macro_server.rs", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/69f45b78608c1ddef9994b013461dcb7584d7072/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "raw_url": "https://github.com/rust-lang/rust/raw/69f45b78608c1ddef9994b013461dcb7584d7072/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fproc_macro_server.rs?ref=69f45b78608c1ddef9994b013461dcb7584d7072", "patch": "@@ -329,6 +329,7 @@ impl Ident {\n         sess.symbol_gallery.insert(sym, span);\n         Ident { sym, is_raw, span }\n     }\n+\n     fn dollar_crate(span: Span) -> Ident {\n         // `$crate` is accepted as an ident only if it comes from the compiler.\n         Ident { sym: kw::DollarCrate, is_raw: false, span }\n@@ -403,6 +404,7 @@ impl server::TokenStream for Rustc<'_, '_> {\n     fn is_empty(&mut self, stream: &Self::TokenStream) -> bool {\n         stream.is_empty()\n     }\n+\n     fn from_str(&mut self, src: &str) -> Self::TokenStream {\n         parse_stream_from_source_str(\n             FileName::proc_macro_source_code(src),\n@@ -411,9 +413,11 @@ impl server::TokenStream for Rustc<'_, '_> {\n             Some(self.call_site),\n         )\n     }\n+\n     fn to_string(&mut self, stream: &Self::TokenStream) -> String {\n         pprust::tts_to_string(stream)\n     }\n+\n     fn expand_expr(&mut self, stream: &Self::TokenStream) -> Result<Self::TokenStream, ()> {\n         // Parse the expression from our tokenstream.\n         let expr: PResult<'_, _> = try {\n@@ -464,12 +468,14 @@ impl server::TokenStream for Rustc<'_, '_> {\n             _ => Err(()),\n         }\n     }\n+\n     fn from_token_tree(\n         &mut self,\n         tree: TokenTree<Self::Group, Self::Punct, Self::Ident, Self::Literal>,\n     ) -> Self::TokenStream {\n         tree.to_internal()\n     }\n+\n     fn concat_trees(\n         &mut self,\n         base: Option<Self::TokenStream>,\n@@ -484,6 +490,7 @@ impl server::TokenStream for Rustc<'_, '_> {\n         }\n         builder.build()\n     }\n+\n     fn concat_streams(\n         &mut self,\n         base: Option<Self::TokenStream>,\n@@ -498,6 +505,7 @@ impl server::TokenStream for Rustc<'_, '_> {\n         }\n         builder.build()\n     }\n+\n     fn into_trees(\n         &mut self,\n         stream: Self::TokenStream,\n@@ -543,21 +551,27 @@ impl server::Group for Rustc<'_, '_> {\n             flatten: false,\n         }\n     }\n+\n     fn delimiter(&mut self, group: &Self::Group) -> Delimiter {\n         group.delimiter\n     }\n+\n     fn stream(&mut self, group: &Self::Group) -> Self::TokenStream {\n         group.stream.clone()\n     }\n+\n     fn span(&mut self, group: &Self::Group) -> Self::Span {\n         group.span.entire()\n     }\n+\n     fn span_open(&mut self, group: &Self::Group) -> Self::Span {\n         group.span.open\n     }\n+\n     fn span_close(&mut self, group: &Self::Group) -> Self::Span {\n         group.span.close\n     }\n+\n     fn set_span(&mut self, group: &mut Self::Group, span: Self::Span) {\n         group.span = DelimSpan::from_single(span);\n     }\n@@ -567,15 +581,19 @@ impl server::Punct for Rustc<'_, '_> {\n     fn new(&mut self, ch: char, spacing: Spacing) -> Self::Punct {\n         Punct::new(ch, spacing == Spacing::Joint, server::Span::call_site(self))\n     }\n+\n     fn as_char(&mut self, punct: Self::Punct) -> char {\n         punct.ch\n     }\n+\n     fn spacing(&mut self, punct: Self::Punct) -> Spacing {\n         if punct.joint { Spacing::Joint } else { Spacing::Alone }\n     }\n+\n     fn span(&mut self, punct: Self::Punct) -> Self::Span {\n         punct.span\n     }\n+\n     fn with_span(&mut self, punct: Self::Punct, span: Self::Span) -> Self::Punct {\n         Punct { span, ..punct }\n     }\n@@ -585,9 +603,11 @@ impl server::Ident for Rustc<'_, '_> {\n     fn new(&mut self, string: &str, span: Self::Span, is_raw: bool) -> Self::Ident {\n         Ident::new(self.sess(), Symbol::intern(string), is_raw, span)\n     }\n+\n     fn span(&mut self, ident: Self::Ident) -> Self::Span {\n         ident.span\n     }\n+\n     fn with_span(&mut self, ident: Self::Ident, span: Self::Span) -> Self::Ident {\n         Ident { span, ..ident }\n     }\n@@ -639,45 +659,57 @@ impl server::Literal for Rustc<'_, '_> {\n \n         Ok(Literal { lit, span: self.call_site })\n     }\n+\n     fn to_string(&mut self, literal: &Self::Literal) -> String {\n         literal.lit.to_string()\n     }\n+\n     fn debug_kind(&mut self, literal: &Self::Literal) -> String {\n         format!(\"{:?}\", literal.lit.kind)\n     }\n+\n     fn symbol(&mut self, literal: &Self::Literal) -> String {\n         literal.lit.symbol.to_string()\n     }\n+\n     fn suffix(&mut self, literal: &Self::Literal) -> Option<String> {\n         literal.lit.suffix.as_ref().map(Symbol::to_string)\n     }\n+\n     fn integer(&mut self, n: &str) -> Self::Literal {\n         self.lit(token::Integer, Symbol::intern(n), None)\n     }\n+\n     fn typed_integer(&mut self, n: &str, kind: &str) -> Self::Literal {\n         self.lit(token::Integer, Symbol::intern(n), Some(Symbol::intern(kind)))\n     }\n+\n     fn float(&mut self, n: &str) -> Self::Literal {\n         self.lit(token::Float, Symbol::intern(n), None)\n     }\n+\n     fn f32(&mut self, n: &str) -> Self::Literal {\n         self.lit(token::Float, Symbol::intern(n), Some(sym::f32))\n     }\n+\n     fn f64(&mut self, n: &str) -> Self::Literal {\n         self.lit(token::Float, Symbol::intern(n), Some(sym::f64))\n     }\n+\n     fn string(&mut self, string: &str) -> Self::Literal {\n         let quoted = format!(\"{:?}\", string);\n         assert!(quoted.starts_with('\"') && quoted.ends_with('\"'));\n         let symbol = &quoted[1..quoted.len() - 1];\n         self.lit(token::Str, Symbol::intern(symbol), None)\n     }\n+\n     fn character(&mut self, ch: char) -> Self::Literal {\n         let quoted = format!(\"{:?}\", ch);\n         assert!(quoted.starts_with('\\'') && quoted.ends_with('\\''));\n         let symbol = &quoted[1..quoted.len() - 1];\n         self.lit(token::Char, Symbol::intern(symbol), None)\n     }\n+\n     fn byte_string(&mut self, bytes: &[u8]) -> Self::Literal {\n         let string = bytes\n             .iter()\n@@ -687,12 +719,15 @@ impl server::Literal for Rustc<'_, '_> {\n             .collect::<String>();\n         self.lit(token::ByteStr, Symbol::intern(&string), None)\n     }\n+\n     fn span(&mut self, literal: &Self::Literal) -> Self::Span {\n         literal.span\n     }\n+\n     fn set_span(&mut self, literal: &mut Self::Literal, span: Self::Span) {\n         literal.span = span;\n     }\n+\n     fn subspan(\n         &mut self,\n         literal: &Self::Literal,\n@@ -735,6 +770,7 @@ impl server::SourceFile for Rustc<'_, '_> {\n     fn eq(&mut self, file1: &Self::SourceFile, file2: &Self::SourceFile) -> bool {\n         Lrc::ptr_eq(file1, file2)\n     }\n+\n     fn path(&mut self, file: &Self::SourceFile) -> String {\n         match file.name {\n             FileName::Real(ref name) => name\n@@ -746,6 +782,7 @@ impl server::SourceFile for Rustc<'_, '_> {\n             _ => file.name.prefer_local().to_string(),\n         }\n     }\n+\n     fn is_real(&mut self, file: &Self::SourceFile) -> bool {\n         file.is_real_file()\n     }\n@@ -755,6 +792,7 @@ impl server::MultiSpan for Rustc<'_, '_> {\n     fn new(&mut self) -> Self::MultiSpan {\n         vec![]\n     }\n+\n     fn push(&mut self, spans: &mut Self::MultiSpan, span: Self::Span) {\n         spans.push(span)\n     }\n@@ -766,6 +804,7 @@ impl server::Diagnostic for Rustc<'_, '_> {\n         diag.set_span(MultiSpan::from_spans(spans));\n         diag\n     }\n+\n     fn sub(\n         &mut self,\n         diag: &mut Self::Diagnostic,\n@@ -775,6 +814,7 @@ impl server::Diagnostic for Rustc<'_, '_> {\n     ) {\n         diag.sub(level.to_internal(), msg, MultiSpan::from_spans(spans), None);\n     }\n+\n     fn emit(&mut self, mut diag: Self::Diagnostic) {\n         self.sess().span_diagnostic.emit_diagnostic(&mut diag);\n     }\n@@ -788,38 +828,49 @@ impl server::Span for Rustc<'_, '_> {\n             format!(\"{:?} bytes({}..{})\", span.ctxt(), span.lo().0, span.hi().0)\n         }\n     }\n+\n     fn def_site(&mut self) -> Self::Span {\n         self.def_site\n     }\n+\n     fn call_site(&mut self) -> Self::Span {\n         self.call_site\n     }\n+\n     fn mixed_site(&mut self) -> Self::Span {\n         self.mixed_site\n     }\n+\n     fn source_file(&mut self, span: Self::Span) -> Self::SourceFile {\n         self.sess().source_map().lookup_char_pos(span.lo()).file\n     }\n+\n     fn parent(&mut self, span: Self::Span) -> Option<Self::Span> {\n         span.parent_callsite()\n     }\n+\n     fn source(&mut self, span: Self::Span) -> Self::Span {\n         span.source_callsite()\n     }\n+\n     fn start(&mut self, span: Self::Span) -> LineColumn {\n         let loc = self.sess().source_map().lookup_char_pos(span.lo());\n         LineColumn { line: loc.line, column: loc.col.to_usize() }\n     }\n+\n     fn end(&mut self, span: Self::Span) -> LineColumn {\n         let loc = self.sess().source_map().lookup_char_pos(span.hi());\n         LineColumn { line: loc.line, column: loc.col.to_usize() }\n     }\n+\n     fn before(&mut self, span: Self::Span) -> Self::Span {\n         span.shrink_to_lo()\n     }\n+\n     fn after(&mut self, span: Self::Span) -> Self::Span {\n         span.shrink_to_hi()\n     }\n+\n     fn join(&mut self, first: Self::Span, second: Self::Span) -> Option<Self::Span> {\n         let self_loc = self.sess().source_map().lookup_char_pos(first.lo());\n         let other_loc = self.sess().source_map().lookup_char_pos(second.lo());\n@@ -830,9 +881,11 @@ impl server::Span for Rustc<'_, '_> {\n \n         Some(first.to(second))\n     }\n+\n     fn resolved_at(&mut self, span: Self::Span, at: Self::Span) -> Self::Span {\n         span.with_ctxt(at.ctxt())\n     }\n+\n     fn source_text(&mut self, span: Self::Span) -> Option<String> {\n         self.sess().source_map().span_to_snippet(span).ok()\n     }\n@@ -863,6 +916,7 @@ impl server::Span for Rustc<'_, '_> {\n     fn save_span(&mut self, span: Self::Span) -> usize {\n         self.sess().save_proc_macro_span(span)\n     }\n+\n     fn recover_proc_macro_span(&mut self, id: usize) -> Self::Span {\n         let (resolver, krate, def_site) = (&*self.ecx.resolver, self.krate, self.def_site);\n         *self.rebased_spans.entry(id).or_insert_with(|| {"}]}