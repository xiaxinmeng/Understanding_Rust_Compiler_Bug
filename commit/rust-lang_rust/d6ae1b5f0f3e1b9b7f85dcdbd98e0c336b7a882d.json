{"sha": "d6ae1b5f0f3e1b9b7f85dcdbd98e0c336b7a882d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQ2YWUxYjVmMGYzZTFiOWI3Zjg1ZGNkYmQ5OGUwYzMzNmI3YTg4MmQ=", "commit": {"author": {"name": "Ekaterina Babshukova", "email": "ekaterina.babshukova@yandex.ru", "date": "2019-09-21T16:35:39Z"}, "committer": {"name": "Ekaterina Babshukova", "email": "ekaterina.babshukova@yandex.ru", "date": "2019-10-22T20:47:31Z"}, "message": "refactor name_ref_kind.rs", "tree": {"sha": "b945f83081f91ad49b8636c3aa25761bbee22858", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b945f83081f91ad49b8636c3aa25761bbee22858"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d6ae1b5f0f3e1b9b7f85dcdbd98e0c336b7a882d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d6ae1b5f0f3e1b9b7f85dcdbd98e0c336b7a882d", "html_url": "https://github.com/rust-lang/rust/commit/d6ae1b5f0f3e1b9b7f85dcdbd98e0c336b7a882d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d6ae1b5f0f3e1b9b7f85dcdbd98e0c336b7a882d/comments", "author": {"login": "viorina", "id": 6714973, "node_id": "MDQ6VXNlcjY3MTQ5NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/6714973?v=4", "gravatar_id": "", "url": "https://api.github.com/users/viorina", "html_url": "https://github.com/viorina", "followers_url": "https://api.github.com/users/viorina/followers", "following_url": "https://api.github.com/users/viorina/following{/other_user}", "gists_url": "https://api.github.com/users/viorina/gists{/gist_id}", "starred_url": "https://api.github.com/users/viorina/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/viorina/subscriptions", "organizations_url": "https://api.github.com/users/viorina/orgs", "repos_url": "https://api.github.com/users/viorina/repos", "events_url": "https://api.github.com/users/viorina/events{/privacy}", "received_events_url": "https://api.github.com/users/viorina/received_events", "type": "User", "site_admin": false}, "committer": {"login": "viorina", "id": 6714973, "node_id": "MDQ6VXNlcjY3MTQ5NzM=", "avatar_url": "https://avatars.githubusercontent.com/u/6714973?v=4", "gravatar_id": "", "url": "https://api.github.com/users/viorina", "html_url": "https://github.com/viorina", "followers_url": "https://api.github.com/users/viorina/followers", "following_url": "https://api.github.com/users/viorina/following{/other_user}", "gists_url": "https://api.github.com/users/viorina/gists{/gist_id}", "starred_url": "https://api.github.com/users/viorina/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/viorina/subscriptions", "organizations_url": "https://api.github.com/users/viorina/orgs", "repos_url": "https://api.github.com/users/viorina/repos", "events_url": "https://api.github.com/users/viorina/events{/privacy}", "received_events_url": "https://api.github.com/users/viorina/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "11577288c23b1f2de1aaba0137c9c2d6344b9a92", "url": "https://api.github.com/repos/rust-lang/rust/commits/11577288c23b1f2de1aaba0137c9c2d6344b9a92", "html_url": "https://github.com/rust-lang/rust/commit/11577288c23b1f2de1aaba0137c9c2d6344b9a92"}], "stats": {"total": 125, "additions": 61, "deletions": 64}, "files": [{"sha": "7626a3fd1d133202dfc7a295320077177335930b", "filename": "crates/ra_ide_api/src/goto_definition.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d6ae1b5f0f3e1b9b7f85dcdbd98e0c336b7a882d/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6ae1b5f0f3e1b9b7f85dcdbd98e0c336b7a882d/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fgoto_definition.rs?ref=d6ae1b5f0f3e1b9b7f85dcdbd98e0c336b7a882d", "patch": "@@ -10,7 +10,7 @@ use ra_syntax::{\n use crate::{\n     db::RootDatabase,\n     display::ShortLabel,\n-    name_ref_kind::{classify_name_ref, NameKind::*},\n+    name_kind::{classify_name_ref, NameKind::*},\n     FilePosition, NavigationTarget, RangeInfo,\n };\n \n@@ -60,7 +60,6 @@ pub(crate) fn reference_definition(\n         Some(Macro(mac)) => return Exact(NavigationTarget::from_macro_def(db, mac)),\n         Some(FieldAccess(field)) => return Exact(NavigationTarget::from_field(db, field)),\n         Some(AssocItem(assoc)) => return Exact(NavigationTarget::from_assoc_item(db, assoc)),\n-        Some(Method(func)) => return Exact(NavigationTarget::from_def_source(db, func)),\n         Some(Def(def)) => match NavigationTarget::from_def(db, def) {\n             Some(nav) => return Exact(nav),\n             None => return Approximate(vec![]),"}, {"sha": "1702789041a45ad842288f004abae20d467fa650", "filename": "crates/ra_ide_api/src/hover.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d6ae1b5f0f3e1b9b7f85dcdbd98e0c336b7a882d/crates%2Fra_ide_api%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6ae1b5f0f3e1b9b7f85dcdbd98e0c336b7a882d/crates%2Fra_ide_api%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fhover.rs?ref=d6ae1b5f0f3e1b9b7f85dcdbd98e0c336b7a882d", "patch": "@@ -14,7 +14,7 @@ use crate::{\n         description_from_symbol, docs_from_symbol, macro_label, rust_code_markup,\n         rust_code_markup_with_doc, ShortLabel,\n     },\n-    name_ref_kind::{classify_name_ref, NameKind::*},\n+    name_kind::{classify_name_ref, NameKind::*},\n     FilePosition, FileRange, RangeInfo,\n };\n \n@@ -104,7 +104,6 @@ pub(crate) fn hover(db: &RootDatabase, position: FilePosition) -> Option<RangeIn\n         let mut no_fallback = false;\n \n         match classify_name_ref(db, &analyzer, &name_ref) {\n-            Some(Method(it)) => res.extend(from_def_source(db, it)),\n             Some(Macro(it)) => {\n                 let src = it.source(db);\n                 res.extend(hover_text(src.ast.doc_comment_text(), Some(macro_label(&src.ast))));"}, {"sha": "cbf79ce03612620bd3a3b0bc3dd72a87f38bfad1", "filename": "crates/ra_ide_api/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d6ae1b5f0f3e1b9b7f85dcdbd98e0c336b7a882d/crates%2Fra_ide_api%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6ae1b5f0f3e1b9b7f85dcdbd98e0c336b7a882d/crates%2Fra_ide_api%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Flib.rs?ref=d6ae1b5f0f3e1b9b7f85dcdbd98e0c336b7a882d", "patch": "@@ -19,7 +19,7 @@ mod feature_flags;\n mod status;\n mod completion;\n mod runnables;\n-mod name_ref_kind;\n+mod name_kind;\n mod goto_definition;\n mod goto_type_definition;\n mod extend_selection;"}, {"sha": "64adb17841e8a9f12015650ed6fecf872548b379", "filename": "crates/ra_ide_api/src/name_kind.rs", "status": "renamed", "additions": 53, "deletions": 14, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/d6ae1b5f0f3e1b9b7f85dcdbd98e0c336b7a882d/crates%2Fra_ide_api%2Fsrc%2Fname_kind.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6ae1b5f0f3e1b9b7f85dcdbd98e0c336b7a882d/crates%2Fra_ide_api%2Fsrc%2Fname_kind.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fname_kind.rs?ref=d6ae1b5f0f3e1b9b7f85dcdbd98e0c336b7a882d", "patch": "@@ -1,13 +1,13 @@\n //! FIXME: write short doc here\n \n-use hir::Either;\n+use hir::{Either, FromSource};\n+use ra_db::FileId;\n use ra_syntax::{ast, AstNode, AstPtr};\n use test_utils::tested_by;\n \n use crate::db::RootDatabase;\n \n pub enum NameKind {\n-    Method(hir::Function),\n     Macro(hir::MacroDef),\n     FieldAccess(hir::StructField),\n     AssocItem(hir::AssocItem),\n@@ -29,7 +29,7 @@ pub(crate) fn classify_name_ref(\n     if let Some(method_call) = name_ref.syntax().parent().and_then(ast::MethodCallExpr::cast) {\n         tested_by!(goto_definition_works_for_methods);\n         if let Some(func) = analyzer.resolve_method_call(&method_call) {\n-            return Some(Method(func));\n+            return Some(AssocItem(func.into()));\n         }\n     }\n \n@@ -59,17 +59,12 @@ pub(crate) fn classify_name_ref(\n     if let Some(field_expr) = name_ref.syntax().parent().and_then(ast::RecordField::cast) {\n         tested_by!(goto_definition_works_for_record_fields);\n \n-        let record_lit = field_expr.syntax().ancestors().find_map(ast::RecordLit::cast);\n-\n-        if let Some(ty) = record_lit.and_then(|lit| analyzer.type_of(db, &lit.into())) {\n-            if let Some((hir::Adt::Struct(s), _)) = ty.as_adt() {\n-                let hir_path = hir::Path::from_name_ref(name_ref);\n-                let hir_name = hir_path.as_ident().unwrap();\n-\n-                if let Some(field) = s.field(db, hir_name) {\n-                    return Some(FieldAccess(field));\n-                }\n-            }\n+        if let Some(record_lit) = field_expr.syntax().ancestors().find_map(ast::RecordLit::cast) {\n+            let variant_def = analyzer.resolve_record_literal(&record_lit)?;\n+            let hir_path = hir::Path::from_name_ref(name_ref);\n+            let hir_name = hir_path.as_ident()?;\n+            let field = variant_def.field(db, hir_name)?;\n+            return Some(FieldAccess(field));\n         }\n     }\n \n@@ -96,3 +91,47 @@ pub(crate) fn classify_name_ref(\n \n     None\n }\n+\n+pub(crate) fn classify_name(\n+    db: &RootDatabase,\n+    file_id: FileId,\n+    name: &ast::Name,\n+) -> Option<NameKind> {\n+    use NameKind::*;\n+\n+    let parent = name.syntax().parent()?;\n+    let file_id = file_id.into();\n+\n+    if let Some(pat) = ast::BindPat::cast(parent.clone()) {\n+        return Some(Pat(AstPtr::new(&pat)));\n+    }\n+    if let Some(var) = ast::EnumVariant::cast(parent.clone()) {\n+        let src = hir::Source { file_id, ast: var };\n+        let var = hir::EnumVariant::from_source(db, src)?;\n+        return Some(Def(var.into()));\n+    }\n+    if let Some(field) = ast::RecordFieldDef::cast(parent.clone()) {\n+        let src = hir::Source { file_id, ast: hir::FieldSource::Named(field) };\n+        let field = hir::StructField::from_source(db, src)?;\n+        return Some(FieldAccess(field));\n+    }\n+    if let Some(field) = ast::TupleFieldDef::cast(parent.clone()) {\n+        let src = hir::Source { file_id, ast: hir::FieldSource::Pos(field) };\n+        let field = hir::StructField::from_source(db, src)?;\n+        return Some(FieldAccess(field));\n+    }\n+    if let Some(_) = parent.parent().and_then(ast::ItemList::cast) {\n+        let ast = ast::ImplItem::cast(parent.clone())?;\n+        let src = hir::Source { file_id, ast };\n+        let item = hir::AssocItem::from_source(db, src)?;\n+        return Some(AssocItem(item));\n+    }\n+    if let Some(item) = ast::ModuleItem::cast(parent.clone()) {\n+        let src = hir::Source { file_id, ast: item };\n+        let def = hir::ModuleDef::from_source(db, src)?;\n+        return Some(Def(def));\n+    }\n+    // FIXME: TYPE_PARAM, ALIAS, MACRO_CALL; Union\n+\n+    None\n+}", "previous_filename": "crates/ra_ide_api/src/name_ref_kind.rs"}, {"sha": "6a8407c51830063b10942b8165a19eaf80f53583", "filename": "crates/ra_ide_api/src/references.rs", "status": "modified", "additions": 4, "deletions": 43, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/d6ae1b5f0f3e1b9b7f85dcdbd98e0c336b7a882d/crates%2Fra_ide_api%2Fsrc%2Freferences.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6ae1b5f0f3e1b9b7f85dcdbd98e0c336b7a882d/crates%2Fra_ide_api%2Fsrc%2Freferences.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Freferences.rs?ref=d6ae1b5f0f3e1b9b7f85dcdbd98e0c336b7a882d", "patch": "@@ -1,14 +1,14 @@\n //! FIXME: write short doc here\n \n-use hir::{FromSource, ModuleSource};\n+use hir::ModuleSource;\n use ra_db::{SourceDatabase, SourceDatabaseExt};\n-use ra_syntax::{algo::find_node_at_offset, ast, AstNode, AstPtr, SyntaxNode};\n+use ra_syntax::{algo::find_node_at_offset, ast, AstNode, SyntaxNode};\n use relative_path::{RelativePath, RelativePathBuf};\n \n use crate::{\n     db::RootDatabase,\n-    name_ref_kind::{\n-        classify_name_ref,\n+    name_kind::{\n+        classify_name, classify_name_ref,\n         NameKind::{self, *},\n     },\n     FileId, FilePosition, FileRange, FileSystemEdit, NavigationTarget, RangeInfo, SourceChange,\n@@ -64,7 +64,6 @@ pub(crate) fn find_all_refs(\n         Macro(mac) => NavigationTarget::from_macro_def(db, mac),\n         FieldAccess(field) => NavigationTarget::from_field(db, field),\n         AssocItem(assoc) => NavigationTarget::from_assoc_item(db, assoc),\n-        Method(func) => NavigationTarget::from_def_source(db, func),\n         Def(def) => NavigationTarget::from_def(db, def)?,\n         SelfType(ref ty) => match ty.as_adt() {\n             Some((def_id, _)) => NavigationTarget::from_adt_def(db, def_id),\n@@ -105,44 +104,6 @@ pub(crate) fn find_all_refs(\n     }\n }\n \n-fn classify_name(db: &RootDatabase, file_id: FileId, name: &ast::Name) -> Option<NameKind> {\n-    let parent = name.syntax().parent()?;\n-    let file_id = file_id.into();\n-\n-    if let Some(pat) = ast::BindPat::cast(parent.clone()) {\n-        return Some(Pat(AstPtr::new(&pat)));\n-    }\n-    if let Some(var) = ast::EnumVariant::cast(parent.clone()) {\n-        let src = hir::Source { file_id, ast: var };\n-        let var = hir::EnumVariant::from_source(db, src)?;\n-        return Some(Def(var.into()));\n-    }\n-    if let Some(field) = ast::RecordFieldDef::cast(parent.clone()) {\n-        let src = hir::Source { file_id, ast: hir::FieldSource::Named(field) };\n-        let field = hir::StructField::from_source(db, src)?;\n-        return Some(FieldAccess(field));\n-    }\n-    if let Some(field) = ast::TupleFieldDef::cast(parent.clone()) {\n-        let src = hir::Source { file_id, ast: hir::FieldSource::Pos(field) };\n-        let field = hir::StructField::from_source(db, src)?;\n-        return Some(FieldAccess(field));\n-    }\n-    if let Some(_) = parent.parent().and_then(ast::ItemList::cast) {\n-        let ast = ast::ImplItem::cast(parent.clone())?;\n-        let src = hir::Source { file_id, ast };\n-        let item = hir::AssocItem::from_source(db, src)?;\n-        return Some(AssocItem(item));\n-    }\n-    if let Some(item) = ast::ModuleItem::cast(parent.clone()) {\n-        let src = hir::Source { file_id, ast: item };\n-        let def = hir::ModuleDef::from_source(db, src)?;\n-        return Some(Def(def));\n-    }\n-    // FIXME: TYPE_PARAM, ALIAS, MACRO_CALL; Union\n-\n-    None\n-}\n-\n pub(crate) fn rename(\n     db: &RootDatabase,\n     position: FilePosition,"}, {"sha": "98373a49c6d56e24a03a448e1eea1c5f599a9e3e", "filename": "crates/ra_ide_api/src/syntax_highlighting.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d6ae1b5f0f3e1b9b7f85dcdbd98e0c336b7a882d/crates%2Fra_ide_api%2Fsrc%2Fsyntax_highlighting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d6ae1b5f0f3e1b9b7f85dcdbd98e0c336b7a882d/crates%2Fra_ide_api%2Fsrc%2Fsyntax_highlighting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fsyntax_highlighting.rs?ref=d6ae1b5f0f3e1b9b7f85dcdbd98e0c336b7a882d", "patch": "@@ -14,7 +14,7 @@ use ra_syntax::{\n \n use crate::{\n     db::RootDatabase,\n-    name_ref_kind::{classify_name_ref, NameKind::*},\n+    name_kind::{classify_name_ref, NameKind::*},\n     FileId,\n };\n \n@@ -104,7 +104,6 @@ pub(crate) fn highlight(db: &RootDatabase, file_id: FileId) -> Vec<HighlightedRa\n                     // FIXME: try to reuse the SourceAnalyzers\n                     let analyzer = hir::SourceAnalyzer::new(db, file_id, name_ref.syntax(), None);\n                     match classify_name_ref(db, &analyzer, &name_ref) {\n-                        Some(Method(_)) => \"function\",\n                         Some(Macro(_)) => \"macro\",\n                         Some(FieldAccess(_)) => \"field\",\n                         Some(AssocItem(hir::AssocItem::Function(_))) => \"function\","}]}