{"sha": "82619ea2bdb3e1107a1832a31aabcf1b3dd9126c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgyNjE5ZWEyYmRiM2UxMTA3YTE4MzJhMzFhYWJjZjFiM2RkOTEyNmM=", "commit": {"author": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-08-20T21:34:30Z"}, "committer": {"name": "Vadim Petrochenkov", "email": "vadim.petrochenkov@gmail.com", "date": "2018-08-20T22:01:50Z"}, "message": "resolve: Unify reporting of ambiguity errors for macro paths", "tree": {"sha": "cbc5e492f881194a401695fcd041ce4c6cb5290f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/cbc5e492f881194a401695fcd041ce4c6cb5290f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/82619ea2bdb3e1107a1832a31aabcf1b3dd9126c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/82619ea2bdb3e1107a1832a31aabcf1b3dd9126c", "html_url": "https://github.com/rust-lang/rust/commit/82619ea2bdb3e1107a1832a31aabcf1b3dd9126c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/82619ea2bdb3e1107a1832a31aabcf1b3dd9126c/comments", "author": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "committer": {"login": "petrochenkov", "id": 5751617, "node_id": "MDQ6VXNlcjU3NTE2MTc=", "avatar_url": "https://avatars.githubusercontent.com/u/5751617?v=4", "gravatar_id": "", "url": "https://api.github.com/users/petrochenkov", "html_url": "https://github.com/petrochenkov", "followers_url": "https://api.github.com/users/petrochenkov/followers", "following_url": "https://api.github.com/users/petrochenkov/following{/other_user}", "gists_url": "https://api.github.com/users/petrochenkov/gists{/gist_id}", "starred_url": "https://api.github.com/users/petrochenkov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/petrochenkov/subscriptions", "organizations_url": "https://api.github.com/users/petrochenkov/orgs", "repos_url": "https://api.github.com/users/petrochenkov/repos", "events_url": "https://api.github.com/users/petrochenkov/events{/privacy}", "received_events_url": "https://api.github.com/users/petrochenkov/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c2788a88ca1991040eca2ffefc0b88eebdfcc582", "url": "https://api.github.com/repos/rust-lang/rust/commits/c2788a88ca1991040eca2ffefc0b88eebdfcc582", "html_url": "https://github.com/rust-lang/rust/commit/c2788a88ca1991040eca2ffefc0b88eebdfcc582"}], "stats": {"total": 111, "additions": 68, "deletions": 43}, "files": [{"sha": "9bfa17615ff9a3979cf88053f6bd0e8731f1de79", "filename": "src/librustc_resolve/lib.rs", "status": "modified", "additions": 45, "deletions": 24, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/82619ea2bdb3e1107a1832a31aabcf1b3dd9126c/src%2Flibrustc_resolve%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82619ea2bdb3e1107a1832a31aabcf1b3dd9126c/src%2Flibrustc_resolve%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Flib.rs?ref=82619ea2bdb3e1107a1832a31aabcf1b3dd9126c", "patch": "@@ -4431,6 +4431,42 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n         vis.is_accessible_from(module.normal_ancestor_id, self)\n     }\n \n+    fn report_ambiguity_error(\n+        &self, name: Name, span: Span, _lexical: bool,\n+        def1: Def, is_import1: bool, is_glob1: bool, from_expansion1: bool, span1: Span,\n+        def2: Def, is_import2: bool, _is_glob2: bool, _from_expansion2: bool, span2: Span,\n+    ) {\n+        let participle = |is_import: bool| if is_import { \"imported\" } else { \"defined\" };\n+        let msg1 = format!(\"`{}` could refer to the name {} here\", name, participle(is_import1));\n+        let msg2 =\n+            format!(\"`{}` could also refer to the name {} here\", name, participle(is_import2));\n+        let note = if from_expansion1 {\n+            Some(if let Def::Macro(..) = def1 {\n+                format!(\"macro-expanded {} do not shadow\",\n+                        if is_import1 { \"macro imports\" } else { \"macros\" })\n+            } else {\n+                format!(\"macro-expanded {} do not shadow when used in a macro invocation path\",\n+                        if is_import1 { \"imports\" } else { \"items\" })\n+            })\n+        } else if is_glob1 {\n+            Some(format!(\"consider adding an explicit import of `{}` to disambiguate\", name))\n+        } else {\n+            None\n+        };\n+\n+        let mut err = struct_span_err!(self.session, span, E0659, \"`{}` is ambiguous\", name);\n+        err.span_note(span1, &msg1);\n+        match def2 {\n+            Def::Macro(..) if span2.is_dummy() =>\n+                err.note(&format!(\"`{}` is also a builtin macro\", name)),\n+            _ => err.span_note(span2, &msg2),\n+        };\n+        if let Some(note) = note {\n+            err.note(&note);\n+        }\n+        err.emit();\n+    }\n+\n     fn report_errors(&mut self, krate: &Crate) {\n         self.report_shadowing_errors();\n         self.report_with_use_injections(krate);\n@@ -4446,30 +4482,15 @@ impl<'a, 'crateloader: 'a> Resolver<'a, 'crateloader> {\n         }\n \n         for &AmbiguityError { span, name, b1, b2, lexical } in &self.ambiguity_errors {\n-            if !reported_spans.insert(span) { continue }\n-            let participle = |binding: &NameBinding| {\n-                if binding.is_import() { \"imported\" } else { \"defined\" }\n-            };\n-            let msg1 = format!(\"`{}` could refer to the name {} here\", name, participle(b1));\n-            let msg2 = format!(\"`{}` could also refer to the name {} here\", name, participle(b2));\n-            let note = if b1.expansion == Mark::root() || !lexical && b1.is_glob_import() {\n-                format!(\"consider adding an explicit import of `{}` to disambiguate\", name)\n-            } else if let Def::Macro(..) = b1.def() {\n-                format!(\"macro-expanded {} do not shadow\",\n-                        if b1.is_import() { \"macro imports\" } else { \"macros\" })\n-            } else {\n-                format!(\"macro-expanded {} do not shadow when used in a macro invocation path\",\n-                        if b1.is_import() { \"imports\" } else { \"items\" })\n-            };\n-\n-            let mut err = struct_span_err!(self.session, span, E0659, \"`{}` is ambiguous\", name);\n-            err.span_note(b1.span, &msg1);\n-            match b2.def() {\n-                Def::Macro(..) if b2.span.is_dummy() =>\n-                    err.note(&format!(\"`{}` is also a builtin macro\", name)),\n-                _ => err.span_note(b2.span, &msg2),\n-            };\n-            err.note(&note).emit();\n+            if reported_spans.insert(span) {\n+                self.report_ambiguity_error(\n+                    name, span, lexical,\n+                    b1.def(), b1.is_import(), b1.is_glob_import(),\n+                    b1.expansion != Mark::root(), b1.span,\n+                    b2.def(), b2.is_import(), b2.is_glob_import(),\n+                    b2.expansion != Mark::root(), b2.span,\n+                );\n+            }\n         }\n \n         for &PrivacyError(span, name, binding) in &self.privacy_errors {"}, {"sha": "1161d57417b1890865c4590a6da8f698c96bea7e", "filename": "src/librustc_resolve/macros.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/82619ea2bdb3e1107a1832a31aabcf1b3dd9126c/src%2Flibrustc_resolve%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82619ea2bdb3e1107a1832a31aabcf1b3dd9126c/src%2Flibrustc_resolve%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fmacros.rs?ref=82619ea2bdb3e1107a1832a31aabcf1b3dd9126c", "patch": "@@ -871,16 +871,18 @@ impl<'a, 'cl> Resolver<'a, 'cl> {\n                     self.suggest_macro_name(&ident.as_str(), kind, &mut err, span);\n                     err.emit();\n                 },\n-                (Some((legacy_binding, _)), Ok((binding, FromPrelude(false)))) |\n-                (Some((legacy_binding, FromExpansion(true))), Ok((binding, FromPrelude(true)))) => {\n+                (Some((legacy_binding, FromExpansion(from_expansion))),\n+                 Ok((binding, FromPrelude(false)))) |\n+                (Some((legacy_binding, FromExpansion(from_expansion @ true))),\n+                 Ok((binding, FromPrelude(true)))) => {\n                     if legacy_binding.def() != binding.def_ignoring_ambiguity() {\n-                        let msg1 = format!(\"`{}` could refer to the macro defined here\", ident);\n-                        let msg2 =\n-                            format!(\"`{}` could also refer to the macro imported here\", ident);\n-                        self.session.struct_span_err(span, &format!(\"`{}` is ambiguous\", ident))\n-                            .span_note(legacy_binding.span, &msg1)\n-                            .span_note(binding.span, &msg2)\n-                            .emit();\n+                        self.report_ambiguity_error(\n+                            ident.name, span, true,\n+                            legacy_binding.def(), false, false,\n+                            from_expansion, legacy_binding.span,\n+                            binding.def(), binding.is_import(), binding.is_glob_import(),\n+                            binding.expansion != Mark::root(), binding.span,\n+                        );\n                     }\n                 },\n                 // OK, non-macro-expanded legacy wins over macro prelude even if defs are different"}, {"sha": "0036d71107a95f57d8b024a86d6bcb158fcfaf1c", "filename": "src/test/ui/imports/issue-53269.stderr", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/82619ea2bdb3e1107a1832a31aabcf1b3dd9126c/src%2Ftest%2Fui%2Fimports%2Fissue-53269.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/82619ea2bdb3e1107a1832a31aabcf1b3dd9126c/src%2Ftest%2Fui%2Fimports%2Fissue-53269.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fissue-53269.stderr?ref=82619ea2bdb3e1107a1832a31aabcf1b3dd9126c", "patch": "@@ -4,23 +4,24 @@ error[E0432]: unresolved import `nonexistent_module`\n LL |     use nonexistent_module::mac; //~ ERROR unresolved import `nonexistent_module`\n    |         ^^^^^^^^^^^^^^^^^^ Maybe a missing `extern crate nonexistent_module;`?\n \n-error: `mac` is ambiguous\n+error[E0659]: `mac` is ambiguous\n   --> $DIR/issue-53269.rs:18:5\n    |\n LL |     mac!(); //~ ERROR `mac` is ambiguous\n    |     ^^^\n    |\n-note: `mac` could refer to the macro defined here\n+note: `mac` could refer to the name defined here\n   --> $DIR/issue-53269.rs:13:1\n    |\n LL | macro_rules! mac { () => () }\n    | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: `mac` could also refer to the macro imported here\n+note: `mac` could also refer to the name imported here\n   --> $DIR/issue-53269.rs:16:9\n    |\n LL |     use nonexistent_module::mac; //~ ERROR unresolved import `nonexistent_module`\n    |         ^^^^^^^^^^^^^^^^^^^^^^^\n \n error: aborting due to 2 previous errors\n \n-For more information about this error, try `rustc --explain E0432`.\n+Some errors occurred: E0432, E0659.\n+For more information about an error, try `rustc --explain E0432`."}, {"sha": "2c0c4642067ac5f3dc4bb77815d130f1cd91736c", "filename": "src/test/ui/imports/macros.stderr", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/82619ea2bdb3e1107a1832a31aabcf1b3dd9126c/src%2Ftest%2Fui%2Fimports%2Fmacros.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/82619ea2bdb3e1107a1832a31aabcf1b3dd9126c/src%2Ftest%2Fui%2Fimports%2Fmacros.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fmacros.stderr?ref=82619ea2bdb3e1107a1832a31aabcf1b3dd9126c", "patch": "@@ -1,15 +1,15 @@\n-error: `m` is ambiguous\n+error[E0659]: `m` is ambiguous\n   --> $DIR/macros.rs:48:5\n    |\n LL |     m!(); //~ ERROR ambiguous\n    |     ^\n    |\n-note: `m` could refer to the macro defined here\n+note: `m` could refer to the name defined here\n   --> $DIR/macros.rs:46:5\n    |\n LL |     macro_rules! m { () => {} }\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n-note: `m` could also refer to the macro imported here\n+note: `m` could also refer to the name imported here\n   --> $DIR/macros.rs:47:9\n    |\n LL |     use two_macros::m;"}, {"sha": "5c7f15b6fe26f898e4b65f66a4884970e9a54abe", "filename": "src/test/ui/imports/shadow_builtin_macros.stderr", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/82619ea2bdb3e1107a1832a31aabcf1b3dd9126c/src%2Ftest%2Fui%2Fimports%2Fshadow_builtin_macros.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/82619ea2bdb3e1107a1832a31aabcf1b3dd9126c/src%2Ftest%2Fui%2Fimports%2Fshadow_builtin_macros.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimports%2Fshadow_builtin_macros.stderr?ref=82619ea2bdb3e1107a1832a31aabcf1b3dd9126c", "patch": "@@ -1,18 +1,19 @@\n-error: `panic` is ambiguous\n+error[E0659]: `panic` is ambiguous\n   --> $DIR/shadow_builtin_macros.rs:43:5\n    |\n LL |     panic!(); //~ ERROR `panic` is ambiguous\n    |     ^^^^^\n    |\n-note: `panic` could refer to the macro defined here\n+note: `panic` could refer to the name defined here\n   --> $DIR/shadow_builtin_macros.rs:40:9\n    |\n LL |         macro_rules! panic { () => {} }\n    |         ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n LL |     } }\n LL |     m!();\n    |     ----- in this macro invocation\n-note: `panic` could also refer to the macro imported here\n+   = note: `panic` is also a builtin macro\n+   = note: macro-expanded macros do not shadow\n \n error[E0659]: `panic` is ambiguous\n   --> $DIR/shadow_builtin_macros.rs:25:14"}]}