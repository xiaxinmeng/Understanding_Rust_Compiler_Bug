{"sha": "a4f46742c2eb724d813bca7b4834372c8fc3caa8", "node_id": "C_kwDOAAsO6NoAKGE0ZjQ2NzQyYzJlYjcyNGQ4MTNiY2E3YjQ4MzQzNzJjOGZjM2NhYTg", "commit": {"author": {"name": "Matthias Kr\u00fcger", "email": "matthias.krueger@famsik.de", "date": "2021-12-01T09:50:18Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-12-01T09:50:18Z"}, "message": "Rollup merge of #90985 - camsteffen:diag-name-usage, r=jackh726\n\nUse `get_diagnostic_name` more", "tree": {"sha": "61aa5053c921537d571f1105d4e06f5b308383e4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/61aa5053c921537d571f1105d4e06f5b308383e4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a4f46742c2eb724d813bca7b4834372c8fc3caa8", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhp0VbCRBK7hj4Ov3rIwAAM2YIABFHybI5huTUdFKjvjhzmh7I\nKDjqN451aB6JiaTbyRTCSprXDG7BLNAz6m1m7uVBRggr9VZ4HKuHgO57XVuWpfsl\nCJdr99mCMRXpGDYha6jjOP9i2IDrG8TNgRoXTNb7FyG6QRRLePMCl9widEwGkilX\nsDyNQRj8BQwbz5sUf2fZ9z038xXtctma2hdOFoJoZn1fZdQcEyvRty8JGUyyHkuK\n/qoBdOHshBKsNEApuTSoQFxxH6M6WRiw1t7WXoTct4D5hCrd4NMsQ8EKcrRqaEiz\n0j0Y6spXy1ezTEbApgNkmVSKUeByYom3H9t/E7F0wJDN5v9ERxzIkJreD01akSA=\n=LsPT\n-----END PGP SIGNATURE-----\n", "payload": "tree 61aa5053c921537d571f1105d4e06f5b308383e4\nparent e68e5d2391c1dc200bafc39276d321d1c68bdfcc\nparent dec40530f71f38eaf0f853ddbbd80232ee3a5955\nauthor Matthias Kr\u00fcger <matthias.krueger@famsik.de> 1638352218 +0100\ncommitter GitHub <noreply@github.com> 1638352218 +0100\n\nRollup merge of #90985 - camsteffen:diag-name-usage, r=jackh726\n\nUse `get_diagnostic_name` more\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a4f46742c2eb724d813bca7b4834372c8fc3caa8", "html_url": "https://github.com/rust-lang/rust/commit/a4f46742c2eb724d813bca7b4834372c8fc3caa8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a4f46742c2eb724d813bca7b4834372c8fc3caa8/comments", "author": {"login": "matthiaskrgr", "id": 476013, "node_id": "MDQ6VXNlcjQ3NjAxMw==", "avatar_url": "https://avatars.githubusercontent.com/u/476013?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matthiaskrgr", "html_url": "https://github.com/matthiaskrgr", "followers_url": "https://api.github.com/users/matthiaskrgr/followers", "following_url": "https://api.github.com/users/matthiaskrgr/following{/other_user}", "gists_url": "https://api.github.com/users/matthiaskrgr/gists{/gist_id}", "starred_url": "https://api.github.com/users/matthiaskrgr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matthiaskrgr/subscriptions", "organizations_url": "https://api.github.com/users/matthiaskrgr/orgs", "repos_url": "https://api.github.com/users/matthiaskrgr/repos", "events_url": "https://api.github.com/users/matthiaskrgr/events{/privacy}", "received_events_url": "https://api.github.com/users/matthiaskrgr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e68e5d2391c1dc200bafc39276d321d1c68bdfcc", "url": "https://api.github.com/repos/rust-lang/rust/commits/e68e5d2391c1dc200bafc39276d321d1c68bdfcc", "html_url": "https://github.com/rust-lang/rust/commit/e68e5d2391c1dc200bafc39276d321d1c68bdfcc"}, {"sha": "dec40530f71f38eaf0f853ddbbd80232ee3a5955", "url": "https://api.github.com/repos/rust-lang/rust/commits/dec40530f71f38eaf0f853ddbbd80232ee3a5955", "html_url": "https://github.com/rust-lang/rust/commit/dec40530f71f38eaf0f853ddbbd80232ee3a5955"}], "stats": {"total": 147, "additions": 73, "deletions": 74}, "files": [{"sha": "42f5d557542088a10d3da5cb673a85f494cd66e7", "filename": "compiler/rustc_borrowck/src/diagnostics/mod.rs", "status": "modified", "additions": 15, "deletions": 20, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/a4f46742c2eb724d813bca7b4834372c8fc3caa8/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4f46742c2eb724d813bca7b4834372c8fc3caa8/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Fdiagnostics%2Fmod.rs?ref=a4f46742c2eb724d813bca7b4834372c8fc3caa8", "patch": "@@ -738,15 +738,13 @@ impl BorrowedContentSource<'tcx> {\n             BorrowedContentSource::DerefRawPointer => \"a raw pointer\".to_string(),\n             BorrowedContentSource::DerefSharedRef => \"a shared reference\".to_string(),\n             BorrowedContentSource::DerefMutableRef => \"a mutable reference\".to_string(),\n-            BorrowedContentSource::OverloadedDeref(ty) => match ty.kind() {\n-                ty::Adt(def, _) if tcx.is_diagnostic_item(sym::Rc, def.did) => {\n-                    \"an `Rc`\".to_string()\n-                }\n-                ty::Adt(def, _) if tcx.is_diagnostic_item(sym::Arc, def.did) => {\n-                    \"an `Arc`\".to_string()\n-                }\n-                _ => format!(\"dereference of `{}`\", ty),\n-            },\n+            BorrowedContentSource::OverloadedDeref(ty) => ty\n+                .ty_adt_def()\n+                .and_then(|adt| match tcx.get_diagnostic_name(adt.did)? {\n+                    name @ (sym::Rc | sym::Arc) => Some(format!(\"an `{}`\", name)),\n+                    _ => None,\n+                })\n+                .unwrap_or_else(|| format!(\"dereference of `{}`\", ty)),\n             BorrowedContentSource::OverloadedIndex(ty) => format!(\"index of `{}`\", ty),\n         }\n     }\n@@ -770,15 +768,13 @@ impl BorrowedContentSource<'tcx> {\n             BorrowedContentSource::DerefMutableRef => {\n                 bug!(\"describe_for_immutable_place: DerefMutableRef isn't immutable\")\n             }\n-            BorrowedContentSource::OverloadedDeref(ty) => match ty.kind() {\n-                ty::Adt(def, _) if tcx.is_diagnostic_item(sym::Rc, def.did) => {\n-                    \"an `Rc`\".to_string()\n-                }\n-                ty::Adt(def, _) if tcx.is_diagnostic_item(sym::Arc, def.did) => {\n-                    \"an `Arc`\".to_string()\n-                }\n-                _ => format!(\"a dereference of `{}`\", ty),\n-            },\n+            BorrowedContentSource::OverloadedDeref(ty) => ty\n+                .ty_adt_def()\n+                .and_then(|adt| match tcx.get_diagnostic_name(adt.did)? {\n+                    name @ (sym::Rc | sym::Arc) => Some(format!(\"an `{}`\", name)),\n+                    _ => None,\n+                })\n+                .unwrap_or_else(|| format!(\"dereference of `{}`\", ty)),\n             BorrowedContentSource::OverloadedIndex(ty) => format!(\"an index of `{}`\", ty),\n         }\n     }\n@@ -960,8 +956,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                         _ => None,\n                     });\n                 let is_option_or_result = parent_self_ty.map_or(false, |def_id| {\n-                    tcx.is_diagnostic_item(sym::Option, def_id)\n-                        || tcx.is_diagnostic_item(sym::Result, def_id)\n+                    matches!(tcx.get_diagnostic_name(def_id), Some(sym::Option | sym::Result))\n                 });\n                 FnSelfUseKind::Normal { self_arg, implicit_into_iter, is_option_or_result }\n             });"}, {"sha": "65772d02376d43ae082a6e4b11933604c5649fb3", "filename": "compiler/rustc_lint/src/enum_intrinsics_non_enums.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/a4f46742c2eb724d813bca7b4834372c8fc3caa8/compiler%2Frustc_lint%2Fsrc%2Fenum_intrinsics_non_enums.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4f46742c2eb724d813bca7b4834372c8fc3caa8/compiler%2Frustc_lint%2Fsrc%2Fenum_intrinsics_non_enums.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fenum_intrinsics_non_enums.rs?ref=a4f46742c2eb724d813bca7b4834372c8fc3caa8", "patch": "@@ -91,16 +91,14 @@ fn enforce_mem_variant_count(cx: &LateContext<'_>, func_expr: &hir::Expr<'_>, sp\n \n impl<'tcx> LateLintPass<'tcx> for EnumIntrinsicsNonEnums {\n     fn check_expr(&mut self, cx: &LateContext<'_>, expr: &hir::Expr<'_>) {\n-        if let hir::ExprKind::Call(ref func, ref args) = expr.kind {\n-            if let hir::ExprKind::Path(ref qpath) = func.kind {\n-                if let Some(def_id) = cx.qpath_res(qpath, func.hir_id).opt_def_id() {\n-                    if cx.tcx.is_diagnostic_item(sym::mem_discriminant, def_id) {\n-                        enforce_mem_discriminant(cx, func, expr.span, args[0].span);\n-                    } else if cx.tcx.is_diagnostic_item(sym::mem_variant_count, def_id) {\n-                        enforce_mem_variant_count(cx, func, expr.span);\n-                    }\n-                }\n-            }\n+        let hir::ExprKind::Call(func, args) = &expr.kind else { return };\n+        let hir::ExprKind::Path(qpath) = &func.kind else { return };\n+        let Some(def_id) = cx.qpath_res(qpath, func.hir_id).opt_def_id() else { return };\n+        let Some(name) = cx.tcx.get_diagnostic_name(def_id) else { return };\n+        match name {\n+            sym::mem_discriminant => enforce_mem_discriminant(cx, func, expr.span, args[0].span),\n+            sym::mem_variant_count => enforce_mem_variant_count(cx, func, expr.span),\n+            _ => {}\n         }\n     }\n }"}, {"sha": "7cc40cc60d9cdf7fab5cba1bf0922441a37ef2c6", "filename": "compiler/rustc_lint/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/a4f46742c2eb724d813bca7b4834372c8fc3caa8/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4f46742c2eb724d813bca7b4834372c8fc3caa8/compiler%2Frustc_lint%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flib.rs?ref=a4f46742c2eb724d813bca7b4834372c8fc3caa8", "patch": "@@ -33,6 +33,7 @@\n #![cfg_attr(bootstrap, feature(format_args_capture))]\n #![feature(iter_order_by)]\n #![feature(iter_zip)]\n+#![feature(let_else)]\n #![feature(never_type)]\n #![feature(nll)]\n #![feature(control_flow_enum)]"}, {"sha": "4a9b27e89b19927464ef8bdf71849252261c0e70", "filename": "compiler/rustc_lint/src/non_fmt_panic.rs", "status": "modified", "additions": 13, "deletions": 6, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/a4f46742c2eb724d813bca7b4834372c8fc3caa8/compiler%2Frustc_lint%2Fsrc%2Fnon_fmt_panic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4f46742c2eb724d813bca7b4834372c8fc3caa8/compiler%2Frustc_lint%2Fsrc%2Fnon_fmt_panic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnon_fmt_panic.rs?ref=a4f46742c2eb724d813bca7b4834372c8fc3caa8", "patch": "@@ -309,14 +309,21 @@ fn panic_call<'tcx>(cx: &LateContext<'tcx>, f: &'tcx hir::Expr<'tcx>) -> (Span,\n     // Unwrap more levels of macro expansion, as panic_2015!()\n     // was likely expanded from panic!() and possibly from\n     // [debug_]assert!().\n-    for &i in\n-        &[sym::std_panic_macro, sym::core_panic_macro, sym::assert_macro, sym::debug_assert_macro]\n-    {\n+    loop {\n         let parent = expn.call_site.ctxt().outer_expn_data();\n-        if parent.macro_def_id.map_or(false, |id| cx.tcx.is_diagnostic_item(i, id)) {\n-            expn = parent;\n-            panic_macro = i;\n+        let Some(id) = parent.macro_def_id else { break };\n+        let Some(name) = cx.tcx.get_diagnostic_name(id) else { break };\n+        if !matches!(\n+            name,\n+            sym::core_panic_macro\n+                | sym::std_panic_macro\n+                | sym::assert_macro\n+                | sym::debug_assert_macro\n+        ) {\n+            break;\n         }\n+        expn = parent;\n+        panic_macro = name;\n     }\n \n     let macro_symbol ="}, {"sha": "a3a3cd0077dbefd70c80018aaf5550d93ca9b8e6", "filename": "compiler/rustc_lint/src/noop_method_call.rs", "status": "modified", "additions": 30, "deletions": 32, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/a4f46742c2eb724d813bca7b4834372c8fc3caa8/compiler%2Frustc_lint%2Fsrc%2Fnoop_method_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4f46742c2eb724d813bca7b4834372c8fc3caa8/compiler%2Frustc_lint%2Fsrc%2Fnoop_method_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fnoop_method_call.rs?ref=a4f46742c2eb724d813bca7b4834372c8fc3caa8", "patch": "@@ -75,38 +75,36 @@ impl<'tcx> LateLintPass<'tcx> for NoopMethodCall {\n             _ => return,\n         };\n         // (Re)check that it implements the noop diagnostic.\n-        for s in [sym::noop_method_clone, sym::noop_method_deref, sym::noop_method_borrow].iter() {\n-            if cx.tcx.is_diagnostic_item(*s, i.def_id()) {\n-                let method = &call.ident.name;\n-                let receiver = &elements[0];\n-                let receiver_ty = cx.typeck_results().expr_ty(receiver);\n-                let expr_ty = cx.typeck_results().expr_ty_adjusted(expr);\n-                if receiver_ty != expr_ty {\n-                    // This lint will only trigger if the receiver type and resulting expression \\\n-                    // type are the same, implying that the method call is unnecessary.\n-                    return;\n-                }\n-                let expr_span = expr.span;\n-                let note = format!(\n-                    \"the type `{:?}` which `{}` is being called on is the same as \\\n-                     the type returned from `{}`, so the method call does not do \\\n-                     anything and can be removed\",\n-                    receiver_ty, method, method,\n-                );\n-\n-                let span = expr_span.with_lo(receiver.span.hi());\n-                cx.struct_span_lint(NOOP_METHOD_CALL, span, |lint| {\n-                    let method = &call.ident.name;\n-                    let message = format!(\n-                        \"call to `.{}()` on a reference in this situation does nothing\",\n-                        &method,\n-                    );\n-                    lint.build(&message)\n-                        .span_label(span, \"unnecessary method call\")\n-                        .note(&note)\n-                        .emit()\n-                });\n-            }\n+        let Some(name) = cx.tcx.get_diagnostic_name(i.def_id()) else { return };\n+        if !matches!(\n+            name,\n+            sym::noop_method_borrow | sym::noop_method_clone | sym::noop_method_deref\n+        ) {\n+            return;\n         }\n+        let method = &call.ident.name;\n+        let receiver = &elements[0];\n+        let receiver_ty = cx.typeck_results().expr_ty(receiver);\n+        let expr_ty = cx.typeck_results().expr_ty_adjusted(expr);\n+        if receiver_ty != expr_ty {\n+            // This lint will only trigger if the receiver type and resulting expression \\\n+            // type are the same, implying that the method call is unnecessary.\n+            return;\n+        }\n+        let expr_span = expr.span;\n+        let note = format!(\n+            \"the type `{:?}` which `{}` is being called on is the same as \\\n+             the type returned from `{}`, so the method call does not do \\\n+             anything and can be removed\",\n+            receiver_ty, method, method,\n+        );\n+\n+        let span = expr_span.with_lo(receiver.span.hi());\n+        cx.struct_span_lint(NOOP_METHOD_CALL, span, |lint| {\n+            let method = &call.ident.name;\n+            let message =\n+                format!(\"call to `.{}()` on a reference in this situation does nothing\", &method,);\n+            lint.build(&message).span_label(span, \"unnecessary method call\").note(&note).emit()\n+        });\n     }\n }"}, {"sha": "72339da571df4d7eb1b2ca56d28a7c9ad3799170", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/a4f46742c2eb724d813bca7b4834372c8fc3caa8/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4f46742c2eb724d813bca7b4834372c8fc3caa8/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=a4f46742c2eb724d813bca7b4834372c8fc3caa8", "patch": "@@ -539,11 +539,6 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         // is otherwise overwhelming and unhelpful (see #85844 for an\n                         // example).\n \n-                        let trait_is_debug =\n-                            self.tcx.is_diagnostic_item(sym::Debug, trait_ref.def_id());\n-                        let trait_is_display =\n-                            self.tcx.is_diagnostic_item(sym::Display, trait_ref.def_id());\n-\n                         let in_std_macro =\n                             match obligation.cause.span.ctxt().outer_expn_data().macro_def_id {\n                                 Some(macro_def_id) => {\n@@ -553,7 +548,12 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                                 None => false,\n                             };\n \n-                        if in_std_macro && (trait_is_debug || trait_is_display) {\n+                        if in_std_macro\n+                            && matches!(\n+                                self.tcx.get_diagnostic_name(trait_ref.def_id()),\n+                                Some(sym::Debug | sym::Display)\n+                            )\n+                        {\n                             err.emit();\n                             return;\n                         }"}]}