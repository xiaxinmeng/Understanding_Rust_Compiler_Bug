{"sha": "eafab660964bcd1e2c8b19cc2021cc5c7fee6c38", "node_id": "C_kwDOAAsO6NoAKGVhZmFiNjYwOTY0YmNkMWUyYzhiMTljYzIwMjFjYzVjN2ZlZTZjMzg", "commit": {"author": {"name": "Nilstrieb", "email": "48135649+Nilstrieb@users.noreply.github.com", "date": "2022-07-26T13:11:12Z"}, "committer": {"name": "Nilstrieb", "email": "48135649+Nilstrieb@users.noreply.github.com", "date": "2022-08-21T19:15:28Z"}, "message": "UnreachableProp: Preserve unreachable branches for multiple targets\n\nBefore, UnreachablePropagation removed all unreachable branches.\nThis was a pessimization, as it removed information about\nreachability that was used later in the optimization pipeline.\n\nFor example, this code\n```rust\npub enum Two { A, B }\npub fn identity(x: Two) -> Two {\n    match x {\n        Two::A => Two::A,\n        Two::B => Two::B,\n    }\n}\n```\n\nbasically has `switchInt() -> [0: 0, 1: 1, otherwise: unreachable]` for the match.\nThis allows it to be transformed into a simple `x`. If we remove the\nunreachable branch, the transformation becomes illegal.", "tree": {"sha": "9a536e2b4f06a87280239be011c7325ff5b055c4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9a536e2b4f06a87280239be011c7325ff5b055c4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eafab660964bcd1e2c8b19cc2021cc5c7fee6c38", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eafab660964bcd1e2c8b19cc2021cc5c7fee6c38", "html_url": "https://github.com/rust-lang/rust/commit/eafab660964bcd1e2c8b19cc2021cc5c7fee6c38", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eafab660964bcd1e2c8b19cc2021cc5c7fee6c38/comments", "author": {"login": "Nilstrieb", "id": 48135649, "node_id": "MDQ6VXNlcjQ4MTM1NjQ5", "avatar_url": "https://avatars.githubusercontent.com/u/48135649?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nilstrieb", "html_url": "https://github.com/Nilstrieb", "followers_url": "https://api.github.com/users/Nilstrieb/followers", "following_url": "https://api.github.com/users/Nilstrieb/following{/other_user}", "gists_url": "https://api.github.com/users/Nilstrieb/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nilstrieb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nilstrieb/subscriptions", "organizations_url": "https://api.github.com/users/Nilstrieb/orgs", "repos_url": "https://api.github.com/users/Nilstrieb/repos", "events_url": "https://api.github.com/users/Nilstrieb/events{/privacy}", "received_events_url": "https://api.github.com/users/Nilstrieb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Nilstrieb", "id": 48135649, "node_id": "MDQ6VXNlcjQ4MTM1NjQ5", "avatar_url": "https://avatars.githubusercontent.com/u/48135649?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nilstrieb", "html_url": "https://github.com/Nilstrieb", "followers_url": "https://api.github.com/users/Nilstrieb/followers", "following_url": "https://api.github.com/users/Nilstrieb/following{/other_user}", "gists_url": "https://api.github.com/users/Nilstrieb/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nilstrieb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nilstrieb/subscriptions", "organizations_url": "https://api.github.com/users/Nilstrieb/orgs", "repos_url": "https://api.github.com/users/Nilstrieb/repos", "events_url": "https://api.github.com/users/Nilstrieb/events{/privacy}", "received_events_url": "https://api.github.com/users/Nilstrieb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "650bff80a623e17675ac72ae4d62ed200a4a3568", "url": "https://api.github.com/repos/rust-lang/rust/commits/650bff80a623e17675ac72ae4d62ed200a4a3568", "html_url": "https://github.com/rust-lang/rust/commit/650bff80a623e17675ac72ae4d62ed200a4a3568"}], "stats": {"total": 71, "additions": 48, "deletions": 23}, "files": [{"sha": "a7e522beeab1b3abc1bd5e12aaf01b07914b7add", "filename": "compiler/rustc_mir_transform/src/unreachable_prop.rs", "status": "modified", "additions": 48, "deletions": 23, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/eafab660964bcd1e2c8b19cc2021cc5c7fee6c38/compiler%2Frustc_mir_transform%2Fsrc%2Funreachable_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eafab660964bcd1e2c8b19cc2021cc5c7fee6c38/compiler%2Frustc_mir_transform%2Fsrc%2Funreachable_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_transform%2Fsrc%2Funreachable_prop.rs?ref=eafab660964bcd1e2c8b19cc2021cc5c7fee6c38", "patch": "@@ -38,7 +38,19 @@ impl MirPass<'_> for UnreachablePropagation {\n             }\n         }\n \n+        // We do want do keep some unreachable blocks, but make them empty.\n+        for bb in unreachable_blocks {\n+            if !tcx.consider_optimizing(|| {\n+                format!(\"UnreachablePropagation {:?} \", body.source.def_id())\n+            }) {\n+                break;\n+            }\n+\n+            body.basic_blocks_mut()[bb].statements.clear();\n+        }\n+\n         let replaced = !replacements.is_empty();\n+\n         for (bb, terminator_kind) in replacements {\n             if !tcx.consider_optimizing(|| {\n                 format!(\"UnreachablePropagation {:?} \", body.source.def_id())\n@@ -57,42 +69,55 @@ impl MirPass<'_> for UnreachablePropagation {\n \n fn remove_successors<'tcx, F>(\n     terminator_kind: &TerminatorKind<'tcx>,\n-    predicate: F,\n+    is_unreachable: F,\n ) -> Option<TerminatorKind<'tcx>>\n where\n     F: Fn(BasicBlock) -> bool,\n {\n-    let terminator = match *terminator_kind {\n-        TerminatorKind::Goto { target } if predicate(target) => TerminatorKind::Unreachable,\n-        TerminatorKind::SwitchInt { ref discr, switch_ty, ref targets } => {\n+    let terminator = match terminator_kind {\n+        // This will unconditionally run into an unreachable and is therefore unreachable as well.\n+        TerminatorKind::Goto { target } if is_unreachable(*target) => TerminatorKind::Unreachable,\n+        TerminatorKind::SwitchInt { targets, discr, switch_ty } => {\n             let otherwise = targets.otherwise();\n \n-            let original_targets_len = targets.iter().len() + 1;\n-            let (mut values, mut targets): (Vec<_>, Vec<_>) =\n-                targets.iter().filter(|(_, bb)| !predicate(*bb)).unzip();\n+            // If all targets are unreachable, we can be unreachable as well.\n+            if targets.all_targets().iter().all(|bb| is_unreachable(*bb)) {\n+                TerminatorKind::Unreachable\n+            } else if is_unreachable(otherwise) {\n+                // If there are multiple targets, don't delete unreachable branches (like an unreachable otherwise)\n+                // unless otherwise is unrachable, in which case deleting a normal branch causes it to be merged with\n+                // the otherwise, keeping its unreachable.\n+                // This looses information about reachability causing worse codegen.\n+                // For example (see src/test/codegen/match-optimizes-away.rs)\n+                //\n+                // pub enum Two { A, B }\n+                // pub fn identity(x: Two) -> Two {\n+                //     match x {\n+                //         Two::A => Two::A,\n+                //         Two::B => Two::B,\n+                //     }\n+                // }\n+                //\n+                // This generates a `switchInt() -> [0: 0, 1: 1, otherwise: unreachable]`, which allows us or LLVM to\n+                // turn it into just `x` later. Without the unreachable, such a transformation would be illegal.\n+                // If the otherwise branch is unreachable, we can delete all other unreacahble targets, as they will\n+                // still point to the unreachable and therefore not lose reachability information.\n+                let reachable_iter = targets.iter().filter(|(_, bb)| !is_unreachable(*bb));\n \n-            if !predicate(otherwise) {\n-                targets.push(otherwise);\n-            } else {\n-                values.pop();\n-            }\n+                let new_targets = SwitchTargets::new(reachable_iter, otherwise);\n \n-            let retained_targets_len = targets.len();\n+                // No unreachable branches were removed.\n+                if new_targets.all_targets().len() == targets.all_targets().len() {\n+                    return None;\n+                }\n \n-            if targets.is_empty() {\n-                TerminatorKind::Unreachable\n-            } else if targets.len() == 1 {\n-                TerminatorKind::Goto { target: targets[0] }\n-            } else if original_targets_len != retained_targets_len {\n                 TerminatorKind::SwitchInt {\n                     discr: discr.clone(),\n-                    switch_ty,\n-                    targets: SwitchTargets::new(\n-                        values.iter().copied().zip(targets.iter().copied()),\n-                        *targets.last().unwrap(),\n-                    ),\n+                    switch_ty: *switch_ty,\n+                    targets: new_targets,\n                 }\n             } else {\n+                // If the otherwise branch is reachable, we don't want to delete any unreachable branches.\n                 return None;\n             }\n         }"}]}