{"sha": "30c272cb3a42cfd842736ddb90133362fe899290", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMwYzI3MmNiM2E0MmNmZDg0MjczNmRkYjkwMTMzMzYyZmU4OTkyOTA=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-03-21T19:42:34Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2012-03-21T20:53:21Z"}, "message": "methods work\n\nCross-crate method calls don't work yet. Added\nrun-pass/class-method-cross-crate to test that, but it's xfailed\n\nReferences to fields within methods don't work yet. Added\nrun-pass/class-methods to test that, but it's also xfailed", "tree": {"sha": "5daa1ceb5c4570640b5d0a587b89cd350c985d6d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5daa1ceb5c4570640b5d0a587b89cd350c985d6d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/30c272cb3a42cfd842736ddb90133362fe899290", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/30c272cb3a42cfd842736ddb90133362fe899290", "html_url": "https://github.com/rust-lang/rust/commit/30c272cb3a42cfd842736ddb90133362fe899290", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/30c272cb3a42cfd842736ddb90133362fe899290/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3e474424714f8e24fd1237d77cf88a3b35a495e5", "url": "https://api.github.com/repos/rust-lang/rust/commits/3e474424714f8e24fd1237d77cf88a3b35a495e5", "html_url": "https://github.com/rust-lang/rust/commit/3e474424714f8e24fd1237d77cf88a3b35a495e5"}], "stats": {"total": 201, "additions": 162, "deletions": 39}, "files": [{"sha": "58192a8f163b6d7a1058fdb8bf7779867bfa63b5", "filename": "src/rustc/metadata/csearch.rs", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/30c272cb3a42cfd842736ddb90133362fe899290/src%2Frustc%2Fmetadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30c272cb3a42cfd842736ddb90133362fe899290/src%2Frustc%2Fmetadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fcsearch.rs?ref=30c272cb3a42cfd842736ddb90133362fe899290", "patch": "@@ -13,6 +13,7 @@ import std::map::hashmap;\n \n export get_symbol;\n export get_class_fields;\n+// export get_class_method_ids;\n export get_field_type;\n export get_type_param_count;\n export lookup_defs;\n@@ -127,9 +128,17 @@ fn get_iface_methods(tcx: ty::ctxt, def: ast::def_id) -> @[ty::method] {\n fn get_class_fields(tcx: ty::ctxt, def: ast::def_id) -> [ty::field_ty] {\n     let cstore = tcx.sess.cstore;\n     let cdata = cstore::get_crate_data(cstore, def.crate);\n-    decoder::get_class_fields(tcx, cdata, def.node)\n+    decoder::get_class_fields(cdata, def.node)\n }\n \n+/*\n+fn get_class_method_ids(tcx: ty::ctxt, def: ast::def_id) -> [ty::field_ty] {\n+    let cstore = tcx.sess.cstore;\n+    let cdata = cstore::get_crate_data(cstore, def.crate);\n+    decoder::get_class_method_ids(cdata, def.node)\n+}\n+*/\n+\n fn get_type(tcx: ty::ctxt, def: ast::def_id) -> ty::ty_param_bounds_and_ty {\n     let cstore = tcx.sess.cstore;\n     let cdata = cstore::get_crate_data(cstore, def.crate);"}, {"sha": "f4e213e5157157a001b7108b3f612670b15c2435", "filename": "src/rustc/metadata/decoder.rs", "status": "modified", "additions": 24, "deletions": 14, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/30c272cb3a42cfd842736ddb90133362fe899290/src%2Frustc%2Fmetadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30c272cb3a42cfd842736ddb90133362fe899290/src%2Frustc%2Fmetadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmetadata%2Fdecoder.rs?ref=30c272cb3a42cfd842736ddb90133362fe899290", "patch": "@@ -17,6 +17,7 @@ import middle::trans::common::maps;\n import util::ppaux::ty_to_str;\n \n export get_class_fields;\n+// export get_class_method_ids;\n export get_symbol;\n export get_enum_variants;\n export get_type;\n@@ -113,7 +114,7 @@ fn item_parent_item(d: ebml::doc) -> option<ast::def_id> {\n     found\n }\n \n-fn class_field_id(d: ebml::doc, cdata: cmd) -> ast::def_id {\n+fn class_member_id(d: ebml::doc, cdata: cmd) -> ast::def_id {\n     let tagdoc = ebml::get_doc(d, tag_def_id);\n     ret translate_def_id(cdata, parse_def_id(ebml::doc_data(tagdoc)));\n }\n@@ -408,27 +409,36 @@ fn get_iface_methods(cdata: cmd, id: ast::node_id, tcx: ty::ctxt)\n     @result\n }\n \n-/* Take a node ID for a class, return a vector of the class's\n-   field names/IDs */\n-fn get_class_fields(tcx: ty::ctxt,\n-               cdata: cmd, id: ast::node_id) -> [ty::field_ty] {\n+// Helper function that gets either fields or methods\n+fn get_class_members(cdata: cmd, id: ast::node_id,\n+                     family: char) -> [ty::field_ty] {\n     let data = cdata.data;\n     let item = lookup_item(id, data), result = [];\n     ebml::tagged_docs(item, tag_items_data_item) {|an_item|\n-        let fam = item_family(an_item);\n-        alt fam {\n-         'g' {\n-             let name = item_name(an_item);\n-             let _ty = doc_type(an_item, tcx, cdata);\n-             let did = class_field_id(an_item, cdata);\n-             result += [{ident: name, id: did}];\n-         }\n-        _ { /* this only handles fields */}\n+       if item_family(an_item) == family {\n+          let name = item_name(an_item);\n+          let did = class_member_id(an_item, cdata);\n+          result += [{ident: name, id: did}];\n        }\n     }\n     result\n }\n \n+\n+/* Take a node ID for a class, return a vector of the class's\n+   field names/IDs */\n+fn get_class_fields(cdata: cmd, id: ast::node_id) -> [ty::field_ty] {\n+    get_class_members(cdata, id, 'g')\n+}\n+\n+/*\n+/* Take a node ID for a class, return a vector of the class's\n+   method names/IDs */\n+fn get_class_method_ids(cdata: cmd, id: ast::node_id) -> [ty::field_ty] {\n+    get_class_members(cdata, id, 'h')\n+}\n+*/\n+\n fn family_has_type_params(fam_ch: char) -> bool {\n     alt check fam_ch {\n       'c' | 'T' | 'm' | 'n' | 'g' | 'h' { false }"}, {"sha": "648ac24208a576b3ec56b19131fc8992e4ac87bb", "filename": "src/rustc/middle/trans/base.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/30c272cb3a42cfd842736ddb90133362fe899290/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30c272cb3a42cfd842736ddb90133362fe899290/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=30c272cb3a42cfd842736ddb90133362fe899290", "patch": "@@ -4194,7 +4194,10 @@ fn trans_item(ccx: @crate_ctxt, item: ast::item) {\n         trans_fn(ccx, *path + [path_name(item.ident)], ctor.node.dec,\n                  ctor_body__, llctor_decl, no_self,\n                  none, ctor.node.id, some(rslt_expr));\n-        // TODO: translate methods!\n+        // Translate methods\n+        let (_, ms) = ast_util::split_class_items(items);\n+        // not sure how this is going to work what with \"self\" and fields\n+        impl::trans_impl(ccx, *path, item.ident, ms, tps);\n       }\n       _ {/* fall through */ }\n     }"}, {"sha": "47e60cc530b829884758f56460ac7afb7954a8c7", "filename": "src/rustc/middle/ty.rs", "status": "modified", "additions": 38, "deletions": 2, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/30c272cb3a42cfd842736ddb90133362fe899290/src%2Frustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30c272cb3a42cfd842736ddb90133362fe899290/src%2Frustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Fty.rs?ref=30c272cb3a42cfd842736ddb90133362fe899290", "patch": "@@ -6,6 +6,7 @@ import session::session;\n import syntax::ast;\n import syntax::ast::*;\n import syntax::ast_util;\n+import syntax::ast_util::{is_local, split_class_items};\n import syntax::codemap::span;\n import metadata::csearch;\n import util::common::*;\n@@ -41,6 +42,7 @@ export get_element_type;\n export is_binopable;\n export is_pred_ty;\n export lookup_class_fields;\n+export lookup_class_method_by_name;\n export lookup_field_type;\n export lookup_item_type;\n export method;\n@@ -2523,7 +2525,7 @@ fn lookup_field_type(tcx: ctxt, class_id: def_id, id: def_id) -> ty::t {\n     }\n }\n \n-// Look up the list of item types for a given class\n+// Look up the list of field names and IDs for a given class\n // Fails if the id is not bound to a class.\n fn lookup_class_fields(cx: ctxt, did: ast::def_id) -> [field_ty] {\n   if did.crate == ast::local_crate {\n@@ -2544,7 +2546,41 @@ fn lookup_class_fields(cx: ctxt, did: ast::def_id) -> [field_ty] {\n     }\n }\n \n-// must be called after typechecking?\n+// Look up the list of method names and IDs for a given class\n+// Fails if the id is not bound to a class.\n+fn lookup_class_method_ids(cx: ctxt, did: ast::def_id)\n+    : is_local(did) -> [{name: ident, id: node_id}] {\n+    alt cx.items.find(did.node) {\n+       some(ast_map::node_item(@{node: item_class(_,items,_), _}, _)) {\n+         let (_,ms) = split_class_items(items);\n+         vec::map(ms, {|m| {name: m.ident, id: m.id}})\n+       }\n+       _ {\n+           cx.sess.bug(\"lookup_class_method_ids: id not bound to a class\");\n+       }\n+    }\n+}\n+\n+/* Given a class def_id and a method name, return the method's\n+ def_id. Needed so we can do static dispatch for methods */\n+fn lookup_class_method_by_name(cx:ctxt, did: ast::def_id, name: ident,\n+                               sp: span) ->\n+    def_id {\n+    if check is_local(did) {\n+       let ms = lookup_class_method_ids(cx, did);\n+       for m in ms {\n+         if m.name == name {\n+             ret ast_util::local_def(m.id);\n+         }\n+       }\n+       cx.sess.span_fatal(sp, #fmt(\"Class doesn't have a method named %s\",\n+                                  name));\n+    }\n+    else {\n+      csearch::get_impl_method(cx.sess.cstore, did, name)\n+    }\n+}\n+\n fn class_field_tys(items: [@class_item]) -> [field_ty] {\n     let rslt = [];\n     for it in items {"}, {"sha": "eb4f87c824fd8f3bf92dcdc899604b41c4ba9321", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 33, "deletions": 14, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/30c272cb3a42cfd842736ddb90133362fe899290/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30c272cb3a42cfd842736ddb90133362fe899290/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=30c272cb3a42cfd842736ddb90133362fe899290", "patch": "@@ -893,11 +893,20 @@ mod collect {\n         }\n     }\n     fn ensure_iface_methods(tcx: ty::ctxt, id: ast::node_id) {\n+        fn store_methods<T>(tcx: ty::ctxt, id: ast::node_id,\n+                            stuff: [T], f: fn@(T) -> ty::method) {\n+            ty::store_iface_methods(tcx, id, @vec::map(stuff, f));\n+        }\n+\n         alt check tcx.items.get(id) {\n           ast_map::node_item(@{node: ast::item_iface(_, ms), _}, _) {\n-            ty::store_iface_methods(tcx, id, @vec::map(ms, {|m|\n-                ty_of_ty_method(tcx, m_collect, m)\n-            }));\n+              store_methods::<ast::ty_method>(tcx, id, ms, {|m|\n+                          ty_of_ty_method(tcx, m_collect, m)});\n+          }\n+          ast_map::node_item(@{node: ast::item_class(_,its,_), _}, _) {\n+              let (_,ms) = split_class_items(its);\n+              store_methods::<@ast::method>(tcx, id, ms, {|m|\n+                          ty_of_method(tcx, m_collect, m)});\n           }\n         }\n     }\n@@ -1038,13 +1047,17 @@ mod collect {\n               write_ty(tcx, ctor.node.id, t_ctor);\n               tcx.tcache.insert(local_def(ctor.node.id),\n                                    {bounds: tpt.bounds, ty: t_ctor});\n+              ensure_iface_methods(tcx, it.id);\n               /* FIXME: check for proper public/privateness */\n               // Write the type of each of the members\n               let (fields, methods) = split_class_items(members);\n               for f in fields {\n                  convert_class_item(tcx, f);\n               }\n-              convert_methods(tcx, methods, @[], none);\n+              let selfty = ty::mk_class(tcx, local_def(it.id),\n+                                        mk_ty_params(tcx, tps).params);\n+              // The selfty is just the class type\n+              convert_methods(tcx, methods, @[], some(selfty));\n           }\n           _ {\n             // This call populates the type cache with the converted type\n@@ -1854,13 +1867,13 @@ fn lookup_method(fcx: @fn_ctxt, expr: @ast::expr, node_id: ast::node_id,\n     }\n }\n \n-enum method_parent {\n-    cls(ast::def_id),\n+enum method_kind {\n+    cls(ast::def_id), // *method* id (in both cases)\n     an_iface(ast::def_id)\n }\n \n fn lookup_method_inner_(tcx: ty::ctxt, ms: [ty::method],\n-    tps: [ty::t], parent: method_parent, name: ast::ident, sp: span)\n+    tps: [ty::t], parent: method_kind, name: ast::ident, sp: span)\n     -> option<{method_ty: ty::t, n_tps: uint, substs: [ty::t],\n         origin: method_origin, self_sub: option<self_subst>}> {\n     #debug(\"lookup_method_inner_: %? %? %s\", ms, parent, name);\n@@ -1878,13 +1891,19 @@ fn lookup_method_inner_(tcx: ty::ctxt, ms: [ty::method],\n                                     boxed iface\");\n           }\n           ret some({method_ty: fty,\n-                          n_tps: vec::len(*m.tps),\n-                          substs: tps,\n-                          origin: alt parent {\n-                                    cls(did) { method_static(did) }\n-                                    an_iface(did) { method_iface(did, i) }\n-                          },\n-                      self_sub: none});\n+                    n_tps: vec::len(*m.tps),\n+                    substs: tps,\n+                    origin: alt parent {\n+                      cls(parent_id)          {\n+                        // look up method named <name>\n+                        // its id is did\n+                        let m_declared = ty::lookup_class_method_by_name(tcx,\n+                                            parent_id, name, sp);\n+                        method_static(m_declared)\n+                      }\n+                      an_iface(did) { method_iface(did, i) }\n+                      },\n+                    self_sub: none});\n        }\n        i += 1u;\n     }"}, {"sha": "7af080a2535e1016742116c4a6e38d0195105ad3", "filename": "src/rustc/syntax/ast_util.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/30c272cb3a42cfd842736ddb90133362fe899290/src%2Frustc%2Fsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30c272cb3a42cfd842736ddb90133362fe899290/src%2Frustc%2Fsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fsyntax%2Fast_util.rs?ref=30c272cb3a42cfd842736ddb90133362fe899290", "patch": "@@ -17,7 +17,9 @@ fn path_name(p: @path) -> str { path_name_i(p.node.idents) }\n \n fn path_name_i(idents: [ident]) -> str { str::connect(idents, \"::\") }\n \n-fn local_def(id: node_id) -> def_id { ret {crate: local_crate, node: id}; }\n+fn local_def(id: node_id) -> def_id { {crate: local_crate, node: id} }\n+\n+pure fn is_local(did: ast::def_id) -> bool { did.crate == local_crate }\n \n fn stmt_id(s: stmt) -> node_id {\n     alt s.node {"}, {"sha": "50a5bf1e6240c67e301662df84ec9e647c94b9d6", "filename": "src/test/auxiliary/cci_class_2.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/30c272cb3a42cfd842736ddb90133362fe899290/src%2Ftest%2Fauxiliary%2Fcci_class_2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30c272cb3a42cfd842736ddb90133362fe899290/src%2Ftest%2Fauxiliary%2Fcci_class_2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fauxiliary%2Fcci_class_2.rs?ref=30c272cb3a42cfd842736ddb90133362fe899290", "patch": "@@ -0,0 +1,15 @@\n+mod kitties {\n+\n+class cat {\n+  priv {\n+    let mutable meows : uint;\n+  }\n+\n+  let how_hungry : int;\n+\n+  new(in_x : uint, in_y : int) { meows = in_x; how_hungry = in_y; }\n+\n+  fn speak() {}\n+}\n+\n+}"}, {"sha": "1d79fa3f56d504c93cf04dcc550b4251b61e4259", "filename": "src/test/run-pass/class-method-cross-crate.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/30c272cb3a42cfd842736ddb90133362fe899290/src%2Ftest%2Frun-pass%2Fclass-method-cross-crate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30c272cb3a42cfd842736ddb90133362fe899290/src%2Ftest%2Frun-pass%2Fclass-method-cross-crate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-method-cross-crate.rs?ref=30c272cb3a42cfd842736ddb90133362fe899290", "patch": "@@ -0,0 +1,13 @@\n+// xfail-test\n+// xfail-fast\n+// aux-build:cci_class_2.rs\n+use cci_class;\n+import cci_class::kitties::*;\n+\n+fn main() {\n+  let nyan : cat = cat(52u, 99);\n+  let kitty = cat(1000u, 2);\n+  assert(nyan.how_hungry == 99);\n+  assert(kitty.how_hungry == 2);\n+  nyan.speak();\n+}"}, {"sha": "e9587b752cbde5a8f87727fac48b4de85f8abf0d", "filename": "src/test/run-pass/class-methods.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/30c272cb3a42cfd842736ddb90133362fe899290/src%2Ftest%2Frun-pass%2Fclass-methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30c272cb3a42cfd842736ddb90133362fe899290/src%2Ftest%2Frun-pass%2Fclass-methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclass-methods.rs?ref=30c272cb3a42cfd842736ddb90133362fe899290", "patch": "@@ -0,0 +1,22 @@\n+// xfail-test\n+class cat {\n+  priv {\n+    let mutable meows : uint;\n+  }\n+\n+  let how_hungry : int;\n+\n+  new(in_x : uint, in_y : int) { meows = in_x; how_hungry = in_y; }\n+\n+  fn speak() { meows += 1u; }\n+  fn meow_count() -> uint { meows }\n+}\n+\n+fn main() {\n+  let nyan : cat = cat(52u, 99);\n+  let kitty = cat(1000u, 2);\n+  assert(nyan.how_hungry == 99);\n+  assert(kitty.how_hungry == 2);\n+  nyan.speak();\n+  assert(nyan.meow_count() == 53u);\n+}"}, {"sha": "62084958d5a17e6d0d384f671c95c647757cb41f", "filename": "src/test/run-pass/classes-simple-method.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/30c272cb3a42cfd842736ddb90133362fe899290/src%2Ftest%2Frun-pass%2Fclasses-simple-method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/30c272cb3a42cfd842736ddb90133362fe899290/src%2Ftest%2Frun-pass%2Fclasses-simple-method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fclasses-simple-method.rs?ref=30c272cb3a42cfd842736ddb90133362fe899290", "patch": "@@ -1,4 +1,3 @@\n-// xfail-test\n class cat {\n   priv {\n     let mutable meows : uint;\n@@ -9,10 +8,6 @@ class cat {\n   new(in_x : uint, in_y : int) { meows = in_x; how_hungry = in_y; }\n \n   fn speak() {}\n-  /*\n-  fn speak() { meows += 1u; }\n-  fn meow_count() -> uint { meows }\n-  */\n }\n \n fn main() {\n@@ -21,5 +16,4 @@ fn main() {\n   assert(nyan.how_hungry == 99);\n   assert(kitty.how_hungry == 2);\n   nyan.speak();\n-  //  assert(nyan.meow_count() == 53u);\n }"}]}