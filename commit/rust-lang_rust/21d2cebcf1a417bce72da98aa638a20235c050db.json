{"sha": "21d2cebcf1a417bce72da98aa638a20235c050db", "node_id": "MDY6Q29tbWl0NzI0NzEyOjIxZDJjZWJjZjFhNDE3YmNlNzJkYTk4YWE2MzhhMjAyMzVjMDUwZGI=", "commit": {"author": {"name": "David Lattimore", "email": "dml@google.com", "date": "2020-08-01T02:43:10Z"}, "committer": {"name": "David Lattimore", "email": "dml@google.com", "date": "2020-08-01T02:55:26Z"}, "message": "SSR: Matching trait associated constants, types and functions\n\nThis fixes matching of things like `HashMap::default()` by resolving\n`HashMap` instead of `default` (which resolves to `Default::default`).\n\nSame for associated constants and types that are part of a trait\nimplementation.\n\nHowever, we still don't support matching calls to trait methods.", "tree": {"sha": "5b89fe4b74fef8ce71da396d903f18e2a2ea9da2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5b89fe4b74fef8ce71da396d903f18e2a2ea9da2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/21d2cebcf1a417bce72da98aa638a20235c050db", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/21d2cebcf1a417bce72da98aa638a20235c050db", "html_url": "https://github.com/rust-lang/rust/commit/21d2cebcf1a417bce72da98aa638a20235c050db", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/21d2cebcf1a417bce72da98aa638a20235c050db/comments", "author": {"login": "davidlattimore", "id": 8983542, "node_id": "MDQ6VXNlcjg5ODM1NDI=", "avatar_url": "https://avatars.githubusercontent.com/u/8983542?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidlattimore", "html_url": "https://github.com/davidlattimore", "followers_url": "https://api.github.com/users/davidlattimore/followers", "following_url": "https://api.github.com/users/davidlattimore/following{/other_user}", "gists_url": "https://api.github.com/users/davidlattimore/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidlattimore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidlattimore/subscriptions", "organizations_url": "https://api.github.com/users/davidlattimore/orgs", "repos_url": "https://api.github.com/users/davidlattimore/repos", "events_url": "https://api.github.com/users/davidlattimore/events{/privacy}", "received_events_url": "https://api.github.com/users/davidlattimore/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidlattimore", "id": 8983542, "node_id": "MDQ6VXNlcjg5ODM1NDI=", "avatar_url": "https://avatars.githubusercontent.com/u/8983542?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidlattimore", "html_url": "https://github.com/davidlattimore", "followers_url": "https://api.github.com/users/davidlattimore/followers", "following_url": "https://api.github.com/users/davidlattimore/following{/other_user}", "gists_url": "https://api.github.com/users/davidlattimore/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidlattimore/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidlattimore/subscriptions", "organizations_url": "https://api.github.com/users/davidlattimore/orgs", "repos_url": "https://api.github.com/users/davidlattimore/repos", "events_url": "https://api.github.com/users/davidlattimore/events{/privacy}", "received_events_url": "https://api.github.com/users/davidlattimore/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5af32aeb2b83c7ae8adf3e088bf4f3691aa45eb1", "url": "https://api.github.com/repos/rust-lang/rust/commits/5af32aeb2b83c7ae8adf3e088bf4f3691aa45eb1", "html_url": "https://github.com/rust-lang/rust/commit/5af32aeb2b83c7ae8adf3e088bf4f3691aa45eb1"}], "stats": {"total": 99, "additions": 93, "deletions": 6}, "files": [{"sha": "8be862fd6e1d74de334703742a355b0de1befa8b", "filename": "crates/ra_ide/src/ssr.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/21d2cebcf1a417bce72da98aa638a20235c050db/crates%2Fra_ide%2Fsrc%2Fssr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21d2cebcf1a417bce72da98aa638a20235c050db/crates%2Fra_ide%2Fsrc%2Fssr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fssr.rs?ref=21d2cebcf1a417bce72da98aa638a20235c050db", "patch": "@@ -21,8 +21,8 @@ use ra_ssr::{MatchFinder, SsrError, SsrRule};\n // replacement occurs. For example if our replacement template is `foo::Bar` and we match some\n // code in the `foo` module, we'll insert just `Bar`.\n //\n-// Method calls should generally be written in UFCS form. e.g. `foo::Bar::baz($s, $a)` will match\n-// `$s.baz($a)`, provided the method call `baz` resolves to the method `foo::Bar::baz`.\n+// Inherent method calls should generally be written in UFCS form. e.g. `foo::Bar::baz($s, $a)` will\n+// match `$s.baz($a)`, provided the method call `baz` resolves to the method `foo::Bar::baz`.\n //\n // The scope of the search / replace will be restricted to the current selection if any, otherwise\n // it will apply to the whole workspace."}, {"sha": "d5b65eaacf20a78dda5ef97ea1e6e5480eeea13f", "filename": "crates/ra_ssr/src/resolving.rs", "status": "modified", "additions": 27, "deletions": 4, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/21d2cebcf1a417bce72da98aa638a20235c050db/crates%2Fra_ssr%2Fsrc%2Fresolving.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21d2cebcf1a417bce72da98aa638a20235c050db/crates%2Fra_ssr%2Fsrc%2Fresolving.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Fresolving.rs?ref=21d2cebcf1a417bce72da98aa638a20235c050db", "patch": "@@ -5,7 +5,7 @@ use crate::{parsing, SsrError};\n use parsing::Placeholder;\n use ra_db::FilePosition;\n use ra_syntax::{ast, SmolStr, SyntaxKind, SyntaxNode, SyntaxToken};\n-use rustc_hash::{FxHashMap, FxHashSet};\n+use rustc_hash::FxHashMap;\n use test_utils::mark;\n \n pub(crate) struct ResolutionScope<'db> {\n@@ -111,8 +111,10 @@ impl Resolver<'_, '_> {\n                     .resolution_scope\n                     .resolve_path(&path)\n                     .ok_or_else(|| error!(\"Failed to resolve path `{}`\", node.text()))?;\n-                resolved_paths.insert(node, ResolvedPath { resolution, depth });\n-                return Ok(());\n+                if self.ok_to_use_path_resolution(&resolution) {\n+                    resolved_paths.insert(node, ResolvedPath { resolution, depth });\n+                    return Ok(());\n+                }\n             }\n         }\n         for node in node.children() {\n@@ -136,6 +138,27 @@ impl Resolver<'_, '_> {\n         }\n         false\n     }\n+\n+    fn ok_to_use_path_resolution(&self, resolution: &hir::PathResolution) -> bool {\n+        match resolution {\n+            hir::PathResolution::AssocItem(hir::AssocItem::Function(function)) => {\n+                if function.has_self_param(self.resolution_scope.scope.db) {\n+                    // If we don't use this path resolution, then we won't be able to match method\n+                    // calls. e.g. `Foo::bar($s)` should match `x.bar()`.\n+                    true\n+                } else {\n+                    mark::hit!(replace_associated_trait_default_function_call);\n+                    false\n+                }\n+            }\n+            hir::PathResolution::AssocItem(_) => {\n+                // Not a function. Could be a constant or an associated type.\n+                mark::hit!(replace_associated_trait_constant);\n+                false\n+            }\n+            _ => true,\n+        }\n+    }\n }\n \n impl<'db> ResolutionScope<'db> {\n@@ -176,7 +199,7 @@ impl<'db> ResolutionScope<'db> {\n             adt.ty(self.scope.db).iterate_path_candidates(\n                 self.scope.db,\n                 self.scope.module()?.krate(),\n-                &FxHashSet::default(),\n+                &self.scope.traits_in_scope(),\n                 Some(hir_path.segments().last()?.name),\n                 |_ty, assoc_item| Some(hir::PathResolution::AssocItem(assoc_item)),\n             )"}, {"sha": "0a49a46e382c62d05681b0517d78e22d7ea20902", "filename": "crates/ra_ssr/src/tests.rs", "status": "modified", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/21d2cebcf1a417bce72da98aa638a20235c050db/crates%2Fra_ssr%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21d2cebcf1a417bce72da98aa638a20235c050db/crates%2Fra_ssr%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ssr%2Fsrc%2Ftests.rs?ref=21d2cebcf1a417bce72da98aa638a20235c050db", "patch": "@@ -549,6 +549,70 @@ fn replace_associated_function_call() {\n     );\n }\n \n+#[test]\n+fn replace_associated_trait_default_function_call() {\n+    mark::check!(replace_associated_trait_default_function_call);\n+    assert_ssr_transform(\n+        \"Bar2::foo() ==>> Bar2::foo2()\",\n+        r#\"\n+            trait Foo { fn foo() {} }\n+            pub struct Bar {}\n+            impl Foo for Bar {}\n+            pub struct Bar2 {}\n+            impl Foo for Bar2 {}\n+            impl Bar2 { fn foo2() {} }\n+            fn main() {\n+                Bar::foo();\n+                Bar2::foo();\n+            }\n+        \"#,\n+        expect![[r#\"\n+            trait Foo { fn foo() {} }\n+            pub struct Bar {}\n+            impl Foo for Bar {}\n+            pub struct Bar2 {}\n+            impl Foo for Bar2 {}\n+            impl Bar2 { fn foo2() {} }\n+            fn main() {\n+                Bar::foo();\n+                Bar2::foo2();\n+            }\n+        \"#]],\n+    );\n+}\n+\n+#[test]\n+fn replace_associated_trait_constant() {\n+    mark::check!(replace_associated_trait_constant);\n+    assert_ssr_transform(\n+        \"Bar2::VALUE ==>> Bar2::VALUE_2222\",\n+        r#\"\n+            trait Foo { const VALUE: i32; const VALUE_2222: i32; }\n+            pub struct Bar {}\n+            impl Foo for Bar { const VALUE: i32 = 1;  const VALUE_2222: i32 = 2; }\n+            pub struct Bar2 {}\n+            impl Foo for Bar2 { const VALUE: i32 = 1;  const VALUE_2222: i32 = 2; }\n+            impl Bar2 { fn foo2() {} }\n+            fn main() {\n+                Bar::VALUE;\n+                Bar2::VALUE;\n+            }\n+            \"#,\n+        expect![[r#\"\n+            trait Foo { const VALUE: i32; const VALUE_2222: i32; }\n+            pub struct Bar {}\n+            impl Foo for Bar { const VALUE: i32 = 1;  const VALUE_2222: i32 = 2; }\n+            pub struct Bar2 {}\n+            impl Foo for Bar2 { const VALUE: i32 = 1;  const VALUE_2222: i32 = 2; }\n+            impl Bar2 { fn foo2() {} }\n+            fn main() {\n+                Bar::VALUE;\n+                Bar2::VALUE_2222;\n+            }\n+        \"#]],\n+    );\n+}\n+\n #[test]\n fn replace_path_in_different_contexts() {\n     // Note the <|> inside module a::b which marks the point where the rule is interpreted. We"}]}