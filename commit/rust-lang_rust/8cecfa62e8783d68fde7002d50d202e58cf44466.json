{"sha": "8cecfa62e8783d68fde7002d50d202e58cf44466", "node_id": "MDY6Q29tbWl0NzI0NzEyOjhjZWNmYTYyZTg3ODNkNjhmZGU3MDAyZDUwZDIwMmU1OGNmNDQ0NjY=", "commit": {"author": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2018-08-24T03:51:32Z"}, "committer": {"name": "Nicholas Nethercote", "email": "nnethercote@mozilla.com", "date": "2018-08-28T22:32:11Z"}, "message": "Remove `AccumulateVec` and its uses.\n\nIt's basically just a less capable version of `SmallVec`.", "tree": {"sha": "b2bcc7ce18d9c26753823585421d5c11f84f1ef9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b2bcc7ce18d9c26753823585421d5c11f84f1ef9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/8cecfa62e8783d68fde7002d50d202e58cf44466", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/8cecfa62e8783d68fde7002d50d202e58cf44466", "html_url": "https://github.com/rust-lang/rust/commit/8cecfa62e8783d68fde7002d50d202e58cf44466", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/8cecfa62e8783d68fde7002d50d202e58cf44466/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7061b2775782bb48c0a70d3c79ec711134396687", "url": "https://api.github.com/repos/rust-lang/rust/commits/7061b2775782bb48c0a70d3c79ec711134396687", "html_url": "https://github.com/rust-lang/rust/commit/7061b2775782bb48c0a70d3c79ec711134396687"}], "stats": {"total": 341, "additions": 40, "deletions": 301}, "files": [{"sha": "37a6f9130f595726369088a0d3f4b21f73266541", "filename": "src/Cargo.lock", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8cecfa62e8783d68fde7002d50d202e58cf44466/src%2FCargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/8cecfa62e8783d68fde7002d50d202e58cf44466/src%2FCargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FCargo.lock?ref=8cecfa62e8783d68fde7002d50d202e58cf44466", "patch": "@@ -2354,6 +2354,7 @@ dependencies = [\n  \"rustc_errors 0.0.0\",\n  \"rustc_platform_intrinsics 0.0.0\",\n  \"rustc_target 0.0.0\",\n+ \"smallvec 0.6.5 (registry+https://github.com/rust-lang/crates.io-index)\",\n  \"syntax 0.0.0\",\n  \"syntax_pos 0.0.0\",\n ]"}, {"sha": "371f631737c9871001536c5f4e964f2f0a012736", "filename": "src/librustc/ich/hcx.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8cecfa62e8783d68fde7002d50d202e58cf44466/src%2Flibrustc%2Fich%2Fhcx.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cecfa62e8783d68fde7002d50d202e58cf44466/src%2Flibrustc%2Fich%2Fhcx.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fhcx.rs?ref=8cecfa62e8783d68fde7002d50d202e58cf44466", "patch": "@@ -34,8 +34,8 @@ use syntax_pos::hygiene;\n use rustc_data_structures::stable_hasher::{HashStable,\n                                            StableHasher, StableHasherResult,\n                                            ToStableHashKey};\n-use rustc_data_structures::accumulate_vec::AccumulateVec;\n use rustc_data_structures::fx::{FxHashSet, FxHashMap};\n+use smallvec::SmallVec;\n \n fn compute_ignored_attr_names() -> FxHashSet<Symbol> {\n     debug_assert!(ich::IGNORED_ATTRIBUTES.len() > 0);\n@@ -405,7 +405,7 @@ pub fn hash_stable_trait_impls<'a, 'gcx, W, R>(\n           R: std_hash::BuildHasher,\n {\n     {\n-        let mut blanket_impls: AccumulateVec<[_; 8]> = blanket_impls\n+        let mut blanket_impls: SmallVec<[_; 8]> = blanket_impls\n             .iter()\n             .map(|&def_id| hcx.def_path_hash(def_id))\n             .collect();\n@@ -418,15 +418,15 @@ pub fn hash_stable_trait_impls<'a, 'gcx, W, R>(\n     }\n \n     {\n-        let mut keys: AccumulateVec<[_; 8]> =\n+        let mut keys: SmallVec<[_; 8]> =\n             non_blanket_impls.keys()\n                              .map(|k| (k, k.map_def(|d| hcx.def_path_hash(d))))\n                              .collect();\n         keys.sort_unstable_by(|&(_, ref k1), &(_, ref k2)| k1.cmp(k2));\n         keys.len().hash_stable(hcx, hasher);\n         for (key, ref stable_key) in keys {\n             stable_key.hash_stable(hcx, hasher);\n-            let mut impls : AccumulateVec<[_; 8]> = non_blanket_impls[key]\n+            let mut impls : SmallVec<[_; 8]> = non_blanket_impls[key]\n                 .iter()\n                 .map(|&impl_id| hcx.def_path_hash(impl_id))\n                 .collect();"}, {"sha": "ac5fdb2fe27971f980261a54b5d3cc11b8205379", "filename": "src/librustc/ich/impls_syntax.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/8cecfa62e8783d68fde7002d50d202e58cf44466/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cecfa62e8783d68fde7002d50d202e58cf44466/src%2Flibrustc%2Fich%2Fimpls_syntax.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fich%2Fimpls_syntax.rs?ref=8cecfa62e8783d68fde7002d50d202e58cf44466", "patch": "@@ -25,9 +25,9 @@ use syntax_pos::SourceFile;\n \n use hir::def_id::{DefId, CrateNum, CRATE_DEF_INDEX};\n \n+use smallvec::SmallVec;\n use rustc_data_structures::stable_hasher::{HashStable, ToStableHashKey,\n                                            StableHasher, StableHasherResult};\n-use rustc_data_structures::accumulate_vec::AccumulateVec;\n \n impl<'a> HashStable<StableHashingContext<'a>> for InternedString {\n     #[inline]\n@@ -207,7 +207,7 @@ impl<'a> HashStable<StableHashingContext<'a>> for [ast::Attribute] {\n         }\n \n         // Some attributes are always ignored during hashing.\n-        let filtered: AccumulateVec<[&ast::Attribute; 8]> = self\n+        let filtered: SmallVec<[&ast::Attribute; 8]> = self\n             .iter()\n             .filter(|attr| {\n                 !attr.is_sugared_doc && !hcx.is_ignored_attr(attr.name())"}, {"sha": "10e930d1c92d9a58b3f08632f86b97a27db9aa06", "filename": "src/librustc/traits/structural_impls.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/8cecfa62e8783d68fde7002d50d202e58cf44466/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cecfa62e8783d68fde7002d50d202e58cf44466/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fstructural_impls.rs?ref=8cecfa62e8783d68fde7002d50d202e58cf44466", "patch": "@@ -9,7 +9,7 @@\n // except according to those terms.\n \n use chalk_engine;\n-use rustc_data_structures::accumulate_vec::AccumulateVec;\n+use smallvec::SmallVec;\n use traits;\n use traits::project::Normalized;\n use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n@@ -624,7 +624,7 @@ impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<traits::Goal<'tcx>> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         let v = self.iter()\n             .map(|t| t.fold_with(folder))\n-            .collect::<AccumulateVec<[_; 8]>>();\n+            .collect::<SmallVec<[_; 8]>>();\n         folder.tcx().intern_goals(&v)\n     }\n \n@@ -662,7 +662,7 @@ impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<traits::Clause<'tcx>> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n         let v = self.iter()\n             .map(|t| t.fold_with(folder))\n-            .collect::<AccumulateVec<[_; 8]>>();\n+            .collect::<SmallVec<[_; 8]>>();\n         folder.tcx().intern_clauses(&v)\n     }\n "}, {"sha": "65298a070b71c46a0c27a101a2388946fffcd224", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8cecfa62e8783d68fde7002d50d202e58cf44466/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cecfa62e8783d68fde7002d50d202e58cf44466/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=8cecfa62e8783d68fde7002d50d202e58cf44466", "patch": "@@ -52,7 +52,7 @@ use ty::BindingMode;\n use ty::CanonicalTy;\n use util::nodemap::{DefIdSet, ItemLocalMap};\n use util::nodemap::{FxHashMap, FxHashSet};\n-use rustc_data_structures::accumulate_vec::AccumulateVec;\n+use smallvec::SmallVec;\n use rustc_data_structures::stable_hasher::{HashStable, hash_stable_hashmap,\n                                            StableHasher, StableHasherResult,\n                                            StableVec};\n@@ -2840,7 +2840,7 @@ pub trait InternIteratorElement<T, R>: Sized {\n impl<T, R> InternIteratorElement<T, R> for T {\n     type Output = R;\n     fn intern_with<I: Iterator<Item=Self>, F: FnOnce(&[T]) -> R>(iter: I, f: F) -> Self::Output {\n-        f(&iter.collect::<AccumulateVec<[_; 8]>>())\n+        f(&iter.collect::<SmallVec<[_; 8]>>())\n     }\n }\n \n@@ -2849,14 +2849,14 @@ impl<'a, T, R> InternIteratorElement<T, R> for &'a T\n {\n     type Output = R;\n     fn intern_with<I: Iterator<Item=Self>, F: FnOnce(&[T]) -> R>(iter: I, f: F) -> Self::Output {\n-        f(&iter.cloned().collect::<AccumulateVec<[_; 8]>>())\n+        f(&iter.cloned().collect::<SmallVec<[_; 8]>>())\n     }\n }\n \n impl<T, R, E> InternIteratorElement<T, R> for Result<T, E> {\n     type Output = Result<R, E>;\n     fn intern_with<I: Iterator<Item=Self>, F: FnOnce(&[T]) -> R>(iter: I, f: F) -> Self::Output {\n-        Ok(f(&iter.collect::<Result<AccumulateVec<[_; 8]>, _>>()?))\n+        Ok(f(&iter.collect::<Result<SmallVec<[_; 8]>, _>>()?))\n     }\n }\n "}, {"sha": "6a5df553f3d52531247d17c7c5a6d6bb0119d03a", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/8cecfa62e8783d68fde7002d50d202e58cf44466/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cecfa62e8783d68fde7002d50d202e58cf44466/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=8cecfa62e8783d68fde7002d50d202e58cf44466", "patch": "@@ -16,8 +16,8 @@\n use mir::interpret::{ConstValue, ConstEvalErr};\n use ty::{self, Lift, Ty, TyCtxt};\n use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n-use rustc_data_structures::accumulate_vec::AccumulateVec;\n use rustc_data_structures::indexed_vec::{IndexVec, Idx};\n+use smallvec::SmallVec;\n use mir::interpret;\n \n use std::rc::Rc;\n@@ -741,7 +741,7 @@ BraceStructTypeFoldableImpl! {\n \n impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<ty::ExistentialPredicate<'tcx>> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        let v = self.iter().map(|p| p.fold_with(folder)).collect::<AccumulateVec<[_; 8]>>();\n+        let v = self.iter().map(|p| p.fold_with(folder)).collect::<SmallVec<[_; 8]>>();\n         folder.tcx().intern_existential_predicates(&v)\n     }\n \n@@ -760,7 +760,7 @@ EnumTypeFoldableImpl! {\n \n impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<Ty<'tcx>> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        let v = self.iter().map(|t| t.fold_with(folder)).collect::<AccumulateVec<[_; 8]>>();\n+        let v = self.iter().map(|t| t.fold_with(folder)).collect::<SmallVec<[_; 8]>>();\n         folder.tcx().intern_type_list(&v)\n     }\n \n@@ -1016,7 +1016,7 @@ BraceStructTypeFoldableImpl! {\n \n impl<'tcx> TypeFoldable<'tcx> for &'tcx ty::List<ty::Predicate<'tcx>> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        let v = self.iter().map(|p| p.fold_with(folder)).collect::<AccumulateVec<[_; 8]>>();\n+        let v = self.iter().map(|p| p.fold_with(folder)).collect::<SmallVec<[_; 8]>>();\n         folder.tcx().intern_predicates(&v)\n     }\n "}, {"sha": "b6ffcd55d9150c1ed824b5ccbc1c47f20707b8ee", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 6, "deletions": 14, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/8cecfa62e8783d68fde7002d50d202e58cf44466/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cecfa62e8783d68fde7002d50d202e58cf44466/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=8cecfa62e8783d68fde7002d50d202e58cf44466", "patch": "@@ -17,9 +17,8 @@ use ty::fold::{TypeFoldable, TypeFolder, TypeVisitor};\n \n use serialize::{self, Encodable, Encoder, Decodable, Decoder};\n use syntax_pos::{Span, DUMMY_SP};\n-use rustc_data_structures::accumulate_vec::AccumulateVec;\n-use rustc_data_structures::array_vec::ArrayVec;\n use rustc_data_structures::indexed_vec::Idx;\n+use smallvec::SmallVec;\n \n use core::intrinsics;\n use std::cmp::Ordering;\n@@ -203,11 +202,7 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n     {\n         let defs = tcx.generics_of(def_id);\n         let count = defs.count();\n-        let mut substs = if count <= 8 {\n-            AccumulateVec::Array(ArrayVec::new())\n-        } else {\n-            AccumulateVec::Heap(Vec::with_capacity(count))\n-        };\n+        let mut substs = SmallVec::with_capacity(count);\n         Substs::fill_item(&mut substs, tcx, defs, &mut mk_kind);\n         tcx.intern_substs(&substs)\n     }\n@@ -227,7 +222,7 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n         })\n     }\n \n-    fn fill_item<F>(substs: &mut AccumulateVec<[Kind<'tcx>; 8]>,\n+    fn fill_item<F>(substs: &mut SmallVec<[Kind<'tcx>; 8]>,\n                     tcx: TyCtxt<'a, 'gcx, 'tcx>,\n                     defs: &ty::Generics,\n                     mk_kind: &mut F)\n@@ -240,18 +235,15 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n         Substs::fill_single(substs, defs, mk_kind)\n     }\n \n-    fn fill_single<F>(substs: &mut AccumulateVec<[Kind<'tcx>; 8]>,\n+    fn fill_single<F>(substs: &mut SmallVec<[Kind<'tcx>; 8]>,\n                       defs: &ty::Generics,\n                       mk_kind: &mut F)\n     where F: FnMut(&ty::GenericParamDef, &[Kind<'tcx>]) -> Kind<'tcx>\n     {\n         for param in &defs.params {\n             let kind = mk_kind(param, substs);\n             assert_eq!(param.index as usize, substs.len());\n-            match *substs {\n-                AccumulateVec::Array(ref mut arr) => arr.push(kind),\n-                AccumulateVec::Heap(ref mut vec) => vec.push(kind),\n-            }\n+            substs.push(kind);\n         }\n     }\n \n@@ -325,7 +317,7 @@ impl<'a, 'gcx, 'tcx> Substs<'tcx> {\n \n impl<'tcx> TypeFoldable<'tcx> for &'tcx Substs<'tcx> {\n     fn super_fold_with<'gcx: 'tcx, F: TypeFolder<'gcx, 'tcx>>(&self, folder: &mut F) -> Self {\n-        let params: AccumulateVec<[_; 8]> = self.iter().map(|k| k.fold_with(folder)).collect();\n+        let params: SmallVec<[_; 8]> = self.iter().map(|k| k.fold_with(folder)).collect();\n \n         // If folding doesn't change the substs, it's faster to avoid\n         // calling `mk_substs` and instead reuse the existing substs."}, {"sha": "9423e6b3256c5d229aa7f0fc21834293529d1968", "filename": "src/librustc_data_structures/accumulate_vec.rs", "status": "removed", "additions": 0, "deletions": 242, "changes": 242, "blob_url": "https://github.com/rust-lang/rust/blob/7061b2775782bb48c0a70d3c79ec711134396687/src%2Flibrustc_data_structures%2Faccumulate_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/7061b2775782bb48c0a70d3c79ec711134396687/src%2Flibrustc_data_structures%2Faccumulate_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Faccumulate_vec.rs?ref=7061b2775782bb48c0a70d3c79ec711134396687", "patch": "@@ -1,242 +0,0 @@\n-// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-//! A vector type intended to be used for collecting from iterators onto the stack.\n-//!\n-//! Space for up to N elements is provided on the stack.  If more elements are collected, Vec is\n-//! used to store the values on the heap.\n-//!\n-//! The N above is determined by Array's implementor, by way of an associated constant.\n-\n-use std::ops::{Deref, DerefMut, RangeBounds};\n-use std::iter::{self, IntoIterator, FromIterator};\n-use std::slice;\n-use std::vec;\n-\n-use rustc_serialize::{Encodable, Encoder, Decodable, Decoder};\n-\n-use array_vec::{self, Array, ArrayVec};\n-\n-#[derive(Hash, Debug)]\n-pub enum AccumulateVec<A: Array> {\n-    Array(ArrayVec<A>),\n-    Heap(Vec<A::Element>)\n-}\n-\n-impl<A> Clone for AccumulateVec<A>\n-    where A: Array,\n-          A::Element: Clone {\n-    fn clone(&self) -> Self {\n-        match *self {\n-            AccumulateVec::Array(ref arr) => AccumulateVec::Array(arr.clone()),\n-            AccumulateVec::Heap(ref vec) => AccumulateVec::Heap(vec.clone()),\n-        }\n-    }\n-}\n-\n-impl<A: Array> AccumulateVec<A> {\n-    pub fn new() -> AccumulateVec<A> {\n-        AccumulateVec::Array(ArrayVec::new())\n-    }\n-\n-    pub fn is_array(&self) -> bool {\n-        match self {\n-            AccumulateVec::Array(..) => true,\n-            AccumulateVec::Heap(..) => false,\n-        }\n-    }\n-\n-    pub fn one(el: A::Element) -> Self {\n-        iter::once(el).collect()\n-    }\n-\n-    pub fn many<I: IntoIterator<Item=A::Element>>(iter: I) -> Self {\n-        iter.into_iter().collect()\n-    }\n-\n-    pub fn len(&self) -> usize {\n-        match *self {\n-            AccumulateVec::Array(ref arr) => arr.len(),\n-            AccumulateVec::Heap(ref vec) => vec.len(),\n-        }\n-    }\n-\n-    pub fn is_empty(&self) -> bool {\n-        self.len() == 0\n-    }\n-\n-    pub fn pop(&mut self) -> Option<A::Element> {\n-        match *self {\n-            AccumulateVec::Array(ref mut arr) => arr.pop(),\n-            AccumulateVec::Heap(ref mut vec) => vec.pop(),\n-        }\n-    }\n-\n-    pub fn drain<R>(&mut self, range: R) -> Drain<A>\n-        where R: RangeBounds<usize>\n-    {\n-        match *self {\n-            AccumulateVec::Array(ref mut v) => {\n-                Drain::Array(v.drain(range))\n-            },\n-            AccumulateVec::Heap(ref mut v) => {\n-                Drain::Heap(v.drain(range))\n-            },\n-        }\n-    }\n-}\n-\n-impl<A: Array> Deref for AccumulateVec<A> {\n-    type Target = [A::Element];\n-    fn deref(&self) -> &Self::Target {\n-        match *self {\n-            AccumulateVec::Array(ref v) => v,\n-            AccumulateVec::Heap(ref v) => v,\n-        }\n-    }\n-}\n-\n-impl<A: Array> DerefMut for AccumulateVec<A> {\n-    fn deref_mut(&mut self) -> &mut [A::Element] {\n-        match *self {\n-            AccumulateVec::Array(ref mut v) => v,\n-            AccumulateVec::Heap(ref mut v) => v,\n-        }\n-    }\n-}\n-\n-impl<A: Array> FromIterator<A::Element> for AccumulateVec<A> {\n-    fn from_iter<I>(iter: I) -> AccumulateVec<A> where I: IntoIterator<Item=A::Element> {\n-        let iter = iter.into_iter();\n-        if iter.size_hint().1.map_or(false, |n| n <= A::LEN) {\n-            let mut v = ArrayVec::new();\n-            v.extend(iter);\n-            AccumulateVec::Array(v)\n-        } else {\n-            AccumulateVec::Heap(iter.collect())\n-        }\n-    }\n-}\n-\n-pub struct IntoIter<A: Array> {\n-    repr: IntoIterRepr<A>,\n-}\n-\n-enum IntoIterRepr<A: Array> {\n-    Array(array_vec::Iter<A>),\n-    Heap(vec::IntoIter<A::Element>),\n-}\n-\n-impl<A: Array> Iterator for IntoIter<A> {\n-    type Item = A::Element;\n-\n-    fn next(&mut self) -> Option<A::Element> {\n-        match self.repr {\n-            IntoIterRepr::Array(ref mut arr) => arr.next(),\n-            IntoIterRepr::Heap(ref mut iter) => iter.next(),\n-        }\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        match self.repr {\n-            IntoIterRepr::Array(ref iter) => iter.size_hint(),\n-            IntoIterRepr::Heap(ref iter) => iter.size_hint(),\n-        }\n-    }\n-}\n-\n-pub enum Drain<'a, A: Array>\n-        where A::Element: 'a\n-{\n-    Array(array_vec::Drain<'a, A>),\n-    Heap(vec::Drain<'a, A::Element>),\n-}\n-\n-impl<'a, A: Array> Iterator for Drain<'a, A> {\n-    type Item = A::Element;\n-\n-    fn next(&mut self) -> Option<A::Element> {\n-        match *self {\n-            Drain::Array(ref mut drain) => drain.next(),\n-            Drain::Heap(ref mut drain) => drain.next(),\n-        }\n-    }\n-\n-    fn size_hint(&self) -> (usize, Option<usize>) {\n-        match *self {\n-            Drain::Array(ref drain) => drain.size_hint(),\n-            Drain::Heap(ref drain) => drain.size_hint(),\n-        }\n-    }\n-}\n-\n-impl<A: Array> IntoIterator for AccumulateVec<A> {\n-    type Item = A::Element;\n-    type IntoIter = IntoIter<A>;\n-    fn into_iter(self) -> Self::IntoIter {\n-        IntoIter {\n-            repr: match self {\n-                AccumulateVec::Array(arr) => IntoIterRepr::Array(arr.into_iter()),\n-                AccumulateVec::Heap(vec) => IntoIterRepr::Heap(vec.into_iter()),\n-            }\n-        }\n-    }\n-}\n-\n-impl<'a, A: Array> IntoIterator for &'a AccumulateVec<A> {\n-    type Item = &'a A::Element;\n-    type IntoIter = slice::Iter<'a, A::Element>;\n-    fn into_iter(self) -> Self::IntoIter {\n-        self.iter()\n-    }\n-}\n-\n-impl<'a, A: Array> IntoIterator for &'a mut AccumulateVec<A> {\n-    type Item = &'a mut A::Element;\n-    type IntoIter = slice::IterMut<'a, A::Element>;\n-    fn into_iter(self) -> Self::IntoIter {\n-        self.iter_mut()\n-    }\n-}\n-\n-impl<A: Array> From<Vec<A::Element>> for AccumulateVec<A> {\n-    fn from(v: Vec<A::Element>) -> AccumulateVec<A> {\n-        AccumulateVec::many(v)\n-    }\n-}\n-\n-impl<A: Array> Default for AccumulateVec<A> {\n-    fn default() -> AccumulateVec<A> {\n-        AccumulateVec::new()\n-    }\n-}\n-\n-impl<A> Encodable for AccumulateVec<A>\n-    where A: Array,\n-          A::Element: Encodable {\n-    fn encode<S: Encoder>(&self, s: &mut S) -> Result<(), S::Error> {\n-        s.emit_seq(self.len(), |s| {\n-            for (i, e) in self.iter().enumerate() {\n-                s.emit_seq_elt(i, |s| e.encode(s))?;\n-            }\n-            Ok(())\n-        })\n-    }\n-}\n-\n-impl<A> Decodable for AccumulateVec<A>\n-    where A: Array,\n-          A::Element: Decodable {\n-    fn decode<D: Decoder>(d: &mut D) -> Result<AccumulateVec<A>, D::Error> {\n-        d.read_seq(|d, len| {\n-            (0..len).map(|i| d.read_seq_elt(i, |d| Decodable::decode(d))).collect()\n-        })\n-    }\n-}"}, {"sha": "7915650fd89f70401d79422f01aa15105168394a", "filename": "src/librustc_data_structures/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8cecfa62e8783d68fde7002d50d202e58cf44466/src%2Flibrustc_data_structures%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cecfa62e8783d68fde7002d50d202e58cf44466/src%2Flibrustc_data_structures%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Flib.rs?ref=8cecfa62e8783d68fde7002d50d202e58cf44466", "patch": "@@ -61,7 +61,6 @@ extern crate rustc_cratesio_shim;\n pub use rustc_serialize::hex::ToHex;\n \n pub mod svh;\n-pub mod accumulate_vec;\n pub mod array_vec;\n pub mod base_n;\n pub mod bitslice;"}, {"sha": "075b70c6426fb8407d4e00a3fd5835bf1a8bada7", "filename": "src/librustc_data_structures/small_vec.rs", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8cecfa62e8783d68fde7002d50d202e58cf44466/src%2Flibrustc_data_structures%2Fsmall_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cecfa62e8783d68fde7002d50d202e58cf44466/src%2Flibrustc_data_structures%2Fsmall_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_data_structures%2Fsmall_vec.rs?ref=8cecfa62e8783d68fde7002d50d202e58cf44466", "patch": "@@ -8,11 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-//! A vector type intended to be used for collecting from iterators onto the stack.\n+//! A vector type intended to be used for small vectors.\n //!\n-//! Space for up to N elements is provided on the stack.  If more elements are collected, Vec is\n-//! used to store the values on the heap. SmallVec is similar to AccumulateVec, but adds\n-//! the ability to push elements.\n+//! Space for up to N elements is provided on the stack. If more elements are collected, Vec is\n+//! used to store the values on the heap.\n //!\n //! The N above is determined by Array's implementor, by way of an associated constant.\n "}, {"sha": "881fa2604bc8b9dec1b1cc70870c3cf93be771c4", "filename": "src/librustc_typeck/Cargo.toml", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/8cecfa62e8783d68fde7002d50d202e58cf44466/src%2Flibrustc_typeck%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/8cecfa62e8783d68fde7002d50d202e58cf44466/src%2Flibrustc_typeck%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2FCargo.toml?ref=8cecfa62e8783d68fde7002d50d202e58cf44466", "patch": "@@ -10,12 +10,13 @@ crate-type = [\"dylib\"]\n test = false\n \n [dependencies]\n-log = \"0.4\"\n-syntax = { path = \"../libsyntax\" }\n arena = { path = \"../libarena\" }\n+log = \"0.4\"\n rustc = { path = \"../librustc\" }\n rustc_data_structures = { path = \"../librustc_data_structures\" }\n+rustc_errors = { path = \"../librustc_errors\" }\n rustc_platform_intrinsics = { path = \"../librustc_platform_intrinsics\" }\n rustc_target = { path = \"../librustc_target\" }\n+smallvec = { version = \"0.6.5\", features = [\"union\"] }\n+syntax = { path = \"../libsyntax\" }\n syntax_pos = { path = \"../libsyntax_pos\" }\n-rustc_errors = { path = \"../librustc_errors\" }"}, {"sha": "804aad3c0ecce29b86d51c9025ee1ce13ea96b48", "filename": "src/librustc_typeck/astconv.rs", "status": "modified", "additions": 8, "deletions": 20, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/8cecfa62e8783d68fde7002d50d202e58cf44466/src%2Flibrustc_typeck%2Fastconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cecfa62e8783d68fde7002d50d202e58cf44466/src%2Flibrustc_typeck%2Fastconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fastconv.rs?ref=8cecfa62e8783d68fde7002d50d202e58cf44466", "patch": "@@ -12,8 +12,7 @@\n //! representation.  The main routine here is `ast_ty_to_ty()`: each use\n //! is parameterized by an instance of `AstConv`.\n \n-use rustc_data_structures::accumulate_vec::AccumulateVec;\n-use rustc_data_structures::array_vec::ArrayVec;\n+use smallvec::SmallVec;\n use hir::{self, GenericArg, GenericArgs};\n use hir::def::Def;\n use hir::def_id::DefId;\n@@ -431,18 +430,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n         // We manually build up the substitution, rather than using convenience\n         // methods in subst.rs so that we can iterate over the arguments and\n         // parameters in lock-step linearly, rather than trying to match each pair.\n-        let mut substs: AccumulateVec<[Kind<'tcx>; 8]> = if count <= 8 {\n-            AccumulateVec::Array(ArrayVec::new())\n-        } else {\n-            AccumulateVec::Heap(Vec::with_capacity(count))\n-        };\n-\n-        fn push_kind<'tcx>(substs: &mut AccumulateVec<[Kind<'tcx>; 8]>, kind: Kind<'tcx>) {\n-            match substs {\n-                AccumulateVec::Array(ref mut arr) => arr.push(kind),\n-                AccumulateVec::Heap(ref mut vec) => vec.push(kind),\n-            }\n-        }\n+        let mut substs: SmallVec<[Kind<'tcx>; 8]> = SmallVec::with_capacity(count);\n \n         // Iterate over each segment of the path.\n         while let Some((def_id, defs)) = stack.pop() {\n@@ -451,7 +439,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n             // If we have already computed substitutions for parents, we can use those directly.\n             while let Some(&param) = params.peek() {\n                 if let Some(&kind) = parent_substs.get(param.index as usize) {\n-                    push_kind(&mut substs, kind);\n+                    substs.push(kind);\n                     params.next();\n                 } else {\n                     break;\n@@ -463,7 +451,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n                 if let Some(&param) = params.peek() {\n                     if param.index == 0 {\n                         if let GenericParamDefKind::Type { .. } = param.kind {\n-                            push_kind(&mut substs, self_ty.map(|ty| ty.into())\n+                            substs.push(self_ty.map(|ty| ty.into())\n                                 .unwrap_or_else(|| inferred_kind(None, param, true)));\n                             params.next();\n                         }\n@@ -487,7 +475,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n                         match (arg, &param.kind) {\n                             (GenericArg::Lifetime(_), GenericParamDefKind::Lifetime)\n                             | (GenericArg::Type(_), GenericParamDefKind::Type { .. }) => {\n-                                push_kind(&mut substs, provided_kind(param, arg));\n+                                substs.push(provided_kind(param, arg));\n                                 args.next();\n                                 params.next();\n                             }\n@@ -501,7 +489,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n                             (GenericArg::Type(_), GenericParamDefKind::Lifetime) => {\n                                 // We expected a lifetime argument, but got a type\n                                 // argument. That means we're inferring the lifetimes.\n-                                push_kind(&mut substs, inferred_kind(None, param, infer_types));\n+                                substs.push(inferred_kind(None, param, infer_types));\n                                 params.next();\n                             }\n                         }\n@@ -518,7 +506,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n                         match param.kind {\n                             GenericParamDefKind::Lifetime | GenericParamDefKind::Type { .. } => {\n                                 let kind = inferred_kind(Some(&substs), param, infer_types);\n-                                push_kind(&mut substs, kind);\n+                                substs.push(kind);\n                             }\n                         }\n                         args.next();\n@@ -1041,7 +1029,7 @@ impl<'o, 'gcx: 'tcx, 'tcx> dyn AstConv<'gcx, 'tcx>+'o {\n             .chain(auto_traits.into_iter().map(ty::ExistentialPredicate::AutoTrait))\n             .chain(existential_projections\n                    .map(|x| ty::ExistentialPredicate::Projection(*x.skip_binder())))\n-            .collect::<AccumulateVec<[_; 8]>>();\n+            .collect::<SmallVec<[_; 8]>>();\n         v.sort_by(|a, b| a.stable_cmp(tcx, b));\n         let existential_predicates = ty::Binder::bind(tcx.mk_existential_predicates(v.into_iter()));\n "}, {"sha": "f465ff4d62163e63148d7bf39eae8376ad433156", "filename": "src/librustc_typeck/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/8cecfa62e8783d68fde7002d50d202e58cf44466/src%2Flibrustc_typeck%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/8cecfa62e8783d68fde7002d50d202e58cf44466/src%2Flibrustc_typeck%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Flib.rs?ref=8cecfa62e8783d68fde7002d50d202e58cf44466", "patch": "@@ -96,6 +96,7 @@ extern crate rustc_platform_intrinsics as intrinsics;\n extern crate rustc_data_structures;\n extern crate rustc_errors as errors;\n extern crate rustc_target;\n+extern crate smallvec;\n \n use rustc::hir;\n use rustc::lint;"}]}