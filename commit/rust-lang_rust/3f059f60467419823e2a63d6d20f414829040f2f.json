{"sha": "3f059f60467419823e2a63d6d20f414829040f2f", "node_id": "C_kwDOAAsO6NoAKDNmMDU5ZjYwNDY3NDE5ODIzZTJhNjNkNmQyMGY0MTQ4MjkwNDBmMmY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-07T20:58:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-02-07T20:58:20Z"}, "message": "Auto merge of #107768 - matthiaskrgr:rollup-9u4cal4, r=matthiaskrgr\n\nRollup of 8 pull requests\n\nSuccessful merges:\n\n - #107719 (Remove `arena_cache` modifier from `upstream_monomorphizations_for`)\n - #107740 (Avoid locking the global context across the `after_expansion` callback)\n - #107746 (Split fn_ctxt/adjust_fulfillment_errors from fn_ctxt/checks)\n - #107749 (allow quick-edit convenience)\n - #107750 (make more readable)\n - #107755 (remove binder from query constraints)\n - #107756 (miri: fix ICE when running out of address space)\n - #107764 (llvm-16: Use Triple.h from new header location.)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "08723e47306b766548b55b53de77fe374cb2405e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/08723e47306b766548b55b53de77fe374cb2405e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3f059f60467419823e2a63d6d20f414829040f2f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3f059f60467419823e2a63d6d20f414829040f2f", "html_url": "https://github.com/rust-lang/rust/commit/3f059f60467419823e2a63d6d20f414829040f2f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3f059f60467419823e2a63d6d20f414829040f2f/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bd39bbb4bb92df439bf6d85470e296cc6a47ffbd", "url": "https://api.github.com/repos/rust-lang/rust/commits/bd39bbb4bb92df439bf6d85470e296cc6a47ffbd", "html_url": "https://github.com/rust-lang/rust/commit/bd39bbb4bb92df439bf6d85470e296cc6a47ffbd"}, {"sha": "232213dd77515eb8ca3b4ff3ca706bbbf0b243ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/232213dd77515eb8ca3b4ff3ca706bbbf0b243ed", "html_url": "https://github.com/rust-lang/rust/commit/232213dd77515eb8ca3b4ff3ca706bbbf0b243ed"}], "stats": {"total": 911, "additions": 461, "deletions": 450}, "files": [{"sha": "1dc6c42fbf78ea3a4b60f27ec9370de3bcad73d2", "filename": "compiler/rustc_borrowck/src/type_check/constraint_conversion.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3f059f60467419823e2a63d6d20f414829040f2f/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f059f60467419823e2a63d6d20f414829040f2f/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_borrowck%2Fsrc%2Ftype_check%2Fconstraint_conversion.rs?ref=3f059f60467419823e2a63d6d20f414829040f2f", "patch": "@@ -83,16 +83,8 @@ impl<'a, 'tcx> ConstraintConversion<'a, 'tcx> {\n         }\n         self.constraints.member_constraints = tmp;\n \n-        for (predicate, constraint_category) in outlives {\n-            // At the moment, we never generate any \"higher-ranked\"\n-            // region constraints like `for<'a> 'a: 'b`. At some point\n-            // when we move to universes, we will, and this assertion\n-            // will start to fail.\n-            let predicate = predicate.no_bound_vars().unwrap_or_else(|| {\n-                bug!(\"query_constraint {:?} contained bound vars\", predicate,);\n-            });\n-\n-            self.convert(predicate, *constraint_category);\n+        for &(predicate, constraint_category) in outlives {\n+            self.convert(predicate, constraint_category);\n         }\n     }\n "}, {"sha": "5042c6bac9932dcfd4821aa3e273c14fab373b7d", "filename": "compiler/rustc_const_eval/src/interpret/intrinsics/caller_location.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3f059f60467419823e2a63d6d20f414829040f2f/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f059f60467419823e2a63d6d20f414829040f2f/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics%2Fcaller_location.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fintrinsics%2Fcaller_location.rs?ref=3f059f60467419823e2a63d6d20f414829040f2f", "patch": "@@ -78,13 +78,16 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         col: u32,\n     ) -> MPlaceTy<'tcx, M::Provenance> {\n         let loc_details = &self.tcx.sess.opts.unstable_opts.location_detail;\n+        // This can fail if rustc runs out of memory right here. Trying to emit an error would be\n+        // pointless, since that would require allocating more memory than these short strings.\n         let file = if loc_details.file {\n             self.allocate_str(filename.as_str(), MemoryKind::CallerLocation, Mutability::Not)\n+                .unwrap()\n         } else {\n             // FIXME: This creates a new allocation each time. It might be preferable to\n             // perform this allocation only once, and re-use the `MPlaceTy`.\n             // See https://github.com/rust-lang/rust/pull/89920#discussion_r730012398\n-            self.allocate_str(\"<redacted>\", MemoryKind::CallerLocation, Mutability::Not)\n+            self.allocate_str(\"<redacted>\", MemoryKind::CallerLocation, Mutability::Not).unwrap()\n         };\n         let line = if loc_details.line { Scalar::from_u32(line) } else { Scalar::from_u32(0) };\n         let col = if loc_details.column { Scalar::from_u32(col) } else { Scalar::from_u32(0) };\n@@ -95,8 +98,6 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             .bound_type_of(self.tcx.require_lang_item(LangItem::PanicLocation, None))\n             .subst(*self.tcx, self.tcx.mk_substs([self.tcx.lifetimes.re_erased.into()].iter()));\n         let loc_layout = self.layout_of(loc_ty).unwrap();\n-        // This can fail if rustc runs out of memory right here. Trying to emit an error would be\n-        // pointless, since that would require allocating more memory than a Location.\n         let location = self.allocate(loc_layout, MemoryKind::CallerLocation).unwrap();\n \n         // Initialize fields."}, {"sha": "d8087a36a7c6abfb48240319148c8e68e2bf3917", "filename": "compiler/rustc_const_eval/src/interpret/machine.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3f059f60467419823e2a63d6d20f414829040f2f/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f059f60467419823e2a63d6d20f414829040f2f/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmachine.rs?ref=3f059f60467419823e2a63d6d20f414829040f2f", "patch": "@@ -291,7 +291,7 @@ pub trait Machine<'mir, 'tcx>: Sized {\n     fn adjust_alloc_base_pointer(\n         ecx: &InterpCx<'mir, 'tcx, Self>,\n         ptr: Pointer,\n-    ) -> Pointer<Self::Provenance>;\n+    ) -> InterpResult<'tcx, Pointer<Self::Provenance>>;\n \n     /// \"Int-to-pointer cast\"\n     fn ptr_from_addr_cast(\n@@ -505,8 +505,8 @@ pub macro compile_time_machine(<$mir: lifetime, $tcx: lifetime>) {\n     fn adjust_alloc_base_pointer(\n         _ecx: &InterpCx<$mir, $tcx, Self>,\n         ptr: Pointer<AllocId>,\n-    ) -> Pointer<AllocId> {\n-        ptr\n+    ) -> InterpResult<$tcx, Pointer<AllocId>> {\n+        Ok(ptr)\n     }\n \n     #[inline(always)]"}, {"sha": "cfad930b1e52ec6ca1174e7700b5e3135fbcdf80", "filename": "compiler/rustc_const_eval/src/interpret/memory.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/3f059f60467419823e2a63d6d20f414829040f2f/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f059f60467419823e2a63d6d20f414829040f2f/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fmemory.rs?ref=3f059f60467419823e2a63d6d20f414829040f2f", "patch": "@@ -171,7 +171,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n             _ => {}\n         }\n         // And we need to get the provenance.\n-        Ok(M::adjust_alloc_base_pointer(self, ptr))\n+        M::adjust_alloc_base_pointer(self, ptr)\n     }\n \n     pub fn create_fn_alloc_ptr(\n@@ -200,8 +200,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         kind: MemoryKind<M::MemoryKind>,\n     ) -> InterpResult<'tcx, Pointer<M::Provenance>> {\n         let alloc = Allocation::uninit(size, align, M::PANIC_ON_ALLOC_FAIL)?;\n-        // We can `unwrap` since `alloc` contains no pointers.\n-        Ok(self.allocate_raw_ptr(alloc, kind).unwrap())\n+        self.allocate_raw_ptr(alloc, kind)\n     }\n \n     pub fn allocate_bytes_ptr(\n@@ -210,10 +209,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         align: Align,\n         kind: MemoryKind<M::MemoryKind>,\n         mutability: Mutability,\n-    ) -> Pointer<M::Provenance> {\n+    ) -> InterpResult<'tcx, Pointer<M::Provenance>> {\n         let alloc = Allocation::from_bytes(bytes, align, mutability);\n-        // We can `unwrap` since `alloc` contains no pointers.\n-        self.allocate_raw_ptr(alloc, kind).unwrap()\n+        self.allocate_raw_ptr(alloc, kind)\n     }\n \n     /// This can fail only of `alloc` contains provenance.\n@@ -230,7 +228,7 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         );\n         let alloc = M::adjust_allocation(self, id, Cow::Owned(alloc), Some(kind))?;\n         self.memory.alloc_map.insert(id, (kind, alloc.into_owned()));\n-        Ok(M::adjust_alloc_base_pointer(self, Pointer::from(id)))\n+        M::adjust_alloc_base_pointer(self, Pointer::from(id))\n     }\n \n     pub fn reallocate_ptr("}, {"sha": "038282e2161e6637891d2cde59fe2e766e40b189", "filename": "compiler/rustc_const_eval/src/interpret/place.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3f059f60467419823e2a63d6d20f414829040f2f/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f059f60467419823e2a63d6d20f414829040f2f/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_const_eval%2Fsrc%2Finterpret%2Fplace.rs?ref=3f059f60467419823e2a63d6d20f414829040f2f", "patch": "@@ -754,8 +754,8 @@ where\n         str: &str,\n         kind: MemoryKind<M::MemoryKind>,\n         mutbl: Mutability,\n-    ) -> MPlaceTy<'tcx, M::Provenance> {\n-        let ptr = self.allocate_bytes_ptr(str.as_bytes(), Align::ONE, kind, mutbl);\n+    ) -> InterpResult<'tcx, MPlaceTy<'tcx, M::Provenance>> {\n+        let ptr = self.allocate_bytes_ptr(str.as_bytes(), Align::ONE, kind, mutbl)?;\n         let meta = Scalar::from_machine_usize(u64::try_from(str.len()).unwrap(), self);\n         let mplace = MemPlace { ptr: ptr.into(), meta: MemPlaceMeta::Meta(meta) };\n \n@@ -764,7 +764,7 @@ where\n             ty::TypeAndMut { ty: self.tcx.types.str_, mutbl },\n         );\n         let layout = self.layout_of(ty).unwrap();\n-        MPlaceTy { mplace, layout, align: layout.align.abi }\n+        Ok(MPlaceTy { mplace, layout, align: layout.align.abi })\n     }\n \n     /// Writes the aggregate to the destination."}, {"sha": "1da13afecfa935b9adf8d0568064a0aa675423b3", "filename": "compiler/rustc_driver_impl/src/lib.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/3f059f60467419823e2a63d6d20f414829040f2f/compiler%2Frustc_driver_impl%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f059f60467419823e2a63d6d20f414829040f2f/compiler%2Frustc_driver_impl%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_driver_impl%2Fsrc%2Flib.rs?ref=3f059f60467419823e2a63d6d20f414829040f2f", "patch": "@@ -326,14 +326,16 @@ fn run_compiler(\n                 }\n             }\n \n-            let mut gctxt = queries.global_ctxt()?;\n+            // Make sure name resolution and macro expansion is run.\n+            queries.global_ctxt()?;\n+\n             if callbacks.after_expansion(compiler, queries) == Compilation::Stop {\n                 return early_exit();\n             }\n \n             // Make sure the `output_filenames` query is run for its side\n             // effects of writing the dep-info and reporting errors.\n-            gctxt.enter(|tcx| tcx.output_filenames(()));\n+            queries.global_ctxt()?.enter(|tcx| tcx.output_filenames(()));\n \n             if sess.opts.output_types.contains_key(&OutputType::DepInfo)\n                 && sess.opts.output_types.len() == 1\n@@ -345,7 +347,7 @@ fn run_compiler(\n                 return early_exit();\n             }\n \n-            gctxt.enter(|tcx| {\n+            queries.global_ctxt()?.enter(|tcx| {\n                 let result = tcx.analysis(());\n                 if sess.opts.unstable_opts.save_analysis {\n                     let crate_name = tcx.crate_name(LOCAL_CRATE);\n@@ -362,8 +364,6 @@ fn run_compiler(\n                 result\n             })?;\n \n-            drop(gctxt);\n-\n             if callbacks.after_analysis(compiler, queries) == Compilation::Stop {\n                 return early_exit();\n             }"}, {"sha": "db1acb599271696008ec0143c1f68a587ddf173f", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/adjust_fulfillment_errors.rs", "status": "modified", "additions": 373, "deletions": 1, "changes": 374, "blob_url": "https://github.com/rust-lang/rust/blob/3f059f60467419823e2a63d6d20f414829040f2f/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fadjust_fulfillment_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f059f60467419823e2a63d6d20f414829040f2f/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fadjust_fulfillment_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fadjust_fulfillment_errors.rs?ref=3f059f60467419823e2a63d6d20f414829040f2f", "patch": "@@ -1,10 +1,382 @@\n use crate::FnCtxt;\n use rustc_hir as hir;\n use rustc_hir::def::Res;\n-use rustc_middle::ty::{self, DefIdTree, Ty};\n+use rustc_hir::def_id::DefId;\n+use rustc_infer::traits::ObligationCauseCode;\n+use rustc_middle::ty::{self, DefIdTree, Ty, TypeSuperVisitable, TypeVisitable, TypeVisitor};\n+use rustc_span::{self, Span};\n use rustc_trait_selection::traits;\n \n+use std::ops::ControlFlow;\n+\n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n+    pub fn adjust_fulfillment_error_for_expr_obligation(\n+        &self,\n+        error: &mut traits::FulfillmentError<'tcx>,\n+    ) -> bool {\n+        let (traits::ExprItemObligation(def_id, hir_id, idx) | traits::ExprBindingObligation(def_id, _, hir_id, idx))\n+            = *error.obligation.cause.code().peel_derives() else { return false; };\n+        let hir = self.tcx.hir();\n+        let hir::Node::Expr(expr) = hir.get(hir_id) else { return false; };\n+\n+        let Some(unsubstituted_pred) =\n+            self.tcx.predicates_of(def_id).instantiate_identity(self.tcx).predicates.into_iter().nth(idx)\n+            else { return false; };\n+\n+        let generics = self.tcx.generics_of(def_id);\n+        let predicate_substs = match unsubstituted_pred.kind().skip_binder() {\n+            ty::PredicateKind::Clause(ty::Clause::Trait(pred)) => pred.trait_ref.substs,\n+            ty::PredicateKind::Clause(ty::Clause::Projection(pred)) => pred.projection_ty.substs,\n+            _ => ty::List::empty(),\n+        };\n+\n+        let find_param_matching = |matches: &dyn Fn(&ty::ParamTy) -> bool| {\n+            predicate_substs.types().find_map(|ty| {\n+                ty.walk().find_map(|arg| {\n+                    if let ty::GenericArgKind::Type(ty) = arg.unpack()\n+                        && let ty::Param(param_ty) = ty.kind()\n+                        && matches(param_ty)\n+                    {\n+                        Some(arg)\n+                    } else {\n+                        None\n+                    }\n+                })\n+            })\n+        };\n+\n+        // Prefer generics that are local to the fn item, since these are likely\n+        // to be the cause of the unsatisfied predicate.\n+        let mut param_to_point_at = find_param_matching(&|param_ty| {\n+            self.tcx.parent(generics.type_param(param_ty, self.tcx).def_id) == def_id\n+        });\n+        // Fall back to generic that isn't local to the fn item. This will come\n+        // from a trait or impl, for example.\n+        let mut fallback_param_to_point_at = find_param_matching(&|param_ty| {\n+            self.tcx.parent(generics.type_param(param_ty, self.tcx).def_id) != def_id\n+                && param_ty.name != rustc_span::symbol::kw::SelfUpper\n+        });\n+        // Finally, the `Self` parameter is possibly the reason that the predicate\n+        // is unsatisfied. This is less likely to be true for methods, because\n+        // method probe means that we already kinda check that the predicates due\n+        // to the `Self` type are true.\n+        let mut self_param_to_point_at =\n+            find_param_matching(&|param_ty| param_ty.name == rustc_span::symbol::kw::SelfUpper);\n+\n+        // Finally, for ambiguity-related errors, we actually want to look\n+        // for a parameter that is the source of the inference type left\n+        // over in this predicate.\n+        if let traits::FulfillmentErrorCode::CodeAmbiguity = error.code {\n+            fallback_param_to_point_at = None;\n+            self_param_to_point_at = None;\n+            param_to_point_at =\n+                self.find_ambiguous_parameter_in(def_id, error.root_obligation.predicate);\n+        }\n+\n+        if self.closure_span_overlaps_error(error, expr.span) {\n+            return false;\n+        }\n+\n+        match &expr.kind {\n+            hir::ExprKind::Path(qpath) => {\n+                if let hir::Node::Expr(hir::Expr {\n+                    kind: hir::ExprKind::Call(callee, args),\n+                    hir_id: call_hir_id,\n+                    span: call_span,\n+                    ..\n+                }) = hir.get_parent(expr.hir_id)\n+                    && callee.hir_id == expr.hir_id\n+                {\n+                    if self.closure_span_overlaps_error(error, *call_span) {\n+                        return false;\n+                    }\n+\n+                    for param in\n+                        [param_to_point_at, fallback_param_to_point_at, self_param_to_point_at]\n+                        .into_iter()\n+                        .flatten()\n+                    {\n+                        if self.blame_specific_arg_if_possible(\n+                                error,\n+                                def_id,\n+                                param,\n+                                *call_hir_id,\n+                                callee.span,\n+                                None,\n+                                args,\n+                            )\n+                        {\n+                            return true;\n+                        }\n+                    }\n+                }\n+                // Notably, we only point to params that are local to the\n+                // item we're checking, since those are the ones we are able\n+                // to look in the final `hir::PathSegment` for. Everything else\n+                // would require a deeper search into the `qpath` than I think\n+                // is worthwhile.\n+                if let Some(param_to_point_at) = param_to_point_at\n+                    && self.point_at_path_if_possible(error, def_id, param_to_point_at, qpath)\n+                {\n+                    return true;\n+                }\n+            }\n+            hir::ExprKind::MethodCall(segment, receiver, args, ..) => {\n+                for param in [param_to_point_at, fallback_param_to_point_at, self_param_to_point_at]\n+                    .into_iter()\n+                    .flatten()\n+                {\n+                    if self.blame_specific_arg_if_possible(\n+                        error,\n+                        def_id,\n+                        param,\n+                        hir_id,\n+                        segment.ident.span,\n+                        Some(receiver),\n+                        args,\n+                    ) {\n+                        return true;\n+                    }\n+                }\n+                if let Some(param_to_point_at) = param_to_point_at\n+                    && self.point_at_generic_if_possible(error, def_id, param_to_point_at, segment)\n+                {\n+                    return true;\n+                }\n+            }\n+            hir::ExprKind::Struct(qpath, fields, ..) => {\n+                if let Res::Def(\n+                    hir::def::DefKind::Struct | hir::def::DefKind::Variant,\n+                    variant_def_id,\n+                ) = self.typeck_results.borrow().qpath_res(qpath, hir_id)\n+                {\n+                    for param in\n+                        [param_to_point_at, fallback_param_to_point_at, self_param_to_point_at]\n+                    {\n+                        if let Some(param) = param {\n+                            let refined_expr = self.point_at_field_if_possible(\n+                                def_id,\n+                                param,\n+                                variant_def_id,\n+                                fields,\n+                            );\n+\n+                            match refined_expr {\n+                                None => {}\n+                                Some((refined_expr, _)) => {\n+                                    error.obligation.cause.span = refined_expr\n+                                        .span\n+                                        .find_ancestor_in_same_ctxt(error.obligation.cause.span)\n+                                        .unwrap_or(refined_expr.span);\n+                                    return true;\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+                if let Some(param_to_point_at) = param_to_point_at\n+                    && self.point_at_path_if_possible(error, def_id, param_to_point_at, qpath)\n+                {\n+                    return true;\n+                }\n+            }\n+            _ => {}\n+        }\n+\n+        false\n+    }\n+\n+    fn point_at_path_if_possible(\n+        &self,\n+        error: &mut traits::FulfillmentError<'tcx>,\n+        def_id: DefId,\n+        param: ty::GenericArg<'tcx>,\n+        qpath: &hir::QPath<'tcx>,\n+    ) -> bool {\n+        match qpath {\n+            hir::QPath::Resolved(_, path) => {\n+                if let Some(segment) = path.segments.last()\n+                    && self.point_at_generic_if_possible(error, def_id, param, segment)\n+                {\n+                    return true;\n+                }\n+            }\n+            hir::QPath::TypeRelative(_, segment) => {\n+                if self.point_at_generic_if_possible(error, def_id, param, segment) {\n+                    return true;\n+                }\n+            }\n+            _ => {}\n+        }\n+\n+        false\n+    }\n+\n+    fn point_at_generic_if_possible(\n+        &self,\n+        error: &mut traits::FulfillmentError<'tcx>,\n+        def_id: DefId,\n+        param_to_point_at: ty::GenericArg<'tcx>,\n+        segment: &hir::PathSegment<'tcx>,\n+    ) -> bool {\n+        let own_substs = self\n+            .tcx\n+            .generics_of(def_id)\n+            .own_substs(ty::InternalSubsts::identity_for_item(self.tcx, def_id));\n+        let Some((index, _)) = own_substs\n+            .iter()\n+            .filter(|arg| matches!(arg.unpack(), ty::GenericArgKind::Type(_)))\n+            .enumerate()\n+            .find(|(_, arg)| **arg == param_to_point_at) else { return false };\n+        let Some(arg) = segment\n+            .args()\n+            .args\n+            .iter()\n+            .filter(|arg| matches!(arg, hir::GenericArg::Type(_)))\n+            .nth(index) else { return false; };\n+        error.obligation.cause.span = arg\n+            .span()\n+            .find_ancestor_in_same_ctxt(error.obligation.cause.span)\n+            .unwrap_or(arg.span());\n+        true\n+    }\n+\n+    fn find_ambiguous_parameter_in<T: TypeVisitable<'tcx>>(\n+        &self,\n+        item_def_id: DefId,\n+        t: T,\n+    ) -> Option<ty::GenericArg<'tcx>> {\n+        struct FindAmbiguousParameter<'a, 'tcx>(&'a FnCtxt<'a, 'tcx>, DefId);\n+        impl<'tcx> TypeVisitor<'tcx> for FindAmbiguousParameter<'_, 'tcx> {\n+            type BreakTy = ty::GenericArg<'tcx>;\n+            fn visit_ty(&mut self, ty: Ty<'tcx>) -> std::ops::ControlFlow<Self::BreakTy> {\n+                if let Some(origin) = self.0.type_var_origin(ty)\n+                    && let rustc_infer::infer::type_variable::TypeVariableOriginKind::TypeParameterDefinition(_, Some(def_id)) =\n+                        origin.kind\n+                    && let generics = self.0.tcx.generics_of(self.1)\n+                    && let Some(index) = generics.param_def_id_to_index(self.0.tcx, def_id)\n+                    && let Some(subst) = ty::InternalSubsts::identity_for_item(self.0.tcx, self.1)\n+                        .get(index as usize)\n+                {\n+                    ControlFlow::Break(*subst)\n+                } else {\n+                    ty.super_visit_with(self)\n+                }\n+            }\n+        }\n+        t.visit_with(&mut FindAmbiguousParameter(self, item_def_id)).break_value()\n+    }\n+\n+    fn closure_span_overlaps_error(\n+        &self,\n+        error: &traits::FulfillmentError<'tcx>,\n+        span: Span,\n+    ) -> bool {\n+        if let traits::FulfillmentErrorCode::CodeSelectionError(\n+            traits::SelectionError::OutputTypeParameterMismatch(_, expected, _),\n+        ) = error.code\n+            && let ty::Closure(def_id, _) | ty::Generator(def_id, ..) = expected.skip_binder().self_ty().kind()\n+            && span.overlaps(self.tcx.def_span(*def_id))\n+        {\n+            true\n+        } else {\n+            false\n+        }\n+    }\n+\n+    fn point_at_field_if_possible(\n+        &self,\n+        def_id: DefId,\n+        param_to_point_at: ty::GenericArg<'tcx>,\n+        variant_def_id: DefId,\n+        expr_fields: &[hir::ExprField<'tcx>],\n+    ) -> Option<(&'tcx hir::Expr<'tcx>, Ty<'tcx>)> {\n+        let def = self.tcx.adt_def(def_id);\n+\n+        let identity_substs = ty::InternalSubsts::identity_for_item(self.tcx, def_id);\n+        let fields_referencing_param: Vec<_> = def\n+            .variant_with_id(variant_def_id)\n+            .fields\n+            .iter()\n+            .filter(|field| {\n+                let field_ty = field.ty(self.tcx, identity_substs);\n+                Self::find_param_in_ty(field_ty.into(), param_to_point_at)\n+            })\n+            .collect();\n+\n+        if let [field] = fields_referencing_param.as_slice() {\n+            for expr_field in expr_fields {\n+                // Look for the ExprField that matches the field, using the\n+                // same rules that check_expr_struct uses for macro hygiene.\n+                if self.tcx.adjust_ident(expr_field.ident, variant_def_id) == field.ident(self.tcx)\n+                {\n+                    return Some((expr_field.expr, self.tcx.type_of(field.did)));\n+                }\n+            }\n+        }\n+\n+        None\n+    }\n+\n+    /// - `blame_specific_*` means that the function will recursively traverse the expression,\n+    /// looking for the most-specific-possible span to blame.\n+    ///\n+    /// - `point_at_*` means that the function will only go \"one level\", pointing at the specific\n+    /// expression mentioned.\n+    ///\n+    /// `blame_specific_arg_if_possible` will find the most-specific expression anywhere inside\n+    /// the provided function call expression, and mark it as responsible for the fullfillment\n+    /// error.\n+    fn blame_specific_arg_if_possible(\n+        &self,\n+        error: &mut traits::FulfillmentError<'tcx>,\n+        def_id: DefId,\n+        param_to_point_at: ty::GenericArg<'tcx>,\n+        call_hir_id: hir::HirId,\n+        callee_span: Span,\n+        receiver: Option<&'tcx hir::Expr<'tcx>>,\n+        args: &'tcx [hir::Expr<'tcx>],\n+    ) -> bool {\n+        let ty = self.tcx.type_of(def_id);\n+        if !ty.is_fn() {\n+            return false;\n+        }\n+        let sig = ty.fn_sig(self.tcx).skip_binder();\n+        let args_referencing_param: Vec<_> = sig\n+            .inputs()\n+            .iter()\n+            .enumerate()\n+            .filter(|(_, ty)| Self::find_param_in_ty((**ty).into(), param_to_point_at))\n+            .collect();\n+        // If there's one field that references the given generic, great!\n+        if let [(idx, _)] = args_referencing_param.as_slice()\n+            && let Some(arg) = receiver\n+                .map_or(args.get(*idx), |rcvr| if *idx == 0 { Some(rcvr) } else { args.get(*idx - 1) }) {\n+\n+            error.obligation.cause.span = arg.span.find_ancestor_in_same_ctxt(error.obligation.cause.span).unwrap_or(arg.span);\n+\n+            if let hir::Node::Expr(arg_expr) = self.tcx.hir().get(arg.hir_id) {\n+                // This is more specific than pointing at the entire argument.\n+                self.blame_specific_expr_if_possible(error, arg_expr)\n+            }\n+\n+            error.obligation.cause.map_code(|parent_code| {\n+                ObligationCauseCode::FunctionArgumentObligation {\n+                    arg_hir_id: arg.hir_id,\n+                    call_hir_id,\n+                    parent_code,\n+                }\n+            });\n+            return true;\n+        } else if args_referencing_param.len() > 0 {\n+            // If more than one argument applies, then point to the callee span at least...\n+            // We have chance to fix this up further in `point_at_generics_if_possible`\n+            error.obligation.cause.span = callee_span;\n+        }\n+\n+        false\n+    }\n+\n     /**\n      * Recursively searches for the most-specific blamable expression.\n      * For example, if you have a chain of constraints like:"}, {"sha": "2a1265600de8b32738e227b6670768c98af19401", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/checks.rs", "status": "modified", "additions": 1, "deletions": 369, "changes": 370, "blob_url": "https://github.com/rust-lang/rust/blob/3f059f60467419823e2a63d6d20f414829040f2f/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f059f60467419823e2a63d6d20f414829040f2f/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2Fchecks.rs?ref=3f059f60467419823e2a63d6d20f414829040f2f", "patch": "@@ -26,7 +26,7 @@ use rustc_infer::infer::InferOk;\n use rustc_infer::infer::TypeTrace;\n use rustc_middle::ty::adjustment::AllowTwoPhase;\n use rustc_middle::ty::visit::TypeVisitable;\n-use rustc_middle::ty::{self, DefIdTree, IsSuggestable, Ty, TypeSuperVisitable, TypeVisitor};\n+use rustc_middle::ty::{self, DefIdTree, IsSuggestable, Ty};\n use rustc_session::Session;\n use rustc_span::symbol::{kw, Ident};\n use rustc_span::{self, sym, Span};\n@@ -36,8 +36,6 @@ use std::iter;\n use std::mem;\n use std::slice;\n \n-use std::ops::ControlFlow;\n-\n impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     pub(in super::super) fn check_casts(&mut self) {\n         // don't hold the borrow to deferred_cast_checks while checking to avoid borrow checker errors\n@@ -1758,372 +1756,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         }\n     }\n \n-    fn adjust_fulfillment_error_for_expr_obligation(\n-        &self,\n-        error: &mut traits::FulfillmentError<'tcx>,\n-    ) -> bool {\n-        let (traits::ExprItemObligation(def_id, hir_id, idx) | traits::ExprBindingObligation(def_id, _, hir_id, idx))\n-            = *error.obligation.cause.code().peel_derives() else { return false; };\n-        let hir = self.tcx.hir();\n-        let hir::Node::Expr(expr) = hir.get(hir_id) else { return false; };\n-\n-        let Some(unsubstituted_pred) =\n-            self.tcx.predicates_of(def_id).instantiate_identity(self.tcx).predicates.into_iter().nth(idx)\n-            else { return false; };\n-\n-        let generics = self.tcx.generics_of(def_id);\n-        let predicate_substs = match unsubstituted_pred.kind().skip_binder() {\n-            ty::PredicateKind::Clause(ty::Clause::Trait(pred)) => pred.trait_ref.substs,\n-            ty::PredicateKind::Clause(ty::Clause::Projection(pred)) => pred.projection_ty.substs,\n-            _ => ty::List::empty(),\n-        };\n-\n-        let find_param_matching = |matches: &dyn Fn(&ty::ParamTy) -> bool| {\n-            predicate_substs.types().find_map(|ty| {\n-                ty.walk().find_map(|arg| {\n-                    if let ty::GenericArgKind::Type(ty) = arg.unpack()\n-                        && let ty::Param(param_ty) = ty.kind()\n-                        && matches(param_ty)\n-                    {\n-                        Some(arg)\n-                    } else {\n-                        None\n-                    }\n-                })\n-            })\n-        };\n-\n-        // Prefer generics that are local to the fn item, since these are likely\n-        // to be the cause of the unsatisfied predicate.\n-        let mut param_to_point_at = find_param_matching(&|param_ty| {\n-            self.tcx.parent(generics.type_param(param_ty, self.tcx).def_id) == def_id\n-        });\n-        // Fall back to generic that isn't local to the fn item. This will come\n-        // from a trait or impl, for example.\n-        let mut fallback_param_to_point_at = find_param_matching(&|param_ty| {\n-            self.tcx.parent(generics.type_param(param_ty, self.tcx).def_id) != def_id\n-                && param_ty.name != rustc_span::symbol::kw::SelfUpper\n-        });\n-        // Finally, the `Self` parameter is possibly the reason that the predicate\n-        // is unsatisfied. This is less likely to be true for methods, because\n-        // method probe means that we already kinda check that the predicates due\n-        // to the `Self` type are true.\n-        let mut self_param_to_point_at =\n-            find_param_matching(&|param_ty| param_ty.name == rustc_span::symbol::kw::SelfUpper);\n-\n-        // Finally, for ambiguity-related errors, we actually want to look\n-        // for a parameter that is the source of the inference type left\n-        // over in this predicate.\n-        if let traits::FulfillmentErrorCode::CodeAmbiguity = error.code {\n-            fallback_param_to_point_at = None;\n-            self_param_to_point_at = None;\n-            param_to_point_at =\n-                self.find_ambiguous_parameter_in(def_id, error.root_obligation.predicate);\n-        }\n-\n-        if self.closure_span_overlaps_error(error, expr.span) {\n-            return false;\n-        }\n-\n-        match &expr.kind {\n-            hir::ExprKind::Path(qpath) => {\n-                if let hir::Node::Expr(hir::Expr {\n-                    kind: hir::ExprKind::Call(callee, args),\n-                    hir_id: call_hir_id,\n-                    span: call_span,\n-                    ..\n-                }) = hir.get_parent(expr.hir_id)\n-                    && callee.hir_id == expr.hir_id\n-                {\n-                    if self.closure_span_overlaps_error(error, *call_span) {\n-                        return false;\n-                    }\n-\n-                    for param in\n-                        [param_to_point_at, fallback_param_to_point_at, self_param_to_point_at]\n-                        .into_iter()\n-                        .flatten()\n-                    {\n-                        if self.blame_specific_arg_if_possible(\n-                                error,\n-                                def_id,\n-                                param,\n-                                *call_hir_id,\n-                                callee.span,\n-                                None,\n-                                args,\n-                            )\n-                        {\n-                            return true;\n-                        }\n-                    }\n-                }\n-                // Notably, we only point to params that are local to the\n-                // item we're checking, since those are the ones we are able\n-                // to look in the final `hir::PathSegment` for. Everything else\n-                // would require a deeper search into the `qpath` than I think\n-                // is worthwhile.\n-                if let Some(param_to_point_at) = param_to_point_at\n-                    && self.point_at_path_if_possible(error, def_id, param_to_point_at, qpath)\n-                {\n-                    return true;\n-                }\n-            }\n-            hir::ExprKind::MethodCall(segment, receiver, args, ..) => {\n-                for param in [param_to_point_at, fallback_param_to_point_at, self_param_to_point_at]\n-                    .into_iter()\n-                    .flatten()\n-                {\n-                    if self.blame_specific_arg_if_possible(\n-                        error,\n-                        def_id,\n-                        param,\n-                        hir_id,\n-                        segment.ident.span,\n-                        Some(receiver),\n-                        args,\n-                    ) {\n-                        return true;\n-                    }\n-                }\n-                if let Some(param_to_point_at) = param_to_point_at\n-                    && self.point_at_generic_if_possible(error, def_id, param_to_point_at, segment)\n-                {\n-                    return true;\n-                }\n-            }\n-            hir::ExprKind::Struct(qpath, fields, ..) => {\n-                if let Res::Def(DefKind::Struct | DefKind::Variant, variant_def_id) =\n-                    self.typeck_results.borrow().qpath_res(qpath, hir_id)\n-                {\n-                    for param in\n-                        [param_to_point_at, fallback_param_to_point_at, self_param_to_point_at]\n-                    {\n-                        if let Some(param) = param {\n-                            let refined_expr = self.point_at_field_if_possible(\n-                                def_id,\n-                                param,\n-                                variant_def_id,\n-                                fields,\n-                            );\n-\n-                            match refined_expr {\n-                                None => {}\n-                                Some((refined_expr, _)) => {\n-                                    error.obligation.cause.span = refined_expr\n-                                        .span\n-                                        .find_ancestor_in_same_ctxt(error.obligation.cause.span)\n-                                        .unwrap_or(refined_expr.span);\n-                                    return true;\n-                                }\n-                            }\n-                        }\n-                    }\n-                }\n-                if let Some(param_to_point_at) = param_to_point_at\n-                    && self.point_at_path_if_possible(error, def_id, param_to_point_at, qpath)\n-                {\n-                    return true;\n-                }\n-            }\n-            _ => {}\n-        }\n-\n-        false\n-    }\n-\n-    fn closure_span_overlaps_error(\n-        &self,\n-        error: &traits::FulfillmentError<'tcx>,\n-        span: Span,\n-    ) -> bool {\n-        if let traits::FulfillmentErrorCode::CodeSelectionError(\n-            traits::SelectionError::OutputTypeParameterMismatch(_, expected, _),\n-        ) = error.code\n-            && let ty::Closure(def_id, _) | ty::Generator(def_id, ..) = expected.skip_binder().self_ty().kind()\n-            && span.overlaps(self.tcx.def_span(*def_id))\n-        {\n-            true\n-        } else {\n-            false\n-        }\n-    }\n-\n-    /// - `blame_specific_*` means that the function will recursively traverse the expression,\n-    /// looking for the most-specific-possible span to blame.\n-    ///\n-    /// - `point_at_*` means that the function will only go \"one level\", pointing at the specific\n-    /// expression mentioned.\n-    ///\n-    /// `blame_specific_arg_if_possible` will find the most-specific expression anywhere inside\n-    /// the provided function call expression, and mark it as responsible for the fullfillment\n-    /// error.\n-    fn blame_specific_arg_if_possible(\n-        &self,\n-        error: &mut traits::FulfillmentError<'tcx>,\n-        def_id: DefId,\n-        param_to_point_at: ty::GenericArg<'tcx>,\n-        call_hir_id: hir::HirId,\n-        callee_span: Span,\n-        receiver: Option<&'tcx hir::Expr<'tcx>>,\n-        args: &'tcx [hir::Expr<'tcx>],\n-    ) -> bool {\n-        let ty = self.tcx.type_of(def_id);\n-        if !ty.is_fn() {\n-            return false;\n-        }\n-        let sig = ty.fn_sig(self.tcx).skip_binder();\n-        let args_referencing_param: Vec<_> = sig\n-            .inputs()\n-            .iter()\n-            .enumerate()\n-            .filter(|(_, ty)| Self::find_param_in_ty((**ty).into(), param_to_point_at))\n-            .collect();\n-        // If there's one field that references the given generic, great!\n-        if let [(idx, _)] = args_referencing_param.as_slice()\n-            && let Some(arg) = receiver\n-                .map_or(args.get(*idx), |rcvr| if *idx == 0 { Some(rcvr) } else { args.get(*idx - 1) }) {\n-\n-            error.obligation.cause.span = arg.span.find_ancestor_in_same_ctxt(error.obligation.cause.span).unwrap_or(arg.span);\n-\n-            if let hir::Node::Expr(arg_expr) = self.tcx.hir().get(arg.hir_id) {\n-                // This is more specific than pointing at the entire argument.\n-                self.blame_specific_expr_if_possible(error, arg_expr)\n-            }\n-\n-            error.obligation.cause.map_code(|parent_code| {\n-                ObligationCauseCode::FunctionArgumentObligation {\n-                    arg_hir_id: arg.hir_id,\n-                    call_hir_id,\n-                    parent_code,\n-                }\n-            });\n-            return true;\n-        } else if args_referencing_param.len() > 0 {\n-            // If more than one argument applies, then point to the callee span at least...\n-            // We have chance to fix this up further in `point_at_generics_if_possible`\n-            error.obligation.cause.span = callee_span;\n-        }\n-\n-        false\n-    }\n-\n-    // FIXME: Make this private and move to mod adjust_fulfillment_errors\n-    pub fn point_at_field_if_possible(\n-        &self,\n-        def_id: DefId,\n-        param_to_point_at: ty::GenericArg<'tcx>,\n-        variant_def_id: DefId,\n-        expr_fields: &[hir::ExprField<'tcx>],\n-    ) -> Option<(&'tcx hir::Expr<'tcx>, Ty<'tcx>)> {\n-        let def = self.tcx.adt_def(def_id);\n-\n-        let identity_substs = ty::InternalSubsts::identity_for_item(self.tcx, def_id);\n-        let fields_referencing_param: Vec<_> = def\n-            .variant_with_id(variant_def_id)\n-            .fields\n-            .iter()\n-            .filter(|field| {\n-                let field_ty = field.ty(self.tcx, identity_substs);\n-                Self::find_param_in_ty(field_ty.into(), param_to_point_at)\n-            })\n-            .collect();\n-\n-        if let [field] = fields_referencing_param.as_slice() {\n-            for expr_field in expr_fields {\n-                // Look for the ExprField that matches the field, using the\n-                // same rules that check_expr_struct uses for macro hygiene.\n-                if self.tcx.adjust_ident(expr_field.ident, variant_def_id) == field.ident(self.tcx)\n-                {\n-                    return Some((expr_field.expr, self.tcx.type_of(field.did)));\n-                }\n-            }\n-        }\n-\n-        None\n-    }\n-\n-    fn point_at_path_if_possible(\n-        &self,\n-        error: &mut traits::FulfillmentError<'tcx>,\n-        def_id: DefId,\n-        param: ty::GenericArg<'tcx>,\n-        qpath: &QPath<'tcx>,\n-    ) -> bool {\n-        match qpath {\n-            hir::QPath::Resolved(_, path) => {\n-                if let Some(segment) = path.segments.last()\n-                    && self.point_at_generic_if_possible(error, def_id, param, segment)\n-                {\n-                    return true;\n-                }\n-            }\n-            hir::QPath::TypeRelative(_, segment) => {\n-                if self.point_at_generic_if_possible(error, def_id, param, segment) {\n-                    return true;\n-                }\n-            }\n-            _ => {}\n-        }\n-\n-        false\n-    }\n-\n-    fn point_at_generic_if_possible(\n-        &self,\n-        error: &mut traits::FulfillmentError<'tcx>,\n-        def_id: DefId,\n-        param_to_point_at: ty::GenericArg<'tcx>,\n-        segment: &hir::PathSegment<'tcx>,\n-    ) -> bool {\n-        let own_substs = self\n-            .tcx\n-            .generics_of(def_id)\n-            .own_substs(ty::InternalSubsts::identity_for_item(self.tcx, def_id));\n-        let Some((index, _)) = own_substs\n-            .iter()\n-            .filter(|arg| matches!(arg.unpack(), ty::GenericArgKind::Type(_)))\n-            .enumerate()\n-            .find(|(_, arg)| **arg == param_to_point_at) else { return false };\n-        let Some(arg) = segment\n-            .args()\n-            .args\n-            .iter()\n-            .filter(|arg| matches!(arg, hir::GenericArg::Type(_)))\n-            .nth(index) else { return false; };\n-        error.obligation.cause.span = arg\n-            .span()\n-            .find_ancestor_in_same_ctxt(error.obligation.cause.span)\n-            .unwrap_or(arg.span());\n-        true\n-    }\n-\n-    fn find_ambiguous_parameter_in<T: TypeVisitable<'tcx>>(\n-        &self,\n-        item_def_id: DefId,\n-        t: T,\n-    ) -> Option<ty::GenericArg<'tcx>> {\n-        struct FindAmbiguousParameter<'a, 'tcx>(&'a FnCtxt<'a, 'tcx>, DefId);\n-        impl<'tcx> TypeVisitor<'tcx> for FindAmbiguousParameter<'_, 'tcx> {\n-            type BreakTy = ty::GenericArg<'tcx>;\n-            fn visit_ty(&mut self, ty: Ty<'tcx>) -> std::ops::ControlFlow<Self::BreakTy> {\n-                if let Some(origin) = self.0.type_var_origin(ty)\n-                    && let TypeVariableOriginKind::TypeParameterDefinition(_, Some(def_id)) =\n-                        origin.kind\n-                    && let generics = self.0.tcx.generics_of(self.1)\n-                    && let Some(index) = generics.param_def_id_to_index(self.0.tcx, def_id)\n-                    && let Some(subst) = ty::InternalSubsts::identity_for_item(self.0.tcx, self.1)\n-                        .get(index as usize)\n-                {\n-                    ControlFlow::Break(*subst)\n-                } else {\n-                    ty.super_visit_with(self)\n-                }\n-            }\n-        }\n-        t.visit_with(&mut FindAmbiguousParameter(self, item_def_id)).break_value()\n-    }\n-\n     fn label_fn_like(\n         &self,\n         err: &mut Diagnostic,"}, {"sha": "7cc9e49b1b62adf66597091e683e21525347ca8f", "filename": "compiler/rustc_infer/src/infer/canonical/query_response.rs", "status": "modified", "additions": 16, "deletions": 25, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/3f059f60467419823e2a63d6d20f414829040f2f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f059f60467419823e2a63d6d20f414829040f2f/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=3f059f60467419823e2a63d6d20f414829040f2f", "patch": "@@ -268,14 +268,12 @@ impl<'tcx> InferCtxt<'tcx> {\n                 (GenericArgKind::Lifetime(v_o), GenericArgKind::Lifetime(v_r)) => {\n                     // To make `v_o = v_r`, we emit `v_o: v_r` and `v_r: v_o`.\n                     if v_o != v_r {\n-                        output_query_region_constraints.outlives.push((\n-                            ty::Binder::dummy(ty::OutlivesPredicate(v_o.into(), v_r)),\n-                            constraint_category,\n-                        ));\n-                        output_query_region_constraints.outlives.push((\n-                            ty::Binder::dummy(ty::OutlivesPredicate(v_r.into(), v_o)),\n-                            constraint_category,\n-                        ));\n+                        output_query_region_constraints\n+                            .outlives\n+                            .push((ty::OutlivesPredicate(v_o.into(), v_r), constraint_category));\n+                        output_query_region_constraints\n+                            .outlives\n+                            .push((ty::OutlivesPredicate(v_r.into(), v_o), constraint_category));\n                     }\n                 }\n \n@@ -318,10 +316,8 @@ impl<'tcx> InferCtxt<'tcx> {\n             query_response.value.region_constraints.outlives.iter().filter_map(|&r_c| {\n                 let r_c = substitute_value(self.tcx, &result_subst, r_c);\n \n-                // Screen out `'a: 'a` cases -- we skip the binder here but\n-                // only compare the inner values to one another, so they are still at\n-                // consistent binding levels.\n-                let ty::OutlivesPredicate(k1, r2) = r_c.0.skip_binder();\n+                // Screen out `'a: 'a` cases.\n+                let ty::OutlivesPredicate(k1, r2) = r_c.0;\n                 if k1 != r2.into() { Some(r_c) } else { None }\n             }),\n         );\n@@ -559,11 +555,11 @@ impl<'tcx> InferCtxt<'tcx> {\n \n     pub fn query_outlives_constraint_to_obligation(\n         &self,\n-        predicate: QueryOutlivesConstraint<'tcx>,\n+        (predicate, _): QueryOutlivesConstraint<'tcx>,\n         cause: ObligationCause<'tcx>,\n         param_env: ty::ParamEnv<'tcx>,\n     ) -> Obligation<'tcx, ty::Predicate<'tcx>> {\n-        let ty::OutlivesPredicate(k1, r2) = predicate.0.skip_binder();\n+        let ty::OutlivesPredicate(k1, r2) = predicate;\n \n         let atom = match k1.unpack() {\n             GenericArgKind::Lifetime(r1) => {\n@@ -578,7 +574,7 @@ impl<'tcx> InferCtxt<'tcx> {\n                 span_bug!(cause.span, \"unexpected const outlives {:?}\", predicate);\n             }\n         };\n-        let predicate = predicate.0.rebind(atom);\n+        let predicate = ty::Binder::dummy(atom);\n \n         Obligation::new(self.tcx, cause, param_env, predicate)\n     }\n@@ -643,8 +639,7 @@ pub fn make_query_region_constraints<'tcx>(\n     let outlives: Vec<_> = constraints\n         .iter()\n         .map(|(k, origin)| {\n-            // no bound vars in the code above\n-            let constraint = ty::Binder::dummy(match *k {\n+            let constraint = match *k {\n                 // Swap regions because we are going from sub (<=) to outlives\n                 // (>=).\n                 Constraint::VarSubVar(v1, v2) => ty::OutlivesPredicate(\n@@ -658,16 +653,12 @@ pub fn make_query_region_constraints<'tcx>(\n                     ty::OutlivesPredicate(tcx.mk_region(ty::ReVar(v2)).into(), r1)\n                 }\n                 Constraint::RegSubReg(r1, r2) => ty::OutlivesPredicate(r2.into(), r1),\n-            });\n+            };\n             (constraint, origin.to_constraint_category())\n         })\n-        .chain(\n-            outlives_obligations\n-                // no bound vars in the code above\n-                .map(|(ty, r, constraint_category)| {\n-                    (ty::Binder::dummy(ty::OutlivesPredicate(ty.into(), r)), constraint_category)\n-                }),\n-        )\n+        .chain(outlives_obligations.map(|(ty, r, constraint_category)| {\n+            (ty::OutlivesPredicate(ty.into(), r), constraint_category)\n+        }))\n         .collect();\n \n     QueryRegionConstraints { outlives, member_constraints: member_constraints.clone() }"}, {"sha": "9146a3739b2b1b76dfe30a8dd68ec355debede20", "filename": "compiler/rustc_llvm/llvm-wrapper/LLVMWrapper.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3f059f60467419823e2a63d6d20f414829040f2f/compiler%2Frustc_llvm%2Fllvm-wrapper%2FLLVMWrapper.h", "raw_url": "https://github.com/rust-lang/rust/raw/3f059f60467419823e2a63d6d20f414829040f2f/compiler%2Frustc_llvm%2Fllvm-wrapper%2FLLVMWrapper.h", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_llvm%2Fllvm-wrapper%2FLLVMWrapper.h?ref=3f059f60467419823e2a63d6d20f414829040f2f", "patch": "@@ -4,7 +4,6 @@\n #include \"llvm/ADT/ArrayRef.h\"\n #include \"llvm/ADT/DenseSet.h\"\n #include \"llvm/ADT/SmallVector.h\"\n-#include \"llvm/ADT/Triple.h\"\n #include \"llvm/Analysis/Lint.h\"\n #include \"llvm/Analysis/Passes.h\"\n #include \"llvm/IR/IRBuilder.h\"\n@@ -44,6 +43,12 @@\n #include \"llvm/IR/IRPrintingPasses.h\"\n #include \"llvm/Linker/Linker.h\"\n \n+#if LLVM_VERSION_GE(16, 0)\n+#include \"llvm/TargetParser/Triple.h\"\n+#else\n+#include \"llvm/ADT/Triple.h\"\n+#endif\n+\n extern \"C\" void LLVMRustSetLastError(const char *);\n \n enum class LLVMRustResult { Success, Failure };"}, {"sha": "d6f20a8fc06ec563f960c59e604c96b89464c2b7", "filename": "compiler/rustc_middle/src/infer/canonical.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/3f059f60467419823e2a63d6d20f414829040f2f/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f059f60467419823e2a63d6d20f414829040f2f/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs?ref=3f059f60467419823e2a63d6d20f414829040f2f", "patch": "@@ -324,10 +324,8 @@ impl<'tcx, V> Canonical<'tcx, V> {\n     }\n }\n \n-pub type QueryOutlivesConstraint<'tcx> = (\n-    ty::Binder<'tcx, ty::OutlivesPredicate<GenericArg<'tcx>, Region<'tcx>>>,\n-    ConstraintCategory<'tcx>,\n-);\n+pub type QueryOutlivesConstraint<'tcx> =\n+    (ty::OutlivesPredicate<GenericArg<'tcx>, Region<'tcx>>, ConstraintCategory<'tcx>);\n \n TrivialTypeTraversalAndLiftImpls! {\n     for <'tcx> {"}, {"sha": "f22c0dbc60d9d0f6a7114f0db7f87b550737eaca", "filename": "compiler/rustc_middle/src/mir/interpret/error.rs", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/3f059f60467419823e2a63d6d20f414829040f2f/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f059f60467419823e2a63d6d20f414829040f2f/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Finterpret%2Ferror.rs?ref=3f059f60467419823e2a63d6d20f414829040f2f", "patch": "@@ -430,8 +430,10 @@ pub enum ResourceExhaustionInfo {\n     ///\n     /// The exact limit is set by the `const_eval_limit` attribute.\n     StepLimitReached,\n-    /// There is not enough memory to perform an allocation.\n+    /// There is not enough memory (on the host) to perform an allocation.\n     MemoryExhausted,\n+    /// The address space (of the target) is full.\n+    AddressSpaceFull,\n }\n \n impl fmt::Display for ResourceExhaustionInfo {\n@@ -447,6 +449,9 @@ impl fmt::Display for ResourceExhaustionInfo {\n             MemoryExhausted => {\n                 write!(f, \"tried to allocate more memory than available to compiler\")\n             }\n+            AddressSpaceFull => {\n+                write!(f, \"there are no more free addresses in the address space\")\n+            }\n         }\n     }\n }"}, {"sha": "7aa9282b9beceb88301dc76df08af1845b4a101b", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3f059f60467419823e2a63d6d20f414829040f2f/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f059f60467419823e2a63d6d20f414829040f2f/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=3f059f60467419823e2a63d6d20f414829040f2f", "patch": "@@ -1541,7 +1541,6 @@ rustc_queries! {\n     query upstream_monomorphizations_for(def_id: DefId)\n         -> Option<&'tcx FxHashMap<SubstsRef<'tcx>, CrateNum>>\n     {\n-        arena_cache\n         desc { |tcx|\n             \"collecting available upstream monomorphizations for `{}`\",\n             tcx.def_path_str(def_id),"}, {"sha": "cea6033ede208f7ce091ba1f800aa1c151f9ce19", "filename": "src/doc/rustc/book.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/3f059f60467419823e2a63d6d20f414829040f2f/src%2Fdoc%2Frustc%2Fbook.toml", "raw_url": "https://github.com/rust-lang/rust/raw/3f059f60467419823e2a63d6d20f414829040f2f/src%2Fdoc%2Frustc%2Fbook.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fbook.toml?ref=3f059f60467419823e2a63d6d20f414829040f2f", "patch": "@@ -5,3 +5,4 @@ title = \"The rustc book\"\n \n [output.html]\n git-repository-url = \"https://github.com/rust-lang/rust/tree/master/src/doc/rustc\"\n+edit-url-template = \"https://github.com/rust-lang/rust/edit/master/src/doc/rustc/{path}\""}, {"sha": "1770c121a0e73064d6db671d6bf3b50b10784e5a", "filename": "src/doc/rustc/src/codegen-options/index.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f059f60467419823e2a63d6d20f414829040f2f/src%2Fdoc%2Frustc%2Fsrc%2Fcodegen-options%2Findex.md", "raw_url": "https://github.com/rust-lang/rust/raw/3f059f60467419823e2a63d6d20f414829040f2f/src%2Fdoc%2Frustc%2Fsrc%2Fcodegen-options%2Findex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fcodegen-options%2Findex.md?ref=3f059f60467419823e2a63d6d20f414829040f2f", "patch": "@@ -562,7 +562,7 @@ Supported values for this option are:\n * `v0` \u2014 The \"v0\" mangling scheme. The specific format is not specified at\n   this time.\n \n-The default if not specified will use a compiler-chosen default which may\n+The default, if not specified, will use a compiler-chosen default which may\n change in the future.\n \n [name mangling]: https://en.wikipedia.org/wiki/Name_mangling"}, {"sha": "dcb1879042041daa9e9a0d520c4ef7d7265db366", "filename": "src/tools/miri/src/intptrcast.rs", "status": "modified", "additions": 26, "deletions": 9, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/3f059f60467419823e2a63d6d20f414829040f2f/src%2Ftools%2Fmiri%2Fsrc%2Fintptrcast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f059f60467419823e2a63d6d20f414829040f2f/src%2Ftools%2Fmiri%2Fsrc%2Fintptrcast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fintptrcast.rs?ref=3f059f60467419823e2a63d6d20f414829040f2f", "patch": "@@ -162,11 +162,14 @@ impl<'mir, 'tcx> GlobalStateInner {\n         Ok(Pointer::new(Some(Provenance::Wildcard), Size::from_bytes(addr)))\n     }\n \n-    fn alloc_base_addr(ecx: &MiriInterpCx<'mir, 'tcx>, alloc_id: AllocId) -> u64 {\n+    fn alloc_base_addr(\n+        ecx: &MiriInterpCx<'mir, 'tcx>,\n+        alloc_id: AllocId,\n+    ) -> InterpResult<'tcx, u64> {\n         let mut global_state = ecx.machine.intptrcast.borrow_mut();\n         let global_state = &mut *global_state;\n \n-        match global_state.base_addr.entry(alloc_id) {\n+        Ok(match global_state.base_addr.entry(alloc_id) {\n             Entry::Occupied(entry) => *entry.get(),\n             Entry::Vacant(entry) => {\n                 // There is nothing wrong with a raw pointer being cast to an integer only after\n@@ -181,7 +184,10 @@ impl<'mir, 'tcx> GlobalStateInner {\n                     rng.gen_range(0..16)\n                 };\n                 // From next_base_addr + slack, round up to adjust for alignment.\n-                let base_addr = global_state.next_base_addr.checked_add(slack).unwrap();\n+                let base_addr = global_state\n+                    .next_base_addr\n+                    .checked_add(slack)\n+                    .ok_or_else(|| err_exhaust!(AddressSpaceFull))?;\n                 let base_addr = Self::align_addr(base_addr, align.bytes());\n                 entry.insert(base_addr);\n                 trace!(\n@@ -197,24 +203,33 @@ impl<'mir, 'tcx> GlobalStateInner {\n                 // of at least 1 to avoid two allocations having the same base address.\n                 // (The logic in `alloc_id_from_addr` assumes unique addresses, and different\n                 // function/vtable pointers need to be distinguishable!)\n-                global_state.next_base_addr = base_addr.checked_add(max(size.bytes(), 1)).unwrap();\n+                global_state.next_base_addr = base_addr\n+                    .checked_add(max(size.bytes(), 1))\n+                    .ok_or_else(|| err_exhaust!(AddressSpaceFull))?;\n+                // Even if `Size` didn't overflow, we might still have filled up the address space.\n+                if global_state.next_base_addr > ecx.machine_usize_max() {\n+                    throw_exhaust!(AddressSpaceFull);\n+                }\n                 // Given that `next_base_addr` increases in each allocation, pushing the\n                 // corresponding tuple keeps `int_to_ptr_map` sorted\n                 global_state.int_to_ptr_map.push((base_addr, alloc_id));\n \n                 base_addr\n             }\n-        }\n+        })\n     }\n \n     /// Convert a relative (tcx) pointer to an absolute address.\n-    pub fn rel_ptr_to_addr(ecx: &MiriInterpCx<'mir, 'tcx>, ptr: Pointer<AllocId>) -> u64 {\n+    pub fn rel_ptr_to_addr(\n+        ecx: &MiriInterpCx<'mir, 'tcx>,\n+        ptr: Pointer<AllocId>,\n+    ) -> InterpResult<'tcx, u64> {\n         let (alloc_id, offset) = ptr.into_parts(); // offset is relative (AllocId provenance)\n-        let base_addr = GlobalStateInner::alloc_base_addr(ecx, alloc_id);\n+        let base_addr = GlobalStateInner::alloc_base_addr(ecx, alloc_id)?;\n \n         // Add offset with the right kind of pointer-overflowing arithmetic.\n         let dl = ecx.data_layout();\n-        dl.overflowing_offset(base_addr, offset.bytes()).0\n+        Ok(dl.overflowing_offset(base_addr, offset.bytes()).0)\n     }\n \n     /// When a pointer is used for a memory access, this computes where in which allocation the\n@@ -232,7 +247,9 @@ impl<'mir, 'tcx> GlobalStateInner {\n             GlobalStateInner::alloc_id_from_addr(ecx, addr.bytes())?\n         };\n \n-        let base_addr = GlobalStateInner::alloc_base_addr(ecx, alloc_id);\n+        // This cannot fail: since we already have a pointer with that provenance, rel_ptr_to_addr\n+        // must have been called in the past.\n+        let base_addr = GlobalStateInner::alloc_base_addr(ecx, alloc_id).unwrap();\n \n         // Wrapping \"addr - base_addr\"\n         let dl = ecx.data_layout();"}, {"sha": "8e44d4d7adec8465607827b6ba9f06529a623ce3", "filename": "src/tools/miri/src/machine.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/3f059f60467419823e2a63d6d20f414829040f2f/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f059f60467419823e2a63d6d20f414829040f2f/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fmachine.rs?ref=3f059f60467419823e2a63d6d20f414829040f2f", "patch": "@@ -971,7 +971,7 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n     fn adjust_alloc_base_pointer(\n         ecx: &MiriInterpCx<'mir, 'tcx>,\n         ptr: Pointer<AllocId>,\n-    ) -> Pointer<Provenance> {\n+    ) -> InterpResult<'tcx, Pointer<Provenance>> {\n         if cfg!(debug_assertions) {\n             // The machine promises to never call us on thread-local or extern statics.\n             let alloc_id = ptr.provenance;\n@@ -985,17 +985,17 @@ impl<'mir, 'tcx> Machine<'mir, 'tcx> for MiriMachine<'mir, 'tcx> {\n                 _ => {}\n             }\n         }\n-        let absolute_addr = intptrcast::GlobalStateInner::rel_ptr_to_addr(ecx, ptr);\n+        let absolute_addr = intptrcast::GlobalStateInner::rel_ptr_to_addr(ecx, ptr)?;\n         let tag = if let Some(borrow_tracker) = &ecx.machine.borrow_tracker {\n             borrow_tracker.borrow_mut().base_ptr_tag(ptr.provenance, &ecx.machine)\n         } else {\n             // Value does not matter, SB is disabled\n             BorTag::default()\n         };\n-        Pointer::new(\n+        Ok(Pointer::new(\n             Provenance::Concrete { alloc_id: ptr.provenance, tag },\n             Size::from_bytes(absolute_addr),\n-        )\n+        ))\n     }\n \n     #[inline(always)]"}, {"sha": "ed1c6ebfece76ceed96988a2385a21c6d0145065", "filename": "src/tools/miri/src/shims/backtrace.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/3f059f60467419823e2a63d6d20f414829040f2f/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fbacktrace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f059f60467419823e2a63d6d20f414829040f2f/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fbacktrace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fbacktrace.rs?ref=3f059f60467419823e2a63d6d20f414829040f2f", "patch": "@@ -190,9 +190,9 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n             0 => {\n                 // These are \"mutable\" allocations as we consider them to be owned by the callee.\n                 let name_alloc =\n-                    this.allocate_str(&name, MiriMemoryKind::Rust.into(), Mutability::Mut);\n+                    this.allocate_str(&name, MiriMemoryKind::Rust.into(), Mutability::Mut)?;\n                 let filename_alloc =\n-                    this.allocate_str(&filename, MiriMemoryKind::Rust.into(), Mutability::Mut);\n+                    this.allocate_str(&filename, MiriMemoryKind::Rust.into(), Mutability::Mut)?;\n \n                 this.write_immediate(\n                     name_alloc.to_ref(this),"}, {"sha": "0ea1137200b9d98177de5a0770fa040a7fd19471", "filename": "src/tools/miri/src/shims/panic.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3f059f60467419823e2a63d6d20f414829040f2f/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3f059f60467419823e2a63d6d20f414829040f2f/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fmiri%2Fsrc%2Fshims%2Fpanic.rs?ref=3f059f60467419823e2a63d6d20f414829040f2f", "patch": "@@ -172,7 +172,7 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriInterpCxExt<'mir, 'tcx> {\n         let this = self.eval_context_mut();\n \n         // First arg: message.\n-        let msg = this.allocate_str(msg, MiriMemoryKind::Machine.into(), Mutability::Not);\n+        let msg = this.allocate_str(msg, MiriMemoryKind::Machine.into(), Mutability::Not)?;\n \n         // Call the lang item.\n         let panic = this.tcx.lang_items().panic_fn().unwrap();"}]}