{"sha": "f203fc7daf8d598a7eacee1a135f2fd92dc6382e", "node_id": "MDY6Q29tbWl0NzI0NzEyOmYyMDNmYzdkYWY4ZDU5OGE3ZWFjZWUxYTEzNWYyZmQ5MmRjNjM4MmU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-28T05:46:53Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-28T05:46:53Z"}, "message": "auto merge of #12348 : brunoabinader/rust/libcollections-list-refactory, r=alexcrichton\n\nThis PR includes:\r\n- Create an iterator for ```List<T>``` called ```Items<T>```;\r\n- Move all list operations inside ```List<T>``` impl;\r\n- Removed functions that are already provided by ```Iterator``` trait;\r\n- Refactor on ```len()``` and ```is_empty``` using ```Container``` trait;\r\n- Bunch of minor fixes;\r\n\r\nA replacement for using @ is intended, but still in discussion.\r\n\r\nCloses #12344.", "tree": {"sha": "d9519b932dd81fc44b4290554a7722d729d1fdc2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d9519b932dd81fc44b4290554a7722d729d1fdc2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f203fc7daf8d598a7eacee1a135f2fd92dc6382e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f203fc7daf8d598a7eacee1a135f2fd92dc6382e", "html_url": "https://github.com/rust-lang/rust/commit/f203fc7daf8d598a7eacee1a135f2fd92dc6382e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f203fc7daf8d598a7eacee1a135f2fd92dc6382e/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "700fd35fb9d448c5e1658c3cec9c1153c57cc802", "url": "https://api.github.com/repos/rust-lang/rust/commits/700fd35fb9d448c5e1658c3cec9c1153c57cc802", "html_url": "https://github.com/rust-lang/rust/commit/700fd35fb9d448c5e1658c3cec9c1153c57cc802"}, {"sha": "4da6d041c268d58654d54b317288c940e5c623fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/4da6d041c268d58654d54b317288c940e5c623fd", "html_url": "https://github.com/rust-lang/rust/commit/4da6d041c268d58654d54b317288c940e5c623fd"}], "stats": {"total": 394, "additions": 177, "deletions": 217}, "files": [{"sha": "bb299b107c7db9e22aaab0963f4c815a79c2d462", "filename": "src/doc/rust.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/f203fc7daf8d598a7eacee1a135f2fd92dc6382e/src%2Fdoc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/f203fc7daf8d598a7eacee1a135f2fd92dc6382e/src%2Fdoc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust.md?ref=f203fc7daf8d598a7eacee1a135f2fd92dc6382e", "patch": "@@ -3256,10 +3256,10 @@ An example of a *recursive* type and its use:\n ~~~~\n enum List<T> {\n   Nil,\n-  Cons(T, @List<T>)\n+  Cons(T, ~List<T>)\n }\n \n-let a: List<int> = Cons(7, @Cons(13, @Nil));\n+let a: List<int> = Cons(7, ~Cons(13, ~Nil));\n ~~~~\n \n ### Pointer types"}, {"sha": "1fc88eda37b5fcb3c090247b308ef9a68e93b036", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f203fc7daf8d598a7eacee1a135f2fd92dc6382e/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f203fc7daf8d598a7eacee1a135f2fd92dc6382e/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=f203fc7daf8d598a7eacee1a135f2fd92dc6382e", "patch": "@@ -25,7 +25,6 @@\n extern crate collections;\n \n use collections::list::{List, Cons, Nil};\n-use collections::list;\n \n use std::cast::{transmute, transmute_mut, transmute_mut_region};\n use std::cast;\n@@ -44,7 +43,7 @@ use std::vec;\n // The way arena uses arrays is really deeply awful. The arrays are\n // allocated, and have capacities reserved, but the fill for the array\n // will always stay at 0.\n-#[deriving(Clone)]\n+#[deriving(Clone, Eq)]\n struct Chunk {\n     data: Rc<RefCell<~[u8]>>,\n     fill: Cell<uint>,\n@@ -119,13 +118,11 @@ impl Drop for Arena {\n     fn drop(&mut self) {\n         unsafe {\n             destroy_chunk(&self.head);\n-\n-            list::each(self.chunks.get(), |chunk| {\n+            for chunk in self.chunks.get().iter() {\n                 if !chunk.is_pod.get() {\n                     destroy_chunk(chunk);\n                 }\n-                true\n-            });\n+            }\n         }\n     }\n }"}, {"sha": "2359b7ec7694f7b33bda39033d122d127efda263", "filename": "src/libcollections/list.rs", "status": "modified", "additions": 145, "deletions": 185, "changes": 330, "blob_url": "https://github.com/rust-lang/rust/blob/f203fc7daf8d598a7eacee1a135f2fd92dc6382e/src%2Flibcollections%2Flist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f203fc7daf8d598a7eacee1a135f2fd92dc6382e/src%2Flibcollections%2Flist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcollections%2Flist.rs?ref=f203fc7daf8d598a7eacee1a135f2fd92dc6382e", "patch": "@@ -10,7 +10,7 @@\n \n //! A standard, garbage-collected linked list.\n \n-\n+use std::container::Container;\n \n #[deriving(Clone, Eq)]\n #[allow(missing_doc)]\n@@ -19,259 +19,219 @@ pub enum List<T> {\n     Nil,\n }\n \n-/// Create a list from a vector\n-pub fn from_vec<T:Clone + 'static>(v: &[T]) -> @List<T> {\n-    v.rev_iter().fold(@Nil::<T>, |t, h| @Cons((*h).clone(), t))\n-}\n-\n-/**\n- * Left fold\n- *\n- * Applies `f` to `u` and the first element in the list, then applies `f` to\n- * the result of the previous call and the second element, and so on,\n- * returning the accumulated result.\n- *\n- * # Arguments\n- *\n- * * ls - The list to fold\n- * * z - The initial value\n- * * f - The function to apply\n- */\n-pub fn foldl<T:Clone,U>(z: T, ls: @List<U>, f: |&T, &U| -> T) -> T {\n-    let mut accum: T = z;\n-    iter(ls, |elt| accum = f(&accum, elt));\n-    accum\n+pub struct Items<'a, T> {\n+    priv head: &'a List<T>,\n+    priv next: Option<&'a @List<T>>\n }\n \n-/**\n- * Search for an element that matches a given predicate\n- *\n- * Apply function `f` to each element of `ls`, starting from the first.\n- * When function `f` returns true then an option containing the element\n- * is returned. If `f` matches no elements then none is returned.\n- */\n-pub fn find<T:Clone>(ls: @List<T>, f: |&T| -> bool) -> Option<T> {\n-    let mut ls = ls;\n-    loop {\n-        ls = match *ls {\n-          Cons(ref hd, tl) => {\n-            if f(hd) { return Some((*hd).clone()); }\n-            tl\n-          }\n-          Nil => return None\n+impl<'a, T> Iterator<&'a T> for Items<'a, T> {\n+    fn next(&mut self) -> Option<&'a T> {\n+        match self.next {\n+            None => match *self.head {\n+                Nil => None,\n+                Cons(ref value, ref tail) => {\n+                    self.next = Some(tail);\n+                    Some(value)\n+                }\n+            },\n+            Some(next) => match **next {\n+                Nil => None,\n+                Cons(ref value, ref tail) => {\n+                    self.next = Some(tail);\n+                    Some(value)\n+                }\n+            }\n         }\n-    };\n+    }\n }\n \n-/**\n- * Returns true if a list contains an element that matches a given predicate\n- *\n- * Apply function `f` to each element of `ls`, starting from the first.\n- * When function `f` returns true then it also returns true. If `f` matches no\n- * elements then false is returned.\n- */\n-pub fn any<T>(ls: @List<T>, f: |&T| -> bool) -> bool {\n-    let mut ls = ls;\n-    loop {\n-        ls = match *ls {\n-            Cons(ref hd, tl) => {\n-                if f(hd) { return true; }\n-                tl\n-            }\n-            Nil => return false\n+impl<T> List<T> {\n+    /// Returns a forward iterator\n+    pub fn iter<'a>(&'a self) -> Items<'a, T> {\n+        Items {\n+            head: self,\n+            next: None\n         }\n-    };\n-}\n+    }\n \n-/// Returns true if a list contains an element with the given value\n-pub fn has<T:Eq>(ls: @List<T>, elt: T) -> bool {\n-    let mut found = false;\n-    each(ls, |e| {\n-        if *e == elt { found = true; false } else { true }\n-    });\n-    return found;\n-}\n+    /// Returns the first element of a list\n+    pub fn head<'a>(&'a self) -> Option<&'a T> {\n+        match *self {\n+          Nil => None,\n+          Cons(ref head, _) => Some(head)\n+        }\n+    }\n \n-/// Returns true if the list is empty\n-pub fn is_empty<T>(ls: @List<T>) -> bool {\n-    match *ls {\n-        Nil => true,\n-        _ => false\n+    /// Returns all but the first element of a list\n+    pub fn tail(&self) -> Option<@List<T>> {\n+        match *self {\n+            Nil => None,\n+            Cons(_, tail) => Some(tail)\n+        }\n     }\n }\n \n-/// Returns the length of a list\n-pub fn len<T>(ls: @List<T>) -> uint {\n-    let mut count = 0u;\n-    iter(ls, |_e| count += 1u);\n-    count\n-}\n+impl<T> Container for List<T> {\n+    /// Returns the length of a list\n+    fn len(&self) -> uint { self.iter().len() }\n \n-/// Returns all but the first element of a list\n-pub fn tail<T>(ls: @List<T>) -> @List<T> {\n-    match *ls {\n-        Cons(_, tl) => return tl,\n-        Nil => fail!(\"list empty\")\n-    }\n+    /// Returns true if the list is empty\n+    fn is_empty(&self) -> bool { match *self { Nil => true, _ => false } }\n }\n \n-/// Returns the first element of a list\n-pub fn head<T:Clone>(ls: @List<T>) -> T {\n-    match *ls {\n-      Cons(ref hd, _) => (*hd).clone(),\n-      // makes me sad\n-      _ => fail!(\"head invoked on empty list\")\n+impl<T:Eq> List<T> {\n+    /// Returns true if a list contains an element with the given value\n+    pub fn contains(&self, element: T) -> bool {\n+        self.iter().any(|list_element| *list_element == element)\n     }\n }\n \n-/// Appends one list to another\n-pub fn append<T:Clone + 'static>(l: @List<T>, m: @List<T>) -> @List<T> {\n-    match *l {\n-      Nil => return m,\n-      Cons(ref x, xs) => {\n-        let rest = append(xs, m);\n-        return @Cons((*x).clone(), rest);\n-      }\n+impl<T:'static + Clone> List<T> {\n+    /// Create a list from a vector\n+    pub fn from_vec(v: &[T]) -> List<T> {\n+        match v.len() {\n+            0 => Nil,\n+            _ => v.rev_iter().fold(Nil, |tail, value: &T| Cons(value.clone(), @tail))\n+        }\n     }\n-}\n \n-/*\n-/// Push one element into the front of a list, returning a new list\n-/// THIS VERSION DOESN'T ACTUALLY WORK\n-fn push<T:Clone>(ll: &mut @list<T>, vv: T) {\n-    ll = &mut @cons(vv, *ll)\n-}\n-*/\n-\n-/// Iterate over a list\n-pub fn iter<T>(l: @List<T>, f: |&T|) {\n-    let mut cur = l;\n-    loop {\n-        cur = match *cur {\n-          Cons(ref hd, tl) => {\n-            f(hd);\n-            tl\n-          }\n-          Nil => break\n+    /// Appends one list to another, returning a new list\n+    pub fn append(&self, other: List<T>) -> List<T> {\n+        match other {\n+            Nil => return self.clone(),\n+            _ => match *self {\n+                Nil => return other,\n+                Cons(ref value, tail) => Cons(value.clone(), @tail.append(other))\n+            }\n         }\n     }\n-}\n \n-/// Iterate over a list\n-pub fn each<T>(l: @List<T>, f: |&T| -> bool) -> bool {\n-    let mut cur = l;\n-    loop {\n-        cur = match *cur {\n-          Cons(ref hd, tl) => {\n-            if !f(hd) { return false; }\n-            tl\n-          }\n-          Nil => { return true; }\n-        }\n+    /// Push one element into the front of a list, returning a new list\n+    pub fn unshift(&self, element: T) -> List<T> {\n+        Cons(element, @(self.clone()))\n     }\n }\n \n #[cfg(test)]\n mod tests {\n-    use list::{List, Nil, from_vec, head, is_empty, tail};\n+    use list::{List, Nil};\n     use list;\n \n-    use std::option;\n+    #[test]\n+    fn test_iter() {\n+        let list = List::from_vec([0, 1, 2]);\n+        let mut iter = list.iter();\n+        assert_eq!(&0, iter.next().unwrap());\n+        assert_eq!(&1, iter.next().unwrap());\n+        assert_eq!(&2, iter.next().unwrap());\n+        assert_eq!(None, iter.next());\n+    }\n \n     #[test]\n     fn test_is_empty() {\n-        let empty : @list::List<int> = from_vec([]);\n-        let full1 = from_vec([1]);\n-        let full2 = from_vec(['r', 'u']);\n+        let empty : list::List<int> = List::from_vec([]);\n+        let full1 = List::from_vec([1]);\n+        let full2 = List::from_vec(['r', 'u']);\n \n-        assert!(is_empty(empty));\n-        assert!(!is_empty(full1));\n-        assert!(!is_empty(full2));\n+        assert!(empty.is_empty());\n+        assert!(!full1.is_empty());\n+        assert!(!full2.is_empty());\n     }\n \n     #[test]\n     fn test_from_vec() {\n-        let l = from_vec([0, 1, 2]);\n+        let list = List::from_vec([0, 1, 2]);\n+        assert_eq!(list.head().unwrap(), &0);\n \n-        assert_eq!(head(l), 0);\n+        let mut tail = list.tail().unwrap();\n+        assert_eq!(tail.head().unwrap(), &1);\n \n-        let tail_l = tail(l);\n-        assert_eq!(head(tail_l), 1);\n-\n-        let tail_tail_l = tail(tail_l);\n-        assert_eq!(head(tail_tail_l), 2);\n+        tail = tail.tail().unwrap();\n+        assert_eq!(tail.head().unwrap(), &2);\n     }\n \n     #[test]\n     fn test_from_vec_empty() {\n-        let empty : @list::List<int> = from_vec([]);\n-        assert_eq!(empty, @list::Nil::<int>);\n+        let empty : list::List<int> = List::from_vec([]);\n+        assert_eq!(empty, Nil::<int>);\n     }\n \n     #[test]\n-    fn test_foldl() {\n-        fn add(a: &uint, b: &int) -> uint { return *a + (*b as uint); }\n-        let l = from_vec([0, 1, 2, 3, 4]);\n-        let empty = @list::Nil::<int>;\n-        assert_eq!(list::foldl(0u, l, add), 10u);\n-        assert_eq!(list::foldl(0u, empty, add), 0u);\n-    }\n+    fn test_fold() {\n+        fn add_(a: uint, b: &uint) -> uint { a + *b }\n+        fn subtract_(a: uint, b: &uint) -> uint { a - *b }\n \n-    #[test]\n-    fn test_foldl2() {\n-        fn sub(a: &int, b: &int) -> int {\n-            *a - *b\n-        }\n-        let l = from_vec([1, 2, 3, 4]);\n-        assert_eq!(list::foldl(0, l, sub), -10);\n+        let empty = Nil::<uint>;\n+        assert_eq!(empty.iter().fold(0u, add_), 0u);\n+        assert_eq!(empty.iter().fold(10u, subtract_), 10u);\n+\n+        let list = List::from_vec([0u, 1u, 2u, 3u, 4u]);\n+        assert_eq!(list.iter().fold(0u, add_), 10u);\n+        assert_eq!(list.iter().fold(10u, subtract_), 0u);\n     }\n \n     #[test]\n     fn test_find_success() {\n-        fn match_(i: &int) -> bool { return *i == 2; }\n-        let l = from_vec([0, 1, 2]);\n-        assert_eq!(list::find(l, match_), option::Some(2));\n+        fn match_(i: & &int) -> bool { **i == 2 }\n+\n+        let list = List::from_vec([0, 1, 2]);\n+        assert_eq!(list.iter().find(match_).unwrap(), &2);\n     }\n \n     #[test]\n     fn test_find_fail() {\n-        fn match_(_i: &int) -> bool { return false; }\n-        let l = from_vec([0, 1, 2]);\n-        let empty = @list::Nil::<int>;\n-        assert_eq!(list::find(l, match_), option::None::<int>);\n-        assert_eq!(list::find(empty, match_), option::None::<int>);\n+        fn match_(_i: & &int) -> bool { false }\n+\n+        let empty = Nil::<int>;\n+        assert_eq!(empty.iter().find(match_), None);\n+\n+        let list = List::from_vec([0, 1, 2]);\n+        assert_eq!(list.iter().find(match_), None);\n     }\n \n     #[test]\n     fn test_any() {\n-        fn match_(i: &int) -> bool { return *i == 2; }\n-        let l = from_vec([0, 1, 2]);\n-        let empty = @list::Nil::<int>;\n-        assert_eq!(list::any(l, match_), true);\n-        assert_eq!(list::any(empty, match_), false);\n+        fn match_(i: &int) -> bool { *i == 2 }\n+\n+        let empty = Nil::<int>;\n+        assert_eq!(empty.iter().any(match_), false);\n+\n+        let list = List::from_vec([0, 1, 2]);\n+        assert_eq!(list.iter().any(match_), true);\n     }\n \n     #[test]\n-    fn test_has() {\n-        let l = from_vec([5, 8, 6]);\n-        let empty = @list::Nil::<int>;\n-        assert!((list::has(l, 5)));\n-        assert!((!list::has(l, 7)));\n-        assert!((list::has(l, 8)));\n-        assert!((!list::has(empty, 5)));\n+    fn test_contains() {\n+        let empty = Nil::<int>;\n+        assert!((!empty.contains(5)));\n+\n+        let list = List::from_vec([5, 8, 6]);\n+        assert!((list.contains(5)));\n+        assert!((!list.contains(7)));\n+        assert!((list.contains(8)));\n     }\n \n     #[test]\n     fn test_len() {\n-        let l = from_vec([0, 1, 2]);\n-        let empty = @list::Nil::<int>;\n-        assert_eq!(list::len(l), 3u);\n-        assert_eq!(list::len(empty), 0u);\n+        let empty = Nil::<int>;\n+        assert_eq!(empty.len(), 0u);\n+\n+        let list = List::from_vec([0, 1, 2]);\n+        assert_eq!(list.len(), 3u);\n     }\n \n     #[test]\n     fn test_append() {\n-        assert!(from_vec([1,2,3,4])\n-            == list::append(list::from_vec([1,2]), list::from_vec([3,4])));\n+        assert_eq!(List::from_vec([1, 2, 3, 4]),\n+                   List::from_vec([1, 2]).append(List::from_vec([3, 4])));\n+    }\n+\n+    #[test]\n+    fn test_unshift() {\n+        let list = List::from_vec([1]);\n+        let new_list = list.unshift(0);\n+        assert_eq!(list.len(), 1u);\n+        assert_eq!(new_list.len(), 2u);\n+        assert_eq!(new_list, List::from_vec([0, 1]));\n     }\n }"}, {"sha": "dda45e839e12af82b89b0e10e1e4e76a05742c3f", "filename": "src/librustc/middle/typeck/mod.rs", "status": "modified", "additions": 9, "deletions": 15, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/f203fc7daf8d598a7eacee1a135f2fd92dc6382e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f203fc7daf8d598a7eacee1a135f2fd92dc6382e/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftypeck%2Fmod.rs?ref=f203fc7daf8d598a7eacee1a135f2fd92dc6382e", "patch": "@@ -73,7 +73,6 @@ use std::cell::RefCell;\n use collections::HashMap;\n use std::rc::Rc;\n use collections::List;\n-use collections::list;\n use syntax::codemap::Span;\n use syntax::print::pprust::*;\n use syntax::{ast, ast_map, abi};\n@@ -311,23 +310,18 @@ pub fn require_same_types(tcx: ty::ctxt,\n // corresponding ty::Region\n pub type isr_alist = @List<(ty::BoundRegion, ty::Region)>;\n \n-trait get_and_find_region {\n-    fn get(&self, br: ty::BoundRegion) -> ty::Region;\n-    fn find(&self, br: ty::BoundRegion) -> Option<ty::Region>;\n+trait get_region<'a, T:'static> {\n+    fn get(&'a self, br: ty::BoundRegion) -> ty::Region;\n }\n \n-impl get_and_find_region for isr_alist {\n-    fn get(&self, br: ty::BoundRegion) -> ty::Region {\n-        self.find(br).unwrap()\n-    }\n-\n-    fn find(&self, br: ty::BoundRegion) -> Option<ty::Region> {\n-        let mut ret = None;\n-        list::each(*self, |isr| {\n+impl<'a, T:'static> get_region <'a, T> for isr_alist {\n+    fn get(&'a self, br: ty::BoundRegion) -> ty::Region {\n+        let mut region = None;\n+        for isr in self.iter() {\n             let (isr_br, isr_r) = *isr;\n-            if isr_br == br { ret = Some(isr_r); false } else { true }\n-        });\n-        ret\n+            if isr_br == br { region = Some(isr_r); break; }\n+        };\n+        region.unwrap()\n     }\n }\n "}, {"sha": "bc28f2f445ee086468603b717f1e425f2ec77ae8", "filename": "src/libstd/cell.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/f203fc7daf8d598a7eacee1a135f2fd92dc6382e/src%2Flibstd%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f203fc7daf8d598a7eacee1a135f2fd92dc6382e/src%2Flibstd%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcell.rs?ref=f203fc7daf8d598a7eacee1a135f2fd92dc6382e", "patch": "@@ -55,6 +55,12 @@ impl<T:Pod> Clone for Cell<T> {\n     }\n }\n \n+impl<T:Eq + Pod> Eq for Cell<T> {\n+    fn eq(&self, other: &Cell<T>) -> bool {\n+        self.get() == other.get()\n+    }\n+}\n+\n /// A mutable memory location with dynamically checked borrow rules\n pub struct RefCell<T> {\n     priv value: T,\n@@ -273,11 +279,14 @@ mod test {\n     #[test]\n     fn smoketest_cell() {\n         let x = Cell::new(10);\n+        assert_eq!(x, Cell::new(10));\n         assert_eq!(x.get(), 10);\n         x.set(20);\n+        assert_eq!(x, Cell::new(20));\n         assert_eq!(x.get(), 20);\n \n         let y = Cell::new((30, 40));\n+        assert_eq!(y, Cell::new((30, 40)));\n         assert_eq!(y.get(), (30, 40));\n     }\n "}, {"sha": "0129740252ca1293b3f98d4f3e673f29829b8f98", "filename": "src/test/run-pass/log-knows-the-names-of-variants-in-std.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/f203fc7daf8d598a7eacee1a135f2fd92dc6382e/src%2Ftest%2Frun-pass%2Flog-knows-the-names-of-variants-in-std.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f203fc7daf8d598a7eacee1a135f2fd92dc6382e/src%2Ftest%2Frun-pass%2Flog-knows-the-names-of-variants-in-std.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Flog-knows-the-names-of-variants-in-std.rs?ref=f203fc7daf8d598a7eacee1a135f2fd92dc6382e", "patch": "@@ -11,7 +11,7 @@\n // except according to those terms.\n \n extern crate collections;\n-use collections::list;\n+use collections::list::List;\n \n #[deriving(Clone)]\n enum foo {\n@@ -24,8 +24,8 @@ fn check_log<T>(exp: ~str, v: T) {\n }\n \n pub fn main() {\n-    let x = list::from_vec([a(22u), b(~\"hi\")]);\n-    let exp = ~\"@Cons(a(22u), @Cons(b(~\\\"hi\\\"), @Nil))\";\n+    let x = List::from_vec([a(22u), b(~\"hi\")]);\n+    let exp = ~\"Cons(a(22u), @Cons(b(~\\\"hi\\\"), @Nil))\";\n     let act = format!(\"{:?}\", x);\n     assert!(act == exp);\n     check_log(exp, x);"}, {"sha": "66bb2e702bea3bbb71e5596541129eae425fd09f", "filename": "src/test/run-pass/non-boolean-pure-fns.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f203fc7daf8d598a7eacee1a135f2fd92dc6382e/src%2Ftest%2Frun-pass%2Fnon-boolean-pure-fns.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f203fc7daf8d598a7eacee1a135f2fd92dc6382e/src%2Ftest%2Frun-pass%2Fnon-boolean-pure-fns.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fnon-boolean-pure-fns.rs?ref=f203fc7daf8d598a7eacee1a135f2fd92dc6382e", "patch": "@@ -14,19 +14,19 @@\n \n extern crate collections;\n \n-use collections::list::{List, Cons, Nil, head, is_empty};\n+use collections::list::{List, Cons, Nil};\n \n-fn pure_length_go<T:Clone>(ls: @List<T>, acc: uint) -> uint {\n+fn pure_length_go<T>(ls: @List<T>, acc: uint) -> uint {\n     match *ls { Nil => { acc } Cons(_, tl) => { pure_length_go(tl, acc + 1u) } }\n }\n \n-fn pure_length<T:Clone>(ls: @List<T>) -> uint { pure_length_go(ls, 0u) }\n+fn pure_length<T>(ls: @List<T>) -> uint { pure_length_go(ls, 0u) }\n \n-fn nonempty_list<T:Clone>(ls: @List<T>) -> bool { pure_length(ls) > 0u }\n+fn nonempty_list<T>(ls: @List<T>) -> bool { pure_length(ls) > 0u }\n \n fn safe_head<T:Clone>(ls: @List<T>) -> T {\n-    assert!(!is_empty(ls));\n-    return head(ls);\n+    assert!(!ls.is_empty());\n+    return ls.head().unwrap().clone();\n }\n \n pub fn main() {"}]}