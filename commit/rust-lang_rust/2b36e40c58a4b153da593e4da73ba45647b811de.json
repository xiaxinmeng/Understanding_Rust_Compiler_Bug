{"sha": "2b36e40c58a4b153da593e4da73ba45647b811de", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJiMzZlNDBjNThhNGIxNTNkYTU5M2U0ZGE3M2JhNDU2NDdiODExZGU=", "commit": {"author": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-05-12T08:51:13Z"}, "committer": {"name": "Marijn Haverbeke", "email": "marijnh@gmail.com", "date": "2011-05-12T08:51:13Z"}, "message": "Ensure ann tags are actually kept around during typechecking\n\nThis way, the tag assigned by the parser stays with the node.\nI realize ann replacing is probably going away real soon, but\nI needed this now for moving the resolve defs out of the AST.", "tree": {"sha": "c2cad9d5166622366057eb7c59b3e9dc0221e717", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c2cad9d5166622366057eb7c59b3e9dc0221e717"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2b36e40c58a4b153da593e4da73ba45647b811de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2b36e40c58a4b153da593e4da73ba45647b811de", "html_url": "https://github.com/rust-lang/rust/commit/2b36e40c58a4b153da593e4da73ba45647b811de", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2b36e40c58a4b153da593e4da73ba45647b811de/comments", "author": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marijnh", "id": 144427, "node_id": "MDQ6VXNlcjE0NDQyNw==", "avatar_url": "https://avatars.githubusercontent.com/u/144427?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marijnh", "html_url": "https://github.com/marijnh", "followers_url": "https://api.github.com/users/marijnh/followers", "following_url": "https://api.github.com/users/marijnh/following{/other_user}", "gists_url": "https://api.github.com/users/marijnh/gists{/gist_id}", "starred_url": "https://api.github.com/users/marijnh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marijnh/subscriptions", "organizations_url": "https://api.github.com/users/marijnh/orgs", "repos_url": "https://api.github.com/users/marijnh/repos", "events_url": "https://api.github.com/users/marijnh/events{/privacy}", "received_events_url": "https://api.github.com/users/marijnh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "079512494f403657fc6ad26be71e4dec6b9ebaae", "url": "https://api.github.com/repos/rust-lang/rust/commits/079512494f403657fc6ad26be71e4dec6b9ebaae", "html_url": "https://github.com/rust-lang/rust/commit/079512494f403657fc6ad26be71e4dec6b9ebaae"}], "stats": {"total": 426, "additions": 224, "deletions": 202}, "files": [{"sha": "af3ded1955054167474a0093ba4fe2f6026ab286", "filename": "src/comp/front/ast.rs", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/2b36e40c58a4b153da593e4da73ba45647b811de/src%2Fcomp%2Ffront%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b36e40c58a4b153da593e4da73ba45647b811de/src%2Fcomp%2Ffront%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Ffront%2Fast.rs?ref=2b36e40c58a4b153da593e4da73ba45647b811de", "patch": "@@ -24,11 +24,19 @@ type ty_param = ident;\n // Annotations added during successive passes.\n tag ann {\n     ann_none(uint);\n-    ann_type(middle.ty.t,\n+    ann_type(uint,\n+             middle.ty.t,\n              Option.t[vec[middle.ty.t]], /* ty param substs */\n              Option.t[@ts_ann]); /* pre- and postcondition for typestate */\n }\n \n+fn ann_tag(&ann a) -> uint {\n+    ret alt (a) {\n+        case (ann_none(?t)) { t }\n+        case (ann_type(?t, _, _, _)) { t }\n+    };\n+}\n+\n tag def {\n     def_fn(def_id);\n     def_obj(def_id);"}, {"sha": "02383f76cb4e41252a6d803c9ca92707a1595378", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/2b36e40c58a4b153da593e4da73ba45647b811de/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b36e40c58a4b153da593e4da73ba45647b811de/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=2b36e40c58a4b153da593e4da73ba45647b811de", "patch": "@@ -3127,7 +3127,7 @@ fn node_ann_ty_params(&ast.ann a) -> vec[ty.t] {\n             log_err \"missing type annotation\";\n             fail;\n         }\n-        case (ast.ann_type(_, ?tps_opt, _)) {\n+        case (ast.ann_type(_, _, ?tps_opt, _)) {\n             alt (tps_opt) {\n                 case (none[vec[ty.t]]) {\n                     log_err \"type annotation has no ty params\";\n@@ -4148,7 +4148,7 @@ fn lval_generic_fn(&@block_ctxt cx,\n             cx.fcx.lcx.ccx.sess.bug(\"no type annotation for path!\");\n             fail;\n         }\n-        case (ast.ann_type(?monoty_, ?tps, _)) {\n+        case (ast.ann_type(_, ?monoty_, ?tps, _)) {\n             monoty = monoty_;\n             tys = Option.get[vec[ty.t]](tps);\n         }"}, {"sha": "eb37b44438e7b05bdb21442ebc4050b10b837630", "filename": "src/comp/middle/ty.rs", "status": "modified", "additions": 25, "deletions": 22, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/2b36e40c58a4b153da593e4da73ba45647b811de/src%2Fcomp%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b36e40c58a4b153da593e4da73ba45647b811de/src%2Fcomp%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Fty.rs?ref=2b36e40c58a4b153da593e4da73ba45647b811de", "patch": "@@ -1433,7 +1433,7 @@ fn ann_to_type(&ast.ann ann) -> t {\n             log_err \"ann_to_type() called on node with no type\";\n             fail;\n         }\n-        case (ast.ann_type(?ty, _, _)) {\n+        case (ast.ann_type(_, ?ty, _, _)) {\n             ret ty;\n         }\n     }\n@@ -1445,7 +1445,7 @@ fn ann_to_type_params(&ast.ann ann) -> vec[t] {\n             log_err \"ann_to_type_params() called on node with no type params\";\n             fail;\n         }\n-        case (ast.ann_type(_, ?tps, _)) {\n+        case (ast.ann_type(_, _, ?tps, _)) {\n             alt (tps) {\n                 case (none[vec[t]]) {\n                     let vec[t] result = vec();\n@@ -1467,7 +1467,7 @@ fn ann_to_monotype(ctxt cx, ast.ann a) -> t {\n             log_err \"ann_to_monotype() called on expression with no type!\";\n             fail;\n         }\n-        case (ast.ann_type(?typ, ?tps_opt, _)) {\n+        case (ast.ann_type(_, ?typ, ?tps_opt, _)) {\n             alt (tps_opt) {\n                 case (none[vec[t]]) { ret typ; }\n                 case (some[vec[t]](?tps)) {\n@@ -1479,8 +1479,8 @@ fn ann_to_monotype(ctxt cx, ast.ann a) -> t {\n }\n \n // Turns a type into an ann_type, using defaults for other fields.\n-fn triv_ann(t typ) -> ast.ann {\n-    ret ast.ann_type(typ, none[vec[t]], none[@ts_ann]);\n+fn triv_ann(&ast.ann old, t typ) -> ast.ann {\n+    ret ast.ann_type(ast.ann_tag(old), typ, none[vec[t]], none[@ts_ann]);\n }\n \n // Returns the number of distinct type parameters in the given type.\n@@ -1778,7 +1778,7 @@ fn expr_has_ty_params(&@ast.expr expr) -> bool {\n     // FIXME: Rewrite using complex patterns when they're trustworthy.\n     alt (expr_ann(expr)) {\n         case (ast.ann_none(_)) { fail; }\n-        case (ast.ann_type(_, ?tps_opt, _)) {\n+        case (ast.ann_type(_, _, ?tps_opt, _)) {\n             ret !Option.is_none[vec[t]](tps_opt);\n         }\n     }\n@@ -1794,28 +1794,31 @@ fn replace_expr_type(&@ast.expr expr,\n         new_tps = none[vec[t]];\n     }\n \n-    auto ann = ast.ann_type(new_tyt._1, new_tps, none[@ts_ann]);\n+    fn mkann_fn(t tyt, Option.t[vec[t]] tps, &ast.ann old_ann) -> ast.ann {\n+        ret ast.ann_type(ast.ann_tag(old_ann), tyt, tps, none[@ts_ann]);\n+    }\n+    auto mkann = bind mkann_fn(new_tyt._1, new_tps, _);\n \n     alt (expr.node) {\n-        case (ast.expr_call(?callee, ?args, _)) {\n-            ret @fold.respan[ast.expr_](expr.span,\n-                                        ast.expr_call(callee, args, ann));\n+        case (ast.expr_call(?callee, ?args, ?a)) {\n+            ret @fold.respan(expr.span,\n+                             ast.expr_call(callee, args, mkann(a)));\n         }\n-        case (ast.expr_self_method(?ident, _)) {\n-            ret @fold.respan[ast.expr_](expr.span,\n-                                        ast.expr_self_method(ident, ann));\n+        case (ast.expr_self_method(?ident, ?a)) {\n+            ret @fold.respan(expr.span,\n+                             ast.expr_self_method(ident, mkann(a)));\n         }\n-        case (ast.expr_bind(?callee, ?args, _)) {\n-            ret @fold.respan[ast.expr_](expr.span,\n-                                        ast.expr_bind(callee, args, ann));\n+        case (ast.expr_bind(?callee, ?args, ?a)) {\n+            ret @fold.respan(expr.span,\n+                             ast.expr_bind(callee, args, mkann(a)));\n         }\n-        case (ast.expr_field(?e, ?i, _)) {\n-            ret @fold.respan[ast.expr_](expr.span,\n-                                        ast.expr_field(e, i, ann));\n+        case (ast.expr_field(?e, ?i, ?a)) {\n+            ret @fold.respan(expr.span,\n+                             ast.expr_field(e, i, mkann(a)));\n         }\n-        case (ast.expr_path(?p, ?dopt, _)) {\n-            ret @fold.respan[ast.expr_](expr.span,\n-                                        ast.expr_path(p, dopt, ann));\n+        case (ast.expr_path(?p, ?dopt, ?a)) {\n+            ret @fold.respan(expr.span,\n+                             ast.expr_path(p, dopt, mkann(a)));\n         }\n         case (_) {\n             log_err \"unhandled expr type in replace_expr_type(): \" +"}, {"sha": "af6dc0242494e45baa39f4cc78c03051f721733c", "filename": "src/comp/middle/typeck.rs", "status": "modified", "additions": 165, "deletions": 155, "changes": 320, "blob_url": "https://github.com/rust-lang/rust/blob/2b36e40c58a4b153da593e4da73ba45647b811de/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b36e40c58a4b153da593e4da73ba45647b811de/src%2Fcomp%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypeck.rs?ref=2b36e40c58a4b153da593e4da73ba45647b811de", "patch": "@@ -178,7 +178,7 @@ fn ty_param_count_and_ty_for_def(&@fn_ctxt fcx, &ast.span sp, &ast.def defn)\n // Instantiates the given path, which must refer to an item with the given\n // number of type parameters and type.\n fn instantiate_path(&@fn_ctxt fcx, &ast.path pth, &ty_param_count_and_ty tpt,\n-                    &span sp) -> ast.ann {\n+                    &span sp, uint ann_tag) -> ast.ann {\n     auto ty_param_count = tpt._0;\n     auto t = bind_params_in_type(fcx.ccx.tcx, tpt._1);\n \n@@ -209,7 +209,7 @@ fn instantiate_path(&@fn_ctxt fcx, &ast.path pth, &ty_param_count_and_ty tpt,\n         ty_substs_opt = some[vec[ty.t]](ty_substs);\n     }\n \n-    ret ast.ann_type(t, ty_substs_opt, none[@ts_ann]);\n+    ret ast.ann_type(ann_tag, t, ty_substs_opt, none[@ts_ann]);\n }\n \n fn ast_mode_to_mode(ast.mode mode) -> ty.mode {\n@@ -622,8 +622,8 @@ mod Collect {\n \n             auto tpt = tup(ty_param_count, result_ty);\n             cx.type_cache.insert(variant.node.id, tpt);\n-            auto variant_t = rec(ann=triv_ann(result_ty)\n-                with variant.node\n+            auto variant_t = rec(ann=triv_ann(variant.node.ann, result_ty)\n+                                 with variant.node\n             );\n             result += vec(fold.respan[ast.variant_](variant.span, variant_t));\n         }\n@@ -692,7 +692,7 @@ mod Collect {\n                        &ast.def_id id, &ast.ann a) -> @ast.item {\n         // assert (e.cx.type_cache.contains_key(id));\n         auto typ = e.cx.type_cache.get(id)._1;\n-        auto item = ast.item_const(i, t, ex, id, triv_ann(typ));\n+        auto item = ast.item_const(i, t, ex, id, triv_ann(a, typ));\n         ret @fold.respan[ast.item_](sp, item);\n     }\n \n@@ -701,7 +701,7 @@ mod Collect {\n                     &ast.def_id id, &ast.ann a) -> @ast.item {\n         // assert (e.cx.type_cache.contains_key(id));\n         auto typ = e.cx.type_cache.get(id)._1;\n-        auto item = ast.item_fn(i, f, ty_params, id, triv_ann(typ));\n+        auto item = ast.item_fn(i, f, ty_params, id, triv_ann(a, typ));\n         ret @fold.respan[ast.item_](sp, item);\n     }\n \n@@ -711,7 +711,7 @@ mod Collect {\n         // assert (e.cx.type_cache.contains_key(id));\n         auto typ = e.cx.type_cache.get(id)._1;\n         auto item = ast.native_item_fn(i, ln, d, ty_params, id,\n-                                       triv_ann(typ));\n+                                       triv_ann(a, typ));\n         ret @fold.respan[ast.native_item_](sp, item);\n     }\n \n@@ -756,17 +756,17 @@ mod Collect {\n                                      meth_ty.proto,\n                                      meth_ty.inputs,\n                                      meth_ty.output);\n-            m_ = rec(ann=triv_ann(meth_tfn)\n-                with meth.node\n+            m_ = rec(ann=triv_ann(meth.node.ann, meth_tfn)\n+                     with meth.node\n             );\n             m = @rec(node=m_ with *meth);\n             Vec.push[@ast.method](methods, m);\n         }\n         auto g = bind getter(e.cx, _);\n         for (ast.obj_field fld in ob.fields) {\n             let ty.t fty = ast_ty_to_ty(e.cx.tcx, g, fld.ty);\n-            let ast.obj_field f = rec(ann=triv_ann(fty)\n-                with fld\n+            let ast.obj_field f = rec(ann=triv_ann(fld.ann, fty)\n+                                      with fld\n             );\n             Vec.push[ast.obj_field](fields, f);\n         }\n@@ -778,7 +778,7 @@ mod Collect {\n                 let ty.t output = ty.mk_nil(e.cx.tcx);\n                 auto dtor_tfn = ty.mk_fn(e.cx.tcx, ast.proto_fn, inputs,\n                                          output);\n-                auto d_ = rec(ann=triv_ann(dtor_tfn) with d.node);\n+                auto d_ = rec(ann=triv_ann(d.node.ann, dtor_tfn) with d.node);\n                 dtor = some[@ast.method](@rec(node=d_ with *d));\n             }\n             case (none[@ast.method]) { }\n@@ -788,7 +788,7 @@ mod Collect {\n                        fields = fields,\n                        dtor = dtor\n                        with ob);\n-        auto item = ast.item_obj(i, ob_, ty_params, odid, triv_ann(t));\n+        auto item = ast.item_obj(i, ob_, ty_params, odid, triv_ann(a, t));\n         ret @fold.respan[ast.item_](sp, item);\n     }\n \n@@ -797,7 +797,7 @@ mod Collect {\n                     &ast.def_id id, &ast.ann a) -> @ast.item {\n         // assert (e.cx.type_cache.contains_key(id));\n         auto typ = e.cx.type_cache.get(id)._1;\n-        auto item = ast.item_ty(i, t, ty_params, id, triv_ann(typ));\n+        auto item = ast.item_ty(i, t, ty_params, id, triv_ann(a, typ));\n         ret @fold.respan[ast.item_](sp, item);\n     }\n \n@@ -809,7 +809,8 @@ mod Collect {\n                                                 ty_params);\n         auto typ = e.cx.type_cache.get(id)._1;\n         auto item = ast.item_tag(i, variants_t, ty_params, id,\n-                                 ast.ann_type(typ, none[vec[ty.t]],\n+                                 ast.ann_type(ast.ann_tag(a), typ,\n+                                              none[vec[ty.t]],\n                                               none[@ts_ann]));\n         ret @fold.respan[ast.item_](sp, item);\n     }\n@@ -1117,20 +1118,22 @@ mod Pushdown {\n             case (ast.pat_wild(?ann)) {\n                 auto t = Demand.simple(fcx, pat.span, expected,\n                                        ann_to_type(ann));\n-                p_1 = ast.pat_wild(ast.ann_type(t, none[vec[ty.t]],\n+                p_1 = ast.pat_wild(ast.ann_type(ast.ann_tag(ann), t,\n+                                                none[vec[ty.t]],\n                                                 none[@ts_ann]));\n             }\n             case (ast.pat_lit(?lit, ?ann)) {\n                 auto t = Demand.simple(fcx, pat.span, expected,\n                                        ann_to_type(ann));\n-                p_1 = ast.pat_lit(lit, ast.ann_type(t, none[vec[ty.t]],\n+                p_1 = ast.pat_lit(lit, ast.ann_type(ast.ann_tag(ann), t,\n+                                                    none[vec[ty.t]],\n                                                     none[@ts_ann]));\n             }\n             case (ast.pat_bind(?id, ?did, ?ann)) {\n                 auto t = Demand.simple(fcx, pat.span, expected,\n                                        ann_to_type(ann));\n                 fcx.locals.insert(did, t);\n-                p_1 = ast.pat_bind(id, did, ast.ann_type(t,\n+                p_1 = ast.pat_bind(id, did, ast.ann_type(ast.ann_tag(ann), t,\n                                                          none[vec[ty.t]],\n                                                          none[@ts_ann]));\n             }\n@@ -1199,7 +1202,7 @@ mod Pushdown {\n                         fail;\n                     }\n                 }\n-                e_1 = ast.expr_vec(es_1, mut, triv_ann(t));\n+                e_1 = ast.expr_vec(es_1, mut, triv_ann(ann, t));\n             }\n             case (ast.expr_tup(?es_0, ?ann)) {\n                 auto t = Demand.simple(fcx, e.span, expected,\n@@ -1220,7 +1223,7 @@ mod Pushdown {\n                         fail;\n                     }\n                 }\n-                e_1 = ast.expr_tup(elts_1, triv_ann(t));\n+                e_1 = ast.expr_tup(elts_1, triv_ann(ann, t));\n             }\n             case (ast.expr_rec(?fields_0, ?base_0, ?ann)) {\n \n@@ -1277,12 +1280,12 @@ mod Pushdown {\n                         fail;\n                     }\n                 }\n-                e_1 = ast.expr_rec(fields_1, base_1, triv_ann(t));\n+                e_1 = ast.expr_rec(fields_1, base_1, triv_ann(ann, t));\n             }\n             case (ast.expr_bind(?sube, ?es, ?ann)) {\n                 auto t = Demand.simple(fcx, e.span, expected,\n                                        ann_to_type(ann));\n-                e_1 = ast.expr_bind(sube, es, triv_ann(t));\n+                e_1 = ast.expr_bind(sube, es, triv_ann(ann, t));\n             }\n             case (ast.expr_call(?sube, ?es, ?ann)) {\n                 // NB: we call 'Demand.autoderef' and pass in adk only in\n@@ -1291,34 +1294,34 @@ mod Pushdown {\n                 // so there's no need.\n                 auto t = Demand.autoderef(fcx, e.span, expected,\n                                           ann_to_type(ann), adk);\n-                e_1 = ast.expr_call(sube, es, triv_ann(t));\n+                e_1 = ast.expr_call(sube, es, triv_ann(ann, t));\n             }\n             case (ast.expr_self_method(?id, ?ann)) {\n                 auto t = Demand.simple(fcx, e.span, expected,\n                                        ann_to_type(ann));\n-                e_1 = ast.expr_self_method(id, triv_ann(t));\n+                e_1 = ast.expr_self_method(id, triv_ann(ann, t));\n             }\n             case (ast.expr_binary(?bop, ?lhs, ?rhs, ?ann)) {\n                 auto t = Demand.simple(fcx, e.span, expected,\n                                        ann_to_type(ann));\n-                e_1 = ast.expr_binary(bop, lhs, rhs, triv_ann(t));\n+                e_1 = ast.expr_binary(bop, lhs, rhs, triv_ann(ann, t));\n             }\n             case (ast.expr_unary(?uop, ?sube, ?ann)) {\n                 // See note in expr_unary for why we're calling\n                 // Demand.autoderef.\n                 auto t = Demand.autoderef(fcx, e.span, expected,\n                                           ann_to_type(ann), adk);\n-                e_1 = ast.expr_unary(uop, sube, triv_ann(t));\n+                e_1 = ast.expr_unary(uop, sube, triv_ann(ann, t));\n             }\n             case (ast.expr_lit(?lit, ?ann)) {\n                 auto t = Demand.simple(fcx, e.span, expected,\n                                        ann_to_type(ann));\n-                e_1 = ast.expr_lit(lit, triv_ann(t));\n+                e_1 = ast.expr_lit(lit, triv_ann(ann, t));\n             }\n             case (ast.expr_cast(?sube, ?ast_ty, ?ann)) {\n                 auto t = Demand.simple(fcx, e.span, expected,\n                                        ann_to_type(ann));\n-                e_1 = ast.expr_cast(sube, ast_ty, triv_ann(t));\n+                e_1 = ast.expr_cast(sube, ast_ty, triv_ann(ann, t));\n             }\n             case (ast.expr_if(?cond, ?then_0, ?else_0, ?ann)) {\n                 auto t = Demand.autoderef(fcx, e.span, expected,\n@@ -1333,56 +1336,56 @@ mod Pushdown {\n                         else_1 = some[@ast.expr](e_1);\n                     }\n                 }\n-                e_1 = ast.expr_if(cond, then_1, else_1, triv_ann(t));\n+                e_1 = ast.expr_if(cond, then_1, else_1, triv_ann(ann, t));\n             }\n             case (ast.expr_for(?decl, ?seq, ?bloc, ?ann)) {\n                 auto t = Demand.simple(fcx, e.span, expected,\n                                        ann_to_type(ann));\n-                e_1 = ast.expr_for(decl, seq, bloc, triv_ann(t));\n+                e_1 = ast.expr_for(decl, seq, bloc, triv_ann(ann, t));\n             }\n             case (ast.expr_for_each(?decl, ?seq, ?bloc, ?ann)) {\n                 auto t = Demand.simple(fcx, e.span, expected,\n                                        ann_to_type(ann));\n-                e_1 = ast.expr_for_each(decl, seq, bloc, triv_ann(t));\n+                e_1 = ast.expr_for_each(decl, seq, bloc, triv_ann(ann, t));\n             }\n             case (ast.expr_while(?cond, ?bloc, ?ann)) {\n                 auto t = Demand.simple(fcx, e.span, expected,\n                                        ann_to_type(ann));\n-                e_1 = ast.expr_while(cond, bloc, triv_ann(t));\n+                e_1 = ast.expr_while(cond, bloc, triv_ann(ann, t));\n             }\n             case (ast.expr_do_while(?bloc, ?cond, ?ann)) {\n                 auto t = Demand.simple(fcx, e.span, expected,\n                                        ann_to_type(ann));\n-                e_1 = ast.expr_do_while(bloc, cond, triv_ann(t));\n+                e_1 = ast.expr_do_while(bloc, cond, triv_ann(ann, t));\n             }\n             case (ast.expr_block(?bloc, ?ann)) {\n                 auto t = Demand.autoderef(fcx, e.span, expected,\n                                           ann_to_type(ann), adk);\n-                e_1 = ast.expr_block(bloc, triv_ann(t));\n+                e_1 = ast.expr_block(bloc, triv_ann(ann, t));\n             }\n             case (ast.expr_assign(?lhs_0, ?rhs_0, ?ann)) {\n                 auto t = Demand.autoderef(fcx, e.span, expected,\n                                           ann_to_type(ann), adk);\n                 auto lhs_1 = pushdown_expr(fcx, expected, lhs_0);\n                 auto rhs_1 = pushdown_expr(fcx, expected, rhs_0);\n-                e_1 = ast.expr_assign(lhs_1, rhs_1, triv_ann(t));\n+                e_1 = ast.expr_assign(lhs_1, rhs_1, triv_ann(ann, t));\n             }\n             case (ast.expr_assign_op(?op, ?lhs_0, ?rhs_0, ?ann)) {\n                 auto t = Demand.autoderef(fcx, e.span, expected,\n                                           ann_to_type(ann), adk);\n                 auto lhs_1 = pushdown_expr(fcx, expected, lhs_0);\n                 auto rhs_1 = pushdown_expr(fcx, expected, rhs_0);\n-                e_1 = ast.expr_assign_op(op, lhs_1, rhs_1, triv_ann(t));\n+                e_1 = ast.expr_assign_op(op, lhs_1, rhs_1, triv_ann(ann, t));\n             }\n             case (ast.expr_field(?lhs, ?rhs, ?ann)) {\n                 auto t = Demand.autoderef(fcx, e.span, expected,\n                                           ann_to_type(ann), adk);\n-                e_1 = ast.expr_field(lhs, rhs, triv_ann(t));\n+                e_1 = ast.expr_field(lhs, rhs, triv_ann(ann, t));\n             }\n             case (ast.expr_index(?base, ?index, ?ann)) {\n                 auto t = Demand.autoderef(fcx, e.span, expected,\n                                           ann_to_type(ann), adk);\n-                e_1 = ast.expr_index(base, index, triv_ann(t));\n+                e_1 = ast.expr_index(base, index, triv_ann(ann, t));\n             }\n             case (ast.expr_path(?pth, ?d, ?ann)) {\n                 auto tp_substs_0 = ty.ann_to_type_params(ann);\n@@ -1401,7 +1404,7 @@ mod Pushdown {\n                             \"path expr; did you pass it to check_expr()?\";\n                         fail;\n                     }\n-                    case (ast.ann_type(_, ?tps_opt, _)) {\n+                    case (ast.ann_type(_, _, ?tps_opt, _)) {\n                         alt (tps_opt) {\n                             case (none[vec[ty.t]]) {\n                                 ty_params_opt = none[vec[ty.t]];\n@@ -1414,13 +1417,14 @@ mod Pushdown {\n                 }\n \n                 e_1 = ast.expr_path(pth, d,\n-                                    ast.ann_type(t, ty_params_opt,\n+                                    ast.ann_type(ast.ann_tag(ann), t,\n+                                                 ty_params_opt,\n                                                  none[@ts_ann]));\n             }\n             case (ast.expr_ext(?p, ?args, ?body, ?expanded, ?ann)) {\n                 auto t = Demand.autoderef(fcx, e.span, expected,\n                                           ann_to_type(ann), adk);\n-                e_1 = ast.expr_ext(p, args, body, expanded, triv_ann(t));\n+                e_1 = ast.expr_ext(p, args, body, expanded, triv_ann(ann, t));\n             }\n             /* FIXME: should this check the type annotations? */\n             case (ast.expr_fail(_))  { e_1 = e.node; } \n@@ -1436,7 +1440,7 @@ mod Pushdown {\n             case (ast.expr_port(?ann)) {\n                 auto t = Demand.simple(fcx, e.span, expected,\n                                        ann_to_type(ann));\n-                e_1 = ast.expr_port(triv_ann(t));\n+                e_1 = ast.expr_port(triv_ann(ann, t));\n             }\n \n             case (ast.expr_chan(?es, ?ann)) {\n@@ -1453,7 +1457,7 @@ mod Pushdown {\n                         fail;\n                     }\n                 }\n-                e_1 = ast.expr_chan(es_1, triv_ann(t));\n+                e_1 = ast.expr_chan(es_1, triv_ann(ann, t));\n             }\n \n             case (ast.expr_alt(?discrim, ?arms_0, ?ann)) {\n@@ -1466,7 +1470,7 @@ mod Pushdown {\n                     auto arm_1 = rec(pat=arm_0.pat, block=block_1);\n                     arms_1 += vec(arm_1);\n                 }\n-                e_1 = ast.expr_alt(discrim, arms_1, triv_ann(t));\n+                e_1 = ast.expr_alt(discrim, arms_1, triv_ann(ann, t));\n             }\n \n             case (ast.expr_recv(?lval_0, ?expr_0, ?ann)) {\n@@ -1506,14 +1510,16 @@ mod Pushdown {\n                 auto e_1 = pushdown_expr(fcx, expected, e_0);\n                 auto block_ = rec(stmts=bloc.node.stmts,\n                                   expr=some[@ast.expr](e_1),\n-                                  a=plain_ann(fcx.ccx.tcx));\n+                                  a=plain_ann(bloc.node.a, fcx.ccx.tcx));\n                 ret fold.respan[ast.block_](bloc.span, block_);\n             }\n             case (none[@ast.expr]) {\n                 Demand.simple(fcx, bloc.span, expected,\n                               ty.mk_nil(fcx.ccx.tcx));\n-                ret fold.respan[ast.block_](bloc.span,\n-                      rec(a = plain_ann(fcx.ccx.tcx) with bloc.node));\n+                ret fold.respan(bloc.span,\n+                                rec(a = plain_ann(bloc.node.a, fcx.ccx.tcx)\n+                                    with bloc.node));\n+                                            \n             }\n         }\n     }\n@@ -1539,8 +1545,8 @@ fn writeback_local(&Option.t[@fn_ctxt] env, &span sp, &@ast.local local)\n         }\n     }\n \n-    auto local_wb = @rec(ann=triv_ann(local_ty)\n-        with *local\n+    auto local_wb = @rec(ann=triv_ann(local.ann, local_ty)\n+                         with *local\n     );\n     ret @fold.respan[ast.decl_](sp, ast.decl_local(local_wb));\n }\n@@ -1560,14 +1566,14 @@ fn resolve_local_types_in_annotation(&Option.t[@fn_ctxt] env, &ast.ann ann)\n             log \"warning: no type for expression\";\n             ret ann;\n         }\n-        case (ast.ann_type(?typ, ?tps, ?ts_info)) {\n+        case (ast.ann_type(?tg, ?typ, ?tps, ?ts_info)) {\n             auto tt = ann_to_type(ann);\n             if (!ty.type_contains_locals(fcx.ccx.tcx, tt)) {\n                 ret ann;\n             }\n             auto f = bind resolver(fcx, _);\n             auto new_type = ty.fold_ty(fcx.ccx.tcx, f, ann_to_type(ann));\n-            ret ast.ann_type(new_type, tps, ts_info);\n+            ret ast.ann_type(tg, new_type, tps, ts_info);\n         }\n     }\n }\n@@ -1618,17 +1624,17 @@ fn check_lit(@crate_ctxt ccx, &@ast.lit lit) -> ty.t {\n fn check_pat(&@fn_ctxt fcx, &@ast.pat pat) -> @ast.pat {\n     auto new_pat;\n     alt (pat.node) {\n-        case (ast.pat_wild(_)) {\n-            new_pat = ast.pat_wild(triv_ann(next_ty_var(fcx.ccx)));\n+        case (ast.pat_wild(?ann)) {\n+            new_pat = ast.pat_wild(triv_ann(ann, next_ty_var(fcx.ccx)));\n         }\n-        case (ast.pat_lit(?lt, _)) {\n-            new_pat = ast.pat_lit(lt, triv_ann(check_lit(fcx.ccx, lt)));\n+        case (ast.pat_lit(?lt, ?ann)) {\n+            new_pat = ast.pat_lit(lt, triv_ann(ann, check_lit(fcx.ccx, lt)));\n         }\n-        case (ast.pat_bind(?id, ?def_id, _)) {\n-            auto ann = triv_ann(next_ty_var(fcx.ccx));\n+        case (ast.pat_bind(?id, ?def_id, ?a)) {\n+            auto ann = triv_ann(a, next_ty_var(fcx.ccx));\n             new_pat = ast.pat_bind(id, def_id, ann);\n         }\n-        case (ast.pat_tag(?p, ?subpats, ?vdef_opt, _)) {\n+        case (ast.pat_tag(?p, ?subpats, ?vdef_opt, ?old_ann)) {\n             auto vdef = Option.get[ast.variant_def](vdef_opt);\n             auto t = ty.lookup_item_type(fcx.ccx.sess, fcx.ccx.tcx,\n                                          fcx.ccx.type_cache, vdef._1)._1;\n@@ -1637,7 +1643,8 @@ fn check_pat(&@fn_ctxt fcx, &@ast.pat pat) -> @ast.pat {\n \n             auto tpt = ty.lookup_item_type(fcx.ccx.sess, fcx.ccx.tcx,\n                                            fcx.ccx.type_cache, vdef._0);\n-            auto ann = instantiate_path(fcx, p, tpt, pat.span);\n+            auto ann = instantiate_path(fcx, p, tpt, pat.span,\n+                                        ast.ann_tag(old_ann));\n \n             alt (struct(fcx.ccx.tcx, t)) {\n                 // N-ary variants have function types.\n@@ -1805,7 +1812,8 @@ fn check_expr(&@fn_ctxt fcx, &@ast.expr expr) -> @ast.expr {\n     }\n \n     // A generic function for checking assignment expressions\n-    fn check_assignment(&@fn_ctxt fcx, &@ast.expr lhs, &@ast.expr rhs)\n+    fn check_assignment(&@fn_ctxt fcx, &@ast.expr lhs, &@ast.expr rhs,\n+                        &ast.ann a)\n         -> tup(@ast.expr, @ast.expr, ast.ann) {\n         auto lhs_0 = check_expr(fcx, lhs);\n         auto rhs_0 = check_expr(fcx, rhs);\n@@ -1816,7 +1824,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast.expr expr) -> @ast.expr {\n         auto rhs_1 = Pushdown.pushdown_expr(fcx, expr_ty(fcx.ccx.tcx, lhs_1),\n                                             rhs_0);\n \n-        auto ann = triv_ann(expr_ty(fcx.ccx.tcx, rhs_1));\n+        auto ann = triv_ann(a, expr_ty(fcx.ccx.tcx, rhs_1));\n         ret tup(lhs_1, rhs_1, ann);\n     }\n \n@@ -1842,14 +1850,14 @@ fn check_expr(&@fn_ctxt fcx, &@ast.expr expr) -> @ast.expr {\n     }\n \n     alt (expr.node) {\n-        case (ast.expr_lit(?lit, _)) {\n+        case (ast.expr_lit(?lit, ?a)) {\n             auto typ = check_lit(fcx.ccx, lit);\n-            auto ann = triv_ann(typ);\n+            auto ann = triv_ann(a, typ);\n             ret @fold.respan[ast.expr_](expr.span, ast.expr_lit(lit, ann));\n         }\n \n \n-        case (ast.expr_binary(?binop, ?lhs, ?rhs, _)) {\n+        case (ast.expr_binary(?binop, ?lhs, ?rhs, ?a)) {\n             auto lhs_0 = check_expr(fcx, lhs);\n             auto rhs_0 = check_expr(fcx, rhs);\n             auto lhs_t0 = expr_ty(fcx.ccx.tcx, lhs_0);\n@@ -1874,14 +1882,14 @@ fn check_expr(&@fn_ctxt fcx, &@ast.expr expr) -> @ast.expr {\n                 case (_) { /* fall through */ }\n             }\n \n-            auto ann = triv_ann(t);\n+            auto ann = triv_ann(a, t);\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_binary(binop, lhs_1, rhs_1,\n                                                         ann));\n         }\n \n \n-        case (ast.expr_unary(?unop, ?oper, _)) {\n+        case (ast.expr_unary(?unop, ?oper, ?a)) {\n             auto oper_1 = check_expr(fcx, oper);\n             auto oper_t = expr_ty(fcx.ccx.tcx, oper_1);\n             alt (unop) {\n@@ -1905,20 +1913,21 @@ fn check_expr(&@fn_ctxt fcx, &@ast.expr expr) -> @ast.expr {\n                 case (_) { oper_t = strip_boxes(fcx.ccx.tcx, oper_t); }\n             }\n \n-            auto ann = triv_ann(oper_t);\n+            auto ann = triv_ann(a, oper_t);\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_unary(unop, oper_1, ann));\n         }\n \n-        case (ast.expr_path(?pth, ?defopt, _)) {\n+        case (ast.expr_path(?pth, ?defopt, ?old_ann)) {\n             auto t = ty.mk_nil(fcx.ccx.tcx);\n             assert (defopt != none[ast.def]);\n             auto defn = Option.get[ast.def](defopt);\n \n             auto tpt = ty_param_count_and_ty_for_def(fcx, expr.span, defn);\n \n             if (ty.def_has_ty_params(defn)) {\n-                auto ann = instantiate_path(fcx, pth, tpt, expr.span);\n+                auto ann = instantiate_path(fcx, pth, tpt, expr.span,\n+                                            ast.ann_tag(old_ann));\n                 ret @fold.respan[ast.expr_](expr.span,\n                                             ast.expr_path(pth, defopt, ann));\n             }\n@@ -1931,35 +1940,35 @@ fn check_expr(&@fn_ctxt fcx, &@ast.expr expr) -> @ast.expr {\n                 fail;\n             }\n \n-            auto e = ast.expr_path(pth, defopt, triv_ann(tpt._1));\n+            auto e = ast.expr_path(pth, defopt, triv_ann(old_ann, tpt._1));\n             ret @fold.respan[ast.expr_](expr.span, e);\n         }\n \n-        case (ast.expr_ext(?p, ?args, ?body, ?expanded, _)) {\n+        case (ast.expr_ext(?p, ?args, ?body, ?expanded, ?a)) {\n             auto exp_ = check_expr(fcx, expanded);\n             auto t = expr_ty(fcx.ccx.tcx, exp_);\n-            auto ann = triv_ann(t);\n+            auto ann = triv_ann(a, t);\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_ext(p, args, body, exp_,\n                                                      ann));\n         }\n \n-        case (ast.expr_fail(_)) {\n+        case (ast.expr_fail(?a)) {\n             ret @fold.respan[ast.expr_](expr.span,\n-                ast.expr_fail(plain_ann(fcx.ccx.tcx)));\n+                ast.expr_fail(plain_ann(a, fcx.ccx.tcx)));\n         }\n \n-        case (ast.expr_break(_)) {\n+        case (ast.expr_break(?a)) {\n             ret @fold.respan[ast.expr_](expr.span,\n-                ast.expr_break(plain_ann(fcx.ccx.tcx)));\n+                ast.expr_break(plain_ann(a, fcx.ccx.tcx)));\n         }\n \n-        case (ast.expr_cont(_)) {\n+        case (ast.expr_cont(?a)) {\n             ret @fold.respan[ast.expr_](expr.span,\n-                ast.expr_cont(plain_ann(fcx.ccx.tcx)));\n+                ast.expr_cont(plain_ann(a, fcx.ccx.tcx)));\n         }\n \n-        case (ast.expr_ret(?expr_opt, _)) {\n+        case (ast.expr_ret(?expr_opt, ?a)) {\n             alt (expr_opt) {\n                 case (none[@ast.expr]) {\n                     auto nil = ty.mk_nil(fcx.ccx.tcx);\n@@ -1971,7 +1980,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast.expr expr) -> @ast.expr {\n                     ret @fold.respan[ast.expr_]\n                         (expr.span,\n                          ast.expr_ret(none[@ast.expr],\n-                                      plain_ann(fcx.ccx.tcx)));\n+                                      plain_ann(a, fcx.ccx.tcx)));\n                 }\n \n                 case (some[@ast.expr](?e)) {\n@@ -1980,12 +1989,12 @@ fn check_expr(&@fn_ctxt fcx, &@ast.expr expr) -> @ast.expr {\n                                                          expr_0);\n                     ret @fold.respan[ast.expr_]\n                         (expr.span, ast.expr_ret(some(expr_1),\n-                                                 plain_ann(fcx.ccx.tcx)));\n+                                                 plain_ann(a, fcx.ccx.tcx)));\n                 }\n             }\n         }\n \n-        case (ast.expr_put(?expr_opt, _)) {\n+        case (ast.expr_put(?expr_opt, ?a)) {\n             require_impure(fcx.ccx.sess, fcx.purity, expr.span);\n \n             alt (expr_opt) {\n@@ -1998,7 +2007,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast.expr expr) -> @ast.expr {\n \n                     ret @fold.respan[ast.expr_]\n                         (expr.span, ast.expr_put(none[@ast.expr],\n-                         plain_ann(fcx.ccx.tcx)));\n+                                    plain_ann(a, fcx.ccx.tcx)));\n                 }\n \n                 case (some[@ast.expr](?e)) {\n@@ -2007,28 +2016,28 @@ fn check_expr(&@fn_ctxt fcx, &@ast.expr expr) -> @ast.expr {\n                                                          expr_0);\n                     ret @fold.respan[ast.expr_]\n                         (expr.span, ast.expr_put(some(expr_1),\n-                                                 plain_ann(fcx.ccx.tcx)));\n+                                                 plain_ann(a, fcx.ccx.tcx)));\n                 }\n             }\n         }\n \n-        case (ast.expr_be(?e, _)) {\n+        case (ast.expr_be(?e, ?a)) {\n             /* FIXME: prove instead of check */\n             assert (ast.is_call_expr(e));\n             auto expr_0 = check_expr(fcx, e);\n             auto expr_1 = Pushdown.pushdown_expr(fcx, fcx.ret_ty, expr_0);\n-            ret @fold.respan[ast.expr_](expr.span,\n-                ast.expr_be(expr_1, plain_ann(fcx.ccx.tcx)));\n+            ret @fold.respan(expr.span,\n+                             ast.expr_be(expr_1, plain_ann(a, fcx.ccx.tcx)));\n         }\n \n-        case (ast.expr_log(?l,?e,_)) {\n+        case (ast.expr_log(?l, ?e, ?a)) {\n             auto expr_t = check_expr(fcx, e);\n             ret @fold.respan[ast.expr_]\n                 (expr.span, ast.expr_log(l, expr_t,\n-                                         plain_ann(fcx.ccx.tcx)));\n+                                         plain_ann(a, fcx.ccx.tcx)));\n         }\n \n-        case (ast.expr_check(?e, _)) {\n+        case (ast.expr_check(?e, ?a)) {\n             auto expr_t = check_expr(fcx, e);\n             Demand.simple(fcx, expr.span, ty.mk_bool(fcx.ccx.tcx),\n                           expr_ty(fcx.ccx.tcx, expr_t));\n@@ -2052,7 +2061,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast.expr expr) -> @ast.expr {\n \n                             ret @fold.respan[ast.expr_]\n                                 (expr.span, ast.expr_check(expr_t,\n-                                   plain_ann(fcx.ccx.tcx)));\n+                                     plain_ann(a, fcx.ccx.tcx)));\n                         }\n                         case (_) {\n                            fcx.ccx.sess.span_err(expr.span,\n@@ -2068,37 +2077,37 @@ fn check_expr(&@fn_ctxt fcx, &@ast.expr expr) -> @ast.expr {\n             }\n         }\n \n-        case (ast.expr_assert(?e, _)) {\n+        case (ast.expr_assert(?e, ?a)) {\n             auto expr_t = check_expr(fcx, e);\n             Demand.simple(fcx, expr.span, ty.mk_bool(fcx.ccx.tcx),\n                           expr_ty(fcx.ccx.tcx, expr_t));\n             ret @fold.respan[ast.expr_]\n                 (expr.span, ast.expr_assert(expr_t,\n-                                                plain_ann(fcx.ccx.tcx)));\n+                                            plain_ann(a, fcx.ccx.tcx)));\n         }\n \n-        case (ast.expr_assign(?lhs, ?rhs, _)) {\n+        case (ast.expr_assign(?lhs, ?rhs, ?a)) {\n             require_impure(fcx.ccx.sess, fcx.purity, expr.span);\n \n-            auto checked = check_assignment(fcx, lhs, rhs);\n+            auto checked = check_assignment(fcx, lhs, rhs, a);\n             auto newexpr = ast.expr_assign(checked._0,\n                                            checked._1,\n                                            checked._2);\n             ret @fold.respan[ast.expr_](expr.span, newexpr);\n         }\n \n-        case (ast.expr_assign_op(?op, ?lhs, ?rhs, _)) {\n+        case (ast.expr_assign_op(?op, ?lhs, ?rhs, ?a)) {\n             require_impure(fcx.ccx.sess, fcx.purity, expr.span);\n \n-            auto checked = check_assignment(fcx, lhs, rhs);\n+            auto checked = check_assignment(fcx, lhs, rhs, a);\n             auto newexpr = ast.expr_assign_op(op,\n                                               checked._0,\n                                               checked._1,\n                                               checked._2);\n             ret @fold.respan[ast.expr_](expr.span, newexpr);\n         }\n \n-        case (ast.expr_send(?lhs, ?rhs, _)) {\n+        case (ast.expr_send(?lhs, ?rhs, ?a)) {\n             require_impure(fcx.ccx.sess, fcx.purity, expr.span);\n \n             auto lhs_0 = check_expr(fcx, lhs);\n@@ -2118,12 +2127,12 @@ fn check_expr(&@fn_ctxt fcx, &@ast.expr expr) -> @ast.expr {\n             }\n             auto rhs_1 = Pushdown.pushdown_expr(fcx, item_t, rhs_0);\n \n-            auto ann = triv_ann(chan_t);\n+            auto ann = triv_ann(a, chan_t);\n             auto newexpr = ast.expr_send(lhs_1, rhs_1, ann);\n             ret @fold.respan[ast.expr_](expr.span, newexpr);\n         }\n \n-        case (ast.expr_recv(?lhs, ?rhs, _)) {\n+        case (ast.expr_recv(?lhs, ?rhs, ?a)) {\n             require_impure(fcx.ccx.sess, fcx.purity, expr.span);\n \n             auto lhs_0 = check_expr(fcx, lhs);\n@@ -2143,12 +2152,12 @@ fn check_expr(&@fn_ctxt fcx, &@ast.expr expr) -> @ast.expr {\n             }\n             auto lhs_1 = Pushdown.pushdown_expr(fcx, item_t, lhs_0);\n \n-            auto ann = triv_ann(item_t);\n+            auto ann = triv_ann(a, item_t);\n             auto newexpr = ast.expr_recv(lhs_1, rhs_1, ann);\n             ret @fold.respan[ast.expr_](expr.span, newexpr);\n         }\n \n-        case (ast.expr_if(?cond, ?thn, ?elsopt, _)) {\n+        case (ast.expr_if(?cond, ?thn, ?elsopt, ?a)) {\n             auto cond_0 = check_expr(fcx, cond);\n             auto cond_1 = Pushdown.pushdown_expr(fcx, ty.mk_bool(fcx.ccx.tcx),\n                                                  cond_0);\n@@ -2173,61 +2182,61 @@ fn check_expr(&@fn_ctxt fcx, &@ast.expr expr) -> @ast.expr {\n \n             auto thn_1 = Pushdown.pushdown_block(fcx, elsopt_t, thn_0);\n \n-            auto ann = triv_ann(elsopt_t);\n+            auto ann = triv_ann(a, elsopt_t);\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_if(cond_1, thn_1,\n                                                     elsopt_1, ann));\n         }\n \n-        case (ast.expr_for(?decl, ?seq, ?body, _)) {\n+        case (ast.expr_for(?decl, ?seq, ?body, ?a)) {\n             auto decl_1 = check_decl_local(fcx, decl);\n             auto seq_1 = check_expr(fcx, seq);\n             auto body_1 = check_block(fcx, body);\n \n             // FIXME: enforce that the type of the decl is the element type\n             // of the seq.\n \n-            auto ann = triv_ann(ty.mk_nil(fcx.ccx.tcx));\n+            auto ann = triv_ann(a, ty.mk_nil(fcx.ccx.tcx));\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_for(decl_1, seq_1,\n                                                      body_1, ann));\n         }\n \n-        case (ast.expr_for_each(?decl, ?seq, ?body, _)) {\n+        case (ast.expr_for_each(?decl, ?seq, ?body, ?a)) {\n             auto decl_1 = check_decl_local(fcx, decl);\n             auto seq_1 = check_expr(fcx, seq);\n             auto body_1 = check_block(fcx, body);\n \n-            auto ann = triv_ann(ty.mk_nil(fcx.ccx.tcx));\n+            auto ann = triv_ann(a, ty.mk_nil(fcx.ccx.tcx));\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_for_each(decl_1, seq_1,\n                                                           body_1, ann));\n         }\n \n-        case (ast.expr_while(?cond, ?body, _)) {\n+        case (ast.expr_while(?cond, ?body, ?a)) {\n             auto cond_0 = check_expr(fcx, cond);\n             auto cond_1 = Pushdown.pushdown_expr(fcx, ty.mk_bool(fcx.ccx.tcx),\n                                                  cond_0);\n             auto body_1 = check_block(fcx, body);\n \n-            auto ann = triv_ann(ty.mk_nil(fcx.ccx.tcx));\n+            auto ann = triv_ann(a, ty.mk_nil(fcx.ccx.tcx));\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_while(cond_1, body_1, ann));\n         }\n \n-        case (ast.expr_do_while(?body, ?cond, _)) {\n+        case (ast.expr_do_while(?body, ?cond, ?a)) {\n             auto cond_0 = check_expr(fcx, cond);\n             auto cond_1 = Pushdown.pushdown_expr(fcx, ty.mk_bool(fcx.ccx.tcx),\n                                                  cond_0);\n             auto body_1 = check_block(fcx, body);\n \n-            auto ann = triv_ann(block_ty(fcx.ccx.tcx, body_1));\n+            auto ann = triv_ann(a, block_ty(fcx.ccx.tcx, body_1));\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_do_while(body_1, cond_1,\n                                                           ann));\n         }\n \n-        case (ast.expr_alt(?expr, ?arms, _)) {\n+        case (ast.expr_alt(?expr, ?arms, ?a)) {\n             auto expr_0 = check_expr(fcx, expr);\n \n             // Typecheck the patterns first, so that we get types for all the\n@@ -2272,26 +2281,26 @@ fn check_expr(&@fn_ctxt fcx, &@ast.expr expr) -> @ast.expr {\n \n             auto expr_1 = Pushdown.pushdown_expr(fcx, pattern_ty, expr_0);\n \n-            auto ann = triv_ann(result_ty);\n+            auto ann = triv_ann(a, result_ty);\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_alt(expr_1, arms_1, ann));\n         }\n \n-        case (ast.expr_block(?b, _)) {\n+        case (ast.expr_block(?b, ?a)) {\n             auto b_0 = check_block(fcx, b);\n             auto ann;\n             alt (b_0.node.expr) {\n                 case (some[@ast.expr](?expr)) {\n-                    ann = triv_ann(expr_ty(fcx.ccx.tcx, expr));\n+                    ann = triv_ann(a, expr_ty(fcx.ccx.tcx, expr));\n                 }\n                 case (none[@ast.expr]) {\n-                    ann = triv_ann(ty.mk_nil(fcx.ccx.tcx));\n+                    ann = triv_ann(a, ty.mk_nil(fcx.ccx.tcx));\n                 }\n             }\n             ret @fold.respan[ast.expr_](expr.span, ast.expr_block(b_0, ann));\n         }\n \n-        case (ast.expr_bind(?f, ?args, _)) {\n+        case (ast.expr_bind(?f, ?args, ?a)) {\n             // Call the generic checker.\n             auto result = check_call_or_bind(fcx, f, args);\n \n@@ -2324,13 +2333,13 @@ fn check_expr(&@fn_ctxt fcx, &@ast.expr expr) -> @ast.expr {\n             }\n \n             auto t_1 = ty.mk_fn(fcx.ccx.tcx, proto_1, arg_tys_1, rt_1);\n-            auto ann = triv_ann(t_1);\n+            auto ann = triv_ann(a, t_1);\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_bind(result._0, result._1,\n                                                       ann));\n         }\n \n-        case (ast.expr_call(?f, ?args, _)) {\n+        case (ast.expr_call(?f, ?args, ?a)) {\n             /* here we're kind of hosed, as f can be any expr\n              need to restrict it to being an explicit expr_path if we're\n             inside a pure function, and need an environment mapping from \n@@ -2352,12 +2361,12 @@ fn check_expr(&@fn_ctxt fcx, &@ast.expr expr) -> @ast.expr {\n                 }\n             }\n \n-            auto ann = triv_ann(rt_1);\n+            auto ann = triv_ann(a, rt_1);\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_call(f_1, args_1, ann));\n         }\n \n-        case (ast.expr_self_method(?id, _)) {\n+        case (ast.expr_self_method(?id, ?a)) {\n             auto t = ty.mk_nil(fcx.ccx.tcx);\n             let ty.t this_obj_ty;\n \n@@ -2387,15 +2396,15 @@ fn check_expr(&@fn_ctxt fcx, &@ast.expr expr) -> @ast.expr {\n                 case (_) { fail; }\n             }\n \n-            auto ann = triv_ann(t);\n+            auto ann = triv_ann(a, t);\n \n             require_impure(fcx.ccx.sess, fcx.purity, expr.span);\n \n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_self_method(id, ann));\n         }\n \n-        case (ast.expr_spawn(?dom, ?name, ?f, ?args, _)) {\n+        case (ast.expr_spawn(?dom, ?name, ?f, ?args, ?a)) {\n             auto result = check_call(fcx, f, args);\n             auto f_1 = result._0;\n             auto args_1 = result._1;\n@@ -2419,13 +2428,13 @@ fn check_expr(&@fn_ctxt fcx, &@ast.expr expr) -> @ast.expr {\n \n             // FIXME: Other typechecks needed\n \n-            auto ann = triv_ann(ty.mk_task(fcx.ccx.tcx));\n+            auto ann = triv_ann(a, ty.mk_task(fcx.ccx.tcx));\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_spawn(dom, name,\n                                                        f_1, args_1, ann));\n         }\n \n-        case (ast.expr_cast(?e, ?t, _)) {\n+        case (ast.expr_cast(?e, ?t, ?a)) {\n             auto e_1 = check_expr(fcx, e);\n             auto t_1 = ast_ty_to_ty_crate(fcx.ccx, t);\n             // FIXME: there are more forms of cast to support, eventually.\n@@ -2437,12 +2446,12 @@ fn check_expr(&@fn_ctxt fcx, &@ast.expr expr) -> @ast.expr {\n                     \" as \" + ty_to_str(fcx.ccx.tcx, t_1));\n             }\n \n-            auto ann = triv_ann(t_1);\n+            auto ann = triv_ann(a, t_1);\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_cast(e_1, t, ann));\n         }\n \n-        case (ast.expr_vec(?args, ?mut, _)) {\n+        case (ast.expr_vec(?args, ?mut, ?a)) {\n             let vec[@ast.expr] args_1 = vec();\n \n             let ty.t t;\n@@ -2460,13 +2469,13 @@ fn check_expr(&@fn_ctxt fcx, &@ast.expr expr) -> @ast.expr {\n                 Vec.push[@ast.expr](args_1,expr_1);\n             }\n \n-            auto ann = triv_ann(ty.mk_vec(fcx.ccx.tcx,\n-                                          rec(ty=t, mut=mut)));\n+            auto ann = triv_ann(a, ty.mk_vec(fcx.ccx.tcx,\n+                                             rec(ty=t, mut=mut)));\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_vec(args_1, mut, ann));\n         }\n \n-        case (ast.expr_tup(?elts, _)) {\n+        case (ast.expr_tup(?elts, ?a)) {\n             let vec[ast.elt] elts_1 = vec();\n             let vec[ty.mt] elts_mt = vec();\n \n@@ -2477,12 +2486,12 @@ fn check_expr(&@fn_ctxt fcx, &@ast.expr expr) -> @ast.expr {\n                 elts_mt += vec(rec(ty=expr_t, mut=e.mut));\n             }\n \n-            auto ann = triv_ann(ty.mk_tup(fcx.ccx.tcx, elts_mt));\n+            auto ann = triv_ann(a, ty.mk_tup(fcx.ccx.tcx, elts_mt));\n             ret @fold.respan[ast.expr_](expr.span,\n                                         ast.expr_tup(elts_1, ann));\n         }\n \n-        case (ast.expr_rec(?fields, ?base, _)) {\n+        case (ast.expr_rec(?fields, ?base, ?a)) {\n \n             auto base_1;\n             alt (base) {\n@@ -2508,7 +2517,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast.expr expr) -> @ast.expr {\n \n             alt (base) {\n                 case (none[@ast.expr]) {\n-                    ann = triv_ann(ty.mk_rec(fcx.ccx.tcx, fields_t));\n+                    ann = triv_ann(a, ty.mk_rec(fcx.ccx.tcx, fields_t));\n                 }\n \n                 case (some[@ast.expr](?bexpr)) {\n@@ -2528,7 +2537,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast.expr expr) -> @ast.expr {\n                         }\n                     }\n \n-                    ann = triv_ann(bexpr_t);\n+                    ann = triv_ann(a, bexpr_t);\n \n                     for (ty.field f in fields_t) {\n                         auto found = false;\n@@ -2553,7 +2562,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast.expr expr) -> @ast.expr {\n                                         ast.expr_rec(fields_1, base_1, ann));\n         }\n \n-        case (ast.expr_field(?base, ?field, _)) {\n+        case (ast.expr_field(?base, ?field, ?a)) {\n             auto base_1 = check_expr(fcx, base);\n             auto base_t = strip_boxes(fcx.ccx.tcx,\n                                       expr_ty(fcx.ccx.tcx, base_1));\n@@ -2565,7 +2574,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast.expr expr) -> @ast.expr {\n                         fcx.ccx.sess.span_err(expr.span,\n                                               \"bad index on tuple\");\n                     }\n-                    auto ann = triv_ann(args.(ix).ty);\n+                    auto ann = triv_ann(a, args.(ix).ty);\n                     ret @fold.respan[ast.expr_](expr.span,\n                                                 ast.expr_field(base_1,\n                                                                field,\n@@ -2579,7 +2588,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast.expr expr) -> @ast.expr {\n                         fcx.ccx.sess.span_err(expr.span,\n                                               \"bad index on record\");\n                     }\n-                    auto ann = triv_ann(fields.(ix).mt.ty);\n+                    auto ann = triv_ann(a, fields.(ix).mt.ty);\n                     ret @fold.respan[ast.expr_](expr.span,\n                                                 ast.expr_field(base_1,\n                                                                field,\n@@ -2596,7 +2605,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast.expr expr) -> @ast.expr {\n                     auto meth = methods.(ix);\n                     auto t = ty.mk_fn(fcx.ccx.tcx, meth.proto,\n                                       meth.inputs, meth.output);\n-                    auto ann = triv_ann(t);\n+                    auto ann = triv_ann(a, t);\n                     ret @fold.respan[ast.expr_](expr.span,\n                                                 ast.expr_field(base_1,\n                                                                field,\n@@ -2611,7 +2620,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast.expr expr) -> @ast.expr {\n             }\n         }\n \n-        case (ast.expr_index(?base, ?idx, _)) {\n+        case (ast.expr_index(?base, ?idx, ?a)) {\n             auto base_1 = check_expr(fcx, base);\n             auto base_t = strip_boxes(fcx.ccx.tcx,\n                                       expr_ty(fcx.ccx.tcx, base_1));\n@@ -2626,7 +2635,7 @@ fn check_expr(&@fn_ctxt fcx, &@ast.expr expr) -> @ast.expr {\n                              \"non-integral type of vec index: \"\n                              + ty_to_str(fcx.ccx.tcx, idx_t));\n                     }\n-                    auto ann = triv_ann(mt.ty);\n+                    auto ann = triv_ann(a, mt.ty);\n                     ret @fold.respan[ast.expr_](expr.span,\n                                                 ast.expr_index(base_1,\n                                                                idx_1,\n@@ -2639,8 +2648,8 @@ fn check_expr(&@fn_ctxt fcx, &@ast.expr expr) -> @ast.expr {\n                              \"non-integral type of str index: \"\n                              + ty_to_str(fcx.ccx.tcx, idx_t));\n                     }\n-                    auto ann = triv_ann(ty.mk_mach(fcx.ccx.tcx,\n-                                                   common.ty_u8));\n+                    auto ann = triv_ann(a, ty.mk_mach(fcx.ccx.tcx,\n+                                                      common.ty_u8));\n                     ret @fold.respan[ast.expr_](expr.span,\n                                                 ast.expr_index(base_1,\n                                                                idx_1,\n@@ -2655,20 +2664,20 @@ fn check_expr(&@fn_ctxt fcx, &@ast.expr expr) -> @ast.expr {\n             }\n         }\n \n-        case (ast.expr_port(_)) {\n+        case (ast.expr_port(?a)) {\n             auto t = next_ty_var(fcx.ccx);\n             auto pt = ty.mk_port(fcx.ccx.tcx, t);\n-            auto ann = triv_ann(pt);\n+            auto ann = triv_ann(a, pt);\n             ret @fold.respan[ast.expr_](expr.span, ast.expr_port(ann));\n         }\n \n-        case (ast.expr_chan(?x, _)) {\n+        case (ast.expr_chan(?x, ?a)) {\n             auto expr_1 = check_expr(fcx, x);\n             auto port_t = expr_ty(fcx.ccx.tcx, expr_1);\n             alt (struct(fcx.ccx.tcx, port_t)) {\n                 case (ty.ty_port(?subtype)) {\n                     auto ct = ty.mk_chan(fcx.ccx.tcx, subtype);\n-                    auto ann = triv_ann(ct);\n+                    auto ann = triv_ann(a, ct);\n                     ret @fold.respan[ast.expr_](expr.span,\n                                                 ast.expr_chan(expr_1, ann));\n                 }\n@@ -2716,7 +2725,7 @@ fn check_decl_local(&@fn_ctxt fcx, &@ast.decl decl) -> @ast.decl {\n             auto a_res = local.ann;\n             alt (a_res) {\n                 case (ann_none(_)) {\n-                    a_res = triv_ann(t);\n+                    a_res = triv_ann(a_res, t);\n                 }\n                 case (_) {}\n             }\n@@ -2758,14 +2767,14 @@ fn check_stmt(&@fn_ctxt fcx, &@ast.stmt stmt) -> @ast.stmt {\n                     auto decl_1 = check_decl_local(fcx, decl);\n                     ret @fold.respan[ast.stmt_](stmt.span,\n                            ast.stmt_decl(decl_1,\n-                             plain_ann(fcx.ccx.tcx)));\n+                                         plain_ann(a, fcx.ccx.tcx)));\n                 }\n \n                 case (ast.decl_item(_)) {\n                     // Ignore for now. We'll return later.\n                     ret @fold.respan[ast.stmt_](stmt.span,\n                            ast.stmt_decl(decl,\n-                             plain_ann(fcx.ccx.tcx)));\n+                                         plain_ann(a, fcx.ccx.tcx)));\n                 }\n             }\n \n@@ -2776,8 +2785,8 @@ fn check_stmt(&@fn_ctxt fcx, &@ast.stmt stmt) -> @ast.stmt {\n             auto expr_t = check_expr(fcx, expr);\n             expr_t = Pushdown.pushdown_expr(fcx, expr_ty(fcx.ccx.tcx, expr_t),\n                                             expr_t);\n-            ret @fold.respan[ast.stmt_](stmt.span,\n-                   ast.stmt_expr(expr_t, plain_ann(fcx.ccx.tcx)));\n+            ret @fold.respan(stmt.span,\n+                            ast.stmt_expr(expr_t, plain_ann(a, fcx.ccx.tcx)));\n         }\n     }\n \n@@ -2802,9 +2811,9 @@ fn check_block(&@fn_ctxt fcx, &ast.block block) -> ast.block {\n         }\n     }\n \n-    ret fold.respan[ast.block_](block.span,\n-                                rec(stmts=stmts, expr=expr,\n-                                    a=plain_ann(fcx.ccx.tcx)));\n+    ret fold.respan(block.span,\n+                    rec(stmts=stmts, expr=expr,\n+                        a=plain_ann(block.node.a, fcx.ccx.tcx)));\n }\n \n fn check_const(&@crate_ctxt ccx, &span sp, &ast.ident ident, &@ast.ty t,\n@@ -2884,7 +2893,8 @@ fn check_item_fn(&@crate_ctxt ccx, &span sp, &ast.ident ident, &ast._fn f,\n     }\n \n     auto output_ty = ast_ty_to_ty_crate(ccx, f.decl.output);\n-    auto fn_ann = triv_ann(ty.mk_fn(ccx.tcx, f.proto, inputs, output_ty));\n+    auto fn_ann = triv_ann(ann, ty.mk_fn(ccx.tcx, f.proto, inputs,\n+                                         output_ty));\n \n     auto item = ast.item_fn(ident, f, ty_params, id, fn_ann);\n     ret @fold.respan[ast.item_](sp, item);"}, {"sha": "832938f593e265b088eea3f9506468ce2da793ae", "filename": "src/comp/middle/typestate_check.rs", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/2b36e40c58a4b153da593e4da73ba45647b811de/src%2Fcomp%2Fmiddle%2Ftypestate_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b36e40c58a4b153da593e4da73ba45647b811de/src%2Fcomp%2Fmiddle%2Ftypestate_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftypestate_check.rs?ref=2b36e40c58a4b153da593e4da73ba45647b811de", "patch": "@@ -389,7 +389,7 @@ fn mk_f_to_fn_info(@ast.crate c) -> fn_info_map {\n fn ann_to_ts_ann(ann a, uint nv) -> ts_ann {\n   alt (a) {\n     case (ann_none(_))      { ret empty_ann(nv); }\n-    case (ann_type(_,_,?t)) {\n+    case (ann_type(_,_,_,?t)) {\n       alt (t) {\n         /* Kind of inconsistent. empty_ann()s everywhere\n          or an option of a ts_ann? */\n@@ -406,7 +406,7 @@ fn ann_to_ts_ann_fail(ann a) -> Option.t[@ts_ann] {\n           log(\"ann_to_ts_ann_fail: didn't expect ann_none here\");\n           fail;\n       }\n-      case (ann_type(_,_,?t)) {\n+      case (ann_type(_,_,_,?t)) {\n           ret t;\n       }\n   }\n@@ -418,7 +418,7 @@ fn ann_to_ts_ann_fail_more(ann a) -> @ts_ann {\n           log(\"ann_to_ts_ann_fail: didn't expect ann_none here\");\n           fail;\n       }\n-      case (ann_type(_,_,?t)) {\n+      case (ann_type(_,_,_,?t)) {\n           assert (! is_none[@ts_ann](t));\n           ret get[@ts_ann](t);\n       }\n@@ -450,7 +450,7 @@ fn expr_states(@expr e) -> pre_and_post_state {\n       log_err \"expr_pp: the impossible happened (no annotation)\";\n       fail;\n     }\n-    case (ann_type(_, _, ?maybe_pp)) {\n+    case (ann_type(_, _, _, ?maybe_pp)) {\n       alt (maybe_pp) {\n         case (none[@ts_ann]) {\n           log_err \"expr_pp: the impossible happened (no pre/post)\";\n@@ -471,7 +471,7 @@ fn expr_pp(@expr e) -> pre_and_post {\n       log_err \"expr_pp: the impossible happened (no annotation)\";\n       fail;\n     }\n-    case (ann_type(_, _, ?maybe_pp)) {\n+    case (ann_type(_, _, _, ?maybe_pp)) {\n       alt (maybe_pp) {\n         case (none[@ts_ann]) {\n           log_err \"expr_pp: the impossible happened (no pre/post)\";\n@@ -505,7 +505,7 @@ fn block_pp(&block b) -> pre_and_post {\n            log_err \"block_pp: the impossible happened (no ann)\";\n            fail;\n        }\n-       case (ann_type(_,_,?t)) {\n+       case (ann_type(_, _,_,?t)) {\n            alt (t) {\n                case (none[@ts_ann]) {\n                    log_err \"block_pp: the impossible happened (no ty)\";\n@@ -525,7 +525,7 @@ fn block_states(&block b) -> pre_and_post_state {\n            log_err \"block_pp: the impossible happened (no ann)\";\n            fail;\n        }\n-       case (ann_type(_,_,?t)) {\n+       case (ann_type(_, _,_,?t)) {\n            alt (t) {\n                case (none[@ts_ann]) {\n                    log_err \"block_states: the impossible happened (no ty)\";\n@@ -605,8 +605,8 @@ fn with_pp(ann a, pre_and_post p) -> ann {\n       log(\"with_pp: the impossible happened\");\n       fail; /* shouldn't happen b/c code is typechecked */\n     }\n-    case (ann_type(?t, ?ps, _)) {\n-      ret (ann_type(t, ps,\n+    case (ann_type(?tg, ?t, ?ps, _)) {\n+      ret (ann_type(tg, t, ps,\n                     some[@ts_ann]\n                     (@rec(conditions=p,\n                           states=empty_states(pps_len(p))))));\n@@ -1292,7 +1292,7 @@ fn find_pre_post_state_item(fn_info_map fm, fn_info enclosing, @item i)\n \n fn set_prestate_ann(@ann a, prestate pre) -> bool {\n   alt (*a) {\n-    case (ann_type(_,_,?ts_a)) {\n+    case (ann_type(_, _,_,?ts_a)) {\n       assert (! is_none[@ts_ann](ts_a));\n       ret set_prestate(get[@ts_ann](ts_a), pre);\n     }\n@@ -1306,7 +1306,7 @@ fn set_prestate_ann(@ann a, prestate pre) -> bool {\n \n fn extend_prestate_ann(ann a, prestate pre) -> bool {\n   alt (a) {\n-    case (ann_type(_,_,?ts_a)) {\n+    case (ann_type(_,_,_,?ts_a)) {\n       assert (! is_none[@ts_ann](ts_a));\n       ret extend_prestate((get[@ts_ann](ts_a)).states.prestate, pre);\n     }\n@@ -1319,7 +1319,7 @@ fn extend_prestate_ann(ann a, prestate pre) -> bool {\n \n fn set_poststate_ann(ann a, poststate post) -> bool {\n   alt (a) {\n-    case (ann_type(_,_,?ts_a)) {\n+    case (ann_type(_, _,_,?ts_a)) {\n       assert (! is_none[@ts_ann](ts_a));\n       ret set_poststate(get[@ts_ann](ts_a), post);\n     }\n@@ -1332,7 +1332,7 @@ fn set_poststate_ann(ann a, poststate post) -> bool {\n \n fn extend_poststate_ann(ann a, poststate post) -> bool {\n   alt (a) {\n-    case (ann_type(_,_,?ts_a)) {\n+    case (ann_type(_, _,_,?ts_a)) {\n       assert (! is_none[@ts_ann](ts_a));\n       ret extend_poststate((*get[@ts_ann](ts_a)).states.poststate, post);\n     }\n@@ -1345,7 +1345,7 @@ fn extend_poststate_ann(ann a, poststate post) -> bool {\n \n fn set_pre_and_post(&ann a, pre_and_post pp) -> () {\n     alt (a) {\n-        case (ann_type(_,_,?ts_a)) {\n+        case (ann_type(_, _,_,?ts_a)) {\n             assert (! is_none[@ts_ann](ts_a));\n             auto t = *get[@ts_ann](ts_a);\n             /*  log(\"set_pre_and_post, old =\");\n@@ -2046,8 +2046,9 @@ fn init_ann(&fn_info fi, &ann a) -> ann {\n             // result in an uninitialized ann -- but don't want to have to\n             // write code to handle native_mods properly\n         }\n-        case (ann_type(?t,?ps,_)) {\n-            ret ann_type(t, ps, some[@ts_ann](@empty_ann(num_locals(fi))));\n+        case (ann_type(?tg, ?t,?ps,_)) {\n+            ret ann_type(tg, t, ps,\n+                         some[@ts_ann](@empty_ann(num_locals(fi))));\n         }\n     }\n }\n@@ -2060,8 +2061,8 @@ fn init_blank_ann(&() ignore, &ann a) -> ann {\n             log(\"warning: init_blank_ann: saw ann_none\");\n             ret a;\n         }\n-        case (ann_type(?t,?ps,_)) {\n-            ret ann_type(t, ps, some[@ts_ann](@empty_ann(0u)));\n+        case (ann_type(?tg, ?t,?ps,_)) {\n+            ret ann_type(tg, t, ps, some[@ts_ann](@empty_ann(0u)));\n         }\n     }\n }\n@@ -2074,7 +2075,7 @@ fn init_block(&fn_info fi, &span sp, &block_ b) -> block {\n             log(\"init_block: shouldn't see ann_none\");\n             fail;\n         }\n-        case (ann_type(?t,?ps,_)) {\n+        case (ann_type(_, ?t,?ps,_)) {\n             auto fld0 = fold.new_identity_fold[fn_info]();\n \n             fld0 = @rec(fold_ann = bind init_ann(_,_) with *fld0);"}, {"sha": "83223d7507e18b1908d40953200f2eab65d55154", "filename": "src/comp/util/common.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/2b36e40c58a4b153da593e4da73ba45647b811de/src%2Fcomp%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2b36e40c58a4b153da593e4da73ba45647b811de/src%2Fcomp%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fcommon.rs?ref=2b36e40c58a4b153da593e4da73ba45647b811de", "patch": "@@ -117,8 +117,8 @@ fn field_exprs(vec[ast.field] fields) -> vec [@ast.expr] {\n     ret Vec.map[ast.field, @ast.expr](f, fields);\n }\n \n-fn plain_ann(middle.ty.ctxt tcx) -> ast.ann {\n-  ret ast.ann_type(middle.ty.mk_nil(tcx),\n+fn plain_ann(&ast.ann old, middle.ty.ctxt tcx) -> ast.ann {\n+    ret ast.ann_type(ast.ann_tag(old), middle.ty.mk_nil(tcx),\n                    none[vec[middle.ty.t]], none[@ts_ann]);\n }\n \n@@ -164,7 +164,7 @@ fn log_ann(&ast.ann a) -> () {\n         case (ast.ann_none(_)) {\n             log(\"ann_none\");\n         }\n-        case (ast.ann_type(_,_,_)) {\n+        case (ast.ann_type(_,_,_,_)) {\n             log(\"ann_type\");\n         }\n     }"}]}