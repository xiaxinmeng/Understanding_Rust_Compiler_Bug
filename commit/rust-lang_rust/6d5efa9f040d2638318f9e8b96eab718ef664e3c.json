{"sha": "6d5efa9f040d2638318f9e8b96eab718ef664e3c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZkNWVmYTlmMDQwZDI2MzgzMThmOWU4Yjk2ZWFiNzE4ZWY2NjRlM2M=", "commit": {"author": {"name": "Jack Huey", "email": "jack.huey@umassmed.edu", "date": "2020-10-26T18:18:31Z"}, "committer": {"name": "Jack Huey", "email": "jack.huey@umassmed.edu", "date": "2021-03-31T14:16:37Z"}, "message": "Add var to BoundRegion. Add query to get bound vars for applicable items.", "tree": {"sha": "b24284a8356c8d4a2e395aa91b136251dd7a2a08", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b24284a8356c8d4a2e395aa91b136251dd7a2a08"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6d5efa9f040d2638318f9e8b96eab718ef664e3c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6d5efa9f040d2638318f9e8b96eab718ef664e3c", "html_url": "https://github.com/rust-lang/rust/commit/6d5efa9f040d2638318f9e8b96eab718ef664e3c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6d5efa9f040d2638318f9e8b96eab718ef664e3c/comments", "author": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jackh726", "id": 31162821, "node_id": "MDQ6VXNlcjMxMTYyODIx", "avatar_url": "https://avatars.githubusercontent.com/u/31162821?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jackh726", "html_url": "https://github.com/jackh726", "followers_url": "https://api.github.com/users/jackh726/followers", "following_url": "https://api.github.com/users/jackh726/following{/other_user}", "gists_url": "https://api.github.com/users/jackh726/gists{/gist_id}", "starred_url": "https://api.github.com/users/jackh726/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jackh726/subscriptions", "organizations_url": "https://api.github.com/users/jackh726/orgs", "repos_url": "https://api.github.com/users/jackh726/repos", "events_url": "https://api.github.com/users/jackh726/events{/privacy}", "received_events_url": "https://api.github.com/users/jackh726/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "666859a6f85a9ddad1e29de2daa4b8eef190c062", "url": "https://api.github.com/repos/rust-lang/rust/commits/666859a6f85a9ddad1e29de2daa4b8eef190c062", "html_url": "https://github.com/rust-lang/rust/commit/666859a6f85a9ddad1e29de2daa4b8eef190c062"}], "stats": {"total": 1633, "additions": 1261, "deletions": 372}, "files": [{"sha": "6317808e7fbe0b87e6b6ed288322c17b7d3f008f", "filename": "compiler/rustc_hir/src/hir.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6d5efa9f040d2638318f9e8b96eab718ef664e3c/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d5efa9f040d2638318f9e8b96eab718ef664e3c/compiler%2Frustc_hir%2Fsrc%2Fhir.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir%2Fsrc%2Fhir.rs?ref=6d5efa9f040d2638318f9e8b96eab718ef664e3c", "patch": "@@ -402,7 +402,7 @@ pub enum TraitBoundModifier {\n /// `typeck::collect::compute_bounds` matches these against\n /// the \"special\" built-in traits (see `middle::lang_items`) and\n /// detects `Copy`, `Send` and `Sync`.\n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Clone, Debug, HashStable_Generic)]\n pub enum GenericBound<'hir> {\n     Trait(PolyTraitRef<'hir>, TraitBoundModifier),\n     // FIXME(davidtwco): Introduce `PolyTraitRef::LangItem`\n@@ -2556,7 +2556,7 @@ pub enum UseKind {\n /// that the `ref_id` is for. Note that `ref_id`'s value is not the `HirId` of the\n /// trait being referred to but just a unique `HirId` that serves as a key\n /// within the resolution map.\n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Clone, Debug, HashStable_Generic)]\n pub struct TraitRef<'hir> {\n     pub path: &'hir Path<'hir>,\n     // Don't hash the `ref_id`. It is tracked via the thing it is used to access.\n@@ -2575,7 +2575,7 @@ impl TraitRef<'_> {\n     }\n }\n \n-#[derive(Debug, HashStable_Generic)]\n+#[derive(Clone, Debug, HashStable_Generic)]\n pub struct PolyTraitRef<'hir> {\n     /// The `'a` in `for<'a> Foo<&'a T>`.\n     pub bound_generic_params: &'hir [GenericParam<'hir>],"}, {"sha": "c68705da413f829401cb03eb7b78d9346d04a16c", "filename": "compiler/rustc_infer/src/infer/canonical/canonicalizer.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d5efa9f040d2638318f9e8b96eab718ef664e3c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d5efa9f040d2638318f9e8b96eab718ef664e3c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fcanonicalizer.rs?ref=6d5efa9f040d2638318f9e8b96eab718ef664e3c", "patch": "@@ -621,7 +621,7 @@ impl<'cx, 'tcx> Canonicalizer<'cx, 'tcx> {\n         r: ty::Region<'tcx>,\n     ) -> ty::Region<'tcx> {\n         let var = self.canonical_var(info, r.into());\n-        let br = ty::BoundRegion { kind: ty::BrAnon(var.as_u32()) };\n+        let br = ty::BoundRegion { var, kind: ty::BrAnon(var.as_u32()) };\n         let region = ty::ReLateBound(self.binder_index, br);\n         self.tcx().mk_region(region)\n     }"}, {"sha": "b8ecc949588fb0658d3e79b7c416018d220773c1", "filename": "compiler/rustc_infer/src/infer/canonical/query_response.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d5efa9f040d2638318f9e8b96eab718ef664e3c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d5efa9f040d2638318f9e8b96eab718ef664e3c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=6d5efa9f040d2638318f9e8b96eab718ef664e3c", "patch": "@@ -439,7 +439,7 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n \n                         // We only allow a `ty::INNERMOST` index in substitutions.\n                         assert_eq!(debruijn, ty::INNERMOST);\n-                        opt_values[br.assert_bound_var()] = Some(*original_value);\n+                        opt_values[br.var] = Some(*original_value);\n                     }\n                 }\n                 GenericArgKind::Const(result_value) => {"}, {"sha": "553a11d4393f94ba0f3e1e14fdd1e8463745265a", "filename": "compiler/rustc_infer/src/infer/canonical/substitute.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6d5efa9f040d2638318f9e8b96eab718ef664e3c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fsubstitute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d5efa9f040d2638318f9e8b96eab718ef664e3c/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fsubstitute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fsubstitute.rs?ref=6d5efa9f040d2638318f9e8b96eab718ef664e3c", "patch": "@@ -71,11 +71,10 @@ where\n     if var_values.var_values.is_empty() {\n         value\n     } else {\n-        let fld_r =\n-            |br: ty::BoundRegion| match var_values.var_values[br.assert_bound_var()].unpack() {\n-                GenericArgKind::Lifetime(l) => l,\n-                r => bug!(\"{:?} is a region but value is {:?}\", br, r),\n-            };\n+        let fld_r = |br: ty::BoundRegion| match var_values.var_values[br.var].unpack() {\n+            GenericArgKind::Lifetime(l) => l,\n+            r => bug!(\"{:?} is a region but value is {:?}\", br, r),\n+        };\n \n         let fld_t = |bound_ty: ty::BoundTy| match var_values.var_values[bound_ty.var].unpack() {\n             GenericArgKind::Type(ty) => ty,"}, {"sha": "8e53e4ba948058bdd4351b7a93227ddf27aea74a", "filename": "compiler/rustc_middle/src/ich/impls_ty.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6d5efa9f040d2638318f9e8b96eab718ef664e3c/compiler%2Frustc_middle%2Fsrc%2Fich%2Fimpls_ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d5efa9f040d2638318f9e8b96eab718ef664e3c/compiler%2Frustc_middle%2Fsrc%2Fich%2Fimpls_ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fich%2Fimpls_ty.rs?ref=6d5efa9f040d2638318f9e8b96eab718ef664e3c", "patch": "@@ -70,16 +70,16 @@ impl<'a> HashStable<StableHashingContext<'a>> for ty::RegionKind {\n             ty::ReEmpty(universe) => {\n                 universe.hash_stable(hcx, hasher);\n             }\n-            ty::ReLateBound(db, ty::BoundRegion { kind: ty::BrAnon(i) }) => {\n+            ty::ReLateBound(db, ty::BoundRegion { kind: ty::BrAnon(i), .. }) => {\n                 db.hash_stable(hcx, hasher);\n                 i.hash_stable(hcx, hasher);\n             }\n-            ty::ReLateBound(db, ty::BoundRegion { kind: ty::BrNamed(def_id, name) }) => {\n+            ty::ReLateBound(db, ty::BoundRegion { kind: ty::BrNamed(def_id, name), .. }) => {\n                 db.hash_stable(hcx, hasher);\n                 def_id.hash_stable(hcx, hasher);\n                 name.hash_stable(hcx, hasher);\n             }\n-            ty::ReLateBound(db, ty::BoundRegion { kind: ty::BrEnv }) => {\n+            ty::ReLateBound(db, ty::BoundRegion { kind: ty::BrEnv, .. }) => {\n                 db.hash_stable(hcx, hasher);\n             }\n             ty::ReEarlyBound(ty::EarlyBoundRegion { def_id, index, name }) => {"}, {"sha": "5df2f91f09fff253a70b0179873d7a35631dd988", "filename": "compiler/rustc_middle/src/infer/canonical.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/6d5efa9f040d2638318f9e8b96eab718ef664e3c/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d5efa9f040d2638318f9e8b96eab718ef664e3c/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Finfer%2Fcanonical.rs?ref=6d5efa9f040d2638318f9e8b96eab718ef664e3c", "patch": "@@ -314,7 +314,8 @@ impl<'tcx> CanonicalVarValues<'tcx> {\n                         tcx.mk_ty(ty::Bound(ty::INNERMOST, ty::BoundVar::from_u32(i).into())).into()\n                     }\n                     GenericArgKind::Lifetime(..) => {\n-                        let br = ty::BoundRegion { kind: ty::BrAnon(i) };\n+                        let br =\n+                            ty::BoundRegion { var: ty::BoundVar::from_u32(i), kind: ty::BrAnon(i) };\n                         tcx.mk_region(ty::ReLateBound(ty::INNERMOST, br)).into()\n                     }\n                     GenericArgKind::Const(ct) => tcx"}, {"sha": "aa6488b329eba76cb14311993556a37c8102d42e", "filename": "compiler/rustc_middle/src/middle/resolve_lifetime.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d5efa9f040d2638318f9e8b96eab718ef664e3c/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fresolve_lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d5efa9f040d2638318f9e8b96eab718ef664e3c/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fresolve_lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmiddle%2Fresolve_lifetime.rs?ref=6d5efa9f040d2638318f9e8b96eab718ef664e3c", "patch": "@@ -83,4 +83,6 @@ pub struct ResolveLifetimes {\n     /// be late-bound if (a) it does NOT appear in a where-clause and\n     /// (b) it DOES appear in the arguments.\n     pub late_bound: FxHashMap<LocalDefId, FxHashSet<ItemLocalId>>,\n+\n+    pub late_bound_vars: FxHashMap<LocalDefId, FxHashMap<ItemLocalId, Vec<ty::BoundVariableKind>>>,\n }"}, {"sha": "99d063c7eeafb57b2d935c4f777b4521d15fed83", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6d5efa9f040d2638318f9e8b96eab718ef664e3c/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d5efa9f040d2638318f9e8b96eab718ef664e3c/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=6d5efa9f040d2638318f9e8b96eab718ef664e3c", "patch": "@@ -1290,6 +1290,10 @@ rustc_queries! {\n         -> Option<Vec<ObjectLifetimeDefault>> {\n         desc { \"looking up lifetime defaults for a region on an item\" }\n     }\n+    query late_bound_vars_map(_: LocalDefId)\n+        -> Option<&'tcx FxHashMap<ItemLocalId, Vec<ty::BoundVariableKind>>> {\n+        desc { \"looking up late bound vars\" }\n+    }\n \n     query visibility(def_id: DefId) -> ty::Visibility {\n         eval_always"}, {"sha": "bb2b00cbaea818bc3c794ec20bca334f873d40f9", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6d5efa9f040d2638318f9e8b96eab718ef664e3c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d5efa9f040d2638318f9e8b96eab718ef664e3c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=6d5efa9f040d2638318f9e8b96eab718ef664e3c", "patch": "@@ -810,7 +810,7 @@ impl CanonicalUserType<'tcx> {\n                             ty::ReLateBound(debruijn, br) => {\n                                 // We only allow a `ty::INNERMOST` index in substitutions.\n                                 assert_eq!(*debruijn, ty::INNERMOST);\n-                                cvar == br.assert_bound_var()\n+                                cvar == br.var\n                             }\n                             _ => false,\n                         },\n@@ -2672,6 +2672,17 @@ impl<'tcx> TyCtxt<'tcx> {\n     pub fn object_lifetime_defaults(self, id: HirId) -> Option<Vec<ObjectLifetimeDefault>> {\n         self.object_lifetime_defaults_map(id.owner)\n     }\n+\n+    pub fn late_bound_vars(self, id: HirId) -> &'tcx List<ty::BoundVariableKind> {\n+        self.mk_bound_variable_kinds(\n+            self.late_bound_vars_map(id.owner)\n+                .and_then(|map| map.get(&id.local_id).cloned())\n+                .unwrap_or_else(|| {\n+                    bug!(\"No bound vars found for {:?} ({:?})\", self.hir().node_to_string(id), id)\n+                })\n+                .iter(),\n+        )\n+    }\n }\n \n impl TyCtxtAt<'tcx> {"}, {"sha": "368236b146fb0a03b52d39225573aa27f4b955cf", "filename": "compiler/rustc_middle/src/ty/fold.rs", "status": "modified", "additions": 141, "deletions": 22, "changes": 163, "blob_url": "https://github.com/rust-lang/rust/blob/6d5efa9f040d2638318f9e8b96eab718ef664e3c/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d5efa9f040d2638318f9e8b96eab718ef664e3c/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ffold.rs?ref=6d5efa9f040d2638318f9e8b96eab718ef664e3c", "patch": "@@ -634,6 +634,42 @@ impl<'tcx> TyCtxt<'tcx> {\n         .0\n     }\n \n+    pub fn shift_bound_var_indices<T>(self, bound_vars: usize, value: T) -> T\n+    where\n+        T: TypeFoldable<'tcx>,\n+    {\n+        self.replace_escaping_bound_vars(\n+            value,\n+            |r| {\n+                self.mk_region(ty::ReLateBound(\n+                    ty::INNERMOST,\n+                    ty::BoundRegion {\n+                        var: ty::BoundVar::from_usize(r.var.as_usize() + bound_vars),\n+                        kind: r.kind,\n+                    },\n+                ))\n+            },\n+            |t| {\n+                self.mk_ty(ty::Bound(\n+                    ty::INNERMOST,\n+                    ty::BoundTy {\n+                        var: ty::BoundVar::from_usize(t.var.as_usize() + bound_vars),\n+                        kind: t.kind,\n+                    },\n+                ))\n+            },\n+            |c, ty| {\n+                self.mk_const(ty::Const {\n+                    val: ty::ConstKind::Bound(\n+                        ty::INNERMOST,\n+                        ty::BoundVar::from_usize(c.as_usize() + bound_vars),\n+                    ),\n+                    ty,\n+                })\n+            },\n+        )\n+    }\n+\n     /// Returns a set of all late-bound regions that are constrained\n     /// by `value`, meaning that if we instantiate those LBR with\n     /// variables and equate `value` with something else, those\n@@ -695,16 +731,21 @@ impl<'tcx> TyCtxt<'tcx> {\n         T: TypeFoldable<'tcx>,\n     {\n         let mut counter = 0;\n-        Binder::bind(\n-            self.replace_late_bound_regions(sig, |_| {\n-                let br = ty::BoundRegion { kind: ty::BrAnon(counter) };\n+        let inner = self\n+            .replace_late_bound_regions(sig, |_| {\n+                let br = ty::BoundRegion {\n+                    var: ty::BoundVar::from_u32(counter),\n+                    kind: ty::BrAnon(counter),\n+                };\n                 let r = self.mk_region(ty::ReLateBound(ty::INNERMOST, br));\n                 counter += 1;\n                 r\n             })\n-            .0,\n-            self,\n-        )\n+            .0;\n+        let bound_vars = self.mk_bound_variable_kinds(\n+            (0..counter).map(|i| ty::BoundVariableKind::Region(ty::BrAnon(i))),\n+        );\n+        Binder::bind_with_vars(inner, bound_vars)\n     }\n }\n \n@@ -777,27 +818,105 @@ impl<'tcx> TypeVisitor<'tcx> for BoundVarsCollector<'tcx> {\n     }\n \n     fn visit_region(&mut self, r: ty::Region<'tcx>) -> ControlFlow<Self::BreakTy> {\n-        use std::collections::btree_map::Entry;\n         match r {\n-            ty::ReLateBound(index, br) if *index == self.binder_index => match br.kind {\n-                ty::BrNamed(_def_id, _name) => {\n-                    // FIXME\n-                }\n+            ty::ReLateBound(index, _br) if *index == self.binder_index => {\n+                bug!(\"{:?} {:?}\", index, _br)\n+            }\n \n-                ty::BrAnon(var) => match self.vars.entry(var) {\n-                    Entry::Vacant(entry) => {\n-                        entry.insert(ty::BoundVariableKind::Region(br.kind));\n+            _ => (),\n+        };\n+\n+        r.super_visit_with(self)\n+    }\n+}\n+\n+pub struct ValidateBoundVars<'tcx> {\n+    bound_vars: &'tcx ty::List<ty::BoundVariableKind>,\n+    binder_index: ty::DebruijnIndex,\n+    // We may encounter the same variable at different levels of binding, so\n+    // this can't just be `Ty`\n+    visited: SsoHashSet<(ty::DebruijnIndex, Ty<'tcx>)>,\n+}\n+\n+impl<'tcx> ValidateBoundVars<'tcx> {\n+    pub fn new(bound_vars: &'tcx ty::List<ty::BoundVariableKind>) -> Self {\n+        ValidateBoundVars {\n+            bound_vars,\n+            binder_index: ty::INNERMOST,\n+            visited: SsoHashSet::default(),\n+        }\n+    }\n+}\n+\n+impl<'tcx> TypeVisitor<'tcx> for ValidateBoundVars<'tcx> {\n+    type BreakTy = ();\n+\n+    fn visit_binder<T: TypeFoldable<'tcx>>(\n+        &mut self,\n+        t: &Binder<'tcx, T>,\n+    ) -> ControlFlow<Self::BreakTy> {\n+        self.binder_index.shift_in(1);\n+        let result = t.super_visit_with(self);\n+        self.binder_index.shift_out(1);\n+        result\n+    }\n+\n+    fn visit_ty(&mut self, t: Ty<'tcx>) -> ControlFlow<Self::BreakTy> {\n+        if t.outer_exclusive_binder < self.binder_index\n+            || !self.visited.insert((self.binder_index, t))\n+        {\n+            return ControlFlow::BREAK;\n+        }\n+        match *t.kind() {\n+            ty::Bound(debruijn, bound_ty) if debruijn == self.binder_index => {\n+                if self.bound_vars.len() <= bound_ty.var.as_usize() {\n+                    panic!(\"Not enough bound vars: {:?} not found in {:?}\", t, self.bound_vars);\n+                }\n+                let list_var = self.bound_vars[bound_ty.var.as_usize()];\n+                match list_var {\n+                    ty::BoundVariableKind::Ty(kind) => {\n+                        if kind != bound_ty.kind {\n+                            panic!(\n+                                \"Mismatched type kinds: {:?} doesn't var in list {:?}\",\n+                                bound_ty.kind, list_var\n+                            );\n+                        }\n                     }\n-                    Entry::Occupied(entry) => match entry.get() {\n-                        ty::BoundVariableKind::Region(_) => {}\n-                        _ => bug!(\"Conflicting bound vars\"),\n-                    },\n-                },\n+                    _ => panic!(\n+                        \"Mismatched bound variable kinds! Expected type, found {:?}\",\n+                        list_var\n+                    ),\n+                }\n+            }\n+\n+            _ => (),\n+        };\n+\n+        t.super_visit_with(self)\n+    }\n \n-                ty::BrEnv => {\n-                    // FIXME\n+    fn visit_region(&mut self, r: ty::Region<'tcx>) -> ControlFlow<Self::BreakTy> {\n+        match r {\n+            ty::ReLateBound(index, br) if *index == self.binder_index => {\n+                if self.bound_vars.len() <= br.var.as_usize() {\n+                    panic!(\"Not enough bound vars: {:?} not found in {:?}\", *br, self.bound_vars);\n                 }\n-            },\n+                let list_var = self.bound_vars[br.var.as_usize()];\n+                match list_var {\n+                    ty::BoundVariableKind::Region(kind) => {\n+                        if kind != br.kind {\n+                            panic!(\n+                                \"Mismatched region kinds: {:?} doesn't match var ({:?}) in list ({:?})\",\n+                                br.kind, list_var, self.bound_vars\n+                            );\n+                        }\n+                    }\n+                    _ => panic!(\n+                        \"Mismatched bound variable kinds! Expected region, found {:?}\",\n+                        list_var\n+                    ),\n+                }\n+            }\n \n             _ => (),\n         };"}, {"sha": "e7bbdc3ccebdf4adfd4e2c3554488109a5a0b59e", "filename": "compiler/rustc_middle/src/ty/layout.rs", "status": "modified", "additions": 37, "deletions": 15, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/6d5efa9f040d2638318f9e8b96eab718ef664e3c/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d5efa9f040d2638318f9e8b96eab718ef664e3c/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Flayout.rs?ref=6d5efa9f040d2638318f9e8b96eab718ef664e3c", "patch": "@@ -1,3 +1,4 @@\n+// ignore-tidy-filelength\n use crate::ich::StableHashingContext;\n use crate::middle::codegen_fn_attrs::CodegenFnAttrFlags;\n use crate::mir::{GeneratorLayout, GeneratorSavedLocal};\n@@ -2481,21 +2482,42 @@ impl<'tcx> ty::Instance<'tcx> {\n             ty::Closure(def_id, substs) => {\n                 let sig = substs.as_closure().sig();\n \n-                let env_ty = tcx.closure_env_ty(def_id, substs).unwrap();\n-                sig.map_bound(|sig| {\n+                let bound_vars = tcx.mk_bound_variable_kinds(\n+                    sig.bound_vars()\n+                        .iter()\n+                        .chain(iter::once(ty::BoundVariableKind::Region(ty::BrEnv))),\n+                );\n+                let br = ty::BoundRegion {\n+                    var: ty::BoundVar::from_usize(bound_vars.len() - 1),\n+                    kind: ty::BoundRegionKind::BrEnv,\n+                };\n+                let env_region = ty::ReLateBound(ty::INNERMOST, br);\n+                let env_ty = tcx.closure_env_ty(def_id, substs, env_region).unwrap();\n+\n+                let sig = sig.skip_binder();\n+                ty::Binder::bind_with_vars(\n                     tcx.mk_fn_sig(\n-                        iter::once(env_ty.skip_binder()).chain(sig.inputs().iter().cloned()),\n+                        iter::once(env_ty).chain(sig.inputs().iter().cloned()),\n                         sig.output(),\n                         sig.c_variadic,\n                         sig.unsafety,\n                         sig.abi,\n-                    )\n-                })\n+                    ),\n+                    bound_vars,\n+                )\n             }\n             ty::Generator(_, substs, _) => {\n                 let sig = substs.as_generator().poly_sig();\n \n-                let br = ty::BoundRegion { kind: ty::BrEnv };\n+                let bound_vars = tcx.mk_bound_variable_kinds(\n+                    sig.bound_vars()\n+                        .iter()\n+                        .chain(iter::once(ty::BoundVariableKind::Region(ty::BrEnv))),\n+                );\n+                let br = ty::BoundRegion {\n+                    var: ty::BoundVar::from_usize(bound_vars.len() - 1),\n+                    kind: ty::BoundRegionKind::BrEnv,\n+                };\n                 let env_region = ty::ReLateBound(ty::INNERMOST, br);\n                 let env_ty = tcx.mk_mut_ref(tcx.mk_region(env_region), ty);\n \n@@ -2504,21 +2526,21 @@ impl<'tcx> ty::Instance<'tcx> {\n                 let pin_substs = tcx.intern_substs(&[env_ty.into()]);\n                 let env_ty = tcx.mk_adt(pin_adt_ref, pin_substs);\n \n-                sig.map_bound(|sig| {\n-                    let state_did = tcx.require_lang_item(LangItem::GeneratorState, None);\n-                    let state_adt_ref = tcx.adt_def(state_did);\n-                    let state_substs =\n-                        tcx.intern_substs(&[sig.yield_ty.into(), sig.return_ty.into()]);\n-                    let ret_ty = tcx.mk_adt(state_adt_ref, state_substs);\n-\n+                let sig = sig.skip_binder();\n+                let state_did = tcx.require_lang_item(LangItem::GeneratorState, None);\n+                let state_adt_ref = tcx.adt_def(state_did);\n+                let state_substs = tcx.intern_substs(&[sig.yield_ty.into(), sig.return_ty.into()]);\n+                let ret_ty = tcx.mk_adt(state_adt_ref, state_substs);\n+                ty::Binder::bind_with_vars(\n                     tcx.mk_fn_sig(\n                         [env_ty, sig.resume_ty].iter(),\n                         &ret_ty,\n                         false,\n                         hir::Unsafety::Normal,\n                         rustc_target::spec::abi::Abi::Rust,\n-                    )\n-                })\n+                    ),\n+                    bound_vars,\n+                )\n             }\n             _ => bug!(\"unexpected type {:?} in Instance::fn_sig\", ty),\n         }"}, {"sha": "6574c9382604b1ec894007c6a265f4081bcf0c56", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 27, "deletions": 4, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/6d5efa9f040d2638318f9e8b96eab718ef664e3c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d5efa9f040d2638318f9e8b96eab718ef664e3c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=6d5efa9f040d2638318f9e8b96eab718ef664e3c", "patch": "@@ -543,10 +543,33 @@ impl<'tcx> Predicate<'tcx> {\n         // substitution code expects equal binding levels in the values\n         // from the substitution and the value being substituted into, and\n         // this trick achieves that).\n-        let substs = trait_ref.skip_binder().substs;\n-        let pred = self.kind().skip_binder();\n-        let new = pred.subst(tcx, substs);\n-        tcx.reuse_or_mk_predicate(self, ty::Binder::bind(new, tcx))\n+\n+        // Working through the second example:\n+        // trait_ref: for<'x> T: Foo1<'^0.0>; substs: [T, '^0.0]\n+        // predicate: for<'b> Self: Bar1<'a, '^0.0>; substs: [Self, 'a, '^0.0]\n+        // We want to end up with:\n+        //     for<'x, 'b> T: Bar1<'^0.0, '^0.1>\n+        // To do this:\n+        // 1) We must shift all bound vars in predicate by the length\n+        //    of trait ref's bound vars. So, we would end up with predicate like\n+        //    Self: Bar1<'a, '^0.1>\n+        // 2) We can then apply the trait substs to this, ending up with\n+        //    T: Bar1<'^0.0, '^0.1>\n+        // 3) Finally, to create the final bound vars, we concatenate the bound\n+        //    vars of the trait ref with those of the predicate:\n+        //    ['x, 'b]\n+        let bound_pred = self.kind();\n+        let pred_bound_vars = bound_pred.bound_vars();\n+        let trait_bound_vars = trait_ref.bound_vars();\n+        // 1) Self: Bar1<'a, '^0.0> -> Self: Bar1<'a, '^0.1>\n+        let shifted_pred =\n+            tcx.shift_bound_var_indices(trait_bound_vars.len(), bound_pred.skip_binder());\n+        // 2) Self: Bar1<'a, '^0.1> -> T: Bar1<'^0.0, '^0.1>\n+        let new = shifted_pred.subst(tcx, trait_ref.skip_binder().substs);\n+        // 3) ['x] + ['b] -> ['x, 'b]\n+        let bound_vars =\n+            tcx.mk_bound_variable_kinds(trait_bound_vars.iter().chain(pred_bound_vars));\n+        tcx.reuse_or_mk_predicate(self, ty::Binder::bind_with_vars(new, bound_vars))\n     }\n }\n "}, {"sha": "b8f39fce21d656fe4bff1eeed78124944426692c", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6d5efa9f040d2638318f9e8b96eab718ef664e3c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d5efa9f040d2638318f9e8b96eab718ef664e3c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=6d5efa9f040d2638318f9e8b96eab718ef664e3c", "patch": "@@ -1636,7 +1636,7 @@ impl<F: fmt::Write> PrettyPrinter<'tcx> for FmtPrinter<'_, 'tcx, F> {\n                 data.name != kw::Empty && data.name != kw::UnderscoreLifetime\n             }\n \n-            ty::ReLateBound(_, ty::BoundRegion { kind: br })\n+            ty::ReLateBound(_, ty::BoundRegion { kind: br, .. })\n             | ty::ReFree(ty::FreeRegion { bound_region: br, .. })\n             | ty::RePlaceholder(ty::Placeholder { name: br, .. }) => {\n                 if let ty::BrNamed(_, name) = br {\n@@ -1715,7 +1715,7 @@ impl<F: fmt::Write> FmtPrinter<'_, '_, F> {\n                     return Ok(self);\n                 }\n             }\n-            ty::ReLateBound(_, ty::BoundRegion { kind: br })\n+            ty::ReLateBound(_, ty::BoundRegion { kind: br, .. })\n             | ty::ReFree(ty::FreeRegion { bound_region: br, .. })\n             | ty::RePlaceholder(ty::Placeholder { name: br, .. }) => {\n                 if let ty::BrNamed(_, name) = br {\n@@ -1821,7 +1821,8 @@ impl<F: fmt::Write> FmtPrinter<'_, 'tcx, F> {\n                     ty::BrNamed(DefId::local(CRATE_DEF_INDEX), name)\n                 }\n             };\n-            self.tcx.mk_region(ty::ReLateBound(ty::INNERMOST, ty::BoundRegion { kind }))\n+            self.tcx\n+                .mk_region(ty::ReLateBound(ty::INNERMOST, ty::BoundRegion { var: br.var, kind }))\n         });\n         start_or_continue(&mut self, \"\", \"> \")?;\n \n@@ -1865,7 +1866,7 @@ impl<F: fmt::Write> FmtPrinter<'_, 'tcx, F> {\n         struct LateBoundRegionNameCollector<'a>(&'a mut FxHashSet<Symbol>);\n         impl<'tcx> ty::fold::TypeVisitor<'tcx> for LateBoundRegionNameCollector<'_> {\n             fn visit_region(&mut self, r: ty::Region<'tcx>) -> ControlFlow<Self::BreakTy> {\n-                if let ty::ReLateBound(_, ty::BoundRegion { kind: ty::BrNamed(_, name) }) = *r {\n+                if let ty::ReLateBound(_, ty::BoundRegion { kind: ty::BrNamed(_, name), .. }) = *r {\n                     self.0.insert(name);\n                 }\n                 r.super_visit_with(self)"}, {"sha": "e352d0bc756976d039daa460450ac0e10a6aa19c", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 33, "deletions": 34, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/6d5efa9f040d2638318f9e8b96eab718ef664e3c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d5efa9f040d2638318f9e8b96eab718ef664e3c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=6d5efa9f040d2638318f9e8b96eab718ef664e3c", "patch": "@@ -6,6 +6,7 @@ use self::TyKind::*;\n \n use crate::infer::canonical::Canonical;\n use crate::ty::fold::BoundVarsCollector;\n+use crate::ty::fold::ValidateBoundVars;\n use crate::ty::subst::{GenericArg, InternalSubsts, Subst, SubstsRef};\n use crate::ty::InferTy::{self, *};\n use crate::ty::{\n@@ -63,22 +64,10 @@ pub enum BoundRegionKind {\n #[derive(Copy, Clone, PartialEq, Eq, Hash, TyEncodable, TyDecodable, Debug, PartialOrd, Ord)]\n #[derive(HashStable)]\n pub struct BoundRegion {\n+    pub var: BoundVar,\n     pub kind: BoundRegionKind,\n }\n \n-impl BoundRegion {\n-    /// When canonicalizing, we replace unbound inference variables and free\n-    /// regions with anonymous late bound regions. This method asserts that\n-    /// we have an anonymous late bound region, which hence may refer to\n-    /// a canonical variable.\n-    pub fn assert_bound_var(&self) -> BoundVar {\n-        match self.kind {\n-            BoundRegionKind::BrAnon(var) => BoundVar::from_u32(var),\n-            _ => bug!(\"bound region is not anonymous\"),\n-        }\n-    }\n-}\n-\n impl BoundRegionKind {\n     pub fn is_named(&self) -> bool {\n         match *self {\n@@ -987,13 +976,17 @@ where\n         value.visit_with(&mut collector);\n         Binder(value, collector.into_vars(tcx))\n     }\n-}\n \n-impl<'tcx, T> Binder<'tcx, T> {\n     pub fn bind_with_vars(value: T, vars: &'tcx List<BoundVariableKind>) -> Binder<'tcx, T> {\n+        if cfg!(debug_assertions) {\n+            let mut validator = ValidateBoundVars::new(vars);\n+            value.visit_with(&mut validator);\n+        }\n         Binder(value, vars)\n     }\n+}\n \n+impl<'tcx, T> Binder<'tcx, T> {\n     /// Skips the binder and returns the \"bound\" value. This is a\n     /// risky thing to do because it's easy to get confused about\n     /// De Bruijn indices and the like. It is usually better to\n@@ -1022,18 +1015,31 @@ impl<'tcx, T> Binder<'tcx, T> {\n         Binder(&self.0, self.1)\n     }\n \n-    pub fn map_bound_ref<F, U>(&self, f: F) -> Binder<'tcx, U>\n+    pub fn map_bound_ref_unchecked<F, U>(&self, f: F) -> Binder<'tcx, U>\n+    where\n+        F: FnOnce(&T) -> U,\n+    {\n+        let value = f(&self.0);\n+        Binder(value, self.1)\n+    }\n+\n+    pub fn map_bound_ref<F, U: TypeFoldable<'tcx>>(&self, f: F) -> Binder<'tcx, U>\n     where\n         F: FnOnce(&T) -> U,\n     {\n         self.as_ref().map_bound(f)\n     }\n \n-    pub fn map_bound<F, U>(self, f: F) -> Binder<'tcx, U>\n+    pub fn map_bound<F, U: TypeFoldable<'tcx>>(self, f: F) -> Binder<'tcx, U>\n     where\n         F: FnOnce(T) -> U,\n     {\n-        Binder(f(self.0), self.1)\n+        let value = f(self.0);\n+        if cfg!(debug_assertions) {\n+            let mut validator = ValidateBoundVars::new(self.1);\n+            value.visit_with(&mut validator);\n+        }\n+        Binder(value, self.1)\n     }\n \n     /// Wraps a `value` in a binder, using the same bound variables as the\n@@ -1045,7 +1051,14 @@ impl<'tcx, T> Binder<'tcx, T> {\n     /// don't actually track bound vars. However, semantically, it is different\n     /// because bound vars aren't allowed to change here, whereas they are\n     /// in `bind`. This may be (debug) asserted in the future.\n-    pub fn rebind<U>(&self, value: U) -> Binder<'tcx, U> {\n+    pub fn rebind<U>(&self, value: U) -> Binder<'tcx, U>\n+    where\n+        U: TypeFoldable<'tcx>,\n+    {\n+        if cfg!(debug_assertions) {\n+            let mut validator = ValidateBoundVars::new(self.bound_vars());\n+            value.visit_with(&mut validator);\n+        }\n         Binder(value, self.1)\n     }\n \n@@ -1066,20 +1079,6 @@ impl<'tcx, T> Binder<'tcx, T> {\n         if self.0.has_escaping_bound_vars() { None } else { Some(self.skip_binder()) }\n     }\n \n-    /// Given two things that have the same binder level,\n-    /// and an operation that wraps on their contents, executes the operation\n-    /// and then wraps its result.\n-    ///\n-    /// `f` should consider bound regions at depth 1 to be free, and\n-    /// anything it produces with bound regions at depth 1 will be\n-    /// bound in the resulting return value.\n-    pub fn fuse<U, F, R>(self, u: Binder<'tcx, U>, f: F) -> Binder<'tcx, R>\n-    where\n-        F: FnOnce(T, U) -> R,\n-    {\n-        Binder(f(self.0, u.0), self.1)\n-    }\n-\n     /// Splits the contents into two things that share the same binder\n     /// level as the original, returning two distinct binders.\n     ///\n@@ -1204,7 +1203,7 @@ pub type PolyFnSig<'tcx> = Binder<'tcx, FnSig<'tcx>>;\n impl<'tcx> PolyFnSig<'tcx> {\n     #[inline]\n     pub fn inputs(&self) -> Binder<'tcx, &'tcx [Ty<'tcx>]> {\n-        self.map_bound_ref(|fn_sig| fn_sig.inputs())\n+        self.map_bound_ref_unchecked(|fn_sig| fn_sig.inputs())\n     }\n     #[inline]\n     pub fn input(&self, index: usize) -> ty::Binder<'tcx, Ty<'tcx>> {"}, {"sha": "b211ac2a79fdc453686947e3e261eafc4937b31a", "filename": "compiler/rustc_middle/src/ty/util.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/6d5efa9f040d2638318f9e8b96eab718ef664e3c/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d5efa9f040d2638318f9e8b96eab718ef664e3c/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Futil.rs?ref=6d5efa9f040d2638318f9e8b96eab718ef664e3c", "patch": "@@ -499,18 +499,18 @@ impl<'tcx> TyCtxt<'tcx> {\n         self,\n         closure_def_id: DefId,\n         closure_substs: SubstsRef<'tcx>,\n-    ) -> Option<ty::Binder<'tcx, Ty<'tcx>>> {\n+        env_region: ty::RegionKind,\n+    ) -> Option<Ty<'tcx>> {\n         let closure_ty = self.mk_closure(closure_def_id, closure_substs);\n-        let br = ty::BoundRegion { kind: ty::BrEnv };\n-        let env_region = ty::ReLateBound(ty::INNERMOST, br);\n         let closure_kind_ty = closure_substs.as_closure().kind_ty();\n         let closure_kind = closure_kind_ty.to_opt_closure_kind()?;\n+        debug_assert!(!closure_ty.has_escaping_bound_vars());\n         let env_ty = match closure_kind {\n             ty::ClosureKind::Fn => self.mk_imm_ref(self.mk_region(env_region), closure_ty),\n             ty::ClosureKind::FnMut => self.mk_mut_ref(self.mk_region(env_region), closure_ty),\n             ty::ClosureKind::FnOnce => closure_ty,\n         };\n-        Some(ty::Binder::bind(env_ty, self))\n+        Some(env_ty)\n     }\n \n     /// Returns `true` if the node pointed to by `def_id` is a `static` item."}, {"sha": "6ea0ba0a8e1ba517de570897e6751c083259c8ae", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6d5efa9f040d2638318f9e8b96eab718ef664e3c/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d5efa9f040d2638318f9e8b96eab718ef664e3c/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fmod.rs?ref=6d5efa9f040d2638318f9e8b96eab718ef664e3c", "patch": "@@ -502,7 +502,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         // lifetimes without names with the value `'0`.\n         match ty.kind() {\n             ty::Ref(\n-                ty::RegionKind::ReLateBound(_, ty::BoundRegion { kind: br })\n+                ty::RegionKind::ReLateBound(_, ty::BoundRegion { kind: br, .. })\n                 | ty::RegionKind::RePlaceholder(ty::PlaceholderRegion { name: br, .. }),\n                 _,\n                 _,\n@@ -523,7 +523,7 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n         let region = match ty.kind() {\n             ty::Ref(region, _, _) => {\n                 match region {\n-                    ty::RegionKind::ReLateBound(_, ty::BoundRegion { kind: br })\n+                    ty::RegionKind::ReLateBound(_, ty::BoundRegion { kind: br, .. })\n                     | ty::RegionKind::RePlaceholder(ty::PlaceholderRegion { name: br, .. }) => {\n                         printer.region_highlight_mode.highlighting_bound_region(*br, counter)\n                     }"}, {"sha": "c2ac1e289ce4e1d1a0451600f3bd9434a73b9afb", "filename": "compiler/rustc_mir/src/borrow_check/universal_regions.rs", "status": "modified", "additions": 27, "deletions": 13, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/6d5efa9f040d2638318f9e8b96eab718ef664e3c/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Funiversal_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d5efa9f040d2638318f9e8b96eab718ef664e3c/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Funiversal_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Funiversal_regions.rs?ref=6d5efa9f040d2638318f9e8b96eab718ef664e3c", "patch": "@@ -596,24 +596,38 @@ impl<'cx, 'tcx> UniversalRegionsBuilder<'cx, 'tcx> {\n                 assert_eq!(self.mir_def.did.to_def_id(), def_id);\n                 let closure_sig = substs.as_closure().sig();\n                 let inputs_and_output = closure_sig.inputs_and_output();\n-                let closure_ty = tcx.closure_env_ty(def_id, substs).unwrap();\n-                ty::Binder::fuse(closure_ty, inputs_and_output, |closure_ty, inputs_and_output| {\n-                    // The \"inputs\" of the closure in the\n-                    // signature appear as a tuple.  The MIR side\n-                    // flattens this tuple.\n-                    let (&output, tuplized_inputs) = inputs_and_output.split_last().unwrap();\n-                    assert_eq!(tuplized_inputs.len(), 1, \"multiple closure inputs\");\n-                    let inputs = match tuplized_inputs[0].kind() {\n-                        ty::Tuple(inputs) => inputs,\n-                        _ => bug!(\"closure inputs not a tuple: {:?}\", tuplized_inputs[0]),\n-                    };\n+                let bound_vars = tcx.mk_bound_variable_kinds(\n+                    inputs_and_output\n+                        .bound_vars()\n+                        .iter()\n+                        .chain(iter::once(ty::BoundVariableKind::Region(ty::BrEnv))),\n+                );\n+                let br = ty::BoundRegion {\n+                    var: ty::BoundVar::from_usize(bound_vars.len() - 1),\n+                    kind: ty::BrEnv,\n+                };\n+                let env_region = ty::ReLateBound(ty::INNERMOST, br);\n+                let closure_ty = tcx.closure_env_ty(def_id, substs, env_region).unwrap();\n+\n+                // The \"inputs\" of the closure in the\n+                // signature appear as a tuple.  The MIR side\n+                // flattens this tuple.\n+                let (&output, tuplized_inputs) =\n+                    inputs_and_output.skip_binder().split_last().unwrap();\n+                assert_eq!(tuplized_inputs.len(), 1, \"multiple closure inputs\");\n+                let inputs = match tuplized_inputs[0].kind() {\n+                    ty::Tuple(inputs) => inputs,\n+                    _ => bug!(\"closure inputs not a tuple: {:?}\", tuplized_inputs[0]),\n+                };\n \n+                ty::Binder::bind_with_vars(\n                     tcx.mk_type_list(\n                         iter::once(closure_ty)\n                             .chain(inputs.iter().map(|k| k.expect_ty()))\n                             .chain(iter::once(output)),\n-                    )\n-                })\n+                    ),\n+                    bound_vars,\n+                )\n             }\n \n             DefiningTy::Generator(def_id, substs, movability) => {"}, {"sha": "c90f94c6d63fbc3e547dc952afc0bfea2bdb3b1d", "filename": "compiler/rustc_mir_build/src/build/mod.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/6d5efa9f040d2638318f9e8b96eab718ef664e3c/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d5efa9f040d2638318f9e8b96eab718ef664e3c/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmod.rs?ref=6d5efa9f040d2638318f9e8b96eab718ef664e3c", "patch": "@@ -252,8 +252,13 @@ fn liberated_closure_env_ty(\n         _ => bug!(\"closure expr does not have closure type: {:?}\", closure_ty),\n     };\n \n-    let closure_env_ty = tcx.closure_env_ty(closure_def_id, closure_substs).unwrap();\n-    tcx.erase_late_bound_regions(closure_env_ty)\n+    let bound_vars =\n+        tcx.mk_bound_variable_kinds(std::iter::once(ty::BoundVariableKind::Region(ty::BrEnv)));\n+    let br =\n+        ty::BoundRegion { var: ty::BoundVar::from_usize(bound_vars.len() - 1), kind: ty::BrEnv };\n+    let env_region = ty::ReLateBound(ty::INNERMOST, br);\n+    let closure_env_ty = tcx.closure_env_ty(closure_def_id, closure_substs, env_region).unwrap();\n+    tcx.erase_late_bound_regions(ty::Binder::bind_with_vars(closure_env_ty, bound_vars))\n }\n \n #[derive(Debug, PartialEq, Eq)]"}, {"sha": "25acbd478bf56ab728e90c15d819c8de21a092d7", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6d5efa9f040d2638318f9e8b96eab718ef664e3c/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d5efa9f040d2638318f9e8b96eab718ef664e3c/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=6d5efa9f040d2638318f9e8b96eab718ef664e3c", "patch": "@@ -34,6 +34,7 @@ use tracing::debug;\n \n mod diagnostics;\n crate mod lifetimes;\n+crate mod supertraits;\n \n type Res = def::Res<NodeId>;\n "}, {"sha": "79d81ef047e723b3f342c35a8bca4b0567d44c9e", "filename": "compiler/rustc_resolve/src/late/lifetimes.rs", "status": "modified", "additions": 574, "deletions": 87, "changes": 661, "blob_url": "https://github.com/rust-lang/rust/blob/6d5efa9f040d2638318f9e8b96eab718ef664e3c/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d5efa9f040d2638318f9e8b96eab718ef664e3c/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Flifetimes.rs?ref=6d5efa9f040d2638318f9e8b96eab718ef664e3c", "patch": "@@ -30,7 +30,7 @@ use std::cell::Cell;\n use std::fmt;\n use std::mem::take;\n \n-use tracing::debug;\n+use tracing::{debug, span, Level};\n \n // This counts the no of times a lifetime is used\n #[derive(Clone, Copy, Debug)]\n@@ -44,7 +44,7 @@ trait RegionExt {\n \n     fn late(index: u32, hir_map: &Map<'_>, param: &GenericParam<'_>) -> (ParamName, Region);\n \n-    fn late_anon(named_late_bound_vars: u32, anon_index: &Cell<u32>) -> Region;\n+    fn late_anon(named_late_bound_vars: u32, index: &Cell<u32>) -> Region;\n \n     fn id(&self) -> Option<DefId>;\n \n@@ -150,6 +150,8 @@ struct NamedRegionMap {\n     // be late-bound if (a) it does NOT appear in a where-clause and\n     // (b) it DOES appear in the arguments.\n     late_bound: HirIdSet,\n+\n+    late_bound_vars: HirIdMap<Vec<ty::BoundVariableKind>>,\n }\n \n crate struct LifetimeContext<'a, 'tcx> {\n@@ -164,13 +166,15 @@ crate struct LifetimeContext<'a, 'tcx> {\n     /// correct when representing these constraints, we should only introduce one\n     /// scope. However, we want to support both locations for the quantifier and\n     /// during lifetime resolution we want precise information (so we can't\n-    /// desugar in an earlier phase).\n+    /// desugar in an earlier phase). Moreso, an error here doesn't cause a bail\n+    /// from type checking, so we need to be extra careful that we don't lose\n+    /// any bound var information.\n     ///\n     /// So, if we encounter a quantifier at the outer scope, we set\n     /// `trait_ref_hack` to `true` (and introduce a scope), and then if we encounter\n     /// a quantifier at the inner scope, we error. If `trait_ref_hack` is `false`,\n     /// then we introduce the scope at the inner quantifier.\n-    trait_ref_hack: bool,\n+    trait_ref_hack: Option<(Vec<ty::BoundVariableKind>, u32)>,\n \n     /// Used to disallow the use of in-band lifetimes in `fn` or `Fn` syntax.\n     is_in_fn_syntax: bool,\n@@ -228,8 +232,19 @@ enum Scope<'a> {\n         /// of the resulting opaque type.\n         opaque_type_parent: bool,\n \n+        /// We need to keep track of the number of named late bound vars, since\n+        /// we may have elided lifetimes that have an index starting *after*\n+        /// these.\n         named_late_bound_vars: u32,\n \n+        from_poly_trait_ref: bool,\n+\n+        /// The late bound vars for a given item are stored by `HirId` to be\n+        /// queried later. However, if we enter an elision scope, we have to\n+        /// later append the elided bound vars to the list and need to know what\n+        /// to append to.\n+        hir_id: hir::HirId,\n+\n         s: ScopeRef<'a>,\n     },\n \n@@ -257,6 +272,51 @@ enum Scope<'a> {\n         s: ScopeRef<'a>,\n     },\n \n+    /// This is a particularly interesting consequence of how we handle poly\n+    /// trait refs. See `trait_ref_hack` for additional info. This bit is\n+    /// important w.r.t. querying late-bound vars.\n+    ///\n+    /// To completely understand why this is necessary, first it's important to\n+    /// realize that `T: for<'a> U + for<'a, 'b> V` is actually two separate\n+    /// trait refs: `T: for<'a> U` and `T: for<'b> V` and as such, the late\n+    /// bound vars on each needs to be tracked separately. Also, in this case,\n+    /// are *three* relevant `HirId`s: one for the entire bound and one\n+    /// for each separate one.\n+    ///\n+    /// Next, imagine three different poly trait refs:\n+    ///   1) `for<'a, 'b> T: U<'a, 'b>`\n+    ///   2) `T: for<'a, 'b> U<'a, 'b>`\n+    ///   3) `for<'a> T: for<'b> U<'a, 'b>`\n+    ///\n+    /// First, note that the third example is semantically invalid and an error,\n+    /// but we *must* handle it as valid, since type checking isn't bailed out\n+    /// of. Other than that, if ask for bound vars for each, we expect\n+    /// `['a, 'b]`. If we *didn't* allow binders before `T`, then we would\n+    /// always introduce a binder scope at the inner trait ref. This is great,\n+    /// becauase later on during type-checking, we will ask \"what are the late\n+    /// bound vars on this trait ref\". However, because we allow bound vars on\n+    /// the bound itself, we have to have some way of keeping track of the fact\n+    /// that we actually want to store the late bound vars as being associated\n+    /// with the trait ref; this is that.\n+    ///\n+    /// One alternative way to handle this would be to just introduce a new\n+    /// `Binder` scope, but that's semantically a bit different, since bound\n+    /// vars from both `for<...>`s *do* share the same binder level.\n+    TraitRefHackInner {\n+        hir_id: hir::HirId,\n+        named_late_bound_vars: u32,\n+        s: ScopeRef<'a>,\n+    },\n+\n+    /// When we have nested trait refs, we concanetate late bound vars for inner\n+    /// trait refs from outer ones. But we also need to include any HRTB\n+    /// lifetimes encountered when identifying the trait that an associated type\n+    /// is declared on.\n+    Supertrait {\n+        lifetimes: Vec<ty::BoundVariableKind>,\n+        s: ScopeRef<'a>,\n+    },\n+\n     Root,\n }\n \n@@ -272,6 +332,8 @@ impl<'a> fmt::Debug for TruncatedScopeDebug<'a> {\n                 track_lifetime_uses,\n                 opaque_type_parent,\n                 named_late_bound_vars,\n+                from_poly_trait_ref,\n+                hir_id,\n                 s: _,\n             } => f\n                 .debug_struct(\"Binder\")\n@@ -280,6 +342,8 @@ impl<'a> fmt::Debug for TruncatedScopeDebug<'a> {\n                 .field(\"track_lifetime_uses\", track_lifetime_uses)\n                 .field(\"opaque_type_parent\", opaque_type_parent)\n                 .field(\"named_late_bound_vars\", named_late_bound_vars)\n+                .field(\"from_poly_trait_ref\", from_poly_trait_ref)\n+                .field(\"hir_id\", hir_id)\n                 .field(\"s\", &\"..\")\n                 .finish(),\n             Scope::Body { id, s: _ } => {\n@@ -293,6 +357,17 @@ impl<'a> fmt::Debug for TruncatedScopeDebug<'a> {\n                 .field(\"lifetime\", lifetime)\n                 .field(\"s\", &\"..\")\n                 .finish(),\n+            Scope::TraitRefHackInner { hir_id, named_late_bound_vars, s: _ } => f\n+                .debug_struct(\"TraitRefHackInner\")\n+                .field(\"hir_id\", hir_id)\n+                .field(\"named_late_bound_vars\", named_late_bound_vars)\n+                .field(\"s\", &\"..\")\n+                .finish(),\n+            Scope::Supertrait { lifetimes, s: _ } => f\n+                .debug_struct(\"Supertrait\")\n+                .field(\"lifetimes\", lifetimes)\n+                .field(\"s\", &\"..\")\n+                .finish(),\n             Scope::Root => f.debug_struct(\"Root\").finish(),\n         }\n     }\n@@ -342,6 +417,7 @@ pub fn provide(providers: &mut ty::query::Providers) {\n                 _ => None,\n             }\n         },\n+        late_bound_vars_map: |tcx, id| resolve_lifetimes_for(tcx, id).late_bound_vars.get(&id),\n \n         ..*providers\n     };\n@@ -399,13 +475,16 @@ fn do_resolve(\n     trait_definition_only: bool,\n ) -> ResolveLifetimes {\n     let item = tcx.hir().expect_item(tcx.hir().local_def_id_to_hir_id(local_def_id));\n-    let mut named_region_map =\n-        NamedRegionMap { defs: Default::default(), late_bound: Default::default() };\n+    let mut named_region_map = NamedRegionMap {\n+        defs: Default::default(),\n+        late_bound: Default::default(),\n+        late_bound_vars: Default::default(),\n+    };\n     let mut visitor = LifetimeContext {\n         tcx,\n         map: &mut named_region_map,\n         scope: ROOT_SCOPE,\n-        trait_ref_hack: false,\n+        trait_ref_hack: None,\n         is_in_fn_syntax: false,\n         is_in_const_generic: false,\n         trait_definition_only,\n@@ -426,6 +505,10 @@ fn do_resolve(\n         let map = rl.late_bound.entry(hir_id.owner).or_default();\n         map.insert(hir_id.local_id);\n     }\n+    for (hir_id, v) in named_region_map.late_bound_vars {\n+        let map = rl.late_bound_vars.entry(hir_id.owner).or_default();\n+        map.insert(hir_id.local_id, v);\n+    }\n \n     debug!(?rl.defs);\n     rl\n@@ -511,6 +594,19 @@ fn sub_items_have_self_param(node: &hir::ItemKind<'_>) -> bool {\n     matches!(*node, hir::ItemKind::Trait(..) | hir::ItemKind::TraitAlias(..))\n }\n \n+fn late_region_as_bound_region<'tcx>(tcx: TyCtxt<'tcx>, region: &Region) -> ty::BoundVariableKind {\n+    match region {\n+        Region::LateBound(_, _, def_id, _) => {\n+            let name = tcx.hir().name(tcx.hir().local_def_id_to_hir_id(def_id.expect_local()));\n+            ty::BoundVariableKind::Region(ty::BrNamed(*def_id, name))\n+        }\n+        Region::LateBoundAnon(_, _, anon_idx) => {\n+            ty::BoundVariableKind::Region(ty::BrAnon(*anon_idx))\n+        }\n+        _ => bug!(\"{:?} is not a late region\", region),\n+    }\n+}\n+\n impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     type Map = Map<'tcx>;\n \n@@ -538,11 +634,59 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n         self.labels_in_fn = saved;\n     }\n \n+    fn visit_fn(\n+        &mut self,\n+        fk: intravisit::FnKind<'tcx>,\n+        fd: &'tcx hir::FnDecl<'tcx>,\n+        b: hir::BodyId,\n+        s: rustc_span::Span,\n+        hir_id: hir::HirId,\n+    ) {\n+        let name = match fk {\n+            intravisit::FnKind::ItemFn(id, _, _, _) => id.as_str(),\n+            intravisit::FnKind::Method(id, _, _) => id.as_str(),\n+            intravisit::FnKind::Closure => Symbol::intern(\"closure\").as_str(),\n+        };\n+        let name: &str = &name;\n+        let span = span!(Level::DEBUG, \"visit_fn\", name);\n+        let _enter = span.enter();\n+        match fk {\n+            // Any `Binders` are handled elsewhere\n+            intravisit::FnKind::ItemFn(..) | intravisit::FnKind::Method(..) => {\n+                intravisit::walk_fn(self, fk, fd, b, s, hir_id)\n+            }\n+            intravisit::FnKind::Closure => {\n+                self.map.late_bound_vars.insert(hir_id, vec![]);\n+                let scope = Scope::Binder {\n+                    hir_id,\n+                    lifetimes: FxHashMap::default(),\n+                    next_early_index: self.next_early_index(),\n+                    s: self.scope,\n+                    track_lifetime_uses: true,\n+                    opaque_type_parent: false,\n+                    named_late_bound_vars: 0,\n+                    from_poly_trait_ref: false,\n+                };\n+                self.with(scope, move |_old_scope, this| {\n+                    intravisit::walk_fn(this, fk, fd, b, s, hir_id)\n+                });\n+            }\n+        }\n+    }\n+\n     fn visit_item(&mut self, item: &'tcx hir::Item<'tcx>) {\n+        match &item.kind {\n+            hir::ItemKind::Impl(hir::Impl { of_trait, .. }) => {\n+                if let Some(of_trait) = of_trait {\n+                    self.map.late_bound_vars.insert(of_trait.hir_ref_id, Vec::default());\n+                }\n+            }\n+            _ => {}\n+        }\n         match item.kind {\n             hir::ItemKind::Fn(ref sig, ref generics, _) => {\n                 self.missing_named_lifetime_spots.push(generics.into());\n-                self.visit_early_late(None, &sig.decl, generics, |this| {\n+                self.visit_early_late(None, item.hir_id(), &sig.decl, generics, |this| {\n                     intravisit::walk_item(this, item);\n                 });\n                 self.missing_named_lifetime_spots.pop();\n@@ -590,6 +734,16 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                                     self.map.late_bound.insert(hir::HirId { owner, local_id });\n                                 });\n                             }\n+                            for (&owner, late_bound_vars) in\n+                                resolved_lifetimes.late_bound_vars.iter()\n+                            {\n+                                late_bound_vars.iter().for_each(|(&local_id, late_bound_vars)| {\n+                                    self.map.late_bound_vars.insert(\n+                                        hir::HirId { owner, local_id },\n+                                        late_bound_vars.clone(),\n+                                    );\n+                                });\n+                            }\n                             break;\n                         }\n                         hir::Node::Crate(_) => bug!(\"No Item about an OpaqueTy\"),\n@@ -629,12 +783,15 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         }\n                     })\n                     .collect();\n+                self.map.late_bound_vars.insert(item.hir_id(), vec![]);\n                 let scope = Scope::Binder {\n+                    hir_id: item.hir_id(),\n                     lifetimes,\n                     next_early_index: index + non_lifetime_count,\n                     opaque_type_parent: true,\n                     track_lifetime_uses,\n                     named_late_bound_vars: 0,\n+                    from_poly_trait_ref: false,\n                     s: ROOT_SCOPE,\n                 };\n                 self.with(scope, |old_scope, this| {\n@@ -649,7 +806,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n     fn visit_foreign_item(&mut self, item: &'tcx hir::ForeignItem<'tcx>) {\n         match item.kind {\n             hir::ForeignItemKind::Fn(ref decl, _, ref generics) => {\n-                self.visit_early_late(None, decl, generics, |this| {\n+                self.visit_early_late(None, item.hir_id(), decl, generics, |this| {\n                     intravisit::walk_foreign_item(this, item);\n                 })\n             }\n@@ -681,23 +838,32 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 };\n                 self.missing_named_lifetime_spots\n                     .push(MissingLifetimeSpot::HigherRanked { span, span_type });\n+                let mut named_late_bound_vars = 0;\n+                let (lifetimes, binders): (FxHashMap<hir::ParamName, Region>, Vec<_>) = c\n+                    .generic_params\n+                    .iter()\n+                    .filter_map(|param| match param.kind {\n+                        GenericParamKind::Lifetime { .. } => {\n+                            let late_bound_idx = named_late_bound_vars;\n+                            named_late_bound_vars += 1;\n+                            let pair = Region::late(late_bound_idx, &self.tcx.hir(), param);\n+                            let r = pair.1.clone();\n+                            let r = late_region_as_bound_region(self.tcx, &r);\n+                            Some((pair, r))\n+                        }\n+                        _ => None,\n+                    })\n+                    .unzip();\n+                self.map.late_bound_vars.insert(ty.hir_id, binders);\n                 let scope = Scope::Binder {\n-                    lifetimes: c\n-                        .generic_params\n-                        .iter()\n-                        .enumerate()\n-                        .filter_map(|(idx, param)| match param.kind {\n-                            GenericParamKind::Lifetime { .. } => {\n-                                Some(Region::late(idx as u32, &self.tcx.hir(), param))\n-                            }\n-                            _ => None,\n-                        })\n-                        .collect(),\n+                    hir_id: ty.hir_id,\n+                    lifetimes,\n                     s: self.scope,\n                     next_early_index,\n                     track_lifetime_uses: true,\n                     opaque_type_parent: false,\n-                    named_late_bound_vars: c.generic_params.len() as u32,\n+                    named_late_bound_vars,\n+                    from_poly_trait_ref: false,\n                 };\n                 self.with(scope, |old_scope, this| {\n                     // a bare fn has no bounds, so everything\n@@ -874,18 +1040,21 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     }\n                 }\n                 let next_early_index = index + non_lifetime_count;\n+                self.map.late_bound_vars.insert(ty.hir_id, vec![]);\n \n                 if let Some(elision_region) = elision {\n                     let scope =\n                         Scope::Elision { elide: Elide::Exact(elision_region), s: self.scope };\n                     self.with(scope, |_old_scope, this| {\n                         let scope = Scope::Binder {\n+                            hir_id: ty.hir_id,\n                             lifetimes,\n                             next_early_index,\n                             s: this.scope,\n                             track_lifetime_uses: true,\n                             opaque_type_parent: false,\n                             named_late_bound_vars: 0,\n+                            from_poly_trait_ref: false,\n                         };\n                         this.with(scope, |_old_scope, this| {\n                             this.visit_generics(generics);\n@@ -896,12 +1065,14 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     });\n                 } else {\n                     let scope = Scope::Binder {\n+                        hir_id: ty.hir_id,\n                         lifetimes,\n                         next_early_index,\n                         s: self.scope,\n                         track_lifetime_uses: true,\n                         opaque_type_parent: false,\n                         named_late_bound_vars: 0,\n+                        from_poly_trait_ref: false,\n                     };\n                     self.with(scope, |_old_scope, this| {\n                         this.visit_generics(generics);\n@@ -923,6 +1094,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 let tcx = self.tcx;\n                 self.visit_early_late(\n                     Some(tcx.hir().get_parent_item(trait_item.hir_id())),\n+                    trait_item.hir_id(),\n                     &sig.decl,\n                     &trait_item.generics,\n                     |this| intravisit::walk_trait_item(this, trait_item),\n@@ -948,13 +1120,16 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         }\n                     })\n                     .collect();\n+                self.map.late_bound_vars.insert(trait_item.hir_id(), vec![]);\n                 let scope = Scope::Binder {\n+                    hir_id: trait_item.hir_id(),\n                     lifetimes,\n                     next_early_index: index + non_lifetime_count,\n                     s: self.scope,\n                     track_lifetime_uses: true,\n                     opaque_type_parent: true,\n                     named_late_bound_vars: 0,\n+                    from_poly_trait_ref: false,\n                 };\n                 self.with(scope, |old_scope, this| {\n                     this.check_lifetime_params(old_scope, &generics.params);\n@@ -986,6 +1161,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 let tcx = self.tcx;\n                 self.visit_early_late(\n                     Some(tcx.hir().get_parent_item(impl_item.hir_id())),\n+                    impl_item.hir_id(),\n                     &sig.decl,\n                     &impl_item.generics,\n                     |this| intravisit::walk_impl_item(this, impl_item),\n@@ -998,7 +1174,7 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                 let mut index = self.next_early_index();\n                 let mut non_lifetime_count = 0;\n                 debug!(\"visit_ty: index = {}\", index);\n-                let lifetimes = generics\n+                let lifetimes: FxHashMap<hir::ParamName, Region> = generics\n                     .params\n                     .iter()\n                     .filter_map(|param| match param.kind {\n@@ -1011,13 +1187,16 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                         }\n                     })\n                     .collect();\n+                self.map.late_bound_vars.insert(ty.hir_id, vec![]);\n                 let scope = Scope::Binder {\n+                    hir_id: ty.hir_id,\n                     lifetimes,\n                     next_early_index: index + non_lifetime_count,\n                     s: self.scope,\n                     track_lifetime_uses: true,\n                     opaque_type_parent: true,\n                     named_late_bound_vars: 0,\n+                    from_poly_trait_ref: false,\n                 };\n                 self.with(scope, |old_scope, this| {\n                     this.check_lifetime_params(old_scope, &generics.params);\n@@ -1100,32 +1279,40 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n                     ref bound_generic_params,\n                     ..\n                 }) => {\n-                    let lifetimes: FxHashMap<_, _> = bound_generic_params\n+                    let mut named_late_bound_vars = 0;\n+                    let (lifetimes, binders): (FxHashMap<_, _>, Vec<_>) = bound_generic_params\n                         .iter()\n-                        .enumerate()\n-                        .filter_map(|(idx, param)| match param.kind {\n+                        .filter_map(|param| match param.kind {\n                             GenericParamKind::Lifetime { .. } => {\n-                                Some(Region::late(idx as u32, &self.tcx.hir(), param))\n+                                let late_bound_idx = named_late_bound_vars;\n+                                named_late_bound_vars += 1;\n+                                let pair = Region::late(late_bound_idx, &self.tcx.hir(), param);\n+                                let r = pair.1.clone();\n+                                let r = late_region_as_bound_region(self.tcx, &r);\n+                                Some((pair, r))\n                             }\n                             _ => None,\n                         })\n-                        .collect();\n+                        .unzip();\n+                    self.map.late_bound_vars.insert(bounded_ty.hir_id, binders.clone());\n                     if !lifetimes.is_empty() {\n                         let next_early_index = self.next_early_index();\n                         let scope = Scope::Binder {\n+                            hir_id: bounded_ty.hir_id,\n                             lifetimes,\n                             s: self.scope,\n                             next_early_index,\n                             track_lifetime_uses: true,\n                             opaque_type_parent: false,\n-                            named_late_bound_vars: bound_generic_params.len() as u32,\n+                            named_late_bound_vars,\n+                            from_poly_trait_ref: true,\n                         };\n                         let result = self.with(scope, |old_scope, this| {\n                             this.check_lifetime_params(old_scope, &bound_generic_params);\n                             this.visit_ty(&bounded_ty);\n-                            this.trait_ref_hack = true;\n+                            this.trait_ref_hack = Some((binders, named_late_bound_vars));\n                             walk_list!(this, visit_param_bound, bounds);\n-                            this.trait_ref_hack = false;\n+                            this.trait_ref_hack = None;\n                         });\n                         result\n                     } else {\n@@ -1155,14 +1342,17 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n \n     fn visit_param_bound(&mut self, bound: &'tcx hir::GenericBound<'tcx>) {\n         match bound {\n-            hir::GenericBound::LangItemTrait { .. } if !self.trait_ref_hack => {\n+            hir::GenericBound::LangItemTrait(_, _, hir_id, _) if self.trait_ref_hack.is_none() => {\n+                self.map.late_bound_vars.insert(*hir_id, vec![]);\n                 let scope = Scope::Binder {\n+                    hir_id: *hir_id,\n                     lifetimes: FxHashMap::default(),\n                     s: self.scope,\n                     next_early_index: self.next_early_index(),\n                     track_lifetime_uses: true,\n                     opaque_type_parent: false,\n                     named_late_bound_vars: 0,\n+                    from_poly_trait_ref: false,\n                 };\n                 self.with(scope, |_, this| {\n                     intravisit::walk_param_bound(this, bound);\n@@ -1181,48 +1371,159 @@ impl<'a, 'tcx> Visitor<'tcx> for LifetimeContext<'a, 'tcx> {\n \n         let should_pop_missing_lt = self.is_trait_ref_fn_scope(trait_ref);\n \n-        let trait_ref_hack = take(&mut self.trait_ref_hack);\n-        if !trait_ref_hack\n-            || trait_ref\n-                .bound_generic_params\n-                .iter()\n-                .any(|param| matches!(param.kind, GenericParamKind::Lifetime { .. }))\n-        {\n-            if trait_ref_hack {\n-                struct_span_err!(\n-                    self.tcx.sess,\n-                    trait_ref.span,\n-                    E0316,\n-                    \"nested quantification of lifetimes\"\n-                )\n-                .emit();\n-            }\n-            let next_early_index = self.next_early_index();\n-            let scope = Scope::Binder {\n-                lifetimes: trait_ref\n+        let trait_ref_hack = self.trait_ref_hack.take();\n+        let next_early_index = self.next_early_index();\n+        // See note on `trait_ref_hack`. If `for<..>` has been defined in both\n+        // the outer and inner part of the trait ref, emit an error.\n+        let has_lifetimes = trait_ref.bound_generic_params.iter().any(|param| match param.kind {\n+            GenericParamKind::Lifetime { .. } => true,\n+            _ => false,\n+        });\n+        if trait_ref_hack.is_some() && has_lifetimes {\n+            struct_span_err!(\n+                self.tcx.sess,\n+                trait_ref.span,\n+                E0316,\n+                \"nested quantification of lifetimes\"\n+            )\n+            .emit();\n+        }\n+\n+        let (binders, named_late_bound_vars, lifetimes) =\n+            if let Some((mut binders, mut named_late_bound_vars)) = trait_ref_hack.clone() {\n+                let initial_binders = named_late_bound_vars;\n+                binders.extend(trait_ref.bound_generic_params.iter().filter_map(|param| {\n+                    match param.kind {\n+                        GenericParamKind::Lifetime { .. } => {\n+                            let late_bound_idx = named_late_bound_vars;\n+                            named_late_bound_vars += 1;\n+                            let region = Region::late(late_bound_idx, &self.tcx.hir(), param).1;\n+                            Some(late_region_as_bound_region(self.tcx, &region))\n+                        }\n+                        GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => None,\n+                    }\n+                }));\n+\n+                let mut named_late_bound_vars = initial_binders;\n+                let lifetimes: FxHashMap<hir::ParamName, Region> = trait_ref\n                     .bound_generic_params\n                     .iter()\n-                    .enumerate()\n-                    .filter_map(|(idx, param)| match param.kind {\n+                    .filter_map(|param| match param.kind {\n                         GenericParamKind::Lifetime { .. } => {\n-                            Some(Region::late(idx as u32, &self.tcx.hir(), param))\n+                            let late_bound_idx = named_late_bound_vars;\n+                            named_late_bound_vars += 1;\n+                            Some(Region::late(late_bound_idx, &self.tcx.hir(), param))\n                         }\n                         _ => None,\n                     })\n-                    .collect(),\n+                    .collect();\n+\n+                (binders, named_late_bound_vars, lifetimes)\n+            } else {\n+                let mut supertrait_lifetimes = vec![];\n+                let mut scope = self.scope;\n+                let mut binders = loop {\n+                    match scope {\n+                        Scope::Body { .. } | Scope::Root => {\n+                            break vec![];\n+                        }\n+\n+                        Scope::Elision { s, .. } | Scope::ObjectLifetimeDefault { s, .. } => {\n+                            scope = s;\n+                        }\n+\n+                        Scope::TraitRefHackInner { hir_id, .. } => {\n+                            // Nested poly trait refs have the binders concatenated\n+                            // If we reach `TraitRefHackInner`, then there is only one more `Binder` above us,\n+                            // over all the bounds. We don't want this, since all the lifetimes we care about\n+                            // are here anyways.\n+                            let mut full_binders =\n+                                self.map.late_bound_vars.entry(*hir_id).or_default().clone();\n+                            full_binders.extend(supertrait_lifetimes.into_iter());\n+                            break full_binders;\n+                        }\n+\n+                        Scope::Supertrait { s, lifetimes } => {\n+                            supertrait_lifetimes = lifetimes.clone();\n+                            scope = s;\n+                        }\n+\n+                        Scope::Binder { hir_id, from_poly_trait_ref, .. } => {\n+                            if !from_poly_trait_ref {\n+                                // We should only see super trait lifetimes if there is a `Binder` above\n+                                assert!(supertrait_lifetimes.is_empty());\n+                                break vec![];\n+                            }\n+                            // Nested poly trait refs have the binders concatenated\n+                            let mut full_binders =\n+                                self.map.late_bound_vars.entry(*hir_id).or_default().clone();\n+                            full_binders.extend(supertrait_lifetimes.into_iter());\n+                            break full_binders;\n+                        }\n+                    }\n+                };\n+                let mut named_late_bound_vars = binders.len() as u32;\n+                let local_binders: Vec<_> = trait_ref\n+                    .bound_generic_params\n+                    .iter()\n+                    .filter_map(|param| match param.kind {\n+                        GenericParamKind::Lifetime { .. } => {\n+                            let late_bound_idx = named_late_bound_vars;\n+                            named_late_bound_vars += 1;\n+                            let region = Region::late(late_bound_idx, &self.tcx.hir(), param).1;\n+                            Some(late_region_as_bound_region(self.tcx, &region))\n+                        }\n+                        GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => None,\n+                    })\n+                    .collect();\n+\n+                let mut named_late_bound_vars = binders.len() as u32;\n+                let lifetimes: FxHashMap<hir::ParamName, Region> = trait_ref\n+                    .bound_generic_params\n+                    .iter()\n+                    .filter_map(|param| match param.kind {\n+                        GenericParamKind::Lifetime { .. } => {\n+                            let late_bound_idx = named_late_bound_vars;\n+                            named_late_bound_vars += 1;\n+                            Some(Region::late(late_bound_idx, &self.tcx.hir(), param))\n+                        }\n+                        _ => None,\n+                    })\n+                    .collect();\n+\n+                binders.extend(local_binders.into_iter());\n+\n+                (binders, named_late_bound_vars, lifetimes)\n+            };\n+\n+        debug!(?binders);\n+        self.map.late_bound_vars.insert(trait_ref.trait_ref.hir_ref_id, binders);\n+\n+        if trait_ref_hack.is_none() || has_lifetimes {\n+            let scope = Scope::Binder {\n+                hir_id: trait_ref.trait_ref.hir_ref_id,\n+                lifetimes,\n                 s: self.scope,\n                 next_early_index,\n                 track_lifetime_uses: true,\n                 opaque_type_parent: false,\n-                named_late_bound_vars: trait_ref.bound_generic_params.len() as u32,\n+                named_late_bound_vars: named_late_bound_vars as u32,\n+                from_poly_trait_ref: true,\n             };\n             self.with(scope, |old_scope, this| {\n                 this.check_lifetime_params(old_scope, &trait_ref.bound_generic_params);\n                 walk_list!(this, visit_generic_param, trait_ref.bound_generic_params);\n                 this.visit_trait_ref(&trait_ref.trait_ref);\n             });\n         } else {\n-            self.visit_trait_ref(&trait_ref.trait_ref);\n+            let scope = Scope::TraitRefHackInner {\n+                hir_id: trait_ref.trait_ref.hir_ref_id,\n+                named_late_bound_vars: named_late_bound_vars as u32,\n+                s: self.scope,\n+            };\n+            self.with(scope, |_old_scope, this| {\n+                this.visit_trait_ref(&trait_ref.trait_ref);\n+            });\n         }\n         self.trait_ref_hack = trait_ref_hack;\n         if should_pop_missing_lt {\n@@ -1374,7 +1675,9 @@ fn extract_labels(ctxt: &mut LifetimeContext<'_, '_>, body: &hir::Body<'_>) {\n             match *scope {\n                 Scope::Body { s, .. }\n                 | Scope::Elision { s, .. }\n-                | Scope::ObjectLifetimeDefault { s, .. } => {\n+                | Scope::ObjectLifetimeDefault { s, .. }\n+                | Scope::TraitRefHackInner { s, .. }\n+                | Scope::Supertrait { s, .. } => {\n                     scope = s;\n                 }\n \n@@ -1563,11 +1866,12 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         let labels_in_fn = take(&mut self.labels_in_fn);\n         let xcrate_object_lifetime_defaults = take(&mut self.xcrate_object_lifetime_defaults);\n         let missing_named_lifetime_spots = take(&mut self.missing_named_lifetime_spots);\n+        let trait_ref_hack = take(&mut self.trait_ref_hack);\n         let mut this = LifetimeContext {\n             tcx: *tcx,\n             map,\n             scope: &wrap_scope,\n-            trait_ref_hack: self.trait_ref_hack,\n+            trait_ref_hack,\n             is_in_fn_syntax: self.is_in_fn_syntax,\n             is_in_const_generic: self.is_in_const_generic,\n             trait_definition_only: self.trait_definition_only,\n@@ -1587,6 +1891,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         self.labels_in_fn = this.labels_in_fn;\n         self.xcrate_object_lifetime_defaults = this.xcrate_object_lifetime_defaults;\n         self.missing_named_lifetime_spots = this.missing_named_lifetime_spots;\n+        self.trait_ref_hack = this.trait_ref_hack;\n     }\n \n     /// helper method to determine the span to remove when suggesting the\n@@ -1881,6 +2186,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     fn visit_early_late<F>(\n         &mut self,\n         parent_id: Option<hir::HirId>,\n+        hir_id: hir::HirId,\n         decl: &'tcx hir::FnDecl<'tcx>,\n         generics: &'tcx hir::Generics<'tcx>,\n         walk: F,\n@@ -1890,34 +2196,34 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         insert_late_bound_lifetimes(self.map, decl, generics);\n \n         // Find the start of nested early scopes, e.g., in methods.\n-        let mut index = 0;\n+        let mut next_early_index = 0;\n         if let Some(parent_id) = parent_id {\n             let parent = self.tcx.hir().expect_item(parent_id);\n             if sub_items_have_self_param(&parent.kind) {\n-                index += 1; // Self comes before lifetimes\n+                next_early_index += 1; // Self comes before lifetimes\n             }\n             match parent.kind {\n                 hir::ItemKind::Trait(_, _, ref generics, ..)\n                 | hir::ItemKind::Impl(hir::Impl { ref generics, .. }) => {\n-                    index += generics.params.len() as u32;\n+                    next_early_index += generics.params.len() as u32;\n                 }\n                 _ => {}\n             }\n         }\n \n         let mut non_lifetime_count = 0;\n         let mut named_late_bound_vars = 0;\n-        let lifetimes = generics\n+        let lifetimes: FxHashMap<hir::ParamName, Region> = generics\n             .params\n             .iter()\n-            .enumerate()\n-            .filter_map(|(idx, param)| match param.kind {\n+            .filter_map(|param| match param.kind {\n                 GenericParamKind::Lifetime { .. } => {\n                     if self.map.late_bound.contains(&param.hir_id) {\n+                        let late_bound_idx = named_late_bound_vars;\n                         named_late_bound_vars += 1;\n-                        Some(Region::late(idx as u32, &self.tcx.hir(), param))\n+                        Some(Region::late(late_bound_idx, &self.tcx.hir(), param))\n                     } else {\n-                        Some(Region::early(&self.tcx.hir(), &mut index, param))\n+                        Some(Region::early(&self.tcx.hir(), &mut next_early_index, param))\n                     }\n                 }\n                 GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => {\n@@ -1926,15 +2232,37 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 }\n             })\n             .collect();\n-        let next_early_index = index + non_lifetime_count;\n+        let next_early_index = next_early_index + non_lifetime_count;\n \n+        let mut named_late_bound_vars = 0;\n+        let binders: Vec<_> = generics\n+            .params\n+            .iter()\n+            .filter_map(|param| match param.kind {\n+                GenericParamKind::Lifetime { .. } => {\n+                    if self.map.late_bound.contains(&param.hir_id) {\n+                        let late_bound_idx = named_late_bound_vars;\n+                        named_late_bound_vars += 1;\n+                        let r = Region::late(late_bound_idx, &self.tcx.hir(), param).1;\n+                        let r = late_region_as_bound_region(self.tcx, &r);\n+                        Some(r)\n+                    } else {\n+                        None\n+                    }\n+                }\n+                GenericParamKind::Type { .. } | GenericParamKind::Const { .. } => None,\n+            })\n+            .collect();\n+        self.map.late_bound_vars.insert(hir_id, binders);\n         let scope = Scope::Binder {\n+            hir_id,\n             lifetimes,\n             next_early_index,\n             s: self.scope,\n             opaque_type_parent: true,\n             track_lifetime_uses: false,\n-            named_late_bound_vars,\n+            named_late_bound_vars: named_late_bound_vars as u32,\n+            from_poly_trait_ref: false,\n         };\n         self.with(scope, move |old_scope, this| {\n             this.check_lifetime_params(old_scope, &generics.params);\n@@ -1957,7 +2285,9 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 Scope::Binder { s, .. }\n                 | Scope::Body { s, .. }\n                 | Scope::Elision { s, .. }\n-                | Scope::ObjectLifetimeDefault { s, .. } => scope = s,\n+                | Scope::ObjectLifetimeDefault { s, .. }\n+                | Scope::TraitRefHackInner { s, .. }\n+                | Scope::Supertrait { s, .. } => scope = s,\n             }\n         }\n     }\n@@ -1989,6 +2319,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n         // given name or we run out of scopes.\n         // search.\n         let mut late_depth = 0;\n+        let mut in_poly_trait_ref = false;\n         let mut scope = self.scope;\n         let mut outermost_body = None;\n         let result = loop {\n@@ -2006,7 +2337,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     break None;\n                 }\n \n-                Scope::Binder { ref lifetimes, s, .. } => {\n+                Scope::Binder { ref lifetimes, from_poly_trait_ref, s, .. } => {\n                     match lifetime_ref.name {\n                         LifetimeName::Param(param_name) => {\n                             if let Some(&def) = lifetimes.get(&param_name.normalize_to_macros_2_0())\n@@ -2017,11 +2348,35 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                         _ => bug!(\"expected LifetimeName::Param\"),\n                     }\n \n-                    late_depth += 1;\n+                    match (from_poly_trait_ref, in_poly_trait_ref) {\n+                        // This is the first binder we see that is a poly trait ref; add one to the\n+                        // late depth and mark that we're potentially in nested trait refs.\n+                        (true, false) => {\n+                            in_poly_trait_ref = true;\n+                            late_depth += 1;\n+                        }\n+                        // We've already seen a binder that is a poly trait ref and this one is too,\n+                        // that means that they are nested and we are concatenating the bound vars;\n+                        // don't increase the late depth.\n+                        (true, true) => {}\n+                        // We've exited nested poly trait refs; add one to the late depth and mark\n+                        // that we are no longer in nested trait refs\n+                        (false, true) => {\n+                            in_poly_trait_ref = false;\n+                            late_depth += 1;\n+                        }\n+                        // Any other kind of nested binders: just increase late depth.\n+                        (false, false) => {\n+                            late_depth += 1;\n+                        }\n+                    }\n                     scope = s;\n                 }\n \n-                Scope::Elision { s, .. } | Scope::ObjectLifetimeDefault { s, .. } => {\n+                Scope::Elision { s, .. }\n+                | Scope::ObjectLifetimeDefault { s, .. }\n+                | Scope::TraitRefHackInner { s, .. }\n+                | Scope::Supertrait { s, .. } => {\n                     scope = s;\n                 }\n             }\n@@ -2117,6 +2472,8 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 _ => None,\n             })\n             .collect();\n+        // We short-circuit here if all are elided in order to pluralize\n+        // possible errors\n         if elide_lifetimes {\n             self.resolve_elided_lifetimes(&lifetimes);\n         } else {\n@@ -2171,7 +2528,9 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n                         Scope::Binder { s, .. }\n                         | Scope::Elision { s, .. }\n-                        | Scope::ObjectLifetimeDefault { s, .. } => {\n+                        | Scope::ObjectLifetimeDefault { s, .. }\n+                        | Scope::TraitRefHackInner { s, .. }\n+                        | Scope::Supertrait { s, .. } => {\n                             scope = s;\n                         }\n                     }\n@@ -2271,27 +2630,80 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             generic_args.args.iter().any(|arg| matches!(arg, GenericArg::Lifetime(_)));\n \n         // Resolve lifetimes found in the type `XX` from `Item = XX` bindings.\n-        for b in generic_args.bindings {\n+        for binding in generic_args.bindings {\n             let scope = Scope::ObjectLifetimeDefault {\n                 lifetime: if has_lifetime_parameter { None } else { Some(Region::Static) },\n                 s: self.scope,\n             };\n-            self.with(scope, |_, this| this.visit_assoc_type_binding(b));\n+            if let Some(type_def_id) = type_def_id {\n+                let lifetimes =\n+                    LifetimeContext::supertrait_bounds(self.tcx, type_def_id, binding.ident);\n+                if let Some(lifetimes) = lifetimes {\n+                    self.with(scope, |_, this| {\n+                        let scope = Scope::Supertrait { lifetimes, s: this.scope };\n+                        this.with(scope, |_, this| this.visit_assoc_type_binding(binding));\n+                    });\n+                } else {\n+                    self.with(scope, |_, this| this.visit_assoc_type_binding(binding));\n+                }\n+            } else {\n+                self.with(scope, |_, this| this.visit_assoc_type_binding(binding));\n+            }\n         }\n     }\n \n+    fn trait_defines_associated_type_named(\n+        tcx: TyCtxt<'tcx>,\n+        trait_def_id: DefId,\n+        assoc_name: Ident,\n+    ) -> bool {\n+        tcx.associated_items(trait_def_id)\n+            .find_by_name_and_kind(tcx, assoc_name, ty::AssocKind::Type, trait_def_id)\n+            .is_some()\n+    }\n+\n+    fn supertrait_bounds(\n+        tcx: TyCtxt<'tcx>,\n+        def_id: DefId,\n+        assoc_name: Ident,\n+    ) -> Option<Vec<ty::BoundVariableKind>> {\n+        let all_candidates = super::supertraits::supertraits(tcx, def_id);\n+        let mut matching_candidates = all_candidates\n+            .filter(|r| LifetimeContext::trait_defines_associated_type_named(tcx, r.0, assoc_name));\n+\n+        matching_candidates.next().map(|c| c.1.into_iter().collect())\n+    }\n+\n     #[tracing::instrument(level = \"debug\", skip(self))]\n     fn visit_fn_like_elision(\n         &mut self,\n         inputs: &'tcx [hir::Ty<'tcx>],\n         output: Option<&'tcx hir::Ty<'tcx>>,\n     ) {\n         debug!(\"visit_fn_like_elision: enter\");\n-        let named_late_bound_vars = match *self.scope {\n-            Scope::Binder { named_late_bound_vars, .. } => named_late_bound_vars,\n-            Scope::Body { .. } => 0,\n-            _ => bug!(\"{:?}\", self.scope),\n+        let mut scope = &*self.scope;\n+        let (hir_id, named_late_bound_vars) = loop {\n+            match scope {\n+                Scope::Binder { hir_id, named_late_bound_vars, .. }\n+                | Scope::TraitRefHackInner { hir_id, named_late_bound_vars, .. } => {\n+                    break (*hir_id, *named_late_bound_vars);\n+                }\n+                Scope::Body { id, .. } => break (id.hir_id, 0),\n+                Scope::ObjectLifetimeDefault { ref s, .. }\n+                | Scope::Elision { ref s, .. }\n+                | Scope::Supertrait { ref s, .. } => {\n+                    scope = *s;\n+                }\n+                Scope::Root => bug!(\"In fn_like_elision without appropriate scope above\"),\n+            }\n         };\n+        let mut gather = GatherAnonLifetimes { anon_count: 0 };\n+        for input in inputs {\n+            gather.visit_ty(input);\n+        }\n+        self.map.late_bound_vars.entry(hir_id).or_default().extend(\n+            (0..gather.anon_count).map(|var| ty::BoundVariableKind::Region(ty::BrAnon(var))),\n+        );\n         let arg_scope = Scope::Elision {\n             elide: Elide::FreshLateAnon(named_late_bound_vars, Cell::new(0)),\n             s: self.scope,\n@@ -2563,6 +2975,41 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 }\n             }\n         }\n+\n+        struct GatherAnonLifetimes {\n+            anon_count: u32,\n+        }\n+        impl<'v> Visitor<'v> for GatherAnonLifetimes {\n+            type Map = intravisit::ErasedMap<'v>;\n+\n+            fn nested_visit_map(&mut self) -> NestedVisitorMap<Self::Map> {\n+                NestedVisitorMap::None\n+            }\n+\n+            fn visit_ty(&mut self, ty: &hir::Ty<'_>) {\n+                if let hir::TyKind::BareFn(_) = ty.kind {\n+                    return;\n+                }\n+                intravisit::walk_ty(self, ty);\n+            }\n+\n+            fn visit_generic_args(\n+                &mut self,\n+                path_span: Span,\n+                generic_args: &'v hir::GenericArgs<'v>,\n+            ) {\n+                if generic_args.parenthesized {\n+                    return;\n+                }\n+                intravisit::walk_generic_args(self, path_span, generic_args)\n+            }\n+\n+            fn visit_lifetime(&mut self, lifetime_ref: &hir::Lifetime) {\n+                if lifetime_ref.is_elided() {\n+                    self.anon_count += 1;\n+                }\n+            }\n+        }\n     }\n \n     fn resolve_elided_lifetimes(&mut self, lifetime_refs: &[&'tcx hir::Lifetime]) {\n@@ -2574,6 +3021,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n         let span = lifetime_refs[0].span;\n         let mut late_depth = 0;\n+        let mut in_poly_trait_ref = false;\n         let mut scope = self.scope;\n         let mut lifetime_names = FxHashSet::default();\n         let mut lifetime_spans = vec![];\n@@ -2584,15 +3032,29 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n \n                 Scope::Root => break None,\n \n-                Scope::Binder { s, ref lifetimes, .. } => {\n+                Scope::Binder { s, ref lifetimes, from_poly_trait_ref, .. } => {\n                     // collect named lifetimes for suggestions\n                     for name in lifetimes.keys() {\n                         if let hir::ParamName::Plain(name) = name {\n                             lifetime_names.insert(name.name);\n                             lifetime_spans.push(name.span);\n                         }\n                     }\n-                    late_depth += 1;\n+                    // See comments in `resolve_lifetime_ref`\n+                    match (from_poly_trait_ref, in_poly_trait_ref) {\n+                        (true, false) => {\n+                            in_poly_trait_ref = true;\n+                            late_depth += 1;\n+                        }\n+                        (true, true) => {}\n+                        (false, true) => {\n+                            in_poly_trait_ref = false;\n+                            late_depth += 1;\n+                        }\n+                        (false, false) => {\n+                            late_depth += 1;\n+                        }\n+                    }\n                     scope = s;\n                 }\n \n@@ -2602,6 +3064,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                             for lifetime_ref in lifetime_refs {\n                                 let lifetime = Region::late_anon(named_late_bound_vars, counter)\n                                     .shifted(late_depth);\n+\n                                 self.insert_lifetime(lifetime_ref, lifetime);\n                             }\n                             return;\n@@ -2638,7 +3101,9 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     return;\n                 }\n \n-                Scope::ObjectLifetimeDefault { s, .. } => {\n+                Scope::ObjectLifetimeDefault { s, .. }\n+                | Scope::TraitRefHackInner { s, .. }\n+                | Scope::Supertrait { s, .. } => {\n                     scope = s;\n                 }\n             }\n@@ -2744,11 +3209,25 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n     fn resolve_object_lifetime_default(&mut self, lifetime_ref: &'tcx hir::Lifetime) {\n         debug!(\"resolve_object_lifetime_default(lifetime_ref={:?})\", lifetime_ref);\n         let mut late_depth = 0;\n+        let mut in_poly_trait_ref = false;\n         let mut scope = self.scope;\n         let lifetime = loop {\n             match *scope {\n-                Scope::Binder { s, .. } => {\n-                    late_depth += 1;\n+                Scope::Binder { s, from_poly_trait_ref, .. } => {\n+                    match (from_poly_trait_ref, in_poly_trait_ref) {\n+                        (true, false) => {\n+                            in_poly_trait_ref = true;\n+                            late_depth += 1;\n+                        }\n+                        (true, true) => {}\n+                        (false, true) => {\n+                            in_poly_trait_ref = false;\n+                            late_depth += 1;\n+                        }\n+                        (false, false) => {\n+                            late_depth += 1;\n+                        }\n+                    }\n                     scope = s;\n                 }\n \n@@ -2757,6 +3236,10 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 Scope::Body { .. } | Scope::ObjectLifetimeDefault { lifetime: None, .. } => return,\n \n                 Scope::ObjectLifetimeDefault { lifetime: Some(l), .. } => break l,\n+\n+                Scope::TraitRefHackInner { s, .. } | Scope::Supertrait { s, .. } => {\n+                    scope = s;\n+                }\n             }\n         };\n         self.insert_lifetime(lifetime_ref, lifetime.shifted(late_depth));\n@@ -2880,7 +3363,9 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n             match *old_scope {\n                 Scope::Body { s, .. }\n                 | Scope::Elision { s, .. }\n-                | Scope::ObjectLifetimeDefault { s, .. } => {\n+                | Scope::ObjectLifetimeDefault { s, .. }\n+                | Scope::TraitRefHackInner { s, .. }\n+                | Scope::Supertrait { s, .. } => {\n                     old_scope = s;\n                 }\n \n@@ -2926,7 +3411,7 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                 // A lifetime only used in a fn argument could as well\n                 // be replaced with `'_`, as that would generate a\n                 // fresh name, too.\n-                Scope::Elision { elide: Elide::FreshLateAnon(_, _), .. } => break true,\n+                Scope::Elision { elide: Elide::FreshLateAnon(..), .. } => break true,\n \n                 // In the return type or other such place, `'_` is not\n                 // going to make a fresh name, so we cannot\n@@ -2936,7 +3421,9 @@ impl<'a, 'tcx> LifetimeContext<'a, 'tcx> {\n                     elide: Elide::Exact(_) | Elide::Error(_) | Elide::Forbid, ..\n                 } => break false,\n \n-                Scope::ObjectLifetimeDefault { s, .. } => scope = s,\n+                Scope::ObjectLifetimeDefault { s, .. }\n+                | Scope::TraitRefHackInner { s, .. }\n+                | Scope::Supertrait { s, .. } => scope = s,\n             }\n         }\n     }"}, {"sha": "2130c33bd770b38fe4622922575dd34aa6eb71ce", "filename": "compiler/rustc_resolve/src/late/supertraits.rs", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/6d5efa9f040d2638318f9e8b96eab718ef664e3c/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fsupertraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d5efa9f040d2638318f9e8b96eab718ef664e3c/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fsupertraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate%2Fsupertraits.rs?ref=6d5efa9f040d2638318f9e8b96eab718ef664e3c", "patch": "@@ -0,0 +1,60 @@\n+use smallvec::{smallvec, SmallVec};\n+\n+use rustc_data_structures::fx::FxHashSet;\n+use rustc_hir::def_id::DefId;\n+use rustc_middle::ty::{self, TyCtxt};\n+\n+pub struct Elaborator<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    stack: SmallVec<[(DefId, SmallVec<[ty::BoundVariableKind; 8]>); 8]>,\n+    visited: FxHashSet<DefId>,\n+}\n+\n+#[allow(dead_code)]\n+pub fn supertraits<'tcx>(tcx: TyCtxt<'tcx>, def_id: DefId) -> Elaborator<'tcx> {\n+    Elaborator { tcx, stack: smallvec![(def_id, smallvec![])], visited: Default::default() }\n+}\n+\n+impl<'tcx> Elaborator<'tcx> {\n+    fn elaborate(&mut self, def_id: DefId, bound_vars: &SmallVec<[ty::BoundVariableKind; 8]>) {\n+        let tcx = self.tcx;\n+\n+        let predicates = tcx.super_predicates_of(def_id);\n+        let obligations = predicates.predicates.iter().filter_map(|&(pred, _)| {\n+            let bound_predicate = pred.kind();\n+            match bound_predicate.skip_binder() {\n+                ty::PredicateKind::Trait(data, _) => {\n+                    // The order here needs to match what we would get from `subst_supertrait`\n+                    let pred_bound_vars = bound_predicate.bound_vars();\n+                    let mut all_bound_vars = bound_vars.clone();\n+                    all_bound_vars.extend(pred_bound_vars.iter());\n+                    let super_def_id = data.trait_ref.def_id;\n+                    Some((super_def_id, all_bound_vars))\n+                }\n+                _ => None,\n+            }\n+        });\n+\n+        let visited = &mut self.visited;\n+        let obligations = obligations.filter(|o| visited.insert(o.0));\n+        self.stack.extend(obligations);\n+    }\n+}\n+\n+impl<'tcx> Iterator for Elaborator<'tcx> {\n+    type Item = (DefId, SmallVec<[ty::BoundVariableKind; 8]>);\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        (self.stack.len(), None)\n+    }\n+\n+    fn next(&mut self) -> Option<Self::Item> {\n+        match self.stack.pop() {\n+            Some((def_id, bound_vars)) => {\n+                self.elaborate(def_id, &bound_vars);\n+                Some((def_id, bound_vars))\n+            }\n+            None => None,\n+        }\n+    }\n+}"}, {"sha": "37a834043f624ba5b0474bc91ad2a62fac03e192", "filename": "compiler/rustc_symbol_mangling/src/v0.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d5efa9f040d2638318f9e8b96eab718ef664e3c/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d5efa9f040d2638318f9e8b96eab718ef664e3c/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_symbol_mangling%2Fsrc%2Fv0.rs?ref=6d5efa9f040d2638318f9e8b96eab718ef664e3c", "patch": "@@ -318,7 +318,7 @@ impl Printer<'tcx> for SymbolMangler<'tcx> {\n \n             // Late-bound lifetimes use indices starting at 1,\n             // see `BinderLevel` for more details.\n-            ty::ReLateBound(debruijn, ty::BoundRegion { kind: ty::BrAnon(i) }) => {\n+            ty::ReLateBound(debruijn, ty::BoundRegion { kind: ty::BrAnon(i), .. }) => {\n                 let binder = &self.binders[self.binders.len() - 1 - debruijn.index()];\n                 let depth = binder.lifetime_depths.start + i;\n "}, {"sha": "8c97e606c569ff0279fd7b5b3f85a2349e232f17", "filename": "compiler/rustc_traits/src/chalk/db.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/6d5efa9f040d2638318f9e8b96eab718ef664e3c/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d5efa9f040d2638318f9e8b96eab718ef664e3c/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Fdb.rs?ref=6d5efa9f040d2638318f9e8b96eab718ef664e3c", "patch": "@@ -735,7 +735,10 @@ fn bound_vars_for_item(tcx: TyCtxt<'tcx>, def_id: DefId) -> SubstsRef<'tcx> {\n             .into(),\n \n         ty::GenericParamDefKind::Lifetime => {\n-            let br = ty::BoundRegion { kind: ty::BrAnon(substs.len() as u32) };\n+            let br = ty::BoundRegion {\n+                var: ty::BoundVar::from_usize(substs.len()),\n+                kind: ty::BrAnon(substs.len() as u32),\n+            };\n             tcx.mk_region(ty::RegionKind::ReLateBound(ty::INNERMOST, br)).into()\n         }\n "}, {"sha": "39890fd5b0574a2a0b98cb5f6393d5b3920c4e51", "filename": "compiler/rustc_traits/src/chalk/lowering.rs", "status": "modified", "additions": 17, "deletions": 16, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/6d5efa9f040d2638318f9e8b96eab718ef664e3c/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d5efa9f040d2638318f9e8b96eab718ef664e3c/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs?ref=6d5efa9f040d2638318f9e8b96eab718ef664e3c", "patch": "@@ -434,17 +434,11 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::Lifetime<RustInterner<'tcx>>> for Region<'t\n             ReEarlyBound(_) => {\n                 panic!(\"Should have already been substituted.\");\n             }\n-            ReLateBound(db, br) => match br.kind {\n-                ty::BoundRegionKind::BrAnon(var) => {\n-                    chalk_ir::LifetimeData::BoundVar(chalk_ir::BoundVar::new(\n-                        chalk_ir::DebruijnIndex::new(db.as_u32()),\n-                        var as usize,\n-                    ))\n-                    .intern(interner)\n-                }\n-                ty::BoundRegionKind::BrNamed(_def_id, _name) => unimplemented!(),\n-                ty::BrEnv => unimplemented!(),\n-            },\n+            ReLateBound(db, br) => chalk_ir::LifetimeData::BoundVar(chalk_ir::BoundVar::new(\n+                chalk_ir::DebruijnIndex::new(db.as_u32()),\n+                br.var.as_usize(),\n+            ))\n+            .intern(interner),\n             ReFree(_) => unimplemented!(),\n             ReStatic => chalk_ir::LifetimeData::Static.intern(interner),\n             ReVar(_) => unimplemented!(),\n@@ -467,7 +461,10 @@ impl<'tcx> LowerInto<'tcx, Region<'tcx>> for &chalk_ir::Lifetime<RustInterner<'t\n         let kind = match self.data(interner) {\n             chalk_ir::LifetimeData::BoundVar(var) => ty::RegionKind::ReLateBound(\n                 ty::DebruijnIndex::from_u32(var.debruijn.depth()),\n-                ty::BoundRegion { kind: ty::BrAnon(var.index as u32) },\n+                ty::BoundRegion {\n+                    var: ty::BoundVar::from_usize(var.index),\n+                    kind: ty::BrAnon(var.index as u32),\n+                },\n             ),\n             chalk_ir::LifetimeData::InferenceVar(_var) => unimplemented!(),\n             chalk_ir::LifetimeData::Placeholder(p) => {\n@@ -900,7 +897,7 @@ impl<'tcx> TypeVisitor<'tcx> for BoundVarsCollector<'tcx> {\n                     },\n                 },\n \n-                ty::BrEnv => unimplemented!(),\n+                ty::BoundRegionKind::BrEnv => unimplemented!(),\n             },\n \n             ty::ReEarlyBound(_re) => {\n@@ -948,7 +945,7 @@ impl<'a, 'tcx> TypeFolder<'tcx> for NamedBoundVarSubstitutor<'a, 'tcx> {\n             ty::ReLateBound(index, br) if *index == self.binder_index => match br.kind {\n                 ty::BrNamed(def_id, _name) => match self.named_parameters.get(&def_id) {\n                     Some(idx) => {\n-                        let new_br = ty::BoundRegion { kind: ty::BrAnon(*idx) };\n+                        let new_br = ty::BoundRegion { var: br.var, kind: ty::BrAnon(*idx) };\n                         return self.tcx.mk_region(RegionKind::ReLateBound(*index, new_br));\n                     }\n                     None => panic!(\"Missing `BrNamed`.\"),\n@@ -1031,12 +1028,16 @@ impl<'tcx> TypeFolder<'tcx> for ParamsSubstitutor<'tcx> {\n             // This covers any region variables in a goal, right?\n             ty::ReEarlyBound(_re) => match self.named_regions.get(&_re.def_id) {\n                 Some(idx) => {\n-                    let br = ty::BoundRegion { kind: ty::BrAnon(*idx) };\n+                    let br = ty::BoundRegion {\n+                        var: ty::BoundVar::from_u32(*idx),\n+                        kind: ty::BrAnon(*idx),\n+                    };\n                     self.tcx.mk_region(RegionKind::ReLateBound(self.binder_index, br))\n                 }\n                 None => {\n                     let idx = self.named_regions.len() as u32;\n-                    let br = ty::BoundRegion { kind: ty::BrAnon(idx) };\n+                    let br =\n+                        ty::BoundRegion { var: ty::BoundVar::from_u32(idx), kind: ty::BrAnon(idx) };\n                     self.named_regions.insert(_re.def_id, idx);\n                     self.tcx.mk_region(RegionKind::ReLateBound(self.binder_index, br))\n                 }"}, {"sha": "845375f3e322b71e3908157315e8e6a5417c21ac", "filename": "compiler/rustc_typeck/src/astconv/generics.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d5efa9f040d2638318f9e8b96eab718ef664e3c/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fgenerics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d5efa9f040d2638318f9e8b96eab718ef664e3c/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fgenerics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fgenerics.rs?ref=6d5efa9f040d2638318f9e8b96eab718ef664e3c", "patch": "@@ -166,7 +166,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         parent_substs: &[subst::GenericArg<'tcx>],\n         has_self: bool,\n         self_ty: Option<Ty<'tcx>>,\n-        arg_count: GenericArgCountResult,\n+        arg_count: &GenericArgCountResult,\n         ctx: &mut impl CreateSubstsForGenericArgsCtxt<'a, 'tcx>,\n     ) -> SubstsRef<'tcx> {\n         // Collect the segments of the path; we need to substitute arguments"}, {"sha": "8d55bc8f2f33b7134cf106ba655e42a2f56631db", "filename": "compiler/rustc_typeck/src/astconv/mod.rs", "status": "modified", "additions": 117, "deletions": 97, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/6d5efa9f040d2638318f9e8b96eab718ef664e3c/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d5efa9f040d2638318f9e8b96eab718ef664e3c/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs?ref=6d5efa9f040d2638318f9e8b96eab718ef664e3c", "patch": "@@ -210,14 +210,20 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         let r = match tcx.named_region(lifetime.hir_id) {\n             Some(rl::Region::Static) => tcx.lifetimes.re_static,\n \n-            Some(rl::Region::LateBound(debruijn, _, id, _)) => {\n-                let name = lifetime_name(id.expect_local());\n-                let br = ty::BoundRegion { kind: ty::BrNamed(id, name) };\n+            Some(rl::Region::LateBound(debruijn, index, def_id, _)) => {\n+                let name = lifetime_name(def_id.expect_local());\n+                let br = ty::BoundRegion {\n+                    var: ty::BoundVar::from_u32(index),\n+                    kind: ty::BrNamed(def_id, name),\n+                };\n                 tcx.mk_region(ty::ReLateBound(debruijn, br))\n             }\n \n-            Some(rl::Region::LateBoundAnon(debruijn, _index, anon_index)) => {\n-                let br = ty::BoundRegion { kind: ty::BrAnon(anon_index) };\n+            Some(rl::Region::LateBoundAnon(debruijn, index, anon_index)) => {\n+                let br = ty::BoundRegion {\n+                    var: ty::BoundVar::from_u32(index),\n+                    kind: ty::BrAnon(anon_index),\n+                };\n                 tcx.mk_region(ty::ReLateBound(debruijn, br))\n             }\n \n@@ -266,7 +272,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         def_id: DefId,\n         item_segment: &hir::PathSegment<'_>,\n     ) -> SubstsRef<'tcx> {\n-        let (substs, assoc_bindings, _) = self.create_substs_for_ast_path(\n+        let (substs, _) = self.create_substs_for_ast_path(\n             span,\n             def_id,\n             &[],\n@@ -275,6 +281,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             item_segment.infer_args,\n             None,\n         );\n+        let assoc_bindings = self.create_assoc_bindings_for_generic_args(item_segment.args());\n \n         if let Some(b) = assoc_bindings.first() {\n             Self::prohibit_assoc_ty_binding(self.tcx(), b.span);\n@@ -314,6 +321,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     /// `[Vec<u8>, u8]` and `generic_args` are the arguments for the associated\n     /// type itself: `['a]`. The returned `SubstsRef` concatenates these two\n     /// lists: `[Vec<u8>, u8, 'a]`.\n+    #[tracing::instrument(level = \"debug\", skip(self, span))]\n     fn create_substs_for_ast_path<'a>(\n         &self,\n         span: Span,\n@@ -323,15 +331,10 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         generic_args: &'a hir::GenericArgs<'_>,\n         infer_args: bool,\n         self_ty: Option<Ty<'tcx>>,\n-    ) -> (SubstsRef<'tcx>, Vec<ConvertedBinding<'a, 'tcx>>, GenericArgCountResult) {\n+    ) -> (SubstsRef<'tcx>, GenericArgCountResult) {\n         // If the type is parameterized by this region, then replace this\n         // region with the current anon region binding (in other words,\n         // whatever & would get replaced with).\n-        debug!(\n-            \"create_substs_for_ast_path(def_id={:?}, self_ty={:?}, \\\n-                generic_args={:?})\",\n-            def_id, self_ty, generic_args\n-        );\n \n         let tcx = self.tcx();\n         let generics = tcx.generics_of(def_id);\n@@ -367,7 +370,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         // here and so associated type bindings will be handled regardless of whether there are any\n         // non-`Self` generic parameters.\n         if generics.params.len() == 0 {\n-            return (tcx.intern_substs(&[]), vec![], arg_count);\n+            return (tcx.intern_substs(&[]), arg_count);\n         }\n \n         let is_object = self_ty.map_or(false, |ty| ty == self.tcx().types.trait_object_dummy_self);\n@@ -540,7 +543,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             parent_substs,\n             self_ty.is_some(),\n             self_ty,\n-            arg_count.clone(),\n+            &arg_count,\n             &mut substs_ctx,\n         );\n \n@@ -551,6 +554,18 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             generic_args.args.is_empty(),\n         );\n \n+        debug!(\n+            \"create_substs_for_ast_path(generic_params={:?}, self_ty={:?}) -> {:?}\",\n+            generics, self_ty, substs\n+        );\n+\n+        (substs, arg_count)\n+    }\n+\n+    fn create_assoc_bindings_for_generic_args<'a>(\n+        &self,\n+        generic_args: &'a hir::GenericArgs<'_>,\n+    ) -> Vec<ConvertedBinding<'a, 'tcx>> {\n         // Convert associated-type bindings or constraints into a separate vector.\n         // Example: Given this:\n         //\n@@ -581,12 +596,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             })\n             .collect();\n \n-        debug!(\n-            \"create_substs_for_ast_path(generic_params={:?}, self_ty={:?}) -> {:?}\",\n-            generics, self_ty, substs\n-        );\n-\n-        (substs, assoc_bindings, arg_count)\n+        assoc_bindings\n     }\n \n     crate fn create_substs_for_associated_item(\n@@ -636,8 +646,27 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         )\n     }\n \n-    /// The given trait-ref must actually be a trait.\n-    pub(super) fn instantiate_poly_trait_ref_inner(\n+    /// Given a trait bound like `Debug`, applies that trait bound the given self-type to construct\n+    /// a full trait reference. The resulting trait reference is returned. This may also generate\n+    /// auxiliary bounds, which are added to `bounds`.\n+    ///\n+    /// Example:\n+    ///\n+    /// ```\n+    /// poly_trait_ref = Iterator<Item = u32>\n+    /// self_ty = Foo\n+    /// ```\n+    ///\n+    /// this would return `Foo: Iterator` and add `<Foo as Iterator>::Item = u32` into `bounds`.\n+    ///\n+    /// **A note on binders:** against our usual convention, there is an implied bounder around\n+    /// the `self_ty` and `poly_trait_ref` parameters here. So they may reference bound regions.\n+    /// If for example you had `for<'a> Foo<'a>: Bar<'a>`, then the `self_ty` would be `Foo<'a>`\n+    /// where `'a` is a bound region at depth 0. Similarly, the `poly_trait_ref` would be\n+    /// `Bar<'a>`. The returned poly-trait-ref will have this binder instantiated explicitly,\n+    /// however.\n+    #[tracing::instrument(level = \"debug\", skip(self, span, constness, bounds, speculative))]\n+    pub fn instantiate_poly_trait_ref(\n         &self,\n         trait_ref: &hir::TraitRef<'_>,\n         span: Span,\n@@ -648,18 +677,25 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     ) -> GenericArgCountResult {\n         let trait_def_id = trait_ref.trait_def_id().unwrap_or_else(|| FatalError.raise());\n \n-        debug!(\"instantiate_poly_trait_ref({:?}, def_id={:?})\", trait_ref, trait_def_id);\n-\n         self.prohibit_generics(trait_ref.path.segments.split_last().unwrap().1);\n \n-        let (substs, assoc_bindings, arg_count) = self.create_substs_for_ast_trait_ref(\n+        let tcx = self.tcx();\n+        let bound_vars = tcx.late_bound_vars(trait_ref.hir_ref_id);\n+        debug!(?bound_vars);\n+\n+        let (substs, arg_count) = self.create_substs_for_ast_trait_ref(\n             trait_ref.path.span,\n             trait_def_id,\n             self_ty,\n             trait_ref.path.segments.last().unwrap(),\n         );\n-        let poly_trait_ref = ty::Binder::bind(ty::TraitRef::new(trait_def_id, substs), self.tcx());\n+        let assoc_bindings = self\n+            .create_assoc_bindings_for_generic_args(trait_ref.path.segments.last().unwrap().args());\n+\n+        let poly_trait_ref =\n+            ty::Binder::bind_with_vars(ty::TraitRef::new(trait_def_id, substs), bound_vars);\n \n+        debug!(?poly_trait_ref, ?assoc_bindings);\n         bounds.trait_bounds.push((poly_trait_ref, span, constness));\n \n         let mut dup_bindings = FxHashMap::default();\n@@ -677,50 +713,9 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             // Okay to ignore `Err` because of `ErrorReported` (see above).\n         }\n \n-        debug!(\n-            \"instantiate_poly_trait_ref({:?}, bounds={:?}) -> {:?}\",\n-            trait_ref, bounds, poly_trait_ref\n-        );\n-\n         arg_count\n     }\n \n-    /// Given a trait bound like `Debug`, applies that trait bound the given self-type to construct\n-    /// a full trait reference. The resulting trait reference is returned. This may also generate\n-    /// auxiliary bounds, which are added to `bounds`.\n-    ///\n-    /// Example:\n-    ///\n-    /// ```\n-    /// poly_trait_ref = Iterator<Item = u32>\n-    /// self_ty = Foo\n-    /// ```\n-    ///\n-    /// this would return `Foo: Iterator` and add `<Foo as Iterator>::Item = u32` into `bounds`.\n-    ///\n-    /// **A note on binders:** against our usual convention, there is an implied bounder around\n-    /// the `self_ty` and `poly_trait_ref` parameters here. So they may reference bound regions.\n-    /// If for example you had `for<'a> Foo<'a>: Bar<'a>`, then the `self_ty` would be `Foo<'a>`\n-    /// where `'a` is a bound region at depth 0. Similarly, the `poly_trait_ref` would be\n-    /// `Bar<'a>`. The returned poly-trait-ref will have this binder instantiated explicitly,\n-    /// however.\n-    pub fn instantiate_poly_trait_ref(\n-        &self,\n-        poly_trait_ref: &hir::PolyTraitRef<'_>,\n-        constness: Constness,\n-        self_ty: Ty<'tcx>,\n-        bounds: &mut Bounds<'tcx>,\n-    ) -> GenericArgCountResult {\n-        self.instantiate_poly_trait_ref_inner(\n-            &poly_trait_ref.trait_ref,\n-            poly_trait_ref.span,\n-            constness,\n-            self_ty,\n-            bounds,\n-            false,\n-        )\n-    }\n-\n     pub fn instantiate_lang_item_trait_ref(\n         &self,\n         lang_item: hir::LangItem,\n@@ -732,7 +727,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     ) {\n         let trait_def_id = self.tcx().require_lang_item(lang_item, Some(span));\n \n-        let (substs, assoc_bindings, _) = self.create_substs_for_ast_path(\n+        let (substs, _) = self.create_substs_for_ast_path(\n             span,\n             trait_def_id,\n             &[],\n@@ -741,7 +736,11 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             false,\n             Some(self_ty),\n         );\n-        let poly_trait_ref = ty::Binder::bind(ty::TraitRef::new(trait_def_id, substs), self.tcx());\n+        let assoc_bindings = self.create_assoc_bindings_for_generic_args(args);\n+        let tcx = self.tcx();\n+        let bound_vars = tcx.late_bound_vars(hir_id);\n+        let poly_trait_ref =\n+            ty::Binder::bind_with_vars(ty::TraitRef::new(trait_def_id, substs), bound_vars);\n         bounds.trait_bounds.push((poly_trait_ref, span, Constness::NotConst));\n \n         let mut dup_bindings = FxHashMap::default();\n@@ -765,23 +764,23 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         self_ty: Ty<'tcx>,\n         trait_segment: &hir::PathSegment<'_>,\n     ) -> ty::TraitRef<'tcx> {\n-        let (substs, assoc_bindings, _) =\n+        let (substs, _) =\n             self.create_substs_for_ast_trait_ref(span, trait_def_id, self_ty, trait_segment);\n+        let assoc_bindings = self.create_assoc_bindings_for_generic_args(trait_segment.args());\n         if let Some(b) = assoc_bindings.first() {\n             Self::prohibit_assoc_ty_binding(self.tcx(), b.span);\n         }\n         ty::TraitRef::new(trait_def_id, substs)\n     }\n \n+    #[tracing::instrument(level = \"debug\", skip(self, span))]\n     fn create_substs_for_ast_trait_ref<'a>(\n         &self,\n         span: Span,\n         trait_def_id: DefId,\n         self_ty: Ty<'tcx>,\n         trait_segment: &'a hir::PathSegment<'a>,\n-    ) -> (SubstsRef<'tcx>, Vec<ConvertedBinding<'a, 'tcx>>, GenericArgCountResult) {\n-        debug!(\"create_substs_for_ast_trait_ref(trait_segment={:?})\", trait_segment);\n-\n+    ) -> (SubstsRef<'tcx>, GenericArgCountResult) {\n         self.complain_about_internal_fn_trait(span, trait_def_id, trait_segment);\n \n         self.create_substs_for_ast_path(\n@@ -803,7 +802,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     }\n \n     // Returns `true` if a bounds list includes `?Sized`.\n-    pub fn is_unsized(&self, ast_bounds: &[&hir::GenericBound<'_>], span: Span) -> bool {\n+    pub fn is_unsized(&self, ast_bounds: &[hir::GenericBound<'_>], span: Span) -> bool {\n         let tcx = self.tcx();\n \n         // Try to find an unbound in bounds.\n@@ -858,28 +857,44 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     /// **A note on binders:** there is an implied binder around\n     /// `param_ty` and `ast_bounds`. See `instantiate_poly_trait_ref`\n     /// for more details.\n+    #[tracing::instrument(level = \"debug\", skip(self, bounds))]\n     fn add_bounds(\n         &self,\n         param_ty: Ty<'tcx>,\n-        ast_bounds: &[&hir::GenericBound<'_>],\n+        ast_bounds: &[hir::GenericBound<'_>],\n         bounds: &mut Bounds<'tcx>,\n+        bound_vars: &'tcx ty::List<ty::BoundVariableKind>,\n     ) {\n         let constness = self.default_constness_for_trait_bounds();\n         for ast_bound in ast_bounds {\n             match *ast_bound {\n                 hir::GenericBound::Trait(ref b, hir::TraitBoundModifier::None) => {\n-                    self.instantiate_poly_trait_ref(b, constness, param_ty, bounds);\n+                    self.instantiate_poly_trait_ref(\n+                        &b.trait_ref,\n+                        b.span,\n+                        constness,\n+                        param_ty,\n+                        bounds,\n+                        false,\n+                    );\n                 }\n                 hir::GenericBound::Trait(ref b, hir::TraitBoundModifier::MaybeConst) => {\n-                    self.instantiate_poly_trait_ref(b, Constness::NotConst, param_ty, bounds);\n+                    self.instantiate_poly_trait_ref(\n+                        &b.trait_ref,\n+                        b.span,\n+                        Constness::NotConst,\n+                        param_ty,\n+                        bounds,\n+                        false,\n+                    );\n                 }\n                 hir::GenericBound::Trait(_, hir::TraitBoundModifier::Maybe) => {}\n                 hir::GenericBound::LangItemTrait(lang_item, span, hir_id, args) => self\n                     .instantiate_lang_item_trait_ref(\n-                        *lang_item, *span, *hir_id, args, param_ty, bounds,\n+                        lang_item, span, hir_id, args, param_ty, bounds,\n                     ),\n                 hir::GenericBound::Outlives(ref l) => bounds.region_bounds.push((\n-                    ty::Binder::bind(self.ast_region_to_region(l, None), self.tcx()),\n+                    ty::Binder::bind_with_vars(self.ast_region_to_region(l, None), bound_vars),\n                     l.span,\n                 )),\n             }\n@@ -909,7 +924,6 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         sized_by_default: SizedByDefault,\n         span: Span,\n     ) -> Bounds<'tcx> {\n-        let ast_bounds: Vec<_> = ast_bounds.iter().collect();\n         self.compute_bounds_inner(param_ty, &ast_bounds, sized_by_default, span)\n     }\n \n@@ -929,7 +943,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             if let Some(trait_ref) = ast_bound.trait_ref() {\n                 if let Some(trait_did) = trait_ref.trait_def_id() {\n                     if self.tcx().trait_may_define_assoc_type(trait_did, assoc_name) {\n-                        result.push(ast_bound);\n+                        result.push(ast_bound.clone());\n                     }\n                 }\n             }\n@@ -941,13 +955,13 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     fn compute_bounds_inner(\n         &self,\n         param_ty: Ty<'tcx>,\n-        ast_bounds: &[&hir::GenericBound<'_>],\n+        ast_bounds: &[hir::GenericBound<'_>],\n         sized_by_default: SizedByDefault,\n         span: Span,\n     ) -> Bounds<'tcx> {\n         let mut bounds = Bounds::default();\n \n-        self.add_bounds(param_ty, ast_bounds, &mut bounds);\n+        self.add_bounds(param_ty, ast_bounds, &mut bounds, ty::List::empty());\n \n         bounds.implicitly_sized = if let SizedByDefault::Yes = sized_by_default {\n             if !self.is_unsized(ast_bounds, span) { Some(span) } else { None }\n@@ -964,6 +978,10 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n     /// **A note on binders:** given something like `T: for<'a> Iterator<Item = &'a u32>`, the\n     /// `trait_ref` here will be `for<'a> T: Iterator`. The `binding` data however is from *inside*\n     /// the binder (e.g., `&'a u32`) and hence may reference bound regions.\n+    #[tracing::instrument(\n+        level = \"debug\",\n+        skip(self, bounds, speculative, dup_bindings, path_span)\n+    )]\n     fn add_predicates_for_ast_type_binding(\n         &self,\n         hir_ref_id: hir::HirId,\n@@ -990,7 +1008,6 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         //\n         // We want to produce `<B as SuperTrait<i32>>::T == foo`.\n \n-        debug!(?hir_ref_id, ?trait_ref, ?binding, ?bounds, \"add_predicates_for_ast_type_binding\",);\n         let tcx = self.tcx();\n \n         let candidate =\n@@ -1140,10 +1157,8 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 //\n                 // Calling `skip_binder` is okay, because `add_bounds` expects the `param_ty`\n                 // parameter to have a skipped binder.\n-                let param_ty =\n-                    tcx.mk_projection(assoc_ty.def_id, projection_ty.skip_binder().substs);\n-                let ast_bounds: Vec<_> = ast_bounds.iter().collect();\n-                self.add_bounds(param_ty, &ast_bounds, bounds);\n+                let param_ty = tcx.mk_ty(ty::Projection(projection_ty.skip_binder()));\n+                self.add_bounds(param_ty, ast_bounds, bounds, candidate.bound_vars());\n             }\n         }\n         Ok(())\n@@ -1177,10 +1192,12 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     Err(GenericArgCountMismatch { invalid_args: cur_potential_assoc_types, .. }),\n                 ..\n             } = self.instantiate_poly_trait_ref(\n-                trait_bound,\n+                &trait_bound.trait_ref,\n+                trait_bound.span,\n                 Constness::NotConst,\n                 dummy_self,\n                 &mut bounds,\n+                false,\n             ) {\n                 potential_assoc_types.extend(cur_potential_assoc_types);\n             }\n@@ -2169,12 +2186,13 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         }\n     }\n \n-    /// Parses the programmer's textual representation of a type into our\n-    /// internal notion of a type.\n     pub fn ast_ty_to_ty(&self, ast_ty: &hir::Ty<'_>) -> Ty<'tcx> {\n         self.ast_ty_to_ty_inner(ast_ty, false)\n     }\n \n+    /// Parses the programmer's textual representation of a type into our\n+    /// internal notion of a type.\n+    ///\n     /// Turns a `hir::Ty` into a `Ty`. For diagnostics' purposes we keep track of whether trait\n     /// objects are borrowed like `&dyn Trait` to avoid emitting redundant errors.\n     #[tracing::instrument(level = \"debug\", skip(self))]\n@@ -2200,6 +2218,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                 require_c_abi_if_c_variadic(tcx, &bf.decl, bf.abi, ast_ty.span);\n \n                 tcx.mk_fn_ptr(self.ty_of_fn(\n+                    ast_ty.hir_id,\n                     bf.unsafety,\n                     bf.abi,\n                     &bf.decl,\n@@ -2242,7 +2261,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n             }\n             hir::TyKind::Path(hir::QPath::LangItem(lang_item, span)) => {\n                 let def_id = tcx.require_lang_item(lang_item, Some(span));\n-                let (substs, _, _) = self.create_substs_for_ast_path(\n+                let (substs, _) = self.create_substs_for_ast_path(\n                     span,\n                     def_id,\n                     &[],\n@@ -2279,7 +2298,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         result_ty\n     }\n \n-    pub fn impl_trait_ty_to_ty(\n+    fn impl_trait_ty_to_ty(\n         &self,\n         def_id: DefId,\n         lifetimes: &[hir::GenericArg<'_>],\n@@ -2340,6 +2359,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n     pub fn ty_of_fn(\n         &self,\n+        hir_id: hir::HirId,\n         unsafety: hir::Unsafety,\n         abi: abi::Abi,\n         decl: &hir::FnDecl<'_>,\n@@ -2350,6 +2370,8 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n         debug!(\"ty_of_fn\");\n \n         let tcx = self.tcx();\n+        let bound_vars = tcx.late_bound_vars(hir_id);\n+        debug!(?bound_vars);\n \n         // We proactively collect all the inferred type params to emit a single error per fn def.\n         let mut visitor = PlaceholderHirTyCollector::default();\n@@ -2369,10 +2391,8 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n \n         debug!(\"ty_of_fn: output_ty={:?}\", output_ty);\n \n-        let bare_fn_ty = ty::Binder::bind(\n-            tcx.mk_fn_sig(input_tys, output_ty, decl.c_variadic, unsafety, abi),\n-            tcx,\n-        );\n+        let fn_ty = tcx.mk_fn_sig(input_tys, output_ty, decl.c_variadic, unsafety, abi);\n+        let bare_fn_ty = ty::Binder::bind_with_vars(fn_ty, bound_vars);\n \n         if !self.allow_ty_infer() {\n             // We always collect the spans for placeholder types when evaluating `fn`s, but we"}, {"sha": "22d3dc6bdc0c0b7f31b0da7f6d2116658117d379", "filename": "compiler/rustc_typeck/src/check/closure.rs", "status": "modified", "additions": 23, "deletions": 10, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/6d5efa9f040d2638318f9e8b96eab718ef664e3c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d5efa9f040d2638318f9e8b96eab718ef664e3c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs?ref=6d5efa9f040d2638318f9e8b96eab718ef664e3c", "patch": "@@ -69,7 +69,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         let expr_def_id = self.tcx.hir().local_def_id(expr.hir_id);\n \n         let ClosureSignatures { bound_sig, liberated_sig } =\n-            self.sig_of_closure(expr_def_id.to_def_id(), decl, body, expected_sig);\n+            self.sig_of_closure(expr.hir_id, expr_def_id.to_def_id(), decl, body, expected_sig);\n \n         debug!(\"check_closure: ty_of_closure returns {:?}\", liberated_sig);\n \n@@ -288,29 +288,31 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n \n     fn sig_of_closure(\n         &self,\n+        hir_id: hir::HirId,\n         expr_def_id: DefId,\n         decl: &hir::FnDecl<'_>,\n         body: &hir::Body<'_>,\n         expected_sig: Option<ExpectedSig<'tcx>>,\n     ) -> ClosureSignatures<'tcx> {\n         if let Some(e) = expected_sig {\n-            self.sig_of_closure_with_expectation(expr_def_id, decl, body, e)\n+            self.sig_of_closure_with_expectation(hir_id, expr_def_id, decl, body, e)\n         } else {\n-            self.sig_of_closure_no_expectation(expr_def_id, decl, body)\n+            self.sig_of_closure_no_expectation(hir_id, expr_def_id, decl, body)\n         }\n     }\n \n     /// If there is no expected signature, then we will convert the\n     /// types that the user gave into a signature.\n     fn sig_of_closure_no_expectation(\n         &self,\n+        hir_id: hir::HirId,\n         expr_def_id: DefId,\n         decl: &hir::FnDecl<'_>,\n         body: &hir::Body<'_>,\n     ) -> ClosureSignatures<'tcx> {\n         debug!(\"sig_of_closure_no_expectation()\");\n \n-        let bound_sig = self.supplied_sig_of_closure(expr_def_id, decl, body);\n+        let bound_sig = self.supplied_sig_of_closure(hir_id, expr_def_id, decl, body);\n \n         self.closure_sigs(expr_def_id, body, bound_sig)\n     }\n@@ -364,6 +366,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     ///   regions with depth 1, which are bound then by the closure.\n     fn sig_of_closure_with_expectation(\n         &self,\n+        hir_id: hir::HirId,\n         expr_def_id: DefId,\n         decl: &hir::FnDecl<'_>,\n         body: &hir::Body<'_>,\n@@ -375,7 +378,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // expectation if things don't see to match up with what we\n         // expect.\n         if expected_sig.sig.c_variadic() != decl.c_variadic {\n-            return self.sig_of_closure_no_expectation(expr_def_id, decl, body);\n+            return self.sig_of_closure_no_expectation(hir_id, expr_def_id, decl, body);\n         } else if expected_sig.sig.skip_binder().inputs_and_output.len() != decl.inputs.len() + 1 {\n             return self.sig_of_closure_with_mismatched_number_of_arguments(\n                 expr_def_id,\n@@ -411,9 +414,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // Along the way, it also writes out entries for types that the user\n         // wrote into our typeck results, which are then later used by the privacy\n         // check.\n-        match self.check_supplied_sig_against_expectation(expr_def_id, decl, body, &closure_sigs) {\n+        match self.check_supplied_sig_against_expectation(\n+            hir_id,\n+            expr_def_id,\n+            decl,\n+            body,\n+            &closure_sigs,\n+        ) {\n             Ok(infer_ok) => self.register_infer_ok_obligations(infer_ok),\n-            Err(_) => return self.sig_of_closure_no_expectation(expr_def_id, decl, body),\n+            Err(_) => return self.sig_of_closure_no_expectation(hir_id, expr_def_id, decl, body),\n         }\n \n         closure_sigs\n@@ -460,6 +469,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// strategy.\n     fn check_supplied_sig_against_expectation(\n         &self,\n+        hir_id: hir::HirId,\n         expr_def_id: DefId,\n         decl: &hir::FnDecl<'_>,\n         body: &hir::Body<'_>,\n@@ -469,7 +479,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         //\n         // (See comment on `sig_of_closure_with_expectation` for the\n         // meaning of these letters.)\n-        let supplied_sig = self.supplied_sig_of_closure(expr_def_id, decl, body);\n+        let supplied_sig = self.supplied_sig_of_closure(hir_id, expr_def_id, decl, body);\n \n         debug!(\"check_supplied_sig_against_expectation: supplied_sig={:?}\", supplied_sig);\n \n@@ -534,6 +544,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n     /// Also, record this closure signature for later.\n     fn supplied_sig_of_closure(\n         &self,\n+        hir_id: hir::HirId,\n         expr_def_id: DefId,\n         decl: &hir::FnDecl<'_>,\n         body: &hir::Body<'_>,\n@@ -545,6 +556,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             decl, body.generator_kind,\n         );\n \n+        let bound_vars = self.tcx.late_bound_vars(hir_id);\n+\n         // First, convert the types that the user supplied (if any).\n         let supplied_arguments = decl.inputs.iter().map(|a| astconv.ast_ty_to_ty(a));\n         let supplied_return = match decl.output {\n@@ -571,15 +584,15 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             },\n         };\n \n-        let result = ty::Binder::bind(\n+        let result = ty::Binder::bind_with_vars(\n             self.tcx.mk_fn_sig(\n                 supplied_arguments,\n                 supplied_return,\n                 decl.c_variadic,\n                 hir::Unsafety::Normal,\n                 Abi::RustCall,\n             ),\n-            self.tcx,\n+            bound_vars,\n         );\n \n         debug!(\"supplied_sig_of_closure: result={:?}\", result);"}, {"sha": "9ace455042103559b738507ab3009ada6ebe0143", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d5efa9f040d2638318f9e8b96eab718ef664e3c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d5efa9f040d2638318f9e8b96eab718ef664e3c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs?ref=6d5efa9f040d2638318f9e8b96eab718ef664e3c", "patch": "@@ -1462,7 +1462,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 &[][..],\n                 has_self,\n                 self_ty,\n-                arg_count,\n+                &arg_count,\n                 &mut CreateCtorSubstsContext {\n                     fcx: self,\n                     span,"}, {"sha": "e40aa914858586b6ec7814307e8addd43c048acf", "filename": "compiler/rustc_typeck/src/check/generator_interior.rs", "status": "modified", "additions": 10, "deletions": 3, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/6d5efa9f040d2638318f9e8b96eab718ef664e3c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d5efa9f040d2638318f9e8b96eab718ef664e3c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fgenerator_interior.rs?ref=6d5efa9f040d2638318f9e8b96eab718ef664e3c", "patch": "@@ -186,7 +186,10 @@ pub fn resolve_interior<'a, 'tcx>(\n                 // which means that none of the regions inside relate to any other, even if\n                 // typeck had previously found constraints that would cause them to be related.\n                 let folded = fcx.tcx.fold_regions(erased, &mut false, |_, current_depth| {\n-                    let br = ty::BoundRegion { kind: ty::BrAnon(counter) };\n+                    let br = ty::BoundRegion {\n+                        var: ty::BoundVar::from_u32(counter),\n+                        kind: ty::BrAnon(counter),\n+                    };\n                     let r = fcx.tcx.mk_region(ty::ReLateBound(current_depth, br));\n                     counter += 1;\n                     r\n@@ -202,11 +205,15 @@ pub fn resolve_interior<'a, 'tcx>(\n \n     // Extract type components to build the witness type.\n     let type_list = fcx.tcx.mk_type_list(type_causes.iter().map(|cause| cause.ty));\n-    let witness = fcx.tcx.mk_generator_witness(ty::Binder::bind(type_list, fcx.tcx));\n+    let bound_vars = fcx.tcx.mk_bound_variable_kinds(\n+        (0..counter).map(|i| ty::BoundVariableKind::Region(ty::BrAnon(i))),\n+    );\n+    let witness =\n+        fcx.tcx.mk_generator_witness(ty::Binder::bind_with_vars(type_list, bound_vars.clone()));\n \n     // Store the generator types and spans into the typeck results for this generator.\n     visitor.fcx.inh.typeck_results.borrow_mut().generator_interior_types =\n-        ty::Binder::bind(type_causes, fcx.tcx);\n+        ty::Binder::bind_with_vars(type_causes, bound_vars);\n \n     debug!(\n         \"types in generator after region replacement {:?}, span = {:?}\","}, {"sha": "303a77507cf7bc84a3fc1e1a341e0e1d828e44c2", "filename": "compiler/rustc_typeck/src/check/intrinsic.rs", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/6d5efa9f040d2638318f9e8b96eab718ef664e3c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d5efa9f040d2638318f9e8b96eab718ef664e3c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fintrinsic.rs?ref=6d5efa9f040d2638318f9e8b96eab718ef664e3c", "patch": "@@ -101,12 +101,21 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n     let intrinsic_name = tcx.item_name(it.def_id.to_def_id());\n     let name_str = intrinsic_name.as_str();\n \n+    let bound_vars = tcx.mk_bound_variable_kinds(\n+        [ty::BoundVariableKind::Region(ty::BrAnon(0)), ty::BoundVariableKind::Region(ty::BrEnv)]\n+            .iter()\n+            .copied(),\n+    );\n     let mk_va_list_ty = |mutbl| {\n         tcx.lang_items().va_list().map(|did| {\n-            let region = tcx\n-                .mk_region(ty::ReLateBound(ty::INNERMOST, ty::BoundRegion { kind: ty::BrAnon(0) }));\n-            let env_region =\n-                tcx.mk_region(ty::ReLateBound(ty::INNERMOST, ty::BoundRegion { kind: ty::BrEnv }));\n+            let region = tcx.mk_region(ty::ReLateBound(\n+                ty::INNERMOST,\n+                ty::BoundRegion { var: ty::BoundVar::from_u32(0), kind: ty::BrAnon(0) },\n+            ));\n+            let env_region = tcx.mk_region(ty::ReLateBound(\n+                ty::INNERMOST,\n+                ty::BoundRegion { var: ty::BoundVar::from_u32(1), kind: ty::BrEnv },\n+            ));\n             let va_list_ty = tcx.type_of(did).subst(tcx, &[region.into()]);\n             (tcx.mk_ref(env_region, ty::TypeAndMut { ty: va_list_ty, mutbl }), va_list_ty)\n         })\n@@ -305,7 +314,7 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n                     tcx.associated_items(tcx.lang_items().discriminant_kind_trait().unwrap());\n                 let discriminant_def_id = assoc_items.in_definition_order().next().unwrap().def_id;\n \n-                let br = ty::BoundRegion { kind: ty::BrAnon(0) };\n+                let br = ty::BoundRegion { var: ty::BoundVar::from_u32(0), kind: ty::BrAnon(0) };\n                 (\n                     1,\n                     vec![\n@@ -366,7 +375,7 @@ pub fn check_intrinsic_type(tcx: TyCtxt<'_>, it: &hir::ForeignItem<'_>) {\n         (n_tps, inputs, output, unsafety)\n     };\n     let sig = tcx.mk_fn_sig(inputs.into_iter(), output, false, unsafety, Abi::RustIntrinsic);\n-    let sig = ty::Binder::bind(sig, tcx);\n+    let sig = ty::Binder::bind_with_vars(sig, bound_vars);\n     equate_intrinsic_type(tcx, it, n_tps, sig)\n }\n "}, {"sha": "f546a0d8963544883282aa0140b2783663681ee1", "filename": "compiler/rustc_typeck/src/check/method/confirm.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d5efa9f040d2638318f9e8b96eab718ef664e3c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d5efa9f040d2638318f9e8b96eab718ef664e3c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fconfirm.rs?ref=6d5efa9f040d2638318f9e8b96eab718ef664e3c", "patch": "@@ -381,7 +381,7 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n             parent_substs,\n             false,\n             None,\n-            arg_count_correct,\n+            &arg_count_correct,\n             &mut MethodSubstsCtxt { cfcx: self, pick, seg },\n         )\n     }"}, {"sha": "0760d59875c701ace0864a9cddea7a98e7783dd6", "filename": "compiler/rustc_typeck/src/check/mod.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/6d5efa9f040d2638318f9e8b96eab718ef664e3c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d5efa9f040d2638318f9e8b96eab718ef664e3c/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs?ref=6d5efa9f040d2638318f9e8b96eab718ef664e3c", "patch": "@@ -497,6 +497,7 @@ fn typeck_with_fallback<'tcx>(\n                 let fcx = FnCtxt::new(&inh, param_env, body.value.hir_id);\n                 <dyn AstConv<'_>>::ty_of_fn(\n                     &fcx,\n+                    id,\n                     header.unsafety,\n                     header.abi,\n                     decl,"}, {"sha": "afe52c977334d5414cec747e3fe875f9650db7d8", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 20, "deletions": 6, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/6d5efa9f040d2638318f9e8b96eab718ef664e3c/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d5efa9f040d2638318f9e8b96eab718ef664e3c/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=6d5efa9f040d2638318f9e8b96eab718ef664e3c", "patch": "@@ -1712,6 +1712,7 @@ fn fn_sig(tcx: TyCtxt<'_>, def_id: DefId) -> ty::PolyFnSig<'_> {\n                 }\n                 None => <dyn AstConv<'_>>::ty_of_fn(\n                     &icx,\n+                    hir_id,\n                     sig.header.unsafety,\n                     sig.header.abi,\n                     &sig.decl,\n@@ -1729,6 +1730,7 @@ fn fn_sig(tcx: TyCtxt<'_>, def_id: DefId) -> ty::PolyFnSig<'_> {\n             ..\n         }) => <dyn AstConv<'_>>::ty_of_fn(\n             &icx,\n+            hir_id,\n             header.unsafety,\n             header.abi,\n             decl,\n@@ -2082,6 +2084,7 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericP\n         match predicate {\n             hir::WherePredicate::BoundPredicate(bound_pred) => {\n                 let ty = icx.to_ty(&bound_pred.bounded_ty);\n+                let bound_vars = icx.tcx.late_bound_vars(bound_pred.bounded_ty.hir_id);\n \n                 // Keep the type around in a dummy predicate, in case of no bounds.\n                 // That way, `where Ty:` is not a complete noop (see #53696) and `Ty`\n@@ -2097,12 +2100,12 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericP\n                     } else {\n                         let span = bound_pred.bounded_ty.span;\n                         let re_root_empty = tcx.lifetimes.re_root_empty;\n-                        let predicate = ty::Binder::bind(\n+                        let predicate = ty::Binder::bind_with_vars(\n                             ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(\n                                 ty,\n                                 re_root_empty,\n                             )),\n-                            tcx,\n+                            bound_vars,\n                         );\n                         predicates.insert((predicate.to_predicate(tcx), span));\n                     }\n@@ -2120,10 +2123,12 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericP\n                             let mut bounds = Bounds::default();\n                             let _ = <dyn AstConv<'_>>::instantiate_poly_trait_ref(\n                                 &icx,\n-                                &poly_trait_ref,\n+                                &poly_trait_ref.trait_ref,\n+                                poly_trait_ref.span,\n                                 constness,\n                                 ty,\n                                 &mut bounds,\n+                                false,\n                             );\n                             predicates.extend(bounds.predicates(tcx, ty));\n                         }\n@@ -2146,11 +2151,11 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericP\n                             let region =\n                                 <dyn AstConv<'_>>::ast_region_to_region(&icx, lifetime, None);\n                             predicates.insert((\n-                                ty::Binder::bind(\n+                                ty::Binder::bind_with_vars(\n                                     ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(\n                                         ty, region,\n                                     )),\n-                                    tcx,\n+                                    bound_vars,\n                                 )\n                                 .to_predicate(tcx),\n                                 lifetime.span,\n@@ -2373,7 +2378,14 @@ fn predicates_from_bound<'tcx>(\n             };\n \n             let mut bounds = Bounds::default();\n-            let _ = astconv.instantiate_poly_trait_ref(tr, constness, param_ty, &mut bounds);\n+            let _ = astconv.instantiate_poly_trait_ref(\n+                &tr.trait_ref,\n+                tr.span,\n+                constness,\n+                param_ty,\n+                &mut bounds,\n+                false,\n+            );\n             bounds.predicates(astconv.tcx(), param_ty)\n         }\n         hir::GenericBound::LangItemTrait(lang_item, span, hir_id, args) => {\n@@ -2409,8 +2421,10 @@ fn compute_sig_of_foreign_fn_decl<'tcx>(\n     } else {\n         hir::Unsafety::Unsafe\n     };\n+    let hir_id = tcx.hir().local_def_id_to_hir_id(def_id.expect_local());\n     let fty = <dyn AstConv<'_>>::ty_of_fn(\n         &ItemCtxt::new(tcx, def_id),\n+        hir_id,\n         unsafety,\n         abi,\n         decl,"}, {"sha": "4244d37232f2212312a4e3de4d21ef956aea375f", "filename": "compiler/rustc_typeck/src/lib.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6d5efa9f040d2638318f9e8b96eab718ef664e3c/compiler%2Frustc_typeck%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d5efa9f040d2638318f9e8b96eab718ef664e3c/compiler%2Frustc_typeck%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Flib.rs?ref=6d5efa9f040d2638318f9e8b96eab718ef664e3c", "patch": "@@ -430,7 +430,7 @@ pub fn hir_ty_to_ty<'tcx>(tcx: TyCtxt<'tcx>, hir_ty: &hir::Ty<'_>) -> Ty<'tcx> {\n     let env_node_id = tcx.hir().get_parent_item(hir_ty.hir_id);\n     let env_def_id = tcx.hir().local_def_id(env_node_id);\n     let item_cx = self::collect::ItemCtxt::new(tcx, env_def_id.to_def_id());\n-    item_cx.to_ty(hir_ty)\n+    AstConv::ast_ty_to_ty(&item_cx, hir_ty)\n }\n \n pub fn hir_trait_to_predicates<'tcx>(\n@@ -445,7 +445,7 @@ pub fn hir_trait_to_predicates<'tcx>(\n     let env_def_id = tcx.hir().local_def_id(env_hir_id);\n     let item_cx = self::collect::ItemCtxt::new(tcx, env_def_id.to_def_id());\n     let mut bounds = Bounds::default();\n-    let _ = <dyn AstConv<'_>>::instantiate_poly_trait_ref_inner(\n+    let _ = <dyn AstConv<'_>>::instantiate_poly_trait_ref(\n         &item_cx,\n         hir_trait,\n         DUMMY_SP,"}, {"sha": "217e899001ef9b23fef5b6797b76bfee48c1a0d2", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d5efa9f040d2638318f9e8b96eab718ef664e3c/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d5efa9f040d2638318f9e8b96eab718ef664e3c/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=6d5efa9f040d2638318f9e8b96eab718ef664e3c", "patch": "@@ -411,7 +411,7 @@ impl Clean<Option<Lifetime>> for ty::RegionKind {\n     fn clean(&self, _cx: &mut DocContext<'_>) -> Option<Lifetime> {\n         match *self {\n             ty::ReStatic => Some(Lifetime::statik()),\n-            ty::ReLateBound(_, ty::BoundRegion { kind: ty::BrNamed(_, name) }) => {\n+            ty::ReLateBound(_, ty::BoundRegion { kind: ty::BrNamed(_, name), .. }) => {\n                 Some(Lifetime(name))\n             }\n             ty::ReEarlyBound(ref data) => Some(Lifetime(data.name)),"}, {"sha": "60cbe9f376f01542f79debe868a8893a1cc13189", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d5efa9f040d2638318f9e8b96eab718ef664e3c/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d5efa9f040d2638318f9e8b96eab718ef664e3c/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=6d5efa9f040d2638318f9e8b96eab718ef664e3c", "patch": "@@ -97,7 +97,7 @@ fn external_generic_args(\n         .iter()\n         .filter_map(|kind| match kind.unpack() {\n             GenericArgKind::Lifetime(lt) => match lt {\n-                ty::ReLateBound(_, ty::BoundRegion { kind: ty::BrAnon(_) }) => {\n+                ty::ReLateBound(_, ty::BoundRegion { kind: ty::BrAnon(_), .. }) => {\n                     Some(GenericArg::Lifetime(Lifetime::elided()))\n                 }\n                 _ => lt.clean(cx).map(GenericArg::Lifetime),"}, {"sha": "c8530c70f78d2086e9ae31de93e8d8e1ab3738ec", "filename": "src/test/incremental/hashes/function_interfaces.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6d5efa9f040d2638318f9e8b96eab718ef664e3c/src%2Ftest%2Fincremental%2Fhashes%2Ffunction_interfaces.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d5efa9f040d2638318f9e8b96eab718ef664e3c/src%2Ftest%2Fincremental%2Fhashes%2Ffunction_interfaces.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Ffunction_interfaces.rs?ref=6d5efa9f040d2638318f9e8b96eab718ef664e3c", "patch": "@@ -118,7 +118,7 @@ pub fn type_parameter<T>() {}\n pub fn lifetime_parameter() {}\n \n #[cfg(not(cfail1))]\n-#[rustc_clean(cfg = \"cfail2\", except = \"hir_owner, hir_owner_nodes, generics_of\")]\n+#[rustc_clean(cfg = \"cfail2\", except = \"hir_owner, hir_owner_nodes, generics_of,fn_sig\")]\n #[rustc_clean(cfg = \"cfail3\")]\n pub fn lifetime_parameter<'a>() {}\n \n@@ -150,7 +150,7 @@ pub fn lifetime_bound<'a, T>() {}\n #[cfg(not(cfail1))]\n #[rustc_clean(\n     cfg = \"cfail2\",\n-    except = \"hir_owner, hir_owner_nodes, generics_of, type_of, predicates_of\"\n+    except = \"hir_owner, hir_owner_nodes, generics_of, type_of, predicates_of,fn_sig\"\n )]\n #[rustc_clean(cfg = \"cfail3\")]\n pub fn lifetime_bound<'a, T: 'a>() {}\n@@ -183,7 +183,7 @@ pub fn second_lifetime_bound<'a, 'b, T: 'a>() {}\n #[cfg(not(cfail1))]\n #[rustc_clean(\n     cfg = \"cfail2\",\n-    except = \"hir_owner, hir_owner_nodes, generics_of, type_of, predicates_of\"\n+    except = \"hir_owner, hir_owner_nodes, generics_of, type_of, predicates_of,fn_sig\"\n )]\n #[rustc_clean(cfg = \"cfail3\")]\n pub fn second_lifetime_bound<'a, 'b, T: 'a + 'b>() {}"}, {"sha": "ee7b258cec4edc71b764eeb017dff81404b15982", "filename": "src/test/incremental/hashes/inherent_impls.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/6d5efa9f040d2638318f9e8b96eab718ef664e3c/src%2Ftest%2Fincremental%2Fhashes%2Finherent_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d5efa9f040d2638318f9e8b96eab718ef664e3c/src%2Ftest%2Fincremental%2Fhashes%2Finherent_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fincremental%2Fhashes%2Finherent_impls.rs?ref=6d5efa9f040d2638318f9e8b96eab718ef664e3c", "patch": "@@ -312,7 +312,7 @@ impl Foo {\n     // if we lower generics before the body, then the `HirId` for\n     // things in the body will be affected. So if you start to see\n     // `typeck` appear dirty, that might be the cause. -nmatsakis\n-    #[rustc_clean(cfg=\"cfail2\", except=\"hir_owner,hir_owner_nodes\")]\n+    #[rustc_clean(cfg=\"cfail2\", except=\"hir_owner,hir_owner_nodes,fn_sig\")]\n     #[rustc_clean(cfg=\"cfail3\")]\n     pub fn add_lifetime_parameter_to_method<'a>(&self) { }\n }\n@@ -360,7 +360,7 @@ impl Foo {\n impl Foo {\n     #[rustc_clean(\n         cfg=\"cfail2\",\n-        except=\"hir_owner,hir_owner_nodes,generics_of,predicates_of,type_of\"\n+        except=\"hir_owner,hir_owner_nodes,generics_of,predicates_of,type_of,fn_sig\"\n     )]\n     #[rustc_clean(cfg=\"cfail3\")]\n     pub fn add_lifetime_bound_to_lifetime_param_of_method<'a, 'b: 'a>(&self) { }\n@@ -388,7 +388,7 @@ impl Foo {\n     // body will be affected. So if you start to see `typeck`\n     // appear dirty, that might be the cause. -nmatsakis\n     #[rustc_clean(cfg=\"cfail2\", except=\"hir_owner,hir_owner_nodes,generics_of,predicates_of,\\\n-                                        type_of\")]\n+                                        type_of,fn_sig\")]\n     #[rustc_clean(cfg=\"cfail3\")]\n     pub fn add_lifetime_bound_to_type_param_of_method<'a, T: 'a>(&self) { }\n }"}, {"sha": "7ab3836493b01ce546bec90266e0e8080fd223a2", "filename": "src/test/ui/associated-type-bounds/hrtb.rs", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/6d5efa9f040d2638318f9e8b96eab718ef664e3c/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fhrtb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d5efa9f040d2638318f9e8b96eab718ef664e3c/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fhrtb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-type-bounds%2Fhrtb.rs?ref=6d5efa9f040d2638318f9e8b96eab718ef664e3c", "patch": "@@ -0,0 +1,65 @@\n+// check-pass\n+\n+#![feature(associated_type_bounds)]\n+\n+trait A<'a> {}\n+trait B<'b> {}\n+fn foo<T>()\n+where\n+    for<'a> T: A<'a> + 'a,\n+{\n+}\n+trait C<'c>: for<'a> A<'a> + for<'b> B<'b> {\n+    type As;\n+}\n+struct D<T>\n+where\n+    T: for<'c> C<'c, As: A<'c>>,\n+{\n+    t: std::marker::PhantomData<T>,\n+}\n+\n+trait E<'e> {\n+    type As;\n+}\n+trait F<'f>: for<'a> A<'a> + for<'e> E<'e> {}\n+struct G<T>\n+where\n+    for<'f> T: F<'f, As: E<'f>> + 'f,\n+{\n+    t: std::marker::PhantomData<T>,\n+}\n+\n+trait I<'a, 'b, 'c> {\n+    type As;\n+}\n+trait H<'d, 'e>: for<'f> I<'d, 'f, 'e> + 'd {}\n+fn foo2<T>()\n+where\n+    T: for<'g> H<'g, 'g, As: for<'h> H<'h, 'g> + 'g>,\n+{\n+}\n+\n+fn foo3<T>()\n+where\n+    T: for<'i> H<'i, 'i, As: for<'j> H<'j, 'i, As: for<'k> I<'i, 'k, 'j> + 'j> + 'i>,\n+{\n+}\n+fn foo4<T>()\n+where\n+    T: for<'l, 'i> H<'l, 'i, As: for<'j> H<'j, 'i, As: for<'k> I<'l, 'k, 'j> + 'j> + 'i>,\n+{\n+}\n+\n+struct X<'x, 'y> {\n+    x: std::marker::PhantomData<&'x ()>,\n+    y: std::marker::PhantomData<&'y ()>,\n+}\n+\n+fn foo5<T>()\n+where\n+    T: for<'l, 'i> H<'l, 'i, As: for<'j> H<'j, 'i, As: for<'k> H<'j, 'k, As = X<'j, 'k>> + 'j> + 'i>\n+{\n+}\n+\n+fn main() {}"}, {"sha": "8cdfe247e025e7b17626f8976fbaaeb2ff781f81", "filename": "src/test/ui/hrtb/complex.rs", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6d5efa9f040d2638318f9e8b96eab718ef664e3c/src%2Ftest%2Fui%2Fhrtb%2Fcomplex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6d5efa9f040d2638318f9e8b96eab718ef664e3c/src%2Ftest%2Fui%2Fhrtb%2Fcomplex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fcomplex.rs?ref=6d5efa9f040d2638318f9e8b96eab718ef664e3c", "patch": "@@ -9,12 +9,20 @@ trait C<'c>: for<'a> A<'a> + for<'b> B<'b> {\n struct D<T> where T: for<'c> C<'c, As=&'c ()> {\n     t: std::marker::PhantomData<T>,\n }\n-trait E<'e> {\n+trait E<'e, 'g> {\n     type As;\n }\n-trait F<'f>: for<'a> A<'a> + for<'e> E<'e> {}\n+trait F<'f>: for<'a> A<'a> + for<'e> E<'e, 'f> {}\n struct G<T> where T: for<'f> F<'f, As=&'f ()> {\n     t: std::marker::PhantomData<T>,\n }\n+trait H<'a, 'b> {\n+    type As;\n+}\n+trait I<'a>: for<'b> H<'a, 'b> {}\n+\n+struct J<T> where T: for<'i> I<'i, As=&'i ()> {\n+    t: std::marker::PhantomData<T>,\n+}\n \n fn main() {}"}, {"sha": "ff16bf0e078fc191aac6f4729b705846003415f8", "filename": "src/test/ui/nll/closure-requirements/escape-argument-callee.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d5efa9f040d2638318f9e8b96eab718ef664e3c/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-argument-callee.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6d5efa9f040d2638318f9e8b96eab718ef664e3c/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-argument-callee.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-argument-callee.stderr?ref=6d5efa9f040d2638318f9e8b96eab718ef664e3c", "patch": "@@ -6,7 +6,7 @@ LL |         let mut closure = expect_sig(|p, y| *p = y);\n    |\n    = note: defining type: test::{closure#0} with closure substs [\n                i16,\n-               for<'r, 's, 't0> extern \"rust-call\" fn((&ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('r) }) mut &ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('s) }) i32, &ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('t0) }) i32)),\n+               for<'r, 's, 't0> extern \"rust-call\" fn((&ReLateBound(DebruijnIndex(0), BoundRegion { var: 0, kind: BrNamed('r) }) mut &ReLateBound(DebruijnIndex(0), BoundRegion { var: 1, kind: BrNamed('s) }) i32, &ReLateBound(DebruijnIndex(0), BoundRegion { var: 2, kind: BrNamed('t0) }) i32)),\n                (),\n            ]\n "}, {"sha": "22398f085725507c5e1ae43553800bba666ba2c9", "filename": "src/test/ui/nll/closure-requirements/escape-argument.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d5efa9f040d2638318f9e8b96eab718ef664e3c/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-argument.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6d5efa9f040d2638318f9e8b96eab718ef664e3c/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-argument.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fescape-argument.stderr?ref=6d5efa9f040d2638318f9e8b96eab718ef664e3c", "patch": "@@ -6,7 +6,7 @@ LL |         let mut closure = expect_sig(|p, y| *p = y);\n    |\n    = note: defining type: test::{closure#0} with closure substs [\n                i16,\n-               for<'r, 's> extern \"rust-call\" fn((&ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('r) }) mut &ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('s) }) i32, &ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('s) }) i32)),\n+               for<'r, 's> extern \"rust-call\" fn((&ReLateBound(DebruijnIndex(0), BoundRegion { var: 0, kind: BrNamed('r) }) mut &ReLateBound(DebruijnIndex(0), BoundRegion { var: 1, kind: BrNamed('s) }) i32, &ReLateBound(DebruijnIndex(0), BoundRegion { var: 1, kind: BrNamed('s) }) i32)),\n                (),\n            ]\n "}, {"sha": "11420efaa066eeecb1bdf521159525930ac5e63d", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-fail-no-postdom.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d5efa9f040d2638318f9e8b96eab718ef664e3c/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-fail-no-postdom.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6d5efa9f040d2638318f9e8b96eab718ef664e3c/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-fail-no-postdom.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-fail-no-postdom.stderr?ref=6d5efa9f040d2638318f9e8b96eab718ef664e3c", "patch": "@@ -10,7 +10,7 @@ LL | |         },\n    |\n    = note: defining type: supply::{closure#0} with closure substs [\n                i16,\n-               for<'r, 's> extern \"rust-call\" fn((std::cell::Cell<&'_#1r &ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('r) }) u32>, std::cell::Cell<&'_#2r &ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('r) }) u32>, std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('s) }) &'_#3r u32>, std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('r) }) u32>, std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('s) }) u32>)),\n+               for<'r, 's> extern \"rust-call\" fn((std::cell::Cell<&'_#1r &ReLateBound(DebruijnIndex(0), BoundRegion { var: 0, kind: BrNamed('r) }) u32>, std::cell::Cell<&'_#2r &ReLateBound(DebruijnIndex(0), BoundRegion { var: 0, kind: BrNamed('r) }) u32>, std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { var: 1, kind: BrNamed('s) }) &'_#3r u32>, std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { var: 0, kind: BrNamed('r) }) u32>, std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { var: 1, kind: BrNamed('s) }) u32>)),\n                (),\n            ]\n    = note: late-bound region is '_#4r"}, {"sha": "98c3c28fb43ff8382ee5c02e9dca9a78ff75f405", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-ref.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d5efa9f040d2638318f9e8b96eab718ef664e3c/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6d5efa9f040d2638318f9e8b96eab718ef664e3c/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-ref.stderr?ref=6d5efa9f040d2638318f9e8b96eab718ef664e3c", "patch": "@@ -11,7 +11,7 @@ LL | |     });\n    |\n    = note: defining type: supply::{closure#0} with closure substs [\n                i16,\n-               for<'r, 's, 't0, 't1, 't2, 't3> extern \"rust-call\" fn((&ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('r) }) std::cell::Cell<&'_#1r &ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('s) }) u32>, &ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('t0) }) std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('t1) }) &'_#2r u32>, &ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('t2) }) std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('s) }) u32>, &ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('t3) }) std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('t1) }) u32>)),\n+               for<'r, 's, 't0, 't1, 't2, 't3> extern \"rust-call\" fn((&ReLateBound(DebruijnIndex(0), BoundRegion { var: 0, kind: BrNamed('r) }) std::cell::Cell<&'_#1r &ReLateBound(DebruijnIndex(0), BoundRegion { var: 1, kind: BrNamed('s) }) u32>, &ReLateBound(DebruijnIndex(0), BoundRegion { var: 2, kind: BrNamed('t0) }) std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { var: 3, kind: BrNamed('t1) }) &'_#2r u32>, &ReLateBound(DebruijnIndex(0), BoundRegion { var: 4, kind: BrNamed('t2) }) std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { var: 1, kind: BrNamed('s) }) u32>, &ReLateBound(DebruijnIndex(0), BoundRegion { var: 5, kind: BrNamed('t3) }) std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { var: 3, kind: BrNamed('t1) }) u32>)),\n                (),\n            ]\n    = note: late-bound region is '_#3r"}, {"sha": "30ef343b26123268780e197fb52d6bdb75b0f2b8", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-shorter-to-static-comparing-against-free.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6d5efa9f040d2638318f9e8b96eab718ef664e3c/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-comparing-against-free.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6d5efa9f040d2638318f9e8b96eab718ef664e3c/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-comparing-against-free.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-comparing-against-free.stderr?ref=6d5efa9f040d2638318f9e8b96eab718ef664e3c", "patch": "@@ -10,7 +10,7 @@ LL | |     })\n    |\n    = note: defining type: case1::{closure#0} with closure substs [\n                i32,\n-               for<'r> extern \"rust-call\" fn((std::cell::Cell<&'_#1r u32>, std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('r) }) u32>)),\n+               for<'r> extern \"rust-call\" fn((std::cell::Cell<&'_#1r u32>, std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { var: 0, kind: BrNamed('r) }) u32>)),\n                (),\n            ]\n \n@@ -49,7 +49,7 @@ LL | |     })\n    |\n    = note: defining type: case2::{closure#0} with closure substs [\n                i32,\n-               for<'r> extern \"rust-call\" fn((std::cell::Cell<&'_#1r u32>, std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('r) }) u32>)),\n+               for<'r> extern \"rust-call\" fn((std::cell::Cell<&'_#1r u32>, std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { var: 0, kind: BrNamed('r) }) u32>)),\n                (),\n            ]\n    = note: number of external vids: 2"}, {"sha": "29993b129c71ae869caa89b193ab4c460d814f15", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-shorter-to-static-no-bound.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d5efa9f040d2638318f9e8b96eab718ef664e3c/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-no-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6d5efa9f040d2638318f9e8b96eab718ef664e3c/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-no-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-no-bound.stderr?ref=6d5efa9f040d2638318f9e8b96eab718ef664e3c", "patch": "@@ -12,7 +12,7 @@ LL | |     });\n    |\n    = note: defining type: supply::{closure#0} with closure substs [\n                i16,\n-               for<'r, 's, 't0, 't1, 't2> extern \"rust-call\" fn((&ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('r) }) std::cell::Cell<&'_#1r &ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('s) }) u32>, &ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('t0) }) std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('s) }) u32>, &ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('t1) }) std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('t2) }) u32>)),\n+               for<'r, 's, 't0, 't1, 't2> extern \"rust-call\" fn((&ReLateBound(DebruijnIndex(0), BoundRegion { var: 0, kind: BrNamed('r) }) std::cell::Cell<&'_#1r &ReLateBound(DebruijnIndex(0), BoundRegion { var: 1, kind: BrNamed('s) }) u32>, &ReLateBound(DebruijnIndex(0), BoundRegion { var: 2, kind: BrNamed('t0) }) std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { var: 1, kind: BrNamed('s) }) u32>, &ReLateBound(DebruijnIndex(0), BoundRegion { var: 3, kind: BrNamed('t1) }) std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { var: 4, kind: BrNamed('t2) }) u32>)),\n                (),\n            ]\n    = note: late-bound region is '_#2r"}, {"sha": "cb505d8b1eceb501faaa1b74b72232886926042e", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-shorter-to-static-wrong-bound.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d5efa9f040d2638318f9e8b96eab718ef664e3c/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-wrong-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6d5efa9f040d2638318f9e8b96eab718ef664e3c/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-wrong-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-shorter-to-static-wrong-bound.stderr?ref=6d5efa9f040d2638318f9e8b96eab718ef664e3c", "patch": "@@ -12,7 +12,7 @@ LL | |     });\n    |\n    = note: defining type: supply::{closure#0} with closure substs [\n                i16,\n-               for<'r, 's, 't0, 't1, 't2, 't3> extern \"rust-call\" fn((&ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('r) }) std::cell::Cell<&'_#1r &ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('s) }) u32>, &ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('t0) }) std::cell::Cell<&'_#2r &ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('t1) }) u32>, &ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('t2) }) std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('s) }) u32>, &ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('t3) }) std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('t1) }) u32>)),\n+               for<'r, 's, 't0, 't1, 't2, 't3> extern \"rust-call\" fn((&ReLateBound(DebruijnIndex(0), BoundRegion { var: 0, kind: BrNamed('r) }) std::cell::Cell<&'_#1r &ReLateBound(DebruijnIndex(0), BoundRegion { var: 1, kind: BrNamed('s) }) u32>, &ReLateBound(DebruijnIndex(0), BoundRegion { var: 2, kind: BrNamed('t0) }) std::cell::Cell<&'_#2r &ReLateBound(DebruijnIndex(0), BoundRegion { var: 3, kind: BrNamed('t1) }) u32>, &ReLateBound(DebruijnIndex(0), BoundRegion { var: 4, kind: BrNamed('t2) }) std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { var: 1, kind: BrNamed('s) }) u32>, &ReLateBound(DebruijnIndex(0), BoundRegion { var: 5, kind: BrNamed('t3) }) std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { var: 3, kind: BrNamed('t1) }) u32>)),\n                (),\n            ]\n    = note: late-bound region is '_#3r"}, {"sha": "2ec9d4d8db1a6aa4d3b133b8bf171292bc1ce56e", "filename": "src/test/ui/nll/closure-requirements/propagate-approximated-val.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d5efa9f040d2638318f9e8b96eab718ef664e3c/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-val.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6d5efa9f040d2638318f9e8b96eab718ef664e3c/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-val.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-approximated-val.stderr?ref=6d5efa9f040d2638318f9e8b96eab718ef664e3c", "patch": "@@ -11,7 +11,7 @@ LL | |     });\n    |\n    = note: defining type: test::{closure#0} with closure substs [\n                i16,\n-               for<'r, 's> extern \"rust-call\" fn((std::cell::Cell<&'_#1r &ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('r) }) u32>, std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('s) }) &'_#2r u32>, std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('r) }) u32>, std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('s) }) u32>)),\n+               for<'r, 's> extern \"rust-call\" fn((std::cell::Cell<&'_#1r &ReLateBound(DebruijnIndex(0), BoundRegion { var: 0, kind: BrNamed('r) }) u32>, std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { var: 1, kind: BrNamed('s) }) &'_#2r u32>, std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { var: 0, kind: BrNamed('r) }) u32>, std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { var: 1, kind: BrNamed('s) }) u32>)),\n                (),\n            ]\n    = note: late-bound region is '_#3r"}, {"sha": "21e4232c788fb928c4a64b2e1fe3b0d1c6ab327d", "filename": "src/test/ui/nll/closure-requirements/propagate-despite-same-free-region.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d5efa9f040d2638318f9e8b96eab718ef664e3c/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-despite-same-free-region.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6d5efa9f040d2638318f9e8b96eab718ef664e3c/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-despite-same-free-region.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-despite-same-free-region.stderr?ref=6d5efa9f040d2638318f9e8b96eab718ef664e3c", "patch": "@@ -10,7 +10,7 @@ LL | |         },\n    |\n    = note: defining type: supply::{closure#0} with closure substs [\n                i16,\n-               for<'r, 's> extern \"rust-call\" fn((std::cell::Cell<&'_#1r &ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('r) }) u32>, std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('s) }) &'_#2r u32>, std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('r) }) u32>, std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('s) }) u32>)),\n+               for<'r, 's> extern \"rust-call\" fn((std::cell::Cell<&'_#1r &ReLateBound(DebruijnIndex(0), BoundRegion { var: 0, kind: BrNamed('r) }) u32>, std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { var: 1, kind: BrNamed('s) }) &'_#2r u32>, std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { var: 0, kind: BrNamed('r) }) u32>, std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { var: 1, kind: BrNamed('s) }) u32>)),\n                (),\n            ]\n    = note: late-bound region is '_#3r"}, {"sha": "8b9b0435420573c0dc5e7ec7f65c67bc3d50c4cc", "filename": "src/test/ui/nll/closure-requirements/propagate-fail-to-approximate-longer-no-bounds.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d5efa9f040d2638318f9e8b96eab718ef664e3c/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-no-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6d5efa9f040d2638318f9e8b96eab718ef664e3c/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-no-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-no-bounds.stderr?ref=6d5efa9f040d2638318f9e8b96eab718ef664e3c", "patch": "@@ -11,7 +11,7 @@ LL | |     });\n    |\n    = note: defining type: supply::{closure#0} with closure substs [\n                i16,\n-               for<'r, 's, 't0, 't1, 't2> extern \"rust-call\" fn((&ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('r) }) std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('s) }) &'_#1r u32>, &ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('t0) }) std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('t1) }) u32>, &ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('t2) }) std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('s) }) u32>)),\n+               for<'r, 's, 't0, 't1, 't2> extern \"rust-call\" fn((&ReLateBound(DebruijnIndex(0), BoundRegion { var: 0, kind: BrNamed('r) }) std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { var: 1, kind: BrNamed('s) }) &'_#1r u32>, &ReLateBound(DebruijnIndex(0), BoundRegion { var: 2, kind: BrNamed('t0) }) std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { var: 3, kind: BrNamed('t1) }) u32>, &ReLateBound(DebruijnIndex(0), BoundRegion { var: 4, kind: BrNamed('t2) }) std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { var: 1, kind: BrNamed('s) }) u32>)),\n                (),\n            ]\n    = note: late-bound region is '_#2r"}, {"sha": "060ce690f0306ac492a5d366b9318869cb07be52", "filename": "src/test/ui/nll/closure-requirements/propagate-fail-to-approximate-longer-wrong-bounds.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d5efa9f040d2638318f9e8b96eab718ef664e3c/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-wrong-bounds.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6d5efa9f040d2638318f9e8b96eab718ef664e3c/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-wrong-bounds.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Fpropagate-fail-to-approximate-longer-wrong-bounds.stderr?ref=6d5efa9f040d2638318f9e8b96eab718ef664e3c", "patch": "@@ -11,7 +11,7 @@ LL | |     });\n    |\n    = note: defining type: supply::{closure#0} with closure substs [\n                i16,\n-               for<'r, 's, 't0, 't1, 't2, 't3> extern \"rust-call\" fn((&ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('r) }) std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('s) }) &'_#1r u32>, &ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('t0) }) std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('t1) }) &'_#2r u32>, &ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('t2) }) std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('s) }) u32>, &ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('t3) }) std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('t1) }) u32>)),\n+               for<'r, 's, 't0, 't1, 't2, 't3> extern \"rust-call\" fn((&ReLateBound(DebruijnIndex(0), BoundRegion { var: 0, kind: BrNamed('r) }) std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { var: 1, kind: BrNamed('s) }) &'_#1r u32>, &ReLateBound(DebruijnIndex(0), BoundRegion { var: 2, kind: BrNamed('t0) }) std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { var: 3, kind: BrNamed('t1) }) &'_#2r u32>, &ReLateBound(DebruijnIndex(0), BoundRegion { var: 4, kind: BrNamed('t2) }) std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { var: 1, kind: BrNamed('s) }) u32>, &ReLateBound(DebruijnIndex(0), BoundRegion { var: 5, kind: BrNamed('t3) }) std::cell::Cell<&ReLateBound(DebruijnIndex(0), BoundRegion { var: 3, kind: BrNamed('t1) }) u32>)),\n                (),\n            ]\n    = note: late-bound region is '_#3r"}, {"sha": "5fc1d5c43618154f55ac5fc9644402799d72a4cd", "filename": "src/test/ui/nll/closure-requirements/return-wrong-bound-region.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6d5efa9f040d2638318f9e8b96eab718ef664e3c/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Freturn-wrong-bound-region.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6d5efa9f040d2638318f9e8b96eab718ef664e3c/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Freturn-wrong-bound-region.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fclosure-requirements%2Freturn-wrong-bound-region.stderr?ref=6d5efa9f040d2638318f9e8b96eab718ef664e3c", "patch": "@@ -6,7 +6,7 @@ LL |     expect_sig(|a, b| b); // ought to return `a`\n    |\n    = note: defining type: test::{closure#0} with closure substs [\n                i16,\n-               for<'r, 's> extern \"rust-call\" fn((&ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('r) }) i32, &ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('s) }) i32)) -> &ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('r) }) i32,\n+               for<'r, 's> extern \"rust-call\" fn((&ReLateBound(DebruijnIndex(0), BoundRegion { var: 0, kind: BrNamed('r) }) i32, &ReLateBound(DebruijnIndex(0), BoundRegion { var: 1, kind: BrNamed('s) }) i32)) -> &ReLateBound(DebruijnIndex(0), BoundRegion { var: 0, kind: BrNamed('r) }) i32,\n                (),\n            ]\n "}, {"sha": "baf223b786b080709fd7ba3629f507d1f96f3d36", "filename": "src/test/ui/nll/ty-outlives/ty-param-closure-approximate-lower-bound.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6d5efa9f040d2638318f9e8b96eab718ef664e3c/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-approximate-lower-bound.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/6d5efa9f040d2638318f9e8b96eab718ef664e3c/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-approximate-lower-bound.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnll%2Fty-outlives%2Fty-param-closure-approximate-lower-bound.stderr?ref=6d5efa9f040d2638318f9e8b96eab718ef664e3c", "patch": "@@ -6,7 +6,7 @@ LL |     twice(cell, value, |a, b| invoke(a, b));\n    |\n    = note: defining type: generic::<T>::{closure#0} with closure substs [\n                i16,\n-               for<'r, 's> extern \"rust-call\" fn((std::option::Option<std::cell::Cell<&'_#1r &ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('r) }) ()>>, &ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('s) }) T)),\n+               for<'r, 's> extern \"rust-call\" fn((std::option::Option<std::cell::Cell<&'_#1r &ReLateBound(DebruijnIndex(0), BoundRegion { var: 0, kind: BrNamed('r) }) ()>>, &ReLateBound(DebruijnIndex(0), BoundRegion { var: 1, kind: BrNamed('s) }) T)),\n                (),\n            ]\n    = note: number of external vids: 2\n@@ -31,7 +31,7 @@ LL |     twice(cell, value, |a, b| invoke(a, b));\n    |\n    = note: defining type: generic_fail::<T>::{closure#0} with closure substs [\n                i16,\n-               for<'r, 's> extern \"rust-call\" fn((std::option::Option<std::cell::Cell<&'_#1r &ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('r) }) ()>>, &ReLateBound(DebruijnIndex(0), BoundRegion { kind: BrNamed('s) }) T)),\n+               for<'r, 's> extern \"rust-call\" fn((std::option::Option<std::cell::Cell<&'_#1r &ReLateBound(DebruijnIndex(0), BoundRegion { var: 0, kind: BrNamed('r) }) ()>>, &ReLateBound(DebruijnIndex(0), BoundRegion { var: 1, kind: BrNamed('s) }) T)),\n                (),\n            ]\n    = note: late-bound region is '_#2r"}]}