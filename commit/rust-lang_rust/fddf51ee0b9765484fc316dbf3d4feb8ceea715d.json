{"sha": "fddf51ee0b9765484fc316dbf3d4feb8ceea715d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZkZGY1MWVlMGI5NzY1NDg0ZmMzMTZkYmYzZDRmZWI4Y2VlYTcxNWQ=", "commit": {"author": {"name": "Mike Hommey", "email": "mh@glandium.org", "date": "2018-04-02T23:51:02Z"}, "committer": {"name": "Simon Sapin", "email": "simon.sapin@exyr.org", "date": "2018-04-12T20:53:22Z"}, "message": "Use NonNull<Void> instead of *mut u8 in the Alloc trait\n\nFixes #49608", "tree": {"sha": "52814590ab7288801f78e8ee5493e156f3181017", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/52814590ab7288801f78e8ee5493e156f3181017"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fddf51ee0b9765484fc316dbf3d4feb8ceea715d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fddf51ee0b9765484fc316dbf3d4feb8ceea715d", "html_url": "https://github.com/rust-lang/rust/commit/fddf51ee0b9765484fc316dbf3d4feb8ceea715d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fddf51ee0b9765484fc316dbf3d4feb8ceea715d/comments", "author": {"login": "glandium", "id": 1038527, "node_id": "MDQ6VXNlcjEwMzg1Mjc=", "avatar_url": "https://avatars.githubusercontent.com/u/1038527?v=4", "gravatar_id": "", "url": "https://api.github.com/users/glandium", "html_url": "https://github.com/glandium", "followers_url": "https://api.github.com/users/glandium/followers", "following_url": "https://api.github.com/users/glandium/following{/other_user}", "gists_url": "https://api.github.com/users/glandium/gists{/gist_id}", "starred_url": "https://api.github.com/users/glandium/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/glandium/subscriptions", "organizations_url": "https://api.github.com/users/glandium/orgs", "repos_url": "https://api.github.com/users/glandium/repos", "events_url": "https://api.github.com/users/glandium/events{/privacy}", "received_events_url": "https://api.github.com/users/glandium/received_events", "type": "User", "site_admin": false}, "committer": {"login": "SimonSapin", "id": 291359, "node_id": "MDQ6VXNlcjI5MTM1OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/291359?v=4", "gravatar_id": "", "url": "https://api.github.com/users/SimonSapin", "html_url": "https://github.com/SimonSapin", "followers_url": "https://api.github.com/users/SimonSapin/followers", "following_url": "https://api.github.com/users/SimonSapin/following{/other_user}", "gists_url": "https://api.github.com/users/SimonSapin/gists{/gist_id}", "starred_url": "https://api.github.com/users/SimonSapin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/SimonSapin/subscriptions", "organizations_url": "https://api.github.com/users/SimonSapin/orgs", "repos_url": "https://api.github.com/users/SimonSapin/repos", "events_url": "https://api.github.com/users/SimonSapin/events{/privacy}", "received_events_url": "https://api.github.com/users/SimonSapin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fd242ee64c5488e64e2bb677d90f2460e017b7cb", "url": "https://api.github.com/repos/rust-lang/rust/commits/fd242ee64c5488e64e2bb677d90f2460e017b7cb", "html_url": "https://github.com/rust-lang/rust/commit/fd242ee64c5488e64e2bb677d90f2460e017b7cb"}], "stats": {"total": 265, "additions": 136, "deletions": 129}, "files": [{"sha": "498ac2997420f7b25f7cd0a3f8202950d8ad93ec", "filename": "src/doc/nomicon", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon?ref=fddf51ee0b9765484fc316dbf3d4feb8ceea715d", "patch": "@@ -1 +1 @@\n-Subproject commit 6a8f0a27e9a58c55c89d07bc43a176fdae5e051c\n+Subproject commit 498ac2997420f7b25f7cd0a3f8202950d8ad93ec"}, {"sha": "a3f3ee65bf0145f54c0f71685f44693f6354cd92", "filename": "src/doc/unstable-book/src/language-features/global-allocator.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fddf51ee0b9765484fc316dbf3d4feb8ceea715d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fglobal-allocator.md", "raw_url": "https://github.com/rust-lang/rust/raw/fddf51ee0b9765484fc316dbf3d4feb8ceea715d/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fglobal-allocator.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fglobal-allocator.md?ref=fddf51ee0b9765484fc316dbf3d4feb8ceea715d", "patch": "@@ -30,6 +30,7 @@ looks like:\n #![feature(global_allocator, allocator_api, heap_api)]\n \n use std::alloc::{GlobalAlloc, System, Layout, Void};\n+use std::ptr::NonNull;\n \n struct MyAllocator;\n "}, {"sha": "af48aa7961e061fbe11b9cca81982a77dacc0a94", "filename": "src/liballoc/alloc.rs", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fddf51ee0b9765484fc316dbf3d4feb8ceea715d/src%2Fliballoc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fddf51ee0b9765484fc316dbf3d4feb8ceea715d/src%2Fliballoc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Falloc.rs?ref=fddf51ee0b9765484fc316dbf3d4feb8ceea715d", "patch": "@@ -16,6 +16,7 @@\n             issue = \"32838\")]\n \n use core::intrinsics::{min_align_of_val, size_of_val};\n+use core::ptr::NonNull;\n use core::usize;\n \n #[doc(inline)]\n@@ -120,27 +121,27 @@ unsafe impl GlobalAlloc for Global {\n \n unsafe impl Alloc for Global {\n     #[inline]\n-    unsafe fn alloc(&mut self, layout: Layout) -> Result<*mut u8, AllocErr> {\n+    unsafe fn alloc(&mut self, layout: Layout) -> Result<NonNull<Void>, AllocErr> {\n         GlobalAlloc::alloc(self, layout).into()\n     }\n \n     #[inline]\n-    unsafe fn dealloc(&mut self, ptr: *mut u8, layout: Layout) {\n-        GlobalAlloc::dealloc(self, ptr as *mut Void, layout)\n+    unsafe fn dealloc(&mut self, ptr: NonNull<Void>, layout: Layout) {\n+        GlobalAlloc::dealloc(self, ptr.as_ptr(), layout)\n     }\n \n     #[inline]\n     unsafe fn realloc(&mut self,\n-                      ptr: *mut u8,\n+                      ptr: NonNull<Void>,\n                       layout: Layout,\n                       new_size: usize)\n-                      -> Result<*mut u8, AllocErr>\n+                      -> Result<NonNull<Void>, AllocErr>\n     {\n-        GlobalAlloc::realloc(self, ptr as *mut Void, layout, new_size).into()\n+        GlobalAlloc::realloc(self, ptr.as_ptr(), layout, new_size).into()\n     }\n \n     #[inline]\n-    unsafe fn alloc_zeroed(&mut self, layout: Layout) -> Result<*mut u8, AllocErr> {\n+    unsafe fn alloc_zeroed(&mut self, layout: Layout) -> Result<NonNull<Void>, AllocErr> {\n         GlobalAlloc::alloc_zeroed(self, layout).into()\n     }\n \n@@ -195,8 +196,8 @@ mod tests {\n             let ptr = Global.alloc_zeroed(layout.clone())\n                 .unwrap_or_else(|_| Global.oom());\n \n-            let end = ptr.offset(layout.size() as isize);\n-            let mut i = ptr;\n+            let mut i = ptr.cast::<u8>().as_ptr();\n+            let end = i.offset(layout.size() as isize);\n             while i < end {\n                 assert_eq!(*i, 0);\n                 i = i.offset(1);"}, {"sha": "88754ace3ce2c72219d40b2f0bc2ba55ebbe741e", "filename": "src/liballoc/arc.rs", "status": "modified", "additions": 6, "deletions": 10, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fddf51ee0b9765484fc316dbf3d4feb8ceea715d/src%2Fliballoc%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fddf51ee0b9765484fc316dbf3d4feb8ceea715d/src%2Fliballoc%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Farc.rs?ref=fddf51ee0b9765484fc316dbf3d4feb8ceea715d", "patch": "@@ -512,15 +512,13 @@ impl<T: ?Sized> Arc<T> {\n     // Non-inlined part of `drop`.\n     #[inline(never)]\n     unsafe fn drop_slow(&mut self) {\n-        let ptr = self.ptr.as_ptr();\n-\n         // Destroy the data at this time, even though we may not free the box\n         // allocation itself (there may still be weak pointers lying around).\n         ptr::drop_in_place(&mut self.ptr.as_mut().data);\n \n         if self.inner().weak.fetch_sub(1, Release) == 1 {\n             atomic::fence(Acquire);\n-            Global.dealloc(ptr as *mut u8, Layout::for_value(&*ptr))\n+            Global.dealloc(self.ptr.as_void(), Layout::for_value(self.ptr.as_ref()))\n         }\n     }\n \n@@ -558,7 +556,7 @@ impl<T: ?Sized> Arc<T> {\n             .unwrap_or_else(|_| Global.oom());\n \n         // Initialize the real ArcInner\n-        let inner = set_data_ptr(ptr as *mut T, mem) as *mut ArcInner<T>;\n+        let inner = set_data_ptr(ptr as *mut T, mem.as_ptr() as *mut u8) as *mut ArcInner<T>;\n \n         ptr::write(&mut (*inner).strong, atomic::AtomicUsize::new(1));\n         ptr::write(&mut (*inner).weak, atomic::AtomicUsize::new(1));\n@@ -625,7 +623,7 @@ impl<T: Clone> ArcFromSlice<T> for Arc<[T]> {\n         // In the event of a panic, elements that have been written\n         // into the new ArcInner will be dropped, then the memory freed.\n         struct Guard<T> {\n-            mem: *mut u8,\n+            mem: NonNull<u8>,\n             elems: *mut T,\n             layout: Layout,\n             n_elems: usize,\n@@ -639,7 +637,7 @@ impl<T: Clone> ArcFromSlice<T> for Arc<[T]> {\n                     let slice = from_raw_parts_mut(self.elems, self.n_elems);\n                     ptr::drop_in_place(slice);\n \n-                    Global.dealloc(self.mem, self.layout.clone());\n+                    Global.dealloc(self.mem.as_void(), self.layout.clone());\n                 }\n             }\n         }\n@@ -655,7 +653,7 @@ impl<T: Clone> ArcFromSlice<T> for Arc<[T]> {\n             let elems = &mut (*ptr).data as *mut [T] as *mut T;\n \n             let mut guard = Guard{\n-                mem: mem,\n+                mem: NonNull::new_unchecked(mem),\n                 elems: elems,\n                 layout: layout,\n                 n_elems: 0,\n@@ -1147,8 +1145,6 @@ impl<T: ?Sized> Drop for Weak<T> {\n     /// assert!(other_weak_foo.upgrade().is_none());\n     /// ```\n     fn drop(&mut self) {\n-        let ptr = self.ptr.as_ptr();\n-\n         // If we find out that we were the last weak pointer, then its time to\n         // deallocate the data entirely. See the discussion in Arc::drop() about\n         // the memory orderings\n@@ -1160,7 +1156,7 @@ impl<T: ?Sized> Drop for Weak<T> {\n         if self.inner().weak.fetch_sub(1, Release) == 1 {\n             atomic::fence(Acquire);\n             unsafe {\n-                Global.dealloc(ptr as *mut u8, Layout::for_value(&*ptr))\n+                Global.dealloc(self.ptr.as_void(), Layout::for_value(self.ptr.as_ref()))\n             }\n         }\n     }"}, {"sha": "64aa40ac166e6f3b6a54083fa4c2a4a1511c959c", "filename": "src/liballoc/btree/node.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fddf51ee0b9765484fc316dbf3d4feb8ceea715d/src%2Fliballoc%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fddf51ee0b9765484fc316dbf3d4feb8ceea715d/src%2Fliballoc%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbtree%2Fnode.rs?ref=fddf51ee0b9765484fc316dbf3d4feb8ceea715d", "patch": "@@ -236,7 +236,7 @@ impl<K, V> Root<K, V> {\n     pub fn pop_level(&mut self) {\n         debug_assert!(self.height > 0);\n \n-        let top = self.node.ptr.as_ptr() as *mut u8;\n+        let top = self.node.ptr;\n \n         self.node = unsafe {\n             BoxedNode::from_ptr(self.as_mut()\n@@ -249,7 +249,7 @@ impl<K, V> Root<K, V> {\n         self.as_mut().as_leaf_mut().parent = ptr::null();\n \n         unsafe {\n-            Global.dealloc(top, Layout::new::<InternalNode<K, V>>());\n+            Global.dealloc(NonNull::from(top).as_void(), Layout::new::<InternalNode<K, V>>());\n         }\n     }\n }\n@@ -433,9 +433,9 @@ impl<K, V> NodeRef<marker::Owned, K, V, marker::Leaf> {\n             marker::Edge\n         >\n     > {\n-        let ptr = self.as_leaf() as *const LeafNode<K, V> as *const u8 as *mut u8;\n+        let node = self.node;\n         let ret = self.ascend().ok();\n-        Global.dealloc(ptr, Layout::new::<LeafNode<K, V>>());\n+        Global.dealloc(node.as_void(), Layout::new::<LeafNode<K, V>>());\n         ret\n     }\n }\n@@ -454,9 +454,9 @@ impl<K, V> NodeRef<marker::Owned, K, V, marker::Internal> {\n             marker::Edge\n         >\n     > {\n-        let ptr = self.as_internal() as *const InternalNode<K, V> as *const u8 as *mut u8;\n+        let node = self.node;\n         let ret = self.ascend().ok();\n-        Global.dealloc(ptr, Layout::new::<InternalNode<K, V>>());\n+        Global.dealloc(node.as_void(), Layout::new::<InternalNode<K, V>>());\n         ret\n     }\n }\n@@ -1239,12 +1239,12 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n                 }\n \n                 Global.dealloc(\n-                    right_node.node.as_ptr() as *mut u8,\n+                    right_node.node.as_void(),\n                     Layout::new::<InternalNode<K, V>>(),\n                 );\n             } else {\n                 Global.dealloc(\n-                    right_node.node.as_ptr() as *mut u8,\n+                    right_node.node.as_void(),\n                     Layout::new::<LeafNode<K, V>>(),\n                 );\n             }"}, {"sha": "cfb6504e743a14527c8ac627188b9d085b379b03", "filename": "src/liballoc/heap.rs", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/fddf51ee0b9765484fc316dbf3d4feb8ceea715d/src%2Fliballoc%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fddf51ee0b9765484fc316dbf3d4feb8ceea715d/src%2Fliballoc%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fheap.rs?ref=fddf51ee0b9765484fc316dbf3d4feb8ceea715d", "patch": "@@ -8,14 +8,20 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-pub use alloc::{Excess, Layout, AllocErr, CannotReallocInPlace};\n+#![allow(deprecated)]\n+\n+pub use alloc::{Layout, AllocErr, CannotReallocInPlace, Void};\n use core::alloc::Alloc as CoreAlloc;\n+use core::ptr::NonNull;\n \n #[doc(hidden)]\n pub mod __core {\n     pub use core::*;\n }\n \n+#[derive(Debug)]\n+pub struct Excess(pub *mut u8, pub usize);\n+\n /// Compatibility with older versions of #[global_allocator] during bootstrap\n pub unsafe trait Alloc {\n     unsafe fn alloc(&mut self, layout: Layout) -> Result<*mut u8, AllocErr>;\n@@ -42,13 +48,13 @@ pub unsafe trait Alloc {\n                               new_layout: Layout) -> Result<(), CannotReallocInPlace>;\n }\n \n-#[allow(deprecated)]\n unsafe impl<T> Alloc for T where T: CoreAlloc {\n     unsafe fn alloc(&mut self, layout: Layout) -> Result<*mut u8, AllocErr> {\n-        CoreAlloc::alloc(self, layout)\n+        CoreAlloc::alloc(self, layout).map(|ptr| ptr.cast().as_ptr())\n     }\n \n     unsafe fn dealloc(&mut self, ptr: *mut u8, layout: Layout) {\n+        let ptr = NonNull::new_unchecked(ptr as *mut Void);\n         CoreAlloc::dealloc(self, ptr, layout)\n     }\n \n@@ -64,35 +70,41 @@ unsafe impl<T> Alloc for T where T: CoreAlloc {\n                       ptr: *mut u8,\n                       layout: Layout,\n                       new_layout: Layout) -> Result<*mut u8, AllocErr> {\n-        CoreAlloc::realloc(self, ptr, layout, new_layout.size())\n+        let ptr = NonNull::new_unchecked(ptr as *mut Void);\n+        CoreAlloc::realloc(self, ptr, layout, new_layout.size()).map(|ptr| ptr.cast().as_ptr())\n     }\n \n     unsafe fn alloc_zeroed(&mut self, layout: Layout) -> Result<*mut u8, AllocErr> {\n-        CoreAlloc::alloc_zeroed(self, layout)\n+        CoreAlloc::alloc_zeroed(self, layout).map(|ptr| ptr.cast().as_ptr())\n     }\n \n     unsafe fn alloc_excess(&mut self, layout: Layout) -> Result<Excess, AllocErr> {\n         CoreAlloc::alloc_excess(self, layout)\n+            .map(|e| Excess(e.0 .cast().as_ptr(), e.1))\n     }\n \n     unsafe fn realloc_excess(&mut self,\n                              ptr: *mut u8,\n                              layout: Layout,\n                              new_layout: Layout) -> Result<Excess, AllocErr> {\n+        let ptr = NonNull::new_unchecked(ptr as *mut Void);\n         CoreAlloc::realloc_excess(self, ptr, layout, new_layout.size())\n+            .map(|e| Excess(e.0 .cast().as_ptr(), e.1))\n     }\n \n     unsafe fn grow_in_place(&mut self,\n                             ptr: *mut u8,\n                             layout: Layout,\n                             new_layout: Layout) -> Result<(), CannotReallocInPlace> {\n+        let ptr = NonNull::new_unchecked(ptr as *mut Void);\n         CoreAlloc::grow_in_place(self, ptr, layout, new_layout.size())\n     }\n \n     unsafe fn shrink_in_place(&mut self,\n                               ptr: *mut u8,\n                               layout: Layout,\n                               new_layout: Layout) -> Result<(), CannotReallocInPlace> {\n+        let ptr = NonNull::new_unchecked(ptr as *mut Void);\n         CoreAlloc::shrink_in_place(self, ptr, layout, new_layout.size())\n     }\n }"}, {"sha": "3a106a2ff5c3debd6e19205a2f49a6fbc7b5b600", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fddf51ee0b9765484fc316dbf3d4feb8ceea715d/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fddf51ee0b9765484fc316dbf3d4feb8ceea715d/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=fddf51ee0b9765484fc316dbf3d4feb8ceea715d", "patch": "@@ -99,6 +99,7 @@\n #![feature(lang_items)]\n #![feature(libc)]\n #![feature(needs_allocator)]\n+#![feature(nonnull_cast)]\n #![feature(nonzero)]\n #![feature(optin_builtin_traits)]\n #![feature(pattern)]"}, {"sha": "d72301f5ad64064cb541a765ec2ab97a6a91b62a", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 19, "deletions": 21, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/fddf51ee0b9765484fc316dbf3d4feb8ceea715d/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fddf51ee0b9765484fc316dbf3d4feb8ceea715d/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=fddf51ee0b9765484fc316dbf3d4feb8ceea715d", "patch": "@@ -12,7 +12,7 @@ use alloc::{Alloc, Layout, Global};\n use core::cmp;\n use core::mem;\n use core::ops::Drop;\n-use core::ptr::{self, Unique};\n+use core::ptr::{self, NonNull, Unique};\n use core::slice;\n use super::boxed::Box;\n use super::allocator::CollectionAllocErr;\n@@ -90,7 +90,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n \n             // handles ZSTs and `cap = 0` alike\n             let ptr = if alloc_size == 0 {\n-                mem::align_of::<T>() as *mut u8\n+                NonNull::<T>::dangling().as_void()\n             } else {\n                 let align = mem::align_of::<T>();\n                 let result = if zeroed {\n@@ -105,7 +105,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n             };\n \n             RawVec {\n-                ptr: Unique::new_unchecked(ptr as *mut _),\n+                ptr: ptr.cast().into(),\n                 cap,\n                 a,\n             }\n@@ -310,11 +310,11 @@ impl<T, A: Alloc> RawVec<T, A> {\n                     let new_cap = 2 * self.cap;\n                     let new_size = new_cap * elem_size;\n                     alloc_guard(new_size).expect(\"capacity overflow\");\n-                    let ptr_res = self.a.realloc(self.ptr.as_ptr() as *mut u8,\n+                    let ptr_res = self.a.realloc(NonNull::from(self.ptr).as_void(),\n                                                  cur,\n                                                  new_size);\n                     match ptr_res {\n-                        Ok(ptr) => (new_cap, Unique::new_unchecked(ptr as *mut T)),\n+                        Ok(ptr) => (new_cap, ptr.cast().into()),\n                         Err(_) => self.a.oom(),\n                     }\n                 }\n@@ -369,8 +369,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n             let new_cap = 2 * self.cap;\n             let new_size = new_cap * elem_size;\n             alloc_guard(new_size).expect(\"capacity overflow\");\n-            let ptr = self.ptr() as *mut _;\n-            match self.a.grow_in_place(ptr, old_layout, new_size) {\n+            match self.a.grow_in_place(NonNull::from(self.ptr).as_void(), old_layout, new_size) {\n                 Ok(_) => {\n                     // We can't directly divide `size`.\n                     self.cap = new_cap;\n@@ -427,13 +426,12 @@ impl<T, A: Alloc> RawVec<T, A> {\n             let res = match self.current_layout() {\n                 Some(layout) => {\n                     debug_assert!(new_layout.align() == layout.align());\n-                    let old_ptr = self.ptr.as_ptr() as *mut u8;\n-                    self.a.realloc(old_ptr, layout, new_layout.size())\n+                    self.a.realloc(NonNull::from(self.ptr).as_void(), layout, new_layout.size())\n                 }\n                 None => self.a.alloc(new_layout),\n             };\n \n-            self.ptr = Unique::new_unchecked(res? as *mut T);\n+            self.ptr = res?.cast().into();\n             self.cap = new_cap;\n \n             Ok(())\n@@ -537,13 +535,12 @@ impl<T, A: Alloc> RawVec<T, A> {\n             let res = match self.current_layout() {\n                 Some(layout) => {\n                     debug_assert!(new_layout.align() == layout.align());\n-                    let old_ptr = self.ptr.as_ptr() as *mut u8;\n-                    self.a.realloc(old_ptr, layout, new_layout.size())\n+                    self.a.realloc(NonNull::from(self.ptr).as_void(), layout, new_layout.size())\n                 }\n                 None => self.a.alloc(new_layout),\n             };\n \n-            self.ptr = Unique::new_unchecked(res? as *mut T);\n+            self.ptr = res?.cast().into();\n             self.cap = new_cap;\n \n             Ok(())\n@@ -600,11 +597,12 @@ impl<T, A: Alloc> RawVec<T, A> {\n             // (regardless of whether `self.cap - used_cap` wrapped).\n             // Therefore we can safely call grow_in_place.\n \n-            let ptr = self.ptr() as *mut _;\n             let new_layout = Layout::new::<T>().repeat(new_cap).unwrap().0;\n             // FIXME: may crash and burn on over-reserve\n             alloc_guard(new_layout.size()).expect(\"capacity overflow\");\n-            match self.a.grow_in_place(ptr, old_layout, new_layout.size()) {\n+            match self.a.grow_in_place(\n+                NonNull::from(self.ptr).as_void(), old_layout, new_layout.size(),\n+            ) {\n                 Ok(_) => {\n                     self.cap = new_cap;\n                     true\n@@ -664,10 +662,10 @@ impl<T, A: Alloc> RawVec<T, A> {\n                 let new_size = elem_size * amount;\n                 let align = mem::align_of::<T>();\n                 let old_layout = Layout::from_size_align_unchecked(old_size, align);\n-                match self.a.realloc(self.ptr.as_ptr() as *mut u8,\n+                match self.a.realloc(NonNull::from(self.ptr).as_void(),\n                                      old_layout,\n                                      new_size) {\n-                    Ok(p) => self.ptr = Unique::new_unchecked(p as *mut T),\n+                    Ok(p) => self.ptr = p.cast().into(),\n                     Err(_) => self.a.oom(),\n                 }\n             }\n@@ -700,8 +698,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n         let elem_size = mem::size_of::<T>();\n         if elem_size != 0 {\n             if let Some(layout) = self.current_layout() {\n-                let ptr = self.ptr() as *mut u8;\n-                self.a.dealloc(ptr, layout);\n+                self.a.dealloc(NonNull::from(self.ptr).as_void(), layout);\n             }\n         }\n     }\n@@ -737,6 +734,7 @@ fn alloc_guard(alloc_size: usize) -> Result<(), CollectionAllocErr> {\n #[cfg(test)]\n mod tests {\n     use super::*;\n+    use alloc::Void;\n \n     #[test]\n     fn allocator_param() {\n@@ -756,7 +754,7 @@ mod tests {\n         // before allocation attempts start failing.\n         struct BoundedAlloc { fuel: usize }\n         unsafe impl Alloc for BoundedAlloc {\n-            unsafe fn alloc(&mut self, layout: Layout) -> Result<*mut u8, AllocErr> {\n+            unsafe fn alloc(&mut self, layout: Layout) -> Result<NonNull<Void>, AllocErr> {\n                 let size = layout.size();\n                 if size > self.fuel {\n                     return Err(AllocErr);\n@@ -766,7 +764,7 @@ mod tests {\n                     err @ Err(_) => err,\n                 }\n             }\n-            unsafe fn dealloc(&mut self, ptr: *mut u8, layout: Layout) {\n+            unsafe fn dealloc(&mut self, ptr: NonNull<Void>, layout: Layout) {\n                 Global.dealloc(ptr, layout)\n             }\n         }"}, {"sha": "1c835fe50decba1fe18b8be6fa7455e5a173948d", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fddf51ee0b9765484fc316dbf3d4feb8ceea715d/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fddf51ee0b9765484fc316dbf3d4feb8ceea715d/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=fddf51ee0b9765484fc316dbf3d4feb8ceea715d", "patch": "@@ -259,7 +259,7 @@ use core::ops::CoerceUnsized;\n use core::ptr::{self, NonNull};\n use core::convert::From;\n \n-use alloc::{Global, Alloc, Layout, box_free};\n+use alloc::{Global, Alloc, Layout, Void, box_free};\n use string::String;\n use vec::Vec;\n \n@@ -671,7 +671,7 @@ impl<T: ?Sized> Rc<T> {\n             .unwrap_or_else(|_| Global.oom());\n \n         // Initialize the real RcBox\n-        let inner = set_data_ptr(ptr as *mut T, mem) as *mut RcBox<T>;\n+        let inner = set_data_ptr(ptr as *mut T, mem.as_ptr() as *mut u8) as *mut RcBox<T>;\n \n         ptr::write(&mut (*inner).strong, Cell::new(1));\n         ptr::write(&mut (*inner).weak, Cell::new(1));\n@@ -737,7 +737,7 @@ impl<T: Clone> RcFromSlice<T> for Rc<[T]> {\n         // In the event of a panic, elements that have been written\n         // into the new RcBox will be dropped, then the memory freed.\n         struct Guard<T> {\n-            mem: *mut u8,\n+            mem: NonNull<Void>,\n             elems: *mut T,\n             layout: Layout,\n             n_elems: usize,\n@@ -760,14 +760,14 @@ impl<T: Clone> RcFromSlice<T> for Rc<[T]> {\n             let v_ptr = v as *const [T];\n             let ptr = Self::allocate_for_ptr(v_ptr);\n \n-            let mem = ptr as *mut _ as *mut u8;\n+            let mem = ptr as *mut _ as *mut Void;\n             let layout = Layout::for_value(&*ptr);\n \n             // Pointer to first element\n             let elems = &mut (*ptr).value as *mut [T] as *mut T;\n \n             let mut guard = Guard{\n-                mem: mem,\n+                mem: NonNull::new_unchecked(mem),\n                 elems: elems,\n                 layout: layout,\n                 n_elems: 0,\n@@ -834,8 +834,6 @@ unsafe impl<#[may_dangle] T: ?Sized> Drop for Rc<T> {\n     /// ```\n     fn drop(&mut self) {\n         unsafe {\n-            let ptr = self.ptr.as_ptr();\n-\n             self.dec_strong();\n             if self.strong() == 0 {\n                 // destroy the contained object\n@@ -846,7 +844,7 @@ unsafe impl<#[may_dangle] T: ?Sized> Drop for Rc<T> {\n                 self.dec_weak();\n \n                 if self.weak() == 0 {\n-                    Global.dealloc(ptr as *mut u8, Layout::for_value(&*ptr));\n+                    Global.dealloc(self.ptr.as_void(), Layout::for_value(self.ptr.as_ref()));\n                 }\n             }\n         }\n@@ -1266,13 +1264,11 @@ impl<T: ?Sized> Drop for Weak<T> {\n     /// ```\n     fn drop(&mut self) {\n         unsafe {\n-            let ptr = self.ptr.as_ptr();\n-\n             self.dec_weak();\n             // the weak count starts at 1, and will only go to zero if all\n             // the strong pointers have disappeared.\n             if self.weak() == 0 {\n-                Global.dealloc(ptr as *mut u8, Layout::for_value(&*ptr));\n+                Global.dealloc(self.ptr.as_void(), Layout::for_value(self.ptr.as_ref()));\n             }\n         }\n     }"}, {"sha": "6fa88ce969a0e4866941b80337bd2c5841d31a06", "filename": "src/liballoc/tests/heap.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fddf51ee0b9765484fc316dbf3d4feb8ceea715d/src%2Fliballoc%2Ftests%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fddf51ee0b9765484fc316dbf3d4feb8ceea715d/src%2Fliballoc%2Ftests%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fheap.rs?ref=fddf51ee0b9765484fc316dbf3d4feb8ceea715d", "patch": "@@ -34,7 +34,8 @@ fn check_overalign_requests<T: Alloc>(mut allocator: T) {\n             allocator.alloc(Layout::from_size_align(size, align).unwrap()).unwrap()\n         }).collect();\n         for &ptr in &pointers {\n-            assert_eq!((ptr as usize) % align, 0, \"Got a pointer less aligned than requested\")\n+            assert_eq!((ptr.as_ptr() as usize) % align, 0,\n+                       \"Got a pointer less aligned than requested\")\n         }\n \n         // Clean up"}, {"sha": "bf27e972177cea5d639dab3fb16ddd0fa6731af3", "filename": "src/liballoc_system/lib.rs", "status": "modified", "additions": 15, "deletions": 14, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/fddf51ee0b9765484fc316dbf3d4feb8ceea715d/src%2Fliballoc_system%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fddf51ee0b9765484fc316dbf3d4feb8ceea715d/src%2Fliballoc_system%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc_system%2Flib.rs?ref=fddf51ee0b9765484fc316dbf3d4feb8ceea715d", "patch": "@@ -42,33 +42,34 @@ const MIN_ALIGN: usize = 8;\n const MIN_ALIGN: usize = 16;\n \n use core::alloc::{Alloc, GlobalAlloc, AllocErr, Layout, Void};\n+use core::ptr::NonNull;\n \n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n pub struct System;\n \n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n unsafe impl Alloc for System {\n     #[inline]\n-    unsafe fn alloc(&mut self, layout: Layout) -> Result<*mut u8, AllocErr> {\n+    unsafe fn alloc(&mut self, layout: Layout) -> Result<NonNull<Void>, AllocErr> {\n         GlobalAlloc::alloc(self, layout).into()\n     }\n \n     #[inline]\n-    unsafe fn alloc_zeroed(&mut self, layout: Layout) -> Result<*mut u8, AllocErr> {\n+    unsafe fn alloc_zeroed(&mut self, layout: Layout) -> Result<NonNull<Void>, AllocErr> {\n         GlobalAlloc::alloc_zeroed(self, layout).into()\n     }\n \n     #[inline]\n-    unsafe fn dealloc(&mut self, ptr: *mut u8, layout: Layout) {\n-        GlobalAlloc::dealloc(self, ptr as *mut Void, layout)\n+    unsafe fn dealloc(&mut self, ptr: NonNull<Void>, layout: Layout) {\n+        GlobalAlloc::dealloc(self, ptr.as_ptr(), layout)\n     }\n \n     #[inline]\n     unsafe fn realloc(&mut self,\n-                      ptr: *mut u8,\n+                      ptr: NonNull<Void>,\n                       old_layout: Layout,\n-                      new_size: usize) -> Result<*mut u8, AllocErr> {\n-        GlobalAlloc::realloc(self, ptr as *mut Void, old_layout, new_size).into()\n+                      new_size: usize) -> Result<NonNull<Void>, AllocErr> {\n+        GlobalAlloc::realloc(self, ptr.as_ptr(), old_layout, new_size).into()\n     }\n \n     #[inline]\n@@ -81,26 +82,26 @@ unsafe impl Alloc for System {\n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n unsafe impl<'a> Alloc for &'a System {\n     #[inline]\n-    unsafe fn alloc(&mut self, layout: Layout) -> Result<*mut u8, AllocErr> {\n+    unsafe fn alloc(&mut self, layout: Layout) -> Result<NonNull<Void>, AllocErr> {\n         GlobalAlloc::alloc(*self, layout).into()\n     }\n \n     #[inline]\n-    unsafe fn alloc_zeroed(&mut self, layout: Layout) -> Result<*mut u8, AllocErr> {\n+    unsafe fn alloc_zeroed(&mut self, layout: Layout) -> Result<NonNull<Void>, AllocErr> {\n         GlobalAlloc::alloc_zeroed(*self, layout).into()\n     }\n \n     #[inline]\n-    unsafe fn dealloc(&mut self, ptr: *mut u8, layout: Layout) {\n-        GlobalAlloc::dealloc(*self, ptr as *mut Void, layout)\n+    unsafe fn dealloc(&mut self, ptr: NonNull<Void>, layout: Layout) {\n+        GlobalAlloc::dealloc(*self, ptr.as_ptr(), layout)\n     }\n \n     #[inline]\n     unsafe fn realloc(&mut self,\n-                      ptr: *mut u8,\n+                      ptr: NonNull<Void>,\n                       old_layout: Layout,\n-                      new_size: usize) -> Result<*mut u8, AllocErr> {\n-        GlobalAlloc::realloc(*self, ptr as *mut Void, old_layout, new_size).into()\n+                      new_size: usize) -> Result<NonNull<Void>, AllocErr> {\n+        GlobalAlloc::realloc(*self, ptr.as_ptr(), old_layout, new_size).into()\n     }\n \n     #[inline]"}, {"sha": "632eed960492c316423b06f8e5478a546146bd6a", "filename": "src/libcore/alloc.rs", "status": "modified", "additions": 25, "deletions": 33, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/fddf51ee0b9765484fc316dbf3d4feb8ceea715d/src%2Flibcore%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fddf51ee0b9765484fc316dbf3d4feb8ceea715d/src%2Flibcore%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Falloc.rs?ref=fddf51ee0b9765484fc316dbf3d4feb8ceea715d", "patch": "@@ -42,21 +42,17 @@ impl Void {\n }\n \n /// Convert from a return value of GlobalAlloc::alloc to that of Alloc::alloc\n-impl From<*mut Void> for Result<*mut u8, AllocErr> {\n+impl From<*mut Void> for Result<NonNull<Void>, AllocErr> {\n     fn from(ptr: *mut Void) -> Self {\n-        if !ptr.is_null() {\n-            Ok(ptr as *mut u8)\n-        } else {\n-            Err(AllocErr)\n-        }\n+        NonNull::new(ptr).ok_or(AllocErr)\n     }\n }\n \n /// Convert from a return value of Alloc::alloc to that of GlobalAlloc::alloc\n-impl From<Result<*mut u8, AllocErr>> for *mut Void {\n-    fn from(result: Result<*mut u8, AllocErr>) -> Self {\n+impl From<Result<NonNull<Void>, AllocErr>> for *mut Void {\n+    fn from(result: Result<NonNull<Void>, AllocErr>) -> Self {\n         match result {\n-            Ok(ptr) => ptr as *mut Void,\n+            Ok(ptr) => ptr.as_ptr(),\n             Err(_) => Void::null_mut(),\n         }\n     }\n@@ -65,7 +61,7 @@ impl From<Result<*mut u8, AllocErr>> for *mut Void {\n /// Represents the combination of a starting address and\n /// a total capacity of the returned block.\n #[derive(Debug)]\n-pub struct Excess(pub *mut u8, pub usize);\n+pub struct Excess(pub NonNull<Void>, pub usize);\n \n fn size_align<T>() -> (usize, usize) {\n     (mem::size_of::<T>(), mem::align_of::<T>())\n@@ -575,7 +571,7 @@ pub unsafe trait Alloc {\n     /// Clients wishing to abort computation in response to an\n     /// allocation error are encouraged to call the allocator's `oom`\n     /// method, rather than directly invoking `panic!` or similar.\n-    unsafe fn alloc(&mut self, layout: Layout) -> Result<*mut u8, AllocErr>;\n+    unsafe fn alloc(&mut self, layout: Layout) -> Result<NonNull<Void>, AllocErr>;\n \n     /// Deallocate the memory referenced by `ptr`.\n     ///\n@@ -592,7 +588,7 @@ pub unsafe trait Alloc {\n     /// * In addition to fitting the block of memory `layout`, the\n     ///   alignment of the `layout` must match the alignment used\n     ///   to allocate that block of memory.\n-    unsafe fn dealloc(&mut self, ptr: *mut u8, layout: Layout);\n+    unsafe fn dealloc(&mut self, ptr: NonNull<Void>, layout: Layout);\n \n     /// Allocator-specific method for signaling an out-of-memory\n     /// condition.\n@@ -710,9 +706,9 @@ pub unsafe trait Alloc {\n     /// reallocation error are encouraged to call the allocator's `oom`\n     /// method, rather than directly invoking `panic!` or similar.\n     unsafe fn realloc(&mut self,\n-                      ptr: *mut u8,\n+                      ptr: NonNull<Void>,\n                       layout: Layout,\n-                      new_size: usize) -> Result<*mut u8, AllocErr> {\n+                      new_size: usize) -> Result<NonNull<Void>, AllocErr> {\n         let old_size = layout.size();\n \n         if new_size >= old_size {\n@@ -729,7 +725,9 @@ pub unsafe trait Alloc {\n         let new_layout = Layout::from_size_align_unchecked(new_size, layout.align());\n         let result = self.alloc(new_layout);\n         if let Ok(new_ptr) = result {\n-            ptr::copy_nonoverlapping(ptr as *const u8, new_ptr, cmp::min(old_size, new_size));\n+            ptr::copy_nonoverlapping(ptr.as_ptr() as *const u8,\n+                                     new_ptr.as_ptr() as *mut u8,\n+                                     cmp::min(old_size, new_size));\n             self.dealloc(ptr, layout);\n         }\n         result\n@@ -751,11 +749,11 @@ pub unsafe trait Alloc {\n     /// Clients wishing to abort computation in response to an\n     /// allocation error are encouraged to call the allocator's `oom`\n     /// method, rather than directly invoking `panic!` or similar.\n-    unsafe fn alloc_zeroed(&mut self, layout: Layout) -> Result<*mut u8, AllocErr> {\n+    unsafe fn alloc_zeroed(&mut self, layout: Layout) -> Result<NonNull<Void>, AllocErr> {\n         let size = layout.size();\n         let p = self.alloc(layout);\n         if let Ok(p) = p {\n-            ptr::write_bytes(p, 0, size);\n+            ptr::write_bytes(p.as_ptr() as *mut u8, 0, size);\n         }\n         p\n     }\n@@ -800,7 +798,7 @@ pub unsafe trait Alloc {\n     /// reallocation error are encouraged to call the allocator's `oom`\n     /// method, rather than directly invoking `panic!` or similar.\n     unsafe fn realloc_excess(&mut self,\n-                             ptr: *mut u8,\n+                             ptr: NonNull<Void>,\n                              layout: Layout,\n                              new_size: usize) -> Result<Excess, AllocErr> {\n         let new_layout = Layout::from_size_align_unchecked(new_size, layout.align());\n@@ -845,7 +843,7 @@ pub unsafe trait Alloc {\n     /// `grow_in_place` failures without aborting, or to fall back on\n     /// another reallocation method before resorting to an abort.\n     unsafe fn grow_in_place(&mut self,\n-                            ptr: *mut u8,\n+                            ptr: NonNull<Void>,\n                             layout: Layout,\n                             new_size: usize) -> Result<(), CannotReallocInPlace> {\n         let _ = ptr; // this default implementation doesn't care about the actual address.\n@@ -900,7 +898,7 @@ pub unsafe trait Alloc {\n     /// `shrink_in_place` failures without aborting, or to fall back\n     /// on another reallocation method before resorting to an abort.\n     unsafe fn shrink_in_place(&mut self,\n-                              ptr: *mut u8,\n+                              ptr: NonNull<Void>,\n                               layout: Layout,\n                               new_size: usize) -> Result<(), CannotReallocInPlace> {\n         let _ = ptr; // this default implementation doesn't care about the actual address.\n@@ -951,7 +949,7 @@ pub unsafe trait Alloc {\n     {\n         let k = Layout::new::<T>();\n         if k.size() > 0 {\n-            unsafe { self.alloc(k).map(|p| NonNull::new_unchecked(p as *mut T)) }\n+            unsafe { self.alloc(k).map(|p| p.cast()) }\n         } else {\n             Err(AllocErr)\n         }\n@@ -977,10 +975,9 @@ pub unsafe trait Alloc {\n     unsafe fn dealloc_one<T>(&mut self, ptr: NonNull<T>)\n         where Self: Sized\n     {\n-        let raw_ptr = ptr.as_ptr() as *mut u8;\n         let k = Layout::new::<T>();\n         if k.size() > 0 {\n-            self.dealloc(raw_ptr, k);\n+            self.dealloc(ptr.as_void(), k);\n         }\n     }\n \n@@ -1020,10 +1017,7 @@ pub unsafe trait Alloc {\n         match Layout::array::<T>(n) {\n             Ok(ref layout) if layout.size() > 0 => {\n                 unsafe {\n-                    self.alloc(layout.clone())\n-                        .map(|p| {\n-                            NonNull::new_unchecked(p as *mut T)\n-                        })\n+                    self.alloc(layout.clone()).map(|p| p.cast())\n                 }\n             }\n             _ => Err(AllocErr),\n@@ -1068,11 +1062,10 @@ pub unsafe trait Alloc {\n                                n_new: usize) -> Result<NonNull<T>, AllocErr>\n         where Self: Sized\n     {\n-        match (Layout::array::<T>(n_old), Layout::array::<T>(n_new), ptr.as_ptr()) {\n-            (Ok(ref k_old), Ok(ref k_new), ptr) if k_old.size() > 0 && k_new.size() > 0 => {\n+        match (Layout::array::<T>(n_old), Layout::array::<T>(n_new)) {\n+            (Ok(ref k_old), Ok(ref k_new)) if k_old.size() > 0 && k_new.size() > 0 => {\n                 debug_assert!(k_old.align() == k_new.align());\n-                self.realloc(ptr as *mut u8, k_old.clone(), k_new.size())\n-                    .map(|p| NonNull::new_unchecked(p as *mut T))\n+                self.realloc(ptr.as_void(), k_old.clone(), k_new.size()).map(NonNull::cast)\n             }\n             _ => {\n                 Err(AllocErr)\n@@ -1103,10 +1096,9 @@ pub unsafe trait Alloc {\n     unsafe fn dealloc_array<T>(&mut self, ptr: NonNull<T>, n: usize) -> Result<(), AllocErr>\n         where Self: Sized\n     {\n-        let raw_ptr = ptr.as_ptr() as *mut u8;\n         match Layout::array::<T>(n) {\n             Ok(ref k) if k.size() > 0 => {\n-                Ok(self.dealloc(raw_ptr, k.clone()))\n+                Ok(self.dealloc(ptr.as_void(), k.clone()))\n             }\n             _ => {\n                 Err(AllocErr)"}, {"sha": "f4e668328ce97b0a93461f5b3b636f63943930fe", "filename": "src/libcore/ptr.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fddf51ee0b9765484fc316dbf3d4feb8ceea715d/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fddf51ee0b9765484fc316dbf3d4feb8ceea715d/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=fddf51ee0b9765484fc316dbf3d4feb8ceea715d", "patch": "@@ -2750,6 +2750,14 @@ impl<T: ?Sized> NonNull<T> {\n             NonNull::new_unchecked(self.as_ptr() as *mut U)\n         }\n     }\n+\n+    /// Cast to a `Void` pointer\n+    #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n+    pub fn as_void(self) -> NonNull<::alloc::Void> {\n+        unsafe {\n+            NonNull::new_unchecked(self.as_ptr() as _)\n+        }\n+    }\n }\n \n #[stable(feature = \"nonnull\", since = \"1.25.0\")]"}, {"sha": "38c993737880ef900b16f1cc9a73f6a646181a29", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fddf51ee0b9765484fc316dbf3d4feb8ceea715d/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fddf51ee0b9765484fc316dbf3d4feb8ceea715d/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=fddf51ee0b9765484fc316dbf3d4feb8ceea715d", "patch": "@@ -757,12 +757,10 @@ impl<K, V> RawTable<K, V> {\n         let buffer = Global.alloc(Layout::from_size_align(size, alignment)\n             .map_err(|_| CollectionAllocErr::CapacityOverflow)?)?;\n \n-        let hashes = buffer as *mut HashUint;\n-\n         Ok(RawTable {\n             capacity_mask: capacity.wrapping_sub(1),\n             size: 0,\n-            hashes: TaggedHashUintPtr::new(hashes),\n+            hashes: TaggedHashUintPtr::new(buffer.cast().as_ptr()),\n             marker: marker::PhantomData,\n         })\n     }\n@@ -1185,7 +1183,7 @@ unsafe impl<#[may_dangle] K, #[may_dangle] V> Drop for RawTable<K, V> {\n         debug_assert!(!oflo, \"should be impossible\");\n \n         unsafe {\n-            Global.dealloc(self.hashes.ptr() as *mut u8,\n+            Global.dealloc(NonNull::new_unchecked(self.hashes.ptr()).as_void(),\n                            Layout::from_size_align(size, align).unwrap());\n             // Remember how everything was allocated out of one buffer\n             // during initialization? We only need one call to free here."}, {"sha": "a34fcb5a7f98b4221dbf37d44a9f5a49d3417511", "filename": "src/libstd/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fddf51ee0b9765484fc316dbf3d4feb8ceea715d/src%2Flibstd%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fddf51ee0b9765484fc316dbf3d4feb8ceea715d/src%2Flibstd%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Flib.rs?ref=fddf51ee0b9765484fc316dbf3d4feb8ceea715d", "patch": "@@ -275,6 +275,7 @@\n #![feature(macro_reexport)]\n #![feature(macro_vis_matcher)]\n #![feature(needs_panic_runtime)]\n+#![feature(nonnull_cast)]\n #![feature(exhaustive_patterns)]\n #![feature(nonzero)]\n #![feature(num_bits_bytes)]"}, {"sha": "b8e844522dc8bb5a458da95463ee457aec92b08a", "filename": "src/test/run-pass/allocator/xcrate-use2.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fddf51ee0b9765484fc316dbf3d4feb8ceea715d/src%2Ftest%2Frun-pass%2Fallocator%2Fxcrate-use2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fddf51ee0b9765484fc316dbf3d4feb8ceea715d/src%2Ftest%2Frun-pass%2Fallocator%2Fxcrate-use2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fallocator%2Fxcrate-use2.rs?ref=fddf51ee0b9765484fc316dbf3d4feb8ceea715d", "patch": "@@ -30,7 +30,7 @@ fn main() {\n         let layout = Layout::from_size_align(4, 2).unwrap();\n \n         // Global allocator routes to the `custom_as_global` global\n-        let ptr = Global.alloc(layout.clone()).unwrap();\n+        let ptr = Global.alloc(layout.clone());\n         helper::work_with(&ptr);\n         assert_eq!(custom_as_global::get(), n + 1);\n         Global.dealloc(ptr, layout.clone());"}, {"sha": "49ab0ee33109d2e099357e32e4459c257ff9607d", "filename": "src/test/run-pass/realloc-16687.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fddf51ee0b9765484fc316dbf3d4feb8ceea715d/src%2Ftest%2Frun-pass%2Frealloc-16687.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fddf51ee0b9765484fc316dbf3d4feb8ceea715d/src%2Ftest%2Frun-pass%2Frealloc-16687.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Frealloc-16687.rs?ref=fddf51ee0b9765484fc316dbf3d4feb8ceea715d", "patch": "@@ -13,10 +13,10 @@\n // Ideally this would be revised to use no_std, but for now it serves\n // well enough to reproduce (and illustrate) the bug from #16687.\n \n-#![feature(heap_api, allocator_api)]\n+#![feature(heap_api, allocator_api, nonnull_cast)]\n \n-use std::heap::{Heap, Alloc, Layout};\n-use std::ptr;\n+use std::alloc::{Global, Alloc, Layout};\n+use std::ptr::{self, NonNull};\n \n fn main() {\n     unsafe {\n@@ -50,36 +50,36 @@ unsafe fn test_triangle() -> bool {\n             println!(\"allocate({:?})\", layout);\n         }\n \n-        let ret = Heap.alloc(layout.clone()).unwrap_or_else(|_| Heap.oom());\n+        let ret = Global.alloc(layout.clone()).unwrap_or_else(|_| Global.oom());\n \n         if PRINT {\n             println!(\"allocate({:?}) = {:?}\", layout, ret);\n         }\n \n-        ret\n+        ret.cast().as_ptr()\n     }\n \n     unsafe fn deallocate(ptr: *mut u8, layout: Layout) {\n         if PRINT {\n             println!(\"deallocate({:?}, {:?}\", ptr, layout);\n         }\n \n-        Heap.dealloc(ptr, layout);\n+        Global.dealloc(NonNull::new_unchecked(ptr).as_void(), layout);\n     }\n \n     unsafe fn reallocate(ptr: *mut u8, old: Layout, new: Layout) -> *mut u8 {\n         if PRINT {\n             println!(\"reallocate({:?}, old={:?}, new={:?})\", ptr, old, new);\n         }\n \n-        let ret = Heap.realloc(ptr, old.clone(), new.clone())\n-            .unwrap_or_else(|_| Heap.oom());\n+        let ret = Global.realloc(NonNull::new_unchecked(ptr).as_void(), old.clone(), new.size())\n+            .unwrap_or_else(|_| Global.oom());\n \n         if PRINT {\n             println!(\"reallocate({:?}, old={:?}, new={:?}) = {:?}\",\n                      ptr, old, new, ret);\n         }\n-        ret\n+        ret.cast().as_ptr()\n     }\n \n     fn idx_to_size(i: usize) -> usize { (i+1) * 10 }"}, {"sha": "3c37243c8b938e4e69ab6c8d33253760e70703a9", "filename": "src/test/run-pass/regions-mock-trans.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fddf51ee0b9765484fc316dbf3d4feb8ceea715d/src%2Ftest%2Frun-pass%2Fregions-mock-trans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fddf51ee0b9765484fc316dbf3d4feb8ceea715d/src%2Ftest%2Frun-pass%2Fregions-mock-trans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fregions-mock-trans.rs?ref=fddf51ee0b9765484fc316dbf3d4feb8ceea715d", "patch": "@@ -13,6 +13,7 @@\n #![feature(allocator_api)]\n \n use std::heap::{Alloc, Heap, Layout};\n+use std::ptr::NonNull;\n \n struct arena(());\n \n@@ -33,7 +34,7 @@ fn alloc<'a>(_bcx : &'a arena) -> &'a Bcx<'a> {\n     unsafe {\n         let ptr = Heap.alloc(Layout::new::<Bcx>())\n             .unwrap_or_else(|_| Heap.oom());\n-        &*(ptr as *const _)\n+        &*(ptr.as_ptr() as *const _)\n     }\n }\n \n@@ -45,7 +46,7 @@ fn g(fcx : &Fcx) {\n     let bcx = Bcx { fcx: fcx };\n     let bcx2 = h(&bcx);\n     unsafe {\n-        Heap.dealloc(bcx2 as *const _ as *mut _, Layout::new::<Bcx>());\n+        Heap.dealloc(NonNull::new_unchecked(bcx2 as *const _ as *mut _), Layout::new::<Bcx>());\n     }\n }\n "}]}