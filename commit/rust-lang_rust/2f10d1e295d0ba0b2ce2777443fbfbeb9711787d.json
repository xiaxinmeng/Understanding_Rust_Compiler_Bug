{"sha": "2f10d1e295d0ba0b2ce2777443fbfbeb9711787d", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmMTBkMWUyOTVkMGJhMGIyY2UyNzc3NDQzZmJmYmViOTcxMTc4N2Q=", "commit": {"author": {"name": "blake2-ppc", "email": "blake2-ppc", "date": "2013-07-29T19:22:54Z"}, "committer": {"name": "blake2-ppc", "email": "blake2-ppc", "date": "2013-07-29T23:48:17Z"}, "message": "extra: Implement DoubleEnded and RandomAccess iterators for bitv", "tree": {"sha": "4a173f08fcaf6dd90d3aa0ed225305202416b22e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4a173f08fcaf6dd90d3aa0ed225305202416b22e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2f10d1e295d0ba0b2ce2777443fbfbeb9711787d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2f10d1e295d0ba0b2ce2777443fbfbeb9711787d", "html_url": "https://github.com/rust-lang/rust/commit/2f10d1e295d0ba0b2ce2777443fbfbeb9711787d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2f10d1e295d0ba0b2ce2777443fbfbeb9711787d/comments", "author": null, "committer": null, "parents": [{"sha": "2ff84124f0d39b20f49ce04f71d31322cdf1a327", "url": "https://api.github.com/repos/rust-lang/rust/commits/2ff84124f0d39b20f49ce04f71d31322cdf1a327", "html_url": "https://github.com/rust-lang/rust/commit/2ff84124f0d39b20f49ce04f71d31322cdf1a327"}], "stats": {"total": 39, "additions": 35, "deletions": 4}, "files": [{"sha": "914aa20792f16aaedd5b39231782e66583c3448c", "filename": "src/libextra/bitv.rs", "status": "modified", "additions": 35, "deletions": 4, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/2f10d1e295d0ba0b2ce2777443fbfbeb9711787d/src%2Flibextra%2Fbitv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2f10d1e295d0ba0b2ce2777443fbfbeb9711787d/src%2Flibextra%2Fbitv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibextra%2Fbitv.rs?ref=2f10d1e295d0ba0b2ce2777443fbfbeb9711787d", "patch": "@@ -12,11 +12,13 @@\n \n \n use std::cmp;\n+use std::iterator::{DoubleEndedIterator, RandomAccessIterator, Invert};\n use std::num;\n use std::ops;\n use std::uint;\n use std::vec;\n \n+\n #[deriving(Clone)]\n struct SmallBitv {\n     /// only the lowest nbits of this value are used. the rest is undefined.\n@@ -404,7 +406,7 @@ impl Bitv {\n \n     #[inline]\n     pub fn iter<'a>(&'a self) -> BitvIterator<'a> {\n-        BitvIterator {bitv: self, next_idx: 0}\n+        BitvIterator {bitv: self, next_idx: 0, end_idx: self.nbits}\n     }\n \n     /// Returns true if all bits are 0\n@@ -564,13 +566,14 @@ fn iterate_bits(base: uint, bits: uint, f: &fn(uint) -> bool) -> bool {\n /// An iterator for Bitv\n pub struct BitvIterator<'self> {\n     priv bitv: &'self Bitv,\n-    priv next_idx: uint\n+    priv next_idx: uint,\n+    priv end_idx: uint,\n }\n \n impl<'self> Iterator<bool> for BitvIterator<'self> {\n     #[inline]\n     fn next(&mut self) -> Option<bool> {\n-        if self.next_idx < self.bitv.nbits {\n+        if self.next_idx != self.end_idx {\n             let idx = self.next_idx;\n             self.next_idx += 1;\n             Some(self.bitv.get(idx))\n@@ -580,11 +583,39 @@ impl<'self> Iterator<bool> for BitvIterator<'self> {\n     }\n \n     fn size_hint(&self) -> (uint, Option<uint>) {\n-        let rem = self.bitv.nbits - self.next_idx;\n+        let rem = self.end_idx - self.next_idx;\n         (rem, Some(rem))\n     }\n }\n \n+impl<'self> DoubleEndedIterator<bool> for BitvIterator<'self> {\n+    #[inline]\n+    fn next_back(&mut self) -> Option<bool> {\n+        if self.next_idx != self.end_idx {\n+            self.end_idx -= 1;\n+            Some(self.bitv.get(self.end_idx))\n+        } else {\n+            None\n+        }\n+    }\n+}\n+\n+impl<'self> RandomAccessIterator<bool> for BitvIterator<'self> {\n+    #[inline]\n+    fn indexable(&self) -> uint {\n+        self.end_idx - self.next_idx\n+    }\n+\n+    #[inline]\n+    fn idx(&self, index: uint) -> Option<bool> {\n+        if index >= self.indexable() {\n+            None\n+        } else {\n+            Some(self.bitv.get(index))\n+        }\n+    }\n+}\n+\n /// An implementation of a set using a bit vector as an underlying\n /// representation for holding numerical elements.\n ///"}]}