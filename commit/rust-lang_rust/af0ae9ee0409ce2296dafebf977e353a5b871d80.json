{"sha": "af0ae9ee0409ce2296dafebf977e353a5b871d80", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFmMGFlOWVlMDQwOWNlMjI5NmRhZmViZjk3N2UzNTNhNWI4NzFkODA=", "commit": {"author": {"name": "Zach Lute", "email": "zach.lute@gmail.com", "date": "2018-09-05T05:56:16Z"}, "committer": {"name": "Zach Lute", "email": "zach.lute@gmail.com", "date": "2018-09-05T05:56:16Z"}, "message": "Updated Ptr methods to better match Parser method names.", "tree": {"sha": "58a5db64a5279bf6586481224e8a772c3f965bfc", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/58a5db64a5279bf6586481224e8a772c3f965bfc"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/af0ae9ee0409ce2296dafebf977e353a5b871d80", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/af0ae9ee0409ce2296dafebf977e353a5b871d80", "html_url": "https://github.com/rust-lang/rust/commit/af0ae9ee0409ce2296dafebf977e353a5b871d80", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/af0ae9ee0409ce2296dafebf977e353a5b871d80/comments", "author": {"login": "zachlute", "id": 308981, "node_id": "MDQ6VXNlcjMwODk4MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/308981?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zachlute", "html_url": "https://github.com/zachlute", "followers_url": "https://api.github.com/users/zachlute/followers", "following_url": "https://api.github.com/users/zachlute/following{/other_user}", "gists_url": "https://api.github.com/users/zachlute/gists{/gist_id}", "starred_url": "https://api.github.com/users/zachlute/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zachlute/subscriptions", "organizations_url": "https://api.github.com/users/zachlute/orgs", "repos_url": "https://api.github.com/users/zachlute/repos", "events_url": "https://api.github.com/users/zachlute/events{/privacy}", "received_events_url": "https://api.github.com/users/zachlute/received_events", "type": "User", "site_admin": false}, "committer": {"login": "zachlute", "id": 308981, "node_id": "MDQ6VXNlcjMwODk4MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/308981?v=4", "gravatar_id": "", "url": "https://api.github.com/users/zachlute", "html_url": "https://github.com/zachlute", "followers_url": "https://api.github.com/users/zachlute/followers", "following_url": "https://api.github.com/users/zachlute/following{/other_user}", "gists_url": "https://api.github.com/users/zachlute/gists{/gist_id}", "starred_url": "https://api.github.com/users/zachlute/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/zachlute/subscriptions", "organizations_url": "https://api.github.com/users/zachlute/orgs", "repos_url": "https://api.github.com/users/zachlute/repos", "events_url": "https://api.github.com/users/zachlute/events{/privacy}", "received_events_url": "https://api.github.com/users/zachlute/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f87771092c5df9e9c07bcb5052e662bde0a0fa59", "url": "https://api.github.com/repos/rust-lang/rust/commits/f87771092c5df9e9c07bcb5052e662bde0a0fa59", "html_url": "https://github.com/rust-lang/rust/commit/f87771092c5df9e9c07bcb5052e662bde0a0fa59"}], "stats": {"total": 104, "additions": 59, "deletions": 45}, "files": [{"sha": "eb417c2dc4f0f044b57c84eed099b9f21c2592d6", "filename": "crates/libsyntax2/src/lexer/comments.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/af0ae9ee0409ce2296dafebf977e353a5b871d80/crates%2Flibsyntax2%2Fsrc%2Flexer%2Fcomments.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af0ae9ee0409ce2296dafebf977e353a5b871d80/crates%2Flibsyntax2%2Fsrc%2Flexer%2Fcomments.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibsyntax2%2Fsrc%2Flexer%2Fcomments.rs?ref=af0ae9ee0409ce2296dafebf977e353a5b871d80", "patch": "@@ -3,7 +3,7 @@ use lexer::ptr::Ptr;\n use SyntaxKind::{self, *};\n \n pub(crate) fn scan_shebang(ptr: &mut Ptr) -> bool {\n-    if ptr.next_is('!') && ptr.nnext_is('/') {\n+    if ptr.at_str(\"!/\") {\n         ptr.bump();\n         ptr.bump();\n         bump_until_eol(ptr);\n@@ -14,15 +14,15 @@ pub(crate) fn scan_shebang(ptr: &mut Ptr) -> bool {\n }\n \n fn scan_block_comment(ptr: &mut Ptr) -> Option<SyntaxKind> {\n-    if ptr.next_is('*') {\n+    if ptr.at('*') {\n         ptr.bump();\n         let mut depth: u32 = 1;\n         while depth > 0 {\n-            if ptr.next_is('*') && ptr.nnext_is('/') {\n+            if ptr.at_str(\"*/\") {\n                 depth -= 1;\n                 ptr.bump();\n                 ptr.bump();\n-            } else if ptr.next_is('/') && ptr.nnext_is('*') {\n+            } else if ptr.at_str(\"/*\") {\n                 depth += 1;\n                 ptr.bump();\n                 ptr.bump();\n@@ -37,7 +37,7 @@ fn scan_block_comment(ptr: &mut Ptr) -> Option<SyntaxKind> {\n }\n \n pub(crate) fn scan_comment(ptr: &mut Ptr) -> Option<SyntaxKind> {\n-    if ptr.next_is('/') {\n+    if ptr.at('/') {\n         bump_until_eol(ptr);\n         Some(COMMENT)\n     } else {\n@@ -47,7 +47,7 @@ pub(crate) fn scan_comment(ptr: &mut Ptr) -> Option<SyntaxKind> {\n \n fn bump_until_eol(ptr: &mut Ptr) {\n     loop {\n-        if ptr.next_is('\\n') || ptr.next_is('\\r') && ptr.nnext_is('\\n') {\n+        if ptr.at('\\n') || ptr.at_str(\"\\r\\n\") {\n             return;\n         }\n         if ptr.bump().is_none() {"}, {"sha": "3e11db88b2702782ea4d9fa4f71a4309c16431e5", "filename": "crates/libsyntax2/src/lexer/mod.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/af0ae9ee0409ce2296dafebf977e353a5b871d80/crates%2Flibsyntax2%2Fsrc%2Flexer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af0ae9ee0409ce2296dafebf977e353a5b871d80/crates%2Flibsyntax2%2Fsrc%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibsyntax2%2Fsrc%2Flexer%2Fmod.rs?ref=af0ae9ee0409ce2296dafebf977e353a5b871d80", "patch": "@@ -67,7 +67,7 @@ fn next_token_inner(c: char, ptr: &mut Ptr) -> SyntaxKind {\n         _ => (),\n     }\n \n-    let ident_start = is_ident_start(c) && !is_string_literal_start(c, ptr.next(), ptr.nnext());\n+    let ident_start = is_ident_start(c) && !is_string_literal_start(c, ptr.current(), ptr.nth(1));\n     if ident_start {\n         return scan_ident(c, ptr);\n     }\n@@ -86,7 +86,7 @@ fn next_token_inner(c: char, ptr: &mut Ptr) -> SyntaxKind {\n     match c {\n         // Multi-byte tokens.\n         '.' => {\n-            return match (ptr.next(), ptr.nnext()) {\n+            return match (ptr.current(), ptr.nth(1)) {\n                 (Some('.'), Some('.')) => {\n                     ptr.bump();\n                     ptr.bump();\n@@ -105,7 +105,7 @@ fn next_token_inner(c: char, ptr: &mut Ptr) -> SyntaxKind {\n             };\n         }\n         ':' => {\n-            return match ptr.next() {\n+            return match ptr.current() {\n                 Some(':') => {\n                     ptr.bump();\n                     COLONCOLON\n@@ -114,7 +114,7 @@ fn next_token_inner(c: char, ptr: &mut Ptr) -> SyntaxKind {\n             };\n         }\n         '=' => {\n-            return match ptr.next() {\n+            return match ptr.current() {\n                 Some('=') => {\n                     ptr.bump();\n                     EQEQ\n@@ -127,7 +127,7 @@ fn next_token_inner(c: char, ptr: &mut Ptr) -> SyntaxKind {\n             };\n         }\n         '!' => {\n-            return match ptr.next() {\n+            return match ptr.current() {\n                 Some('=') => {\n                     ptr.bump();\n                     NEQ\n@@ -136,7 +136,7 @@ fn next_token_inner(c: char, ptr: &mut Ptr) -> SyntaxKind {\n             };\n         }\n         '-' => {\n-            return if ptr.next_is('>') {\n+            return if ptr.at('>') {\n                 ptr.bump();\n                 THIN_ARROW\n             } else {\n@@ -147,14 +147,14 @@ fn next_token_inner(c: char, ptr: &mut Ptr) -> SyntaxKind {\n         // If the character is an ident start not followed by another single\n         // quote, then this is a lifetime name:\n         '\\'' => {\n-            return if ptr.next_is_p(is_ident_start) && !ptr.nnext_is('\\'') {\n+            return if ptr.at_p(is_ident_start) && !ptr.at_str(\"''\") {\n                 ptr.bump();\n-                while ptr.next_is_p(is_ident_continue) {\n+                while ptr.at_p(is_ident_continue) {\n                     ptr.bump();\n                 }\n                 // lifetimes shouldn't end with a single quote\n                 // if we find one, then this is an invalid character literal\n-                if ptr.next_is('\\'') {\n+                if ptr.at('\\'') {\n                     ptr.bump();\n                     return CHAR; // TODO: error reporting\n                 }\n@@ -186,7 +186,7 @@ fn next_token_inner(c: char, ptr: &mut Ptr) -> SyntaxKind {\n }\n \n fn scan_ident(c: char, ptr: &mut Ptr) -> SyntaxKind {\n-    let is_single_letter = match ptr.next() {\n+    let is_single_letter = match ptr.current() {\n         None => true,\n         Some(c) if !is_ident_continue(c) => true,\n         _ => false,\n@@ -202,7 +202,7 @@ fn scan_ident(c: char, ptr: &mut Ptr) -> SyntaxKind {\n }\n \n fn scan_literal_suffix(ptr: &mut Ptr) {\n-    if ptr.next_is_p(is_ident_start) {\n+    if ptr.at_p(is_ident_start) {\n         ptr.bump();\n     }\n     ptr.bump_while(is_ident_continue);"}, {"sha": "22e7d4e99d6a45c61c36ce4e2ce2aef6641674b1", "filename": "crates/libsyntax2/src/lexer/numbers.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/af0ae9ee0409ce2296dafebf977e353a5b871d80/crates%2Flibsyntax2%2Fsrc%2Flexer%2Fnumbers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af0ae9ee0409ce2296dafebf977e353a5b871d80/crates%2Flibsyntax2%2Fsrc%2Flexer%2Fnumbers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibsyntax2%2Fsrc%2Flexer%2Fnumbers.rs?ref=af0ae9ee0409ce2296dafebf977e353a5b871d80", "patch": "@@ -5,7 +5,7 @@ use SyntaxKind::{self, *};\n \n pub(crate) fn scan_number(c: char, ptr: &mut Ptr) -> SyntaxKind {\n     if c == '0' {\n-        match ptr.next().unwrap_or('\\0') {\n+        match ptr.current().unwrap_or('\\0') {\n             'b' | 'o' => {\n                 ptr.bump();\n                 scan_digits(ptr, false);\n@@ -26,7 +26,7 @@ pub(crate) fn scan_number(c: char, ptr: &mut Ptr) -> SyntaxKind {\n     // might be a float, but don't be greedy if this is actually an\n     // integer literal followed by field/method access or a range pattern\n     // (`0..2` and `12.foo()`)\n-    if ptr.next_is('.') && !(ptr.nnext_is('.') || ptr.nnext_is_p(is_ident_start)) {\n+    if ptr.at('.') && !(ptr.at_str(\"..\") || ptr.nth_is_p(1, is_ident_start)) {\n         // might have stuff after the ., and if it does, it needs to start\n         // with a number\n         ptr.bump();\n@@ -35,15 +35,15 @@ pub(crate) fn scan_number(c: char, ptr: &mut Ptr) -> SyntaxKind {\n         return FLOAT_NUMBER;\n     }\n     // it might be a float if it has an exponent\n-    if ptr.next_is('e') || ptr.next_is('E') {\n+    if ptr.at('e') || ptr.at('E') {\n         scan_float_exponent(ptr);\n         return FLOAT_NUMBER;\n     }\n     INT_NUMBER\n }\n \n fn scan_digits(ptr: &mut Ptr, allow_hex: bool) {\n-    while let Some(c) = ptr.next() {\n+    while let Some(c) = ptr.current() {\n         match c {\n             '_' | '0'...'9' => {\n                 ptr.bump();\n@@ -57,9 +57,9 @@ fn scan_digits(ptr: &mut Ptr, allow_hex: bool) {\n }\n \n fn scan_float_exponent(ptr: &mut Ptr) {\n-    if ptr.next_is('e') || ptr.next_is('E') {\n+    if ptr.at('e') || ptr.at('E') {\n         ptr.bump();\n-        if ptr.next_is('-') || ptr.next_is('+') {\n+        if ptr.at('-') || ptr.at('+') {\n             ptr.bump();\n         }\n         scan_digits(ptr, false);"}, {"sha": "aa59e33cceeef0fb462d58491e5a92ac4fd7c25d", "filename": "crates/libsyntax2/src/lexer/ptr.rs", "status": "modified", "additions": 28, "deletions": 14, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/af0ae9ee0409ce2296dafebf977e353a5b871d80/crates%2Flibsyntax2%2Fsrc%2Flexer%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af0ae9ee0409ce2296dafebf977e353a5b871d80/crates%2Flibsyntax2%2Fsrc%2Flexer%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibsyntax2%2Fsrc%2Flexer%2Fptr.rs?ref=af0ae9ee0409ce2296dafebf977e353a5b871d80", "patch": "@@ -2,58 +2,70 @@ use TextUnit;\n \n use std::str::Chars;\n \n+/// A simple view into the characters of a string.\n pub(crate) struct Ptr<'s> {\n     text: &'s str,\n     len: TextUnit,\n }\n \n impl<'s> Ptr<'s> {\n+    /// Creates a new `Ptr` from a string.\n     pub fn new(text: &'s str) -> Ptr<'s> {\n         Ptr {\n             text,\n             len: 0.into(),\n         }\n     }\n \n+    /// Gets the length of the remaining string.\n     pub fn into_len(self) -> TextUnit {\n         self.len\n     }\n \n-    pub fn next(&self) -> Option<char> {\n+    /// Gets the current character, if one exists.\n+    pub fn current(&self) -> Option<char> {\n         self.chars().next()\n     }\n \n-    pub fn nnext(&self) -> Option<char> {\n-        let mut chars = self.chars();\n-        chars.next()?;\n-        chars.next()\n+    /// Gets the nth character from the current.\n+    /// For example, 0 will return the current token, 1 will return the next, etc.\n+    pub fn nth(&self, n: u32) -> Option<char> {\n+        let mut chars = self.chars().peekable();\n+        chars.by_ref().skip(n as usize).next()\n     }\n \n-    pub fn next_is(&self, c: char) -> bool {\n-        self.next() == Some(c)\n+    /// Checks whether the current character is `c`.\n+    pub fn at(&self, c: char) -> bool {\n+        self.current() == Some(c)\n     }\n \n-    pub fn nnext_is(&self, c: char) -> bool {\n-        self.nnext() == Some(c)\n+    /// Checks whether the next characters match `s`.\n+    pub fn at_str(&self, s: &str) -> bool {\n+        let chars = self.chars();\n+        chars.as_str().starts_with(s)\n     }\n \n-    pub fn next_is_p<P: Fn(char) -> bool>(&self, p: P) -> bool {\n-        self.next().map(p) == Some(true)\n+    /// Checks whether the current character satisfies the predicate `p`.\n+    pub fn at_p<P: Fn(char) -> bool>(&self, p: P) -> bool {\n+        self.current().map(p) == Some(true)\n     }\n \n-    pub fn nnext_is_p<P: Fn(char) -> bool>(&self, p: P) -> bool {\n-        self.nnext().map(p) == Some(true)\n+    /// Checks whether the nth character satisfies the predicate `p`.\n+    pub fn nth_is_p<P: Fn(char) -> bool>(&self, n: u32, p: P) -> bool {\n+        self.nth(n).map(p) == Some(true)\n     }\n \n+    /// Moves to the next character.\n     pub fn bump(&mut self) -> Option<char> {\n         let ch = self.chars().next()?;\n         self.len += TextUnit::of_char(ch);\n         Some(ch)\n     }\n \n+    /// Moves to the next character as long as `pred` is satisfied.\n     pub fn bump_while<F: Fn(char) -> bool>(&mut self, pred: F) {\n         loop {\n-            match self.next() {\n+            match self.current() {\n                 Some(c) if pred(c) => {\n                     self.bump();\n                 }\n@@ -62,11 +74,13 @@ impl<'s> Ptr<'s> {\n         }\n     }\n \n+    /// Returns the text up to the current point.\n     pub fn current_token_text(&self) -> &str {\n         let len: u32 = self.len.into();\n         &self.text[..len as usize]\n     }\n \n+    /// Returns an iterator over the remaining characters.\n     fn chars(&self) -> Chars {\n         let len: u32 = self.len.into();\n         self.text[len as usize..].chars()"}, {"sha": "5ff483d14c5ef6d0a018c2debb680226f92bce05", "filename": "crates/libsyntax2/src/lexer/strings.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/af0ae9ee0409ce2296dafebf977e353a5b871d80/crates%2Flibsyntax2%2Fsrc%2Flexer%2Fstrings.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af0ae9ee0409ce2296dafebf977e353a5b871d80/crates%2Flibsyntax2%2Fsrc%2Flexer%2Fstrings.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Flibsyntax2%2Fsrc%2Flexer%2Fstrings.rs?ref=af0ae9ee0409ce2296dafebf977e353a5b871d80", "patch": "@@ -15,11 +15,11 @@ pub(crate) fn is_string_literal_start(c: char, c1: Option<char>, c2: Option<char\n }\n \n pub(crate) fn scan_char(ptr: &mut Ptr) {\n-    while let Some(c) = ptr.next() {\n+    while let Some(c) = ptr.current() {\n         match c {\n             '\\\\' => {\n                 ptr.bump();\n-                if ptr.next_is('\\\\') || ptr.next_is('\\'') {\n+                if ptr.at('\\\\') || ptr.at('\\'') {\n                     ptr.bump();\n                 }\n             }\n@@ -57,11 +57,11 @@ pub(crate) fn scan_byte_char_or_string(ptr: &mut Ptr) -> SyntaxKind {\n }\n \n pub(crate) fn scan_string(ptr: &mut Ptr) {\n-    while let Some(c) = ptr.next() {\n+    while let Some(c) = ptr.current() {\n         match c {\n             '\\\\' => {\n                 ptr.bump();\n-                if ptr.next_is('\\\\') || ptr.next_is('\"') {\n+                if ptr.at('\\\\') || ptr.at('\"') {\n                     ptr.bump();\n                 }\n             }\n@@ -78,19 +78,19 @@ pub(crate) fn scan_string(ptr: &mut Ptr) {\n \n pub(crate) fn scan_raw_string(ptr: &mut Ptr) {\n     let mut hashes = 0;\n-    while ptr.next_is('#') {\n+    while ptr.at('#') {\n         hashes += 1;\n         ptr.bump();\n     }\n-    if !ptr.next_is('\"') {\n+    if !ptr.at('\"') {\n         return;\n     }\n     ptr.bump();\n \n     while let Some(c) = ptr.bump() {\n         if c == '\"' {\n             let mut hashes_left = hashes;\n-            while ptr.next_is('#') && hashes_left > 0{\n+            while ptr.at('#') && hashes_left > 0{\n                 hashes_left -= 1;\n                 ptr.bump();\n             }\n@@ -110,7 +110,7 @@ fn scan_byte_string(ptr: &mut Ptr) {\n }\n \n fn scan_raw_byte_string(ptr: &mut Ptr) {\n-    if !ptr.next_is('\"') {\n+    if !ptr.at('\"') {\n         return;\n     }\n     ptr.bump();"}]}