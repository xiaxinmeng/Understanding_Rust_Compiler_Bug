{"sha": "fb3a01354ffecc41d7a189e4dd225d706387a522", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiM2EwMTM1NGZmZWNjNDFkN2ExODllNGRkMjI1ZDcwNjM4N2E1MjI=", "commit": {"author": {"name": "Sayan Nandan", "email": "17377258+sntdevco@users.noreply.github.com", "date": "2019-08-09T07:31:05Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-08-09T07:31:05Z"}, "message": "Merge pull request #1 from rust-lang/master\n\nMerge recent changes into master", "tree": {"sha": "41492dfe93f1dccba847dadb56ac6aa079edaaa9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/41492dfe93f1dccba847dadb56ac6aa079edaaa9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fb3a01354ffecc41d7a189e4dd225d706387a522", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdTSE5CRBK7hj4Ov3rIwAAdHIIAJt2GxskZvPUGtPcGGVX0qOt\n+Xt5511qIrYsowGfXiAFOtOlRjJWi4kRnTdoRN56uJ7fpKWuum4Qa9yC7v8XKvRH\n/LTOxlW7o8LrNJpqEP762ViyftlGIpZBFGWHPsb7NkJsdcR0qAsgJvCuToF2DGrd\nkHSjA8L19TH+vHskMuUpi2Hv6WDHc3tLA0i4MczRmlMVzt0+q9ZrWMdRQcc5YkA9\nzCu0/qM1POJceJrWYPL9CFodjCkgx9MD6LP/eOMWibJPRhPk7IC2f+gMdPQqknOR\nmkD46RFa23WLyPV9B4KHYV3vni8NCeN7o92e27c6Yrszxb10n4IwcfHEpzD8sLQ=\n=D4qk\n-----END PGP SIGNATURE-----\n", "payload": "tree 41492dfe93f1dccba847dadb56ac6aa079edaaa9\nparent 33445aea509cadcd715009c79795d289268daa7c\nparent 5aa3d9a7b5d3a46a7f158e8881146331a6bc9243\nauthor Sayan Nandan <17377258+sntdevco@users.noreply.github.com> 1565335865 +0530\ncommitter GitHub <noreply@github.com> 1565335865 +0530\n\nMerge pull request #1 from rust-lang/master\n\nMerge recent changes into master"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fb3a01354ffecc41d7a189e4dd225d706387a522", "html_url": "https://github.com/rust-lang/rust/commit/fb3a01354ffecc41d7a189e4dd225d706387a522", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fb3a01354ffecc41d7a189e4dd225d706387a522/comments", "author": {"login": "ohsayan", "id": 17377258, "node_id": "MDQ6VXNlcjE3Mzc3MjU4", "avatar_url": "https://avatars.githubusercontent.com/u/17377258?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ohsayan", "html_url": "https://github.com/ohsayan", "followers_url": "https://api.github.com/users/ohsayan/followers", "following_url": "https://api.github.com/users/ohsayan/following{/other_user}", "gists_url": "https://api.github.com/users/ohsayan/gists{/gist_id}", "starred_url": "https://api.github.com/users/ohsayan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ohsayan/subscriptions", "organizations_url": "https://api.github.com/users/ohsayan/orgs", "repos_url": "https://api.github.com/users/ohsayan/repos", "events_url": "https://api.github.com/users/ohsayan/events{/privacy}", "received_events_url": "https://api.github.com/users/ohsayan/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "33445aea509cadcd715009c79795d289268daa7c", "url": "https://api.github.com/repos/rust-lang/rust/commits/33445aea509cadcd715009c79795d289268daa7c", "html_url": "https://github.com/rust-lang/rust/commit/33445aea509cadcd715009c79795d289268daa7c"}, {"sha": "5aa3d9a7b5d3a46a7f158e8881146331a6bc9243", "url": "https://api.github.com/repos/rust-lang/rust/commits/5aa3d9a7b5d3a46a7f158e8881146331a6bc9243", "html_url": "https://github.com/rust-lang/rust/commit/5aa3d9a7b5d3a46a7f158e8881146331a6bc9243"}], "stats": {"total": 418714, "additions": 237585, "deletions": 181129}, "files": [{"sha": "a0b491f42789a827f7f0e629eeaa0c3ae4a73a92", "filename": ".gitignore", "status": "modified", "additions": 9, "deletions": 24, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitignore?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -1,3 +1,7 @@\n+# This file should only ignore things that are generated during a build,\n+# generated by common IDEs, and optional files controlled by the user\n+# that affect the build (such as config.toml).\n+# FIXME: This needs cleanup.\n *~\n .#*\n .DS_Store\n@@ -12,22 +16,18 @@ __pycache__/\n .project\n .settings/\n .valgrindrc\n-.vscode/\n+.vscode\n .favorites.json\n-/*-*-*-*/\n-/*-*-*/\n /Makefile\n-/build\n+/build/\n /config.toml\n /dist/\n /dl/\n-/doc\n+/doc/\n /inst/\n /llvm/\n /mingw-build/\n-/nd/\n /obj/\n-/rt/\n /rustllvm/\n /src/libcore/unicode/DerivedCoreProperties.txt\n /src/libcore/unicode/DerivedNormalizationProps.txt\n@@ -36,11 +36,8 @@ __pycache__/\n /src/libcore/unicode/Scripts.txt\n /src/libcore/unicode/SpecialCasing.txt\n /src/libcore/unicode/UnicodeData.txt\n-/stage[0-9]+/\n-/target\n-target/\n-/test/\n-/tmp/\n+/src/libcore/unicode/downloaded\n+/target/\n tags\n tags.*\n TAGS\n@@ -49,18 +46,6 @@ TAGS.*\n \\#*\\#\n config.mk\n config.stamp\n-keywords.md\n-lexer.ml\n-mir_dump\n Session.vim\n-src/etc/dl\n-tmp.*.rs\n-version.md\n-version.ml\n-version.texi\n .cargo\n-!src/vendor/**\n-/src/target/\n-\n no_llvm_build\n-"}, {"sha": "f64e21c5af0e4dec0382ff2261b8354f9a27b246", "filename": ".gitmodules", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/.gitmodules", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/.gitmodules", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.gitmodules?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -31,9 +31,9 @@\n [submodule \"src/llvm-emscripten\"]\n \tpath = src/llvm-emscripten\n \turl = https://github.com/rust-lang/llvm.git\n-[submodule \"src/stdsimd\"]\n-\tpath = src/stdsimd\n-\turl = https://github.com/rust-lang-nursery/stdsimd.git\n+[submodule \"src/stdarch\"]\n+\tpath = src/stdarch\n+\turl = https://github.com/rust-lang/stdarch.git\n [submodule \"src/doc/rustc-guide\"]\n \tpath = src/doc/rustc-guide\n \turl = https://github.com/rust-lang/rustc-guide.git\n@@ -43,7 +43,7 @@\n [submodule \"src/llvm-project\"]\n \tpath = src/llvm-project\n \turl = https://github.com/rust-lang/llvm-project.git\n-\tbranch = rustc/8.0-2019-01-16\n+\tbranch = rustc/9.0-2019-07-12\n [submodule \"src/doc/embedded-book\"]\n \tpath = src/doc/embedded-book\n \turl = https://github.com/rust-embedded/book.git"}, {"sha": "c5ecfb54fca52df808b9a523857b47fb93bb2f64", "filename": ".mailmap", "status": "modified", "additions": 26, "deletions": 13, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/.mailmap", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/.mailmap", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.mailmap?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -5,8 +5,8 @@\n # email addresses.\n #\n \n+Aaron Power <theaaronepower@gmail.com> Erin Power <xampprocky@gmail.com>\n Aaron Todd <github@opprobrio.us>\n-Aaron Power <theaaronepower@gmail.com>\n Abhishek Chanda <abhishek.becs@gmail.com> Abhishek Chanda <abhishek@cloudscaling.com>\n Adolfo Ochagav\u00eda <aochagavia92@gmail.com>\n Adrien T\u00e9tar <adri-from-59@hotmail.fr>\n@@ -30,6 +30,7 @@ Ariel Ben-Yehuda <arielb1@mail.tau.ac.il> arielb1 <arielb1@mail.tau.ac.il>\n Austin Seipp <mad.one@gmail.com> <as@hacks.yi.org>\n Aydin Kim <ladinjin@hanmail.net> aydin.kim <aydin.kim@samsung.com>\n Barosl Lee <vcs@barosl.com> Barosl LEE <github@barosl.com>\n+Bastian Kauschke <bastian_kauschke@hotmail.de>\n Ben Alpert <ben@benalpert.com> <spicyjalapeno@gmail.com>\n Ben Sago <ogham@users.noreply.github.com> Ben S <ogham@bsago.me>\n Ben Sago <ogham@users.noreply.github.com> Ben S <ogham@users.noreply.github.com>\n@@ -45,21 +46,24 @@ Brian Anderson <banderson@mozilla.com> <banderson@mozilla.org>\n Brian Dawn <brian.t.dawn@gmail.com>\n Brian Leibig <brian@brianleibig.com> Brian Leibig <brian.leibig@gmail.com>\n Carl-Anton Ingmarsson <mail@carlanton.se> <ca.ingmarsson@gmail.com>\n+Carol (Nichols || Goulding) <carol.nichols@gmail.com> <193874+carols10cents@users.noreply.github.com>\n+Carol (Nichols || Goulding) <carol.nichols@gmail.com> <carol.nichols@gmail.com>\n Carol (Nichols || Goulding) <carol.nichols@gmail.com> <cnichols@thinkthroughmath.com>\n-Carol (Nichols || Goulding) <carol.nichols@gmail.com> Carol Nichols <carol.nichols@gmail.com>\n Carol Willing <carolcode@willingconsulting.com>\n Chris C Cerami <chrisccerami@users.noreply.github.com> Chris C Cerami <chrisccerami@gmail.com>\n Chris Pressey <cpressey@gmail.com>\n Chris Thorn <chris@thorn.co> Chris Thorn <thorn@thoughtbot.com>\n Chris Vittal <christopher.vittal@gmail.com> Christopher Vittal <christopher.vittal@gmail.com>\n-Christian Poveda <christianpoveda@protonmail.com> <z1mvader@protonmail.com> <cn.poveda.ruiz@gmail.com>\n+Christian Poveda <christianpoveda@protonmail.com> <cn.poveda.ruiz@gmail.com>\n+Christian Poveda <christianpoveda@protonmail.com> <z1mvader@protonmail.com>\n+Christian Poveda <christianpoveda@protonmail.com> <cpovedar@fnal.gov>\n Clark Gaebel <cg.wowus.cg@gmail.com> <cgaebel@mozilla.com>\n Clinton Ryan <clint.ryan3@gmail.com>\n Corey Richardson <corey@octayn.net> Elaine \"See More\" Nemo <corey@octayn.net>\n Cyryl P\u0142otnicki <cyplo@cyplo.net>\n Damien Schoof <damien.schoof@gmail.com>\n-Daniel Ramos <dan@daramos.com>\n Daniel J Rollins <drollins@financialforce.com>\n+Daniel Ramos <dan@daramos.com>\n David Klein <david.klein@baesystemsdetica.com>\n David Manescu <david.manescu@gmail.com> <dman2626@uni.sydney.edu.au>\n David Ross <daboross@daboross.net>\n@@ -68,17 +72,19 @@ Diggory Hardy <diggory.hardy@gmail.com> Diggory Hardy <github@dhardy.name>\n Dylan Braithwaite <dylanbraithwaite1@gmail.com> <mail@dylanb.me>\n Dzmitry Malyshau <kvarkus@gmail.com>\n E. Dunham <edunham@mozilla.com> edunham <edunham@mozilla.com>\n+Eduard-Mihai Burtescu <edy.burt@gmail.com>\n Eduardo Bautista <me@eduardobautista.com> <=>\n Eduardo Bautista <me@eduardobautista.com> <mail@eduardobautista.com>\n-Eduard-Mihai Burtescu <edy.burt@gmail.com>\n Elliott Slaughter <elliottslaughter@gmail.com> <eslaughter@mozilla.com>\n Elly Fong-Jones <elly@leptoquark.net>\n Eric Holk <eric.holk@gmail.com> <eholk@cs.indiana.edu>\n Eric Holk <eric.holk@gmail.com> <eholk@mozilla.com>\n Eric Holmes <eric@ejholmes.net>\n Eric Reed <ecreed@cs.washington.edu> <ereed@mozilla.com>\n Erick Tryzelaar <erick.tryzelaar@gmail.com> <etryzelaar@iqt.org>\n-Esteban K\u00fcber <esteban@kuber.com.ar> <estebank@users.noreply.github.com> <esteban@commure.com> <github@kuber.com.ar>\n+Esteban K\u00fcber <esteban@kuber.com.ar> <esteban@commure.com>\n+Esteban K\u00fcber <esteban@kuber.com.ar> <estebank@users.noreply.github.com>\n+Esteban K\u00fcber <esteban@kuber.com.ar> <github@kuber.com.ar>\n Evgeny Sologubov\n Falco Hirschenberger <falco.hirschenberger@gmail.com> <hirschen@itwm.fhg.de>\n Felix S. Klock II <pnkfelix@pnkfx.org> Felix S Klock II <pnkfelix@pnkfx.org>\n@@ -98,9 +104,9 @@ Herman J. Radtke III <herman@hermanradtke.com> Herman J. Radtke III <hermanradtk\n Ilyong Cho <ilyoan@gmail.com>\n Ivan Ivaschenko <defuz.net@gmail.com>\n J. J. Weber <jjweber@gmail.com>\n+Jakub Adam Wieczorek <jakub.adam.wieczorek@gmail.com> <jakub.bukaj@yahoo.com>\n Jakub Adam Wieczorek <jakub.adam.wieczorek@gmail.com> <jakub@jakub.cc>\n Jakub Adam Wieczorek <jakub.adam.wieczorek@gmail.com> <jakubw@jakubw.net>\n-Jakub Adam Wieczorek <jakub.adam.wieczorek@gmail.com> <jakub.bukaj@yahoo.com>\n James Deng <cnjamesdeng@gmail.com> <cnJamesDeng@gmail.com>\n James Miller <bladeon@gmail.com> <james@aatch.net>\n James Perry <james.austin.perry@gmail.com>\n@@ -115,6 +121,7 @@ Jethro Beekman <github@jbeekman.nl>\n Jihyun Yu <j.yu@navercorp.com> <yjh0502@gmail.com>\n Jihyun Yu <j.yu@navercorp.com> jihyun <jihyun@nablecomm.com>\n Jihyun Yu <j.yu@navercorp.com> Jihyun Yu <jihyun@nclab.kaist.ac.kr>\n+Jo\u00e3o Oliveira <hello@jxs.pt> joaoxsouls <joaoxsouls@gmail.com>\n Johann Hofmann <git@johann-hofmann.com> Johann <git@johann-hofmann.com>\n John Clements <clements@racket-lang.org> <clements@brinckerhoff.org>\n John Hodge <acessdev@gmail.com> John Hodge <tpg@mutabah.net>\n@@ -125,13 +132,15 @@ Jonathan S <gereeter@gmail.com> Jonathan S <gereeter+code@gmail.com>\n Jonathan Turner <probata@hotmail.com>\n Jorge Aparicio <japaric@linux.com> <japaricious@gmail.com>\n Joseph Martin <pythoner6@gmail.com>\n-Jo\u00e3o Oliveira <hello@jxs.pt> joaoxsouls <joaoxsouls@gmail.com>\n+Joseph T. Lyons <JosephTLyons@gmail.com> <josephtlyons@gmail.com>\n+Joseph T. Lyons <JosephTLyons@gmail.com> <JosephTLyons@users.noreply.github.com>\n Junyoung Cho <june0.cho@samsung.com>\n Jyun-Yan You <jyyou.tw@gmail.com> <jyyou@cs.nctu.edu.tw>\n Kang Seonghoon <kang.seonghoon@mearie.org> <public+git@mearie.org>\n Keegan McAllister <mcallister.keegan@gmail.com> <kmcallister@mozilla.com>\n Kevin Butler <haqkrs@gmail.com>\n Kyeongwoon Lee <kyeongwoon.lee@samsung.com>\n+Lauren\u021biu Nicola <lnicola@dend.ro>\n Lee Jeffery <leejeffery@gmail.com> Lee Jeffery <lee@leejeffery.co.uk>\n Lee Wondong <wdlee91@gmail.com>\n Lennart Kudling <github@kudling.de>\n@@ -141,32 +150,36 @@ Lindsey Kuper <lindsey@composition.al> <lkuper@mozilla.com>\n Luke Metz <luke.metz@students.olin.edu>\n Luqman Aden <me@luqman.ca> <laden@csclub.uwaterloo.ca>\n Luqman Aden <me@luqman.ca> <laden@mozilla.com>\n-NAKASHIMA, Makoto <makoto.nksm+github@gmail.com> <makoto.nksm@gmail.com>\n-NAKASHIMA, Makoto <makoto.nksm+github@gmail.com> <makoto.nksm+github@gmail.com>\n Marcell Pardavi <marcell.pardavi@gmail.com>\n Margaret Meyerhofer <mmeyerho@andrew.cmu.edu> <mmeyerho@andrew>\n-Mark Simulacrum <mark.simulacrum@gmail.com>\n+Mark Rousskov <mark.simulacrum@gmail.com>\n Mark Sinclair <mark.edward.x@gmail.com>\n Mark Sinclair <mark.edward.x@gmail.com> =Mark Sinclair <=125axel125@gmail.com>\n Markus Westerlind <marwes91@gmail.com> Markus <marwes91@gmail.com>\n Martin Hafskjold Thoresen <martinhath@gmail.com>\n Matej Lach <matej.lach@gmail.com> Matej \u013dach <matej.lach@gmail.com>\n+Mateusz Miku\u0142a <matti@marinelayer.io> <mati865@gmail.com>\n+Mateusz Miku\u0142a <matti@marinelayer.io> <mati865@users.noreply.github.com>\n Matt Brubeck <mbrubeck@limpet.net> <mbrubeck@cs.hmc.edu>\n Matthew Auld <matthew.auld@intel.com>\n Matthew McPherrin <matthew@mcpherrin.ca> <matt@mcpherrin.ca>\n Matthijs Hofstra <thiezz@gmail.com>\n Melody Horn <melody@boringcactus.com> <mathphreak@gmail.com>\n Michael Williams <m.t.williams@live.com>\n Michael Woerister <michaelwoerister@posteo> <michaelwoerister@gmail>\n+Michael Woerister <michaelwoerister@posteo> <michaelwoerister@users.noreply.github.com>\n+Michael Woerister <michaelwoerister@posteo> <michaelwoerister@posteo.net>\n Micka\u00ebl Raybaud-Roig <raybaudroigm@gmail.com> m-r-r <raybaudroigm@gmail.com>\n Ms2ger <ms2ger@gmail.com> <Ms2ger@gmail.com>\n Mukilan Thiagarajan <mukilanthiagarajan@gmail.com>\n+NAKASHIMA, Makoto <makoto.nksm+github@gmail.com> <makoto.nksm@gmail.com>\n+NAKASHIMA, Makoto <makoto.nksm+github@gmail.com> <makoto.nksm+github@gmail.com>\n Nathan West <Lucretiel@gmail.com> <lucretiel@gmail.com>\n Nathan Wilson <wilnathan@gmail.com>\n Nathaniel Herman <nherman@post.harvard.edu> Nathaniel Herman <nherman@college.harvard.edu>\n Neil Pankey <npankey@gmail.com> <neil@wire.im>\n-Nicole Mazzuca <npmazzuca@gmail.com>\n Nick Platt <platt.nicholas@gmail.com>\n+Nicole Mazzuca <npmazzuca@gmail.com>\n Nif Ward <nif.ward@gmail.com>\n Oliver Schneider <oliver.schneider@kit.edu> oli-obk <github6541940@oli-obk.de>\n Oliver Schneider <oliver.schneider@kit.edu> Oliver 'ker' Schneider <rust19446194516@oli-obk.de>\n@@ -224,8 +237,8 @@ Tim JIANG <p90eri@gmail.com>\n Tim Joseph Dumol <tim@timdumol.com>\n Torsten Weber <TorstenWeber12@gmail.com> <torstenweber12@gmail.com>\n Ty Overby <ty@pre-alpha.com>\n+Ulrik Sverdrup <bluss@users.noreply.github.com> bluss <bluss@users.noreply.github.com>\n Ulrik Sverdrup <bluss@users.noreply.github.com> bluss <bluss>\n-Ulrik Sverdrup <bluss@users.noreply.github.com> bluss <bluss@users.noreply.github.com> bluss <bluss>\n Ulrik Sverdrup <bluss@users.noreply.github.com> Ulrik Sverdrup <root@localhost>\n Vadim Petrochenkov <vadim.petrochenkov@gmail.com>\n Vadim Petrochenkov <vadim.petrochenkov@gmail.com> petrochenkov <vadim.petrochenkov@gmail.com>"}, {"sha": "7985b6c0e191f770815fc37d4ee7a7f4ce154020", "filename": ".travis.yml", "status": "removed", "additions": 0, "deletions": 337, "changes": 337, "blob_url": "https://github.com/rust-lang/rust/blob/33445aea509cadcd715009c79795d289268daa7c/.travis.yml", "raw_url": "https://github.com/rust-lang/rust/raw/33445aea509cadcd715009c79795d289268daa7c/.travis.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/.travis.yml?ref=33445aea509cadcd715009c79795d289268daa7c", "patch": "@@ -1,337 +0,0 @@\n-language: shell\n-sudo: required\n-dist: xenial\n-services:\n-  - docker\n-addons:\n-  apt:\n-    packages:\n-      - gdb\n-\n-git:\n-  depth: 2\n-  submodules: false\n-\n-matrix:\n-  fast_finish: true\n-  include:\n-    # Images used in testing PR and try-build should be run first.\n-    - env: IMAGE=x86_64-gnu-llvm-6.0 RUST_BACKTRACE=1\n-      if: type = pull_request OR branch = auto\n-\n-    - env: IMAGE=dist-x86_64-linux DEPLOY=1\n-      if: branch = try OR branch = auto\n-\n-    # \"alternate\" deployments, these are \"nightlies\" but have LLVM assertions\n-    # turned on, they're deployed to a different location primarily for\n-    # additional testing.\n-    - env: IMAGE=dist-x86_64-linux DEPLOY_ALT=1 CI_JOB_NAME=dist-x86_64-linux-alt\n-      if: branch = try OR branch = auto\n-\n-    - env: >\n-        RUST_CHECK_TARGET=dist\n-        RUST_CONFIGURE_ARGS=\"--enable-extended --enable-profiler --enable-lldb --set rust.jemalloc\"\n-        SRC=.\n-        DEPLOY_ALT=1\n-        RUSTC_RETRY_LINKER_ON_SEGFAULT=1\n-        MACOSX_DEPLOYMENT_TARGET=10.7\n-        NO_LLVM_ASSERTIONS=1\n-        NO_DEBUG_ASSERTIONS=1\n-        CI_JOB_NAME=dist-x86_64-apple-alt\n-      os: osx\n-      osx_image: xcode9.3-moar\n-      if: branch = auto\n-\n-    # macOS builders. These are placed near the beginning because they are very\n-    # slow to run.\n-\n-    # OSX builders running tests, these run the full test suite.\n-    # NO_DEBUG_ASSERTIONS=1 to make them go faster, but also do have some\n-    # runners that run `//ignore-debug` tests.\n-    #\n-    # Note that the compiler is compiled to target 10.8 here because the Xcode\n-    # version that we're using, 8.2, cannot compile LLVM for OSX 10.7.\n-    - env: >\n-        RUST_CHECK_TARGET=check\n-        RUST_CONFIGURE_ARGS=\"--build=x86_64-apple-darwin --enable-sanitizers --enable-profiler --set rust.jemalloc\"\n-        SRC=.\n-        RUSTC_RETRY_LINKER_ON_SEGFAULT=1\n-        MACOSX_DEPLOYMENT_TARGET=10.8\n-        MACOSX_STD_DEPLOYMENT_TARGET=10.7\n-        NO_LLVM_ASSERTIONS=1\n-        NO_DEBUG_ASSERTIONS=1\n-        CI_JOB_NAME=x86_64-apple\n-      os: osx\n-      osx_image: xcode9.3-moar\n-      if: branch = auto\n-\n-    - env: >\n-        RUST_CHECK_TARGET=check\n-        RUST_CONFIGURE_ARGS=\"--build=i686-apple-darwin --set rust.jemalloc\"\n-        SRC=.\n-        RUSTC_RETRY_LINKER_ON_SEGFAULT=1\n-        MACOSX_DEPLOYMENT_TARGET=10.8\n-        MACOSX_STD_DEPLOYMENT_TARGET=10.7\n-        NO_LLVM_ASSERTIONS=1\n-        NO_DEBUG_ASSERTIONS=1\n-        CI_JOB_NAME=i686-apple\n-      os: osx\n-      osx_image: xcode9.3-moar\n-      if: branch = auto\n-\n-    # OSX builders producing releases. These do not run the full test suite and\n-    # just produce a bunch of artifacts.\n-    #\n-    # Note that these are running in the `xcode7` image instead of the\n-    # `xcode8.2` image as above. That's because we want to build releases for\n-    # OSX 10.7 and `xcode7` is the latest Xcode able to compile LLVM for 10.7.\n-    - env: >\n-        RUST_CHECK_TARGET=dist\n-        RUST_CONFIGURE_ARGS=\"--build=i686-apple-darwin --enable-full-tools --enable-profiler --enable-lldb --set rust.jemalloc\"\n-        SRC=.\n-        DEPLOY=1\n-        RUSTC_RETRY_LINKER_ON_SEGFAULT=1\n-        MACOSX_DEPLOYMENT_TARGET=10.7\n-        NO_LLVM_ASSERTIONS=1\n-        NO_DEBUG_ASSERTIONS=1\n-        DIST_REQUIRE_ALL_TOOLS=1\n-        CI_JOB_NAME=dist-i686-apple\n-      os: osx\n-      osx_image: xcode9.3-moar\n-      if: branch = auto\n-\n-    - env: >\n-        RUST_CHECK_TARGET=dist\n-        RUST_CONFIGURE_ARGS=\"--target=aarch64-apple-ios,armv7-apple-ios,armv7s-apple-ios,i386-apple-ios,x86_64-apple-ios --enable-full-tools --enable-sanitizers --enable-profiler --enable-lldb --set rust.jemalloc\"\n-        SRC=.\n-        DEPLOY=1\n-        RUSTC_RETRY_LINKER_ON_SEGFAULT=1\n-        MACOSX_DEPLOYMENT_TARGET=10.7\n-        NO_LLVM_ASSERTIONS=1\n-        NO_DEBUG_ASSERTIONS=1\n-        DIST_REQUIRE_ALL_TOOLS=1\n-        CI_JOB_NAME=dist-x86_64-apple\n-      os: osx\n-      osx_image: xcode9.3-moar\n-      if: branch = auto\n-\n-    # Linux builders, remaining docker images\n-    - env: IMAGE=arm-android\n-      if: branch = auto\n-    - env: IMAGE=armhf-gnu\n-      if: branch = auto\n-    - env: IMAGE=dist-various-1 DEPLOY=1\n-      if: branch = auto\n-    - env: IMAGE=dist-various-2 DEPLOY=1\n-      if: branch = auto\n-    - env: IMAGE=dist-aarch64-linux DEPLOY=1\n-      if: branch = auto\n-    - env: IMAGE=dist-android DEPLOY=1\n-      if: branch = auto\n-    - env: IMAGE=dist-arm-linux DEPLOY=1\n-      if: branch = auto\n-    - env: IMAGE=dist-armhf-linux DEPLOY=1\n-      if: branch = auto\n-    - env: IMAGE=dist-armv7-linux DEPLOY=1\n-      if: branch = auto\n-    - env: IMAGE=dist-i586-gnu-i586-i686-musl DEPLOY=1\n-      if: branch = auto\n-    - env: IMAGE=dist-i686-freebsd DEPLOY=1\n-      if: branch = auto\n-    - env: IMAGE=dist-i686-linux DEPLOY=1\n-      if: branch = auto\n-    - env: IMAGE=dist-mips-linux DEPLOY=1\n-      if: branch = auto\n-    - env: IMAGE=dist-mips64-linux DEPLOY=1\n-      if: branch = auto\n-    - env: IMAGE=dist-mips64el-linux DEPLOY=1\n-      if: branch = auto\n-    - env: IMAGE=dist-mipsel-linux DEPLOY=1\n-      if: branch = auto\n-    - env: IMAGE=dist-powerpc-linux DEPLOY=1\n-      if: branch = auto\n-    - env: IMAGE=dist-powerpc64-linux DEPLOY=1\n-      if: branch = auto\n-    - env: IMAGE=dist-powerpc64le-linux DEPLOY=1\n-      if: branch = auto\n-    - env: IMAGE=dist-s390x-linux DEPLOY=1\n-      if: branch = auto\n-    - env: IMAGE=dist-x86_64-freebsd DEPLOY=1\n-      if: branch = auto\n-    - env: IMAGE=dist-x86_64-musl DEPLOY=1\n-      if: branch = auto\n-    - env: IMAGE=dist-x86_64-netbsd DEPLOY=1\n-      if: branch = auto\n-    - env: IMAGE=asmjs\n-      if: branch = auto\n-    - env: IMAGE=i686-gnu\n-      if: branch = auto\n-    - env: IMAGE=i686-gnu-nopt\n-      if: branch = auto\n-    - env: IMAGE=test-various\n-      if: branch = auto\n-    - env: IMAGE=x86_64-gnu\n-      if: branch = auto\n-    - env: IMAGE=x86_64-gnu-full-bootstrap\n-      if: branch = auto\n-    - env: IMAGE=x86_64-gnu-aux\n-      if: branch = auto\n-    - env: IMAGE=x86_64-gnu-tools\n-      if: branch = auto OR (type = pull_request AND commit_message =~ /(?i:^update.*\\b(rls|rustfmt|clippy|miri|cargo)\\b)/)\n-    - env: IMAGE=x86_64-gnu-debug\n-      if: branch = auto\n-    - env: IMAGE=x86_64-gnu-nopt\n-      if: branch = auto\n-    - env: IMAGE=x86_64-gnu-distcheck\n-      if: branch = auto\n-    - env: IMAGE=mingw-check\n-      if: type = pull_request OR branch = auto\n-\n-    - stage: publish toolstate\n-      if: branch = master AND type = push\n-      before_install: []\n-      install: []\n-      sudo: false\n-      script:\n-        MESSAGE_FILE=$(mktemp -t msg.XXXXXX);\n-        . src/ci/docker/x86_64-gnu-tools/repo.sh;\n-        commit_toolstate_change \"$MESSAGE_FILE\" \"$TRAVIS_BUILD_DIR/src/tools/publish_toolstate.py\" \"$(git rev-parse HEAD)\" \"$(git log --format=%s -n1 HEAD)\" \"$MESSAGE_FILE\" \"$TOOLSTATE_REPO_ACCESS_TOKEN\";\n-\n-before_install:\n-  # We'll use the AWS cli to download/upload cached docker layers as well as\n-  # push our deployments, so download that here.\n-  - pip install --user awscli; export PATH=$PATH:$HOME/.local/bin:$HOME/Library/Python/2.7/bin/\n-  - mkdir -p $HOME/rustsrc\n-  # FIXME(#46924): these two commands are required to enable IPv6,\n-  # they shouldn't exist, please revert once more official solutions appeared.\n-  # see https://github.com/travis-ci/travis-ci/issues/8891#issuecomment-353403729\n-  - if [ \"$TRAVIS_OS_NAME\" = linux ]; then\n-      echo '{\"ipv6\":true,\"fixed-cidr-v6\":\"fd9a:8454:6789:13f7::/64\"}' | sudo tee /etc/docker/daemon.json;\n-      sudo service docker restart;\n-    fi\n-\n-install:\n-  - case \"$TRAVIS_OS_NAME\" in\n-        linux)\n-          travis_retry curl -fo $HOME/stamp https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror/2017-03-17-stamp-x86_64-unknown-linux-musl &&\n-            chmod +x $HOME/stamp &&\n-            export PATH=$PATH:$HOME\n-          ;;\n-        osx)\n-          if [[ \"$RUST_CHECK_TARGET\" == dist ]]; then\n-            travis_retry brew update &&\n-            travis_retry brew install xz &&\n-            travis_retry brew install swig;\n-          fi &&\n-          travis_retry curl -fo /usr/local/bin/sccache https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror/2018-04-02-sccache-x86_64-apple-darwin &&\n-            chmod +x /usr/local/bin/sccache &&\n-          travis_retry curl -fo /usr/local/bin/stamp https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror/2017-03-17-stamp-x86_64-apple-darwin &&\n-            chmod +x /usr/local/bin/stamp &&\n-          travis_retry curl -f http://releases.llvm.org/7.0.0/clang+llvm-7.0.0-x86_64-apple-darwin.tar.xz | tar xJf - &&\n-            export CC=`pwd`/clang+llvm-7.0.0-x86_64-apple-darwin/bin/clang &&\n-            export CXX=`pwd`/clang+llvm-7.0.0-x86_64-apple-darwin/bin/clang++ &&\n-            export AR=ar\n-          ;;\n-    esac\n-\n-before_script:\n-  - >\n-      echo \"#### Disk usage before running script:\";\n-      df -h;\n-      du . | sort -nr | head -n100\n-  - >\n-      RUN_SCRIPT=\"src/ci/init_repo.sh . $HOME/rustsrc\";\n-      if [ \"$TRAVIS_OS_NAME\" = \"osx\" ]; then\n-          export RUN_SCRIPT=\"$RUN_SCRIPT && src/ci/run.sh\";\n-      else\n-          export RUN_SCRIPT=\"$RUN_SCRIPT && src/ci/docker/run.sh $IMAGE\";\n-          # Enable core dump on Linux.\n-          sudo sh -c 'echo \"/checkout/obj/cores/core.%p.%E\" > /proc/sys/kernel/core_pattern';\n-      fi\n-  - >\n-      if [ \"$IMAGE\" = mingw-check ]; then\n-        # verify the publish_toolstate script works.\n-        git clone --depth=1 https://github.com/rust-lang-nursery/rust-toolstate.git;\n-        cd rust-toolstate;\n-        python2.7 \"$TRAVIS_BUILD_DIR/src/tools/publish_toolstate.py\" \"$(git rev-parse HEAD)\" \"$(git log --format=%s -n1 HEAD)\" \"\" \"\";\n-        cd ..;\n-        rm -rf rust-toolstate;\n-      fi\n-\n-# Log time information from this machine and an external machine for insight into possible\n-# clock drift. Timezones don't matter since relative deltas give all the necessary info.\n-script:\n-  - >\n-      date && (curl -fs --head https://google.com | grep ^Date: | sed 's/Date: //g' || true)\n-  - stamp sh -x -c \"$RUN_SCRIPT\"\n-  - >\n-      date && (curl -fs --head https://google.com | grep ^Date: | sed 's/Date: //g' || true)\n-\n-after_success:\n-  - >\n-      echo \"#### Build successful; Disk usage after running script:\";\n-      df -h;\n-      du . | sort -nr | head -n100\n-  - >\n-      if [ \"$DEPLOY$DEPLOY_ALT\" == \"1\" ]; then\n-        mkdir -p deploy/$TRAVIS_COMMIT;\n-        if [ \"$TRAVIS_OS_NAME\" == \"osx\" ]; then\n-            rm -rf build/dist/doc &&\n-            cp -r build/dist/* deploy/$TRAVIS_COMMIT;\n-        else\n-            rm -rf obj/build/dist/doc &&\n-            cp -r obj/build/dist/* deploy/$TRAVIS_COMMIT;\n-        fi;\n-        ls -la deploy/$TRAVIS_COMMIT;\n-        deploy_dir=rustc-builds;\n-        if [ \"$DEPLOY_ALT\" == \"1\" ]; then\n-            deploy_dir=rustc-builds-alt;\n-        fi;\n-        travis_retry aws s3 cp --no-progress --recursive --acl public-read ./deploy s3://rust-lang-ci2/$deploy_dir\n-      fi\n-\n-after_failure:\n-  - >\n-      echo \"#### Build failed; Disk usage after running script:\";\n-      df -h;\n-      du . | sort -nr | head -n100\n-\n-  # Random attempt at debugging currently. Just poking around in here to see if\n-  # anything shows up.\n-\n-  # Dump backtrace for macOS\n-  - ls -lat $HOME/Library/Logs/DiagnosticReports/\n-  - find $HOME/Library/Logs/DiagnosticReports\n-      -type f\n-      -name '*.crash'\n-      -not -name '*.stage2-*.crash'\n-      -not -name 'com.apple.CoreSimulator.CoreSimulatorService-*.crash'\n-      -exec printf travis_fold\":start:crashlog\\n\\033[31;1m%s\\033[0m\\n\" {} \\;\n-      -exec head -750 {} \\;\n-      -exec echo travis_fold\":\"end:crashlog \\; || true\n-\n-  # Dump backtrace for Linux\n-  - ln -s . checkout &&\n-    for CORE in obj/cores/core.*; do\n-      EXE=$(echo $CORE | sed 's|obj/cores/core\\.[0-9]*\\.!checkout!\\(.*\\)|\\1|;y|!|/|');\n-      if [ -f \"$EXE\" ]; then\n-        printf travis_fold\":start:crashlog\\n\\033[31;1m%s\\033[0m\\n\" \"$CORE\";\n-        gdb --batch -q -c \"$CORE\" \"$EXE\"\n-          -iex 'set auto-load off'\n-          -iex 'dir src/'\n-          -iex 'set sysroot .'\n-          -ex bt\n-          -ex q;\n-        echo travis_fold\":\"end:crashlog;\n-      fi;\n-    done || true\n-\n-  # see #50887\n-  - cat ./obj/build/x86_64-unknown-linux-gnu/native/asan/build/lib/asan/clang_rt.asan-dynamic-i386.vers || true\n-\n-  # attempt to debug anything killed by the oom killer on linux, just to see if\n-  # it happened\n-  - dmesg | grep -i kill\n-\n-notifications:\n-  email: false"}, {"sha": "4daaa986a2dc2fbf31080efade8a989be2de2d69", "filename": "CONTRIBUTING.md", "status": "modified", "additions": 37, "deletions": 31, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/CONTRIBUTING.md", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/CONTRIBUTING.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/CONTRIBUTING.md?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -15,7 +15,7 @@ links to the major sections:\n * [Helpful Links and Information](#helpful-links-and-information)\n \n If you have questions, please make a post on [internals.rust-lang.org][internals] or\n-hop on [#rust-internals][pound-rust-internals].\n+hop on the [Rust Discord server][rust-discord], [Rust Zulip server][rust-zulip] or [#rust-internals][pound-rust-internals].\n \n As a reminder, all contributors are expected to follow our [Code of Conduct][coc].\n \n@@ -27,14 +27,17 @@ can give you a good example of how a typical contribution would go.\n \n [pound-rust-internals]: https://chat.mibbit.com/?server=irc.mozilla.org&channel=%23rust-internals\n [internals]: https://internals.rust-lang.org\n+[rust-discord]: http://discord.gg/rust-lang\n+[rust-zulip]: https://rust-lang.zulipchat.com\n [coc]: https://www.rust-lang.org/conduct.html\n+[rustc-guide]: https://rust-lang.github.io/rustc-guide/\n [walkthrough]: https://rust-lang.github.io/rustc-guide/walkthrough.html\n \n ## Feature Requests\n [feature-requests]: #feature-requests\n \n To request a change to the way the Rust language works, please head over\n-to the [RFCs repository](https://github.com/rust-lang/rfcs) and view the \n+to the [RFCs repository](https://github.com/rust-lang/rfcs) and view the\n [README](https://github.com/rust-lang/rfcs/blob/master/README.md)\n for instructions.\n \n@@ -119,6 +122,13 @@ bring those changes into the source repository.\n \n Please make pull requests against the `master` branch.\n \n+Rust follows a no merge policy, meaning, when you encounter merge\n+conflicts you are expected to always rebase instead of merge.\n+E.g. always use rebase when bringing the latest changes from\n+the master branch to your feature branch.\n+Also, please make sure that fixup commits are squashed into other related\n+commits with meaningful commit messages.\n+\n Please make sure your pull request is in compliance with Rust's style\n guidelines by running\n \n@@ -129,35 +139,46 @@ request); you can add [git hooks](https://git-scm.com/book/en/v2/Customizing-Git\n before every push to make sure you never forget to make this check.\n \n All pull requests are reviewed by another person. We have a bot,\n-@rust-highfive, that will automatically assign a random person to review your\n+[@rust-highfive][rust-highfive], that will automatically assign a random person to review your\n request.\n \n If you want to request that a specific person reviews your pull request,\n-you can add an `r?` to the message. For example, Steve usually reviews\n+you can add an `r?` to the message. For example, [Steve][steveklabnik] usually reviews\n documentation changes. So if you were to make a documentation change, add\n \n     r? @steveklabnik\n \n-to the end of the message, and @rust-highfive will assign @steveklabnik instead\n+to the end of the message, and @rust-highfive will assign [@steveklabnik][steveklabnik] instead\n of a random person. This is entirely optional.\n \n After someone has reviewed your pull request, they will leave an annotation\n on the pull request with an `r+`. It will look something like this:\n \n-    @bors: r+ 38fe8d2\n+    @bors r+\n \n-This tells @bors, our lovable integration bot, that your pull request has\n-been approved. The PR then enters the [merge queue][merge-queue], where @bors\n+This tells [@bors][bors], our lovable integration bot, that your pull request has\n+been approved. The PR then enters the [merge queue][merge-queue], where [@bors][bors]\n will run all the tests on every platform we support. If it all works out,\n-@bors will merge your code into `master` and close the pull request.\n+[@bors][bors] will merge your code into `master` and close the pull request.\n+\n+Depending on the scale of the change, you may see a slightly different form of `r+`:\n+\n+    @bors r+ rollup\n+\n+The additional `rollup` tells [@bors][bors] that this change is eligible for to be\n+\"rolled up\". Changes that are rolled up are tested and merged at the same time, to\n+speed the process up. Typically only small changes that are expected not to conflict\n+with one another are rolled up.\n \n+[rust-highfive]: https://github.com/rust-highfive\n+[steveklabnik]: https://github.com/steveklabnik\n+[bors]: https://github.com/bors\n [merge-queue]: https://buildbot2.rust-lang.org/homu/queue/rust\n \n Speaking of tests, Rust has a comprehensive test suite. More information about\n it can be found [here][rctd].\n \n ### External Dependencies\n-[external-dependencies]: #external-dependencies\n \n Currently building Rust will also build the following external projects:\n \n@@ -187,10 +208,9 @@ Breakage is not allowed in the beta and stable channels, and must be addressed\n before the PR is merged.\n \n #### Breaking Tools Built With The Compiler\n-[breaking-tools-built-with-the-compiler]: #breaking-tools-built-with-the-compiler\n \n Rust's build system builds a number of tools that make use of the\n-internals of the compiler. This includes \n+internals of the compiler. This includes\n [Clippy](https://github.com/rust-lang/rust-clippy),\n [RLS](https://github.com/rust-lang/rls) and\n [rustfmt](https://github.com/rust-lang/rustfmt). If these tools\n@@ -220,7 +240,7 @@ Here are those same steps in detail:\n    `config.toml.example` in the root directory of the Rust repository.\n    Set `submodules = false` in the `[build]` section. This will prevent `x.py`\n    from resetting to the original branch after you make your changes. If you\n-   need to [update any submodules to their latest versions][updating-submodules],\n+   need to [update any submodules to their latest versions](#updating-submodules),\n    see the section of this file about that for more information.\n 2. (optional) Run `./x.py test src/tools/rustfmt` (substituting the submodule\n    that broke for `rustfmt`). Fix any errors in the submodule (and possibly others).\n@@ -234,7 +254,6 @@ Here are those same steps in detail:\n 8. (optional) Send a PR to rust-lang/rust updating the submodule.\n \n #### Updating submodules\n-[updating-submodules]: #updating-submodules\n \n These instructions are specific to updating `rustfmt`, however they may apply\n to the other submodules as well. Please help by improving these instructions\n@@ -288,22 +307,11 @@ This should change the version listed in `Cargo.lock` to the new version you upd\n the submodule to. Running `./x.py build` should work now.\n \n ## Writing Documentation\n-[writing-documentation]: #writing-documentation\n \n Documentation improvements are very welcome. The source of `doc.rust-lang.org`\n is located in `src/doc` in the tree, and standard API documentation is generated\n-from the source code itself.\n-\n-Documentation pull requests function in the same way as other pull requests,\n-though you may see a slightly different form of `r+`:\n-\n-    @bors: r+ 38fe8d2 rollup\n-\n-That additional `rollup` tells @bors that this change is eligible for a 'rollup'.\n-To save @bors some work, and to get small changes through more quickly, when\n-@bors attempts to merge a commit that's rollup-eligible, it will also merge\n-the other rollup-eligible patches too, and they'll get tested and merged at\n-the same time.\n+from the source code itself. Documentation pull requests function in the same way\n+as other pull requests.\n \n To find documentation-related issues, sort by the [T-doc label][tdoc].\n \n@@ -325,7 +333,6 @@ tracker in that repo is also a great way to find things that need doing. There\n are issues for beginners and advanced compiler devs alike!\n \n ## Issue Triage\n-[issue-triage]: #issue-triage\n \n Sometimes, an issue will stay open, even though the bug has been fixed. And\n sometimes, the original bug may go stale because something has changed in the\n@@ -393,7 +400,6 @@ If you're looking for somewhere to start, check out the [E-easy][eeasy] tag.\n [rfcbot]: https://github.com/anp/rfcbot-rs/\n \n ## Out-of-tree Contributions\n-[out-of-tree-contributions]: #out-of-tree-contributions\n \n There are a number of other ways to contribute to Rust that don't deal with\n this repository.\n@@ -413,7 +419,6 @@ valuable!\n [community-library]: https://github.com/rust-lang/rfcs/labels/A-community-library\n \n ## Helpful Links and Information\n-[helpful-info]: #helpful-info\n \n For people new to Rust, and just starting to contribute, or even for\n more seasoned developers, some useful places to look for information\n@@ -428,7 +433,8 @@ are:\n * Although out of date, [Tom Lee's great blog article][tlgba] is very helpful\n * [rustaceans.org][ro] is helpful, but mostly dedicated to IRC\n * The [Rust Compiler Testing Docs][rctd]\n-* For @bors, [this cheat sheet][cheatsheet] is helpful (Remember to replace `@homu` with `@bors` in the commands that you use.)\n+* For [@bors][bors], [this cheat sheet][cheatsheet] is helpful\n+(though you'll need to replace `@homu` with `@bors` in any commands)\n * **Google!** ([search only in Rust Documentation][gsearchdocs] to find types, traits, etc. quickly)\n * Don't be afraid to ask! The Rust community is friendly and helpful.\n "}, {"sha": "52cfa2cb1f80e53353357e604e71108bfb2f8d0d", "filename": "Cargo.lock", "status": "modified", "additions": 1436, "deletions": 1043, "changes": 2479, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "ccd7e8b7654a67f05e15444db80b89421e160590", "filename": "Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/Cargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/Cargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.toml?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -67,6 +67,7 @@ rustc-workspace-hack = { path = 'src/tools/rustc-workspace-hack' }\n # See comments in `tools/rustc-std-workspace-core/README.md` for what's going on\n # here\n rustc-std-workspace-core = { path = 'src/tools/rustc-std-workspace-core' }\n+rustc-std-workspace-alloc = { path = 'src/tools/rustc-std-workspace-alloc' }\n \n [patch.\"https://github.com/rust-lang/rust-clippy\"]\n clippy_lints = { path = \"src/tools/clippy/clippy_lints\" }"}, {"sha": "40df6a47378717da376995cc79a8f86f4c3de117", "filename": "README.md", "status": "modified", "additions": 59, "deletions": 36, "changes": 95, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/README.md", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/README.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/README.md?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -6,19 +6,22 @@ standard library, and documentation.\n [Rust]: https://www.rust-lang.org\n \n ## Quick Start\n-[quick-start]: #quick-start\n \n Read [\"Installation\"] from [The Book].\n \n [\"Installation\"]: https://doc.rust-lang.org/book/ch01-01-installation.html\n [The Book]: https://doc.rust-lang.org/book/index.html\n \n ## Installing from Source\n-[building-from-source]: #building-from-source\n \n-_Note: If you wish to contribute to the compiler, you should read\n-[this chapter](https://rust-lang.github.io/rustc-guide/how-to-build-and-run.html)\n-of the rustc-guide instead._\n+_Note: If you wish to contribute to the compiler, you should read [this\n+chapter][rustcguidebuild] of the rustc-guide instead of this section._\n+\n+The Rust build system has a Python script called `x.py` to bootstrap building\n+the compiler. More information about it may be found by running `./x.py --help`\n+or reading the [rustc guide][rustcguidebuild].\n+\n+[rustcguidebuild]: https://rust-lang.github.io/rustc-guide/how-to-build-and-run.html\n \n ### Building on *nix\n 1. Make sure you have installed the dependencies:\n@@ -39,27 +42,36 @@ of the rustc-guide instead._\n \n [source]: https://github.com/rust-lang/rust\n \n-3. Build and install:\n+3. Configure the build settings:\n+\n+    The Rust build system uses a file named `config.toml` in the root of the\n+    source tree to determine various configuration settings for the build.\n+    Copy the default `config.toml.example` to `config.toml` to get started.\n \n     ```sh\n-    $ ./x.py build && sudo ./x.py install\n+    $ cp config.toml.example config.toml\n     ```\n \n-    > ***Note:*** Install locations can be adjusted by copying the config file\n-    > from `./config.toml.example` to `./config.toml`, and\n-    > adjusting the `prefix` option under `[install]`. Various other options, such\n-    > as enabling debug information, are also supported, and are documented in\n-    > the config file.\n+    It is recommended that if you plan to use the Rust build system to create\n+    an installation (using `./x.py install`) that you set the `prefix` value\n+    in the `[install]` section to a directory that you have write permissions.\n+\n+4. Build and install:\n+\n+    ```sh\n+    $ ./x.py build && ./x.py install\n+    ```\n \n-    When complete, `sudo ./x.py install` will place several programs into\n-    `/usr/local/bin`: `rustc`, the Rust compiler, and `rustdoc`, the\n+    When complete, `./x.py install` will place several programs into\n+    `$PREFIX/bin`: `rustc`, the Rust compiler, and `rustdoc`, the\n     API-documentation tool. This install does not include [Cargo],\n-    Rust's package manager, which you may also want to build.\n+    Rust's package manager. To build and install Cargo, you may\n+    run `./x.py install cargo` or set the `build.extended` key in\n+    `config.toml` to `true` to build and install all tools.\n \n [Cargo]: https://github.com/rust-lang/cargo\n \n ### Building on Windows\n-[building-on-windows]: #building-on-windows\n \n There are two prominent ABIs in use on Windows: the native (MSVC) ABI used by\n Visual Studio, and the GNU ABI used by the GCC toolchain. Which version of Rust\n@@ -69,7 +81,6 @@ for interop with GNU software built using the MinGW/MSYS2 toolchain use the GNU\n build.\n \n #### MinGW\n-[windows-mingw]: #windows-mingw\n \n [MSYS2][msys2] can be used to easily build Rust on Windows:\n \n@@ -110,11 +121,15 @@ build.\n    ```\n \n #### MSVC\n-[windows-msvc]: #windows-msvc\n \n-MSVC builds of Rust additionally require an installation of Visual Studio 2013\n-(or later) so `rustc` can use its linker. Make sure to check the \u201cC++ tools\u201d\n-option.\n+MSVC builds of Rust additionally require an installation of Visual Studio 2017\n+(or later) so `rustc` can use its linker.  The simplest way is to get the\n+[Visual Studio], check the \u201cC++ build tools\u201d and \u201cWindows 10 SDK\u201d workload.\n+\n+[Visual Studio]: https://visualstudio.microsoft.com/downloads/\n+\n+(If you're installing cmake yourself, be careful that \u201cC++ CMake tools for\n+Windows\u201d doesn't get included under \u201cIndividual components\u201d.)\n \n With these dependencies installed, you can build the compiler in a `cmd.exe`\n shell with:\n@@ -129,12 +144,11 @@ then you may need to force rustbuild to use an older version. This can be done\n by manually calling the appropriate vcvars file before running the bootstrap.\n \n ```batch\n-> CALL \"C:\\Program Files (x86)\\Microsoft Visual Studio 14.0\\VC\\bin\\amd64\\vcvars64.bat\"\n+> CALL \"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\BuildTools\\VC\\Auxiliary\\Build\\vcvars64.bat\"\n > python x.py build\n ```\n \n #### Specifying an ABI\n-[specifying-an-abi]: #specifying-an-abi\n \n Each specific ABI can also be used from either environment (for example, using\n the GNU ABI in PowerShell) by using an explicit build triple. The available\n@@ -148,11 +162,10 @@ Windows build triples are:\n \n The build triple can be specified by either specifying `--build=<triple>` when\n invoking `x.py` commands, or by copying the `config.toml` file (as described\n-in Building From Source), and modifying the `build` option under the `[build]`\n-section.\n+in [Installing From Source](#installing-from-source)), and modifying the\n+`build` option under the `[build]` section.\n \n ### Configure and Make\n-[configure-and-make]: #configure-and-make\n \n While it's not the recommended build system, this project also provides a\n configure script and makefile (the latter of which just invokes `x.py`).\n@@ -167,7 +180,6 @@ When using the configure script, the generated `config.mk` file may override the\n `config.mk` file.\n \n ## Building Documentation\n-[building-documentation]: #building-documentation\n \n If you\u2019d like to build the documentation, it\u2019s almost the same:\n \n@@ -180,7 +192,6 @@ the ABI used. I.e., if the ABI was `x86_64-pc-windows-msvc`, the directory will\n `build\\x86_64-pc-windows-msvc\\doc`.\n \n ## Notes\n-[notes]: #notes\n \n Since the Rust compiler is written in Rust, it must be built by a\n precompiled \"snapshot\" version of itself (made in an earlier stage of\n@@ -189,11 +200,11 @@ fetch snapshots, and an OS that can execute the available snapshot binaries.\n \n Snapshot binaries are currently built and tested on several platforms:\n \n-| Platform / Architecture  | x86 | x86_64 |\n-|--------------------------|-----|--------|\n-| Windows (7, 8, 10, ...)  | \u2713   | \u2713      |\n-| Linux (2.6.18 or later)  | \u2713   | \u2713      |\n-| OSX (10.7 Lion or later) | \u2713   | \u2713      |\n+| Platform / Architecture    | x86 | x86_64 |\n+|----------------------------|-----|--------|\n+| Windows (7, 8, 10, ...)    | \u2713   | \u2713      |\n+| Linux (2.6.18 or later)    | \u2713   | \u2713      |\n+| macOS (10.7 Lion or later) | \u2713   | \u2713      |\n \n You may find that other platforms work, but these are our officially\n supported build environments that are most likely to work.\n@@ -203,7 +214,6 @@ There is more advice about hacking on Rust in [CONTRIBUTING.md].\n [CONTRIBUTING.md]: https://github.com/rust-lang/rust/blob/master/CONTRIBUTING.md\n \n ## Getting Help\n-[getting-help]: #getting-help\n \n The Rust community congregates in a few places:\n \n@@ -216,7 +226,6 @@ The Rust community congregates in a few places:\n [users.rust-lang.org]: https://users.rust-lang.org/\n \n ## Contributing\n-[contributing]: #contributing\n \n To contribute to Rust, please see [CONTRIBUTING](CONTRIBUTING.md).\n \n@@ -237,11 +246,25 @@ Also, you may find the [rustdocs for the compiler itself][rustdocs] useful.\n [rustdocs]: https://doc.rust-lang.org/nightly/nightly-rustc/rustc/\n \n ## License\n-[license]: #license\n \n Rust is primarily distributed under the terms of both the MIT license\n and the Apache License (Version 2.0), with portions covered by various\n BSD-like licenses.\n \n See [LICENSE-APACHE](LICENSE-APACHE), [LICENSE-MIT](LICENSE-MIT), and\n [COPYRIGHT](COPYRIGHT) for details.\n+\n+## Trademark\n+\n+The Rust programming language is an open source, community project governed\n+by a core team. It is also sponsored by the Mozilla Foundation (\u201cMozilla\u201d),\n+which owns and protects the Rust and Cargo trademarks and logos\n+(the \u201cRust Trademarks\u201d).\n+\n+If you want to use these names or brands, please read the [media guide][media-guide].\n+\n+Third-party logos may be subject to third-party copyrights and trademarks. See\n+[Licenses][policies-licenses] for details.\n+\n+[media-guide]: https://www.rust-lang.org/policies/media-guide\n+[policies-licenses]: https://www.rust-lang.org/policies/licenses"}, {"sha": "7ad739d06d54f0aeaf3c56a28ab7a66b017ce32d", "filename": "RELEASES.md", "status": "modified", "additions": 492, "deletions": 4, "changes": 496, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/RELEASES.md", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/RELEASES.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/RELEASES.md?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -1,3 +1,485 @@\n+Version 1.37.0 (2019-08-15)\n+==========================\n+\n+Language\n+--------\n+- `#[must_use]` will now warn if the type is contained in a [tuple][61100],\n+  [`Box`][62228], or an [array][62235] and unused.\n+- [You can now use the `cfg` and `cfg_attr` attributes on\n+  generic parameters.][61547]\n+- [You can now use enum variants through type alias.][61682] e.g. You can\n+  write the following:\n+  ```rust\n+  type MyOption = Option<u8>;\n+\n+  fn increment_or_zero(x: MyOption) -> u8 {\n+      match x {\n+          MyOption::Some(y) => y + 1,\n+          MyOption::None => 0,\n+      }\n+  }\n+  ```\n+- [You can now use `_` as an identifier for consts.][61347] e.g. You can write\n+  `const _: u32 = 5;`.\n+- [You can now use `#[repr(align(X)]` on enums.][61229]\n+- [The  `?`/_\"Kleene\"_ macro operator is now available in the\n+  2015 edition.][60932]\n+\n+Compiler\n+--------\n+- [You can now enable Profile-Guided Optimization with the `-C profile-generate`\n+  and `-C profile-use` flags.][61268] For more information on how to use profile\n+  guided optimization, please refer to the [rustc book][rustc-book-pgo].\n+- [The `rust-lldb` wrapper script should now work again.][61827]\n+\n+Libraries\n+---------\n+- [`mem::MaybeUninit<T>` is now ABI-compatible with `T`.][61802]\n+\n+Stabilized APIs\n+---------------\n+- [`BufReader::buffer`]\n+- [`BufWriter::buffer`]\n+- [`Cell::from_mut`]\n+- [`Cell<[T]>::as_slice_of_cells`][`Cell<slice>::as_slice_of_cells`]\n+- [`DoubleEndedIterator::nth_back`]\n+- [`Option::xor`]\n+- [`Wrapping::reverse_bits`]\n+- [`i128::reverse_bits`]\n+- [`i16::reverse_bits`]\n+- [`i32::reverse_bits`]\n+- [`i64::reverse_bits`]\n+- [`i8::reverse_bits`]\n+- [`isize::reverse_bits`]\n+- [`slice::copy_within`]\n+- [`u128::reverse_bits`]\n+- [`u16::reverse_bits`]\n+- [`u32::reverse_bits`]\n+- [`u64::reverse_bits`]\n+- [`u8::reverse_bits`]\n+- [`usize::reverse_bits`]\n+\n+Cargo\n+-----\n+- [`Cargo.lock` files are now included by default when publishing executable crates\n+  with executables.][cargo/7026]\n+- [You can now specify `default-run=\"foo\"` in `[package]` to specify the\n+  default executable to use for `cargo run`.][cargo/7056]\n+\n+Misc\n+----\n+\n+Compatibility Notes\n+-------------------\n+- [Using `...` for inclusive range patterns will now warn by default.][61342]\n+  Please transition your code to using the `..=` syntax for inclusive\n+  ranges instead.\n+- [Using a trait object without the `dyn` will now warn by default.][61203]\n+  Please transition your code to use `dyn Trait` for trait objects instead.\n+\n+[62228]: https://github.com/rust-lang/rust/pull/62228/\n+[62235]: https://github.com/rust-lang/rust/pull/62235/\n+[61802]: https://github.com/rust-lang/rust/pull/61802/\n+[61827]: https://github.com/rust-lang/rust/pull/61827/\n+[61547]: https://github.com/rust-lang/rust/pull/61547/\n+[61682]: https://github.com/rust-lang/rust/pull/61682/\n+[61268]: https://github.com/rust-lang/rust/pull/61268/\n+[61342]: https://github.com/rust-lang/rust/pull/61342/\n+[61347]: https://github.com/rust-lang/rust/pull/61347/\n+[61100]: https://github.com/rust-lang/rust/pull/61100/\n+[61203]: https://github.com/rust-lang/rust/pull/61203/\n+[61229]: https://github.com/rust-lang/rust/pull/61229/\n+[60932]: https://github.com/rust-lang/rust/pull/60932/\n+[cargo/7026]: https://github.com/rust-lang/cargo/pull/7026/\n+[cargo/7056]: https://github.com/rust-lang/cargo/pull/7056/\n+[`BufReader::buffer`]: https://doc.rust-lang.org/std/io/struct.BufReader.html#method.buffer\n+[`BufWriter::buffer`]: https://doc.rust-lang.org/std/io/struct.BufWriter.html#method.buffer\n+[`Cell::from_mut`]: https://doc.rust-lang.org/std/cell/struct.Cell.html#method.from_mut\n+[`Cell<slice>::as_slice_of_cells`]: https://doc.rust-lang.org/std/cell/struct.Cell.html#method.as_slice_of_cells\n+[`DoubleEndedIterator::nth_back`]: https://doc.rust-lang.org/std/iter/trait.DoubleEndedIterator.html#method.nth_back\n+[`Option::xor`]: https://doc.rust-lang.org/std/option/enum.Option.html#method.xor\n+[`RefCell::try_borrow_unguarded`]: https://doc.rust-lang.org/std/cell/struct.RefCell.html#method.try_borrow_unguarded\n+[`Wrapping::reverse_bits`]: https://doc.rust-lang.org/std/num/struct.Wrapping.html#method.reverse_bits\n+[`i128::reverse_bits`]: https://doc.rust-lang.org/std/primitive.i128.html#method.reverse_bits\n+[`i16::reverse_bits`]: https://doc.rust-lang.org/std/primitive.i16.html#method.reverse_bits\n+[`i32::reverse_bits`]: https://doc.rust-lang.org/std/primitive.i32.html#method.reverse_bits\n+[`i64::reverse_bits`]: https://doc.rust-lang.org/std/primitive.i64.html#method.reverse_bits\n+[`i8::reverse_bits`]: https://doc.rust-lang.org/std/primitive.i8.html#method.reverse_bits\n+[`isize::reverse_bits`]: https://doc.rust-lang.org/std/primitive.isize.html#method.reverse_bits\n+[`slice::copy_within`]: https://doc.rust-lang.org/std/primitive.slice.html#method.copy_within\n+[`u128::reverse_bits`]: https://doc.rust-lang.org/std/primitive.u128.html#method.reverse_bits\n+[`u16::reverse_bits`]: https://doc.rust-lang.org/std/primitive.u16.html#method.reverse_bits\n+[`u32::reverse_bits`]: https://doc.rust-lang.org/std/primitive.u32.html#method.reverse_bits\n+[`u64::reverse_bits`]: https://doc.rust-lang.org/std/primitive.u64.html#method.reverse_bits\n+[`u8::reverse_bits`]: https://doc.rust-lang.org/std/primitive.u8.html#method.reverse_bits\n+[`usize::reverse_bits`]: https://doc.rust-lang.org/std/primitive.usize.html#method.reverse_bits\n+[rustc-book-pgo]: https://doc.rust-lang.org/rustc/profile-guided-optimization.html\n+\n+\n+Version 1.36.0 (2019-07-04)\n+==========================\n+\n+Language\n+--------\n+- [Non-Lexical Lifetimes are now enabled on the 2015 edition.][59114]\n+- [The order of traits in trait objects no longer affects the semantics of that\n+  object.][59445] e.g. `dyn Send + fmt::Debug` is now equivalent to\n+  `dyn fmt::Debug + Send`, where this was previously not the case.\n+\n+Libraries\n+---------\n+- [`HashMap`'s implementation has been replaced with `hashbrown::HashMap` implementation.][58623]\n+- [`TryFromSliceError` now implements `From<Infallible>`.][60318]\n+- [`mem::needs_drop` is now available as a const fn.][60364]\n+- [`alloc::Layout::from_size_align_unchecked` is now available as a const fn.][60370]\n+- [`String` now implements `BorrowMut<str>`.][60404]\n+- [`io::Cursor` now implements `Default`.][60234]\n+- [Both `NonNull::{dangling, cast}` are now const fns.][60244]\n+- [The `alloc` crate is now stable.][59675] `alloc` allows you to use a subset\n+  of `std` (e.g. `Vec`, `Box`, `Arc`) in `#![no_std]` environments if the\n+  environment has access to heap memory allocation.\n+- [`String` now implements `From<&String>`.][59825]\n+- [You can now pass multiple arguments to the `dbg!` macro.][59826] `dbg!` will\n+  return a tuple of each argument when there is multiple arguments.\n+- [`Result::{is_err, is_ok}` are now `#[must_use]` and will produce a warning if\n+  not used.][59648]\n+\n+Stabilized APIs\n+---------------\n+- [`VecDeque::rotate_left`]\n+- [`VecDeque::rotate_right`]\n+- [`Iterator::copied`]\n+- [`io::IoSlice`]\n+- [`io::IoSliceMut`]\n+- [`Read::read_vectored`]\n+- [`Write::write_vectored`]\n+- [`str::as_mut_ptr`]\n+- [`mem::MaybeUninit`]\n+- [`pointer::align_offset`]\n+- [`future::Future`]\n+- [`task::Context`]\n+- [`task::RawWaker`]\n+- [`task::RawWakerVTable`]\n+- [`task::Waker`]\n+- [`task::Poll`]\n+\n+Cargo\n+-----\n+- [Cargo will now produce an error if you attempt to use the name of a required dependency as a feature.][cargo/6860]\n+- [You can now pass the `--offline` flag to run cargo without accessing the network.][cargo/6934]\n+\n+You can find further change's in [Cargo's 1.36.0 release notes][cargo-1-36-0].\n+\n+Clippy\n+------\n+There have been numerous additions and fixes to clippy, see [Clippy's 1.36.0 release notes][clippy-1-36-0] for more details.\n+\n+Misc\n+----\n+\n+Compatibility Notes\n+-------------------\n+- With the stabilisation of `mem::MaybeUninit`, `mem::uninitialized` use is no\n+  longer recommended, and will be deprecated in 1.39.0.\n+\n+[60318]: https://github.com/rust-lang/rust/pull/60318/\n+[60364]: https://github.com/rust-lang/rust/pull/60364/\n+[60370]: https://github.com/rust-lang/rust/pull/60370/\n+[60404]: https://github.com/rust-lang/rust/pull/60404/\n+[60234]: https://github.com/rust-lang/rust/pull/60234/\n+[60244]: https://github.com/rust-lang/rust/pull/60244/\n+[58623]: https://github.com/rust-lang/rust/pull/58623/\n+[59648]: https://github.com/rust-lang/rust/pull/59648/\n+[59675]: https://github.com/rust-lang/rust/pull/59675/\n+[59825]: https://github.com/rust-lang/rust/pull/59825/\n+[59826]: https://github.com/rust-lang/rust/pull/59826/\n+[59445]: https://github.com/rust-lang/rust/pull/59445/\n+[59114]: https://github.com/rust-lang/rust/pull/59114/\n+[cargo/6860]: https://github.com/rust-lang/cargo/pull/6860/\n+[cargo/6934]: https://github.com/rust-lang/cargo/pull/6934/\n+[`VecDeque::rotate_left`]: https://doc.rust-lang.org/std/collections/struct.VecDeque.html#method.rotate_left\n+[`VecDeque::rotate_right`]: https://doc.rust-lang.org/std/collections/struct.VecDeque.html#method.rotate_right\n+[`Iterator::copied`]: https://doc.rust-lang.org/std/iter/trait.Iterator.html#tymethod.copied\n+[`io::IoSlice`]: https://doc.rust-lang.org/std/io/struct.IoSlice.html\n+[`io::IoSliceMut`]: https://doc.rust-lang.org/std/io/struct.IoSliceMut.html\n+[`Read::read_vectored`]: https://doc.rust-lang.org/std/io/trait.Read.html#method.read_vectored\n+[`Write::write_vectored`]: https://doc.rust-lang.org/std/io/trait.Write.html#method.write_vectored\n+[`str::as_mut_ptr`]: https://doc.rust-lang.org/std/primitive.str.html#method.as_mut_ptr\n+[`mem::MaybeUninit`]: https://doc.rust-lang.org/std/mem/union.MaybeUninit.html\n+[`pointer::align_offset`]: https://doc.rust-lang.org/std/primitive.pointer.html#method.align_offset\n+[`future::Future`]: https://doc.rust-lang.org/std/future/trait.Future.html\n+[`task::Context`]: https://doc.rust-lang.org/beta/std/task/struct.Context.html\n+[`task::RawWaker`]: https://doc.rust-lang.org/beta/std/task/struct.RawWaker.html\n+[`task::RawWakerVTable`]: https://doc.rust-lang.org/beta/std/task/struct.RawWakerVTable.html\n+[`task::Waker`]: https://doc.rust-lang.org/beta/std/task/struct.Waker.html\n+[`task::Poll`]: https://doc.rust-lang.org/beta/std/task/enum.Poll.html\n+[clippy-1-36-0]: https://github.com/rust-lang/rust-clippy/blob/master/CHANGELOG.md#rust-136\n+[cargo-1-36-0]: https://github.com/rust-lang/cargo/blob/master/CHANGELOG.md#cargo-136-2019-07-04\n+\n+\n+Version 1.35.0 (2019-05-23)\n+==========================\n+\n+Language\n+--------\n+- [`FnOnce`, `FnMut`, and the `Fn` traits are now implemented for `Box<FnOnce>`,\n+  `Box<FnMut>`, and `Box<Fn>` respectively.][59500]\n+- [You can now coerce closures into unsafe function pointers.][59580] e.g.\n+  ```rust\n+  unsafe fn call_unsafe(func: unsafe fn()) {\n+      func()\n+  }\n+\n+  pub fn main() {\n+      unsafe { call_unsafe(|| {}); }\n+  }\n+  ```\n+\n+\n+Compiler\n+--------\n+- [Added the `armv6-unknown-freebsd-gnueabihf` and\n+  `armv7-unknown-freebsd-gnueabihf` targets.][58080]\n+- [Added the `wasm32-unknown-wasi` target.][59464]\n+\n+\n+Libraries\n+---------\n+- [`Thread` will now show its ID in `Debug` output.][59460]\n+- [`StdinLock`, `StdoutLock`, and `StderrLock` now implement `AsRawFd`.][59512]\n+- [`alloc::System` now implements `Default`.][59451]\n+- [Expanded `Debug` output (`{:#?}`) for structs now has a trailing comma on the\n+  last field.][59076]\n+- [`char::{ToLowercase, ToUppercase}` now\n+  implement `ExactSizeIterator`.][58778]\n+- [All `NonZero` numeric types now implement `FromStr`.][58717]\n+- [Removed the `Read` trait bounds\n+  on the `BufReader::{get_ref, get_mut, into_inner}` methods.][58423]\n+- [You can now call the `dbg!` macro without any parameters to print the file\n+  and line where it is called.][57847]\n+- [In place ASCII case conversions are now up to 4\u00d7 faster.][59283]\n+  e.g. `str::make_ascii_lowercase`\n+- [`hash_map::{OccupiedEntry, VacantEntry}` now implement `Sync`\n+  and `Send`.][58369]\n+\n+Stabilized APIs\n+---------------\n+- [`f32::copysign`]\n+- [`f64::copysign`]\n+- [`RefCell::replace_with`]\n+- [`RefCell::map_split`]\n+- [`ptr::hash`]\n+- [`Range::contains`]\n+- [`RangeFrom::contains`]\n+- [`RangeTo::contains`]\n+- [`RangeInclusive::contains`]\n+- [`RangeToInclusive::contains`]\n+- [`Option::copied`]\n+\n+Cargo\n+-----\n+- [You can now set `cargo:rustc-cdylib-link-arg` at build time to pass custom\n+  linker arguments when building a `cdylib`.][cargo/6298] Its usage is highly\n+  platform specific.\n+\n+Misc\n+----\n+- [The Rust toolchain is now available natively for musl based distros.][58575]\n+\n+[59460]: https://github.com/rust-lang/rust/pull/59460/\n+[59464]: https://github.com/rust-lang/rust/pull/59464/\n+[59500]: https://github.com/rust-lang/rust/pull/59500/\n+[59512]: https://github.com/rust-lang/rust/pull/59512/\n+[59580]: https://github.com/rust-lang/rust/pull/59580/\n+[59283]: https://github.com/rust-lang/rust/pull/59283/\n+[59451]: https://github.com/rust-lang/rust/pull/59451/\n+[59076]: https://github.com/rust-lang/rust/pull/59076/\n+[58778]: https://github.com/rust-lang/rust/pull/58778/\n+[58717]: https://github.com/rust-lang/rust/pull/58717/\n+[58369]: https://github.com/rust-lang/rust/pull/58369/\n+[58423]: https://github.com/rust-lang/rust/pull/58423/\n+[58080]: https://github.com/rust-lang/rust/pull/58080/\n+[57847]: https://github.com/rust-lang/rust/pull/57847/\n+[58575]: https://github.com/rust-lang/rust/pull/58575\n+[cargo/6298]: https://github.com/rust-lang/cargo/pull/6298/\n+[`f32::copysign`]: https://doc.rust-lang.org/stable/std/primitive.f32.html#method.copysign\n+[`f64::copysign`]: https://doc.rust-lang.org/stable/std/primitive.f64.html#method.copysign\n+[`RefCell::replace_with`]: https://doc.rust-lang.org/stable/std/cell/struct.RefCell.html#method.replace_with\n+[`RefCell::map_split`]: https://doc.rust-lang.org/stable/std/cell/struct.RefCell.html#method.map_split\n+[`ptr::hash`]: https://doc.rust-lang.org/stable/std/ptr/fn.hash.html\n+[`Range::contains`]: https://doc.rust-lang.org/std/ops/struct.Range.html#method.contains\n+[`RangeFrom::contains`]: https://doc.rust-lang.org/std/ops/struct.RangeFrom.html#method.contains\n+[`RangeTo::contains`]: https://doc.rust-lang.org/std/ops/struct.RangeTo.html#method.contains\n+[`RangeInclusive::contains`]: https://doc.rust-lang.org/std/ops/struct.RangeInclusive.html#method.contains\n+[`RangeToInclusive::contains`]: https://doc.rust-lang.org/std/ops/struct.RangeToInclusive.html#method.contains\n+[`Option::copied`]: https://doc.rust-lang.org/std/option/enum.Option.html#method.copied\n+\n+Version 1.34.2 (2019-05-14)\n+===========================\n+\n+* [Destabilize the `Error::type_id` function due to a security\n+   vulnerability][60785] ([CVE-2019-12083])\n+\n+[60785]: https://github.com/rust-lang/rust/pull/60785\n+[CVE-2019-12083]: https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-12083\n+\n+Version 1.34.1 (2019-04-25)\n+===========================\n+\n+* [Fix false positives for the `redundant_closure` Clippy lint][clippy/3821]\n+* [Fix false positives for the `missing_const_for_fn` Clippy lint][clippy/3844]\n+* [Fix Clippy panic when checking some macros][clippy/3805]\n+\n+[clippy/3821]: https://github.com/rust-lang/rust-clippy/pull/3821\n+[clippy/3844]: https://github.com/rust-lang/rust-clippy/pull/3844\n+[clippy/3805]: https://github.com/rust-lang/rust-clippy/pull/3805\n+\n+Version 1.34.0 (2019-04-11)\n+==========================\n+\n+Language\n+--------\n+- [You can now use `#[deprecated = \"reason\"]`][58166] as a shorthand for\n+  `#[deprecated(note = \"reason\")]`. This was previously allowed by mistake\n+  but had no effect.\n+- [You can now accept token streams in `#[attr()]`,`#[attr[]]`, and\n+  `#[attr{}]` procedural macros.][57367]\n+- [You can now write `extern crate self as foo;`][57407] to import your\n+  crate's root into the extern prelude.\n+\n+\n+Compiler\n+--------\n+- [You can now target `riscv64imac-unknown-none-elf` and\n+  `riscv64gc-unknown-none-elf`.][58406]\n+- [You can now enable linker plugin LTO optimisations with\n+  `-C linker-plugin-lto`.][58057] This allows rustc to compile your Rust code\n+  into LLVM bitcode allowing LLVM to perform LTO optimisations across C/C++ FFI\n+  boundaries.\n+- [You can now target `powerpc64-unknown-freebsd`.][57809]\n+\n+\n+Libraries\n+---------\n+- [The trait bounds have been removed on some of `HashMap<K, V, S>`'s and\n+  `HashSet<T, S>`'s basic methods.][58370] Most notably you no longer require\n+  the `Hash` trait to create an iterator.\n+- [The `Ord` trait bounds have been removed on some of `BinaryHeap<T>`'s basic\n+  methods.][58421] Most notably you no longer require the `Ord` trait to create\n+  an iterator.\n+- [The methods `overflowing_neg` and `wrapping_neg` are now `const` functions\n+  for all numeric types.][58044]\n+- [Indexing a `str` is now generic over all types that\n+  implement `SliceIndex<str>`.][57604]\n+- [`str::trim`, `str::trim_matches`, `str::trim_{start, end}`, and\n+  `str::trim_{start, end}_matches` are now `#[must_use]`][57106] and will\n+  produce a warning if their returning type is unused.\n+- [The methods `checked_pow`, `saturating_pow`, `wrapping_pow`, and\n+  `overflowing_pow` are now available for all numeric types.][57873] These are\n+  equivalent to methods such as `wrapping_add` for the `pow` operation.\n+\n+\n+Stabilized APIs\n+---------------\n+\n+#### std & core\n+* [`Any::type_id`]\n+* [`Error::type_id`]\n+* [`atomic::AtomicI16`]\n+* [`atomic::AtomicI32`]\n+* [`atomic::AtomicI64`]\n+* [`atomic::AtomicI8`]\n+* [`atomic::AtomicU16`]\n+* [`atomic::AtomicU32`]\n+* [`atomic::AtomicU64`]\n+* [`atomic::AtomicU8`]\n+* [`convert::Infallible`]\n+* [`convert::TryFrom`]\n+* [`convert::TryInto`]\n+* [`iter::from_fn`]\n+* [`iter::successors`]\n+* [`num::NonZeroI128`]\n+* [`num::NonZeroI16`]\n+* [`num::NonZeroI32`]\n+* [`num::NonZeroI64`]\n+* [`num::NonZeroI8`]\n+* [`num::NonZeroIsize`]\n+* [`slice::sort_by_cached_key`]\n+* [`str::escape_debug`]\n+* [`str::escape_default`]\n+* [`str::escape_unicode`]\n+* [`str::split_ascii_whitespace`]\n+\n+#### std\n+* [`Instant::checked_add`]\n+* [`Instant::checked_sub`]\n+* [`SystemTime::checked_add`]\n+* [`SystemTime::checked_sub`]\n+\n+Cargo\n+-----\n+- [You can now use alternative registries to crates.io.][cargo/6654]\n+\n+Misc\n+----\n+- [You can now use the `?` operator in your documentation tests without manually\n+  adding `fn main() -> Result<(), _> {}`.][56470]\n+\n+Compatibility Notes\n+-------------------\n+- [`Command::before_exec` is being replaced by the unsafe method\n+  `Command::pre_exec`][58059] and will be deprecated with Rust 1.37.0.\n+- [Use of `ATOMIC_{BOOL, ISIZE, USIZE}_INIT` is now deprecated][57425] as you\n+  can now use `const` functions in `static` variables.\n+\n+[58370]: https://github.com/rust-lang/rust/pull/58370/\n+[58406]: https://github.com/rust-lang/rust/pull/58406/\n+[58421]: https://github.com/rust-lang/rust/pull/58421/\n+[58166]: https://github.com/rust-lang/rust/pull/58166/\n+[58044]: https://github.com/rust-lang/rust/pull/58044/\n+[58057]: https://github.com/rust-lang/rust/pull/58057/\n+[58059]: https://github.com/rust-lang/rust/pull/58059/\n+[57809]: https://github.com/rust-lang/rust/pull/57809/\n+[57873]: https://github.com/rust-lang/rust/pull/57873/\n+[57604]: https://github.com/rust-lang/rust/pull/57604/\n+[57367]: https://github.com/rust-lang/rust/pull/57367/\n+[57407]: https://github.com/rust-lang/rust/pull/57407/\n+[57425]: https://github.com/rust-lang/rust/pull/57425/\n+[57106]: https://github.com/rust-lang/rust/pull/57106/\n+[56470]: https://github.com/rust-lang/rust/pull/56470/\n+[cargo/6654]: https://github.com/rust-lang/cargo/pull/6654/\n+[`Any::type_id`]: https://doc.rust-lang.org/std/any/trait.Any.html#tymethod.type_id\n+[`Error::type_id`]: https://doc.rust-lang.org/std/error/trait.Error.html#method.type_id\n+[`atomic::AtomicI16`]: https://doc.rust-lang.org/std/sync/atomic/struct.AtomicI16.html\n+[`atomic::AtomicI32`]: https://doc.rust-lang.org/std/sync/atomic/struct.AtomicI32.html\n+[`atomic::AtomicI64`]: https://doc.rust-lang.org/std/sync/atomic/struct.AtomicI64.html\n+[`atomic::AtomicI8`]: https://doc.rust-lang.org/std/sync/atomic/struct.AtomicI8.html\n+[`atomic::AtomicU16`]: https://doc.rust-lang.org/std/sync/atomic/struct.AtomicU16.html\n+[`atomic::AtomicU32`]: https://doc.rust-lang.org/std/sync/atomic/struct.AtomicU32.html\n+[`atomic::AtomicU64`]: https://doc.rust-lang.org/std/sync/atomic/struct.AtomicU64.html\n+[`atomic::AtomicU8`]: https://doc.rust-lang.org/std/sync/atomic/struct.AtomicU8.html\n+[`convert::Infallible`]: https://doc.rust-lang.org/std/convert/enum.Infallible.html\n+[`convert::TryFrom`]: https://doc.rust-lang.org/std/convert/trait.TryFrom.html\n+[`convert::TryInto`]: https://doc.rust-lang.org/std/convert/trait.TryInto.html\n+[`iter::from_fn`]: https://doc.rust-lang.org/std/iter/fn.from_fn.html\n+[`iter::successors`]: https://doc.rust-lang.org/std/iter/fn.successors.html\n+[`num::NonZeroI128`]: https://doc.rust-lang.org/std/num/struct.NonZeroI128.html\n+[`num::NonZeroI16`]: https://doc.rust-lang.org/std/num/struct.NonZeroI16.html\n+[`num::NonZeroI32`]: https://doc.rust-lang.org/std/num/struct.NonZeroI32.html\n+[`num::NonZeroI64`]: https://doc.rust-lang.org/std/num/struct.NonZeroI64.html\n+[`num::NonZeroI8`]: https://doc.rust-lang.org/std/num/struct.NonZeroI8.html\n+[`num::NonZeroIsize`]: https://doc.rust-lang.org/std/num/struct.NonZeroIsize.html\n+[`slice::sort_by_cached_key`]: https://doc.rust-lang.org/std/primitive.slice.html#method.sort_by_cached_key\n+[`str::escape_debug`]: https://doc.rust-lang.org/std/primitive.str.html#method.escape_debug\n+[`str::escape_default`]: https://doc.rust-lang.org/std/primitive.str.html#method.escape_default\n+[`str::escape_unicode`]: https://doc.rust-lang.org/std/primitive.str.html#method.escape_unicode\n+[`str::split_ascii_whitespace`]: https://doc.rust-lang.org/std/primitive.str.html#method.split_ascii_whitespace\n+[`Instant::checked_add`]: https://doc.rust-lang.org/std/time/struct.Instant.html#method.checked_add\n+[`Instant::checked_sub`]: https://doc.rust-lang.org/std/time/struct.Instant.html#method.checked_sub\n+[`SystemTime::checked_add`]: https://doc.rust-lang.org/std/time/struct.SystemTime.html#method.checked_add\n+[`SystemTime::checked_sub`]: https://doc.rust-lang.org/std/time/struct.SystemTime.html#method.checked_sub\n+\n+\n Version 1.33.0 (2019-02-28)\n ==========================\n \n@@ -57,7 +539,7 @@ Compiler\n --------\n - [You can now set a linker flavor for `rustc` with the `-Clinker-flavor`\n   command line argument.][56351]\n-- [The mininum required LLVM version has been bumped to 6.0.][56642]\n+- [The minimum required LLVM version has been bumped to 6.0.][56642]\n - [Added support for the PowerPC64 architecture on FreeBSD.][57615]\n - [The `x86_64-fortanix-unknown-sgx` target support has been upgraded to\n   tier 2 support.][57130] Visit the [platform support][platform-support] page for\n@@ -99,6 +581,8 @@ Stabilized APIs\n \n Cargo\n -----\n+- [You can now publish crates that require a feature flag to compile with\n+  `cargo publish --features` or `cargo publish --all-features`.][cargo/6453]\n - [Cargo should now rebuild a crate if a file was modified during the initial\n   build.][cargo/6484]\n \n@@ -110,8 +594,11 @@ Compatibility Notes\n   methods instead.\n - The `Error::cause` method has been deprecated in favor of `Error::source` which supports\n   downcasting.\n+- [Libtest no longer creates a new thread for each test when\n+  `--test-threads=1`.  It also runs the tests in deterministic order][56243]\n \n [55982]: https://github.com/rust-lang/rust/pull/55982/\n+[56243]: https://github.com/rust-lang/rust/pull/56243\n [56303]: https://github.com/rust-lang/rust/pull/56303/\n [56351]: https://github.com/rust-lang/rust/pull/56351/\n [56362]: https://github.com/rust-lang/rust/pull/56362\n@@ -132,6 +619,7 @@ Compatibility Notes\n [57535]: https://github.com/rust-lang/rust/pull/57535/\n [57566]: https://github.com/rust-lang/rust/pull/57566/\n [57615]: https://github.com/rust-lang/rust/pull/57615/\n+[cargo/6453]: https://github.com/rust-lang/cargo/pull/6453/\n [cargo/6484]: https://github.com/rust-lang/cargo/pull/6484/\n [`unix::FileExt::read_exact_at`]: https://doc.rust-lang.org/std/os/unix/fs/trait.FileExt.html#method.read_exact_at\n [`unix::FileExt::write_all_at`]: https://doc.rust-lang.org/std/os/unix/fs/trait.FileExt.html#method.write_all_at\n@@ -482,7 +970,7 @@ Compiler\n \n Libraries\n ---------\n-- [You can now convert `num::NonZero*` types to their raw equivalvents using the\n+- [You can now convert `num::NonZero*` types to their raw equivalents using the\n   `From` trait.][54240] E.g. `u8` now implements `From<NonZeroU8>`.\n - [You can now convert a `&Option<T>` into `Option<&T>` and `&mut Option<T>`\n   into `Option<&mut T>` using the `From` trait.][53218]\n@@ -675,7 +1163,7 @@ Security Notes\n   caused by an integer overflow. This has been fixed by deterministically\n   panicking when an overflow happens.\n \n-  Thank you to Scott McMurray for responsibily disclosing this vulnerability to\n+  Thank you to Scott McMurray for responsibly disclosing this vulnerability to\n   us.\n \n \n@@ -947,7 +1435,7 @@ Security Notes\n   given machine. This release fixes that vulnerability; you can read\n   more about this on the [blog][rustdoc-sec]. The associated CVE is [CVE-2018-1000622].\n \n-  Thank you to Red Hat for responsibily disclosing this vulnerability to us.\n+  Thank you to Red Hat for responsibly disclosing this vulnerability to us.\n \n Compatibility Notes\n -------------------"}, {"sha": "d70ad54b1c812ee6ef9b293cbfa9f434f4fb882b", "filename": "appveyor.yml", "status": "removed", "additions": 0, "deletions": 262, "changes": 262, "blob_url": "https://github.com/rust-lang/rust/blob/33445aea509cadcd715009c79795d289268daa7c/appveyor.yml", "raw_url": "https://github.com/rust-lang/rust/raw/33445aea509cadcd715009c79795d289268daa7c/appveyor.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/appveyor.yml?ref=33445aea509cadcd715009c79795d289268daa7c", "patch": "@@ -1,262 +0,0 @@\n-environment:\n-\n-  # By default schannel checks revocation of certificates unlike some other SSL\n-  # backends, but we've historically had problems on CI where a revocation\n-  # server goes down presumably. See #43333 for more info\n-  CARGO_HTTP_CHECK_REVOKE: false\n-\n-  matrix:\n-  # 32/64 bit MSVC tests\n-  - MSYS_BITS: 64\n-    RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc --enable-profiler\n-    SCRIPT: python x.py test\n-    CI_JOB_NAME: x86_64-msvc\n-  - MSYS_BITS: 32\n-    RUST_CONFIGURE_ARGS: --build=i686-pc-windows-msvc\n-    SCRIPT: make appveyor-subset-1\n-    CI_JOB_NAME: i686-msvc-1\n-  - MSYS_BITS: 32\n-    RUST_CONFIGURE_ARGS: --build=i686-pc-windows-msvc\n-    SCRIPT: make appveyor-subset-2\n-    CI_JOB_NAME: i686-msvc-2\n-\n-  # MSVC aux tests\n-  - MSYS_BITS: 64\n-    RUST_CHECK_TARGET: check-aux EXCLUDE_CARGO=1\n-    RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc\n-    CI_JOB_NAME: x86_64-msvc-aux\n-  - MSYS_BITS: 64\n-    SCRIPT: python x.py test src/tools/cargotest src/tools/cargo\n-    RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc\n-    CI_JOB_NAME: x86_64-msvc-cargo\n-\n-  # MSVC tools tests\n-  - MSYS_BITS: 64\n-    SCRIPT: src/ci/docker/x86_64-gnu-tools/checktools.sh x.py /tmp/toolstates.json windows\n-    RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc --save-toolstates=/tmp/toolstates.json --enable-test-miri\n-    CI_JOB_NAME: x86_64-msvc-tools\n-\n-  # 32/64-bit MinGW builds.\n-  #\n-  # We are using MinGW with posix threads since LLVM does not compile with\n-  # the win32 threads version due to missing support for C++'s std::thread.\n-  #\n-  # Instead of relying on the MinGW version installed on appveryor we download\n-  # and install one ourselves so we won't be surprised by changes to appveyor's\n-  # build image.\n-  #\n-  # Finally, note that the downloads below are all in the `rust-lang-ci` S3\n-  # bucket, but they cleraly didn't originate there! The downloads originally\n-  # came from the mingw-w64 SourceForge download site. Unfortunately\n-  # SourceForge is notoriously flaky, so we mirror it on our own infrastructure.\n-  - MSYS_BITS: 32\n-    RUST_CONFIGURE_ARGS: --build=i686-pc-windows-gnu\n-    SCRIPT: make appveyor-subset-1\n-    MINGW_URL: https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror\n-    MINGW_ARCHIVE: i686-6.3.0-release-posix-dwarf-rt_v5-rev2.7z\n-    MINGW_DIR: mingw32\n-    CI_JOB_NAME: i686-mingw-1\n-  - MSYS_BITS: 32\n-    RUST_CONFIGURE_ARGS: --build=i686-pc-windows-gnu\n-    SCRIPT: make appveyor-subset-2\n-    MINGW_URL: https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror\n-    MINGW_ARCHIVE: i686-6.3.0-release-posix-dwarf-rt_v5-rev2.7z\n-    MINGW_DIR: mingw32\n-    CI_JOB_NAME: i686-mingw-2\n-  - MSYS_BITS: 64\n-    SCRIPT: python x.py test\n-    RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-gnu\n-    MINGW_URL: https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror\n-    MINGW_ARCHIVE: x86_64-6.3.0-release-posix-seh-rt_v5-rev2.7z\n-    MINGW_DIR: mingw64\n-    CI_JOB_NAME: x86_64-mingw\n-\n-  # 32/64 bit MSVC and GNU deployment\n-  - RUST_CONFIGURE_ARGS: >\n-      --build=x86_64-pc-windows-msvc\n-      --target=x86_64-pc-windows-msvc,aarch64-pc-windows-msvc\n-      --enable-full-tools\n-      --enable-profiler\n-    SCRIPT: python x.py dist\n-    DIST_REQUIRE_ALL_TOOLS: 1\n-    DEPLOY: 1\n-    CI_JOB_NAME: dist-x86_64-msvc\n-    APPVEYOR_BUILD_WORKER_IMAGE: Visual Studio 2017 Preview\n-  - RUST_CONFIGURE_ARGS: >\n-      --build=i686-pc-windows-msvc\n-      --target=i586-pc-windows-msvc\n-      --enable-full-tools\n-      --enable-profiler\n-    SCRIPT: python x.py dist\n-    DIST_REQUIRE_ALL_TOOLS: 1\n-    DEPLOY: 1\n-    CI_JOB_NAME: dist-i686-msvc\n-  - MSYS_BITS: 32\n-    RUST_CONFIGURE_ARGS: --build=i686-pc-windows-gnu --enable-full-tools\n-    SCRIPT: python x.py dist\n-    MINGW_URL: https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror\n-    MINGW_ARCHIVE: i686-6.3.0-release-posix-dwarf-rt_v5-rev2.7z\n-    MINGW_DIR: mingw32\n-    DIST_REQUIRE_ALL_TOOLS: 1\n-    DEPLOY: 1\n-    CI_JOB_NAME: dist-i686-mingw\n-  - MSYS_BITS: 64\n-    SCRIPT: python x.py dist\n-    RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-gnu --enable-full-tools\n-    MINGW_URL: https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror\n-    MINGW_ARCHIVE: x86_64-6.3.0-release-posix-seh-rt_v5-rev2.7z\n-    MINGW_DIR: mingw64\n-    DIST_REQUIRE_ALL_TOOLS: 1\n-    DEPLOY: 1\n-    CI_JOB_NAME: dist-x86_64-mingw\n-\n-  # \"alternate\" deployment, see .travis.yml for more info\n-  - MSYS_BITS: 64\n-    RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc --enable-extended --enable-profiler\n-    SCRIPT: python x.py dist\n-    DEPLOY_ALT: 1\n-    CI_JOB_NAME: dist-x86_64-msvc-alt\n-\n-matrix:\n-  fast_finish: true\n-\n-clone_depth: 2\n-build: false\n-\n-install:\n-  # If we need to download a custom MinGW, do so here and set the path\n-  # appropriately.\n-  #\n-  # Note that this *also* means that we're not using what is typically\n-  # /mingw32/bin/python2.7.exe, which is a \"correct\" python interpreter where\n-  # /usr/bin/python2.7.exe is not. To ensure we use the right interpreter we\n-  # move `C:\\Python27` ahead in PATH and then also make sure the `python2.7.exe`\n-  # file exists in there (which it doesn't by default).\n-  - if defined MINGW_URL appveyor-retry appveyor DownloadFile %MINGW_URL%/%MINGW_ARCHIVE%\n-  - if defined MINGW_URL 7z x -y %MINGW_ARCHIVE% > nul\n-  - if defined MINGW_URL set PATH=%CD%\\%MINGW_DIR%\\bin;C:\\msys64\\usr\\bin;%PATH%\n-\n-  # If we're compiling for MSVC then we, like most other distribution builders,\n-  # switch to clang as the compiler. This'll allow us eventually to enable LTO\n-  # amongst LLVM and rustc. Note that we only do this on MSVC as I don't think\n-  # clang has an output mode compatible with MinGW that we need. If it does we\n-  # should switch to clang for MinGW as well!\n-  #\n-  # Note that the LLVM installer is an NSIS installer\n-  #\n-  # Original downloaded here came from\n-  # http://releases.llvm.org/7.0.0/LLVM-7.0.0-win64.exe\n-  - if NOT defined MINGW_URL appveyor-retry appveyor DownloadFile https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror/LLVM-7.0.0-win64.exe\n-  - if NOT defined MINGW_URL .\\LLVM-7.0.0-win64.exe /S /NCRC /D=C:\\clang-rust\n-  - if NOT defined MINGW_URL set RUST_CONFIGURE_ARGS=%RUST_CONFIGURE_ARGS% --set llvm.clang-cl=C:\\clang-rust\\bin\\clang-cl.exe\n-\n-  # Here we do a pretty heinous thing which is to mangle the MinGW installation\n-  # we just had above. Currently, as of this writing, we're using MinGW-w64\n-  # builds of gcc, and that's currently at 6.3.0. We use 6.3.0 as it appears to\n-  # be the first version which contains a fix for #40546, builds randomly\n-  # failing during LLVM due to ar.exe/ranlib.exe failures.\n-  #\n-  # Unfortunately, though, 6.3.0 *also* is the first version of MinGW-w64 builds\n-  # to contain a regression in gdb (#40184). As a result if we were to use the\n-  # gdb provided (7.11.1) then we would fail all debuginfo tests.\n-  #\n-  # In order to fix spurious failures (pretty high priority) we use 6.3.0. To\n-  # avoid disabling gdb tests we download an *old* version of gdb, specifically\n-  # that found inside the 6.2.0 distribution. We then overwrite the 6.3.0 gdb\n-  # with the 6.2.0 gdb to get tests passing.\n-  #\n-  # Note that we don't literally overwrite the gdb.exe binary because it appears\n-  # to just use gdborig.exe, so that's the binary we deal with instead.\n-  - if defined MINGW_URL appveyor-retry appveyor DownloadFile %MINGW_URL%/2017-04-20-%MSYS_BITS%bit-gdborig.exe\n-  - if defined MINGW_URL mv 2017-04-20-%MSYS_BITS%bit-gdborig.exe %MINGW_DIR%\\bin\\gdborig.exe\n-\n-  # Otherwise pull in the MinGW installed on appveyor\n-  - if NOT defined MINGW_URL set PATH=C:\\msys64\\mingw%MSYS_BITS%\\bin;C:\\msys64\\usr\\bin;%PATH%\n-\n-  # Prefer the \"native\" Python as LLVM has trouble building with MSYS sometimes\n-  - copy C:\\Python27\\python.exe C:\\Python27\\python2.7.exe\n-  - set PATH=C:\\Python27;%PATH%\n-\n-  # Download and install sccache\n-  - appveyor-retry appveyor DownloadFile https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror/2018-04-26-sccache-x86_64-pc-windows-msvc\n-  - mv 2018-04-26-sccache-x86_64-pc-windows-msvc sccache.exe\n-  - set PATH=%PATH%;%CD%\n-\n-  # Download and install ninja\n-  #\n-  # Note that this is originally from the github releases patch of Ninja\n-  - appveyor-retry appveyor DownloadFile https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror/2017-03-15-ninja-win.zip\n-  - 7z x 2017-03-15-ninja-win.zip\n-  - set RUST_CONFIGURE_ARGS=%RUST_CONFIGURE_ARGS% --enable-ninja\n-  # - set PATH=%PATH%;%CD% -- this already happens above for sccache\n-\n-  # Install InnoSetup to get `iscc` used to produce installers\n-  - appveyor-retry appveyor DownloadFile https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror/2017-08-22-is.exe\n-  - 2017-08-22-is.exe /VERYSILENT /SUPPRESSMSGBOXES /NORESTART /SP-\n-  - set PATH=\"C:\\Program Files (x86)\\Inno Setup 5\";%PATH%\n-\n-  # Help debug some handle issues on AppVeyor\n-  - appveyor-retry appveyor DownloadFile https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror/2017-05-15-Handle.zip\n-  - mkdir handle\n-  - 7z x -ohandle 2017-05-15-Handle.zip\n-  - set PATH=%PATH%;%CD%\\handle\n-  - handle.exe -accepteula -help\n-\n-test_script:\n-  - if not exist C:\\cache\\rustsrc\\NUL mkdir C:\\cache\\rustsrc\n-  - sh src/ci/init_repo.sh . /c/cache/rustsrc\n-  - set SRC=.\n-  - set NO_CCACHE=1\n-  - sh src/ci/run.sh\n-\n-on_failure:\n-  # Dump crash log\n-  - set PATH=%PATH%;\"C:\\Program Files (x86)\\Windows Kits\\10\\Debuggers\\X64\"\n-  - if exist %LOCALAPPDATA%\\CrashDumps for %%f in (%LOCALAPPDATA%\\CrashDumps\\*) do cdb -c \"k;q\" -G -z \"%%f\"\n-\n-branches:\n-  only:\n-    - auto\n-\n-before_deploy:\n-  - ps: |\n-        New-Item -Path deploy -ItemType directory\n-        Remove-Item -Recurse -Force build\\dist\\doc\n-        Get-ChildItem -Path build\\dist | Move-Item -Destination deploy\n-        Get-ChildItem -Path deploy | Foreach-Object {\n-          Push-AppveyorArtifact $_.FullName -FileName ${env:APPVEYOR_REPO_COMMIT}/$_\n-        }\n-\n-deploy:\n-  - provider: S3\n-    access_key_id: $(AWS_ACCESS_KEY_ID)\n-    secret_access_key: $(AWS_SECRET_ACCESS_KEY)\n-    bucket: rust-lang-ci2\n-    set_public: true\n-    region: us-west-1\n-    artifact: /.*/\n-    folder: rustc-builds\n-    on:\n-      branch: auto\n-      DEPLOY: 1\n-    max_error_retry: 5\n-\n-  # This provider is the same as the one above except that it has a slightly\n-  # different upload directory and a slightly different trigger\n-  - provider: S3\n-    access_key_id: $(AWS_ACCESS_KEY_ID)\n-    secret_access_key: $(AWS_SECRET_ACCESS_KEY)\n-    bucket: rust-lang-ci2\n-    set_public: true\n-    region: us-west-1\n-    artifact: /.*/\n-    folder: rustc-builds-alt\n-    on:\n-      branch: auto\n-      DEPLOY_ALT: 1\n-    max_error_retry: 5\n-\n-# init:\n-#   - ps: iex ((new-object net.webclient).DownloadString('https://raw.githubusercontent.com/appveyor/ci/master/scripts/enable-rdp.ps1'))\n-# on_finish:\n-#   - ps: $blockRdp = $true; iex ((new-object net.webclient).DownloadString('https://raw.githubusercontent.com/appveyor/ci/master/scripts/enable-rdp.ps1'))"}, {"sha": "cb9f388a8e47b22d28663ce8507a3c62d254e5ad", "filename": "config.toml.example", "status": "modified", "additions": 28, "deletions": 26, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/config.toml.example", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/config.toml.example", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/config.toml.example?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -14,10 +14,6 @@\n # =============================================================================\n [llvm]\n \n-# Indicates whether rustc will support compilation with LLVM\n-# note: rustc does not compile without LLVM at the moment\n-#enabled = true\n-\n # Indicates whether the LLVM build is a Release or Debug build\n #optimize = true\n \n@@ -61,14 +57,13 @@\n # support. You'll need to write a target specification at least, and most\n # likely, teach rustc about the C ABI of the target. Get in touch with the\n # Rust team and file an issue if you need assistance in porting!\n-#targets = \"X86;ARM;AArch64;Mips;PowerPC;SystemZ;MSP430;Sparc;NVPTX;Hexagon\"\n+#targets = \"AArch64;ARM;Hexagon;MSP430;Mips;NVPTX;PowerPC;RISCV;Sparc;SystemZ;WebAssembly;X86\"\n \n # LLVM experimental targets to build support for. These targets are specified in\n # the same format as above, but since these targets are experimental, they are\n # not built by default and the experimental Rust compilation targets that depend\n-# on them will not work unless the user opts in to building them. By default the\n-# `WebAssembly` and `RISCV` targets are enabled when compiling LLVM from scratch.\n-#experimental-targets = \"WebAssembly;RISCV\"\n+# on them will not work unless the user opts in to building them.\n+#experimental-targets = \"\"\n \n # Cap the number of parallel linker invocations when compiling LLVM.\n # This can be useful when building LLVM with debug info, which significantly\n@@ -305,20 +300,27 @@\n # library.\n #debug-assertions = false\n \n-# Whether or not debuginfo is emitted\n-#debuginfo = false\n+# Debuginfo level for most of Rust code, corresponds to the `-C debuginfo=N` option of `rustc`.\n+# `0` - no debug info\n+# `1` - line tables only\n+# `2` - full debug info with variable and type information\n+# Can be overriden for specific subsets of Rust code (rustc, std or tools).\n+# Debuginfo for tests run with compiletest is not controlled by this option\n+# and needs to be enabled separately with `debuginfo-level-tests`.\n+#debuginfo-level = if debug { 2 } else { 0 }\n+\n+# Debuginfo level for the compiler.\n+#debuginfo-level-rustc = debuginfo-level\n \n-# Whether or not line number debug information is emitted\n-#debuginfo-lines = false\n+# Debuginfo level for the standard library.\n+#debuginfo-level-std = debuginfo-level\n \n-# Whether or not to only build debuginfo for the standard library if enabled.\n-# If enabled, this will not compile the compiler with debuginfo, just the\n-# standard library.\n-#debuginfo-only-std = false\n+# Debuginfo level for the tools.\n+#debuginfo-level-tools = debuginfo-level\n \n-# Enable debuginfo for the extended tools: cargo, rls, rustfmt\n-# Adding debuginfo makes them several times larger.\n-#debuginfo-tools = false\n+# Debuginfo level for the test suites run with compiletest.\n+# FIXME(#61117): Some tests fail when this option is enabled.\n+#debuginfo-level-tests = 0\n \n # Whether or not `panic!`s generate backtraces (RUST_BACKTRACE)\n #backtrace = true\n@@ -349,10 +351,8 @@\n # harness are debuggable just from logfiles.\n #verbose-tests = false\n \n-# Flag indicating whether tests are compiled with optimizations (the -O flag) or\n-# with debuginfo (the -g flag)\n+# Flag indicating whether tests are compiled with optimizations (the -O flag).\n #optimize-tests = true\n-#debuginfo-tests = true\n \n # Flag indicating whether codegen tests will be run or not. If you get an error\n # saying that the FileCheck executable is missing, you may want to disable this.\n@@ -368,10 +368,6 @@\n # When creating source tarballs whether or not to create a source tarball.\n #dist-src = false\n \n-# Whether to also run the Miri tests suite when running tests.\n-# As a side-effect also generates MIR for all libraries.\n-#test-miri = false\n-\n # After building or testing extended tools (e.g. clippy and rustfmt), append the\n # result (broken, compiling, testing) into this JSON file.\n #save-toolstates = \"/path/to/toolstates.json\"\n@@ -425,6 +421,9 @@\n # development of NLL\n #test-compare-mode = false\n \n+# Use LLVM libunwind as the implementation for Rust's unwinder.\n+#llvm-libunwind = false\n+\n # =============================================================================\n # Options for specific targets\n #\n@@ -481,6 +480,9 @@\n # linked binaries\n #musl-root = \"...\"\n \n+# The root location of the `wasm32-wasi` sysroot.\n+#wasi-root = \"...\"\n+\n # Used in testing for configuring where the QEMU images are located, you\n # probably don't want to use this.\n #qemu-rootfs = \"...\""}, {"sha": "df230cde9b7130a94e69f4e15f2cdd4d40bf5430", "filename": "rustfmt.toml", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/rustfmt.toml", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/rustfmt.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rustfmt.toml?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -0,0 +1,6 @@\n+# Currently, most of the code in the compiler uses historical style.\n+#\n+# For new code, consider running rustfmt with this config (it should\n+# be picked up automatically).\n+version = \"Two\"\n+use_small_heuristics = \"Max\""}, {"sha": "f1b36f5858037b7f12fadf37c070c68ff886af21", "filename": "src/.gitignore", "status": "removed", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/33445aea509cadcd715009c79795d289268daa7c/src%2F.gitignore", "raw_url": "https://github.com/rust-lang/rust/raw/33445aea509cadcd715009c79795d289268daa7c/src%2F.gitignore", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2F.gitignore?ref=33445aea509cadcd715009c79795d289268daa7c", "patch": "@@ -1,46 +0,0 @@\n-*.a\n-*.aux\n-*.bc\n-*.boot\n-*.bz2\n-*.cmi\n-*.cmo\n-*.cmx\n-*.cp\n-*.cps\n-*.d\n-*.dSYM\n-*.def\n-*.diff\n-*.dll\n-*.dylib\n-*.elc\n-*.epub\n-*.exe\n-*.fn\n-*.html\n-*.kdev4\n-*.ky\n-*.ll\n-*.llvm\n-*.log\n-*.o\n-*.orig\n-*.out\n-*.patch\n-*.pdb\n-*.pdf\n-*.pg\n-*.pot\n-*.pyc\n-*.rej\n-*.rlib\n-*.rustc\n-*.so\n-*.swo\n-*.swp\n-*.tmp\n-*.toc\n-*.tp\n-*.vr\n-*.x86"}, {"sha": "32ca4a105741b9f09754a40d2da21f5095fb056f", "filename": "src/README.md", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2FREADME.md?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -5,10 +5,7 @@ This directory contains the source code of the rust project, including:\n \n For more information on how various parts of the compiler work, see the [rustc guide].\n \n-There is also useful content in the following READMEs, which are gradually being moved over to the guide:\n-- https://github.com/rust-lang/rust/tree/master/src/librustc/ty/query\n-- https://github.com/rust-lang/rust/tree/master/src/librustc/dep_graph\n-- https://github.com/rust-lang/rust/tree/master/src/librustc/infer/higher_ranked\n-- https://github.com/rust-lang/rust/tree/master/src/librustc/infer/lexical_region_resolve\n+There is also useful content in this README:\n+https://github.com/rust-lang/rust/tree/master/src/librustc/infer/lexical_region_resolve.\n \n [rustc guide]: https://rust-lang.github.io/rustc-guide/about-this-guide.html"}, {"sha": "589ee9276a5a3be6a406e19d495bfa1de7b5e4b9", "filename": "src/bootstrap/Cargo.toml", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fbootstrap%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fbootstrap%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FCargo.toml?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -36,17 +36,16 @@ test = false\n \n [dependencies]\n build_helper = { path = \"../build_helper\" }\n-cmake = \"0.1.23\"\n+cmake = \"0.1.38\"\n filetime = \"0.2\"\n num_cpus = \"1.0\"\n-getopts = \"0.2\"\n-cc = \"1.0.1\"\n+getopts = \"0.2.19\"\n+cc = \"1.0.35\"\n libc = \"0.2\"\n-serde = \"1.0.8\"\n-serde_derive = \"1.0.8\"\n+serde = { version = \"1.0.8\", features = [\"derive\"] }\n serde_json = \"1.0.2\"\n toml = \"0.4\"\n-lazy_static = \"0.2\"\n+lazy_static = \"1.3.0\"\n time = \"0.1\"\n petgraph = \"0.4.13\"\n "}, {"sha": "3e877fc4e317c9e0affbea0b3f58b685d0b4bf06", "filename": "src/bootstrap/README.md", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fbootstrap%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fbootstrap%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2FREADME.md?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -55,11 +55,11 @@ The script accepts commands, flags, and arguments to determine what to do:\n   # run all unit tests\n   ./x.py test\n \n-  # execute the run-pass test suite\n-  ./x.py test src/test/run-pass\n+  # execute the UI test suite\n+  ./x.py test src/test/ui\n \n-  # execute only some tests in the run-pass test suite\n-  ./x.py test src/test/run-pass --test-args substring-of-test-name\n+  # execute only some tests in the UI test suite\n+  ./x.py test src/test/ui --test-args substring-of-test-name\n \n   # execute tests in the standard library in stage0\n   ./x.py test --stage 0 src/libstd\n@@ -215,7 +215,7 @@ build/\n \n     # Output for all compiletest-based test suites\n     test/\n-      run-pass/\n+      ui/\n       compile-fail/\n       debuginfo/\n       ..."}, {"sha": "bd1a87c5744d39d8c1a552a0925ff18a53b627d8", "filename": "src/bootstrap/bin/main.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fbootstrap%2Fbin%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fbootstrap%2Fbin%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Fmain.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -5,7 +5,8 @@\n //! parent directory, and otherwise documentation can be found throughout the `build`\n //! directory in each respective module.\n \n-#![deny(warnings)]\n+// NO-RUSTC-WRAPPER\n+#![deny(warnings, rust_2018_idioms, unused_lifetimes)]\n \n use std::env;\n "}, {"sha": "54b689fb062a53ee9a02a8d3b26cf37a72e277f5", "filename": "src/bootstrap/bin/rustc.rs", "status": "modified", "additions": 69, "deletions": 43, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fbootstrap%2Fbin%2Frustc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fbootstrap%2Fbin%2Frustc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustc.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -15,7 +15,8 @@\n //! switching compilers for the bootstrap and for build scripts will probably\n //! never get replaced.\n \n-#![deny(warnings)]\n+// NO-RUSTC-WRAPPER\n+#![deny(warnings, rust_2018_idioms, unused_lifetimes)]\n \n use std::env;\n use std::ffi::OsString;\n@@ -89,11 +90,29 @@ fn main() {\n \n     let mut cmd = Command::new(rustc);\n     cmd.args(&args)\n-        .arg(\"--cfg\")\n-        .arg(format!(\"stage{}\", stage))\n         .env(bootstrap::util::dylib_path_var(),\n              env::join_paths(&dylib_path).unwrap());\n-    let mut maybe_crate = None;\n+\n+    // Get the name of the crate we're compiling, if any.\n+    let crate_name = args.windows(2)\n+        .find(|args| args[0] == \"--crate-name\")\n+        .and_then(|args| args[1].to_str());\n+\n+    if let Some(crate_name) = crate_name {\n+        if let Some(target) = env::var_os(\"RUSTC_TIME\") {\n+            if target == \"all\" ||\n+               target.into_string().unwrap().split(\",\").any(|c| c.trim() == crate_name)\n+            {\n+                cmd.arg(\"-Ztime\");\n+            }\n+        }\n+    }\n+\n+    // Non-zero stages must all be treated uniformly to avoid problems when attempting to uplift\n+    // compiler libraries and such from stage 1 to 2.\n+    if stage == \"0\" {\n+        cmd.arg(\"--cfg\").arg(\"bootstrap\");\n+    }\n \n     // Print backtrace in case of ICE\n     if env::var(\"RUSTC_BACKTRACE_ON_ICE\").is_ok() && env::var(\"RUST_BACKTRACE\").is_err() {\n@@ -102,10 +121,33 @@ fn main() {\n \n     cmd.env(\"RUSTC_BREAK_ON_ICE\", \"1\");\n \n+    if let Ok(debuginfo_level) = env::var(\"RUSTC_DEBUGINFO_LEVEL\") {\n+        cmd.arg(format!(\"-Cdebuginfo={}\", debuginfo_level));\n+    }\n+\n+    if env::var_os(\"RUSTC_DENY_WARNINGS\").is_some() &&\n+       env::var_os(\"RUSTC_EXTERNAL_TOOL\").is_none() {\n+        // When extending this list, search for `NO-RUSTC-WRAPPER` and add the new lints\n+        // there as well, some code doesn't go through this `rustc` wrapper.\n+        cmd.arg(\"-Dwarnings\");\n+        cmd.arg(\"-Drust_2018_idioms\");\n+        cmd.arg(\"-Dunused_lifetimes\");\n+        // cfg(not(bootstrap)): Remove this during the next stage 0 compiler update.\n+        // `-Drustc::internal` is a new feature and `rustc_version` mis-reports the `stage`.\n+        let cfg_not_bootstrap = stage != \"0\" && crate_name != Some(\"rustc_version\");\n+        if cfg_not_bootstrap && use_internal_lints(crate_name) {\n+            cmd.arg(\"-Zunstable-options\");\n+            cmd.arg(\"-Drustc::internal\");\n+        }\n+    }\n+\n     if let Some(target) = target {\n         // The stage0 compiler has a special sysroot distinct from what we\n-        // actually downloaded, so we just always pass the `--sysroot` option.\n-        cmd.arg(\"--sysroot\").arg(&sysroot);\n+        // actually downloaded, so we just always pass the `--sysroot` option,\n+        // unless one is already set.\n+        if !args.iter().any(|arg| arg == \"--sysroot\") {\n+            cmd.arg(\"--sysroot\").arg(&sysroot);\n+        }\n \n         cmd.arg(\"-Zexternal-macro-backtrace\");\n \n@@ -122,8 +164,8 @@ fn main() {\n             cmd.arg(\"-Cprefer-dynamic\");\n         }\n \n-        // Help the libc crate compile by assisting it in finding the MUSL\n-        // native libraries.\n+        // Help the libc crate compile by assisting it in finding various\n+        // sysroot native libraries.\n         if let Some(s) = env::var_os(\"MUSL_ROOT\") {\n             if target.contains(\"musl\") {\n                 let mut root = OsString::from(\"native=\");\n@@ -132,18 +174,18 @@ fn main() {\n                 cmd.arg(\"-L\").arg(&root);\n             }\n         }\n+        if let Some(s) = env::var_os(\"WASI_ROOT\") {\n+            let mut root = OsString::from(\"native=\");\n+            root.push(&s);\n+            root.push(\"/lib/wasm32-wasi\");\n+            cmd.arg(\"-L\").arg(&root);\n+        }\n \n         // Override linker if necessary.\n         if let Ok(target_linker) = env::var(\"RUSTC_TARGET_LINKER\") {\n             cmd.arg(format!(\"-Clinker={}\", target_linker));\n         }\n \n-        let crate_name = args.windows(2)\n-            .find(|a| &*a[0] == \"--crate-name\")\n-            .unwrap();\n-        let crate_name = &*crate_name[1];\n-        maybe_crate = Some(crate_name);\n-\n         // If we're compiling specifically the `panic_abort` crate then we pass\n         // the `-C panic=abort` option. Note that we do not do this for any\n         // other crate intentionally as this is the only crate for now that we\n@@ -156,26 +198,21 @@ fn main() {\n         // `compiler_builtins` are unconditionally compiled with panic=abort to\n         // workaround undefined references to `rust_eh_unwind_resume` generated\n         // otherwise, see issue https://github.com/rust-lang/rust/issues/43095.\n-        if crate_name == \"panic_abort\" ||\n-           crate_name == \"compiler_builtins\" && stage != \"0\" {\n+        if crate_name == Some(\"panic_abort\") ||\n+           crate_name == Some(\"compiler_builtins\") && stage != \"0\" {\n             cmd.arg(\"-C\").arg(\"panic=abort\");\n         }\n \n         // Set various options from config.toml to configure how we're building\n         // code.\n-        if env::var(\"RUSTC_DEBUGINFO\") == Ok(\"true\".to_string()) {\n-            cmd.arg(\"-g\");\n-        } else if env::var(\"RUSTC_DEBUGINFO_LINES\") == Ok(\"true\".to_string()) {\n-            cmd.arg(\"-Cdebuginfo=1\");\n-        }\n         let debug_assertions = match env::var(\"RUSTC_DEBUG_ASSERTIONS\") {\n             Ok(s) => if s == \"true\" { \"y\" } else { \"n\" },\n             Err(..) => \"n\",\n         };\n \n         // The compiler builtins are pretty sensitive to symbols referenced in\n         // libcore and such, so we never compile them with debug assertions.\n-        if crate_name == \"compiler_builtins\" {\n+        if crate_name == Some(\"compiler_builtins\") {\n             cmd.arg(\"-C\").arg(\"debug-assertions=no\");\n         } else {\n             cmd.arg(\"-C\").arg(format!(\"debug-assertions={}\", debug_assertions));\n@@ -251,19 +288,6 @@ fn main() {\n             }\n         }\n \n-        // When running miri tests, we need to generate MIR for all libraries\n-        if env::var(\"TEST_MIRI\").ok().map_or(false, |val| val == \"true\") {\n-            // The flags here should be kept in sync with `add_miri_default_args`\n-            // in miri's `src/lib.rs`.\n-            cmd.arg(\"-Zalways-encode-mir\");\n-            // These options are preferred by miri, to be able to perform better validation,\n-            // but the bootstrap compiler might not understand them.\n-            if stage != \"0\" {\n-                cmd.arg(\"-Zmir-emit-retag\");\n-                cmd.arg(\"-Zmir-opt-level=0\");\n-            }\n-        }\n-\n         if let Ok(map) = env::var(\"RUSTC_DEBUGINFO_MAP\") {\n             cmd.arg(\"--remap-path-prefix\").arg(&map);\n         }\n@@ -295,12 +319,6 @@ fn main() {\n         cmd.arg(\"--cfg\").arg(\"parallel_compiler\");\n     }\n \n-    if env::var_os(\"RUSTC_DENY_WARNINGS\").is_some() && env::var_os(\"RUSTC_EXTERNAL_TOOL\").is_none()\n-    {\n-        cmd.arg(\"-Dwarnings\");\n-        cmd.arg(\"-Dbare_trait_objects\");\n-    }\n-\n     if verbose > 1 {\n         eprintln!(\n             \"rustc command: {:?}={:?} {:?}\",\n@@ -323,7 +341,7 @@ fn main() {\n     }\n \n     if env::var_os(\"RUSTC_PRINT_STEP_TIMINGS\").is_some() {\n-        if let Some(krate) = maybe_crate {\n+        if let Some(crate_name) = crate_name {\n             let start = Instant::now();\n             let status = cmd\n                 .status()\n@@ -332,7 +350,7 @@ fn main() {\n \n             let is_test = args.iter().any(|a| a == \"--test\");\n             eprintln!(\"[RUSTC-TIMING] {} test:{} {}.{:03}\",\n-                      krate.to_string_lossy(),\n+                      crate_name,\n                       is_test,\n                       dur.as_secs(),\n                       dur.subsec_nanos() / 1_000_000);\n@@ -351,6 +369,14 @@ fn main() {\n     std::process::exit(code);\n }\n \n+// Rustc crates for which internal lints are in effect.\n+fn use_internal_lints(crate_name: Option<&str>) -> bool {\n+    crate_name.map_or(false, |crate_name| {\n+        crate_name.starts_with(\"rustc\") || crate_name.starts_with(\"syntax\") ||\n+        [\"arena\", \"fmt_macros\"].contains(&crate_name)\n+    })\n+}\n+\n #[cfg(unix)]\n fn exec_cmd(cmd: &mut Command) -> io::Result<i32> {\n     use std::os::unix::process::CommandExt;"}, {"sha": "ff38ee8788f5652c2c551ff3db1a120a89a27c2c", "filename": "src/bootstrap/bin/rustdoc.rs", "status": "modified", "additions": 21, "deletions": 3, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fbootstrap%2Fbin%2Frustdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fbootstrap%2Fbin%2Frustdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbin%2Frustdoc.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -2,7 +2,8 @@\n //!\n //! See comments in `src/bootstrap/rustc.rs` for more information.\n \n-#![deny(warnings)]\n+// NO-RUSTC-WRAPPER\n+#![deny(warnings, rust_2018_idioms, unused_lifetimes)]\n \n use std::env;\n use std::process::Command;\n@@ -35,7 +36,7 @@ fn main() {\n         .arg(\"--cfg\")\n         .arg(\"dox\")\n         .arg(\"--sysroot\")\n-        .arg(sysroot)\n+        .arg(&sysroot)\n         .env(bootstrap::util::dylib_path_var(),\n              env::join_paths(&dylib_path).unwrap());\n \n@@ -69,10 +70,27 @@ fn main() {\n                .arg(\"unstable-options\");\n         }\n         cmd.arg(\"--generate-redirect-pages\");\n+        has_unstable = true;\n+    }\n+\n+    // Needed to be able to run all rustdoc tests.\n+    if let Some(ref x) = env::var_os(\"RUSTDOC_RESOURCE_SUFFIX\") {\n+        // This \"unstable-options\" can be removed when `--resource-suffix` is stabilized\n+        if !has_unstable {\n+            cmd.arg(\"-Z\")\n+               .arg(\"unstable-options\");\n+        }\n+        cmd.arg(\"--resource-suffix\").arg(x);\n     }\n \n     if verbose > 1 {\n-        eprintln!(\"rustdoc command: {:?}\", cmd);\n+        eprintln!(\n+            \"rustdoc command: {:?}={:?} {:?}\",\n+            bootstrap::util::dylib_path_var(),\n+            env::join_paths(&dylib_path).unwrap(),\n+            cmd,\n+        );\n+        eprintln!(\"sysroot: {:?}\", sysroot);\n         eprintln!(\"libdir: {:?}\", libdir);\n     }\n "}, {"sha": "86901792d79740f1467f53baeb4862f598aad9e3", "filename": "src/bootstrap/bootstrap.py", "status": "modified", "additions": 52, "deletions": 28, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fbootstrap%2Fbootstrap.py", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fbootstrap%2Fbootstrap.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbootstrap.py?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -177,7 +177,6 @@ def default_build_triple():\n     # The goal here is to come up with the same triple as LLVM would,\n     # at least for the subset of platforms we're willing to target.\n     ostype_mapper = {\n-        'Bitrig': 'unknown-bitrig',\n         'Darwin': 'apple-darwin',\n         'DragonFly': 'unknown-dragonfly',\n         'FreeBSD': 'unknown-freebsd',\n@@ -677,9 +676,15 @@ def update_submodule(self, module, checked_out, recorded_submodules):\n \n         run([\"git\", \"submodule\", \"-q\", \"sync\", module],\n             cwd=self.rust_root, verbose=self.verbose)\n-        run([\"git\", \"submodule\", \"update\",\n-            \"--init\", \"--recursive\", \"--progress\", module],\n-            cwd=self.rust_root, verbose=self.verbose)\n+        try:\n+            run([\"git\", \"submodule\", \"update\",\n+                 \"--init\", \"--recursive\", \"--progress\", module],\n+                cwd=self.rust_root, verbose=self.verbose, exception=True)\n+        except RuntimeError:\n+            # Some versions of git don't support --progress.\n+            run([\"git\", \"submodule\", \"update\",\n+                 \"--init\", \"--recursive\", module],\n+                cwd=self.rust_root, verbose=self.verbose)\n         run([\"git\", \"reset\", \"-q\", \"--hard\"],\n             cwd=module_path, verbose=self.verbose)\n         run([\"git\", \"clean\", \"-qdfx\"],\n@@ -730,6 +735,47 @@ def set_dev_environment(self):\n         \"\"\"Set download URL for development environment\"\"\"\n         self._download_url = 'https://dev-static.rust-lang.org'\n \n+    def check_vendored_status(self):\n+        \"\"\"Check that vendoring is configured properly\"\"\"\n+        vendor_dir = os.path.join(self.rust_root, 'vendor')\n+        if 'SUDO_USER' in os.environ and not self.use_vendored_sources:\n+            if os.environ.get('USER') != os.environ['SUDO_USER']:\n+                self.use_vendored_sources = True\n+                print('info: looks like you are running this command under `sudo`')\n+                print('      and so in order to preserve your $HOME this will now')\n+                print('      use vendored sources by default.')\n+                if not os.path.exists(vendor_dir):\n+                    print('error: vendoring required, but vendor directory does not exist.')\n+                    print('       Run `cargo vendor` without sudo to initialize the '\n+                        'vendor directory.')\n+                    raise Exception(\"{} not found\".format(vendor_dir))\n+\n+        if self.use_vendored_sources:\n+            if not os.path.exists('.cargo'):\n+                os.makedirs('.cargo')\n+            with output('.cargo/config') as cargo_config:\n+                cargo_config.write(\n+                    \"[source.crates-io]\\n\"\n+                    \"replace-with = 'vendored-sources'\\n\"\n+                    \"registry = 'https://example.com'\\n\"\n+                    \"\\n\"\n+                    \"[source.vendored-sources]\\n\"\n+                    \"directory = '{}/vendor'\\n\"\n+                .format(self.rust_root))\n+        else:\n+            if os.path.exists('.cargo'):\n+                shutil.rmtree('.cargo')\n+\n+    def ensure_vendored(self):\n+        \"\"\"Ensure that the vendored sources are available if needed\"\"\"\n+        vendor_dir = os.path.join(self.rust_root, 'vendor')\n+        # Note that this does not handle updating the vendored dependencies if\n+        # the rust git repository is updated. Normal development usually does\n+        # not use vendoring, so hopefully this isn't too much of a problem.\n+        if self.use_vendored_sources and not os.path.exists(vendor_dir):\n+            run([self.cargo(), \"vendor\"],\n+                verbose=self.verbose, cwd=self.rust_root)\n+\n \n def bootstrap(help_triggered):\n     \"\"\"Configure, fetch, build and run the initial bootstrap\"\"\"\n@@ -771,30 +817,7 @@ def bootstrap(help_triggered):\n \n     build.use_locked_deps = '\\nlocked-deps = true' in build.config_toml\n \n-    if 'SUDO_USER' in os.environ and not build.use_vendored_sources:\n-        if os.environ.get('USER') != os.environ['SUDO_USER']:\n-            build.use_vendored_sources = True\n-            print('info: looks like you are running this command under `sudo`')\n-            print('      and so in order to preserve your $HOME this will now')\n-            print('      use vendored sources by default. Note that if this')\n-            print('      does not work you should run a normal build first')\n-            print('      before running a command like `sudo ./x.py install`')\n-\n-    if build.use_vendored_sources:\n-        if not os.path.exists('.cargo'):\n-            os.makedirs('.cargo')\n-        with output('.cargo/config') as cargo_config:\n-            cargo_config.write(\"\"\"\n-                [source.crates-io]\n-                replace-with = 'vendored-sources'\n-                registry = 'https://example.com'\n-\n-                [source.vendored-sources]\n-                directory = '{}/vendor'\n-            \"\"\".format(build.rust_root))\n-    else:\n-        if os.path.exists('.cargo'):\n-            shutil.rmtree('.cargo')\n+    build.check_vendored_status()\n \n     data = stage0_data(build.rust_root)\n     build.date = data['date']\n@@ -810,6 +833,7 @@ def bootstrap(help_triggered):\n     build.build = args.build or build.build_triple()\n     build.download_stage0()\n     sys.stdout.flush()\n+    build.ensure_vendored()\n     build.build_bootstrap()\n     sys.stdout.flush()\n "}, {"sha": "e54c9360baeceeac8163e0ec67db44a4f487ffa6", "filename": "src/bootstrap/builder.rs", "status": "modified", "additions": 111, "deletions": 710, "changes": 821, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fbootstrap%2Fbuilder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fbootstrap%2Fbuilder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -11,6 +11,8 @@ use std::path::{Path, PathBuf};\n use std::process::Command;\n use std::time::{Duration, Instant};\n \n+use build_helper::t;\n+\n use crate::cache::{Cache, Interned, INTERNER};\n use crate::check;\n use crate::compile;\n@@ -57,7 +59,7 @@ pub trait Step: 'static + Clone + Debug + PartialEq + Eq + Hash {\n \n     const DEFAULT: bool = false;\n \n-    /// Run this rule for all hosts without cross compiling.\n+    /// If true, then this rule should be skipped if --target was specified, but --host was not\n     const ONLY_HOSTS: bool = false;\n \n     /// Primary function to execute this rule. Can call `builder.ensure()`\n@@ -161,7 +163,7 @@ impl StepDescription {\n \n         // Determine the targets participating in this rule.\n         let targets = if self.only_hosts {\n-            if !builder.config.run_host_only {\n+            if builder.config.skip_only_host_steps {\n                 return; // don't run anything\n             } else {\n                 &builder.hosts\n@@ -316,6 +318,8 @@ impl<'a> ShouldRun<'a> {\n pub enum Kind {\n     Build,\n     Check,\n+    Clippy,\n+    Fix,\n     Test,\n     Bench,\n     Dist,\n@@ -357,7 +361,7 @@ impl<'a> Builder<'a> {\n                 tool::Miri,\n                 native::Lld\n             ),\n-            Kind::Check => describe!(\n+            Kind::Check | Kind::Clippy | Kind::Fix => describe!(\n                 check::Std,\n                 check::Test,\n                 check::Rustc,\n@@ -367,20 +371,18 @@ impl<'a> Builder<'a> {\n             Kind::Test => describe!(\n                 test::Tidy,\n                 test::Ui,\n-                test::RunPass,\n                 test::CompileFail,\n                 test::RunFail,\n                 test::RunPassValgrind,\n                 test::MirOpt,\n                 test::Codegen,\n                 test::CodegenUnits,\n+                test::Assembly,\n                 test::Incremental,\n                 test::Debuginfo,\n                 test::UiFullDeps,\n-                test::RunPassFullDeps,\n                 test::Rustdoc,\n                 test::Pretty,\n-                test::RunPassPretty,\n                 test::RunFailPretty,\n                 test::RunPassValgrindPretty,\n                 test::Crate,\n@@ -400,19 +402,21 @@ impl<'a> Builder<'a> {\n                 test::TheBook,\n                 test::UnstableBook,\n                 test::RustcBook,\n+                test::RustcGuide,\n                 test::EmbeddedBook,\n+                test::EditionGuide,\n                 test::Rustfmt,\n                 test::Miri,\n                 test::Clippy,\n                 test::CompiletestTest,\n                 test::RustdocJSStd,\n                 test::RustdocJSNotStd,\n                 test::RustdocTheme,\n+                test::RustdocUi,\n                 // Run bootstrap close to the end as it's unlikely to fail\n                 test::Bootstrap,\n                 // Run run-make last, since these won't pass without make on Windows\n                 test::RunMake,\n-                test::RustdocUi\n             ),\n             Kind::Bench => describe!(test::Crate, test::CrateLibrustc),\n             Kind::Doc => describe!(\n@@ -516,6 +520,8 @@ impl<'a> Builder<'a> {\n         let (kind, paths) = match build.config.cmd {\n             Subcommand::Build { ref paths } => (Kind::Build, &paths[..]),\n             Subcommand::Check { ref paths } => (Kind::Check, &paths[..]),\n+            Subcommand::Clippy { ref paths } => (Kind::Clippy, &paths[..]),\n+            Subcommand::Fix { ref paths } => (Kind::Fix, &paths[..]),\n             Subcommand::Doc { ref paths } => (Kind::Doc, &paths[..]),\n             Subcommand::Test { ref paths, .. } => (Kind::Test, &paths[..]),\n             Subcommand::Bench { ref paths, .. } => (Kind::Bench, &paths[..]),\n@@ -537,15 +543,6 @@ impl<'a> Builder<'a> {\n             parent: Cell::new(None),\n         };\n \n-        if kind == Kind::Dist {\n-            assert!(\n-                !builder.config.test_miri,\n-                \"Do not distribute with miri enabled.\\n\\\n-                The distributed libraries would include all MIR (increasing binary size).\n-                The distributed MIR would include validation statements.\"\n-            );\n-        }\n-\n         builder\n     }\n \n@@ -573,6 +570,30 @@ impl<'a> Builder<'a> {\n         })\n     }\n \n+    /// Similar to `compiler`, except handles the full-bootstrap option to\n+    /// silently use the stage1 compiler instead of a stage2 compiler if one is\n+    /// requested.\n+    ///\n+    /// Note that this does *not* have the side effect of creating\n+    /// `compiler(stage, host)`, unlike `compiler` above which does have such\n+    /// a side effect. The returned compiler here can only be used to compile\n+    /// new artifacts, it can't be used to rely on the presence of a particular\n+    /// sysroot.\n+    ///\n+    /// See `force_use_stage1` for documentation on what each argument is.\n+    pub fn compiler_for(\n+        &self,\n+        stage: u32,\n+        host: Interned<String>,\n+        target: Interned<String>,\n+    ) -> Compiler {\n+        if self.build.force_use_stage1(Compiler { stage, host }, target) {\n+            self.compiler(1, self.config.build)\n+        } else {\n+            self.compiler(stage, host)\n+        }\n+    }\n+\n     pub fn sysroot(&self, compiler: Compiler) -> Interned<PathBuf> {\n         self.ensure(compile::Sysroot { compiler })\n     }\n@@ -632,7 +653,28 @@ impl<'a> Builder<'a> {\n         if compiler.is_snapshot(self) {\n             self.rustc_snapshot_libdir()\n         } else {\n-            self.sysroot(compiler).join(libdir(&compiler.host))\n+            match self.config.libdir_relative() {\n+                Some(relative_libdir) if compiler.stage >= 1\n+                    => self.sysroot(compiler).join(relative_libdir),\n+                _ => self.sysroot(compiler).join(libdir(&compiler.host))\n+            }\n+        }\n+    }\n+\n+    /// Returns the compiler's relative libdir where it stores the dynamic libraries that\n+    /// it itself links against.\n+    ///\n+    /// For example this returns `lib` on Unix and `bin` on\n+    /// Windows.\n+    pub fn libdir_relative(&self, compiler: Compiler) -> &Path {\n+        if compiler.is_snapshot(self) {\n+            libdir(&self.config.build).as_ref()\n+        } else {\n+            match self.config.libdir_relative() {\n+                Some(relative_libdir) if compiler.stage >= 1\n+                    => relative_libdir,\n+                _ => libdir(&compiler.host).as_ref()\n+            }\n         }\n     }\n \n@@ -669,28 +711,27 @@ impl<'a> Builder<'a> {\n             .map(|entry| entry.path())\n     }\n \n-    pub fn rustdoc(&self, host: Interned<String>) -> PathBuf {\n-        self.ensure(tool::Rustdoc { host })\n+    pub fn rustdoc(&self, compiler: Compiler) -> PathBuf {\n+        self.ensure(tool::Rustdoc { compiler })\n     }\n \n-    pub fn rustdoc_cmd(&self, host: Interned<String>) -> Command {\n+    pub fn rustdoc_cmd(&self, compiler: Compiler) -> Command {\n         let mut cmd = Command::new(&self.out.join(\"bootstrap/debug/rustdoc\"));\n-        let compiler = self.compiler(self.top_stage, host);\n         cmd.env(\"RUSTC_STAGE\", compiler.stage.to_string())\n             .env(\"RUSTC_SYSROOT\", self.sysroot(compiler))\n             // Note that this is *not* the sysroot_libdir because rustdoc must be linked\n             // equivalently to rustc.\n             .env(\"RUSTDOC_LIBDIR\", self.rustc_libdir(compiler))\n             .env(\"CFG_RELEASE_CHANNEL\", &self.config.channel)\n-            .env(\"RUSTDOC_REAL\", self.rustdoc(host))\n+            .env(\"RUSTDOC_REAL\", self.rustdoc(compiler))\n             .env(\"RUSTDOC_CRATE_VERSION\", self.rust_version())\n             .env(\"RUSTC_BOOTSTRAP\", \"1\");\n \n         // Remove make-related flags that can cause jobserver problems.\n         cmd.env_remove(\"MAKEFLAGS\");\n         cmd.env_remove(\"MFLAGS\");\n \n-        if let Some(linker) = self.linker(host) {\n+        if let Some(linker) = self.linker(compiler.host) {\n             cmd.env(\"RUSTC_TARGET_LINKER\", linker);\n         }\n         cmd\n@@ -726,24 +767,20 @@ impl<'a> Builder<'a> {\n         // This is for the original compiler, but if we're forced to use stage 1, then\n         // std/test/rustc stamps won't exist in stage 2, so we need to get those from stage 1, since\n         // we copy the libs forward.\n-        let cmp = if self.force_use_stage1(compiler, target) {\n-            self.compiler(1, compiler.host)\n-        } else {\n-            compiler\n-        };\n+        let cmp = self.compiler_for(compiler.stage, compiler.host, target);\n \n         let libstd_stamp = match cmd {\n-            \"check\" => check::libstd_stamp(self, cmp, target),\n+            \"check\" | \"clippy\" | \"fix\" => check::libstd_stamp(self, cmp, target),\n             _ => compile::libstd_stamp(self, cmp, target),\n         };\n \n         let libtest_stamp = match cmd {\n-            \"check\" => check::libtest_stamp(self, cmp, target),\n-            _ => compile::libstd_stamp(self, cmp, target),\n+            \"check\" | \"clippy\" | \"fix\" => check::libtest_stamp(self, cmp, target),\n+            _ => compile::libtest_stamp(self, cmp, target),\n         };\n \n         let librustc_stamp = match cmd {\n-            \"check\" => check::librustc_stamp(self, cmp, target),\n+            \"check\" | \"clippy\" | \"fix\" => check::librustc_stamp(self, cmp, target),\n             _ => compile::librustc_stamp(self, cmp, target),\n         };\n \n@@ -752,7 +789,7 @@ impl<'a> Builder<'a> {\n                 // This is the intended out directory for compiler documentation.\n                 my_out = self.compiler_doc_out(target);\n             }\n-            let rustdoc = self.rustdoc(compiler.host);\n+            let rustdoc = self.rustdoc(compiler);\n             self.clear_if_dirty(&my_out, &rustdoc);\n         } else if cmd != \"test\" {\n             match mode {\n@@ -807,9 +844,9 @@ impl<'a> Builder<'a> {\n             assert_eq!(target, compiler.host);\n         }\n \n-        // Set a flag for `check` so that certain build scripts can do less work\n-        // (e.g., not building/requiring LLVM).\n-        if cmd == \"check\" {\n+        // Set a flag for `check`/`clippy`/`fix`, so that certain build\n+        // scripts can do less work (e.g. not building/requiring LLVM).\n+        if cmd == \"check\" || cmd == \"clippy\" || cmd == \"fix\" {\n             cargo.env(\"RUST_CHECK\", \"1\");\n         }\n \n@@ -831,14 +868,30 @@ impl<'a> Builder<'a> {\n \n         // FIXME: Temporary fix for https://github.com/rust-lang/cargo/issues/3005\n         // Force cargo to output binaries with disambiguating hashes in the name\n-        let metadata = if compiler.stage == 0 {\n-            // Treat stage0 like special channel, whether it's a normal prior-\n+        let mut metadata = if compiler.stage == 0 {\n+            // Treat stage0 like a special channel, whether it's a normal prior-\n             // release rustc or a local rebuild with the same version, so we\n             // never mix these libraries by accident.\n-            \"bootstrap\"\n+            \"bootstrap\".to_string()\n         } else {\n-            &self.config.channel\n+            self.config.channel.to_string()\n         };\n+        // We want to make sure that none of the dependencies between\n+        // std/test/rustc unify with one another. This is done for weird linkage\n+        // reasons but the gist of the problem is that if librustc, libtest, and\n+        // libstd all depend on libc from crates.io (which they actually do) we\n+        // want to make sure they all get distinct versions. Things get really\n+        // weird if we try to unify all these dependencies right now, namely\n+        // around how many times the library is linked in dynamic libraries and\n+        // such. If rustc were a static executable or if we didn't ship dylibs\n+        // this wouldn't be a problem, but we do, so it is. This is in general\n+        // just here to make sure things build right. If you can remove this and\n+        // things still build right, please do!\n+        match mode {\n+            Mode::Std => metadata.push_str(\"std\"),\n+            Mode::Test => metadata.push_str(\"test\"),\n+            _ => {},\n+        }\n         cargo.env(\"__CARGO_DEFAULT_LIB_METADATA\", &metadata);\n \n         let stage;\n@@ -858,6 +911,11 @@ impl<'a> Builder<'a> {\n             extra_args.push_str(&s);\n         }\n \n+        if cmd == \"clippy\" {\n+            extra_args.push_str(\"-Zforce-unstable-if-unmarked -Zunstable-options \\\n+                --json-rendered=termcolor\");\n+        }\n+\n         if !extra_args.is_empty() {\n             cargo.env(\n                 \"RUSTFLAGS\",\n@@ -909,12 +967,11 @@ impl<'a> Builder<'a> {\n             .env(\n                 \"RUSTDOC_REAL\",\n                 if cmd == \"doc\" || cmd == \"rustdoc\" || (cmd == \"test\" && want_rustdoc) {\n-                    self.rustdoc(compiler.host)\n+                    self.rustdoc(compiler)\n                 } else {\n                     PathBuf::from(\"/path/to/nowhere/rustdoc/not/required\")\n                 },\n             )\n-            .env(\"TEST_MIRI\", self.config.test_miri.to_string())\n             .env(\"RUSTC_ERROR_METADATA_DST\", self.extended_error_dir());\n \n         if let Some(host_linker) = self.linker(compiler.host) {\n@@ -926,26 +983,19 @@ impl<'a> Builder<'a> {\n         if let Some(ref error_format) = self.config.rustc_error_format {\n             cargo.env(\"RUSTC_ERROR_FORMAT\", error_format);\n         }\n-        if cmd != \"build\" && cmd != \"check\" && cmd != \"rustc\" && want_rustdoc {\n+        if !([\"build\", \"check\", \"clippy\", \"fix\", \"rustc\"].contains(&cmd)) && want_rustdoc {\n             cargo.env(\"RUSTDOC_LIBDIR\", self.rustc_libdir(compiler));\n         }\n \n-        if mode.is_tool() {\n-            // Tools like cargo and rls don't get debuginfo by default right now, but this can be\n-            // enabled in the config.  Adding debuginfo makes them several times larger.\n-            if self.config.rust_debuginfo_tools {\n-                cargo.env(\"RUSTC_DEBUGINFO\", self.config.rust_debuginfo.to_string());\n-                cargo.env(\n-                    \"RUSTC_DEBUGINFO_LINES\",\n-                    self.config.rust_debuginfo_lines.to_string(),\n-                );\n-            }\n-        } else {\n-            cargo.env(\"RUSTC_DEBUGINFO\", self.config.rust_debuginfo.to_string());\n-            cargo.env(\n-                \"RUSTC_DEBUGINFO_LINES\",\n-                self.config.rust_debuginfo_lines.to_string(),\n-            );\n+        let debuginfo_level = match mode {\n+            Mode::Rustc | Mode::Codegen => self.config.rust_debuginfo_level_rustc,\n+            Mode::Std | Mode::Test => self.config.rust_debuginfo_level_std,\n+            Mode::ToolBootstrap | Mode::ToolStd |\n+            Mode::ToolTest | Mode::ToolRustc => self.config.rust_debuginfo_level_tools,\n+        };\n+        cargo.env(\"RUSTC_DEBUGINFO_LEVEL\", debuginfo_level.to_string());\n+\n+        if !mode.is_tool() {\n             cargo.env(\"RUSTC_FORCE_UNSTABLE\", \"1\");\n \n             // Currently the compiler depends on crates from crates.io, and\n@@ -996,10 +1046,7 @@ impl<'a> Builder<'a> {\n         // For other crates, however, we know that we've already got a standard\n         // library up and running, so we can use the normal compiler to compile\n         // build scripts in that situation.\n-        //\n-        // If LLVM support is disabled we need to use the snapshot compiler to compile\n-        // build scripts, as the new compiler doesn't support executables.\n-        if mode == Mode::Std || !self.config.llvm_enabled {\n+        if mode == Mode::Std {\n             cargo\n                 .env(\"RUSTC_SNAPSHOT\", &self.initial_rustc)\n                 .env(\"RUSTC_SNAPSHOT_LIBDIR\", self.rustc_snapshot_libdir());\n@@ -1268,650 +1315,4 @@ impl<'a> Builder<'a> {\n }\n \n #[cfg(test)]\n-mod __test {\n-    use super::*;\n-    use crate::config::Config;\n-    use std::thread;\n-\n-    fn configure(host: &[&str], target: &[&str]) -> Config {\n-        let mut config = Config::default_opts();\n-        // don't save toolstates\n-        config.save_toolstates = None;\n-        config.run_host_only = true;\n-        config.dry_run = true;\n-        // try to avoid spurious failures in dist where we create/delete each others file\n-        let dir = config.out.join(\"tmp-rustbuild-tests\").join(\n-            &thread::current()\n-                .name()\n-                .unwrap_or(\"unknown\")\n-                .replace(\":\", \"-\"),\n-        );\n-        t!(fs::create_dir_all(&dir));\n-        config.out = dir;\n-        config.build = INTERNER.intern_str(\"A\");\n-        config.hosts = vec![config.build]\n-            .clone()\n-            .into_iter()\n-            .chain(host.iter().map(|s| INTERNER.intern_str(s)))\n-            .collect::<Vec<_>>();\n-        config.targets = config\n-            .hosts\n-            .clone()\n-            .into_iter()\n-            .chain(target.iter().map(|s| INTERNER.intern_str(s)))\n-            .collect::<Vec<_>>();\n-        config\n-    }\n-\n-    fn first<A, B>(v: Vec<(A, B)>) -> Vec<A> {\n-        v.into_iter().map(|(a, _)| a).collect::<Vec<_>>()\n-    }\n-\n-    #[test]\n-    fn dist_baseline() {\n-        let build = Build::new(configure(&[], &[]));\n-        let mut builder = Builder::new(&build);\n-        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n-\n-        let a = INTERNER.intern_str(\"A\");\n-\n-        assert_eq!(\n-            first(builder.cache.all::<dist::Docs>()),\n-            &[dist::Docs { stage: 2, host: a },]\n-        );\n-        assert_eq!(\n-            first(builder.cache.all::<dist::Mingw>()),\n-            &[dist::Mingw { host: a },]\n-        );\n-        assert_eq!(\n-            first(builder.cache.all::<dist::Rustc>()),\n-            &[dist::Rustc {\n-                compiler: Compiler { host: a, stage: 2 }\n-            },]\n-        );\n-        assert_eq!(\n-            first(builder.cache.all::<dist::Std>()),\n-            &[dist::Std {\n-                compiler: Compiler { host: a, stage: 2 },\n-                target: a,\n-            },]\n-        );\n-        assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n-    }\n-\n-    #[test]\n-    fn dist_with_targets() {\n-        let build = Build::new(configure(&[], &[\"B\"]));\n-        let mut builder = Builder::new(&build);\n-        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n-\n-        let a = INTERNER.intern_str(\"A\");\n-        let b = INTERNER.intern_str(\"B\");\n-\n-        assert_eq!(\n-            first(builder.cache.all::<dist::Docs>()),\n-            &[\n-                dist::Docs { stage: 2, host: a },\n-                dist::Docs { stage: 2, host: b },\n-            ]\n-        );\n-        assert_eq!(\n-            first(builder.cache.all::<dist::Mingw>()),\n-            &[dist::Mingw { host: a }, dist::Mingw { host: b },]\n-        );\n-        assert_eq!(\n-            first(builder.cache.all::<dist::Rustc>()),\n-            &[dist::Rustc {\n-                compiler: Compiler { host: a, stage: 2 }\n-            },]\n-        );\n-        assert_eq!(\n-            first(builder.cache.all::<dist::Std>()),\n-            &[\n-                dist::Std {\n-                    compiler: Compiler { host: a, stage: 2 },\n-                    target: a,\n-                },\n-                dist::Std {\n-                    compiler: Compiler { host: a, stage: 2 },\n-                    target: b,\n-                },\n-            ]\n-        );\n-        assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n-    }\n-\n-    #[test]\n-    fn dist_with_hosts() {\n-        let build = Build::new(configure(&[\"B\"], &[]));\n-        let mut builder = Builder::new(&build);\n-        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n-\n-        let a = INTERNER.intern_str(\"A\");\n-        let b = INTERNER.intern_str(\"B\");\n-\n-        assert_eq!(\n-            first(builder.cache.all::<dist::Docs>()),\n-            &[\n-                dist::Docs { stage: 2, host: a },\n-                dist::Docs { stage: 2, host: b },\n-            ]\n-        );\n-        assert_eq!(\n-            first(builder.cache.all::<dist::Mingw>()),\n-            &[dist::Mingw { host: a }, dist::Mingw { host: b },]\n-        );\n-        assert_eq!(\n-            first(builder.cache.all::<dist::Rustc>()),\n-            &[\n-                dist::Rustc {\n-                    compiler: Compiler { host: a, stage: 2 }\n-                },\n-                dist::Rustc {\n-                    compiler: Compiler { host: b, stage: 2 }\n-                },\n-            ]\n-        );\n-        assert_eq!(\n-            first(builder.cache.all::<dist::Std>()),\n-            &[\n-                dist::Std {\n-                    compiler: Compiler { host: a, stage: 2 },\n-                    target: a,\n-                },\n-                dist::Std {\n-                    compiler: Compiler { host: a, stage: 2 },\n-                    target: b,\n-                },\n-            ]\n-        );\n-        assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n-    }\n-\n-    #[test]\n-    fn dist_with_targets_and_hosts() {\n-        let build = Build::new(configure(&[\"B\"], &[\"C\"]));\n-        let mut builder = Builder::new(&build);\n-        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n-\n-        let a = INTERNER.intern_str(\"A\");\n-        let b = INTERNER.intern_str(\"B\");\n-        let c = INTERNER.intern_str(\"C\");\n-\n-        assert_eq!(\n-            first(builder.cache.all::<dist::Docs>()),\n-            &[\n-                dist::Docs { stage: 2, host: a },\n-                dist::Docs { stage: 2, host: b },\n-                dist::Docs { stage: 2, host: c },\n-            ]\n-        );\n-        assert_eq!(\n-            first(builder.cache.all::<dist::Mingw>()),\n-            &[\n-                dist::Mingw { host: a },\n-                dist::Mingw { host: b },\n-                dist::Mingw { host: c },\n-            ]\n-        );\n-        assert_eq!(\n-            first(builder.cache.all::<dist::Rustc>()),\n-            &[\n-                dist::Rustc {\n-                    compiler: Compiler { host: a, stage: 2 }\n-                },\n-                dist::Rustc {\n-                    compiler: Compiler { host: b, stage: 2 }\n-                },\n-            ]\n-        );\n-        assert_eq!(\n-            first(builder.cache.all::<dist::Std>()),\n-            &[\n-                dist::Std {\n-                    compiler: Compiler { host: a, stage: 2 },\n-                    target: a,\n-                },\n-                dist::Std {\n-                    compiler: Compiler { host: a, stage: 2 },\n-                    target: b,\n-                },\n-                dist::Std {\n-                    compiler: Compiler { host: a, stage: 2 },\n-                    target: c,\n-                },\n-            ]\n-        );\n-        assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n-    }\n-\n-    #[test]\n-    fn dist_with_target_flag() {\n-        let mut config = configure(&[\"B\"], &[\"C\"]);\n-        config.run_host_only = false; // as-if --target=C was passed\n-        let build = Build::new(config);\n-        let mut builder = Builder::new(&build);\n-        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n-\n-        let a = INTERNER.intern_str(\"A\");\n-        let b = INTERNER.intern_str(\"B\");\n-        let c = INTERNER.intern_str(\"C\");\n-\n-        assert_eq!(\n-            first(builder.cache.all::<dist::Docs>()),\n-            &[\n-                dist::Docs { stage: 2, host: a },\n-                dist::Docs { stage: 2, host: b },\n-                dist::Docs { stage: 2, host: c },\n-            ]\n-        );\n-        assert_eq!(\n-            first(builder.cache.all::<dist::Mingw>()),\n-            &[\n-                dist::Mingw { host: a },\n-                dist::Mingw { host: b },\n-                dist::Mingw { host: c },\n-            ]\n-        );\n-        assert_eq!(first(builder.cache.all::<dist::Rustc>()), &[]);\n-        assert_eq!(\n-            first(builder.cache.all::<dist::Std>()),\n-            &[\n-                dist::Std {\n-                    compiler: Compiler { host: a, stage: 2 },\n-                    target: a,\n-                },\n-                dist::Std {\n-                    compiler: Compiler { host: a, stage: 2 },\n-                    target: b,\n-                },\n-                dist::Std {\n-                    compiler: Compiler { host: a, stage: 2 },\n-                    target: c,\n-                },\n-            ]\n-        );\n-        assert_eq!(first(builder.cache.all::<dist::Src>()), &[]);\n-    }\n-\n-    #[test]\n-    fn dist_with_same_targets_and_hosts() {\n-        let build = Build::new(configure(&[\"B\"], &[\"B\"]));\n-        let mut builder = Builder::new(&build);\n-        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n-\n-        let a = INTERNER.intern_str(\"A\");\n-        let b = INTERNER.intern_str(\"B\");\n-\n-        assert_eq!(\n-            first(builder.cache.all::<dist::Docs>()),\n-            &[\n-                dist::Docs { stage: 2, host: a },\n-                dist::Docs { stage: 2, host: b },\n-            ]\n-        );\n-        assert_eq!(\n-            first(builder.cache.all::<dist::Mingw>()),\n-            &[dist::Mingw { host: a }, dist::Mingw { host: b },]\n-        );\n-        assert_eq!(\n-            first(builder.cache.all::<dist::Rustc>()),\n-            &[\n-                dist::Rustc {\n-                    compiler: Compiler { host: a, stage: 2 }\n-                },\n-                dist::Rustc {\n-                    compiler: Compiler { host: b, stage: 2 }\n-                },\n-            ]\n-        );\n-        assert_eq!(\n-            first(builder.cache.all::<dist::Std>()),\n-            &[\n-                dist::Std {\n-                    compiler: Compiler { host: a, stage: 2 },\n-                    target: a,\n-                },\n-                dist::Std {\n-                    compiler: Compiler { host: a, stage: 2 },\n-                    target: b,\n-                },\n-            ]\n-        );\n-        assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n-        assert_eq!(\n-            first(builder.cache.all::<compile::Std>()),\n-            &[\n-                compile::Std {\n-                    compiler: Compiler { host: a, stage: 0 },\n-                    target: a,\n-                },\n-                compile::Std {\n-                    compiler: Compiler { host: a, stage: 1 },\n-                    target: a,\n-                },\n-                compile::Std {\n-                    compiler: Compiler { host: a, stage: 2 },\n-                    target: a,\n-                },\n-                compile::Std {\n-                    compiler: Compiler { host: a, stage: 1 },\n-                    target: b,\n-                },\n-                compile::Std {\n-                    compiler: Compiler { host: a, stage: 2 },\n-                    target: b,\n-                },\n-            ]\n-        );\n-        assert_eq!(\n-            first(builder.cache.all::<compile::Test>()),\n-            &[\n-                compile::Test {\n-                    compiler: Compiler { host: a, stage: 0 },\n-                    target: a,\n-                },\n-                compile::Test {\n-                    compiler: Compiler { host: a, stage: 1 },\n-                    target: a,\n-                },\n-                compile::Test {\n-                    compiler: Compiler { host: a, stage: 2 },\n-                    target: a,\n-                },\n-                compile::Test {\n-                    compiler: Compiler { host: a, stage: 1 },\n-                    target: b,\n-                },\n-                compile::Test {\n-                    compiler: Compiler { host: a, stage: 2 },\n-                    target: b,\n-                },\n-            ]\n-        );\n-        assert_eq!(\n-            first(builder.cache.all::<compile::Assemble>()),\n-            &[\n-                compile::Assemble {\n-                    target_compiler: Compiler { host: a, stage: 0 },\n-                },\n-                compile::Assemble {\n-                    target_compiler: Compiler { host: a, stage: 1 },\n-                },\n-                compile::Assemble {\n-                    target_compiler: Compiler { host: a, stage: 2 },\n-                },\n-                compile::Assemble {\n-                    target_compiler: Compiler { host: b, stage: 2 },\n-                },\n-            ]\n-        );\n-    }\n-\n-    #[test]\n-    fn build_default() {\n-        let build = Build::new(configure(&[\"B\"], &[\"C\"]));\n-        let mut builder = Builder::new(&build);\n-        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Build), &[]);\n-\n-        let a = INTERNER.intern_str(\"A\");\n-        let b = INTERNER.intern_str(\"B\");\n-        let c = INTERNER.intern_str(\"C\");\n-\n-        assert!(!builder.cache.all::<compile::Std>().is_empty());\n-        assert!(!builder.cache.all::<compile::Assemble>().is_empty());\n-        assert_eq!(\n-            first(builder.cache.all::<compile::Rustc>()),\n-            &[\n-                compile::Rustc {\n-                    compiler: Compiler { host: a, stage: 0 },\n-                    target: a,\n-                },\n-                compile::Rustc {\n-                    compiler: Compiler { host: a, stage: 1 },\n-                    target: a,\n-                },\n-                compile::Rustc {\n-                    compiler: Compiler { host: a, stage: 2 },\n-                    target: a,\n-                },\n-                compile::Rustc {\n-                    compiler: Compiler { host: b, stage: 2 },\n-                    target: a,\n-                },\n-                compile::Rustc {\n-                    compiler: Compiler { host: a, stage: 0 },\n-                    target: b,\n-                },\n-                compile::Rustc {\n-                    compiler: Compiler { host: a, stage: 1 },\n-                    target: b,\n-                },\n-                compile::Rustc {\n-                    compiler: Compiler { host: a, stage: 2 },\n-                    target: b,\n-                },\n-                compile::Rustc {\n-                    compiler: Compiler { host: b, stage: 2 },\n-                    target: b,\n-                },\n-            ]\n-        );\n-\n-        assert_eq!(\n-            first(builder.cache.all::<compile::Test>()),\n-            &[\n-                compile::Test {\n-                    compiler: Compiler { host: a, stage: 0 },\n-                    target: a,\n-                },\n-                compile::Test {\n-                    compiler: Compiler { host: a, stage: 1 },\n-                    target: a,\n-                },\n-                compile::Test {\n-                    compiler: Compiler { host: a, stage: 2 },\n-                    target: a,\n-                },\n-                compile::Test {\n-                    compiler: Compiler { host: b, stage: 2 },\n-                    target: a,\n-                },\n-                compile::Test {\n-                    compiler: Compiler { host: a, stage: 0 },\n-                    target: b,\n-                },\n-                compile::Test {\n-                    compiler: Compiler { host: a, stage: 1 },\n-                    target: b,\n-                },\n-                compile::Test {\n-                    compiler: Compiler { host: a, stage: 2 },\n-                    target: b,\n-                },\n-                compile::Test {\n-                    compiler: Compiler { host: b, stage: 2 },\n-                    target: b,\n-                },\n-                compile::Test {\n-                    compiler: Compiler { host: a, stage: 2 },\n-                    target: c,\n-                },\n-                compile::Test {\n-                    compiler: Compiler { host: b, stage: 2 },\n-                    target: c,\n-                },\n-            ]\n-        );\n-    }\n-\n-    #[test]\n-    fn build_with_target_flag() {\n-        let mut config = configure(&[\"B\"], &[\"C\"]);\n-        config.run_host_only = false;\n-        let build = Build::new(config);\n-        let mut builder = Builder::new(&build);\n-        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Build), &[]);\n-\n-        let a = INTERNER.intern_str(\"A\");\n-        let b = INTERNER.intern_str(\"B\");\n-        let c = INTERNER.intern_str(\"C\");\n-\n-        assert!(!builder.cache.all::<compile::Std>().is_empty());\n-        assert_eq!(\n-            first(builder.cache.all::<compile::Assemble>()),\n-            &[\n-                compile::Assemble {\n-                    target_compiler: Compiler { host: a, stage: 0 },\n-                },\n-                compile::Assemble {\n-                    target_compiler: Compiler { host: a, stage: 1 },\n-                },\n-                compile::Assemble {\n-                    target_compiler: Compiler { host: b, stage: 1 },\n-                },\n-                compile::Assemble {\n-                    target_compiler: Compiler { host: a, stage: 2 },\n-                },\n-                compile::Assemble {\n-                    target_compiler: Compiler { host: b, stage: 2 },\n-                },\n-            ]\n-        );\n-        assert_eq!(\n-            first(builder.cache.all::<compile::Rustc>()),\n-            &[\n-                compile::Rustc {\n-                    compiler: Compiler { host: a, stage: 0 },\n-                    target: a,\n-                },\n-                compile::Rustc {\n-                    compiler: Compiler { host: a, stage: 1 },\n-                    target: a,\n-                },\n-                compile::Rustc {\n-                    compiler: Compiler { host: a, stage: 0 },\n-                    target: b,\n-                },\n-                compile::Rustc {\n-                    compiler: Compiler { host: a, stage: 1 },\n-                    target: b,\n-                },\n-            ]\n-        );\n-\n-        assert_eq!(\n-            first(builder.cache.all::<compile::Test>()),\n-            &[\n-                compile::Test {\n-                    compiler: Compiler { host: a, stage: 0 },\n-                    target: a,\n-                },\n-                compile::Test {\n-                    compiler: Compiler { host: a, stage: 1 },\n-                    target: a,\n-                },\n-                compile::Test {\n-                    compiler: Compiler { host: a, stage: 2 },\n-                    target: a,\n-                },\n-                compile::Test {\n-                    compiler: Compiler { host: b, stage: 2 },\n-                    target: a,\n-                },\n-                compile::Test {\n-                    compiler: Compiler { host: a, stage: 0 },\n-                    target: b,\n-                },\n-                compile::Test {\n-                    compiler: Compiler { host: a, stage: 1 },\n-                    target: b,\n-                },\n-                compile::Test {\n-                    compiler: Compiler { host: a, stage: 2 },\n-                    target: b,\n-                },\n-                compile::Test {\n-                    compiler: Compiler { host: b, stage: 2 },\n-                    target: b,\n-                },\n-                compile::Test {\n-                    compiler: Compiler { host: a, stage: 2 },\n-                    target: c,\n-                },\n-                compile::Test {\n-                    compiler: Compiler { host: b, stage: 2 },\n-                    target: c,\n-                },\n-            ]\n-        );\n-    }\n-\n-    #[test]\n-    fn test_with_no_doc_stage0() {\n-        let mut config = configure(&[], &[]);\n-        config.stage = Some(0);\n-        config.cmd = Subcommand::Test {\n-            paths: vec![\"src/libstd\".into()],\n-            test_args: vec![],\n-            rustc_args: vec![],\n-            fail_fast: true,\n-            doc_tests: DocTests::No,\n-            bless: false,\n-            compare_mode: None,\n-        };\n-\n-        let build = Build::new(config);\n-        let mut builder = Builder::new(&build);\n-\n-        let host = INTERNER.intern_str(\"A\");\n-\n-        builder.run_step_descriptions(\n-            &[StepDescription::from::<test::Crate>()],\n-            &[\"src/libstd\".into()],\n-        );\n-\n-        // Ensure we don't build any compiler artifacts.\n-        assert!(!builder.cache.contains::<compile::Rustc>());\n-        assert_eq!(\n-            first(builder.cache.all::<test::Crate>()),\n-            &[test::Crate {\n-                compiler: Compiler { host, stage: 0 },\n-                target: host,\n-                mode: Mode::Std,\n-                test_kind: test::TestKind::Test,\n-                krate: INTERNER.intern_str(\"std\"),\n-            },]\n-        );\n-    }\n-\n-    #[test]\n-    fn test_exclude() {\n-        let mut config = configure(&[], &[]);\n-        config.exclude = vec![\n-            \"src/test/run-pass\".into(),\n-            \"src/tools/tidy\".into(),\n-        ];\n-        config.cmd = Subcommand::Test {\n-            paths: Vec::new(),\n-            test_args: Vec::new(),\n-            rustc_args: Vec::new(),\n-            fail_fast: true,\n-            doc_tests: DocTests::No,\n-            bless: false,\n-            compare_mode: None,\n-        };\n-\n-        let build = Build::new(config);\n-        let builder = Builder::new(&build);\n-        builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Test), &[]);\n-\n-        // Ensure we have really excluded run-pass & tidy\n-        assert!(!builder.cache.contains::<test::RunPass>());\n-        assert!(!builder.cache.contains::<test::Tidy>());\n-\n-        // Ensure other tests are not affected.\n-        assert!(builder.cache.contains::<test::RunPassFullDeps>());\n-        assert!(builder.cache.contains::<test::RustdocUi>());\n-    }\n-}\n+mod tests;"}, {"sha": "d1542b1fca6b7b6278a967e62685a4a65f10bdc8", "filename": "src/bootstrap/builder/tests.rs", "status": "added", "additions": 655, "deletions": 0, "changes": 655, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fbootstrap%2Fbuilder%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fbootstrap%2Fbuilder%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fbuilder%2Ftests.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -0,0 +1,655 @@\n+use super::*;\n+use crate::config::Config;\n+use std::thread;\n+\n+use pretty_assertions::assert_eq;\n+\n+fn configure(host: &[&str], target: &[&str]) -> Config {\n+    let mut config = Config::default_opts();\n+    // don't save toolstates\n+    config.save_toolstates = None;\n+    config.skip_only_host_steps = false;\n+    config.dry_run = true;\n+    // try to avoid spurious failures in dist where we create/delete each others file\n+    let dir = config.out.join(\"tmp-rustbuild-tests\").join(\n+        &thread::current()\n+            .name()\n+            .unwrap_or(\"unknown\")\n+            .replace(\":\", \"-\"),\n+    );\n+    t!(fs::create_dir_all(&dir));\n+    config.out = dir;\n+    config.build = INTERNER.intern_str(\"A\");\n+    config.hosts = vec![config.build]\n+        .clone()\n+        .into_iter()\n+        .chain(host.iter().map(|s| INTERNER.intern_str(s)))\n+        .collect::<Vec<_>>();\n+    config.targets = config\n+        .hosts\n+        .clone()\n+        .into_iter()\n+        .chain(target.iter().map(|s| INTERNER.intern_str(s)))\n+        .collect::<Vec<_>>();\n+    config\n+}\n+\n+fn first<A, B>(v: Vec<(A, B)>) -> Vec<A> {\n+    v.into_iter().map(|(a, _)| a).collect::<Vec<_>>()\n+}\n+\n+#[test]\n+fn dist_baseline() {\n+    let build = Build::new(configure(&[], &[]));\n+    let mut builder = Builder::new(&build);\n+    builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n+\n+    let a = INTERNER.intern_str(\"A\");\n+\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Docs>()),\n+        &[dist::Docs { host: a },]\n+    );\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Mingw>()),\n+        &[dist::Mingw { host: a },]\n+    );\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Rustc>()),\n+        &[dist::Rustc {\n+            compiler: Compiler { host: a, stage: 2 }\n+        },]\n+    );\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Std>()),\n+        &[dist::Std {\n+            compiler: Compiler { host: a, stage: 1 },\n+            target: a,\n+        },]\n+    );\n+    assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n+}\n+\n+#[test]\n+fn dist_with_targets() {\n+    let build = Build::new(configure(&[], &[\"B\"]));\n+    let mut builder = Builder::new(&build);\n+    builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n+\n+    let a = INTERNER.intern_str(\"A\");\n+    let b = INTERNER.intern_str(\"B\");\n+\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Docs>()),\n+        &[\n+            dist::Docs { host: a },\n+            dist::Docs { host: b },\n+        ]\n+    );\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Mingw>()),\n+        &[dist::Mingw { host: a }, dist::Mingw { host: b },]\n+    );\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Rustc>()),\n+        &[dist::Rustc {\n+            compiler: Compiler { host: a, stage: 2 }\n+        },]\n+    );\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Std>()),\n+        &[\n+            dist::Std {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: a,\n+            },\n+            dist::Std {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: b,\n+            },\n+        ]\n+    );\n+    assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n+}\n+\n+#[test]\n+fn dist_with_hosts() {\n+    let build = Build::new(configure(&[\"B\"], &[]));\n+    let mut builder = Builder::new(&build);\n+    builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n+\n+    let a = INTERNER.intern_str(\"A\");\n+    let b = INTERNER.intern_str(\"B\");\n+\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Docs>()),\n+        &[\n+            dist::Docs { host: a },\n+            dist::Docs { host: b },\n+        ]\n+    );\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Mingw>()),\n+        &[dist::Mingw { host: a }, dist::Mingw { host: b },]\n+    );\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Rustc>()),\n+        &[\n+            dist::Rustc {\n+                compiler: Compiler { host: a, stage: 2 }\n+            },\n+            dist::Rustc {\n+                compiler: Compiler { host: b, stage: 2 }\n+            },\n+        ]\n+    );\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Std>()),\n+        &[\n+            dist::Std {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: a,\n+            },\n+            dist::Std {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: b,\n+            },\n+        ]\n+    );\n+    assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n+}\n+\n+#[test]\n+fn dist_only_cross_host() {\n+    let a = INTERNER.intern_str(\"A\");\n+    let b = INTERNER.intern_str(\"B\");\n+    let mut build = Build::new(configure(&[\"B\"], &[]));\n+    build.config.docs = false;\n+    build.config.extended = true;\n+    build.hosts = vec![b];\n+    let mut builder = Builder::new(&build);\n+    builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n+\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Rustc>()),\n+        &[\n+            dist::Rustc {\n+                compiler: Compiler { host: b, stage: 2 }\n+            },\n+        ]\n+    );\n+    assert_eq!(\n+        first(builder.cache.all::<compile::Rustc>()),\n+        &[\n+            compile::Rustc {\n+                compiler: Compiler { host: a, stage: 0 },\n+                target: a,\n+            },\n+            compile::Rustc {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: b,\n+            },\n+        ]\n+    );\n+}\n+\n+#[test]\n+fn dist_with_targets_and_hosts() {\n+    let build = Build::new(configure(&[\"B\"], &[\"C\"]));\n+    let mut builder = Builder::new(&build);\n+    builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n+\n+    let a = INTERNER.intern_str(\"A\");\n+    let b = INTERNER.intern_str(\"B\");\n+    let c = INTERNER.intern_str(\"C\");\n+\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Docs>()),\n+        &[\n+            dist::Docs { host: a },\n+            dist::Docs { host: b },\n+            dist::Docs { host: c },\n+        ]\n+    );\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Mingw>()),\n+        &[\n+            dist::Mingw { host: a },\n+            dist::Mingw { host: b },\n+            dist::Mingw { host: c },\n+        ]\n+    );\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Rustc>()),\n+        &[\n+            dist::Rustc {\n+                compiler: Compiler { host: a, stage: 2 }\n+            },\n+            dist::Rustc {\n+                compiler: Compiler { host: b, stage: 2 }\n+            },\n+        ]\n+    );\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Std>()),\n+        &[\n+            dist::Std {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: a,\n+            },\n+            dist::Std {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: b,\n+            },\n+            dist::Std {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: c,\n+            },\n+        ]\n+    );\n+    assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n+}\n+\n+#[test]\n+fn dist_with_target_flag() {\n+    let mut config = configure(&[\"B\"], &[\"C\"]);\n+    config.skip_only_host_steps = true; // as-if --target=C was passed\n+    let build = Build::new(config);\n+    let mut builder = Builder::new(&build);\n+    builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n+\n+    let a = INTERNER.intern_str(\"A\");\n+    let b = INTERNER.intern_str(\"B\");\n+    let c = INTERNER.intern_str(\"C\");\n+\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Docs>()),\n+        &[\n+            dist::Docs { host: a },\n+            dist::Docs { host: b },\n+            dist::Docs { host: c },\n+        ]\n+    );\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Mingw>()),\n+        &[\n+            dist::Mingw { host: a },\n+            dist::Mingw { host: b },\n+            dist::Mingw { host: c },\n+        ]\n+    );\n+    assert_eq!(first(builder.cache.all::<dist::Rustc>()), &[]);\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Std>()),\n+        &[\n+            dist::Std {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: a,\n+            },\n+            dist::Std {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: b,\n+            },\n+            dist::Std {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: c,\n+            },\n+        ]\n+    );\n+    assert_eq!(first(builder.cache.all::<dist::Src>()), &[]);\n+}\n+\n+#[test]\n+fn dist_with_same_targets_and_hosts() {\n+    let build = Build::new(configure(&[\"B\"], &[\"B\"]));\n+    let mut builder = Builder::new(&build);\n+    builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Dist), &[]);\n+\n+    let a = INTERNER.intern_str(\"A\");\n+    let b = INTERNER.intern_str(\"B\");\n+\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Docs>()),\n+        &[\n+            dist::Docs { host: a },\n+            dist::Docs { host: b },\n+        ]\n+    );\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Mingw>()),\n+        &[dist::Mingw { host: a }, dist::Mingw { host: b },]\n+    );\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Rustc>()),\n+        &[\n+            dist::Rustc {\n+                compiler: Compiler { host: a, stage: 2 }\n+            },\n+            dist::Rustc {\n+                compiler: Compiler { host: b, stage: 2 }\n+            },\n+        ]\n+    );\n+    assert_eq!(\n+        first(builder.cache.all::<dist::Std>()),\n+        &[\n+            dist::Std {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: a,\n+            },\n+            dist::Std {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: b,\n+            },\n+        ]\n+    );\n+    assert_eq!(first(builder.cache.all::<dist::Src>()), &[dist::Src]);\n+    assert_eq!(\n+        first(builder.cache.all::<compile::Std>()),\n+        &[\n+            compile::Std {\n+                compiler: Compiler { host: a, stage: 0 },\n+                target: a,\n+            },\n+            compile::Std {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: a,\n+            },\n+            compile::Std {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: a,\n+            },\n+            compile::Std {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: b,\n+            },\n+        ]\n+    );\n+    assert_eq!(\n+        first(builder.cache.all::<compile::Test>()),\n+        &[\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 0 },\n+                target: a,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: a,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: a,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: b,\n+            },\n+        ]\n+    );\n+    assert_eq!(\n+        first(builder.cache.all::<compile::Assemble>()),\n+        &[\n+            compile::Assemble {\n+                target_compiler: Compiler { host: a, stage: 0 },\n+            },\n+            compile::Assemble {\n+                target_compiler: Compiler { host: a, stage: 1 },\n+            },\n+            compile::Assemble {\n+                target_compiler: Compiler { host: a, stage: 2 },\n+            },\n+            compile::Assemble {\n+                target_compiler: Compiler { host: b, stage: 2 },\n+            },\n+        ]\n+    );\n+}\n+\n+#[test]\n+fn build_default() {\n+    let build = Build::new(configure(&[\"B\"], &[\"C\"]));\n+    let mut builder = Builder::new(&build);\n+    builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Build), &[]);\n+\n+    let a = INTERNER.intern_str(\"A\");\n+    let b = INTERNER.intern_str(\"B\");\n+    let c = INTERNER.intern_str(\"C\");\n+\n+    assert!(!builder.cache.all::<compile::Std>().is_empty());\n+    assert!(!builder.cache.all::<compile::Assemble>().is_empty());\n+    assert_eq!(\n+        first(builder.cache.all::<compile::Rustc>()),\n+        &[\n+            compile::Rustc {\n+                compiler: Compiler { host: a, stage: 0 },\n+                target: a,\n+            },\n+            compile::Rustc {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: a,\n+            },\n+            compile::Rustc {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: a,\n+            },\n+            compile::Rustc {\n+                compiler: Compiler { host: b, stage: 2 },\n+                target: a,\n+            },\n+            compile::Rustc {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: b,\n+            },\n+            compile::Rustc {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: b,\n+            },\n+            compile::Rustc {\n+                compiler: Compiler { host: b, stage: 2 },\n+                target: b,\n+            },\n+        ]\n+    );\n+\n+    assert_eq!(\n+        first(builder.cache.all::<compile::Test>()),\n+        &[\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 0 },\n+                target: a,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: a,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: a,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: b, stage: 2 },\n+                target: a,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: b,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: b,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: b, stage: 2 },\n+                target: b,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: c,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: b, stage: 2 },\n+                target: c,\n+            },\n+        ]\n+    );\n+}\n+\n+#[test]\n+fn build_with_target_flag() {\n+    let mut config = configure(&[\"B\"], &[\"C\"]);\n+    config.skip_only_host_steps = true;\n+    let build = Build::new(config);\n+    let mut builder = Builder::new(&build);\n+    builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Build), &[]);\n+\n+    let a = INTERNER.intern_str(\"A\");\n+    let b = INTERNER.intern_str(\"B\");\n+    let c = INTERNER.intern_str(\"C\");\n+\n+    assert!(!builder.cache.all::<compile::Std>().is_empty());\n+    assert_eq!(\n+        first(builder.cache.all::<compile::Assemble>()),\n+        &[\n+            compile::Assemble {\n+                target_compiler: Compiler { host: a, stage: 0 },\n+            },\n+            compile::Assemble {\n+                target_compiler: Compiler { host: a, stage: 1 },\n+            },\n+            compile::Assemble {\n+                target_compiler: Compiler { host: a, stage: 2 },\n+            },\n+            compile::Assemble {\n+                target_compiler: Compiler { host: b, stage: 2 },\n+            },\n+        ]\n+    );\n+    assert_eq!(\n+        first(builder.cache.all::<compile::Rustc>()),\n+        &[\n+            compile::Rustc {\n+                compiler: Compiler { host: a, stage: 0 },\n+                target: a,\n+            },\n+            compile::Rustc {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: a,\n+            },\n+            compile::Rustc {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: b,\n+            },\n+        ]\n+    );\n+\n+    assert_eq!(\n+        first(builder.cache.all::<compile::Test>()),\n+        &[\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 0 },\n+                target: a,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: a,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: a,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: b, stage: 2 },\n+                target: a,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 1 },\n+                target: b,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: b,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: b, stage: 2 },\n+                target: b,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: a, stage: 2 },\n+                target: c,\n+            },\n+            compile::Test {\n+                compiler: Compiler { host: b, stage: 2 },\n+                target: c,\n+            },\n+        ]\n+    );\n+}\n+\n+#[test]\n+fn test_with_no_doc_stage0() {\n+    let mut config = configure(&[], &[]);\n+    config.stage = Some(0);\n+    config.cmd = Subcommand::Test {\n+        paths: vec![\"src/libstd\".into()],\n+        test_args: vec![],\n+        rustc_args: vec![],\n+        fail_fast: true,\n+        doc_tests: DocTests::No,\n+        bless: false,\n+        compare_mode: None,\n+        rustfix_coverage: false,\n+        pass: None,\n+    };\n+\n+    let build = Build::new(config);\n+    let mut builder = Builder::new(&build);\n+\n+    let host = INTERNER.intern_str(\"A\");\n+\n+    builder.run_step_descriptions(\n+        &[StepDescription::from::<test::Crate>()],\n+        &[\"src/libstd\".into()],\n+    );\n+\n+    // Ensure we don't build any compiler artifacts.\n+    assert!(!builder.cache.contains::<compile::Rustc>());\n+    assert_eq!(\n+        first(builder.cache.all::<test::Crate>()),\n+        &[test::Crate {\n+            compiler: Compiler { host, stage: 0 },\n+            target: host,\n+            mode: Mode::Std,\n+            test_kind: test::TestKind::Test,\n+            krate: INTERNER.intern_str(\"std\"),\n+        },]\n+    );\n+}\n+\n+#[test]\n+fn test_exclude() {\n+    let mut config = configure(&[], &[]);\n+    config.exclude = vec![\n+        \"src/tools/tidy\".into(),\n+    ];\n+    config.cmd = Subcommand::Test {\n+        paths: Vec::new(),\n+        test_args: Vec::new(),\n+        rustc_args: Vec::new(),\n+        fail_fast: true,\n+        doc_tests: DocTests::No,\n+        bless: false,\n+        compare_mode: None,\n+        rustfix_coverage: false,\n+        pass: None,\n+    };\n+\n+    let build = Build::new(config);\n+    let builder = Builder::new(&build);\n+    builder.run_step_descriptions(&Builder::get_step_descriptions(Kind::Test), &[]);\n+\n+    // Ensure we have really excluded tidy\n+    assert!(!builder.cache.contains::<test::Tidy>());\n+\n+    // Ensure other tests are not affected.\n+    assert!(builder.cache.contains::<test::RustdocUi>());\n+}"}, {"sha": "53071df855297e30f17598f8dd03d159f412a151", "filename": "src/bootstrap/cache.rs", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fbootstrap%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fbootstrap%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcache.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -13,6 +13,8 @@ use std::path::{Path, PathBuf};\n use std::sync::Mutex;\n use std::cmp::{PartialOrd, Ord, Ordering};\n \n+use lazy_static::lazy_static;\n+\n use crate::builder::Step;\n \n pub struct Interned<T>(usize, PhantomData<*const T>);\n@@ -264,8 +266,10 @@ impl Cache {\n                         .expect(\"invalid type mapped\");\n         stepcache.get(step).cloned()\n     }\n+}\n \n-    #[cfg(test)]\n+#[cfg(test)]\n+impl Cache {\n     pub fn all<S: Ord + Copy + Step>(&mut self) -> Vec<(S, S::Output)> {\n         let cache = self.0.get_mut();\n         let type_id = TypeId::of::<S>();\n@@ -277,7 +281,6 @@ impl Cache {\n         v\n     }\n \n-    #[cfg(test)]\n     pub fn contains<S: Step>(&self) -> bool {\n         self.0.borrow().contains_key(&TypeId::of::<S>())\n     }"}, {"sha": "c58a98bac36783dccffe786a65c76f1d8a2b14f0", "filename": "src/bootstrap/cc_detect.rs", "status": "modified", "additions": 29, "deletions": 17, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fbootstrap%2Fcc_detect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fbootstrap%2Fcc_detect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcc_detect.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -45,6 +45,8 @@ fn cc2ar(cc: &Path, target: &str) -> Option<PathBuf> {\n         Some(PathBuf::from(\"ar\"))\n     } else if target.contains(\"openbsd\") {\n         Some(PathBuf::from(\"ar\"))\n+    } else if target.contains(\"vxworks\") {\n+        Some(PathBuf::from(\"vx-ar\"))\n     } else {\n         let parent = cc.parent().unwrap();\n         let file = cc.file_name().unwrap().to_str().unwrap();\n@@ -95,29 +97,39 @@ pub fn find(build: &mut Build) {\n         };\n \n         build.cc.insert(target, compiler);\n-        build.verbose(&format!(\"CC_{} = {:?}\", &target, build.cc(target)));\n-        build.verbose(&format!(\"CFLAGS_{} = {:?}\", &target, build.cflags(target, GitRepo::Rustc)));\n-        if let Some(ar) = ar {\n-            build.verbose(&format!(\"AR_{} = {:?}\", &target, ar));\n-            build.ar.insert(target, ar);\n-        }\n-    }\n+        let cflags = build.cflags(target, GitRepo::Rustc);\n \n-    // For all host triples we need to find a C++ compiler as well\n-    let hosts = build.hosts.iter().cloned().chain(iter::once(build.build)).collect::<HashSet<_>>();\n-    for host in hosts.into_iter() {\n+        // If we use llvm-libunwind, we will need a C++ compiler as well for all targets\n+        // We'll need one anyways if the target triple is also a host triple\n         let mut cfg = cc::Build::new();\n         cfg.cargo_metadata(false).opt_level(2).warnings(false).debug(false).cpp(true)\n-           .target(&host).host(&build.build);\n-        let config = build.config.target_config.get(&host);\n-        if let Some(cxx) = config.and_then(|c| c.cxx.as_ref()) {\n+            .target(&target).host(&build.build);\n+\n+        let cxx_configured = if let Some(cxx) = config.and_then(|c| c.cxx.as_ref()) {\n             cfg.compiler(cxx);\n+            true\n+        } else if build.hosts.contains(&target) || build.build == target {\n+            set_compiler(&mut cfg, Language::CPlusPlus, target, config, build);\n+            true\n         } else {\n-            set_compiler(&mut cfg, Language::CPlusPlus, host, config, build);\n+            false\n+        };\n+\n+        if cxx_configured {\n+            let compiler = cfg.get_compiler();\n+            build.cxx.insert(target, compiler);\n+        }\n+\n+        build.verbose(&format!(\"CC_{} = {:?}\", &target, build.cc(target)));\n+        build.verbose(&format!(\"CFLAGS_{} = {:?}\", &target, cflags));\n+        if let Ok(cxx) = build.cxx(target) {\n+            build.verbose(&format!(\"CXX_{} = {:?}\", &target, cxx));\n+            build.verbose(&format!(\"CXXFLAGS_{} = {:?}\", &target, cflags));\n+        }\n+        if let Some(ar) = ar {\n+            build.verbose(&format!(\"AR_{} = {:?}\", &target, ar));\n+            build.ar.insert(target, ar);\n         }\n-        let compiler = cfg.get_compiler();\n-        build.verbose(&format!(\"CXX_{} = {:?}\", host, compiler.path()));\n-        build.cxx.insert(host, compiler);\n     }\n }\n "}, {"sha": "8e8d8f5e787a7a0effa2488d705a1e7e1871d7ce", "filename": "src/bootstrap/channel.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fbootstrap%2Fchannel.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fbootstrap%2Fchannel.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fchannel.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -11,10 +11,9 @@ use std::process::Command;\n use build_helper::output;\n \n use crate::Build;\n-use crate::config::Config;\n \n // The version number\n-pub const CFG_RELEASE_NUM: &str = \"1.35.0\";\n+pub const CFG_RELEASE_NUM: &str = \"1.38.0\";\n \n pub struct GitInfo {\n     inner: Option<Info>,\n@@ -27,20 +26,20 @@ struct Info {\n }\n \n impl GitInfo {\n-    pub fn new(config: &Config, dir: &Path) -> GitInfo {\n+    pub fn new(ignore_git: bool, dir: &Path) -> GitInfo {\n         // See if this even begins to look like a git dir\n-        if config.ignore_git || !dir.join(\".git\").exists() {\n+        if ignore_git || !dir.join(\".git\").exists() {\n             return GitInfo { inner: None }\n         }\n \n         // Make sure git commands work\n-        let out = Command::new(\"git\")\n-                          .arg(\"rev-parse\")\n-                          .current_dir(dir)\n-                          .output()\n-                          .expect(\"failed to spawn git\");\n-        if !out.status.success() {\n-            return GitInfo { inner: None }\n+        match Command::new(\"git\")\n+            .arg(\"rev-parse\")\n+            .current_dir(dir)\n+            .output()\n+        {\n+            Ok(ref out) if out.status.success() => {}\n+            _ => return GitInfo { inner: None },\n         }\n \n         // Ok, let's scrape some info"}, {"sha": "11b082ac3f6d8ad226e162f99e630c2b15eb440b", "filename": "src/bootstrap/check.rs", "status": "modified", "additions": 30, "deletions": 12, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fbootstrap%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fbootstrap%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcheck.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -1,8 +1,8 @@\n-//! Implementation of compiling the compiler and standard library, in \"check\" mode.\n+//! Implementation of compiling the compiler and standard library, in \"check\"-based modes.\n \n use crate::compile::{run_cargo, std_cargo, test_cargo, rustc_cargo, rustc_cargo_env,\n                      add_to_sysroot};\n-use crate::builder::{RunConfig, Builder, ShouldRun, Step};\n+use crate::builder::{RunConfig, Builder, Kind, ShouldRun, Step};\n use crate::tool::{prepare_tool_cargo, SourceType};\n use crate::{Compiler, Mode};\n use crate::cache::{INTERNER, Interned};\n@@ -13,6 +13,22 @@ pub struct Std {\n     pub target: Interned<String>,\n }\n \n+fn args(kind: Kind) -> Vec<String> {\n+    match kind {\n+        Kind::Clippy => vec![\"--\".to_owned(), \"--cap-lints\".to_owned(), \"warn\".to_owned()],\n+        _ => Vec::new()\n+    }\n+}\n+\n+fn cargo_subcommand(kind: Kind) -> &'static str {\n+    match kind {\n+        Kind::Check => \"check\",\n+        Kind::Clippy => \"clippy\",\n+        Kind::Fix => \"fix\",\n+        _ => unreachable!()\n+    }\n+}\n+\n impl Step for Std {\n     type Output = ();\n     const DEFAULT: bool = true;\n@@ -31,13 +47,13 @@ impl Step for Std {\n         let target = self.target;\n         let compiler = builder.compiler(0, builder.config.build);\n \n-        let mut cargo = builder.cargo(compiler, Mode::Std, target, \"check\");\n+        let mut cargo = builder.cargo(compiler, Mode::Std, target, cargo_subcommand(builder.kind));\n         std_cargo(builder, &compiler, target, &mut cargo);\n \n-        let _folder = builder.fold_output(|| format!(\"stage{}-std\", compiler.stage));\n         builder.info(&format!(\"Checking std artifacts ({} -> {})\", &compiler.host, target));\n         run_cargo(builder,\n                   &mut cargo,\n+                  args(builder.kind),\n                   &libstd_stamp(builder, compiler, target),\n                   true);\n \n@@ -78,13 +94,14 @@ impl Step for Rustc {\n \n         builder.ensure(Test { target });\n \n-        let mut cargo = builder.cargo(compiler, Mode::Rustc, target, \"check\");\n+        let mut cargo = builder.cargo(compiler, Mode::Rustc, target,\n+            cargo_subcommand(builder.kind));\n         rustc_cargo(builder, &mut cargo);\n \n-        let _folder = builder.fold_output(|| format!(\"stage{}-rustc\", compiler.stage));\n         builder.info(&format!(\"Checking compiler artifacts ({} -> {})\", &compiler.host, target));\n         run_cargo(builder,\n                   &mut cargo,\n+                  args(builder.kind),\n                   &librustc_stamp(builder, compiler, target),\n                   true);\n \n@@ -127,15 +144,16 @@ impl Step for CodegenBackend {\n \n         builder.ensure(Rustc { target });\n \n-        let mut cargo = builder.cargo(compiler, Mode::Codegen, target, \"check\");\n+        let mut cargo = builder.cargo(compiler, Mode::Codegen, target,\n+            cargo_subcommand(builder.kind));\n         cargo.arg(\"--manifest-path\").arg(builder.src.join(\"src/librustc_codegen_llvm/Cargo.toml\"));\n         rustc_cargo_env(builder, &mut cargo);\n \n         // We won't build LLVM if it's not available, as it shouldn't affect `check`.\n \n-        let _folder = builder.fold_output(|| format!(\"stage{}-rustc_codegen_llvm\", compiler.stage));\n         run_cargo(builder,\n                   &mut cargo,\n+                  args(builder.kind),\n                   &codegen_backend_stamp(builder, compiler, target, backend),\n                   true);\n     }\n@@ -166,13 +184,13 @@ impl Step for Test {\n \n         builder.ensure(Std { target });\n \n-        let mut cargo = builder.cargo(compiler, Mode::Test, target, \"check\");\n+        let mut cargo = builder.cargo(compiler, Mode::Test, target, cargo_subcommand(builder.kind));\n         test_cargo(builder, &compiler, target, &mut cargo);\n \n-        let _folder = builder.fold_output(|| format!(\"stage{}-test\", compiler.stage));\n         builder.info(&format!(\"Checking test artifacts ({} -> {})\", &compiler.host, target));\n         run_cargo(builder,\n                   &mut cargo,\n+                  args(builder.kind),\n                   &libtest_stamp(builder, compiler, target),\n                   true);\n \n@@ -212,15 +230,15 @@ impl Step for Rustdoc {\n                                            compiler,\n                                            Mode::ToolRustc,\n                                            target,\n-                                           \"check\",\n+                                           cargo_subcommand(builder.kind),\n                                            \"src/tools/rustdoc\",\n                                            SourceType::InTree,\n                                            &[]);\n \n-        let _folder = builder.fold_output(|| format!(\"stage{}-rustdoc\", compiler.stage));\n         println!(\"Checking rustdoc artifacts ({} -> {})\", &compiler.host, target);\n         run_cargo(builder,\n                   &mut cargo,\n+                  args(builder.kind),\n                   &rustdoc_stamp(builder, compiler, target),\n                   true);\n "}, {"sha": "73be8bfed8e8821e5730895e7d1315c707409214", "filename": "src/bootstrap/clean.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fbootstrap%2Fclean.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fbootstrap%2Fclean.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fclean.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -9,6 +9,8 @@ use std::fs;\n use std::io::{self, ErrorKind};\n use std::path::Path;\n \n+use build_helper::t;\n+\n use crate::Build;\n \n pub fn clean(build: &Build, all: bool) {"}, {"sha": "4cd793adaf574d2588db110f3ef9b60e547e2bd5", "filename": "src/bootstrap/compile.rs", "status": "modified", "additions": 94, "deletions": 34, "changes": 128, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fbootstrap%2Fcompile.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fbootstrap%2Fcompile.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fcompile.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -15,12 +15,13 @@ use std::path::{Path, PathBuf};\n use std::process::{Command, Stdio, exit};\n use std::str;\n \n-use build_helper::{output, mtime, up_to_date};\n+use build_helper::{output, mtime, t, up_to_date};\n use filetime::FileTime;\n+use serde::Deserialize;\n use serde_json;\n \n use crate::dist;\n-use crate::util::{exe, libdir, is_dylib};\n+use crate::util::{exe, is_dylib};\n use crate::{Compiler, Mode, GitRepo};\n use crate::native;\n \n@@ -69,20 +70,20 @@ impl Step for Std {\n \n         builder.ensure(StartupObjects { compiler, target });\n \n-        if builder.force_use_stage1(compiler, target) {\n-            let from = builder.compiler(1, builder.config.build);\n+        let compiler_to_use = builder.compiler_for(compiler.stage, compiler.host, target);\n+        if compiler_to_use != compiler {\n             builder.ensure(Std {\n-                compiler: from,\n+                compiler: compiler_to_use,\n                 target,\n             });\n-            builder.info(&format!(\"Uplifting stage1 std ({} -> {})\", from.host, target));\n+            builder.info(&format!(\"Uplifting stage1 std ({} -> {})\", compiler_to_use.host, target));\n \n             // Even if we're not building std this stage, the new sysroot must\n             // still contain the third party objects needed by various targets.\n             copy_third_party_objects(builder, &compiler, target);\n \n             builder.ensure(StdLink {\n-                compiler: from,\n+                compiler: compiler_to_use,\n                 target_compiler: compiler,\n                 target,\n             });\n@@ -94,11 +95,11 @@ impl Step for Std {\n         let mut cargo = builder.cargo(compiler, Mode::Std, target, \"build\");\n         std_cargo(builder, &compiler, target, &mut cargo);\n \n-        let _folder = builder.fold_output(|| format!(\"stage{}-std\", compiler.stage));\n         builder.info(&format!(\"Building stage{} std artifacts ({} -> {})\", compiler.stage,\n                 &compiler.host, target));\n         run_cargo(builder,\n                   &mut cargo,\n+                  vec![],\n                   &libstd_stamp(builder, compiler, target),\n                   false);\n \n@@ -127,6 +128,13 @@ fn copy_third_party_objects(builder: &Builder<'_>, compiler: &Compiler, target:\n                 &libdir.join(obj),\n             );\n         }\n+    } else if target.ends_with(\"-wasi\") {\n+        for &obj in &[\"crt1.o\"] {\n+            builder.copy(\n+                &builder.wasi_root(target).unwrap().join(\"lib/wasm32-wasi\").join(obj),\n+                &libdir.join(obj),\n+            );\n+        }\n     }\n \n     // Copies libunwind.a compiled to be linked wit x86_64-fortanix-unknown-sgx.\n@@ -153,16 +161,43 @@ pub fn std_cargo(builder: &Builder<'_>,\n         cargo.env(\"MACOSX_DEPLOYMENT_TARGET\", target);\n     }\n \n+    // Determine if we're going to compile in optimized C intrinsics to\n+    // the `compiler-builtins` crate. These intrinsics live in LLVM's\n+    // `compiler-rt` repository, but our `src/llvm-project` submodule isn't\n+    // always checked out, so we need to conditionally look for this. (e.g. if\n+    // an external LLVM is used we skip the LLVM submodule checkout).\n+    //\n+    // Note that this shouldn't affect the correctness of `compiler-builtins`,\n+    // but only its speed. Some intrinsics in C haven't been translated to Rust\n+    // yet but that's pretty rare. Other intrinsics have optimized\n+    // implementations in C which have only had slower versions ported to Rust,\n+    // so we favor the C version where we can, but it's not critical.\n+    //\n+    // If `compiler-rt` is available ensure that the `c` feature of the\n+    // `compiler-builtins` crate is enabled and it's configured to learn where\n+    // `compiler-rt` is located.\n+    let compiler_builtins_root = builder.src.join(\"src/llvm-project/compiler-rt\");\n+    let compiler_builtins_c_feature = if compiler_builtins_root.exists() {\n+        cargo.env(\"RUST_COMPILER_RT_ROOT\", &compiler_builtins_root);\n+        \" compiler-builtins-c\".to_string()\n+    } else {\n+        String::new()\n+    };\n+\n     if builder.no_std(target) == Some(true) {\n+        let mut features = \"compiler-builtins-mem\".to_string();\n+        features.push_str(&compiler_builtins_c_feature);\n+\n         // for no-std targets we only compile a few no_std crates\n         cargo\n             .args(&[\"-p\", \"alloc\"])\n             .arg(\"--manifest-path\")\n             .arg(builder.src.join(\"src/liballoc/Cargo.toml\"))\n             .arg(\"--features\")\n-            .arg(\"compiler-builtins-mem\");\n+            .arg(\"compiler-builtins-mem compiler-builtins-c\");\n     } else {\n-        let features = builder.std_features();\n+        let mut features = builder.std_features();\n+        features.push_str(&compiler_builtins_c_feature);\n \n         if compiler.stage != 0 && builder.config.sanitizers {\n             // This variable is used by the sanitizer runtime crates, e.g.\n@@ -188,6 +223,12 @@ pub fn std_cargo(builder: &Builder<'_>,\n                 cargo.env(\"MUSL_ROOT\", p);\n             }\n         }\n+\n+        if target.ends_with(\"-wasi\") {\n+            if let Some(p) = builder.wasi_root(target) {\n+                cargo.env(\"WASI_ROOT\", p);\n+            }\n+        }\n     }\n }\n \n@@ -284,7 +325,7 @@ impl Step for StartupObjects {\n     fn run(self, builder: &Builder<'_>) {\n         let for_compiler = self.compiler;\n         let target = self.target;\n-        if !target.contains(\"pc-windows-gnu\") {\n+        if !target.contains(\"windows-gnu\") {\n             return\n         }\n \n@@ -299,7 +340,7 @@ impl Step for StartupObjects {\n             if !up_to_date(src_file, dst_file) {\n                 let mut cmd = Command::new(&builder.initial_rustc);\n                 builder.run(cmd.env(\"RUSTC_BOOTSTRAP\", \"1\")\n-                            .arg(\"--cfg\").arg(\"stage0\")\n+                            .arg(\"--cfg\").arg(\"bootstrap\")\n                             .arg(\"--target\").arg(target)\n                             .arg(\"--emit=obj\")\n                             .arg(\"-o\").arg(dst_file)\n@@ -361,15 +402,16 @@ impl Step for Test {\n             return;\n         }\n \n-        if builder.force_use_stage1(compiler, target) {\n+        let compiler_to_use = builder.compiler_for(compiler.stage, compiler.host, target);\n+        if compiler_to_use != compiler {\n             builder.ensure(Test {\n-                compiler: builder.compiler(1, builder.config.build),\n+                compiler: compiler_to_use,\n                 target,\n             });\n             builder.info(\n                 &format!(\"Uplifting stage1 test ({} -> {})\", builder.config.build, target));\n             builder.ensure(TestLink {\n-                compiler: builder.compiler(1, builder.config.build),\n+                compiler: compiler_to_use,\n                 target_compiler: compiler,\n                 target,\n             });\n@@ -379,11 +421,11 @@ impl Step for Test {\n         let mut cargo = builder.cargo(compiler, Mode::Test, target, \"build\");\n         test_cargo(builder, &compiler, target, &mut cargo);\n \n-        let _folder = builder.fold_output(|| format!(\"stage{}-test\", compiler.stage));\n         builder.info(&format!(\"Building stage{} test artifacts ({} -> {})\", compiler.stage,\n                 &compiler.host, target));\n         run_cargo(builder,\n                   &mut cargo,\n+                  vec![],\n                   &libtest_stamp(builder, compiler, target),\n                   false);\n \n@@ -486,15 +528,16 @@ impl Step for Rustc {\n             return;\n         }\n \n-        if builder.force_use_stage1(compiler, target) {\n+        let compiler_to_use = builder.compiler_for(compiler.stage, compiler.host, target);\n+        if compiler_to_use != compiler {\n             builder.ensure(Rustc {\n-                compiler: builder.compiler(1, builder.config.build),\n+                compiler: compiler_to_use,\n                 target,\n             });\n             builder.info(&format!(\"Uplifting stage1 rustc ({} -> {})\",\n                 builder.config.build, target));\n             builder.ensure(RustcLink {\n-                compiler: builder.compiler(1, builder.config.build),\n+                compiler: compiler_to_use,\n                 target_compiler: compiler,\n                 target,\n             });\n@@ -510,11 +553,11 @@ impl Step for Rustc {\n         let mut cargo = builder.cargo(compiler, Mode::Rustc, target, \"build\");\n         rustc_cargo(builder, &mut cargo);\n \n-        let _folder = builder.fold_output(|| format!(\"stage{}-rustc\", compiler.stage));\n         builder.info(&format!(\"Building stage{} compiler artifacts ({} -> {})\",\n                  compiler.stage, &compiler.host, target));\n         run_cargo(builder,\n                   &mut cargo,\n+                  vec![],\n                   &librustc_stamp(builder, compiler, target),\n                   false);\n \n@@ -545,13 +588,6 @@ pub fn rustc_cargo_env(builder: &Builder<'_>, cargo: &mut Command) {\n     let libdir_relative = builder.config.libdir_relative().unwrap_or(Path::new(\"lib\"));\n     cargo.env(\"CFG_LIBDIR_RELATIVE\", libdir_relative);\n \n-    // If we're not building a compiler with debugging information then remove\n-    // these two env vars which would be set otherwise.\n-    if builder.config.rust_debuginfo_only_std {\n-        cargo.env_remove(\"RUSTC_DEBUGINFO\");\n-        cargo.env_remove(\"RUSTC_DEBUGINFO_LINES\");\n-    }\n-\n     if let Some(ref ver_date) = builder.rust_info.commit_date() {\n         cargo.env(\"CFG_VER_DATE\", ver_date);\n     }\n@@ -650,9 +686,10 @@ impl Step for CodegenBackend {\n             return;\n         }\n \n-        if builder.force_use_stage1(compiler, target) {\n+        let compiler_to_use = builder.compiler_for(compiler.stage, compiler.host, target);\n+        if compiler_to_use != compiler {\n             builder.ensure(CodegenBackend {\n-                compiler: builder.compiler(1, builder.config.build),\n+                compiler: compiler_to_use,\n                 target,\n                 backend,\n             });\n@@ -670,9 +707,9 @@ impl Step for CodegenBackend {\n \n         let tmp_stamp = out_dir.join(\".tmp.stamp\");\n \n-        let _folder = builder.fold_output(|| format!(\"stage{}-rustc_codegen_llvm\", compiler.stage));\n         let files = run_cargo(builder,\n                               cargo.arg(\"--features\").arg(features),\n+                              vec![],\n                               &tmp_stamp,\n                               false);\n         if builder.config.dry_run {\n@@ -734,6 +771,10 @@ pub fn build_codegen_backend(builder: &Builder<'_>,\n                     cargo.env(\"CFG_LLVM_ROOT\", s);\n                 }\n             }\n+            // Some LLVM linker flags (-L and -l) may be needed to link librustc_llvm.\n+            if let Some(ref s) = builder.config.llvm_ldflags {\n+                cargo.env(\"LLVM_LINKER_FLAGS\", s);\n+            }\n             // Building with a static libstdc++ is only supported on linux right now,\n             // not for MSVC or macOS\n             if builder.config.llvm_static_stdcpp &&\n@@ -988,13 +1029,13 @@ impl Step for Assemble {\n \n         // Link in all dylibs to the libdir\n         let sysroot = builder.sysroot(target_compiler);\n-        let sysroot_libdir = sysroot.join(libdir(&*host));\n-        t!(fs::create_dir_all(&sysroot_libdir));\n+        let rustc_libdir = builder.rustc_libdir(target_compiler);\n+        t!(fs::create_dir_all(&rustc_libdir));\n         let src_libdir = builder.sysroot_libdir(build_compiler, host);\n         for f in builder.read_dir(&src_libdir) {\n             let filename = f.file_name().into_string().unwrap();\n             if is_dylib(&filename) {\n-                builder.copy(&f.path(), &sysroot_libdir.join(&filename));\n+                builder.copy(&f.path(), &rustc_libdir.join(&filename));\n             }\n         }\n \n@@ -1043,6 +1084,7 @@ pub fn add_to_sysroot(\n \n pub fn run_cargo(builder: &Builder<'_>,\n                  cargo: &mut Command,\n+                 tail_args: Vec<String>,\n                  stamp: &Path,\n                  is_check: bool)\n     -> Vec<PathBuf>\n@@ -1065,7 +1107,7 @@ pub fn run_cargo(builder: &Builder<'_>,\n     // files we need to probe for later.\n     let mut deps = Vec::new();\n     let mut toplevel = Vec::new();\n-    let ok = stream_cargo(builder, cargo, &mut |msg| {\n+    let ok = stream_cargo(builder, cargo, tail_args, &mut |msg| {\n         let (filenames, crate_types) = match msg {\n             CargoMessage::CompilerArtifact {\n                 filenames,\n@@ -1074,12 +1116,17 @@ pub fn run_cargo(builder: &Builder<'_>,\n                 },\n                 ..\n             } => (filenames, crate_types),\n+            CargoMessage::CompilerMessage { message } => {\n+                eprintln!(\"{}\", message.rendered);\n+                return;\n+            }\n             _ => return,\n         };\n         for filename in filenames {\n             // Skip files like executables\n             if !filename.ends_with(\".rlib\") &&\n                !filename.ends_with(\".lib\") &&\n+               !filename.ends_with(\".a\") &&\n                !is_dylib(&filename) &&\n                !(is_check && filename.ends_with(\".rmeta\")) {\n                 continue;\n@@ -1201,6 +1248,7 @@ pub fn run_cargo(builder: &Builder<'_>,\n pub fn stream_cargo(\n     builder: &Builder<'_>,\n     cargo: &mut Command,\n+    tail_args: Vec<String>,\n     cb: &mut dyn FnMut(CargoMessage<'_>),\n ) -> bool {\n     if builder.config.dry_run {\n@@ -1211,6 +1259,10 @@ pub fn stream_cargo(\n     cargo.arg(\"--message-format\").arg(\"json\")\n          .stdout(Stdio::piped());\n \n+    for arg in tail_args {\n+        cargo.arg(arg);\n+    }\n+\n     builder.verbose(&format!(\"running: {:?}\", cargo));\n     let mut child = match cargo.spawn() {\n         Ok(child) => child,\n@@ -1257,5 +1309,13 @@ pub enum CargoMessage<'a> {\n     },\n     BuildScriptExecuted {\n         package_id: Cow<'a, str>,\n+    },\n+    CompilerMessage {\n+        message: ClippyMessage<'a>\n     }\n }\n+\n+#[derive(Deserialize)]\n+pub struct ClippyMessage<'a> {\n+    rendered: Cow<'a, str>,\n+}"}, {"sha": "a5bfafdfdb4dcf5b45e91b75dd25827b9fdab22f", "filename": "src/bootstrap/config.rs", "status": "modified", "additions": 60, "deletions": 52, "changes": 112, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fbootstrap%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fbootstrap%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfig.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -10,8 +10,9 @@ use std::path::{Path, PathBuf};\n use std::process;\n use std::cmp;\n \n-use num_cpus;\n+use build_helper::t;\n use toml;\n+use serde::Deserialize;\n use crate::cache::{INTERNER, Interned};\n use crate::flags::Flags;\n pub use crate::flags::Subcommand;\n@@ -48,8 +49,9 @@ pub struct Config {\n     pub exclude: Vec<PathBuf>,\n     pub rustc_error_format: Option<String>,\n     pub test_compare_mode: bool,\n+    pub llvm_libunwind: bool,\n \n-    pub run_host_only: bool,\n+    pub skip_only_host_steps: bool,\n \n     pub on_fail: Option<String>,\n     pub stage: Option<u32>,\n@@ -64,7 +66,6 @@ pub struct Config {\n     pub backtrace_on_ice: bool,\n \n     // llvm codegen options\n-    pub llvm_enabled: bool,\n     pub llvm_assertions: bool,\n     pub llvm_optimize: bool,\n     pub llvm_thin_lto: bool,\n@@ -74,7 +75,7 @@ pub struct Config {\n     pub llvm_link_shared: bool,\n     pub llvm_clang_cl: Option<String>,\n     pub llvm_targets: Option<String>,\n-    pub llvm_experimental_targets: String,\n+    pub llvm_experimental_targets: Option<String>,\n     pub llvm_link_jobs: Option<u32>,\n     pub llvm_version_suffix: Option<String>,\n     pub llvm_use_linker: Option<String>,\n@@ -94,15 +95,14 @@ pub struct Config {\n     pub rust_codegen_units: Option<u32>,\n     pub rust_codegen_units_std: Option<u32>,\n     pub rust_debug_assertions: bool,\n-    pub rust_debuginfo: bool,\n-    pub rust_debuginfo_lines: bool,\n-    pub rust_debuginfo_only_std: bool,\n-    pub rust_debuginfo_tools: bool,\n+    pub rust_debuginfo_level_rustc: u32,\n+    pub rust_debuginfo_level_std: u32,\n+    pub rust_debuginfo_level_tools: u32,\n+    pub rust_debuginfo_level_tests: u32,\n     pub rust_rpath: bool,\n     pub rustc_parallel: bool,\n     pub rustc_default_linker: Option<String>,\n     pub rust_optimize_tests: bool,\n-    pub rust_debuginfo_tests: bool,\n     pub rust_dist_src: bool,\n     pub rust_codegen_backends: Vec<Interned<String>>,\n     pub rust_codegen_backends_dir: String,\n@@ -128,7 +128,6 @@ pub struct Config {\n     pub low_priority: bool,\n     pub channel: String,\n     pub verbose_tests: bool,\n-    pub test_miri: bool,\n     pub save_toolstates: Option<PathBuf>,\n     pub print_step_timings: bool,\n     pub missing_tools: bool,\n@@ -170,6 +169,7 @@ pub struct Target {\n     pub ndk: Option<PathBuf>,\n     pub crt_static: Option<bool>,\n     pub musl_root: Option<PathBuf>,\n+    pub wasi_root: Option<PathBuf>,\n     pub qemu_rootfs: Option<PathBuf>,\n     pub no_std: bool,\n }\n@@ -244,7 +244,6 @@ struct Install {\n #[derive(Deserialize, Default)]\n #[serde(deny_unknown_fields, rename_all = \"kebab-case\")]\n struct Llvm {\n-    enabled: Option<bool>,\n     ccache: Option<StringOrBool>,\n     ninja: Option<bool>,\n     assertions: Option<bool>,\n@@ -298,24 +297,23 @@ struct Rust {\n     codegen_units: Option<u32>,\n     codegen_units_std: Option<u32>,\n     debug_assertions: Option<bool>,\n-    debuginfo: Option<bool>,\n-    debuginfo_lines: Option<bool>,\n-    debuginfo_only_std: Option<bool>,\n-    debuginfo_tools: Option<bool>,\n+    debuginfo_level: Option<u32>,\n+    debuginfo_level_rustc: Option<u32>,\n+    debuginfo_level_std: Option<u32>,\n+    debuginfo_level_tools: Option<u32>,\n+    debuginfo_level_tests: Option<u32>,\n     parallel_compiler: Option<bool>,\n     backtrace: Option<bool>,\n     default_linker: Option<String>,\n     channel: Option<String>,\n     musl_root: Option<String>,\n     rpath: Option<bool>,\n     optimize_tests: Option<bool>,\n-    debuginfo_tests: Option<bool>,\n     codegen_tests: Option<bool>,\n     ignore_git: Option<bool>,\n     debug: Option<bool>,\n     dist_src: Option<bool>,\n     verbose_tests: Option<bool>,\n-    test_miri: Option<bool>,\n     incremental: Option<bool>,\n     save_toolstates: Option<String>,\n     codegen_backends: Option<Vec<String>>,\n@@ -330,6 +328,7 @@ struct Rust {\n     remap_debuginfo: Option<bool>,\n     jemalloc: Option<bool>,\n     test_compare_mode: Option<bool>,\n+    llvm_libunwind: Option<bool>,\n }\n \n /// TOML representation of how each build target is configured.\n@@ -346,6 +345,7 @@ struct TomlTarget {\n     android_ndk: Option<String>,\n     crt_static: Option<bool>,\n     musl_root: Option<String>,\n+    wasi_root: Option<String>,\n     qemu_rootfs: Option<String>,\n }\n \n@@ -360,7 +360,6 @@ impl Config {\n \n     pub fn default_opts() -> Config {\n         let mut config = Config::default();\n-        config.llvm_enabled = true;\n         config.llvm_optimize = true;\n         config.llvm_version_check = true;\n         config.backtrace = true;\n@@ -374,7 +373,6 @@ impl Config {\n         config.codegen_tests = true;\n         config.ignore_git = false;\n         config.rust_dist_src = true;\n-        config.test_miri = false;\n         config.rust_codegen_backends = vec![INTERNER.intern_str(\"llvm\")];\n         config.rust_codegen_backends_dir = \"codegen-backends\".to_owned();\n         config.deny_warnings = true;\n@@ -399,12 +397,12 @@ impl Config {\n         config.rustc_error_format = flags.rustc_error_format;\n         config.on_fail = flags.on_fail;\n         config.stage = flags.stage;\n-        config.jobs = flags.jobs;\n+        config.jobs = flags.jobs.map(threads_from_config);\n         config.cmd = flags.cmd;\n         config.incremental = flags.incremental;\n         config.dry_run = flags.dry_run;\n         config.keep_stage = flags.keep_stage;\n-        if let Some(value) = flags.warnings {\n+        if let Some(value) = flags.deny_warnings {\n             config.deny_warnings = value;\n         }\n \n@@ -415,7 +413,9 @@ impl Config {\n         }\n \n         // If --target was specified but --host wasn't specified, don't run any host-only tests.\n-        config.run_host_only = !(flags.host.is_empty() && !flags.target.is_empty());\n+        let has_hosts = !flags.host.is_empty();\n+        let has_targets = !flags.target.is_empty();\n+        config.skip_only_host_steps = !has_hosts && has_targets;\n \n         let toml = file.map(|file| {\n             let contents = t!(fs::read_to_string(&file));\n@@ -492,12 +492,13 @@ impl Config {\n         // Store off these values as options because if they're not provided\n         // we'll infer default values for them later\n         let mut llvm_assertions = None;\n-        let mut debuginfo_lines = None;\n-        let mut debuginfo_only_std = None;\n-        let mut debuginfo_tools = None;\n         let mut debug = None;\n-        let mut debuginfo = None;\n         let mut debug_assertions = None;\n+        let mut debuginfo_level = None;\n+        let mut debuginfo_level_rustc = None;\n+        let mut debuginfo_level_std = None;\n+        let mut debuginfo_level_tools = None;\n+        let mut debuginfo_level_tests = None;\n         let mut optimize = None;\n         let mut ignore_git = None;\n \n@@ -512,7 +513,6 @@ impl Config {\n                 Some(StringOrBool::Bool(false)) | None => {}\n             }\n             set(&mut config.ninja, llvm.ninja);\n-            set(&mut config.llvm_enabled, llvm.enabled);\n             llvm_assertions = llvm.assertions;\n             set(&mut config.llvm_optimize, llvm.optimize);\n             set(&mut config.llvm_thin_lto, llvm.thin_lto);\n@@ -521,8 +521,7 @@ impl Config {\n             set(&mut config.llvm_static_stdcpp, llvm.static_libstdcpp);\n             set(&mut config.llvm_link_shared, llvm.link_shared);\n             config.llvm_targets = llvm.targets.clone();\n-            config.llvm_experimental_targets = llvm.experimental_targets.clone()\n-                .unwrap_or_else(|| \"WebAssembly;RISCV\".to_string());\n+            config.llvm_experimental_targets = llvm.experimental_targets.clone();\n             config.llvm_link_jobs = llvm.link_jobs;\n             config.llvm_version_suffix = llvm.version_suffix.clone();\n             config.llvm_clang_cl = llvm.clang_cl.clone();\n@@ -538,23 +537,23 @@ impl Config {\n         if let Some(ref rust) = toml.rust {\n             debug = rust.debug;\n             debug_assertions = rust.debug_assertions;\n-            debuginfo = rust.debuginfo;\n-            debuginfo_lines = rust.debuginfo_lines;\n-            debuginfo_only_std = rust.debuginfo_only_std;\n-            debuginfo_tools = rust.debuginfo_tools;\n+            debuginfo_level = rust.debuginfo_level;\n+            debuginfo_level_rustc = rust.debuginfo_level_rustc;\n+            debuginfo_level_std = rust.debuginfo_level_std;\n+            debuginfo_level_tools = rust.debuginfo_level_tools;\n+            debuginfo_level_tests = rust.debuginfo_level_tests;\n             optimize = rust.optimize;\n             ignore_git = rust.ignore_git;\n             set(&mut config.rust_optimize_tests, rust.optimize_tests);\n-            set(&mut config.rust_debuginfo_tests, rust.debuginfo_tests);\n             set(&mut config.codegen_tests, rust.codegen_tests);\n             set(&mut config.rust_rpath, rust.rpath);\n             set(&mut config.jemalloc, rust.jemalloc);\n             set(&mut config.test_compare_mode, rust.test_compare_mode);\n+            set(&mut config.llvm_libunwind, rust.llvm_libunwind);\n             set(&mut config.backtrace, rust.backtrace);\n             set(&mut config.channel, rust.channel.clone());\n             set(&mut config.rust_dist_src, rust.dist_src);\n             set(&mut config.verbose_tests, rust.verbose_tests);\n-            set(&mut config.test_miri, rust.test_miri);\n             // in the case \"false\" is set explicitly, do not overwrite the command line args\n             if let Some(true) = rust.incremental {\n                 config.incremental = true;\n@@ -567,7 +566,7 @@ impl Config {\n             config.rustc_default_linker = rust.default_linker.clone();\n             config.musl_root = rust.musl_root.clone().map(PathBuf::from);\n             config.save_toolstates = rust.save_toolstates.clone().map(PathBuf::from);\n-            set(&mut config.deny_warnings, rust.deny_warnings.or(flags.warnings));\n+            set(&mut config.deny_warnings, flags.deny_warnings.or(rust.deny_warnings));\n             set(&mut config.backtrace_on_ice, rust.backtrace_on_ice);\n             set(&mut config.rust_verify_llvm_ir, rust.verify_llvm_ir);\n             set(&mut config.rust_remap_debuginfo, rust.remap_debuginfo);\n@@ -580,13 +579,8 @@ impl Config {\n \n             set(&mut config.rust_codegen_backends_dir, rust.codegen_backends_dir.clone());\n \n-            match rust.codegen_units {\n-                Some(0) => config.rust_codegen_units = Some(num_cpus::get() as u32),\n-                Some(n) => config.rust_codegen_units = Some(n),\n-                None => {}\n-            }\n-\n-            config.rust_codegen_units_std = rust.codegen_units_std;\n+            config.rust_codegen_units = rust.codegen_units.map(threads_from_config);\n+            config.rust_codegen_units_std = rust.codegen_units_std.map(threads_from_config);\n         }\n \n         if let Some(ref t) = toml.target {\n@@ -609,6 +603,7 @@ impl Config {\n                 target.linker = cfg.linker.clone().map(PathBuf::from);\n                 target.crt_static = cfg.crt_static.clone();\n                 target.musl_root = cfg.musl_root.clone().map(PathBuf::from);\n+                target.wasi_root = cfg.wasi_root.clone().map(PathBuf::from);\n                 target.qemu_rootfs = cfg.qemu_rootfs.clone().map(PathBuf::from);\n \n                 config.target_config.insert(INTERNER.intern_string(triple.clone()), target);\n@@ -635,18 +630,19 @@ impl Config {\n         let default = true;\n         config.rust_optimize = optimize.unwrap_or(default);\n \n-        let default = match &config.channel[..] {\n-            \"stable\" | \"beta\" | \"nightly\" => true,\n-            _ => false,\n-        };\n-        config.rust_debuginfo_lines = debuginfo_lines.unwrap_or(default);\n-        config.rust_debuginfo_only_std = debuginfo_only_std.unwrap_or(default);\n-        config.rust_debuginfo_tools = debuginfo_tools.unwrap_or(false);\n-\n         let default = debug == Some(true);\n-        config.rust_debuginfo = debuginfo.unwrap_or(default);\n         config.rust_debug_assertions = debug_assertions.unwrap_or(default);\n \n+        let with_defaults = |debuginfo_level_specific: Option<u32>| {\n+            debuginfo_level_specific\n+                .or(debuginfo_level)\n+                .unwrap_or(if debug == Some(true) { 2 } else { 0 })\n+        };\n+        config.rust_debuginfo_level_rustc = with_defaults(debuginfo_level_rustc);\n+        config.rust_debuginfo_level_std = with_defaults(debuginfo_level_std);\n+        config.rust_debuginfo_level_tools = with_defaults(debuginfo_level_tools);\n+        config.rust_debuginfo_level_tests = debuginfo_level_tests.unwrap_or(0);\n+\n         let default = config.channel == \"dev\";\n         config.ignore_git = ignore_git.unwrap_or(default);\n \n@@ -671,10 +667,22 @@ impl Config {\n     pub fn very_verbose(&self) -> bool {\n         self.verbose > 1\n     }\n+\n+    pub fn llvm_enabled(&self) -> bool {\n+        self.rust_codegen_backends.contains(&INTERNER.intern_str(\"llvm\"))\n+        || self.rust_codegen_backends.contains(&INTERNER.intern_str(\"emscripten\"))\n+    }\n }\n \n fn set<T>(field: &mut T, val: Option<T>) {\n     if let Some(v) = val {\n         *field = v;\n     }\n }\n+\n+fn threads_from_config(v: u32) -> u32 {\n+    match v {\n+        0 => num_cpus::get() as u32,\n+        n => n,\n+    }\n+}"}, {"sha": "346f0cb2039c08ccbd8d17826cc7af7c24f84a75", "filename": "src/bootstrap/configure.py", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fbootstrap%2Fconfigure.py", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fbootstrap%2Fconfigure.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fconfigure.py?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -36,8 +36,6 @@ def v(*args):\n o(\"compiler-docs\", \"build.compiler-docs\", \"build compiler documentation\")\n o(\"optimize-tests\", \"rust.optimize-tests\", \"build tests with optimizations\")\n o(\"parallel-compiler\", \"rust.parallel-compiler\", \"build a multi-threaded rustc\")\n-o(\"test-miri\", \"rust.test-miri\", \"run miri's test suite\")\n-o(\"debuginfo-tests\", \"rust.debuginfo-tests\", \"build tests with debugger metadata\")\n o(\"verbose-tests\", \"rust.verbose-tests\", \"enable verbose output when running tests\")\n o(\"ccache\", \"llvm.ccache\", \"invoke gcc/clang via ccache to reuse object files between builds\")\n o(\"sccache\", None, \"invoke gcc/clang via sccache to reuse object files between builds\")\n@@ -68,17 +66,20 @@ def v(*args):\n o(\"cxxflags\", \"llvm.cxxflags\", \"build LLVM with these extra compiler flags\")\n o(\"ldflags\", \"llvm.ldflags\", \"build LLVM with these extra linker flags\")\n \n+o(\"llvm-libunwind\", \"rust.llvm_libunwind\", \"use LLVM libunwind\")\n+\n # Optimization and debugging options. These may be overridden by the release\n # channel, etc.\n o(\"optimize\", \"rust.optimize\", \"build optimized rust code\")\n o(\"optimize-llvm\", \"llvm.optimize\", \"build optimized LLVM\")\n o(\"llvm-assertions\", \"llvm.assertions\", \"build LLVM with assertions\")\n o(\"debug-assertions\", \"rust.debug-assertions\", \"build with debugging assertions\")\n o(\"llvm-release-debuginfo\", \"llvm.release-debuginfo\", \"build LLVM with debugger metadata\")\n-o(\"debuginfo\", \"rust.debuginfo\", \"build with debugger metadata\")\n-o(\"debuginfo-lines\", \"rust.debuginfo-lines\", \"build with line number debugger metadata\")\n-o(\"debuginfo-only-std\", \"rust.debuginfo-only-std\", \"build only libstd with debugging information\")\n-o(\"debuginfo-tools\", \"rust.debuginfo-tools\", \"build extended tools with debugging information\")\n+v(\"debuginfo-level\", \"rust.debuginfo-level\", \"debuginfo level for Rust code\")\n+v(\"debuginfo-level-rustc\", \"rust.debuginfo-level-rustc\", \"debuginfo level for the compiler\")\n+v(\"debuginfo-level-std\", \"rust.debuginfo-level-std\", \"debuginfo level for the standard library\")\n+v(\"debuginfo-level-tools\", \"rust.debuginfo-level-tools\", \"debuginfo level for the tools\")\n+v(\"debuginfo-level-tests\", \"rust.debuginfo-level-tests\", \"debuginfo level for the test suites run with compiletest\")\n v(\"save-toolstates\", \"rust.save-toolstates\", \"save build and test status of external tools into this file\")\n \n v(\"prefix\", \"install.prefix\", \"set installation prefix\")\n@@ -123,7 +124,9 @@ def v(*args):\n   \"arm-unknown-linux-musleabihf install directory\")\n v(\"musl-root-armv5te\", \"target.armv5te-unknown-linux-musleabi.musl-root\",\n   \"armv5te-unknown-linux-musleabi install directory\")\n-v(\"musl-root-armv7\", \"target.armv7-unknown-linux-musleabihf.musl-root\",\n+v(\"musl-root-armv7\", \"target.armv7-unknown-linux-musleabi.musl-root\",\n+  \"armv7-unknown-linux-musleabi install directory\")\n+v(\"musl-root-armv7hf\", \"target.armv7-unknown-linux-musleabihf.musl-root\",\n   \"armv7-unknown-linux-musleabihf install directory\")\n v(\"musl-root-aarch64\", \"target.aarch64-unknown-linux-musl.musl-root\",\n   \"aarch64-unknown-linux-musl install directory\")"}, {"sha": "bd012a887c26ee70fbfb53577c765850397cf217", "filename": "src/bootstrap/dist.rs", "status": "modified", "additions": 100, "deletions": 101, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fbootstrap%2Fdist.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fbootstrap%2Fdist.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdist.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -14,11 +14,11 @@ use std::io::Write;\n use std::path::{PathBuf, Path};\n use std::process::{Command, Stdio};\n \n-use build_helper::output;\n+use build_helper::{output, t};\n \n use crate::{Compiler, Mode, LLVM_TOOLS};\n use crate::channel;\n-use crate::util::{libdir, is_dylib, exe};\n+use crate::util::{is_dylib, exe};\n use crate::builder::{Builder, RunConfig, ShouldRun, Step};\n use crate::compile;\n use crate::tool::{self, Tool};\n@@ -68,7 +68,6 @@ fn missing_tool(tool_name: &str, skip: bool) {\n \n #[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Docs {\n-    pub stage: u32,\n     pub host: Interned<String>,\n }\n \n@@ -82,7 +81,6 @@ impl Step for Docs {\n \n     fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Docs {\n-            stage: run.builder.top_stage,\n             host: run.target,\n         });\n     }\n@@ -130,7 +128,6 @@ impl Step for Docs {\n \n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct RustcDocs {\n-    pub stage: u32,\n     pub host: Interned<String>,\n }\n \n@@ -144,7 +141,6 @@ impl Step for RustcDocs {\n \n     fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(RustcDocs {\n-            stage: run.builder.top_stage,\n             host: run.target,\n         });\n     }\n@@ -473,21 +469,23 @@ impl Step for Rustc {\n         fn prepare_image(builder: &Builder<'_>, compiler: Compiler, image: &Path) {\n             let host = compiler.host;\n             let src = builder.sysroot(compiler);\n-            let libdir = libdir(&host);\n+            let libdir = builder.rustc_libdir(compiler);\n \n             // Copy rustc/rustdoc binaries\n             t!(fs::create_dir_all(image.join(\"bin\")));\n             builder.cp_r(&src.join(\"bin\"), &image.join(\"bin\"));\n \n-            builder.install(&builder.rustdoc(compiler.host), &image.join(\"bin\"), 0o755);\n+            builder.install(&builder.rustdoc(compiler), &image.join(\"bin\"), 0o755);\n+\n+            let libdir_relative = builder.libdir_relative(compiler);\n \n             // Copy runtime DLLs needed by the compiler\n-            if libdir != \"bin\" {\n-                for entry in builder.read_dir(&src.join(libdir)) {\n+            if libdir_relative.to_str() != Some(\"bin\") {\n+                for entry in builder.read_dir(&libdir) {\n                     let name = entry.file_name();\n                     if let Some(s) = name.to_str() {\n                         if is_dylib(s) {\n-                            builder.install(&entry.path(), &image.join(libdir), 0o644);\n+                            builder.install(&entry.path(), &image.join(&libdir_relative), 0o644);\n                         }\n                     }\n                 }\n@@ -645,7 +643,11 @@ impl Step for Std {\n \n     fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Std {\n-            compiler: run.builder.compiler(run.builder.top_stage, run.builder.config.build),\n+            compiler: run.builder.compiler_for(\n+                run.builder.top_stage,\n+                run.builder.config.build,\n+                run.target,\n+            ),\n             target: run.target,\n         });\n     }\n@@ -735,7 +737,14 @@ impl Step for Analysis {\n \n     fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Analysis {\n-            compiler: run.builder.compiler(run.builder.top_stage, run.builder.config.build),\n+            // Find the actual compiler (handling the full bootstrap option) which\n+            // produced the save-analysis data because that data isn't copied\n+            // through the sysroot uplifting.\n+            compiler: run.builder.compiler_for(\n+                run.builder.top_stage,\n+                run.builder.config.build,\n+                run.target,\n+            ),\n             target: run.target,\n         });\n     }\n@@ -755,14 +764,6 @@ impl Step for Analysis {\n \n         builder.ensure(Std { compiler, target });\n \n-        // Package save-analysis from stage1 if not doing a full bootstrap, as the\n-        // stage2 artifacts is simply copied from stage1 in that case.\n-        let compiler = if builder.force_use_stage1(compiler, target) {\n-            builder.compiler(1, compiler.host)\n-        } else {\n-            compiler.clone()\n-        };\n-\n         let image = tmpdir(builder).join(format!(\"{}-{}-image\", name, target));\n \n         let src = builder.stage_out(compiler, Mode::Std)\n@@ -803,6 +804,7 @@ fn copy_src_dirs(builder: &Builder<'_>, src_dirs: &[&str], exclude_dirs: &[&str]\n \n         const LLVM_PROJECTS: &[&str] = &[\n             \"llvm-project/clang\", \"llvm-project\\\\clang\",\n+            \"llvm-project/libunwind\", \"llvm-project\\\\libunwind\",\n             \"llvm-project/lld\", \"llvm-project\\\\lld\",\n             \"llvm-project/lldb\", \"llvm-project\\\\lldb\",\n             \"llvm-project/llvm\", \"llvm-project\\\\llvm\",\n@@ -901,9 +903,10 @@ impl Step for Src {\n             \"src/libtest\",\n             \"src/libterm\",\n             \"src/libprofiler_builtins\",\n-            \"src/stdsimd\",\n+            \"src/stdarch\",\n             \"src/libproc_macro\",\n             \"src/tools/rustc-std-workspace-core\",\n+            \"src/tools/rustc-std-workspace-alloc\",\n             \"src/librustc\",\n             \"src/libsyntax\",\n         ];\n@@ -932,8 +935,6 @@ impl Step for Src {\n     }\n }\n \n-const CARGO_VENDOR_VERSION: &str = \"0.1.22\";\n-\n #[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct PlainSourceTarball;\n \n@@ -995,26 +996,6 @@ impl Step for PlainSourceTarball {\n \n         // If we're building from git sources, we need to vendor a complete distribution.\n         if builder.rust_info.is_git() {\n-            // Get cargo-vendor installed, if it isn't already.\n-            let mut has_cargo_vendor = false;\n-            let mut cmd = Command::new(&builder.initial_cargo);\n-            for line in output(cmd.arg(\"install\").arg(\"--list\")).lines() {\n-                has_cargo_vendor |= line.starts_with(\"cargo-vendor \");\n-            }\n-            if !has_cargo_vendor {\n-                let mut cmd = builder.cargo(\n-                    builder.compiler(0, builder.config.build),\n-                    Mode::ToolBootstrap,\n-                    builder.config.build,\n-                    \"install\"\n-                );\n-                cmd.arg(\"--force\")\n-                   .arg(\"--debug\")\n-                   .arg(\"--vers\").arg(CARGO_VENDOR_VERSION)\n-                   .arg(\"cargo-vendor\");\n-                builder.run(&mut cmd);\n-            }\n-\n             // Vendor all Cargo dependencies\n             let mut cmd = Command::new(&builder.initial_cargo);\n             cmd.arg(\"vendor\")\n@@ -1063,7 +1044,7 @@ pub fn sanitize_sh(path: &Path) -> String {\n \n #[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Cargo {\n-    pub stage: u32,\n+    pub compiler: Compiler,\n     pub target: Interned<String>,\n }\n \n@@ -1077,16 +1058,20 @@ impl Step for Cargo {\n \n     fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Cargo {\n-            stage: run.builder.top_stage,\n+            compiler: run.builder.compiler_for(\n+                run.builder.top_stage,\n+                run.builder.config.build,\n+                run.target,\n+            ),\n             target: run.target,\n         });\n     }\n \n     fn run(self, builder: &Builder<'_>) -> PathBuf {\n-        let stage = self.stage;\n+        let compiler = self.compiler;\n         let target = self.target;\n \n-        builder.info(&format!(\"Dist cargo stage{} ({})\", stage, target));\n+        builder.info(&format!(\"Dist cargo stage{} ({})\", compiler.stage, target));\n         let src = builder.src.join(\"src/tools/cargo\");\n         let etc = src.join(\"src/etc\");\n         let release_num = builder.release_num(\"cargo\");\n@@ -1101,10 +1086,7 @@ impl Step for Cargo {\n         // Prepare the image directory\n         builder.create_dir(&image.join(\"share/zsh/site-functions\"));\n         builder.create_dir(&image.join(\"etc/bash_completion.d\"));\n-        let cargo = builder.ensure(tool::Cargo {\n-            compiler: builder.compiler(stage, builder.config.build),\n-            target\n-        });\n+        let cargo = builder.ensure(tool::Cargo { compiler, target });\n         builder.install(&cargo, &image.join(\"bin\"), 0o755);\n         for man in t!(etc.join(\"man\").read_dir()) {\n             let man = t!(man);\n@@ -1149,7 +1131,7 @@ impl Step for Cargo {\n \n #[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Rls {\n-    pub stage: u32,\n+    pub compiler: Compiler,\n     pub target: Interned<String>,\n }\n \n@@ -1163,17 +1145,21 @@ impl Step for Rls {\n \n     fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Rls {\n-            stage: run.builder.top_stage,\n+            compiler: run.builder.compiler_for(\n+                run.builder.top_stage,\n+                run.builder.config.build,\n+                run.target,\n+            ),\n             target: run.target,\n         });\n     }\n \n     fn run(self, builder: &Builder<'_>) -> Option<PathBuf> {\n-        let stage = self.stage;\n+        let compiler = self.compiler;\n         let target = self.target;\n         assert!(builder.config.extended);\n \n-        builder.info(&format!(\"Dist RLS stage{} ({})\", stage, target));\n+        builder.info(&format!(\"Dist RLS stage{} ({})\", compiler.stage, target));\n         let src = builder.src.join(\"src/tools/rls\");\n         let release_num = builder.release_num(\"rls\");\n         let name = pkgname(builder, \"rls\");\n@@ -1188,8 +1174,9 @@ impl Step for Rls {\n         // We expect RLS to build, because we've exited this step above if tool\n         // state for RLS isn't testing.\n         let rls = builder.ensure(tool::Rls {\n-            compiler: builder.compiler(stage, builder.config.build),\n-            target, extra_features: Vec::new()\n+            compiler,\n+            target,\n+            extra_features: Vec::new(),\n         }).or_else(|| { missing_tool(\"RLS\", builder.build.config.missing_tools); None })?;\n \n         builder.install(&rls, &image.join(\"bin\"), 0o755);\n@@ -1228,7 +1215,7 @@ impl Step for Rls {\n \n #[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Clippy {\n-    pub stage: u32,\n+    pub compiler: Compiler,\n     pub target: Interned<String>,\n }\n \n@@ -1242,17 +1229,21 @@ impl Step for Clippy {\n \n     fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Clippy {\n-            stage: run.builder.top_stage,\n+            compiler: run.builder.compiler_for(\n+                run.builder.top_stage,\n+                run.builder.config.build,\n+                run.target,\n+            ),\n             target: run.target,\n         });\n     }\n \n     fn run(self, builder: &Builder<'_>) -> Option<PathBuf> {\n-        let stage = self.stage;\n+        let compiler = self.compiler;\n         let target = self.target;\n         assert!(builder.config.extended);\n \n-        builder.info(&format!(\"Dist clippy stage{} ({})\", stage, target));\n+        builder.info(&format!(\"Dist clippy stage{} ({})\", compiler.stage, target));\n         let src = builder.src.join(\"src/tools/clippy\");\n         let release_num = builder.release_num(\"clippy\");\n         let name = pkgname(builder, \"clippy\");\n@@ -1267,11 +1258,12 @@ impl Step for Clippy {\n         // We expect clippy to build, because we've exited this step above if tool\n         // state for clippy isn't testing.\n         let clippy = builder.ensure(tool::Clippy {\n-            compiler: builder.compiler(stage, builder.config.build),\n-            target, extra_features: Vec::new()\n+            compiler,\n+            target,\n+            extra_features: Vec::new(),\n         }).or_else(|| { missing_tool(\"clippy\", builder.build.config.missing_tools); None })?;\n         let cargoclippy = builder.ensure(tool::CargoClippy {\n-            compiler: builder.compiler(stage, builder.config.build),\n+            compiler,\n             target, extra_features: Vec::new()\n         }).or_else(|| { missing_tool(\"cargo clippy\", builder.build.config.missing_tools); None })?;\n \n@@ -1312,7 +1304,7 @@ impl Step for Clippy {\n \n #[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Miri {\n-    pub stage: u32,\n+    pub compiler: Compiler,\n     pub target: Interned<String>,\n }\n \n@@ -1326,17 +1318,21 @@ impl Step for Miri {\n \n     fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Miri {\n-            stage: run.builder.top_stage,\n+            compiler: run.builder.compiler_for(\n+                run.builder.top_stage,\n+                run.builder.config.build,\n+                run.target,\n+            ),\n             target: run.target,\n         });\n     }\n \n     fn run(self, builder: &Builder<'_>) -> Option<PathBuf> {\n-        let stage = self.stage;\n+        let compiler = self.compiler;\n         let target = self.target;\n         assert!(builder.config.extended);\n \n-        builder.info(&format!(\"Dist miri stage{} ({})\", stage, target));\n+        builder.info(&format!(\"Dist miri stage{} ({})\", compiler.stage, target));\n         let src = builder.src.join(\"src/tools/miri\");\n         let release_num = builder.release_num(\"miri\");\n         let name = pkgname(builder, \"miri\");\n@@ -1351,12 +1347,14 @@ impl Step for Miri {\n         // We expect miri to build, because we've exited this step above if tool\n         // state for miri isn't testing.\n         let miri = builder.ensure(tool::Miri {\n-            compiler: builder.compiler(stage, builder.config.build),\n-            target, extra_features: Vec::new()\n+            compiler,\n+            target,\n+            extra_features: Vec::new(),\n         }).or_else(|| { missing_tool(\"miri\", builder.build.config.missing_tools); None })?;\n         let cargomiri = builder.ensure(tool::CargoMiri {\n-            compiler: builder.compiler(stage, builder.config.build),\n-            target, extra_features: Vec::new()\n+            compiler,\n+            target,\n+            extra_features: Vec::new()\n         }).or_else(|| { missing_tool(\"cargo miri\", builder.build.config.missing_tools); None })?;\n \n         builder.install(&miri, &image.join(\"bin\"), 0o755);\n@@ -1396,7 +1394,7 @@ impl Step for Miri {\n \n #[derive(Debug, PartialOrd, Ord, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Rustfmt {\n-    pub stage: u32,\n+    pub compiler: Compiler,\n     pub target: Interned<String>,\n }\n \n@@ -1410,16 +1408,20 @@ impl Step for Rustfmt {\n \n     fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Rustfmt {\n-            stage: run.builder.top_stage,\n+            compiler: run.builder.compiler_for(\n+                run.builder.top_stage,\n+                run.builder.config.build,\n+                run.target,\n+            ),\n             target: run.target,\n         });\n     }\n \n     fn run(self, builder: &Builder<'_>) -> Option<PathBuf> {\n-        let stage = self.stage;\n+        let compiler = self.compiler;\n         let target = self.target;\n \n-        builder.info(&format!(\"Dist Rustfmt stage{} ({})\", stage, target));\n+        builder.info(&format!(\"Dist Rustfmt stage{} ({})\", compiler.stage, target));\n         let src = builder.src.join(\"src/tools/rustfmt\");\n         let release_num = builder.release_num(\"rustfmt\");\n         let name = pkgname(builder, \"rustfmt\");\n@@ -1432,12 +1434,14 @@ impl Step for Rustfmt {\n \n         // Prepare the image directory\n         let rustfmt = builder.ensure(tool::Rustfmt {\n-            compiler: builder.compiler(stage, builder.config.build),\n-            target, extra_features: Vec::new()\n+            compiler,\n+            target,\n+            extra_features: Vec::new(),\n         }).or_else(|| { missing_tool(\"Rustfmt\", builder.build.config.missing_tools); None })?;\n         let cargofmt = builder.ensure(tool::Cargofmt {\n-            compiler: builder.compiler(stage, builder.config.build),\n-            target, extra_features: Vec::new()\n+            compiler,\n+            target,\n+            extra_features: Vec::new(),\n         }).or_else(|| { missing_tool(\"Cargofmt\", builder.build.config.missing_tools); None })?;\n \n         builder.install(&rustfmt, &image.join(\"bin\"), 0o755);\n@@ -1502,30 +1506,28 @@ impl Step for Extended {\n \n     /// Creates a combined installer for the specified target in the provided stage.\n     fn run(self, builder: &Builder<'_>) {\n-        let stage = self.stage;\n         let target = self.target;\n+        let stage = self.stage;\n+        let compiler = builder.compiler_for(self.stage, self.host, self.target);\n \n-        builder.info(&format!(\"Dist extended stage{} ({})\", stage, target));\n+        builder.info(&format!(\"Dist extended stage{} ({})\", compiler.stage, target));\n \n         let rustc_installer = builder.ensure(Rustc {\n             compiler: builder.compiler(stage, target),\n         });\n-        let cargo_installer = builder.ensure(Cargo { stage, target });\n-        let rustfmt_installer = builder.ensure(Rustfmt { stage, target });\n-        let rls_installer = builder.ensure(Rls { stage, target });\n-        let llvm_tools_installer = builder.ensure(LlvmTools { stage, target });\n-        let clippy_installer = builder.ensure(Clippy { stage, target });\n-        let miri_installer = builder.ensure(Miri { stage, target });\n+        let cargo_installer = builder.ensure(Cargo { compiler, target });\n+        let rustfmt_installer = builder.ensure(Rustfmt { compiler, target });\n+        let rls_installer = builder.ensure(Rls { compiler, target });\n+        let llvm_tools_installer = builder.ensure(LlvmTools { target });\n+        let clippy_installer = builder.ensure(Clippy { compiler, target });\n+        let miri_installer = builder.ensure(Miri { compiler, target });\n         let lldb_installer = builder.ensure(Lldb { target });\n         let mingw_installer = builder.ensure(Mingw { host: target });\n-        let analysis_installer = builder.ensure(Analysis {\n-            compiler: builder.compiler(stage, self.host),\n-            target\n-        });\n+        let analysis_installer = builder.ensure(Analysis { compiler, target });\n \n-        let docs_installer = builder.ensure(Docs { stage, host: target, });\n+        let docs_installer = builder.ensure(Docs { host: target, });\n         let std_installer = builder.ensure(Std {\n-            compiler: builder.compiler(stage, self.host),\n+            compiler: builder.compiler(stage, target),\n             target,\n         });\n \n@@ -2073,7 +2075,6 @@ pub fn maybe_install_llvm_dylib(builder: &Builder<'_>,\n \n #[derive(Clone, Debug, Eq, Hash, PartialEq)]\n pub struct LlvmTools {\n-    pub stage: u32,\n     pub target: Interned<String>,\n }\n \n@@ -2087,26 +2088,24 @@ impl Step for LlvmTools {\n \n     fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(LlvmTools {\n-            stage: run.builder.top_stage,\n             target: run.target,\n         });\n     }\n \n     fn run(self, builder: &Builder<'_>) -> Option<PathBuf> {\n-        let stage = self.stage;\n         let target = self.target;\n         assert!(builder.config.extended);\n \n         /* run only if llvm-config isn't used */\n         if let Some(config) = builder.config.target_config.get(&target) {\n             if let Some(ref _s) = config.llvm_config {\n-                builder.info(&format!(\"Skipping LlvmTools stage{} ({}): external LLVM\",\n-                    stage, target));\n+                builder.info(&format!(\"Skipping LlvmTools ({}): external LLVM\",\n+                    target));\n                 return None;\n             }\n         }\n \n-        builder.info(&format!(\"Dist LlvmTools stage{} ({})\", stage, target));\n+        builder.info(&format!(\"Dist LlvmTools ({})\", target));\n         let src = builder.src.join(\"src/llvm-project/llvm\");\n         let name = pkgname(builder, \"llvm-tools\");\n "}, {"sha": "36229720e42cd5f993c4338c03f97e958126b04d", "filename": "src/bootstrap/doc.rs", "status": "modified", "additions": 47, "deletions": 115, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fbootstrap%2Fdoc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fbootstrap%2Fdoc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fdoc.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -13,7 +13,7 @@ use std::io;\n use std::path::{PathBuf, Path};\n \n use crate::Mode;\n-use build_helper::up_to_date;\n+use build_helper::{t, up_to_date};\n \n use crate::util::symlink_dir;\n use crate::builder::{Builder, Compiler, RunConfig, ShouldRun, Step};\n@@ -23,7 +23,7 @@ use crate::cache::{INTERNER, Interned};\n use crate::config::Config;\n \n macro_rules! book {\n-    ($($name:ident, $path:expr, $book_name:expr, $book_ver:expr;)+) => {\n+    ($($name:ident, $path:expr, $book_name:expr;)+) => {\n         $(\n             #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n         pub struct $name {\n@@ -46,10 +46,10 @@ macro_rules! book {\n             }\n \n             fn run(self, builder: &Builder<'_>) {\n-                builder.ensure(Rustbook {\n+                builder.ensure(RustbookSrc {\n                     target: self.target,\n                     name: INTERNER.intern_str($book_name),\n-                    version: $book_ver,\n+                    src: doc_src(builder),\n                 })\n             }\n         }\n@@ -60,50 +60,17 @@ macro_rules! book {\n // NOTE: When adding a book here, make sure to ALSO build the book by\n // adding a build step in `src/bootstrap/builder.rs`!\n book!(\n-    EditionGuide, \"src/doc/edition-guide\", \"edition-guide\", RustbookVersion::MdBook2;\n-    EmbeddedBook, \"src/doc/embedded-book\", \"embedded-book\", RustbookVersion::MdBook2;\n-    Nomicon, \"src/doc/nomicon\", \"nomicon\", RustbookVersion::MdBook1;\n-    Reference, \"src/doc/reference\", \"reference\", RustbookVersion::MdBook1;\n-    RustByExample, \"src/doc/rust-by-example\", \"rust-by-example\", RustbookVersion::MdBook1;\n-    RustcBook, \"src/doc/rustc\", \"rustc\", RustbookVersion::MdBook1;\n-    RustdocBook, \"src/doc/rustdoc\", \"rustdoc\", RustbookVersion::MdBook1;\n+    EditionGuide, \"src/doc/edition-guide\", \"edition-guide\";\n+    EmbeddedBook, \"src/doc/embedded-book\", \"embedded-book\";\n+    Nomicon, \"src/doc/nomicon\", \"nomicon\";\n+    Reference, \"src/doc/reference\", \"reference\";\n+    RustByExample, \"src/doc/rust-by-example\", \"rust-by-example\";\n+    RustcBook, \"src/doc/rustc\", \"rustc\";\n+    RustdocBook, \"src/doc/rustdoc\", \"rustdoc\";\n );\n \n-#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n-enum RustbookVersion {\n-    MdBook1,\n-    MdBook2,\n-}\n-\n-#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n-struct Rustbook {\n-    target: Interned<String>,\n-    name: Interned<String>,\n-    version: RustbookVersion,\n-}\n-\n-impl Step for Rustbook {\n-    type Output = ();\n-\n-    // rustbook is never directly called, and only serves as a shim for the nomicon and the\n-    // reference.\n-    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n-        run.never()\n-    }\n-\n-    /// Invoke `rustbook` for `target` for the doc book `name`.\n-    ///\n-    /// This will not actually generate any documentation if the documentation has\n-    /// already been generated.\n-    fn run(self, builder: &Builder<'_>) {\n-        let src = builder.src.join(\"src/doc\");\n-        builder.ensure(RustbookSrc {\n-            target: self.target,\n-            name: self.name,\n-            src: INTERNER.intern_path(src),\n-            version: self.version,\n-        });\n-    }\n+fn doc_src(builder: &Builder<'_>) -> Interned<PathBuf> {\n+    INTERNER.intern_path(builder.src.join(\"src/doc\"))\n }\n \n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n@@ -134,7 +101,6 @@ impl Step for UnstableBook {\n             target: self.target,\n             name: INTERNER.intern_str(\"unstable-book\"),\n             src: builder.md_doc_out(self.target),\n-            version: RustbookVersion::MdBook1,\n         })\n     }\n }\n@@ -188,7 +154,6 @@ struct RustbookSrc {\n     target: Interned<String>,\n     name: Interned<String>,\n     src: Interned<PathBuf>,\n-    version: RustbookVersion,\n }\n \n impl Step for RustbookSrc {\n@@ -220,18 +185,11 @@ impl Step for RustbookSrc {\n         builder.info(&format!(\"Rustbook ({}) - {}\", target, name));\n         let _ = fs::remove_dir_all(&out);\n \n-        let vers = match self.version {\n-            RustbookVersion::MdBook1 => \"1\",\n-            RustbookVersion::MdBook2 => \"2\",\n-        };\n-\n         builder.run(rustbook_cmd\n                        .arg(\"build\")\n                        .arg(&src)\n                        .arg(\"-d\")\n-                       .arg(out)\n-                       .arg(\"-m\")\n-                       .arg(vers));\n+                       .arg(out));\n     }\n }\n \n@@ -274,33 +232,33 @@ impl Step for TheBook {\n         let name = self.name;\n \n         // build book\n-        builder.ensure(Rustbook {\n+        builder.ensure(RustbookSrc {\n             target,\n             name: INTERNER.intern_string(name.to_string()),\n-            version: RustbookVersion::MdBook1,\n+            src: doc_src(builder),\n         });\n \n         // building older edition redirects\n \n         let source_name = format!(\"{}/first-edition\", name);\n-        builder.ensure(Rustbook {\n+        builder.ensure(RustbookSrc {\n             target,\n             name: INTERNER.intern_string(source_name),\n-            version: RustbookVersion::MdBook1,\n+            src: doc_src(builder),\n         });\n \n         let source_name = format!(\"{}/second-edition\", name);\n-        builder.ensure(Rustbook {\n+        builder.ensure(RustbookSrc {\n             target,\n             name: INTERNER.intern_string(source_name),\n-            version: RustbookVersion::MdBook1,\n+            src: doc_src(builder),\n         });\n \n         let source_name = format!(\"{}/2018-edition\", name);\n-        builder.ensure(Rustbook {\n+        builder.ensure(RustbookSrc {\n             target,\n             name: INTERNER.intern_string(source_name),\n-            version: RustbookVersion::MdBook1,\n+            src: doc_src(builder),\n         });\n \n         // build the version info page and CSS\n@@ -331,24 +289,21 @@ fn invoke_rustdoc(\n \n     let path = builder.src.join(\"src/doc\").join(markdown);\n \n-    let favicon = builder.src.join(\"src/doc/favicon.inc\");\n+    let header = builder.src.join(\"src/doc/redirect.inc\");\n     let footer = builder.src.join(\"src/doc/footer.inc\");\n     let version_info = out.join(\"version_info.html\");\n \n-    let mut cmd = builder.rustdoc_cmd(compiler.host);\n+    let mut cmd = builder.rustdoc_cmd(compiler);\n \n     let out = out.join(\"book\");\n \n     cmd.arg(\"--html-after-content\").arg(&footer)\n         .arg(\"--html-before-content\").arg(&version_info)\n-        .arg(\"--html-in-header\").arg(&favicon)\n+        .arg(\"--html-in-header\").arg(&header)\n         .arg(\"--markdown-no-toc\")\n-        .arg(\"--markdown-playground-url\")\n-        .arg(\"https://play.rust-lang.org/\")\n-        .arg(\"-o\").arg(&out)\n-        .arg(&path)\n-        .arg(\"--markdown-css\")\n-        .arg(\"../rust.css\");\n+        .arg(\"--markdown-playground-url\").arg(\"https://play.rust-lang.org/\")\n+        .arg(\"-o\").arg(&out).arg(&path)\n+        .arg(\"--markdown-css\").arg(\"../rust.css\");\n \n     builder.run(&mut cmd);\n }\n@@ -415,7 +370,7 @@ impl Step for Standalone {\n             }\n \n             let html = out.join(filename).with_extension(\"html\");\n-            let rustdoc = builder.rustdoc(compiler.host);\n+            let rustdoc = builder.rustdoc(compiler);\n             if up_to_date(&path, &html) &&\n                up_to_date(&footer, &html) &&\n                up_to_date(&favicon, &html) &&\n@@ -425,14 +380,13 @@ impl Step for Standalone {\n                 continue\n             }\n \n-            let mut cmd = builder.rustdoc_cmd(compiler.host);\n+            let mut cmd = builder.rustdoc_cmd(compiler);\n             cmd.arg(\"--html-after-content\").arg(&footer)\n                .arg(\"--html-before-content\").arg(&version_info)\n                .arg(\"--html-in-header\").arg(&favicon)\n                .arg(\"--markdown-no-toc\")\n                .arg(\"--index-page\").arg(&builder.src.join(\"src/doc/index.md\"))\n-               .arg(\"--markdown-playground-url\")\n-               .arg(\"https://play.rust-lang.org/\")\n+               .arg(\"--markdown-playground-url\").arg(\"https://play.rust-lang.org/\")\n                .arg(\"-o\").arg(&out)\n                .arg(&path);\n \n@@ -479,12 +433,7 @@ impl Step for Std {\n         builder.info(&format!(\"Documenting stage{} std ({})\", stage, target));\n         let out = builder.doc_out(target);\n         t!(fs::create_dir_all(&out));\n-        let compiler = builder.compiler(stage, builder.config.build);\n-        let compiler = if builder.force_use_stage1(compiler, target) {\n-            builder.compiler(1, compiler.host)\n-        } else {\n-            compiler\n-        };\n+        let compiler = builder.compiler_for(stage, builder.config.build, target);\n \n         builder.ensure(compile::Std { compiler, target });\n         let out_dir = builder.stage_out(compiler, Mode::Std)\n@@ -523,6 +472,7 @@ impl Step for Std {\n                  .arg(\"--markdown-css\").arg(\"rust.css\")\n                  .arg(\"--markdown-no-toc\")\n                  .arg(\"--generate-redirect-pages\")\n+                 .arg(\"--resource-suffix\").arg(crate::channel::CFG_RELEASE_NUM)\n                  .arg(\"--index-page\").arg(&builder.src.join(\"src/doc/index.md\"));\n \n             builder.run(&mut cargo);\n@@ -566,12 +516,7 @@ impl Step for Test {\n         builder.info(&format!(\"Documenting stage{} test ({})\", stage, target));\n         let out = builder.doc_out(target);\n         t!(fs::create_dir_all(&out));\n-        let compiler = builder.compiler(stage, builder.config.build);\n-        let compiler = if builder.force_use_stage1(compiler, target) {\n-            builder.compiler(1, compiler.host)\n-        } else {\n-            compiler\n-        };\n+        let compiler = builder.compiler_for(stage, builder.config.build, target);\n \n         // Build libstd docs so that we generate relative links\n         builder.ensure(Std { stage, target });\n@@ -589,6 +534,7 @@ impl Step for Test {\n \n         cargo.arg(\"--no-deps\")\n              .arg(\"-p\").arg(\"test\")\n+             .env(\"RUSTDOC_RESOURCE_SUFFIX\", crate::channel::CFG_RELEASE_NUM)\n              .env(\"RUSTDOC_GENERATE_REDIRECT_PAGES\", \"1\");\n \n         builder.run(&mut cargo);\n@@ -634,12 +580,7 @@ impl Step for WhitelistedRustc {\n         builder.info(&format!(\"Documenting stage{} whitelisted compiler ({})\", stage, target));\n         let out = builder.doc_out(target);\n         t!(fs::create_dir_all(&out));\n-        let compiler = builder.compiler(stage, builder.config.build);\n-        let compiler = if builder.force_use_stage1(compiler, target) {\n-            builder.compiler(1, compiler.host)\n-        } else {\n-            compiler\n-        };\n+        let compiler = builder.compiler_for(stage, builder.config.build, target);\n \n         // Build libstd docs so that we generate relative links\n         builder.ensure(Std { stage, target });\n@@ -660,6 +601,7 @@ impl Step for WhitelistedRustc {\n         // for which docs must be built.\n         for krate in &[\"proc_macro\"] {\n             cargo.arg(\"-p\").arg(krate)\n+                 .env(\"RUSTDOC_RESOURCE_SUFFIX\", crate::channel::CFG_RELEASE_NUM)\n                  .env(\"RUSTDOC_GENERATE_REDIRECT_PAGES\", \"1\");\n         }\n \n@@ -707,12 +649,7 @@ impl Step for Rustc {\n         t!(fs::create_dir_all(&out));\n \n         // Get the correct compiler for this stage.\n-        let compiler = builder.compiler(stage, builder.config.build);\n-        let compiler = if builder.force_use_stage1(compiler, target) {\n-            builder.compiler(1, compiler.host)\n-        } else {\n-            compiler\n-        };\n+        let compiler = builder.compiler_for(stage, builder.config.build, target);\n \n         if !builder.config.compiler_docs {\n             builder.info(\"\\tskipping - compiler/librustdoc docs disabled\");\n@@ -729,7 +666,7 @@ impl Step for Rustc {\n \n         // Build cargo command.\n         let mut cargo = builder.cargo(compiler, Mode::Rustc, target, \"doc\");\n-        cargo.env(\"RUSTDOCFLAGS\", \"--document-private-items\");\n+        cargo.env(\"RUSTDOCFLAGS\", \"--document-private-items --passes strip-hidden\");\n         compile::rustc_cargo(builder, &mut cargo);\n \n         // Only include compiler crates, no dependencies of those, such as `libc`.\n@@ -808,12 +745,7 @@ impl Step for Rustdoc {\n         t!(fs::create_dir_all(&out));\n \n         // Get the correct compiler for this stage.\n-        let compiler = builder.compiler(stage, builder.config.build);\n-        let compiler = if builder.force_use_stage1(compiler, target) {\n-            builder.compiler(1, compiler.host)\n-        } else {\n-            compiler\n-        };\n+        let compiler = builder.compiler_for(stage, builder.config.build, target);\n \n         if !builder.config.compiler_docs {\n             builder.info(\"\\tskipping - compiler/librustdoc docs disabled\");\n@@ -824,7 +756,7 @@ impl Step for Rustdoc {\n         builder.ensure(Rustc { stage, target });\n \n         // Build rustdoc.\n-        builder.ensure(tool::Rustdoc { host: compiler.host });\n+        builder.ensure(tool::Rustdoc { compiler: compiler });\n \n         // Symlink compiler docs to the output directory of rustdoc documentation.\n         let out_dir = builder.stage_out(compiler, Mode::ToolRustc)\n@@ -883,9 +815,14 @@ impl Step for ErrorIndex {\n         builder.info(&format!(\"Documenting error index ({})\", target));\n         let out = builder.doc_out(target);\n         t!(fs::create_dir_all(&out));\n-        let mut index = builder.tool_cmd(Tool::ErrorIndex);\n+        let compiler = builder.compiler(2, builder.config.build);\n+        let mut index = tool::ErrorIndex::command(\n+            builder,\n+            compiler,\n+        );\n         index.arg(\"html\");\n         index.arg(out.join(\"error-index.html\"));\n+        index.arg(crate::channel::CFG_RELEASE_NUM);\n \n         // FIXME: shouldn't have to pass this env var\n         index.env(\"CFG_BUILD\", &builder.config.build)\n@@ -919,11 +856,6 @@ impl Step for UnstableBookGen {\n     fn run(self, builder: &Builder<'_>) {\n         let target = self.target;\n \n-        builder.ensure(compile::Std {\n-            compiler: builder.compiler(builder.top_stage, builder.config.build),\n-            target,\n-        });\n-\n         builder.info(&format!(\"Generating unstable book md files ({})\", target));\n         let out = builder.md_doc_out(target).join(\"unstable-book\");\n         builder.create_dir(&out);"}, {"sha": "828865f10ffba37ce53dcfb1003527316565cb82", "filename": "src/bootstrap/flags.rs", "status": "modified", "additions": 88, "deletions": 4, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fbootstrap%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fbootstrap%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fflags.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -33,8 +33,11 @@ pub struct Flags {\n     pub rustc_error_format: Option<String>,\n     pub dry_run: bool,\n \n-    // true => deny\n-    pub warnings: Option<bool>,\n+    // This overrides the deny-warnings configuation option,\n+    // which passes -Dwarnings to the compiler invocations.\n+    //\n+    // true => deny, false => allow\n+    pub deny_warnings: Option<bool>,\n }\n \n pub enum Subcommand {\n@@ -44,6 +47,12 @@ pub enum Subcommand {\n     Check {\n         paths: Vec<PathBuf>,\n     },\n+    Clippy {\n+        paths: Vec<PathBuf>,\n+    },\n+    Fix {\n+        paths: Vec<PathBuf>,\n+    },\n     Doc {\n         paths: Vec<PathBuf>,\n     },\n@@ -52,10 +61,12 @@ pub enum Subcommand {\n         /// Whether to automatically update stderr/stdout files\n         bless: bool,\n         compare_mode: Option<String>,\n+        pass: Option<String>,\n         test_args: Vec<String>,\n         rustc_args: Vec<String>,\n         fail_fast: bool,\n         doc_tests: DocTests,\n+        rustfix_coverage: bool,\n     },\n     Bench {\n         paths: Vec<PathBuf>,\n@@ -89,6 +100,8 @@ Usage: x.py <subcommand> [options] [<paths>...]\n Subcommands:\n     build       Compile either the compiler or libraries\n     check       Compile either the compiler or libraries, using cargo check\n+    clippy      Run clippy\n+    fix         Run cargo fix\n     test        Build and run some test suites\n     bench       Build and run some benchmarks\n     doc         Build documentation\n@@ -145,6 +158,8 @@ To learn more about a subcommand, run `./x.py <subcommand> -h`\"\n         let subcommand = args.iter().find(|&s| {\n             (s == \"build\")\n                 || (s == \"check\")\n+                || (s == \"clippy\")\n+                || (s == \"fix\")\n                 || (s == \"test\")\n                 || (s == \"bench\")\n                 || (s == \"doc\")\n@@ -188,6 +203,18 @@ To learn more about a subcommand, run `./x.py <subcommand> -h`\"\n                     \"mode describing what file the actual ui output will be compared to\",\n                     \"COMPARE MODE\",\n                 );\n+                opts.optopt(\n+                    \"\",\n+                    \"pass\",\n+                    \"force {check,build,run}-pass tests to this mode.\",\n+                    \"check | build | run\"\n+                );\n+                opts.optflag(\n+                    \"\",\n+                    \"rustfix-coverage\",\n+                    \"enable this to generate a Rustfix coverage file, which is saved in \\\n+                        `/<build_base>/rustfix_missing_coverage.txt`\",\n+                );\n             }\n             \"bench\" => {\n                 opts.optmulti(\"\", \"test-args\", \"extra arguments\", \"ARGS\");\n@@ -274,14 +301,36 @@ Arguments:\n     the compiler.\",\n                 );\n             }\n+            \"clippy\" => {\n+                subcommand_help.push_str(\n+                    \"\\n\n+Arguments:\n+    This subcommand accepts a number of paths to directories to the crates\n+    and/or artifacts to run clippy against. For example:\n+\n+        ./x.py clippy src/libcore\n+        ./x.py clippy src/libcore src/libproc_macro\",\n+                );\n+            }\n+            \"fix\" => {\n+                subcommand_help.push_str(\n+                    \"\\n\n+Arguments:\n+    This subcommand accepts a number of paths to directories to the crates\n+    and/or artifacts to run `cargo fix` against. For example:\n+\n+        ./x.py fix src/libcore\n+        ./x.py fix src/libcore src/libproc_macro\",\n+                );\n+            }\n             \"test\" => {\n                 subcommand_help.push_str(\n                     \"\\n\n Arguments:\n     This subcommand accepts a number of paths to directories to tests that\n     should be compiled and run. For example:\n \n-        ./x.py test src/test/run-pass\n+        ./x.py test src/test/ui\n         ./x.py test src/libstd --test-args hash_map\n         ./x.py test src/libstd --stage 0 --no-doc\n         ./x.py test src/test/ui --bless\n@@ -356,13 +405,17 @@ Arguments:\n         let cmd = match subcommand.as_str() {\n             \"build\" => Subcommand::Build { paths },\n             \"check\" => Subcommand::Check { paths },\n+            \"clippy\" => Subcommand::Clippy { paths },\n+            \"fix\" => Subcommand::Fix { paths },\n             \"test\" => Subcommand::Test {\n                 paths,\n                 bless: matches.opt_present(\"bless\"),\n                 compare_mode: matches.opt_str(\"compare-mode\"),\n+                pass: matches.opt_str(\"pass\"),\n                 test_args: matches.opt_strs(\"test-args\"),\n                 rustc_args: matches.opt_strs(\"rustc-args\"),\n                 fail_fast: !matches.opt_present(\"no-fail-fast\"),\n+                rustfix_coverage: matches.opt_present(\"rustfix-coverage\"),\n                 doc_tests: if matches.opt_present(\"doc\") {\n                     DocTests::Only\n                 } else if matches.opt_present(\"no-doc\") {\n@@ -418,7 +471,7 @@ Arguments:\n                 .into_iter()\n                 .map(|p| p.into())\n                 .collect::<Vec<_>>(),\n-            warnings: matches.opt_str(\"warnings\").map(|v| v == \"deny\"),\n+            deny_warnings: parse_deny_warnings(&matches),\n         }\n     }\n }\n@@ -467,6 +520,13 @@ impl Subcommand {\n         }\n     }\n \n+    pub fn rustfix_coverage(&self) -> bool {\n+        match *self {\n+            Subcommand::Test { rustfix_coverage, .. } => rustfix_coverage,\n+            _ => false,\n+        }\n+    }\n+\n     pub fn compare_mode(&self) -> Option<&str> {\n         match *self {\n             Subcommand::Test {\n@@ -475,6 +535,15 @@ impl Subcommand {\n             _ => None,\n         }\n     }\n+\n+    pub fn pass(&self) -> Option<&str> {\n+        match *self {\n+            Subcommand::Test {\n+                ref pass, ..\n+            } => pass.as_ref().map(|s| &s[..]),\n+            _ => None,\n+        }\n+    }\n }\n \n fn split(s: &[String]) -> Vec<String> {\n@@ -483,3 +552,18 @@ fn split(s: &[String]) -> Vec<String> {\n         .map(|s| s.to_string())\n         .collect()\n }\n+\n+fn parse_deny_warnings(matches: &getopts::Matches) -> Option<bool> {\n+    match matches.opt_str(\"warnings\").as_ref().map(|v| v.as_str()) {\n+        Some(\"deny\") => Some(true),\n+        Some(\"allow\") => Some(false),\n+        Some(value) => {\n+            eprintln!(\n+                r#\"invalid value for --warnings: {:?}, expected \"allow\" or \"deny\"\"#,\n+                value,\n+                );\n+            process::exit(1);\n+        },\n+        None => None,\n+    }\n+}"}, {"sha": "557586709c61275af7c8658af672075aa67f8a03", "filename": "src/bootstrap/install.rs", "status": "modified", "additions": 47, "deletions": 35, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fbootstrap%2Finstall.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fbootstrap%2Finstall.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Finstall.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -5,10 +5,13 @@\n \n use std::env;\n use std::fs;\n-use std::path::{Path, PathBuf, Component};\n+use std::path::{Component, Path, PathBuf};\n use std::process::Command;\n \n+use build_helper::t;\n+\n use crate::dist::{self, pkgname, sanitize_sh, tmpdir};\n+use crate::Compiler;\n \n use crate::builder::{Builder, RunConfig, ShouldRun, Step};\n use crate::cache::Interned;\n@@ -56,7 +59,7 @@ fn install_sh(\n     package: &str,\n     name: &str,\n     stage: u32,\n-    host: Option<Interned<String>>\n+    host: Option<Interned<String>>,\n ) {\n     builder.info(&format!(\"Install {} stage{} ({:?})\", package, stage, host));\n \n@@ -142,9 +145,8 @@ macro_rules! install {\n         $(\n             #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n         pub struct $name {\n-            pub stage: u32,\n+            pub compiler: Compiler,\n             pub target: Interned<String>,\n-            pub host: Interned<String>,\n         }\n \n         impl $name {\n@@ -173,9 +175,8 @@ macro_rules! install {\n \n             fn make_run(run: RunConfig<'_>) {\n                 run.builder.ensure($name {\n-                    stage: run.builder.top_stage,\n+                    compiler: run.builder.compiler(run.builder.top_stage, run.builder.config.build),\n                     target: run.target,\n-                    host: run.builder.config.build,\n                 });\n             }\n \n@@ -188,67 +189,81 @@ macro_rules! install {\n \n install!((self, builder, _config),\n     Docs, \"src/doc\", _config.docs, only_hosts: false, {\n-        builder.ensure(dist::Docs { stage: self.stage, host: self.target });\n-        install_docs(builder, self.stage, self.target);\n+        builder.ensure(dist::Docs { host: self.target });\n+        install_docs(builder, self.compiler.stage, self.target);\n     };\n     Std, \"src/libstd\", true, only_hosts: true, {\n         for target in &builder.targets {\n             builder.ensure(dist::Std {\n-                compiler: builder.compiler(self.stage, self.host),\n+                compiler: self.compiler,\n                 target: *target\n             });\n-            install_std(builder, self.stage, *target);\n+            install_std(builder, self.compiler.stage, *target);\n         }\n     };\n     Cargo, \"cargo\", Self::should_build(_config), only_hosts: true, {\n-        builder.ensure(dist::Cargo { stage: self.stage, target: self.target });\n-        install_cargo(builder, self.stage, self.target);\n+        builder.ensure(dist::Cargo { compiler: self.compiler, target: self.target });\n+        install_cargo(builder, self.compiler.stage, self.target);\n     };\n     Rls, \"rls\", Self::should_build(_config), only_hosts: true, {\n-        if builder.ensure(dist::Rls { stage: self.stage, target: self.target }).is_some() ||\n+        if builder.ensure(dist::Rls { compiler: self.compiler, target: self.target }).is_some() ||\n             Self::should_install(builder) {\n-            install_rls(builder, self.stage, self.target);\n+            install_rls(builder, self.compiler.stage, self.target);\n         } else {\n-            builder.info(&format!(\"skipping Install RLS stage{} ({})\", self.stage, self.target));\n+            builder.info(\n+                &format!(\"skipping Install RLS stage{} ({})\", self.compiler.stage, self.target),\n+            );\n         }\n     };\n     Clippy, \"clippy\", Self::should_build(_config), only_hosts: true, {\n-        if builder.ensure(dist::Clippy { stage: self.stage, target: self.target }).is_some() ||\n-            Self::should_install(builder) {\n-            install_clippy(builder, self.stage, self.target);\n+        if builder.ensure(dist::Clippy {\n+            compiler: self.compiler,\n+            target: self.target,\n+        }).is_some() || Self::should_install(builder) {\n+            install_clippy(builder, self.compiler.stage, self.target);\n         } else {\n-            builder.info(&format!(\"skipping Install clippy stage{} ({})\", self.stage, self.target));\n+            builder.info(\n+                &format!(\"skipping Install clippy stage{} ({})\", self.compiler.stage, self.target),\n+            );\n         }\n     };\n     Miri, \"miri\", Self::should_build(_config), only_hosts: true, {\n-        if builder.ensure(dist::Miri { stage: self.stage, target: self.target }).is_some() ||\n+        if builder.ensure(dist::Miri { compiler: self.compiler, target: self.target }).is_some() ||\n             Self::should_install(builder) {\n-            install_miri(builder, self.stage, self.target);\n+            install_miri(builder, self.compiler.stage, self.target);\n         } else {\n-            builder.info(&format!(\"skipping Install miri stage{} ({})\", self.stage, self.target));\n+            builder.info(\n+                &format!(\"skipping Install miri stage{} ({})\", self.compiler.stage, self.target),\n+            );\n         }\n     };\n     Rustfmt, \"rustfmt\", Self::should_build(_config), only_hosts: true, {\n-        if builder.ensure(dist::Rustfmt { stage: self.stage, target: self.target }).is_some() ||\n-            Self::should_install(builder) {\n-            install_rustfmt(builder, self.stage, self.target);\n+        if builder.ensure(dist::Rustfmt {\n+            compiler: self.compiler,\n+            target: self.target\n+        }).is_some() || Self::should_install(builder) {\n+            install_rustfmt(builder, self.compiler.stage, self.target);\n         } else {\n             builder.info(\n-                &format!(\"skipping Install Rustfmt stage{} ({})\", self.stage, self.target));\n+                &format!(\"skipping Install Rustfmt stage{} ({})\", self.compiler.stage, self.target),\n+            );\n         }\n     };\n     Analysis, \"analysis\", Self::should_build(_config), only_hosts: false, {\n         builder.ensure(dist::Analysis {\n-            compiler: builder.compiler(self.stage, self.host),\n+            // Find the actual compiler (handling the full bootstrap option) which\n+            // produced the save-analysis data because that data isn't copied\n+            // through the sysroot uplifting.\n+            compiler: builder.compiler_for(builder.top_stage, builder.config.build, self.target),\n             target: self.target\n         });\n-        install_analysis(builder, self.stage, self.target);\n+        install_analysis(builder, self.compiler.stage, self.target);\n     };\n     Rustc, \"src/librustc\", true, only_hosts: true, {\n         builder.ensure(dist::Rustc {\n-            compiler: builder.compiler(self.stage, self.target),\n+            compiler: self.compiler,\n         });\n-        install_rustc(builder, self.stage, self.target);\n+        install_rustc(builder, self.compiler.stage, self.target);\n     };\n );\n \n@@ -264,15 +279,12 @@ impl Step for Src {\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n         let config = &run.builder.config;\n-        let cond = config.extended &&\n-            config.tools.as_ref().map_or(true, |t| t.contains(\"src\"));\n+        let cond = config.extended && config.tools.as_ref().map_or(true, |t| t.contains(\"src\"));\n         run.path(\"src\").default_condition(cond)\n     }\n \n     fn make_run(run: RunConfig<'_>) {\n-        run.builder.ensure(Src {\n-            stage: run.builder.top_stage,\n-        });\n+        run.builder.ensure(Src { stage: run.builder.top_stage });\n     }\n \n     fn run(self, builder: &Builder<'_>) {"}, {"sha": "6867d62a480bd2ba57a5a08767f784ad1266c423", "filename": "src/bootstrap/job.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fbootstrap%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fbootstrap%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fjob.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -32,6 +32,7 @@\n use std::env;\n use std::io;\n use std::mem;\n+use std::ptr;\n use crate::Build;\n \n type HANDLE = *mut u8;\n@@ -118,8 +119,8 @@ pub unsafe fn setup(build: &mut Build) {\n     SetErrorMode(mode & !SEM_NOGPFAULTERRORBOX);\n \n     // Create a new job object for us to use\n-    let job = CreateJobObjectW(0 as *mut _, 0 as *const _);\n-    assert!(job != 0 as *mut _, \"{}\", io::Error::last_os_error());\n+    let job = CreateJobObjectW(ptr::null_mut(), ptr::null());\n+    assert!(!job.is_null(), \"{}\", io::Error::last_os_error());\n \n     // Indicate that when all handles to the job object are gone that all\n     // process in the object should be killed. Note that this includes our\n@@ -166,8 +167,8 @@ pub unsafe fn setup(build: &mut Build) {\n     };\n \n     let parent = OpenProcess(PROCESS_DUP_HANDLE, FALSE, pid.parse().unwrap());\n-    assert!(parent != 0 as *mut _, \"{}\", io::Error::last_os_error());\n-    let mut parent_handle = 0 as *mut _;\n+    assert!(!parent.is_null(), \"{}\", io::Error::last_os_error());\n+    let mut parent_handle = ptr::null_mut();\n     let r = DuplicateHandle(GetCurrentProcess(), job,\n                             parent, &mut parent_handle,\n                             0, FALSE, DUPLICATE_SAME_ACCESS);"}, {"sha": "b72aa78f3de191c330134764a625d3d251915177", "filename": "src/bootstrap/lib.rs", "status": "modified", "additions": 62, "deletions": 59, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fbootstrap%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fbootstrap%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Flib.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -103,22 +103,12 @@\n //! More documentation can be found in each respective module below, and you can\n //! also check out the `src/bootstrap/README.md` file for more information.\n \n-#![deny(rust_2018_idioms)]\n-#![deny(warnings)]\n+// NO-RUSTC-WRAPPER\n+#![deny(warnings, rust_2018_idioms, unused_lifetimes)]\n+\n #![feature(core_intrinsics)]\n #![feature(drain_filter)]\n \n-#[macro_use]\n-extern crate build_helper;\n-#[macro_use]\n-extern crate serde_derive;\n-#[macro_use]\n-extern crate lazy_static;\n-\n-#[cfg(test)]\n-#[macro_use]\n-extern crate pretty_assertions;\n-\n use std::cell::{RefCell, Cell};\n use std::collections::{HashSet, HashMap};\n use std::env;\n@@ -134,10 +124,12 @@ use std::os::unix::fs::symlink as symlink_file;\n #[cfg(windows)]\n use std::os::windows::fs::symlink_file;\n \n-use build_helper::{run_silent, run_suppressed, try_run_silent, try_run_suppressed, output, mtime};\n+use build_helper::{\n+    mtime, output, run, run_suppressed, t, try_run, try_run_suppressed,\n+};\n use filetime::FileTime;\n \n-use crate::util::{exe, libdir, OutputFolder, CiEnv};\n+use crate::util::{exe, libdir, CiEnv};\n \n mod cc_detect;\n mod channel;\n@@ -190,6 +182,7 @@ const LLVM_TOOLS: &[&str] = &[\n     \"llvm-readobj\", // used to get information from ELFs/objects that the other tools don't provide\n     \"llvm-size\", // used to prints the size of the linker sections of a program\n     \"llvm-strip\", // used to discard symbols from binary files to reduce their size\n+    \"llvm-ar\" // used for creating and modifying archive files\n ];\n \n /// A structure representing a Rust compiler.\n@@ -205,11 +198,11 @@ pub struct Compiler {\n \n #[derive(PartialEq, Eq, Copy, Clone, Debug)]\n pub enum DocTests {\n-    // Default, run normal tests and doc tests.\n+    /// Run normal tests and doc tests (default).\n     Yes,\n-    // Do not run any doc tests.\n+    /// Do not run any doc tests.\n     No,\n-    // Only run doc tests.\n+    /// Only run doc tests.\n     Only,\n }\n \n@@ -229,10 +222,10 @@ pub enum GitRepo {\n /// methods specifically on this structure itself (to make it easier to\n /// organize).\n pub struct Build {\n-    // User-specified configuration via config.toml\n+    /// User-specified configuration from `config.toml`.\n     config: Config,\n \n-    // Derived properties from the above two configurations\n+    // Properties derived from the above configuration\n     src: PathBuf,\n     out: PathBuf,\n     rust_info: channel::GitInfo,\n@@ -241,17 +234,19 @@ pub struct Build {\n     clippy_info: channel::GitInfo,\n     miri_info: channel::GitInfo,\n     rustfmt_info: channel::GitInfo,\n+    in_tree_llvm_info: channel::GitInfo,\n+    emscripten_llvm_info: channel::GitInfo,\n     local_rebuild: bool,\n     fail_fast: bool,\n     doc_tests: DocTests,\n     verbosity: usize,\n \n-    // Targets for which to build.\n+    // Targets for which to build\n     build: Interned<String>,\n     hosts: Vec<Interned<String>>,\n     targets: Vec<Interned<String>>,\n \n-    // Stage 0 (downloaded) compiler and cargo or their local rust equivalents.\n+    // Stage 0 (downloaded) compiler and cargo or their local rust equivalents\n     initial_rustc: PathBuf,\n     initial_cargo: PathBuf,\n \n@@ -261,7 +256,7 @@ pub struct Build {\n     cxx: HashMap<Interned<String>, cc::Tool>,\n     ar: HashMap<Interned<String>, PathBuf>,\n     ranlib: HashMap<Interned<String>, PathBuf>,\n-    // Misc\n+    // Miscellaneous\n     crates: HashMap<Interned<String>, Crate>,\n     is_sudo: bool,\n     ci_env: CiEnv,\n@@ -276,14 +271,9 @@ pub struct Build {\n #[derive(Debug)]\n struct Crate {\n     name: Interned<String>,\n-    version: String,\n     deps: HashSet<Interned<String>>,\n     id: String,\n     path: PathBuf,\n-    doc_step: String,\n-    build_step: String,\n-    test_step: String,\n-    bench_step: String,\n }\n \n impl Crate {\n@@ -357,12 +347,18 @@ impl Build {\n             }\n             None => false,\n         };\n-        let rust_info = channel::GitInfo::new(&config, &src);\n-        let cargo_info = channel::GitInfo::new(&config, &src.join(\"src/tools/cargo\"));\n-        let rls_info = channel::GitInfo::new(&config, &src.join(\"src/tools/rls\"));\n-        let clippy_info = channel::GitInfo::new(&config, &src.join(\"src/tools/clippy\"));\n-        let miri_info = channel::GitInfo::new(&config, &src.join(\"src/tools/miri\"));\n-        let rustfmt_info = channel::GitInfo::new(&config, &src.join(\"src/tools/rustfmt\"));\n+\n+        let ignore_git = config.ignore_git;\n+        let rust_info = channel::GitInfo::new(ignore_git, &src);\n+        let cargo_info = channel::GitInfo::new(ignore_git, &src.join(\"src/tools/cargo\"));\n+        let rls_info = channel::GitInfo::new(ignore_git, &src.join(\"src/tools/rls\"));\n+        let clippy_info = channel::GitInfo::new(ignore_git, &src.join(\"src/tools/clippy\"));\n+        let miri_info = channel::GitInfo::new(ignore_git, &src.join(\"src/tools/miri\"));\n+        let rustfmt_info = channel::GitInfo::new(ignore_git, &src.join(\"src/tools/rustfmt\"));\n+\n+        // we always try to use git for LLVM builds\n+        let in_tree_llvm_info = channel::GitInfo::new(false, &src.join(\"src/llvm-project\"));\n+        let emscripten_llvm_info = channel::GitInfo::new(false, &src.join(\"src/llvm-emscripten\"));\n \n         let mut build = Build {\n             initial_rustc: config.initial_rustc.clone(),\n@@ -386,6 +382,8 @@ impl Build {\n             clippy_info,\n             miri_info,\n             rustfmt_info,\n+            in_tree_llvm_info,\n+            emscripten_llvm_info,\n             cc: HashMap::new(),\n             cxx: HashMap::new(),\n             ar: HashMap::new(),\n@@ -495,6 +493,9 @@ impl Build {\n     fn std_features(&self) -> String {\n         let mut features = \"panic-unwind\".to_string();\n \n+        if self.config.llvm_libunwind {\n+            features.push_str(\" llvm-libunwind\");\n+        }\n         if self.config.backtrace {\n             features.push_str(\" backtrace\");\n         }\n@@ -539,9 +540,7 @@ impl Build {\n             Mode::Rustc => \"-rustc\",\n             Mode::Codegen => \"-codegen\",\n             Mode::ToolBootstrap => \"-bootstrap-tools\",\n-            Mode::ToolStd => \"-tools\",\n-            Mode::ToolTest => \"-tools\",\n-            Mode::ToolRustc => \"-tools\",\n+            Mode::ToolStd | Mode::ToolTest | Mode::ToolRustc => \"-tools\",\n         };\n         self.out.join(&*compiler.host)\n                 .join(format!(\"stage{}{}\", compiler.stage, suffix))\n@@ -681,7 +680,7 @@ impl Build {\n     fn run(&self, cmd: &mut Command) {\n         if self.config.dry_run { return; }\n         self.verbose(&format!(\"running: {:?}\", cmd));\n-        run_silent(cmd)\n+        run(cmd)\n     }\n \n     /// Runs a command, printing out nice contextual information if it fails.\n@@ -697,7 +696,7 @@ impl Build {\n     fn try_run(&self, cmd: &mut Command) -> bool {\n         if self.config.dry_run { return true; }\n         self.verbose(&format!(\"running: {:?}\", cmd));\n-        try_run_silent(cmd)\n+        try_run(cmd)\n     }\n \n     /// Runs a command, printing out nice contextual information if it fails.\n@@ -720,6 +719,17 @@ impl Build {\n         }\n     }\n \n+    pub fn is_verbose_than(&self, level: usize) -> bool {\n+        self.verbosity > level\n+    }\n+\n+    /// Prints a message if this build is configured in more verbose mode than `level`.\n+    fn verbose_than(&self, level: usize, msg: &str) {\n+        if self.is_verbose_than(level) {\n+            println!(\"{}\", msg);\n+        }\n+    }\n+\n     fn info(&self, msg: &str) {\n         if self.config.dry_run { return; }\n         println!(\"{}\", msg);\n@@ -843,6 +853,13 @@ impl Build {\n             .map(|p| &**p)\n     }\n \n+    /// Returns the sysroot for the wasi target, if defined\n+    fn wasi_root(&self, target: Interned<String>) -> Option<&Path> {\n+        self.config.target_config.get(&target)\n+            .and_then(|t| t.wasi_root.as_ref())\n+            .map(|p| &**p)\n+    }\n+\n     /// Returns `true` if this is a no-std `target`, if defined\n     fn no_std(&self, target: Interned<String>) -> Option<bool> {\n         self.config.target_config.get(&target)\n@@ -1017,15 +1034,15 @@ impl Build {\n     }\n \n     fn llvm_tools_package_vers(&self) -> String {\n-        self.package_vers(&self.rust_version())\n+        self.package_vers(channel::CFG_RELEASE_NUM)\n     }\n \n     fn llvm_tools_vers(&self) -> String {\n         self.rust_version()\n     }\n \n     fn lldb_package_vers(&self) -> String {\n-        self.package_vers(&self.rust_version())\n+        self.package_vers(channel::CFG_RELEASE_NUM)\n     }\n \n     fn lldb_vers(&self) -> String {\n@@ -1074,27 +1091,12 @@ impl Build {\n         }\n     }\n \n-    /// Fold the output of the commands after this method into a group. The fold\n-    /// ends when the returned object is dropped. Folding can only be used in\n-    /// the Travis CI environment.\n-    pub fn fold_output<D, F>(&self, name: F) -> Option<OutputFolder>\n-        where D: Into<String>, F: FnOnce() -> D\n-    {\n-        if !self.config.dry_run && self.ci_env == CiEnv::Travis {\n-            Some(OutputFolder::new(name().into()))\n-        } else {\n-            None\n-        }\n-    }\n-\n     /// Updates the actual toolstate of a tool.\n     ///\n     /// The toolstates are saved to the file specified by the key\n     /// `rust.save-toolstates` in `config.toml`. If unspecified, nothing will be\n     /// done. The file is updated immediately after this function completes.\n     pub fn save_toolstate(&self, tool: &str, state: ToolState) {\n-        use std::io::{Seek, SeekFrom};\n-\n         if let Some(ref path) = self.config.save_toolstates {\n             let mut file = t!(fs::OpenOptions::new()\n                 .create(true)\n@@ -1152,6 +1154,7 @@ impl Build {\n     /// Copies a file from `src` to `dst`\n     pub fn copy(&self, src: &Path, dst: &Path) {\n         if self.config.dry_run { return; }\n+        self.verbose_than(1, &format!(\"Copy {:?} to {:?}\", src, dst));\n         let _ = fs::remove_file(&dst);\n         let metadata = t!(src.symlink_metadata());\n         if metadata.file_type().is_symlink() {\n@@ -1192,8 +1195,7 @@ impl Build {\n     /// when this function is called.\n     pub fn cp_r(&self, src: &Path, dst: &Path) {\n         if self.config.dry_run { return; }\n-        for f in t!(fs::read_dir(src)) {\n-            let f = t!(f);\n+        for f in self.read_dir(src) {\n             let path = f.path();\n             let name = path.file_name().unwrap();\n             let dst = dst.join(name);\n@@ -1245,6 +1247,7 @@ impl Build {\n     fn install(&self, src: &Path, dstdir: &Path, perms: u32) {\n         if self.config.dry_run { return; }\n         let dst = dstdir.join(src.file_name().unwrap());\n+        self.verbose_than(1, &format!(\"Install {:?} to {:?}\", src, dst));\n         t!(fs::create_dir_all(dstdir));\n         drop(fs::remove_file(&dst));\n         {\n@@ -1308,7 +1311,7 @@ fn chmod(path: &Path, perms: u32) {\n fn chmod(_path: &Path, _perms: u32) {}\n \n \n-impl<'a> Compiler {\n+impl Compiler {\n     pub fn with_stage(mut self, stage: u32) -> Compiler {\n         self.stage = stage;\n         self"}, {"sha": "b622b3682a7779c24fc25b8ca022cbfe7c26f3bb", "filename": "src/bootstrap/metadata.rs", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fbootstrap%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fbootstrap%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fmetadata.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -4,6 +4,7 @@ use std::path::PathBuf;\n use std::collections::HashSet;\n \n use build_helper::output;\n+use serde::Deserialize;\n use serde_json;\n \n use crate::{Build, Crate};\n@@ -19,7 +20,6 @@ struct Output {\n struct Package {\n     id: String,\n     name: String,\n-    version: String,\n     source: Option<String>,\n     manifest_path: String,\n }\n@@ -83,12 +83,7 @@ fn build_krate(features: &str, build: &mut Build, resolves: &mut Vec<ResolveNode\n             let mut path = PathBuf::from(package.manifest_path);\n             path.pop();\n             build.crates.insert(name, Crate {\n-                build_step: format!(\"build-crate-{}\", name),\n-                doc_step: format!(\"doc-crate-{}\", name),\n-                test_step: format!(\"test-crate-{}\", name),\n-                bench_step: format!(\"bench-crate-{}\", name),\n                 name,\n-                version: package.version,\n                 id: package.id,\n                 deps: HashSet::new(),\n                 path,"}, {"sha": "73d6fe532c8b3cf5966a2741e96c67ab9951dc91", "filename": "src/bootstrap/mk/Makefile.in", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fbootstrap%2Fmk%2FMakefile.in", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fbootstrap%2Fmk%2FMakefile.in", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fmk%2FMakefile.in?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -48,11 +48,8 @@ check:\n \t$(Q)$(BOOTSTRAP) test $(BOOTSTRAP_ARGS)\n check-aux:\n \t$(Q)$(BOOTSTRAP) test \\\n-\t\tsrc/test/pretty \\\n-\t\tsrc/test/run-pass/pretty \\\n \t\tsrc/test/run-fail/pretty \\\n \t\tsrc/test/run-pass-valgrind/pretty \\\n-\t\tsrc/test/run-pass-fulldeps/pretty \\\n \t\t$(AUX_ARGS) \\\n \t\t$(BOOTSTRAP_ARGS)\n check-bootstrap:\n@@ -76,14 +73,12 @@ check-stage2-T-x86_64-unknown-linux-musl-H-x86_64-unknown-linux-gnu:\n \n TESTS_IN_2 := \\\n \tsrc/test/ui \\\n-\tsrc/test/run-pass \\\n \tsrc/test/compile-fail \\\n-\tsrc/test/run-pass-fulldeps \\\n \tsrc/tools/linkchecker\n \n-appveyor-subset-1:\n+ci-subset-1:\n \t$(Q)$(BOOTSTRAP) test $(TESTS_IN_2:%=--exclude %)\n-appveyor-subset-2:\n+ci-subset-2:\n \t$(Q)$(BOOTSTRAP) test $(TESTS_IN_2)\n \n "}, {"sha": "f02def3e1b05dcf0c32a94c7237af828903d0a65", "filename": "src/bootstrap/native.rs", "status": "modified", "additions": 76, "deletions": 28, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fbootstrap%2Fnative.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fbootstrap%2Fnative.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fnative.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -14,10 +14,11 @@ use std::fs::{self, File};\n use std::path::{Path, PathBuf};\n use std::process::Command;\n \n-use build_helper::output;\n+use build_helper::{output, t};\n use cmake;\n use cc;\n \n+use crate::channel;\n use crate::util::{self, exe};\n use build_helper::up_to_date;\n use crate::builder::{Builder, RunConfig, ShouldRun, Step};\n@@ -66,41 +67,49 @@ impl Step for Llvm {\n             }\n         }\n \n-        let rebuild_trigger = builder.src.join(\"src/rustllvm/llvm-rebuild-trigger\");\n-        let rebuild_trigger_contents = t!(fs::read_to_string(&rebuild_trigger));\n-\n-        let (out_dir, llvm_config_ret_dir) = if emscripten {\n+        let (llvm_info, root, out_dir, llvm_config_ret_dir) = if emscripten {\n+            let info = &builder.emscripten_llvm_info;\n             let dir = builder.emscripten_llvm_out(target);\n             let config_dir = dir.join(\"bin\");\n-            (dir, config_dir)\n+            (info, \"src/llvm-emscripten\", dir, config_dir)\n         } else {\n+            let info = &builder.in_tree_llvm_info;\n             let mut dir = builder.llvm_out(builder.config.build);\n             if !builder.config.build.contains(\"msvc\") || builder.config.ninja {\n                 dir.push(\"build\");\n             }\n-            (builder.llvm_out(target), dir.join(\"bin\"))\n+            (info, \"src/llvm-project/llvm\", builder.llvm_out(target), dir.join(\"bin\"))\n         };\n-        let done_stamp = out_dir.join(\"llvm-finished-building\");\n+\n+        if !llvm_info.is_git() {\n+            println!(\n+                \"git could not determine the LLVM submodule commit hash. \\\n+                Assuming that an LLVM build is necessary.\",\n+            );\n+        }\n+\n         let build_llvm_config = llvm_config_ret_dir\n             .join(exe(\"llvm-config\", &*builder.config.build));\n-        if done_stamp.exists() {\n-            let done_contents = t!(fs::read_to_string(&done_stamp));\n+        let done_stamp = out_dir.join(\"llvm-finished-building\");\n+\n+        if let Some(llvm_commit) = llvm_info.sha() {\n+            if done_stamp.exists() {\n+                let done_contents = t!(fs::read(&done_stamp));\n \n-            // If LLVM was already built previously and contents of the rebuild-trigger file\n-            // didn't change from the previous build, then no action is required.\n-            if done_contents == rebuild_trigger_contents {\n-                return build_llvm_config\n+                // If LLVM was already built previously and the submodule's commit didn't change\n+                // from the previous build, then no action is required.\n+                if done_contents == llvm_commit.as_bytes() {\n+                    return build_llvm_config\n+                }\n             }\n         }\n \n-        let _folder = builder.fold_output(|| \"llvm\");\n         let descriptor = if emscripten { \"Emscripten \" } else { \"\" };\n         builder.info(&format!(\"Building {}LLVM for {}\", descriptor, target));\n         let _time = util::timeit(&builder);\n         t!(fs::create_dir_all(&out_dir));\n \n         // http://llvm.org/docs/CMake.html\n-        let root = if self.emscripten { \"src/llvm-emscripten\" } else { \"src/llvm-project/llvm\" };\n         let mut cfg = cmake::Config::new(builder.src.join(root));\n \n         let profile = match (builder.config.llvm_optimize, builder.config.llvm_release_debuginfo) {\n@@ -116,14 +125,18 @@ impl Step for Llvm {\n         } else {\n             match builder.config.llvm_targets {\n                 Some(ref s) => s,\n-                None => \"X86;ARM;AArch64;Mips;PowerPC;SystemZ;MSP430;Sparc;NVPTX;Hexagon\",\n+                None => \"AArch64;ARM;Hexagon;MSP430;Mips;NVPTX;PowerPC;RISCV;\\\n+                         Sparc;SystemZ;WebAssembly;X86\",\n             }\n         };\n \n         let llvm_exp_targets = if self.emscripten {\n             \"\"\n         } else {\n-            &builder.config.llvm_experimental_targets[..]\n+            match builder.config.llvm_experimental_targets {\n+                Some(ref s) => s,\n+                None => \"\",\n+            }\n         };\n \n         let assertions = if builder.config.llvm_assertions {\"ON\"} else {\"OFF\"};\n@@ -141,13 +154,16 @@ impl Step for Llvm {\n            .define(\"WITH_POLLY\", \"OFF\")\n            .define(\"LLVM_ENABLE_TERMINFO\", \"OFF\")\n            .define(\"LLVM_ENABLE_LIBEDIT\", \"OFF\")\n+           .define(\"LLVM_ENABLE_Z3_SOLVER\", \"OFF\")\n            .define(\"LLVM_PARALLEL_COMPILE_JOBS\", builder.jobs().to_string())\n            .define(\"LLVM_TARGET_ARCH\", target.split('-').next().unwrap())\n            .define(\"LLVM_DEFAULT_TARGET_TRIPLE\", target);\n \n         if builder.config.llvm_thin_lto && !emscripten {\n-            cfg.define(\"LLVM_ENABLE_LTO\", \"Thin\")\n-               .define(\"LLVM_ENABLE_LLD\", \"ON\");\n+            cfg.define(\"LLVM_ENABLE_LTO\", \"Thin\");\n+            if !target.contains(\"apple\") {\n+               cfg.define(\"LLVM_ENABLE_LLD\", \"ON\");\n+            }\n         }\n \n         // By default, LLVM will automatically find OCaml and, if it finds it,\n@@ -191,8 +207,16 @@ impl Step for Llvm {\n             cfg.define(\"LLVM_BUILD_32_BITS\", \"ON\");\n         }\n \n+        let mut enabled_llvm_projects = Vec::new();\n+\n+        if util::forcing_clang_based_tests() {\n+            enabled_llvm_projects.push(\"clang\");\n+            enabled_llvm_projects.push(\"compiler-rt\");\n+        }\n+\n         if want_lldb {\n-            cfg.define(\"LLVM_ENABLE_PROJECTS\", \"clang;lldb\");\n+            enabled_llvm_projects.push(\"clang\");\n+            enabled_llvm_projects.push(\"lldb\");\n             // For the time being, disable code signing.\n             cfg.define(\"LLDB_CODESIGN_IDENTITY\", \"\");\n             cfg.define(\"LLDB_NO_DEBUGSERVER\", \"ON\");\n@@ -202,6 +226,12 @@ impl Step for Llvm {\n             cfg.define(\"LLVM_ENABLE_LIBXML2\", \"OFF\");\n         }\n \n+        if enabled_llvm_projects.len() > 0 {\n+            enabled_llvm_projects.sort();\n+            enabled_llvm_projects.dedup();\n+            cfg.define(\"LLVM_ENABLE_PROJECTS\", enabled_llvm_projects.join(\";\"));\n+        }\n+\n         if let Some(num_linkers) = builder.config.llvm_link_jobs {\n             if num_linkers > 0 {\n                 cfg.define(\"LLVM_PARALLEL_LINK_JOBS\", num_linkers.to_string());\n@@ -231,7 +261,21 @@ impl Step for Llvm {\n         }\n \n         if let Some(ref suffix) = builder.config.llvm_version_suffix {\n-            cfg.define(\"LLVM_VERSION_SUFFIX\", suffix);\n+            // Allow version-suffix=\"\" to not define a version suffix at all.\n+            if !suffix.is_empty() {\n+                cfg.define(\"LLVM_VERSION_SUFFIX\", suffix);\n+            }\n+        } else {\n+            let mut default_suffix = format!(\n+                \"-rust-{}-{}\",\n+                channel::CFG_RELEASE_NUM,\n+                builder.config.channel,\n+            );\n+            if let Some(sha) = llvm_info.sha_short() {\n+                default_suffix.push_str(\"-\");\n+                default_suffix.push_str(sha);\n+            }\n+            cfg.define(\"LLVM_VERSION_SUFFIX\", default_suffix);\n         }\n \n         if let Some(ref linker) = builder.config.llvm_use_linker {\n@@ -259,7 +303,9 @@ impl Step for Llvm {\n \n         cfg.build();\n \n-        t!(fs::write(&done_stamp, &rebuild_trigger_contents));\n+        if let Some(llvm_commit) = llvm_info.sha() {\n+            t!(fs::write(&done_stamp, llvm_commit));\n+        }\n \n         build_llvm_config\n     }\n@@ -289,6 +335,10 @@ fn check_llvm_version(builder: &Builder<'_>, llvm_config: &Path) {\n fn configure_cmake(builder: &Builder<'_>,\n                    target: Interned<String>,\n                    cfg: &mut cmake::Config) {\n+    // Do not print installation messages for up-to-date files.\n+    // LLVM and LLD builds can produce a lot of those and hit CI limits on log size.\n+    cfg.define(\"CMAKE_INSTALL_MESSAGE\", \"LAZY\");\n+\n     if builder.config.ninja {\n         cfg.generator(\"Ninja\");\n     }\n@@ -370,7 +420,7 @@ fn configure_cmake(builder: &Builder<'_>,\n \n     cfg.build_arg(\"-j\").build_arg(builder.jobs().to_string());\n     let mut cflags = builder.cflags(target, GitRepo::Llvm).join(\" \");\n-    if let Some(ref s) = builder.config.llvm_cxxflags {\n+    if let Some(ref s) = builder.config.llvm_cflags {\n         cflags.push_str(&format!(\" {}\", s));\n     }\n     cfg.define(\"CMAKE_C_FLAGS\", cflags);\n@@ -408,7 +458,7 @@ fn configure_cmake(builder: &Builder<'_>,\n     }\n \n     if env::var_os(\"SCCACHE_ERROR_LOG\").is_some() {\n-        cfg.env(\"RUST_LOG\", \"sccache=warn\");\n+        cfg.env(\"RUSTC_LOG\", \"sccache=warn\");\n     }\n }\n \n@@ -447,7 +497,6 @@ impl Step for Lld {\n             return out_dir\n         }\n \n-        let _folder = builder.fold_output(|| \"lld\");\n         builder.info(&format!(\"Building LLD for {}\", target));\n         let _time = util::timeit(&builder);\n         t!(fs::create_dir_all(&out_dir));\n@@ -502,7 +551,7 @@ impl Step for TestHelpers {\n     }\n \n     /// Compiles the `rust_test_helpers.c` library which we used in various\n-    /// `run-pass` test suites for ABI testing.\n+    /// `run-pass` tests for ABI testing.\n     fn run(self, builder: &Builder<'_>) {\n         if builder.config.dry_run {\n             return;\n@@ -514,7 +563,6 @@ impl Step for TestHelpers {\n             return\n         }\n \n-        let _folder = builder.fold_output(|| \"build_test_helpers\");\n         builder.info(\"Building test helpers\");\n         t!(fs::create_dir_all(&dst));\n         let mut cfg = cc::Build::new();"}, {"sha": "4e3930c8da7fc5b2b48e9ee771655b46bfb70dc7", "filename": "src/bootstrap/sanity.rs", "status": "modified", "additions": 19, "deletions": 3, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fbootstrap%2Fsanity.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fbootstrap%2Fsanity.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Fsanity.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -15,7 +15,7 @@ use std::fs;\n use std::path::PathBuf;\n use std::process::Command;\n \n-use build_helper::output;\n+use build_helper::{output, t};\n \n use crate::Build;\n \n@@ -78,8 +78,11 @@ pub fn check(build: &mut Build) {\n \n     // We need cmake, but only if we're actually building LLVM or sanitizers.\n     let building_llvm = build.hosts.iter()\n-        .filter_map(|host| build.config.target_config.get(host))\n-        .any(|config| config.llvm_config.is_none());\n+        .map(|host| build.config.target_config\n+            .get(host)\n+            .map(|config| config.llvm_config.is_none())\n+            .unwrap_or(true))\n+        .any(|build_llvm_ourselves| build_llvm_ourselves);\n     if building_llvm || build.config.sanitizers {\n         cmd_finder.must_have(\"cmake\");\n     }\n@@ -106,6 +109,14 @@ pub fn check(build: &mut Build) {\n                 build.config.ninja = true;\n             }\n         }\n+\n+        if build.config.lldb_enabled {\n+            cmd_finder.must_have(\"swig\");\n+            let out = output(Command::new(\"swig\").arg(\"-version\"));\n+            if !out.contains(\"SWIG Version 3\") && !out.contains(\"SWIG Version 4\") {\n+                panic!(\"Ensure that Swig 3.x.x or 4.x.x is installed.\");\n+            }\n+        }\n     }\n \n     build.config.python = build.config.python.take().map(|p| cmd_finder.must_have(p))\n@@ -131,6 +142,11 @@ pub fn check(build: &mut Build) {\n             continue;\n         }\n \n+        // We don't use a C compiler on wasm32\n+        if target.contains(\"wasm32\") {\n+            continue;\n+        }\n+\n         if !build.config.dry_run {\n             cmd_finder.must_have(build.cc(*target));\n             if let Some(ar) = build.ar(*target) {"}, {"sha": "c2c134bfd1d7da7d1a7225e448a62810e9873d74", "filename": "src/bootstrap/test.rs", "status": "modified", "additions": 199, "deletions": 120, "changes": 319, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fbootstrap%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fbootstrap%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftest.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -11,7 +11,7 @@ use std::iter;\n use std::path::{Path, PathBuf};\n use std::process::Command;\n \n-use build_helper::{self, output};\n+use build_helper::{self, output, t};\n \n use crate::builder::{Builder, Compiler, Kind, RunConfig, ShouldRun, Step};\n use crate::cache::{Interned, INTERNER};\n@@ -177,7 +177,7 @@ impl Step for Cargotest {\n             cmd.arg(&builder.initial_cargo)\n                 .arg(&out_dir)\n                 .env(\"RUSTC\", builder.rustc(compiler))\n-                .env(\"RUSTDOC\", builder.rustdoc(compiler.host)),\n+                .env(\"RUSTDOC\", builder.rustdoc(compiler)),\n         );\n     }\n }\n@@ -229,6 +229,9 @@ impl Step for Cargo {\n         cargo.env(\"CFG_DISABLE_CROSS_TESTS\", \"1\");\n         // Disable a test that has issues with mingw.\n         cargo.env(\"CARGO_TEST_DISABLE_GIT_CLI\", \"1\");\n+        // Forcibly disable tests using nightly features since any changes to\n+        // those features won't be able to land.\n+        cargo.env(\"CARGO_TEST_DISABLE_NIGHTLY\", \"1\");\n \n         try_run(\n             builder,\n@@ -360,11 +363,9 @@ pub struct Miri {\n impl Step for Miri {\n     type Output = ();\n     const ONLY_HOSTS: bool = true;\n-    const DEFAULT: bool = true;\n \n     fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n-        let test_miri = run.builder.config.test_miri;\n-        run.path(\"src/tools/miri\").default_condition(test_miri)\n+        run.path(\"src/tools/miri\")\n     }\n \n     fn make_run(run: RunConfig<'_>) {\n@@ -386,26 +387,92 @@ impl Step for Miri {\n             extra_features: Vec::new(),\n         });\n         if let Some(miri) = miri {\n-            let mut cargo = tool::prepare_tool_cargo(builder,\n-                                                 compiler,\n-                                                 Mode::ToolRustc,\n-                                                 host,\n-                                                 \"test\",\n-                                                 \"src/tools/miri\",\n-                                                 SourceType::Submodule,\n-                                                 &[]);\n+            // # Run `cargo miri setup`.\n+            // As a side-effect, this will install xargo.\n+            let mut cargo = tool::prepare_tool_cargo(\n+                builder,\n+                compiler,\n+                Mode::ToolRustc,\n+                host,\n+                \"run\",\n+                \"src/tools/miri\",\n+                SourceType::Submodule,\n+                &[],\n+            );\n+            cargo\n+                .arg(\"--bin\")\n+                .arg(\"cargo-miri\")\n+                .arg(\"--\")\n+                .arg(\"miri\")\n+                .arg(\"setup\");\n+\n+            // Tell `cargo miri` not to worry about the sysroot mismatch (we built with\n+            // stage1 but run with stage2).\n+            cargo.env(\"MIRI_SKIP_SYSROOT_CHECK\", \"1\");\n+            // Tell `cargo miri setup` where to find the sources.\n+            cargo.env(\"XARGO_RUST_SRC\", builder.src.join(\"src\"));\n+            // Debug things.\n+            cargo.env(\"RUST_BACKTRACE\", \"1\");\n+            // Configure `cargo install` path, and let cargo-miri know that that's where\n+            // xargo ends up.\n+            cargo.env(\"CARGO_INSTALL_ROOT\", &builder.out); // cargo adds a `bin/`\n+            cargo.env(\"XARGO\", builder.out.join(\"bin\").join(\"xargo\"));\n+\n+            if !try_run(builder, &mut cargo) {\n+                return;\n+            }\n+\n+            // # Determine where Miri put its sysroot.\n+            // To this end, we run `cargo miri setup --env` and capture the output.\n+            // (We do this separately from the above so that when the setup actually\n+            // happens we get some output.)\n+            // We re-use the `cargo` from above.\n+            cargo.arg(\"--env\");\n+\n+            // FIXME: Is there a way in which we can re-use the usual `run` helpers?\n+            let miri_sysroot = if builder.config.dry_run {\n+                String::new()\n+            } else {\n+                builder.verbose(&format!(\"running: {:?}\", cargo));\n+                let out = cargo.output()\n+                    .expect(\"We already ran `cargo miri setup` before and that worked\");\n+                assert!(out.status.success(), \"`cargo miri setup` returned with non-0 exit code\");\n+                // Output is \"MIRI_SYSROOT=<str>\\n\".\n+                let stdout = String::from_utf8(out.stdout)\n+                    .expect(\"`cargo miri setup` stdout is not valid UTF-8\");\n+                let stdout = stdout.trim();\n+                builder.verbose(&format!(\"`cargo miri setup --env` returned: {:?}\", stdout));\n+                let sysroot = stdout.splitn(2, '=')\n+                    .nth(1).expect(\"`cargo miri setup` stdout did not contain '='\");\n+                sysroot.to_owned()\n+            };\n+\n+            // # Run `cargo test`.\n+            let mut cargo = tool::prepare_tool_cargo(\n+                builder,\n+                compiler,\n+                Mode::ToolRustc,\n+                host,\n+                \"test\",\n+                \"src/tools/miri\",\n+                SourceType::Submodule,\n+                &[],\n+            );\n \n             // miri tests need to know about the stage sysroot\n-            cargo.env(\"MIRI_SYSROOT\", builder.sysroot(compiler));\n+            cargo.env(\"MIRI_SYSROOT\", miri_sysroot);\n             cargo.env(\"RUSTC_TEST_SUITE\", builder.rustc(compiler));\n             cargo.env(\"RUSTC_LIB_PATH\", builder.rustc_libdir(compiler));\n             cargo.env(\"MIRI_PATH\", miri);\n \n             builder.add_rustc_lib_path(compiler, &mut cargo);\n \n-            if try_run(builder, &mut cargo) {\n-                builder.save_toolstate(\"miri\", ToolState::TestPass);\n+            if !try_run(builder, &mut cargo) {\n+                return;\n             }\n+\n+            // # Done!\n+            builder.save_toolstate(\"miri\", ToolState::TestPass);\n         } else {\n             eprintln!(\"failed to test miri: could not build\");\n         }\n@@ -414,7 +481,6 @@ impl Step for Miri {\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct CompiletestTest {\n-    stage: u32,\n     host: Interned<String>,\n }\n \n@@ -427,16 +493,14 @@ impl Step for CompiletestTest {\n \n     fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(CompiletestTest {\n-            stage: run.builder.top_stage,\n             host: run.target,\n         });\n     }\n \n     /// Runs `cargo test` for compiletest.\n     fn run(self, builder: &Builder<'_>) {\n-        let stage = self.stage;\n         let host = self.host;\n-        let compiler = builder.compiler(stage, host);\n+        let compiler = builder.compiler(0, host);\n \n         let mut cargo = tool::prepare_tool_cargo(builder,\n                                                  compiler,\n@@ -563,7 +627,7 @@ impl Step for RustdocTheme {\n                 builder.sysroot_libdir(self.compiler, self.compiler.host),\n             )\n             .env(\"CFG_RELEASE_CHANNEL\", &builder.config.channel)\n-            .env(\"RUSTDOC_REAL\", builder.rustdoc(self.compiler.host))\n+            .env(\"RUSTDOC_REAL\", builder.rustdoc(self.compiler))\n             .env(\"RUSTDOC_CRATE_VERSION\", builder.rust_version())\n             .env(\"RUSTC_BOOTSTRAP\", \"1\");\n         if let Some(linker) = builder.linker(self.compiler.host) {\n@@ -686,7 +750,7 @@ impl Step for RustdocUi {\n             target: self.target,\n             mode: \"ui\",\n             suite: \"rustdoc-ui\",\n-            path: None,\n+            path: Some(\"src/test/rustdoc-ui\"),\n             compare_mode: None,\n         })\n     }\n@@ -712,11 +776,10 @@ impl Step for Tidy {\n         if !builder.config.vendor {\n             cmd.arg(\"--no-vendor\");\n         }\n-        if !builder.config.verbose_tests {\n-            cmd.arg(\"--quiet\");\n+        if builder.is_verbose() {\n+            cmd.arg(\"--verbose\");\n         }\n \n-        let _folder = builder.fold_output(|| \"tidy\");\n         builder.info(\"tidy check\");\n         try_run(builder, &mut cmd);\n     }\n@@ -824,13 +887,6 @@ default_test_with_compare_mode!(Ui {\n     compare_mode: \"nll\"\n });\n \n-default_test_with_compare_mode!(RunPass {\n-    path: \"src/test/run-pass\",\n-    mode: \"run-pass\",\n-    suite: \"run-pass\",\n-    compare_mode: \"nll\"\n-});\n-\n default_test!(CompileFail {\n     path: \"src/test/compile-fail\",\n     mode: \"compile-fail\",\n@@ -885,31 +941,16 @@ host_test!(UiFullDeps {\n     suite: \"ui-fulldeps\"\n });\n \n-host_test!(RunPassFullDeps {\n-    path: \"src/test/run-pass-fulldeps\",\n-    mode: \"run-pass\",\n-    suite: \"run-pass-fulldeps\"\n-});\n-\n host_test!(Rustdoc {\n     path: \"src/test/rustdoc\",\n     mode: \"rustdoc\",\n     suite: \"rustdoc\"\n });\n \n-test!(Pretty {\n+host_test!(Pretty {\n     path: \"src/test/pretty\",\n     mode: \"pretty\",\n-    suite: \"pretty\",\n-    default: false,\n-    host: true\n-});\n-test!(RunPassPretty {\n-    path: \"src/test/run-pass/pretty\",\n-    mode: \"pretty\",\n-    suite: \"run-pass\",\n-    default: false,\n-    host: true\n+    suite: \"pretty\"\n });\n test!(RunFailPretty {\n     path: \"src/test/run-fail/pretty\",\n@@ -938,6 +979,12 @@ host_test!(RunMakeFullDeps {\n     suite: \"run-make-fulldeps\"\n });\n \n+default_test!(Assembly {\n+    path: \"src/test/assembly\",\n+    mode: \"assembly\",\n+    suite: \"assembly\"\n+});\n+\n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n struct Compiletest {\n     compiler: Compiler,\n@@ -975,14 +1022,10 @@ impl Step for Compiletest {\n         }\n \n         if suite == \"debuginfo\" {\n-            // Skip debuginfo tests on MSVC\n-            if builder.config.build.contains(\"msvc\") {\n-                return;\n-            }\n-\n+            let msvc = builder.config.build.contains(\"msvc\");\n             if mode == \"debuginfo\" {\n                 return builder.ensure(Compiletest {\n-                    mode: \"debuginfo-both\",\n+                    mode: if msvc { \"debuginfo-cdb\" } else { \"debuginfo-gdb+lldb\" },\n                     ..self\n                 });\n             }\n@@ -993,11 +1036,7 @@ impl Step for Compiletest {\n             });\n         }\n \n-        if suite.ends_with(\"fulldeps\") ||\n-            // FIXME: Does pretty need librustc compiled? Note that there are\n-            // fulldeps test suites with mode = pretty as well.\n-            mode == \"pretty\"\n-        {\n+        if suite.ends_with(\"fulldeps\") {\n             builder.ensure(compile::Rustc { compiler, target });\n         }\n \n@@ -1019,7 +1058,10 @@ impl Step for Compiletest {\n         // Also provide `rust_test_helpers` for the host.\n         builder.ensure(native::TestHelpers { target: compiler.host });\n \n-        builder.ensure(native::TestHelpers { target });\n+        // wasm32 can't build the test helpers\n+        if !target.contains(\"wasm32\") {\n+            builder.ensure(native::TestHelpers { target });\n+        }\n         builder.ensure(RemoteCopyLibs { compiler, target });\n \n         let mut cmd = builder.tool_cmd(Tool::Compiletest);\n@@ -1042,7 +1084,7 @@ impl Step for Compiletest {\n             || mode == \"js-doc-test\"\n         {\n             cmd.arg(\"--rustdoc-path\")\n-                .arg(builder.rustdoc(compiler.host));\n+                .arg(builder.rustdoc(compiler));\n         }\n \n         cmd.arg(\"--src-base\")\n@@ -1069,6 +1111,11 @@ impl Step for Compiletest {\n             }\n         });\n \n+        if let Some(ref pass) = builder.config.cmd.pass() {\n+            cmd.arg(\"--pass\");\n+            cmd.arg(pass);\n+        }\n+\n         if let Some(ref nodejs) = builder.config.nodejs {\n             cmd.arg(\"--nodejs\").arg(nodejs);\n         }\n@@ -1082,10 +1129,8 @@ impl Step for Compiletest {\n             if builder.config.rust_optimize_tests {\n                 flags.push(\"-O\".to_string());\n             }\n-            if builder.config.rust_debuginfo_tests {\n-                flags.push(\"-g\".to_string());\n-            }\n         }\n+        flags.push(format!(\"-Cdebuginfo={}\", builder.config.rust_debuginfo_level_tests));\n         flags.push(\"-Zunstable-options\".to_string());\n         flags.push(builder.config.cmd.rustc_args().join(\" \"));\n \n@@ -1149,24 +1194,9 @@ impl Step for Compiletest {\n             }\n         }\n \n-        if let Some(var) = env::var_os(\"RUSTBUILD_FORCE_CLANG_BASED_TESTS\") {\n-            match &var.to_string_lossy().to_lowercase()[..] {\n-                \"1\" | \"yes\" | \"on\" => {\n-                    assert!(builder.config.lldb_enabled,\n-                        \"RUSTBUILD_FORCE_CLANG_BASED_TESTS needs Clang/LLDB to \\\n-                         be built.\");\n-                    let clang_exe = builder.llvm_out(target).join(\"bin\").join(\"clang\");\n-                    cmd.arg(\"--run-clang-based-tests-with\").arg(clang_exe);\n-                }\n-                \"0\" | \"no\" | \"off\" => {\n-                    // Nothing to do.\n-                }\n-                other => {\n-                    // Let's make sure typos don't get unnoticed\n-                    panic!(\"Unrecognized option '{}' set in \\\n-                            RUSTBUILD_FORCE_CLANG_BASED_TESTS\", other);\n-                }\n-            }\n+        if util::forcing_clang_based_tests() {\n+            let clang_exe = builder.llvm_out(target).join(\"bin\").join(\"clang\");\n+            cmd.arg(\"--run-clang-based-tests-with\").arg(clang_exe);\n         }\n \n         // Get paths from cmd args\n@@ -1184,8 +1214,19 @@ impl Step for Compiletest {\n                     Err(_) => p,\n                 }\n             })\n-            .filter(|p| p.starts_with(suite_path) && p.is_file())\n-            .map(|p| p.strip_prefix(suite_path).unwrap().to_str().unwrap())\n+            .filter(|p| p.starts_with(suite_path) && (p.is_dir() || p.is_file()))\n+            .filter_map(|p| {\n+                // Since test suite paths are themselves directories, if we don't\n+                // specify a directory or file, we'll get an empty string here\n+                // (the result of the test suite directory without its suite prefix).\n+                // Therefore, we need to filter these out, as only the first --test-args\n+                // flag is respected, so providing an empty --test-args conflicts with\n+                // any following it.\n+                match p.strip_prefix(suite_path).ok().and_then(|p| p.to_str()) {\n+                    Some(s) if s != \"\" => Some(s),\n+                    _ => None,\n+                }\n+            })\n             .collect();\n \n         test_args.append(&mut builder.config.cmd.test_args());\n@@ -1200,7 +1241,7 @@ impl Step for Compiletest {\n             cmd.arg(\"--quiet\");\n         }\n \n-        if builder.config.llvm_enabled {\n+        if builder.config.llvm_enabled() {\n             let llvm_config = builder.ensure(native::Llvm {\n                 target: builder.config.build,\n                 emscripten: false,\n@@ -1231,14 +1272,30 @@ impl Step for Compiletest {\n                 if let Some(ar) = builder.ar(target) {\n                     cmd.arg(\"--ar\").arg(ar);\n                 }\n+\n+                // The llvm/bin directory contains many useful cross-platform\n+                // tools. Pass the path to run-make tests so they can use them.\n+                let llvm_bin_path = llvm_config.parent()\n+                    .expect(\"Expected llvm-config to be contained in directory\");\n+                assert!(llvm_bin_path.is_dir());\n+                cmd.arg(\"--llvm-bin-dir\").arg(llvm_bin_path);\n+\n+                // If LLD is available, add it to the PATH\n+                if builder.config.lld_enabled {\n+                    let lld_install_root = builder.ensure(native::Lld {\n+                        target: builder.config.build,\n+                    });\n+\n+                    let lld_bin_path = lld_install_root.join(\"bin\");\n+\n+                    let old_path = env::var_os(\"PATH\").unwrap_or_default();\n+                    let new_path = env::join_paths(std::iter::once(lld_bin_path)\n+                        .chain(env::split_paths(&old_path)))\n+                        .expect(\"Could not add LLD bin path to PATH\");\n+                    cmd.env(\"PATH\", new_path);\n+                }\n             }\n         }\n-        if suite == \"run-make-fulldeps\" && !builder.config.llvm_enabled {\n-            builder.info(\n-                \"Ignoring run-make test suite as they generally don't work without LLVM\"\n-            );\n-            return;\n-        }\n \n         if suite != \"run-make-fulldeps\" {\n             cmd.arg(\"--cc\")\n@@ -1274,11 +1331,11 @@ impl Step for Compiletest {\n         builder.add_rust_test_threads(&mut cmd);\n \n         if builder.config.sanitizers {\n-            cmd.env(\"SANITIZER_SUPPORT\", \"1\");\n+            cmd.env(\"RUSTC_SANITIZER_SUPPORT\", \"1\");\n         }\n \n         if builder.config.profiler {\n-            cmd.env(\"PROFILER_SUPPORT\", \"1\");\n+            cmd.env(\"RUSTC_PROFILER_SUPPORT\", \"1\");\n         }\n \n         cmd.env(\"RUST_TEST_TMPDIR\", builder.out.join(\"tmp\"));\n@@ -1293,9 +1350,12 @@ impl Step for Compiletest {\n             cmd.arg(\"--android-cross-path\").arg(\"\");\n         }\n \n+        if builder.config.cmd.rustfix_coverage() {\n+            cmd.arg(\"--rustfix-coverage\");\n+        }\n+\n         builder.ci_env.force_coloring_in_ci(&mut cmd);\n \n-        let _folder = builder.fold_output(|| format!(\"test_{}\", suite));\n         builder.info(&format!(\n             \"Check compiletest suite={} mode={} ({} -> {})\",\n             suite, mode, &compiler.host, target\n@@ -1305,7 +1365,6 @@ impl Step for Compiletest {\n \n         if let Some(compare_mode) = compare_mode {\n             cmd.arg(\"--compare-mode\").arg(compare_mode);\n-            let _folder = builder.fold_output(|| format!(\"test_{}_{}\", suite, compare_mode));\n             builder.info(&format!(\n                 \"Check compiletest suite={} mode={} compare_mode={} ({} -> {})\",\n                 suite, mode, compare_mode, &compiler.host, target\n@@ -1349,7 +1408,6 @@ impl Step for DocTest {\n         // tests for all files that end in `*.md`\n         let mut stack = vec![builder.src.join(self.path)];\n         let _time = util::timeit(&builder);\n-        let _folder = builder.fold_output(|| format!(\"test_{}\", self.name));\n \n         let mut files = Vec::new();\n         while let Some(p) = stack.pop() {\n@@ -1430,6 +1488,7 @@ test_book!(\n     EmbeddedBook, \"src/doc/embedded-book\", \"embedded-book\", default=false;\n     TheBook, \"src/doc/book\", \"book\", default=false;\n     UnstableBook, \"src/doc/unstable-book\", \"unstable-book\", default=true;\n+    EditionGuide, \"src/doc/edition-guide\", \"edition-guide\", default=false;\n );\n \n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n@@ -1470,16 +1529,18 @@ impl Step for ErrorIndex {\n         t!(fs::create_dir_all(&dir));\n         let output = dir.join(\"error-index.md\");\n \n-        let mut tool = builder.tool_cmd(Tool::ErrorIndex);\n+        let mut tool = tool::ErrorIndex::command(\n+            builder,\n+            builder.compiler(compiler.stage, builder.config.build),\n+        );\n         tool.arg(\"markdown\")\n             .arg(&output)\n             .env(\"CFG_BUILD\", &builder.config.build)\n             .env(\"RUSTC_ERROR_METADATA_DST\", builder.extended_error_dir());\n \n-        let _folder = builder.fold_output(|| \"test_error_index\");\n         builder.info(&format!(\"Testing error-index stage{}\", compiler.stage));\n         let _time = util::timeit(&builder);\n-        builder.run(&mut tool);\n+        builder.run_quiet(&mut tool);\n         markdown_test(builder, compiler, &output);\n     }\n }\n@@ -1495,7 +1556,7 @@ fn markdown_test(builder: &Builder<'_>, compiler: Compiler, markdown: &Path) ->\n     }\n \n     builder.info(&format!(\"doc tests for: {}\", markdown.display()));\n-    let mut cmd = builder.rustdoc_cmd(compiler.host);\n+    let mut cmd = builder.rustdoc_cmd(compiler);\n     builder.add_rust_test_threads(&mut cmd);\n     cmd.arg(\"--test\");\n     cmd.arg(markdown);\n@@ -1511,6 +1572,34 @@ fn markdown_test(builder: &Builder<'_>, compiler: Compiler, markdown: &Path) ->\n     }\n }\n \n+#[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n+pub struct RustcGuide;\n+\n+impl Step for RustcGuide {\n+    type Output = ();\n+    const DEFAULT: bool = false;\n+    const ONLY_HOSTS: bool = true;\n+\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n+        run.path(\"src/doc/rustc-guide\")\n+    }\n+\n+    fn make_run(run: RunConfig<'_>) {\n+        run.builder.ensure(RustcGuide);\n+    }\n+\n+    fn run(self, builder: &Builder<'_>) {\n+        let src = builder.src.join(\"src/doc/rustc-guide\");\n+        let mut rustbook_cmd = builder.tool_cmd(Tool::Rustbook);\n+        let toolstate = if try_run(builder, rustbook_cmd.arg(\"linkcheck\").arg(&src)) {\n+            ToolState::TestPass\n+        } else {\n+            ToolState::TestFail\n+        };\n+        builder.save_toolstate(\"rustc-guide\", toolstate);\n+    }\n+}\n+\n #[derive(Debug, Copy, Clone, PartialEq, Eq, Hash)]\n pub struct CrateLibrustc {\n     compiler: Compiler,\n@@ -1676,15 +1765,11 @@ impl Step for Crate {\n         builder.ensure(compile::Test { compiler, target });\n         builder.ensure(RemoteCopyLibs { compiler, target });\n \n-        // If we're not doing a full bootstrap but we're testing a stage2 version of\n-        // libstd, then what we're actually testing is the libstd produced in\n-        // stage1. Reflect that here by updating the compiler that we're working\n-        // with automatically.\n-        let compiler = if builder.force_use_stage1(compiler, target) {\n-            builder.compiler(1, compiler.host)\n-        } else {\n-            compiler.clone()\n-        };\n+        // If we're not doing a full bootstrap but we're testing a stage2\n+        // version of libstd, then what we're actually testing is the libstd\n+        // produced in stage1. Reflect that here by updating the compiler that\n+        // we're working with automatically.\n+        let compiler = builder.compiler_for(compiler.stage, compiler.host, target);\n \n         let mut cargo = builder.cargo(compiler, mode, target, test_kind.subcommand());\n         match mode {\n@@ -1779,14 +1864,6 @@ impl Step for Crate {\n             );\n         }\n \n-        let _folder = builder.fold_output(|| {\n-            format!(\n-                \"{}_stage{}-{}\",\n-                test_kind.subcommand(),\n-                compiler.stage,\n-                krate\n-            )\n-        });\n         builder.info(&format!(\n             \"{} {} stage{} ({} -> {})\",\n             test_kind, krate, compiler.stage, &compiler.host, target\n@@ -1846,12 +1923,14 @@ impl Step for CrateRustdoc {\n         cargo.arg(\"--\");\n         cargo.args(&builder.config.cmd.test_args());\n \n+        if self.host.contains(\"musl\") {\n+            cargo.arg(\"'-Ctarget-feature=-crt-static'\");\n+        }\n+\n         if !builder.config.verbose_tests {\n             cargo.arg(\"--quiet\");\n         }\n \n-        let _folder = builder\n-            .fold_output(|| format!(\"{}_stage{}-rustdoc\", test_kind.subcommand(), compiler.stage));\n         builder.info(&format!(\n             \"{} rustdoc stage{} ({} -> {})\",\n             test_kind, compiler.stage, &compiler.host, target"}, {"sha": "15a329a5b91529334c24a91d3d3c703cc50a77d8", "filename": "src/bootstrap/tool.rs", "status": "modified", "additions": 147, "deletions": 152, "changes": 299, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fbootstrap%2Ftool.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fbootstrap%2Ftool.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftool.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -4,12 +4,13 @@ use std::path::PathBuf;\n use std::process::{Command, exit};\n use std::collections::HashSet;\n \n+use build_helper::t;\n+\n use crate::Mode;\n use crate::Compiler;\n use crate::builder::{Step, RunConfig, ShouldRun, Builder};\n use crate::util::{exe, add_lib_path};\n use crate::compile;\n-use crate::native;\n use crate::channel::GitInfo;\n use crate::channel;\n use crate::cache::Interned;\n@@ -73,16 +74,16 @@ impl Step for ToolBuild {\n             &self.extra_features,\n         );\n \n-        let _folder = builder.fold_output(|| format!(\"stage{}-{}\", compiler.stage, tool));\n         builder.info(&format!(\"Building stage{} tool {} ({})\", compiler.stage, tool, target));\n         let mut duplicates = Vec::new();\n-        let is_expected = compile::stream_cargo(builder, &mut cargo, &mut |msg| {\n+        let is_expected = compile::stream_cargo(builder, &mut cargo, vec![], &mut |msg| {\n             // Only care about big things like the RLS/Cargo for now\n             match tool {\n                 | \"rls\"\n                 | \"cargo\"\n                 | \"clippy-driver\"\n                 | \"miri\"\n+                | \"rustfmt\"\n                 => {}\n \n                 _ => return,\n@@ -107,36 +108,63 @@ impl Step for ToolBuild {\n                     continue\n                 }\n \n-                // Don't worry about libs that turn out to be host dependencies\n-                // or build scripts, we only care about target dependencies that\n-                // are in `deps`.\n-                if let Some(maybe_target) = val.1\n-                    .parent()                   // chop off file name\n-                    .and_then(|p| p.parent())   // chop off `deps`\n-                    .and_then(|p| p.parent())   // chop off `release`\n-                    .and_then(|p| p.file_name())\n-                    .and_then(|p| p.to_str())\n-                {\n-                    if maybe_target != &*target {\n-                        continue\n+                // Don't worry about compiles that turn out to be host\n+                // dependencies or build scripts. To skip these we look for\n+                // anything that goes in `.../release/deps` but *doesn't* go in\n+                // `$target/release/deps`. This ensure that outputs in\n+                // `$target/release` are still considered candidates for\n+                // deduplication.\n+                if let Some(parent) = val.1.parent() {\n+                    if parent.ends_with(\"release/deps\") {\n+                        let maybe_target = parent\n+                            .parent()\n+                            .and_then(|p| p.parent())\n+                            .and_then(|p| p.file_name())\n+                            .and_then(|p| p.to_str())\n+                            .unwrap();\n+                        if maybe_target != &*target {\n+                            continue;\n+                        }\n                     }\n                 }\n \n+                // Record that we've built an artifact for `id`, and if one was\n+                // already listed then we need to see if we reused the same\n+                // artifact or produced a duplicate.\n                 let mut artifacts = builder.tool_artifacts.borrow_mut();\n                 let prev_artifacts = artifacts\n                     .entry(target)\n                     .or_default();\n-                if let Some(prev) = prev_artifacts.get(&*id) {\n-                    if prev.1 != val.1 {\n-                        duplicates.push((\n-                            id.to_string(),\n-                            val,\n-                            prev.clone(),\n-                        ));\n+                let prev = match prev_artifacts.get(&*id) {\n+                    Some(prev) => prev,\n+                    None => {\n+                        prev_artifacts.insert(id.to_string(), val);\n+                        continue;\n                     }\n-                    return\n+                };\n+                if prev.1 == val.1 {\n+                    return; // same path, same artifact\n                 }\n-                prev_artifacts.insert(id.to_string(), val);\n+\n+                // If the paths are different and one of them *isn't* inside of\n+                // `release/deps`, then it means it's probably in\n+                // `$target/release`, or it's some final artifact like\n+                // `libcargo.rlib`. In these situations Cargo probably just\n+                // copied it up from `$target/release/deps/libcargo-xxxx.rlib`,\n+                // so if the features are equal we can just skip it.\n+                let prev_no_hash = prev.1.parent().unwrap().ends_with(\"release/deps\");\n+                let val_no_hash = val.1.parent().unwrap().ends_with(\"release/deps\");\n+                if prev.2 == val.2 || !prev_no_hash || !val_no_hash {\n+                    return;\n+                }\n+\n+                // ... and otherwise this looks like we duplicated some sort of\n+                // compilation, so record it to generate an error later.\n+                duplicates.push((\n+                    id.to_string(),\n+                    val,\n+                    prev.clone(),\n+                ));\n             }\n         });\n \n@@ -235,7 +263,7 @@ pub fn prepare_tool_cargo(\n     cargo.env(\"CFG_VERSION\", builder.rust_version());\n     cargo.env(\"CFG_RELEASE_NUM\", channel::CFG_RELEASE_NUM);\n \n-    let info = GitInfo::new(&builder.config, &dir);\n+    let info = GitInfo::new(builder.config.ignore_git, &dir);\n     if let Some(sha) = info.sha() {\n         cargo.env(\"CFG_COMMIT_HASH\", sha);\n     }\n@@ -251,9 +279,9 @@ pub fn prepare_tool_cargo(\n     cargo\n }\n \n-macro_rules! tool {\n+macro_rules! bootstrap_tool {\n     ($(\n-        $name:ident, $path:expr, $tool_name:expr, $mode:expr\n+        $name:ident, $path:expr, $tool_name:expr\n         $(,llvm_tools = $llvm:expr)*\n         $(,is_external_tool = $external:expr)*\n         ;\n@@ -266,13 +294,6 @@ macro_rules! tool {\n         }\n \n         impl Tool {\n-            pub fn get_mode(&self) -> Mode {\n-                let mode = match self {\n-                    $(Tool::$name => $mode,)+\n-                };\n-                mode\n-            }\n-\n             /// Whether this tool requires LLVM to run\n             pub fn uses_llvm_tools(&self) -> bool {\n                 match self {\n@@ -283,27 +304,15 @@ macro_rules! tool {\n \n         impl<'a> Builder<'a> {\n             pub fn tool_exe(&self, tool: Tool) -> PathBuf {\n-                let stage = self.tool_default_stage(tool);\n                 match tool {\n                     $(Tool::$name =>\n                         self.ensure($name {\n-                            compiler: self.compiler(stage, self.config.build),\n+                            compiler: self.compiler(0, self.config.build),\n                             target: self.config.build,\n                         }),\n                     )+\n                 }\n             }\n-\n-            pub fn tool_default_stage(&self, tool: Tool) -> u32 {\n-                // Compile the error-index in the same stage as rustdoc to avoid\n-                // recompiling rustdoc twice if we can. Otherwise compile\n-                // everything else in stage0 as there's no need to rebootstrap\n-                // everything.\n-                match tool {\n-                    Tool::ErrorIndex if self.top_stage >= 2 => self.top_stage,\n-                    _ => 0,\n-                }\n-            }\n         }\n \n         $(\n@@ -322,7 +331,8 @@ macro_rules! tool {\n \n             fn make_run(run: RunConfig<'_>) {\n                 run.builder.ensure($name {\n-                    compiler: run.builder.compiler(run.builder.top_stage, run.builder.config.build),\n+                    // snapshot compiler\n+                    compiler: run.builder.compiler(0, run.builder.config.build),\n                     target: run.target,\n                 });\n             }\n@@ -332,7 +342,7 @@ macro_rules! tool {\n                     compiler: self.compiler,\n                     target: self.target,\n                     tool: $tool_name,\n-                    mode: $mode,\n+                    mode: Mode::ToolBootstrap,\n                     path: $path,\n                     is_optional_tool: false,\n                     source_type: if false $(|| $external)* {\n@@ -348,21 +358,67 @@ macro_rules! tool {\n     }\n }\n \n-tool!(\n-    Rustbook, \"src/tools/rustbook\", \"rustbook\", Mode::ToolBootstrap;\n-    ErrorIndex, \"src/tools/error_index_generator\", \"error_index_generator\", Mode::ToolRustc;\n-    UnstableBookGen, \"src/tools/unstable-book-gen\", \"unstable-book-gen\", Mode::ToolBootstrap;\n-    Tidy, \"src/tools/tidy\", \"tidy\", Mode::ToolBootstrap;\n-    Linkchecker, \"src/tools/linkchecker\", \"linkchecker\", Mode::ToolBootstrap;\n-    CargoTest, \"src/tools/cargotest\", \"cargotest\", Mode::ToolBootstrap;\n-    Compiletest, \"src/tools/compiletest\", \"compiletest\", Mode::ToolBootstrap, llvm_tools = true;\n-    BuildManifest, \"src/tools/build-manifest\", \"build-manifest\", Mode::ToolBootstrap;\n-    RemoteTestClient, \"src/tools/remote-test-client\", \"remote-test-client\", Mode::ToolBootstrap;\n-    RustInstaller, \"src/tools/rust-installer\", \"fabricate\", Mode::ToolBootstrap,\n-        is_external_tool = true;\n-    RustdocTheme, \"src/tools/rustdoc-themes\", \"rustdoc-themes\", Mode::ToolBootstrap;\n+bootstrap_tool!(\n+    Rustbook, \"src/tools/rustbook\", \"rustbook\";\n+    UnstableBookGen, \"src/tools/unstable-book-gen\", \"unstable-book-gen\";\n+    Tidy, \"src/tools/tidy\", \"tidy\";\n+    Linkchecker, \"src/tools/linkchecker\", \"linkchecker\";\n+    CargoTest, \"src/tools/cargotest\", \"cargotest\";\n+    Compiletest, \"src/tools/compiletest\", \"compiletest\", llvm_tools = true;\n+    BuildManifest, \"src/tools/build-manifest\", \"build-manifest\";\n+    RemoteTestClient, \"src/tools/remote-test-client\", \"remote-test-client\";\n+    RustInstaller, \"src/tools/rust-installer\", \"fabricate\", is_external_tool = true;\n+    RustdocTheme, \"src/tools/rustdoc-themes\", \"rustdoc-themes\";\n );\n \n+#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n+pub struct ErrorIndex {\n+    pub compiler: Compiler,\n+}\n+\n+impl ErrorIndex {\n+    pub fn command(builder: &Builder<'_>, compiler: Compiler) -> Command {\n+        let mut cmd = Command::new(builder.ensure(ErrorIndex {\n+            compiler\n+        }));\n+        add_lib_path(\n+            vec![PathBuf::from(&builder.sysroot_libdir(compiler, compiler.host))],\n+            &mut cmd,\n+        );\n+        cmd\n+    }\n+}\n+\n+impl Step for ErrorIndex {\n+    type Output = PathBuf;\n+\n+    fn should_run(run: ShouldRun<'_>) -> ShouldRun<'_> {\n+        run.path(\"src/tools/error_index_generator\")\n+    }\n+\n+    fn make_run(run: RunConfig<'_>) {\n+        // Compile the error-index in the same stage as rustdoc to avoid\n+        // recompiling rustdoc twice if we can.\n+        let stage = if run.builder.top_stage >= 2 { run.builder.top_stage } else { 0 };\n+        run.builder.ensure(ErrorIndex {\n+            compiler: run.builder.compiler(stage, run.builder.config.build),\n+        });\n+    }\n+\n+    fn run(self, builder: &Builder<'_>) -> PathBuf {\n+        builder.ensure(ToolBuild {\n+            compiler: self.compiler,\n+            target: self.compiler.host,\n+            tool: \"error_index_generator\",\n+            mode: Mode::ToolRustc,\n+            path: \"src/tools/error_index_generator\",\n+            is_optional_tool: false,\n+            source_type: SourceType::InTree,\n+            extra_features: Vec::new(),\n+        }).expect(\"expected to build -- essential tool\")\n+    }\n+}\n+\n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct RemoteTestServer {\n     pub compiler: Compiler,\n@@ -399,7 +455,9 @@ impl Step for RemoteTestServer {\n \n #[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]\n pub struct Rustdoc {\n-    pub host: Interned<String>,\n+    /// This should only ever be 0 or 2.\n+    /// We sometimes want to reference the \"bootstrap\" rustdoc, which is why this option is here.\n+    pub compiler: Compiler,\n }\n \n impl Step for Rustdoc {\n@@ -413,12 +471,12 @@ impl Step for Rustdoc {\n \n     fn make_run(run: RunConfig<'_>) {\n         run.builder.ensure(Rustdoc {\n-            host: run.host,\n+            compiler: run.builder.compiler(run.builder.top_stage, run.host),\n         });\n     }\n \n     fn run(self, builder: &Builder<'_>) -> PathBuf {\n-        let target_compiler = builder.compiler(builder.top_stage, self.host);\n+        let target_compiler = self.compiler;\n         if target_compiler.stage == 0 {\n             if !target_compiler.is_snapshot(builder) {\n                 panic!(\"rustdoc in stage 0 must be snapshot rustdoc\");\n@@ -450,11 +508,6 @@ impl Step for Rustdoc {\n             &[],\n         );\n \n-        // Most tools don't get debuginfo, but rustdoc should.\n-        cargo.env(\"RUSTC_DEBUGINFO\", builder.config.rust_debuginfo.to_string())\n-             .env(\"RUSTC_DEBUGINFO_LINES\", builder.config.rust_debuginfo_lines.to_string());\n-\n-        let _folder = builder.fold_output(|| format!(\"stage{}-rustdoc\", target_compiler.stage));\n         builder.info(&format!(\"Building rustdoc for stage{} ({})\",\n             target_compiler.stage, target_compiler.host));\n         builder.run(&mut cargo);\n@@ -504,9 +557,9 @@ impl Step for Cargo {\n     }\n \n     fn run(self, builder: &Builder<'_>) -> PathBuf {\n-        // Cargo depends on procedural macros, which requires a full host\n-        // compiler to be available, so we need to depend on that.\n-        builder.ensure(compile::Rustc {\n+        // Cargo depends on procedural macros, so make sure the host\n+        // libstd/libproc_macro is available.\n+        builder.ensure(compile::Test {\n             compiler: self.compiler,\n             target: builder.config.build,\n         });\n@@ -578,26 +631,26 @@ macro_rules! tool_extended {\n tool_extended!((self, builder),\n     Cargofmt, rustfmt, \"src/tools/rustfmt\", \"cargo-fmt\", {};\n     CargoClippy, clippy, \"src/tools/clippy\", \"cargo-clippy\", {\n-        // Clippy depends on procedural macros (serde), which requires a full host\n-        // compiler to be available, so we need to depend on that.\n-        builder.ensure(compile::Rustc {\n+        // Clippy depends on procedural macros, so make sure that's built for\n+        // the compiler itself.\n+        builder.ensure(compile::Test {\n             compiler: self.compiler,\n             target: builder.config.build,\n         });\n     };\n     Clippy, clippy, \"src/tools/clippy\", \"clippy-driver\", {\n-        // Clippy depends on procedural macros (serde), which requires a full host\n-        // compiler to be available, so we need to depend on that.\n-        builder.ensure(compile::Rustc {\n+        // Clippy depends on procedural macros, so make sure that's built for\n+        // the compiler itself.\n+        builder.ensure(compile::Test {\n             compiler: self.compiler,\n             target: builder.config.build,\n         });\n     };\n     Miri, miri, \"src/tools/miri\", \"miri\", {};\n     CargoMiri, miri, \"src/tools/miri\", \"cargo-miri\", {\n-        // Miri depends on procedural macros (serde), which requires a full host\n-        // compiler to be available, so we need to depend on that.\n-        builder.ensure(compile::Rustc {\n+        // Miri depends on procedural macros, so make sure that's built for\n+        // the compiler itself.\n+        builder.ensure(compile::Test {\n             compiler: self.compiler,\n             target: builder.config.build,\n         });\n@@ -611,9 +664,9 @@ tool_extended!((self, builder),\n         if clippy.is_some() {\n             self.extra_features.push(\"clippy\".to_owned());\n         }\n-        // RLS depends on procedural macros, which requires a full host\n-        // compiler to be available, so we need to depend on that.\n-        builder.ensure(compile::Rustc {\n+        // RLS depends on procedural macros, so make sure that's built for\n+        // the compiler itself.\n+        builder.ensure(compile::Test {\n             compiler: self.compiler,\n             target: builder.config.build,\n         });\n@@ -626,24 +679,15 @@ impl<'a> Builder<'a> {\n     /// `host`.\n     pub fn tool_cmd(&self, tool: Tool) -> Command {\n         let mut cmd = Command::new(self.tool_exe(tool));\n-        let compiler = self.compiler(self.tool_default_stage(tool), self.config.build);\n-        self.prepare_tool_cmd(compiler, tool, &mut cmd);\n-        cmd\n-    }\n-\n-    /// Prepares the `cmd` provided to be able to run the `compiler` provided.\n-    ///\n-    /// Notably this munges the dynamic library lookup path to point to the\n-    /// right location to run `compiler`.\n-    fn prepare_tool_cmd(&self, compiler: Compiler, tool: Tool, cmd: &mut Command) {\n+        let compiler = self.compiler(0, self.config.build);\n         let host = &compiler.host;\n+        // Prepares the `cmd` provided to be able to run the `compiler` provided.\n+        //\n+        // Notably this munges the dynamic library lookup path to point to the\n+        // right location to run `compiler`.\n         let mut lib_paths: Vec<PathBuf> = vec![\n-            if compiler.stage == 0 && tool != Tool::ErrorIndex {\n-                self.build.rustc_snapshot_libdir()\n-            } else {\n-                PathBuf::from(&self.sysroot_libdir(compiler, compiler.host))\n-            },\n-            self.cargo_out(compiler, tool.get_mode(), *host).join(\"deps\"),\n+            self.build.rustc_snapshot_libdir(),\n+            self.cargo_out(compiler, Mode::ToolBootstrap, *host).join(\"deps\"),\n         ];\n \n         // On MSVC a tool may invoke a C compiler (e.g., compiletest in run-make\n@@ -664,56 +708,7 @@ impl<'a> Builder<'a> {\n             }\n         }\n \n-        // Add the llvm/bin directory to PATH since it contains lots of\n-        // useful, platform-independent tools\n-        if tool.uses_llvm_tools() && !self.config.dry_run {\n-            let mut additional_paths = vec![];\n-\n-            if let Some(llvm_bin_path) = self.llvm_bin_path() {\n-                additional_paths.push(llvm_bin_path);\n-            }\n-\n-            // If LLD is available, add that too.\n-            if self.config.lld_enabled {\n-                let lld_install_root = self.ensure(native::Lld {\n-                    target: self.config.build,\n-                });\n-\n-                let lld_bin_path = lld_install_root.join(\"bin\");\n-                additional_paths.push(lld_bin_path);\n-            }\n-\n-            if host.contains(\"windows\") {\n-                // On Windows, PATH and the dynamic library path are the same,\n-                // so we just add the LLVM bin path to lib_path\n-                lib_paths.extend(additional_paths);\n-            } else {\n-                let old_path = env::var_os(\"PATH\").unwrap_or_default();\n-                let new_path = env::join_paths(additional_paths.into_iter()\n-                        .chain(env::split_paths(&old_path)))\n-                    .expect(\"Could not add LLVM bin path to PATH\");\n-                cmd.env(\"PATH\", new_path);\n-            }\n-        }\n-\n-        add_lib_path(lib_paths, cmd);\n-    }\n-\n-    fn llvm_bin_path(&self) -> Option<PathBuf> {\n-        if self.config.llvm_enabled {\n-            let llvm_config = self.ensure(native::Llvm {\n-                target: self.config.build,\n-                emscripten: false,\n-            });\n-\n-            // Add the llvm/bin directory to PATH since it contains lots of\n-            // useful, platform-independent tools\n-            let llvm_bin_path = llvm_config.parent()\n-                .expect(\"Expected llvm-config to be contained in directory\");\n-            assert!(llvm_bin_path.is_dir());\n-            Some(llvm_bin_path.to_path_buf())\n-        } else {\n-            None\n-        }\n+        add_lib_path(lib_paths, &mut cmd);\n+        cmd\n     }\n }"}, {"sha": "e86209be91fe17c0d4e198b920980199a830116a", "filename": "src/bootstrap/toolstate.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fbootstrap%2Ftoolstate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fbootstrap%2Ftoolstate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Ftoolstate.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -1,3 +1,5 @@\n+use serde::{Deserialize, Serialize};\n+\n #[derive(Copy, Clone, Debug, Deserialize, Serialize, PartialEq, Eq)]\n #[serde(rename_all = \"kebab-case\")]\n /// Whether a tool can be compiled, tested or neither"}, {"sha": "98ae7b692bb3c7524bc01bde8bbfea1b799f8fcf", "filename": "src/bootstrap/util.rs", "status": "modified", "additions": 25, "deletions": 73, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fbootstrap%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fbootstrap%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbootstrap%2Futil.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -6,10 +6,12 @@\n use std::env;\n use std::str;\n use std::fs;\n-use std::io::{self, Write};\n+use std::io;\n use std::path::{Path, PathBuf};\n use std::process::Command;\n-use std::time::{SystemTime, Instant};\n+use std::time::Instant;\n+\n+use build_helper::t;\n \n use crate::config::Config;\n use crate::builder::Builder;\n@@ -207,7 +209,7 @@ pub fn symlink_dir(config: &Config, src: &Path, dest: &Path) -> io::Result<()> {\n             let h = CreateFileW(path.as_ptr(),\n                                 GENERIC_WRITE,\n                                 FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,\n-                                0 as *mut _,\n+                                ptr::null_mut(),\n                                 OPEN_EXISTING,\n                                 FILE_FLAG_OPEN_REPARSE_POINT | FILE_FLAG_BACKUP_SEMANTICS,\n                                 ptr::null_mut());\n@@ -252,87 +254,21 @@ pub fn symlink_dir(config: &Config, src: &Path, dest: &Path) -> io::Result<()> {\n     }\n }\n \n-/// An RAII structure that indicates all output until this instance is dropped\n-/// is part of the same group.\n-///\n-/// On Travis CI, these output will be folded by default, together with the\n-/// elapsed time in this block. This reduces noise from unnecessary logs,\n-/// allowing developers to quickly identify the error.\n-///\n-/// Travis CI supports folding by printing `travis_fold:start:<name>` and\n-/// `travis_fold:end:<name>` around the block. Time elapsed is recognized\n-/// similarly with `travis_time:[start|end]:<name>`. These are undocumented, but\n-/// can easily be deduced from source code of the [Travis build commands].\n-///\n-/// [Travis build commands]:\n-/// https://github.com/travis-ci/travis-build/blob/f603c0089/lib/travis/build/templates/header.sh\n-pub struct OutputFolder {\n-    name: String,\n-    start_time: SystemTime, // we need SystemTime to get the UNIX timestamp.\n-}\n-\n-impl OutputFolder {\n-    /// Creates a new output folder with the given group name.\n-    pub fn new(name: String) -> OutputFolder {\n-        // \"\\r\" moves the cursor to the beginning of the line, and \"\\x1b[0K\" is\n-        // the ANSI escape code to clear from the cursor to end of line.\n-        // Travis seems to have trouble when _not_ using \"\\r\\x1b[0K\", that will\n-        // randomly put lines to the top of the webpage.\n-        print!(\"travis_fold:start:{0}\\r\\x1b[0Ktravis_time:start:{0}\\r\\x1b[0K\", name);\n-        OutputFolder {\n-            name,\n-            start_time: SystemTime::now(),\n-        }\n-    }\n-}\n-\n-impl Drop for OutputFolder {\n-    fn drop(&mut self) {\n-        use std::time::*;\n-        use std::u64;\n-\n-        fn to_nanos(duration: Result<Duration, SystemTimeError>) -> u64 {\n-            match duration {\n-                Ok(d) => d.as_secs() * 1_000_000_000 + d.subsec_nanos() as u64,\n-                Err(_) => u64::MAX,\n-            }\n-        }\n-\n-        let end_time = SystemTime::now();\n-        let duration = end_time.duration_since(self.start_time);\n-        let start = self.start_time.duration_since(UNIX_EPOCH);\n-        let finish = end_time.duration_since(UNIX_EPOCH);\n-        println!(\n-            \"travis_fold:end:{0}\\r\\x1b[0K\\n\\\n-                travis_time:end:{0}:start={1},finish={2},duration={3}\\r\\x1b[0K\",\n-            self.name,\n-            to_nanos(start),\n-            to_nanos(finish),\n-            to_nanos(duration)\n-        );\n-        io::stdout().flush().unwrap();\n-    }\n-}\n-\n /// The CI environment rustbuild is running in. This mainly affects how the logs\n /// are printed.\n #[derive(Copy, Clone, PartialEq, Eq, Debug)]\n pub enum CiEnv {\n     /// Not a CI environment.\n     None,\n-    /// The Travis CI environment, for Linux (including Docker) and macOS builds.\n-    Travis,\n-    /// The AppVeyor environment, for Windows builds.\n-    AppVeyor,\n+    /// The Azure Pipelines environment, for Linux (including Docker), Windows, and macOS builds.\n+    AzurePipelines,\n }\n \n impl CiEnv {\n     /// Obtains the current CI environment.\n     pub fn current() -> CiEnv {\n-        if env::var(\"TRAVIS\").ok().map_or(false, |e| &*e == \"true\") {\n-            CiEnv::Travis\n-        } else if env::var(\"APPVEYOR\").ok().map_or(false, |e| &*e == \"True\") {\n-            CiEnv::AppVeyor\n+        if env::var(\"TF_BUILD\").ok().map_or(false, |e| &*e == \"True\") {\n+            CiEnv::AzurePipelines\n         } else {\n             CiEnv::None\n         }\n@@ -350,3 +286,19 @@ impl CiEnv {\n         }\n     }\n }\n+\n+pub fn forcing_clang_based_tests() -> bool {\n+    if let Some(var) = env::var_os(\"RUSTBUILD_FORCE_CLANG_BASED_TESTS\") {\n+        match &var.to_string_lossy().to_lowercase()[..] {\n+            \"1\" | \"yes\" | \"on\" => true,\n+            \"0\" | \"no\" | \"off\" => false,\n+            other => {\n+                // Let's make sure typos don't go unnoticed\n+                panic!(\"Unrecognized option '{}' set in \\\n+                        RUSTBUILD_FORCE_CLANG_BASED_TESTS\", other)\n+            }\n+        }\n+    } else {\n+        false\n+    }\n+}"}, {"sha": "a1aa18922b5c5b9ccac1712c0033ce7e13e959d6", "filename": "src/build_helper/lib.rs", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fbuild_helper%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fbuild_helper%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fbuild_helper%2Flib.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -1,4 +1,5 @@\n-#![deny(rust_2018_idioms)]\n+// NO-RUSTC-WRAPPER\n+#![deny(warnings, rust_2018_idioms, unused_lifetimes)]\n \n use std::fs::File;\n use std::path::{Path, PathBuf};\n@@ -44,18 +45,19 @@ pub fn restore_library_path() {\n     }\n }\n \n-pub fn run(cmd: &mut Command) {\n+/// Run the command, printing what we are running.\n+pub fn run_verbose(cmd: &mut Command) {\n     println!(\"running: {:?}\", cmd);\n-    run_silent(cmd);\n+    run(cmd);\n }\n \n-pub fn run_silent(cmd: &mut Command) {\n-    if !try_run_silent(cmd) {\n+pub fn run(cmd: &mut Command) {\n+    if !try_run(cmd) {\n         std::process::exit(1);\n     }\n }\n \n-pub fn try_run_silent(cmd: &mut Command) -> bool {\n+pub fn try_run(cmd: &mut Command) -> bool {\n     let status = match cmd.status() {\n         Ok(status) => status,\n         Err(e) => fail(&format!(\n@@ -113,7 +115,7 @@ pub fn gnu_target(target: &str) -> &str {\n }\n \n pub fn make(host: &str) -> PathBuf {\n-    if host.contains(\"bitrig\") || host.contains(\"dragonfly\") || host.contains(\"freebsd\")\n+    if host.contains(\"dragonfly\") || host.contains(\"freebsd\")\n         || host.contains(\"netbsd\") || host.contains(\"openbsd\")\n     {\n         PathBuf::from(\"gmake\")\n@@ -288,9 +290,9 @@ pub fn sanitizer_lib_boilerplate(sanitizer_name: &str)\n     } else {\n         format!(\"static={}\", link_name)\n     };\n-    // The source for `compiler-rt` comes from the `compiler-builtins` crate, so\n-    // load our env var set by cargo to find the source code.\n-    let dir = env::var_os(\"DEP_COMPILER_RT_COMPILER_RT\").unwrap();\n+    // This env var is provided by rustbuild to tell us where `compiler-rt`\n+    // lives.\n+    let dir = env::var_os(\"RUST_COMPILER_RT_ROOT\").unwrap();\n     let lib = native_lib_boilerplate(\n         dir.as_ref(),\n         sanitizer_name,"}, {"sha": "687856cca6b62cc2b860afb59964d8c0d8d95e00", "filename": "src/ci/azure-pipelines/auto.yml", "status": "added", "additions": 350, "deletions": 0, "changes": 350, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fazure-pipelines%2Fauto.yml", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fazure-pipelines%2Fauto.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fazure-pipelines%2Fauto.yml?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -0,0 +1,350 @@\n+#\n+# Azure Pipelines \"auto\" branch build for Rust on Linux, macOS, and Windows.\n+#\n+\n+pr: none\n+trigger:\n+  - auto\n+\n+variables:\n+- group: real-prod-credentials\n+\n+jobs:\n+- job: Linux\n+  timeoutInMinutes: 600\n+  pool:\n+    vmImage: ubuntu-16.04\n+  steps:\n+  - template: steps/run.yml\n+  strategy:\n+    matrix:\n+      x86_64-gnu-llvm-6.0:\n+        IMAGE: x86_64-gnu-llvm-6.0\n+        RUST_BACKTRACE: 1\n+\n+      dist-x86_64-linux:\n+        IMAGE: dist-x86_64-linux\n+        DEPLOY: 1\n+\n+      # \"alternate\" deployments, these are \"nightlies\" but have LLVM assertions\n+      # turned on, they're deployed to a different location primarily for\n+      # additional testing.\n+      dist-x86_64-linux-alt:\n+        IMAGE: dist-x86_64-linux\n+        DEPLOY_ALT: 1\n+\n+      # Linux builders, remaining docker images\n+      arm-android:\n+        IMAGE: arm-android\n+\n+      armhf-gnu:\n+        IMAGE: armhf-gnu\n+\n+      dist-various-1:\n+        IMAGE: dist-various-1\n+        DEPLOY: 1\n+\n+      dist-various-2:\n+        IMAGE: dist-various-2\n+        DEPLOY: 1\n+\n+      dist-aarch64-linux:\n+        IMAGE: dist-aarch64-linux\n+        DEPLOY: 1\n+\n+      dist-android:\n+        IMAGE: dist-android\n+        DEPLOY: 1\n+\n+      dist-arm-linux:\n+        IMAGE: dist-arm-linux\n+        DEPLOY: 1\n+\n+      dist-armhf-linux:\n+        IMAGE: dist-armhf-linux\n+        DEPLOY: 1\n+\n+      dist-armv7-linux:\n+        IMAGE: dist-armv7-linux\n+        DEPLOY: 1\n+\n+      dist-i586-gnu-i586-i686-musl:\n+        IMAGE: dist-i586-gnu-i586-i686-musl\n+        DEPLOY: 1\n+\n+      dist-i686-freebsd:\n+        IMAGE: dist-i686-freebsd\n+        DEPLOY: 1\n+\n+      dist-i686-linux:\n+        IMAGE: dist-i686-linux\n+        DEPLOY: 1\n+\n+      dist-mips-linux:\n+        IMAGE: dist-mips-linux\n+        DEPLOY: 1\n+\n+      dist-mips64-linux:\n+        IMAGE: dist-mips64-linux\n+        DEPLOY: 1\n+\n+      dist-mips64el-linux:\n+        IMAGE: dist-mips64el-linux\n+        DEPLOY: 1\n+\n+      dist-mipsel-linux:\n+        IMAGE: dist-mipsel-linux\n+        DEPLOY: 1\n+\n+      dist-powerpc-linux:\n+        IMAGE: dist-powerpc-linux\n+        DEPLOY: 1\n+\n+      dist-powerpc64-linux:\n+        IMAGE: dist-powerpc64-linux\n+        DEPLOY: 1\n+\n+      dist-powerpc64le-linux:\n+        IMAGE: dist-powerpc64le-linux\n+        DEPLOY: 1\n+\n+      dist-s390x-linux:\n+        IMAGE: dist-s390x-linux\n+        DEPLOY: 1\n+\n+      dist-x86_64-freebsd:\n+        IMAGE: dist-x86_64-freebsd\n+        DEPLOY: 1\n+\n+      dist-x86_64-musl:\n+        IMAGE: dist-x86_64-musl\n+        DEPLOY: 1\n+\n+      dist-x86_64-netbsd:\n+        IMAGE: dist-x86_64-netbsd\n+        DEPLOY: 1\n+\n+      asmjs:\n+        IMAGE: asmjs\n+      i686-gnu:\n+        IMAGE: i686-gnu\n+      i686-gnu-nopt:\n+        IMAGE: i686-gnu-nopt\n+      test-various:\n+        IMAGE: test-various\n+      x86_64-gnu:\n+        IMAGE: x86_64-gnu\n+      x86_64-gnu-full-bootstrap:\n+        IMAGE: x86_64-gnu-full-bootstrap\n+      x86_64-gnu-aux:\n+        IMAGE: x86_64-gnu-aux\n+      x86_64-gnu-tools:\n+        IMAGE: x86_64-gnu-tools\n+      x86_64-gnu-debug:\n+        IMAGE: x86_64-gnu-debug\n+      x86_64-gnu-nopt:\n+        IMAGE: x86_64-gnu-nopt\n+      x86_64-gnu-distcheck:\n+        IMAGE: x86_64-gnu-distcheck\n+      mingw-check:\n+        IMAGE: mingw-check\n+\n+- job: macOS\n+  timeoutInMinutes: 600\n+  pool:\n+    vmImage: macos-10.13\n+  steps:\n+  - template: steps/run.yml\n+  strategy:\n+    matrix:\n+      # OSX builders running tests, these run the full test suite.\n+      # NO_DEBUG_ASSERTIONS=1 to make them go faster, but also do have some\n+      # runners that run `//ignore-debug` tests.\n+      #\n+      # Note that the compiler is compiled to target 10.8 here because the Xcode\n+      # version that we're using, 8.2, cannot compile LLVM for OSX 10.7.\n+      x86_64-apple:\n+        SCRIPT: ./x.py test\n+        RUST_CONFIGURE_ARGS: --build=x86_64-apple-darwin --enable-sanitizers --enable-profiler --set rust.jemalloc\n+        RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n+        MACOSX_DEPLOYMENT_TARGET: 10.8\n+        MACOSX_STD_DEPLOYMENT_TARGET: 10.7\n+        NO_LLVM_ASSERTIONS: 1\n+        NO_DEBUG_ASSERTIONS: 1\n+\n+      dist-x86_64-apple:\n+        SCRIPT: ./x.py dist\n+        RUST_CONFIGURE_ARGS: --target=aarch64-apple-ios,armv7-apple-ios,armv7s-apple-ios,i386-apple-ios,x86_64-apple-ios --enable-full-tools --enable-sanitizers --enable-profiler --set rust.jemalloc\n+        DEPLOY: 1\n+        RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n+        MACOSX_DEPLOYMENT_TARGET: 10.7\n+        NO_LLVM_ASSERTIONS: 1\n+        NO_DEBUG_ASSERTIONS: 1\n+        DIST_REQUIRE_ALL_TOOLS: 1\n+\n+      dist-x86_64-apple-alt:\n+        SCRIPT: ./x.py dist\n+        RUST_CONFIGURE_ARGS: --enable-extended --enable-profiler --set rust.jemalloc\n+        DEPLOY_ALT: 1\n+        RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n+        MACOSX_DEPLOYMENT_TARGET: 10.7\n+        NO_LLVM_ASSERTIONS: 1\n+        NO_DEBUG_ASSERTIONS: 1\n+\n+      i686-apple:\n+        SCRIPT: ./x.py test\n+        RUST_CONFIGURE_ARGS: --build=i686-apple-darwin --set rust.jemalloc\n+        RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n+        MACOSX_DEPLOYMENT_TARGET: 10.8\n+        MACOSX_STD_DEPLOYMENT_TARGET: 10.7\n+        NO_LLVM_ASSERTIONS: 1\n+        NO_DEBUG_ASSERTIONS: 1\n+\n+      dist-i686-apple:\n+        SCRIPT: ./x.py dist\n+        RUST_CONFIGURE_ARGS: --build=i686-apple-darwin --enable-full-tools --enable-profiler --set rust.jemalloc\n+        DEPLOY: 1\n+        RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n+        MACOSX_DEPLOYMENT_TARGET: 10.7\n+        NO_LLVM_ASSERTIONS: 1\n+        NO_DEBUG_ASSERTIONS: 1\n+        DIST_REQUIRE_ALL_TOOLS: 1\n+\n+\n+\n+- job: Windows\n+  timeoutInMinutes: 600\n+  pool:\n+    vmImage: 'vs2017-win2016'\n+  steps:\n+  - template: steps/run.yml\n+  strategy:\n+    matrix:\n+      # 32/64 bit MSVC tests\n+      x86_64-msvc-1:\n+        MSYS_BITS: 64\n+        RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc --enable-profiler\n+        SCRIPT: make ci-subset-1\n+        # FIXME(#59637)\n+        NO_DEBUG_ASSERTIONS: 1\n+        NO_LLVM_ASSERTIONS: 1\n+      x86_64-msvc-2:\n+        MSYS_BITS: 64\n+        RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc --enable-profiler\n+        SCRIPT: make ci-subset-2\n+      i686-msvc-1:\n+        MSYS_BITS: 32\n+        RUST_CONFIGURE_ARGS: --build=i686-pc-windows-msvc\n+        SCRIPT: make ci-subset-1\n+      i686-msvc-2:\n+        MSYS_BITS: 32\n+        RUST_CONFIGURE_ARGS: --build=i686-pc-windows-msvc\n+        SCRIPT: make ci-subset-2\n+      # MSVC aux tests\n+      x86_64-msvc-aux:\n+        MSYS_BITS: 64\n+        RUST_CHECK_TARGET: check-aux EXCLUDE_CARGO=1\n+        RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc\n+      x86_64-msvc-cargo:\n+        MSYS_BITS: 64\n+        SCRIPT: python x.py test src/tools/cargotest src/tools/cargo\n+        RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc\n+        VCVARS_BAT: vcvars64.bat\n+      # MSVC tools tests\n+      x86_64-msvc-tools:\n+        MSYS_BITS: 64\n+        SCRIPT: src/ci/docker/x86_64-gnu-tools/checktools.sh x.py /tmp/toolstates.json windows\n+        RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc --save-toolstates=/tmp/toolstates.json\n+\n+      # 32/64-bit MinGW builds.\n+      #\n+      # We are using MinGW with posix threads since LLVM does not compile with\n+      # the win32 threads version due to missing support for C++'s std::thread.\n+      #\n+      # Instead of relying on the MinGW version installed on appveryor we download\n+      # and install one ourselves so we won't be surprised by changes to appveyor's\n+      # build image.\n+      #\n+      # Finally, note that the downloads below are all in the `rust-lang-ci` S3\n+      # bucket, but they cleraly didn't originate there! The downloads originally\n+      # came from the mingw-w64 SourceForge download site. Unfortunately\n+      # SourceForge is notoriously flaky, so we mirror it on our own infrastructure.\n+      i686-mingw-1:\n+        MSYS_BITS: 32\n+        RUST_CONFIGURE_ARGS: --build=i686-pc-windows-gnu\n+        SCRIPT: make ci-subset-1\n+        MINGW_URL: https://rust-lang-ci2.s3.amazonaws.com/rust-ci-mirror\n+        MINGW_ARCHIVE: i686-6.3.0-release-posix-dwarf-rt_v5-rev2.7z\n+        MINGW_DIR: mingw32\n+        # FIXME(#59637)\n+        NO_DEBUG_ASSERTIONS: 1\n+        NO_LLVM_ASSERTIONS: 1\n+      i686-mingw-2:\n+        MSYS_BITS: 32\n+        RUST_CONFIGURE_ARGS: --build=i686-pc-windows-gnu\n+        SCRIPT: make ci-subset-2\n+        MINGW_URL: https://rust-lang-ci2.s3.amazonaws.com/rust-ci-mirror\n+        MINGW_ARCHIVE: i686-6.3.0-release-posix-dwarf-rt_v5-rev2.7z\n+        MINGW_DIR: mingw32\n+      x86_64-mingw-1:\n+        MSYS_BITS: 64\n+        SCRIPT: make ci-subset-1\n+        RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-gnu\n+        MINGW_URL: https://rust-lang-ci2.s3.amazonaws.com/rust-ci-mirror\n+        MINGW_ARCHIVE: x86_64-6.3.0-release-posix-seh-rt_v5-rev2.7z\n+        MINGW_DIR: mingw64\n+        # FIXME(#59637)\n+        NO_DEBUG_ASSERTIONS: 1\n+        NO_LLVM_ASSERTIONS: 1\n+      x86_64-mingw-2:\n+        MSYS_BITS: 64\n+        SCRIPT: make ci-subset-2\n+        RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-gnu\n+        MINGW_URL: https://rust-lang-ci2.s3.amazonaws.com/rust-ci-mirror\n+        MINGW_ARCHIVE: x86_64-6.3.0-release-posix-seh-rt_v5-rev2.7z\n+        MINGW_DIR: mingw64\n+\n+      # 32/64 bit MSVC and GNU deployment\n+      dist-x86_64-msvc:\n+        RUST_CONFIGURE_ARGS: >\n+          --build=x86_64-pc-windows-msvc\n+          --target=x86_64-pc-windows-msvc,aarch64-pc-windows-msvc\n+          --enable-full-tools\n+          --enable-profiler\n+        SCRIPT: python x.py dist\n+        DIST_REQUIRE_ALL_TOOLS: 1\n+        DEPLOY: 1\n+      dist-i686-msvc:\n+        RUST_CONFIGURE_ARGS: >\n+          --build=i686-pc-windows-msvc\n+          --target=i586-pc-windows-msvc\n+          --enable-full-tools\n+          --enable-profiler\n+        SCRIPT: python x.py dist\n+        DIST_REQUIRE_ALL_TOOLS: 1\n+        DEPLOY: 1\n+      dist-i686-mingw:\n+        MSYS_BITS: 32\n+        RUST_CONFIGURE_ARGS: --build=i686-pc-windows-gnu --enable-full-tools --enable-profiler\n+        SCRIPT: python x.py dist\n+        MINGW_URL: https://rust-lang-ci2.s3.amazonaws.com/rust-ci-mirror\n+        MINGW_ARCHIVE: i686-6.3.0-release-posix-dwarf-rt_v5-rev2.7z\n+        MINGW_DIR: mingw32\n+        DIST_REQUIRE_ALL_TOOLS: 1\n+        DEPLOY: 1\n+      dist-x86_64-mingw:\n+        MSYS_BITS: 64\n+        SCRIPT: python x.py dist\n+        RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-gnu --enable-full-tools --enable-profiler\n+        MINGW_URL: https://rust-lang-ci2.s3.amazonaws.com/rust-ci-mirror\n+        MINGW_ARCHIVE: x86_64-6.3.0-release-posix-seh-rt_v5-rev2.7z\n+        MINGW_DIR: mingw64\n+        DIST_REQUIRE_ALL_TOOLS: 1\n+        DEPLOY: 1\n+\n+      # \"alternate\" deployment, see .travis.yml for more info\n+      dist-x86_64-msvc-alt:\n+        MSYS_BITS: 64\n+        RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc --enable-extended --enable-profiler\n+        SCRIPT: python x.py dist\n+        DEPLOY_ALT: 1"}, {"sha": "9742c7196585113050aa91f235bfea1ee8263f47", "filename": "src/ci/azure-pipelines/master.yml", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fazure-pipelines%2Fmaster.yml", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fazure-pipelines%2Fmaster.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fazure-pipelines%2Fmaster.yml?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -0,0 +1,25 @@\n+#\n+# Azure Pipelines job to publish toolstate. Only triggers on pushes to master.\n+#\n+\n+pr: none\n+trigger:\n+  - master\n+\n+variables:\n+- group: real-prod-credentials\n+\n+pool:\n+  vmImage: ubuntu-16.04\n+\n+steps:\n+- checkout: self\n+  fetchDepth: 2\n+\n+- script: |\n+    export MESSAGE_FILE=$(mktemp -t msg.XXXXXX)\n+    . src/ci/docker/x86_64-gnu-tools/repo.sh\n+    commit_toolstate_change \"$MESSAGE_FILE\" \"$BUILD_SOURCESDIRECTORY/src/tools/publish_toolstate.py\" \"$(git rev-parse HEAD)\" \"$(git log --format=%s -n1 HEAD)\" \"$MESSAGE_FILE\" \"$TOOLSTATE_REPO_ACCESS_TOKEN\"\n+  displayName: Publish toolstate\n+  env:\n+    TOOLSTATE_REPO_ACCESS_TOKEN: $(TOOLSTATE_REPO_ACCESS_TOKEN)"}, {"sha": "62e23efe1ef168f951c8ac3d901ef451a7d92d43", "filename": "src/ci/azure-pipelines/pr.yml", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fazure-pipelines%2Fpr.yml", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fazure-pipelines%2Fpr.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fazure-pipelines%2Fpr.yml?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -0,0 +1,35 @@\n+#\n+# Azure Pipelines pull request build for Rust\n+#\n+\n+trigger: none\n+pr:\n+- master\n+\n+variables:\n+- group: public-credentials\n+\n+jobs:\n+- job: Linux\n+  timeoutInMinutes: 600\n+  pool:\n+    vmImage: ubuntu-16.04\n+  steps:\n+    - template: steps/run.yml\n+  strategy:\n+    matrix:\n+      x86_64-gnu-llvm-6.0:\n+        IMAGE: x86_64-gnu-llvm-6.0\n+      mingw-check:\n+        IMAGE: mingw-check\n+\n+- job: LinuxTools\n+  timeoutInMinutes: 600\n+  pool:\n+    vmImage: ubuntu-16.04\n+  steps:\n+    - template: steps/run.yml\n+      parameters:\n+        only_on_updated_submodules: 'yes'\n+  variables:\n+    IMAGE: x86_64-gnu-tools"}, {"sha": "45ec767e0b875469c800631dea493be81760689e", "filename": "src/ci/azure-pipelines/steps/install-clang.yml", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fazure-pipelines%2Fsteps%2Finstall-clang.yml", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fazure-pipelines%2Fsteps%2Finstall-clang.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fazure-pipelines%2Fsteps%2Finstall-clang.yml?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -0,0 +1,46 @@\n+steps:\n+\n+- bash: |\n+    set -e\n+    curl -f http://releases.llvm.org/7.0.0/clang+llvm-7.0.0-x86_64-apple-darwin.tar.xz | tar xJf -\n+\n+    export CC=`pwd`/clang+llvm-7.0.0-x86_64-apple-darwin/bin/clang\n+    echo \"##vso[task.setvariable variable=CC]$CC\"\n+\n+    export CXX=`pwd`/clang+llvm-7.0.0-x86_64-apple-darwin/bin/clang++\n+    echo \"##vso[task.setvariable variable=CXX]$CXX\"\n+\n+    # Configure `AR` specifically so rustbuild doesn't try to infer it as\n+    # `clang-ar` by accident.\n+    echo \"##vso[task.setvariable variable=AR]ar\"\n+  displayName: Install clang (OSX)\n+  condition: and(succeeded(), eq(variables['Agent.OS'], 'Darwin'))\n+\n+# If we're compiling for MSVC then we, like most other distribution builders,\n+# switch to clang as the compiler. This'll allow us eventually to enable LTO\n+# amongst LLVM and rustc. Note that we only do this on MSVC as I don't think\n+# clang has an output mode compatible with MinGW that we need. If it does we\n+# should switch to clang for MinGW as well!\n+#\n+# Note that the LLVM installer is an NSIS installer\n+#\n+# Original downloaded here came from\n+# http://releases.llvm.org/7.0.0/LLVM-7.0.0-win64.exe\n+# That installer was run through `wine` on Linux and then the resulting\n+# installation directory (found in `$HOME/.wine/drive_c/Program Files/LLVM`) was\n+# packaged up into a tarball. We've had issues otherwise that the installer will\n+# randomly hang, provide not a lot of useful information, pollute global state,\n+# etc. In general the tarball is just more confined and easier to deal with when\n+# working with various CI environments.\n+- bash: |\n+    set -e\n+    mkdir -p citools\n+    cd citools\n+    curl -f https://rust-lang-ci2.s3.amazonaws.com/rust-ci-mirror/LLVM-7.0.0-win64.tar.gz | tar xzf -\n+    echo \"##vso[task.setvariable variable=RUST_CONFIGURE_ARGS]$RUST_CONFIGURE_ARGS --set llvm.clang-cl=`pwd`/clang-rust/bin/clang-cl.exe\"\n+  condition: and(succeeded(), eq(variables['Agent.OS'], 'Windows_NT'), eq(variables['MINGW_URL'],''))\n+  displayName: Install clang (Windows)\n+\n+# Note that we don't install clang on Linux since its compiler story is just so\n+# different. Each container has its own toolchain configured appropriately\n+# already."}, {"sha": "427e50f571f764197cfca484c0e93fd6da670808", "filename": "src/ci/azure-pipelines/steps/install-sccache.yml", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fazure-pipelines%2Fsteps%2Finstall-sccache.yml", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fazure-pipelines%2Fsteps%2Finstall-sccache.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fazure-pipelines%2Fsteps%2Finstall-sccache.yml?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -0,0 +1,21 @@\n+steps:\n+\n+- bash: |\n+    set -e\n+    curl -fo /usr/local/bin/sccache https://rust-lang-ci2.s3.amazonaws.com/rust-ci-mirror/2018-04-02-sccache-x86_64-apple-darwin\n+    chmod +x /usr/local/bin/sccache\n+  displayName: Install sccache (OSX)\n+  condition: and(succeeded(), eq(variables['Agent.OS'], 'Darwin'))\n+\n+- script: |\n+    md sccache\n+    powershell -Command \"$ProgressPreference = 'SilentlyContinue'; iwr -outf sccache\\sccache.exe https://rust-lang-ci2.s3.amazonaws.com/rust-ci-mirror/2018-04-26-sccache-x86_64-pc-windows-msvc\"\n+    echo ##vso[task.prependpath]%CD%\\sccache\n+  displayName: Install sccache (Windows)\n+  condition: and(succeeded(), eq(variables['Agent.OS'], 'Windows_NT'))\n+\n+# Note that we don't install sccache on Linux since it's installed elsewhere\n+# through all the containers.\n+#\n+# FIXME: we should probably install sccache outside the containers and then\n+# mount it inside the containers so we can centralize all installation here."}, {"sha": "c42c2311b493ff05cea5a751206fb36bea676fc5", "filename": "src/ci/azure-pipelines/steps/install-windows-build-deps.yml", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fazure-pipelines%2Fsteps%2Finstall-windows-build-deps.yml", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fazure-pipelines%2Fsteps%2Finstall-windows-build-deps.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fazure-pipelines%2Fsteps%2Finstall-windows-build-deps.yml?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -0,0 +1,119 @@\n+steps:\n+# We use the WIX toolset to create combined installers for Windows, and these\n+# binaries are downloaded from\n+# https://github.com/wixtoolset/wix3 originally\n+- bash: |\n+    set -e\n+    curl -O https://rust-lang-ci2.s3-us-west-1.amazonaws.com/rust-ci-mirror/wix311-binaries.zip\n+    echo \"##vso[task.setvariable variable=WIX]`pwd`/wix\"\n+    mkdir -p wix/bin\n+    cd wix/bin\n+    7z x ../../wix311-binaries.zip\n+  displayName: Install wix\n+  condition: and(succeeded(), eq(variables['Agent.OS'], 'Windows_NT'))\n+\n+# We use InnoSetup and its `iscc` program to also create combined installers.\n+# Honestly at this point WIX above and `iscc` are just holdovers from\n+# oh-so-long-ago and are required for creating installers on Windows. I think\n+# one is MSI installers and one is EXE, but they're not used so frequently at\n+# this point anyway so perhaps it's a wash!\n+- script: |\n+    powershell -Command \"$ProgressPreference = 'SilentlyContinue'; iwr -outf is-install.exe https://rust-lang-ci2.s3.amazonaws.com/rust-ci-mirror/2017-08-22-is.exe\"\n+    is-install.exe /VERYSILENT /SUPPRESSMSGBOXES /NORESTART /SP-\n+    echo ##vso[task.prependpath]C:\\Program Files (x86)\\Inno Setup 5\n+  displayName: Install InnoSetup\n+  condition: and(succeeded(), eq(variables['Agent.OS'], 'Windows_NT'))\n+\n+# We've had issues with the default drive in use running out of space during a\n+# build, and it looks like the `C:` drive has more space than the default `D:`\n+# drive. We should probably confirm this with the azure pipelines team at some\n+# point, but this seems to fix our \"disk space full\" problems.\n+- script: |\n+    mkdir c:\\MORE_SPACE\n+    mklink /J build c:\\MORE_SPACE\n+  displayName: \"Ensure build happens on C:/ instead of D:/\"\n+  condition: and(succeeded(), eq(variables['Agent.OS'], 'Windows_NT'))\n+\n+- bash: git config --replace-all --global core.autocrlf false\n+  displayName: \"Disable git automatic line ending conversion (on C:/)\"\n+\n+# Download and install MSYS2, needed primarily for the test suite (run-make) but\n+# also used by the MinGW toolchain for assembling things.\n+#\n+# FIXME: we should probe the default azure image and see if we can use the MSYS2\n+# toolchain there. (if there's even one there). For now though this gets the job\n+# done.\n+- script: |\n+    set MSYS_PATH=%CD%\\citools\\msys64\n+    choco install msys2 --params=\"/InstallDir:%MSYS_PATH% /NoPath\" -y\n+    set PATH=%MSYS_PATH%\\usr\\bin;%PATH%\n+    pacman -S --noconfirm --needed base-devel ca-certificates make diffutils tar\n+    IF \"%MINGW_URL%\"==\"\" (\n+      IF \"%MSYS_BITS%\"==\"32\" pacman -S --noconfirm --needed mingw-w64-i686-toolchain mingw-w64-i686-cmake mingw-w64-i686-gcc mingw-w64-i686-python2\n+      IF \"%MSYS_BITS%\"==\"64\" pacman -S --noconfirm --needed mingw-w64-x86_64-toolchain mingw-w64-x86_64-cmake mingw-w64-x86_64-gcc mingw-w64-x86_64-python2\n+    )\n+    where rev\n+    rev --help\n+    where make\n+\n+    echo ##vso[task.setvariable variable=MSYS_PATH]%MSYS_PATH%\n+    echo ##vso[task.prependpath]%MSYS_PATH%\\usr\\bin\n+  displayName: Install msys2\n+  condition: and(succeeded(), eq(variables['Agent.OS'], 'Windows_NT'))\n+\n+# If we need to download a custom MinGW, do so here and set the path\n+# appropriately.\n+#\n+# Here we also do a pretty heinous thing which is to mangle the MinGW\n+# installation we just downloaded. Currently, as of this writing, we're using\n+# MinGW-w64 builds of gcc, and that's currently at 6.3.0. We use 6.3.0 as it\n+# appears to be the first version which contains a fix for #40546, builds\n+# randomly failing during LLVM due to ar.exe/ranlib.exe failures.\n+#\n+# Unfortunately, though, 6.3.0 *also* is the first version of MinGW-w64 builds\n+# to contain a regression in gdb (#40184). As a result if we were to use the\n+# gdb provided (7.11.1) then we would fail all debuginfo tests.\n+#\n+# In order to fix spurious failures (pretty high priority) we use 6.3.0. To\n+# avoid disabling gdb tests we download an *old* version of gdb, specifically\n+# that found inside the 6.2.0 distribution. We then overwrite the 6.3.0 gdb\n+# with the 6.2.0 gdb to get tests passing.\n+#\n+# Note that we don't literally overwrite the gdb.exe binary because it appears\n+# to just use gdborig.exe, so that's the binary we deal with instead.\n+- script: |\n+    powershell -Command \"$ProgressPreference = 'SilentlyContinue'; iwr -outf %MINGW_ARCHIVE% %MINGW_URL%/%MINGW_ARCHIVE%\"\n+    7z x -y %MINGW_ARCHIVE% > nul\n+    powershell -Command \"$ProgressPreference = 'SilentlyContinue'; iwr -outf 2017-04-20-%MSYS_BITS%bit-gdborig.exe %MINGW_URL%/2017-04-20-%MSYS_BITS%bit-gdborig.exe\"\n+    mv 2017-04-20-%MSYS_BITS%bit-gdborig.exe %MINGW_DIR%\\bin\\gdborig.exe\n+    echo ##vso[task.prependpath]%CD%\\%MINGW_DIR%\\bin\n+  condition: and(succeeded(), eq(variables['Agent.OS'], 'Windows_NT'), ne(variables['MINGW_URL'],''))\n+  displayName: Download custom MinGW\n+\n+# Otherwise pull in the MinGW installed on appveyor\n+- script: |\n+    echo ##vso[task.prependpath]%MSYS_PATH%\\mingw%MSYS_BITS%\\bin\n+  condition: and(succeeded(), eq(variables['Agent.OS'], 'Windows_NT'), eq(variables['MINGW_URL'],''))\n+  displayName: Add MinGW to path\n+\n+# Make sure we use the native python interpreter instead of some msys equivalent\n+# one way or another. The msys interpreters seem to have weird path conversions\n+# baked in which break LLVM's build system one way or another, so let's use the\n+# native version which keeps everything as native as possible.\n+- script: |\n+    copy C:\\Python27amd64\\python.exe C:\\Python27amd64\\python2.7.exe\n+    echo ##vso[task.prependpath]C:\\Python27amd64\n+  displayName: Prefer the \"native\" Python as LLVM has trouble building with MSYS sometimes\n+  condition: and(succeeded(), eq(variables['Agent.OS'], 'Windows_NT'))\n+\n+# Note that this is originally from the github releases patch of Ninja\n+- script: |\n+    md ninja\n+    powershell -Command \"$ProgressPreference = 'SilentlyContinue'; iwr -outf 2017-03-15-ninja-win.zip https://rust-lang-ci2.s3.amazonaws.com/rust-ci-mirror/2017-03-15-ninja-win.zip\"\n+    7z x -oninja 2017-03-15-ninja-win.zip\n+    del 2017-03-15-ninja-win.zip\n+    set RUST_CONFIGURE_ARGS=%RUST_CONFIGURE_ARGS% --enable-ninja\n+    echo ##vso[task.setvariable variable=RUST_CONFIGURE_ARGS]%RUST_CONFIGURE_ARGS%\n+    echo ##vso[task.prependpath]%CD%\\ninja\n+  displayName: Download and install ninja\n+  condition: and(succeeded(), eq(variables['Agent.OS'], 'Windows_NT'))"}, {"sha": "ca32888b74c34ce0ea2f3e7b4993ad78312a7828", "filename": "src/ci/azure-pipelines/steps/run.yml", "status": "added", "additions": 207, "deletions": 0, "changes": 207, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fazure-pipelines%2Fsteps%2Frun.yml", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fazure-pipelines%2Fsteps%2Frun.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fazure-pipelines%2Fsteps%2Frun.yml?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -0,0 +1,207 @@\n+# FIXME(linux): need to configure core dumps, enable them, and then dump\n+# backtraces on failure from all core dumps:\n+#\n+# - bash: sudo apt install gdb\n+# - bash: sudo sh -c 'echo \"/checkout/obj/cores/core.%p.%E\" > /proc/sys/kernel/core_pattern'\n+#\n+# Check travis config for `gdb --batch` command to print all crash logs\n+\n+parameters:\n+  # When this parameter is set to anything other than an empty string the tests\n+  # will only be executed when the commit updates submodules\n+  only_on_updated_submodules: ''\n+\n+steps:\n+\n+# Disable automatic line ending conversion, which is enabled by default on\n+# Azure's Windows image. Having the conversion enabled caused regressions both\n+# in our test suite (it broke miri tests) and in the ecosystem, since we\n+# started shipping install scripts with CRLF endings instead of the old LF.\n+#\n+# Note that we do this a couple times during the build as the PATH and current\n+# user/directory change, e.g. when mingw is enabled.\n+- bash: git config --global core.autocrlf false\n+  displayName: \"Disable git automatic line ending conversion\"\n+\n+- checkout: self\n+  fetchDepth: 2\n+\n+# Set the SKIP_JOB environment variable if this job is supposed to only run\n+# when submodules are updated and they were not. The following time consuming\n+# tasks will be skipped when the environment variable is present.\n+- ${{ if parameters.only_on_updated_submodules }}:\n+  - bash: |\n+      set -e\n+      # Submodules pseudo-files inside git have the 160000 permissions, so when\n+      # those files are present in the diff a submodule was updated.\n+      if git diff HEAD^ | grep \"^index .* 160000\" >/dev/null 2>&1; then\n+          echo \"Executing the job since submodules are updated\"\n+      else\n+          echo \"Not executing this job since no submodules were updated\"\n+          echo \"##vso[task.setvariable variable=SKIP_JOB;]1\"\n+      fi\n+    displayName: Decide whether to run this job\n+\n+# Spawn a background process to collect CPU usage statistics which we'll upload\n+# at the end of the build. See the comments in the script here for more\n+# information.\n+- bash: python src/ci/cpu-usage-over-time.py &> cpu-usage.csv &\n+  displayName: \"Collect CPU-usage statistics in the background\"\n+\n+- bash: printenv | sort\n+  displayName: Show environment variables\n+\n+- bash: |\n+    set -e\n+    df -h\n+    du . | sort -nr | head -n100\n+  displayName: Show disk usage\n+  # FIXME: this hasn't been tested, but maybe it works on Windows? Should test!\n+  condition: and(succeeded(), ne(variables['Agent.OS'], 'Windows_NT'))\n+\n+- template: install-sccache.yml\n+- template: install-clang.yml\n+\n+# Switch to XCode 9.3 on OSX since it seems to be the last version that supports\n+# i686-apple-darwin. We'll eventually want to upgrade this and it will probably\n+# force us to drop i686-apple-darwin, but let's keep the wheels turning for now.\n+- bash: |\n+    set -e\n+    sudo xcode-select --switch /Applications/Xcode_9.3.app\n+  displayName: Switch to Xcode 9.3 (OSX)\n+  condition: and(succeeded(), eq(variables['Agent.OS'], 'Darwin'))\n+\n+- template: install-windows-build-deps.yml\n+\n+# Looks like docker containers have IPv6 disabled by default, so let's turn it\n+# on since libstd tests require it\n+- bash: |\n+    set -e\n+    sudo mkdir -p /etc/docker\n+    echo '{\"ipv6\":true,\"fixed-cidr-v6\":\"fd9a:8454:6789:13f7::/64\"}' | sudo tee /etc/docker/daemon.json\n+    sudo service docker restart\n+  displayName: Enable IPv6\n+  condition: and(succeeded(), not(variables.SKIP_JOB), eq(variables['Agent.OS'], 'Linux'))\n+\n+# Disable automatic line ending conversion (again). On Windows, when we're\n+# installing dependencies, something switches the git configuration directory or\n+# re-enables autocrlf. We've not tracked down the exact cause -- and there may\n+# be multiple -- but this should ensure submodules are checked out with the\n+# appropriate line endings.\n+- bash: git config --replace-all --global core.autocrlf false\n+  displayName: \"Disable git automatic line ending conversion\"\n+\n+# Check out all our submodules, but more quickly than using git by using one of\n+# our custom scripts\n+- bash: |\n+    set -e\n+    mkdir -p $HOME/rustsrc\n+    $BUILD_SOURCESDIRECTORY/src/ci/init_repo.sh . $HOME/rustsrc\n+  condition: and(succeeded(), not(variables.SKIP_JOB), ne(variables['Agent.OS'], 'Windows_NT'))\n+  displayName: Check out submodules (Unix)\n+- script: |\n+    if not exist C:\\cache\\rustsrc\\NUL mkdir C:\\cache\\rustsrc\n+    sh src/ci/init_repo.sh . /c/cache/rustsrc\n+  condition: and(succeeded(), not(variables.SKIP_JOB), eq(variables['Agent.OS'], 'Windows_NT'))\n+  displayName: Check out submodules (Windows)\n+\n+# See also the disable for autocrlf above, this just checks that it worked\n+#\n+# We check both in rust-lang/rust and in a submodule to make sure both are\n+# accurate. Submodules are checked out significantly later than the main\n+# repository in this script, so settings can (and do!) change between then.\n+#\n+# Linux (and maybe macOS) builders don't currently have dos2unix so just only\n+# run this step on Windows.\n+- bash: |\n+    set -x\n+    # print out the git configuration so we can better investigate failures in\n+    # the following\n+    git config --list --show-origin\n+    dos2unix -ih Cargo.lock src/tools/rust-installer/install-template.sh\n+    endings=$(dos2unix -ic Cargo.lock src/tools/rust-installer/install-template.sh)\n+    # if endings has non-zero length, error out\n+    if [ -n \"$endings\" ]; then exit 1 ; fi\n+  condition: and(succeeded(), eq(variables['Agent.OS'], 'Windows_NT'))\n+  displayName: Verify line endings are LF\n+\n+# Ensure the `aws` CLI is installed so we can deploy later on, cache docker\n+# images, etc.\n+- bash: src/ci/install-awscli.sh\n+  env:\n+    AGENT_OS: $(Agent.OS)\n+  condition: and(succeeded(), not(variables.SKIP_JOB))\n+  displayName: Install awscli\n+\n+# Configure our CI_JOB_NAME variable which log analyzers can use for the main\n+# step to see what's going on.\n+- bash: |\n+    builder=$(echo $AGENT_JOBNAME | cut -d ' ' -f 2)\n+    echo \"##vso[task.setvariable variable=CI_JOB_NAME]$builder\"\n+  displayName: Configure Job Name\n+\n+# As a quick smoke check on the otherwise very fast mingw-check linux builder\n+# check our own internal scripts.\n+- bash: |\n+    set -e\n+    git clone --depth=1 https://github.com/rust-lang-nursery/rust-toolstate.git\n+    cd rust-toolstate\n+    python2.7 \"$BUILD_SOURCESDIRECTORY/src/tools/publish_toolstate.py\" \"$(git rev-parse HEAD)\" \"$(git log --format=%s -n1 HEAD)\" \"\" \"\"\n+    cd ..\n+    rm -rf rust-toolstate\n+  condition: and(succeeded(), not(variables.SKIP_JOB), eq(variables['IMAGE'], 'mingw-check'))\n+  displayName: Verify the publish_toolstate script works\n+\n+- bash: |\n+    set -e\n+    # Remove any preexisting rustup installation since it can interfere\n+    # with the cargotest step and its auto-detection of things like Clippy in\n+    # the environment\n+    rustup self uninstall -y || true\n+    if [ \"$IMAGE\" = \"\" ]; then\n+      src/ci/run.sh\n+    else\n+      src/ci/docker/run.sh $IMAGE\n+    fi\n+  #timeoutInMinutes: 180\n+  timeoutInMinutes: 600\n+  env:\n+    CI: true\n+    SRC: .\n+    AWS_SECRET_ACCESS_KEY: $(AWS_SECRET_ACCESS_KEY)\n+    TOOLSTATE_REPO_ACCESS_TOKEN: $(TOOLSTATE_REPO_ACCESS_TOKEN)\n+  condition: and(succeeded(), not(variables.SKIP_JOB))\n+  displayName: Run build\n+\n+# If we're a deploy builder, use the `aws` command to publish everything to our\n+# bucket.\n+- bash: |\n+    set -e\n+    source src/ci/shared.sh\n+    if [ \"$AGENT_OS\" = \"Linux\" ]; then\n+        rm -rf obj/build/dist/doc\n+        upload_dir=obj/build/dist\n+    else\n+        rm -rf build/dist/doc\n+        upload_dir=build/dist\n+    fi\n+    ls -la $upload_dir\n+    deploy_dir=rustc-builds\n+    if [ \"$DEPLOY_ALT\" == \"1\" ]; then\n+        deploy_dir=rustc-builds-alt\n+    fi\n+    retry aws s3 cp --no-progress --recursive --acl public-read ./$upload_dir s3://$DEPLOY_BUCKET/$deploy_dir/$BUILD_SOURCEVERSION\n+  env:\n+    AWS_SECRET_ACCESS_KEY: $(AWS_SECRET_ACCESS_KEY)\n+  condition: and(succeeded(), not(variables.SKIP_JOB), or(eq(variables.DEPLOY, '1'), eq(variables.DEPLOY_ALT, '1')))\n+  displayName: Upload artifacts\n+\n+# Upload CPU usage statistics that we've been gathering this whole time. Always\n+# execute this step in case we want to inspect failed builds, but don't let\n+# errors here ever fail the build since this is just informational.\n+- bash: aws s3 cp --acl public-read cpu-usage.csv s3://$DEPLOY_BUCKET/rustc-builds/$BUILD_SOURCEVERSION/cpu-$SYSTEM_JOBNAME.csv\n+  env:\n+    AWS_SECRET_ACCESS_KEY: $(AWS_SECRET_ACCESS_KEY)\n+  condition: variables['AWS_SECRET_ACCESS_KEY']\n+  continueOnError: true\n+  displayName: Upload CPU usage statistics"}, {"sha": "0df6c6c951f246eaf70d018f6546ae7c54e4b273", "filename": "src/ci/azure-pipelines/try.yml", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fazure-pipelines%2Ftry.yml", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fazure-pipelines%2Ftry.yml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fazure-pipelines%2Ftry.yml?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -0,0 +1,78 @@\n+pr: none\n+trigger:\n+- try\n+\n+variables:\n+- group: real-prod-credentials\n+\n+jobs:\n+- job: Linux\n+  timeoutInMinutes: 600\n+  pool:\n+    vmImage: ubuntu-16.04\n+  steps:\n+  - template: steps/run.yml\n+  strategy:\n+    matrix:\n+      dist-x86_64-linux:\n+        IMAGE: dist-x86_64-linux\n+        DEPLOY: 1\n+\n+      dist-x86_64-linux-alt:\n+        IMAGE: dist-x86_64-linux\n+        DEPLOY_ALT: 1\n+\n+# The macOS and Windows builds here are currently disabled due to them not being\n+# overly necessary on `try` builds. We also don't actually have anything that\n+# consumes the artifacts currently. Perhaps one day we can reenable, but for now\n+# it helps free up capacity on Azure.\n+# - job: macOS\n+#   timeoutInMinutes: 600\n+#   pool:\n+#     vmImage: macos-10.13\n+#   steps:\n+#   - template: steps/run.yml\n+#   strategy:\n+#     matrix:\n+#       dist-x86_64-apple:\n+#         SCRIPT: ./x.py dist\n+#         RUST_CONFIGURE_ARGS: --target=aarch64-apple-ios,armv7-apple-ios,armv7s-apple-ios,i386-apple-ios,x86_64-apple-ios --enable-full-tools --enable-sanitizers --enable-profiler --set rust.jemalloc\n+#         DEPLOY: 1\n+#         RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n+#         MACOSX_DEPLOYMENT_TARGET: 10.7\n+#         NO_LLVM_ASSERTIONS: 1\n+#         NO_DEBUG_ASSERTIONS: 1\n+#         DIST_REQUIRE_ALL_TOOLS: 1\n+#\n+#       dist-x86_64-apple-alt:\n+#         SCRIPT: ./x.py dist\n+#         RUST_CONFIGURE_ARGS: --enable-extended --enable-profiler --set rust.jemalloc\n+#         DEPLOY_ALT: 1\n+#         RUSTC_RETRY_LINKER_ON_SEGFAULT: 1\n+#         MACOSX_DEPLOYMENT_TARGET: 10.7\n+#         NO_LLVM_ASSERTIONS: 1\n+#         NO_DEBUG_ASSERTIONS: 1\n+#\n+# - job: Windows\n+#   timeoutInMinutes: 600\n+#   pool:\n+#     vmImage: 'vs2017-win2016'\n+#   steps:\n+#   - template: steps/run.yml\n+#   strategy:\n+#     matrix:\n+#       dist-x86_64-msvc:\n+#         RUST_CONFIGURE_ARGS: >\n+#           --build=x86_64-pc-windows-msvc\n+#           --target=x86_64-pc-windows-msvc,aarch64-pc-windows-msvc\n+#           --enable-full-tools\n+#           --enable-profiler\n+#         SCRIPT: python x.py dist\n+#         DIST_REQUIRE_ALL_TOOLS: 1\n+#         DEPLOY: 1\n+#\n+#       dist-x86_64-msvc-alt:\n+#         MSYS_BITS: 64\n+#         RUST_CONFIGURE_ARGS: --build=x86_64-pc-windows-msvc --enable-extended --enable-profiler\n+#         SCRIPT: python x.py dist\n+#         DEPLOY_ALT: 1"}, {"sha": "daf21670b33391d49cbe9f26d6c7fd7b347f6943", "filename": "src/ci/cpu-usage-over-time.py", "status": "added", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fcpu-usage-over-time.py", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fcpu-usage-over-time.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fcpu-usage-over-time.py?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -0,0 +1,160 @@\n+#!/usr/bin/env python\n+# ignore-tidy-linelength\n+\n+# This is a small script that we use on CI to collect CPU usage statistics of\n+# our builders. By seeing graphs of CPU usage over time we hope to correlate\n+# that with possible improvements to Rust's own build system, ideally diagnosing\n+# that either builders are always fully using their CPU resources or they're\n+# idle for long stretches of time.\n+#\n+# This script is relatively simple, but it's platform specific. Each platform\n+# (OSX/Windows/Linux) has a different way of calculating the current state of\n+# CPU at a point in time. We then compare two captured states to determine the\n+# percentage of time spent in one state versus another. The state capturing is\n+# all platform-specific but the loop at the bottom is the cross platform part\n+# that executes everywhere.\n+#\n+# # Viewing statistics\n+#\n+# All builders will upload their CPU statistics as CSV files to our S3 buckets.\n+# These URLS look like:\n+#\n+#   https://$bucket.s3.amazonaws.com/rustc-builds/$commit/cpu-$builder.csv\n+#\n+# for example\n+#\n+#   https://rust-lang-ci2.s3.amazonaws.com/rustc-builds/68baada19cd5340f05f0db15a3e16d6671609bcc/cpu-x86_64-apple.csv\n+#\n+# Each CSV file has two columns. The first is the timestamp of the measurement\n+# and the second column is the % of idle cpu time in that time slice. Ideally\n+# the second column is always zero.\n+#\n+# Once you've downloaded a file there's various ways to plot it and visualize\n+# it. For command line usage you use the `src/etc/cpu-usage-over-time-plot.sh`\n+# script in this repository.\n+\n+import datetime\n+import sys\n+import time\n+\n+if sys.platform == 'linux2':\n+    class State:\n+        def __init__(self):\n+            with open('/proc/stat', 'r') as file:\n+                data = file.readline().split()\n+            if data[0] != 'cpu':\n+                raise Exception('did not start with \"cpu\"')\n+            self.user = int(data[1])\n+            self.nice = int(data[2])\n+            self.system = int(data[3])\n+            self.idle = int(data[4])\n+            self.iowait = int(data[5])\n+            self.irq = int(data[6])\n+            self.softirq = int(data[7])\n+            self.steal = int(data[8])\n+            self.guest = int(data[9])\n+            self.guest_nice = int(data[10])\n+\n+        def idle_since(self, prev):\n+            user = self.user - prev.user\n+            nice = self.nice - prev.nice\n+            system = self.system - prev.system\n+            idle = self.idle - prev.idle\n+            iowait = self.iowait - prev.iowait\n+            irq = self.irq - prev.irq\n+            softirq = self.softirq - prev.softirq\n+            steal = self.steal - prev.steal\n+            guest = self.guest - prev.guest\n+            guest_nice = self.guest_nice - prev.guest_nice\n+            total = user + nice + system + idle + iowait + irq + softirq + steal + guest + guest_nice\n+            return float(idle) / float(total) * 100\n+\n+elif sys.platform == 'win32':\n+    from ctypes.wintypes import DWORD\n+    from ctypes import Structure, windll, WinError, GetLastError, byref\n+\n+    class FILETIME(Structure):\n+        _fields_ = [\n+            (\"dwLowDateTime\", DWORD),\n+            (\"dwHighDateTime\", DWORD),\n+        ]\n+\n+    class State:\n+        def __init__(self):\n+            idle, kernel, user = FILETIME(), FILETIME(), FILETIME()\n+\n+            success = windll.kernel32.GetSystemTimes(\n+                byref(idle),\n+                byref(kernel),\n+                byref(user),\n+            )\n+\n+            assert success, WinError(GetLastError())[1]\n+\n+            self.idle = (idle.dwHighDateTime << 32) | idle.dwLowDateTime\n+            self.kernel = (kernel.dwHighDateTime << 32) | kernel.dwLowDateTime\n+            self.user = (user.dwHighDateTime << 32) | user.dwLowDateTime\n+\n+        def idle_since(self, prev):\n+            idle = self.idle - prev.idle\n+            user = self.user - prev.user\n+            kernel = self.kernel - prev.kernel\n+            return float(idle) / float(user + kernel) * 100\n+\n+elif sys.platform == 'darwin':\n+    from ctypes import *\n+    libc = cdll.LoadLibrary('/usr/lib/libc.dylib')\n+\n+    PROESSOR_CPU_LOAD_INFO = c_int(2)\n+    CPU_STATE_USER = 0\n+    CPU_STATE_SYSTEM = 1\n+    CPU_STATE_IDLE = 2\n+    CPU_STATE_NICE = 3\n+    c_int_p = POINTER(c_int)\n+\n+    class State:\n+        def __init__(self):\n+            num_cpus_u = c_uint(0)\n+            cpu_info = c_int_p()\n+            cpu_info_cnt = c_int(0)\n+            err = libc.host_processor_info(\n+                libc.mach_host_self(),\n+                PROESSOR_CPU_LOAD_INFO,\n+                byref(num_cpus_u),\n+                byref(cpu_info),\n+                byref(cpu_info_cnt),\n+            )\n+            assert err == 0\n+            self.user = 0\n+            self.system = 0\n+            self.idle = 0\n+            self.nice = 0\n+            cur = 0\n+            while cur < cpu_info_cnt.value:\n+                self.user += cpu_info[cur + CPU_STATE_USER]\n+                self.system += cpu_info[cur + CPU_STATE_SYSTEM]\n+                self.idle += cpu_info[cur + CPU_STATE_IDLE]\n+                self.nice += cpu_info[cur + CPU_STATE_NICE]\n+                cur += num_cpus_u.value\n+\n+        def idle_since(self, prev):\n+            user = self.user - prev.user\n+            system = self.system - prev.system\n+            idle = self.idle - prev.idle\n+            nice = self.nice - prev.nice\n+            return float(idle) / float(user + system + idle + nice) * 100.0\n+\n+else:\n+    print('unknown platform', sys.platform)\n+    sys.exit(1)\n+\n+cur_state = State();\n+print(\"Time,Idle\")\n+while True:\n+    time.sleep(1);\n+    next_state = State();\n+    now = datetime.datetime.utcnow().isoformat()\n+    idle = next_state.idle_since(cur_state)\n+    print(\"%s,%s\" % (now, idle))\n+    sys.stdout.flush()\n+    cur_state = next_state"}, {"sha": "367e43849923fca154a6867d158431a214d2f8c7", "filename": "src/ci/docker/README.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fdocker%2FREADME.md", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fdocker%2FREADME.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2FREADME.md?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -20,7 +20,7 @@ Images will output artifacts in an `obj` dir at the root of a repository.\n \n - Each directory, excluding `scripts` and `disabled`, corresponds to a docker image\n - `scripts` contains files shared by docker images\n-- `disabled` contains images that are not built on travis\n+- `disabled` contains images that are not built on CI\n \n ## Docker Toolbox on Windows\n "}, {"sha": "b934d1ce97124d4ee4ccaaf9b87dd1514383f1e2", "filename": "src/ci/docker/arm-android/Dockerfile", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fdocker%2Farm-android%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fdocker%2Farm-android%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Farm-android%2FDockerfile?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -7,23 +7,21 @@ COPY scripts/android-ndk.sh /scripts/\n RUN . /scripts/android-ndk.sh && \\\n     download_and_make_toolchain android-ndk-r15c-linux-x86_64.zip arm 14\n \n-# Note:\n-# Do not upgrade to `openjdk-9-jre-headless`, as it will cause certificate error\n-# when installing the Android SDK (see PR #45193). This is unfortunate, but\n-# every search result suggested either disabling HTTPS or replacing JDK 9 by\n-# JDK 8 as the solution (e.g. https://stackoverflow.com/q/41421340). :|\n RUN dpkg --add-architecture i386 && \\\n     apt-get update && \\\n     apt-get install -y --no-install-recommends \\\n   libgl1-mesa-glx \\\n   libpulse0 \\\n   libstdc++6:i386 \\\n-  openjdk-8-jre-headless \\\n-  tzdata\n+  openjdk-9-jre-headless \\\n+  tzdata \\\n+  wget \\\n+  python3\n \n COPY scripts/android-sdk.sh /scripts/\n-RUN . /scripts/android-sdk.sh && \\\n-    download_and_create_avd 4333796 armeabi-v7a 18\n+COPY scripts/android-sdk-manager.py /scripts/\n+COPY arm-android/android-sdk.lock /android/sdk/android-sdk.lock\n+RUN /scripts/android-sdk.sh\n \n ENV PATH=$PATH:/android/sdk/emulator\n ENV PATH=$PATH:/android/sdk/tools"}, {"sha": "a1be8a4346b6d87c2e1f5f5367e70b6a912a4285", "filename": "src/ci/docker/arm-android/android-sdk.lock", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fdocker%2Farm-android%2Fandroid-sdk.lock", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fdocker%2Farm-android%2Fandroid-sdk.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Farm-android%2Fandroid-sdk.lock?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -0,0 +1,6 @@\n+emulator emulator-linux-5264690.zip 48c1cda2bdf3095d9d9d5c010fbfb3d6d673e3ea\n+patcher;v4 3534162-studio.sdk-patcher.zip 046699c5e2716ae11d77e0bad814f7f33fab261e\n+platform-tools platform-tools_r28.0.2-linux.zip 46a4c02a9b8e4e2121eddf6025da3c979bf02e28\n+platforms;android-18 android-18_r03.zip e6b09b3505754cbbeb4a5622008b907262ee91cb\n+system-images;android-18;default;armeabi-v7a sys-img/android/armeabi-v7a-18_r05.zip 580b583720f7de671040d5917c8c9db0c7aa03fd\n+tools sdk-tools-linux-4333796.zip 8c7c28554a32318461802c1291d76fccfafde054"}, {"sha": "235920833f83980cf89acdbe1e6fcc1969cfebd0", "filename": "src/ci/docker/armhf-gnu/Dockerfile", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fdocker%2Farmhf-gnu%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fdocker%2Farmhf-gnu%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Farmhf-gnu%2FDockerfile?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -71,7 +71,8 @@ COPY scripts/qemu-bare-bones-addentropy.c /tmp/addentropy.c\n RUN arm-linux-gnueabihf-gcc addentropy.c -o rootfs/addentropy -static\n \n # TODO: What is this?!\n-RUN curl -O http://ftp.nl.debian.org/debian/dists/jessie/main/installer-armhf/current/images/device-tree/vexpress-v2p-ca15-tc1.dtb\n+# Source of the file: https://github.com/vfdev-5/qemu-rpi2-vexpress/raw/master/vexpress-v2p-ca15-tc1.dtb\n+RUN curl -O https://rust-lang-ci2.s3.amazonaws.com/rust-ci-mirror/vexpress-v2p-ca15-tc1.dtb\n \n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh"}, {"sha": "3abaab6b34ef0dece78106d7955dc7f24c084a5d", "filename": "src/ci/docker/asmjs/Dockerfile", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fdocker%2Fasmjs%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fdocker%2Fasmjs%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fasmjs%2FDockerfile?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -32,8 +32,16 @@ ENV TARGETS=asmjs-unknown-emscripten\n ENV RUST_CONFIGURE_ARGS --enable-emscripten --disable-optimize-tests\n \n ENV SCRIPT python2.7 ../x.py test --target $TARGETS \\\n-  src/test/run-pass \\\n+  src/test/ui \\\n   src/test/run-fail \\\n   src/libstd \\\n   src/liballoc \\\n   src/libcore\n+\n+# Debug assertions in rustc are largely covered by other builders, and LLVM\n+# assertions cause this builder to slow down by quite a large amount and don't\n+# buy us a huge amount over other builders (not sure if we've ever seen an\n+# asmjs-specific backend assertion trip), so disable assertions for these\n+# tests.\n+ENV NO_LLVM_ASSERTIONS=1\n+ENV NO_DEBUG_ASSERTIONS=1"}, {"sha": "11a3acd68e3e8c19e3aac3cc9f46ecf1aba66fe7", "filename": "src/ci/docker/disabled/dist-x86_64-redox/Dockerfile", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fdocker%2Fdisabled%2Fdist-x86_64-redox%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fdocker%2Fdisabled%2Fdist-x86_64-redox%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdisabled%2Fdist-x86_64-redox%2FDockerfile?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -7,8 +7,8 @@ COPY scripts/crosstool-ng.sh /scripts/\n RUN sh /scripts/crosstool-ng.sh\n \n WORKDIR /tmp\n-COPY cross/install-x86_64-redox.sh /tmp/\n-RUN ./install-x86_64-redox.sh\n+COPY dist-various-1/install-x86_64-redox.sh /scripts/\n+RUN sh /scripts/install-x86_64-redox.sh\n \n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh"}, {"sha": "f5eb66ed7142f728d5c06de3a7a426f9b3b0c6d9", "filename": "src/ci/docker/dist-aarch64-linux/Dockerfile", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fdocker%2Fdist-aarch64-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fdocker%2Fdist-aarch64-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-aarch64-linux%2FDockerfile?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -32,5 +32,8 @@ ENV CC_aarch64_unknown_linux_gnu=aarch64-unknown-linux-gnueabi-gcc \\\n \n ENV HOSTS=aarch64-unknown-linux-gnu\n \n-ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n+ENV RUST_CONFIGURE_ARGS \\\n+      --enable-extended \\\n+      --enable-profiler \\\n+      --disable-docs\n ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS"}, {"sha": "8c052db1b0dde9283d4b856c615ca09db410db23", "filename": "src/ci/docker/dist-powerpc-linux/Dockerfile", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fdocker%2Fdist-powerpc-linux%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fdocker%2Fdist-powerpc-linux%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-powerpc-linux%2FDockerfile?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -36,7 +36,3 @@ ENV HOSTS=powerpc-unknown-linux-gnu\n \n ENV RUST_CONFIGURE_ARGS --enable-extended --disable-docs\n ENV SCRIPT python2.7 ../x.py dist --host $HOSTS --target $HOSTS\n-\n-# FIXME(#36150) this will fail the bootstrap. Probably means something bad is\n-#               happening!\n-ENV NO_LLVM_ASSERTIONS 1"}, {"sha": "fc53849a2ada41f6094b3793e96b093d8ffc606a", "filename": "src/ci/docker/dist-powerpc64-linux/build-powerpc64-toolchain.sh", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fdocker%2Fdist-powerpc64-linux%2Fbuild-powerpc64-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fdocker%2Fdist-powerpc64-linux%2Fbuild-powerpc64-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-powerpc64-linux%2Fbuild-powerpc64-toolchain.sh?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -3,9 +3,29 @@ set -ex\n \n source shared.sh\n \n+BINUTILS=2.32\n+TARGET=powerpc64-unknown-linux-gnu\n+PREFIX=/x-tools/$TARGET\n+SYSROOT=$PREFIX/$TARGET/sysroot\n+\n mkdir build\n cd build\n cp ../powerpc64-linux-gnu.config .config\n hide_output ct-ng build\n cd ..\n rm -rf build\n+\n+chmod -R u+w $PREFIX\n+\n+# Next, download and build newer binutils.\n+mkdir binutils-$TARGET\n+pushd binutils-$TARGET\n+curl https://ftp.gnu.org/gnu/binutils/binutils-$BINUTILS.tar.bz2 | tar xjf -\n+mkdir binutils-build\n+cd binutils-build\n+hide_output ../binutils-$BINUTILS/configure --target=$TARGET \\\n+  --prefix=$PREFIX --with-sysroot=$SYSROOT\n+hide_output make -j10\n+hide_output make install\n+popd\n+rm -rf binutils-$TARGET"}, {"sha": "f866a24287f9e6d9aed7b0758bd4ee258f37ee1c", "filename": "src/ci/docker/dist-powerpc64le-linux/build-powerpc64le-toolchain.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fdocker%2Fdist-powerpc64le-linux%2Fbuild-powerpc64le-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fdocker%2Fdist-powerpc64le-linux%2Fbuild-powerpc64le-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-powerpc64le-linux%2Fbuild-powerpc64le-toolchain.sh?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -4,7 +4,7 @@ set -ex\n \n source shared.sh\n \n-BINUTILS=2.25.1\n+BINUTILS=2.32\n GCC=5.3.0\n TARGET=powerpc64le-linux-gnu\n SYSROOT=/usr/local/$TARGET/sysroot"}, {"sha": "ae2ea8ef95a6a18fe0661595f8e3f8cd893fffd0", "filename": "src/ci/docker/dist-various-1/Dockerfile", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fdocker%2Fdist-various-1%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fdocker%2Fdist-various-1%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-1%2FDockerfile?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -64,7 +64,7 @@ RUN env \\\n     env \\\n     CC=arm-linux-gnueabihf-gcc CFLAGS=\"-march=armv7-a\" \\\n     CXX=arm-linux-gnueabihf-g++ CXXFLAGS=\"-march=armv7-a\" \\\n-    bash musl.sh armv7 && \\\n+    bash musl.sh armv7hf && \\\n     env \\\n     CC=aarch64-linux-gnu-gcc \\\n     CXX=aarch64-linux-gnu-g++ \\\n@@ -104,12 +104,17 @@ ENV TARGETS=$TARGETS,armv5te-unknown-linux-musleabi\n ENV TARGETS=$TARGETS,armv7-unknown-linux-musleabihf\n ENV TARGETS=$TARGETS,aarch64-unknown-linux-musl\n ENV TARGETS=$TARGETS,sparc64-unknown-linux-gnu\n-ENV TARGETS=$TARGETS,x86_64-unknown-redox\n+# FIXME: temporarily disable the redox builder,\n+# see: https://github.com/rust-lang/rust/issues/63160\n+# ENV TARGETS=$TARGETS,x86_64-unknown-redox\n ENV TARGETS=$TARGETS,thumbv6m-none-eabi\n ENV TARGETS=$TARGETS,thumbv7m-none-eabi\n ENV TARGETS=$TARGETS,thumbv7em-none-eabi\n ENV TARGETS=$TARGETS,thumbv7em-none-eabihf\n+ENV TARGETS=$TARGETS,thumbv8m.base-none-eabi\n ENV TARGETS=$TARGETS,thumbv8m.main-none-eabi\n+ENV TARGETS=$TARGETS,thumbv8m.main-none-eabihf\n+ENV TARGETS=$TARGETS,riscv32i-unknown-none-elf\n ENV TARGETS=$TARGETS,riscv32imc-unknown-none-elf\n ENV TARGETS=$TARGETS,riscv32imac-unknown-none-elf\n ENV TARGETS=$TARGETS,riscv64imac-unknown-none-elf\n@@ -124,7 +129,6 @@ ENV CC_mipsel_unknown_linux_musl=mipsel-openwrt-linux-gcc \\\n     CC_mips_unknown_linux_musl=mips-openwrt-linux-gcc \\\n     CC_sparc64_unknown_linux_gnu=sparc64-linux-gnu-gcc \\\n     CC_x86_64_unknown_redox=x86_64-unknown-redox-gcc \\\n-    CC_armebv7r_none_eabi=arm-none-eabi-gcc \\\n     CC_thumbv7neon_unknown_linux_gnueabihf=arm-linux-gnueabihf-gcc \\\n     AR_thumbv7neon_unknown_linux_gnueabihf=arm-linux-gnueabihf-ar \\\n     CXX_thumbv7neon_unknown_linux_gnueabihf=arm-linux-gnueabihf-g++\n@@ -133,7 +137,7 @@ ENV RUST_CONFIGURE_ARGS \\\n       --musl-root-armv5te=/musl-armv5te \\\n       --musl-root-arm=/musl-arm \\\n       --musl-root-armhf=/musl-armhf \\\n-      --musl-root-armv7=/musl-armv7 \\\n+      --musl-root-armv7hf=/musl-armv7hf \\\n       --musl-root-aarch64=/musl-aarch64 \\\n       --musl-root-mips=/musl-mips \\\n       --musl-root-mipsel=/musl-mipsel \\"}, {"sha": "60a96e3b8e9524e5d951249ae58649ae4b23cea6", "filename": "src/ci/docker/dist-various-1/install-mips-musl.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fdocker%2Fdist-various-1%2Finstall-mips-musl.sh", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fdocker%2Fdist-various-1%2Finstall-mips-musl.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-1%2Finstall-mips-musl.sh?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -5,7 +5,7 @@ mkdir /usr/local/mips-linux-musl\n # originally from\n # https://downloads.openwrt.org/snapshots/trunk/ar71xx/generic/\n # OpenWrt-Toolchain-ar71xx-generic_gcc-5.3.0_musl-1.1.16.Linux-x86_64.tar.bz2\n-URL=\"https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror\"\n+URL=\"https://rust-lang-ci2.s3.amazonaws.com/rust-ci-mirror\"\n FILE=\"OpenWrt-Toolchain-ar71xx-generic_gcc-5.3.0_musl-1.1.16.Linux-x86_64.tar.bz2\"\n curl -L \"$URL/$FILE\" | tar xjf - -C /usr/local/mips-linux-musl --strip-components=2\n "}, {"sha": "9ae41218ee4fbf2f429510d50fb7f8b475aa4c07", "filename": "src/ci/docker/dist-various-1/install-mipsel-musl.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fdocker%2Fdist-various-1%2Finstall-mipsel-musl.sh", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fdocker%2Fdist-various-1%2Finstall-mipsel-musl.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-1%2Finstall-mipsel-musl.sh?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -5,7 +5,7 @@ mkdir /usr/local/mipsel-linux-musl\n # Note that this originally came from:\n # https://downloads.openwrt.org/snapshots/trunk/malta/generic/\n # OpenWrt-Toolchain-malta-le_gcc-5.3.0_musl-1.1.15.Linux-x86_64.tar.bz2\n-URL=\"https://s3-us-west-1.amazonaws.com/rust-lang-ci2/libc\"\n+URL=\"https://rust-lang-ci2.s3.amazonaws.com/libc\"\n FILE=\"OpenWrt-Toolchain-malta-le_gcc-5.3.0_musl-1.1.15.Linux-x86_64.tar.bz2\"\n curl -L \"$URL/$FILE\" | tar xjf - -C /usr/local/mipsel-linux-musl --strip-components=2\n "}, {"sha": "dad9792233847fd7ad77a28fc72dc4d5aa439a6a", "filename": "src/ci/docker/dist-various-1/install-x86_64-redox.sh", "status": "modified", "additions": 2, "deletions": 9, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fdocker%2Fdist-various-1%2Finstall-x86_64-redox.sh", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fdocker%2Fdist-various-1%2Finstall-x86_64-redox.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-1%2Finstall-x86_64-redox.sh?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -1,13 +1,6 @@\n #!/usr/bin/env bash\n-# ignore-tidy-linelength\n \n set -ex\n \n-apt-get update\n-apt-get install -y --no-install-recommends software-properties-common apt-transport-https\n-\n-apt-key adv --batch --yes --keyserver hkp://keyserver.ubuntu.com:80 --recv-keys AA12E97F0881517F\n-add-apt-repository -y 'deb https://static.redox-os.org/toolchain/apt /'\n-\n-apt-get update\n-apt-get install -y x86-64-unknown-redox-gcc\n+curl https://static.redox-os.org/toolchain/x86_64-unknown-redox/relibc-install.tar.gz | \\\n+tar --extract --gzip --directory /usr/local"}, {"sha": "2ae6c58941e4c62e781600772640c701582f7e3d", "filename": "src/ci/docker/dist-various-2/Dockerfile", "status": "modified", "additions": 43, "deletions": 8, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fdocker%2Fdist-various-2%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fdocker%2Fdist-various-2%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-2%2FDockerfile?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -1,11 +1,15 @@\n-FROM ubuntu:17.10\n+FROM ubuntu:18.04\n \n COPY scripts/cross-apt-packages.sh /scripts/\n RUN sh /scripts/cross-apt-packages.sh\n \n-RUN apt-get build-dep -y clang llvm && apt-get install -y --no-install-recommends \\\n+# Enable source repositories, which are disabled by default on Ubuntu >= 18.04\n+RUN sed -i 's/^# deb-src/deb-src/' /etc/apt/sources.list\n+\n+RUN apt-get update && apt-get build-dep -y clang llvm && apt-get install -y --no-install-recommends \\\n   build-essential \\\n-  gcc-multilib \\\n+# gcc-multilib can not be installed together with gcc-arm-linux-gnueabi\n+  gcc-7-multilib \\\n   libedit-dev \\\n   libgmp-dev \\\n   libisl-dev \\\n@@ -15,10 +19,22 @@ RUN apt-get build-dep -y clang llvm && apt-get install -y --no-install-recommend\n   nodejs \\\n   python2.7-dev \\\n   software-properties-common \\\n-  unzip\n+  unzip \\\n+  # Needed for apt-key to work:\n+  dirmngr \\\n+  gpg-agent \\\n+  g++-7-arm-linux-gnueabi\n \n RUN apt-key adv --batch --yes --keyserver keyserver.ubuntu.com --recv-keys 74DA7924C5513486\n-RUN add-apt-repository -y 'deb http://apt.dilos.org/dilos dilos2-testing main'\n+RUN add-apt-repository -y 'deb http://apt.dilos.org/dilos dilos2 main'\n+\n+WORKDIR /build\n+COPY scripts/musl.sh /build\n+RUN env \\\n+    CC=arm-linux-gnueabi-gcc-7 CFLAGS=\"-march=armv7-a\" \\\n+    CXX=arm-linux-gnueabi-g++-7 CXXFLAGS=\"-march=armv7-a\" \\\n+    bash musl.sh armv7 && \\\n+    rm -rf /build/*\n \n WORKDIR /tmp\n COPY dist-various-2/shared.sh /tmp/\n@@ -34,6 +50,9 @@ COPY dist-various-2/build-x86_64-fortanix-unknown-sgx-toolchain.sh /tmp/\n # Any update to the commit id here, should cause the container image to be re-built from this point on.\n RUN /tmp/build-x86_64-fortanix-unknown-sgx-toolchain.sh \"53b586346f2c7870e20b170decdc30729d97c42b\"\n \n+COPY dist-various-2/build-wasi-toolchain.sh /tmp/\n+RUN /tmp/build-wasi-toolchain.sh\n+\n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh\n \n@@ -49,7 +68,11 @@ ENV \\\n     CXX_sparcv9_sun_solaris=sparcv9-sun-solaris2.10-g++ \\\n     AR_x86_64_sun_solaris=x86_64-sun-solaris2.10-ar \\\n     CC_x86_64_sun_solaris=x86_64-sun-solaris2.10-gcc \\\n-    CXX_x86_64_sun_solaris=x86_64-sun-solaris2.10-g++\n+    CXX_x86_64_sun_solaris=x86_64-sun-solaris2.10-g++ \\\n+    CC_armv7_unknown_linux_gnueabi=arm-linux-gnueabi-gcc-7 \\\n+    CXX_armv7_unknown_linux_gnueabi=arm-linux-gnueabi-g++-7 \\\n+    CC=gcc-7 \\\n+    CXX=g++-7\n \n ENV CARGO_TARGET_X86_64_FUCHSIA_AR /usr/local/bin/llvm-ar\n ENV CARGO_TARGET_X86_64_FUCHSIA_RUSTFLAGS \\\n@@ -64,15 +87,27 @@ ENV CARGO_TARGET_AARCH64_FUCHSIA_RUSTFLAGS \\\n \n ENV TARGETS=x86_64-fuchsia\n ENV TARGETS=$TARGETS,aarch64-fuchsia\n-ENV TARGETS=$TARGETS,sparcv9-sun-solaris\n ENV TARGETS=$TARGETS,wasm32-unknown-unknown\n+ENV TARGETS=$TARGETS,wasm32-wasi\n+ENV TARGETS=$TARGETS,sparcv9-sun-solaris\n ENV TARGETS=$TARGETS,x86_64-sun-solaris\n ENV TARGETS=$TARGETS,x86_64-unknown-linux-gnux32\n ENV TARGETS=$TARGETS,x86_64-unknown-cloudabi\n ENV TARGETS=$TARGETS,x86_64-fortanix-unknown-sgx\n ENV TARGETS=$TARGETS,nvptx64-nvidia-cuda\n+ENV TARGETS=$TARGETS,armv7-unknown-linux-gnueabi\n+ENV TARGETS=$TARGETS,armv7-unknown-linux-musleabi\n \n ENV X86_FORTANIX_SGX_LIBS=\"/x86_64-fortanix-unknown-sgx/lib/\"\n \n-ENV RUST_CONFIGURE_ARGS --enable-extended --enable-lld --disable-docs\n+# As per https://bugs.launchpad.net/ubuntu/+source/gcc-defaults/+bug/1300211\n+# we need asm in the search path for gcc-7 (for gnux32) but not in the search path of the\n+# cross compilers.\n+# Luckily one of the folders is /usr/local/include so symlink /usr/include/asm-generic there\n+RUN ln -s /usr/include/asm-generic /usr/local/include/asm\n+\n+ENV RUST_CONFIGURE_ARGS --enable-extended --enable-lld --disable-docs \\\n+  --set target.wasm32-wasi.wasi-root=/wasm32-wasi \\\n+  --musl-root-armv7=/musl-armv7\n+\n ENV SCRIPT python2.7 ../x.py dist --target $TARGETS"}, {"sha": "73acdf5be6356733909ae059d71837f5c64be18d", "filename": "src/ci/docker/dist-various-2/build-fuchsia-toolchain.sh", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fdocker%2Fdist-various-2%2Fbuild-fuchsia-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fdocker%2Fdist-various-2%2Fbuild-fuchsia-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-2%2Fbuild-fuchsia-toolchain.sh?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -1,7 +1,5 @@\n #!/usr/bin/env bash\n \n-# ignore-tidy-linelength\n-\n set -ex\n source shared.sh\n \n@@ -12,7 +10,7 @@ pushd zircon > /dev/null\n \n # Download sources\n git init\n-git remote add origin https://fuchsia.googlesource.com/zircon\n+git remote add origin https://github.com/rust-lang-nursery/mirror-google-fuchsia-zircon\n git fetch --depth=1 origin $ZIRCON\n git reset --hard FETCH_HEAD\n "}, {"sha": "7bf8946c4f136a4d3b7b09206bd3b3404701232c", "filename": "src/ci/docker/dist-various-2/build-wasi-toolchain.sh", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fdocker%2Fdist-various-2%2Fbuild-wasi-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fdocker%2Fdist-various-2%2Fbuild-wasi-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-various-2%2Fbuild-wasi-toolchain.sh?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -0,0 +1,20 @@\n+#!/bin/sh\n+#\n+# ignore-tidy-linelength\n+\n+set -ex\n+\n+# Originally from https://releases.llvm.org/8.0.0/clang+llvm-8.0.0-x86_64-linux-gnu-ubuntu-14.04.tar.xz\n+curl https://rust-lang-ci2.s3.amazonaws.com/rust-ci-mirror/clang%2Bllvm-8.0.0-x86_64-linux-gnu-ubuntu-14.04.tar.xz | \\\n+  tar xJf -\n+export PATH=`pwd`/clang+llvm-8.0.0-x86_64-linux-gnu-ubuntu-14.04/bin:$PATH\n+\n+git clone https://github.com/CraneStation/wasi-sysroot\n+\n+cd wasi-sysroot\n+git reset --hard e5f14be38362f1ab83302895a6e74b2ffd0e2302\n+make -j$(nproc) INSTALL_DIR=/wasm32-wasi install\n+\n+cd ..\n+rm -rf reference-sysroot-wasi\n+rm -rf clang+llvm*"}, {"sha": "ddc2066537cefa7f69d0b6599695a7da8defa5df", "filename": "src/ci/docker/dist-x86_64-linux/build-gcc.sh", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-gcc.sh", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-gcc.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-gcc.sh?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -32,6 +32,7 @@ hide_output ../gcc-$GCC/configure \\\n     --enable-languages=c,c++\n hide_output make -j10\n hide_output make install\n+ln -s gcc /rustroot/bin/cc\n \n cd ..\n rm -rf gcc-build"}, {"sha": "13dae6169053a09a3eedd892180c11da48d8aba5", "filename": "src/ci/docker/dist-x86_64-linux/build-openssl.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-openssl.sh", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-openssl.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-linux%2Fbuild-openssl.sh?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -4,7 +4,7 @@ set -ex\n source shared.sh\n \n VERSION=1.0.2k\n-URL=https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror/openssl-$VERSION.tar.gz\n+URL=https://rust-lang-ci2.s3.amazonaws.com/rust-ci-mirror/openssl-$VERSION.tar.gz\n \n curl $URL | tar xzf -\n "}, {"sha": "385eefde846c293b41d3f3727fec5e8fc9cc2267", "filename": "src/ci/docker/dist-x86_64-musl/Dockerfile", "status": "modified", "additions": 16, "deletions": 12, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fdocker%2Fdist-x86_64-musl%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fdocker%2Fdist-x86_64-musl%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-musl%2FDockerfile?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -4,6 +4,7 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   g++ \\\n   make \\\n   file \\\n+  wget \\\n   curl \\\n   ca-certificates \\\n   python2.7 \\\n@@ -18,29 +19,32 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n \n WORKDIR /build/\n \n-COPY scripts/musl.sh /build/\n+COPY scripts/musl-toolchain.sh /build/\n # We need to mitigate rust-lang/rust#34978 when compiling musl itself as well\n-RUN CC=gcc \\\n-    CFLAGS=\"-Wa,-mrelax-relocations=no\" \\\n-    CXX=g++ \\\n-    CXXFLAGS=\"-Wa,-mrelax-relocations=no\" \\\n-    bash musl.sh x86_64 && rm -rf /build\n+RUN CFLAGS=\"-Wa,-mrelax-relocations=no -Wa,--compress-debug-sections=none -Wl,--compress-debug-sections=none\" \\\n+    CXXFLAGS=\"-Wa,-mrelax-relocations=no -Wa,--compress-debug-sections=none -Wl,--compress-debug-sections=none\" \\\n+    REPLACE_CC=1 bash musl-toolchain.sh x86_64 && rm -rf build\n \n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh\n \n+ENV HOSTS=x86_64-unknown-linux-musl\n+\n ENV RUST_CONFIGURE_ARGS \\\n-      --musl-root-x86_64=/musl-x86_64 \\\n+      --musl-root-x86_64=/usr/local/x86_64-linux-musl \\\n       --enable-extended \\\n-      --disable-docs\n+      --disable-docs \\\n+      --set target.x86_64-unknown-linux-musl.crt-static=false \\\n+      --build $HOSTS\n \n # Newer binutils broke things on some vms/distros (i.e., linking against\n # unknown relocs disabled by the following flag), so we need to go out of our\n # way to produce \"super compatible\" binaries.\n #\n # See: https://github.com/rust-lang/rust/issues/34978\n-ENV CFLAGS_x86_64_unknown_linux_musl=-Wa,-mrelax-relocations=no\n+# And: https://github.com/rust-lang/rust/issues/59411\n+ENV CFLAGS_x86_64_unknown_linux_musl=\"-Wa,-mrelax-relocations=no -Wa,--compress-debug-sections=none \\\n+    -Wl,--compress-debug-sections=none\"\n \n-ENV SCRIPT \\\n-      python2.7 ../x.py test --target x86_64-unknown-linux-musl && \\\n-      python2.7 ../x.py dist --target x86_64-unknown-linux-musl\n+# To run native tests replace `dist` below with `test`\n+ENV SCRIPT python2.7 ../x.py dist --build $HOSTS"}, {"sha": "2e9b9dcc2344ed2d1c38f30c53bf18f5e348381e", "filename": "src/ci/docker/dist-x86_64-netbsd/build-netbsd-toolchain.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fdocker%2Fdist-x86_64-netbsd%2Fbuild-netbsd-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fdocker%2Fdist-x86_64-netbsd%2Fbuild-netbsd-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fdist-x86_64-netbsd%2Fbuild-netbsd-toolchain.sh?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -25,7 +25,7 @@ cd netbsd\n \n mkdir -p /x-tools/x86_64-unknown-netbsd/sysroot\n \n-URL=https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror\n+URL=https://rust-lang-ci2.s3.amazonaws.com/rust-ci-mirror\n \n # Originally from ftp://ftp.netbsd.org/pub/NetBSD/NetBSD-$BSD/source/sets/*.tgz\n curl $URL/2018-03-01-netbsd-src.tgz | tar xzf -"}, {"sha": "2041ba50bc9a041f9ac6e7d9332203df54e454d4", "filename": "src/ci/docker/i686-gnu-nopt/Dockerfile", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fdocker%2Fi686-gnu-nopt%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fdocker%2Fi686-gnu-nopt%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fi686-gnu-nopt%2FDockerfile?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -18,4 +18,4 @@ COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh\n \n ENV RUST_CONFIGURE_ARGS --build=i686-unknown-linux-gnu --disable-optimize-tests\n-ENV RUST_CHECK_TARGET check\n+ENV SCRIPT python2.7 ../x.py test"}, {"sha": "415d6b63eb8dc1152de7a0c191c0ce0cc4da250a", "filename": "src/ci/docker/run.sh", "status": "modified", "additions": 75, "deletions": 25, "changes": 100, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fdocker%2Frun.sh", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fdocker%2Frun.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Frun.sh?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -12,23 +12,37 @@ ci_dir=\"`dirname $docker_dir`\"\n src_dir=\"`dirname $ci_dir`\"\n root_dir=\"`dirname $src_dir`\"\n \n-source \"$ci_dir/shared.sh\"\n+objdir=$root_dir/obj\n+dist=$objdir/build/dist\n \n-travis_fold start build_docker\n-travis_time_start\n+source \"$ci_dir/shared.sh\"\n \n if [ -f \"$docker_dir/$image/Dockerfile\" ]; then\n     if [ \"$CI\" != \"\" ]; then\n       hash_key=/tmp/.docker-hash-key.txt\n       rm -f \"${hash_key}\"\n       echo $image >> $hash_key\n-      find $docker_dir -type f | sort | xargs cat >> $hash_key\n+\n+      cat \"$docker_dir/$image/Dockerfile\" >> $hash_key\n+      # Look for all source files involves in the COPY command\n+      copied_files=/tmp/.docker-copied-files.txt\n+      rm -f \"$copied_files\"\n+      for i in $(sed -n -e 's/^COPY \\(.*\\) .*$/\\1/p' \"$docker_dir/$image/Dockerfile\"); do\n+        # List the file names\n+        find \"$docker_dir/$i\" -type f >> $copied_files\n+      done\n+      # Sort the file names and cat the content into the hash key\n+      sort $copied_files | xargs cat >> $hash_key\n+\n       docker --version >> $hash_key\n       cksum=$(sha512sum $hash_key | \\\n         awk '{print $1}')\n+\n       s3url=\"s3://$SCCACHE_BUCKET/docker/$cksum\"\n-      url=\"https://s3-us-west-1.amazonaws.com/$SCCACHE_BUCKET/docker/$cksum\"\n-      echo \"Attempting to download $s3url\"\n+      url=\"https://$SCCACHE_BUCKET.s3.amazonaws.com/docker/$cksum\"\n+      upload=\"aws s3 cp - $s3url\"\n+\n+      echo \"Attempting to download $url\"\n       rm -f /tmp/rustci_docker_cache\n       set +e\n       retry curl -y 30 -Y 10 --connect-timeout 30 -f -L -C - -o /tmp/rustci_docker_cache \"$url\"\n@@ -51,28 +65,32 @@ if [ -f \"$docker_dir/$image/Dockerfile\" ]; then\n       -f \"$dockerfile\" \\\n       \"$context\"\n \n-    if [ \"$s3url\" != \"\" ]; then\n+    if [ \"$upload\" != \"\" ]; then\n       digest=$(docker inspect rust-ci --format '{{.Id}}')\n       echo \"Built container $digest\"\n       if ! grep -q \"$digest\" <(echo \"$loaded_images\"); then\n-        echo \"Uploading finished image to $s3url\"\n+        echo \"Uploading finished image to $url\"\n         set +e\n         docker history -q rust-ci | \\\n           grep -v missing | \\\n           xargs docker save | \\\n           gzip | \\\n-          aws s3 cp - $s3url\n+          $upload\n         set -e\n       else\n         echo \"Looks like docker image is the same as before, not uploading\"\n       fi\n+      # Record the container image for reuse, e.g. by rustup.rs builds\n+      info=\"$dist/image-$image.txt\"\n+      mkdir -p \"$dist\"\n+      echo \"$url\" >\"$info\"\n+      echo \"$digest\" >>\"$info\"\n     fi\n elif [ -f \"$docker_dir/disabled/$image/Dockerfile\" ]; then\n-    if [ -n \"$TRAVIS_OS_NAME\" ]; then\n-        echo Cannot run disabled images on travis!\n+    if isCI; then\n+        echo Cannot run disabled images on CI!\n         exit 1\n     fi\n-    # retry messes with the pipe from tar to docker. Not needed on non-travis\n     # Transform changes the context of disabled Dockerfiles to match the enabled ones\n     tar --transform 's#^./disabled/#./#' -C $docker_dir -c . | docker \\\n       build \\\n@@ -85,11 +103,6 @@ else\n     exit 1\n fi\n \n-travis_fold end build_docker\n-travis_time_finish\n-\n-objdir=$root_dir/obj\n-\n mkdir -p $HOME/.cargo\n mkdir -p $objdir/tmp\n mkdir -p $objdir/cores\n@@ -112,24 +125,61 @@ fi\n # goes ahead and sets it for all builders.\n args=\"$args --privileged\"\n \n-exec docker \\\n+# Things get a little weird if this script is already running in a docker\n+# container. If we're already in a docker container then we assume it's set up\n+# to do docker-in-docker where we have access to a working `docker` command.\n+#\n+# If this is the case (we check via the presence of `/.dockerenv`)\n+# then we can't actually use the `--volume` argument. Typically we use\n+# `--volume` to efficiently share the build and source directory between this\n+# script and the container we're about to spawn. If we're inside docker already\n+# though the `--volume` argument maps the *host's* folder to the container we're\n+# about to spawn, when in fact we want the folder in this container itself. To\n+# work around this we use a recipe cribbed from\n+# https://circleci.com/docs/2.0/building-docker-images/#mounting-folders to\n+# create a temporary container with a volume. We then copy the entire source\n+# directory into this container, and then use that copy in the container we're\n+# about to spawn. Finally after the build finishes we re-extract the object\n+# directory.\n+#\n+# Note that none of this is necessary if we're *not* in a docker-in-docker\n+# scenario. If this script is run on a bare metal host then we share a bunch of\n+# data directories to share as much data as possible. Note that we also use\n+# `LOCAL_USER_ID` (recognized in `src/ci/run.sh`) to ensure that files are all\n+# read/written as the same user as the bare-metal user.\n+if [ -f /.dockerenv ]; then\n+  docker create -v /checkout --name checkout alpine:3.4 /bin/true\n+  docker cp . checkout:/checkout\n+  args=\"$args --volumes-from checkout\"\n+else\n+  args=\"$args --volume $root_dir:/checkout:ro\"\n+  args=\"$args --volume $objdir:/checkout/obj\"\n+  args=\"$args --volume $HOME/.cargo:/cargo\"\n+  args=\"$args --volume $HOME/rustsrc:$HOME/rustsrc\"\n+  args=\"$args --env LOCAL_USER_ID=`id -u`\"\n+fi\n+\n+docker \\\n   run \\\n-  --volume \"$root_dir:/checkout:ro\" \\\n-  --volume \"$objdir:/checkout/obj\" \\\n   --workdir /checkout/obj \\\n   --env SRC=/checkout \\\n   $args \\\n   --env CARGO_HOME=/cargo \\\n   --env DEPLOY \\\n   --env DEPLOY_ALT \\\n-  --env LOCAL_USER_ID=`id -u` \\\n-  --env TRAVIS \\\n-  --env TRAVIS_BRANCH \\\n+  --env CI \\\n+  --env TF_BUILD \\\n+  --env BUILD_SOURCEBRANCHNAME \\\n   --env TOOLSTATE_REPO_ACCESS_TOKEN \\\n+  --env TOOLSTATE_REPO \\\n+  --env TOOLSTATE_PUBLISH \\\n   --env CI_JOB_NAME=\"${CI_JOB_NAME-$IMAGE}\" \\\n-  --volume \"$HOME/.cargo:/cargo\" \\\n-  --volume \"$HOME/rustsrc:$HOME/rustsrc\" \\\n   --init \\\n   --rm \\\n   rust-ci \\\n   /checkout/src/ci/run.sh\n+\n+if [ -f /.dockerenv ]; then\n+  rm -rf $objdir\n+  docker cp checkout:/checkout/obj $objdir\n+fi"}, {"sha": "7c9a8b82e928266aa914a07093c8352ca4e3698d", "filename": "src/ci/docker/scripts/android-sdk-manager.py", "status": "added", "additions": 190, "deletions": 0, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fdocker%2Fscripts%2Fandroid-sdk-manager.py", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fdocker%2Fscripts%2Fandroid-sdk-manager.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fscripts%2Fandroid-sdk-manager.py?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -0,0 +1,190 @@\n+#!/usr/bin/env python3\n+# Simpler reimplementation of Android's sdkmanager\n+# Extra features of this implementation are pinning and mirroring\n+\n+# These URLs are the Google repositories containing the list of available\n+# packages and their versions. The list has been generated by listing the URLs\n+# fetched while executing `tools/bin/sdkmanager --list`\n+BASE_REPOSITORY = \"https://dl.google.com/android/repository/\"\n+REPOSITORIES = [\n+    \"sys-img/android/sys-img2-1.xml\",\n+    \"sys-img/android-wear/sys-img2-1.xml\",\n+    \"sys-img/android-wear-cn/sys-img2-1.xml\",\n+    \"sys-img/android-tv/sys-img2-1.xml\",\n+    \"sys-img/google_apis/sys-img2-1.xml\",\n+    \"sys-img/google_apis_playstore/sys-img2-1.xml\",\n+    \"addon2-1.xml\",\n+    \"glass/addon2-1.xml\",\n+    \"extras/intel/addon2-1.xml\",\n+    \"repository2-1.xml\",\n+]\n+\n+# Available hosts: linux, macosx and windows\n+HOST_OS = \"linux\"\n+\n+# Mirroring options\n+MIRROR_BUCKET = \"rust-lang-ci2\"\n+MIRROR_BASE_DIR = \"rust-ci-mirror/android/\"\n+\n+import argparse\n+import hashlib\n+import os\n+import subprocess\n+import sys\n+import tempfile\n+import urllib.request\n+import xml.etree.ElementTree as ET\n+\n+class Package:\n+    def __init__(self, path, url, sha1, deps=None):\n+        if deps is None:\n+            deps = []\n+        self.path = path.strip()\n+        self.url = url.strip()\n+        self.sha1 = sha1.strip()\n+        self.deps = deps\n+\n+    def download(self, base_url):\n+        _, file = tempfile.mkstemp()\n+        url = base_url + self.url\n+        subprocess.run([\"curl\", \"-o\", file, url], check=True)\n+        # Ensure there are no hash mismatches\n+        with open(file, \"rb\") as f:\n+            sha1 = hashlib.sha1(f.read()).hexdigest()\n+            if sha1 != self.sha1:\n+                raise RuntimeError(\n+                    \"hash mismatch for package \" + self.path + \": \" +\n+                    sha1 + \" vs \" + self.sha1 + \" (known good)\"\n+                )\n+        return file\n+\n+    def __repr__(self):\n+        return \"<Package \"+self.path+\" at \"+self.url+\" (sha1=\"+self.sha1+\")\"\n+\n+def fetch_url(url):\n+    page = urllib.request.urlopen(url)\n+    return page.read()\n+\n+def fetch_repository(base, repo_url):\n+    packages = {}\n+    root = ET.fromstring(fetch_url(base + repo_url))\n+    for package in root:\n+        if package.tag != \"remotePackage\":\n+            continue\n+        path = package.attrib[\"path\"]\n+\n+        for archive in package.find(\"archives\"):\n+            host_os = archive.find(\"host-os\")\n+            if host_os is not None and host_os.text != HOST_OS:\n+                continue\n+            complete = archive.find(\"complete\")\n+            url = os.path.join(os.path.dirname(repo_url), complete.find(\"url\").text)\n+            sha1 = complete.find(\"checksum\").text\n+\n+            deps = []\n+            dependencies = package.find(\"dependencies\")\n+            if dependencies is not None:\n+                for dep in dependencies:\n+                    deps.append(dep.attrib[\"path\"])\n+\n+            packages[path] = Package(path, url, sha1, deps)\n+            break\n+\n+    return packages\n+\n+def fetch_repositories():\n+    packages = {}\n+    for repo in REPOSITORIES:\n+        packages.update(fetch_repository(BASE_REPOSITORY, repo))\n+    return packages\n+\n+class Lockfile:\n+    def __init__(self, path):\n+        self.path = path\n+        self.packages = {}\n+        if os.path.exists(path):\n+            with open(path) as f:\n+                for line in f:\n+                    path, url, sha1 = line.split(\" \")\n+                    self.packages[path] = Package(path, url, sha1)\n+\n+    def add(self, packages, name, *, update=True):\n+        if name not in packages:\n+            raise NameError(\"package not found: \" + name)\n+        if not update and name in self.packages:\n+            return\n+        self.packages[name] = packages[name]\n+        for dep in packages[name].deps:\n+            self.add(packages, dep, update=False)\n+\n+    def save(self):\n+        packages = list(sorted(self.packages.values(), key=lambda p: p.path))\n+        with open(self.path, \"w\") as f:\n+            for package in packages:\n+                f.write(package.path + \" \" + package.url + \" \" + package.sha1 + \"\\n\")\n+\n+def cli_add_to_lockfile(args):\n+    lockfile = Lockfile(args.lockfile)\n+    packages = fetch_repositories()\n+    for package in args.packages:\n+        lockfile.add(packages, package)\n+    lockfile.save()\n+\n+def cli_update_mirror(args):\n+    lockfile = Lockfile(args.lockfile)\n+    for package in lockfile.packages.values():\n+        path = package.download(BASE_REPOSITORY)\n+        subprocess.run([\n+            \"aws\", \"s3\", \"mv\", path,\n+            \"s3://\" + MIRROR_BUCKET + \"/\" + MIRROR_BASE_DIR + package.url,\n+            \"--profile=\" + args.awscli_profile,\n+        ], check=True)\n+\n+def cli_install(args):\n+    lockfile = Lockfile(args.lockfile)\n+    for package in lockfile.packages.values():\n+        # Download the file from the mirror into a temp file\n+        url = \"https://\" + MIRROR_BUCKET + \".s3.amazonaws.com/\" + MIRROR_BASE_DIR\n+        downloaded = package.download(url)\n+        # Extract the file in a temporary directory\n+        extract_dir = tempfile.mkdtemp()\n+        subprocess.run([\n+            \"unzip\", \"-q\", downloaded, \"-d\", extract_dir,\n+        ], check=True)\n+        # Figure out the prefix used in the zip\n+        subdirs = [d for d in os.listdir(extract_dir) if not d.startswith(\".\")]\n+        if len(subdirs) != 1:\n+            raise RuntimeError(\"extracted directory contains more than one dir\")\n+        # Move the extracted files in the proper directory\n+        dest = os.path.join(args.dest, package.path.replace(\";\", \"/\"))\n+        os.makedirs(\"/\".join(dest.split(\"/\")[:-1]), exist_ok=True)\n+        os.rename(os.path.join(extract_dir, subdirs[0]), dest)\n+        os.unlink(downloaded)\n+\n+def cli():\n+    parser = argparse.ArgumentParser()\n+    subparsers = parser.add_subparsers()\n+\n+    add_to_lockfile = subparsers.add_parser(\"add-to-lockfile\")\n+    add_to_lockfile.add_argument(\"lockfile\")\n+    add_to_lockfile.add_argument(\"packages\", nargs=\"+\")\n+    add_to_lockfile.set_defaults(func=cli_add_to_lockfile)\n+\n+    update_mirror = subparsers.add_parser(\"update-mirror\")\n+    update_mirror.add_argument(\"lockfile\")\n+    update_mirror.add_argument(\"--awscli-profile\", default=\"default\")\n+    update_mirror.set_defaults(func=cli_update_mirror)\n+\n+    install = subparsers.add_parser(\"install\")\n+    install.add_argument(\"lockfile\")\n+    install.add_argument(\"dest\")\n+    install.set_defaults(func=cli_install)\n+\n+    args = parser.parse_args()\n+    if not hasattr(args, \"func\"):\n+        print(\"error: a subcommand is required (see --help)\")\n+        exit(1)\n+    args.func(args)\n+\n+if __name__ == \"__main__\":\n+    cli()"}, {"sha": "e35be697a8df095b58981d8acdb18b7c0d371c8f", "filename": "src/ci/docker/scripts/android-sdk.sh", "status": "modified", "additions": 21, "deletions": 48, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fdocker%2Fscripts%2Fandroid-sdk.sh", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fdocker%2Fscripts%2Fandroid-sdk.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fscripts%2Fandroid-sdk.sh?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -2,54 +2,27 @@ set -ex\n \n export ANDROID_HOME=/android/sdk\n PATH=$PATH:\"${ANDROID_HOME}/tools/bin\"\n+LOCKFILE=\"${ANDROID_HOME}/android-sdk.lock\"\n \n-download_sdk() {\n-    mkdir -p /android\n-    curl -fo sdk.zip \"https://dl.google.com/android/repository/sdk-tools-linux-$1.zip\"\n-    unzip -q sdk.zip -d \"$ANDROID_HOME\"\n-    rm -f sdk.zip\n-}\n-\n-download_sysimage() {\n-    abi=$1\n-    api=$2\n-\n-    # See https://developer.android.com/studio/command-line/sdkmanager.html for\n-    # usage of `sdkmanager`.\n-    #\n-    # The output from sdkmanager is so noisy that it will occupy all of the 4 MB\n-    # log extremely quickly. Thus we must silence all output.\n-    yes | sdkmanager --licenses > /dev/null\n-    yes | sdkmanager platform-tools emulator \\\n-        \"platforms;android-$api\" \\\n-        \"system-images;android-$api;default;$abi\" > /dev/null\n-}\n-\n-create_avd() {\n-    abi=$1\n-    api=$2\n-\n-    # See https://developer.android.com/studio/command-line/avdmanager.html for\n-    # usage of `avdmanager`.\n-    echo no | avdmanager create avd \\\n-        -n \"$abi-$api\" \\\n-        -k \"system-images;android-$api;default;$abi\"\n-}\n-\n-download_and_create_avd() {\n-    download_sdk $1\n-    download_sysimage $2 $3\n-    create_avd $2 $3\n-}\n-\n-# Usage:\n+# To add a new packages to the SDK or to update an existing one you need to\n+# run the command:\n+#\n+#    android-sdk-manager.py add-to-lockfile $LOCKFILE <package-name>\n+#\n+# Then, after every lockfile update the mirror has to be synchronized as well:\n #\n-#       setup_android_sdk 4333796 armeabi-v7a 18\n+#    android-sdk-manager.py update-mirror $LOCKFILE\n #\n-# 4333796 =>\n-#   SDK tool version.\n-#   Copy from https://developer.android.com/studio/index.html#command-tools\n-# armeabi-v7a =>\n-#   System image ABI\n-# 18 =>\n-#   Android API Level (18 = Android 4.3 = Jelly Bean MR2)\n+/scripts/android-sdk-manager.py install \"${LOCKFILE}\" \"${ANDROID_HOME}\"\n+\n+details=$(cat \"${LOCKFILE}\" \\\n+    | grep system-images \\\n+    | sed 's/^system-images;android-\\([0-9]\\+\\);default;\\([a-z0-9-]\\+\\) /\\1 \\2 /g')\n+api=\"$(echo \"${details}\" | awk '{print($1)}')\"\n+abi=\"$(echo \"${details}\" | awk '{print($2)}')\"\n+\n+# See https://developer.android.com/studio/command-line/avdmanager.html for\n+# usage of `avdmanager`.\n+echo no | avdmanager create avd \\\n+    -n \"$abi-$api\" \\\n+    -k \"system-images;android-$api;default;$abi\""}, {"sha": "47196e8939626a69bc82255bac116f0a68981459", "filename": "src/ci/docker/scripts/emscripten.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fdocker%2Fscripts%2Femscripten.sh", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fdocker%2Fscripts%2Femscripten.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fscripts%2Femscripten.sh?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -18,7 +18,7 @@ exit 1\n }\n \n cd /\n-curl -fL https://s3.amazonaws.com/mozilla-games/emscripten/releases/emsdk-portable.tar.gz | \\\n+curl -fL https://mozilla-games.s3.amazonaws.com/emscripten/releases/emsdk-portable.tar.gz | \\\n     tar -xz\n \n cd /emsdk-portable"}, {"sha": "8cef69d9c26bb5b34c4f726d541ffe5985cb9a5f", "filename": "src/ci/docker/scripts/freebsd-toolchain.sh", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fdocker%2Fscripts%2Ffreebsd-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fdocker%2Fscripts%2Ffreebsd-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fscripts%2Ffreebsd-toolchain.sh?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -1,4 +1,6 @@\n #!/bin/bash\n+# ignore-tidy-linelength\n+\n set -eux\n \n arch=$1\n@@ -55,7 +57,9 @@ for lib in c++ c_nonshared compiler_rt execinfo gcc pthread rt ssp_nonshared; do\n   files_to_extract=(\"${files_to_extract[@]}\" \"./usr/lib/lib${lib}.*\")\n done\n \n-URL=https://download.freebsd.org/ftp/releases/${freebsd_arch}/${freebsd_version}-RELEASE/base.txz\n+# Originally downloaded from:\n+# https://download.freebsd.org/ftp/releases/${freebsd_arch}/${freebsd_version}-RELEASE/base.txz\n+URL=https://rust-lang-ci2.s3.amazonaws.com/rust-ci-mirror/2019-04-04-freebsd-${freebsd_arch}-${freebsd_version}-RELEASE-base.txz\n curl \"$URL\" | tar xJf - -C \"$sysroot\" --wildcards \"${files_to_extract[@]}\"\n \n # Fix up absolute symlinks from the system image.  This can be removed"}, {"sha": "55899fa6c3e695f655971730bf17d77f0fa5196c", "filename": "src/ci/docker/scripts/musl-toolchain.sh", "status": "added", "additions": 82, "deletions": 0, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fdocker%2Fscripts%2Fmusl-toolchain.sh", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fdocker%2Fscripts%2Fmusl-toolchain.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fscripts%2Fmusl-toolchain.sh?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -0,0 +1,82 @@\n+# This script runs `musl-cross-make` to prepare C toolchain (Binutils, GCC, musl itself)\n+# and builds static libunwind that we distribute for static target.\n+#\n+# Versions of the toolchain components are configurable in `musl-cross-make/Makefile` and\n+# musl unlike GLIBC is forward compatible so upgrading it shouldn't break old distributions.\n+# Right now we have: Binutils 2.27, GCC 6.4.0, musl 1.1.22.\n+set -ex\n+\n+hide_output() {\n+  set +x\n+  on_err=\"\n+echo ERROR: An error was encountered with the build.\n+cat /tmp/build.log\n+exit 1\n+\"\n+  trap \"$on_err\" ERR\n+  bash -c \"while true; do sleep 30; echo \\$(date) - building ...; done\" &\n+  PING_LOOP_PID=$!\n+  $@ &> /tmp/build.log\n+  trap - ERR\n+  kill $PING_LOOP_PID\n+  rm /tmp/build.log\n+  set -x\n+}\n+\n+ARCH=$1\n+TARGET=$ARCH-linux-musl\n+\n+OUTPUT=/usr/local\n+shift\n+\n+# Ancient binutils versions don't understand debug symbols produced by more recent tools.\n+# Apparently applying `-fPIC` everywhere allows them to link successfully.\n+export CFLAGS=\"-fPIC $CFLAGS\"\n+\n+git clone https://github.com/richfelker/musl-cross-make -b v0.9.8\n+cd musl-cross-make\n+\n+hide_output make -j$(nproc) TARGET=$TARGET\n+hide_output make install TARGET=$TARGET OUTPUT=$OUTPUT\n+\n+cd -\n+\n+# Install musl library to make binaries executable\n+ln -s $OUTPUT/$TARGET/lib/libc.so /lib/ld-musl-$ARCH.so.1\n+echo $OUTPUT/$TARGET/lib >> /etc/ld-musl-$ARCH.path\n+\n+# Now when musl bootstraps itself create proper toolchain symlinks to make build and tests easier\n+if [ \"$REPLACE_CC\" = \"1\" ]; then\n+    for exec in cc gcc; do\n+        ln -s $TARGET-gcc /usr/local/bin/$exec\n+    done\n+    for exec in cpp c++ g++; do\n+        ln -s $TARGET-g++ /usr/local/bin/$exec\n+    done\n+fi\n+\n+export CC=$TARGET-gcc\n+export CXX=$TARGET-g++\n+\n+LLVM=70\n+\n+# may have been downloaded in a previous run\n+if [ ! -d libunwind-release_$LLVM ]; then\n+  curl -L https://github.com/llvm-mirror/llvm/archive/release_$LLVM.tar.gz | tar xzf -\n+  curl -L https://github.com/llvm-mirror/libunwind/archive/release_$LLVM.tar.gz | tar xzf -\n+fi\n+\n+# fixme(mati865): Replace it with https://github.com/rust-lang/rust/pull/59089\n+mkdir libunwind-build\n+cd libunwind-build\n+cmake ../libunwind-release_$LLVM \\\n+          -DLLVM_PATH=/build/llvm-release_$LLVM \\\n+          -DLIBUNWIND_ENABLE_SHARED=0 \\\n+          -DCMAKE_C_COMPILER=$CC \\\n+          -DCMAKE_CXX_COMPILER=$CXX \\\n+          -DCMAKE_C_FLAGS=\"$CFLAGS\" \\\n+          -DCMAKE_CXX_FLAGS=\"$CXXFLAGS\"\n+\n+hide_output make -j$(nproc)\n+cp lib/libunwind.a $OUTPUT/$TARGET/lib\n+cd - && rm -rf libunwind-build"}, {"sha": "c2cf77d56cb3b120c9eb4bddc0128efb70e5610f", "filename": "src/ci/docker/scripts/musl.sh", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fdocker%2Fscripts%2Fmusl.sh", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fdocker%2Fscripts%2Fmusl.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fscripts%2Fmusl.sh?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -22,7 +22,7 @@ shift\n \n export CFLAGS=\"-fPIC $CFLAGS\"\n \n-MUSL=musl-1.1.20\n+MUSL=musl-1.1.22\n \n # may have been downloaded in a previous run\n if [ ! -d $MUSL ]; then"}, {"sha": "194de3c339f8c4ef22ef574214237e1013ac1a2b", "filename": "src/ci/docker/scripts/sccache.sh", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fdocker%2Fscripts%2Fsccache.sh", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fdocker%2Fscripts%2Fsccache.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fscripts%2Fsccache.sh?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -1,8 +1,6 @@\n-# ignore-tidy-linelength\n-\n set -ex\n \n curl -fo /usr/local/bin/sccache \\\n-  https://s3-us-west-1.amazonaws.com/rust-lang-ci2/rust-ci-mirror/2018-04-02-sccache-x86_64-unknown-linux-musl\n+  https://rust-lang-ci2.s3.amazonaws.com/rust-ci-mirror/2018-04-02-sccache-x86_64-unknown-linux-musl\n \n chmod +x /usr/local/bin/sccache"}, {"sha": "6a2600d875642f55588d6c6d3e216beacb4c550c", "filename": "src/ci/docker/test-various/Dockerfile", "status": "modified", "additions": 19, "deletions": 8, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fdocker%2Ftest-various%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fdocker%2Ftest-various%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Ftest-various%2FDockerfile?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -11,19 +11,25 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   cmake \\\n   sudo \\\n   gdb \\\n-  xz-utils\n-\n-# FIXME: build the `ptx-linker` instead.\n-RUN curl -sL https://github.com/denzp/rust-ptx-linker/releases/download/v0.9.0-alpha.2/rust-ptx-linker.linux64.tar.gz | \\\n-  tar -xzvC /usr/bin\n+  libssl-dev \\\n+  pkg-config \\\n+  xz-utils \\\n+  wget \\\n+  patch\n \n RUN curl -sL https://nodejs.org/dist/v9.2.0/node-v9.2.0-linux-x64.tar.xz | \\\n   tar -xJ\n \n+WORKDIR /build/\n+COPY scripts/musl-toolchain.sh /build/\n+RUN bash musl-toolchain.sh x86_64 && rm -rf build\n+WORKDIR /\n+\n COPY scripts/sccache.sh /scripts/\n RUN sh /scripts/sccache.sh\n \n ENV RUST_CONFIGURE_ARGS \\\n+  --musl-root-x86_64=/usr/local/x86_64-linux-musl \\\n   --set build.nodejs=/node-v9.2.0-linux-x64/bin/node \\\n   --set rust.lld\n \n@@ -37,14 +43,19 @@ ENV WASM_TARGETS=wasm32-unknown-unknown\n ENV WASM_SCRIPT python2.7 /checkout/x.py test --target $WASM_TARGETS \\\n   src/test/run-make \\\n   src/test/ui \\\n-  src/test/run-pass \\\n   src/test/compile-fail \\\n   src/test/mir-opt \\\n   src/test/codegen-units \\\n   src/libcore\n \n ENV NVPTX_TARGETS=nvptx64-nvidia-cuda\n ENV NVPTX_SCRIPT python2.7 /checkout/x.py test --target $NVPTX_TARGETS \\\n-  src/test/run-make\n+  src/test/run-make \\\n+  src/test/assembly\n+\n+ENV MUSL_TARGETS=x86_64-unknown-linux-musl \\\n+    CC_x86_64_unknown_linux_musl=x86_64-linux-musl-gcc \\\n+    CXX_x86_64_unknown_linux_musl=x86_64-linux-musl-g++\n+ENV MUSL_SCRIPT python2.7 /checkout/x.py test --target $MUSL_TARGETS\n \n-ENV SCRIPT $WASM_SCRIPT && $NVPTX_SCRIPT\n+ENV SCRIPT $WASM_SCRIPT && $NVPTX_SCRIPT && $MUSL_SCRIPT"}, {"sha": "b2748d9c2ab79696791838f8d063e08f2619fc51", "filename": "src/ci/docker/x86_64-gnu-debug/Dockerfile", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fdocker%2Fx86_64-gnu-debug%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fdocker%2Fx86_64-gnu-debug%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-debug%2FDockerfile?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -1,4 +1,4 @@\n-FROM ubuntu:18.10\n+FROM ubuntu:19.04\n \n RUN apt-get update && apt-get install -y --no-install-recommends \\\n   g++ \\\n@@ -17,6 +17,8 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   cmake \\\n   sudo \\\n   gdb \\\n+  libssl-dev \\\n+  pkg-config \\\n   xz-utils \\\n   lld \\\n   clang\n@@ -31,7 +33,6 @@ ENV RUST_CONFIGURE_ARGS \\\n       --build=x86_64-unknown-linux-gnu \\\n       --enable-debug \\\n       --enable-lld \\\n-      --enable-lldb \\\n       --enable-optimize \\\n       --set llvm.use-linker=lld \\\n       --set target.x86_64-unknown-linux-gnu.linker=clang \\"}, {"sha": "364f45aba2c00442b82b75b3f887f75cde9f1cb5", "filename": "src/ci/docker/x86_64-gnu-distcheck/Dockerfile", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fdocker%2Fx86_64-gnu-distcheck%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fdocker%2Fx86_64-gnu-distcheck%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-distcheck%2FDockerfile?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -21,3 +21,10 @@ RUN sh /scripts/sccache.sh\n ENV RUST_CONFIGURE_ARGS --build=x86_64-unknown-linux-gnu --set rust.ignore-git=false\n ENV SCRIPT python2.7 ../x.py test distcheck\n ENV DIST_SRC 1\n+\n+# The purpose of this builder is to test that we can `./x.py test` successfully\n+# from a tarball, not to test LLVM/rustc's own set of assertions. These cause a\n+# significant hit to CI compile time (over a half hour as observed in #61185),\n+# so disable assertions for this builder.\n+ENV NO_LLVM_ASSERTIONS=1\n+ENV NO_DEBUG_ASSERTIONS=1"}, {"sha": "207f972c3cdae40c5187894068ff7343fe0cb086", "filename": "src/ci/docker/x86_64-gnu-full-bootstrap/Dockerfile", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fdocker%2Fx86_64-gnu-full-bootstrap%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fdocker%2Fx86_64-gnu-full-bootstrap%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-full-bootstrap%2FDockerfile?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -11,6 +11,8 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   cmake \\\n   sudo \\\n   gdb \\\n+  libssl-dev \\\n+  pkg-config \\\n   xz-utils\n \n COPY scripts/sccache.sh /scripts/\n@@ -20,3 +22,9 @@ ENV RUST_CONFIGURE_ARGS \\\n       --build=x86_64-unknown-linux-gnu \\\n       --enable-full-bootstrap\n ENV SCRIPT python2.7 ../x.py build\n+\n+# In general this just slows down the build and we're just a smoke test that\n+# a full bootstrap works in general, so there's not much need to take this\n+# penalty in build times.\n+ENV NO_LLVM_ASSERTIONS 1\n+ENV NO_DEBUG_ASSERTIONS 1"}, {"sha": "6dbbb2203470ba0b5da1c94db33585b239a64743", "filename": "src/ci/docker/x86_64-gnu-llvm-6.0/Dockerfile", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fdocker%2Fx86_64-gnu-llvm-6.0%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fdocker%2Fx86_64-gnu-llvm-6.0%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-llvm-6.0%2FDockerfile?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -13,6 +13,8 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   gdb \\\n   llvm-6.0-tools \\\n   libedit-dev \\\n+  libssl-dev \\\n+  pkg-config \\\n   zlib1g-dev \\\n   xz-utils\n \n@@ -24,4 +26,10 @@ ENV RUST_CONFIGURE_ARGS \\\n       --build=x86_64-unknown-linux-gnu \\\n       --llvm-root=/usr/lib/llvm-6.0 \\\n       --enable-llvm-link-shared\n-ENV RUST_CHECK_TARGET check\n+ENV SCRIPT python2.7 ../x.py test src/tools/tidy && python2.7 ../x.py test\n+\n+# The purpose of this container isn't to test with debug assertions and\n+# this is run on all PRs, so let's get speedier builds by disabling these extra\n+# checks.\n+ENV NO_DEBUG_ASSERTIONS=1\n+ENV NO_LLVM_ASSERTIONS=1"}, {"sha": "6a5c7f5d9e6103c34e51b33903c282bef4f444eb", "filename": "src/ci/docker/x86_64-gnu-nopt/Dockerfile", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fdocker%2Fx86_64-gnu-nopt%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fdocker%2Fx86_64-gnu-nopt%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-nopt%2FDockerfile?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -11,6 +11,8 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   cmake \\\n   sudo \\\n   gdb \\\n+  libssl-dev \\\n+  pkg-config \\\n   xz-utils\n \n COPY scripts/sccache.sh /scripts/\n@@ -19,4 +21,4 @@ RUN sh /scripts/sccache.sh\n ENV RUST_CONFIGURE_ARGS --build=x86_64-unknown-linux-gnu \\\n   --disable-optimize-tests \\\n   --set rust.test-compare-mode\n-ENV RUST_CHECK_TARGET check\n+ENV SCRIPT python2.7 ../x.py test"}, {"sha": "f11ae7a34cb91fcd45c4f6af30f5e6e9f0c1c6eb", "filename": "src/ci/docker/x86_64-gnu-tools/Dockerfile", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2FDockerfile?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -23,6 +23,5 @@ COPY x86_64-gnu-tools/repo.sh /tmp/\n \n ENV RUST_CONFIGURE_ARGS \\\n   --build=x86_64-unknown-linux-gnu \\\n-  --enable-test-miri \\\n   --save-toolstates=/tmp/toolstates.json\n ENV SCRIPT /tmp/checktools.sh ../x.py /tmp/toolstates.json linux"}, {"sha": "4fbb8c4d2034900dda85f48c5d4afa55b2834c4f", "filename": "src/ci/docker/x86_64-gnu-tools/checkregression.py", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2Fcheckregression.py", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2Fcheckregression.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2Fcheckregression.py?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -1,9 +1,18 @@\n #!/usr/bin/env python\n # -*- coding: utf-8 -*-\n \n+## This script has two purposes: detect any tool that *regressed*, which is used\n+## during the week before the beta branches to reject PRs; and detect any tool\n+## that *changed* to see if we need to update the toolstate repo.\n+\n import sys\n import json\n \n+# Regressions for these tools during the beta cutoff week do not cause failure.\n+# See `status_check` in `checktools.sh` for tools that have to pass on the\n+# beta/stable branches.\n+REGRESSION_OK = [\"rustc-guide\", \"miri\", \"embedded-book\"]\n+\n if __name__ == '__main__':\n     os_name = sys.argv[1]\n     toolstate_file = sys.argv[2]\n@@ -32,7 +41,8 @@\n                 'The state of \"{}\" has {} from \"{}\" to \"{}\"'\n                 .format(tool, verb, state, new_state)\n             )\n-            regressed = True\n+            if not (verb == 'regressed' and tool in REGRESSION_OK):\n+                regressed = True\n \n     if regressed:\n         sys.exit(1)"}, {"sha": "4243effdf9b4b22074af2022a0e49feb53d62580", "filename": "src/ci/docker/x86_64-gnu-tools/checktools.sh", "status": "modified", "additions": 30, "deletions": 8, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2Fchecktools.sh", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2Fchecktools.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2Fchecktools.sh?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -24,6 +24,8 @@ python2.7 \"$X_PY\" test --no-fail-fast \\\n     src/doc/reference \\\n     src/doc/rust-by-example \\\n     src/doc/embedded-book \\\n+    src/doc/edition-guide \\\n+    src/doc/rustc-guide \\\n     src/tools/clippy \\\n     src/tools/rls \\\n     src/tools/rustfmt \\\n@@ -34,12 +36,17 @@ set -e\n cat \"$TOOLSTATE_FILE\"\n echo\n \n+# This function checks if a particular tool is *not* in status \"test-pass\".\n+check_tool_failed() {\n+    grep -vq '\"'\"$1\"'\":\"test-pass\"' \"$TOOLSTATE_FILE\"\n+}\n+\n # This function checks that if a tool's submodule changed, the tool's state must improve\n-verify_status() {\n+verify_submodule_changed() {\n     echo \"Verifying status of $1...\"\n     if echo \"$CHANGED_FILES\" | grep -q \"^M[[:blank:]]$2$\"; then\n         echo \"This PR updated '$2', verifying if status is 'test-pass'...\"\n-        if grep -vq '\"'\"$1\"'\":\"test-pass\"' \"$TOOLSTATE_FILE\"; then\n+        if check_tool_failed \"$1\"; then\n             echo\n             echo \"\u26a0\ufe0f We detected that this PR updated '$1', but its tests failed.\"\n             echo\n@@ -54,30 +61,43 @@ verify_status() {\n     fi\n }\n \n-# deduplicates the submodule check and the assertion that on beta some tools MUST be passing\n+# deduplicates the submodule check and the assertion that on beta some tools MUST be passing.\n+# $1 should be \"submodule_changed\" to only check tools that got changed by this PR,\n+# or \"beta_required\" to check all tools that have $2 set to \"beta\".\n check_dispatch() {\n     if [ \"$1\" = submodule_changed ]; then\n         # ignore $2 (branch id)\n-        verify_status $3 $4\n+        verify_submodule_changed $3 $4\n     elif [ \"$2\" = beta ]; then\n         echo \"Requiring test passing for $3...\"\n-        if grep -q '\"'\"$3\"'\":\"\\(test\\|build\\)-fail\"' \"$TOOLSTATE_FILE\"; then\n+        if check_tool_failed \"$3\"; then\n             exit 4\n         fi\n     fi\n }\n \n-# list all tools here\n+# List all tools here.\n+# This function gets called with \"submodule_changed\" for each PR that changed a submodule,\n+# and with \"beta_required\" for each PR that lands on beta/stable.\n+# The purpose of this function is to *reject* PRs if a tool is not \"test-pass\" and\n+# (a) the tool's submodule has been updated, or (b) we landed on beta/stable and the\n+# tool has to \"test-pass\" on that branch.\n status_check() {\n     check_dispatch $1 beta book src/doc/book\n     check_dispatch $1 beta nomicon src/doc/nomicon\n     check_dispatch $1 beta reference src/doc/reference\n     check_dispatch $1 beta rust-by-example src/doc/rust-by-example\n+    check_dispatch $1 beta edition-guide src/doc/edition-guide\n     check_dispatch $1 beta rls src/tools/rls\n     check_dispatch $1 beta rustfmt src/tools/rustfmt\n     check_dispatch $1 beta clippy-driver src/tools/clippy\n-    # these tools are not required for beta to successfully branch\n+    # These tools are not required on the beta/stable branches, but they *do* cause\n+    # PRs to fail if a submodule update does not fix them.\n+    # They will still cause failure during the beta cutoff week, unless `checkregression.py`\n+    # exempts them from that.\n     check_dispatch $1 nightly miri src/tools/miri\n+    check_dispatch $1 nightly embedded-book src/doc/embedded-book\n+    check_dispatch $1 nightly rustc-guide src/doc/rustc-guide\n }\n \n # If this PR is intended to update one of these tools, do not let the build pass\n@@ -86,12 +106,14 @@ status_check() {\n status_check \"submodule_changed\"\n \n CHECK_NOT=\"$(readlink -f \"$(dirname $0)/checkregression.py\")\"\n+# This callback is called by `commit_toolstate_change`, see `repo.sh`.\n change_toolstate() {\n     # only update the history\n     if python2.7 \"$CHECK_NOT\" \"$OS\" \"$TOOLSTATE_FILE\" \"_data/latest.json\" changed; then\n         echo 'Toolstate is not changed. Not updating.'\n     else\n         if [ $SIX_WEEK_CYCLE -ge 35 ]; then\n+            # Reject any regressions during the week before beta cutoff.\n             python2.7 \"$CHECK_NOT\" \"$OS\" \"$TOOLSTATE_FILE\" \"_data/latest.json\" regressed\n         fi\n         sed -i \"1 a\\\\\n@@ -101,7 +123,7 @@ $COMMIT\\t$(cat \"$TOOLSTATE_FILE\")\n }\n \n if [ \"$RUST_RELEASE_CHANNEL\" = nightly ]; then\n-    if [ -n \"${TOOLSTATE_REPO_ACCESS_TOKEN+is_set}\" ]; then\n+    if [ -n \"${TOOLSTATE_PUBLISH+is_set}\" ]; then\n         . \"$(dirname $0)/repo.sh\"\n         MESSAGE_FILE=$(mktemp -t msg.XXXXXX)\n         echo \"($OS CI update)\" > \"$MESSAGE_FILE\""}, {"sha": "82700a00fb6af61e398dcceb7e3700cba8568af3", "filename": "src/ci/docker/x86_64-gnu-tools/repo.sh", "status": "modified", "additions": 12, "deletions": 24, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2Frepo.sh", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2Frepo.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu-tools%2Frepo.sh?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -5,8 +5,8 @@\n #\n # The function relies on a GitHub bot user, which should have a Personal access\n # token defined in the environment variable $TOOLSTATE_REPO_ACCESS_TOKEN. If for\n-# some reason you need to change the token, please update `.travis.yml` and\n-# `appveyor.yml`:\n+# some reason you need to change the token, please update the Azure Pipelines\n+# variable group.\n #\n #   1. Generate a new Personal access token:\n #\n@@ -18,28 +18,9 @@\n #           Save it somewhere secure, as the token would be gone once you leave\n #           the page.\n #\n-#   2. Encrypt the token for Travis CI\n+#   2. Update the variable group in Azure Pipelines\n #\n-#       * Install the `travis` tool locally (`gem install travis`).\n-#       * Encrypt the token:\n-#           ```\n-#           travis -r rust-lang/rust encrypt \\\n-#                   TOOLSTATE_REPO_ACCESS_TOKEN=aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n-#           ```\n-#       * Copy output to replace the existing one in `.travis.yml`.\n-#       * Details of this step can be found in\n-#           <https://docs.travis-ci.com/user/encryption-keys/>\n-#\n-#   3. Encrypt the token for AppVeyor\n-#\n-#       * Login to AppVeyor using your main account, and login as the rust-lang\n-#           organization.\n-#       * Open the [\"Encrypt data\" tool](https://ci.appveyor.com/tools/encrypt)\n-#       * Paste the 40-digit token into the \"Value to encrypt\" box, then click\n-#           \"Encrypt\"\n-#       * Copy the output to replace the existing one in `appveyor.yml`.\n-#       * Details of this step can be found in\n-#           <https://www.appveyor.com/docs/how-to/git-push/>\n+#       * Ping a member of the infrastructure team to do this.\n #\n #   4. Replace the email address below if the bot account identity is changed\n #\n@@ -55,13 +36,20 @@ commit_toolstate_change() {\n     git config --global credential.helper store\n     printf 'https://%s:x-oauth-basic@github.com\\n' \"$TOOLSTATE_REPO_ACCESS_TOKEN\" \\\n         > \"$HOME/.git-credentials\"\n-    git clone --depth=1 https://github.com/rust-lang-nursery/rust-toolstate.git\n+    git clone --depth=1 $TOOLSTATE_REPO\n \n     cd rust-toolstate\n     FAILURE=1\n     MESSAGE_FILE=\"$1\"\n     shift\n     for RETRY_COUNT in 1 2 3 4 5; do\n+        # Call the callback.\n+        # - If we are in the `auto` branch (pre-landing), this is called from `checktools.sh` and\n+        #   the callback is `change_toolstate` in that file. The purpose of this is to publish the\n+        #   test results (the new commit-to-toolstate mapping) in the toolstate repo.\n+        # - If we are in the `master` branch (post-landing), this is called by the CI pipeline\n+        #   and the callback is `src/tools/publish_toolstate.py`. The purpose is to publish\n+        #   the new \"current\" toolstate in the toolstate repo.\n         \"$@\"\n         # `git commit` failing means nothing to commit.\n         FAILURE=0"}, {"sha": "4ec4364721393691ced50f59359f95aa82e2bb20", "filename": "src/ci/docker/x86_64-gnu/Dockerfile", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fdocker%2Fx86_64-gnu%2FDockerfile", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fdocker%2Fx86_64-gnu%2FDockerfile", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fdocker%2Fx86_64-gnu%2FDockerfile?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -1,4 +1,4 @@\n-FROM ubuntu:18.10\n+FROM ubuntu:19.04\n \n RUN apt-get update && apt-get install -y --no-install-recommends \\\n   g++ \\\n@@ -11,6 +11,8 @@ RUN apt-get update && apt-get install -y --no-install-recommends \\\n   cmake \\\n   sudo \\\n   gdb \\\n+  libssl-dev \\\n+  pkg-config \\\n   xz-utils\n \n COPY scripts/sccache.sh /scripts/"}, {"sha": "c7c3b0a5fbf5b0733064b0a46695e8f9a80c80ff", "filename": "src/ci/init_repo.sh", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Finit_repo.sh", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Finit_repo.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Finit_repo.sh?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -1,15 +1,16 @@\n #!/usr/bin/env bash\n \n+# FIXME(61301): we need to debug spurious failures with this on Windows on\n+# Azure, so let's print more information in the logs.\n+set -x\n+\n set -o errexit\n set -o pipefail\n set -o nounset\n \n ci_dir=$(cd $(dirname $0) && pwd)\n . \"$ci_dir/shared.sh\"\n \n-travis_fold start init_repo\n-travis_time_start\n-\n REPO_DIR=\"$1\"\n CACHE_DIR=\"$2\"\n \n@@ -69,5 +70,3 @@ retry sh -c \"git submodule deinit -f $use_git && \\\n     git submodule sync && \\\n     git submodule update -j 16 --init --recursive $use_git\"\n wait\n-travis_fold end init_repo\n-travis_time_finish"}, {"sha": "d491b9fbcdcf81a6ae67ac5496fe05b5f8635fb2", "filename": "src/ci/install-awscli.sh", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Finstall-awscli.sh", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Finstall-awscli.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Finstall-awscli.sh?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -0,0 +1,35 @@\n+#!/bin/bash\n+# This script downloads and installs awscli from the packages mirrored in our\n+# own S3 bucket. This follows the recommendations at:\n+#\n+#    https://packaging.python.org/guides/index-mirrors-and-caches/#caching-with-pip\n+#\n+# To create a new mirrored copy you can run the command:\n+#\n+#    pip wheel awscli\n+#\n+# Before compressing please make sure all the wheels end with `-none-any.whl`.\n+# If that's not the case you'll need to remove the non-cross-platform ones and\n+# replace them with the .tar.gz downloaded from https://pypi.org. Also make\n+# sure it's possible to call this script with both Python 2 and Python 3.\n+\n+set -euo pipefail\n+IFS=$'\\n\\t'\n+\n+MIRROR=\"https://rust-lang-ci2.s3.amazonaws.com/rust-ci-mirror/2019-07-27-awscli.tar\"\n+DEPS_DIR=\"/tmp/awscli-deps\"\n+\n+pip=\"pip\"\n+pipflags=\"\"\n+if [[ \"${AGENT_OS}\" == \"Linux\" ]]; then\n+    pip=\"pip3\"\n+    pipflags=\"--user\"\n+\n+    sudo apt-get install -y python3-setuptools\n+    echo \"##vso[task.prependpath]$HOME/.local/bin\"\n+fi\n+\n+mkdir -p \"${DEPS_DIR}\"\n+curl \"${MIRROR}\" | tar xf - -C \"${DEPS_DIR}\"\n+\"${pip}\" install ${pipflags} --no-index \"--find-links=${DEPS_DIR}\" awscli\n+rm -rf \"${DEPS_DIR}\""}, {"sha": "f1eb417cdf98236b76c3bd02bc89f53eb4b070f8", "filename": "src/ci/run.sh", "status": "modified", "additions": 8, "deletions": 23, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Frun.sh", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Frun.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Frun.sh?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -23,7 +23,9 @@ fi\n ci_dir=`cd $(dirname $0) && pwd`\n source \"$ci_dir/shared.sh\"\n \n-if [ \"$TRAVIS\" != \"true\" ] || [ \"$TRAVIS_BRANCH\" == \"auto\" ]; then\n+branch_name=$(getCIBranch)\n+\n+if [ ! isCI ] || [ \"$branch_name\" = \"auto\" ] || [ \"$branch_name\" = \"try\" ]; then\n     RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --set build.print-step-timings --enable-verbose-tests\"\n fi\n \n@@ -44,10 +46,11 @@ fi\n # FIXME: need a scheme for changing this `nightly` value to `beta` and `stable`\n #        either automatically or manually.\n export RUST_RELEASE_CHANNEL=nightly\n-if [ \"$DEPLOY$DEPLOY_ALT\" != \"\" ]; then\n+if [ \"$DEPLOY$DEPLOY_ALT\" = \"1\" ]; then\n   RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --release-channel=$RUST_RELEASE_CHANNEL\"\n   RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --enable-llvm-static-stdcpp\"\n   RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --set rust.remap-debuginfo\"\n+  RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --debuginfo-level-std=1\"\n \n   if [ \"$NO_LLVM_ASSERTIONS\" = \"1\" ]; then\n     RUST_CONFIGURE_ARGS=\"$RUST_CONFIGURE_ARGS --disable-llvm-assertions\"\n@@ -88,28 +91,15 @@ if [ \"$RUN_CHECK_WITH_PARALLEL_QUERIES\" != \"\" ]; then\n   rm -rf build\n fi\n \n-travis_fold start configure\n-travis_time_start\n $SRC/configure $RUST_CONFIGURE_ARGS\n-travis_fold end configure\n-travis_time_finish\n \n-travis_fold start make-prepare\n-travis_time_start\n retry make prepare\n-travis_fold end make-prepare\n-travis_time_finish\n \n-travis_fold start check-bootstrap\n-travis_time_start\n make check-bootstrap\n-travis_fold end check-bootstrap\n-travis_time_finish\n \n # Display the CPU and memory information. This helps us know why the CI timing\n # is fluctuating.\n-travis_fold start log-system-info\n-if [ \"$TRAVIS_OS_NAME\" = \"osx\" ]; then\n+if isOSX; then\n     system_profiler SPHardwareDataType || true\n     sysctl hw || true\n     ncpus=$(sysctl -n hw.ncpu)\n@@ -118,23 +108,18 @@ else\n     cat /proc/meminfo || true\n     ncpus=$(grep processor /proc/cpuinfo | wc -l)\n fi\n-travis_fold end log-system-info\n \n if [ ! -z \"$SCRIPT\" ]; then\n   sh -x -c \"$SCRIPT\"\n else\n   do_make() {\n-    travis_fold start \"make-$1\"\n-    travis_time_start\n     echo \"make -j $ncpus $1\"\n     make -j $ncpus $1\n     local retval=$?\n-    travis_fold end \"make-$1\"\n-    travis_time_finish\n     return $retval\n   }\n \n-  do_make tidy\n-  do_make all\n   do_make \"$RUST_CHECK_TARGET\"\n fi\n+\n+sccache --show-stats || true"}, {"sha": "b093a07ec5c5aac8f116a21ee571b14c3fa8208a", "filename": "src/ci/shared.sh", "status": "modified", "additions": 11, "deletions": 33, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fshared.sh", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fci%2Fshared.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fci%2Fshared.sh?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -24,36 +24,14 @@ function retry {\n   done\n }\n \n-if ! declare -F travis_fold; then\n-  if [ \"${TRAVIS-false}\" = 'true' ]; then\n-    # This is a trimmed down copy of\n-    # https://github.com/travis-ci/travis-build/blob/master/lib/travis/build/templates/header.sh\n-    travis_fold() {\n-      echo -en \"travis_fold:$1:$2\\r\\033[0K\"\n-    }\n-    travis_time_start() {\n-      travis_timer_id=$(printf %08x $(( RANDOM * RANDOM )))\n-      travis_start_time=$(travis_nanoseconds)\n-      echo -en \"travis_time:start:$travis_timer_id\\r\\033[0K\"\n-    }\n-    travis_time_finish() {\n-      travis_end_time=$(travis_nanoseconds)\n-      local duration=$(($travis_end_time-$travis_start_time))\n-      local msg=\"travis_time:end:$travis_timer_id\"\n-      echo -en \"\\n$msg:start=$travis_start_time,finish=$travis_end_time,duration=$duration\\r\\033[0K\"\n-    }\n-    if [ $(uname) = 'Darwin' ]; then\n-      travis_nanoseconds() {\n-        date -u '+%s000000000'\n-      }\n-    else\n-      travis_nanoseconds() {\n-        date -u '+%s%N'\n-      }\n-    fi\n-  else\n-    travis_fold() { return 0; }\n-    travis_time_start() { return 0; }\n-    travis_time_finish() { return 0; }\n-  fi\n-fi\n+function isCI {\n+  [ \"$CI\" = \"true\" ] || [ \"$TF_BUILD\" = \"True\" ]\n+}\n+\n+function isOSX {\n+  [ \"$AGENT_OS\" = \"Darwin\" ]\n+}\n+\n+function getCIBranch {\n+  echo \"$BUILD_SOURCEBRANCHNAME\"\n+}"}, {"sha": "7ddc46460f09a5cd9bd2a620565bdc20b3315ea9", "filename": "src/doc/book", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fbook?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -1 +1 @@\n-Subproject commit 9cffbeabec3bcec42d09432bfe7705125c848889\n+Subproject commit 7ddc46460f09a5cd9bd2a620565bdc20b3315ea9"}, {"sha": "e58bc4ca104e890ac56af846877c874c432a64b5", "filename": "src/doc/edition-guide", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fedition-guide?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -1 +1 @@\n-Subproject commit aa0022c875907886cae8f3ef8e9ebf6e2a5e728d\n+Subproject commit e58bc4ca104e890ac56af846877c874c432a64b5"}, {"sha": "c5da1e11915d3f28266168baaf55822f7e3fe999", "filename": "src/doc/embedded-book", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fembedded-book?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -1 +1 @@\n-Subproject commit 9e656ead82bfe869493dec82653a52e27fa6a05c\n+Subproject commit c5da1e11915d3f28266168baaf55822f7e3fe999"}, {"sha": "3788e3c864e820ed22556caccb32953fdd651c2a", "filename": "src/doc/man/rustc.1", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fdoc%2Fman%2Frustc.1", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fdoc%2Fman%2Frustc.1", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fman%2Frustc.1?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -261,12 +261,12 @@ full debug info with variable and type information.\n .RE\n .TP\n \\fBopt\\-level\\fR=\\fIVAL\\fR\n-Optimize with possible levels 0\\[en]3\n+Optimize with possible levels 0\\[en]3, s (optimize for size), or z (for minimal size)\n \n .SH ENVIRONMENT\n \n-Some of these affect the output of the compiler, while others affect programs\n-which link to the standard library.\n+Some of these affect only test harness programs (generated via rustc --test);\n+others affect all programs which link to the Rust standard library.\n \n .TP\n \\fBRUST_TEST_THREADS\\fR"}, {"sha": "8a7d05615e5bc0a7fb961b4919c44f5221ee54da", "filename": "src/doc/nomicon", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fnomicon?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -1 +1 @@\n-Subproject commit f1ff93b66844493a7b03101c7df66ac958c62418\n+Subproject commit 8a7d05615e5bc0a7fb961b4919c44f5221ee54da"}, {"sha": "33e3860c2a4340ba428e789a980bafeeb7982b02", "filename": "src/doc/redirect.inc", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fdoc%2Fredirect.inc", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fdoc%2Fredirect.inc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Fredirect.inc?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -0,0 +1,2 @@\n+<meta name=\"robots\" content=\"noindex,follow\">\n+<link rel=\"shortcut icon\" href=\"https://www.rust-lang.org/favicon.ico\">"}, {"sha": "b4b3536839042a6743fc76f0d9ad2a812020aeaa", "filename": "src/doc/reference", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Freference?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -1 +1 @@\n-Subproject commit 41493ffce5d0e17d54eaf5ec9a995054e2b9aece\n+Subproject commit b4b3536839042a6743fc76f0d9ad2a812020aeaa"}, {"sha": "61ee12739fb37426603b65e857060f03aefb3434", "filename": "src/doc/robots.txt", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fdoc%2Frobots.txt", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fdoc%2Frobots.txt", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frobots.txt?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -0,0 +1,27 @@\n+# NB: This file is not automatically deployed. After changes, it needs to be uploaded manually to doc.rust-lang.org\n+User-agent: *\n+Disallow: /0.3/\n+Disallow: /0.4/\n+Disallow: /0.5/\n+Disallow: /0.6/\n+Disallow: /0.7/\n+Disallow: /0.8/\n+Disallow: /0.9/\n+Disallow: /0.10/\n+Disallow: /0.11.0/\n+Disallow: /0.12.0/\n+Disallow: /1.0.0-alpha/\n+Disallow: /1.0.0-alpha.2/\n+Disallow: /1.0.0-beta/\n+Disallow: /1.0.0-beta.2/\n+Disallow: /1.0.0-beta.3/\n+Disallow: /1.0.0-beta.4/\n+Disallow: /1.0.0-beta.5/\n+Disallow: /book/first-edition/\n+Disallow: /book/second-edition/\n+Disallow: /stable/book/first-edition/\n+Disallow: /stable/book/second-edition/\n+Disallow: /beta/book/first-edition/\n+Disallow: /beta/book/second-edition/\n+Disallow: /nightly/book/first-edition/\n+Disallow: /nightly/book/second-edition/"}, {"sha": "f2c15ba5ee89ae9469a2cf60494977749901d764", "filename": "src/doc/rust-by-example", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust-by-example?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -1 +1 @@\n-Subproject commit 2ce92beabb912d417a7314d6da83ac9b50dc2afb\n+Subproject commit f2c15ba5ee89ae9469a2cf60494977749901d764"}, {"sha": "a92d4ff54db837a6e64dd260d66b3bc5e2e60f43", "filename": "src/doc/rust.css", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fdoc%2Frust.css", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fdoc%2Frust.css", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frust.css?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -14,19 +14,19 @@\n \tfont-family: 'Source Serif Pro';\n \tfont-style: normal;\n \tfont-weight: 400;\n-\tsrc: local('Source Serif Pro'), url(\"SourceSerifPro-Regular.woff\") format('woff');\n+\tsrc: local('Source Serif Pro'), url(\"SourceSerifPro-Regular.ttf.woff\") format('woff');\n }\n @font-face {\n \tfont-family: 'Source Serif Pro';\n \tfont-style: italic;\n \tfont-weight: 400;\n-\tsrc: url(\"Heuristica-Italic.woff\") format('woff');\n+\tsrc: url(\"SourceSerifPro-It.ttf.woff\") format('woff');\n }\n @font-face {\n \tfont-family: 'Source Serif Pro';\n \tfont-style: normal;\n \tfont-weight: 700;\n-\tsrc: local('Source Serif Pro Bold'), url(\"SourceSerifPro-Bold.woff\") format('woff');\n+\tsrc: local('Source Serif Pro Bold'), url(\"SourceSerifPro-Bold.ttf.woff\") format('woff');\n }\n @font-face {\n \tfont-family: 'Source Code Pro';"}, {"sha": "6f4ba673ff9d4613e98415bc095347a6a0031e9c", "filename": "src/doc/rustc-guide", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": null, "raw_url": null, "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc-guide?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -1 +1 @@\n-Subproject commit 344c4e437ba4cfa5c14db643ec4d6b68dcd164c5\n+Subproject commit 6f4ba673ff9d4613e98415bc095347a6a0031e9c"}, {"sha": "e3684fc9f320a7c400f0d09f69873c283ff2b4eb", "filename": "src/doc/rustc-ux-guidelines.md", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fdoc%2Frustc-ux-guidelines.md", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fdoc%2Frustc-ux-guidelines.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc-ux-guidelines.md?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -61,17 +61,17 @@ for details on how to format and write long error codes.\n \n * All of them are accessible [online](http://doc.rust-lang.org/error-index.html),\n   which are auto-generated from rustc source code in different places:\n-  [librustc](https://github.com/rust-lang/rust/blob/master/src/librustc/diagnostics.rs),\n-  [libsyntax](https://github.com/rust-lang/rust/blob/master/src/libsyntax/diagnostics.rs),\n-  [librustc_borrowck](https://github.com/rust-lang/rust/blob/master/src/librustc_borrowck/diagnostics.rs),\n-  [librustc_metadata](https://github.com/rust-lang/rust/blob/master/src/librustc_metadata/diagnostics.rs),\n-  [librustc_mir](https://github.com/rust-lang/rust/blob/master/src/librustc_mir/diagnostics.rs),\n-  [librustc_passes](https://github.com/rust-lang/rust/blob/master/src/librustc_passes/diagnostics.rs),\n-  [librustc_privacy](https://github.com/rust-lang/rust/blob/master/src/librustc_privacy/diagnostics.rs),\n-  [librustc_resolve](https://github.com/rust-lang/rust/blob/master/src/librustc_resolve/diagnostics.rs),\n-  [librustc_codegen_llvm](https://github.com/rust-lang/rust/blob/master/src/librustc_codegen_llvm/diagnostics.rs),\n-  [librustc_plugin](https://github.com/rust-lang/rust/blob/master/src/librustc_plugin/diagnostics.rs),\n-  [librustc_typeck](https://github.com/rust-lang/rust/blob/master/src/librustc_typeck/diagnostics.rs).\n+  [librustc](https://github.com/rust-lang/rust/blob/master/src/librustc/error_codes.rs),\n+  [libsyntax](https://github.com/rust-lang/rust/blob/master/src/libsyntax/error_codes.rs),\n+  [librustc_borrowck](https://github.com/rust-lang/rust/blob/master/src/librustc_borrowck/error_codes.rs),\n+  [librustc_metadata](https://github.com/rust-lang/rust/blob/master/src/librustc_metadata/error_codes.rs),\n+  [librustc_mir](https://github.com/rust-lang/rust/blob/master/src/librustc_mir/error_codes.rs),\n+  [librustc_passes](https://github.com/rust-lang/rust/blob/master/src/librustc_passes/error_codes.rs),\n+  [librustc_privacy](https://github.com/rust-lang/rust/blob/master/src/librustc_privacy/error_codes.rs),\n+  [librustc_resolve](https://github.com/rust-lang/rust/blob/master/src/librustc_resolve/error_codes.rs),\n+  [librustc_codegen_llvm](https://github.com/rust-lang/rust/blob/master/src/librustc_codegen_llvm/error_codes.rs),\n+  [librustc_plugin](https://github.com/rust-lang/rust/blob/master/src/librustc_plugin/error_codes.rs),\n+  [librustc_typeck](https://github.com/rust-lang/rust/blob/master/src/librustc_typeck/error_codes.rs).\n * Explanations have full markdown support. Use it, especially to highlight\n code with backticks.\n * When talking about the compiler, call it `the compiler`, not `Rust` or"}, {"sha": "3cda8d927973ca64c7210d37ecd750093f838ca7", "filename": "src/doc/rustc/src/SUMMARY.md", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fdoc%2Frustc%2Fsrc%2FSUMMARY.md", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fdoc%2Frustc%2Fsrc%2FSUMMARY.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2FSUMMARY.md?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -13,5 +13,6 @@\n - [Targets](targets/index.md)\n     - [Built-in Targets](targets/built-in.md)\n     - [Custom Targets](targets/custom.md)\n+- [Profile-guided Optimization](profile-guided-optimization.md)\n - [Linker-plugin based LTO](linker-plugin-lto.md)\n - [Contributing to `rustc`](contributing.md)"}, {"sha": "5c41acc6581c5ae04564187de3a84b6ad072b26a", "filename": "src/doc/rustc/src/codegen-options/index.md", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fdoc%2Frustc%2Fsrc%2Fcodegen-options%2Findex.md", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fdoc%2Frustc%2Fsrc%2Fcodegen-options%2Findex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fcodegen-options%2Findex.md?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -214,3 +214,20 @@ This option lets you control what happens when the code panics.\n ## incremental\n \n This flag allows you to enable incremental compilation.\n+\n+## profile-generate\n+\n+This flag allows for creating instrumented binaries that will collect\n+profiling data for use with profile-guided optimization (PGO). The flag takes\n+an optional argument which is the path to a directory into which the\n+instrumented binary will emit the collected data. See the chapter on\n+[profile-guided optimization] for more information.\n+\n+## profile-use\n+\n+This flag specifies the profiling data file to be used for profile-guided\n+optimization (PGO). The flag takes a mandatory argument which is the path\n+to a valid `.profdata` file. See the chapter on\n+[profile-guided optimization] for more information.\n+\n+[profile-guided optimization]: ../profile-guided-optimization.md"}, {"sha": "d774e465118b3d520be86a402fc64466b214a5c1", "filename": "src/doc/rustc/src/command-line-arguments.md", "status": "modified", "additions": 205, "deletions": 20, "changes": 225, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fdoc%2Frustc%2Fsrc%2Fcommand-line-arguments.md", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fdoc%2Frustc%2Fsrc%2Fcommand-line-arguments.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fcommand-line-arguments.md?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -17,44 +17,164 @@ to `#[cfg(verbose)]` and `#[cfg(feature = \"serde\")]` respectively.\n \n ## `-L`: add a directory to the library search path\n \n-When looking for external crates, a directory passed to this flag will be searched.\n+When looking for external crates or libraries, a directory passed to this flag\n+will be searched.\n+\n+The kind of search path can optionally be specified with the form `-L\n+KIND=PATH` where `KIND` may be one of:\n+\n+- `dependency` \u2014\u00a0Only search for transitive dependencies in this directory.\n+- `crate` \u2014\u00a0Only search for this crate's direct dependencies in this\n+  directory.\n+- `native` \u2014 Only search for native libraries in this directory.\n+- `framework` \u2014\u00a0Only search for macOS frameworks in this directory.\n+- `all` \u2014\u00a0Search for all library kinds in this directory. This is the default\n+  if `KIND` is not specified.\n \n ## `-l`: link the generated crate to a native library\n \n This flag allows you to specify linking to a specific native library when building\n a crate.\n \n+The kind of library can optionally be specified with the form `-l KIND=lib`\n+where `KIND` may be one of:\n+\n+- `dylib` \u2014\u00a0A native dynamic library.\n+- `static` \u2014\u00a0A native static library (such as a `.a` archive).\n+- `framework` \u2014\u00a0A macOS framework.\n+\n+The kind of library can be specified in a [`#[link]`\n+attribute][link-attribute]. If the kind is not specified in the `link`\n+attribute or on the command-line, it will link a dynamic library if available,\n+otherwise it will use a static library. If the kind is specified on the\n+command-line, it will override the kind specified in a `link` attribute.\n+\n+The name used in a `link` attribute may be overridden using the form `-l\n+ATTR_NAME:LINK_NAME` where `ATTR_NAME` is the name in the `link` attribute,\n+and `LINK_NAME` is the name of the actual library that will be linked.\n+\n+[link-attribute]: ../reference/items/external-blocks.html#the-link-attribute\n+\n ## `--crate-type`: a list of types of crates for the compiler to emit\n \n-This instructs `rustc` on which crate type to build.\n+This instructs `rustc` on which crate type to build. This flag accepts a\n+comma-separated list of values, and may be specified multiple times. The valid\n+crate types are:\n+\n+- `lib` \u2014 Generates a library kind preferred by the compiler, currently\n+  defaults to `rlib`.\n+- `rlib` \u2014 A Rust static library.\n+- `staticlib` \u2014 A native static library.\n+- `dylib` \u2014 A Rust dynamic library.\n+- `cdylib` \u2014 A native dynamic library.\n+- `bin` \u2014 A runnable executable program.\n+- `proc-macro` \u2014 Generates a format suitable for a procedural macro library\n+  that may be loaded by the compiler.\n+\n+The crate type may be specified with the [`crate_type` attribute][crate_type].\n+The `--crate-type` command-line value will override the `crate_type`\n+attribute.\n+\n+More details may be found in the [linkage chapter] of the reference.\n+\n+[linkage chapter]: ../reference/linkage.html\n+[crate_type]: ../reference/linkage.html\n \n ## `--crate-name`: specify the name of the crate being built\n \n This informs `rustc` of the name of your crate.\n \n-## `--emit`: emit output other than a crate\n-\n-Instead of producing a crate, this flag can print out things like the assembly or LLVM-IR.\n+## `--edition`: specify the edition to use\n+\n+This flag takes a value of `2015` or `2018`. The default is `2015`. More\n+information about editions may be found in the [edition guide].\n+\n+[edition guide]: ../edition-guide/introduction.html\n+\n+## `--emit`: specifies the types of output files to generate\n+\n+This flag controls the types of output files generated by the compiler. It\n+accepts a comma-separated list of values, and may be specified multiple times.\n+The valid emit kinds are:\n+\n+- `asm` \u2014 Generates a file with the crate's assembly code. The default output\n+  filename is `CRATE_NAME.s`.\n+- `dep-info` \u2014 Generates a file with Makefile syntax that indicates all the\n+  source files that were loaded to generate the crate. The default output\n+  filename is `CRATE_NAME.d`.\n+- `link` \u2014 Generates the crates specified by `--crate-type`. The default\n+  output filenames depend on the crate type and platform. This is the default\n+  if `--emit` is not specified.\n+- `llvm-bc` \u2014 Generates a binary file containing the [LLVM bitcode]. The\n+  default output filename is `CRATE_NAME.bc`.\n+- `llvm-ir` \u2014 Generates a file containing [LLVM IR]. The default output\n+  filename is `CRATE_NAME.ll`.\n+- `metadata` \u2014 Generates a file containing metadata about the crate. The\n+  default output filename is `CRATE_NAME.rmeta`.\n+- `mir` \u2014 Generates a file containing rustc's mid-level intermediate\n+  representation. The default output filename is `CRATE_NAME.mir`.\n+- `obj` \u2014 Generates a native object file. The default output filename is\n+  `CRATE_NAME.o`.\n+\n+The output filename can be set with the `-o` flag. A suffix may be added to\n+the filename with the `-C extra-filename` flag. The files are written to the\n+current directory unless the `--out-dir` flag is used. Each emission type may\n+also specify the output filename with the form `KIND=PATH`, which takes\n+precedence over the `-o` flag.\n+\n+[LLVM bitcode]: https://llvm.org/docs/BitCodeFormat.html\n+[LLVM IR]: https://llvm.org/docs/LangRef.html\n \n ## `--print`: print compiler information\n \n-This flag prints out various information about the compiler.\n+This flag prints out various information about the compiler. This flag may be\n+specified multiple times, and the information is printed in the order the\n+flags are specified. Specifying a `--print` flag will usually disable the\n+`--emit` step and will only print the requested information. The valid types\n+of print values are:\n+\n+- `crate-name` \u2014 The name of the crate.\n+- `file-names` \u2014 The names of the files created by the `link` emit kind.\n+- `sysroot` \u2014 Path to the sysroot.\n+- `cfg` \u2014 List of cfg values. See [conditional compilation] for more\n+  information about cfg values.\n+- `target-list` \u2014 List of known targets. The target may be selected with the\n+  `--target` flag.\n+- `target-cpus` \u2014 List of available CPU values for the current target. The\n+  target CPU may be selected with the `-C target-cpu=val` flag.\n+- `target-features` \u2014 List of available target features for the current\n+  target. Target features may be enabled with the `-C target-feature=val`\n+  flag.\n+- `relocation-models` \u2014 List of relocation models. Relocation models may be\n+  selected with the `-C relocation-model=val` flag.\n+- `code-models` \u2014 List of code models. Code models may be selected with the\n+  `-C code-model=val` flag.\n+- `tls-models` \u2014 List of Thread Local Storage models supported. The model may\n+  be selected with the `-Z tls-model=val` flag.\n+- `native-static-libs` \u2014 This may be used when creating a `staticlib` crate\n+  type. If this is the only flag, it will perform a full compilation and\n+  include a diagnostic note that indicates the linker flags to use when\n+  linking the resulting static library. The note starts with the text\n+  `native-static-libs:` to make it easier to fetch the output.\n+\n+[conditional compilation]: ../reference/conditional-compilation.html\n \n ## `-g`: include debug information\n \n-A synonym for `-C debuginfo=2`, for more see [here](codegen-options/index.html#debuginfo).\n+A synonym for `-C debuginfo=2`, for more see [here](codegen-options/index.md#debuginfo).\n \n ## `-O`: optimize your code\n \n-A synonym for `-C opt-level=2`, for more see [here](codegen-options/index.html#opt-level).\n+A synonym for `-C opt-level=2`, for more see [here](codegen-options/index.md#opt-level).\n \n ## `-o`: filename of the output\n \n This flag controls the output filename.\n \n ## `--out-dir`: directory to write the output in\n \n-The outputted crate will be written to this directory.\n+The outputted crate will be written to this directory. This flag is ignored if\n+the `-o` flag is used.\n \n ## `--explain`: provide a detailed explanation of an error message\n \n@@ -68,31 +188,38 @@ and instead produce a test harness.\n \n ## `--target`: select a target triple to build\n \n-This controls which [target](targets/index.html) to produce.\n+This controls which [target](targets/index.md) to produce.\n \n ## `-W`: set lint warnings\n \n-This flag will set which lints should be set to the [warn level](lints/levels.html#warn).\n+This flag will set which lints should be set to the [warn level](lints/levels.md#warn).\n \n ## `-A`: set lint allowed\n \n-This flag will set which lints should be set to the [allow level](lints/levels.html#allow).\n+This flag will set which lints should be set to the [allow level](lints/levels.md#allow).\n \n ## `-D`: set lint denied\n \n-This flag will set which lints should be set to the [deny level](lints/levels.html#deny).\n+This flag will set which lints should be set to the [deny level](lints/levels.md#deny).\n \n ## `-F`: set lint forbidden\n \n-This flag will set which lints should be set to the [forbid level](lints/levels.html#forbid).\n+This flag will set which lints should be set to the [forbid level](lints/levels.md#forbid).\n+\n+## `-Z`: set unstable options\n+\n+This flag will allow you to set unstable options of rustc. In order to set multiple options,\n+the -Z flag can be used multiple times. For example: `rustc -Z verbose -Z time`.\n+Specifying options with -Z is only available on nightly. To view all available options\n+run: `rustc -Z help`.\n \n ## `--cap-lints`: set the most restrictive lint level\n \n-This flag lets you 'cap' lints, for more, [see here](lints/levels.html#capping-lints).\n+This flag lets you 'cap' lints, for more, [see here](lints/levels.md#capping-lints).\n \n ## `-C`/`--codegen`: code generation options\n \n-This flag will allow you to set [codegen options](codegen-options/index.html).\n+This flag will allow you to set [codegen options](codegen-options/index.md).\n \n ## `-V`/`--version`: print a version\n \n@@ -104,8 +231,9 @@ This flag, when combined with other flags, makes them produce extra output.\n \n ## `--extern`: specify where an external library is located\n \n-This flag allows you to pass the name and location of an external crate that will\n-be linked into the crate you're buildling.\n+This flag allows you to pass the name and location of an external crate that\n+will be linked into the crate you are building. This flag may be specified\n+multiple times. The format of the value should be `CRATENAME=PATH`.\n \n ## `--sysroot`: Override the system root\n \n@@ -114,8 +242,65 @@ distribution; this flag allows that to be overridden.\n \n ## `--error-format`: control how errors are produced\n \n-This flag lets you control the format of errors.\n+This flag lets you control the format of messages. Messages are printed to\n+stderr. The valid options are:\n+\n+- `human` \u2014 Human-readable output. This is the default.\n+- `json` \u2014 Structured JSON output.\n+- `short` \u2014 Short, one-line messages.\n \n ## `--color`: configure coloring of output\n \n-This flag lets you control color settings of the output.\n+This flag lets you control color settings of the output. The valid options\n+are:\n+\n+- `auto` \u2014 Use colors if output goes to a tty. This is the default.\n+- `always` \u2014\u00a0Always use colors.\n+- `never` \u2014\u00a0Never colorize output.\n+\n+## `--remap-path-prefix`: remap source names in output\n+\n+Remap source path prefixes in all output, including compiler diagnostics,\n+debug information, macro expansions, etc. It takes a value of the form\n+`FROM=TO` where a path prefix equal to `FROM` is rewritten to the value `TO`.\n+The `FROM` may itself contain an `=` symbol, but the `TO` value may not. This\n+flag may be specified multiple times.\n+\n+This is useful for normalizing build products, for example by removing the\n+current directory out of pathnames emitted into the object files. The\n+replacement is purely textual, with no consideration of the current system's\n+pathname syntax. For example `--remap-path-prefix foo=bar` will match\n+`foo/lib.rs` but not `./foo/lib.rs`.\n+\n+## `--json`: configure json messages printed by the compiler\n+\n+When the `--error-format=json` option is passed to rustc then all of the\n+compiler's diagnostic output will be emitted in the form of JSON blobs. The\n+`--json` argument can be used in conjunction with `--error-format=json` to\n+configure what the JSON blobs contain as well as which ones are emitted.\n+\n+With `--error-format=json` the compiler will always emit any compiler errors as\n+a JSON blob, but the following options are also available to the `--json` flag\n+to customize the output:\n+\n+- `diagnostic-short` - json blobs for diagnostic messages should use the \"short\"\n+  rendering instead of the normal \"human\" default. This means that the output of\n+  `--error-format=short` will be embedded into the JSON diagnostics instead of\n+  the default `--error-format=human`.\n+\n+- `diagnostic-rendered-ansi` - by default JSON blobs in their `rendered` field\n+  will contain a plain text rendering of the diagnostic. This option instead\n+  indicates that the diagnostic should have embedded ANSI color codes intended\n+  to be used to colorize the message in the manner rustc typically already does\n+  for terminal outputs. Note that this is usefully combined with crates like\n+  `fwdansi` to translate these ANSI codes on Windows to console commands or\n+  `strip-ansi-escapes` if you'd like to optionally remove the ansi colors\n+  afterwards.\n+\n+- `artifacts` - this instructs rustc to emit a JSON blob for each artifact that\n+  is emitted. An artifact corresponds to a request from the `--emit` CLI\n+  argument, and as soon as the artifact is available on the filesystem a\n+  notification will be emitted.\n+\n+Note that it is invalid to combine the `--json` argument with the `--color`\n+argument, and it is required to combine `--json` with `--error-format=json`."}, {"sha": "2ae726c4ba61d6af6744f03c82ff644e3933f92a", "filename": "src/doc/rustc/src/linker-plugin-lto.md", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fdoc%2Frustc%2Fsrc%2Flinker-plugin-lto.md", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fdoc%2Frustc%2Fsrc%2Flinker-plugin-lto.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Flinker-plugin-lto.md?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -100,9 +100,10 @@ LLVM. However, the approximation is usually reliable.\n \n The following table shows known good combinations of toolchain versions.\n \n-|           | Clang 7   | Clang 8   |\n+|           |  Clang 7  |  Clang 8  |\n |-----------|-----------|-----------|\n | Rust 1.34 |     \u2717     |     \u2713     |\n-| Rust 1.35 |     \u2717     |    \u2713(?)   |\n+| Rust 1.35 |     \u2717     |     \u2713     |\n+| Rust 1.36 |     \u2717     |     \u2713     |\n \n Note that the compatibility policy for this feature might change in the future."}, {"sha": "049e59b651722ab029e25365d6fc93e2c665cf57", "filename": "src/doc/rustc/src/lints/groups.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Fgroups.md", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Fgroups.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Fgroups.md?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -21,9 +21,9 @@ Here's a list of each lint group, and the lints that they are made up of:\n | edition-2018        | Lints that will be turned into errors in Rust 2018            | tyvar-behind-raw-pointer                                                                                                                                                                                                                                                                                                                                                                                                                                                               |\n | rust-2018-idioms    | Lints to nudge you toward idiomatic features of Rust 2018     | bare-trait-object, unreachable-pub                                                                                                                                                                                                                                                                                                                                                                                                                                                     |\n | unused              | These lints detect things being declared but not used         | unused-imports, unused-variables, unused-assignments, dead-code, unused-mut, unreachable-code, unreachable-patterns, unused-must-use, unused-unsafe, path-statements, unused-attributes, unused-macros, unused-allocation, unused-doc-comment, unused-extern-crates, unused-features, unused-parens                                                                                                                                                                                    |\n-| future-incompatible | Lints that detect code that has future-compatibility problems | private-in-public, pub-use-of-private-extern-crate, patterns-in-fns-without-body, safe-extern-statics, invalid-type-param-default, legacy-directory-ownership, legacy-imports, legacy-constructor-visibility, missing-fragment-specifier, illegal-floating-point-literal-pattern, anonymous-parameters, parenthesized-params-in-types-and-modules, late-bound-lifetime-arguments, safe-packed-borrows, incoherent-fundamental-impls, tyvar-behind-raw-pointer, unstable-name-collision |\n+| future-incompatible | Lints that detect code that has future-compatibility problems | private-in-public, pub-use-of-private-extern-crate, patterns-in-fns-without-body, safe-extern-statics, invalid-type-param-default, legacy-directory-ownership, legacy-imports, legacy-constructor-visibility, missing-fragment-specifier, illegal-floating-point-literal-pattern, anonymous-parameters, parenthesized-params-in-types-and-modules, late-bound-lifetime-arguments, safe-packed-borrows, tyvar-behind-raw-pointer, unstable-name-collision |\n \n Additionally, there's a `bad-style` lint group that's a deprecated alias for `nonstandard-style`.\n \n Finally, you can also see the table above by invoking `rustc -W help`. This will give you the exact values for the specific\n-compiler you have installed.\n\\ No newline at end of file\n+compiler you have installed."}, {"sha": "9010d436eb5cfa6eac08b2915252459e8d26d78b", "filename": "src/doc/rustc/src/lints/index.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Findex.md", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Findex.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Findex.md?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -19,7 +19,7 @@ warning: unused variable: `x`\n 2 |     let x = 5;\n   |         ^\n   |\n-  = note: #[warn(unused_variables)] on by default\n+  = note: `#[warn(unused_variables)]` on by default\n   = note: to avoid this warning, consider using `_x` instead\n ```\n "}, {"sha": "834a4a79727ab9a84346c9e88c1c7f0799042280", "filename": "src/doc/rustc/src/lints/levels.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flevels.md", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flevels.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flevels.md?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -53,7 +53,7 @@ warning: unused variable: `x`\n 2 |     let x = 5;\n   |         ^\n   |\n-  = note: #[warn(unused_variables)] on by default\n+  = note: `#[warn(unused_variables)]` on by default\n   = note: to avoid this warning, consider using `_x` instead\n ```\n \n@@ -76,7 +76,7 @@ error: bitshift exceeds the type's number of bits\n 2 |     100u8 << 10;\n   |     ^^^^^^^^^^^\n   |\n-  = note: #[deny(exceeding_bitshifts)] on by default\n+  = note: `#[deny(exceeding_bitshifts)]` on by default\n ```\n \n What's the difference between an error from a lint and a regular old error?\n@@ -236,7 +236,7 @@ warning: bitshift exceeds the type's number of bits\n 2 |     100u8 << 10;\n   |     ^^^^^^^^^^^\n   |\n-  = note: #[warn(exceeding_bitshifts)] on by default\n+  = note: `#[warn(exceeding_bitshifts)]` on by default\n \n warning: this expression will panic at run-time\n  --> lib.rs:2:5"}, {"sha": "a6e4e166d7bc685971ab5b5a9e4010358a155dcf", "filename": "src/doc/rustc/src/lints/listing/allowed-by-default.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fallowed-by-default.md", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fallowed-by-default.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fallowed-by-default.md?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -165,7 +165,7 @@ pub struct Foo;\n When set to 'deny', this will produce:\n \n ```text\n-error: type does not implement `fmt::Debug`; consider adding #[derive(Debug)] or a manual implementation\n+error: type does not implement `fmt::Debug`; consider adding `#[derive(Debug)]` or a manual implementation\n  --> src/main.rs:3:1\n   |\n 3 | pub struct Foo;"}, {"sha": "6574267f185113f13da7fa7b93b0f05898255694", "filename": "src/doc/rustc/src/lints/listing/deny-by-default.md", "status": "modified", "additions": 6, "deletions": 47, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fdeny-by-default.md", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fdeny-by-default.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fdeny-by-default.md?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -40,7 +40,7 @@ error: defaults for type parameters are only allowed in `struct`, `enum`, `type`\n 4 | fn foo<T=i32>(t: T) {}\n   |        ^\n   |\n-  = note: #[deny(invalid_type_param_default)] on by default\n+  = note: `#[deny(invalid_type_param_default)]` on by default\n   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n   = note: for more information, see issue #36887 <https://github.com/rust-lang/rust/issues/36887>\n ```\n@@ -74,7 +74,7 @@ error: private struct constructors are not usable through re-exports in outer mo\n 5 |         ::S;\n   |         ^^^\n   |\n-  = note: #[deny(legacy_constructor_visibility)] on by default\n+  = note: `#[deny(legacy_constructor_visibility)]` on by default\n   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n   = note: for more information, see issue #39207 <https://github.com/rust-lang/rust/issues/39207>\n ```\n@@ -84,9 +84,9 @@ error: private struct constructors are not usable through re-exports in outer mo\n \n The legacy_directory_ownership warning is issued when\n \n-* There is a non-inline module with a #[path] attribute (e.g. #[path = \"foo.rs\"] mod bar;),\n+* There is a non-inline module with a `#[path]` attribute (e.g. `#[path = \"foo.rs\"] mod bar;`),\n * The module's file (\"foo.rs\" in the above example) is not named \"mod.rs\", and\n-* The module's file contains a non-inline child module without a #[path] attribute.\n+* The module's file contains a non-inline child module without a `#[path]` attribute.\n \n The warning can be fixed by renaming the parent module to \"mod.rs\" and moving\n it into its own directory if appropriate.\n@@ -139,7 +139,7 @@ const FOO: i32 = 5;\n This will produce:\n \n ```text\n-error: const items should never be #[no_mangle]\n+error: const items should never be `#[no_mangle]`\n  --> src/main.rs:3:1\n   |\n 3 | const FOO: i32 = 5;\n@@ -187,7 +187,7 @@ error: parenthesized parameters may only be used with a trait\n 2 |   let x = 5 as usize();\n   |                     ^^\n   |\n-  = note: #[deny(parenthesized_params_in_types_and_modules)] on by default\n+  = note: `#[deny(parenthesized_params_in_types_and_modules)]` on by default\n   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n   = note: for more information, see issue #42238 <https://github.com/rust-lang/rust/issues/42238>\n ```\n@@ -222,44 +222,3 @@ error: invalid `crate_type` value\n   | ^^^^^^^^^^^^^^^^^^^^\n   |\n ```\n-\n-## incoherent-fundamental-impls\n-\n-This lint detects potentially-conflicting impls that were erroneously allowed. Some\n-example code that triggers this lint:\n-\n-```rust,ignore\n-pub trait Trait1<X> {\n-    type Output;\n-}\n-\n-pub trait Trait2<X> {}\n-\n-pub struct A;\n-\n-impl<X, T> Trait1<X> for T where T: Trait2<X> {\n-    type Output = ();\n-}\n-\n-impl<X> Trait1<Box<X>> for A {\n-    type Output = i32;\n-}\n-```\n-\n-This will produce:\n-\n-```text\n-error: conflicting implementations of trait `Trait1<std::boxed::Box<_>>` for type `A`: (E0119)\n-  --> src/main.rs:13:1\n-   |\n-9  | impl<X, T> Trait1<X> for T where T: Trait2<X> {\n-   | --------------------------------------------- first implementation here\n-...\n-13 | impl<X> Trait1<Box<X>> for A {\n-   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ conflicting implementation for `A`\n-   |\n-   = note: #[deny(incoherent_fundamental_impls)] on by default\n-   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n-   = note: for more information, see issue #46205 <https://github.com/rust-lang/rust/issues/46205>\n-   = note: downstream crates may implement trait `Trait2<std::boxed::Box<_>>` for type `A`\n-```"}, {"sha": "e486240fda896f164267093ecb8023483a0ea457", "filename": "src/doc/rustc/src/lints/listing/warn-by-default.md", "status": "modified", "additions": 21, "deletions": 20, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fwarn-by-default.md", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fwarn-by-default.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Flints%2Flisting%2Fwarn-by-default.md?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -90,7 +90,7 @@ warning: floating-point literals cannot be used in patterns\n 4 |         5.0 => {},\n   |         ^^^\n   |\n-  = note: #[warn(illegal_floating_point_literal_pattern)] on by default\n+  = note: `#[warn(illegal_floating_point_literal_pattern)]` on by default\n   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n   = note: for more information, see issue #41620 <https://github.com/rust-lang/rust/issues/41620>\n ```\n@@ -109,7 +109,7 @@ extern \"C\" {\n This will produce:\n \n ```text\n-warning: found struct without foreign-function-safe representation annotation in foreign module, consider adding a #[repr(C)] attribute to the type\n+warning: found struct without foreign-function-safe representation annotation in foreign module, consider adding a `#[repr(C)]` attribute to the type\n  --> src/main.rs:2:20\n   |\n 2 |     static STATIC: String;\n@@ -146,7 +146,7 @@ warning: cannot specify lifetime arguments explicitly if late bound lifetime par\n 8 |     S.late::<'static>(&0, &0);\n   |              ^^^^^^^\n   |\n-  = note: #[warn(late_bound_lifetime_arguments)] on by default\n+  = note: `#[warn(late_bound_lifetime_arguments)]` on by default\n   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n   = note: for more information, see issue #42868 <https://github.com/rust-lang/rust/issues/42868>\n ```\n@@ -327,7 +327,7 @@ warning: patterns aren't allowed in methods without bodies\n 2 |     fn foo(mut arg: u8);\n   |            ^^^^^^^\n   |\n-  = note: #[warn(patterns_in_fns_without_body)] on by default\n+  = note: `#[warn(patterns_in_fns_without_body)]` on by default\n   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n   = note: for more information, see issue #35203 <https://github.com/rust-lang/rust/issues/35203>\n ```\n@@ -406,7 +406,7 @@ fn foo() {}\n This will produce:\n \n ```text\n-warning: function is marked #[no_mangle], but not exported\n+warning: function is marked `#[no_mangle]`, but not exported\n  --> src/main.rs:2:1\n   |\n 2 | fn foo() {}\n@@ -433,7 +433,7 @@ static X: i32 = 4;\n This will produce:\n \n ```text\n-warning: static is marked #[no_mangle], but not exported\n+warning: static is marked `#[no_mangle]`, but not exported\n  --> src/main.rs:2:1\n   |\n 2 | static X: i32 = 4;\n@@ -496,7 +496,7 @@ warning: borrow of packed field requires unsafe function or block (error E0133)\n 11 |     let y = &x.data.0;\n    |             ^^^^^^^^^\n    |\n-   = note: #[warn(safe_packed_borrows)] on by default\n+   = note: `#[warn(safe_packed_borrows)]` on by default\n    = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in a future release!\n    = note: for more information, see issue #46043 <https://github.com/rust-lang/rust/issues/46043>\n ```\n@@ -529,18 +529,21 @@ This lint detects bounds in type aliases. These are not currently enforced.\n Some example code that triggers this lint:\n \n ```rust\n+#[allow(dead_code)]\n type SendVec<T: Send> = Vec<T>;\n ```\n \n This will produce:\n \n ```text\n-warning: type alias is never used: `SendVec`\n- --> src/main.rs:1:1\n+warning: bounds on generic parameters are not enforced in type aliases\n+ --> src/lib.rs:2:17\n   |\n-1 | type SendVec<T: Send> = Vec<T>;\n-  | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+2 | type SendVec<T: Send> = Vec<T>;\n+  |                 ^^^^\n   |\n+  = note: `#[warn(type_alias_bounds)]` on by default\n+  = help: the bound will not be checked when the type alias is used, and should be removed\n ```\n \n ## tyvar-behind-raw-pointer\n@@ -564,7 +567,7 @@ warning: type annotations needed\n 4 |     if data.is_null() {}\n   |             ^^^^^^^\n   |\n-  = note: #[warn(tyvar_behind_raw_pointer)] on by default\n+  = note: `#[warn(tyvar_behind_raw_pointer)]` on by default\n   = warning: this was previously accepted by the compiler but is being phased out; it will become a hard error in the 2018 edition!\n   = note: for more information, see issue #46906 <https://github.com/rust-lang/rust/issues/46906>\n ```\n@@ -725,19 +728,17 @@ This lint detects attributes that were not used by the compiler. Some\n example code that triggers this lint:\n \n ```rust\n-#![feature(custom_attribute)]\n-\n-#![mutable_doc]\n+#![macro_export]\n ```\n \n This will produce:\n \n ```text\n warning: unused attribute\n- --> src/main.rs:4:1\n+ --> src/main.rs:1:1\n   |\n-4 | #![mutable_doc]\n-  | ^^^^^^^^^^^^^^^\n+1 | #![macro_export]\n+  | ^^^^^^^^^^^^^^^^\n   |\n ```\n \n@@ -786,7 +787,7 @@ warning: doc comment not used by rustdoc\n \n ## unused-features\n \n-This lint detects unused or unknown features found in crate-level #[feature] directives.\n+This lint detects unused or unknown features found in crate-level `#[feature]` directives.\n To fix this, simply remove the feature flag.\n \n ## unused-imports\n@@ -838,7 +839,7 @@ warning: unused macro definition\n \n ## unused-must-use\n \n-This lint detects unused result of a type flagged as #[must_use]. Some\n+This lint detects unused result of a type flagged as `#[must_use]`. Some\n example code that triggers this lint:\n \n ```rust"}, {"sha": "38be07a6440dab772e199f81687e2f4c3304812b", "filename": "src/doc/rustc/src/profile-guided-optimization.md", "status": "added", "additions": 136, "deletions": 0, "changes": 136, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fdoc%2Frustc%2Fsrc%2Fprofile-guided-optimization.md", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fdoc%2Frustc%2Fsrc%2Fprofile-guided-optimization.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustc%2Fsrc%2Fprofile-guided-optimization.md?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -0,0 +1,136 @@\n+# Profile Guided Optimization\n+\n+`rustc` supports doing profile-guided optimization (PGO).\n+This chapter describes what PGO is, what it is good for, and how it can be used.\n+\n+## What Is Profiled-Guided Optimization?\n+\n+The basic concept of PGO is to collect data about the typical execution of\n+a program (e.g. which branches it is likely to take) and then use this data\n+to inform optimizations such as inlining, machine-code layout,\n+register allocation, etc.\n+\n+There are different ways of collecting data about a program's execution.\n+One is to run the program inside a profiler (such as `perf`) and another\n+is to create an instrumented binary, that is, a binary that has data\n+collection built into it, and run that.\n+The latter usually provides more accurate data and it is also what is\n+supported by `rustc`.\n+\n+## Usage\n+\n+Generating a PGO-optimized program involves following a workflow with four steps:\n+\n+1. Compile the program with instrumentation enabled\n+   (e.g. `rustc -Cprofile-generate=/tmp/pgo-data main.rs`)\n+2. Run the instrumented program (e.g. `./main`) which generates a\n+   `default_<id>.profraw` file\n+3. Convert the `.profraw` file into a `.profdata` file using\n+   LLVM's `llvm-profdata` tool\n+4. Compile the program again, this time making use of the profiling data\n+   (for example `rustc -Cprofile-use=merged.profdata main.rs`)\n+\n+An instrumented program will create one or more `.profraw` files, one for each\n+instrumented binary. E.g. an instrumented executable that loads two instrumented\n+dynamic libraries at runtime will generate three `.profraw` files. Running an\n+instrumented binary multiple times, on the other hand, will re-use the\n+respective `.profraw` files, updating them in place.\n+\n+These `.profraw` files have to be post-processed before they can be fed back\n+into the compiler. This is done by the `llvm-profdata` tool. This tool\n+is most easily installed via\n+\n+```bash\n+rustup component add llvm-tools-preview\n+```\n+\n+Note that installing the `llvm-tools-preview` component won't add\n+`llvm-profdata` to the `PATH`. Rather, the tool can be found in:\n+\n+```bash\n+~/.rustup/toolchains/<toolchain>/lib/rustlib/<target-triple>/bin/\n+```\n+\n+Alternatively, an `llvm-profdata` coming with a recent LLVM or Clang\n+version usually works too.\n+\n+The `llvm-profdata` tool merges multiple `.profraw` files into a single\n+`.profdata` file that can then be fed back into the compiler via\n+`-Cprofile-use`:\n+\n+```bash\n+# STEP 1: Compile the binary with instrumentation\n+rustc -Cprofile-generate=/tmp/pgo-data -O ./main.rs\n+\n+# STEP 2: Run the binary a few times, maybe with common sets of args.\n+#         Each run will create or update `.profraw` files in /tmp/pgo-data\n+./main mydata1.csv\n+./main mydata2.csv\n+./main mydata3.csv\n+\n+# STEP 3: Merge and post-process all the `.profraw` files in /tmp/pgo-data\n+llvm-profdata merge -o ./merged.profdata /tmp/pgo-data\n+\n+# STEP 4: Use the merged `.profdata` file during optimization. All `rustc`\n+#         flags have to be the same.\n+rustc -Cprofile-use=./merged.profdata -O ./main.rs\n+```\n+\n+### A Complete Cargo Workflow\n+\n+Using this feature with Cargo works very similar to using it with `rustc`\n+directly. Again, we generate an instrumented binary, run it to produce data,\n+merge the data, and feed it back into the compiler. Some things of note:\n+\n+- We use the `RUSTFLAGS` environment variable in order to pass the PGO compiler\n+  flags to the compilation of all crates in the program.\n+\n+- We pass the `--target` flag to Cargo, which prevents the `RUSTFLAGS`\n+  arguments to be passed to Cargo build scripts. We don't want the build\n+  scripts to generate a bunch of `.profraw` files.\n+\n+- We pass `--release` to Cargo because that's where PGO makes the most sense.\n+  In theory, PGO can also be done on debug builds but there is little reason\n+  to do so.\n+\n+- It is recommended to use *absolute paths* for the argument of\n+  `-Cprofile-generate` and `-Cprofile-use`. Cargo can invoke `rustc` with\n+  varying working directories, meaning that `rustc` will not be able to find\n+  the supplied `.profdata` file. With absolute paths this is not an issue.\n+\n+- It is good practice to make sure that there is no left-over profiling data\n+  from previous compilation sessions. Just deleting the directory is a simple\n+  way of doing so (see `STEP 0` below).\n+\n+This is what the entire workflow looks like:\n+\n+```bash\n+# STEP 0: Make sure there is no left-over profiling data from previous runs\n+rm -rf /tmp/pgo-data\n+\n+# STEP 1: Build the instrumented binaries\n+RUSTFLAGS=\"-Cprofile-generate=/tmp/pgo-data\" \\\n+    cargo build --release --target=x86_64-unknown-linux-gnu\n+\n+# STEP 2: Run the instrumented binaries with some typical data\n+./target/x86_64-unknown-linux-gnu/release/myprogram mydata1.csv\n+./target/x86_64-unknown-linux-gnu/release/myprogram mydata2.csv\n+./target/x86_64-unknown-linux-gnu/release/myprogram mydata3.csv\n+\n+# STEP 3: Merge the `.profraw` files into a `.profdata` file\n+llvm-profdata merge -o /tmp/pgo-data/merged.profdata /tmp/pgo-data\n+\n+# STEP 4: Use the `.profdata` file for guiding optimizations\n+RUSTFLAGS=\"-Cprofile-use=/tmp/pgo-data/merged.profdata\" \\\n+    cargo build --release --target=x86_64-unknown-linux-gnu\n+```\n+\n+## Further Reading\n+\n+`rustc`'s PGO support relies entirely on LLVM's implementation of the feature\n+and is equivalent to what Clang offers via the `-fprofile-generate` /\n+`-fprofile-use` flags. The [Profile Guided Optimization][clang-pgo] section\n+in Clang's documentation is therefore an interesting read for anyone who wants\n+to use PGO with Rust.\n+\n+[clang-pgo]: https://clang.llvm.org/docs/UsersManual.html#profile-guided-optimization"}, {"sha": "b21defaedc31312147423bd3c051d9a34b472973", "filename": "src/doc/rustdoc/src/command-line-arguments.md", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fdoc%2Frustdoc%2Fsrc%2Fcommand-line-arguments.md", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fdoc%2Frustdoc%2Fsrc%2Fcommand-line-arguments.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Fcommand-line-arguments.md?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -178,7 +178,7 @@ $ rustdoc src/lib.rs --passes strip-priv-imports\n An argument of \"list\" will print a list of possible \"rustdoc passes\", and other\n arguments will be the name of which passes to run in addition to the defaults.\n \n-For more details on passes, see [the chapter on them](passes.html).\n+For more details on passes, see [the chapter on them](passes.md).\n \n See also `--no-defaults`.\n \n@@ -194,7 +194,7 @@ By default, `rustdoc` will run several passes over your code. This\n removes those defaults, allowing you to use `--passes` to specify\n exactly which passes you want.\n \n-For more details on passes, see [the chapter on them](passes.html).\n+For more details on passes, see [the chapter on them](passes.md).\n \n See also `--passes`.\n \n@@ -207,7 +207,7 @@ $ rustdoc src/lib.rs --test\n ```\n \n This flag will run your code examples as tests. For more, see [the chapter\n-on documentation tests](documentation-tests.html).\n+on documentation tests](documentation-tests.md).\n \n See also `--test-args`.\n \n@@ -220,7 +220,7 @@ $ rustdoc src/lib.rs --test --test-args ignored\n ```\n \n This flag will pass options to the test runner when running documentation tests.\n-For more, see [the chapter on documentation tests](documentation-tests.html).\n+For more, see [the chapter on documentation tests](documentation-tests.md).\n \n See also `--test`.\n "}, {"sha": "12d4ea205b31e64308106741522b85a910300d99", "filename": "src/doc/rustdoc/src/passes.md", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fdoc%2Frustdoc%2Fsrc%2Fpasses.md", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fdoc%2Frustdoc%2Fsrc%2Fpasses.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Fpasses.md?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -5,8 +5,8 @@ Rustdoc has a concept called \"passes\". These are transformations that\n \n In addition to the passes below, check out the docs for these flags:\n \n-* [`--passes`](command-line-arguments.html#a--passes-add-more-rustdoc-passes)\n-* [`--no-defaults`](command-line-arguments.html#a--no-defaults-dont-run-default-passes)\n+* [`--passes`](command-line-arguments.md#--passes-add-more-rustdoc-passes)\n+* [`--no-defaults`](command-line-arguments.md#--no-defaults-dont-run-default-passes)\n \n ## Default passes\n "}, {"sha": "80ac405eb2f2a72d9d6bbcac0e1b15ce35e027c7", "filename": "src/doc/rustdoc/src/the-doc-attribute.md", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fdoc%2Frustdoc%2Fsrc%2Fthe-doc-attribute.md", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fdoc%2Frustdoc%2Fsrc%2Fthe-doc-attribute.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Fthe-doc-attribute.md?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -92,6 +92,21 @@ the tracking issue.\n #![doc(issue_tracker_base_url = \"https://github.com/rust-lang/rust/issues/\")]\n ```\n \n+### `html_root_url`\n+\n+The `#[doc(html_root_url = \"\u2026\")]` attribute value indicates the URL for\n+generating links to external crates. When rustdoc needs to generate a link to\n+an item in an external crate, it will first check if the extern crate has been\n+documented locally on-disk, and if so link directly to it. Failing that, it\n+will use the URL given by the `--extern-html-root-url` command-line flag if\n+available. If that is not available, then it will use the `html_root_url`\n+value in the extern crate if it is available. If that is not available, then\n+the extern items will not be linked.\n+\n+```rust,ignore\n+#![doc(html_root_url = \"https://docs.rs/serde/1.0\")]\n+```\n+\n ### `html_no_source`\n \n By default, `rustdoc` will include the source code of your program, with links\n@@ -187,7 +202,7 @@ mod bar {\n Now we'll have a `Re-exports` line, and `Bar` will not link to anywhere.\n \n One special case: In Rust 2018 and later, if you `pub use` one of your dependencies, `rustdoc` will\n-not eagerly inline it as a module unless you add `#[doc(inline)}`.\n+not eagerly inline it as a module unless you add `#[doc(inline)]`.\n \n ## `#[doc(hidden)]`\n "}, {"sha": "6e32468b64dee0f4c4503f90e3424fd53dfdb61e", "filename": "src/doc/rustdoc/src/unstable-features.md", "status": "modified", "additions": 32, "deletions": 3, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fdoc%2Frustdoc%2Fsrc%2Funstable-features.md", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fdoc%2Frustdoc%2Fsrc%2Funstable-features.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Funstable-features.md?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -183,9 +183,8 @@ Book][unstable-masked] and [its tracking issue][issue-masked].\n \n As designed in [RFC 1990], Rustdoc can read an external file to use as a type's documentation. This\n is useful if certain documentation is so long that it would break the flow of reading the source.\n-Instead of writing it all inline, writing `#[doc(include = \"sometype.md\")]` (where `sometype.md` is\n-a file adjacent to the `lib.rs` for the crate) will ask Rustdoc to instead read that file and use it\n-as if it were written inline.\n+Instead of writing it all inline, writing `#[doc(include = \"sometype.md\")]` will ask Rustdoc to\n+instead read that file and use it as if it were written inline.\n \n [RFC 1990]: https://github.com/rust-lang/rfcs/pull/1990\n \n@@ -212,6 +211,36 @@ pub struct BigX;\n Then, when looking for it through the `rustdoc` search, if you enter \"x\" or\n \"big\", search will show the `BigX` struct first.\n \n+### Include items only when collecting doctests\n+\n+Rustdoc's [documentation tests] can do some things that regular unit tests can't, so it can\n+sometimes be useful to extend your doctests with samples that wouldn't otherwise need to be in\n+documentation. To this end, Rustdoc allows you to have certain items only appear when it's\n+collecting doctests, so you can utilize doctest functionality without forcing the test to appear in\n+docs, or to find an arbitrary private item to include it on.\n+\n+If you add `#![feature(cfg_doctest)]` to your crate, Rustdoc will set `cfg(doctest)` when collecting\n+doctests. Note that they will still link against only the public items of your crate; if you need to\n+test private items, unit tests are still the way to go.\n+\n+In this example, we're adding doctests that we know won't compile, to verify that our struct can\n+only take in valid data:\n+\n+```rust\n+#![feature(cfg_doctest)]\n+\n+/// We have a struct here. Remember it doesn't accept negative numbers!\n+pub struct MyStruct(usize);\n+\n+/// ```compile_fail\n+/// let x = my_crate::MyStruct(-5);\n+/// ```\n+#[cfg(doctest)]\n+pub struct MyStructOnlyTakesUsize;\n+```\n+\n+[documentation tests]: documentation-tests.html\n+\n ## Unstable command-line arguments\n \n These features are enabled by passing a command-line flag to Rustdoc, but the flags in question are"}, {"sha": "bbcacb7f3d5d9b05111fb1e2a1c52e105e2111c5", "filename": "src/doc/rustdoc/src/what-is-rustdoc.md", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fdoc%2Frustdoc%2Fsrc%2Fwhat-is-rustdoc.md", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fdoc%2Frustdoc%2Fsrc%2Fwhat-is-rustdoc.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Frustdoc%2Fsrc%2Fwhat-is-rustdoc.md?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -98,21 +98,21 @@ documentation for them as well!\n `rustdoc` can also generate HTML from standalone Markdown files. Let's\n give it a try: create a `README.md` file with these contents:\n \n-```text\n-    # Docs\n+````text\n+# Docs\n \n-    This is a project to test out `rustdoc`.\n+This is a project to test out `rustdoc`.\n \n-    [Here is a link!](https://www.rust-lang.org)\n+[Here is a link!](https://www.rust-lang.org)\n \n-    ## Subheading\n+## Subheading\n \n-    ```rust\n-    fn foo() -> i32 {\n-        1 + 1\n-    }\n-    ```\n+```rust\n+fn foo() -> i32 {\n+    1 + 1\n+}\n ```\n+````\n \n And call `rustdoc` on it:\n "}, {"sha": "5b2e19bd7aa78eeaf345ad29921cf276d6e16aba", "filename": "src/doc/unstable-book/book.toml", "status": "added", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fdoc%2Funstable-book%2Fbook.toml", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fdoc%2Funstable-book%2Fbook.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fbook.toml?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -0,0 +1,3 @@\n+[book]\n+title = \"The Rust Unstable Book\"\n+author = \"The Rust Community\""}, {"sha": "e0bb782270e22821f416ac44a45d91236e985ffd", "filename": "src/doc/unstable-book/src/language-features/arbitrary-enum-discriminant.md", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Farbitrary-enum-discriminant.md", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Farbitrary-enum-discriminant.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Farbitrary-enum-discriminant.md?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -0,0 +1,37 @@\n+# `arbitrary_enum_discriminant`\n+\n+The tracking issue for this feature is: [#60553]\n+\n+[#60553]: https://github.com/rust-lang/rust/issues/60553\n+\n+------------------------\n+\n+The `arbitrary_enum_discriminant` feature permits tuple-like and\n+struct-like enum variants with `#[repr(<int-type>)]` to have explicit discriminants.\n+\n+## Examples\n+\n+```rust\n+#![feature(arbitrary_enum_discriminant)]\n+\n+#[allow(dead_code)]\n+#[repr(u8)]\n+enum Enum {\n+    Unit = 3,\n+    Tuple(u16) = 2,\n+    Struct {\n+        a: u8,\n+        b: u16,\n+    } = 1,\n+}\n+\n+impl Enum {\n+    fn tag(&self) -> u8 {\n+        unsafe { *(self as *const Self as *const u8) }\n+    }\n+}\n+\n+assert_eq!(3, Enum::Unit.tag());\n+assert_eq!(2, Enum::Tuple(5).tag());\n+assert_eq!(1, Enum::Struct{a: 7, b: 11}.tag());\n+```"}, {"sha": "bf0819ec920b7f0462ad912fa87ad80124e1c34c", "filename": "src/doc/unstable-book/src/language-features/box-patterns.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fbox-patterns.md", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fbox-patterns.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fbox-patterns.md?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -4,7 +4,7 @@ The tracking issue for this feature is: [#29641]\n \n [#29641]: https://github.com/rust-lang/rust/issues/29641\n \n-See also [`box_syntax`](language-features/box-syntax.html)\n+See also [`box_syntax`](box-syntax.md)\n \n ------------------------\n "}, {"sha": "9569974d22ca28124cd888e78c56a9a81d15aedf", "filename": "src/doc/unstable-book/src/language-features/box-syntax.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fbox-syntax.md", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fbox-syntax.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fbox-syntax.md?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -4,7 +4,7 @@ The tracking issue for this feature is: [#49733]\n \n [#49733]: https://github.com/rust-lang/rust/issues/49733\n \n-See also [`box_patterns`](language-features/box-patterns.html)\n+See also [`box_patterns`](box-patterns.md)\n \n ------------------------\n "}, {"sha": "09d1b19b4c3c382868c7500a2557a48c241f4cba", "filename": "src/doc/unstable-book/src/language-features/const-in-array-repeat-expressions.md", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fconst-in-array-repeat-expressions.md", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fconst-in-array-repeat-expressions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fconst-in-array-repeat-expressions.md?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -0,0 +1,11 @@\n+# `const_in_array_repeat_expressions`\n+\n+The tracking issue for this feature is: [#49147]\n+\n+[#44109]: https://github.com/rust-lang/rust/issues/49147\n+\n+------------------------\n+\n+Relaxes the rules for repeat expressions, `[x; N]` such that `x` may also be `const` (strictly\n+speaking rvalue promotable), in addition to `typeof(x): Copy`. The result of `[x; N]` where `x` is\n+`const` is itself also `const`."}, {"sha": "97cf58e57e6056e7e9399056806f0cd03762e8eb", "filename": "src/doc/unstable-book/src/language-features/generators.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fgenerators.md", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fgenerators.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fgenerators.md?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -146,7 +146,7 @@ closure-like semantics. Namely:\n   generators also depend on variables live across suspension points. This means\n   that although the ambient environment may be `Send` or `Sync`, the generator\n   itself may not be due to internal variables live across `yield` points being\n-  not-`Send` or not-`Sync`. Note that generators, like closures, do\n+  not-`Send` or not-`Sync`. Note that generators do\n   not implement traits like `Copy` or `Clone` automatically.\n \n * Whenever a generator is dropped it will drop all captured environment"}, {"sha": "3ee024c6b588361e8f10a3f593aebf1f60b6333d", "filename": "src/doc/unstable-book/src/language-features/lang-items.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Flang-items.md", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Flang-items.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Flang-items.md?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -192,7 +192,7 @@ such as \"```undefined reference to `__rust_probestack'```\". Using this crate\n also requires enabling the library feature `compiler_builtins_lib`. You can read\n more about this [here][compiler-builtins-lib].\n \n-[compiler-builtins-lib]: library-features/compiler-builtins-lib.html\n+[compiler-builtins-lib]: ../library-features/compiler-builtins-lib.md\n \n ## More about the language items\n "}, {"sha": "0d11c31aca6e956ab91f3fff9e5e82f9f1b89f23", "filename": "src/doc/unstable-book/src/language-features/member-constraints.md", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fmember-constraints.md", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fmember-constraints.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fmember-constraints.md?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -0,0 +1,29 @@\n+# `member_constraints`\n+\n+The tracking issue for this feature is: [#61977]\n+\n+[#61977]: https://github.com/rust-lang/rust/issues/61977\n+\n+------------------------\n+\n+The `member_constraints` feature gate lets you use `impl Trait` syntax with\n+multiple unrelated lifetime parameters.\n+\n+A simple example is:\n+\n+```rust\n+#![feature(member_constraints)]\n+\n+trait Trait<'a, 'b> { }\n+impl<T> Trait<'_, '_> for T {}\n+\n+fn foo<'a, 'b>(x: &'a u32, y: &'b u32) -> impl Trait<'a, 'b> {\n+  (x, y)\n+}\n+\n+fn main() { }\n+```\n+\n+Without the `member_constraints` feature gate, the above example is an\n+error because both `'a` and `'b` appear in the impl Trait bounds, but\n+neither outlives the other."}, {"sha": "22dae0c89a6ff5a460ef4c04679f2b29c24ca0c6", "filename": "src/doc/unstable-book/src/language-features/non-ascii-idents.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fnon-ascii-idents.md", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fnon-ascii-idents.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fnon-ascii-idents.md?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -45,4 +45,4 @@ that does _not_ occur in the set of [strict keywords].\n \n [`XID_start`]:  http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%3AXID_Start%3A%5D&abb=on&g=&i=\n [`XID_continue`]: http://unicode.org/cldr/utility/list-unicodeset.jsp?a=%5B%3AXID_Continue%3A%5D&abb=on&g=&i=\n-[strict keywords]: ../reference/keywords.html#strict-keywords\n+[strict keywords]: ../../reference/keywords.md#strict-keywords"}, {"sha": "907147c17ef8e500260577c1c637d7260bc7bd5b", "filename": "src/doc/unstable-book/src/language-features/non-exhaustive.md", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fnon-exhaustive.md", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fnon-exhaustive.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fnon-exhaustive.md?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -7,10 +7,12 @@ The tracking issue for this feature is: [#44109]\n ------------------------\n \n The `non_exhaustive` gate allows you to use the `#[non_exhaustive]` attribute\n-on structs and enums. When applied within a crate, users of the crate will need\n-to use the `_` pattern when matching enums and use the `..` pattern when\n-matching structs. Structs marked as `non_exhaustive` will not be able to be\n-created normally outside of the defining crate. This is demonstrated below:\n+on structs, enums and enum variants. When applied within a crate, users of the\n+crate will need to use the `_` pattern when matching enums and use the `..`\n+pattern when matching structs. Enum variants cannot be matched against.\n+Structs and enum variants marked as `non_exhaustive` will not be able to\n+be created normally outside of the defining crate. This is demonstrated\n+below:\n \n ```rust,ignore (pseudo-Rust)\n use std::error::Error as StdError;\n@@ -72,4 +74,3 @@ let config = Config { window_width: 640, window_height: 480 };\n // when marked non_exhaustive.\n let &Config { window_width, window_height, .. } = config;\n ```\n-"}, {"sha": "8db241e4b4ebf7f0e67713dc0240b112745a83c0", "filename": "src/doc/unstable-book/src/language-features/on-unimplemented.md", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fon-unimplemented.md", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fon-unimplemented.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fon-unimplemented.md?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -98,7 +98,8 @@ application of these fields based on a variety of attributes when using\n    `crate_local`) or matching against a particular method. Currently used\n    for `try`.\n  - `from_desugaring`: usable both as boolean (whether the flag is present)\n-   or matching against a particular desugaring.\n+   or matching against a particular desugaring. The desugaring is identified\n+   with its variant name in the `DesugaringKind` enum.\n \n For example, the `Iterator` trait can be annotated in the following way:\n \n@@ -138,3 +139,16 @@ error[E0277]: `&str` is not an iterator\n   = help: the trait `std::iter::Iterator` is not implemented for `&str`\n   = note: required by `std::iter::IntoIterator::into_iter`\n ```\n+\n+If you need to filter on multiple attributes, you can use `all`, `any` or\n+`not` in the following way:\n+\n+```rust,compile_fail\n+#[rustc_on_unimplemented(\n+    on(\n+        all(_Self=\"&str\", T=\"std::string::String\"),\n+        note=\"you can coerce a `{T}` into a `{Self}` by writing `&*variable`\"\n+    )\n+)]\n+pub trait From<T>: Sized { /* ... */ }\n+```"}, {"sha": "4b83c204ba10579d2152672578834232bd4d1984", "filename": "src/doc/unstable-book/src/language-features/param-attrs.md", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fparam-attrs.md", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fparam-attrs.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fparam-attrs.md?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -0,0 +1,27 @@\n+# `param_attrs`\n+\n+The tracking issue for this feature is: [#60406]\n+\n+[#60406]: https://github.com/rust-lang/rust/issues/60406\n+\n+Allow attributes in formal function parameter position so external tools and compiler internals can\n+take advantage of the additional information that the parameters provide.\n+\n+Enables finer conditional compilation with `#[cfg(..)]` and linting control of variables. Moreover,\n+opens the path to richer DSLs created by users.\n+\n+------------------------\n+\n+Example:\n+\n+```rust\n+#![feature(param_attrs)]\n+\n+fn len(\n+  #[cfg(windows)] slice: &[u16],\n+  #[cfg(not(windows))] slice: &[u8],\n+) -> usize\n+{\n+  slice.len()\n+}\n+```"}, {"sha": "bf5dd81d735af768be0994f50fa6fb6193be9569", "filename": "src/doc/unstable-book/src/language-features/plugin-registrar.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fplugin-registrar.md", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fplugin-registrar.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fplugin-registrar.md?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -8,6 +8,6 @@ This feature is part of \"compiler plugins.\" It will often be used with the\n [`plugin`] and `rustc_private` features as well. For more details, see\n their docs.\n \n-[`plugin`]: language-features/plugin.html\n+[`plugin`]: plugin.md\n \n ------------------------"}, {"sha": "8be4d16998276f91e4cc63e065304780fd3ef071", "filename": "src/doc/unstable-book/src/language-features/plugin.md", "status": "modified", "additions": 10, "deletions": 18, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fplugin.md", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fplugin.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fplugin.md?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -8,7 +8,7 @@ The tracking issue for this feature is: [#29597]\n This feature is part of \"compiler plugins.\" It will often be used with the\n [`plugin_registrar`] and `rustc_private` features.\n \n-[`plugin_registrar`]: language-features/plugin-registrar.html\n+[`plugin_registrar`]: plugin-registrar.md\n \n ------------------------\n \n@@ -39,12 +39,12 @@ of a library.\n \n Plugins can extend Rust's syntax in various ways. One kind of syntax extension\n is the procedural macro. These are invoked the same way as [ordinary\n-macros](../book/macros.html), but the expansion is performed by arbitrary Rust\n+macros](../../book/macros.md), but the expansion is performed by arbitrary Rust\n code that manipulates syntax trees at\n compile time.\n \n Let's write a plugin\n-[`roman_numerals.rs`](https://github.com/rust-lang/rust/blob/master/src/test/run-pass-fulldeps/auxiliary/roman_numerals.rs)\n+[`roman_numerals.rs`](https://github.com/rust-lang/rust/blob/master/src/test/ui-fulldeps/auxiliary/roman_numerals.rs)\n that implements Roman numeral integer literals.\n \n ```rust,ignore\n@@ -56,15 +56,14 @@ extern crate syntax_pos;\n extern crate rustc;\n extern crate rustc_plugin;\n \n-use syntax::parse::token;\n+use syntax::parse::token::{self, Token};\n use syntax::tokenstream::TokenTree;\n use syntax::ext::base::{ExtCtxt, MacResult, DummyResult, MacEager};\n-use syntax::ext::build::AstBuilder;  // A trait for expr_usize.\n use syntax_pos::Span;\n use rustc_plugin::Registry;\n \n fn expand_rn(cx: &mut ExtCtxt, sp: Span, args: &[TokenTree])\n-        -> Box<MacResult + 'static> {\n+        -> Box<dyn MacResult + 'static> {\n \n     static NUMERALS: &'static [(&'static str, usize)] = &[\n         (\"M\", 1000), (\"CM\", 900), (\"D\", 500), (\"CD\", 400),\n@@ -80,7 +79,7 @@ fn expand_rn(cx: &mut ExtCtxt, sp: Span, args: &[TokenTree])\n     }\n \n     let text = match args[0] {\n-        TokenTree::Token(_, token::Ident(s)) => s.to_string(),\n+        TokenTree::Token(Token { kind: token::Ident(s, _), .. }) => s.to_string(),\n         _ => {\n             cx.span_err(sp, \"argument should be a single identifier\");\n             return DummyResult::any(sp);\n@@ -130,9 +129,9 @@ The advantages over a simple `fn(&str) -> u32` are:\n   a way to define new literal syntax for any data type.\n \n In addition to procedural macros, you can define new\n-[`derive`](../reference/attributes.html#derive)-like attributes and other kinds\n+[`derive`](../../reference/attributes/derive.md)-like attributes and other kinds\n of extensions.  See `Registry::register_syntax_extension` and the\n-`SyntaxExtension` enum.  For a more involved macro example, see\n+`SyntaxExtension` struct.  For a more involved macro example, see\n [`regex_macros`](https://github.com/rust-lang/regex/blob/master/regex_macros/src/lib.rs).\n \n \n@@ -164,17 +163,10 @@ can continue and find further errors.\n To print syntax fragments for debugging, you can use `span_note` together with\n `syntax::print::pprust::*_to_string`.\n \n-The example above produced an integer literal using `AstBuilder::expr_usize`.\n-As an alternative to the `AstBuilder` trait, `libsyntax` provides a set of\n-quasiquote macros. They are undocumented and very rough around the edges.\n-However, the implementation may be a good starting point for an improved\n-quasiquote as an ordinary plugin library.\n-\n-\n # Lint plugins\n \n Plugins can extend [Rust's lint\n-infrastructure](../reference/attributes.html#lint-check-attributes) with\n+infrastructure](../../reference/attributes/diagnostics.md#lint-check-attributes) with\n additional checks for code style, safety, etc. Now let's write a plugin\n [`lint_plugin_test.rs`](https://github.com/rust-lang/rust/blob/master/src/test/ui-fulldeps/auxiliary/lint_plugin_test.rs)\n that warns about any item named `lintme`.\n@@ -253,7 +245,7 @@ mostly use the same infrastructure as lint plugins, and provide examples of how\n to access type information.\n \n Lints defined by plugins are controlled by the usual [attributes and compiler\n-flags](../reference/attributes.html#lint-check-attributes), e.g.\n+flags](../../reference/attributes/diagnostics.md#lint-check-attributes), e.g.\n `#[allow(test_lint)]` or `-A test-lint`. These identifiers are derived from the\n first argument to `declare_lint!`, with appropriate case and punctuation\n conversion."}, {"sha": "415c6ebe8b4bcfe7e45026f4e0dda575da807bcb", "filename": "src/doc/unstable-book/src/language-features/repr-align-enum.md", "status": "removed", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/33445aea509cadcd715009c79795d289268daa7c/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Frepr-align-enum.md", "raw_url": "https://github.com/rust-lang/rust/raw/33445aea509cadcd715009c79795d289268daa7c/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Frepr-align-enum.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Frepr-align-enum.md?ref=33445aea509cadcd715009c79795d289268daa7c", "patch": "@@ -1,42 +0,0 @@\n-# `repr_align_enum`\n-\n-The tracking issue for this feature is: [#57996]\n-\n-[#57996]: https://github.com/rust-lang/rust/issues/57996\n-\n-------------------------\n-\n-The `repr_align_enum` feature allows using the `#[repr(align(x))]` attribute\n-on enums, similarly to structs.\n-\n-# Examples\n-\n-```rust\n-#![feature(repr_align_enum)]\n-\n-#[repr(align(8))]\n-enum Aligned {\n-    Foo,\n-    Bar { value: u32 },\n-}\n-\n-fn main() {\n-    assert_eq!(std::mem::align_of::<Aligned>(), 8);\n-}\n-```\n-\n-This is equivalent to using an aligned wrapper struct everywhere:\n-\n-```rust\n-#[repr(align(8))]\n-struct Aligned(Unaligned);\n-\n-enum Unaligned {\n-    Foo,\n-    Bar { value: u32 },\n-}\n-\n-fn main() {\n-    assert_eq!(std::mem::align_of::<Aligned>(), 8);\n-}\n-```"}, {"sha": "cdb74495884a8e6e8d027992e147814ed44946ee", "filename": "src/doc/unstable-book/src/language-features/slice-patterns.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fslice-patterns.md", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fslice-patterns.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Fslice-patterns.md?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -1,8 +1,8 @@\n # `slice_patterns`\n \n-The tracking issue for this feature is: [#23121]\n+The tracking issue for this feature is: [#62254]\n \n-[#23121]: https://github.com/rust-lang/rust/issues/23121\n+[#62254]: https://github.com/rust-lang/rust/issues/62254\n \n ------------------------\n \n@@ -17,7 +17,7 @@ matched against that pattern. For example:\n fn is_symmetric(list: &[u32]) -> bool {\n     match list {\n         &[] | &[_] => true,\n-        &[x, ref inside.., y] if x == y => is_symmetric(inside),\n+        &[x, ref inside @ .., y] if x == y => is_symmetric(inside),\n         &[..] => false,\n     }\n }"}, {"sha": "862411ab392031ee9315d4fc07edf5a61b04c6e9", "filename": "src/doc/unstable-book/src/language-features/transparent-enums.md", "status": "added", "additions": 93, "deletions": 0, "changes": 93, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Ftransparent-enums.md", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Ftransparent-enums.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Ftransparent-enums.md?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -0,0 +1,93 @@\n+# `transparent_enums`\n+\n+The tracking issue for this feature is [#60405]\n+\n+[60405]: https://github.com/rust-lang/rust/issues/60405\n+\n+----\n+\n+The `transparent_enums` feature allows you mark `enum`s as\n+`#[repr(transparent)]`. An `enum` may be `#[repr(transparent)]` if it has\n+exactly one variant, and that variant matches the same conditions which `struct`\n+requires for transparency. Some concrete illustrations follow.\n+\n+```rust\n+#![feature(transparent_enums)]\n+\n+// This enum has the same representation as `f32`.\n+#[repr(transparent)]\n+enum SingleFieldEnum {\n+    Variant(f32)\n+}\n+\n+// This enum has the same representation as `usize`.\n+#[repr(transparent)]\n+enum MultiFieldEnum {\n+    Variant { field: usize, nothing: () },\n+}\n+```\n+\n+For consistency with transparent `struct`s, `enum`s must have exactly one\n+non-zero-sized field. If all fields are zero-sized, the `enum` must not be\n+`#[repr(transparent)]`:\n+\n+```rust\n+#![feature(transparent_enums)]\n+\n+// This (non-transparent) enum is already valid in stable Rust:\n+pub enum GoodEnum {\n+    Nothing,\n+}\n+\n+// Error: transparent enum needs exactly one non-zero-sized field, but has 0\n+// #[repr(transparent)]\n+// pub enum BadEnum {\n+//     Nothing(()),\n+// }\n+\n+// Error: transparent enum needs exactly one non-zero-sized field, but has 0\n+// #[repr(transparent)]\n+// pub enum BadEmptyEnum {\n+//     Nothing,\n+// }\n+```\n+\n+The one exception is if the `enum` is generic over `T` and has a field of type\n+`T`, it may be `#[repr(transparent)]` even if `T` is a zero-sized type:\n+\n+```rust\n+#![feature(transparent_enums)]\n+\n+// This enum has the same representation as `T`.\n+#[repr(transparent)]\n+pub enum GenericEnum<T> {\n+    Variant(T, ()),\n+}\n+\n+// This is okay even though `()` is a zero-sized type.\n+pub const THIS_IS_OKAY: GenericEnum<()> = GenericEnum::Variant((), ());\n+```\n+\n+Transparent `enum`s require exactly one variant:\n+\n+```rust\n+// Error: transparent enum needs exactly one variant, but has 0\n+// #[repr(transparent)]\n+// pub enum TooFewVariants {\n+// }\n+\n+// Error: transparent enum needs exactly one variant, but has 2\n+// #[repr(transparent)]\n+// pub enum TooManyVariants {\n+//     First(usize),\n+//     Second,\n+// }\n+```\n+\n+Like transarent `struct`s, a transparent `enum` of type `E` has the same layout,\n+size, and ABI as its single non-ZST field. If it is generic over a type `T`, and\n+all its fields are ZSTs except for exactly one field of type `T`, then it has\n+the same layout and ABI as `T` (even if `T` is a ZST when monomorphized).\n+\n+Like transparent `struct`s, transparent `enum`s are FFI-safe if and only if\n+their underlying representation type is also FFI-safe."}, {"sha": "b731c9ea6d0123c23d536828891a28403e3a564c", "filename": "src/doc/unstable-book/src/language-features/transparent-unions.md", "status": "added", "additions": 83, "deletions": 0, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Ftransparent-unions.md", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Ftransparent-unions.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Ftransparent-unions.md?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -0,0 +1,83 @@\n+# `transparent_unions`\n+\n+The tracking issue for this feature is [#60405]\n+\n+[60405]: https://github.com/rust-lang/rust/issues/60405\n+\n+----\n+\n+The `transparent_unions` feature allows you mark `union`s as\n+`#[repr(transparent)]`. A `union` may be `#[repr(transparent)]` in exactly the\n+same conditions in which a `struct` may be `#[repr(transparent)]` (generally,\n+this means the `union` must have exactly one non-zero-sized field). Some\n+concrete illustrations follow.\n+\n+```rust\n+#![feature(transparent_unions)]\n+\n+// This union has the same representation as `f32`.\n+#[repr(transparent)]\n+union SingleFieldUnion {\n+    field: f32,\n+}\n+\n+// This union has the same representation as `usize`.\n+#[repr(transparent)]\n+union MultiFieldUnion {\n+    field: usize,\n+    nothing: (),\n+}\n+```\n+\n+For consistency with transparent `struct`s, `union`s must have exactly one\n+non-zero-sized field. If all fields are zero-sized, the `union` must not be\n+`#[repr(transparent)]`:\n+\n+```rust\n+#![feature(transparent_unions)]\n+\n+// This (non-transparent) union is already valid in stable Rust:\n+pub union GoodUnion {\n+    pub nothing: (),\n+}\n+\n+// Error: transparent union needs exactly one non-zero-sized field, but has 0\n+// #[repr(transparent)]\n+// pub union BadUnion {\n+//     pub nothing: (),\n+// }\n+```\n+\n+The one exception is if the `union` is generic over `T` and has a field of type\n+`T`, it may be `#[repr(transparent)]` even if `T` is a zero-sized type:\n+\n+```rust\n+#![feature(transparent_unions)]\n+\n+// This union has the same representation as `T`.\n+#[repr(transparent)]\n+pub union GenericUnion<T: Copy> { // Unions with non-`Copy` fields are unstable.\n+    pub field: T,\n+    pub nothing: (),\n+}\n+\n+// This is okay even though `()` is a zero-sized type.\n+pub const THIS_IS_OKAY: GenericUnion<()> = GenericUnion { field: () };\n+```\n+\n+Like transarent `struct`s, a transparent `union` of type `U` has the same\n+layout, size, and ABI as its single non-ZST field. If it is generic over a type\n+`T`, and all its fields are ZSTs except for exactly one field of type `T`, then\n+it has the same layout and ABI as `T` (even if `T` is a ZST when monomorphized).\n+\n+Like transparent `struct`s, transparent `union`s are FFI-safe if and only if\n+their underlying representation type is also FFI-safe.\n+\n+A `union` may not be eligible for the same nonnull-style optimizations that a\n+`struct` or `enum` (with the same fields) are eligible for. Adding\n+`#[repr(transparent)]` to  `union` does not change this. To give a more concrete\n+example, it is unspecified whether `size_of::<T>()` is equal to\n+`size_of::<Option<T>>()`, where `T` is a `union` (regardless of whether or not\n+it is transparent). The Rust compiler is free to perform this optimization if\n+possible, but is not required to, and different compiler versions may differ in\n+their application of these optimizations."}, {"sha": "bcdeafc4b113717c431d8f833ae20a6a5c54e441", "filename": "src/doc/unstable-book/src/language-features/type-alias-enum-variants.md", "status": "removed", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/33445aea509cadcd715009c79795d289268daa7c/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Ftype-alias-enum-variants.md", "raw_url": "https://github.com/rust-lang/rust/raw/33445aea509cadcd715009c79795d289268daa7c/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Ftype-alias-enum-variants.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Ftype-alias-enum-variants.md?ref=33445aea509cadcd715009c79795d289268daa7c", "patch": "@@ -1,36 +0,0 @@\n-# `type_alias_enum_variants`\n-\n-The tracking issue for this feature is: [#49683]\n-\n-[#49683]: https://github.com/rust-lang/rust/issues/49683\n-\n-------------------------\n-\n-The `type_alias_enum_variants` feature enables the use of variants on type\n-aliases that refer to enums, as both a constructor and a pattern. That is,\n-it allows for the syntax `EnumAlias::Variant`, which behaves exactly the same\n-as `Enum::Variant` (assuming that `EnumAlias` is an alias for some enum type\n-`Enum`).\n-\n-Note that since `Self` exists as a type alias, this feature also enables the\n-use of the syntax `Self::Variant` within an impl block for an enum type.\n-\n-```rust\n-#![feature(type_alias_enum_variants)]\n-\n-enum Foo {\n-    Bar(i32),\n-    Baz { i: i32 },\n-}\n-\n-type Alias = Foo;\n-\n-fn main() {\n-    let t = Alias::Bar(0);\n-    let t = Alias::Baz { i: 0 };\n-    match t {\n-        Alias::Bar(_i) => {}\n-        Alias::Baz { i: _i } => {}\n-    }\n-}\n-```"}, {"sha": "71003fba00ba237e9fed3601258d7aa18c502165", "filename": "src/doc/unstable-book/src/language-features/unboxed-closures.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Funboxed-closures.md", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Funboxed-closures.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Funboxed-closures.md?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -2,7 +2,7 @@\n \n The tracking issue for this feature is [#29625]\n \n-See Also: [`fn_traits`](library-features/fn-traits.html)\n+See Also: [`fn_traits`](../library-features/fn-traits.md)\n \n [#29625]: https://github.com/rust-lang/rust/issues/29625\n "}, {"sha": "343084b7db5016f9fef3ea74be335ea3d4ded529", "filename": "src/doc/unstable-book/src/language-features/unsized-locals.md", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Funsized-locals.md", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Funsized-locals.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flanguage-features%2Funsized-locals.md?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -117,9 +117,7 @@ fn main () {\n }\n ```\n \n-One of the objectives of this feature is to allow `Box<dyn FnOnce>`, instead of `Box<dyn FnBox>` in the future. See [#28796] for details.\n-\n-[#28796]: https://github.com/rust-lang/rust/issues/28796\n+One of the objectives of this feature is to allow `Box<dyn FnOnce>`.\n \n ## Variable length arrays\n "}, {"sha": "2a1b6397781f95fc9a98fbb620c6e5b2dd29aae8", "filename": "src/doc/unstable-book/src/library-features/asm.md", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fasm.md", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fasm.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fasm.md?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -190,4 +190,4 @@ constraints, etc.\n [llvm-docs]: http://llvm.org/docs/LangRef.html#inline-assembler-expressions\n \n If you need more power and don't mind losing some of the niceties of\n-`asm!`, check out [global_asm](language-features/global-asm.html).\n+`asm!`, check out [global_asm](global-asm.md).", "previous_filename": "src/doc/unstable-book/src/language-features/asm.md"}, {"sha": "ecfd34a22e5ccbd39794a260879eb88317088e09", "filename": "src/doc/unstable-book/src/library-features/concat-idents.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fconcat-idents.md", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fconcat-idents.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fconcat-idents.md?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "previous_filename": "src/doc/unstable-book/src/language-features/concat-idents.md"}, {"sha": "ae839bf2ac32b7d96c419045d2a436554ae6445a", "filename": "src/doc/unstable-book/src/library-features/debug-map-key-value.md", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fdebug-map-key-value.md", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fdebug-map-key-value.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fdebug-map-key-value.md?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -0,0 +1,9 @@\n+# `debug_map_key_value`\n+\n+The tracking issue for this feature is: [#62482]\n+\n+[#62482]: https://github.com/rust-lang/rust/issues/62482\n+\n+------------------------\n+\n+Add the methods `key` and `value` to `DebugMap` so that an entry can be formatted across multiple calls without additional buffering."}, {"sha": "29a8aecee6c2fd26e5420a2c06640823e01b99fa", "filename": "src/doc/unstable-book/src/library-features/fn-traits.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Ffn-traits.md", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Ffn-traits.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Ffn-traits.md?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -2,7 +2,7 @@\n \n The tracking issue for this feature is [#29625]\n \n-See Also: [`unboxed_closures`](language-features/unboxed-closures.html)\n+See Also: [`unboxed_closures`](../language-features/unboxed-closures.md)\n \n [#29625]: https://github.com/rust-lang/rust/issues/29625\n "}, {"sha": "bc55fe80fa64c599f954ebdedd613ebba60465e1", "filename": "src/doc/unstable-book/src/library-features/global-asm.md", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fglobal-asm.md", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fglobal-asm.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fglobal-asm.md?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -75,4 +75,4 @@ usages and placed the larger, single usage in the crate root.\n If you don't need quite as much power and flexibility as\n `global_asm!` provides, and you don't mind restricting your inline\n assembly to `fn` bodies only, you might try the\n-[asm](language-features/asm.html) feature instead.\n+[asm](asm.md) feature instead.", "previous_filename": "src/doc/unstable-book/src/language-features/global-asm.md"}, {"sha": "e556adaa13ea738db2fdb9b30069fa8ac06583ea", "filename": "src/doc/unstable-book/src/library-features/n16.md", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/33445aea509cadcd715009c79795d289268daa7c/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fn16.md", "raw_url": "https://github.com/rust-lang/rust/raw/33445aea509cadcd715009c79795d289268daa7c/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fn16.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Fn16.md?ref=33445aea509cadcd715009c79795d289268daa7c", "patch": "@@ -1,5 +0,0 @@\n-# `n16`\n-\n-This feature is internal to the Rust compiler and is not intended for general use.\n-\n-------------------------"}, {"sha": "41aa286e69bfb320a0467ce4659e506093257807", "filename": "src/doc/unstable-book/src/library-features/trace-macros.md", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Ftrace-macros.md", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Ftrace-macros.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Flibrary-features%2Ftrace-macros.md?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "previous_filename": "src/doc/unstable-book/src/language-features/trace-macros.md"}, {"sha": "554c52c3c9c2761c7f6768a51923c7b36fdbf2c5", "filename": "src/doc/unstable-book/src/the-unstable-book.md", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fdoc%2Funstable-book%2Fsrc%2Fthe-unstable-book.md", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fdoc%2Funstable-book%2Fsrc%2Fthe-unstable-book.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fdoc%2Funstable-book%2Fsrc%2Fthe-unstable-book.md?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -14,7 +14,7 @@ fn main() {\n \n The `box_syntax` feature [has a chapter][box] describing how to use it.\n \n-[box]: language-features/box-syntax.html\n+[box]: language-features/box-syntax.md\n \n Because this documentation relates to unstable features, we make no guarantees\n that what is contained here is accurate or up to date. It's developed on a"}, {"sha": "0905789079a3e51c072cfcc0c7c621a0cdde7c02", "filename": "src/etc/cpu-usage-over-time-plot.sh", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fetc%2Fcpu-usage-over-time-plot.sh", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fetc%2Fcpu-usage-over-time-plot.sh", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fcpu-usage-over-time-plot.sh?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -0,0 +1,49 @@\n+#!/bin/bash\n+\n+# A small script to help visualizing CPU usage over time data collected on CI\n+# using `gnuplot`.\n+#\n+# This script is expected to be called with two arguments. The first is the full\n+# commit SHA of the build you're interested in, and the second is the name of\n+# the builder. For example:\n+#\n+#  ./src/etc/cpu-usage-over-time-plot.sh e699ea096fcc2fc9ce8e8bcf884e11496a31cc9f i686-mingw-1\n+#\n+# That will generate `$builder.png` in the current directory which you can open\n+# up to see a hopefully pretty graph.\n+#\n+# Improvements to this script are greatly appreciated!\n+\n+set -ex\n+\n+bucket=rust-lang-ci2\n+commit=$1\n+builder=$2\n+\n+curl -O https://$bucket.s3.amazonaws.com/rustc-builds/$commit/cpu-$builder.csv\n+\n+gnuplot <<-EOF\n+reset\n+set timefmt '%Y-%m-%dT%H:%M:%S'\n+set xdata time\n+set ylabel \"CPU Usage %\"\n+set xlabel \"Time\"\n+set datafile sep ','\n+set term png size 3000,1000\n+set output \"$builder.png\"\n+set grid\n+\n+f(x) = mean_y\n+fit f(x) 'cpu-$builder.csv' using 1:(100-\\$2) via mean_y\n+\n+set label 1 gprintf(\"Average = %g%%\", mean_y) center font \",18\"\n+set label 1 at graph 0.50, 0.25\n+set xtics rotate by 45 offset -2,-2.4 300\n+set ytics 10\n+set boxwidth 0.5\n+\n+plot \\\\\n+   mean_y with lines linetype 1 linecolor rgb \"#ff0000\" title \"average\", \\\\\n+   \"cpu-$builder.csv\" using 1:(100-\\$2) with points pointtype 7 pointsize 0.4 title \"$builder\", \\\\\n+   \"\" using 1:(100-\\$2) smooth bezier linewidth 3 title \"bezier\"\n+EOF"}, {"sha": "fe38c49d2707dcdf9061e2d8fff362c06e62fb3d", "filename": "src/etc/gdb_load_rust_pretty_printers.py", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fetc%2Fgdb_load_rust_pretty_printers.py", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fetc%2Fgdb_load_rust_pretty_printers.py", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fgdb_load_rust_pretty_printers.py?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -1,2 +1,3 @@\n+import gdb\n import gdb_rust_pretty_printing\n gdb_rust_pretty_printing.register_printers(gdb.current_objfile())"}, {"sha": "de30b58526a138eef01dd532d0bdb66b0dbd3a8d", "filename": "src/etc/natvis/liballoc.natvis", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fetc%2Fnatvis%2Fliballoc.natvis", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fetc%2Fnatvis%2Fliballoc.natvis", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fnatvis%2Fliballoc.natvis?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -7,11 +7,11 @@\n       <Item Name=\"[capacity]\" ExcludeView=\"simple\">buf.cap</Item>\n       <ArrayItems>\n         <Size>len</Size>\n-        <ValuePointer>buf.ptr.pointer.__0</ValuePointer>\n+        <ValuePointer>buf.ptr.pointer</ValuePointer>\n       </ArrayItems>\n     </Expand>\n   </Type>\n-  <Type Name=\"alloc::vec_deque::VecDeque&lt;*&gt;\">\n+  <Type Name=\"alloc::collections::vec_deque::VecDeque&lt;*&gt;\">\n     <DisplayString>{{ size={tail &lt;= head ? head - tail : buf.cap - tail + head} }}</DisplayString>\n     <Expand>\n       <Item Name=\"[size]\" ExcludeView=\"simple\">tail &lt;= head ? head - tail : buf.cap - tail + head</Item>\n@@ -24,19 +24,19 @@\n           <If Condition=\"i == head\">\n             <Break/>\n           </If>\n-          <Item>buf.ptr.pointer.__0 + i</Item>\n+          <Item>buf.ptr.pointer[i]</Item>\n           <Exec>i = (i + 1 == buf.cap ? 0 : i + 1)</Exec>\n         </Loop>\n       </CustomListItems>\n     </Expand>\n   </Type>\n-  <Type Name=\"alloc::linked_list::LinkedList&lt;*&gt;\">\n+  <Type Name=\"alloc::collections::linked_list::LinkedList&lt;*&gt;\">\n     <DisplayString>{{ size={len} }}</DisplayString>\n     <Expand>\n       <LinkedListItems>\n         <Size>len</Size>\n-        <HeadPointer>*(alloc::linked_list::Node&lt;$T1&gt; **)&amp;head</HeadPointer>\n-        <NextPointer>*(alloc::linked_list::Node&lt;$T1&gt; **)&amp;next</NextPointer>\n+        <HeadPointer>*(alloc::collections::linked_list::Node&lt;$T1&gt; **)&amp;head</HeadPointer>\n+        <NextPointer>*(alloc::collections::linked_list::Node&lt;$T1&gt; **)&amp;next</NextPointer>\n         <ValueNode>element</ValueNode>\n       </LinkedListItems>\n     </Expand>"}, {"sha": "0e703b3b9502644e30dd527895736e874ba006bb", "filename": "src/etc/natvis/libcore.natvis", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fetc%2Fnatvis%2Flibcore.natvis", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fetc%2Fnatvis%2Flibcore.natvis", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Fnatvis%2Flibcore.natvis?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -1,15 +1,15 @@\n <?xml version=\"1.0\" encoding=\"utf-8\"?>\n <AutoVisualizer xmlns=\"http://schemas.microsoft.com/vstudio/debugger/natvis/2010\">\n   <Type Name=\"core::ptr::Unique&lt;*&gt;\">\n-    <DisplayString>{{ Unique {*pointer.__0} }}</DisplayString>\n+    <DisplayString>{{ Unique {pointer} }}</DisplayString>\n     <Expand>\n-      <Item Name=\"[ptr]\">pointer.__0</Item>\n+      <Item Name=\"[ptr]\">pointer</Item>\n     </Expand>\n   </Type>\n   <Type Name=\"core::ptr::Shared&lt;*&gt;\">\n-    <DisplayString>{{ Shared {*pointer.__0} }}</DisplayString>\n+    <DisplayString>{{ Shared {pointer} }}</DisplayString>\n     <Expand>\n-      <Item Name=\"[ptr]\">pointer.__0</Item>\n+      <Item Name=\"[ptr]\">pointer</Item>\n     </Expand>\n   </Type>\n   <Type Name=\"core::option::Option&lt;*&gt;\">"}, {"sha": "7b9b40e6b4a0afb288f8b8875ef0352d129843fb", "filename": "src/etc/rust-lldb", "status": "modified", "additions": 22, "deletions": 17, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fetc%2Frust-lldb", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fetc%2Frust-lldb", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fetc%2Frust-lldb?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -3,25 +3,30 @@\n # Exit if anything fails\n set -e\n \n-# Find out where to look for the pretty printer Python module\n-RUSTC_SYSROOT=`rustc --print sysroot`\n-\n # Find the host triple so we can find lldb in rustlib.\n-host=`rustc -vV | sed -n -e 's/^host: //p'`\n+host=$(rustc -vV | sed -n -e 's/^host: //p')\n+\n+# Find out where to look for the pretty printer Python module\n+RUSTC_SYSROOT=$(rustc --print sysroot)\n+RUST_LLDB=\"$RUSTC_SYSROOT/lib/rustlib/$host/bin/lldb\"\n \n lldb=lldb\n-if [ -f \"$RUSTC_SYSROOT/lib/rustlib/$host/bin/lldb\" ]; then\n-    lldb=\"$RUSTC_SYSROOT/lib/rustlib/$host/bin/lldb\"\n+if [ -f \"$RUST_LLDB\" ]; then\n+    lldb=\"$RUST_LLDB\"\n else\n-    LLDB_VERSION=`\"$lldb\" --version 2>/dev/null | head -1 | cut -d. -f1`\n+    if ! command -v \"$lldb\" > /dev/null; then\n+        echo \"$lldb not found! Please install it.\" >&2\n+        exit 1\n+    else\n+        LLDB_VERSION=$(\"$lldb\" --version | cut -d ' ' -f3)\n \n-    if [ \"$LLDB_VERSION\" = \"lldb-350\" ]\n-    then\n-        echo \"***\"\n-\techo \\\n-\"WARNING: This version of LLDB has known issues with Rust and cannot \\\n-display the contents of local variables!\"\n-        echo \"***\"\n+        if [ \"$LLDB_VERSION\" = \"3.5.0\" ]; then\n+            cat << EOF >&2\n+***\n+WARNING: This version of LLDB has known issues with Rust and cannot display the contents of local variables!\n+***\n+EOF\n+        fi\n     fi\n fi\n \n@@ -31,7 +36,7 @@ category_definition=\"type summary add --no-value --python-function lldb_rust_for\n category_enable=\"type category enable Rust\"\n \n # Call LLDB with the commands added to the argument list\n-exec \"$lldb\" --one-line-before-file=\"$script_import\" \\\n-    --one-line-before-file=\"$category_definition\" \\\n-    --one-line-before-file=\"$category_enable\" \\\n+exec \"$lldb\" --one-line-before-file \"$script_import\" \\\n+    --one-line-before-file \"$category_definition\" \\\n+    --one-line-before-file \"$category_enable\" \\\n     \"$@\""}, {"sha": "d1119f7b7c0a7f6a83cccaa0aa7c8d0897d5abde", "filename": "src/liballoc/Cargo.toml", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fliballoc%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fliballoc%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2FCargo.toml?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -12,11 +12,11 @@ path = \"lib.rs\"\n \n [dependencies]\n core = { path = \"../libcore\" }\n-compiler_builtins = { version = \"0.1.0\", features = ['rustc-dep-of-std'] }\n+compiler_builtins = { version = \"0.1.10\", features = ['rustc-dep-of-std'] }\n \n [dev-dependencies]\n-rand = \"0.6\"\n-rand_xorshift = \"0.1\"\n+rand = \"0.7\"\n+rand_xorshift = \"0.2\"\n \n [[test]]\n name = \"collectionstests\"\n@@ -33,3 +33,4 @@ harness = false\n \n [features]\n compiler-builtins-mem = ['compiler_builtins/mem']\n+compiler-builtins-c = [\"compiler_builtins/c\"]"}, {"sha": "dc7fd1adc295895016dd2c71f34df41355ca02ea", "filename": "src/liballoc/alloc.rs", "status": "modified", "additions": 22, "deletions": 33, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fliballoc%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fliballoc%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Falloc.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -10,12 +10,15 @@ use core::usize;\n #[doc(inline)]\n pub use core::alloc::*;\n \n+#[cfg(test)]\n+mod tests;\n+\n extern \"Rust\" {\n     // These are the magic symbols to call the global allocator.  rustc generates\n     // them from the `#[global_allocator]` attribute if there is one, or uses the\n     // default implementations in libstd (`__rdl_alloc` etc in `src/libstd/alloc.rs`)\n     // otherwise.\n-    #[allocator]\n+    #[rustc_allocator]\n     #[rustc_allocator_nounwind]\n     fn __rust_alloc(size: usize, align: usize) -> *mut u8;\n     #[rustc_allocator_nounwind]\n@@ -37,6 +40,8 @@ extern \"Rust\" {\n ///\n /// Note: while this type is unstable, the functionality it provides can be\n /// accessed through the [free functions in `alloc`](index.html#functions).\n+///\n+/// [`Alloc`]: trait.Alloc.html\n #[unstable(feature = \"allocator_api\", issue = \"32838\")]\n #[derive(Copy, Clone, Default, Debug)]\n pub struct Global;\n@@ -54,6 +59,10 @@ pub struct Global;\n ///\n /// See [`GlobalAlloc::alloc`].\n ///\n+/// [`Global`]: struct.Global.html\n+/// [`Alloc`]: trait.Alloc.html\n+/// [`GlobalAlloc::alloc`]: trait.GlobalAlloc.html#tymethod.alloc\n+///\n /// # Examples\n ///\n /// ```\n@@ -87,6 +96,10 @@ pub unsafe fn alloc(layout: Layout) -> *mut u8 {\n /// # Safety\n ///\n /// See [`GlobalAlloc::dealloc`].\n+///\n+/// [`Global`]: struct.Global.html\n+/// [`Alloc`]: trait.Alloc.html\n+/// [`GlobalAlloc::dealloc`]: trait.GlobalAlloc.html#tymethod.dealloc\n #[stable(feature = \"global_alloc\", since = \"1.28.0\")]\n #[inline]\n pub unsafe fn dealloc(ptr: *mut u8, layout: Layout) {\n@@ -105,6 +118,10 @@ pub unsafe fn dealloc(ptr: *mut u8, layout: Layout) {\n /// # Safety\n ///\n /// See [`GlobalAlloc::realloc`].\n+///\n+/// [`Global`]: struct.Global.html\n+/// [`Alloc`]: trait.Alloc.html\n+/// [`GlobalAlloc::realloc`]: trait.GlobalAlloc.html#method.realloc\n #[stable(feature = \"global_alloc\", since = \"1.28.0\")]\n #[inline]\n pub unsafe fn realloc(ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8 {\n@@ -124,6 +141,10 @@ pub unsafe fn realloc(ptr: *mut u8, layout: Layout, new_size: usize) -> *mut u8\n ///\n /// See [`GlobalAlloc::alloc_zeroed`].\n ///\n+/// [`Global`]: struct.Global.html\n+/// [`Alloc`]: trait.Alloc.html\n+/// [`GlobalAlloc::alloc_zeroed`]: trait.GlobalAlloc.html#method.alloc_zeroed\n+///\n /// # Examples\n ///\n /// ```\n@@ -226,35 +247,3 @@ pub fn handle_alloc_error(layout: Layout) -> ! {\n     }\n     unsafe { oom_impl(layout) }\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    extern crate test;\n-    use test::Bencher;\n-    use crate::boxed::Box;\n-    use crate::alloc::{Global, Alloc, Layout, handle_alloc_error};\n-\n-    #[test]\n-    fn allocate_zeroed() {\n-        unsafe {\n-            let layout = Layout::from_size_align(1024, 1).unwrap();\n-            let ptr = Global.alloc_zeroed(layout.clone())\n-                .unwrap_or_else(|_| handle_alloc_error(layout));\n-\n-            let mut i = ptr.cast::<u8>().as_ptr();\n-            let end = i.add(layout.size());\n-            while i < end {\n-                assert_eq!(*i, 0);\n-                i = i.offset(1);\n-            }\n-            Global.dealloc(ptr, layout);\n-        }\n-    }\n-\n-    #[bench]\n-    fn alloc_owned_small(b: &mut Bencher) {\n-        b.iter(|| {\n-            let _: Box<_> = box 10;\n-        })\n-    }\n-}"}, {"sha": "c69f4e49ee1e3994e6621496129e54fceea84e52", "filename": "src/liballoc/alloc/tests.rs", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fliballoc%2Falloc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fliballoc%2Falloc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Falloc%2Ftests.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -0,0 +1,30 @@\n+use super::*;\n+\n+extern crate test;\n+use test::Bencher;\n+use crate::boxed::Box;\n+\n+#[test]\n+fn allocate_zeroed() {\n+    unsafe {\n+        let layout = Layout::from_size_align(1024, 1).unwrap();\n+        let ptr = Global.alloc_zeroed(layout.clone())\n+            .unwrap_or_else(|_| handle_alloc_error(layout));\n+\n+        let mut i = ptr.cast::<u8>().as_ptr();\n+        let end = i.add(layout.size());\n+        while i < end {\n+            assert_eq!(*i, 0);\n+            i = i.offset(1);\n+        }\n+        Global.dealloc(ptr, layout);\n+    }\n+}\n+\n+#[bench]\n+#[cfg(not(miri))] // Miri does not support benchmarks\n+fn alloc_owned_small(b: &mut Bencher) {\n+    b.iter(|| {\n+        let _: Box<_> = box 10;\n+    })\n+}"}, {"sha": "6357ea3ea11bd8b99a1d75e759b75af0a8e4916e", "filename": "src/liballoc/benches/btree/set.rs", "status": "modified", "additions": 57, "deletions": 57, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fliballoc%2Fbenches%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fliballoc%2Fbenches%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Fbtree%2Fset.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -3,86 +3,86 @@ use std::collections::BTreeSet;\n use rand::{thread_rng, Rng};\n use test::{black_box, Bencher};\n \n-fn random(n1: u32, n2: u32) -> [BTreeSet<usize>; 2] {\n+fn random(n: usize) -> BTreeSet<usize> {\n     let mut rng = thread_rng();\n-    let mut set1 = BTreeSet::new();\n-    let mut set2 = BTreeSet::new();\n-    for _ in 0..n1 {\n-        let i = rng.gen::<usize>();\n-        set1.insert(i);\n+    let mut set = BTreeSet::new();\n+    while set.len() < n {\n+        set.insert(rng.gen());\n     }\n-    for _ in 0..n2 {\n-        let i = rng.gen::<usize>();\n-        set2.insert(i);\n-    }\n-    [set1, set2]\n+    assert_eq!(set.len(), n);\n+    set\n }\n \n-fn staggered(n1: u32, n2: u32) -> [BTreeSet<u32>; 2] {\n-    let mut even = BTreeSet::new();\n-    let mut odd = BTreeSet::new();\n-    for i in 0..n1 {\n-        even.insert(i * 2);\n-    }\n-    for i in 0..n2 {\n-        odd.insert(i * 2 + 1);\n+fn neg(n: usize) -> BTreeSet<i32> {\n+    let mut set = BTreeSet::new();\n+    for i in -(n as i32)..=-1 {\n+        set.insert(i);\n     }\n-    [even, odd]\n+    assert_eq!(set.len(), n);\n+    set\n }\n \n-fn neg_vs_pos(n1: u32, n2: u32) -> [BTreeSet<i32>; 2] {\n-    let mut neg = BTreeSet::new();\n-    let mut pos = BTreeSet::new();\n-    for i in -(n1 as i32)..=-1 {\n-        neg.insert(i);\n-    }\n-    for i in 1..=(n2 as i32) {\n-        pos.insert(i);\n+fn pos(n: usize) -> BTreeSet<i32> {\n+    let mut set = BTreeSet::new();\n+    for i in 1..=(n as i32) {\n+        set.insert(i);\n     }\n-    [neg, pos]\n+    assert_eq!(set.len(), n);\n+    set\n }\n \n-fn pos_vs_neg(n1: u32, n2: u32) -> [BTreeSet<i32>; 2] {\n-    let mut neg = BTreeSet::new();\n-    let mut pos = BTreeSet::new();\n-    for i in -(n1 as i32)..=-1 {\n-        neg.insert(i);\n-    }\n-    for i in 1..=(n2 as i32) {\n-        pos.insert(i);\n+\n+fn stagger(n1: usize, factor: usize) -> [BTreeSet<u32>; 2] {\n+    let n2 = n1 * factor;\n+    let mut sets = [BTreeSet::new(), BTreeSet::new()];\n+    for i in 0..(n1 + n2) {\n+        let b = i % (factor + 1) != 0;\n+        sets[b as usize].insert(i as u32);\n     }\n-    [pos, neg]\n+    assert_eq!(sets[0].len(), n1);\n+    assert_eq!(sets[1].len(), n2);\n+    sets\n }\n \n-macro_rules! set_intersection_bench {\n-    ($name: ident, $sets: expr) => {\n+macro_rules! set_bench {\n+    ($name: ident, $set_func: ident, $result_func: ident, $sets: expr) => {\n         #[bench]\n         pub fn $name(b: &mut Bencher) {\n             // setup\n             let sets = $sets;\n \n             // measure\n             b.iter(|| {\n-                let x = sets[0].intersection(&sets[1]).count();\n+                let x = sets[0].$set_func(&sets[1]).$result_func();\n                 black_box(x);\n             })\n         }\n     };\n }\n \n-set_intersection_bench! {intersect_random_100,          random(100, 100)}\n-set_intersection_bench! {intersect_random_10k,          random(10_000, 10_000)}\n-set_intersection_bench! {intersect_random_10_vs_10k,    random(10, 10_000)}\n-set_intersection_bench! {intersect_random_10k_vs_10,    random(10_000, 10)}\n-set_intersection_bench! {intersect_staggered_100,       staggered(100, 100)}\n-set_intersection_bench! {intersect_staggered_10k,       staggered(10_000, 10_000)}\n-set_intersection_bench! {intersect_staggered_10_vs_10k, staggered(10, 10_000)}\n-set_intersection_bench! {intersect_staggered_10k_vs_10, staggered(10_000, 10)}\n-set_intersection_bench! {intersect_neg_vs_pos_100,      neg_vs_pos(100, 100)}\n-set_intersection_bench! {intersect_neg_vs_pos_10k,      neg_vs_pos(10_000, 10_000)}\n-set_intersection_bench! {intersect_neg_vs_pos_10_vs_10k,neg_vs_pos(10, 10_000)}\n-set_intersection_bench! {intersect_neg_vs_pos_10k_vs_10,neg_vs_pos(10_000, 10)}\n-set_intersection_bench! {intersect_pos_vs_neg_100,      pos_vs_neg(100, 100)}\n-set_intersection_bench! {intersect_pos_vs_neg_10k,      pos_vs_neg(10_000, 10_000)}\n-set_intersection_bench! {intersect_pos_vs_neg_10_vs_10k,pos_vs_neg(10, 10_000)}\n-set_intersection_bench! {intersect_pos_vs_neg_10k_vs_10,pos_vs_neg(10_000, 10)}\n+set_bench! {intersection_100_neg_vs_100_pos, intersection, count, [neg(100), pos(100)]}\n+set_bench! {intersection_100_neg_vs_10k_pos, intersection, count, [neg(100), pos(10_000)]}\n+set_bench! {intersection_100_pos_vs_100_neg, intersection, count, [pos(100), neg(100)]}\n+set_bench! {intersection_100_pos_vs_10k_neg, intersection, count, [pos(100), neg(10_000)]}\n+set_bench! {intersection_10k_neg_vs_100_pos, intersection, count, [neg(10_000), pos(100)]}\n+set_bench! {intersection_10k_neg_vs_10k_pos, intersection, count, [neg(10_000), pos(10_000)]}\n+set_bench! {intersection_10k_pos_vs_100_neg, intersection, count, [pos(10_000), neg(100)]}\n+set_bench! {intersection_10k_pos_vs_10k_neg, intersection, count, [pos(10_000), neg(10_000)]}\n+set_bench! {intersection_random_100_vs_100, intersection, count, [random(100), random(100)]}\n+set_bench! {intersection_random_100_vs_10k, intersection, count, [random(100), random(10_000)]}\n+set_bench! {intersection_random_10k_vs_100, intersection, count, [random(10_000), random(100)]}\n+set_bench! {intersection_random_10k_vs_10k, intersection, count, [random(10_000), random(10_000)]}\n+set_bench! {intersection_staggered_100_vs_100, intersection, count, stagger(100, 1)}\n+set_bench! {intersection_staggered_10k_vs_10k, intersection, count, stagger(10_000, 1)}\n+set_bench! {intersection_staggered_100_vs_10k, intersection, count, stagger(100, 100)}\n+set_bench! {difference_random_100_vs_100, difference, count, [random(100), random(100)]}\n+set_bench! {difference_random_100_vs_10k, difference, count, [random(100), random(10_000)]}\n+set_bench! {difference_random_10k_vs_100, difference, count, [random(10_000), random(100)]}\n+set_bench! {difference_random_10k_vs_10k, difference, count, [random(10_000), random(10_000)]}\n+set_bench! {difference_staggered_100_vs_100, difference, count, stagger(100, 1)}\n+set_bench! {difference_staggered_10k_vs_10k, difference, count, stagger(10_000, 1)}\n+set_bench! {difference_staggered_100_vs_10k, difference, count, stagger(100, 100)}\n+set_bench! {is_subset_100_vs_100, is_subset, clone, [pos(100), pos(100)]}\n+set_bench! {is_subset_100_vs_10k, is_subset, clone, [pos(100), pos(10_000)]}\n+set_bench! {is_subset_10k_vs_100, is_subset, clone, [pos(10_000), pos(100)]}\n+set_bench! {is_subset_10k_vs_10k, is_subset, clone, [pos(10_000), pos(10_000)]}"}, {"sha": "ef91d801dc72cb6e30c3915486f151bd9113cfe2", "filename": "src/liballoc/benches/slice.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fliballoc%2Fbenches%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fliballoc%2Fbenches%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fbenches%2Fslice.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -186,12 +186,12 @@ const SEED: [u8; 16] = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15];\n \n fn gen_random(len: usize) -> Vec<u64> {\n     let mut rng = XorShiftRng::from_seed(SEED);\n-    rng.sample_iter(&Standard).take(len).collect()\n+    (&mut rng).sample_iter(&Standard).take(len).collect()\n }\n \n fn gen_random_bytes(len: usize) -> Vec<u8> {\n     let mut rng = XorShiftRng::from_seed(SEED);\n-    rng.sample_iter(&Standard).take(len).collect()\n+    (&mut rng).sample_iter(&Standard).take(len).collect()\n }\n \n fn gen_mostly_ascending(len: usize) -> Vec<u64> {\n@@ -221,14 +221,14 @@ fn gen_strings(len: usize) -> Vec<String> {\n     let mut v = vec![];\n     for _ in 0..len {\n         let n = rng.gen::<usize>() % 20 + 1;\n-        v.push(rng.sample_iter(&Alphanumeric).take(n).collect());\n+        v.push((&mut rng).sample_iter(&Alphanumeric).take(n).collect());\n     }\n     v\n }\n \n fn gen_big_random(len: usize) -> Vec<[u64; 16]> {\n     let mut rng = XorShiftRng::from_seed(SEED);\n-    rng.sample_iter(&Standard).map(|x| [x; 16]).take(len).collect()\n+    (&mut rng).sample_iter(&Standard).map(|x| [x; 16]).take(len).collect()\n }\n \n macro_rules! sort {"}, {"sha": "d5e15b3719c2e6cb89cb377c7515730ff8e80698", "filename": "src/liballoc/borrow.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fliballoc%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fliballoc%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fborrow.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -32,6 +32,7 @@ impl<'a, B: ?Sized> Borrow<B> for Cow<'a, B>\n /// from any borrow of a given type.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub trait ToOwned {\n+    /// The resulting type after obtaining ownership.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     type Owned: Borrow<Self>;\n \n@@ -135,7 +136,7 @@ impl<T> ToOwned for T\n /// Another example showing how to keep `Cow` in a struct:\n ///\n /// ```\n-/// use std::borrow::{Cow, ToOwned};\n+/// use std::borrow::Cow;\n ///\n /// struct Items<'a, X: 'a> where [X]: ToOwned<Owned = Vec<X>> {\n ///     values: Cow<'a, [X]>,"}, {"sha": "c92db517cad36111453dee9fa7676fef5bfb96c7", "filename": "src/liballoc/boxed.rs", "status": "modified", "additions": 147, "deletions": 115, "changes": 262, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fliballoc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fliballoc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -1,19 +1,9 @@\n //! A pointer type for heap allocation.\n //!\n-//! `Box<T>`, casually referred to as a 'box', provides the simplest form of\n+//! [`Box<T>`], casually referred to as a 'box', provides the simplest form of\n //! heap allocation in Rust. Boxes provide ownership for this allocation, and\n //! drop their contents when they go out of scope.\n //!\n-//! For non-zero-sized values, a [`Box`] will use the [`Global`] allocator for\n-//! its allocation. It is valid to convert both ways between a [`Box`] and a\n-//! raw pointer allocated with the [`Global`] allocator, given that the\n-//! [`Layout`] used with the allocator is correct for the type. More precisely,\n-//! a `value: *mut T` that has been allocated with the [`Global`] allocator\n-//! with `Layout::for_value(&*value)` may be converted into a box using\n-//! `Box::<T>::from_raw(value)`. Conversely, the memory backing a `value: *mut\n-//! T` obtained from `Box::<T>::into_raw` may be deallocated using the\n-//! [`Global`] allocator with `Layout::for_value(&*value)`.\n-//!\n //! # Examples\n //!\n //! Move a value from the stack to the heap by creating a [`Box`]:\n@@ -58,18 +48,38 @@\n //!\n //! It wouldn't work. This is because the size of a `List` depends on how many\n //! elements are in the list, and so we don't know how much memory to allocate\n-//! for a `Cons`. By introducing a `Box`, which has a defined size, we know how\n+//! for a `Cons`. By introducing a [`Box<T>`], which has a defined size, we know how\n //! big `Cons` needs to be.\n //!\n+//! # Memory layout\n+//!\n+//! For non-zero-sized values, a [`Box`] will use the [`Global`] allocator for\n+//! its allocation. It is valid to convert both ways between a [`Box`] and a\n+//! raw pointer allocated with the [`Global`] allocator, given that the\n+//! [`Layout`] used with the allocator is correct for the type. More precisely,\n+//! a `value: *mut T` that has been allocated with the [`Global`] allocator\n+//! with `Layout::for_value(&*value)` may be converted into a box using\n+//! [`Box::<T>::from_raw(value)`]. Conversely, the memory backing a `value: *mut\n+//! T` obtained from [`Box::<T>::into_raw`] may be deallocated using the\n+//! [`Global`] allocator with [`Layout::for_value(&*value)`].\n+//!\n+//!\n //! [dereferencing]: ../../std/ops/trait.Deref.html\n //! [`Box`]: struct.Box.html\n+//! [`Box<T>`]: struct.Box.html\n+//! [`Box::<T>::from_raw(value)`]: struct.Box.html#method.from_raw\n+//! [`Box::<T>::into_raw`]: struct.Box.html#method.into_raw\n+//! [`Global`]: ../alloc/struct.Global.html\n+//! [`Layout`]: ../alloc/struct.Layout.html\n+//! [`Layout::for_value(&*value)`]: ../alloc/struct.Layout.html#method.for_value\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n use core::any::Any;\n+use core::array::LengthAtMost32;\n use core::borrow;\n use core::cmp::Ordering;\n-use core::convert::From;\n+use core::convert::{From, TryFrom};\n use core::fmt;\n use core::future::Future;\n use core::hash::{Hash, Hasher};\n@@ -81,7 +91,7 @@ use core::ops::{\n     CoerceUnsized, DispatchFromDyn, Deref, DerefMut, Receiver, Generator, GeneratorState\n };\n use core::ptr::{self, NonNull, Unique};\n-use core::task::{Waker, Poll};\n+use core::task::{Context, Poll};\n \n use crate::vec::Vec;\n use crate::raw_vec::RawVec;\n@@ -125,24 +135,38 @@ impl<T: ?Sized> Box<T> {\n     ///\n     /// After calling this function, the raw pointer is owned by the\n     /// resulting `Box`. Specifically, the `Box` destructor will call\n-    /// the destructor of `T` and free the allocated memory. Since the\n-    /// way `Box` allocates and releases memory is unspecified, the\n-    /// only valid pointer to pass to this function is the one taken\n-    /// from another `Box` via the [`Box::into_raw`] function.\n+    /// the destructor of `T` and free the allocated memory. For this\n+    /// to be safe, the memory must have been allocated in accordance\n+    /// with the [memory layout] used by `Box` .\n+    ///\n+    /// # Safety\n     ///\n     /// This function is unsafe because improper use may lead to\n     /// memory problems. For example, a double-free may occur if the\n     /// function is called twice on the same raw pointer.\n     ///\n-    /// [`Box::into_raw`]: struct.Box.html#method.into_raw\n-    ///\n     /// # Examples\n-    ///\n+    /// Recreate a `Box` which was previously converted to a raw pointer\n+    /// using [`Box::into_raw`]:\n     /// ```\n     /// let x = Box::new(5);\n     /// let ptr = Box::into_raw(x);\n     /// let x = unsafe { Box::from_raw(ptr) };\n     /// ```\n+    /// Manually create a `Box` from scratch by using the global allocator:\n+    /// ```\n+    /// use std::alloc::{alloc, Layout};\n+    ///\n+    /// unsafe {\n+    ///     let ptr = alloc(Layout::new::<i32>()) as *mut i32;\n+    ///     *ptr = 5;\n+    ///     let x = Box::from_raw(ptr);\n+    /// }\n+    /// ```\n+    ///\n+    /// [memory layout]: index.html#memory-layout\n+    /// [`Layout`]: ../alloc/struct.Layout.html\n+    /// [`Box::into_raw`]: struct.Box.html#method.into_raw\n     #[stable(feature = \"box_raw\", since = \"1.4.0\")]\n     #[inline]\n     pub unsafe fn from_raw(raw: *mut T) -> Self {\n@@ -155,22 +179,40 @@ impl<T: ?Sized> Box<T> {\n     ///\n     /// After calling this function, the caller is responsible for the\n     /// memory previously managed by the `Box`. In particular, the\n-    /// caller should properly destroy `T` and release the memory. The\n-    /// proper way to do so is to convert the raw pointer back into a\n-    /// `Box` with the [`Box::from_raw`] function.\n+    /// caller should properly destroy `T` and release the memory, taking\n+    /// into account the [memory layout] used by `Box`. The easiest way to\n+    /// do this is to convert the raw pointer back into a `Box` with the\n+    /// [`Box::from_raw`] function, allowing the `Box` destructor to perform\n+    /// the cleanup.\n     ///\n     /// Note: this is an associated function, which means that you have\n     /// to call it as `Box::into_raw(b)` instead of `b.into_raw()`. This\n     /// is so that there is no conflict with a method on the inner type.\n     ///\n-    /// [`Box::from_raw`]: struct.Box.html#method.from_raw\n-    ///\n     /// # Examples\n-    ///\n+    /// Converting the raw pointer back into a `Box` with [`Box::from_raw`]\n+    /// for automatic cleanup:\n     /// ```\n-    /// let x = Box::new(5);\n+    /// let x = Box::new(String::from(\"Hello\"));\n     /// let ptr = Box::into_raw(x);\n+    /// let x = unsafe { Box::from_raw(ptr) };\n     /// ```\n+    /// Manual cleanup by explicitly running the destructor and deallocating\n+    /// the memory:\n+    /// ```\n+    /// use std::alloc::{dealloc, Layout};\n+    /// use std::ptr;\n+    ///\n+    /// let x = Box::new(String::from(\"Hello\"));\n+    /// let p = Box::into_raw(x);\n+    /// unsafe {\n+    ///     ptr::drop_in_place(p);\n+    ///     dealloc(p as *mut u8, Layout::new::<String>());\n+    /// }\n+    /// ```\n+    ///\n+    /// [memory layout]: index.html#memory-layout\n+    /// [`Box::from_raw`]: struct.Box.html#method.from_raw\n     #[stable(feature = \"box_raw\", since = \"1.4.0\")]\n     #[inline]\n     pub fn into_raw(b: Box<T>) -> *mut T {\n@@ -182,7 +224,7 @@ impl<T: ?Sized> Box<T> {\n     /// After calling this function, the caller is responsible for the\n     /// memory previously managed by the `Box`. In particular, the\n     /// caller should properly destroy `T` and release the memory. The\n-    /// proper way to do so is to convert the `NonNull<T>` pointer\n+    /// easiest way to do so is to convert the `NonNull<T>` pointer\n     /// into a raw pointer and back into a `Box` with the [`Box::from_raw`]\n     /// function.\n     ///\n@@ -201,6 +243,10 @@ impl<T: ?Sized> Box<T> {\n     /// fn main() {\n     ///     let x = Box::new(5);\n     ///     let ptr = Box::into_raw_non_null(x);\n+    ///\n+    ///     // Clean up the memory by converting the NonNull pointer back\n+    ///     // into a Box and letting the Box be dropped.\n+    ///     let x = unsafe { Box::from_raw(ptr.as_ptr()) };\n     /// }\n     /// ```\n     #[unstable(feature = \"box_into_raw_non_null\", issue = \"47336\")]\n@@ -212,15 +258,16 @@ impl<T: ?Sized> Box<T> {\n     #[unstable(feature = \"ptr_internals\", issue = \"0\", reason = \"use into_raw_non_null instead\")]\n     #[inline]\n     #[doc(hidden)]\n-    pub fn into_unique(mut b: Box<T>) -> Unique<T> {\n+    pub fn into_unique(b: Box<T>) -> Unique<T> {\n+        let mut unique = b.0;\n+        mem::forget(b);\n         // Box is kind-of a library type, but recognized as a \"unique pointer\" by\n         // Stacked Borrows.  This function here corresponds to \"reborrowing to\n         // a raw pointer\", but there is no actual reborrow here -- so\n         // without some care, the pointer we are returning here still carries\n-        // the `Uniq` tag.  We round-trip through a mutable reference to avoid that.\n-        let unique = unsafe { b.0.as_mut() as *mut T };\n-        mem::forget(b);\n-        unsafe { Unique::new_unchecked(unique) }\n+        // the tag of `b`, with `Unique` permission.\n+        // We round-trip through a mutable reference to avoid that.\n+        unsafe { Unique::new_unchecked(unique.as_mut() as *mut T) }\n     }\n \n     /// Consumes and leaks the `Box`, returning a mutable reference,\n@@ -278,7 +325,7 @@ impl<T: ?Sized> Box<T> {\n     /// This conversion does not allocate on the heap and happens in place.\n     ///\n     /// This is also available via [`From`].\n-    #[unstable(feature = \"box_into_pin\", issue = \"0\")]\n+    #[unstable(feature = \"box_into_pin\", issue = \"62370\")]\n     pub fn into_pin(boxed: Box<T>) -> Pin<Box<T>> {\n         // It's not possible to move or replace the insides of a `Pin<Box<T>>`\n         // when `T: !Unpin`,  so it's safe to pin it directly without any\n@@ -325,23 +372,35 @@ impl<T: Clone> Clone for Box<T> {\n     /// ```\n     /// let x = Box::new(5);\n     /// let y = x.clone();\n+    ///\n+    /// // The value is the same\n+    /// assert_eq!(x, y);\n+    ///\n+    /// // But they are unique objects\n+    /// assert_ne!(&*x as *const i32, &*y as *const i32);\n     /// ```\n     #[rustfmt::skip]\n     #[inline]\n     fn clone(&self) -> Box<T> {\n         box { (**self).clone() }\n     }\n+\n     /// Copies `source`'s contents into `self` without creating a new allocation.\n     ///\n     /// # Examples\n     ///\n     /// ```\n     /// let x = Box::new(5);\n     /// let mut y = Box::new(10);\n+    /// let yp: *const i32 = &*y;\n     ///\n     /// y.clone_from(&x);\n     ///\n-    /// assert_eq!(*y, 5);\n+    /// // The value is the same\n+    /// assert_eq!(x, y);\n+    ///\n+    /// // And no allocation occurred\n+    /// assert_eq!(yp, &*y);\n     /// ```\n     #[inline]\n     fn clone_from(&mut self, source: &Box<T>) {\n@@ -353,11 +412,10 @@ impl<T: Clone> Clone for Box<T> {\n #[stable(feature = \"box_slice_clone\", since = \"1.3.0\")]\n impl Clone for Box<str> {\n     fn clone(&self) -> Self {\n-        let len = self.len();\n-        let buf = RawVec::with_capacity(len);\n+        // this makes a copy of the data\n+        let buf: Box<[u8]> = self.as_bytes().into();\n         unsafe {\n-            ptr::copy_nonoverlapping(self.as_ptr(), buf.ptr(), len);\n-            from_boxed_utf8_unchecked(buf.into_box())\n+            from_boxed_utf8_unchecked(buf)\n         }\n     }\n }\n@@ -504,9 +562,12 @@ impl<T: Copy> From<&[T]> for Box<[T]> {\n     /// println!(\"{:?}\", boxed_slice);\n     /// ```\n     fn from(slice: &[T]) -> Box<[T]> {\n-        let mut boxed = unsafe { RawVec::with_capacity(slice.len()).into_box() };\n-        boxed.copy_from_slice(slice);\n-        boxed\n+        let len = slice.len();\n+        let buf = RawVec::with_capacity(len);\n+        unsafe {\n+            ptr::copy_nonoverlapping(slice.as_ptr(), buf.ptr(), len);\n+            buf.into_box()\n+        }\n     }\n }\n \n@@ -552,6 +613,22 @@ impl From<Box<str>> for Box<[u8]> {\n     }\n }\n \n+#[unstable(feature = \"boxed_slice_try_from\", issue = \"0\")]\n+impl<T, const N: usize> TryFrom<Box<[T]>> for Box<[T; N]>\n+where\n+    [T; N]: LengthAtMost32,\n+{\n+    type Error = Box<[T]>;\n+\n+    fn try_from(boxed_slice: Box<[T]>) -> Result<Self, Self::Error> {\n+        if boxed_slice.len() == N {\n+            Ok(unsafe { Box::from_raw(Box::into_raw(boxed_slice) as *mut [T; N]) })\n+        } else {\n+            Err(boxed_slice)\n+        }\n+    }\n+}\n+\n impl Box<dyn Any> {\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -672,11 +749,22 @@ impl<I: Iterator + ?Sized> Iterator for Box<I> {\n         (**self).nth(n)\n     }\n }\n+\n+#[stable(feature = \"rust1\", since = \"1.0.0\")]\n+impl<I: Iterator + Sized> Iterator for Box<I> {\n+    fn last(self) -> Option<I::Item> where I: Sized {\n+        (*self).last()\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I: DoubleEndedIterator + ?Sized> DoubleEndedIterator for Box<I> {\n     fn next_back(&mut self) -> Option<I::Item> {\n         (**self).next_back()\n     }\n+    fn nth_back(&mut self, n: usize) -> Option<I::Item> {\n+        (**self).nth_back(n)\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<I: ExactSizeIterator + ?Sized> ExactSizeIterator for Box<I> {\n@@ -691,82 +779,26 @@ impl<I: ExactSizeIterator + ?Sized> ExactSizeIterator for Box<I> {\n #[stable(feature = \"fused\", since = \"1.26.0\")]\n impl<I: FusedIterator + ?Sized> FusedIterator for Box<I> {}\n \n+#[stable(feature = \"boxed_closure_impls\", since = \"1.35.0\")]\n+impl<A, F: FnOnce<A> + ?Sized> FnOnce<A> for Box<F> {\n+    type Output = <F as FnOnce<A>>::Output;\n \n-/// `FnBox` is a version of the `FnOnce` intended for use with boxed\n-/// closure objects. The idea is that where one would normally store a\n-/// `Box<dyn FnOnce()>` in a data structure, you should use\n-/// `Box<dyn FnBox()>`. The two traits behave essentially the same, except\n-/// that a `FnBox` closure can only be called if it is boxed. (Note\n-/// that `FnBox` may be deprecated in the future if `Box<dyn FnOnce()>`\n-/// closures become directly usable.)\n-///\n-/// # Examples\n-///\n-/// Here is a snippet of code which creates a hashmap full of boxed\n-/// once closures and then removes them one by one, calling each\n-/// closure as it is removed. Note that the type of the closures\n-/// stored in the map is `Box<dyn FnBox() -> i32>` and not `Box<dyn FnOnce()\n-/// -> i32>`.\n-///\n-/// ```\n-/// #![feature(fnbox)]\n-///\n-/// use std::boxed::FnBox;\n-/// use std::collections::HashMap;\n-///\n-/// fn make_map() -> HashMap<i32, Box<dyn FnBox() -> i32>> {\n-///     let mut map: HashMap<i32, Box<dyn FnBox() -> i32>> = HashMap::new();\n-///     map.insert(1, Box::new(|| 22));\n-///     map.insert(2, Box::new(|| 44));\n-///     map\n-/// }\n-///\n-/// fn main() {\n-///     let mut map = make_map();\n-///     for i in &[1, 2] {\n-///         let f = map.remove(&i).unwrap();\n-///         assert_eq!(f(), i * 22);\n-///     }\n-/// }\n-/// ```\n-#[rustc_paren_sugar]\n-#[unstable(feature = \"fnbox\",\n-           reason = \"will be deprecated if and when `Box<FnOnce>` becomes usable\", issue = \"28796\")]\n-pub trait FnBox<A> {\n-    type Output;\n-\n-    fn call_box(self: Box<Self>, args: A) -> Self::Output;\n-}\n-\n-#[unstable(feature = \"fnbox\",\n-           reason = \"will be deprecated if and when `Box<FnOnce>` becomes usable\", issue = \"28796\")]\n-impl<A, F> FnBox<A> for F\n-    where F: FnOnce<A>\n-{\n-    type Output = F::Output;\n-\n-    fn call_box(self: Box<F>, args: A) -> F::Output {\n-        self.call_once(args)\n+    extern \"rust-call\" fn call_once(self, args: A) -> Self::Output {\n+        <F as FnOnce<A>>::call_once(*self, args)\n     }\n }\n \n-#[unstable(feature = \"fnbox\",\n-           reason = \"will be deprecated if and when `Box<FnOnce>` becomes usable\", issue = \"28796\")]\n-impl<A, R> FnOnce<A> for Box<dyn FnBox<A, Output = R> + '_> {\n-    type Output = R;\n-\n-    extern \"rust-call\" fn call_once(self, args: A) -> R {\n-        self.call_box(args)\n+#[stable(feature = \"boxed_closure_impls\", since = \"1.35.0\")]\n+impl<A, F: FnMut<A> + ?Sized> FnMut<A> for Box<F> {\n+    extern \"rust-call\" fn call_mut(&mut self, args: A) -> Self::Output {\n+        <F as FnMut<A>>::call_mut(self, args)\n     }\n }\n \n-#[unstable(feature = \"fnbox\",\n-           reason = \"will be deprecated if and when `Box<FnOnce>` becomes usable\", issue = \"28796\")]\n-impl<A, R> FnOnce<A> for Box<dyn FnBox<A, Output = R> + Send + '_> {\n-    type Output = R;\n-\n-    extern \"rust-call\" fn call_once(self, args: A) -> R {\n-        self.call_box(args)\n+#[stable(feature = \"boxed_closure_impls\", since = \"1.35.0\")]\n+impl<A, F: Fn<A> + ?Sized> Fn<A> for Box<F> {\n+    extern \"rust-call\" fn call(&self, args: A) -> Self::Output {\n+        <F as Fn<A>>::call(self, args)\n     }\n }\n \n@@ -907,11 +939,11 @@ impl<G: ?Sized + Generator> Generator for Pin<Box<G>> {\n     }\n }\n \n-#[unstable(feature = \"futures_api\", issue = \"50547\")]\n+#[stable(feature = \"futures_api\", since = \"1.36.0\")]\n impl<F: ?Sized + Future + Unpin> Future for Box<F> {\n     type Output = F::Output;\n \n-    fn poll(mut self: Pin<&mut Self>, waker: &Waker) -> Poll<Self::Output> {\n-        F::poll(Pin::new(&mut *self), waker)\n+    fn poll(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output> {\n+        F::poll(Pin::new(&mut *self), cx)\n     }\n }"}, {"sha": "654eabd0703263d7464480e102a636ac4183cc89", "filename": "src/liballoc/boxed_test.rs", "status": "removed", "additions": 0, "deletions": 140, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/33445aea509cadcd715009c79795d289268daa7c/src%2Fliballoc%2Fboxed_test.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33445aea509cadcd715009c79795d289268daa7c/src%2Fliballoc%2Fboxed_test.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fboxed_test.rs?ref=33445aea509cadcd715009c79795d289268daa7c", "patch": "@@ -1,140 +0,0 @@\n-//! Test for `boxed` mod.\n-\n-use core::any::Any;\n-use core::ops::Deref;\n-use core::result::Result::{Err, Ok};\n-use core::clone::Clone;\n-use core::f64;\n-use core::i64;\n-\n-use std::boxed::Box;\n-\n-#[test]\n-fn test_owned_clone() {\n-    let a = Box::new(5);\n-    let b: Box<i32> = a.clone();\n-    assert!(a == b);\n-}\n-\n-#[derive(PartialEq, Eq)]\n-struct Test;\n-\n-#[test]\n-fn any_move() {\n-    let a = Box::new(8) as Box<dyn Any>;\n-    let b = Box::new(Test) as Box<dyn Any>;\n-\n-    match a.downcast::<i32>() {\n-        Ok(a) => {\n-            assert!(a == Box::new(8));\n-        }\n-        Err(..) => panic!(),\n-    }\n-    match b.downcast::<Test>() {\n-        Ok(a) => {\n-            assert!(a == Box::new(Test));\n-        }\n-        Err(..) => panic!(),\n-    }\n-\n-    let a = Box::new(8) as Box<dyn Any>;\n-    let b = Box::new(Test) as Box<dyn Any>;\n-\n-    assert!(a.downcast::<Box<Test>>().is_err());\n-    assert!(b.downcast::<Box<i32>>().is_err());\n-}\n-\n-#[test]\n-fn test_show() {\n-    let a = Box::new(8) as Box<dyn Any>;\n-    let b = Box::new(Test) as Box<dyn Any>;\n-    let a_str = format!(\"{:?}\", a);\n-    let b_str = format!(\"{:?}\", b);\n-    assert_eq!(a_str, \"Any\");\n-    assert_eq!(b_str, \"Any\");\n-\n-    static EIGHT: usize = 8;\n-    static TEST: Test = Test;\n-    let a = &EIGHT as &dyn Any;\n-    let b = &TEST as &dyn Any;\n-    let s = format!(\"{:?}\", a);\n-    assert_eq!(s, \"Any\");\n-    let s = format!(\"{:?}\", b);\n-    assert_eq!(s, \"Any\");\n-}\n-\n-#[test]\n-fn deref() {\n-    fn homura<T: Deref<Target = i32>>(_: T) {}\n-    homura(Box::new(765));\n-}\n-\n-#[test]\n-fn raw_sized() {\n-    let x = Box::new(17);\n-    let p = Box::into_raw(x);\n-    unsafe {\n-        assert_eq!(17, *p);\n-        *p = 19;\n-        let y = Box::from_raw(p);\n-        assert_eq!(19, *y);\n-    }\n-}\n-\n-#[test]\n-fn raw_trait() {\n-    trait Foo {\n-        fn get(&self) -> u32;\n-        fn set(&mut self, value: u32);\n-    }\n-\n-    struct Bar(u32);\n-\n-    impl Foo for Bar {\n-        fn get(&self) -> u32 {\n-            self.0\n-        }\n-\n-        fn set(&mut self, value: u32) {\n-            self.0 = value;\n-        }\n-    }\n-\n-    let x: Box<dyn Foo> = Box::new(Bar(17));\n-    let p = Box::into_raw(x);\n-    unsafe {\n-        assert_eq!(17, (*p).get());\n-        (*p).set(19);\n-        let y: Box<dyn Foo> = Box::from_raw(p);\n-        assert_eq!(19, y.get());\n-    }\n-}\n-\n-#[test]\n-fn f64_slice() {\n-    let slice: &[f64] = &[-1.0, 0.0, 1.0, f64::INFINITY];\n-    let boxed: Box<[f64]> = Box::from(slice);\n-    assert_eq!(&*boxed, slice)\n-}\n-\n-#[test]\n-fn i64_slice() {\n-    let slice: &[i64] = &[i64::MIN, -2, -1, 0, 1, 2, i64::MAX];\n-    let boxed: Box<[i64]> = Box::from(slice);\n-    assert_eq!(&*boxed, slice)\n-}\n-\n-#[test]\n-fn str_slice() {\n-    let s = \"Hello, world!\";\n-    let boxed: Box<str> = Box::from(s);\n-    assert_eq!(&*boxed, s)\n-}\n-\n-#[test]\n-fn boxed_slice_from_iter() {\n-    let iter = 0..100;\n-    let boxed: Box<[u32]> = iter.collect();\n-    assert_eq!(boxed.len(), 100);\n-    assert_eq!(boxed[7], 7);\n-}"}, {"sha": "9f531f5b83c75d6444b56ba7bb82aec8d1c5a929", "filename": "src/liballoc/collections/binary_heap.rs", "status": "modified", "additions": 73, "deletions": 3, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbinary_heap.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -207,6 +207,44 @@ use super::SpecExtend;\n /// // The heap should now be empty.\n /// assert!(heap.is_empty())\n /// ```\n+///\n+/// ## Min-heap\n+///\n+/// Either `std::cmp::Reverse` or a custom `Ord` implementation can be used to\n+/// make `BinaryHeap` a min-heap. This makes `heap.pop()` return the smallest\n+/// value instead of the greatest one.\n+///\n+/// ```\n+/// use std::collections::BinaryHeap;\n+/// use std::cmp::Reverse;\n+///\n+/// let mut heap = BinaryHeap::new();\n+///\n+/// // Wrap values in `Reverse`\n+/// heap.push(Reverse(1));\n+/// heap.push(Reverse(5));\n+/// heap.push(Reverse(2));\n+///\n+/// // If we pop these scores now, they should come back in the reverse order.\n+/// assert_eq!(heap.pop(), Some(Reverse(1)));\n+/// assert_eq!(heap.pop(), Some(Reverse(2)));\n+/// assert_eq!(heap.pop(), Some(Reverse(5)));\n+/// assert_eq!(heap.pop(), None);\n+/// ```\n+///\n+/// # Time complexity\n+///\n+/// | [push] | [pop]    | [peek]/[peek\\_mut] |\n+/// |--------|----------|--------------------|\n+/// | O(1)~  | O(log n) | O(1)               |\n+///\n+/// The value for `push` is an expected cost; the method documentation gives a\n+/// more detailed analysis.\n+///\n+/// [push]: #method.push\n+/// [pop]: #method.pop\n+/// [peek]: #method.peek\n+/// [peek\\_mut]: #method.peek_mut\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct BinaryHeap<T> {\n     data: Vec<T>,\n@@ -360,6 +398,10 @@ impl<T: Ord> BinaryHeap<T> {\n     /// }\n     /// assert_eq!(heap.peek(), Some(&2));\n     /// ```\n+    ///\n+    /// # Time complexity\n+    ///\n+    /// Cost is O(1) in the worst case.\n     #[stable(feature = \"binary_heap_peek_mut\", since = \"1.12.0\")]\n     pub fn peek_mut(&mut self) -> Option<PeekMut<'_, T>> {\n         if self.is_empty() {\n@@ -387,6 +429,11 @@ impl<T: Ord> BinaryHeap<T> {\n     /// assert_eq!(heap.pop(), Some(1));\n     /// assert_eq!(heap.pop(), None);\n     /// ```\n+    ///\n+    /// # Time complexity\n+    ///\n+    /// The worst case cost of `pop` on a heap containing *n* elements is O(log\n+    /// n).\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn pop(&mut self) -> Option<T> {\n         self.data.pop().map(|mut item| {\n@@ -414,6 +461,22 @@ impl<T: Ord> BinaryHeap<T> {\n     /// assert_eq!(heap.len(), 3);\n     /// assert_eq!(heap.peek(), Some(&5));\n     /// ```\n+    ///\n+    /// # Time complexity\n+    ///\n+    /// The expected cost of `push`, averaged over every possible ordering of\n+    /// the elements being pushed, and over a sufficiently large number of\n+    /// pushes, is O(1). This is the most meaningful cost metric when pushing\n+    /// elements that are *not* already in any sorted pattern.\n+    ///\n+    /// The time complexity degrades if elements are pushed in predominantly\n+    /// ascending order. In the worst case, elements are pushed in ascending\n+    /// sorted order and the amortized cost per push is O(log n) against a heap\n+    /// containing *n* elements.\n+    ///\n+    /// The worst case cost of a *single* call to `push` is O(n). The worst case\n+    /// occurs when capacity is exhausted and needs a resize. The resize cost\n+    /// has been amortized in the previous figures.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn push(&mut self, item: T) {\n         let old_len = self.len();\n@@ -626,6 +689,10 @@ impl<T> BinaryHeap<T> {\n     /// assert_eq!(heap.peek(), Some(&5));\n     ///\n     /// ```\n+    ///\n+    /// # Time complexity\n+    ///\n+    /// Cost is O(1) in the worst case.\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn peek(&self) -> Option<&T> {\n         self.data.get(0)\n@@ -968,6 +1035,11 @@ impl<'a, T> Iterator for Iter<'a, T> {\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         self.iter.size_hint()\n     }\n+\n+    #[inline]\n+    fn last(self) -> Option<&'a T> {\n+        self.iter.last()\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1177,9 +1249,7 @@ impl<T: Ord> BinaryHeap<T> {\n \n         self.reserve(lower);\n \n-        for elem in iterator {\n-            self.push(elem);\n-        }\n+        iterator.for_each(move |elem| self.push(elem));\n     }\n }\n "}, {"sha": "1683b8105567f7f10c135f1dd1dca1abea12e13c", "filename": "src/liballoc/collections/btree/map.rs", "status": "modified", "additions": 43, "deletions": 15, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -75,10 +75,10 @@ use Entry::*;\n ///\n /// // look up the values associated with some keys.\n /// let to_find = [\"Up!\", \"Office Space\"];\n-/// for book in &to_find {\n-///     match movie_reviews.get(book) {\n-///        Some(review) => println!(\"{}: {}\", book, review),\n-///        None => println!(\"{} is unreviewed.\", book)\n+/// for movie in &to_find {\n+///     match movie_reviews.get(movie) {\n+///        Some(review) => println!(\"{}: {}\", movie, review),\n+///        None => println!(\"{} is unreviewed.\", movie)\n ///     }\n /// }\n ///\n@@ -200,7 +200,7 @@ impl<K: Clone, V: Clone> Clone for BTreeMap<K, V> {\n             }\n         }\n \n-        if self.len() == 0 {\n+        if self.is_empty() {\n             // Ideally we'd call `BTreeMap::new` here, but that has the `K:\n             // Ord` constraint, which this method lacks.\n             BTreeMap {\n@@ -759,19 +759,19 @@ impl<K: Ord, V> BTreeMap<K, V> {\n     #[stable(feature = \"btree_append\", since = \"1.11.0\")]\n     pub fn append(&mut self, other: &mut Self) {\n         // Do we have to append anything at all?\n-        if other.len() == 0 {\n+        if other.is_empty() {\n             return;\n         }\n \n         // We can just swap `self` and `other` if `self` is empty.\n-        if self.len() == 0 {\n+        if self.is_empty() {\n             mem::swap(self, other);\n             return;\n         }\n \n         // First, we merge `self` and `other` into a sorted sequence in linear time.\n-        let self_iter = mem::replace(self, BTreeMap::new()).into_iter();\n-        let other_iter = mem::replace(other, BTreeMap::new()).into_iter();\n+        let self_iter = mem::take(self).into_iter();\n+        let other_iter = mem::take(other).into_iter();\n         let iter = MergeIter {\n             left: self_iter.peekable(),\n             right: other_iter.peekable(),\n@@ -1193,6 +1193,10 @@ impl<'a, K: 'a, V: 'a> Iterator for Iter<'a, K, V> {\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         (self.length, Some(self.length))\n     }\n+\n+    fn last(mut self) -> Option<(&'a K, &'a V)> {\n+        self.next_back()\n+    }\n }\n \n #[stable(feature = \"fused\", since = \"1.26.0\")]\n@@ -1253,6 +1257,10 @@ impl<'a, K: 'a, V: 'a> Iterator for IterMut<'a, K, V> {\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         (self.length, Some(self.length))\n     }\n+\n+    fn last(mut self) -> Option<(&'a K, &'a mut V)> {\n+        self.next_back()\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1421,6 +1429,10 @@ impl<'a, K, V> Iterator for Keys<'a, K, V> {\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         self.inner.size_hint()\n     }\n+\n+    fn last(mut self) -> Option<&'a K> {\n+        self.next_back()\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1458,6 +1470,10 @@ impl<'a, K, V> Iterator for Values<'a, K, V> {\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         self.inner.size_hint()\n     }\n+\n+    fn last(mut self) -> Option<&'a V> {\n+        self.next_back()\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -1495,6 +1511,10 @@ impl<'a, K, V> Iterator for Range<'a, K, V> {\n             unsafe { Some(self.next_unchecked()) }\n         }\n     }\n+\n+    fn last(mut self) -> Option<(&'a K, &'a V)> {\n+        self.next_back()\n+    }\n }\n \n #[stable(feature = \"map_values_mut\", since = \"1.10.0\")]\n@@ -1508,6 +1528,10 @@ impl<'a, K, V> Iterator for ValuesMut<'a, K, V> {\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         self.inner.size_hint()\n     }\n+\n+    fn last(mut self) -> Option<&'a mut V> {\n+        self.next_back()\n+    }\n }\n \n #[stable(feature = \"map_values_mut\", since = \"1.10.0\")]\n@@ -1626,6 +1650,10 @@ impl<'a, K, V> Iterator for RangeMut<'a, K, V> {\n             unsafe { Some(self.next_unchecked()) }\n         }\n     }\n+\n+    fn last(mut self) -> Option<(&'a K, &'a mut V)> {\n+        self.next_back()\n+    }\n }\n \n impl<'a, K, V> RangeMut<'a, K, V> {\n@@ -1727,9 +1755,9 @@ impl<K: Ord, V> FromIterator<(K, V)> for BTreeMap<K, V> {\n impl<K: Ord, V> Extend<(K, V)> for BTreeMap<K, V> {\n     #[inline]\n     fn extend<T: IntoIterator<Item = (K, V)>>(&mut self, iter: T) {\n-        for (k, v) in iter {\n+        iter.into_iter().for_each(move |(k, v)| {\n             self.insert(k, v);\n-        }\n+        });\n     }\n }\n \n@@ -2004,7 +2032,7 @@ impl<K, V> BTreeMap<K, V> {\n     /// assert_eq!(keys, [1, 2]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn keys<'a>(&'a self) -> Keys<'a, K, V> {\n+    pub fn keys(&self) -> Keys<'_, K, V> {\n         Keys { inner: self.iter() }\n     }\n \n@@ -2025,7 +2053,7 @@ impl<K, V> BTreeMap<K, V> {\n     /// assert_eq!(values, [\"hello\", \"goodbye\"]);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn values<'a>(&'a self) -> Values<'a, K, V> {\n+    pub fn values(&self) -> Values<'_, K, V> {\n         Values { inner: self.iter() }\n     }\n \n@@ -2529,8 +2557,8 @@ enum UnderflowResult<'a, K, V> {\n     Stole(NodeRef<marker::Mut<'a>, K, V, marker::Internal>),\n }\n \n-fn handle_underfull_node<'a, K, V>(node: NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>)\n-                                   -> UnderflowResult<'a, K, V> {\n+fn handle_underfull_node<K, V>(node: NodeRef<marker::Mut<'_>, K, V, marker::LeafOrInternal>)\n+                               -> UnderflowResult<'_, K, V> {\n     let parent = if let Ok(parent) = node.ascend() {\n         parent\n     } else {"}, {"sha": "e067096f0c780ccc9c5294dbe9fbb45471d47dab", "filename": "src/liballoc/collections/btree/node.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -106,10 +106,10 @@ impl<K, V> LeafNode<K, V> {\n         LeafNode {\n             // As a general policy, we leave fields uninitialized if they can be, as this should\n             // be both slightly faster and easier to track in Valgrind.\n-            keys: uninitialized_array![_; CAPACITY],\n-            vals: uninitialized_array![_; CAPACITY],\n+            keys: uninit_array![_; CAPACITY],\n+            vals: uninit_array![_; CAPACITY],\n             parent: ptr::null(),\n-            parent_idx: MaybeUninit::uninitialized(),\n+            parent_idx: MaybeUninit::uninit(),\n             len: 0\n         }\n     }\n@@ -129,7 +129,7 @@ unsafe impl Sync for NodeHeader<(), ()> {}\n // ever take a pointer past the first key.\n static EMPTY_ROOT_NODE: NodeHeader<(), ()> = NodeHeader {\n     parent: ptr::null(),\n-    parent_idx: MaybeUninit::uninitialized(),\n+    parent_idx: MaybeUninit::uninit(),\n     len: 0,\n     keys_start: [],\n };\n@@ -159,7 +159,7 @@ impl<K, V> InternalNode<K, V> {\n     unsafe fn new() -> Self {\n         InternalNode {\n             data: LeafNode::new(),\n-            edges: uninitialized_array![_; 2*B],\n+            edges: uninit_array![_; 2*B],\n         }\n     }\n }\n@@ -261,7 +261,7 @@ impl<K, V> Root<K, V> {\n             -> NodeRef<marker::Mut<'_>, K, V, marker::Internal> {\n         debug_assert!(!self.is_shared_root());\n         let mut new_node = Box::new(unsafe { InternalNode::new() });\n-        new_node.edges[0].set(unsafe { BoxedNode::from_ptr(self.node.as_ptr()) });\n+        new_node.edges[0].write(unsafe { BoxedNode::from_ptr(self.node.as_ptr()) });\n \n         self.node = BoxedNode::from_internal(new_node);\n         self.height += 1;\n@@ -394,7 +394,7 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n     }\n \n     /// Temporarily takes out another, immutable reference to the same node.\n-    fn reborrow<'a>(&'a self) -> NodeRef<marker::Immut<'a>, K, V, Type> {\n+    fn reborrow(&self) -> NodeRef<marker::Immut<'_>, K, V, Type> {\n         NodeRef {\n             height: self.height,\n             node: self.node,\n@@ -737,7 +737,7 @@ impl<'a, K, V> NodeRef<marker::Mut<'a>, K, V, marker::Internal> {\n         unsafe {\n             ptr::write(self.keys_mut().get_unchecked_mut(idx), key);\n             ptr::write(self.vals_mut().get_unchecked_mut(idx), val);\n-            self.as_internal_mut().edges.get_unchecked_mut(idx + 1).set(edge.node);\n+            self.as_internal_mut().edges.get_unchecked_mut(idx + 1).write(edge.node);\n \n             (*self.as_leaf_mut()).len += 1;\n \n@@ -1080,7 +1080,7 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Internal>, marker::\n         let mut child = self.descend();\n         unsafe {\n             (*child.as_leaf_mut()).parent = ptr;\n-            (*child.as_leaf_mut()).parent_idx.set(idx);\n+            (*child.as_leaf_mut()).parent_idx.write(idx);\n         }\n     }\n "}, {"sha": "d3af910a82c27939dab4b03e1190ccad6b842a86", "filename": "src/liballoc/collections/btree/set.rs", "status": "modified", "additions": 242, "deletions": 67, "changes": 309, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fset.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -3,7 +3,7 @@\n \n use core::borrow::Borrow;\n use core::cmp::Ordering::{self, Less, Greater, Equal};\n-use core::cmp::{min, max};\n+use core::cmp::max;\n use core::fmt::{self, Debug};\n use core::iter::{Peekable, FromIterator, FusedIterator};\n use core::ops::{BitOr, BitAnd, BitXor, Sub, RangeBounds};\n@@ -118,17 +118,36 @@ pub struct Range<'a, T: 'a> {\n /// [`difference`]: struct.BTreeSet.html#method.difference\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Difference<'a, T: 'a> {\n-    a: Peekable<Iter<'a, T>>,\n-    b: Peekable<Iter<'a, T>>,\n+    inner: DifferenceInner<'a, T>,\n+}\n+enum DifferenceInner<'a, T: 'a> {\n+    Stitch {\n+        self_iter: Iter<'a, T>,\n+        other_iter: Peekable<Iter<'a, T>>,\n+    },\n+    Search {\n+        self_iter: Iter<'a, T>,\n+        other_set: &'a BTreeSet<T>,\n+    },\n }\n \n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n impl<T: fmt::Debug> fmt::Debug for Difference<'_, T> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_tuple(\"Difference\")\n-         .field(&self.a)\n-         .field(&self.b)\n-         .finish()\n+        match &self.inner {\n+            DifferenceInner::Stitch {\n+                self_iter,\n+                other_iter,\n+            } => f\n+                .debug_tuple(\"Difference\")\n+                .field(&self_iter)\n+                .field(&other_iter)\n+                .finish(),\n+            DifferenceInner::Search {\n+                self_iter,\n+                other_set: _,\n+            } => f.debug_tuple(\"Difference\").field(&self_iter).finish(),\n+        }\n     }\n }\n \n@@ -164,17 +183,36 @@ impl<T: fmt::Debug> fmt::Debug for SymmetricDifference<'_, T> {\n /// [`intersection`]: struct.BTreeSet.html#method.intersection\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct Intersection<'a, T: 'a> {\n-    a: Peekable<Iter<'a, T>>,\n-    b: Peekable<Iter<'a, T>>,\n+    inner: IntersectionInner<'a, T>,\n+}\n+enum IntersectionInner<'a, T: 'a> {\n+    Stitch {\n+        small_iter: Iter<'a, T>, // for size_hint, should be the smaller of the sets\n+        other_iter: Iter<'a, T>,\n+    },\n+    Search {\n+        small_iter: Iter<'a, T>,\n+        large_set: &'a BTreeSet<T>,\n+    },\n }\n \n #[stable(feature = \"collection_debug\", since = \"1.17.0\")]\n impl<T: fmt::Debug> fmt::Debug for Intersection<'_, T> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        f.debug_tuple(\"Intersection\")\n-         .field(&self.a)\n-         .field(&self.b)\n-         .finish()\n+        match &self.inner {\n+            IntersectionInner::Stitch {\n+                small_iter,\n+                other_iter,\n+            } => f\n+                .debug_tuple(\"Intersection\")\n+                .field(&small_iter)\n+                .field(&other_iter)\n+                .finish(),\n+            IntersectionInner::Search {\n+                small_iter,\n+                large_set: _,\n+            } => f.debug_tuple(\"Intersection\").field(&small_iter).finish(),\n+        }\n     }\n }\n \n@@ -201,6 +239,14 @@ impl<T: fmt::Debug> fmt::Debug for Union<'_, T> {\n     }\n }\n \n+// This constant is used by functions that compare two sets.\n+// It estimates the relative size at which searching performs better\n+// than iterating, based on the benchmarks in\n+// https://github.com/ssomers/rust_bench_btreeset_intersection;\n+// It's used to divide rather than multiply sizes, to rule out overflow,\n+// and it's a power of two to make that division cheap.\n+const ITER_PERFORMANCE_TIPPING_SIZE_DIFF: usize = 16;\n+\n impl<T: Ord> BTreeSet<T> {\n     /// Makes a new `BTreeSet` with a reasonable choice of B.\n     ///\n@@ -268,9 +314,24 @@ impl<T: Ord> BTreeSet<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn difference<'a>(&'a self, other: &'a BTreeSet<T>) -> Difference<'a, T> {\n-        Difference {\n-            a: self.iter().peekable(),\n-            b: other.iter().peekable(),\n+        if self.len() > other.len() / ITER_PERFORMANCE_TIPPING_SIZE_DIFF {\n+            // Self is bigger than or not much smaller than other set.\n+            // Iterate both sets jointly, spotting matches along the way.\n+            Difference {\n+                inner: DifferenceInner::Stitch {\n+                    self_iter: self.iter(),\n+                    other_iter: other.iter().peekable(),\n+                },\n+            }\n+        } else {\n+            // Self is much smaller than other set, or both sets are empty.\n+            // Iterate the small set, searching for matches in the large set.\n+            Difference {\n+                inner: DifferenceInner::Search {\n+                    self_iter: self.iter(),\n+                    other_set: other,\n+                },\n+            }\n         }\n     }\n \n@@ -326,9 +387,29 @@ impl<T: Ord> BTreeSet<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn intersection<'a>(&'a self, other: &'a BTreeSet<T>) -> Intersection<'a, T> {\n-        Intersection {\n-            a: self.iter().peekable(),\n-            b: other.iter().peekable(),\n+        let (small, other) = if self.len() <= other.len() {\n+            (self, other)\n+        } else {\n+            (other, self)\n+        };\n+        if small.len() > other.len() / ITER_PERFORMANCE_TIPPING_SIZE_DIFF {\n+            // Small set is not much smaller than other set.\n+            // Iterate both sets jointly, spotting matches along the way.\n+            Intersection {\n+                inner: IntersectionInner::Stitch {\n+                    small_iter: small.iter(),\n+                    other_iter: other.iter(),\n+                },\n+            }\n+        } else {\n+            // Big difference in number of elements, or both sets are empty.\n+            // Iterate the small set, searching for matches in the large set.\n+            Intersection {\n+                inner: IntersectionInner::Search {\n+                    small_iter: small.iter(),\n+                    large_set: other,\n+                },\n+            }\n         }\n     }\n \n@@ -462,28 +543,44 @@ impl<T: Ord> BTreeSet<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn is_subset(&self, other: &BTreeSet<T>) -> bool {\n-        // Stolen from TreeMap\n-        let mut x = self.iter();\n-        let mut y = other.iter();\n-        let mut a = x.next();\n-        let mut b = y.next();\n-        while a.is_some() {\n-            if b.is_none() {\n-                return false;\n-            }\n+        // Same result as self.difference(other).next().is_none()\n+        // but the 3 paths below are faster (in order: hugely, 20%, 5%).\n+        if self.len() > other.len() {\n+            false\n+        } else if self.len() > other.len() / ITER_PERFORMANCE_TIPPING_SIZE_DIFF {\n+            // Self is not much smaller than other set.\n+            // Stolen from TreeMap\n+            let mut x = self.iter();\n+            let mut y = other.iter();\n+            let mut a = x.next();\n+            let mut b = y.next();\n+            while a.is_some() {\n+                if b.is_none() {\n+                    return false;\n+                }\n \n-            let a1 = a.unwrap();\n-            let b1 = b.unwrap();\n+                let a1 = a.unwrap();\n+                let b1 = b.unwrap();\n \n-            match b1.cmp(a1) {\n-                Less => (),\n-                Greater => return false,\n-                Equal => a = x.next(),\n-            }\n+                match b1.cmp(a1) {\n+                    Less => (),\n+                    Greater => return false,\n+                    Equal => a = x.next(),\n+                }\n \n-            b = y.next();\n+                b = y.next();\n+            }\n+            true\n+        } else {\n+            // Big difference in number of elements, or both sets are empty.\n+            // Iterate the small set, searching for matches in the large set.\n+            for next in self {\n+                if !other.contains(next) {\n+                    return false;\n+                }\n+            }\n+            true\n         }\n-        true\n     }\n \n     /// Returns `true` if the set is a superset of another,\n@@ -786,9 +883,9 @@ impl<'a, T> IntoIterator for &'a BTreeSet<T> {\n impl<T: Ord> Extend<T> for BTreeSet<T> {\n     #[inline]\n     fn extend<Iter: IntoIterator<Item = T>>(&mut self, iter: Iter) {\n-        for elem in iter {\n+        iter.into_iter().for_each(move |elem| {\n             self.insert(elem);\n-        }\n+        });\n     }\n }\n \n@@ -922,6 +1019,9 @@ impl<'a, T> Iterator for Iter<'a, T> {\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         self.iter.size_hint()\n     }\n+    fn last(mut self) -> Option<&'a T> {\n+        self.next_back()\n+    }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<'a, T> DoubleEndedIterator for Iter<'a, T> {\n@@ -976,6 +1076,10 @@ impl<'a, T> Iterator for Range<'a, T> {\n     fn next(&mut self) -> Option<&'a T> {\n         self.iter.next().map(|(k, _)| k)\n     }\n+\n+    fn last(mut self) -> Option<&'a T> {\n+        self.next_back()\n+    }\n }\n \n #[stable(feature = \"btree_range\", since = \"1.17.0\")]\n@@ -1001,8 +1105,22 @@ fn cmp_opt<T: Ord>(x: Option<&T>, y: Option<&T>, short: Ordering, long: Ordering\n impl<T> Clone for Difference<'_, T> {\n     fn clone(&self) -> Self {\n         Difference {\n-            a: self.a.clone(),\n-            b: self.b.clone(),\n+            inner: match &self.inner {\n+                DifferenceInner::Stitch {\n+                    self_iter,\n+                    other_iter,\n+                } => DifferenceInner::Stitch {\n+                    self_iter: self_iter.clone(),\n+                    other_iter: other_iter.clone(),\n+                },\n+                DifferenceInner::Search {\n+                    self_iter,\n+                    other_set,\n+                } => DifferenceInner::Search {\n+                    self_iter: self_iter.clone(),\n+                    other_set,\n+                },\n+            },\n         }\n     }\n }\n@@ -1011,24 +1129,52 @@ impl<'a, T: Ord> Iterator for Difference<'a, T> {\n     type Item = &'a T;\n \n     fn next(&mut self) -> Option<&'a T> {\n-        loop {\n-            match cmp_opt(self.a.peek(), self.b.peek(), Less, Less) {\n-                Less => return self.a.next(),\n-                Equal => {\n-                    self.a.next();\n-                    self.b.next();\n-                }\n-                Greater => {\n-                    self.b.next();\n+        match &mut self.inner {\n+            DifferenceInner::Stitch {\n+                self_iter,\n+                other_iter,\n+            } => {\n+                let mut self_next = self_iter.next()?;\n+                loop {\n+                    match other_iter\n+                        .peek()\n+                        .map_or(Less, |other_next| Ord::cmp(self_next, other_next))\n+                    {\n+                        Less => return Some(self_next),\n+                        Equal => {\n+                            self_next = self_iter.next()?;\n+                            other_iter.next();\n+                        }\n+                        Greater => {\n+                            other_iter.next();\n+                        }\n+                    }\n                 }\n             }\n+            DifferenceInner::Search {\n+                self_iter,\n+                other_set,\n+            } => loop {\n+                let self_next = self_iter.next()?;\n+                if !other_set.contains(&self_next) {\n+                    return Some(self_next);\n+                }\n+            },\n         }\n     }\n \n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        let a_len = self.a.len();\n-        let b_len = self.b.len();\n-        (a_len.saturating_sub(b_len), Some(a_len))\n+        let (self_len, other_len) = match &self.inner {\n+            DifferenceInner::Stitch {\n+                self_iter,\n+                other_iter\n+            } => (self_iter.len(), other_iter.len()),\n+            DifferenceInner::Search {\n+                self_iter,\n+                other_set\n+            } => (self_iter.len(), other_set.len()),\n+        };\n+        (self_len.saturating_sub(other_len), Some(self_len))\n     }\n }\n \n@@ -1073,8 +1219,22 @@ impl<T: Ord> FusedIterator for SymmetricDifference<'_, T> {}\n impl<T> Clone for Intersection<'_, T> {\n     fn clone(&self) -> Self {\n         Intersection {\n-            a: self.a.clone(),\n-            b: self.b.clone(),\n+            inner: match &self.inner {\n+                IntersectionInner::Stitch {\n+                    small_iter,\n+                    other_iter,\n+                } => IntersectionInner::Stitch {\n+                    small_iter: small_iter.clone(),\n+                    other_iter: other_iter.clone(),\n+                },\n+                IntersectionInner::Search {\n+                    small_iter,\n+                    large_set,\n+                } => IntersectionInner::Search {\n+                    small_iter: small_iter.clone(),\n+                    large_set,\n+                },\n+            },\n         }\n     }\n }\n@@ -1083,24 +1243,39 @@ impl<'a, T: Ord> Iterator for Intersection<'a, T> {\n     type Item = &'a T;\n \n     fn next(&mut self) -> Option<&'a T> {\n-        loop {\n-            match Ord::cmp(self.a.peek()?, self.b.peek()?) {\n-                Less => {\n-                    self.a.next();\n-                }\n-                Equal => {\n-                    self.b.next();\n-                    return self.a.next();\n-                }\n-                Greater => {\n-                    self.b.next();\n+        match &mut self.inner {\n+            IntersectionInner::Stitch {\n+                small_iter,\n+                other_iter,\n+            } => {\n+                let mut small_next = small_iter.next()?;\n+                let mut other_next = other_iter.next()?;\n+                loop {\n+                    match Ord::cmp(small_next, other_next) {\n+                        Less => small_next = small_iter.next()?,\n+                        Greater => other_next = other_iter.next()?,\n+                        Equal => return Some(small_next),\n+                    }\n                 }\n             }\n+            IntersectionInner::Search {\n+                small_iter,\n+                large_set,\n+            } => loop {\n+                let small_next = small_iter.next()?;\n+                if large_set.contains(&small_next) {\n+                    return Some(small_next);\n+                }\n+            },\n         }\n     }\n \n     fn size_hint(&self) -> (usize, Option<usize>) {\n-        (0, Some(min(self.a.len(), self.b.len())))\n+        let min_len = match &self.inner {\n+            IntersectionInner::Stitch { small_iter, .. } => small_iter.len(),\n+            IntersectionInner::Search { small_iter, .. } => small_iter.len(),\n+        };\n+        (0, Some(min_len))\n     }\n }\n "}, {"sha": "a14a3fe9994abb59c517411f62ec9400ad22a6ef", "filename": "src/liballoc/collections/linked_list.rs", "status": "modified", "additions": 54, "deletions": 285, "changes": 339, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fliballoc%2Fcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fliballoc%2Fcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Flinked_list.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -23,6 +23,9 @@ use core::ptr::NonNull;\n use crate::boxed::Box;\n use super::SpecExtend;\n \n+#[cfg(test)]\n+mod tests;\n+\n /// A doubly-linked list with owned nodes.\n ///\n /// The `LinkedList` allows pushing and popping elements at either end\n@@ -86,6 +89,9 @@ impl<T> Clone for Iter<'_, T> {\n /// [`LinkedList`]: struct.LinkedList.html\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub struct IterMut<'a, T: 'a> {\n+    // We do *not* exclusively own the entire list here, references to node's `element`\n+    // have been handed out by the iterator!  So be careful when using this; the methods\n+    // called must be aware that there can be aliasing pointers to `element`.\n     list: &'a mut LinkedList<T>,\n     head: Option<NonNull<Node<T>>>,\n     tail: Option<NonNull<Node<T>>>,\n@@ -143,14 +149,17 @@ impl<T> LinkedList<T> {\n     /// Adds the given node to the front of the list.\n     #[inline]\n     fn push_front_node(&mut self, mut node: Box<Node<T>>) {\n+        // This method takes care not to create mutable references to whole nodes,\n+        // to maintain validity of aliasing pointers into `element`.\n         unsafe {\n             node.next = self.head;\n             node.prev = None;\n             let node = Some(Box::into_raw_non_null(node));\n \n             match self.head {\n                 None => self.tail = node,\n-                Some(mut head) => head.as_mut().prev = node,\n+                // Not creating new mutable (unique!) references overlapping `element`.\n+                Some(head) => (*head.as_ptr()).prev = node,\n             }\n \n             self.head = node;\n@@ -161,13 +170,16 @@ impl<T> LinkedList<T> {\n     /// Removes and returns the node at the front of the list.\n     #[inline]\n     fn pop_front_node(&mut self) -> Option<Box<Node<T>>> {\n+        // This method takes care not to create mutable references to whole nodes,\n+        // to maintain validity of aliasing pointers into `element`.\n         self.head.map(|node| unsafe {\n             let node = Box::from_raw(node.as_ptr());\n             self.head = node.next;\n \n             match self.head {\n                 None => self.tail = None,\n-                Some(mut head) => head.as_mut().prev = None,\n+                // Not creating new mutable (unique!) references overlapping `element`.\n+                Some(head) => (*head.as_ptr()).prev = None,\n             }\n \n             self.len -= 1;\n@@ -178,14 +190,17 @@ impl<T> LinkedList<T> {\n     /// Adds the given node to the back of the list.\n     #[inline]\n     fn push_back_node(&mut self, mut node: Box<Node<T>>) {\n+        // This method takes care not to create mutable references to whole nodes,\n+        // to maintain validity of aliasing pointers into `element`.\n         unsafe {\n             node.next = None;\n             node.prev = self.tail;\n             let node = Some(Box::into_raw_non_null(node));\n \n             match self.tail {\n                 None => self.head = node,\n-                Some(mut tail) => tail.as_mut().next = node,\n+                // Not creating new mutable (unique!) references overlapping `element`.\n+                Some(tail) => (*tail.as_ptr()).next = node,\n             }\n \n             self.tail = node;\n@@ -196,13 +211,16 @@ impl<T> LinkedList<T> {\n     /// Removes and returns the node at the back of the list.\n     #[inline]\n     fn pop_back_node(&mut self) -> Option<Box<Node<T>>> {\n+        // This method takes care not to create mutable references to whole nodes,\n+        // to maintain validity of aliasing pointers into `element`.\n         self.tail.map(|node| unsafe {\n             let node = Box::from_raw(node.as_ptr());\n             self.tail = node.prev;\n \n             match self.tail {\n                 None => self.head = None,\n-                Some(mut tail) => tail.as_mut().next = None,\n+                // Not creating new mutable (unique!) references overlapping `element`.\n+                Some(tail) => (*tail.as_ptr()).next = None,\n             }\n \n             self.len -= 1;\n@@ -213,20 +231,24 @@ impl<T> LinkedList<T> {\n     /// Unlinks the specified node from the current list.\n     ///\n     /// Warning: this will not check that the provided node belongs to the current list.\n+    ///\n+    /// This method takes care not to create mutable references to `element`, to\n+    /// maintain validity of aliasing pointers.\n     #[inline]\n     unsafe fn unlink_node(&mut self, mut node: NonNull<Node<T>>) {\n-        let node = node.as_mut();\n+        let node = node.as_mut(); // this one is ours now, we can create an &mut.\n \n+        // Not creating new mutable (unique!) references overlapping `element`.\n         match node.prev {\n-            Some(mut prev) => prev.as_mut().next = node.next.clone(),\n+            Some(prev) => (*prev.as_ptr()).next = node.next,\n             // this node is the head node\n-            None => self.head = node.next.clone(),\n+            None => self.head = node.next,\n         };\n \n         match node.next {\n-            Some(mut next) => next.as_mut().prev = node.prev.clone(),\n+            Some(next) => (*next.as_ptr()).prev = node.prev,\n             // this node is the tail node\n-            None => self.tail = node.prev.clone(),\n+            None => self.tail = node.prev,\n         };\n \n         self.len -= 1;\n@@ -297,6 +319,8 @@ impl<T> LinkedList<T> {\n         match self.tail {\n             None => mem::swap(self, other),\n             Some(mut tail) => {\n+                // `as_mut` is okay here because we have exclusive access to the entirety\n+                // of both lists.\n                 if let Some(mut other_head) = other.head.take() {\n                     unsafe {\n                         tail.as_mut().next = Some(other_head);\n@@ -687,7 +711,7 @@ impl<T> LinkedList<T> {\n         let len = self.len();\n         assert!(at <= len, \"Cannot split off at a nonexistent index\");\n         if at == 0 {\n-            return mem::replace(self, Self::new());\n+            return mem::take(self);\n         } else if at == len {\n             return Self::new();\n         }\n@@ -811,6 +835,11 @@ impl<'a, T> Iterator for Iter<'a, T> {\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         (self.len, Some(self.len))\n     }\n+\n+    #[inline]\n+    fn last(mut self) -> Option<&'a T> {\n+        self.next_back()\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -860,6 +889,11 @@ impl<'a, T> Iterator for IterMut<'a, T> {\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         (self.len, Some(self.len))\n     }\n+\n+    #[inline]\n+    fn last(mut self) -> Option<&'a mut T> {\n+        self.next_back()\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -916,9 +950,11 @@ impl<T> IterMut<'_, T> {\n                issue = \"27794\")]\n     pub fn insert_next(&mut self, element: T) {\n         match self.head {\n+            // `push_back` is okay with aliasing `element` references\n             None => self.list.push_back(element),\n-            Some(mut head) => unsafe {\n-                let mut prev = match head.as_ref().prev {\n+            Some(head) => unsafe {\n+                let prev = match head.as_ref().prev {\n+                    // `push_front` is okay with aliasing nodes\n                     None => return self.list.push_front(element),\n                     Some(prev) => prev,\n                 };\n@@ -929,8 +965,10 @@ impl<T> IterMut<'_, T> {\n                     element,\n                 }));\n \n-                prev.as_mut().next = node;\n-                head.as_mut().prev = node;\n+                // Not creating references to entire nodes to not invalidate the\n+                // reference to `element` we handed to the user.\n+                (*prev.as_ptr()).next = node;\n+                (*head.as_ptr()).prev = node;\n \n                 self.list.len += 1;\n             },\n@@ -994,6 +1032,7 @@ impl<T, F> Iterator for DrainFilter<'_, T, F>\n                 self.idx += 1;\n \n                 if (self.pred)(&mut node.as_mut().element) {\n+                    // `unlink_node` is okay with aliasing `element` references.\n                     self.list.unlink_node(node);\n                     return Some(Box::from_raw(node.as_ptr()).element);\n                 }\n@@ -1107,9 +1146,7 @@ impl<T> Extend<T> for LinkedList<T> {\n \n impl<I: IntoIterator> SpecExtend<I> for LinkedList<I::Item> {\n     default fn spec_extend(&mut self, iter: I) {\n-        for elt in iter {\n-            self.push_back(elt);\n-        }\n+        iter.into_iter().for_each(move |elt| self.push_back(elt));\n     }\n }\n \n@@ -1210,271 +1247,3 @@ unsafe impl<T: Send> Send for IterMut<'_, T> {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n unsafe impl<T: Sync> Sync for IterMut<'_, T> {}\n-\n-#[cfg(test)]\n-mod tests {\n-    use std::thread;\n-    use std::vec::Vec;\n-\n-    use rand::{thread_rng, RngCore};\n-\n-    use super::{LinkedList, Node};\n-\n-    #[cfg(test)]\n-    fn list_from<T: Clone>(v: &[T]) -> LinkedList<T> {\n-        v.iter().cloned().collect()\n-    }\n-\n-    pub fn check_links<T>(list: &LinkedList<T>) {\n-        unsafe {\n-            let mut len = 0;\n-            let mut last_ptr: Option<&Node<T>> = None;\n-            let mut node_ptr: &Node<T>;\n-            match list.head {\n-                None => {\n-                    // tail node should also be None.\n-                    assert!(list.tail.is_none());\n-                    assert_eq!(0, list.len);\n-                    return;\n-                }\n-                Some(node) => node_ptr = &*node.as_ptr(),\n-            }\n-            loop {\n-                match (last_ptr, node_ptr.prev) {\n-                    (None, None) => {}\n-                    (None, _) => panic!(\"prev link for head\"),\n-                    (Some(p), Some(pptr)) => {\n-                        assert_eq!(p as *const Node<T>, pptr.as_ptr() as *const Node<T>);\n-                    }\n-                    _ => panic!(\"prev link is none, not good\"),\n-                }\n-                match node_ptr.next {\n-                    Some(next) => {\n-                        last_ptr = Some(node_ptr);\n-                        node_ptr = &*next.as_ptr();\n-                        len += 1;\n-                    }\n-                    None => {\n-                        len += 1;\n-                        break;\n-                    }\n-                }\n-            }\n-\n-            // verify that the tail node points to the last node.\n-            let tail = list.tail.as_ref().expect(\"some tail node\").as_ref();\n-            assert_eq!(tail as *const Node<T>, node_ptr as *const Node<T>);\n-            // check that len matches interior links.\n-            assert_eq!(len, list.len);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_append() {\n-        // Empty to empty\n-        {\n-            let mut m = LinkedList::<i32>::new();\n-            let mut n = LinkedList::new();\n-            m.append(&mut n);\n-            check_links(&m);\n-            assert_eq!(m.len(), 0);\n-            assert_eq!(n.len(), 0);\n-        }\n-        // Non-empty to empty\n-        {\n-            let mut m = LinkedList::new();\n-            let mut n = LinkedList::new();\n-            n.push_back(2);\n-            m.append(&mut n);\n-            check_links(&m);\n-            assert_eq!(m.len(), 1);\n-            assert_eq!(m.pop_back(), Some(2));\n-            assert_eq!(n.len(), 0);\n-            check_links(&m);\n-        }\n-        // Empty to non-empty\n-        {\n-            let mut m = LinkedList::new();\n-            let mut n = LinkedList::new();\n-            m.push_back(2);\n-            m.append(&mut n);\n-            check_links(&m);\n-            assert_eq!(m.len(), 1);\n-            assert_eq!(m.pop_back(), Some(2));\n-            check_links(&m);\n-        }\n-\n-        // Non-empty to non-empty\n-        let v = vec![1, 2, 3, 4, 5];\n-        let u = vec![9, 8, 1, 2, 3, 4, 5];\n-        let mut m = list_from(&v);\n-        let mut n = list_from(&u);\n-        m.append(&mut n);\n-        check_links(&m);\n-        let mut sum = v;\n-        sum.extend_from_slice(&u);\n-        assert_eq!(sum.len(), m.len());\n-        for elt in sum {\n-            assert_eq!(m.pop_front(), Some(elt))\n-        }\n-        assert_eq!(n.len(), 0);\n-        // let's make sure it's working properly, since we\n-        // did some direct changes to private members\n-        n.push_back(3);\n-        assert_eq!(n.len(), 1);\n-        assert_eq!(n.pop_front(), Some(3));\n-        check_links(&n);\n-    }\n-\n-    #[test]\n-    fn test_insert_prev() {\n-        let mut m = list_from(&[0, 2, 4, 6, 8]);\n-        let len = m.len();\n-        {\n-            let mut it = m.iter_mut();\n-            it.insert_next(-2);\n-            loop {\n-                match it.next() {\n-                    None => break,\n-                    Some(elt) => {\n-                        it.insert_next(*elt + 1);\n-                        match it.peek_next() {\n-                            Some(x) => assert_eq!(*x, *elt + 2),\n-                            None => assert_eq!(8, *elt),\n-                        }\n-                    }\n-                }\n-            }\n-            it.insert_next(0);\n-            it.insert_next(1);\n-        }\n-        check_links(&m);\n-        assert_eq!(m.len(), 3 + len * 2);\n-        assert_eq!(m.into_iter().collect::<Vec<_>>(),\n-                   [-2, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1]);\n-    }\n-\n-    #[test]\n-    #[cfg_attr(target_os = \"emscripten\", ignore)]\n-    fn test_send() {\n-        let n = list_from(&[1, 2, 3]);\n-        thread::spawn(move || {\n-                check_links(&n);\n-                let a: &[_] = &[&1, &2, &3];\n-                assert_eq!(a, &*n.iter().collect::<Vec<_>>());\n-            })\n-            .join()\n-            .ok()\n-            .unwrap();\n-    }\n-\n-    #[test]\n-    fn test_fuzz() {\n-        for _ in 0..25 {\n-            fuzz_test(3);\n-            fuzz_test(16);\n-            fuzz_test(189);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_26021() {\n-        // There was a bug in split_off that failed to null out the RHS's head's prev ptr.\n-        // This caused the RHS's dtor to walk up into the LHS at drop and delete all of\n-        // its nodes.\n-        //\n-        // https://github.com/rust-lang/rust/issues/26021\n-        let mut v1 = LinkedList::new();\n-        v1.push_front(1);\n-        v1.push_front(1);\n-        v1.push_front(1);\n-        v1.push_front(1);\n-        let _ = v1.split_off(3); // Dropping this now should not cause laundry consumption\n-        assert_eq!(v1.len(), 3);\n-\n-        assert_eq!(v1.iter().len(), 3);\n-        assert_eq!(v1.iter().collect::<Vec<_>>().len(), 3);\n-    }\n-\n-    #[test]\n-    fn test_split_off() {\n-        let mut v1 = LinkedList::new();\n-        v1.push_front(1);\n-        v1.push_front(1);\n-        v1.push_front(1);\n-        v1.push_front(1);\n-\n-        // test all splits\n-        for ix in 0..1 + v1.len() {\n-            let mut a = v1.clone();\n-            let b = a.split_off(ix);\n-            check_links(&a);\n-            check_links(&b);\n-            a.extend(b);\n-            assert_eq!(v1, a);\n-        }\n-    }\n-\n-    #[cfg(test)]\n-    fn fuzz_test(sz: i32) {\n-        let mut m: LinkedList<_> = LinkedList::new();\n-        let mut v = vec![];\n-        for i in 0..sz {\n-            check_links(&m);\n-            let r: u8 = thread_rng().next_u32() as u8;\n-            match r % 6 {\n-                0 => {\n-                    m.pop_back();\n-                    v.pop();\n-                }\n-                1 => {\n-                    if !v.is_empty() {\n-                        m.pop_front();\n-                        v.remove(0);\n-                    }\n-                }\n-                2 | 4 => {\n-                    m.push_front(-i);\n-                    v.insert(0, -i);\n-                }\n-                3 | 5 | _ => {\n-                    m.push_back(i);\n-                    v.push(i);\n-                }\n-            }\n-        }\n-\n-        check_links(&m);\n-\n-        let mut i = 0;\n-        for (a, &b) in m.into_iter().zip(&v) {\n-            i += 1;\n-            assert_eq!(a, b);\n-        }\n-        assert_eq!(i, v.len());\n-    }\n-\n-    #[test]\n-    fn drain_filter_test() {\n-        let mut m: LinkedList<u32> = LinkedList::new();\n-        m.extend(&[1, 2, 3, 4, 5, 6]);\n-        let deleted = m.drain_filter(|v| *v < 4).collect::<Vec<_>>();\n-\n-        check_links(&m);\n-\n-        assert_eq!(deleted, &[1, 2, 3]);\n-        assert_eq!(m.into_iter().collect::<Vec<_>>(), &[4, 5, 6]);\n-    }\n-\n-    #[test]\n-    fn drain_to_empty_test() {\n-        let mut m: LinkedList<u32> = LinkedList::new();\n-        m.extend(&[1, 2, 3, 4, 5, 6]);\n-        let deleted = m.drain_filter(|_| true).collect::<Vec<_>>();\n-\n-        check_links(&m);\n-\n-        assert_eq!(deleted, &[1, 2, 3, 4, 5, 6]);\n-        assert_eq!(m.into_iter().collect::<Vec<_>>(), &[]);\n-    }\n-}"}, {"sha": "9a6c57d286970d997a9ca4612f30b0cab3bd6383", "filename": "src/liballoc/collections/linked_list/tests.rs", "status": "added", "additions": 264, "deletions": 0, "changes": 264, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fliballoc%2Fcollections%2Flinked_list%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fliballoc%2Fcollections%2Flinked_list%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Flinked_list%2Ftests.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -0,0 +1,264 @@\n+use super::*;\n+\n+use std::thread;\n+use std::vec::Vec;\n+\n+use rand::{thread_rng, RngCore};\n+\n+fn list_from<T: Clone>(v: &[T]) -> LinkedList<T> {\n+    v.iter().cloned().collect()\n+}\n+\n+pub fn check_links<T>(list: &LinkedList<T>) {\n+    unsafe {\n+        let mut len = 0;\n+        let mut last_ptr: Option<&Node<T>> = None;\n+        let mut node_ptr: &Node<T>;\n+        match list.head {\n+            None => {\n+                // tail node should also be None.\n+                assert!(list.tail.is_none());\n+                assert_eq!(0, list.len);\n+                return;\n+            }\n+            Some(node) => node_ptr = &*node.as_ptr(),\n+        }\n+        loop {\n+            match (last_ptr, node_ptr.prev) {\n+                (None, None) => {}\n+                (None, _) => panic!(\"prev link for head\"),\n+                (Some(p), Some(pptr)) => {\n+                    assert_eq!(p as *const Node<T>, pptr.as_ptr() as *const Node<T>);\n+                }\n+                _ => panic!(\"prev link is none, not good\"),\n+            }\n+            match node_ptr.next {\n+                Some(next) => {\n+                    last_ptr = Some(node_ptr);\n+                    node_ptr = &*next.as_ptr();\n+                    len += 1;\n+                }\n+                None => {\n+                    len += 1;\n+                    break;\n+                }\n+            }\n+        }\n+\n+        // verify that the tail node points to the last node.\n+        let tail = list.tail.as_ref().expect(\"some tail node\").as_ref();\n+        assert_eq!(tail as *const Node<T>, node_ptr as *const Node<T>);\n+        // check that len matches interior links.\n+        assert_eq!(len, list.len);\n+    }\n+}\n+\n+#[test]\n+fn test_append() {\n+    // Empty to empty\n+    {\n+        let mut m = LinkedList::<i32>::new();\n+        let mut n = LinkedList::new();\n+        m.append(&mut n);\n+        check_links(&m);\n+        assert_eq!(m.len(), 0);\n+        assert_eq!(n.len(), 0);\n+    }\n+    // Non-empty to empty\n+    {\n+        let mut m = LinkedList::new();\n+        let mut n = LinkedList::new();\n+        n.push_back(2);\n+        m.append(&mut n);\n+        check_links(&m);\n+        assert_eq!(m.len(), 1);\n+        assert_eq!(m.pop_back(), Some(2));\n+        assert_eq!(n.len(), 0);\n+        check_links(&m);\n+    }\n+    // Empty to non-empty\n+    {\n+        let mut m = LinkedList::new();\n+        let mut n = LinkedList::new();\n+        m.push_back(2);\n+        m.append(&mut n);\n+        check_links(&m);\n+        assert_eq!(m.len(), 1);\n+        assert_eq!(m.pop_back(), Some(2));\n+        check_links(&m);\n+    }\n+\n+    // Non-empty to non-empty\n+    let v = vec![1, 2, 3, 4, 5];\n+    let u = vec![9, 8, 1, 2, 3, 4, 5];\n+    let mut m = list_from(&v);\n+    let mut n = list_from(&u);\n+    m.append(&mut n);\n+    check_links(&m);\n+    let mut sum = v;\n+    sum.extend_from_slice(&u);\n+    assert_eq!(sum.len(), m.len());\n+    for elt in sum {\n+        assert_eq!(m.pop_front(), Some(elt))\n+    }\n+    assert_eq!(n.len(), 0);\n+    // let's make sure it's working properly, since we\n+    // did some direct changes to private members\n+    n.push_back(3);\n+    assert_eq!(n.len(), 1);\n+    assert_eq!(n.pop_front(), Some(3));\n+    check_links(&n);\n+}\n+\n+#[test]\n+fn test_insert_prev() {\n+    let mut m = list_from(&[0, 2, 4, 6, 8]);\n+    let len = m.len();\n+    {\n+        let mut it = m.iter_mut();\n+        it.insert_next(-2);\n+        loop {\n+            match it.next() {\n+                None => break,\n+                Some(elt) => {\n+                    it.insert_next(*elt + 1);\n+                    match it.peek_next() {\n+                        Some(x) => assert_eq!(*x, *elt + 2),\n+                        None => assert_eq!(8, *elt),\n+                    }\n+                }\n+            }\n+        }\n+        it.insert_next(0);\n+        it.insert_next(1);\n+    }\n+    check_links(&m);\n+    assert_eq!(m.len(), 3 + len * 2);\n+    assert_eq!(m.into_iter().collect::<Vec<_>>(),\n+                [-2, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1]);\n+}\n+\n+#[test]\n+#[cfg_attr(target_os = \"emscripten\", ignore)]\n+#[cfg(not(miri))] // Miri does not support threads\n+fn test_send() {\n+    let n = list_from(&[1, 2, 3]);\n+    thread::spawn(move || {\n+            check_links(&n);\n+            let a: &[_] = &[&1, &2, &3];\n+            assert_eq!(a, &*n.iter().collect::<Vec<_>>());\n+        })\n+        .join()\n+        .ok()\n+        .unwrap();\n+}\n+\n+#[test]\n+fn test_fuzz() {\n+    for _ in 0..25 {\n+        fuzz_test(3);\n+        fuzz_test(16);\n+        #[cfg(not(miri))] // Miri is too slow\n+        fuzz_test(189);\n+    }\n+}\n+\n+#[test]\n+fn test_26021() {\n+    // There was a bug in split_off that failed to null out the RHS's head's prev ptr.\n+    // This caused the RHS's dtor to walk up into the LHS at drop and delete all of\n+    // its nodes.\n+    //\n+    // https://github.com/rust-lang/rust/issues/26021\n+    let mut v1 = LinkedList::new();\n+    v1.push_front(1);\n+    v1.push_front(1);\n+    v1.push_front(1);\n+    v1.push_front(1);\n+    let _ = v1.split_off(3); // Dropping this now should not cause laundry consumption\n+    assert_eq!(v1.len(), 3);\n+\n+    assert_eq!(v1.iter().len(), 3);\n+    assert_eq!(v1.iter().collect::<Vec<_>>().len(), 3);\n+}\n+\n+#[test]\n+fn test_split_off() {\n+    let mut v1 = LinkedList::new();\n+    v1.push_front(1);\n+    v1.push_front(1);\n+    v1.push_front(1);\n+    v1.push_front(1);\n+\n+    // test all splits\n+    for ix in 0..1 + v1.len() {\n+        let mut a = v1.clone();\n+        let b = a.split_off(ix);\n+        check_links(&a);\n+        check_links(&b);\n+        a.extend(b);\n+        assert_eq!(v1, a);\n+    }\n+}\n+\n+fn fuzz_test(sz: i32) {\n+    let mut m: LinkedList<_> = LinkedList::new();\n+    let mut v = vec![];\n+    for i in 0..sz {\n+        check_links(&m);\n+        let r: u8 = thread_rng().next_u32() as u8;\n+        match r % 6 {\n+            0 => {\n+                m.pop_back();\n+                v.pop();\n+            }\n+            1 => {\n+                if !v.is_empty() {\n+                    m.pop_front();\n+                    v.remove(0);\n+                }\n+            }\n+            2 | 4 => {\n+                m.push_front(-i);\n+                v.insert(0, -i);\n+            }\n+            3 | 5 | _ => {\n+                m.push_back(i);\n+                v.push(i);\n+            }\n+        }\n+    }\n+\n+    check_links(&m);\n+\n+    let mut i = 0;\n+    for (a, &b) in m.into_iter().zip(&v) {\n+        i += 1;\n+        assert_eq!(a, b);\n+    }\n+    assert_eq!(i, v.len());\n+}\n+\n+#[test]\n+fn drain_filter_test() {\n+    let mut m: LinkedList<u32> = LinkedList::new();\n+    m.extend(&[1, 2, 3, 4, 5, 6]);\n+    let deleted = m.drain_filter(|v| *v < 4).collect::<Vec<_>>();\n+\n+    check_links(&m);\n+\n+    assert_eq!(deleted, &[1, 2, 3]);\n+    assert_eq!(m.into_iter().collect::<Vec<_>>(), &[4, 5, 6]);\n+}\n+\n+#[test]\n+fn drain_to_empty_test() {\n+    let mut m: LinkedList<u32> = LinkedList::new();\n+    m.extend(&[1, 2, 3, 4, 5, 6]);\n+    let deleted = m.drain_filter(|_| true).collect::<Vec<_>>();\n+\n+    check_links(&m);\n+\n+    assert_eq!(deleted, &[1, 2, 3, 4, 5, 6]);\n+    assert_eq!(m.into_iter().collect::<Vec<_>>(), &[]);\n+}"}, {"sha": "9240346ace93169a39ecce59759c86cbb32d79be", "filename": "src/liballoc/collections/vec_deque.rs", "status": "modified", "additions": 102, "deletions": 431, "changes": 533, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fliballoc%2Fcollections%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -7,6 +7,7 @@\n \n #![stable(feature = \"rust1\", since = \"1.0.0\")]\n \n+use core::array::LengthAtMost32;\n use core::cmp::{self, Ordering};\n use core::fmt;\n use core::iter::{repeat_with, FromIterator, FusedIterator};\n@@ -21,6 +22,9 @@ use crate::collections::CollectionAllocErr;\n use crate::raw_vec::RawVec;\n use crate::vec::Vec;\n \n+#[cfg(test)]\n+mod tests;\n+\n const INITIAL_CAPACITY: usize = 7; // 2^3 - 1\n const MINIMUM_CAPACITY: usize = 1; // 2 - 1\n #[cfg(target_pointer_width = \"16\")]\n@@ -96,7 +100,7 @@ impl<T> VecDeque<T> {\n             // For zero sized types, we are always at maximum capacity\n             MAXIMUM_ZST_CAPACITY\n         } else {\n-            self.buf.cap()\n+            self.buf.capacity()\n         }\n     }\n \n@@ -312,10 +316,10 @@ impl<T> VecDeque<T> {\n     }\n \n     /// Frobs the head and tail sections around to handle the fact that we\n-    /// just reallocated. Unsafe because it trusts old_cap.\n+    /// just reallocated. Unsafe because it trusts old_capacity.\n     #[inline]\n-    unsafe fn handle_cap_increase(&mut self, old_cap: usize) {\n-        let new_cap = self.cap();\n+    unsafe fn handle_capacity_increase(&mut self, old_capacity: usize) {\n+        let new_capacity = self.cap();\n \n         // Move the shortest contiguous section of the ring buffer\n         //    T             H\n@@ -334,15 +338,15 @@ impl<T> VecDeque<T> {\n         if self.tail <= self.head {\n             // A\n             // Nop\n-        } else if self.head < old_cap - self.tail {\n+        } else if self.head < old_capacity - self.tail {\n             // B\n-            self.copy_nonoverlapping(old_cap, 0, self.head);\n-            self.head += old_cap;\n+            self.copy_nonoverlapping(old_capacity, 0, self.head);\n+            self.head += old_capacity;\n             debug_assert!(self.head > self.tail);\n         } else {\n             // C\n-            let new_tail = new_cap - (old_cap - self.tail);\n-            self.copy_nonoverlapping(new_tail, self.tail, old_cap - self.tail);\n+            let new_tail = new_capacity - (old_capacity - self.tail);\n+            self.copy_nonoverlapping(new_tail, self.tail, old_capacity - self.tail);\n             self.tail = new_tail;\n             debug_assert!(self.head < self.tail);\n         }\n@@ -367,7 +371,7 @@ impl<T> VecDeque<T> {\n         VecDeque::with_capacity(INITIAL_CAPACITY)\n     }\n \n-    /// Creates an empty `VecDeque` with space for at least `n` elements.\n+    /// Creates an empty `VecDeque` with space for at least `capacity` elements.\n     ///\n     /// # Examples\n     ///\n@@ -377,10 +381,10 @@ impl<T> VecDeque<T> {\n     /// let vector: VecDeque<u32> = VecDeque::with_capacity(10);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn with_capacity(n: usize) -> VecDeque<T> {\n+    pub fn with_capacity(capacity: usize) -> VecDeque<T> {\n         // +1 since the ringbuffer always leaves one space empty\n-        let cap = cmp::max(n + 1, MINIMUM_CAPACITY + 1).next_power_of_two();\n-        assert!(cap > n, \"capacity overflow\");\n+        let cap = cmp::max(capacity + 1, MINIMUM_CAPACITY + 1).next_power_of_two();\n+        assert!(cap > capacity, \"capacity overflow\");\n \n         VecDeque {\n             tail: 0,\n@@ -549,7 +553,7 @@ impl<T> VecDeque<T> {\n         if new_cap > old_cap {\n             self.buf.reserve_exact(used_cap, new_cap - used_cap);\n             unsafe {\n-                self.handle_cap_increase(old_cap);\n+                self.handle_capacity_increase(old_cap);\n             }\n         }\n     }\n@@ -639,7 +643,7 @@ impl<T> VecDeque<T> {\n         if new_cap > old_cap {\n             self.buf.try_reserve_exact(used_cap, new_cap - used_cap)?;\n             unsafe {\n-                self.handle_cap_increase(old_cap);\n+                self.handle_capacity_increase(old_cap);\n             }\n         }\n         Ok(())\n@@ -1833,8 +1837,8 @@ impl<T> VecDeque<T> {\n     /// Retains only the elements specified by the predicate.\n     ///\n     /// In other words, remove all elements `e` such that `f(&e)` returns false.\n-    /// This method operates in place and preserves the order of the retained\n-    /// elements.\n+    /// This method operates in place, visiting each element exactly once in the\n+    /// original order, and preserves the order of the retained elements.\n     ///\n     /// # Examples\n     ///\n@@ -1846,6 +1850,20 @@ impl<T> VecDeque<T> {\n     /// buf.retain(|&x| x%2 == 0);\n     /// assert_eq!(buf, [2, 4]);\n     /// ```\n+    ///\n+    /// The exact order may be useful for tracking external state, like an index.\n+    ///\n+    /// ```\n+    /// use std::collections::VecDeque;\n+    ///\n+    /// let mut buf = VecDeque::new();\n+    /// buf.extend(1..6);\n+    ///\n+    /// let keep = [false, true, true, false, true];\n+    /// let mut i = 0;\n+    /// buf.retain(|_| (keep[i], i += 1).0);\n+    /// assert_eq!(buf, [2, 3, 5]);\n+    /// ```\n     #[stable(feature = \"vec_deque_retain\", since = \"1.4.0\")]\n     pub fn retain<F>(&mut self, mut f: F)\n         where F: FnMut(&T) -> bool\n@@ -1871,7 +1889,7 @@ impl<T> VecDeque<T> {\n             let old_cap = self.cap();\n             self.buf.double();\n             unsafe {\n-                self.handle_cap_increase(old_cap);\n+                self.handle_capacity_increase(old_cap);\n             }\n             debug_assert!(!self.is_full());\n         }\n@@ -1932,8 +1950,6 @@ impl<T> VecDeque<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(vecdeque_rotate)]\n-    ///\n     /// use std::collections::VecDeque;\n     ///\n     /// let mut buf: VecDeque<_> = (0..10).collect();\n@@ -1947,7 +1963,7 @@ impl<T> VecDeque<T> {\n     /// }\n     /// assert_eq!(buf, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);\n     /// ```\n-    #[unstable(feature = \"vecdeque_rotate\", issue = \"56686\")]\n+    #[stable(feature = \"vecdeque_rotate\", since = \"1.36.0\")]\n     pub fn rotate_left(&mut self, mid: usize) {\n         assert!(mid <= self.len());\n         let k = self.len() - mid;\n@@ -1977,8 +1993,6 @@ impl<T> VecDeque<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(vecdeque_rotate)]\n-    ///\n     /// use std::collections::VecDeque;\n     ///\n     /// let mut buf: VecDeque<_> = (0..10).collect();\n@@ -1992,7 +2006,7 @@ impl<T> VecDeque<T> {\n     /// }\n     /// assert_eq!(buf, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]);\n     /// ```\n-    #[unstable(feature = \"vecdeque_rotate\", issue = \"56686\")]\n+    #[stable(feature = \"vecdeque_rotate\", since = \"1.36.0\")]\n     pub fn rotate_right(&mut self, k: usize) {\n         assert!(k <= self.len());\n         let mid = self.len() - k;\n@@ -2194,6 +2208,11 @@ impl<'a, T> Iterator for Iter<'a, T> {\n         self.tail = self.head - iter.len();\n         final_res\n     }\n+\n+    #[inline]\n+    fn last(mut self) -> Option<&'a T> {\n+        self.next_back()\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -2307,6 +2326,11 @@ impl<'a, T> Iterator for IterMut<'a, T> {\n         accum = front.iter_mut().fold(accum, &mut f);\n         back.iter_mut().fold(accum, &mut f)\n     }\n+\n+    #[inline]\n+    fn last(mut self) -> Option<&'a mut T> {\n+        self.next_back()\n+    }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n@@ -2549,13 +2573,14 @@ impl<A: PartialEq> PartialEq for VecDeque<A> {\n impl<A: Eq> Eq for VecDeque<A> {}\n \n macro_rules! __impl_slice_eq1 {\n-    ($Lhs: ty, $Rhs: ty) => {\n-        __impl_slice_eq1! { $Lhs, $Rhs, Sized }\n-    };\n-    ($Lhs: ty, $Rhs: ty, $Bound: ident) => {\n+    ([$($vars:tt)*] $lhs:ty, $rhs:ty, $($constraints:tt)*) => {\n         #[stable(feature = \"vec_deque_partial_eq_slice\", since = \"1.17.0\")]\n-        impl<A: $Bound, B> PartialEq<$Rhs> for $Lhs where A: PartialEq<B> {\n-            fn eq(&self, other: &$Rhs) -> bool {\n+        impl<A, B, $($vars)*> PartialEq<$rhs> for $lhs\n+        where\n+            A: PartialEq<B>,\n+            $($constraints)*\n+        {\n+            fn eq(&self, other: &$rhs) -> bool {\n                 if self.len() != other.len() {\n                     return false;\n                 }\n@@ -2567,26 +2592,12 @@ macro_rules! __impl_slice_eq1 {\n     }\n }\n \n-__impl_slice_eq1! { VecDeque<A>, Vec<B> }\n-__impl_slice_eq1! { VecDeque<A>, &[B] }\n-__impl_slice_eq1! { VecDeque<A>, &mut [B] }\n-\n-macro_rules! array_impls {\n-    ($($N: expr)+) => {\n-        $(\n-            __impl_slice_eq1! { VecDeque<A>, [B; $N] }\n-            __impl_slice_eq1! { VecDeque<A>, &[B; $N] }\n-            __impl_slice_eq1! { VecDeque<A>, &mut [B; $N] }\n-        )+\n-    }\n-}\n-\n-array_impls! {\n-     0  1  2  3  4  5  6  7  8  9\n-    10 11 12 13 14 15 16 17 18 19\n-    20 21 22 23 24 25 26 27 28 29\n-    30 31 32\n-}\n+__impl_slice_eq1! { [] VecDeque<A>, Vec<B>, }\n+__impl_slice_eq1! { [] VecDeque<A>, &[B], }\n+__impl_slice_eq1! { [] VecDeque<A>, &mut [B], }\n+__impl_slice_eq1! { [const N: usize] VecDeque<A>, [B; N], [B; N]: LengthAtMost32 }\n+__impl_slice_eq1! { [const N: usize] VecDeque<A>, &[B; N], [B; N]: LengthAtMost32 }\n+__impl_slice_eq1! { [const N: usize] VecDeque<A>, &mut [B; N], [B; N]: LengthAtMost32 }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A: PartialOrd> PartialOrd for VecDeque<A> {\n@@ -2677,9 +2688,7 @@ impl<'a, T> IntoIterator for &'a mut VecDeque<T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<A> Extend<A> for VecDeque<A> {\n     fn extend<T: IntoIterator<Item = A>>(&mut self, iter: T) {\n-        for elt in iter {\n-            self.push_back(elt);\n-        }\n+        iter.into_iter().for_each(move |elt| self.push_back(elt));\n     }\n }\n \n@@ -2699,6 +2708,14 @@ impl<T: fmt::Debug> fmt::Debug for VecDeque<T> {\n \n #[stable(feature = \"vecdeque_vec_conversions\", since = \"1.10.0\")]\n impl<T> From<Vec<T>> for VecDeque<T> {\n+    /// Turn a [`Vec<T>`] into a [`VecDeque<T>`].\n+    ///\n+    /// [`Vec<T>`]: crate::vec::Vec\n+    /// [`VecDeque<T>`]: crate::collections::VecDeque\n+    ///\n+    /// This avoids reallocating where possible, but the conditions for that are\n+    /// strict, and subject to change, and so shouldn't be relied upon unless the\n+    /// `Vec<T>` came from `From<VecDeque<T>>` and hasn't been reallocated.\n     fn from(mut other: Vec<T>) -> Self {\n         unsafe {\n             let other_buf = other.as_mut_ptr();\n@@ -2708,9 +2725,9 @@ impl<T> From<Vec<T>> for VecDeque<T> {\n \n             // We need to extend the buf if it's not a power of two, too small\n             // or doesn't have at least one free space\n-            if !buf.cap().is_power_of_two() || (buf.cap() < (MINIMUM_CAPACITY + 1)) ||\n-               (buf.cap() == len) {\n-                let cap = cmp::max(buf.cap() + 1, MINIMUM_CAPACITY + 1).next_power_of_two();\n+            if !buf.capacity().is_power_of_two() || (buf.capacity() < (MINIMUM_CAPACITY + 1)) ||\n+               (buf.capacity() == len) {\n+                let cap = cmp::max(buf.capacity() + 1, MINIMUM_CAPACITY + 1).next_power_of_two();\n                 buf.reserve_exact(len, cap - len);\n             }\n \n@@ -2725,6 +2742,35 @@ impl<T> From<Vec<T>> for VecDeque<T> {\n \n #[stable(feature = \"vecdeque_vec_conversions\", since = \"1.10.0\")]\n impl<T> From<VecDeque<T>> for Vec<T> {\n+    /// Turn a [`VecDeque<T>`] into a [`Vec<T>`].\n+    ///\n+    /// [`Vec<T>`]: crate::vec::Vec\n+    /// [`VecDeque<T>`]: crate::collections::VecDeque\n+    ///\n+    /// This never needs to re-allocate, but does need to do O(n) data movement if\n+    /// the circular buffer doesn't happen to be at the beginning of the allocation.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// use std::collections::VecDeque;\n+    ///\n+    /// // This one is O(1).\n+    /// let deque: VecDeque<_> = (1..5).collect();\n+    /// let ptr = deque.as_slices().0.as_ptr();\n+    /// let vec = Vec::from(deque);\n+    /// assert_eq!(vec, [1, 2, 3, 4]);\n+    /// assert_eq!(vec.as_ptr(), ptr);\n+    ///\n+    /// // This one needs data rearranging.\n+    /// let mut deque: VecDeque<_> = (1..5).collect();\n+    /// deque.push_front(9);\n+    /// deque.push_front(8);\n+    /// let ptr = deque.as_slices().1.as_ptr();\n+    /// let vec = Vec::from(deque);\n+    /// assert_eq!(vec, [8, 9, 1, 2, 3, 4]);\n+    /// assert_eq!(vec.as_ptr(), ptr);\n+    /// ```\n     fn from(other: VecDeque<T>) -> Self {\n         unsafe {\n             let buf = other.buf.ptr();\n@@ -2793,378 +2839,3 @@ impl<T> From<VecDeque<T>> for Vec<T> {\n         }\n     }\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    use ::test;\n-\n-    use super::VecDeque;\n-\n-    #[bench]\n-    fn bench_push_back_100(b: &mut test::Bencher) {\n-        let mut deq = VecDeque::with_capacity(101);\n-        b.iter(|| {\n-            for i in 0..100 {\n-                deq.push_back(i);\n-            }\n-            deq.head = 0;\n-            deq.tail = 0;\n-        })\n-    }\n-\n-    #[bench]\n-    fn bench_push_front_100(b: &mut test::Bencher) {\n-        let mut deq = VecDeque::with_capacity(101);\n-        b.iter(|| {\n-            for i in 0..100 {\n-                deq.push_front(i);\n-            }\n-            deq.head = 0;\n-            deq.tail = 0;\n-        })\n-    }\n-\n-    #[bench]\n-    fn bench_pop_back_100(b: &mut test::Bencher) {\n-        let mut deq = VecDeque::<i32>::with_capacity(101);\n-\n-        b.iter(|| {\n-            deq.head = 100;\n-            deq.tail = 0;\n-            while !deq.is_empty() {\n-                test::black_box(deq.pop_back());\n-            }\n-        })\n-    }\n-\n-    #[bench]\n-    fn bench_pop_front_100(b: &mut test::Bencher) {\n-        let mut deq = VecDeque::<i32>::with_capacity(101);\n-\n-        b.iter(|| {\n-            deq.head = 100;\n-            deq.tail = 0;\n-            while !deq.is_empty() {\n-                test::black_box(deq.pop_front());\n-            }\n-        })\n-    }\n-\n-    #[test]\n-    fn test_swap_front_back_remove() {\n-        fn test(back: bool) {\n-            // This test checks that every single combination of tail position and length is tested.\n-            // Capacity 15 should be large enough to cover every case.\n-            let mut tester = VecDeque::with_capacity(15);\n-            let usable_cap = tester.capacity();\n-            let final_len = usable_cap / 2;\n-\n-            for len in 0..final_len {\n-                let expected: VecDeque<_> = if back {\n-                    (0..len).collect()\n-                } else {\n-                    (0..len).rev().collect()\n-                };\n-                for tail_pos in 0..usable_cap {\n-                    tester.tail = tail_pos;\n-                    tester.head = tail_pos;\n-                    if back {\n-                        for i in 0..len * 2 {\n-                            tester.push_front(i);\n-                        }\n-                        for i in 0..len {\n-                            assert_eq!(tester.swap_remove_back(i), Some(len * 2 - 1 - i));\n-                        }\n-                    } else {\n-                        for i in 0..len * 2 {\n-                            tester.push_back(i);\n-                        }\n-                        for i in 0..len {\n-                            let idx = tester.len() - 1 - i;\n-                            assert_eq!(tester.swap_remove_front(idx), Some(len * 2 - 1 - i));\n-                        }\n-                    }\n-                    assert!(tester.tail < tester.cap());\n-                    assert!(tester.head < tester.cap());\n-                    assert_eq!(tester, expected);\n-                }\n-            }\n-        }\n-        test(true);\n-        test(false);\n-    }\n-\n-    #[test]\n-    fn test_insert() {\n-        // This test checks that every single combination of tail position, length, and\n-        // insertion position is tested. Capacity 15 should be large enough to cover every case.\n-\n-        let mut tester = VecDeque::with_capacity(15);\n-        // can't guarantee we got 15, so have to get what we got.\n-        // 15 would be great, but we will definitely get 2^k - 1, for k >= 4, or else\n-        // this test isn't covering what it wants to\n-        let cap = tester.capacity();\n-\n-\n-        // len is the length *after* insertion\n-        for len in 1..cap {\n-            // 0, 1, 2, .., len - 1\n-            let expected = (0..).take(len).collect::<VecDeque<_>>();\n-            for tail_pos in 0..cap {\n-                for to_insert in 0..len {\n-                    tester.tail = tail_pos;\n-                    tester.head = tail_pos;\n-                    for i in 0..len {\n-                        if i != to_insert {\n-                            tester.push_back(i);\n-                        }\n-                    }\n-                    tester.insert(to_insert, to_insert);\n-                    assert!(tester.tail < tester.cap());\n-                    assert!(tester.head < tester.cap());\n-                    assert_eq!(tester, expected);\n-                }\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_remove() {\n-        // This test checks that every single combination of tail position, length, and\n-        // removal position is tested. Capacity 15 should be large enough to cover every case.\n-\n-        let mut tester = VecDeque::with_capacity(15);\n-        // can't guarantee we got 15, so have to get what we got.\n-        // 15 would be great, but we will definitely get 2^k - 1, for k >= 4, or else\n-        // this test isn't covering what it wants to\n-        let cap = tester.capacity();\n-\n-        // len is the length *after* removal\n-        for len in 0..cap - 1 {\n-            // 0, 1, 2, .., len - 1\n-            let expected = (0..).take(len).collect::<VecDeque<_>>();\n-            for tail_pos in 0..cap {\n-                for to_remove in 0..=len {\n-                    tester.tail = tail_pos;\n-                    tester.head = tail_pos;\n-                    for i in 0..len {\n-                        if i == to_remove {\n-                            tester.push_back(1234);\n-                        }\n-                        tester.push_back(i);\n-                    }\n-                    if to_remove == len {\n-                        tester.push_back(1234);\n-                    }\n-                    tester.remove(to_remove);\n-                    assert!(tester.tail < tester.cap());\n-                    assert!(tester.head < tester.cap());\n-                    assert_eq!(tester, expected);\n-                }\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_drain() {\n-        let mut tester: VecDeque<usize> = VecDeque::with_capacity(7);\n-\n-        let cap = tester.capacity();\n-        for len in 0..=cap {\n-            for tail in 0..=cap {\n-                for drain_start in 0..=len {\n-                    for drain_end in drain_start..=len {\n-                        tester.tail = tail;\n-                        tester.head = tail;\n-                        for i in 0..len {\n-                            tester.push_back(i);\n-                        }\n-\n-                        // Check that we drain the correct values\n-                        let drained: VecDeque<_> = tester.drain(drain_start..drain_end).collect();\n-                        let drained_expected: VecDeque<_> = (drain_start..drain_end).collect();\n-                        assert_eq!(drained, drained_expected);\n-\n-                        // We shouldn't have changed the capacity or made the\n-                        // head or tail out of bounds\n-                        assert_eq!(tester.capacity(), cap);\n-                        assert!(tester.tail < tester.cap());\n-                        assert!(tester.head < tester.cap());\n-\n-                        // We should see the correct values in the VecDeque\n-                        let expected: VecDeque<_> = (0..drain_start)\n-                            .chain(drain_end..len)\n-                            .collect();\n-                        assert_eq!(expected, tester);\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_shrink_to_fit() {\n-        // This test checks that every single combination of head and tail position,\n-        // is tested. Capacity 15 should be large enough to cover every case.\n-\n-        let mut tester = VecDeque::with_capacity(15);\n-        // can't guarantee we got 15, so have to get what we got.\n-        // 15 would be great, but we will definitely get 2^k - 1, for k >= 4, or else\n-        // this test isn't covering what it wants to\n-        let cap = tester.capacity();\n-        tester.reserve(63);\n-        let max_cap = tester.capacity();\n-\n-        for len in 0..=cap {\n-            // 0, 1, 2, .., len - 1\n-            let expected = (0..).take(len).collect::<VecDeque<_>>();\n-            for tail_pos in 0..=max_cap {\n-                tester.tail = tail_pos;\n-                tester.head = tail_pos;\n-                tester.reserve(63);\n-                for i in 0..len {\n-                    tester.push_back(i);\n-                }\n-                tester.shrink_to_fit();\n-                assert!(tester.capacity() <= cap);\n-                assert!(tester.tail < tester.cap());\n-                assert!(tester.head < tester.cap());\n-                assert_eq!(tester, expected);\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_split_off() {\n-        // This test checks that every single combination of tail position, length, and\n-        // split position is tested. Capacity 15 should be large enough to cover every case.\n-\n-        let mut tester = VecDeque::with_capacity(15);\n-        // can't guarantee we got 15, so have to get what we got.\n-        // 15 would be great, but we will definitely get 2^k - 1, for k >= 4, or else\n-        // this test isn't covering what it wants to\n-        let cap = tester.capacity();\n-\n-        // len is the length *before* splitting\n-        for len in 0..cap {\n-            // index to split at\n-            for at in 0..=len {\n-                // 0, 1, 2, .., at - 1 (may be empty)\n-                let expected_self = (0..).take(at).collect::<VecDeque<_>>();\n-                // at, at + 1, .., len - 1 (may be empty)\n-                let expected_other = (at..).take(len - at).collect::<VecDeque<_>>();\n-\n-                for tail_pos in 0..cap {\n-                    tester.tail = tail_pos;\n-                    tester.head = tail_pos;\n-                    for i in 0..len {\n-                        tester.push_back(i);\n-                    }\n-                    let result = tester.split_off(at);\n-                    assert!(tester.tail < tester.cap());\n-                    assert!(tester.head < tester.cap());\n-                    assert!(result.tail < result.cap());\n-                    assert!(result.head < result.cap());\n-                    assert_eq!(tester, expected_self);\n-                    assert_eq!(result, expected_other);\n-                }\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_from_vec() {\n-        use crate::vec::Vec;\n-        for cap in 0..35 {\n-            for len in 0..=cap {\n-                let mut vec = Vec::with_capacity(cap);\n-                vec.extend(0..len);\n-\n-                let vd = VecDeque::from(vec.clone());\n-                assert!(vd.cap().is_power_of_two());\n-                assert_eq!(vd.len(), vec.len());\n-                assert!(vd.into_iter().eq(vec));\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn test_vec_from_vecdeque() {\n-        use crate::vec::Vec;\n-\n-        fn create_vec_and_test_convert(cap: usize, offset: usize, len: usize) {\n-            let mut vd = VecDeque::with_capacity(cap);\n-            for _ in 0..offset {\n-                vd.push_back(0);\n-                vd.pop_front();\n-            }\n-            vd.extend(0..len);\n-\n-            let vec: Vec<_> = Vec::from(vd.clone());\n-            assert_eq!(vec.len(), vd.len());\n-            assert!(vec.into_iter().eq(vd));\n-        }\n-\n-        for cap_pwr in 0..7 {\n-            // Make capacity as a (2^x)-1, so that the ring size is 2^x\n-            let cap = (2i32.pow(cap_pwr) - 1) as usize;\n-\n-            // In these cases there is enough free space to solve it with copies\n-            for len in 0..((cap + 1) / 2) {\n-                // Test contiguous cases\n-                for offset in 0..(cap - len) {\n-                    create_vec_and_test_convert(cap, offset, len)\n-                }\n-\n-                // Test cases where block at end of buffer is bigger than block at start\n-                for offset in (cap - len)..(cap - (len / 2)) {\n-                    create_vec_and_test_convert(cap, offset, len)\n-                }\n-\n-                // Test cases where block at start of buffer is bigger than block at end\n-                for offset in (cap - (len / 2))..cap {\n-                    create_vec_and_test_convert(cap, offset, len)\n-                }\n-            }\n-\n-            // Now there's not (necessarily) space to straighten the ring with simple copies,\n-            // the ring will use swapping when:\n-            // (cap + 1 - offset) > (cap + 1 - len) && (len - (cap + 1 - offset)) > (cap + 1 - len))\n-            //  right block size  >   free space    &&      left block size       >    free space\n-            for len in ((cap + 1) / 2)..cap {\n-                // Test contiguous cases\n-                for offset in 0..(cap - len) {\n-                    create_vec_and_test_convert(cap, offset, len)\n-                }\n-\n-                // Test cases where block at end of buffer is bigger than block at start\n-                for offset in (cap - len)..(cap - (len / 2)) {\n-                    create_vec_and_test_convert(cap, offset, len)\n-                }\n-\n-                // Test cases where block at start of buffer is bigger than block at end\n-                for offset in (cap - (len / 2))..cap {\n-                    create_vec_and_test_convert(cap, offset, len)\n-                }\n-            }\n-        }\n-    }\n-\n-    #[test]\n-    fn issue_53529() {\n-        use crate::boxed::Box;\n-\n-        let mut dst = VecDeque::new();\n-        dst.push_front(Box::new(1));\n-        dst.push_front(Box::new(2));\n-        assert_eq!(*dst.pop_back().unwrap(), 1);\n-\n-        let mut src = VecDeque::new();\n-        src.push_front(Box::new(2));\n-        dst.append(&mut src);\n-        for a in dst {\n-            assert_eq!(*a, 2);\n-        }\n-    }\n-\n-}"}, {"sha": "d25352399796e684ec503bc05ed8b1597ed48806", "filename": "src/liballoc/collections/vec_deque/tests.rs", "status": "added", "additions": 379, "deletions": 0, "changes": 379, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fliballoc%2Fcollections%2Fvec_deque%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fliballoc%2Fcollections%2Fvec_deque%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fvec_deque%2Ftests.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -0,0 +1,379 @@\n+use super::*;\n+\n+use ::test;\n+\n+#[bench]\n+#[cfg(not(miri))] // Miri does not support benchmarks\n+fn bench_push_back_100(b: &mut test::Bencher) {\n+    let mut deq = VecDeque::with_capacity(101);\n+    b.iter(|| {\n+        for i in 0..100 {\n+            deq.push_back(i);\n+        }\n+        deq.head = 0;\n+        deq.tail = 0;\n+    })\n+}\n+\n+#[bench]\n+#[cfg(not(miri))] // Miri does not support benchmarks\n+fn bench_push_front_100(b: &mut test::Bencher) {\n+    let mut deq = VecDeque::with_capacity(101);\n+    b.iter(|| {\n+        for i in 0..100 {\n+            deq.push_front(i);\n+        }\n+        deq.head = 0;\n+        deq.tail = 0;\n+    })\n+}\n+\n+#[bench]\n+#[cfg(not(miri))] // Miri does not support benchmarks\n+fn bench_pop_back_100(b: &mut test::Bencher) {\n+    let mut deq = VecDeque::<i32>::with_capacity(101);\n+\n+    b.iter(|| {\n+        deq.head = 100;\n+        deq.tail = 0;\n+        while !deq.is_empty() {\n+            test::black_box(deq.pop_back());\n+        }\n+    })\n+}\n+\n+#[bench]\n+#[cfg(not(miri))] // Miri does not support benchmarks\n+fn bench_pop_front_100(b: &mut test::Bencher) {\n+    let mut deq = VecDeque::<i32>::with_capacity(101);\n+\n+    b.iter(|| {\n+        deq.head = 100;\n+        deq.tail = 0;\n+        while !deq.is_empty() {\n+            test::black_box(deq.pop_front());\n+        }\n+    })\n+}\n+\n+#[test]\n+fn test_swap_front_back_remove() {\n+    fn test(back: bool) {\n+        // This test checks that every single combination of tail position and length is tested.\n+        // Capacity 15 should be large enough to cover every case.\n+        let mut tester = VecDeque::with_capacity(15);\n+        let usable_cap = tester.capacity();\n+        let final_len = usable_cap / 2;\n+\n+        for len in 0..final_len {\n+            let expected: VecDeque<_> = if back {\n+                (0..len).collect()\n+            } else {\n+                (0..len).rev().collect()\n+            };\n+            for tail_pos in 0..usable_cap {\n+                tester.tail = tail_pos;\n+                tester.head = tail_pos;\n+                if back {\n+                    for i in 0..len * 2 {\n+                        tester.push_front(i);\n+                    }\n+                    for i in 0..len {\n+                        assert_eq!(tester.swap_remove_back(i), Some(len * 2 - 1 - i));\n+                    }\n+                } else {\n+                    for i in 0..len * 2 {\n+                        tester.push_back(i);\n+                    }\n+                    for i in 0..len {\n+                        let idx = tester.len() - 1 - i;\n+                        assert_eq!(tester.swap_remove_front(idx), Some(len * 2 - 1 - i));\n+                    }\n+                }\n+                assert!(tester.tail < tester.cap());\n+                assert!(tester.head < tester.cap());\n+                assert_eq!(tester, expected);\n+            }\n+        }\n+    }\n+    test(true);\n+    test(false);\n+}\n+\n+#[test]\n+fn test_insert() {\n+    // This test checks that every single combination of tail position, length, and\n+    // insertion position is tested. Capacity 15 should be large enough to cover every case.\n+\n+    let mut tester = VecDeque::with_capacity(15);\n+    // can't guarantee we got 15, so have to get what we got.\n+    // 15 would be great, but we will definitely get 2^k - 1, for k >= 4, or else\n+    // this test isn't covering what it wants to\n+    let cap = tester.capacity();\n+\n+\n+    // len is the length *after* insertion\n+    for len in 1..cap {\n+        // 0, 1, 2, .., len - 1\n+        let expected = (0..).take(len).collect::<VecDeque<_>>();\n+        for tail_pos in 0..cap {\n+            for to_insert in 0..len {\n+                tester.tail = tail_pos;\n+                tester.head = tail_pos;\n+                for i in 0..len {\n+                    if i != to_insert {\n+                        tester.push_back(i);\n+                    }\n+                }\n+                tester.insert(to_insert, to_insert);\n+                assert!(tester.tail < tester.cap());\n+                assert!(tester.head < tester.cap());\n+                assert_eq!(tester, expected);\n+            }\n+        }\n+    }\n+}\n+\n+#[test]\n+fn test_remove() {\n+    // This test checks that every single combination of tail position, length, and\n+    // removal position is tested. Capacity 15 should be large enough to cover every case.\n+\n+    let mut tester = VecDeque::with_capacity(15);\n+    // can't guarantee we got 15, so have to get what we got.\n+    // 15 would be great, but we will definitely get 2^k - 1, for k >= 4, or else\n+    // this test isn't covering what it wants to\n+    let cap = tester.capacity();\n+\n+    // len is the length *after* removal\n+    for len in 0..cap - 1 {\n+        // 0, 1, 2, .., len - 1\n+        let expected = (0..).take(len).collect::<VecDeque<_>>();\n+        for tail_pos in 0..cap {\n+            for to_remove in 0..=len {\n+                tester.tail = tail_pos;\n+                tester.head = tail_pos;\n+                for i in 0..len {\n+                    if i == to_remove {\n+                        tester.push_back(1234);\n+                    }\n+                    tester.push_back(i);\n+                }\n+                if to_remove == len {\n+                    tester.push_back(1234);\n+                }\n+                tester.remove(to_remove);\n+                assert!(tester.tail < tester.cap());\n+                assert!(tester.head < tester.cap());\n+                assert_eq!(tester, expected);\n+            }\n+        }\n+    }\n+}\n+\n+#[test]\n+fn test_drain() {\n+    let mut tester: VecDeque<usize> = VecDeque::with_capacity(7);\n+\n+    let cap = tester.capacity();\n+    for len in 0..=cap {\n+        for tail in 0..=cap {\n+            for drain_start in 0..=len {\n+                for drain_end in drain_start..=len {\n+                    tester.tail = tail;\n+                    tester.head = tail;\n+                    for i in 0..len {\n+                        tester.push_back(i);\n+                    }\n+\n+                    // Check that we drain the correct values\n+                    let drained: VecDeque<_> = tester.drain(drain_start..drain_end).collect();\n+                    let drained_expected: VecDeque<_> = (drain_start..drain_end).collect();\n+                    assert_eq!(drained, drained_expected);\n+\n+                    // We shouldn't have changed the capacity or made the\n+                    // head or tail out of bounds\n+                    assert_eq!(tester.capacity(), cap);\n+                    assert!(tester.tail < tester.cap());\n+                    assert!(tester.head < tester.cap());\n+\n+                    // We should see the correct values in the VecDeque\n+                    let expected: VecDeque<_> = (0..drain_start)\n+                        .chain(drain_end..len)\n+                        .collect();\n+                    assert_eq!(expected, tester);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+#[test]\n+fn test_shrink_to_fit() {\n+    // This test checks that every single combination of head and tail position,\n+    // is tested. Capacity 15 should be large enough to cover every case.\n+\n+    let mut tester = VecDeque::with_capacity(15);\n+    // can't guarantee we got 15, so have to get what we got.\n+    // 15 would be great, but we will definitely get 2^k - 1, for k >= 4, or else\n+    // this test isn't covering what it wants to\n+    let cap = tester.capacity();\n+    tester.reserve(63);\n+    let max_cap = tester.capacity();\n+\n+    for len in 0..=cap {\n+        // 0, 1, 2, .., len - 1\n+        let expected = (0..).take(len).collect::<VecDeque<_>>();\n+        for tail_pos in 0..=max_cap {\n+            tester.tail = tail_pos;\n+            tester.head = tail_pos;\n+            tester.reserve(63);\n+            for i in 0..len {\n+                tester.push_back(i);\n+            }\n+            tester.shrink_to_fit();\n+            assert!(tester.capacity() <= cap);\n+            assert!(tester.tail < tester.cap());\n+            assert!(tester.head < tester.cap());\n+            assert_eq!(tester, expected);\n+        }\n+    }\n+}\n+\n+#[test]\n+fn test_split_off() {\n+    // This test checks that every single combination of tail position, length, and\n+    // split position is tested. Capacity 15 should be large enough to cover every case.\n+\n+    let mut tester = VecDeque::with_capacity(15);\n+    // can't guarantee we got 15, so have to get what we got.\n+    // 15 would be great, but we will definitely get 2^k - 1, for k >= 4, or else\n+    // this test isn't covering what it wants to\n+    let cap = tester.capacity();\n+\n+    // len is the length *before* splitting\n+    for len in 0..cap {\n+        // index to split at\n+        for at in 0..=len {\n+            // 0, 1, 2, .., at - 1 (may be empty)\n+            let expected_self = (0..).take(at).collect::<VecDeque<_>>();\n+            // at, at + 1, .., len - 1 (may be empty)\n+            let expected_other = (at..).take(len - at).collect::<VecDeque<_>>();\n+\n+            for tail_pos in 0..cap {\n+                tester.tail = tail_pos;\n+                tester.head = tail_pos;\n+                for i in 0..len {\n+                    tester.push_back(i);\n+                }\n+                let result = tester.split_off(at);\n+                assert!(tester.tail < tester.cap());\n+                assert!(tester.head < tester.cap());\n+                assert!(result.tail < result.cap());\n+                assert!(result.head < result.cap());\n+                assert_eq!(tester, expected_self);\n+                assert_eq!(result, expected_other);\n+            }\n+        }\n+    }\n+}\n+\n+#[test]\n+fn test_from_vec() {\n+    use crate::vec::Vec;\n+    for cap in 0..35 {\n+        for len in 0..=cap {\n+            let mut vec = Vec::with_capacity(cap);\n+            vec.extend(0..len);\n+\n+            let vd = VecDeque::from(vec.clone());\n+            assert!(vd.cap().is_power_of_two());\n+            assert_eq!(vd.len(), vec.len());\n+            assert!(vd.into_iter().eq(vec));\n+        }\n+    }\n+}\n+\n+#[test]\n+fn test_vec_from_vecdeque() {\n+    use crate::vec::Vec;\n+\n+    fn create_vec_and_test_convert(capacity: usize, offset: usize, len: usize) {\n+        let mut vd = VecDeque::with_capacity(capacity);\n+        for _ in 0..offset {\n+            vd.push_back(0);\n+            vd.pop_front();\n+        }\n+        vd.extend(0..len);\n+\n+        let vec: Vec<_> = Vec::from(vd.clone());\n+        assert_eq!(vec.len(), vd.len());\n+        assert!(vec.into_iter().eq(vd));\n+    }\n+\n+    #[cfg(not(miri))] // Miri is too slow\n+    let max_pwr = 7;\n+    #[cfg(miri)]\n+    let max_pwr = 5;\n+\n+    for cap_pwr in 0..max_pwr {\n+        // Make capacity as a (2^x)-1, so that the ring size is 2^x\n+        let cap = (2i32.pow(cap_pwr) - 1) as usize;\n+\n+        // In these cases there is enough free space to solve it with copies\n+        for len in 0..((cap + 1) / 2) {\n+            // Test contiguous cases\n+            for offset in 0..(cap - len) {\n+                create_vec_and_test_convert(cap, offset, len)\n+            }\n+\n+            // Test cases where block at end of buffer is bigger than block at start\n+            for offset in (cap - len)..(cap - (len / 2)) {\n+                create_vec_and_test_convert(cap, offset, len)\n+            }\n+\n+            // Test cases where block at start of buffer is bigger than block at end\n+            for offset in (cap - (len / 2))..cap {\n+                create_vec_and_test_convert(cap, offset, len)\n+            }\n+        }\n+\n+        // Now there's not (necessarily) space to straighten the ring with simple copies,\n+        // the ring will use swapping when:\n+        // (cap + 1 - offset) > (cap + 1 - len) && (len - (cap + 1 - offset)) > (cap + 1 - len))\n+        //  right block size  >   free space    &&      left block size       >    free space\n+        for len in ((cap + 1) / 2)..cap {\n+            // Test contiguous cases\n+            for offset in 0..(cap - len) {\n+                create_vec_and_test_convert(cap, offset, len)\n+            }\n+\n+            // Test cases where block at end of buffer is bigger than block at start\n+            for offset in (cap - len)..(cap - (len / 2)) {\n+                create_vec_and_test_convert(cap, offset, len)\n+            }\n+\n+            // Test cases where block at start of buffer is bigger than block at end\n+            for offset in (cap - (len / 2))..cap {\n+                create_vec_and_test_convert(cap, offset, len)\n+            }\n+        }\n+    }\n+}\n+\n+#[test]\n+fn issue_53529() {\n+    use crate::boxed::Box;\n+\n+    let mut dst = VecDeque::new();\n+    dst.push_front(Box::new(1));\n+    dst.push_front(Box::new(2));\n+    assert_eq!(*dst.pop_back().unwrap(), 1);\n+\n+    let mut src = VecDeque::new();\n+    src.push_front(Box::new(2));\n+    dst.append(&mut src);\n+    for a in dst {\n+        assert_eq!(*a, 2);\n+    }\n+}"}, {"sha": "68cbc366d7bc2a25bb77e9eaff2761c5a34dd559", "filename": "src/liballoc/fmt.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fliballoc%2Ffmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fliballoc%2Ffmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ffmt.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -343,9 +343,10 @@\n //! * `^` - the argument is center-aligned in `width` columns\n //! * `>` - the argument is right-aligned in `width` columns\n //!\n-//! Note that alignment may not be implemented by some types. A good way\n-//! to ensure padding is applied is to format your input, then use this\n-//! resulting string to pad your output.\n+//! Note that alignment may not be implemented by some types. In particular, it\n+//! is not generally implemented for the `Debug` trait.  A good way to ensure\n+//! padding is applied is to format your input, then use this resulting string\n+//! to pad your output.\n //!\n //! ## Sign/`#`/`0`\n //!"}, {"sha": "deea74daa52d57ca4b74579e0f746ecc8ed60b67", "filename": "src/liballoc/lib.rs", "status": "modified", "additions": 33, "deletions": 26, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fliballoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fliballoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Flib.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -10,30 +10,30 @@\n //!\n //! ## Boxed values\n //!\n-//! The [`Box`](boxed/index.html) type is a smart pointer type. There can\n-//! only be one owner of a `Box`, and the owner can decide to mutate the\n-//! contents, which live on the heap.\n+//! The [`Box`] type is a smart pointer type. There can only be one owner of a\n+//! [`Box`], and the owner can decide to mutate the contents, which live on the\n+//! heap.\n //!\n //! This type can be sent among threads efficiently as the size of a `Box` value\n //! is the same as that of a pointer. Tree-like data structures are often built\n //! with boxes because each node often has only one owner, the parent.\n //!\n //! ## Reference counted pointers\n //!\n-//! The [`Rc`](rc/index.html) type is a non-threadsafe reference-counted pointer\n-//! type intended for sharing memory within a thread. An `Rc` pointer wraps a\n-//! type, `T`, and only allows access to `&T`, a shared reference.\n+//! The [`Rc`] type is a non-threadsafe reference-counted pointer type intended\n+//! for sharing memory within a thread. An [`Rc`] pointer wraps a type, `T`, and\n+//! only allows access to `&T`, a shared reference.\n //!\n-//! This type is useful when inherited mutability (such as using `Box`) is too\n-//! constraining for an application, and is often paired with the `Cell` or\n-//! `RefCell` types in order to allow mutation.\n+//! This type is useful when inherited mutability (such as using [`Box`]) is too\n+//! constraining for an application, and is often paired with the [`Cell`] or\n+//! [`RefCell`] types in order to allow mutation.\n //!\n //! ## Atomically reference counted pointers\n //!\n-//! The [`Arc`](sync/index.html) type is the threadsafe equivalent of the `Rc`\n-//! type. It provides all the same functionality of `Rc`, except it requires\n-//! that the contained type `T` is shareable. Additionally, `Arc<T>` is itself\n-//! sendable while `Rc<T>` is not.\n+//! The [`Arc`] type is the threadsafe equivalent of the [`Rc`] type. It\n+//! provides all the same functionality of [`Rc`], except it requires that the\n+//! contained type `T` is shareable. Additionally, [`Arc<T>`][`Arc`] is itself\n+//! sendable while [`Rc<T>`][`Rc`] is not.\n //!\n //! This type allows for shared access to the contained data, and is often\n //! paired with synchronization primitives such as mutexes to allow mutation of\n@@ -49,24 +49,27 @@\n //!\n //! The [`alloc`](alloc/index.html) module defines the low-level interface to the\n //! default global allocator. It is not compatible with the libc allocator API.\n+//!\n+//! [`Arc`]: sync/index.html\n+//! [`Box`]: boxed/index.html\n+//! [`Cell`]: ../core/cell/index.html\n+//! [`Rc`]: rc/index.html\n+//! [`RefCell`]: ../core/cell/index.html\n \n #![allow(unused_attributes)]\n-#![unstable(feature = \"alloc\",\n-            reason = \"this library is unlikely to be stabilized in its current \\\n-                      form or name\",\n-            issue = \"27783\")]\n+#![stable(feature = \"alloc\", since = \"1.36.0\")]\n #![doc(html_root_url = \"https://doc.rust-lang.org/nightly/\",\n        issue_tracker_base_url = \"https://github.com/rust-lang/rust/issues/\",\n        test(no_crate_inject, attr(allow(unused_variables), deny(warnings))))]\n #![no_std]\n #![needs_allocator]\n \n-#![deny(rust_2018_idioms)]\n-#![allow(explicit_outlives_requirements)]\n-\n #![warn(deprecated_in_future)]\n-#![warn(intra_doc_link_resolution_failure)]\n+#![warn(missing_docs)]\n #![warn(missing_debug_implementations)]\n+#![deny(intra_doc_link_resolution_failure)] // rustdoc is run without -D warnings\n+#![allow(explicit_outlives_requirements)]\n+#![cfg_attr(not(bootstrap), allow(incomplete_features))]\n \n #![cfg_attr(not(test), feature(generator_trait))]\n #![cfg_attr(test, feature(test))]\n@@ -79,25 +82,27 @@\n #![feature(box_syntax)]\n #![feature(cfg_target_has_atomic)]\n #![feature(coerce_unsized)]\n+#![feature(const_generic_impls_guard)]\n+#![feature(const_generics)]\n+#![cfg_attr(not(bootstrap), feature(const_in_array_repeat_expressions))]\n #![feature(dispatch_from_dyn)]\n #![feature(core_intrinsics)]\n-#![feature(custom_attribute)]\n #![feature(dropck_eyepatch)]\n #![feature(exact_size_is_empty)]\n #![feature(fmt_internals)]\n #![feature(fn_traits)]\n #![feature(fundamental)]\n-#![feature(futures_api)]\n+#![feature(internal_uninit_const)]\n #![feature(lang_items)]\n #![feature(libc)]\n-#![feature(needs_allocator)]\n #![feature(nll)]\n #![feature(optin_builtin_traits)]\n #![feature(pattern)]\n #![feature(ptr_internals)]\n #![feature(ptr_offset_from)]\n #![feature(rustc_attrs)]\n #![feature(receiver_trait)]\n+#![feature(slice_from_raw_parts)]\n #![feature(specialization)]\n #![feature(staged_api)]\n #![feature(std_internals)]\n@@ -107,14 +112,16 @@\n #![feature(unboxed_closures)]\n #![feature(unicode_internals)]\n #![feature(unsize)]\n+#![feature(unsized_locals)]\n #![feature(allocator_internals)]\n #![feature(on_unimplemented)]\n #![feature(rustc_const_unstable)]\n #![feature(const_vec_new)]\n #![feature(slice_partition_dedup)]\n-#![feature(maybe_uninit, maybe_uninit_slice, maybe_uninit_array)]\n+#![feature(maybe_uninit_extra, maybe_uninit_slice, maybe_uninit_array)]\n #![feature(alloc_layout_extra)]\n #![feature(try_trait)]\n+#![feature(mem_take)]\n \n // Allow testing this library\n \n@@ -144,7 +151,7 @@ mod boxed {\n     pub use std::boxed::Box;\n }\n #[cfg(test)]\n-mod boxed_test;\n+mod tests;\n pub mod collections;\n #[cfg(all(target_has_atomic = \"ptr\", target_has_atomic = \"cas\"))]\n pub mod sync;"}, {"sha": "250c419c531f8030a1045b6303d5e947a4a5d6d8", "filename": "src/liballoc/macros.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fliballoc%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fliballoc%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fmacros.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -42,7 +42,7 @@ macro_rules! vec {\n     ($($x:expr),*) => (\n         <[_]>::into_vec(box [$($x),*])\n     );\n-    ($($x:expr,)*) => (vec![$($x),*])\n+    ($($x:expr,)*) => ($crate::vec![$($x),*])\n }\n \n // HACK(japaric): with cfg(test) the inherent `[T]::into_vec` method, which is"}, {"sha": "6767cf89f73ba2ce205cd784050eda5b9be72e5f", "filename": "src/liballoc/prelude.rs", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/33445aea509cadcd715009c79795d289268daa7c/src%2Fliballoc%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33445aea509cadcd715009c79795d289268daa7c/src%2Fliballoc%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fprelude.rs?ref=33445aea509cadcd715009c79795d289268daa7c", "patch": "@@ -1,19 +0,0 @@\n-//! The alloc Prelude\n-//!\n-//! The purpose of this module is to alleviate imports of commonly-used\n-//! items of the `alloc` crate by adding a glob import to the top of modules:\n-//!\n-//! ```\n-//! # #![allow(unused_imports)]\n-//! # #![feature(alloc)]\n-//! extern crate alloc;\n-//! use alloc::prelude::*;\n-//! ```\n-\n-#![unstable(feature = \"alloc\", issue = \"27783\")]\n-\n-#[unstable(feature = \"alloc\", issue = \"27783\")] pub use crate::borrow::ToOwned;\n-#[unstable(feature = \"alloc\", issue = \"27783\")] pub use crate::boxed::Box;\n-#[unstable(feature = \"alloc\", issue = \"27783\")] pub use crate::slice::SliceConcatExt;\n-#[unstable(feature = \"alloc\", issue = \"27783\")] pub use crate::string::{String, ToString};\n-#[unstable(feature = \"alloc\", issue = \"27783\")] pub use crate::vec::Vec;"}, {"sha": "0534ad3edc79d541ebe1695f81ffaf7ff455d441", "filename": "src/liballoc/prelude/mod.rs", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fliballoc%2Fprelude%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fliballoc%2Fprelude%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fprelude%2Fmod.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -0,0 +1,15 @@\n+//! The alloc Prelude\n+//!\n+//! The purpose of this module is to alleviate imports of commonly-used\n+//! items of the `alloc` crate by adding a glob import to the top of modules:\n+//!\n+//! ```\n+//! # #![allow(unused_imports)]\n+//! #![feature(alloc_prelude)]\n+//! extern crate alloc;\n+//! use alloc::prelude::v1::*;\n+//! ```\n+\n+#![unstable(feature = \"alloc_prelude\", issue = \"58935\")]\n+\n+pub mod v1;"}, {"sha": "3cb285bf0492f5ccf32252c89547bbe6f6232866", "filename": "src/liballoc/prelude/v1.rs", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fliballoc%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fliballoc%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fprelude%2Fv1.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -0,0 +1,10 @@\n+//! The first version of the prelude of `alloc` crate.\n+//!\n+//! See the [module-level documentation](../index.html) for more.\n+\n+#![unstable(feature = \"alloc_prelude\", issue = \"58935\")]\n+\n+#[unstable(feature = \"alloc_prelude\", issue = \"58935\")] pub use crate::borrow::ToOwned;\n+#[unstable(feature = \"alloc_prelude\", issue = \"58935\")] pub use crate::boxed::Box;\n+#[unstable(feature = \"alloc_prelude\", issue = \"58935\")] pub use crate::string::{String, ToString};\n+#[unstable(feature = \"alloc_prelude\", issue = \"58935\")] pub use crate::vec::Vec;"}, {"sha": "0abab45e920cc8bd7ad88ac2b6551b857804bc2c", "filename": "src/liballoc/raw_vec.rs", "status": "modified", "additions": 66, "deletions": 139, "changes": 205, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fliballoc%2Fraw_vec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fliballoc%2Fraw_vec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -11,6 +11,9 @@ use crate::alloc::{Alloc, Layout, Global, handle_alloc_error};\n use crate::collections::CollectionAllocErr::{self, *};\n use crate::boxed::Box;\n \n+#[cfg(test)]\n+mod tests;\n+\n /// A low-level utility for more ergonomically allocating, reallocating, and deallocating\n /// a buffer of memory on the heap without having to worry about all the corner cases\n /// involved. This type is excellent for building your own data structures like Vec and VecDeque.\n@@ -34,7 +37,7 @@ use crate::boxed::Box;\n /// that might occur with zero-sized types.\n ///\n /// However this means that you need to be careful when round-tripping this type\n-/// with a `Box<[T]>`: `cap()` won't yield the len. However `with_capacity`,\n+/// with a `Box<[T]>`: `capacity()` won't yield the len. However `with_capacity`,\n /// `shrink_to_fit`, and `from_box` will actually set RawVec's private capacity\n /// field. This allows zero-sized types to not be special-cased by consumers of\n /// this type.\n@@ -65,25 +68,25 @@ impl<T, A: Alloc> RawVec<T, A> {\n     /// Like `with_capacity` but parameterized over the choice of\n     /// allocator for the returned RawVec.\n     #[inline]\n-    pub fn with_capacity_in(cap: usize, a: A) -> Self {\n-        RawVec::allocate_in(cap, false, a)\n+    pub fn with_capacity_in(capacity: usize, a: A) -> Self {\n+        RawVec::allocate_in(capacity, false, a)\n     }\n \n     /// Like `with_capacity_zeroed` but parameterized over the choice\n     /// of allocator for the returned RawVec.\n     #[inline]\n-    pub fn with_capacity_zeroed_in(cap: usize, a: A) -> Self {\n-        RawVec::allocate_in(cap, true, a)\n+    pub fn with_capacity_zeroed_in(capacity: usize, a: A) -> Self {\n+        RawVec::allocate_in(capacity, true, a)\n     }\n \n-    fn allocate_in(cap: usize, zeroed: bool, mut a: A) -> Self {\n+    fn allocate_in(capacity: usize, zeroed: bool, mut a: A) -> Self {\n         unsafe {\n             let elem_size = mem::size_of::<T>();\n \n-            let alloc_size = cap.checked_mul(elem_size).unwrap_or_else(|| capacity_overflow());\n+            let alloc_size = capacity.checked_mul(elem_size).unwrap_or_else(|| capacity_overflow());\n             alloc_guard(alloc_size).unwrap_or_else(|_| capacity_overflow());\n \n-            // handles ZSTs and `cap = 0` alike\n+            // handles ZSTs and `capacity = 0` alike\n             let ptr = if alloc_size == 0 {\n                 NonNull::<T>::dangling()\n             } else {\n@@ -102,7 +105,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n \n             RawVec {\n                 ptr: ptr.into(),\n-                cap,\n+                cap: capacity,\n                 a,\n             }\n         }\n@@ -120,8 +123,8 @@ impl<T> RawVec<T, Global> {\n     }\n \n     /// Creates a RawVec (on the system heap) with exactly the\n-    /// capacity and alignment requirements for a `[T; cap]`. This is\n-    /// equivalent to calling RawVec::new when `cap` is 0 or T is\n+    /// capacity and alignment requirements for a `[T; capacity]`. This is\n+    /// equivalent to calling RawVec::new when `capacity` is 0 or T is\n     /// zero-sized. Note that if `T` is zero-sized this means you will\n     /// *not* get a RawVec with the requested capacity!\n     ///\n@@ -135,14 +138,14 @@ impl<T> RawVec<T, Global> {\n     ///\n     /// Aborts on OOM\n     #[inline]\n-    pub fn with_capacity(cap: usize) -> Self {\n-        RawVec::allocate_in(cap, false, Global)\n+    pub fn with_capacity(capacity: usize) -> Self {\n+        RawVec::allocate_in(capacity, false, Global)\n     }\n \n     /// Like `with_capacity` but guarantees the buffer is zeroed.\n     #[inline]\n-    pub fn with_capacity_zeroed(cap: usize) -> Self {\n-        RawVec::allocate_in(cap, true, Global)\n+    pub fn with_capacity_zeroed(capacity: usize) -> Self {\n+        RawVec::allocate_in(capacity, true, Global)\n     }\n }\n \n@@ -154,10 +157,10 @@ impl<T, A: Alloc> RawVec<T, A> {\n     /// The ptr must be allocated (via the given allocator `a`), and with the given capacity. The\n     /// capacity cannot exceed `isize::MAX` (only a concern on 32-bit systems).\n     /// If the ptr and capacity come from a RawVec created via `a`, then this is guaranteed.\n-    pub unsafe fn from_raw_parts_in(ptr: *mut T, cap: usize, a: A) -> Self {\n+    pub unsafe fn from_raw_parts_in(ptr: *mut T, capacity: usize, a: A) -> Self {\n         RawVec {\n             ptr: Unique::new_unchecked(ptr),\n-            cap,\n+            cap: capacity,\n             a,\n         }\n     }\n@@ -171,10 +174,10 @@ impl<T> RawVec<T, Global> {\n     /// The ptr must be allocated (on the system heap), and with the given capacity. The\n     /// capacity cannot exceed `isize::MAX` (only a concern on 32-bit systems).\n     /// If the ptr and capacity come from a RawVec, then this is guaranteed.\n-    pub unsafe fn from_raw_parts(ptr: *mut T, cap: usize) -> Self {\n+    pub unsafe fn from_raw_parts(ptr: *mut T, capacity: usize) -> Self {\n         RawVec {\n             ptr: Unique::new_unchecked(ptr),\n-            cap,\n+            cap: capacity,\n             a: Global,\n         }\n     }\n@@ -191,7 +194,7 @@ impl<T> RawVec<T, Global> {\n \n impl<T, A: Alloc> RawVec<T, A> {\n     /// Gets a raw pointer to the start of the allocation. Note that this is\n-    /// Unique::empty() if `cap = 0` or T is zero-sized. In the former case, you must\n+    /// Unique::empty() if `capacity = 0` or T is zero-sized. In the former case, you must\n     /// be careful.\n     pub fn ptr(&self) -> *mut T {\n         self.ptr.as_ptr()\n@@ -201,7 +204,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n     ///\n     /// This will always be `usize::MAX` if `T` is zero-sized.\n     #[inline(always)]\n-    pub fn cap(&self) -> usize {\n+    pub fn capacity(&self) -> usize {\n         if mem::size_of::<T>() == 0 {\n             !0\n         } else {\n@@ -240,7 +243,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n     /// This function is ideal for when pushing elements one-at-a-time because\n     /// you don't need to incur the costs of the more general computations\n     /// reserve needs to do to guard against overflow. You do however need to\n-    /// manually check if your `len == cap`.\n+    /// manually check if your `len == capacity`.\n     ///\n     /// # Panics\n     ///\n@@ -256,7 +259,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(alloc, raw_vec_internals)]\n+    /// # #![feature(raw_vec_internals)]\n     /// # extern crate alloc;\n     /// # use std::ptr;\n     /// # use alloc::raw_vec::RawVec;\n@@ -267,7 +270,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n     ///\n     /// impl<T> MyVec<T> {\n     ///     pub fn push(&mut self, elem: T) {\n-    ///         if self.len == self.buf.cap() { self.buf.double(); }\n+    ///         if self.len == self.buf.capacity() { self.buf.double(); }\n     ///         // double would have aborted or panicked if the len exceeded\n     ///         // `isize::MAX` so this is safe to do unchecked now.\n     ///         unsafe {\n@@ -381,20 +384,20 @@ impl<T, A: Alloc> RawVec<T, A> {\n     }\n \n     /// The same as `reserve_exact`, but returns on errors instead of panicking or aborting.\n-    pub fn try_reserve_exact(&mut self, used_cap: usize, needed_extra_cap: usize)\n+    pub fn try_reserve_exact(&mut self, used_capacity: usize, needed_extra_capacity: usize)\n            -> Result<(), CollectionAllocErr> {\n \n-        self.reserve_internal(used_cap, needed_extra_cap, Fallible, Exact)\n+        self.reserve_internal(used_capacity, needed_extra_capacity, Fallible, Exact)\n     }\n \n     /// Ensures that the buffer contains at least enough space to hold\n-    /// `used_cap + needed_extra_cap` elements. If it doesn't already,\n+    /// `used_capacity + needed_extra_capacity` elements. If it doesn't already,\n     /// will reallocate the minimum possible amount of memory necessary.\n     /// Generally this will be exactly the amount of memory necessary,\n     /// but in principle the allocator is free to give back more than\n     /// we asked for.\n     ///\n-    /// If `used_cap` exceeds `self.cap()`, this may fail to actually allocate\n+    /// If `used_capacity` exceeds `self.capacity()`, this may fail to actually allocate\n     /// the requested space. This is not really unsafe, but the unsafe\n     /// code *you* write that relies on the behavior of this function may break.\n     ///\n@@ -407,41 +410,42 @@ impl<T, A: Alloc> RawVec<T, A> {\n     /// # Aborts\n     ///\n     /// Aborts on OOM\n-    pub fn reserve_exact(&mut self, used_cap: usize, needed_extra_cap: usize) {\n-        match self.reserve_internal(used_cap, needed_extra_cap, Infallible, Exact) {\n+    pub fn reserve_exact(&mut self, used_capacity: usize, needed_extra_capacity: usize) {\n+        match self.reserve_internal(used_capacity, needed_extra_capacity, Infallible, Exact) {\n             Err(CapacityOverflow) => capacity_overflow(),\n             Err(AllocErr) => unreachable!(),\n             Ok(()) => { /* yay */ }\n          }\n      }\n \n-    /// Calculates the buffer's new size given that it'll hold `used_cap +\n-    /// needed_extra_cap` elements. This logic is used in amortized reserve methods.\n+    /// Calculates the buffer's new size given that it'll hold `used_capacity +\n+    /// needed_extra_capacity` elements. This logic is used in amortized reserve methods.\n     /// Returns `(new_capacity, new_alloc_size)`.\n-    fn amortized_new_size(&self, used_cap: usize, needed_extra_cap: usize)\n+    fn amortized_new_size(&self, used_capacity: usize, needed_extra_capacity: usize)\n         -> Result<usize, CollectionAllocErr> {\n \n         // Nothing we can really do about these checks :(\n-        let required_cap = used_cap.checked_add(needed_extra_cap).ok_or(CapacityOverflow)?;\n+        let required_cap = used_capacity.checked_add(needed_extra_capacity)\n+            .ok_or(CapacityOverflow)?;\n         // Cannot overflow, because `cap <= isize::MAX`, and type of `cap` is `usize`.\n         let double_cap = self.cap * 2;\n         // `double_cap` guarantees exponential growth.\n         Ok(cmp::max(double_cap, required_cap))\n     }\n \n     /// The same as `reserve`, but returns on errors instead of panicking or aborting.\n-    pub fn try_reserve(&mut self, used_cap: usize, needed_extra_cap: usize)\n+    pub fn try_reserve(&mut self, used_capacity: usize, needed_extra_capacity: usize)\n         -> Result<(), CollectionAllocErr> {\n-        self.reserve_internal(used_cap, needed_extra_cap, Fallible, Amortized)\n+        self.reserve_internal(used_capacity, needed_extra_capacity, Fallible, Amortized)\n     }\n \n     /// Ensures that the buffer contains at least enough space to hold\n-    /// `used_cap + needed_extra_cap` elements. If it doesn't already have\n+    /// `used_capacity + needed_extra_capacity` elements. If it doesn't already have\n     /// enough capacity, will reallocate enough space plus comfortable slack\n     /// space to get amortized `O(1)` behavior. Will limit this behavior\n     /// if it would needlessly cause itself to panic.\n     ///\n-    /// If `used_cap` exceeds `self.cap()`, this may fail to actually allocate\n+    /// If `used_capacity` exceeds `self.capacity()`, this may fail to actually allocate\n     /// the requested space. This is not really unsafe, but the unsafe\n     /// code *you* write that relies on the behavior of this function may break.\n     ///\n@@ -460,7 +464,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n     /// # Examples\n     ///\n     /// ```\n-    /// # #![feature(alloc, raw_vec_internals)]\n+    /// # #![feature(raw_vec_internals)]\n     /// # extern crate alloc;\n     /// # use std::ptr;\n     /// # use alloc::raw_vec::RawVec;\n@@ -487,20 +491,20 @@ impl<T, A: Alloc> RawVec<T, A> {\n     /// #   vector.push_all(&[1, 3, 5, 7, 9]);\n     /// # }\n     /// ```\n-    pub fn reserve(&mut self, used_cap: usize, needed_extra_cap: usize) {\n-        match self.reserve_internal(used_cap, needed_extra_cap, Infallible, Amortized) {\n+    pub fn reserve(&mut self, used_capacity: usize, needed_extra_capacity: usize) {\n+        match self.reserve_internal(used_capacity, needed_extra_capacity, Infallible, Amortized) {\n             Err(CapacityOverflow) => capacity_overflow(),\n             Err(AllocErr) => unreachable!(),\n             Ok(()) => { /* yay */ }\n         }\n     }\n     /// Attempts to ensure that the buffer contains at least enough space to hold\n-    /// `used_cap + needed_extra_cap` elements. If it doesn't already have\n+    /// `used_capacity + needed_extra_capacity` elements. If it doesn't already have\n     /// enough capacity, will reallocate in place enough space plus comfortable slack\n     /// space to get amortized `O(1)` behavior. Will limit this behaviour\n     /// if it would needlessly cause itself to panic.\n     ///\n-    /// If `used_cap` exceeds `self.cap()`, this may fail to actually allocate\n+    /// If `used_capacity` exceeds `self.capacity()`, this may fail to actually allocate\n     /// the requested space. This is not really unsafe, but the unsafe\n     /// code *you* write that relies on the behavior of this function may break.\n     ///\n@@ -511,7 +515,7 @@ impl<T, A: Alloc> RawVec<T, A> {\n     /// * Panics if the requested capacity exceeds `usize::MAX` bytes.\n     /// * Panics on 32-bit platforms if the requested capacity exceeds\n     ///   `isize::MAX` bytes.\n-    pub fn reserve_in_place(&mut self, used_cap: usize, needed_extra_cap: usize) -> bool {\n+    pub fn reserve_in_place(&mut self, used_capacity: usize, needed_extra_capacity: usize) -> bool {\n         unsafe {\n             // NOTE: we don't early branch on ZSTs here because we want this\n             // to actually catch \"asking for more than usize::MAX\" in that case.\n@@ -520,20 +524,20 @@ impl<T, A: Alloc> RawVec<T, A> {\n \n             // Don't actually need any more capacity. If the current `cap` is 0, we can't\n             // reallocate in place.\n-            // Wrapping in case they give a bad `used_cap`\n+            // Wrapping in case they give a bad `used_capacity`\n             let old_layout = match self.current_layout() {\n                 Some(layout) => layout,\n                 None => return false,\n             };\n-            if self.cap().wrapping_sub(used_cap) >= needed_extra_cap {\n+            if self.capacity().wrapping_sub(used_capacity) >= needed_extra_capacity {\n                 return false;\n             }\n \n-            let new_cap = self.amortized_new_size(used_cap, needed_extra_cap)\n+            let new_cap = self.amortized_new_size(used_capacity, needed_extra_capacity)\n                 .unwrap_or_else(|_| capacity_overflow());\n \n-            // Here, `cap < used_cap + needed_extra_cap <= new_cap`\n-            // (regardless of whether `self.cap - used_cap` wrapped).\n+            // Here, `cap < used_capacity + needed_extra_capacity <= new_cap`\n+            // (regardless of whether `self.cap - used_capacity` wrapped).\n             // Therefore we can safely call grow_in_place.\n \n             let new_layout = Layout::new::<T>().repeat(new_cap).unwrap().0;\n@@ -632,8 +636,8 @@ use ReserveStrategy::*;\n impl<T, A: Alloc> RawVec<T, A> {\n     fn reserve_internal(\n         &mut self,\n-        used_cap: usize,\n-        needed_extra_cap: usize,\n+        used_capacity: usize,\n+        needed_extra_capacity: usize,\n         fallibility: Fallibility,\n         strategy: ReserveStrategy,\n     ) -> Result<(), CollectionAllocErr> {\n@@ -646,15 +650,15 @@ impl<T, A: Alloc> RawVec<T, A> {\n             // panic.\n \n             // Don't actually need any more capacity.\n-            // Wrapping in case they gave a bad `used_cap`.\n-            if self.cap().wrapping_sub(used_cap) >= needed_extra_cap {\n+            // Wrapping in case they gave a bad `used_capacity`.\n+            if self.capacity().wrapping_sub(used_capacity) >= needed_extra_capacity {\n                 return Ok(());\n             }\n \n             // Nothing we can really do about these checks :(\n             let new_cap = match strategy {\n-                Exact => used_cap.checked_add(needed_extra_cap).ok_or(CapacityOverflow)?,\n-                Amortized => self.amortized_new_size(used_cap, needed_extra_cap)?,\n+                Exact => used_capacity.checked_add(needed_extra_capacity).ok_or(CapacityOverflow)?,\n+                Amortized => self.amortized_new_size(used_capacity, needed_extra_capacity)?,\n             };\n             let new_layout = Layout::array::<T>(new_cap).map_err(|_| CapacityOverflow)?;\n \n@@ -685,14 +689,16 @@ impl<T, A: Alloc> RawVec<T, A> {\n impl<T> RawVec<T, Global> {\n     /// Converts the entire buffer into `Box<[T]>`.\n     ///\n-    /// While it is not *strictly* Undefined Behavior to call\n-    /// this procedure while some of the RawVec is uninitialized,\n-    /// it certainly makes it trivial to trigger it.\n-    ///\n     /// Note that this will correctly reconstitute any `cap` changes\n     /// that may have been performed. (see description of type for details)\n+    ///\n+    /// # Undefined Behavior\n+    ///\n+    /// All elements of `RawVec<T, Global>` must be initialized. Notice that\n+    /// the rules around uninitialized boxed values are not finalized yet,\n+    /// but until they are, it is advisable to avoid them.\n     pub unsafe fn into_box(self) -> Box<[T]> {\n-        // NOTE: not calling `cap()` here, actually using the real `cap` field!\n+        // NOTE: not calling `capacity()` here, actually using the real `cap` field!\n         let slice = slice::from_raw_parts_mut(self.ptr(), self.cap);\n         let output: Box<[T]> = Box::from_raw(slice);\n         mem::forget(self);\n@@ -745,82 +751,3 @@ fn alloc_guard(alloc_size: usize) -> Result<(), CollectionAllocErr> {\n fn capacity_overflow() -> ! {\n     panic!(\"capacity overflow\")\n }\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-\n-    #[test]\n-    fn allocator_param() {\n-        use crate::alloc::AllocErr;\n-\n-        // Writing a test of integration between third-party\n-        // allocators and RawVec is a little tricky because the RawVec\n-        // API does not expose fallible allocation methods, so we\n-        // cannot check what happens when allocator is exhausted\n-        // (beyond detecting a panic).\n-        //\n-        // Instead, this just checks that the RawVec methods do at\n-        // least go through the Allocator API when it reserves\n-        // storage.\n-\n-        // A dumb allocator that consumes a fixed amount of fuel\n-        // before allocation attempts start failing.\n-        struct BoundedAlloc { fuel: usize }\n-        unsafe impl Alloc for BoundedAlloc {\n-            unsafe fn alloc(&mut self, layout: Layout) -> Result<NonNull<u8>, AllocErr> {\n-                let size = layout.size();\n-                if size > self.fuel {\n-                    return Err(AllocErr);\n-                }\n-                match Global.alloc(layout) {\n-                    ok @ Ok(_) => { self.fuel -= size; ok }\n-                    err @ Err(_) => err,\n-                }\n-            }\n-            unsafe fn dealloc(&mut self, ptr: NonNull<u8>, layout: Layout) {\n-                Global.dealloc(ptr, layout)\n-            }\n-        }\n-\n-        let a = BoundedAlloc { fuel: 500 };\n-        let mut v: RawVec<u8, _> = RawVec::with_capacity_in(50, a);\n-        assert_eq!(v.a.fuel, 450);\n-        v.reserve(50, 150); // (causes a realloc, thus using 50 + 150 = 200 units of fuel)\n-        assert_eq!(v.a.fuel, 250);\n-    }\n-\n-    #[test]\n-    fn reserve_does_not_overallocate() {\n-        {\n-            let mut v: RawVec<u32> = RawVec::new();\n-            // First `reserve` allocates like `reserve_exact`\n-            v.reserve(0, 9);\n-            assert_eq!(9, v.cap());\n-        }\n-\n-        {\n-            let mut v: RawVec<u32> = RawVec::new();\n-            v.reserve(0, 7);\n-            assert_eq!(7, v.cap());\n-            // 97 if more than double of 7, so `reserve` should work\n-            // like `reserve_exact`.\n-            v.reserve(7, 90);\n-            assert_eq!(97, v.cap());\n-        }\n-\n-        {\n-            let mut v: RawVec<u32> = RawVec::new();\n-            v.reserve(0, 12);\n-            assert_eq!(12, v.cap());\n-            v.reserve(12, 3);\n-            // 3 is less than half of 12, so `reserve` must grow\n-            // exponentially. At the time of writing this test grow\n-            // factor is 2, so new capacity is 24, however, grow factor\n-            // of 1.5 is OK too. Hence `>= 18` in assert.\n-            assert!(v.cap() >= 12 + 12 / 2);\n-        }\n-    }\n-\n-\n-}"}, {"sha": "c389898d1ef0450c3bdf3f168b45fbb40e71e089", "filename": "src/liballoc/raw_vec/tests.rs", "status": "added", "additions": 73, "deletions": 0, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fliballoc%2Fraw_vec%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fliballoc%2Fraw_vec%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fraw_vec%2Ftests.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -0,0 +1,73 @@\n+use super::*;\n+\n+#[test]\n+fn allocator_param() {\n+    use crate::alloc::AllocErr;\n+\n+    // Writing a test of integration between third-party\n+    // allocators and RawVec is a little tricky because the RawVec\n+    // API does not expose fallible allocation methods, so we\n+    // cannot check what happens when allocator is exhausted\n+    // (beyond detecting a panic).\n+    //\n+    // Instead, this just checks that the RawVec methods do at\n+    // least go through the Allocator API when it reserves\n+    // storage.\n+\n+    // A dumb allocator that consumes a fixed amount of fuel\n+    // before allocation attempts start failing.\n+    struct BoundedAlloc { fuel: usize }\n+    unsafe impl Alloc for BoundedAlloc {\n+        unsafe fn alloc(&mut self, layout: Layout) -> Result<NonNull<u8>, AllocErr> {\n+            let size = layout.size();\n+            if size > self.fuel {\n+                return Err(AllocErr);\n+            }\n+            match Global.alloc(layout) {\n+                ok @ Ok(_) => { self.fuel -= size; ok }\n+                err @ Err(_) => err,\n+            }\n+        }\n+        unsafe fn dealloc(&mut self, ptr: NonNull<u8>, layout: Layout) {\n+            Global.dealloc(ptr, layout)\n+        }\n+    }\n+\n+    let a = BoundedAlloc { fuel: 500 };\n+    let mut v: RawVec<u8, _> = RawVec::with_capacity_in(50, a);\n+    assert_eq!(v.a.fuel, 450);\n+    v.reserve(50, 150); // (causes a realloc, thus using 50 + 150 = 200 units of fuel)\n+    assert_eq!(v.a.fuel, 250);\n+}\n+\n+#[test]\n+fn reserve_does_not_overallocate() {\n+    {\n+        let mut v: RawVec<u32> = RawVec::new();\n+        // First `reserve` allocates like `reserve_exact`\n+        v.reserve(0, 9);\n+        assert_eq!(9, v.capacity());\n+    }\n+\n+    {\n+        let mut v: RawVec<u32> = RawVec::new();\n+        v.reserve(0, 7);\n+        assert_eq!(7, v.capacity());\n+        // 97 if more than double of 7, so `reserve` should work\n+        // like `reserve_exact`.\n+        v.reserve(7, 90);\n+        assert_eq!(97, v.capacity());\n+    }\n+\n+    {\n+        let mut v: RawVec<u32> = RawVec::new();\n+        v.reserve(0, 12);\n+        assert_eq!(12, v.capacity());\n+        v.reserve(12, 3);\n+        // 3 is less than half of 12, so `reserve` must grow\n+        // exponentially. At the time of writing this test grow\n+        // factor is 2, so new capacity is 24, however, grow factor\n+        // of 1.5 is OK too. Hence `>= 18` in assert.\n+        assert!(v.capacity() >= 12 + 12 / 2);\n+    }\n+}"}, {"sha": "0c406a92029a78de30d5a255bd689f037266e327", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 431, "deletions": 527, "changes": 958, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -232,25 +232,30 @@ use crate::boxed::Box;\n use std::boxed::Box;\n \n use core::any::Any;\n+use core::array::LengthAtMost32;\n use core::borrow;\n use core::cell::Cell;\n use core::cmp::Ordering;\n use core::fmt;\n use core::hash::{Hash, Hasher};\n use core::intrinsics::abort;\n+use core::iter;\n use core::marker::{self, Unpin, Unsize, PhantomData};\n-use core::mem::{self, align_of_val, forget, size_of_val};\n+use core::mem::{self, align_of, align_of_val, forget, size_of_val};\n use core::ops::{Deref, Receiver, CoerceUnsized, DispatchFromDyn};\n use core::pin::Pin;\n use core::ptr::{self, NonNull};\n-use core::slice::from_raw_parts_mut;\n-use core::convert::From;\n+use core::slice::{self, from_raw_parts_mut};\n+use core::convert::{From, TryFrom};\n use core::usize;\n \n use crate::alloc::{Global, Alloc, Layout, box_free, handle_alloc_error};\n use crate::string::String;\n use crate::vec::Vec;\n \n+#[cfg(test)]\n+mod tests;\n+\n struct RcBox<T: ?Sized> {\n     strong: Cell<usize>,\n     weak: Cell<usize>,\n@@ -286,6 +291,19 @@ impl<T: ?Sized + Unsize<U>, U: ?Sized> CoerceUnsized<Rc<U>> for Rc<T> {}\n #[unstable(feature = \"dispatch_from_dyn\", issue = \"0\")]\n impl<T: ?Sized + Unsize<U>, U: ?Sized> DispatchFromDyn<Rc<U>> for Rc<T> {}\n \n+impl<T: ?Sized> Rc<T> {\n+    fn from_inner(ptr: NonNull<RcBox<T>>) -> Self {\n+        Self {\n+            ptr,\n+            phantom: PhantomData,\n+        }\n+    }\n+\n+    unsafe fn from_ptr(ptr: *mut RcBox<T>) -> Self {\n+        Self::from_inner(NonNull::new_unchecked(ptr))\n+    }\n+}\n+\n impl<T> Rc<T> {\n     /// Constructs a new `Rc<T>`.\n     ///\n@@ -298,18 +316,15 @@ impl<T> Rc<T> {\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     pub fn new(value: T) -> Rc<T> {\n-        Rc {\n-            // there is an implicit weak pointer owned by all the strong\n-            // pointers, which ensures that the weak destructor never frees\n-            // the allocation while the strong destructor is running, even\n-            // if the weak pointer is stored inside the strong one.\n-            ptr: Box::into_raw_non_null(box RcBox {\n-                strong: Cell::new(1),\n-                weak: Cell::new(1),\n-                value,\n-            }),\n-            phantom: PhantomData,\n-        }\n+        // There is an implicit weak pointer owned by all the strong\n+        // pointers, which ensures that the weak destructor never frees\n+        // the allocation while the strong destructor is running, even\n+        // if the weak pointer is stored inside the strong one.\n+        Self::from_inner(Box::into_raw_non_null(box RcBox {\n+            strong: Cell::new(1),\n+            weak: Cell::new(1),\n+            value,\n+        }))\n     }\n \n     /// Constructs a new `Pin<Rc<T>>`. If `T` does not implement `Unpin`, then\n@@ -375,9 +390,9 @@ impl<T: ?Sized> Rc<T> {\n     /// ```\n     /// use std::rc::Rc;\n     ///\n-    /// let x = Rc::new(10);\n+    /// let x = Rc::new(\"hello\".to_owned());\n     /// let x_ptr = Rc::into_raw(x);\n-    /// assert_eq!(unsafe { *x_ptr }, 10);\n+    /// assert_eq!(unsafe { &*x_ptr }, \"hello\");\n     /// ```\n     #[stable(feature = \"rc_raw\", since = \"1.17.0\")]\n     pub fn into_raw(this: Self) -> *const T {\n@@ -401,13 +416,13 @@ impl<T: ?Sized> Rc<T> {\n     /// ```\n     /// use std::rc::Rc;\n     ///\n-    /// let x = Rc::new(10);\n+    /// let x = Rc::new(\"hello\".to_owned());\n     /// let x_ptr = Rc::into_raw(x);\n     ///\n     /// unsafe {\n     ///     // Convert back to an `Rc` to prevent leak.\n     ///     let x = Rc::from_raw(x_ptr);\n-    ///     assert_eq!(*x, 10);\n+    ///     assert_eq!(&*x, \"hello\");\n     ///\n     ///     // Further calls to `Rc::from_raw(x_ptr)` would be memory unsafe.\n     /// }\n@@ -416,20 +431,13 @@ impl<T: ?Sized> Rc<T> {\n     /// ```\n     #[stable(feature = \"rc_raw\", since = \"1.17.0\")]\n     pub unsafe fn from_raw(ptr: *const T) -> Self {\n-        // Align the unsized value to the end of the RcBox.\n-        // Because it is ?Sized, it will always be the last field in memory.\n-        let align = align_of_val(&*ptr);\n-        let layout = Layout::new::<RcBox<()>>();\n-        let offset = (layout.size() + layout.padding_needed_for(align)) as isize;\n+        let offset = data_offset(ptr);\n \n         // Reverse the offset to find the original RcBox.\n         let fake_ptr = ptr as *mut RcBox<T>;\n         let rc_ptr = set_data_ptr(fake_ptr, (ptr as *mut u8).offset(-offset));\n \n-        Rc {\n-            ptr: NonNull::new_unchecked(rc_ptr),\n-            phantom: PhantomData,\n-        }\n+        Self::from_ptr(rc_ptr)\n     }\n \n     /// Consumes the `Rc`, returning the wrapped pointer as `NonNull<T>`.\n@@ -441,10 +449,10 @@ impl<T: ?Sized> Rc<T> {\n     ///\n     /// use std::rc::Rc;\n     ///\n-    /// let x = Rc::new(10);\n+    /// let x = Rc::new(\"hello\".to_owned());\n     /// let ptr = Rc::into_raw_non_null(x);\n-    /// let deref = unsafe { *ptr.as_ref() };\n-    /// assert_eq!(deref, 10);\n+    /// let deref = unsafe { ptr.as_ref() };\n+    /// assert_eq!(deref, \"hello\");\n     /// ```\n     #[unstable(feature = \"rc_into_raw_non_null\", issue = \"47336\")]\n     #[inline]\n@@ -584,15 +592,18 @@ impl<T: ?Sized> Rc<T> {\n impl<T: Clone> Rc<T> {\n     /// Makes a mutable reference into the given `Rc`.\n     ///\n-    /// If there are other `Rc` or [`Weak`][weak] pointers to the same value,\n-    /// then `make_mut` will invoke [`clone`][clone] on the inner value to\n-    /// ensure unique ownership. This is also referred to as clone-on-write.\n+    /// If there are other `Rc` pointers to the same value, then `make_mut` will\n+    /// [`clone`] the inner value to ensure unique ownership.  This is also\n+    /// referred to as clone-on-write.\n     ///\n-    /// See also [`get_mut`][get_mut], which will fail rather than cloning.\n+    /// If there are no other `Rc` pointers to this value, then [`Weak`]\n+    /// pointers to this value will be dissassociated.\n     ///\n-    /// [weak]: struct.Weak.html\n-    /// [clone]: ../../std/clone/trait.Clone.html#tymethod.clone\n-    /// [get_mut]: struct.Rc.html#method.get_mut\n+    /// See also [`get_mut`], which will fail rather than cloning.\n+    ///\n+    /// [`Weak`]: struct.Weak.html\n+    /// [`clone`]: ../../std/clone/trait.Clone.html#tymethod.clone\n+    /// [`get_mut`]: struct.Rc.html#method.get_mut\n     ///\n     /// # Examples\n     ///\n@@ -611,6 +622,23 @@ impl<T: Clone> Rc<T> {\n     /// assert_eq!(*data, 8);\n     /// assert_eq!(*other_data, 12);\n     /// ```\n+    ///\n+    /// [`Weak`] pointers will be dissassociated:\n+    ///\n+    /// ```\n+    /// use std::rc::Rc;\n+    ///\n+    /// let mut data = Rc::new(75);\n+    /// let weak = Rc::downgrade(&data);\n+    ///\n+    /// assert!(75 == *data);\n+    /// assert!(75 == *weak.upgrade().unwrap());\n+    ///\n+    /// *Rc::make_mut(&mut data) += 1;\n+    ///\n+    /// assert!(76 == *data);\n+    /// assert!(weak.upgrade().is_none());\n+    /// ```\n     #[inline]\n     #[stable(feature = \"rc_unique\", since = \"1.4.0\")]\n     pub fn make_mut(this: &mut Self) -> &mut T {\n@@ -667,29 +695,37 @@ impl Rc<dyn Any> {\n         if (*self).is::<T>() {\n             let ptr = self.ptr.cast::<RcBox<T>>();\n             forget(self);\n-            Ok(Rc { ptr, phantom: PhantomData })\n+            Ok(Rc::from_inner(ptr))\n         } else {\n             Err(self)\n         }\n     }\n }\n \n impl<T: ?Sized> Rc<T> {\n-    // Allocates an `RcBox<T>` with sufficient space for an unsized value\n-    unsafe fn allocate_for_ptr(ptr: *const T) -> *mut RcBox<T> {\n-        // Calculate layout using the given value.\n+    /// Allocates an `RcBox<T>` with sufficient space for\n+    /// an unsized value where the value has the layout provided.\n+    ///\n+    /// The function `mem_to_rcbox` is called with the data pointer\n+    /// and must return back a (potentially fat)-pointer for the `RcBox<T>`.\n+    unsafe fn allocate_for_unsized(\n+        value_layout: Layout,\n+        mem_to_rcbox: impl FnOnce(*mut u8) -> *mut RcBox<T>\n+    ) -> *mut RcBox<T> {\n+        // Calculate layout using the given value layout.\n         // Previously, layout was calculated on the expression\n         // `&*(ptr as *const RcBox<T>)`, but this created a misaligned\n         // reference (see #54908).\n         let layout = Layout::new::<RcBox<()>>()\n-            .extend(Layout::for_value(&*ptr)).unwrap().0\n+            .extend(value_layout).unwrap().0\n             .pad_to_align().unwrap();\n \n+        // Allocate for the layout.\n         let mem = Global.alloc(layout)\n             .unwrap_or_else(|_| handle_alloc_error(layout));\n \n         // Initialize the RcBox\n-        let inner = set_data_ptr(ptr as *mut T, mem.as_ptr() as *mut u8) as *mut RcBox<T>;\n+        let inner = mem_to_rcbox(mem.as_ptr());\n         debug_assert_eq!(Layout::for_value(&*inner), layout);\n \n         ptr::write(&mut (*inner).strong, Cell::new(1));\n@@ -698,6 +734,15 @@ impl<T: ?Sized> Rc<T> {\n         inner\n     }\n \n+    /// Allocates an `RcBox<T>` with sufficient space for an unsized value\n+    unsafe fn allocate_for_ptr(ptr: *const T) -> *mut RcBox<T> {\n+        // Allocate for the `RcBox<T>` using the given value.\n+        Self::allocate_for_unsized(\n+            Layout::for_value(&*ptr),\n+            |mem| set_data_ptr(ptr as *mut T, mem) as *mut RcBox<T>,\n+        )\n+    }\n+\n     fn from_box(v: Box<T>) -> Rc<T> {\n         unsafe {\n             let box_unique = Box::into_unique(v);\n@@ -715,44 +760,49 @@ impl<T: ?Sized> Rc<T> {\n             // Free the allocation without dropping its contents\n             box_free(box_unique);\n \n-            Rc { ptr: NonNull::new_unchecked(ptr), phantom: PhantomData }\n+            Self::from_ptr(ptr)\n         }\n     }\n }\n \n-// Sets the data pointer of a `?Sized` raw pointer.\n-//\n-// For a slice/trait object, this sets the `data` field and leaves the rest\n-// unchanged. For a sized raw pointer, this simply sets the pointer.\n+impl<T> Rc<[T]> {\n+    /// Allocates an `RcBox<[T]>` with the given length.\n+    unsafe fn allocate_for_slice(len: usize) -> *mut RcBox<[T]> {\n+        Self::allocate_for_unsized(\n+            Layout::array::<T>(len).unwrap(),\n+            |mem| ptr::slice_from_raw_parts_mut(mem as *mut T, len) as *mut RcBox<[T]>,\n+        )\n+    }\n+}\n+\n+/// Sets the data pointer of a `?Sized` raw pointer.\n+///\n+/// For a slice/trait object, this sets the `data` field and leaves the rest\n+/// unchanged. For a sized raw pointer, this simply sets the pointer.\n unsafe fn set_data_ptr<T: ?Sized, U>(mut ptr: *mut T, data: *mut U) -> *mut T {\n     ptr::write(&mut ptr as *mut _ as *mut *mut u8, data as *mut u8);\n     ptr\n }\n \n impl<T> Rc<[T]> {\n-    // Copy elements from slice into newly allocated Rc<[T]>\n-    //\n-    // Unsafe because the caller must either take ownership or bind `T: Copy`\n+    /// Copy elements from slice into newly allocated Rc<[T]>\n+    ///\n+    /// Unsafe because the caller must either take ownership or bind `T: Copy`\n     unsafe fn copy_from_slice(v: &[T]) -> Rc<[T]> {\n-        let v_ptr = v as *const [T];\n-        let ptr = Self::allocate_for_ptr(v_ptr);\n+        let ptr = Self::allocate_for_slice(v.len());\n \n         ptr::copy_nonoverlapping(\n             v.as_ptr(),\n             &mut (*ptr).value as *mut [T] as *mut T,\n             v.len());\n \n-        Rc { ptr: NonNull::new_unchecked(ptr), phantom: PhantomData }\n+        Self::from_ptr(ptr)\n     }\n-}\n-\n-trait RcFromSlice<T> {\n-    fn from_slice(slice: &[T]) -> Self;\n-}\n \n-impl<T: Clone> RcFromSlice<T> for Rc<[T]> {\n-    #[inline]\n-    default fn from_slice(v: &[T]) -> Self {\n+    /// Constructs an `Rc<[T]>` from an iterator known to be of a certain size.\n+    ///\n+    /// Behavior is undefined should the size be wrong.\n+    unsafe fn from_iter_exact(iter: impl iter::Iterator<Item = T>, len: usize) -> Rc<[T]> {\n         // Panic guard while cloning T elements.\n         // In the event of a panic, elements that have been written\n         // into the new RcBox will be dropped, then the memory freed.\n@@ -769,37 +819,48 @@ impl<T: Clone> RcFromSlice<T> for Rc<[T]> {\n                     let slice = from_raw_parts_mut(self.elems, self.n_elems);\n                     ptr::drop_in_place(slice);\n \n-                    Global.dealloc(self.mem, self.layout.clone());\n+                    Global.dealloc(self.mem, self.layout);\n                 }\n             }\n         }\n \n-        unsafe {\n-            let v_ptr = v as *const [T];\n-            let ptr = Self::allocate_for_ptr(v_ptr);\n+        let ptr = Self::allocate_for_slice(len);\n \n-            let mem = ptr as *mut _ as *mut u8;\n-            let layout = Layout::for_value(&*ptr);\n+        let mem = ptr as *mut _ as *mut u8;\n+        let layout = Layout::for_value(&*ptr);\n \n-            // Pointer to first element\n-            let elems = &mut (*ptr).value as *mut [T] as *mut T;\n+        // Pointer to first element\n+        let elems = &mut (*ptr).value as *mut [T] as *mut T;\n \n-            let mut guard = Guard{\n-                mem: NonNull::new_unchecked(mem),\n-                elems: elems,\n-                layout: layout,\n-                n_elems: 0,\n-            };\n+        let mut guard = Guard {\n+            mem: NonNull::new_unchecked(mem),\n+            elems,\n+            layout,\n+            n_elems: 0,\n+        };\n \n-            for (i, item) in v.iter().enumerate() {\n-                ptr::write(elems.add(i), item.clone());\n-                guard.n_elems += 1;\n-            }\n+        for (i, item) in iter.enumerate() {\n+            ptr::write(elems.add(i), item);\n+            guard.n_elems += 1;\n+        }\n \n-            // All clear. Forget the guard so it doesn't free the new RcBox.\n-            forget(guard);\n+        // All clear. Forget the guard so it doesn't free the new RcBox.\n+        forget(guard);\n \n-            Rc { ptr: NonNull::new_unchecked(ptr), phantom: PhantomData }\n+        Self::from_ptr(ptr)\n+    }\n+}\n+\n+/// Specialization trait used for `From<&[T]>`.\n+trait RcFromSlice<T> {\n+    fn from_slice(slice: &[T]) -> Self;\n+}\n+\n+impl<T: Clone> RcFromSlice<T> for Rc<[T]> {\n+    #[inline]\n+    default fn from_slice(v: &[T]) -> Self {\n+        unsafe {\n+            Self::from_iter_exact(v.iter().cloned(), v.len())\n         }\n     }\n }\n@@ -891,7 +952,7 @@ impl<T: ?Sized> Clone for Rc<T> {\n     #[inline]\n     fn clone(&self) -> Rc<T> {\n         self.inc_strong();\n-        Rc { ptr: self.ptr, phantom: PhantomData }\n+        Self::from_inner(self.ptr)\n     }\n }\n \n@@ -932,6 +993,11 @@ impl<T: ?Sized + PartialEq> RcEqIdent<T> for Rc<T> {\n     }\n }\n \n+/// We're doing this specialization here, and not as a more general optimization on `&T`, because it\n+/// would otherwise add a cost to all equality checks on refs. We assume that `Rc`s are used to\n+/// store large values, that are slow to clone, but also heavy to check for equality, causing this\n+/// cost to pay off more easily. It's also more likely to have two `Rc` clones, that point to\n+/// the same value, than two `&T`s.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized + Eq> RcEqIdent<T> for Rc<T> {\n     #[inline]\n@@ -1192,6 +1258,114 @@ impl<T> From<Vec<T>> for Rc<[T]> {\n     }\n }\n \n+#[unstable(feature = \"boxed_slice_try_from\", issue = \"0\")]\n+impl<T, const N: usize> TryFrom<Rc<[T]>> for Rc<[T; N]>\n+where\n+    [T; N]: LengthAtMost32,\n+{\n+    type Error = Rc<[T]>;\n+\n+    fn try_from(boxed_slice: Rc<[T]>) -> Result<Self, Self::Error> {\n+        if boxed_slice.len() == N {\n+            Ok(unsafe { Rc::from_raw(Rc::into_raw(boxed_slice) as *mut [T; N]) })\n+        } else {\n+            Err(boxed_slice)\n+        }\n+    }\n+}\n+\n+#[stable(feature = \"shared_from_iter\", since = \"1.37.0\")]\n+impl<T> iter::FromIterator<T> for Rc<[T]> {\n+    /// Takes each element in the `Iterator` and collects it into an `Rc<[T]>`.\n+    ///\n+    /// # Performance characteristics\n+    ///\n+    /// ## The general case\n+    ///\n+    /// In the general case, collecting into `Rc<[T]>` is done by first\n+    /// collecting into a `Vec<T>`. That is, when writing the following:\n+    ///\n+    /// ```rust\n+    /// # use std::rc::Rc;\n+    /// let evens: Rc<[u8]> = (0..10).filter(|&x| x % 2 == 0).collect();\n+    /// # assert_eq!(&*evens, &[0, 2, 4, 6, 8]);\n+    /// ```\n+    ///\n+    /// this behaves as if we wrote:\n+    ///\n+    /// ```rust\n+    /// # use std::rc::Rc;\n+    /// let evens: Rc<[u8]> = (0..10).filter(|&x| x % 2 == 0)\n+    ///     .collect::<Vec<_>>() // The first set of allocations happens here.\n+    ///     .into(); // A second allocation for `Rc<[T]>` happens here.\n+    /// # assert_eq!(&*evens, &[0, 2, 4, 6, 8]);\n+    /// ```\n+    ///\n+    /// This will allocate as many times as needed for constructing the `Vec<T>`\n+    /// and then it will allocate once for turning the `Vec<T>` into the `Rc<[T]>`.\n+    ///\n+    /// ## Iterators of known length\n+    ///\n+    /// When your `Iterator` implements `TrustedLen` and is of an exact size,\n+    /// a single allocation will be made for the `Rc<[T]>`. For example:\n+    ///\n+    /// ```rust\n+    /// # use std::rc::Rc;\n+    /// let evens: Rc<[u8]> = (0..10).collect(); // Just a single allocation happens here.\n+    /// # assert_eq!(&*evens, &*(0..10).collect::<Vec<_>>());\n+    /// ```\n+    fn from_iter<I: iter::IntoIterator<Item = T>>(iter: I) -> Self {\n+        RcFromIter::from_iter(iter.into_iter())\n+    }\n+}\n+\n+/// Specialization trait used for collecting into `Rc<[T]>`.\n+trait RcFromIter<T, I> {\n+    fn from_iter(iter: I) -> Self;\n+}\n+\n+impl<T, I: Iterator<Item = T>> RcFromIter<T, I> for Rc<[T]> {\n+    default fn from_iter(iter: I) -> Self {\n+        iter.collect::<Vec<T>>().into()\n+    }\n+}\n+\n+impl<T, I: iter::TrustedLen<Item = T>> RcFromIter<T, I> for Rc<[T]>  {\n+    default fn from_iter(iter: I) -> Self {\n+        // This is the case for a `TrustedLen` iterator.\n+        let (low, high) = iter.size_hint();\n+        if let Some(high) = high {\n+            debug_assert_eq!(\n+                low, high,\n+                \"TrustedLen iterator's size hint is not exact: {:?}\",\n+                (low, high)\n+            );\n+\n+            unsafe {\n+                // SAFETY: We need to ensure that the iterator has an exact length and we have.\n+                Rc::from_iter_exact(iter, low)\n+            }\n+        } else {\n+            // Fall back to normal implementation.\n+            iter.collect::<Vec<T>>().into()\n+        }\n+    }\n+}\n+\n+impl<'a, T: 'a + Clone> RcFromIter<&'a T, slice::Iter<'a, T>> for Rc<[T]> {\n+    fn from_iter(iter: slice::Iter<'a, T>) -> Self {\n+        // Delegate to `impl<T: Clone> From<&[T]> for Rc<[T]>`.\n+        //\n+        // In the case that `T: Copy`, we get to use `ptr::copy_nonoverlapping`\n+        // which is even more performant.\n+        //\n+        // In the fall-back case we have `T: Clone`. This is still better\n+        // than the `TrustedLen` implementation as slices have a known length\n+        // and so we get to avoid calling `size_hint` and avoid the branching.\n+        iter.as_slice().into()\n+    }\n+}\n+\n /// `Weak` is a version of [`Rc`] that holds a non-owning reference to the\n /// managed value. The value is accessed by calling [`upgrade`] on the `Weak`\n /// pointer, which returns an [`Option`]`<`[`Rc`]`<T>>`.\n@@ -1257,6 +1431,143 @@ impl<T> Weak<T> {\n             ptr: NonNull::new(usize::MAX as *mut RcBox<T>).expect(\"MAX is not 0\"),\n         }\n     }\n+\n+    /// Returns a raw pointer to the object `T` pointed to by this `Weak<T>`.\n+    ///\n+    /// It is up to the caller to ensure that the object is still alive when accessing it through\n+    /// the pointer.\n+    ///\n+    /// The pointer may be [`null`] or be dangling in case the object has already been destroyed.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(weak_into_raw)]\n+    ///\n+    /// use std::rc::Rc;\n+    /// use std::ptr;\n+    ///\n+    /// let strong = Rc::new(\"hello\".to_owned());\n+    /// let weak = Rc::downgrade(&strong);\n+    /// // Both point to the same object\n+    /// assert!(ptr::eq(&*strong, weak.as_raw()));\n+    /// // The strong here keeps it alive, so we can still access the object.\n+    /// assert_eq!(\"hello\", unsafe { &*weak.as_raw() });\n+    ///\n+    /// drop(strong);\n+    /// // But not any more. We can do weak.as_raw(), but accessing the pointer would lead to\n+    /// // undefined behaviour.\n+    /// // assert_eq!(\"hello\", unsafe { &*weak.as_raw() });\n+    /// ```\n+    ///\n+    /// [`null`]: ../../std/ptr/fn.null.html\n+    #[unstable(feature = \"weak_into_raw\", issue = \"60728\")]\n+    pub fn as_raw(&self) -> *const T {\n+        match self.inner() {\n+            None => ptr::null(),\n+            Some(inner) => {\n+                let offset = data_offset_sized::<T>();\n+                let ptr = inner as *const RcBox<T>;\n+                // Note: while the pointer we create may already point to dropped value, the\n+                // allocation still lives (it must hold the weak point as long as we are alive).\n+                // Therefore, the offset is OK to do, it won't get out of the allocation.\n+                let ptr = unsafe { (ptr as *const u8).offset(offset) };\n+                ptr as *const T\n+            }\n+        }\n+    }\n+\n+    /// Consumes the `Weak<T>` and turns it into a raw pointer.\n+    ///\n+    /// This converts the weak pointer into a raw pointer, preserving the original weak count. It\n+    /// can be turned back into the `Weak<T>` with [`from_raw`].\n+    ///\n+    /// The same restrictions of accessing the target of the pointer as with\n+    /// [`as_raw`] apply.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(weak_into_raw)]\n+    ///\n+    /// use std::rc::{Rc, Weak};\n+    ///\n+    /// let strong = Rc::new(\"hello\".to_owned());\n+    /// let weak = Rc::downgrade(&strong);\n+    /// let raw = weak.into_raw();\n+    ///\n+    /// assert_eq!(1, Rc::weak_count(&strong));\n+    /// assert_eq!(\"hello\", unsafe { &*raw });\n+    ///\n+    /// drop(unsafe { Weak::from_raw(raw) });\n+    /// assert_eq!(0, Rc::weak_count(&strong));\n+    /// ```\n+    ///\n+    /// [`from_raw`]: struct.Weak.html#method.from_raw\n+    /// [`as_raw`]: struct.Weak.html#method.as_raw\n+    #[unstable(feature = \"weak_into_raw\", issue = \"60728\")]\n+    pub fn into_raw(self) -> *const T {\n+        let result = self.as_raw();\n+        mem::forget(self);\n+        result\n+    }\n+\n+    /// Converts a raw pointer previously created by [`into_raw`] back into `Weak<T>`.\n+    ///\n+    /// This can be used to safely get a strong reference (by calling [`upgrade`]\n+    /// later) or to deallocate the weak count by dropping the `Weak<T>`.\n+    ///\n+    /// It takes ownership of one weak count. In case a [`null`] is passed, a dangling [`Weak`] is\n+    /// returned.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The pointer must represent one valid weak count. In other words, it must point to `T` which\n+    /// is or *was* managed by an [`Rc`] and the weak count of that [`Rc`] must not have reached\n+    /// 0. It is allowed for the strong count to be 0.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(weak_into_raw)]\n+    ///\n+    /// use std::rc::{Rc, Weak};\n+    ///\n+    /// let strong = Rc::new(\"hello\".to_owned());\n+    ///\n+    /// let raw_1 = Rc::downgrade(&strong).into_raw();\n+    /// let raw_2 = Rc::downgrade(&strong).into_raw();\n+    ///\n+    /// assert_eq!(2, Rc::weak_count(&strong));\n+    ///\n+    /// assert_eq!(\"hello\", &*unsafe { Weak::from_raw(raw_1) }.upgrade().unwrap());\n+    /// assert_eq!(1, Rc::weak_count(&strong));\n+    ///\n+    /// drop(strong);\n+    ///\n+    /// // Decrement the last weak count.\n+    /// assert!(unsafe { Weak::from_raw(raw_2) }.upgrade().is_none());\n+    /// ```\n+    ///\n+    /// [`null`]: ../../std/ptr/fn.null.html\n+    /// [`into_raw`]: struct.Weak.html#method.into_raw\n+    /// [`upgrade`]: struct.Weak.html#method.upgrade\n+    /// [`Rc`]: struct.Rc.html\n+    /// [`Weak`]: struct.Weak.html\n+    #[unstable(feature = \"weak_into_raw\", issue = \"60728\")]\n+    pub unsafe fn from_raw(ptr: *const T) -> Self {\n+        if ptr.is_null() {\n+            Self::new()\n+        } else {\n+            // See Rc::from_raw for details\n+            let offset = data_offset(ptr);\n+            let fake_ptr = ptr as *mut RcBox<T>;\n+            let ptr = set_data_ptr(fake_ptr, (ptr as *mut u8).offset(-offset));\n+            Weak {\n+                ptr: NonNull::new(ptr).expect(\"Invalid pointer passed to from_raw\"),\n+            }\n+        }\n+    }\n }\n \n pub(crate) fn is_dangling<T: ?Sized>(ptr: NonNull<T>) -> bool {\n@@ -1298,7 +1609,7 @@ impl<T: ?Sized> Weak<T> {\n             None\n         } else {\n             inner.inc_strong();\n-            Some(Rc { ptr: self.ptr, phantom: PhantomData })\n+            Some(Rc::from_inner(self.ptr))\n         }\n     }\n \n@@ -1357,18 +1668,18 @@ impl<T: ?Sized> Weak<T> {\n     ///\n     /// ```\n     /// #![feature(weak_ptr_eq)]\n-    /// use std::rc::{Rc, Weak};\n+    /// use std::rc::Rc;\n     ///\n     /// let first_rc = Rc::new(5);\n     /// let first = Rc::downgrade(&first_rc);\n     /// let second = Rc::downgrade(&first_rc);\n     ///\n-    /// assert!(Weak::ptr_eq(&first, &second));\n+    /// assert!(first.ptr_eq(&second));\n     ///\n     /// let third_rc = Rc::new(5);\n     /// let third = Rc::downgrade(&third_rc);\n     ///\n-    /// assert!(!Weak::ptr_eq(&first, &third));\n+    /// assert!(!first.ptr_eq(&third));\n     /// ```\n     ///\n     /// Comparing `Weak::new`.\n@@ -1379,16 +1690,16 @@ impl<T: ?Sized> Weak<T> {\n     ///\n     /// let first = Weak::new();\n     /// let second = Weak::new();\n-    /// assert!(Weak::ptr_eq(&first, &second));\n+    /// assert!(first.ptr_eq(&second));\n     ///\n     /// let third_rc = Rc::new(());\n     /// let third = Rc::downgrade(&third_rc);\n-    /// assert!(!Weak::ptr_eq(&first, &third));\n+    /// assert!(!first.ptr_eq(&third));\n     /// ```\n     #[inline]\n     #[unstable(feature = \"weak_ptr_eq\", issue = \"55981\")]\n-    pub fn ptr_eq(this: &Self, other: &Self) -> bool {\n-        this.ptr.as_ptr() == other.ptr.as_ptr()\n+    pub fn ptr_eq(&self, other: &Self) -> bool {\n+        self.ptr.as_ptr() == other.ptr.as_ptr()\n     }\n }\n \n@@ -1502,14 +1813,16 @@ trait RcBoxPtr<T: ?Sized> {\n \n     #[inline]\n     fn inc_strong(&self) {\n+        let strong = self.strong();\n+\n         // We want to abort on overflow instead of dropping the value.\n         // The reference count will never be zero when this is called;\n         // nevertheless, we insert an abort here to hint LLVM at\n         // an otherwise missed optimization.\n-        if self.strong() == 0 || self.strong() == usize::max_value() {\n+        if strong == 0 || strong == usize::max_value() {\n             unsafe { abort(); }\n         }\n-        self.inner().strong.set(self.strong() + 1);\n+        self.inner().strong.set(strong + 1);\n     }\n \n     #[inline]\n@@ -1524,14 +1837,16 @@ trait RcBoxPtr<T: ?Sized> {\n \n     #[inline]\n     fn inc_weak(&self) {\n+        let weak = self.weak();\n+\n         // We want to abort on overflow instead of dropping the value.\n         // The reference count will never be zero when this is called;\n         // nevertheless, we insert an abort here to hint LLVM at\n         // an otherwise missed optimization.\n-        if self.weak() == 0 || self.weak() == usize::max_value() {\n+        if weak == 0 || weak == usize::max_value() {\n             unsafe { abort(); }\n         }\n-        self.inner().weak.set(self.weak() + 1);\n+        self.inner().weak.set(weak + 1);\n     }\n \n     #[inline]\n@@ -1556,436 +1871,6 @@ impl<T: ?Sized> RcBoxPtr<T> for RcBox<T> {\n     }\n }\n \n-#[cfg(test)]\n-mod tests {\n-    use super::{Rc, Weak};\n-    use std::boxed::Box;\n-    use std::cell::RefCell;\n-    use std::option::Option::{self, None, Some};\n-    use std::result::Result::{Err, Ok};\n-    use std::mem::drop;\n-    use std::clone::Clone;\n-    use std::convert::From;\n-\n-    #[test]\n-    fn test_clone() {\n-        let x = Rc::new(RefCell::new(5));\n-        let y = x.clone();\n-        *x.borrow_mut() = 20;\n-        assert_eq!(*y.borrow(), 20);\n-    }\n-\n-    #[test]\n-    fn test_simple() {\n-        let x = Rc::new(5);\n-        assert_eq!(*x, 5);\n-    }\n-\n-    #[test]\n-    fn test_simple_clone() {\n-        let x = Rc::new(5);\n-        let y = x.clone();\n-        assert_eq!(*x, 5);\n-        assert_eq!(*y, 5);\n-    }\n-\n-    #[test]\n-    fn test_destructor() {\n-        let x: Rc<Box<_>> = Rc::new(box 5);\n-        assert_eq!(**x, 5);\n-    }\n-\n-    #[test]\n-    fn test_live() {\n-        let x = Rc::new(5);\n-        let y = Rc::downgrade(&x);\n-        assert!(y.upgrade().is_some());\n-    }\n-\n-    #[test]\n-    fn test_dead() {\n-        let x = Rc::new(5);\n-        let y = Rc::downgrade(&x);\n-        drop(x);\n-        assert!(y.upgrade().is_none());\n-    }\n-\n-    #[test]\n-    fn weak_self_cyclic() {\n-        struct Cycle {\n-            x: RefCell<Option<Weak<Cycle>>>,\n-        }\n-\n-        let a = Rc::new(Cycle { x: RefCell::new(None) });\n-        let b = Rc::downgrade(&a.clone());\n-        *a.x.borrow_mut() = Some(b);\n-\n-        // hopefully we don't double-free (or leak)...\n-    }\n-\n-    #[test]\n-    fn is_unique() {\n-        let x = Rc::new(3);\n-        assert!(Rc::is_unique(&x));\n-        let y = x.clone();\n-        assert!(!Rc::is_unique(&x));\n-        drop(y);\n-        assert!(Rc::is_unique(&x));\n-        let w = Rc::downgrade(&x);\n-        assert!(!Rc::is_unique(&x));\n-        drop(w);\n-        assert!(Rc::is_unique(&x));\n-    }\n-\n-    #[test]\n-    fn test_strong_count() {\n-        let a = Rc::new(0);\n-        assert!(Rc::strong_count(&a) == 1);\n-        let w = Rc::downgrade(&a);\n-        assert!(Rc::strong_count(&a) == 1);\n-        let b = w.upgrade().expect(\"upgrade of live rc failed\");\n-        assert!(Rc::strong_count(&b) == 2);\n-        assert!(Rc::strong_count(&a) == 2);\n-        drop(w);\n-        drop(a);\n-        assert!(Rc::strong_count(&b) == 1);\n-        let c = b.clone();\n-        assert!(Rc::strong_count(&b) == 2);\n-        assert!(Rc::strong_count(&c) == 2);\n-    }\n-\n-    #[test]\n-    fn test_weak_count() {\n-        let a = Rc::new(0);\n-        assert!(Rc::strong_count(&a) == 1);\n-        assert!(Rc::weak_count(&a) == 0);\n-        let w = Rc::downgrade(&a);\n-        assert!(Rc::strong_count(&a) == 1);\n-        assert!(Rc::weak_count(&a) == 1);\n-        drop(w);\n-        assert!(Rc::strong_count(&a) == 1);\n-        assert!(Rc::weak_count(&a) == 0);\n-        let c = a.clone();\n-        assert!(Rc::strong_count(&a) == 2);\n-        assert!(Rc::weak_count(&a) == 0);\n-        drop(c);\n-    }\n-\n-    #[test]\n-    fn weak_counts() {\n-        assert_eq!(Weak::weak_count(&Weak::<u64>::new()), None);\n-        assert_eq!(Weak::strong_count(&Weak::<u64>::new()), 0);\n-\n-        let a = Rc::new(0);\n-        let w = Rc::downgrade(&a);\n-        assert_eq!(Weak::strong_count(&w), 1);\n-        assert_eq!(Weak::weak_count(&w), Some(1));\n-        let w2 = w.clone();\n-        assert_eq!(Weak::strong_count(&w), 1);\n-        assert_eq!(Weak::weak_count(&w), Some(2));\n-        assert_eq!(Weak::strong_count(&w2), 1);\n-        assert_eq!(Weak::weak_count(&w2), Some(2));\n-        drop(w);\n-        assert_eq!(Weak::strong_count(&w2), 1);\n-        assert_eq!(Weak::weak_count(&w2), Some(1));\n-        let a2 = a.clone();\n-        assert_eq!(Weak::strong_count(&w2), 2);\n-        assert_eq!(Weak::weak_count(&w2), Some(1));\n-        drop(a2);\n-        drop(a);\n-        assert_eq!(Weak::strong_count(&w2), 0);\n-        assert_eq!(Weak::weak_count(&w2), Some(1));\n-        drop(w2);\n-    }\n-\n-    #[test]\n-    fn try_unwrap() {\n-        let x = Rc::new(3);\n-        assert_eq!(Rc::try_unwrap(x), Ok(3));\n-        let x = Rc::new(4);\n-        let _y = x.clone();\n-        assert_eq!(Rc::try_unwrap(x), Err(Rc::new(4)));\n-        let x = Rc::new(5);\n-        let _w = Rc::downgrade(&x);\n-        assert_eq!(Rc::try_unwrap(x), Ok(5));\n-    }\n-\n-    #[test]\n-    fn into_from_raw() {\n-        let x = Rc::new(box \"hello\");\n-        let y = x.clone();\n-\n-        let x_ptr = Rc::into_raw(x);\n-        drop(y);\n-        unsafe {\n-            assert_eq!(**x_ptr, \"hello\");\n-\n-            let x = Rc::from_raw(x_ptr);\n-            assert_eq!(**x, \"hello\");\n-\n-            assert_eq!(Rc::try_unwrap(x).map(|x| *x), Ok(\"hello\"));\n-        }\n-    }\n-\n-    #[test]\n-    fn test_into_from_raw_unsized() {\n-        use std::fmt::Display;\n-        use std::string::ToString;\n-\n-        let rc: Rc<str> = Rc::from(\"foo\");\n-\n-        let ptr = Rc::into_raw(rc.clone());\n-        let rc2 = unsafe { Rc::from_raw(ptr) };\n-\n-        assert_eq!(unsafe { &*ptr }, \"foo\");\n-        assert_eq!(rc, rc2);\n-\n-        let rc: Rc<dyn Display> = Rc::new(123);\n-\n-        let ptr = Rc::into_raw(rc.clone());\n-        let rc2 = unsafe { Rc::from_raw(ptr) };\n-\n-        assert_eq!(unsafe { &*ptr }.to_string(), \"123\");\n-        assert_eq!(rc2.to_string(), \"123\");\n-    }\n-\n-    #[test]\n-    fn get_mut() {\n-        let mut x = Rc::new(3);\n-        *Rc::get_mut(&mut x).unwrap() = 4;\n-        assert_eq!(*x, 4);\n-        let y = x.clone();\n-        assert!(Rc::get_mut(&mut x).is_none());\n-        drop(y);\n-        assert!(Rc::get_mut(&mut x).is_some());\n-        let _w = Rc::downgrade(&x);\n-        assert!(Rc::get_mut(&mut x).is_none());\n-    }\n-\n-    #[test]\n-    fn test_cowrc_clone_make_unique() {\n-        let mut cow0 = Rc::new(75);\n-        let mut cow1 = cow0.clone();\n-        let mut cow2 = cow1.clone();\n-\n-        assert!(75 == *Rc::make_mut(&mut cow0));\n-        assert!(75 == *Rc::make_mut(&mut cow1));\n-        assert!(75 == *Rc::make_mut(&mut cow2));\n-\n-        *Rc::make_mut(&mut cow0) += 1;\n-        *Rc::make_mut(&mut cow1) += 2;\n-        *Rc::make_mut(&mut cow2) += 3;\n-\n-        assert!(76 == *cow0);\n-        assert!(77 == *cow1);\n-        assert!(78 == *cow2);\n-\n-        // none should point to the same backing memory\n-        assert!(*cow0 != *cow1);\n-        assert!(*cow0 != *cow2);\n-        assert!(*cow1 != *cow2);\n-    }\n-\n-    #[test]\n-    fn test_cowrc_clone_unique2() {\n-        let mut cow0 = Rc::new(75);\n-        let cow1 = cow0.clone();\n-        let cow2 = cow1.clone();\n-\n-        assert!(75 == *cow0);\n-        assert!(75 == *cow1);\n-        assert!(75 == *cow2);\n-\n-        *Rc::make_mut(&mut cow0) += 1;\n-\n-        assert!(76 == *cow0);\n-        assert!(75 == *cow1);\n-        assert!(75 == *cow2);\n-\n-        // cow1 and cow2 should share the same contents\n-        // cow0 should have a unique reference\n-        assert!(*cow0 != *cow1);\n-        assert!(*cow0 != *cow2);\n-        assert!(*cow1 == *cow2);\n-    }\n-\n-    #[test]\n-    fn test_cowrc_clone_weak() {\n-        let mut cow0 = Rc::new(75);\n-        let cow1_weak = Rc::downgrade(&cow0);\n-\n-        assert!(75 == *cow0);\n-        assert!(75 == *cow1_weak.upgrade().unwrap());\n-\n-        *Rc::make_mut(&mut cow0) += 1;\n-\n-        assert!(76 == *cow0);\n-        assert!(cow1_weak.upgrade().is_none());\n-    }\n-\n-    #[test]\n-    fn test_show() {\n-        let foo = Rc::new(75);\n-        assert_eq!(format!(\"{:?}\", foo), \"75\");\n-    }\n-\n-    #[test]\n-    fn test_unsized() {\n-        let foo: Rc<[i32]> = Rc::new([1, 2, 3]);\n-        assert_eq!(foo, foo.clone());\n-    }\n-\n-    #[test]\n-    fn test_from_owned() {\n-        let foo = 123;\n-        let foo_rc = Rc::from(foo);\n-        assert!(123 == *foo_rc);\n-    }\n-\n-    #[test]\n-    fn test_new_weak() {\n-        let foo: Weak<usize> = Weak::new();\n-        assert!(foo.upgrade().is_none());\n-    }\n-\n-    #[test]\n-    fn test_ptr_eq() {\n-        let five = Rc::new(5);\n-        let same_five = five.clone();\n-        let other_five = Rc::new(5);\n-\n-        assert!(Rc::ptr_eq(&five, &same_five));\n-        assert!(!Rc::ptr_eq(&five, &other_five));\n-    }\n-\n-    #[test]\n-    fn test_from_str() {\n-        let r: Rc<str> = Rc::from(\"foo\");\n-\n-        assert_eq!(&r[..], \"foo\");\n-    }\n-\n-    #[test]\n-    fn test_copy_from_slice() {\n-        let s: &[u32] = &[1, 2, 3];\n-        let r: Rc<[u32]> = Rc::from(s);\n-\n-        assert_eq!(&r[..], [1, 2, 3]);\n-    }\n-\n-    #[test]\n-    fn test_clone_from_slice() {\n-        #[derive(Clone, Debug, Eq, PartialEq)]\n-        struct X(u32);\n-\n-        let s: &[X] = &[X(1), X(2), X(3)];\n-        let r: Rc<[X]> = Rc::from(s);\n-\n-        assert_eq!(&r[..], s);\n-    }\n-\n-    #[test]\n-    #[should_panic]\n-    fn test_clone_from_slice_panic() {\n-        use std::string::{String, ToString};\n-\n-        struct Fail(u32, String);\n-\n-        impl Clone for Fail {\n-            fn clone(&self) -> Fail {\n-                if self.0 == 2 {\n-                    panic!();\n-                }\n-                Fail(self.0, self.1.clone())\n-            }\n-        }\n-\n-        let s: &[Fail] = &[\n-            Fail(0, \"foo\".to_string()),\n-            Fail(1, \"bar\".to_string()),\n-            Fail(2, \"baz\".to_string()),\n-        ];\n-\n-        // Should panic, but not cause memory corruption\n-        let _r: Rc<[Fail]> = Rc::from(s);\n-    }\n-\n-    #[test]\n-    fn test_from_box() {\n-        let b: Box<u32> = box 123;\n-        let r: Rc<u32> = Rc::from(b);\n-\n-        assert_eq!(*r, 123);\n-    }\n-\n-    #[test]\n-    fn test_from_box_str() {\n-        use std::string::String;\n-\n-        let s = String::from(\"foo\").into_boxed_str();\n-        let r: Rc<str> = Rc::from(s);\n-\n-        assert_eq!(&r[..], \"foo\");\n-    }\n-\n-    #[test]\n-    fn test_from_box_slice() {\n-        let s = vec![1, 2, 3].into_boxed_slice();\n-        let r: Rc<[u32]> = Rc::from(s);\n-\n-        assert_eq!(&r[..], [1, 2, 3]);\n-    }\n-\n-    #[test]\n-    fn test_from_box_trait() {\n-        use std::fmt::Display;\n-        use std::string::ToString;\n-\n-        let b: Box<dyn Display> = box 123;\n-        let r: Rc<dyn Display> = Rc::from(b);\n-\n-        assert_eq!(r.to_string(), \"123\");\n-    }\n-\n-    #[test]\n-    fn test_from_box_trait_zero_sized() {\n-        use std::fmt::Debug;\n-\n-        let b: Box<dyn Debug> = box ();\n-        let r: Rc<dyn Debug> = Rc::from(b);\n-\n-        assert_eq!(format!(\"{:?}\", r), \"()\");\n-    }\n-\n-    #[test]\n-    fn test_from_vec() {\n-        let v = vec![1, 2, 3];\n-        let r: Rc<[u32]> = Rc::from(v);\n-\n-        assert_eq!(&r[..], [1, 2, 3]);\n-    }\n-\n-    #[test]\n-    fn test_downcast() {\n-        use std::any::Any;\n-\n-        let r1: Rc<dyn Any> = Rc::new(i32::max_value());\n-        let r2: Rc<dyn Any> = Rc::new(\"abc\");\n-\n-        assert!(r1.clone().downcast::<u32>().is_err());\n-\n-        let r1i32 = r1.downcast::<i32>();\n-        assert!(r1i32.is_ok());\n-        assert_eq!(r1i32.unwrap(), Rc::new(i32::max_value()));\n-\n-        assert!(r2.clone().downcast::<i32>().is_err());\n-\n-        let r2str = r2.downcast::<&'static str>();\n-        assert!(r2str.is_ok());\n-        assert_eq!(r2str.unwrap(), Rc::new(\"abc\"));\n-    }\n-}\n-\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: ?Sized> borrow::Borrow<T> for Rc<T> {\n     fn borrow(&self) -> &T {\n@@ -2002,3 +1887,22 @@ impl<T: ?Sized> AsRef<T> for Rc<T> {\n \n #[stable(feature = \"pin\", since = \"1.33.0\")]\n impl<T: ?Sized> Unpin for Rc<T> { }\n+\n+unsafe fn data_offset<T: ?Sized>(ptr: *const T) -> isize {\n+    // Align the unsized value to the end of the `RcBox`.\n+    // Because it is ?Sized, it will always be the last field in memory.\n+    data_offset_align(align_of_val(&*ptr))\n+}\n+\n+/// Computes the offset of the data field within `RcBox`.\n+///\n+/// Unlike [`data_offset`], this doesn't need the pointer, but it works only on `T: Sized`.\n+fn data_offset_sized<T>() -> isize {\n+    data_offset_align(align_of::<T>())\n+}\n+\n+#[inline]\n+fn data_offset_align(align: usize) -> isize {\n+    let layout = Layout::new::<RcBox<()>>();\n+    (layout.size() + layout.padding_needed_for(align)) as isize\n+}"}, {"sha": "6fd3f909357141120289b6e50bd65051636feefd", "filename": "src/liballoc/rc/tests.rs", "status": "added", "additions": 439, "deletions": 0, "changes": 439, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fliballoc%2Frc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fliballoc%2Frc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc%2Ftests.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -0,0 +1,439 @@\n+use super::*;\n+\n+use std::boxed::Box;\n+use std::cell::RefCell;\n+use std::option::Option::{self, None, Some};\n+use std::result::Result::{Err, Ok};\n+use std::mem::drop;\n+use std::clone::Clone;\n+use std::convert::{From, TryInto};\n+\n+#[test]\n+fn test_clone() {\n+    let x = Rc::new(RefCell::new(5));\n+    let y = x.clone();\n+    *x.borrow_mut() = 20;\n+    assert_eq!(*y.borrow(), 20);\n+}\n+\n+#[test]\n+fn test_simple() {\n+    let x = Rc::new(5);\n+    assert_eq!(*x, 5);\n+}\n+\n+#[test]\n+fn test_simple_clone() {\n+    let x = Rc::new(5);\n+    let y = x.clone();\n+    assert_eq!(*x, 5);\n+    assert_eq!(*y, 5);\n+}\n+\n+#[test]\n+fn test_destructor() {\n+    let x: Rc<Box<_>> = Rc::new(box 5);\n+    assert_eq!(**x, 5);\n+}\n+\n+#[test]\n+fn test_live() {\n+    let x = Rc::new(5);\n+    let y = Rc::downgrade(&x);\n+    assert!(y.upgrade().is_some());\n+}\n+\n+#[test]\n+fn test_dead() {\n+    let x = Rc::new(5);\n+    let y = Rc::downgrade(&x);\n+    drop(x);\n+    assert!(y.upgrade().is_none());\n+}\n+\n+#[test]\n+fn weak_self_cyclic() {\n+    struct Cycle {\n+        x: RefCell<Option<Weak<Cycle>>>,\n+    }\n+\n+    let a = Rc::new(Cycle { x: RefCell::new(None) });\n+    let b = Rc::downgrade(&a.clone());\n+    *a.x.borrow_mut() = Some(b);\n+\n+    // hopefully we don't double-free (or leak)...\n+}\n+\n+#[test]\n+fn is_unique() {\n+    let x = Rc::new(3);\n+    assert!(Rc::is_unique(&x));\n+    let y = x.clone();\n+    assert!(!Rc::is_unique(&x));\n+    drop(y);\n+    assert!(Rc::is_unique(&x));\n+    let w = Rc::downgrade(&x);\n+    assert!(!Rc::is_unique(&x));\n+    drop(w);\n+    assert!(Rc::is_unique(&x));\n+}\n+\n+#[test]\n+fn test_strong_count() {\n+    let a = Rc::new(0);\n+    assert!(Rc::strong_count(&a) == 1);\n+    let w = Rc::downgrade(&a);\n+    assert!(Rc::strong_count(&a) == 1);\n+    let b = w.upgrade().expect(\"upgrade of live rc failed\");\n+    assert!(Rc::strong_count(&b) == 2);\n+    assert!(Rc::strong_count(&a) == 2);\n+    drop(w);\n+    drop(a);\n+    assert!(Rc::strong_count(&b) == 1);\n+    let c = b.clone();\n+    assert!(Rc::strong_count(&b) == 2);\n+    assert!(Rc::strong_count(&c) == 2);\n+}\n+\n+#[test]\n+fn test_weak_count() {\n+    let a = Rc::new(0);\n+    assert!(Rc::strong_count(&a) == 1);\n+    assert!(Rc::weak_count(&a) == 0);\n+    let w = Rc::downgrade(&a);\n+    assert!(Rc::strong_count(&a) == 1);\n+    assert!(Rc::weak_count(&a) == 1);\n+    drop(w);\n+    assert!(Rc::strong_count(&a) == 1);\n+    assert!(Rc::weak_count(&a) == 0);\n+    let c = a.clone();\n+    assert!(Rc::strong_count(&a) == 2);\n+    assert!(Rc::weak_count(&a) == 0);\n+    drop(c);\n+}\n+\n+#[test]\n+fn weak_counts() {\n+    assert_eq!(Weak::weak_count(&Weak::<u64>::new()), None);\n+    assert_eq!(Weak::strong_count(&Weak::<u64>::new()), 0);\n+\n+    let a = Rc::new(0);\n+    let w = Rc::downgrade(&a);\n+    assert_eq!(Weak::strong_count(&w), 1);\n+    assert_eq!(Weak::weak_count(&w), Some(1));\n+    let w2 = w.clone();\n+    assert_eq!(Weak::strong_count(&w), 1);\n+    assert_eq!(Weak::weak_count(&w), Some(2));\n+    assert_eq!(Weak::strong_count(&w2), 1);\n+    assert_eq!(Weak::weak_count(&w2), Some(2));\n+    drop(w);\n+    assert_eq!(Weak::strong_count(&w2), 1);\n+    assert_eq!(Weak::weak_count(&w2), Some(1));\n+    let a2 = a.clone();\n+    assert_eq!(Weak::strong_count(&w2), 2);\n+    assert_eq!(Weak::weak_count(&w2), Some(1));\n+    drop(a2);\n+    drop(a);\n+    assert_eq!(Weak::strong_count(&w2), 0);\n+    assert_eq!(Weak::weak_count(&w2), Some(1));\n+    drop(w2);\n+}\n+\n+#[test]\n+fn try_unwrap() {\n+    let x = Rc::new(3);\n+    assert_eq!(Rc::try_unwrap(x), Ok(3));\n+    let x = Rc::new(4);\n+    let _y = x.clone();\n+    assert_eq!(Rc::try_unwrap(x), Err(Rc::new(4)));\n+    let x = Rc::new(5);\n+    let _w = Rc::downgrade(&x);\n+    assert_eq!(Rc::try_unwrap(x), Ok(5));\n+}\n+\n+#[test]\n+fn into_from_raw() {\n+    let x = Rc::new(box \"hello\");\n+    let y = x.clone();\n+\n+    let x_ptr = Rc::into_raw(x);\n+    drop(y);\n+    unsafe {\n+        assert_eq!(**x_ptr, \"hello\");\n+\n+        let x = Rc::from_raw(x_ptr);\n+        assert_eq!(**x, \"hello\");\n+\n+        assert_eq!(Rc::try_unwrap(x).map(|x| *x), Ok(\"hello\"));\n+    }\n+}\n+\n+#[test]\n+fn test_into_from_raw_unsized() {\n+    use std::fmt::Display;\n+    use std::string::ToString;\n+\n+    let rc: Rc<str> = Rc::from(\"foo\");\n+\n+    let ptr = Rc::into_raw(rc.clone());\n+    let rc2 = unsafe { Rc::from_raw(ptr) };\n+\n+    assert_eq!(unsafe { &*ptr }, \"foo\");\n+    assert_eq!(rc, rc2);\n+\n+    let rc: Rc<dyn Display> = Rc::new(123);\n+\n+    let ptr = Rc::into_raw(rc.clone());\n+    let rc2 = unsafe { Rc::from_raw(ptr) };\n+\n+    assert_eq!(unsafe { &*ptr }.to_string(), \"123\");\n+    assert_eq!(rc2.to_string(), \"123\");\n+}\n+\n+#[test]\n+fn get_mut() {\n+    let mut x = Rc::new(3);\n+    *Rc::get_mut(&mut x).unwrap() = 4;\n+    assert_eq!(*x, 4);\n+    let y = x.clone();\n+    assert!(Rc::get_mut(&mut x).is_none());\n+    drop(y);\n+    assert!(Rc::get_mut(&mut x).is_some());\n+    let _w = Rc::downgrade(&x);\n+    assert!(Rc::get_mut(&mut x).is_none());\n+}\n+\n+#[test]\n+fn test_cowrc_clone_make_unique() {\n+    let mut cow0 = Rc::new(75);\n+    let mut cow1 = cow0.clone();\n+    let mut cow2 = cow1.clone();\n+\n+    assert!(75 == *Rc::make_mut(&mut cow0));\n+    assert!(75 == *Rc::make_mut(&mut cow1));\n+    assert!(75 == *Rc::make_mut(&mut cow2));\n+\n+    *Rc::make_mut(&mut cow0) += 1;\n+    *Rc::make_mut(&mut cow1) += 2;\n+    *Rc::make_mut(&mut cow2) += 3;\n+\n+    assert!(76 == *cow0);\n+    assert!(77 == *cow1);\n+    assert!(78 == *cow2);\n+\n+    // none should point to the same backing memory\n+    assert!(*cow0 != *cow1);\n+    assert!(*cow0 != *cow2);\n+    assert!(*cow1 != *cow2);\n+}\n+\n+#[test]\n+fn test_cowrc_clone_unique2() {\n+    let mut cow0 = Rc::new(75);\n+    let cow1 = cow0.clone();\n+    let cow2 = cow1.clone();\n+\n+    assert!(75 == *cow0);\n+    assert!(75 == *cow1);\n+    assert!(75 == *cow2);\n+\n+    *Rc::make_mut(&mut cow0) += 1;\n+\n+    assert!(76 == *cow0);\n+    assert!(75 == *cow1);\n+    assert!(75 == *cow2);\n+\n+    // cow1 and cow2 should share the same contents\n+    // cow0 should have a unique reference\n+    assert!(*cow0 != *cow1);\n+    assert!(*cow0 != *cow2);\n+    assert!(*cow1 == *cow2);\n+}\n+\n+#[test]\n+fn test_cowrc_clone_weak() {\n+    let mut cow0 = Rc::new(75);\n+    let cow1_weak = Rc::downgrade(&cow0);\n+\n+    assert!(75 == *cow0);\n+    assert!(75 == *cow1_weak.upgrade().unwrap());\n+\n+    *Rc::make_mut(&mut cow0) += 1;\n+\n+    assert!(76 == *cow0);\n+    assert!(cow1_weak.upgrade().is_none());\n+}\n+\n+#[test]\n+fn test_show() {\n+    let foo = Rc::new(75);\n+    assert_eq!(format!(\"{:?}\", foo), \"75\");\n+}\n+\n+#[test]\n+fn test_unsized() {\n+    let foo: Rc<[i32]> = Rc::new([1, 2, 3]);\n+    assert_eq!(foo, foo.clone());\n+}\n+\n+#[test]\n+fn test_from_owned() {\n+    let foo = 123;\n+    let foo_rc = Rc::from(foo);\n+    assert!(123 == *foo_rc);\n+}\n+\n+#[test]\n+fn test_new_weak() {\n+    let foo: Weak<usize> = Weak::new();\n+    assert!(foo.upgrade().is_none());\n+}\n+\n+#[test]\n+fn test_ptr_eq() {\n+    let five = Rc::new(5);\n+    let same_five = five.clone();\n+    let other_five = Rc::new(5);\n+\n+    assert!(Rc::ptr_eq(&five, &same_five));\n+    assert!(!Rc::ptr_eq(&five, &other_five));\n+}\n+\n+#[test]\n+fn test_from_str() {\n+    let r: Rc<str> = Rc::from(\"foo\");\n+\n+    assert_eq!(&r[..], \"foo\");\n+}\n+\n+#[test]\n+fn test_copy_from_slice() {\n+    let s: &[u32] = &[1, 2, 3];\n+    let r: Rc<[u32]> = Rc::from(s);\n+\n+    assert_eq!(&r[..], [1, 2, 3]);\n+}\n+\n+#[test]\n+fn test_clone_from_slice() {\n+    #[derive(Clone, Debug, Eq, PartialEq)]\n+    struct X(u32);\n+\n+    let s: &[X] = &[X(1), X(2), X(3)];\n+    let r: Rc<[X]> = Rc::from(s);\n+\n+    assert_eq!(&r[..], s);\n+}\n+\n+#[test]\n+#[should_panic]\n+fn test_clone_from_slice_panic() {\n+    use std::string::{String, ToString};\n+\n+    struct Fail(u32, String);\n+\n+    impl Clone for Fail {\n+        fn clone(&self) -> Fail {\n+            if self.0 == 2 {\n+                panic!();\n+            }\n+            Fail(self.0, self.1.clone())\n+        }\n+    }\n+\n+    let s: &[Fail] = &[\n+        Fail(0, \"foo\".to_string()),\n+        Fail(1, \"bar\".to_string()),\n+        Fail(2, \"baz\".to_string()),\n+    ];\n+\n+    // Should panic, but not cause memory corruption\n+    let _r: Rc<[Fail]> = Rc::from(s);\n+}\n+\n+#[test]\n+fn test_from_box() {\n+    let b: Box<u32> = box 123;\n+    let r: Rc<u32> = Rc::from(b);\n+\n+    assert_eq!(*r, 123);\n+}\n+\n+#[test]\n+fn test_from_box_str() {\n+    use std::string::String;\n+\n+    let s = String::from(\"foo\").into_boxed_str();\n+    let r: Rc<str> = Rc::from(s);\n+\n+    assert_eq!(&r[..], \"foo\");\n+}\n+\n+#[test]\n+fn test_from_box_slice() {\n+    let s = vec![1, 2, 3].into_boxed_slice();\n+    let r: Rc<[u32]> = Rc::from(s);\n+\n+    assert_eq!(&r[..], [1, 2, 3]);\n+}\n+\n+#[test]\n+fn test_from_box_trait() {\n+    use std::fmt::Display;\n+    use std::string::ToString;\n+\n+    let b: Box<dyn Display> = box 123;\n+    let r: Rc<dyn Display> = Rc::from(b);\n+\n+    assert_eq!(r.to_string(), \"123\");\n+}\n+\n+#[test]\n+fn test_from_box_trait_zero_sized() {\n+    use std::fmt::Debug;\n+\n+    let b: Box<dyn Debug> = box ();\n+    let r: Rc<dyn Debug> = Rc::from(b);\n+\n+    assert_eq!(format!(\"{:?}\", r), \"()\");\n+}\n+\n+#[test]\n+fn test_from_vec() {\n+    let v = vec![1, 2, 3];\n+    let r: Rc<[u32]> = Rc::from(v);\n+\n+    assert_eq!(&r[..], [1, 2, 3]);\n+}\n+\n+#[test]\n+fn test_downcast() {\n+    use std::any::Any;\n+\n+    let r1: Rc<dyn Any> = Rc::new(i32::max_value());\n+    let r2: Rc<dyn Any> = Rc::new(\"abc\");\n+\n+    assert!(r1.clone().downcast::<u32>().is_err());\n+\n+    let r1i32 = r1.downcast::<i32>();\n+    assert!(r1i32.is_ok());\n+    assert_eq!(r1i32.unwrap(), Rc::new(i32::max_value()));\n+\n+    assert!(r2.clone().downcast::<i32>().is_err());\n+\n+    let r2str = r2.downcast::<&'static str>();\n+    assert!(r2str.is_ok());\n+    assert_eq!(r2str.unwrap(), Rc::new(\"abc\"));\n+}\n+\n+#[test]\n+fn test_array_from_slice() {\n+    let v = vec![1, 2, 3];\n+    let r: Rc<[u32]> = Rc::from(v);\n+\n+    let a: Result<Rc<[u32; 3]>, _> = r.clone().try_into();\n+    assert!(a.is_ok());\n+\n+    let a: Result<Rc<[u32; 2]>, _> = r.clone().try_into();\n+    assert!(a.is_err());\n+}"}, {"sha": "881d499c0745baf427f3e61e98281d263473b06f", "filename": "src/liballoc/slice.rs", "status": "modified", "additions": 137, "deletions": 59, "changes": 196, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fliballoc%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fliballoc%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fslice.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -123,12 +123,12 @@ pub use core::slice::{RChunks, RChunksMut, RChunksExact, RChunksExactMut};\n ////////////////////////////////////////////////////////////////////////////////\n \n // HACK(japaric) needed for the implementation of `vec!` macro during testing\n-// NB see the hack module in this file for more details\n+// N.B., see the `hack` module in this file for more details.\n #[cfg(test)]\n pub use hack::into_vec;\n \n // HACK(japaric) needed for the implementation of `Vec::clone` during testing\n-// NB see the hack module in this file for more details\n+// N.B., see the `hack` module in this file for more details.\n #[cfg(test)]\n pub use hack::to_vec;\n \n@@ -137,17 +137,16 @@ pub use hack::to_vec;\n // `core::slice::SliceExt` - we need to supply these functions for the\n // `test_permutations` test\n mod hack {\n-    use core::mem;\n-\n     use crate::boxed::Box;\n     use crate::vec::Vec;\n     #[cfg(test)]\n     use crate::string::ToString;\n \n-    pub fn into_vec<T>(mut b: Box<[T]>) -> Vec<T> {\n+    pub fn into_vec<T>(b: Box<[T]>) -> Vec<T> {\n         unsafe {\n-            let xs = Vec::from_raw_parts(b.as_mut_ptr(), b.len(), b.len());\n-            mem::forget(b);\n+            let len = b.len();\n+            let b = Box::into_raw(b);\n+            let xs = Vec::from_raw_parts(b as *mut T, len, len);\n             xs\n         }\n     }\n@@ -376,7 +375,7 @@ impl<T> [T] {\n     pub fn to_vec(&self) -> Vec<T>\n         where T: Clone\n     {\n-        // NB see hack module in this file\n+        // N.B., see the `hack` module in this file for more details.\n         hack::to_vec(self)\n     }\n \n@@ -397,7 +396,7 @@ impl<T> [T] {\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     #[inline]\n     pub fn into_vec(self: Box<Self>) -> Vec<T> {\n-        // NB see hack module in this file\n+        // N.B., see the `hack` module in this file for more details.\n         hack::into_vec(self)\n     }\n \n@@ -485,6 +484,57 @@ impl<T> [T] {\n         }\n         buf\n     }\n+\n+    /// Flattens a slice of `T` into a single value `Self::Output`.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// assert_eq!([\"hello\", \"world\"].concat(), \"helloworld\");\n+    /// assert_eq!([[1, 2], [3, 4]].concat(), [1, 2, 3, 4]);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    pub fn concat<Item: ?Sized>(&self) -> <Self as Concat<Item>>::Output\n+        where Self: Concat<Item>\n+    {\n+        Concat::concat(self)\n+    }\n+\n+    /// Flattens a slice of `T` into a single value `Self::Output`, placing a\n+    /// given separator between each.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// assert_eq!([\"hello\", \"world\"].join(\" \"), \"hello world\");\n+    /// assert_eq!([[1, 2], [3, 4]].join(&0), [1, 2, 0, 3, 4]);\n+    /// assert_eq!([[1, 2], [3, 4]].join(&[0, 0][..]), [1, 2, 0, 0, 3, 4]);\n+    /// ```\n+    #[stable(feature = \"rename_connect_to_join\", since = \"1.3.0\")]\n+    pub fn join<Separator>(&self, sep: Separator) -> <Self as Join<Separator>>::Output\n+        where Self: Join<Separator>\n+    {\n+        Join::join(self, sep)\n+    }\n+\n+    /// Flattens a slice of `T` into a single value `Self::Output`, placing a\n+    /// given separator between each.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// # #![allow(deprecated)]\n+    /// assert_eq!([\"hello\", \"world\"].connect(\" \"), \"hello world\");\n+    /// assert_eq!([[1, 2], [3, 4]].connect(&0), [1, 2, 0, 3, 4]);\n+    /// ```\n+    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+    #[rustc_deprecated(since = \"1.3.0\", reason = \"renamed to join\")]\n+    pub fn connect<Separator>(&self, sep: Separator) -> <Self as Join<Separator>>::Output\n+        where Self: Join<Separator>\n+    {\n+        Join::join(self, sep)\n+    }\n+\n }\n \n #[lang = \"slice_u8_alloc\"]\n@@ -528,75 +578,84 @@ impl [u8] {\n ////////////////////////////////////////////////////////////////////////////////\n // Extension traits for slices over specific kinds of data\n ////////////////////////////////////////////////////////////////////////////////\n-#[unstable(feature = \"slice_concat_ext\",\n-           reason = \"trait should not have to exist\",\n-           issue = \"27747\")]\n-/// An extension trait for concatenating slices\n+\n+/// Helper trait for [`[T]::concat`](../../std/primitive.slice.html#method.concat).\n+///\n+/// Note: the `Item` type parameter is not used in this trait,\n+/// but it allows impls to be more generic.\n+/// Without it, we get this error:\n+///\n+/// ```error\n+/// error[E0207]: the type parameter `T` is not constrained by the impl trait, self type, or predica\n+///    --> src/liballoc/slice.rs:608:6\n+///     |\n+/// 608 | impl<T: Clone, V: Borrow<[T]>> Concat for [V] {\n+///     |      ^ unconstrained type parameter\n+/// ```\n+///\n+/// This is because there could exist `V` types with multiple `Borrow<[_]>` impls,\n+/// such that multiple `T` types would apply:\n ///\n-/// While this trait is unstable, the methods are stable. `SliceConcatExt` is\n-/// included in the [standard library prelude], so you can use [`join()`] and\n-/// [`concat()`] as if they existed on `[T]` itself.\n+/// ```\n+/// # #[allow(dead_code)]\n+/// pub struct Foo(Vec<u32>, Vec<String>);\n ///\n-/// [standard library prelude]: ../../std/prelude/index.html\n-/// [`join()`]: #tymethod.join\n-/// [`concat()`]: #tymethod.concat\n-pub trait SliceConcatExt<T: ?Sized> {\n-    #[unstable(feature = \"slice_concat_ext\",\n-               reason = \"trait should not have to exist\",\n-               issue = \"27747\")]\n+/// impl std::borrow::Borrow<[u32]> for Foo {\n+///     fn borrow(&self) -> &[u32] { &self.0 }\n+/// }\n+///\n+/// impl std::borrow::Borrow<[String]> for Foo {\n+///     fn borrow(&self) -> &[String] { &self.1 }\n+/// }\n+/// ```\n+#[unstable(feature = \"slice_concat_trait\", issue = \"27747\")]\n+pub trait Concat<Item: ?Sized> {\n+    #[unstable(feature = \"slice_concat_trait\", issue = \"27747\")]\n     /// The resulting type after concatenation\n     type Output;\n \n-    /// Flattens a slice of `T` into a single value `Self::Output`.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// assert_eq!([\"hello\", \"world\"].concat(), \"helloworld\");\n-    /// assert_eq!([[1, 2], [3, 4]].concat(), [1, 2, 3, 4]);\n-    /// ```\n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    fn concat(&self) -> Self::Output;\n+    /// Implementation of [`[T]::concat`](../../std/primitive.slice.html#method.concat)\n+    #[unstable(feature = \"slice_concat_trait\", issue = \"27747\")]\n+    fn concat(slice: &Self) -> Self::Output;\n+}\n \n-    /// Flattens a slice of `T` into a single value `Self::Output`, placing a\n-    /// given separator between each.\n-    ///\n-    /// # Examples\n-    ///\n-    /// ```\n-    /// assert_eq!([\"hello\", \"world\"].join(\" \"), \"hello world\");\n-    /// assert_eq!([[1, 2], [3, 4]].join(&0), [1, 2, 0, 3, 4]);\n-    /// ```\n-    #[stable(feature = \"rename_connect_to_join\", since = \"1.3.0\")]\n-    fn join(&self, sep: &T) -> Self::Output;\n+/// Helper trait for [`[T]::join`](../../std/primitive.slice.html#method.join)\n+#[unstable(feature = \"slice_concat_trait\", issue = \"27747\")]\n+pub trait Join<Separator> {\n+    #[unstable(feature = \"slice_concat_trait\", issue = \"27747\")]\n+    /// The resulting type after concatenation\n+    type Output;\n \n-    #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    #[rustc_deprecated(since = \"1.3.0\", reason = \"renamed to join\")]\n-    fn connect(&self, sep: &T) -> Self::Output;\n+    /// Implementation of [`[T]::join`](../../std/primitive.slice.html#method.join)\n+    #[unstable(feature = \"slice_concat_trait\", issue = \"27747\")]\n+    fn join(slice: &Self, sep: Separator) -> Self::Output;\n }\n \n-#[unstable(feature = \"slice_concat_ext\",\n-           reason = \"trait should not have to exist\",\n-           issue = \"27747\")]\n-impl<T: Clone, V: Borrow<[T]>> SliceConcatExt<T> for [V] {\n+#[unstable(feature = \"slice_concat_ext\", issue = \"27747\")]\n+impl<T: Clone, V: Borrow<[T]>> Concat<T> for [V] {\n     type Output = Vec<T>;\n \n-    fn concat(&self) -> Vec<T> {\n-        let size = self.iter().map(|slice| slice.borrow().len()).sum();\n+    fn concat(slice: &Self) -> Vec<T> {\n+        let size = slice.iter().map(|slice| slice.borrow().len()).sum();\n         let mut result = Vec::with_capacity(size);\n-        for v in self {\n+        for v in slice {\n             result.extend_from_slice(v.borrow())\n         }\n         result\n     }\n+}\n \n-    fn join(&self, sep: &T) -> Vec<T> {\n-        let mut iter = self.iter();\n+#[unstable(feature = \"slice_concat_ext\", issue = \"27747\")]\n+impl<T: Clone, V: Borrow<[T]>> Join<&T> for [V] {\n+    type Output = Vec<T>;\n+\n+    fn join(slice: &Self, sep: &T) -> Vec<T> {\n+        let mut iter = slice.iter();\n         let first = match iter.next() {\n             Some(first) => first,\n             None => return vec![],\n         };\n-        let size = self.iter().map(|slice| slice.borrow().len()).sum::<usize>() + self.len() - 1;\n+        let size = slice.iter().map(|v| v.borrow().len()).sum::<usize>() + slice.len() - 1;\n         let mut result = Vec::with_capacity(size);\n         result.extend_from_slice(first.borrow());\n \n@@ -606,9 +665,28 @@ impl<T: Clone, V: Borrow<[T]>> SliceConcatExt<T> for [V] {\n         }\n         result\n     }\n+}\n \n-    fn connect(&self, sep: &T) -> Vec<T> {\n-        self.join(sep)\n+#[unstable(feature = \"slice_concat_ext\", issue = \"27747\")]\n+impl<T: Clone, V: Borrow<[T]>> Join<&[T]> for [V] {\n+    type Output = Vec<T>;\n+\n+    fn join(slice: &Self, sep: &[T]) -> Vec<T> {\n+        let mut iter = slice.iter();\n+        let first = match iter.next() {\n+            Some(first) => first,\n+            None => return vec![],\n+        };\n+        let size = slice.iter().map(|v| v.borrow().len()).sum::<usize>() +\n+            sep.len() * (slice.len() - 1);\n+        let mut result = Vec::with_capacity(size);\n+        result.extend_from_slice(first.borrow());\n+\n+        for v in iter {\n+            result.extend_from_slice(sep);\n+            result.extend_from_slice(v.borrow())\n+        }\n+        result\n     }\n }\n "}, {"sha": "9a1342c30d502b57130c632b4c3011faf1420f40", "filename": "src/liballoc/str.rs", "status": "modified", "additions": 34, "deletions": 17, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fliballoc%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fliballoc%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstr.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -28,7 +28,7 @@\n // It's cleaner to just turn off the unused_imports warning than to fix them.\n #![allow(unused_imports)]\n \n-use core::borrow::Borrow;\n+use core::borrow::{Borrow, BorrowMut};\n use core::str::pattern::{Pattern, Searcher, ReverseSearcher, DoubleEndedSearcher};\n use core::mem;\n use core::ptr;\n@@ -37,7 +37,7 @@ use core::unicode::conversions;\n \n use crate::borrow::ToOwned;\n use crate::boxed::Box;\n-use crate::slice::{SliceConcatExt, SliceIndex};\n+use crate::slice::{Concat, Join, SliceIndex};\n use crate::string::String;\n use crate::vec::Vec;\n \n@@ -68,26 +68,29 @@ pub use core::str::pattern;\n pub use core::str::EncodeUtf16;\n #[stable(feature = \"split_ascii_whitespace\", since = \"1.34.0\")]\n pub use core::str::SplitAsciiWhitespace;\n+#[stable(feature = \"str_escape\", since = \"1.34.0\")]\n+pub use core::str::{EscapeDebug, EscapeDefault, EscapeUnicode};\n \n-#[unstable(feature = \"slice_concat_ext\",\n-           reason = \"trait should not have to exist\",\n-           issue = \"27747\")]\n-impl<S: Borrow<str>> SliceConcatExt<str> for [S] {\n+/// Note: `str` in `Concat<str>` is not meaningful here.\n+/// This type parameter of the trait only exists to enable another impl.\n+#[unstable(feature = \"slice_concat_ext\", issue = \"27747\")]\n+impl<S: Borrow<str>> Concat<str> for [S] {\n     type Output = String;\n \n-    fn concat(&self) -> String {\n-        self.join(\"\")\n+    fn concat(slice: &Self) -> String {\n+        Join::join(slice, \"\")\n     }\n+}\n+\n+#[unstable(feature = \"slice_concat_ext\", issue = \"27747\")]\n+impl<S: Borrow<str>> Join<&str> for [S] {\n+    type Output = String;\n \n-    fn join(&self, sep: &str) -> String {\n+    fn join(slice: &Self, sep: &str) -> String {\n         unsafe {\n-            String::from_utf8_unchecked( join_generic_copy(self, sep.as_bytes()) )\n+            String::from_utf8_unchecked( join_generic_copy(slice, sep.as_bytes()) )\n         }\n     }\n-\n-    fn connect(&self, sep: &str) -> String {\n-        self.join(sep)\n-    }\n }\n \n macro_rules! spezialize_for_lengths {\n@@ -128,7 +131,7 @@ macro_rules! copy_slice_and_advance {\n \n // Optimized join implementation that works for both Vec<T> (T: Copy) and String's inner vec\n // Currently (2018-05-13) there is a bug with type inference and specialization (see issue #36262)\n-// For this reason SliceConcatExt<T> is not specialized for T: Copy and SliceConcatExt<str> is the\n+// For this reason SliceConcat<T> is not specialized for T: Copy and SliceConcat<str> is the\n // only user of this function. It is left in place for the time when that is fixed.\n //\n // the bounds for String-join are S: Borrow<str> and for Vec-join Borrow<[T]>\n@@ -188,6 +191,14 @@ impl Borrow<str> for String {\n     }\n }\n \n+#[stable(feature = \"string_borrow_mut\", since = \"1.36.0\")]\n+impl BorrowMut<str> for String {\n+    #[inline]\n+    fn borrow_mut(&mut self) -> &mut str {\n+        &mut self[..]\n+    }\n+}\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl ToOwned for str {\n     type Owned = String;\n@@ -197,7 +208,7 @@ impl ToOwned for str {\n     }\n \n     fn clone_into(&self, target: &mut String) {\n-        let mut b = mem::replace(target, String::new()).into_bytes();\n+        let mut b = mem::take(target).into_bytes();\n         self.as_bytes().clone_into(&mut b);\n         *target = unsafe { String::from_utf8_unchecked(b) }\n     }\n@@ -421,6 +432,13 @@ impl str {\n     ///\n     /// assert_eq!(new_year, new_year.to_uppercase());\n     /// ```\n+    ///\n+    /// One character can become multiple:\n+    /// ```\n+    /// let s = \"tsch\u00fc\u00df\";\n+    ///\n+    /// assert_eq!(\"TSCH\u00dcSS\", s.to_uppercase());\n+    /// ```\n     #[stable(feature = \"unicode_case_mapping\", since = \"1.2.0\")]\n     pub fn to_uppercase(&self) -> String {\n         let mut s = String::with_capacity(self.len());\n@@ -571,4 +589,3 @@ impl str {\n pub unsafe fn from_boxed_utf8_unchecked(v: Box<[u8]>) -> Box<str> {\n     Box::from_raw(Box::into_raw(v) as *mut str)\n }\n-"}, {"sha": "eca726cd41032f28d1638398de4d593a019af07f", "filename": "src/liballoc/string.rs", "status": "modified", "additions": 28, "deletions": 3, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fliballoc%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fliballoc%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fstring.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522", "patch": "@@ -552,7 +552,7 @@ impl String {\n     /// assert_eq!(\"Hello \ufffdWorld\", output);\n     /// ```\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn from_utf8_lossy<'a>(v: &'a [u8]) -> Cow<'a, str> {\n+    pub fn from_utf8_lossy(v: &[u8]) -> Cow<'_, str> {\n         let mut iter = lossy::Utf8Lossy::from_bytes(v).chunks();\n \n         let (first_valid, first_broken) = if let Some(chunk) = iter.next() {\n@@ -1200,8 +1200,8 @@ impl String {\n     /// Retains only the characters specified by the predicate.\n     ///\n     /// In other words, remove all characters `c` such that `f(c)` returns `false`.\n-    /// This method operates in place and preserves the order of the retained\n-    /// characters.\n+    /// This method operates in place, visiting each character exactly once in the\n+    /// original order, and preserves the order of the retained characters.\n     ///\n     /// # Examples\n     ///\n@@ -1212,6 +1212,16 @@ impl String {\n     ///\n     /// assert_eq!(s, \"foobar\");\n     /// ```\n+    ///\n+    /// The exact order may be useful for tracking external state, like an index.\n+    ///\n+    /// ```\n+    /// let mut s = String::from(\"abcde\");\n+    /// let keep = [false, true, true, false, true];\n+    /// let mut i = 0;\n+    /// s.retain(|_| (keep[i], i += 1).0);\n+    /// assert_eq!(s, \"bce\");\n+    /// ```\n     #[inline]\n     #[stable(feature = \"string_retain\", since = \"1.26.0\")]\n     pub fn retain<F>(&mut self, mut f: F)\n@@ -1828,6 +1838,7 @@ impl PartialEq for String {\n macro_rules! impl_eq {\n     ($lhs:ty, $rhs: ty) => {\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[allow(unused_lifetimes)]\n         impl<'a, 'b> PartialEq<$rhs> for $lhs {\n             #[inline]\n             fn eq(&self, other: &$rhs) -> bool { PartialEq::eq(&self[..], &other[..]) }\n@@ -1836,6 +1847,7 @@ macro_rules! impl_eq {\n         }\n \n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[allow(unused_lifetimes)]\n         impl<'a, 'b> PartialEq<$lhs> for $rhs {\n             #[inline]\n             fn eq(&self, other: &$lhs) -> bool { PartialEq::eq(&self[..], &other[..]) }\n@@ -2179,6 +2191,14 @@ impl From<&str> for String {\n     }\n }\n \n+#[stable(feature = \"from_ref_string\", since = \"1.35.0\")]\n+impl From<&String> for String {\n+    #[inline]\n+    fn from(s: &String) -> String {\n+        s.clone()\n+    }\n+}\n+\n // note: test pulls in libstd, which causes errors here\n #[cfg(not(test))]\n #[stable(feature = \"string_from_box\", since = \"1.18.0\")]\n@@ -2367,6 +2387,11 @@ impl Iterator for Drain<'_> {\n     fn size_hint(&self) -> (usize, Option<usize>) {\n         self.iter.size_hint()\n     }\n+\n+    #[inline]\n+    fn last(mut self) -> Option<char> {\n+        self.next_back()\n+    }\n }\n \n #[stable(feature = \"drain\", since = \"1.6.0\")]"}, {"sha": "7d3b2656a7b907b491c1d1e7ca8b9ef733453b87", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "9220f5e0333efa431570f50ca56663d1c1400c4a", "filename": "src/liballoc/sync/tests.rs", "status": "added", "additions": 492, "deletions": 0, "changes": 492, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fliballoc%2Fsync%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fliballoc%2Fsync%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync%2Ftests.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "ed46ba8a1b938249dbb3abfa93e67c952d77d7ff", "filename": "src/liballoc/tests.rs", "status": "added", "additions": 153, "deletions": 0, "changes": 153, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fliballoc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fliballoc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "cf2ad2a8e60338620de2fb9f931006f14d13f594", "filename": "src/liballoc/tests/arc.rs", "status": "modified", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fliballoc%2Ftests%2Farc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fliballoc%2Ftests%2Farc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Farc.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "0685fa943c0b87a78c4312cb4e8cee7789b0776c", "filename": "src/liballoc/tests/binary_heap.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fliballoc%2Ftests%2Fbinary_heap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fliballoc%2Ftests%2Fbinary_heap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbinary_heap.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "844afe870766ba1d2c161ecd9af933d96ee0890a", "filename": "src/liballoc/tests/btree/map.rs", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbtree%2Fmap.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "8c3dacd914f39947e549c6a7095ffe5a0ccfaebe", "filename": "src/liballoc/tests/btree/set.rs", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fbtree%2Fset.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "6f357eda9b83b88d70e93c58cddb4edef75b452b", "filename": "src/liballoc/tests/cow_str.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fliballoc%2Ftests%2Fcow_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fliballoc%2Ftests%2Fcow_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fcow_str.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "904b3e7e1b07cc4f23bd2ddae5e3063d1e335752", "filename": "src/liballoc/tests/heap.rs", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fliballoc%2Ftests%2Fheap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fliballoc%2Ftests%2Fheap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fheap.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "6d774f3fecd9267cf1cf812895100ea6e30e7874", "filename": "src/liballoc/tests/lib.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fliballoc%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fliballoc%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Flib.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "8a26454c389d7c6855b661199084f7e386ebd97b", "filename": "src/liballoc/tests/linked_list.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fliballoc%2Ftests%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fliballoc%2Ftests%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Flinked_list.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "7854ca0fc16b26936111d78926fff1252df1e960", "filename": "src/liballoc/tests/rc.rs", "status": "modified", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fliballoc%2Ftests%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fliballoc%2Ftests%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Frc.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "ad2cd7c95eb8fc381acb684cb3b0ae62d228b37c", "filename": "src/liballoc/tests/slice.rs", "status": "modified", "additions": 15, "deletions": 22, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fliballoc%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fliballoc%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fslice.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "c5198ca39fedf33788c6cd76b59afbbef42a2173", "filename": "src/liballoc/tests/str.rs", "status": "modified", "additions": 10, "deletions": 11, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fliballoc%2Ftests%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fliballoc%2Ftests%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fstr.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "765210e5aa6b39f636ee6245d04c671246d7824e", "filename": "src/liballoc/tests/string.rs", "status": "modified", "additions": 2, "deletions": 11, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fliballoc%2Ftests%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fliballoc%2Ftests%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fstring.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "6e8ffe18522a06b683050016b256c1da3f2ced98", "filename": "src/liballoc/tests/vec.rs", "status": "modified", "additions": 132, "deletions": 14, "changes": 146, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fliballoc%2Ftests%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fliballoc%2Ftests%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fvec.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "1bbcca97b3c78056ee0a8d818d09eae5d4538ee6", "filename": "src/liballoc/tests/vec_deque.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fliballoc%2Ftests%2Fvec_deque.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fliballoc%2Ftests%2Fvec_deque.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Ftests%2Fvec_deque.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "dac04e4e624032be1d6222e1bcc019d6400e6939", "filename": "src/liballoc/vec.rs", "status": "modified", "additions": 209, "deletions": 62, "changes": 271, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fliballoc%2Fvec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Fliballoc%2Fvec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fvec.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "2643912f6d7d6caed2619450ef7307be05d3b332", "filename": "src/libarena/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibarena%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibarena%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2FCargo.toml?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "690d8344acff96b8667fefe0b10f2972a8e0c650", "filename": "src/libarena/lib.rs", "status": "modified", "additions": 166, "deletions": 241, "changes": 407, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibarena%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibarena%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Flib.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "fa4189409d0e86ad67776c7bd973f12d5802fec6", "filename": "src/libarena/tests.rs", "status": "added", "additions": 213, "deletions": 0, "changes": 213, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibarena%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibarena%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibarena%2Ftests.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "ac07ffb14febdd8ba0f74a7d1a319b1f0ea5f1f4", "filename": "src/libcore/Cargo.toml", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2FCargo.toml?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "5d0333d5226d20b43a2a8de996742d5b9fb657e1", "filename": "src/libcore/alloc.rs", "status": "modified", "additions": 19, "deletions": 16, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Falloc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Falloc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Falloc.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "078091a9b5475494486fb8a56fcf09a5ca8c60ee", "filename": "src/libcore/any.rs", "status": "modified", "additions": 32, "deletions": 5, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fany.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fany.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fany.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "b5614010e5c2f2b1730d93092b1fd6c38b7105ab", "filename": "src/libcore/array.rs", "status": "modified", "additions": 309, "deletions": 170, "changes": 479, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Farray.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "e6a6fdde540422abac4613b194ae73ae267d3345", "filename": "src/libcore/ascii.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fascii.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "a337c467131335cdbafe1f60951f31743f317ff4", "filename": "src/libcore/benches/ascii.rs", "status": "added", "additions": 349, "deletions": 0, "changes": 349, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fbenches%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fbenches%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbenches%2Fascii.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "7dcfad8306fceab448ae1a3899f2b946648c3603", "filename": "src/libcore/benches/iter.rs", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fbenches%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fbenches%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbenches%2Fiter.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "dea2963d9ac8377eeb54045acbb3a5d0285f202e", "filename": "src/libcore/benches/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fbenches%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fbenches%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fbenches%2Flib.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "4d58aaca941833ac047d7282c25261bfad9e329c", "filename": "src/libcore/borrow.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fborrow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fborrow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fborrow.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "8579dbf353e800e8c287bcfd3eecacc9eb7f9451", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 106, "deletions": 68, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "0a870c67518c73a8fd4361971b1c35fc099db0f7", "filename": "src/libcore/char/convert.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fchar%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fchar%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fconvert.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "23059243c61d773e3210b71d2f7261d74994fa6f", "filename": "src/libcore/char/decode.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fchar%2Fdecode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fchar%2Fdecode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fdecode.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "aa834db2b9b3e99f68d8fd1f9454570305fc765a", "filename": "src/libcore/char/methods.rs", "status": "modified", "additions": 44, "deletions": 38, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fchar%2Fmethods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fchar%2Fmethods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fmethods.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "dedd2f758b6cb299336ccb15373165bd0a98f2fc", "filename": "src/libcore/char/mod.rs", "status": "modified", "additions": 32, "deletions": 10, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fchar%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fchar%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar%2Fmod.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "9e32acb97d36001d1f4c1a9f142b977dc0ea4eee", "filename": "src/libcore/clone.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fclone.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fclone.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fclone.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "f9613556a1ebc1bd593e68a8ec5616db4184c532", "filename": "src/libcore/cmp.rs", "status": "modified", "additions": 22, "deletions": 17, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fcmp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fcmp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcmp.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "624b13d96472cfe1dad9ded9f9a134576666fba6", "filename": "src/libcore/convert.rs", "status": "modified", "additions": 140, "deletions": 97, "changes": 237, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fconvert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fconvert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fconvert.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "eda0e7c518c58290b6f212c2319dae92ee038948", "filename": "src/libcore/ffi.rs", "status": "modified", "additions": 199, "deletions": 57, "changes": 256, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fffi.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "cb4e32622ff1f6a169725e06651d918fb02f8cf2", "filename": "src/libcore/fmt/builders.rs", "status": "modified", "additions": 173, "deletions": 73, "changes": 246, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Ffmt%2Fbuilders.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Ffmt%2Fbuilders.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fbuilders.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "a2fff913ac720c1475eeb23a6a9be0d3588ff035", "filename": "src/libcore/fmt/float.rs", "status": "modified", "additions": 25, "deletions": 24, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Ffmt%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Ffmt%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Ffloat.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "4a7c6af7adab750ff5441ee573706ad65d390556", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 78, "deletions": 78, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "3b5c9fbff250ae1e654e156e38b36950f489e69d", "filename": "src/libcore/fmt/num.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Ffmt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Ffmt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fnum.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "593c01060ca49ae981ce21ceab6423055e85cf30", "filename": "src/libcore/future/future.rs", "status": "modified", "additions": 38, "deletions": 30, "changes": 68, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Ffuture%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Ffuture%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture%2Ffuture.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "89ea4713cfdaaa43b377e9bc18fa49735940a48b", "filename": "src/libcore/future/mod.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Ffuture%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Ffuture%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffuture%2Fmod.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "38e38642842403bf88843ca2f8a22fd1e2b94f7d", "filename": "src/libcore/hash/mod.rs", "status": "modified", "additions": 19, "deletions": 22, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fhash%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fhash%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fmod.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "19aeafd882ef12c1ca5e3cc39ce7282f535da02e", "filename": "src/libcore/hash/sip.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fhash%2Fsip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fhash%2Fsip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhash%2Fsip.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "3b2b28217f9b391cd3dd20fe031701de9e311ae4", "filename": "src/libcore/hint.rs", "status": "modified", "additions": 83, "deletions": 16, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fhint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fhint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fhint.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "3acf2ec837d88cae0ca415e45d0c08af150e4686", "filename": "src/libcore/internal_macros.rs", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Finternal_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Finternal_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Finternal_macros.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "56e45c3695f61830594cbaaba62ea3076b27381f", "filename": "src/libcore/intrinsics.rs", "status": "modified", "additions": 75, "deletions": 45, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fintrinsics.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "76239ebc0abaf360e7f5a1c5e14e5cb3c4e741a5", "filename": "src/libcore/iter/adapters/chain.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fiter%2Fadapters%2Fchain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fiter%2Fadapters%2Fchain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Fchain.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "8c2aae477bf2a35ca1a31864ef517e36a81ea6a1", "filename": "src/libcore/iter/adapters/flatten.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fiter%2Fadapters%2Fflatten.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fiter%2Fadapters%2Fflatten.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Fflatten.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "b2702902956935b86d2f805cfb5582434379a395", "filename": "src/libcore/iter/adapters/mod.rs", "status": "modified", "additions": 242, "deletions": 20, "changes": 262, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Fmod.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "06f047d92872e31ac1f372d593a1fadee4a2bb09", "filename": "src/libcore/iter/adapters/zip.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fiter%2Fadapters%2Fzip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fiter%2Fadapters%2Fzip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fadapters%2Fzip.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "aba8e84d58be553566165846b39eb2990f2da84b", "filename": "src/libcore/iter/mod.rs", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fiter%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fiter%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fmod.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "efda3b263cc97fae94f08fb2dda1522424763779", "filename": "src/libcore/iter/range.rs", "status": "modified", "additions": 88, "deletions": 53, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fiter%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fiter%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Frange.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "70a3b70c180dc1169cf441d7d9981cea8032d65f", "filename": "src/libcore/iter/sources.rs", "status": "modified", "additions": 11, "deletions": 13, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fiter%2Fsources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fiter%2Fsources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Fsources.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "812463e77f9767476c4ae42b474db34a8e88b339", "filename": "src/libcore/iter/traits/accum.rs", "status": "modified", "additions": 50, "deletions": 74, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fiter%2Ftraits%2Faccum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fiter%2Ftraits%2Faccum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Faccum.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "1865160bc3cf428626241165fbf37ef080aa940c", "filename": "src/libcore/iter/traits/collect.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fiter%2Ftraits%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fiter%2Ftraits%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fcollect.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "2c1aeb5690a585d0e254bc4b274b9828597a5b8d", "filename": "src/libcore/iter/traits/double_ended.rs", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fiter%2Ftraits%2Fdouble_ended.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fiter%2Ftraits%2Fdouble_ended.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fdouble_ended.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "4a7db348b18516c51c51f64fd091e41da85ce35f", "filename": "src/libcore/iter/traits/exact_size.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fiter%2Ftraits%2Fexact_size.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fiter%2Ftraits%2Fexact_size.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fexact_size.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "7e941267ce8246e52ab1828cd2ed79f6b0ab4d23", "filename": "src/libcore/iter/traits/iterator.rs", "status": "modified", "additions": 140, "deletions": 127, "changes": 267, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "4d627383fd7cc50ac7484e669b8fd9068a487575", "filename": "src/libcore/lib.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Flib.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "09d2331b60fed4eed36312b98f3c3028b46d77fa", "filename": "src/libcore/macros.rs", "status": "modified", "additions": 776, "deletions": 160, "changes": 936, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmacros.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "79a188dbac99d891609cefed14f3edd81d90b96f", "filename": "src/libcore/marker.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fmarker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fmarker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmarker.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "90e84d0b28c3b0bea5c8d0a0c3d315f74ab73148", "filename": "src/libcore/mem.rs", "status": "removed", "additions": 0, "deletions": 1433, "changes": 1433, "blob_url": "https://github.com/rust-lang/rust/blob/33445aea509cadcd715009c79795d289268daa7c/src%2Flibcore%2Fmem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33445aea509cadcd715009c79795d289268daa7c/src%2Flibcore%2Fmem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem.rs?ref=33445aea509cadcd715009c79795d289268daa7c"}, {"sha": "bb353993236289b2ae4d131d9d4352fb34b0b8b4", "filename": "src/libcore/mem/manually_drop.rs", "status": "added", "additions": 148, "deletions": 0, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fmem%2Fmanually_drop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fmem%2Fmanually_drop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmanually_drop.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "8d064de6f4751da48c1dc68fd33ef8fdd1f0d1f7", "filename": "src/libcore/mem/maybe_uninit.rs", "status": "added", "additions": 551, "deletions": 0, "changes": 551, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmaybe_uninit.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "86dae985fdb00cc3d6ab67609dd6663de19200b1", "filename": "src/libcore/mem/mod.rs", "status": "added", "additions": 823, "deletions": 0, "changes": 823, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fmem%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fmem%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fmem%2Fmod.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "342ac69748d92a5d35d97cb53d8af2f7fcee56d6", "filename": "src/libcore/num/bignum.rs", "status": "modified", "additions": 30, "deletions": 30, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fnum%2Fbignum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fnum%2Fbignum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fbignum.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "fa3c8075378ca40a14a472903bfa7377d4dc1e2a", "filename": "src/libcore/num/dec2flt/algorithm.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fnum%2Fdec2flt%2Falgorithm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fnum%2Fdec2flt%2Falgorithm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Falgorithm.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "4536bbc94ad803e5d83117437d581d9a52541a25", "filename": "src/libcore/num/dec2flt/mod.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fnum%2Fdec2flt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fnum%2Fdec2flt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Fmod.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "4d50516ce546bb79e4461ee0c98a0da10fd04614", "filename": "src/libcore/num/dec2flt/num.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fnum%2Fdec2flt%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fnum%2Fdec2flt%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Fnum.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "cf3664a8748867a375802be4556a83a7b907e34c", "filename": "src/libcore/num/dec2flt/parse.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fnum%2Fdec2flt%2Fparse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fnum%2Fdec2flt%2Fparse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Fparse.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "fdbdaa238e0f2f63896eb81d19f33fe07b2599c0", "filename": "src/libcore/num/dec2flt/rawfp.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fnum%2Fdec2flt%2Frawfp.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fnum%2Fdec2flt%2Frawfp.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fdec2flt%2Frawfp.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "8ff78166a9f2d83b526382ca6bbf64df56c6dbef", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 125, "deletions": 23, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "d45c04f45afc2b4fe3b4a697dae6814304f00b4f", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 125, "deletions": 23, "changes": 148, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "ee0f18ba295e994247183ae600be8380470b10c1", "filename": "src/libcore/num/flt2dec/decoder.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fnum%2Fflt2dec%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fnum%2Fflt2dec%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fflt2dec%2Fdecoder.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "6d42a77744966cad5240f5cffbae10f280a045b4", "filename": "src/libcore/num/flt2dec/mod.rs", "status": "modified", "additions": 10, "deletions": 12, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fnum%2Fflt2dec%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fnum%2Fflt2dec%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fflt2dec%2Fmod.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "35fb4b927589ff6bc5e875cced022253e135af95", "filename": "src/libcore/num/flt2dec/strategy/dragon.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fflt2dec%2Fstrategy%2Fdragon.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "61b50ec8ca566cba3125ce588902b8bdf56f4792", "filename": "src/libcore/num/flt2dec/strategy/grisu.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fflt2dec%2Fstrategy%2Fgrisu.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "67e30e7ffcb24d371d9f4c691d6e4c3cab5b62aa", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 406, "deletions": 247, "changes": 653, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "fd129a306d1c57024d788dc72dfdeea9069616d1", "filename": "src/libcore/num/wrapping.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fnum%2Fwrapping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fnum%2Fwrapping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fwrapping.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "3c009d644c64e3f6f3feb98f30e8150b56430cee", "filename": "src/libcore/ops/arith.rs", "status": "modified", "additions": 77, "deletions": 62, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fops%2Farith.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fops%2Farith.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Farith.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "a8f862f6c05a55f010d0e2dca351e90faaa2d976", "filename": "src/libcore/ops/bit.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fops%2Fbit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fops%2Fbit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Fbit.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "ce0d3fd01f78fefc030dbe2d2a3b67afbfc7561c", "filename": "src/libcore/ops/deref.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fops%2Fderef.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fops%2Fderef.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Fderef.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "b9552eaa1a0e5678c8b66aa6e2af55508416ea9b", "filename": "src/libcore/ops/function.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fops%2Ffunction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fops%2Ffunction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Ffunction.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "9cff474a760306be8f639270d67b5fed39802cd1", "filename": "src/libcore/ops/index.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fops%2Findex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fops%2Findex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Findex.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "5d1d3efd4120f2994b0296da0e1fce596fbd1664", "filename": "src/libcore/ops/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fops%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fops%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Fmod.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "1b4c4218cc15bb95e25ab47e803e6096414fdc1b", "filename": "src/libcore/ops/range.rs", "status": "modified", "additions": 67, "deletions": 43, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fops%2Frange.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fops%2Frange.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Frange.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "76fec1020f1eff572d8c8c5890efeffce81bc207", "filename": "src/libcore/ops/try.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fops%2Ftry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fops%2Ftry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Ftry.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "8e46830084642b573623723650f280e73671602e", "filename": "src/libcore/ops/unsize.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fops%2Funsize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fops%2Funsize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops%2Funsize.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "259ed36c5788530d05333c8158a7ff884fc28e31", "filename": "src/libcore/option.rs", "status": "modified", "additions": 249, "deletions": 80, "changes": 329, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Foption.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "989fc96732a5ab789b6273c3174833b68d6cc162", "filename": "src/libcore/panic.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpanic.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "15b7d69c58d24b09fc9abaa57daf3b91c80c07aa", "filename": "src/libcore/panicking.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fpanicking.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fpanicking.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpanicking.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "271ddcc4662cf0b53105336f7ac270dd4369d4a2", "filename": "src/libcore/pin.rs", "status": "modified", "additions": 262, "deletions": 115, "changes": 377, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fpin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fpin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fpin.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "c503d8c701938dc87b7f1c542f1171c11c309d7f", "filename": "src/libcore/prelude/v1.rs", "status": "modified", "additions": 56, "deletions": 11, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fprelude%2Fv1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fprelude%2Fv1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude%2Fv1.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "a9a029d606d6f84315931b1b69381dfe663c1de4", "filename": "src/libcore/ptr.rs", "status": "removed", "additions": 0, "deletions": 3075, "changes": 3075, "blob_url": "https://github.com/rust-lang/rust/blob/33445aea509cadcd715009c79795d289268daa7c/src%2Flibcore%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/33445aea509cadcd715009c79795d289268daa7c/src%2Flibcore%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr.rs?ref=33445aea509cadcd715009c79795d289268daa7c"}, {"sha": "fa55bbf9c16507ecd4c1f5399fd6ec9d4f497efb", "filename": "src/libcore/ptr/mod.rs", "status": "added", "additions": 2857, "deletions": 0, "changes": 2857, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fptr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fptr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fmod.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "ad3d1ce396ab755c70dd1adc709eec93943f9565", "filename": "src/libcore/ptr/non_null.rs", "status": "added", "additions": 226, "deletions": 0, "changes": 226, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fptr%2Fnon_null.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fptr%2Fnon_null.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Fnon_null.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "f0d011fe6b2c0c02f779d26ad0a4937e23e54efe", "filename": "src/libcore/ptr/unique.rs", "status": "added", "additions": 180, "deletions": 0, "changes": 180, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fptr%2Funique.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fptr%2Funique.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fptr%2Funique.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "75c329a7d6c10ad4a60d795a1fe58e48f6a69e02", "filename": "src/libcore/raw.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fraw.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fraw.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fraw.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "8c60a9c1b501d0497aec7faea4154e086f89c16e", "filename": "src/libcore/result.rs", "status": "modified", "additions": 165, "deletions": 61, "changes": 226, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fresult.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fresult.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fresult.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "45ab016c4962826d7953ddb6dd337ac349339b6e", "filename": "src/libcore/slice/memchr.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fslice%2Fmemchr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fslice%2Fmemchr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmemchr.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "d5a34ea2bd5a17edda41537a4194c82aa96cbadd", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 484, "deletions": 124, "changes": 608, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "0437937d769b7c435712796a34f8c1b9b8b92bde", "filename": "src/libcore/slice/rotate.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fslice%2Frotate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fslice%2Frotate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Frotate.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "2f2170f7ff14ce7860d3b219f7e55ce0e2a7365b", "filename": "src/libcore/slice/sort.rs", "status": "modified", "additions": 94, "deletions": 5, "changes": 99, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fslice%2Fsort.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fslice%2Fsort.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fsort.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "e8f747f1a67d5fc8c73070b4959c63787893f07e", "filename": "src/libcore/str/lossy.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fstr%2Flossy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fstr%2Flossy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Flossy.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "4faf9ff4d2ee2ca7eb2db4dd58bd5c0072929837", "filename": "src/libcore/str/mod.rs", "status": "modified", "additions": 135, "deletions": 66, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fstr%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fstr%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fmod.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}, {"sha": "ad9d956fda1c84d1309a4809d6a462b3822cfd4d", "filename": "src/libcore/str/pattern.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fstr%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fb3a01354ffecc41d7a189e4dd225d706387a522/src%2Flibcore%2Fstr%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fstr%2Fpattern.rs?ref=fb3a01354ffecc41d7a189e4dd225d706387a522"}]}