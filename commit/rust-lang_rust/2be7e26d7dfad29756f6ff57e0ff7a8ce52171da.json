{"sha": "2be7e26d7dfad29756f6ff57e0ff7a8ce52171da", "node_id": "C_kwDOAAsO6NoAKDJiZTdlMjZkN2RmYWQyOTc1NmY2ZmY1N2UwZmY3YThjZTUyMTcxZGE", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2022-03-27T17:10:31Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2022-03-27T17:21:09Z"}, "message": "Move mismatched-arg-count diagnostic to inference", "tree": {"sha": "0fad0e2cb332b28aca623d5628bbf4872a825352", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0fad0e2cb332b28aca623d5628bbf4872a825352"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2be7e26d7dfad29756f6ff57e0ff7a8ce52171da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2be7e26d7dfad29756f6ff57e0ff7a8ce52171da", "html_url": "https://github.com/rust-lang/rust/commit/2be7e26d7dfad29756f6ff57e0ff7a8ce52171da", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2be7e26d7dfad29756f6ff57e0ff7a8ce52171da/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "837901a4a624f4c1b1e5e7102a3dac79a217c686", "url": "https://api.github.com/repos/rust-lang/rust/commits/837901a4a624f4c1b1e5e7102a3dac79a217c686", "html_url": "https://github.com/rust-lang/rust/commit/837901a4a624f4c1b1e5e7102a3dac79a217c686"}], "stats": {"total": 150, "additions": 67, "deletions": 83}, "files": [{"sha": "c07c017c3df4b95eb519da888a542cb1df1379c1", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/2be7e26d7dfad29756f6ff57e0ff7a8ce52171da/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2be7e26d7dfad29756f6ff57e0ff7a8ce52171da/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=2be7e26d7dfad29756f6ff57e0ff7a8ce52171da", "patch": "@@ -1183,6 +1183,19 @@ impl DefWithBody {\n                         .expect(\"break outside of loop in synthetic syntax\");\n                     acc.push(BreakOutsideOfLoop { expr }.into())\n                 }\n+                hir_ty::InferenceDiagnostic::MismatchedArgCount { call_expr, expected, found } => {\n+                    match source_map.expr_syntax(*call_expr) {\n+                        Ok(source_ptr) => acc.push(\n+                            MismatchedArgCount {\n+                                call_expr: source_ptr,\n+                                expected: *expected,\n+                                found: *found,\n+                            }\n+                            .into(),\n+                        ),\n+                        Err(SyntheticSyntax) => (),\n+                    }\n+                }\n             }\n         }\n         for (expr, mismatch) in infer.expr_type_mismatches() {\n@@ -1297,14 +1310,6 @@ impl DefWithBody {\n                         );\n                     }\n                 }\n-                BodyValidationDiagnostic::MismatchedArgCount { call_expr, expected, found } => {\n-                    match source_map.expr_syntax(call_expr) {\n-                        Ok(source_ptr) => acc.push(\n-                            MismatchedArgCount { call_expr: source_ptr, expected, found }.into(),\n-                        ),\n-                        Err(SyntheticSyntax) => (),\n-                    }\n-                }\n                 BodyValidationDiagnostic::MissingMatchArms { match_expr } => {\n                     match source_map.expr_syntax(match_expr) {\n                         Ok(source_ptr) => {"}, {"sha": "335d95c0cf2652c0deae27bb458cc5b693134daf", "filename": "crates/hir_ty/src/diagnostics/expr.rs", "status": "modified", "additions": 4, "deletions": 62, "changes": 66, "blob_url": "https://github.com/rust-lang/rust/blob/2be7e26d7dfad29756f6ff57e0ff7a8ce52171da/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2be7e26d7dfad29756f6ff57e0ff7a8ce52171da/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Fdiagnostics%2Fexpr.rs?ref=2be7e26d7dfad29756f6ff57e0ff7a8ce52171da", "patch": "@@ -17,7 +17,7 @@ use crate::{\n         deconstruct_pat::DeconstructedPat,\n         usefulness::{compute_match_usefulness, MatchCheckCtx},\n     },\n-    InferenceResult, Interner, TyExt,\n+    InferenceResult, TyExt,\n };\n \n pub(crate) use hir_def::{\n@@ -35,11 +35,6 @@ pub enum BodyValidationDiagnostic {\n     ReplaceFilterMapNextWithFindMap {\n         method_call_expr: ExprId,\n     },\n-    MismatchedArgCount {\n-        call_expr: ExprId,\n-        expected: usize,\n-        found: usize,\n-    },\n     MissingMatchArms {\n         match_expr: ExprId,\n     },\n@@ -119,18 +114,9 @@ impl ExprValidator {\n             return;\n         }\n \n-        let is_method_call = matches!(expr, Expr::MethodCall { .. });\n-        let (sig, mut arg_count) = match expr {\n-            Expr::Call { callee, args } => {\n-                let callee = &self.infer.type_of_expr[*callee];\n-                let sig = match callee.callable_sig(db) {\n-                    Some(sig) => sig,\n-                    None => return,\n-                };\n-                (sig, args.len())\n-            }\n-            Expr::MethodCall { receiver, args, .. } => {\n-                let (callee, subst) = match self.infer.method_resolution(call_id) {\n+        match expr {\n+            Expr::MethodCall { receiver, .. } => {\n+                let (callee, _) = match self.infer.method_resolution(call_id) {\n                     Some(it) => it,\n                     None => return,\n                 };\n@@ -148,53 +134,9 @@ impl ExprValidator {\n                         },\n                     );\n                 }\n-                let receiver = &self.infer.type_of_expr[*receiver];\n-                if receiver.strip_references().is_unknown() {\n-                    // if the receiver is of unknown type, it's very likely we\n-                    // don't know enough to correctly resolve the method call.\n-                    // This is kind of a band-aid for #6975.\n-                    return;\n-                }\n-\n-                let sig = db.callable_item_signature(callee.into()).substitute(Interner, &subst);\n-\n-                (sig, args.len() + 1)\n             }\n             _ => return,\n         };\n-\n-        if sig.is_varargs {\n-            return;\n-        }\n-\n-        if sig.legacy_const_generics_indices.is_empty() {\n-            let mut param_count = sig.params().len();\n-\n-            if arg_count != param_count {\n-                if is_method_call {\n-                    param_count -= 1;\n-                    arg_count -= 1;\n-                }\n-                self.diagnostics.push(BodyValidationDiagnostic::MismatchedArgCount {\n-                    call_expr: call_id,\n-                    expected: param_count,\n-                    found: arg_count,\n-                });\n-            }\n-        } else {\n-            // With `#[rustc_legacy_const_generics]` there are basically two parameter counts that\n-            // are allowed.\n-            let count_non_legacy = sig.params().len();\n-            let count_legacy = sig.params().len() + sig.legacy_const_generics_indices.len();\n-            if arg_count != count_non_legacy && arg_count != count_legacy {\n-                self.diagnostics.push(BodyValidationDiagnostic::MismatchedArgCount {\n-                    call_expr: call_id,\n-                    // Since most users will use the legacy way to call them, report against that.\n-                    expected: count_legacy,\n-                    found: arg_count,\n-                });\n-            }\n-        }\n     }\n \n     fn validate_match("}, {"sha": "71e81b43485755af3cb74c43ffdd72618bfef020", "filename": "crates/hir_ty/src/infer.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/2be7e26d7dfad29756f6ff57e0ff7a8ce52171da/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2be7e26d7dfad29756f6ff57e0ff7a8ce52171da/crates%2Fhir_ty%2Fsrc%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer.rs?ref=2be7e26d7dfad29756f6ff57e0ff7a8ce52171da", "patch": "@@ -143,6 +143,7 @@ pub(crate) type InferResult<T> = Result<InferOk<T>, TypeError>;\n pub enum InferenceDiagnostic {\n     NoSuchField { expr: ExprId },\n     BreakOutsideOfLoop { expr: ExprId },\n+    MismatchedArgCount { call_expr: ExprId, expected: usize, found: usize },\n }\n \n /// A mismatch between an expected and an inferred type."}, {"sha": "238aff75c45ed8ad780baf5425f0b3b449aa4f1b", "filename": "crates/hir_ty/src/infer/expr.rs", "status": "modified", "additions": 49, "deletions": 13, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/2be7e26d7dfad29756f6ff57e0ff7a8ce52171da/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2be7e26d7dfad29756f6ff57e0ff7a8ce52171da/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Fexpr.rs?ref=2be7e26d7dfad29756f6ff57e0ff7a8ce52171da", "patch": "@@ -296,13 +296,18 @@ impl<'a> InferenceContext<'a> {\n                         break;\n                     }\n                 }\n+                // if the function is unresolved, we use is_varargs=true to\n+                // suppress the arg count diagnostic here\n+                let is_varargs =\n+                    derefed_callee.callable_sig(self.db).map_or(false, |sig| sig.is_varargs)\n+                        || res.is_none();\n                 let (param_tys, ret_ty) = match res {\n                     Some(res) => {\n                         let adjustments = auto_deref_adjust_steps(&derefs);\n                         self.write_expr_adj(*callee, adjustments);\n                         res\n                     }\n-                    None => (Vec::new(), self.err_ty()),\n+                    None => (Vec::new(), self.err_ty()), // FIXME diagnostic\n                 };\n                 let indices_to_skip = self.check_legacy_const_generics(derefed_callee, args);\n                 self.register_obligations_for_call(&callee_ty);\n@@ -313,7 +318,14 @@ impl<'a> InferenceContext<'a> {\n                     param_tys.clone(),\n                 );\n \n-                self.check_call_arguments(args, &expected_inputs, &param_tys, &indices_to_skip);\n+                self.check_call_arguments(\n+                    tgt_expr,\n+                    args,\n+                    &expected_inputs,\n+                    &param_tys,\n+                    &indices_to_skip,\n+                    is_varargs,\n+                );\n                 self.normalize_associated_types_in(ret_ty)\n             }\n             Expr::MethodCall { receiver, args, method_name, generic_args } => self\n@@ -948,22 +960,28 @@ impl<'a> InferenceContext<'a> {\n         };\n         let method_ty = method_ty.substitute(Interner, &substs);\n         self.register_obligations_for_call(&method_ty);\n-        let (formal_receiver_ty, param_tys, ret_ty) = match method_ty.callable_sig(self.db) {\n-            Some(sig) => {\n-                if !sig.params().is_empty() {\n-                    (sig.params()[0].clone(), sig.params()[1..].to_vec(), sig.ret().clone())\n-                } else {\n-                    (self.err_ty(), Vec::new(), sig.ret().clone())\n+        let (formal_receiver_ty, param_tys, ret_ty, is_varargs) =\n+            match method_ty.callable_sig(self.db) {\n+                Some(sig) => {\n+                    if !sig.params().is_empty() {\n+                        (\n+                            sig.params()[0].clone(),\n+                            sig.params()[1..].to_vec(),\n+                            sig.ret().clone(),\n+                            sig.is_varargs,\n+                        )\n+                    } else {\n+                        (self.err_ty(), Vec::new(), sig.ret().clone(), sig.is_varargs)\n+                    }\n                 }\n-            }\n-            None => (self.err_ty(), Vec::new(), self.err_ty()),\n-        };\n+                None => (self.err_ty(), Vec::new(), self.err_ty(), true),\n+            };\n         self.unify(&formal_receiver_ty, &receiver_ty);\n \n         let expected_inputs =\n             self.expected_inputs_for_expected_output(expected, ret_ty.clone(), param_tys.clone());\n \n-        self.check_call_arguments(args, &expected_inputs, &param_tys, &[]);\n+        self.check_call_arguments(tgt_expr, args, &expected_inputs, &param_tys, &[], is_varargs);\n         self.normalize_associated_types_in(ret_ty)\n     }\n \n@@ -996,11 +1014,21 @@ impl<'a> InferenceContext<'a> {\n \n     fn check_call_arguments(\n         &mut self,\n+        expr: ExprId,\n         args: &[ExprId],\n         expected_inputs: &[Ty],\n         param_tys: &[Ty],\n         skip_indices: &[u32],\n+        is_varargs: bool,\n     ) {\n+        if args.len() != param_tys.len() + skip_indices.len() && !is_varargs {\n+            self.push_diagnostic(InferenceDiagnostic::MismatchedArgCount {\n+                call_expr: expr,\n+                expected: param_tys.len() + skip_indices.len(),\n+                found: args.len(),\n+            });\n+        }\n+\n         // Quoting https://github.com/rust-lang/rust/blob/6ef275e6c3cb1384ec78128eceeb4963ff788dca/src/librustc_typeck/check/mod.rs#L3325 --\n         // We do this in a pretty awful way: first we type-check any arguments\n         // that are not closures, then we type-check the closures. This is so\n@@ -1188,7 +1216,15 @@ impl<'a> InferenceContext<'a> {\n \n         // only use legacy const generics if the param count matches with them\n         if data.params.len() + data.legacy_const_generics_indices.len() != args.len() {\n-            return Vec::new();\n+            if args.len() <= data.params.len() {\n+                return Vec::new();\n+            } else {\n+                // there are more parameters than there should be without legacy\n+                // const params; use them\n+                let mut indices = data.legacy_const_generics_indices.clone();\n+                indices.sort();\n+                return indices;\n+            }\n         }\n \n         // check legacy const parameters"}]}