{"sha": "d283574558b98b659997fd7bc97028158297388c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQyODM1NzQ1NThiOThiNjU5OTk3ZmQ3YmM5NzAyODE1ODI5NzM4OGM=", "commit": {"author": {"name": "Jakub Wieczorek", "email": "jakub@jakub.cc", "date": "2014-08-17T20:10:25Z"}, "committer": {"name": "Jakub Wieczorek", "email": "jakub@jakub.cc", "date": "2014-08-17T22:08:57Z"}, "message": "Forbid extern statics from appearing in patterns\n\nFixes #16149.", "tree": {"sha": "26daf5ada3b0df480cc970008b609568e204ed53", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/26daf5ada3b0df480cc970008b609568e204ed53"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d283574558b98b659997fd7bc97028158297388c", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d283574558b98b659997fd7bc97028158297388c", "html_url": "https://github.com/rust-lang/rust/commit/d283574558b98b659997fd7bc97028158297388c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d283574558b98b659997fd7bc97028158297388c/comments", "author": null, "committer": null, "parents": [{"sha": "a12a4ddcfabb80d6224960f19d6043f88f47d1e6", "url": "https://api.github.com/repos/rust-lang/rust/commits/a12a4ddcfabb80d6224960f19d6043f88f47d1e6", "html_url": "https://github.com/rust-lang/rust/commit/a12a4ddcfabb80d6224960f19d6043f88f47d1e6"}], "stats": {"total": 137, "additions": 90, "deletions": 47}, "files": [{"sha": "a789049d4de8c08cd5a276845aeef66c674b0d6f", "filename": "src/librustc/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d283574558b98b659997fd7bc97028158297388c/src%2Flibrustc%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d283574558b98b659997fd7bc97028158297388c/src%2Flibrustc%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fdiagnostics.rs?ref=d283574558b98b659997fd7bc97028158297388c", "patch": "@@ -139,7 +139,6 @@ register_diagnostics!(\n     E0120,\n     E0121,\n     E0122,\n-    E0123,\n     E0124,\n     E0125,\n     E0126,\n@@ -173,5 +172,6 @@ register_diagnostics!(\n     E0154,\n     E0155,\n     E0156,\n-    E0157\n+    E0157,\n+    E0158\n )"}, {"sha": "230668e70665382dc1c5ac958e44f56361268ca4", "filename": "src/librustc/middle/check_match.rs", "status": "modified", "additions": 65, "deletions": 29, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/d283574558b98b659997fd7bc97028158297388c/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d283574558b98b659997fd7bc97028158297388c/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcheck_match.rs?ref=d283574558b98b659997fd7bc97028158297388c", "patch": "@@ -23,7 +23,7 @@ use std::gc::{Gc, GC};\n use std::iter::AdditiveIterator;\n use std::iter::range_inclusive;\n use syntax::ast::*;\n-use syntax::ast_util::{is_unguarded, walk_pat};\n+use syntax::ast_util::walk_pat;\n use syntax::codemap::{Span, Spanned, DUMMY_SP};\n use syntax::fold::{Folder, noop_fold_pat};\n use syntax::print::pprust::pat_to_string;\n@@ -159,13 +159,31 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &Expr) {\n                 }\n             }\n \n-            // Third, check for unreachable arms.\n-            check_arms(cx, arms.as_slice());\n+            let mut static_inliner = StaticInliner::new(cx.tcx);\n+            let inlined_arms = arms\n+                .iter()\n+                .map(|arm| Arm {\n+                    pats: arm.pats.iter().map(|pat| {\n+                        static_inliner.fold_pat(*pat)\n+                    }).collect(),\n+                    ..arm.clone()\n+                })\n+                .collect::<Vec<Arm>>();\n+\n+            if static_inliner.failed {\n+                return;\n+            }\n+\n+            // Third, check if there are any references to NaN that we should warn about.\n+            check_for_static_nan(cx, inlined_arms.as_slice());\n+\n+            // Fourth, check for unreachable arms.\n+            check_arms(cx, inlined_arms.as_slice());\n \n             // Finally, check if the whole match expression is exhaustive.\n             // Check for empty enum, because is_useful only works on inhabited types.\n             let pat_ty = node_id_to_type(cx.tcx, scrut.id);\n-            if arms.is_empty() {\n+            if inlined_arms.is_empty() {\n                 if !type_is_empty(cx.tcx, pat_ty) {\n                     // We know the type is inhabited, so this must be wrong\n                     span_err!(cx.tcx.sess, ex.span, E0002,\n@@ -177,19 +195,16 @@ fn check_expr(cx: &mut MatchCheckCtxt, ex: &Expr) {\n                 return;\n             }\n \n-            let mut static_inliner = StaticInliner { tcx: cx.tcx };\n-            let matrix: Matrix = arms\n-                .iter()\n-                .filter(|&arm| is_unguarded(arm))\n-                .flat_map(|arm| arm.pats.iter())\n-                .map(|pat| vec![static_inliner.fold_pat(*pat)])\n+            let matrix: Matrix = inlined_arms\n+                .move_iter()\n+                .filter(|arm| arm.guard.is_none())\n+                .flat_map(|arm| arm.pats.move_iter())\n+                .map(|pat| vec![pat])\n                 .collect();\n             check_exhaustive(cx, ex.span, &matrix);\n         },\n         ExprForLoop(ref pat, _, _, _) => {\n-            let mut static_inliner = StaticInliner {\n-                tcx: cx.tcx\n-            };\n+            let mut static_inliner = StaticInliner::new(cx.tcx);\n             match is_refutable(cx, static_inliner.fold_pat(*pat)) {\n                 Some(uncovered_pat) => {\n                     cx.tcx.sess.span_err(\n@@ -216,28 +231,31 @@ fn is_expr_const_nan(tcx: &ty::ctxt, expr: &Expr) -> bool {\n     }\n }\n \n-// Check for unreachable patterns\n-fn check_arms(cx: &MatchCheckCtxt, arms: &[Arm]) {\n-    let mut seen = Matrix(vec!());\n-    let mut static_inliner = StaticInliner { tcx: cx.tcx };\n+// Check that we do not match against a static NaN (#6804)\n+fn check_for_static_nan(cx: &MatchCheckCtxt, arms: &[Arm]) {\n     for arm in arms.iter() {\n-        for pat in arm.pats.iter() {\n-            let inlined = static_inliner.fold_pat(*pat);\n-\n-            // Check that we do not match against a static NaN (#6804)\n-            walk_pat(&*inlined, |p| {\n+        for &pat in arm.pats.iter() {\n+            walk_pat(&*pat, |p| {\n                 match p.node {\n                     PatLit(expr) if is_expr_const_nan(cx.tcx, &*expr) => {\n-                        span_warn!(cx.tcx.sess, pat.span, E0003,\n+                        span_warn!(cx.tcx.sess, p.span, E0003,\n                             \"unmatchable NaN in pattern, \\\n                              use the is_nan method in a guard instead\");\n                     }\n                     _ => ()\n                 }\n                 true\n             });\n+        }\n+    }\n+}\n \n-            let v = vec![inlined];\n+// Check for unreachable patterns\n+fn check_arms(cx: &MatchCheckCtxt, arms: &[Arm]) {\n+    let mut seen = Matrix(vec!());\n+    for arm in arms.iter() {\n+        for &pat in arm.pats.iter() {\n+            let v = vec![pat];\n             match is_useful(cx, &seen, v.as_slice(), LeaveOutWitness) {\n                 NotUseful => span_err!(cx.tcx.sess, pat.span, E0001, \"unreachable pattern\"),\n                 Useful => (),\n@@ -293,7 +311,17 @@ fn const_val_to_expr(value: &const_val) -> Gc<Expr> {\n }\n \n pub struct StaticInliner<'a> {\n-    pub tcx: &'a ty::ctxt\n+    pub tcx: &'a ty::ctxt,\n+    pub failed: bool\n+}\n+\n+impl<'a> StaticInliner<'a> {\n+    pub fn new<'a>(tcx: &'a ty::ctxt) -> StaticInliner<'a> {\n+        StaticInliner {\n+            tcx: tcx,\n+            failed: false\n+        }\n+    }\n }\n \n impl<'a> Folder for StaticInliner<'a> {\n@@ -302,9 +330,17 @@ impl<'a> Folder for StaticInliner<'a> {\n             PatIdent(..) | PatEnum(..) => {\n                 let def = self.tcx.def_map.borrow().find_copy(&pat.id);\n                 match def {\n-                    Some(DefStatic(did, _)) => {\n-                        let const_expr = lookup_const_by_id(self.tcx, did).unwrap();\n-                        const_expr_to_pat(self.tcx, const_expr)\n+                    Some(DefStatic(did, _)) => match lookup_const_by_id(self.tcx, did) {\n+                        Some(const_expr) => box (GC) Pat {\n+                            span: pat.span,\n+                            ..(*const_expr_to_pat(self.tcx, const_expr)).clone()\n+                        },\n+                        None => {\n+                            self.failed = true;\n+                            span_err!(self.tcx.sess, pat.span, E0158,\n+                                \"extern statics cannot be referenced in patterns\");\n+                            pat\n+                        }\n                     },\n                     _ => noop_fold_pat(pat, self)\n                 }\n@@ -813,7 +849,7 @@ fn check_local(cx: &mut MatchCheckCtxt, loc: &Local) {\n         LocalFor => \"`for` loop\"\n     };\n \n-    let mut static_inliner = StaticInliner { tcx: cx.tcx };\n+    let mut static_inliner = StaticInliner::new(cx.tcx);\n     match is_refutable(cx, static_inliner.fold_pat(loc.pat)) {\n         Some(pat) => {\n             span_err!(cx.tcx.sess, loc.pat.span, E0005,"}, {"sha": "7219c234779ba17fd3e5d5733b16f90e052f3271", "filename": "src/librustc/middle/trans/_match.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d283574558b98b659997fd7bc97028158297388c/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d283574558b98b659997fd7bc97028158297388c/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2F_match.rs?ref=d283574558b98b659997fd7bc97028158297388c", "patch": "@@ -1422,7 +1422,7 @@ fn trans_match_inner<'a>(scope_cx: &'a Block<'a>,\n         bindings_map: create_bindings_map(bcx, *arm.pats.get(0), discr_expr, &*arm.body)\n     }).collect();\n \n-    let mut static_inliner = StaticInliner { tcx: scope_cx.tcx() };\n+    let mut static_inliner = StaticInliner::new(scope_cx.tcx());\n     let mut matches = Vec::new();\n     for arm_data in arm_datas.iter() {\n         matches.extend(arm_data.arm.pats.iter().map(|&p| Match {"}, {"sha": "1a4b41404be01d39f9a194cc8cb4838f9d4bd87c", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/d283574558b98b659997fd7bc97028158297388c/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d283574558b98b659997fd7bc97028158297388c/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=d283574558b98b659997fd7bc97028158297388c", "patch": "@@ -209,21 +209,6 @@ pub fn name_to_dummy_lifetime(name: Name) -> Lifetime {\n                name: name }\n }\n \n-pub fn is_unguarded(a: &Arm) -> bool {\n-    match a.guard {\n-      None => true,\n-      _    => false\n-    }\n-}\n-\n-pub fn unguarded_pat(a: &Arm) -> Option<Vec<Gc<Pat>>> {\n-    if is_unguarded(a) {\n-        Some(/* FIXME (#2543) */ a.pats.clone())\n-    } else {\n-        None\n-    }\n-}\n-\n /// Generate a \"pretty\" name for an `impl` from its type and trait.\n /// This is designed so that symbols of `impl`'d methods give some\n /// hint of where they came from, (previously they would all just be"}, {"sha": "c52c53ec2e9ca8175cb740849dcb6ecd1f399edd", "filename": "src/test/compile-fail/issue-16149.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d283574558b98b659997fd7bc97028158297388c/src%2Ftest%2Fcompile-fail%2Fissue-16149.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d283574558b98b659997fd7bc97028158297388c/src%2Ftest%2Fcompile-fail%2Fissue-16149.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-16149.rs?ref=d283574558b98b659997fd7bc97028158297388c", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2014 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+extern {\n+    static externalValue: int;\n+}\n+\n+fn main() {\n+    let boolValue = match 42 {\n+        externalValue => true,\n+        //~^ ERROR extern statics cannot be referenced in patterns\n+        _ => false\n+    };\n+}\n+"}]}