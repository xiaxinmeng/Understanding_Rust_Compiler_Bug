{"sha": "035233a25907af8206d254878e7e04048fcac95e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAzNTIzM2EyNTkwN2FmODIwNmQyNTQ4NzhlN2UwNDA0OGZjYWM5NWU=", "commit": {"author": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-03-02T18:27:29Z"}, "committer": {"name": "Daniel Micay", "email": "danielmicay@gmail.com", "date": "2013-03-02T19:10:19Z"}, "message": "treemap: reimplement using TotalOrd", "tree": {"sha": "4b00e00aa404e3f047f1848e36d06ee70032bfef", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4b00e00aa404e3f047f1848e36d06ee70032bfef"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/035233a25907af8206d254878e7e04048fcac95e", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/035233a25907af8206d254878e7e04048fcac95e", "html_url": "https://github.com/rust-lang/rust/commit/035233a25907af8206d254878e7e04048fcac95e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/035233a25907af8206d254878e7e04048fcac95e/comments", "author": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "committer": {"login": "thestinger", "id": 1505226, "node_id": "MDQ6VXNlcjE1MDUyMjY=", "avatar_url": "https://avatars.githubusercontent.com/u/1505226?v=4", "gravatar_id": "", "url": "https://api.github.com/users/thestinger", "html_url": "https://github.com/thestinger", "followers_url": "https://api.github.com/users/thestinger/followers", "following_url": "https://api.github.com/users/thestinger/following{/other_user}", "gists_url": "https://api.github.com/users/thestinger/gists{/gist_id}", "starred_url": "https://api.github.com/users/thestinger/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/thestinger/subscriptions", "organizations_url": "https://api.github.com/users/thestinger/orgs", "repos_url": "https://api.github.com/users/thestinger/repos", "events_url": "https://api.github.com/users/thestinger/events{/privacy}", "received_events_url": "https://api.github.com/users/thestinger/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ca1ceb15b1f80d687525f166d99adb1c37b6081d", "url": "https://api.github.com/repos/rust-lang/rust/commits/ca1ceb15b1f80d687525f166d99adb1c37b6081d", "html_url": "https://github.com/rust-lang/rust/commit/ca1ceb15b1f80d687525f166d99adb1c37b6081d"}], "stats": {"total": 169, "additions": 87, "deletions": 82}, "files": [{"sha": "186253761fafecb88d62b9425ef35afd4cac4d96", "filename": "src/libcore/prelude.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/035233a25907af8206d254878e7e04048fcac95e/src%2Flibcore%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/035233a25907af8206d254878e7e04048fcac95e/src%2Flibcore%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude.rs?ref=035233a25907af8206d254878e7e04048fcac95e", "patch": "@@ -27,7 +27,7 @@ pub use clone::Clone;\n pub use cmp::{Eq, Ord, TotalOrd, Ordering, Less, Equal, Greater};\n pub use container::{Container, Mutable, Map, Set};\n pub use hash::Hash;\n-pub use iter::{BaseIter, ExtendedIter, EqIter, CopyableIter};\n+pub use iter::{BaseIter, ReverseIter, ExtendedIter, EqIter, CopyableIter};\n pub use iter::{CopyableOrderedIter, CopyableNonstrictIter, Times};\n pub use num::NumCast;\n pub use path::GenericPath;"}, {"sha": "a093351c4a76387e9674ad28268e9b878e59c02a", "filename": "src/libstd/treemap.rs", "status": "modified", "additions": 86, "deletions": 81, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/035233a25907af8206d254878e7e04048fcac95e/src%2Flibstd%2Ftreemap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/035233a25907af8206d254878e7e04048fcac95e/src%2Flibstd%2Ftreemap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ftreemap.rs?ref=035233a25907af8206d254878e7e04048fcac95e", "patch": "@@ -10,12 +10,8 @@\n \n //! An ordered map and set implemented as self-balancing binary search\n //! trees. The only requirement for the types is that the key implements\n-//! `Ord`, and that the `lt` method provides a total ordering.\n+//! `TotalOrd`.\n \n-use core::container::{Container, Mutable, Map, Set};\n-use core::cmp::{Eq, Ord};\n-use core::iter::{BaseIter, ReverseIter};\n-use core::option::{Option, Some, None};\n use core::prelude::*;\n \n // This is implemented as an AA tree, which is a simplified variation of\n@@ -39,7 +35,7 @@ pub struct TreeMap<K, V> {\n     priv length: uint\n }\n \n-impl<K:Eq + Ord,V:Eq> Eq for TreeMap<K, V> {\n+impl<K: Eq + TotalOrd, V: Eq> Eq for TreeMap<K, V> {\n     pure fn eq(&self, other: &TreeMap<K, V>) -> bool {\n         if self.len() != other.len() {\n             false\n@@ -61,7 +57,8 @@ impl<K:Eq + Ord,V:Eq> Eq for TreeMap<K, V> {\n }\n \n // Lexicographical comparison\n-pure fn lt<K:Ord,V>(a: &TreeMap<K, V>, b: &TreeMap<K, V>) -> bool {\n+pure fn lt<K: Ord + TotalOrd, V>(a: &TreeMap<K, V>,\n+                                 b: &TreeMap<K, V>) -> bool {\n     let mut x = a.iter();\n     let mut y = b.iter();\n \n@@ -78,7 +75,7 @@ pure fn lt<K:Ord,V>(a: &TreeMap<K, V>, b: &TreeMap<K, V>) -> bool {\n     return a_len < b_len;\n }\n \n-impl<K:Ord,V> Ord for TreeMap<K, V> {\n+impl<K: Ord + TotalOrd, V> Ord for TreeMap<K, V> {\n     #[inline(always)]\n     pure fn lt(&self, other: &TreeMap<K, V>) -> bool {\n         lt(self, other)\n@@ -97,38 +94,38 @@ impl<K:Ord,V> Ord for TreeMap<K, V> {\n     }\n }\n \n-impl<K:Ord,V> BaseIter<(&K, &V)> for TreeMap<K, V> {\n+impl<K: TotalOrd, V> BaseIter<(&K, &V)> for TreeMap<K, V> {\n     /// Visit all key-value pairs in order\n     pure fn each(&self, f: fn(&(&self/K, &self/V)) -> bool) {\n         each(&self.root, f)\n     }\n     pure fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n }\n \n-impl<K:Ord,V> ReverseIter<(&K, &V)> for TreeMap<K, V> {\n+impl<K: TotalOrd, V> ReverseIter<(&K, &V)> for TreeMap<K, V> {\n     /// Visit all key-value pairs in reverse order\n     pure fn each_reverse(&self, f: fn(&(&self/K, &self/V)) -> bool) {\n         each_reverse(&self.root, f);\n     }\n }\n \n-impl<K:Ord,V> Container for TreeMap<K, V> {\n+impl<K: TotalOrd, V> Container for TreeMap<K, V> {\n     /// Return the number of elements in the map\n     pure fn len(&self) -> uint { self.length }\n \n     /// Return true if the map contains no elements\n     pure fn is_empty(&self) -> bool { self.root.is_none() }\n }\n \n-impl<K:Ord,V> Mutable for TreeMap<K, V> {\n+impl<K: TotalOrd, V> Mutable for TreeMap<K, V> {\n     /// Clear the map, removing all key-value pairs.\n     fn clear(&mut self) {\n         self.root = None;\n         self.length = 0\n     }\n }\n \n-impl<K:Ord,V> Map<K, V> for TreeMap<K, V> {\n+impl<K: TotalOrd, V> Map<K, V> for TreeMap<K, V> {\n     /// Return true if the map contains a value for the specified key\n     pure fn contains_key(&self, key: &K) -> bool {\n         self.find(key).is_some()\n@@ -146,12 +143,10 @@ impl<K:Ord,V> Map<K, V> for TreeMap<K, V> {\n         loop {\n             match *current {\n               Some(ref r) => {\n-                if *key < r.key {\n-                    current = &r.left;\n-                } else if r.key < *key {\n-                    current = &r.right;\n-                } else {\n-                    return Some(&r.value);\n+                match key.cmp(&r.key) {\n+                   Less => current = &r.left,\n+                   Greater => current = &r.right,\n+                   Equal => return Some(&r.value)\n                 }\n               }\n               None => return None\n@@ -177,7 +172,7 @@ impl<K:Ord,V> Map<K, V> for TreeMap<K, V> {\n     }\n }\n \n-pub impl <K:Ord,V> TreeMap<K, V> {\n+pub impl<K: TotalOrd, V> TreeMap<K, V> {\n     /// Create an empty TreeMap\n     static pure fn new() -> TreeMap<K, V> { TreeMap{root: None, length: 0} }\n \n@@ -207,7 +202,7 @@ pub struct TreeMapIterator<K, V> {\n /// Advance the iterator to the next node (in order) and return a\n /// tuple with a reference to the key and value. If there are no\n /// more nodes, return `None`.\n-pub fn map_next<K: Ord, V>(iter: &mut TreeMapIterator/&r<K, V>)\n+pub fn map_next<K, V>(iter: &mut TreeMapIterator/&r<K, V>)\n                         -> Option<(&r/K, &r/V)> {\n     while !iter.stack.is_empty() || iter.node.is_some() {\n         match *iter.node {\n@@ -226,8 +221,8 @@ pub fn map_next<K: Ord, V>(iter: &mut TreeMapIterator/&r<K, V>)\n }\n \n /// Advance the iterator through the map\n-pub fn map_advance<K: Ord, V>(iter: &mut TreeMapIterator/&r<K, V>,\n-                          f: fn((&r/K, &r/V)) -> bool) {\n+pub fn map_advance<K, V>(iter: &mut TreeMapIterator/&r<K, V>,\n+                         f: fn((&r/K, &r/V)) -> bool) {\n     loop {\n         match map_next(iter) {\n           Some(x) => {\n@@ -242,25 +237,25 @@ pub struct TreeSet<T> {\n     priv map: TreeMap<T, ()>\n }\n \n-impl<T:Ord> BaseIter<T> for TreeSet<T> {\n+impl<T: TotalOrd> BaseIter<T> for TreeSet<T> {\n     /// Visit all values in order\n     pure fn each(&self, f: fn(&T) -> bool) { self.map.each_key(f) }\n     pure fn size_hint(&self) -> Option<uint> { Some(self.len()) }\n }\n \n-impl<T:Ord> ReverseIter<T> for TreeSet<T> {\n+impl<T: TotalOrd> ReverseIter<T> for TreeSet<T> {\n     /// Visit all values in reverse order\n     pure fn each_reverse(&self, f: fn(&T) -> bool) {\n         self.map.each_key_reverse(f)\n     }\n }\n \n-impl<T:Eq + Ord> Eq for TreeSet<T> {\n+impl<T: Eq + TotalOrd> Eq for TreeSet<T> {\n     pure fn eq(&self, other: &TreeSet<T>) -> bool { self.map == other.map }\n     pure fn ne(&self, other: &TreeSet<T>) -> bool { self.map != other.map }\n }\n \n-impl<T:Ord> Ord for TreeSet<T> {\n+impl<T: Ord + TotalOrd> Ord for TreeSet<T> {\n     #[inline(always)]\n     pure fn lt(&self, other: &TreeSet<T>) -> bool { self.map < other.map }\n     #[inline(always)]\n@@ -271,20 +266,20 @@ impl<T:Ord> Ord for TreeSet<T> {\n     pure fn gt(&self, other: &TreeSet<T>) -> bool { self.map > other.map }\n }\n \n-impl<T:Ord> Container for TreeSet<T> {\n+impl<T: TotalOrd> Container for TreeSet<T> {\n     /// Return the number of elements in the set\n     pure fn len(&self) -> uint { self.map.len() }\n \n     /// Return true if the set contains no elements\n     pure fn is_empty(&self) -> bool { self.map.is_empty() }\n }\n \n-impl<T:Ord> Mutable for TreeSet<T> {\n+impl<T: TotalOrd> Mutable for TreeSet<T> {\n     /// Clear the set, removing all values.\n     fn clear(&mut self) { self.map.clear() }\n }\n \n-impl<T:Ord> Set<T> for TreeSet<T> {\n+impl<T: TotalOrd> Set<T> for TreeSet<T> {\n     /// Return true if the set contains a value\n     pure fn contains(&self, value: &T) -> bool {\n         self.map.contains_key(value)\n@@ -309,12 +304,10 @@ impl<T:Ord> Set<T> for TreeSet<T> {\n             while a.is_some() && b.is_some() {\n                 let a1 = a.unwrap();\n                 let b1 = b.unwrap();\n-                if a1 < b1 {\n-                    a = set_next(&mut x);\n-                } else if b1 < a1 {\n-                    b = set_next(&mut y);\n-                } else {\n-                    return false;\n+                match a1.cmp(b1) {\n+                  Less => a = set_next(&mut x),\n+                  Greater => b = set_next(&mut y),\n+                  Equal => return false\n                 }\n             }\n         }\n@@ -341,13 +334,12 @@ impl<T:Ord> Set<T> for TreeSet<T> {\n                 let a1 = a.unwrap();\n                 let b1 = b.unwrap();\n \n-                if b1 < a1 {\n-                    return false\n+                match a1.cmp(b1) {\n+                  Less => (),\n+                  Greater => return false,\n+                  Equal => b = set_next(&mut y),\n                 }\n \n-                if !(a1 < b1) {\n-                    b = set_next(&mut y);\n-                }\n                 a = set_next(&mut x);\n             }\n         }\n@@ -373,11 +365,13 @@ impl<T:Ord> Set<T> for TreeSet<T> {\n                 let a1 = a.unwrap();\n                 let b1 = b.unwrap();\n \n-                if a1 < b1 {\n+                let cmp = a1.cmp(b1);\n+\n+                if cmp == Less {\n                     if !f(a1) { return }\n                     a = set_next(&mut x);\n                 } else {\n-                    if !(b1 < a1) { a = set_next(&mut x) }\n+                    if cmp == Equal { a = set_next(&mut x) }\n                     b = set_next(&mut y);\n                 }\n             }\n@@ -404,11 +398,13 @@ impl<T:Ord> Set<T> for TreeSet<T> {\n                 let a1 = a.unwrap();\n                 let b1 = b.unwrap();\n \n-                if a1 < b1 {\n+                let cmp = a1.cmp(b1);\n+\n+                if cmp == Less {\n                     if !f(a1) { return }\n                     a = set_next(&mut x);\n                 } else {\n-                    if b1 < a1 {\n+                    if cmp == Greater {\n                         if !f(b1) { return }\n                     } else {\n                         a = set_next(&mut x);\n@@ -434,10 +430,13 @@ impl<T:Ord> Set<T> for TreeSet<T> {\n             while a.is_some() && b.is_some() {\n                 let a1 = a.unwrap();\n                 let b1 = b.unwrap();\n-                if a1 < b1 {\n+\n+                let cmp = a1.cmp(b1);\n+\n+                if cmp == Less {\n                     a = set_next(&mut x);\n                 } else {\n-                    if !(b1 < a1) {\n+                    if cmp == Equal {\n                         if !f(a1) { return }\n                     }\n                     b = set_next(&mut y);\n@@ -465,12 +464,14 @@ impl<T:Ord> Set<T> for TreeSet<T> {\n                 let a1 = a.unwrap();\n                 let b1 = b.unwrap();\n \n-                if b1 < a1 {\n+                let cmp = a1.cmp(b1);\n+\n+                if cmp == Greater {\n                     if !f(b1) { return }\n                     b = set_next(&mut y);\n                 } else {\n                     if !f(a1) { return }\n-                    if !(a1 < b1) {\n+                    if cmp == Equal {\n                         b = set_next(&mut y);\n                     }\n                     a = set_next(&mut x);\n@@ -480,7 +481,7 @@ impl<T:Ord> Set<T> for TreeSet<T> {\n     }\n }\n \n-pub impl <T:Ord> TreeSet<T> {\n+pub impl <T: TotalOrd> TreeSet<T> {\n     /// Create an empty TreeSet\n     static pure fn new() -> TreeSet<T> { TreeSet{map: TreeMap::new()} }\n \n@@ -498,12 +499,12 @@ pub struct TreeSetIterator<T> {\n \n /// Advance the iterator to the next node (in order). If this iterator is\n /// finished, does nothing.\n-pub fn set_next<T: Ord>(iter: &mut TreeSetIterator/&r<T>) -> Option<&r/T> {\n+pub fn set_next<T>(iter: &mut TreeSetIterator/&r<T>) -> Option<&r/T> {\n     do map_next(&mut iter.iter).map |&(value, _)| { value }\n }\n \n /// Advance the iterator through the set\n-fn set_advance<T: Ord>(iter: &mut TreeSetIterator/&r<T>,\n+fn set_advance<T>(iter: &mut TreeSetIterator/&r<T>,\n                        f: fn(&r/T) -> bool) {\n     do map_advance(&mut iter.iter) |(k, _)| { f(k) }\n }\n@@ -518,22 +519,22 @@ struct TreeNode<K, V> {\n     level: uint\n }\n \n-pub impl <K:Ord,V> TreeNode<K, V> {\n+pub impl<K: TotalOrd, V> TreeNode<K, V> {\n     #[inline(always)]\n     static pure fn new(key: K, value: V) -> TreeNode<K, V> {\n         TreeNode{key: key, value: value, left: None, right: None, level: 1}\n     }\n }\n \n-pure fn each<K:Ord,V>(node: &r/Option<~TreeNode<K, V>>,\n+pure fn each<K: TotalOrd, V>(node: &r/Option<~TreeNode<K, V>>,\n                         f: fn(&(&r/K, &r/V)) -> bool) {\n     do node.iter |x| {\n         each(&x.left, f);\n         if f(&(&x.key, &x.value)) { each(&x.right, f) }\n     }\n }\n \n-pure fn each_reverse<K:Ord,V>(node: &r/Option<~TreeNode<K, V>>,\n+pure fn each_reverse<K: TotalOrd, V>(node: &r/Option<~TreeNode<K, V>>,\n                                 f: fn(&(&r/K, &r/V)) -> bool) {\n     do node.iter |x| {\n         each_reverse(&x.right, f);\n@@ -542,7 +543,7 @@ pure fn each_reverse<K:Ord,V>(node: &r/Option<~TreeNode<K, V>>,\n }\n \n // Remove left horizontal link by rotating right\n-fn skew<K:Ord,V>(node: &mut ~TreeNode<K, V>) {\n+fn skew<K: TotalOrd, V>(node: &mut ~TreeNode<K, V>) {\n     if node.left.map_default(false, |x| x.level == node.level) {\n         let mut save = node.left.swap_unwrap();\n         node.left <-> save.right; // save.right now None\n@@ -553,7 +554,7 @@ fn skew<K:Ord,V>(node: &mut ~TreeNode<K, V>) {\n \n // Remove dual horizontal link by rotating left and increasing level of\n // the parent\n-fn split<K:Ord,V>(node: &mut ~TreeNode<K, V>) {\n+fn split<K: TotalOrd, V>(node: &mut ~TreeNode<K, V>) {\n     if node.right.map_default(false,\n       |x| x.right.map_default(false, |y| y.level == node.level)) {\n         let mut save = node.right.swap_unwrap();\n@@ -564,24 +565,28 @@ fn split<K:Ord,V>(node: &mut ~TreeNode<K, V>) {\n     }\n }\n \n-fn insert<K:Ord,V>(node: &mut Option<~TreeNode<K, V>>, key: K,\n-                     value: V) -> bool {\n+fn insert<K: TotalOrd, V>(node: &mut Option<~TreeNode<K, V>>, key: K,\n+                          value: V) -> bool {\n     match *node {\n       Some(ref mut save) => {\n-        if key < save.key {\n+        match key.cmp(&save.key) {\n+          Less => {\n             let inserted = insert(&mut save.left, key, value);\n             skew(save);\n             split(save);\n             inserted\n-        } else if save.key < key {\n+          }\n+          Greater => {\n             let inserted = insert(&mut save.right, key, value);\n             skew(save);\n             split(save);\n             inserted\n-        } else {\n+          }\n+          Equal => {\n             save.key = key;\n             save.value = value;\n             false\n+          }\n         }\n       }\n       None => {\n@@ -591,8 +596,9 @@ fn insert<K:Ord,V>(node: &mut Option<~TreeNode<K, V>>, key: K,\n     }\n }\n \n-fn remove<K:Ord,V>(node: &mut Option<~TreeNode<K, V>>, key: &K) -> bool {\n-    fn heir_swap<K:Ord,V>(node: &mut ~TreeNode<K, V>,\n+fn remove<K: TotalOrd, V>(node: &mut Option<~TreeNode<K, V>>,\n+                          key: &K) -> bool {\n+    fn heir_swap<K: TotalOrd, V>(node: &mut ~TreeNode<K, V>,\n                             child: &mut Option<~TreeNode<K, V>>) {\n         // *could* be done without recursion, but it won't borrow check\n         do child.mutate |mut child| {\n@@ -611,11 +617,10 @@ fn remove<K:Ord,V>(node: &mut Option<~TreeNode<K, V>>, key: &K) -> bool {\n         return false // bottom of tree\n       }\n       Some(ref mut save) => {\n-        let (removed, this) = if save.key < *key {\n-            (remove(&mut save.right, key), false)\n-        } else if *key < save.key {\n-            (remove(&mut save.left, key), false)\n-        } else {\n+        let (removed, this) = match key.cmp(&save.key) {\n+          Less => (remove(&mut save.left, key), false),\n+          Greater => (remove(&mut save.right, key), false),\n+          Equal => {\n             if save.left.is_some() {\n                 if save.right.is_some() {\n                     let mut left = save.left.swap_unwrap();\n@@ -637,6 +642,7 @@ fn remove<K:Ord,V>(node: &mut Option<~TreeNode<K, V>>, key: &K) -> bool {\n             } else {\n                 (true, true)\n             }\n+          }\n         };\n \n         if !this {\n@@ -682,12 +688,9 @@ fn remove<K:Ord,V>(node: &mut Option<~TreeNode<K, V>>, key: &K) -> bool {\n \n #[cfg(test)]\n mod test_treemap {\n+    use core::prelude::*;\n     use super::*;\n-    use core::cmp::{Ord, Eq};\n-    use core::option::{Some, Option, None};\n     use core::rand;\n-    use core::str;\n-    use core::vec;\n \n     #[test]\n     fn find_empty() {\n@@ -742,7 +745,8 @@ mod test_treemap {\n         assert m.find(&k1) == Some(&v1);\n     }\n \n-    fn check_equal<K:Eq + Ord,V:Eq>(ctrl: &[(K, V)], map: &TreeMap<K, V>) {\n+    fn check_equal<K: Eq + TotalOrd, V: Eq>(ctrl: &[(K, V)],\n+                                            map: &TreeMap<K, V>) {\n         assert ctrl.is_empty() == map.is_empty();\n         for ctrl.each |x| {\n             let &(k, v) = x;\n@@ -762,11 +766,11 @@ mod test_treemap {\n         }\n     }\n \n-    fn check_left<K:Ord,V>(node: &Option<~TreeNode<K, V>>,\n-                             parent: &~TreeNode<K, V>) {\n+    fn check_left<K: TotalOrd, V>(node: &Option<~TreeNode<K, V>>,\n+                                  parent: &~TreeNode<K, V>) {\n         match *node {\n           Some(ref r) => {\n-            assert r.key < parent.key;\n+            assert r.key.cmp(&parent.key) == Less;\n             assert r.level == parent.level - 1; // left is black\n             check_left(&r.left, r);\n             check_right(&r.right, r, false);\n@@ -775,11 +779,12 @@ mod test_treemap {\n         }\n     }\n \n-    fn check_right<K:Ord,V>(node: &Option<~TreeNode<K, V>>,\n-                              parent: &~TreeNode<K, V>, parent_red: bool) {\n+    fn check_right<K: TotalOrd, V>(node: &Option<~TreeNode<K, V>>,\n+                                   parent: &~TreeNode<K, V>,\n+                                   parent_red: bool) {\n         match *node {\n           Some(ref r) => {\n-            assert r.key > parent.key;\n+            assert r.key.cmp(&parent.key) == Greater;\n             let red = r.level == parent.level;\n             if parent_red { assert !red } // no dual horizontal links\n             assert red || r.level == parent.level - 1; // right red or black\n@@ -790,7 +795,7 @@ mod test_treemap {\n         }\n     }\n \n-    fn check_structure<K:Ord,V>(map: &TreeMap<K, V>) {\n+    fn check_structure<K: TotalOrd, V>(map: &TreeMap<K, V>) {\n         match map.root {\n           Some(ref r) => {\n             check_left(&r.left, r);"}]}