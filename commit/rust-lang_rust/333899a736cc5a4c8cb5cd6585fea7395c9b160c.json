{"sha": "333899a736cc5a4c8cb5cd6585fea7395c9b160c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjMzMzg5OWE3MzZjYzVhNGM4Y2I1Y2Q2NTg1ZmVhNzM5NWM5YjE2MGM=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-11-07T13:27:26Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-11-07T13:27:26Z"}, "message": "Rollup merge of #66182 - RalfJung:invalid-value, r=Centril\n\ninvalid_value lint: fix help text\n\nNow that we also warn about `MaybUninit::uninit().assume_init()`, just telling people \"use `MaybeUninit`\" isn't always sufficient. And anyway this seems like an important enough point to mention it here.", "tree": {"sha": "4e437fd2ceb9b0c236f649563c15e016816853ff", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4e437fd2ceb9b0c236f649563c15e016816853ff"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/333899a736cc5a4c8cb5cd6585fea7395c9b160c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJdxBu+CRBK7hj4Ov3rIwAAdHIIAJiu5KVn+lWzG0jIwZ1iikRB\nO9U2mUxWAbZH7mWZ0GCTtY0VMogncP/uN73XerRwqyquVfUTLAVTAP4+Bz45bJ3m\ntU+ioxWvvTQ+Tszk7DoJ84P9sho7B9d5bHjcF2J75e4kUCGfHtIMGtKyW7bwZ72v\nKEpG2aZPqL5s4U5KQOfls7ptGdo1hxAOH29JguTPK/sBHh9ap0wbH8fxqgPBS7Be\nxpQnqdj/eFHBML7jCqvFKKeNeJ0hPF2531LTdJXHEes9ixDDkuBK4zQLPBOZ9flr\nMIuWQ/iAQxGjQcaSK3PxBtgwAtGzmEBE3MpoZYRmMunXk2efs/q8B9wY1jtXn9c=\n=9gFL\n-----END PGP SIGNATURE-----\n", "payload": "tree 4e437fd2ceb9b0c236f649563c15e016816853ff\nparent a96811ee9c5b123854e673916da67f5f8f3733ed\nparent a5be03654cf412299d1dffc6f83544a5e5efe416\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1573133246 +0100\ncommitter GitHub <noreply@github.com> 1573133246 +0100\n\nRollup merge of #66182 - RalfJung:invalid-value, r=Centril\n\ninvalid_value lint: fix help text\n\nNow that we also warn about `MaybUninit::uninit().assume_init()`, just telling people \"use `MaybeUninit`\" isn't always sufficient. And anyway this seems like an important enough point to mention it here.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/333899a736cc5a4c8cb5cd6585fea7395c9b160c", "html_url": "https://github.com/rust-lang/rust/commit/333899a736cc5a4c8cb5cd6585fea7395c9b160c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/333899a736cc5a4c8cb5cd6585fea7395c9b160c/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a96811ee9c5b123854e673916da67f5f8f3733ed", "url": "https://api.github.com/repos/rust-lang/rust/commits/a96811ee9c5b123854e673916da67f5f8f3733ed", "html_url": "https://github.com/rust-lang/rust/commit/a96811ee9c5b123854e673916da67f5f8f3733ed"}, {"sha": "a5be03654cf412299d1dffc6f83544a5e5efe416", "url": "https://api.github.com/repos/rust-lang/rust/commits/a5be03654cf412299d1dffc6f83544a5e5efe416", "html_url": "https://github.com/rust-lang/rust/commit/a5be03654cf412299d1dffc6f83544a5e5efe416"}], "stats": {"total": 73, "additions": 37, "deletions": 36}, "files": [{"sha": "c6fd1256a8e6491a4dd8733b760de52430602367", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/333899a736cc5a4c8cb5cd6585fea7395c9b160c/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/333899a736cc5a4c8cb5cd6585fea7395c9b160c/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=333899a736cc5a4c8cb5cd6585fea7395c9b160c", "patch": "@@ -2052,7 +2052,8 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidValue {\n                 );\n                 err.span_label(expr.span,\n                     \"this code causes undefined behavior when executed\");\n-                err.span_label(expr.span, \"help: use `MaybeUninit<T>` instead\");\n+                err.span_label(expr.span, \"help: use `MaybeUninit<T>` instead, \\\n+                    and only call `assume_init` after initialization is done\");\n                 if let Some(span) = span {\n                     err.span_note(span, &msg);\n                 } else {"}, {"sha": "bdb5959953f508ac312686a4da0c27b9e6f96338", "filename": "src/test/ui/lint/uninitialized-zeroed.stderr", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/rust-lang/rust/blob/333899a736cc5a4c8cb5cd6585fea7395c9b160c/src%2Ftest%2Fui%2Flint%2Funinitialized-zeroed.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/333899a736cc5a4c8cb5cd6585fea7395c9b160c/src%2Ftest%2Fui%2Flint%2Funinitialized-zeroed.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Funinitialized-zeroed.stderr?ref=333899a736cc5a4c8cb5cd6585fea7395c9b160c", "patch": "@@ -5,7 +5,7 @@ LL |         let _val: &'static T = mem::zeroed();\n    |                                ^^^^^^^^^^^^^\n    |                                |\n    |                                this code causes undefined behavior when executed\n-   |                                help: use `MaybeUninit<T>` instead\n+   |                                help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n note: lint level defined here\n   --> $DIR/uninitialized-zeroed.rs:7:9\n@@ -21,7 +21,7 @@ LL |         let _val: &'static T = mem::uninitialized();\n    |                                ^^^^^^^^^^^^^^^^^^^^\n    |                                |\n    |                                this code causes undefined behavior when executed\n-   |                                help: use `MaybeUninit<T>` instead\n+   |                                help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n    = note: References must be non-null\n \n@@ -32,7 +32,7 @@ LL |         let _val: Wrap<&'static T> = mem::zeroed();\n    |                                      ^^^^^^^^^^^^^\n    |                                      |\n    |                                      this code causes undefined behavior when executed\n-   |                                      help: use `MaybeUninit<T>` instead\n+   |                                      help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n note: References must be non-null (in this struct field)\n   --> $DIR/uninitialized-zeroed.rs:18:18\n@@ -47,7 +47,7 @@ LL |         let _val: Wrap<&'static T> = mem::uninitialized();\n    |                                      ^^^^^^^^^^^^^^^^^^^^\n    |                                      |\n    |                                      this code causes undefined behavior when executed\n-   |                                      help: use `MaybeUninit<T>` instead\n+   |                                      help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n note: References must be non-null (in this struct field)\n   --> $DIR/uninitialized-zeroed.rs:18:18\n@@ -62,7 +62,7 @@ LL |         let _val: ! = mem::zeroed();\n    |                       ^^^^^^^^^^^^^\n    |                       |\n    |                       this code causes undefined behavior when executed\n-   |                       help: use `MaybeUninit<T>` instead\n+   |                       help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n    = note: The never type (`!`) has no valid value\n \n@@ -73,7 +73,7 @@ LL |         let _val: ! = mem::uninitialized();\n    |                       ^^^^^^^^^^^^^^^^^^^^\n    |                       |\n    |                       this code causes undefined behavior when executed\n-   |                       help: use `MaybeUninit<T>` instead\n+   |                       help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n    = note: The never type (`!`) has no valid value\n \n@@ -84,7 +84,7 @@ LL |         let _val: (i32, !) = mem::zeroed();\n    |                              ^^^^^^^^^^^^^\n    |                              |\n    |                              this code causes undefined behavior when executed\n-   |                              help: use `MaybeUninit<T>` instead\n+   |                              help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n    = note: The never type (`!`) has no valid value\n \n@@ -95,7 +95,7 @@ LL |         let _val: (i32, !) = mem::uninitialized();\n    |                              ^^^^^^^^^^^^^^^^^^^^\n    |                              |\n    |                              this code causes undefined behavior when executed\n-   |                              help: use `MaybeUninit<T>` instead\n+   |                              help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n    = note: The never type (`!`) has no valid value\n \n@@ -106,7 +106,7 @@ LL |         let _val: Void = mem::zeroed();\n    |                          ^^^^^^^^^^^^^\n    |                          |\n    |                          this code causes undefined behavior when executed\n-   |                          help: use `MaybeUninit<T>` instead\n+   |                          help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n    = note: 0-variant enums have no valid value\n \n@@ -117,7 +117,7 @@ LL |         let _val: Void = mem::uninitialized();\n    |                          ^^^^^^^^^^^^^^^^^^^^\n    |                          |\n    |                          this code causes undefined behavior when executed\n-   |                          help: use `MaybeUninit<T>` instead\n+   |                          help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n    = note: 0-variant enums have no valid value\n \n@@ -128,7 +128,7 @@ LL |         let _val: &'static i32 = mem::zeroed();\n    |                                  ^^^^^^^^^^^^^\n    |                                  |\n    |                                  this code causes undefined behavior when executed\n-   |                                  help: use `MaybeUninit<T>` instead\n+   |                                  help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n    = note: References must be non-null\n \n@@ -139,7 +139,7 @@ LL |         let _val: &'static i32 = mem::uninitialized();\n    |                                  ^^^^^^^^^^^^^^^^^^^^\n    |                                  |\n    |                                  this code causes undefined behavior when executed\n-   |                                  help: use `MaybeUninit<T>` instead\n+   |                                  help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n    = note: References must be non-null\n \n@@ -150,7 +150,7 @@ LL |         let _val: Ref = mem::zeroed();\n    |                         ^^^^^^^^^^^^^\n    |                         |\n    |                         this code causes undefined behavior when executed\n-   |                         help: use `MaybeUninit<T>` instead\n+   |                         help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n note: References must be non-null (in this struct field)\n   --> $DIR/uninitialized-zeroed.rs:15:12\n@@ -165,7 +165,7 @@ LL |         let _val: Ref = mem::uninitialized();\n    |                         ^^^^^^^^^^^^^^^^^^^^\n    |                         |\n    |                         this code causes undefined behavior when executed\n-   |                         help: use `MaybeUninit<T>` instead\n+   |                         help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n note: References must be non-null (in this struct field)\n   --> $DIR/uninitialized-zeroed.rs:15:12\n@@ -180,7 +180,7 @@ LL |         let _val: fn() = mem::zeroed();\n    |                          ^^^^^^^^^^^^^\n    |                          |\n    |                          this code causes undefined behavior when executed\n-   |                          help: use `MaybeUninit<T>` instead\n+   |                          help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n    = note: Function pointers must be non-null\n \n@@ -191,7 +191,7 @@ LL |         let _val: fn() = mem::uninitialized();\n    |                          ^^^^^^^^^^^^^^^^^^^^\n    |                          |\n    |                          this code causes undefined behavior when executed\n-   |                          help: use `MaybeUninit<T>` instead\n+   |                          help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n    = note: Function pointers must be non-null\n \n@@ -202,7 +202,7 @@ LL |         let _val: Wrap<fn()> = mem::zeroed();\n    |                                ^^^^^^^^^^^^^\n    |                                |\n    |                                this code causes undefined behavior when executed\n-   |                                help: use `MaybeUninit<T>` instead\n+   |                                help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n note: Function pointers must be non-null (in this struct field)\n   --> $DIR/uninitialized-zeroed.rs:18:18\n@@ -217,7 +217,7 @@ LL |         let _val: Wrap<fn()> = mem::uninitialized();\n    |                                ^^^^^^^^^^^^^^^^^^^^\n    |                                |\n    |                                this code causes undefined behavior when executed\n-   |                                help: use `MaybeUninit<T>` instead\n+   |                                help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n note: Function pointers must be non-null (in this struct field)\n   --> $DIR/uninitialized-zeroed.rs:18:18\n@@ -232,7 +232,7 @@ LL |         let _val: WrapEnum<fn()> = mem::zeroed();\n    |                                    ^^^^^^^^^^^^^\n    |                                    |\n    |                                    this code causes undefined behavior when executed\n-   |                                    help: use `MaybeUninit<T>` instead\n+   |                                    help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n note: Function pointers must be non-null (in this enum field)\n   --> $DIR/uninitialized-zeroed.rs:19:28\n@@ -247,7 +247,7 @@ LL |         let _val: WrapEnum<fn()> = mem::uninitialized();\n    |                                    ^^^^^^^^^^^^^^^^^^^^\n    |                                    |\n    |                                    this code causes undefined behavior when executed\n-   |                                    help: use `MaybeUninit<T>` instead\n+   |                                    help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n note: Function pointers must be non-null (in this enum field)\n   --> $DIR/uninitialized-zeroed.rs:19:28\n@@ -262,7 +262,7 @@ LL |         let _val: Wrap<(RefPair, i32)> = mem::zeroed();\n    |                                          ^^^^^^^^^^^^^\n    |                                          |\n    |                                          this code causes undefined behavior when executed\n-   |                                          help: use `MaybeUninit<T>` instead\n+   |                                          help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n note: References must be non-null (in this struct field)\n   --> $DIR/uninitialized-zeroed.rs:16:16\n@@ -277,7 +277,7 @@ LL |         let _val: Wrap<(RefPair, i32)> = mem::uninitialized();\n    |                                          ^^^^^^^^^^^^^^^^^^^^\n    |                                          |\n    |                                          this code causes undefined behavior when executed\n-   |                                          help: use `MaybeUninit<T>` instead\n+   |                                          help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n note: References must be non-null (in this struct field)\n   --> $DIR/uninitialized-zeroed.rs:16:16\n@@ -292,7 +292,7 @@ LL |         let _val: NonNull<i32> = mem::zeroed();\n    |                                  ^^^^^^^^^^^^^\n    |                                  |\n    |                                  this code causes undefined behavior when executed\n-   |                                  help: use `MaybeUninit<T>` instead\n+   |                                  help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n    = note: std::ptr::NonNull<i32> must be non-null\n \n@@ -303,7 +303,7 @@ LL |         let _val: NonNull<i32> = mem::uninitialized();\n    |                                  ^^^^^^^^^^^^^^^^^^^^\n    |                                  |\n    |                                  this code causes undefined behavior when executed\n-   |                                  help: use `MaybeUninit<T>` instead\n+   |                                  help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n    = note: std::ptr::NonNull<i32> must be non-null\n \n@@ -314,7 +314,7 @@ LL |         let _val: *const dyn Send = mem::zeroed();\n    |                                     ^^^^^^^^^^^^^\n    |                                     |\n    |                                     this code causes undefined behavior when executed\n-   |                                     help: use `MaybeUninit<T>` instead\n+   |                                     help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n    = note: The vtable of a wide raw pointer must be non-null\n \n@@ -325,7 +325,7 @@ LL |         let _val: *const dyn Send = mem::uninitialized();\n    |                                     ^^^^^^^^^^^^^^^^^^^^\n    |                                     |\n    |                                     this code causes undefined behavior when executed\n-   |                                     help: use `MaybeUninit<T>` instead\n+   |                                     help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n    = note: The vtable of a wide raw pointer must be non-null\n \n@@ -336,7 +336,7 @@ LL |         let _val: bool = mem::uninitialized();\n    |                          ^^^^^^^^^^^^^^^^^^^^\n    |                          |\n    |                          this code causes undefined behavior when executed\n-   |                          help: use `MaybeUninit<T>` instead\n+   |                          help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n    = note: Booleans must be `true` or `false`\n \n@@ -347,7 +347,7 @@ LL |         let _val: Wrap<char> = mem::uninitialized();\n    |                                ^^^^^^^^^^^^^^^^^^^^\n    |                                |\n    |                                this code causes undefined behavior when executed\n-   |                                help: use `MaybeUninit<T>` instead\n+   |                                help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n note: Characters must be a valid unicode codepoint (in this struct field)\n   --> $DIR/uninitialized-zeroed.rs:18:18\n@@ -362,7 +362,7 @@ LL |         let _val: NonBig = mem::uninitialized();\n    |                            ^^^^^^^^^^^^^^^^^^^^\n    |                            |\n    |                            this code causes undefined behavior when executed\n-   |                            help: use `MaybeUninit<T>` instead\n+   |                            help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n    = note: NonBig must be initialized inside its custom valid range\n \n@@ -373,7 +373,7 @@ LL |         let _val: &'static i32 = mem::transmute(0usize);\n    |                                  ^^^^^^^^^^^^^^^^^^^^^^\n    |                                  |\n    |                                  this code causes undefined behavior when executed\n-   |                                  help: use `MaybeUninit<T>` instead\n+   |                                  help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n    = note: References must be non-null\n \n@@ -384,7 +384,7 @@ LL |         let _val: &'static [i32] = mem::transmute((0usize, 0usize));\n    |                                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |                                    |\n    |                                    this code causes undefined behavior when executed\n-   |                                    help: use `MaybeUninit<T>` instead\n+   |                                    help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n    = note: References must be non-null\n \n@@ -395,7 +395,7 @@ LL |         let _val: NonZeroU32 = mem::transmute(0);\n    |                                ^^^^^^^^^^^^^^^^^\n    |                                |\n    |                                this code causes undefined behavior when executed\n-   |                                help: use `MaybeUninit<T>` instead\n+   |                                help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n    = note: std::num::NonZeroU32 must be non-null\n \n@@ -406,7 +406,7 @@ LL |         let _val: NonNull<i32> = MaybeUninit::zeroed().assume_init();\n    |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |                                  |\n    |                                  this code causes undefined behavior when executed\n-   |                                  help: use `MaybeUninit<T>` instead\n+   |                                  help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n    = note: std::ptr::NonNull<i32> must be non-null\n \n@@ -417,7 +417,7 @@ LL |         let _val: NonNull<i32> = MaybeUninit::uninit().assume_init();\n    |                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |                                  |\n    |                                  this code causes undefined behavior when executed\n-   |                                  help: use `MaybeUninit<T>` instead\n+   |                                  help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n    = note: std::ptr::NonNull<i32> must be non-null\n \n@@ -428,7 +428,7 @@ LL |         let _val: bool = MaybeUninit::uninit().assume_init();\n    |                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n    |                          |\n    |                          this code causes undefined behavior when executed\n-   |                          help: use `MaybeUninit<T>` instead\n+   |                          help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n    |\n    = note: Booleans must be `true` or `false`\n "}]}