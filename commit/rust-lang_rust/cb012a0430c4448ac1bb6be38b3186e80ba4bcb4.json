{"sha": "cb012a0430c4448ac1bb6be38b3186e80ba4bcb4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNiMDEyYTA0MzBjNDQ0OGFjMWJiNmJlMzhiMzE4NmU4MGJhNGJjYjQ=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-05-29T06:15:53Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-05-29T06:15:53Z"}, "message": "Rollup merge of #60766 - vorner:weak-into-raw, r=sfackler\n\nWeak::into_raw\n\nHello\n\nThis is my first shot at #60728. I'd like to consult it a bit before moving further.\n\nThe biggest question I have is if this API makes sense. My motivation for it is to be able to store the `Weak` in `AtomicPtr`. For that I don't actually need for the pointer to point to the `T`, any pointer (maybe casted to `usize`) would be good enough, but this mirrors what `Arc` does and could be useful for other things too (like comparing if Arc and Weak point to the same thing without playing with the counts), while some opaque pointer wouldn't.\n\nSome secondary questions, if this is deemed desirable are:\n* The weak pointer may be dangling if it is created by `Weak::new()`. It would make sense to treat this as NULL, but that is incompatible with `T: ?Sized` \u2012 both `new()` and `ptr::null()` are available only for sized types. The current implementation is therefore also available only for sized `T`s. It would be possible to allow `?Sized` if the API would be `fn into_raw(self) -> Option<NonNull<T>>` and `fn from_raw(NonNull<T>)`, but that's different API than `Arc` has. What would be preferred?\n* There's a FIXME in my code about what I suspect could be UB. Is it really UB & how to get the pointer correctly? Is manual offsetting of the pointer the only way?\n* Am I missing some other necessary thing around the feature gates and such?\n* Is the documentation understandable? I know writing docs is not my strongest skill :-|.\n\nThinks I'd like to do as part of the PR, but are not yet done:\n* Turn the referenced issue into tracking issue for the feature flag.\n* Once the `sync::Weak` is considered reasonable, I'd do the equivalent for `rc::Weak`.\n* This might call for few more tests than what is currently part of the documentation.", "tree": {"sha": "7cd38e2a8da4eab37b082b4694e7880f5b818cb9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7cd38e2a8da4eab37b082b4694e7880f5b818cb9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cb012a0430c4448ac1bb6be38b3186e80ba4bcb4", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJc7iOZCRBK7hj4Ov3rIwAAdHIIAC8+QVVfXfnznVUo+vdhzLm3\nKwvaSSEYCdmpbWCfh5Eo0XFnBx/J5TRx7AOAG7lw9O2vkOiGM81+upe7hoA0/uK/\nGiWEEtxuzX8H8jEHLFdVrkQp1Qq9CGWT3ShbsreApj+0YSKCychcsgC+rXsxCsX6\nY6iAgbHt9i7DyTATT8U9gaxhqTcAhh2eLtCl1aajiMK2+2uHWrZWQyWpBd1kaHiK\nL9NNovLrro9FosUsq55SIjc67oRiAYl3gW157F313JQdy1LClWcVWAOjcZ/WWVKQ\nFYSakJCa4xXtenqSFSTjPJCtBBYxHkSDtwKXgWDqB+BHg83yTpd+Z/0J7asUKxo=\n=sk05\n-----END PGP SIGNATURE-----\n", "payload": "tree 7cd38e2a8da4eab37b082b4694e7880f5b818cb9\nparent 23b9b8320b97adbd3c7c3c3b939d5d162801d9c0\nparent 4f1dcb34dffc26a23fa8c2cac69a31d7557fd173\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1559110553 +0200\ncommitter GitHub <noreply@github.com> 1559110553 +0200\n\nRollup merge of #60766 - vorner:weak-into-raw, r=sfackler\n\nWeak::into_raw\n\nHello\n\nThis is my first shot at #60728. I'd like to consult it a bit before moving further.\n\nThe biggest question I have is if this API makes sense. My motivation for it is to be able to store the `Weak` in `AtomicPtr`. For that I don't actually need for the pointer to point to the `T`, any pointer (maybe casted to `usize`) would be good enough, but this mirrors what `Arc` does and could be useful for other things too (like comparing if Arc and Weak point to the same thing without playing with the counts), while some opaque pointer wouldn't.\n\nSome secondary questions, if this is deemed desirable are:\n* The weak pointer may be dangling if it is created by `Weak::new()`. It would make sense to treat this as NULL, but that is incompatible with `T: ?Sized` \u2012 both `new()` and `ptr::null()` are available only for sized types. The current implementation is therefore also available only for sized `T`s. It would be possible to allow `?Sized` if the API would be `fn into_raw(self) -> Option<NonNull<T>>` and `fn from_raw(NonNull<T>)`, but that's different API than `Arc` has. What would be preferred?\n* There's a FIXME in my code about what I suspect could be UB. Is it really UB & how to get the pointer correctly? Is manual offsetting of the pointer the only way?\n* Am I missing some other necessary thing around the feature gates and such?\n* Is the documentation understandable? I know writing docs is not my strongest skill :-|.\n\nThinks I'd like to do as part of the PR, but are not yet done:\n* Turn the referenced issue into tracking issue for the feature flag.\n* Once the `sync::Weak` is considered reasonable, I'd do the equivalent for `rc::Weak`.\n* This might call for few more tests than what is currently part of the documentation.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cb012a0430c4448ac1bb6be38b3186e80ba4bcb4", "html_url": "https://github.com/rust-lang/rust/commit/cb012a0430c4448ac1bb6be38b3186e80ba4bcb4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cb012a0430c4448ac1bb6be38b3186e80ba4bcb4/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "23b9b8320b97adbd3c7c3c3b939d5d162801d9c0", "url": "https://api.github.com/repos/rust-lang/rust/commits/23b9b8320b97adbd3c7c3c3b939d5d162801d9c0", "html_url": "https://github.com/rust-lang/rust/commit/23b9b8320b97adbd3c7c3c3b939d5d162801d9c0"}, {"sha": "4f1dcb34dffc26a23fa8c2cac69a31d7557fd173", "url": "https://api.github.com/repos/rust-lang/rust/commits/4f1dcb34dffc26a23fa8c2cac69a31d7557fd173", "html_url": "https://github.com/rust-lang/rust/commit/4f1dcb34dffc26a23fa8c2cac69a31d7557fd173"}], "stats": {"total": 326, "additions": 314, "deletions": 12}, "files": [{"sha": "1f357a719bb43880725e51309349591dd1777156", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 156, "deletions": 6, "changes": 162, "blob_url": "https://github.com/rust-lang/rust/blob/cb012a0430c4448ac1bb6be38b3186e80ba4bcb4/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb012a0430c4448ac1bb6be38b3186e80ba4bcb4/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=cb012a0430c4448ac1bb6be38b3186e80ba4bcb4", "patch": "@@ -239,7 +239,7 @@ use core::fmt;\n use core::hash::{Hash, Hasher};\n use core::intrinsics::abort;\n use core::marker::{self, Unpin, Unsize, PhantomData};\n-use core::mem::{self, align_of_val, forget, size_of_val};\n+use core::mem::{self, align_of, align_of_val, forget, size_of_val};\n use core::ops::{Deref, Receiver, CoerceUnsized, DispatchFromDyn};\n use core::pin::Pin;\n use core::ptr::{self, NonNull};\n@@ -416,11 +416,7 @@ impl<T: ?Sized> Rc<T> {\n     /// ```\n     #[stable(feature = \"rc_raw\", since = \"1.17.0\")]\n     pub unsafe fn from_raw(ptr: *const T) -> Self {\n-        // Align the unsized value to the end of the RcBox.\n-        // Because it is ?Sized, it will always be the last field in memory.\n-        let align = align_of_val(&*ptr);\n-        let layout = Layout::new::<RcBox<()>>();\n-        let offset = (layout.size() + layout.padding_needed_for(align)) as isize;\n+        let offset = data_offset(ptr);\n \n         // Reverse the offset to find the original RcBox.\n         let fake_ptr = ptr as *mut RcBox<T>;\n@@ -1262,6 +1258,143 @@ impl<T> Weak<T> {\n             ptr: NonNull::new(usize::MAX as *mut RcBox<T>).expect(\"MAX is not 0\"),\n         }\n     }\n+\n+    /// Returns a raw pointer to the object `T` pointed to by this `Weak<T>`.\n+    ///\n+    /// It is up to the caller to ensure that the object is still alive when accessing it through\n+    /// the pointer.\n+    ///\n+    /// The pointer may be [`null`] or be dangling in case the object has already been destroyed.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(weak_into_raw)]\n+    ///\n+    /// use std::rc::{Rc, Weak};\n+    /// use std::ptr;\n+    ///\n+    /// let strong = Rc::new(42);\n+    /// let weak = Rc::downgrade(&strong);\n+    /// // Both point to the same object\n+    /// assert!(ptr::eq(&*strong, Weak::as_raw(&weak)));\n+    /// // The strong here keeps it alive, so we can still access the object.\n+    /// assert_eq!(42, unsafe { *Weak::as_raw(&weak) });\n+    ///\n+    /// drop(strong);\n+    /// // But not any more. We can do Weak::as_raw(&weak), but accessing the pointer would lead to\n+    /// // undefined behaviour.\n+    /// // assert_eq!(42, unsafe { *Weak::as_raw(&weak) });\n+    /// ```\n+    ///\n+    /// [`null`]: ../../std/ptr/fn.null.html\n+    #[unstable(feature = \"weak_into_raw\", issue = \"60728\")]\n+    pub fn as_raw(this: &Self) -> *const T {\n+        match this.inner() {\n+            None => ptr::null(),\n+            Some(inner) => {\n+                let offset = data_offset_sized::<T>();\n+                let ptr = inner as *const RcBox<T>;\n+                // Note: while the pointer we create may already point to dropped value, the\n+                // allocation still lives (it must hold the weak point as long as we are alive).\n+                // Therefore, the offset is OK to do, it won't get out of the allocation.\n+                let ptr = unsafe { (ptr as *const u8).offset(offset) };\n+                ptr as *const T\n+            }\n+        }\n+    }\n+\n+    /// Consumes the `Weak<T>` and turns it into a raw pointer.\n+    ///\n+    /// This converts the weak pointer into a raw pointer, preserving the original weak count. It\n+    /// can be turned back into the `Weak<T>` with [`from_raw`].\n+    ///\n+    /// The same restrictions of accessing the target of the pointer as with\n+    /// [`as_raw`] apply.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(weak_into_raw)]\n+    ///\n+    /// use std::rc::{Rc, Weak};\n+    ///\n+    /// let strong = Rc::new(42);\n+    /// let weak = Rc::downgrade(&strong);\n+    /// let raw = Weak::into_raw(weak);\n+    ///\n+    /// assert_eq!(1, Rc::weak_count(&strong));\n+    /// assert_eq!(42, unsafe { *raw });\n+    ///\n+    /// drop(unsafe { Weak::from_raw(raw) });\n+    /// assert_eq!(0, Rc::weak_count(&strong));\n+    /// ```\n+    ///\n+    /// [`from_raw`]: struct.Weak.html#method.from_raw\n+    /// [`as_raw`]: struct.Weak.html#method.as_raw\n+    #[unstable(feature = \"weak_into_raw\", issue = \"60728\")]\n+    pub fn into_raw(this: Self) -> *const T {\n+        let result = Self::as_raw(&this);\n+        mem::forget(this);\n+        result\n+    }\n+\n+    /// Converts a raw pointer previously created by [`into_raw`] back into `Weak<T>`.\n+    ///\n+    /// This can be used to safely get a strong reference (by calling [`upgrade`]\n+    /// later) or to deallocate the weak count by dropping the `Weak<T>`.\n+    ///\n+    /// It takes ownership of one weak count. In case a [`null`] is passed, a dangling [`Weak`] is\n+    /// returned.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The pointer must represent one valid weak count. In other words, it must point to `T` which\n+    /// is or *was* managed by an [`Rc`] and the weak count of that [`Rc`] must not have reached\n+    /// 0. It is allowed for the strong count to be 0.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(weak_into_raw)]\n+    ///\n+    /// use std::rc::{Rc, Weak};\n+    ///\n+    /// let strong = Rc::new(42);\n+    ///\n+    /// let raw_1 = Weak::into_raw(Rc::downgrade(&strong));\n+    /// let raw_2 = Weak::into_raw(Rc::downgrade(&strong));\n+    ///\n+    /// assert_eq!(2, Rc::weak_count(&strong));\n+    ///\n+    /// assert_eq!(42, *Weak::upgrade(&unsafe { Weak::from_raw(raw_1) }).unwrap());\n+    /// assert_eq!(1, Rc::weak_count(&strong));\n+    ///\n+    /// drop(strong);\n+    ///\n+    /// // Decrement the last weak count.\n+    /// assert!(Weak::upgrade(&unsafe { Weak::from_raw(raw_2) }).is_none());\n+    /// ```\n+    ///\n+    /// [`null`]: ../../std/ptr/fn.null.html\n+    /// [`into_raw`]: struct.Weak.html#method.into_raw\n+    /// [`upgrade`]: struct.Weak.html#method.upgrade\n+    /// [`Rc`]: struct.Rc.html\n+    /// [`Weak`]: struct.Weak.html\n+    #[unstable(feature = \"weak_into_raw\", issue = \"60728\")]\n+    pub unsafe fn from_raw(ptr: *const T) -> Self {\n+        if ptr.is_null() {\n+            Self::new()\n+        } else {\n+            // See Rc::from_raw for details\n+            let offset = data_offset(ptr);\n+            let fake_ptr = ptr as *mut RcBox<T>;\n+            let ptr = set_data_ptr(fake_ptr, (ptr as *mut u8).offset(-offset));\n+            Weak {\n+                ptr: NonNull::new(ptr).expect(\"Invalid pointer passed to from_raw\"),\n+            }\n+        }\n+    }\n }\n \n pub(crate) fn is_dangling<T: ?Sized>(ptr: NonNull<T>) -> bool {\n@@ -2007,3 +2140,20 @@ impl<T: ?Sized> AsRef<T> for Rc<T> {\n \n #[stable(feature = \"pin\", since = \"1.33.0\")]\n impl<T: ?Sized> Unpin for Rc<T> { }\n+\n+unsafe fn data_offset<T: ?Sized>(ptr: *const T) -> isize {\n+    // Align the unsized value to the end of the RcBox.\n+    // Because it is ?Sized, it will always be the last field in memory.\n+    let align = align_of_val(&*ptr);\n+    let layout = Layout::new::<RcBox<()>>();\n+    (layout.size() + layout.padding_needed_for(align)) as isize\n+}\n+\n+/// Computes the offset of the data field within ArcInner.\n+///\n+/// Unlike [`data_offset`], this doesn't need the pointer, but it works only on `T: Sized`.\n+fn data_offset_sized<T>() -> isize {\n+    let align = align_of::<T>();\n+    let layout = Layout::new::<RcBox<()>>();\n+    (layout.size() + layout.padding_needed_for(align)) as isize\n+}"}, {"sha": "70865656c510ee7b988d28ad86254a2e6b643f73", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 158, "deletions": 6, "changes": 164, "blob_url": "https://github.com/rust-lang/rust/blob/cb012a0430c4448ac1bb6be38b3186e80ba4bcb4/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cb012a0430c4448ac1bb6be38b3186e80ba4bcb4/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=cb012a0430c4448ac1bb6be38b3186e80ba4bcb4", "patch": "@@ -13,7 +13,7 @@ use core::borrow;\n use core::fmt;\n use core::cmp::{self, Ordering};\n use core::intrinsics::abort;\n-use core::mem::{self, align_of_val, size_of_val};\n+use core::mem::{self, align_of, align_of_val, size_of_val};\n use core::ops::{Deref, Receiver, CoerceUnsized, DispatchFromDyn};\n use core::pin::Pin;\n use core::ptr::{self, NonNull};\n@@ -397,11 +397,7 @@ impl<T: ?Sized> Arc<T> {\n     /// ```\n     #[stable(feature = \"rc_raw\", since = \"1.17.0\")]\n     pub unsafe fn from_raw(ptr: *const T) -> Self {\n-        // Align the unsized value to the end of the ArcInner.\n-        // Because it is ?Sized, it will always be the last field in memory.\n-        let align = align_of_val(&*ptr);\n-        let layout = Layout::new::<ArcInner<()>>();\n-        let offset = (layout.size() + layout.padding_needed_for(align)) as isize;\n+        let offset = data_offset(ptr);\n \n         // Reverse the offset to find the original ArcInner.\n         let fake_ptr = ptr as *mut ArcInner<T>;\n@@ -1071,6 +1067,144 @@ impl<T> Weak<T> {\n             ptr: NonNull::new(usize::MAX as *mut ArcInner<T>).expect(\"MAX is not 0\"),\n         }\n     }\n+\n+    /// Returns a raw pointer to the object `T` pointed to by this `Weak<T>`.\n+    ///\n+    /// It is up to the caller to ensure that the object is still alive when accessing it through\n+    /// the pointer.\n+    ///\n+    /// The pointer may be [`null`] or be dangling in case the object has already been destroyed.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(weak_into_raw)]\n+    ///\n+    /// use std::sync::{Arc, Weak};\n+    /// use std::ptr;\n+    ///\n+    /// let strong = Arc::new(42);\n+    /// let weak = Arc::downgrade(&strong);\n+    /// // Both point to the same object\n+    /// assert!(ptr::eq(&*strong, Weak::as_raw(&weak)));\n+    /// // The strong here keeps it alive, so we can still access the object.\n+    /// assert_eq!(42, unsafe { *Weak::as_raw(&weak) });\n+    ///\n+    /// drop(strong);\n+    /// // But not any more. We can do Weak::as_raw(&weak), but accessing the pointer would lead to\n+    /// // undefined behaviour.\n+    /// // assert_eq!(42, unsafe { *Weak::as_raw(&weak) });\n+    /// ```\n+    ///\n+    /// [`null`]: ../../std/ptr/fn.null.html\n+    #[unstable(feature = \"weak_into_raw\", issue = \"60728\")]\n+    pub fn as_raw(this: &Self) -> *const T {\n+        match this.inner() {\n+            None => ptr::null(),\n+            Some(inner) => {\n+                let offset = data_offset_sized::<T>();\n+                let ptr = inner as *const ArcInner<T>;\n+                // Note: while the pointer we create may already point to dropped value, the\n+                // allocation still lives (it must hold the weak point as long as we are alive).\n+                // Therefore, the offset is OK to do, it won't get out of the allocation.\n+                let ptr = unsafe { (ptr as *const u8).offset(offset) };\n+                ptr as *const T\n+            }\n+        }\n+    }\n+\n+    /// Consumes the `Weak<T>` and turns it into a raw pointer.\n+    ///\n+    /// This converts the weak pointer into a raw pointer, preserving the original weak count. It\n+    /// can be turned back into the `Weak<T>` with [`from_raw`].\n+    ///\n+    /// The same restrictions of accessing the target of the pointer as with\n+    /// [`as_raw`] apply.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(weak_into_raw)]\n+    ///\n+    /// use std::sync::{Arc, Weak};\n+    ///\n+    /// let strong = Arc::new(42);\n+    /// let weak = Arc::downgrade(&strong);\n+    /// let raw = Weak::into_raw(weak);\n+    ///\n+    /// assert_eq!(1, Arc::weak_count(&strong));\n+    /// assert_eq!(42, unsafe { *raw });\n+    ///\n+    /// drop(unsafe { Weak::from_raw(raw) });\n+    /// assert_eq!(0, Arc::weak_count(&strong));\n+    /// ```\n+    ///\n+    /// [`from_raw`]: struct.Weak.html#method.from_raw\n+    /// [`as_raw`]: struct.Weak.html#method.as_raw\n+    #[unstable(feature = \"weak_into_raw\", issue = \"60728\")]\n+    pub fn into_raw(this: Self) -> *const T {\n+        let result = Self::as_raw(&this);\n+        mem::forget(this);\n+        result\n+    }\n+\n+    /// Converts a raw pointer previously created by [`into_raw`] back into\n+    /// `Weak<T>`.\n+    ///\n+    /// This can be used to safely get a strong reference (by calling [`upgrade`]\n+    /// later) or to deallocate the weak count by dropping the `Weak<T>`.\n+    ///\n+    /// It takes ownership of one weak count. In case a [`null`] is passed, a dangling [`Weak`] is\n+    /// returned.\n+    ///\n+    /// # Safety\n+    ///\n+    /// The pointer must represent one valid weak count. In other words, it must point to `T` which\n+    /// is or *was* managed by an [`Arc`] and the weak count of that [`Arc`] must not have reached\n+    /// 0. It is allowed for the strong count to be 0.\n+    ///\n+    /// # Examples\n+    ///\n+    /// ```\n+    /// #![feature(weak_into_raw)]\n+    ///\n+    /// use std::sync::{Arc, Weak};\n+    ///\n+    /// let strong = Arc::new(42);\n+    ///\n+    /// let raw_1 = Weak::into_raw(Arc::downgrade(&strong));\n+    /// let raw_2 = Weak::into_raw(Arc::downgrade(&strong));\n+    ///\n+    /// assert_eq!(2, Arc::weak_count(&strong));\n+    ///\n+    /// assert_eq!(42, *Weak::upgrade(&unsafe { Weak::from_raw(raw_1) }).unwrap());\n+    /// assert_eq!(1, Arc::weak_count(&strong));\n+    ///\n+    /// drop(strong);\n+    ///\n+    /// // Decrement the last weak count.\n+    /// assert!(Weak::upgrade(&unsafe { Weak::from_raw(raw_2) }).is_none());\n+    /// ```\n+    ///\n+    /// [`null`]: ../../std/ptr/fn.null.html\n+    /// [`into_raw`]: struct.Weak.html#method.into_raw\n+    /// [`upgrade`]: struct.Weak.html#method.upgrade\n+    /// [`Weak`]: struct.Weak.html\n+    /// [`Arc`]: struct.Arc.html\n+    #[unstable(feature = \"weak_into_raw\", issue = \"60728\")]\n+    pub unsafe fn from_raw(ptr: *const T) -> Self {\n+        if ptr.is_null() {\n+            Self::new()\n+        } else {\n+            // See Arc::from_raw for details\n+            let offset = data_offset(ptr);\n+            let fake_ptr = ptr as *mut ArcInner<T>;\n+            let ptr = set_data_ptr(fake_ptr, (ptr as *mut u8).offset(-offset));\n+            Weak {\n+                ptr: NonNull::new(ptr).expect(\"Invalid pointer passed to from_raw\"),\n+            }\n+        }\n+    }\n }\n \n impl<T: ?Sized> Weak<T> {\n@@ -2150,3 +2284,21 @@ impl<T: ?Sized> AsRef<T> for Arc<T> {\n \n #[stable(feature = \"pin\", since = \"1.33.0\")]\n impl<T: ?Sized> Unpin for Arc<T> { }\n+\n+/// Computes the offset of the data field within ArcInner.\n+unsafe fn data_offset<T: ?Sized>(ptr: *const T) -> isize {\n+    // Align the unsized value to the end of the ArcInner.\n+    // Because it is ?Sized, it will always be the last field in memory.\n+    let align = align_of_val(&*ptr);\n+    let layout = Layout::new::<ArcInner<()>>();\n+    (layout.size() + layout.padding_needed_for(align)) as isize\n+}\n+\n+/// Computes the offset of the data field within ArcInner.\n+///\n+/// Unlike [`data_offset`], this doesn't need the pointer, but it works only on `T: Sized`.\n+fn data_offset_sized<T>() -> isize {\n+    let align = align_of::<T>();\n+    let layout = Layout::new::<ArcInner<()>>();\n+    (layout.size() + layout.padding_needed_for(align)) as isize\n+}"}]}