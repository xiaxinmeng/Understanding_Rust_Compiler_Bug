{"sha": "76e2349c4417788e03f877fe18d13b521b455a4b", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc2ZTIzNDljNDQxNzc4OGUwM2Y4NzdmZTE4ZDEzYjUyMWI0NTVhNGI=", "commit": {"author": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-04-07T11:47:09Z"}, "committer": {"name": "Manish Goregaokar", "email": "manishsmail@gmail.com", "date": "2016-04-07T14:52:41Z"}, "message": "Rollup merge of #32674 - jseyfried:1422_groundwork, r=nikomatsakis\n\nLay groundwork for RFC 1422  and improve `PrivateItemsInPublicInterfacesVisitor`\n\nThis PR lays groundwork for RFC 1422 (cc #32409) and improves `PrivateItemsInPublicInterfacesVisitor`. More specifically, it\n - Refactors away `hir::Visibility::inherit_from`, the semantics of which are obsolete.\n - Makes `hir::Visibility` non-`Copy` so that we will be able to add new variants to represent `pub(restricted)` (for example, `Visibility::Restricted(Path)`).\n - Adds a new `Copy` type `ty::Visibility` that represents a visibility value, i.e. a characterization of where an item is accessible. This is able to represent `pub(restricted)` visibilities.\n - Improves `PrivateItemsInPublicInterfacesVisitor` so that it checks for items in an interface that are less visible than the interface. This fixes #30079 but doesn't change any other behavior.\n\nr? @nikomatsakis", "tree": {"sha": "e59d427997528a655e7ef6adcabf92993139e87a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e59d427997528a655e7ef6adcabf92993139e87a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/76e2349c4417788e03f877fe18d13b521b455a4b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/76e2349c4417788e03f877fe18d13b521b455a4b", "html_url": "https://github.com/rust-lang/rust/commit/76e2349c4417788e03f877fe18d13b521b455a4b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/76e2349c4417788e03f877fe18d13b521b455a4b/comments", "author": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Manishearth", "id": 1617736, "node_id": "MDQ6VXNlcjE2MTc3MzY=", "avatar_url": "https://avatars.githubusercontent.com/u/1617736?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Manishearth", "html_url": "https://github.com/Manishearth", "followers_url": "https://api.github.com/users/Manishearth/followers", "following_url": "https://api.github.com/users/Manishearth/following{/other_user}", "gists_url": "https://api.github.com/users/Manishearth/gists{/gist_id}", "starred_url": "https://api.github.com/users/Manishearth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Manishearth/subscriptions", "organizations_url": "https://api.github.com/users/Manishearth/orgs", "repos_url": "https://api.github.com/users/Manishearth/repos", "events_url": "https://api.github.com/users/Manishearth/events{/privacy}", "received_events_url": "https://api.github.com/users/Manishearth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "444a118a8932c99b902548cb7ca8c249222c053a", "url": "https://api.github.com/repos/rust-lang/rust/commits/444a118a8932c99b902548cb7ca8c249222c053a", "html_url": "https://github.com/rust-lang/rust/commit/444a118a8932c99b902548cb7ca8c249222c053a"}, {"sha": "dcd4621b4df9c1962ea55653e3f01cdf8b6a3e12", "url": "https://api.github.com/repos/rust-lang/rust/commits/dcd4621b4df9c1962ea55653e3f01cdf8b6a3e12", "html_url": "https://github.com/rust-lang/rust/commit/dcd4621b4df9c1962ea55653e3f01cdf8b6a3e12"}], "stats": {"total": 683, "additions": 385, "deletions": 298}, "files": [{"sha": "55fd58da86635b61ee7eb7e619b70e2bb70e7b4f", "filename": "src/librustc/hir/intravisit.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/76e2349c4417788e03f877fe18d13b521b455a4b/src%2Flibrustc%2Fhir%2Fintravisit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e2349c4417788e03f877fe18d13b521b455a4b/src%2Flibrustc%2Fhir%2Fintravisit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fintravisit.rs?ref=76e2349c4417788e03f877fe18d13b521b455a4b", "patch": "@@ -37,10 +37,10 @@ use std::u32;\n #[derive(Copy, Clone, PartialEq, Eq)]\n pub enum FnKind<'a> {\n     /// fn foo() or extern \"Abi\" fn foo()\n-    ItemFn(Name, &'a Generics, Unsafety, Constness, Abi, Visibility, &'a [Attribute]),\n+    ItemFn(Name, &'a Generics, Unsafety, Constness, Abi, &'a Visibility, &'a [Attribute]),\n \n     /// fn foo(&self)\n-    Method(Name, &'a MethodSig, Option<Visibility>, &'a [Attribute]),\n+    Method(Name, &'a MethodSig, Option<&'a Visibility>, &'a [Attribute]),\n \n     /// |x, y| {}\n     Closure(&'a [Attribute]),\n@@ -324,7 +324,7 @@ pub fn walk_item<'v, V: Visitor<'v>>(visitor: &mut V, item: &'v Item) {\n                                             unsafety,\n                                             constness,\n                                             abi,\n-                                            item.vis,\n+                                            &item.vis,\n                                             &item.attrs),\n                              declaration,\n                              body,\n@@ -672,7 +672,7 @@ pub fn walk_impl_item<'v, V: Visitor<'v>>(visitor: &mut V, impl_item: &'v ImplIt\n         ImplItemKind::Method(ref sig, ref body) => {\n             visitor.visit_fn(FnKind::Method(impl_item.name,\n                                             sig,\n-                                            Some(impl_item.vis),\n+                                            Some(&impl_item.vis),\n                                             &impl_item.attrs),\n                              &sig.decl,\n                              body,"}, {"sha": "8c626226bd3c3588842f2a093863faa5cafa157d", "filename": "src/librustc/hir/map/blocks.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/76e2349c4417788e03f877fe18d13b521b455a4b/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e2349c4417788e03f877fe18d13b521b455a4b/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fblocks.rs?ref=76e2349c4417788e03f877fe18d13b521b455a4b", "patch": "@@ -113,7 +113,7 @@ struct ItemFnParts<'a> {\n     unsafety: ast::Unsafety,\n     constness: ast::Constness,\n     abi:      abi::Abi,\n-    vis:      ast::Visibility,\n+    vis:      &'a ast::Visibility,\n     generics: &'a ast::Generics,\n     body:     &'a Block,\n     id:       NodeId,\n@@ -208,7 +208,7 @@ impl<'a> FnLikeNode<'a> {\n         M: FnOnce(NodeId,\n                   Name,\n                   &'a ast::MethodSig,\n-                  Option<ast::Visibility>,\n+                  Option<&'a ast::Visibility>,\n                   &'a ast::Block,\n                   Span,\n                   &'a [Attribute])\n@@ -226,7 +226,7 @@ impl<'a> FnLikeNode<'a> {\n                         body: &block,\n                         generics: generics,\n                         abi: abi,\n-                        vis: i.vis,\n+                        vis: &i.vis,\n                         constness: constness,\n                         span: i.span,\n                         attrs: &i.attrs,\n@@ -242,7 +242,7 @@ impl<'a> FnLikeNode<'a> {\n             map::NodeImplItem(ii) => {\n                 match ii.node {\n                     ast::ImplItemKind::Method(ref sig, ref body) => {\n-                        method(ii.id, ii.name, sig, Some(ii.vis), body, ii.span, &ii.attrs)\n+                        method(ii.id, ii.name, sig, Some(&ii.vis), body, ii.span, &ii.attrs)\n                     }\n                     _ => {\n                         bug!(\"impl method FnLikeNode that is not fn-like\")"}, {"sha": "fc1c4aeb226012b09c0d33ad314e00497eb38822", "filename": "src/librustc/hir/map/mod.rs", "status": "modified", "additions": 1, "deletions": 13, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/76e2349c4417788e03f877fe18d13b521b455a4b/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e2349c4417788e03f877fe18d13b521b455a4b/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmap%2Fmod.rs?ref=76e2349c4417788e03f877fe18d13b521b455a4b", "patch": "@@ -430,7 +430,7 @@ impl<'ast> Map<'ast> {\n \n     /// Returns the NodeId of `id`'s nearest module parent, or `id` itself if no\n     /// module parent is in this map.\n-    fn get_module_parent(&self, id: NodeId) -> NodeId {\n+    pub fn get_module_parent(&self, id: NodeId) -> NodeId {\n         match self.walk_parent_nodes(id, |node| match *node {\n             NodeItem(&Item { node: Item_::ItemMod(_), .. }) => true,\n             _ => false,\n@@ -440,18 +440,6 @@ impl<'ast> Map<'ast> {\n         }\n     }\n \n-    pub fn private_item_is_visible_from(&self, item: NodeId, block: NodeId) -> bool {\n-        // A private item is visible from everything in its nearest module parent.\n-        let visibility = self.get_module_parent(item);\n-        let mut block_ancestor = self.get_module_parent(block);\n-        loop {\n-            if block_ancestor == visibility { return true }\n-            let block_ancestor_parent = self.get_module_parent(block_ancestor);\n-            if block_ancestor_parent == block_ancestor { return false }\n-            block_ancestor = block_ancestor_parent;\n-        }\n-    }\n-\n     /// Returns the nearest enclosing scope. A scope is an item or block.\n     /// FIXME it is not clear to me that all items qualify as scopes - statics\n     /// and associated types probably shouldn't, for example. Behaviour in this"}, {"sha": "8e748875b93f1b4be226f8e73b65acc0348d7436", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 1, "deletions": 10, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/76e2349c4417788e03f877fe18d13b521b455a4b/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e2349c4417788e03f877fe18d13b521b455a4b/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=76e2349c4417788e03f877fe18d13b521b455a4b", "patch": "@@ -1431,21 +1431,12 @@ pub struct PolyTraitRef {\n     pub span: Span,\n }\n \n-#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n+#[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub enum Visibility {\n     Public,\n     Inherited,\n }\n \n-impl Visibility {\n-    pub fn inherit_from(&self, parent_visibility: Visibility) -> Visibility {\n-        match self {\n-            &Inherited => parent_visibility,\n-            &Public => *self,\n-        }\n-    }\n-}\n-\n #[derive(Clone, PartialEq, Eq, RustcEncodable, RustcDecodable, Hash, Debug)]\n pub struct StructField {\n     pub span: Span,"}, {"sha": "7affb129313c886015b53931c07bbd570bd21acc", "filename": "src/librustc/hir/print.rs", "status": "modified", "additions": 31, "deletions": 31, "changes": 62, "blob_url": "https://github.com/rust-lang/rust/blob/76e2349c4417788e03f877fe18d13b521b455a4b/src%2Flibrustc%2Fhir%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e2349c4417788e03f877fe18d13b521b455a4b/src%2Flibrustc%2Fhir%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fprint.rs?ref=76e2349c4417788e03f877fe18d13b521b455a4b", "patch": "@@ -294,7 +294,7 @@ pub fn fun_to_string(decl: &hir::FnDecl,\n                    Some(name),\n                    generics,\n                    opt_explicit_self,\n-                   hir::Inherited)?;\n+                   &hir::Inherited)?;\n         s.end()?; // Close the head box\n         s.end() // Close the outer box\n     })\n@@ -322,8 +322,8 @@ pub fn arg_to_string(arg: &hir::Arg) -> String {\n     to_string(|s| s.print_arg(arg, false))\n }\n \n-pub fn visibility_qualified(vis: hir::Visibility, s: &str) -> String {\n-    match vis {\n+pub fn visibility_qualified(vis: &hir::Visibility, s: &str) -> String {\n+    match *vis {\n         hir::Public => format!(\"pub {}\", s),\n         hir::Inherited => s.to_string(),\n     }\n@@ -573,13 +573,13 @@ impl<'a> State<'a> {\n                               Some(item.name),\n                               generics,\n                               None,\n-                              item.vis)?;\n+                              &item.vis)?;\n                 self.end()?; // end head-ibox\n                 word(&mut self.s, \";\")?;\n                 self.end() // end the outer fn box\n             }\n             hir::ForeignItemStatic(ref t, m) => {\n-                self.head(&visibility_qualified(item.vis, \"static\"))?;\n+                self.head(&visibility_qualified(&item.vis, \"static\"))?;\n                 if m {\n                     self.word_space(\"mut\")?;\n                 }\n@@ -597,7 +597,7 @@ impl<'a> State<'a> {\n                               name: ast::Name,\n                               ty: &hir::Ty,\n                               default: Option<&hir::Expr>,\n-                              vis: hir::Visibility)\n+                              vis: &hir::Visibility)\n                               -> io::Result<()> {\n         word(&mut self.s, &visibility_qualified(vis, \"\"))?;\n         self.word_space(\"const\")?;\n@@ -648,7 +648,7 @@ impl<'a> State<'a> {\n         self.ann.pre(self, NodeItem(item))?;\n         match item.node {\n             hir::ItemExternCrate(ref optional_path) => {\n-                self.head(&visibility_qualified(item.vis, \"extern crate\"))?;\n+                self.head(&visibility_qualified(&item.vis, \"extern crate\"))?;\n                 if let Some(p) = *optional_path {\n                     let val = p.as_str();\n                     if val.contains(\"-\") {\n@@ -666,14 +666,14 @@ impl<'a> State<'a> {\n                 self.end()?; // end outer head-block\n             }\n             hir::ItemUse(ref vp) => {\n-                self.head(&visibility_qualified(item.vis, \"use\"))?;\n+                self.head(&visibility_qualified(&item.vis, \"use\"))?;\n                 self.print_view_path(&vp)?;\n                 word(&mut self.s, \";\")?;\n                 self.end()?; // end inner head-block\n                 self.end()?; // end outer head-block\n             }\n             hir::ItemStatic(ref ty, m, ref expr) => {\n-                self.head(&visibility_qualified(item.vis, \"static\"))?;\n+                self.head(&visibility_qualified(&item.vis, \"static\"))?;\n                 if m == hir::MutMutable {\n                     self.word_space(\"mut\")?;\n                 }\n@@ -689,7 +689,7 @@ impl<'a> State<'a> {\n                 self.end()?; // end the outer cbox\n             }\n             hir::ItemConst(ref ty, ref expr) => {\n-                self.head(&visibility_qualified(item.vis, \"const\"))?;\n+                self.head(&visibility_qualified(&item.vis, \"const\"))?;\n                 self.print_name(item.name)?;\n                 self.word_space(\":\")?;\n                 self.print_type(&ty)?;\n@@ -710,12 +710,12 @@ impl<'a> State<'a> {\n                               Some(item.name),\n                               typarams,\n                               None,\n-                              item.vis)?;\n+                              &item.vis)?;\n                 word(&mut self.s, \" \")?;\n                 self.print_block_with_attrs(&body, &item.attrs)?;\n             }\n             hir::ItemMod(ref _mod) => {\n-                self.head(&visibility_qualified(item.vis, \"mod\"))?;\n+                self.head(&visibility_qualified(&item.vis, \"mod\"))?;\n                 self.print_name(item.name)?;\n                 self.nbsp()?;\n                 self.bopen()?;\n@@ -732,7 +732,7 @@ impl<'a> State<'a> {\n             hir::ItemTy(ref ty, ref params) => {\n                 self.ibox(indent_unit)?;\n                 self.ibox(0)?;\n-                self.word_nbsp(&visibility_qualified(item.vis, \"type\"))?;\n+                self.word_nbsp(&visibility_qualified(&item.vis, \"type\"))?;\n                 self.print_name(item.name)?;\n                 self.print_generics(params)?;\n                 self.end()?; // end the inner ibox\n@@ -745,16 +745,16 @@ impl<'a> State<'a> {\n                 self.end()?; // end the outer ibox\n             }\n             hir::ItemEnum(ref enum_definition, ref params) => {\n-                self.print_enum_def(enum_definition, params, item.name, item.span, item.vis)?;\n+                self.print_enum_def(enum_definition, params, item.name, item.span, &item.vis)?;\n             }\n             hir::ItemStruct(ref struct_def, ref generics) => {\n-                self.head(&visibility_qualified(item.vis, \"struct\"))?;\n+                self.head(&visibility_qualified(&item.vis, \"struct\"))?;\n                 self.print_struct(struct_def, generics, item.name, item.span, true)?;\n             }\n \n             hir::ItemDefaultImpl(unsafety, ref trait_ref) => {\n                 self.head(\"\")?;\n-                self.print_visibility(item.vis)?;\n+                self.print_visibility(&item.vis)?;\n                 self.print_unsafety(unsafety)?;\n                 self.word_nbsp(\"impl\")?;\n                 self.print_trait_ref(trait_ref)?;\n@@ -771,7 +771,7 @@ impl<'a> State<'a> {\n                           ref ty,\n                           ref impl_items) => {\n                 self.head(\"\")?;\n-                self.print_visibility(item.vis)?;\n+                self.print_visibility(&item.vis)?;\n                 self.print_unsafety(unsafety)?;\n                 self.word_nbsp(\"impl\")?;\n \n@@ -809,7 +809,7 @@ impl<'a> State<'a> {\n             }\n             hir::ItemTrait(unsafety, ref generics, ref bounds, ref trait_items) => {\n                 self.head(\"\")?;\n-                self.print_visibility(item.vis)?;\n+                self.print_visibility(&item.vis)?;\n                 self.print_unsafety(unsafety)?;\n                 self.word_nbsp(\"trait\")?;\n                 self.print_name(item.name)?;\n@@ -867,7 +867,7 @@ impl<'a> State<'a> {\n                           generics: &hir::Generics,\n                           name: ast::Name,\n                           span: codemap::Span,\n-                          visibility: hir::Visibility)\n+                          visibility: &hir::Visibility)\n                           -> io::Result<()> {\n         self.head(&visibility_qualified(visibility, \"enum\"))?;\n         self.print_name(name)?;\n@@ -895,8 +895,8 @@ impl<'a> State<'a> {\n         self.bclose(span)\n     }\n \n-    pub fn print_visibility(&mut self, vis: hir::Visibility) -> io::Result<()> {\n-        match vis {\n+    pub fn print_visibility(&mut self, vis: &hir::Visibility) -> io::Result<()> {\n+        match *vis {\n             hir::Public => self.word_nbsp(\"pub\"),\n             hir::Inherited => Ok(()),\n         }\n@@ -915,7 +915,7 @@ impl<'a> State<'a> {\n             if struct_def.is_tuple() {\n                 self.popen()?;\n                 self.commasep(Inconsistent, struct_def.fields(), |s, field| {\n-                    s.print_visibility(field.vis)?;\n+                    s.print_visibility(&field.vis)?;\n                     s.maybe_print_comment(field.span.lo)?;\n                     s.print_type(&field.ty)\n                 })?;\n@@ -937,7 +937,7 @@ impl<'a> State<'a> {\n                 self.hardbreak_if_not_bol()?;\n                 self.maybe_print_comment(field.span.lo)?;\n                 self.print_outer_attributes(&field.attrs)?;\n-                self.print_visibility(field.vis)?;\n+                self.print_visibility(&field.vis)?;\n                 self.print_name(field.name)?;\n                 self.word_nbsp(\":\")?;\n                 self.print_type(&field.ty)?;\n@@ -964,7 +964,7 @@ impl<'a> State<'a> {\n     pub fn print_method_sig(&mut self,\n                             name: ast::Name,\n                             m: &hir::MethodSig,\n-                            vis: hir::Visibility)\n+                            vis: &hir::Visibility)\n                             -> io::Result<()> {\n         self.print_fn(&m.decl,\n                       m.unsafety,\n@@ -986,13 +986,13 @@ impl<'a> State<'a> {\n                 self.print_associated_const(ti.name,\n                                             &ty,\n                                             default.as_ref().map(|expr| &**expr),\n-                                            hir::Inherited)?;\n+                                            &hir::Inherited)?;\n             }\n             hir::MethodTraitItem(ref sig, ref body) => {\n                 if body.is_some() {\n                     self.head(\"\")?;\n                 }\n-                self.print_method_sig(ti.name, sig, hir::Inherited)?;\n+                self.print_method_sig(ti.name, sig, &hir::Inherited)?;\n                 if let Some(ref body) = *body {\n                     self.nbsp()?;\n                     self.print_block_with_attrs(body, &ti.attrs)?;\n@@ -1021,11 +1021,11 @@ impl<'a> State<'a> {\n \n         match ii.node {\n             hir::ImplItemKind::Const(ref ty, ref expr) => {\n-                self.print_associated_const(ii.name, &ty, Some(&expr), ii.vis)?;\n+                self.print_associated_const(ii.name, &ty, Some(&expr), &ii.vis)?;\n             }\n             hir::ImplItemKind::Method(ref sig, ref body) => {\n                 self.head(\"\")?;\n-                self.print_method_sig(ii.name, sig, ii.vis)?;\n+                self.print_method_sig(ii.name, sig, &ii.vis)?;\n                 self.nbsp()?;\n                 self.print_block_with_attrs(body, &ii.attrs)?;\n             }\n@@ -1910,7 +1910,7 @@ impl<'a> State<'a> {\n                     name: Option<ast::Name>,\n                     generics: &hir::Generics,\n                     opt_explicit_self: Option<&hir::ExplicitSelf_>,\n-                    vis: hir::Visibility)\n+                    vis: &hir::Visibility)\n                     -> io::Result<()> {\n         self.print_fn_header_info(unsafety, constness, abi, vis)?;\n \n@@ -2267,7 +2267,7 @@ impl<'a> State<'a> {\n                       name,\n                       &generics,\n                       opt_explicit_self,\n-                      hir::Inherited)?;\n+                      &hir::Inherited)?;\n         self.end()\n     }\n \n@@ -2347,7 +2347,7 @@ impl<'a> State<'a> {\n                                 unsafety: hir::Unsafety,\n                                 constness: hir::Constness,\n                                 abi: Abi,\n-                                vis: hir::Visibility)\n+                                vis: &hir::Visibility)\n                                 -> io::Result<()> {\n         word(&mut self.s, &visibility_qualified(vis, \"\"))?;\n         self.print_unsafety(unsafety)?;"}, {"sha": "d3db0804c24229abf30cdc23bbe44d66529518ac", "filename": "src/librustc/middle/cstore.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/76e2349c4417788e03f877fe18d13b521b455a4b/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e2349c4417788e03f877fe18d13b521b455a4b/src%2Flibrustc%2Fmiddle%2Fcstore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fcstore.rs?ref=76e2349c4417788e03f877fe18d13b521b455a4b", "patch": "@@ -116,7 +116,7 @@ pub const LOCAL_CRATE: ast::CrateNum = 0;\n pub struct ChildItem {\n     pub def: DefLike,\n     pub name: ast::Name,\n-    pub vis: hir::Visibility\n+    pub vis: ty::Visibility,\n }\n \n pub enum FoundAst<'ast> {\n@@ -157,7 +157,7 @@ pub trait CrateStore<'tcx> : Any {\n     // item info\n     fn stability(&self, def: DefId) -> Option<attr::Stability>;\n     fn deprecation(&self, def: DefId) -> Option<attr::Deprecation>;\n-    fn visibility(&self, def: DefId) -> hir::Visibility;\n+    fn visibility(&self, def: DefId) -> ty::Visibility;\n     fn closure_kind(&self, tcx: &TyCtxt<'tcx>, def_id: DefId)\n                     -> ty::ClosureKind;\n     fn closure_ty(&self, tcx: &TyCtxt<'tcx>, def_id: DefId)\n@@ -334,7 +334,7 @@ impl<'tcx> CrateStore<'tcx> for DummyCrateStore {\n     // item info\n     fn stability(&self, def: DefId) -> Option<attr::Stability> { bug!(\"stability\") }\n     fn deprecation(&self, def: DefId) -> Option<attr::Deprecation> { bug!(\"deprecation\") }\n-    fn visibility(&self, def: DefId) -> hir::Visibility { bug!(\"visibility\") }\n+    fn visibility(&self, def: DefId) -> ty::Visibility { bug!(\"visibility\") }\n     fn closure_kind(&self, tcx: &TyCtxt<'tcx>, def_id: DefId)\n                     -> ty::ClosureKind  { bug!(\"closure_kind\") }\n     fn closure_ty(&self, tcx: &TyCtxt<'tcx>, def_id: DefId)"}, {"sha": "47e8f91b48c61bc22ad2aaa76d892c69c641b841", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 57, "deletions": 7, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/76e2349c4417788e03f877fe18d13b521b455a4b/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e2349c4417788e03f877fe18d13b521b455a4b/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=76e2349c4417788e03f877fe18d13b521b455a4b", "patch": "@@ -232,7 +232,7 @@ impl<'tcx> ImplOrTraitItem<'tcx> {\n         }\n     }\n \n-    pub fn vis(&self) -> hir::Visibility {\n+    pub fn vis(&self) -> Visibility {\n         match *self {\n             ConstTraitItem(ref associated_const) => associated_const.vis,\n             MethodTraitItem(ref method) => method.vis,\n@@ -273,14 +273,64 @@ impl ImplOrTraitItemId {\n     }\n }\n \n+#[derive(Clone, Debug, PartialEq, Eq, Copy)]\n+pub enum Visibility {\n+    /// Visible everywhere (including in other crates).\n+    Public,\n+    /// Visible only in the given crate-local module.\n+    Restricted(NodeId),\n+    /// Not visible anywhere in the local crate. This is the visibility of private external items.\n+    PrivateExternal,\n+}\n+\n+impl Visibility {\n+    pub fn from_hir(visibility: &hir::Visibility, id: NodeId, tcx: &TyCtxt) -> Self {\n+        match *visibility {\n+            hir::Public => Visibility::Public,\n+            hir::Inherited => Visibility::Restricted(tcx.map.get_module_parent(id)),\n+        }\n+    }\n+\n+    /// Returns true if an item with this visibility is accessible from the given block.\n+    pub fn is_accessible_from(self, block: NodeId, map: &ast_map::Map) -> bool {\n+        let restriction = match self {\n+            // Public items are visible everywhere.\n+            Visibility::Public => return true,\n+            // Private items from other crates are visible nowhere.\n+            Visibility::PrivateExternal => return false,\n+            // Restricted items are visible in an arbitrary local module.\n+            Visibility::Restricted(module) => module,\n+        };\n+\n+        let mut block_ancestor = block;\n+        loop {\n+            if block_ancestor == restriction { return true }\n+            let block_ancestor_parent = map.get_module_parent(block_ancestor);\n+            if block_ancestor_parent == block_ancestor { return false }\n+            block_ancestor = block_ancestor_parent;\n+        }\n+    }\n+\n+    /// Returns true if this visibility is at least as accessible as the given visibility\n+    pub fn is_at_least(self, vis: Visibility, map: &ast_map::Map) -> bool {\n+        let vis_restriction = match vis {\n+            Visibility::Public => return self == Visibility::Public,\n+            Visibility::PrivateExternal => return true,\n+            Visibility::Restricted(module) => module,\n+        };\n+\n+        self.is_accessible_from(vis_restriction, map)\n+    }\n+}\n+\n #[derive(Clone, Debug)]\n pub struct Method<'tcx> {\n     pub name: Name,\n     pub generics: Generics<'tcx>,\n     pub predicates: GenericPredicates<'tcx>,\n     pub fty: BareFnTy<'tcx>,\n     pub explicit_self: ExplicitSelfCategory,\n-    pub vis: hir::Visibility,\n+    pub vis: Visibility,\n     pub defaultness: hir::Defaultness,\n     pub def_id: DefId,\n     pub container: ImplOrTraitItemContainer,\n@@ -292,7 +342,7 @@ impl<'tcx> Method<'tcx> {\n                predicates: GenericPredicates<'tcx>,\n                fty: BareFnTy<'tcx>,\n                explicit_self: ExplicitSelfCategory,\n-               vis: hir::Visibility,\n+               vis: Visibility,\n                defaultness: hir::Defaultness,\n                def_id: DefId,\n                container: ImplOrTraitItemContainer)\n@@ -336,7 +386,7 @@ impl<'tcx> Hash for Method<'tcx> {\n pub struct AssociatedConst<'tcx> {\n     pub name: Name,\n     pub ty: Ty<'tcx>,\n-    pub vis: hir::Visibility,\n+    pub vis: Visibility,\n     pub defaultness: hir::Defaultness,\n     pub def_id: DefId,\n     pub container: ImplOrTraitItemContainer,\n@@ -347,7 +397,7 @@ pub struct AssociatedConst<'tcx> {\n pub struct AssociatedType<'tcx> {\n     pub name: Name,\n     pub ty: Option<Ty<'tcx>>,\n-    pub vis: hir::Visibility,\n+    pub vis: Visibility,\n     pub defaultness: hir::Defaultness,\n     pub def_id: DefId,\n     pub container: ImplOrTraitItemContainer,\n@@ -1419,7 +1469,7 @@ pub struct FieldDefData<'tcx, 'container: 'tcx> {\n     /// are not real items, and don't have entries in tcache etc.\n     pub did: DefId,\n     pub name: Name,\n-    pub vis: hir::Visibility,\n+    pub vis: Visibility,\n     /// TyIVar is used here to allow for variance (see the doc at\n     /// AdtDefData).\n     ///\n@@ -1704,7 +1754,7 @@ impl<'tcx, 'container> VariantDefData<'tcx, 'container> {\n impl<'tcx, 'container> FieldDefData<'tcx, 'container> {\n     pub fn new(did: DefId,\n                name: Name,\n-               vis: hir::Visibility) -> Self {\n+               vis: Visibility) -> Self {\n         FieldDefData {\n             did: did,\n             name: name,"}, {"sha": "8e7be0e3a0f5e0d3fd5682de643f90a854c801af", "filename": "src/librustc_metadata/csearch.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/76e2349c4417788e03f877fe18d13b521b455a4b/src%2Flibrustc_metadata%2Fcsearch.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e2349c4417788e03f877fe18d13b521b455a4b/src%2Flibrustc_metadata%2Fcsearch.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fcsearch.rs?ref=76e2349c4417788e03f877fe18d13b521b455a4b", "patch": "@@ -48,7 +48,7 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         decoder::get_deprecation(&cdata, def.index)\n     }\n \n-    fn visibility(&self, def: DefId) -> hir::Visibility {\n+    fn visibility(&self, def: DefId) -> ty::Visibility {\n         let cdata = self.get_crate_data(def.krate);\n         decoder::get_visibility(&cdata, def.index)\n     }\n@@ -536,7 +536,6 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n         let mut visible_parent_map = self.visible_parent_map.borrow_mut();\n         if !visible_parent_map.is_empty() { return visible_parent_map; }\n \n-        use rustc::hir;\n         use rustc::middle::cstore::{CrateStore, ChildItem};\n         use std::collections::vec_deque::VecDeque;\n         use std::collections::hash_map::Entry;\n@@ -552,7 +551,7 @@ impl<'tcx> CrateStore<'tcx> for cstore::CStore {\n             let mut bfs_queue = &mut VecDeque::new();\n             let mut add_child = |bfs_queue: &mut VecDeque<_>, child: ChildItem, parent: DefId| {\n                 let child = match child.def {\n-                    DefLike::DlDef(def) if child.vis == hir::Public => def.def_id(),\n+                    DefLike::DlDef(def) if child.vis == ty::Visibility::Public => def.def_id(),\n                     _ => return,\n                 };\n "}, {"sha": "a0881f1153e39eec45eb4037852eb2115436b3cf", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/76e2349c4417788e03f877fe18d13b521b455a4b/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e2349c4417788e03f877fe18d13b521b455a4b/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=76e2349c4417788e03f877fe18d13b521b455a4b", "patch": "@@ -140,13 +140,13 @@ fn item_family(item: rbml::Doc) -> Family {\n     }\n }\n \n-fn item_visibility(item: rbml::Doc) -> hir::Visibility {\n+fn item_visibility(item: rbml::Doc) -> ty::Visibility {\n     match reader::maybe_get_doc(item, tag_items_data_item_visibility) {\n-        None => hir::Public,\n+        None => ty::Visibility::Public,\n         Some(visibility_doc) => {\n             match reader::doc_as_u8(visibility_doc) as char {\n-                'y' => hir::Public,\n-                'i' => hir::Inherited,\n+                'y' => ty::Visibility::Public,\n+                'i' => ty::Visibility::PrivateExternal,\n                 _ => bug!(\"unknown visibility character\")\n             }\n         }\n@@ -541,7 +541,7 @@ pub fn get_deprecation(cdata: Cmd, id: DefIndex) -> Option<attr::Deprecation> {\n     })\n }\n \n-pub fn get_visibility(cdata: Cmd, id: DefIndex) -> hir::Visibility {\n+pub fn get_visibility(cdata: Cmd, id: DefIndex) -> ty::Visibility {\n     item_visibility(cdata.lookup_item(id))\n }\n \n@@ -639,7 +639,7 @@ fn each_child_of_item_or_crate<F, G>(intr: Rc<IdentInterner>,\n                                      item_doc: rbml::Doc,\n                                      mut get_crate_data: G,\n                                      mut callback: F) where\n-    F: FnMut(DefLike, ast::Name, hir::Visibility),\n+    F: FnMut(DefLike, ast::Name, ty::Visibility),\n     G: FnMut(ast::CrateNum) -> Rc<crate_metadata>,\n {\n     // Iterate over all children.\n@@ -723,7 +723,7 @@ fn each_child_of_item_or_crate<F, G>(intr: Rc<IdentInterner>,\n             let def_like = item_to_def_like(crate_data, child_item_doc, child_def_id);\n             // These items have a public visibility because they're part of\n             // a public re-export.\n-            callback(def_like, token::intern(name), hir::Public);\n+            callback(def_like, token::intern(name), ty::Visibility::Public);\n         }\n     }\n }\n@@ -734,7 +734,7 @@ pub fn each_child_of_item<F, G>(intr: Rc<IdentInterner>,\n                                id: DefIndex,\n                                get_crate_data: G,\n                                callback: F) where\n-    F: FnMut(DefLike, ast::Name, hir::Visibility),\n+    F: FnMut(DefLike, ast::Name, ty::Visibility),\n     G: FnMut(ast::CrateNum) -> Rc<crate_metadata>,\n {\n     // Find the item.\n@@ -755,7 +755,7 @@ pub fn each_top_level_item_of_crate<F, G>(intr: Rc<IdentInterner>,\n                                           cdata: Cmd,\n                                           get_crate_data: G,\n                                           callback: F) where\n-    F: FnMut(DefLike, ast::Name, hir::Visibility),\n+    F: FnMut(DefLike, ast::Name, ty::Visibility),\n     G: FnMut(ast::CrateNum) -> Rc<crate_metadata>,\n {\n     let root_doc = rbml::Doc::new(cdata.data());\n@@ -1138,11 +1138,11 @@ pub fn get_struct_field_attrs(cdata: Cmd) -> FnvHashMap<DefId, Vec<ast::Attribut\n     }).collect()\n }\n \n-fn struct_field_family_to_visibility(family: Family) -> hir::Visibility {\n+fn struct_field_family_to_visibility(family: Family) -> ty::Visibility {\n     match family {\n-      PublicField => hir::Public,\n-      InheritedField => hir::Inherited,\n-      _ => bug!()\n+        PublicField => ty::Visibility::Public,\n+        InheritedField => ty::Visibility::PrivateExternal,\n+        _ => bug!()\n     }\n }\n "}, {"sha": "69f61cf97c0b271387ce18fac7eef9d84f23e2c0", "filename": "src/librustc_metadata/encoder.rs", "status": "modified", "additions": 27, "deletions": 17, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/76e2349c4417788e03f877fe18d13b521b455a4b/src%2Flibrustc_metadata%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e2349c4417788e03f877fe18d13b521b455a4b/src%2Flibrustc_metadata%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fencoder.rs?ref=76e2349c4417788e03f877fe18d13b521b455a4b", "patch": "@@ -249,7 +249,7 @@ fn encode_struct_fields(rbml_w: &mut Encoder,\n fn encode_enum_variant_info<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                                       rbml_w: &mut Encoder,\n                                       did: DefId,\n-                                      vis: hir::Visibility,\n+                                      vis: &hir::Visibility,\n                                       index: &mut CrateIndex<'tcx>) {\n     debug!(\"encode_enum_variant_info(did={:?})\", did);\n     let repr_hints = ecx.tcx.lookup_repr_hints(did);\n@@ -355,7 +355,7 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n                        attrs: &[ast::Attribute],\n                        id: NodeId,\n                        name: Name,\n-                       vis: hir::Visibility) {\n+                       vis: &hir::Visibility) {\n     rbml_w.start_tag(tag_items_data_item);\n     encode_def_id_and_key(ecx, rbml_w, ecx.tcx.map.local_def_id(id));\n     encode_family(rbml_w, 'm');\n@@ -383,7 +383,7 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n     encode_deprecation(rbml_w, depr);\n \n     // Encode the reexports of this module, if this module is public.\n-    if vis == hir::Public {\n+    if *vis == hir::Public {\n         debug!(\"(encoding info for module) encoding reexports for {}\", id);\n         encode_reexports(ecx, rbml_w, id);\n     }\n@@ -393,21 +393,31 @@ fn encode_info_for_mod(ecx: &EncodeContext,\n }\n \n fn encode_struct_field_family(rbml_w: &mut Encoder,\n-                              visibility: hir::Visibility) {\n-    encode_family(rbml_w, match visibility {\n-        hir::Public => 'g',\n-        hir::Inherited => 'N'\n-    });\n+                              visibility: ty::Visibility) {\n+    encode_family(rbml_w, if visibility.is_public() { 'g' } else { 'N' });\n }\n \n-fn encode_visibility(rbml_w: &mut Encoder, visibility: hir::Visibility) {\n-    let ch = match visibility {\n-        hir::Public => 'y',\n-        hir::Inherited => 'i',\n-    };\n+fn encode_visibility<T: HasVisibility>(rbml_w: &mut Encoder, visibility: T) {\n+    let ch = if visibility.is_public() { 'y' } else { 'i' };\n     rbml_w.wr_tagged_u8(tag_items_data_item_visibility, ch as u8);\n }\n \n+trait HasVisibility: Sized {\n+    fn is_public(self) -> bool;\n+}\n+\n+impl<'a> HasVisibility for &'a hir::Visibility {\n+    fn is_public(self) -> bool {\n+        *self == hir::Public\n+    }\n+}\n+\n+impl HasVisibility for ty::Visibility {\n+    fn is_public(self) -> bool {\n+        self == ty::Visibility::Public\n+    }\n+}\n+\n fn encode_constness(rbml_w: &mut Encoder, constness: hir::Constness) {\n     rbml_w.start_tag(tag_items_data_item_constness);\n     let ch = match constness {\n@@ -861,7 +871,7 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n     debug!(\"encoding info for item at {}\",\n            tcx.sess.codemap().span_to_string(item.span));\n \n-    let vis = item.vis;\n+    let vis = &item.vis;\n     let def_id = ecx.tcx.map.local_def_id(item.id);\n     let stab = stability::lookup_stability(tcx, ecx.tcx.map.local_def_id(item.id));\n     let depr = stability::lookup_deprecation(tcx, ecx.tcx.map.local_def_id(item.id));\n@@ -932,7 +942,7 @@ fn encode_info_for_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                             &item.attrs,\n                             item.id,\n                             item.name,\n-                            item.vis);\n+                            &item.vis);\n       }\n       hir::ItemForeignMod(ref fm) => {\n         index.record(def_id, rbml_w);\n@@ -1336,7 +1346,7 @@ fn encode_info_for_foreign_item<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n     index.record(def_id, rbml_w);\n     rbml_w.start_tag(tag_items_data_item);\n     encode_def_id_and_key(ecx, rbml_w, def_id);\n-    encode_visibility(rbml_w, nitem.vis);\n+    encode_visibility(rbml_w, &nitem.vis);\n     match nitem.node {\n       hir::ForeignItemFn(ref fndecl, _) => {\n         encode_family(rbml_w, FN_FAMILY);\n@@ -1443,7 +1453,7 @@ fn encode_info_for_items<'a, 'tcx>(ecx: &EncodeContext<'a, 'tcx>,\n                         &[],\n                         CRATE_NODE_ID,\n                         syntax::parse::token::intern(&ecx.link_meta.crate_name),\n-                        hir::Public);\n+                        &hir::Public);\n \n     krate.visit_all_items(&mut EncodeVisitor {\n         index: &mut index,"}, {"sha": "a6ce4cc3ee41a443997e7cf8bf2e3823d63bf351", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 119, "deletions": 114, "changes": 233, "blob_url": "https://github.com/rust-lang/rust/blob/76e2349c4417788e03f877fe18d13b521b455a4b/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e2349c4417788e03f877fe18d13b521b455a4b/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=76e2349c4417788e03f877fe18d13b521b455a4b", "patch": "@@ -382,26 +382,18 @@ struct PrivacyVisitor<'a, 'tcx: 'a> {\n }\n \n impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n-    fn item_is_visible(&self, did: DefId) -> bool {\n-        let visibility = match self.tcx.map.as_local_node_id(did) {\n-            Some(node_id) => self.tcx.map.expect_item(node_id).vis,\n-            None => self.tcx.sess.cstore.visibility(did),\n-        };\n-        visibility == hir::Public || self.private_accessible(did)\n-    }\n-\n-    /// True if `did` is private-accessible\n-    fn private_accessible(&self, did: DefId) -> bool {\n+    fn item_is_accessible(&self, did: DefId) -> bool {\n         match self.tcx.map.as_local_node_id(did) {\n-            Some(node_id) => self.tcx.map.private_item_is_visible_from(node_id, self.curitem),\n-            None => false,\n-        }\n+            Some(node_id) =>\n+                ty::Visibility::from_hir(&self.tcx.map.expect_item(node_id).vis, node_id, self.tcx),\n+            None => self.tcx.sess.cstore.visibility(did),\n+        }.is_accessible_from(self.curitem, &self.tcx.map)\n     }\n \n     // Checks that a field is in scope.\n     fn check_field(&mut self, span: Span, def: ty::AdtDef<'tcx>, field: ty::FieldDef<'tcx>) {\n         if def.adt_kind() == ty::AdtKind::Struct &&\n-                field.vis != hir::Public && !self.private_accessible(def.did) {\n+           !field.vis.is_accessible_from(self.curitem, &self.tcx.map) {\n             span_err!(self.tcx.sess, span, E0451, \"field `{}` of struct `{}` is private\",\n                       field.name, self.tcx.item_path_str(def.did));\n         }\n@@ -412,7 +404,7 @@ impl<'a, 'tcx> PrivacyVisitor<'a, 'tcx> {\n         match self.tcx.impl_or_trait_item(method_def_id).container() {\n             // Trait methods are always all public. The only controlling factor\n             // is whether the trait itself is accessible or not.\n-            ty::TraitContainer(trait_def_id) if !self.item_is_visible(trait_def_id) => {\n+            ty::TraitContainer(trait_def_id) if !self.item_is_accessible(trait_def_id) => {\n                 let msg = format!(\"source trait `{}` is private\",\n                                   self.tcx.item_path_str(trait_def_id));\n                 self.tcx.sess.span_err(span, &msg);\n@@ -464,7 +456,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivacyVisitor<'a, 'tcx> {\n                         _ => expr_ty\n                     }.ty_adt_def().unwrap();\n                     let any_priv = def.struct_variant().fields.iter().any(|f| {\n-                        f.vis != hir::Public && !self.private_accessible(def.did)\n+                        !f.vis.is_accessible_from(self.curitem, &self.tcx.map)\n                     });\n                     if any_priv {\n                         span_err!(self.tcx.sess, expr.span, E0450,\n@@ -548,8 +540,8 @@ impl<'a, 'tcx> SanePrivacyVisitor<'a, 'tcx> {\n     /// Such qualifiers can be set by syntax extensions even if the parser doesn't allow them,\n     /// so we check things like variant fields too.\n     fn check_sane_privacy(&self, item: &hir::Item) {\n-        let check_inherited = |sp, vis, note: &str| {\n-            if vis != hir::Inherited {\n+        let check_inherited = |sp, vis: &hir::Visibility, note: &str| {\n+            if *vis != hir::Inherited {\n                 let mut err = struct_span_err!(self.tcx.sess, sp, E0449,\n                                                \"unnecessary visibility qualifier\");\n                 if !note.is_empty() {\n@@ -561,29 +553,29 @@ impl<'a, 'tcx> SanePrivacyVisitor<'a, 'tcx> {\n \n         match item.node {\n             hir::ItemImpl(_, _, _, Some(..), _, ref impl_items) => {\n-                check_inherited(item.span, item.vis,\n+                check_inherited(item.span, &item.vis,\n                                 \"visibility qualifiers have no effect on trait impls\");\n                 for impl_item in impl_items {\n-                    check_inherited(impl_item.span, impl_item.vis,\n+                    check_inherited(impl_item.span, &impl_item.vis,\n                                     \"visibility qualifiers have no effect on trait impl items\");\n                 }\n             }\n             hir::ItemImpl(_, _, _, None, _, _) => {\n-                check_inherited(item.span, item.vis,\n+                check_inherited(item.span, &item.vis,\n                                 \"place qualifiers on individual methods instead\");\n             }\n             hir::ItemDefaultImpl(..) => {\n-                check_inherited(item.span, item.vis,\n+                check_inherited(item.span, &item.vis,\n                                 \"visibility qualifiers have no effect on trait impls\");\n             }\n             hir::ItemForeignMod(..) => {\n-                check_inherited(item.span, item.vis,\n+                check_inherited(item.span, &item.vis,\n                                 \"place qualifiers on individual functions instead\");\n             }\n             hir::ItemEnum(ref def, _) => {\n                 for variant in &def.variants {\n                     for field in variant.node.data.fields() {\n-                        check_inherited(field.span, field.vis,\n+                        check_inherited(field.span, &field.vis,\n                                         \"visibility qualifiers have no effect on variant fields\");\n                     }\n                 }\n@@ -659,8 +651,8 @@ impl<'a, 'tcx> ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx> {\n         }\n     }\n \n-    fn item_is_public(&self, id: &ast::NodeId, vis: hir::Visibility) -> bool {\n-        self.access_levels.is_reachable(*id) || vis == hir::Public\n+    fn item_is_public(&self, id: &ast::NodeId, vis: &hir::Visibility) -> bool {\n+        self.access_levels.is_reachable(*id) || *vis == hir::Public\n     }\n }\n \n@@ -789,7 +781,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx>\n                                 match impl_item.node {\n                                     hir::ImplItemKind::Const(..) |\n                                     hir::ImplItemKind::Method(..)\n-                                        if self.item_is_public(&impl_item.id, impl_item.vis) =>\n+                                        if self.item_is_public(&impl_item.id, &impl_item.vis) =>\n                                     {\n                                         intravisit::walk_impl_item(self, impl_item)\n                                     }\n@@ -831,14 +823,14 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx>\n                     for impl_item in impl_items {\n                         match impl_item.node {\n                             hir::ImplItemKind::Const(..) => {\n-                                if self.item_is_public(&impl_item.id, impl_item.vis) {\n+                                if self.item_is_public(&impl_item.id, &impl_item.vis) {\n                                     found_pub_static = true;\n                                     intravisit::walk_impl_item(self, impl_item);\n                                 }\n                             }\n                             hir::ImplItemKind::Method(ref sig, _) => {\n                                 if sig.explicit_self.node == hir::SelfStatic &&\n-                                      self.item_is_public(&impl_item.id, impl_item.vis) {\n+                                      self.item_is_public(&impl_item.id, &impl_item.vis) {\n                                     found_pub_static = true;\n                                     intravisit::walk_impl_item(self, impl_item);\n                                 }\n@@ -858,7 +850,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx>\n             hir::ItemTy(..) => return,\n \n             // not at all public, so we don't care\n-            _ if !self.item_is_public(&item.id, item.vis) => {\n+            _ if !self.item_is_public(&item.id, &item.vis) => {\n                 return;\n             }\n \n@@ -944,27 +936,41 @@ impl<'a, 'tcx, 'v> Visitor<'v> for ObsoleteVisiblePrivateTypesVisitor<'a, 'tcx>\n \n struct SearchInterfaceForPrivateItemsVisitor<'a, 'tcx: 'a> {\n     tcx: &'a TyCtxt<'tcx>,\n-    // Do not report an error when a private type is found\n-    is_quiet: bool,\n-    // Is private component found?\n-    is_public: bool,\n+    /// The visitor checks that each component type is at least this visible\n+    required_visibility: ty::Visibility,\n+    /// The visibility of the least visible component that has been visited\n+    min_visibility: ty::Visibility,\n     old_error_set: &'a NodeSet,\n }\n \n impl<'a, 'tcx: 'a> SearchInterfaceForPrivateItemsVisitor<'a, 'tcx> {\n-    // Check if the type alias contain private types when substituted\n-    fn is_public_type_alias(&self, item: &hir::Item, path: &hir::Path) -> bool {\n+    fn new(tcx: &'a TyCtxt<'tcx>, old_error_set: &'a NodeSet) -> Self {\n+        SearchInterfaceForPrivateItemsVisitor {\n+            tcx: tcx,\n+            min_visibility: ty::Visibility::Public,\n+            required_visibility: ty::Visibility::PrivateExternal,\n+            old_error_set: old_error_set,\n+        }\n+    }\n+}\n+\n+impl<'a, 'tcx: 'a> SearchInterfaceForPrivateItemsVisitor<'a, 'tcx> {\n+    // Return the visibility of the type alias's least visible component type when substituted\n+    fn substituted_alias_visibility(&self, item: &hir::Item, path: &hir::Path)\n+                                    -> Option<ty::Visibility> {\n         // We substitute type aliases only when determining impl publicity\n         // FIXME: This will probably change and all type aliases will be substituted,\n         // requires an amendment to RFC 136.\n-        if !self.is_quiet {\n-            return false\n+        if self.required_visibility != ty::Visibility::PrivateExternal {\n+            return None;\n         }\n         // Type alias is considered public if the aliased type is\n         // public, even if the type alias itself is private. So, something\n         // like `type A = u8; pub fn f() -> A {...}` doesn't cause an error.\n         if let hir::ItemTy(ref ty, ref generics) = item.node {\n-            let mut check = SearchInterfaceForPrivateItemsVisitor { is_public: true, ..*self };\n+            let mut check = SearchInterfaceForPrivateItemsVisitor {\n+                min_visibility: ty::Visibility::Public, ..*self\n+            };\n             check.visit_ty(ty);\n             // If a private type alias with default type parameters is used in public\n             // interface we must ensure, that the defaults are public if they are actually used.\n@@ -978,26 +984,23 @@ impl<'a, 'tcx: 'a> SearchInterfaceForPrivateItemsVisitor<'a, 'tcx> {\n                     check.visit_ty(default_ty);\n                 }\n             }\n-            check.is_public\n+            Some(check.min_visibility)\n         } else {\n-            false\n+            None\n         }\n     }\n }\n \n impl<'a, 'tcx: 'a, 'v> Visitor<'v> for SearchInterfaceForPrivateItemsVisitor<'a, 'tcx> {\n     fn visit_ty(&mut self, ty: &hir::Ty) {\n-        if self.is_quiet && !self.is_public {\n-            // We are in quiet mode and a private type is already found, no need to proceed\n-            return\n-        }\n         if let hir::TyPath(_, ref path) = ty.node {\n             let def = self.tcx.def_map.borrow().get(&ty.id).unwrap().full_def();\n             match def {\n                 Def::PrimTy(..) | Def::SelfTy(..) | Def::TyParam(..) => {\n                     // Public\n                 }\n-                Def::AssociatedTy(..) if self.is_quiet => {\n+                Def::AssociatedTy(..)\n+                    if self.required_visibility == ty::Visibility::PrivateExternal => {\n                     // Conservatively approximate the whole type alias as public without\n                     // recursing into its components when determining impl publicity.\n                     // For example, `impl <Type as Trait>::Alias {...}` may be a public impl\n@@ -1011,21 +1014,24 @@ impl<'a, 'tcx: 'a, 'v> Visitor<'v> for SearchInterfaceForPrivateItemsVisitor<'a,\n                     // Non-local means public (private items can't leave their crate, modulo bugs)\n                     if let Some(node_id) = self.tcx.map.as_local_node_id(def_id) {\n                         let item = self.tcx.map.expect_item(node_id);\n-                        if item.vis != hir::Public && !self.is_public_type_alias(item, path) {\n-                            if !self.is_quiet {\n-                                if self.old_error_set.contains(&ty.id) {\n-                                    span_err!(self.tcx.sess, ty.span, E0446,\n-                                              \"private type in public interface\");\n-                                } else {\n-                                    self.tcx.sess.add_lint (\n-                                        lint::builtin::PRIVATE_IN_PUBLIC,\n-                                        node_id,\n-                                        ty.span,\n-                                        format!(\"private type in public interface\"),\n-                                    );\n-                                }\n+                        let vis = match self.substituted_alias_visibility(item, path) {\n+                            Some(vis) => vis,\n+                            None => ty::Visibility::from_hir(&item.vis, node_id, &self.tcx),\n+                        };\n+\n+                        if !vis.is_at_least(self.min_visibility, &self.tcx.map) {\n+                            self.min_visibility = vis;\n+                        }\n+                        if !vis.is_at_least(self.required_visibility, &self.tcx.map) {\n+                            if self.old_error_set.contains(&ty.id) {\n+                                span_err!(self.tcx.sess, ty.span, E0446,\n+                                          \"private type in public interface\");\n+                            } else {\n+                                self.tcx.sess.add_lint(lint::builtin::PRIVATE_IN_PUBLIC,\n+                                                       node_id,\n+                                                       ty.span,\n+                                                       format!(\"private type in public interface\"));\n                             }\n-                            self.is_public = false;\n                         }\n                     }\n                 }\n@@ -1037,28 +1043,26 @@ impl<'a, 'tcx: 'a, 'v> Visitor<'v> for SearchInterfaceForPrivateItemsVisitor<'a,\n     }\n \n     fn visit_trait_ref(&mut self, trait_ref: &hir::TraitRef) {\n-        if self.is_quiet && !self.is_public {\n-            // We are in quiet mode and a private type is already found, no need to proceed\n-            return\n-        }\n         // Non-local means public (private items can't leave their crate, modulo bugs)\n         let def_id = self.tcx.trait_ref_to_def_id(trait_ref);\n         if let Some(node_id) = self.tcx.map.as_local_node_id(def_id) {\n             let item = self.tcx.map.expect_item(node_id);\n-            if item.vis != hir::Public {\n-                if !self.is_quiet {\n-                    if self.old_error_set.contains(&trait_ref.ref_id) {\n-                        span_err!(self.tcx.sess, trait_ref.path.span, E0445,\n-                                  \"private trait in public interface\");\n-                    } else {\n-                        self.tcx.sess.add_lint(lint::builtin::PRIVATE_IN_PUBLIC,\n-                                               node_id,\n-                                               trait_ref.path.span,\n-                                               \"private trait in public interface (error E0445)\"\n-                                                    .to_string());\n-                    }\n+            let vis = ty::Visibility::from_hir(&item.vis, node_id, &self.tcx);\n+\n+            if !vis.is_at_least(self.min_visibility, &self.tcx.map) {\n+                self.min_visibility = vis;\n+            }\n+            if !vis.is_at_least(self.required_visibility, &self.tcx.map) {\n+                if self.old_error_set.contains(&trait_ref.ref_id) {\n+                    span_err!(self.tcx.sess, trait_ref.path.span, E0445,\n+                              \"private trait in public interface\");\n+                } else {\n+                    self.tcx.sess.add_lint(lint::builtin::PRIVATE_IN_PUBLIC,\n+                                           node_id,\n+                                           trait_ref.path.span,\n+                                           \"private trait in public interface (error E0445)\"\n+                                                .to_string());\n                 }\n-                self.is_public = false;\n             }\n         }\n \n@@ -1080,29 +1084,29 @@ struct PrivateItemsInPublicInterfacesVisitor<'a, 'tcx: 'a> {\n \n impl<'a, 'tcx> PrivateItemsInPublicInterfacesVisitor<'a, 'tcx> {\n     // A type is considered public if it doesn't contain any private components\n-    fn is_public_ty(&self, ty: &hir::Ty) -> bool {\n-        let mut check = SearchInterfaceForPrivateItemsVisitor {\n-            tcx: self.tcx, is_quiet: true, is_public: true, old_error_set: self.old_error_set\n-        };\n+    fn ty_visibility(&self, ty: &hir::Ty) -> ty::Visibility {\n+        let mut check = SearchInterfaceForPrivateItemsVisitor::new(self.tcx, self.old_error_set);\n         check.visit_ty(ty);\n-        check.is_public\n+        check.min_visibility\n     }\n \n     // A trait reference is considered public if it doesn't contain any private components\n-    fn is_public_trait_ref(&self, trait_ref: &hir::TraitRef) -> bool {\n-        let mut check = SearchInterfaceForPrivateItemsVisitor {\n-            tcx: self.tcx, is_quiet: true, is_public: true, old_error_set: self.old_error_set\n-        };\n+    fn trait_ref_visibility(&self, trait_ref: &hir::TraitRef) -> ty::Visibility {\n+        let mut check = SearchInterfaceForPrivateItemsVisitor::new(self.tcx, self.old_error_set);\n         check.visit_trait_ref(trait_ref);\n-        check.is_public\n+        check.min_visibility\n     }\n }\n \n impl<'a, 'tcx, 'v> Visitor<'v> for PrivateItemsInPublicInterfacesVisitor<'a, 'tcx> {\n     fn visit_item(&mut self, item: &hir::Item) {\n-        let mut check = SearchInterfaceForPrivateItemsVisitor {\n-            tcx: self.tcx, is_quiet: false, is_public: true, old_error_set: self.old_error_set\n+        let min = |vis1: ty::Visibility, vis2| {\n+            if vis1.is_at_least(vis2, &self.tcx.map) { vis2 } else { vis1 }\n         };\n+\n+        let mut check = SearchInterfaceForPrivateItemsVisitor::new(self.tcx, self.old_error_set);\n+        let item_visibility = ty::Visibility::from_hir(&item.vis, item.id, &self.tcx);\n+\n         match item.node {\n             // Crates are always public\n             hir::ItemExternCrate(..) => {}\n@@ -1113,51 +1117,52 @@ impl<'a, 'tcx, 'v> Visitor<'v> for PrivateItemsInPublicInterfacesVisitor<'a, 'tc\n             // Subitems of these items have inherited publicity\n             hir::ItemConst(..) | hir::ItemStatic(..) | hir::ItemFn(..) |\n             hir::ItemEnum(..) | hir::ItemTrait(..) | hir::ItemTy(..) => {\n-                if item.vis == hir::Public {\n-                    check.visit_item(item);\n-                }\n+                check.required_visibility = item_visibility;\n+                check.visit_item(item);\n             }\n             // Subitems of foreign modules have their own publicity\n             hir::ItemForeignMod(ref foreign_mod) => {\n                 for foreign_item in &foreign_mod.items {\n-                    if foreign_item.vis == hir::Public {\n-                        check.visit_foreign_item(foreign_item);\n-                    }\n+                    check.required_visibility =\n+                        ty::Visibility::from_hir(&foreign_item.vis, item.id, &self.tcx);\n+                    check.visit_foreign_item(foreign_item);\n                 }\n             }\n             // Subitems of structs have their own publicity\n             hir::ItemStruct(ref struct_def, ref generics) => {\n-                if item.vis == hir::Public {\n-                    check.visit_generics(generics);\n-                    for field in struct_def.fields() {\n-                        if field.vis == hir::Public {\n-                            check.visit_struct_field(field);\n-                        }\n-                    }\n+                check.required_visibility = item_visibility;\n+                check.visit_generics(generics);\n+\n+                for field in struct_def.fields() {\n+                    let field_visibility = ty::Visibility::from_hir(&field.vis, item.id, &self.tcx);\n+                    check.required_visibility = min(item_visibility, field_visibility);\n+                    check.visit_struct_field(field);\n                 }\n             }\n             // The interface is empty\n             hir::ItemDefaultImpl(..) => {}\n             // An inherent impl is public when its type is public\n             // Subitems of inherent impls have their own publicity\n             hir::ItemImpl(_, _, ref generics, None, ref ty, ref impl_items) => {\n-                if self.is_public_ty(ty) {\n-                    check.visit_generics(generics);\n-                    for impl_item in impl_items {\n-                        if impl_item.vis == hir::Public {\n-                            check.visit_impl_item(impl_item);\n-                        }\n-                    }\n+                let ty_vis = self.ty_visibility(ty);\n+                check.required_visibility = ty_vis;\n+                check.visit_generics(generics);\n+\n+                for impl_item in impl_items {\n+                    let impl_item_vis =\n+                        ty::Visibility::from_hir(&impl_item.vis, item.id, &self.tcx);\n+                    check.required_visibility = min(impl_item_vis, ty_vis);\n+                    check.visit_impl_item(impl_item);\n                 }\n             }\n             // A trait impl is public when both its type and its trait are public\n             // Subitems of trait impls have inherited publicity\n             hir::ItemImpl(_, _, ref generics, Some(ref trait_ref), ref ty, ref impl_items) => {\n-                if self.is_public_ty(ty) && self.is_public_trait_ref(trait_ref) {\n-                    check.visit_generics(generics);\n-                    for impl_item in impl_items {\n-                        check.visit_impl_item(impl_item);\n-                    }\n+                let vis = min(self.ty_visibility(ty), self.trait_ref_visibility(trait_ref));\n+                check.required_visibility = vis;\n+                check.visit_generics(generics);\n+                for impl_item in impl_items {\n+                    check.visit_impl_item(impl_item);\n                 }\n             }\n         }"}, {"sha": "003450cd6fd7984b81d3e1add6f333175828b371", "filename": "src/librustc_resolve/build_reduced_graph.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/76e2349c4417788e03f877fe18d13b521b455a4b/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e2349c4417788e03f877fe18d13b521b455a4b/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_resolve%2Fbuild_reduced_graph.rs?ref=76e2349c4417788e03f877fe18d13b521b455a4b", "patch": "@@ -26,7 +26,7 @@ use rustc::middle::cstore::{CrateStore, ChildItem, DlDef};\n use rustc::lint;\n use rustc::hir::def::*;\n use rustc::hir::def_id::{CRATE_DEF_INDEX, DefId};\n-use rustc::ty::VariantKind;\n+use rustc::ty::{self, VariantKind};\n \n use syntax::ast::Name;\n use syntax::attr::AttrMetaMethods;\n@@ -434,7 +434,7 @@ impl<'b, 'tcx:'b> Resolver<'b, 'tcx> {\n         }\n \n         let name = xcdef.name;\n-        let is_public = xcdef.vis == hir::Public || parent.is_trait();\n+        let is_public = xcdef.vis == ty::Visibility::Public || parent.is_trait();\n \n         let mut modifiers = DefModifiers::empty();\n         if is_public {"}, {"sha": "31d95af4fbb9c4b416b25d031f4b9cf58fcc35cf", "filename": "src/librustc_typeck/check/method/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/76e2349c4417788e03f877fe18d13b521b455a4b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e2349c4417788e03f877fe18d13b521b455a4b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fmod.rs?ref=76e2349c4417788e03f877fe18d13b521b455a4b", "patch": "@@ -343,7 +343,7 @@ pub fn resolve_ufcs<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n     let def = pick.item.def();\n \n     if let probe::InherentImplPick = pick.kind {\n-        if pick.item.vis() != hir::Public && !fcx.private_item_is_visible(def.def_id()) {\n+        if !pick.item.vis().is_accessible_from(fcx.body_id, &fcx.tcx().map) {\n             let msg = format!(\"{} `{}` is private\", def.kind_name(), &method_name.as_str());\n             fcx.tcx().sess.span_err(span, &msg);\n         }"}, {"sha": "0ffbbfea84ef0c5c946e18ce335bf3b26212926e", "filename": "src/librustc_typeck/check/method/probe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/76e2349c4417788e03f877fe18d13b521b455a4b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e2349c4417788e03f877fe18d13b521b455a4b/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmethod%2Fprobe.rs?ref=76e2349c4417788e03f877fe18d13b521b455a4b", "patch": "@@ -412,7 +412,7 @@ impl<'a,'tcx> ProbeContext<'a,'tcx> {\n             return self.record_static_candidate(ImplSource(impl_def_id));\n         }\n \n-        if item.vis() != hir::Public && !self.fcx.private_item_is_visible(item.def_id()) {\n+        if !item.vis().is_accessible_from(self.fcx.body_id, &self.tcx().map) {\n             self.private_candidate = Some(item.def());\n             return\n         }"}, {"sha": "45877d7099bbf70de70ed88ecbb0b4c3bc973ddb", "filename": "src/librustc_typeck/check/mod.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/76e2349c4417788e03f877fe18d13b521b455a4b/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e2349c4417788e03f877fe18d13b521b455a4b/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcheck%2Fmod.rs?ref=76e2349c4417788e03f877fe18d13b521b455a4b", "patch": "@@ -95,7 +95,7 @@ use rustc::traits::{self, report_fulfillment_errors, ProjectionMode};\n use rustc::ty::{GenericPredicates, TypeScheme};\n use rustc::ty::{ParamTy, ParameterEnvironment};\n use rustc::ty::{LvaluePreference, NoPreference, PreferMutLvalue};\n-use rustc::ty::{self, ToPolyTraitRef, Ty, TyCtxt};\n+use rustc::ty::{self, ToPolyTraitRef, Ty, TyCtxt, Visibility};\n use rustc::ty::{MethodCall, MethodCallee};\n use rustc::ty::adjustment;\n use rustc::ty::error::TypeError;\n@@ -125,8 +125,7 @@ use syntax::ptr::P;\n use syntax::util::lev_distance::find_best_match_for_name;\n \n use rustc::hir::intravisit::{self, Visitor};\n-use rustc::hir;\n-use rustc::hir::{Visibility, PatKind};\n+use rustc::hir::{self, PatKind};\n use rustc::hir::print as pprust;\n use rustc_back::slice;\n use rustc_const_eval::eval_repeat_count;\n@@ -2055,13 +2054,6 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             Err(errors) => { report_fulfillment_errors(self.infcx(), &errors); }\n         }\n     }\n-\n-    fn private_item_is_visible(&self, def_id: DefId) -> bool {\n-        match self.tcx().map.as_local_node_id(def_id) {\n-            Some(node_id) => self.tcx().map.private_item_is_visible_from(node_id, self.body_id),\n-            None => false, // Private items from other crates are never visible\n-        }\n-    }\n }\n \n impl<'a, 'tcx> RegionScope for FnCtxt<'a, 'tcx> {\n@@ -2967,7 +2959,7 @@ fn check_expr_with_expectation_and_lvalue_pref<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                     debug!(\"struct named {:?}\",  base_t);\n                     if let Some(field) = base_def.struct_variant().find_field_named(field.node) {\n                         let field_ty = fcx.field_ty(expr.span, field, substs);\n-                        if field.vis == hir::Public || fcx.private_item_is_visible(base_def.did) {\n+                        if field.vis.is_accessible_from(fcx.body_id, &fcx.tcx().map) {\n                             return Some(field_ty);\n                         }\n                         private_candidate = Some((base_def.did, field_ty));\n@@ -3079,7 +3071,7 @@ fn check_expr_with_expectation_and_lvalue_pref<'a, 'tcx>(fcx: &FnCtxt<'a, 'tcx>,\n                 debug!(\"tuple struct named {:?}\",  base_t);\n                 if let Some(field) = base_def.struct_variant().fields.get(idx.node) {\n                     let field_ty = fcx.field_ty(expr.span, field, substs);\n-                    if field.vis == hir::Public || fcx.private_item_is_visible(base_def.did) {\n+                    if field.vis.is_accessible_from(fcx.body_id, &fcx.tcx().map) {\n                         return Some(field_ty);\n                     }\n                     private_candidate = Some((base_def.did, field_ty));"}, {"sha": "2e1a684684375714582094cfcf31023371eb8e6b", "filename": "src/librustc_typeck/collect.rs", "status": "modified", "additions": 19, "deletions": 28, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/76e2349c4417788e03f877fe18d13b521b455a4b/src%2Flibrustc_typeck%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e2349c4417788e03f877fe18d13b521b455a4b/src%2Flibrustc_typeck%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_typeck%2Fcollect.rs?ref=76e2349c4417788e03f877fe18d13b521b455a4b", "patch": "@@ -532,7 +532,7 @@ fn convert_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                             container: ImplOrTraitItemContainer,\n                             name: ast::Name,\n                             id: ast::NodeId,\n-                            vis: hir::Visibility,\n+                            vis: &hir::Visibility,\n                             sig: &hir::MethodSig,\n                             defaultness: hir::Defaultness,\n                             untransformed_rcvr_ty: Ty<'tcx>,\n@@ -555,7 +555,7 @@ fn convert_method<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                     ty_generic_predicates,\n                                     fty,\n                                     explicit_self_category,\n-                                    vis,\n+                                    ty::Visibility::from_hir(vis, id, ccx.tcx),\n                                     defaultness,\n                                     def_id,\n                                     container);\n@@ -602,7 +602,7 @@ fn convert_associated_const<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                       container: ImplOrTraitItemContainer,\n                                       name: ast::Name,\n                                       id: ast::NodeId,\n-                                      vis: hir::Visibility,\n+                                      vis: &hir::Visibility,\n                                       defaultness: hir::Defaultness,\n                                       ty: ty::Ty<'tcx>,\n                                       has_value: bool)\n@@ -614,7 +614,7 @@ fn convert_associated_const<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n \n     let associated_const = Rc::new(ty::AssociatedConst {\n         name: name,\n-        vis: vis,\n+        vis: ty::Visibility::from_hir(vis, id, ccx.tcx),\n         defaultness: defaultness,\n         def_id: ccx.tcx.map.local_def_id(id),\n         container: container,\n@@ -629,13 +629,13 @@ fn convert_associated_type<'a, 'tcx>(ccx: &CrateCtxt<'a, 'tcx>,\n                                      container: ImplOrTraitItemContainer,\n                                      name: ast::Name,\n                                      id: ast::NodeId,\n-                                     vis: hir::Visibility,\n+                                     vis: &hir::Visibility,\n                                      defaultness: hir::Defaultness,\n                                      ty: Option<Ty<'tcx>>)\n {\n     let associated_type = Rc::new(ty::AssociatedType {\n         name: name,\n-        vis: vis,\n+        vis: ty::Visibility::from_hir(vis, id, ccx.tcx),\n         defaultness: defaultness,\n         ty: ty,\n         def_id: ccx.tcx.map.local_def_id(id),\n@@ -738,17 +738,6 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n             tcx.predicates.borrow_mut().insert(def_id, ty_predicates.clone());\n \n \n-            // If there is a trait reference, treat the methods as always public.\n-            // This is to work around some incorrect behavior in privacy checking:\n-            // when the method belongs to a trait, it should acquire the privacy\n-            // from the trait, not the impl. Forcing the visibility to be public\n-            // makes things sorta work.\n-            let parent_visibility = if opt_trait_ref.is_some() {\n-                hir::Public\n-            } else {\n-                it.vis\n-            };\n-\n             // Convert all the associated consts.\n             // Also, check if there are any duplicate associated items\n             let mut seen_type_items = FnvHashSet();\n@@ -771,9 +760,12 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n                                                generics: ty_generics.clone(),\n                                                ty: ty,\n                                            });\n+                    // Trait-associated constants are always public.\n+                    let public = &hir::Public;\n+                    let visibility = if opt_trait_ref.is_some() { public } else { &impl_item.vis };\n                     convert_associated_const(ccx, ImplContainer(def_id),\n                                              impl_item.name, impl_item.id,\n-                                             impl_item.vis.inherit_from(parent_visibility),\n+                                             visibility,\n                                              impl_item.defaultness,\n                                              ty, true /* has_value */);\n                 }\n@@ -790,18 +782,16 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n                     let typ = ccx.icx(&ty_predicates).to_ty(&ExplicitRscope, ty);\n \n                     convert_associated_type(ccx, ImplContainer(def_id),\n-                                            impl_item.name, impl_item.id, impl_item.vis,\n+                                            impl_item.name, impl_item.id, &impl_item.vis,\n                                             impl_item.defaultness, Some(typ));\n                 }\n             }\n \n             for impl_item in impl_items {\n                 if let hir::ImplItemKind::Method(ref sig, _) = impl_item.node {\n-                    // if the method specifies a visibility, use that, otherwise\n-                    // inherit the visibility from the impl (so `foo` in `pub impl\n-                    // { fn foo(); }` is public, but private in `impl { fn\n-                    // foo(); }`).\n-                    let method_vis = impl_item.vis.inherit_from(parent_visibility);\n+                    // Trait methods are always public.\n+                    let public = &hir::Public;\n+                    let method_vis = if opt_trait_ref.is_some() { public } else { &impl_item.vis };\n \n                     convert_method(ccx, ImplContainer(def_id),\n                                    impl_item.name, impl_item.id, method_vis,\n@@ -839,7 +829,7 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n                                              container,\n                                              trait_item.name,\n                                              trait_item.id,\n-                                             hir::Public,\n+                                             &hir::Public,\n                                              hir::Defaultness::Default,\n                                              ty,\n                                              default.is_some())\n@@ -857,7 +847,7 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n                                             container,\n                                             trait_item.name,\n                                             trait_item.id,\n-                                            hir::Public,\n+                                            &hir::Public,\n                                             hir::Defaultness::Default,\n                                             typ);\n                 }\n@@ -870,7 +860,7 @@ fn convert_item(ccx: &CrateCtxt, it: &hir::Item) {\n                                    container,\n                                    trait_item.name,\n                                    trait_item.id,\n-                                   hir::Inherited,\n+                                   &hir::Inherited,\n                                    sig,\n                                    hir::Defaultness::Default,\n                                    tcx.mk_self_type(),\n@@ -987,6 +977,7 @@ fn convert_struct_variant<'tcx>(tcx: &TyCtxt<'tcx>,\n                                 disr_val: ty::Disr,\n                                 def: &hir::VariantData) -> ty::VariantDefData<'tcx, 'tcx> {\n     let mut seen_fields: FnvHashMap<ast::Name, Span> = FnvHashMap();\n+    let node_id = tcx.map.as_local_node_id(did).unwrap();\n     let fields = def.fields().iter().map(|f| {\n         let fid = tcx.map.local_def_id(f.id);\n         let dup_span = seen_fields.get(&f.name).cloned();\n@@ -1000,7 +991,7 @@ fn convert_struct_variant<'tcx>(tcx: &TyCtxt<'tcx>,\n             seen_fields.insert(f.name, f.span);\n         }\n \n-        ty::FieldDefData::new(fid, f.name, f.vis)\n+        ty::FieldDefData::new(fid, f.name, ty::Visibility::from_hir(&f.vis, node_id, tcx))\n     }).collect();\n     ty::VariantDefData {\n         did: did,"}, {"sha": "850975498269bc4a31382f06455a15ed547f138c", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/76e2349c4417788e03f877fe18d13b521b455a4b/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e2349c4417788e03f877fe18d13b521b455a4b/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=76e2349c4417788e03f877fe18d13b521b455a4b", "patch": "@@ -361,7 +361,7 @@ pub fn build_impl(cx: &DocContext,\n                 })\n             }\n             ty::MethodTraitItem(method) => {\n-                if method.vis != hir::Public && associated_trait.is_none() {\n+                if method.vis != ty::Visibility::Public && associated_trait.is_none() {\n                     return None\n                 }\n                 let mut item = method.clean(cx);\n@@ -471,7 +471,7 @@ fn build_module(cx: &DocContext, tcx: &TyCtxt,\n                 cstore::DlDef(Def::ForeignMod(did)) => {\n                     fill_in(cx, tcx, did, items);\n                 }\n-                cstore::DlDef(def) if item.vis == hir::Public => {\n+                cstore::DlDef(def) if item.vis == ty::Visibility::Public => {\n                     if !visited.insert(def) { continue }\n                     if let Some(i) = try_inline_def(cx, tcx, def) {\n                         items.extend(i)"}, {"sha": "673aa17ecd1455b89c4ae2f2851ef26727447e9a", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/76e2349c4417788e03f877fe18d13b521b455a4b/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e2349c4417788e03f877fe18d13b521b455a4b/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=76e2349c4417788e03f877fe18d13b521b455a4b", "patch": "@@ -1754,7 +1754,7 @@ impl Clean<Item> for hir::StructField {\n             name: Some(self.name).clean(cx),\n             attrs: self.attrs.clean(cx),\n             source: self.span.clean(cx),\n-            visibility: Some(self.vis),\n+            visibility: self.vis.clean(cx),\n             stability: get_stability(cx, cx.map.local_def_id(self.id)),\n             deprecation: get_deprecation(cx, cx.map.local_def_id(self.id)),\n             def_id: cx.map.local_def_id(self.id),\n@@ -1771,7 +1771,7 @@ impl<'tcx> Clean<Item> for ty::FieldDefData<'tcx, 'static> {\n             name: Some(self.name).clean(cx),\n             attrs: attr_map.get(&self.did).unwrap_or(&Vec::new()).clean(cx),\n             source: Span::empty(),\n-            visibility: Some(self.vis),\n+            visibility: self.vis.clean(cx),\n             stability: get_stability(cx, self.did),\n             deprecation: get_deprecation(cx, self.did),\n             def_id: self.did,\n@@ -1784,7 +1784,13 @@ pub type Visibility = hir::Visibility;\n \n impl Clean<Option<Visibility>> for hir::Visibility {\n     fn clean(&self, _: &DocContext) -> Option<Visibility> {\n-        Some(*self)\n+        Some(self.clone())\n+    }\n+}\n+\n+impl Clean<Option<Visibility>> for ty::Visibility {\n+    fn clean(&self, _: &DocContext) -> Option<Visibility> {\n+        Some(if *self == ty::Visibility::Public { hir::Public } else { hir::Inherited })\n     }\n }\n \n@@ -1902,7 +1908,7 @@ impl<'tcx> Clean<Item> for ty::VariantDefData<'tcx, 'static> {\n                             source: Span::empty(),\n                             name: Some(field.name.clean(cx)),\n                             attrs: cx.tcx().get_attrs(field.did).clean(cx),\n-                            visibility: Some(field.vis),\n+                            visibility: field.vis.clean(cx),\n                             def_id: field.did,\n                             stability: get_stability(cx, field.did),\n                             deprecation: get_deprecation(cx, field.did),"}, {"sha": "ce20ad05acb0e05cc730d1b4d644227bd1f31f0c", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/76e2349c4417788e03f877fe18d13b521b455a4b/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e2349c4417788e03f877fe18d13b521b455a4b/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=76e2349c4417788e03f877fe18d13b521b455a4b", "patch": "@@ -31,7 +31,7 @@ use html::render::{cache, CURRENT_LOCATION_KEY};\n /// Helper to render an optional visibility with a space after it (if the\n /// visibility is preset)\n #[derive(Copy, Clone)]\n-pub struct VisSpace(pub Option<hir::Visibility>);\n+pub struct VisSpace<'a>(pub &'a Option<hir::Visibility>);\n /// Similarly to VisSpace, this structure is used to render a function style with a\n /// space after it.\n #[derive(Copy, Clone)]\n@@ -56,9 +56,9 @@ pub struct TyParamBounds<'a>(pub &'a [clean::TyParamBound]);\n pub struct CommaSep<'a, T: 'a>(pub &'a [T]);\n pub struct AbiSpace(pub Abi);\n \n-impl VisSpace {\n-    pub fn get(&self) -> Option<hir::Visibility> {\n-        let VisSpace(v) = *self; v\n+impl<'a> VisSpace<'a> {\n+    pub fn get(self) -> &'a Option<hir::Visibility> {\n+        let VisSpace(v) = self; v\n     }\n }\n \n@@ -636,9 +636,9 @@ impl<'a> fmt::Display for Method<'a> {\n     }\n }\n \n-impl fmt::Display for VisSpace {\n+impl<'a> fmt::Display for VisSpace<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match self.get() {\n+        match *self.get() {\n             Some(hir::Public) => write!(f, \"pub \"),\n             Some(hir::Inherited) | None => Ok(())\n         }"}, {"sha": "c5850089578cd059a051adde3a952496837b84d7", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/76e2349c4417788e03f877fe18d13b521b455a4b/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e2349c4417788e03f877fe18d13b521b455a4b/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=76e2349c4417788e03f877fe18d13b521b455a4b", "patch": "@@ -1714,21 +1714,21 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n                 match *src {\n                     Some(ref src) => {\n                         write!(w, \"<tr><td><code>{}extern crate {} as {};\",\n-                               VisSpace(myitem.visibility),\n+                               VisSpace(&myitem.visibility),\n                                src,\n                                name)?\n                     }\n                     None => {\n                         write!(w, \"<tr><td><code>{}extern crate {};\",\n-                               VisSpace(myitem.visibility), name)?\n+                               VisSpace(&myitem.visibility), name)?\n                     }\n                 }\n                 write!(w, \"</code></td></tr>\")?;\n             }\n \n             clean::ImportItem(ref import) => {\n                 write!(w, \"<tr><td><code>{}{}</code></td></tr>\",\n-                       VisSpace(myitem.visibility), *import)?;\n+                       VisSpace(&myitem.visibility), *import)?;\n             }\n \n             _ => {\n@@ -1831,7 +1831,7 @@ fn item_constant(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n                  c: &clean::Constant) -> fmt::Result {\n     write!(w, \"<pre class='rust const'>{vis}const \\\n                {name}: {typ}{init}</pre>\",\n-           vis = VisSpace(it.visibility),\n+           vis = VisSpace(&it.visibility),\n            name = it.name.as_ref().unwrap(),\n            typ = c.type_,\n            init = Initializer(&c.expr))?;\n@@ -1842,7 +1842,7 @@ fn item_static(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n                s: &clean::Static) -> fmt::Result {\n     write!(w, \"<pre class='rust static'>{vis}static {mutability}\\\n                {name}: {typ}{init}</pre>\",\n-           vis = VisSpace(it.visibility),\n+           vis = VisSpace(&it.visibility),\n            mutability = MutableSpace(s.mutability),\n            name = it.name.as_ref().unwrap(),\n            typ = s.type_,\n@@ -1859,7 +1859,7 @@ fn item_function(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     };\n     write!(w, \"<pre class='rust fn'>{vis}{constness}{unsafety}{abi}fn \\\n                {name}{generics}{decl}{where_clause}</pre>\",\n-           vis = VisSpace(it.visibility),\n+           vis = VisSpace(&it.visibility),\n            constness = ConstnessSpace(vis_constness),\n            unsafety = UnsafetySpace(f.unsafety),\n            abi = AbiSpace(f.abi),\n@@ -1887,7 +1887,7 @@ fn item_trait(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n \n     // Output the trait definition\n     write!(w, \"<pre class='rust trait'>{}{}trait {}{}{}{} \",\n-           VisSpace(it.visibility),\n+           VisSpace(&it.visibility),\n            UnsafetySpace(t.unsafety),\n            it.name.as_ref().unwrap(),\n            t.generics,\n@@ -2214,7 +2214,7 @@ fn item_enum(w: &mut fmt::Formatter, cx: &Context, it: &clean::Item,\n     write!(w, \"<pre class='rust enum'>\")?;\n     render_attributes(w, it)?;\n     write!(w, \"{}enum {}{}{}\",\n-           VisSpace(it.visibility),\n+           VisSpace(&it.visibility),\n            it.name.as_ref().unwrap(),\n            e.generics,\n            WhereClause(&e.generics))?;\n@@ -2326,7 +2326,7 @@ fn render_struct(w: &mut fmt::Formatter, it: &clean::Item,\n                  tab: &str,\n                  structhead: bool) -> fmt::Result {\n     write!(w, \"{}{}{}\",\n-           VisSpace(it.visibility),\n+           VisSpace(&it.visibility),\n            if structhead {\"struct \"} else {\"\"},\n            it.name.as_ref().unwrap())?;\n     if let Some(g) = g {\n@@ -2338,7 +2338,7 @@ fn render_struct(w: &mut fmt::Formatter, it: &clean::Item,\n             for field in fields {\n                 if let clean::StructFieldItem(ref ty) = field.inner {\n                     write!(w, \"    {}{}: {},\\n{}\",\n-                           VisSpace(field.visibility),\n+                           VisSpace(&field.visibility),\n                            field.name.as_ref().unwrap(),\n                            *ty,\n                            tab)?;\n@@ -2361,7 +2361,7 @@ fn render_struct(w: &mut fmt::Formatter, it: &clean::Item,\n                         write!(w, \"_\")?\n                     }\n                     clean::StructFieldItem(ref ty) => {\n-                        write!(w, \"{}{}\", VisSpace(field.visibility), *ty)?\n+                        write!(w, \"{}{}\", VisSpace(&field.visibility), *ty)?\n                     }\n                     _ => unreachable!()\n                 }"}, {"sha": "5c36c38abc5872f626cd7b04b0f9664055c9ce25", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/76e2349c4417788e03f877fe18d13b521b455a4b/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e2349c4417788e03f877fe18d13b521b455a4b/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=76e2349c4417788e03f877fe18d13b521b455a4b", "patch": "@@ -101,7 +101,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             id: item.id,\n             struct_type: struct_type,\n             name: name,\n-            vis: item.vis,\n+            vis: item.vis.clone(),\n             stab: self.stability(item.id),\n             depr: self.deprecation(item.id),\n             attrs: item.attrs.clone(),\n@@ -125,7 +125,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 def: v.node.data.clone(),\n                 whence: v.span,\n             }).collect(),\n-            vis: it.vis,\n+            vis: it.vis.clone(),\n             stab: self.stability(it.id),\n             depr: self.deprecation(it.id),\n             generics: params.clone(),\n@@ -144,7 +144,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         debug!(\"Visiting fn\");\n         Function {\n             id: item.id,\n-            vis: item.vis,\n+            vis: item.vis.clone(),\n             stab: self.stability(item.id),\n             depr: self.deprecation(item.id),\n             attrs: item.attrs.clone(),\n@@ -166,7 +166,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         om.where_outer = span;\n         om.where_inner = m.inner;\n         om.attrs = attrs;\n-        om.vis = vis;\n+        om.vis = vis.clone();\n         om.stab = self.stability(id);\n         om.depr = self.deprecation(id);\n         om.id = id;\n@@ -299,7 +299,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 om.extern_crates.push(ExternCrate {\n                     name: name,\n                     path: p.map(|x|x.to_string()),\n-                    vis: item.vis,\n+                    vis: item.vis.clone(),\n                     attrs: item.attrs.clone(),\n                     whence: item.span,\n                 })\n@@ -324,7 +324,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 };\n                 om.imports.push(Import {\n                     id: item.id,\n-                    vis: item.vis,\n+                    vis: item.vis.clone(),\n                     attrs: item.attrs.clone(),\n                     node: node,\n                     whence: item.span,\n@@ -333,7 +333,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             hir::ItemMod(ref m) => {\n                 om.mods.push(self.visit_mod_contents(item.span,\n                                                      item.attrs.clone(),\n-                                                     item.vis,\n+                                                     item.vis.clone(),\n                                                      item.id,\n                                                      m,\n                                                      Some(name)));\n@@ -353,7 +353,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                     id: item.id,\n                     attrs: item.attrs.clone(),\n                     whence: item.span,\n-                    vis: item.vis,\n+                    vis: item.vis.clone(),\n                     stab: self.stability(item.id),\n                     depr: self.deprecation(item.id),\n                 };\n@@ -368,7 +368,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                     name: name,\n                     attrs: item.attrs.clone(),\n                     whence: item.span,\n-                    vis: item.vis,\n+                    vis: item.vis.clone(),\n                     stab: self.stability(item.id),\n                     depr: self.deprecation(item.id),\n                 };\n@@ -382,7 +382,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                     name: name,\n                     attrs: item.attrs.clone(),\n                     whence: item.span,\n-                    vis: item.vis,\n+                    vis: item.vis.clone(),\n                     stab: self.stability(item.id),\n                     depr: self.deprecation(item.id),\n                 };\n@@ -398,7 +398,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                     id: item.id,\n                     attrs: item.attrs.clone(),\n                     whence: item.span,\n-                    vis: item.vis,\n+                    vis: item.vis.clone(),\n                     stab: self.stability(item.id),\n                     depr: self.deprecation(item.id),\n                 };\n@@ -415,7 +415,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                     attrs: item.attrs.clone(),\n                     id: item.id,\n                     whence: item.span,\n-                    vis: item.vis,\n+                    vis: item.vis.clone(),\n                     stab: self.stability(item.id),\n                     depr: self.deprecation(item.id),\n                 };"}, {"sha": "a8db01b82da945dbf23dd745c8588db8ce4ea7c9", "filename": "src/test/compile-fail/issue-30079.rs", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/76e2349c4417788e03f877fe18d13b521b455a4b/src%2Ftest%2Fcompile-fail%2Fissue-30079.rs", "raw_url": "https://github.com/rust-lang/rust/raw/76e2349c4417788e03f877fe18d13b521b455a4b/src%2Ftest%2Fcompile-fail%2Fissue-30079.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-30079.rs?ref=76e2349c4417788e03f877fe18d13b521b455a4b", "patch": "@@ -0,0 +1,55 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(rustc_attrs)]\n+#![allow(unused)]\n+\n+struct SemiPriv;\n+\n+mod m1 {\n+    struct Priv;\n+    impl ::SemiPriv {\n+        pub fn f(_: Priv) {} //~ WARN private type in public interface\n+        //~^ WARNING hard error\n+    }\n+\n+    impl Priv {\n+        pub fn f(_: Priv) {} // ok\n+    }\n+}\n+\n+mod m2 {\n+    struct Priv;\n+    impl ::std::ops::Deref for ::SemiPriv {\n+        type Target = Priv; //~ WARN private type in public interface\n+        //~^ WARNING hard error\n+        fn deref(&self) -> &Self::Target { unimplemented!() }\n+    }\n+\n+    impl ::std::ops::Deref for Priv {\n+        type Target = Priv; // ok\n+        fn deref(&self) -> &Self::Target { unimplemented!() }\n+    }\n+}\n+\n+trait SemiPrivTrait {\n+    type Assoc;\n+}\n+\n+mod m3 {\n+    struct Priv;\n+    impl ::SemiPrivTrait for () {\n+        type Assoc = Priv; //~ WARN private type in public interface\n+        //~^ WARNING hard error\n+    }\n+}\n+\n+#[rustc_error]\n+fn main() {} //~ ERROR compilation successful"}]}