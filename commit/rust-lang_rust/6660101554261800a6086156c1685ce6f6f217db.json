{"sha": "6660101554261800a6086156c1685ce6f6f217db", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY2NjAxMDE1NTQyNjE4MDBhNjA4NjE1NmMxNjg1Y2U2ZjZmMjE3ZGI=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-10-25T07:56:12Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2018-10-25T07:56:12Z"}, "message": "specify package when running cargo check", "tree": {"sha": "add2532e9e96d85688b8978568a0f866aa8f88d3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/add2532e9e96d85688b8978568a0f866aa8f88d3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6660101554261800a6086156c1685ce6f6f217db", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6660101554261800a6086156c1685ce6f6f217db", "html_url": "https://github.com/rust-lang/rust/commit/6660101554261800a6086156c1685ce6f6f217db", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6660101554261800a6086156c1685ce6f6f217db/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0e359af291463ec9d4de6291777e9a0b3d74adea", "url": "https://api.github.com/repos/rust-lang/rust/commits/0e359af291463ec9d4de6291777e9a0b3d74adea", "html_url": "https://github.com/rust-lang/rust/commit/0e359af291463ec9d4de6291777e9a0b3d74adea"}], "stats": {"total": 111, "additions": 65, "deletions": 46}, "files": [{"sha": "9d7f4f9f11124e088f3709ade020ddc26e6e3e9c", "filename": "crates/ra_lsp_server/src/main_loop/handlers.rs", "status": "modified", "additions": 65, "deletions": 46, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/6660101554261800a6086156c1685ce6f6f217db/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6660101554261800a6086156c1685ce6f6f217db/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_lsp_server%2Fsrc%2Fmain_loop%2Fhandlers.rs?ref=6660101554261800a6086156c1685ce6f6f217db", "patch": "@@ -268,80 +268,99 @@ pub fn handle_runnables(\n         };\n         res.push(r);\n     }\n+    let mut check_args = vec![\"check\".to_string()];\n+    match CargoTargetSpec::for_file(&world, file_id)? {\n+        Some(spec) => spec.push_to(&mut check_args),\n+        None => check_args.push(\"--all\".to_string()),\n+    }\n     // Always add `cargo check`.\n     res.push(req::Runnable {\n         range: Default::default(),\n         label: \"cargo check\".to_string(),\n         bin: \"cargo\".to_string(),\n-        args: vec![\"check\".to_string(), \"--all\".to_string()],\n+        args: check_args,\n         env: FxHashMap::default(),\n     });\n     return Ok(res);\n \n     fn runnable_args(world: &ServerWorld, file_id: FileId, kind: &RunnableKind) -> Result<Vec<String>> {\n-        let spec = if let Some(&crate_id) = world.analysis().crate_for(file_id)?.first() {\n-            let file_id = world.analysis().crate_root(crate_id)?;\n-            let path = world.path_map.get_path(file_id);\n-            world\n-                .workspaces\n-                .iter()\n-                .filter_map(|ws| {\n-                    let tgt = ws.target_by_root(path)?;\n-                    Some((\n-                        tgt.package(ws).name(ws),\n-                        tgt.name(ws),\n-                        tgt.kind(ws),\n-                    ))\n-                })\n-                .next()\n-        } else {\n-            None\n-        };\n+        let spec = CargoTargetSpec::for_file(world, file_id)?;\n         let mut res = Vec::new();\n         match kind {\n             RunnableKind::Test { name } => {\n                 res.push(\"test\".to_string());\n-                if let Some((pkg_name, tgt_name, tgt_kind)) = spec {\n-                    spec_args(pkg_name, tgt_name, tgt_kind, &mut res);\n+                if let Some(spec) = spec {\n+                    spec.push_to(&mut res);\n                 }\n                 res.push(\"--\".to_string());\n                 res.push(name.to_string());\n                 res.push(\"--nocapture\".to_string());\n             }\n             RunnableKind::Bin => {\n                 res.push(\"run\".to_string());\n-                if let Some((pkg_name, tgt_name, tgt_kind)) = spec {\n-                    spec_args(pkg_name, tgt_name, tgt_kind, &mut res);\n+                if let Some(spec) = spec {\n+                    spec.push_to(&mut res);\n                 }\n             }\n         }\n         Ok(res)\n     }\n \n-    fn spec_args(pkg_name: &str, tgt_name: &str, tgt_kind: TargetKind, buf: &mut Vec<String>) {\n-        buf.push(\"--package\".to_string());\n-        buf.push(pkg_name.to_string());\n-        match tgt_kind {\n-            TargetKind::Bin => {\n-                buf.push(\"--bin\".to_string());\n-                buf.push(tgt_name.to_string());\n-            }\n-            TargetKind::Test => {\n-                buf.push(\"--test\".to_string());\n-                buf.push(tgt_name.to_string());\n-            }\n-            TargetKind::Bench => {\n-                buf.push(\"--bench\".to_string());\n-                buf.push(tgt_name.to_string());\n-            }\n-            TargetKind::Example => {\n-                buf.push(\"--example\".to_string());\n-                buf.push(tgt_name.to_string());\n-            }\n-            TargetKind::Lib => {\n-                buf.push(\"--lib\".to_string());\n+    struct CargoTargetSpec {\n+        package: String,\n+        target: String,\n+        target_kind: TargetKind,\n+    }\n+\n+    impl CargoTargetSpec {\n+        fn for_file(world: &ServerWorld, file_id: FileId) -> Result<Option<CargoTargetSpec>> {\n+            let &crate_id = match world.analysis().crate_for(file_id)?.first() {\n+                Some(crate_id) => crate_id,\n+                None => return Ok(None),\n+            };\n+            let file_id = world.analysis().crate_root(crate_id)?;\n+            let path = world.path_map.get_path(file_id);\n+            let res = world\n+                .workspaces\n+                .iter()\n+                .find_map(|ws| {\n+                    let tgt = ws.target_by_root(path)?;\n+                    let res = CargoTargetSpec {\n+                        package: tgt.package(ws).name(ws).to_string(),\n+                        target: tgt.name(ws).to_string(),\n+                        target_kind: tgt.kind(ws),\n+                    };\n+                    Some(res)\n+                });\n+            Ok(res)\n+        }\n+\n+        fn push_to(self, buf: &mut Vec<String>) {\n+            buf.push(\"--package\".to_string());\n+            buf.push(self.package);\n+            match self.target_kind {\n+                TargetKind::Bin => {\n+                    buf.push(\"--bin\".to_string());\n+                    buf.push(self.target);\n+                }\n+                TargetKind::Test => {\n+                    buf.push(\"--test\".to_string());\n+                    buf.push(self.target);\n+                }\n+                TargetKind::Bench => {\n+                    buf.push(\"--bench\".to_string());\n+                    buf.push(self.target);\n+                }\n+                TargetKind::Example => {\n+                    buf.push(\"--example\".to_string());\n+                    buf.push(self.target);\n+                }\n+                TargetKind::Lib => {\n+                    buf.push(\"--lib\".to_string());\n+                }\n+                TargetKind::Other => (),\n             }\n-            TargetKind::Other => (),\n+\n         }\n     }\n }"}]}