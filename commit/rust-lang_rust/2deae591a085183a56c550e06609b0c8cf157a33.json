{"sha": "2deae591a085183a56c550e06609b0c8cf157a33", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJkZWFlNTkxYTA4NTE4M2E1NmM1NTBlMDY2MDliMGM4Y2YxNTdhMzM=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-04-23T19:50:54Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-04-23T19:50:54Z"}, "message": "Rollup merge of #59839 - KodrAus:must-use-num, r=sfackler\n\nWarn on unused results for operation methods on nums\n\nFrom a suggestion by @llogiq\n\nAdds a `#[must_use]` attribute to operation methods on integers that take self by value as the first operand and another value as the second. It makes it clear that these methods return the result of the operation instead of mutating `self`, which is the source of a rather embarrassing bug I had in a codebase of mine recently...\n\nAs an example:\n\n```rust\nstruct Int {\n   value: i64,\n}\n\nimpl Int {\n    fn add(&mut self, other: i64) {\n        self.value.wrapping_add(other);\n    }\n}\n```\n\nWill produce a warning like:\n\n```\nwarning: unused return value of `core::num::<impl i64>::wrapping_add` that must be used\n --> src/main.rs:7:7\n  |\n7 |       self.value.wrapping_add(other);\n  |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: #[warn(unused_must_use)] on by default\n  = note: this returns the result of the operation, without modifying the original\n```\n\nIf this is something we're on board with, we could do something similar for `f32` and `f64` too. There are probably other methods on integers that make sense.", "tree": {"sha": "c04f44cc7bde2f626bfc394772a5720ad850fed1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c04f44cc7bde2f626bfc394772a5720ad850fed1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2deae591a085183a56c550e06609b0c8cf157a33", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJcv2yeCRBK7hj4Ov3rIwAAdHIIAJaHMk8S3SWQQlZyr5DhpduA\nMqgYoz+4SFAafZq+uqnBIRBiD/SzlAfbTWTKz/3gXbghpzSXAKTW+Z5FiwQ9cV+h\nXJmdgcY8sB77o+svmzrsJez1vA74MZQWazVqNm+gx7lRWlydebhDblSXtjIpbv7f\nHfXSfkx2MXA+tldSqglKRux+TOmAgY85vk8QMU1EOsYaWyYloUE7nFqccHus6X6r\nbgee69flLBSOXJMRBTDx35n/84RN28/RRlQnmQSfncxkXbPpWygpDpgegcgY7cGu\nNErZT+qShO6sQdmuimdikYjfti7BBlI0/KEIg8QS7CyNeIUgCPO6fo6SlXyGimI=\n=25Au\n-----END PGP SIGNATURE-----\n", "payload": "tree c04f44cc7bde2f626bfc394772a5720ad850fed1\nparent 62d1574876f5531bce1b267e62dff520d7adcbbb\nparent 23154db8371e5277c373578690b3a79d15e13180\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1556049054 +0200\ncommitter GitHub <noreply@github.com> 1556049054 +0200\n\nRollup merge of #59839 - KodrAus:must-use-num, r=sfackler\n\nWarn on unused results for operation methods on nums\n\nFrom a suggestion by @llogiq\n\nAdds a `#[must_use]` attribute to operation methods on integers that take self by value as the first operand and another value as the second. It makes it clear that these methods return the result of the operation instead of mutating `self`, which is the source of a rather embarrassing bug I had in a codebase of mine recently...\n\nAs an example:\n\n```rust\nstruct Int {\n   value: i64,\n}\n\nimpl Int {\n    fn add(&mut self, other: i64) {\n        self.value.wrapping_add(other);\n    }\n}\n```\n\nWill produce a warning like:\n\n```\nwarning: unused return value of `core::num::<impl i64>::wrapping_add` that must be used\n --> src/main.rs:7:7\n  |\n7 |       self.value.wrapping_add(other);\n  |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n  |\n  = note: #[warn(unused_must_use)] on by default\n  = note: this returns the result of the operation, without modifying the original\n```\n\nIf this is something we're on board with, we could do something similar for `f32` and `f64` too. There are probably other methods on integers that make sense.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2deae591a085183a56c550e06609b0c8cf157a33", "html_url": "https://github.com/rust-lang/rust/commit/2deae591a085183a56c550e06609b0c8cf157a33", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2deae591a085183a56c550e06609b0c8cf157a33/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "62d1574876f5531bce1b267e62dff520d7adcbbb", "url": "https://api.github.com/repos/rust-lang/rust/commits/62d1574876f5531bce1b267e62dff520d7adcbbb", "html_url": "https://github.com/rust-lang/rust/commit/62d1574876f5531bce1b267e62dff520d7adcbbb"}, {"sha": "23154db8371e5277c373578690b3a79d15e13180", "url": "https://api.github.com/repos/rust-lang/rust/commits/23154db8371e5277c373578690b3a79d15e13180", "html_url": "https://github.com/rust-lang/rust/commit/23154db8371e5277c373578690b3a79d15e13180"}], "stats": {"total": 158, "additions": 157, "deletions": 1}, "files": [{"sha": "f1325f383eedb5454c89fe8cae95e1a7a1af3225", "filename": "src/libcore/num/mod.rs", "status": "modified", "additions": 156, "deletions": 0, "changes": 156, "blob_url": "https://github.com/rust-lang/rust/blob/2deae591a085183a56c550e06609b0c8cf157a33/src%2Flibcore%2Fnum%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2deae591a085183a56c550e06609b0c8cf157a33/src%2Flibcore%2Fnum%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fmod.rs?ref=2deae591a085183a56c550e06609b0c8cf157a33", "patch": "@@ -377,6 +377,8 @@ let m = \", $rot_result, \";\n assert_eq!(n.rotate_left(\", $rot, \"), m);\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub const fn rotate_left(self, n: u32) -> Self {\n                 (self as $UnsignedT).rotate_left(n) as Self\n@@ -401,6 +403,8 @@ let m = \", $rot_op, \";\n assert_eq!(n.rotate_right(\", $rot, \"), m);\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub const fn rotate_right(self, n: u32) -> Self {\n                 (self as $UnsignedT).rotate_right(n) as Self\n@@ -598,6 +602,8 @@ assert_eq!((\", stringify!($SelfT), \"::max_value() - 2).checked_add(3), None);\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub fn checked_add(self, rhs: Self) -> Option<Self> {\n                 let (a, b) = self.overflowing_add(rhs);\n@@ -620,6 +626,8 @@ assert_eq!((\", stringify!($SelfT), \"::min_value() + 2).checked_sub(3), None);\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub fn checked_sub(self, rhs: Self) -> Option<Self> {\n                 let (a, b) = self.overflowing_sub(rhs);\n@@ -642,6 +650,8 @@ assert_eq!(\", stringify!($SelfT), \"::max_value().checked_mul(2), None);\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub fn checked_mul(self, rhs: Self) -> Option<Self> {\n                 let (a, b) = self.overflowing_mul(rhs);\n@@ -665,6 +675,8 @@ assert_eq!((1\", stringify!($SelfT), \").checked_div(0), None);\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub fn checked_div(self, rhs: Self) -> Option<Self> {\n                 if rhs == 0 || (self == Self::min_value() && rhs == -1) {\n@@ -691,6 +703,8 @@ assert_eq!(\", stringify!($SelfT), \"::min_value().checked_div_euclid(-1), None);\n assert_eq!((1\", stringify!($SelfT), \").checked_div_euclid(0), None);\n ```\"),\n             #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub fn checked_div_euclid(self, rhs: Self) -> Option<Self> {\n                 if rhs == 0 || (self == Self::min_value() && rhs == -1) {\n@@ -718,6 +732,8 @@ assert_eq!(\", stringify!($SelfT), \"::MIN.checked_rem(-1), None);\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub fn checked_rem(self, rhs: Self) -> Option<Self> {\n                 if rhs == 0 || (self == Self::min_value() && rhs == -1) {\n@@ -745,6 +761,8 @@ assert_eq!(5\", stringify!($SelfT), \".checked_rem_euclid(0), None);\n assert_eq!(\", stringify!($SelfT), \"::MIN.checked_rem_euclid(-1), None);\n ```\"),\n             #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub fn checked_rem_euclid(self, rhs: Self) -> Option<Self> {\n                 if rhs == 0 || (self == Self::min_value() && rhs == -1) {\n@@ -791,6 +809,8 @@ assert_eq!(0x1\", stringify!($SelfT), \".checked_shl(129), None);\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub fn checked_shl(self, rhs: u32) -> Option<Self> {\n                 let (a, b) = self.overflowing_shl(rhs);\n@@ -812,6 +832,8 @@ assert_eq!(0x10\", stringify!($SelfT), \".checked_shr(128), None);\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub fn checked_shr(self, rhs: u32) -> Option<Self> {\n                 let (a, b) = self.overflowing_shr(rhs);\n@@ -860,6 +882,8 @@ $EndFeature, \"\n ```\"),\n \n             #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub fn checked_pow(self, mut exp: u32) -> Option<Self> {\n                 let mut base = self;\n@@ -901,6 +925,8 @@ $EndFeature, \"\n \n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             #[rustc_const_unstable(feature = \"const_saturating_int_methods\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub const fn saturating_add(self, rhs: Self) -> Self {\n                 intrinsics::saturating_add(self, rhs)\n@@ -924,6 +950,8 @@ $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n             #[rustc_const_unstable(feature = \"const_saturating_int_methods\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub const fn saturating_sub(self, rhs: Self) -> Self {\n                 intrinsics::saturating_sub(self, rhs)\n@@ -947,6 +975,8 @@ assert_eq!(\", stringify!($SelfT), \"::MIN.saturating_mul(10), \", stringify!($Self\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub fn saturating_mul(self, rhs: Self) -> Self {\n                 self.checked_mul(rhs).unwrap_or_else(|| {\n@@ -976,6 +1006,8 @@ assert_eq!(\", stringify!($SelfT), \"::MIN.saturating_pow(3), \", stringify!($SelfT\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub fn saturating_pow(self, exp: u32) -> Self {\n                 match self.checked_pow(exp) {\n@@ -1001,6 +1033,8 @@ assert_eq!(\", stringify!($SelfT), \"::max_value().wrapping_add(2), \", stringify!(\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub const fn wrapping_add(self, rhs: Self) -> Self {\n                 intrinsics::overflowing_add(self, rhs)\n@@ -1022,6 +1056,8 @@ stringify!($SelfT), \"::max_value());\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub const fn wrapping_sub(self, rhs: Self) -> Self {\n                 intrinsics::overflowing_sub(self, rhs)\n@@ -1042,6 +1078,8 @@ assert_eq!(11i8.wrapping_mul(12), -124);\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub const fn wrapping_mul(self, rhs: Self) -> Self {\n                 intrinsics::overflowing_mul(self, rhs)\n@@ -1070,6 +1108,8 @@ assert_eq!((-128i8).wrapping_div(-1), -128);\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub fn wrapping_div(self, rhs: Self) -> Self {\n                 self.overflowing_div(rhs).0\n@@ -1098,6 +1138,8 @@ assert_eq!(100\", stringify!($SelfT), \".wrapping_div_euclid(10), 10);\n assert_eq!((-128i8).wrapping_div_euclid(-1), -128);\n ```\"),\n             #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub fn wrapping_div_euclid(self, rhs: Self) -> Self {\n                 self.overflowing_div_euclid(rhs).0\n@@ -1126,6 +1168,8 @@ assert_eq!((-128i8).wrapping_rem(-1), 0);\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub fn wrapping_rem(self, rhs: Self) -> Self {\n                 self.overflowing_rem(rhs).0\n@@ -1153,6 +1197,8 @@ assert_eq!(100\", stringify!($SelfT), \".wrapping_rem_euclid(10), 0);\n assert_eq!((-128i8).wrapping_rem_euclid(-1), 0);\n ```\"),\n             #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub fn wrapping_rem_euclid(self, rhs: Self) -> Self {\n                 self.overflowing_rem_euclid(rhs).0\n@@ -1203,6 +1249,8 @@ assert_eq!((-1\", stringify!($SelfT), \").wrapping_shl(128), -1);\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub const fn wrapping_shl(self, rhs: u32) -> Self {\n                 unsafe {\n@@ -1230,6 +1278,8 @@ assert_eq!((-128i16).wrapping_shr(64), -128);\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub const fn wrapping_shr(self, rhs: u32) -> Self {\n                 unsafe {\n@@ -1284,6 +1334,8 @@ assert_eq!(3i8.wrapping_pow(6), -39);\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub fn wrapping_pow(self, mut exp: u32) -> Self {\n                 let mut base = self;\n@@ -1326,6 +1378,8 @@ assert_eq!(\", stringify!($SelfT), \"::MAX.overflowing_add(1), (\", stringify!($Sel\n \"::MIN, true));\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub const fn overflowing_add(self, rhs: Self) -> (Self, bool) {\n                 let (a, b) = intrinsics::add_with_overflow(self as $ActualT, rhs as $ActualT);\n@@ -1351,6 +1405,8 @@ assert_eq!(\", stringify!($SelfT), \"::MIN.overflowing_sub(1), (\", stringify!($Sel\n \"::MAX, true));\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub const fn overflowing_sub(self, rhs: Self) -> (Self, bool) {\n                 let (a, b) = intrinsics::sub_with_overflow(self as $ActualT, rhs as $ActualT);\n@@ -1374,6 +1430,8 @@ assert_eq!(1_000_000_000i32.overflowing_mul(10), (1410065408, true));\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub const fn overflowing_mul(self, rhs: Self) -> (Self, bool) {\n                 let (a, b) = intrinsics::mul_with_overflow(self as $ActualT, rhs as $ActualT);\n@@ -1405,6 +1463,8 @@ $EndFeature, \"\n ```\"),\n             #[inline]\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             pub fn overflowing_div(self, rhs: Self) -> (Self, bool) {\n                 if self == Self::min_value() && rhs == -1 {\n                     (self, true)\n@@ -1438,6 +1498,8 @@ assert_eq!(\", stringify!($SelfT), \"::MIN.overflowing_div_euclid(-1), (\", stringi\n ```\"),\n             #[inline]\n             #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             pub fn overflowing_div_euclid(self, rhs: Self) -> (Self, bool) {\n                 if self == Self::min_value() && rhs == -1 {\n                     (self, true)\n@@ -1470,6 +1532,8 @@ $EndFeature, \"\n ```\"),\n             #[inline]\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             pub fn overflowing_rem(self, rhs: Self) -> (Self, bool) {\n                 if self == Self::min_value() && rhs == -1 {\n                     (0, true)\n@@ -1502,6 +1566,8 @@ assert_eq!(5\", stringify!($SelfT), \".overflowing_rem_euclid(2), (1, false));\n assert_eq!(\", stringify!($SelfT), \"::MIN.overflowing_rem_euclid(-1), (0, true));\n ```\"),\n             #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub fn overflowing_rem_euclid(self, rhs: Self) -> (Self, bool) {\n                 if self == Self::min_value() && rhs == -1 {\n@@ -1555,6 +1621,8 @@ assert_eq!(0x1i32.overflowing_shl(36), (0x10, true));\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub const fn overflowing_shl(self, rhs: u32) -> (Self, bool) {\n                 (self.wrapping_shl(rhs), (rhs > ($BITS - 1)))\n@@ -1578,6 +1646,8 @@ assert_eq!(0x10i32.overflowing_shr(36), (0x1, true));\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub const fn overflowing_shr(self, rhs: u32) -> (Self, bool) {\n                 (self.wrapping_shr(rhs), (rhs > ($BITS - 1)))\n@@ -1630,6 +1700,8 @@ assert_eq!(3i8.overflowing_pow(5), (-13, true));\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub fn overflowing_pow(self, mut exp: u32) -> (Self, bool) {\n                 let mut base = self;\n@@ -1677,6 +1749,8 @@ assert_eq!(x.pow(5), 32);\",\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             #[rustc_inherit_overflow_checks]\n             pub fn pow(self, mut exp: u32) -> Self {\n@@ -1732,6 +1806,8 @@ assert_eq!((-a).div_euclid(b), -2); // -7 >= 4 * -2\n assert_eq!((-a).div_euclid(-b), 2); // -7 >= -4 * 2\n ```\"),\n             #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             #[rustc_inherit_overflow_checks]\n             pub fn div_euclid(self, rhs: Self) -> Self {\n@@ -1770,6 +1846,8 @@ assert_eq!(a.rem_euclid(-b), 3);\n assert_eq!((-a).rem_euclid(-b), 1);\n ```\"),\n             #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             #[rustc_inherit_overflow_checks]\n             pub fn rem_euclid(self, rhs: Self) -> Self {\n@@ -2277,6 +2355,8 @@ let m = \", $rot_result, \";\n assert_eq!(n.rotate_left(\", $rot, \"), m);\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub const fn rotate_left(self, n: u32) -> Self {\n                 intrinsics::rotate_left(self, n as $SelfT)\n@@ -2301,6 +2381,8 @@ let m = \", $rot_op, \";\n assert_eq!(n.rotate_right(\", $rot, \"), m);\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub const fn rotate_right(self, n: u32) -> Self {\n                 intrinsics::rotate_right(self, n as $SelfT)\n@@ -2496,6 +2578,8 @@ Basic usage:\n assert_eq!((\", stringify!($SelfT), \"::max_value() - 2).checked_add(3), None);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub fn checked_add(self, rhs: Self) -> Option<Self> {\n                 let (a, b) = self.overflowing_add(rhs);\n@@ -2516,6 +2600,8 @@ Basic usage:\n assert_eq!(0\", stringify!($SelfT), \".checked_sub(1), None);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub fn checked_sub(self, rhs: Self) -> Option<Self> {\n                 let (a, b) = self.overflowing_sub(rhs);\n@@ -2536,6 +2622,8 @@ Basic usage:\n assert_eq!(\", stringify!($SelfT), \"::max_value().checked_mul(2), None);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub fn checked_mul(self, rhs: Self) -> Option<Self> {\n                 let (a, b) = self.overflowing_mul(rhs);\n@@ -2556,6 +2644,8 @@ Basic usage:\n assert_eq!(1\", stringify!($SelfT), \".checked_div(0), None);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub fn checked_div(self, rhs: Self) -> Option<Self> {\n                 match rhs {\n@@ -2579,6 +2669,8 @@ assert_eq!(128\", stringify!($SelfT), \".checked_div_euclid(2), Some(64));\n assert_eq!(1\", stringify!($SelfT), \".checked_div_euclid(0), None);\n ```\"),\n             #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub fn checked_div_euclid(self, rhs: Self) -> Option<Self> {\n                 if rhs == 0 {\n@@ -2603,6 +2695,8 @@ Basic usage:\n assert_eq!(5\", stringify!($SelfT), \".checked_rem(0), None);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub fn checked_rem(self, rhs: Self) -> Option<Self> {\n                 if rhs == 0 {\n@@ -2627,6 +2721,8 @@ assert_eq!(5\", stringify!($SelfT), \".checked_rem_euclid(2), Some(1));\n assert_eq!(5\", stringify!($SelfT), \".checked_rem_euclid(0), None);\n ```\"),\n             #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub fn checked_rem_euclid(self, rhs: Self) -> Option<Self> {\n                 if rhs == 0 {\n@@ -2672,6 +2768,8 @@ Basic usage:\n assert_eq!(0x10\", stringify!($SelfT), \".checked_shl(129), None);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub fn checked_shl(self, rhs: u32) -> Option<Self> {\n                 let (a, b) = self.overflowing_shl(rhs);\n@@ -2692,6 +2790,8 @@ Basic usage:\n assert_eq!(0x10\", stringify!($SelfT), \".checked_shr(129), None);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub fn checked_shr(self, rhs: u32) -> Option<Self> {\n                 let (a, b) = self.overflowing_shr(rhs);\n@@ -2712,6 +2812,8 @@ Basic usage:\n assert_eq!(\", stringify!($SelfT), \"::max_value().checked_pow(2), None);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub fn checked_pow(self, mut exp: u32) -> Option<Self> {\n                 let mut base = self;\n@@ -2750,6 +2852,8 @@ assert_eq!(200u8.saturating_add(127), 255);\", $EndFeature, \"\n ```\"),\n \n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[rustc_const_unstable(feature = \"const_saturating_int_methods\")]\n             #[inline]\n             pub const fn saturating_add(self, rhs: Self) -> Self {\n@@ -2770,6 +2874,8 @@ Basic usage:\n assert_eq!(13\", stringify!($SelfT), \".saturating_sub(127), 0);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[rustc_const_unstable(feature = \"const_saturating_int_methods\")]\n             #[inline]\n             pub const fn saturating_sub(self, rhs: Self) -> Self {\n@@ -2793,6 +2899,8 @@ assert_eq!((\", stringify!($SelfT), \"::MAX).saturating_mul(10), \", stringify!($Se\n \"::MAX);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub fn saturating_mul(self, rhs: Self) -> Self {\n                 self.checked_mul(rhs).unwrap_or(Self::max_value())\n@@ -2815,6 +2923,8 @@ assert_eq!(\", stringify!($SelfT), \"::MAX.saturating_pow(2), \", stringify!($SelfT\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub fn saturating_pow(self, exp: u32) -> Self {\n                 match self.checked_pow(exp) {\n@@ -2838,6 +2948,8 @@ assert_eq!(200\", stringify!($SelfT), \".wrapping_add(\", stringify!($SelfT), \"::ma\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub const fn wrapping_add(self, rhs: Self) -> Self {\n                 intrinsics::overflowing_add(self, rhs)\n@@ -2858,6 +2970,8 @@ assert_eq!(100\", stringify!($SelfT), \".wrapping_sub(\", stringify!($SelfT), \"::ma\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub const fn wrapping_sub(self, rhs: Self) -> Self {\n                 intrinsics::overflowing_sub(self, rhs)\n@@ -2879,6 +2993,8 @@ $EndFeature, \"\n         /// assert_eq!(25u8.wrapping_mul(12), 44);\n         /// ```\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n         #[inline]\n         pub const fn wrapping_mul(self, rhs: Self) -> Self {\n             intrinsics::overflowing_mul(self, rhs)\n@@ -2899,6 +3015,8 @@ Basic usage:\n \", $Feature, \"assert_eq!(100\", stringify!($SelfT), \".wrapping_div(10), 10);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub fn wrapping_div(self, rhs: Self) -> Self {\n                 self / rhs\n@@ -2924,6 +3042,8 @@ Basic usage:\n assert_eq!(100\", stringify!($SelfT), \".wrapping_div_euclid(10), 10);\n ```\"),\n             #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub fn wrapping_div_euclid(self, rhs: Self) -> Self {\n                 self / rhs\n@@ -2946,6 +3066,8 @@ Basic usage:\n \", $Feature, \"assert_eq!(100\", stringify!($SelfT), \".wrapping_rem(10), 0);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub fn wrapping_rem(self, rhs: Self) -> Self {\n                 self % rhs\n@@ -2972,6 +3094,8 @@ Basic usage:\n assert_eq!(100\", stringify!($SelfT), \".wrapping_rem_euclid(10), 0);\n ```\"),\n             #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub fn wrapping_rem_euclid(self, rhs: Self) -> Self {\n                 self % rhs\n@@ -3026,6 +3150,8 @@ Basic usage:\n assert_eq!(1\", stringify!($SelfT), \".wrapping_shl(128), 1);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub const fn wrapping_shl(self, rhs: u32) -> Self {\n                 unsafe {\n@@ -3055,6 +3181,8 @@ Basic usage:\n assert_eq!(128\", stringify!($SelfT), \".wrapping_shr(128), 128);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"num_wrapping\", since = \"1.2.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub const fn wrapping_shr(self, rhs: u32) -> Self {\n                 unsafe {\n@@ -3076,6 +3204,8 @@ Basic usage:\n assert_eq!(3u8.wrapping_pow(6), 217);\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub fn wrapping_pow(self, mut exp: u32) -> Self {\n                 let mut base = self;\n@@ -3118,6 +3248,8 @@ assert_eq!(5\", stringify!($SelfT), \".overflowing_add(2), (7, false));\n assert_eq!(\", stringify!($SelfT), \"::MAX.overflowing_add(1), (0, true));\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub const fn overflowing_add(self, rhs: Self) -> (Self, bool) {\n                 let (a, b) = intrinsics::add_with_overflow(self as $ActualT, rhs as $ActualT);\n@@ -3144,6 +3276,8 @@ assert_eq!(0\", stringify!($SelfT), \".overflowing_sub(1), (\", stringify!($SelfT),\n $EndFeature, \"\n ```\"),\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub const fn overflowing_sub(self, rhs: Self) -> (Self, bool) {\n                 let (a, b) = intrinsics::sub_with_overflow(self as $ActualT, rhs as $ActualT);\n@@ -3169,6 +3303,8 @@ $EndFeature, \"\n         /// assert_eq!(1_000_000_000u32.overflowing_mul(10), (1410065408, true));\n         /// ```\n         #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+        #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n         #[inline]\n         pub const fn overflowing_mul(self, rhs: Self) -> (Self, bool) {\n             let (a, b) = intrinsics::mul_with_overflow(self as $ActualT, rhs as $ActualT);\n@@ -3196,6 +3332,8 @@ Basic usage\n ```\"),\n             #[inline]\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             pub fn overflowing_div(self, rhs: Self) -> (Self, bool) {\n                 (self / rhs, false)\n             }\n@@ -3226,6 +3364,8 @@ assert_eq!(5\", stringify!($SelfT), \".overflowing_div_euclid(2), (2, false));\n ```\"),\n             #[inline]\n             #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             pub fn overflowing_div_euclid(self, rhs: Self) -> (Self, bool) {\n                 (self / rhs, false)\n             }\n@@ -3252,6 +3392,8 @@ Basic usage\n ```\"),\n             #[inline]\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             pub fn overflowing_rem(self, rhs: Self) -> (Self, bool) {\n                 (self % rhs, false)\n             }\n@@ -3282,6 +3424,8 @@ assert_eq!(5\", stringify!($SelfT), \".overflowing_rem_euclid(2), (1, false));\n ```\"),\n             #[inline]\n             #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             pub fn overflowing_rem_euclid(self, rhs: Self) -> (Self, bool) {\n                 (self % rhs, false)\n             }\n@@ -3329,6 +3473,8 @@ Basic usage\n assert_eq!(0x1\", stringify!($SelfT), \".overflowing_shl(132), (0x10, true));\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub const fn overflowing_shl(self, rhs: u32) -> (Self, bool) {\n                 (self.wrapping_shl(rhs), (rhs > ($BITS - 1)))\n@@ -3353,6 +3499,8 @@ Basic usage\n assert_eq!(0x10\", stringify!($SelfT), \".overflowing_shr(132), (0x1, true));\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"wrapping\", since = \"1.7.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub const fn overflowing_shr(self, rhs: u32) -> (Self, bool) {\n                 (self.wrapping_shr(rhs), (rhs > ($BITS - 1)))\n@@ -3374,6 +3522,8 @@ Basic usage:\n assert_eq!(3u8.overflowing_pow(6), (217, true));\", $EndFeature, \"\n ```\"),\n             #[stable(feature = \"no_panic_pow\", since = \"1.34.0\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             pub fn overflowing_pow(self, mut exp: u32) -> (Self, bool) {\n                 let mut base = self;\n@@ -3418,6 +3568,8 @@ Basic usage:\n \", $Feature, \"assert_eq!(2\", stringify!($SelfT), \".pow(5), 32);\", $EndFeature, \"\n ```\"),\n         #[stable(feature = \"rust1\", since = \"1.0.0\")]\n+        #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n         #[inline]\n         #[rustc_inherit_overflow_checks]\n         pub fn pow(self, mut exp: u32) -> Self {\n@@ -3459,6 +3611,8 @@ Basic usage:\n assert_eq!(7\", stringify!($SelfT), \".div_euclid(4), 1); // or any other integer type\n ```\"),\n             #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             #[rustc_inherit_overflow_checks]\n             pub fn div_euclid(self, rhs: Self) -> Self {\n@@ -3483,6 +3637,8 @@ Basic usage:\n assert_eq!(7\", stringify!($SelfT), \".rem_euclid(4), 3); // or any other integer type\n ```\"),\n             #[unstable(feature = \"euclidean_division\", issue = \"49048\")]\n+            #[must_use = \"this returns the result of the operation, \\\n+                          without modifying the original\"]\n             #[inline]\n             #[rustc_inherit_overflow_checks]\n             pub fn rem_euclid(self, rhs: Self) -> Self {"}, {"sha": "6d5a9876c373c37ab5a6f5c68ba3eb9b4496acc7", "filename": "src/test/run-pass/functions-closures/closure-expected-type/expect-infer-supply-two-infers.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/2deae591a085183a56c550e06609b0c8cf157a33/src%2Ftest%2Frun-pass%2Ffunctions-closures%2Fclosure-expected-type%2Fexpect-infer-supply-two-infers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2deae591a085183a56c550e06609b0c8cf157a33/src%2Ftest%2Frun-pass%2Ffunctions-closures%2Fclosure-expected-type%2Fexpect-infer-supply-two-infers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Ffunctions-closures%2Fclosure-expected-type%2Fexpect-infer-supply-two-infers.rs?ref=2deae591a085183a56c550e06609b0c8cf157a33", "patch": "@@ -12,7 +12,7 @@ fn expect_free_supply_free<'x>(x: &'x u32) {\n         x.push(22_u32);\n \n         // ...since we now know the type of `y` and can resolve the method call.\n-        y.wrapping_add(1);\n+        let _ = y.wrapping_add(1);\n     });\n }\n "}]}