{"sha": "06ca016b6e779ba972efb9d1735afc527d301505", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA2Y2EwMTZiNmU3NzliYTk3MmVmYjlkMTczNWFmYzUyN2QzMDE1MDU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-07-18T08:40:23Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-07-18T08:40:23Z"}, "message": "Auto merge of #34886 - jseyfried:improve_stmt_matchers, r=eddyb\n\nmacros: fix bug in `stmt` matchers\n\nToday, `stmt` matchers stop too early when parsing expression statements that begin with non-braced macro invocations. For example,\n```rust\nfn main() {\n    macro_rules! m { ($s:stmt;) => { $s } }\n    id!(vec![].push(0););\n    //^ Before this PR, the `stmt` matcher only consumes \"vec![]\", so this is an error.\n    //| After this PR, the `stmt` matcher consumes \"vec![].push(0)\", so this compiles.\n}\n```\nThis change is backwards compatible due to the follow set for `stmt`.\n\nr? @eddyb", "tree": {"sha": "61577431937ee9c358e95e68354a246f30ef5b6c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/61577431937ee9c358e95e68354a246f30ef5b6c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/06ca016b6e779ba972efb9d1735afc527d301505", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/06ca016b6e779ba972efb9d1735afc527d301505", "html_url": "https://github.com/rust-lang/rust/commit/06ca016b6e779ba972efb9d1735afc527d301505", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/06ca016b6e779ba972efb9d1735afc527d301505/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6cc49e51de7ea9b0cc4aff437975544233c57107", "url": "https://api.github.com/repos/rust-lang/rust/commits/6cc49e51de7ea9b0cc4aff437975544233c57107", "html_url": "https://github.com/rust-lang/rust/commit/6cc49e51de7ea9b0cc4aff437975544233c57107"}, {"sha": "bd1ad762b7ab068ac2e3e1bfc413e80aac2dc7fd", "url": "https://api.github.com/repos/rust-lang/rust/commits/bd1ad762b7ab068ac2e3e1bfc413e80aac2dc7fd", "html_url": "https://github.com/rust-lang/rust/commit/bd1ad762b7ab068ac2e3e1bfc413e80aac2dc7fd"}], "stats": {"total": 97, "additions": 48, "deletions": 49}, "files": [{"sha": "125f1abb062bf2966b17a31cb428edd4a8fe6620", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 31, "deletions": 49, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/06ca016b6e779ba972efb9d1735afc527d301505/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06ca016b6e779ba972efb9d1735afc527d301505/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=06ca016b6e779ba972efb9d1735afc527d301505", "patch": "@@ -3789,13 +3789,8 @@ impl<'a> Parser<'a> {\n \n     /// Parse a statement. This stops just before trailing semicolons on everything but items.\n     /// e.g. a `StmtKind::Semi` parses to a `StmtKind::Expr`, leaving the trailing `;` unconsumed.\n-    ///\n-    /// Also, if a macro begins an expression statement, this only parses the macro. For example,\n-    /// ```rust\n-    /// vec![1].into_iter(); //< `parse_stmt` only parses the \"vec![1]\"\n-    /// ```\n     pub fn parse_stmt(&mut self) -> PResult<'a, Option<Stmt>> {\n-        Ok(self.parse_stmt_())\n+        Ok(self.parse_stmt_(true))\n     }\n \n     // Eat tokens until we can be relatively sure we reached the end of the\n@@ -3859,15 +3854,15 @@ impl<'a> Parser<'a> {\n         }\n     }\n \n-    fn parse_stmt_(&mut self) -> Option<Stmt> {\n-        self.parse_stmt_without_recovery().unwrap_or_else(|mut e| {\n+    fn parse_stmt_(&mut self, macro_expanded: bool) -> Option<Stmt> {\n+        self.parse_stmt_without_recovery(macro_expanded).unwrap_or_else(|mut e| {\n             e.emit();\n             self.recover_stmt_(SemiColonMode::Break);\n             None\n         })\n     }\n \n-    fn parse_stmt_without_recovery(&mut self) -> PResult<'a, Option<Stmt>> {\n+    fn parse_stmt_without_recovery(&mut self, macro_expanded: bool) -> PResult<'a, Option<Stmt>> {\n         maybe_whole!(Some deref self, NtStmt);\n \n         let attrs = self.parse_outer_attributes()?;\n@@ -3930,10 +3925,34 @@ impl<'a> Parser<'a> {\n \n             if id.name == keywords::Invalid.name() {\n                 let mac = spanned(lo, hi, Mac_ { path: pth, tts: tts });\n+                let node = if delim == token::Brace ||\n+                              self.token == token::Semi || self.token == token::Eof {\n+                    StmtKind::Mac(P((mac, style, attrs.into())))\n+                }\n+                // We used to incorrectly stop parsing macro-expanded statements here.\n+                // If the next token will be an error anyway but could have parsed with the\n+                // earlier behavior, stop parsing here and emit a warning to avoid breakage.\n+                else if macro_expanded && self.token.can_begin_expr() && match self.token {\n+                    // These can continue an expression, so we can't stop parsing and warn.\n+                    token::OpenDelim(token::Paren) | token::OpenDelim(token::Bracket) |\n+                    token::BinOp(token::Minus) | token::BinOp(token::Star) |\n+                    token::BinOp(token::And) | token::BinOp(token::Or) |\n+                    token::AndAnd | token::OrOr |\n+                    token::DotDot | token::DotDotDot => false,\n+                    _ => true,\n+                } {\n+                    self.warn_missing_semicolon();\n+                    StmtKind::Mac(P((mac, style, attrs.into())))\n+                } else {\n+                    let e = self.mk_mac_expr(lo, hi, mac.node, ThinVec::new());\n+                    let e = self.parse_dot_or_call_expr_with(e, lo, attrs.into())?;\n+                    let e = self.parse_assoc_expr_with(0, LhsExpr::AlreadyParsed(e))?;\n+                    StmtKind::Expr(e)\n+                };\n                 Stmt {\n                     id: ast::DUMMY_NODE_ID,\n-                    node: StmtKind::Mac(P((mac, style, attrs.into()))),\n                     span: mk_sp(lo, hi),\n+                    node: node,\n                 }\n             } else {\n                 // if it has a special ident, it's definitely an item\n@@ -4061,49 +4080,12 @@ impl<'a> Parser<'a> {\n     }\n \n     /// Parse a statement, including the trailing semicolon.\n-    /// This parses expression statements that begin with macros correctly (c.f. `parse_stmt`).\n     pub fn parse_full_stmt(&mut self, macro_expanded: bool) -> PResult<'a, Option<Stmt>> {\n-        let mut stmt = match self.parse_stmt_() {\n+        let mut stmt = match self.parse_stmt_(macro_expanded) {\n             Some(stmt) => stmt,\n             None => return Ok(None),\n         };\n \n-        if let StmtKind::Mac(mac) = stmt.node {\n-            if mac.1 != MacStmtStyle::NoBraces ||\n-               self.token == token::Semi || self.token == token::Eof {\n-                stmt.node = StmtKind::Mac(mac);\n-            } else {\n-                // We used to incorrectly stop parsing macro-expanded statements here.\n-                // If the next token will be an error anyway but could have parsed with the\n-                // earlier behavior, stop parsing here and emit a warning to avoid breakage.\n-                if macro_expanded && self.token.can_begin_expr() && match self.token {\n-                    // These tokens can continue an expression, so we can't stop parsing and warn.\n-                    token::OpenDelim(token::Paren) | token::OpenDelim(token::Bracket) |\n-                    token::BinOp(token::Minus) | token::BinOp(token::Star) |\n-                    token::BinOp(token::And) | token::BinOp(token::Or) |\n-                    token::AndAnd | token::OrOr |\n-                    token::DotDot | token::DotDotDot => false,\n-                    _ => true,\n-                } {\n-                    self.warn_missing_semicolon();\n-                    stmt.node = StmtKind::Mac(mac);\n-                    return Ok(Some(stmt));\n-                }\n-\n-                let (mac, _style, attrs) = mac.unwrap();\n-                let e = self.mk_mac_expr(stmt.span.lo, stmt.span.hi, mac.node, ThinVec::new());\n-                let e = self.parse_dot_or_call_expr_with(e, stmt.span.lo, attrs)?;\n-                let e = self.parse_assoc_expr_with(0, LhsExpr::AlreadyParsed(e))?;\n-                stmt.node = StmtKind::Expr(e);\n-            }\n-        }\n-\n-        stmt = self.handle_trailing_semicolon(stmt, macro_expanded)?;\n-        Ok(Some(stmt))\n-    }\n-\n-    fn handle_trailing_semicolon(&mut self, mut stmt: Stmt, macro_expanded: bool)\n-                                 -> PResult<'a, Stmt> {\n         match stmt.node {\n             StmtKind::Expr(ref expr) if self.token != token::Eof => {\n                 // expression without semicolon\n@@ -4133,7 +4115,7 @@ impl<'a> Parser<'a> {\n         }\n \n         stmt.span.hi = self.last_span.hi;\n-        Ok(stmt)\n+        Ok(Some(stmt))\n     }\n \n     fn warn_missing_semicolon(&self) {"}, {"sha": "8f46d3301eb370a411d94ec078340841a89e3eb1", "filename": "src/test/compile-fail/macro-stmt-matchers.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/06ca016b6e779ba972efb9d1735afc527d301505/src%2Ftest%2Fcompile-fail%2Fmacro-stmt-matchers.rs", "raw_url": "https://github.com/rust-lang/rust/raw/06ca016b6e779ba972efb9d1735afc527d301505/src%2Ftest%2Fcompile-fail%2Fmacro-stmt-matchers.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fmacro-stmt-matchers.rs?ref=06ca016b6e779ba972efb9d1735afc527d301505", "patch": "@@ -0,0 +1,17 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(rustc_attrs)]\n+\n+#[rustc_error]\n+fn main() { //~ ERROR compilation successful\n+    macro_rules! m { ($s:stmt;) => { $s } }\n+    m!(vec![].push(0););\n+}"}]}