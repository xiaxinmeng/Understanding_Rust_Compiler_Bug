{"sha": "b834c4c1bad7521af47f38f44a4048be0a1fe2ee", "node_id": "MDY6Q29tbWl0NzI0NzEyOmI4MzRjNGMxYmFkNzUyMWFmNDdmMzhmNDRhNDA0OGJlMGExZmUyZWU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-09-02T18:58:12Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-09-02T18:58:12Z"}, "message": "Auto merge of #88596 - m-ou-se:rollup-cidzt4v, r=m-ou-se\n\nRollup of 12 pull requests\n\nSuccessful merges:\n\n - #88177 (Stabilize std::os::unix::fs::chroot)\n - #88505 (Use `unwrap_unchecked` where possible)\n - #88512 (Upgrade array_into_iter lint to include Deref-to-array types.)\n - #88532 (Remove single use variables)\n - #88543 (Improve closure dummy capture suggestion in macros.)\n - #88560 (`fmt::Formatter::pad`: don't call chars().count() more than one time)\n - #88565 (Add regression test for issue 83190)\n - #88567 (Remove redundant `Span` in `QueryJobInfo`)\n - #88573 (rustdoc: Don't panic on ambiguous inherent associated types)\n - #88582 (Implement #88581)\n - #88589 (Correct doc comments inside `use_expr_visitor.rs`)\n - #88592 (Fix ICE in const check)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "05c1953f87411db5254bae0a205b2cdc3ea6ad54", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/05c1953f87411db5254bae0a205b2cdc3ea6ad54"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b834c4c1bad7521af47f38f44a4048be0a1fe2ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b834c4c1bad7521af47f38f44a4048be0a1fe2ee", "html_url": "https://github.com/rust-lang/rust/commit/b834c4c1bad7521af47f38f44a4048be0a1fe2ee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b834c4c1bad7521af47f38f44a4048be0a1fe2ee/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1cf8fdd4f0be26bcfa9e3b1e10d4bf80107ba492", "url": "https://api.github.com/repos/rust-lang/rust/commits/1cf8fdd4f0be26bcfa9e3b1e10d4bf80107ba492", "html_url": "https://github.com/rust-lang/rust/commit/1cf8fdd4f0be26bcfa9e3b1e10d4bf80107ba492"}, {"sha": "c082e157cae3307ea991e259758b26e855362b8e", "url": "https://api.github.com/repos/rust-lang/rust/commits/c082e157cae3307ea991e259758b26e855362b8e", "html_url": "https://github.com/rust-lang/rust/commit/c082e157cae3307ea991e259758b26e855362b8e"}], "stats": {"total": 942, "additions": 726, "deletions": 216}, "files": [{"sha": "5ac42c50c7240d22edb1adbd1b775248ac89d3fc", "filename": "compiler/rustc_lint/src/array_into_iter.rs", "status": "modified", "additions": 30, "deletions": 24, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/b834c4c1bad7521af47f38f44a4048be0a1fe2ee/compiler%2Frustc_lint%2Fsrc%2Farray_into_iter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b834c4c1bad7521af47f38f44a4048be0a1fe2ee/compiler%2Frustc_lint%2Fsrc%2Farray_into_iter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Farray_into_iter.rs?ref=b834c4c1bad7521af47f38f44a4048be0a1fe2ee", "patch": "@@ -74,39 +74,45 @@ impl<'tcx> LateLintPass<'tcx> for ArrayIntoIter {\n                 _ => return,\n             };\n \n-            // As this is a method call expression, we have at least one\n-            // argument.\n+            // As this is a method call expression, we have at least one argument.\n             let receiver_arg = &args[0];\n+            let receiver_ty = cx.typeck_results().expr_ty(receiver_arg);\n+            let adjustments = cx.typeck_results().expr_adjustments(receiver_arg);\n \n-            // Peel all `Box<_>` layers. We have to special case `Box` here as\n-            // `Box` is the only thing that values can be moved out of via\n-            // method call. `Box::new([1]).into_iter()` should trigger this\n-            // lint.\n-            let mut recv_ty = cx.typeck_results().expr_ty(receiver_arg);\n-            let mut num_box_derefs = 0;\n-            while recv_ty.is_box() {\n-                num_box_derefs += 1;\n-                recv_ty = recv_ty.boxed_ty();\n-            }\n+            let target = match adjustments.last() {\n+                Some(Adjustment { kind: Adjust::Borrow(_), target }) => target,\n+                _ => return,\n+            };\n \n-            // Make sure we found an array after peeling the boxes.\n-            if !matches!(recv_ty.kind(), ty::Array(..)) {\n-                return;\n+            let types =\n+                std::iter::once(receiver_ty).chain(adjustments.iter().map(|adj| adj.target));\n+\n+            let mut found_array = false;\n+\n+            for ty in types {\n+                match ty.kind() {\n+                    // If we run into a &[T; N] or &[T] first, there's nothing to warn about.\n+                    // It'll resolve to the reference version.\n+                    ty::Ref(_, inner_ty, _) if inner_ty.is_array() => return,\n+                    ty::Ref(_, inner_ty, _) if matches!(inner_ty.kind(), ty::Slice(..)) => return,\n+                    // Found an actual array type without matching a &[T; N] first.\n+                    // This is the problematic case.\n+                    ty::Array(..) => {\n+                        found_array = true;\n+                        break;\n+                    }\n+                    _ => {}\n+                }\n             }\n \n-            // Make sure that there is an autoref coercion at the expected\n-            // position. The first `num_box_derefs` adjustments are the derefs\n-            // of the box.\n-            match cx.typeck_results().expr_adjustments(receiver_arg).get(num_box_derefs) {\n-                Some(Adjustment { kind: Adjust::Borrow(_), .. }) => {}\n-                _ => return,\n+            if !found_array {\n+                return;\n             }\n \n             // Emit lint diagnostic.\n-            let target = match *cx.typeck_results().expr_ty_adjusted(receiver_arg).kind() {\n+            let target = match *target.kind() {\n                 ty::Ref(_, inner_ty, _) if inner_ty.is_array() => \"[T; N]\",\n                 ty::Ref(_, inner_ty, _) if matches!(inner_ty.kind(), ty::Slice(..)) => \"[T]\",\n-\n                 // We know the original first argument type is an array type,\n                 // we know that the first adjustment was an autoref coercion\n                 // and we know that `IntoIterator` is the trait involved. The\n@@ -135,7 +141,7 @@ impl<'tcx> LateLintPass<'tcx> for ArrayIntoIter {\n                         String::new(),\n                         Applicability::MaybeIncorrect,\n                     );\n-                } else {\n+                } else if receiver_ty.is_array() {\n                     diag.multipart_suggestion(\n                         \"or use `IntoIterator::into_iter(..)` instead of `.into_iter()` to explicitly iterate by value\",\n                         vec!["}, {"sha": "83f6e79d5fcf674dfbc8f3bb36bee4f3827bf78e", "filename": "compiler/rustc_middle/src/mir/mod.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b834c4c1bad7521af47f38f44a4048be0a1fe2ee/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b834c4c1bad7521af47f38f44a4048be0a1fe2ee/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fmir%2Fmod.rs?ref=b834c4c1bad7521af47f38f44a4048be0a1fe2ee", "patch": "@@ -411,8 +411,7 @@ impl<'tcx> Body<'tcx> {\n     /// Returns an iterator over all function arguments.\n     #[inline]\n     pub fn args_iter(&self) -> impl Iterator<Item = Local> + ExactSizeIterator {\n-        let arg_count = self.arg_count;\n-        (1..arg_count + 1).map(Local::new)\n+        (1..self.arg_count + 1).map(Local::new)\n     }\n \n     /// Returns an iterator over all user-defined variables and compiler-generated temporaries (all\n@@ -421,9 +420,7 @@ impl<'tcx> Body<'tcx> {\n     pub fn vars_and_temps_iter(\n         &self,\n     ) -> impl DoubleEndedIterator<Item = Local> + ExactSizeIterator {\n-        let arg_count = self.arg_count;\n-        let local_count = self.local_decls.len();\n-        (arg_count + 1..local_count).map(Local::new)\n+        (self.arg_count + 1..self.local_decls.len()).map(Local::new)\n     }\n \n     #[inline]"}, {"sha": "0c381276823598493e8aa12acd9fa6f30542271f", "filename": "compiler/rustc_mir/src/transform/check_consts/check.rs", "status": "modified", "additions": 19, "deletions": 17, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/b834c4c1bad7521af47f38f44a4048be0a1fe2ee/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b834c4c1bad7521af47f38f44a4048be0a1fe2ee/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fcheck.rs?ref=b834c4c1bad7521af47f38f44a4048be0a1fe2ee", "patch": "@@ -9,7 +9,7 @@ use rustc_infer::traits::{ImplSource, Obligation, ObligationCause};\n use rustc_middle::mir::visit::{MutatingUseContext, NonMutatingUseContext, PlaceContext, Visitor};\n use rustc_middle::mir::*;\n use rustc_middle::ty::cast::CastTy;\n-use rustc_middle::ty::subst::GenericArgKind;\n+use rustc_middle::ty::subst::{GenericArgKind, InternalSubsts};\n use rustc_middle::ty::{self, adjustment::PointerCast, Instance, InstanceDef, Ty, TyCtxt};\n use rustc_middle::ty::{Binder, TraitPredicate, TraitRef};\n use rustc_span::{sym, Span, Symbol};\n@@ -793,7 +793,7 @@ impl Visitor<'tcx> for Checker<'mir, 'tcx> {\n \n                 let fn_ty = func.ty(body, tcx);\n \n-                let (mut callee, substs) = match *fn_ty.kind() {\n+                let (mut callee, mut substs) = match *fn_ty.kind() {\n                     ty::FnDef(def_id, substs) => (def_id, substs),\n \n                     ty::FnPtr(_) => {\n@@ -846,29 +846,31 @@ impl Visitor<'tcx> for Checker<'mir, 'tcx> {\n                                 .iter()\n                                 .find(|did| tcx.item_name(**did) == callee_name)\n                             {\n+                                // using internal substs is ok here, since this is only\n+                                // used for the `resolve` call below\n+                                substs = InternalSubsts::identity_for_item(tcx, did);\n                                 callee = did;\n                             }\n                         }\n-                        _ => {\n-                            if !tcx.is_const_fn_raw(callee) {\n-                                // At this point, it is only legal when the caller is marked with\n-                                // #[default_method_body_is_const], and the callee is in the same\n-                                // trait.\n-                                let callee_trait = tcx.trait_of_item(callee);\n-                                if callee_trait.is_some() {\n-                                    if tcx.has_attr(caller, sym::default_method_body_is_const) {\n-                                        if tcx.trait_of_item(caller) == callee_trait {\n-                                            nonconst_call_permission = true;\n-                                        }\n+                        _ if !tcx.is_const_fn_raw(callee) => {\n+                            // At this point, it is only legal when the caller is marked with\n+                            // #[default_method_body_is_const], and the callee is in the same\n+                            // trait.\n+                            let callee_trait = tcx.trait_of_item(callee);\n+                            if callee_trait.is_some() {\n+                                if tcx.has_attr(caller, sym::default_method_body_is_const) {\n+                                    if tcx.trait_of_item(caller) == callee_trait {\n+                                        nonconst_call_permission = true;\n                                     }\n                                 }\n+                            }\n \n-                                if !nonconst_call_permission {\n-                                    self.check_op(ops::FnCallNonConst);\n-                                    return;\n-                                }\n+                            if !nonconst_call_permission {\n+                                self.check_op(ops::FnCallNonConst);\n+                                return;\n                             }\n                         }\n+                        _ => {}\n                     }\n \n                     // Resolve a trait method call to its concrete implementation, which may be in a"}, {"sha": "c3fdf4fc228511b0ebc767267f052461f681196a", "filename": "compiler/rustc_query_system/src/query/job.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b834c4c1bad7521af47f38f44a4048be0a1fe2ee/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fjob.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b834c4c1bad7521af47f38f44a4048be0a1fe2ee/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fjob.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fjob.rs?ref=b834c4c1bad7521af47f38f44a4048be0a1fe2ee", "patch": "@@ -61,7 +61,7 @@ where\n     }\n \n     fn query(self, map: &QueryMap<D>) -> QueryStackFrame {\n-        map.get(&self).unwrap().info.query.clone()\n+        map.get(&self).unwrap().query.clone()\n     }\n \n     #[cfg(parallel_compiler)]\n@@ -81,7 +81,7 @@ where\n }\n \n pub struct QueryJobInfo<D> {\n-    pub info: QueryInfo,\n+    pub query: QueryStackFrame,\n     pub job: QueryJob<D>,\n }\n \n@@ -155,7 +155,7 @@ where\n \n         while let Some(job) = current_job {\n             let info = query_map.get(&job).unwrap();\n-            cycle.push(info.info.clone());\n+            cycle.push(QueryInfo { span: info.job.span, query: info.query.clone() });\n \n             if job == *self {\n                 cycle.reverse();\n@@ -170,7 +170,7 @@ where\n                     .job\n                     .parent\n                     .as_ref()\n-                    .map(|parent| (info.info.span, parent.query(&query_map)));\n+                    .map(|parent| (info.job.span, parent.query(&query_map)));\n                 return CycleError { usage, cycle };\n             }\n \n@@ -649,13 +649,10 @@ pub fn print_query_stack<CTX: QueryContext>(\n         };\n         let mut diag = Diagnostic::new(\n             Level::FailureNote,\n-            &format!(\n-                \"#{} [{}] {}\",\n-                i, query_info.info.query.name, query_info.info.query.description\n-            ),\n+            &format!(\"#{} [{}] {}\", i, query_info.query.name, query_info.query.description),\n         );\n         diag.span =\n-            tcx.dep_context().sess().source_map().guess_head_span(query_info.info.span).into();\n+            tcx.dep_context().sess().source_map().guess_head_span(query_info.job.span).into();\n         handler.force_print_diagnostic(diag);\n \n         current_query = query_info.job.parent;"}, {"sha": "3f22de6fba4077987d673cb21dfe8a4fea89b830", "filename": "compiler/rustc_query_system/src/query/plumbing.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/b834c4c1bad7521af47f38f44a4048be0a1fe2ee/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b834c4c1bad7521af47f38f44a4048be0a1fe2ee/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fquery%2Fplumbing.rs?ref=b834c4c1bad7521af47f38f44a4048be0a1fe2ee", "patch": "@@ -130,8 +130,8 @@ where\n             for (k, v) in shard.active.iter() {\n                 if let QueryResult::Started(ref job) = *v {\n                     let id = QueryJobId::new(job.id, shard_id, kind);\n-                    let info = QueryInfo { span: job.span, query: make_query(tcx, k.clone()) };\n-                    jobs.insert(id, QueryJobInfo { info, job: job.clone() });\n+                    let query = make_query(tcx, k.clone());\n+                    jobs.insert(id, QueryJobInfo { query, job: job.clone() });\n                 }\n             }\n         }"}, {"sha": "702f69a9fcf0ba2381c181d97a40fefb78d93f53", "filename": "compiler/rustc_typeck/src/check/upvar.rs", "status": "modified", "additions": 26, "deletions": 9, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/b834c4c1bad7521af47f38f44a4048be0a1fe2ee/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b834c4c1bad7521af47f38f44a4048be0a1fe2ee/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fupvar.rs?ref=b834c4c1bad7521af47f38f44a4048be0a1fe2ee", "patch": "@@ -47,7 +47,7 @@ use rustc_middle::ty::{\n };\n use rustc_session::lint;\n use rustc_span::sym;\n-use rustc_span::{BytePos, MultiSpan, Pos, Span, Symbol, DUMMY_SP};\n+use rustc_span::{BytePos, MultiSpan, Pos, Span, Symbol};\n use rustc_trait_selection::infer::InferCtxtExt;\n \n use rustc_data_structures::stable_map::FxHashMap;\n@@ -680,15 +680,32 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         migrated_variables_concat\n                     );\n \n-                    // If the body was entirely expanded from a macro\n-                    // invocation, i.e. the body is not contained inside the\n-                    // closure span, then we walk up the expansion until we\n-                    // find the span before the expansion.\n-                    let closure_body_span = self.tcx.hir().span(body_id.hir_id)\n-                        .find_ancestor_inside(closure_span)\n-                        .unwrap_or(DUMMY_SP);\n+                    let mut closure_body_span = {\n+                        // If the body was entirely expanded from a macro\n+                        // invocation, i.e. the body is not contained inside the\n+                        // closure span, then we walk up the expansion until we\n+                        // find the span before the expansion.\n+                        let s = self.tcx.hir().span(body_id.hir_id);\n+                        s.find_ancestor_inside(closure_span).unwrap_or(s)\n+                    };\n+\n+                    if let Ok(mut s) = self.tcx.sess.source_map().span_to_snippet(closure_body_span) {\n+                        if s.starts_with('$') {\n+                            // Looks like a macro fragment. Try to find the real block.\n+                            if let Some(hir::Node::Expr(&hir::Expr {\n+                                kind: hir::ExprKind::Block(block, ..), ..\n+                            })) = self.tcx.hir().find(body_id.hir_id) {\n+                                // If the body is a block (with `{..}`), we use the span of that block.\n+                                // E.g. with a `|| $body` expanded from a `m!({ .. })`, we use `{ .. }`, and not `$body`.\n+                                // Since we know it's a block, we know we can insert the `let _ = ..` without\n+                                // breaking the macro syntax.\n+                                if let Ok(snippet) = self.tcx.sess.source_map().span_to_snippet(block.span) {\n+                                    closure_body_span = block.span;\n+                                    s = snippet;\n+                                }\n+                            }\n+                        }\n \n-                    if let Ok(s) = self.tcx.sess.source_map().span_to_snippet(closure_body_span) {\n                         let mut lines = s.lines();\n                         let line1 = lines.next().unwrap_or_default();\n "}, {"sha": "ba70006fe96b3bb7a918bbcde28f049addbd7ec0", "filename": "compiler/rustc_typeck/src/expr_use_visitor.rs", "status": "modified", "additions": 39, "deletions": 39, "changes": 78, "blob_url": "https://github.com/rust-lang/rust/blob/b834c4c1bad7521af47f38f44a4048be0a1fe2ee/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b834c4c1bad7521af47f38f44a4048be0a1fe2ee/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fexpr_use_visitor.rs?ref=b834c4c1bad7521af47f38f44a4048be0a1fe2ee", "patch": "@@ -21,74 +21,74 @@ use std::iter;\n \n use crate::mem_categorization as mc;\n \n-///////////////////////////////////////////////////////////////////////////\n-// The Delegate trait\n-\n /// This trait defines the callbacks you can expect to receive when\n /// employing the ExprUseVisitor.\n pub trait Delegate<'tcx> {\n-    // The value found at `place` is moved, depending\n-    // on `mode`. Where `diag_expr_id` is the id used for diagnostics for `place`.\n-    //\n-    // Use of a `Copy` type in a ByValue context is considered a use\n-    // by `ImmBorrow` and `borrow` is called instead. This is because\n-    // a shared borrow is the \"minimum access\" that would be needed\n-    // to perform a copy.\n-    //\n-    //\n-    // The parameter `diag_expr_id` indicates the HIR id that ought to be used for\n-    // diagnostics. Around pattern matching such as `let pat = expr`, the diagnostic\n-    // id will be the id of the expression `expr` but the place itself will have\n-    // the id of the binding in the pattern `pat`.\n+    /// The value found at `place` is moved, depending\n+    /// on `mode`. Where `diag_expr_id` is the id used for diagnostics for `place`.\n+    ///\n+    /// Use of a `Copy` type in a ByValue context is considered a use\n+    /// by `ImmBorrow` and `borrow` is called instead. This is because\n+    /// a shared borrow is the \"minimum access\" that would be needed\n+    /// to perform a copy.\n+    ///\n+    ///\n+    /// The parameter `diag_expr_id` indicates the HIR id that ought to be used for\n+    /// diagnostics. Around pattern matching such as `let pat = expr`, the diagnostic\n+    /// id will be the id of the expression `expr` but the place itself will have\n+    /// the id of the binding in the pattern `pat`.\n     fn consume(&mut self, place_with_id: &PlaceWithHirId<'tcx>, diag_expr_id: hir::HirId);\n \n-    // The value found at `place` is being borrowed with kind `bk`.\n-    // `diag_expr_id` is the id used for diagnostics (see `consume` for more details).\n+    /// The value found at `place` is being borrowed with kind `bk`.\n+    /// `diag_expr_id` is the id used for diagnostics (see `consume` for more details).\n     fn borrow(\n         &mut self,\n         place_with_id: &PlaceWithHirId<'tcx>,\n         diag_expr_id: hir::HirId,\n         bk: ty::BorrowKind,\n     );\n \n-    // The path at `assignee_place` is being assigned to.\n-    // `diag_expr_id` is the id used for diagnostics (see `consume` for more details).\n+    /// The path at `assignee_place` is being assigned to.\n+    /// `diag_expr_id` is the id used for diagnostics (see `consume` for more details).\n     fn mutate(&mut self, assignee_place: &PlaceWithHirId<'tcx>, diag_expr_id: hir::HirId);\n \n-    // The `place` should be a fake read because of specified `cause`.\n+    /// The `place` should be a fake read because of specified `cause`.\n     fn fake_read(&mut self, place: Place<'tcx>, cause: FakeReadCause, diag_expr_id: hir::HirId);\n }\n \n #[derive(Copy, Clone, PartialEq, Debug)]\n enum ConsumeMode {\n-    Copy, // reference to x where x has a type that copies\n-    Move, // reference to x where x has a type that moves\n+    /// reference to x where x has a type that copies\n+    Copy,\n+    /// reference to x where x has a type that moves\n+    Move,\n }\n \n #[derive(Copy, Clone, PartialEq, Debug)]\n pub enum MutateMode {\n     Init,\n-    JustWrite,    // x = y\n-    WriteAndRead, // x += y\n+    /// Example: `x = y`\n+    JustWrite,\n+    /// Example: `x += y`\n+    WriteAndRead,\n }\n \n-///////////////////////////////////////////////////////////////////////////\n-// The ExprUseVisitor type\n-//\n-// This is the code that actually walks the tree.\n+/// The ExprUseVisitor type\n+///\n+/// This is the code that actually walks the tree.\n pub struct ExprUseVisitor<'a, 'tcx> {\n     mc: mc::MemCategorizationContext<'a, 'tcx>,\n     body_owner: LocalDefId,\n     delegate: &'a mut dyn Delegate<'tcx>,\n }\n \n-// If the MC results in an error, it's because the type check\n-// failed (or will fail, when the error is uncovered and reported\n-// during writeback). In this case, we just ignore this part of the\n-// code.\n-//\n-// Note that this macro appears similar to try!(), but, unlike try!(),\n-// it does not propagate the error.\n+/// If the MC results in an error, it's because the type check\n+/// failed (or will fail, when the error is uncovered and reported\n+/// during writeback). In this case, we just ignore this part of the\n+/// code.\n+///\n+/// Note that this macro appears similar to try!(), but, unlike try!(),\n+/// it does not propagate the error.\n macro_rules! return_if_err {\n     ($inp: expr) => {\n         match $inp {\n@@ -537,9 +537,9 @@ impl<'a, 'tcx> ExprUseVisitor<'a, 'tcx> {\n         self.walk_expr(with_expr);\n     }\n \n-    // Invoke the appropriate delegate calls for anything that gets\n-    // consumed or borrowed as part of the automatic adjustment\n-    // process.\n+    /// Invoke the appropriate delegate calls for anything that gets\n+    /// consumed or borrowed as part of the automatic adjustment\n+    /// process.\n     fn walk_adjustment(&mut self, expr: &hir::Expr<'_>) {\n         let adjustments = self.mc.typeck_results.expr_adjustments(expr);\n         let mut place_with_id = return_if_err!(self.mc.cat_expr_unadjusted(expr));"}, {"sha": "9d45c5082db434cb4a13cf63776f3e529aee1b39", "filename": "library/alloc/src/collections/linked_list.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b834c4c1bad7521af47f38f44a4048be0a1fe2ee/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b834c4c1bad7521af47f38f44a4048be0a1fe2ee/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fcollections%2Flinked_list.rs?ref=b834c4c1bad7521af47f38f44a4048be0a1fe2ee", "patch": "@@ -300,7 +300,10 @@ impl<T> LinkedList<T> {\n         let tail = self.tail.take();\n         let len = mem::replace(&mut self.len, 0);\n         if let Some(head) = head {\n-            let tail = tail.unwrap_or_else(|| unsafe { core::hint::unreachable_unchecked() });\n+            // SAFETY: In a LinkedList, either both the head and tail are None because\n+            // the list is empty, or both head and tail are Some because the list is populated.\n+            // Since we have verified the head is Some, we are sure the tail is Some too.\n+            let tail = unsafe { tail.unwrap_unchecked() };\n             Some((head, tail, len))\n         } else {\n             None"}, {"sha": "70cccd31b92ded435eb886bd9a475bc79b27a1c1", "filename": "library/core/src/array/mod.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b834c4c1bad7521af47f38f44a4048be0a1fe2ee/library%2Fcore%2Fsrc%2Farray%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b834c4c1bad7521af47f38f44a4048be0a1fe2ee/library%2Fcore%2Fsrc%2Farray%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Farray%2Fmod.rs?ref=b834c4c1bad7521af47f38f44a4048be0a1fe2ee", "patch": "@@ -459,11 +459,8 @@ where\n     debug_assert!(N <= iter.size_hint().1.unwrap_or(usize::MAX));\n     debug_assert!(N <= iter.size_hint().0);\n \n-    match collect_into_array(iter) {\n-        Some(array) => array,\n-        // SAFETY: covered by the function contract.\n-        None => unsafe { crate::hint::unreachable_unchecked() },\n-    }\n+    // SAFETY: covered by the function contract.\n+    unsafe { collect_into_array(iter).unwrap_unchecked() }\n }\n \n /// Pulls `N` items from `iter` and returns them as an array. If the iterator"}, {"sha": "aff789f2afa1486b1b25816b2d15ccb6c5510493", "filename": "library/core/src/fmt/mod.rs", "status": "modified", "additions": 17, "deletions": 12, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/b834c4c1bad7521af47f38f44a4048be0a1fe2ee/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b834c4c1bad7521af47f38f44a4048be0a1fe2ee/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ffmt%2Fmod.rs?ref=b834c4c1bad7521af47f38f44a4048be0a1fe2ee", "patch": "@@ -402,7 +402,7 @@ impl<'a> Arguments<'a> {\n \n         if self.args.is_empty() {\n             pieces_length\n-        } else if self.pieces[0] == \"\" && pieces_length < 16 {\n+        } else if !self.pieces.is_empty() && self.pieces[0].is_empty() && pieces_length < 16 {\n             // If the format string starts with an argument,\n             // don't preallocate anything, unless length\n             // of pieces is significant.\n@@ -1163,7 +1163,7 @@ pub fn write(output: &mut dyn Write, args: Arguments<'_>) -> Result {\n                 }\n                 // SAFETY: arg and args.args come from the same Arguments,\n                 // which guarantees the indexes are always within bounds.\n-                unsafe { run(&mut formatter, arg, &args.args) }?;\n+                unsafe { run(&mut formatter, arg, args.args) }?;\n                 idx += 1;\n             }\n         }\n@@ -1409,7 +1409,7 @@ impl<'a> Formatter<'a> {\n                 // we know that it can't panic. Use `get` + `unwrap_or` to avoid\n                 // `unsafe` and otherwise don't emit any panic-related code\n                 // here.\n-                s.get(..i).unwrap_or(&s)\n+                s.get(..i).unwrap_or(s)\n             } else {\n                 &s\n             }\n@@ -1421,16 +1421,21 @@ impl<'a> Formatter<'a> {\n             // If we're under the maximum length, and there's no minimum length\n             // requirements, then we can just emit the string\n             None => self.buf.write_str(s),\n-            // If we're under the maximum width, check if we're over the minimum\n-            // width, if so it's as easy as just emitting the string.\n-            Some(width) if s.chars().count() >= width => self.buf.write_str(s),\n-            // If we're under both the maximum and the minimum width, then fill\n-            // up the minimum width with the specified string + some alignment.\n             Some(width) => {\n-                let align = rt::v1::Alignment::Left;\n-                let post_padding = self.padding(width - s.chars().count(), align)?;\n-                self.buf.write_str(s)?;\n-                post_padding.write(self.buf)\n+                let chars_count = s.chars().count();\n+                // If we're under the maximum width, check if we're over the minimum\n+                // width, if so it's as easy as just emitting the string.\n+                if chars_count >= width {\n+                    self.buf.write_str(s)\n+                }\n+                // If we're under both the maximum and the minimum width, then fill\n+                // up the minimum width with the specified string + some alignment.\n+                else {\n+                    let align = rt::v1::Alignment::Left;\n+                    let post_padding = self.padding(width - chars_count, align)?;\n+                    self.buf.write_str(s)?;\n+                    post_padding.write(self.buf)\n+                }\n             }\n         }\n     }"}, {"sha": "780d6c34c919732640dc0da9004f85eae97dc4d6", "filename": "library/core/src/num/int_macros.rs", "status": "modified", "additions": 167, "deletions": 0, "changes": 167, "blob_url": "https://github.com/rust-lang/rust/blob/b834c4c1bad7521af47f38f44a4048be0a1fe2ee/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b834c4c1bad7521af47f38f44a4048be0a1fe2ee/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fint_macros.rs?ref=b834c4c1bad7521af47f38f44a4048be0a1fe2ee", "patch": "@@ -1834,6 +1834,173 @@ macro_rules! int_impl {\n             }\n         }\n \n+        /// Calculates the quotient of `self` and `rhs`, rounding the result towards negative infinity.\n+        ///\n+        /// # Panics\n+        ///\n+        /// This function will panic if `rhs` is 0 or the division results in overflow.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage:\n+        ///\n+        /// ```\n+        /// #![feature(int_roundings)]\n+        #[doc = concat!(\"let a: \", stringify!($SelfT),\" = 8;\")]\n+        /// let b = 3;\n+        ///\n+        /// assert_eq!(a.div_floor(b), 2);\n+        /// assert_eq!(a.div_floor(-b), -3);\n+        /// assert_eq!((-a).div_floor(b), -3);\n+        /// assert_eq!((-a).div_floor(-b), 2);\n+        /// ```\n+        #[unstable(feature = \"int_roundings\", issue = \"88581\")]\n+        #[must_use = \"this returns the result of the operation, \\\n+                      without modifying the original\"]\n+        #[inline]\n+        #[rustc_inherit_overflow_checks]\n+        pub const fn div_floor(self, rhs: Self) -> Self {\n+            let d = self / rhs;\n+            let r = self % rhs;\n+            if (r > 0 && rhs < 0) || (r < 0 && rhs > 0) {\n+                d - 1\n+            } else {\n+                d\n+            }\n+        }\n+\n+        /// Calculates the quotient of `self` and `rhs`, rounding the result towards positive infinity.\n+        ///\n+        /// # Panics\n+        ///\n+        /// This function will panic if `rhs` is 0 or the division results in overflow.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage:\n+        ///\n+        /// ```\n+        /// #![feature(int_roundings)]\n+        #[doc = concat!(\"let a: \", stringify!($SelfT),\" = 8;\")]\n+        /// let b = 3;\n+        ///\n+        /// assert_eq!(a.div_ceil(b), 3);\n+        /// assert_eq!(a.div_ceil(-b), -2);\n+        /// assert_eq!((-a).div_ceil(b), -2);\n+        /// assert_eq!((-a).div_ceil(-b), 3);\n+        /// ```\n+        #[unstable(feature = \"int_roundings\", issue = \"88581\")]\n+        #[must_use = \"this returns the result of the operation, \\\n+                      without modifying the original\"]\n+        #[inline]\n+        #[rustc_inherit_overflow_checks]\n+        pub const fn div_ceil(self, rhs: Self) -> Self {\n+            let d = self / rhs;\n+            let r = self % rhs;\n+            if (r > 0 && rhs > 0) || (r < 0 && rhs < 0) {\n+                d + 1\n+            } else {\n+                d\n+            }\n+        }\n+\n+        /// If `rhs` is positive, calculates the smallest value greater than or\n+        /// equal to `self` that is a multiple of `rhs`. If `rhs` is negative,\n+        /// calculates the largest value less than or equal to `self` that is a\n+        /// multiple of `rhs`.\n+        ///\n+        /// # Panics\n+        ///\n+        /// This function will panic if `rhs` is 0 or the operation results in overflow.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage:\n+        ///\n+        /// ```\n+        /// #![feature(int_roundings)]\n+        #[doc = concat!(\"assert_eq!(16_\", stringify!($SelfT), \".next_multiple_of(8), 16);\")]\n+        #[doc = concat!(\"assert_eq!(23_\", stringify!($SelfT), \".next_multiple_of(8), 24);\")]\n+        #[doc = concat!(\"assert_eq!(16_\", stringify!($SelfT), \".next_multiple_of(-8), 16);\")]\n+        #[doc = concat!(\"assert_eq!(23_\", stringify!($SelfT), \".next_multiple_of(-8), 16);\")]\n+        #[doc = concat!(\"assert_eq!((-16_\", stringify!($SelfT), \").next_multiple_of(8), -16);\")]\n+        #[doc = concat!(\"assert_eq!((-23_\", stringify!($SelfT), \").next_multiple_of(8), -16);\")]\n+        #[doc = concat!(\"assert_eq!((-16_\", stringify!($SelfT), \").next_multiple_of(-8), -16);\")]\n+        #[doc = concat!(\"assert_eq!((-23_\", stringify!($SelfT), \").next_multiple_of(-8), -24);\")]\n+        /// ```\n+        #[unstable(feature = \"int_roundings\", issue = \"88581\")]\n+        #[must_use = \"this returns the result of the operation, \\\n+                      without modifying the original\"]\n+        #[inline]\n+        #[rustc_inherit_overflow_checks]\n+        pub const fn next_multiple_of(self, rhs: Self) -> Self {\n+            // This would otherwise fail when calculating `r` when self == T::MIN.\n+            if rhs == -1 {\n+                return self;\n+            }\n+\n+            let r = self % rhs;\n+            let m = if (r > 0 && rhs < 0) || (r < 0 && rhs > 0) {\n+                r + rhs\n+            } else {\n+                r\n+            };\n+\n+            if m == 0 {\n+                self\n+            } else {\n+                self + (rhs - m)\n+            }\n+        }\n+\n+        /// If `rhs` is positive, calculates the smallest value greater than or\n+        /// equal to `self` that is a multiple of `rhs`. If `rhs` is negative,\n+        /// calculates the largest value less than or equal to `self` that is a\n+        /// multiple of `rhs`. Returns `None` if `rhs` is zero or the operation\n+        /// would result in overflow.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage:\n+        ///\n+        /// ```\n+        /// #![feature(int_roundings)]\n+        #[doc = concat!(\"assert_eq!(16_\", stringify!($SelfT), \".checked_next_multiple_of(8), Some(16));\")]\n+        #[doc = concat!(\"assert_eq!(23_\", stringify!($SelfT), \".checked_next_multiple_of(8), Some(24));\")]\n+        #[doc = concat!(\"assert_eq!(16_\", stringify!($SelfT), \".checked_next_multiple_of(-8), Some(16));\")]\n+        #[doc = concat!(\"assert_eq!(23_\", stringify!($SelfT), \".checked_next_multiple_of(-8), Some(16));\")]\n+        #[doc = concat!(\"assert_eq!((-16_\", stringify!($SelfT), \").checked_next_multiple_of(8), Some(-16));\")]\n+        #[doc = concat!(\"assert_eq!((-23_\", stringify!($SelfT), \").checked_next_multiple_of(8), Some(-16));\")]\n+        #[doc = concat!(\"assert_eq!((-16_\", stringify!($SelfT), \").checked_next_multiple_of(-8), Some(-16));\")]\n+        #[doc = concat!(\"assert_eq!((-23_\", stringify!($SelfT), \").checked_next_multiple_of(-8), Some(-24));\")]\n+        #[doc = concat!(\"assert_eq!(1_\", stringify!($SelfT), \".checked_next_multiple_of(0), None);\")]\n+        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_next_multiple_of(2), None);\")]\n+        /// ```\n+        #[unstable(feature = \"int_roundings\", issue = \"88581\")]\n+        #[must_use = \"this returns the result of the operation, \\\n+                      without modifying the original\"]\n+        #[inline]\n+        #[rustc_inherit_overflow_checks]\n+        pub const fn checked_next_multiple_of(self, rhs: Self) -> Option<Self> {\n+            // This would otherwise fail when calculating `r` when self == T::MIN.\n+            if rhs == -1 {\n+                return Some(self);\n+            }\n+\n+            let r = try_opt!(self.checked_rem(rhs));\n+            let m = if (r > 0 && rhs < 0) || (r < 0 && rhs > 0) {\n+                try_opt!(r.checked_add(rhs))\n+            } else {\n+                r\n+            };\n+\n+            if m == 0 {\n+                Some(self)\n+            } else {\n+                self.checked_add(try_opt!(rhs.checked_sub(m)))\n+            }\n+        }\n+\n         /// Returns the logarithm of the number with respect to an arbitrary base.\n         ///\n         /// This method might not be optimized owing to implementation details;"}, {"sha": "02a5ed4ca800e124de5d6791164285fc48984247", "filename": "library/core/src/num/uint_macros.rs", "status": "modified", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/b834c4c1bad7521af47f38f44a4048be0a1fe2ee/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b834c4c1bad7521af47f38f44a4048be0a1fe2ee/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fnum%2Fuint_macros.rs?ref=b834c4c1bad7521af47f38f44a4048be0a1fe2ee", "patch": "@@ -1848,6 +1848,110 @@ macro_rules! uint_impl {\n             self % rhs\n         }\n \n+        /// Calculates the quotient of `self` and `rhs`, rounding the result towards negative infinity.\n+        ///\n+        /// This is the same as performing `self / rhs` for all unsigned integers.\n+        ///\n+        /// # Panics\n+        ///\n+        /// This function will panic if `rhs` is 0.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage:\n+        ///\n+        /// ```\n+        /// #![feature(int_roundings)]\n+        #[doc = concat!(\"assert_eq!(7_\", stringify!($SelfT), \".div_floor(4), 1);\")]\n+        /// ```\n+        #[unstable(feature = \"int_roundings\", issue = \"88581\")]\n+        #[inline(always)]\n+        #[rustc_inherit_overflow_checks]\n+        pub const fn div_floor(self, rhs: Self) -> Self {\n+            self / rhs\n+        }\n+\n+        /// Calculates the quotient of `self` and `rhs`, rounding the result towards positive infinity.\n+        ///\n+        /// # Panics\n+        ///\n+        /// This function will panic if `rhs` is 0.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage:\n+        ///\n+        /// ```\n+        /// #![feature(int_roundings)]\n+        #[doc = concat!(\"assert_eq!(7_\", stringify!($SelfT), \".div_ceil(4), 2);\")]\n+        /// ```\n+        #[unstable(feature = \"int_roundings\", issue = \"88581\")]\n+        #[inline]\n+        #[rustc_inherit_overflow_checks]\n+        pub const fn div_ceil(self, rhs: Self) -> Self {\n+            let d = self / rhs;\n+            let r = self % rhs;\n+            if r > 0 && rhs > 0 {\n+                d + 1\n+            } else {\n+                d\n+            }\n+        }\n+\n+        /// Calculates the smallest value greater than or equal to `self` that\n+        /// is a multiple of `rhs`.\n+        ///\n+        /// # Panics\n+        ///\n+        /// This function will panic if `rhs` is 0 or the operation results in overflow.\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage:\n+        ///\n+        /// ```\n+        /// #![feature(int_roundings)]\n+        #[doc = concat!(\"assert_eq!(16_\", stringify!($SelfT), \".next_multiple_of(8), 16);\")]\n+        #[doc = concat!(\"assert_eq!(23_\", stringify!($SelfT), \".next_multiple_of(8), 24);\")]\n+        /// ```\n+        #[unstable(feature = \"int_roundings\", issue = \"88581\")]\n+        #[must_use = \"this returns the result of the operation, \\\n+                      without modifying the original\"]\n+        #[inline]\n+        #[rustc_inherit_overflow_checks]\n+        pub const fn next_multiple_of(self, rhs: Self) -> Self {\n+            match self % rhs {\n+                0 => self,\n+                r => self + (rhs - r)\n+            }\n+        }\n+\n+        /// Calculates the smallest value greater than or equal to `self` that\n+        /// is a multiple of `rhs`. If `rhs` is negative,\n+        ///\n+        /// # Examples\n+        ///\n+        /// Basic usage:\n+        ///\n+        /// ```\n+        /// #![feature(int_roundings)]\n+        #[doc = concat!(\"assert_eq!(16_\", stringify!($SelfT), \".checked_next_multiple_of(8), Some(16));\")]\n+        #[doc = concat!(\"assert_eq!(23_\", stringify!($SelfT), \".checked_next_multiple_of(8), Some(24));\")]\n+        #[doc = concat!(\"assert_eq!(1_\", stringify!($SelfT), \".checked_next_multiple_of(0), None);\")]\n+        #[doc = concat!(\"assert_eq!(\", stringify!($SelfT), \"::MAX.checked_next_multiple_of(2), None);\")]\n+        /// ```\n+        #[unstable(feature = \"int_roundings\", issue = \"88581\")]\n+        #[must_use = \"this returns the result of the operation, \\\n+                      without modifying the original\"]\n+        #[inline]\n+        #[rustc_inherit_overflow_checks]\n+        pub const fn checked_next_multiple_of(self, rhs: Self) -> Option<Self> {\n+            match try_opt!(self.checked_rem(rhs)) {\n+                0 => Some(self),\n+                r => self.checked_add(try_opt!(rhs.checked_sub(r)))\n+            }\n+        }\n+\n         /// Returns `true` if and only if `self == 2^k` for some `k`.\n         ///\n         /// # Examples"}, {"sha": "9d5e03dd0de795eeefe17466421e81b0b203ee72", "filename": "library/core/src/option.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/b834c4c1bad7521af47f38f44a4048be0a1fe2ee/library%2Fcore%2Fsrc%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b834c4c1bad7521af47f38f44a4048be0a1fe2ee/library%2Fcore%2Fsrc%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Foption.rs?ref=b834c4c1bad7521af47f38f44a4048be0a1fe2ee", "patch": "@@ -1198,11 +1198,8 @@ impl<T> Option<T> {\n     pub fn insert(&mut self, value: T) -> &mut T {\n         *self = Some(value);\n \n-        match self {\n-            Some(v) => v,\n-            // SAFETY: the code above just filled the option\n-            None => unsafe { hint::unreachable_unchecked() },\n-        }\n+        // SAFETY: the code above just filled the option\n+        unsafe { self.as_mut().unwrap_unchecked() }\n     }\n \n     /// Inserts `value` into the option if it is [`None`], then"}, {"sha": "19bcc45108dfd5225761723e0c6b7bb64fbb0eaa", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/b834c4c1bad7521af47f38f44a4048be0a1fe2ee/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b834c4c1bad7521af47f38f44a4048be0a1fe2ee/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=b834c4c1bad7521af47f38f44a4048be0a1fe2ee", "patch": "@@ -64,6 +64,7 @@\n #![feature(unsized_tuple_coercion)]\n #![feature(const_option)]\n #![feature(integer_atomics)]\n+#![feature(int_roundings)]\n #![feature(slice_group_by)]\n #![feature(trusted_random_access)]\n #![feature(unsize)]"}, {"sha": "d2d655ea2c75015959b518a695d6b4dd8f63240a", "filename": "library/core/tests/num/int_macros.rs", "status": "modified", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/b834c4c1bad7521af47f38f44a4048be0a1fe2ee/library%2Fcore%2Ftests%2Fnum%2Fint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b834c4c1bad7521af47f38f44a4048be0a1fe2ee/library%2Fcore%2Ftests%2Fnum%2Fint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fnum%2Fint_macros.rs?ref=b834c4c1bad7521af47f38f44a4048be0a1fe2ee", "patch": "@@ -289,6 +289,55 @@ macro_rules! int_module {\n                 assert_eq!(r.saturating_pow(3), -8 as $T);\n                 assert_eq!(r.saturating_pow(0), 1 as $T);\n             }\n+\n+            #[test]\n+            fn test_div_floor() {\n+                let a: $T = 8;\n+                let b = 3;\n+                assert_eq!(a.div_floor(b), 2);\n+                assert_eq!(a.div_floor(-b), -3);\n+                assert_eq!((-a).div_floor(b), -3);\n+                assert_eq!((-a).div_floor(-b), 2);\n+            }\n+\n+            #[test]\n+            fn test_div_ceil() {\n+                let a: $T = 8;\n+                let b = 3;\n+                assert_eq!(a.div_ceil(b), 3);\n+                assert_eq!(a.div_ceil(-b), -2);\n+                assert_eq!((-a).div_ceil(b), -2);\n+                assert_eq!((-a).div_ceil(-b), 3);\n+            }\n+\n+            #[test]\n+            fn test_next_multiple_of() {\n+                assert_eq!((16 as $T).next_multiple_of(8), 16);\n+                assert_eq!((23 as $T).next_multiple_of(8), 24);\n+                assert_eq!((16 as $T).next_multiple_of(-8), 16);\n+                assert_eq!((23 as $T).next_multiple_of(-8), 16);\n+                assert_eq!((-16 as $T).next_multiple_of(8), -16);\n+                assert_eq!((-23 as $T).next_multiple_of(8), -16);\n+                assert_eq!((-16 as $T).next_multiple_of(-8), -16);\n+                assert_eq!((-23 as $T).next_multiple_of(-8), -24);\n+                assert_eq!(MIN.next_multiple_of(-1), MIN);\n+            }\n+\n+            #[test]\n+            fn test_checked_next_multiple_of() {\n+                assert_eq!((16 as $T).checked_next_multiple_of(8), Some(16));\n+                assert_eq!((23 as $T).checked_next_multiple_of(8), Some(24));\n+                assert_eq!((16 as $T).checked_next_multiple_of(-8), Some(16));\n+                assert_eq!((23 as $T).checked_next_multiple_of(-8), Some(16));\n+                assert_eq!((-16 as $T).checked_next_multiple_of(8), Some(-16));\n+                assert_eq!((-23 as $T).checked_next_multiple_of(8), Some(-16));\n+                assert_eq!((-16 as $T).checked_next_multiple_of(-8), Some(-16));\n+                assert_eq!((-23 as $T).checked_next_multiple_of(-8), Some(-24));\n+                assert_eq!((1 as $T).checked_next_multiple_of(0), None);\n+                assert_eq!(MAX.checked_next_multiple_of(2), None);\n+                assert_eq!(MIN.checked_next_multiple_of(-3), None);\n+                assert_eq!(MIN.checked_next_multiple_of(-1), Some(MIN));\n+            }\n         }\n     };\n }"}, {"sha": "49f8f1f13fad46ffc0a79fd228b5e4f8bbf0f5e2", "filename": "library/core/tests/num/uint_macros.rs", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b834c4c1bad7521af47f38f44a4048be0a1fe2ee/library%2Fcore%2Ftests%2Fnum%2Fuint_macros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b834c4c1bad7521af47f38f44a4048be0a1fe2ee/library%2Fcore%2Ftests%2Fnum%2Fuint_macros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Fnum%2Fuint_macros.rs?ref=b834c4c1bad7521af47f38f44a4048be0a1fe2ee", "patch": "@@ -205,6 +205,31 @@ macro_rules! uint_module {\n                 assert_eq!(r.overflowing_pow(2), (1 as $T, true));\n                 assert_eq!(r.saturating_pow(2), MAX);\n             }\n+\n+            #[test]\n+            fn test_div_floor() {\n+                assert_eq!((8 as $T).div_floor(3), 2);\n+            }\n+\n+            #[test]\n+            fn test_div_ceil() {\n+                assert_eq!((8 as $T).div_ceil(3), 3);\n+            }\n+\n+            #[test]\n+            fn test_next_multiple_of() {\n+                assert_eq!((16 as $T).next_multiple_of(8), 16);\n+                assert_eq!((23 as $T).next_multiple_of(8), 24);\n+                assert_eq!(MAX.next_multiple_of(1), MAX);\n+            }\n+\n+            #[test]\n+            fn test_checked_next_multiple_of() {\n+                assert_eq!((16 as $T).checked_next_multiple_of(8), Some(16));\n+                assert_eq!((23 as $T).checked_next_multiple_of(8), Some(24));\n+                assert_eq!((1 as $T).checked_next_multiple_of(0), None);\n+                assert_eq!(MAX.checked_next_multiple_of(2), None);\n+            }\n         }\n     };\n }"}, {"sha": "6cf37f23c574d745d2c5fccb30f9dbd53a4f0e8f", "filename": "library/std/src/os/unix/fs.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/b834c4c1bad7521af47f38f44a4048be0a1fe2ee/library%2Fstd%2Fsrc%2Fos%2Funix%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b834c4c1bad7521af47f38f44a4048be0a1fe2ee/library%2Fstd%2Fsrc%2Fos%2Funix%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fos%2Funix%2Ffs.rs?ref=b834c4c1bad7521af47f38f44a4048be0a1fe2ee", "patch": "@@ -934,7 +934,6 @@ impl DirBuilderExt for fs::DirBuilder {\n /// # Examples\n ///\n /// ```no_run\n-/// #![feature(unix_chroot)]\n /// use std::os::unix::fs;\n ///\n /// fn main() -> std::io::Result<()> {\n@@ -944,7 +943,7 @@ impl DirBuilderExt for fs::DirBuilder {\n ///     Ok(())\n /// }\n /// ```\n-#[unstable(feature = \"unix_chroot\", issue = \"84715\")]\n+#[stable(feature = \"unix_chroot\", since = \"1.56.0\")]\n #[cfg(not(any(target_os = \"fuchsia\", target_os = \"vxworks\")))]\n pub fn chroot<P: AsRef<Path>>(dir: P) -> io::Result<()> {\n     sys::fs::chroot(dir.as_ref())"}, {"sha": "a9baa1c31aeb8785958feb2b360053fb09b48d6c", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/b834c4c1bad7521af47f38f44a4048be0a1fe2ee/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b834c4c1bad7521af47f38f44a4048be0a1fe2ee/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=b834c4c1bad7521af47f38f44a4048be0a1fe2ee", "patch": "@@ -1311,10 +1311,11 @@ fn clean_qpath(hir_ty: &hir::Ty<'_>, cx: &mut DocContext<'_>) -> Type {\n         }\n         hir::QPath::TypeRelative(ref qself, ref segment) => {\n             let ty = hir_ty_to_ty(cx.tcx, hir_ty);\n-            let res = if let ty::Projection(proj) = ty.kind() {\n-                Res::Def(DefKind::Trait, proj.trait_ref(cx.tcx).def_id)\n-            } else {\n-                Res::Err\n+            let res = match ty.kind() {\n+                ty::Projection(proj) => Res::Def(DefKind::Trait, proj.trait_ref(cx.tcx).def_id),\n+                // Rustdoc handles `ty::Error`s by turning them into `Type::Infer`s.\n+                ty::Error(_) => return Type::Infer,\n+                _ => bug!(\"clean: expected associated type, found `{:?}`\", ty),\n             };\n             let trait_path = hir::Path { span, res, segments: &[] }.clean(cx);\n             Type::QPath {\n@@ -1379,6 +1380,7 @@ impl Clean<Type> for hir::Ty<'_> {\n                 DynTrait(bounds, lifetime)\n             }\n             TyKind::BareFn(ref barefn) => BareFunction(Box::new(barefn.clean(cx))),\n+            // Rustdoc handles `TyKind::Err`s by turning them into `Type::Infer`s.\n             TyKind::Infer | TyKind::Err => Infer,\n             TyKind::Typeof(..) => panic!(\"unimplemented type {:?}\", self.kind),\n         }"}, {"sha": "3ad56aebc21c580b28a4638d53dde913c289fa43", "filename": "src/test/rustdoc-ui/ambiguous-inherent-assoc-ty.rs", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/b834c4c1bad7521af47f38f44a4048be0a1fe2ee/src%2Ftest%2Frustdoc-ui%2Fambiguous-inherent-assoc-ty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b834c4c1bad7521af47f38f44a4048be0a1fe2ee/src%2Ftest%2Frustdoc-ui%2Fambiguous-inherent-assoc-ty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fambiguous-inherent-assoc-ty.rs?ref=b834c4c1bad7521af47f38f44a4048be0a1fe2ee", "patch": "@@ -0,0 +1,17 @@\n+// This test ensures that rustdoc does not panic on inherented associated types\n+// that are referred to without fully-qualified syntax.\n+\n+#![feature(inherent_associated_types)]\n+#![allow(incomplete_features)]\n+\n+pub struct Struct;\n+\n+impl Struct {\n+    pub type AssocTy = usize;\n+    pub const AssocConst: Self::AssocTy = 42;\n+    //~^ ERROR ambiguous associated type\n+    //~| HELP use fully-qualified syntax\n+    // FIXME: for some reason, the error is shown twice with rustdoc but only once with rustc\n+    //~| ERROR ambiguous associated type\n+    //~| HELP use fully-qualified syntax\n+}"}, {"sha": "b963b722f66201708db4650dba2ad194c31b2597", "filename": "src/test/rustdoc-ui/ambiguous-inherent-assoc-ty.stderr", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/b834c4c1bad7521af47f38f44a4048be0a1fe2ee/src%2Ftest%2Frustdoc-ui%2Fambiguous-inherent-assoc-ty.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b834c4c1bad7521af47f38f44a4048be0a1fe2ee/src%2Ftest%2Frustdoc-ui%2Fambiguous-inherent-assoc-ty.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fambiguous-inherent-assoc-ty.stderr?ref=b834c4c1bad7521af47f38f44a4048be0a1fe2ee", "patch": "@@ -0,0 +1,15 @@\n+error[E0223]: ambiguous associated type\n+  --> $DIR/ambiguous-inherent-assoc-ty.rs:11:27\n+   |\n+LL |     pub const AssocConst: Self::AssocTy = 42;\n+   |                           ^^^^^^^^^^^^^ help: use fully-qualified syntax: `<Struct as Trait>::AssocTy`\n+\n+error[E0223]: ambiguous associated type\n+  --> $DIR/ambiguous-inherent-assoc-ty.rs:11:27\n+   |\n+LL |     pub const AssocConst: Self::AssocTy = 42;\n+   |                           ^^^^^^^^^^^^^ help: use fully-qualified syntax: `<Struct as Trait>::AssocTy`\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0223`."}, {"sha": "f91454aa2111e044ee11a99f84582a8b02e267de", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/closure-body-macro-fragment.fixed", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/b834c4c1bad7521af47f38f44a4048be0a1fe2ee/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fclosure-body-macro-fragment.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/b834c4c1bad7521af47f38f44a4048be0a1fe2ee/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fclosure-body-macro-fragment.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fclosure-body-macro-fragment.fixed?ref=b834c4c1bad7521af47f38f44a4048be0a1fe2ee", "patch": "@@ -0,0 +1,25 @@\n+// run-rustfix\n+// edition:2018\n+// check-pass\n+#![warn(rust_2021_compatibility)]\n+\n+macro_rules! m {\n+    (@ $body:expr) => {{\n+        let f = || $body;\n+        //~^ WARNING: drop order\n+        f();\n+    }};\n+    ($body:block) => {{\n+        m!(@ $body);\n+    }};\n+}\n+\n+fn main() {\n+    let a = (1.to_string(), 2.to_string());\n+    m!({\n+        let _ = &a;\n+        //~^ HELP: add a dummy\n+        let x = a.0;\n+        println!(\"{}\", x);\n+    });\n+}"}, {"sha": "5a1026d04331912d4d998eea56b7bacfd7da06a9", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/closure-body-macro-fragment.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/b834c4c1bad7521af47f38f44a4048be0a1fe2ee/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fclosure-body-macro-fragment.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b834c4c1bad7521af47f38f44a4048be0a1fe2ee/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fclosure-body-macro-fragment.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fclosure-body-macro-fragment.rs?ref=b834c4c1bad7521af47f38f44a4048be0a1fe2ee", "patch": "@@ -0,0 +1,24 @@\n+// run-rustfix\n+// edition:2018\n+// check-pass\n+#![warn(rust_2021_compatibility)]\n+\n+macro_rules! m {\n+    (@ $body:expr) => {{\n+        let f = || $body;\n+        //~^ WARNING: drop order\n+        f();\n+    }};\n+    ($body:block) => {{\n+        m!(@ $body);\n+    }};\n+}\n+\n+fn main() {\n+    let a = (1.to_string(), 2.to_string());\n+    m!({\n+        //~^ HELP: add a dummy\n+        let x = a.0;\n+        println!(\"{}\", x);\n+    });\n+}"}, {"sha": "e6e5598f6d2a1beee09d78c72271ab1c511f074b", "filename": "src/test/ui/closures/2229_closure_analysis/migrations/closure-body-macro-fragment.stderr", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/b834c4c1bad7521af47f38f44a4048be0a1fe2ee/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fclosure-body-macro-fragment.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b834c4c1bad7521af47f38f44a4048be0a1fe2ee/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fclosure-body-macro-fragment.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fclosures%2F2229_closure_analysis%2Fmigrations%2Fclosure-body-macro-fragment.stderr?ref=b834c4c1bad7521af47f38f44a4048be0a1fe2ee", "patch": "@@ -0,0 +1,37 @@\n+warning: changes to closure capture in Rust 2021 will affect drop order\n+  --> $DIR/closure-body-macro-fragment.rs:8:17\n+   |\n+LL |           let f = || $body;\n+   |  _________________^\n+LL | |\n+LL | |         f();\n+LL | |     }};\n+   | |     - in Rust 2018, `a` is dropped here, but in Rust 2021, only `a.0` will be dropped here as part of the closure\n+LL | |     ($body:block) => {{\n+LL | |         m!(@ $body);\n+   | |__________________^\n+...\n+LL | /     m!({\n+LL | |\n+LL | |         let x = a.0;\n+   | |                 --- in Rust 2018, this closure captures all of `a`, but in Rust 2021, it will only capture `a.0`\n+LL | |         println!(\"{}\", x);\n+LL | |     });\n+   | |_______- in this macro invocation\n+   |\n+note: the lint level is defined here\n+  --> $DIR/closure-body-macro-fragment.rs:4:9\n+   |\n+LL | #![warn(rust_2021_compatibility)]\n+   |         ^^^^^^^^^^^^^^^^^^^^^^^\n+   = note: `#[warn(rust_2021_incompatible_closure_captures)]` implied by `#[warn(rust_2021_compatibility)]`\n+   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/disjoint-capture-in-closures.html>\n+   = note: this warning originates in the macro `m` (in Nightly builds, run with -Z macro-backtrace for more info)\n+help: add a dummy let to cause `a` to be fully captured\n+   |\n+LL ~     m!({\n+LL +         let _ = &a;\n+   |\n+\n+warning: 1 warning emitted\n+"}, {"sha": "8724fa69825463a33700f615a7d633dce3e27aa7", "filename": "src/test/ui/const-generics/const_trait_fn-issue-88433.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/b834c4c1bad7521af47f38f44a4048be0a1fe2ee/src%2Ftest%2Fui%2Fconst-generics%2Fconst_trait_fn-issue-88433.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b834c4c1bad7521af47f38f44a4048be0a1fe2ee/src%2Ftest%2Fui%2Fconst-generics%2Fconst_trait_fn-issue-88433.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconst-generics%2Fconst_trait_fn-issue-88433.rs?ref=b834c4c1bad7521af47f38f44a4048be0a1fe2ee", "patch": "@@ -0,0 +1,26 @@\n+// build-pass\n+\n+#![feature(const_trait_impl)]\n+\n+trait Func<T> {\n+    type Output;\n+\n+    fn call_once(self, arg: T) -> Self::Output;\n+}\n+\n+\n+struct Closure;\n+\n+impl const Func<&usize> for Closure {\n+    type Output = usize;\n+\n+    fn call_once(self, arg: &usize) -> Self::Output {\n+        *arg\n+    }\n+}\n+\n+enum Bug<T = [(); Closure.call_once(&0) ]> {\n+    V(T),\n+}\n+\n+fn main() {}"}, {"sha": "da931c3edaf6f9de6805e771f2b3b28edd27001f", "filename": "src/test/ui/issues/issue-83190.rs", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/rust-lang/rust/blob/b834c4c1bad7521af47f38f44a4048be0a1fe2ee/src%2Ftest%2Fui%2Fissues%2Fissue-83190.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b834c4c1bad7521af47f38f44a4048be0a1fe2ee/src%2Ftest%2Fui%2Fissues%2Fissue-83190.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-83190.rs?ref=b834c4c1bad7521af47f38f44a4048be0a1fe2ee", "patch": "@@ -0,0 +1,49 @@\n+// check-pass\n+\n+// Regression test for issue #83190, triggering an ICE in borrowck.\n+\n+pub trait Any {}\n+impl<T> Any for T {}\n+\n+pub trait StreamOnce {\n+    type Range;\n+}\n+\n+pub trait Parser<Input>: Sized {\n+    type Output;\n+    type PartialState;\n+    fn map(self) -> Map<Self> {\n+        todo!()\n+    }\n+}\n+\n+pub struct Map<P>(P);\n+impl<I, P: Parser<I, Output = ()>> Parser<I> for Map<P> {\n+    type Output = ();\n+    type PartialState = P::PartialState;\n+}\n+\n+struct TakeWhile1<Input>(Input);\n+impl<I: StreamOnce> Parser<I> for TakeWhile1<I> {\n+    type Output = I::Range;\n+    type PartialState = ();\n+}\n+impl<I> TakeWhile1<I> {\n+    fn new() -> Self {\n+        todo!()\n+    }\n+}\n+\n+impl<I, A: Parser<I>> Parser<I> for (A,) {\n+    type Output = ();\n+    type PartialState = Map<A::Output>;\n+}\n+\n+pub fn metric_stream_parser<'a, I>() -> impl Parser<I, Output = (), PartialState = impl Any + 'a>\n+where\n+    I: StreamOnce<Range = &'a [()]>,\n+{\n+    (TakeWhile1::new(),).map()\n+}\n+\n+fn main() {}"}, {"sha": "60995170a5164397b459ca6c0df73e865863fd50", "filename": "src/test/ui/iterators/into-iter-on-arrays-2018.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/b834c4c1bad7521af47f38f44a4048be0a1fe2ee/src%2Ftest%2Fui%2Fiterators%2Finto-iter-on-arrays-2018.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b834c4c1bad7521af47f38f44a4048be0a1fe2ee/src%2Ftest%2Fui%2Fiterators%2Finto-iter-on-arrays-2018.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fiterators%2Finto-iter-on-arrays-2018.rs?ref=b834c4c1bad7521af47f38f44a4048be0a1fe2ee", "patch": "@@ -19,9 +19,12 @@ fn main() {\n     //~^ WARNING this method call resolves to `<&[T; N] as IntoIterator>::into_iter`\n     //~| WARNING this changes meaning\n \n-    // The `array_into_iter` lint doesn't cover other wrappers that deref to an array.\n     let _: Iter<'_, i32> = Rc::new(array).into_iter();\n+    //~^ WARNING this method call resolves to `<&[T; N] as IntoIterator>::into_iter`\n+    //~| WARNING this changes meaning\n     let _: Iter<'_, i32> = Array(array).into_iter();\n+    //~^ WARNING this method call resolves to `<&[T; N] as IntoIterator>::into_iter`\n+    //~| WARNING this changes meaning\n \n     // But you can always use the trait method explicitly as an array.\n     let _: IntoIter<i32, 10> = IntoIterator::into_iter(array);"}, {"sha": "bc08fdcafa08d3dcc249e7c55e8b365cf848e373", "filename": "src/test/ui/iterators/into-iter-on-arrays-2018.stderr", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/b834c4c1bad7521af47f38f44a4048be0a1fe2ee/src%2Ftest%2Fui%2Fiterators%2Finto-iter-on-arrays-2018.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b834c4c1bad7521af47f38f44a4048be0a1fe2ee/src%2Ftest%2Fui%2Fiterators%2Finto-iter-on-arrays-2018.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fiterators%2Finto-iter-on-arrays-2018.stderr?ref=b834c4c1bad7521af47f38f44a4048be0a1fe2ee", "patch": "@@ -20,21 +20,31 @@ warning: this method call resolves to `<&[T; N] as IntoIterator>::into_iter` (du\n   --> $DIR/into-iter-on-arrays-2018.rs:18:44\n    |\n LL |     let _: Iter<'_, i32> = Box::new(array).into_iter();\n-   |                                            ^^^^^^^^^\n+   |                                            ^^^^^^^^^ help: use `.iter()` instead of `.into_iter()` to avoid ambiguity: `iter`\n    |\n    = warning: this changes meaning in Rust 2021\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/IntoIterator-for-arrays.html>\n-help: use `.iter()` instead of `.into_iter()` to avoid ambiguity\n+\n+warning: this method call resolves to `<&[T; N] as IntoIterator>::into_iter` (due to backwards compatibility), but will resolve to <[T; N] as IntoIterator>::into_iter in Rust 2021.\n+  --> $DIR/into-iter-on-arrays-2018.rs:22:43\n    |\n-LL |     let _: Iter<'_, i32> = Box::new(array).iter();\n-   |                                            ~~~~\n-help: or use `IntoIterator::into_iter(..)` instead of `.into_iter()` to explicitly iterate by value\n+LL |     let _: Iter<'_, i32> = Rc::new(array).into_iter();\n+   |                                           ^^^^^^^^^ help: use `.iter()` instead of `.into_iter()` to avoid ambiguity: `iter`\n+   |\n+   = warning: this changes meaning in Rust 2021\n+   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/IntoIterator-for-arrays.html>\n+\n+warning: this method call resolves to `<&[T; N] as IntoIterator>::into_iter` (due to backwards compatibility), but will resolve to <[T; N] as IntoIterator>::into_iter in Rust 2021.\n+  --> $DIR/into-iter-on-arrays-2018.rs:25:41\n    |\n-LL |     let _: Iter<'_, i32> = IntoIterator::into_iter(Box::new(array));\n-   |                            ++++++++++++++++++++++++               ~\n+LL |     let _: Iter<'_, i32> = Array(array).into_iter();\n+   |                                         ^^^^^^^^^ help: use `.iter()` instead of `.into_iter()` to avoid ambiguity: `iter`\n+   |\n+   = warning: this changes meaning in Rust 2021\n+   = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/IntoIterator-for-arrays.html>\n \n warning: this method call resolves to `<&[T; N] as IntoIterator>::into_iter` (due to backwards compatibility), but will resolve to <[T; N] as IntoIterator>::into_iter in Rust 2021.\n-  --> $DIR/into-iter-on-arrays-2018.rs:29:24\n+  --> $DIR/into-iter-on-arrays-2018.rs:32:24\n    |\n LL |     for _ in [1, 2, 3].into_iter() {}\n    |                        ^^^^^^^^^\n@@ -51,5 +61,5 @@ LL -     for _ in [1, 2, 3].into_iter() {}\n LL +     for _ in [1, 2, 3] {}\n    | \n \n-warning: 3 warnings emitted\n+warning: 5 warnings emitted\n "}, {"sha": "2df1a06df20ab027ad6e9e49be526149e87ec8ff", "filename": "src/test/ui/iterators/into-iter-on-arrays-lint.stderr", "status": "modified", "additions": 8, "deletions": 72, "changes": 80, "blob_url": "https://github.com/rust-lang/rust/blob/b834c4c1bad7521af47f38f44a4048be0a1fe2ee/src%2Ftest%2Fui%2Fiterators%2Finto-iter-on-arrays-lint.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/b834c4c1bad7521af47f38f44a4048be0a1fe2ee/src%2Ftest%2Fui%2Fiterators%2Finto-iter-on-arrays-lint.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fiterators%2Finto-iter-on-arrays-lint.stderr?ref=b834c4c1bad7521af47f38f44a4048be0a1fe2ee", "patch": "@@ -71,137 +71,73 @@ warning: this method call resolves to `<&[T; N] as IntoIterator>::into_iter` (du\n   --> $DIR/into-iter-on-arrays-lint.rs:23:21\n    |\n LL |     Box::new(small).into_iter();\n-   |                     ^^^^^^^^^\n+   |                     ^^^^^^^^^ help: use `.iter()` instead of `.into_iter()` to avoid ambiguity: `iter`\n    |\n    = warning: this changes meaning in Rust 2021\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/IntoIterator-for-arrays.html>\n-help: use `.iter()` instead of `.into_iter()` to avoid ambiguity\n-   |\n-LL |     Box::new(small).iter();\n-   |                     ~~~~\n-help: or use `IntoIterator::into_iter(..)` instead of `.into_iter()` to explicitly iterate by value\n-   |\n-LL |     IntoIterator::into_iter(Box::new(small));\n-   |     ++++++++++++++++++++++++               ~\n \n warning: this method call resolves to `<&[T; N] as IntoIterator>::into_iter` (due to backwards compatibility), but will resolve to <[T; N] as IntoIterator>::into_iter in Rust 2021.\n   --> $DIR/into-iter-on-arrays-lint.rs:26:22\n    |\n LL |     Box::new([1, 2]).into_iter();\n-   |                      ^^^^^^^^^\n+   |                      ^^^^^^^^^ help: use `.iter()` instead of `.into_iter()` to avoid ambiguity: `iter`\n    |\n    = warning: this changes meaning in Rust 2021\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/IntoIterator-for-arrays.html>\n-help: use `.iter()` instead of `.into_iter()` to avoid ambiguity\n-   |\n-LL |     Box::new([1, 2]).iter();\n-   |                      ~~~~\n-help: or use `IntoIterator::into_iter(..)` instead of `.into_iter()` to explicitly iterate by value\n-   |\n-LL |     IntoIterator::into_iter(Box::new([1, 2]));\n-   |     ++++++++++++++++++++++++                ~\n \n warning: this method call resolves to `<&[T; N] as IntoIterator>::into_iter` (due to backwards compatibility), but will resolve to <[T; N] as IntoIterator>::into_iter in Rust 2021.\n   --> $DIR/into-iter-on-arrays-lint.rs:29:19\n    |\n LL |     Box::new(big).into_iter();\n-   |                   ^^^^^^^^^\n+   |                   ^^^^^^^^^ help: use `.iter()` instead of `.into_iter()` to avoid ambiguity: `iter`\n    |\n    = warning: this changes meaning in Rust 2021\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/IntoIterator-for-arrays.html>\n-help: use `.iter()` instead of `.into_iter()` to avoid ambiguity\n-   |\n-LL |     Box::new(big).iter();\n-   |                   ~~~~\n-help: or use `IntoIterator::into_iter(..)` instead of `.into_iter()` to explicitly iterate by value\n-   |\n-LL |     IntoIterator::into_iter(Box::new(big));\n-   |     ++++++++++++++++++++++++             ~\n \n warning: this method call resolves to `<&[T; N] as IntoIterator>::into_iter` (due to backwards compatibility), but will resolve to <[T; N] as IntoIterator>::into_iter in Rust 2021.\n   --> $DIR/into-iter-on-arrays-lint.rs:32:25\n    |\n LL |     Box::new([0u8; 33]).into_iter();\n-   |                         ^^^^^^^^^\n+   |                         ^^^^^^^^^ help: use `.iter()` instead of `.into_iter()` to avoid ambiguity: `iter`\n    |\n    = warning: this changes meaning in Rust 2021\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/IntoIterator-for-arrays.html>\n-help: use `.iter()` instead of `.into_iter()` to avoid ambiguity\n-   |\n-LL |     Box::new([0u8; 33]).iter();\n-   |                         ~~~~\n-help: or use `IntoIterator::into_iter(..)` instead of `.into_iter()` to explicitly iterate by value\n-   |\n-LL |     IntoIterator::into_iter(Box::new([0u8; 33]));\n-   |     ++++++++++++++++++++++++                   ~\n \n warning: this method call resolves to `<&[T; N] as IntoIterator>::into_iter` (due to backwards compatibility), but will resolve to <[T; N] as IntoIterator>::into_iter in Rust 2021.\n   --> $DIR/into-iter-on-arrays-lint.rs:36:31\n    |\n LL |     Box::new(Box::new(small)).into_iter();\n-   |                               ^^^^^^^^^\n+   |                               ^^^^^^^^^ help: use `.iter()` instead of `.into_iter()` to avoid ambiguity: `iter`\n    |\n    = warning: this changes meaning in Rust 2021\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/IntoIterator-for-arrays.html>\n-help: use `.iter()` instead of `.into_iter()` to avoid ambiguity\n-   |\n-LL |     Box::new(Box::new(small)).iter();\n-   |                               ~~~~\n-help: or use `IntoIterator::into_iter(..)` instead of `.into_iter()` to explicitly iterate by value\n-   |\n-LL |     IntoIterator::into_iter(Box::new(Box::new(small)));\n-   |     ++++++++++++++++++++++++                         ~\n \n warning: this method call resolves to `<&[T; N] as IntoIterator>::into_iter` (due to backwards compatibility), but will resolve to <[T; N] as IntoIterator>::into_iter in Rust 2021.\n   --> $DIR/into-iter-on-arrays-lint.rs:39:32\n    |\n LL |     Box::new(Box::new([1, 2])).into_iter();\n-   |                                ^^^^^^^^^\n+   |                                ^^^^^^^^^ help: use `.iter()` instead of `.into_iter()` to avoid ambiguity: `iter`\n    |\n    = warning: this changes meaning in Rust 2021\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/IntoIterator-for-arrays.html>\n-help: use `.iter()` instead of `.into_iter()` to avoid ambiguity\n-   |\n-LL |     Box::new(Box::new([1, 2])).iter();\n-   |                                ~~~~\n-help: or use `IntoIterator::into_iter(..)` instead of `.into_iter()` to explicitly iterate by value\n-   |\n-LL |     IntoIterator::into_iter(Box::new(Box::new([1, 2])));\n-   |     ++++++++++++++++++++++++                          ~\n \n warning: this method call resolves to `<&[T; N] as IntoIterator>::into_iter` (due to backwards compatibility), but will resolve to <[T; N] as IntoIterator>::into_iter in Rust 2021.\n   --> $DIR/into-iter-on-arrays-lint.rs:42:29\n    |\n LL |     Box::new(Box::new(big)).into_iter();\n-   |                             ^^^^^^^^^\n+   |                             ^^^^^^^^^ help: use `.iter()` instead of `.into_iter()` to avoid ambiguity: `iter`\n    |\n    = warning: this changes meaning in Rust 2021\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/IntoIterator-for-arrays.html>\n-help: use `.iter()` instead of `.into_iter()` to avoid ambiguity\n-   |\n-LL |     Box::new(Box::new(big)).iter();\n-   |                             ~~~~\n-help: or use `IntoIterator::into_iter(..)` instead of `.into_iter()` to explicitly iterate by value\n-   |\n-LL |     IntoIterator::into_iter(Box::new(Box::new(big)));\n-   |     ++++++++++++++++++++++++                       ~\n \n warning: this method call resolves to `<&[T; N] as IntoIterator>::into_iter` (due to backwards compatibility), but will resolve to <[T; N] as IntoIterator>::into_iter in Rust 2021.\n   --> $DIR/into-iter-on-arrays-lint.rs:45:35\n    |\n LL |     Box::new(Box::new([0u8; 33])).into_iter();\n-   |                                   ^^^^^^^^^\n+   |                                   ^^^^^^^^^ help: use `.iter()` instead of `.into_iter()` to avoid ambiguity: `iter`\n    |\n    = warning: this changes meaning in Rust 2021\n    = note: for more information, see <https://doc.rust-lang.org/nightly/edition-guide/rust-2021/IntoIterator-for-arrays.html>\n-help: use `.iter()` instead of `.into_iter()` to avoid ambiguity\n-   |\n-LL |     Box::new(Box::new([0u8; 33])).iter();\n-   |                                   ~~~~\n-help: or use `IntoIterator::into_iter(..)` instead of `.into_iter()` to explicitly iterate by value\n-   |\n-LL |     IntoIterator::into_iter(Box::new(Box::new([0u8; 33])));\n-   |     ++++++++++++++++++++++++                             ~\n \n warning: 12 warnings emitted\n "}]}