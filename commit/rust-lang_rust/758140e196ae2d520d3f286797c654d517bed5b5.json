{"sha": "758140e196ae2d520d3f286797c654d517bed5b5", "node_id": "C_kwDOAAsO6NoAKDc1ODE0MGUxOTZhZTJkNTIwZDNmMjg2Nzk3YzY1NGQ1MTdiZWQ1YjU", "commit": {"author": {"name": "Rejyr", "email": "jerrylwang123@gmail.com", "date": "2022-11-13T14:46:31Z"}, "committer": {"name": "Rejyr", "email": "jerrylwang123@gmail.com", "date": "2023-01-09T23:56:59Z"}, "message": "migrate: rest of `builtin.rs` without `builtin_asm_labels`", "tree": {"sha": "401a5ee6e4d4524cf64ba72e1d6ddc0e9ad746d1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/401a5ee6e4d4524cf64ba72e1d6ddc0e9ad746d1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/758140e196ae2d520d3f286797c654d517bed5b5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/758140e196ae2d520d3f286797c654d517bed5b5", "html_url": "https://github.com/rust-lang/rust/commit/758140e196ae2d520d3f286797c654d517bed5b5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/758140e196ae2d520d3f286797c654d517bed5b5/comments", "author": {"login": "Rejyr", "id": 88239847, "node_id": "MDQ6VXNlcjg4MjM5ODQ3", "avatar_url": "https://avatars.githubusercontent.com/u/88239847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Rejyr", "html_url": "https://github.com/Rejyr", "followers_url": "https://api.github.com/users/Rejyr/followers", "following_url": "https://api.github.com/users/Rejyr/following{/other_user}", "gists_url": "https://api.github.com/users/Rejyr/gists{/gist_id}", "starred_url": "https://api.github.com/users/Rejyr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Rejyr/subscriptions", "organizations_url": "https://api.github.com/users/Rejyr/orgs", "repos_url": "https://api.github.com/users/Rejyr/repos", "events_url": "https://api.github.com/users/Rejyr/events{/privacy}", "received_events_url": "https://api.github.com/users/Rejyr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "Rejyr", "id": 88239847, "node_id": "MDQ6VXNlcjg4MjM5ODQ3", "avatar_url": "https://avatars.githubusercontent.com/u/88239847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Rejyr", "html_url": "https://github.com/Rejyr", "followers_url": "https://api.github.com/users/Rejyr/followers", "following_url": "https://api.github.com/users/Rejyr/following{/other_user}", "gists_url": "https://api.github.com/users/Rejyr/gists{/gist_id}", "starred_url": "https://api.github.com/users/Rejyr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Rejyr/subscriptions", "organizations_url": "https://api.github.com/users/Rejyr/orgs", "repos_url": "https://api.github.com/users/Rejyr/repos", "events_url": "https://api.github.com/users/Rejyr/events{/privacy}", "received_events_url": "https://api.github.com/users/Rejyr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "587d49766b711fab79015adecb101138fffa8acc", "url": "https://api.github.com/repos/rust-lang/rust/commits/587d49766b711fab79015adecb101138fffa8acc", "html_url": "https://github.com/rust-lang/rust/commit/587d49766b711fab79015adecb101138fffa8acc"}], "stats": {"total": 548, "additions": 363, "deletions": 185}, "files": [{"sha": "3fa52ff0eb31edb324debb8c054fc882b5d5e1f2", "filename": "compiler/rustc_error_messages/locales/en-US/lint.ftl", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/758140e196ae2d520d3f286797c654d517bed5b5/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Flint.ftl", "raw_url": "https://github.com/rust-lang/rust/raw/758140e196ae2d520d3f286797c654d517bed5b5/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Flint.ftl", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_error_messages%2Flocales%2Fen-US%2Flint.ftl?ref=758140e196ae2d520d3f286797c654d517bed5b5", "patch": "@@ -370,6 +370,8 @@ lint_builtin_anonymous_params = anonymous parameters are deprecated and will be\n     .suggestion = try naming the parameter or explicitly ignoring it\n \n lint_builtin_deprecated_attr_link = use of deprecated attribute `{$name}`: {$reason}. See {$link}\n+    .msg_suggestion = {$msg}\n+    .default_suggestion = remove this attribute\n lint_builtin_deprecated_attr_used = use of deprecated attribute `{$name}`: no longer used.\n lint_builtin_deprecated_attr_default_suggestion = remove this attribute\n \n@@ -430,10 +432,16 @@ lint_builtin_incomplete_features = the feature `{$name}` is incomplete and may n\n     .note = see issue #{$n} <https://github.com/rust-lang/rust/issues/{$n}> for more information\n     .help = consider using `min_{$name}` instead, which is more stable and complete\n \n-lint_builtin_clashing_extern_same_name = `{$this_fi}` redeclared with a different signature\n+lint_builtin_unpermitted_type_init_zeroed = the type `{$ty}` does not permit zero-initialization\n+lint_builtin_unpermitted_type_init_unint = the type `{$ty}` does not permit being left uninitialized\n+\n+lint_builtin_unpermitted_type_init_label = this code causes undefined behavior when executed\n+lint_builtin_unpermitted_type_init_label_suggestion = help: use `MaybeUninit<T>` instead, and only call `assume_init` after initialization is done\n+\n+lint_builtin_clashing_extern_same_name = `{$this}` redeclared with a different signature\n     .previous_decl_label = `{$orig}` previously declared here\n     .mismatch_label = this signature doesn't match the previous declaration\n-lint_builtin_clashing_extern_diff_name = `{$this_fi}` redeclares `{$orig}` with a different signature\n+lint_builtin_clashing_extern_diff_name = `{$this}` redeclares `{$orig}` with a different signature\n     .previous_decl_label = `{$orig}` previously declared here\n     .mismatch_label = this signature doesn't match the previous declaration\n "}, {"sha": "2bdff0d5a09c7ff8af6c58a4da507db0722d540d", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 120, "deletions": 175, "changes": 295, "blob_url": "https://github.com/rust-lang/rust/blob/758140e196ae2d520d3f286797c654d517bed5b5/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/758140e196ae2d520d3f286797c654d517bed5b5/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=758140e196ae2d520d3f286797c654d517bed5b5", "patch": "@@ -1,3 +1,5 @@\n+// #![deny(rustc::untranslatable_diagnostic)]\n+// #![deny(rustc::diagnostic_outside_of_impl)]\n //! Lints in the Rust compiler.\n //!\n //! This contains lints which can feasibly be implemented as their own\n@@ -23,16 +25,21 @@\n use crate::{\n     errors::BuiltinEllpisisInclusiveRangePatterns,\n     lints::{\n-        BuiltinAnonymousParams, BuiltinBoxPointers, BuiltinConstNoMangle,\n-        BuiltinDeprecatedAttrUsed, BuiltinDerefNullptr, BuiltinEllipsisInclusiveRangePatternsLint,\n-        BuiltinExplicitOutlives, BuiltinExplicitOutlivesSuggestion, BuiltinIncompleteFeatures,\n+        BuiltinAnonymousParams, BuiltinBoxPointers, BuiltinClashingExtern,\n+        BuiltinClashingExternSub, BuiltinConstNoMangle, BuiltinDeprecatedAttrLink,\n+        BuiltinDeprecatedAttrLinkSuggestion, BuiltinDeprecatedAttrUsed, BuiltinDerefNullptr,\n+        BuiltinEllipsisInclusiveRangePatternsLint, BuiltinExplicitOutlives,\n+        BuiltinExplicitOutlivesSuggestion, BuiltinIncompleteFeatures,\n         BuiltinIncompleteFeaturesHelp, BuiltinIncompleteFeaturesNote, BuiltinKeywordIdents,\n         BuiltinMissingCopyImpl, BuiltinMissingDebugImpl, BuiltinMissingDoc,\n         BuiltinMutablesTransmutes, BuiltinNoMangleGeneric, BuiltinNonShorthandFieldPatterns,\n-        BuiltinSpecialModuleNameUsed, BuiltinTrivialBounds, BuiltinUnexpectedCliConfigName,\n-        BuiltinUnexpectedCliConfigValue, BuiltinUnnameableTestItems, BuiltinUnreachablePub,\n-        BuiltinUnsafe, BuiltinUnstableFeatures, BuiltinUnusedDocComment,\n-        BuiltinUnusedDocCommentSub, BuiltinWhileTrue,\n+        BuiltinSpecialModuleNameUsed, BuiltinTrivialBounds, BuiltinTypeAliasGenericBounds,\n+        BuiltinTypeAliasGenericBoundsSuggestion, BuiltinTypeAliasWhereClause,\n+        BuiltinUnexpectedCliConfigName, BuiltinUnexpectedCliConfigValue,\n+        BuiltinUngatedAsyncFnTrackCaller, BuiltinUnnameableTestItems, BuiltinUnpermittedTypeInit,\n+        BuiltinUnpermittedTypeInitSub, BuiltinUnreachablePub, BuiltinUnsafe,\n+        BuiltinUnstableFeatures, BuiltinUnusedDocComment, BuiltinUnusedDocCommentSub,\n+        BuiltinWhileTrue, SuggestChangingAssocTypes,\n     },\n     types::{transparent_newtype_field, CItemKind},\n     EarlyContext, EarlyLintPass, LateContext, LateLintPass, LintContext,\n@@ -45,9 +52,7 @@ use rustc_ast::{self as ast, *};\n use rustc_ast_pretty::pprust::{self, expr_to_string};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::stack::ensure_sufficient_stack;\n-use rustc_errors::{\n-    fluent, Applicability, DecorateLint, DelayDm, Diagnostic, DiagnosticStyledString, MultiSpan,\n-};\n+use rustc_errors::{fluent, Applicability, DecorateLint, MultiSpan};\n use rustc_feature::{deprecated_attributes, AttributeGate, BuiltinAttribute, GateIssue, Stability};\n use rustc_hir as hir;\n use rustc_hir::def::{DefKind, Res};\n@@ -923,24 +928,18 @@ impl EarlyLintPass for DeprecatedAttr {\n                     _,\n                 ) = gate\n                 {\n-                    // FIXME(davidtwco) translatable deprecated attr\n-                    cx.struct_span_lint(\n+                    let suggestion = match suggestion {\n+                        Some(msg) => {\n+                            BuiltinDeprecatedAttrLinkSuggestion::Msg { suggestion: attr.span, msg }\n+                        }\n+                        None => {\n+                            BuiltinDeprecatedAttrLinkSuggestion::Default { suggestion: attr.span }\n+                        }\n+                    };\n+                    cx.emit_spanned_lint(\n                         DEPRECATED,\n                         attr.span,\n-                        fluent::lint_builtin_deprecated_attr_link,\n-                        |lint| {\n-                            lint.set_arg(\"name\", name)\n-                                .set_arg(\"reason\", reason)\n-                                .set_arg(\"link\", link)\n-                                .span_suggestion_short(\n-                                    attr.span,\n-                                    suggestion.map(|s| s.into()).unwrap_or(\n-                                        fluent::lint_builtin_deprecated_attr_default_suggestion,\n-                                    ),\n-                                    \"\",\n-                                    Applicability::MachineApplicable,\n-                                )\n-                        },\n+                        BuiltinDeprecatedAttrLink { name, reason, link, suggestion },\n                     );\n                 }\n                 return;\n@@ -1305,20 +1304,10 @@ impl<'tcx> LateLintPass<'tcx> for UngatedAsyncFnTrackCaller {\n             // Now, check if the function has the `#[track_caller]` attribute\n             && let Some(attr) = attrs.iter().find(|attr| attr.has_name(sym::track_caller))\n             {\n-                cx.struct_span_lint(\n-                    UNGATED_ASYNC_FN_TRACK_CALLER,\n-                    attr.span,\n-                    fluent::lint_ungated_async_fn_track_caller,\n-                    |lint| {\n-                        lint.span_label(span, fluent::label);\n-                        rustc_session::parse::add_feature_diagnostics(\n-                            lint,\n-                            &cx.tcx.sess.parse_sess,\n-                            sym::closure_track_caller,\n-                        );\n-                        lint\n-                    },\n-                );\n+                cx.emit_spanned_lint(UNGATED_ASYNC_FN_TRACK_CALLER, attr.span, BuiltinUngatedAsyncFnTrackCaller {\n+                    label: span,\n+                    parse_sess: &cx.tcx.sess.parse_sess,\n+                });\n             }\n     }\n }\n@@ -1447,7 +1436,7 @@ declare_lint_pass!(\n );\n \n impl TypeAliasBounds {\n-    fn is_type_variable_assoc(qpath: &hir::QPath<'_>) -> bool {\n+    pub(crate) fn is_type_variable_assoc(qpath: &hir::QPath<'_>) -> bool {\n         match *qpath {\n             hir::QPath::TypeRelative(ref ty, _) => {\n                 // If this is a type variable, we found a `T::Assoc`.\n@@ -1461,29 +1450,6 @@ impl TypeAliasBounds {\n             hir::QPath::Resolved(..) | hir::QPath::LangItem(..) => false,\n         }\n     }\n-\n-    fn suggest_changing_assoc_types(ty: &hir::Ty<'_>, err: &mut Diagnostic) {\n-        // Access to associates types should use `<T as Bound>::Assoc`, which does not need a\n-        // bound.  Let's see if this type does that.\n-\n-        // We use a HIR visitor to walk the type.\n-        use rustc_hir::intravisit::{self, Visitor};\n-        struct WalkAssocTypes<'a> {\n-            err: &'a mut Diagnostic,\n-        }\n-        impl Visitor<'_> for WalkAssocTypes<'_> {\n-            fn visit_qpath(&mut self, qpath: &hir::QPath<'_>, id: hir::HirId, span: Span) {\n-                if TypeAliasBounds::is_type_variable_assoc(qpath) {\n-                    self.err.span_help(span, fluent::lint_builtin_type_alias_bounds_help);\n-                }\n-                intravisit::walk_qpath(self, qpath, id)\n-            }\n-        }\n-\n-        // Let's go for a walk!\n-        let mut visitor = WalkAssocTypes { err };\n-        visitor.visit_ty(ty);\n-    }\n }\n \n impl<'tcx> LateLintPass<'tcx> for TypeAliasBounds {\n@@ -1517,35 +1483,31 @@ impl<'tcx> LateLintPass<'tcx> for TypeAliasBounds {\n \n         let mut suggested_changing_assoc_types = false;\n         if !where_spans.is_empty() {\n-            cx.lint(TYPE_ALIAS_BOUNDS, fluent::lint_builtin_type_alias_where_clause, |lint| {\n-                lint.set_span(where_spans);\n-                lint.span_suggestion(\n-                    type_alias_generics.where_clause_span,\n-                    fluent::suggestion,\n-                    \"\",\n-                    Applicability::MachineApplicable,\n-                );\n-                if !suggested_changing_assoc_types {\n-                    TypeAliasBounds::suggest_changing_assoc_types(ty, lint);\n-                    suggested_changing_assoc_types = true;\n-                }\n-                lint\n+            let sub = (!suggested_changing_assoc_types).then(|| {\n+                suggested_changing_assoc_types = true;\n+                SuggestChangingAssocTypes { ty }\n             });\n+            cx.emit_spanned_lint(\n+                TYPE_ALIAS_BOUNDS,\n+                where_spans,\n+                BuiltinTypeAliasWhereClause {\n+                    suggestion: type_alias_generics.where_clause_span,\n+                    sub,\n+                },\n+            );\n         }\n \n         if !inline_spans.is_empty() {\n-            cx.lint(TYPE_ALIAS_BOUNDS, fluent::lint_builtin_type_alias_generic_bounds, |lint| {\n-                lint.set_span(inline_spans);\n-                lint.multipart_suggestion(\n-                    fluent::suggestion,\n-                    inline_sugg,\n-                    Applicability::MachineApplicable,\n-                );\n-                if !suggested_changing_assoc_types {\n-                    TypeAliasBounds::suggest_changing_assoc_types(ty, lint);\n-                }\n-                lint\n+            let suggestion = BuiltinTypeAliasGenericBoundsSuggestion { suggestions: inline_sugg };\n+            let sub = (!suggested_changing_assoc_types).then(|| {\n+                suggested_changing_assoc_types = true;\n+                SuggestChangingAssocTypes { ty }\n             });\n+            cx.emit_spanned_lint(\n+                TYPE_ALIAS_BOUNDS,\n+                inline_spans,\n+                BuiltinTypeAliasGenericBounds { suggestion, sub },\n+            );\n         }\n     }\n }\n@@ -2376,6 +2338,36 @@ declare_lint! {\n \n declare_lint_pass!(InvalidValue => [INVALID_VALUE]);\n \n+/// Information about why a type cannot be initialized this way.\n+pub struct InitError {\n+    pub(crate) message: String,\n+    /// Spans from struct fields and similar that can be obtained from just the type.\n+    pub(crate) span: Option<Span>,\n+    /// Used to report a trace through adts.\n+    pub(crate) nested: Option<Box<InitError>>,\n+}\n+impl InitError {\n+    fn spanned(self, span: Span) -> InitError {\n+        Self { span: Some(span), ..self }\n+    }\n+\n+    fn nested(self, nested: impl Into<Option<InitError>>) -> InitError {\n+        assert!(self.nested.is_none());\n+        Self { nested: nested.into().map(Box::new), ..self }\n+    }\n+}\n+\n+impl<'a> From<&'a str> for InitError {\n+    fn from(s: &'a str) -> Self {\n+        s.to_owned().into()\n+    }\n+}\n+impl From<String> for InitError {\n+    fn from(message: String) -> Self {\n+        Self { message, span: None, nested: None }\n+    }\n+}\n+\n impl<'tcx> LateLintPass<'tcx> for InvalidValue {\n     fn check_expr(&mut self, cx: &LateContext<'tcx>, expr: &hir::Expr<'_>) {\n         #[derive(Debug, Copy, Clone, PartialEq)]\n@@ -2384,36 +2376,6 @@ impl<'tcx> LateLintPass<'tcx> for InvalidValue {\n             Uninit,\n         }\n \n-        /// Information about why a type cannot be initialized this way.\n-        struct InitError {\n-            message: String,\n-            /// Spans from struct fields and similar that can be obtained from just the type.\n-            span: Option<Span>,\n-            /// Used to report a trace through adts.\n-            nested: Option<Box<InitError>>,\n-        }\n-        impl InitError {\n-            fn spanned(self, span: Span) -> InitError {\n-                Self { span: Some(span), ..self }\n-            }\n-\n-            fn nested(self, nested: impl Into<Option<InitError>>) -> InitError {\n-                assert!(self.nested.is_none());\n-                Self { nested: nested.into().map(Box::new), ..self }\n-            }\n-        }\n-\n-        impl<'a> From<&'a str> for InitError {\n-            fn from(s: &'a str) -> Self {\n-                s.to_owned().into()\n-            }\n-        }\n-        impl From<String> for InitError {\n-            fn from(message: String) -> Self {\n-                Self { message, span: None, nested: None }\n-            }\n-        }\n-\n         /// Test if this constant is all-0.\n         fn is_zero(expr: &hir::Expr<'_>) -> bool {\n             use hir::ExprKind::*;\n@@ -2637,46 +2599,16 @@ impl<'tcx> LateLintPass<'tcx> for InvalidValue {\n             // using zeroed or uninitialized memory.\n             // We are extremely conservative with what we warn about.\n             let conjured_ty = cx.typeck_results().expr_ty(expr);\n-            if let Some(mut err) = with_no_trimmed_paths!(ty_find_init_error(cx, conjured_ty, init))\n-            {\n-                // FIXME(davidtwco): make translatable\n-                cx.struct_span_lint(\n+            if let Some(err) = with_no_trimmed_paths!(ty_find_init_error(cx, conjured_ty, init)) {\n+                let msg = match init {\n+                    InitKind::Zeroed => fluent::lint_builtin_unpermitted_type_init_zeroed,\n+                    InitKind::Uninit => fluent::lint_builtin_unpermitted_type_init_unint,\n+                };\n+                let sub = BuiltinUnpermittedTypeInitSub { err };\n+                cx.emit_spanned_lint(\n                     INVALID_VALUE,\n                     expr.span,\n-                    DelayDm(|| {\n-                        format!(\n-                            \"the type `{}` does not permit {}\",\n-                            conjured_ty,\n-                            match init {\n-                                InitKind::Zeroed => \"zero-initialization\",\n-                                InitKind::Uninit => \"being left uninitialized\",\n-                            },\n-                        )\n-                    }),\n-                    |lint| {\n-                        lint.span_label(\n-                            expr.span,\n-                            \"this code causes undefined behavior when executed\",\n-                        );\n-                        lint.span_label(\n-                            expr.span,\n-                            \"help: use `MaybeUninit<T>` instead, \\\n-                            and only call `assume_init` after initialization is done\",\n-                        );\n-                        loop {\n-                            if let Some(span) = err.span {\n-                                lint.span_note(span, &err.message);\n-                            } else {\n-                                lint.note(&err.message);\n-                            }\n-                            if let Some(e) = err.nested {\n-                                err = *e;\n-                            } else {\n-                                break;\n-                            }\n-                        }\n-                        lint\n-                    },\n+                    BuiltinUnpermittedTypeInit { msg, ty: conjured_ty, label: expr.span, sub },\n                 );\n             }\n         }\n@@ -3022,31 +2954,44 @@ impl<'tcx> LateLintPass<'tcx> for ClashingExternDeclarations {\n                             SymbolName::Normal(_) => fi.span,\n                             SymbolName::Link(_, annot_span) => fi.span.to(annot_span),\n                         };\n-                    // Finally, emit the diagnostic.\n \n-                    let msg = if orig.get_name() == this_fi.ident.name {\n-                        fluent::lint_builtin_clashing_extern_same_name\n+                    // Finally, emit the diagnostic.\n+                    let mut expected_str = DiagnosticStyledString::new();\n+                    expected_str.push(existing_decl_ty.fn_sig(tcx).to_string(), false);\n+                    let mut found_str = DiagnosticStyledString::new();\n+                    found_str.push(this_decl_ty.fn_sig(tcx).to_string(), true);\n+\n+                    let this = this_fi.ident.name;\n+                    let orig = orig.get_name();\n+                    let previous_decl_label = get_relevant_span(orig_fi);\n+                    let mismatch_label = get_relevant_span(this_fi);\n+                    let sub = BuiltinClashingExternSub {\n+                        tcx,\n+                        expected: existing_decl_ty,\n+                        found: this_decl_ty,\n+                    };\n+                    let decorator = if orig == this {\n+                        BuiltinClashingExtern::SameName {\n+                            this,\n+                            orig,\n+                            previous_decl_label,\n+                            mismatch_label,\n+                            sub,\n+                        }\n                     } else {\n-                        fluent::lint_builtin_clashing_extern_diff_name\n+                        BuiltinClashingExtern::DiffName {\n+                            this,\n+                            orig,\n+                            previous_decl_label,\n+                            mismatch_label,\n+                            sub,\n+                        }\n                     };\n-                    tcx.struct_span_lint_hir(\n+                    tcx.emit_spanned_lint(\n                         CLASHING_EXTERN_DECLARATIONS,\n                         this_fi.hir_id(),\n                         get_relevant_span(this_fi),\n-                        msg,\n-                        |lint| {\n-                            let mut expected_str = DiagnosticStyledString::new();\n-                            expected_str.push(existing_decl_ty.fn_sig(tcx).to_string(), false);\n-                            let mut found_str = DiagnosticStyledString::new();\n-                            found_str.push(this_decl_ty.fn_sig(tcx).to_string(), true);\n-\n-                            lint.set_arg(\"this_fi\", this_fi.ident.name)\n-                                .set_arg(\"orig\", orig.get_name())\n-                                .span_label(get_relevant_span(orig_fi), fluent::previous_decl_label)\n-                                .span_label(get_relevant_span(this_fi), fluent::mismatch_label)\n-                                // FIXME(davidtwco): translatable expected/found\n-                                .note_expected_found(&\"\", expected_str, &\"\", found_str)\n-                        },\n+                        decorator,\n                     );\n                 }\n             }"}, {"sha": "ee6fa5300f4a31117ead534746540f38e53dadb8", "filename": "compiler/rustc_lint/src/lints.rs", "status": "modified", "additions": 233, "deletions": 8, "changes": 241, "blob_url": "https://github.com/rust-lang/rust/blob/758140e196ae2d520d3f286797c654d517bed5b5/compiler%2Frustc_lint%2Fsrc%2Flints.rs", "raw_url": "https://github.com/rust-lang/rust/raw/758140e196ae2d520d3f286797c654d517bed5b5/compiler%2Frustc_lint%2Fsrc%2Flints.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flints.rs?ref=758140e196ae2d520d3f286797c654d517bed5b5", "patch": "@@ -1,14 +1,18 @@\n use std::num::NonZeroU32;\n \n use rustc_errors::{\n-    fluent, AddToDiagnostic, Applicability, DecorateLint, DiagnosticMessage, SuggestionStyle,\n+    fluent, AddToDiagnostic, Applicability, DecorateLint, DiagnosticMessage,\n+    DiagnosticStyledString, SuggestionStyle,\n };\n use rustc_hir::def_id::DefId;\n use rustc_macros::{LintDiagnostic, Subdiagnostic};\n use rustc_middle::ty::{Predicate, Ty, TyCtxt};\n-use rustc_span::{edition::Edition, symbol::Ident, Span, Symbol};\n+use rustc_session::parse::ParseSess;\n+use rustc_span::{edition::Edition, sym, symbol::Ident, Span, Symbol};\n \n-use crate::{errors::OverruledAttributeSub, LateContext};\n+use crate::{\n+    builtin::InitError, builtin::TypeAliasBounds, errors::OverruledAttributeSub, LateContext,\n+};\n \n // array_into_iter.rs\n #[derive(LintDiagnostic)]\n@@ -142,7 +146,31 @@ pub struct BuiltinAnonymousParams<'a> {\n     pub ty_snip: &'a str,\n }\n \n-// FIXME: add lint::builtin_deprecated_attr_link\n+// FIXME(davidtwco) translatable deprecated attr\n+#[derive(LintDiagnostic)]\n+#[diag(lint_builtin_deprecated_attr_link)]\n+pub struct BuiltinDeprecatedAttrLink<'a> {\n+    pub name: Symbol,\n+    pub reason: &'a str,\n+    pub link: &'a str,\n+    #[subdiagnostic]\n+    pub suggestion: BuiltinDeprecatedAttrLinkSuggestion<'a>,\n+}\n+\n+#[derive(Subdiagnostic)]\n+pub enum BuiltinDeprecatedAttrLinkSuggestion<'a> {\n+    #[suggestion(msg_suggestion, code = \"\", applicability = \"machine-applicable\")]\n+    Msg {\n+        #[primary_span]\n+        suggestion: Span,\n+        msg: &'a str,\n+    },\n+    #[suggestion(default_suggestion, code = \"\", applicability = \"machine-applicable\")]\n+    Default {\n+        #[primary_span]\n+        suggestion: Span,\n+    },\n+}\n \n #[derive(LintDiagnostic)]\n #[diag(lint_builtin_deprecated_attr_used)]\n@@ -199,6 +227,31 @@ pub struct BuiltinMutablesTransmutes;\n #[diag(lint_builtin_unstable_features)]\n pub struct BuiltinUnstableFeatures;\n \n+// lint_ungated_async_fn_track_caller\n+pub struct BuiltinUngatedAsyncFnTrackCaller<'a> {\n+    pub label: Span,\n+    pub parse_sess: &'a ParseSess,\n+}\n+\n+impl<'a> DecorateLint<'a, ()> for BuiltinUngatedAsyncFnTrackCaller<'_> {\n+    fn decorate_lint<'b>(\n+        self,\n+        diag: &'b mut rustc_errors::DiagnosticBuilder<'a, ()>,\n+    ) -> &'b mut rustc_errors::DiagnosticBuilder<'a, ()> {\n+        diag.span_label(self.label, fluent::label);\n+        rustc_session::parse::add_feature_diagnostics(\n+            diag,\n+            &self.parse_sess,\n+            sym::closure_track_caller,\n+        );\n+        diag\n+    }\n+\n+    fn msg(&self) -> DiagnosticMessage {\n+        fluent::lint_ungated_async_fn_track_caller\n+    }\n+}\n+\n #[derive(LintDiagnostic)]\n #[diag(lint_builtin_unreachable_pub)]\n pub struct BuiltinUnreachablePub<'a> {\n@@ -209,9 +262,83 @@ pub struct BuiltinUnreachablePub<'a> {\n     pub help: Option<()>,\n }\n \n-// FIXME: migrate builtin_type_alias_where_clause\n+pub struct SuggestChangingAssocTypes<'a, 'b> {\n+    pub ty: &'a rustc_hir::Ty<'b>,\n+}\n+\n+impl AddToDiagnostic for SuggestChangingAssocTypes<'_, '_> {\n+    fn add_to_diagnostic_with<F>(self, diag: &mut rustc_errors::Diagnostic, _: F)\n+    where\n+        F: Fn(\n+            &mut rustc_errors::Diagnostic,\n+            rustc_errors::SubdiagnosticMessage,\n+        ) -> rustc_errors::SubdiagnosticMessage,\n+    {\n+        // Access to associates types should use `<T as Bound>::Assoc`, which does not need a\n+        // bound.  Let's see if this type does that.\n+\n+        // We use a HIR visitor to walk the type.\n+        use rustc_hir::intravisit::{self, Visitor};\n+        struct WalkAssocTypes<'a> {\n+            err: &'a mut rustc_errors::Diagnostic,\n+        }\n+        impl Visitor<'_> for WalkAssocTypes<'_> {\n+            fn visit_qpath(\n+                &mut self,\n+                qpath: &rustc_hir::QPath<'_>,\n+                id: rustc_hir::HirId,\n+                span: Span,\n+            ) {\n+                if TypeAliasBounds::is_type_variable_assoc(qpath) {\n+                    self.err.span_help(span, fluent::lint_builtin_type_alias_bounds_help);\n+                }\n+                intravisit::walk_qpath(self, qpath, id)\n+            }\n+        }\n+\n+        // Let's go for a walk!\n+        let mut visitor = WalkAssocTypes { err: diag };\n+        visitor.visit_ty(self.ty);\n+    }\n+}\n \n-// FIXME: migrate builtin_type_alias_generic_bounds\n+#[derive(LintDiagnostic)]\n+#[diag(lint_builtin_type_alias_where_clause)]\n+pub struct BuiltinTypeAliasWhereClause<'a, 'b> {\n+    #[suggestion(code = \"\", applicability = \"machine-applicable\")]\n+    pub suggestion: Span,\n+    #[subdiagnostic]\n+    pub sub: Option<SuggestChangingAssocTypes<'a, 'b>>,\n+}\n+\n+#[derive(LintDiagnostic)]\n+#[diag(lint_builtin_type_alias_generic_bounds)]\n+pub struct BuiltinTypeAliasGenericBounds<'a, 'b> {\n+    #[subdiagnostic]\n+    pub suggestion: BuiltinTypeAliasGenericBoundsSuggestion,\n+    #[subdiagnostic]\n+    pub sub: Option<SuggestChangingAssocTypes<'a, 'b>>,\n+}\n+\n+pub struct BuiltinTypeAliasGenericBoundsSuggestion {\n+    pub suggestions: Vec<(Span, String)>,\n+}\n+\n+impl AddToDiagnostic for BuiltinTypeAliasGenericBoundsSuggestion {\n+    fn add_to_diagnostic_with<F>(self, diag: &mut rustc_errors::Diagnostic, _: F)\n+    where\n+        F: Fn(\n+            &mut rustc_errors::Diagnostic,\n+            rustc_errors::SubdiagnosticMessage,\n+        ) -> rustc_errors::SubdiagnosticMessage,\n+    {\n+        diag.multipart_suggestion(\n+            fluent::suggestion,\n+            self.suggestions,\n+            Applicability::MachineApplicable,\n+        );\n+    }\n+}\n \n #[derive(LintDiagnostic)]\n #[diag(lint_builtin_trivial_bounds)]\n@@ -285,9 +412,107 @@ pub struct BuiltinIncompleteFeaturesNote {\n     pub n: NonZeroU32,\n }\n \n-// FIXME: migrate \"the type `{}` does not permit {}\"\n+pub struct BuiltinUnpermittedTypeInit<'a> {\n+    pub msg: DiagnosticMessage,\n+    pub ty: Ty<'a>,\n+    pub label: Span,\n+    pub sub: BuiltinUnpermittedTypeInitSub,\n+}\n+\n+impl<'a> DecorateLint<'a, ()> for BuiltinUnpermittedTypeInit<'_> {\n+    fn decorate_lint<'b>(\n+        self,\n+        diag: &'b mut rustc_errors::DiagnosticBuilder<'a, ()>,\n+    ) -> &'b mut rustc_errors::DiagnosticBuilder<'a, ()> {\n+        diag.set_arg(\"ty\", self.ty);\n+        diag.span_label(self.label, fluent::lint_builtin_unpermitted_type_init_label);\n+        diag.span_label(self.label, fluent::lint_builtin_unpermitted_type_init_label_suggestion);\n+        self.sub.add_to_diagnostic(diag);\n+        diag\n+    }\n+\n+    fn msg(&self) -> rustc_errors::DiagnosticMessage {\n+        self.msg.clone()\n+    }\n+}\n+\n+// FIXME(davidtwco): make translatable\n+pub struct BuiltinUnpermittedTypeInitSub {\n+    pub err: InitError,\n+}\n \n-// FIXME: fluent::lint::builtin_clashing_extern_{same,diff}_name\n+impl AddToDiagnostic for BuiltinUnpermittedTypeInitSub {\n+    fn add_to_diagnostic_with<F>(self, diag: &mut rustc_errors::Diagnostic, _: F)\n+    where\n+        F: Fn(\n+            &mut rustc_errors::Diagnostic,\n+            rustc_errors::SubdiagnosticMessage,\n+        ) -> rustc_errors::SubdiagnosticMessage,\n+    {\n+        let mut err = self.err;\n+        loop {\n+            if let Some(span) = err.span {\n+                diag.span_note(span, err.message);\n+            } else {\n+                diag.note(err.message);\n+            }\n+            if let Some(e) = err.nested {\n+                err = *e;\n+            } else {\n+                break;\n+            }\n+        }\n+    }\n+}\n+\n+#[derive(LintDiagnostic)]\n+pub enum BuiltinClashingExtern<'a> {\n+    #[diag(lint_builtin_clashing_extern_same_name)]\n+    SameName {\n+        this: Symbol,\n+        orig: Symbol,\n+        #[label(previous_decl_label)]\n+        previous_decl_label: Span,\n+        #[label(mismatch_label)]\n+        mismatch_label: Span,\n+        #[subdiagnostic]\n+        sub: BuiltinClashingExternSub<'a>,\n+    },\n+    #[diag(lint_builtin_clashing_extern_diff_name)]\n+    DiffName {\n+        this: Symbol,\n+        orig: Symbol,\n+        #[label(previous_decl_label)]\n+        previous_decl_label: Span,\n+        #[label(mismatch_label)]\n+        mismatch_label: Span,\n+        #[subdiagnostic]\n+        sub: BuiltinClashingExternSub<'a>,\n+    },\n+}\n+\n+// FIXME(davidtwco): translatable expected/found\n+pub struct BuiltinClashingExternSub<'a> {\n+    pub tcx: TyCtxt<'a>,\n+    pub expected: Ty<'a>,\n+    pub found: Ty<'a>,\n+}\n+\n+impl AddToDiagnostic for BuiltinClashingExternSub<'_> {\n+    fn add_to_diagnostic_with<F>(self, diag: &mut rustc_errors::Diagnostic, _: F)\n+    where\n+        F: Fn(\n+            &mut rustc_errors::Diagnostic,\n+            rustc_errors::SubdiagnosticMessage,\n+        ) -> rustc_errors::SubdiagnosticMessage,\n+    {\n+        let mut expected_str = DiagnosticStyledString::new();\n+        expected_str.push(self.expected.fn_sig(self.tcx).to_string(), false);\n+        let mut found_str = DiagnosticStyledString::new();\n+        found_str.push(self.found.fn_sig(self.tcx).to_string(), true);\n+        diag.note_expected_found(&\"\", expected_str, &\"\", found_str);\n+    }\n+}\n \n #[derive(LintDiagnostic)]\n #[diag(lint_builtin_deref_nullptr)]"}]}