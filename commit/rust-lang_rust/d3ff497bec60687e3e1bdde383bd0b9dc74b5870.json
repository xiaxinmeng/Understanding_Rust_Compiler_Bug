{"sha": "d3ff497bec60687e3e1bdde383bd0b9dc74b5870", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQzZmY0OTdiZWM2MDY4N2UzZTFiZGRlMzgzYmQwYjlkYzc0YjU4NzA=", "commit": {"author": {"name": "Charles Lew", "email": "crlf0710@gmail.com", "date": "2021-06-20T09:43:25Z"}, "committer": {"name": "Charles Lew", "email": "crlf0710@gmail.com", "date": "2021-06-28T11:39:48Z"}, "message": "Update other codegens to use tcx managed vtable allocations.", "tree": {"sha": "f12696156730de79bc337241e6a2dc4e9cfad0e3", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f12696156730de79bc337241e6a2dc4e9cfad0e3"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d3ff497bec60687e3e1bdde383bd0b9dc74b5870", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d3ff497bec60687e3e1bdde383bd0b9dc74b5870", "html_url": "https://github.com/rust-lang/rust/commit/d3ff497bec60687e3e1bdde383bd0b9dc74b5870", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d3ff497bec60687e3e1bdde383bd0b9dc74b5870/comments", "author": {"login": "crlf0710", "id": 451806, "node_id": "MDQ6VXNlcjQ1MTgwNg==", "avatar_url": "https://avatars.githubusercontent.com/u/451806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/crlf0710", "html_url": "https://github.com/crlf0710", "followers_url": "https://api.github.com/users/crlf0710/followers", "following_url": "https://api.github.com/users/crlf0710/following{/other_user}", "gists_url": "https://api.github.com/users/crlf0710/gists{/gist_id}", "starred_url": "https://api.github.com/users/crlf0710/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/crlf0710/subscriptions", "organizations_url": "https://api.github.com/users/crlf0710/orgs", "repos_url": "https://api.github.com/users/crlf0710/repos", "events_url": "https://api.github.com/users/crlf0710/events{/privacy}", "received_events_url": "https://api.github.com/users/crlf0710/received_events", "type": "User", "site_admin": false}, "committer": {"login": "crlf0710", "id": 451806, "node_id": "MDQ6VXNlcjQ1MTgwNg==", "avatar_url": "https://avatars.githubusercontent.com/u/451806?v=4", "gravatar_id": "", "url": "https://api.github.com/users/crlf0710", "html_url": "https://github.com/crlf0710", "followers_url": "https://api.github.com/users/crlf0710/followers", "following_url": "https://api.github.com/users/crlf0710/following{/other_user}", "gists_url": "https://api.github.com/users/crlf0710/gists{/gist_id}", "starred_url": "https://api.github.com/users/crlf0710/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/crlf0710/subscriptions", "organizations_url": "https://api.github.com/users/crlf0710/orgs", "repos_url": "https://api.github.com/users/crlf0710/repos", "events_url": "https://api.github.com/users/crlf0710/events{/privacy}", "received_events_url": "https://api.github.com/users/crlf0710/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "654e3345e535913653a2bad4204c31f9ccedb3c4", "url": "https://api.github.com/repos/rust-lang/rust/commits/654e3345e535913653a2bad4204c31f9ccedb3c4", "html_url": "https://github.com/rust-lang/rust/commit/654e3345e535913653a2bad4204c31f9ccedb3c4"}], "stats": {"total": 392, "additions": 143, "deletions": 249}, "files": [{"sha": "a8a0bb52a246e728041afe7ba14593b76db0cafb", "filename": "compiler/rustc_codegen_cranelift/src/common.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3ff497bec60687e3e1bdde383bd0b9dc74b5870/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3ff497bec60687e3e1bdde383bd0b9dc74b5870/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fcommon.rs?ref=d3ff497bec60687e3e1bdde383bd0b9dc74b5870", "patch": "@@ -233,7 +233,7 @@ pub(crate) struct FunctionCx<'m, 'clif, 'tcx: 'm> {\n     pub(crate) module: &'m mut dyn Module,\n     pub(crate) tcx: TyCtxt<'tcx>,\n     pub(crate) pointer_type: Type, // Cached from module\n-    pub(crate) vtables: FxHashMap<(Ty<'tcx>, Option<ty::PolyExistentialTraitRef<'tcx>>), DataId>,\n+    pub(crate) vtables: FxHashMap<(Ty<'tcx>, Option<ty::PolyExistentialTraitRef<'tcx>>), Pointer>,\n     pub(crate) constants_cx: ConstantCx,\n \n     pub(crate) instance: Instance<'tcx>,"}, {"sha": "a87b3703949f9aebc5ec69e6e3a2bbb4cfd9b3fe", "filename": "compiler/rustc_codegen_cranelift/src/constant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3ff497bec60687e3e1bdde383bd0b9dc74b5870/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3ff497bec60687e3e1bdde383bd0b9dc74b5870/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fconstant.rs?ref=d3ff497bec60687e3e1bdde383bd0b9dc74b5870", "patch": "@@ -249,7 +249,7 @@ pub(crate) fn codegen_const_value<'tcx>(\n     }\n }\n \n-fn pointer_for_allocation<'tcx>(\n+pub(crate) fn pointer_for_allocation<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n     alloc: &'tcx Allocation,\n ) -> crate::pointer::Pointer {"}, {"sha": "b817bf4aff7718c89e424c14c6039457287ff251", "filename": "compiler/rustc_codegen_cranelift/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3ff497bec60687e3e1bdde383bd0b9dc74b5870/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3ff497bec60687e3e1bdde383bd0b9dc74b5870/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Flib.rs?ref=d3ff497bec60687e3e1bdde383bd0b9dc74b5870", "patch": "@@ -98,7 +98,7 @@ mod prelude {\n     pub(crate) use cranelift_codegen::isa::{self, CallConv};\n     pub(crate) use cranelift_codegen::Context;\n     pub(crate) use cranelift_frontend::{FunctionBuilder, FunctionBuilderContext, Variable};\n-    pub(crate) use cranelift_module::{self, DataContext, DataId, FuncId, Linkage, Module};\n+    pub(crate) use cranelift_module::{self, DataContext, FuncId, Linkage, Module};\n \n     pub(crate) use crate::abi::*;\n     pub(crate) use crate::base::{codegen_operand, codegen_place};"}, {"sha": "b9d379c6117c91d846e3620649c2e40f951daf9f", "filename": "compiler/rustc_codegen_cranelift/src/unsize.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d3ff497bec60687e3e1bdde383bd0b9dc74b5870/compiler%2Frustc_codegen_cranelift%2Fsrc%2Funsize.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3ff497bec60687e3e1bdde383bd0b9dc74b5870/compiler%2Frustc_codegen_cranelift%2Fsrc%2Funsize.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Funsize.rs?ref=d3ff497bec60687e3e1bdde383bd0b9dc74b5870", "patch": "@@ -31,9 +31,7 @@ pub(crate) fn unsized_info<'tcx>(\n             // change to the vtable.\n             old_info.expect(\"unsized_info: missing old info for trait upcast\")\n         }\n-        (_, &ty::Dynamic(ref data, ..)) => {\n-            crate::vtable::get_vtable(fx, fx.layout_of(source), data.principal())\n-        }\n+        (_, &ty::Dynamic(ref data, ..)) => crate::vtable::get_vtable(fx, source, data.principal()),\n         _ => bug!(\"unsized_info: invalid unsizing {:?} -> {:?}\", source, target),\n     }\n }"}, {"sha": "12f7092d935a33732d858ddad42e2eff87f93b66", "filename": "compiler/rustc_codegen_cranelift/src/vtable.rs", "status": "modified", "additions": 10, "deletions": 96, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/d3ff497bec60687e3e1bdde383bd0b9dc74b5870/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3ff497bec60687e3e1bdde383bd0b9dc74b5870/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_cranelift%2Fsrc%2Fvtable.rs?ref=d3ff497bec60687e3e1bdde383bd0b9dc74b5870", "patch": "@@ -4,7 +4,7 @@\n // FIXME dedup this logic between miri, cg_llvm and cg_clif\n \n use crate::prelude::*;\n-use ty::VtblEntry;\n+use super::constant::pointer_for_allocation;\n \n fn vtable_memflags() -> MemFlags {\n     let mut flags = MemFlags::trusted(); // A vtable access is always aligned and will never trap.\n@@ -66,105 +66,19 @@ pub(crate) fn get_ptr_and_method_ref<'tcx>(\n \n pub(crate) fn get_vtable<'tcx>(\n     fx: &mut FunctionCx<'_, '_, 'tcx>,\n-    layout: TyAndLayout<'tcx>,\n+    ty: Ty<'tcx>,\n     trait_ref: Option<ty::PolyExistentialTraitRef<'tcx>>,\n ) -> Value {\n-    let data_id = if let Some(data_id) = fx.vtables.get(&(layout.ty, trait_ref)) {\n-        *data_id\n+    let vtable_ptr = if let Some(vtable_ptr) = fx.vtables.get(&(ty, trait_ref)) {\n+        *vtable_ptr\n     } else {\n-        let data_id = build_vtable(fx, layout, trait_ref);\n-        fx.vtables.insert((layout.ty, trait_ref), data_id);\n-        data_id\n-    };\n-\n-    let local_data_id = fx.module.declare_data_in_func(data_id, &mut fx.bcx.func);\n-    fx.bcx.ins().global_value(fx.pointer_type, local_data_id)\n-}\n-\n-fn build_vtable<'tcx>(\n-    fx: &mut FunctionCx<'_, '_, 'tcx>,\n-    layout: TyAndLayout<'tcx>,\n-    trait_ref: Option<ty::PolyExistentialTraitRef<'tcx>>,\n-) -> DataId {\n-    let tcx = fx.tcx;\n-    let usize_size = fx.layout_of(fx.tcx.types.usize).size.bytes() as usize;\n+        let vtable_alloc_id = fx.tcx.vtable_allocation(ty, trait_ref);\n+        let vtable_allocation = fx.tcx.global_alloc(vtable_alloc_id).unwrap_memory();\n+        let vtable_ptr = pointer_for_allocation(fx, vtable_allocation);\n \n-    let drop_in_place_fn = import_function(\n-        tcx,\n-        fx.module,\n-        Instance::resolve_drop_in_place(tcx, layout.ty).polymorphize(fx.tcx),\n-    );\n-\n-    let vtable_entries = if let Some(trait_ref) = trait_ref {\n-        tcx.vtable_entries(trait_ref.with_self_ty(tcx, layout.ty))\n-    } else {\n-        ty::COMMON_VTABLE_ENTRIES\n+        fx.vtables.insert((ty, trait_ref), vtable_ptr);\n+        vtable_ptr\n     };\n \n-    let mut data_ctx = DataContext::new();\n-    let mut data = ::std::iter::repeat(0u8)\n-        .take(vtable_entries.len() * usize_size)\n-        .collect::<Vec<u8>>()\n-        .into_boxed_slice();\n-\n-    for (idx, entry) in vtable_entries.iter().enumerate() {\n-        match entry {\n-            VtblEntry::MetadataSize => {\n-                write_usize(fx.tcx, &mut data, idx, layout.size.bytes());\n-            }\n-            VtblEntry::MetadataAlign => {\n-                write_usize(fx.tcx, &mut data, idx, layout.align.abi.bytes());\n-            }\n-            VtblEntry::MetadataDropInPlace | VtblEntry::Vacant | VtblEntry::Method(_, _) => {}\n-        }\n-    }\n-    data_ctx.define(data);\n-\n-    for (idx, entry) in vtable_entries.iter().enumerate() {\n-        match entry {\n-            VtblEntry::MetadataDropInPlace => {\n-                let func_ref = fx.module.declare_func_in_data(drop_in_place_fn, &mut data_ctx);\n-                data_ctx.write_function_addr((idx * usize_size) as u32, func_ref);\n-            }\n-            VtblEntry::Method(def_id, substs) => {\n-                let func_id = import_function(\n-                    tcx,\n-                    fx.module,\n-                    Instance::resolve_for_vtable(tcx, ParamEnv::reveal_all(), *def_id, substs)\n-                        .unwrap()\n-                        .polymorphize(fx.tcx),\n-                );\n-                let func_ref = fx.module.declare_func_in_data(func_id, &mut data_ctx);\n-                data_ctx.write_function_addr((idx * usize_size) as u32, func_ref);\n-            }\n-            VtblEntry::MetadataSize | VtblEntry::MetadataAlign | VtblEntry::Vacant => {}\n-        }\n-    }\n-\n-    data_ctx.set_align(fx.tcx.data_layout.pointer_align.pref.bytes());\n-\n-    let data_id = fx.module.declare_anonymous_data(false, false).unwrap();\n-\n-    fx.module.define_data(data_id, &data_ctx).unwrap();\n-\n-    data_id\n-}\n-\n-fn write_usize(tcx: TyCtxt<'_>, buf: &mut [u8], idx: usize, num: u64) {\n-    let pointer_size =\n-        tcx.layout_of(ParamEnv::reveal_all().and(tcx.types.usize)).unwrap().size.bytes() as usize;\n-    let target = &mut buf[idx * pointer_size..(idx + 1) * pointer_size];\n-\n-    match tcx.data_layout.endian {\n-        rustc_target::abi::Endian::Little => match pointer_size {\n-            4 => target.copy_from_slice(&(num as u32).to_le_bytes()),\n-            8 => target.copy_from_slice(&(num as u64).to_le_bytes()),\n-            _ => todo!(\"pointer size {} is not yet supported\", pointer_size),\n-        },\n-        rustc_target::abi::Endian::Big => match pointer_size {\n-            4 => target.copy_from_slice(&(num as u32).to_be_bytes()),\n-            8 => target.copy_from_slice(&(num as u64).to_be_bytes()),\n-            _ => todo!(\"pointer size {} is not yet supported\", pointer_size),\n-        },\n-    }\n+    vtable_ptr.get_addr(fx)\n }"}, {"sha": "df5ad8ecc271dc01fd49198ac882fc98427249c5", "filename": "compiler/rustc_codegen_llvm/src/common.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d3ff497bec60687e3e1bdde383bd0b9dc74b5870/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3ff497bec60687e3e1bdde383bd0b9dc74b5870/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_llvm%2Fsrc%2Fcommon.rs?ref=d3ff497bec60687e3e1bdde383bd0b9dc74b5870", "patch": "@@ -282,6 +282,10 @@ impl ConstMethods<'tcx> for CodegenCx<'ll, 'tcx> {\n         }\n     }\n \n+    fn const_data_from_alloc(&self, alloc: &Allocation) -> Self::Value {\n+        const_alloc_to_llvm(self, alloc)\n+    }\n+\n     fn from_const_alloc(\n         &self,\n         layout: TyAndLayout<'tcx>,"}, {"sha": "63245a94c8e3d8fb9388d85e948e8347c53865a5", "filename": "compiler/rustc_codegen_ssa/src/meth.rs", "status": "modified", "additions": 4, "deletions": 39, "changes": 43, "blob_url": "https://github.com/rust-lang/rust/blob/d3ff497bec60687e3e1bdde383bd0b9dc74b5870/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3ff497bec60687e3e1bdde383bd0b9dc74b5870/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fmeth.rs?ref=d3ff497bec60687e3e1bdde383bd0b9dc74b5870", "patch": "@@ -1,6 +1,6 @@\n use crate::traits::*;\n \n-use rustc_middle::ty::{self, Instance, Ty, VtblEntry, COMMON_VTABLE_ENTRIES};\n+use rustc_middle::ty::{self, Ty};\n use rustc_target::abi::call::FnAbi;\n \n #[derive(Copy, Clone, Debug)]\n@@ -70,48 +70,13 @@ pub fn get_vtable<'tcx, Cx: CodegenMethods<'tcx>>(\n         return val;\n     }\n \n-    // Not in the cache; build it.\n-    let nullptr = cx.const_null(cx.type_i8p_ext(cx.data_layout().instruction_address_space));\n-\n-    let vtable_entries = if let Some(trait_ref) = trait_ref {\n-        tcx.vtable_entries(trait_ref.with_self_ty(tcx, ty))\n-    } else {\n-        COMMON_VTABLE_ENTRIES\n-    };\n-\n-    let layout = cx.layout_of(ty);\n-    // /////////////////////////////////////////////////////////////////////////////////////////////\n-    // If you touch this code, be sure to also make the corresponding changes to\n-    // `get_vtable` in `rust_mir/interpret/traits.rs`.\n-    // /////////////////////////////////////////////////////////////////////////////////////////////\n-    let components: Vec<_> = vtable_entries\n-        .iter()\n-        .map(|entry| match entry {\n-            VtblEntry::MetadataDropInPlace => {\n-                cx.get_fn_addr(Instance::resolve_drop_in_place(cx.tcx(), ty))\n-            }\n-            VtblEntry::MetadataSize => cx.const_usize(layout.size.bytes()),\n-            VtblEntry::MetadataAlign => cx.const_usize(layout.align.abi.bytes()),\n-            VtblEntry::Vacant => nullptr,\n-            VtblEntry::Method(def_id, substs) => cx.get_fn_addr(\n-                ty::Instance::resolve_for_vtable(\n-                    cx.tcx(),\n-                    ty::ParamEnv::reveal_all(),\n-                    *def_id,\n-                    substs,\n-                )\n-                .unwrap()\n-                .polymorphize(cx.tcx()),\n-            ),\n-        })\n-        .collect();\n-\n-    let vtable_const = cx.const_struct(&components, false);\n+    let vtable_alloc_id = tcx.vtable_allocation(ty, trait_ref);\n+    let vtable_allocation = tcx.global_alloc(vtable_alloc_id).unwrap_memory();\n+    let vtable_const = cx.const_data_from_alloc(vtable_allocation);\n     let align = cx.data_layout().pointer_align.abi;\n     let vtable = cx.static_addr_of(vtable_const, align, Some(\"vtable\"));\n \n     cx.create_vtable_metadata(ty, vtable);\n-\n     cx.vtables().borrow_mut().insert((ty, trait_ref), vtable);\n     vtable\n }"}, {"sha": "20f6618712327870212d734e8ca15062b03aacbf", "filename": "compiler/rustc_codegen_ssa/src/traits/consts.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3ff497bec60687e3e1bdde383bd0b9dc74b5870/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3ff497bec60687e3e1bdde383bd0b9dc74b5870/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Ftraits%2Fconsts.rs?ref=d3ff497bec60687e3e1bdde383bd0b9dc74b5870", "patch": "@@ -26,6 +26,8 @@ pub trait ConstMethods<'tcx>: BackendTypes {\n     fn const_to_opt_uint(&self, v: Self::Value) -> Option<u64>;\n     fn const_to_opt_u128(&self, v: Self::Value, sign_ext: bool) -> Option<u128>;\n \n+    fn const_data_from_alloc(&self, alloc: &Allocation) -> Self::Value;\n+\n     fn scalar_to_backend(&self, cv: Scalar, layout: &abi::Scalar, llty: Self::Type) -> Self::Value;\n     fn from_const_alloc(\n         &self,"}, {"sha": "a5a03ce0a4b684d7dbdeaca5ea855e6b491c4d2d", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d3ff497bec60687e3e1bdde383bd0b9dc74b5870/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3ff497bec60687e3e1bdde383bd0b9dc74b5870/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=d3ff497bec60687e3e1bdde383bd0b9dc74b5870", "patch": "@@ -11,7 +11,7 @@ use crate::middle;\n use crate::middle::cstore::{CrateStoreDyn, EncodedMetadata};\n use crate::middle::resolve_lifetime::{self, LifetimeScopeForPath, ObjectLifetimeDefault};\n use crate::middle::stability;\n-use crate::mir::interpret::{self, Allocation, ConstValue, Scalar};\n+use crate::mir::interpret::{self, AllocId, Allocation, ConstValue, Scalar};\n use crate::mir::{Body, Field, Local, Place, PlaceElem, ProjectionKind, Promoted};\n use crate::thir::Thir;\n use crate::traits;\n@@ -1045,6 +1045,9 @@ pub struct GlobalCtxt<'tcx> {\n     output_filenames: Arc<OutputFilenames>,\n \n     pub main_def: Option<MainDefinition>,\n+\n+    pub(super) vtables_cache:\n+        Lock<FxHashMap<(Ty<'tcx>, Option<ty::PolyExistentialTraitRef<'tcx>>), AllocId>>,\n }\n \n impl<'tcx> TyCtxt<'tcx> {\n@@ -1202,6 +1205,7 @@ impl<'tcx> TyCtxt<'tcx> {\n             alloc_map: Lock::new(interpret::AllocMap::new()),\n             output_filenames: Arc::new(output_filenames),\n             main_def: resolutions.main_def,\n+            vtables_cache: Default::default(),\n         }\n     }\n "}, {"sha": "859a940a62526f6a0c63c3873f688a869fc4bd4e", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 2, "deletions": 16, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/d3ff497bec60687e3e1bdde383bd0b9dc74b5870/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3ff497bec60687e3e1bdde383bd0b9dc74b5870/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=d3ff497bec60687e3e1bdde383bd0b9dc74b5870", "patch": "@@ -18,6 +18,7 @@ pub use adt::*;\n pub use assoc::*;\n pub use closure::*;\n pub use generics::*;\n+pub use vtable::*;\n \n use crate::hir::exports::ExportMap;\n use crate::ich::StableHashingContext;\n@@ -94,6 +95,7 @@ pub mod relate;\n pub mod subst;\n pub mod trait_def;\n pub mod util;\n+pub mod vtable;\n pub mod walk;\n \n mod adt;\n@@ -2009,19 +2011,3 @@ impl<'tcx> fmt::Debug for SymbolName<'tcx> {\n         fmt::Display::fmt(&self.name, fmt)\n     }\n }\n-\n-#[derive(Clone, Copy, Debug, PartialEq, HashStable)]\n-pub enum VtblEntry<'tcx> {\n-    MetadataDropInPlace,\n-    MetadataSize,\n-    MetadataAlign,\n-    Vacant,\n-    Method(DefId, SubstsRef<'tcx>),\n-}\n-\n-pub const COMMON_VTABLE_ENTRIES: &[VtblEntry<'_>] =\n-    &[VtblEntry::MetadataDropInPlace, VtblEntry::MetadataSize, VtblEntry::MetadataAlign];\n-\n-pub const COMMON_VTABLE_ENTRIES_DROPINPLACE: usize = 0;\n-pub const COMMON_VTABLE_ENTRIES_SIZE: usize = 1;\n-pub const COMMON_VTABLE_ENTRIES_ALIGN: usize = 2;"}, {"sha": "3a35d8c88a47890089bd681f5c00a6f151ba8529", "filename": "compiler/rustc_middle/src/ty/vtable.rs", "status": "added", "additions": 106, "deletions": 0, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/d3ff497bec60687e3e1bdde383bd0b9dc74b5870/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3ff497bec60687e3e1bdde383bd0b9dc74b5870/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fvtable.rs?ref=d3ff497bec60687e3e1bdde383bd0b9dc74b5870", "patch": "@@ -0,0 +1,106 @@\n+use std::convert::TryFrom;\n+\n+use crate::mir::interpret::{alloc_range, AllocId, Allocation, Pointer, Scalar};\n+use crate::ty::fold::TypeFoldable;\n+use crate::ty::{self, DefId, SubstsRef, Ty, TyCtxt};\n+use rustc_ast::Mutability;\n+\n+#[derive(Clone, Copy, Debug, PartialEq, HashStable)]\n+pub enum VtblEntry<'tcx> {\n+    MetadataDropInPlace,\n+    MetadataSize,\n+    MetadataAlign,\n+    Vacant,\n+    Method(DefId, SubstsRef<'tcx>),\n+}\n+\n+pub const COMMON_VTABLE_ENTRIES: &[VtblEntry<'_>] =\n+    &[VtblEntry::MetadataDropInPlace, VtblEntry::MetadataSize, VtblEntry::MetadataAlign];\n+\n+pub const COMMON_VTABLE_ENTRIES_DROPINPLACE: usize = 0;\n+pub const COMMON_VTABLE_ENTRIES_SIZE: usize = 1;\n+pub const COMMON_VTABLE_ENTRIES_ALIGN: usize = 2;\n+\n+impl<'tcx> TyCtxt<'tcx> {\n+    /// Retrieves an allocation that represents the contents of a vtable.\n+    /// There's a cache within `TyCtxt` so it will be deduplicated.\n+    pub fn vtable_allocation(\n+        self,\n+        ty: Ty<'tcx>,\n+        poly_trait_ref: Option<ty::PolyExistentialTraitRef<'tcx>>,\n+    ) -> AllocId {\n+        let tcx = self;\n+        let vtables_cache = tcx.vtables_cache.lock();\n+        if let Some(alloc_id) = vtables_cache.get(&(ty, poly_trait_ref)).cloned() {\n+            return alloc_id;\n+        }\n+        drop(vtables_cache);\n+\n+        // See https://github.com/rust-lang/rust/pull/86475#discussion_r655162674\n+        assert!(\n+            !ty.needs_subst() && !poly_trait_ref.map_or(false, |trait_ref| trait_ref.needs_subst())\n+        );\n+        let param_env = ty::ParamEnv::reveal_all();\n+        let vtable_entries = if let Some(poly_trait_ref) = poly_trait_ref {\n+            let trait_ref = poly_trait_ref.with_self_ty(tcx, ty);\n+            let trait_ref = tcx.erase_regions(trait_ref);\n+\n+            tcx.vtable_entries(trait_ref)\n+        } else {\n+            COMMON_VTABLE_ENTRIES\n+        };\n+\n+        let layout =\n+            tcx.layout_of(param_env.and(ty)).expect(\"failed to build vtable representation\");\n+        assert!(!layout.is_unsized(), \"can't create a vtable for an unsized type\");\n+        let size = layout.size.bytes();\n+        let align = layout.align.abi.bytes();\n+\n+        let ptr_size = tcx.data_layout.pointer_size;\n+        let ptr_align = tcx.data_layout.pointer_align.abi;\n+\n+        let vtable_size = ptr_size * u64::try_from(vtable_entries.len()).unwrap();\n+        let mut vtable = Allocation::uninit(vtable_size, ptr_align);\n+\n+        // No need to do any alignment checks on the memory accesses below, because we know the\n+        // allocation is correctly aligned as we created it above. Also we're only offsetting by\n+        // multiples of `ptr_align`, which means that it will stay aligned to `ptr_align`.\n+\n+        for (idx, entry) in vtable_entries.iter().enumerate() {\n+            let idx: u64 = u64::try_from(idx).unwrap();\n+            let scalar = match entry {\n+                VtblEntry::MetadataDropInPlace => {\n+                    let instance = ty::Instance::resolve_drop_in_place(tcx, ty);\n+                    let fn_alloc_id = tcx.create_fn_alloc(instance);\n+                    let fn_ptr = Pointer::from(fn_alloc_id);\n+                    fn_ptr.into()\n+                }\n+                VtblEntry::MetadataSize => Scalar::from_uint(size, ptr_size).into(),\n+                VtblEntry::MetadataAlign => Scalar::from_uint(align, ptr_size).into(),\n+                VtblEntry::Vacant => continue,\n+                VtblEntry::Method(def_id, substs) => {\n+                    // See https://github.com/rust-lang/rust/pull/86475#discussion_r655162674\n+                    assert!(!substs.needs_subst());\n+\n+                    // Prepare the fn ptr we write into the vtable.\n+                    let instance =\n+                        ty::Instance::resolve_for_vtable(tcx, param_env, *def_id, substs)\n+                            .expect(\"resolution failed during building vtable representation\")\n+                            .polymorphize(tcx);\n+                    let fn_alloc_id = tcx.create_fn_alloc(instance);\n+                    let fn_ptr = Pointer::from(fn_alloc_id);\n+                    fn_ptr.into()\n+                }\n+            };\n+            vtable\n+                .write_scalar(&tcx, alloc_range(ptr_size * idx, ptr_size), scalar)\n+                .expect(\"failed to build vtable representation\");\n+        }\n+\n+        vtable.mutability = Mutability::Not;\n+        let alloc_id = tcx.create_memory_alloc(tcx.intern_const_alloc(vtable));\n+        let mut vtables_cache = self.vtables_cache.lock();\n+        vtables_cache.insert((ty, poly_trait_ref), alloc_id);\n+        alloc_id\n+    }\n+}"}, {"sha": "5332e615bc8eacaec143f53c02343b4f79bb1fe9", "filename": "compiler/rustc_mir/src/interpret/traits.rs", "status": "modified", "additions": 6, "deletions": 91, "changes": 97, "blob_url": "https://github.com/rust-lang/rust/blob/d3ff497bec60687e3e1bdde383bd0b9dc74b5870/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3ff497bec60687e3e1bdde383bd0b9dc74b5870/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Finterpret%2Ftraits.rs?ref=d3ff497bec60687e3e1bdde383bd0b9dc74b5870", "patch": "@@ -1,29 +1,14 @@\n use std::convert::TryFrom;\n \n-use rustc_middle::mir::interpret::{\n-    AllocError, InterpError, InterpResult, Pointer, PointerArithmetic, Scalar,\n-    UndefinedBehaviorInfo, UnsupportedOpInfo,\n-};\n+use rustc_middle::mir::interpret::{InterpResult, Pointer, PointerArithmetic, Scalar};\n use rustc_middle::ty::{\n-    self, Instance, Ty, VtblEntry, COMMON_VTABLE_ENTRIES, COMMON_VTABLE_ENTRIES_ALIGN,\n+    self, Ty, COMMON_VTABLE_ENTRIES, COMMON_VTABLE_ENTRIES_ALIGN,\n     COMMON_VTABLE_ENTRIES_DROPINPLACE, COMMON_VTABLE_ENTRIES_SIZE,\n };\n-use rustc_target::abi::{Align, LayoutOf, Size};\n+use rustc_target::abi::{Align, Size};\n \n-use super::alloc_range;\n use super::util::ensure_monomorphic_enough;\n-use super::{Allocation, FnVal, InterpCx, Machine};\n-\n-fn vtable_alloc_error_to_interp_error<'tcx>(error: AllocError) -> InterpError<'tcx> {\n-    match error {\n-        AllocError::ReadPointerAsBytes => {\n-            InterpError::Unsupported(UnsupportedOpInfo::ReadPointerAsBytes)\n-        }\n-        AllocError::InvalidUninitBytes(_info) => {\n-            InterpError::UndefinedBehavior(UndefinedBehaviorInfo::InvalidUninitBytes(None))\n-        }\n-    }\n-}\n+use super::{FnVal, InterpCx, Machine};\n \n impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n     /// Creates a dynamic vtable for the given type and vtable origin. This is used only for\n@@ -45,79 +30,9 @@ impl<'mir, 'tcx: 'mir, M: Machine<'mir, 'tcx>> InterpCx<'mir, 'tcx, M> {\n         ensure_monomorphic_enough(*self.tcx, ty)?;\n         ensure_monomorphic_enough(*self.tcx, poly_trait_ref)?;\n \n-        if let Some(&vtable) = self.vtables.get(&(ty, poly_trait_ref)) {\n-            // This means we guarantee that there are no duplicate vtables, we will\n-            // always use the same vtable for the same (Type, Trait) combination.\n-            // That's not what happens in rustc, but emulating per-crate deduplication\n-            // does not sound like it actually makes anything any better.\n-            return Ok(vtable);\n-        }\n-\n-        let vtable_entries = if let Some(poly_trait_ref) = poly_trait_ref {\n-            let trait_ref = poly_trait_ref.with_self_ty(*self.tcx, ty);\n-            let trait_ref = self.tcx.erase_regions(trait_ref);\n-\n-            self.tcx.vtable_entries(trait_ref)\n-        } else {\n-            COMMON_VTABLE_ENTRIES\n-        };\n-\n-        let layout = self.layout_of(ty)?;\n-        assert!(!layout.is_unsized(), \"can't create a vtable for an unsized type\");\n-        let size = layout.size.bytes();\n-        let align = layout.align.abi.bytes();\n-\n-        let tcx = *self.tcx;\n-        let ptr_size = self.pointer_size();\n-        let ptr_align = tcx.data_layout.pointer_align.abi;\n-        // /////////////////////////////////////////////////////////////////////////////////////////\n-        // If you touch this code, be sure to also make the corresponding changes to\n-        // `get_vtable` in `rust_codegen_llvm/meth.rs`.\n-        // /////////////////////////////////////////////////////////////////////////////////////////\n-        let vtable_size = ptr_size * u64::try_from(vtable_entries.len()).unwrap();\n-        let mut vtable = Allocation::uninit(vtable_size, ptr_align);\n-\n-        // No need to do any alignment checks on the memory accesses below, because we know the\n-        // allocation is correctly aligned as we created it above. Also we're only offsetting by\n-        // multiples of `ptr_align`, which means that it will stay aligned to `ptr_align`.\n-        let scalars = vtable_entries\n-            .iter()\n-            .map(|entry| -> InterpResult<'tcx, _> {\n-                match entry {\n-                    VtblEntry::MetadataDropInPlace => {\n-                        let instance = Instance::resolve_drop_in_place(tcx, ty);\n-                        let fn_alloc_id = tcx.create_fn_alloc(instance);\n-                        let fn_ptr = Pointer::from(fn_alloc_id);\n-                        Ok(Some(fn_ptr.into()))\n-                    }\n-                    VtblEntry::MetadataSize => Ok(Some(Scalar::from_uint(size, ptr_size).into())),\n-                    VtblEntry::MetadataAlign => Ok(Some(Scalar::from_uint(align, ptr_size).into())),\n-                    VtblEntry::Vacant => Ok(None),\n-                    VtblEntry::Method(def_id, substs) => {\n-                        // Prepare the fn ptr we write into the vtable.\n-                        let instance =\n-                            Instance::resolve_for_vtable(tcx, self.param_env, *def_id, substs)\n-                                .ok_or_else(|| err_inval!(TooGeneric))?;\n-                        let fn_alloc_id = tcx.create_fn_alloc(instance);\n-                        let fn_ptr = Pointer::from(fn_alloc_id);\n-                        Ok(Some(fn_ptr.into()))\n-                    }\n-                }\n-            })\n-            .collect::<Result<Vec<_>, _>>()?;\n-        for (idx, scalar) in scalars.into_iter().enumerate() {\n-            if let Some(scalar) = scalar {\n-                let idx: u64 = u64::try_from(idx).unwrap();\n-                vtable\n-                    .write_scalar(self, alloc_range(ptr_size * idx, ptr_size), scalar)\n-                    .map_err(vtable_alloc_error_to_interp_error)?;\n-            }\n-        }\n-\n-        let vtable_id = tcx.create_memory_alloc(tcx.intern_const_alloc(vtable));\n-        let vtable_ptr = self.memory.global_base_pointer(Pointer::from(vtable_id))?;\n+        let vtable_allocation = self.tcx.vtable_allocation(ty, poly_trait_ref);\n \n-        assert!(self.vtables.insert((ty, poly_trait_ref), vtable_ptr).is_none());\n+        let vtable_ptr = self.memory.global_base_pointer(Pointer::from(vtable_allocation))?;\n \n         Ok(vtable_ptr)\n     }"}]}