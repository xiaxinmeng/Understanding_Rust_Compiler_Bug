{"sha": "680031b0164a94aaeee17a1d8c3027e6e8865a4c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjY4MDAzMWIwMTY0YTk0YWFlZWUxN2ExZDhjMzAyN2U2ZTg4NjVhNGM=", "commit": {"author": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2018-04-29T14:09:56Z"}, "committer": {"name": "Simonas Kazlauskas", "email": "git@kazlauskas.me", "date": "2018-05-17T20:13:08Z"}, "message": "Implement [T]::align_to", "tree": {"sha": "d527dbed79906a163f5949a87debafe8b66ef257", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d527dbed79906a163f5949a87debafe8b66ef257"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/680031b0164a94aaeee17a1d8c3027e6e8865a4c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/680031b0164a94aaeee17a1d8c3027e6e8865a4c", "html_url": "https://github.com/rust-lang/rust/commit/680031b0164a94aaeee17a1d8c3027e6e8865a4c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/680031b0164a94aaeee17a1d8c3027e6e8865a4c/comments", "author": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nagisa", "id": 679122, "node_id": "MDQ6VXNlcjY3OTEyMg==", "avatar_url": "https://avatars.githubusercontent.com/u/679122?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nagisa", "html_url": "https://github.com/nagisa", "followers_url": "https://api.github.com/users/nagisa/followers", "following_url": "https://api.github.com/users/nagisa/following{/other_user}", "gists_url": "https://api.github.com/users/nagisa/gists{/gist_id}", "starred_url": "https://api.github.com/users/nagisa/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nagisa/subscriptions", "organizations_url": "https://api.github.com/users/nagisa/orgs", "repos_url": "https://api.github.com/users/nagisa/repos", "events_url": "https://api.github.com/users/nagisa/events{/privacy}", "received_events_url": "https://api.github.com/users/nagisa/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d45378216b31eab9ee7c7c461ae20bfb29bd20b3", "url": "https://api.github.com/repos/rust-lang/rust/commits/d45378216b31eab9ee7c7c461ae20bfb29bd20b3", "html_url": "https://github.com/rust-lang/rust/commit/d45378216b31eab9ee7c7c461ae20bfb29bd20b3"}], "stats": {"total": 401, "additions": 287, "deletions": 114}, "files": [{"sha": "ffa4a66346c99775df415624a78348ae9a1eaac0", "filename": "src/libcore/slice/mod.rs", "status": "modified", "additions": 162, "deletions": 20, "changes": 182, "blob_url": "https://github.com/rust-lang/rust/blob/680031b0164a94aaeee17a1d8c3027e6e8865a4c/src%2Flibcore%2Fslice%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/680031b0164a94aaeee17a1d8c3027e6e8865a4c/src%2Flibcore%2Fslice%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fslice%2Fmod.rs?ref=680031b0164a94aaeee17a1d8c3027e6e8865a4c", "patch": "@@ -1697,27 +1697,169 @@ impl<T> [T] {\n         }\n     }\n \n-    // #[unstable(feature = \"slice_align_to\", issue = \"44488\")]\n-    // pub fn align_to<U>(&self) -> (&[T], &[U], &[T]) {\n-    //     // First, find at what point do we split between the first and 2nd slice.\n-    //     let x = self.as_ptr();\n-    //     let offset = x.align_offset(::mem::align_of::<U>());\n-    //     if offset > x * ::mem::size_of::<T>() {\n-    //         return (self, [], []);\n-    //     }\n-\n-    // }\n-\n-    // #[unstable(feature = \"slice_align_to\", issue = \"44488\")]\n-    // pub fn align_to_mut<U>(&mut self) -> (&mut [T], &mut [U], &mut [T]) {\n-    // }\n-}}\n+    /// Function to calculate lenghts of the middle and trailing slice for `align_to{,_mut}`.\n+    fn align_to_offsets<U>(&self) -> (usize, usize) {\n+        // What we gonna do about `rest` is figure out what multiple of `U`s we can put in a\n+        // lowest number of `T`s. And how many `T`s we need for each such \"multiple\".\n+        //\n+        // Consider for example T=u8 U=u16. Then we can put 1 U in 2 Ts. Simple. Now, consider\n+        // for example a case where size_of::<T> = 16, size_of::<U> = 24. We can put 2 Us in\n+        // place of every 3 Ts in the `rest` slice. A bit more complicated.\n+        //\n+        // Formula to calculate this is:\n+        //\n+        // Us = lcm(size_of::<T>, size_of::<U>) / size_of::<U>\n+        // Ts = lcm(size_of::<T>, size_of::<U>) / size_of::<T>\n+        //\n+        // Expanded and simplified:\n+        //\n+        // Us = size_of::<T> / gcd(size_of::<T>, size_of::<U>)\n+        // Ts = size_of::<U> / gcd(size_of::<T>, size_of::<U>)\n+        //\n+        // Luckily since all this is constant-evaluated... performance here matters not!\n+        #[inline]\n+        fn gcd(a: usize, b: usize) -> usize {\n+            // iterative stein\u2019s algorithm\n+            // We should still make this `const fn` (and revert to recursive algorithm if we do)\n+            // because relying on llvm to consteval all this is\u2026 well, it makes me\n+            let (ctz_a, mut ctz_b) = unsafe {\n+                if a == 0 { return b; }\n+                if b == 0 { return a; }\n+                (::intrinsics::cttz_nonzero(a), ::intrinsics::cttz_nonzero(b))\n+            };\n+            let k = ctz_a.min(ctz_b);\n+            let mut a = a >> ctz_a;\n+            let mut b = b;\n+            loop {\n+                // remove all factors of 2 from b\n+                b >>= ctz_b;\n+                if a > b {\n+                    ::mem::swap(&mut a, &mut b);\n+                }\n+                b = b - a;\n+                unsafe {\n+                    if b == 0 {\n+                        break;\n+                    }\n+                    ctz_b = ::intrinsics::cttz_nonzero(b);\n+                }\n+            }\n+            return a << k;\n+        }\n+        let gcd: usize = gcd(::mem::size_of::<T>(), ::mem::size_of::<U>());\n+        let ts: usize = ::mem::size_of::<U>() / gcd;\n+        let us: usize = ::mem::size_of::<T>() / gcd;\n \n-#[lang = \"slice\"]\n-#[cfg(not(test))]\n-#[cfg(not(stage0))]\n-impl<T> [T] {\n-    slice_core_methods!();\n+        // Armed with this knowledge, we can find how many `U`s we can fit!\n+        let us_len = self.len() / ts * us;\n+        // And how many `T`s will be in the trailing slice!\n+        let ts_len = self.len() % ts;\n+        return (us_len, ts_len);\n+    }\n+\n+    /// Transmute the slice to a slice of another type, ensuring aligment of the types is\n+    /// maintained.\n+    ///\n+    /// This method splits the slice into three distinct slices: prefix, correctly aligned middle\n+    /// slice of a new type, and the suffix slice. The middle slice will have the greatest length\n+    /// possible for a given type and input slice.\n+    ///\n+    /// This method has no purpose when either input element `T` or output element `U` are\n+    /// zero-sized and will return the original slice without splitting anything.\n+    ///\n+    /// # Unsafety\n+    ///\n+    /// This method is essentially a `transmute` with respect to the elements in the returned\n+    /// middle slice, so all the usual caveats pertaining to `transmute::<T, U>` also apply here.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// # #![feature(slice_align_to)]\n+    /// unsafe {\n+    ///     let bytes: [u8; 7] = [1, 2, 3, 4, 5, 6, 7];\n+    ///     let (prefix, shorts, suffix) = bytes.align_to::<u16>();\n+    ///     // less_efficient_algorithm_for_bytes(prefix);\n+    ///     // more_efficient_algorithm_for_aligned_shorts(shorts);\n+    ///     // less_efficient_algorithm_for_bytes(suffix);\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"slice_align_to\", issue = \"44488\")]\n+    #[cfg(not(stage0))]\n+    pub unsafe fn align_to<U>(&self) -> (&[T], &[U], &[T]) {\n+        // Note that most of this function will be constant-evaluated,\n+        if ::mem::size_of::<U>() == 0 || ::mem::size_of::<T>() == 0 {\n+            // handle ZSTs specially, which is \u2013 don't handle them at all.\n+            return (self, &[], &[]);\n+        }\n+        let ptr = self.as_ptr();\n+        let offset = ::intrinsics::align_offset(ptr, ::mem::align_of::<U>());\n+        if offset > self.len() {\n+            return (self, &[], &[]);\n+        } else {\n+            let (left, rest) = self.split_at(offset);\n+            let (us_len, ts_len) = rest.align_to_offsets::<U>();\n+            return (left,\n+                    from_raw_parts(rest.as_ptr() as *const U, us_len),\n+                    from_raw_parts(rest.as_ptr().offset((rest.len() - ts_len) as isize), ts_len))\n+        }\n+    }\n+\n+    /// Transmute the slice to a slice of another type, ensuring aligment of the types is\n+    /// maintained.\n+    ///\n+    /// This method splits the slice into three distinct slices: prefix, correctly aligned middle\n+    /// slice of a new type, and the suffix slice. The middle slice will have the greatest length\n+    /// possible for a given type and input slice.\n+    ///\n+    /// This method has no purpose when either input element `T` or output element `U` are\n+    /// zero-sized and will return the original slice without splitting anything.\n+    ///\n+    /// # Unsafety\n+    ///\n+    /// This method is essentially a `transmute` with respect to the elements in the returned\n+    /// middle slice, so all the usual caveats pertaining to `transmute::<T, U>` also apply here.\n+    ///\n+    /// # Examples\n+    ///\n+    /// Basic usage:\n+    ///\n+    /// ```\n+    /// # #![feature(slice_align_to)]\n+    /// unsafe {\n+    ///     let mut bytes: [u8; 7] = [1, 2, 3, 4, 5, 6, 7];\n+    ///     let (prefix, shorts, suffix) = bytes.align_to_mut::<u16>();\n+    ///     // less_efficient_algorithm_for_bytes(prefix);\n+    ///     // more_efficient_algorithm_for_aligned_shorts(shorts);\n+    ///     // less_efficient_algorithm_for_bytes(suffix);\n+    /// }\n+    /// ```\n+    #[unstable(feature = \"slice_align_to\", issue = \"44488\")]\n+    #[cfg(not(stage0))]\n+    pub unsafe fn align_to_mut<U>(&mut self) -> (&mut [T], &mut [U], &mut [T]) {\n+        // Note that most of this function will be constant-evaluated,\n+        if ::mem::size_of::<U>() == 0 || ::mem::size_of::<T>() == 0 {\n+            // handle ZSTs specially, which is \u2013 don't handle them at all.\n+            return (self, &mut [], &mut []);\n+        }\n+\n+        // First, find at what point do we split between the first and 2nd slice. Easy with\n+        // ptr.align_offset.\n+        let ptr = self.as_ptr();\n+        let offset = ::intrinsics::align_offset(ptr, ::mem::align_of::<U>());\n+        if offset > self.len() {\n+            return (self, &mut [], &mut []);\n+        } else {\n+            let (left, rest) = self.split_at_mut(offset);\n+            let (us_len, ts_len) = rest.align_to_offsets::<U>();\n+            let mut_ptr = rest.as_mut_ptr();\n+            return (left,\n+                    from_raw_parts_mut(mut_ptr as *mut U, us_len),\n+                    from_raw_parts_mut(mut_ptr.offset((rest.len() - ts_len) as isize), ts_len))\n+        }\n+    }\n }\n \n #[lang = \"slice_u8\"]"}, {"sha": "dbd26b2c7183673a4e1f0739e5c0afca0a73d3df", "filename": "src/libcore/tests/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/680031b0164a94aaeee17a1d8c3027e6e8865a4c/src%2Flibcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/680031b0164a94aaeee17a1d8c3027e6e8865a4c/src%2Flibcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Flib.rs?ref=680031b0164a94aaeee17a1d8c3027e6e8865a4c", "patch": "@@ -41,6 +41,8 @@\n #![feature(try_from)]\n #![feature(try_trait)]\n #![feature(exact_chunks)]\n+#![feature(slice_align_to)]\n+#![feature(align_offset)]\n #![feature(reverse_bits)]\n #![feature(inclusive_range_methods)]\n #![feature(iterator_find_map)]"}, {"sha": "9384cb327981df926a3138757ffc6c4174b5fc36", "filename": "src/libcore/tests/ptr.rs", "status": "modified", "additions": 89, "deletions": 0, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/680031b0164a94aaeee17a1d8c3027e6e8865a4c/src%2Flibcore%2Ftests%2Fptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/680031b0164a94aaeee17a1d8c3027e6e8865a4c/src%2Flibcore%2Ftests%2Fptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fptr.rs?ref=680031b0164a94aaeee17a1d8c3027e6e8865a4c", "patch": "@@ -296,3 +296,92 @@ fn write_unaligned_drop() {\n     }\n     DROPS.with(|d| assert_eq!(*d.borrow(), [0]));\n }\n+\n+#[test]\n+fn align_offset_zst() {\n+    // For pointers of stride = 0, the pointer is already aligned or it cannot be aligned at\n+    // all, because no amount of elements will align the pointer.\n+    let mut p = 1;\n+    while p < 1024 {\n+        assert_eq!((p as *const ()).align_offset(p), 0);\n+        if p != 1 {\n+            assert_eq!(((p + 1) as *const ()).align_offset(p), !0);\n+        }\n+        p = (p + 1).next_power_of_two();\n+    }\n+}\n+\n+#[test]\n+fn align_offset_stride1() {\n+    // For pointers of stride = 1, the pointer can always be aligned. The offset is equal to\n+    // number of bytes.\n+    let mut align = 1;\n+    while align < 1024 {\n+        for ptr in 1..2*align {\n+            let expected = ptr % align;\n+            let offset = if expected == 0 { 0 } else { align - expected };\n+            assert_eq!((ptr as *const u8).align_offset(align), offset,\n+            \"ptr = {}, align = {}, size = 1\", ptr, align);\n+            align = (align + 1).next_power_of_two();\n+        }\n+    }\n+}\n+\n+#[test]\n+fn align_offset_weird_strides() {\n+    #[repr(packed)]\n+    struct A3(u16, u8);\n+    struct A4(u32);\n+    #[repr(packed)]\n+    struct A5(u32, u8);\n+    #[repr(packed)]\n+    struct A6(u32, u16);\n+    #[repr(packed)]\n+    struct A7(u32, u16, u8);\n+    #[repr(packed)]\n+    struct A8(u32, u32);\n+    #[repr(packed)]\n+    struct A9(u32, u32, u8);\n+    #[repr(packed)]\n+    struct A10(u32, u32, u16);\n+\n+    unsafe fn test_weird_stride<T>(ptr: *const T, align: usize) -> bool {\n+        let numptr = ptr as usize;\n+        let mut expected = usize::max_value();\n+        // Naive but definitely correct way to find the *first* aligned element of stride::<T>.\n+        for el in 0..align {\n+            if (numptr + el * ::std::mem::size_of::<T>()) % align == 0 {\n+                expected = el;\n+                break;\n+            }\n+        }\n+        let got = ptr.align_offset(align);\n+        if got != expected {\n+            eprintln!(\"aligning {:p} (with stride of {}) to {}, expected {}, got {}\", ptr,\n+                      ::std::mem::size_of::<T>(), align, expected, got);\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    // For pointers of stride != 1, we verify the algorithm against the naivest possible\n+    // implementation\n+    let mut align = 1;\n+    let mut x = false;\n+    while align < 1024 {\n+        for ptr in 1usize..4*align {\n+            unsafe {\n+                x |= test_weird_stride::<A3>(ptr as *const A3, align);\n+                x |= test_weird_stride::<A4>(ptr as *const A4, align);\n+                x |= test_weird_stride::<A5>(ptr as *const A5, align);\n+                x |= test_weird_stride::<A6>(ptr as *const A6, align);\n+                x |= test_weird_stride::<A7>(ptr as *const A7, align);\n+                x |= test_weird_stride::<A8>(ptr as *const A8, align);\n+                x |= test_weird_stride::<A9>(ptr as *const A9, align);\n+                x |= test_weird_stride::<A10>(ptr as *const A10, align);\n+            }\n+        }\n+        align = (align + 1).next_power_of_two();\n+    }\n+    assert!(!x);\n+}"}, {"sha": "8acb531b989a03a78d2b982f41616c1ae0fcf191", "filename": "src/libcore/tests/slice.rs", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/680031b0164a94aaeee17a1d8c3027e6e8865a4c/src%2Flibcore%2Ftests%2Fslice.rs", "raw_url": "https://github.com/rust-lang/rust/raw/680031b0164a94aaeee17a1d8c3027e6e8865a4c/src%2Flibcore%2Ftests%2Fslice.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ftests%2Fslice.rs?ref=680031b0164a94aaeee17a1d8c3027e6e8865a4c", "patch": "@@ -812,3 +812,37 @@ pub mod memchr {\n         }\n     }\n }\n+\n+#[test]\n+fn test_align_to_simple() {\n+    let bytes = [1u8, 2, 3, 4, 5, 6, 7];\n+    let (prefix, aligned, suffix) = unsafe { bytes.align_to::<u16>() };\n+    assert_eq!(aligned.len(), 3);\n+    assert!(prefix == [1] || suffix == [7]);\n+    let expect1 = [1 << 8 | 2, 3 << 8 | 4, 5 << 8 | 6];\n+    let expect2 = [1 | 2 << 8, 3 | 4 << 8, 5 | 6 << 8];\n+    let expect3 = [2 | 3 << 8, 4 | 5 << 8, 6 | 7 << 8];\n+    let expect4 = [2 | 3 << 8, 4 | 5 << 8, 6 | 7 << 8];\n+    assert!(aligned == expect1 || aligned == expect2 || aligned == expect3 || aligned == expect4,\n+            \"aligned={:?} expected={:?} || {:?} || {:?} || {:?}\",\n+            aligned, expect1, expect2, expect3, expect4);\n+}\n+\n+#[test]\n+fn test_align_to_zst() {\n+    let bytes = [1, 2, 3, 4, 5, 6, 7];\n+    let (prefix, aligned, suffix) = unsafe { bytes.align_to::<()>() };\n+    assert_eq!(aligned.len(), 0);\n+    assert!(prefix == [1, 2, 3, 4, 5, 6, 7] || suffix == [1, 2, 3, 4, 5, 6, 7]);\n+}\n+\n+#[test]\n+fn test_align_to_non_trivial() {\n+    #[repr(align(8))] struct U64(u64, u64);\n+    #[repr(align(8))] struct U64U64U32(u64, u64, u32);\n+    let data = [U64(1, 2), U64(3, 4), U64(5, 6), U64(7, 8), U64(9, 10), U64(11, 12), U64(13, 14),\n+                U64(15, 16)];\n+    let (prefix, aligned, suffix) = unsafe { data.align_to::<U64U64U32>() };\n+    assert_eq!(aligned.len(), 4);\n+    assert_eq!(prefix.len() + suffix.len(), 2);\n+}"}, {"sha": "f7d427cb7b26c8d989a2053f5a0cf429860e8df1", "filename": "src/test/run-pass/align-offset-sign.rs", "status": "removed", "additions": 0, "deletions": 94, "changes": 94, "blob_url": "https://github.com/rust-lang/rust/blob/d45378216b31eab9ee7c7c461ae20bfb29bd20b3/src%2Ftest%2Frun-pass%2Falign-offset-sign.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d45378216b31eab9ee7c7c461ae20bfb29bd20b3/src%2Ftest%2Frun-pass%2Falign-offset-sign.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Falign-offset-sign.rs?ref=d45378216b31eab9ee7c7c461ae20bfb29bd20b3", "patch": "@@ -1,94 +0,0 @@\n-// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n-// file at the top-level directory of this distribution and at\n-// http://rust-lang.org/COPYRIGHT.\n-//\n-// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n-// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n-// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n-// option. This file may not be copied, modified, or distributed\n-// except according to those terms.\n-\n-#![feature(align_offset)]\n-\n-#[derive(Clone, Copy)]\n-#[repr(packed)]\n-struct A3(u16, u8);\n-struct A4(u32);\n-#[repr(packed)]\n-struct A5(u32, u8);\n-#[repr(packed)]\n-struct A6(u32, u16);\n-#[repr(packed)]\n-struct A7(u32, u16, u8);\n-#[repr(packed)]\n-struct A8(u32, u32);\n-#[repr(packed)]\n-struct A9(u32, u32, u8);\n-#[repr(packed)]\n-struct A10(u32, u32, u16);\n-\n-unsafe fn test_weird_stride<T>(ptr: *const T, align: usize) -> bool {\n-    let numptr = ptr as usize;\n-    let mut expected = usize::max_value();\n-    // Naive but definitely correct way to find the *first* aligned element of stride::<T>.\n-    for el in (0..align) {\n-        if (numptr + el * ::std::mem::size_of::<T>()) % align == 0 {\n-            expected = el;\n-            break;\n-        }\n-    }\n-    let got = ptr.align_offset(align);\n-    if got != expected {\n-        eprintln!(\"aligning {:p} (with stride of {}) to {}, expected {}, got {}\", ptr, ::std::mem::size_of::<T>(), align, expected, got);\n-        return true;\n-    }\n-    return false;\n-}\n-\n-fn main() {\n-    unsafe {\n-        // For pointers of stride = 0, the pointer is already aligned or it cannot be aligned at\n-        // all, because no amount of elements will align the pointer.\n-        let mut p = 1;\n-        while p < 1024 {\n-            assert_eq!((p as *const ()).align_offset(p), 0);\n-            if (p != 1) {\n-                assert_eq!(((p + 1) as *const ()).align_offset(p), !0);\n-            }\n-            p = (p + 1).next_power_of_two();\n-        }\n-\n-        // For pointers of stride = 1, the pointer can always be aligned. The offset is equal to\n-        // number of bytes.\n-        let mut align = 1;\n-        while align < 1024 {\n-            for ptr in 1..2*align {\n-                let expected = ptr % align;\n-                let offset = if expected == 0 { 0 } else { align - expected };\n-                assert_eq!((ptr as *const u8).align_offset(align), offset,\n-                           \"ptr = {}, align = {}, size = 1\", ptr, align);\n-                align = (align + 1).next_power_of_two();\n-            }\n-        }\n-\n-\n-        // For pointers of stride != 1, we verify the algorithm against the naivest possible\n-        // implementation\n-        let mut align = 1;\n-        let mut x = false;\n-        while align < 1024 {\n-            for ptr in 1usize..4*align {\n-                x |= test_weird_stride::<A3>(ptr as *const A3, align);\n-                x |= test_weird_stride::<A4>(ptr as *const A4, align);\n-                x |= test_weird_stride::<A5>(ptr as *const A5, align);\n-                x |= test_weird_stride::<A6>(ptr as *const A6, align);\n-                x |= test_weird_stride::<A7>(ptr as *const A7, align);\n-                x |= test_weird_stride::<A8>(ptr as *const A8, align);\n-                x |= test_weird_stride::<A9>(ptr as *const A9, align);\n-                x |= test_weird_stride::<A10>(ptr as *const A10, align);\n-            }\n-            align = (align + 1).next_power_of_two();\n-        }\n-        assert!(!x);\n-    }\n-}"}]}