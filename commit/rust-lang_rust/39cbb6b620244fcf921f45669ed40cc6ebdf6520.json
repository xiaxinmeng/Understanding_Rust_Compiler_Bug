{"sha": "39cbb6b620244fcf921f45669ed40cc6ebdf6520", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM5Y2JiNmI2MjAyNDRmY2Y5MjFmNDU2NjllZDQwY2M2ZWJkZjY1MjA=", "commit": {"author": {"name": "Michal Terepeta", "email": "michal.terepeta@gmail.com", "date": "2020-01-19T15:07:15Z"}, "committer": {"name": "Michal Terepeta", "email": "michal.terepeta@gmail.com", "date": "2020-01-22T19:13:56Z"}, "message": "Rewrite ra_prof's profile printing\n\nThis changes the way we print things to first construct a mapping from\nevents to the children and uses that mapping to actually print things.\nIt should not change the actual output that we produce.\n\nThe new approach two benefits:\n\n * It avoids a potential quadratic behavior of the previous approach.\n   For instance, for a vector of N elements:\n   ```\n   [Message{level: (N - 1)}, ..., Message{level: 1}, Message{level: 0}]\n   ```\n   we would first do a linear scan to find entry with level 0, then\n   another scan to find one with level 1, etc.\n\n * It makes it much easier to improve the output in the future, because\n   we now pre-compute the children for each entry and can easily take\n   that into account when printing.\n\nSigned-off-by: Michal Terepeta <michal.terepeta@gmail.com>", "tree": {"sha": "e8516f6712b932bf51e558302cec4e1621255fd7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e8516f6712b932bf51e558302cec4e1621255fd7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/39cbb6b620244fcf921f45669ed40cc6ebdf6520", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/39cbb6b620244fcf921f45669ed40cc6ebdf6520", "html_url": "https://github.com/rust-lang/rust/commit/39cbb6b620244fcf921f45669ed40cc6ebdf6520", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/39cbb6b620244fcf921f45669ed40cc6ebdf6520/comments", "author": {"login": "michalt", "id": 119711, "node_id": "MDQ6VXNlcjExOTcxMQ==", "avatar_url": "https://avatars.githubusercontent.com/u/119711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michalt", "html_url": "https://github.com/michalt", "followers_url": "https://api.github.com/users/michalt/followers", "following_url": "https://api.github.com/users/michalt/following{/other_user}", "gists_url": "https://api.github.com/users/michalt/gists{/gist_id}", "starred_url": "https://api.github.com/users/michalt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michalt/subscriptions", "organizations_url": "https://api.github.com/users/michalt/orgs", "repos_url": "https://api.github.com/users/michalt/repos", "events_url": "https://api.github.com/users/michalt/events{/privacy}", "received_events_url": "https://api.github.com/users/michalt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "michalt", "id": 119711, "node_id": "MDQ6VXNlcjExOTcxMQ==", "avatar_url": "https://avatars.githubusercontent.com/u/119711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/michalt", "html_url": "https://github.com/michalt", "followers_url": "https://api.github.com/users/michalt/followers", "following_url": "https://api.github.com/users/michalt/following{/other_user}", "gists_url": "https://api.github.com/users/michalt/gists{/gist_id}", "starred_url": "https://api.github.com/users/michalt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/michalt/subscriptions", "organizations_url": "https://api.github.com/users/michalt/orgs", "repos_url": "https://api.github.com/users/michalt/repos", "events_url": "https://api.github.com/users/michalt/events{/privacy}", "received_events_url": "https://api.github.com/users/michalt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9b1465af322e311152a23c1f61f967bda2bffcee", "url": "https://api.github.com/repos/rust-lang/rust/commits/9b1465af322e311152a23c1f61f967bda2bffcee", "html_url": "https://github.com/rust-lang/rust/commit/9b1465af322e311152a23c1f61f967bda2bffcee"}], "stats": {"total": 117, "additions": 71, "deletions": 46}, "files": [{"sha": "d95e7eb1bbf41aabf72bf610e22533930739722f", "filename": "crates/ra_prof/src/lib.rs", "status": "modified", "additions": 71, "deletions": 46, "changes": 117, "blob_url": "https://github.com/rust-lang/rust/blob/39cbb6b620244fcf921f45669ed40cc6ebdf6520/crates%2Fra_prof%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39cbb6b620244fcf921f45669ed40cc6ebdf6520/crates%2Fra_prof%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_prof%2Fsrc%2Flib.rs?ref=39cbb6b620244fcf921f45669ed40cc6ebdf6520", "patch": "@@ -6,9 +6,9 @@ mod google_cpu_profiler;\n \n use std::{\n     cell::RefCell,\n+    collections::BTreeMap,\n     collections::HashSet,\n     io::{stderr, Write},\n-    iter::repeat,\n     mem,\n     sync::{\n         atomic::{AtomicBool, Ordering},\n@@ -17,7 +17,6 @@ use std::{\n     time::{Duration, Instant},\n };\n \n-use itertools::Itertools;\n use once_cell::sync::Lazy;\n \n pub use crate::memory_usage::{Bytes, MemoryUsage};\n@@ -201,7 +200,7 @@ impl Drop for Profiler {\n                         // (otherwise we could print `0ms` despite user's `>0` filter when\n                         // `duration` is just a few nanos).\n                         if duration.as_millis() > longer_than.as_millis() {\n-                            print(0, &stack.messages, &mut stdout.lock(), longer_than, None);\n+                            print(&stack.messages, longer_than, &mut stdout.lock());\n                         }\n                         stack.messages.clear();\n                     }\n@@ -212,59 +211,85 @@ impl Drop for Profiler {\n     }\n }\n \n-fn print(\n-    lvl: usize,\n-    msgs: &[Message],\n-    out: &mut impl Write,\n-    longer_than: Duration,\n-    total: Option<Duration>,\n-) {\n+fn print(msgs: &[Message], longer_than: Duration, out: &mut impl Write) {\n     if msgs.is_empty() {\n         return;\n     }\n-    // The index of the first element that will be included in the slice when we recurse.\n-    let mut next_start = 0;\n-    let indent = repeat(\"    \").take(lvl).collect::<String>();\n-    // We output hierarchy for long calls, but sum up all short calls\n-    let mut short = Vec::new();\n+    let children_map = idx_to_children(msgs);\n+    let root_idx = msgs.len() - 1;\n+    print_for_idx(root_idx, &children_map, msgs, longer_than, out);\n+}\n+\n+fn print_for_idx(\n+    current_idx: usize,\n+    children_map: &[Vec<usize>],\n+    msgs: &[Message],\n+    longer_than: Duration,\n+    out: &mut impl Write,\n+) {\n+    let current = &msgs[current_idx];\n+    let current_indent = \"    \".repeat(current.level);\n+    writeln!(out, \"{}{:5}ms - {}\", current_indent, current.duration.as_millis(), current.message)\n+        .expect(\"printing profiling info\");\n+\n+    let longer_than_millis = longer_than.as_millis();\n+    let children_indices = &children_map[current_idx];\n     let mut accounted_for = Duration::default();\n-    for (i, &Message { level, duration, message: ref msg }) in msgs.iter().enumerate() {\n-        if level != lvl {\n-            continue;\n-        }\n-        accounted_for += duration;\n-        if duration.as_millis() > longer_than.as_millis() {\n-            writeln!(out, \"{}{:5}ms - {}\", indent, duration.as_millis(), msg)\n-                .expect(\"printing profiling info to stdout\");\n+    let mut short_children = BTreeMap::new(); // Use `BTreeMap` to get deterministic output.\n \n-            print(lvl + 1, &msgs[next_start..i], out, longer_than, Some(duration));\n+    for child_idx in children_indices.iter() {\n+        let child = &msgs[*child_idx];\n+        if child.duration.as_millis() > longer_than_millis {\n+            print_for_idx(*child_idx, children_map, msgs, longer_than, out);\n         } else {\n-            short.push((msg, duration))\n+            let pair = short_children.entry(&child.message).or_insert((Duration::default(), 0));\n+            pair.0 += child.duration;\n+            pair.1 += 1;\n         }\n+        accounted_for += child.duration;\n+    }\n \n-        next_start = i + 1;\n+    for (child_msg, (duration, count)) in short_children.iter() {\n+        let millis = duration.as_millis();\n+        writeln!(out, \"    {}{:5}ms - {} ({} calls)\", current_indent, millis, child_msg, count)\n+            .expect(\"printing profiling info\");\n     }\n-    short.sort_by_key(|(msg, _time)| *msg);\n-    for (msg, entires) in short.iter().group_by(|(msg, _time)| msg).into_iter() {\n-        let mut count = 0;\n-        let mut total_duration = Duration::default();\n-        entires.for_each(|(_msg, time)| {\n-            count += 1;\n-            total_duration += *time;\n-        });\n-        writeln!(out, \"{}{:5}ms - {} ({} calls)\", indent, total_duration.as_millis(), msg, count)\n-            .expect(\"printing profiling info to stdout\");\n+\n+    let unaccounted_millis = (current.duration - accounted_for).as_millis();\n+    if !children_indices.is_empty()\n+        && unaccounted_millis > 0\n+        && unaccounted_millis > longer_than_millis\n+    {\n+        writeln!(out, \"    {}{:5}ms - ???\", current_indent, unaccounted_millis)\n+            .expect(\"printing profiling info\");\n     }\n+}\n \n-    if let Some(total) = total {\n-        if let Some(unaccounted) = total.checked_sub(accounted_for) {\n-            let unaccounted_millis = unaccounted.as_millis();\n-            if unaccounted_millis > longer_than.as_millis() && unaccounted_millis > 0 {\n-                writeln!(out, \"{}{:5}ms - ???\", indent, unaccounted_millis)\n-                    .expect(\"printing profiling info to stdout\");\n-            }\n+/// Returns a mapping from an index in the `msgs` to the vector with the indices of its children.\n+///\n+/// This assumes that the entries in `msgs` are in the order of when the calls to `profile` finish.\n+/// In other words, a postorder of the call graph. In particular, the root is the last element of\n+/// `msgs`.\n+fn idx_to_children(msgs: &[Message]) -> Vec<Vec<usize>> {\n+    // Initialize with the index of the root; `ancestors` should be never empty.\n+    let mut ancestors = vec![msgs.len() - 1];\n+    let mut result: Vec<Vec<usize>> = vec![];\n+    result.resize_with(msgs.len(), Default::default);\n+    for (idx, msg) in msgs[..msgs.len() - 1].iter().enumerate().rev() {\n+        // We need to find the parent of the current message, i.e., the last ancestor that has a\n+        // level lower than the current message.\n+        while msgs[*ancestors.last().unwrap()].level >= msg.level {\n+            ancestors.pop();\n         }\n+        result[*ancestors.last().unwrap()].push(idx);\n+        ancestors.push(idx);\n+    }\n+    // Note that above we visited all children from the last to the first one. Let's reverse vectors\n+    // to get the more natural order where the first element is the first child.\n+    for vec in result.iter_mut() {\n+        vec.reverse();\n     }\n+    result\n }\n \n /// Prints backtrace to stderr, useful for debugging.\n@@ -373,7 +398,7 @@ mod tests {\n             Message { level: 1, duration: Duration::from_nanos(2), message: \"bar\".to_owned() },\n             Message { level: 0, duration: Duration::from_millis(1), message: \"foo\".to_owned() },\n         ];\n-        print(0, &msgs, &mut result, Duration::from_millis(0), Some(Duration::from_millis(1)));\n+        print(&msgs, Duration::from_millis(0), &mut result);\n         // The calls to `bar` are so short that they'll be rounded to 0ms and should get collapsed\n         // when printing.\n         assert_eq!(\n@@ -389,7 +414,7 @@ mod tests {\n             Message { level: 1, duration: Duration::from_millis(2), message: \"bar\".to_owned() },\n             Message { level: 0, duration: Duration::from_millis(5), message: \"foo\".to_owned() },\n         ];\n-        print(0, &msgs, &mut result, Duration::from_millis(0), Some(Duration::from_millis(1)));\n+        print(&msgs, Duration::from_millis(0), &mut result);\n         assert_eq!(\n             std::str::from_utf8(&result).unwrap().lines().collect::<Vec<_>>(),\n             vec![\n@@ -411,7 +436,7 @@ mod tests {\n             Message { level: 1, duration: Duration::from_millis(4), message: \"bar\".to_owned() },\n             Message { level: 0, duration: Duration::from_millis(9), message: \"foo\".to_owned() },\n         ];\n-        print(0, &msgs, &mut result, Duration::from_millis(0), None);\n+        print(&msgs, Duration::from_millis(0), &mut result);\n         assert_eq!(\n             std::str::from_utf8(&result).unwrap().lines().collect::<Vec<_>>(),\n             vec!["}]}