{"sha": "d15abaa06fe65a01072c74db55786e97d17365b4", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQxNWFiYWEwNmZlNjVhMDEwNzJjNzRkYjU1Nzg2ZTk3ZDE3MzY1YjQ=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-04-19T13:54:34Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2019-04-19T13:54:34Z"}, "message": "Merge #1168\n\n1168: Add all remaining mbe matchers r=matklad a=edwin0cheng\n\nThis PR adds following  mbe matchers:\r\n\r\n* block\r\n* meta\r\n* tt\r\n* literal\r\n* vis\n\nCo-authored-by: Edwin Cheng <edwin0cheng@gmail.com>", "tree": {"sha": "68024131d628d333ffd4e6dcba453b335bfafbae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/68024131d628d333ffd4e6dcba453b335bfafbae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d15abaa06fe65a01072c74db55786e97d17365b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d15abaa06fe65a01072c74db55786e97d17365b4", "html_url": "https://github.com/rust-lang/rust/commit/d15abaa06fe65a01072c74db55786e97d17365b4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d15abaa06fe65a01072c74db55786e97d17365b4/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "153db2467f691aaf5ff6d87044342ddae4ee9ae6", "url": "https://api.github.com/repos/rust-lang/rust/commits/153db2467f691aaf5ff6d87044342ddae4ee9ae6", "html_url": "https://github.com/rust-lang/rust/commit/153db2467f691aaf5ff6d87044342ddae4ee9ae6"}, {"sha": "1afde29adbb6c9094babe117f7972f7157d16cc1", "url": "https://api.github.com/repos/rust-lang/rust/commits/1afde29adbb6c9094babe117f7972f7157d16cc1", "html_url": "https://github.com/rust-lang/rust/commit/1afde29adbb6c9094babe117f7972f7157d16cc1"}], "stats": {"total": 229, "additions": 227, "deletions": 2}, "files": [{"sha": "814586fd66d918a61c9940547ea9957f5785816f", "filename": "crates/ra_mbe/src/lib.rs", "status": "modified", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/d15abaa06fe65a01072c74db55786e97d17365b4/crates%2Fra_mbe%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d15abaa06fe65a01072c74db55786e97d17365b4/crates%2Fra_mbe%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Flib.rs?ref=d15abaa06fe65a01072c74db55786e97d17365b4", "patch": "@@ -731,4 +731,95 @@ MACRO_ITEMS@[0; 40)\n         }\n \"#, r#\"extern crate a ; mod b ; mod c {} use d ; const E : i32 = 0 ; static F : i32 = 0 ; impl G {} struct H ; enum I {Foo} trait J {} fn h () {} extern {} type T = u8 ;\"#);\n     }\n+\n+    #[test]\n+    fn test_block() {\n+        let rules = create_rules(\n+            r#\"\n+        macro_rules! foo {\n+            ($ i:block) => { fn foo() $ i }\n+        }\n+\"#,\n+        );\n+        assert_expansion(&rules, \"foo! { { 1; } }\", \"fn foo () {1 ;}\");\n+    }\n+\n+    #[test]\n+    fn test_meta() {\n+        let rules = create_rules(\n+            r#\"\n+        macro_rules! foo {\n+            ($ i:meta) => (\n+                #[$ i]\n+                fn bar() {}\n+            )\n+        }\n+\"#,\n+        );\n+        assert_expansion(\n+            &rules,\n+            r#\"foo! { cfg(target_os = \"windows\") }\"#,\n+            r#\"# [cfg (target_os = \"windows\")] fn bar () {}\"#,\n+        );\n+    }\n+\n+    #[test]\n+    fn test_tt_block() {\n+        let rules = create_rules(\n+            r#\"\n+        macro_rules! foo {\n+            ($ i:tt) => { fn foo() $ i }\n+        }\n+\"#,\n+        );\n+        assert_expansion(&rules, r#\"foo! { { 1; } }\"#, r#\"fn foo () {1 ;}\"#);\n+    }\n+\n+    #[test]\n+    fn test_tt_group() {\n+        let rules = create_rules(\n+            r#\"\n+        macro_rules! foo {\n+             ($($ i:tt)*) => { $($ i)* }\n+        }\n+\"#,\n+        );\n+        assert_expansion(&rules, r#\"foo! { fn foo() {} }\"#, r#\"fn foo () {}\"#);\n+    }\n+\n+    #[test]\n+    fn test_lifetime() {\n+        let rules = create_rules(\n+            r#\"\n+        macro_rules! foo {\n+              ($ lt:lifetime) => { struct Ref<$ lt>{ s: &$ lt str } }\n+        }\n+\"#,\n+        );\n+        assert_expansion(&rules, r#\"foo!{'a}\"#, r#\"struct Ref < 'a > {s : & 'a str}\"#);\n+    }\n+\n+    #[test]\n+    fn test_literal() {\n+        let rules = create_rules(\n+            r#\"\n+        macro_rules! foo {\n+              ($ type:ty $ lit:literal) => { const VALUE: $ type = $ lit;};\n+        }\n+\"#,\n+        );\n+        assert_expansion(&rules, r#\"foo!(u8 0)\"#, r#\"const VALUE : u8 = 0 ;\"#);\n+    }\n+\n+    #[test]\n+    fn test_vis() {\n+        let rules = create_rules(\n+            r#\"\n+        macro_rules! foo {\n+              ($ vis:vis $ name:ident) => { $ vis fn $ name() {}};\n+        }\n+\"#,\n+        );\n+        assert_expansion(&rules, r#\"foo!(pub foo);\"#, r#\"pub fn foo () {}\"#);\n+    }\n }"}, {"sha": "01e29b556a97be91cf18e015d794d25633dec9bf", "filename": "crates/ra_mbe/src/mbe_expander.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d15abaa06fe65a01072c74db55786e97d17365b4/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d15abaa06fe65a01072c74db55786e97d17365b4/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs?ref=d15abaa06fe65a01072c74db55786e97d17365b4", "patch": "@@ -161,11 +161,43 @@ fn match_lhs(pattern: &crate::Subtree, input: &mut TtCursor) -> Result<Bindings,\n                             let pat = input.eat_stmt().ok_or(ExpandError::UnexpectedToken)?.clone();\n                             res.inner.insert(text.clone(), Binding::Simple(pat.into()));\n                         }\n+                        \"block\" => {\n+                            let block =\n+                                input.eat_block().ok_or(ExpandError::UnexpectedToken)?.clone();\n+                            res.inner.insert(text.clone(), Binding::Simple(block.into()));\n+                        }\n+                        \"meta\" => {\n+                            let meta =\n+                                input.eat_meta().ok_or(ExpandError::UnexpectedToken)?.clone();\n+                            res.inner.insert(text.clone(), Binding::Simple(meta.into()));\n+                        }\n+                        \"tt\" => {\n+                            let token = input.eat().ok_or(ExpandError::UnexpectedToken)?.clone();\n+                            res.inner.insert(text.clone(), Binding::Simple(token.into()));\n+                        }\n                         \"item\" => {\n                             let item =\n                                 input.eat_item().ok_or(ExpandError::UnexpectedToken)?.clone();\n                             res.inner.insert(text.clone(), Binding::Simple(item.into()));\n                         }\n+                        \"lifetime\" => {\n+                            let lifetime =\n+                                input.eat_lifetime().ok_or(ExpandError::UnexpectedToken)?.clone();\n+                            res.inner.insert(text.clone(), Binding::Simple(lifetime.into()));\n+                        }\n+                        \"literal\" => {\n+                            let literal =\n+                                input.eat_literal().ok_or(ExpandError::UnexpectedToken)?.clone();\n+                            res.inner.insert(\n+                                text.clone(),\n+                                Binding::Simple(tt::Leaf::from(literal).into()),\n+                            );\n+                        }\n+                        \"vis\" => {\n+                            let vis = input.eat_vis().ok_or(ExpandError::UnexpectedToken)?.clone();\n+                            res.inner.insert(text.clone(), Binding::Simple(vis.into()));\n+                        }\n+\n                         _ => return Err(ExpandError::UnexpectedToken),\n                     }\n                 }"}, {"sha": "528aa0f8a0c8edb71e73752e48be95d05362b2e3", "filename": "crates/ra_mbe/src/subtree_parser.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d15abaa06fe65a01072c74db55786e97d17365b4/crates%2Fra_mbe%2Fsrc%2Fsubtree_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d15abaa06fe65a01072c74db55786e97d17365b4/crates%2Fra_mbe%2Fsrc%2Fsubtree_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fsubtree_parser.rs?ref=d15abaa06fe65a01072c74db55786e97d17365b4", "patch": "@@ -46,10 +46,22 @@ impl<'a> Parser<'a> {\n         self.parse(|src, sink| ra_parser::parse_stmt(src, sink, false))\n     }\n \n+    pub fn parse_block(self) -> Option<tt::TokenTree> {\n+        self.parse(ra_parser::parse_block)\n+    }\n+\n+    pub fn parse_meta(self) -> Option<tt::TokenTree> {\n+        self.parse(ra_parser::parse_meta)\n+    }\n+\n     pub fn parse_item(self) -> Option<tt::TokenTree> {\n         self.parse(ra_parser::parse_item)\n     }\n \n+    pub fn parse_vis(self) -> Option<tt::TokenTree> {\n+        self.parse(ra_parser::parse_vis)\n+    }\n+\n     fn parse<F>(self, f: F) -> Option<tt::TokenTree>\n     where\n         F: FnOnce(&dyn TokenSource, &mut dyn TreeSink),"}, {"sha": "38a4810299a99f018ff4037c06455361f89fc7e5", "filename": "crates/ra_mbe/src/syntax_bridge.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d15abaa06fe65a01072c74db55786e97d17365b4/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d15abaa06fe65a01072c74db55786e97d17365b4/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fsyntax_bridge.rs?ref=d15abaa06fe65a01072c74db55786e97d17365b4", "patch": "@@ -157,7 +157,10 @@ fn convert_tt(\n                         );\n                     }\n                 } else {\n-                    let child = if token.kind().is_keyword() || token.kind() == IDENT {\n+                    let child: tt::TokenTree = if token.kind().is_keyword()\n+                        || token.kind() == IDENT\n+                        || token.kind() == LIFETIME\n+                    {\n                         let relative_range = token.range() - global_offset;\n                         let id = token_map.alloc(relative_range);\n                         let text = token.text().clone();"}, {"sha": "741b5ea1cc7b66a9dc27577571c4c7c6ba9b7194", "filename": "crates/ra_mbe/src/tt_cursor.rs", "status": "modified", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/d15abaa06fe65a01072c74db55786e97d17365b4/crates%2Fra_mbe%2Fsrc%2Ftt_cursor.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d15abaa06fe65a01072c74db55786e97d17365b4/crates%2Fra_mbe%2Fsrc%2Ftt_cursor.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Ftt_cursor.rs?ref=d15abaa06fe65a01072c74db55786e97d17365b4", "patch": "@@ -41,6 +41,13 @@ impl<'a> TtCursor<'a> {\n         }\n     }\n \n+    pub(crate) fn at_literal(&mut self) -> Option<&'a tt::Literal> {\n+        match self.current() {\n+            Some(tt::TokenTree::Leaf(tt::Leaf::Literal(i))) => Some(i),\n+            _ => None,\n+        }\n+    }\n+\n     pub(crate) fn bump(&mut self) {\n         self.pos += 1;\n     }\n@@ -79,6 +86,13 @@ impl<'a> TtCursor<'a> {\n         })\n     }\n \n+    pub(crate) fn eat_literal(&mut self) -> Option<&'a tt::Literal> {\n+        self.at_literal().map(|i| {\n+            self.bump();\n+            i\n+        })\n+    }\n+\n     pub(crate) fn eat_path(&mut self) -> Option<tt::TokenTree> {\n         let parser = Parser::new(&mut self.pos, self.subtree);\n         parser.parse_path()\n@@ -104,11 +118,37 @@ impl<'a> TtCursor<'a> {\n         parser.parse_stmt()\n     }\n \n+    pub(crate) fn eat_block(&mut self) -> Option<tt::TokenTree> {\n+        let parser = Parser::new(&mut self.pos, self.subtree);\n+        parser.parse_block()\n+    }\n+\n+    pub(crate) fn eat_meta(&mut self) -> Option<tt::TokenTree> {\n+        let parser = Parser::new(&mut self.pos, self.subtree);\n+        parser.parse_meta()\n+    }\n+\n     pub(crate) fn eat_item(&mut self) -> Option<tt::TokenTree> {\n         let parser = Parser::new(&mut self.pos, self.subtree);\n         parser.parse_item()\n     }\n \n+    pub(crate) fn eat_lifetime(&mut self) -> Option<tt::TokenTree> {\n+        // check if it start from \"`\"\n+        if let Some(ident) = self.at_ident() {\n+            if ident.text.chars().next()? != '\\'' {\n+                return None;\n+            }\n+        }\n+\n+        self.eat_ident().cloned().map(|ident| tt::Leaf::from(ident).into())\n+    }\n+\n+    pub(crate) fn eat_vis(&mut self) -> Option<tt::TokenTree> {\n+        let parser = Parser::new(&mut self.pos, self.subtree);\n+        parser.parse_vis()\n+    }\n+\n     pub(crate) fn expect_char(&mut self, char: char) -> Result<(), ParseError> {\n         if self.at_char(char) {\n             self.bump();"}, {"sha": "67eae749d5f6cc44c55c22b39a91d9c26b7b1efd", "filename": "crates/ra_parser/src/grammar.rs", "status": "modified", "additions": 32, "deletions": 1, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/d15abaa06fe65a01072c74db55786e97d17365b4/crates%2Fra_parser%2Fsrc%2Fgrammar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d15abaa06fe65a01072c74db55786e97d17365b4/crates%2Fra_parser%2Fsrc%2Fgrammar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Fgrammar.rs?ref=d15abaa06fe65a01072c74db55786e97d17365b4", "patch": "@@ -95,6 +95,37 @@ pub(crate) fn stmt(p: &mut Parser, with_semi: bool) {\n     expressions::stmt(p, with_semi)\n }\n \n+pub(crate) fn block(p: &mut Parser) {\n+    expressions::block(p);\n+}\n+\n+// Parse a meta item , which excluded [], e.g : #[ MetaItem ]\n+pub(crate) fn meta_item(p: &mut Parser) {\n+    fn is_delimiter(p: &mut Parser) -> bool {\n+        match p.current() {\n+            L_CURLY | L_PAREN | L_BRACK => true,\n+            _ => false,\n+        }\n+    }\n+\n+    if is_delimiter(p) {\n+        items::token_tree(p);\n+        return;\n+    }\n+\n+    let m = p.start();\n+    while !p.at(EOF) {\n+        if is_delimiter(p) {\n+            items::token_tree(p);\n+            break;\n+        } else {\n+            p.bump();\n+        }\n+    }\n+\n+    m.complete(p, TOKEN_TREE);\n+}\n+\n pub(crate) fn item(p: &mut Parser) {\n     items::item_or_macro(p, true, items::ItemFlavor::Mod)\n }\n@@ -136,7 +167,7 @@ impl BlockLike {\n     }\n }\n \n-fn opt_visibility(p: &mut Parser) -> bool {\n+pub(crate) fn opt_visibility(p: &mut Parser) -> bool {\n     match p.current() {\n         PUB_KW => {\n             let m = p.start();"}, {"sha": "970d699c01b23085774c6075e23c5e623653a3ce", "filename": "crates/ra_parser/src/lib.rs", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d15abaa06fe65a01072c74db55786e97d17365b4/crates%2Fra_parser%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d15abaa06fe65a01072c74db55786e97d17365b4/crates%2Fra_parser%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_parser%2Fsrc%2Flib.rs?ref=d15abaa06fe65a01072c74db55786e97d17365b4", "patch": "@@ -93,11 +93,27 @@ pub fn parse_stmt(token_source: &dyn TokenSource, tree_sink: &mut dyn TreeSink,\n     parse_from_tokens(token_source, tree_sink, |p| grammar::stmt(p, with_semi));\n }\n \n+/// Parse given tokens into the given sink as a block\n+pub fn parse_block(token_source: &dyn TokenSource, tree_sink: &mut dyn TreeSink) {\n+    parse_from_tokens(token_source, tree_sink, grammar::block);\n+}\n+\n+pub fn parse_meta(token_source: &dyn TokenSource, tree_sink: &mut dyn TreeSink) {\n+    parse_from_tokens(token_source, tree_sink, grammar::meta_item);\n+}\n+\n /// Parse given tokens into the given sink as an item\n pub fn parse_item(token_source: &dyn TokenSource, tree_sink: &mut dyn TreeSink) {\n     parse_from_tokens(token_source, tree_sink, grammar::item);\n }\n \n+/// Parse given tokens into the given sink as an visibility qualifier\n+pub fn parse_vis(token_source: &dyn TokenSource, tree_sink: &mut dyn TreeSink) {\n+    parse_from_tokens(token_source, tree_sink, |p| {\n+        grammar::opt_visibility(p);\n+    });\n+}\n+\n pub fn parse_macro_items(token_source: &dyn TokenSource, tree_sink: &mut dyn TreeSink) {\n     parse_from_tokens(token_source, tree_sink, grammar::macro_items);\n }"}]}