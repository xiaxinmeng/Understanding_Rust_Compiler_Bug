{"sha": "ff7e057dca58865a670581ab5dcaa006ed17696c", "node_id": "C_kwDOAAsO6NoAKGZmN2UwNTdkY2E1ODg2NWE2NzA1ODFhYjVkY2FhMDA2ZWQxNzY5NmM", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-03-12T15:44:51Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-03-12T15:44:51Z"}, "message": "Merge #11691\n\n11691: feat: Suggest union literals, suggest union fields within an empty union literal r=Veykril a=m0rg-dev\n\nAdds a `Union {\u2026}` completion in contexts where a union is expected, expanding to a choice of available fields (if snippets are supported):\r\n\r\n![image](https://user-images.githubusercontent.com/38578268/158023335-84c03e39-daf0-4a52-b969-f40b01501cc8.png)\r\n![image](https://user-images.githubusercontent.com/38578268/158023354-db49d0bb-034c-49d3-bc02-07414179cb61.png)\r\n\r\nAlso, adds support for listing possible fields in an empty union literal.\r\n\r\n![image](https://user-images.githubusercontent.com/38578268/158023398-4695ae34-ce64-4f40-8494-68731a3030c6.png)\r\n![image](https://user-images.githubusercontent.com/38578268/158023406-be96dd95-125a-47ac-9628-0bce634ca2eb.png)\r\n\r\nCloses #11568.\n\nCo-authored-by: Morgan Thomas <corp@m0rg.dev>", "tree": {"sha": "98fa62c4c65549e6a4b6ead4fa686346de46cc0d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/98fa62c4c65549e6a4b6ead4fa686346de46cc0d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ff7e057dca58865a670581ab5dcaa006ed17696c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJiLL/zCRBK7hj4Ov3rIwAAhDQIAHHOaeRzv+tFrVj9zSkJYVqG\nOCODoA0CAWl8uK5xJH4Xkt/GqiG8WQ6UAw26fiJH1Vx7W0r+/4UwkY42pk4cJQVZ\nDRc7P3oUyDHXS3wXPcgAuHYAtbJYuRg8mOvnH7iYElkBAbeHaq1AaYxiKuiSdKgy\nMZjtDgSnU4M+xuNXESzQo6kLCnxCExG78AcXbGqM4jkxo61Nt1YmUoC4v/Sk/v6w\nb4QfW2ZHRddlewP8a5xNECblMzLd4sKD8J286QntcLAfDnszFMcZuHhD2FmL4Cjd\nLEk8jgSNZR8rM6jIkTS5NQkgQ4foLkBfkJPlrYiThZ7VSRGXOVnt5ZCh+n7i1Iw=\n=W677\n-----END PGP SIGNATURE-----\n", "payload": "tree 98fa62c4c65549e6a4b6ead4fa686346de46cc0d\nparent 421d9643ba5d99446269decfc5bb82a948d16029\nparent f922b805fef6f38da2f5c901fbcd76b9e4ccad92\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1647099891 +0000\ncommitter GitHub <noreply@github.com> 1647099891 +0000\n\nMerge #11691\n\n11691: feat: Suggest union literals, suggest union fields within an empty union literal r=Veykril a=m0rg-dev\n\nAdds a `Union {\u2026}` completion in contexts where a union is expected, expanding to a choice of available fields (if snippets are supported):\r\n\r\n![image](https://user-images.githubusercontent.com/38578268/158023335-84c03e39-daf0-4a52-b969-f40b01501cc8.png)\r\n![image](https://user-images.githubusercontent.com/38578268/158023354-db49d0bb-034c-49d3-bc02-07414179cb61.png)\r\n\r\nAlso, adds support for listing possible fields in an empty union literal.\r\n\r\n![image](https://user-images.githubusercontent.com/38578268/158023398-4695ae34-ce64-4f40-8494-68731a3030c6.png)\r\n![image](https://user-images.githubusercontent.com/38578268/158023406-be96dd95-125a-47ac-9628-0bce634ca2eb.png)\r\n\r\nCloses #11568.\n\nCo-authored-by: Morgan Thomas <corp@m0rg.dev>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ff7e057dca58865a670581ab5dcaa006ed17696c", "html_url": "https://github.com/rust-lang/rust/commit/ff7e057dca58865a670581ab5dcaa006ed17696c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ff7e057dca58865a670581ab5dcaa006ed17696c/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "421d9643ba5d99446269decfc5bb82a948d16029", "url": "https://api.github.com/repos/rust-lang/rust/commits/421d9643ba5d99446269decfc5bb82a948d16029", "html_url": "https://github.com/rust-lang/rust/commit/421d9643ba5d99446269decfc5bb82a948d16029"}, {"sha": "f922b805fef6f38da2f5c901fbcd76b9e4ccad92", "url": "https://api.github.com/repos/rust-lang/rust/commits/f922b805fef6f38da2f5c901fbcd76b9e4ccad92", "html_url": "https://github.com/rust-lang/rust/commit/f922b805fef6f38da2f5c901fbcd76b9e4ccad92"}], "stats": {"total": 207, "additions": 179, "deletions": 28}, "files": [{"sha": "91e6b84294e529a1c3d92d5f6a8df9df43e68deb", "filename": "crates/ide_completion/src/completions.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ff7e057dca58865a670581ab5dcaa006ed17696c/crates%2Fide_completion%2Fsrc%2Fcompletions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff7e057dca58865a670581ab5dcaa006ed17696c/crates%2Fide_completion%2Fsrc%2Fcompletions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions.rs?ref=ff7e057dca58865a670581ab5dcaa006ed17696c", "patch": "@@ -35,6 +35,7 @@ use crate::{\n         render_field, render_resolution, render_tuple_field,\n         struct_literal::render_struct_literal,\n         type_alias::{render_type_alias, render_type_alias_with_eq},\n+        union_literal::render_union_literal,\n         RenderContext,\n     },\n     CompletionContext, CompletionItem, CompletionItemKind,\n@@ -234,6 +235,17 @@ impl Completions {\n         self.add_opt(item);\n     }\n \n+    pub(crate) fn add_union_literal(\n+        &mut self,\n+        ctx: &CompletionContext,\n+        un: hir::Union,\n+        path: Option<hir::ModPath>,\n+        local_name: Option<hir::Name>,\n+    ) {\n+        let item = render_union_literal(RenderContext::new(ctx, false), un, path, local_name);\n+        self.add_opt(item);\n+    }\n+\n     pub(crate) fn add_tuple_field(\n         &mut self,\n         ctx: &CompletionContext,"}, {"sha": "264b3784bf1dc8aff528aaaffe2a261942338e35", "filename": "crates/ide_completion/src/completions/record.rs", "status": "modified", "additions": 54, "deletions": 28, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/ff7e057dca58865a670581ab5dcaa006ed17696c/crates%2Fide_completion%2Fsrc%2Fcompletions%2Frecord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff7e057dca58865a670581ab5dcaa006ed17696c/crates%2Fide_completion%2Fsrc%2Fcompletions%2Frecord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Fcompletions%2Frecord.rs?ref=ff7e057dca58865a670581ab5dcaa006ed17696c", "patch": "@@ -14,32 +14,51 @@ pub(crate) fn complete_record(acc: &mut Completions, ctx: &CompletionContext) ->\n             | ImmediateLocation::RecordExprUpdate(record_expr),\n         ) => {\n             let ty = ctx.sema.type_of_expr(&Expr::RecordExpr(record_expr.clone()));\n-            let default_trait = ctx.famous_defs().core_default_Default();\n-            let impl_default_trait = default_trait.zip(ty).map_or(false, |(default_trait, ty)| {\n-                ty.original.impls_trait(ctx.db, default_trait, &[])\n-            });\n-\n-            let missing_fields = ctx.sema.record_literal_missing_fields(record_expr);\n-            if impl_default_trait && !missing_fields.is_empty() && ctx.path_qual().is_none() {\n-                let completion_text = \"..Default::default()\";\n-                let mut item =\n-                    CompletionItem::new(SymbolKind::Field, ctx.source_range(), completion_text);\n-                let completion_text =\n-                    completion_text.strip_prefix(ctx.token.text()).unwrap_or(completion_text);\n-                item.insert_text(completion_text).set_relevance(CompletionRelevance {\n-                    exact_postfix_snippet_match: true,\n-                    ..Default::default()\n-                });\n-                item.add_to(acc);\n-            }\n-            if ctx.previous_token_is(T![.]) {\n-                let mut item =\n-                    CompletionItem::new(CompletionItemKind::Snippet, ctx.source_range(), \"..\");\n-                item.insert_text(\".\");\n-                item.add_to(acc);\n-                return None;\n+\n+            if let Some(hir::Adt::Union(un)) = ty.as_ref().and_then(|t| t.original.as_adt()) {\n+                // ctx.sema.record_literal_missing_fields will always return\n+                // an empty Vec on a union literal. This is normally\n+                // reasonable, but here we'd like to present the full list\n+                // of fields if the literal is empty.\n+                let were_fields_specified = record_expr\n+                    .record_expr_field_list()\n+                    .and_then(|fl| fl.fields().next())\n+                    .is_some();\n+\n+                match were_fields_specified {\n+                    false => un.fields(ctx.db).into_iter().map(|f| (f, f.ty(ctx.db))).collect(),\n+                    true => vec![],\n+                }\n+            } else {\n+                let missing_fields = ctx.sema.record_literal_missing_fields(record_expr);\n+\n+                let default_trait = ctx.famous_defs().core_default_Default();\n+                let impl_default_trait =\n+                    default_trait.zip(ty.as_ref()).map_or(false, |(default_trait, ty)| {\n+                        ty.original.impls_trait(ctx.db, default_trait, &[])\n+                    });\n+\n+                if impl_default_trait && !missing_fields.is_empty() && ctx.path_qual().is_none() {\n+                    let completion_text = \"..Default::default()\";\n+                    let mut item =\n+                        CompletionItem::new(SymbolKind::Field, ctx.source_range(), completion_text);\n+                    let completion_text =\n+                        completion_text.strip_prefix(ctx.token.text()).unwrap_or(completion_text);\n+                    item.insert_text(completion_text).set_relevance(CompletionRelevance {\n+                        exact_postfix_snippet_match: true,\n+                        ..Default::default()\n+                    });\n+                    item.add_to(acc);\n+                }\n+                if ctx.previous_token_is(T![.]) {\n+                    let mut item =\n+                        CompletionItem::new(CompletionItemKind::Snippet, ctx.source_range(), \"..\");\n+                    item.insert_text(\".\");\n+                    item.add_to(acc);\n+                    return None;\n+                }\n+                missing_fields\n             }\n-            missing_fields\n         }\n         Some(ImmediateLocation::RecordPat(record_pat)) => {\n             ctx.sema.record_pattern_missing_fields(record_pat)\n@@ -62,14 +81,21 @@ pub(crate) fn complete_record_literal(\n         return None;\n     }\n \n-    if let hir::Adt::Struct(strukt) = ctx.expected_type.as_ref()?.as_adt()? {\n-        if ctx.path_qual().is_none() {\n+    match ctx.expected_type.as_ref()?.as_adt()? {\n+        hir::Adt::Struct(strukt) if ctx.path_qual().is_none() => {\n             let module = if let Some(module) = ctx.module { module } else { strukt.module(ctx.db) };\n             let path = module.find_use_path(ctx.db, hir::ModuleDef::from(strukt));\n \n             acc.add_struct_literal(ctx, strukt, path, None);\n         }\n-    }\n+        hir::Adt::Union(un) if ctx.path_qual().is_none() => {\n+            let module = if let Some(module) = ctx.module { module } else { un.module(ctx.db) };\n+            let path = module.find_use_path(ctx.db, hir::ModuleDef::from(un));\n+\n+            acc.add_union_literal(ctx, un, path, None);\n+        }\n+        _ => {}\n+    };\n \n     Some(())\n }"}, {"sha": "0ed346c55e2cb045b04166bb3228d7e72876db22", "filename": "crates/ide_completion/src/render.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ff7e057dca58865a670581ab5dcaa006ed17696c/crates%2Fide_completion%2Fsrc%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff7e057dca58865a670581ab5dcaa006ed17696c/crates%2Fide_completion%2Fsrc%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Frender.rs?ref=ff7e057dca58865a670581ab5dcaa006ed17696c", "patch": "@@ -9,6 +9,7 @@ pub(crate) mod pattern;\n pub(crate) mod type_alias;\n pub(crate) mod struct_literal;\n pub(crate) mod compound;\n+pub(crate) mod union_literal;\n \n use hir::{AsAssocItem, HasAttrs, HirDisplay, ScopeDef};\n use ide_db::{helpers::item_name, RootDatabase, SnippetCap, SymbolKind};"}, {"sha": "80499e102b4824460727a488ae6636ef7e01ebce", "filename": "crates/ide_completion/src/render/union_literal.rs", "status": "added", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/rust-lang/rust/blob/ff7e057dca58865a670581ab5dcaa006ed17696c/crates%2Fide_completion%2Fsrc%2Frender%2Funion_literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff7e057dca58865a670581ab5dcaa006ed17696c/crates%2Fide_completion%2Fsrc%2Frender%2Funion_literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Frender%2Funion_literal.rs?ref=ff7e057dca58865a670581ab5dcaa006ed17696c", "patch": "@@ -0,0 +1,76 @@\n+//! Renderer for `union` literals.\n+\n+use hir::{HirDisplay, Name, StructKind};\n+use itertools::Itertools;\n+\n+use crate::{\n+    render::{\n+        compound::{format_literal_label, visible_fields},\n+        RenderContext,\n+    },\n+    CompletionItem, CompletionItemKind,\n+};\n+\n+pub(crate) fn render_union_literal(\n+    ctx: RenderContext,\n+    un: hir::Union,\n+    path: Option<hir::ModPath>,\n+    local_name: Option<Name>,\n+) -> Option<CompletionItem> {\n+    let name = local_name.unwrap_or_else(|| un.name(ctx.db())).to_smol_str();\n+\n+    let qualified_name = match path {\n+        Some(p) => p.to_string(),\n+        None => name.to_string(),\n+    };\n+\n+    let mut item = CompletionItem::new(\n+        CompletionItemKind::Snippet,\n+        ctx.source_range(),\n+        format_literal_label(&name, StructKind::Record),\n+    );\n+\n+    let fields = un.fields(ctx.db());\n+    let (fields, fields_omitted) = visible_fields(&ctx, &fields, un)?;\n+\n+    if fields.is_empty() {\n+        return None;\n+    }\n+\n+    let literal = if ctx.snippet_cap().is_some() {\n+        format!(\n+            \"{} {{ ${{1|{}|}}: ${{2:()}} }}$0\",\n+            qualified_name,\n+            fields.iter().map(|field| field.name(ctx.db())).format(\",\")\n+        )\n+    } else {\n+        format!(\n+            \"{} {{ {} }}\",\n+            qualified_name,\n+            fields\n+                .iter()\n+                .format_with(\", \", |field, f| { f(&format_args!(\"{}: ()\", field.name(ctx.db()))) })\n+        )\n+    };\n+\n+    let detail = format!(\n+        \"{} {{ {}{} }}\",\n+        qualified_name,\n+        fields.iter().format_with(\", \", |field, f| {\n+            f(&format_args!(\"{}: {}\", field.name(ctx.db()), field.ty(ctx.db()).display(ctx.db())))\n+        }),\n+        if fields_omitted { \", ..\" } else { \"\" }\n+    );\n+\n+    item.set_documentation(ctx.docs(un))\n+        .set_deprecated(ctx.is_deprecated(un))\n+        .detail(&detail)\n+        .set_relevance(ctx.completion_relevance());\n+\n+    match ctx.snippet_cap() {\n+        Some(snippet_cap) => item.insert_snippet(snippet_cap, literal),\n+        None => item.insert_text(literal),\n+    };\n+\n+    Some(item.build())\n+}"}, {"sha": "5e9367960f7e72ab499eacaefeb3b8e24f3efa6c", "filename": "crates/ide_completion/src/tests/record.rs", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/ff7e057dca58865a670581ab5dcaa006ed17696c/crates%2Fide_completion%2Fsrc%2Ftests%2Frecord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff7e057dca58865a670581ab5dcaa006ed17696c/crates%2Fide_completion%2Fsrc%2Ftests%2Frecord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide_completion%2Fsrc%2Ftests%2Frecord.rs?ref=ff7e057dca58865a670581ab5dcaa006ed17696c", "patch": "@@ -204,3 +204,39 @@ fn main() {\n         \"#]],\n     );\n }\n+\n+#[test]\n+fn empty_union_literal() {\n+    check(\n+        r#\"\n+union Union { foo: u32, bar: f32 }\n+\n+fn foo() {\n+    let other = Union {\n+        $0\n+    };\n+}\n+        \"#,\n+        expect![[r#\"\n+            fd foo u32\n+            fd bar f32\n+        \"#]],\n+    )\n+}\n+\n+#[test]\n+fn dont_suggest_additional_union_fields() {\n+    check(\n+        r#\"\n+union Union { foo: u32, bar: f32 }\n+\n+fn foo() {\n+    let other = Union {\n+        foo: 1,\n+        $0\n+    };\n+}\n+        \"#,\n+        expect![[r#\"\"#]],\n+    )\n+}"}]}