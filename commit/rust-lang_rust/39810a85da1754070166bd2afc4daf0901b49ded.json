{"sha": "39810a85da1754070166bd2afc4daf0901b49ded", "node_id": "C_kwDOAAsO6NoAKDM5ODEwYTg1ZGExNzU0MDcwMTY2YmQyYWZjNGRhZjA5MDFiNDlkZWQ", "commit": {"author": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-03-18T21:03:48Z"}, "committer": {"name": "Nicholas Nethercote", "email": "n.nethercote@gmail.com", "date": "2022-03-18T22:44:44Z"}, "message": "Add `TtParser::macro_name`.\n\nInstead of passing it into `parse_tt`.", "tree": {"sha": "3e3e7e05613696add544877816c17300c0d7b019", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3e3e7e05613696add544877816c17300c0d7b019"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/39810a85da1754070166bd2afc4daf0901b49ded", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/39810a85da1754070166bd2afc4daf0901b49ded", "html_url": "https://github.com/rust-lang/rust/commit/39810a85da1754070166bd2afc4daf0901b49ded", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/39810a85da1754070166bd2afc4daf0901b49ded/comments", "author": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nnethercote", "id": 1940286, "node_id": "MDQ6VXNlcjE5NDAyODY=", "avatar_url": "https://avatars.githubusercontent.com/u/1940286?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nnethercote", "html_url": "https://github.com/nnethercote", "followers_url": "https://api.github.com/users/nnethercote/followers", "following_url": "https://api.github.com/users/nnethercote/following{/other_user}", "gists_url": "https://api.github.com/users/nnethercote/gists{/gist_id}", "starred_url": "https://api.github.com/users/nnethercote/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nnethercote/subscriptions", "organizations_url": "https://api.github.com/users/nnethercote/orgs", "repos_url": "https://api.github.com/users/nnethercote/repos", "events_url": "https://api.github.com/users/nnethercote/events{/privacy}", "received_events_url": "https://api.github.com/users/nnethercote/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "354bd1071c0d7a8a636a211b9934a188fd64dabe", "url": "https://api.github.com/repos/rust-lang/rust/commits/354bd1071c0d7a8a636a211b9934a188fd64dabe", "html_url": "https://github.com/rust-lang/rust/commit/354bd1071c0d7a8a636a211b9934a188fd64dabe"}], "stats": {"total": 73, "additions": 35, "deletions": 38}, "files": [{"sha": "e2c586c31be0ae4827546599a3a7de6fa36bf7d1", "filename": "compiler/rustc_expand/src/mbe/macro_parser.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/39810a85da1754070166bd2afc4daf0901b49ded/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39810a85da1754070166bd2afc4daf0901b49ded/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_parser.rs?ref=39810a85da1754070166bd2afc4daf0901b49ded", "patch": "@@ -492,9 +492,15 @@ fn token_name_eq(t1: &Token, t2: &Token) -> bool {\n     }\n }\n \n-pub struct TtParser;\n+pub struct TtParser {\n+    macro_name: Ident,\n+}\n \n impl TtParser {\n+    pub(super) fn new(macro_name: Ident) -> Self {\n+        Self { macro_name }\n+    }\n+\n     /// Process the matcher positions of `cur_items` until it is empty. In the process, this will\n     /// produce more items in `next_items` and `bb_items`.\n     ///\n@@ -693,7 +699,6 @@ impl TtParser {\n         &self,\n         parser: &mut Cow<'_, Parser<'_>>,\n         ms: &[TokenTree],\n-        macro_name: Ident,\n     ) -> NamedParseResult {\n         // A queue of possible matcher positions. We initialize it with the matcher position in\n         // which the \"dot\" is before the first token of the first token tree in `ms`.\n@@ -779,12 +784,7 @@ impl TtParser {\n \n                 (_, _) => {\n                     // Too many possibilities!\n-                    return self.ambiguity_error(\n-                        macro_name,\n-                        next_items,\n-                        bb_items,\n-                        parser.token.span,\n-                    );\n+                    return self.ambiguity_error(next_items, bb_items, parser.token.span);\n                 }\n             }\n \n@@ -794,7 +794,6 @@ impl TtParser {\n \n     fn ambiguity_error<'root, 'tt>(\n         &self,\n-        macro_name: Ident,\n         next_items: SmallVec<[MatcherPosHandle<'root, 'tt>; 1]>,\n         bb_items: SmallVec<[MatcherPosHandle<'root, 'tt>; 1]>,\n         token_span: rustc_span::Span,\n@@ -813,7 +812,8 @@ impl TtParser {\n         Error(\n             token_span,\n             format!(\n-                \"local ambiguity when calling macro `{macro_name}`: multiple parsing options: {}\",\n+                \"local ambiguity when calling macro `{}`: multiple parsing options: {}\",\n+                self.macro_name,\n                 match next_items.len() {\n                     0 => format!(\"built-in NTs {}.\", nts),\n                     1 => format!(\"built-in NTs {} or 1 other option.\", nts),"}, {"sha": "e853b3cb49ae70ff6b31e92edca32773eb8a2458", "filename": "compiler/rustc_expand/src/mbe/macro_rules.rs", "status": "modified", "additions": 25, "deletions": 28, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/39810a85da1754070166bd2afc4daf0901b49ded/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/39810a85da1754070166bd2afc4daf0901b49ded/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_expand%2Fsrc%2Fmbe%2Fmacro_rules.rs?ref=39810a85da1754070166bd2afc4daf0901b49ded", "patch": "@@ -245,7 +245,7 @@ fn generic_extension<'cx>(\n     // this situation.)\n     let parser = parser_from_cx(sess, arg.clone());\n \n-    let tt_parser = TtParser;\n+    let tt_parser = TtParser::new(name);\n     for (i, lhs) in lhses.iter().enumerate() {\n         // try each arm's matchers\n         let lhs_tt = match *lhs {\n@@ -259,7 +259,7 @@ fn generic_extension<'cx>(\n         // are not recorded. On the first `Success(..)`ful matcher, the spans are merged.\n         let mut gated_spans_snapshot = mem::take(&mut *sess.gated_spans.spans.borrow_mut());\n \n-        match tt_parser.parse_tt(&mut Cow::Borrowed(&parser), lhs_tt, name) {\n+        match tt_parser.parse_tt(&mut Cow::Borrowed(&parser), lhs_tt) {\n             Success(named_matches) => {\n                 // The matcher was `Success(..)`ful.\n                 // Merge the gated spans from parsing the matcher with the pre-existing ones.\n@@ -352,11 +352,9 @@ fn generic_extension<'cx>(\n                 mbe::TokenTree::Delimited(_, ref delim) => &delim.tts,\n                 _ => continue,\n             };\n-            if let Success(_) = tt_parser.parse_tt(\n-                &mut Cow::Borrowed(&parser_from_cx(sess, arg.clone())),\n-                lhs_tt,\n-                name,\n-            ) {\n+            if let Success(_) =\n+                tt_parser.parse_tt(&mut Cow::Borrowed(&parser_from_cx(sess, arg.clone())), lhs_tt)\n+            {\n                 if comma_span.is_dummy() {\n                     err.note(\"you might be missing a comma\");\n                 } else {\n@@ -449,27 +447,26 @@ pub fn compile_declarative_macro(\n     ];\n \n     let parser = Parser::new(&sess.parse_sess, body, true, rustc_parse::MACRO_ARGUMENTS);\n-    let tt_parser = TtParser;\n-    let argument_map =\n-        match tt_parser.parse_tt(&mut Cow::Borrowed(&parser), &argument_gram, def.ident) {\n-            Success(m) => m,\n-            Failure(token, msg) => {\n-                let s = parse_failure_msg(&token);\n-                let sp = token.span.substitute_dummy(def.span);\n-                sess.parse_sess.span_diagnostic.struct_span_err(sp, &s).span_label(sp, msg).emit();\n-                return mk_syn_ext(Box::new(macro_rules_dummy_expander));\n-            }\n-            Error(sp, msg) => {\n-                sess.parse_sess\n-                    .span_diagnostic\n-                    .struct_span_err(sp.substitute_dummy(def.span), &msg)\n-                    .emit();\n-                return mk_syn_ext(Box::new(macro_rules_dummy_expander));\n-            }\n-            ErrorReported => {\n-                return mk_syn_ext(Box::new(macro_rules_dummy_expander));\n-            }\n-        };\n+    let tt_parser = TtParser::new(def.ident);\n+    let argument_map = match tt_parser.parse_tt(&mut Cow::Borrowed(&parser), &argument_gram) {\n+        Success(m) => m,\n+        Failure(token, msg) => {\n+            let s = parse_failure_msg(&token);\n+            let sp = token.span.substitute_dummy(def.span);\n+            sess.parse_sess.span_diagnostic.struct_span_err(sp, &s).span_label(sp, msg).emit();\n+            return mk_syn_ext(Box::new(macro_rules_dummy_expander));\n+        }\n+        Error(sp, msg) => {\n+            sess.parse_sess\n+                .span_diagnostic\n+                .struct_span_err(sp.substitute_dummy(def.span), &msg)\n+                .emit();\n+            return mk_syn_ext(Box::new(macro_rules_dummy_expander));\n+        }\n+        ErrorReported => {\n+            return mk_syn_ext(Box::new(macro_rules_dummy_expander));\n+        }\n+    };\n \n     let mut valid = true;\n "}]}