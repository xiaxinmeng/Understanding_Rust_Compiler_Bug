{"sha": "f47e58950bc8541a887d9e1720a5ecc9b9c346d5", "node_id": "MDY6Q29tbWl0NzI0NzEyOmY0N2U1ODk1MGJjODU0MWE4ODdkOWUxNzIwYTVlY2M5YjljMzQ2ZDU=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-08-02T18:20:56Z"}, "committer": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2019-08-04T08:30:42Z"}, "message": "check that atomics are sufficiently aligned, and add test", "tree": {"sha": "5364a94cde15030a3f013b0a312af56c5c2da51a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5364a94cde15030a3f013b0a312af56c5c2da51a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/f47e58950bc8541a887d9e1720a5ecc9b9c346d5", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/f47e58950bc8541a887d9e1720a5ecc9b9c346d5", "html_url": "https://github.com/rust-lang/rust/commit/f47e58950bc8541a887d9e1720a5ecc9b9c346d5", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/f47e58950bc8541a887d9e1720a5ecc9b9c346d5/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "702f63e427a17081db942ff7f964b682b2e2b663", "url": "https://api.github.com/repos/rust-lang/rust/commits/702f63e427a17081db942ff7f964b682b2e2b663", "html_url": "https://github.com/rust-lang/rust/commit/702f63e427a17081db942ff7f964b682b2e2b663"}], "stats": {"total": 69, "additions": 58, "deletions": 11}, "files": [{"sha": "d442fcedbdb177c9eca17db0bc3733007f07bf9e", "filename": "src/shims/intrinsics.rs", "status": "modified", "additions": 46, "deletions": 11, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/f47e58950bc8541a887d9e1720a5ecc9b9c346d5/src%2Fshims%2Fintrinsics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f47e58950bc8541a887d9e1720a5ecc9b9c346d5/src%2Fshims%2Fintrinsics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fshims%2Fintrinsics.rs?ref=f47e58950bc8541a887d9e1720a5ecc9b9c346d5", "patch": "@@ -1,7 +1,7 @@\n use rustc_apfloat::Float;\n use rustc::mir;\n use rustc::mir::interpret::{InterpResult, PointerArithmetic};\n-use rustc::ty::layout::{self, LayoutOf, Size};\n+use rustc::ty::layout::{self, LayoutOf, Size, Align};\n use rustc::ty;\n \n use crate::{\n@@ -48,30 +48,44 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 }\n             }\n \n+            \"volatile_load\" => {\n+                let ptr = this.deref_operand(args[0])?;\n+                this.copy_op(ptr.into(), dest)?;\n+            }\n+\n+            \"volatile_store\" => {\n+                let ptr = this.deref_operand(args[0])?;\n+                this.copy_op(args[1], ptr.into())?;\n+            }\n+\n             \"atomic_load\" |\n             \"atomic_load_relaxed\" |\n             \"atomic_load_acq\" => {\n                 let ptr = this.deref_operand(args[0])?;\n                 let val = this.read_scalar(ptr.into())?; // make sure it fits into a scalar; otherwise it cannot be atomic\n-                this.write_scalar(val, dest)?;\n-            }\n \n-            \"volatile_load\" => {\n-                let ptr = this.deref_operand(args[0])?;\n-                this.copy_op(ptr.into(), dest)?;\n+                // Check alignment requirements. Atomics must always be aligned to their size,\n+                // even if the type they wrap would be less aligned (e.g. AtomicU64 on 32bit must\n+                // be 8-aligned).\n+                let align = Align::from_bytes(ptr.layout.size.bytes()).unwrap();\n+                this.memory().check_ptr_access(ptr.ptr, ptr.layout.size, align)?;\n+\n+                this.write_scalar(val, dest)?;\n             }\n \n             \"atomic_store\" |\n             \"atomic_store_relaxed\" |\n             \"atomic_store_rel\" => {\n                 let ptr = this.deref_operand(args[0])?;\n                 let val = this.read_scalar(args[1])?; // make sure it fits into a scalar; otherwise it cannot be atomic\n-                this.write_scalar(val, ptr.into())?;\n-            }\n \n-            \"volatile_store\" => {\n-                let ptr = this.deref_operand(args[0])?;\n-                this.copy_op(args[1], ptr.into())?;\n+                // Check alignment requirements. Atomics must always be aligned to their size,\n+                // even if the type they wrap would be less aligned (e.g. AtomicU64 on 32bit must\n+                // be 8-aligned).\n+                let align = Align::from_bytes(ptr.layout.size.bytes()).unwrap();\n+                this.memory().check_ptr_access(ptr.ptr, ptr.layout.size, align)?;\n+\n+                this.write_scalar(val, ptr.into())?;\n             }\n \n             \"atomic_fence_acq\" => {\n@@ -82,6 +96,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let ptr = this.deref_operand(args[0])?;\n                 let new = this.read_scalar(args[1])?;\n                 let old = this.read_scalar(ptr.into())?;\n+\n+                // Check alignment requirements. Atomics must always be aligned to their size,\n+                // even if the type they wrap would be less aligned (e.g. AtomicU64 on 32bit must\n+                // be 8-aligned).\n+                let align = Align::from_bytes(ptr.layout.size.bytes()).unwrap();\n+                this.memory().check_ptr_access(ptr.ptr, ptr.layout.size, align)?;\n+\n                 this.write_scalar(old, dest)?; // old value is returned\n                 this.write_scalar(new, ptr.into())?;\n             }\n@@ -91,6 +112,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 let expect_old = this.read_immediate(args[1])?; // read as immediate for the sake of `binary_op()`\n                 let new = this.read_scalar(args[2])?;\n                 let old = this.read_immediate(ptr.into())?; // read as immediate for the sake of `binary_op()`\n+\n+                // Check alignment requirements. Atomics must always be aligned to their size,\n+                // even if the type they wrap would be less aligned (e.g. AtomicU64 on 32bit must\n+                // be 8-aligned).\n+                let align = Align::from_bytes(ptr.layout.size.bytes()).unwrap();\n+                this.memory().check_ptr_access(ptr.ptr, ptr.layout.size, align)?;\n+\n                 // binary_op will bail if either of them is not a scalar\n                 let (eq, _) = this.binary_op(mir::BinOp::Eq, old, expect_old)?;\n                 let res = Immediate::ScalarPair(old.to_scalar_or_undef(), eq.into());\n@@ -137,6 +165,13 @@ pub trait EvalContextExt<'mir, 'tcx: 'mir>: crate::MiriEvalContextExt<'mir, 'tcx\n                 }\n                 let rhs = this.read_immediate(args[1])?;\n                 let old = this.read_immediate(ptr.into())?;\n+\n+                // Check alignment requirements. Atomics must always be aligned to their size,\n+                // even if the type they wrap would be less aligned (e.g. AtomicU64 on 32bit must\n+                // be 8-aligned).\n+                let align = Align::from_bytes(ptr.layout.size.bytes()).unwrap();\n+                this.memory().check_ptr_access(ptr.ptr, ptr.layout.size, align)?;\n+\n                 this.write_immediate(*old, dest)?; // old value is returned\n                 let (op, neg) = match intrinsic_name.split('_').nth(1).unwrap() {\n                     \"or\" => (mir::BinOp::BitOr, false),"}, {"sha": "5d2347c03ffee72c19710d104a7750f59b4d84d9", "filename": "tests/compile-fail/atomic_unaligned.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/f47e58950bc8541a887d9e1720a5ecc9b9c346d5/tests%2Fcompile-fail%2Fatomic_unaligned.rs", "raw_url": "https://github.com/rust-lang/rust/raw/f47e58950bc8541a887d9e1720a5ecc9b9c346d5/tests%2Fcompile-fail%2Fatomic_unaligned.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fcompile-fail%2Fatomic_unaligned.rs?ref=f47e58950bc8541a887d9e1720a5ecc9b9c346d5", "patch": "@@ -0,0 +1,12 @@\n+#![feature(core_intrinsics)]\n+\n+fn main() {\n+    // Do a 4-aligned u64 atomic access. That should be UB on all platforms,\n+    // even if u64 only has alignment 4.\n+    let z = [0u32; 2];\n+    let zptr = &z as *const _ as *const u64;\n+    unsafe {\n+        ::std::intrinsics::atomic_load(zptr);\n+        //~^ ERROR tried to access memory with alignment 4, but alignment 8 is required\n+    }\n+}"}]}