{"sha": "d3163e96553ae8cb1fca0e62084b124e8b98310b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQzMTYzZTk2NTUzYWU4Y2IxZmNhMGU2MjA4NGIxMjRlOGI5ODMxMGI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-01-24T23:04:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-01-24T23:04:15Z"}, "message": "Auto merge of #81355 - jonas-schievink:rollup-vpaadij, r=jonas-schievink\n\nRollup of 14 pull requests\n\nSuccessful merges:\n\n - #75180 (Implement Error for &(impl Error))\n - #78578 (Permit mutable references in all const contexts)\n - #79174 (Make std::future a re-export of core::future)\n - #79884 (Replace magic numbers with existing constants)\n - #80855 (Expand assert!(expr, args..) to include $crate for hygiene on 2021.)\n - #80933 (Fix sysroot option not being honored across rustc)\n - #81259 (Replace version_check dependency with own version parsing code)\n - #81264 (Add unstable option to control doctest run directory)\n - #81279 (Small refactor in typeck)\n - #81297 (Don't provide backend_optimization_level query for extern crates)\n - #81302 (Fix rendering of stabilization version for trait implementors)\n - #81310 (Do not mark unit variants as used when in path pattern)\n - #81320 (Make bad shlex parsing a pretty error)\n - #81338 (Clean up `dominators_given_rpo`)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "8f0e190a1dd178971317e5cab80cc9ea453d6dd9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8f0e190a1dd178971317e5cab80cc9ea453d6dd9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d3163e96553ae8cb1fca0e62084b124e8b98310b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d3163e96553ae8cb1fca0e62084b124e8b98310b", "html_url": "https://github.com/rust-lang/rust/commit/d3163e96553ae8cb1fca0e62084b124e8b98310b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d3163e96553ae8cb1fca0e62084b124e8b98310b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1d0d76f8dd4f5f6ecbeab575b87edaf1c9f56bb8", "url": "https://api.github.com/repos/rust-lang/rust/commits/1d0d76f8dd4f5f6ecbeab575b87edaf1c9f56bb8", "html_url": "https://github.com/rust-lang/rust/commit/1d0d76f8dd4f5f6ecbeab575b87edaf1c9f56bb8"}, {"sha": "529f15f9b9c5bcd1d2a02e2fa74027a5c5a458de", "url": "https://api.github.com/repos/rust-lang/rust/commits/529f15f9b9c5bcd1d2a02e2fa74027a5c5a458de", "html_url": "https://github.com/rust-lang/rust/commit/529f15f9b9c5bcd1d2a02e2fa74027a5c5a458de"}], "stats": {"total": 1383, "additions": 942, "deletions": 441}, "files": [{"sha": "9d726b240da936163342af04faea8c428e15208c", "filename": "Cargo.lock", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d3163e96553ae8cb1fca0e62084b124e8b98310b/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/d3163e96553ae8cb1fca0e62084b124e8b98310b/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=d3163e96553ae8cb1fca0e62084b124e8b98310b", "patch": "@@ -3568,7 +3568,6 @@ dependencies = [\n  \"rustc_serialize\",\n  \"rustc_session\",\n  \"rustc_span\",\n- \"version_check\",\n ]\n \n [[package]]"}, {"sha": "dc0711a5b0f30d0bef88695991e61d59f4864ea3", "filename": "compiler/rustc_attr/Cargo.toml", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/d3163e96553ae8cb1fca0e62084b124e8b98310b/compiler%2Frustc_attr%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/d3163e96553ae8cb1fca0e62084b124e8b98310b/compiler%2Frustc_attr%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2FCargo.toml?ref=d3163e96553ae8cb1fca0e62084b124e8b98310b", "patch": "@@ -18,4 +18,3 @@ rustc_lexer = { path = \"../rustc_lexer\" }\n rustc_macros = { path = \"../rustc_macros\" }\n rustc_session = { path = \"../rustc_session\" }\n rustc_ast = { path = \"../rustc_ast\" }\n-version_check = \"0.9\""}, {"sha": "26baaf07880f1ff3985253beda4b93b53f2ea288", "filename": "compiler/rustc_attr/src/builtin.rs", "status": "modified", "additions": 28, "deletions": 4, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/d3163e96553ae8cb1fca0e62084b124e8b98310b/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3163e96553ae8cb1fca0e62084b124e8b98310b/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_attr%2Fsrc%2Fbuiltin.rs?ref=d3163e96553ae8cb1fca0e62084b124e8b98310b", "patch": "@@ -10,7 +10,6 @@ use rustc_session::Session;\n use rustc_span::hygiene::Transparency;\n use rustc_span::{symbol::sym, symbol::Symbol, Span};\n use std::num::NonZeroU32;\n-use version_check::Version;\n \n pub fn is_builtin_attr(attr: &Attribute) -> bool {\n     attr.is_doc_comment() || attr.ident().filter(|ident| is_builtin_attr_name(ident.name)).is_some()\n@@ -526,6 +525,26 @@ fn gate_cfg(gated_cfg: &GatedCfg, cfg_span: Span, sess: &ParseSess, features: &F\n     }\n }\n \n+#[derive(Clone, Debug, PartialEq, Eq, PartialOrd, Ord)]\n+struct Version {\n+    major: u16,\n+    minor: u16,\n+    patch: u16,\n+}\n+\n+fn parse_version(s: &str, allow_appendix: bool) -> Option<Version> {\n+    let mut components = s.split('-');\n+    let d = components.next()?;\n+    if !allow_appendix && components.next().is_some() {\n+        return None;\n+    }\n+    let mut digits = d.splitn(3, '.');\n+    let major = digits.next()?.parse().ok()?;\n+    let minor = digits.next()?.parse().ok()?;\n+    let patch = digits.next().unwrap_or(\"0\").parse().ok()?;\n+    Some(Version { major, minor, patch })\n+}\n+\n /// Evaluate a cfg-like condition (with `any` and `all`), using `eval` to\n /// evaluate individual items.\n pub fn eval_condition(\n@@ -555,16 +574,21 @@ pub fn eval_condition(\n                     return false;\n                 }\n             };\n-            let min_version = match Version::parse(&min_version.as_str()) {\n+            let min_version = match parse_version(&min_version.as_str(), false) {\n                 Some(ver) => ver,\n                 None => {\n-                    sess.span_diagnostic.struct_span_err(*span, \"invalid version literal\").emit();\n+                    sess.span_diagnostic\n+                        .struct_span_warn(\n+                            *span,\n+                            \"unknown version literal format, assuming it refers to a future version\",\n+                        )\n+                        .emit();\n                     return false;\n                 }\n             };\n             let channel = env!(\"CFG_RELEASE_CHANNEL\");\n             let nightly = channel == \"nightly\" || channel == \"dev\";\n-            let rustc_version = Version::parse(env!(\"CFG_RELEASE\")).unwrap();\n+            let rustc_version = parse_version(env!(\"CFG_RELEASE\"), true).unwrap();\n \n             // See https://github.com/rust-lang/rust/issues/64796#issuecomment-625474439 for details\n             if nightly { rustc_version > min_version } else { rustc_version >= min_version }"}, {"sha": "f82269c4eee4fba573004d81eed7c67bf82b2ffc", "filename": "compiler/rustc_builtin_macros/src/assert.rs", "status": "modified", "additions": 21, "deletions": 5, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d3163e96553ae8cb1fca0e62084b124e8b98310b/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3163e96553ae8cb1fca0e62084b124e8b98310b/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_builtin_macros%2Fsrc%2Fassert.rs?ref=d3163e96553ae8cb1fca0e62084b124e8b98310b", "patch": "@@ -12,27 +12,43 @@ use rustc_span::{Span, DUMMY_SP};\n \n pub fn expand_assert<'cx>(\n     cx: &'cx mut ExtCtxt<'_>,\n-    sp: Span,\n+    span: Span,\n     tts: TokenStream,\n ) -> Box<dyn MacResult + 'cx> {\n-    let Assert { cond_expr, custom_message } = match parse_assert(cx, sp, tts) {\n+    let Assert { cond_expr, custom_message } = match parse_assert(cx, span, tts) {\n         Ok(assert) => assert,\n         Err(mut err) => {\n             err.emit();\n-            return DummyResult::any(sp);\n+            return DummyResult::any(span);\n         }\n     };\n \n     // `core::panic` and `std::panic` are different macros, so we use call-site\n     // context to pick up whichever is currently in scope.\n-    let sp = cx.with_call_site_ctxt(sp);\n+    let sp = cx.with_call_site_ctxt(span);\n \n     let panic_call = if let Some(tokens) = custom_message {\n+        let path = if span.rust_2021() {\n+            // On edition 2021, we always call `$crate::panic!()`.\n+            Path {\n+                span: sp,\n+                segments: cx\n+                    .std_path(&[sym::panic])\n+                    .into_iter()\n+                    .map(|ident| PathSegment::from_ident(ident))\n+                    .collect(),\n+                tokens: None,\n+            }\n+        } else {\n+            // Before edition 2021, we call `panic!()` unqualified,\n+            // such that it calls either `std::panic!()` or `core::panic!()`.\n+            Path::from_ident(Ident::new(sym::panic, sp))\n+        };\n         // Pass the custom message to panic!().\n         cx.expr(\n             sp,\n             ExprKind::MacCall(MacCall {\n-                path: Path::from_ident(Ident::new(sym::panic, sp)),\n+                path,\n                 args: P(MacArgs::Delimited(\n                     DelimSpan::from_single(sp),\n                     MacDelimiter::Parenthesis,"}, {"sha": "72e049b6d7469ed879c42b3405f19d2021bf9ef1", "filename": "compiler/rustc_codegen_ssa/src/back/link.rs", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d3163e96553ae8cb1fca0e62084b124e8b98310b/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3163e96553ae8cb1fca0e62084b124e8b98310b/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fback%2Flink.rs?ref=d3163e96553ae8cb1fca0e62084b124e8b98310b", "patch": "@@ -885,9 +885,22 @@ fn link_sanitizers(sess: &Session, crate_type: CrateType, linker: &mut dyn Linke\n }\n \n fn link_sanitizer_runtime(sess: &Session, linker: &mut dyn Linker, name: &str) {\n-    let default_sysroot = filesearch::get_or_default_sysroot();\n-    let default_tlib =\n-        filesearch::make_target_lib_path(&default_sysroot, sess.opts.target_triple.triple());\n+    fn find_sanitizer_runtime(sess: &Session, filename: &String) -> PathBuf {\n+        let session_tlib =\n+            filesearch::make_target_lib_path(&sess.sysroot, sess.opts.target_triple.triple());\n+        let path = session_tlib.join(&filename);\n+        if path.exists() {\n+            return session_tlib;\n+        } else {\n+            let default_sysroot = filesearch::get_or_default_sysroot();\n+            let default_tlib = filesearch::make_target_lib_path(\n+                &default_sysroot,\n+                sess.opts.target_triple.triple(),\n+            );\n+            return default_tlib;\n+        }\n+    }\n+\n     let channel = option_env!(\"CFG_RELEASE_CHANNEL\")\n         .map(|channel| format!(\"-{}\", channel))\n         .unwrap_or_default();\n@@ -898,18 +911,19 @@ fn link_sanitizer_runtime(sess: &Session, linker: &mut dyn Linker, name: &str) {\n             // LLVM will link to `@rpath/*.dylib`, so we need to specify an\n             // rpath to the library as well (the rpath should be absolute, see\n             // PR #41352 for details).\n-            let libname = format!(\"rustc{}_rt.{}\", channel, name);\n-            let rpath = default_tlib.to_str().expect(\"non-utf8 component in path\");\n+            let filename = format!(\"rustc{}_rt.{}\", channel, name);\n+            let path = find_sanitizer_runtime(&sess, &filename);\n+            let rpath = path.to_str().expect(\"non-utf8 component in path\");\n             linker.args(&[\"-Wl,-rpath\", \"-Xlinker\", rpath]);\n-            linker.link_dylib(Symbol::intern(&libname));\n+            linker.link_dylib(Symbol::intern(&filename));\n         }\n         \"aarch64-fuchsia\"\n         | \"aarch64-unknown-linux-gnu\"\n         | \"x86_64-fuchsia\"\n         | \"x86_64-unknown-freebsd\"\n         | \"x86_64-unknown-linux-gnu\" => {\n             let filename = format!(\"librustc{}_rt.{}.a\", channel, name);\n-            let path = default_tlib.join(&filename);\n+            let path = find_sanitizer_runtime(&sess, &filename).join(&filename);\n             linker.link_whole_rlib(&path);\n         }\n         _ => {}"}, {"sha": "b205ea9cf6c9d1be8c9ed54c864a165dfe170ff2", "filename": "compiler/rustc_codegen_ssa/src/base.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3163e96553ae8cb1fca0e62084b124e8b98310b/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3163e96553ae8cb1fca0e62084b124e8b98310b/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Fbase.rs?ref=d3163e96553ae8cb1fca0e62084b124e8b98310b", "patch": "@@ -783,7 +783,7 @@ impl CrateInfo {\n     }\n }\n \n-pub fn provide_both(providers: &mut Providers) {\n+pub fn provide(providers: &mut Providers) {\n     providers.backend_optimization_level = |tcx, cratenum| {\n         let for_speed = match tcx.sess.opts.optimize {\n             // If globally no optimisation is done, #[optimize] has no effect."}, {"sha": "0307117e1c8b20e63ec2ce976c5d85eb2bb5d499", "filename": "compiler/rustc_codegen_ssa/src/lib.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d3163e96553ae8cb1fca0e62084b124e8b98310b/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3163e96553ae8cb1fca0e62084b124e8b98310b/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_codegen_ssa%2Fsrc%2Flib.rs?ref=d3163e96553ae8cb1fca0e62084b124e8b98310b", "patch": "@@ -160,13 +160,12 @@ pub struct CodegenResults {\n \n pub fn provide(providers: &mut Providers) {\n     crate::back::symbol_export::provide(providers);\n-    crate::base::provide_both(providers);\n+    crate::base::provide(providers);\n     crate::target_features::provide(providers);\n }\n \n pub fn provide_extern(providers: &mut Providers) {\n     crate::back::symbol_export::provide_extern(providers);\n-    crate::base::provide_both(providers);\n }\n \n /// Checks if the given filename ends with the `.rcgu.o` extension that `rustc`"}, {"sha": "ad62e3c9fc8f4a074ec9110ad450082e3deb12bc", "filename": "compiler/rustc_data_structures/src/graph/dominators/mod.rs", "status": "modified", "additions": 5, "deletions": 11, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d3163e96553ae8cb1fca0e62084b124e8b98310b/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fdominators%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3163e96553ae8cb1fca0e62084b124e8b98310b/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fdominators%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fgraph%2Fdominators%2Fmod.rs?ref=d3163e96553ae8cb1fca0e62084b124e8b98310b", "patch": "@@ -8,7 +8,6 @@\n use super::iterate::reverse_post_order;\n use super::ControlFlowGraph;\n use rustc_index::vec::{Idx, IndexVec};\n-use std::borrow::BorrowMut;\n use std::cmp::Ordering;\n \n #[cfg(test)]\n@@ -20,22 +19,17 @@ pub fn dominators<G: ControlFlowGraph>(graph: G) -> Dominators<G::Node> {\n     dominators_given_rpo(graph, &rpo)\n }\n \n-fn dominators_given_rpo<G: ControlFlowGraph + BorrowMut<G>>(\n-    mut graph: G,\n-    rpo: &[G::Node],\n-) -> Dominators<G::Node> {\n-    let start_node = graph.borrow().start_node();\n+fn dominators_given_rpo<G: ControlFlowGraph>(graph: G, rpo: &[G::Node]) -> Dominators<G::Node> {\n+    let start_node = graph.start_node();\n     assert_eq!(rpo[0], start_node);\n \n     // compute the post order index (rank) for each node\n-    let mut post_order_rank: IndexVec<G::Node, usize> =\n-        (0..graph.borrow().num_nodes()).map(|_| 0).collect();\n+    let mut post_order_rank = IndexVec::from_elem_n(0, graph.num_nodes());\n     for (index, node) in rpo.iter().rev().cloned().enumerate() {\n         post_order_rank[node] = index;\n     }\n \n-    let mut immediate_dominators: IndexVec<G::Node, Option<G::Node>> =\n-        (0..graph.borrow().num_nodes()).map(|_| None).collect();\n+    let mut immediate_dominators = IndexVec::from_elem_n(None, graph.num_nodes());\n     immediate_dominators[start_node] = Some(start_node);\n \n     let mut changed = true;\n@@ -44,7 +38,7 @@ fn dominators_given_rpo<G: ControlFlowGraph + BorrowMut<G>>(\n \n         for &node in &rpo[1..] {\n             let mut new_idom = None;\n-            for pred in graph.borrow_mut().predecessors(node) {\n+            for pred in graph.predecessors(node) {\n                 if immediate_dominators[pred].is_some() {\n                     // (*) dominators for `pred` have been calculated\n                     new_idom = Some(if let Some(new_idom) = new_idom {"}, {"sha": "6f98760a7b0ad39ae47cd8cc75e0985462ed559e", "filename": "compiler/rustc_mir/src/transform/check_consts/ops.rs", "status": "modified", "additions": 44, "deletions": 27, "changes": 71, "blob_url": "https://github.com/rust-lang/rust/blob/d3163e96553ae8cb1fca0e62084b124e8b98310b/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3163e96553ae8cb1fca0e62084b124e8b98310b/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fops.rs?ref=d3163e96553ae8cb1fca0e62084b124e8b98310b", "patch": "@@ -268,16 +268,20 @@ impl NonConstOp for CellBorrow {\n }\n \n #[derive(Debug)]\n+/// This op is for `&mut` borrows in the trailing expression of a constant\n+/// which uses the \"enclosing scopes rule\" to leak its locals into anonymous\n+/// static or const items.\n pub struct MutBorrow(pub hir::BorrowKind);\n \n impl NonConstOp for MutBorrow {\n-    fn status_in_item(&self, ccx: &ConstCx<'_, '_>) -> Status {\n-        // Forbid everywhere except in const fn with a feature gate\n-        if ccx.const_kind() == hir::ConstContext::ConstFn {\n-            Status::Unstable(sym::const_mut_refs)\n-        } else {\n-            Status::Forbidden\n-        }\n+    fn status_in_item(&self, _ccx: &ConstCx<'_, '_>) -> Status {\n+        Status::Forbidden\n+    }\n+\n+    fn importance(&self) -> DiagnosticImportance {\n+        // If there were primary errors (like non-const function calls), do not emit further\n+        // errors about mutable references.\n+        DiagnosticImportance::Secondary\n     }\n \n     fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n@@ -286,25 +290,15 @@ impl NonConstOp for MutBorrow {\n             hir::BorrowKind::Ref => \"\",\n         };\n \n-        let mut err = if ccx.const_kind() == hir::ConstContext::ConstFn {\n-            feature_err(\n-                &ccx.tcx.sess.parse_sess,\n-                sym::const_mut_refs,\n-                span,\n-                &format!(\"{}mutable references are not allowed in {}s\", raw, ccx.const_kind()),\n-            )\n-        } else {\n-            let mut err = struct_span_err!(\n-                ccx.tcx.sess,\n-                span,\n-                E0764,\n-                \"{}mutable references are not allowed in {}s\",\n-                raw,\n-                ccx.const_kind(),\n-            );\n-            err.span_label(span, format!(\"`&{}mut` is only allowed in `const fn`\", raw));\n-            err\n-        };\n+        let mut err = struct_span_err!(\n+            ccx.tcx.sess,\n+            span,\n+            E0764,\n+            \"{}mutable references are not allowed in the final value of {}s\",\n+            raw,\n+            ccx.const_kind(),\n+        );\n+\n         if ccx.tcx.sess.teach(&err.get_code().unwrap()) {\n             err.note(\n                 \"References in statics and constants may only refer \\\n@@ -321,6 +315,29 @@ impl NonConstOp for MutBorrow {\n     }\n }\n \n+#[derive(Debug)]\n+pub struct TransientMutBorrow(pub hir::BorrowKind);\n+\n+impl NonConstOp for TransientMutBorrow {\n+    fn status_in_item(&self, _: &ConstCx<'_, '_>) -> Status {\n+        Status::Unstable(sym::const_mut_refs)\n+    }\n+\n+    fn build_error(&self, ccx: &ConstCx<'_, 'tcx>, span: Span) -> DiagnosticBuilder<'tcx> {\n+        let raw = match self.0 {\n+            hir::BorrowKind::Raw => \"raw \",\n+            hir::BorrowKind::Ref => \"\",\n+        };\n+\n+        feature_err(\n+            &ccx.tcx.sess.parse_sess,\n+            sym::const_mut_refs,\n+            span,\n+            &format!(\"{}mutable references are not allowed in {}s\", raw, ccx.const_kind()),\n+        )\n+    }\n+}\n+\n #[derive(Debug)]\n pub struct MutDeref;\n impl NonConstOp for MutDeref {\n@@ -329,7 +346,7 @@ impl NonConstOp for MutDeref {\n     }\n \n     fn importance(&self) -> DiagnosticImportance {\n-        // Usually a side-effect of a `MutBorrow` somewhere.\n+        // Usually a side-effect of a `TransientMutBorrow` somewhere.\n         DiagnosticImportance::Secondary\n     }\n "}, {"sha": "a92997dddac6aafe9af656a2452d6fa84cd3eebb", "filename": "compiler/rustc_mir/src/transform/check_consts/validation.rs", "status": "modified", "additions": 26, "deletions": 3, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/d3163e96553ae8cb1fca0e62084b124e8b98310b/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3163e96553ae8cb1fca0e62084b124e8b98310b/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=d3163e96553ae8cb1fca0e62084b124e8b98310b", "patch": "@@ -466,6 +466,29 @@ impl Validator<'mir, 'tcx> {\n             }\n         }\n     }\n+\n+    fn check_mut_borrow(&mut self, local: Local, kind: hir::BorrowKind) {\n+        match self.const_kind() {\n+            // In a const fn all borrows are transient or point to the places given via\n+            // references in the arguments (so we already checked them with\n+            // TransientMutBorrow/MutBorrow as appropriate).\n+            // The borrow checker guarantees that no new non-transient borrows are created.\n+            // NOTE: Once we have heap allocations during CTFE we need to figure out\n+            // how to prevent `const fn` to create long-lived allocations that point\n+            // to mutable memory.\n+            hir::ConstContext::ConstFn => self.check_op(ops::TransientMutBorrow(kind)),\n+            _ => {\n+                // Locals with StorageDead do not live beyond the evaluation and can\n+                // thus safely be borrowed without being able to be leaked to the final\n+                // value of the constant.\n+                if self.local_has_storage_dead(local) {\n+                    self.check_op(ops::TransientMutBorrow(kind));\n+                } else {\n+                    self.check_op(ops::MutBorrow(kind));\n+                }\n+            }\n+        }\n+    }\n }\n \n impl Visitor<'tcx> for Validator<'mir, 'tcx> {\n@@ -562,15 +585,15 @@ impl Visitor<'tcx> for Validator<'mir, 'tcx> {\n \n                 if !is_allowed {\n                     if let BorrowKind::Mut { .. } = kind {\n-                        self.check_op(ops::MutBorrow(hir::BorrowKind::Ref));\n+                        self.check_mut_borrow(place.local, hir::BorrowKind::Ref)\n                     } else {\n                         self.check_op(ops::CellBorrow);\n                     }\n                 }\n             }\n \n-            Rvalue::AddressOf(Mutability::Mut, _) => {\n-                self.check_op(ops::MutBorrow(hir::BorrowKind::Raw))\n+            Rvalue::AddressOf(Mutability::Mut, ref place) => {\n+                self.check_mut_borrow(place.local, hir::BorrowKind::Raw)\n             }\n \n             Rvalue::Ref(_, BorrowKind::Shared | BorrowKind::Shallow, ref place)"}, {"sha": "3b1b53553d5e46c30e0235e4f64e20077bfdbf87", "filename": "compiler/rustc_passes/src/dead.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3163e96553ae8cb1fca0e62084b124e8b98310b/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3163e96553ae8cb1fca0e62084b124e8b98310b/compiler%2Frustc_passes%2Fsrc%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_passes%2Fsrc%2Fdead.rs?ref=d3163e96553ae8cb1fca0e62084b124e8b98310b", "patch": "@@ -290,6 +290,7 @@ impl<'tcx> Visitor<'tcx> for MarkSymbolVisitor<'tcx> {\n     }\n \n     fn visit_pat(&mut self, pat: &'tcx hir::Pat<'tcx>) {\n+        self.in_pat = true;\n         match pat.kind {\n             PatKind::Struct(ref path, ref fields, _) => {\n                 let res = self.typeck_results().qpath_res(path, pat.hir_id);\n@@ -302,7 +303,6 @@ impl<'tcx> Visitor<'tcx> for MarkSymbolVisitor<'tcx> {\n             _ => (),\n         }\n \n-        self.in_pat = true;\n         intravisit::walk_pat(self, pat);\n         self.in_pat = false;\n     }"}, {"sha": "47361092a5c50a83dbe48008f73a375b5a9129b0", "filename": "compiler/rustc_typeck/src/check/check.rs", "status": "modified", "additions": 129, "deletions": 113, "changes": 242, "blob_url": "https://github.com/rust-lang/rust/blob/d3163e96553ae8cb1fca0e62084b124e8b98310b/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3163e96553ae8cb1fca0e62084b124e8b98310b/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcheck.rs?ref=d3163e96553ae8cb1fca0e62084b124e8b98310b", "patch": "@@ -846,21 +846,13 @@ pub(super) fn check_specialization_validity<'tcx>(\n         Ok(ancestors) => ancestors,\n         Err(_) => return,\n     };\n-    let mut ancestor_impls = ancestors\n-        .skip(1)\n-        .filter_map(|parent| {\n-            if parent.is_from_trait() {\n-                None\n-            } else {\n-                Some((parent, parent.item(tcx, trait_item.ident, kind, trait_def.def_id)))\n-            }\n-        })\n-        .peekable();\n-\n-    if ancestor_impls.peek().is_none() {\n-        // No parent, nothing to specialize.\n-        return;\n-    }\n+    let mut ancestor_impls = ancestors.skip(1).filter_map(|parent| {\n+        if parent.is_from_trait() {\n+            None\n+        } else {\n+            Some((parent, parent.item(tcx, trait_item.ident, kind, trait_def.def_id)))\n+        }\n+    });\n \n     let opt_result = ancestor_impls.find_map(|(parent_impl, parent_item)| {\n         match parent_item {\n@@ -902,8 +894,6 @@ pub(super) fn check_impl_items_against_trait<'tcx>(\n     impl_trait_ref: ty::TraitRef<'tcx>,\n     impl_item_refs: &[hir::ImplItemRef<'_>],\n ) {\n-    let impl_span = tcx.sess.source_map().guess_head_span(full_impl_span);\n-\n     // If the trait reference itself is erroneous (so the compilation is going\n     // to fail), skip checking the items here -- the `impl_item` table in `tcx`\n     // isn't populated for such impls.\n@@ -931,111 +921,75 @@ pub(super) fn check_impl_items_against_trait<'tcx>(\n \n     // Locate trait definition and items\n     let trait_def = tcx.trait_def(impl_trait_ref.def_id);\n-\n-    let impl_items = || impl_item_refs.iter().map(|iiref| tcx.hir().impl_item(iiref.id));\n+    let impl_items = impl_item_refs.iter().map(|iiref| tcx.hir().impl_item(iiref.id));\n+    let associated_items = tcx.associated_items(impl_trait_ref.def_id);\n \n     // Check existing impl methods to see if they are both present in trait\n     // and compatible with trait signature\n-    for impl_item in impl_items() {\n-        let namespace = impl_item.kind.namespace();\n+    for impl_item in impl_items {\n         let ty_impl_item = tcx.associated_item(tcx.hir().local_def_id(impl_item.hir_id));\n-        let ty_trait_item = tcx\n-            .associated_items(impl_trait_ref.def_id)\n-            .find_by_name_and_namespace(tcx, ty_impl_item.ident, namespace, impl_trait_ref.def_id)\n-            .or_else(|| {\n-                // Not compatible, but needed for the error message\n-                tcx.associated_items(impl_trait_ref.def_id)\n-                    .filter_by_name(tcx, ty_impl_item.ident, impl_trait_ref.def_id)\n-                    .next()\n-            });\n-\n-        // Check that impl definition matches trait definition\n-        if let Some(ty_trait_item) = ty_trait_item {\n+\n+        let mut items =\n+            associated_items.filter_by_name(tcx, ty_impl_item.ident, impl_trait_ref.def_id);\n+\n+        let (compatible_kind, ty_trait_item) = if let Some(ty_trait_item) = items.next() {\n+            let is_compatible = |ty: &&ty::AssocItem| match (ty.kind, &impl_item.kind) {\n+                (ty::AssocKind::Const, hir::ImplItemKind::Const(..)) => true,\n+                (ty::AssocKind::Fn, hir::ImplItemKind::Fn(..)) => true,\n+                (ty::AssocKind::Type, hir::ImplItemKind::TyAlias(..)) => true,\n+                _ => false,\n+            };\n+\n+            // If we don't have a compatible item, we'll use the first one whose name matches\n+            // to report an error.\n+            let mut compatible_kind = is_compatible(&ty_trait_item);\n+            let mut trait_item = ty_trait_item;\n+\n+            if !compatible_kind {\n+                if let Some(ty_trait_item) = items.find(is_compatible) {\n+                    compatible_kind = true;\n+                    trait_item = ty_trait_item;\n+                }\n+            }\n+\n+            (compatible_kind, trait_item)\n+        } else {\n+            continue;\n+        };\n+\n+        if compatible_kind {\n             match impl_item.kind {\n                 hir::ImplItemKind::Const(..) => {\n                     // Find associated const definition.\n-                    if ty_trait_item.kind == ty::AssocKind::Const {\n-                        compare_const_impl(\n-                            tcx,\n-                            &ty_impl_item,\n-                            impl_item.span,\n-                            &ty_trait_item,\n-                            impl_trait_ref,\n-                        );\n-                    } else {\n-                        let mut err = struct_span_err!(\n-                            tcx.sess,\n-                            impl_item.span,\n-                            E0323,\n-                            \"item `{}` is an associated const, \\\n-                             which doesn't match its trait `{}`\",\n-                            ty_impl_item.ident,\n-                            impl_trait_ref.print_only_trait_path()\n-                        );\n-                        err.span_label(impl_item.span, \"does not match trait\");\n-                        // We can only get the spans from local trait definition\n-                        // Same for E0324 and E0325\n-                        if let Some(trait_span) = tcx.hir().span_if_local(ty_trait_item.def_id) {\n-                            err.span_label(trait_span, \"item in trait\");\n-                        }\n-                        err.emit()\n-                    }\n+                    compare_const_impl(\n+                        tcx,\n+                        &ty_impl_item,\n+                        impl_item.span,\n+                        &ty_trait_item,\n+                        impl_trait_ref,\n+                    );\n                 }\n                 hir::ImplItemKind::Fn(..) => {\n                     let opt_trait_span = tcx.hir().span_if_local(ty_trait_item.def_id);\n-                    if ty_trait_item.kind == ty::AssocKind::Fn {\n-                        compare_impl_method(\n-                            tcx,\n-                            &ty_impl_item,\n-                            impl_item.span,\n-                            &ty_trait_item,\n-                            impl_trait_ref,\n-                            opt_trait_span,\n-                        );\n-                    } else {\n-                        let mut err = struct_span_err!(\n-                            tcx.sess,\n-                            impl_item.span,\n-                            E0324,\n-                            \"item `{}` is an associated method, \\\n-                             which doesn't match its trait `{}`\",\n-                            ty_impl_item.ident,\n-                            impl_trait_ref.print_only_trait_path()\n-                        );\n-                        err.span_label(impl_item.span, \"does not match trait\");\n-                        if let Some(trait_span) = opt_trait_span {\n-                            err.span_label(trait_span, \"item in trait\");\n-                        }\n-                        err.emit()\n-                    }\n+                    compare_impl_method(\n+                        tcx,\n+                        &ty_impl_item,\n+                        impl_item.span,\n+                        &ty_trait_item,\n+                        impl_trait_ref,\n+                        opt_trait_span,\n+                    );\n                 }\n                 hir::ImplItemKind::TyAlias(_) => {\n                     let opt_trait_span = tcx.hir().span_if_local(ty_trait_item.def_id);\n-                    if ty_trait_item.kind == ty::AssocKind::Type {\n-                        compare_ty_impl(\n-                            tcx,\n-                            &ty_impl_item,\n-                            impl_item.span,\n-                            &ty_trait_item,\n-                            impl_trait_ref,\n-                            opt_trait_span,\n-                        );\n-                    } else {\n-                        let mut err = struct_span_err!(\n-                            tcx.sess,\n-                            impl_item.span,\n-                            E0325,\n-                            \"item `{}` is an associated type, \\\n-                             which doesn't match its trait `{}`\",\n-                            ty_impl_item.ident,\n-                            impl_trait_ref.print_only_trait_path()\n-                        );\n-                        err.span_label(impl_item.span, \"does not match trait\");\n-                        if let Some(trait_span) = opt_trait_span {\n-                            err.span_label(trait_span, \"item in trait\");\n-                        }\n-                        err.emit()\n-                    }\n+                    compare_ty_impl(\n+                        tcx,\n+                        &ty_impl_item,\n+                        impl_item.span,\n+                        &ty_trait_item,\n+                        impl_trait_ref,\n+                        opt_trait_span,\n+                    );\n                 }\n             }\n \n@@ -1046,12 +1000,22 @@ pub(super) fn check_impl_items_against_trait<'tcx>(\n                 impl_id.to_def_id(),\n                 impl_item,\n             );\n+        } else {\n+            report_mismatch_error(\n+                tcx,\n+                ty_trait_item.def_id,\n+                impl_trait_ref,\n+                impl_item,\n+                &ty_impl_item,\n+            );\n         }\n     }\n \n-    // Check for missing items from trait\n-    let mut missing_items = Vec::new();\n     if let Ok(ancestors) = trait_def.ancestors(tcx, impl_id.to_def_id()) {\n+        let impl_span = tcx.sess.source_map().guess_head_span(full_impl_span);\n+\n+        // Check for missing items from trait\n+        let mut missing_items = Vec::new();\n         for trait_item in tcx.associated_items(impl_trait_ref.def_id).in_definition_order() {\n             let is_implemented = ancestors\n                 .leaf_def(tcx, trait_item.ident, trait_item.kind)\n@@ -1064,11 +1028,63 @@ pub(super) fn check_impl_items_against_trait<'tcx>(\n                 }\n             }\n         }\n+\n+        if !missing_items.is_empty() {\n+            missing_items_err(tcx, impl_span, &missing_items, full_impl_span);\n+        }\n     }\n+}\n+\n+#[inline(never)]\n+#[cold]\n+fn report_mismatch_error<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    trait_item_def_id: DefId,\n+    impl_trait_ref: ty::TraitRef<'tcx>,\n+    impl_item: &hir::ImplItem<'_>,\n+    ty_impl_item: &ty::AssocItem,\n+) {\n+    let mut err = match impl_item.kind {\n+        hir::ImplItemKind::Const(..) => {\n+            // Find associated const definition.\n+            struct_span_err!(\n+                tcx.sess,\n+                impl_item.span,\n+                E0323,\n+                \"item `{}` is an associated const, which doesn't match its trait `{}`\",\n+                ty_impl_item.ident,\n+                impl_trait_ref.print_only_trait_path()\n+            )\n+        }\n+\n+        hir::ImplItemKind::Fn(..) => {\n+            struct_span_err!(\n+                tcx.sess,\n+                impl_item.span,\n+                E0324,\n+                \"item `{}` is an associated method, which doesn't match its trait `{}`\",\n+                ty_impl_item.ident,\n+                impl_trait_ref.print_only_trait_path()\n+            )\n+        }\n \n-    if !missing_items.is_empty() {\n-        missing_items_err(tcx, impl_span, &missing_items, full_impl_span);\n+        hir::ImplItemKind::TyAlias(_) => {\n+            struct_span_err!(\n+                tcx.sess,\n+                impl_item.span,\n+                E0325,\n+                \"item `{}` is an associated type, which doesn't match its trait `{}`\",\n+                ty_impl_item.ident,\n+                impl_trait_ref.print_only_trait_path()\n+            )\n+        }\n+    };\n+\n+    err.span_label(impl_item.span, \"does not match trait\");\n+    if let Some(trait_span) = tcx.hir().span_if_local(trait_item_def_id) {\n+        err.span_label(trait_span, \"item in trait\");\n     }\n+    err.emit();\n }\n \n /// Checks whether a type can be represented in memory. In particular, it"}, {"sha": "b1443bc33d2ffe8b7e97a351be0584584a592480", "filename": "library/core/src/time.rs", "status": "modified", "additions": 15, "deletions": 5, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d3163e96553ae8cb1fca0e62084b124e8b98310b/library%2Fcore%2Fsrc%2Ftime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3163e96553ae8cb1fca0e62084b124e8b98310b/library%2Fcore%2Fsrc%2Ftime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Ftime.rs?ref=d3163e96553ae8cb1fca0e62084b124e8b98310b", "patch": "@@ -1067,13 +1067,23 @@ impl fmt::Debug for Duration {\n         }\n \n         if self.secs > 0 {\n-            fmt_decimal(f, self.secs, self.nanos, 100_000_000)?;\n+            fmt_decimal(f, self.secs, self.nanos, NANOS_PER_SEC / 10)?;\n             f.write_str(\"s\")\n-        } else if self.nanos >= 1_000_000 {\n-            fmt_decimal(f, self.nanos as u64 / 1_000_000, self.nanos % 1_000_000, 100_000)?;\n+        } else if self.nanos >= NANOS_PER_MILLI {\n+            fmt_decimal(\n+                f,\n+                (self.nanos / NANOS_PER_MILLI) as u64,\n+                self.nanos % NANOS_PER_MILLI,\n+                NANOS_PER_MILLI / 10,\n+            )?;\n             f.write_str(\"ms\")\n-        } else if self.nanos >= 1_000 {\n-            fmt_decimal(f, self.nanos as u64 / 1_000, self.nanos % 1_000, 100)?;\n+        } else if self.nanos >= NANOS_PER_MICRO {\n+            fmt_decimal(\n+                f,\n+                (self.nanos / NANOS_PER_MICRO) as u64,\n+                self.nanos % NANOS_PER_MICRO,\n+                NANOS_PER_MICRO / 10,\n+            )?;\n             f.write_str(\"\u00b5s\")\n         } else {\n             fmt_decimal(f, self.nanos as u64, 0, 1)?;"}, {"sha": "605d953f5da7130add600f95f886b3de1c0675a1", "filename": "library/std/src/error.rs", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d3163e96553ae8cb1fca0e62084b124e8b98310b/library%2Fstd%2Fsrc%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3163e96553ae8cb1fca0e62084b124e8b98310b/library%2Fstd%2Fsrc%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ferror.rs?ref=d3163e96553ae8cb1fca0e62084b124e8b98310b", "patch": "@@ -486,6 +486,27 @@ impl<T: Error> Error for Box<T> {\n     }\n }\n \n+#[stable(feature = \"error_by_ref\", since = \"1.51.0\")]\n+impl<'a, T: Error + ?Sized> Error for &'a T {\n+    #[allow(deprecated, deprecated_in_future)]\n+    fn description(&self) -> &str {\n+        Error::description(&**self)\n+    }\n+\n+    #[allow(deprecated)]\n+    fn cause(&self) -> Option<&dyn Error> {\n+        Error::cause(&**self)\n+    }\n+\n+    fn source(&self) -> Option<&(dyn Error + 'static)> {\n+        Error::source(&**self)\n+    }\n+\n+    fn backtrace(&self) -> Option<&Backtrace> {\n+        Error::backtrace(&**self)\n+    }\n+}\n+\n #[stable(feature = \"fmt_error\", since = \"1.11.0\")]\n impl Error for fmt::Error {\n     #[allow(deprecated)]"}, {"sha": "9d9c36e9afb0f8a06772742207e730addaace5fd", "filename": "library/std/src/future.rs", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/1d0d76f8dd4f5f6ecbeab575b87edaf1c9f56bb8/library%2Fstd%2Fsrc%2Ffuture.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d0d76f8dd4f5f6ecbeab575b87edaf1c9f56bb8/library%2Fstd%2Fsrc%2Ffuture.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ffuture.rs?ref=1d0d76f8dd4f5f6ecbeab575b87edaf1c9f56bb8", "patch": "@@ -1,17 +0,0 @@\n-//! Asynchronous values.\n-\n-#[doc(inline)]\n-#[stable(feature = \"futures_api\", since = \"1.36.0\")]\n-pub use core::future::Future;\n-\n-#[doc(inline)]\n-#[unstable(feature = \"gen_future\", issue = \"50547\")]\n-pub use core::future::{from_generator, get_context, ResumeTy};\n-\n-#[doc(inline)]\n-#[stable(feature = \"future_readiness_fns\", since = \"1.48.0\")]\n-pub use core::future::{pending, ready, Pending, Ready};\n-\n-#[doc(inline)]\n-#[unstable(feature = \"into_future\", issue = \"67644\")]\n-pub use core::future::IntoFuture;"}, {"sha": "92c8b7c1774772a5361c1f33d6c095b5a0aa29e6", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d3163e96553ae8cb1fca0e62084b124e8b98310b/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3163e96553ae8cb1fca0e62084b124e8b98310b/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=d3163e96553ae8cb1fca0e62084b124e8b98310b", "patch": "@@ -406,6 +406,8 @@ pub use core::cmp;\n pub use core::convert;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::default;\n+#[stable(feature = \"futures_api\", since = \"1.36.0\")]\n+pub use core::future;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::hash;\n #[stable(feature = \"core_hint\", since = \"1.27.0\")]\n@@ -505,9 +507,6 @@ pub mod task {\n     pub use alloc::task::*;\n }\n \n-#[stable(feature = \"futures_api\", since = \"1.36.0\")]\n-pub mod future;\n-\n // Platform-abstraction modules\n #[macro_use]\n mod sys_common;"}, {"sha": "fee1bf4c3a6a709aa4b1836c3f4425ebeac0c449", "filename": "src/librustdoc/config.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/d3163e96553ae8cb1fca0e62084b124e8b98310b/src%2Flibrustdoc%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3163e96553ae8cb1fca0e62084b124e8b98310b/src%2Flibrustdoc%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fconfig.rs?ref=d3163e96553ae8cb1fca0e62084b124e8b98310b", "patch": "@@ -103,6 +103,8 @@ crate struct Options {\n     crate should_test: bool,\n     /// List of arguments to pass to the test harness, if running tests.\n     crate test_args: Vec<String>,\n+    /// The working directory in which to run tests.\n+    crate test_run_directory: Option<PathBuf>,\n     /// Optional path to persist the doctest executables to, defaults to a\n     /// temporary directory if not set.\n     crate persist_doctests: Option<PathBuf>,\n@@ -175,6 +177,7 @@ impl fmt::Debug for Options {\n             .field(\"lint_cap\", &self.lint_cap)\n             .field(\"should_test\", &self.should_test)\n             .field(\"test_args\", &self.test_args)\n+            .field(\"test_run_directory\", &self.test_run_directory)\n             .field(\"persist_doctests\", &self.persist_doctests)\n             .field(\"default_passes\", &self.default_passes)\n             .field(\"manual_passes\", &self.manual_passes)\n@@ -572,6 +575,7 @@ impl Options {\n         let enable_index_page = matches.opt_present(\"enable-index-page\") || index_page.is_some();\n         let static_root_path = matches.opt_str(\"static-root-path\");\n         let generate_search_filter = !matches.opt_present(\"disable-per-crate-search\");\n+        let test_run_directory = matches.opt_str(\"test-run-directory\").map(PathBuf::from);\n         let persist_doctests = matches.opt_str(\"persist-doctests\").map(PathBuf::from);\n         let test_builder = matches.opt_str(\"test-builder\").map(PathBuf::from);\n         let codegen_options_strs = matches.opt_strs(\"C\");\n@@ -613,6 +617,7 @@ impl Options {\n             display_warnings,\n             show_coverage,\n             crate_version,\n+            test_run_directory,\n             persist_doctests,\n             runtool,\n             runtool_args,"}, {"sha": "30ff124dac60fb754e3a74d1b23047e3a924de95", "filename": "src/librustdoc/doctest.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d3163e96553ae8cb1fca0e62084b124e8b98310b/src%2Flibrustdoc%2Fdoctest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3163e96553ae8cb1fca0e62084b124e8b98310b/src%2Flibrustdoc%2Fdoctest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctest.rs?ref=d3163e96553ae8cb1fca0e62084b124e8b98310b", "patch": "@@ -365,6 +365,9 @@ fn run_test(\n     } else {\n         cmd = Command::new(output_file);\n     }\n+    if let Some(run_directory) = options.test_run_directory {\n+        cmd.current_dir(run_directory);\n+    }\n \n     match cmd.output() {\n         Err(e) => return Err(TestFailure::ExecutionError(e)),"}, {"sha": "ef45c98e406291d18d00595dec06a70bcaac34d9", "filename": "src/librustdoc/html/render/mod.rs", "status": "modified", "additions": 21, "deletions": 30, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/d3163e96553ae8cb1fca0e62084b124e8b98310b/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3163e96553ae8cb1fca0e62084b124e8b98310b/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fmod.rs?ref=d3163e96553ae8cb1fca0e62084b124e8b98310b", "patch": "@@ -2474,7 +2474,7 @@ fn item_function(w: &mut Buffer, cx: &Context<'_>, it: &clean::Item, f: &clean::\n fn render_implementor(\n     cx: &Context<'_>,\n     implementor: &Impl,\n-    parent: &clean::Item,\n+    trait_: &clean::Item,\n     w: &mut Buffer,\n     implementor_dups: &FxHashMap<Symbol, (DefId, bool)>,\n     aliases: &[String],\n@@ -2494,11 +2494,11 @@ fn render_implementor(\n         w,\n         cx,\n         implementor,\n-        parent,\n+        trait_,\n         AssocItemLink::Anchor(None),\n         RenderMode::Normal,\n-        implementor.impl_item.stable_since(cx.tcx()).as_deref(),\n-        implementor.impl_item.const_stable_since(cx.tcx()).as_deref(),\n+        trait_.stable_since(cx.tcx()).as_deref(),\n+        trait_.const_stable_since(cx.tcx()).as_deref(),\n         false,\n         Some(use_absolute),\n         false,\n@@ -2937,34 +2937,25 @@ fn render_stability_since_raw(\n     containing_ver: Option<&str>,\n     containing_const_ver: Option<&str>,\n ) {\n-    let ver = ver.and_then(|inner| if !inner.is_empty() { Some(inner) } else { None });\n-\n-    let const_ver = const_ver.and_then(|inner| if !inner.is_empty() { Some(inner) } else { None });\n+    let ver = ver.filter(|inner| !inner.is_empty());\n+    let const_ver = const_ver.filter(|inner| !inner.is_empty());\n \n-    if let Some(v) = ver {\n-        if let Some(cv) = const_ver {\n-            if const_ver != containing_const_ver {\n-                write!(\n-                    w,\n-                    \"<span class=\\\"since\\\" title=\\\"Stable since Rust version {0}, const since {1}\\\">{0} (const: {1})</span>\",\n-                    v, cv\n-                );\n-            } else if ver != containing_ver {\n-                write!(\n-                    w,\n-                    \"<span class=\\\"since\\\" title=\\\"Stable since Rust version {0}\\\">{0}</span>\",\n-                    v\n-                );\n-            }\n-        } else {\n-            if ver != containing_ver {\n-                write!(\n-                    w,\n-                    \"<span class=\\\"since\\\" title=\\\"Stable since Rust version {0}\\\">{0}</span>\",\n-                    v\n-                );\n-            }\n+    match (ver, const_ver) {\n+        (Some(v), Some(cv)) if const_ver != containing_const_ver => {\n+            write!(\n+                w,\n+                \"<span class=\\\"since\\\" title=\\\"Stable since Rust version {0}, const since {1}\\\">{0} (const: {1})</span>\",\n+                v, cv\n+            );\n+        }\n+        (Some(v), _) if ver != containing_ver => {\n+            write!(\n+                w,\n+                \"<span class=\\\"since\\\" title=\\\"Stable since Rust version {0}\\\">{0}</span>\",\n+                v\n+            );\n         }\n+        _ => {}\n     }\n }\n "}, {"sha": "c61cbf78f771a2909d3ae5b39ebb56e6e3c9d516", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d3163e96553ae8cb1fca0e62084b124e8b98310b/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3163e96553ae8cb1fca0e62084b124e8b98310b/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=d3163e96553ae8cb1fca0e62084b124e8b98310b", "patch": "@@ -168,6 +168,14 @@ fn opts() -> Vec<RustcOptGroup> {\n         stable(\"test-args\", |o| {\n             o.optmulti(\"\", \"test-args\", \"arguments to pass to the test runner\", \"ARGS\")\n         }),\n+        unstable(\"test-run-directory\", |o| {\n+            o.optopt(\n+                \"\",\n+                \"test-run-directory\",\n+                \"The working directory in which to run tests\",\n+                \"PATH\",\n+            )\n+        }),\n         stable(\"target\", |o| o.optopt(\"\", \"target\", \"target triple to document\", \"TRIPLE\")),\n         stable(\"markdown-css\", |o| {\n             o.optmulti("}, {"sha": "e9b2754794a78c10ebb0536c2bc8db28c0f42858", "filename": "src/test/rustdoc-ui/run-directory.correct.stdout", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d3163e96553ae8cb1fca0e62084b124e8b98310b/src%2Ftest%2Frustdoc-ui%2Frun-directory.correct.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/d3163e96553ae8cb1fca0e62084b124e8b98310b/src%2Ftest%2Frustdoc-ui%2Frun-directory.correct.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Frun-directory.correct.stdout?ref=d3163e96553ae8cb1fca0e62084b124e8b98310b", "patch": "@@ -0,0 +1,6 @@\n+\n+running 1 test\n+test $DIR/run-directory.rs - foo (line 10) ... ok\n+\n+test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in $TIME\n+"}, {"sha": "97a5dbc5c0cd19112a8b6c02652880f568ca197f", "filename": "src/test/rustdoc-ui/run-directory.incorrect.stdout", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d3163e96553ae8cb1fca0e62084b124e8b98310b/src%2Ftest%2Frustdoc-ui%2Frun-directory.incorrect.stdout", "raw_url": "https://github.com/rust-lang/rust/raw/d3163e96553ae8cb1fca0e62084b124e8b98310b/src%2Ftest%2Frustdoc-ui%2Frun-directory.incorrect.stdout", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Frun-directory.incorrect.stdout?ref=d3163e96553ae8cb1fca0e62084b124e8b98310b", "patch": "@@ -0,0 +1,6 @@\n+\n+running 1 test\n+test $DIR/run-directory.rs - foo (line 19) ... ok\n+\n+test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in $TIME\n+"}, {"sha": "78431c0e80b59137fe389d68a1454f367f865459", "filename": "src/test/rustdoc-ui/run-directory.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d3163e96553ae8cb1fca0e62084b124e8b98310b/src%2Ftest%2Frustdoc-ui%2Frun-directory.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3163e96553ae8cb1fca0e62084b124e8b98310b/src%2Ftest%2Frustdoc-ui%2Frun-directory.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Frun-directory.rs?ref=d3163e96553ae8cb1fca0e62084b124e8b98310b", "patch": "@@ -0,0 +1,23 @@\n+// this test asserts that the cwd of doctest invocations is set correctly.\n+\n+// revisions: correct incorrect\n+// check-pass\n+// [correct]compile-flags:--test --test-run-directory={{src-base}}\n+// [incorrect]compile-flags:--test --test-run-directory={{src-base}}/coverage\n+// normalize-stdout-test: \"src/test/rustdoc-ui\" -> \"$$DIR\"\n+// normalize-stdout-test \"finished in \\d+\\.\\d+s\" -> \"finished in $$TIME\"\n+\n+/// ```\n+/// assert_eq!(\n+///     std::fs::read_to_string(\"run-directory.rs\").unwrap(),\n+///     include_str!(\"run-directory.rs\"),\n+/// );\n+/// ```\n+#[cfg(correct)]\n+pub fn foo() {}\n+\n+/// ```\n+/// assert!(std::fs::read_to_string(\"run-directory.rs\").is_err());\n+/// ```\n+#[cfg(incorrect)]\n+pub fn foo() {}"}, {"sha": "0a065d8095bf238a11538909a8b5b653221d97b4", "filename": "src/test/rustdoc/implementor-stable-version.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/d3163e96553ae8cb1fca0e62084b124e8b98310b/src%2Ftest%2Frustdoc%2Fimplementor-stable-version.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3163e96553ae8cb1fca0e62084b124e8b98310b/src%2Ftest%2Frustdoc%2Fimplementor-stable-version.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fimplementor-stable-version.rs?ref=d3163e96553ae8cb1fca0e62084b124e8b98310b", "patch": "@@ -0,0 +1,19 @@\n+#![crate_name = \"foo\"]\n+\n+#![feature(staged_api)]\n+\n+#[stable(feature = \"bar\", since = \"OLD 1.0\")]\n+pub trait Bar {}\n+\n+#[stable(feature = \"baz\", since = \"OLD 1.0\")]\n+pub trait Baz {}\n+\n+pub struct Foo;\n+\n+// @has foo/trait.Bar.html '//div[@id=\"implementors-list\"]//span[@class=\"since\"]' 'NEW 2.0'\n+#[stable(feature = \"foobar\", since = \"NEW 2.0\")]\n+impl Bar for Foo {}\n+\n+// @!has foo/trait.Baz.html '//div[@id=\"implementors-list\"]//span[@class=\"since\"]' 'OLD 1.0'\n+#[stable(feature = \"foobaz\", since = \"OLD 1.0\")]\n+impl Baz for Foo {}"}, {"sha": "8f9680778aa03d766e5f87f69798a9cb0a78c797", "filename": "src/test/ui/check-static-immutable-mut-slices.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3163e96553ae8cb1fca0e62084b124e8b98310b/src%2Ftest%2Fui%2Fcheck-static-immutable-mut-slices.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3163e96553ae8cb1fca0e62084b124e8b98310b/src%2Ftest%2Fui%2Fcheck-static-immutable-mut-slices.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcheck-static-immutable-mut-slices.rs?ref=d3163e96553ae8cb1fca0e62084b124e8b98310b", "patch": "@@ -1,6 +1,6 @@\n // Checks that immutable static items can't have mutable slices\n \n static TEST: &'static mut [isize] = &mut [];\n-//~^ ERROR mutable references are not allowed in statics\n+//~^ ERROR mutable references are not allowed\n \n pub fn main() { }"}, {"sha": "a32a94c1315ab01446fffdf56781a17b112dbd73", "filename": "src/test/ui/check-static-immutable-mut-slices.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d3163e96553ae8cb1fca0e62084b124e8b98310b/src%2Ftest%2Fui%2Fcheck-static-immutable-mut-slices.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d3163e96553ae8cb1fca0e62084b124e8b98310b/src%2Ftest%2Fui%2Fcheck-static-immutable-mut-slices.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcheck-static-immutable-mut-slices.stderr?ref=d3163e96553ae8cb1fca0e62084b124e8b98310b", "patch": "@@ -1,8 +1,8 @@\n-error[E0764]: mutable references are not allowed in statics\n+error[E0764]: mutable references are not allowed in the final value of statics\n   --> $DIR/check-static-immutable-mut-slices.rs:3:37\n    |\n LL | static TEST: &'static mut [isize] = &mut [];\n-   |                                     ^^^^^^^ `&mut` is only allowed in `const fn`\n+   |                                     ^^^^^^^\n \n error: aborting due to previous error\n "}, {"sha": "60cdcc7df7449b2bf4f19027793bce91ad7f68dc", "filename": "src/test/ui/consts/const-address-of-mut.stderr", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/d3163e96553ae8cb1fca0e62084b124e8b98310b/src%2Ftest%2Fui%2Fconsts%2Fconst-address-of-mut.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d3163e96553ae8cb1fca0e62084b124e8b98310b/src%2Ftest%2Fui%2Fconsts%2Fconst-address-of-mut.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-address-of-mut.stderr?ref=d3163e96553ae8cb1fca0e62084b124e8b98310b", "patch": "@@ -1,20 +1,29 @@\n-error[E0764]: raw mutable references are not allowed in constants\n+error[E0658]: raw mutable references are not allowed in constants\n   --> $DIR/const-address-of-mut.rs:3:32\n    |\n LL | const A: () = { let mut x = 2; &raw mut x; };\n-   |                                ^^^^^^^^^^ `&raw mut` is only allowed in `const fn`\n+   |                                ^^^^^^^^^^\n+   |\n+   = note: see issue #57349 <https://github.com/rust-lang/rust/issues/57349> for more information\n+   = help: add `#![feature(const_mut_refs)]` to the crate attributes to enable\n \n-error[E0764]: raw mutable references are not allowed in statics\n+error[E0658]: raw mutable references are not allowed in statics\n   --> $DIR/const-address-of-mut.rs:5:33\n    |\n LL | static B: () = { let mut x = 2; &raw mut x; };\n-   |                                 ^^^^^^^^^^ `&raw mut` is only allowed in `const fn`\n+   |                                 ^^^^^^^^^^\n+   |\n+   = note: see issue #57349 <https://github.com/rust-lang/rust/issues/57349> for more information\n+   = help: add `#![feature(const_mut_refs)]` to the crate attributes to enable\n \n-error[E0764]: raw mutable references are not allowed in statics\n+error[E0658]: raw mutable references are not allowed in statics\n   --> $DIR/const-address-of-mut.rs:7:37\n    |\n LL | static mut C: () = { let mut x = 2; &raw mut x; };\n-   |                                     ^^^^^^^^^^ `&raw mut` is only allowed in `const fn`\n+   |                                     ^^^^^^^^^^\n+   |\n+   = note: see issue #57349 <https://github.com/rust-lang/rust/issues/57349> for more information\n+   = help: add `#![feature(const_mut_refs)]` to the crate attributes to enable\n \n error[E0658]: raw mutable references are not allowed in constant functions\n   --> $DIR/const-address-of-mut.rs:11:13\n@@ -27,5 +36,4 @@ LL |     let y = &raw mut x;\n \n error: aborting due to 4 previous errors\n \n-Some errors have detailed explanations: E0658, E0764.\n-For more information about an error, try `rustc --explain E0658`.\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "ec229d7f53a0fcb0257709bf2dd559ce5fbf1758", "filename": "src/test/ui/consts/const-eval/issue-65394.stderr", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d3163e96553ae8cb1fca0e62084b124e8b98310b/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-65394.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d3163e96553ae8cb1fca0e62084b124e8b98310b/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-65394.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-eval%2Fissue-65394.stderr?ref=d3163e96553ae8cb1fca0e62084b124e8b98310b", "patch": "@@ -1,8 +1,11 @@\n-error[E0764]: mutable references are not allowed in constants\n+error[E0658]: mutable references are not allowed in constants\n   --> $DIR/issue-65394.rs:8:13\n    |\n LL |     let r = &mut x;\n-   |             ^^^^^^ `&mut` is only allowed in `const fn`\n+   |             ^^^^^^\n+   |\n+   = note: see issue #57349 <https://github.com/rust-lang/rust/issues/57349> for more information\n+   = help: add `#![feature(const_mut_refs)]` to the crate attributes to enable\n \n error[E0493]: destructors cannot be evaluated at compile-time\n   --> $DIR/issue-65394.rs:7:9\n@@ -15,5 +18,5 @@ LL | };\n \n error: aborting due to 2 previous errors\n \n-Some errors have detailed explanations: E0493, E0764.\n+Some errors have detailed explanations: E0493, E0658.\n For more information about an error, try `rustc --explain E0493`."}, {"sha": "dd5cadfe2951ec0e2bdf6c58c3058dcd9465c6af", "filename": "src/test/ui/consts/const-multi-ref.stderr", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/d3163e96553ae8cb1fca0e62084b124e8b98310b/src%2Ftest%2Fui%2Fconsts%2Fconst-multi-ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d3163e96553ae8cb1fca0e62084b124e8b98310b/src%2Ftest%2Fui%2Fconsts%2Fconst-multi-ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-multi-ref.stderr?ref=d3163e96553ae8cb1fca0e62084b124e8b98310b", "patch": "@@ -1,8 +1,11 @@\n-error[E0764]: mutable references are not allowed in constants\n+error[E0658]: mutable references are not allowed in constants\n   --> $DIR/const-multi-ref.rs:6:13\n    |\n LL |     let p = &mut a;\n-   |             ^^^^^^ `&mut` is only allowed in `const fn`\n+   |             ^^^^^^\n+   |\n+   = note: see issue #57349 <https://github.com/rust-lang/rust/issues/57349> for more information\n+   = help: add `#![feature(const_mut_refs)]` to the crate attributes to enable\n \n error[E0658]: cannot borrow here, since the borrowed element may contain interior mutability\n   --> $DIR/const-multi-ref.rs:16:13\n@@ -15,5 +18,4 @@ LL |     let p = &a;\n \n error: aborting due to 2 previous errors\n \n-Some errors have detailed explanations: E0658, E0764.\n-For more information about an error, try `rustc --explain E0658`.\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "24df647f05b7ee158838f61b4c3f6f377762c436", "filename": "src/test/ui/consts/const-mut-refs/const_mut_address_of.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d3163e96553ae8cb1fca0e62084b124e8b98310b/src%2Ftest%2Fui%2Fconsts%2Fconst-mut-refs%2Fconst_mut_address_of.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3163e96553ae8cb1fca0e62084b124e8b98310b/src%2Ftest%2Fui%2Fconsts%2Fconst-mut-refs%2Fconst_mut_address_of.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-mut-refs%2Fconst_mut_address_of.rs?ref=d3163e96553ae8cb1fca0e62084b124e8b98310b", "patch": "@@ -1,3 +1,4 @@\n+// check-pass\n #![feature(const_mut_refs)]\n #![feature(const_fn)]\n #![feature(raw_ref_op)]\n@@ -22,9 +23,7 @@ const fn baz(foo: &mut Foo)-> *mut usize {\n \n const _: () = {\n     foo().bar();\n-    //~^ ERROR mutable references are not allowed in constants\n     baz(&mut foo());\n-    //~^ ERROR mutable references are not allowed in constants\n };\n \n fn main() {}"}, {"sha": "2214ce6ee1c8768fafd979f9f2f1bbe6fb483a35", "filename": "src/test/ui/consts/const-mut-refs/const_mut_address_of.stderr", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/1d0d76f8dd4f5f6ecbeab575b87edaf1c9f56bb8/src%2Ftest%2Fui%2Fconsts%2Fconst-mut-refs%2Fconst_mut_address_of.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1d0d76f8dd4f5f6ecbeab575b87edaf1c9f56bb8/src%2Ftest%2Fui%2Fconsts%2Fconst-mut-refs%2Fconst_mut_address_of.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-mut-refs%2Fconst_mut_address_of.stderr?ref=1d0d76f8dd4f5f6ecbeab575b87edaf1c9f56bb8", "patch": "@@ -1,15 +0,0 @@\n-error[E0764]: mutable references are not allowed in constants\n-  --> $DIR/const_mut_address_of.rs:24:5\n-   |\n-LL |     foo().bar();\n-   |     ^^^^^ `&mut` is only allowed in `const fn`\n-\n-error[E0764]: mutable references are not allowed in constants\n-  --> $DIR/const_mut_address_of.rs:26:9\n-   |\n-LL |     baz(&mut foo());\n-   |         ^^^^^^^^^^ `&mut` is only allowed in `const fn`\n-\n-error: aborting due to 2 previous errors\n-\n-For more information about this error, try `rustc --explain E0764`."}, {"sha": "544458dfcd8bbd30ca7127348341ccc6b8e1429a", "filename": "src/test/ui/consts/const-mut-refs/const_mut_refs.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d3163e96553ae8cb1fca0e62084b124e8b98310b/src%2Ftest%2Fui%2Fconsts%2Fconst-mut-refs%2Fconst_mut_refs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3163e96553ae8cb1fca0e62084b124e8b98310b/src%2Ftest%2Fui%2Fconsts%2Fconst-mut-refs%2Fconst_mut_refs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-mut-refs%2Fconst_mut_refs.rs?ref=d3163e96553ae8cb1fca0e62084b124e8b98310b", "patch": "@@ -1,3 +1,4 @@\n+// check-pass\n #![feature(const_mut_refs)]\n \n struct Foo {\n@@ -29,9 +30,6 @@ const fn bazz(foo: &mut Foo) -> usize {\n \n fn main() {\n     let _: [(); foo().bar()] = [(); 1];\n-    //~^ ERROR mutable references are not allowed in constants\n     let _: [(); baz(&mut foo())] = [(); 2];\n-    //~^ ERROR mutable references are not allowed in constants\n     let _: [(); bazz(&mut foo())] = [(); 3];\n-    //~^ ERROR mutable references are not allowed in constants\n }"}, {"sha": "4ca7b128b7c4b8253ad5e8fa7a650229c0a6c2a6", "filename": "src/test/ui/consts/const-mut-refs/const_mut_refs.stderr", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/1d0d76f8dd4f5f6ecbeab575b87edaf1c9f56bb8/src%2Ftest%2Fui%2Fconsts%2Fconst-mut-refs%2Fconst_mut_refs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1d0d76f8dd4f5f6ecbeab575b87edaf1c9f56bb8/src%2Ftest%2Fui%2Fconsts%2Fconst-mut-refs%2Fconst_mut_refs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-mut-refs%2Fconst_mut_refs.stderr?ref=1d0d76f8dd4f5f6ecbeab575b87edaf1c9f56bb8", "patch": "@@ -1,21 +0,0 @@\n-error[E0764]: mutable references are not allowed in constants\n-  --> $DIR/const_mut_refs.rs:31:17\n-   |\n-LL |     let _: [(); foo().bar()] = [(); 1];\n-   |                 ^^^^^ `&mut` is only allowed in `const fn`\n-\n-error[E0764]: mutable references are not allowed in constants\n-  --> $DIR/const_mut_refs.rs:33:21\n-   |\n-LL |     let _: [(); baz(&mut foo())] = [(); 2];\n-   |                     ^^^^^^^^^^ `&mut` is only allowed in `const fn`\n-\n-error[E0764]: mutable references are not allowed in constants\n-  --> $DIR/const_mut_refs.rs:35:22\n-   |\n-LL |     let _: [(); bazz(&mut foo())] = [(); 3];\n-   |                      ^^^^^^^^^^ `&mut` is only allowed in `const fn`\n-\n-error: aborting due to 3 previous errors\n-\n-For more information about this error, try `rustc --explain E0764`."}, {"sha": "166ba20f124e6d9629dabd04890a4890611acbf3", "filename": "src/test/ui/consts/const-mut-refs/mut_ref_in_final.rs", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/d3163e96553ae8cb1fca0e62084b124e8b98310b/src%2Ftest%2Fui%2Fconsts%2Fconst-mut-refs%2Fmut_ref_in_final.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3163e96553ae8cb1fca0e62084b124e8b98310b/src%2Ftest%2Fui%2Fconsts%2Fconst-mut-refs%2Fmut_ref_in_final.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-mut-refs%2Fmut_ref_in_final.rs?ref=d3163e96553ae8cb1fca0e62084b124e8b98310b", "patch": "@@ -0,0 +1,57 @@\n+#![feature(const_mut_refs)]\n+#![feature(const_fn)]\n+#![feature(raw_ref_op)]\n+#![feature(const_raw_ptr_deref)]\n+\n+const NULL: *mut i32 = std::ptr::null_mut();\n+const A: *const i32 = &4;\n+\n+// It could be made sound to allow it to compile,\n+// but we do not want to allow this to compile,\n+// as that would be an enormous footgun in oli-obk's opinion.\n+const B: *mut i32 = &mut 4; //~ ERROR mutable references are not allowed\n+\n+// Ok, no actual mutable allocation exists\n+const B2: Option<&mut i32> = None;\n+\n+// Not ok, can't prove that no mutable allocation ends up in final value\n+const B3: Option<&mut i32> = Some(&mut 42); //~ ERROR temporary value dropped while borrowed\n+\n+const fn helper(x: &mut i32) -> Option<&mut i32> { Some(x) }\n+const B4: Option<&mut i32> = helper(&mut 42); //~ ERROR temporary value dropped while borrowed\n+\n+// Ok, because no references to mutable data exist here, since the `{}` moves\n+// its value and then takes a reference to that.\n+const C: *const i32 = &{\n+    let mut x = 42;\n+    x += 3;\n+    x\n+};\n+\n+use std::cell::UnsafeCell;\n+struct NotAMutex<T>(UnsafeCell<T>);\n+\n+unsafe impl<T> Sync for NotAMutex<T> {}\n+\n+const FOO: NotAMutex<&mut i32> = NotAMutex(UnsafeCell::new(&mut 42));\n+//~^ ERROR temporary value dropped while borrowed\n+\n+static FOO2: NotAMutex<&mut i32> = NotAMutex(UnsafeCell::new(&mut 42));\n+//~^ ERROR temporary value dropped while borrowed\n+\n+static mut FOO3: NotAMutex<&mut i32> = NotAMutex(UnsafeCell::new(&mut 42));\n+//~^ ERROR temporary value dropped while borrowed\n+\n+// `BAR` works, because `&42` promotes immediately instead of relying on\n+// the enclosing scope rule.\n+const BAR: NotAMutex<&i32> = NotAMutex(UnsafeCell::new(&42));\n+\n+fn main() {\n+    println!(\"{}\", unsafe { *A });\n+    unsafe { *B = 4 } // Bad news\n+\n+    unsafe {\n+        **FOO.0.get() = 99;\n+        assert_eq!(**FOO.0.get(), 99);\n+    }\n+}"}, {"sha": "cbae74cce6f6b414901305350d853a305d847fb6", "filename": "src/test/ui/consts/const-mut-refs/mut_ref_in_final.stderr", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/d3163e96553ae8cb1fca0e62084b124e8b98310b/src%2Ftest%2Fui%2Fconsts%2Fconst-mut-refs%2Fmut_ref_in_final.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d3163e96553ae8cb1fca0e62084b124e8b98310b/src%2Ftest%2Fui%2Fconsts%2Fconst-mut-refs%2Fmut_ref_in_final.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-mut-refs%2Fmut_ref_in_final.stderr?ref=d3163e96553ae8cb1fca0e62084b124e8b98310b", "patch": "@@ -0,0 +1,60 @@\n+error[E0764]: mutable references are not allowed in the final value of constants\n+  --> $DIR/mut_ref_in_final.rs:12:21\n+   |\n+LL | const B: *mut i32 = &mut 4;\n+   |                     ^^^^^^\n+\n+error[E0716]: temporary value dropped while borrowed\n+  --> $DIR/mut_ref_in_final.rs:18:40\n+   |\n+LL | const B3: Option<&mut i32> = Some(&mut 42);\n+   |                              ----------^^-\n+   |                              |         | |\n+   |                              |         | temporary value is freed at the end of this statement\n+   |                              |         creates a temporary which is freed while still in use\n+   |                              using this value as a constant requires that borrow lasts for `'static`\n+\n+error[E0716]: temporary value dropped while borrowed\n+  --> $DIR/mut_ref_in_final.rs:21:42\n+   |\n+LL | const B4: Option<&mut i32> = helper(&mut 42);\n+   |                              ------------^^-\n+   |                              |           | |\n+   |                              |           | temporary value is freed at the end of this statement\n+   |                              |           creates a temporary which is freed while still in use\n+   |                              using this value as a constant requires that borrow lasts for `'static`\n+\n+error[E0716]: temporary value dropped while borrowed\n+  --> $DIR/mut_ref_in_final.rs:36:65\n+   |\n+LL | const FOO: NotAMutex<&mut i32> = NotAMutex(UnsafeCell::new(&mut 42));\n+   |                                  -------------------------------^^--\n+   |                                  |                              |  |\n+   |                                  |                              |  temporary value is freed at the end of this statement\n+   |                                  |                              creates a temporary which is freed while still in use\n+   |                                  using this value as a constant requires that borrow lasts for `'static`\n+\n+error[E0716]: temporary value dropped while borrowed\n+  --> $DIR/mut_ref_in_final.rs:39:67\n+   |\n+LL | static FOO2: NotAMutex<&mut i32> = NotAMutex(UnsafeCell::new(&mut 42));\n+   |                                    -------------------------------^^--\n+   |                                    |                              |  |\n+   |                                    |                              |  temporary value is freed at the end of this statement\n+   |                                    |                              creates a temporary which is freed while still in use\n+   |                                    using this value as a static requires that borrow lasts for `'static`\n+\n+error[E0716]: temporary value dropped while borrowed\n+  --> $DIR/mut_ref_in_final.rs:42:71\n+   |\n+LL | static mut FOO3: NotAMutex<&mut i32> = NotAMutex(UnsafeCell::new(&mut 42));\n+   |                                        -------------------------------^^--\n+   |                                        |                              |  |\n+   |                                        |                              |  temporary value is freed at the end of this statement\n+   |                                        |                              creates a temporary which is freed while still in use\n+   |                                        using this value as a static requires that borrow lasts for `'static`\n+\n+error: aborting due to 6 previous errors\n+\n+Some errors have detailed explanations: E0716, E0764.\n+For more information about an error, try `rustc --explain E0716`."}, {"sha": "1e856ec0a0accecbfd98da066535975601426501", "filename": "src/test/ui/consts/const-mut-refs/mut_ref_in_final_dynamic_check.rs", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/d3163e96553ae8cb1fca0e62084b124e8b98310b/src%2Ftest%2Fui%2Fconsts%2Fconst-mut-refs%2Fmut_ref_in_final_dynamic_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3163e96553ae8cb1fca0e62084b124e8b98310b/src%2Ftest%2Fui%2Fconsts%2Fconst-mut-refs%2Fmut_ref_in_final_dynamic_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-mut-refs%2Fmut_ref_in_final_dynamic_check.rs?ref=d3163e96553ae8cb1fca0e62084b124e8b98310b", "patch": "@@ -0,0 +1,28 @@\n+#![feature(const_mut_refs)]\n+#![feature(const_fn)]\n+#![feature(raw_ref_op)]\n+#![feature(const_raw_ptr_deref)]\n+\n+// This file checks that our dynamic checks catch things that the static checks miss.\n+// We do not have static checks for these, because we do not look into function bodies.\n+// We treat all functions as not returning a mutable reference, because there is no way to\n+// do that without causing the borrow checker to complain (see the B4/helper test in\n+// mut_ref_in_final.rs).\n+\n+const fn helper() -> Option<&'static mut i32> { unsafe {\n+    // Undefined behaviour (integer as pointer), who doesn't love tests like this.\n+    // This code never gets executed, because the static checks fail before that.\n+    Some(&mut *(42 as *mut i32)) //~ ERROR any use of this value will cause an error\n+} }\n+// The error is an evaluation error and not a validation error, so the error is reported\n+// directly at the site where it occurs.\n+const A: Option<&mut i32> = helper();\n+\n+const fn helper2() -> Option<&'static mut i32> { unsafe {\n+    // Undefined behaviour (dangling pointer), who doesn't love tests like this.\n+    // This code never gets executed, because the static checks fail before that.\n+    Some(&mut *(&mut 42 as *mut i32))\n+} }\n+const B: Option<&mut i32> = helper2(); //~ ERROR encountered dangling pointer in final constant\n+\n+fn main() {}"}, {"sha": "0bbf84b71bb685db66fecaa8ea46101fea67e7ef", "filename": "src/test/ui/consts/const-mut-refs/mut_ref_in_final_dynamic_check.stderr", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d3163e96553ae8cb1fca0e62084b124e8b98310b/src%2Ftest%2Fui%2Fconsts%2Fconst-mut-refs%2Fmut_ref_in_final_dynamic_check.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d3163e96553ae8cb1fca0e62084b124e8b98310b/src%2Ftest%2Fui%2Fconsts%2Fconst-mut-refs%2Fmut_ref_in_final_dynamic_check.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst-mut-refs%2Fmut_ref_in_final_dynamic_check.stderr?ref=d3163e96553ae8cb1fca0e62084b124e8b98310b", "patch": "@@ -0,0 +1,23 @@\n+error: any use of this value will cause an error\n+  --> $DIR/mut_ref_in_final_dynamic_check.rs:15:10\n+   |\n+LL |     Some(&mut *(42 as *mut i32))\n+   |          ^^^^^^^^^^^^^^^^^^^^^^\n+   |          |\n+   |          unable to turn bytes into a pointer\n+   |          inside `helper` at $DIR/mut_ref_in_final_dynamic_check.rs:15:10\n+   |          inside `A` at $DIR/mut_ref_in_final_dynamic_check.rs:19:29\n+...\n+LL | const A: Option<&mut i32> = helper();\n+   | -------------------------------------\n+   |\n+   = note: `#[deny(const_err)]` on by default\n+\n+error: encountered dangling pointer in final constant\n+  --> $DIR/mut_ref_in_final_dynamic_check.rs:26:1\n+   |\n+LL | const B: Option<&mut i32> = helper2();\n+   | ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "3eac61c0ce670a67ba911a73795a3fdab62aaa98", "filename": "src/test/ui/consts/const_let_assign3.stderr", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d3163e96553ae8cb1fca0e62084b124e8b98310b/src%2Ftest%2Fui%2Fconsts%2Fconst_let_assign3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d3163e96553ae8cb1fca0e62084b124e8b98310b/src%2Ftest%2Fui%2Fconsts%2Fconst_let_assign3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fconst_let_assign3.stderr?ref=d3163e96553ae8cb1fca0e62084b124e8b98310b", "patch": "@@ -7,19 +7,24 @@ LL |     const fn foo(&mut self, x: u32) {\n    = note: see issue #57349 <https://github.com/rust-lang/rust/issues/57349> for more information\n    = help: add `#![feature(const_mut_refs)]` to the crate attributes to enable\n \n-error[E0764]: mutable references are not allowed in constants\n+error[E0658]: mutable references are not allowed in constants\n   --> $DIR/const_let_assign3.rs:16:5\n    |\n LL |     s.foo(3);\n-   |     ^ `&mut` is only allowed in `const fn`\n+   |     ^\n+   |\n+   = note: see issue #57349 <https://github.com/rust-lang/rust/issues/57349> for more information\n+   = help: add `#![feature(const_mut_refs)]` to the crate attributes to enable\n \n-error[E0764]: mutable references are not allowed in constants\n+error[E0658]: mutable references are not allowed in constants\n   --> $DIR/const_let_assign3.rs:22:13\n    |\n LL |     let y = &mut x;\n-   |             ^^^^^^ `&mut` is only allowed in `const fn`\n+   |             ^^^^^^\n+   |\n+   = note: see issue #57349 <https://github.com/rust-lang/rust/issues/57349> for more information\n+   = help: add `#![feature(const_mut_refs)]` to the crate attributes to enable\n \n error: aborting due to 3 previous errors\n \n-Some errors have detailed explanations: E0658, E0764.\n-For more information about an error, try `rustc --explain E0658`.\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "62bbb3b569c37513645204d10f4fd626ad4a1dae", "filename": "src/test/ui/consts/issue-17718-const-bad-values.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d3163e96553ae8cb1fca0e62084b124e8b98310b/src%2Ftest%2Fui%2Fconsts%2Fissue-17718-const-bad-values.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3163e96553ae8cb1fca0e62084b124e8b98310b/src%2Ftest%2Fui%2Fconsts%2Fissue-17718-const-bad-values.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-17718-const-bad-values.rs?ref=d3163e96553ae8cb1fca0e62084b124e8b98310b", "patch": "@@ -1,10 +1,9 @@\n const C1: &'static mut [usize] = &mut [];\n-//~^ ERROR: mutable references are not allowed in constants\n+//~^ ERROR: mutable references are not allowed\n \n static mut S: usize = 3;\n const C2: &'static mut usize = unsafe { &mut S };\n //~^ ERROR: constants cannot refer to statics\n //~| ERROR: constants cannot refer to statics\n-//~| ERROR: mutable references are not allowed in constants\n \n fn main() {}"}, {"sha": "ce60aaa0797f819ea1b6b2fa52d6a050c4e14ee7", "filename": "src/test/ui/consts/issue-17718-const-bad-values.stderr", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d3163e96553ae8cb1fca0e62084b124e8b98310b/src%2Ftest%2Fui%2Fconsts%2Fissue-17718-const-bad-values.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d3163e96553ae8cb1fca0e62084b124e8b98310b/src%2Ftest%2Fui%2Fconsts%2Fissue-17718-const-bad-values.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fissue-17718-const-bad-values.stderr?ref=d3163e96553ae8cb1fca0e62084b124e8b98310b", "patch": "@@ -1,8 +1,8 @@\n-error[E0764]: mutable references are not allowed in constants\n+error[E0764]: mutable references are not allowed in the final value of constants\n   --> $DIR/issue-17718-const-bad-values.rs:1:34\n    |\n LL | const C1: &'static mut [usize] = &mut [];\n-   |                                  ^^^^^^^ `&mut` is only allowed in `const fn`\n+   |                                  ^^^^^^^\n \n error[E0013]: constants cannot refer to statics\n   --> $DIR/issue-17718-const-bad-values.rs:5:46\n@@ -20,13 +20,7 @@ LL | const C2: &'static mut usize = unsafe { &mut S };\n    |\n    = help: consider extracting the value of the `static` to a `const`, and referring to that\n \n-error[E0764]: mutable references are not allowed in constants\n-  --> $DIR/issue-17718-const-bad-values.rs:5:41\n-   |\n-LL | const C2: &'static mut usize = unsafe { &mut S };\n-   |                                         ^^^^^^ `&mut` is only allowed in `const fn`\n-\n-error: aborting due to 4 previous errors\n+error: aborting due to 3 previous errors\n \n Some errors have detailed explanations: E0013, E0764.\n For more information about an error, try `rustc --explain E0013`."}, {"sha": "fad8f011f75f55ba17f3926d9408a4641f05f4fb", "filename": "src/test/ui/consts/projection_qualif.mut_refs.stderr", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1d0d76f8dd4f5f6ecbeab575b87edaf1c9f56bb8/src%2Ftest%2Fui%2Fconsts%2Fprojection_qualif.mut_refs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1d0d76f8dd4f5f6ecbeab575b87edaf1c9f56bb8/src%2Ftest%2Fui%2Fconsts%2Fprojection_qualif.mut_refs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fprojection_qualif.mut_refs.stderr?ref=1d0d76f8dd4f5f6ecbeab575b87edaf1c9f56bb8", "patch": "@@ -1,19 +0,0 @@\n-error[E0764]: mutable references are not allowed in constants\n-  --> $DIR/projection_qualif.rs:10:27\n-   |\n-LL |         let b: *mut u32 = &mut a;\n-   |                           ^^^^^^ `&mut` is only allowed in `const fn`\n-\n-error[E0658]: dereferencing raw pointers in constants is unstable\n-  --> $DIR/projection_qualif.rs:11:18\n-   |\n-LL |         unsafe { *b = 5; }\n-   |                  ^^^^^^\n-   |\n-   = note: see issue #51911 <https://github.com/rust-lang/rust/issues/51911> for more information\n-   = help: add `#![feature(const_raw_ptr_deref)]` to the crate attributes to enable\n-\n-error: aborting due to 2 previous errors\n-\n-Some errors have detailed explanations: E0658, E0764.\n-For more information about an error, try `rustc --explain E0658`."}, {"sha": "fad8f011f75f55ba17f3926d9408a4641f05f4fb", "filename": "src/test/ui/consts/projection_qualif.stock.stderr", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/1d0d76f8dd4f5f6ecbeab575b87edaf1c9f56bb8/src%2Ftest%2Fui%2Fconsts%2Fprojection_qualif.stock.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1d0d76f8dd4f5f6ecbeab575b87edaf1c9f56bb8/src%2Ftest%2Fui%2Fconsts%2Fprojection_qualif.stock.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fprojection_qualif.stock.stderr?ref=1d0d76f8dd4f5f6ecbeab575b87edaf1c9f56bb8", "patch": "@@ -1,19 +0,0 @@\n-error[E0764]: mutable references are not allowed in constants\n-  --> $DIR/projection_qualif.rs:10:27\n-   |\n-LL |         let b: *mut u32 = &mut a;\n-   |                           ^^^^^^ `&mut` is only allowed in `const fn`\n-\n-error[E0658]: dereferencing raw pointers in constants is unstable\n-  --> $DIR/projection_qualif.rs:11:18\n-   |\n-LL |         unsafe { *b = 5; }\n-   |                  ^^^^^^\n-   |\n-   = note: see issue #51911 <https://github.com/rust-lang/rust/issues/51911> for more information\n-   = help: add `#![feature(const_raw_ptr_deref)]` to the crate attributes to enable\n-\n-error: aborting due to 2 previous errors\n-\n-Some errors have detailed explanations: E0658, E0764.\n-For more information about an error, try `rustc --explain E0658`."}, {"sha": "5faa983ab09f71cc0e9ebabcea6f6d0df7daf80f", "filename": "src/test/ui/consts/read_from_static_mut_ref.rs", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1d0d76f8dd4f5f6ecbeab575b87edaf1c9f56bb8/src%2Ftest%2Fui%2Fconsts%2Fread_from_static_mut_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1d0d76f8dd4f5f6ecbeab575b87edaf1c9f56bb8/src%2Ftest%2Fui%2Fconsts%2Fread_from_static_mut_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fread_from_static_mut_ref.rs?ref=1d0d76f8dd4f5f6ecbeab575b87edaf1c9f56bb8", "patch": "@@ -1,9 +0,0 @@\n-// We are keeping this test in case we decide to allow mutable references in statics again\n-#![feature(const_mut_refs)]\n-#![allow(const_err)]\n-\n-static OH_NO: &mut i32 = &mut 42;\n-//~^ ERROR mutable references are not allowed in statics\n-fn main() {\n-    assert_eq!(*OH_NO, 42);\n-}"}, {"sha": "c936ac0b7d585208c1bfa044535ffe4732e0bc91", "filename": "src/test/ui/consts/read_from_static_mut_ref.stderr", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/1d0d76f8dd4f5f6ecbeab575b87edaf1c9f56bb8/src%2Ftest%2Fui%2Fconsts%2Fread_from_static_mut_ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/1d0d76f8dd4f5f6ecbeab575b87edaf1c9f56bb8/src%2Ftest%2Fui%2Fconsts%2Fread_from_static_mut_ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fread_from_static_mut_ref.stderr?ref=1d0d76f8dd4f5f6ecbeab575b87edaf1c9f56bb8", "patch": "@@ -1,9 +0,0 @@\n-error[E0764]: mutable references are not allowed in statics\n-  --> $DIR/read_from_static_mut_ref.rs:5:26\n-   |\n-LL | static OH_NO: &mut i32 = &mut 42;\n-   |                          ^^^^^^^ `&mut` is only allowed in `const fn`\n-\n-error: aborting due to previous error\n-\n-For more information about this error, try `rustc --explain E0764`."}, {"sha": "8db75dd63cf2a0e5357f7e65bf3ee69bd4d52a98", "filename": "src/test/ui/consts/static_mut_containing_mut_ref2.mut_refs.stderr", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d3163e96553ae8cb1fca0e62084b124e8b98310b/src%2Ftest%2Fui%2Fconsts%2Fstatic_mut_containing_mut_ref2.mut_refs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d3163e96553ae8cb1fca0e62084b124e8b98310b/src%2Ftest%2Fui%2Fconsts%2Fstatic_mut_containing_mut_ref2.mut_refs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fstatic_mut_containing_mut_ref2.mut_refs.stderr?ref=d3163e96553ae8cb1fca0e62084b124e8b98310b", "patch": "@@ -1,9 +1,9 @@\n-error[E0764]: mutable references are not allowed in statics\n-  --> $DIR/static_mut_containing_mut_ref2.rs:7:46\n+error[E0080]: could not evaluate static initializer\n+  --> $DIR/static_mut_containing_mut_ref2.rs:7:45\n    |\n LL | pub static mut STDERR_BUFFER: () = unsafe { *(&mut STDERR_BUFFER_SPACE) = 42; };\n-   |                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^ `&mut` is only allowed in `const fn`\n+   |                                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ modifying a static's initial value from another static's initializer\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0764`.\n+For more information about this error, try `rustc --explain E0080`."}, {"sha": "61368546083db1ff813282b4ab9d3d03e7eff136", "filename": "src/test/ui/consts/static_mut_containing_mut_ref2.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/d3163e96553ae8cb1fca0e62084b124e8b98310b/src%2Ftest%2Fui%2Fconsts%2Fstatic_mut_containing_mut_ref2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3163e96553ae8cb1fca0e62084b124e8b98310b/src%2Ftest%2Fui%2Fconsts%2Fstatic_mut_containing_mut_ref2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fstatic_mut_containing_mut_ref2.rs?ref=d3163e96553ae8cb1fca0e62084b124e8b98310b", "patch": "@@ -5,6 +5,7 @@\n static mut STDERR_BUFFER_SPACE: u8 = 0;\n \n pub static mut STDERR_BUFFER: () = unsafe { *(&mut STDERR_BUFFER_SPACE) = 42; };\n-//~^ ERROR  mutable references are not allowed in statics\n+//[mut_refs]~^ ERROR could not evaluate static initializer\n+//[stock]~^^ ERROR mutable references are not allowed in statics\n \n fn main() {}"}, {"sha": "5cdcea2323109fc5f346b7825be6579bbb985651", "filename": "src/test/ui/consts/static_mut_containing_mut_ref2.stock.stderr", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d3163e96553ae8cb1fca0e62084b124e8b98310b/src%2Ftest%2Fui%2Fconsts%2Fstatic_mut_containing_mut_ref2.stock.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d3163e96553ae8cb1fca0e62084b124e8b98310b/src%2Ftest%2Fui%2Fconsts%2Fstatic_mut_containing_mut_ref2.stock.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fstatic_mut_containing_mut_ref2.stock.stderr?ref=d3163e96553ae8cb1fca0e62084b124e8b98310b", "patch": "@@ -1,9 +1,12 @@\n-error[E0764]: mutable references are not allowed in statics\n+error[E0658]: mutable references are not allowed in statics\n   --> $DIR/static_mut_containing_mut_ref2.rs:7:46\n    |\n LL | pub static mut STDERR_BUFFER: () = unsafe { *(&mut STDERR_BUFFER_SPACE) = 42; };\n-   |                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^ `&mut` is only allowed in `const fn`\n+   |                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #57349 <https://github.com/rust-lang/rust/issues/57349> for more information\n+   = help: add `#![feature(const_mut_refs)]` to the crate attributes to enable\n \n error: aborting due to previous error\n \n-For more information about this error, try `rustc --explain E0764`.\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "3ee50907461cac7a573ada158576c62c6539d0d3", "filename": "src/test/ui/consts/write_to_mut_ref_dest.mut_refs.stderr", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/d3163e96553ae8cb1fca0e62084b124e8b98310b/src%2Ftest%2Fui%2Fconsts%2Fwrite_to_mut_ref_dest.mut_refs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d3163e96553ae8cb1fca0e62084b124e8b98310b/src%2Ftest%2Fui%2Fconsts%2Fwrite_to_mut_ref_dest.mut_refs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fwrite_to_mut_ref_dest.mut_refs.stderr?ref=d3163e96553ae8cb1fca0e62084b124e8b98310b", "patch": "@@ -0,0 +1,12 @@\n+error[E0658]: dereferencing raw pointers in constants is unstable\n+  --> $DIR/write_to_mut_ref_dest.rs:11:18\n+   |\n+LL |         unsafe { *b = 5; }\n+   |                  ^^^^^^\n+   |\n+   = note: see issue #51911 <https://github.com/rust-lang/rust/issues/51911> for more information\n+   = help: add `#![feature(const_raw_ptr_deref)]` to the crate attributes to enable\n+\n+error: aborting due to previous error\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "d35df330bb8c33c956480b628daf3b857019d1ca", "filename": "src/test/ui/consts/write_to_mut_ref_dest.rs", "status": "renamed", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3163e96553ae8cb1fca0e62084b124e8b98310b/src%2Ftest%2Fui%2Fconsts%2Fwrite_to_mut_ref_dest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3163e96553ae8cb1fca0e62084b124e8b98310b/src%2Ftest%2Fui%2Fconsts%2Fwrite_to_mut_ref_dest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fwrite_to_mut_ref_dest.rs?ref=d3163e96553ae8cb1fca0e62084b124e8b98310b", "patch": "@@ -7,7 +7,7 @@ use std::cell::Cell;\n const FOO: &u32 = {\n     let mut a = 42;\n     {\n-        let b: *mut u32 = &mut a; //~ ERROR mutable references are not allowed in constants\n+        let b: *mut u32 = &mut a; //[stock]~ ERROR mutable references are not allowed in constants\n         unsafe { *b = 5; } //~ ERROR dereferencing raw pointers in constants\n     }\n     &{a}", "previous_filename": "src/test/ui/consts/projection_qualif.rs"}, {"sha": "2b6d1d3267b619ebc6769d85f2710c8ff3cb159d", "filename": "src/test/ui/consts/write_to_mut_ref_dest.stock.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d3163e96553ae8cb1fca0e62084b124e8b98310b/src%2Ftest%2Fui%2Fconsts%2Fwrite_to_mut_ref_dest.stock.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d3163e96553ae8cb1fca0e62084b124e8b98310b/src%2Ftest%2Fui%2Fconsts%2Fwrite_to_mut_ref_dest.stock.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fwrite_to_mut_ref_dest.stock.stderr?ref=d3163e96553ae8cb1fca0e62084b124e8b98310b", "patch": "@@ -0,0 +1,21 @@\n+error[E0658]: mutable references are not allowed in constants\n+  --> $DIR/write_to_mut_ref_dest.rs:10:27\n+   |\n+LL |         let b: *mut u32 = &mut a;\n+   |                           ^^^^^^\n+   |\n+   = note: see issue #57349 <https://github.com/rust-lang/rust/issues/57349> for more information\n+   = help: add `#![feature(const_mut_refs)]` to the crate attributes to enable\n+\n+error[E0658]: dereferencing raw pointers in constants is unstable\n+  --> $DIR/write_to_mut_ref_dest.rs:11:18\n+   |\n+LL |         unsafe { *b = 5; }\n+   |                  ^^^^^^\n+   |\n+   = note: see issue #51911 <https://github.com/rust-lang/rust/issues/51911> for more information\n+   = help: add `#![feature(const_raw_ptr_deref)]` to the crate attributes to enable\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0658`."}, {"sha": "665c305e9617f0007768e3a60c0dea45ea044776", "filename": "src/test/ui/consts/write_to_static_via_mut_ref.rs", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/d3163e96553ae8cb1fca0e62084b124e8b98310b/src%2Ftest%2Fui%2Fconsts%2Fwrite_to_static_via_mut_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3163e96553ae8cb1fca0e62084b124e8b98310b/src%2Ftest%2Fui%2Fconsts%2Fwrite_to_static_via_mut_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fwrite_to_static_via_mut_ref.rs?ref=d3163e96553ae8cb1fca0e62084b124e8b98310b", "patch": "@@ -0,0 +1,8 @@\n+#![feature(const_mut_refs)]\n+#![allow(const_err)]\n+\n+static OH_NO: &mut i32 = &mut 42; //~ ERROR mutable references are not allowed\n+fn main() {\n+    assert_eq!(*OH_NO, 42);\n+    *OH_NO = 43; //~ ERROR cannot assign to `*OH_NO`, as `OH_NO` is an immutable static\n+}"}, {"sha": "d19e998d6173660556543109760f55487df9ef54", "filename": "src/test/ui/consts/write_to_static_via_mut_ref.stderr", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/d3163e96553ae8cb1fca0e62084b124e8b98310b/src%2Ftest%2Fui%2Fconsts%2Fwrite_to_static_via_mut_ref.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d3163e96553ae8cb1fca0e62084b124e8b98310b/src%2Ftest%2Fui%2Fconsts%2Fwrite_to_static_via_mut_ref.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Fwrite_to_static_via_mut_ref.stderr?ref=d3163e96553ae8cb1fca0e62084b124e8b98310b", "patch": "@@ -0,0 +1,16 @@\n+error[E0764]: mutable references are not allowed in the final value of statics\n+  --> $DIR/write_to_static_via_mut_ref.rs:4:26\n+   |\n+LL | static OH_NO: &mut i32 = &mut 42;\n+   |                          ^^^^^^^\n+\n+error[E0594]: cannot assign to `*OH_NO`, as `OH_NO` is an immutable static item\n+  --> $DIR/write_to_static_via_mut_ref.rs:7:5\n+   |\n+LL |     *OH_NO = 43;\n+   |     ^^^^^^^^^^^ cannot assign\n+\n+error: aborting due to 2 previous errors\n+\n+Some errors have detailed explanations: E0594, E0764.\n+For more information about an error, try `rustc --explain E0594`."}, {"sha": "c211ad1a2f8f6e592fb1e2975f4f6d627d54a229", "filename": "src/test/ui/error-codes/E0017.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d3163e96553ae8cb1fca0e62084b124e8b98310b/src%2Ftest%2Fui%2Ferror-codes%2FE0017.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3163e96553ae8cb1fca0e62084b124e8b98310b/src%2Ftest%2Fui%2Ferror-codes%2FE0017.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0017.rs?ref=d3163e96553ae8cb1fca0e62084b124e8b98310b", "patch": "@@ -2,12 +2,13 @@ static X: i32 = 1;\n const C: i32 = 2;\n static mut M: i32 = 3;\n \n-const CR: &'static mut i32 = &mut C; //~ ERROR E0764\n+const CR: &'static mut i32 = &mut C; //~ ERROR mutable references are not allowed\n                                      //~| WARN taking a mutable\n-static STATIC_REF: &'static mut i32 = &mut X; //~ ERROR E0764\n+static STATIC_REF: &'static mut i32 = &mut X; //~ ERROR E0658\n                                               //~| ERROR cannot borrow\n+                                              //~| ERROR mutable references are not allowed\n \n-static CONST_REF: &'static mut i32 = &mut C; //~ ERROR E0764\n+static CONST_REF: &'static mut i32 = &mut C; //~ ERROR mutable references are not allowed\n                                               //~| WARN taking a mutable\n-static STATIC_MUT_REF: &'static mut i32 = unsafe { &mut M }; //~ ERROR E0764\n+static STATIC_MUT_REF: &'static mut i32 = unsafe { &mut M }; //~ ERROR mutable references are not\n fn main() {}"}, {"sha": "7d959b6d148ed22a7b093c1548d33aee494e938b", "filename": "src/test/ui/error-codes/E0017.stderr", "status": "modified", "additions": 22, "deletions": 13, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/d3163e96553ae8cb1fca0e62084b124e8b98310b/src%2Ftest%2Fui%2Ferror-codes%2FE0017.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d3163e96553ae8cb1fca0e62084b124e8b98310b/src%2Ftest%2Fui%2Ferror-codes%2FE0017.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0017.stderr?ref=d3163e96553ae8cb1fca0e62084b124e8b98310b", "patch": "@@ -13,17 +13,26 @@ note: `const` item defined here\n LL | const C: i32 = 2;\n    | ^^^^^^^^^^^^^^^^^\n \n-error[E0764]: mutable references are not allowed in constants\n+error[E0764]: mutable references are not allowed in the final value of constants\n   --> $DIR/E0017.rs:5:30\n    |\n LL | const CR: &'static mut i32 = &mut C;\n-   |                              ^^^^^^ `&mut` is only allowed in `const fn`\n+   |                              ^^^^^^\n \n-error[E0764]: mutable references are not allowed in statics\n+error[E0658]: mutation through a reference is not allowed in statics\n   --> $DIR/E0017.rs:7:39\n    |\n LL | static STATIC_REF: &'static mut i32 = &mut X;\n-   |                                       ^^^^^^ `&mut` is only allowed in `const fn`\n+   |                                       ^^^^^^\n+   |\n+   = note: see issue #57349 <https://github.com/rust-lang/rust/issues/57349> for more information\n+   = help: add `#![feature(const_mut_refs)]` to the crate attributes to enable\n+\n+error[E0764]: mutable references are not allowed in the final value of statics\n+  --> $DIR/E0017.rs:7:39\n+   |\n+LL | static STATIC_REF: &'static mut i32 = &mut X;\n+   |                                       ^^^^^^\n \n error[E0596]: cannot borrow immutable static item `X` as mutable\n   --> $DIR/E0017.rs:7:39\n@@ -32,7 +41,7 @@ LL | static STATIC_REF: &'static mut i32 = &mut X;\n    |                                       ^^^^^^ cannot borrow as mutable\n \n warning: taking a mutable reference to a `const` item\n-  --> $DIR/E0017.rs:10:38\n+  --> $DIR/E0017.rs:11:38\n    |\n LL | static CONST_REF: &'static mut i32 = &mut C;\n    |                                      ^^^^^^\n@@ -45,19 +54,19 @@ note: `const` item defined here\n LL | const C: i32 = 2;\n    | ^^^^^^^^^^^^^^^^^\n \n-error[E0764]: mutable references are not allowed in statics\n-  --> $DIR/E0017.rs:10:38\n+error[E0764]: mutable references are not allowed in the final value of statics\n+  --> $DIR/E0017.rs:11:38\n    |\n LL | static CONST_REF: &'static mut i32 = &mut C;\n-   |                                      ^^^^^^ `&mut` is only allowed in `const fn`\n+   |                                      ^^^^^^\n \n-error[E0764]: mutable references are not allowed in statics\n-  --> $DIR/E0017.rs:12:52\n+error[E0764]: mutable references are not allowed in the final value of statics\n+  --> $DIR/E0017.rs:13:52\n    |\n LL | static STATIC_MUT_REF: &'static mut i32 = unsafe { &mut M };\n-   |                                                    ^^^^^^ `&mut` is only allowed in `const fn`\n+   |                                                    ^^^^^^\n \n-error: aborting due to 5 previous errors; 2 warnings emitted\n+error: aborting due to 6 previous errors; 2 warnings emitted\n \n-Some errors have detailed explanations: E0596, E0764.\n+Some errors have detailed explanations: E0596, E0658, E0764.\n For more information about an error, try `rustc --explain E0596`."}, {"sha": "6049d95f0d277e8327567babd1e7e2e4ead59b15", "filename": "src/test/ui/error-codes/E0388.rs", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/d3163e96553ae8cb1fca0e62084b124e8b98310b/src%2Ftest%2Fui%2Ferror-codes%2FE0388.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3163e96553ae8cb1fca0e62084b124e8b98310b/src%2Ftest%2Fui%2Ferror-codes%2FE0388.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0388.rs?ref=d3163e96553ae8cb1fca0e62084b124e8b98310b", "patch": "@@ -1,12 +1,13 @@\n static X: i32 = 1;\n const C: i32 = 2;\n \n-const CR: &'static mut i32 = &mut C; //~ ERROR E0764\n+const CR: &'static mut i32 = &mut C; //~ ERROR mutable references are not allowed\n                                      //~| WARN taking a mutable\n static STATIC_REF: &'static mut i32 = &mut X; //~ ERROR cannot borrow\n-                                              //~| ERROR E0764\n+                                              //~| ERROR E0658\n+                                              //~| ERROR mutable references are not allowed\n \n-static CONST_REF: &'static mut i32 = &mut C; //~ ERROR E0764\n+static CONST_REF: &'static mut i32 = &mut C; //~ ERROR mutable references are not allowed\n                                              //~| WARN taking a mutable\n \n fn main() {}"}, {"sha": "4886a156d2ea597e9478e44815e1c6414c0b1b47", "filename": "src/test/ui/error-codes/E0388.stderr", "status": "modified", "additions": 19, "deletions": 10, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/d3163e96553ae8cb1fca0e62084b124e8b98310b/src%2Ftest%2Fui%2Ferror-codes%2FE0388.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d3163e96553ae8cb1fca0e62084b124e8b98310b/src%2Ftest%2Fui%2Ferror-codes%2FE0388.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ferror-codes%2FE0388.stderr?ref=d3163e96553ae8cb1fca0e62084b124e8b98310b", "patch": "@@ -13,17 +13,26 @@ note: `const` item defined here\n LL | const C: i32 = 2;\n    | ^^^^^^^^^^^^^^^^^\n \n-error[E0764]: mutable references are not allowed in constants\n+error[E0764]: mutable references are not allowed in the final value of constants\n   --> $DIR/E0388.rs:4:30\n    |\n LL | const CR: &'static mut i32 = &mut C;\n-   |                              ^^^^^^ `&mut` is only allowed in `const fn`\n+   |                              ^^^^^^\n \n-error[E0764]: mutable references are not allowed in statics\n+error[E0658]: mutation through a reference is not allowed in statics\n   --> $DIR/E0388.rs:6:39\n    |\n LL | static STATIC_REF: &'static mut i32 = &mut X;\n-   |                                       ^^^^^^ `&mut` is only allowed in `const fn`\n+   |                                       ^^^^^^\n+   |\n+   = note: see issue #57349 <https://github.com/rust-lang/rust/issues/57349> for more information\n+   = help: add `#![feature(const_mut_refs)]` to the crate attributes to enable\n+\n+error[E0764]: mutable references are not allowed in the final value of statics\n+  --> $DIR/E0388.rs:6:39\n+   |\n+LL | static STATIC_REF: &'static mut i32 = &mut X;\n+   |                                       ^^^^^^\n \n error[E0596]: cannot borrow immutable static item `X` as mutable\n   --> $DIR/E0388.rs:6:39\n@@ -32,7 +41,7 @@ LL | static STATIC_REF: &'static mut i32 = &mut X;\n    |                                       ^^^^^^ cannot borrow as mutable\n \n warning: taking a mutable reference to a `const` item\n-  --> $DIR/E0388.rs:9:38\n+  --> $DIR/E0388.rs:10:38\n    |\n LL | static CONST_REF: &'static mut i32 = &mut C;\n    |                                      ^^^^^^\n@@ -45,13 +54,13 @@ note: `const` item defined here\n LL | const C: i32 = 2;\n    | ^^^^^^^^^^^^^^^^^\n \n-error[E0764]: mutable references are not allowed in statics\n-  --> $DIR/E0388.rs:9:38\n+error[E0764]: mutable references are not allowed in the final value of statics\n+  --> $DIR/E0388.rs:10:38\n    |\n LL | static CONST_REF: &'static mut i32 = &mut C;\n-   |                                      ^^^^^^ `&mut` is only allowed in `const fn`\n+   |                                      ^^^^^^\n \n-error: aborting due to 4 previous errors; 2 warnings emitted\n+error: aborting due to 5 previous errors; 2 warnings emitted\n \n-Some errors have detailed explanations: E0596, E0764.\n+Some errors have detailed explanations: E0596, E0658, E0764.\n For more information about an error, try `rustc --explain E0596`."}, {"sha": "e35784a68d101a6af270893fb5ca7b83ec52c478", "filename": "src/test/ui/feature-gates/feature-gate-cfg-version.rs", "status": "modified", "additions": 19, "deletions": 11, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/d3163e96553ae8cb1fca0e62084b124e8b98310b/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-cfg-version.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3163e96553ae8cb1fca0e62084b124e8b98310b/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-cfg-version.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-cfg-version.rs?ref=d3163e96553ae8cb1fca0e62084b124e8b98310b", "patch": "@@ -1,3 +1,9 @@\n+#[cfg(version(42))] //~ ERROR: expected a version literal\n+//~^ ERROR `cfg(version)` is experimental and subject to change\n+fn foo() {}\n+#[cfg(version(1.20))] //~ ERROR: expected a version literal\n+//~^ ERROR `cfg(version)` is experimental and subject to change\n+fn foo() -> bool { true }\n #[cfg(version(\"1.44\"))]\n //~^ ERROR `cfg(version)` is experimental and subject to change\n fn foo() -> bool { true }\n@@ -11,30 +17,32 @@ fn bar() -> bool  { false }\n #[cfg(version(false))] //~ ERROR: expected a version literal\n //~^ ERROR `cfg(version)` is experimental and subject to change\n fn bar() -> bool  { false }\n-#[cfg(version(\"foo\"))] //~ ERROR: invalid version literal\n+#[cfg(version(\"foo\"))] //~ WARNING: unknown version literal format\n //~^ ERROR `cfg(version)` is experimental and subject to change\n fn bar() -> bool  { false }\n-#[cfg(version(\"999\"))]\n+#[cfg(version(\"999\"))] //~ WARNING: unknown version literal format\n //~^ ERROR `cfg(version)` is experimental and subject to change\n fn bar() -> bool  { false }\n-#[cfg(version(\"-1\"))] //~ ERROR: invalid version literal\n+#[cfg(version(\"-1\"))] //~ WARNING: unknown version literal format\n //~^ ERROR `cfg(version)` is experimental and subject to change\n fn bar() -> bool  { false }\n-#[cfg(version(\"65536\"))] //~ ERROR: invalid version literal\n+#[cfg(version(\"65536\"))] //~ WARNING: unknown version literal format\n //~^ ERROR `cfg(version)` is experimental and subject to change\n fn bar() -> bool  { false }\n-#[cfg(version(\"0\"))]\n+#[cfg(version(\"0\"))] //~ WARNING: unknown version literal format\n //~^ ERROR `cfg(version)` is experimental and subject to change\n fn bar() -> bool { true }\n-\n-#[cfg(version(\"1.65536.2\"))]\n+#[cfg(version(\"1.0\"))]\n+//~^ ERROR `cfg(version)` is experimental and subject to change\n+fn bar() -> bool { true }\n+#[cfg(version(\"1.65536.2\"))] //~ WARNING: unknown version literal format\n+//~^ ERROR `cfg(version)` is experimental and subject to change\n+fn bar() -> bool  { false }\n+#[cfg(version(\"1.20.0-stable\"))] //~ WARNING: unknown version literal format\n //~^ ERROR `cfg(version)` is experimental and subject to change\n-fn version_check_bug() {}\n+fn bar() {}\n \n fn main() {\n-    // This should fail but due to a bug in version_check `1.65536.2` is interpreted as `1.2`.\n-    // See https://github.com/SergioBenitez/version_check/issues/11\n-    version_check_bug();\n     assert!(foo());\n     assert!(bar());\n     assert!(cfg!(version(\"1.42\"))); //~ ERROR `cfg(version)` is experimental and subject to change"}, {"sha": "ae899d409ecf9e899cba05bfb7f3b29a9f4b916c", "filename": "src/test/ui/feature-gates/feature-gate-cfg-version.stderr", "status": "modified", "additions": 91, "deletions": 19, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/d3163e96553ae8cb1fca0e62084b124e8b98310b/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-cfg-version.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d3163e96553ae8cb1fca0e62084b124e8b98310b/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-cfg-version.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ffeature-gates%2Ffeature-gate-cfg-version.stderr?ref=d3163e96553ae8cb1fca0e62084b124e8b98310b", "patch": "@@ -1,14 +1,44 @@\n error[E0658]: `cfg(version)` is experimental and subject to change\n   --> $DIR/feature-gate-cfg-version.rs:1:7\n    |\n+LL | #[cfg(version(42))]\n+   |       ^^^^^^^^^^^\n+   |\n+   = note: see issue #64796 <https://github.com/rust-lang/rust/issues/64796> for more information\n+   = help: add `#![feature(cfg_version)]` to the crate attributes to enable\n+\n+error: expected a version literal\n+  --> $DIR/feature-gate-cfg-version.rs:1:15\n+   |\n+LL | #[cfg(version(42))]\n+   |               ^^\n+\n+error[E0658]: `cfg(version)` is experimental and subject to change\n+  --> $DIR/feature-gate-cfg-version.rs:4:7\n+   |\n+LL | #[cfg(version(1.20))]\n+   |       ^^^^^^^^^^^^^\n+   |\n+   = note: see issue #64796 <https://github.com/rust-lang/rust/issues/64796> for more information\n+   = help: add `#![feature(cfg_version)]` to the crate attributes to enable\n+\n+error: expected a version literal\n+  --> $DIR/feature-gate-cfg-version.rs:4:15\n+   |\n+LL | #[cfg(version(1.20))]\n+   |               ^^^^\n+\n+error[E0658]: `cfg(version)` is experimental and subject to change\n+  --> $DIR/feature-gate-cfg-version.rs:7:7\n+   |\n LL | #[cfg(version(\"1.44\"))]\n    |       ^^^^^^^^^^^^^^^\n    |\n    = note: see issue #64796 <https://github.com/rust-lang/rust/issues/64796> for more information\n    = help: add `#![feature(cfg_version)]` to the crate attributes to enable\n \n error[E0658]: `cfg(version)` is experimental and subject to change\n-  --> $DIR/feature-gate-cfg-version.rs:4:11\n+  --> $DIR/feature-gate-cfg-version.rs:10:11\n    |\n LL | #[cfg(not(version(\"1.44\")))]\n    |           ^^^^^^^^^^^^^^^\n@@ -17,7 +47,7 @@ LL | #[cfg(not(version(\"1.44\")))]\n    = help: add `#![feature(cfg_version)]` to the crate attributes to enable\n \n error[E0658]: `cfg(version)` is experimental and subject to change\n-  --> $DIR/feature-gate-cfg-version.rs:8:7\n+  --> $DIR/feature-gate-cfg-version.rs:14:7\n    |\n LL | #[cfg(version(\"1.43\", \"1.44\", \"1.45\"))]\n    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n@@ -26,13 +56,13 @@ LL | #[cfg(version(\"1.43\", \"1.44\", \"1.45\"))]\n    = help: add `#![feature(cfg_version)]` to the crate attributes to enable\n \n error: expected single version literal\n-  --> $DIR/feature-gate-cfg-version.rs:8:7\n+  --> $DIR/feature-gate-cfg-version.rs:14:7\n    |\n LL | #[cfg(version(\"1.43\", \"1.44\", \"1.45\"))]\n    |       ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\n \n error[E0658]: `cfg(version)` is experimental and subject to change\n-  --> $DIR/feature-gate-cfg-version.rs:11:7\n+  --> $DIR/feature-gate-cfg-version.rs:17:7\n    |\n LL | #[cfg(version(false))]\n    |       ^^^^^^^^^^^^^^\n@@ -41,92 +71,134 @@ LL | #[cfg(version(false))]\n    = help: add `#![feature(cfg_version)]` to the crate attributes to enable\n \n error: expected a version literal\n-  --> $DIR/feature-gate-cfg-version.rs:11:15\n+  --> $DIR/feature-gate-cfg-version.rs:17:15\n    |\n LL | #[cfg(version(false))]\n    |               ^^^^^\n \n error[E0658]: `cfg(version)` is experimental and subject to change\n-  --> $DIR/feature-gate-cfg-version.rs:14:7\n+  --> $DIR/feature-gate-cfg-version.rs:20:7\n    |\n LL | #[cfg(version(\"foo\"))]\n    |       ^^^^^^^^^^^^^^\n    |\n    = note: see issue #64796 <https://github.com/rust-lang/rust/issues/64796> for more information\n    = help: add `#![feature(cfg_version)]` to the crate attributes to enable\n \n-error: invalid version literal\n-  --> $DIR/feature-gate-cfg-version.rs:14:15\n+warning: unknown version literal format, assuming it refers to a future version\n+  --> $DIR/feature-gate-cfg-version.rs:20:15\n    |\n LL | #[cfg(version(\"foo\"))]\n    |               ^^^^^\n \n error[E0658]: `cfg(version)` is experimental and subject to change\n-  --> $DIR/feature-gate-cfg-version.rs:17:7\n+  --> $DIR/feature-gate-cfg-version.rs:23:7\n    |\n LL | #[cfg(version(\"999\"))]\n    |       ^^^^^^^^^^^^^^\n    |\n    = note: see issue #64796 <https://github.com/rust-lang/rust/issues/64796> for more information\n    = help: add `#![feature(cfg_version)]` to the crate attributes to enable\n \n+warning: unknown version literal format, assuming it refers to a future version\n+  --> $DIR/feature-gate-cfg-version.rs:23:15\n+   |\n+LL | #[cfg(version(\"999\"))]\n+   |               ^^^^^\n+\n error[E0658]: `cfg(version)` is experimental and subject to change\n-  --> $DIR/feature-gate-cfg-version.rs:20:7\n+  --> $DIR/feature-gate-cfg-version.rs:26:7\n    |\n LL | #[cfg(version(\"-1\"))]\n    |       ^^^^^^^^^^^^^\n    |\n    = note: see issue #64796 <https://github.com/rust-lang/rust/issues/64796> for more information\n    = help: add `#![feature(cfg_version)]` to the crate attributes to enable\n \n-error: invalid version literal\n-  --> $DIR/feature-gate-cfg-version.rs:20:15\n+warning: unknown version literal format, assuming it refers to a future version\n+  --> $DIR/feature-gate-cfg-version.rs:26:15\n    |\n LL | #[cfg(version(\"-1\"))]\n    |               ^^^^\n \n error[E0658]: `cfg(version)` is experimental and subject to change\n-  --> $DIR/feature-gate-cfg-version.rs:23:7\n+  --> $DIR/feature-gate-cfg-version.rs:29:7\n    |\n LL | #[cfg(version(\"65536\"))]\n    |       ^^^^^^^^^^^^^^^^\n    |\n    = note: see issue #64796 <https://github.com/rust-lang/rust/issues/64796> for more information\n    = help: add `#![feature(cfg_version)]` to the crate attributes to enable\n \n-error: invalid version literal\n-  --> $DIR/feature-gate-cfg-version.rs:23:15\n+warning: unknown version literal format, assuming it refers to a future version\n+  --> $DIR/feature-gate-cfg-version.rs:29:15\n    |\n LL | #[cfg(version(\"65536\"))]\n    |               ^^^^^^^\n \n error[E0658]: `cfg(version)` is experimental and subject to change\n-  --> $DIR/feature-gate-cfg-version.rs:26:7\n+  --> $DIR/feature-gate-cfg-version.rs:32:7\n    |\n LL | #[cfg(version(\"0\"))]\n    |       ^^^^^^^^^^^^\n    |\n    = note: see issue #64796 <https://github.com/rust-lang/rust/issues/64796> for more information\n    = help: add `#![feature(cfg_version)]` to the crate attributes to enable\n \n+warning: unknown version literal format, assuming it refers to a future version\n+  --> $DIR/feature-gate-cfg-version.rs:32:15\n+   |\n+LL | #[cfg(version(\"0\"))]\n+   |               ^^^\n+\n+error[E0658]: `cfg(version)` is experimental and subject to change\n+  --> $DIR/feature-gate-cfg-version.rs:35:7\n+   |\n+LL | #[cfg(version(\"1.0\"))]\n+   |       ^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #64796 <https://github.com/rust-lang/rust/issues/64796> for more information\n+   = help: add `#![feature(cfg_version)]` to the crate attributes to enable\n+\n error[E0658]: `cfg(version)` is experimental and subject to change\n-  --> $DIR/feature-gate-cfg-version.rs:30:7\n+  --> $DIR/feature-gate-cfg-version.rs:38:7\n    |\n LL | #[cfg(version(\"1.65536.2\"))]\n    |       ^^^^^^^^^^^^^^^^^^^^\n    |\n    = note: see issue #64796 <https://github.com/rust-lang/rust/issues/64796> for more information\n    = help: add `#![feature(cfg_version)]` to the crate attributes to enable\n \n+warning: unknown version literal format, assuming it refers to a future version\n+  --> $DIR/feature-gate-cfg-version.rs:38:15\n+   |\n+LL | #[cfg(version(\"1.65536.2\"))]\n+   |               ^^^^^^^^^^^\n+\n+error[E0658]: `cfg(version)` is experimental and subject to change\n+  --> $DIR/feature-gate-cfg-version.rs:41:7\n+   |\n+LL | #[cfg(version(\"1.20.0-stable\"))]\n+   |       ^^^^^^^^^^^^^^^^^^^^^^^^\n+   |\n+   = note: see issue #64796 <https://github.com/rust-lang/rust/issues/64796> for more information\n+   = help: add `#![feature(cfg_version)]` to the crate attributes to enable\n+\n+warning: unknown version literal format, assuming it refers to a future version\n+  --> $DIR/feature-gate-cfg-version.rs:41:15\n+   |\n+LL | #[cfg(version(\"1.20.0-stable\"))]\n+   |               ^^^^^^^^^^^^^^^\n+\n error[E0658]: `cfg(version)` is experimental and subject to change\n-  --> $DIR/feature-gate-cfg-version.rs:40:18\n+  --> $DIR/feature-gate-cfg-version.rs:48:18\n    |\n LL |     assert!(cfg!(version(\"1.42\")));\n    |                  ^^^^^^^^^^^^^^^\n    |\n    = note: see issue #64796 <https://github.com/rust-lang/rust/issues/64796> for more information\n    = help: add `#![feature(cfg_version)]` to the crate attributes to enable\n \n-error: aborting due to 16 previous errors\n+error: aborting due to 19 previous errors; 7 warnings emitted\n \n For more information about this error, try `rustc --explain E0658`."}, {"sha": "0fe9ae56c6564b244f50937c0d67f3d6a46307fc", "filename": "src/test/ui/hygiene/no_implicit_prelude-2021.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d3163e96553ae8cb1fca0e62084b124e8b98310b/src%2Ftest%2Fui%2Fhygiene%2Fno_implicit_prelude-2021.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3163e96553ae8cb1fca0e62084b124e8b98310b/src%2Ftest%2Fui%2Fhygiene%2Fno_implicit_prelude-2021.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhygiene%2Fno_implicit_prelude-2021.rs?ref=d3163e96553ae8cb1fca0e62084b124e8b98310b", "patch": "@@ -0,0 +1,9 @@\n+// check-pass\n+// edition:2021\n+\n+#![no_implicit_prelude]\n+\n+fn main() {\n+    assert!(true, \"hoi\");\n+    assert!(false, \"hoi {}\", 123);\n+}"}, {"sha": "6ec6e7bdcb81e8cfb104d0c33963e25c8f718417", "filename": "src/test/ui/issues/issue-46604.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/d3163e96553ae8cb1fca0e62084b124e8b98310b/src%2Ftest%2Fui%2Fissues%2Fissue-46604.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3163e96553ae8cb1fca0e62084b124e8b98310b/src%2Ftest%2Fui%2Fissues%2Fissue-46604.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-46604.rs?ref=d3163e96553ae8cb1fca0e62084b124e8b98310b", "patch": "@@ -1,4 +1,4 @@\n-static buf: &mut [u8] = &mut [1u8,2,3,4,5,7];   //~ ERROR E0764\n+static buf: &mut [u8] = &mut [1u8,2,3,4,5,7];   //~ ERROR mutable references are not allowed\n fn write<T: AsRef<[u8]>>(buffer: T) { }\n \n fn main() {"}, {"sha": "7faa2d79ba4835baf2f7b502896017b2afaee78b", "filename": "src/test/ui/issues/issue-46604.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/d3163e96553ae8cb1fca0e62084b124e8b98310b/src%2Ftest%2Fui%2Fissues%2Fissue-46604.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d3163e96553ae8cb1fca0e62084b124e8b98310b/src%2Ftest%2Fui%2Fissues%2Fissue-46604.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-46604.stderr?ref=d3163e96553ae8cb1fca0e62084b124e8b98310b", "patch": "@@ -1,8 +1,8 @@\n-error[E0764]: mutable references are not allowed in statics\n+error[E0764]: mutable references are not allowed in the final value of statics\n   --> $DIR/issue-46604.rs:1:25\n    |\n LL | static buf: &mut [u8] = &mut [1u8,2,3,4,5,7];\n-   |                         ^^^^^^^^^^^^^^^^^^^^ `&mut` is only allowed in `const fn`\n+   |                         ^^^^^^^^^^^^^^^^^^^^\n \n error[E0594]: cannot assign to `buf[_]`, as `buf` is an immutable static item\n   --> $DIR/issue-46604.rs:6:5"}, {"sha": "0bcdd6edf0d667aff4ba68279b4a051804539d68", "filename": "src/test/ui/lint/dead-code/const-and-self.rs", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d3163e96553ae8cb1fca0e62084b124e8b98310b/src%2Ftest%2Fui%2Flint%2Fdead-code%2Fconst-and-self.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3163e96553ae8cb1fca0e62084b124e8b98310b/src%2Ftest%2Fui%2Flint%2Fdead-code%2Fconst-and-self.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fdead-code%2Fconst-and-self.rs?ref=d3163e96553ae8cb1fca0e62084b124e8b98310b", "patch": "@@ -1,6 +1,6 @@\n // check-pass\n \n-#![deny(dead_code)]\n+#![warn(dead_code)]\n \n const TLC: usize = 4;\n \n@@ -28,8 +28,27 @@ impl Foo<Y> for X {\n     }\n }\n \n+enum E {\n+    A,\n+    B, //~ WARN variant is never constructed: `B`\n+    C, //~ WARN variant is never constructed: `C`\n+}\n+\n+type F = E;\n+\n+impl E {\n+    fn check(&self) -> bool {\n+        match self {\n+            Self::A => true,\n+            Self::B => false,\n+            F::C => false,\n+        }\n+    }\n+}\n+\n fn main() {\n     let s = [0,1,2,3];\n     s.doit();\n     X::foo();\n+    E::A.check();\n }"}, {"sha": "c0e406189e8ab3a64ecfe1b47994e4beac1493de", "filename": "src/test/ui/lint/dead-code/const-and-self.stderr", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d3163e96553ae8cb1fca0e62084b124e8b98310b/src%2Ftest%2Fui%2Flint%2Fdead-code%2Fconst-and-self.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d3163e96553ae8cb1fca0e62084b124e8b98310b/src%2Ftest%2Fui%2Flint%2Fdead-code%2Fconst-and-self.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fdead-code%2Fconst-and-self.stderr?ref=d3163e96553ae8cb1fca0e62084b124e8b98310b", "patch": "@@ -0,0 +1,20 @@\n+warning: variant is never constructed: `B`\n+  --> $DIR/const-and-self.rs:33:5\n+   |\n+LL |     B,\n+   |     ^\n+   |\n+note: the lint level is defined here\n+  --> $DIR/const-and-self.rs:3:9\n+   |\n+LL | #![warn(dead_code)]\n+   |         ^^^^^^^^^\n+\n+warning: variant is never constructed: `C`\n+  --> $DIR/const-and-self.rs:34:5\n+   |\n+LL |     C,\n+   |     ^\n+\n+warning: 2 warnings emitted\n+"}, {"sha": "1683841e9d78137725b4e4ce37d9f37b2909cbb7", "filename": "src/test/ui/never_type/issue-52443.stderr", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/d3163e96553ae8cb1fca0e62084b124e8b98310b/src%2Ftest%2Fui%2Fnever_type%2Fissue-52443.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d3163e96553ae8cb1fca0e62084b124e8b98310b/src%2Ftest%2Fui%2Fnever_type%2Fissue-52443.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fnever_type%2Fissue-52443.stderr?ref=d3163e96553ae8cb1fca0e62084b124e8b98310b", "patch": "@@ -39,11 +39,14 @@ error[E0015]: calls in constants are limited to constant functions, tuple struct\n LL |     [(); { for _ in 0usize.. {}; 0}];\n    |                     ^^^^^^^^\n \n-error[E0764]: mutable references are not allowed in constants\n+error[E0658]: mutable references are not allowed in constants\n   --> $DIR/issue-52443.rs:9:21\n    |\n LL |     [(); { for _ in 0usize.. {}; 0}];\n-   |                     ^^^^^^^^ `&mut` is only allowed in `const fn`\n+   |                     ^^^^^^^^\n+   |\n+   = note: see issue #57349 <https://github.com/rust-lang/rust/issues/57349> for more information\n+   = help: add `#![feature(const_mut_refs)]` to the crate attributes to enable\n \n error[E0015]: calls in constants are limited to constant functions, tuple structs and tuple variants\n   --> $DIR/issue-52443.rs:9:21\n@@ -53,5 +56,5 @@ LL |     [(); { for _ in 0usize.. {}; 0}];\n \n error: aborting due to 6 previous errors; 1 warning emitted\n \n-Some errors have detailed explanations: E0015, E0308, E0744, E0764.\n+Some errors have detailed explanations: E0015, E0308, E0658, E0744.\n For more information about an error, try `rustc --explain E0015`."}, {"sha": "b7178c2b52bfbff8424977ee5d71a5c90ac0cbf7", "filename": "src/test/ui/unsafe/ranged_ints2_const.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/d3163e96553ae8cb1fca0e62084b124e8b98310b/src%2Ftest%2Fui%2Funsafe%2Franged_ints2_const.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3163e96553ae8cb1fca0e62084b124e8b98310b/src%2Ftest%2Fui%2Funsafe%2Franged_ints2_const.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsafe%2Franged_ints2_const.rs?ref=d3163e96553ae8cb1fca0e62084b124e8b98310b", "patch": "@@ -18,3 +18,9 @@ const fn bar() -> NonZero<u32> {\n     let y = unsafe { &mut x.0 }; //~ ERROR mutable references\n     unsafe { NonZero(1) }\n }\n+\n+const fn boo() -> NonZero<u32> {\n+    let mut x = unsafe { NonZero(1) };\n+    unsafe { let y = &mut x.0; } //~ ERROR mutable references\n+    unsafe { NonZero(1) }\n+}"}, {"sha": "a0dc950e76dd1a4e631c8b809a26bf5d74f15618", "filename": "src/test/ui/unsafe/ranged_ints2_const.stderr", "status": "modified", "additions": 10, "deletions": 1, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/d3163e96553ae8cb1fca0e62084b124e8b98310b/src%2Ftest%2Fui%2Funsafe%2Franged_ints2_const.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/d3163e96553ae8cb1fca0e62084b124e8b98310b/src%2Ftest%2Fui%2Funsafe%2Franged_ints2_const.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funsafe%2Franged_ints2_const.stderr?ref=d3163e96553ae8cb1fca0e62084b124e8b98310b", "patch": "@@ -16,6 +16,15 @@ LL |     let y = unsafe { &mut x.0 };\n    = note: see issue #57349 <https://github.com/rust-lang/rust/issues/57349> for more information\n    = help: add `#![feature(const_mut_refs)]` to the crate attributes to enable\n \n+error[E0658]: mutable references are not allowed in constant functions\n+  --> $DIR/ranged_ints2_const.rs:24:22\n+   |\n+LL |     unsafe { let y = &mut x.0; }\n+   |                      ^^^^^^^^\n+   |\n+   = note: see issue #57349 <https://github.com/rust-lang/rust/issues/57349> for more information\n+   = help: add `#![feature(const_mut_refs)]` to the crate attributes to enable\n+\n error[E0133]: mutation of layout constrained field is unsafe and requires unsafe function or block\n   --> $DIR/ranged_ints2_const.rs:11:13\n    |\n@@ -24,7 +33,7 @@ LL |     let y = &mut x.0;\n    |\n    = note: mutating layout constrained fields cannot statically be checked for valid values\n \n-error: aborting due to 3 previous errors\n+error: aborting due to 4 previous errors\n \n Some errors have detailed explanations: E0133, E0658.\n For more information about an error, try `rustc --explain E0133`."}, {"sha": "6ec292aba649589be6d3426b8367ac80d4b5a48e", "filename": "src/tools/jsondocck/src/main.rs", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/d3163e96553ae8cb1fca0e62084b124e8b98310b/src%2Ftools%2Fjsondocck%2Fsrc%2Fmain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d3163e96553ae8cb1fca0e62084b124e8b98310b/src%2Ftools%2Fjsondocck%2Fsrc%2Fmain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fjsondocck%2Fsrc%2Fmain.rs?ref=d3163e96553ae8cb1fca0e62084b124e8b98310b", "patch": "@@ -149,7 +149,22 @@ fn get_commands(template: &str) -> Result<Vec<Command>, ()> {\n             }\n         }\n \n-        let args = cap.name(\"args\").map_or(vec![], |m| shlex::split(m.as_str()).unwrap());\n+        let args = cap.name(\"args\").map_or(Some(vec![]), |m| shlex::split(m.as_str()));\n+\n+        let args = match args {\n+            Some(args) => args,\n+            None => {\n+                print_err(\n+                    &format!(\n+                        \"Invalid arguments to shlex::split: `{}`\",\n+                        cap.name(\"args\").unwrap().as_str()\n+                    ),\n+                    lineno,\n+                );\n+                errors = true;\n+                continue;\n+            }\n+        };\n \n         if !cmd.validate(&args, commands.len(), lineno) {\n             errors = true;"}]}