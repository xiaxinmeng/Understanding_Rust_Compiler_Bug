{"sha": "ea0224f5ab5e0fce6f83ae395c30058dcd434be7", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVhMDIyNGY1YWI1ZTBmY2U2ZjgzYWUzOTVjMzAwNThkY2Q0MzRiZTc=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-07-03T09:28:49Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2018-07-03T22:10:08Z"}, "message": "error_report: rustfmt", "tree": {"sha": "afbc9480c2c8404a9b7936b2f40811d146c242e5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/afbc9480c2c8404a9b7936b2f40811d146c242e5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ea0224f5ab5e0fce6f83ae395c30058dcd434be7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ea0224f5ab5e0fce6f83ae395c30058dcd434be7", "html_url": "https://github.com/rust-lang/rust/commit/ea0224f5ab5e0fce6f83ae395c30058dcd434be7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ea0224f5ab5e0fce6f83ae395c30058dcd434be7/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "739320a6011fd78b15328416d3c488d025974039", "url": "https://api.github.com/repos/rust-lang/rust/commits/739320a6011fd78b15328416d3c488d025974039", "html_url": "https://github.com/rust-lang/rust/commit/739320a6011fd78b15328416d3c488d025974039"}], "stats": {"total": 107, "additions": 72, "deletions": 35}, "files": [{"sha": "fdeb1c47ea6e6720ec2b2ce62f5f3ec18e3df7bf", "filename": "src/librustc_mir/borrow_check/nll/region_infer/error_reporting.rs", "status": "modified", "additions": 72, "deletions": 35, "changes": 107, "blob_url": "https://github.com/rust-lang/rust/blob/ea0224f5ab5e0fce6f83ae395c30058dcd434be7/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ea0224f5ab5e0fce6f83ae395c30058dcd434be7/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fnll%2Fregion_infer%2Ferror_reporting.rs?ref=ea0224f5ab5e0fce6f83ae395c30058dcd434be7", "patch": "@@ -8,17 +8,18 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::fmt;\n-use borrow_check::nll::region_infer::{ConstraintIndex, RegionInferenceContext};\n use borrow_check::nll::region_infer::values::ToElementIndex;\n+use borrow_check::nll::region_infer::{Cause, ConstraintIndex, RegionInferenceContext};\n+use borrow_check::nll::region_infer::{ConstraintIndex, RegionInferenceContext};\n use borrow_check::nll::type_check::Locations;\n use rustc::hir::def_id::DefId;\n-use rustc::infer::InferCtxt;\n use rustc::infer::error_reporting::nice_region_error::NiceRegionError;\n-use rustc::mir::{self, Location, Mir, Place, StatementKind, TerminatorKind, Rvalue};\n+use rustc::infer::InferCtxt;\n+use rustc::mir::{self, Location, Mir, Place, Rvalue, StatementKind, TerminatorKind};\n use rustc::ty::RegionVid;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_data_structures::indexed_vec::IndexVec;\n+use std::fmt;\n use syntax_pos::Span;\n \n /// Constraints that are considered interesting can be categorized to\n@@ -50,16 +51,13 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// When reporting an error, it is useful to be able to determine which constraints influenced\n     /// the region being reported as an error. This function finds all of the paths from the\n     /// constraint.\n-    fn find_constraint_paths_from_region(\n-        &self,\n-        r0: RegionVid\n-    ) -> Vec<Vec<ConstraintIndex>> {\n+    fn find_constraint_paths_from_region(&self, r0: RegionVid) -> Vec<Vec<ConstraintIndex>> {\n         let constraints = self.constraints.clone();\n \n         // Mapping of regions to the previous region and constraint index that led to it.\n         let mut previous = FxHashMap();\n         // Regions yet to be visited.\n-        let mut next = vec! [ r0 ];\n+        let mut next = vec![r0];\n         // Regions that have been visited.\n         let mut visited = FxHashSet();\n         // Ends of paths.\n@@ -68,8 +66,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         // When we've still got points to visit...\n         while let Some(current) = next.pop() {\n             // ...take the next point...\n-            debug!(\"find_constraint_paths_from_region: current={:?} visited={:?} next={:?}\",\n-                   current, visited, next);\n+            debug!(\n+                \"find_constraint_paths_from_region: current={:?} visited={:?} next={:?}\",\n+                current, visited, next\n+            );\n             // ...but make sure not to visit this point again...\n             visited.insert(current);\n \n@@ -78,8 +78,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n             for (index, constraint) in constraints.iter_enumerated() {\n                 if constraint.sub == current {\n                     // ...add the regions that join us with to the path we've taken...\n-                    debug!(\"find_constraint_paths_from_region: index={:?} constraint={:?}\",\n-                           index, constraint);\n+                    debug!(\n+                        \"find_constraint_paths_from_region: index={:?} constraint={:?}\",\n+                        index, constraint\n+                    );\n                     let next_region = constraint.sup.clone();\n \n                     // ...unless we've visited it since this was added...\n@@ -95,27 +97,41 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n             if upcoming.is_empty() {\n                 // If we didn't find any edges then this is the end of a path...\n-                debug!(\"find_constraint_paths_from_region: new end region current={:?}\", current);\n+                debug!(\n+                    \"find_constraint_paths_from_region: new end region current={:?}\",\n+                    current\n+                );\n                 end_regions.insert(current);\n             } else {\n                 // ...but, if we did find edges, then add these to the regions yet to visit.\n-                debug!(\"find_constraint_paths_from_region: extend next upcoming={:?}\", upcoming);\n+                debug!(\n+                    \"find_constraint_paths_from_region: extend next upcoming={:?}\",\n+                    upcoming\n+                );\n                 next.extend(upcoming);\n             }\n-\n         }\n \n         // Now we've visited each point, compute the final paths.\n         let mut paths: Vec<Vec<ConstraintIndex>> = Vec::new();\n-        debug!(\"find_constraint_paths_from_region: end_regions={:?}\", end_regions);\n+        debug!(\n+            \"find_constraint_paths_from_region: end_regions={:?}\",\n+            end_regions\n+        );\n         for end_region in end_regions {\n-            debug!(\"find_constraint_paths_from_region: end_region={:?}\", end_region);\n+            debug!(\n+                \"find_constraint_paths_from_region: end_region={:?}\",\n+                end_region\n+            );\n \n             // Get the constraint and region that led to this end point.\n             // We can unwrap as we know if end_point was in the vector that it\n             // must also be in our previous map.\n             let (mut index, mut region) = previous.get(&end_region).unwrap();\n-            debug!(\"find_constraint_paths_from_region: index={:?} region={:?}\", index, region);\n+            debug!(\n+                \"find_constraint_paths_from_region: index={:?} region={:?}\",\n+                index, region\n+            );\n \n             // Keep track of the indices.\n             let mut path: Vec<ConstraintIndex> = vec![index];\n@@ -125,7 +141,10 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                 index = p.0;\n                 region = p.1;\n \n-                debug!(\"find_constraint_paths_from_region: index={:?} region={:?}\", index, region);\n+                debug!(\n+                    \"find_constraint_paths_from_region: index={:?} region={:?}\",\n+                    index, region\n+                );\n                 path.push(index);\n             }\n \n@@ -140,16 +159,28 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n     /// This function will return true if a constraint is interesting and false if a constraint\n     /// is not. It is useful in filtering constraint paths to only interesting points.\n     fn constraint_is_interesting(&self, index: &ConstraintIndex) -> bool {\n-        self.constraints.get(*index).filter(|constraint| {\n-            debug!(\"constraint_is_interesting: locations={:?} constraint={:?}\",\n-                   constraint.locations, constraint);\n-            if let Locations::Interesting(_) = constraint.locations { true } else { false }\n-        }).is_some()\n+        self.constraints\n+            .get(*index)\n+            .filter(|constraint| {\n+                debug!(\n+                    \"constraint_is_interesting: locations={:?} constraint={:?}\",\n+                    constraint.locations, constraint\n+                );\n+                if let Locations::Interesting(_) = constraint.locations {\n+                    true\n+                } else {\n+                    false\n+                }\n+            })\n+            .is_some()\n     }\n \n     /// This function classifies a constraint from a location.\n-    fn classify_constraint(&self, index: &ConstraintIndex,\n-                           mir: &Mir<'tcx>) -> Option<(ConstraintCategory, Span)> {\n+    fn classify_constraint(\n+        &self,\n+        index: &ConstraintIndex,\n+        mir: &Mir<'tcx>,\n+    ) -> Option<(ConstraintCategory, Span)> {\n         let constraint = self.constraints.get(*index)?;\n         let span = constraint.locations.span(mir);\n         let location = constraint.locations.from_location()?;\n@@ -182,7 +213,7 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n                             _ => ConstraintCategory::Other,\n                         }\n                     }\n-                },\n+                }\n                 _ => ConstraintCategory::Other,\n             }\n         };\n@@ -234,18 +265,21 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n         let path = constraints.iter().min_by_key(|p| p.len()).unwrap();\n         debug!(\"report_error: shortest_path={:?}\", path);\n \n-        let mut categorized_path = path.iter().filter_map(|index| {\n-            self.classify_constraint(index, mir)\n-        }).collect::<Vec<(ConstraintCategory, Span)>>();\n+        let mut categorized_path = path.iter()\n+            .filter_map(|index| self.classify_constraint(index, mir))\n+            .collect::<Vec<(ConstraintCategory, Span)>>();\n         debug!(\"report_error: categorized_path={:?}\", categorized_path);\n \n         categorized_path.sort_by(|p0, p1| p0.0.cmp(&p1.0));\n         debug!(\"report_error: sorted_path={:?}\", categorized_path);\n \n         if let Some((category, span)) = &categorized_path.first() {\n             let mut diag = infcx.tcx.sess.struct_span_err(\n-                *span, &format!(\"{} requires that data must outlive {}\",\n-                                category, outlived_fr_string),\n+                *span,\n+                &format!(\n+                    \"{} requires that data must outlive {}\",\n+                    category, outlived_fr_string\n+                ),\n             );\n \n             diag.emit();\n@@ -269,8 +303,11 @@ impl<'tcx> RegionInferenceContext<'tcx> {\n \n     /// Tries to finds a good span to blame for the fact that `fr1`\n     /// contains `fr2`.\n-    pub(super) fn blame_constraint(&self, fr1: RegionVid,\n-                                   elem: impl ToElementIndex) -> ConstraintIndex {\n+    pub(super) fn blame_constraint(\n+        &self,\n+        fr1: RegionVid,\n+        elem: impl ToElementIndex,\n+    ) -> ConstraintIndex {\n         // Find everything that influenced final value of `fr`.\n         let influenced_fr1 = self.dependencies(fr1);\n "}]}