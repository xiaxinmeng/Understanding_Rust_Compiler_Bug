{"sha": "d2d42fd4c746b10cffa4116ade9629340fdc4a5c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmQyZDQyZmQ0Yzc0NmIxMGNmZmE0MTE2YWRlOTYyOTM0MGZkYzRhNWM=", "commit": {"author": {"name": "Brian Anderson", "email": "andersrb@gmail.com", "date": "2011-04-06T03:42:33Z"}, "committer": {"name": "Brian Anderson", "email": "andersrb@gmail.com", "date": "2011-04-08T01:58:36Z"}, "message": "Make block results work for generic types\n\nI think just about every type can be used as a block result now. There's quite\na proliferation of tests here, but they all test slightly different things and\nsome are split out to remain XFAILed. The tests of generic vectors are still\nXFAILed because generic aliased boxes still don't work in general.", "tree": {"sha": "24ad8ee5b2bfb51da69e97d9c722c4773789444a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/24ad8ee5b2bfb51da69e97d9c722c4773789444a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/d2d42fd4c746b10cffa4116ade9629340fdc4a5c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/d2d42fd4c746b10cffa4116ade9629340fdc4a5c", "html_url": "https://github.com/rust-lang/rust/commit/d2d42fd4c746b10cffa4116ade9629340fdc4a5c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/d2d42fd4c746b10cffa4116ade9629340fdc4a5c/comments", "author": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brson", "id": 147214, "node_id": "MDQ6VXNlcjE0NzIxNA==", "avatar_url": "https://avatars.githubusercontent.com/u/147214?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brson", "html_url": "https://github.com/brson", "followers_url": "https://api.github.com/users/brson/followers", "following_url": "https://api.github.com/users/brson/following{/other_user}", "gists_url": "https://api.github.com/users/brson/gists{/gist_id}", "starred_url": "https://api.github.com/users/brson/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brson/subscriptions", "organizations_url": "https://api.github.com/users/brson/orgs", "repos_url": "https://api.github.com/users/brson/repos", "events_url": "https://api.github.com/users/brson/events{/privacy}", "received_events_url": "https://api.github.com/users/brson/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ed14ea1d3f4f12bc132fcf1bed3bcc0ac4b7da16", "url": "https://api.github.com/repos/rust-lang/rust/commits/ed14ea1d3f4f12bc132fcf1bed3bcc0ac4b7da16", "html_url": "https://github.com/rust-lang/rust/commit/ed14ea1d3f4f12bc132fcf1bed3bcc0ac4b7da16"}], "stats": {"total": 245, "additions": 191, "deletions": 54}, "files": [{"sha": "09dad4bc765a8413135a1301fc2d67508c07e2bd", "filename": "src/comp/middle/trans.rs", "status": "modified", "additions": 17, "deletions": 14, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/d2d42fd4c746b10cffa4116ade9629340fdc4a5c/src%2Fcomp%2Fmiddle%2Ftrans.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2d42fd4c746b10cffa4116ade9629340fdc4a5c/src%2Fcomp%2Fmiddle%2Ftrans.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftrans.rs?ref=d2d42fd4c746b10cffa4116ade9629340fdc4a5c", "patch": "@@ -5215,20 +5215,25 @@ fn init_local(@block_ctxt cx, @ast.local local) -> result {\n             }\n         }\n         case (_) {\n-            if (middle.ty.type_has_dynamic_size(ty)) {\n-                auto llsz = size_of(bcx, ty);\n-                bcx = call_bzero(llsz.bcx, llptr, llsz.val).bcx;\n-\n-            } else {\n-                auto llty = type_of(bcx.fcx.ccx, ty);\n-                auto null = lib.llvm.llvm.LLVMConstNull(llty);\n-                bcx.build.Store(null, llptr);\n-            }\n+            bcx = zero_alloca(bcx, llptr, ty).bcx;\n         }\n     }\n     ret res(bcx, llptr);\n }\n \n+fn zero_alloca(@block_ctxt cx, ValueRef llptr, @ty.t t) -> result {\n+    auto bcx = cx;\n+    if (ty.type_has_dynamic_size(t)) {\n+        auto llsz = size_of(bcx, t);\n+        bcx = call_bzero(llsz.bcx, llptr, llsz.val).bcx;\n+    } else {\n+        auto llty = type_of(bcx.fcx.ccx, t);\n+        auto null = lib.llvm.llvm.LLVMConstNull(llty);\n+        bcx.build.Store(null, llptr);\n+    }\n+    ret res(bcx, llptr);\n+ }\n+\n fn trans_stmt(@block_ctxt cx, &ast.stmt s) -> result {\n     auto bcx = cx;\n     alt (s.node) {\n@@ -5407,8 +5412,7 @@ fn trans_block(@block_ctxt cx, &ast.block b) -> result {\n                 ret r;\n             } else {\n                 auto r_ty = ty.expr_ty(e);\n-\n-                if (ty.type_is_boxed(r_ty)) {\n+                if (!ty.type_is_nil(r_ty)) {\n                     // The value resulting from the block gets copied into an\n                     // alloca created in an outer scope and its refcount\n                     // bumped so that it can escape this block. This means\n@@ -5424,9 +5428,8 @@ fn trans_block(@block_ctxt cx, &ast.block b) -> result {\n                     // NB: Here we're building and initalizing the alloca in\n                     // the alloca context, not this block's context.\n                     auto res_alloca = alloc_ty(bcx, r_ty);\n-                    auto alloca_ty = type_of(bcx.fcx.ccx, r_ty);\n-                    auto builder = new_builder(bcx.fcx.llallocas);\n-                    builder.Store(C_null(alloca_ty), res_alloca.val);\n+                    auto llbcx = llallocas_block_ctxt(bcx.fcx);\n+                    zero_alloca(llbcx, res_alloca.val, r_ty);\n \n                     // Now we're working in our own block context again\n                     auto res_copy = copy_ty(bcx, INIT,"}, {"sha": "314ae7fd88866c273df432fb65a2c5f793859d9b", "filename": "src/test/run-pass/expr-alt-generic-box1.rs", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/rust-lang/rust/blob/d2d42fd4c746b10cffa4116ade9629340fdc4a5c/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-box1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2d42fd4c746b10cffa4116ade9629340fdc4a5c/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-box1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-box1.rs?ref=d2d42fd4c746b10cffa4116ade9629340fdc4a5c", "patch": "@@ -0,0 +1,25 @@\n+// xfail-boot\n+// -*- rust -*-\n+\n+type compare[T] = fn(@T t1, @T t2) -> bool;\n+\n+fn test_generic[T](@T expected, &compare[T] eq) {\n+  let @T actual = alt (true) {\n+    case (true) {\n+      expected\n+    }\n+  };\n+  check (eq(expected, actual));\n+}\n+\n+fn test_box() {\n+  fn compare_box(@bool b1, @bool b2) -> bool {\n+    ret *b1 == b2;\n+  }\n+  auto eq = bind compare_box(_, _);\n+  test_generic[bool](@true, eq);\n+}\n+\n+fn main() {\n+  test_box();\n+}"}, {"sha": "196ceafcb4351f4f60f6f62c99055d78d3698dbf", "filename": "src/test/run-pass/expr-alt-generic-box2.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/d2d42fd4c746b10cffa4116ade9629340fdc4a5c/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-box2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2d42fd4c746b10cffa4116ade9629340fdc4a5c/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-box2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-alt-generic-box2.rs?ref=d2d42fd4c746b10cffa4116ade9629340fdc4a5c", "patch": "@@ -0,0 +1,26 @@\n+// xfail-boot\n+// xfail-stage0\n+// -*- rust -*-\n+\n+type compare[T] = fn(&T t1, &T t2) -> bool;\n+\n+fn test_generic[T](&T expected, &compare[T] eq) {\n+  let T actual = alt (true) {\n+    case (true) {\n+      expected\n+    }\n+  };\n+  check (eq(expected, actual));\n+}\n+\n+fn test_vec() {\n+  fn compare_vec(vec[int] v1, vec[int] v2) -> bool {\n+    ret v1 == v2;\n+  }\n+  auto eq = bind compare_vec(_, _);\n+  test_generic[vec[int]](vec(1, 2, 3), eq);\n+}\n+\n+fn main() {\n+  test_vec();\n+}"}, {"sha": "6668105955d9d8330d720bae66cb5b8acc43c35c", "filename": "src/test/run-pass/expr-alt-generic.rs", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/d2d42fd4c746b10cffa4116ade9629340fdc4a5c/src%2Ftest%2Frun-pass%2Fexpr-alt-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2d42fd4c746b10cffa4116ade9629340fdc4a5c/src%2Ftest%2Frun-pass%2Fexpr-alt-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-alt-generic.rs?ref=d2d42fd4c746b10cffa4116ade9629340fdc4a5c", "patch": "@@ -0,0 +1,35 @@\n+// xfail-boot\n+// -*- rust -*-\n+\n+type compare[T] = fn(&T t1, &T t2) -> bool;\n+\n+fn test_generic[T](&T expected, &compare[T] eq) {\n+  let T actual = alt (true) {\n+    case (true) {\n+      expected\n+    }\n+  };\n+  check (eq(expected, actual));\n+}\n+\n+fn test_bool() {\n+  fn compare_bool(&bool b1, &bool b2) -> bool {\n+    ret b1 == b2;\n+  }\n+  auto eq = bind compare_bool(_, _);\n+  test_generic[bool](true, eq);\n+}\n+\n+fn test_tup() {\n+  type t = tup(int, int);\n+  fn compare_tup(&t t1, &t t2) -> bool {\n+    ret t1 == t2;\n+  }\n+  auto eq = bind compare_tup(_, _);\n+  test_generic[t](tup(1, 2), eq);\n+}\n+\n+fn main() {\n+  test_bool();\n+  test_tup();\n+}\n\\ No newline at end of file"}, {"sha": "57487fd617d06dddbba092b6ac76937bb0bbf280", "filename": "src/test/run-pass/expr-block-generic-box1.rs", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/d2d42fd4c746b10cffa4116ade9629340fdc4a5c/src%2Ftest%2Frun-pass%2Fexpr-block-generic-box1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2d42fd4c746b10cffa4116ade9629340fdc4a5c/src%2Ftest%2Frun-pass%2Fexpr-block-generic-box1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-block-generic-box1.rs?ref=d2d42fd4c746b10cffa4116ade9629340fdc4a5c", "patch": "@@ -0,0 +1,23 @@\n+// xfail-boot\n+// -*- rust -*-\n+\n+type compare[T] = fn(@T t1, @T t2) -> bool;\n+\n+fn test_generic[T](@T expected, &compare[T] eq) {\n+  let @T actual = { expected };\n+  check (eq(expected, actual));\n+}\n+\n+fn test_box() {\n+  fn compare_box(@bool b1, @bool b2) -> bool {\n+    log *b1;\n+    log *b2;\n+    ret *b1 == *b2;\n+  }\n+  auto eq = bind compare_box(_, _);\n+  test_generic[bool](@true, eq);\n+}\n+\n+fn main() {\n+  test_box();\n+}\n\\ No newline at end of file"}, {"sha": "a129755db5873d57ef50aec3f7f8562faf3d380c", "filename": "src/test/run-pass/expr-block-generic-box2.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d2d42fd4c746b10cffa4116ade9629340fdc4a5c/src%2Ftest%2Frun-pass%2Fexpr-block-generic-box2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2d42fd4c746b10cffa4116ade9629340fdc4a5c/src%2Ftest%2Frun-pass%2Fexpr-block-generic-box2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-block-generic-box2.rs?ref=d2d42fd4c746b10cffa4116ade9629340fdc4a5c", "patch": "@@ -0,0 +1,22 @@\n+// xfail-boot\n+// xfail-stage0\n+// -*- rust -*-\n+\n+type compare[T] = fn(&T t1, &T t2) -> bool;\n+\n+fn test_generic[T](&T expected, &compare[T] eq) {\n+  let T actual = { expected };\n+  check (eq(expected, actual));\n+}\n+\n+fn test_vec() {\n+  fn compare_vec(&vec[int] v1, &vec[int] v2) -> bool {\n+    ret v1 == v2;\n+  }\n+  auto eq = bind compare_vec(_, _);\n+  test_generic[vec[int]](vec(1, 2), eq);\n+}\n+\n+fn main() {\n+  test_vec();\n+}\n\\ No newline at end of file"}, {"sha": "ded3b6207045b7b3a1530df3f755129ba021fbd9", "filename": "src/test/run-pass/expr-block-generic.rs", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d2d42fd4c746b10cffa4116ade9629340fdc4a5c/src%2Ftest%2Frun-pass%2Fexpr-block-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2d42fd4c746b10cffa4116ade9629340fdc4a5c/src%2Ftest%2Frun-pass%2Fexpr-block-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-block-generic.rs?ref=d2d42fd4c746b10cffa4116ade9629340fdc4a5c", "patch": "@@ -1,5 +1,4 @@\n // xfail-boot\n-// xfail-stage0\n // -*- rust -*-\n \n // Tests for standalone blocks as expressions with dynamic type sizes\n@@ -29,28 +28,9 @@ fn test_tup() {\n   test_generic[t](tup(1, 2), eq);\n }\n \n-fn test_vec() {\n-  fn compare_vec(&vec[int] v1, &vec[int] v2) -> bool {\n-    ret v1 == v2;\n-  }\n-  auto eq = bind compare_vec(_, _);\n-  test_generic[vec[int]](vec(1, 2), eq);\n-}\n-\n-fn test_box() {\n-  fn compare_box(&@bool b1, &@bool b2) -> bool {\n-    ret *b1 == *b2;\n-  }\n-  auto eq = bind compare_box(_, _);\n-  test_generic[@bool](@true, eq);\n-}\n-\n fn main() {\n   test_bool();\n   test_tup();\n-  // FIXME: These two don't pass yet\n-  test_vec();\n-  test_box();\n }\n \n "}, {"sha": "32aea8bb72f159ad0de33bbc92e48a139ff8d23a", "filename": "src/test/run-pass/expr-if-generic-box1.rs", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/d2d42fd4c746b10cffa4116ade9629340fdc4a5c/src%2Ftest%2Frun-pass%2Fexpr-if-generic-box1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2d42fd4c746b10cffa4116ade9629340fdc4a5c/src%2Ftest%2Frun-pass%2Fexpr-if-generic-box1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-if-generic-box1.rs?ref=d2d42fd4c746b10cffa4116ade9629340fdc4a5c", "patch": "@@ -0,0 +1,21 @@\n+// xfail-boot\n+// -*- rust -*-\n+\n+type compare[T] = fn(@T t1, @T t2) -> bool;\n+\n+fn test_generic[T](@T expected, @T not_expected, &compare[T] eq) {\n+  let @T actual = if (true) { expected } else { not_expected };\n+  check (eq(expected, actual));\n+}\n+\n+fn test_box() {\n+  fn compare_box(@bool b1, @bool b2) -> bool {\n+    ret *b1 == *b2;\n+  }\n+  auto eq = bind compare_box(_, _);\n+  test_generic[bool](@true, @false, eq);\n+}\n+\n+fn main() {\n+  test_box();\n+}\n\\ No newline at end of file"}, {"sha": "a1559cf9895c95d0bfd28af931e09b3bf8ec65ca", "filename": "src/test/run-pass/expr-if-generic-box2.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/d2d42fd4c746b10cffa4116ade9629340fdc4a5c/src%2Ftest%2Frun-pass%2Fexpr-if-generic-box2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2d42fd4c746b10cffa4116ade9629340fdc4a5c/src%2Ftest%2Frun-pass%2Fexpr-if-generic-box2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-if-generic-box2.rs?ref=d2d42fd4c746b10cffa4116ade9629340fdc4a5c", "patch": "@@ -0,0 +1,22 @@\n+// xfail-boot\n+// xfail-stage0\n+// -*- rust -*-\n+\n+type compare[T] = fn(&T t1, &T t2) -> bool;\n+\n+fn test_generic[T](&T expected, &T not_expected, &compare[T] eq) {\n+  let T actual = if (true) { expected } else { not_expected };\n+  check (eq(expected, actual));\n+}\n+\n+fn test_vec() {\n+  fn compare_vec(&vec[int] v1, &vec[int] v2) -> bool {\n+    ret v1 == v2;\n+  }\n+  auto eq = bind compare_vec(_, _);\n+  test_generic[vec[int]](vec(1, 2), vec(2, 3), eq);\n+}\n+\n+fn main() {\n+  test_vec();\n+}\n\\ No newline at end of file"}, {"sha": "0a0db2ddfde31fe8866c5405f9fa4c4d8335b7b1", "filename": "src/test/run-pass/expr-if-generic.rs", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/d2d42fd4c746b10cffa4116ade9629340fdc4a5c/src%2Ftest%2Frun-pass%2Fexpr-if-generic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/d2d42fd4c746b10cffa4116ade9629340fdc4a5c/src%2Ftest%2Frun-pass%2Fexpr-if-generic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fexpr-if-generic.rs?ref=d2d42fd4c746b10cffa4116ade9629340fdc4a5c", "patch": "@@ -1,5 +1,4 @@\n // xfail-boot\n-// xfail-stage0\n // -*- rust -*-\n \n // Tests for if as expressions with dynamic type sizes\n@@ -28,26 +27,7 @@ fn test_tup() {\n   test_generic[t](tup(1, 2), tup(2, 3), eq);\n }\n \n-fn test_vec() {\n-  fn compare_vec(&vec[int] v1, &vec[int] v2) -> bool {\n-    ret v1 == v2;\n-  }\n-  auto eq = bind compare_vec(_, _);\n-  test_generic[vec[int]](vec(1, 2), vec(2, 3), eq);\n-}\n-\n-fn test_box() {\n-  fn compare_box(&@bool b1, &@bool b2) -> bool {\n-    ret *b1 == *b2;\n-  }\n-  auto eq = bind compare_box(_, _);\n-  test_generic[@bool](@true, @false, eq);\n-}\n-\n fn main() {\n   test_bool();\n   test_tup();\n-  // FIXME: These two don't pass yet\n-  test_vec();\n-  test_box();\n }\n\\ No newline at end of file"}]}