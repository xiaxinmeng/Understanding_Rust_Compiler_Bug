{"sha": "941c4cd56bee9bc9f16eba7a7ab6c2b332da0f9f", "node_id": "MDY6Q29tbWl0NzI0NzEyOjk0MWM0Y2Q1NmJlZTliYzlmMTZlYmE3YTdhYjZjMmIzMzJkYTBmOWY=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-12-06T22:26:59Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-12-06T22:26:59Z"}, "message": "Rollup merge of #67052 - Centril:config-1, r=petrochenkov\n\nDitch `parse_in_attr`\n\nFixes #66940\n\nr? @petrochenkov", "tree": {"sha": "88407d3a1aeac319d4ca6025438cbb78bb14d6c5", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/88407d3a1aeac319d4ca6025438cbb78bb14d6c5"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/941c4cd56bee9bc9f16eba7a7ab6c2b332da0f9f", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJd6tWzCRBK7hj4Ov3rIwAAdHIIAAzy10vkSSBfUI9Kvm6HShLr\n+sFsUU+sMYbk45ynigp+UI78AWxvzj8fjF4XeXmRczn0pp8WdlL6krwmyAQjo91I\nHLPdQxZ3oX/et8d53n7e5J62SshHnmdeF00bSd0+twi6JfC+k0k9aOLLQJtnQmsu\nVt8La+5/cWeptjFlO3dE30XZebkxauHBKn5WClipA5BEWqD5xmhgfTfx6sRgE26V\nJPV+6Mj36rjm/mVVn6wVmsi0fwkLmGRNtdged1ccO5ykaMHXybqmEfe8R/kDH3U8\nOw7szJIADZUTVZvfDxVBf31zVqkzN/9grZVhHn+xsyRgNEN/kpCCDJoFu/6eVWM=\n=u5k7\n-----END PGP SIGNATURE-----\n", "payload": "tree 88407d3a1aeac319d4ca6025438cbb78bb14d6c5\nparent 99fee7896b9a5e8e21af1ba6787b21566e945d78\nparent 99191c2e717883bfec51b49df0e412a34849fc4a\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1575671219 +0100\ncommitter GitHub <noreply@github.com> 1575671219 +0100\n\nRollup merge of #67052 - Centril:config-1, r=petrochenkov\n\nDitch `parse_in_attr`\n\nFixes #66940\n\nr? @petrochenkov\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/941c4cd56bee9bc9f16eba7a7ab6c2b332da0f9f", "html_url": "https://github.com/rust-lang/rust/commit/941c4cd56bee9bc9f16eba7a7ab6c2b332da0f9f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/941c4cd56bee9bc9f16eba7a7ab6c2b332da0f9f/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "99fee7896b9a5e8e21af1ba6787b21566e945d78", "url": "https://api.github.com/repos/rust-lang/rust/commits/99fee7896b9a5e8e21af1ba6787b21566e945d78", "html_url": "https://github.com/rust-lang/rust/commit/99fee7896b9a5e8e21af1ba6787b21566e945d78"}, {"sha": "99191c2e717883bfec51b49df0e412a34849fc4a", "url": "https://api.github.com/repos/rust-lang/rust/commits/99191c2e717883bfec51b49df0e412a34849fc4a", "html_url": "https://github.com/rust-lang/rust/commit/99191c2e717883bfec51b49df0e412a34849fc4a"}], "stats": {"total": 491, "additions": 327, "deletions": 164}, "files": [{"sha": "1e9203f377f383b028978416b6f6c34d5b2a9788", "filename": "src/librustc_parse/config.rs", "status": "modified", "additions": 62, "deletions": 44, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/941c4cd56bee9bc9f16eba7a7ab6c2b332da0f9f/src%2Flibrustc_parse%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/941c4cd56bee9bc9f16eba7a7ab6c2b332da0f9f/src%2Flibrustc_parse%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fconfig.rs?ref=941c4cd56bee9bc9f16eba7a7ab6c2b332da0f9f", "patch": "@@ -8,18 +8,19 @@\n //!\n //! [#64197]: https://github.com/rust-lang/rust/issues/64197\n \n-use crate::validate_attr;\n+use crate::{parse_in, validate_attr};\n use rustc_feature::Features;\n use rustc_errors::Applicability;\n use syntax::attr::HasAttrs;\n use syntax::feature_gate::{feature_err, get_features};\n use syntax::attr;\n-use syntax::ast;\n+use syntax::ast::{self, Attribute, AttrItem, MetaItem};\n use syntax::edition::Edition;\n use syntax::mut_visit::*;\n use syntax::ptr::P;\n use syntax::sess::ParseSess;\n use syntax::util::map_in_place::MapInPlace;\n+use syntax_pos::Span;\n use syntax_pos::symbol::sym;\n \n use smallvec::SmallVec;\n@@ -72,6 +73,11 @@ macro_rules! configure {\n     }\n }\n \n+const CFG_ATTR_GRAMMAR_HELP: &str = \"#[cfg_attr(condition, attribute, other_attribute, ...)]\";\n+const CFG_ATTR_NOTE_REF: &str = \"for more information, visit \\\n+    <https://doc.rust-lang.org/reference/conditional-compilation.html\\\n+    #the-cfg_attr-attribute>\";\n+\n impl<'a> StripUnconfigured<'a> {\n     pub fn configure<T: HasAttrs>(&mut self, mut node: T) -> Option<T> {\n         self.process_cfg_attrs(&mut node);\n@@ -97,34 +103,14 @@ impl<'a> StripUnconfigured<'a> {\n     /// Gives a compiler warning when the `cfg_attr` contains no attributes and\n     /// is in the original source file. Gives a compiler error if the syntax of\n     /// the attribute is incorrect.\n-    fn process_cfg_attr(&mut self, attr: ast::Attribute) -> Vec<ast::Attribute> {\n+    fn process_cfg_attr(&mut self, attr: Attribute) -> Vec<Attribute> {\n         if !attr.has_name(sym::cfg_attr) {\n             return vec![attr];\n         }\n-        if let ast::MacArgs::Empty = attr.get_normal_item().args {\n-            self.sess.span_diagnostic\n-                .struct_span_err(\n-                    attr.span,\n-                    \"malformed `cfg_attr` attribute input\",\n-                ).span_suggestion(\n-                    attr.span,\n-                    \"missing condition and attribute\",\n-                    \"#[cfg_attr(condition, attribute, other_attribute, ...)]\".to_owned(),\n-                    Applicability::HasPlaceholders,\n-                ).note(\"for more information, visit \\\n-                       <https://doc.rust-lang.org/reference/conditional-compilation.html\\\n-                       #the-cfg_attr-attribute>\")\n-                .emit();\n-            return vec![];\n-        }\n \n-        let res = crate::parse_in_attr(self.sess, &attr, |p| p.parse_cfg_attr());\n-        let (cfg_predicate, expanded_attrs) = match res {\n-            Ok(result) => result,\n-            Err(mut e) => {\n-                e.emit();\n-                return vec![];\n-            }\n+        let (cfg_predicate, expanded_attrs) = match self.parse_cfg_attr(&attr) {\n+            None => return vec![],\n+            Some(r) => r,\n         };\n \n         // Lint on zero attributes in source.\n@@ -135,24 +121,56 @@ impl<'a> StripUnconfigured<'a> {\n         // At this point we know the attribute is considered used.\n         attr::mark_used(&attr);\n \n-        if attr::cfg_matches(&cfg_predicate, self.sess, self.features) {\n-            // We call `process_cfg_attr` recursively in case there's a\n-            // `cfg_attr` inside of another `cfg_attr`. E.g.\n-            //  `#[cfg_attr(false, cfg_attr(true, some_attr))]`.\n-            expanded_attrs.into_iter()\n-            .flat_map(|(item, span)| self.process_cfg_attr(attr::mk_attr_from_item(\n-                attr.style,\n-                item,\n-                span,\n-            )))\n+        if !attr::cfg_matches(&cfg_predicate, self.sess, self.features) {\n+            return vec![];\n+        }\n+\n+        // We call `process_cfg_attr` recursively in case there's a\n+        // `cfg_attr` inside of another `cfg_attr`. E.g.\n+        //  `#[cfg_attr(false, cfg_attr(true, some_attr))]`.\n+        expanded_attrs\n+            .into_iter()\n+            .flat_map(|(item, span)| {\n+                let attr = attr::mk_attr_from_item(attr.style, item, span);\n+                self.process_cfg_attr(attr)\n+            })\n             .collect()\n-        } else {\n-            vec![]\n+    }\n+\n+    fn parse_cfg_attr(&self, attr: &Attribute) -> Option<(MetaItem, Vec<(AttrItem, Span)>)> {\n+        match attr.get_normal_item().args {\n+            ast::MacArgs::Delimited(dspan, delim, ref tts) if !tts.is_empty() => {\n+                let msg = \"wrong `cfg_attr` delimiters\";\n+                validate_attr::check_meta_bad_delim(self.sess, dspan, delim, msg);\n+                match parse_in(self.sess, tts.clone(), \"`cfg_attr` input\", |p| p.parse_cfg_attr()) {\n+                    Ok(r) => return Some(r),\n+                    Err(mut e) => e\n+                        .help(&format!(\"the valid syntax is `{}`\", CFG_ATTR_GRAMMAR_HELP))\n+                        .note(CFG_ATTR_NOTE_REF)\n+                        .emit(),\n+                }\n+            }\n+            _ => self.error_malformed_cfg_attr_missing(attr.span),\n         }\n+        None\n+    }\n+\n+    fn error_malformed_cfg_attr_missing(&self, span: Span) {\n+        self.sess\n+            .span_diagnostic\n+            .struct_span_err(span, \"malformed `cfg_attr` attribute input\")\n+            .span_suggestion(\n+                span,\n+                \"missing condition and attribute\",\n+                CFG_ATTR_GRAMMAR_HELP.to_string(),\n+                Applicability::HasPlaceholders,\n+            )\n+            .note(CFG_ATTR_NOTE_REF)\n+            .emit();\n     }\n \n     /// Determines if a node with the given attributes should be included in this configuration.\n-    pub fn in_cfg(&self, attrs: &[ast::Attribute]) -> bool {\n+    pub fn in_cfg(&self, attrs: &[Attribute]) -> bool {\n         attrs.iter().all(|attr| {\n             if !is_cfg(attr) {\n                 return true;\n@@ -199,15 +217,15 @@ impl<'a> StripUnconfigured<'a> {\n     }\n \n     /// Visit attributes on expression and statements (but not attributes on items in blocks).\n-    fn visit_expr_attrs(&mut self, attrs: &[ast::Attribute]) {\n+    fn visit_expr_attrs(&mut self, attrs: &[Attribute]) {\n         // flag the offending attributes\n         for attr in attrs.iter() {\n             self.maybe_emit_expr_attr_err(attr);\n         }\n     }\n \n     /// If attributes are not allowed on expressions, emit an error for `attr`\n-    pub fn maybe_emit_expr_attr_err(&self, attr: &ast::Attribute) {\n+    pub fn maybe_emit_expr_attr_err(&self, attr: &Attribute) {\n         if !self.features.map(|features| features.stmt_expr_attributes).unwrap_or(true) {\n             let mut err = feature_err(self.sess,\n                                       sym::stmt_expr_attributes,\n@@ -350,7 +368,7 @@ impl<'a> MutVisitor for StripUnconfigured<'a> {\n     }\n }\n \n-fn is_cfg(attr: &ast::Attribute) -> bool {\n+fn is_cfg(attr: &Attribute) -> bool {\n     attr.check_name(sym::cfg)\n }\n \n@@ -359,8 +377,8 @@ fn is_cfg(attr: &ast::Attribute) -> bool {\n pub fn process_configure_mod(\n     sess: &ParseSess,\n     cfg_mods: bool,\n-    attrs: &[ast::Attribute],\n-) -> (bool, Vec<ast::Attribute>) {\n+    attrs: &[Attribute],\n+) -> (bool, Vec<Attribute>) {\n     // Don't perform gated feature checking.\n     let mut strip_unconfigured = StripUnconfigured { sess, features: None };\n     let mut attrs = attrs.to_owned();"}, {"sha": "faff386e9231826d42924eba891daf68bd0397dc", "filename": "src/librustc_parse/lib.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/941c4cd56bee9bc9f16eba7a7ab6c2b332da0f9f/src%2Flibrustc_parse%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/941c4cd56bee9bc9f16eba7a7ab6c2b332da0f9f/src%2Flibrustc_parse%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Flib.rs?ref=941c4cd56bee9bc9f16eba7a7ab6c2b332da0f9f", "patch": "@@ -271,21 +271,13 @@ pub fn stream_to_parser_with_base_dir<'a>(\n }\n \n /// Runs the given subparser `f` on the tokens of the given `attr`'s item.\n-pub fn parse_in_attr<'a, T>(\n+pub fn parse_in<'a, T>(\n     sess: &'a ParseSess,\n-    attr: &ast::Attribute,\n+    tts: TokenStream,\n+    name: &'static str,\n     mut f: impl FnMut(&mut Parser<'a>) -> PResult<'a, T>,\n ) -> PResult<'a, T> {\n-    let mut parser = Parser::new(\n-        sess,\n-        // FIXME(#66940, Centril | petrochenkov): refactor this function so it doesn't\n-        // require reconstructing and immediately re-parsing delimiters.\n-        attr.get_normal_item().args.outer_tokens(),\n-        None,\n-        false,\n-        false,\n-        Some(\"attribute\"),\n-    );\n+    let mut parser = Parser::new(sess, tts, None, false, false, Some(name));\n     let result = f(&mut parser)?;\n     if parser.token != token::Eof {\n         parser.unexpected()?;"}, {"sha": "00fd6b8a25bc3df5ec298423cb17789dd135de58", "filename": "src/librustc_parse/parser/attr.rs", "status": "modified", "additions": 20, "deletions": 9, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/941c4cd56bee9bc9f16eba7a7ab6c2b332da0f9f/src%2Flibrustc_parse%2Fparser%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/941c4cd56bee9bc9f16eba7a7ab6c2b332da0f9f/src%2Flibrustc_parse%2Fparser%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fattr.rs?ref=941c4cd56bee9bc9f16eba7a7ab6c2b332da0f9f", "patch": "@@ -220,7 +220,7 @@ impl<'a> Parser<'a> {\n         Ok(attrs)\n     }\n \n-    pub(super) fn parse_unsuffixed_lit(&mut self) -> PResult<'a, ast::Lit> {\n+    crate fn parse_unsuffixed_lit(&mut self) -> PResult<'a, ast::Lit> {\n         let lit = self.parse_lit()?;\n         debug!(\"checking if {:?} is unusuffixed\", lit);\n \n@@ -238,25 +238,36 @@ impl<'a> Parser<'a> {\n \n     /// Parses `cfg_attr(pred, attr_item_list)` where `attr_item_list` is comma-delimited.\n     pub fn parse_cfg_attr(&mut self) -> PResult<'a, (ast::MetaItem, Vec<(ast::AttrItem, Span)>)> {\n-        self.expect(&token::OpenDelim(token::Paren))?;\n-\n         let cfg_predicate = self.parse_meta_item()?;\n         self.expect(&token::Comma)?;\n \n         // Presumably, the majority of the time there will only be one attr.\n         let mut expanded_attrs = Vec::with_capacity(1);\n-\n-        while !self.check(&token::CloseDelim(token::Paren)) {\n-            let lo = self.token.span.lo();\n+        while self.token.kind != token::Eof {\n+            let lo = self.token.span;\n             let item = self.parse_attr_item()?;\n-            expanded_attrs.push((item, self.prev_span.with_lo(lo)));\n-            self.expect_one_of(&[token::Comma], &[token::CloseDelim(token::Paren)])?;\n+            expanded_attrs.push((item, lo.to(self.prev_span)));\n+            if !self.eat(&token::Comma) {\n+                break;\n+            }\n         }\n \n-        self.expect(&token::CloseDelim(token::Paren))?;\n         Ok((cfg_predicate, expanded_attrs))\n     }\n \n+    /// Matches `COMMASEP(meta_item_inner)`.\n+    crate fn parse_meta_seq_top(&mut self) -> PResult<'a, Vec<ast::NestedMetaItem>> {\n+        // Presumably, the majority of the time there will only be one attr.\n+        let mut nmis = Vec::with_capacity(1);\n+        while self.token.kind != token::Eof {\n+            nmis.push(self.parse_meta_item_inner()?);\n+            if !self.eat(&token::Comma) {\n+                break;\n+            }\n+        }\n+        Ok(nmis)\n+    }\n+\n     /// Matches the following grammar (per RFC 1559).\n     ///\n     ///     meta_item : PATH ( '=' UNSUFFIXED_LIT | '(' meta_item_inner? ')' )? ;"}, {"sha": "5334fc485e7a63a26d8aba09e1a173f28ed16a82", "filename": "src/librustc_parse/parser/path.rs", "status": "modified", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/941c4cd56bee9bc9f16eba7a7ab6c2b332da0f9f/src%2Flibrustc_parse%2Fparser%2Fpath.rs", "raw_url": "https://github.com/rust-lang/rust/raw/941c4cd56bee9bc9f16eba7a7ab6c2b332da0f9f/src%2Flibrustc_parse%2Fparser%2Fpath.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fpath.rs?ref=941c4cd56bee9bc9f16eba7a7ab6c2b332da0f9f", "patch": "@@ -3,7 +3,6 @@ use crate::maybe_whole;\n use rustc_errors::{PResult, Applicability, pluralize};\n use syntax::ast::{self, QSelf, Path, PathSegment, Ident, ParenthesizedArgs, AngleBracketedArgs};\n use syntax::ast::{AnonConst, GenericArg, AssocTyConstraint, AssocTyConstraintKind, BlockCheckMode};\n-use syntax::ast::MacArgs;\n use syntax::ThinVec;\n use syntax::token::{self, Token};\n use syntax_pos::source_map::{Span, BytePos};\n@@ -109,42 +108,6 @@ impl<'a> Parser<'a> {\n         Ok(Path { segments, span: lo.to(self.prev_span) })\n     }\n \n-    /// Like `parse_path`, but also supports parsing `Word` meta items into paths for\n-    /// backwards-compatibility. This is used when parsing derive macro paths in `#[derive]`\n-    /// attributes.\n-    fn parse_path_allowing_meta(&mut self, style: PathStyle) -> PResult<'a, Path> {\n-        let meta_ident = match self.token.kind {\n-            token::Interpolated(ref nt) => match **nt {\n-                token::NtMeta(ref item) => match item.args {\n-                    MacArgs::Empty => Some(item.path.clone()),\n-                    _ => None,\n-                },\n-                _ => None,\n-            },\n-            _ => None,\n-        };\n-        if let Some(path) = meta_ident {\n-            self.bump();\n-            return Ok(path);\n-        }\n-        self.parse_path(style)\n-    }\n-\n-    /// Parse a list of paths inside `#[derive(path_0, ..., path_n)]`.\n-    pub fn parse_derive_paths(&mut self) -> PResult<'a, Vec<Path>> {\n-        self.expect(&token::OpenDelim(token::Paren))?;\n-        let mut list = Vec::new();\n-        while !self.eat(&token::CloseDelim(token::Paren)) {\n-            let path = self.parse_path_allowing_meta(PathStyle::Mod)?;\n-            list.push(path);\n-            if !self.eat(&token::Comma) {\n-                self.expect(&token::CloseDelim(token::Paren))?;\n-                break\n-            }\n-        }\n-        Ok(list)\n-    }\n-\n     pub(super) fn parse_path_segments(\n         &mut self,\n         segments: &mut Vec<PathSegment>,"}, {"sha": "94d3fe7b55167e65b69ffc5c9a5819c56106a0f1", "filename": "src/librustc_parse/validate_attr.rs", "status": "modified", "additions": 35, "deletions": 3, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/941c4cd56bee9bc9f16eba7a7ab6c2b332da0f9f/src%2Flibrustc_parse%2Fvalidate_attr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/941c4cd56bee9bc9f16eba7a7ab6c2b332da0f9f/src%2Flibrustc_parse%2Fvalidate_attr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fvalidate_attr.rs?ref=941c4cd56bee9bc9f16eba7a7ab6c2b332da0f9f", "patch": "@@ -1,10 +1,13 @@\n //! Meta-syntax validation logic of attributes for post-expansion.\n \n+use crate::parse_in;\n+\n use rustc_errors::{PResult, Applicability};\n use rustc_feature::{AttributeTemplate, BUILTIN_ATTRIBUTE_MAP};\n-use syntax::ast::{self, Attribute, AttrKind, Ident, MacArgs, MetaItem, MetaItemKind};\n+use syntax::ast::{self, Attribute, AttrKind, Ident, MacArgs, MacDelimiter, MetaItem, MetaItemKind};\n use syntax::attr::mk_name_value_item_str;\n use syntax::early_buffered_lints::ILL_FORMED_ATTRIBUTE_INPUT;\n+use syntax::tokenstream::DelimSpan;\n use syntax::sess::ParseSess;\n use syntax_pos::{Symbol, sym};\n \n@@ -27,16 +30,45 @@ pub fn check_meta(sess: &ParseSess, attr: &Attribute) {\n pub fn parse_meta<'a>(sess: &'a ParseSess, attr: &Attribute) -> PResult<'a, MetaItem> {\n     Ok(match attr.kind {\n         AttrKind::Normal(ref item) => MetaItem {\n-            path: item.path.clone(),\n-            kind: super::parse_in_attr(sess, attr, |p| p.parse_meta_item_kind())?,\n             span: attr.span,\n+            path: item.path.clone(),\n+            kind: match &attr.get_normal_item().args {\n+                MacArgs::Empty => MetaItemKind::Word,\n+                MacArgs::Eq(_, t) => {\n+                    let v = parse_in(sess, t.clone(), \"name value\", |p| p.parse_unsuffixed_lit())?;\n+                    MetaItemKind::NameValue(v)\n+                }\n+                MacArgs::Delimited(dspan, delim, t) => {\n+                    check_meta_bad_delim(sess, *dspan, *delim, \"wrong meta list delimiters\");\n+                    let nmis = parse_in(sess, t.clone(), \"meta list\", |p| p.parse_meta_seq_top())?;\n+                    MetaItemKind::List(nmis)\n+                }\n+            }\n         },\n         AttrKind::DocComment(comment) => {\n             mk_name_value_item_str(Ident::new(sym::doc, attr.span), comment, attr.span)\n         }\n     })\n }\n \n+crate fn check_meta_bad_delim(sess: &ParseSess, span: DelimSpan, delim: MacDelimiter, msg: &str) {\n+    if let ast::MacDelimiter::Parenthesis = delim {\n+        return;\n+    }\n+\n+    sess.span_diagnostic\n+        .struct_span_err(span.entire(), msg)\n+        .multipart_suggestion(\n+            \"the delimiters should be `(` and `)`\",\n+            vec![\n+                (span.open, \"(\".to_string()),\n+                (span.close, \")\".to_string()),\n+            ],\n+            Applicability::MachineApplicable,\n+        )\n+        .emit();\n+}\n+\n /// Checks that the given meta-item is compatible with this `AttributeTemplate`.\n fn is_attr_template_compatible(template: &AttributeTemplate, meta: &ast::MetaItemKind) -> bool {\n     match meta {"}, {"sha": "520488c658676bfc07e179951269d44458e4f0a2", "filename": "src/libsyntax_expand/proc_macro.rs", "status": "modified", "additions": 62, "deletions": 25, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/941c4cd56bee9bc9f16eba7a7ab6c2b332da0f9f/src%2Flibsyntax_expand%2Fproc_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/941c4cd56bee9bc9f16eba7a7ab6c2b332da0f9f/src%2Flibsyntax_expand%2Fproc_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax_expand%2Fproc_macro.rs?ref=941c4cd56bee9bc9f16eba7a7ab6c2b332da0f9f", "patch": "@@ -1,7 +1,7 @@\n use crate::base::{self, *};\n use crate::proc_macro_server;\n \n-use syntax::ast::{self, ItemKind, MacArgs};\n+use syntax::ast::{self, ItemKind, MetaItemKind, NestedMetaItem};\n use syntax::errors::{Applicability, FatalError};\n use syntax::symbol::sym;\n use syntax::token;\n@@ -171,34 +171,71 @@ crate fn collect_derives(cx: &mut ExtCtxt<'_>, attrs: &mut Vec<ast::Attribute>)\n         if !attr.has_name(sym::derive) {\n             return true;\n         }\n-        if !attr.is_meta_item_list() {\n-            cx.struct_span_err(attr.span, \"malformed `derive` attribute input\")\n-                .span_suggestion(\n-                    attr.span,\n-                    \"missing traits to be derived\",\n-                    \"#[derive(Trait1, Trait2, ...)]\".to_owned(),\n-                    Applicability::HasPlaceholders,\n-                ).emit();\n-            return false;\n-        }\n \n-        let parse_derive_paths = |attr: &ast::Attribute| {\n-            if let MacArgs::Empty = attr.get_normal_item().args {\n-                return Ok(Vec::new());\n+        // 1) First let's ensure that it's a meta item.\n+        let nmis = match attr.meta_item_list() {\n+            None => {\n+                cx.struct_span_err(attr.span, \"malformed `derive` attribute input\")\n+                    .span_suggestion(\n+                        attr.span,\n+                        \"missing traits to be derived\",\n+                        \"#[derive(Trait1, Trait2, ...)]\".to_owned(),\n+                        Applicability::HasPlaceholders,\n+                    )\n+                    .emit();\n+                return false;\n             }\n-            rustc_parse::parse_in_attr(cx.parse_sess, attr, |p| p.parse_derive_paths())\n+            Some(x) => x,\n         };\n \n-        match parse_derive_paths(attr) {\n-            Ok(traits) => {\n-                result.extend(traits);\n-                true\n-            }\n-            Err(mut e) => {\n-                e.emit();\n-                false\n-            }\n-        }\n+        let mut error_reported_filter_map = false;\n+        let mut error_reported_map = false;\n+        let traits = nmis\n+            .into_iter()\n+            // 2) Moreover, let's ensure we have a path and not `#[derive(\"foo\")]`.\n+            .filter_map(|nmi| match nmi {\n+                NestedMetaItem::Literal(lit) => {\n+                    error_reported_filter_map = true;\n+                    cx.struct_span_err(lit.span, \"expected path to a trait, found literal\")\n+                        .help(\"for example, write `#[derive(Debug)]` for `Debug`\")\n+                        .emit();\n+                    None\n+                }\n+                NestedMetaItem::MetaItem(mi) => Some(mi),\n+            })\n+            // 3) Finally, we only accept `#[derive($path_0, $path_1, ..)]`\n+            // but not e.g. `#[derive($path_0 = \"value\", $path_1(abc))]`.\n+            // In this case we can still at least determine that the user\n+            // wanted this trait to be derived, so let's keep it.\n+            .map(|mi| {\n+                let mut traits_dont_accept = |title, action| {\n+                    error_reported_map = true;\n+                    let sp = mi.span.with_lo(mi.path.span.hi());\n+                    cx.struct_span_err(sp, title)\n+                        .span_suggestion(\n+                            sp,\n+                            action,\n+                            String::new(),\n+                            Applicability::MachineApplicable,\n+                        )\n+                        .emit();\n+                };\n+                match &mi.kind {\n+                    MetaItemKind::List(..) => traits_dont_accept(\n+                        \"traits in `#[derive(...)]` don't accept arguments\",\n+                        \"remove the arguments\",\n+                    ),\n+                    MetaItemKind::NameValue(..) => traits_dont_accept(\n+                        \"traits in `#[derive(...)]` don't accept values\",\n+                        \"remove the value\",\n+                    ),\n+                    MetaItemKind::Word => {}\n+                }\n+                mi.path\n+            });\n+\n+        result.extend(traits);\n+        !error_reported_filter_map && !error_reported_map\n     });\n     result\n }"}, {"sha": "8ca31c118369c23f9db2f495676bcb647f5f61ae", "filename": "src/test/ui/conditional-compilation/cfg-attr-parse.rs", "status": "modified", "additions": 14, "deletions": 2, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/941c4cd56bee9bc9f16eba7a7ab6c2b332da0f9f/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-attr-parse.rs", "raw_url": "https://github.com/rust-lang/rust/raw/941c4cd56bee9bc9f16eba7a7ab6c2b332da0f9f/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-attr-parse.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-attr-parse.rs?ref=941c4cd56bee9bc9f16eba7a7ab6c2b332da0f9f", "patch": "@@ -1,11 +1,11 @@\n // Parse `cfg_attr` with varying numbers of attributes and trailing commas\n \n // Completely empty `cfg_attr` input\n-#[cfg_attr()] //~ error: expected identifier, found `)`\n+#[cfg_attr()] //~ error: malformed `cfg_attr` attribute input\n struct NoConfigurationPredicate;\n \n // Zero attributes, zero trailing comma (comma manatory here)\n-#[cfg_attr(all())] //~ error: expected `,`, found `)`\n+#[cfg_attr(all())] //~ error: expected `,`, found end of `cfg_attr`\n struct A0C0;\n \n // Zero attributes, one trailing comma\n@@ -40,4 +40,16 @@ struct A2C1;\n #[cfg_attr(all(), must_use, deprecated,,)] //~ ERROR expected identifier\n struct A2C2;\n \n+// Wrong delimiter `[`\n+#[cfg_attr[all(),,]]\n+//~^ ERROR wrong `cfg_attr` delimiters\n+//~| ERROR expected identifier, found `,`\n+struct BracketZero;\n+\n+// Wrong delimiter `{`\n+#[cfg_attr{all(),,}]\n+//~^ ERROR wrong `cfg_attr` delimiters\n+//~| ERROR expected identifier, found `,`\n+struct BraceZero;\n+\n fn main() {}"}, {"sha": "3a590d3282d46b04bfba865e320b69270e4b45d8", "filename": "src/test/ui/conditional-compilation/cfg-attr-parse.stderr", "status": "modified", "additions": 59, "deletions": 5, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/941c4cd56bee9bc9f16eba7a7ab6c2b332da0f9f/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-attr-parse.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/941c4cd56bee9bc9f16eba7a7ab6c2b332da0f9f/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-attr-parse.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconditional-compilation%2Fcfg-attr-parse.stderr?ref=941c4cd56bee9bc9f16eba7a7ab6c2b332da0f9f", "patch": "@@ -1,32 +1,86 @@\n-error: expected identifier, found `)`\n-  --> $DIR/cfg-attr-parse.rs:4:12\n+error: malformed `cfg_attr` attribute input\n+  --> $DIR/cfg-attr-parse.rs:4:1\n    |\n LL | #[cfg_attr()]\n-   |            ^ expected identifier\n+   | ^^^^^^^^^^^^^ help: missing condition and attribute: `#[cfg_attr(condition, attribute, other_attribute, ...)]`\n+   |\n+   = note: for more information, visit <https://doc.rust-lang.org/reference/conditional-compilation.html#the-cfg_attr-attribute>\n \n-error: expected `,`, found `)`\n+error: expected `,`, found end of `cfg_attr` input\n   --> $DIR/cfg-attr-parse.rs:8:17\n    |\n LL | #[cfg_attr(all())]\n    |                 ^ expected `,`\n+   |\n+   = help: the valid syntax is `#[cfg_attr(condition, attribute, other_attribute, ...)]`\n+   = note: for more information, visit <https://doc.rust-lang.org/reference/conditional-compilation.html#the-cfg_attr-attribute>\n \n error: expected identifier, found `,`\n   --> $DIR/cfg-attr-parse.rs:16:18\n    |\n LL | #[cfg_attr(all(),,)]\n    |                  ^ expected identifier\n+   |\n+   = help: the valid syntax is `#[cfg_attr(condition, attribute, other_attribute, ...)]`\n+   = note: for more information, visit <https://doc.rust-lang.org/reference/conditional-compilation.html#the-cfg_attr-attribute>\n \n error: expected identifier, found `,`\n   --> $DIR/cfg-attr-parse.rs:28:28\n    |\n LL | #[cfg_attr(all(), must_use,,)]\n    |                            ^ expected identifier\n+   |\n+   = help: the valid syntax is `#[cfg_attr(condition, attribute, other_attribute, ...)]`\n+   = note: for more information, visit <https://doc.rust-lang.org/reference/conditional-compilation.html#the-cfg_attr-attribute>\n \n error: expected identifier, found `,`\n   --> $DIR/cfg-attr-parse.rs:40:40\n    |\n LL | #[cfg_attr(all(), must_use, deprecated,,)]\n    |                                        ^ expected identifier\n+   |\n+   = help: the valid syntax is `#[cfg_attr(condition, attribute, other_attribute, ...)]`\n+   = note: for more information, visit <https://doc.rust-lang.org/reference/conditional-compilation.html#the-cfg_attr-attribute>\n+\n+error: wrong `cfg_attr` delimiters\n+  --> $DIR/cfg-attr-parse.rs:44:11\n+   |\n+LL | #[cfg_attr[all(),,]]\n+   |           ^^^^^^^^^\n+   |\n+help: the delimiters should be `(` and `)`\n+   |\n+LL | #[cfg_attr(all(),,)]\n+   |           ^       ^\n+\n+error: expected identifier, found `,`\n+  --> $DIR/cfg-attr-parse.rs:44:18\n+   |\n+LL | #[cfg_attr[all(),,]]\n+   |                  ^ expected identifier\n+   |\n+   = help: the valid syntax is `#[cfg_attr(condition, attribute, other_attribute, ...)]`\n+   = note: for more information, visit <https://doc.rust-lang.org/reference/conditional-compilation.html#the-cfg_attr-attribute>\n+\n+error: wrong `cfg_attr` delimiters\n+  --> $DIR/cfg-attr-parse.rs:50:11\n+   |\n+LL | #[cfg_attr{all(),,}]\n+   |           ^^^^^^^^^\n+   |\n+help: the delimiters should be `(` and `)`\n+   |\n+LL | #[cfg_attr(all(),,)]\n+   |           ^       ^\n+\n+error: expected identifier, found `,`\n+  --> $DIR/cfg-attr-parse.rs:50:18\n+   |\n+LL | #[cfg_attr{all(),,}]\n+   |                  ^ expected identifier\n+   |\n+   = help: the valid syntax is `#[cfg_attr(condition, attribute, other_attribute, ...)]`\n+   = note: for more information, visit <https://doc.rust-lang.org/reference/conditional-compilation.html#the-cfg_attr-attribute>\n \n-error: aborting due to 5 previous errors\n+error: aborting due to 9 previous errors\n "}, {"sha": "77fa2f566a8fc1524bd5d61ea5e58e23d1392387", "filename": "src/test/ui/malformed/malformed-derive-entry.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/941c4cd56bee9bc9f16eba7a7ab6c2b332da0f9f/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-derive-entry.rs", "raw_url": "https://github.com/rust-lang/rust/raw/941c4cd56bee9bc9f16eba7a7ab6c2b332da0f9f/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-derive-entry.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-derive-entry.rs?ref=941c4cd56bee9bc9f16eba7a7ab6c2b332da0f9f", "patch": "@@ -1,7 +1,11 @@\n-#[derive(Copy(Bad))] //~ ERROR expected one of `)`, `,`, or `::`, found `(`\n+#[derive(Copy(Bad))]\n+//~^ ERROR traits in `#[derive(...)]` don't accept arguments\n+//~| ERROR the trait bound\n struct Test1;\n \n-#[derive(Copy=\"bad\")] //~ ERROR expected one of `)`, `,`, or `::`, found `=`\n+#[derive(Copy=\"bad\")]\n+//~^ ERROR traits in `#[derive(...)]` don't accept values\n+//~| ERROR the trait bound\n struct Test2;\n \n #[derive] //~ ERROR malformed `derive` attribute input"}, {"sha": "1f1ee39b049e309a35cbfe14139458ff15b14f28", "filename": "src/test/ui/malformed/malformed-derive-entry.stderr", "status": "modified", "additions": 20, "deletions": 7, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/941c4cd56bee9bc9f16eba7a7ab6c2b332da0f9f/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-derive-entry.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/941c4cd56bee9bc9f16eba7a7ab6c2b332da0f9f/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-derive-entry.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-derive-entry.stderr?ref=941c4cd56bee9bc9f16eba7a7ab6c2b332da0f9f", "patch": "@@ -1,20 +1,33 @@\n-error: expected one of `)`, `,`, or `::`, found `(`\n+error: traits in `#[derive(...)]` don't accept arguments\n   --> $DIR/malformed-derive-entry.rs:1:14\n    |\n LL | #[derive(Copy(Bad))]\n-   |              ^ expected one of `)`, `,`, or `::`\n+   |              ^^^^^ help: remove the arguments\n \n-error: expected one of `)`, `,`, or `::`, found `=`\n-  --> $DIR/malformed-derive-entry.rs:4:14\n+error: traits in `#[derive(...)]` don't accept values\n+  --> $DIR/malformed-derive-entry.rs:6:14\n    |\n LL | #[derive(Copy=\"bad\")]\n-   |              ^ expected one of `)`, `,`, or `::`\n+   |              ^^^^^^ help: remove the value\n \n error: malformed `derive` attribute input\n-  --> $DIR/malformed-derive-entry.rs:7:1\n+  --> $DIR/malformed-derive-entry.rs:11:1\n    |\n LL | #[derive]\n    | ^^^^^^^^^ help: missing traits to be derived: `#[derive(Trait1, Trait2, ...)]`\n \n-error: aborting due to 3 previous errors\n+error[E0277]: the trait bound `Test1: std::clone::Clone` is not satisfied\n+  --> $DIR/malformed-derive-entry.rs:1:10\n+   |\n+LL | #[derive(Copy(Bad))]\n+   |          ^^^^ the trait `std::clone::Clone` is not implemented for `Test1`\n+\n+error[E0277]: the trait bound `Test2: std::clone::Clone` is not satisfied\n+  --> $DIR/malformed-derive-entry.rs:6:10\n+   |\n+LL | #[derive(Copy=\"bad\")]\n+   |          ^^^^ the trait `std::clone::Clone` is not implemented for `Test2`\n+\n+error: aborting due to 5 previous errors\n \n+For more information about this error, try `rustc --explain E0277`."}, {"sha": "5b1614b69a92b6bc482cefece3f57456a12f05bc", "filename": "src/test/ui/malformed/malformed-meta-delim.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/941c4cd56bee9bc9f16eba7a7ab6c2b332da0f9f/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-meta-delim.rs", "raw_url": "https://github.com/rust-lang/rust/raw/941c4cd56bee9bc9f16eba7a7ab6c2b332da0f9f/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-meta-delim.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-meta-delim.rs?ref=941c4cd56bee9bc9f16eba7a7ab6c2b332da0f9f", "patch": "@@ -0,0 +1,11 @@\n+fn main() {}\n+\n+#[allow { foo_lint } ]\n+//~^ ERROR wrong meta list delimiters\n+//~| HELP the delimiters should be `(` and `)`\n+fn delim_brace() {}\n+\n+#[allow [ foo_lint ] ]\n+//~^ ERROR wrong meta list delimiters\n+//~| HELP the delimiters should be `(` and `)`\n+fn delim_bracket() {}"}, {"sha": "407193d4adebbd8784daf89623206769a145e5f5", "filename": "src/test/ui/malformed/malformed-meta-delim.stderr", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/941c4cd56bee9bc9f16eba7a7ab6c2b332da0f9f/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-meta-delim.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/941c4cd56bee9bc9f16eba7a7ab6c2b332da0f9f/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-meta-delim.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-meta-delim.stderr?ref=941c4cd56bee9bc9f16eba7a7ab6c2b332da0f9f", "patch": "@@ -0,0 +1,24 @@\n+error: wrong meta list delimiters\n+  --> $DIR/malformed-meta-delim.rs:3:9\n+   |\n+LL | #[allow { foo_lint } ]\n+   |         ^^^^^^^^^^^^\n+   |\n+help: the delimiters should be `(` and `)`\n+   |\n+LL | #[allow ( foo_lint ) ]\n+   |         ^          ^\n+\n+error: wrong meta list delimiters\n+  --> $DIR/malformed-meta-delim.rs:8:9\n+   |\n+LL | #[allow [ foo_lint ] ]\n+   |         ^^^^^^^^^^^^\n+   |\n+help: the delimiters should be `(` and `)`\n+   |\n+LL | #[allow ( foo_lint ) ]\n+   |         ^          ^\n+\n+error: aborting due to 2 previous errors\n+"}, {"sha": "05b7ebe4666622c61f309087e983617db31c5dbc", "filename": "src/test/ui/malformed/malformed-special-attrs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/941c4cd56bee9bc9f16eba7a7ab6c2b332da0f9f/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-special-attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/941c4cd56bee9bc9f16eba7a7ab6c2b332da0f9f/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-special-attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-special-attrs.rs?ref=941c4cd56bee9bc9f16eba7a7ab6c2b332da0f9f", "patch": "@@ -1,7 +1,7 @@\n #[cfg_attr] //~ ERROR malformed `cfg_attr` attribute\n struct S1;\n \n-#[cfg_attr = \"\"] //~ ERROR expected `(`, found `=`\n+#[cfg_attr = \"\"] //~ ERROR malformed `cfg_attr` attribute\n struct S2;\n \n #[derive] //~ ERROR malformed `derive` attribute"}, {"sha": "6f535e03e6aec31035d8bd73b56231aaebeaad30", "filename": "src/test/ui/malformed/malformed-special-attrs.stderr", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/941c4cd56bee9bc9f16eba7a7ab6c2b332da0f9f/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-special-attrs.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/941c4cd56bee9bc9f16eba7a7ab6c2b332da0f9f/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-special-attrs.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmalformed%2Fmalformed-special-attrs.stderr?ref=941c4cd56bee9bc9f16eba7a7ab6c2b332da0f9f", "patch": "@@ -6,11 +6,13 @@ LL | #[cfg_attr]\n    |\n    = note: for more information, visit <https://doc.rust-lang.org/reference/conditional-compilation.html#the-cfg_attr-attribute>\n \n-error: expected `(`, found `=`\n-  --> $DIR/malformed-special-attrs.rs:4:12\n+error: malformed `cfg_attr` attribute input\n+  --> $DIR/malformed-special-attrs.rs:4:1\n    |\n LL | #[cfg_attr = \"\"]\n-   |            ^ expected `(`\n+   | ^^^^^^^^^^^^^^^^ help: missing condition and attribute: `#[cfg_attr(condition, attribute, other_attribute, ...)]`\n+   |\n+   = note: for more information, visit <https://doc.rust-lang.org/reference/conditional-compilation.html#the-cfg_attr-attribute>\n \n error: malformed `derive` attribute input\n   --> $DIR/malformed-special-attrs.rs:7:1"}, {"sha": "8fb34f21152ab513fb1a3cfb2daeeedaee6e2e9e", "filename": "src/test/ui/on-unimplemented/expected-comma-found-token.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/941c4cd56bee9bc9f16eba7a7ab6c2b332da0f9f/src%2Ftest%2Fui%2Fon-unimplemented%2Fexpected-comma-found-token.rs", "raw_url": "https://github.com/rust-lang/rust/raw/941c4cd56bee9bc9f16eba7a7ab6c2b332da0f9f/src%2Ftest%2Fui%2Fon-unimplemented%2Fexpected-comma-found-token.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fon-unimplemented%2Fexpected-comma-found-token.rs?ref=941c4cd56bee9bc9f16eba7a7ab6c2b332da0f9f", "patch": "@@ -6,7 +6,7 @@\n \n #[rustc_on_unimplemented(\n     message=\"the message\"\n-    label=\"the label\" //~ ERROR expected one of `)` or `,`, found `label`\n+    label=\"the label\" //~ ERROR expected `,`, found `label`\n )]\n trait T {}\n "}, {"sha": "048b72ee3bcdff21f184fc6b1bb5df22a5471ccb", "filename": "src/test/ui/on-unimplemented/expected-comma-found-token.stderr", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/941c4cd56bee9bc9f16eba7a7ab6c2b332da0f9f/src%2Ftest%2Fui%2Fon-unimplemented%2Fexpected-comma-found-token.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/941c4cd56bee9bc9f16eba7a7ab6c2b332da0f9f/src%2Ftest%2Fui%2Fon-unimplemented%2Fexpected-comma-found-token.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fon-unimplemented%2Fexpected-comma-found-token.stderr?ref=941c4cd56bee9bc9f16eba7a7ab6c2b332da0f9f", "patch": "@@ -1,11 +1,8 @@\n-error: expected one of `)` or `,`, found `label`\n+error: expected `,`, found `label`\n   --> $DIR/expected-comma-found-token.rs:9:5\n    |\n LL |     message=\"the message\"\n-   |                          -\n-   |                          |\n-   |                          expected one of `)` or `,`\n-   |                          help: missing `,`\n+   |                          - expected `,`\n LL |     label=\"the label\"\n    |     ^^^^^ unexpected token\n "}, {"sha": "713b9eb542cfac9e3be6a637f5a7a2a10c7d3119", "filename": "src/test/ui/span/macro-ty-params.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/941c4cd56bee9bc9f16eba7a7ab6c2b332da0f9f/src%2Ftest%2Fui%2Fspan%2Fmacro-ty-params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/941c4cd56bee9bc9f16eba7a7ab6c2b332da0f9f/src%2Ftest%2Fui%2Fspan%2Fmacro-ty-params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fmacro-ty-params.rs?ref=941c4cd56bee9bc9f16eba7a7ab6c2b332da0f9f", "patch": "@@ -10,5 +10,4 @@ fn main() {\n     foo::<T>!(); //~ ERROR generic arguments in macro path\n     foo::<>!(); //~ ERROR generic arguments in macro path\n     m!(Default<>); //~ ERROR generic arguments in macro path\n-    //~^ ERROR unexpected generic arguments in path\n }"}, {"sha": "21683b2fb8643cb414c123da09b3fa09e06a4a65", "filename": "src/test/ui/span/macro-ty-params.stderr", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/941c4cd56bee9bc9f16eba7a7ab6c2b332da0f9f/src%2Ftest%2Fui%2Fspan%2Fmacro-ty-params.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/941c4cd56bee9bc9f16eba7a7ab6c2b332da0f9f/src%2Ftest%2Fui%2Fspan%2Fmacro-ty-params.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspan%2Fmacro-ty-params.stderr?ref=941c4cd56bee9bc9f16eba7a7ab6c2b332da0f9f", "patch": "@@ -10,17 +10,11 @@ error: generic arguments in macro path\n LL |     foo::<>!();\n    |          ^^\n \n-error: unexpected generic arguments in path\n-  --> $DIR/macro-ty-params.rs:12:8\n-   |\n-LL |     m!(Default<>);\n-   |        ^^^^^^^^^\n-\n error: generic arguments in macro path\n   --> $DIR/macro-ty-params.rs:12:15\n    |\n LL |     m!(Default<>);\n    |               ^^\n \n-error: aborting due to 4 previous errors\n+error: aborting due to 3 previous errors\n "}]}