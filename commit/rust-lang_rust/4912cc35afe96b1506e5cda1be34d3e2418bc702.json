{"sha": "4912cc35afe96b1506e5cda1be34d3e2418bc702", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ5MTJjYzM1YWZlOTZiMTUwNmU1Y2RhMWJlMzRkM2UyNDE4YmM3MDI=", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-08-04T09:42:17Z"}, "committer": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2019-08-04T09:42:17Z"}, "message": "Merge #1634\n\n1634: Implement .await completion for futures r=flodiebold a=eupn\n\nCloses #1263 with completion for `.await` syntax for types that are implementing `std::future::Future` trait.\r\n\r\nr? @flodiebold \n\nCo-authored-by: Evgenii P <eupn@protonmail.com>", "tree": {"sha": "fa40d55d943e18ce52ea072cc26c74fcf519f911", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fa40d55d943e18ce52ea072cc26c74fcf519f911"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4912cc35afe96b1506e5cda1be34d3e2418bc702", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4912cc35afe96b1506e5cda1be34d3e2418bc702", "html_url": "https://github.com/rust-lang/rust/commit/4912cc35afe96b1506e5cda1be34d3e2418bc702", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4912cc35afe96b1506e5cda1be34d3e2418bc702/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "658382c1f5d27813daf93495f4cbd5aada1f0567", "url": "https://api.github.com/repos/rust-lang/rust/commits/658382c1f5d27813daf93495f4cbd5aada1f0567", "html_url": "https://github.com/rust-lang/rust/commit/658382c1f5d27813daf93495f4cbd5aada1f0567"}, {"sha": "9f9c5aa65914763f5a9ff80230544fea48cbcdf1", "url": "https://api.github.com/repos/rust-lang/rust/commits/9f9c5aa65914763f5a9ff80230544fea48cbcdf1", "html_url": "https://github.com/rust-lang/rust/commit/9f9c5aa65914763f5a9ff80230544fea48cbcdf1"}], "stats": {"total": 114, "additions": 104, "deletions": 10}, "files": [{"sha": "e86716d74c8e40789d73add65eea311d74b5cabc", "filename": "crates/ra_hir/src/source_binder.rs", "status": "modified", "additions": 33, "deletions": 2, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/4912cc35afe96b1506e5cda1be34d3e2418bc702/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4912cc35afe96b1506e5cda1be34d3e2418bc702/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fsource_binder.rs?ref=4912cc35afe96b1506e5cda1be34d3e2418bc702", "patch": "@@ -18,14 +18,18 @@ use ra_syntax::{\n use rustc_hash::{FxHashMap, FxHashSet};\n \n use crate::{\n-    expr,\n     expr::{\n+        self,\n         scope::{ExprScopes, ScopeId},\n         BodySourceMap,\n     },\n     ids::LocationCtx,\n+    name,\n+    path::{PathKind, PathSegment},\n+    ty::method_resolution::implements_trait,\n     AsName, AstId, Const, Crate, DefWithBody, Either, Enum, Function, HirDatabase, HirFileId,\n-    MacroDef, Module, Name, Path, PerNs, Resolver, Static, Struct, Trait, Ty,\n+    MacroDef, Module, ModuleDef, Name, Path, PerNs, Resolution, Resolver, Static, Struct, Trait,\n+    Ty,\n };\n \n /// Locates the module by `FileId`. Picks topmost module in the file.\n@@ -409,6 +413,33 @@ impl SourceAnalyzer {\n         crate::ty::autoderef(db, &self.resolver, canonical).map(|canonical| canonical.value)\n     }\n \n+    /// Checks that particular type `ty` implements `std::future::Future`.\n+    /// This function is used in `.await` syntax completion.\n+    pub fn impls_future(&self, db: &impl HirDatabase, ty: Ty) -> bool {\n+        let std_future_path = Path {\n+            kind: PathKind::Abs,\n+            segments: vec![\n+                PathSegment { name: name::STD, args_and_bindings: None },\n+                PathSegment { name: name::FUTURE_MOD, args_and_bindings: None },\n+                PathSegment { name: name::FUTURE_TYPE, args_and_bindings: None },\n+            ],\n+        };\n+\n+        let std_future_trait =\n+            match self.resolver.resolve_path_segments(db, &std_future_path).into_fully_resolved() {\n+                PerNs { types: Some(Resolution::Def(ModuleDef::Trait(trait_))), .. } => trait_,\n+                _ => return false,\n+            };\n+\n+        let krate = match self.resolver.krate() {\n+            Some(krate) => krate,\n+            _ => return false,\n+        };\n+\n+        let canonical_ty = crate::ty::Canonical { value: ty, num_vars: 0 };\n+        implements_trait(&canonical_ty, db, &self.resolver, krate, std_future_trait)\n+    }\n+\n     #[cfg(test)]\n     pub(crate) fn body_source_map(&self) -> Arc<BodySourceMap> {\n         self.body_source_map.clone().unwrap()"}, {"sha": "88d012a74c320b53be170d8c00ee60abea8b5033", "filename": "crates/ra_hir/src/ty/method_resolution.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4912cc35afe96b1506e5cda1be34d3e2418bc702/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4912cc35afe96b1506e5cda1be34d3e2418bc702/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fty%2Fmethod_resolution.rs?ref=4912cc35afe96b1506e5cda1be34d3e2418bc702", "patch": "@@ -255,6 +255,20 @@ fn iterate_inherent_methods<T>(\n     None\n }\n \n+pub(crate) fn implements_trait(\n+    ty: &Canonical<Ty>,\n+    db: &impl HirDatabase,\n+    resolver: &Resolver,\n+    krate: Crate,\n+    trait_: Trait,\n+) -> bool {\n+    let env = lower::trait_env(db, resolver);\n+    let goal = generic_implements_goal(db, env.clone(), trait_, ty.clone());\n+    let solution = db.trait_solve(krate, goal);\n+\n+    solution.is_some()\n+}\n+\n impl Ty {\n     // This would be nicer if it just returned an iterator, but that runs into\n     // lifetime problems, because we need to borrow temp `CrateImplBlocks`."}, {"sha": "d43ff2eeccec29de6a93eda5740710d405fa0658", "filename": "crates/ra_ide_api/src/completion/complete_dot.rs", "status": "modified", "additions": 57, "deletions": 8, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/4912cc35afe96b1506e5cda1be34d3e2418bc702/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4912cc35afe96b1506e5cda1be34d3e2418bc702/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_dot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide_api%2Fsrc%2Fcompletion%2Fcomplete_dot.rs?ref=4912cc35afe96b1506e5cda1be34d3e2418bc702", "patch": "@@ -1,19 +1,36 @@\n use hir::{AdtDef, Ty, TypeCtor};\n \n-use crate::completion::{CompletionContext, Completions};\n+use crate::completion::completion_item::CompletionKind;\n+use crate::{\n+    completion::{completion_context::CompletionContext, completion_item::Completions},\n+    CompletionItem,\n+};\n use rustc_hash::FxHashSet;\n \n-/// Complete dot accesses, i.e. fields or methods (currently only fields).\n+/// Complete dot accesses, i.e. fields or methods (and .await syntax).\n pub(super) fn complete_dot(acc: &mut Completions, ctx: &CompletionContext) {\n-    let receiver_ty =\n-        match ctx.dot_receiver.as_ref().and_then(|it| ctx.analyzer.type_of(ctx.db, it)) {\n-            Some(it) => it,\n-            None => return,\n-        };\n+    let dot_receiver = match &ctx.dot_receiver {\n+        Some(expr) => expr,\n+        _ => return,\n+    };\n+\n+    let receiver_ty = match ctx.analyzer.type_of(ctx.db, &dot_receiver) {\n+        Some(ty) => ty,\n+        _ => return,\n+    };\n+\n     if !ctx.is_call {\n         complete_fields(acc, ctx, receiver_ty.clone());\n     }\n-    complete_methods(acc, ctx, receiver_ty);\n+    complete_methods(acc, ctx, receiver_ty.clone());\n+\n+    // Suggest .await syntax for types that implement Future trait\n+    if ctx.analyzer.impls_future(ctx.db, receiver_ty) {\n+        CompletionItem::new(CompletionKind::Keyword, ctx.source_range(), \"await\")\n+            .detail(\"expr.await\")\n+            .insert_text(\"await\")\n+            .add_to(acc);\n+    }\n }\n \n fn complete_fields(acc: &mut Completions, ctx: &CompletionContext, receiver: Ty) {\n@@ -406,4 +423,36 @@ mod tests {\n         \"###\n         );\n     }\n+\n+    #[test]\n+    fn test_completion_await_impls_future() {\n+        assert_debug_snapshot_matches!(\n+        do_completion(\n+            r###\"\n+            //- /main.rs\n+            use std::future::*;\n+            struct A {}\n+            impl Future for A {}\n+            fn foo(a: A) {\n+                a.<|>\n+            }\n+\n+            //- /std/lib.rs\n+            pub mod future {\n+                pub trait Future {}\n+            }\n+            \"###, CompletionKind::Keyword),\n+        @r###\"\n+       \u22ee[\n+       \u22ee    CompletionItem {\n+       \u22ee        label: \"await\",\n+       \u22ee        source_range: [74; 74),\n+       \u22ee        delete: [74; 74),\n+       \u22ee        insert: \"await\",\n+       \u22ee        detail: \"expr.await\",\n+       \u22ee    },\n+       \u22ee]\n+        \"###\n+        )\n+    }\n }"}]}