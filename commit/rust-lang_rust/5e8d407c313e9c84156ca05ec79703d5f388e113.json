{"sha": "5e8d407c313e9c84156ca05ec79703d5f388e113", "node_id": "MDY6Q29tbWl0NzI0NzEyOjVlOGQ0MDdjMzEzZTljODQxNTZjYTA1ZWM3OTcwM2Q1ZjM4OGUxMTM=", "commit": {"author": {"name": "kennytm", "email": "kennytm@gmail.com", "date": "2017-10-15T06:21:55Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2017-10-15T06:21:55Z"}, "message": "Rollup merge of #45263 - Manishearth:hashmap-clean, r=bluss\n\nDo some cleanups for hashmaps\n\n@mystor noticed some things whilst reading through the hashmap RawTable code.\n\nFirstly, in RawTable we deal with this hash_offset value that is the offset of the list of hashes from the buffer start. This is always zero, and this isn't consistently used (which means that we would have bugs if we set it to something else). We should just remove this since it doesn't help us at all.\n\nSecondly, the probing length tag is not copied when cloning a raw table. This is minor and basically means we do a bit more work than we need on further inserts on a cloned hashmap.\n\nr? @Gankro", "tree": {"sha": "794cac2e247bb8513b680e0c248a407931f87246", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/794cac2e247bb8513b680e0c248a407931f87246"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/5e8d407c313e9c84156ca05ec79703d5f388e113", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/5e8d407c313e9c84156ca05ec79703d5f388e113", "html_url": "https://github.com/rust-lang/rust/commit/5e8d407c313e9c84156ca05ec79703d5f388e113", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/5e8d407c313e9c84156ca05ec79703d5f388e113/comments", "author": {"login": "kennytm", "id": 103023, "node_id": "MDQ6VXNlcjEwMzAyMw==", "avatar_url": "https://avatars.githubusercontent.com/u/103023?v=4", "gravatar_id": "", "url": "https://api.github.com/users/kennytm", "html_url": "https://github.com/kennytm", "followers_url": "https://api.github.com/users/kennytm/followers", "following_url": "https://api.github.com/users/kennytm/following{/other_user}", "gists_url": "https://api.github.com/users/kennytm/gists{/gist_id}", "starred_url": "https://api.github.com/users/kennytm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/kennytm/subscriptions", "organizations_url": "https://api.github.com/users/kennytm/orgs", "repos_url": "https://api.github.com/users/kennytm/repos", "events_url": "https://api.github.com/users/kennytm/events{/privacy}", "received_events_url": "https://api.github.com/users/kennytm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "34a286bf9075f944f5d581e66f7d362d104a4959", "url": "https://api.github.com/repos/rust-lang/rust/commits/34a286bf9075f944f5d581e66f7d362d104a4959", "html_url": "https://github.com/rust-lang/rust/commit/34a286bf9075f944f5d581e66f7d362d104a4959"}, {"sha": "e8e7715bebdd401ebacfabb66928d0f7e4733120", "url": "https://api.github.com/repos/rust-lang/rust/commits/e8e7715bebdd401ebacfabb66928d0f7e4733120", "html_url": "https://github.com/rust-lang/rust/commit/e8e7715bebdd401ebacfabb66928d0f7e4733120"}], "stats": {"total": 32, "additions": 16, "deletions": 16}, "files": [{"sha": "7e623a0af17c3c1bab2db1c7948cb2b5f3974aad", "filename": "src/libstd/collections/hash/table.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/5e8d407c313e9c84156ca05ec79703d5f388e113/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/5e8d407c313e9c84156ca05ec79703d5f388e113/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhash%2Ftable.rs?ref=5e8d407c313e9c84156ca05ec79703d5f388e113", "patch": "@@ -717,26 +717,25 @@ fn calculate_offsets(hashes_size: usize,\n     (pairs_offset, end_of_pairs, oflo)\n }\n \n-// Returns a tuple of (minimum required malloc alignment, hash_offset,\n+// Returns a tuple of (minimum required malloc alignment,\n // array_size), from the start of a mallocated array.\n fn calculate_allocation(hash_size: usize,\n                         hash_align: usize,\n                         pairs_size: usize,\n                         pairs_align: usize)\n-                        -> (usize, usize, usize, bool) {\n-    let hash_offset = 0;\n+                        -> (usize, usize, bool) {\n     let (_, end_of_pairs, oflo) = calculate_offsets(hash_size, pairs_size, pairs_align);\n \n     let align = cmp::max(hash_align, pairs_align);\n \n-    (align, hash_offset, end_of_pairs, oflo)\n+    (align, end_of_pairs, oflo)\n }\n \n #[test]\n fn test_offset_calculation() {\n-    assert_eq!(calculate_allocation(128, 8, 16, 8), (8, 0, 144, false));\n-    assert_eq!(calculate_allocation(3, 1, 2, 1), (1, 0, 5, false));\n-    assert_eq!(calculate_allocation(6, 2, 12, 4), (4, 0, 20, false));\n+    assert_eq!(calculate_allocation(128, 8, 16, 8), (8, 144, false));\n+    assert_eq!(calculate_allocation(3, 1, 2, 1), (1, 5, false));\n+    assert_eq!(calculate_allocation(6, 2, 12, 4), (4, 20, false));\n     assert_eq!(calculate_offsets(128, 15, 4), (128, 143, false));\n     assert_eq!(calculate_offsets(3, 2, 4), (4, 6, false));\n     assert_eq!(calculate_offsets(6, 12, 4), (8, 20, false));\n@@ -768,10 +767,10 @@ impl<K, V> RawTable<K, V> {\n         // This is great in theory, but in practice getting the alignment\n         // right is a little subtle. Therefore, calculating offsets has been\n         // factored out into a different function.\n-        let (alignment, hash_offset, size, oflo) = calculate_allocation(hashes_size,\n-                                                                        align_of::<HashUint>(),\n-                                                                        pairs_size,\n-                                                                        align_of::<(K, V)>());\n+        let (alignment, size, oflo) = calculate_allocation(hashes_size,\n+                                                           align_of::<HashUint>(),\n+                                                           pairs_size,\n+                                                           align_of::<(K, V)>());\n         assert!(!oflo, \"capacity overflow\");\n \n         // One check for overflow that covers calculation and rounding of size.\n@@ -784,7 +783,7 @@ impl<K, V> RawTable<K, V> {\n         let buffer = Heap.alloc(Layout::from_size_align(size, alignment).unwrap())\n             .unwrap_or_else(|e| Heap.oom(e));\n \n-        let hashes = buffer.offset(hash_offset as isize) as *mut HashUint;\n+        let hashes = buffer as *mut HashUint;\n \n         RawTable {\n             capacity_mask: capacity.wrapping_sub(1),\n@@ -1157,6 +1156,7 @@ impl<K: Clone, V: Clone> Clone for RawTable<K, V> {\n             }\n \n             new_ht.size = self.size();\n+            new_ht.set_tag(self.tag());\n \n             new_ht\n         }\n@@ -1183,10 +1183,10 @@ unsafe impl<#[may_dangle] K, #[may_dangle] V> Drop for RawTable<K, V> {\n \n         let hashes_size = self.capacity() * size_of::<HashUint>();\n         let pairs_size = self.capacity() * size_of::<(K, V)>();\n-        let (align, _, size, oflo) = calculate_allocation(hashes_size,\n-                                                          align_of::<HashUint>(),\n-                                                          pairs_size,\n-                                                          align_of::<(K, V)>());\n+        let (align, size, oflo) = calculate_allocation(hashes_size,\n+                                                       align_of::<HashUint>(),\n+                                                       pairs_size,\n+                                                       align_of::<(K, V)>());\n \n         debug_assert!(!oflo, \"should be impossible\");\n "}]}