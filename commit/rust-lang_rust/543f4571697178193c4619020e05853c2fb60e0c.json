{"sha": "543f4571697178193c4619020e05853c2fb60e0c", "node_id": "MDY6Q29tbWl0NzI0NzEyOjU0M2Y0NTcxNjk3MTc4MTkzYzQ2MTkwMjBlMDU4NTNjMmZiNjBlMGM=", "commit": {"author": {"name": "Mazdak Farrokhzad", "email": "twingoow@gmail.com", "date": "2019-02-08T23:15:52Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2019-02-08T23:15:52Z"}, "message": "Rollup merge of #58245 - taiki-e:librustc_lint-2018, r=Centril\n\nlibrustc_lint => 2018\n\nTransitions `librustc_lint` to Rust 2018; cc #58099\n\nr? @Centril", "tree": {"sha": "fb605e7bad7f5a340ce782945e84371a0a587581", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/fb605e7bad7f5a340ce782945e84371a0a587581"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/543f4571697178193c4619020e05853c2fb60e0c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJcXg2oCRBK7hj4Ov3rIwAAdHIIAGG/ioE7q+7k9cC4WerKPxvD\n++SmKUqUU46WrZy7KnXdCxjRa1hWWzARvW3SLvaGIwC2COfeQ1yisRb6ojrtSOOc\nwB5AawXrtQMCCTjYkImn/pEWWJvvaaHZ+CGF0fHya/LfViEyvpxGKCdkGu9dYYTQ\nI7jyUyf8pivF3mR0SAWyx//yd3gePqreHMRU5CitYELmGmUsk79p8QD3bMTZhkok\nhWsT9N8wnQbDQoLsO0wvwSrhsr0hmona2uqC6UtGHkqmKUb1xTZ/HaB55PWgJEmx\nXpJPyDvFsECGAX4duC+Wxqi9rk/7Vu1bcXVtioZOAVHr4sHaxYDFao/r9Dfsme0=\n=FDa9\n-----END PGP SIGNATURE-----\n", "payload": "tree fb605e7bad7f5a340ce782945e84371a0a587581\nparent 2b8ed1e1bd9a51a2cff05ad3a1499c67ecbcfd3d\nparent 6140134b6f2004a4d331821278c8b17f47a51f25\nauthor Mazdak Farrokhzad <twingoow@gmail.com> 1549667752 +0100\ncommitter GitHub <noreply@github.com> 1549667752 +0100\n\nRollup merge of #58245 - taiki-e:librustc_lint-2018, r=Centril\n\nlibrustc_lint => 2018\n\nTransitions `librustc_lint` to Rust 2018; cc #58099\n\nr? @Centril\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/543f4571697178193c4619020e05853c2fb60e0c", "html_url": "https://github.com/rust-lang/rust/commit/543f4571697178193c4619020e05853c2fb60e0c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/543f4571697178193c4619020e05853c2fb60e0c/comments", "author": {"login": "Centril", "id": 855702, "node_id": "MDQ6VXNlcjg1NTcwMg==", "avatar_url": "https://avatars.githubusercontent.com/u/855702?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Centril", "html_url": "https://github.com/Centril", "followers_url": "https://api.github.com/users/Centril/followers", "following_url": "https://api.github.com/users/Centril/following{/other_user}", "gists_url": "https://api.github.com/users/Centril/gists{/gist_id}", "starred_url": "https://api.github.com/users/Centril/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Centril/subscriptions", "organizations_url": "https://api.github.com/users/Centril/orgs", "repos_url": "https://api.github.com/users/Centril/repos", "events_url": "https://api.github.com/users/Centril/events{/privacy}", "received_events_url": "https://api.github.com/users/Centril/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2b8ed1e1bd9a51a2cff05ad3a1499c67ecbcfd3d", "url": "https://api.github.com/repos/rust-lang/rust/commits/2b8ed1e1bd9a51a2cff05ad3a1499c67ecbcfd3d", "html_url": "https://github.com/rust-lang/rust/commit/2b8ed1e1bd9a51a2cff05ad3a1499c67ecbcfd3d"}, {"sha": "6140134b6f2004a4d331821278c8b17f47a51f25", "url": "https://api.github.com/repos/rust-lang/rust/commits/6140134b6f2004a4d331821278c8b17f47a51f25", "html_url": "https://github.com/rust-lang/rust/commit/6140134b6f2004a4d331821278c8b17f47a51f25"}], "stats": {"total": 208, "additions": 108, "deletions": 100}, "files": [{"sha": "82f7118df2d0b8369252d3778e133a864b498cba", "filename": "src/librustc_lint/Cargo.toml", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/543f4571697178193c4619020e05853c2fb60e0c/src%2Flibrustc_lint%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/543f4571697178193c4619020e05853c2fb60e0c/src%2Flibrustc_lint%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2FCargo.toml?ref=543f4571697178193c4619020e05853c2fb60e0c", "patch": "@@ -2,6 +2,7 @@\n authors = [\"The Rust Project Developers\"]\n name = \"rustc_lint\"\n version = \"0.0.0\"\n+edition = \"2018\"\n \n [lib]\n name = \"rustc_lint\""}, {"sha": "cbcc7f3574d03e31ce85de59a60d4617aa3d42ee", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 56, "deletions": 52, "changes": 108, "blob_url": "https://github.com/rust-lang/rust/blob/543f4571697178193c4619020e05853c2fb60e0c/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/543f4571697178193c4619020e05853c2fb60e0c/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=543f4571697178193c4619020e05853c2fb60e0c", "patch": "@@ -21,6 +21,7 @@\n use rustc::hir::def::Def;\n use rustc::hir::def_id::{DefId, LOCAL_CRATE};\n use rustc::ty::{self, Ty};\n+use rustc::{lint, util};\n use hir::Node;\n use util::nodemap::NodeSet;\n use lint::{LateContext, LintContext, LintArray};\n@@ -42,10 +43,13 @@ use syntax::symbol::keywords;\n use syntax::errors::{Applicability, DiagnosticBuilder};\n use syntax::print::pprust::expr_to_string;\n use syntax::visit::FnKind;\n+use syntax::struct_span_err;\n \n use rustc::hir::{self, GenericParamKind, PatKind};\n \n-use nonstandard_style::{MethodLateContext, method_context};\n+use crate::nonstandard_style::{MethodLateContext, method_context};\n+\n+use log::debug;\n \n // hardwired lints from librustc\n pub use lint::builtin::*;\n@@ -70,7 +74,7 @@ impl LintPass for WhileTrue {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for WhileTrue {\n-    fn check_expr(&mut self, cx: &LateContext, e: &hir::Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'_, '_>, e: &hir::Expr) {\n         if let hir::ExprKind::While(ref cond, ..) = e.node {\n             if let hir::ExprKind::Lit(ref lit) = cond.node {\n                 if let ast::LitKind::Bool(true) = lit.node {\n@@ -102,7 +106,7 @@ declare_lint! {\n pub struct BoxPointers;\n \n impl BoxPointers {\n-    fn check_heap_type<'a, 'tcx>(&self, cx: &LateContext, span: Span, ty: Ty) {\n+    fn check_heap_type<'a, 'tcx>(&self, cx: &LateContext<'_, '_>, span: Span, ty: Ty<'_>) {\n         for leaf_ty in ty.walk() {\n             if leaf_ty.is_box() {\n                 let m = format!(\"type uses owned (Box type) pointers: {}\", ty);\n@@ -123,7 +127,7 @@ impl LintPass for BoxPointers {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BoxPointers {\n-    fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n+    fn check_item(&mut self, cx: &LateContext<'_, '_>, it: &hir::Item) {\n         match it.node {\n             hir::ItemKind::Fn(..) |\n             hir::ItemKind::Ty(..) |\n@@ -150,7 +154,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for BoxPointers {\n         }\n     }\n \n-    fn check_expr(&mut self, cx: &LateContext, e: &hir::Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'_, '_>, e: &hir::Expr) {\n         let ty = cx.tables.node_id_to_type(e.hir_id);\n         self.check_heap_type(cx, e.span, ty);\n     }\n@@ -176,7 +180,7 @@ impl LintPass for NonShorthandFieldPatterns {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonShorthandFieldPatterns {\n-    fn check_pat(&mut self, cx: &LateContext, pat: &hir::Pat) {\n+    fn check_pat(&mut self, cx: &LateContext<'_, '_>, pat: &hir::Pat) {\n         if let PatKind::Struct(ref qpath, ref field_pats, _) = pat.node {\n             let variant = cx.tables.pat_ty(pat).ty_adt_def()\n                                    .expect(\"struct pattern type is not an ADT\")\n@@ -233,7 +237,7 @@ impl LintPass for UnsafeCode {\n }\n \n impl UnsafeCode {\n-    fn report_unsafe(&self, cx: &EarlyContext, span: Span, desc: &'static str) {\n+    fn report_unsafe(&self, cx: &EarlyContext<'_>, span: Span, desc: &'static str) {\n         // This comes from a macro that has #[allow_internal_unsafe].\n         if span.allows_unsafe() {\n             return;\n@@ -244,15 +248,15 @@ impl UnsafeCode {\n }\n \n impl EarlyLintPass for UnsafeCode {\n-    fn check_attribute(&mut self, cx: &EarlyContext, attr: &ast::Attribute) {\n+    fn check_attribute(&mut self, cx: &EarlyContext<'_>, attr: &ast::Attribute) {\n         if attr.check_name(\"allow_internal_unsafe\") {\n             self.report_unsafe(cx, attr.span, \"`allow_internal_unsafe` allows defining \\\n                                                macros using unsafe without triggering \\\n                                                the `unsafe_code` lint at their call site\");\n         }\n     }\n \n-    fn check_expr(&mut self, cx: &EarlyContext, e: &ast::Expr) {\n+    fn check_expr(&mut self, cx: &EarlyContext<'_>, e: &ast::Expr) {\n         if let ast::ExprKind::Block(ref blk, _) = e.node {\n             // Don't warn about generated blocks, that'll just pollute the output.\n             if blk.rules == ast::BlockCheckMode::Unsafe(ast::UserProvided) {\n@@ -261,7 +265,7 @@ impl EarlyLintPass for UnsafeCode {\n         }\n     }\n \n-    fn check_item(&mut self, cx: &EarlyContext, it: &ast::Item) {\n+    fn check_item(&mut self, cx: &EarlyContext<'_>, it: &ast::Item) {\n         match it.node {\n             ast::ItemKind::Trait(_, ast::Unsafety::Unsafe, ..) => {\n                 self.report_unsafe(cx, it.span, \"declaration of an `unsafe` trait\")\n@@ -276,8 +280,8 @@ impl EarlyLintPass for UnsafeCode {\n     }\n \n     fn check_fn(&mut self,\n-                cx: &EarlyContext,\n-                fk: FnKind,\n+                cx: &EarlyContext<'_>,\n+                fk: FnKind<'_>,\n                 _: &ast::FnDecl,\n                 span: Span,\n                 _: ast::NodeId) {\n@@ -296,7 +300,7 @@ impl EarlyLintPass for UnsafeCode {\n         }\n     }\n \n-    fn check_trait_item(&mut self, cx: &EarlyContext, item: &ast::TraitItem) {\n+    fn check_trait_item(&mut self, cx: &EarlyContext<'_>, item: &ast::TraitItem) {\n         if let ast::TraitItemKind::Method(ref sig, None) = item.node {\n             if sig.header.unsafety == ast::Unsafety::Unsafe {\n                 self.report_unsafe(cx, item.span, \"declaration of an `unsafe` method\")\n@@ -354,7 +358,7 @@ impl MissingDoc {\n     }\n \n     fn check_missing_docs_attrs(&self,\n-                                cx: &LateContext,\n+                                cx: &LateContext<'_, '_>,\n                                 id: Option<ast::NodeId>,\n                                 attrs: &[ast::Attribute],\n                                 sp: Span,\n@@ -399,7 +403,7 @@ impl LintPass for MissingDoc {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n-    fn enter_lint_attrs(&mut self, _: &LateContext, attrs: &[ast::Attribute]) {\n+    fn enter_lint_attrs(&mut self, _: &LateContext<'_, '_>, attrs: &[ast::Attribute]) {\n         let doc_hidden = self.doc_hidden() ||\n                          attrs.iter().any(|attr| {\n             attr.check_name(\"doc\") &&\n@@ -411,11 +415,11 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n         self.doc_hidden_stack.push(doc_hidden);\n     }\n \n-    fn exit_lint_attrs(&mut self, _: &LateContext, _attrs: &[ast::Attribute]) {\n+    fn exit_lint_attrs(&mut self, _: &LateContext<'_, '_>, _attrs: &[ast::Attribute]) {\n         self.doc_hidden_stack.pop().expect(\"empty doc_hidden_stack\");\n     }\n \n-    fn check_crate(&mut self, cx: &LateContext, krate: &hir::Crate) {\n+    fn check_crate(&mut self, cx: &LateContext<'_, '_>, krate: &hir::Crate) {\n         self.check_missing_docs_attrs(cx, None, &krate.attrs, krate.span, \"crate\");\n \n         for macro_def in &krate.exported_macros {\n@@ -428,7 +432,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n         }\n     }\n \n-    fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n+    fn check_item(&mut self, cx: &LateContext<'_, '_>, it: &hir::Item) {\n         let desc = match it.node {\n             hir::ItemKind::Fn(..) => \"a function\",\n             hir::ItemKind::Mod(..) => \"a module\",\n@@ -473,7 +477,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n         self.check_missing_docs_attrs(cx, Some(it.id), &it.attrs, it.span, desc);\n     }\n \n-    fn check_trait_item(&mut self, cx: &LateContext, trait_item: &hir::TraitItem) {\n+    fn check_trait_item(&mut self, cx: &LateContext<'_, '_>, trait_item: &hir::TraitItem) {\n         if self.private_traits.contains(&trait_item.id) {\n             return;\n         }\n@@ -491,7 +495,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n                                       desc);\n     }\n \n-    fn check_impl_item(&mut self, cx: &LateContext, impl_item: &hir::ImplItem) {\n+    fn check_impl_item(&mut self, cx: &LateContext<'_, '_>, impl_item: &hir::ImplItem) {\n         // If the method is an impl for a trait, don't doc.\n         if method_context(cx, impl_item.id) == MethodLateContext::TraitImpl {\n             return;\n@@ -510,7 +514,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n                                       desc);\n     }\n \n-    fn check_struct_field(&mut self, cx: &LateContext, sf: &hir::StructField) {\n+    fn check_struct_field(&mut self, cx: &LateContext<'_, '_>, sf: &hir::StructField) {\n         if !sf.is_positional() {\n             self.check_missing_docs_attrs(cx,\n                                           Some(sf.id),\n@@ -520,7 +524,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDoc {\n         }\n     }\n \n-    fn check_variant(&mut self, cx: &LateContext, v: &hir::Variant, _: &hir::Generics) {\n+    fn check_variant(&mut self, cx: &LateContext<'_, '_>, v: &hir::Variant, _: &hir::Generics) {\n         self.check_missing_docs_attrs(cx,\n                                       Some(v.node.data.id()),\n                                       &v.node.attrs,\n@@ -549,7 +553,7 @@ impl LintPass for MissingCopyImplementations {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingCopyImplementations {\n-    fn check_item(&mut self, cx: &LateContext, item: &hir::Item) {\n+    fn check_item(&mut self, cx: &LateContext<'_, '_>, item: &hir::Item) {\n         if !cx.access_levels.is_reachable(item.id) {\n             return;\n         }\n@@ -620,7 +624,7 @@ impl LintPass for MissingDebugImplementations {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MissingDebugImplementations {\n-    fn check_item(&mut self, cx: &LateContext, item: &hir::Item) {\n+    fn check_item(&mut self, cx: &LateContext<'_, '_>, item: &hir::Item) {\n         if !cx.access_levels.is_reachable(item.id) {\n             return;\n         }\n@@ -681,7 +685,7 @@ impl LintPass for AnonymousParameters {\n }\n \n impl EarlyLintPass for AnonymousParameters {\n-    fn check_trait_item(&mut self, cx: &EarlyContext, it: &ast::TraitItem) {\n+    fn check_trait_item(&mut self, cx: &EarlyContext<'_>, it: &ast::TraitItem) {\n         match it.node {\n             ast::TraitItemKind::Method(ref sig, _) => {\n                 for arg in sig.decl.inputs.iter() {\n@@ -749,7 +753,7 @@ impl LintPass for DeprecatedAttr {\n }\n \n impl EarlyLintPass for DeprecatedAttr {\n-    fn check_attribute(&mut self, cx: &EarlyContext, attr: &ast::Attribute) {\n+    fn check_attribute(&mut self, cx: &EarlyContext<'_>, attr: &ast::Attribute) {\n         for &&(n, _, _, ref g) in &self.depr_attrs {\n             if attr.name() == n {\n                 if let &AttributeGate::Gated(Stability::Deprecated(link, suggestion),\n@@ -804,15 +808,15 @@ impl UnusedDocComment {\n }\n \n impl EarlyLintPass for UnusedDocComment {\n-    fn check_local(&mut self, cx: &EarlyContext, decl: &ast::Local) {\n+    fn check_local(&mut self, cx: &EarlyContext<'_>, decl: &ast::Local) {\n         self.warn_if_doc(decl.attrs.iter(), cx);\n     }\n \n-    fn check_arm(&mut self, cx: &EarlyContext, arm: &ast::Arm) {\n+    fn check_arm(&mut self, cx: &EarlyContext<'_>, arm: &ast::Arm) {\n         self.warn_if_doc(arm.attrs.iter(), cx);\n     }\n \n-    fn check_expr(&mut self, cx: &EarlyContext, expr: &ast::Expr) {\n+    fn check_expr(&mut self, cx: &EarlyContext<'_>, expr: &ast::Expr) {\n         self.warn_if_doc(expr.attrs.iter(), cx);\n     }\n }\n@@ -837,7 +841,7 @@ impl LintPass for PluginAsLibrary {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for PluginAsLibrary {\n-    fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n+    fn check_item(&mut self, cx: &LateContext<'_, '_>, it: &hir::Item) {\n         if cx.tcx.plugin_registrar_fn(LOCAL_CRATE).is_some() {\n             // We're compiling a plugin; it's fine to link other plugins.\n             return;\n@@ -894,7 +898,7 @@ impl LintPass for InvalidNoMangleItems {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for InvalidNoMangleItems {\n-    fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n+    fn check_item(&mut self, cx: &LateContext<'_, '_>, it: &hir::Item) {\n         match it.node {\n             hir::ItemKind::Fn(.., ref generics, _) => {\n                 if let Some(no_mangle_attr) = attr::find_by_name(&it.attrs, \"no_mangle\") {\n@@ -968,7 +972,7 @@ impl LintPass for MutableTransmutes {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MutableTransmutes {\n-    fn check_expr(&mut self, cx: &LateContext, expr: &hir::Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'_, '_>, expr: &hir::Expr) {\n         use rustc_target::spec::abi::Abi::RustIntrinsic;\n \n         let msg = \"mutating transmuted &mut T from &T may cause undefined behavior, \\\n@@ -1004,7 +1008,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for MutableTransmutes {\n             None\n         }\n \n-        fn def_id_is_transmute(cx: &LateContext, def_id: DefId) -> bool {\n+        fn def_id_is_transmute(cx: &LateContext<'_, '_>, def_id: DefId) -> bool {\n             cx.tcx.fn_sig(def_id).abi() == RustIntrinsic &&\n             cx.tcx.item_name(def_id) == \"transmute\"\n         }\n@@ -1032,7 +1036,7 @@ impl LintPass for UnstableFeatures {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnstableFeatures {\n-    fn check_attribute(&mut self, ctx: &LateContext, attr: &ast::Attribute) {\n+    fn check_attribute(&mut self, ctx: &LateContext<'_, '_>, attr: &ast::Attribute) {\n         if attr.check_name(\"feature\") {\n             if let Some(items) = attr.meta_item_list() {\n                 for item in items {\n@@ -1063,7 +1067,7 @@ impl LintPass for UnionsWithDropFields {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnionsWithDropFields {\n-    fn check_item(&mut self, ctx: &LateContext, item: &hir::Item) {\n+    fn check_item(&mut self, ctx: &LateContext<'_, '_>, item: &hir::Item) {\n         if let hir::ItemKind::Union(ref vdata, _) = item.node {\n             for field in vdata.fields() {\n                 let field_ty = ctx.tcx.type_of(ctx.tcx.hir().local_def_id(field.id));\n@@ -1099,7 +1103,7 @@ impl LintPass for UnreachablePub {\n }\n \n impl UnreachablePub {\n-    fn perform_lint(&self, cx: &LateContext, what: &str, id: ast::NodeId,\n+    fn perform_lint(&self, cx: &LateContext<'_, '_>, what: &str, id: ast::NodeId,\n                     vis: &hir::Visibility, span: Span, exportable: bool) {\n         let mut applicability = Applicability::MachineApplicable;\n         match vis.node {\n@@ -1134,20 +1138,20 @@ impl UnreachablePub {\n \n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnreachablePub {\n-    fn check_item(&mut self, cx: &LateContext, item: &hir::Item) {\n+    fn check_item(&mut self, cx: &LateContext<'_, '_>, item: &hir::Item) {\n         self.perform_lint(cx, \"item\", item.id, &item.vis, item.span, true);\n     }\n \n-    fn check_foreign_item(&mut self, cx: &LateContext, foreign_item: &hir::ForeignItem) {\n+    fn check_foreign_item(&mut self, cx: &LateContext<'_, '_>, foreign_item: &hir::ForeignItem) {\n         self.perform_lint(cx, \"item\", foreign_item.id, &foreign_item.vis,\n                           foreign_item.span, true);\n     }\n \n-    fn check_struct_field(&mut self, cx: &LateContext, field: &hir::StructField) {\n+    fn check_struct_field(&mut self, cx: &LateContext<'_, '_>, field: &hir::StructField) {\n         self.perform_lint(cx, \"field\", field.id, &field.vis, field.span, false);\n     }\n \n-    fn check_impl_item(&mut self, cx: &LateContext, impl_item: &hir::ImplItem) {\n+    fn check_impl_item(&mut self, cx: &LateContext<'_, '_>, impl_item: &hir::ImplItem) {\n         self.perform_lint(cx, \"item\", impl_item.id, &impl_item.vis, impl_item.span, false);\n     }\n }\n@@ -1193,7 +1197,7 @@ impl TypeAliasBounds {\n         }\n     }\n \n-    fn suggest_changing_assoc_types(ty: &hir::Ty, err: &mut DiagnosticBuilder) {\n+    fn suggest_changing_assoc_types(ty: &hir::Ty, err: &mut DiagnosticBuilder<'_>) {\n         // Access to associates types should use `<T as Bound>::Assoc`, which does not need a\n         // bound.  Let's see if this type does that.\n \n@@ -1225,7 +1229,7 @@ impl TypeAliasBounds {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeAliasBounds {\n-    fn check_item(&mut self, cx: &LateContext, item: &hir::Item) {\n+    fn check_item(&mut self, cx: &LateContext<'_, '_>, item: &hir::Item) {\n         let (ty, type_alias_generics) = match item.node {\n             hir::ItemKind::Ty(ref ty, ref generics) => (&*ty, generics),\n             _ => return,\n@@ -1281,7 +1285,7 @@ impl LintPass for UnusedBrokenConst {\n         lint_array!()\n     }\n }\n-fn check_const(cx: &LateContext, body_id: hir::BodyId) {\n+fn check_const(cx: &LateContext<'_, '_>, body_id: hir::BodyId) {\n     let def_id = cx.tcx.hir().body_owner_def_id(body_id);\n     let is_static = cx.tcx.is_static(def_id).is_some();\n     let param_env = if is_static {\n@@ -1299,7 +1303,7 @@ fn check_const(cx: &LateContext, body_id: hir::BodyId) {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedBrokenConst {\n-    fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n+    fn check_item(&mut self, cx: &LateContext<'_, '_>, it: &hir::Item) {\n         match it.node {\n             hir::ItemKind::Const(_, body_id) => {\n                 check_const(cx, body_id);\n@@ -1429,7 +1433,7 @@ impl LintPass for EllipsisInclusiveRangePatterns {\n }\n \n impl EarlyLintPass for EllipsisInclusiveRangePatterns {\n-    fn check_pat(&mut self, cx: &EarlyContext, pat: &ast::Pat, visit_subpats: &mut bool) {\n+    fn check_pat(&mut self, cx: &EarlyContext<'_>, pat: &ast::Pat, visit_subpats: &mut bool) {\n         use self::ast::{PatKind, RangeEnd, RangeSyntax::DotDotDot};\n \n         /// If `pat` is a `...` pattern, return the start and end of the range, as well as the span\n@@ -1507,7 +1511,7 @@ impl LintPass for UnnameableTestItems {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnnameableTestItems {\n-    fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n+    fn check_item(&mut self, cx: &LateContext<'_, '_>, it: &hir::Item) {\n         if self.items_nameable {\n             if let hir::ItemKind::Mod(..) = it.node {}\n             else {\n@@ -1526,7 +1530,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnnameableTestItems {\n         }\n     }\n \n-    fn check_item_post(&mut self, _cx: &LateContext, it: &hir::Item) {\n+    fn check_item_post(&mut self, _cx: &LateContext<'_, '_>, it: &hir::Item) {\n         if !self.items_nameable && self.boundary == it.id {\n             self.items_nameable = true;\n         }\n@@ -1554,7 +1558,7 @@ impl LintPass for KeywordIdents {\n }\n \n impl KeywordIdents {\n-    fn check_tokens(&mut self, cx: &EarlyContext, tokens: TokenStream) {\n+    fn check_tokens(&mut self, cx: &EarlyContext<'_>, tokens: TokenStream) {\n         for tt in tokens.into_trees() {\n             match tt {\n                 TokenTree::Token(span, tok) => match tok.ident() {\n@@ -1576,13 +1580,13 @@ impl KeywordIdents {\n }\n \n impl EarlyLintPass for KeywordIdents {\n-    fn check_mac_def(&mut self, cx: &EarlyContext, mac_def: &ast::MacroDef, _id: ast::NodeId) {\n+    fn check_mac_def(&mut self, cx: &EarlyContext<'_>, mac_def: &ast::MacroDef, _id: ast::NodeId) {\n         self.check_tokens(cx, mac_def.stream());\n     }\n-    fn check_mac(&mut self, cx: &EarlyContext, mac: &ast::Mac) {\n+    fn check_mac(&mut self, cx: &EarlyContext<'_>, mac: &ast::Mac) {\n         self.check_tokens(cx, mac.node.tts.clone().into());\n     }\n-    fn check_ident(&mut self, cx: &EarlyContext, ident: ast::Ident) {\n+    fn check_ident(&mut self, cx: &EarlyContext<'_>, ident: ast::Ident) {\n         let ident_str = &ident.as_str()[..];\n         let cur_edition = cx.sess.edition();\n         let is_raw_ident = |ident: ast::Ident| {\n@@ -1665,7 +1669,7 @@ impl LintPass for ExplicitOutlivesRequirements {\n impl ExplicitOutlivesRequirements {\n     fn collect_outlives_bound_spans(\n         &self,\n-        cx: &LateContext,\n+        cx: &LateContext<'_, '_>,\n         item_def_id: DefId,\n         param_name: &str,\n         bounds: &hir::GenericBounds,"}, {"sha": "3165673111cca008363c69ef5425f4ffeec33c60", "filename": "src/librustc_lint/diagnostics.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/543f4571697178193c4619020e05853c2fb60e0c/src%2Flibrustc_lint%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/543f4571697178193c4619020e05853c2fb60e0c/src%2Flibrustc_lint%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fdiagnostics.rs?ref=543f4571697178193c4619020e05853c2fb60e0c", "patch": "@@ -1,3 +1,5 @@\n+use syntax::{register_diagnostic, register_diagnostics};\n+\n register_diagnostics! {\n     E0721, // `await` keyword\n }"}, {"sha": "6e5988f24382206cb36256e29439385adb1773fe", "filename": "src/librustc_lint/lib.rs", "status": "modified", "additions": 2, "deletions": 8, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/543f4571697178193c4619020e05853c2fb60e0c/src%2Flibrustc_lint%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/543f4571697178193c4619020e05853c2fb60e0c/src%2Flibrustc_lint%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Flib.rs?ref=543f4571697178193c4619020e05853c2fb60e0c", "patch": "@@ -19,15 +19,10 @@\n \n #![recursion_limit=\"256\"]\n \n-#[macro_use]\n-extern crate syntax;\n+#![deny(rust_2018_idioms)]\n+\n #[macro_use]\n extern crate rustc;\n-#[macro_use]\n-extern crate log;\n-extern crate rustc_target;\n-extern crate syntax_pos;\n-extern crate rustc_data_structures;\n \n mod diagnostics;\n mod nonstandard_style;\n@@ -49,7 +44,6 @@ use rustc::lint::builtin::{\n     parser::ILL_FORMED_ATTRIBUTE_INPUT,\n };\n use rustc::session;\n-use rustc::util;\n use rustc::hir;\n \n use syntax::ast;"}, {"sha": "2dbafc7ede2a22a33688729aad6d5cbe462abb36", "filename": "src/librustc_lint/nonstandard_style.rs", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/543f4571697178193c4619020e05853c2fb60e0c/src%2Flibrustc_lint%2Fnonstandard_style.rs", "raw_url": "https://github.com/rust-lang/rust/raw/543f4571697178193c4619020e05853c2fb60e0c/src%2Flibrustc_lint%2Fnonstandard_style.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fnonstandard_style.rs?ref=543f4571697178193c4619020e05853c2fb60e0c", "patch": "@@ -1,6 +1,7 @@\n use rustc::hir::{self, GenericParamKind, PatKind};\n use rustc::hir::def::Def;\n use rustc::hir::intravisit::FnKind;\n+use rustc::lint;\n use rustc::ty;\n use rustc_target::spec::abi::Abi;\n use lint::{EarlyContext, LateContext, LintContext, LintArray};\n@@ -17,7 +18,7 @@ pub enum MethodLateContext {\n     PlainImpl,\n }\n \n-pub fn method_context(cx: &LateContext, id: ast::NodeId) -> MethodLateContext {\n+pub fn method_context(cx: &LateContext<'_, '_>, id: ast::NodeId) -> MethodLateContext {\n     let def_id = cx.tcx.hir().local_def_id(id);\n     let item = cx.tcx.associated_item(def_id);\n     match item.container {\n@@ -41,7 +42,7 @@ declare_lint! {\n pub struct NonCamelCaseTypes;\n \n impl NonCamelCaseTypes {\n-    fn check_case(&self, cx: &EarlyContext, sort: &str, ident: &Ident) {\n+    fn check_case(&self, cx: &EarlyContext<'_>, sort: &str, ident: &Ident) {\n         fn char_has_case(c: char) -> bool {\n             c.is_lowercase() || c.is_uppercase()\n         }\n@@ -115,7 +116,7 @@ impl LintPass for NonCamelCaseTypes {\n }\n \n impl EarlyLintPass for NonCamelCaseTypes {\n-    fn check_item(&mut self, cx: &EarlyContext, it: &ast::Item) {\n+    fn check_item(&mut self, cx: &EarlyContext<'_>, it: &ast::Item) {\n         let has_repr_c = it.attrs\n             .iter()\n             .any(|attr| {\n@@ -138,11 +139,11 @@ impl EarlyLintPass for NonCamelCaseTypes {\n         }\n     }\n \n-    fn check_variant(&mut self, cx: &EarlyContext, v: &ast::Variant, _: &ast::Generics) {\n+    fn check_variant(&mut self, cx: &EarlyContext<'_>, v: &ast::Variant, _: &ast::Generics) {\n         self.check_case(cx, \"variant\", &v.node.ident);\n     }\n \n-    fn check_generic_param(&mut self, cx: &EarlyContext, param: &ast::GenericParam) {\n+    fn check_generic_param(&mut self, cx: &EarlyContext<'_>, param: &ast::GenericParam) {\n         if let ast::GenericParamKind::Type { .. } = param.kind {\n             self.check_case(cx, \"type parameter\", &param.ident);\n         }\n@@ -190,7 +191,7 @@ impl NonSnakeCase {\n     }\n \n     /// Checks if a given identifier is snake case, and reports a diagnostic if not.\n-    fn check_snake_case(&self, cx: &LateContext, sort: &str, ident: &Ident) {\n+    fn check_snake_case(&self, cx: &LateContext<'_, '_>, sort: &str, ident: &Ident) {\n         fn is_snake_case(ident: &str) -> bool {\n             if ident.is_empty() {\n                 return true;\n@@ -249,7 +250,7 @@ impl LintPass for NonSnakeCase {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonSnakeCase {\n-    fn check_crate(&mut self, cx: &LateContext, cr: &hir::Crate) {\n+    fn check_crate(&mut self, cx: &LateContext<'_, '_>, cr: &hir::Crate) {\n         let crate_ident = if let Some(name) = &cx.tcx.sess.opts.crate_name {\n             Some(Ident::from_str(name))\n         } else {\n@@ -286,16 +287,16 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonSnakeCase {\n         }\n     }\n \n-    fn check_generic_param(&mut self, cx: &LateContext, param: &hir::GenericParam) {\n+    fn check_generic_param(&mut self, cx: &LateContext<'_, '_>, param: &hir::GenericParam) {\n         if let GenericParamKind::Lifetime { .. } = param.kind {\n             self.check_snake_case(cx, \"lifetime\", &param.name.ident());\n         }\n     }\n \n     fn check_fn(\n         &mut self,\n-        cx: &LateContext,\n-        fk: FnKind,\n+        cx: &LateContext<'_, '_>,\n+        fk: FnKind<'_>,\n         _: &hir::FnDecl,\n         _: &hir::Body,\n         _: Span,\n@@ -324,13 +325,13 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonSnakeCase {\n         }\n     }\n \n-    fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n+    fn check_item(&mut self, cx: &LateContext<'_, '_>, it: &hir::Item) {\n         if let hir::ItemKind::Mod(_) = it.node {\n             self.check_snake_case(cx, \"module\", &it.ident);\n         }\n     }\n \n-    fn check_trait_item(&mut self, cx: &LateContext, item: &hir::TraitItem) {\n+    fn check_trait_item(&mut self, cx: &LateContext<'_, '_>, item: &hir::TraitItem) {\n         if let hir::TraitItemKind::Method(_, hir::TraitMethod::Required(pnames)) = &item.node {\n             self.check_snake_case(cx, \"trait method\", &item.ident);\n             for param_name in pnames {\n@@ -339,15 +340,15 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonSnakeCase {\n         }\n     }\n \n-    fn check_pat(&mut self, cx: &LateContext, p: &hir::Pat) {\n+    fn check_pat(&mut self, cx: &LateContext<'_, '_>, p: &hir::Pat) {\n         if let &PatKind::Binding(_, _, _, ident, _) = &p.node {\n             self.check_snake_case(cx, \"variable\", &ident);\n         }\n     }\n \n     fn check_struct_def(\n         &mut self,\n-        cx: &LateContext,\n+        cx: &LateContext<'_, '_>,\n         s: &hir::VariantData,\n         _: ast::Name,\n         _: &hir::Generics,\n@@ -369,7 +370,7 @@ declare_lint! {\n pub struct NonUpperCaseGlobals;\n \n impl NonUpperCaseGlobals {\n-    fn check_upper_case(cx: &LateContext, sort: &str, ident: &Ident) {\n+    fn check_upper_case(cx: &LateContext<'_, '_>, sort: &str, ident: &Ident) {\n         let name = &ident.name.as_str();\n \n         if name.chars().any(|c| c.is_lowercase()) {\n@@ -399,7 +400,7 @@ impl LintPass for NonUpperCaseGlobals {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonUpperCaseGlobals {\n-    fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n+    fn check_item(&mut self, cx: &LateContext<'_, '_>, it: &hir::Item) {\n         match it.node {\n             hir::ItemKind::Static(..) if !attr::contains_name(&it.attrs, \"no_mangle\") => {\n                 NonUpperCaseGlobals::check_upper_case(cx, \"static variable\", &it.ident);\n@@ -411,19 +412,19 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for NonUpperCaseGlobals {\n         }\n     }\n \n-    fn check_trait_item(&mut self, cx: &LateContext, ti: &hir::TraitItem) {\n+    fn check_trait_item(&mut self, cx: &LateContext<'_, '_>, ti: &hir::TraitItem) {\n         if let hir::TraitItemKind::Const(..) = ti.node {\n             NonUpperCaseGlobals::check_upper_case(cx, \"associated constant\", &ti.ident);\n         }\n     }\n \n-    fn check_impl_item(&mut self, cx: &LateContext, ii: &hir::ImplItem) {\n+    fn check_impl_item(&mut self, cx: &LateContext<'_, '_>, ii: &hir::ImplItem) {\n         if let hir::ImplItemKind::Const(..) = ii.node {\n             NonUpperCaseGlobals::check_upper_case(cx, \"associated constant\", &ii.ident);\n         }\n     }\n \n-    fn check_pat(&mut self, cx: &LateContext, p: &hir::Pat) {\n+    fn check_pat(&mut self, cx: &LateContext<'_, '_>, p: &hir::Pat) {\n         // Lint for constants that look like binding identifiers (#7526)\n         if let PatKind::Path(hir::QPath::Resolved(None, ref path)) = p.node {\n             if let Def::Const(..) = path.def {"}, {"sha": "f6b7ccfe2ecd8de9d0cc23e7bfcb9f1fae2eda4b", "filename": "src/librustc_lint/types.rs", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/543f4571697178193c4619020e05853c2fb60e0c/src%2Flibrustc_lint%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/543f4571697178193c4619020e05853c2fb60e0c/src%2Flibrustc_lint%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Ftypes.rs?ref=543f4571697178193c4619020e05853c2fb60e0c", "patch": "@@ -4,6 +4,7 @@ use rustc::hir::Node;\n use rustc::ty::subst::Substs;\n use rustc::ty::{self, AdtKind, ParamEnv, Ty, TyCtxt};\n use rustc::ty::layout::{self, IntegerExt, LayoutOf, VariantIdx};\n+use rustc::{lint, util};\n use rustc_data_structures::indexed_vec::Idx;\n use util::nodemap::FxHashSet;\n use lint::{LateContext, LintContext, LintArray};\n@@ -23,6 +24,8 @@ use rustc::hir;\n \n use rustc::mir::interpret::{sign_extend, truncate};\n \n+use log::debug;\n+\n declare_lint! {\n     UNUSED_COMPARISONS,\n     Warn,\n@@ -241,7 +244,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n             }\n         }\n \n-        fn check_limits(cx: &LateContext,\n+        fn check_limits(cx: &LateContext<'_, '_>,\n                         binop: hir::BinOp,\n                         l: &hir::Expr,\n                         r: &hir::Expr)\n@@ -298,7 +301,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n             }\n         }\n \n-        fn get_bin_hex_repr(cx: &LateContext, lit: &ast::Lit) -> Option<String> {\n+        fn get_bin_hex_repr(cx: &LateContext<'_, '_>, lit: &ast::Lit) -> Option<String> {\n             let src = cx.sess().source_map().span_to_snippet(lit.span).ok()?;\n             let firstch = src.chars().next()?;\n \n@@ -320,7 +323,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n         //\n         // No suggestion for: `isize`, `usize`.\n         fn get_type_suggestion<'a>(\n-            t: &ty::TyKind,\n+            t: &ty::TyKind<'_>,\n             val: u128,\n             negative: bool,\n         ) -> Option<String> {\n@@ -364,9 +367,9 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for TypeLimits {\n         }\n \n         fn report_bin_hex_error(\n-            cx: &LateContext,\n+            cx: &LateContext<'_, '_>,\n             expr: &hir::Expr,\n-            ty: ty::TyKind,\n+            ty: ty::TyKind<'_>,\n             repr_str: String,\n             val: u128,\n             negative: bool,\n@@ -481,7 +484,7 @@ impl<'a, 'tcx> ImproperCTypesVisitor<'a, 'tcx> {\n     fn check_type_for_ffi(&self,\n                           cache: &mut FxHashSet<Ty<'tcx>>,\n                           ty: Ty<'tcx>) -> FfiResult<'tcx> {\n-        use self::FfiResult::*;\n+        use FfiResult::*;\n \n         let cx = self.cx.tcx;\n \n@@ -799,7 +802,7 @@ impl LintPass for ImproperCTypes {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for ImproperCTypes {\n-    fn check_foreign_item(&mut self, cx: &LateContext, it: &hir::ForeignItem) {\n+    fn check_foreign_item(&mut self, cx: &LateContext<'_, '_>, it: &hir::ForeignItem) {\n         let mut vis = ImproperCTypesVisitor { cx };\n         let abi = cx.tcx.hir().get_foreign_abi(it.id);\n         if abi != Abi::RustIntrinsic && abi != Abi::PlatformIntrinsic {\n@@ -829,7 +832,7 @@ impl LintPass for VariantSizeDifferences {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for VariantSizeDifferences {\n-    fn check_item(&mut self, cx: &LateContext, it: &hir::Item) {\n+    fn check_item(&mut self, cx: &LateContext<'_, '_>, it: &hir::Item) {\n         if let hir::ItemKind::Enum(ref enum_definition, _) = it.node {\n             let item_def_id = cx.tcx.hir().local_def_id(it.id);\n             let t = cx.tcx.type_of(item_def_id);"}, {"sha": "407e6842935151b355441a8dc335da4a467c7d54", "filename": "src/librustc_lint/unused.rs", "status": "modified", "additions": 16, "deletions": 13, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/543f4571697178193c4619020e05853c2fb60e0c/src%2Flibrustc_lint%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/543f4571697178193c4619020e05853c2fb60e0c/src%2Flibrustc_lint%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Funused.rs?ref=543f4571697178193c4619020e05853c2fb60e0c", "patch": "@@ -1,5 +1,6 @@\n use rustc::hir::def::Def;\n use rustc::hir::def_id::DefId;\n+use rustc::lint;\n use rustc::ty;\n use rustc::ty::adjustment;\n use lint::{LateContext, EarlyContext, LintContext, LintArray};\n@@ -16,6 +17,8 @@ use syntax_pos::Span;\n \n use rustc::hir;\n \n+use log::debug;\n+\n declare_lint! {\n     pub UNUSED_MUST_USE,\n     Warn,\n@@ -43,7 +46,7 @@ impl LintPass for UnusedResults {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n-    fn check_stmt(&mut self, cx: &LateContext, s: &hir::Stmt) {\n+    fn check_stmt(&mut self, cx: &LateContext<'_, '_>, s: &hir::Stmt) {\n         let expr = match s.node {\n             hir::StmtKind::Semi(ref expr) => &**expr,\n             _ => return,\n@@ -168,7 +171,7 @@ impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedResults {\n         }\n \n         fn check_must_use(\n-            cx: &LateContext,\n+            cx: &LateContext<'_, '_>,\n             def_id: DefId,\n             sp: Span,\n             descr_pre_path: &str,\n@@ -212,7 +215,7 @@ impl LintPass for PathStatements {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for PathStatements {\n-    fn check_stmt(&mut self, cx: &LateContext, s: &hir::Stmt) {\n+    fn check_stmt(&mut self, cx: &LateContext<'_, '_>, s: &hir::Stmt) {\n         if let hir::StmtKind::Semi(ref expr) = s.node {\n             if let hir::ExprKind::Path(_) = expr.node {\n                 cx.span_lint(PATH_STATEMENTS, s.span, \"path statement with no effect\");\n@@ -241,7 +244,7 @@ impl LintPass for UnusedAttributes {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedAttributes {\n-    fn check_attribute(&mut self, cx: &LateContext, attr: &ast::Attribute) {\n+    fn check_attribute(&mut self, cx: &LateContext<'_, '_>, attr: &ast::Attribute) {\n         debug!(\"checking attribute: {:?}\", attr);\n         // Note that check_name() marks the attribute as used if it matches.\n         for &(name, ty, ..) in BUILTIN_ATTRIBUTES {\n@@ -303,7 +306,7 @@ pub struct UnusedParens;\n \n impl UnusedParens {\n     fn check_unused_parens_expr(&self,\n-                                cx: &EarlyContext,\n+                                cx: &EarlyContext<'_>,\n                                 value: &ast::Expr,\n                                 msg: &str,\n                                 followed_by_block: bool) {\n@@ -325,7 +328,7 @@ impl UnusedParens {\n     }\n \n     fn check_unused_parens_pat(&self,\n-                                cx: &EarlyContext,\n+                                cx: &EarlyContext<'_>,\n                                 value: &ast::Pat,\n                                 msg: &str) {\n         if let ast::PatKind::Paren(_) = value.node {\n@@ -339,7 +342,7 @@ impl UnusedParens {\n         }\n     }\n \n-    fn remove_outer_parens(cx: &EarlyContext, span: Span, pattern: &str, msg: &str) {\n+    fn remove_outer_parens(cx: &EarlyContext<'_>, span: Span, pattern: &str, msg: &str) {\n         let span_msg = format!(\"unnecessary parentheses around {}\", msg);\n         let mut err = cx.struct_span_lint(UNUSED_PARENS, span, &span_msg);\n         let mut ate_left_paren = false;\n@@ -387,7 +390,7 @@ impl LintPass for UnusedParens {\n }\n \n impl EarlyLintPass for UnusedParens {\n-    fn check_expr(&mut self, cx: &EarlyContext, e: &ast::Expr) {\n+    fn check_expr(&mut self, cx: &EarlyContext<'_>, e: &ast::Expr) {\n         use syntax::ast::ExprKind::*;\n         let (value, msg, followed_by_block) = match e.node {\n             If(ref cond, ..) => (cond, \"`if` condition\", true),\n@@ -429,7 +432,7 @@ impl EarlyLintPass for UnusedParens {\n         self.check_unused_parens_expr(cx, &value, msg, followed_by_block);\n     }\n \n-    fn check_pat(&mut self, cx: &EarlyContext, p: &ast::Pat, _: &mut bool) {\n+    fn check_pat(&mut self, cx: &EarlyContext<'_>, p: &ast::Pat, _: &mut bool) {\n         use ast::PatKind::{Paren, Range};\n         // The lint visitor will visit each subpattern of `p`. We do not want to lint any range\n         // pattern no matter where it occurs in the pattern. For something like `&(a..=b)`, there\n@@ -443,7 +446,7 @@ impl EarlyLintPass for UnusedParens {\n         }\n     }\n \n-    fn check_stmt(&mut self, cx: &EarlyContext, s: &ast::Stmt) {\n+    fn check_stmt(&mut self, cx: &EarlyContext<'_>, s: &ast::Stmt) {\n         if let ast::StmtKind::Local(ref local) = s.node {\n             if let Some(ref value) = local.init {\n                 self.check_unused_parens_expr(cx, &value, \"assigned value\", false);\n@@ -462,7 +465,7 @@ declare_lint! {\n pub struct UnusedImportBraces;\n \n impl UnusedImportBraces {\n-    fn check_use_tree(&self, cx: &EarlyContext, use_tree: &ast::UseTree, item: &ast::Item) {\n+    fn check_use_tree(&self, cx: &EarlyContext<'_>, use_tree: &ast::UseTree, item: &ast::Item) {\n         if let ast::UseTreeKind::Nested(ref items) = use_tree.kind {\n             // Recursively check nested UseTrees\n             for &(ref tree, _) in items {\n@@ -509,7 +512,7 @@ impl LintPass for UnusedImportBraces {\n }\n \n impl EarlyLintPass for UnusedImportBraces {\n-    fn check_item(&mut self, cx: &EarlyContext, item: &ast::Item) {\n+    fn check_item(&mut self, cx: &EarlyContext<'_>, item: &ast::Item) {\n         if let ast::ItemKind::Use(ref use_tree) = item.node {\n             self.check_use_tree(cx, use_tree, item);\n         }\n@@ -536,7 +539,7 @@ impl LintPass for UnusedAllocation {\n }\n \n impl<'a, 'tcx> LateLintPass<'a, 'tcx> for UnusedAllocation {\n-    fn check_expr(&mut self, cx: &LateContext, e: &hir::Expr) {\n+    fn check_expr(&mut self, cx: &LateContext<'_, '_>, e: &hir::Expr) {\n         match e.node {\n             hir::ExprKind::Box(_) => {}\n             _ => return,"}]}