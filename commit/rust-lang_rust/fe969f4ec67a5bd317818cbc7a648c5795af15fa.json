{"sha": "fe969f4ec67a5bd317818cbc7a648c5795af15fa", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZlOTY5ZjRlYzY3YTViZDMxNzgxOGNiYzdhNjQ4YzU3OTVhZjE1ZmE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-29T08:12:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2019-11-29T08:12:43Z"}, "message": "Auto merge of #66590 - Aaron1011:fix/real-impl-trait-coherence, r=varkor\n\nApply proper commit from PR #63934\n\nWhile working on PR #63934, I accidentally reverted to an older version\nof the PR while working on a rebase. The PR was then merged, not with\nthe later, approved changes, but with earlier, unapproved changes.\n\nThis PR applies the changes that were *suppoesd* to be mereged in\nPR #63934. All of the proper tests appear to have been merged\nin PR #63934, so this PR adds no new tests", "tree": {"sha": "5f7458527733b0fb162a198bf5006f084a6a86aa", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5f7458527733b0fb162a198bf5006f084a6a86aa"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fe969f4ec67a5bd317818cbc7a648c5795af15fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fe969f4ec67a5bd317818cbc7a648c5795af15fa", "html_url": "https://github.com/rust-lang/rust/commit/fe969f4ec67a5bd317818cbc7a648c5795af15fa", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fe969f4ec67a5bd317818cbc7a648c5795af15fa/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3907d59bcf6824f32bf9c91205f0c2dbcc467658", "url": "https://api.github.com/repos/rust-lang/rust/commits/3907d59bcf6824f32bf9c91205f0c2dbcc467658", "html_url": "https://github.com/rust-lang/rust/commit/3907d59bcf6824f32bf9c91205f0c2dbcc467658"}, {"sha": "79fcaf8f12017fed25cb8f8f077a762408af8c9c", "url": "https://api.github.com/repos/rust-lang/rust/commits/79fcaf8f12017fed25cb8f8f077a762408af8c9c", "html_url": "https://github.com/rust-lang/rust/commit/79fcaf8f12017fed25cb8f8f077a762408af8c9c"}], "stats": {"total": 67, "additions": 52, "deletions": 15}, "files": [{"sha": "933bc06c21efedfd2086cd052a0c119c65815acf", "filename": "src/librustc/traits/coherence.rs", "status": "modified", "additions": 33, "deletions": 15, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/fe969f4ec67a5bd317818cbc7a648c5795af15fa/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe969f4ec67a5bd317818cbc7a648c5795af15fa/src%2Flibrustc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Fcoherence.rs?ref=fe969f4ec67a5bd317818cbc7a648c5795af15fa", "patch": "@@ -382,7 +382,7 @@ fn orphan_check_trait_ref<'tcx>(\n         ty: Ty<'tcx>,\n         in_crate: InCrate,\n     ) -> Vec<Ty<'tcx>> {\n-        if fundamental_ty(ty) && ty_is_non_local(tcx, ty, in_crate).is_some() {\n+        if fundamental_ty(ty) && ty_is_non_local(ty, in_crate).is_some() {\n             ty.walk_shallow().flat_map(|ty| uncover_fundamental_ty(tcx, ty, in_crate)).collect()\n         } else {\n             vec![ty]\n@@ -396,7 +396,7 @@ fn orphan_check_trait_ref<'tcx>(\n         .enumerate()\n     {\n         debug!(\"orphan_check_trait_ref: check ty `{:?}`\", input_ty);\n-        let non_local_tys = ty_is_non_local(tcx, input_ty, in_crate);\n+        let non_local_tys = ty_is_non_local(input_ty, in_crate);\n         if non_local_tys.is_none() {\n             debug!(\"orphan_check_trait_ref: ty_is_local `{:?}`\", input_ty);\n             return Ok(());\n@@ -405,7 +405,7 @@ fn orphan_check_trait_ref<'tcx>(\n             let local_type = trait_ref\n                 .input_types()\n                 .flat_map(|ty| uncover_fundamental_ty(tcx, ty, in_crate))\n-                .filter(|ty| ty_is_non_local_constructor(tcx, ty, in_crate).is_none())\n+                .filter(|ty| ty_is_non_local_constructor(ty, in_crate).is_none())\n                 .next();\n \n             debug!(\"orphan_check_trait_ref: uncovered ty local_type: `{:?}`\", local_type);\n@@ -423,13 +423,13 @@ fn orphan_check_trait_ref<'tcx>(\n     Err(OrphanCheckErr::NonLocalInputType(non_local_spans))\n }\n \n-fn ty_is_non_local<'t>(tcx: TyCtxt<'t>, ty: Ty<'t>, in_crate: InCrate) -> Option<Vec<Ty<'t>>> {\n-    match ty_is_non_local_constructor(tcx, ty, in_crate) {\n+fn ty_is_non_local<'t>(ty: Ty<'t>, in_crate: InCrate) -> Option<Vec<Ty<'t>>> {\n+    match ty_is_non_local_constructor(ty, in_crate) {\n         Some(ty) => if !fundamental_ty(ty) {\n             Some(vec![ty])\n         } else {\n             let tys: Vec<_> = ty.walk_shallow()\n-                .filter_map(|t| ty_is_non_local(tcx, t, in_crate))\n+                .filter_map(|t| ty_is_non_local(t, in_crate))\n                 .flat_map(|i| i)\n                 .collect();\n             if tys.is_empty() {\n@@ -460,7 +460,6 @@ fn def_id_is_local(def_id: DefId, in_crate: InCrate) -> bool {\n }\n \n fn ty_is_non_local_constructor<'tcx>(\n-    tcx: TyCtxt<'tcx>,\n     ty: Ty<'tcx>,\n     in_crate: InCrate,\n ) -> Option<Ty<'tcx>> {\n@@ -503,14 +502,33 @@ fn ty_is_non_local_constructor<'tcx>(\n         } else {\n             Some(ty)\n         },\n-        ty::Opaque(did, _) => {\n-            // Check the underlying type that this opaque\n-            // type resolves to.\n-            // This recursion will eventually terminate,\n-            // since we've already managed to successfully\n-            // resolve all opaque types by this point\n-            let real_ty = tcx.type_of(did);\n-            ty_is_non_local_constructor(tcx, real_ty, in_crate)\n+        ty::Opaque(..) => {\n+            // This merits some explanation.\n+            // Normally, opaque types are not involed when performing\n+            // coherence checking, since it is illegal to directly\n+            // implement a trait on an opaque type. However, we might\n+            // end up looking at an opaque type during coherence checking\n+            // if an opaque type gets used within another type (e.g. as\n+            // a type parameter). This requires us to decide whether or\n+            // not an opaque type should be considered 'local' or not.\n+            //\n+            // We choose to treat all opaque types as non-local, even\n+            // those that appear within the same crate. This seems\n+            // somewhat suprising at first, but makes sense when\n+            // you consider that opaque types are supposed to hide\n+            // the underlying type *within the same crate*. When an\n+            // opaque type is used from outside the module\n+            // where it is declared, it should be impossible to observe\n+            // anyything about it other than the traits that it implements.\n+            //\n+            // The alternative would be to look at the underlying type\n+            // to determine whether or not the opaque type itself should\n+            // be considered local. However, this could make it a breaking change\n+            // to switch the underlying ('defining') type from a local type\n+            // to a remote type. This would violate the rule that opaque\n+            // types should be completely opaque apart from the traits\n+            // that they implement, so we don't use this behavior.\n+            Some(ty)\n         }\n \n         ty::Dynamic(ref tt, ..) => {"}, {"sha": "1d95cc7530c5e7b37e5e3c9bb37460dd2e8a7566", "filename": "src/test/ui/type-alias-impl-trait/issue-66580-closure-coherence.rs", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/fe969f4ec67a5bd317818cbc7a648c5795af15fa/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-66580-closure-coherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fe969f4ec67a5bd317818cbc7a648c5795af15fa/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-66580-closure-coherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Ftype-alias-impl-trait%2Fissue-66580-closure-coherence.rs?ref=fe969f4ec67a5bd317818cbc7a648c5795af15fa", "patch": "@@ -0,0 +1,19 @@\n+// Regression test for issue #66580\n+// Ensures that we don't try to determine whether a closure\n+// is foreign when it's the underlying type of an opaque type\n+// check-pass\n+#![feature(type_alias_impl_trait)]\n+\n+type Closure = impl FnOnce();\n+\n+fn closure() -> Closure {\n+    || {}\n+}\n+\n+struct Wrap<T> { f: T }\n+\n+impl Wrap<Closure> {}\n+\n+impl<T> Wrap<T> {}\n+\n+fn main() {}"}]}