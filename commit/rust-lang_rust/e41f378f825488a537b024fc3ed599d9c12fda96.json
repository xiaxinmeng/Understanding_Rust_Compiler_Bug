{"sha": "e41f378f825488a537b024fc3ed599d9c12fda96", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU0MWYzNzhmODI1NDg4YTUzN2IwMjRmYzNlZDU5OWQ5YzEyZmRhOTY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-04-12T00:38:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-04-12T00:38:20Z"}, "message": "Auto merge of #84112 - Dylan-DPC:rollup-tapsrzz, r=Dylan-DPC\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #83669 (Issue 81508 fix)\n - #84014 (Improve trait/impl method discrepancy errors)\n - #84059 (Bump libc dependency of std to 0.2.93)\n - #84067 (clean up example on read_to_string)\n - #84079 (Improve test for `rustdoc::bare_urls` lint)\n - #84094 (Remove FixedSizeArray)\n - #84101 (rustdoc: Move crate loader to collect_intra_doc_links::early )\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "b9d939abd2fa4e173de4c8d45d02e7c8d3033a52", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/b9d939abd2fa4e173de4c8d45d02e7c8d3033a52"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e41f378f825488a537b024fc3ed599d9c12fda96", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e41f378f825488a537b024fc3ed599d9c12fda96", "html_url": "https://github.com/rust-lang/rust/commit/e41f378f825488a537b024fc3ed599d9c12fda96", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e41f378f825488a537b024fc3ed599d9c12fda96/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3f8added7003120582953d4f3f43991fb3bb2798", "url": "https://api.github.com/repos/rust-lang/rust/commits/3f8added7003120582953d4f3f43991fb3bb2798", "html_url": "https://github.com/rust-lang/rust/commit/3f8added7003120582953d4f3f43991fb3bb2798"}, {"sha": "1ff117e987be82e9cff59350fd1810ebe21f8b26", "url": "https://api.github.com/repos/rust-lang/rust/commits/1ff117e987be82e9cff59350fd1810ebe21f8b26", "html_url": "https://github.com/rust-lang/rust/commit/1ff117e987be82e9cff59350fd1810ebe21f8b26"}], "stats": {"total": 1003, "additions": 671, "deletions": 332}, "files": [{"sha": "ac7a1a5c3e93971d851474debd06c7dead8cc92c", "filename": "Cargo.lock", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/e41f378f825488a537b024fc3ed599d9c12fda96/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/e41f378f825488a537b024fc3ed599d9c12fda96/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=e41f378f825488a537b024fc3ed599d9c12fda96", "patch": "@@ -1909,9 +1909,9 @@ checksum = \"830d08ce1d1d941e6b30645f1a0eb5643013d835ce3779a5fc208261dbe10f55\"\n \n [[package]]\n name = \"libc\"\n-version = \"0.2.88\"\n+version = \"0.2.93\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"03b07a082330a35e43f63177cc01689da34fbffa0105e1246cf0311472cac73a\"\n+checksum = \"9385f66bf6105b241aa65a61cb923ef20efc665cb9f9bb50ac2f0c4b7f378d41\"\n dependencies = [\n  \"rustc-std-workspace-core\",\n ]"}, {"sha": "008e6d015e879e2068c78cc80dbbe19bf1168b6e", "filename": "compiler/rustc_middle/src/ty/error.rs", "status": "modified", "additions": 8, "deletions": 5, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e41f378f825488a537b024fc3ed599d9c12fda96/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e41f378f825488a537b024fc3ed599d9c12fda96/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Ferror.rs?ref=e41f378f825488a537b024fc3ed599d9c12fda96", "patch": "@@ -36,6 +36,7 @@ pub enum TypeError<'tcx> {\n     UnsafetyMismatch(ExpectedFound<hir::Unsafety>),\n     AbiMismatch(ExpectedFound<abi::Abi>),\n     Mutability,\n+    ArgumentMutability(usize),\n     TupleSize(ExpectedFound<usize>),\n     FixedArraySize(ExpectedFound<u64>),\n     ArgCount,\n@@ -46,6 +47,7 @@ pub enum TypeError<'tcx> {\n     RegionsPlaceholderMismatch,\n \n     Sorts(ExpectedFound<Ty<'tcx>>),\n+    ArgumentSorts(ExpectedFound<Ty<'tcx>>, usize),\n     IntMismatch(ExpectedFound<ty::IntVarValue>),\n     FloatMismatch(ExpectedFound<ty::FloatTy>),\n     Traits(ExpectedFound<DefId>),\n@@ -110,7 +112,7 @@ impl<'tcx> fmt::Display for TypeError<'tcx> {\n             AbiMismatch(values) => {\n                 write!(f, \"expected {} fn, found {} fn\", values.expected, values.found)\n             }\n-            Mutability => write!(f, \"types differ in mutability\"),\n+            ArgumentMutability(_) | Mutability => write!(f, \"types differ in mutability\"),\n             TupleSize(values) => write!(\n                 f,\n                 \"expected a tuple with {} element{}, \\\n@@ -142,7 +144,7 @@ impl<'tcx> fmt::Display for TypeError<'tcx> {\n                 br_string(br)\n             ),\n             RegionsPlaceholderMismatch => write!(f, \"one type is more general than the other\"),\n-            Sorts(values) => ty::tls::with(|tcx| {\n+            ArgumentSorts(values, _) | Sorts(values) => ty::tls::with(|tcx| {\n                 report_maybe_different(\n                     f,\n                     &values.expected.sort_string(tcx),\n@@ -199,10 +201,11 @@ impl<'tcx> TypeError<'tcx> {\n         use self::TypeError::*;\n         match self {\n             CyclicTy(_) | CyclicConst(_) | UnsafetyMismatch(_) | Mismatch | AbiMismatch(_)\n-            | FixedArraySize(_) | Sorts(_) | IntMismatch(_) | FloatMismatch(_)\n-            | VariadicMismatch(_) | TargetFeatureCast(_) => false,\n+            | FixedArraySize(_) | ArgumentSorts(..) | Sorts(_) | IntMismatch(_)\n+            | FloatMismatch(_) | VariadicMismatch(_) | TargetFeatureCast(_) => false,\n \n             Mutability\n+            | ArgumentMutability(_)\n             | TupleSize(_)\n             | ArgCount\n             | RegionsDoesNotOutlive(..)\n@@ -339,7 +342,7 @@ impl<'tcx> TyCtxt<'tcx> {\n         use self::TypeError::*;\n         debug!(\"note_and_explain_type_err err={:?} cause={:?}\", err, cause);\n         match err {\n-            Sorts(values) => {\n+            ArgumentSorts(values, _) | Sorts(values) => {\n                 match (values.expected.kind(), values.found.kind()) {\n                     (ty::Closure(..), ty::Closure(..)) => {\n                         db.note(\"no two closures, even if identical, have the same type\");"}, {"sha": "b6f93c9bd59e79bbe51efb25aefa106fdcea6e10", "filename": "compiler/rustc_middle/src/ty/relate.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e41f378f825488a537b024fc3ed599d9c12fda96/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e41f378f825488a537b024fc3ed599d9c12fda96/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Frelate.rs?ref=e41f378f825488a537b024fc3ed599d9c12fda96", "patch": "@@ -179,6 +179,12 @@ impl<'tcx> Relate<'tcx> for ty::FnSig<'tcx> {\n                 } else {\n                     relation.relate_with_variance(ty::Contravariant, a, b)\n                 }\n+            })\n+            .enumerate()\n+            .map(|(i, r)| match r {\n+                Err(TypeError::Sorts(exp_found)) => Err(TypeError::ArgumentSorts(exp_found, i)),\n+                Err(TypeError::Mutability) => Err(TypeError::ArgumentMutability(i)),\n+                r => r,\n             });\n         Ok(ty::FnSig {\n             inputs_and_output: tcx.mk_type_list(inputs_and_output)?,"}, {"sha": "7290c41d615dfbb962b3d49f693bb3b2bc85ffcf", "filename": "compiler/rustc_middle/src/ty/structural_impls.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e41f378f825488a537b024fc3ed599d9c12fda96/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e41f378f825488a537b024fc3ed599d9c12fda96/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs?ref=e41f378f825488a537b024fc3ed599d9c12fda96", "patch": "@@ -587,6 +587,7 @@ impl<'a, 'tcx> Lift<'tcx> for ty::error::TypeError<'a> {\n             UnsafetyMismatch(x) => UnsafetyMismatch(x),\n             AbiMismatch(x) => AbiMismatch(x),\n             Mutability => Mutability,\n+            ArgumentMutability(i) => ArgumentMutability(i),\n             TupleSize(x) => TupleSize(x),\n             FixedArraySize(x) => FixedArraySize(x),\n             ArgCount => ArgCount,\n@@ -607,6 +608,7 @@ impl<'a, 'tcx> Lift<'tcx> for ty::error::TypeError<'a> {\n             CyclicTy(t) => return tcx.lift(t).map(|t| CyclicTy(t)),\n             CyclicConst(ct) => return tcx.lift(ct).map(|ct| CyclicConst(ct)),\n             ProjectionMismatched(x) => ProjectionMismatched(x),\n+            ArgumentSorts(x, i) => return tcx.lift(x).map(|x| ArgumentSorts(x, i)),\n             Sorts(x) => return tcx.lift(x).map(Sorts),\n             ExistentialMismatch(x) => return tcx.lift(x).map(ExistentialMismatch),\n             ConstMismatch(x) => return tcx.lift(x).map(ConstMismatch),"}, {"sha": "9321f11f6593380f749d79476205eca86929f173", "filename": "compiler/rustc_resolve/src/late.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e41f378f825488a537b024fc3ed599d9c12fda96/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e41f378f825488a537b024fc3ed599d9c12fda96/compiler%2Frustc_resolve%2Fsrc%2Flate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flate.rs?ref=e41f378f825488a537b024fc3ed599d9c12fda96", "patch": "@@ -1031,7 +1031,6 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n             }\n \n             ItemKind::Static(ref ty, _, ref expr) | ItemKind::Const(_, ref ty, ref expr) => {\n-                debug!(\"resolve_item ItemKind::Const\");\n                 self.with_item_rib(HasGenericParams::No, |this| {\n                     this.visit_ty(ty);\n                     if let Some(expr) = expr {\n@@ -1597,6 +1596,7 @@ impl<'a: 'ast, 'b, 'ast> LateResolutionVisitor<'a, 'b, 'ast> {\n                         .try_resolve_as_non_binding(pat_src, pat, bmode, ident, has_sub)\n                         .unwrap_or_else(|| self.fresh_binding(ident, pat.id, pat_src, bindings));\n                     self.r.record_partial_res(pat.id, PartialRes::new(res));\n+                    self.r.record_pat_span(pat.id, pat.span);\n                 }\n                 PatKind::TupleStruct(ref path, ref sub_patterns) => {\n                     self.smart_resolve_path("}, {"sha": "129954381c9baf497321a6e1aea4350cfef88ce6", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 63, "deletions": 2, "changes": 65, "blob_url": "https://github.com/rust-lang/rust/blob/e41f378f825488a537b024fc3ed599d9c12fda96/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e41f378f825488a537b024fc3ed599d9c12fda96/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=e41f378f825488a537b024fc3ed599d9c12fda96", "patch": "@@ -891,6 +891,10 @@ pub struct Resolver<'a> {\n     /// \"self-confirming\" import resolutions during import validation.\n     unusable_binding: Option<&'a NameBinding<'a>>,\n \n+    // Spans for local variables found during pattern resolution.\n+    // Used for suggestions during error reporting.\n+    pat_span_map: NodeMap<Span>,\n+\n     /// Resolutions for nodes that have a single resolution.\n     partial_res_map: NodeMap<PartialRes>,\n     /// Resolutions for import nodes, which have multiple resolutions in different namespaces.\n@@ -1270,6 +1274,7 @@ impl<'a> Resolver<'a> {\n             last_import_segment: false,\n             unusable_binding: None,\n \n+            pat_span_map: Default::default(),\n             partial_res_map: Default::default(),\n             import_res_map: Default::default(),\n             label_res_map: Default::default(),\n@@ -1917,7 +1922,6 @@ impl<'a> Resolver<'a> {\n                 return Some(LexicalScopeBinding::Item(binding));\n             }\n         }\n-\n         self.early_resolve_ident_in_lexical_scope(\n             orig_ident,\n             ScopeSet::Late(ns, module, record_used_id),\n@@ -2394,7 +2398,59 @@ impl<'a> Resolver<'a> {\n                             .next()\n                             .map_or(false, |c| c.is_ascii_uppercase())\n                         {\n-                            (format!(\"use of undeclared type `{}`\", ident), None)\n+                            // Check whether the name refers to an item in the value namespace.\n+                            let suggestion = if ribs.is_some() {\n+                                let match_span = match self.resolve_ident_in_lexical_scope(\n+                                    ident,\n+                                    ValueNS,\n+                                    parent_scope,\n+                                    None,\n+                                    path_span,\n+                                    &ribs.unwrap()[ValueNS],\n+                                ) {\n+                                    // Name matches a local variable. For example:\n+                                    // ```\n+                                    // fn f() {\n+                                    //     let Foo: &str = \"\";\n+                                    //     println!(\"{}\", Foo::Bar); // Name refers to local\n+                                    //                               // variable `Foo`.\n+                                    // }\n+                                    // ```\n+                                    Some(LexicalScopeBinding::Res(Res::Local(id))) => {\n+                                        Some(*self.pat_span_map.get(&id).unwrap())\n+                                    }\n+\n+                                    // Name matches item from a local name binding\n+                                    // created by `use` declaration. For example:\n+                                    // ```\n+                                    // pub Foo: &str = \"\";\n+                                    //\n+                                    // mod submod {\n+                                    //     use super::Foo;\n+                                    //     println!(\"{}\", Foo::Bar); // Name refers to local\n+                                    //                               // binding `Foo`.\n+                                    // }\n+                                    // ```\n+                                    Some(LexicalScopeBinding::Item(name_binding)) => {\n+                                        Some(name_binding.span)\n+                                    }\n+                                    _ => None,\n+                                };\n+\n+                                if let Some(span) = match_span {\n+                                    Some((\n+                                        vec![(span, String::from(\"\"))],\n+                                        format!(\"`{}` is defined here, but is not a type\", ident),\n+                                        Applicability::MaybeIncorrect,\n+                                    ))\n+                                } else {\n+                                    None\n+                                }\n+                            } else {\n+                                None\n+                            };\n+\n+                            (format!(\"use of undeclared type `{}`\", ident), suggestion)\n                         } else {\n                             (format!(\"use of undeclared crate or module `{}`\", ident), None)\n                         }\n@@ -2805,6 +2861,11 @@ impl<'a> Resolver<'a> {\n         }\n     }\n \n+    fn record_pat_span(&mut self, node: NodeId, span: Span) {\n+        debug!(\"(recording pat) recording {:?} for {:?}\", node, span);\n+        self.pat_span_map.insert(node, span);\n+    }\n+\n     fn is_accessible_from(&self, vis: ty::Visibility, module: Module<'a>) -> bool {\n         vis.is_accessible_from(module.nearest_parent_mod, self)\n     }"}, {"sha": "60ca562f9920068d44fc8e5635a65b7ed0a4652b", "filename": "compiler/rustc_typeck/src/check/compare_method.rs", "status": "modified", "additions": 87, "deletions": 81, "changes": 168, "blob_url": "https://github.com/rust-lang/rust/blob/e41f378f825488a537b024fc3ed599d9c12fda96/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e41f378f825488a537b024fc3ed599d9c12fda96/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcompare_method.rs?ref=e41f378f825488a537b024fc3ed599d9c12fda96", "patch": "@@ -278,9 +278,8 @@ fn compare_predicate_entailment<'tcx>(\n         if let Err(terr) = sub_result {\n             debug!(\"sub_types failed: impl ty {:?}, trait ty {:?}\", impl_fty, trait_fty);\n \n-            let (impl_err_span, trait_err_span) = extract_spans_for_error_reporting(\n-                &infcx, param_env, &terr, &cause, impl_m, impl_sig, trait_m, trait_sig,\n-            );\n+            let (impl_err_span, trait_err_span) =\n+                extract_spans_for_error_reporting(&infcx, &terr, &cause, impl_m, trait_m);\n \n             cause.make_mut().span = impl_err_span;\n \n@@ -291,18 +290,79 @@ fn compare_predicate_entailment<'tcx>(\n                 \"method `{}` has an incompatible type for trait\",\n                 trait_m.ident\n             );\n-            if let TypeError::Mutability = terr {\n-                if let Some(trait_err_span) = trait_err_span {\n-                    if let Ok(trait_err_str) = tcx.sess.source_map().span_to_snippet(trait_err_span)\n+            match &terr {\n+                TypeError::ArgumentMutability(0) | TypeError::ArgumentSorts(_, 0)\n+                    if trait_m.fn_has_self_parameter =>\n+                {\n+                    let ty = trait_sig.inputs()[0];\n+                    let sugg = match ExplicitSelf::determine(ty, |_| ty == impl_trait_ref.self_ty())\n                     {\n+                        ExplicitSelf::ByValue => \"self\".to_owned(),\n+                        ExplicitSelf::ByReference(_, hir::Mutability::Not) => \"&self\".to_owned(),\n+                        ExplicitSelf::ByReference(_, hir::Mutability::Mut) => {\n+                            \"&mut self\".to_owned()\n+                        }\n+                        _ => format!(\"self: {}\", ty),\n+                    };\n+\n+                    // When the `impl` receiver is an arbitrary self type, like `self: Box<Self>`, the\n+                    // span points only at the type `Box<Self`>, but we want to cover the whole\n+                    // argument pattern and type.\n+                    let impl_m_hir_id =\n+                        tcx.hir().local_def_id_to_hir_id(impl_m.def_id.expect_local());\n+                    let span = match tcx.hir().expect_impl_item(impl_m_hir_id).kind {\n+                        ImplItemKind::Fn(ref sig, body) => tcx\n+                            .hir()\n+                            .body_param_names(body)\n+                            .zip(sig.decl.inputs.iter())\n+                            .map(|(param, ty)| param.span.to(ty.span))\n+                            .next()\n+                            .unwrap_or(impl_err_span),\n+                        _ => bug!(\"{:?} is not a method\", impl_m),\n+                    };\n+\n+                    diag.span_suggestion(\n+                        span,\n+                        \"change the self-receiver type to match the trait\",\n+                        sugg,\n+                        Applicability::MachineApplicable,\n+                    );\n+                }\n+                TypeError::ArgumentMutability(i) | TypeError::ArgumentSorts(_, i) => {\n+                    if trait_sig.inputs().len() == *i {\n+                        // Suggestion to change output type. We do not suggest in `async` functions\n+                        // to avoid complex logic or incorrect output.\n+                        let impl_m_hir_id =\n+                            tcx.hir().local_def_id_to_hir_id(impl_m.def_id.expect_local());\n+                        match tcx.hir().expect_impl_item(impl_m_hir_id).kind {\n+                            ImplItemKind::Fn(ref sig, _)\n+                                if sig.header.asyncness == hir::IsAsync::NotAsync =>\n+                            {\n+                                let msg = \"change the output type to match the trait\";\n+                                let ap = Applicability::MachineApplicable;\n+                                match sig.decl.output {\n+                                    hir::FnRetTy::DefaultReturn(sp) => {\n+                                        let sugg = format!(\"-> {} \", trait_sig.output());\n+                                        diag.span_suggestion_verbose(sp, msg, sugg, ap);\n+                                    }\n+                                    hir::FnRetTy::Return(hir_ty) => {\n+                                        let sugg = trait_sig.output().to_string();\n+                                        diag.span_suggestion(hir_ty.span, msg, sugg, ap);\n+                                    }\n+                                };\n+                            }\n+                            _ => {}\n+                        };\n+                    } else if let Some(trait_ty) = trait_sig.inputs().get(*i) {\n                         diag.span_suggestion(\n                             impl_err_span,\n-                            \"consider changing the mutability to match the trait\",\n-                            trait_err_str,\n+                            \"change the parameter type to match the trait\",\n+                            trait_ty.to_string(),\n                             Applicability::MachineApplicable,\n                         );\n                     }\n                 }\n+                _ => {}\n             }\n \n             infcx.note_type_err(\n@@ -385,86 +445,35 @@ fn check_region_bounds_on_impl_item<'tcx>(\n \n fn extract_spans_for_error_reporting<'a, 'tcx>(\n     infcx: &infer::InferCtxt<'a, 'tcx>,\n-    param_env: ty::ParamEnv<'tcx>,\n     terr: &TypeError<'_>,\n     cause: &ObligationCause<'tcx>,\n     impl_m: &ty::AssocItem,\n-    impl_sig: ty::FnSig<'tcx>,\n     trait_m: &ty::AssocItem,\n-    trait_sig: ty::FnSig<'tcx>,\n ) -> (Span, Option<Span>) {\n     let tcx = infcx.tcx;\n     let impl_m_hir_id = tcx.hir().local_def_id_to_hir_id(impl_m.def_id.expect_local());\n-    let (impl_m_output, impl_m_iter) = match tcx.hir().expect_impl_item(impl_m_hir_id).kind {\n-        ImplItemKind::Fn(ref impl_m_sig, _) => {\n-            (&impl_m_sig.decl.output, impl_m_sig.decl.inputs.iter())\n+    let mut impl_args = match tcx.hir().expect_impl_item(impl_m_hir_id).kind {\n+        ImplItemKind::Fn(ref sig, _) => {\n+            sig.decl.inputs.iter().map(|t| t.span).chain(iter::once(sig.decl.output.span()))\n         }\n         _ => bug!(\"{:?} is not a method\", impl_m),\n     };\n-\n-    match *terr {\n-        TypeError::Mutability => {\n-            if let Some(def_id) = trait_m.def_id.as_local() {\n-                let trait_m_hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n-                let trait_m_iter = match tcx.hir().expect_trait_item(trait_m_hir_id).kind {\n-                    TraitItemKind::Fn(ref trait_m_sig, _) => trait_m_sig.decl.inputs.iter(),\n-                    _ => bug!(\"{:?} is not a TraitItemKind::Fn\", trait_m),\n-                };\n-\n-                iter::zip(impl_m_iter, trait_m_iter)\n-                    .find(|&(ref impl_arg, ref trait_arg)| {\n-                        match (&impl_arg.kind, &trait_arg.kind) {\n-                            (\n-                                &hir::TyKind::Rptr(_, ref impl_mt),\n-                                &hir::TyKind::Rptr(_, ref trait_mt),\n-                            )\n-                            | (&hir::TyKind::Ptr(ref impl_mt), &hir::TyKind::Ptr(ref trait_mt)) => {\n-                                impl_mt.mutbl != trait_mt.mutbl\n-                            }\n-                            _ => false,\n-                        }\n-                    })\n-                    .map(|(ref impl_arg, ref trait_arg)| (impl_arg.span, Some(trait_arg.span)))\n-                    .unwrap_or_else(|| (cause.span(tcx), tcx.hir().span_if_local(trait_m.def_id)))\n-            } else {\n-                (cause.span(tcx), tcx.hir().span_if_local(trait_m.def_id))\n+    let trait_args = trait_m.def_id.as_local().map(|def_id| {\n+        let trait_m_hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n+        match tcx.hir().expect_trait_item(trait_m_hir_id).kind {\n+            TraitItemKind::Fn(ref sig, _) => {\n+                sig.decl.inputs.iter().map(|t| t.span).chain(iter::once(sig.decl.output.span()))\n             }\n+            _ => bug!(\"{:?} is not a TraitItemKind::Fn\", trait_m),\n         }\n-        TypeError::Sorts(ExpectedFound { .. }) => {\n-            if let Some(def_id) = trait_m.def_id.as_local() {\n-                let trait_m_hir_id = tcx.hir().local_def_id_to_hir_id(def_id);\n-                let (trait_m_output, trait_m_iter) =\n-                    match tcx.hir().expect_trait_item(trait_m_hir_id).kind {\n-                        TraitItemKind::Fn(ref trait_m_sig, _) => {\n-                            (&trait_m_sig.decl.output, trait_m_sig.decl.inputs.iter())\n-                        }\n-                        _ => bug!(\"{:?} is not a TraitItemKind::Fn\", trait_m),\n-                    };\n+    });\n \n-                let impl_iter = impl_sig.inputs().iter();\n-                let trait_iter = trait_sig.inputs().iter();\n-                iter::zip(iter::zip(impl_iter, trait_iter), iter::zip(impl_m_iter, trait_m_iter))\n-                    .find_map(|((&impl_arg_ty, &trait_arg_ty), (impl_arg, trait_arg))| match infcx\n-                        .at(&cause, param_env)\n-                        .sub(trait_arg_ty, impl_arg_ty)\n-                    {\n-                        Ok(_) => None,\n-                        Err(_) => Some((impl_arg.span, Some(trait_arg.span))),\n-                    })\n-                    .unwrap_or_else(|| {\n-                        if infcx\n-                            .at(&cause, param_env)\n-                            .sup(trait_sig.output(), impl_sig.output())\n-                            .is_err()\n-                        {\n-                            (impl_m_output.span(), Some(trait_m_output.span()))\n-                        } else {\n-                            (cause.span(tcx), tcx.hir().span_if_local(trait_m.def_id))\n-                        }\n-                    })\n-            } else {\n-                (cause.span(tcx), tcx.hir().span_if_local(trait_m.def_id))\n-            }\n+    match *terr {\n+        TypeError::ArgumentMutability(i) => {\n+            (impl_args.nth(i).unwrap(), trait_args.and_then(|mut args| args.nth(i)))\n+        }\n+        TypeError::ArgumentSorts(ExpectedFound { .. }, i) => {\n+            (impl_args.nth(i).unwrap(), trait_args.and_then(|mut args| args.nth(i)))\n         }\n         _ => (cause.span(tcx), tcx.hir().span_if_local(trait_m.def_id)),\n     }\n@@ -514,8 +523,7 @@ fn compare_self_type<'tcx>(\n                 tcx.sess,\n                 impl_m_span,\n                 E0185,\n-                \"method `{}` has a `{}` declaration in the impl, but \\\n-                                            not in the trait\",\n+                \"method `{}` has a `{}` declaration in the impl, but not in the trait\",\n                 trait_m.ident,\n                 self_descr\n             );\n@@ -535,8 +543,7 @@ fn compare_self_type<'tcx>(\n                 tcx.sess,\n                 impl_m_span,\n                 E0186,\n-                \"method `{}` has a `{}` declaration in the trait, but \\\n-                                            not in the impl\",\n+                \"method `{}` has a `{}` declaration in the trait, but not in the impl\",\n                 trait_m.ident,\n                 self_descr\n             );\n@@ -993,8 +1000,7 @@ crate fn compare_const_impl<'tcx>(\n                 tcx.sess,\n                 cause.span,\n                 E0326,\n-                \"implemented const `{}` has an incompatible type for \\\n-                                             trait\",\n+                \"implemented const `{}` has an incompatible type for trait\",\n                 trait_c.ident\n             );\n "}, {"sha": "b6ce825e2477a53eed05f3787137e61781d9ebd3", "filename": "library/core/src/array/mod.rs", "status": "modified", "additions": 0, "deletions": 36, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/e41f378f825488a537b024fc3ed599d9c12fda96/library%2Fcore%2Fsrc%2Farray%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e41f378f825488a537b024fc3ed599d9c12fda96/library%2Fcore%2Fsrc%2Farray%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Farray%2Fmod.rs?ref=e41f378f825488a537b024fc3ed599d9c12fda96", "patch": "@@ -12,7 +12,6 @@ use crate::convert::{Infallible, TryFrom};\n use crate::fmt;\n use crate::hash::{self, Hash};\n use crate::iter::TrustedLen;\n-use crate::marker::Unsize;\n use crate::mem::{self, MaybeUninit};\n use crate::ops::{Index, IndexMut};\n use crate::slice::{Iter, IterMut};\n@@ -36,41 +35,6 @@ pub fn from_mut<T>(s: &mut T) -> &mut [T; 1] {\n     unsafe { &mut *(s as *mut T).cast::<[T; 1]>() }\n }\n \n-/// Utility trait implemented only on arrays of fixed size\n-///\n-/// This trait can be used to implement other traits on fixed-size arrays\n-/// without causing much metadata bloat.\n-///\n-/// The trait is marked unsafe in order to restrict implementors to fixed-size\n-/// arrays. A user of this trait can assume that implementors have the exact\n-/// layout in memory of a fixed size array (for example, for unsafe\n-/// initialization).\n-///\n-/// Note that the traits [`AsRef`] and [`AsMut`] provide similar methods for types that\n-/// may not be fixed-size arrays. Implementors should prefer those traits\n-/// instead.\n-#[unstable(feature = \"fixed_size_array\", issue = \"27778\")]\n-pub unsafe trait FixedSizeArray<T> {\n-    /// Converts the array to immutable slice\n-    #[unstable(feature = \"fixed_size_array\", issue = \"27778\")]\n-    fn as_slice(&self) -> &[T];\n-    /// Converts the array to mutable slice\n-    #[unstable(feature = \"fixed_size_array\", issue = \"27778\")]\n-    fn as_mut_slice(&mut self) -> &mut [T];\n-}\n-\n-#[unstable(feature = \"fixed_size_array\", issue = \"27778\")]\n-unsafe impl<T, A: Unsize<[T]>> FixedSizeArray<T> for A {\n-    #[inline]\n-    fn as_slice(&self) -> &[T] {\n-        self\n-    }\n-    #[inline]\n-    fn as_mut_slice(&mut self) -> &mut [T] {\n-        self\n-    }\n-}\n-\n /// The error type returned when a conversion from a slice to an array fails.\n #[stable(feature = \"try_from\", since = \"1.34.0\")]\n #[derive(Debug, Copy, Clone)]"}, {"sha": "ce7480ce2ee892317e744af6794574a1e21ebc54", "filename": "library/core/tests/array.rs", "status": "modified", "additions": 1, "deletions": 19, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e41f378f825488a537b024fc3ed599d9c12fda96/library%2Fcore%2Ftests%2Farray.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e41f378f825488a537b024fc3ed599d9c12fda96/library%2Fcore%2Ftests%2Farray.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Farray.rs?ref=e41f378f825488a537b024fc3ed599d9c12fda96", "patch": "@@ -1,24 +1,6 @@\n-use core::array::{self, FixedSizeArray, IntoIter};\n+use core::array::{self, IntoIter};\n use core::convert::TryFrom;\n \n-#[test]\n-fn fixed_size_array() {\n-    let mut array = [0; 64];\n-    let mut zero_sized = [(); 64];\n-    let mut empty_array = [0; 0];\n-    let mut empty_zero_sized = [(); 0];\n-\n-    assert_eq!(FixedSizeArray::as_slice(&array).len(), 64);\n-    assert_eq!(FixedSizeArray::as_slice(&zero_sized).len(), 64);\n-    assert_eq!(FixedSizeArray::as_slice(&empty_array).len(), 0);\n-    assert_eq!(FixedSizeArray::as_slice(&empty_zero_sized).len(), 0);\n-\n-    assert_eq!(FixedSizeArray::as_mut_slice(&mut array).len(), 64);\n-    assert_eq!(FixedSizeArray::as_mut_slice(&mut zero_sized).len(), 64);\n-    assert_eq!(FixedSizeArray::as_mut_slice(&mut empty_array).len(), 0);\n-    assert_eq!(FixedSizeArray::as_mut_slice(&mut empty_zero_sized).len(), 0);\n-}\n-\n #[test]\n fn array_from_ref() {\n     let value: String = \"Hello World!\".into();"}, {"sha": "6624fd473539a98fec245735e5bdab4646088d7d", "filename": "library/core/tests/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e41f378f825488a537b024fc3ed599d9c12fda96/library%2Fcore%2Ftests%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e41f378f825488a537b024fc3ed599d9c12fda96/library%2Fcore%2Ftests%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Ftests%2Flib.rs?ref=e41f378f825488a537b024fc3ed599d9c12fda96", "patch": "@@ -28,7 +28,6 @@\n #![feature(duration_zero)]\n #![feature(exact_size_is_empty)]\n #![feature(extern_types)]\n-#![feature(fixed_size_array)]\n #![feature(flt2dec)]\n #![feature(fmt_internals)]\n #![feature(hashmap_internals)]"}, {"sha": "84a642289212c2a37c5dbf871557c61ed979679f", "filename": "library/std/Cargo.toml", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e41f378f825488a537b024fc3ed599d9c12fda96/library%2Fstd%2FCargo.toml", "raw_url": "https://github.com/rust-lang/rust/raw/e41f378f825488a537b024fc3ed599d9c12fda96/library%2Fstd%2FCargo.toml", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2FCargo.toml?ref=e41f378f825488a537b024fc3ed599d9c12fda96", "patch": "@@ -16,7 +16,7 @@ cfg-if = { version = \"0.1.8\", features = ['rustc-dep-of-std'] }\n panic_unwind = { path = \"../panic_unwind\", optional = true }\n panic_abort = { path = \"../panic_abort\" }\n core = { path = \"../core\" }\n-libc = { version = \"0.2.88\", default-features = false, features = ['rustc-dep-of-std'] }\n+libc = { version = \"0.2.93\", default-features = false, features = ['rustc-dep-of-std'] }\n compiler_builtins = { version = \"0.1.39\" }\n profiler_builtins = { path = \"../profiler_builtins\", optional = true }\n unwind = { path = \"../unwind\" }"}, {"sha": "e6120b8ee31c2dc36e13fa2c701d9e2def2133bb", "filename": "library/std/src/fs.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/e41f378f825488a537b024fc3ed599d9c12fda96/library%2Fstd%2Fsrc%2Ffs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e41f378f825488a537b024fc3ed599d9c12fda96/library%2Fstd%2Fsrc%2Ffs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Ffs.rs?ref=e41f378f825488a537b024fc3ed599d9c12fda96", "patch": "@@ -265,8 +265,9 @@ pub fn read<P: AsRef<Path>>(path: P) -> io::Result<Vec<u8>> {\n /// ```no_run\n /// use std::fs;\n /// use std::net::SocketAddr;\n+/// use std::error::Error;\n ///\n-/// fn main() -> Result<(), Box<dyn std::error::Error + 'static>> {\n+/// fn main() -> Result<(), Box<dyn Error>> {\n ///     let foo: SocketAddr = fs::read_to_string(\"address.txt\")?.parse()?;\n ///     Ok(())\n /// }"}, {"sha": "91695ced6a962899e9bdd2ec3e88a58201b5e1e5", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e41f378f825488a537b024fc3ed599d9c12fda96/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e41f378f825488a537b024fc3ed599d9c12fda96/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=e41f378f825488a537b024fc3ed599d9c12fda96", "patch": "@@ -214,7 +214,6 @@\n     feature(slice_index_methods, coerce_unsized, sgx_platform)\n )]\n #![deny(rustc::existing_doc_keyword)]\n-#![cfg_attr(all(test, target_vendor = \"fortanix\", target_env = \"sgx\"), feature(fixed_size_array))]\n // std is implemented with unstable features, many of which are internal\n // compiler details that will never be stable\n // NB: the following list is sorted to minimize merge conflicts."}, {"sha": "be7bff1a29c2b4d51e45cbc9afc3b4007e8c8f36", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 3, "deletions": 51, "changes": 54, "blob_url": "https://github.com/rust-lang/rust/blob/e41f378f825488a537b024fc3ed599d9c12fda96/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e41f378f825488a537b024fc3ed599d9c12fda96/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=e41f378f825488a537b024fc3ed599d9c12fda96", "patch": "@@ -5,8 +5,8 @@ use rustc_driver::abort_on_err;\n use rustc_errors::emitter::{Emitter, EmitterWriter};\n use rustc_errors::json::JsonEmitter;\n use rustc_feature::UnstableFeatures;\n-use rustc_hir::def::{Namespace::TypeNS, Res};\n-use rustc_hir::def_id::{CrateNum, DefId, DefIndex, LocalDefId, CRATE_DEF_INDEX, LOCAL_CRATE};\n+use rustc_hir::def::Res;\n+use rustc_hir::def_id::{CrateNum, DefId, DefIndex, LocalDefId, LOCAL_CRATE};\n use rustc_hir::HirId;\n use rustc_hir::{\n     intravisit::{self, NestedVisitorMap, Visitor},\n@@ -356,55 +356,7 @@ crate fn create_resolver<'a>(\n     let (krate, resolver, _) = &*parts;\n     let resolver = resolver.borrow().clone();\n \n-    // Letting the resolver escape at the end of the function leads to inconsistencies between the\n-    // crates the TyCtxt sees and the resolver sees (because the resolver could load more crates\n-    // after escaping). Hopefully `IntraLinkCrateLoader` gets all the crates we need ...\n-    struct IntraLinkCrateLoader {\n-        current_mod: DefId,\n-        resolver: Rc<RefCell<interface::BoxedResolver>>,\n-    }\n-    impl ast::visit::Visitor<'_> for IntraLinkCrateLoader {\n-        fn visit_attribute(&mut self, attr: &ast::Attribute) {\n-            use crate::html::markdown::{markdown_links, MarkdownLink};\n-            use crate::passes::collect_intra_doc_links::Disambiguator;\n-\n-            if let Some(doc) = attr.doc_str() {\n-                for MarkdownLink { link, .. } in markdown_links(&doc.as_str()) {\n-                    // FIXME: this misses a *lot* of the preprocessing done in collect_intra_doc_links\n-                    // I think most of it shouldn't be necessary since we only need the crate prefix?\n-                    let path_str = match Disambiguator::from_str(&link) {\n-                        Ok(x) => x.map_or(link.as_str(), |(_, p)| p),\n-                        Err(_) => continue,\n-                    };\n-                    self.resolver.borrow_mut().access(|resolver| {\n-                        let _ = resolver.resolve_str_path_error(\n-                            attr.span,\n-                            path_str,\n-                            TypeNS,\n-                            self.current_mod,\n-                        );\n-                    });\n-                }\n-            }\n-            ast::visit::walk_attribute(self, attr);\n-        }\n-\n-        fn visit_item(&mut self, item: &ast::Item) {\n-            use rustc_ast_lowering::ResolverAstLowering;\n-\n-            if let ast::ItemKind::Mod(..) = item.kind {\n-                let new_mod =\n-                    self.resolver.borrow_mut().access(|resolver| resolver.local_def_id(item.id));\n-                let old_mod = mem::replace(&mut self.current_mod, new_mod.to_def_id());\n-                ast::visit::walk_item(self, item);\n-                self.current_mod = old_mod;\n-            } else {\n-                ast::visit::walk_item(self, item);\n-            }\n-        }\n-    }\n-    let crate_id = LocalDefId { local_def_index: CRATE_DEF_INDEX }.to_def_id();\n-    let mut loader = IntraLinkCrateLoader { current_mod: crate_id, resolver };\n+    let mut loader = crate::passes::collect_intra_doc_links::IntraLinkCrateLoader::new(resolver);\n     ast::visit::walk_crate(&mut loader, krate);\n \n     loader.resolver"}, {"sha": "6342110adfe0bf0ca77fd07647f5f5b0e7e7e6cd", "filename": "src/librustdoc/passes/collect_intra_doc_links.rs", "status": "modified", "additions": 140, "deletions": 81, "changes": 221, "blob_url": "https://github.com/rust-lang/rust/blob/e41f378f825488a537b024fc3ed599d9c12fda96/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e41f378f825488a537b024fc3ed599d9c12fda96/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links.rs?ref=e41f378f825488a537b024fc3ed599d9c12fda96", "patch": "@@ -39,13 +39,16 @@ use crate::passes::Pass;\n \n use super::span_of_attrs;\n \n+mod early;\n+crate use early::IntraLinkCrateLoader;\n+\n crate const COLLECT_INTRA_DOC_LINKS: Pass = Pass {\n     name: \"collect-intra-doc-links\",\n     run: collect_intra_doc_links,\n     description: \"resolves intra-doc links\",\n };\n \n-crate fn collect_intra_doc_links(krate: Crate, cx: &mut DocContext<'_>) -> Crate {\n+fn collect_intra_doc_links(krate: Crate, cx: &mut DocContext<'_>) -> Crate {\n     LinkCollector {\n         cx,\n         mod_ids: Vec::new(),\n@@ -892,6 +895,117 @@ impl<'a, 'tcx> DocFolder for LinkCollector<'a, 'tcx> {\n     }\n }\n \n+enum PreprocessingError<'a> {\n+    Anchor(AnchorFailure),\n+    Disambiguator(Range<usize>, String),\n+    Resolution(ResolutionFailure<'a>, String, Option<Disambiguator>),\n+}\n+\n+impl From<AnchorFailure> for PreprocessingError<'_> {\n+    fn from(err: AnchorFailure) -> Self {\n+        Self::Anchor(err)\n+    }\n+}\n+\n+struct PreprocessingInfo {\n+    path_str: String,\n+    disambiguator: Option<Disambiguator>,\n+    extra_fragment: Option<String>,\n+    link_text: String,\n+}\n+\n+/// Returns:\n+/// - `None` if the link should be ignored.\n+/// - `Some(Err)` if the link should emit an error\n+/// - `Some(Ok)` if the link is valid\n+///\n+/// `link_buffer` is needed for lifetime reasons; it will always be overwritten and the contents ignored.\n+fn preprocess_link<'a>(\n+    ori_link: &'a MarkdownLink,\n+) -> Option<Result<PreprocessingInfo, PreprocessingError<'a>>> {\n+    // [] is mostly likely not supposed to be a link\n+    if ori_link.link.is_empty() {\n+        return None;\n+    }\n+\n+    // Bail early for real links.\n+    if ori_link.link.contains('/') {\n+        return None;\n+    }\n+\n+    let stripped = ori_link.link.replace(\"`\", \"\");\n+    let mut parts = stripped.split('#');\n+\n+    let link = parts.next().unwrap();\n+    if link.trim().is_empty() {\n+        // This is an anchor to an element of the current page, nothing to do in here!\n+        return None;\n+    }\n+    let extra_fragment = parts.next();\n+    if parts.next().is_some() {\n+        // A valid link can't have multiple #'s\n+        return Some(Err(AnchorFailure::MultipleAnchors.into()));\n+    }\n+\n+    // Parse and strip the disambiguator from the link, if present.\n+    let (path_str, disambiguator) = match Disambiguator::from_str(&link) {\n+        Ok(Some((d, path))) => (path.trim(), Some(d)),\n+        Ok(None) => (link.trim(), None),\n+        Err((err_msg, relative_range)) => {\n+            // Only report error if we would not have ignored this link. See issue #83859.\n+            if !should_ignore_link_with_disambiguators(link) {\n+                let no_backticks_range = range_between_backticks(&ori_link);\n+                let disambiguator_range = (no_backticks_range.start + relative_range.start)\n+                    ..(no_backticks_range.start + relative_range.end);\n+                return Some(Err(PreprocessingError::Disambiguator(disambiguator_range, err_msg)));\n+            } else {\n+                return None;\n+            }\n+        }\n+    };\n+\n+    if should_ignore_link(path_str) {\n+        return None;\n+    }\n+\n+    // We stripped `()` and `!` when parsing the disambiguator.\n+    // Add them back to be displayed, but not prefix disambiguators.\n+    let link_text =\n+        disambiguator.map(|d| d.display_for(path_str)).unwrap_or_else(|| path_str.to_owned());\n+\n+    // Strip generics from the path.\n+    let path_str = if path_str.contains(['<', '>'].as_slice()) {\n+        match strip_generics_from_path(&path_str) {\n+            Ok(path) => path,\n+            Err(err_kind) => {\n+                debug!(\"link has malformed generics: {}\", path_str);\n+                return Some(Err(PreprocessingError::Resolution(\n+                    err_kind,\n+                    path_str.to_owned(),\n+                    disambiguator,\n+                )));\n+            }\n+        }\n+    } else {\n+        path_str.to_owned()\n+    };\n+\n+    // Sanity check to make sure we don't have any angle brackets after stripping generics.\n+    assert!(!path_str.contains(['<', '>'].as_slice()));\n+\n+    // The link is not an intra-doc link if it still contains spaces after stripping generics.\n+    if path_str.contains(' ') {\n+        return None;\n+    }\n+\n+    Some(Ok(PreprocessingInfo {\n+        path_str,\n+        disambiguator,\n+        extra_fragment: extra_fragment.map(String::from),\n+        link_text,\n+    }))\n+}\n+\n impl LinkCollector<'_, '_> {\n     /// This is the entry point for resolving an intra-doc link.\n     ///\n@@ -907,64 +1021,36 @@ impl LinkCollector<'_, '_> {\n     ) -> Option<ItemLink> {\n         trace!(\"considering link '{}'\", ori_link.link);\n \n-        // Bail early for real links.\n-        if ori_link.link.contains('/') {\n-            return None;\n-        }\n-\n-        // [] is mostly likely not supposed to be a link\n-        if ori_link.link.is_empty() {\n-            return None;\n-        }\n-\n         let diag_info = DiagnosticInfo {\n             item,\n             dox,\n             ori_link: &ori_link.link,\n             link_range: ori_link.range.clone(),\n         };\n \n-        let link = ori_link.link.replace(\"`\", \"\");\n-        let no_backticks_range = range_between_backticks(&ori_link);\n-        let parts = link.split('#').collect::<Vec<_>>();\n-        let (link, extra_fragment) = if parts.len() > 2 {\n-            // A valid link can't have multiple #'s\n-            anchor_failure(self.cx, diag_info, AnchorFailure::MultipleAnchors);\n-            return None;\n-        } else if parts.len() == 2 {\n-            if parts[0].trim().is_empty() {\n-                // This is an anchor to an element of the current page, nothing to do in here!\n-                return None;\n-            }\n-            (parts[0], Some(parts[1].to_owned()))\n-        } else {\n-            (parts[0], None)\n-        };\n-\n-        // Parse and strip the disambiguator from the link, if present.\n-        let (mut path_str, disambiguator) = match Disambiguator::from_str(&link) {\n-            Ok(Some((d, path))) => (path.trim(), Some(d)),\n-            Ok(None) => (link.trim(), None),\n-            Err((err_msg, relative_range)) => {\n-                if !should_ignore_link_with_disambiguators(link) {\n-                    // Only report error if we would not have ignored this link.\n-                    // See issue #83859.\n-                    let disambiguator_range = (no_backticks_range.start + relative_range.start)\n-                        ..(no_backticks_range.start + relative_range.end);\n-                    disambiguator_error(self.cx, diag_info, disambiguator_range, &err_msg);\n+        let PreprocessingInfo { path_str, disambiguator, extra_fragment, link_text } =\n+            match preprocess_link(&ori_link)? {\n+                Ok(x) => x,\n+                Err(err) => {\n+                    match err {\n+                        PreprocessingError::Anchor(err) => anchor_failure(self.cx, diag_info, err),\n+                        PreprocessingError::Disambiguator(range, msg) => {\n+                            disambiguator_error(self.cx, diag_info, range, &msg)\n+                        }\n+                        PreprocessingError::Resolution(err, path_str, disambiguator) => {\n+                            resolution_failure(\n+                                self,\n+                                diag_info,\n+                                &path_str,\n+                                disambiguator,\n+                                smallvec![err],\n+                            );\n+                        }\n+                    }\n+                    return None;\n                 }\n-                return None;\n-            }\n-        };\n-\n-        if should_ignore_link(path_str) {\n-            return None;\n-        }\n-\n-        // We stripped `()` and `!` when parsing the disambiguator.\n-        // Add them back to be displayed, but not prefix disambiguators.\n-        let link_text =\n-            disambiguator.map(|d| d.display_for(path_str)).unwrap_or_else(|| path_str.to_owned());\n+            };\n+        let mut path_str = &*path_str;\n \n         // In order to correctly resolve intra-doc links we need to\n         // pick a base AST node to work from.  If the documentation for\n@@ -1029,39 +1115,12 @@ impl LinkCollector<'_, '_> {\n             module_id = DefId { krate, index: CRATE_DEF_INDEX };\n         }\n \n-        // Strip generics from the path.\n-        let stripped_path_string;\n-        if path_str.contains(['<', '>'].as_slice()) {\n-            stripped_path_string = match strip_generics_from_path(path_str) {\n-                Ok(path) => path,\n-                Err(err_kind) => {\n-                    debug!(\"link has malformed generics: {}\", path_str);\n-                    resolution_failure(\n-                        self,\n-                        diag_info,\n-                        path_str,\n-                        disambiguator,\n-                        smallvec![err_kind],\n-                    );\n-                    return None;\n-                }\n-            };\n-            path_str = &stripped_path_string;\n-        }\n-        // Sanity check to make sure we don't have any angle brackets after stripping generics.\n-        assert!(!path_str.contains(['<', '>'].as_slice()));\n-\n-        // The link is not an intra-doc link if it still contains spaces after stripping generics.\n-        if path_str.contains(' ') {\n-            return None;\n-        }\n-\n         let (mut res, mut fragment) = self.resolve_with_disambiguator_cached(\n             ResolutionInfo {\n                 module_id,\n                 dis: disambiguator,\n                 path_str: path_str.to_owned(),\n-                extra_fragment,\n+                extra_fragment: extra_fragment.map(String::from),\n             },\n             diag_info.clone(), // this struct should really be Copy, but Range is not :(\n             matches!(ori_link.kind, LinkType::Reference | LinkType::Shortcut),\n@@ -1438,7 +1497,7 @@ fn should_ignore_link(path_str: &str) -> bool {\n \n #[derive(Copy, Clone, Debug, PartialEq, Eq, Hash)]\n /// Disambiguators for a link.\n-crate enum Disambiguator {\n+enum Disambiguator {\n     /// `prim@`\n     ///\n     /// This is buggy, see <https://github.com/rust-lang/rust/pull/77875#discussion_r503583103>\n@@ -1467,7 +1526,7 @@ impl Disambiguator {\n     /// This returns `Ok(Some(...))` if a disambiguator was found,\n     /// `Ok(None)` if no disambiguator was found, or `Err(...)`\n     /// if there was a problem with the disambiguator.\n-    crate fn from_str(link: &str) -> Result<Option<(Self, &str)>, (String, Range<usize>)> {\n+    fn from_str(link: &str) -> Result<Option<(Self, &str)>, (String, Range<usize>)> {\n         use Disambiguator::{Kind, Namespace as NS, Primitive};\n \n         if let Some(idx) = link.find('@') {"}, {"sha": "7cba2523d1a3b938e45b20671e9976e9ac976ec4", "filename": "src/librustdoc/passes/collect_intra_doc_links/early.rs", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/e41f378f825488a537b024fc3ed599d9c12fda96/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links%2Fearly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e41f378f825488a537b024fc3ed599d9c12fda96/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links%2Fearly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses%2Fcollect_intra_doc_links%2Fearly.rs?ref=e41f378f825488a537b024fc3ed599d9c12fda96", "patch": "@@ -0,0 +1,63 @@\n+use rustc_ast as ast;\n+use rustc_hir::def::Namespace::TypeNS;\n+use rustc_hir::def_id::{DefId, LocalDefId, CRATE_DEF_INDEX};\n+use rustc_interface::interface;\n+\n+use std::cell::RefCell;\n+use std::mem;\n+use std::rc::Rc;\n+\n+// Letting the resolver escape at the end of the function leads to inconsistencies between the\n+// crates the TyCtxt sees and the resolver sees (because the resolver could load more crates\n+// after escaping). Hopefully `IntraLinkCrateLoader` gets all the crates we need ...\n+crate struct IntraLinkCrateLoader {\n+    current_mod: DefId,\n+    crate resolver: Rc<RefCell<interface::BoxedResolver>>,\n+}\n+\n+impl IntraLinkCrateLoader {\n+    crate fn new(resolver: Rc<RefCell<interface::BoxedResolver>>) -> Self {\n+        let crate_id = LocalDefId { local_def_index: CRATE_DEF_INDEX }.to_def_id();\n+        Self { current_mod: crate_id, resolver }\n+    }\n+}\n+\n+impl ast::visit::Visitor<'_> for IntraLinkCrateLoader {\n+    fn visit_attribute(&mut self, attr: &ast::Attribute) {\n+        use crate::html::markdown::markdown_links;\n+        use crate::passes::collect_intra_doc_links::preprocess_link;\n+\n+        if let Some(doc) = attr.doc_str() {\n+            for link in markdown_links(&doc.as_str()) {\n+                let path_str = if let Some(Ok(x)) = preprocess_link(&link) {\n+                    x.path_str\n+                } else {\n+                    continue;\n+                };\n+                self.resolver.borrow_mut().access(|resolver| {\n+                    let _ = resolver.resolve_str_path_error(\n+                        attr.span,\n+                        &path_str,\n+                        TypeNS,\n+                        self.current_mod,\n+                    );\n+                });\n+            }\n+        }\n+        ast::visit::walk_attribute(self, attr);\n+    }\n+\n+    fn visit_item(&mut self, item: &ast::Item) {\n+        use rustc_ast_lowering::ResolverAstLowering;\n+\n+        if let ast::ItemKind::Mod(..) = item.kind {\n+            let new_mod =\n+                self.resolver.borrow_mut().access(|resolver| resolver.local_def_id(item.id));\n+            let old_mod = mem::replace(&mut self.current_mod, new_mod.to_def_id());\n+            ast::visit::walk_item(self, item);\n+            self.current_mod = old_mod;\n+        } else {\n+            ast::visit::walk_item(self, item);\n+        }\n+    }\n+}"}, {"sha": "23aa5c44c21fd7146ccf4b91999f249f17e3714b", "filename": "src/test/rustdoc-ui/bare-urls.fixed", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/e41f378f825488a537b024fc3ed599d9c12fda96/src%2Ftest%2Frustdoc-ui%2Fbare-urls.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/e41f378f825488a537b024fc3ed599d9c12fda96/src%2Ftest%2Frustdoc-ui%2Fbare-urls.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fbare-urls.fixed?ref=e41f378f825488a537b024fc3ed599d9c12fda96", "patch": "@@ -0,0 +1,60 @@\n+// run-rustfix\n+\n+#![deny(rustdoc::bare_urls)]\n+\n+/// <https://somewhere.com>\n+//~^ ERROR this URL is not a hyperlink\n+/// <https://somewhere.com/a>\n+//~^ ERROR this URL is not a hyperlink\n+/// <https://www.somewhere.com>\n+//~^ ERROR this URL is not a hyperlink\n+/// <https://www.somewhere.com/a>\n+//~^ ERROR this URL is not a hyperlink\n+/// <https://subdomain.example.com>\n+//~^ ERROR not a hyperlink\n+/// <https://somewhere.com?>\n+//~^ ERROR this URL is not a hyperlink\n+/// <https://somewhere.com/a?>\n+//~^ ERROR this URL is not a hyperlink\n+/// <https://somewhere.com?hello=12>\n+//~^ ERROR this URL is not a hyperlink\n+/// <https://somewhere.com/a?hello=12>\n+//~^ ERROR this URL is not a hyperlink\n+/// <https://example.com?hello=12#xyz>\n+//~^ ERROR this URL is not a hyperlink\n+/// <https://example.com/a?hello=12#xyz>\n+//~^ ERROR this URL is not a hyperlink\n+/// <https://example.com#xyz>\n+//~^ ERROR this URL is not a hyperlink\n+/// <https://example.com/a#xyz>\n+//~^ ERROR this URL is not a hyperlink\n+/// <https://somewhere.com?hello=12&bye=11>\n+//~^ ERROR this URL is not a hyperlink\n+/// <https://somewhere.com/a?hello=12&bye=11>\n+//~^ ERROR this URL is not a hyperlink\n+/// <https://somewhere.com?hello=12&bye=11#xyz>\n+//~^ ERROR this URL is not a hyperlink\n+/// hey! <https://somewhere.com/a?hello=12&bye=11#xyz>\n+//~^ ERROR this URL is not a hyperlink\n+pub fn c() {}\n+\n+/// <https://somewhere.com>\n+/// [a](http://a.com)\n+/// [b]\n+///\n+/// [b]: http://b.com\n+///\n+/// ```\n+/// This link should not be linted: http://example.com\n+///\n+/// Nor this one: <http://example.com> or this one: [x](http://example.com)\n+/// ```\n+///\n+/// [should_not.lint](should_not.lint)\n+pub fn everything_is_fine_here() {}\n+\n+#[allow(rustdoc::bare_urls)]\n+pub mod foo {\n+    /// https://somewhere.com/a?hello=12&bye=11#xyz\n+    pub fn bar() {}\n+}"}, {"sha": "592f57343bc922aeb68da11ed637b54ea13392b8", "filename": "src/test/rustdoc-ui/bare-urls.rs", "status": "renamed", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e41f378f825488a537b024fc3ed599d9c12fda96/src%2Ftest%2Frustdoc-ui%2Fbare-urls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e41f378f825488a537b024fc3ed599d9c12fda96/src%2Ftest%2Frustdoc-ui%2Fbare-urls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fbare-urls.rs?ref=e41f378f825488a537b024fc3ed599d9c12fda96", "patch": "@@ -1,3 +1,5 @@\n+// run-rustfix\n+\n #![deny(rustdoc::bare_urls)]\n \n /// https://somewhere.com", "previous_filename": "src/test/rustdoc-ui/url-improvements.rs"}, {"sha": "6b612f81590dc73b62eb7ad11a783c0eb3bba4f7", "filename": "src/test/rustdoc-ui/bare-urls.stderr", "status": "renamed", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/e41f378f825488a537b024fc3ed599d9c12fda96/src%2Ftest%2Frustdoc-ui%2Fbare-urls.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e41f378f825488a537b024fc3ed599d9c12fda96/src%2Ftest%2Frustdoc-ui%2Fbare-urls.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc-ui%2Fbare-urls.stderr?ref=e41f378f825488a537b024fc3ed599d9c12fda96", "patch": "@@ -1,107 +1,107 @@\n error: this URL is not a hyperlink\n-  --> $DIR/url-improvements.rs:3:5\n+  --> $DIR/bare-urls.rs:5:5\n    |\n LL | /// https://somewhere.com\n    |     ^^^^^^^^^^^^^^^^^^^^^ help: use an automatic link instead: `<https://somewhere.com>`\n    |\n note: the lint level is defined here\n-  --> $DIR/url-improvements.rs:1:9\n+  --> $DIR/bare-urls.rs:3:9\n    |\n LL | #![deny(rustdoc::bare_urls)]\n    |         ^^^^^^^^^^^^^^^^^^\n \n error: this URL is not a hyperlink\n-  --> $DIR/url-improvements.rs:5:5\n+  --> $DIR/bare-urls.rs:7:5\n    |\n LL | /// https://somewhere.com/a\n    |     ^^^^^^^^^^^^^^^^^^^^^^^ help: use an automatic link instead: `<https://somewhere.com/a>`\n \n error: this URL is not a hyperlink\n-  --> $DIR/url-improvements.rs:7:5\n+  --> $DIR/bare-urls.rs:9:5\n    |\n LL | /// https://www.somewhere.com\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^ help: use an automatic link instead: `<https://www.somewhere.com>`\n \n error: this URL is not a hyperlink\n-  --> $DIR/url-improvements.rs:9:5\n+  --> $DIR/bare-urls.rs:11:5\n    |\n LL | /// https://www.somewhere.com/a\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use an automatic link instead: `<https://www.somewhere.com/a>`\n \n error: this URL is not a hyperlink\n-  --> $DIR/url-improvements.rs:11:5\n+  --> $DIR/bare-urls.rs:13:5\n    |\n LL | /// https://subdomain.example.com\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use an automatic link instead: `<https://subdomain.example.com>`\n \n error: this URL is not a hyperlink\n-  --> $DIR/url-improvements.rs:13:5\n+  --> $DIR/bare-urls.rs:15:5\n    |\n LL | /// https://somewhere.com?\n    |     ^^^^^^^^^^^^^^^^^^^^^^ help: use an automatic link instead: `<https://somewhere.com?>`\n \n error: this URL is not a hyperlink\n-  --> $DIR/url-improvements.rs:15:5\n+  --> $DIR/bare-urls.rs:17:5\n    |\n LL | /// https://somewhere.com/a?\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^ help: use an automatic link instead: `<https://somewhere.com/a?>`\n \n error: this URL is not a hyperlink\n-  --> $DIR/url-improvements.rs:17:5\n+  --> $DIR/bare-urls.rs:19:5\n    |\n LL | /// https://somewhere.com?hello=12\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use an automatic link instead: `<https://somewhere.com?hello=12>`\n \n error: this URL is not a hyperlink\n-  --> $DIR/url-improvements.rs:19:5\n+  --> $DIR/bare-urls.rs:21:5\n    |\n LL | /// https://somewhere.com/a?hello=12\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use an automatic link instead: `<https://somewhere.com/a?hello=12>`\n \n error: this URL is not a hyperlink\n-  --> $DIR/url-improvements.rs:21:5\n+  --> $DIR/bare-urls.rs:23:5\n    |\n LL | /// https://example.com?hello=12#xyz\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use an automatic link instead: `<https://example.com?hello=12#xyz>`\n \n error: this URL is not a hyperlink\n-  --> $DIR/url-improvements.rs:23:5\n+  --> $DIR/bare-urls.rs:25:5\n    |\n LL | /// https://example.com/a?hello=12#xyz\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use an automatic link instead: `<https://example.com/a?hello=12#xyz>`\n \n error: this URL is not a hyperlink\n-  --> $DIR/url-improvements.rs:25:5\n+  --> $DIR/bare-urls.rs:27:5\n    |\n LL | /// https://example.com#xyz\n    |     ^^^^^^^^^^^^^^^^^^^^^^^ help: use an automatic link instead: `<https://example.com#xyz>`\n \n error: this URL is not a hyperlink\n-  --> $DIR/url-improvements.rs:27:5\n+  --> $DIR/bare-urls.rs:29:5\n    |\n LL | /// https://example.com/a#xyz\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^ help: use an automatic link instead: `<https://example.com/a#xyz>`\n \n error: this URL is not a hyperlink\n-  --> $DIR/url-improvements.rs:29:5\n+  --> $DIR/bare-urls.rs:31:5\n    |\n LL | /// https://somewhere.com?hello=12&bye=11\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use an automatic link instead: `<https://somewhere.com?hello=12&bye=11>`\n \n error: this URL is not a hyperlink\n-  --> $DIR/url-improvements.rs:31:5\n+  --> $DIR/bare-urls.rs:33:5\n    |\n LL | /// https://somewhere.com/a?hello=12&bye=11\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use an automatic link instead: `<https://somewhere.com/a?hello=12&bye=11>`\n \n error: this URL is not a hyperlink\n-  --> $DIR/url-improvements.rs:33:5\n+  --> $DIR/bare-urls.rs:35:5\n    |\n LL | /// https://somewhere.com?hello=12&bye=11#xyz\n    |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use an automatic link instead: `<https://somewhere.com?hello=12&bye=11#xyz>`\n \n error: this URL is not a hyperlink\n-  --> $DIR/url-improvements.rs:35:10\n+  --> $DIR/bare-urls.rs:37:10\n    |\n LL | /// hey! https://somewhere.com/a?hello=12&bye=11#xyz\n    |          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ help: use an automatic link instead: `<https://somewhere.com/a?hello=12&bye=11#xyz>`", "previous_filename": "src/test/rustdoc-ui/url-improvements.stderr"}, {"sha": "d11c69f812a8dfe9ea3db2474363c188c096c5b3", "filename": "src/test/rustdoc/intra-doc/auxiliary/empty.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e41f378f825488a537b024fc3ed599d9c12fda96/src%2Ftest%2Frustdoc%2Fintra-doc%2Fauxiliary%2Fempty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e41f378f825488a537b024fc3ed599d9c12fda96/src%2Ftest%2Frustdoc%2Fintra-doc%2Fauxiliary%2Fempty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc%2Fauxiliary%2Fempty.rs?ref=e41f378f825488a537b024fc3ed599d9c12fda96", "patch": "@@ -0,0 +1 @@\n+// intentionally empty"}, {"sha": "d11c69f812a8dfe9ea3db2474363c188c096c5b3", "filename": "src/test/rustdoc/intra-doc/auxiliary/empty2.rs", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/e41f378f825488a537b024fc3ed599d9c12fda96/src%2Ftest%2Frustdoc%2Fintra-doc%2Fauxiliary%2Fempty2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e41f378f825488a537b024fc3ed599d9c12fda96/src%2Ftest%2Frustdoc%2Fintra-doc%2Fauxiliary%2Fempty2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc%2Fauxiliary%2Fempty2.rs?ref=e41f378f825488a537b024fc3ed599d9c12fda96", "patch": "@@ -0,0 +1 @@\n+// intentionally empty"}, {"sha": "5d8dcf8bc1d1682357b5cb982c07713c82f6c3f5", "filename": "src/test/rustdoc/intra-doc/extern-crate-only-used-in-link.rs", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/e41f378f825488a537b024fc3ed599d9c12fda96/src%2Ftest%2Frustdoc%2Fintra-doc%2Fextern-crate-only-used-in-link.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e41f378f825488a537b024fc3ed599d9c12fda96/src%2Ftest%2Frustdoc%2Fintra-doc%2Fextern-crate-only-used-in-link.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fintra-doc%2Fextern-crate-only-used-in-link.rs?ref=e41f378f825488a537b024fc3ed599d9c12fda96", "patch": "@@ -1,8 +1,19 @@\n+// This test is just a little cursed.\n // aux-build:issue-66159-1.rs\n // aux-crate:priv:issue_66159_1=issue-66159-1.rs\n+// aux-build:empty.rs\n+// aux-crate:priv:empty=empty.rs\n+// aux-build:empty2.rs\n+// aux-crate:priv:empty2=empty2.rs\n // build-aux-docs\n-// compile-flags:-Z unstable-options\n+// compile-flags:-Z unstable-options --edition 2018\n \n // @has extern_crate_only_used_in_link/index.html\n // @has - '//a[@href=\"../issue_66159_1/struct.Something.html\"]' 'issue_66159_1::Something'\n //! [issue_66159_1::Something]\n+\n+// @has - '//a[@href=\"../empty/index.html\"]' 'empty'\n+//! [`empty`]\n+\n+// @has - '//a[@href=\"../empty2/index.html\"]' 'empty2'\n+//! [empty2<x>]"}, {"sha": "3c7dc1fc3c9b23f88e97439f934418204b48713c", "filename": "src/test/ui/associated-types/defaults-specialization.stderr", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/e41f378f825488a537b024fc3ed599d9c12fda96/src%2Ftest%2Fui%2Fassociated-types%2Fdefaults-specialization.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e41f378f825488a537b024fc3ed599d9c12fda96/src%2Ftest%2Fui%2Fassociated-types%2Fdefaults-specialization.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fassociated-types%2Fdefaults-specialization.stderr?ref=e41f378f825488a537b024fc3ed599d9c12fda96", "patch": "@@ -15,7 +15,10 @@ LL |     fn make() -> Self::Ty {\n    |                  -------- type in trait\n ...\n LL |     fn make() -> u8 { 0 }\n-   |                  ^^ expected associated type, found `u8`\n+   |                  ^^\n+   |                  |\n+   |                  expected associated type, found `u8`\n+   |                  help: change the output type to match the trait: `<A<T> as Tr>::Ty`\n    |\n    = note: expected fn pointer `fn() -> <A<T> as Tr>::Ty`\n               found fn pointer `fn() -> u8`\n@@ -30,7 +33,10 @@ LL |     default type Ty = bool;\n    |     ----------------------- expected this associated type\n LL | \n LL |     fn make() -> bool { true }\n-   |                  ^^^^ expected associated type, found `bool`\n+   |                  ^^^^\n+   |                  |\n+   |                  expected associated type, found `bool`\n+   |                  help: change the output type to match the trait: `<B<T> as Tr>::Ty`\n    |\n    = note: expected fn pointer `fn() -> <B<T> as Tr>::Ty`\n               found fn pointer `fn() -> bool`"}, {"sha": "f42a9e49abdff5947c5a947fa3c0cb9ce08c4693", "filename": "src/test/ui/compare-method/bad-self-type.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/e41f378f825488a537b024fc3ed599d9c12fda96/src%2Ftest%2Fui%2Fcompare-method%2Fbad-self-type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e41f378f825488a537b024fc3ed599d9c12fda96/src%2Ftest%2Fui%2Fcompare-method%2Fbad-self-type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcompare-method%2Fbad-self-type.rs?ref=e41f378f825488a537b024fc3ed599d9c12fda96", "patch": "@@ -0,0 +1,26 @@\n+use std::future::Future;\n+use std::task::{Context, Poll};\n+\n+fn main() {}\n+\n+struct MyFuture {}\n+\n+impl Future for MyFuture {\n+    type Output = ();\n+    fn poll(self, _: &mut Context<'_>) -> Poll<()> {\n+    //~^ ERROR method `poll` has an incompatible type for trait\n+        todo!()\n+    }\n+}\n+\n+trait T {\n+    fn foo(self);\n+    fn bar(self) -> Option<()>;\n+}\n+\n+impl T for MyFuture {\n+    fn foo(self: Box<Self>) {}\n+    //~^ ERROR method `foo` has an incompatible type for trait\n+    fn bar(self) {}\n+    //~^ ERROR method `bar` has an incompatible type for trait\n+}"}, {"sha": "76f91fbf241d030c36065d5acd923aa1bfa0f67e", "filename": "src/test/ui/compare-method/bad-self-type.stderr", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/e41f378f825488a537b024fc3ed599d9c12fda96/src%2Ftest%2Fui%2Fcompare-method%2Fbad-self-type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e41f378f825488a537b024fc3ed599d9c12fda96/src%2Ftest%2Fui%2Fcompare-method%2Fbad-self-type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcompare-method%2Fbad-self-type.stderr?ref=e41f378f825488a537b024fc3ed599d9c12fda96", "patch": "@@ -0,0 +1,46 @@\n+error[E0053]: method `poll` has an incompatible type for trait\n+  --> $DIR/bad-self-type.rs:10:13\n+   |\n+LL |     fn poll(self, _: &mut Context<'_>) -> Poll<()> {\n+   |             ^^^^\n+   |             |\n+   |             expected struct `Pin`, found struct `MyFuture`\n+   |             help: change the self-receiver type to match the trait: `self: Pin<&mut MyFuture>`\n+   |\n+   = note: expected fn pointer `fn(Pin<&mut MyFuture>, &mut Context<'_>) -> Poll<_>`\n+              found fn pointer `fn(MyFuture, &mut Context<'_>) -> Poll<_>`\n+\n+error[E0053]: method `foo` has an incompatible type for trait\n+  --> $DIR/bad-self-type.rs:22:18\n+   |\n+LL |     fn foo(self);\n+   |            ---- type in trait\n+...\n+LL |     fn foo(self: Box<Self>) {}\n+   |            ------^^^^^^^^^\n+   |            |     |\n+   |            |     expected struct `MyFuture`, found struct `Box`\n+   |            help: change the self-receiver type to match the trait: `self`\n+   |\n+   = note: expected fn pointer `fn(MyFuture)`\n+              found fn pointer `fn(Box<MyFuture>)`\n+\n+error[E0053]: method `bar` has an incompatible type for trait\n+  --> $DIR/bad-self-type.rs:24:18\n+   |\n+LL |     fn bar(self) -> Option<()>;\n+   |                     ---------- type in trait\n+...\n+LL |     fn bar(self) {}\n+   |                  ^ expected enum `Option`, found `()`\n+   |\n+   = note: expected fn pointer `fn(MyFuture) -> Option<()>`\n+              found fn pointer `fn(MyFuture)`\n+help: change the output type to match the trait\n+   |\n+LL |     fn bar(self) -> Option<()> {}\n+   |                  ^^^^^^^^^^^^^\n+\n+error: aborting due to 3 previous errors\n+\n+For more information about this error, try `rustc --explain E0053`."}, {"sha": "d581628ea48adaffbef65f307f500bbb3190350a", "filename": "src/test/ui/compare-method/reordered-type-param.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e41f378f825488a537b024fc3ed599d9c12fda96/src%2Ftest%2Fui%2Fcompare-method%2Freordered-type-param.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e41f378f825488a537b024fc3ed599d9c12fda96/src%2Ftest%2Fui%2Fcompare-method%2Freordered-type-param.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fcompare-method%2Freordered-type-param.stderr?ref=e41f378f825488a537b024fc3ed599d9c12fda96", "patch": "@@ -5,8 +5,10 @@ LL |   fn b<C:Clone,D>(&self, x: C) -> C;\n    |                             - type in trait\n ...\n LL |   fn b<F:Clone,G>(&self, _x: G) -> G { panic!() }\n-   |        -       -             ^ expected type parameter `F`, found type parameter `G`\n-   |        |       |\n+   |        -       -             ^\n+   |        |       |             |\n+   |        |       |             expected type parameter `F`, found type parameter `G`\n+   |        |       |             help: change the parameter type to match the trait: `F`\n    |        |       found type parameter\n    |        expected type parameter\n    |"}, {"sha": "d37670db08537447ae3edf31558ec295efe4560a", "filename": "src/test/ui/impl-trait/impl-generic-mismatch-ab.stderr", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/e41f378f825488a537b024fc3ed599d9c12fda96/src%2Ftest%2Fui%2Fimpl-trait%2Fimpl-generic-mismatch-ab.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e41f378f825488a537b024fc3ed599d9c12fda96/src%2Ftest%2Fui%2Fimpl-trait%2Fimpl-generic-mismatch-ab.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fimpl-generic-mismatch-ab.stderr?ref=e41f378f825488a537b024fc3ed599d9c12fda96", "patch": "@@ -5,8 +5,10 @@ LL |     fn foo<A: Debug>(&self, a: &A, b: &impl Debug);\n    |                                -- type in trait\n ...\n LL |     fn foo<B: Debug>(&self, a: &impl Debug, b: &B) { }\n-   |            -                   ^^^^^^^^^^^ expected type parameter `B`, found type parameter `impl Debug`\n-   |            |\n+   |            -                   ^^^^^^^^^^^\n+   |            |                   |\n+   |            |                   expected type parameter `B`, found type parameter `impl Debug`\n+   |            |                   help: change the parameter type to match the trait: `&B`\n    |            expected type parameter\n    |\n    = note: expected fn pointer `fn(&(), &B, &impl Debug)`"}, {"sha": "bea24339837a2414cb7ecf02ac6648b287b3a871", "filename": "src/test/ui/impl-trait/trait_type.stderr", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e41f378f825488a537b024fc3ed599d9c12fda96/src%2Ftest%2Fui%2Fimpl-trait%2Ftrait_type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e41f378f825488a537b024fc3ed599d9c12fda96/src%2Ftest%2Fui%2Fimpl-trait%2Ftrait_type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Ftrait_type.stderr?ref=e41f378f825488a537b024fc3ed599d9c12fda96", "patch": "@@ -1,8 +1,11 @@\n error[E0053]: method `fmt` has an incompatible type for trait\n-  --> $DIR/trait_type.rs:7:4\n+  --> $DIR/trait_type.rs:7:21\n    |\n LL |    fn fmt(&self, x: &str) -> () { }\n-   |    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ types differ in mutability\n+   |                     ^^^^\n+   |                     |\n+   |                     types differ in mutability\n+   |                     help: change the parameter type to match the trait: `&mut Formatter<'_>`\n    |\n    = note: expected fn pointer `fn(&MyType, &mut Formatter<'_>) -> Result<(), std::fmt::Error>`\n               found fn pointer `fn(&MyType, &str)`"}, {"sha": "6c3651ff1217a28381698ec173b811ac0a11aa52", "filename": "src/test/ui/issues/issue-13033.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/e41f378f825488a537b024fc3ed599d9c12fda96/src%2Ftest%2Fui%2Fissues%2Fissue-13033.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e41f378f825488a537b024fc3ed599d9c12fda96/src%2Ftest%2Fui%2Fissues%2Fissue-13033.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-13033.stderr?ref=e41f378f825488a537b024fc3ed599d9c12fda96", "patch": "@@ -8,7 +8,7 @@ LL |     fn bar(&mut self, other: &dyn Foo) {}\n    |                              ^^^^^^^^\n    |                              |\n    |                              types differ in mutability\n-   |                              help: consider changing the mutability to match the trait: `&mut dyn Foo`\n+   |                              help: change the parameter type to match the trait: `&mut dyn Foo`\n    |\n    = note: expected fn pointer `fn(&mut Baz, &mut dyn Foo)`\n               found fn pointer `fn(&mut Baz, &dyn Foo)`"}, {"sha": "6f4813ca6235b1cfb1d8a3331d530d1ff06d42f8", "filename": "src/test/ui/issues/issue-20225.stderr", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e41f378f825488a537b024fc3ed599d9c12fda96/src%2Ftest%2Fui%2Fissues%2Fissue-20225.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e41f378f825488a537b024fc3ed599d9c12fda96/src%2Ftest%2Fui%2Fissues%2Fissue-20225.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-20225.stderr?ref=e41f378f825488a537b024fc3ed599d9c12fda96", "patch": "@@ -1,33 +1,42 @@\n error[E0053]: method `call` has an incompatible type for trait\n-  --> $DIR/issue-20225.rs:6:3\n+  --> $DIR/issue-20225.rs:6:43\n    |\n LL | impl<'a, T> Fn<(&'a T,)> for Foo {\n    |          - this type parameter\n LL |   extern \"rust-call\" fn call(&self, (_,): (T,)) {}\n-   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&T`, found type parameter `T`\n+   |                                           ^^^^\n+   |                                           |\n+   |                                           expected `&T`, found type parameter `T`\n+   |                                           help: change the parameter type to match the trait: `(&'a T,)`\n    |\n    = note: expected fn pointer `extern \"rust-call\" fn(&Foo, (&'a T,))`\n               found fn pointer `extern \"rust-call\" fn(&Foo, (T,))`\n \n error[E0053]: method `call_mut` has an incompatible type for trait\n-  --> $DIR/issue-20225.rs:11:3\n+  --> $DIR/issue-20225.rs:11:51\n    |\n LL | impl<'a, T> FnMut<(&'a T,)> for Foo {\n    |          - this type parameter\n LL |   extern \"rust-call\" fn call_mut(&mut self, (_,): (T,)) {}\n-   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&T`, found type parameter `T`\n+   |                                                   ^^^^\n+   |                                                   |\n+   |                                                   expected `&T`, found type parameter `T`\n+   |                                                   help: change the parameter type to match the trait: `(&'a T,)`\n    |\n    = note: expected fn pointer `extern \"rust-call\" fn(&mut Foo, (&'a T,))`\n               found fn pointer `extern \"rust-call\" fn(&mut Foo, (T,))`\n \n error[E0053]: method `call_once` has an incompatible type for trait\n-  --> $DIR/issue-20225.rs:18:3\n+  --> $DIR/issue-20225.rs:18:47\n    |\n LL | impl<'a, T> FnOnce<(&'a T,)> for Foo {\n    |          - this type parameter\n ...\n LL |   extern \"rust-call\" fn call_once(self, (_,): (T,)) {}\n-   |   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `&T`, found type parameter `T`\n+   |                                               ^^^^\n+   |                                               |\n+   |                                               expected `&T`, found type parameter `T`\n+   |                                               help: change the parameter type to match the trait: `(&'a T,)`\n    |\n    = note: expected fn pointer `extern \"rust-call\" fn(Foo, (&'a T,))`\n               found fn pointer `extern \"rust-call\" fn(Foo, (T,))`"}, {"sha": "d92966da17c4ceb7e2db6a3fb02c81a502cf3560", "filename": "src/test/ui/issues/issue-21332.stderr", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e41f378f825488a537b024fc3ed599d9c12fda96/src%2Ftest%2Fui%2Fissues%2Fissue-21332.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e41f378f825488a537b024fc3ed599d9c12fda96/src%2Ftest%2Fui%2Fissues%2Fissue-21332.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-21332.stderr?ref=e41f378f825488a537b024fc3ed599d9c12fda96", "patch": "@@ -1,8 +1,11 @@\n error[E0053]: method `next` has an incompatible type for trait\n-  --> $DIR/issue-21332.rs:5:5\n+  --> $DIR/issue-21332.rs:5:27\n    |\n LL |     fn next(&mut self) -> Result<i32, i32> { Ok(7) }\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected enum `Option`, found enum `Result`\n+   |                           ^^^^^^^^^^^^^^^^\n+   |                           |\n+   |                           expected enum `Option`, found enum `Result`\n+   |                           help: change the output type to match the trait: `Option<i32>`\n    |\n    = note: expected fn pointer `fn(&mut S) -> Option<i32>`\n               found fn pointer `fn(&mut S) -> Result<i32, i32>`"}, {"sha": "71b2a9df09553d49538f881b6c13c3d346223f2b", "filename": "src/test/ui/issues/issue-35869.stderr", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/e41f378f825488a537b024fc3ed599d9c12fda96/src%2Ftest%2Fui%2Fissues%2Fissue-35869.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e41f378f825488a537b024fc3ed599d9c12fda96/src%2Ftest%2Fui%2Fissues%2Fissue-35869.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-35869.stderr?ref=e41f378f825488a537b024fc3ed599d9c12fda96", "patch": "@@ -5,7 +5,10 @@ LL |     fn foo(_: fn(u8) -> ());\n    |               ------------ type in trait\n ...\n LL |     fn foo(_: fn(u16) -> ()) {}\n-   |               ^^^^^^^^^^^^^ expected `u8`, found `u16`\n+   |               ^^^^^^^^^^^^^\n+   |               |\n+   |               expected `u8`, found `u16`\n+   |               help: change the parameter type to match the trait: `fn(u8)`\n    |\n    = note: expected fn pointer `fn(fn(u8))`\n               found fn pointer `fn(fn(u16))`\n@@ -17,7 +20,10 @@ LL |     fn bar(_: Option<u8>);\n    |               ---------- type in trait\n ...\n LL |     fn bar(_: Option<u16>) {}\n-   |               ^^^^^^^^^^^ expected `u8`, found `u16`\n+   |               ^^^^^^^^^^^\n+   |               |\n+   |               expected `u8`, found `u16`\n+   |               help: change the parameter type to match the trait: `Option<u8>`\n    |\n    = note: expected fn pointer `fn(Option<u8>)`\n               found fn pointer `fn(Option<u16>)`\n@@ -29,7 +35,10 @@ LL |     fn baz(_: (u8, u16));\n    |               --------- type in trait\n ...\n LL |     fn baz(_: (u16, u16)) {}\n-   |               ^^^^^^^^^^ expected `u8`, found `u16`\n+   |               ^^^^^^^^^^\n+   |               |\n+   |               expected `u8`, found `u16`\n+   |               help: change the parameter type to match the trait: `(u8, u16)`\n    |\n    = note: expected fn pointer `fn((u8, _))`\n               found fn pointer `fn((u16, _))`\n@@ -41,7 +50,10 @@ LL |     fn qux() -> u8;\n    |                 -- type in trait\n ...\n LL |     fn qux() -> u16 { 5u16 }\n-   |                 ^^^ expected `u8`, found `u16`\n+   |                 ^^^\n+   |                 |\n+   |                 expected `u8`, found `u16`\n+   |                 help: change the output type to match the trait: `u8`\n    |\n    = note: expected fn pointer `fn() -> u8`\n               found fn pointer `fn() -> u16`"}, {"sha": "6ce8126b9f970d64d592d3bf8a2b5c5e7754d11c", "filename": "src/test/ui/mismatched_types/E0053.stderr", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e41f378f825488a537b024fc3ed599d9c12fda96/src%2Ftest%2Fui%2Fmismatched_types%2FE0053.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e41f378f825488a537b024fc3ed599d9c12fda96/src%2Ftest%2Fui%2Fmismatched_types%2FE0053.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2FE0053.stderr?ref=e41f378f825488a537b024fc3ed599d9c12fda96", "patch": "@@ -5,7 +5,10 @@ LL |     fn foo(x: u16);\n    |               --- type in trait\n ...\n LL |     fn foo(x: i16) { }\n-   |               ^^^ expected `u16`, found `i16`\n+   |               ^^^\n+   |               |\n+   |               expected `u16`, found `i16`\n+   |               help: change the parameter type to match the trait: `u16`\n    |\n    = note: expected fn pointer `fn(u16)`\n               found fn pointer `fn(i16)`\n@@ -20,7 +23,7 @@ LL |     fn bar(&mut self) { }\n    |            ^^^^^^^^^\n    |            |\n    |            types differ in mutability\n-   |            help: consider changing the mutability to match the trait: `&self`\n+   |            help: change the self-receiver type to match the trait: `self: &Bar`\n    |\n    = note: expected fn pointer `fn(&Bar)`\n               found fn pointer `fn(&mut Bar)`"}, {"sha": "2ac4d1c33a9b945c2891d266394963180614a88b", "filename": "src/test/ui/mismatched_types/trait-impl-fn-incompatibility.stderr", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/e41f378f825488a537b024fc3ed599d9c12fda96/src%2Ftest%2Fui%2Fmismatched_types%2Ftrait-impl-fn-incompatibility.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e41f378f825488a537b024fc3ed599d9c12fda96/src%2Ftest%2Fui%2Fmismatched_types%2Ftrait-impl-fn-incompatibility.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fmismatched_types%2Ftrait-impl-fn-incompatibility.stderr?ref=e41f378f825488a537b024fc3ed599d9c12fda96", "patch": "@@ -5,7 +5,10 @@ LL |     fn foo(x: u16);\n    |               --- type in trait\n ...\n LL |     fn foo(x: i16) { }\n-   |               ^^^ expected `u16`, found `i16`\n+   |               ^^^\n+   |               |\n+   |               expected `u16`, found `i16`\n+   |               help: change the parameter type to match the trait: `u16`\n    |\n    = note: expected fn pointer `fn(u16)`\n               found fn pointer `fn(i16)`\n@@ -20,7 +23,7 @@ LL |     fn bar(&mut self, bar: &Bar) { }\n    |                            ^^^^\n    |                            |\n    |                            types differ in mutability\n-   |                            help: consider changing the mutability to match the trait: `&mut Bar`\n+   |                            help: change the parameter type to match the trait: `&mut Bar`\n    |\n    = note: expected fn pointer `fn(&mut Bar, &mut Bar)`\n               found fn pointer `fn(&mut Bar, &Bar)`"}, {"sha": "23605cd2fd91dfa54acf8dcfd0bbdb30f3c4a60a", "filename": "src/test/ui/resolve/issue-81508.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/e41f378f825488a537b024fc3ed599d9c12fda96/src%2Ftest%2Fui%2Fresolve%2Fissue-81508.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e41f378f825488a537b024fc3ed599d9c12fda96/src%2Ftest%2Fui%2Fresolve%2Fissue-81508.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-81508.rs?ref=e41f378f825488a537b024fc3ed599d9c12fda96", "patch": "@@ -0,0 +1,22 @@\n+// Confusing diagnostic when using variable as a type:\n+//\n+// Previous warnings indicate Foo is not used, when in fact it is\n+// used improperly as a variable or constant. New warning points\n+// out user may be trying to use variable as a type. Test demonstrates\n+// cases for both local variable and const.\n+\n+fn main() {\n+    let Baz: &str = \"\";\n+\n+    println!(\"{}\", Baz::Bar); //~ ERROR: failed to resolve: use of undeclared type `Baz`\n+}\n+\n+#[allow(non_upper_case_globals)]\n+pub const Foo: &str = \"\";\n+\n+mod submod {\n+    use super::Foo;\n+    fn function() {\n+        println!(\"{}\", Foo::Bar); //~ ERROR: failed to resolve: use of undeclared type `Foo`\n+    }\n+}"}, {"sha": "15555631b90474887cdb356f8a4158e1d03ad044", "filename": "src/test/ui/resolve/issue-81508.stderr", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e41f378f825488a537b024fc3ed599d9c12fda96/src%2Ftest%2Fui%2Fresolve%2Fissue-81508.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e41f378f825488a537b024fc3ed599d9c12fda96/src%2Ftest%2Fui%2Fresolve%2Fissue-81508.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fresolve%2Fissue-81508.stderr?ref=e41f378f825488a537b024fc3ed599d9c12fda96", "patch": "@@ -0,0 +1,21 @@\n+error[E0433]: failed to resolve: use of undeclared type `Baz`\n+  --> $DIR/issue-81508.rs:11:20\n+   |\n+LL |     let Baz: &str = \"\";\n+   |         --- help: `Baz` is defined here, but is not a type\n+LL | \n+LL |     println!(\"{}\", Baz::Bar);\n+   |                    ^^^ use of undeclared type `Baz`\n+\n+error[E0433]: failed to resolve: use of undeclared type `Foo`\n+  --> $DIR/issue-81508.rs:20:24\n+   |\n+LL |     use super::Foo;\n+   |         ---------- help: `Foo` is defined here, but is not a type\n+LL |     fn function() {\n+LL |         println!(\"{}\", Foo::Bar);\n+   |                        ^^^ use of undeclared type `Foo`\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0433`."}, {"sha": "9f8896f01ee06f90e776c07c1ccbfdfa8a496216", "filename": "src/test/ui/wrong-mul-method-signature.stderr", "status": "modified", "additions": 15, "deletions": 6, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/e41f378f825488a537b024fc3ed599d9c12fda96/src%2Ftest%2Fui%2Fwrong-mul-method-signature.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/e41f378f825488a537b024fc3ed599d9c12fda96/src%2Ftest%2Fui%2Fwrong-mul-method-signature.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fwrong-mul-method-signature.stderr?ref=e41f378f825488a537b024fc3ed599d9c12fda96", "patch": "@@ -1,26 +1,35 @@\n error[E0053]: method `mul` has an incompatible type for trait\n-  --> $DIR/wrong-mul-method-signature.rs:16:5\n+  --> $DIR/wrong-mul-method-signature.rs:16:21\n    |\n LL |     fn mul(self, s: &f64) -> Vec1 {\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `f64`, found `&f64`\n+   |                     ^^^^\n+   |                     |\n+   |                     expected `f64`, found `&f64`\n+   |                     help: change the parameter type to match the trait: `f64`\n    |\n    = note: expected fn pointer `fn(Vec1, f64) -> Vec1`\n               found fn pointer `fn(Vec1, &f64) -> Vec1`\n \n error[E0053]: method `mul` has an incompatible type for trait\n-  --> $DIR/wrong-mul-method-signature.rs:33:5\n+  --> $DIR/wrong-mul-method-signature.rs:33:21\n    |\n LL |     fn mul(self, s: f64) -> Vec2 {\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected struct `Vec2`, found `f64`\n+   |                     ^^^\n+   |                     |\n+   |                     expected struct `Vec2`, found `f64`\n+   |                     help: change the parameter type to match the trait: `Vec2`\n    |\n    = note: expected fn pointer `fn(Vec2, Vec2) -> f64`\n               found fn pointer `fn(Vec2, f64) -> Vec2`\n \n error[E0053]: method `mul` has an incompatible type for trait\n-  --> $DIR/wrong-mul-method-signature.rs:52:5\n+  --> $DIR/wrong-mul-method-signature.rs:52:29\n    |\n LL |     fn mul(self, s: f64) -> f64 {\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^ expected `i32`, found `f64`\n+   |                             ^^^\n+   |                             |\n+   |                             expected `i32`, found `f64`\n+   |                             help: change the output type to match the trait: `i32`\n    |\n    = note: expected fn pointer `fn(Vec3, _) -> i32`\n               found fn pointer `fn(Vec3, _) -> f64`"}]}