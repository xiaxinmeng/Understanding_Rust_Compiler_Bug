{"sha": "e8d30bf542af6fe285c76867361ffdd7bac79a2c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmU4ZDMwYmY1NDJhZjZmZTI4NWM3Njg2NzM2MWZmZGQ3YmFjNzlhMmM=", "commit": {"author": {"name": "Yuki Okushi", "email": "huyuumi.dev@gmail.com", "date": "2020-08-19T06:54:30Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-08-19T06:54:30Z"}, "message": "Rollup merge of #75554 - jumbatm:fix-clashing-extern-decl-overflow, r=lcnr\n\nFix clashing_extern_declarations stack overflow for recursive types.\n\nFixes #75512.\n\nAdds a seen set to `structurally_same_type` to avoid recursing indefinitely for types which contain values of the same type through a pointer or reference.", "tree": {"sha": "1ee3cc71caf38e1effa69ae9ca274ee0736ed5b8", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1ee3cc71caf38e1effa69ae9ca274ee0736ed5b8"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/e8d30bf542af6fe285c76867361ffdd7bac79a2c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJfPMymCRBK7hj4Ov3rIwAAdHIIABExrawxBMWc1r432EQWrKAQ\ncpqhsW2nbJf5QHQGKOA1P+31FAJPOeqyuDMzSMh+82LLDyHztZYoKC5W3iVOGabs\nax+hUWPQlmDtcDLRmOZEYFT13ZKTmPQGVcFCRzSJBAWPmx64obGe6RbK3I3DTStV\nuf2I0lARqop1UqRb+Gn1nW6U3eKwIRYEerSelMsIxdihOK9UpUbP5GfVbPy4S4HA\nWmygpAUrM0yzXSXyRgQliNNieN0G6gs8wFxn0w6OZJK6g+sbBQqXaD3h10+4JRLv\nntoOgOec4JqzNXUlPzCQhD2fo2r3JvvJbLWf5TlSr5kNrYlXPRVmWcSunz9fLPk=\n=Wfs5\n-----END PGP SIGNATURE-----\n", "payload": "tree 1ee3cc71caf38e1effa69ae9ca274ee0736ed5b8\nparent ac264b53d114ed00828b3236b8b2279df09f1623\nparent bc15dd6dde58aaed724cf692c0635060a77fc99c\nauthor Yuki Okushi <huyuumi.dev@gmail.com> 1597820070 +0900\ncommitter GitHub <noreply@github.com> 1597820070 +0900\n\nRollup merge of #75554 - jumbatm:fix-clashing-extern-decl-overflow, r=lcnr\n\nFix clashing_extern_declarations stack overflow for recursive types.\n\nFixes #75512.\n\nAdds a seen set to `structurally_same_type` to avoid recursing indefinitely for types which contain values of the same type through a pointer or reference.\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/e8d30bf542af6fe285c76867361ffdd7bac79a2c", "html_url": "https://github.com/rust-lang/rust/commit/e8d30bf542af6fe285c76867361ffdd7bac79a2c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/e8d30bf542af6fe285c76867361ffdd7bac79a2c/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "ac264b53d114ed00828b3236b8b2279df09f1623", "url": "https://api.github.com/repos/rust-lang/rust/commits/ac264b53d114ed00828b3236b8b2279df09f1623", "html_url": "https://github.com/rust-lang/rust/commit/ac264b53d114ed00828b3236b8b2279df09f1623"}, {"sha": "bc15dd6dde58aaed724cf692c0635060a77fc99c", "url": "https://api.github.com/repos/rust-lang/rust/commits/bc15dd6dde58aaed724cf692c0635060a77fc99c", "html_url": "https://github.com/rust-lang/rust/commit/bc15dd6dde58aaed724cf692c0635060a77fc99c"}], "stats": {"total": 353, "additions": 251, "deletions": 102}, "files": [{"sha": "b337bf0a3f9226f7fecb3ccdfc4375a4791fd1b3", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 132, "deletions": 102, "changes": 234, "blob_url": "https://github.com/rust-lang/rust/blob/e8d30bf542af6fe285c76867361ffdd7bac79a2c/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8d30bf542af6fe285c76867361ffdd7bac79a2c/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=e8d30bf542af6fe285c76867361ffdd7bac79a2c", "patch": "@@ -29,6 +29,7 @@ use rustc_ast::visit::{FnCtxt, FnKind};\n use rustc_ast::{self as ast, *};\n use rustc_ast_pretty::pprust::{self, expr_to_string};\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::stack::ensure_sufficient_stack;\n use rustc_errors::{Applicability, DiagnosticBuilder, DiagnosticStyledString};\n use rustc_feature::{deprecated_attributes, AttributeGate, AttributeTemplate, AttributeType};\n use rustc_feature::{GateIssue, Stability};\n@@ -2153,123 +2154,152 @@ impl ClashingExternDeclarations {\n         b: Ty<'tcx>,\n         ckind: CItemKind,\n     ) -> bool {\n-        debug!(\"structurally_same_type(cx, a = {:?}, b = {:?})\", a, b);\n-        let tcx = cx.tcx;\n-        if a == b || rustc_middle::ty::TyS::same_type(a, b) {\n-            // All nominally-same types are structurally same, too.\n-            true\n-        } else {\n-            // Do a full, depth-first comparison between the two.\n-            use rustc_middle::ty::TyKind::*;\n-            let a_kind = &a.kind;\n-            let b_kind = &b.kind;\n-\n-            let compare_layouts = |a, b| -> bool {\n-                let a_layout = &cx.layout_of(a).unwrap().layout.abi;\n-                let b_layout = &cx.layout_of(b).unwrap().layout.abi;\n-                debug!(\"{:?} == {:?} = {}\", a_layout, b_layout, a_layout == b_layout);\n-                a_layout == b_layout\n-            };\n+        fn structurally_same_type_impl<'tcx>(\n+            seen_types: &mut FxHashSet<(Ty<'tcx>, Ty<'tcx>)>,\n+            cx: &LateContext<'tcx>,\n+            a: Ty<'tcx>,\n+            b: Ty<'tcx>,\n+            ckind: CItemKind,\n+        ) -> bool {\n+            debug!(\"structurally_same_type_impl(cx, a = {:?}, b = {:?})\", a, b);\n+            if !seen_types.insert((a, b)) {\n+                // We've encountered a cycle. There's no point going any further -- the types are\n+                // structurally the same.\n+                return true;\n+            }\n+            let tcx = cx.tcx;\n+            if a == b || rustc_middle::ty::TyS::same_type(a, b) {\n+                // All nominally-same types are structurally same, too.\n+                true\n+            } else {\n+                // Do a full, depth-first comparison between the two.\n+                use rustc_middle::ty::TyKind::*;\n+                let a_kind = &a.kind;\n+                let b_kind = &b.kind;\n+\n+                let compare_layouts = |a, b| -> bool {\n+                    let a_layout = &cx.layout_of(a).unwrap().layout.abi;\n+                    let b_layout = &cx.layout_of(b).unwrap().layout.abi;\n+                    debug!(\"{:?} == {:?} = {}\", a_layout, b_layout, a_layout == b_layout);\n+                    a_layout == b_layout\n+                };\n+\n+                #[allow(rustc::usage_of_ty_tykind)]\n+                let is_primitive_or_pointer = |kind: &ty::TyKind<'_>| {\n+                    kind.is_primitive() || matches!(kind, RawPtr(..) | Ref(..))\n+                };\n \n-            #[allow(rustc::usage_of_ty_tykind)]\n-            let is_primitive_or_pointer =\n-                |kind: &ty::TyKind<'_>| kind.is_primitive() || matches!(kind, RawPtr(..));\n-\n-            match (a_kind, b_kind) {\n-                (Adt(_, a_substs), Adt(_, b_substs)) => {\n-                    let a = a.subst(cx.tcx, a_substs);\n-                    let b = b.subst(cx.tcx, b_substs);\n-                    debug!(\"Comparing {:?} and {:?}\", a, b);\n-\n-                    if let (Adt(a_def, ..), Adt(b_def, ..)) = (&a.kind, &b.kind) {\n-                        // Grab a flattened representation of all fields.\n-                        let a_fields = a_def.variants.iter().flat_map(|v| v.fields.iter());\n-                        let b_fields = b_def.variants.iter().flat_map(|v| v.fields.iter());\n-                        compare_layouts(a, b)\n+                ensure_sufficient_stack(|| {\n+                    match (a_kind, b_kind) {\n+                        (Adt(a_def, a_substs), Adt(b_def, b_substs)) => {\n+                            let a = a.subst(cx.tcx, a_substs);\n+                            let b = b.subst(cx.tcx, b_substs);\n+                            debug!(\"Comparing {:?} and {:?}\", a, b);\n+\n+                            // Grab a flattened representation of all fields.\n+                            let a_fields = a_def.variants.iter().flat_map(|v| v.fields.iter());\n+                            let b_fields = b_def.variants.iter().flat_map(|v| v.fields.iter());\n+                            compare_layouts(a, b)\n                             && a_fields.eq_by(\n                                 b_fields,\n                                 |&ty::FieldDef { did: a_did, .. },\n                                  &ty::FieldDef { did: b_did, .. }| {\n-                                    Self::structurally_same_type(\n+                                    structurally_same_type_impl(\n+                                        seen_types,\n                                         cx,\n                                         tcx.type_of(a_did),\n                                         tcx.type_of(b_did),\n                                         ckind,\n                                     )\n                                 },\n                             )\n-                    } else {\n-                        unreachable!()\n-                    }\n-                }\n-                (Array(a_ty, a_const), Array(b_ty, b_const)) => {\n-                    // For arrays, we also check the constness of the type.\n-                    a_const.val == b_const.val\n-                        && Self::structurally_same_type(cx, a_const.ty, b_const.ty, ckind)\n-                        && Self::structurally_same_type(cx, a_ty, b_ty, ckind)\n-                }\n-                (Slice(a_ty), Slice(b_ty)) => Self::structurally_same_type(cx, a_ty, b_ty, ckind),\n-                (RawPtr(a_tymut), RawPtr(b_tymut)) => {\n-                    a_tymut.mutbl == b_tymut.mutbl\n-                        && Self::structurally_same_type(cx, &a_tymut.ty, &b_tymut.ty, ckind)\n-                }\n-                (Ref(_a_region, a_ty, a_mut), Ref(_b_region, b_ty, b_mut)) => {\n-                    // For structural sameness, we don't need the region to be same.\n-                    a_mut == b_mut && Self::structurally_same_type(cx, a_ty, b_ty, ckind)\n-                }\n-                (FnDef(..), FnDef(..)) => {\n-                    let a_poly_sig = a.fn_sig(tcx);\n-                    let b_poly_sig = b.fn_sig(tcx);\n-\n-                    // As we don't compare regions, skip_binder is fine.\n-                    let a_sig = a_poly_sig.skip_binder();\n-                    let b_sig = b_poly_sig.skip_binder();\n-\n-                    (a_sig.abi, a_sig.unsafety, a_sig.c_variadic)\n-                        == (b_sig.abi, b_sig.unsafety, b_sig.c_variadic)\n-                        && a_sig.inputs().iter().eq_by(b_sig.inputs().iter(), |a, b| {\n-                            Self::structurally_same_type(cx, a, b, ckind)\n-                        })\n-                        && Self::structurally_same_type(cx, a_sig.output(), b_sig.output(), ckind)\n-                }\n-                (Tuple(a_substs), Tuple(b_substs)) => {\n-                    a_substs.types().eq_by(b_substs.types(), |a_ty, b_ty| {\n-                        Self::structurally_same_type(cx, a_ty, b_ty, ckind)\n-                    })\n-                }\n-                // For these, it's not quite as easy to define structural-sameness quite so easily.\n-                // For the purposes of this lint, take the conservative approach and mark them as\n-                // not structurally same.\n-                (Dynamic(..), Dynamic(..))\n-                | (Error(..), Error(..))\n-                | (Closure(..), Closure(..))\n-                | (Generator(..), Generator(..))\n-                | (GeneratorWitness(..), GeneratorWitness(..))\n-                | (Projection(..), Projection(..))\n-                | (Opaque(..), Opaque(..)) => false,\n-\n-                // These definitely should have been caught above.\n-                (Bool, Bool) | (Char, Char) | (Never, Never) | (Str, Str) => unreachable!(),\n-\n-                // An Adt and a primitive type. This can be FFI-safe is the ADT is an enum with a\n-                // non-null field.\n-                (Adt(..), other_kind) | (other_kind, Adt(..))\n-                    if is_primitive_or_pointer(other_kind) =>\n-                {\n-                    let (primitive, adt) =\n-                        if is_primitive_or_pointer(&a.kind) { (a, b) } else { (b, a) };\n-                    if let Some(ty) = crate::types::repr_nullable_ptr(cx, adt, ckind) {\n-                        ty == primitive\n-                    } else {\n-                        compare_layouts(a, b)\n+                        }\n+                        (Array(a_ty, a_const), Array(b_ty, b_const)) => {\n+                            // For arrays, we also check the constness of the type.\n+                            a_const.val == b_const.val\n+                                && structurally_same_type_impl(seen_types, cx, a_ty, b_ty, ckind)\n+                        }\n+                        (Slice(a_ty), Slice(b_ty)) => {\n+                            structurally_same_type_impl(seen_types, cx, a_ty, b_ty, ckind)\n+                        }\n+                        (RawPtr(a_tymut), RawPtr(b_tymut)) => {\n+                            a_tymut.mutbl == b_tymut.mutbl\n+                                && structurally_same_type_impl(\n+                                    seen_types,\n+                                    cx,\n+                                    &a_tymut.ty,\n+                                    &b_tymut.ty,\n+                                    ckind,\n+                                )\n+                        }\n+                        (Ref(_a_region, a_ty, a_mut), Ref(_b_region, b_ty, b_mut)) => {\n+                            // For structural sameness, we don't need the region to be same.\n+                            a_mut == b_mut\n+                                && structurally_same_type_impl(seen_types, cx, a_ty, b_ty, ckind)\n+                        }\n+                        (FnDef(..), FnDef(..)) => {\n+                            let a_poly_sig = a.fn_sig(tcx);\n+                            let b_poly_sig = b.fn_sig(tcx);\n+\n+                            // As we don't compare regions, skip_binder is fine.\n+                            let a_sig = a_poly_sig.skip_binder();\n+                            let b_sig = b_poly_sig.skip_binder();\n+\n+                            (a_sig.abi, a_sig.unsafety, a_sig.c_variadic)\n+                                == (b_sig.abi, b_sig.unsafety, b_sig.c_variadic)\n+                                && a_sig.inputs().iter().eq_by(b_sig.inputs().iter(), |a, b| {\n+                                    structurally_same_type_impl(seen_types, cx, a, b, ckind)\n+                                })\n+                                && structurally_same_type_impl(\n+                                    seen_types,\n+                                    cx,\n+                                    a_sig.output(),\n+                                    b_sig.output(),\n+                                    ckind,\n+                                )\n+                        }\n+                        (Tuple(a_substs), Tuple(b_substs)) => {\n+                            a_substs.types().eq_by(b_substs.types(), |a_ty, b_ty| {\n+                                structurally_same_type_impl(seen_types, cx, a_ty, b_ty, ckind)\n+                            })\n+                        }\n+                        // For these, it's not quite as easy to define structural-sameness quite so easily.\n+                        // For the purposes of this lint, take the conservative approach and mark them as\n+                        // not structurally same.\n+                        (Dynamic(..), Dynamic(..))\n+                        | (Error(..), Error(..))\n+                        | (Closure(..), Closure(..))\n+                        | (Generator(..), Generator(..))\n+                        | (GeneratorWitness(..), GeneratorWitness(..))\n+                        | (Projection(..), Projection(..))\n+                        | (Opaque(..), Opaque(..)) => false,\n+\n+                        // These definitely should have been caught above.\n+                        (Bool, Bool) | (Char, Char) | (Never, Never) | (Str, Str) => unreachable!(),\n+\n+                        // An Adt and a primitive or pointer type. This can be FFI-safe if non-null\n+                        // enum layout optimisation is being applied.\n+                        (Adt(..), other_kind) | (other_kind, Adt(..))\n+                            if is_primitive_or_pointer(other_kind) =>\n+                        {\n+                            let (primitive, adt) =\n+                                if is_primitive_or_pointer(&a.kind) { (a, b) } else { (b, a) };\n+                            if let Some(ty) = crate::types::repr_nullable_ptr(cx, adt, ckind) {\n+                                ty == primitive\n+                            } else {\n+                                compare_layouts(a, b)\n+                            }\n+                        }\n+                        // Otherwise, just compare the layouts. This may fail to lint for some\n+                        // incompatible types, but at the very least, will stop reads into\n+                        // uninitialised memory.\n+                        _ => compare_layouts(a, b),\n                     }\n-                }\n-                // Otherwise, just compare the layouts. This may fail to lint for some\n-                // incompatible types, but at the very least, will stop reads into\n-                // uninitialised memory.\n-                _ => compare_layouts(a, b),\n+                })\n             }\n         }\n+        let mut seen_types = FxHashSet::default();\n+        structurally_same_type_impl(&mut seen_types, cx, a, b, ckind)\n     }\n }\n "}, {"sha": "ab0fd0a2e708542f978e634c81eb9d78077b26f1", "filename": "src/test/ui/lint/clashing-extern-fn-recursion.rs", "status": "added", "additions": 119, "deletions": 0, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/e8d30bf542af6fe285c76867361ffdd7bac79a2c/src%2Ftest%2Fui%2Flint%2Fclashing-extern-fn-recursion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/e8d30bf542af6fe285c76867361ffdd7bac79a2c/src%2Ftest%2Fui%2Flint%2Fclashing-extern-fn-recursion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Fclashing-extern-fn-recursion.rs?ref=e8d30bf542af6fe285c76867361ffdd7bac79a2c", "patch": "@@ -0,0 +1,119 @@\n+// check-pass\n+//\n+// This tests checks that clashing_extern_declarations handles types that are recursive through a\n+// pointer or ref argument. See #75512.\n+\n+#![crate_type = \"lib\"]\n+\n+mod raw_ptr_recursion {\n+    mod a {\n+        #[repr(C)]\n+        struct Pointy {\n+            pointy: *const Pointy,\n+        }\n+\n+        extern \"C\" {\n+            fn run_pointy(pointy: Pointy);\n+        }\n+    }\n+    mod b {\n+        #[repr(C)]\n+        struct Pointy {\n+            pointy: *const Pointy,\n+        }\n+\n+        extern \"C\" {\n+            fn run_pointy(pointy: Pointy);\n+        }\n+    }\n+}\n+\n+mod raw_ptr_recursion_once_removed {\n+    mod a {\n+        #[repr(C)]\n+        struct Pointy1 {\n+            pointy_two: *const Pointy2,\n+        }\n+\n+        #[repr(C)]\n+        struct Pointy2 {\n+            pointy_one: *const Pointy1,\n+        }\n+\n+        extern \"C\" {\n+            fn run_pointy2(pointy: Pointy2);\n+        }\n+    }\n+\n+    mod b {\n+        #[repr(C)]\n+        struct Pointy1 {\n+            pointy_two: *const Pointy2,\n+        }\n+\n+        #[repr(C)]\n+        struct Pointy2 {\n+            pointy_one: *const Pointy1,\n+        }\n+\n+        extern \"C\" {\n+            fn run_pointy2(pointy: Pointy2);\n+        }\n+    }\n+}\n+\n+mod ref_recursion {\n+    mod a {\n+        #[repr(C)]\n+        struct Reffy<'a> {\n+            reffy: &'a Reffy<'a>,\n+        }\n+\n+        extern \"C\" {\n+            fn reffy_recursion(reffy: Reffy);\n+        }\n+    }\n+    mod b {\n+        #[repr(C)]\n+        struct Reffy<'a> {\n+            reffy: &'a Reffy<'a>,\n+        }\n+\n+        extern \"C\" {\n+            fn reffy_recursion(reffy: Reffy);\n+        }\n+    }\n+}\n+\n+mod ref_recursion_once_removed {\n+    mod a {\n+        #[repr(C)]\n+        struct Reffy1<'a> {\n+            reffy: &'a Reffy2<'a>,\n+        }\n+\n+        struct Reffy2<'a> {\n+            reffy: &'a Reffy1<'a>,\n+        }\n+\n+        extern \"C\" {\n+            #[allow(improper_ctypes)]\n+            fn reffy_once_removed(reffy: Reffy1);\n+        }\n+    }\n+    mod b {\n+        #[repr(C)]\n+        struct Reffy1<'a> {\n+            reffy: &'a Reffy2<'a>,\n+        }\n+\n+        struct Reffy2<'a> {\n+            reffy: &'a Reffy1<'a>,\n+        }\n+\n+        extern \"C\" {\n+            #[allow(improper_ctypes)]\n+            fn reffy_once_removed(reffy: Reffy1);\n+        }\n+    }\n+}"}]}