{"sha": "20cea3ebb468df74447ed3aa5e646f741208bea8", "node_id": "C_kwDOAAsO6NoAKDIwY2VhM2ViYjQ2OGRmNzQ0NDdlZDNhYTVlNjQ2Zjc0MTIwOGJlYTg", "commit": {"author": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-06-22T04:27:15Z"}, "committer": {"name": "Michael Goulet", "email": "michael@errs.io", "date": "2022-06-24T22:36:55Z"}, "message": "Fix printing impl trait under binders", "tree": {"sha": "92d554f0ae7c03070dd5858970ac7ddae4c1e987", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/92d554f0ae7c03070dd5858970ac7ddae4c1e987"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/20cea3ebb468df74447ed3aa5e646f741208bea8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/20cea3ebb468df74447ed3aa5e646f741208bea8", "html_url": "https://github.com/rust-lang/rust/commit/20cea3ebb468df74447ed3aa5e646f741208bea8", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/20cea3ebb468df74447ed3aa5e646f741208bea8/comments", "author": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "compiler-errors", "id": 3674314, "node_id": "MDQ6VXNlcjM2NzQzMTQ=", "avatar_url": "https://avatars.githubusercontent.com/u/3674314?v=4", "gravatar_id": "", "url": "https://api.github.com/users/compiler-errors", "html_url": "https://github.com/compiler-errors", "followers_url": "https://api.github.com/users/compiler-errors/followers", "following_url": "https://api.github.com/users/compiler-errors/following{/other_user}", "gists_url": "https://api.github.com/users/compiler-errors/gists{/gist_id}", "starred_url": "https://api.github.com/users/compiler-errors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/compiler-errors/subscriptions", "organizations_url": "https://api.github.com/users/compiler-errors/orgs", "repos_url": "https://api.github.com/users/compiler-errors/repos", "events_url": "https://api.github.com/users/compiler-errors/events{/privacy}", "received_events_url": "https://api.github.com/users/compiler-errors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fdca237d5194bf8a1c9b437ebd2114d1c2ba6195", "url": "https://api.github.com/repos/rust-lang/rust/commits/fdca237d5194bf8a1c9b437ebd2114d1c2ba6195", "html_url": "https://github.com/rust-lang/rust/commit/fdca237d5194bf8a1c9b437ebd2114d1c2ba6195"}], "stats": {"total": 291, "additions": 178, "deletions": 113}, "files": [{"sha": "d0f53f8f74b2663124b2c14b9eebe14daa93f9ec", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 133, "deletions": 113, "changes": 246, "blob_url": "https://github.com/rust-lang/rust/blob/20cea3ebb468df74447ed3aa5e646f741208bea8/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20cea3ebb468df74447ed3aa5e646f741208bea8/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=20cea3ebb468df74447ed3aa5e646f741208bea8", "patch": "@@ -226,7 +226,7 @@ pub trait PrettyPrinter<'tcx>:\n         value.as_ref().skip_binder().print(self)\n     }\n \n-    fn wrap_binder<T, F: Fn(&T, Self) -> Result<Self, fmt::Error>>(\n+    fn wrap_binder<T, F: FnOnce(&T, Self) -> Result<Self, fmt::Error>>(\n         self,\n         value: &ty::Binder<'tcx, T>,\n         f: F,\n@@ -773,26 +773,26 @@ pub trait PrettyPrinter<'tcx>:\n         def_id: DefId,\n         substs: &'tcx ty::List<ty::GenericArg<'tcx>>,\n     ) -> Result<Self::Type, Self::Error> {\n-        define_scoped_cx!(self);\n+        let tcx = self.tcx();\n \n         // Grab the \"TraitA + TraitB\" from `impl TraitA + TraitB`,\n         // by looking up the projections associated with the def_id.\n-        let bounds = self.tcx().bound_explicit_item_bounds(def_id);\n+        let bounds = tcx.bound_explicit_item_bounds(def_id);\n \n         let mut traits = FxIndexMap::default();\n         let mut fn_traits = FxIndexMap::default();\n         let mut is_sized = false;\n \n         for predicate in bounds.transpose_iter().map(|e| e.map_bound(|(p, _)| *p)) {\n-            let predicate = predicate.subst(self.tcx(), substs);\n+            let predicate = predicate.subst(tcx, substs);\n             let bound_predicate = predicate.kind();\n \n             match bound_predicate.skip_binder() {\n                 ty::PredicateKind::Trait(pred) => {\n                     let trait_ref = bound_predicate.rebind(pred.trait_ref);\n \n                     // Don't print + Sized, but rather + ?Sized if absent.\n-                    if Some(trait_ref.def_id()) == self.tcx().lang_items().sized_trait() {\n+                    if Some(trait_ref.def_id()) == tcx.lang_items().sized_trait() {\n                         is_sized = true;\n                         continue;\n                     }\n@@ -801,7 +801,7 @@ pub trait PrettyPrinter<'tcx>:\n                 }\n                 ty::PredicateKind::Projection(pred) => {\n                     let proj_ref = bound_predicate.rebind(pred);\n-                    let trait_ref = proj_ref.required_poly_trait_ref(self.tcx());\n+                    let trait_ref = proj_ref.required_poly_trait_ref(tcx);\n \n                     // Projection type entry -- the def-id for naming, and the ty.\n                     let proj_ty = (proj_ref.projection_def_id(), proj_ref.term());\n@@ -817,148 +817,168 @@ pub trait PrettyPrinter<'tcx>:\n             }\n         }\n \n+        {\n+            define_scoped_cx!(self);\n+            p!(\"impl \");\n+        }\n+\n         let mut first = true;\n         // Insert parenthesis around (Fn(A, B) -> C) if the opaque ty has more than one other trait\n         let paren_needed = fn_traits.len() > 1 || traits.len() > 0 || !is_sized;\n \n-        p!(\"impl\");\n-\n         for (fn_once_trait_ref, entry) in fn_traits {\n-            // Get the (single) generic ty (the args) of this FnOnce trait ref.\n-            let generics = self.tcx().generics_of(fn_once_trait_ref.def_id());\n-            let args =\n-                generics.own_substs_no_defaults(self.tcx(), fn_once_trait_ref.skip_binder().substs);\n-\n-            match (entry.return_ty, args[0].expect_ty()) {\n-                // We can only print `impl Fn() -> ()` if we have a tuple of args and we recorded\n-                // a return type.\n-                (Some(return_ty), arg_tys) if matches!(arg_tys.kind(), ty::Tuple(_)) => {\n-                    let name = if entry.fn_trait_ref.is_some() {\n-                        \"Fn\"\n-                    } else if entry.fn_mut_trait_ref.is_some() {\n-                        \"FnMut\"\n-                    } else {\n-                        \"FnOnce\"\n-                    };\n+            {\n+                define_scoped_cx!(self);\n+                p!(\n+                    write(\"{}\", if first { \"\" } else { \" + \" }),\n+                    write(\"{}\", if paren_needed { \"(\" } else { \"\" })\n+                );\n+            }\n+\n+            self = self.wrap_binder(&fn_once_trait_ref, |trait_ref, mut self_| {\n+                // Get the (single) generic ty (the args) of this FnOnce trait ref.\n+                let generics = tcx.generics_of(trait_ref.def_id);\n+                let args = generics.own_substs_no_defaults(tcx, trait_ref.substs);\n+\n+                match (entry.return_ty, args[0].expect_ty()) {\n+                    // We can only print `impl Fn() -> ()` if we have a tuple of args and we recorded\n+                    // a return type.\n+                    (Some(return_ty), arg_tys) if matches!(arg_tys.kind(), ty::Tuple(_)) => {\n+                        let name = if entry.fn_trait_ref.is_some() {\n+                            \"Fn\"\n+                        } else if entry.fn_mut_trait_ref.is_some() {\n+                            \"FnMut\"\n+                        } else {\n+                            \"FnOnce\"\n+                        };\n \n-                    p!(\n-                        write(\"{}\", if first { \" \" } else { \" + \" }),\n-                        write(\"{}{}(\", if paren_needed { \"(\" } else { \"\" }, name)\n-                    );\n+                        define_scoped_cx!(self_);\n+                        p!(write(\"{}(\", name));\n \n-                    for (idx, ty) in arg_tys.tuple_fields().iter().enumerate() {\n-                        if idx > 0 {\n-                            p!(\", \");\n+                        for (idx, ty) in arg_tys.tuple_fields().iter().enumerate() {\n+                            if idx > 0 {\n+                                p!(\", \");\n+                            }\n+                            p!(print(ty));\n                         }\n-                        p!(print(ty));\n-                    }\n \n-                    p!(\")\");\n-                    if let Term::Ty(ty) = return_ty.skip_binder() {\n-                        if !ty.is_unit() {\n-                            p!(\" -> \", print(return_ty));\n+                        p!(\")\");\n+                        if let Term::Ty(ty) = return_ty.skip_binder() {\n+                            if !ty.is_unit() {\n+                                p!(\" -> \", print(return_ty));\n+                            }\n                         }\n-                    }\n-                    p!(write(\"{}\", if paren_needed { \")\" } else { \"\" }));\n+                        p!(write(\"{}\", if paren_needed { \")\" } else { \"\" }));\n \n-                    first = false;\n-                }\n-                // If we got here, we can't print as a `impl Fn(A, B) -> C`. Just record the\n-                // trait_refs we collected in the OpaqueFnEntry as normal trait refs.\n-                _ => {\n-                    if entry.has_fn_once {\n-                        traits.entry(fn_once_trait_ref).or_default().extend(\n-                            // Group the return ty with its def id, if we had one.\n-                            entry\n-                                .return_ty\n-                                .map(|ty| (self.tcx().lang_items().fn_once_output().unwrap(), ty)),\n-                        );\n-                    }\n-                    if let Some(trait_ref) = entry.fn_mut_trait_ref {\n-                        traits.entry(trait_ref).or_default();\n+                        first = false;\n                     }\n-                    if let Some(trait_ref) = entry.fn_trait_ref {\n-                        traits.entry(trait_ref).or_default();\n+                    // If we got here, we can't print as a `impl Fn(A, B) -> C`. Just record the\n+                    // trait_refs we collected in the OpaqueFnEntry as normal trait refs.\n+                    _ => {\n+                        if entry.has_fn_once {\n+                            traits.entry(fn_once_trait_ref).or_default().extend(\n+                                // Group the return ty with its def id, if we had one.\n+                                entry\n+                                    .return_ty\n+                                    .map(|ty| (tcx.lang_items().fn_once_output().unwrap(), ty)),\n+                            );\n+                        }\n+                        if let Some(trait_ref) = entry.fn_mut_trait_ref {\n+                            traits.entry(trait_ref).or_default();\n+                        }\n+                        if let Some(trait_ref) = entry.fn_trait_ref {\n+                            traits.entry(trait_ref).or_default();\n+                        }\n                     }\n                 }\n-            }\n+\n+                Ok(self_)\n+            })?;\n         }\n \n         // Print the rest of the trait types (that aren't Fn* family of traits)\n         for (trait_ref, assoc_items) in traits {\n-            p!(\n-                write(\"{}\", if first { \" \" } else { \" + \" }),\n-                print(trait_ref.skip_binder().print_only_trait_name())\n-            );\n+            {\n+                define_scoped_cx!(self);\n+                p!(write(\"{}\", if first { \"\" } else { \" + \" }));\n+            }\n \n-            let generics = self.tcx().generics_of(trait_ref.def_id());\n-            let args = generics.own_substs_no_defaults(self.tcx(), trait_ref.skip_binder().substs);\n+            self = self.wrap_binder(&trait_ref, |trait_ref, mut self_| {\n+                define_scoped_cx!(self_);\n+                p!(print(trait_ref.print_only_trait_name()));\n \n-            if !args.is_empty() || !assoc_items.is_empty() {\n-                let mut first = true;\n+                let generics = tcx.generics_of(trait_ref.def_id);\n+                let args = generics.own_substs_no_defaults(tcx, trait_ref.substs);\n \n-                for ty in args {\n-                    if first {\n-                        p!(\"<\");\n-                        first = false;\n-                    } else {\n-                        p!(\", \");\n+                if !args.is_empty() || !assoc_items.is_empty() {\n+                    let mut first = true;\n+\n+                    for ty in args {\n+                        if first {\n+                            p!(\"<\");\n+                            first = false;\n+                        } else {\n+                            p!(\", \");\n+                        }\n+                        p!(print(ty));\n                     }\n-                    p!(print(trait_ref.rebind(*ty)));\n-                }\n \n-                for (assoc_item_def_id, term) in assoc_items {\n-                    // Skip printing `<[generator@] as Generator<_>>::Return` from async blocks,\n-                    // unless we can find out what generator return type it comes from.\n-                    let term = if let Some(ty) = term.skip_binder().ty()\n-                        && let ty::Projection(ty::ProjectionTy { item_def_id, substs }) = ty.kind()\n-                        && Some(*item_def_id) == self.tcx().lang_items().generator_return()\n-                    {\n-                        if let ty::Generator(_, substs, _) = substs.type_at(0).kind() {\n-                            let return_ty = substs.as_generator().return_ty();\n-                            if !return_ty.is_ty_infer() {\n-                                return_ty.into()\n+                    for (assoc_item_def_id, term) in assoc_items {\n+                        // Skip printing `<[generator@] as Generator<_>>::Return` from async blocks,\n+                        // unless we can find out what generator return type it comes from.\n+                        let term = if let Some(ty) = term.skip_binder().ty()\n+                            && let ty::Projection(ty::ProjectionTy { item_def_id, substs }) = ty.kind()\n+                            && Some(*item_def_id) == tcx.lang_items().generator_return()\n+                        {\n+                            if let ty::Generator(_, substs, _) = substs.type_at(0).kind() {\n+                                let return_ty = substs.as_generator().return_ty();\n+                                if !return_ty.is_ty_infer() {\n+                                    return_ty.into()\n+                                } else {\n+                                    continue;\n+                                }\n                             } else {\n                                 continue;\n                             }\n                         } else {\n-                            continue;\n-                        }\n-                    } else {\n-                        term.skip_binder()\n-                    };\n+                            term.skip_binder()\n+                        };\n \n-                    if first {\n-                        p!(\"<\");\n-                        first = false;\n-                    } else {\n-                        p!(\", \");\n-                    }\n+                        if first {\n+                            p!(\"<\");\n+                            first = false;\n+                        } else {\n+                            p!(\", \");\n+                        }\n \n-                    p!(write(\"{} = \", self.tcx().associated_item(assoc_item_def_id).name));\n+                        p!(write(\"{} = \", tcx.associated_item(assoc_item_def_id).name));\n \n-                    match term {\n-                        Term::Ty(ty) => {\n-                            p!(print(ty))\n-                        }\n-                        Term::Const(c) => {\n-                            p!(print(c));\n-                        }\n-                    };\n-                }\n+                        match term {\n+                            Term::Ty(ty) => {\n+                                p!(print(ty))\n+                            }\n+                            Term::Const(c) => {\n+                                p!(print(c));\n+                            }\n+                        };\n+                    }\n \n-                if !first {\n-                    p!(\">\");\n+                    if !first {\n+                        p!(\">\");\n+                    }\n                 }\n-            }\n \n-            first = false;\n+                first = false;\n+                Ok(self_)\n+            })?;\n         }\n \n+        define_scoped_cx!(self);\n+\n         if !is_sized {\n-            p!(write(\"{}?Sized\", if first { \" \" } else { \" + \" }));\n+            p!(write(\"{}?Sized\", if first { \"\" } else { \" + \" }));\n         } else if first {\n-            p!(\" Sized\");\n+            p!(\"Sized\");\n         }\n \n         Ok(self)\n@@ -1869,7 +1889,7 @@ impl<'tcx> PrettyPrinter<'tcx> for FmtPrinter<'_, 'tcx> {\n         self.pretty_in_binder(value)\n     }\n \n-    fn wrap_binder<T, C: Fn(&T, Self) -> Result<Self, Self::Error>>(\n+    fn wrap_binder<T, C: FnOnce(&T, Self) -> Result<Self, Self::Error>>(\n         self,\n         value: &ty::Binder<'tcx, T>,\n         f: C,\n@@ -2256,7 +2276,7 @@ impl<'tcx> FmtPrinter<'_, 'tcx> {\n         Ok(inner)\n     }\n \n-    pub fn pretty_wrap_binder<T, C: Fn(&T, Self) -> Result<Self, fmt::Error>>(\n+    pub fn pretty_wrap_binder<T, C: FnOnce(&T, Self) -> Result<Self, fmt::Error>>(\n         self,\n         value: &ty::Binder<'tcx, T>,\n         f: C,"}, {"sha": "273b5dcdb098545f91f83bf01d7db6a47598fe66", "filename": "src/test/ui/impl-trait/printing-binder.rs", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/20cea3ebb468df74447ed3aa5e646f741208bea8/src%2Ftest%2Fui%2Fimpl-trait%2Fprinting-binder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/20cea3ebb468df74447ed3aa5e646f741208bea8/src%2Ftest%2Fui%2Fimpl-trait%2Fprinting-binder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fprinting-binder.rs?ref=20cea3ebb468df74447ed3aa5e646f741208bea8", "patch": "@@ -0,0 +1,14 @@\n+trait Trait<'a> {}\n+impl<T> Trait<'_> for T {}\n+fn whatever() -> impl for<'a> Trait<'a> + for<'b> Trait<'b> {}\n+\n+fn whatever2() -> impl for<'c> Fn(&'c ()) {\n+    |_: &()| {}\n+}\n+\n+fn main() {\n+    let x: u32 = whatever();\n+    //~^ ERROR mismatched types\n+    let x2: u32 = whatever2();\n+    //~^ ERROR mismatched types\n+}"}, {"sha": "5ffec8af1028915defdee18a6ab16434e8ea1bc9", "filename": "src/test/ui/impl-trait/printing-binder.stderr", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/20cea3ebb468df74447ed3aa5e646f741208bea8/src%2Ftest%2Fui%2Fimpl-trait%2Fprinting-binder.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/20cea3ebb468df74447ed3aa5e646f741208bea8/src%2Ftest%2Fui%2Fimpl-trait%2Fprinting-binder.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fimpl-trait%2Fprinting-binder.stderr?ref=20cea3ebb468df74447ed3aa5e646f741208bea8", "patch": "@@ -0,0 +1,31 @@\n+error[E0308]: mismatched types\n+  --> $DIR/printing-binder.rs:10:18\n+   |\n+LL | fn whatever() -> impl for<'a> Trait<'a> + for<'b> Trait<'b> {}\n+   |                  ------------------------------------------ the found opaque type\n+...\n+LL |     let x: u32 = whatever();\n+   |            ---   ^^^^^^^^^^ expected `u32`, found opaque type\n+   |            |\n+   |            expected due to this\n+   |\n+   = note:     expected type `u32`\n+           found opaque type `impl for<'a> Trait<'a> + for<'b> Trait<'b>`\n+\n+error[E0308]: mismatched types\n+  --> $DIR/printing-binder.rs:12:19\n+   |\n+LL | fn whatever2() -> impl for<'c> Fn(&'c ()) {\n+   |                   ----------------------- the found opaque type\n+...\n+LL |     let x2: u32 = whatever2();\n+   |             ---   ^^^^^^^^^^^ expected `u32`, found opaque type\n+   |             |\n+   |             expected due to this\n+   |\n+   = note:     expected type `u32`\n+           found opaque type `impl for<'c> Fn(&'c ())`\n+\n+error: aborting due to 2 previous errors\n+\n+For more information about this error, try `rustc --explain E0308`."}]}