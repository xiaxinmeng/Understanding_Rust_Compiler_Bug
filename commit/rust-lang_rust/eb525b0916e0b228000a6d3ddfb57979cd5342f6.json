{"sha": "eb525b0916e0b228000a6d3ddfb57979cd5342f6", "node_id": "MDY6Q29tbWl0NzI0NzEyOmViNTI1YjA5MTZlMGIyMjgwMDBhNmQzZGRmYjU3OTc5Y2Q1MzQyZjY=", "commit": {"author": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2018-12-07T15:40:23Z"}, "committer": {"name": "Eduard-Mihai Burtescu", "email": "edy.burt@gmail.com", "date": "2019-03-15T07:26:13Z"}, "message": "rustc: tie the 'tcx between Print and PrintCx in ty::print.", "tree": {"sha": "3dc2f7d1212d853fe67ff218e7ecacbcf1759c6f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3dc2f7d1212d853fe67ff218e7ecacbcf1759c6f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eb525b0916e0b228000a6d3ddfb57979cd5342f6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eb525b0916e0b228000a6d3ddfb57979cd5342f6", "html_url": "https://github.com/rust-lang/rust/commit/eb525b0916e0b228000a6d3ddfb57979cd5342f6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eb525b0916e0b228000a6d3ddfb57979cd5342f6/comments", "author": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "committer": {"login": "eddyb", "id": 77424, "node_id": "MDQ6VXNlcjc3NDI0", "avatar_url": "https://avatars.githubusercontent.com/u/77424?v=4", "gravatar_id": "", "url": "https://api.github.com/users/eddyb", "html_url": "https://github.com/eddyb", "followers_url": "https://api.github.com/users/eddyb/followers", "following_url": "https://api.github.com/users/eddyb/following{/other_user}", "gists_url": "https://api.github.com/users/eddyb/gists{/gist_id}", "starred_url": "https://api.github.com/users/eddyb/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/eddyb/subscriptions", "organizations_url": "https://api.github.com/users/eddyb/orgs", "repos_url": "https://api.github.com/users/eddyb/repos", "events_url": "https://api.github.com/users/eddyb/events{/privacy}", "received_events_url": "https://api.github.com/users/eddyb/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3bad9f7b3d09a49277d5861733706f03dde1e7c5", "url": "https://api.github.com/repos/rust-lang/rust/commits/3bad9f7b3d09a49277d5861733706f03dde1e7c5", "html_url": "https://github.com/rust-lang/rust/commit/3bad9f7b3d09a49277d5861733706f03dde1e7c5"}], "stats": {"total": 209, "additions": 115, "deletions": 94}, "files": [{"sha": "5349e990a77613781b2916e30530251ba0f0218b", "filename": "src/librustc/infer/outlives/free_region_map.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb525b0916e0b228000a6d3ddfb57979cd5342f6/src%2Flibrustc%2Finfer%2Foutlives%2Ffree_region_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb525b0916e0b228000a6d3ddfb57979cd5342f6/src%2Flibrustc%2Finfer%2Foutlives%2Ffree_region_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Finfer%2Foutlives%2Ffree_region_map.rs?ref=eb525b0916e0b228000a6d3ddfb57979cd5342f6", "patch": "@@ -91,7 +91,7 @@ impl_stable_hash_for!(struct FreeRegionMap<'tcx> {\n impl<'a, 'tcx> Lift<'tcx> for FreeRegionMap<'a> {\n     type Lifted = FreeRegionMap<'tcx>;\n     fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<FreeRegionMap<'tcx>> {\n-        self.relation.maybe_map(|&fr| fr.lift_to_tcx(tcx))\n+        self.relation.maybe_map(|&fr| tcx.lift(&fr))\n                      .map(|relation| FreeRegionMap { relation })\n     }\n }"}, {"sha": "bff07de5bcf333a138f2809c6cd53693b8aea3d9", "filename": "src/librustc/mir/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb525b0916e0b228000a6d3ddfb57979cd5342f6/src%2Flibrustc%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb525b0916e0b228000a6d3ddfb57979cd5342f6/src%2Flibrustc%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmir%2Fmod.rs?ref=eb525b0916e0b228000a6d3ddfb57979cd5342f6", "patch": "@@ -2405,7 +2405,7 @@ impl<'tcx> Debug for Rvalue<'tcx> {\n                     AggregateKind::Adt(adt_def, variant, substs, _user_ty, _) => {\n                         let variant_def = &adt_def.variants[variant];\n \n-                        ppaux::parameterized(fmt, substs, variant_def.did, &[])?;\n+                        ppaux::parameterized(fmt, variant_def.did, substs)?;\n \n                         match variant_def.ctor_kind {\n                             CtorKind::Const => Ok(()),"}, {"sha": "0a49dea7ec1bce319d55da74f211767ddd19edd0", "filename": "src/librustc/ty/instance.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb525b0916e0b228000a6d3ddfb57979cd5342f6/src%2Flibrustc%2Fty%2Finstance.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb525b0916e0b228000a6d3ddfb57979cd5342f6/src%2Flibrustc%2Fty%2Finstance.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Finstance.rs?ref=eb525b0916e0b228000a6d3ddfb57979cd5342f6", "patch": "@@ -175,7 +175,7 @@ impl<'tcx> InstanceDef<'tcx> {\n \n impl<'tcx> fmt::Display for Instance<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        ppaux::parameterized(f, self.substs, self.def_id(), &[])?;\n+        ppaux::parameterized(f, self.def_id(), self.substs)?;\n         match self.def {\n             InstanceDef::Item(_) => Ok(()),\n             InstanceDef::VtableShim(_) => {"}, {"sha": "dbccd60f86b63d6b22ab44cdcee02fbe931f3d77", "filename": "src/librustc/ty/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eb525b0916e0b228000a6d3ddfb57979cd5342f6/src%2Flibrustc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb525b0916e0b228000a6d3ddfb57979cd5342f6/src%2Flibrustc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fmod.rs?ref=eb525b0916e0b228000a6d3ddfb57979cd5342f6", "patch": "@@ -1001,7 +1001,7 @@ impl<'a, 'gcx, 'tcx> Generics {\n }\n \n /// Bounds on generics.\n-#[derive(Clone, Default, HashStable)]\n+#[derive(Clone, Default, Debug, HashStable)]\n pub struct GenericPredicates<'tcx> {\n     pub parent: Option<DefId>,\n     pub predicates: Vec<(Predicate<'tcx>, Span)>,\n@@ -1506,7 +1506,7 @@ impl<'tcx> Predicate<'tcx> {\n /// `[[], [U:Bar<T>]]`. Now if there were some particular reference\n /// like `Foo<isize,usize>`, then the `InstantiatedPredicates` would be `[[],\n /// [usize:Bar<isize>]]`.\n-#[derive(Clone)]\n+#[derive(Clone, Debug)]\n pub struct InstantiatedPredicates<'tcx> {\n     pub predicates: Vec<Predicate<'tcx>>,\n }"}, {"sha": "a9fffa2ee87b1ca08a77e6fada06412d5971b7a3", "filename": "src/librustc/ty/print.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/eb525b0916e0b228000a6d3ddfb57979cd5342f6/src%2Flibrustc%2Fty%2Fprint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb525b0916e0b228000a6d3ddfb57979cd5342f6/src%2Flibrustc%2Fty%2Fprint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fprint.rs?ref=eb525b0916e0b228000a6d3ddfb57979cd5342f6", "patch": "@@ -56,32 +56,36 @@ impl PrintCx<'a, 'gcx, 'tcx> {\n }\n \n pub trait Print<'tcx> {\n-    fn print<F: fmt::Write>(&self, f: &mut F, cx: &mut PrintCx<'_, '_, '_>) -> fmt::Result;\n-    fn print_to_string(&self, cx: &mut PrintCx<'_, '_, '_>) -> String {\n+    fn print<F: fmt::Write>(&self, f: &mut F, cx: &mut PrintCx<'_, '_, 'tcx>) -> fmt::Result;\n+    fn print_to_string(&self, cx: &mut PrintCx<'_, '_, 'tcx>) -> String {\n         let mut result = String::new();\n         let _ = self.print(&mut result, cx);\n         result\n     }\n-    fn print_display<F: fmt::Write>(&self, f: &mut F, cx: &mut PrintCx<'_, '_, '_>) -> fmt::Result {\n+    fn print_display<F: fmt::Write>(\n+        &self,\n+        f: &mut F,\n+        cx: &mut PrintCx<'_, '_, 'tcx>,\n+    ) -> fmt::Result {\n         let old_debug = cx.is_debug;\n         cx.is_debug = false;\n         let result = self.print(f, cx);\n         cx.is_debug = old_debug;\n         result\n     }\n-    fn print_display_to_string(&self, cx: &mut PrintCx<'_, '_, '_>) -> String {\n+    fn print_display_to_string(&self, cx: &mut PrintCx<'_, '_, 'tcx>) -> String {\n         let mut result = String::new();\n         let _ = self.print_display(&mut result, cx);\n         result\n     }\n-    fn print_debug<F: fmt::Write>(&self, f: &mut F, cx: &mut PrintCx<'_, '_, '_>) -> fmt::Result {\n+    fn print_debug<F: fmt::Write>(&self, f: &mut F, cx: &mut PrintCx<'_, '_, 'tcx>) -> fmt::Result {\n         let old_debug = cx.is_debug;\n         cx.is_debug = true;\n         let result = self.print(f, cx);\n         cx.is_debug = old_debug;\n         result\n     }\n-    fn print_debug_to_string(&self, cx: &mut PrintCx<'_, '_, '_>) -> String {\n+    fn print_debug_to_string(&self, cx: &mut PrintCx<'_, '_, 'tcx>) -> String {\n         let mut result = String::new();\n         let _ = self.print_debug(&mut result, cx);\n         result"}, {"sha": "a19eb1d9545a23e8a2e2eb0a8d1fec9a4770e0ae", "filename": "src/librustc/ty/structural_impls.rs", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/eb525b0916e0b228000a6d3ddfb57979cd5342f6/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb525b0916e0b228000a6d3ddfb57979cd5342f6/src%2Flibrustc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fstructural_impls.rs?ref=eb525b0916e0b228000a6d3ddfb57979cd5342f6", "patch": "@@ -48,7 +48,10 @@ CloneTypeFoldableAndLiftImpls! {\n     // really meant to be folded. In general, we can only fold a fully\n     // general `Region`.\n     crate::ty::BoundRegion,\n+    crate::ty::Placeholder<crate::ty::BoundRegion>,\n     crate::ty::ClosureKind,\n+    crate::ty::FreeRegion,\n+    crate::ty::InferTy,\n     crate::ty::IntVarValue,\n     crate::ty::ParamConst,\n     crate::ty::ParamTy,\n@@ -480,6 +483,13 @@ impl<'a, 'tcx> Lift<'tcx> for ty::InstanceDef<'a> {\n     }\n }\n \n+BraceStructLiftImpl! {\n+    impl<'a, 'tcx> Lift<'tcx> for ty::TypeAndMut<'a> {\n+        type Lifted = ty::TypeAndMut<'tcx>;\n+        ty, mutbl\n+    }\n+}\n+\n BraceStructLiftImpl! {\n     impl<'a, 'tcx> Lift<'tcx> for ty::Instance<'a> {\n         type Lifted = ty::Instance<'tcx>;\n@@ -494,6 +504,28 @@ BraceStructLiftImpl! {\n     }\n }\n \n+// FIXME(eddyb) this is like what some of the macros above generate,\n+// except that macros *also* generate a foldable impl, which we don't\n+// want (with it we'd risk bypassing `fold_region` / `fold_const`).\n+impl<'tcx> Lift<'tcx> for ty::RegionKind {\n+    type Lifted = ty::RegionKind;\n+    fn lift_to_tcx<'b, 'gcx>(&self, _: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        Some(self.clone())\n+    }\n+}\n+\n+impl<'a, 'tcx> Lift<'tcx> for ty::LazyConst<'a> {\n+    type Lifted = ty::LazyConst<'tcx>;\n+    fn lift_to_tcx<'b, 'gcx>(&self, tcx: TyCtxt<'b, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n+        match self {\n+            ty::LazyConst::Evaluated(v) => Some(ty::LazyConst::Evaluated(tcx.lift(v)?)),\n+            ty::LazyConst::Unevaluated(def_id, substs) => {\n+                Some(ty::LazyConst::Unevaluated(*def_id, tcx.lift(substs)?))\n+            }\n+        }\n+    }\n+}\n+\n BraceStructLiftImpl! {\n     impl<'a, 'tcx> Lift<'tcx> for ty::Const<'a> {\n         type Lifted = ty::Const<'tcx>;"}, {"sha": "0e4b43155d9c205e3ed156f64d66021f82c938a4", "filename": "src/librustc/ty/sty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/eb525b0916e0b228000a6d3ddfb57979cd5342f6/src%2Flibrustc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb525b0916e0b228000a6d3ddfb57979cd5342f6/src%2Flibrustc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsty.rs?ref=eb525b0916e0b228000a6d3ddfb57979cd5342f6", "patch": "@@ -616,7 +616,7 @@ impl<'tcx> List<ExistentialPredicate<'tcx>> {\n \n     #[inline]\n     pub fn projection_bounds<'a>(&'a self) ->\n-        impl Iterator<Item=ExistentialProjection<'tcx>> + 'a {\n+        impl Iterator<Item=ExistentialProjection<'tcx>> + Clone + 'a {\n         self.iter().filter_map(|predicate| {\n             match *predicate {\n                 ExistentialPredicate::Projection(p) => Some(p),"}, {"sha": "85a05bb9f558586d746d9012d43ade2cc7a63428", "filename": "src/librustc/ty/subst.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eb525b0916e0b228000a6d3ddfb57979cd5342f6/src%2Flibrustc%2Fty%2Fsubst.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb525b0916e0b228000a6d3ddfb57979cd5342f6/src%2Flibrustc%2Fty%2Fsubst.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fsubst.rs?ref=eb525b0916e0b228000a6d3ddfb57979cd5342f6", "patch": "@@ -140,9 +140,9 @@ impl<'a, 'tcx> Lift<'tcx> for Kind<'a> {\n \n     fn lift_to_tcx<'cx, 'gcx>(&self, tcx: TyCtxt<'cx, 'gcx, 'tcx>) -> Option<Self::Lifted> {\n         match self.unpack() {\n-            UnpackedKind::Lifetime(lt) => lt.lift_to_tcx(tcx).map(|lt| lt.into()),\n-            UnpackedKind::Type(ty) => ty.lift_to_tcx(tcx).map(|ty| ty.into()),\n-            UnpackedKind::Const(ct) => ct.lift_to_tcx(tcx).map(|ct| ct.into()),\n+            UnpackedKind::Lifetime(lt) => tcx.lift(&lt).map(|lt| lt.into()),\n+            UnpackedKind::Type(ty) => tcx.lift(&ty).map(|ty| ty.into()),\n+            UnpackedKind::Const(ct) => tcx.lift(&ct).map(|ct| ct.into()),\n         }\n     }\n }"}, {"sha": "b56ce0665e9e94df84de56c6936264ac235887f4", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 62, "deletions": 77, "changes": 139, "blob_url": "https://github.com/rust-lang/rust/blob/eb525b0916e0b228000a6d3ddfb57979cd5342f6/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb525b0916e0b228000a6d3ddfb57979cd5342f6/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=eb525b0916e0b228000a6d3ddfb57979cd5342f6", "patch": "@@ -14,6 +14,7 @@ use crate::mir::interpret::ConstValue;\n \n use std::cell::Cell;\n use std::fmt;\n+use std::iter;\n use std::usize;\n \n use rustc_target::spec::abi::Abi;\n@@ -182,7 +183,9 @@ impl RegionHighlightMode {\n macro_rules! gen_display_debug_body {\n     ( $with:path ) => {\n         fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-            PrintCx::with(|mut cx| $with(self, f, &mut cx))\n+            PrintCx::with(|mut cx| {\n+                $with(&cx.tcx.lift(self).expect(\"could not lift for printing\"), f, &mut cx)\n+            })\n         }\n     };\n }\n@@ -215,7 +218,7 @@ macro_rules! gen_print_impl {\n             fn print<F: fmt::Write>(\n                 &$self,\n                 $f: &mut F,\n-                $cx: &mut PrintCx<'_, '_, '_>,\n+                $cx: &mut PrintCx<'_, '_, 'tcx>,\n             ) -> fmt::Result {\n                 if $cx.is_debug $dbg\n                 else $disp\n@@ -227,7 +230,7 @@ macro_rules! gen_print_impl {\n             fn print<F: fmt::Write>(\n                 &$self,\n                 $f: &mut F,\n-                $cx: &mut PrintCx<'_, '_, '_>,\n+                $cx: &mut PrintCx<'_, '_, 'tcx>,\n             ) -> fmt::Result {\n                 if $cx.is_debug $dbg\n                 else $disp\n@@ -285,9 +288,9 @@ macro_rules! print {\n impl PrintCx<'a, 'gcx, 'tcx> {\n     fn fn_sig<F: fmt::Write>(&mut self,\n                              f: &mut F,\n-                             inputs: &[Ty<'_>],\n+                             inputs: &[Ty<'tcx>],\n                              c_variadic: bool,\n-                             output: Ty<'_>)\n+                             output: Ty<'tcx>)\n                              -> fmt::Result {\n         write!(f, \"(\")?;\n         let mut inputs = inputs.iter();\n@@ -308,12 +311,13 @@ impl PrintCx<'a, 'gcx, 'tcx> {\n         Ok(())\n     }\n \n-    fn parameterized<F: fmt::Write>(&mut self,\n-                                    f: &mut F,\n-                                    substs: SubstsRef<'_>,\n-                                    did: DefId,\n-                                    projections: &[ty::ProjectionPredicate<'_>])\n-                                    -> fmt::Result {\n+    fn parameterized<F: fmt::Write>(\n+        &mut self,\n+        f: &mut F,\n+        did: DefId,\n+        substs: SubstsRef<'tcx>,\n+        projections: impl Iterator<Item = ty::ExistentialProjection<'tcx>> + Clone,\n+    ) -> fmt::Result {\n         let key = self.tcx.def_key(did);\n \n         let verbose = self.is_verbose;\n@@ -411,7 +415,6 @@ impl PrintCx<'a, 'gcx, 'tcx> {\n                     *has_default.unwrap_or(&false)\n                 };\n                 if has_default {\n-                    let substs = self.tcx.lift(&substs).expect(\"could not lift for printing\");\n                     let types = substs.types().rev().skip(child_types);\n                     for ((def_id, has_default), actual) in type_params.zip(types) {\n                         if !has_default {\n@@ -428,10 +431,12 @@ impl PrintCx<'a, 'gcx, 'tcx> {\n         print!(f, self, write(\"{}\", self.tcx.item_path_str(path_def_id)))?;\n         let fn_trait_kind = self.tcx.lang_items().fn_trait_kind(path_def_id);\n \n-        if !verbose && fn_trait_kind.is_some() && projections.len() == 1 {\n-            let projection_ty = projections[0].ty;\n+        if !verbose && fn_trait_kind.is_some() {\n             if let Tuple(ref args) = substs.type_at(1).sty {\n-                return self.fn_sig(f, args, false, projection_ty);\n+                let mut projections = projections.clone();\n+                if let (Some(proj), None) = (projections.next(), projections.next()) {\n+                    return self.fn_sig(f, args, false, proj.ty);\n+                }\n             }\n         }\n \n@@ -490,7 +495,7 @@ impl PrintCx<'a, 'gcx, 'tcx> {\n             start_or_continue(f, \"<\", \", \")?;\n             print!(f, self,\n                     write(\"{}=\",\n-                            self.tcx.associated_item(projection.projection_ty.item_def_id).ident),\n+                            self.tcx.associated_item(projection.item_def_id).ident),\n                     print_display(projection.ty))?;\n         }\n \n@@ -530,7 +535,7 @@ impl PrintCx<'a, 'gcx, 'tcx> {\n         Ok(())\n     }\n \n-    fn in_binder<T, F>(&mut self, f: &mut F, value: ty::Binder<T>) -> fmt::Result\n+    fn in_binder<T, F>(&mut self, f: &mut F, value: &ty::Binder<T>) -> fmt::Result\n         where T: Print<'tcx> + TypeFoldable<'tcx>, F: fmt::Write\n     {\n         fn name_by_region_index(index: usize) -> InternedString {\n@@ -547,7 +552,7 @@ impl PrintCx<'a, 'gcx, 'tcx> {\n         // the output. We'll probably want to tweak this over time to\n         // decide just how much information to give.\n         if self.binder_depth == 0 {\n-            self.prepare_late_bound_region_info(&value);\n+            self.prepare_late_bound_region_info(value);\n         }\n \n         let mut empty = true;\n@@ -562,7 +567,7 @@ impl PrintCx<'a, 'gcx, 'tcx> {\n \n         let old_region_index = self.region_index;\n         let mut region_index = old_region_index;\n-        let new_value = self.tcx.replace_late_bound_regions(&value, |br| {\n+        let new_value = self.tcx.replace_late_bound_regions(value, |br| {\n             let _ = start_or_continue(f, \"for<\", \", \");\n             let br = match br {\n                 ty::BrNamed(_, name) => {\n@@ -604,16 +609,15 @@ impl PrintCx<'a, 'gcx, 'tcx> {\n     }\n }\n \n-pub fn parameterized<F: fmt::Write>(f: &mut F,\n-                                    substs: SubstsRef<'_>,\n-                                    did: DefId,\n-                                    projections: &[ty::ProjectionPredicate<'_>])\n-                                    -> fmt::Result {\n-    PrintCx::with(|mut cx| cx.parameterized(f, substs, did, projections))\n+pub fn parameterized<F: fmt::Write>(f: &mut F, did: DefId, substs: SubstsRef<'_>) -> fmt::Result {\n+    PrintCx::with(|mut cx| {\n+        let substs = cx.tcx.lift(&substs).expect(\"could not lift for printing\");\n+        cx.parameterized(f, did, substs, iter::empty())\n+    })\n }\n \n impl<'a, 'tcx, T: Print<'tcx>> Print<'tcx> for &'a T {\n-    fn print<F: fmt::Write>(&self, f: &mut F, cx: &mut PrintCx<'_, '_, '_>) -> fmt::Result {\n+    fn print<F: fmt::Write>(&self, f: &mut F, cx: &mut PrintCx<'_, '_, 'tcx>) -> fmt::Result {\n         (*self).print(f, cx)\n     }\n }\n@@ -628,16 +632,13 @@ define_print! {\n             let mut first = true;\n \n             if let Some(principal) = self.principal() {\n-                let principal = cx.tcx\n-                    .lift(&principal)\n-                    .expect(\"could not lift for printing\")\n-                    .with_self_ty(cx.tcx, dummy_self);\n-                let projections = self.projection_bounds().map(|p| {\n-                    cx.tcx.lift(&p)\n-                        .expect(\"could not lift for printing\")\n-                        .with_self_ty(cx.tcx, dummy_self)\n-                }).collect::<Vec<_>>();\n-                cx.parameterized(f, principal.substs, principal.def_id, &projections)?;\n+                let principal = principal.with_self_ty(cx.tcx, dummy_self);\n+                cx.parameterized(\n+                    f,\n+                    principal.def_id,\n+                    principal.substs,\n+                    self.projection_bounds(),\n+                )?;\n                 first = false;\n             }\n \n@@ -755,15 +756,15 @@ define_print! {\n define_print! {\n     ('tcx) ty::ExistentialTraitRef<'tcx>, (self, f, cx) {\n         display {\n-            cx.parameterized(f, self.substs, self.def_id, &[])\n-        }\n-        debug {\n             let dummy_self = cx.tcx.mk_infer(ty::FreshTy(0));\n \n-            let trait_ref = *cx.tcx.lift(&ty::Binder::bind(*self))\n-                                .expect(\"could not lift for printing\")\n-                                .with_self_ty(cx.tcx, dummy_self).skip_binder();\n-            cx.parameterized(f, trait_ref.substs, trait_ref.def_id, &[])\n+            let trait_ref = *ty::Binder::bind(*self)\n+                .with_self_ty(cx.tcx, dummy_self)\n+                .skip_binder();\n+            cx.parameterized(f, trait_ref.def_id, trait_ref.substs, iter::empty())\n+        }\n+        debug {\n+            self.print_display(f, cx)\n         }\n     }\n }\n@@ -957,22 +958,6 @@ define_print! {\n     }\n }\n \n-define_print! {\n-    ('tcx) ty::GenericPredicates<'tcx>, (self, f, cx) {\n-        debug {\n-            write!(f, \"GenericPredicates({:?})\", self.predicates)\n-        }\n-    }\n-}\n-\n-define_print! {\n-    ('tcx) ty::InstantiatedPredicates<'tcx>, (self, f, cx) {\n-        debug {\n-            write!(f, \"InstantiatedPredicates({:?})\", self.predicates)\n-        }\n-    }\n-}\n-\n define_print! {\n     ('tcx) ty::FnSig<'tcx>, (self, f, cx) {\n         display {\n@@ -1098,16 +1083,15 @@ define_print_multi! {\n     ]\n     (self, f, cx) {\n         display {\n-            cx.in_binder(f, cx.tcx.lift(self)\n-                .expect(\"could not lift for printing\"))\n+            cx.in_binder(f, self)\n         }\n     }\n }\n \n define_print! {\n     ('tcx) ty::TraitRef<'tcx>, (self, f, cx) {\n         display {\n-            cx.parameterized(f, self.substs, self.def_id, &[])\n+            cx.parameterized(f, self.def_id, self.substs, iter::empty())\n         }\n         debug {\n             // when printing out the debug representation, we don't need\n@@ -1117,7 +1101,7 @@ define_print! {\n                    write(\"<\"),\n                    print(self.self_ty()),\n                    write(\" as \"))?;\n-            cx.parameterized(f, self.substs, self.def_id, &[])?;\n+            cx.parameterized(f, self.def_id, self.substs, iter::empty())?;\n             write!(f, \">\")\n         }\n     }\n@@ -1166,11 +1150,9 @@ define_print! {\n                     write!(f, \")\")\n                 }\n                 FnDef(def_id, substs) => {\n-                    let substs = cx.tcx.lift(&substs)\n-                        .expect(\"could not lift for printing\");\n                     let sig = cx.tcx.fn_sig(def_id).subst(cx.tcx, substs);\n                     print!(f, cx, print(sig), write(\" {{\"))?;\n-                    cx.parameterized(f, substs, def_id, &[])?;\n+                    cx.parameterized(f, def_id, substs, iter::empty())?;\n                     write!(f, \"}}\")\n                 }\n                 FnPtr(ref bare_fn) => {\n@@ -1192,7 +1174,7 @@ define_print! {\n                         ty::BoundTyKind::Param(p) => write!(f, \"{}\", p),\n                     }\n                 }\n-                Adt(def, substs) => cx.parameterized(f, substs, def.did, &[]),\n+                Adt(def, substs) => cx.parameterized(f, def.did, substs, iter::empty()),\n                 Dynamic(data, r) => {\n                     let r = r.print_to_string(cx);\n                     if !r.is_empty() {\n@@ -1206,7 +1188,9 @@ define_print! {\n                         Ok(())\n                     }\n                 }\n-                Foreign(def_id) => parameterized(f, subst::InternalSubsts::empty(), def_id, &[]),\n+                Foreign(def_id) => {\n+                    cx.parameterized(f, def_id, subst::InternalSubsts::empty(), iter::empty())\n+                }\n                 Projection(ref data) => data.print(f, cx),\n                 UnnormalizedProjection(ref data) => {\n                     write!(f, \"Unnormalized(\")?;\n@@ -1237,8 +1221,6 @@ define_print! {\n                     }\n                     // Grab the \"TraitA + TraitB\" from `impl TraitA + TraitB`,\n                     // by looking up the projections associated with the def_id.\n-                    let substs = cx.tcx.lift(&substs)\n-                        .expect(\"could not lift for printing\");\n                     let bounds = cx.tcx.predicates_of(def_id).instantiate(cx.tcx, substs);\n \n                     let mut first = true;\n@@ -1305,8 +1287,7 @@ define_print! {\n                     print!(f, cx, write(\" \"), print(witness), write(\"]\"))\n                 },\n                 GeneratorWitness(types) => {\n-                    cx.in_binder(f, cx.tcx.lift(&types)\n-                        .expect(\"could not lift for printing\"))\n+                    cx.in_binder(f, &types)\n                 }\n                 Closure(did, substs) => {\n                     let upvar_tys = substs.upvar_tys(did, cx.tcx);\n@@ -1347,8 +1328,8 @@ define_print! {\n                         write!(\n                             f,\n                             \" closure_kind_ty={:?} closure_sig_ty={:?}\",\n-                            substs.closure_kind_ty(did, tcx),\n-                            substs.closure_sig_ty(did, tcx),\n+                            substs.closure_kind_ty(did, cx.tcx),\n+                            substs.closure_sig_ty(did, cx.tcx),\n                         )?;\n                     }\n \n@@ -1435,8 +1416,12 @@ define_print! {\n     }\n }\n \n-define_print! {\n-    ('tcx, T: Print<'tcx> + fmt::Debug, U: Print<'tcx> + fmt::Debug) ty::OutlivesPredicate<T, U>,\n+// Similar problem to `Binder<T>`, can't define a generic impl.\n+define_print_multi! {\n+    [\n+    ('tcx) ty::OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>,\n+    ('tcx) ty::OutlivesPredicate<ty::Region<'tcx>, ty::Region<'tcx>>\n+    ]\n     (self, f, cx) {\n         display {\n             print!(f, cx, print(self.0), write(\" : \"), print(self.1))\n@@ -1524,7 +1509,7 @@ define_print! {\n                 }\n                 ty::Predicate::ConstEvaluatable(def_id, substs) => {\n                     write!(f, \"the constant `\")?;\n-                    cx.parameterized(f, substs, def_id, &[])?;\n+                    cx.parameterized(f, def_id, substs, iter::empty())?;\n                     write!(f, \"` can be evaluated\")\n                 }\n             }"}, {"sha": "ceb08f943678b15a97aa5273effc4741dd962229", "filename": "src/librustc_codegen_llvm/intrinsic.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/eb525b0916e0b228000a6d3ddfb57979cd5342f6/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb525b0916e0b228000a6d3ddfb57979cd5342f6/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_codegen_llvm%2Fintrinsic.rs?ref=eb525b0916e0b228000a6d3ddfb57979cd5342f6", "patch": "@@ -1903,7 +1903,7 @@ unsupported {} from `{}` with element `{}` of size `{}` to `{}`\"#,\n                 return_error!(\n                     \"expected element type `{}` of vector type `{}` \\\n                      to be a signed or unsigned integer type\",\n-                    arg_tys[0].simd_type(tcx).sty, arg_tys[0]\n+                    arg_tys[0].simd_type(tcx), arg_tys[0]\n                 );\n             }\n         };\n@@ -1955,7 +1955,7 @@ fn int_type_width_signed(ty: Ty<'_>, cx: &CodegenCx<'_, '_>) -> Option<(u64, boo\n \n // Returns the width of a float Ty\n // Returns None if the type is not a float\n-fn float_type_width(ty: Ty) -> Option<u64> {\n+fn float_type_width(ty: Ty<'_>) -> Option<u64> {\n     match ty.sty {\n         ty::Float(t) => Some(t.bit_width() as u64),\n         _ => None,"}]}