{"sha": "0271224bdae26260ab498f47323997f9edb5879e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjAyNzEyMjRiZGFlMjYyNjBhYjQ5OGY0NzMyMzk5N2Y5ZWRiNTg3OWU=", "commit": {"author": {"name": "Jakub Wieczorek", "email": "jakub@jakub.cc", "date": "2014-06-05T22:00:29Z"}, "committer": {"name": "Jakub Wieczorek", "email": "jakub@jakub.cc", "date": "2014-06-08T11:30:04Z"}, "message": "Add detection of dead struct fields", "tree": {"sha": "4b2b91ede68b072dcafa37b0fb2a338b1e6b0483", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4b2b91ede68b072dcafa37b0fb2a338b1e6b0483"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/0271224bdae26260ab498f47323997f9edb5879e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/0271224bdae26260ab498f47323997f9edb5879e", "html_url": "https://github.com/rust-lang/rust/commit/0271224bdae26260ab498f47323997f9edb5879e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/0271224bdae26260ab498f47323997f9edb5879e/comments", "author": null, "committer": null, "parents": [{"sha": "7580ef902eaaf402219b47c3f92019c0644086db", "url": "https://api.github.com/repos/rust-lang/rust/commits/7580ef902eaaf402219b47c3f92019c0644086db", "html_url": "https://github.com/rust-lang/rust/commit/7580ef902eaaf402219b47c3f92019c0644086db"}], "stats": {"total": 157, "additions": 155, "deletions": 2}, "files": [{"sha": "46899ae19ca095f84bed03c2c85fe211cca8f2de", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 79, "deletions": 2, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/0271224bdae26260ab498f47323997f9edb5879e/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0271224bdae26260ab498f47323997f9edb5879e/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=0271224bdae26260ab498f47323997f9edb5879e", "patch": "@@ -124,6 +124,32 @@ impl<'a> MarkSymbolVisitor<'a> {\n         }\n     }\n \n+    fn handle_field_access(&mut self, lhs: &ast::Expr, name: &ast::Ident) {\n+        match ty::get(ty::expr_ty_adjusted(self.tcx, lhs)).sty {\n+            ty::ty_struct(id, _) => {\n+                let fields = ty::lookup_struct_fields(self.tcx, id);\n+                let field_id = fields.iter()\n+                    .find(|field| field.name == name.name).unwrap().id;\n+                self.live_symbols.insert(field_id.node);\n+            },\n+            _ => ()\n+        }\n+    }\n+\n+    fn handle_field_pattern_match(&mut self, lhs: &ast::Pat, pats: &[ast::FieldPat]) {\n+        match self.tcx.def_map.borrow().get(&lhs.id) {\n+            &def::DefStruct(id) | &def::DefVariant(_, id, _) => {\n+                let fields = ty::lookup_struct_fields(self.tcx, id);\n+                for pat in pats.iter() {\n+                    let field_id = fields.iter()\n+                        .find(|field| field.name == pat.ident.name).unwrap().id;\n+                    self.live_symbols.insert(field_id.node);\n+                }\n+            }\n+            _ => ()\n+        }\n+    }\n+\n     fn mark_live_symbols(&mut self) {\n         let mut scanned = HashSet::new();\n         while self.worklist.len() > 0 {\n@@ -147,10 +173,22 @@ impl<'a> MarkSymbolVisitor<'a> {\n         match *node {\n             ast_map::NodeItem(item) => {\n                 match item.node {\n+                    ast::ItemStruct(struct_def, _) => {\n+                        let has_extern_repr = item.attrs.iter().fold(attr::ReprAny, |acc, attr| {\n+                            attr::find_repr_attr(self.tcx.sess.diagnostic(), attr, acc)\n+                        }) == attr::ReprExtern;\n+                        let live_fields = struct_def.fields.iter().filter(|f| {\n+                            has_extern_repr || match f.node.kind {\n+                                ast::NamedField(_, ast::Public) => true,\n+                                _ => false\n+                            }\n+                        });\n+                        self.live_symbols.extend(live_fields.map(|f| f.node.id));\n+                        visit::walk_item(self, item, ());\n+                    }\n                     ast::ItemFn(..)\n                     | ast::ItemTy(..)\n                     | ast::ItemEnum(..)\n-                    | ast::ItemStruct(..)\n                     | ast::ItemStatic(..) => {\n                         visit::walk_item(self, item, ());\n                     }\n@@ -178,18 +216,32 @@ impl<'a> Visitor<()> for MarkSymbolVisitor<'a> {\n             ast::ExprMethodCall(..) => {\n                 self.lookup_and_handle_method(expr.id, expr.span);\n             }\n+            ast::ExprField(ref lhs, ref ident, _) => {\n+                self.handle_field_access(*lhs, ident);\n+            }\n             _ => ()\n         }\n \n         visit::walk_expr(self, expr, ())\n     }\n \n+    fn visit_pat(&mut self, pat: &ast::Pat, _: ()) {\n+        match pat.node {\n+            ast::PatStruct(_, ref fields, _) => {\n+                self.handle_field_pattern_match(pat, fields.as_slice());\n+            }\n+            _ => ()\n+        }\n+\n+        visit::walk_pat(self, pat, ())\n+    }\n+\n     fn visit_path(&mut self, path: &ast::Path, id: ast::NodeId, _: ()) {\n         self.lookup_and_handle_definition(&id);\n         visit::walk_path(self, path, ());\n     }\n \n-    fn visit_item(&mut self, _item: &ast::Item, _: ()) {\n+    fn visit_item(&mut self, _: &ast::Item, _: ()) {\n         // Do not recurse into items. These items will be added to the\n         // worklist and recursed into manually if necessary.\n     }\n@@ -317,6 +369,23 @@ struct DeadVisitor<'a> {\n }\n \n impl<'a> DeadVisitor<'a> {\n+    fn should_warn_about_field(&mut self, node: &ast::StructField_) -> bool {\n+        let (is_named, has_leading_underscore) = match node.ident() {\n+            Some(ref ident) => (true, token::get_ident(*ident).get()[0] == ('_' as u8)),\n+            _ => (false, false)\n+        };\n+        let field_type = ty::node_id_to_type(self.tcx, node.id);\n+        let is_marker_field = match ty::ty_to_def_id(field_type) {\n+            Some(def_id) => self.tcx.lang_items.items().any(|(_, item)| *item == Some(def_id)),\n+            _ => false\n+        };\n+        is_named\n+            && !self.symbol_is_live(node.id, None)\n+            && !has_leading_underscore\n+            && !is_marker_field\n+            && !has_allow_dead_code_or_lang_attr(node.attrs.as_slice())\n+    }\n+\n     // id := node id of an item's definition.\n     // ctor_id := `Some` if the item is a struct_ctor (tuple struct),\n     //            `None` otherwise.\n@@ -399,6 +468,14 @@ impl<'a> Visitor<()> for DeadVisitor<'a> {\n         visit::walk_block(self, block, ());\n     }\n \n+    fn visit_struct_field(&mut self, field: &ast::StructField, _: ()) {\n+        if self.should_warn_about_field(&field.node) {\n+            self.warn_dead_code(field.node.id, field.span, field.node.ident().unwrap());\n+        }\n+\n+        visit::walk_struct_field(self, field, ());\n+    }\n+\n     // Overwrite so that we don't warn the trait method itself.\n     fn visit_trait_method(&mut self, trait_method: &ast::TraitMethod, _: ()) {\n         match *trait_method {"}, {"sha": "e18484a68f3a87b34e319ae4b9651d8747dac082", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/0271224bdae26260ab498f47323997f9edb5879e/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0271224bdae26260ab498f47323997f9edb5879e/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=0271224bdae26260ab498f47323997f9edb5879e", "patch": "@@ -1046,6 +1046,15 @@ pub struct StructField_ {\n     pub attrs: Vec<Attribute>,\n }\n \n+impl StructField_ {\n+    pub fn ident(&self) -> Option<Ident> {\n+        match self.kind {\n+            NamedField(ref ident, _) => Some(ident.clone()),\n+            UnnamedField(_) => None\n+        }\n+    }\n+}\n+\n pub type StructField = Spanned<StructField_>;\n \n #[deriving(Clone, PartialEq, Eq, Encodable, Decodable, Hash)]"}, {"sha": "718af1841b6232fa4ad188a502fabc2c6c64dd5c", "filename": "src/test/compile-fail/lint-dead-code-4.rs", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/rust-lang/rust/blob/0271224bdae26260ab498f47323997f9edb5879e/src%2Ftest%2Fcompile-fail%2Flint-dead-code-4.rs", "raw_url": "https://github.com/rust-lang/rust/raw/0271224bdae26260ab498f47323997f9edb5879e/src%2Ftest%2Fcompile-fail%2Flint-dead-code-4.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flint-dead-code-4.rs?ref=0271224bdae26260ab498f47323997f9edb5879e", "patch": "@@ -0,0 +1,67 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![feature(struct_variant)]\n+#![allow(unused_variable)]\n+#![allow(non_camel_case_types)]\n+#![deny(dead_code)]\n+\n+extern crate libc;\n+\n+use std::num;\n+\n+struct Foo {\n+    x: uint,\n+    b: bool, //~ ERROR: code is never used\n+    marker: std::kinds::marker::NoCopy\n+}\n+\n+fn field_read(f: Foo) -> uint {\n+    num::pow(f.x, 2)\n+}\n+\n+enum XYZ {\n+    X,\n+    Y {\n+        a: String,\n+        b: int //~ ERROR: code is never used\n+    },\n+    Z\n+}\n+\n+fn field_match_in_patterns(b: XYZ) -> String {\n+    match b {\n+        Y { a: a, .. } => a,\n+        _ => \"\".to_string()\n+    }\n+}\n+\n+struct Bar {\n+    x: uint, //~ ERROR: code is never used\n+    b: bool,\n+    _guard: ()\n+}\n+\n+#[repr(C)]\n+struct Baz {\n+    x: libc::c_uint\n+}\n+\n+fn field_match_in_let(f: Bar) -> bool {\n+    let Bar { b, .. } = f;\n+    b\n+}\n+\n+fn main() {\n+    field_read(Foo { x: 1, b: false, marker: std::kinds::marker::NoCopy });\n+    field_match_in_patterns(Z);\n+    field_match_in_let(Bar { x: 42u, b: true, _guard: () });\n+    let _ = Baz { x: 0 };\n+}"}]}