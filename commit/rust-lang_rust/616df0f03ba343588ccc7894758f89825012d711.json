{"sha": "616df0f03ba343588ccc7894758f89825012d711", "node_id": "C_kwDOAAsO6NoAKDYxNmRmMGYwM2JhMzQzNTg4Y2NjNzg5NDc1OGY4OTgyNTAxMmQ3MTE", "commit": {"author": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2022-11-22T09:42:01Z"}, "committer": {"name": "Maybe Waffle", "email": "waffle.lapkin@gmail.com", "date": "2022-11-22T18:49:16Z"}, "message": "`rustc_parse`: remove `ref` patterns", "tree": {"sha": "8a44a8801287ffc2664c01853c83009e76f4083c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8a44a8801287ffc2664c01853c83009e76f4083c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/616df0f03ba343588ccc7894758f89825012d711", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/616df0f03ba343588ccc7894758f89825012d711", "html_url": "https://github.com/rust-lang/rust/commit/616df0f03ba343588ccc7894758f89825012d711", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/616df0f03ba343588ccc7894758f89825012d711/comments", "author": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "WaffleLapkin", "id": 38225716, "node_id": "MDQ6VXNlcjM4MjI1NzE2", "avatar_url": "https://avatars.githubusercontent.com/u/38225716?v=4", "gravatar_id": "", "url": "https://api.github.com/users/WaffleLapkin", "html_url": "https://github.com/WaffleLapkin", "followers_url": "https://api.github.com/users/WaffleLapkin/followers", "following_url": "https://api.github.com/users/WaffleLapkin/following{/other_user}", "gists_url": "https://api.github.com/users/WaffleLapkin/gists{/gist_id}", "starred_url": "https://api.github.com/users/WaffleLapkin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/WaffleLapkin/subscriptions", "organizations_url": "https://api.github.com/users/WaffleLapkin/orgs", "repos_url": "https://api.github.com/users/WaffleLapkin/repos", "events_url": "https://api.github.com/users/WaffleLapkin/events{/privacy}", "received_events_url": "https://api.github.com/users/WaffleLapkin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0f7d81754db66d46ee9aa033735a1ee5c1daa44d", "url": "https://api.github.com/repos/rust-lang/rust/commits/0f7d81754db66d46ee9aa033735a1ee5c1daa44d", "html_url": "https://github.com/rust-lang/rust/commit/0f7d81754db66d46ee9aa033735a1ee5c1daa44d"}], "stats": {"total": 78, "additions": 39, "deletions": 39}, "files": [{"sha": "0ed24fe849c079ba0b0d186bb652ab258583363d", "filename": "compiler/rustc_parse/src/parser/attr.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/616df0f03ba343588ccc7894758f89825012d711/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/616df0f03ba343588ccc7894758f89825012d711/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fattr.rs?ref=616df0f03ba343588ccc7894758f89825012d711", "patch": "@@ -245,9 +245,9 @@ impl<'a> Parser<'a> {\n     ///     PATH `=` UNSUFFIXED_LIT\n     /// The delimiters or `=` are still put into the resulting token stream.\n     pub fn parse_attr_item(&mut self, capture_tokens: bool) -> PResult<'a, ast::AttrItem> {\n-        let item = match self.token.kind {\n-            token::Interpolated(ref nt) => match **nt {\n-                Nonterminal::NtMeta(ref item) => Some(item.clone().into_inner()),\n+        let item = match &self.token.kind {\n+            token::Interpolated(nt) => match &**nt {\n+                Nonterminal::NtMeta(item) => Some(item.clone().into_inner()),\n                 _ => None,\n             },\n             _ => None,\n@@ -364,9 +364,9 @@ impl<'a> Parser<'a> {\n     /// meta_item_inner : (meta_item | UNSUFFIXED_LIT) (',' meta_item_inner)? ;\n     /// ```\n     pub fn parse_meta_item(&mut self) -> PResult<'a, ast::MetaItem> {\n-        let nt_meta = match self.token.kind {\n-            token::Interpolated(ref nt) => match **nt {\n-                token::NtMeta(ref e) => Some(e.clone()),\n+        let nt_meta = match &self.token.kind {\n+            token::Interpolated(nt) => match &**nt {\n+                token::NtMeta(e) => Some(e.clone()),\n                 _ => None,\n             },\n             _ => None,"}, {"sha": "94c83503dc99b923b62932811a989ddc1032319b", "filename": "compiler/rustc_parse/src/parser/diagnostics.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/616df0f03ba343588ccc7894758f89825012d711/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "raw_url": "https://github.com/rust-lang/rust/raw/616df0f03ba343588ccc7894758f89825012d711/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fdiagnostics.rs?ref=616df0f03ba343588ccc7894758f89825012d711", "patch": "@@ -973,7 +973,7 @@ impl<'a> Parser<'a> {\n         inner_op: &Expr,\n         outer_op: &Spanned<AssocOp>,\n     ) -> bool /* advanced the cursor */ {\n-        if let ExprKind::Binary(op, ref l1, ref r1) = inner_op.kind {\n+        if let ExprKind::Binary(op, l1, r1) = &inner_op.kind {\n             if let ExprKind::Field(_, ident) = l1.kind\n                 && ident.as_str().parse::<i32>().is_err()\n                 && !matches!(r1.kind, ExprKind::Lit(_))\n@@ -1079,8 +1079,8 @@ impl<'a> Parser<'a> {\n \n         let mk_err_expr = |this: &Self, span| Ok(Some(this.mk_expr(span, ExprKind::Err)));\n \n-        match inner_op.kind {\n-            ExprKind::Binary(op, ref l1, ref r1) if op.node.is_comparison() => {\n+        match &inner_op.kind {\n+            ExprKind::Binary(op, l1, r1) if op.node.is_comparison() => {\n                 let mut err = ComparisonOperatorsCannotBeChained {\n                     span: vec![op.span, self.prev_token.span],\n                     suggest_turbofish: None,\n@@ -1237,8 +1237,8 @@ impl<'a> Parser<'a> {\n         let bounds = self.parse_generic_bounds(None)?;\n         let sum_span = ty.span.to(self.prev_token.span);\n \n-        let sub = match ty.kind {\n-            TyKind::Rptr(ref lifetime, ref mut_ty) => {\n+        let sub = match &ty.kind {\n+            TyKind::Rptr(lifetime, mut_ty) => {\n                 let sum_with_parens = pprust::to_string(|s| {\n                     s.s.word(\"&\");\n                     s.print_opt_lifetime(lifetime);"}, {"sha": "dc914f5ea6454d443cf18a401e1da3e859854026", "filename": "compiler/rustc_parse/src/parser/expr.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/616df0f03ba343588ccc7894758f89825012d711/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/616df0f03ba343588ccc7894758f89825012d711/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fexpr.rs?ref=616df0f03ba343588ccc7894758f89825012d711", "patch": "@@ -414,7 +414,7 @@ impl<'a> Parser<'a> {\n                 self.sess.ambiguous_block_expr_parse.borrow_mut().insert(sp, lhs.span);\n                 false\n             }\n-            (true, Some(ref op)) if !op.can_continue_expr_unambiguously() => false,\n+            (true, Some(op)) if !op.can_continue_expr_unambiguously() => false,\n             (true, Some(_)) => {\n                 self.error_found_expr_would_be_stmt(lhs);\n                 true\n@@ -1728,7 +1728,7 @@ impl<'a> Parser<'a> {\n             || !self.restrictions.contains(Restrictions::NO_STRUCT_LITERAL)\n         {\n             let expr = self.parse_expr_opt()?;\n-            if let Some(ref expr) = expr {\n+            if let Some(expr) = &expr {\n                 if label.is_some()\n                     && matches!(\n                         expr.kind,\n@@ -2590,8 +2590,8 @@ impl<'a> Parser<'a> {\n         // Used to check the `let_chains` and `if_let_guard` features mostly by scanning\n         // `&&` tokens.\n         fn check_let_expr(expr: &Expr) -> (bool, bool) {\n-            match expr.kind {\n-                ExprKind::Binary(BinOp { node: BinOpKind::And, .. }, ref lhs, ref rhs) => {\n+            match &expr.kind {\n+                ExprKind::Binary(BinOp { node: BinOpKind::And, .. }, lhs, rhs) => {\n                     let lhs_rslt = check_let_expr(lhs);\n                     let rhs_rslt = check_let_expr(rhs);\n                     (lhs_rslt.0 || rhs_rslt.0, false)"}, {"sha": "db3072e42627447712936eb4af29de8bc9f53c66", "filename": "compiler/rustc_parse/src/parser/item.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/616df0f03ba343588ccc7894758f89825012d711/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/616df0f03ba343588ccc7894758f89825012d711/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fitem.rs?ref=616df0f03ba343588ccc7894758f89825012d711", "patch": "@@ -1255,8 +1255,8 @@ impl<'a> Parser<'a> {\n             }\n         };\n \n-        match impl_info.1 {\n-            ItemKind::Impl(box Impl { of_trait: Some(ref trai), ref mut constness, .. }) => {\n+        match &mut impl_info.1 {\n+            ItemKind::Impl(box Impl { of_trait: Some(trai), constness, .. }) => {\n                 *constness = Const::Yes(const_span);\n \n                 let before_trait = trai.path.span.shrink_to_lo();\n@@ -2585,8 +2585,8 @@ impl<'a> Parser<'a> {\n     }\n \n     fn is_named_param(&self) -> bool {\n-        let offset = match self.token.kind {\n-            token::Interpolated(ref nt) => match **nt {\n+        let offset = match &self.token.kind {\n+            token::Interpolated(nt) => match **nt {\n                 token::NtPat(..) => return self.look_ahead(1, |t| t == &token::Colon),\n                 _ => 0,\n             },"}, {"sha": "4d8bff28b05aa300a4ed81e7505536914837e8fd", "filename": "compiler/rustc_parse/src/parser/mod.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/616df0f03ba343588ccc7894758f89825012d711/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/616df0f03ba343588ccc7894758f89825012d711/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fmod.rs?ref=616df0f03ba343588ccc7894758f89825012d711", "patch": "@@ -384,8 +384,8 @@ enum TokenType {\n \n impl TokenType {\n     fn to_string(&self) -> String {\n-        match *self {\n-            TokenType::Token(ref t) => format!(\"`{}`\", pprust::token_kind_to_string(t)),\n+        match self {\n+            TokenType::Token(t) => format!(\"`{}`\", pprust::token_kind_to_string(t)),\n             TokenType::Keyword(kw) => format!(\"`{}`\", kw),\n             TokenType::Operator => \"an operator\".to_string(),\n             TokenType::Lifetime => \"lifetime\".to_string(),\n@@ -738,8 +738,8 @@ impl<'a> Parser<'a> {\n \n     fn check_inline_const(&self, dist: usize) -> bool {\n         self.is_keyword_ahead(dist, &[kw::Const])\n-            && self.look_ahead(dist + 1, |t| match t.kind {\n-                token::Interpolated(ref nt) => matches!(**nt, token::NtBlock(..)),\n+            && self.look_ahead(dist + 1, |t| match &t.kind {\n+                token::Interpolated(nt) => matches!(**nt, token::NtBlock(..)),\n                 token::OpenDelim(Delimiter::Brace) => true,\n                 _ => false,\n             })\n@@ -860,7 +860,7 @@ impl<'a> Parser<'a> {\n             if let token::CloseDelim(..) | token::Eof = self.token.kind {\n                 break;\n             }\n-            if let Some(ref t) = sep.sep {\n+            if let Some(t) = &sep.sep {\n                 if first {\n                     first = false;\n                 } else {\n@@ -895,7 +895,7 @@ impl<'a> Parser<'a> {\n \n                                 _ => {\n                                     // Attempt to keep parsing if it was a similar separator.\n-                                    if let Some(ref tokens) = t.similar_tokens() {\n+                                    if let Some(tokens) = t.similar_tokens() {\n                                         if tokens.contains(&self.token.kind) && !unclosed_delims {\n                                             self.bump();\n                                         }"}, {"sha": "239ed79ce2ffb825682f1fd3db0d26661cd8cf5e", "filename": "compiler/rustc_parse/src/parser/nonterminal.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/616df0f03ba343588ccc7894758f89825012d711/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fnonterminal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/616df0f03ba343588ccc7894758f89825012d711/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fnonterminal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fnonterminal.rs?ref=616df0f03ba343588ccc7894758f89825012d711", "patch": "@@ -42,9 +42,9 @@ impl<'a> Parser<'a> {\n                 token::Comma | token::Ident(..) | token::Interpolated(..) => true,\n                 _ => token.can_begin_type(),\n             },\n-            NonterminalKind::Block => match token.kind {\n+            NonterminalKind::Block => match &token.kind {\n                 token::OpenDelim(Delimiter::Brace) => true,\n-                token::Interpolated(ref nt) => !matches!(\n+                token::Interpolated(nt) => !matches!(\n                     **nt,\n                     token::NtItem(_)\n                         | token::NtPat(_)\n@@ -56,16 +56,16 @@ impl<'a> Parser<'a> {\n                 ),\n                 _ => false,\n             },\n-            NonterminalKind::Path | NonterminalKind::Meta => match token.kind {\n+            NonterminalKind::Path | NonterminalKind::Meta => match &token.kind {\n                 token::ModSep | token::Ident(..) => true,\n-                token::Interpolated(ref nt) => match **nt {\n+                token::Interpolated(nt) => match **nt {\n                     token::NtPath(_) | token::NtMeta(_) => true,\n                     _ => may_be_ident(&nt),\n                 },\n                 _ => false,\n             },\n             NonterminalKind::PatParam { .. } | NonterminalKind::PatWithOr { .. } => {\n-                match token.kind {\n+                match &token.kind {\n                 token::Ident(..) |                          // box, ref, mut, and other identifiers (can stricten)\n                 token::OpenDelim(Delimiter::Parenthesis) |  // tuple pattern\n                 token::OpenDelim(Delimiter::Bracket) |      // slice pattern\n@@ -80,13 +80,13 @@ impl<'a> Parser<'a> {\n                 token::BinOp(token::Shl) => true,           // path (double UFCS)\n                 // leading vert `|` or-pattern\n                 token::BinOp(token::Or) =>  matches!(kind, NonterminalKind::PatWithOr {..}),\n-                token::Interpolated(ref nt) => may_be_ident(nt),\n+                token::Interpolated(nt) => may_be_ident(nt),\n                 _ => false,\n             }\n             }\n-            NonterminalKind::Lifetime => match token.kind {\n+            NonterminalKind::Lifetime => match &token.kind {\n                 token::Lifetime(_) => true,\n-                token::Interpolated(ref nt) => {\n+                token::Interpolated(nt) => {\n                     matches!(**nt, token::NtLifetime(_))\n                 }\n                 _ => false,"}, {"sha": "cbeec951e2dfe8dd0c037ae7f44a966ce11905d7", "filename": "compiler/rustc_parse/src/parser/pat.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/616df0f03ba343588ccc7894758f89825012d711/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/616df0f03ba343588ccc7894758f89825012d711/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fpat.rs?ref=616df0f03ba343588ccc7894758f89825012d711", "patch": "@@ -485,7 +485,7 @@ impl<'a> Parser<'a> {\n         let mut rhs = self.parse_pat_no_top_alt(None)?;\n         let sp = lhs.span.to(rhs.span);\n \n-        if let PatKind::Ident(_, _, ref mut sub @ None) = rhs.kind {\n+        if let PatKind::Ident(_, _, sub @ None) = &mut rhs.kind {\n             // The user inverted the order, so help them fix that.\n             let mut applicability = Applicability::MachineApplicable;\n             // FIXME(bindings_after_at): Remove this code when stabilizing the feature.\n@@ -595,7 +595,7 @@ impl<'a> Parser<'a> {\n         self.recover_additional_muts();\n \n         // Make sure we don't allow e.g. `let mut $p;` where `$p:pat`.\n-        if let token::Interpolated(ref nt) = self.token.kind {\n+        if let token::Interpolated(nt) = &self.token.kind {\n             if let token::NtPat(_) = **nt {\n                 self.expected_ident_found().emit();\n             }\n@@ -796,7 +796,7 @@ impl<'a> Parser<'a> {\n     /// expression syntax `...expr` for splatting in expressions.\n     fn parse_pat_range_to(&mut self, mut re: Spanned<RangeEnd>) -> PResult<'a, PatKind> {\n         let end = self.parse_pat_range_end()?;\n-        if let RangeEnd::Included(ref mut syn @ RangeSyntax::DotDotDot) = &mut re.node {\n+        if let RangeEnd::Included(syn @ RangeSyntax::DotDotDot) = &mut re.node {\n             *syn = RangeSyntax::DotDotEq;\n             self.struct_span_err(re.span, \"range-to patterns with `...` are not allowed\")\n                 .span_suggestion_short("}, {"sha": "1b56cd72db079b872f3fea8678b4d7b640743b2a", "filename": "compiler/rustc_parse/src/parser/stmt.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/616df0f03ba343588ccc7894758f89825012d711/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/616df0f03ba343588ccc7894758f89825012d711/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_parse%2Fsrc%2Fparser%2Fstmt.rs?ref=616df0f03ba343588ccc7894758f89825012d711", "patch": "@@ -563,9 +563,9 @@ impl<'a> Parser<'a> {\n         };\n \n         let mut eat_semi = true;\n-        match stmt.kind {\n+        match &mut stmt.kind {\n             // Expression without semicolon.\n-            StmtKind::Expr(ref mut expr)\n+            StmtKind::Expr(expr)\n                 if self.token != token::Eof && classify::expr_requires_semi_to_be_stmt(expr) => {\n                 // Just check for errors and recover; do not eat semicolon yet.\n                 // `expect_one_of` returns PResult<'a, bool /* recovered */>\n@@ -611,7 +611,7 @@ impl<'a> Parser<'a> {\n                 }\n             }\n             StmtKind::Expr(_) | StmtKind::MacCall(_) => {}\n-            StmtKind::Local(ref mut local) if let Err(e) = self.expect_semi() => {\n+            StmtKind::Local(local) if let Err(e) = self.expect_semi() => {\n                 // We might be at the `,` in `let x = foo<bar, baz>;`. Try to recover.\n                 match &mut local.kind {\n                     LocalKind::Init(expr) | LocalKind::InitElse(expr, _) => {"}]}