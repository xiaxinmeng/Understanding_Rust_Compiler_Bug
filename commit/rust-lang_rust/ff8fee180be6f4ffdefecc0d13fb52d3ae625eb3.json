{"sha": "ff8fee180be6f4ffdefecc0d13fb52d3ae625eb3", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZmOGZlZTE4MGJlNmY0ZmZkZWZlY2MwZDEzZmI1MmQzYWU2MjVlYjM=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-06-18T21:34:04Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-06-18T21:34:04Z"}, "message": "Auto merge of #26147 - arielb1:assoc-trans, r=nikomatsakis\n\nFixes #25700\r\n\r\nr? @nikomatsakis", "tree": {"sha": "168e2a201da1202bad2bc958aae3a1bf23e415b6", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/168e2a201da1202bad2bc958aae3a1bf23e415b6"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ff8fee180be6f4ffdefecc0d13fb52d3ae625eb3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ff8fee180be6f4ffdefecc0d13fb52d3ae625eb3", "html_url": "https://github.com/rust-lang/rust/commit/ff8fee180be6f4ffdefecc0d13fb52d3ae625eb3", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ff8fee180be6f4ffdefecc0d13fb52d3ae625eb3/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "url": "https://api.github.com/repos/rust-lang/rust/commits/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6", "html_url": "https://github.com/rust-lang/rust/commit/9cc0b2247509d61d6a246a5c5ad67f84b9a2d8b6"}, {"sha": "21fd312043818d0e92f44223a49a0d66d1e2880b", "url": "https://api.github.com/repos/rust-lang/rust/commits/21fd312043818d0e92f44223a49a0d66d1e2880b", "html_url": "https://github.com/rust-lang/rust/commit/21fd312043818d0e92f44223a49a0d66d1e2880b"}], "stats": {"total": 338, "additions": 231, "deletions": 107}, "files": [{"sha": "b4b53c003ea2f8fcadfd9dd32cf9e07e7836db19", "filename": "src/librustc/middle/traits/mod.rs", "status": "modified", "additions": 34, "deletions": 64, "changes": 98, "blob_url": "https://github.com/rust-lang/rust/blob/ff8fee180be6f4ffdefecc0d13fb52d3ae625eb3/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff8fee180be6f4ffdefecc0d13fb52d3ae625eb3/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fmod.rs?ref=ff8fee180be6f4ffdefecc0d13fb52d3ae625eb3", "patch": "@@ -245,7 +245,7 @@ pub enum Vtable<'tcx, N> {\n     /// Vtable automatically generated for a closure. The def ID is the ID\n     /// of the closure expression. This is a `VtableImpl` in spirit, but the\n     /// impl is generated by the compiler and does not appear in the source.\n-    VtableClosure(ast::DefId, subst::Substs<'tcx>),\n+    VtableClosure(VtableClosureData<'tcx, N>),\n \n     /// Same as above, but for a fn pointer type with the given signature.\n     VtableFnPointer(ty::Ty<'tcx>),\n@@ -268,7 +268,16 @@ pub struct VtableImplData<'tcx, N> {\n     pub nested: Vec<N>\n }\n \n-#[derive(Debug,Clone)]\n+#[derive(Clone, PartialEq, Eq)]\n+pub struct VtableClosureData<'tcx, N> {\n+    pub closure_def_id: ast::DefId,\n+    pub substs: subst::Substs<'tcx>,\n+    /// Nested obligations. This can be non-empty if the closure\n+    /// signature contains associated types.\n+    pub nested: Vec<N>\n+}\n+\n+#[derive(Debug, Clone)]\n pub struct VtableDefaultImplData<N> {\n     pub trait_def_id: ast::DefId,\n     pub nested: Vec<N>\n@@ -304,12 +313,12 @@ pub fn predicates_for_generics<'tcx>(tcx: &ty::ctxt<'tcx>,\n /// `bound` or is not known to meet bound (note that this is\n /// conservative towards *no impl*, which is the opposite of the\n /// `evaluate` methods).\n-pub fn evaluate_builtin_bound<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n-                                       typer: &ty::ClosureTyper<'tcx>,\n-                                       ty: Ty<'tcx>,\n-                                       bound: ty::BuiltinBound,\n-                                       span: Span)\n-                                       -> SelectionResult<'tcx, ()>\n+pub fn type_known_to_meet_builtin_bound<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n+                                                 typer: &ty::ClosureTyper<'tcx>,\n+                                                 ty: Ty<'tcx>,\n+                                                 bound: ty::BuiltinBound,\n+                                                 span: Span)\n+                                                 -> bool\n {\n     debug!(\"type_known_to_meet_builtin_bound(ty={}, bound={:?})\",\n            ty.repr(infcx.tcx),\n@@ -327,61 +336,18 @@ pub fn evaluate_builtin_bound<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n     // Note: we only assume something is `Copy` if we can\n     // *definitively* show that it implements `Copy`. Otherwise,\n     // assume it is move; linear is always ok.\n-    let result = match fulfill_cx.select_all_or_error(infcx, typer) {\n-        Ok(()) => Ok(Some(())), // Success, we know it implements Copy.\n-        Err(errors) => {\n-            // If there were any hard errors, propagate an arbitrary\n-            // one of those. If no hard errors at all, report\n-            // ambiguity.\n-            let sel_error =\n-                errors.iter()\n-                      .filter_map(|err| {\n-                          match err.code {\n-                              CodeAmbiguity => None,\n-                              CodeSelectionError(ref e) => Some(e.clone()),\n-                              CodeProjectionError(_) => {\n-                                  infcx.tcx.sess.span_bug(\n-                                      span,\n-                                      \"projection error while selecting?\")\n-                              }\n-                          }\n-                      })\n-                      .next();\n-            match sel_error {\n-                None => { Ok(None) }\n-                Some(e) => { Err(e) }\n-            }\n-        }\n-    };\n-\n-    debug!(\"type_known_to_meet_builtin_bound: ty={} bound={:?} result={:?}\",\n-           ty.repr(infcx.tcx),\n-           bound,\n-           result);\n-\n-    result\n-}\n-\n-pub fn type_known_to_meet_builtin_bound<'a,'tcx>(infcx: &InferCtxt<'a,'tcx>,\n-                                                 typer: &ty::ClosureTyper<'tcx>,\n-                                                 ty: Ty<'tcx>,\n-                                                 bound: ty::BuiltinBound,\n-                                                 span: Span)\n-                                                 -> bool\n-{\n-    match evaluate_builtin_bound(infcx, typer, ty, bound, span) {\n-        Ok(Some(())) => {\n-            // definitely impl'd\n+    match fulfill_cx.select_all_or_error(infcx, typer) {\n+        Ok(()) => {\n+            debug!(\"type_known_to_meet_builtin_bound: ty={} bound={:?} success\",\n+                   ty.repr(infcx.tcx),\n+                   bound);\n             true\n         }\n-        Ok(None) => {\n-            // ambiguous: if coherence check was successful, shouldn't\n-            // happen, but we might have reported an error and been\n-            // soldering on, so just treat this like not implemented\n-            false\n-        }\n-        Err(_) => {\n-            // errors: not implemented.\n+        Err(e) => {\n+            debug!(\"type_known_to_meet_builtin_bound: ty={} bound={:?} errors={}\",\n+                   ty.repr(infcx.tcx),\n+                   bound,\n+                   e.repr(infcx.tcx));\n             false\n         }\n     }\n@@ -545,8 +511,8 @@ impl<'tcx, N> Vtable<'tcx, N> {\n             VtableParam(n) => n,\n             VtableBuiltin(i) => i.nested,\n             VtableDefaultImpl(d) => d.nested,\n-            VtableObject(_) | VtableFnPointer(..) |\n-            VtableClosure(..) => vec![]\n+            VtableClosure(c) => c.nested,\n+            VtableObject(_) | VtableFnPointer(..) => vec![]\n         }\n     }\n \n@@ -567,7 +533,11 @@ impl<'tcx, N> Vtable<'tcx, N> {\n                 nested: d.nested.into_iter().map(f).collect()\n             }),\n             VtableFnPointer(f) => VtableFnPointer(f),\n-            VtableClosure(d, s) => VtableClosure(d, s),\n+            VtableClosure(c) => VtableClosure(VtableClosureData {\n+                closure_def_id: c.closure_def_id,\n+                substs: c.substs,\n+                nested: c.nested.into_iter().map(f).collect()\n+            })\n         }\n     }\n }"}, {"sha": "71946aa79ce3aa5a2ba79cfb9d631feaada29e50", "filename": "src/librustc/middle/traits/project.rs", "status": "modified", "additions": 30, "deletions": 14, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/ff8fee180be6f4ffdefecc0d13fb52d3ae625eb3/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff8fee180be6f4ffdefecc0d13fb52d3ae625eb3/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fproject.rs?ref=ff8fee180be6f4ffdefecc0d13fb52d3ae625eb3", "patch": "@@ -17,15 +17,15 @@ use super::ObligationCause;\n use super::PredicateObligation;\n use super::SelectionContext;\n use super::SelectionError;\n+use super::VtableClosureData;\n use super::VtableImplData;\n use super::util;\n \n use middle::infer;\n-use middle::subst::{Subst, Substs};\n+use middle::subst::Subst;\n use middle::ty::{self, AsPredicate, ReferencesError, RegionEscape,\n                  HasProjectionTypes, ToPolyTraitRef, Ty};\n use middle::ty_fold::{self, TypeFoldable, TypeFolder};\n-use syntax::ast;\n use syntax::parse::token;\n use util::common::FN_OUTPUT_NAME;\n use util::ppaux::Repr;\n@@ -57,7 +57,7 @@ pub struct MismatchedProjectionTypes<'tcx> {\n enum ProjectionTyCandidate<'tcx> {\n     ParamEnv(ty::PolyProjectionPredicate<'tcx>),\n     Impl(VtableImplData<'tcx, PredicateObligation<'tcx>>),\n-    Closure(ast::DefId, Substs<'tcx>),\n+    Closure(VtableClosureData<'tcx, PredicateObligation<'tcx>>),\n     FnPointer(Ty<'tcx>),\n }\n \n@@ -162,11 +162,16 @@ fn consider_unification_despite_ambiguity<'cx,'tcx>(selcx: &mut SelectionContext\n                                                         self_ty,\n                                                         &closure_type.sig,\n                                                         util::TupleArgumentsFlag::No);\n+            // We don't have to normalize the return type here - this is only\n+            // reached for TyClosure: Fn inputs where the closure kind is\n+            // still unknown, which should only occur in typeck where the\n+            // closure type is already normalized.\n             let (ret_type, _) =\n                 infcx.replace_late_bound_regions_with_fresh_var(\n                     obligation.cause.span,\n                     infer::AssocTypeProjection(obligation.predicate.projection_ty.item_name),\n                     &ty::Binder(ret_type));\n+\n             debug!(\"consider_unification_despite_ambiguity: ret_type={:?}\",\n                    ret_type.repr(selcx.tcx()));\n             let origin = infer::RelateOutputImplTypes(obligation.cause.span);\n@@ -686,9 +691,9 @@ fn assemble_candidates_from_impls<'cx,'tcx>(\n                 selcx, obligation, obligation_trait_ref, candidate_set,\n                 data.object_ty);\n         }\n-        super::VtableClosure(closure_def_id, substs) => {\n+        super::VtableClosure(data) => {\n             candidate_set.vec.push(\n-                ProjectionTyCandidate::Closure(closure_def_id, substs));\n+                ProjectionTyCandidate::Closure(data));\n         }\n         super::VtableFnPointer(fn_type) => {\n             candidate_set.vec.push(\n@@ -755,8 +760,8 @@ fn confirm_candidate<'cx,'tcx>(\n             confirm_impl_candidate(selcx, obligation, impl_vtable)\n         }\n \n-        ProjectionTyCandidate::Closure(def_id, substs) => {\n-            confirm_closure_candidate(selcx, obligation, def_id, &substs)\n+        ProjectionTyCandidate::Closure(closure_vtable) => {\n+            confirm_closure_candidate(selcx, obligation, closure_vtable)\n         }\n \n         ProjectionTyCandidate::FnPointer(fn_type) => {\n@@ -779,13 +784,24 @@ fn confirm_fn_pointer_candidate<'cx,'tcx>(\n fn confirm_closure_candidate<'cx,'tcx>(\n     selcx: &mut SelectionContext<'cx,'tcx>,\n     obligation: &ProjectionTyObligation<'tcx>,\n-    closure_def_id: ast::DefId,\n-    substs: &Substs<'tcx>)\n+    vtable: VtableClosureData<'tcx, PredicateObligation<'tcx>>)\n     -> (Ty<'tcx>, Vec<PredicateObligation<'tcx>>)\n {\n     let closure_typer = selcx.closure_typer();\n-    let closure_type = closure_typer.closure_type(closure_def_id, substs);\n-    confirm_callable_candidate(selcx, obligation, &closure_type.sig, util::TupleArgumentsFlag::No)\n+    let closure_type = closure_typer.closure_type(vtable.closure_def_id, &vtable.substs);\n+    let Normalized {\n+        value: closure_type,\n+        mut obligations\n+    } = normalize_with_depth(selcx,\n+                             obligation.cause.clone(),\n+                             obligation.recursion_depth+1,\n+                             &closure_type);\n+    let (ty, mut cc_obligations) = confirm_callable_candidate(selcx,\n+                                                              obligation,\n+                                                              &closure_type.sig,\n+                                                              util::TupleArgumentsFlag::No);\n+    obligations.append(&mut cc_obligations);\n+    (ty, obligations)\n }\n \n fn confirm_callable_candidate<'cx,'tcx>(\n@@ -797,7 +813,7 @@ fn confirm_callable_candidate<'cx,'tcx>(\n {\n     let tcx = selcx.tcx();\n \n-    debug!(\"confirm_closure_candidate({},{})\",\n+    debug!(\"confirm_callable_candidate({},{})\",\n            obligation.repr(tcx),\n            fn_sig.repr(tcx));\n \n@@ -921,8 +937,8 @@ impl<'tcx> Repr<'tcx> for ProjectionTyCandidate<'tcx> {\n                 format!(\"ParamEnv({})\", data.repr(tcx)),\n             ProjectionTyCandidate::Impl(ref data) =>\n                 format!(\"Impl({})\", data.repr(tcx)),\n-            ProjectionTyCandidate::Closure(ref a, ref b) =>\n-                format!(\"Closure(({},{}))\", a.repr(tcx), b.repr(tcx)),\n+            ProjectionTyCandidate::Closure(ref data) =>\n+                format!(\"Closure({})\", data.repr(tcx)),\n             ProjectionTyCandidate::FnPointer(a) =>\n                 format!(\"FnPointer(({}))\", a.repr(tcx)),\n         }"}, {"sha": "8e2a90aa808848fa4f00d77fe2dd1c5f6e9c1e87", "filename": "src/librustc/middle/traits/select.rs", "status": "modified", "additions": 53, "deletions": 19, "changes": 72, "blob_url": "https://github.com/rust-lang/rust/blob/ff8fee180be6f4ffdefecc0d13fb52d3ae625eb3/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff8fee180be6f4ffdefecc0d13fb52d3ae625eb3/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Fselect.rs?ref=ff8fee180be6f4ffdefecc0d13fb52d3ae625eb3", "patch": "@@ -31,7 +31,8 @@ use super::Selection;\n use super::SelectionResult;\n use super::{VtableBuiltin, VtableImpl, VtableParam, VtableClosure,\n             VtableFnPointer, VtableObject, VtableDefaultImpl};\n-use super::{VtableImplData, VtableObjectData, VtableBuiltinData, VtableDefaultImplData};\n+use super::{VtableImplData, VtableObjectData, VtableBuiltinData,\n+            VtableClosureData, VtableDefaultImplData};\n use super::object_safety;\n use super::util;\n \n@@ -355,7 +356,14 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         };\n         assert!(!substs.has_escaping_regions());\n \n-        let closure_trait_ref = self.closure_trait_ref(obligation, closure_def_id, substs);\n+        // It is OK to call the unnormalized variant here - this is only\n+        // reached for TyClosure: Fn inputs where the closure kind is\n+        // still unknown, which should only occur in typeck where the\n+        // closure type is already normalized.\n+        let closure_trait_ref = self.closure_trait_ref_unnormalized(obligation,\n+                                                                    closure_def_id,\n+                                                                    substs);\n+\n         match self.confirm_poly_trait_refs(obligation.cause.clone(),\n                                            obligation.predicate.to_poly_trait_ref(),\n                                            closure_trait_ref) {\n@@ -2001,8 +2009,9 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             }\n \n             ClosureCandidate(closure_def_id, substs) => {\n-                try!(self.confirm_closure_candidate(obligation, closure_def_id, &substs));\n-                Ok(VtableClosure(closure_def_id, substs))\n+                let vtable_closure =\n+                    try!(self.confirm_closure_candidate(obligation, closure_def_id, &substs));\n+                Ok(VtableClosure(vtable_closure))\n             }\n \n             BuiltinObjectCandidate => {\n@@ -2343,24 +2352,33 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                  obligation: &TraitObligation<'tcx>,\n                                  closure_def_id: ast::DefId,\n                                  substs: &Substs<'tcx>)\n-                                 -> Result<(),SelectionError<'tcx>>\n+                                 -> Result<VtableClosureData<'tcx, PredicateObligation<'tcx>>,\n+                                           SelectionError<'tcx>>\n     {\n         debug!(\"confirm_closure_candidate({},{},{})\",\n                obligation.repr(self.tcx()),\n                closure_def_id.repr(self.tcx()),\n                substs.repr(self.tcx()));\n \n-        let trait_ref = self.closure_trait_ref(obligation,\n-                                               closure_def_id,\n-                                               substs);\n+        let Normalized {\n+            value: trait_ref,\n+            obligations\n+        } = self.closure_trait_ref(obligation, closure_def_id, substs);\n \n-        debug!(\"confirm_closure_candidate(closure_def_id={}, trait_ref={})\",\n+        debug!(\"confirm_closure_candidate(closure_def_id={}, trait_ref={}, obligations={})\",\n                closure_def_id.repr(self.tcx()),\n-               trait_ref.repr(self.tcx()));\n+               trait_ref.repr(self.tcx()),\n+               obligations.repr(self.tcx()));\n+\n+        try!(self.confirm_poly_trait_refs(obligation.cause.clone(),\n+                                          obligation.predicate.to_poly_trait_ref(),\n+                                          trait_ref));\n \n-        self.confirm_poly_trait_refs(obligation.cause.clone(),\n-                                     obligation.predicate.to_poly_trait_ref(),\n-                                     trait_ref)\n+        Ok(VtableClosureData {\n+            closure_def_id: closure_def_id,\n+            substs: substs.clone(),\n+            nested: obligations\n+        })\n     }\n \n     /// In the case of closure types and fn pointers,\n@@ -2819,11 +2837,11 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n     }\n \n-    fn closure_trait_ref(&self,\n-                         obligation: &TraitObligation<'tcx>,\n-                         closure_def_id: ast::DefId,\n-                         substs: &Substs<'tcx>)\n-                         -> ty::PolyTraitRef<'tcx>\n+    fn closure_trait_ref_unnormalized(&mut self,\n+                                      obligation: &TraitObligation<'tcx>,\n+                                      closure_def_id: ast::DefId,\n+                                      substs: &Substs<'tcx>)\n+                                      -> ty::PolyTraitRef<'tcx>\n     {\n         let closure_type = self.closure_typer.closure_type(closure_def_id, substs);\n         let ty::Binder((trait_ref, _)) =\n@@ -2832,7 +2850,6 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                                                     obligation.predicate.0.self_ty(), // (1)\n                                                     &closure_type.sig,\n                                                     util::TupleArgumentsFlag::No);\n-\n         // (1) Feels icky to skip the binder here, but OTOH we know\n         // that the self-type is an unboxed closure type and hence is\n         // in fact unparameterized (or at least does not reference any\n@@ -2842,6 +2859,23 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         ty::Binder(trait_ref)\n     }\n \n+    fn closure_trait_ref(&mut self,\n+                         obligation: &TraitObligation<'tcx>,\n+                         closure_def_id: ast::DefId,\n+                         substs: &Substs<'tcx>)\n+                         -> Normalized<'tcx, ty::PolyTraitRef<'tcx>>\n+    {\n+        let trait_ref = self.closure_trait_ref_unnormalized(\n+            obligation, closure_def_id, substs);\n+\n+        // A closure signature can contain associated types which\n+        // must be normalized.\n+        normalize_with_depth(self,\n+                             obligation.cause.clone(),\n+                             obligation.recursion_depth+1,\n+                             &trait_ref)\n+    }\n+\n     /// Returns the obligations that are implied by instantiating an\n     /// impl or trait. The obligations are substituted and fully\n     /// normalized. This is used when confirming an impl or default"}, {"sha": "c1205d4a46d81055157289417be7482bfb9b77cd", "filename": "src/librustc/middle/traits/util.rs", "status": "modified", "additions": 17, "deletions": 4, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/ff8fee180be6f4ffdefecc0d13fb52d3ae625eb3/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff8fee180be6f4ffdefecc0d13fb52d3ae625eb3/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftraits%2Futil.rs?ref=ff8fee180be6f4ffdefecc0d13fb52d3ae625eb3", "patch": "@@ -308,6 +308,12 @@ impl<'tcx, N> fmt::Debug for VtableImplData<'tcx, N> {\n     }\n }\n \n+impl<'tcx, N> fmt::Debug for super::VtableClosureData<'tcx, N> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        write!(f, \"VtableClosure({:?})\", self.closure_def_id)\n+    }\n+}\n+\n impl<'tcx> fmt::Debug for super::VtableObjectData<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         write!(f, \"VtableObject(...)\")\n@@ -497,10 +503,8 @@ impl<'tcx, N:Repr<'tcx>> Repr<'tcx> for super::Vtable<'tcx, N> {\n             super::VtableDefaultImpl(ref t) =>\n                 t.repr(tcx),\n \n-            super::VtableClosure(ref d, ref s) =>\n-                format!(\"VtableClosure({},{})\",\n-                        d.repr(tcx),\n-                        s.repr(tcx)),\n+            super::VtableClosure(ref d) =>\n+                d.repr(tcx),\n \n             super::VtableFnPointer(ref d) =>\n                 format!(\"VtableFnPointer({})\",\n@@ -529,6 +533,15 @@ impl<'tcx, N:Repr<'tcx>> Repr<'tcx> for super::VtableImplData<'tcx, N> {\n     }\n }\n \n+impl<'tcx, N:Repr<'tcx>> Repr<'tcx> for super::VtableClosureData<'tcx, N> {\n+    fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n+        format!(\"VtableClosure(closure_def_id={}, substs={}, nested={})\",\n+                self.closure_def_id.repr(tcx),\n+                self.substs.repr(tcx),\n+                self.nested.repr(tcx))\n+    }\n+}\n+\n impl<'tcx, N:Repr<'tcx>> Repr<'tcx> for super::VtableBuiltinData<N> {\n     fn repr(&self, tcx: &ty::ctxt<'tcx>) -> String {\n         format!(\"VtableBuiltin(nested={})\","}, {"sha": "cc91ccbfbd41e265ead805de2e15f94d6df80320", "filename": "src/librustc/middle/ty_fold.rs", "status": "modified", "additions": 12, "deletions": 2, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ff8fee180be6f4ffdefecc0d13fb52d3ae625eb3/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff8fee180be6f4ffdefecc0d13fb52d3ae625eb3/src%2Flibrustc%2Fmiddle%2Fty_fold.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty_fold.rs?ref=ff8fee180be6f4ffdefecc0d13fb52d3ae625eb3", "patch": "@@ -479,6 +479,16 @@ impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::VtableImplData<\n     }\n }\n \n+impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::VtableClosureData<'tcx, N> {\n+    fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::VtableClosureData<'tcx, N> {\n+        traits::VtableClosureData {\n+            closure_def_id: self.closure_def_id,\n+            substs: self.substs.fold_with(folder),\n+            nested: self.nested.fold_with(folder),\n+        }\n+    }\n+}\n+\n impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::VtableDefaultImplData<N> {\n     fn fold_with<F:TypeFolder<'tcx>>(&self, folder: &mut F) -> traits::VtableDefaultImplData<N> {\n         traits::VtableDefaultImplData {\n@@ -501,8 +511,8 @@ impl<'tcx, N: TypeFoldable<'tcx>> TypeFoldable<'tcx> for traits::Vtable<'tcx, N>\n         match *self {\n             traits::VtableImpl(ref v) => traits::VtableImpl(v.fold_with(folder)),\n             traits::VtableDefaultImpl(ref t) => traits::VtableDefaultImpl(t.fold_with(folder)),\n-            traits::VtableClosure(d, ref s) => {\n-                traits::VtableClosure(d, s.fold_with(folder))\n+            traits::VtableClosure(ref d) => {\n+                traits::VtableClosure(d.fold_with(folder))\n             }\n             traits::VtableFnPointer(ref d) => {\n                 traits::VtableFnPointer(d.fold_with(folder))"}, {"sha": "7827771994f9809b6a28487ae828f45e40a1d9f3", "filename": "src/librustc_trans/trans/meth.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/ff8fee180be6f4ffdefecc0d13fb52d3ae625eb3/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff8fee180be6f4ffdefecc0d13fb52d3ae625eb3/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Ftrans%2Fmeth.rs?ref=ff8fee180be6f4ffdefecc0d13fb52d3ae625eb3", "patch": "@@ -359,13 +359,13 @@ fn trans_monomorphized_callee<'blk, 'tcx>(bcx: Block<'blk, 'tcx>,\n \n             Callee { bcx: bcx, data: Fn(llfn) }\n         }\n-        traits::VtableClosure(closure_def_id, substs) => {\n+        traits::VtableClosure(vtable_closure) => {\n             // The substitutions should have no type parameters remaining\n             // after passing through fulfill_obligation\n             let trait_closure_kind = bcx.tcx().lang_items.fn_trait_kind(trait_id).unwrap();\n             let llfn = closure::trans_closure_method(bcx.ccx(),\n-                                                     closure_def_id,\n-                                                     substs,\n+                                                     vtable_closure.closure_def_id,\n+                                                     vtable_closure.substs,\n                                                      MethodCallKey(method_call),\n                                                      bcx.fcx.param_substs,\n                                                      trait_closure_kind);\n@@ -716,7 +716,11 @@ pub fn get_vtable<'a, 'tcx>(ccx: &CrateContext<'a, 'tcx>,\n                     nested: _ }) => {\n                 emit_vtable_methods(ccx, id, substs, param_substs).into_iter()\n             }\n-            traits::VtableClosure(closure_def_id, substs) => {\n+            traits::VtableClosure(\n+                traits::VtableClosureData {\n+                    closure_def_id,\n+                    substs,\n+                    nested: _ }) => {\n                 let trait_closure_kind = tcx.lang_items.fn_trait_kind(trait_ref.def_id()).unwrap();\n                 let llfn = closure::trans_closure_method(ccx,\n                                                          closure_def_id,"}, {"sha": "477c3237f84eec9fdcea09463e39b2eb89b15464", "filename": "src/test/compile-fail/issue-25700.rs", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/ff8fee180be6f4ffdefecc0d13fb52d3ae625eb3/src%2Ftest%2Fcompile-fail%2Fissue-25700.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff8fee180be6f4ffdefecc0d13fb52d3ae625eb3/src%2Ftest%2Fcompile-fail%2Fissue-25700.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-25700.rs?ref=ff8fee180be6f4ffdefecc0d13fb52d3ae625eb3", "patch": "@@ -0,0 +1,24 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct S<T: 'static>(Option<&'static T>);\n+\n+trait Tr { type Out; }\n+impl<T> Tr for T { type Out = T; }\n+\n+impl<T: 'static> Copy for S<T> where S<T>: Tr<Out=T> {}\n+impl<T: 'static> Clone for S<T> where S<T>: Tr<Out=T> {\n+    fn clone(&self) -> Self { *self }\n+}\n+fn main() {\n+    let t = S::<()>(None);\n+    drop(t);\n+    drop(t); //~ ERROR use of moved value\n+}"}, {"sha": "57f5b84b28537f52e88bb8aa86542a17e71a9381", "filename": "src/test/run-pass/issue-25700-1.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/ff8fee180be6f4ffdefecc0d13fb52d3ae625eb3/src%2Ftest%2Frun-pass%2Fissue-25700-1.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff8fee180be6f4ffdefecc0d13fb52d3ae625eb3/src%2Ftest%2Frun-pass%2Fissue-25700-1.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-25700-1.rs?ref=ff8fee180be6f4ffdefecc0d13fb52d3ae625eb3", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+struct S<T: 'static>(Option<&'static T>);\n+\n+trait Tr { type Out; }\n+impl<T> Tr for T { type Out = T; }\n+\n+impl<T: 'static> Copy for S<T> where S<T>: Tr<Out=T> {}\n+impl<T: 'static> Clone for S<T> where S<T>: Tr<Out=T> {\n+    fn clone(&self) -> Self { *self }\n+}\n+fn main() {\n+    S::<()>(None);\n+}"}, {"sha": "3117e6f3681de124f21b090c366e72f78fa7b981", "filename": "src/test/run-pass/issue-25700-2.rs", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/ff8fee180be6f4ffdefecc0d13fb52d3ae625eb3/src%2Ftest%2Frun-pass%2Fissue-25700-2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ff8fee180be6f4ffdefecc0d13fb52d3ae625eb3/src%2Ftest%2Frun-pass%2Fissue-25700-2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-25700-2.rs?ref=ff8fee180be6f4ffdefecc0d13fb52d3ae625eb3", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub trait Parser {\n+    type Input;\n+}\n+\n+pub struct Iter<P: Parser>(P, P::Input);\n+\n+pub struct Map<P, F>(P, F);\n+impl<P, F> Parser for Map<P, F> where F: FnMut(P) {\n+    type Input = u8;\n+}\n+\n+trait AstId { type Untyped; }\n+impl AstId for u32 { type Untyped = u32; }\n+\n+fn record_type<Id: AstId>(i: Id::Untyped) -> u8 {\n+    Iter(Map(i, |_: Id::Untyped| {}), 42).1\n+}\n+\n+pub fn main() {\n+   assert_eq!(record_type::<u32>(3), 42);\n+}"}]}