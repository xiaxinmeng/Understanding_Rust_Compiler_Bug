{"sha": "57f097ea25f2c05f424fc9b9dc50dbd6d399845c", "node_id": "C_kwDOAAsO6NoAKDU3ZjA5N2VhMjVmMmMwNWY0MjRmYzliOWRjNTBkYmQ2ZDM5OTg0NWM", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-01T19:54:55Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-10-01T19:54:55Z"}, "message": "Auto merge of #102236 - cjgillot:compute_lint_levels_by_def, r=oli-obk\n\nCompute lint levels by definition\n\nSecond attempt to https://github.com/rust-lang/rust/pull/101620.\n\nI think that I have removed the perf regression.", "tree": {"sha": "54b2bb2968147e1c6c3e422a18622192334d2ba7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/54b2bb2968147e1c6c3e422a18622192334d2ba7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/57f097ea25f2c05f424fc9b9dc50dbd6d399845c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/57f097ea25f2c05f424fc9b9dc50dbd6d399845c", "html_url": "https://github.com/rust-lang/rust/commit/57f097ea25f2c05f424fc9b9dc50dbd6d399845c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/57f097ea25f2c05f424fc9b9dc50dbd6d399845c/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "56a35bc906be1250a76fdb9a4b70e9261e10aec5", "url": "https://api.github.com/repos/rust-lang/rust/commits/56a35bc906be1250a76fdb9a4b70e9261e10aec5", "html_url": "https://github.com/rust-lang/rust/commit/56a35bc906be1250a76fdb9a4b70e9261e10aec5"}, {"sha": "fec53fd9db276d34d8d17701aeb3e81576d761fe", "url": "https://api.github.com/repos/rust-lang/rust/commits/fec53fd9db276d34d8d17701aeb3e81576d761fe", "html_url": "https://github.com/rust-lang/rust/commit/fec53fd9db276d34d8d17701aeb3e81576d761fe"}], "stats": {"total": 1290, "additions": 791, "deletions": 499}, "files": [{"sha": "fe257e10205faaba0a4ed055ec7faa3fd5ac4c7a", "filename": "compiler/rustc_data_structures/src/sorted_map.rs", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/57f097ea25f2c05f424fc9b9dc50dbd6d399845c/compiler%2Frustc_data_structures%2Fsrc%2Fsorted_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57f097ea25f2c05f424fc9b9dc50dbd6d399845c/compiler%2Frustc_data_structures%2Fsrc%2Fsorted_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_data_structures%2Fsrc%2Fsorted_map.rs?ref=57f097ea25f2c05f424fc9b9dc50dbd6d399845c", "patch": "@@ -96,6 +96,23 @@ impl<K: Ord, V> SortedMap<K, V> {\n         }\n     }\n \n+    /// Gets a mutable reference to the value in the entry, or insert a new one.\n+    #[inline]\n+    pub fn get_mut_or_insert_default(&mut self, key: K) -> &mut V\n+    where\n+        K: Eq,\n+        V: Default,\n+    {\n+        let index = match self.lookup_index_for(&key) {\n+            Ok(index) => index,\n+            Err(index) => {\n+                self.data.insert(index, (key, V::default()));\n+                index\n+            }\n+        };\n+        unsafe { &mut self.data.get_unchecked_mut(index).1 }\n+    }\n+\n     #[inline]\n     pub fn clear(&mut self) {\n         self.data.clear();"}, {"sha": "31e410aaaf082fc1c7a32c364439cf097e2ba531", "filename": "compiler/rustc_errors/src/diagnostic.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/57f097ea25f2c05f424fc9b9dc50dbd6d399845c/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57f097ea25f2c05f424fc9b9dc50dbd6d399845c/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Fdiagnostic.rs?ref=57f097ea25f2c05f424fc9b9dc50dbd6d399845c", "patch": "@@ -364,9 +364,10 @@ impl Diagnostic {\n             // The lint index inside the attribute is manually transferred here.\n             let lint_index = expectation_id.get_lint_index();\n             expectation_id.set_lint_index(None);\n-            let mut stable_id = *unstable_to_stable\n+            let mut stable_id = unstable_to_stable\n                 .get(&expectation_id)\n-                .expect(\"each unstable `LintExpectationId` must have a matching stable id\");\n+                .expect(\"each unstable `LintExpectationId` must have a matching stable id\")\n+                .normalize();\n \n             stable_id.set_lint_index(lint_index);\n             *expectation_id = stable_id;"}, {"sha": "7c312da62793f03ff0acfbd4835dade4e6a7dc6b", "filename": "compiler/rustc_errors/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/57f097ea25f2c05f424fc9b9dc50dbd6d399845c/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57f097ea25f2c05f424fc9b9dc50dbd6d399845c/compiler%2Frustc_errors%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_errors%2Fsrc%2Flib.rs?ref=57f097ea25f2c05f424fc9b9dc50dbd6d399845c", "patch": "@@ -1211,7 +1211,7 @@ impl HandlerInner {\n \n         if let Some(expectation_id) = diagnostic.level.get_expectation_id() {\n             self.suppressed_expected_diag = true;\n-            self.fulfilled_expectations.insert(expectation_id);\n+            self.fulfilled_expectations.insert(expectation_id.normalize());\n         }\n \n         if matches!(diagnostic.level, Warning(_))"}, {"sha": "74e35afc87d7bac343e7a389ae1accafb2a9dc74", "filename": "compiler/rustc_lint/src/context.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/57f097ea25f2c05f424fc9b9dc50dbd6d399845c/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57f097ea25f2c05f424fc9b9dc50dbd6d399845c/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fcontext.rs?ref=57f097ea25f2c05f424fc9b9dc50dbd6d399845c", "patch": "@@ -558,7 +558,7 @@ pub struct LateContext<'tcx> {\n \n /// Context for lint checking of the AST, after expansion, before lowering to HIR.\n pub struct EarlyContext<'a> {\n-    pub builder: LintLevelsBuilder<'a>,\n+    pub builder: LintLevelsBuilder<'a, crate::levels::TopDown>,\n     pub buffered: LintBuffer,\n }\n "}, {"sha": "f7759bec908b40682bb455a0ffb66229a56eb388", "filename": "compiler/rustc_lint/src/early.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/57f097ea25f2c05f424fc9b9dc50dbd6d399845c/compiler%2Frustc_lint%2Fsrc%2Fearly.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57f097ea25f2c05f424fc9b9dc50dbd6d399845c/compiler%2Frustc_lint%2Fsrc%2Fearly.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fearly.rs?ref=57f097ea25f2c05f424fc9b9dc50dbd6d399845c", "patch": "@@ -58,6 +58,7 @@ impl<'a, T: EarlyLintPass> EarlyContextAndPass<'a, T> {\n         F: FnOnce(&mut Self),\n     {\n         let is_crate_node = id == ast::CRATE_NODE_ID;\n+        debug!(?id);\n         let push = self.context.builder.push(attrs, is_crate_node, None);\n \n         self.check_id(id);"}, {"sha": "4c3c39734dd6fcb9f7a039b56c64bc86237c0eaa", "filename": "compiler/rustc_lint/src/expect.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/57f097ea25f2c05f424fc9b9dc50dbd6d399845c/compiler%2Frustc_lint%2Fsrc%2Fexpect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57f097ea25f2c05f424fc9b9dc50dbd6d399845c/compiler%2Frustc_lint%2Fsrc%2Fexpect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fexpect.rs?ref=57f097ea25f2c05f424fc9b9dc50dbd6d399845c", "patch": "@@ -16,8 +16,10 @@ fn check_expectations(tcx: TyCtxt<'_>, tool_filter: Option<Symbol>) {\n         return;\n     }\n \n+    let lint_expectations = tcx.lint_expectations(());\n     let fulfilled_expectations = tcx.sess.diagnostic().steal_fulfilled_expectation_ids();\n-    let lint_expectations = &tcx.lint_levels(()).lint_expectations;\n+\n+    tracing::debug!(?lint_expectations, ?fulfilled_expectations);\n \n     for (id, expectation) in lint_expectations {\n         // This check will always be true, since `lint_expectations` only"}, {"sha": "be1d7d98aa69cd76fa743f280c0b5a7ec72738b1", "filename": "compiler/rustc_lint/src/levels.rs", "status": "modified", "additions": 530, "deletions": 295, "changes": 825, "blob_url": "https://github.com/rust-lang/rust/blob/57f097ea25f2c05f424fc9b9dc50dbd6d399845c/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57f097ea25f2c05f424fc9b9dc50dbd6d399845c/compiler%2Frustc_lint%2Fsrc%2Flevels.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Flevels.rs?ref=57f097ea25f2c05f424fc9b9dc50dbd6d399845c", "patch": "@@ -5,11 +5,13 @@ use rustc_ast_pretty::pprust;\n use rustc_data_structures::fx::FxHashMap;\n use rustc_errors::{Applicability, Diagnostic, DiagnosticBuilder, DiagnosticMessage, MultiSpan};\n use rustc_hir as hir;\n-use rustc_hir::{intravisit, HirId};\n+use rustc_hir::intravisit::{self, Visitor};\n+use rustc_hir::HirId;\n+use rustc_index::vec::IndexVec;\n use rustc_middle::hir::nested_filter;\n use rustc_middle::lint::{\n-    struct_lint_level, LevelAndSource, LintExpectation, LintLevelMap, LintLevelSets,\n-    LintLevelSource, LintSet, LintStackIndex, COMMAND_LINE,\n+    reveal_actual_level, struct_lint_level, LevelAndSource, LintExpectation, LintLevelSource,\n+    ShallowLintLevelMap,\n };\n use rustc_middle::ty::query::Providers;\n use rustc_middle::ty::{RegisteredTools, TyCtxt};\n@@ -27,68 +29,483 @@ use crate::errors::{\n     UnknownToolInScopedLint,\n };\n \n-fn lint_levels(tcx: TyCtxt<'_>, (): ()) -> LintLevelMap {\n-    let store = unerased_lint_store(tcx);\n-    let levels =\n-        LintLevelsBuilder::new(tcx.sess, false, &store, &tcx.resolutions(()).registered_tools);\n-    let mut builder = LintLevelMapBuilder { levels, tcx };\n-    let krate = tcx.hir().krate();\n+/// Collection of lint levels for the whole crate.\n+/// This is used by AST-based lints, which do not\n+/// wait until we have built HIR to be emitted.\n+#[derive(Debug)]\n+struct LintLevelSets {\n+    /// Linked list of specifications.\n+    list: IndexVec<LintStackIndex, LintSet>,\n+}\n+\n+rustc_index::newtype_index! {\n+    struct LintStackIndex {\n+        ENCODABLE = custom, // we don't need encoding\n+        const COMMAND_LINE = 0,\n+    }\n+}\n \n-    builder.levels.id_to_set.reserve(krate.owners.len() + 1);\n+/// Specifications found at this position in the stack.  This map only represents the lints\n+/// found for one set of attributes (like `shallow_lint_levels_on` does).\n+///\n+/// We store the level specifications as a linked list.\n+/// Each `LintSet` represents a set of attributes on the same AST node.\n+/// The `parent` forms a linked list that matches the AST tree.\n+/// This way, walking the linked list is equivalent to walking the AST bottom-up\n+/// to find the specifications for a given lint.\n+#[derive(Debug)]\n+struct LintSet {\n+    // -A,-W,-D flags, a `Symbol` for the flag itself and `Level` for which\n+    // flag.\n+    specs: FxHashMap<LintId, LevelAndSource>,\n+    parent: LintStackIndex,\n+}\n \n-    let push =\n-        builder.levels.push(tcx.hir().attrs(hir::CRATE_HIR_ID), true, Some(hir::CRATE_HIR_ID));\n+impl LintLevelSets {\n+    fn new() -> Self {\n+        LintLevelSets { list: IndexVec::new() }\n+    }\n+\n+    fn get_lint_level(\n+        &self,\n+        lint: &'static Lint,\n+        idx: LintStackIndex,\n+        aux: Option<&FxHashMap<LintId, LevelAndSource>>,\n+        sess: &Session,\n+    ) -> LevelAndSource {\n+        let lint = LintId::of(lint);\n+        let (level, mut src) = self.raw_lint_id_level(lint, idx, aux);\n+        let level = reveal_actual_level(level, &mut src, sess, lint, |id| {\n+            self.raw_lint_id_level(id, idx, aux)\n+        });\n+        (level, src)\n+    }\n+\n+    fn raw_lint_id_level(\n+        &self,\n+        id: LintId,\n+        mut idx: LintStackIndex,\n+        aux: Option<&FxHashMap<LintId, LevelAndSource>>,\n+    ) -> (Option<Level>, LintLevelSource) {\n+        if let Some(specs) = aux {\n+            if let Some(&(level, src)) = specs.get(&id) {\n+                return (Some(level), src);\n+            }\n+        }\n+        loop {\n+            let LintSet { ref specs, parent } = self.list[idx];\n+            if let Some(&(level, src)) = specs.get(&id) {\n+                return (Some(level), src);\n+            }\n+            if idx == COMMAND_LINE {\n+                return (None, LintLevelSource::Default);\n+            }\n+            idx = parent;\n+        }\n+    }\n+}\n \n-    builder.levels.register_id(hir::CRATE_HIR_ID);\n+fn lint_expectations(tcx: TyCtxt<'_>, (): ()) -> Vec<(LintExpectationId, LintExpectation)> {\n+    let store = unerased_lint_store(tcx);\n+\n+    let mut builder = LintLevelsBuilder {\n+        sess: tcx.sess,\n+        provider: QueryMapExpectationsWrapper {\n+            tcx,\n+            cur: hir::CRATE_HIR_ID,\n+            specs: ShallowLintLevelMap::default(),\n+            expectations: Vec::new(),\n+            unstable_to_stable_ids: FxHashMap::default(),\n+            empty: FxHashMap::default(),\n+        },\n+        warn_about_weird_lints: false,\n+        store,\n+        registered_tools: &tcx.resolutions(()).registered_tools,\n+    };\n+\n+    builder.add_command_line();\n+    builder.add_id(hir::CRATE_HIR_ID);\n     tcx.hir().walk_toplevel_module(&mut builder);\n-    builder.levels.pop(push);\n \n-    builder.levels.update_unstable_expectation_ids();\n-    builder.levels.build_map()\n+    tcx.sess.diagnostic().update_unstable_expectation_id(&builder.provider.unstable_to_stable_ids);\n+\n+    builder.provider.expectations\n }\n \n-pub struct LintLevelsBuilder<'s> {\n-    sess: &'s Session,\n-    lint_expectations: Vec<(LintExpectationId, LintExpectation)>,\n-    /// Each expectation has a stable and an unstable identifier. This map\n-    /// is used to map from unstable to stable [`LintExpectationId`]s.\n-    expectation_id_map: FxHashMap<LintExpectationId, LintExpectationId>,\n+#[instrument(level = \"trace\", skip(tcx), ret)]\n+fn shallow_lint_levels_on(tcx: TyCtxt<'_>, owner: hir::OwnerId) -> ShallowLintLevelMap {\n+    let store = unerased_lint_store(tcx);\n+    let attrs = tcx.hir_attrs(owner);\n+\n+    let mut levels = LintLevelsBuilder {\n+        sess: tcx.sess,\n+        provider: LintLevelQueryMap {\n+            tcx,\n+            cur: owner.into(),\n+            specs: ShallowLintLevelMap::default(),\n+            empty: FxHashMap::default(),\n+            attrs,\n+        },\n+        warn_about_weird_lints: false,\n+        store,\n+        registered_tools: &tcx.resolutions(()).registered_tools,\n+    };\n+\n+    if owner == hir::CRATE_OWNER_ID {\n+        levels.add_command_line();\n+    }\n+\n+    match attrs.map.range(..) {\n+        // There is only something to do if there are attributes at all.\n+        [] => {}\n+        // Most of the time, there is only one attribute.  Avoid fetching HIR in that case.\n+        [(local_id, _)] => levels.add_id(HirId { owner, local_id: *local_id }),\n+        // Otherwise, we need to visit the attributes in source code order, so we fetch HIR and do\n+        // a standard visit.\n+        // FIXME(#102522) Just iterate on attrs once that iteration order matches HIR's.\n+        _ => match tcx.hir().expect_owner(owner) {\n+            hir::OwnerNode::Item(item) => levels.visit_item(item),\n+            hir::OwnerNode::ForeignItem(item) => levels.visit_foreign_item(item),\n+            hir::OwnerNode::TraitItem(item) => levels.visit_trait_item(item),\n+            hir::OwnerNode::ImplItem(item) => levels.visit_impl_item(item),\n+            hir::OwnerNode::Crate(mod_) => {\n+                levels.add_id(hir::CRATE_HIR_ID);\n+                levels.visit_mod(mod_, mod_.spans.inner_span, hir::CRATE_HIR_ID)\n+            }\n+        },\n+    }\n+\n+    let specs = levels.provider.specs;\n+\n+    #[cfg(debug_assertions)]\n+    for (_, v) in specs.specs.iter() {\n+        debug_assert!(!v.is_empty());\n+    }\n+\n+    specs\n+}\n+\n+pub struct TopDown {\n     sets: LintLevelSets,\n-    id_to_set: FxHashMap<HirId, LintStackIndex>,\n     cur: LintStackIndex,\n+}\n+\n+pub trait LintLevelsProvider {\n+    fn current_specs(&self) -> &FxHashMap<LintId, LevelAndSource>;\n+    fn insert(&mut self, id: LintId, lvl: LevelAndSource);\n+    fn get_lint_level(&self, lint: &'static Lint, sess: &Session) -> LevelAndSource;\n+    fn push_expectation(&mut self, _id: LintExpectationId, _expectation: LintExpectation) {}\n+}\n+\n+impl LintLevelsProvider for TopDown {\n+    fn current_specs(&self) -> &FxHashMap<LintId, LevelAndSource> {\n+        &self.sets.list[self.cur].specs\n+    }\n+\n+    fn insert(&mut self, id: LintId, lvl: LevelAndSource) {\n+        self.sets.list[self.cur].specs.insert(id, lvl);\n+    }\n+\n+    fn get_lint_level(&self, lint: &'static Lint, sess: &Session) -> LevelAndSource {\n+        self.sets.get_lint_level(lint, self.cur, Some(self.current_specs()), sess)\n+    }\n+}\n+\n+struct LintLevelQueryMap<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    cur: HirId,\n+    specs: ShallowLintLevelMap,\n+    /// Empty hash map to simplify code.\n+    empty: FxHashMap<LintId, LevelAndSource>,\n+    attrs: &'tcx hir::AttributeMap<'tcx>,\n+}\n+\n+impl LintLevelsProvider for LintLevelQueryMap<'_> {\n+    fn current_specs(&self) -> &FxHashMap<LintId, LevelAndSource> {\n+        self.specs.specs.get(&self.cur.local_id).unwrap_or(&self.empty)\n+    }\n+    fn insert(&mut self, id: LintId, lvl: LevelAndSource) {\n+        self.specs.specs.get_mut_or_insert_default(self.cur.local_id).insert(id, lvl);\n+    }\n+    fn get_lint_level(&self, lint: &'static Lint, _: &Session) -> LevelAndSource {\n+        self.specs.lint_level_id_at_node(self.tcx, LintId::of(lint), self.cur)\n+    }\n+}\n+\n+struct QueryMapExpectationsWrapper<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n+    cur: HirId,\n+    specs: ShallowLintLevelMap,\n+    expectations: Vec<(LintExpectationId, LintExpectation)>,\n+    unstable_to_stable_ids: FxHashMap<LintExpectationId, LintExpectationId>,\n+    /// Empty hash map to simplify code.\n+    empty: FxHashMap<LintId, LevelAndSource>,\n+}\n+\n+impl LintLevelsProvider for QueryMapExpectationsWrapper<'_> {\n+    fn current_specs(&self) -> &FxHashMap<LintId, LevelAndSource> {\n+        self.specs.specs.get(&self.cur.local_id).unwrap_or(&self.empty)\n+    }\n+    fn insert(&mut self, id: LintId, lvl: LevelAndSource) {\n+        let specs = self.specs.specs.get_mut_or_insert_default(self.cur.local_id);\n+        specs.clear();\n+        specs.insert(id, lvl);\n+    }\n+    fn get_lint_level(&self, lint: &'static Lint, _: &Session) -> LevelAndSource {\n+        self.specs.lint_level_id_at_node(self.tcx, LintId::of(lint), self.cur)\n+    }\n+    fn push_expectation(&mut self, id: LintExpectationId, expectation: LintExpectation) {\n+        let LintExpectationId::Stable { attr_id: Some(attr_id), hir_id, attr_index, .. } = id else { bug!(\"unstable expectation id should already be mapped\") };\n+        let key = LintExpectationId::Unstable { attr_id, lint_index: None };\n+\n+        if !self.unstable_to_stable_ids.contains_key(&key) {\n+            self.unstable_to_stable_ids.insert(\n+                key,\n+                LintExpectationId::Stable { hir_id, attr_index, lint_index: None, attr_id: None },\n+            );\n+        }\n+\n+        self.expectations.push((id.normalize(), expectation));\n+    }\n+}\n+\n+impl<'tcx> LintLevelsBuilder<'_, LintLevelQueryMap<'tcx>> {\n+    fn add_id(&mut self, hir_id: HirId) {\n+        self.provider.cur = hir_id;\n+        self.add(\n+            self.provider.attrs.get(hir_id.local_id),\n+            hir_id == hir::CRATE_HIR_ID,\n+            Some(hir_id),\n+        );\n+    }\n+}\n+\n+impl<'tcx> Visitor<'tcx> for LintLevelsBuilder<'_, LintLevelQueryMap<'tcx>> {\n+    type NestedFilter = nested_filter::OnlyBodies;\n+\n+    fn nested_visit_map(&mut self) -> Self::Map {\n+        self.provider.tcx.hir()\n+    }\n+\n+    fn visit_param(&mut self, param: &'tcx hir::Param<'tcx>) {\n+        self.add_id(param.hir_id);\n+        intravisit::walk_param(self, param);\n+    }\n+\n+    fn visit_item(&mut self, it: &'tcx hir::Item<'tcx>) {\n+        self.add_id(it.hir_id());\n+        intravisit::walk_item(self, it);\n+    }\n+\n+    fn visit_foreign_item(&mut self, it: &'tcx hir::ForeignItem<'tcx>) {\n+        self.add_id(it.hir_id());\n+        intravisit::walk_foreign_item(self, it);\n+    }\n+\n+    fn visit_stmt(&mut self, e: &'tcx hir::Stmt<'tcx>) {\n+        // We will call `add_id` when we walk\n+        // the `StmtKind`. The outer statement itself doesn't\n+        // define the lint levels.\n+        intravisit::walk_stmt(self, e);\n+    }\n+\n+    fn visit_expr(&mut self, e: &'tcx hir::Expr<'tcx>) {\n+        self.add_id(e.hir_id);\n+        intravisit::walk_expr(self, e);\n+    }\n+\n+    fn visit_field_def(&mut self, s: &'tcx hir::FieldDef<'tcx>) {\n+        self.add_id(s.hir_id);\n+        intravisit::walk_field_def(self, s);\n+    }\n+\n+    fn visit_variant(&mut self, v: &'tcx hir::Variant<'tcx>) {\n+        self.add_id(v.id);\n+        intravisit::walk_variant(self, v);\n+    }\n+\n+    fn visit_local(&mut self, l: &'tcx hir::Local<'tcx>) {\n+        self.add_id(l.hir_id);\n+        intravisit::walk_local(self, l);\n+    }\n+\n+    fn visit_arm(&mut self, a: &'tcx hir::Arm<'tcx>) {\n+        self.add_id(a.hir_id);\n+        intravisit::walk_arm(self, a);\n+    }\n+\n+    fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem<'tcx>) {\n+        self.add_id(trait_item.hir_id());\n+        intravisit::walk_trait_item(self, trait_item);\n+    }\n+\n+    fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem<'tcx>) {\n+        self.add_id(impl_item.hir_id());\n+        intravisit::walk_impl_item(self, impl_item);\n+    }\n+}\n+\n+impl<'tcx> LintLevelsBuilder<'_, QueryMapExpectationsWrapper<'tcx>> {\n+    fn add_id(&mut self, hir_id: HirId) {\n+        self.provider.cur = hir_id;\n+        self.add(self.provider.tcx.hir().attrs(hir_id), hir_id == hir::CRATE_HIR_ID, Some(hir_id));\n+    }\n+}\n+\n+impl<'tcx> Visitor<'tcx> for LintLevelsBuilder<'_, QueryMapExpectationsWrapper<'tcx>> {\n+    type NestedFilter = nested_filter::All;\n+\n+    fn nested_visit_map(&mut self) -> Self::Map {\n+        self.provider.tcx.hir()\n+    }\n+\n+    fn visit_param(&mut self, param: &'tcx hir::Param<'tcx>) {\n+        self.add_id(param.hir_id);\n+        intravisit::walk_param(self, param);\n+    }\n+\n+    fn visit_item(&mut self, it: &'tcx hir::Item<'tcx>) {\n+        self.add_id(it.hir_id());\n+        intravisit::walk_item(self, it);\n+    }\n+\n+    fn visit_foreign_item(&mut self, it: &'tcx hir::ForeignItem<'tcx>) {\n+        self.add_id(it.hir_id());\n+        intravisit::walk_foreign_item(self, it);\n+    }\n+\n+    fn visit_stmt(&mut self, e: &'tcx hir::Stmt<'tcx>) {\n+        // We will call `add_id` when we walk\n+        // the `StmtKind`. The outer statement itself doesn't\n+        // define the lint levels.\n+        intravisit::walk_stmt(self, e);\n+    }\n+\n+    fn visit_expr(&mut self, e: &'tcx hir::Expr<'tcx>) {\n+        self.add_id(e.hir_id);\n+        intravisit::walk_expr(self, e);\n+    }\n+\n+    fn visit_field_def(&mut self, s: &'tcx hir::FieldDef<'tcx>) {\n+        self.add_id(s.hir_id);\n+        intravisit::walk_field_def(self, s);\n+    }\n+\n+    fn visit_variant(&mut self, v: &'tcx hir::Variant<'tcx>) {\n+        self.add_id(v.id);\n+        intravisit::walk_variant(self, v);\n+    }\n+\n+    fn visit_local(&mut self, l: &'tcx hir::Local<'tcx>) {\n+        self.add_id(l.hir_id);\n+        intravisit::walk_local(self, l);\n+    }\n+\n+    fn visit_arm(&mut self, a: &'tcx hir::Arm<'tcx>) {\n+        self.add_id(a.hir_id);\n+        intravisit::walk_arm(self, a);\n+    }\n+\n+    fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem<'tcx>) {\n+        self.add_id(trait_item.hir_id());\n+        intravisit::walk_trait_item(self, trait_item);\n+    }\n+\n+    fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem<'tcx>) {\n+        self.add_id(impl_item.hir_id());\n+        intravisit::walk_impl_item(self, impl_item);\n+    }\n+}\n+\n+pub struct LintLevelsBuilder<'s, P> {\n+    sess: &'s Session,\n+    provider: P,\n     warn_about_weird_lints: bool,\n     store: &'s LintStore,\n     registered_tools: &'s RegisteredTools,\n }\n \n-pub struct BuilderPush {\n+pub(crate) struct BuilderPush {\n     prev: LintStackIndex,\n-    pub changed: bool,\n }\n \n-impl<'s> LintLevelsBuilder<'s> {\n-    pub fn new(\n+impl<'s> LintLevelsBuilder<'s, TopDown> {\n+    pub(crate) fn new(\n         sess: &'s Session,\n         warn_about_weird_lints: bool,\n         store: &'s LintStore,\n         registered_tools: &'s RegisteredTools,\n     ) -> Self {\n         let mut builder = LintLevelsBuilder {\n             sess,\n-            lint_expectations: Default::default(),\n-            expectation_id_map: Default::default(),\n-            sets: LintLevelSets::new(),\n-            cur: COMMAND_LINE,\n-            id_to_set: Default::default(),\n+            provider: TopDown { sets: LintLevelSets::new(), cur: COMMAND_LINE },\n             warn_about_weird_lints,\n             store,\n             registered_tools,\n         };\n-        builder.process_command_line(sess, store);\n-        assert_eq!(builder.sets.list.len(), 1);\n+        builder.process_command_line();\n+        assert_eq!(builder.provider.sets.list.len(), 1);\n         builder\n     }\n \n+    fn process_command_line(&mut self) {\n+        self.provider.cur = self\n+            .provider\n+            .sets\n+            .list\n+            .push(LintSet { specs: FxHashMap::default(), parent: COMMAND_LINE });\n+        self.add_command_line();\n+    }\n+\n+    /// Pushes a list of AST lint attributes onto this context.\n+    ///\n+    /// This function will return a `BuilderPush` object which should be passed\n+    /// to `pop` when this scope for the attributes provided is exited.\n+    ///\n+    /// This function will perform a number of tasks:\n+    ///\n+    /// * It'll validate all lint-related attributes in `attrs`\n+    /// * It'll mark all lint-related attributes as used\n+    /// * Lint levels will be updated based on the attributes provided\n+    /// * Lint attributes are validated, e.g., a `#[forbid]` can't be switched to\n+    ///   `#[allow]`\n+    ///\n+    /// Don't forget to call `pop`!\n+    pub(crate) fn push(\n+        &mut self,\n+        attrs: &[ast::Attribute],\n+        is_crate_node: bool,\n+        source_hir_id: Option<HirId>,\n+    ) -> BuilderPush {\n+        let prev = self.provider.cur;\n+        self.provider.cur =\n+            self.provider.sets.list.push(LintSet { specs: FxHashMap::default(), parent: prev });\n+\n+        self.add(attrs, is_crate_node, source_hir_id);\n+\n+        if self.provider.current_specs().is_empty() {\n+            self.provider.sets.list.pop();\n+            self.provider.cur = prev;\n+        }\n+\n+        BuilderPush { prev }\n+    }\n+\n+    /// Called after `push` when the scope of a set of attributes are exited.\n+    pub(crate) fn pop(&mut self, push: BuilderPush) {\n+        self.provider.cur = push.prev;\n+        std::mem::forget(push);\n+    }\n+}\n+\n+#[cfg(debug_assertions)]\n+impl Drop for BuilderPush {\n+    fn drop(&mut self) {\n+        panic!(\"Found a `push` without a `pop`.\");\n+    }\n+}\n+\n+impl<'s, P: LintLevelsProvider> LintLevelsBuilder<'s, P> {\n     pub(crate) fn sess(&self) -> &Session {\n         self.sess\n     }\n@@ -98,24 +515,20 @@ impl<'s> LintLevelsBuilder<'s> {\n     }\n \n     fn current_specs(&self) -> &FxHashMap<LintId, LevelAndSource> {\n-        &self.sets.list[self.cur].specs\n+        self.provider.current_specs()\n     }\n \n-    fn current_specs_mut(&mut self) -> &mut FxHashMap<LintId, LevelAndSource> {\n-        &mut self.sets.list[self.cur].specs\n+    fn insert(&mut self, id: LintId, lvl: LevelAndSource) {\n+        self.provider.insert(id, lvl)\n     }\n \n-    fn process_command_line(&mut self, sess: &Session, store: &LintStore) {\n-        self.sets.lint_cap = sess.opts.lint_cap.unwrap_or(Level::Forbid);\n-\n-        self.cur =\n-            self.sets.list.push(LintSet { specs: FxHashMap::default(), parent: COMMAND_LINE });\n-        for &(ref lint_name, level) in &sess.opts.lint_opts {\n-            store.check_lint_name_cmdline(sess, &lint_name, level, self.registered_tools);\n+    fn add_command_line(&mut self) {\n+        for &(ref lint_name, level) in &self.sess.opts.lint_opts {\n+            self.store.check_lint_name_cmdline(self.sess, &lint_name, level, self.registered_tools);\n             let orig_level = level;\n             let lint_flag_val = Symbol::intern(lint_name);\n \n-            let Ok(ids) = store.find_lints(&lint_name) else {\n+            let Ok(ids) = self.store.find_lints(&lint_name) else {\n                 // errors handled in check_lint_name_cmdline above\n                 continue\n             };\n@@ -129,7 +542,7 @@ impl<'s> LintLevelsBuilder<'s> {\n \n                 if self.check_gated_lint(id, DUMMY_SP) {\n                     let src = LintLevelSource::CommandLine(lint_flag_val, orig_level);\n-                    self.current_specs_mut().insert(id, (level, src));\n+                    self.insert(id, (level, src));\n                 }\n             }\n         }\n@@ -138,9 +551,11 @@ impl<'s> LintLevelsBuilder<'s> {\n     /// Attempts to insert the `id` to `level_src` map entry. If unsuccessful\n     /// (e.g. if a forbid was already inserted on the same scope), then emits a\n     /// diagnostic with no change to `specs`.\n-    fn insert_spec(&mut self, id: LintId, (level, src): LevelAndSource) {\n-        let (old_level, old_src) =\n-            self.sets.get_lint_level(id.lint, self.cur, Some(self.current_specs()), &self.sess);\n+    fn insert_spec(&mut self, id: LintId, (mut level, src): LevelAndSource) {\n+        let (old_level, old_src) = self.provider.get_lint_level(id.lint, &self.sess);\n+        if let Level::Expect(id) = &mut level && let LintExpectationId::Stable { .. } = id {\n+            *id = id.normalize();\n+        }\n         // Setting to a non-forbid level is an error if the lint previously had\n         // a forbid level. Note that this is not necessarily true even with a\n         // `#[forbid(..)]` attribute present, as that is overridden by `--cap-lints`.\n@@ -158,7 +573,7 @@ impl<'s> LintLevelsBuilder<'s> {\n                 let id_name = id.lint.name_lower();\n                 let fcw_warning = match old_src {\n                     LintLevelSource::Default => false,\n-                    LintLevelSource::Node(symbol, _, _) => self.store.is_lint_group(symbol),\n+                    LintLevelSource::Node { name, .. } => self.store.is_lint_group(name),\n                     LintLevelSource::CommandLine(symbol, _) => self.store.is_lint_group(symbol),\n                 };\n                 debug!(\n@@ -178,8 +593,8 @@ impl<'s> LintLevelsBuilder<'s> {\n                                 id.to_string()\n                             ));\n                         }\n-                        LintLevelSource::Node(_, forbid_source_span, reason) => {\n-                            diag.span_label(forbid_source_span, \"`forbid` level set here\");\n+                        LintLevelSource::Node { span, reason, .. } => {\n+                            diag.span_label(span, \"`forbid` level set here\");\n                             if let Some(rationale) = reason {\n                                 diag.note(rationale.as_str());\n                             }\n@@ -199,11 +614,8 @@ impl<'s> LintLevelsBuilder<'s> {\n                             LintLevelSource::Default => {\n                                 OverruledAttributeSub::DefaultSource { id: id.to_string() }\n                             }\n-                            LintLevelSource::Node(_, forbid_source_span, reason) => {\n-                                OverruledAttributeSub::NodeSource {\n-                                    span: forbid_source_span,\n-                                    reason,\n-                                }\n+                            LintLevelSource::Node { span, reason, .. } => {\n+                                OverruledAttributeSub::NodeSource { span, reason }\n                             }\n                             LintLevelSource::CommandLine(_, _) => {\n                                 OverruledAttributeSub::CommandLineSource\n@@ -244,45 +656,21 @@ impl<'s> LintLevelsBuilder<'s> {\n \n         match (old_level, level) {\n             // If the new level is an expectation store it in `ForceWarn`\n-            (Level::ForceWarn(_), Level::Expect(expectation_id)) => self\n-                .current_specs_mut()\n-                .insert(id, (Level::ForceWarn(Some(expectation_id)), old_src)),\n-            // Keep `ForceWarn` level but drop the expectation\n-            (Level::ForceWarn(_), _) => {\n-                self.current_specs_mut().insert(id, (Level::ForceWarn(None), old_src))\n+            (Level::ForceWarn(_), Level::Expect(expectation_id)) => {\n+                self.insert(id, (Level::ForceWarn(Some(expectation_id)), old_src))\n             }\n+            // Keep `ForceWarn` level but drop the expectation\n+            (Level::ForceWarn(_), _) => self.insert(id, (Level::ForceWarn(None), old_src)),\n             // Set the lint level as normal\n-            _ => self.current_specs_mut().insert(id, (level, src)),\n+            _ => self.insert(id, (level, src)),\n         };\n     }\n \n-    /// Pushes a list of AST lint attributes onto this context.\n-    ///\n-    /// This function will return a `BuilderPush` object which should be passed\n-    /// to `pop` when this scope for the attributes provided is exited.\n-    ///\n-    /// This function will perform a number of tasks:\n-    ///\n-    /// * It'll validate all lint-related attributes in `attrs`\n-    /// * It'll mark all lint-related attributes as used\n-    /// * Lint levels will be updated based on the attributes provided\n-    /// * Lint attributes are validated, e.g., a `#[forbid]` can't be switched to\n-    ///   `#[allow]`\n-    ///\n-    /// Don't forget to call `pop`!\n-    pub(crate) fn push(\n-        &mut self,\n-        attrs: &[ast::Attribute],\n-        is_crate_node: bool,\n-        source_hir_id: Option<HirId>,\n-    ) -> BuilderPush {\n-        let prev = self.cur;\n-        self.cur = self.sets.list.push(LintSet { specs: FxHashMap::default(), parent: prev });\n-\n+    fn add(&mut self, attrs: &[ast::Attribute], is_crate_node: bool, source_hir_id: Option<HirId>) {\n         let sess = self.sess;\n         for (attr_index, attr) in attrs.iter().enumerate() {\n             if attr.has_name(sym::automatically_derived) {\n-                self.current_specs_mut().insert(\n+                self.insert(\n                     LintId::of(SINGLE_USE_LIFETIMES),\n                     (Level::Allow, LintLevelSource::Default),\n                 );\n@@ -293,7 +681,17 @@ impl<'s> LintLevelsBuilder<'s> {\n                 None => continue,\n                 // This is the only lint level with a `LintExpectationId` that can be created from an attribute\n                 Some(Level::Expect(unstable_id)) if let Some(hir_id) = source_hir_id => {\n-                    let stable_id = self.create_stable_id(unstable_id, hir_id, attr_index);\n+                    let LintExpectationId::Unstable { attr_id, lint_index } = unstable_id\n+                        else { bug!(\"stable id Level::from_attr\") };\n+\n+                    let stable_id = LintExpectationId::Stable {\n+                        hir_id,\n+                        attr_index: attr_index.try_into().unwrap(),\n+                        lint_index,\n+                        // we pass the previous unstable attr_id such that we can trace the ast id when building a map\n+                        // to go from unstable to stable id.\n+                        attr_id: Some(attr_id),\n+                    };\n \n                     Level::Expect(stable_id)\n                 }\n@@ -408,21 +806,27 @@ impl<'s> LintLevelsBuilder<'s> {\n                                 [lint] => *lint == LintId::of(UNFULFILLED_LINT_EXPECTATIONS),\n                                 _ => false,\n                             };\n-                            self.lint_expectations.push((\n+                            self.provider.push_expectation(\n                                 expect_id,\n                                 LintExpectation::new(\n                                     reason,\n                                     sp,\n                                     is_unfulfilled_lint_expectations,\n                                     tool_name,\n                                 ),\n-                            ));\n+                            );\n                         }\n-                        let src = LintLevelSource::Node(\n-                            meta_item.path.segments.last().expect(\"empty lint name\").ident.name,\n-                            sp,\n+                        let src = LintLevelSource::Node {\n+                            name: meta_item\n+                                .path\n+                                .segments\n+                                .last()\n+                                .expect(\"empty lint name\")\n+                                .ident\n+                                .name,\n+                            span: sp,\n                             reason,\n-                        );\n+                        };\n                         for &id in *ids {\n                             if self.check_gated_lint(id, attr.span) {\n                                 self.insert_spec(id, (level, src));\n@@ -435,31 +839,26 @@ impl<'s> LintLevelsBuilder<'s> {\n                             Ok(ids) => {\n                                 let complete_name =\n                                     &format!(\"{}::{}\", tool_ident.unwrap().name, name);\n-                                let src = LintLevelSource::Node(\n-                                    Symbol::intern(complete_name),\n-                                    sp,\n+                                let src = LintLevelSource::Node {\n+                                    name: Symbol::intern(complete_name),\n+                                    span: sp,\n                                     reason,\n-                                );\n+                                };\n                                 for &id in ids {\n                                     if self.check_gated_lint(id, attr.span) {\n                                         self.insert_spec(id, (level, src));\n                                     }\n                                 }\n                                 if let Level::Expect(expect_id) = level {\n-                                    self.lint_expectations.push((\n+                                    self.provider.push_expectation(\n                                         expect_id,\n                                         LintExpectation::new(reason, sp, false, tool_name),\n-                                    ));\n+                                    );\n                                 }\n                             }\n                             Err((Some(ids), ref new_lint_name)) => {\n                                 let lint = builtin::RENAMED_AND_REMOVED_LINTS;\n-                                let (lvl, src) = self.sets.get_lint_level(\n-                                    lint,\n-                                    self.cur,\n-                                    Some(self.current_specs()),\n-                                    &sess,\n-                                );\n+                                let (lvl, src) = self.provider.get_lint_level(lint, &sess);\n                                 struct_lint_level(\n                                     self.sess,\n                                     lint,\n@@ -481,19 +880,19 @@ impl<'s> LintLevelsBuilder<'s> {\n                                     },\n                                 );\n \n-                                let src = LintLevelSource::Node(\n-                                    Symbol::intern(&new_lint_name),\n-                                    sp,\n+                                let src = LintLevelSource::Node {\n+                                    name: Symbol::intern(&new_lint_name),\n+                                    span: sp,\n                                     reason,\n-                                );\n+                                };\n                                 for id in ids {\n                                     self.insert_spec(*id, (level, src));\n                                 }\n                                 if let Level::Expect(expect_id) = level {\n-                                    self.lint_expectations.push((\n+                                    self.provider.push_expectation(\n                                         expect_id,\n                                         LintExpectation::new(reason, sp, false, tool_name),\n-                                    ));\n+                                    );\n                                 }\n                             }\n                             Err((None, _)) => {\n@@ -519,12 +918,7 @@ impl<'s> LintLevelsBuilder<'s> {\n \n                     CheckLintNameResult::Warning(msg, renamed) => {\n                         let lint = builtin::RENAMED_AND_REMOVED_LINTS;\n-                        let (renamed_lint_level, src) = self.sets.get_lint_level(\n-                            lint,\n-                            self.cur,\n-                            Some(self.current_specs()),\n-                            &sess,\n-                        );\n+                        let (renamed_lint_level, src) = self.provider.get_lint_level(lint, &sess);\n                         struct_lint_level(\n                             self.sess,\n                             lint,\n@@ -547,12 +941,7 @@ impl<'s> LintLevelsBuilder<'s> {\n                     }\n                     CheckLintNameResult::NoLint(suggestion) => {\n                         let lint = builtin::UNKNOWN_LINTS;\n-                        let (level, src) = self.sets.get_lint_level(\n-                            lint,\n-                            self.cur,\n-                            Some(self.current_specs()),\n-                            self.sess,\n-                        );\n+                        let (level, src) = self.provider.get_lint_level(lint, self.sess);\n                         let name = if let Some(tool_ident) = tool_ident {\n                             format!(\"{}::{}\", tool_ident.name, name)\n                         } else {\n@@ -588,17 +977,21 @@ impl<'s> LintLevelsBuilder<'s> {\n                     if let CheckLintNameResult::Ok(ids) =\n                         self.store.check_lint_name(&new_name, None, self.registered_tools)\n                     {\n-                        let src = LintLevelSource::Node(Symbol::intern(&new_name), sp, reason);\n+                        let src = LintLevelSource::Node {\n+                            name: Symbol::intern(&new_name),\n+                            span: sp,\n+                            reason,\n+                        };\n                         for &id in ids {\n                             if self.check_gated_lint(id, attr.span) {\n                                 self.insert_spec(id, (level, src));\n                             }\n                         }\n                         if let Level::Expect(expect_id) = level {\n-                            self.lint_expectations.push((\n+                            self.provider.push_expectation(\n                                 expect_id,\n                                 LintExpectation::new(reason, sp, false, tool_name),\n-                            ));\n+                            );\n                         }\n                     } else {\n                         panic!(\"renamed lint does not exist: {}\", new_name);\n@@ -613,13 +1006,12 @@ impl<'s> LintLevelsBuilder<'s> {\n                     continue;\n                 }\n \n-                let LintLevelSource::Node(lint_attr_name, lint_attr_span, _) = *src else {\n+                let LintLevelSource::Node { name: lint_attr_name, span: lint_attr_span, .. } = *src else {\n                     continue\n                 };\n \n                 let lint = builtin::UNUSED_ATTRIBUTES;\n-                let (lint_level, lint_src) =\n-                    self.sets.get_lint_level(lint, self.cur, Some(self.current_specs()), self.sess);\n+                let (lint_level, lint_src) = self.provider.get_lint_level(lint, &self.sess);\n                 struct_lint_level(\n                     self.sess,\n                     lint,\n@@ -637,32 +1029,13 @@ impl<'s> LintLevelsBuilder<'s> {\n                 break;\n             }\n         }\n-\n-        if self.current_specs().is_empty() {\n-            self.sets.list.pop();\n-            self.cur = prev;\n-        }\n-\n-        BuilderPush { prev, changed: prev != self.cur }\n-    }\n-\n-    fn create_stable_id(\n-        &mut self,\n-        unstable_id: LintExpectationId,\n-        hir_id: HirId,\n-        attr_index: usize,\n-    ) -> LintExpectationId {\n-        let stable_id =\n-            LintExpectationId::Stable { hir_id, attr_index: attr_index as u16, lint_index: None };\n-\n-        self.expectation_id_map.insert(unstable_id, stable_id);\n-\n-        stable_id\n     }\n \n     /// Checks if the lint is gated on a feature that is not enabled.\n     ///\n     /// Returns `true` if the lint's feature is enabled.\n+    // FIXME only emit this once for each attribute, instead of repeating it 4 times for\n+    // pre-expansion lints, post-expansion lints, `shallow_lint_levels_on` and `lint_expectations`.\n     fn check_gated_lint(&self, lint_id: LintId, span: Span) -> bool {\n         if let Some(feature) = lint_id.lint.feature_gate {\n             if !self.sess.features_untracked().enabled(feature) {\n@@ -689,19 +1062,14 @@ impl<'s> LintLevelsBuilder<'s> {\n         true\n     }\n \n-    /// Called after `push` when the scope of a set of attributes are exited.\n-    pub fn pop(&mut self, push: BuilderPush) {\n-        self.cur = push.prev;\n-    }\n-\n     /// Find the lint level for a lint.\n-    pub fn lint_level(&self, lint: &'static Lint) -> (Level, LintLevelSource) {\n-        self.sets.get_lint_level(lint, self.cur, None, self.sess)\n+    pub fn lint_level(&self, lint: &'static Lint) -> LevelAndSource {\n+        self.provider.get_lint_level(lint, self.sess)\n     }\n \n     /// Used to emit a lint-related diagnostic based on the current state of\n     /// this lint context.\n-    pub fn struct_lint(\n+    pub(crate) fn struct_lint(\n         &self,\n         lint: &'static Lint,\n         span: Option<MultiSpan>,\n@@ -713,141 +1081,8 @@ impl<'s> LintLevelsBuilder<'s> {\n         let (level, src) = self.lint_level(lint);\n         struct_lint_level(self.sess, lint, level, src, span, msg, decorate)\n     }\n-\n-    /// Registers the ID provided with the current set of lints stored in\n-    /// this context.\n-    pub fn register_id(&mut self, id: HirId) {\n-        self.id_to_set.insert(id, self.cur);\n-    }\n-\n-    fn update_unstable_expectation_ids(&self) {\n-        self.sess.diagnostic().update_unstable_expectation_id(&self.expectation_id_map);\n-    }\n-\n-    pub fn build_map(self) -> LintLevelMap {\n-        LintLevelMap {\n-            sets: self.sets,\n-            id_to_set: self.id_to_set,\n-            lint_expectations: self.lint_expectations,\n-        }\n-    }\n-}\n-\n-struct LintLevelMapBuilder<'tcx> {\n-    levels: LintLevelsBuilder<'tcx>,\n-    tcx: TyCtxt<'tcx>,\n-}\n-\n-impl LintLevelMapBuilder<'_> {\n-    fn with_lint_attrs<F>(&mut self, id: hir::HirId, f: F)\n-    where\n-        F: FnOnce(&mut Self),\n-    {\n-        let is_crate_hir = id == hir::CRATE_HIR_ID;\n-        let attrs = self.tcx.hir().attrs(id);\n-        let push = self.levels.push(attrs, is_crate_hir, Some(id));\n-\n-        if push.changed {\n-            self.levels.register_id(id);\n-        }\n-        f(self);\n-        self.levels.pop(push);\n-    }\n-}\n-\n-impl<'tcx> intravisit::Visitor<'tcx> for LintLevelMapBuilder<'tcx> {\n-    type NestedFilter = nested_filter::All;\n-\n-    fn nested_visit_map(&mut self) -> Self::Map {\n-        self.tcx.hir()\n-    }\n-\n-    fn visit_param(&mut self, param: &'tcx hir::Param<'tcx>) {\n-        self.with_lint_attrs(param.hir_id, |builder| {\n-            intravisit::walk_param(builder, param);\n-        });\n-    }\n-\n-    fn visit_item(&mut self, it: &'tcx hir::Item<'tcx>) {\n-        self.with_lint_attrs(it.hir_id(), |builder| {\n-            intravisit::walk_item(builder, it);\n-        });\n-    }\n-\n-    fn visit_foreign_item(&mut self, it: &'tcx hir::ForeignItem<'tcx>) {\n-        self.with_lint_attrs(it.hir_id(), |builder| {\n-            intravisit::walk_foreign_item(builder, it);\n-        })\n-    }\n-\n-    fn visit_stmt(&mut self, e: &'tcx hir::Stmt<'tcx>) {\n-        // We will call `with_lint_attrs` when we walk\n-        // the `StmtKind`. The outer statement itself doesn't\n-        // define the lint levels.\n-        intravisit::walk_stmt(self, e);\n-    }\n-\n-    fn visit_expr(&mut self, e: &'tcx hir::Expr<'tcx>) {\n-        self.with_lint_attrs(e.hir_id, |builder| {\n-            intravisit::walk_expr(builder, e);\n-        })\n-    }\n-\n-    fn visit_expr_field(&mut self, field: &'tcx hir::ExprField<'tcx>) {\n-        self.with_lint_attrs(field.hir_id, |builder| {\n-            intravisit::walk_expr_field(builder, field);\n-        })\n-    }\n-\n-    fn visit_field_def(&mut self, s: &'tcx hir::FieldDef<'tcx>) {\n-        self.with_lint_attrs(s.hir_id, |builder| {\n-            intravisit::walk_field_def(builder, s);\n-        })\n-    }\n-\n-    fn visit_variant(&mut self, v: &'tcx hir::Variant<'tcx>) {\n-        self.with_lint_attrs(v.id, |builder| {\n-            intravisit::walk_variant(builder, v);\n-        })\n-    }\n-\n-    fn visit_local(&mut self, l: &'tcx hir::Local<'tcx>) {\n-        self.with_lint_attrs(l.hir_id, |builder| {\n-            intravisit::walk_local(builder, l);\n-        })\n-    }\n-\n-    fn visit_arm(&mut self, a: &'tcx hir::Arm<'tcx>) {\n-        self.with_lint_attrs(a.hir_id, |builder| {\n-            intravisit::walk_arm(builder, a);\n-        })\n-    }\n-\n-    fn visit_trait_item(&mut self, trait_item: &'tcx hir::TraitItem<'tcx>) {\n-        self.with_lint_attrs(trait_item.hir_id(), |builder| {\n-            intravisit::walk_trait_item(builder, trait_item);\n-        });\n-    }\n-\n-    fn visit_impl_item(&mut self, impl_item: &'tcx hir::ImplItem<'tcx>) {\n-        self.with_lint_attrs(impl_item.hir_id(), |builder| {\n-            intravisit::walk_impl_item(builder, impl_item);\n-        });\n-    }\n-\n-    fn visit_pat_field(&mut self, field: &'tcx hir::PatField<'tcx>) {\n-        self.with_lint_attrs(field.hir_id, |builder| {\n-            intravisit::walk_pat_field(builder, field);\n-        })\n-    }\n-\n-    fn visit_generic_param(&mut self, p: &'tcx hir::GenericParam<'tcx>) {\n-        self.with_lint_attrs(p.hir_id, |builder| {\n-            intravisit::walk_generic_param(builder, p);\n-        });\n-    }\n }\n \n-pub fn provide(providers: &mut Providers) {\n-    providers.lint_levels = lint_levels;\n+pub(crate) fn provide(providers: &mut Providers) {\n+    *providers = Providers { shallow_lint_levels_on, lint_expectations, ..*providers };\n }"}, {"sha": "cbe7afc8e5558b2e2fe0bbe79f183d6ddf42c52a", "filename": "compiler/rustc_lint_defs/src/lib.rs", "status": "modified", "additions": 26, "deletions": 5, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/57f097ea25f2c05f424fc9b9dc50dbd6d399845c/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57f097ea25f2c05f424fc9b9dc50dbd6d399845c/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint_defs%2Fsrc%2Flib.rs?ref=57f097ea25f2c05f424fc9b9dc50dbd6d399845c", "patch": "@@ -92,7 +92,7 @@ pub enum LintExpectationId {\n     /// stable and can be cached. The additional index ensures that nodes with\n     /// several expectations can correctly match diagnostics to the individual\n     /// expectation.\n-    Stable { hir_id: HirId, attr_index: u16, lint_index: Option<u16> },\n+    Stable { hir_id: HirId, attr_index: u16, lint_index: Option<u16>, attr_id: Option<AttrId> },\n }\n \n impl LintExpectationId {\n@@ -116,13 +116,31 @@ impl LintExpectationId {\n \n         *lint_index = new_lint_index\n     }\n+\n+    /// Prepares the id for hashing. Removes references to the ast.\n+    /// Should only be called when the id is stable.\n+    pub fn normalize(self) -> Self {\n+        match self {\n+            Self::Stable { hir_id, attr_index, lint_index, .. } => {\n+                Self::Stable { hir_id, attr_index, lint_index, attr_id: None }\n+            }\n+            Self::Unstable { .. } => {\n+                unreachable!(\"`normalize` called when `ExpectationId` is unstable\")\n+            }\n+        }\n+    }\n }\n \n impl<HCX: rustc_hir::HashStableContext> HashStable<HCX> for LintExpectationId {\n     #[inline]\n     fn hash_stable(&self, hcx: &mut HCX, hasher: &mut StableHasher) {\n         match self {\n-            LintExpectationId::Stable { hir_id, attr_index, lint_index: Some(lint_index) } => {\n+            LintExpectationId::Stable {\n+                hir_id,\n+                attr_index,\n+                lint_index: Some(lint_index),\n+                attr_id: _,\n+            } => {\n                 hir_id.hash_stable(hcx, hasher);\n                 attr_index.hash_stable(hcx, hasher);\n                 lint_index.hash_stable(hcx, hasher);\n@@ -142,9 +160,12 @@ impl<HCX: rustc_hir::HashStableContext> ToStableHashKey<HCX> for LintExpectation\n     #[inline]\n     fn to_stable_hash_key(&self, _: &HCX) -> Self::KeyType {\n         match self {\n-            LintExpectationId::Stable { hir_id, attr_index, lint_index: Some(lint_index) } => {\n-                (*hir_id, *attr_index, *lint_index)\n-            }\n+            LintExpectationId::Stable {\n+                hir_id,\n+                attr_index,\n+                lint_index: Some(lint_index),\n+                attr_id: _,\n+            } => (*hir_id, *attr_index, *lint_index),\n             _ => {\n                 unreachable!(\"HashStable should only be called for a filled `LintExpectationId`\")\n             }"}, {"sha": "6b556826918553293eb98bd13d943192b94b2445", "filename": "compiler/rustc_middle/src/dep_graph/dep_node.rs", "status": "modified", "additions": 32, "deletions": 6, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/57f097ea25f2c05f424fc9b9dc50dbd6d399845c/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fdep_node.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57f097ea25f2c05f424fc9b9dc50dbd6d399845c/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fdep_node.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fdep_graph%2Fdep_node.rs?ref=57f097ea25f2c05f424fc9b9dc50dbd6d399845c", "patch": "@@ -62,7 +62,7 @@ use crate::ty::TyCtxt;\n use rustc_data_structures::fingerprint::Fingerprint;\n use rustc_hir::def_id::{CrateNum, DefId, LocalDefId};\n use rustc_hir::definitions::DefPathHash;\n-use rustc_hir::{HirId, OwnerId};\n+use rustc_hir::{HirId, ItemLocalId, OwnerId};\n use rustc_query_system::dep_graph::FingerprintStyle;\n use rustc_span::symbol::Symbol;\n use std::hash::Hash;\n@@ -194,7 +194,7 @@ impl DepNodeExt for DepNode {\n         let kind = dep_kind_from_label_string(label)?;\n \n         match tcx.fingerprint_style(kind) {\n-            FingerprintStyle::Opaque => Err(()),\n+            FingerprintStyle::Opaque | FingerprintStyle::HirId => Err(()),\n             FingerprintStyle::Unit => Ok(DepNode::new_no_params(tcx, kind)),\n             FingerprintStyle::DefPathHash => {\n                 Ok(DepNode::from_def_path_hash(tcx, def_path_hash, kind))\n@@ -344,7 +344,7 @@ impl<'tcx> DepNodeParams<TyCtxt<'tcx>> for (DefId, DefId) {\n impl<'tcx> DepNodeParams<TyCtxt<'tcx>> for HirId {\n     #[inline(always)]\n     fn fingerprint_style() -> FingerprintStyle {\n-        FingerprintStyle::Opaque\n+        FingerprintStyle::HirId\n     }\n \n     // We actually would not need to specialize the implementation of this\n@@ -353,10 +353,36 @@ impl<'tcx> DepNodeParams<TyCtxt<'tcx>> for HirId {\n     #[inline(always)]\n     fn to_fingerprint(&self, tcx: TyCtxt<'tcx>) -> Fingerprint {\n         let HirId { owner, local_id } = *self;\n-\n         let def_path_hash = tcx.def_path_hash(owner.to_def_id());\n-        let local_id = Fingerprint::from_smaller_hash(local_id.as_u32().into());\n+        Fingerprint::new(\n+            // `owner` is local, so is completely defined by the local hash\n+            def_path_hash.local_hash(),\n+            local_id.as_u32().into(),\n+        )\n+    }\n \n-        def_path_hash.0.combine(local_id)\n+    #[inline(always)]\n+    fn to_debug_str(&self, tcx: TyCtxt<'tcx>) -> String {\n+        let HirId { owner, local_id } = *self;\n+        format!(\"{}.{}\", tcx.def_path_str(owner.to_def_id()), local_id.as_u32())\n+    }\n+\n+    #[inline(always)]\n+    fn recover(tcx: TyCtxt<'tcx>, dep_node: &DepNode) -> Option<Self> {\n+        if tcx.fingerprint_style(dep_node.kind) == FingerprintStyle::HirId {\n+            let (local_hash, local_id) = Fingerprint::from(dep_node.hash).as_value();\n+            let def_path_hash = DefPathHash::new(tcx.sess.local_stable_crate_id(), local_hash);\n+            let def_id = tcx\n+                .def_path_hash_to_def_id(def_path_hash, &mut || {\n+                    panic!(\"Failed to extract HirId: {:?} {}\", dep_node.kind, dep_node.hash)\n+                })\n+                .expect_local();\n+            let local_id = local_id\n+                .try_into()\n+                .unwrap_or_else(|_| panic!(\"local id should be u32, found {:?}\", local_id));\n+            Some(HirId { owner: OwnerId { def_id }, local_id: ItemLocalId::from_u32(local_id) })\n+        } else {\n+            None\n+        }\n     }\n }"}, {"sha": "36f748f561a68702881336bcc9c6606163043e00", "filename": "compiler/rustc_middle/src/hir/map/mod.rs", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/57f097ea25f2c05f424fc9b9dc50dbd6d399845c/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57f097ea25f2c05f424fc9b9dc50dbd6d399845c/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fhir%2Fmap%2Fmod.rs?ref=57f097ea25f2c05f424fc9b9dc50dbd6d399845c", "patch": "@@ -61,7 +61,7 @@ pub struct ParentHirIterator<'hir> {\n }\n \n impl<'hir> Iterator for ParentHirIterator<'hir> {\n-    type Item = (HirId, Node<'hir>);\n+    type Item = HirId;\n \n     fn next(&mut self) -> Option<Self::Item> {\n         if self.current_id == CRATE_HIR_ID {\n@@ -77,10 +77,7 @@ impl<'hir> Iterator for ParentHirIterator<'hir> {\n             }\n \n             self.current_id = parent_id;\n-            if let Some(node) = self.map.find(parent_id) {\n-                return Some((parent_id, node));\n-            }\n-            // If this `HirId` doesn't have an entry, skip it and look for its `parent_id`.\n+            return Some(parent_id);\n         }\n     }\n }\n@@ -393,8 +390,8 @@ impl<'hir> Map<'hir> {\n     }\n \n     pub fn enclosing_body_owner(self, hir_id: HirId) -> LocalDefId {\n-        for (parent, _) in self.parent_iter(hir_id) {\n-            if let Some(body) = self.find(parent).map(associated_body).flatten() {\n+        for (_, node) in self.parent_iter(hir_id) {\n+            if let Some(body) = associated_body(node) {\n                 return self.body_owner_def_id(body);\n             }\n         }\n@@ -635,10 +632,17 @@ impl<'hir> Map<'hir> {\n     /// Returns an iterator for the nodes in the ancestor tree of the `current_id`\n     /// until the crate root is reached. Prefer this over your own loop using `get_parent_node`.\n     #[inline]\n-    pub fn parent_iter(self, current_id: HirId) -> ParentHirIterator<'hir> {\n+    pub fn parent_id_iter(self, current_id: HirId) -> impl Iterator<Item = HirId> + 'hir {\n         ParentHirIterator { current_id, map: self }\n     }\n \n+    /// Returns an iterator for the nodes in the ancestor tree of the `current_id`\n+    /// until the crate root is reached. Prefer this over your own loop using `get_parent_node`.\n+    #[inline]\n+    pub fn parent_iter(self, current_id: HirId) -> impl Iterator<Item = (HirId, Node<'hir>)> {\n+        self.parent_id_iter(current_id).filter_map(move |id| Some((id, self.find(id)?)))\n+    }\n+\n     /// Returns an iterator for the nodes in the ancestor tree of the `current_id`\n     /// until the crate root is reached. Prefer this over your own loop using `get_parent_node`.\n     #[inline]"}, {"sha": "f3e4f1faeb05c1af7bf4106f6a4ccde6170d0275", "filename": "compiler/rustc_middle/src/lint.rs", "status": "modified", "additions": 123, "deletions": 126, "changes": 249, "blob_url": "https://github.com/rust-lang/rust/blob/57f097ea25f2c05f424fc9b9dc50dbd6d399845c/compiler%2Frustc_middle%2Fsrc%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57f097ea25f2c05f424fc9b9dc50dbd6d399845c/compiler%2Frustc_middle%2Fsrc%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Flint.rs?ref=57f097ea25f2c05f424fc9b9dc50dbd6d399845c", "patch": "@@ -1,20 +1,20 @@\n use std::cmp;\n \n use rustc_data_structures::fx::FxHashMap;\n-use rustc_data_structures::stable_hasher::{HashStable, StableHasher};\n+use rustc_data_structures::sorted_map::SortedMap;\n use rustc_errors::{Diagnostic, DiagnosticBuilder, DiagnosticId, DiagnosticMessage, MultiSpan};\n-use rustc_hir::HirId;\n-use rustc_index::vec::IndexVec;\n-use rustc_query_system::ich::StableHashingContext;\n+use rustc_hir::{HirId, ItemLocalId};\n use rustc_session::lint::{\n     builtin::{self, FORBIDDEN_LINT_GROUPS},\n-    FutureIncompatibilityReason, Level, Lint, LintExpectationId, LintId,\n+    FutureIncompatibilityReason, Level, Lint, LintId,\n };\n use rustc_session::Session;\n use rustc_span::hygiene::MacroKind;\n use rustc_span::source_map::{DesugaringKind, ExpnKind};\n use rustc_span::{symbol, Span, Symbol, DUMMY_SP};\n \n+use crate::ty::TyCtxt;\n+\n /// How a lint level was set.\n #[derive(Clone, Copy, PartialEq, Eq, HashStable, Debug)]\n pub enum LintLevelSource {\n@@ -23,7 +23,12 @@ pub enum LintLevelSource {\n     Default,\n \n     /// Lint level was set by an attribute.\n-    Node(Symbol, Span, Option<Symbol> /* RFC 2383 reason */),\n+    Node {\n+        name: Symbol,\n+        span: Span,\n+        /// RFC 2383 reason\n+        reason: Option<Symbol>,\n+    },\n \n     /// Lint level was set by a command-line flag.\n     /// The provided `Level` is the level specified on the command line.\n@@ -35,15 +40,15 @@ impl LintLevelSource {\n     pub fn name(&self) -> Symbol {\n         match *self {\n             LintLevelSource::Default => symbol::kw::Default,\n-            LintLevelSource::Node(name, _, _) => name,\n+            LintLevelSource::Node { name, .. } => name,\n             LintLevelSource::CommandLine(name, _) => name,\n         }\n     }\n \n     pub fn span(&self) -> Span {\n         match *self {\n             LintLevelSource::Default => DUMMY_SP,\n-            LintLevelSource::Node(_, span, _) => span,\n+            LintLevelSource::Node { span, .. } => span,\n             LintLevelSource::CommandLine(_, _) => DUMMY_SP,\n         }\n     }\n@@ -52,145 +57,137 @@ impl LintLevelSource {\n /// A tuple of a lint level and its source.\n pub type LevelAndSource = (Level, LintLevelSource);\n \n-#[derive(Debug, HashStable)]\n-pub struct LintLevelSets {\n-    pub list: IndexVec<LintStackIndex, LintSet>,\n-    pub lint_cap: Level,\n-}\n-\n-rustc_index::newtype_index! {\n-    #[derive(HashStable)]\n-    pub struct LintStackIndex {\n-        const COMMAND_LINE = 0,\n-    }\n-}\n-\n-#[derive(Debug, HashStable)]\n-pub struct LintSet {\n-    // -A,-W,-D flags, a `Symbol` for the flag itself and `Level` for which\n-    // flag.\n-    pub specs: FxHashMap<LintId, LevelAndSource>,\n-\n-    pub parent: LintStackIndex,\n+/// Return type for the `shallow_lint_levels_on` query.\n+///\n+/// This map represents the set of allowed lints and allowance levels given\n+/// by the attributes for *a single HirId*.\n+#[derive(Default, Debug, HashStable)]\n+pub struct ShallowLintLevelMap {\n+    pub specs: SortedMap<ItemLocalId, FxHashMap<LintId, LevelAndSource>>,\n }\n \n-impl LintLevelSets {\n-    pub fn new() -> Self {\n-        LintLevelSets { list: IndexVec::new(), lint_cap: Level::Forbid }\n-    }\n-\n-    pub fn get_lint_level(\n-        &self,\n-        lint: &'static Lint,\n-        idx: LintStackIndex,\n-        aux: Option<&FxHashMap<LintId, LevelAndSource>>,\n-        sess: &Session,\n-    ) -> LevelAndSource {\n-        let (level, mut src) = self.get_lint_id_level(LintId::of(lint), idx, aux);\n-\n-        // If `level` is none then we actually assume the default level for this\n-        // lint.\n-        let mut level = level.unwrap_or_else(|| lint.default_level(sess.edition()));\n-\n-        // If we're about to issue a warning, check at the last minute for any\n-        // directives against the warnings \"lint\". If, for example, there's an\n-        // `allow(warnings)` in scope then we want to respect that instead.\n-        //\n-        // We exempt `FORBIDDEN_LINT_GROUPS` from this because it specifically\n-        // triggers in cases (like #80988) where you have `forbid(warnings)`,\n-        // and so if we turned that into an error, it'd defeat the purpose of the\n-        // future compatibility warning.\n-        if level == Level::Warn && LintId::of(lint) != LintId::of(FORBIDDEN_LINT_GROUPS) {\n-            let (warnings_level, warnings_src) =\n-                self.get_lint_id_level(LintId::of(builtin::WARNINGS), idx, aux);\n-            if let Some(configured_warning_level) = warnings_level {\n-                if configured_warning_level != Level::Warn {\n-                    level = configured_warning_level;\n-                    src = warnings_src;\n-                }\n+/// From an initial level and source, verify the effect of special annotations:\n+/// `warnings` lint level and lint caps.\n+///\n+/// The return of this function is suitable for diagnostics.\n+pub fn reveal_actual_level(\n+    level: Option<Level>,\n+    src: &mut LintLevelSource,\n+    sess: &Session,\n+    lint: LintId,\n+    probe_for_lint_level: impl FnOnce(LintId) -> (Option<Level>, LintLevelSource),\n+) -> Level {\n+    // If `level` is none then we actually assume the default level for this lint.\n+    let mut level = level.unwrap_or_else(|| lint.lint.default_level(sess.edition()));\n+\n+    // If we're about to issue a warning, check at the last minute for any\n+    // directives against the warnings \"lint\". If, for example, there's an\n+    // `allow(warnings)` in scope then we want to respect that instead.\n+    //\n+    // We exempt `FORBIDDEN_LINT_GROUPS` from this because it specifically\n+    // triggers in cases (like #80988) where you have `forbid(warnings)`,\n+    // and so if we turned that into an error, it'd defeat the purpose of the\n+    // future compatibility warning.\n+    if level == Level::Warn && lint != LintId::of(FORBIDDEN_LINT_GROUPS) {\n+        let (warnings_level, warnings_src) = probe_for_lint_level(LintId::of(builtin::WARNINGS));\n+        if let Some(configured_warning_level) = warnings_level {\n+            if configured_warning_level != Level::Warn {\n+                level = configured_warning_level;\n+                *src = warnings_src;\n             }\n         }\n+    }\n \n-        // Ensure that we never exceed the `--cap-lints` argument\n-        // unless the source is a --force-warn\n-        level = if let LintLevelSource::CommandLine(_, Level::ForceWarn(_)) = src {\n-            level\n-        } else {\n-            cmp::min(level, self.lint_cap)\n-        };\n-\n-        if let Some(driver_level) = sess.driver_lint_caps.get(&LintId::of(lint)) {\n-            // Ensure that we never exceed driver level.\n-            level = cmp::min(*driver_level, level);\n-        }\n+    // Ensure that we never exceed the `--cap-lints` argument unless the source is a --force-warn\n+    level = if let LintLevelSource::CommandLine(_, Level::ForceWarn(_)) = src {\n+        level\n+    } else {\n+        cmp::min(level, sess.opts.lint_cap.unwrap_or(Level::Forbid))\n+    };\n \n-        (level, src)\n+    if let Some(driver_level) = sess.driver_lint_caps.get(&lint) {\n+        // Ensure that we never exceed driver level.\n+        level = cmp::min(*driver_level, level);\n     }\n \n-    pub fn get_lint_id_level(\n+    level\n+}\n+\n+impl ShallowLintLevelMap {\n+    /// Perform a deep probe in the HIR tree looking for the actual level for the lint.\n+    /// This lint level is not usable for diagnostics, it needs to be corrected by\n+    /// `reveal_actual_level` beforehand.\n+    #[instrument(level = \"trace\", skip(self, tcx), ret)]\n+    fn probe_for_lint_level(\n         &self,\n+        tcx: TyCtxt<'_>,\n         id: LintId,\n-        mut idx: LintStackIndex,\n-        aux: Option<&FxHashMap<LintId, LevelAndSource>>,\n+        start: HirId,\n     ) -> (Option<Level>, LintLevelSource) {\n-        if let Some(specs) = aux {\n-            if let Some(&(level, src)) = specs.get(&id) {\n-                return (Some(level), src);\n-            }\n+        if let Some(map) = self.specs.get(&start.local_id)\n+            && let Some(&(level, src)) = map.get(&id)\n+        {\n+            return (Some(level), src);\n         }\n-        loop {\n-            let LintSet { ref specs, parent } = self.list[idx];\n-            if let Some(&(level, src)) = specs.get(&id) {\n-                return (Some(level), src);\n+\n+        let mut owner = start.owner;\n+        let mut specs = &self.specs;\n+\n+        for parent in tcx.hir().parent_id_iter(start) {\n+            if parent.owner != owner {\n+                owner = parent.owner;\n+                specs = &tcx.shallow_lint_levels_on(owner).specs;\n             }\n-            if idx == COMMAND_LINE {\n-                return (None, LintLevelSource::Default);\n+            if let Some(map) = specs.get(&parent.local_id)\n+                && let Some(&(level, src)) = map.get(&id)\n+            {\n+                return (Some(level), src);\n             }\n-            idx = parent;\n         }\n-    }\n-}\n \n-#[derive(Debug)]\n-pub struct LintLevelMap {\n-    /// This is a collection of lint expectations as described in RFC 2383, that\n-    /// can be fulfilled during this compilation session. This means that at least\n-    /// one expected lint is currently registered in the lint store.\n-    ///\n-    /// The [`LintExpectationId`] is stored as a part of the [`Expect`](Level::Expect)\n-    /// lint level.\n-    pub lint_expectations: Vec<(LintExpectationId, LintExpectation)>,\n-    pub sets: LintLevelSets,\n-    pub id_to_set: FxHashMap<HirId, LintStackIndex>,\n-}\n+        (None, LintLevelSource::Default)\n+    }\n \n-impl LintLevelMap {\n-    /// If the `id` was previously registered with `register_id` when building\n-    /// this `LintLevelMap` this returns the corresponding lint level and source\n-    /// of the lint level for the lint provided.\n-    ///\n-    /// If the `id` was not previously registered, returns `None`. If `None` is\n-    /// returned then the parent of `id` should be acquired and this function\n-    /// should be called again.\n-    pub fn level_and_source(\n+    /// Fetch and return the user-visible lint level for the given lint at the given HirId.\n+    #[instrument(level = \"trace\", skip(self, tcx), ret)]\n+    pub fn lint_level_id_at_node(\n         &self,\n-        lint: &'static Lint,\n-        id: HirId,\n-        session: &Session,\n-    ) -> Option<LevelAndSource> {\n-        self.id_to_set.get(&id).map(|idx| self.sets.get_lint_level(lint, *idx, None, session))\n+        tcx: TyCtxt<'_>,\n+        lint: LintId,\n+        cur: HirId,\n+    ) -> (Level, LintLevelSource) {\n+        let (level, mut src) = self.probe_for_lint_level(tcx, lint, cur);\n+        let level = reveal_actual_level(level, &mut src, tcx.sess, lint, |lint| {\n+            self.probe_for_lint_level(tcx, lint, cur)\n+        });\n+        (level, src)\n     }\n }\n \n-impl<'a> HashStable<StableHashingContext<'a>> for LintLevelMap {\n-    #[inline]\n-    fn hash_stable(&self, hcx: &mut StableHashingContext<'a>, hasher: &mut StableHasher) {\n-        let LintLevelMap { ref sets, ref id_to_set, ref lint_expectations } = *self;\n+impl TyCtxt<'_> {\n+    /// Fetch and return the user-visible lint level for the given lint at the given HirId.\n+    pub fn lint_level_at_node(self, lint: &'static Lint, id: HirId) -> (Level, LintLevelSource) {\n+        self.shallow_lint_levels_on(id.owner).lint_level_id_at_node(self, LintId::of(lint), id)\n+    }\n \n-        id_to_set.hash_stable(hcx, hasher);\n-        lint_expectations.hash_stable(hcx, hasher);\n+    /// Walks upwards from `id` to find a node which might change lint levels with attributes.\n+    /// It stops at `bound` and just returns it if reached.\n+    pub fn maybe_lint_level_root_bounded(self, mut id: HirId, bound: HirId) -> HirId {\n+        let hir = self.hir();\n+        loop {\n+            if id == bound {\n+                return bound;\n+            }\n \n-        hcx.while_hashing_spans(true, |hcx| sets.hash_stable(hcx, hasher))\n+            if hir.attrs(id).iter().any(|attr| Level::from_attr(attr).is_some()) {\n+                return id;\n+            }\n+            let next = hir.get_parent_node(id);\n+            if next == id {\n+                bug!(\"lint traversal reached the root of the crate\");\n+            }\n+            id = next;\n+        }\n     }\n }\n \n@@ -261,11 +258,11 @@ pub fn explain_lint_level_source(\n                 ));\n             }\n         }\n-        LintLevelSource::Node(lint_attr_name, src, reason) => {\n+        LintLevelSource::Node { name: lint_attr_name, span, reason, .. } => {\n             if let Some(rationale) = reason {\n                 err.note(rationale.as_str());\n             }\n-            err.span_note_once(src, \"the lint level is defined here\");\n+            err.span_note_once(span, \"the lint level is defined here\");\n             if lint_attr_name.as_str() != name {\n                 let level_str = level.as_str();\n                 err.note_once(&format!("}, {"sha": "cf5b365b27c999a9a90c6f2ac549320ab5a75180", "filename": "compiler/rustc_middle/src/query/mod.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/57f097ea25f2c05f424fc9b9dc50dbd6d399845c/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57f097ea25f2c05f424fc9b9dc50dbd6d399845c/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fquery%2Fmod.rs?ref=57f097ea25f2c05f424fc9b9dc50dbd6d399845c", "patch": "@@ -274,10 +274,15 @@ rustc_queries! {\n         separate_provide_extern\n     }\n \n-    query lint_levels(_: ()) -> LintLevelMap {\n+    query shallow_lint_levels_on(key: hir::OwnerId) -> rustc_middle::lint::ShallowLintLevelMap {\n+        eval_always // fetches `resolutions`\n         arena_cache\n-        eval_always\n-        desc { \"computing the lint levels for items in this crate\" }\n+        desc { |tcx| \"looking up lint levels for `{}`\", tcx.def_path_str(key.to_def_id()) }\n+    }\n+\n+    query lint_expectations(_: ()) -> Vec<(LintExpectationId, LintExpectation)> {\n+        arena_cache\n+        desc { \"computing `#[expect]`ed lints in this crate\" }\n     }\n \n     query parent_module_from_def_id(key: LocalDefId) -> LocalDefId {"}, {"sha": "97646003e733969a9ef9ae3a3e362ce72c782a9c", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 2, "deletions": 40, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/57f097ea25f2c05f424fc9b9dc50dbd6d399845c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57f097ea25f2c05f424fc9b9dc50dbd6d399845c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=57f097ea25f2c05f424fc9b9dc50dbd6d399845c", "patch": "@@ -4,7 +4,7 @@ use crate::arena::Arena;\n use crate::dep_graph::{DepGraph, DepKindStruct};\n use crate::hir::place::Place as HirPlace;\n use crate::infer::canonical::{Canonical, CanonicalVarInfo, CanonicalVarInfos};\n-use crate::lint::{struct_lint_level, LintLevelSource};\n+use crate::lint::struct_lint_level;\n use crate::middle::codegen_fn_attrs::CodegenFnAttrs;\n use crate::middle::resolve_lifetime;\n use crate::middle::stability;\n@@ -57,7 +57,7 @@ use rustc_serialize::opaque::{FileEncodeResult, FileEncoder};\n use rustc_session::config::{CrateType, OutputFilenames};\n use rustc_session::cstore::CrateStoreDyn;\n use rustc_session::errors::TargetDataLayoutErrorsWrapper;\n-use rustc_session::lint::{Level, Lint};\n+use rustc_session::lint::Lint;\n use rustc_session::Limit;\n use rustc_session::Session;\n use rustc_span::def_id::{DefPathHash, StableCrateId};\n@@ -2812,44 +2812,6 @@ impl<'tcx> TyCtxt<'tcx> {\n         iter.intern_with(|xs| self.intern_bound_variable_kinds(xs))\n     }\n \n-    /// Walks upwards from `id` to find a node which might change lint levels with attributes.\n-    /// It stops at `bound` and just returns it if reached.\n-    pub fn maybe_lint_level_root_bounded(self, mut id: HirId, bound: HirId) -> HirId {\n-        let hir = self.hir();\n-        loop {\n-            if id == bound {\n-                return bound;\n-            }\n-\n-            if hir.attrs(id).iter().any(|attr| Level::from_attr(attr).is_some()) {\n-                return id;\n-            }\n-            let next = hir.get_parent_node(id);\n-            if next == id {\n-                bug!(\"lint traversal reached the root of the crate\");\n-            }\n-            id = next;\n-        }\n-    }\n-\n-    pub fn lint_level_at_node(\n-        self,\n-        lint: &'static Lint,\n-        mut id: hir::HirId,\n-    ) -> (Level, LintLevelSource) {\n-        let sets = self.lint_levels(());\n-        loop {\n-            if let Some(pair) = sets.level_and_source(lint, id, self.sess) {\n-                return pair;\n-            }\n-            let next = self.hir().get_parent_node(id);\n-            if next == id {\n-                bug!(\"lint traversal reached the root of the crate\");\n-            }\n-            id = next;\n-        }\n-    }\n-\n     /// Emit a lint at `span` from a lint struct (some type that implements `DecorateLint`,\n     /// typically generated by `#[derive(LintDiagnostic)]`).\n     pub fn emit_spanned_lint("}, {"sha": "b6cda34c51f616c78d1babfdde0d7b0d64a1004b", "filename": "compiler/rustc_middle/src/ty/query.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/57f097ea25f2c05f424fc9b9dc50dbd6d399845c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57f097ea25f2c05f424fc9b9dc50dbd6d399845c/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery.rs?ref=57f097ea25f2c05f424fc9b9dc50dbd6d399845c", "patch": "@@ -1,6 +1,6 @@\n use crate::dep_graph;\n use crate::infer::canonical::{self, Canonical};\n-use crate::lint::LintLevelMap;\n+use crate::lint::LintExpectation;\n use crate::metadata::ModChild;\n use crate::middle::codegen_fn_attrs::CodegenFnAttrs;\n use crate::middle::exported_symbols::{ExportedSymbol, SymbolExportInfo};\n@@ -51,6 +51,7 @@ use rustc_index::{bit_set::FiniteBitSet, vec::IndexVec};\n use rustc_session::config::{EntryFnType, OptLevel, OutputFilenames, SymbolManglingVersion};\n use rustc_session::cstore::{CrateDepKind, CrateSource};\n use rustc_session::cstore::{ExternCrate, ForeignModule, LinkagePreference, NativeLib};\n+use rustc_session::lint::LintExpectationId;\n use rustc_session::utils::NativeLibKind;\n use rustc_session::Limits;\n use rustc_span::symbol::Symbol;"}, {"sha": "cdbf734cdbe18843a6055925538354bb5d62e4b1", "filename": "compiler/rustc_query_impl/src/keys.rs", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/57f097ea25f2c05f424fc9b9dc50dbd6d399845c/compiler%2Frustc_query_impl%2Fsrc%2Fkeys.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57f097ea25f2c05f424fc9b9dc50dbd6d399845c/compiler%2Frustc_query_impl%2Fsrc%2Fkeys.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_impl%2Fsrc%2Fkeys.rs?ref=57f097ea25f2c05f424fc9b9dc50dbd6d399845c", "patch": "@@ -1,7 +1,7 @@\n //! Defines the set of legal keys that can be used in queries.\n \n use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, LOCAL_CRATE};\n-use rustc_hir::hir_id::OwnerId;\n+use rustc_hir::hir_id::{HirId, OwnerId};\n use rustc_middle::infer::canonical::Canonical;\n use rustc_middle::mir;\n use rustc_middle::traits;\n@@ -557,3 +557,19 @@ impl<'tcx> Key for (Ty<'tcx>, ty::ValTree<'tcx>) {\n         DUMMY_SP\n     }\n }\n+\n+impl Key for HirId {\n+    #[inline(always)]\n+    fn query_crate_is_local(&self) -> bool {\n+        true\n+    }\n+\n+    fn default_span(&self, tcx: TyCtxt<'_>) -> Span {\n+        tcx.hir().span(*self)\n+    }\n+\n+    #[inline(always)]\n+    fn key_as_def_id(&self) -> Option<DefId> {\n+        None\n+    }\n+}"}, {"sha": "da2075fd5aadae209ba29832740a59cceefad10d", "filename": "compiler/rustc_query_system/src/dep_graph/mod.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/57f097ea25f2c05f424fc9b9dc50dbd6d399845c/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/57f097ea25f2c05f424fc9b9dc50dbd6d399845c/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_query_system%2Fsrc%2Fdep_graph%2Fmod.rs?ref=57f097ea25f2c05f424fc9b9dc50dbd6d399845c", "patch": "@@ -94,6 +94,8 @@ impl<T: DepContext> HasDepContext for T {\n pub enum FingerprintStyle {\n     /// The fingerprint is actually a DefPathHash.\n     DefPathHash,\n+    /// The fingerprint is actually a HirId.\n+    HirId,\n     /// Query key was `()` or equivalent, so fingerprint is just zero.\n     Unit,\n     /// Some opaque hash.\n@@ -104,7 +106,9 @@ impl FingerprintStyle {\n     #[inline]\n     pub fn reconstructible(self) -> bool {\n         match self {\n-            FingerprintStyle::DefPathHash | FingerprintStyle::Unit => true,\n+            FingerprintStyle::DefPathHash | FingerprintStyle::Unit | FingerprintStyle::HirId => {\n+                true\n+            }\n             FingerprintStyle::Opaque => false,\n         }\n     }"}, {"sha": "5942fa8aeb4f0de429a93871f9db96999c7add99", "filename": "src/test/ui/lint/rfc-2383-lint-reason/force_warn_expected_lints_fulfilled.stderr", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/57f097ea25f2c05f424fc9b9dc50dbd6d399845c/src%2Ftest%2Fui%2Flint%2Frfc-2383-lint-reason%2Fforce_warn_expected_lints_fulfilled.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/57f097ea25f2c05f424fc9b9dc50dbd6d399845c/src%2Ftest%2Fui%2Flint%2Frfc-2383-lint-reason%2Fforce_warn_expected_lints_fulfilled.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Flint%2Frfc-2383-lint-reason%2Fforce_warn_expected_lints_fulfilled.stderr?ref=57f097ea25f2c05f424fc9b9dc50dbd6d399845c", "patch": "@@ -1,11 +1,3 @@\n-warning: denote infinite loops with `loop { ... }`\n-  --> $DIR/force_warn_expected_lints_fulfilled.rs:10:5\n-   |\n-LL |     while true {\n-   |     ^^^^^^^^^^ help: use `loop`\n-   |\n-   = note: requested on the command line with `--force-warn while-true`\n-\n warning: unused variable: `x`\n   --> $DIR/force_warn_expected_lints_fulfilled.rs:20:9\n    |\n@@ -36,5 +28,13 @@ LL |     let mut what_does_the_fox_say = \"*ding* *deng* *dung*\";\n    |\n    = note: requested on the command line with `--force-warn unused-mut`\n \n+warning: denote infinite loops with `loop { ... }`\n+  --> $DIR/force_warn_expected_lints_fulfilled.rs:10:5\n+   |\n+LL |     while true {\n+   |     ^^^^^^^^^^ help: use `loop`\n+   |\n+   = note: requested on the command line with `--force-warn while-true`\n+\n warning: 5 warnings emitted\n "}]}