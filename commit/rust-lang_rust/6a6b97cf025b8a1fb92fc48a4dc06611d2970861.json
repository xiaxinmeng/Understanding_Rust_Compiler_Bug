{"sha": "6a6b97cf025b8a1fb92fc48a4dc06611d2970861", "node_id": "MDY6Q29tbWl0NzI0NzEyOjZhNmI5N2NmMDI1YjhhMWZiOTJmYzQ4YTRkYzA2NjExZDI5NzA4NjE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-11-20T18:13:10Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-11-20T18:13:10Z"}, "message": "Auto merge of #29822 - petrochenkov:pubexport, r=alexcrichton\n\nThis patch implements the plan described in https://internals.rust-lang.org/t/privacy-and-its-interaction-with-docs-lints-and-stability/2880 with one deviation.\n\nIt turns out, that rustdoc needs the \"directly public\" set for its docs inlining logic, so the privacy pass have to produce three sets and not two. Three is arguably too many, so I merged them in one map:\n`public_items/exported_items/reachable_items: NodeSet => access_levels: NodeMap<AccessLevel>`\n\nr? @alexcrichton", "tree": {"sha": "2e0d2c85ad48b3312abdc0f3610825126ed24089", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2e0d2c85ad48b3312abdc0f3610825126ed24089"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/6a6b97cf025b8a1fb92fc48a4dc06611d2970861", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/6a6b97cf025b8a1fb92fc48a4dc06611d2970861", "html_url": "https://github.com/rust-lang/rust/commit/6a6b97cf025b8a1fb92fc48a4dc06611d2970861", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/6a6b97cf025b8a1fb92fc48a4dc06611d2970861/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "68276619b5fb36a1f0cfd98823b5b4d2404441a0", "url": "https://api.github.com/repos/rust-lang/rust/commits/68276619b5fb36a1f0cfd98823b5b4d2404441a0", "html_url": "https://github.com/rust-lang/rust/commit/68276619b5fb36a1f0cfd98823b5b4d2404441a0"}, {"sha": "c1ad5af4a6e7137ba246d1493d6efa59baa62465", "url": "https://api.github.com/repos/rust-lang/rust/commits/c1ad5af4a6e7137ba246d1493d6efa59baa62465", "html_url": "https://github.com/rust-lang/rust/commit/c1ad5af4a6e7137ba246d1493d6efa59baa62465"}], "stats": {"total": 479, "additions": 205, "deletions": 274}, "files": [{"sha": "74a61f700e3b8ac172fcfa3185f72f569c15a8b8", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6a6b97cf025b8a1fb92fc48a4dc06611d2970861/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a6b97cf025b8a1fb92fc48a4dc06611d2970861/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=6a6b97cf025b8a1fb92fc48a4dc06611d2970861", "patch": "@@ -25,7 +25,7 @@\n //! for all lint attributes.\n use self::TargetLint::*;\n \n-use middle::privacy::ExportedItems;\n+use middle::privacy::AccessLevels;\n use middle::ty::{self, Ty};\n use session::{early_error, Session};\n use lint::{Level, LevelSource, Lint, LintId, LintArray, LintPass};\n@@ -277,8 +277,8 @@ pub struct LateContext<'a, 'tcx: 'a> {\n     /// The crate being checked.\n     pub krate: &'a hir::Crate,\n \n-    /// Items exported from the crate being checked.\n-    pub exported_items: &'a ExportedItems,\n+    /// Items accessible from the crate being checked.\n+    pub access_levels: &'a AccessLevels,\n \n     /// The store of registered lints.\n     lints: LintStore,\n@@ -564,15 +564,15 @@ impl<'a> EarlyContext<'a> {\n impl<'a, 'tcx> LateContext<'a, 'tcx> {\n     fn new(tcx: &'a ty::ctxt<'tcx>,\n            krate: &'a hir::Crate,\n-           exported_items: &'a ExportedItems) -> LateContext<'a, 'tcx> {\n+           access_levels: &'a AccessLevels) -> LateContext<'a, 'tcx> {\n         // We want to own the lint store, so move it out of the session.\n         let lint_store = mem::replace(&mut *tcx.sess.lint_store.borrow_mut(),\n                                       LintStore::new());\n \n         LateContext {\n             tcx: tcx,\n             krate: krate,\n-            exported_items: exported_items,\n+            access_levels: access_levels,\n             lints: lint_store,\n             level_stack: vec![],\n             node_levels: RefCell::new(FnvHashMap()),\n@@ -1014,10 +1014,9 @@ impl LateLintPass for GatherNodeLevels {\n /// Perform lint checking on a crate.\n ///\n /// Consumes the `lint_store` field of the `Session`.\n-pub fn check_crate(tcx: &ty::ctxt,\n-                   exported_items: &ExportedItems) {\n+pub fn check_crate(tcx: &ty::ctxt, access_levels: &AccessLevels) {\n     let krate = tcx.map.krate();\n-    let mut cx = LateContext::new(tcx, krate, exported_items);\n+    let mut cx = LateContext::new(tcx, krate, access_levels);\n \n     // Visit the whole crate.\n     cx.with_lint_attrs(&krate.attrs, |cx| {"}, {"sha": "acd635874e39266bd0a0a11cdaacf6e4ec8ca27a", "filename": "src/librustc/middle/dead.rs", "status": "modified", "additions": 6, "deletions": 27, "changes": 33, "blob_url": "https://github.com/rust-lang/rust/blob/6a6b97cf025b8a1fb92fc48a4dc06611d2970861/src%2Flibrustc%2Fmiddle%2Fdead.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a6b97cf025b8a1fb92fc48a4dc06611d2970861/src%2Flibrustc%2Fmiddle%2Fdead.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fdead.rs?ref=6a6b97cf025b8a1fb92fc48a4dc06611d2970861", "patch": "@@ -19,7 +19,6 @@ use rustc_front::intravisit::{self, Visitor};\n use middle::{def, pat_util, privacy, ty};\n use middle::def_id::{DefId};\n use lint;\n-use util::nodemap::NodeSet;\n \n use std::collections::HashSet;\n use syntax::{ast, codemap};\n@@ -370,25 +369,10 @@ impl<'v> Visitor<'v> for LifeSeeder {\n }\n \n fn create_and_seed_worklist(tcx: &ty::ctxt,\n-                            exported_items: &privacy::ExportedItems,\n-                            reachable_symbols: &NodeSet,\n+                            access_levels: &privacy::AccessLevels,\n                             krate: &hir::Crate) -> Vec<ast::NodeId> {\n     let mut worklist = Vec::new();\n-\n-    // Preferably, we would only need to seed the worklist with reachable\n-    // symbols. However, since the set of reachable symbols differs\n-    // depending on whether a crate is built as bin or lib, and we want\n-    // the warning to be consistent, we also seed the worklist with\n-    // exported symbols.\n-    for id in exported_items {\n-        worklist.push(*id);\n-    }\n-    for id in reachable_symbols {\n-        // Reachable variants can be dead, because we warn about\n-        // variants never constructed, not variants never used.\n-        if let Some(ast_map::NodeVariant(..)) = tcx.map.find(*id) {\n-            continue;\n-        }\n+    for (id, _) in &access_levels.map {\n         worklist.push(*id);\n     }\n \n@@ -408,12 +392,10 @@ fn create_and_seed_worklist(tcx: &ty::ctxt,\n }\n \n fn find_live(tcx: &ty::ctxt,\n-             exported_items: &privacy::ExportedItems,\n-             reachable_symbols: &NodeSet,\n+             access_levels: &privacy::AccessLevels,\n              krate: &hir::Crate)\n              -> Box<HashSet<ast::NodeId>> {\n-    let worklist = create_and_seed_worklist(tcx, exported_items,\n-                                            reachable_symbols, krate);\n+    let worklist = create_and_seed_worklist(tcx, access_levels, krate);\n     let mut symbol_visitor = MarkSymbolVisitor::new(tcx, worklist);\n     symbol_visitor.mark_live_symbols();\n     symbol_visitor.live_symbols\n@@ -607,12 +589,9 @@ impl<'a, 'tcx, 'v> Visitor<'v> for DeadVisitor<'a, 'tcx> {\n     }\n }\n \n-pub fn check_crate(tcx: &ty::ctxt,\n-                   exported_items: &privacy::ExportedItems,\n-                   reachable_symbols: &NodeSet) {\n+pub fn check_crate(tcx: &ty::ctxt, access_levels: &privacy::AccessLevels) {\n     let krate = tcx.map.krate();\n-    let live_symbols = find_live(tcx, exported_items,\n-                                 reachable_symbols, krate);\n+    let live_symbols = find_live(tcx, access_levels, krate);\n     let mut visitor = DeadVisitor { tcx: tcx, live_symbols: live_symbols };\n     intravisit::walk_crate(&mut visitor, krate);\n }"}, {"sha": "f464ea58c2d196f76a103d5e493791b2dc9f6ec7", "filename": "src/librustc/middle/privacy.rs", "status": "modified", "additions": 42, "deletions": 8, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/6a6b97cf025b8a1fb92fc48a4dc06611d2970861/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a6b97cf025b8a1fb92fc48a4dc06611d2970861/src%2Flibrustc%2Fmiddle%2Fprivacy.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fprivacy.rs?ref=6a6b97cf025b8a1fb92fc48a4dc06611d2970861", "patch": "@@ -17,20 +17,54 @@ pub use self::ImportUse::*;\n pub use self::LastPrivate::*;\n \n use middle::def_id::DefId;\n-use util::nodemap::{DefIdSet, NodeSet};\n+use util::nodemap::{DefIdSet, FnvHashMap};\n \n-/// A set of AST nodes exported by the crate.\n-pub type ExportedItems = NodeSet;\n+use std::hash::Hash;\n+use syntax::ast::NodeId;\n+\n+// Accessibility levels, sorted in ascending order\n+#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]\n+pub enum AccessLevel {\n+    // Exported items + items participating in various kinds of public interfaces,\n+    // but not directly nameable. For example, if function `fn f() -> T {...}` is\n+    // public, then type `T` is exported. Its values can be obtained by other crates\n+    // even if the type itseld is not nameable.\n+    // FIXME: Mostly unimplemented. Only `type` aliases export items currently.\n+    Reachable,\n+    // Public items + items accessible to other crates with help of `pub use` reexports\n+    Exported,\n+    // Items accessible to other crates directly, without help of reexports\n+    Public,\n+}\n+\n+// Accessibility levels for reachable HIR nodes\n+#[derive(Clone)]\n+pub struct AccessLevels<Id = NodeId> {\n+    pub map: FnvHashMap<Id, AccessLevel>\n+}\n+\n+impl<Id: Hash + Eq> AccessLevels<Id> {\n+    pub fn is_reachable(&self, id: Id) -> bool {\n+        self.map.contains_key(&id)\n+    }\n+    pub fn is_exported(&self, id: Id) -> bool {\n+        self.map.get(&id) >= Some(&AccessLevel::Exported)\n+    }\n+    pub fn is_public(&self, id: Id) -> bool {\n+        self.map.get(&id) >= Some(&AccessLevel::Public)\n+    }\n+}\n+\n+impl<Id: Hash + Eq> Default for AccessLevels<Id> {\n+    fn default() -> Self {\n+        AccessLevels { map: Default::default() }\n+    }\n+}\n \n /// A set containing all exported definitions from external crates.\n /// The set does not contain any entries from local crates.\n pub type ExternalExports = DefIdSet;\n \n-/// A set of AST nodes that are fully public in the crate. This map is used for\n-/// documentation purposes (reexporting a private struct inlines the doc,\n-/// reexporting a public struct doesn't inline the doc).\n-pub type PublicItems = NodeSet;\n-\n #[derive(Copy, Clone, Debug)]\n pub enum LastPrivate {\n     LastMod(PrivateDep),"}, {"sha": "d146ad2d8003b766d2eabae34cd0e1d0e62c4f25", "filename": "src/librustc/middle/reachable.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6a6b97cf025b8a1fb92fc48a4dc06611d2970861/src%2Flibrustc%2Fmiddle%2Freachable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a6b97cf025b8a1fb92fc48a4dc06611d2970861/src%2Flibrustc%2Fmiddle%2Freachable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Freachable.rs?ref=6a6b97cf025b8a1fb92fc48a4dc06611d2970861", "patch": "@@ -329,15 +329,15 @@ impl<'a, 'tcx> ReachableContext<'a, 'tcx> {\n // trait items are used from inlinable code through method call syntax or UFCS, or their\n // trait is a lang item.\n struct CollectPrivateImplItemsVisitor<'a> {\n-    exported_items: &'a privacy::ExportedItems,\n+    access_levels: &'a privacy::AccessLevels,\n     worklist: &'a mut Vec<ast::NodeId>,\n }\n \n impl<'a, 'v> Visitor<'v> for CollectPrivateImplItemsVisitor<'a> {\n     fn visit_item(&mut self, item: &hir::Item) {\n         // We need only trait impls here, not inherent impls, and only non-exported ones\n         if let hir::ItemImpl(_, _, _, Some(_), _, ref impl_items) = item.node {\n-            if !self.exported_items.contains(&item.id) {\n+            if !self.access_levels.is_reachable(item.id) {\n                 for impl_item in impl_items {\n                     self.worklist.push(impl_item.id);\n                 }\n@@ -347,7 +347,7 @@ impl<'a, 'v> Visitor<'v> for CollectPrivateImplItemsVisitor<'a> {\n }\n \n pub fn find_reachable(tcx: &ty::ctxt,\n-                      exported_items: &privacy::ExportedItems)\n+                      access_levels: &privacy::AccessLevels)\n                       -> NodeSet {\n \n     let mut reachable_context = ReachableContext::new(tcx);\n@@ -357,7 +357,7 @@ pub fn find_reachable(tcx: &ty::ctxt,\n     //         If other crates link to us, they're going to expect to be able to\n     //         use the lang items, so we need to be sure to mark them as\n     //         exported.\n-    for id in exported_items {\n+    for (id, _) in &access_levels.map {\n         reachable_context.worklist.push(*id);\n     }\n     for (_, item) in tcx.lang_items.items() {\n@@ -369,7 +369,7 @@ pub fn find_reachable(tcx: &ty::ctxt,\n     }\n     {\n         let mut collect_private_impl_items = CollectPrivateImplItemsVisitor {\n-            exported_items: exported_items,\n+            access_levels: access_levels,\n             worklist: &mut reachable_context.worklist,\n         };\n         tcx.map.krate().visit_all_items(&mut collect_private_impl_items);"}, {"sha": "0ef2ac723fcec7123ed4a160900ea5099a22ee82", "filename": "src/librustc/middle/stability.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/6a6b97cf025b8a1fb92fc48a4dc06611d2970861/src%2Flibrustc%2Fmiddle%2Fstability.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a6b97cf025b8a1fb92fc48a4dc06611d2970861/src%2Flibrustc%2Fmiddle%2Fstability.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fstability.rs?ref=6a6b97cf025b8a1fb92fc48a4dc06611d2970861", "patch": "@@ -19,7 +19,7 @@ use metadata::cstore::LOCAL_CRATE;\n use middle::def;\n use middle::def_id::{CRATE_DEF_INDEX, DefId};\n use middle::ty;\n-use middle::privacy::PublicItems;\n+use middle::privacy::AccessLevels;\n use metadata::csearch;\n use syntax::parse::token::InternedString;\n use syntax::codemap::{Span, DUMMY_SP};\n@@ -73,7 +73,7 @@ struct Annotator<'a, 'tcx: 'a> {\n     tcx: &'a ty::ctxt<'tcx>,\n     index: &'a mut Index<'tcx>,\n     parent: Option<&'tcx Stability>,\n-    export_map: &'a PublicItems,\n+    access_levels: &'a AccessLevels,\n     in_trait_impl: bool,\n     in_enum: bool,\n }\n@@ -143,7 +143,7 @@ impl<'a, 'tcx: 'a> Annotator<'a, 'tcx> {\n             } else {\n                 debug!(\"annotate: not found, parent = {:?}\", self.parent);\n                 let mut is_error = kind == AnnotationKind::Required &&\n-                                   self.export_map.contains(&id) &&\n+                                   self.access_levels.is_reachable(id) &&\n                                    !self.tcx.sess.opts.test;\n                 if let Some(stab) = self.parent {\n                     if stab.level.is_unstable() {\n@@ -266,12 +266,12 @@ impl<'a, 'tcx, 'v> Visitor<'v> for Annotator<'a, 'tcx> {\n \n impl<'tcx> Index<'tcx> {\n     /// Construct the stability index for a crate being compiled.\n-    pub fn build(&mut self, tcx: &ty::ctxt<'tcx>, krate: &'tcx Crate, export_map: &PublicItems) {\n+    pub fn build(&mut self, tcx: &ty::ctxt<'tcx>, krate: &Crate, access_levels: &AccessLevels) {\n         let mut annotator = Annotator {\n             tcx: tcx,\n             index: self,\n             parent: None,\n-            export_map: export_map,\n+            access_levels: access_levels,\n             in_trait_impl: false,\n             in_enum: false,\n         };"}, {"sha": "501781627fbce5a4c90c0da927847ee0f9ee121d", "filename": "src/librustc/middle/ty/mod.rs", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/6a6b97cf025b8a1fb92fc48a4dc06611d2970861/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a6b97cf025b8a1fb92fc48a4dc06611d2970861/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty%2Fmod.rs?ref=6a6b97cf025b8a1fb92fc48a4dc06611d2970861", "patch": "@@ -104,14 +104,12 @@ pub const INITIAL_DISCRIMINANT_VALUE: Disr = 0;\n /// produced by the driver and fed to trans and later passes.\n pub struct CrateAnalysis<'a> {\n     pub export_map: ExportMap,\n-    pub exported_items: middle::privacy::ExportedItems,\n-    pub public_items: middle::privacy::PublicItems,\n+    pub access_levels: middle::privacy::AccessLevels,\n     pub reachable: NodeSet,\n     pub name: &'a str,\n     pub glob_map: Option<GlobMap>,\n }\n \n-\n #[derive(Copy, Clone)]\n pub enum DtorKind {\n     NoDtor,"}, {"sha": "cb345ac517e0dd80439248c650d5ea7bd4e6cadf", "filename": "src/librustc_driver/driver.rs", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/6a6b97cf025b8a1fb92fc48a4dc06611d2970861/src%2Flibrustc_driver%2Fdriver.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a6b97cf025b8a1fb92fc48a4dc06611d2970861/src%2Flibrustc_driver%2Fdriver.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Fdriver.rs?ref=6a6b97cf025b8a1fb92fc48a4dc06611d2970861", "patch": "@@ -746,7 +746,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n                                         \"const checking\",\n                                         || middle::check_const::check_crate(tcx));\n \n-                                   let (exported_items, public_items) =\n+                                   let access_levels =\n                                        time(time_passes, \"privacy checking\", || {\n                                            rustc_privacy::check_crate(tcx,\n                                                                       &export_map,\n@@ -755,7 +755,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n \n                                    // Do not move this check past lint\n                                    time(time_passes, \"stability index\", || {\n-                                       tcx.stability.borrow_mut().build(tcx, krate, &exported_items)\n+                                       tcx.stability.borrow_mut().build(tcx, krate, &access_levels)\n                                    });\n \n                                    time(time_passes,\n@@ -807,12 +807,10 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n                                    let reachable_map =\n                                        time(time_passes,\n                                             \"reachability checking\",\n-                                            || reachable::find_reachable(tcx, &exported_items));\n+                                            || reachable::find_reachable(tcx, &access_levels));\n \n                                    time(time_passes, \"death checking\", || {\n-                                       middle::dead::check_crate(tcx,\n-                                                                 &exported_items,\n-                                                                 &reachable_map)\n+                                       middle::dead::check_crate(tcx, &access_levels);\n                                    });\n \n                                    let ref lib_features_used =\n@@ -827,7 +825,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n \n                                    time(time_passes,\n                                         \"lint checking\",\n-                                        || lint::check_crate(tcx, &exported_items));\n+                                        || lint::check_crate(tcx, &access_levels));\n \n                                    // The above three passes generate errors w/o aborting\n                                    tcx.sess.abort_if_errors();\n@@ -836,8 +834,7 @@ pub fn phase_3_run_analysis_passes<'tcx, F, R>(sess: &'tcx Session,\n                                      mir_map,\n                                      ty::CrateAnalysis {\n                                          export_map: export_map,\n-                                         exported_items: exported_items,\n-                                         public_items: public_items,\n+                                         access_levels: access_levels,\n                                          reachable: reachable_map,\n                                          name: name,\n                                          glob_map: glob_map,"}, {"sha": "1fd4ee72cec913c7f42fe914f2329a3440108d7b", "filename": "src/librustc_lint/builtin.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6a6b97cf025b8a1fb92fc48a4dc06611d2970861/src%2Flibrustc_lint%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a6b97cf025b8a1fb92fc48a4dc06611d2970861/src%2Flibrustc_lint%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_lint%2Fbuiltin.rs?ref=6a6b97cf025b8a1fb92fc48a4dc06611d2970861", "patch": "@@ -301,8 +301,8 @@ impl MissingDoc {\n         // Only check publicly-visible items, using the result from the privacy pass.\n         // It's an option so the crate root can also use this function (it doesn't\n         // have a NodeId).\n-        if let Some(ref id) = id {\n-            if !cx.exported_items.contains(id) {\n+        if let Some(id) = id {\n+            if !cx.access_levels.is_exported(id) {\n                 return;\n             }\n         }\n@@ -470,7 +470,7 @@ impl LintPass for MissingCopyImplementations {\n \n impl LateLintPass for MissingCopyImplementations {\n     fn check_item(&mut self, cx: &LateContext, item: &hir::Item) {\n-        if !cx.exported_items.contains(&item.id) {\n+        if !cx.access_levels.is_reachable(item.id) {\n             return;\n         }\n         let (def, ty) = match item.node {\n@@ -534,7 +534,7 @@ impl LintPass for MissingDebugImplementations {\n \n impl LateLintPass for MissingDebugImplementations {\n     fn check_item(&mut self, cx: &LateContext, item: &hir::Item) {\n-        if !cx.exported_items.contains(&item.id) {\n+        if !cx.access_levels.is_reachable(item.id) {\n             return;\n         }\n \n@@ -987,15 +987,15 @@ impl LateLintPass for InvalidNoMangleItems {\n         match it.node {\n             hir::ItemFn(..) => {\n                 if attr::contains_name(&it.attrs, \"no_mangle\") &&\n-                       !cx.exported_items.contains(&it.id) {\n+                       !cx.access_levels.is_reachable(it.id) {\n                     let msg = format!(\"function {} is marked #[no_mangle], but not exported\",\n                                       it.name);\n                     cx.span_lint(PRIVATE_NO_MANGLE_FNS, it.span, &msg);\n                 }\n             },\n             hir::ItemStatic(..) => {\n                 if attr::contains_name(&it.attrs, \"no_mangle\") &&\n-                       !cx.exported_items.contains(&it.id) {\n+                       !cx.access_levels.is_reachable(it.id) {\n                     let msg = format!(\"static {} is marked #[no_mangle], but not exported\",\n                                       it.name);\n                     cx.span_lint(PRIVATE_NO_MANGLE_STATICS, it.span, &msg);"}, {"sha": "1ca8eeadfe5bb0a58bfc60dad26d807965fb87cb", "filename": "src/librustc_privacy/lib.rs", "status": "modified", "additions": 103, "deletions": 172, "changes": 275, "blob_url": "https://github.com/rust-lang/rust/blob/6a6b97cf025b8a1fb92fc48a4dc06611d2970861/src%2Flibrustc_privacy%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a6b97cf025b8a1fb92fc48a4dc06611d2970861/src%2Flibrustc_privacy%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_privacy%2Flib.rs?ref=6a6b97cf025b8a1fb92fc48a4dc06611d2970861", "patch": "@@ -32,19 +32,21 @@ extern crate rustc_front;\n use self::PrivacyResult::*;\n use self::FieldName::*;\n \n+use std::cmp;\n use std::mem::replace;\n \n use rustc_front::hir;\n use rustc_front::intravisit::{self, Visitor};\n \n use rustc::middle::def;\n use rustc::middle::def_id::DefId;\n+use rustc::middle::privacy::{AccessLevel, AccessLevels};\n use rustc::middle::privacy::ImportUse::*;\n use rustc::middle::privacy::LastPrivate::*;\n use rustc::middle::privacy::PrivateDep::*;\n-use rustc::middle::privacy::{ExternalExports, ExportedItems, PublicItems};\n+use rustc::middle::privacy::ExternalExports;\n use rustc::middle::ty::{self, Ty};\n-use rustc::util::nodemap::{NodeMap, NodeSet};\n+use rustc::util::nodemap::NodeMap;\n use rustc::front::map as ast_map;\n \n use syntax::ast;\n@@ -159,64 +161,57 @@ struct EmbargoVisitor<'a, 'tcx: 'a> {\n     tcx: &'a ty::ctxt<'tcx>,\n     export_map: &'a def::ExportMap,\n \n-    // This flag is an indicator of whether the previous item in the\n-    // hierarchical chain was exported or not. This is the indicator of whether\n-    // children should be exported as well. Note that this can flip from false\n-    // to true if a reexported module is entered (or an action similar).\n-    prev_exported: bool,\n-\n-    // This is a list of all exported items in the AST. An exported item is any\n-    // function/method/item which is usable by external crates. This essentially\n-    // means that the result is \"public all the way down\", but the \"path down\"\n-    // may jump across private boundaries through reexport statements or type aliases.\n-    exported_items: ExportedItems,\n-\n-    // Items that are directly public without help of reexports or type aliases.\n-    // These two fields are closely related to one another in that they are only\n-    // used for generation of the `public_items` set, not for privacy checking at\n-    // all. Invariant: at any moment public items are a subset of exported items.\n-    public_items: PublicItems,\n-    prev_public: bool,\n+    // Accessibility levels for reachable nodes\n+    access_levels: AccessLevels,\n+    // Previous accessibility level, None means unreachable\n+    prev_level: Option<AccessLevel>,\n+    // Have something changed in the level map?\n+    changed: bool,\n }\n \n impl<'a, 'tcx> EmbargoVisitor<'a, 'tcx> {\n-    // Returns tuple (is_public, is_exported) for a type\n-    fn is_public_exported_ty(&self, ty: &hir::Ty) -> (bool, bool) {\n+    fn ty_level(&self, ty: &hir::Ty) -> Option<AccessLevel> {\n         if let hir::TyPath(..) = ty.node {\n             match self.tcx.def_map.borrow().get(&ty.id).unwrap().full_def() {\n                 def::DefPrimTy(..) | def::DefSelfTy(..) | def::DefTyParam(..) => {\n-                    (true, true)\n+                    Some(AccessLevel::Public)\n                 }\n                 def => {\n                     if let Some(node_id) = self.tcx.map.as_local_node_id(def.def_id()) {\n-                        (self.public_items.contains(&node_id),\n-                         self.exported_items.contains(&node_id))\n+                        self.get(node_id)\n                     } else {\n-                        (true, true)\n+                        Some(AccessLevel::Public)\n                     }\n                 }\n             }\n         } else {\n-            (true, true)\n+            Some(AccessLevel::Public)\n         }\n     }\n \n-    // Returns tuple (is_public, is_exported) for a trait\n-    fn is_public_exported_trait(&self, trait_ref: &hir::TraitRef) -> (bool, bool) {\n+    fn trait_level(&self, trait_ref: &hir::TraitRef) -> Option<AccessLevel> {\n         let did = self.tcx.trait_ref_to_def_id(trait_ref);\n         if let Some(node_id) = self.tcx.map.as_local_node_id(did) {\n-            (self.public_items.contains(&node_id), self.exported_items.contains(&node_id))\n+            self.get(node_id)\n         } else {\n-            (true, true)\n+            Some(AccessLevel::Public)\n         }\n     }\n \n-    fn maybe_insert_id(&mut self, id: ast::NodeId) {\n-        if self.prev_public {\n-            self.public_items.insert(id);\n-        }\n-        if self.prev_exported {\n-            self.exported_items.insert(id);\n+    fn get(&self, id: ast::NodeId) -> Option<AccessLevel> {\n+        self.access_levels.map.get(&id).cloned()\n+    }\n+\n+    // Updates node level and returns the updated level\n+    fn update(&mut self, id: ast::NodeId, level: Option<AccessLevel>) -> Option<AccessLevel> {\n+        let old_level = self.get(id);\n+        // Accessibility levels can only grow\n+        if level > old_level {\n+            self.access_levels.map.insert(id, level.unwrap());\n+            self.changed = true;\n+            level\n+        } else {\n+            old_level\n         }\n     }\n }\n@@ -227,187 +222,126 @@ impl<'a, 'tcx, 'v> Visitor<'v> for EmbargoVisitor<'a, 'tcx> {\n     fn visit_nested_item(&mut self, item: hir::ItemId) {\n         self.visit_item(self.tcx.map.expect_item(item.id))\n     }\n+\n     fn visit_item(&mut self, item: &hir::Item) {\n-        let orig_all_public = self.prev_public;\n-        let orig_all_exported = self.prev_exported;\n-        match item.node {\n-            // impls/extern blocks do not break the \"public chain\" because they\n-            // cannot have visibility qualifiers on them anyway. Impls are also not\n-            // added to public/exported sets based on inherited publicity.\n-            hir::ItemImpl(..) | hir::ItemDefaultImpl(..) => {}\n+        let inherited_item_level = match item.node {\n+            // Impls inherit level from their types and traits\n+            hir::ItemImpl(_, _, _, None, ref ty, _) => {\n+                self.ty_level(&ty)\n+            }\n+            hir::ItemImpl(_, _, _, Some(ref trait_ref), ref ty, _) => {\n+                cmp::min(self.ty_level(&ty), self.trait_level(trait_ref))\n+            }\n+            hir::ItemDefaultImpl(_, ref trait_ref) => {\n+                self.trait_level(trait_ref)\n+            }\n+            // Foreign mods inherit level from parents\n             hir::ItemForeignMod(..) => {\n-                self.maybe_insert_id(item.id);\n+                self.prev_level\n             }\n-\n-            // Private by default, hence we only retain the \"public chain\" if\n-            // `pub` is explicitly listed.\n+            // Other `pub` items inherit levels from parents\n             _ => {\n-                self.prev_public = self.prev_public && item.vis == hir::Public;\n-                self.prev_exported = (self.prev_exported && item.vis == hir::Public) ||\n-                                     self.exported_items.contains(&item.id);\n-\n-                self.maybe_insert_id(item.id);\n+                if item.vis == hir::Public { self.prev_level } else { None }\n             }\n-        }\n+        };\n \n+        // Update id of the item itself\n+        let item_level = self.update(item.id, inherited_item_level);\n+\n+        // Update ids of nested things\n         match item.node {\n-            // Enum variants inherit from their parent, so if the enum is\n-            // public all variants are public\n             hir::ItemEnum(ref def, _) => {\n                 for variant in &def.variants {\n-                    self.maybe_insert_id(variant.node.data.id());\n+                    let variant_level = self.update(variant.node.data.id(), item_level);\n                     for field in variant.node.data.fields() {\n-                        // Variant fields are always public\n-                        self.maybe_insert_id(field.node.id);\n+                        self.update(field.node.id, variant_level);\n                     }\n                 }\n             }\n-\n-            // Inherent impls for public/exported types and their public items are public/exported\n-            hir::ItemImpl(_, _, _, None, ref ty, ref impl_items) => {\n-                let (public_ty, exported_ty) = self.is_public_exported_ty(&ty);\n-\n-                if public_ty {\n-                    self.public_items.insert(item.id);\n-                }\n-                if exported_ty {\n-                    self.exported_items.insert(item.id);\n-                }\n-\n+            hir::ItemImpl(_, _, _, None, _, ref impl_items) => {\n                 for impl_item in impl_items {\n                     if impl_item.vis == hir::Public {\n-                        if public_ty {\n-                            self.public_items.insert(impl_item.id);\n-                        }\n-                        if exported_ty {\n-                            self.exported_items.insert(impl_item.id);\n-                        }\n+                        self.update(impl_item.id, item_level);\n                     }\n                 }\n             }\n-\n-            // Trait impl and its items are public/exported if both the self type and the trait\n-            // of this impl are public/exported\n-            hir::ItemImpl(_, _, _, Some(ref trait_ref), ref ty, ref impl_items) => {\n-                let (public_ty, exported_ty) = self.is_public_exported_ty(&ty);\n-                let (public_trait, exported_trait) = self.is_public_exported_trait(trait_ref);\n-\n-                if public_ty && public_trait {\n-                    self.public_items.insert(item.id);\n-                }\n-                if exported_ty && exported_trait {\n-                    self.exported_items.insert(item.id);\n-                }\n-\n+            hir::ItemImpl(_, _, _, Some(_), _, ref impl_items) => {\n                 for impl_item in impl_items {\n-                    if public_ty && public_trait {\n-                        self.public_items.insert(impl_item.id);\n-                    }\n-                    if exported_ty && exported_trait {\n-                        self.exported_items.insert(impl_item.id);\n-                    }\n-                }\n-            }\n-\n-            // Default trait impls are public/exported for public/exported traits\n-            hir::ItemDefaultImpl(_, ref trait_ref) => {\n-                let (public_trait, exported_trait) = self.is_public_exported_trait(trait_ref);\n-\n-                if public_trait {\n-                    self.public_items.insert(item.id);\n-                }\n-                if exported_trait {\n-                    self.exported_items.insert(item.id);\n+                    self.update(impl_item.id, item_level);\n                 }\n             }\n-\n-            // Default methods on traits are all public/exported so long as the trait\n-            // is public/exported\n             hir::ItemTrait(_, _, _, ref trait_items) => {\n                 for trait_item in trait_items {\n-                    self.maybe_insert_id(trait_item.id);\n+                    self.update(trait_item.id, item_level);\n                 }\n             }\n-\n-            // Struct constructors are public if the struct is all public.\n             hir::ItemStruct(ref def, _) => {\n                 if !def.is_struct() {\n-                    self.maybe_insert_id(def.id());\n+                    self.update(def.id(), item_level);\n                 }\n                 for field in def.fields() {\n-                    // Struct fields can be public or private, so lets check\n                     if field.node.kind.visibility() == hir::Public {\n-                        self.maybe_insert_id(field.node.id);\n+                        self.update(field.node.id, item_level);\n                     }\n                 }\n             }\n-\n-            hir::ItemTy(ref ty, _) if self.prev_exported => {\n+            hir::ItemForeignMod(ref foreign_mod) => {\n+                for foreign_item in &foreign_mod.items {\n+                    if foreign_item.vis == hir::Public {\n+                        self.update(foreign_item.id, item_level);\n+                    }\n+                }\n+            }\n+            hir::ItemTy(ref ty, _) if item_level.is_some() => {\n                 if let hir::TyPath(..) = ty.node {\n                     match self.tcx.def_map.borrow().get(&ty.id).unwrap().full_def() {\n                         def::DefPrimTy(..) | def::DefSelfTy(..) | def::DefTyParam(..) => {},\n                         def => {\n                             if let Some(node_id) = self.tcx.map.as_local_node_id(def.def_id()) {\n-                                self.exported_items.insert(node_id);\n+                                self.update(node_id, Some(AccessLevel::Reachable));\n                             }\n                         }\n                     }\n                 }\n             }\n-\n-            hir::ItemForeignMod(ref foreign_mod) => {\n-                for foreign_item in &foreign_mod.items {\n-                    let public = self.prev_public && foreign_item.vis == hir::Public;\n-                    let exported = (self.prev_exported && foreign_item.vis == hir::Public) ||\n-                                   self.exported_items.contains(&foreign_item.id);\n-\n-                    if public {\n-                        self.public_items.insert(foreign_item.id);\n-                    }\n-                    if exported {\n-                        self.exported_items.insert(foreign_item.id);\n-                    }\n-                }\n-            }\n-\n             _ => {}\n         }\n \n+        let orig_level = self.prev_level;\n+        self.prev_level = item_level;\n+\n         intravisit::walk_item(self, item);\n \n-        self.prev_public = orig_all_public;\n-        self.prev_exported = orig_all_exported;\n+        self.prev_level = orig_level;\n     }\n \n     fn visit_block(&mut self, b: &'v hir::Block) {\n-        let orig_all_public = replace(&mut self.prev_public, false);\n-        let orig_all_exported = replace(&mut self.prev_exported, false);\n+        let orig_level = replace(&mut self.prev_level, None);\n \n-        // Blocks can have exported and public items, for example impls, but they always\n-        // start as non-public and non-exported regardless of publicity of a function,\n+        // Blocks can have public items, for example impls, but they always\n+        // start as completely private regardless of publicity of a function,\n         // constant, type, field, etc. in which this block resides\n         intravisit::walk_block(self, b);\n \n-        self.prev_public = orig_all_public;\n-        self.prev_exported = orig_all_exported;\n+        self.prev_level = orig_level;\n     }\n \n     fn visit_mod(&mut self, m: &hir::Mod, _sp: Span, id: ast::NodeId) {\n         // This code is here instead of in visit_item so that the\n         // crate module gets processed as well.\n-        if self.prev_exported {\n-            assert!(self.export_map.contains_key(&id), \"wut {}\", id);\n-            for export in self.export_map.get(&id).unwrap() {\n+        if self.prev_level.is_some() {\n+            for export in self.export_map.get(&id).expect(\"module isn't found in export map\") {\n                 if let Some(node_id) = self.tcx.map.as_local_node_id(export.def_id) {\n-                    self.exported_items.insert(node_id);\n+                    self.update(node_id, Some(AccessLevel::Exported));\n                 }\n             }\n         }\n-        intravisit::walk_mod(self, m)\n+\n+        intravisit::walk_mod(self, m);\n     }\n \n     fn visit_macro_def(&mut self, md: &'v hir::MacroDef) {\n-        self.maybe_insert_id(md.id);\n+        self.update(md.id, Some(AccessLevel::Public));\n     }\n }\n \n@@ -1169,8 +1103,7 @@ impl<'a, 'tcx> SanePrivacyVisitor<'a, 'tcx> {\n \n struct VisiblePrivateTypesVisitor<'a, 'tcx: 'a> {\n     tcx: &'a ty::ctxt<'tcx>,\n-    exported_items: &'a ExportedItems,\n-    public_items: &'a PublicItems,\n+    access_levels: &'a AccessLevels,\n     in_variant: bool,\n }\n \n@@ -1210,7 +1143,7 @@ impl<'a, 'tcx> VisiblePrivateTypesVisitor<'a, 'tcx> {\n     fn trait_is_public(&self, trait_id: ast::NodeId) -> bool {\n         // FIXME: this would preferably be using `exported_items`, but all\n         // traits are exported currently (see `EmbargoVisitor.exported_trait`)\n-        self.public_items.contains(&trait_id)\n+        self.access_levels.is_public(trait_id)\n     }\n \n     fn check_ty_param_bound(&self,\n@@ -1226,7 +1159,7 @@ impl<'a, 'tcx> VisiblePrivateTypesVisitor<'a, 'tcx> {\n     }\n \n     fn item_is_public(&self, id: &ast::NodeId, vis: hir::Visibility) -> bool {\n-        self.exported_items.contains(id) || vis == hir::Public\n+        self.access_levels.is_reachable(*id) || vis == hir::Public\n     }\n }\n \n@@ -1332,7 +1265,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n                                   match impl_item.node {\n                                       hir::ImplItemKind::Const(..) |\n                                       hir::ImplItemKind::Method(..) => {\n-                                          self.exported_items.contains(&impl_item.id)\n+                                          self.access_levels.is_reachable(impl_item.id)\n                                       }\n                                       hir::ImplItemKind::Type(_) => false,\n                                   }\n@@ -1461,7 +1394,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n     }\n \n     fn visit_foreign_item(&mut self, item: &hir::ForeignItem) {\n-        if self.exported_items.contains(&item.id) {\n+        if self.access_levels.is_reachable(item.id) {\n             intravisit::walk_foreign_item(self, item)\n         }\n     }\n@@ -1479,7 +1412,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n     }\n \n     fn visit_variant(&mut self, v: &hir::Variant, g: &hir::Generics, item_id: ast::NodeId) {\n-        if self.exported_items.contains(&v.node.data.id()) {\n+        if self.access_levels.is_reachable(v.node.data.id()) {\n             self.in_variant = true;\n             intravisit::walk_variant(self, v, g, item_id);\n             self.in_variant = false;\n@@ -1509,7 +1442,7 @@ impl<'a, 'tcx, 'v> Visitor<'v> for VisiblePrivateTypesVisitor<'a, 'tcx> {\n pub fn check_crate(tcx: &ty::ctxt,\n                    export_map: &def::ExportMap,\n                    external_exports: ExternalExports)\n-                   -> (ExportedItems, PublicItems) {\n+                   -> AccessLevels {\n     let krate = tcx.map.krate();\n \n     // Sanity check to make sure that all privacy usage and controls are\n@@ -1544,33 +1477,31 @@ pub fn check_crate(tcx: &ty::ctxt,\n     // items which are reachable from external crates based on visibility.\n     let mut visitor = EmbargoVisitor {\n         tcx: tcx,\n-        exported_items: NodeSet(),\n-        public_items: NodeSet(),\n         export_map: export_map,\n-        prev_exported: true,\n-        prev_public: true,\n+        access_levels: Default::default(),\n+        prev_level: Some(AccessLevel::Public),\n+        changed: false,\n     };\n-    visitor.exported_items.insert(ast::CRATE_NODE_ID);\n-    visitor.public_items.insert(ast::CRATE_NODE_ID);\n     loop {\n-        let before = (visitor.exported_items.len(), visitor.public_items.len());\n         intravisit::walk_crate(&mut visitor, krate);\n-        let after = (visitor.exported_items.len(), visitor.public_items.len());\n-        if after == before {\n+        if visitor.changed {\n+            visitor.changed = false;\n+        } else {\n             break\n         }\n     }\n+    visitor.update(ast::CRATE_NODE_ID, Some(AccessLevel::Public));\n \n-    let EmbargoVisitor { exported_items, public_items, .. } = visitor;\n+    let EmbargoVisitor { access_levels, .. } = visitor;\n \n     {\n         let mut visitor = VisiblePrivateTypesVisitor {\n             tcx: tcx,\n-            exported_items: &exported_items,\n-            public_items: &public_items,\n+            access_levels: &access_levels,\n             in_variant: false,\n         };\n         intravisit::walk_crate(&mut visitor, krate);\n     }\n-    return (exported_items, public_items);\n+\n+    access_levels\n }"}, {"sha": "f20f5dbbc4e5def07f6c5ee581ff2ff6f4e8eca8", "filename": "src/librustdoc/core.rs", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/6a6b97cf025b8a1fb92fc48a4dc06611d2970861/src%2Flibrustdoc%2Fcore.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a6b97cf025b8a1fb92fc48a4dc06611d2970861/src%2Flibrustdoc%2Fcore.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fcore.rs?ref=6a6b97cf025b8a1fb92fc48a4dc06611d2970861", "patch": "@@ -13,10 +13,10 @@ use rustc_lint;\n use rustc_driver::{driver, target_features};\n use rustc::session::{self, config};\n use rustc::middle::def_id::DefId;\n+use rustc::middle::privacy::AccessLevels;\n use rustc::middle::ty;\n use rustc::front::map as hir_map;\n use rustc::lint;\n-use rustc::util::nodemap::DefIdSet;\n use rustc_trans::back::link;\n use rustc_resolve as resolve;\n use rustc_front::lowering::{lower_crate, LoweringContext};\n@@ -77,8 +77,7 @@ impl<'b, 'tcx> DocContext<'b, 'tcx> {\n }\n \n pub struct CrateAnalysis {\n-    pub exported_items: DefIdSet,\n-    pub public_items: DefIdSet,\n+    pub access_levels: AccessLevels<DefId>,\n     pub external_paths: ExternalPaths,\n     pub external_typarams: RefCell<Option<HashMap<DefId, String>>>,\n     pub inlined: RefCell<Option<HashSet<DefId>>>,\n@@ -147,18 +146,15 @@ pub fn run_core(search_paths: SearchPaths, cfgs: Vec<String>, externs: Externs,\n                                         &name,\n                                         resolve::MakeGlobMap::No,\n                                         |tcx, _, analysis| {\n-        let ty::CrateAnalysis { exported_items, public_items, .. } = analysis;\n+        let ty::CrateAnalysis { access_levels, .. } = analysis;\n \n         // Convert from a NodeId set to a DefId set since we don't always have easy access\n         // to the map from defid -> nodeid\n-        let exported_items: DefIdSet =\n-            exported_items.into_iter()\n-                          .map(|n| tcx.map.local_def_id(n))\n-                          .collect();\n-        let public_items: DefIdSet =\n-            public_items.into_iter()\n-                        .map(|n| tcx.map.local_def_id(n))\n-                        .collect();\n+        let access_levels = AccessLevels {\n+            map: access_levels.map.into_iter()\n+                                  .map(|(k, v)| (tcx.map.local_def_id(k), v))\n+                                  .collect()\n+        };\n \n         let ctxt = DocContext {\n             map: &tcx.map,\n@@ -174,8 +170,7 @@ pub fn run_core(search_paths: SearchPaths, cfgs: Vec<String>, externs: Externs,\n         debug!(\"crate: {:?}\", ctxt.map.krate());\n \n         let mut analysis = CrateAnalysis {\n-            exported_items: exported_items,\n-            public_items: public_items,\n+            access_levels: access_levels,\n             external_paths: RefCell::new(None),\n             external_typarams: RefCell::new(None),\n             inlined: RefCell::new(None),"}, {"sha": "1b98f5bae0cc2e6c7f7d1a1879b7b2b8ce30f7fe", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/6a6b97cf025b8a1fb92fc48a4dc06611d2970861/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a6b97cf025b8a1fb92fc48a4dc06611d2970861/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=6a6b97cf025b8a1fb92fc48a4dc06611d2970861", "patch": "@@ -56,8 +56,8 @@ use serialize::json::{self, ToJson};\n use syntax::{abi, ast};\n use rustc::metadata::cstore::LOCAL_CRATE;\n use rustc::middle::def_id::{CRATE_DEF_INDEX, DefId};\n+use rustc::middle::privacy::AccessLevels;\n use rustc::middle::stability;\n-use rustc::util::nodemap::DefIdSet;\n use rustc_front::hir;\n \n use clean::{self, SelfTy};\n@@ -244,7 +244,7 @@ pub struct Cache {\n     search_index: Vec<IndexItem>,\n     privmod: bool,\n     remove_priv: bool,\n-    public_items: DefIdSet,\n+    access_levels: AccessLevels<DefId>,\n     deref_trait_did: Option<DefId>,\n \n     // In rare case where a structure is defined in one module but implemented\n@@ -415,8 +415,8 @@ pub fn run(mut krate: clean::Crate,\n     // Crawl the crate to build various caches used for the output\n     let analysis = ::ANALYSISKEY.with(|a| a.clone());\n     let analysis = analysis.borrow();\n-    let public_items = analysis.as_ref().map(|a| a.public_items.clone());\n-    let public_items = public_items.unwrap_or(DefIdSet());\n+    let access_levels = analysis.as_ref().map(|a| a.access_levels.clone());\n+    let access_levels = access_levels.unwrap_or(Default::default());\n     let paths: HashMap<DefId, (Vec<String>, ItemType)> =\n       analysis.as_ref().map(|a| {\n         let paths = a.external_paths.borrow_mut().take().unwrap();\n@@ -435,7 +435,7 @@ pub fn run(mut krate: clean::Crate,\n         primitive_locations: HashMap::new(),\n         remove_priv: cx.passes.contains(\"strip-private\"),\n         privmod: false,\n-        public_items: public_items,\n+        access_levels: access_levels,\n         orphan_methods: Vec::new(),\n         traits: mem::replace(&mut krate.external_traits, HashMap::new()),\n         deref_trait_did: analysis.as_ref().and_then(|a| a.deref_trait_did),\n@@ -1053,7 +1053,7 @@ impl DocFolder for Cache {\n                 if\n                     !self.paths.contains_key(&item.def_id) ||\n                     !item.def_id.is_local() ||\n-                    self.public_items.contains(&item.def_id)\n+                    self.access_levels.is_public(item.def_id)\n                 {\n                     self.paths.insert(item.def_id,\n                                       (self.stack.clone(), shortty(&item)));"}, {"sha": "d011ba08a9ccc2199d629ac7bd204b2cf407dbda", "filename": "src/librustdoc/passes.rs", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/6a6b97cf025b8a1fb92fc48a4dc06611d2970861/src%2Flibrustdoc%2Fpasses.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a6b97cf025b8a1fb92fc48a4dc06611d2970861/src%2Flibrustdoc%2Fpasses.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fpasses.rs?ref=6a6b97cf025b8a1fb92fc48a4dc06611d2970861", "patch": "@@ -8,6 +8,8 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n+use rustc::middle::def_id::DefId;\n+use rustc::middle::privacy::AccessLevels;\n use rustc::util::nodemap::DefIdSet;\n use std::cmp;\n use std::string::String;\n@@ -96,13 +98,13 @@ pub fn strip_private(mut krate: clean::Crate) -> plugins::PluginResult {\n     let analysis = super::ANALYSISKEY.with(|a| a.clone());\n     let analysis = analysis.borrow();\n     let analysis = analysis.as_ref().unwrap();\n-    let exported_items = analysis.exported_items.clone();\n+    let access_levels = analysis.access_levels.clone();\n \n     // strip all private items\n     {\n         let mut stripper = Stripper {\n             retained: &mut retained,\n-            exported_items: &exported_items,\n+            access_levels: &access_levels,\n         };\n         krate = stripper.fold_crate(krate);\n     }\n@@ -117,7 +119,7 @@ pub fn strip_private(mut krate: clean::Crate) -> plugins::PluginResult {\n \n struct Stripper<'a> {\n     retained: &'a mut DefIdSet,\n-    exported_items: &'a DefIdSet,\n+    access_levels: &'a AccessLevels<DefId>,\n }\n \n impl<'a> fold::DocFolder for Stripper<'a> {\n@@ -130,18 +132,14 @@ impl<'a> fold::DocFolder for Stripper<'a> {\n             clean::VariantItem(..) | clean::MethodItem(..) |\n             clean::ForeignFunctionItem(..) | clean::ForeignStaticItem(..) => {\n                 if i.def_id.is_local() {\n-                    if !self.exported_items.contains(&i.def_id) {\n-                        return None;\n-                    }\n-                    // Traits are in exported_items even when they're totally private.\n-                    if i.is_trait() && i.visibility != Some(hir::Public) {\n+                    if !self.access_levels.is_exported(i.def_id) {\n                         return None;\n                     }\n                 }\n             }\n \n             clean::ConstantItem(..) => {\n-                if i.def_id.is_local() && !self.exported_items.contains(&i.def_id) {\n+                if i.def_id.is_local() && !self.access_levels.is_exported(i.def_id) {\n                     return None;\n                 }\n             }\n@@ -168,7 +166,7 @@ impl<'a> fold::DocFolder for Stripper<'a> {\n             clean::ImplItem(clean::Impl{\n                 for_: clean::ResolvedPath{ did, .. }, ..\n             }) => {\n-                if did.is_local() && !self.exported_items.contains(&did) {\n+                if did.is_local() && !self.access_levels.is_exported(did) {\n                     return None;\n                 }\n             }"}, {"sha": "150464404a22f860b88a7e1921f32c37cbf35e0b", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/6a6b97cf025b8a1fb92fc48a4dc06611d2970861/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/6a6b97cf025b8a1fb92fc48a4dc06611d2970861/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=6a6b97cf025b8a1fb92fc48a4dc06611d2970861", "patch": "@@ -214,7 +214,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         let analysis = match self.analysis {\n             Some(analysis) => analysis, None => return false\n         };\n-        if !please_inline && analysis.public_items.contains(&def) {\n+        if !please_inline && analysis.access_levels.is_public(def) {\n             return false\n         }\n         if !self.view_item_stack.insert(def_node_id) { return false }"}]}