{"sha": "070ab63807dc80fa6a6c5ee80531284761ab42de", "node_id": "MDY6Q29tbWl0NzI0NzEyOjA3MGFiNjM4MDdkYzgwZmE2YTZjNWVlODA1MzEyODQ3NjFhYjQyZGU=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-27T21:51:43Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-12-27T21:51:43Z"}, "message": "auto merge of #19916 : SimonSapin/rust/ascii-reform, r=sfackler\n\nImplements [RFC 486](https://github.com/rust-lang/rfcs/pull/486). Fixes #19908.\r\n\r\n* Rename `to_ascii_{lower,upper}` to `to_ascii_{lower,upper}case`, per #14401\r\n* Remove the `Ascii` type and associated traits: `AsciiCast`, `OwnedAsciiCast`, `AsciiStr`, `IntoBytes`, and `IntoString`.\r\n* As a replacement, add `.is_ascii()` to `AsciiExt`, and implement `AsciiExt` for `u8` and `char`.\r\n\r\n[breaking-change]", "tree": {"sha": "52706298e8d708cccdea4ad1781d58ea26887db1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/52706298e8d708cccdea4ad1781d58ea26887db1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/070ab63807dc80fa6a6c5ee80531284761ab42de", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/070ab63807dc80fa6a6c5ee80531284761ab42de", "html_url": "https://github.com/rust-lang/rust/commit/070ab63807dc80fa6a6c5ee80531284761ab42de", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/070ab63807dc80fa6a6c5ee80531284761ab42de/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0201334439393bed205c1148bed425b80aab8c22", "url": "https://api.github.com/repos/rust-lang/rust/commits/0201334439393bed205c1148bed425b80aab8c22", "html_url": "https://github.com/rust-lang/rust/commit/0201334439393bed205c1148bed425b80aab8c22"}, {"sha": "12e60719c4cd2f1f4f8790eb0452869c5816f7dd", "url": "https://api.github.com/repos/rust-lang/rust/commits/12e60719c4cd2f1f4f8790eb0452869c5816f7dd", "html_url": "https://github.com/rust-lang/rust/commit/12e60719c4cd2f1f4f8790eb0452869c5816f7dd"}], "stats": {"total": 762, "additions": 146, "deletions": 616}, "files": [{"sha": "16c6f7250306d96a82630b7bf9a839c1eaaa6180", "filename": "src/compiletest/errors.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/070ab63807dc80fa6a6c5ee80531284761ab42de/src%2Fcompiletest%2Ferrors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/070ab63807dc80fa6a6c5ee80531284761ab42de/src%2Fcompiletest%2Ferrors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Ferrors.rs?ref=070ab63807dc80fa6a6c5ee80531284761ab42de", "patch": "@@ -67,7 +67,7 @@ fn parse_expected(last_nonfollow_error: Option<uint>,\n                   re: &Regex) -> Option<(WhichLine, ExpectedError)> {\n     re.captures(line).and_then(|caps| {\n         let adjusts = caps.name(\"adjusts\").unwrap_or(\"\").len();\n-        let kind = caps.name(\"kind\").unwrap_or(\"\").to_ascii_lower();\n+        let kind = caps.name(\"kind\").unwrap_or(\"\").to_ascii_lowercase();\n         let msg = caps.name(\"msg\").unwrap_or(\"\").trim().to_string();\n         let follow = caps.name(\"follow\").unwrap_or(\"\").len() > 0;\n "}, {"sha": "1abcd8bd214075ecd264622abeea789b207264ab", "filename": "src/compiletest/runtest.rs", "status": "modified", "additions": 3, "deletions": 14, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/070ab63807dc80fa6a6c5ee80531284761ab42de/src%2Fcompiletest%2Fruntest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/070ab63807dc80fa6a6c5ee80531284761ab42de/src%2Fcompiletest%2Fruntest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcompiletest%2Fruntest.rs?ref=070ab63807dc80fa6a6c5ee80531284761ab42de", "patch": "@@ -21,6 +21,8 @@ use util::logv;\n #[cfg(target_os = \"windows\")]\n use util;\n \n+#[cfg(target_os = \"windows\")]\n+use std::ascii::AsciiExt;\n use std::io::File;\n use std::io::fs::PathExtensions;\n use std::io::fs;\n@@ -985,22 +987,9 @@ fn check_expected_errors(expected_errors: Vec<errors::ExpectedError> ,\n         format!(\"{}:{}:\", testfile.display(), ee.line)\n     }).collect::<Vec<String> >();\n \n-    #[cfg(target_os = \"windows\")]\n-    fn to_lower( s : &str ) -> String {\n-        let i = s.chars();\n-        let c : Vec<char> = i.map( |c| {\n-            if c.is_ascii() {\n-                c.to_ascii().to_lowercase().as_char()\n-            } else {\n-                c\n-            }\n-        } ).collect();\n-        String::from_chars(c.as_slice())\n-    }\n-\n     #[cfg(windows)]\n     fn prefix_matches( line : &str, prefix : &str ) -> bool {\n-        to_lower(line).as_slice().starts_with(to_lower(prefix).as_slice())\n+        line.to_ascii_lowercase().starts_with(prefix.to_ascii_lowercase().as_slice())\n     }\n \n     #[cfg(unix)]"}, {"sha": "787e999eea9f1eac75f33a8d3ac85f5714ede8e8", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/070ab63807dc80fa6a6c5ee80531284761ab42de/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/070ab63807dc80fa6a6c5ee80531284761ab42de/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=070ab63807dc80fa6a6c5ee80531284761ab42de", "patch": "@@ -68,7 +68,7 @@ pub struct Lint {\n impl Lint {\n     /// Get the lint's name, with ASCII letters converted to lowercase.\n     pub fn name_lower(&self) -> String {\n-        self.name.to_ascii_lower()\n+        self.name.to_ascii_lowercase()\n     }\n }\n "}, {"sha": "bff670f9ea95450957a81001881794da9a12fe64", "filename": "src/librustdoc/html/markdown.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/070ab63807dc80fa6a6c5ee80531284761ab42de/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "raw_url": "https://github.com/rust-lang/rust/raw/070ab63807dc80fa6a6c5ee80531284761ab42de/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fmarkdown.rs?ref=070ab63807dc80fa6a6c5ee80531284761ab42de", "patch": "@@ -235,7 +235,7 @@ pub fn render(w: &mut fmt::Formatter, s: &str, print_toc: bool) -> fmt::Result {\n         };\n \n         // Transform the contents of the header into a hyphenated string\n-        let id = s.words().map(|s| s.to_ascii_lower())\n+        let id = s.words().map(|s| s.to_ascii_lowercase())\n             .collect::<Vec<String>>().connect(\"-\");\n \n         // This is a terrible hack working around how hoedown gives us rendered"}, {"sha": "7bd955a905bbd00c6e9b60d9f2142adee6b6d769", "filename": "src/libstd/ascii.rs", "status": "modified", "additions": 115, "deletions": 568, "changes": 683, "blob_url": "https://github.com/rust-lang/rust/blob/070ab63807dc80fa6a6c5ee80531284761ab42de/src%2Flibstd%2Fascii.rs", "raw_url": "https://github.com/rust-lang/rust/raw/070ab63807dc80fa6a6c5ee80531284761ab42de/src%2Flibstd%2Fascii.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fascii.rs?ref=070ab63807dc80fa6a6c5ee80531284761ab42de", "patch": "@@ -16,500 +16,185 @@\n #![allow(deprecated)]\n \n use core::kinds::Sized;\n-use fmt;\n use iter::IteratorExt;\n-use mem;\n use ops::FnMut;\n-use option::Option;\n-use option::Option::{Some, None};\n-use slice::{SliceExt, AsSlice};\n-use str::{Str, StrExt};\n-use string::{String, IntoString};\n+use slice::SliceExt;\n+use str::StrExt;\n+use string::String;\n use vec::Vec;\n \n-/// Datatype to hold one ascii character. It wraps a `u8`, with the highest bit always zero.\n-#[deriving(Clone, Copy, PartialEq, PartialOrd, Ord, Eq, Hash)]\n-pub struct Ascii { chr: u8 }\n-\n-impl Ascii {\n-    /// Converts an ascii character into a `u8`.\n-    #[inline]\n-    #[unstable = \"recently renamed\"]\n-    pub fn as_byte(&self) -> u8 {\n-        self.chr\n-    }\n-\n-    /// Deprecated: use `as_byte` instead.\n-    #[deprecated = \"use as_byte\"]\n-    pub fn to_byte(self) -> u8 {\n-        self.as_byte()\n-    }\n-\n-    /// Converts an ascii character into a `char`.\n-    #[inline]\n-    #[unstable = \"recently renamed\"]\n-    pub fn as_char(&self) -> char {\n-        self.chr as char\n-    }\n-\n-    /// Deprecated: use `as_char` instead.\n-    #[deprecated = \"use as_char\"]\n-    pub fn to_char(self) -> char {\n-        self.as_char()\n-    }\n-\n-    /// Convert to lowercase.\n-    #[inline]\n-    #[stable]\n-    pub fn to_lowercase(&self) -> Ascii {\n-        Ascii{chr: ASCII_LOWER_MAP[self.chr as uint]}\n-    }\n-\n-    /// Convert to uppercase.\n-    #[inline]\n-    #[stable]\n-    pub fn to_uppercase(&self) -> Ascii {\n-        Ascii{chr: ASCII_UPPER_MAP[self.chr as uint]}\n-    }\n-\n-    /// Compares two ascii characters of equality, ignoring case.\n-    #[inline]\n-    #[deprecated = \"normalize with to_lowercase\"]\n-    pub fn eq_ignore_case(self, other: Ascii) -> bool {\n-        ASCII_LOWER_MAP[self.chr as uint] == ASCII_LOWER_MAP[other.chr as uint]\n-    }\n-\n-    // the following methods are like ctype, and the implementation is inspired by musl\n-\n-    /// Check if the character is a letter (a-z, A-Z)\n-    #[inline]\n-    #[stable]\n-    pub fn is_alphabetic(&self) -> bool {\n-        (self.chr >= 0x41 && self.chr <= 0x5A) || (self.chr >= 0x61 && self.chr <= 0x7A)\n-    }\n-\n-    /// Check if the character is a number (0-9)\n-    #[inline]\n-    #[unstable = \"may be renamed\"]\n-    pub fn is_digit(&self) -> bool {\n-        self.chr >= 0x30 && self.chr <= 0x39\n-    }\n-\n-    /// Check if the character is a letter or number\n-    #[inline]\n-    #[stable]\n-    pub fn is_alphanumeric(&self) -> bool {\n-        self.is_alphabetic() || self.is_digit()\n-    }\n-\n-    /// Check if the character is a space or horizontal tab\n-    #[inline]\n-    #[experimental = \"likely to be removed\"]\n-    pub fn is_blank(&self) -> bool {\n-        self.chr == b' ' || self.chr == b'\\t'\n-    }\n-\n-    /// Check if the character is a control character\n-    #[inline]\n-    #[stable]\n-    pub fn is_control(&self) -> bool {\n-        self.chr < 0x20 || self.chr == 0x7F\n-    }\n-\n-    /// Checks if the character is printable (except space)\n-    #[inline]\n-    #[experimental = \"unsure about naming, or whether this is needed\"]\n-    pub fn is_graph(&self) -> bool {\n-        (self.chr - 0x21) < 0x5E\n-    }\n-\n-    /// Checks if the character is printable (including space)\n-    #[inline]\n-    #[unstable = \"unsure about naming\"]\n-    pub fn is_print(&self) -> bool {\n-        (self.chr - 0x20) < 0x5F\n-    }\n-\n-    /// Checks if the character is alphabetic and lowercase\n-    #[inline]\n-    #[stable]\n-    pub fn is_lowercase(&self) -> bool {\n-        (self.chr - b'a') < 26\n-    }\n-\n-    /// Checks if the character is alphabetic and uppercase\n-    #[inline]\n-    #[stable]\n-    pub fn is_uppercase(&self) -> bool {\n-        (self.chr - b'A') < 26\n-    }\n-\n-    /// Checks if the character is punctuation\n-    #[inline]\n-    #[stable]\n-    pub fn is_punctuation(&self) -> bool {\n-        self.is_graph() && !self.is_alphanumeric()\n-    }\n-\n-    /// Checks if the character is a valid hex digit\n-    #[inline]\n-    #[stable]\n-    pub fn is_hex(&self) -> bool {\n-        self.is_digit() || ((self.chr | 32u8) - b'a') < 6\n-    }\n-}\n+/// Extension methods for ASCII-subset only operations on owned strings\n+#[experimental = \"would prefer to do this in a more general way\"]\n+pub trait OwnedAsciiExt {\n+    /// Convert the string to ASCII upper case:\n+    /// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n+    /// but non-ASCII letters are unchanged.\n+    fn into_ascii_uppercase(self) -> Self;\n \n-impl<'a> fmt::Show for Ascii {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        (self.chr as char).fmt(f)\n-    }\n+    /// Convert the string to ASCII lower case:\n+    /// ASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\n+    /// but non-ASCII letters are unchanged.\n+    fn into_ascii_lowercase(self) -> Self;\n }\n \n-/// Trait for converting into an ascii type.\n-#[experimental = \"may be replaced by generic conversion traits\"]\n-pub trait AsciiCast<T> for Sized? {\n-    /// Convert to an ascii type, panic on non-ASCII input.\n-    #[inline]\n-    fn to_ascii(&self) -> T {\n-        assert!(self.is_ascii());\n-        unsafe {self.to_ascii_nocheck()}\n-    }\n-\n-    /// Convert to an ascii type, return None on non-ASCII input.\n-    #[inline]\n-    fn to_ascii_opt(&self) -> Option<T> {\n-        if self.is_ascii() {\n-            Some(unsafe { self.to_ascii_nocheck() })\n-        } else {\n-            None\n-        }\n-    }\n-\n-    /// Convert to an ascii type, not doing any range asserts\n-    unsafe fn to_ascii_nocheck(&self) -> T;\n-\n-    /// Check if convertible to ascii\n+/// Extension methods for ASCII-subset only operations on string slices\n+#[experimental = \"would prefer to do this in a more general way\"]\n+pub trait AsciiExt<T = Self> for Sized? {\n+    /// Check if within the ASCII range.\n     fn is_ascii(&self) -> bool;\n-}\n \n-#[experimental = \"may be replaced by generic conversion traits\"]\n-impl<'a> AsciiCast<&'a[Ascii]> for [u8] {\n-    #[inline]\n-    unsafe fn to_ascii_nocheck(&self) -> &'a[Ascii] {\n-        mem::transmute(self)\n-    }\n+    /// Makes a copy of the string in ASCII upper case:\n+    /// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n+    /// but non-ASCII letters are unchanged.\n+    fn to_ascii_uppercase(&self) -> T;\n \n-    #[inline]\n-    fn is_ascii(&self) -> bool {\n-        for b in self.iter() {\n-            if !b.is_ascii() { return false; }\n-        }\n-        true\n-    }\n-}\n+    /// Makes a copy of the string in ASCII lower case:\n+    /// ASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\n+    /// but non-ASCII letters are unchanged.\n+    fn to_ascii_lowercase(&self) -> T;\n \n-#[experimental = \"may be replaced by generic conversion traits\"]\n-impl<'a> AsciiCast<&'a [Ascii]> for str {\n-    #[inline]\n-    unsafe fn to_ascii_nocheck(&self) -> &'a [Ascii] {\n-        mem::transmute(self)\n-    }\n+    /// Check that two strings are an ASCII case-insensitive match.\n+    /// Same as `to_ascii_lowercase(a) == to_ascii_lower(b)`,\n+    /// but without allocating and copying temporary strings.\n+    fn eq_ignore_ascii_case(&self, other: &Self) -> bool;\n+}\n \n+#[experimental = \"would prefer to do this in a more general way\"]\n+impl AsciiExt<String> for str {\n     #[inline]\n     fn is_ascii(&self) -> bool {\n         self.bytes().all(|b| b.is_ascii())\n     }\n-}\n-\n-#[experimental = \"may be replaced by generic conversion traits\"]\n-impl AsciiCast<Ascii> for u8 {\n-    #[inline]\n-    unsafe fn to_ascii_nocheck(&self) -> Ascii {\n-        Ascii{ chr: *self }\n-    }\n \n     #[inline]\n-    fn is_ascii(&self) -> bool {\n-        *self & 128 == 0u8\n+    fn to_ascii_uppercase(&self) -> String {\n+        // Vec<u8>::to_ascii_uppercase() preserves the UTF-8 invariant.\n+        unsafe { String::from_utf8_unchecked(self.as_bytes().to_ascii_uppercase()) }\n     }\n-}\n \n-#[experimental = \"may be replaced by generic conversion traits\"]\n-impl AsciiCast<Ascii> for char {\n     #[inline]\n-    unsafe fn to_ascii_nocheck(&self) -> Ascii {\n-        Ascii{ chr: *self as u8 }\n+    fn to_ascii_lowercase(&self) -> String {\n+        // Vec<u8>::to_ascii_lowercase() preserves the UTF-8 invariant.\n+        unsafe { String::from_utf8_unchecked(self.as_bytes().to_ascii_lowercase()) }\n     }\n \n     #[inline]\n-    fn is_ascii(&self) -> bool {\n-        *self as u32 - ('\\x7F' as u32 & *self as u32) == 0\n+    fn eq_ignore_ascii_case(&self, other: &str) -> bool {\n+        self.as_bytes().eq_ignore_ascii_case(other.as_bytes())\n     }\n }\n \n-/// Trait for copyless casting to an ascii vector.\n-#[experimental = \"may be replaced by generic conversion traits\"]\n-pub trait OwnedAsciiCast {\n-    /// Check if convertible to ascii\n-    fn is_ascii(&self) -> bool;\n-\n-    /// Take ownership and cast to an ascii vector.\n-    /// # Panics\n-    ///\n-    /// Panic on non-ASCII input.\n+#[experimental = \"would prefer to do this in a more general way\"]\n+impl OwnedAsciiExt for String {\n     #[inline]\n-    fn into_ascii(self) -> Vec<Ascii> {\n-        assert!(self.is_ascii());\n-        unsafe {self.into_ascii_nocheck()}\n+    fn into_ascii_uppercase(self) -> String {\n+        // Vec<u8>::into_ascii_uppercase() preserves the UTF-8 invariant.\n+        unsafe { String::from_utf8_unchecked(self.into_bytes().into_ascii_uppercase()) }\n     }\n \n-    /// Take ownership and cast to an ascii vector. Return None on non-ASCII input.\n     #[inline]\n-    fn into_ascii_opt(self) -> Option<Vec<Ascii>> {\n-        if self.is_ascii() {\n-            Some(unsafe { self.into_ascii_nocheck() })\n-        } else {\n-            None\n-        }\n+    fn into_ascii_lowercase(self) -> String {\n+        // Vec<u8>::into_ascii_lowercase() preserves the UTF-8 invariant.\n+        unsafe { String::from_utf8_unchecked(self.into_bytes().into_ascii_lowercase()) }\n     }\n-\n-    /// Take ownership and cast to an ascii vector.\n-    /// Does not perform validation checks.\n-    unsafe fn into_ascii_nocheck(self) -> Vec<Ascii>;\n }\n \n-#[experimental = \"may be replaced by generic conversion traits\"]\n-impl OwnedAsciiCast for String {\n+#[experimental = \"would prefer to do this in a more general way\"]\n+impl AsciiExt<Vec<u8>> for [u8] {\n     #[inline]\n     fn is_ascii(&self) -> bool {\n-        self.as_slice().is_ascii()\n+        self.iter().all(|b| b.is_ascii())\n     }\n \n     #[inline]\n-    unsafe fn into_ascii_nocheck(self) -> Vec<Ascii> {\n-        self.into_bytes().into_ascii_nocheck()\n+    fn to_ascii_uppercase(&self) -> Vec<u8> {\n+        self.iter().map(|b| b.to_ascii_uppercase()).collect()\n     }\n-}\n \n-#[experimental = \"may be replaced by generic conversion traits\"]\n-impl OwnedAsciiCast for Vec<u8> {\n     #[inline]\n-    fn is_ascii(&self) -> bool {\n-        self.as_slice().is_ascii()\n+    fn to_ascii_lowercase(&self) -> Vec<u8> {\n+        self.iter().map(|b| b.to_ascii_lowercase()).collect()\n     }\n \n     #[inline]\n-    unsafe fn into_ascii_nocheck(self) -> Vec<Ascii> {\n-        let v = Vec::from_raw_parts(self.as_ptr() as *mut Ascii,\n-                                    self.len(),\n-                                    self.capacity());\n-\n-        // We forget `self` to avoid freeing it at the end of the scope\n-        // Otherwise, the returned `Vec` would point to freed memory\n-        mem::forget(self);\n-        v\n+    fn eq_ignore_ascii_case(&self, other: &[u8]) -> bool {\n+        self.len() == other.len() &&\n+        self.iter().zip(other.iter()).all(|(a, b)| {\n+            a.eq_ignore_ascii_case(b)\n+        })\n     }\n }\n \n-/// Trait for converting an ascii type to a string. Needed to convert\n-/// `&[Ascii]` to `&str`.\n-#[experimental = \"may be replaced by generic conversion traits\"]\n-pub trait AsciiStr for Sized? {\n-    /// Convert to a string.\n-    fn as_str_ascii<'a>(&'a self) -> &'a str;\n-\n-    /// Deprecated: use `to_lowercase`\n-    #[deprecated=\"renamed `to_lowercase`\"]\n-    fn to_lower(&self) -> Vec<Ascii>;\n-\n-    /// Convert to vector representing a lower cased ascii string.\n-    #[deprecated = \"use iterators instead\"]\n-    fn to_lowercase(&self) -> Vec<Ascii>;\n-\n-    /// Deprecated: use `to_uppercase`\n-    #[deprecated=\"renamed `to_uppercase`\"]\n-    fn to_upper(&self) -> Vec<Ascii>;\n-\n-    /// Convert to vector representing a upper cased ascii string.\n-    #[deprecated = \"use iterators instead\"]\n-    fn to_uppercase(&self) -> Vec<Ascii>;\n-\n-    /// Compares two Ascii strings ignoring case.\n-    #[deprecated = \"use iterators instead\"]\n-    fn eq_ignore_case(&self, other: &[Ascii]) -> bool;\n-}\n-\n-#[experimental = \"may be replaced by generic conversion traits\"]\n-impl AsciiStr for [Ascii] {\n-    #[inline]\n-    fn as_str_ascii<'a>(&'a self) -> &'a str {\n-        unsafe { mem::transmute(self) }\n-    }\n-\n-    #[inline]\n-    fn to_lower(&self) -> Vec<Ascii> {\n-      self.to_lowercase()\n-    }\n-\n-    #[inline]\n-    fn to_lowercase(&self) -> Vec<Ascii> {\n-        self.iter().map(|a| a.to_lowercase()).collect()\n-    }\n-\n-    #[inline]\n-    fn to_upper(&self) -> Vec<Ascii> {\n-      self.to_uppercase()\n-    }\n-\n-    #[inline]\n-    fn to_uppercase(&self) -> Vec<Ascii> {\n-        self.iter().map(|a| a.to_uppercase()).collect()\n-    }\n-\n+#[experimental = \"would prefer to do this in a more general way\"]\n+impl OwnedAsciiExt for Vec<u8> {\n     #[inline]\n-    fn eq_ignore_case(&self, other: &[Ascii]) -> bool {\n-        self.iter().zip(other.iter()).all(|(&a, &b)| a.eq_ignore_case(b))\n+    fn into_ascii_uppercase(mut self) -> Vec<u8> {\n+        for byte in self.iter_mut() {\n+            *byte = byte.to_ascii_uppercase();\n+        }\n+        self\n     }\n-}\n \n-impl IntoString for Vec<Ascii> {\n     #[inline]\n-    fn into_string(self) -> String {\n-        unsafe { String::from_utf8_unchecked(self.into_bytes()) }\n-    }\n-}\n-\n-/// Trait to convert to an owned byte vector by consuming self\n-#[experimental = \"may be replaced by generic conversion traits\"]\n-pub trait IntoBytes {\n-    /// Converts to an owned byte vector by consuming self\n-    fn into_bytes(self) -> Vec<u8>;\n-}\n-\n-#[experimental = \"may be replaced by generic conversion traits\"]\n-impl IntoBytes for Vec<Ascii> {\n-    fn into_bytes(self) -> Vec<u8> {\n-        unsafe {\n-            let v = Vec::from_raw_parts(self.as_ptr() as *mut u8,\n-                                        self.len(),\n-                                        self.capacity());\n-\n-            // We forget `self` to avoid freeing it at the end of the scope\n-            // Otherwise, the returned `Vec` would point to freed memory\n-            mem::forget(self);\n-            v\n+    fn into_ascii_lowercase(mut self) -> Vec<u8> {\n+        for byte in self.iter_mut() {\n+            *byte = byte.to_ascii_lowercase();\n         }\n+        self\n     }\n }\n \n-\n-/// Extension methods for ASCII-subset only operations on owned strings\n #[experimental = \"would prefer to do this in a more general way\"]\n-pub trait OwnedAsciiExt {\n-    /// Convert the string to ASCII upper case:\n-    /// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n-    /// but non-ASCII letters are unchanged.\n-    fn into_ascii_upper(self) -> Self;\n-\n-    /// Convert the string to ASCII lower case:\n-    /// ASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\n-    /// but non-ASCII letters are unchanged.\n-    fn into_ascii_lower(self) -> Self;\n-}\n-\n-/// Extension methods for ASCII-subset only operations on string slices\n-#[experimental = \"would prefer to do this in a more general way\"]\n-pub trait AsciiExt<T> for Sized? {\n-    /// Makes a copy of the string in ASCII upper case:\n-    /// ASCII letters 'a' to 'z' are mapped to 'A' to 'Z',\n-    /// but non-ASCII letters are unchanged.\n-    fn to_ascii_upper(&self) -> T;\n-\n-    /// Makes a copy of the string in ASCII lower case:\n-    /// ASCII letters 'A' to 'Z' are mapped to 'a' to 'z',\n-    /// but non-ASCII letters are unchanged.\n-    fn to_ascii_lower(&self) -> T;\n-\n-    /// Check that two strings are an ASCII case-insensitive match.\n-    /// Same as `to_ascii_lower(a) == to_ascii_lower(b)`,\n-    /// but without allocating and copying temporary strings.\n-    fn eq_ignore_ascii_case(&self, other: &Self) -> bool;\n-}\n-\n-#[experimental = \"would prefer to do this in a more general way\"]\n-impl AsciiExt<String> for str {\n-    #[inline]\n-    fn to_ascii_upper(&self) -> String {\n-        // Vec<u8>::to_ascii_upper() preserves the UTF-8 invariant.\n-        unsafe { String::from_utf8_unchecked(self.as_bytes().to_ascii_upper()) }\n-    }\n-\n+impl AsciiExt for u8 {\n     #[inline]\n-    fn to_ascii_lower(&self) -> String {\n-        // Vec<u8>::to_ascii_lower() preserves the UTF-8 invariant.\n-        unsafe { String::from_utf8_unchecked(self.as_bytes().to_ascii_lower()) }\n+    fn is_ascii(&self) -> bool {\n+        *self & 128 == 0u8\n     }\n \n     #[inline]\n-    fn eq_ignore_ascii_case(&self, other: &str) -> bool {\n-        self.as_bytes().eq_ignore_ascii_case(other.as_bytes())\n+    fn to_ascii_uppercase(&self) -> u8 {\n+        ASCII_UPPERCASE_MAP[*self as uint]\n     }\n-}\n \n-#[experimental = \"would prefer to do this in a more general way\"]\n-impl OwnedAsciiExt for String {\n     #[inline]\n-    fn into_ascii_upper(self) -> String {\n-        // Vec<u8>::into_ascii_upper() preserves the UTF-8 invariant.\n-        unsafe { String::from_utf8_unchecked(self.into_bytes().into_ascii_upper()) }\n+    fn to_ascii_lowercase(&self) -> u8 {\n+        ASCII_LOWERCASE_MAP[*self as uint]\n     }\n \n     #[inline]\n-    fn into_ascii_lower(self) -> String {\n-        // Vec<u8>::into_ascii_lower() preserves the UTF-8 invariant.\n-        unsafe { String::from_utf8_unchecked(self.into_bytes().into_ascii_lower()) }\n+    fn eq_ignore_ascii_case(&self, other: &u8) -> bool {\n+        self.to_ascii_lowercase() == other.to_ascii_lowercase()\n     }\n }\n \n #[experimental = \"would prefer to do this in a more general way\"]\n-impl AsciiExt<Vec<u8>> for [u8] {\n-    #[inline]\n-    fn to_ascii_upper(&self) -> Vec<u8> {\n-        self.iter().map(|&byte| ASCII_UPPER_MAP[byte as uint]).collect()\n-    }\n-\n+impl AsciiExt for char {\n     #[inline]\n-    fn to_ascii_lower(&self) -> Vec<u8> {\n-        self.iter().map(|&byte| ASCII_LOWER_MAP[byte as uint]).collect()\n+    fn is_ascii(&self) -> bool {\n+        *self as u32 <= 0x7F\n     }\n \n     #[inline]\n-    fn eq_ignore_ascii_case(&self, other: &[u8]) -> bool {\n-        self.len() == other.len() &&\n-            self.iter().zip(other.iter()).all(\n-            |(byte_self, byte_other)| {\n-                ASCII_LOWER_MAP[*byte_self as uint] ==\n-                    ASCII_LOWER_MAP[*byte_other as uint]\n-            })\n+    fn to_ascii_uppercase(&self) -> char {\n+        if self.is_ascii() {\n+            (*self as u8).to_ascii_uppercase() as char\n+        } else {\n+            *self\n+        }\n     }\n-}\n \n-#[experimental = \"would prefer to do this in a more general way\"]\n-impl OwnedAsciiExt for Vec<u8> {\n     #[inline]\n-    fn into_ascii_upper(mut self) -> Vec<u8> {\n-        for byte in self.iter_mut() {\n-            *byte = ASCII_UPPER_MAP[*byte as uint];\n+    fn to_ascii_lowercase(&self) -> char {\n+        if self.is_ascii() {\n+            (*self as u8).to_ascii_lowercase() as char\n+        } else {\n+            *self\n         }\n-        self\n     }\n \n     #[inline]\n-    fn into_ascii_lower(mut self) -> Vec<u8> {\n-        for byte in self.iter_mut() {\n-            *byte = ASCII_LOWER_MAP[*byte as uint];\n-        }\n-        self\n+    fn eq_ignore_ascii_case(&self, other: &char) -> bool {\n+        self.to_ascii_lowercase() == other.to_ascii_lowercase()\n     }\n }\n \n@@ -549,7 +234,7 @@ pub fn escape_default<F>(c: u8, mut f: F) where\n     }\n }\n \n-static ASCII_LOWER_MAP: [u8, ..256] = [\n+static ASCII_LOWERCASE_MAP: [u8, ..256] = [\n     0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n     0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n     0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n@@ -588,7 +273,7 @@ static ASCII_LOWER_MAP: [u8, ..256] = [\n     0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff,\n ];\n \n-static ASCII_UPPER_MAP: [u8, ..256] = [\n+static ASCII_UPPERCASE_MAP: [u8, ..256] = [\n     0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07,\n     0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f,\n     0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17,\n@@ -634,205 +319,79 @@ mod tests {\n     use prelude::*;\n     use char::from_u32;\n \n-    macro_rules! v2ascii {\n-        ( [$($e:expr),*]) => (&[$(Ascii{chr:$e}),*]);\n-        (&[$($e:expr),*]) => (&[$(Ascii{chr:$e}),*]);\n-    }\n-\n-    macro_rules! vec2ascii {\n-        ($($e:expr),*) => ([$(Ascii{chr:$e}),*].to_vec());\n-    }\n-\n     #[test]\n     fn test_ascii() {\n-        assert_eq!(65u8.to_ascii().to_byte(), 65u8);\n-        assert_eq!(65u8.to_ascii().to_char(), 'A');\n-        assert_eq!('A'.to_ascii().to_char(), 'A');\n-        assert_eq!('A'.to_ascii().to_byte(), 65u8);\n-\n-        assert_eq!('A'.to_ascii().to_lowercase().to_char(), 'a');\n-        assert_eq!('Z'.to_ascii().to_lowercase().to_char(), 'z');\n-        assert_eq!('a'.to_ascii().to_uppercase().to_char(), 'A');\n-        assert_eq!('z'.to_ascii().to_uppercase().to_char(), 'Z');\n-\n-        assert_eq!('@'.to_ascii().to_lowercase().to_char(), '@');\n-        assert_eq!('['.to_ascii().to_lowercase().to_char(), '[');\n-        assert_eq!('`'.to_ascii().to_uppercase().to_char(), '`');\n-        assert_eq!('{'.to_ascii().to_uppercase().to_char(), '{');\n-\n-        assert!('0'.to_ascii().is_digit());\n-        assert!('9'.to_ascii().is_digit());\n-        assert!(!'/'.to_ascii().is_digit());\n-        assert!(!':'.to_ascii().is_digit());\n-\n-        assert!((0x1fu8).to_ascii().is_control());\n-        assert!(!' '.to_ascii().is_control());\n-        assert!((0x7fu8).to_ascii().is_control());\n-\n         assert!(\"banana\".chars().all(|c| c.is_ascii()));\n         assert!(!\"\u0e1b\u0e23\u0e30\u0e40\u0e17\u0e28\u0e44\u0e17\u0e22\u4e2d\u534eVi\u1ec7t Nam\".chars().all(|c| c.is_ascii()));\n     }\n \n     #[test]\n     fn test_ascii_vec() {\n-        let test = &[40u8, 32u8, 59u8];\n-        let b: &[_] = v2ascii!([40, 32, 59]);\n-        assert_eq!(test.to_ascii(), b);\n-        assert_eq!(\"( ;\".to_ascii(), b);\n-        let v = vec![40u8, 32u8, 59u8];\n-        assert_eq!(v.to_ascii(), b);\n-        assert_eq!(\"( ;\".to_string().to_ascii(), b);\n-\n-        assert_eq!(\"abCDef&?#\".to_ascii().to_lowercase().into_string(), \"abcdef&?#\");\n-        assert_eq!(\"abCDef&?#\".to_ascii().to_uppercase().into_string(), \"ABCDEF&?#\");\n-\n-        assert_eq!(\"\".to_ascii().to_lowercase().into_string(), \"\");\n-        assert_eq!(\"YMCA\".to_ascii().to_lowercase().into_string(), \"ymca\");\n-        let mixed = \"abcDEFxyz:.;\".to_ascii();\n-        assert_eq!(mixed.to_uppercase().into_string(), \"ABCDEFXYZ:.;\");\n-\n-        assert!(\"aBcDeF&?#\".to_ascii().eq_ignore_case(\"AbCdEf&?#\".to_ascii()));\n-\n         assert!(\"\".is_ascii());\n         assert!(\"a\".is_ascii());\n         assert!(!\"\\u{2009}\".is_ascii());\n \n     }\n \n     #[test]\n-    fn test_ascii_vec_ng() {\n-        assert_eq!(\"abCDef&?#\".to_ascii().to_lowercase().into_string(), \"abcdef&?#\");\n-        assert_eq!(\"abCDef&?#\".to_ascii().to_uppercase().into_string(), \"ABCDEF&?#\");\n-        assert_eq!(\"\".to_ascii().to_lowercase().into_string(), \"\");\n-        assert_eq!(\"YMCA\".to_ascii().to_lowercase().into_string(), \"ymca\");\n-        let mixed = \"abcDEFxyz:.;\".to_ascii();\n-        assert_eq!(mixed.to_uppercase().into_string(), \"ABCDEFXYZ:.;\");\n-    }\n-\n-    #[test]\n-    fn test_owned_ascii_vec() {\n-        assert_eq!((\"( ;\".to_string()).into_ascii(), vec2ascii![40, 32, 59]);\n-        assert_eq!((vec![40u8, 32u8, 59u8]).into_ascii(), vec2ascii![40, 32, 59]);\n-    }\n-\n-    #[test]\n-    fn test_ascii_as_str() {\n-        let v = v2ascii!([40, 32, 59]);\n-        assert_eq!(v.as_str_ascii(), \"( ;\");\n-    }\n-\n-    #[test]\n-    fn test_ascii_into_string() {\n-        assert_eq!(vec2ascii![40, 32, 59].into_string(), \"( ;\");\n-        assert_eq!(vec2ascii!(40, 32, 59).into_string(), \"( ;\");\n-    }\n-\n-    #[test]\n-    fn test_ascii_to_bytes() {\n-        assert_eq!(vec2ascii![40, 32, 59].into_bytes(), vec![40u8, 32u8, 59u8]);\n-    }\n-\n-    #[test] #[should_fail]\n-    fn test_ascii_vec_panic_u8_slice()  { (&[127u8, 128u8, 255u8]).to_ascii(); }\n-\n-    #[test] #[should_fail]\n-    fn test_ascii_vec_panic_str_slice() { \"zo\u00e4\u534e\".to_ascii(); }\n-\n-    #[test] #[should_fail]\n-    fn test_ascii_panic_u8_slice() { 255u8.to_ascii(); }\n-\n-    #[test] #[should_fail]\n-    fn test_ascii_panic_char_slice() { '\u03bb'.to_ascii(); }\n-\n-    #[test]\n-    fn test_opt() {\n-        assert_eq!(65u8.to_ascii_opt(), Some(Ascii { chr: 65u8 }));\n-        assert_eq!(255u8.to_ascii_opt(), None);\n-\n-        assert_eq!('A'.to_ascii_opt(), Some(Ascii { chr: 65u8 }));\n-        assert_eq!('\u03bb'.to_ascii_opt(), None);\n-\n-        assert_eq!(\"zo\u00e4\u534e\".to_ascii_opt(), None);\n-\n-        let test1 = &[127u8, 128u8, 255u8];\n-        assert_eq!((test1).to_ascii_opt(), None);\n-\n-        let v = [40u8, 32u8, 59u8];\n-        let v2: &[_] = v2ascii!(&[40, 32, 59]);\n-        assert_eq!(v.to_ascii_opt(), Some(v2));\n-        let v = [127u8, 128u8, 255u8];\n-        assert_eq!(v.to_ascii_opt(), None);\n-\n-        let v = \"( ;\";\n-        assert_eq!(v.to_ascii_opt(), Some(v2));\n-        assert_eq!(\"zo\u00e4\u534e\".to_ascii_opt(), None);\n-\n-        assert_eq!((vec![40u8, 32u8, 59u8]).into_ascii_opt(), Some(vec2ascii![40, 32, 59]));\n-        assert_eq!((vec![127u8, 128u8, 255u8]).into_ascii_opt(), None);\n-\n-        assert_eq!((\"( ;\".to_string()).into_ascii_opt(), Some(vec2ascii![40, 32, 59]));\n-        assert_eq!((\"zo\u00e4\u534e\".to_string()).into_ascii_opt(), None);\n-    }\n-\n-    #[test]\n-    fn test_to_ascii_upper() {\n-        assert_eq!(\"url()URL()uRl()\u00fcrl\".to_ascii_upper(), \"URL()URL()URL()\u00fcRL\");\n-        assert_eq!(\"h\u0131\u212a\u00df\".to_ascii_upper(), \"H\u0131\u212a\u00df\");\n+    fn test_to_ascii_uppercase() {\n+        assert_eq!(\"url()URL()uRl()\u00fcrl\".to_ascii_uppercase(), \"URL()URL()URL()\u00fcRL\");\n+        assert_eq!(\"h\u0131\u212a\u00df\".to_ascii_uppercase(), \"H\u0131\u212a\u00df\");\n \n         let mut i = 0;\n         while i <= 500 {\n             let upper = if 'a' as u32 <= i && i <= 'z' as u32 { i + 'A' as u32 - 'a' as u32 }\n                         else { i };\n-            assert_eq!((from_u32(i).unwrap()).to_string().to_ascii_upper(),\n+            assert_eq!((from_u32(i).unwrap()).to_string().to_ascii_uppercase(),\n                        (from_u32(upper).unwrap()).to_string());\n             i += 1;\n         }\n     }\n \n     #[test]\n-    fn test_to_ascii_lower() {\n-        assert_eq!(\"url()URL()uRl()\u00dcrl\".to_ascii_lower(), \"url()url()url()\u00dcrl\");\n+    fn test_to_ascii_lowercase() {\n+        assert_eq!(\"url()URL()uRl()\u00dcrl\".to_ascii_lowercase(), \"url()url()url()\u00dcrl\");\n         // Dotted capital I, Kelvin sign, Sharp S.\n-        assert_eq!(\"H\u0130\u212a\u00df\".to_ascii_lower(), \"h\u0130\u212a\u00df\");\n+        assert_eq!(\"H\u0130\u212a\u00df\".to_ascii_lowercase(), \"h\u0130\u212a\u00df\");\n \n         let mut i = 0;\n         while i <= 500 {\n             let lower = if 'A' as u32 <= i && i <= 'Z' as u32 { i + 'a' as u32 - 'A' as u32 }\n                         else { i };\n-            assert_eq!((from_u32(i).unwrap()).to_string().to_ascii_lower(),\n+            assert_eq!((from_u32(i).unwrap()).to_string().to_ascii_lowercase(),\n                        (from_u32(lower).unwrap()).to_string());\n             i += 1;\n         }\n     }\n \n     #[test]\n-    fn test_into_ascii_upper() {\n-        assert_eq!((\"url()URL()uRl()\u00fcrl\".to_string()).into_ascii_upper(),\n+    fn test_into_ascii_uppercase() {\n+        assert_eq!((\"url()URL()uRl()\u00fcrl\".to_string()).into_ascii_uppercase(),\n                    \"URL()URL()URL()\u00fcRL\".to_string());\n-        assert_eq!((\"h\u0131\u212a\u00df\".to_string()).into_ascii_upper(), \"H\u0131\u212a\u00df\");\n+        assert_eq!((\"h\u0131\u212a\u00df\".to_string()).into_ascii_uppercase(), \"H\u0131\u212a\u00df\");\n \n         let mut i = 0;\n         while i <= 500 {\n             let upper = if 'a' as u32 <= i && i <= 'z' as u32 { i + 'A' as u32 - 'a' as u32 }\n                         else { i };\n-            assert_eq!((from_u32(i).unwrap()).to_string().into_ascii_upper(),\n+            assert_eq!((from_u32(i).unwrap()).to_string().into_ascii_uppercase(),\n                        (from_u32(upper).unwrap()).to_string());\n             i += 1;\n         }\n     }\n \n     #[test]\n-    fn test_into_ascii_lower() {\n-        assert_eq!((\"url()URL()uRl()\u00dcrl\".to_string()).into_ascii_lower(),\n+    fn test_into_ascii_lowercase() {\n+        assert_eq!((\"url()URL()uRl()\u00dcrl\".to_string()).into_ascii_lowercase(),\n                    \"url()url()url()\u00dcrl\");\n         // Dotted capital I, Kelvin sign, Sharp S.\n-        assert_eq!((\"H\u0130\u212a\u00df\".to_string()).into_ascii_lower(), \"h\u0130\u212a\u00df\");\n+        assert_eq!((\"H\u0130\u212a\u00df\".to_string()).into_ascii_lowercase(), \"h\u0130\u212a\u00df\");\n \n         let mut i = 0;\n         while i <= 500 {\n             let lower = if 'A' as u32 <= i && i <= 'Z' as u32 { i + 'a' as u32 - 'A' as u32 }\n                         else { i };\n-            assert_eq!((from_u32(i).unwrap()).to_string().into_ascii_lower(),\n+            assert_eq!((from_u32(i).unwrap()).to_string().into_ascii_lowercase(),\n                        (from_u32(lower).unwrap()).to_string());\n             i += 1;\n         }\n@@ -858,16 +417,4 @@ mod tests {\n             i += 1;\n         }\n     }\n-\n-    #[test]\n-    fn test_to_string() {\n-        let s = Ascii{ chr: b't' }.to_string();\n-        assert_eq!(s, \"t\");\n-    }\n-\n-    #[test]\n-    fn test_show() {\n-        let c = Ascii { chr: b't' };\n-        assert_eq!(format!(\"{}\", c), \"t\");\n-    }\n }"}, {"sha": "ea381bc0577d6775f0bdc104c3c2084405463e22", "filename": "src/libstd/path/windows.rs", "status": "modified", "additions": 13, "deletions": 15, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/070ab63807dc80fa6a6c5ee80531284761ab42de/src%2Flibstd%2Fpath%2Fwindows.rs", "raw_url": "https://github.com/rust-lang/rust/raw/070ab63807dc80fa6a6c5ee80531284761ab42de/src%2Flibstd%2Fpath%2Fwindows.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fwindows.rs?ref=070ab63807dc80fa6a6c5ee80531284761ab42de", "patch": "@@ -14,7 +14,7 @@\n \n use self::PathPrefix::*;\n \n-use ascii::AsciiCast;\n+use ascii::AsciiExt;\n use c_str::{CString, ToCStr};\n use clone::Clone;\n use cmp::{PartialEq, Eq, PartialOrd, Ord, Ordering};\n@@ -237,10 +237,10 @@ impl GenericPathUnsafe for Path {\n             let repr = me.repr[];\n             match me.prefix {\n                 Some(DiskPrefix) => {\n-                    repr.as_bytes()[0] == path.as_bytes()[0].to_ascii().to_uppercase().as_byte()\n+                    repr.as_bytes()[0] == path.as_bytes()[0].to_ascii_uppercase()\n                 }\n                 Some(VerbatimDiskPrefix) => {\n-                    repr.as_bytes()[4] == path.as_bytes()[0].to_ascii().to_uppercase().as_byte()\n+                    repr.as_bytes()[4] == path.as_bytes()[0].to_ascii_uppercase()\n                 }\n                 _ => false\n             }\n@@ -673,17 +673,17 @@ impl Path {\n         match (self.prefix, other.prefix) {\n             (Some(DiskPrefix), Some(VerbatimDiskPrefix)) => {\n                 self.is_absolute() &&\n-                    s_repr.as_bytes()[0].to_ascii().to_lowercase() ==\n-                        o_repr.as_bytes()[4].to_ascii().to_lowercase()\n+                    s_repr.as_bytes()[0].to_ascii_lowercase() ==\n+                        o_repr.as_bytes()[4].to_ascii_lowercase()\n             }\n             (Some(VerbatimDiskPrefix), Some(DiskPrefix)) => {\n                 other.is_absolute() &&\n-                    s_repr.as_bytes()[4].to_ascii().to_lowercase() ==\n-                        o_repr.as_bytes()[0].to_ascii().to_lowercase()\n+                    s_repr.as_bytes()[4].to_ascii_lowercase() ==\n+                        o_repr.as_bytes()[0].to_ascii_lowercase()\n             }\n             (Some(VerbatimDiskPrefix), Some(VerbatimDiskPrefix)) => {\n-                s_repr.as_bytes()[4].to_ascii().to_lowercase() ==\n-                    o_repr.as_bytes()[4].to_ascii().to_lowercase()\n+                s_repr.as_bytes()[4].to_ascii_lowercase() ==\n+                    o_repr.as_bytes()[4].to_ascii_lowercase()\n             }\n             (Some(UNCPrefix(_,_)), Some(VerbatimUNCPrefix(_,_))) => {\n                 s_repr[2..self.prefix_len()] == o_repr[8..other.prefix_len()]\n@@ -750,7 +750,7 @@ impl Path {\n                                 let mut s = String::from_str(s[0..len]);\n                                 unsafe {\n                                     let v = s.as_mut_vec();\n-                                    v[0] = (*v)[0].to_ascii().to_uppercase().as_byte();\n+                                    v[0] = (*v)[0].to_ascii_uppercase();\n                                 }\n                                 if is_abs {\n                                     // normalize C:/ to C:\\\n@@ -765,7 +765,7 @@ impl Path {\n                                 let mut s = String::from_str(s[0..len]);\n                                 unsafe {\n                                     let v = s.as_mut_vec();\n-                                    v[4] = (*v)[4].to_ascii().to_uppercase().as_byte();\n+                                    v[4] = (*v)[4].to_ascii_uppercase();\n                                 }\n                                 Some(s)\n                             }\n@@ -786,14 +786,12 @@ impl Path {\n                         let mut s = String::with_capacity(n);\n                         match prefix {\n                             Some(DiskPrefix) => {\n-                                s.push(prefix_.as_bytes()[0].to_ascii()\n-                                                   .to_uppercase().as_char());\n+                                s.push(prefix_.as_bytes()[0].to_ascii_uppercase() as char);\n                                 s.push(':');\n                             }\n                             Some(VerbatimDiskPrefix) => {\n                                 s.push_str(prefix_[0..4]);\n-                                s.push(prefix_.as_bytes()[4].to_ascii()\n-                                                   .to_uppercase().as_char());\n+                                s.push(prefix_.as_bytes()[4].to_ascii_uppercase() as char);\n                                 s.push_str(prefix_[5..]);\n                             }\n                             Some(UNCPrefix(a,b)) => {"}, {"sha": "d1540f98a2355651f7a2bc2738d49f6120989aa2", "filename": "src/libstd/prelude.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/070ab63807dc80fa6a6c5ee80531284761ab42de/src%2Flibstd%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/070ab63807dc80fa6a6c5ee80531284761ab42de/src%2Flibstd%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fprelude.rs?ref=070ab63807dc80fa6a6c5ee80531284761ab42de", "patch": "@@ -56,8 +56,6 @@\n \n // Reexported types and traits\n \n-#[doc(no_inline)] pub use ascii::{Ascii, AsciiCast, OwnedAsciiCast, AsciiStr};\n-#[doc(no_inline)] pub use ascii::IntoBytes;\n #[doc(no_inline)] pub use borrow::IntoCow;\n #[doc(no_inline)] pub use c_str::ToCStr;\n #[doc(no_inline)] pub use char::{Char, UnicodeChar};"}, {"sha": "2844c0b523e5d63d54c11e7b16b2602ad5b5dc57", "filename": "src/libsyntax/ext/bytes.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/070ab63807dc80fa6a6c5ee80531284761ab42de/src%2Flibsyntax%2Fext%2Fbytes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/070ab63807dc80fa6a6c5ee80531284761ab42de/src%2Flibsyntax%2Fext%2Fbytes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Fbytes.rs?ref=070ab63807dc80fa6a6c5ee80531284761ab42de", "patch": "@@ -15,6 +15,7 @@ use codemap::Span;\n use ext::base::*;\n use ext::base;\n use ext::build::AstBuilder;\n+use std::ascii::AsciiExt;\n \n \n pub fn expand_syntax_ext<'cx>(cx: &'cx mut ExtCtxt,"}, {"sha": "28f7a78ddd08ac149a7bbb36a6f01045ee9868dd", "filename": "src/libsyntax/feature_gate.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/070ab63807dc80fa6a6c5ee80531284761ab42de/src%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/070ab63807dc80fa6a6c5ee80531284761ab42de/src%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Ffeature_gate.rs?ref=070ab63807dc80fa6a6c5ee80531284761ab42de", "patch": "@@ -31,6 +31,8 @@ use visit::Visitor;\n use parse::token;\n \n use std::slice;\n+use std::ascii::AsciiExt;\n+\n \n // if you change this list without updating src/doc/reference.md, @cmr will be sad\n static KNOWN_FEATURES: &'static [(&'static str, Status)] = &["}, {"sha": "bac2452524e3eed4878a840e9518e1f36e0286a2", "filename": "src/libterm/terminfo/parm.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/070ab63807dc80fa6a6c5ee80531284761ab42de/src%2Flibterm%2Fterminfo%2Fparm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/070ab63807dc80fa6a6c5ee80531284761ab42de/src%2Flibterm%2Fterminfo%2Fparm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibterm%2Fterminfo%2Fparm.rs?ref=070ab63807dc80fa6a6c5ee80531284761ab42de", "patch": "@@ -14,6 +14,7 @@ pub use self::Param::*;\n use self::States::*;\n use self::FormatState::*;\n use self::FormatOp::*;\n+use std::ascii::OwnedAsciiExt;\n use std::mem::replace;\n \n #[deriving(Copy, PartialEq)]\n@@ -530,10 +531,7 @@ fn format(val: Param, op: FormatOp, flags: Flags) -> Result<Vec<u8> ,String> {\n                     }\n                 }\n                 FormatHEX => {\n-                    s = s.to_ascii()\n-                         .iter()\n-                         .map(|b| b.to_uppercase().as_byte())\n-                         .collect();\n+                    s = s.into_ascii_uppercase();\n                     if flags.alternate {\n                         let s_ = replace(&mut s, vec!(b'0', b'X'));\n                         s.extend(s_.into_iter());"}, {"sha": "f49b648e21579ddc0729abefab817bab8f0295da", "filename": "src/test/bench/shootout-k-nucleotide-pipes.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/070ab63807dc80fa6a6c5ee80531284761ab42de/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/070ab63807dc80fa6a6c5ee80531284761ab42de/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide-pipes.rs?ref=070ab63807dc80fa6a6c5ee80531284761ab42de", "patch": "@@ -17,6 +17,7 @@\n \n extern crate collections;\n \n+use std::ascii::{AsciiExt, OwnedAsciiExt};\n use std::collections::HashMap;\n use std::mem::replace;\n use std::num::Float;\n@@ -64,18 +65,16 @@ fn sort_and_fmt(mm: &HashMap<Vec<u8> , uint>, total: uint) -> String {\n    let mut buffer = String::new();\n    for &(ref k, v) in pairs_sorted.iter() {\n        buffer.push_str(format!(\"{} {:0.3}\\n\",\n-                               k.as_slice()\n-                               .to_ascii()\n-                               .to_uppercase()\n-                               .into_string(), v).as_slice());\n+                               k.to_ascii_uppercase(),\n+                               v).as_slice());\n    }\n \n    return buffer\n }\n \n // given a map, search for the frequency of a pattern\n fn find(mm: &HashMap<Vec<u8> , uint>, key: String) -> uint {\n-   let key = key.into_ascii().as_slice().to_lowercase().into_string();\n+   let key = key.into_ascii_lowercase();\n    match mm.get(key.as_bytes()) {\n       option::Option::None      => { return 0u; }\n       option::Option::Some(&num) => { return num; }"}, {"sha": "a0ef392ed3af2d2310e78dfba1984b2b66cc2f66", "filename": "src/test/bench/shootout-k-nucleotide.rs", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/070ab63807dc80fa6a6c5ee80531284761ab42de/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "raw_url": "https://github.com/rust-lang/rust/raw/070ab63807dc80fa6a6c5ee80531284761ab42de/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fbench%2Fshootout-k-nucleotide.rs?ref=070ab63807dc80fa6a6c5ee80531284761ab42de", "patch": "@@ -42,6 +42,7 @@\n \n #![feature(slicing_syntax)]\n \n+use std::ascii::OwnedAsciiExt;\n use std::string::String;\n use std::slice;\n use std::sync::{Arc, Future};\n@@ -286,10 +287,7 @@ fn get_sequence<R: Buffer>(r: &mut R, key: &str) -> Vec<u8> {\n     {\n         res.push_all(l.as_slice().trim().as_bytes());\n     }\n-    for b in res.iter_mut() {\n-        *b = b.to_ascii().to_uppercase().to_byte();\n-    }\n-    res\n+    res.into_ascii_uppercase()\n }\n \n fn main() {"}, {"sha": "26ee65fa565e2bb3588ed261fcec0e35177e8026", "filename": "src/test/run-pass/issue-10683.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/070ab63807dc80fa6a6c5ee80531284761ab42de/src%2Ftest%2Frun-pass%2Fissue-10683.rs", "raw_url": "https://github.com/rust-lang/rust/raw/070ab63807dc80fa6a6c5ee80531284761ab42de/src%2Ftest%2Frun-pass%2Fissue-10683.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fissue-10683.rs?ref=070ab63807dc80fa6a6c5ee80531284761ab42de", "patch": "@@ -13,7 +13,7 @@ use std::ascii::AsciiExt;\n static NAME: &'static str = \"hello world\";\n \n fn main() {\n-    match NAME.to_ascii_lower().as_slice() {\n+    match NAME.to_ascii_lowercase().as_slice() {\n         \"foo\" => {}\n         _ => {}\n     }"}]}