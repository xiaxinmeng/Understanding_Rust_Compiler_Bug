{"sha": "9f7b58f3c94708f344237f826b4f96a659b5fc82", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlmN2I1OGYzYzk0NzA4ZjM0NDIzN2Y4MjZiNGY5NmE2NTliNWZjODI=", "commit": {"author": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2020-02-04T14:00:51Z"}, "committer": {"name": "Stein Somers", "email": "git@steinsomers.be", "date": "2020-02-28T00:06:23Z"}, "message": "Make implementation of navigation simpler, safer and faster", "tree": {"sha": "69eebd72e54b660bc41939fa834575ce5572c30f", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/69eebd72e54b660bc41939fa834575ce5572c30f"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9f7b58f3c94708f344237f826b4f96a659b5fc82", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9f7b58f3c94708f344237f826b4f96a659b5fc82", "html_url": "https://github.com/rust-lang/rust/commit/9f7b58f3c94708f344237f826b4f96a659b5fc82", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9f7b58f3c94708f344237f826b4f96a659b5fc82/comments", "author": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ssomers", "id": 10174877, "node_id": "MDQ6VXNlcjEwMTc0ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/10174877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ssomers", "html_url": "https://github.com/ssomers", "followers_url": "https://api.github.com/users/ssomers/followers", "following_url": "https://api.github.com/users/ssomers/following{/other_user}", "gists_url": "https://api.github.com/users/ssomers/gists{/gist_id}", "starred_url": "https://api.github.com/users/ssomers/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ssomers/subscriptions", "organizations_url": "https://api.github.com/users/ssomers/orgs", "repos_url": "https://api.github.com/users/ssomers/repos", "events_url": "https://api.github.com/users/ssomers/events{/privacy}", "received_events_url": "https://api.github.com/users/ssomers/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4f6661a18d2c35e6d4bfa8533ddaab10cd522b35", "url": "https://api.github.com/repos/rust-lang/rust/commits/4f6661a18d2c35e6d4bfa8533ddaab10cd522b35", "html_url": "https://github.com/rust-lang/rust/commit/4f6661a18d2c35e6d4bfa8533ddaab10cd522b35"}], "stats": {"total": 298, "additions": 148, "deletions": 150}, "files": [{"sha": "e62855f2fb3475b946119d39bcff53dfa772c304", "filename": "src/liballoc/collections/btree/map.rs", "status": "modified", "additions": 4, "deletions": 7, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/9f7b58f3c94708f344237f826b4f96a659b5fc82/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f7b58f3c94708f344237f826b4f96a659b5fc82/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fmap.rs?ref=9f7b58f3c94708f344237f826b4f96a659b5fc82", "patch": "@@ -1473,16 +1473,13 @@ impl<K, V> Drop for IntoIter<K, V> {\n     fn drop(&mut self) {\n         self.for_each(drop);\n         unsafe {\n-            let leaf_node = ptr::read(&self.front).into_node();\n-            if leaf_node.is_shared_root() {\n+            let mut node = ptr::read(&self.front).into_node().forget_type();\n+            if node.is_shared_root() {\n                 return;\n             }\n \n-            if let Some(first_parent) = leaf_node.deallocate_and_ascend() {\n-                let mut cur_internal_node = first_parent.into_node();\n-                while let Some(parent) = cur_internal_node.deallocate_and_ascend() {\n-                    cur_internal_node = parent.into_node()\n-                }\n+            while let Some(parent) = node.deallocate_and_ascend() {\n+                node = parent.into_node().forget_type();\n             }\n         }\n     }"}, {"sha": "5e8dcf247ae5996af8fde8a55ceea5d5bcb464e1", "filename": "src/liballoc/collections/btree/navigate.rs", "status": "modified", "additions": 122, "deletions": 123, "changes": 245, "blob_url": "https://github.com/rust-lang/rust/blob/9f7b58f3c94708f344237f826b4f96a659b5fc82/src%2Fliballoc%2Fcollections%2Fbtree%2Fnavigate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f7b58f3c94708f344237f826b4f96a659b5fc82/src%2Fliballoc%2Fcollections%2Fbtree%2Fnavigate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fnavigate.rs?ref=9f7b58f3c94708f344237f826b4f96a659b5fc82", "patch": "@@ -3,151 +3,112 @@ use core::ptr;\n use super::node::{marker, ForceResult::*, Handle, NodeRef};\n use super::unwrap_unchecked;\n \n-macro_rules! def_next {\n-    { unsafe fn $name:ident : $next_kv:ident $next_edge:ident $initial_leaf_edge:ident } => {\n-        /// Given a leaf edge handle into an immutable tree, returns a handle to the next\n-        /// leaf edge and references to the key and value between these edges.\n-        /// Unsafe because the caller must ensure that the given leaf edge has a successor.\n-        unsafe fn $name <'a, K: 'a, V: 'a>(\n-            leaf_edge: Handle<NodeRef<marker::Immut<'a>, K, V, marker::Leaf>, marker::Edge>,\n-        ) -> (Handle<NodeRef<marker::Immut<'a>, K, V, marker::Leaf>, marker::Edge>, &'a K, &'a V) {\n-            let mut cur_handle = match leaf_edge.$next_kv() {\n-                Ok(leaf_kv) => {\n-                    let (k, v) = leaf_kv.into_kv();\n-                    let next_leaf_edge = leaf_kv.$next_edge();\n-                    return (next_leaf_edge, k, v);\n-                }\n-                Err(last_edge) => {\n-                    let next_level = last_edge.into_node().ascend().ok();\n-                    unwrap_unchecked(next_level)\n-                }\n-            };\n-\n-            loop {\n-                cur_handle = match cur_handle.$next_kv() {\n-                    Ok(internal_kv) => {\n-                        let (k, v) = internal_kv.into_kv();\n-                        let next_internal_edge = internal_kv.$next_edge();\n-                        let next_leaf_edge = next_internal_edge.descend().$initial_leaf_edge();\n-                        return (next_leaf_edge, k, v);\n-                    }\n-                    Err(last_edge) => {\n-                        let next_level = last_edge.into_node().ascend().ok();\n-                        unwrap_unchecked(next_level)\n-                    }\n-                }\n+impl<BorrowType, K, V> Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge> {\n+    /// Given a leaf edge handle, returns [`Result::Ok`] with a handle to the neighboring KV\n+    /// on the right side, which is either in the same leaf node or in an ancestor node.\n+    /// If the leaf edge is the last one in the tree, returns [`Result::Err`] with the root node.\n+    pub fn next_kv(\n+        self,\n+    ) -> Result<\n+        Handle<NodeRef<BorrowType, K, V, marker::LeafOrInternal>, marker::KV>,\n+        NodeRef<BorrowType, K, V, marker::LeafOrInternal>,\n+    > {\n+        let mut edge = self.forget_node_type();\n+        loop {\n+            edge = match edge.right_kv() {\n+                Ok(internal_kv) => return Ok(internal_kv),\n+                Err(last_edge) => match last_edge.into_node().ascend() {\n+                    Ok(parent_edge) => parent_edge.forget_node_type(),\n+                    Err(root) => return Err(root.forget_type()),\n+                },\n             }\n         }\n-    };\n-}\n-\n-macro_rules! def_next_mut {\n-    { unsafe fn $name:ident : $next_kv:ident $next_edge:ident $initial_leaf_edge:ident } => {\n-        /// Given a leaf edge handle into a mutable tree, returns handles to the next\n-        /// leaf edge and to the KV between these edges.\n-        /// Unsafe for two reasons:\n-        /// - the caller must ensure that the given leaf edge has a successor;\n-        /// - both returned handles represent mutable references into the same tree\n-        ///   that can easily invalidate each other, even on immutable use.\n-        unsafe fn $name <'a, K: 'a, V: 'a>(\n-            leaf_edge: Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>,\n-        ) -> (Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge>,\n-              Handle<NodeRef<marker::Mut<'a>, K, V, marker::LeafOrInternal>, marker::KV>) {\n-            let mut cur_handle = match leaf_edge.$next_kv() {\n-                Ok(leaf_kv) => {\n-                    let next_leaf_edge = ptr::read(&leaf_kv).$next_edge();\n-                    return (next_leaf_edge, leaf_kv.forget_node_type());\n-                }\n-                Err(last_edge) => {\n-                    let next_level = last_edge.into_node().ascend().ok();\n-                    unwrap_unchecked(next_level)\n-                }\n-            };\n+    }\n \n-            loop {\n-                cur_handle = match cur_handle.$next_kv() {\n-                    Ok(internal_kv) => {\n-                        let next_internal_edge = ptr::read(&internal_kv).$next_edge();\n-                        let next_leaf_edge = next_internal_edge.descend().$initial_leaf_edge();\n-                        return (next_leaf_edge, internal_kv.forget_node_type());\n-                    }\n-                    Err(last_edge) => {\n-                        let next_level = last_edge.into_node().ascend().ok();\n-                        unwrap_unchecked(next_level)\n-                    }\n-                }\n+    /// Given a leaf edge handle, returns [`Result::Ok`] with a handle to the neighboring KV\n+    /// on the left side, which is either in the same leaf node or in an ancestor node.\n+    /// If the leaf edge is the first one in the tree, returns [`Result::Err`] with the root node.\n+    pub fn next_back_kv(\n+        self,\n+    ) -> Result<\n+        Handle<NodeRef<BorrowType, K, V, marker::LeafOrInternal>, marker::KV>,\n+        NodeRef<BorrowType, K, V, marker::LeafOrInternal>,\n+    > {\n+        let mut edge = self.forget_node_type();\n+        loop {\n+            edge = match edge.left_kv() {\n+                Ok(internal_kv) => return Ok(internal_kv),\n+                Err(last_edge) => match last_edge.into_node().ascend() {\n+                    Ok(parent_edge) => parent_edge.forget_node_type(),\n+                    Err(root) => return Err(root.forget_type()),\n+                },\n             }\n         }\n-    };\n+    }\n }\n \n-macro_rules! def_next_dealloc {\n-    { unsafe fn $name:ident : $next_kv:ident $next_edge:ident $initial_leaf_edge:ident } => {\n-        /// Given a leaf edge handle into an owned tree, returns a handle to the next\n-        /// leaf edge and the key and value between these edges, while deallocating\n-        /// any node left behind.\n+macro_rules! def_next_kv_uncheched_dealloc {\n+    { unsafe fn $name:ident : $adjacent_kv:ident } => {\n+        /// Given a leaf edge handle into an owned tree, returns a handle to the next KV,\n+        /// while deallocating any node left behind.\n         /// Unsafe for two reasons:\n-        /// - the caller must ensure that the given leaf edge has a successor;\n-        /// - the node pointed at by the given handle, and its ancestors, may be deallocated,\n+        /// - The caller must ensure that the leaf edge is not the last one in the tree.\n+        /// - The node pointed at by the given handle, and its ancestors, may be deallocated,\n         ///   while the reference to those nodes in the surviving ancestors is left dangling;\n-        ///   thus using the returned handle is dangerous.\n+        ///   thus using the returned handle to navigate further is dangerous.\n         unsafe fn $name <K, V>(\n             leaf_edge: Handle<NodeRef<marker::Owned, K, V, marker::Leaf>, marker::Edge>,\n-        ) -> (Handle<NodeRef<marker::Owned, K, V, marker::Leaf>, marker::Edge>, K, V) {\n-            let mut cur_handle = match leaf_edge.$next_kv() {\n-                Ok(leaf_kv) => {\n-                    let k = ptr::read(leaf_kv.reborrow().into_kv().0);\n-                    let v = ptr::read(leaf_kv.reborrow().into_kv().1);\n-                    let next_leaf_edge = leaf_kv.$next_edge();\n-                    return (next_leaf_edge, k, v);\n-                }\n-                Err(last_edge) => {\n-                    unwrap_unchecked(last_edge.into_node().deallocate_and_ascend())\n-                }\n-            };\n-\n+        ) -> Handle<NodeRef<marker::Owned, K, V, marker::LeafOrInternal>, marker::KV> {\n+            let mut edge = leaf_edge.forget_node_type();\n             loop {\n-                cur_handle = match cur_handle.$next_kv() {\n-                    Ok(internal_kv) => {\n-                        let k = ptr::read(internal_kv.reborrow().into_kv().0);\n-                        let v = ptr::read(internal_kv.reborrow().into_kv().1);\n-                        let next_internal_edge = internal_kv.$next_edge();\n-                        let next_leaf_edge = next_internal_edge.descend().$initial_leaf_edge();\n-                        return (next_leaf_edge, k, v);\n-                    }\n+                edge = match edge.$adjacent_kv() {\n+                    Ok(internal_kv) => return internal_kv,\n                     Err(last_edge) => {\n-                        unwrap_unchecked(last_edge.into_node().deallocate_and_ascend())\n+                        let parent_edge = last_edge.into_node().deallocate_and_ascend();\n+                        unwrap_unchecked(parent_edge).forget_node_type()\n                     }\n                 }\n             }\n         }\n     };\n }\n \n-def_next! {unsafe fn next_unchecked: right_kv right_edge first_leaf_edge}\n-def_next! {unsafe fn next_back_unchecked: left_kv left_edge last_leaf_edge}\n-def_next_mut! {unsafe fn next_unchecked_mut: right_kv right_edge first_leaf_edge}\n-def_next_mut! {unsafe fn next_back_unchecked_mut: left_kv left_edge last_leaf_edge}\n-def_next_dealloc! {unsafe fn next_unchecked_deallocating: right_kv right_edge first_leaf_edge}\n-def_next_dealloc! {unsafe fn next_back_unchecked_deallocating: left_kv left_edge last_leaf_edge}\n+def_next_kv_uncheched_dealloc! {unsafe fn next_kv_unchecked_dealloc: right_kv}\n+def_next_kv_uncheched_dealloc! {unsafe fn next_back_kv_unchecked_dealloc: left_kv}\n+\n+/// This replaces the value behind the `v` unique reference by calling the\n+/// relevant function.\n+///\n+/// Safety: The change closure must not panic.\n+#[inline]\n+unsafe fn replace<T, R>(v: &mut T, change: impl FnOnce(T) -> (T, R)) -> R {\n+    let value = ptr::read(v);\n+    let (new_value, ret) = change(value);\n+    ptr::write(v, new_value);\n+    ret\n+}\n \n impl<'a, K, V> Handle<NodeRef<marker::Immut<'a>, K, V, marker::Leaf>, marker::Edge> {\n     /// Moves the leaf edge handle to the next leaf edge and returns references to the\n     /// key and value in between.\n     /// Unsafe because the caller must ensure that the leaf edge is not the last one in the tree.\n     pub unsafe fn next_unchecked(&mut self) -> (&'a K, &'a V) {\n-        let (next_edge, k, v) = next_unchecked(*self);\n-        *self = next_edge;\n-        (k, v)\n+        replace(self, |leaf_edge| {\n+            let kv = leaf_edge.next_kv();\n+            let kv = unwrap_unchecked(kv.ok());\n+            (kv.next_leaf_edge(), kv.into_kv())\n+        })\n     }\n \n     /// Moves the leaf edge handle to the previous leaf edge and returns references to the\n     /// key and value in between.\n     /// Unsafe because the caller must ensure that the leaf edge is not the first one in the tree.\n     pub unsafe fn next_back_unchecked(&mut self) -> (&'a K, &'a V) {\n-        let (next_edge, k, v) = next_back_unchecked(*self);\n-        *self = next_edge;\n-        (k, v)\n+        replace(self, |leaf_edge| {\n+            let kv = leaf_edge.next_back_kv();\n+            let kv = unwrap_unchecked(kv.ok());\n+            (kv.next_back_leaf_edge(), kv.into_kv())\n+        })\n     }\n }\n \n@@ -158,8 +119,11 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge\n     /// - The caller must ensure that the leaf edge is not the last one in the tree.\n     /// - Using the updated handle may well invalidate the returned references.\n     pub unsafe fn next_unchecked(&mut self) -> (&'a mut K, &'a mut V) {\n-        let (next_edge, kv) = next_unchecked_mut(ptr::read(self));\n-        *self = next_edge;\n+        let kv = replace(self, |leaf_edge| {\n+            let kv = leaf_edge.next_kv();\n+            let kv = unwrap_unchecked(kv.ok());\n+            (ptr::read(&kv).next_leaf_edge(), kv)\n+        });\n         // Doing the descend (and perhaps another move) invalidates the references\n         // returned by `into_kv_mut`, so we have to do this last.\n         kv.into_kv_mut()\n@@ -171,8 +135,11 @@ impl<'a, K, V> Handle<NodeRef<marker::Mut<'a>, K, V, marker::Leaf>, marker::Edge\n     /// - The caller must ensure that the leaf edge is not the first one in the tree.\n     /// - Using the updated handle may well invalidate the returned references.\n     pub unsafe fn next_back_unchecked(&mut self) -> (&'a mut K, &'a mut V) {\n-        let (next_edge, kv) = next_back_unchecked_mut(ptr::read(self));\n-        *self = next_edge;\n+        let kv = replace(self, |leaf_edge| {\n+            let kv = leaf_edge.next_back_kv();\n+            let kv = unwrap_unchecked(kv.ok());\n+            (ptr::read(&kv).next_back_leaf_edge(), kv)\n+        });\n         // Doing the descend (and perhaps another move) invalidates the references\n         // returned by `into_kv_mut`, so we have to do this last.\n         kv.into_kv_mut()\n@@ -192,9 +159,12 @@ impl<K, V> Handle<NodeRef<marker::Owned, K, V, marker::Leaf>, marker::Edge> {\n     ///   if the two preconditions above hold.\n     /// - Using the updated handle may well invalidate the returned references.\n     pub unsafe fn next_unchecked(&mut self) -> (K, V) {\n-        let (next_edge, k, v) = next_unchecked_deallocating(ptr::read(self));\n-        *self = next_edge;\n-        (k, v)\n+        replace(self, |leaf_edge| {\n+            let kv = next_kv_unchecked_dealloc(leaf_edge);\n+            let k = ptr::read(kv.reborrow().into_kv().0);\n+            let v = ptr::read(kv.reborrow().into_kv().1);\n+            (kv.next_leaf_edge(), (k, v))\n+        })\n     }\n \n     /// Moves the leaf edge handle to the previous leaf edge and returns the key\n@@ -209,9 +179,12 @@ impl<K, V> Handle<NodeRef<marker::Owned, K, V, marker::Leaf>, marker::Edge> {\n     ///   if the two preconditions above hold.\n     /// - Using the updated handle may well invalidate the returned references.\n     pub unsafe fn next_back_unchecked(&mut self) -> (K, V) {\n-        let (next_edge, k, v) = next_back_unchecked_deallocating(ptr::read(self));\n-        *self = next_edge;\n-        (k, v)\n+        replace(self, |leaf_edge| {\n+            let kv = next_back_kv_unchecked_dealloc(leaf_edge);\n+            let k = ptr::read(kv.reborrow().into_kv().0);\n+            let v = ptr::read(kv.reborrow().into_kv().1);\n+            (kv.next_back_leaf_edge(), (k, v))\n+        })\n     }\n }\n \n@@ -242,3 +215,29 @@ impl<BorrowType, K, V> NodeRef<BorrowType, K, V, marker::LeafOrInternal> {\n         }\n     }\n }\n+\n+impl<BorrowType, K, V> Handle<NodeRef<BorrowType, K, V, marker::LeafOrInternal>, marker::KV> {\n+    /// Returns the leaf edge closest to a KV for forward navigation.\n+    pub fn next_leaf_edge(self) -> Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge> {\n+        match self.force() {\n+            Leaf(leaf_kv) => leaf_kv.right_edge(),\n+            Internal(internal_kv) => {\n+                let next_internal_edge = internal_kv.right_edge();\n+                next_internal_edge.descend().first_leaf_edge()\n+            }\n+        }\n+    }\n+\n+    /// Returns the leaf edge closest to a KV for backward navigation.\n+    pub fn next_back_leaf_edge(\n+        self,\n+    ) -> Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge> {\n+        match self.force() {\n+            Leaf(leaf_kv) => leaf_kv.left_edge(),\n+            Internal(internal_kv) => {\n+                let next_internal_edge = internal_kv.left_edge();\n+                next_internal_edge.descend().last_leaf_edge()\n+            }\n+        }\n+    }\n+}"}, {"sha": "62b96ab9ef9cd2a732085db318aea866a425b809", "filename": "src/liballoc/collections/btree/node.rs", "status": "modified", "additions": 22, "deletions": 20, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/9f7b58f3c94708f344237f826b4f96a659b5fc82/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9f7b58f3c94708f344237f826b4f96a659b5fc82/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fcollections%2Fbtree%2Fnode.rs?ref=9f7b58f3c94708f344237f826b4f96a659b5fc82", "patch": "@@ -451,31 +451,25 @@ impl<BorrowType, K, V, Type> NodeRef<BorrowType, K, V, Type> {\n     }\n }\n \n-impl<K, V> NodeRef<marker::Owned, K, V, marker::Leaf> {\n+impl<K, V> NodeRef<marker::Owned, K, V, marker::LeafOrInternal> {\n     /// Similar to `ascend`, gets a reference to a node's parent node, but also\n     /// deallocate the current node in the process. This is unsafe because the\n     /// current node will still be accessible despite being deallocated.\n     pub unsafe fn deallocate_and_ascend(\n         self,\n     ) -> Option<Handle<NodeRef<marker::Owned, K, V, marker::Internal>, marker::Edge>> {\n         assert!(!self.is_shared_root());\n+        let height = self.height;\n         let node = self.node;\n         let ret = self.ascend().ok();\n-        Global.dealloc(node.cast(), Layout::new::<LeafNode<K, V>>());\n-        ret\n-    }\n-}\n-\n-impl<K, V> NodeRef<marker::Owned, K, V, marker::Internal> {\n-    /// Similar to `ascend`, gets a reference to a node's parent node, but also\n-    /// deallocate the current node in the process. This is unsafe because the\n-    /// current node will still be accessible despite being deallocated.\n-    pub unsafe fn deallocate_and_ascend(\n-        self,\n-    ) -> Option<Handle<NodeRef<marker::Owned, K, V, marker::Internal>, marker::Edge>> {\n-        let node = self.node;\n-        let ret = self.ascend().ok();\n-        Global.dealloc(node.cast(), Layout::new::<InternalNode<K, V>>());\n+        Global.dealloc(\n+            node.cast(),\n+            if height > 0 {\n+                Layout::new::<InternalNode<K, V>>()\n+            } else {\n+                Layout::new::<LeafNode<K, V>>()\n+            },\n+        );\n         ret\n     }\n }\n@@ -1418,15 +1412,23 @@ unsafe fn move_edges<K, V>(\n     dest.correct_childrens_parent_links(dest_offset, dest_offset + count);\n }\n \n-impl<BorrowType, K, V> Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::KV> {\n+impl<BorrowType, K, V> Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::Edge> {\n     pub fn forget_node_type(\n         self,\n-    ) -> Handle<NodeRef<BorrowType, K, V, marker::LeafOrInternal>, marker::KV> {\n-        unsafe { Handle::new_kv(self.node.forget_type(), self.idx) }\n+    ) -> Handle<NodeRef<BorrowType, K, V, marker::LeafOrInternal>, marker::Edge> {\n+        unsafe { Handle::new_edge(self.node.forget_type(), self.idx) }\n+    }\n+}\n+\n+impl<BorrowType, K, V> Handle<NodeRef<BorrowType, K, V, marker::Internal>, marker::Edge> {\n+    pub fn forget_node_type(\n+        self,\n+    ) -> Handle<NodeRef<BorrowType, K, V, marker::LeafOrInternal>, marker::Edge> {\n+        unsafe { Handle::new_edge(self.node.forget_type(), self.idx) }\n     }\n }\n \n-impl<BorrowType, K, V> Handle<NodeRef<BorrowType, K, V, marker::Internal>, marker::KV> {\n+impl<BorrowType, K, V> Handle<NodeRef<BorrowType, K, V, marker::Leaf>, marker::KV> {\n     pub fn forget_node_type(\n         self,\n     ) -> Handle<NodeRef<BorrowType, K, V, marker::LeafOrInternal>, marker::KV> {"}]}