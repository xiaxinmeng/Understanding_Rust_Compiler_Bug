{"sha": "cc9666f68f829c17ff3a535f714fe5dbb3f72755", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNjOTY2NmY2OGY4MjljMTdmZjNhNTM1ZjcxNGZlNWRiYjNmNzI3NTU=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-07-23T04:48:22Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2013-07-23T23:56:22Z"}, "message": "std: rename str.as_buf to as_imm_buf, add str.as_mut_buf", "tree": {"sha": "853b5af416a659b279c575f22d884ba9d0c0daae", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/853b5af416a659b279c575f22d884ba9d0c0daae"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cc9666f68f829c17ff3a535f714fe5dbb3f72755", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cc9666f68f829c17ff3a535f714fe5dbb3f72755", "html_url": "https://github.com/rust-lang/rust/commit/cc9666f68f829c17ff3a535f714fe5dbb3f72755", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cc9666f68f829c17ff3a535f714fe5dbb3f72755/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "3b818edeba4dbca7c605ca5600f2d1b4b000120b", "url": "https://api.github.com/repos/rust-lang/rust/commits/3b818edeba4dbca7c605ca5600f2d1b4b000120b", "html_url": "https://github.com/rust-lang/rust/commit/3b818edeba4dbca7c605ca5600f2d1b4b000120b"}], "stats": {"total": 132, "additions": 63, "deletions": 69}, "files": [{"sha": "c4fee90826651838f64ae108e4bbfd8c3b9a13ef", "filename": "src/libstd/option.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc9666f68f829c17ff3a535f714fe5dbb3f72755/src%2Flibstd%2Foption.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc9666f68f829c17ff3a535f714fe5dbb3f72755/src%2Flibstd%2Foption.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Foption.rs?ref=cc9666f68f829c17ff3a535f714fe5dbb3f72755", "patch": "@@ -445,10 +445,10 @@ fn test_unwrap_ptr() {\n #[test]\n fn test_unwrap_str() {\n     let x = ~\"test\";\n-    let addr_x = x.as_buf(|buf, _len| buf);\n+    let addr_x = x.as_imm_buf(|buf, _len| buf);\n     let opt = Some(x);\n     let y = opt.unwrap();\n-    let addr_y = y.as_buf(|buf, _len| buf);\n+    let addr_y = y.as_imm_buf(|buf, _len| buf);\n     assert_eq!(addr_x, addr_y);\n }\n "}, {"sha": "59121d6f135c7f510301c707b99679b305ed081a", "filename": "src/libstd/str.rs", "status": "modified", "additions": 59, "deletions": 65, "changes": 124, "blob_url": "https://github.com/rust-lang/rust/blob/cc9666f68f829c17ff3a535f714fe5dbb3f72755/src%2Flibstd%2Fstr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc9666f68f829c17ff3a535f714fe5dbb3f72755/src%2Flibstd%2Fstr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fstr.rs?ref=cc9666f68f829c17ff3a535f714fe5dbb3f72755", "patch": "@@ -191,10 +191,10 @@ impl<'self, S: Str> StrVector for &'self [S] {\n         s.reserve(len);\n \n         unsafe {\n-            do s.as_buf |buf, _| {\n-                let mut buf = ::cast::transmute_mut_unsafe(buf);\n+            do s.as_mut_buf |buf, _| {\n+                let mut buf = buf;\n                 for self.iter().advance |ss| {\n-                    do ss.as_slice().as_buf |ssbuf, sslen| {\n+                    do ss.as_slice().as_imm_buf |ssbuf, sslen| {\n                         let sslen = sslen - 1;\n                         ptr::copy_memory(buf, ssbuf, sslen);\n                         buf = buf.offset(sslen);\n@@ -222,12 +222,12 @@ impl<'self, S: Str> StrVector for &'self [S] {\n         s.reserve(len);\n \n         unsafe {\n-            do s.as_buf |buf, _| {\n-                do sep.as_buf |sepbuf, seplen| {\n+            do s.as_mut_buf |buf, _| {\n+                do sep.as_imm_buf |sepbuf, seplen| {\n                     let seplen = seplen - 1;\n                     let mut buf = ::cast::transmute_mut_unsafe(buf);\n                     for self.iter().advance |ss| {\n-                        do ss.as_slice().as_buf |ssbuf, sslen| {\n+                        do ss.as_slice().as_imm_buf |ssbuf, sslen| {\n                             let sslen = sslen - 1;\n                             if first {\n                                 first = false;\n@@ -533,8 +533,8 @@ Section: Comparing strings\n #[lang=\"str_eq\"]\n #[inline]\n pub fn eq_slice(a: &str, b: &str) -> bool {\n-    do a.as_buf |ap, alen| {\n-        do b.as_buf |bp, blen| {\n+    do a.as_imm_buf |ap, alen| {\n+        do b.as_imm_buf |bp, blen| {\n             if (alen != blen) { false }\n             else {\n                 unsafe {\n@@ -550,8 +550,8 @@ pub fn eq_slice(a: &str, b: &str) -> bool {\n #[cfg(test)]\n #[inline]\n pub fn eq_slice(a: &str, b: &str) -> bool {\n-    do a.as_buf |ap, alen| {\n-        do b.as_buf |bp, blen| {\n+    do a.as_imm_buf |ap, alen| {\n+        do b.as_imm_buf |bp, blen| {\n             if (alen != blen) { false }\n             else {\n                 unsafe {\n@@ -868,7 +868,7 @@ pub mod raw {\n      * If end is greater than the length of the string.\n      */\n     pub unsafe fn slice_bytes_owned(s: &str, begin: uint, end: uint) -> ~str {\n-        do s.as_buf |sbuf, n| {\n+        do s.as_imm_buf |sbuf, n| {\n             assert!((begin <= end));\n             assert!((end <= n));\n \n@@ -896,7 +896,7 @@ pub mod raw {\n      */\n     #[inline]\n     pub unsafe fn slice_bytes(s: &str, begin: uint, end: uint) -> &str {\n-        do s.as_buf |sbuf, n| {\n+        do s.as_imm_buf |sbuf, n| {\n              assert!((begin <= end));\n              assert!((end <= n));\n \n@@ -909,8 +909,7 @@ pub mod raw {\n     pub unsafe fn push_byte(s: &mut ~str, b: u8) {\n         let new_len = s.len() + 1;\n         s.reserve_at_least(new_len);\n-        do s.as_buf |buf, len| {\n-            let buf: *mut u8 = ::cast::transmute(buf);\n+        do s.as_mut_buf |buf, len| {\n             *ptr::mut_offset(buf, len) = b;\n         }\n         set_len(&mut *s, new_len);\n@@ -1130,7 +1129,7 @@ impl<'self> Str for @str {\n impl<'self> Container for &'self str {\n     #[inline]\n     fn len(&self) -> uint {\n-        do self.as_buf |_p, n| { n - 1u }\n+        do self.as_imm_buf |_p, n| { n - 1u }\n     }\n     #[inline]\n     fn is_empty(&self) -> bool {\n@@ -1225,7 +1224,8 @@ pub trait StrSlice<'self> {\n \n     fn subslice_offset(&self, inner: &str) -> uint;\n \n-    fn as_buf<T>(&self, f: &fn(*u8, uint) -> T) -> T;\n+    fn as_imm_buf<T>(&self, f: &fn(*u8, uint) -> T) -> T;\n+    fn as_mut_buf<T>(&self, f: &fn(*mut u8, uint) -> T) -> T;\n     fn as_c_str<T>(&self, f: &fn(*libc::c_char) -> T) -> T;\n }\n \n@@ -1849,15 +1849,15 @@ impl<'self> StrSlice<'self> for &'self str {\n \n     /// Given a string, make a new string with repeated copies of it.\n     fn repeat(&self, nn: uint) -> ~str {\n-        do self.as_buf |buf, len| {\n+        do self.as_imm_buf |buf, len| {\n             let mut ret = ~\"\";\n             // ignore the NULL terminator\n             let len = len - 1;\n             ret.reserve(nn * len);\n \n             unsafe {\n-                do ret.as_buf |rbuf, _len| {\n-                    let mut rbuf = ::cast::transmute_mut_unsafe(rbuf);\n+                do ret.as_mut_buf |rbuf, _len| {\n+                    let mut rbuf = rbuf;\n \n                     for nn.times {\n                         ptr::copy_memory(rbuf, buf, len);\n@@ -1950,8 +1950,8 @@ impl<'self> StrSlice<'self> for &'self str {\n      */\n     #[inline]\n     fn subslice_offset(&self, inner: &str) -> uint {\n-        do self.as_buf |a, a_len| {\n-            do inner.as_buf |b, b_len| {\n+        do self.as_imm_buf |a, a_len| {\n+            do inner.as_imm_buf |b, b_len| {\n                 let a_start: uint;\n                 let a_end: uint;\n                 let b_start: uint;\n@@ -1976,14 +1976,31 @@ impl<'self> StrSlice<'self> for &'self str {\n      * to full strings, or suffixes of them.\n      */\n     #[inline]\n-    fn as_buf<T>(&self, f: &fn(*u8, uint) -> T) -> T {\n+    fn as_imm_buf<T>(&self, f: &fn(*u8, uint) -> T) -> T {\n         unsafe {\n             let v: *(*u8, uint) = cast::transmute(self);\n             let (buf, len) = *v;\n             f(buf, len)\n         }\n     }\n \n+    /**\n+     * Work with the byte buffer and length of a slice.\n+     *\n+     * The given length is one byte longer than the 'official' indexable\n+     * length of the string. This is to permit probing the byte past the\n+     * indexable area for a null byte, as is the case in slices pointing\n+     * to full strings, or suffixes of them.\n+     */\n+    #[inline]\n+    fn as_mut_buf<T>(&self, f: &fn(*mut u8, uint) -> T) -> T {\n+        unsafe {\n+            let v: *(*mut u8, uint) = cast::transmute(self);\n+            let (buf, len) = *v;\n+            f(buf, len)\n+        }\n+    }\n+\n     /**\n      * Work with the byte buffer of a string as a null-terminated C string.\n      *\n@@ -2001,7 +2018,7 @@ impl<'self> StrSlice<'self> for &'self str {\n      */\n     #[inline]\n     fn as_c_str<T>(&self, f: &fn(*libc::c_char) -> T) -> T {\n-        do self.as_buf |buf, len| {\n+        do self.as_imm_buf |buf, len| {\n             // NB: len includes the trailing null.\n             assert!(len > 0);\n             if unsafe { *(ptr::offset(buf, len - 1)) != 0 } {\n@@ -2068,8 +2085,8 @@ impl OwnedStr for ~str {\n             let llen = self.len();\n             let rlen = rhs.len();\n             self.reserve(llen + rlen);\n-            do self.as_buf |lbuf, _llen| {\n-                do rhs.as_buf |rbuf, _rlen| {\n+            do self.as_imm_buf |lbuf, _llen| {\n+                do rhs.as_imm_buf |rbuf, _rlen| {\n                     let dst = ptr::offset(lbuf, llen);\n                     let dst = ::cast::transmute_mut_unsafe(dst);\n                     ptr::copy_memory(dst, rbuf, rlen);\n@@ -2086,8 +2103,8 @@ impl OwnedStr for ~str {\n             let llen = self.len();\n             let rlen = rhs.len();\n             self.reserve_at_least(llen + rlen);\n-            do self.as_buf |lbuf, _llen| {\n-                do rhs.as_buf |rbuf, _rlen| {\n+            do self.as_imm_buf |lbuf, _llen| {\n+                do rhs.as_imm_buf |rbuf, _rlen| {\n                     let dst = ptr::offset(lbuf, llen);\n                     let dst = ::cast::transmute_mut_unsafe(dst);\n                     ptr::copy_memory(dst, rbuf, rlen);\n@@ -2110,8 +2127,7 @@ impl OwnedStr for ~str {\n             let new_len = len + nb;\n             self.reserve_at_least(new_len);\n             let off = len;\n-            do self.as_buf |buf, _len| {\n-                let buf: *mut u8 = ::cast::transmute(buf);\n+            do self.as_mut_buf |buf, _len| {\n                 match nb {\n                     1u => {\n                         *ptr::mut_offset(buf, off) = code as u8;\n@@ -3073,45 +3089,23 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_as_buf() {\n-        let a = \"Abcdefg\";\n-        let b = do a.as_buf |buf, _l| {\n-            assert_eq!(unsafe { *buf }, 65u8);\n-            100\n-        };\n-        assert_eq!(b, 100);\n-    }\n-\n-    #[test]\n-    fn test_as_buf_small() {\n-        let a = \"A\";\n-        let b = do a.as_buf |buf, _l| {\n-            assert_eq!(unsafe { *buf }, 65u8);\n-            100\n-        };\n-        assert_eq!(b, 100);\n-    }\n-\n-    #[test]\n-    fn test_as_buf2() {\n-        unsafe {\n-            let s = ~\"hello\";\n-            let sb = s.as_buf(|b, _l| b);\n-            let s_cstr = raw::from_buf(sb);\n-            assert_eq!(s_cstr, s);\n+    fn test_as_imm_buf() {\n+        do \"\".as_imm_buf |buf, len| {\n+            assert_eq!(len, 1);\n+            unsafe {\n+                assert_eq!(*ptr::offset(buf, 0), 0);\n+            }\n         }\n-    }\n \n-    #[test]\n-    fn test_as_buf_3() {\n-        let a = ~\"hello\";\n-        do a.as_buf |buf, len| {\n+        do \"hello\".as_imm_buf |buf, len| {\n+            assert_eq!(len, 6);\n             unsafe {\n-                assert_eq!(a[0], 'h' as u8);\n-                assert_eq!(*buf, 'h' as u8);\n-                assert_eq!(len, 6u);\n-                assert_eq!(*ptr::offset(buf,4u), 'o' as u8);\n-                assert_eq!(*ptr::offset(buf,5u), 0u8);\n+                assert_eq!(*ptr::offset(buf, 0), 'h' as u8);\n+                assert_eq!(*ptr::offset(buf, 1), 'e' as u8);\n+                assert_eq!(*ptr::offset(buf, 2), 'l' as u8);\n+                assert_eq!(*ptr::offset(buf, 3), 'l' as u8);\n+                assert_eq!(*ptr::offset(buf, 4), 'o' as u8);\n+                assert_eq!(*ptr::offset(buf, 5), 0);\n             }\n         }\n     }"}, {"sha": "9775f1ef45a7475730489d632dffa06984f9f66a", "filename": "src/test/run-pass/c-stack-returning-int64.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/cc9666f68f829c17ff3a535f714fe5dbb3f72755/src%2Ftest%2Frun-pass%2Fc-stack-returning-int64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cc9666f68f829c17ff3a535f714fe5dbb3f72755/src%2Ftest%2Frun-pass%2Fc-stack-returning-int64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fc-stack-returning-int64.rs?ref=cc9666f68f829c17ff3a535f714fe5dbb3f72755", "patch": "@@ -20,11 +20,11 @@ mod libc {\n }\n \n fn atol(s: ~str) -> int {\n-    s.as_buf(|x, _len| unsafe { libc::atol(x) })\n+    s.as_imm_buf(|x, _len| unsafe { libc::atol(x) })\n }\n \n fn atoll(s: ~str) -> i64 {\n-    s.as_buf(|x, _len| unsafe { libc::atoll(x) })\n+    s.as_imm_buf(|x, _len| unsafe { libc::atoll(x) })\n }\n \n pub fn main() {"}]}