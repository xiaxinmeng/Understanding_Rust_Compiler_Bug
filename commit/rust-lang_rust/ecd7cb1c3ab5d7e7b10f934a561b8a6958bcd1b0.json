{"sha": "ecd7cb1c3ab5d7e7b10f934a561b8a6958bcd1b0", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVjZDdjYjFjM2FiNWQ3ZTdiMTBmOTM0YTU2MWI4YTY5NThiY2QxYjA=", "commit": {"author": {"name": "Yuki Okushi", "email": "huyuumi.dev@gmail.com", "date": "2021-01-30T04:36:39Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-01-30T04:36:39Z"}, "message": "Rollup merge of #79023 - yoshuawuyts:stream, r=KodrAus\n\nAdd `core::stream::Stream`\n\n[[Tracking issue: #79024](https://github.com/rust-lang/rust/issues/79024)]\n\nThis patch adds the `core::stream` submodule and implements `core::stream::Stream` in accordance with [RFC2996](https://github.com/rust-lang/rfcs/pull/2996). The RFC hasn't been merged yet, but as requested by the libs team in https://github.com/rust-lang/rfcs/pull/2996#issuecomment-725696389 I'm filing this PR to get the ball rolling.\n\n## Documentatation\n\nThe docs in this PR have been adapted from [`std::iter`](https://doc.rust-lang.org/std/iter/index.html), [`async_std::stream`](https://docs.rs/async-std/1.7.0/async_std/stream/index.html), and [`futures::stream::Stream`](https://docs.rs/futures/0.3.8/futures/stream/trait.Stream.html). Once this PR lands my plan is to follow this up with PRs to add helper methods such as `stream::repeat` which can be used to document more of the concepts that are currently missing. That will allow us to cover concepts such as \"infinite streams\" and \"laziness\" in more depth.\n\n## Feature gate\n\nThe feature gate for `Stream` is `stream_trait`. This matches the `#[lang = \"future_trait\"]` attribute name. The intention is that only the APIs defined in RFC2996 will use this feature gate, with future additions such as `stream::repeat` using their own feature gates. This is so we can ensure a smooth path towards stabilizing the `Stream` trait without needing to stabilize all the APIs in `core::stream` at once. But also don't start expanding the API until _after_ stabilization, as was the case with `std::future`.\n\n__edit:__ the feature gate has been changed to `async_stream` to match the feature gate proposed in the RFC.\n\n## Conclusion\n\nThis PR introduces `core::stream::{Stream, Next}` and re-exports it from `std` as `std::stream::{Stream, Next}`. Landing `Stream` in the stdlib has been a mult-year process; and it's incredibly exciting for this to finally happen!\n\n---\n\nr? `````@KodrAus`````\ncc/ `````@rust-lang/wg-async-foundations````` `````@rust-lang/libs`````", "tree": {"sha": "c7c78e7cdb916b46f283ddf2a5994723536c7291", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/c7c78e7cdb916b46f283ddf2a5994723536c7291"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ecd7cb1c3ab5d7e7b10f934a561b8a6958bcd1b0", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJgFOJYCRBK7hj4Ov3rIwAAdHIIABfTNret9V2DZsG8JHQcbSbA\nKDCWsHGg68MM9zCsL1ETQ8hD6VtOtEscWpA8P4FJ3AH9RS9z1vXZYqcOnRSY0Aid\nV7BJGocplSvM66A/xFe5vapAW7k2Y5jtFQjlBD3l0OCh/qrhGYmVJrQOPtTwgNSt\nmA1SkJIwDlt8A7PrTJQskPm3sQt9FcYaC01TYxPl798vqJx35TTkrOAcHghWxHK1\nh3YYzkMQLe0y7cGt0XvRjJSL7QikACGpD/rWW9s5zuCNP9mCj707BLRLhSQnu25+\nn/oKbl//jcEcE/h6I7jqTPVKMwe6dgHr4xjzbrd6Yd24QFY+pB5Swv+bwnmGJaY=\n=JxKf\n-----END PGP SIGNATURE-----\n", "payload": "tree c7c78e7cdb916b46f283ddf2a5994723536c7291\nparent 0248c6f178ab3a4d2ec702b7d418ff8375ab0515\nparent a1b11321fb2d6ce00af9c8957c98df76432b1b78\nauthor Yuki Okushi <huyuumi.dev@gmail.com> 1611981399 +0900\ncommitter GitHub <noreply@github.com> 1611981399 +0900\n\nRollup merge of #79023 - yoshuawuyts:stream, r=KodrAus\n\nAdd `core::stream::Stream`\n\n[[Tracking issue: #79024](https://github.com/rust-lang/rust/issues/79024)]\n\nThis patch adds the `core::stream` submodule and implements `core::stream::Stream` in accordance with [RFC2996](https://github.com/rust-lang/rfcs/pull/2996). The RFC hasn't been merged yet, but as requested by the libs team in https://github.com/rust-lang/rfcs/pull/2996#issuecomment-725696389 I'm filing this PR to get the ball rolling.\n\n## Documentatation\n\nThe docs in this PR have been adapted from [`std::iter`](https://doc.rust-lang.org/std/iter/index.html), [`async_std::stream`](https://docs.rs/async-std/1.7.0/async_std/stream/index.html), and [`futures::stream::Stream`](https://docs.rs/futures/0.3.8/futures/stream/trait.Stream.html). Once this PR lands my plan is to follow this up with PRs to add helper methods such as `stream::repeat` which can be used to document more of the concepts that are currently missing. That will allow us to cover concepts such as \"infinite streams\" and \"laziness\" in more depth.\n\n## Feature gate\n\nThe feature gate for `Stream` is `stream_trait`. This matches the `#[lang = \"future_trait\"]` attribute name. The intention is that only the APIs defined in RFC2996 will use this feature gate, with future additions such as `stream::repeat` using their own feature gates. This is so we can ensure a smooth path towards stabilizing the `Stream` trait without needing to stabilize all the APIs in `core::stream` at once. But also don't start expanding the API until _after_ stabilization, as was the case with `std::future`.\n\n__edit:__ the feature gate has been changed to `async_stream` to match the feature gate proposed in the RFC.\n\n## Conclusion\n\nThis PR introduces `core::stream::{Stream, Next}` and re-exports it from `std` as `std::stream::{Stream, Next}`. Landing `Stream` in the stdlib has been a mult-year process; and it's incredibly exciting for this to finally happen!\n\n---\n\nr? `````@KodrAus`````\ncc/ `````@rust-lang/wg-async-foundations````` `````@rust-lang/libs`````\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ecd7cb1c3ab5d7e7b10f934a561b8a6958bcd1b0", "html_url": "https://github.com/rust-lang/rust/commit/ecd7cb1c3ab5d7e7b10f934a561b8a6958bcd1b0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ecd7cb1c3ab5d7e7b10f934a561b8a6958bcd1b0/comments", "author": {"login": "JohnTitor", "id": 25030997, "node_id": "MDQ6VXNlcjI1MDMwOTk3", "avatar_url": "https://avatars.githubusercontent.com/u/25030997?v=4", "gravatar_id": "", "url": "https://api.github.com/users/JohnTitor", "html_url": "https://github.com/JohnTitor", "followers_url": "https://api.github.com/users/JohnTitor/followers", "following_url": "https://api.github.com/users/JohnTitor/following{/other_user}", "gists_url": "https://api.github.com/users/JohnTitor/gists{/gist_id}", "starred_url": "https://api.github.com/users/JohnTitor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/JohnTitor/subscriptions", "organizations_url": "https://api.github.com/users/JohnTitor/orgs", "repos_url": "https://api.github.com/users/JohnTitor/repos", "events_url": "https://api.github.com/users/JohnTitor/events{/privacy}", "received_events_url": "https://api.github.com/users/JohnTitor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0248c6f178ab3a4d2ec702b7d418ff8375ab0515", "url": "https://api.github.com/repos/rust-lang/rust/commits/0248c6f178ab3a4d2ec702b7d418ff8375ab0515", "html_url": "https://github.com/rust-lang/rust/commit/0248c6f178ab3a4d2ec702b7d418ff8375ab0515"}, {"sha": "a1b11321fb2d6ce00af9c8957c98df76432b1b78", "url": "https://api.github.com/repos/rust-lang/rust/commits/a1b11321fb2d6ce00af9c8957c98df76432b1b78", "html_url": "https://github.com/rust-lang/rust/commit/a1b11321fb2d6ce00af9c8957c98df76432b1b78"}], "stats": {"total": 271, "additions": 271, "deletions": 0}, "files": [{"sha": "a3c0be69813864148071e99b3b520e98d05fa42c", "filename": "library/alloc/src/boxed.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ecd7cb1c3ab5d7e7b10f934a561b8a6958bcd1b0/library%2Falloc%2Fsrc%2Fboxed.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecd7cb1c3ab5d7e7b10f934a561b8a6958bcd1b0/library%2Falloc%2Fsrc%2Fboxed.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fboxed.rs?ref=ecd7cb1c3ab5d7e7b10f934a561b8a6958bcd1b0", "patch": "@@ -149,6 +149,7 @@ use core::ops::{\n };\n use core::pin::Pin;\n use core::ptr::{self, Unique};\n+use core::stream::Stream;\n use core::task::{Context, Poll};\n \n use crate::alloc::{handle_alloc_error, AllocError, Allocator, Global, Layout, WriteCloneIntoRaw};\n@@ -1621,3 +1622,16 @@ where\n         F::poll(Pin::new(&mut *self), cx)\n     }\n }\n+\n+#[unstable(feature = \"async_stream\", issue = \"79024\")]\n+impl<S: ?Sized + Stream + Unpin> Stream for Box<S> {\n+    type Item = S::Item;\n+\n+    fn poll_next(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {\n+        Pin::new(&mut **self).poll_next(cx)\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        (**self).size_hint()\n+    }\n+}"}, {"sha": "5868f2b5b6562d48cc553e8ce267c08eda92afa1", "filename": "library/alloc/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/ecd7cb1c3ab5d7e7b10f934a561b8a6958bcd1b0/library%2Falloc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecd7cb1c3ab5d7e7b10f934a561b8a6958bcd1b0/library%2Falloc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Flib.rs?ref=ecd7cb1c3ab5d7e7b10f934a561b8a6958bcd1b0", "patch": "@@ -82,6 +82,7 @@\n #![feature(array_windows)]\n #![feature(allow_internal_unstable)]\n #![feature(arbitrary_self_types)]\n+#![feature(async_stream)]\n #![feature(box_patterns)]\n #![feature(box_syntax)]\n #![feature(cfg_sanitize)]"}, {"sha": "a4395ab57e8a1edf5787186e900585d3862be171", "filename": "library/core/src/lib.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ecd7cb1c3ab5d7e7b10f934a561b8a6958bcd1b0/library%2Fcore%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecd7cb1c3ab5d7e7b10f934a561b8a6958bcd1b0/library%2Fcore%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Flib.rs?ref=ecd7cb1c3ab5d7e7b10f934a561b8a6958bcd1b0", "patch": "@@ -254,6 +254,8 @@ pub mod panicking;\n pub mod pin;\n pub mod raw;\n pub mod result;\n+#[unstable(feature = \"async_stream\", issue = \"79024\")]\n+pub mod stream;\n pub mod sync;\n \n pub mod fmt;"}, {"sha": "0df18af65ebf04cc740f77931871df0bd5dfc637", "filename": "library/core/src/stream/mod.rs", "status": "added", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/rust-lang/rust/blob/ecd7cb1c3ab5d7e7b10f934a561b8a6958bcd1b0/library%2Fcore%2Fsrc%2Fstream%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecd7cb1c3ab5d7e7b10f934a561b8a6958bcd1b0/library%2Fcore%2Fsrc%2Fstream%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstream%2Fmod.rs?ref=ecd7cb1c3ab5d7e7b10f934a561b8a6958bcd1b0", "patch": "@@ -0,0 +1,127 @@\n+//! Composable asynchronous iteration.\n+//!\n+//! If futures are asynchronous values, then streams are asynchronous\n+//! iterators. If you've found yourself with an asynchronous collection of some kind,\n+//! and needed to perform an operation on the elements of said collection,\n+//! you'll quickly run into 'streams'. Streams are heavily used in idiomatic\n+//! asynchronous Rust code, so it's worth becoming familiar with them.\n+//!\n+//! Before explaining more, let's talk about how this module is structured:\n+//!\n+//! # Organization\n+//!\n+//! This module is largely organized by type:\n+//!\n+//! * [Traits] are the core portion: these traits define what kind of streams\n+//!   exist and what you can do with them. The methods of these traits are worth\n+//!   putting some extra study time into.\n+//! * Functions provide some helpful ways to create some basic streams.\n+//! * Structs are often the return types of the various methods on this\n+//!   module's traits. You'll usually want to look at the method that creates\n+//!   the `struct`, rather than the `struct` itself. For more detail about why,\n+//!   see '[Implementing Stream](#implementing-stream)'.\n+//!\n+//! [Traits]: #traits\n+//!\n+//! That's it! Let's dig into streams.\n+//!\n+//! # Stream\n+//!\n+//! The heart and soul of this module is the [`Stream`] trait. The core of\n+//! [`Stream`] looks like this:\n+//!\n+//! ```\n+//! # use core::task::{Context, Poll};\n+//! # use core::pin::Pin;\n+//! trait Stream {\n+//!     type Item;\n+//!     fn poll_next(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>>;\n+//! }\n+//! ```\n+//!\n+//! Unlike `Iterator`, `Stream` makes a distinction between the [`poll_next`]\n+//! method which is used when implementing a `Stream`, and a (to-be-implemented)\n+//! `next` method which is used when consuming a stream. Consumers of `Stream`\n+//! only need to consider `next`, which when called, returns a future which\n+//! yields `Option<Stream::Item>`.\n+//!\n+//! The future returned by `next` will yield `Some(Item)` as long as there are\n+//! elements, and once they've all been exhausted, will yield `None` to indicate\n+//! that iteration is finished. If we're waiting on something asynchronous to\n+//! resolve, the future will wait until the stream is ready to yield again.\n+//!\n+//! Individual streams may choose to resume iteration, and so calling `next`\n+//! again may or may not eventually yield `Some(Item)` again at some point.\n+//!\n+//! [`Stream`]'s full definition includes a number of other methods as well,\n+//! but they are default methods, built on top of [`poll_next`], and so you get\n+//! them for free.\n+//!\n+//! [`Poll`]: super::task::Poll\n+//! [`poll_next`]: Stream::poll_next\n+//!\n+//! # Implementing Stream\n+//!\n+//! Creating a stream of your own involves two steps: creating a `struct` to\n+//! hold the stream's state, and then implementing [`Stream`] for that\n+//! `struct`.\n+//!\n+//! Let's make a stream named `Counter` which counts from `1` to `5`:\n+//!\n+//! ```no_run\n+//! #![feature(async_stream)]\n+//! # use core::stream::Stream;\n+//! # use core::task::{Context, Poll};\n+//! # use core::pin::Pin;\n+//!\n+//! // First, the struct:\n+//!\n+//! /// A stream which counts from one to five\n+//! struct Counter {\n+//!     count: usize,\n+//! }\n+//!\n+//! // we want our count to start at one, so let's add a new() method to help.\n+//! // This isn't strictly necessary, but is convenient. Note that we start\n+//! // `count` at zero, we'll see why in `poll_next()`'s implementation below.\n+//! impl Counter {\n+//!     fn new() -> Counter {\n+//!         Counter { count: 0 }\n+//!     }\n+//! }\n+//!\n+//! // Then, we implement `Stream` for our `Counter`:\n+//!\n+//! impl Stream for Counter {\n+//!     // we will be counting with usize\n+//!     type Item = usize;\n+//!\n+//!     // poll_next() is the only required method\n+//!     fn poll_next(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {\n+//!         // Increment our count. This is why we started at zero.\n+//!         self.count += 1;\n+//!\n+//!         // Check to see if we've finished counting or not.\n+//!         if self.count < 6 {\n+//!             Poll::Ready(Some(self.count))\n+//!         } else {\n+//!             Poll::Ready(None)\n+//!         }\n+//!     }\n+//! }\n+//! ```\n+//!\n+//! # Laziness\n+//!\n+//! Streams are *lazy*. This means that just creating a stream doesn't _do_ a\n+//! whole lot. Nothing really happens until you call `next`. This is sometimes a\n+//! source of confusion when creating a stream solely for its side effects. The\n+//! compiler will warn us about this kind of behavior:\n+//!\n+//! ```text\n+//! warning: unused result that must be used: streams do nothing unless polled\n+//! ```\n+\n+mod stream;\n+\n+pub use stream::Stream;"}, {"sha": "e37902dae1f2d24de0e5f0752ab2f7b7a5d723f0", "filename": "library/core/src/stream/stream/mod.rs", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/rust-lang/rust/blob/ecd7cb1c3ab5d7e7b10f934a561b8a6958bcd1b0/library%2Fcore%2Fsrc%2Fstream%2Fstream%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecd7cb1c3ab5d7e7b10f934a561b8a6958bcd1b0/library%2Fcore%2Fsrc%2Fstream%2Fstream%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fstream%2Fstream%2Fmod.rs?ref=ecd7cb1c3ab5d7e7b10f934a561b8a6958bcd1b0", "patch": "@@ -0,0 +1,110 @@\n+use crate::ops::DerefMut;\n+use crate::pin::Pin;\n+use crate::task::{Context, Poll};\n+\n+/// An interface for dealing with asynchronous iterators.\n+///\n+/// This is the main stream trait. For more about the concept of streams\n+/// generally, please see the [module-level documentation]. In particular, you\n+/// may want to know how to [implement `Stream`][impl].\n+///\n+/// [module-level documentation]: index.html\n+/// [impl]: index.html#implementing-stream\n+#[unstable(feature = \"async_stream\", issue = \"79024\")]\n+#[must_use = \"streams do nothing unless polled\"]\n+pub trait Stream {\n+    /// The type of items yielded by the stream.\n+    type Item;\n+\n+    /// Attempt to pull out the next value of this stream, registering the\n+    /// current task for wakeup if the value is not yet available, and returning\n+    /// `None` if the stream is exhausted.\n+    ///\n+    /// # Return value\n+    ///\n+    /// There are several possible return values, each indicating a distinct\n+    /// stream state:\n+    ///\n+    /// - `Poll::Pending` means that this stream's next value is not ready\n+    /// yet. Implementations will ensure that the current task will be notified\n+    /// when the next value may be ready.\n+    ///\n+    /// - `Poll::Ready(Some(val))` means that the stream has successfully\n+    /// produced a value, `val`, and may produce further values on subsequent\n+    /// `poll_next` calls.\n+    ///\n+    /// - `Poll::Ready(None)` means that the stream has terminated, and\n+    /// `poll_next` should not be invoked again.\n+    ///\n+    /// # Panics\n+    ///\n+    /// Once a stream has finished (returned `Ready(None)` from `poll_next`), calling its\n+    /// `poll_next` method again may panic, block forever, or cause other kinds of\n+    /// problems; the `Stream` trait places no requirements on the effects of\n+    /// such a call. However, as the `poll_next` method is not marked `unsafe`,\n+    /// Rust's usual rules apply: calls must never cause undefined behavior\n+    /// (memory corruption, incorrect use of `unsafe` functions, or the like),\n+    /// regardless of the stream's state.\n+    fn poll_next(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>>;\n+\n+    /// Returns the bounds on the remaining length of the stream.\n+    ///\n+    /// Specifically, `size_hint()` returns a tuple where the first element\n+    /// is the lower bound, and the second element is the upper bound.\n+    ///\n+    /// The second half of the tuple that is returned is an [`Option`]`<`[`usize`]`>`.\n+    /// A [`None`] here means that either there is no known upper bound, or the\n+    /// upper bound is larger than [`usize`].\n+    ///\n+    /// # Implementation notes\n+    ///\n+    /// It is not enforced that a stream implementation yields the declared\n+    /// number of elements. A buggy stream may yield less than the lower bound\n+    /// or more than the upper bound of elements.\n+    ///\n+    /// `size_hint()` is primarily intended to be used for optimizations such as\n+    /// reserving space for the elements of the stream, but must not be\n+    /// trusted to e.g., omit bounds checks in unsafe code. An incorrect\n+    /// implementation of `size_hint()` should not lead to memory safety\n+    /// violations.\n+    ///\n+    /// That said, the implementation should provide a correct estimation,\n+    /// because otherwise it would be a violation of the trait's protocol.\n+    ///\n+    /// The default implementation returns `(0, `[`None`]`)` which is correct for any\n+    /// stream.\n+    #[inline]\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        (0, None)\n+    }\n+}\n+\n+#[unstable(feature = \"async_stream\", issue = \"79024\")]\n+impl<S: ?Sized + Stream + Unpin> Stream for &mut S {\n+    type Item = S::Item;\n+\n+    fn poll_next(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {\n+        S::poll_next(Pin::new(&mut **self), cx)\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        (**self).size_hint()\n+    }\n+}\n+\n+#[unstable(feature = \"async_stream\", issue = \"79024\")]\n+impl<P> Stream for Pin<P>\n+where\n+    P: DerefMut + Unpin,\n+    P::Target: Stream,\n+{\n+    type Item = <P::Target as Stream>::Item;\n+\n+    fn poll_next(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {\n+        self.get_mut().as_mut().poll_next(cx)\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        (**self).size_hint()\n+    }\n+}"}, {"sha": "09a05bc1b45e139237815272255bf534e7bac5d1", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/ecd7cb1c3ab5d7e7b10f934a561b8a6958bcd1b0/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecd7cb1c3ab5d7e7b10f934a561b8a6958bcd1b0/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=ecd7cb1c3ab5d7e7b10f934a561b8a6958bcd1b0", "patch": "@@ -224,6 +224,7 @@\n #![feature(allocator_internals)]\n #![feature(allow_internal_unsafe)]\n #![feature(allow_internal_unstable)]\n+#![feature(async_stream)]\n #![feature(arbitrary_self_types)]\n #![feature(array_error_internals)]\n #![feature(asm)]\n@@ -450,6 +451,8 @@ pub use core::ptr;\n pub use core::raw;\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n pub use core::result;\n+#[unstable(feature = \"async_stream\", issue = \"79024\")]\n+pub use core::stream;\n #[stable(feature = \"i128\", since = \"1.26.0\")]\n #[allow(deprecated, deprecated_in_future)]\n pub use core::u128;"}, {"sha": "c4118bf5d9e7fc8cbf2adfcb87b202a927e793e8", "filename": "library/std/src/panic.rs", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/ecd7cb1c3ab5d7e7b10f934a561b8a6958bcd1b0/library%2Fstd%2Fsrc%2Fpanic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ecd7cb1c3ab5d7e7b10f934a561b8a6958bcd1b0/library%2Fstd%2Fsrc%2Fpanic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fpanic.rs?ref=ecd7cb1c3ab5d7e7b10f934a561b8a6958bcd1b0", "patch": "@@ -12,6 +12,7 @@ use crate::panicking;\n use crate::pin::Pin;\n use crate::ptr::{NonNull, Unique};\n use crate::rc::Rc;\n+use crate::stream::Stream;\n use crate::sync::atomic;\n use crate::sync::{Arc, Mutex, RwLock};\n use crate::task::{Context, Poll};\n@@ -340,6 +341,19 @@ impl<F: Future> Future for AssertUnwindSafe<F> {\n     }\n }\n \n+#[unstable(feature = \"async_stream\", issue = \"79024\")]\n+impl<S: Stream> Stream for AssertUnwindSafe<S> {\n+    type Item = S::Item;\n+\n+    fn poll_next(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<S::Item>> {\n+        unsafe { self.map_unchecked_mut(|x| &mut x.0) }.poll_next(cx)\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        self.0.size_hint()\n+    }\n+}\n+\n /// Invokes a closure, capturing the cause of an unwinding panic if one occurs.\n ///\n /// This function will return `Ok` with the closure's result if the closure"}]}