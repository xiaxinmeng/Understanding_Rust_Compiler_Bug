{"sha": "1f7bce012d7df14e3e5d8e595fb6f557b677bd92", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFmN2JjZTAxMmQ3ZGYxNGUzZTVkOGU1OTVmYjZmNTU3YjY3N2JkOTI=", "commit": {"author": {"name": "inquisitivecrystal", "email": "22333129+inquisitivecrystal@users.noreply.github.com", "date": "2021-08-05T23:58:46Z"}, "committer": {"name": "inquisitivecrystal", "email": "22333129+inquisitivecrystal@users.noreply.github.com", "date": "2021-08-28T07:24:39Z"}, "message": "Teach tools that macros are now HIR items", "tree": {"sha": "eca977a4b22548c2dd77eb1ff104303cbdaf0df1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/eca977a4b22548c2dd77eb1ff104303cbdaf0df1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1f7bce012d7df14e3e5d8e595fb6f557b677bd92", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1f7bce012d7df14e3e5d8e595fb6f557b677bd92", "html_url": "https://github.com/rust-lang/rust/commit/1f7bce012d7df14e3e5d8e595fb6f557b677bd92", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1f7bce012d7df14e3e5d8e595fb6f557b677bd92/comments", "author": {"login": "inquisitivecrystal", "id": 22333129, "node_id": "MDQ6VXNlcjIyMzMzMTI5", "avatar_url": "https://avatars.githubusercontent.com/u/22333129?v=4", "gravatar_id": "", "url": "https://api.github.com/users/inquisitivecrystal", "html_url": "https://github.com/inquisitivecrystal", "followers_url": "https://api.github.com/users/inquisitivecrystal/followers", "following_url": "https://api.github.com/users/inquisitivecrystal/following{/other_user}", "gists_url": "https://api.github.com/users/inquisitivecrystal/gists{/gist_id}", "starred_url": "https://api.github.com/users/inquisitivecrystal/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/inquisitivecrystal/subscriptions", "organizations_url": "https://api.github.com/users/inquisitivecrystal/orgs", "repos_url": "https://api.github.com/users/inquisitivecrystal/repos", "events_url": "https://api.github.com/users/inquisitivecrystal/events{/privacy}", "received_events_url": "https://api.github.com/users/inquisitivecrystal/received_events", "type": "User", "site_admin": false}, "committer": {"login": "inquisitivecrystal", "id": 22333129, "node_id": "MDQ6VXNlcjIyMzMzMTI5", "avatar_url": "https://avatars.githubusercontent.com/u/22333129?v=4", "gravatar_id": "", "url": "https://api.github.com/users/inquisitivecrystal", "html_url": "https://github.com/inquisitivecrystal", "followers_url": "https://api.github.com/users/inquisitivecrystal/followers", "following_url": "https://api.github.com/users/inquisitivecrystal/following{/other_user}", "gists_url": "https://api.github.com/users/inquisitivecrystal/gists{/gist_id}", "starred_url": "https://api.github.com/users/inquisitivecrystal/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/inquisitivecrystal/subscriptions", "organizations_url": "https://api.github.com/users/inquisitivecrystal/orgs", "repos_url": "https://api.github.com/users/inquisitivecrystal/repos", "events_url": "https://api.github.com/users/inquisitivecrystal/events{/privacy}", "received_events_url": "https://api.github.com/users/inquisitivecrystal/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0299ed8bbb0b10c17489551c89c16794c7cd6edc", "url": "https://api.github.com/repos/rust-lang/rust/commits/0299ed8bbb0b10c17489551c89c16794c7cd6edc", "html_url": "https://github.com/rust-lang/rust/commit/0299ed8bbb0b10c17489551c89c16794c7cd6edc"}], "stats": {"total": 164, "additions": 72, "deletions": 92}, "files": [{"sha": "640acffb114d945de22d1324f2bce214fec84637", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 4, "deletions": 19, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/1f7bce012d7df14e3e5d8e595fb6f557b677bd92/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f7bce012d7df14e3e5d8e595fb6f557b677bd92/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=1f7bce012d7df14e3e5d8e595fb6f557b677bd92", "patch": "@@ -91,7 +91,6 @@ impl Clean<Item> for doctree::Module<'_> {\n         items.extend(self.foreigns.iter().map(|x| x.clean(cx)));\n         items.extend(self.mods.iter().map(|x| x.clean(cx)));\n         items.extend(self.items.iter().map(|x| x.clean(cx)).flatten());\n-        items.extend(self.macros.iter().map(|x| x.clean(cx)));\n \n         // determine if we should display the inner contents or\n         // the outer `mod` item for the source code.\n@@ -1861,6 +1860,10 @@ impl Clean<Vec<Item>> for (&hir::Item<'_>, Option<Symbol>) {\n                 ItemKind::Fn(ref sig, ref generics, body_id) => {\n                     clean_fn_or_proc_macro(item, sig, generics, body_id, &mut name, cx)\n                 }\n+                ItemKind::Macro(ref macro_def) => MacroItem(Macro {\n+                    source: display_macro_source(cx, name, &macro_def, def_id, &item.vis),\n+                    imported_from: None,\n+                }),\n                 ItemKind::Trait(is_auto, unsafety, ref generics, ref bounds, ref item_ids) => {\n                     let items = item_ids\n                         .iter()\n@@ -2138,24 +2141,6 @@ impl Clean<Item> for (&hir::ForeignItem<'_>, Option<Symbol>) {\n     }\n }\n \n-impl Clean<Item> for (&hir::MacroDef<'_>, Option<Symbol>) {\n-    fn clean(&self, cx: &mut DocContext<'_>) -> Item {\n-        let (item, renamed) = self;\n-        let name = renamed.unwrap_or(item.ident.name);\n-        let def_id = item.def_id.to_def_id();\n-\n-        Item::from_hir_id_and_parts(\n-            item.hir_id(),\n-            Some(name),\n-            MacroItem(Macro {\n-                source: display_macro_source(cx, name, &item.ast, def_id, &item.vis),\n-                imported_from: None,\n-            }),\n-            cx,\n-        )\n-    }\n-}\n-\n impl Clean<TypeBinding> for hir::TypeBinding<'_> {\n     fn clean(&self, cx: &mut DocContext<'_>) -> TypeBinding {\n         TypeBinding { name: self.ident.name, kind: self.kind.clean(cx) }"}, {"sha": "bf14a17c0769355f33f36dbad24dcede2b495ea0", "filename": "src/librustdoc/doctest.rs", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/1f7bce012d7df14e3e5d8e595fb6f557b677bd92/src%2Flibrustdoc%2Fdoctest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f7bce012d7df14e3e5d8e595fb6f557b677bd92/src%2Flibrustdoc%2Fdoctest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctest.rs?ref=1f7bce012d7df14e3e5d8e595fb6f557b677bd92", "patch": "@@ -1171,10 +1171,21 @@ impl<'a, 'hir, 'tcx> intravisit::Visitor<'hir> for HirCollector<'a, 'hir, 'tcx>\n     }\n \n     fn visit_item(&mut self, item: &'hir hir::Item<'_>) {\n-        let name = if let hir::ItemKind::Impl(impl_) = &item.kind {\n-            rustc_hir_pretty::id_to_string(&self.map, impl_.self_ty.hir_id)\n-        } else {\n-            item.ident.to_string()\n+        let name = match &item.kind {\n+            hir::ItemKind::Macro(ref macro_def) => {\n+                // FIXME(#88038): Non exported macros have historically not been tested,\n+                // but we really ought to start testing them.\n+                let def_id = item.def_id.to_def_id();\n+                if macro_def.macro_rules && !self.tcx.has_attr(def_id, sym::macro_export) {\n+                    intravisit::walk_item(self, item);\n+                    return;\n+                }\n+                item.ident.to_string()\n+            }\n+            hir::ItemKind::Impl(impl_) => {\n+                rustc_hir_pretty::id_to_string(&self.map, impl_.self_ty.hir_id)\n+            }\n+            _ => item.ident.to_string(),\n         };\n \n         self.visit_testable(name, item.hir_id(), item.span, |this| {\n@@ -1216,15 +1227,6 @@ impl<'a, 'hir, 'tcx> intravisit::Visitor<'hir> for HirCollector<'a, 'hir, 'tcx>\n             intravisit::walk_field_def(this, f);\n         });\n     }\n-\n-    fn visit_macro_def(&mut self, macro_def: &'hir hir::MacroDef<'_>) {\n-        self.visit_testable(\n-            macro_def.ident.to_string(),\n-            macro_def.hir_id(),\n-            macro_def.span,\n-            |_| (),\n-        );\n-    }\n }\n \n #[cfg(test)]"}, {"sha": "8f1e8f277c5fe8795a7a7d8ca98471cf3e8df29c", "filename": "src/librustdoc/doctree.rs", "status": "modified", "additions": 2, "deletions": 10, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/1f7bce012d7df14e3e5d8e595fb6f557b677bd92/src%2Flibrustdoc%2Fdoctree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f7bce012d7df14e3e5d8e595fb6f557b677bd92/src%2Flibrustdoc%2Fdoctree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fdoctree.rs?ref=1f7bce012d7df14e3e5d8e595fb6f557b677bd92", "patch": "@@ -5,6 +5,7 @@ use rustc_span::{self, Span, Symbol};\n \n use rustc_hir as hir;\n \n+#[derive(Debug)]\n crate struct Module<'hir> {\n     crate name: Symbol,\n     crate where_inner: Span,\n@@ -13,20 +14,11 @@ crate struct Module<'hir> {\n     // (item, renamed)\n     crate items: Vec<(&'hir hir::Item<'hir>, Option<Symbol>)>,\n     crate foreigns: Vec<(&'hir hir::ForeignItem<'hir>, Option<Symbol>)>,\n-    crate macros: Vec<(&'hir hir::MacroDef<'hir>, Option<Symbol>)>,\n }\n \n impl Module<'hir> {\n     crate fn new(name: Symbol, id: hir::HirId, where_inner: Span) -> Module<'hir> {\n-        Module {\n-            name,\n-            id,\n-            where_inner,\n-            mods: Vec::new(),\n-            items: Vec::new(),\n-            foreigns: Vec::new(),\n-            macros: Vec::new(),\n-        }\n+        Module { name, id, where_inner, mods: Vec::new(), items: Vec::new(), foreigns: Vec::new() }\n     }\n \n     crate fn where_outer(&self, tcx: TyCtxt<'_>) -> Span {"}, {"sha": "897b9140fc8bcc6dfdc6aef07198cd5abd59908d", "filename": "src/librustdoc/visit_ast.rs", "status": "modified", "additions": 42, "deletions": 49, "changes": 91, "blob_url": "https://github.com/rust-lang/rust/blob/1f7bce012d7df14e3e5d8e595fb6f557b677bd92/src%2Flibrustdoc%2Fvisit_ast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f7bce012d7df14e3e5d8e595fb6f557b677bd92/src%2Flibrustdoc%2Fvisit_ast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fvisit_ast.rs?ref=1f7bce012d7df14e3e5d8e595fb6f557b677bd92", "patch": "@@ -9,7 +9,7 @@ use rustc_hir::Node;\n use rustc_middle::middle::privacy::AccessLevel;\n use rustc_middle::ty::TyCtxt;\n use rustc_span;\n-use rustc_span::def_id::LOCAL_CRATE;\n+use rustc_span::def_id::{CRATE_DEF_ID, LOCAL_CRATE};\n use rustc_span::source_map::Spanned;\n use rustc_span::symbol::{kw, sym, Symbol};\n \n@@ -79,49 +79,23 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n             &krate.module(),\n             self.cx.tcx.crate_name(LOCAL_CRATE),\n         );\n-        // Attach the crate's exported macros to the top-level module.\n-        // In the case of macros 2.0 (`pub macro`), and for built-in `derive`s or attributes as\n-        // well (_e.g._, `Copy`), these are wrongly bundled in there too, so we need to fix that by\n-        // moving them back to their correct locations.\n-        'exported_macros: for def in krate.exported_macros() {\n-            // The `def` of a macro in `exported_macros` should correspond to either:\n-            //  - a `#[macro_export] macro_rules!` macro,\n-            //  - a built-in `derive` (or attribute) macro such as the ones in `::core`,\n-            //  - a `pub macro`.\n-            // Only the last two need to be fixed, thus:\n-            if def.ast.macro_rules {\n-                top_level_module.macros.push((def, None));\n-                continue 'exported_macros;\n-            }\n-            let tcx = self.cx.tcx;\n-            // Note: this is not the same as `.parent_module()`. Indeed, the latter looks\n-            // for the closest module _ancestor_, which is not necessarily a direct parent\n-            // (since a direct parent isn't necessarily a module, c.f. #77828).\n-            let macro_parent_def_id = {\n-                use rustc_middle::ty::DefIdTree;\n-                tcx.parent(def.def_id.to_def_id()).unwrap()\n-            };\n-            let macro_parent_path = tcx.def_path(macro_parent_def_id);\n-            // HACK: rustdoc has no way to lookup `doctree::Module`s by their HirId. Instead,\n-            // lookup the module by its name, by looking at each path segment one at a time.\n-            let mut cur_mod = &mut top_level_module;\n-            for path_segment in macro_parent_path.data {\n-                // Path segments may refer to a module (in which case they belong to the type\n-                // namespace), which is _necessary_ for the macro to be accessible outside it\n-                // (no \"associated macros\" as of yet). Else we bail with an outer `continue`.\n-                let path_segment_ty_ns = match path_segment.data {\n-                    rustc_hir::definitions::DefPathData::TypeNs(symbol) => symbol,\n-                    _ => continue 'exported_macros,\n-                };\n-                // Descend into the child module that matches this path segment (if any).\n-                match cur_mod.mods.iter_mut().find(|child| child.name == path_segment_ty_ns) {\n-                    Some(child_mod) => cur_mod = &mut *child_mod,\n-                    None => continue 'exported_macros,\n+\n+        // `#[macro_export] macro_rules!` items are reexported at the top level of the\n+        // crate, regardless of where they're defined. We want to document the\n+        // top level rexport of the macro, not its original definition, since\n+        // the rexport defines the path that a user will actually see. Accordingly,\n+        // we add the rexport as an item here, and then skip over the original\n+        // definition in `visit_item()` below.\n+        for export in self.cx.tcx.module_exports(CRATE_DEF_ID).unwrap_or(&[]) {\n+            if let Res::Def(DefKind::Macro(_), def_id) = export.res {\n+                if let Some(local_def_id) = def_id.as_local() {\n+                    if self.cx.tcx.has_attr(def_id, sym::macro_export) {\n+                        let hir_id = self.cx.tcx.hir().local_def_id_to_hir_id(local_def_id);\n+                        let item = self.cx.tcx.hir().expect_item(hir_id);\n+                        top_level_module.items.push((item, None));\n+                    }\n                 }\n             }\n-            let cur_mod_def_id = tcx.hir().local_def_id(cur_mod.id).to_def_id();\n-            assert_eq!(cur_mod_def_id, macro_parent_def_id);\n-            cur_mod.macros.push((def, None));\n         }\n         self.cx.cache.exact_paths = self.exact_paths;\n         top_level_module\n@@ -238,10 +212,6 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 self.inlining = prev;\n                 true\n             }\n-            Node::MacroDef(def) if !glob => {\n-                om.macros.push((def, renamed));\n-                true\n-            }\n             _ => false,\n         };\n         self.view_item_stack.remove(&res_hir_id);\n@@ -257,7 +227,10 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n         debug!(\"visiting item {:?}\", item);\n         let name = renamed.unwrap_or(item.ident.name);\n \n-        if item.vis.node.is_pub() {\n+        let def_id = item.def_id.to_def_id();\n+        let is_pub = item.vis.node.is_pub() || self.cx.tcx.has_attr(def_id, sym::macro_export);\n+\n+        if is_pub {\n             self.store_path(item.def_id.to_def_id());\n         }\n \n@@ -269,7 +242,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n                 }\n             }\n             // If we're inlining, skip private items.\n-            _ if self.inlining && !item.vis.node.is_pub() => {}\n+            _ if self.inlining && !is_pub => {}\n             hir::ItemKind::GlobalAsm(..) => {}\n             hir::ItemKind::Use(_, hir::UseKind::ListStem) => {}\n             hir::ItemKind::Use(ref path, kind) => {\n@@ -285,7 +258,7 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n \n                 // If there was a private module in the current path then don't bother inlining\n                 // anything as it will probably be stripped anyway.\n-                if item.vis.node.is_pub() && self.inside_public_path {\n+                if is_pub && self.inside_public_path {\n                     let please_inline = attrs.iter().any(|item| match item.meta_item_list() {\n                         Some(ref list) if item.has_name(sym::doc) => {\n                             list.iter().any(|i| i.has_name(sym::inline))\n@@ -307,6 +280,26 @@ impl<'a, 'tcx> RustdocVisitor<'a, 'tcx> {\n \n                 om.items.push((item, renamed))\n             }\n+            hir::ItemKind::Macro(ref macro_def) => {\n+                // `#[macro_export] macro_rules!` items are handled seperately in `visit()`,\n+                // above, since they need to be documented at the module top level. Accordingly,\n+                // we only want to handle macros if one of three conditions holds:\n+                //\n+                // 1. This macro was defined by `macro`, and thus isn't covered by the case\n+                //    above.\n+                // 2. This macro isn't marked with `#[macro_export]`, and thus isn't covered\n+                //    by the case above.\n+                // 3. We're inlining, since a reexport where inlining has been requested\n+                //    should be inlined even if it is also documented at the top level.\n+\n+                let def_id = item.def_id.to_def_id();\n+                let is_macro_2_0 = !macro_def.macro_rules;\n+                let nonexported = !self.cx.tcx.has_attr(def_id, sym::macro_export);\n+\n+                if is_macro_2_0 || nonexported || self.inlining {\n+                    om.items.push((item, renamed));\n+                }\n+            }\n             hir::ItemKind::Mod(ref m) => {\n                 om.mods.push(self.visit_mod_contents(&item.vis, item.hir_id(), m, name));\n             }"}, {"sha": "940eee7a78897131d0ced058361e5dd3a87454e3", "filename": "src/tools/clippy/clippy_lints/src/missing_doc.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/1f7bce012d7df14e3e5d8e595fb6f557b677bd92/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_doc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f7bce012d7df14e3e5d8e595fb6f557b677bd92/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_doc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_doc.rs?ref=1f7bce012d7df14e3e5d8e595fb6f557b677bd92", "patch": "@@ -122,8 +122,8 @@ impl<'tcx> LateLintPass<'tcx> for MissingDoc {\n             },\n             hir::ItemKind::Const(..)\n             | hir::ItemKind::Enum(..)\n-            | hir::ItemKind::Mod(..)\n             | hir::ItemKind::Macro(..)\n+            | hir::ItemKind::Mod(..)\n             | hir::ItemKind::Static(..)\n             | hir::ItemKind::Struct(..)\n             | hir::ItemKind::Trait(..)"}, {"sha": "667cdd8302528caec005ef878d7a8f2087d50e70", "filename": "src/tools/clippy/clippy_lints/src/missing_inline.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/1f7bce012d7df14e3e5d8e595fb6f557b677bd92/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_inline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f7bce012d7df14e3e5d8e595fb6f557b677bd92/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_inline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmissing_inline.rs?ref=1f7bce012d7df14e3e5d8e595fb6f557b677bd92", "patch": "@@ -118,6 +118,7 @@ impl<'tcx> LateLintPass<'tcx> for MissingInline {\n             },\n             hir::ItemKind::Const(..)\n             | hir::ItemKind::Enum(..)\n+            | hir::ItemKind::Macro(..)\n             | hir::ItemKind::Mod(..)\n             | hir::ItemKind::Static(..)\n             | hir::ItemKind::Struct(..)"}, {"sha": "e97983a2e1451d373e77609e8f13f456f7dbbfde", "filename": "src/tools/clippy/clippy_lints/src/utils/inspector.rs", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/1f7bce012d7df14e3e5d8e595fb6f557b677bd92/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finspector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1f7bce012d7df14e3e5d8e595fb6f557b677bd92/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finspector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Finspector.rs?ref=1f7bce012d7df14e3e5d8e595fb6f557b677bd92", "patch": "@@ -381,6 +381,13 @@ fn print_item(cx: &LateContext<'_>, item: &hir::Item<'_>) {\n             let item_ty = cx.tcx.type_of(did);\n             println!(\"function of type {:#?}\", item_ty);\n         },\n+        hir::ItemKind::Macro(ref macro_def) => {\n+            if macro_def.macro_rules {\n+                println!(\"macro introduced by `macro_rules!`\");\n+            } else {\n+                println!(\"macro introduced by `macro`\");\n+            }\n+        },\n         hir::ItemKind::Mod(..) => println!(\"module\"),\n         hir::ItemKind::ForeignMod { abi, .. } => println!(\"foreign module with abi: {}\", abi),\n         hir::ItemKind::GlobalAsm(asm) => println!(\"global asm: {:?}\", asm),"}]}