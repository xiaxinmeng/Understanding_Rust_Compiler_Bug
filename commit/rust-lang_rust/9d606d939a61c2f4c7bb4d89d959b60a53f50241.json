{"sha": "9d606d939a61c2f4c7bb4d89d959b60a53f50241", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlkNjA2ZDkzOWE2MWMyZjRjN2JiNGQ4OWQ5NTliNjBhNTNmNTAyNDE=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-23T14:50:15Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-08-23T14:50:15Z"}, "message": "Auto merge of #74238 - RalfJung:offset_from, r=oli-obk\n\nstabilize ptr_offset_from\n\nThis stabilizes ptr::offset_from, and closes https://github.com/rust-lang/rust/issues/41079. It also removes the deprecated `wrapping_offset_from`. This function was deprecated 19 days ago and was never stable; given an FCP of 10 days and some waiting time until FCP starts, that leaves at least a month between deprecation and removal which I think is fine for a nightly-only API.\n\nRegarding the open questions in https://github.com/rust-lang/rust/issues/41079:\n* Should offset_from abort instead of panic on ZSTs? -- As far as I know, there is no precedent for such aborts. We could, however, declare this UB. Given that the size is always known statically and the check thus rather cheap, UB seems excessive.\n* Should there be more methods like this with different restrictions (to allow nuw/nsw, perhaps) or that return usize (like how isize-taking offset is more conveniently done with usize-taking add these days)? -- No reason to block stabilization on that, we can always add such methods later.\n\nAlso nominating the lang team because this exposes an intrinsic.\n\nThe stabilized method is best described [by its doc-comment](https://github.com/RalfJung/rust/blob/56d4b2d69abb93e4f0ca79471deca7aaaaeca214/src/libcore/ptr/const_ptr.rs#L227). The documentation forgot to mention the requirement that both pointers must \"have the same provenance\", aka \"be derived from pointers to the same allocation\", which I am adding in this PR. This is a precondition that [Miri already implements](https://play.rust-lang.org/?version=nightly&mode=debug&edition=2018&gist=a3b9d0a07a01321f5202cd99e9613480) and that, should LLVM ever obtain a `psub` operation to subtract pointers, will likely be required for that operation (following the semantics in [this paper](https://people.mpi-sws.org/~jung/twinsem/twinsem.pdf)).", "tree": {"sha": "69c870f2108e2b9a19bc4bfe9e61d81a5105ed05", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/69c870f2108e2b9a19bc4bfe9e61d81a5105ed05"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9d606d939a61c2f4c7bb4d89d959b60a53f50241", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9d606d939a61c2f4c7bb4d89d959b60a53f50241", "html_url": "https://github.com/rust-lang/rust/commit/9d606d939a61c2f4c7bb4d89d959b60a53f50241", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9d606d939a61c2f4c7bb4d89d959b60a53f50241/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b88434ee0f133d220fd86e8bfec7b764a4084bf2", "url": "https://api.github.com/repos/rust-lang/rust/commits/b88434ee0f133d220fd86e8bfec7b764a4084bf2", "html_url": "https://github.com/rust-lang/rust/commit/b88434ee0f133d220fd86e8bfec7b764a4084bf2"}, {"sha": "4129e0757a682e5177690ff34df9cc4480257a24", "url": "https://api.github.com/repos/rust-lang/rust/commits/4129e0757a682e5177690ff34df9cc4480257a24", "html_url": "https://github.com/rust-lang/rust/commit/4129e0757a682e5177690ff34df9cc4480257a24"}], "stats": {"total": 198, "additions": 57, "deletions": 141}, "files": [{"sha": "17573f319e2649823115c3ae5bb7a0cbe51a861f", "filename": "library/alloc/src/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9d606d939a61c2f4c7bb4d89d959b60a53f50241/library%2Falloc%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d606d939a61c2f4c7bb4d89d959b60a53f50241/library%2Falloc%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Flib.rs?ref=9d606d939a61c2f4c7bb4d89d959b60a53f50241", "patch": "@@ -113,7 +113,6 @@\n #![feature(or_patterns)]\n #![feature(pattern)]\n #![feature(ptr_internals)]\n-#![feature(ptr_offset_from)]\n #![feature(raw_ref_op)]\n #![feature(rustc_attrs)]\n #![feature(receiver_trait)]"}, {"sha": "fc70dec16f618aeea80e257ebc4e5ae4055c49f6", "filename": "library/core/src/ptr/const_ptr.rs", "status": "modified", "additions": 23, "deletions": 63, "changes": 86, "blob_url": "https://github.com/rust-lang/rust/blob/9d606d939a61c2f4c7bb4d89d959b60a53f50241/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d606d939a61c2f4c7bb4d89d959b60a53f50241/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fconst_ptr.rs?ref=9d606d939a61c2f4c7bb4d89d959b60a53f50241", "patch": "@@ -240,8 +240,8 @@ impl<T: ?Sized> *const T {\n     /// different allocated object. Note that in Rust,\n     /// every (stack-allocated) variable is considered a separate allocated object.\n     ///\n-    /// In other words, `x.wrapping_offset(y.wrapping_offset_from(x))` is\n-    /// *not* the same as `y`, and dereferencing it is undefined behavior\n+    /// In other words, `x.wrapping_offset((y as usize).wrapping_sub(x as usize) / size_of::<T>())`\n+    /// is *not* the same as `y`, and dereferencing it is undefined behavior\n     /// unless `x` and `y` point into the same allocated object.\n     ///\n     /// Compared to [`offset`], this method basically delays the requirement of staying\n@@ -292,7 +292,6 @@ impl<T: ?Sized> *const T {\n     /// This function is the inverse of [`offset`].\n     ///\n     /// [`offset`]: #method.offset\n-    /// [`wrapping_offset_from`]: #method.wrapping_offset_from\n     ///\n     /// # Safety\n     ///\n@@ -303,6 +302,9 @@ impl<T: ?Sized> *const T {\n     ///   byte past the end of the same allocated object. Note that in Rust,\n     ///   every (stack-allocated) variable is considered a separate allocated object.\n     ///\n+    /// * Both pointers must be *derived from* a pointer to the same object.\n+    ///   (See below for an example.)\n+    ///\n     /// * The distance between the pointers, **in bytes**, cannot overflow an `isize`.\n     ///\n     /// * The distance between the pointers, in bytes, must be an exact multiple\n@@ -323,10 +325,6 @@ impl<T: ?Sized> *const T {\n     /// Extension. As such, memory acquired directly from allocators or memory\n     /// mapped files *may* be too large to handle with this function.\n     ///\n-    /// Consider using [`wrapping_offset_from`] instead if these constraints are\n-    /// difficult to satisfy. The only advantage of this method is that it\n-    /// enables more aggressive compiler optimizations.\n-    ///\n     /// # Panics\n     ///\n     /// This function panics if `T` is a Zero-Sized Type (\"ZST\").\n@@ -336,8 +334,6 @@ impl<T: ?Sized> *const T {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// #![feature(ptr_offset_from)]\n-    ///\n     /// let a = [0; 5];\n     /// let ptr1: *const i32 = &a[1];\n     /// let ptr2: *const i32 = &a[3];\n@@ -348,7 +344,24 @@ impl<T: ?Sized> *const T {\n     ///     assert_eq!(ptr2.offset(-2), ptr1);\n     /// }\n     /// ```\n-    #[unstable(feature = \"ptr_offset_from\", issue = \"41079\")]\n+    ///\n+    /// *Incorrect* usage:\n+    ///\n+    /// ```rust,no_run\n+    /// let ptr1 = Box::into_raw(Box::new(0u8)) as *const u8;\n+    /// let ptr2 = Box::into_raw(Box::new(1u8)) as *const u8;\n+    /// let diff = (ptr2 as isize).wrapping_sub(ptr1 as isize);\n+    /// // Make ptr2_other an \"alias\" of ptr2, but derived from ptr1.\n+    /// let ptr2_other = (ptr1 as *const u8).wrapping_offset(diff);\n+    /// assert_eq!(ptr2 as usize, ptr2_other as usize);\n+    /// // Since ptr2_other and ptr2 are derived from pointers to different objects,\n+    /// // computing their offset is undefined behavior, even though\n+    /// // they point to the same address!\n+    /// unsafe {\n+    ///     let zero = ptr2_other.offset_from(ptr2); // Undefined Behavior\n+    /// }\n+    /// ```\n+    #[stable(feature = \"ptr_offset_from\", since = \"1.47.0\")]\n     #[rustc_const_unstable(feature = \"const_ptr_offset_from\", issue = \"41079\")]\n     #[inline]\n     pub const unsafe fn offset_from(self, origin: *const T) -> isize\n@@ -423,59 +436,6 @@ impl<T: ?Sized> *const T {\n         intrinsics::ptr_guaranteed_ne(self, other)\n     }\n \n-    /// Calculates the distance between two pointers. The returned value is in\n-    /// units of T: the distance in bytes is divided by `mem::size_of::<T>()`.\n-    ///\n-    /// If the address different between the two pointers is not a multiple of\n-    /// `mem::size_of::<T>()` then the result of the division is rounded towards\n-    /// zero.\n-    ///\n-    /// Though this method is safe for any two pointers, note that its result\n-    /// will be mostly useless if the two pointers aren't into the same allocated\n-    /// object, for example if they point to two different local variables.\n-    ///\n-    /// # Panics\n-    ///\n-    /// This function panics if `T` is a zero-sized type.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// #![feature(ptr_wrapping_offset_from)]\n-    ///\n-    /// let a = [0; 5];\n-    /// let ptr1: *const i32 = &a[1];\n-    /// let ptr2: *const i32 = &a[3];\n-    /// assert_eq!(ptr2.wrapping_offset_from(ptr1), 2);\n-    /// assert_eq!(ptr1.wrapping_offset_from(ptr2), -2);\n-    /// assert_eq!(ptr1.wrapping_offset(2), ptr2);\n-    /// assert_eq!(ptr2.wrapping_offset(-2), ptr1);\n-    ///\n-    /// let ptr1: *const i32 = 3 as _;\n-    /// let ptr2: *const i32 = 13 as _;\n-    /// assert_eq!(ptr2.wrapping_offset_from(ptr1), 2);\n-    /// ```\n-    #[unstable(feature = \"ptr_wrapping_offset_from\", issue = \"41079\")]\n-    #[rustc_deprecated(\n-        since = \"1.46.0\",\n-        reason = \"Pointer distances across allocation \\\n-        boundaries are not typically meaningful. \\\n-        Use integer subtraction if you really need this.\"\n-    )]\n-    #[inline]\n-    pub fn wrapping_offset_from(self, origin: *const T) -> isize\n-    where\n-        T: Sized,\n-    {\n-        let pointee_size = mem::size_of::<T>();\n-        assert!(0 < pointee_size && pointee_size <= isize::MAX as usize);\n-\n-        let d = isize::wrapping_sub(self as _, origin as _);\n-        d.wrapping_div(pointee_size as _)\n-    }\n-\n     /// Calculates the offset from a pointer (convenience for `.offset(count as isize)`).\n     ///\n     /// `count` is in units of T; e.g., a `count` of 3 represents a pointer"}, {"sha": "2d25f21e55c761a5321765d8712fedabf2e2be38", "filename": "library/core/src/ptr/mut_ptr.rs", "status": "modified", "additions": 23, "deletions": 60, "changes": 83, "blob_url": "https://github.com/rust-lang/rust/blob/9d606d939a61c2f4c7bb4d89d959b60a53f50241/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d606d939a61c2f4c7bb4d89d959b60a53f50241/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fptr%2Fmut_ptr.rs?ref=9d606d939a61c2f4c7bb4d89d959b60a53f50241", "patch": "@@ -246,8 +246,8 @@ impl<T: ?Sized> *mut T {\n     /// different allocated object. Note that in Rust,\n     /// every (stack-allocated) variable is considered a separate allocated object.\n     ///\n-    /// In other words, `x.wrapping_offset(y.wrapping_offset_from(x))` is\n-    /// *not* the same as `y`, and dereferencing it is undefined behavior\n+    /// In other words, `x.wrapping_offset((y as usize).wrapping_sub(x as usize) / size_of::<T>())`\n+    /// is *not* the same as `y`, and dereferencing it is undefined behavior\n     /// unless `x` and `y` point into the same allocated object.\n     ///\n     /// Compared to [`offset`], this method basically delays the requirement of staying\n@@ -463,7 +463,6 @@ impl<T: ?Sized> *mut T {\n     /// This function is the inverse of [`offset`].\n     ///\n     /// [`offset`]: #method.offset-1\n-    /// [`wrapping_offset_from`]: #method.wrapping_offset_from-1\n     ///\n     /// # Safety\n     ///\n@@ -474,6 +473,9 @@ impl<T: ?Sized> *mut T {\n     ///   byte past the end of the same allocated object. Note that in Rust,\n     ///   every (stack-allocated) variable is considered a separate allocated object.\n     ///\n+    /// * Both pointers must be *derived from* a pointer to the same object.\n+    ///   (See below for an example.)\n+    ///\n     /// * The distance between the pointers, **in bytes**, cannot overflow an `isize`.\n     ///\n     /// * The distance between the pointers, in bytes, must be an exact multiple\n@@ -494,10 +496,6 @@ impl<T: ?Sized> *mut T {\n     /// Extension. As such, memory acquired directly from allocators or memory\n     /// mapped files *may* be too large to handle with this function.\n     ///\n-    /// Consider using [`wrapping_offset_from`] instead if these constraints are\n-    /// difficult to satisfy. The only advantage of this method is that it\n-    /// enables more aggressive compiler optimizations.\n-    ///\n     /// # Panics\n     ///\n     /// This function panics if `T` is a Zero-Sized Type (\"ZST\").\n@@ -507,8 +505,6 @@ impl<T: ?Sized> *mut T {\n     /// Basic usage:\n     ///\n     /// ```\n-    /// #![feature(ptr_offset_from)]\n-    ///\n     /// let mut a = [0; 5];\n     /// let ptr1: *mut i32 = &mut a[1];\n     /// let ptr2: *mut i32 = &mut a[3];\n@@ -519,7 +515,24 @@ impl<T: ?Sized> *mut T {\n     ///     assert_eq!(ptr2.offset(-2), ptr1);\n     /// }\n     /// ```\n-    #[unstable(feature = \"ptr_offset_from\", issue = \"41079\")]\n+    ///\n+    /// *Incorrect* usage:\n+    ///\n+    /// ```rust,no_run\n+    /// let ptr1 = Box::into_raw(Box::new(0u8));\n+    /// let ptr2 = Box::into_raw(Box::new(1u8));\n+    /// let diff = (ptr2 as isize).wrapping_sub(ptr1 as isize);\n+    /// // Make ptr2_other an \"alias\" of ptr2, but derived from ptr1.\n+    /// let ptr2_other = (ptr1 as *mut u8).wrapping_offset(diff);\n+    /// assert_eq!(ptr2 as usize, ptr2_other as usize);\n+    /// // Since ptr2_other and ptr2 are derived from pointers to different objects,\n+    /// // computing their offset is undefined behavior, even though\n+    /// // they point to the same address!\n+    /// unsafe {\n+    ///     let zero = ptr2_other.offset_from(ptr2); // Undefined Behavior\n+    /// }\n+    /// ```\n+    #[stable(feature = \"ptr_offset_from\", since = \"1.47.0\")]\n     #[rustc_const_unstable(feature = \"const_ptr_offset_from\", issue = \"41079\")]\n     #[inline]\n     pub const unsafe fn offset_from(self, origin: *const T) -> isize\n@@ -530,56 +543,6 @@ impl<T: ?Sized> *mut T {\n         unsafe { (self as *const T).offset_from(origin) }\n     }\n \n-    /// Calculates the distance between two pointers. The returned value is in\n-    /// units of T: the distance in bytes is divided by `mem::size_of::<T>()`.\n-    ///\n-    /// If the address different between the two pointers is not a multiple of\n-    /// `mem::size_of::<T>()` then the result of the division is rounded towards\n-    /// zero.\n-    ///\n-    /// Though this method is safe for any two pointers, note that its result\n-    /// will be mostly useless if the two pointers aren't into the same allocated\n-    /// object, for example if they point to two different local variables.\n-    ///\n-    /// # Panics\n-    ///\n-    /// This function panics if `T` is a zero-sized type.\n-    ///\n-    /// # Examples\n-    ///\n-    /// Basic usage:\n-    ///\n-    /// ```\n-    /// #![feature(ptr_wrapping_offset_from)]\n-    ///\n-    /// let mut a = [0; 5];\n-    /// let ptr1: *mut i32 = &mut a[1];\n-    /// let ptr2: *mut i32 = &mut a[3];\n-    /// assert_eq!(ptr2.wrapping_offset_from(ptr1), 2);\n-    /// assert_eq!(ptr1.wrapping_offset_from(ptr2), -2);\n-    /// assert_eq!(ptr1.wrapping_offset(2), ptr2);\n-    /// assert_eq!(ptr2.wrapping_offset(-2), ptr1);\n-    ///\n-    /// let ptr1: *mut i32 = 3 as _;\n-    /// let ptr2: *mut i32 = 13 as _;\n-    /// assert_eq!(ptr2.wrapping_offset_from(ptr1), 2);\n-    /// ```\n-    #[unstable(feature = \"ptr_wrapping_offset_from\", issue = \"41079\")]\n-    #[rustc_deprecated(\n-        since = \"1.46.0\",\n-        reason = \"Pointer distances across allocation \\\n-        boundaries are not typically meaningful. \\\n-        Use integer subtraction if you really need this.\"\n-    )]\n-    #[inline]\n-    pub fn wrapping_offset_from(self, origin: *const T) -> isize\n-    where\n-        T: Sized,\n-    {\n-        #[allow(deprecated_in_future, deprecated)]\n-        (self as *const T).wrapping_offset_from(origin)\n-    }\n-\n     /// Calculates the offset from a pointer (convenience for `.offset(count as isize)`).\n     ///\n     /// `count` is in units of T; e.g., a `count` of 3 represents a pointer"}, {"sha": "00f37d90c6afea0fdf0b418256cff2a42cb1ad91", "filename": "library/std/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d606d939a61c2f4c7bb4d89d959b60a53f50241/library%2Fstd%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d606d939a61c2f4c7bb4d89d959b60a53f50241/library%2Fstd%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Flib.rs?ref=9d606d939a61c2f4c7bb4d89d959b60a53f50241", "patch": "@@ -208,7 +208,7 @@\n #![cfg_attr(test, feature(print_internals, set_stdio, update_panic_count))]\n #![cfg_attr(\n     all(target_vendor = \"fortanix\", target_env = \"sgx\"),\n-    feature(slice_index_methods, coerce_unsized, sgx_platform, ptr_wrapping_offset_from)\n+    feature(slice_index_methods, coerce_unsized, sgx_platform)\n )]\n #![cfg_attr(all(test, target_vendor = \"fortanix\", target_env = \"sgx\"), feature(fixed_size_array))]\n // std is implemented with unstable features, many of which are internal"}, {"sha": "b017fee7e2726618172e33252e52effe9ef1d242", "filename": "src/librustdoc/lib.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9d606d939a61c2f4c7bb4d89d959b60a53f50241/src%2Flibrustdoc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d606d939a61c2f4c7bb4d89d959b60a53f50241/src%2Flibrustdoc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Flib.rs?ref=9d606d939a61c2f4c7bb4d89d959b60a53f50241", "patch": "@@ -9,7 +9,6 @@\n #![feature(nll)]\n #![feature(or_patterns)]\n #![feature(test)]\n-#![feature(ptr_offset_from)]\n #![feature(crate_visibility_modifier)]\n #![feature(never_type)]\n #![feature(once_cell)]"}, {"sha": "a491f1c92d3e10b0cbd812bdd1c2e421cf152a90", "filename": "src/test/ui/consts/offset.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9d606d939a61c2f4c7bb4d89d959b60a53f50241/src%2Ftest%2Fui%2Fconsts%2Foffset.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d606d939a61c2f4c7bb4d89d959b60a53f50241/src%2Ftest%2Fui%2Fconsts%2Foffset.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Foffset.rs?ref=9d606d939a61c2f4c7bb4d89d959b60a53f50241", "patch": "@@ -1,7 +1,6 @@\n // run-pass\n #![feature(const_ptr_offset)]\n #![feature(const_ptr_offset_from)]\n-#![feature(ptr_offset_from)]\n use std::ptr;\n \n #[repr(C)]"}, {"sha": "8d501e0d9533783f0e83a46f637b794affbb6e71", "filename": "src/test/ui/consts/offset_from.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9d606d939a61c2f4c7bb4d89d959b60a53f50241/src%2Ftest%2Fui%2Fconsts%2Foffset_from.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d606d939a61c2f4c7bb4d89d959b60a53f50241/src%2Ftest%2Fui%2Fconsts%2Foffset_from.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Foffset_from.rs?ref=9d606d939a61c2f4c7bb4d89d959b60a53f50241", "patch": "@@ -2,7 +2,6 @@\n \n #![feature(const_raw_ptr_deref)]\n #![feature(const_ptr_offset_from)]\n-#![feature(ptr_offset_from)]\n \n struct Struct {\n     field: (),"}, {"sha": "b73191d56a6129d840d3ede8f745f4de6ceaea05", "filename": "src/test/ui/consts/offset_from_ub.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/9d606d939a61c2f4c7bb4d89d959b60a53f50241/src%2Ftest%2Fui%2Fconsts%2Foffset_from_ub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d606d939a61c2f4c7bb4d89d959b60a53f50241/src%2Ftest%2Fui%2Fconsts%2Foffset_from_ub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Foffset_from_ub.rs?ref=9d606d939a61c2f4c7bb4d89d959b60a53f50241", "patch": "@@ -1,6 +1,5 @@\n #![feature(const_raw_ptr_deref)]\n #![feature(const_ptr_offset_from)]\n-#![feature(ptr_offset_from)]\n \n #[repr(C)]\n struct Struct {"}, {"sha": "a89dcefd839205542f1563f69bb3d4f168c0fccc", "filename": "src/test/ui/consts/offset_from_ub.stderr", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/9d606d939a61c2f4c7bb4d89d959b60a53f50241/src%2Ftest%2Fui%2Fconsts%2Foffset_from_ub.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9d606d939a61c2f4c7bb4d89d959b60a53f50241/src%2Ftest%2Fui%2Fconsts%2Foffset_from_ub.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fconsts%2Foffset_from_ub.stderr?ref=9d606d939a61c2f4c7bb4d89d959b60a53f50241", "patch": "@@ -6,9 +6,9 @@ LL |           unsafe { intrinsics::ptr_offset_from(self, origin) }\n    |                    |\n    |                    ptr_offset_from cannot compute offset of pointers into different allocations.\n    |                    inside `std::ptr::const_ptr::<impl *const Struct>::offset_from` at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-   |                    inside `DIFFERENT_ALLOC` at $DIR/offset_from_ub.rs:17:27\n+   |                    inside `DIFFERENT_ALLOC` at $DIR/offset_from_ub.rs:16:27\n    | \n-  ::: $DIR/offset_from_ub.rs:11:1\n+  ::: $DIR/offset_from_ub.rs:10:1\n    |\n LL | / pub const DIFFERENT_ALLOC: usize = {\n LL | |\n@@ -29,9 +29,9 @@ LL |           unsafe { intrinsics::ptr_offset_from(self, origin) }\n    |                    |\n    |                    unable to turn bytes into a pointer\n    |                    inside `std::ptr::const_ptr::<impl *const u8>::offset_from` at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-   |                    inside `NOT_PTR` at $DIR/offset_from_ub.rs:23:14\n+   |                    inside `NOT_PTR` at $DIR/offset_from_ub.rs:22:14\n    | \n-  ::: $DIR/offset_from_ub.rs:21:1\n+  ::: $DIR/offset_from_ub.rs:20:1\n    |\n LL | / pub const NOT_PTR: usize = {\n LL | |\n@@ -47,9 +47,9 @@ LL |           unsafe { intrinsics::ptr_offset_from(self, origin) }\n    |                    |\n    |                    exact_div: 1_isize cannot be divided by 2_isize without remainder\n    |                    inside `std::ptr::const_ptr::<impl *const u16>::offset_from` at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-   |                    inside `NOT_MULTIPLE_OF_SIZE` at $DIR/offset_from_ub.rs:31:14\n+   |                    inside `NOT_MULTIPLE_OF_SIZE` at $DIR/offset_from_ub.rs:30:14\n    | \n-  ::: $DIR/offset_from_ub.rs:26:1\n+  ::: $DIR/offset_from_ub.rs:25:1\n    |\n LL | / pub const NOT_MULTIPLE_OF_SIZE: isize = {\n LL | |\n@@ -68,9 +68,9 @@ LL |           unsafe { intrinsics::ptr_offset_from(self, origin) }\n    |                    |\n    |                    inbounds test failed: 0x0 is not a valid pointer\n    |                    inside `std::ptr::const_ptr::<impl *const u8>::offset_from` at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-   |                    inside `OFFSET_FROM_NULL` at $DIR/offset_from_ub.rs:37:14\n+   |                    inside `OFFSET_FROM_NULL` at $DIR/offset_from_ub.rs:36:14\n    | \n-  ::: $DIR/offset_from_ub.rs:34:1\n+  ::: $DIR/offset_from_ub.rs:33:1\n    |\n LL | / pub const OFFSET_FROM_NULL: isize = {\n LL | |\n@@ -87,9 +87,9 @@ LL |           unsafe { intrinsics::ptr_offset_from(self, origin) }\n    |                    |\n    |                    unable to turn bytes into a pointer\n    |                    inside `std::ptr::const_ptr::<impl *const u8>::offset_from` at $SRC_DIR/core/src/ptr/const_ptr.rs:LL:COL\n-   |                    inside `DIFFERENT_INT` at $DIR/offset_from_ub.rs:44:14\n+   |                    inside `DIFFERENT_INT` at $DIR/offset_from_ub.rs:43:14\n    | \n-  ::: $DIR/offset_from_ub.rs:40:1\n+  ::: $DIR/offset_from_ub.rs:39:1\n    |\n LL | / pub const DIFFERENT_INT: isize = { // offset_from with two different integers: like DIFFERENT_ALLOC\n LL | |"}, {"sha": "aa59c119706ea690ad56a1288b4fd0f4ea8ce259", "filename": "src/test/ui/offset_from.rs", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9d606d939a61c2f4c7bb4d89d959b60a53f50241/src%2Ftest%2Fui%2Foffset_from.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9d606d939a61c2f4c7bb4d89d959b60a53f50241/src%2Ftest%2Fui%2Foffset_from.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Foffset_from.rs?ref=9d606d939a61c2f4c7bb4d89d959b60a53f50241", "patch": "@@ -1,7 +1,5 @@\n // run-pass\n \n-#![feature(ptr_offset_from)]\n-\n fn main() {\n     let mut a = [0; 5];\n     let ptr1: *mut i32 = &mut a[1];"}]}