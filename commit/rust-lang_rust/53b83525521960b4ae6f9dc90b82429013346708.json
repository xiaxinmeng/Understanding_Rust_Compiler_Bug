{"sha": "53b83525521960b4ae6f9dc90b82429013346708", "node_id": "MDY6Q29tbWl0NzI0NzEyOjUzYjgzNTI1NTIxOTYwYjRhZTZmOWRjOTBiODI0MjkwMTMzNDY3MDg=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-05-30T19:03:21Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2013-06-08T18:59:03Z"}, "message": "rustpkg: Extract version number from git, as per #5684\n\nFor now, the test I added just checks that PkgId::new parses the\nversion number out of a git repo's tags list, where relevant.", "tree": {"sha": "d4df37d69feb9d4b91ac39984b78b268fedbbaf0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d4df37d69feb9d4b91ac39984b78b268fedbbaf0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/53b83525521960b4ae6f9dc90b82429013346708", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/53b83525521960b4ae6f9dc90b82429013346708", "html_url": "https://github.com/rust-lang/rust/commit/53b83525521960b4ae6f9dc90b82429013346708", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/53b83525521960b4ae6f9dc90b82429013346708/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a014088da1c492f6d4238393e84d037f12cf1273", "url": "https://api.github.com/repos/rust-lang/rust/commits/a014088da1c492f6d4238393e84d037f12cf1273", "html_url": "https://github.com/rust-lang/rust/commit/a014088da1c492f6d4238393e84d037f12cf1273"}], "stats": {"total": 239, "additions": 178, "deletions": 61}, "files": [{"sha": "9b05c848b6e32fbdddea5c71673f9a7a99ca0a79", "filename": "src/librustpkg/package_id.rs", "status": "modified", "additions": 9, "deletions": 60, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/53b83525521960b4ae6f9dc90b82429013346708/src%2Flibrustpkg%2Fpackage_id.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53b83525521960b4ae6f9dc90b82429013346708/src%2Flibrustpkg%2Fpackage_id.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fpackage_id.rs?ref=53b83525521960b4ae6f9dc90b82429013346708", "patch": "@@ -12,9 +12,8 @@ pub use package_path::{RemotePath, LocalPath, normalize, hash};\n use extra::semver;\n use core::prelude::*;\n use core::result;\n-\n-/// Placeholder\n-pub fn default_version() -> Version { ExactRevision(0.1) }\n+use core::prelude::*;\n+use version::{default_version, try_getting_version, Version};\n \n /// Path-fragment identifier of a package such as\n /// 'github.com/graydon/test'; path must be a relative\n@@ -49,11 +48,17 @@ impl PkgId {\n         let remote_path = RemotePath(p);\n         let local_path = normalize(copy remote_path);\n         let short_name = (copy local_path).filestem().expect(fmt!(\"Strange path! %s\", s));\n+\n+        let version = match try_getting_version(remote_path) {\n+            Some(v) => v,\n+            None => default_version()\n+        };\n+\n         PkgId {\n             local_path: local_path,\n             remote_path: remote_path,\n             short_name: short_name,\n-            version: default_version()\n+            version: version\n         }\n     }\n \n@@ -74,59 +79,3 @@ impl ToStr for PkgId {\n         fmt!(\"%s-%s\", self.local_path.to_str(), self.version.to_str())\n     }\n }\n-\n-/// A version is either an exact revision,\n-/// or a semantic version\n-pub enum Version {\n-    ExactRevision(float),\n-    SemVersion(semver::Version)\n-}\n-\n-\n-impl Ord for Version {\n-    fn lt(&self, other: &Version) -> bool {\n-        match (self, other) {\n-            (&ExactRevision(f1), &ExactRevision(f2)) => f1 < f2,\n-            (&SemVersion(ref v1), &SemVersion(ref v2)) => v1 < v2,\n-            _ => false // incomparable, really\n-        }\n-    }\n-    fn le(&self, other: &Version) -> bool {\n-        match (self, other) {\n-            (&ExactRevision(f1), &ExactRevision(f2)) => f1 <= f2,\n-            (&SemVersion(ref v1), &SemVersion(ref v2)) => v1 <= v2,\n-            _ => false // incomparable, really\n-        }\n-    }\n-    fn ge(&self, other: &Version) -> bool {\n-        match (self, other) {\n-            (&ExactRevision(f1), &ExactRevision(f2)) => f1 > f2,\n-            (&SemVersion(ref v1), &SemVersion(ref v2)) => v1 > v2,\n-            _ => false // incomparable, really\n-        }\n-    }\n-    fn gt(&self, other: &Version) -> bool {\n-        match (self, other) {\n-            (&ExactRevision(f1), &ExactRevision(f2)) => f1 >= f2,\n-            (&SemVersion(ref v1), &SemVersion(ref v2)) => v1 >= v2,\n-            _ => false // incomparable, really\n-        }\n-    }\n-\n-}\n-\n-impl ToStr for Version {\n-    fn to_str(&self) -> ~str {\n-        match *self {\n-            ExactRevision(ref n) => n.to_str(),\n-            SemVersion(ref v) => v.to_str()\n-        }\n-    }\n-}\n-\n-pub fn parse_vers(vers: ~str) -> result::Result<semver::Version, ~str> {\n-    match semver::parse(vers) {\n-        Some(vers) => result::Ok(vers),\n-        None => result::Err(~\"could not parse version: invalid\")\n-    }\n-}"}, {"sha": "8591251d4cd5f8973d78de09ff8828e6fc46fb78", "filename": "src/librustpkg/rustpkg.rc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/53b83525521960b4ae6f9dc90b82429013346708/src%2Flibrustpkg%2Frustpkg.rc", "raw_url": "https://github.com/rust-lang/rust/raw/53b83525521960b4ae6f9dc90b82429013346708/src%2Flibrustpkg%2Frustpkg.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Frustpkg.rc?ref=53b83525521960b4ae6f9dc90b82429013346708", "patch": "@@ -18,6 +18,7 @@\n #[license = \"MIT/ASL2\"];\n #[crate_type = \"lib\"];\n \n+#[no_core];\n #[no_std];\n \n extern mod core(name = \"std\");\n@@ -53,6 +54,7 @@ mod target;\n #[cfg(test)]\n mod tests;\n mod util;\n+mod version;\n mod workspace;\n \n pub mod usage;"}, {"sha": "e897f757ec229d30b5083f5bf750c26f51ff48bb", "filename": "src/librustpkg/tests.rs", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/53b83525521960b4ae6f9dc90b82429013346708/src%2Flibrustpkg%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53b83525521960b4ae6f9dc90b82429013346708/src%2Flibrustpkg%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Ftests.rs?ref=53b83525521960b4ae6f9dc90b82429013346708", "patch": "@@ -18,7 +18,8 @@ use core::prelude::*;\n use core::result;\n use extra::tempfile::mkdtemp;\n use package_path::*;\n-use package_id::{PkgId, default_version};\n+use package_id::PkgId;\n+use version::{default_version, ExactRevision};\n use path_util::{target_executable_in_workspace, target_library_in_workspace,\n                target_test_in_workspace, target_bench_in_workspace,\n                make_dir_rwx, u_rwx,\n@@ -53,6 +54,16 @@ fn remote_pkg() -> PkgId {\n     }\n }\n \n+fn remote_versioned_pkg() -> PkgId {\n+    let remote = RemotePath(Path(\"github.com/catamorphism/test_pkg_version\"));\n+    PkgId {\n+        local_path: normalize(copy remote),\n+        remote_path: remote,\n+        short_name: ~\"test_pkg_version\",\n+        version: default_version()\n+    }\n+}\n+\n fn writeFile(file_path: &Path, contents: &str) {\n     let out: @io::Writer =\n         result::get(&io::file_writer(file_path,\n@@ -242,3 +253,18 @@ fn test_package_ids_must_be_relative_path_like() {\n     }\n \n }\n+\n+#[test]\n+fn test_package_version() {\n+    let workspace = mkdtemp(&os::tmpdir(), \"test\").expect(\"couldn't create temp dir\");\n+    let sysroot = test_sysroot();\n+    debug!(\"sysroot = %s\", sysroot.to_str());\n+    let ctxt = fake_ctxt(Some(@sysroot));\n+    let temp_pkg_id = PkgId::new(\"github.com/catamorphism/test_pkg_version\");\n+    match temp_pkg_id.version {\n+        ExactRevision(0.2) => (),\n+        _ => fail!(fmt!(\"test_package_version: package version was %?, expected Some(0.2)\",\n+                        temp_pkg_id.version))\n+    }\n+    // also check that file paths are right\n+}"}, {"sha": "2de020970210da2dfac6a3541cbe5d9c38e8a431", "filename": "src/librustpkg/version.rs", "status": "added", "additions": 140, "deletions": 0, "changes": 140, "blob_url": "https://github.com/rust-lang/rust/blob/53b83525521960b4ae6f9dc90b82429013346708/src%2Flibrustpkg%2Fversion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/53b83525521960b4ae6f9dc90b82429013346708/src%2Flibrustpkg%2Fversion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustpkg%2Fversion.rs?ref=53b83525521960b4ae6f9dc90b82429013346708", "patch": "@@ -0,0 +1,140 @@\n+// Copyright 2013 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+/// A version is either an exact revision,\n+/// or a semantic version\n+\n+extern mod std;\n+\n+use std::semver;\n+use core::prelude::*;\n+use core::run;\n+use package_path::RemotePath;\n+use std::tempfile::mkdtemp;\n+\n+pub enum Version {\n+    ExactRevision(float),\n+    SemVersion(semver::Version)\n+}\n+\n+\n+impl Ord for Version {\n+    fn lt(&self, other: &Version) -> bool {\n+        match (self, other) {\n+            (&ExactRevision(f1), &ExactRevision(f2)) => f1 < f2,\n+            (&SemVersion(ref v1), &SemVersion(ref v2)) => v1 < v2,\n+            _ => false // incomparable, really\n+        }\n+    }\n+    fn le(&self, other: &Version) -> bool {\n+        match (self, other) {\n+            (&ExactRevision(f1), &ExactRevision(f2)) => f1 <= f2,\n+            (&SemVersion(ref v1), &SemVersion(ref v2)) => v1 <= v2,\n+            _ => false // incomparable, really\n+        }\n+    }\n+    fn ge(&self, other: &Version) -> bool {\n+        match (self, other) {\n+            (&ExactRevision(f1), &ExactRevision(f2)) => f1 > f2,\n+            (&SemVersion(ref v1), &SemVersion(ref v2)) => v1 > v2,\n+            _ => false // incomparable, really\n+        }\n+    }\n+    fn gt(&self, other: &Version) -> bool {\n+        match (self, other) {\n+            (&ExactRevision(f1), &ExactRevision(f2)) => f1 >= f2,\n+            (&SemVersion(ref v1), &SemVersion(ref v2)) => v1 >= v2,\n+            _ => false // incomparable, really\n+        }\n+    }\n+\n+}\n+\n+impl ToStr for Version {\n+    fn to_str(&self) -> ~str {\n+        match *self {\n+            ExactRevision(ref n) => n.to_str(),\n+            SemVersion(ref v) => v.to_str()\n+        }\n+    }\n+}\n+\n+pub fn parse_vers(vers: ~str) -> result::Result<semver::Version, ~str> {\n+    match semver::parse(vers) {\n+        Some(vers) => result::Ok(vers),\n+        None => result::Err(~\"could not parse version: invalid\")\n+    }\n+}\n+\n+\n+/// If `remote_path` refers to a git repo that can be downloaded,\n+/// and the most recent tag in that repo denotes a version, return it;\n+/// otherwise, `None`\n+pub fn try_getting_version(remote_path: &RemotePath) -> Option<Version> {\n+    debug!(\"try_getting_version: %s\", remote_path.to_str());\n+    if is_url_like(remote_path) {\n+        debug!(\"Trying to fetch its sources..\");\n+        let tmp_dir = mkdtemp(&os::tmpdir(),\n+                              \"test\").expect(\"try_getting_version: couldn't create temp dir\");\n+        debug!(\"executing {git clone https://%s %s}\", remote_path.to_str(), tmp_dir.to_str());\n+        let outp  = run::process_output(\"git\", [~\"clone\", fmt!(\"https://%s\", remote_path.to_str()),\n+                                                tmp_dir.to_str()]);\n+        if outp.status == 0 {\n+            debug!(\"Cloned it... ( %s, %s )\", str::from_bytes(outp.output), str::from_bytes(outp.error));\n+            let mut output = None;\n+            debug!(\"executing {git --git-dir=%s tag -l}\", tmp_dir.push(\".git\").to_str());\n+            let outp = run::process_output(\"git\", [fmt!(\"--git-dir=%s\", tmp_dir.push(\".git\").to_str()),\n+                                                           ~\"tag\", ~\"-l\"]);\n+            let output_text = str::from_bytes(outp.output);\n+            debug!(\"Full output: ( %s ) [%?]\", output_text, outp.status);\n+            for output_text.each_split_char('\\n') |l| {\n+                debug!(\"A line of output: %s\", l);\n+                if !l.is_whitespace() {\n+                    output = Some(l);\n+                }\n+            }\n+\n+            output.chain(try_parsing_version)\n+        }\n+        else {\n+            None\n+        }\n+    }\n+    else {\n+        None\n+    }\n+}\n+    \n+fn try_parsing_version(s: &str) -> Option<Version> {\n+    let s = s.trim();\n+    debug!(\"Attempting to parse: %s\", s);\n+    match float::from_str(s) {\n+        Some(f) => {\n+            debug!(\"%s -> %f\", s, f);\n+            Some(ExactRevision(f)) // semver not handled yet\n+        }\n+        None => {\n+            debug!(\"None!!\");\n+            None\n+        }\n+    }\n+}\n+\n+/// Placeholder\n+pub fn default_version() -> Version { ExactRevision(0.1) }\n+\n+/// Just an approximation\n+fn is_url_like(p: &RemotePath) -> bool {\n+    let mut n = 0;\n+    for p.to_str().each_split_char('/') |_| {\n+        n += 1;\n+    }\n+    n > 2\n+}\n\\ No newline at end of file"}]}