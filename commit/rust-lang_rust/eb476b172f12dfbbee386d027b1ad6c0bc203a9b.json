{"sha": "eb476b172f12dfbbee386d027b1ad6c0bc203a9b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmViNDc2YjE3MmYxMmRmYmJlZTM4NmQwMjdiMWFkNmMwYmMyMDNhOWI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-08T22:53:20Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-03-08T22:53:20Z"}, "message": "Auto merge of #82877 - ehuss:revert-rwlock, r=m-ou-se\n\nRevert switch of env locking to rwlock, to fix deadlock in process spawning\n\nThis reverts commit 354f19cf2475148994954b6783341620c7445071, reversing changes made to 0cfba2fd090834c909d5ed9deccdee8170da791b.\n\nPR https://github.com/rust-lang/rust/pull/81850 switched the environment lock from a mutex to an rwlock. However, process spawning (when not able to use `posix_spawn`) locks the environment before forking, and unlocks it after forking (in both the parent and the child). With a mutex, this works (although probably not correct even with a mutex). With an rwlock, on at least some targets, unlocking in the child does not work correctly, resulting in a deadlock.\n\nThis has manifested as CI hangs on i686 Linux; that target doesn't use `posix_spawn` in the CI environment due to the age of the installed C library (currently glibc 2.23). (Switching to `posix_spawn` would just mask this issue, though, which would still arise in any case that can't use `posix_spawn`.)\n\nSome additional cleanup of environment handling around process spawning may help, but for now, revert the PR and go back to a standard mutex.\n\nFixes #82221", "tree": {"sha": "7e55d5d064b5c24f8cbbf4a58b11472f297a4406", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/7e55d5d064b5c24f8cbbf4a58b11472f297a4406"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/eb476b172f12dfbbee386d027b1ad6c0bc203a9b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/eb476b172f12dfbbee386d027b1ad6c0bc203a9b", "html_url": "https://github.com/rust-lang/rust/commit/eb476b172f12dfbbee386d027b1ad6c0bc203a9b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/eb476b172f12dfbbee386d027b1ad6c0bc203a9b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8f349be27815d43d462a32faeb270a22a68486b6", "url": "https://api.github.com/repos/rust-lang/rust/commits/8f349be27815d43d462a32faeb270a22a68486b6", "html_url": "https://github.com/rust-lang/rust/commit/8f349be27815d43d462a32faeb270a22a68486b6"}, {"sha": "acdca316c3d42299d31c1b47eb792006ffdfc29c", "url": "https://api.github.com/repos/rust-lang/rust/commits/acdca316c3d42299d31c1b47eb792006ffdfc29c", "html_url": "https://github.com/rust-lang/rust/commit/acdca316c3d42299d31c1b47eb792006ffdfc29c"}], "stats": {"total": 84, "additions": 12, "deletions": 72}, "files": [{"sha": "d5e14bec7657298e2d4ced4951a300c5fa81ab51", "filename": "library/std/src/sys/unix/os.rs", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/eb476b172f12dfbbee386d027b1ad6c0bc203a9b/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb476b172f12dfbbee386d027b1ad6c0bc203a9b/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fos.rs?ref=eb476b172f12dfbbee386d027b1ad6c0bc203a9b", "patch": "@@ -22,7 +22,6 @@ use crate::str;\n use crate::sys::cvt;\n use crate::sys::fd;\n use crate::sys_common::mutex::{StaticMutex, StaticMutexGuard};\n-use crate::sys_common::rwlock::{RWLockReadGuard, StaticRWLock};\n use crate::vec;\n \n use libc::{c_char, c_int, c_void};\n@@ -491,20 +490,20 @@ pub unsafe fn environ() -> *mut *const *const c_char {\n     extern \"C\" {\n         static mut environ: *const *const c_char;\n     }\n-    ptr::addr_of_mut!(environ)\n+    &mut environ\n }\n \n-static ENV_LOCK: StaticRWLock = StaticRWLock::new();\n-\n-pub fn env_read_lock() -> RWLockReadGuard {\n-    ENV_LOCK.read_with_guard()\n+pub unsafe fn env_lock() -> StaticMutexGuard {\n+    // It is UB to attempt to acquire this mutex reentrantly!\n+    static ENV_LOCK: StaticMutex = StaticMutex::new();\n+    ENV_LOCK.lock()\n }\n \n /// Returns a vector of (variable, value) byte-vector pairs for all the\n /// environment variables of the current process.\n pub fn env() -> Env {\n     unsafe {\n-        let _guard = env_read_lock();\n+        let _guard = env_lock();\n         let mut environ = *environ();\n         let mut result = Vec::new();\n         if !environ.is_null() {\n@@ -541,7 +540,7 @@ pub fn getenv(k: &OsStr) -> io::Result<Option<OsString>> {\n     // always None as well\n     let k = CString::new(k.as_bytes())?;\n     unsafe {\n-        let _guard = env_read_lock();\n+        let _guard = env_lock();\n         let s = libc::getenv(k.as_ptr()) as *const libc::c_char;\n         let ret = if s.is_null() {\n             None\n@@ -557,7 +556,7 @@ pub fn setenv(k: &OsStr, v: &OsStr) -> io::Result<()> {\n     let v = CString::new(v.as_bytes())?;\n \n     unsafe {\n-        let _guard = ENV_LOCK.write_with_guard();\n+        let _guard = env_lock();\n         cvt(libc::setenv(k.as_ptr(), v.as_ptr(), 1)).map(drop)\n     }\n }\n@@ -566,7 +565,7 @@ pub fn unsetenv(n: &OsStr) -> io::Result<()> {\n     let nbuf = CString::new(n.as_bytes())?;\n \n     unsafe {\n-        let _guard = ENV_LOCK.write_with_guard();\n+        let _guard = env_lock();\n         cvt(libc::unsetenv(nbuf.as_ptr())).map(drop)\n     }\n }"}, {"sha": "2746f87468dca3f2d4f35dfd3949c6007d2d9f0e", "filename": "library/std/src/sys/unix/process/process_unix.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/eb476b172f12dfbbee386d027b1ad6c0bc203a9b/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb476b172f12dfbbee386d027b1ad6c0bc203a9b/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs?ref=eb476b172f12dfbbee386d027b1ad6c0bc203a9b", "patch": "@@ -47,7 +47,7 @@ impl Command {\n         // a lock any more because the parent won't do anything and the child is\n         // in its own process.\n         let result = unsafe {\n-            let _env_lock = sys::os::env_read_lock();\n+            let _env_lock = sys::os::env_lock();\n             cvt(libc::fork())?\n         };\n \n@@ -124,7 +124,7 @@ impl Command {\n                     // Similar to when forking, we want to ensure that access to\n                     // the environment is synchronized, so make sure to grab the\n                     // environment lock before we try to exec.\n-                    let _lock = sys::os::env_read_lock();\n+                    let _lock = sys::os::env_lock();\n \n                     let Err(e) = self.do_exec(theirs, envp.as_ref());\n                     e\n@@ -404,7 +404,7 @@ impl Command {\n             cvt_nz(libc::posix_spawnattr_setflags(attrs.0.as_mut_ptr(), flags as _))?;\n \n             // Make sure we synchronize access to the global `environ` resource\n-            let _env_lock = sys::os::env_read_lock();\n+            let _env_lock = sys::os::env_lock();\n             let envp = envp.map(|c| c.as_ptr()).unwrap_or_else(|| *sys::os::environ() as *const _);\n             cvt_nz(libc::posix_spawnp(\n                 &mut p.pid,"}, {"sha": "3705d641a1be646ab38436b8aaed032a6ef3e312", "filename": "library/std/src/sys_common/rwlock.rs", "status": "modified", "additions": 0, "deletions": 59, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/eb476b172f12dfbbee386d027b1ad6c0bc203a9b/library%2Fstd%2Fsrc%2Fsys_common%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/eb476b172f12dfbbee386d027b1ad6c0bc203a9b/library%2Fstd%2Fsrc%2Fsys_common%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fstd%2Fsrc%2Fsys_common%2Frwlock.rs?ref=eb476b172f12dfbbee386d027b1ad6c0bc203a9b", "patch": "@@ -86,62 +86,3 @@ impl RWLock {\n         self.0.destroy()\n     }\n }\n-\n-// the cfg annotations only exist due to dead code warnings. the code itself is portable\n-#[cfg(unix)]\n-pub struct StaticRWLock(RWLock);\n-\n-#[cfg(unix)]\n-impl StaticRWLock {\n-    pub const fn new() -> StaticRWLock {\n-        StaticRWLock(RWLock::new())\n-    }\n-\n-    /// Acquires shared access to the underlying lock, blocking the current\n-    /// thread to do so.\n-    ///\n-    /// The lock is automatically unlocked when the returned guard is dropped.\n-    #[inline]\n-    pub fn read_with_guard(&'static self) -> RWLockReadGuard {\n-        // SAFETY: All methods require static references, therefore self\n-        // cannot be moved between invocations.\n-        unsafe {\n-            self.0.read();\n-        }\n-        RWLockReadGuard(&self.0)\n-    }\n-\n-    /// Acquires write access to the underlying lock, blocking the current thread\n-    /// to do so.\n-    ///\n-    /// The lock is automatically unlocked when the returned guard is dropped.\n-    #[inline]\n-    pub fn write_with_guard(&'static self) -> RWLockWriteGuard {\n-        // SAFETY: All methods require static references, therefore self\n-        // cannot be moved between invocations.\n-        unsafe {\n-            self.0.write();\n-        }\n-        RWLockWriteGuard(&self.0)\n-    }\n-}\n-\n-#[cfg(unix)]\n-pub struct RWLockReadGuard(&'static RWLock);\n-\n-#[cfg(unix)]\n-impl Drop for RWLockReadGuard {\n-    fn drop(&mut self) {\n-        unsafe { self.0.read_unlock() }\n-    }\n-}\n-\n-#[cfg(unix)]\n-pub struct RWLockWriteGuard(&'static RWLock);\n-\n-#[cfg(unix)]\n-impl Drop for RWLockWriteGuard {\n-    fn drop(&mut self) {\n-        unsafe { self.0.write_unlock() }\n-    }\n-}"}]}