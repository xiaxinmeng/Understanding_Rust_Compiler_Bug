{"sha": "a0245bb3cb51c0e9a19c20abac6473da446832e0", "node_id": "C_kwDOAAsO6NoAKGEwMjQ1YmIzY2I1MWMwZTlhMTljMjBhYmFjNjQ3M2RhNDQ2ODMyZTA", "commit": {"author": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2023-05-23T16:56:25Z"}, "committer": {"name": "lcnr", "email": "rust@lcnr.de", "date": "2023-05-30T11:03:38Z"}, "message": "rework the leak_check to take the outer_universe\n\nclean up coherence to not rely on probes anymore", "tree": {"sha": "a1f1a0a2f524ad23a6fb28f2ec7c076f1729aafe", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a1f1a0a2f524ad23a6fb28f2ec7c076f1729aafe"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/a0245bb3cb51c0e9a19c20abac6473da446832e0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/a0245bb3cb51c0e9a19c20abac6473da446832e0", "html_url": "https://github.com/rust-lang/rust/commit/a0245bb3cb51c0e9a19c20abac6473da446832e0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/a0245bb3cb51c0e9a19c20abac6473da446832e0/comments", "author": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lcnr", "id": 29864074, "node_id": "MDQ6VXNlcjI5ODY0MDc0", "avatar_url": "https://avatars.githubusercontent.com/u/29864074?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lcnr", "html_url": "https://github.com/lcnr", "followers_url": "https://api.github.com/users/lcnr/followers", "following_url": "https://api.github.com/users/lcnr/following{/other_user}", "gists_url": "https://api.github.com/users/lcnr/gists{/gist_id}", "starred_url": "https://api.github.com/users/lcnr/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lcnr/subscriptions", "organizations_url": "https://api.github.com/users/lcnr/orgs", "repos_url": "https://api.github.com/users/lcnr/repos", "events_url": "https://api.github.com/users/lcnr/events{/privacy}", "received_events_url": "https://api.github.com/users/lcnr/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "2a4467da9f82a8d7be9b8c9f575a64b9a2df5961", "url": "https://api.github.com/repos/rust-lang/rust/commits/2a4467da9f82a8d7be9b8c9f575a64b9a2df5961", "html_url": "https://github.com/rust-lang/rust/commit/2a4467da9f82a8d7be9b8c9f575a64b9a2df5961"}], "stats": {"total": 344, "additions": 178, "deletions": 166}, "files": [{"sha": "905781ec8f59412b337766d5c0cdae819bc83956", "filename": "compiler/rustc_hir_typeck/src/coercion.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/a0245bb3cb51c0e9a19c20abac6473da446832e0/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0245bb3cb51c0e9a19c20abac6473da446832e0/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fcoercion.rs?ref=a0245bb3cb51c0e9a19c20abac6473da446832e0", "patch": "@@ -808,6 +808,8 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         G: FnOnce(Ty<'tcx>) -> Vec<Adjustment<'tcx>>,\n     {\n         self.commit_if_ok(|snapshot| {\n+            let outer_universe = self.infcx.universe();\n+\n             let result = if let ty::FnPtr(fn_ty_b) = b.kind()\n                 && let (hir::Unsafety::Normal, hir::Unsafety::Unsafe) =\n                     (fn_ty_a.unsafety(), fn_ty_b.unsafety())\n@@ -824,7 +826,7 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n             // want the coerced type to be the actual supertype of these two,\n             // but for now, we want to just error to ensure we don't lock\n             // ourselves into a specific behavior with NLL.\n-            self.leak_check(snapshot)?;\n+            self.leak_check(outer_universe, Some(snapshot))?;\n \n             result\n         })"}, {"sha": "6b2dd0a2b4fed91c3b61def480e3d13b9bf01712", "filename": "compiler/rustc_infer/src/infer/at.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a0245bb3cb51c0e9a19c20abac6473da446832e0/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0245bb3cb51c0e9a19c20abac6473da446832e0/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fat.rs?ref=a0245bb3cb51c0e9a19c20abac6473da446832e0", "patch": "@@ -70,8 +70,8 @@ impl<'tcx> InferCtxt<'tcx> {\n             tcx: self.tcx,\n             defining_use_anchor: self.defining_use_anchor,\n             considering_regions: self.considering_regions,\n+            skip_leak_check: self.skip_leak_check,\n             inner: self.inner.clone(),\n-            skip_leak_check: self.skip_leak_check.clone(),\n             lexical_region_resolutions: self.lexical_region_resolutions.clone(),\n             selection_cache: self.selection_cache.clone(),\n             evaluation_cache: self.evaluation_cache.clone(),"}, {"sha": "974bc2f1153d288021d226db06c23551feb540b3", "filename": "compiler/rustc_infer/src/infer/higher_ranked/mod.rs", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/a0245bb3cb51c0e9a19c20abac6473da446832e0/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fhigher_ranked%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0245bb3cb51c0e9a19c20abac6473da446832e0/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fhigher_ranked%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fhigher_ranked%2Fmod.rs?ref=a0245bb3cb51c0e9a19c20abac6473da446832e0", "patch": "@@ -105,24 +105,31 @@ impl<'tcx> InferCtxt<'tcx> {\n         self.tcx.replace_bound_vars_uncached(binder, delegate)\n     }\n \n-    /// See [RegionConstraintCollector::leak_check][1].\n+    /// See [RegionConstraintCollector::leak_check][1]. We only check placeholder\n+    /// leaking into `outer_universe`, i.e. placeholders which cannot be named by that\n+    /// universe.\n     ///\n     /// [1]: crate::infer::region_constraints::RegionConstraintCollector::leak_check\n-    pub fn leak_check(&self, snapshot: &CombinedSnapshot<'tcx>) -> RelateResult<'tcx, ()> {\n+    pub fn leak_check(\n+        &self,\n+        outer_universe: ty::UniverseIndex,\n+        only_consider_snapshot: Option<&CombinedSnapshot<'tcx>>,\n+    ) -> RelateResult<'tcx, ()> {\n         // If the user gave `-Zno-leak-check`, or we have been\n         // configured to skip the leak check, then skip the leak check\n         // completely. The leak check is deprecated. Any legitimate\n         // subtyping errors that it would have caught will now be\n         // caught later on, during region checking. However, we\n         // continue to use it for a transition period.\n-        if self.tcx.sess.opts.unstable_opts.no_leak_check || self.skip_leak_check.get() {\n+        if self.tcx.sess.opts.unstable_opts.no_leak_check || self.skip_leak_check {\n             return Ok(());\n         }\n \n         self.inner.borrow_mut().unwrap_region_constraints().leak_check(\n             self.tcx,\n+            outer_universe,\n             self.universe(),\n-            snapshot,\n+            only_consider_snapshot,\n         )\n     }\n }"}, {"sha": "447d4c9f84bc057cd80be8fe188095f3bc7ecdd7", "filename": "compiler/rustc_infer/src/infer/mod.rs", "status": "modified", "additions": 22, "deletions": 33, "changes": 55, "blob_url": "https://github.com/rust-lang/rust/blob/a0245bb3cb51c0e9a19c20abac6473da446832e0/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0245bb3cb51c0e9a19c20abac6473da446832e0/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fmod.rs?ref=a0245bb3cb51c0e9a19c20abac6473da446832e0", "patch": "@@ -251,14 +251,13 @@ pub struct InferCtxt<'tcx> {\n     /// solving is left to borrowck instead.\n     pub considering_regions: bool,\n \n-    pub inner: RefCell<InferCtxtInner<'tcx>>,\n-\n     /// If set, this flag causes us to skip the 'leak check' during\n     /// higher-ranked subtyping operations. This flag is a temporary one used\n     /// to manage the removal of the leak-check: for the time being, we still run the\n-    /// leak-check, but we issue warnings. This flag can only be set to true\n-    /// when entering a snapshot.\n-    skip_leak_check: Cell<bool>,\n+    /// leak-check, but we issue warnings.\n+    skip_leak_check: bool,\n+\n+    pub inner: RefCell<InferCtxtInner<'tcx>>,\n \n     /// Once region inference is done, the values for each variable.\n     lexical_region_resolutions: RefCell<Option<LexicalRegionResolutions<'tcx>>>,\n@@ -543,6 +542,7 @@ pub struct InferCtxtBuilder<'tcx> {\n     tcx: TyCtxt<'tcx>,\n     defining_use_anchor: DefiningAnchor,\n     considering_regions: bool,\n+    skip_leak_check: bool,\n     /// Whether we are in coherence mode.\n     intercrate: bool,\n }\n@@ -557,6 +557,7 @@ impl<'tcx> TyCtxtInferExt<'tcx> for TyCtxt<'tcx> {\n             tcx: self,\n             defining_use_anchor: DefiningAnchor::Error,\n             considering_regions: true,\n+            skip_leak_check: false,\n             intercrate: false,\n         }\n     }\n@@ -584,6 +585,11 @@ impl<'tcx> InferCtxtBuilder<'tcx> {\n         self\n     }\n \n+    pub fn skip_leak_check(mut self, skip_leak_check: bool) -> Self {\n+        self.skip_leak_check = skip_leak_check;\n+        self\n+    }\n+\n     /// Given a canonical value `C` as a starting point, create an\n     /// inference context that contains each of the bound values\n     /// within instantiated as a fresh variable. The `f` closure is\n@@ -605,11 +611,18 @@ impl<'tcx> InferCtxtBuilder<'tcx> {\n     }\n \n     pub fn build(&mut self) -> InferCtxt<'tcx> {\n-        let InferCtxtBuilder { tcx, defining_use_anchor, considering_regions, intercrate } = *self;\n+        let InferCtxtBuilder {\n+            tcx,\n+            defining_use_anchor,\n+            considering_regions,\n+            skip_leak_check,\n+            intercrate,\n+        } = *self;\n         InferCtxt {\n             tcx,\n             defining_use_anchor,\n             considering_regions,\n+            skip_leak_check,\n             inner: RefCell::new(InferCtxtInner::new()),\n             lexical_region_resolutions: RefCell::new(None),\n             selection_cache: Default::default(),\n@@ -619,7 +632,6 @@ impl<'tcx> InferCtxtBuilder<'tcx> {\n             tainted_by_errors: Cell::new(None),\n             err_count_on_creation: tcx.sess.err_count(),\n             in_snapshot: Cell::new(false),\n-            skip_leak_check: Cell::new(false),\n             universe: Cell::new(ty::UniverseIndex::ROOT),\n             intercrate,\n         }\n@@ -815,32 +827,9 @@ impl<'tcx> InferCtxt<'tcx> {\n         r\n     }\n \n-    /// If `should_skip` is true, then execute `f` then unroll any bindings it creates.\n-    #[instrument(skip(self, f), level = \"debug\")]\n-    pub fn probe_maybe_skip_leak_check<R, F>(&self, should_skip: bool, f: F) -> R\n-    where\n-        F: FnOnce(&CombinedSnapshot<'tcx>) -> R,\n-    {\n-        let snapshot = self.start_snapshot();\n-        let was_skip_leak_check = self.skip_leak_check.get();\n-        if should_skip {\n-            self.skip_leak_check.set(true);\n-        }\n-        let r = f(&snapshot);\n-        self.rollback_to(\"probe\", snapshot);\n-        self.skip_leak_check.set(was_skip_leak_check);\n-        r\n-    }\n-\n-    /// Scan the constraints produced since `snapshot` began and returns:\n-    ///\n-    /// - `None` -- if none of them involves \"region outlives\" constraints.\n-    /// - `Some(true)` -- if there are `'a: 'b` constraints where `'a` or `'b` is a placeholder.\n-    /// - `Some(false)` -- if there are `'a: 'b` constraints but none involve placeholders.\n-    pub fn region_constraints_added_in_snapshot(\n-        &self,\n-        snapshot: &CombinedSnapshot<'tcx>,\n-    ) -> Option<bool> {\n+    /// Scan the constraints produced since `snapshot` and check whether\n+    /// we added any region constraints.\n+    pub fn region_constraints_added_in_snapshot(&self, snapshot: &CombinedSnapshot<'tcx>) -> bool {\n         self.inner\n             .borrow_mut()\n             .unwrap_region_constraints()"}, {"sha": "dd65f66ccd14098931cf5f3e91cbb9a367e80eeb", "filename": "compiler/rustc_infer/src/infer/region_constraints/leak_check.rs", "status": "modified", "additions": 69, "deletions": 56, "changes": 125, "blob_url": "https://github.com/rust-lang/rust/blob/a0245bb3cb51c0e9a19c20abac6473da446832e0/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fleak_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0245bb3cb51c0e9a19c20abac6473da446832e0/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fleak_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fleak_check.rs?ref=a0245bb3cb51c0e9a19c20abac6473da446832e0", "patch": "@@ -3,7 +3,6 @@ use crate::infer::CombinedSnapshot;\n use rustc_data_structures::{\n     fx::FxIndexMap,\n     graph::{scc::Sccs, vec_graph::VecGraph},\n-    undo_log::UndoLogs,\n };\n use rustc_index::Idx;\n use rustc_middle::ty::error::TypeError;\n@@ -13,7 +12,9 @@ impl<'tcx> RegionConstraintCollector<'_, 'tcx> {\n     /// Searches new universes created during `snapshot`, looking for\n     /// placeholders that may \"leak\" out from the universes they are contained\n     /// in. If any leaking placeholders are found, then an `Err` is returned\n-    /// (typically leading to the snapshot being reversed).\n+    /// (typically leading to the snapshot being reversed). This algorithm\n+    /// only looks at placeholders which cannot be named by `outer_universe`,\n+    /// as this is the universe we're currently checking for a leak.\n     ///\n     /// The leak check *used* to be the only way we had to handle higher-ranked\n     /// obligations. Now that we have integrated universes into the region\n@@ -55,36 +56,34 @@ impl<'tcx> RegionConstraintCollector<'_, 'tcx> {\n     ///   * if they must also be equal to a placeholder P, and U cannot name P, report an error, as that\n     ///     indicates `P: R` and `R` is in an incompatible universe\n     ///\n+    /// To improve performance and for the old trait solver caching to be sound, this takes\n+    /// an optional snapshot in which case we only look at region constraints added in that\n+    /// snapshot. If we were to not do that the `leak_check` during evaluation can rely on\n+    /// region constraints added outside of that evaluation. As that is not reflected in the\n+    /// cache key this would be unsound.\n+    ///\n     /// # Historical note\n     ///\n     /// Older variants of the leak check used to report errors for these\n     /// patterns, but we no longer do:\n     ///\n     /// * R: P1, even if R cannot name P1, because R = 'static is a valid sol'n\n     /// * R: P1, R: P2, as above\n+    #[instrument(level = \"debug\", skip(self, tcx, only_consider_snapshot), ret)]\n     pub fn leak_check(\n         &mut self,\n         tcx: TyCtxt<'tcx>,\n+        outer_universe: ty::UniverseIndex,\n         max_universe: ty::UniverseIndex,\n-        snapshot: &CombinedSnapshot<'tcx>,\n+        only_consider_snapshot: Option<&CombinedSnapshot<'tcx>>,\n     ) -> RelateResult<'tcx, ()> {\n-        debug!(\n-            \"leak_check(max_universe={:?}, snapshot.universe={:?})\",\n-            max_universe, snapshot.universe\n-        );\n-\n-        assert!(UndoLogs::<super::UndoLog<'_>>::in_snapshot(&self.undo_log));\n-\n-        let universe_at_start_of_snapshot = snapshot.universe;\n-        if universe_at_start_of_snapshot == max_universe {\n+        if outer_universe == max_universe {\n             return Ok(());\n         }\n \n-        let mini_graph =\n-            &MiniGraph::new(tcx, self.undo_log.region_constraints(), &self.storage.data.verifys);\n+        let mini_graph = &MiniGraph::new(tcx, &self, only_consider_snapshot);\n \n-        let mut leak_check =\n-            LeakCheck::new(tcx, universe_at_start_of_snapshot, max_universe, mini_graph, self);\n+        let mut leak_check = LeakCheck::new(tcx, outer_universe, max_universe, mini_graph, self);\n         leak_check.assign_placeholder_values()?;\n         leak_check.propagate_scc_value()?;\n         Ok(())\n@@ -93,7 +92,7 @@ impl<'tcx> RegionConstraintCollector<'_, 'tcx> {\n \n struct LeakCheck<'me, 'tcx> {\n     tcx: TyCtxt<'tcx>,\n-    universe_at_start_of_snapshot: ty::UniverseIndex,\n+    outer_universe: ty::UniverseIndex,\n     mini_graph: &'me MiniGraph<'tcx>,\n     rcc: &'me RegionConstraintCollector<'me, 'tcx>,\n \n@@ -121,15 +120,15 @@ struct LeakCheck<'me, 'tcx> {\n impl<'me, 'tcx> LeakCheck<'me, 'tcx> {\n     fn new(\n         tcx: TyCtxt<'tcx>,\n-        universe_at_start_of_snapshot: ty::UniverseIndex,\n+        outer_universe: ty::UniverseIndex,\n         max_universe: ty::UniverseIndex,\n         mini_graph: &'me MiniGraph<'tcx>,\n         rcc: &'me RegionConstraintCollector<'me, 'tcx>,\n     ) -> Self {\n         let dummy_scc_universe = SccUniverse { universe: max_universe, region: None };\n         Self {\n             tcx,\n-            universe_at_start_of_snapshot,\n+            outer_universe,\n             mini_graph,\n             rcc,\n             scc_placeholders: IndexVec::from_elem_n(None, mini_graph.sccs.num_sccs()),\n@@ -154,7 +153,7 @@ impl<'me, 'tcx> LeakCheck<'me, 'tcx> {\n \n             // Detect those SCCs that directly contain a placeholder\n             if let ty::RePlaceholder(placeholder) = **region {\n-                if self.universe_at_start_of_snapshot.cannot_name(placeholder.universe) {\n+                if self.outer_universe.cannot_name(placeholder.universe) {\n                     self.assign_scc_value(scc, placeholder)?;\n                 }\n             }\n@@ -364,56 +363,70 @@ struct MiniGraph<'tcx> {\n }\n \n impl<'tcx> MiniGraph<'tcx> {\n-    fn new<'a>(\n+    fn new(\n         tcx: TyCtxt<'tcx>,\n-        undo_log: impl Iterator<Item = &'a UndoLog<'tcx>>,\n-        verifys: &[Verify<'tcx>],\n-    ) -> Self\n-    where\n-        'tcx: 'a,\n-    {\n+        region_constraints: &RegionConstraintCollector<'_, 'tcx>,\n+        only_consider_snapshot: Option<&CombinedSnapshot<'tcx>>,\n+    ) -> Self {\n         let mut nodes = FxIndexMap::default();\n         let mut edges = Vec::new();\n \n         // Note that if `R2: R1`, we get a callback `r1, r2`, so `target` is first parameter.\n-        Self::iterate_undo_log(tcx, undo_log, verifys, |target, source| {\n-            let source_node = Self::add_node(&mut nodes, source);\n-            let target_node = Self::add_node(&mut nodes, target);\n-            edges.push((source_node, target_node));\n-        });\n+        Self::iterate_region_constraints(\n+            tcx,\n+            region_constraints,\n+            only_consider_snapshot,\n+            |target, source| {\n+                let source_node = Self::add_node(&mut nodes, source);\n+                let target_node = Self::add_node(&mut nodes, target);\n+                edges.push((source_node, target_node));\n+            },\n+        );\n         let graph = VecGraph::new(nodes.len(), edges);\n         let sccs = Sccs::new(&graph);\n         Self { nodes, sccs }\n     }\n \n     /// Invokes `each_edge(R1, R2)` for each edge where `R2: R1`\n-    fn iterate_undo_log<'a>(\n+    fn iterate_region_constraints(\n         tcx: TyCtxt<'tcx>,\n-        undo_log: impl Iterator<Item = &'a UndoLog<'tcx>>,\n-        verifys: &[Verify<'tcx>],\n+        region_constraints: &RegionConstraintCollector<'_, 'tcx>,\n+        only_consider_snapshot: Option<&CombinedSnapshot<'tcx>>,\n         mut each_edge: impl FnMut(ty::Region<'tcx>, ty::Region<'tcx>),\n-    ) where\n-        'tcx: 'a,\n-    {\n-        for undo_entry in undo_log {\n-            match undo_entry {\n-                &AddConstraint(Constraint::VarSubVar(a, b)) => {\n-                    each_edge(ty::Region::new_var(tcx, a), ty::Region::new_var(tcx, b));\n-                }\n-                &AddConstraint(Constraint::RegSubVar(a, b)) => {\n-                    each_edge(a, ty::Region::new_var(tcx, b));\n-                }\n-                &AddConstraint(Constraint::VarSubReg(a, b)) => {\n-                    each_edge(ty::Region::new_var(tcx, a), b);\n-                }\n-                &AddConstraint(Constraint::RegSubReg(a, b)) => {\n-                    each_edge(a, b);\n+    ) {\n+        let mut each_constraint = |constraint| match constraint {\n+            &Constraint::VarSubVar(a, b) => {\n+                each_edge(ty::Region::new_var(tcx, a), ty::Region::new_var(tcx, b));\n+            }\n+            &Constraint::RegSubVar(a, b) => {\n+                each_edge(a, ty::Region::new_var(tcx, b));\n+            }\n+            &Constraint::VarSubReg(a, b) => {\n+                each_edge(ty::Region::new_var(tcx, a), b);\n+            }\n+            &Constraint::RegSubReg(a, b) => {\n+                each_edge(a, b);\n+            }\n+        };\n+\n+        if let Some(snapshot) = only_consider_snapshot {\n+            for undo_entry in\n+                region_constraints.undo_log.region_constraints_in_snapshot(&snapshot.undo_snapshot)\n+            {\n+                match undo_entry {\n+                    AddConstraint(constraint) => {\n+                        each_constraint(constraint);\n+                    }\n+                    &AddVerify(i) => span_bug!(\n+                        region_constraints.data().verifys[i].origin.span(),\n+                        \"we never add verifications while doing higher-ranked things\",\n+                    ),\n+                    &AddCombination(..) | &AddVar(..) => {}\n                 }\n-                &AddVerify(i) => span_bug!(\n-                    verifys[i].origin.span(),\n-                    \"we never add verifications while doing higher-ranked things\",\n-                ),\n-                &AddCombination(..) | &AddVar(..) => {}\n+            }\n+        } else {\n+            for (constraint, _origin) in &region_constraints.data().constraints {\n+                each_constraint(constraint)\n             }\n         }\n     }"}, {"sha": "613da8a0b4576b6de9b2d401a274d35a28af77b4", "filename": "compiler/rustc_infer/src/infer/region_constraints/mod.rs", "status": "modified", "additions": 3, "deletions": 8, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/a0245bb3cb51c0e9a19c20abac6473da446832e0/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0245bb3cb51c0e9a19c20abac6473da446832e0/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fregion_constraints%2Fmod.rs?ref=a0245bb3cb51c0e9a19c20abac6473da446832e0", "patch": "@@ -400,7 +400,7 @@ impl<'tcx> RegionConstraintCollector<'_, 'tcx> {\n         data\n     }\n \n-    pub(super) fn data(&self) -> &RegionConstraintData<'tcx> {\n+    pub fn data(&self) -> &RegionConstraintData<'tcx> {\n         &self.data\n     }\n \n@@ -683,15 +683,10 @@ impl<'tcx> RegionConstraintCollector<'_, 'tcx> {\n     }\n \n     /// See `InferCtxt::region_constraints_added_in_snapshot`.\n-    pub fn region_constraints_added_in_snapshot(&self, mark: &Snapshot<'tcx>) -> Option<bool> {\n+    pub fn region_constraints_added_in_snapshot(&self, mark: &Snapshot<'tcx>) -> bool {\n         self.undo_log\n             .region_constraints_in_snapshot(mark)\n-            .map(|&elt| match elt {\n-                AddConstraint(constraint) => Some(constraint.involves_placeholders()),\n-                _ => None,\n-            })\n-            .max()\n-            .unwrap_or(None)\n+            .any(|&elt| matches!(elt, AddConstraint(_)))\n     }\n \n     #[inline]"}, {"sha": "8dd1a7c5f21f0b035e4cb9ec75589ee6c8a0dc33", "filename": "compiler/rustc_infer/src/infer/undo_log.rs", "status": "modified", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/a0245bb3cb51c0e9a19c20abac6473da446832e0/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fundo_log.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0245bb3cb51c0e9a19c20abac6473da446832e0/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fundo_log.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fundo_log.rs?ref=a0245bb3cb51c0e9a19c20abac6473da446832e0", "patch": "@@ -183,15 +183,6 @@ impl<'tcx> InferCtxtUndoLogs<'tcx> {\n         self.logs[s.undo_len..].iter().any(|log| matches!(log, UndoLog::OpaqueTypes(..)))\n     }\n \n-    pub(crate) fn region_constraints(\n-        &self,\n-    ) -> impl Iterator<Item = &'_ region_constraints::UndoLog<'tcx>> + Clone {\n-        self.logs.iter().filter_map(|log| match log {\n-            UndoLog::RegionConstraintCollector(log) => Some(log),\n-            _ => None,\n-        })\n-    }\n-\n     fn assert_open_snapshot(&self, snapshot: &Snapshot<'tcx>) {\n         // Failures here may indicate a failure to follow a stack discipline.\n         assert!(self.logs.len() >= snapshot.undo_len);"}, {"sha": "d6fd457de06da42d4f5c17ac024ac8fa9c821dc2", "filename": "compiler/rustc_trait_selection/src/traits/coherence.rs", "status": "modified", "additions": 62, "deletions": 49, "changes": 111, "blob_url": "https://github.com/rust-lang/rust/blob/a0245bb3cb51c0e9a19c20abac6473da446832e0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0245bb3cb51c0e9a19c20abac6473da446832e0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fcoherence.rs?ref=a0245bb3cb51c0e9a19c20abac6473da446832e0", "patch": "@@ -5,7 +5,7 @@\n //! [trait-specialization]: https://rustc-dev-guide.rust-lang.org/traits/specialization.html\n \n use crate::infer::outlives::env::OutlivesEnvironment;\n-use crate::infer::{CombinedSnapshot, InferOk};\n+use crate::infer::InferOk;\n use crate::traits::outlives_bounds::InferCtxtExt as _;\n use crate::traits::select::IntercrateAmbiguityCause;\n use crate::traits::util::impl_subject_and_oblig;\n@@ -62,6 +62,21 @@ pub fn add_placeholder_note(err: &mut Diagnostic) {\n     );\n }\n \n+#[derive(Debug, Clone, Copy)]\n+enum TrackAmbiguityCauses {\n+    Yes,\n+    No,\n+}\n+\n+impl TrackAmbiguityCauses {\n+    fn is_yes(self) -> bool {\n+        match self {\n+            TrackAmbiguityCauses::Yes => true,\n+            TrackAmbiguityCauses::No => false,\n+        }\n+    }\n+}\n+\n /// If there are types that satisfy both impls, returns `Some`\n /// with a suitably-freshened `ImplHeader` with those types\n /// substituted. Otherwise, returns `None`.\n@@ -97,29 +112,28 @@ pub fn overlapping_impls(\n         return None;\n     }\n \n-    let infcx = tcx\n-        .infer_ctxt()\n-        .with_opaque_type_inference(DefiningAnchor::Bubble)\n-        .intercrate(true)\n-        .build();\n-    let selcx = &mut SelectionContext::new(&infcx);\n-    let overlaps =\n-        overlap(selcx, skip_leak_check, impl1_def_id, impl2_def_id, overlap_mode).is_some();\n-    if !overlaps {\n-        return None;\n-    }\n+    let _overlap_with_bad_diagnostics = overlap(\n+        tcx,\n+        TrackAmbiguityCauses::No,\n+        skip_leak_check,\n+        impl1_def_id,\n+        impl2_def_id,\n+        overlap_mode,\n+    )?;\n \n     // In the case where we detect an error, run the check again, but\n     // this time tracking intercrate ambiguity causes for better\n     // diagnostics. (These take time and can lead to false errors.)\n-    let infcx = tcx\n-        .infer_ctxt()\n-        .with_opaque_type_inference(DefiningAnchor::Bubble)\n-        .intercrate(true)\n-        .build();\n-    let selcx = &mut SelectionContext::new(&infcx);\n-    selcx.enable_tracking_intercrate_ambiguity_causes();\n-    Some(overlap(selcx, skip_leak_check, impl1_def_id, impl2_def_id, overlap_mode).unwrap())\n+    let overlap = overlap(\n+        tcx,\n+        TrackAmbiguityCauses::Yes,\n+        skip_leak_check,\n+        impl1_def_id,\n+        impl2_def_id,\n+        overlap_mode,\n+    )\n+    .unwrap();\n+    Some(overlap)\n }\n \n fn with_fresh_ty_vars<'cx, 'tcx>(\n@@ -146,40 +160,34 @@ fn with_fresh_ty_vars<'cx, 'tcx>(\n \n /// Can both impl `a` and impl `b` be satisfied by a common type (including\n /// where-clauses)? If so, returns an `ImplHeader` that unifies the two impls.\n-fn overlap<'cx, 'tcx>(\n-    selcx: &mut SelectionContext<'cx, 'tcx>,\n+#[instrument(level = \"debug\", skip(tcx))]\n+fn overlap<'tcx>(\n+    tcx: TyCtxt<'tcx>,\n+    track_ambiguity_causes: TrackAmbiguityCauses,\n     skip_leak_check: SkipLeakCheck,\n     impl1_def_id: DefId,\n     impl2_def_id: DefId,\n     overlap_mode: OverlapMode,\n ) -> Option<OverlapResult<'tcx>> {\n-    debug!(\n-        \"overlap(impl1_def_id={:?}, impl2_def_id={:?}, overlap_mode={:?})\",\n-        impl1_def_id, impl2_def_id, overlap_mode\n-    );\n-\n-    selcx.infcx.probe_maybe_skip_leak_check(skip_leak_check.is_yes(), |snapshot| {\n-        overlap_within_probe(selcx, impl1_def_id, impl2_def_id, overlap_mode, snapshot)\n-    })\n-}\n-\n-fn overlap_within_probe<'cx, 'tcx>(\n-    selcx: &mut SelectionContext<'cx, 'tcx>,\n-    impl1_def_id: DefId,\n-    impl2_def_id: DefId,\n-    overlap_mode: OverlapMode,\n-    snapshot: &CombinedSnapshot<'tcx>,\n-) -> Option<OverlapResult<'tcx>> {\n-    let infcx = selcx.infcx;\n-\n     if overlap_mode.use_negative_impl() {\n-        if negative_impl(infcx.tcx, impl1_def_id, impl2_def_id)\n-            || negative_impl(infcx.tcx, impl2_def_id, impl1_def_id)\n+        if negative_impl(tcx, impl1_def_id, impl2_def_id)\n+            || negative_impl(tcx, impl2_def_id, impl1_def_id)\n         {\n             return None;\n         }\n     }\n \n+    let infcx = tcx\n+        .infer_ctxt()\n+        .with_opaque_type_inference(DefiningAnchor::Bubble)\n+        .skip_leak_check(skip_leak_check.is_yes())\n+        .intercrate(true)\n+        .build();\n+    let selcx = &mut SelectionContext::new(&infcx);\n+    if track_ambiguity_causes.is_yes() {\n+        selcx.enable_tracking_intercrate_ambiguity_causes();\n+    }\n+\n     // For the purposes of this check, we don't bring any placeholder\n     // types into scope; instead, we replace the generic types with\n     // fresh type variables, and hence we do our evaluations in an\n@@ -198,18 +206,23 @@ fn overlap_within_probe<'cx, 'tcx>(\n         }\n     }\n \n-    // We disable the leak when creating the `snapshot` by using\n-    // `infcx.probe_maybe_disable_leak_check`.\n-    if infcx.leak_check(snapshot).is_err() {\n+    // We toggle the `leak_check` by using `skip_leak_check` when constructing the\n+    // inference context, so this may be a noop.\n+    if infcx.leak_check(ty::UniverseIndex::ROOT, None).is_err() {\n         debug!(\"overlap: leak check failed\");\n         return None;\n     }\n \n     let intercrate_ambiguity_causes = selcx.take_intercrate_ambiguity_causes();\n     debug!(\"overlap: intercrate_ambiguity_causes={:#?}\", intercrate_ambiguity_causes);\n-\n-    let involves_placeholder =\n-        matches!(selcx.infcx.region_constraints_added_in_snapshot(snapshot), Some(true));\n+    let involves_placeholder = infcx\n+        .inner\n+        .borrow_mut()\n+        .unwrap_region_constraints()\n+        .data()\n+        .constraints\n+        .iter()\n+        .any(|c| c.0.involves_placeholders());\n \n     let impl_header = selcx.infcx.resolve_vars_if_possible(impl1_header);\n     Some(OverlapResult { impl_header, intercrate_ambiguity_causes, involves_placeholder })"}, {"sha": "a8a74d7501abf6f442bc296c2ce8b3a5b3565e07", "filename": "compiler/rustc_trait_selection/src/traits/query/evaluate_obligation.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/a0245bb3cb51c0e9a19c20abac6473da446832e0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fevaluate_obligation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0245bb3cb51c0e9a19c20abac6473da446832e0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fevaluate_obligation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Fevaluate_obligation.rs?ref=a0245bb3cb51c0e9a19c20abac6473da446832e0", "patch": "@@ -90,7 +90,7 @@ impl<'tcx> InferCtxtExt<'tcx> for InferCtxt<'tcx> {\n                     Ok(EvaluationResult::EvaluatedToAmbig)\n                 } else if self.opaque_types_added_in_snapshot(snapshot) {\n                     Ok(EvaluationResult::EvaluatedToOkModuloOpaqueTypes)\n-                } else if self.region_constraints_added_in_snapshot(snapshot).is_some() {\n+                } else if self.region_constraints_added_in_snapshot(snapshot) {\n                     Ok(EvaluationResult::EvaluatedToOkModuloRegions)\n                 } else {\n                     Ok(EvaluationResult::EvaluatedToOk)"}, {"sha": "42c1b629ac242b3a3fffded6a6ac3f936f72cf90", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/a0245bb3cb51c0e9a19c20abac6473da446832e0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a0245bb3cb51c0e9a19c20abac6473da446832e0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=a0245bb3cb51c0e9a19c20abac6473da446832e0", "patch": "@@ -561,9 +561,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         op: impl FnOnce(&mut Self) -> Result<EvaluationResult, OverflowError>,\n     ) -> Result<EvaluationResult, OverflowError> {\n         self.infcx.probe(|snapshot| -> Result<EvaluationResult, OverflowError> {\n+            let outer_universe = self.infcx.universe();\n             let result = op(self)?;\n \n-            match self.infcx.leak_check(snapshot) {\n+            match self.infcx.leak_check(outer_universe, Some(snapshot)) {\n                 Ok(()) => {}\n                 Err(_) => return Ok(EvaluatedToErr),\n             }\n@@ -572,9 +573,10 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 return Ok(result.max(EvaluatedToOkModuloOpaqueTypes));\n             }\n \n-            match self.infcx.region_constraints_added_in_snapshot(snapshot) {\n-                None => Ok(result),\n-                Some(_) => Ok(result.max(EvaluatedToOkModuloRegions)),\n+            if self.infcx.region_constraints_added_in_snapshot(snapshot) {\n+                Ok(result.max(EvaluatedToOkModuloRegions))\n+            } else {\n+                Ok(result)\n             }\n         })\n     }"}]}