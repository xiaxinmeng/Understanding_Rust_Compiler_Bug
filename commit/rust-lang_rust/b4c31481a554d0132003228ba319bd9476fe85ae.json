{"sha": "b4c31481a554d0132003228ba319bd9476fe85ae", "node_id": "C_kwDOAAsO6NoAKGI0YzMxNDgxYTU1NGQwMTMyMDAzMjI4YmEzMTliZDk0NzZmZTg1YWU", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2022-01-13T19:18:47Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2022-01-13T19:18:47Z"}, "message": "Merge #11276\n\n11276: internal: Slightly cleanup HasFormatSpecifier::lex_format_specifier r=Veykril a=Veykril\n\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>", "tree": {"sha": "0429796e6e1a95863e67c6ee27c89d1dbabbfd78", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0429796e6e1a95863e67c6ee27c89d1dbabbfd78"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/b4c31481a554d0132003228ba319bd9476fe85ae", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJh4HsXCRBK7hj4Ov3rIwAATU8IAH70p5cE9zLWCVriP1rv43cO\n2TJLnu0AXY783BkvWvTghCoMOWrjR8ykJ/QhrkuanKxGPPYG3/z0MVDKn78zH9TB\nZPSIBIPx+CeeqUFq9xksflBuRI+NW8rGqoWrVwWJC8YNDfx3sbibtA5LJalFGAgd\nG8Np+lEKc3Mfd7v7uMIWXr8cYH8FtZ6JyUHZk/wg9iRxNYNsBcq6t7v/mIeuMK6i\nkI0MEWs6wPqd7QAKXBKWRHTHogYS+nA1T7G0WDBnqsVjkWJ8pV4dn3QvgfZvLcWB\ny1BCn8877DQr/ltOf9ZW9dauDczGVK3qp2BqRZWd1ntbln0zGUBQFSO5D2yl7+s=\n=1Q3v\n-----END PGP SIGNATURE-----\n", "payload": "tree 0429796e6e1a95863e67c6ee27c89d1dbabbfd78\nparent 07ded2aef0b286c106fbd36d4e0e56ed7924639e\nparent c3148cb396bdcdb9802c56c95946093408bf8fc2\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1642101527 +0000\ncommitter GitHub <noreply@github.com> 1642101527 +0000\n\nMerge #11276\n\n11276: internal: Slightly cleanup HasFormatSpecifier::lex_format_specifier r=Veykril a=Veykril\n\nbors r+\n\nCo-authored-by: Lukas Wirth <lukastw97@gmail.com>\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/b4c31481a554d0132003228ba319bd9476fe85ae", "html_url": "https://github.com/rust-lang/rust/commit/b4c31481a554d0132003228ba319bd9476fe85ae", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/b4c31481a554d0132003228ba319bd9476fe85ae/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "07ded2aef0b286c106fbd36d4e0e56ed7924639e", "url": "https://api.github.com/repos/rust-lang/rust/commits/07ded2aef0b286c106fbd36d4e0e56ed7924639e", "html_url": "https://github.com/rust-lang/rust/commit/07ded2aef0b286c106fbd36d4e0e56ed7924639e"}, {"sha": "c3148cb396bdcdb9802c56c95946093408bf8fc2", "url": "https://api.github.com/repos/rust-lang/rust/commits/c3148cb396bdcdb9802c56c95946093408bf8fc2", "html_url": "https://github.com/rust-lang/rust/commit/c3148cb396bdcdb9802c56c95946093408bf8fc2"}], "stats": {"total": 359, "additions": 146, "deletions": 213}, "files": [{"sha": "3b0a1c5ddcdd146b29fd0c455e5f4e8de35a521a", "filename": "crates/syntax/src/ast/token_ext.rs", "status": "modified", "additions": 146, "deletions": 213, "changes": 359, "blob_url": "https://github.com/rust-lang/rust/blob/b4c31481a554d0132003228ba319bd9476fe85ae/crates%2Fsyntax%2Fsrc%2Fast%2Ftoken_ext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/b4c31481a554d0132003228ba319bd9476fe85ae/crates%2Fsyntax%2Fsrc%2Fast%2Ftoken_ext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fsyntax%2Fsrc%2Fast%2Ftoken_ext.rs?ref=b4c31481a554d0132003228ba319bd9476fe85ae", "patch": "@@ -288,124 +288,142 @@ pub trait HasFormatSpecifier: AstToken {\n             Some(char_ranges) => char_ranges,\n             None => return,\n         };\n-        let mut chars = char_ranges.iter().peekable();\n+        let mut chars = char_ranges\n+            .iter()\n+            .filter_map(|(range, res)| Some((*range, *res.as_ref().ok()?)))\n+            .peekable();\n \n         while let Some((range, first_char)) = chars.next() {\n-            match first_char {\n-                Ok('{') => {\n-                    // Format specifier, see syntax at https://doc.rust-lang.org/std/fmt/index.html#syntax\n-                    if let Some((_, Ok('{'))) = chars.peek() {\n-                        // Escaped format specifier, `{{`\n-                        chars.next();\n-                        continue;\n-                    }\n+            if let '{' = first_char {\n+                // Format specifier, see syntax at https://doc.rust-lang.org/std/fmt/index.html#syntax\n+                if let Some((_, '{')) = chars.peek() {\n+                    // Escaped format specifier, `{{`\n+                    chars.next();\n+                    continue;\n+                }\n \n-                    callback(*range, FormatSpecifier::Open);\n+                callback(range, FormatSpecifier::Open);\n \n-                    // check for integer/identifier\n-                    match chars\n-                        .peek()\n-                        .and_then(|next| next.1.as_ref().ok())\n-                        .copied()\n-                        .unwrap_or_default()\n-                    {\n-                        '0'..='9' => {\n-                            // integer\n-                            read_integer(&mut chars, &mut callback);\n+                // check for integer/identifier\n+                let (_, int_char) = chars.peek().copied().unwrap_or_default();\n+                match int_char {\n+                    // integer\n+                    '0'..='9' => read_integer(&mut chars, &mut callback),\n+                    // identifier\n+                    c if c == '_' || c.is_alphabetic() => {\n+                        read_identifier(&mut chars, &mut callback)\n+                    }\n+                    _ => {}\n+                }\n+\n+                if let Some((_, ':')) = chars.peek() {\n+                    skip_char_and_emit(&mut chars, FormatSpecifier::Colon, &mut callback);\n+\n+                    // check for fill/align\n+                    let mut cloned = chars.clone().take(2);\n+                    let (_, first) = cloned.next().unwrap_or_default();\n+                    let (_, second) = cloned.next().unwrap_or_default();\n+                    match second {\n+                        '<' | '^' | '>' => {\n+                            // alignment specifier, first char specifies fillment\n+                            skip_char_and_emit(&mut chars, FormatSpecifier::Fill, &mut callback);\n+                            skip_char_and_emit(&mut chars, FormatSpecifier::Align, &mut callback);\n                         }\n-                        c if c == '_' || c.is_alphabetic() => {\n-                            // identifier\n-                            read_identifier(&mut chars, &mut callback);\n+                        _ => {\n+                            if let '<' | '^' | '>' = first {\n+                                skip_char_and_emit(\n+                                    &mut chars,\n+                                    FormatSpecifier::Align,\n+                                    &mut callback,\n+                                );\n+                            }\n+                        }\n+                    }\n+\n+                    // check for sign\n+                    match chars.peek().copied().unwrap_or_default().1 {\n+                        '+' | '-' => {\n+                            skip_char_and_emit(&mut chars, FormatSpecifier::Sign, &mut callback);\n                         }\n                         _ => {}\n                     }\n \n-                    if let Some((_, Ok(':'))) = chars.peek() {\n-                        skip_char_and_emit(&mut chars, FormatSpecifier::Colon, &mut callback);\n-\n-                        // check for fill/align\n-                        let mut cloned = chars.clone().take(2);\n-                        let first = cloned\n-                            .next()\n-                            .and_then(|next| next.1.as_ref().ok())\n-                            .copied()\n-                            .unwrap_or_default();\n-                        let second = cloned\n-                            .next()\n-                            .and_then(|next| next.1.as_ref().ok())\n-                            .copied()\n-                            .unwrap_or_default();\n-                        match second {\n-                            '<' | '^' | '>' => {\n-                                // alignment specifier, first char specifies fillment\n+                    // check for `#`\n+                    if let Some((_, '#')) = chars.peek() {\n+                        skip_char_and_emit(&mut chars, FormatSpecifier::NumberSign, &mut callback);\n+                    }\n+\n+                    // check for `0`\n+                    let mut cloned = chars.clone().take(2);\n+                    let first = cloned.next().map(|next| next.1);\n+                    let second = cloned.next().map(|next| next.1);\n+\n+                    if first == Some('0') && second != Some('$') {\n+                        skip_char_and_emit(&mut chars, FormatSpecifier::Zero, &mut callback);\n+                    }\n+\n+                    // width\n+                    match chars.peek().copied().unwrap_or_default().1 {\n+                        '0'..='9' => {\n+                            read_integer(&mut chars, &mut callback);\n+                            if let Some((_, '$')) = chars.peek() {\n                                 skip_char_and_emit(\n                                     &mut chars,\n-                                    FormatSpecifier::Fill,\n+                                    FormatSpecifier::DollarSign,\n                                     &mut callback,\n                                 );\n+                            }\n+                        }\n+                        c if c == '_' || c.is_alphabetic() => {\n+                            read_identifier(&mut chars, &mut callback);\n+\n+                            if chars.peek().map(|&(_, c)| c) == Some('?') {\n                                 skip_char_and_emit(\n                                     &mut chars,\n-                                    FormatSpecifier::Align,\n+                                    FormatSpecifier::QuestionMark,\n                                     &mut callback,\n                                 );\n                             }\n-                            _ => match first {\n-                                '<' | '^' | '>' => {\n+\n+                            // can be either width (indicated by dollar sign, or type in which case\n+                            // the next sign has to be `}`)\n+                            let next = chars.peek().map(|&(_, c)| c);\n+\n+                            match next {\n+                                Some('$') => skip_char_and_emit(\n+                                    &mut chars,\n+                                    FormatSpecifier::DollarSign,\n+                                    &mut callback,\n+                                ),\n+                                Some('}') => {\n                                     skip_char_and_emit(\n                                         &mut chars,\n-                                        FormatSpecifier::Align,\n+                                        FormatSpecifier::Close,\n                                         &mut callback,\n                                     );\n+                                    continue;\n                                 }\n-                                _ => {}\n-                            },\n+                                _ => continue,\n+                            };\n                         }\n+                        _ => {}\n+                    }\n \n-                        // check for sign\n-                        match chars\n-                            .peek()\n-                            .and_then(|next| next.1.as_ref().ok())\n-                            .copied()\n-                            .unwrap_or_default()\n-                        {\n-                            '+' | '-' => {\n+                    // precision\n+                    if let Some((_, '.')) = chars.peek() {\n+                        skip_char_and_emit(&mut chars, FormatSpecifier::Dot, &mut callback);\n+\n+                        match chars.peek().copied().unwrap_or_default().1 {\n+                            '*' => {\n                                 skip_char_and_emit(\n                                     &mut chars,\n-                                    FormatSpecifier::Sign,\n+                                    FormatSpecifier::Asterisk,\n                                     &mut callback,\n                                 );\n                             }\n-                            _ => {}\n-                        }\n-\n-                        // check for `#`\n-                        if let Some((_, Ok('#'))) = chars.peek() {\n-                            skip_char_and_emit(\n-                                &mut chars,\n-                                FormatSpecifier::NumberSign,\n-                                &mut callback,\n-                            );\n-                        }\n-\n-                        // check for `0`\n-                        let mut cloned = chars.clone().take(2);\n-                        let first = cloned.next().and_then(|next| next.1.as_ref().ok()).copied();\n-                        let second = cloned.next().and_then(|next| next.1.as_ref().ok()).copied();\n-\n-                        if first == Some('0') && second != Some('$') {\n-                            skip_char_and_emit(&mut chars, FormatSpecifier::Zero, &mut callback);\n-                        }\n-\n-                        // width\n-                        match chars\n-                            .peek()\n-                            .and_then(|next| next.1.as_ref().ok())\n-                            .copied()\n-                            .unwrap_or_default()\n-                        {\n                             '0'..='9' => {\n                                 read_integer(&mut chars, &mut callback);\n-                                if let Some((_, Ok('$'))) = chars.peek() {\n+                                if let Some((_, '$')) = chars.peek() {\n                                     skip_char_and_emit(\n                                         &mut chars,\n                                         FormatSpecifier::DollarSign,\n@@ -415,178 +433,93 @@ pub trait HasFormatSpecifier: AstToken {\n                             }\n                             c if c == '_' || c.is_alphabetic() => {\n                                 read_identifier(&mut chars, &mut callback);\n-\n-                                if chars.peek().and_then(|next| next.1.as_ref().ok()).copied()\n-                                    == Some('?')\n-                                {\n-                                    skip_char_and_emit(\n-                                        &mut chars,\n-                                        FormatSpecifier::QuestionMark,\n-                                        &mut callback,\n-                                    );\n+                                if chars.peek().map(|&(_, c)| c) != Some('$') {\n+                                    continue;\n                                 }\n-\n-                                // can be either width (indicated by dollar sign, or type in which case\n-                                // the next sign has to be `}`)\n-                                let next =\n-                                    chars.peek().and_then(|next| next.1.as_ref().ok()).copied();\n-\n-                                match next {\n-                                    Some('$') => skip_char_and_emit(\n-                                        &mut chars,\n-                                        FormatSpecifier::DollarSign,\n-                                        &mut callback,\n-                                    ),\n-                                    Some('}') => {\n-                                        skip_char_and_emit(\n-                                            &mut chars,\n-                                            FormatSpecifier::Close,\n-                                            &mut callback,\n-                                        );\n-                                        continue;\n-                                    }\n-                                    _ => continue,\n-                                };\n+                                skip_char_and_emit(\n+                                    &mut chars,\n+                                    FormatSpecifier::DollarSign,\n+                                    &mut callback,\n+                                );\n+                            }\n+                            _ => {\n+                                continue;\n                             }\n-                            _ => {}\n                         }\n+                    }\n \n-                        // precision\n-                        if let Some((_, Ok('.'))) = chars.peek() {\n-                            skip_char_and_emit(&mut chars, FormatSpecifier::Dot, &mut callback);\n-\n-                            match chars\n-                                .peek()\n-                                .and_then(|next| next.1.as_ref().ok())\n-                                .copied()\n-                                .unwrap_or_default()\n-                            {\n-                                '*' => {\n-                                    skip_char_and_emit(\n-                                        &mut chars,\n-                                        FormatSpecifier::Asterisk,\n-                                        &mut callback,\n-                                    );\n-                                }\n-                                '0'..='9' => {\n-                                    read_integer(&mut chars, &mut callback);\n-                                    if let Some((_, Ok('$'))) = chars.peek() {\n-                                        skip_char_and_emit(\n-                                            &mut chars,\n-                                            FormatSpecifier::DollarSign,\n-                                            &mut callback,\n-                                        );\n-                                    }\n-                                }\n-                                c if c == '_' || c.is_alphabetic() => {\n-                                    read_identifier(&mut chars, &mut callback);\n-                                    if chars.peek().and_then(|next| next.1.as_ref().ok()).copied()\n-                                        != Some('$')\n-                                    {\n-                                        continue;\n-                                    }\n-                                    skip_char_and_emit(\n-                                        &mut chars,\n-                                        FormatSpecifier::DollarSign,\n-                                        &mut callback,\n-                                    );\n-                                }\n-                                _ => {\n-                                    continue;\n-                                }\n-                            }\n+                    // type\n+                    match chars.peek().copied().unwrap_or_default().1 {\n+                        '?' => {\n+                            skip_char_and_emit(\n+                                &mut chars,\n+                                FormatSpecifier::QuestionMark,\n+                                &mut callback,\n+                            );\n                         }\n+                        c if c == '_' || c.is_alphabetic() => {\n+                            read_identifier(&mut chars, &mut callback);\n \n-                        // type\n-                        match chars\n-                            .peek()\n-                            .and_then(|next| next.1.as_ref().ok())\n-                            .copied()\n-                            .unwrap_or_default()\n-                        {\n-                            '?' => {\n+                            if chars.peek().map(|&(_, c)| c) == Some('?') {\n                                 skip_char_and_emit(\n                                     &mut chars,\n                                     FormatSpecifier::QuestionMark,\n                                     &mut callback,\n                                 );\n                             }\n-                            c if c == '_' || c.is_alphabetic() => {\n-                                read_identifier(&mut chars, &mut callback);\n-\n-                                if chars.peek().and_then(|next| next.1.as_ref().ok()).copied()\n-                                    == Some('?')\n-                                {\n-                                    skip_char_and_emit(\n-                                        &mut chars,\n-                                        FormatSpecifier::QuestionMark,\n-                                        &mut callback,\n-                                    );\n-                                }\n-                            }\n-                            _ => {}\n                         }\n-                    }\n-\n-                    match chars.peek() {\n-                        Some((_, Ok('}'))) => {\n-                            skip_char_and_emit(&mut chars, FormatSpecifier::Close, &mut callback);\n-                        }\n-                        Some((_, _)) | None => continue,\n+                        _ => {}\n                     }\n                 }\n-                _ => {\n-                    while let Some((_, Ok(next_char))) = chars.peek() {\n-                        if next_char == &'{' {\n-                            break;\n-                        }\n-                        chars.next();\n-                    }\n+\n+                if let Some((_, '}')) = chars.peek() {\n+                    skip_char_and_emit(&mut chars, FormatSpecifier::Close, &mut callback);\n                 }\n-            };\n+                continue;\n+            }\n         }\n \n-        fn skip_char_and_emit<'a, I, F>(\n+        fn skip_char_and_emit<I, F>(\n             chars: &mut std::iter::Peekable<I>,\n             emit: FormatSpecifier,\n             callback: &mut F,\n         ) where\n-            I: Iterator<Item = &'a (TextRange, Result<char, rustc_lexer::unescape::EscapeError>)>,\n+            I: Iterator<Item = (TextRange, char)>,\n             F: FnMut(TextRange, FormatSpecifier),\n         {\n             let (range, _) = chars.next().unwrap();\n-            callback(*range, emit);\n+            callback(range, emit);\n         }\n \n-        fn read_integer<'a, I, F>(chars: &mut std::iter::Peekable<I>, callback: &mut F)\n+        fn read_integer<I, F>(chars: &mut std::iter::Peekable<I>, callback: &mut F)\n         where\n-            I: Iterator<Item = &'a (TextRange, Result<char, rustc_lexer::unescape::EscapeError>)>,\n+            I: Iterator<Item = (TextRange, char)>,\n             F: FnMut(TextRange, FormatSpecifier),\n         {\n             let (mut range, c) = chars.next().unwrap();\n-            assert!(c.as_ref().unwrap().is_ascii_digit());\n-            while let Some((r, Ok(next_char))) = chars.peek() {\n+            assert!(c.is_ascii_digit());\n+            while let Some(&(r, next_char)) = chars.peek() {\n                 if next_char.is_ascii_digit() {\n                     chars.next();\n-                    range = range.cover(*r);\n+                    range = range.cover(r);\n                 } else {\n                     break;\n                 }\n             }\n             callback(range, FormatSpecifier::Integer);\n         }\n \n-        fn read_identifier<'a, I, F>(chars: &mut std::iter::Peekable<I>, callback: &mut F)\n+        fn read_identifier<I, F>(chars: &mut std::iter::Peekable<I>, callback: &mut F)\n         where\n-            I: Iterator<Item = &'a (TextRange, Result<char, rustc_lexer::unescape::EscapeError>)>,\n+            I: Iterator<Item = (TextRange, char)>,\n             F: FnMut(TextRange, FormatSpecifier),\n         {\n             let (mut range, c) = chars.next().unwrap();\n-            assert!(c.as_ref().unwrap().is_alphabetic() || *c.as_ref().unwrap() == '_');\n-            while let Some((r, Ok(next_char))) = chars.peek() {\n-                if *next_char == '_' || next_char.is_ascii_digit() || next_char.is_alphabetic() {\n+            assert!(c.is_alphabetic() || c == '_');\n+            while let Some(&(r, next_char)) = chars.peek() {\n+                if next_char == '_' || next_char.is_ascii_digit() || next_char.is_alphabetic() {\n                     chars.next();\n-                    range = range.cover(*r);\n+                    range = range.cover(r);\n                 } else {\n                     break;\n                 }"}]}