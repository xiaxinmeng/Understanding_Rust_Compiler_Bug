{"sha": "746afe8952a026c24fd229474f40658cbc9e12c7", "node_id": "C_kwDOAAsO6NoAKDc0NmFmZTg5NTJhMDI2YzI0ZmQyMjk0NzRmNDA2NThjYmM5ZTEyYzc", "commit": {"author": {"name": "Ben Kimock", "email": "kimockb@gmail.com", "date": "2022-07-27T00:47:53Z"}, "committer": {"name": "Ben Kimock", "email": "kimockb@gmail.com", "date": "2022-07-27T01:25:56Z"}, "message": "Clarify safety comments", "tree": {"sha": "d579e2f87166c1a0352b148fb04731ed630e14d9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/d579e2f87166c1a0352b148fb04731ed630e14d9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/746afe8952a026c24fd229474f40658cbc9e12c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/746afe8952a026c24fd229474f40658cbc9e12c7", "html_url": "https://github.com/rust-lang/rust/commit/746afe8952a026c24fd229474f40658cbc9e12c7", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/746afe8952a026c24fd229474f40658cbc9e12c7/comments", "author": {"login": "saethlin", "id": 12105168, "node_id": "MDQ6VXNlcjEyMTA1MTY4", "avatar_url": "https://avatars.githubusercontent.com/u/12105168?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saethlin", "html_url": "https://github.com/saethlin", "followers_url": "https://api.github.com/users/saethlin/followers", "following_url": "https://api.github.com/users/saethlin/following{/other_user}", "gists_url": "https://api.github.com/users/saethlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/saethlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saethlin/subscriptions", "organizations_url": "https://api.github.com/users/saethlin/orgs", "repos_url": "https://api.github.com/users/saethlin/repos", "events_url": "https://api.github.com/users/saethlin/events{/privacy}", "received_events_url": "https://api.github.com/users/saethlin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "saethlin", "id": 12105168, "node_id": "MDQ6VXNlcjEyMTA1MTY4", "avatar_url": "https://avatars.githubusercontent.com/u/12105168?v=4", "gravatar_id": "", "url": "https://api.github.com/users/saethlin", "html_url": "https://github.com/saethlin", "followers_url": "https://api.github.com/users/saethlin/followers", "following_url": "https://api.github.com/users/saethlin/following{/other_user}", "gists_url": "https://api.github.com/users/saethlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/saethlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/saethlin/subscriptions", "organizations_url": "https://api.github.com/users/saethlin/orgs", "repos_url": "https://api.github.com/users/saethlin/repos", "events_url": "https://api.github.com/users/saethlin/events{/privacy}", "received_events_url": "https://api.github.com/users/saethlin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e2e3a887710b281ccc0e4e841c6fd4d5f95d85fc", "url": "https://api.github.com/repos/rust-lang/rust/commits/e2e3a887710b281ccc0e4e841c6fd4d5f95d85fc", "html_url": "https://github.com/rust-lang/rust/commit/e2e3a887710b281ccc0e4e841c6fd4d5f95d85fc"}], "stats": {"total": 106, "additions": 47, "deletions": 59}, "files": [{"sha": "dea72813365b21b9bc5e46e6af3e4cbe57c79184", "filename": "library/core/src/slice/iter.rs", "status": "modified", "additions": 47, "deletions": 59, "changes": 106, "blob_url": "https://github.com/rust-lang/rust/blob/746afe8952a026c24fd229474f40658cbc9e12c7/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs", "raw_url": "https://github.com/rust-lang/rust/raw/746afe8952a026c24fd229474f40658cbc9e12c7/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Fcore%2Fsrc%2Fslice%2Fiter.rs?ref=746afe8952a026c24fd229474f40658cbc9e12c7", "patch": "@@ -1629,11 +1629,12 @@ unsafe impl<'a, T> TrustedRandomAccessNoCoerce for Chunks<'a, T> {\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n #[must_use = \"iterators are lazy and do nothing unless consumed\"]\n pub struct ChunksMut<'a, T: 'a> {\n-    // This slice pointer must point at a valid region of T with at least length v.len(). Normally,\n-    // those requirements would mean that we could instead use a &mut [T] here, but we cannot\n-    // because __iterator_get_unchecked needs to return &mut [T], which guarantees certain aliasing\n-    // properties that we cannot uphold if we hold on to the full original &mut [T]. Wrapping a raw\n-    // slice instead lets us hand out non-overlapping &mut [T] subslices of the slice we wrap.\n+    /// # Safety\n+    /// This slice pointer must point at a valid region of `T` with at least length `v.len()`. Normally,\n+    /// those requirements would mean that we could instead use a `&mut [T]` here, but we cannot\n+    /// because `__iterator_get_unchecked` needs to return `&mut [T]`, which guarantees certain aliasing\n+    /// properties that we cannot uphold if we hold on to the full original `&mut [T]`. Wrapping a raw\n+    /// slice instead lets us hand out non-overlapping `&mut [T]` subslices of the slice we wrap.\n     v: *mut [T],\n     chunk_size: usize,\n     _marker: PhantomData<&'a mut T>,\n@@ -1656,7 +1657,7 @@ impl<'a, T> Iterator for ChunksMut<'a, T> {\n             None\n         } else {\n             let sz = cmp::min(self.v.len(), self.chunk_size);\n-            // SAFETY: This type ensures that any split_at_mut on self.v is valid.\n+            // SAFETY: The self.v contract ensures that any split_at_mut is valid.\n             let (head, tail) = unsafe { self.v.split_at_mut(sz) };\n             self.v = tail;\n             // SAFETY: Nothing else points to or will point to the contents of this slice.\n@@ -1692,9 +1693,9 @@ impl<'a, T> Iterator for ChunksMut<'a, T> {\n                 Some(sum) => cmp::min(self.v.len(), sum),\n                 None => self.v.len(),\n             };\n-            // SAFETY: This type ensures that any split_at_mut on self.v is valid.\n+            // SAFETY: The self.v contract ensures that any split_at_mut is valid.\n             let (head, tail) = unsafe { self.v.split_at_mut(end) };\n-            // SAFETY: This type ensures that any split_at_mut on self.v is valid.\n+            // SAFETY: The self.v contract ensures that any split_at_mut is valid.\n             let (_, nth) = unsafe { head.split_at_mut(start) };\n             self.v = tail;\n             // SAFETY: Nothing else points to or will point to the contents of this slice.\n@@ -1715,7 +1716,7 @@ impl<'a, T> Iterator for ChunksMut<'a, T> {\n \n     unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> Self::Item {\n         let start = idx * self.chunk_size;\n-        // SAFETY: see comments for `Chunks::__iterator_get_unchecked`.\n+        // SAFETY: see comments for `Chunks::__iterator_get_unchecked` and `self.v`.\n         //\n         // Also note that the caller also guarantees that we're never called\n         // with the same index again, and that no other methods that will\n@@ -1758,9 +1759,9 @@ impl<'a, T> DoubleEndedIterator for ChunksMut<'a, T> {\n                 Some(res) => cmp::min(self.v.len(), res),\n                 None => self.v.len(),\n             };\n-            // SAFETY: This type ensures that any split_at_mut on self.v is valid.\n+            // SAFETY: The self.v contract ensures that any split_at_mut is valid.\n             let (temp, _tail) = unsafe { self.v.split_at_mut(end) };\n-            // SAFETY: This type ensures that any split_at_mut on self.v is valid.\n+            // SAFETY: The self.v contract ensures that any split_at_mut is valid.\n             let (head, nth_back) = unsafe { temp.split_at_mut(start) };\n             self.v = head;\n             // SAFETY: Nothing else points to or will point to the contents of this slice.\n@@ -1970,11 +1971,12 @@ unsafe impl<'a, T> TrustedRandomAccessNoCoerce for ChunksExact<'a, T> {\n #[stable(feature = \"chunks_exact\", since = \"1.31.0\")]\n #[must_use = \"iterators are lazy and do nothing unless consumed\"]\n pub struct ChunksExactMut<'a, T: 'a> {\n-    // This slice pointer must point at a valid region of T with at least length v.len(). Normally,\n-    // those requirements would mean that we could instead use a &mut [T] here, but we cannot\n-    // because __iterator_get_unchecked needs to return &mut [T], which guarantees certain aliasing\n-    // properties that we cannot uphold if we hold on to the full original &mut [T]. Wrapping a raw\n-    // slice instead lets us hand out non-overlapping &mut [T] subslices of the slice we wrap.\n+    /// # Safety\n+    /// This slice pointer must point at a valid region of `T` with at least length `v.len()`. Normally,\n+    /// those requirements would mean that we could instead use a `&mut [T]` here, but we cannot\n+    /// because `__iterator_get_unchecked` needs to return `&mut [T]`, which guarantees certain aliasing\n+    /// properties that we cannot uphold if we hold on to the full original `&mut [T]`. Wrapping a raw\n+    /// slice instead lets us hand out non-overlapping `&mut [T]` subslices of the slice we wrap.\n     v: *mut [T],\n     rem: &'a mut [T], // The iterator never yields from here, so this can be unique\n     chunk_size: usize,\n@@ -2036,7 +2038,7 @@ impl<'a, T> Iterator for ChunksExactMut<'a, T> {\n             self.v = &mut [];\n             None\n         } else {\n-            // SAFETY: This type ensures that any split_at_mut on self.v is valid.\n+            // SAFETY: The self.v contract ensures that any split_at_mut is valid.\n             let (_, snd) = unsafe { self.v.split_at_mut(start) };\n             self.v = snd;\n             self.next()\n@@ -2050,7 +2052,7 @@ impl<'a, T> Iterator for ChunksExactMut<'a, T> {\n \n     unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> Self::Item {\n         let start = idx * self.chunk_size;\n-        // SAFETY: see comments for `ChunksMut::__iterator_get_unchecked`.\n+        // SAFETY: see comments for `Chunks::__iterator_get_unchecked` and `self.v`.\n         unsafe { from_raw_parts_mut(self.v.as_mut_ptr().add(start), self.chunk_size) }\n     }\n }\n@@ -2079,9 +2081,9 @@ impl<'a, T> DoubleEndedIterator for ChunksExactMut<'a, T> {\n         } else {\n             let start = (len - 1 - n) * self.chunk_size;\n             let end = start + self.chunk_size;\n-            // SAFETY: This type ensures that any split_at_mut on self.v is valid.\n+            // SAFETY: The self.v contract ensures that any split_at_mut is valid.\n             let (temp, _tail) = unsafe { mem::replace(&mut self.v, &mut []).split_at_mut(end) };\n-            // SAFETY: This type ensures that any split_at_mut on self.v is valid.\n+            // SAFETY: The self.v contract ensures that any split_at_mut is valid.\n             let (head, nth_back) = unsafe { temp.split_at_mut(start) };\n             self.v = head;\n             // SAFETY: Nothing else points to or will point to the contents of this slice.\n@@ -2669,11 +2671,12 @@ unsafe impl<'a, T> TrustedRandomAccessNoCoerce for RChunks<'a, T> {\n #[stable(feature = \"rchunks\", since = \"1.31.0\")]\n #[must_use = \"iterators are lazy and do nothing unless consumed\"]\n pub struct RChunksMut<'a, T: 'a> {\n-    // This slice pointer must point at a valid region of T with at least length v.len(). Normally,\n-    // those requirements would mean that we could instead use a &mut [T] here, but we cannot\n-    // because __iterator_get_unchecked needs to return &mut [T], which guarantees certain aliasing\n-    // properties that we cannot uphold if we hold on to the full original &mut [T]. Wrapping a raw\n-    // slice instead lets us hand out non-overlapping &mut [T] subslices of the slice we wrap.\n+    /// # Safety\n+    /// This slice pointer must point at a valid region of `T` with at least length `v.len()`. Normally,\n+    /// those requirements would mean that we could instead use a `&mut [T]` here, but we cannot\n+    /// because `__iterator_get_unchecked` needs to return `&mut [T]`, which guarantees certain aliasing\n+    /// properties that we cannot uphold if we hold on to the full original `&mut [T]`. Wrapping a raw\n+    /// slice instead lets us hand out non-overlapping `&mut [T]` subslices of the slice we wrap.\n     v: *mut [T],\n     chunk_size: usize,\n     _marker: PhantomData<&'a mut T>,\n@@ -2770,7 +2773,7 @@ impl<'a, T> Iterator for RChunksMut<'a, T> {\n             Some(start) => start,\n         };\n         // SAFETY: see comments for `RChunks::__iterator_get_unchecked` and\n-        // `ChunksMut::__iterator_get_unchecked`\n+        // `ChunksMut::__iterator_get_unchecked`, `self.v`.\n         unsafe { from_raw_parts_mut(self.v.as_mut_ptr().add(start), end - start) }\n     }\n }\n@@ -2803,9 +2806,9 @@ impl<'a, T> DoubleEndedIterator for RChunksMut<'a, T> {\n             let offset_from_end = (len - 1 - n) * self.chunk_size;\n             let end = self.v.len() - offset_from_end;\n             let start = end.saturating_sub(self.chunk_size);\n-            // SAFETY: This type ensures that any split_at_mut on self.v is valid.\n+            // SAFETY: The self.v contract ensures that any split_at_mut is valid.\n             let (tmp, tail) = unsafe { self.v.split_at_mut(end) };\n-            // SAFETY: This type ensures that any split_at_mut on self.v is valid.\n+            // SAFETY: The self.v contract ensures that any split_at_mut is valid.\n             let (_, nth_back) = unsafe { tmp.split_at_mut(start) };\n             self.v = tail;\n             // SAFETY: Nothing else points to or will point to the contents of this slice.\n@@ -3018,11 +3021,12 @@ unsafe impl<'a, T> TrustedRandomAccessNoCoerce for RChunksExact<'a, T> {\n #[stable(feature = \"rchunks\", since = \"1.31.0\")]\n #[must_use = \"iterators are lazy and do nothing unless consumed\"]\n pub struct RChunksExactMut<'a, T: 'a> {\n-    // This slice pointer must point at a valid region of T with at least length v.len(). Normally,\n-    // those requirements would mean that we could instead use a &mut [T] here, but we cannot\n-    // because __iterator_get_unchecked needs to return &mut [T], which guarantees certain aliasing\n-    // properties that we cannot uphold if we hold on to the full original &mut [T]. Wrapping a raw\n-    // slice instead lets us hand out non-overlapping &mut [T] subslices of the slice we wrap.\n+    /// # Safety\n+    /// This slice pointer must point at a valid region of `T` with at least length `v.len()`. Normally,\n+    /// those requirements would mean that we could instead use a `&mut [T]` here, but we cannot\n+    /// because `__iterator_get_unchecked` needs to return `&mut [T]`, which guarantees certain aliasing\n+    /// properties that we cannot uphold if we hold on to the full original `&mut [T]`. Wrapping a raw\n+    /// slice instead lets us hand out non-overlapping `&mut [T]` subslices of the slice we wrap.\n     v: *mut [T],\n     rem: &'a mut [T],\n     chunk_size: usize,\n@@ -3057,7 +3061,7 @@ impl<'a, T> Iterator for RChunksExactMut<'a, T> {\n             None\n         } else {\n             let len = self.v.len();\n-            // SAFETY: This type ensures that any split_at_mut on self.v is valid.\n+            // SAFETY: The self.v contract ensures that any split_at_mut is valid.\n             let (head, tail) = unsafe { self.v.split_at_mut(len - self.chunk_size) };\n             self.v = head;\n             // SAFETY: Nothing else points to or will point to the contents of this slice.\n@@ -3084,7 +3088,7 @@ impl<'a, T> Iterator for RChunksExactMut<'a, T> {\n             None\n         } else {\n             let len = self.v.len();\n-            // SAFETY: This type ensures that any split_at_mut on self.v is valid.\n+            // SAFETY: The self.v contract ensures that any split_at_mut is valid.\n             let (fst, _) = unsafe { self.v.split_at_mut(len - end) };\n             self.v = fst;\n             self.next()\n@@ -3099,7 +3103,7 @@ impl<'a, T> Iterator for RChunksExactMut<'a, T> {\n     unsafe fn __iterator_get_unchecked(&mut self, idx: usize) -> Self::Item {\n         let end = self.v.len() - idx * self.chunk_size;\n         let start = end - self.chunk_size;\n-        // SAFETY: see comments for `RChunksMut::__iterator_get_unchecked`.\n+        // SAFETY: see comments for `RChunksMut::__iterator_get_unchecked` and `self.v`.\n         unsafe { from_raw_parts_mut(self.v.as_mut_ptr().add(start), self.chunk_size) }\n     }\n }\n@@ -3111,7 +3115,7 @@ impl<'a, T> DoubleEndedIterator for RChunksExactMut<'a, T> {\n         if self.v.len() < self.chunk_size {\n             None\n         } else {\n-            // SAFETY: This type ensures that any split_at_mut on self.v is valid.\n+            // SAFETY: The self.v contract ensures that any split_at_mut is valid.\n             let (head, tail) = unsafe { self.v.split_at_mut(self.chunk_size) };\n             self.v = tail;\n             // SAFETY: Nothing else points to or will point to the contents of this slice.\n@@ -3131,9 +3135,9 @@ impl<'a, T> DoubleEndedIterator for RChunksExactMut<'a, T> {\n             let offset = (len - n) * self.chunk_size;\n             let start = self.v.len() - offset;\n             let end = start + self.chunk_size;\n-            // SAFETY: This type ensures that any split_at_mut on self.v is valid.\n+            // SAFETY: The self.v contract ensures that any split_at_mut is valid.\n             let (tmp, tail) = unsafe { self.v.split_at_mut(end) };\n-            // SAFETY: This type ensures that any split_at_mut on self.v is valid.\n+            // SAFETY: The self.v contract ensures that any split_at_mut is valid.\n             let (_, nth_back) = unsafe { tmp.split_at_mut(start) };\n             self.v = tail;\n             // SAFETY: Nothing else points to or will point to the contents of this slice.\n@@ -3220,11 +3224,7 @@ where\n             let mut len = 1;\n             let mut iter = self.slice.windows(2);\n             while let Some([l, r]) = iter.next() {\n-                if (self.predicate)(l, r) {\n-                    len += 1\n-                } else {\n-                    break;\n-                }\n+                if (self.predicate)(l, r) { len += 1 } else { break }\n             }\n             let (head, tail) = self.slice.split_at(len);\n             self.slice = tail;\n@@ -3256,11 +3256,7 @@ where\n             let mut len = 1;\n             let mut iter = self.slice.windows(2);\n             while let Some([l, r]) = iter.next_back() {\n-                if (self.predicate)(l, r) {\n-                    len += 1\n-                } else {\n-                    break;\n-                }\n+                if (self.predicate)(l, r) { len += 1 } else { break }\n             }\n             let (head, tail) = self.slice.split_at(self.slice.len() - len);\n             self.slice = head;\n@@ -3315,11 +3311,7 @@ where\n             let mut len = 1;\n             let mut iter = self.slice.windows(2);\n             while let Some([l, r]) = iter.next() {\n-                if (self.predicate)(l, r) {\n-                    len += 1\n-                } else {\n-                    break;\n-                }\n+                if (self.predicate)(l, r) { len += 1 } else { break }\n             }\n             let slice = mem::take(&mut self.slice);\n             let (head, tail) = slice.split_at_mut(len);\n@@ -3352,11 +3344,7 @@ where\n             let mut len = 1;\n             let mut iter = self.slice.windows(2);\n             while let Some([l, r]) = iter.next_back() {\n-                if (self.predicate)(l, r) {\n-                    len += 1\n-                } else {\n-                    break;\n-                }\n+                if (self.predicate)(l, r) { len += 1 } else { break }\n             }\n             let slice = mem::take(&mut self.slice);\n             let (head, tail) = slice.split_at_mut(slice.len() - len);"}]}