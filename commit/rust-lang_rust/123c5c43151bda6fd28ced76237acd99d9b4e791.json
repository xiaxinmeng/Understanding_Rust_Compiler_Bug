{"sha": "123c5c43151bda6fd28ced76237acd99d9b4e791", "node_id": "MDY6Q29tbWl0NzI0NzEyOjEyM2M1YzQzMTUxYmRhNmZkMjhjZWQ3NjIzN2FjZDk5ZDliNGU3OTE=", "commit": {"author": {"name": "Lindsey Kuper", "email": "lindsey@rockstargirl.org", "date": "2012-05-25T18:03:52Z"}, "committer": {"name": "Lindsey Kuper", "email": "lindsey@rockstargirl.org", "date": "2012-05-25T18:35:42Z"}, "message": "typeck: cleanup/refactoring", "tree": {"sha": "e55812449459814f564a1cf8f7ae8777db3b4127", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e55812449459814f564a1cf8f7ae8777db3b4127"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/123c5c43151bda6fd28ced76237acd99d9b4e791", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/123c5c43151bda6fd28ced76237acd99d9b4e791", "html_url": "https://github.com/rust-lang/rust/commit/123c5c43151bda6fd28ced76237acd99d9b4e791", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/123c5c43151bda6fd28ced76237acd99d9b4e791/comments", "author": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "lkuper", "id": 535218, "node_id": "MDQ6VXNlcjUzNTIxOA==", "avatar_url": "https://avatars.githubusercontent.com/u/535218?v=4", "gravatar_id": "", "url": "https://api.github.com/users/lkuper", "html_url": "https://github.com/lkuper", "followers_url": "https://api.github.com/users/lkuper/followers", "following_url": "https://api.github.com/users/lkuper/following{/other_user}", "gists_url": "https://api.github.com/users/lkuper/gists{/gist_id}", "starred_url": "https://api.github.com/users/lkuper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/lkuper/subscriptions", "organizations_url": "https://api.github.com/users/lkuper/orgs", "repos_url": "https://api.github.com/users/lkuper/repos", "events_url": "https://api.github.com/users/lkuper/events{/privacy}", "received_events_url": "https://api.github.com/users/lkuper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f7cb7b06d53b653b3f9cb585f01605d04ea9fc7d", "url": "https://api.github.com/repos/rust-lang/rust/commits/f7cb7b06d53b653b3f9cb585f01605d04ea9fc7d", "html_url": "https://github.com/rust-lang/rust/commit/f7cb7b06d53b653b3f9cb585f01605d04ea9fc7d"}], "stats": {"total": 79, "additions": 35, "deletions": 44}, "files": [{"sha": "71164588dc51059b481e92f7614d74d26e4e6dea", "filename": "src/rustc/middle/typeck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/123c5c43151bda6fd28ced76237acd99d9b4e791/src%2Frustc%2Fmiddle%2Ftypeck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123c5c43151bda6fd28ced76237acd99d9b4e791/src%2Frustc%2Fmiddle%2Ftypeck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck.rs?ref=123c5c43151bda6fd28ced76237acd99d9b4e791", "patch": "@@ -53,7 +53,7 @@ import middle::ty;\n import middle::ty::{arg, field, node_type_table, mk_nil,\n                     ty_param_bounds_and_ty, lookup_public_fields};\n import middle::ty::{ty_vid, region_vid, vid};\n-import middle::typeck::infer::{ty_and_region_var_methods};\n+import middle::typeck::infer::methods;\n import util::ppaux::{ty_to_str, tys_to_str, region_to_str,\n                      bound_region_to_str, vstore_to_str};\n import std::smallintmap;"}, {"sha": "07eeada10f89106b240fdb885518ab5edbd361ba", "filename": "src/rustc/middle/typeck/check.rs", "status": "modified", "additions": 14, "deletions": 24, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/123c5c43151bda6fd28ced76237acd99d9b4e791/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123c5c43151bda6fd28ced76237acd99d9b4e791/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck.rs?ref=123c5c43151bda6fd28ced76237acd99d9b4e791", "patch": "@@ -445,9 +445,6 @@ impl of region_scope for @fn_ctxt {\n \n impl methods for @fn_ctxt {\n     fn tag() -> str { #fmt[\"%x\", ptr::addr_of(*self) as uint] }\n-    fn ty_to_str(t: ty::t) -> str {\n-        ty_to_str(self.ccx.tcx, resolve_type_vars_if_possible(self, t))\n-    }\n     fn block_region() -> result<ty::region, str> {\n         alt vec::last_opt(self.blocks) {\n           some(bid) { result::ok(ty::re_scope(bid)) }\n@@ -521,8 +518,8 @@ impl methods for @fn_ctxt {\n         self.ccx.tcx.sess.span_err(\n             sp,\n             #fmt[\"mismatched types: expected `%s` but found `%s` (%s)\",\n-                 self.ty_to_str(e),\n-                 self.ty_to_str(a),\n+                 self.infcx.ty_to_str(e),\n+                 self.infcx.ty_to_str(a),\n                  ty::type_err_to_str(self.ccx.tcx, err)]);\n     }\n \n@@ -589,13 +586,6 @@ fn do_autoderef(fcx: @fn_ctxt, sp: span, t: ty::t) -> ty::t {\n     };\n }\n \n-fn resolve_type_vars_if_possible(fcx: @fn_ctxt, typ: ty::t) -> ty::t {\n-    alt infer::resolve_deep(fcx.infcx, typ, false) {\n-      result::ok(new_type) { ret new_type; }\n-      result::err(_) { ret typ; }\n-    }\n-}\n-\n // Returns true if the two types unify and false if they don't.\n fn are_compatible(fcx: @fn_ctxt, expected: ty::t, actual: ty::t) -> bool {\n     alt fcx.mk_eqty(expected, actual) {\n@@ -723,7 +713,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         // type with fresh region variables.\n \n         #debug[\"check_call_or_bind: before universal quant., fty=%s\",\n-               fcx.ty_to_str(fty)];\n+               fcx.infcx.ty_to_str(fty)];\n \n         // This is subtle: we expect `fty` to be a function type, which\n         // normally introduce a level of binding.  In this case, we want to\n@@ -745,7 +735,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n             };\n \n         #debug[\"check_call_or_bind: after universal quant., fty=%s\",\n-               fcx.ty_to_str(fty)];\n+               fcx.infcx.ty_to_str(fty)];\n \n         let supplied_arg_count = vec::len(args);\n \n@@ -780,7 +770,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n             fcx.ccx.tcx.sess.span_fatal(sp, \"mismatched types: \\\n                                              expected function or native \\\n                                              function but found \"\n-                                        + fcx.ty_to_str(fty));\n+                                        + fcx.infcx.ty_to_str(fty));\n           }\n         };\n \n@@ -1002,7 +992,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         tcx.sess.span_err(\n             ex.span, \"binary operation \" + ast_util::binop_to_str(op) +\n             \" cannot be applied to type `\" +\n-            fcx.ty_to_str(lhs_resolved_t) +\n+            fcx.infcx.ty_to_str(lhs_resolved_t) +\n             \"`\");\n         (lhs_resolved_t, false)\n     }\n@@ -1013,7 +1003,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n           _ {\n             fcx.ccx.tcx.sess.span_err(\n                 ex.span, #fmt[\"cannot apply unary operator `%s` to type `%s`\",\n-                              op_str, fcx.ty_to_str(rhs_t)]);\n+                              op_str, fcx.infcx.ty_to_str(rhs_t)]);\n             rhs_t\n           }\n         }\n@@ -1060,7 +1050,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                                                    expected_tys));\n \n         #debug(\"check_expr_fn_with_unifier %s fty=%s\",\n-               expr_to_str(expr), fcx.ty_to_str(fty));\n+               expr_to_str(expr), fcx.infcx.ty_to_str(fty));\n \n         fcx.write_ty(expr.id, fty);\n \n@@ -1185,7 +1175,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                     tcx.sess.span_fatal(\n                         expr.span,\n                         #fmt[\"type %s cannot be dereferenced\",\n-                             fcx.ty_to_str(oper_t)]);\n+                             fcx.infcx.ty_to_str(oper_t)]);\n                   }\n                 }\n               }\n@@ -1428,8 +1418,8 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n         let t_1 = fcx.to_ty(t);\n         let t_e = fcx.expr_ty(e);\n \n-        #debug[\"t_1=%s\", fcx.ty_to_str(t_1)];\n-        #debug[\"t_e=%s\", fcx.ty_to_str(t_e)];\n+        #debug[\"t_1=%s\", fcx.infcx.ty_to_str(t_1)];\n+        #debug[\"t_e=%s\", fcx.infcx.ty_to_str(t_e)];\n \n         alt ty::get(t_1).struct {\n           // This will be looked up later on\n@@ -1600,7 +1590,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n                 fcx.ccx.method_map.insert(id, origin);\n               }\n               none {\n-                let t_err = resolve_type_vars_if_possible(fcx, expr_t);\n+                let t_err = fcx.infcx.resolve_type_vars_if_possible(expr_t);\n                 let msg = #fmt[\"attempted access of field %s on type %s, but \\\n                           no public field or method with that name was found\",\n                                field, ty_to_str(tcx, t_err)];\n@@ -1674,7 +1664,7 @@ fn check_expr_with_unifier(fcx: @fn_ctxt,\n           }\n \n           none {\n-            let t_err = resolve_type_vars_if_possible(fcx, p_ty);\n+            let t_err = fcx.infcx.resolve_type_vars_if_possible(p_ty);\n             let msg = #fmt[\"no `alloc()` method found for type `%s`\",\n                            ty_to_str(tcx, t_err)];\n             tcx.sess.span_err(expr.span, msg);\n@@ -1710,7 +1700,7 @@ fn require_integral(fcx: @fn_ctxt, sp: span, t: ty::t) {\n     if !type_is_integral(fcx, sp, t) {\n         fcx.ccx.tcx.sess.span_err(sp, \"mismatched types: expected \\\n                                        integral type but found `\"\n-                                  + fcx.ty_to_str(t) + \"`\");\n+                                  + fcx.infcx.ty_to_str(t) + \"`\");\n     }\n }\n "}, {"sha": "6965751084c1d9b32b8e31f95b67b777cf7b5cef", "filename": "src/rustc/middle/typeck/check/alt.rs", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/123c5c43151bda6fd28ced76237acd99d9b4e791/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123c5c43151bda6fd28ced76237acd99d9b4e791/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Falt.rs?ref=123c5c43151bda6fd28ced76237acd99d9b4e791", "patch": "@@ -1,4 +1,5 @@\n-import middle::typeck::infer::{ty_and_region_var_methods};\n+import middle::typeck::infer::methods; // next_ty_var,\n+                                       // resolve_type_vars_if_possible\n \n fn check_alt(fcx: @fn_ctxt,\n              expr: @ast::expr,\n@@ -113,7 +114,7 @@ fn check_pat_variant(pcx: pat_ctxt, pat: @ast::pat, path: @ast::path,\n         tcx.sess.span_fatal\n             (pat.span,\n              #fmt[\"mismatched types: expected enum but found `%s`\",\n-                  fcx.ty_to_str(expected)]);\n+                  fcx.infcx.ty_to_str(expected)]);\n       }\n     }\n }\n@@ -134,12 +135,11 @@ fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n       ast::pat_range(begin, end) {\n         check_expr_with(fcx, begin, expected);\n         check_expr_with(fcx, end, expected);\n-        let b_ty = resolve_type_vars_if_possible(fcx,\n-                                                 fcx.expr_ty(begin));\n+        let b_ty =\n+            fcx.infcx.resolve_type_vars_if_possible(fcx.expr_ty(begin));\n         if !require_same_types(\n             tcx, pat.span, b_ty,\n-            resolve_type_vars_if_possible(\n-                fcx, fcx.expr_ty(end)),\n+            fcx.infcx.resolve_type_vars_if_possible(fcx.expr_ty(end)),\n             {|| \"mismatched types in range\" }) {\n             // no-op\n         } else if !ty::type_is_numeric(b_ty) {\n@@ -179,7 +179,7 @@ fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n             tcx.sess.span_fatal\n                 (pat.span,\n                 #fmt[\"mismatched types: expected `%s` but found record\",\n-                     fcx.ty_to_str(expected)]);\n+                     fcx.infcx.ty_to_str(expected)]);\n           }\n         };\n         let f_count = vec::len(fields);\n@@ -216,7 +216,7 @@ fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n             tcx.sess.span_fatal\n                 (pat.span,\n                  #fmt[\"mismatched types: expected `%s`, found tuple\",\n-                      fcx.ty_to_str(expected)]);\n+                      fcx.infcx.ty_to_str(expected)]);\n           }\n         };\n         let e_count = vec::len(elts);\n@@ -244,7 +244,7 @@ fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n             tcx.sess.span_fatal(\n                 pat.span,\n                 \"mismatched types: expected `\" +\n-                fcx.ty_to_str(expected) +\n+                fcx.infcx.ty_to_str(expected) +\n                 \"` found box\");\n           }\n         }\n@@ -259,7 +259,7 @@ fn check_pat(pcx: pat_ctxt, pat: @ast::pat, expected: ty::t) {\n             tcx.sess.span_fatal(\n                 pat.span,\n                 \"mismatched types: expected `\" +\n-                fcx.ty_to_str(expected) +\n+                fcx.infcx.ty_to_str(expected) +\n                 \"` found uniq\");\n           }\n         }"}, {"sha": "b6f01aed1fe49285e53039b0e4dac2b9bec73c6d", "filename": "src/rustc/middle/typeck/check/method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/123c5c43151bda6fd28ced76237acd99d9b4e791/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123c5c43151bda6fd28ced76237acd99d9b4e791/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fmethod.rs?ref=123c5c43151bda6fd28ced76237acd99d9b4e791", "patch": "@@ -2,7 +2,7 @@\n \n import syntax::ast_map;\n import regionmanip::universally_quantify_from_sty;\n-import middle::typeck::infer::{ty_and_region_var_methods};\n+import middle::typeck::infer::methods; // next_ty_vars\n \n enum lookup = {\n     fcx: @fn_ctxt,"}, {"sha": "60eead84bb349efc1e1b66236007b6f4faad2bc6", "filename": "src/rustc/middle/typeck/check/regionmanip.rs", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/123c5c43151bda6fd28ced76237acd99d9b4e791/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123c5c43151bda6fd28ced76237acd99d9b4e791/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fregionmanip.rs?ref=123c5c43151bda6fd28ced76237acd99d9b4e791", "patch": "@@ -12,7 +12,7 @@ fn universally_quantify_from_sty(fcx: @fn_ctxt,\n                                  sty: ty::sty) -> ty::t {\n \n     #debug[\"universally_quantify_from_sty(bound_tys=%?)\",\n-           bound_tys.map {|x| fcx.ty_to_str(x) }];\n+           bound_tys.map {|x| fcx.infcx.ty_to_str(x) }];\n     indent {||\n         let tcx = fcx.tcx();\n         let isr = collect_bound_regions_in_tys(tcx, @nil, bound_tys) { |br|\n@@ -25,7 +25,8 @@ fn universally_quantify_from_sty(fcx: @fn_ctxt,\n         let t_res = ty::fold_sty_to_ty(fcx.ccx.tcx, sty) { |t|\n             replace_bound_regions(tcx, span, isr, t)\n         };\n-        #debug[\"Result of universal quant. is %s\", fcx.ty_to_str(t_res)];\n+        #debug[\"Result of universal quant. is %s\",\n+               fcx.infcx.ty_to_str(t_res)];\n         t_res\n     }\n }"}, {"sha": "8f291e9b89eb4e82945d241b5d9a05ad011972dc", "filename": "src/rustc/middle/typeck/check/vtable.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/123c5c43151bda6fd28ced76237acd99d9b4e791/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123c5c43151bda6fd28ced76237acd99d9b4e791/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fvtable.rs?ref=123c5c43151bda6fd28ced76237acd99d9b4e791", "patch": "@@ -54,7 +54,7 @@ fn lookup_vtable(fcx: @fn_ctxt, isc: resolve::iscopes, sp: span,\n     -> vtable_origin {\n \n     #debug[\"lookup_vtable(ty=%s, iface_ty=%s)\",\n-           fcx.ty_to_str(ty), fcx.ty_to_str(iface_ty)];\n+           fcx.infcx.ty_to_str(ty), fcx.infcx.ty_to_str(iface_ty)];\n     let _i = indenter();\n \n     let tcx = fcx.ccx.tcx;"}, {"sha": "287cdebf60b5c530a5f957adc98aca8ad67dc6e7", "filename": "src/rustc/middle/typeck/check/writeback.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/123c5c43151bda6fd28ced76237acd99d9b4e791/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123c5c43151bda6fd28ced76237acd99d9b4e791/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Fcheck%2Fwriteback.rs?ref=123c5c43151bda6fd28ced76237acd99d9b4e791", "patch": "@@ -123,7 +123,7 @@ fn visit_pat(p: @ast::pat, wbcx: wb_ctxt, v: wb_vt) {\n     resolve_type_vars_for_node(wbcx, p.span, p.id);\n     #debug[\"Type for pattern binding %s (id %d) resolved to %s\",\n            pat_to_str(p), p.id,\n-           wbcx.fcx.ty_to_str(\n+           wbcx.fcx.infcx.ty_to_str(\n                ty::node_id_to_type(wbcx.fcx.ccx.tcx,\n                                    p.id))];\n     visit::visit_pat(p, wbcx, v);\n@@ -135,7 +135,7 @@ fn visit_local(l: @ast::local, wbcx: wb_ctxt, v: wb_vt) {\n       result::ok(lty) {\n         #debug[\"Type for local %s (id %d) resolved to %s\",\n                pat_to_str(l.node.pat), l.node.id,\n-               wbcx.fcx.ty_to_str(lty)];\n+               wbcx.fcx.infcx.ty_to_str(lty)];\n         write_ty_to_tcx(wbcx.fcx.ccx.tcx, l.node.id, lty);\n       }\n       result::err(e) {"}, {"sha": "f94d1656c0bd0225ffd6514c465980a068b64ce6", "filename": "src/rustc/middle/typeck/infer.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/123c5c43151bda6fd28ced76237acd99d9b4e791/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "raw_url": "https://github.com/rust-lang/rust/raw/123c5c43151bda6fd28ced76237acd99d9b4e791/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustc%2Fmiddle%2Ftypeck%2Finfer.rs?ref=123c5c43151bda6fd28ced76237acd99d9b4e791", "patch": "@@ -167,7 +167,7 @@ export mk_assignty;\n export resolve_shallow;\n export resolve_deep;\n export resolve_deep_var;\n-export ty_and_region_var_methods;\n+export methods; // for infer_ctxt\n export compare_tys;\n export fixup_err, fixup_err_to_str;\n \n@@ -388,7 +388,7 @@ fn uok() -> ures {\n     ok(())\n }\n \n-impl methods for infer_ctxt {\n+impl transaction_methods for infer_ctxt {\n     fn commit<T,E>(f: fn() -> result<T,E>) -> result<T,E> {\n \n         assert self.vb.bindings.len() == 0u;\n@@ -431,7 +431,7 @@ impl methods for infer_ctxt {\n     }\n }\n \n-impl ty_and_region_var_methods for infer_ctxt {\n+impl methods for infer_ctxt {\n     fn next_ty_var_id() -> ty_vid {\n         let id = *self.ty_var_counter;\n         *self.ty_var_counter += 1u;"}]}