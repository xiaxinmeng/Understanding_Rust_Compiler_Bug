{"sha": "3823c2dc1995ec261e36435662b8802c714e23d4", "node_id": "MDY6Q29tbWl0NzI0NzEyOjM4MjNjMmRjMTk5NWVjMjYxZTM2NDM1NjYyYjg4MDJjNzE0ZTIzZDQ=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-07-16T20:05:43Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2020-07-16T20:17:49Z"}, "message": "Remove FunctionSignature", "tree": {"sha": "74f7814de8380f97c645afbfe3dad7d924785fcb", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/74f7814de8380f97c645afbfe3dad7d924785fcb"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/3823c2dc1995ec261e36435662b8802c714e23d4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/3823c2dc1995ec261e36435662b8802c714e23d4", "html_url": "https://github.com/rust-lang/rust/commit/3823c2dc1995ec261e36435662b8802c714e23d4", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/3823c2dc1995ec261e36435662b8802c714e23d4/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a5ae8b8b92748e1b876002799d160136a7836212", "url": "https://api.github.com/repos/rust-lang/rust/commits/a5ae8b8b92748e1b876002799d160136a7836212", "html_url": "https://github.com/rust-lang/rust/commit/a5ae8b8b92748e1b876002799d160136a7836212"}], "stats": {"total": 189, "additions": 8, "deletions": 181}, "files": [{"sha": "0f6953158a59a832df22da0ed6013f75f779b452", "filename": "crates/ra_hir/src/code_model.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/3823c2dc1995ec261e36435662b8802c714e23d4/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3823c2dc1995ec261e36435662b8802c714e23d4/crates%2Fra_hir%2Fsrc%2Fcode_model.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_hir%2Fsrc%2Fcode_model.rs?ref=3823c2dc1995ec261e36435662b8802c714e23d4", "patch": "@@ -1553,7 +1553,7 @@ impl Callable {\n         param_list.self_param()\n     }\n     pub fn n_params(&self) -> usize {\n-        self.sig.params().len()\n+        self.sig.params().len() - if self.is_bound_method { 1 } else { 0 }\n     }\n     pub fn params(\n         &self,"}, {"sha": "c7b74e6355e556bea52c4397b5c6e83d66720622", "filename": "crates/ra_ide/src/completion/presentation.rs", "status": "modified", "additions": 7, "deletions": 10, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/3823c2dc1995ec261e36435662b8802c714e23d4/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fpresentation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3823c2dc1995ec261e36435662b8802c714e23d4/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fpresentation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fcompletion%2Fpresentation.rs?ref=3823c2dc1995ec261e36435662b8802c714e23d4", "patch": "@@ -11,10 +11,7 @@ use crate::{\n         completion_item::Builder, CompletionContext, CompletionItem, CompletionItemKind,\n         CompletionKind, Completions,\n     },\n-    display::{\n-        const_label, function_declaration, function_signature::FunctionSignature, macro_label,\n-        type_label,\n-    },\n+    display::{const_label, function_declaration, macro_label, type_label},\n     CompletionScore, RootDatabase,\n };\n \n@@ -198,7 +195,6 @@ impl Completions {\n \n         let name = local_name.unwrap_or_else(|| func.name(ctx.db).to_string());\n         let ast_node = func.source(ctx.db).value;\n-        let function_signature = FunctionSignature::from(&ast_node);\n \n         let mut builder =\n             CompletionItem::new(CompletionKind::Reference, ctx.source_range(), name.clone())\n@@ -211,11 +207,12 @@ impl Completions {\n                 .set_deprecated(is_deprecated(func, ctx.db))\n                 .detail(function_declaration(&ast_node));\n \n-        let params = function_signature\n-            .parameter_names\n-            .iter()\n-            .skip(if function_signature.has_self_param { 1 } else { 0 })\n-            .map(|name| name.trim_start_matches('_').into())\n+        let params = ast_node\n+            .param_list()\n+            .into_iter()\n+            .flat_map(|it| it.params())\n+            .flat_map(|it| it.pat())\n+            .map(|pat| pat.to_string().trim_start_matches('_').into())\n             .collect();\n \n         builder = builder.add_call_parens(ctx, name, Params::Named(params));"}, {"sha": "6d4151dd85d42de957af50d54ffdb945a876432a", "filename": "crates/ra_ide/src/display.rs", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/3823c2dc1995ec261e36435662b8802c714e23d4/crates%2Fra_ide%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/3823c2dc1995ec261e36435662b8802c714e23d4/crates%2Fra_ide%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fdisplay.rs?ref=3823c2dc1995ec261e36435662b8802c714e23d4", "patch": "@@ -1,7 +1,6 @@\n //! This module contains utilities for turning SyntaxNodes and HIR types\n //! into types that may be used to render in a UI.\n \n-pub(crate) mod function_signature;\n mod navigation_target;\n mod short_label;\n \n@@ -77,23 +76,6 @@ pub(crate) fn type_label(node: &ast::TypeAliasDef) -> String {\n     label.trim().to_owned()\n }\n \n-pub(crate) fn generic_parameters<N: TypeParamsOwner>(node: &N) -> Vec<String> {\n-    let mut res = vec![];\n-    if let Some(type_params) = node.type_param_list() {\n-        res.extend(type_params.lifetime_params().map(|p| p.syntax().text().to_string()));\n-        res.extend(type_params.type_params().map(|p| p.syntax().text().to_string()));\n-    }\n-    res\n-}\n-\n-pub(crate) fn where_predicates<N: TypeParamsOwner>(node: &N) -> Vec<String> {\n-    let mut res = vec![];\n-    if let Some(clause) = node.where_clause() {\n-        res.extend(clause.predicates().map(|p| p.syntax().text().to_string()));\n-    }\n-    res\n-}\n-\n pub(crate) fn macro_label(node: &ast::MacroCall) -> String {\n     let name = node.name().map(|name| name.syntax().text().to_string()).unwrap_or_default();\n     let vis = if node.has_atom_attr(\"macro_export\") { \"#[macro_export]\\n\" } else { \"\" };"}, {"sha": "f6e11357f8512783975bd6f9a944c420b6522f01", "filename": "crates/ra_ide/src/display/function_signature.rs", "status": "removed", "additions": 0, "deletions": 152, "changes": 152, "blob_url": "https://github.com/rust-lang/rust/blob/a5ae8b8b92748e1b876002799d160136a7836212/crates%2Fra_ide%2Fsrc%2Fdisplay%2Ffunction_signature.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a5ae8b8b92748e1b876002799d160136a7836212/crates%2Fra_ide%2Fsrc%2Fdisplay%2Ffunction_signature.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_ide%2Fsrc%2Fdisplay%2Ffunction_signature.rs?ref=a5ae8b8b92748e1b876002799d160136a7836212", "patch": "@@ -1,152 +0,0 @@\n-//! FIXME: write short doc here\n-\n-// FIXME: this modules relies on strings and AST way too much, and it should be\n-// rewritten (matklad 2020-05-07)\n-use std::convert::From;\n-\n-use hir::Documentation;\n-use ra_syntax::ast::{self, AstNode, NameOwner, VisibilityOwner};\n-use stdx::split_delim;\n-\n-use crate::display::{generic_parameters, where_predicates};\n-\n-#[derive(Debug)]\n-pub(crate) enum CallableKind {\n-    Function,\n-}\n-\n-/// Contains information about a function signature\n-#[derive(Debug)]\n-pub(crate) struct FunctionSignature {\n-    pub(crate) kind: CallableKind,\n-    /// Optional visibility\n-    pub(crate) visibility: Option<String>,\n-    /// Qualifiers like `async`, `unsafe`, ...\n-    pub(crate) qualifier: FunctionQualifier,\n-    /// Name of the function\n-    pub(crate) name: Option<String>,\n-    /// Documentation for the function\n-    pub(crate) doc: Option<Documentation>,\n-    /// Generic parameters\n-    pub(crate) generic_parameters: Vec<String>,\n-    /// Parameters of the function\n-    pub(crate) parameters: Vec<String>,\n-    /// Parameter names of the function\n-    pub(crate) parameter_names: Vec<String>,\n-    /// Parameter types of the function\n-    pub(crate) parameter_types: Vec<String>,\n-    /// Optional return type\n-    pub(crate) ret_type: Option<String>,\n-    /// Where predicates\n-    pub(crate) where_predicates: Vec<String>,\n-    /// Self param presence\n-    pub(crate) has_self_param: bool,\n-}\n-\n-#[derive(Debug, Default)]\n-pub(crate) struct FunctionQualifier {\n-    // `async` and `const` are mutually exclusive. Do we need to enforcing it here?\n-    pub(crate) is_async: bool,\n-    pub(crate) is_const: bool,\n-    pub(crate) is_unsafe: bool,\n-    /// The string `extern \"..\"`\n-    pub(crate) extern_abi: Option<String>,\n-}\n-\n-impl From<&'_ ast::FnDef> for FunctionSignature {\n-    fn from(node: &ast::FnDef) -> FunctionSignature {\n-        fn param_list(node: &ast::FnDef) -> (bool, Vec<String>, Vec<String>) {\n-            let mut res = vec![];\n-            let mut res_types = vec![];\n-            let mut has_self_param = false;\n-            if let Some(param_list) = node.param_list() {\n-                if let Some(self_param) = param_list.self_param() {\n-                    has_self_param = true;\n-                    let raw_param = self_param.syntax().text().to_string();\n-\n-                    res_types.push(\n-                        raw_param\n-                            .split(':')\n-                            .nth(1)\n-                            .and_then(|it| it.get(1..))\n-                            .unwrap_or_else(|| \"Self\")\n-                            .to_string(),\n-                    );\n-                    res.push(raw_param);\n-                }\n-\n-                // macro-generated functions are missing whitespace\n-                fn fmt_param(param: ast::Param) -> String {\n-                    let text = param.syntax().text().to_string();\n-                    match split_delim(&text, ':') {\n-                        Some((left, right)) => format!(\"{}: {}\", left.trim(), right.trim()),\n-                        _ => text,\n-                    }\n-                }\n-\n-                res.extend(param_list.params().map(fmt_param));\n-                res_types.extend(param_list.params().map(|param| {\n-                    let param_text = param.syntax().text().to_string();\n-                    match param_text.split(':').nth(1).and_then(|it| it.get(1..)) {\n-                        Some(it) => it.to_string(),\n-                        None => param_text,\n-                    }\n-                }));\n-            }\n-            (has_self_param, res, res_types)\n-        }\n-\n-        fn param_name_list(node: &ast::FnDef) -> Vec<String> {\n-            let mut res = vec![];\n-            if let Some(param_list) = node.param_list() {\n-                if let Some(self_param) = param_list.self_param() {\n-                    res.push(self_param.syntax().text().to_string())\n-                }\n-\n-                res.extend(\n-                    param_list\n-                        .params()\n-                        .map(|param| {\n-                            Some(\n-                                param\n-                                    .pat()?\n-                                    .syntax()\n-                                    .descendants()\n-                                    .find_map(ast::Name::cast)?\n-                                    .text()\n-                                    .to_string(),\n-                            )\n-                        })\n-                        .map(|param| param.unwrap_or_default()),\n-                );\n-            }\n-            res\n-        }\n-\n-        let (has_self_param, parameters, parameter_types) = param_list(node);\n-\n-        FunctionSignature {\n-            kind: CallableKind::Function,\n-            visibility: node.visibility().map(|n| n.syntax().text().to_string()),\n-            qualifier: FunctionQualifier {\n-                is_async: node.async_token().is_some(),\n-                is_const: node.const_token().is_some(),\n-                is_unsafe: node.unsafe_token().is_some(),\n-                extern_abi: node.abi().map(|n| n.to_string()),\n-            },\n-            name: node.name().map(|n| n.text().to_string()),\n-            ret_type: node\n-                .ret_type()\n-                .and_then(|r| r.type_ref())\n-                .map(|n| n.syntax().text().to_string()),\n-            parameters,\n-            parameter_names: param_name_list(node),\n-            parameter_types,\n-            generic_parameters: generic_parameters(node),\n-            where_predicates: where_predicates(node),\n-            // docs are processed separately\n-            doc: None,\n-            has_self_param,\n-        }\n-    }\n-}"}]}