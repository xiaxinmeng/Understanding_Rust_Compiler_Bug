{"sha": "cbc6e902889bec9ee96e8e8520ed65aa342d418f", "node_id": "MDY6Q29tbWl0NzI0NzEyOmNiYzZlOTAyODg5YmVjOWVlOTZlOGU4NTIwZWQ2NWFhMzQyZDQxOGY=", "commit": {"author": {"name": "Wonwoo Choi", "email": "chwo9843@gmail.com", "date": "2017-10-01T17:12:08Z"}, "committer": {"name": "Wonwoo Choi", "email": "chwo9843@gmail.com", "date": "2017-10-08T11:53:14Z"}, "message": "Introduce `Print` trait for displaying types", "tree": {"sha": "1916e50a48017cfc3a72001389505e7428ac5102", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1916e50a48017cfc3a72001389505e7428ac5102"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/cbc6e902889bec9ee96e8e8520ed65aa342d418f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/cbc6e902889bec9ee96e8e8520ed65aa342d418f", "html_url": "https://github.com/rust-lang/rust/commit/cbc6e902889bec9ee96e8e8520ed65aa342d418f", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/cbc6e902889bec9ee96e8e8520ed65aa342d418f/comments", "author": {"login": "tirr-c", "id": 2322996, "node_id": "MDQ6VXNlcjIzMjI5OTY=", "avatar_url": "https://avatars.githubusercontent.com/u/2322996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tirr-c", "html_url": "https://github.com/tirr-c", "followers_url": "https://api.github.com/users/tirr-c/followers", "following_url": "https://api.github.com/users/tirr-c/following{/other_user}", "gists_url": "https://api.github.com/users/tirr-c/gists{/gist_id}", "starred_url": "https://api.github.com/users/tirr-c/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tirr-c/subscriptions", "organizations_url": "https://api.github.com/users/tirr-c/orgs", "repos_url": "https://api.github.com/users/tirr-c/repos", "events_url": "https://api.github.com/users/tirr-c/events{/privacy}", "received_events_url": "https://api.github.com/users/tirr-c/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tirr-c", "id": 2322996, "node_id": "MDQ6VXNlcjIzMjI5OTY=", "avatar_url": "https://avatars.githubusercontent.com/u/2322996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tirr-c", "html_url": "https://github.com/tirr-c", "followers_url": "https://api.github.com/users/tirr-c/followers", "following_url": "https://api.github.com/users/tirr-c/following{/other_user}", "gists_url": "https://api.github.com/users/tirr-c/gists{/gist_id}", "starred_url": "https://api.github.com/users/tirr-c/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tirr-c/subscriptions", "organizations_url": "https://api.github.com/users/tirr-c/orgs", "repos_url": "https://api.github.com/users/tirr-c/repos", "events_url": "https://api.github.com/users/tirr-c/events{/privacy}", "received_events_url": "https://api.github.com/users/tirr-c/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9b0480bec63fb1d096fd9017604a861f80ea7df1", "url": "https://api.github.com/repos/rust-lang/rust/commits/9b0480bec63fb1d096fd9017604a861f80ea7df1", "html_url": "https://github.com/rust-lang/rust/commit/9b0480bec63fb1d096fd9017604a861f80ea7df1"}], "stats": {"total": 1771, "additions": 968, "deletions": 803}, "files": [{"sha": "740299b91f118d6b24810704a327928bab862c64", "filename": "src/librustc/ty/context.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/cbc6e902889bec9ee96e8e8520ed65aa342d418f/src%2Flibrustc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbc6e902889bec9ee96e8e8520ed65aa342d418f/src%2Flibrustc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fty%2Fcontext.rs?ref=cbc6e902889bec9ee96e8e8520ed65aa342d418f", "patch": "@@ -915,10 +915,6 @@ pub struct GlobalCtxt<'tcx> {\n     /// Maps Expr NodeId's to `true` iff `&expr` can have 'static lifetime.\n     pub rvalue_promotable_to_static: RefCell<NodeMap<bool>>,\n \n-    pub display_used_late_bound_region_names: RefCell<Option<FxHashSet<Name>>>,\n-\n-    pub display_late_bound_region_index: Cell<usize>,\n-\n     /// The definite name of the current crate after taking into account\n     /// attributes, commandline parameters, etc.\n     pub crate_name: Symbol,\n@@ -1193,8 +1189,6 @@ impl<'a, 'gcx, 'tcx> TyCtxt<'a, 'gcx, 'tcx> {\n             selection_cache: traits::SelectionCache::new(),\n             evaluation_cache: traits::EvaluationCache::new(),\n             rvalue_promotable_to_static: RefCell::new(NodeMap()),\n-            display_used_late_bound_region_names: RefCell::new(None),\n-            display_late_bound_region_index: Cell::new(0),\n             crate_name: Symbol::intern(crate_name),\n             data_layout,\n             layout_interner: RefCell::new(FxHashSet()),"}, {"sha": "0eb2c19fe44ddeb72a2013ce0e79638691e64a39", "filename": "src/librustc/util/ppaux.rs", "status": "modified", "additions": 968, "deletions": 797, "changes": 1765, "blob_url": "https://github.com/rust-lang/rust/blob/cbc6e902889bec9ee96e8e8520ed65aa342d418f/src%2Flibrustc%2Futil%2Fppaux.rs", "raw_url": "https://github.com/rust-lang/rust/raw/cbc6e902889bec9ee96e8e8520ed65aa342d418f/src%2Flibrustc%2Futil%2Fppaux.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Futil%2Fppaux.rs?ref=cbc6e902889bec9ee96e8e8520ed65aa342d418f", "patch": "@@ -33,296 +33,449 @@ use syntax::ast::CRATE_NODE_ID;\n use syntax::symbol::Symbol;\n use hir;\n \n-pub fn verbose() -> bool {\n-    ty::tls::with(|tcx| tcx.sess.verbose())\n+macro_rules! gen_display_debug_body {\n+    ( $with:path ) => {\n+        fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+            let mut cx = PrintContext::new();\n+            $with(self, f, &mut cx)\n+        }\n+    };\n }\n-\n-pub fn identify_regions() -> bool {\n-    ty::tls::with(|tcx| tcx.sess.opts.debugging_opts.identify_regions)\n+macro_rules! gen_display_debug {\n+    ( ($($x:tt)+) $target:ty, display yes ) => {\n+        impl<$($x)+> fmt::Display for $target {\n+            gen_display_debug_body! { Print::print_display }\n+        }\n+    };\n+    ( () $target:ty, display yes ) => {\n+        impl fmt::Display for $target {\n+            gen_display_debug_body! { Print::print_display }\n+        }\n+    };\n+    ( ($($x:tt)+) $target:ty, debug yes ) => {\n+        impl<$($x)+> fmt::Debug for $target {\n+            gen_display_debug_body! { Print::print_debug }\n+        }\n+    };\n+    ( () $target:ty, debug yes ) => {\n+        impl fmt::Debug for $target {\n+            gen_display_debug_body! { Print::print_debug }\n+        }\n+    };\n+    ( $generic:tt $target:ty, $t:ident no ) => {};\n }\n-\n-fn fn_sig(f: &mut fmt::Formatter,\n-          inputs: &[Ty],\n-          variadic: bool,\n-          output: Ty)\n-          -> fmt::Result {\n-    write!(f, \"(\")?;\n-    let mut inputs = inputs.iter();\n-    if let Some(&ty) = inputs.next() {\n-        write!(f, \"{}\", ty)?;\n-        for &ty in inputs {\n-            write!(f, \", {}\", ty)?;\n+macro_rules! gen_print_impl {\n+    ( ($($x:tt)+) $target:ty, ($self:ident, $f:ident, $cx:ident) $disp:block $dbg:block ) => {\n+        impl<$($x)+> Print for $target {\n+            fn print<F: fmt::Write>(&$self, $f: &mut F, $cx: &mut PrintContext) -> fmt::Result {\n+                if $cx.is_debug $dbg\n+                else $disp\n+            }\n         }\n-        if variadic {\n-            write!(f, \", ...\")?;\n+    };\n+    ( () $target:ty, ($self:ident, $f:ident, $cx:ident) $disp:block $dbg:block ) => {\n+        impl Print for $target {\n+            fn print<F: fmt::Write>(&$self, $f: &mut F, $cx: &mut PrintContext) -> fmt::Result {\n+                if $cx.is_debug $dbg\n+                else $disp\n+            }\n         }\n+    };\n+    ( $generic:tt $target:ty,\n+      $vars:tt $gendisp:ident $disp:block $gendbg:ident $dbg:block ) => {\n+        gen_print_impl! { $generic $target, $vars $disp $dbg }\n+        gen_display_debug! { $generic $target, display $gendisp }\n+        gen_display_debug! { $generic $target, debug $gendbg }\n     }\n-    write!(f, \")\")?;\n-    if !output.is_nil() {\n-        write!(f, \" -> {}\", output)?;\n+}\n+macro_rules! define_print {\n+    ( $generic:tt $target:ty,\n+      $vars:tt { display $disp:block debug $dbg:block } ) => {\n+        gen_print_impl! { $generic $target, $vars yes $disp yes $dbg }\n+    };\n+    ( $generic:tt $target:ty,\n+      $vars:tt { debug $dbg:block display $disp:block } ) => {\n+        gen_print_impl! { $generic $target, $vars yes $disp yes $dbg }\n+    };\n+    ( $generic:tt $target:ty,\n+      $vars:tt { debug $dbg:block } ) => {\n+        gen_print_impl! { $generic $target, $vars no {\n+            bug!(concat!(\"display not implemented for \", stringify!($target)));\n+        } yes $dbg }\n+    };\n+    ( $generic:tt $target:ty,\n+      ($self:ident, $f:ident, $cx:ident) { display $disp:block } ) => {\n+        gen_print_impl! { $generic $target, ($self, $f, $cx) yes $disp no {\n+            write!($f, \"{:?}\", $self)\n+        } }\n+    };\n+}\n+macro_rules! define_print_multi {\n+    ( [ $($generic:tt $target:ty),* ] $vars:tt $def:tt ) => {\n+        $(define_print! { $generic $target, $vars $def })*\n+    };\n+}\n+macro_rules! print_inner {\n+    ( $f:expr, $cx:expr, write ($($data:expr),+) ) => {\n+        write!($f, $($data),+)\n+    };\n+    ( $f:expr, $cx:expr, $kind:ident ($data:expr) ) => {\n+        $data.$kind($f, $cx)\n+    };\n+}\n+macro_rules! print {\n+    ( $f:expr, $cx:expr $(, $kind:ident $data:tt)+ ) => {\n+        Ok(())$(.and_then(|_| print_inner!($f, $cx, $kind $data)))+\n+    };\n+}\n+\n+\n+struct LateBoundRegionNameCollector(FxHashSet<Symbol>);\n+impl<'tcx> ty::fold::TypeVisitor<'tcx> for LateBoundRegionNameCollector {\n+    fn visit_region(&mut self, r: ty::Region<'tcx>) -> bool {\n+        match *r {\n+            ty::ReLateBound(_, ty::BrNamed(_, name)) => {\n+                self.0.insert(name);\n+            },\n+            _ => {},\n+        }\n+        r.super_visit_with(self)\n     }\n+}\n \n-    Ok(())\n+#[derive(Debug)]\n+pub struct PrintContext {\n+    is_debug: bool,\n+    is_verbose: bool,\n+    identify_regions: bool,\n+    used_region_names: Option<FxHashSet<Symbol>>,\n+    region_index: usize,\n+    binder_depth: usize,\n+}\n+impl PrintContext {\n+    fn new() -> Self {\n+        ty::tls::with_opt(|tcx| {\n+            let (is_verbose, identify_regions) = tcx.map(\n+                |tcx| (tcx.sess.verbose(), tcx.sess.opts.debugging_opts.identify_regions)\n+            ).unwrap_or((false, false));\n+            PrintContext {\n+                is_debug: false,\n+                is_verbose: is_verbose,\n+                identify_regions: identify_regions,\n+                used_region_names: None,\n+                region_index: 0,\n+                binder_depth: 0,\n+            }\n+        })\n+    }\n+    fn prepare_late_bound_region_info<'tcx, T>(&mut self, value: &ty::Binder<T>)\n+    where T: TypeFoldable<'tcx>\n+    {\n+        let mut collector = LateBoundRegionNameCollector(FxHashSet());\n+        value.visit_with(&mut collector);\n+        self.used_region_names = Some(collector.0);\n+        self.region_index = 0;\n+    }\n }\n \n-pub fn parameterized(f: &mut fmt::Formatter,\n-                     substs: &subst::Substs,\n-                     mut did: DefId,\n-                     projections: &[ty::ProjectionPredicate])\n-                     -> fmt::Result {\n-    let key = ty::tls::with(|tcx| tcx.def_key(did));\n-    let mut item_name = if let Some(name) = key.disambiguated_data.data.get_opt_name() {\n-        Some(name)\n-    } else {\n-        did.index = key.parent.unwrap_or_else(\n-            || bug!(\"finding type for {:?}, encountered def-id {:?} with no parent\",\n-                    did, did));\n-        parameterized(f, substs, did, projections)?;\n-        return write!(f, \"::{}\", key.disambiguated_data.data.as_interned_str());\n-    };\n+pub trait Print {\n+    fn print<F: fmt::Write>(&self, f: &mut F, cx: &mut PrintContext) -> fmt::Result;\n+    fn print_to_string(&self, cx: &mut PrintContext) -> String {\n+        let mut result = String::new();\n+        let _ = self.print(&mut result, cx);\n+        result\n+    }\n+    fn print_display<F: fmt::Write>(&self, f: &mut F, cx: &mut PrintContext) -> fmt::Result {\n+        let old_debug = cx.is_debug;\n+        cx.is_debug = false;\n+        let result = self.print(f, cx);\n+        cx.is_debug = old_debug;\n+        result\n+    }\n+    fn print_display_to_string(&self, cx: &mut PrintContext) -> String {\n+        let mut result = String::new();\n+        let _ = self.print_display(&mut result, cx);\n+        result\n+    }\n+    fn print_debug<F: fmt::Write>(&self, f: &mut F, cx: &mut PrintContext) -> fmt::Result {\n+        let old_debug = cx.is_debug;\n+        cx.is_debug = true;\n+        let result = self.print(f, cx);\n+        cx.is_debug = old_debug;\n+        result\n+    }\n+    fn print_debug_to_string(&self, cx: &mut PrintContext) -> String {\n+        let mut result = String::new();\n+        let _ = self.print_debug(&mut result, cx);\n+        result\n+    }\n+}\n \n-    let mut verbose = false;\n-    let mut num_supplied_defaults = 0;\n-    let mut has_self = false;\n-    let mut num_regions = 0;\n-    let mut num_types = 0;\n-    let mut is_value_path = false;\n-    let fn_trait_kind = ty::tls::with(|tcx| {\n-        // Unfortunately, some kinds of items (e.g., closures) don't have\n-        // generics. So walk back up the find the closest parent that DOES\n-        // have them.\n-        let mut item_def_id = did;\n-        loop {\n-            let key = tcx.def_key(item_def_id);\n-            match key.disambiguated_data.data {\n-                DefPathData::TypeNs(_) => {\n-                    break;\n-                }\n-                DefPathData::ValueNs(_) | DefPathData::EnumVariant(_) => {\n-                    is_value_path = true;\n-                    break;\n-                }\n-                _ => {\n-                    // if we're making a symbol for something, there ought\n-                    // to be a value or type-def or something in there\n-                    // *somewhere*\n-                    item_def_id.index = key.parent.unwrap_or_else(|| {\n-                        bug!(\"finding type for {:?}, encountered def-id {:?} with no \\\n-                             parent\", did, item_def_id);\n-                    });\n-                }\n+impl PrintContext {\n+    fn fn_sig<F: fmt::Write>(&mut self,\n+                             f: &mut F,\n+                             inputs: &[Ty],\n+                             variadic: bool,\n+                             output: Ty)\n+                             -> fmt::Result {\n+        write!(f, \"(\")?;\n+        let mut inputs = inputs.iter();\n+        if let Some(&ty) = inputs.next() {\n+            print!(f, self, print_display(ty))?;\n+            for &ty in inputs {\n+                print!(f, self, write(\", \"), print_display(ty))?;\n+            }\n+            if variadic {\n+                write!(f, \", ...\")?;\n             }\n         }\n-        let mut generics = tcx.generics_of(item_def_id);\n-        let mut path_def_id = did;\n-        verbose = tcx.sess.verbose();\n-        has_self = generics.has_self;\n-\n-        let mut child_types = 0;\n-        if let Some(def_id) = generics.parent {\n-            // Methods.\n-            assert!(is_value_path);\n-            child_types = generics.types.len();\n-            generics = tcx.generics_of(def_id);\n-            num_regions = generics.regions.len();\n-            num_types = generics.types.len();\n+        write!(f, \")\")?;\n+        if !output.is_nil() {\n+            print!(f, self, write(\" -> \"), print_display(output))?;\n+        }\n \n-            if has_self {\n-                write!(f, \"<{} as \", substs.type_at(0))?;\n-            }\n+        Ok(())\n+    }\n \n-            path_def_id = def_id;\n+    fn parameterized<F: fmt::Write>(&mut self,\n+                                    f: &mut F,\n+                                    substs: &subst::Substs,\n+                                    mut did: DefId,\n+                                    projections: &[ty::ProjectionPredicate])\n+                                    -> fmt::Result {\n+        let key = ty::tls::with(|tcx| tcx.def_key(did));\n+        let mut item_name = if let Some(name) = key.disambiguated_data.data.get_opt_name() {\n+            Some(name)\n         } else {\n-            item_name = None;\n-\n-            if is_value_path {\n-                // Functions.\n-                assert_eq!(has_self, false);\n-            } else {\n-                // Types and traits.\n+            did.index = key.parent.unwrap_or_else(\n+                || bug!(\"finding type for {:?}, encountered def-id {:?} with no parent\",\n+                        did, did));\n+            self.parameterized(f, substs, did, projections)?;\n+            return write!(f, \"::{}\", key.disambiguated_data.data.as_interned_str());\n+        };\n+\n+        let verbose = self.is_verbose;\n+        let mut num_supplied_defaults = 0;\n+        let mut has_self = false;\n+        let mut num_regions = 0;\n+        let mut num_types = 0;\n+        let mut is_value_path = false;\n+        let fn_trait_kind = ty::tls::with(|tcx| {\n+            // Unfortunately, some kinds of items (e.g., closures) don't have\n+            // generics. So walk back up the find the closest parent that DOES\n+            // have them.\n+            let mut item_def_id = did;\n+            loop {\n+                let key = tcx.def_key(item_def_id);\n+                match key.disambiguated_data.data {\n+                    DefPathData::TypeNs(_) => {\n+                        break;\n+                    }\n+                    DefPathData::ValueNs(_) | DefPathData::EnumVariant(_) => {\n+                        is_value_path = true;\n+                        break;\n+                    }\n+                    _ => {\n+                        // if we're making a symbol for something, there ought\n+                        // to be a value or type-def or something in there\n+                        // *somewhere*\n+                        item_def_id.index = key.parent.unwrap_or_else(|| {\n+                            bug!(\"finding type for {:?}, encountered def-id {:?} with no \\\n+                                 parent\", did, item_def_id);\n+                        });\n+                    }\n+                }\n+            }\n+            let mut generics = tcx.generics_of(item_def_id);\n+            let mut path_def_id = did;\n+            has_self = generics.has_self;\n+\n+            let mut child_types = 0;\n+            if let Some(def_id) = generics.parent {\n+                // Methods.\n+                assert!(is_value_path);\n+                child_types = generics.types.len();\n+                generics = tcx.generics_of(def_id);\n                 num_regions = generics.regions.len();\n                 num_types = generics.types.len();\n+\n+                if has_self {\n+                    print!(f, self, write(\"<\"), print_display(substs.type_at(0)), write(\" as \"))?;\n+                }\n+\n+                path_def_id = def_id;\n+            } else {\n+                item_name = None;\n+\n+                if is_value_path {\n+                    // Functions.\n+                    assert_eq!(has_self, false);\n+                } else {\n+                    // Types and traits.\n+                    num_regions = generics.regions.len();\n+                    num_types = generics.types.len();\n+                }\n             }\n-        }\n \n-        if !verbose {\n-            if generics.types.last().map_or(false, |def| def.has_default) {\n-                if let Some(substs) = tcx.lift(&substs) {\n-                    let tps = substs.types().rev().skip(child_types);\n-                    for (def, actual) in generics.types.iter().rev().zip(tps) {\n-                        if !def.has_default {\n-                            break;\n-                        }\n-                        if tcx.type_of(def.def_id).subst(tcx, substs) != actual {\n-                            break;\n+            if !verbose {\n+                if generics.types.last().map_or(false, |def| def.has_default) {\n+                    if let Some(substs) = tcx.lift(&substs) {\n+                        let tps = substs.types().rev().skip(child_types);\n+                        for (def, actual) in generics.types.iter().rev().zip(tps) {\n+                            if !def.has_default {\n+                                break;\n+                            }\n+                            if tcx.type_of(def.def_id).subst(tcx, substs) != actual {\n+                                break;\n+                            }\n+                            num_supplied_defaults += 1;\n                         }\n-                        num_supplied_defaults += 1;\n                     }\n                 }\n             }\n-        }\n \n-        write!(f, \"{}\", tcx.item_path_str(path_def_id))?;\n-        Ok(tcx.lang_items().fn_trait_kind(path_def_id))\n-    })?;\n+            print!(f, self, write(\"{}\", tcx.item_path_str(path_def_id)))?;\n+            Ok(tcx.lang_items().fn_trait_kind(path_def_id))\n+        })?;\n \n-    if !verbose && fn_trait_kind.is_some() && projections.len() == 1 {\n-        let projection_ty = projections[0].ty;\n-        if let TyTuple(ref args, _) = substs.type_at(1).sty {\n-            return fn_sig(f, args, false, projection_ty);\n+        if !verbose && fn_trait_kind.is_some() && projections.len() == 1 {\n+            let projection_ty = projections[0].ty;\n+            if let TyTuple(ref args, _) = substs.type_at(1).sty {\n+                return self.fn_sig(f, args, false, projection_ty);\n+            }\n         }\n-    }\n \n-    let empty = Cell::new(true);\n-    let start_or_continue = |f: &mut fmt::Formatter, start: &str, cont: &str| {\n-        if empty.get() {\n-            empty.set(false);\n-            write!(f, \"{}\", start)\n-        } else {\n-            write!(f, \"{}\", cont)\n-        }\n-    };\n+        let empty = Cell::new(true);\n+        let start_or_continue = |f: &mut F, start: &str, cont: &str| {\n+            if empty.get() {\n+                empty.set(false);\n+                write!(f, \"{}\", start)\n+            } else {\n+                write!(f, \"{}\", cont)\n+            }\n+        };\n \n-    let print_regions = |f: &mut fmt::Formatter, start: &str, skip, count| {\n-        // Don't print any regions if they're all erased.\n-        let regions = || substs.regions().skip(skip).take(count);\n-        if regions().all(|r: ty::Region| *r == ty::ReErased) {\n-            return Ok(());\n-        }\n+        let print_regions = |f: &mut F, start: &str, skip, count| {\n+            // Don't print any regions if they're all erased.\n+            let regions = || substs.regions().skip(skip).take(count);\n+            if regions().all(|r: ty::Region| *r == ty::ReErased) {\n+                return Ok(());\n+            }\n \n-        for region in regions() {\n-            let region: ty::Region = region;\n-            start_or_continue(f, start, \", \")?;\n-            if verbose {\n-                write!(f, \"{:?}\", region)?;\n-            } else {\n-                let s = region.to_string();\n-                if s.is_empty() {\n-                    // This happens when the value of the region\n-                    // parameter is not easily serialized. This may be\n-                    // because the user omitted it in the first place,\n-                    // or because it refers to some block in the code,\n-                    // etc. I'm not sure how best to serialize this.\n-                    write!(f, \"'_\")?;\n+            for region in regions() {\n+                let region: ty::Region = region;\n+                start_or_continue(f, start, \", \")?;\n+                if verbose {\n+                    write!(f, \"{:?}\", region)?;\n                 } else {\n-                    write!(f, \"{}\", s)?;\n+                    let s = region.to_string();\n+                    if s.is_empty() {\n+                        // This happens when the value of the region\n+                        // parameter is not easily serialized. This may be\n+                        // because the user omitted it in the first place,\n+                        // or because it refers to some block in the code,\n+                        // etc. I'm not sure how best to serialize this.\n+                        write!(f, \"'_\")?;\n+                    } else {\n+                        write!(f, \"{}\", s)?;\n+                    }\n                 }\n             }\n-        }\n-\n-        Ok(())\n-    };\n-\n-    print_regions(f, \"<\", 0, num_regions)?;\n \n-    let tps = substs.types().take(num_types - num_supplied_defaults)\n-                            .skip(has_self as usize);\n-\n-    for ty in tps {\n-        start_or_continue(f, \"<\", \", \")?;\n-        write!(f, \"{}\", ty)?;\n-    }\n-\n-    for projection in projections {\n-        start_or_continue(f, \"<\", \", \")?;\n-        ty::tls::with(|tcx|\n-            write!(f, \"{}={}\",\n-            tcx.associated_item(projection.projection_ty.item_def_id).name,\n-            projection.ty)\n-        )?;\n-    }\n+            Ok(())\n+        };\n \n-    start_or_continue(f, \"\", \">\")?;\n+        print_regions(f, \"<\", 0, num_regions)?;\n \n-    // For values, also print their name and type parameters.\n-    if is_value_path {\n-        empty.set(true);\n+        let tps = substs.types().take(num_types - num_supplied_defaults)\n+                                .skip(has_self as usize);\n \n-        if has_self {\n-            write!(f, \">\")?;\n+        for ty in tps {\n+            start_or_continue(f, \"<\", \", \")?;\n+            ty.print_display(f, self)?;\n         }\n \n-        if let Some(item_name) = item_name {\n-            write!(f, \"::{}\", item_name)?;\n+        for projection in projections {\n+            start_or_continue(f, \"<\", \", \")?;\n+            ty::tls::with(|tcx|\n+                print!(f, self,\n+                       write(\"{}=\",\n+                             tcx.associated_item(projection.projection_ty.item_def_id).name),\n+                       print_display(projection.ty))\n+            )?;\n         }\n \n-        print_regions(f, \"::<\", num_regions, usize::MAX)?;\n+        start_or_continue(f, \"\", \">\")?;\n \n-        // FIXME: consider being smart with defaults here too\n-        for ty in substs.types().skip(num_types) {\n-            start_or_continue(f, \"::<\", \", \")?;\n-            write!(f, \"{}\", ty)?;\n-        }\n+        // For values, also print their name and type parameters.\n+        if is_value_path {\n+            empty.set(true);\n \n-        start_or_continue(f, \"\", \">\")?;\n-    }\n+            if has_self {\n+                write!(f, \">\")?;\n+            }\n \n-    Ok(())\n-}\n+            if let Some(item_name) = item_name {\n+                write!(f, \"::{}\", item_name)?;\n+            }\n \n-struct LateBoundRegionNameCollector(FxHashSet<Symbol>);\n+            print_regions(f, \"::<\", num_regions, usize::MAX)?;\n \n-impl<'tcx> ty::fold::TypeVisitor<'tcx> for LateBoundRegionNameCollector {\n-    fn visit_region(&mut self, r: ty::Region<'tcx>) -> bool {\n-        match *r {\n-            ty::ReLateBound(_, ty::BrNamed(_, name)) => {\n-                self.0.insert(name);\n-            },\n-            _ => {},\n-        }\n-        r.super_visit_with(self)\n-    }\n-}\n+            // FIXME: consider being smart with defaults here too\n+            for ty in substs.types().skip(num_types) {\n+                start_or_continue(f, \"::<\", \", \")?;\n+                ty.print_display(f, self)?;\n+            }\n \n-fn in_binder<'a, 'gcx, 'tcx, T, U>(f: &mut fmt::Formatter,\n-                                   tcx: TyCtxt<'a, 'gcx, 'tcx>,\n-                                   original: &ty::Binder<T>,\n-                                   lifted: Option<ty::Binder<U>>) -> fmt::Result\n-    where T: fmt::Display, U: fmt::Display + TypeFoldable<'tcx>\n-{\n-    fn name_by_region_index(index: usize) -> Symbol {\n-        match index {\n-            0 => Symbol::intern(\"'r\"),\n-            1 => Symbol::intern(\"'s\"),\n-            i => Symbol::intern(&format!(\"'t{}\", i-2)),\n+            start_or_continue(f, \"\", \">\")?;\n         }\n+\n+        Ok(())\n     }\n \n-    // Replace any anonymous late-bound regions with named\n-    // variants, using gensym'd identifiers, so that we can\n-    // clearly differentiate between named and unnamed regions in\n-    // the output. We'll probably want to tweak this over time to\n-    // decide just how much information to give.\n-    let value = if let Some(v) = lifted {\n-        v\n-    } else {\n-        return write!(f, \"{}\", original.0);\n-    };\n+    fn in_binder<'a, 'gcx, 'tcx, T, U, F>(&mut self,\n+                                          f: &mut F,\n+                                          tcx: TyCtxt<'a, 'gcx, 'tcx>,\n+                                          original: &ty::Binder<T>,\n+                                          lifted: Option<ty::Binder<U>>) -> fmt::Result\n+        where T: Print, U: Print + TypeFoldable<'tcx>, F: fmt::Write\n+    {\n+        fn name_by_region_index(index: usize) -> Symbol {\n+            match index {\n+                0 => Symbol::intern(\"'r\"),\n+                1 => Symbol::intern(\"'s\"),\n+                i => Symbol::intern(&format!(\"'t{}\", i-2)),\n+            }\n+        }\n \n-    let mut empty = true;\n-    let mut start_or_continue = |f: &mut fmt::Formatter, start: &str, cont: &str| {\n-        if empty {\n-            empty = false;\n-            write!(f, \"{}\", start)\n+        // Replace any anonymous late-bound regions with named\n+        // variants, using gensym'd identifiers, so that we can\n+        // clearly differentiate between named and unnamed regions in\n+        // the output. We'll probably want to tweak this over time to\n+        // decide just how much information to give.\n+        let value = if let Some(v) = lifted {\n+            v\n         } else {\n-            write!(f, \"{}\", cont)\n+            return original.0.print_display(f, self);\n+        };\n+\n+        if self.binder_depth == 0 {\n+            self.prepare_late_bound_region_info(&value);\n         }\n-    };\n \n-    // If displaying is just started, collect named late-bound regions.\n-    let display_just_started = tcx.display_used_late_bound_region_names.borrow().is_none();\n-    if display_just_started {\n-        let mut collector = LateBoundRegionNameCollector(FxHashSet());\n-        value.visit_with(&mut collector);\n-        *tcx.display_used_late_bound_region_names.borrow_mut() = Some(collector.0);\n-    }\n+        let mut empty = true;\n+        let mut start_or_continue = |f: &mut F, start: &str, cont: &str| {\n+            if empty {\n+                empty = false;\n+                write!(f, \"{}\", start)\n+            } else {\n+                write!(f, \"{}\", cont)\n+            }\n+        };\n \n-    let old_region_index = tcx.display_late_bound_region_index.get();\n-    let mut region_index = old_region_index;\n-    let new_value = {\n-        let used_region_names = tcx.display_used_late_bound_region_names.borrow();\n-        let used_region_names = used_region_names.as_ref().unwrap();\n-        tcx.replace_late_bound_regions(&value, |br| {\n+        let old_region_index = self.region_index;\n+        let mut region_index = old_region_index;\n+        let new_value = tcx.replace_late_bound_regions(&value, |br| {\n             let _ = start_or_continue(f, \"for<\", \", \");\n             let br = match br {\n                 ty::BrNamed(_, name) => {\n@@ -335,7 +488,7 @@ fn in_binder<'a, 'gcx, 'tcx, T, U>(f: &mut fmt::Formatter,\n                     let name = loop {\n                         let name = name_by_region_index(region_index);\n                         region_index += 1;\n-                        if !used_region_names.contains(&name) {\n+                        if !self.is_name_used(&name) {\n                             break name;\n                         }\n                     };\n@@ -345,47 +498,78 @@ fn in_binder<'a, 'gcx, 'tcx, T, U>(f: &mut fmt::Formatter,\n                 }\n             };\n             tcx.mk_region(ty::ReLateBound(ty::DebruijnIndex::new(1), br))\n-        }).0\n-    };\n-    start_or_continue(f, \"\", \"> \")?;\n-\n-    // Push current state to gcx, and restore after writing new_value.\n-    tcx.display_late_bound_region_index.set(region_index);\n-    write!(f, \"{}\", new_value)?;\n-    tcx.display_late_bound_region_index.set(old_region_index);\n-    if display_just_started {\n-        *tcx.display_used_late_bound_region_names.borrow_mut() = None;\n+        }).0;\n+        start_or_continue(f, \"\", \"> \")?;\n+\n+        // Push current state to gcx, and restore after writing new_value.\n+        self.binder_depth += 1;\n+        self.region_index = region_index;\n+        let result = new_value.print_display(f, self);\n+        self.region_index = old_region_index;\n+        self.binder_depth -= 1;\n+        result\n+    }\n+\n+    fn is_name_used(&self, name: &Symbol) -> bool {\n+        match self.used_region_names {\n+            Some(ref names) => names.contains(name),\n+            None => false,\n+        }\n     }\n-    Ok(())\n }\n \n-impl<'tcx> fmt::Display for &'tcx ty::Slice<ty::ExistentialPredicate<'tcx>> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        // Generate the main trait ref, including associated types.\n-        ty::tls::with(|tcx| {\n-            // Use a type that can't appear in defaults of type parameters.\n-            let dummy_self = tcx.mk_infer(ty::FreshTy(0));\n-\n-            if let Some(p) = self.principal() {\n-                let principal = tcx.lift(&p).expect(\"could not lift TraitRef for printing\")\n-                    .with_self_ty(tcx, dummy_self);\n-                let projections = self.projection_bounds().map(|p| {\n-                    tcx.lift(&p)\n-                        .expect(\"could not lift projection for printing\")\n-                        .with_self_ty(tcx, dummy_self)\n-                }).collect::<Vec<_>>();\n-                parameterized(f, principal.substs, principal.def_id, &projections)?;\n-            }\n+pub fn verbose() -> bool {\n+    ty::tls::with(|tcx| tcx.sess.verbose())\n+}\n \n-            // Builtin bounds.\n-            for did in self.auto_traits() {\n-                write!(f, \" + {}\", tcx.item_path_str(did))?;\n-            }\n+pub fn identify_regions() -> bool {\n+    ty::tls::with(|tcx| tcx.sess.opts.debugging_opts.identify_regions)\n+}\n \n-            Ok(())\n-        })?;\n+pub fn parameterized<F: fmt::Write>(f: &mut F,\n+                                    substs: &subst::Substs,\n+                                    did: DefId,\n+                                    projections: &[ty::ProjectionPredicate])\n+                                    -> fmt::Result {\n+    PrintContext::new().parameterized(f, substs, did, projections)\n+}\n \n-        Ok(())\n+\n+impl<'a, T: Print> Print for &'a T {\n+    fn print<F: fmt::Write>(&self, f: &mut F, cx: &mut PrintContext) -> fmt::Result {\n+        (*self).print(f, cx)\n+    }\n+}\n+\n+define_print! {\n+    ('tcx) &'tcx ty::Slice<ty::ExistentialPredicate<'tcx>>, (self, f, cx) {\n+        display {\n+            // Generate the main trait ref, including associated types.\n+            ty::tls::with(|tcx| {\n+                // Use a type that can't appear in defaults of type parameters.\n+                let dummy_self = tcx.mk_infer(ty::FreshTy(0));\n+\n+                if let Some(p) = self.principal() {\n+                    let principal = tcx.lift(&p).expect(\"could not lift TraitRef for printing\")\n+                        .with_self_ty(tcx, dummy_self);\n+                    let projections = self.projection_bounds().map(|p| {\n+                        tcx.lift(&p)\n+                            .expect(\"could not lift projection for printing\")\n+                            .with_self_ty(tcx, dummy_self)\n+                    }).collect::<Vec<_>>();\n+                    cx.parameterized(f, principal.substs, principal.def_id, &projections)?;\n+                }\n+\n+                // Builtin bounds.\n+                for did in self.auto_traits() {\n+                    write!(f, \" + {}\", tcx.item_path_str(did))?;\n+                }\n+\n+                Ok(())\n+            })?;\n+\n+            Ok(())\n+        }\n     }\n }\n \n@@ -407,42 +591,6 @@ impl fmt::Debug for ty::RegionParameterDef {\n     }\n }\n \n-impl<'tcx> fmt::Debug for ty::TyS<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}\", *self)\n-    }\n-}\n-\n-impl<'tcx> fmt::Display for ty::TypeAndMut<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}{}\",\n-               if self.mutbl == hir::MutMutable { \"mut \" } else { \"\" },\n-               self.ty)\n-    }\n-}\n-\n-impl<'tcx> fmt::Debug for ty::TraitRef<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        // when printing out the debug representation, we don't need\n-        // to enumerate the `for<...>` etc because the debruijn index\n-        // tells you everything you need to know.\n-        write!(f, \"<{:?} as {}>\", self.self_ty(), *self)\n-    }\n-}\n-\n-impl<'tcx> fmt::Debug for ty::ExistentialTraitRef<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        ty::tls::with(|tcx| {\n-            let dummy_self = tcx.mk_infer(ty::FreshTy(0));\n-\n-            let trait_ref = tcx.lift(&ty::Binder(*self))\n-                               .expect(\"could not lift TraitRef for printing\")\n-                               .with_self_ty(tcx, dummy_self).0;\n-            parameterized(f, trait_ref.substs, trait_ref.def_id, &[])\n-        })\n-    }\n-}\n-\n impl fmt::Debug for ty::TraitDef {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         ty::tls::with(|tcx| {\n@@ -459,196 +607,226 @@ impl fmt::Debug for ty::AdtDef {\n     }\n }\n \n-impl<'tcx> fmt::Debug for ty::adjustment::Adjustment<'tcx> {\n+impl<'tcx> fmt::Debug for ty::ClosureUpvar<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{:?} -> {}\", self.kind, self.target)\n+        write!(f, \"ClosureUpvar({:?},{:?})\",\n+               self.def,\n+               self.ty)\n     }\n }\n \n-impl<'tcx> fmt::Debug for ty::Predicate<'tcx> {\n+impl fmt::Debug for ty::UpvarId {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            ty::Predicate::Trait(ref a) => write!(f, \"{:?}\", a),\n-            ty::Predicate::Equate(ref pair) => write!(f, \"{:?}\", pair),\n-            ty::Predicate::Subtype(ref pair) => write!(f, \"{:?}\", pair),\n-            ty::Predicate::RegionOutlives(ref pair) => write!(f, \"{:?}\", pair),\n-            ty::Predicate::TypeOutlives(ref pair) => write!(f, \"{:?}\", pair),\n-            ty::Predicate::Projection(ref pair) => write!(f, \"{:?}\", pair),\n-            ty::Predicate::WellFormed(ty) => write!(f, \"WF({:?})\", ty),\n-            ty::Predicate::ObjectSafe(trait_def_id) => {\n-                write!(f, \"ObjectSafe({:?})\", trait_def_id)\n-            }\n-            ty::Predicate::ClosureKind(closure_def_id, kind) => {\n-                write!(f, \"ClosureKind({:?}, {:?})\", closure_def_id, kind)\n-            }\n-            ty::Predicate::ConstEvaluatable(def_id, substs) => {\n-                write!(f, \"ConstEvaluatable({:?}, {:?})\", def_id, substs)\n-            }\n-        }\n+        write!(f, \"UpvarId({:?};`{}`;{:?})\",\n+               self.var_id,\n+               ty::tls::with(|tcx| tcx.hir.name(tcx.hir.hir_to_node_id(self.var_id))),\n+               self.closure_expr_id)\n     }\n }\n \n-impl fmt::Display for ty::BoundRegion {\n+impl<'tcx> fmt::Debug for ty::UpvarBorrow<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        if verbose() {\n-            return write!(f, \"{:?}\", *self);\n+        write!(f, \"UpvarBorrow({:?}, {:?})\",\n+               self.kind, self.region)\n+    }\n+}\n+\n+define_print! {\n+    ('tcx) ty::TypeAndMut<'tcx>, (self, f, cx) {\n+        display {\n+            print!(f, cx,\n+                   write(\"{}\", if self.mutbl == hir::MutMutable { \"mut \" } else { \"\" }),\n+                   print(self.ty))\n         }\n+    }\n+}\n \n-        match *self {\n-            BrNamed(_, name) => write!(f, \"{}\", name),\n-            BrAnon(_) | BrFresh(_) | BrEnv => Ok(())\n+define_print! {\n+    ('tcx) ty::ExistentialTraitRef<'tcx>, (self, f, cx) {\n+        debug {\n+            ty::tls::with(|tcx| {\n+                let dummy_self = tcx.mk_infer(ty::FreshTy(0));\n+\n+                let trait_ref = tcx.lift(&ty::Binder(*self))\n+                                   .expect(\"could not lift TraitRef for printing\")\n+                                   .with_self_ty(tcx, dummy_self).0;\n+                cx.parameterized(f, trait_ref.substs, trait_ref.def_id, &[])\n+            })\n         }\n     }\n }\n \n-impl fmt::Debug for ty::BoundRegion {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            BrAnon(n) => write!(f, \"BrAnon({:?})\", n),\n-            BrFresh(n) => write!(f, \"BrFresh({:?})\", n),\n-            BrNamed(did, name) => {\n-                write!(f, \"BrNamed({:?}:{:?}, {:?})\",\n-                       did.krate, did.index, name)\n-            }\n-            BrEnv => \"BrEnv\".fmt(f),\n+define_print! {\n+    ('tcx) ty::adjustment::Adjustment<'tcx>, (self, f, cx) {\n+        debug {\n+            print!(f, cx, write(\"{:?} -> \", self.kind), print(self.target))\n         }\n     }\n }\n \n-impl fmt::Debug for ty::RegionKind {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            ty::ReEarlyBound(ref data) => {\n-                write!(f, \"ReEarlyBound({}, {})\",\n-                       data.index,\n-                       data.name)\n+define_print! {\n+    () ty::BoundRegion, (self, f, cx) {\n+        display {\n+            if cx.is_verbose {\n+                return self.print_debug(f, cx);\n             }\n \n-            ty::ReLateBound(binder_id, ref bound_region) => {\n-                write!(f, \"ReLateBound({:?}, {:?})\",\n-                       binder_id,\n-                       bound_region)\n+            match *self {\n+                BrNamed(_, name) => write!(f, \"{}\", name),\n+                BrAnon(_) | BrFresh(_) | BrEnv => Ok(())\n             }\n+        }\n+        debug {\n+            return match *self {\n+                BrAnon(n) => write!(f, \"BrAnon({:?})\", n),\n+                BrFresh(n) => write!(f, \"BrFresh({:?})\", n),\n+                BrNamed(did, name) => {\n+                    write!(f, \"BrNamed({:?}:{:?}, {:?})\",\n+                           did.krate, did.index, name)\n+                }\n+                BrEnv => write!(f, \"BrEnv\"),\n+            };\n+        }\n+    }\n+}\n \n-            ty::ReFree(ref fr) => write!(f, \"{:?}\", fr),\n-\n-            ty::ReScope(id) => {\n-                write!(f, \"ReScope({:?})\", id)\n+define_print! {\n+    () ty::RegionKind, (self, f, cx) {\n+        display {\n+            if cx.is_verbose {\n+                return self.print_debug(f, cx);\n             }\n \n-            ty::ReStatic => write!(f, \"ReStatic\"),\n-\n-            ty::ReVar(ref vid) => {\n-                write!(f, \"{:?}\", vid)\n+            // These printouts are concise.  They do not contain all the information\n+            // the user might want to diagnose an error, but there is basically no way\n+            // to fit that into a short string.  Hence the recommendation to use\n+            // `explain_region()` or `note_and_explain_region()`.\n+            match *self {\n+                ty::ReEarlyBound(ref data) => {\n+                    write!(f, \"{}\", data.name)\n+                }\n+                ty::ReLateBound(_, br) |\n+                ty::ReFree(ty::FreeRegion { bound_region: br, .. }) |\n+                ty::ReSkolemized(_, br) => {\n+                    write!(f, \"{}\", br)\n+                }\n+                ty::ReScope(scope) if cx.identify_regions => {\n+                    match scope.data() {\n+                        region::ScopeData::Node(id) =>\n+                            write!(f, \"'{}s\", id.as_usize()),\n+                        region::ScopeData::CallSite(id) =>\n+                            write!(f, \"'{}cs\", id.as_usize()),\n+                        region::ScopeData::Arguments(id) =>\n+                            write!(f, \"'{}as\", id.as_usize()),\n+                        region::ScopeData::Destruction(id) =>\n+                            write!(f, \"'{}ds\", id.as_usize()),\n+                        region::ScopeData::Remainder(BlockRemainder\n+                                                     { block, first_statement_index }) =>\n+                            write!(f, \"'{}_{}rs\", block.as_usize(), first_statement_index.index()),\n+                    }\n+                }\n+                ty::ReVar(region_vid) if cx.identify_regions => {\n+                    write!(f, \"'{}rv\", region_vid.index)\n+                }\n+                ty::ReScope(_) |\n+                ty::ReVar(_) |\n+                ty::ReErased => Ok(()),\n+                ty::ReStatic => write!(f, \"'static\"),\n+                ty::ReEmpty => write!(f, \"'<empty>\"),\n             }\n+        }\n+        debug {\n+            match *self {\n+                ty::ReEarlyBound(ref data) => {\n+                    write!(f, \"ReEarlyBound({}, {})\",\n+                           data.index,\n+                           data.name)\n+                }\n \n-            ty::ReSkolemized(id, ref bound_region) => {\n-                write!(f, \"ReSkolemized({}, {:?})\", id.index, bound_region)\n-            }\n+                ty::ReLateBound(binder_id, ref bound_region) => {\n+                    write!(f, \"ReLateBound({:?}, {:?})\",\n+                           binder_id,\n+                           bound_region)\n+                }\n \n-            ty::ReEmpty => write!(f, \"ReEmpty\"),\n+                ty::ReFree(ref fr) => write!(f, \"{:?}\", fr),\n \n-            ty::ReErased => write!(f, \"ReErased\")\n-        }\n-    }\n-}\n+                ty::ReScope(id) => {\n+                    write!(f, \"ReScope({:?})\", id)\n+                }\n \n-impl<'tcx> fmt::Debug for ty::ClosureUpvar<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"ClosureUpvar({:?},{:?})\",\n-               self.def,\n-               self.ty)\n-    }\n-}\n+                ty::ReStatic => write!(f, \"ReStatic\"),\n \n-impl fmt::Display for ty::RegionKind {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        if verbose() {\n-            return write!(f, \"{:?}\", *self);\n-        }\n+                ty::ReVar(ref vid) => {\n+                    write!(f, \"{:?}\", vid)\n+                }\n \n-        // These printouts are concise.  They do not contain all the information\n-        // the user might want to diagnose an error, but there is basically no way\n-        // to fit that into a short string.  Hence the recommendation to use\n-        // `explain_region()` or `note_and_explain_region()`.\n-        match *self {\n-            ty::ReEarlyBound(ref data) => {\n-                write!(f, \"{}\", data.name)\n-            }\n-            ty::ReLateBound(_, br) |\n-            ty::ReFree(ty::FreeRegion { bound_region: br, .. }) |\n-            ty::ReSkolemized(_, br) => {\n-                write!(f, \"{}\", br)\n-            }\n-            ty::ReScope(scope) if identify_regions() => {\n-                match scope.data() {\n-                    region::ScopeData::Node(id) =>\n-                        write!(f, \"'{}s\", id.as_usize()),\n-                    region::ScopeData::CallSite(id) =>\n-                        write!(f, \"'{}cs\", id.as_usize()),\n-                    region::ScopeData::Arguments(id) =>\n-                        write!(f, \"'{}as\", id.as_usize()),\n-                    region::ScopeData::Destruction(id) =>\n-                        write!(f, \"'{}ds\", id.as_usize()),\n-                    region::ScopeData::Remainder(BlockRemainder { block, first_statement_index }) =>\n-                        write!(f, \"'{}_{}rs\", block.as_usize(), first_statement_index.index()),\n+                ty::ReSkolemized(id, ref bound_region) => {\n+                    write!(f, \"ReSkolemized({}, {:?})\", id.index, bound_region)\n                 }\n+\n+                ty::ReEmpty => write!(f, \"ReEmpty\"),\n+\n+                ty::ReErased => write!(f, \"ReErased\")\n             }\n-            ty::ReVar(region_vid) if identify_regions() => {\n-                write!(f, \"'{}rv\", region_vid.index)\n-            }\n-            ty::ReScope(_) |\n-            ty::ReVar(_) |\n-            ty::ReErased => Ok(()),\n-            ty::ReStatic => write!(f, \"'static\"),\n-            ty::ReEmpty => write!(f, \"'<empty>\"),\n         }\n     }\n }\n \n-impl fmt::Debug for ty::FreeRegion {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"ReFree({:?}, {:?})\",\n-               self.scope, self.bound_region)\n+define_print! {\n+    () ty::FreeRegion, (self, f, cx) {\n+        debug {\n+            write!(f, \"ReFree({:?}, {:?})\", self.scope, self.bound_region)\n+        }\n     }\n }\n \n-impl fmt::Debug for ty::Variance {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        f.write_str(match *self {\n-            ty::Covariant => \"+\",\n-            ty::Contravariant => \"-\",\n-            ty::Invariant => \"o\",\n-            ty::Bivariant => \"*\",\n-        })\n+define_print! {\n+    () ty::Variance, (self, f, cx) {\n+        debug {\n+            f.write_str(match *self {\n+                ty::Covariant => \"+\",\n+                ty::Contravariant => \"-\",\n+                ty::Invariant => \"o\",\n+                ty::Bivariant => \"*\",\n+            })\n+        }\n     }\n }\n \n-impl<'tcx> fmt::Debug for ty::GenericPredicates<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"GenericPredicates({:?})\", self.predicates)\n+define_print! {\n+    ('tcx) ty::GenericPredicates<'tcx>, (self, f, cx) {\n+        debug {\n+            write!(f, \"GenericPredicates({:?})\", self.predicates)\n+        }\n     }\n }\n \n-impl<'tcx> fmt::Debug for ty::InstantiatedPredicates<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"InstantiatedPredicates({:?})\",\n-               self.predicates)\n+define_print! {\n+    ('tcx) ty::InstantiatedPredicates<'tcx>, (self, f, cx) {\n+        debug {\n+            write!(f, \"InstantiatedPredicates({:?})\", self.predicates)\n+        }\n     }\n }\n \n-impl<'tcx> fmt::Display for ty::FnSig<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        if self.unsafety == hir::Unsafety::Unsafe {\n-            write!(f, \"unsafe \")?;\n-        }\n+define_print! {\n+    ('tcx) ty::FnSig<'tcx>, (self, f, cx) {\n+        display {\n+            if self.unsafety == hir::Unsafety::Unsafe {\n+                write!(f, \"unsafe \")?;\n+            }\n \n-        if self.abi != Abi::Rust {\n-            write!(f, \"extern {} \", self.abi)?;\n-        }\n+            if self.abi != Abi::Rust {\n+                write!(f, \"extern {} \", self.abi)?;\n+            }\n \n-        write!(f, \"fn\")?;\n-        fn_sig(f, self.inputs(), self.variadic, self.output())\n+            write!(f, \"fn\")?;\n+            cx.fn_sig(f, self.inputs(), self.variadic, self.output())\n+        }\n+        debug {\n+            write!(f, \"({:?}; variadic: {})->{:?}\", self.inputs(), self.variadic, self.output())\n+        }\n     }\n }\n \n@@ -676,21 +854,27 @@ impl fmt::Debug for ty::RegionVid {\n     }\n }\n \n-impl<'tcx> fmt::Debug for ty::FnSig<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"({:?}; variadic: {})->{:?}\", self.inputs(), self.variadic, self.output())\n-    }\n-}\n-\n-impl fmt::Debug for ty::InferTy {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            ty::TyVar(ref v) => v.fmt(f),\n-            ty::IntVar(ref v) => v.fmt(f),\n-            ty::FloatVar(ref v) => v.fmt(f),\n-            ty::FreshTy(v) => write!(f, \"FreshTy({:?})\", v),\n-            ty::FreshIntTy(v) => write!(f, \"FreshIntTy({:?})\", v),\n-            ty::FreshFloatTy(v) => write!(f, \"FreshFloatTy({:?})\", v)\n+define_print! {\n+    () ty::InferTy, (self, f, cx) {\n+        display {\n+            match *self {\n+                ty::TyVar(_) => write!(f, \"_\"),\n+                ty::IntVar(_) => write!(f, \"{}\", \"{integer}\"),\n+                ty::FloatVar(_) => write!(f, \"{}\", \"{float}\"),\n+                ty::FreshTy(v) => write!(f, \"FreshTy({})\", v),\n+                ty::FreshIntTy(v) => write!(f, \"FreshIntTy({})\", v),\n+                ty::FreshFloatTy(v) => write!(f, \"FreshFloatTy({})\", v)\n+            }\n+        }\n+        debug {\n+            match *self {\n+                ty::TyVar(ref v) => write!(f, \"{:?}\", v),\n+                ty::IntVar(ref v) => write!(f, \"{:?}\", v),\n+                ty::FloatVar(ref v) => write!(f, \"{:?}\", v),\n+                ty::FreshTy(v) => write!(f, \"FreshTy({:?})\", v),\n+                ty::FreshIntTy(v) => write!(f, \"FreshIntTy({:?})\", v),\n+                ty::FreshFloatTy(v) => write!(f, \"FreshFloatTy({:?})\", v)\n+            }\n         }\n     }\n }\n@@ -715,406 +899,393 @@ impl fmt::Debug for ty::IntVarValue {\n     }\n }*/\n \n-impl<'tcx> fmt::Display for ty::Binder<&'tcx ty::Slice<ty::ExistentialPredicate<'tcx>>> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        ty::tls::with(|tcx| in_binder(f, tcx, self, tcx.lift(self)))\n-    }\n-}\n-\n-impl<'tcx> fmt::Display for ty::Binder<ty::TraitRef<'tcx>> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        ty::tls::with(|tcx| in_binder(f, tcx, self, tcx.lift(self)))\n-    }\n-}\n-\n-impl<'tcx> fmt::Display for ty::Binder<ty::FnSig<'tcx>> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        ty::tls::with(|tcx| in_binder(f, tcx, self, tcx.lift(self)))\n-    }\n-}\n-\n-impl<'tcx> fmt::Display for ty::Binder<ty::TraitPredicate<'tcx>> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        ty::tls::with(|tcx| in_binder(f, tcx, self, tcx.lift(self)))\n-    }\n-}\n-\n-impl<'tcx> fmt::Display for ty::Binder<ty::EquatePredicate<'tcx>> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        ty::tls::with(|tcx| in_binder(f, tcx, self, tcx.lift(self)))\n-    }\n-}\n-\n-impl<'tcx> fmt::Display for ty::Binder<ty::SubtypePredicate<'tcx>> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        ty::tls::with(|tcx| in_binder(f, tcx, self, tcx.lift(self)))\n-    }\n-}\n-\n-impl<'tcx> fmt::Display for ty::Binder<ty::ProjectionPredicate<'tcx>> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        ty::tls::with(|tcx| in_binder(f, tcx, self, tcx.lift(self)))\n-    }\n-}\n-\n-impl<'tcx> fmt::Display for ty::Binder<ty::OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        ty::tls::with(|tcx| in_binder(f, tcx, self, tcx.lift(self)))\n-    }\n-}\n-\n-impl<'tcx> fmt::Display for ty::Binder<ty::OutlivesPredicate<ty::Region<'tcx>,\n-                                                             ty::Region<'tcx>>> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        ty::tls::with(|tcx| in_binder(f, tcx, self, tcx.lift(self)))\n+define_print_multi! {\n+    [\n+    ('tcx) ty::Binder<&'tcx ty::Slice<ty::ExistentialPredicate<'tcx>>>,\n+    ('tcx) ty::Binder<ty::TraitRef<'tcx>>,\n+    ('tcx) ty::Binder<ty::FnSig<'tcx>>,\n+    ('tcx) ty::Binder<ty::TraitPredicate<'tcx>>,\n+    ('tcx) ty::Binder<ty::EquatePredicate<'tcx>>,\n+    ('tcx) ty::Binder<ty::SubtypePredicate<'tcx>>,\n+    ('tcx) ty::Binder<ty::ProjectionPredicate<'tcx>>,\n+    ('tcx) ty::Binder<ty::OutlivesPredicate<Ty<'tcx>, ty::Region<'tcx>>>,\n+    ('tcx) ty::Binder<ty::OutlivesPredicate<ty::Region<'tcx>, ty::Region<'tcx>>>\n+    ]\n+    (self, f, cx) {\n+        display {\n+            ty::tls::with(|tcx| cx.in_binder(f, tcx, self, tcx.lift(self)))\n+        }\n     }\n }\n \n-impl<'tcx> fmt::Display for ty::TraitRef<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        parameterized(f, self.substs, self.def_id, &[])\n+define_print! {\n+    ('tcx) ty::TraitRef<'tcx>, (self, f, cx) {\n+        display {\n+            cx.parameterized(f, self.substs, self.def_id, &[])\n+        }\n+        debug {\n+            // when printing out the debug representation, we don't need\n+            // to enumerate the `for<...>` etc because the debruijn index\n+            // tells you everything you need to know.\n+            print!(f, cx,\n+                   write(\"<\"),\n+                   print(self.self_ty()),\n+                   write(\" as \"))?;\n+            cx.parameterized(f, self.substs, self.def_id, &[])?;\n+            write!(f, \">\")\n+        }\n     }\n }\n \n-impl<'tcx> fmt::Display for ty::GeneratorInterior<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        self.witness.fmt(f)\n+define_print! {\n+    ('tcx) ty::GeneratorInterior<'tcx>, (self, f, cx) {\n+        display {\n+            self.witness.print(f, cx)\n+        }\n     }\n }\n \n-impl<'tcx> fmt::Display for ty::TypeVariants<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            TyBool => write!(f, \"bool\"),\n-            TyChar => write!(f, \"char\"),\n-            TyInt(t) => write!(f, \"{}\", t.ty_to_string()),\n-            TyUint(t) => write!(f, \"{}\", t.ty_to_string()),\n-            TyFloat(t) => write!(f, \"{}\", t.ty_to_string()),\n-            TyRawPtr(ref tm) => {\n-                write!(f, \"*{} {}\", match tm.mutbl {\n-                    hir::MutMutable => \"mut\",\n-                    hir::MutImmutable => \"const\",\n-                },  tm.ty)\n-            }\n-            TyRef(r, ref tm) => {\n-                write!(f, \"&\")?;\n-                let s = r.to_string();\n-                write!(f, \"{}\", s)?;\n-                if !s.is_empty() {\n-                    write!(f, \" \")?;\n+define_print! {\n+    ('tcx) ty::TypeVariants<'tcx>, (self, f, cx) {\n+        display {\n+            match *self {\n+                TyBool => write!(f, \"bool\"),\n+                TyChar => write!(f, \"char\"),\n+                TyInt(t) => write!(f, \"{}\", t.ty_to_string()),\n+                TyUint(t) => write!(f, \"{}\", t.ty_to_string()),\n+                TyFloat(t) => write!(f, \"{}\", t.ty_to_string()),\n+                TyRawPtr(ref tm) => {\n+                    write!(f, \"*{} \", match tm.mutbl {\n+                        hir::MutMutable => \"mut\",\n+                        hir::MutImmutable => \"const\",\n+                    })?;\n+                    tm.ty.print(f, cx)\n                 }\n-                write!(f, \"{}\", tm)\n-            }\n-            TyNever => write!(f, \"!\"),\n-            TyTuple(ref tys, _) => {\n-                write!(f, \"(\")?;\n-                let mut tys = tys.iter();\n-                if let Some(&ty) = tys.next() {\n-                    write!(f, \"{},\", ty)?;\n+                TyRef(r, ref tm) => {\n+                    write!(f, \"&\")?;\n+                    let s = r.print_to_string(cx);\n+                    write!(f, \"{}\", s)?;\n+                    if !s.is_empty() {\n+                        write!(f, \" \")?;\n+                    }\n+                    tm.print(f, cx)\n+                }\n+                TyNever => write!(f, \"!\"),\n+                TyTuple(ref tys, _) => {\n+                    write!(f, \"(\")?;\n+                    let mut tys = tys.iter();\n                     if let Some(&ty) = tys.next() {\n-                        write!(f, \" {}\", ty)?;\n-                        for &ty in tys {\n-                            write!(f, \", {}\", ty)?;\n+                        print!(f, cx, print(ty), write(\",\"))?;\n+                        if let Some(&ty) = tys.next() {\n+                            print!(f, cx, write(\" \"), print(ty))?;\n+                            for &ty in tys {\n+                                print!(f, cx, write(\", \"), print(ty))?;\n+                            }\n                         }\n                     }\n+                    write!(f, \")\")\n                 }\n-                write!(f, \")\")\n-            }\n-            TyFnDef(def_id, substs) => {\n-                ty::tls::with(|tcx| {\n-                    let mut sig = tcx.fn_sig(def_id);\n-                    if let Some(substs) = tcx.lift(&substs) {\n-                        sig = sig.subst(tcx, substs);\n+                TyFnDef(def_id, substs) => {\n+                    ty::tls::with(|tcx| {\n+                        let mut sig = tcx.fn_sig(def_id);\n+                        if let Some(substs) = tcx.lift(&substs) {\n+                            sig = sig.subst(tcx, substs);\n+                        }\n+                        print!(f, cx, print(sig), write(\" {{\"))\n+                    })?;\n+                    cx.parameterized(f, substs, def_id, &[])?;\n+                    write!(f, \"}}\")\n+                }\n+                TyFnPtr(ref bare_fn) => {\n+                    bare_fn.print(f, cx)\n+                }\n+                TyInfer(infer_ty) => write!(f, \"{}\", infer_ty),\n+                TyError => write!(f, \"[type error]\"),\n+                TyParam(ref param_ty) => write!(f, \"{}\", param_ty),\n+                TyAdt(def, substs) => cx.parameterized(f, substs, def.did, &[]),\n+                TyDynamic(data, r) => {\n+                    data.print(f, cx)?;\n+                    let r = r.print_to_string(cx);\n+                    if !r.is_empty() {\n+                        write!(f, \" + {}\", r)\n+                    } else {\n+                        Ok(())\n                     }\n-                    write!(f, \"{} {{\", sig.0)\n-                })?;\n-                parameterized(f, substs, def_id, &[])?;\n-                write!(f, \"}}\")\n-            }\n-            TyFnPtr(ref bare_fn) => {\n-                write!(f, \"{}\", bare_fn)\n-            }\n-            TyInfer(infer_ty) => write!(f, \"{}\", infer_ty),\n-            TyError => write!(f, \"[type error]\"),\n-            TyParam(ref param_ty) => write!(f, \"{}\", param_ty),\n-            TyAdt(def, substs) => parameterized(f, substs, def.did, &[]),\n-            TyDynamic(data, r) => {\n-                write!(f, \"{}\", data)?;\n-                let r = r.to_string();\n-                if !r.is_empty() {\n-                    write!(f, \" + {}\", r)\n-                } else {\n-                    Ok(())\n                 }\n-            }\n-            TyProjection(ref data) => write!(f, \"{}\", data),\n-            TyAnon(def_id, substs) => {\n-                ty::tls::with(|tcx| {\n-                    // Grab the \"TraitA + TraitB\" from `impl TraitA + TraitB`,\n-                    // by looking up the projections associated with the def_id.\n-                    let predicates_of = tcx.predicates_of(def_id);\n-                    let substs = tcx.lift(&substs).unwrap_or_else(|| {\n-                        tcx.intern_substs(&[])\n-                    });\n-                    let bounds = predicates_of.instantiate(tcx, substs);\n-\n-                    let mut first = true;\n-                    let mut is_sized = false;\n-                    write!(f, \"impl\")?;\n-                    for predicate in bounds.predicates {\n-                        if let Some(trait_ref) = predicate.to_opt_poly_trait_ref() {\n-                            // Don't print +Sized, but rather +?Sized if absent.\n-                            if Some(trait_ref.def_id()) == tcx.lang_items().sized_trait() {\n-                                is_sized = true;\n-                                continue;\n+                TyProjection(ref data) => data.print(f, cx),\n+                TyAnon(def_id, substs) => {\n+                    ty::tls::with(|tcx| {\n+                        // Grab the \"TraitA + TraitB\" from `impl TraitA + TraitB`,\n+                        // by looking up the projections associated with the def_id.\n+                        let predicates_of = tcx.predicates_of(def_id);\n+                        let substs = tcx.lift(&substs).unwrap_or_else(|| {\n+                            tcx.intern_substs(&[])\n+                        });\n+                        let bounds = predicates_of.instantiate(tcx, substs);\n+\n+                        let mut first = true;\n+                        let mut is_sized = false;\n+                        write!(f, \"impl\")?;\n+                        for predicate in bounds.predicates {\n+                            if let Some(trait_ref) = predicate.to_opt_poly_trait_ref() {\n+                                // Don't print +Sized, but rather +?Sized if absent.\n+                                if Some(trait_ref.def_id()) == tcx.lang_items().sized_trait() {\n+                                    is_sized = true;\n+                                    continue;\n+                                }\n+\n+                                print!(f, cx,\n+                                       write(\"{}\", if first { \" \" } else { \"+\" }),\n+                                       print(trait_ref))?;\n+                                first = false;\n                             }\n-\n-                            write!(f, \"{}{}\", if first { \" \" } else { \"+\" }, trait_ref)?;\n-                            first = false;\n                         }\n-                    }\n-                    if !is_sized {\n-                        write!(f, \"{}?Sized\", if first { \" \" } else { \"+\" })?;\n-                    }\n-                    Ok(())\n-                })\n-            }\n-            TyStr => write!(f, \"str\"),\n-            TyGenerator(did, substs, interior) => ty::tls::with(|tcx| {\n-                let upvar_tys = substs.upvar_tys(did, tcx);\n-                write!(f, \"[generator\")?;\n-\n-                if let Some(node_id) = tcx.hir.as_local_node_id(did) {\n-                    write!(f, \"@{:?}\", tcx.hir.span(node_id))?;\n-                    let mut sep = \" \";\n-                    tcx.with_freevars(node_id, |freevars| {\n-                        for (freevar, upvar_ty) in freevars.iter().zip(upvar_tys) {\n-                            write!(f,\n-                                        \"{}{}:{}\",\n-                                        sep,\n-                                        tcx.hir.name(freevar.var_id()),\n-                                        upvar_ty)?;\n-                            sep = \", \";\n+                        if !is_sized {\n+                            write!(f, \"{}?Sized\", if first { \" \" } else { \"+\" })?;\n                         }\n                         Ok(())\n-                    })?\n-                } else {\n-                    // cross-crate closure types should only be\n-                    // visible in trans bug reports, I imagine.\n-                    write!(f, \"@{:?}\", did)?;\n-                    let mut sep = \" \";\n-                    for (index, upvar_ty) in upvar_tys.enumerate() {\n-                        write!(f, \"{}{}:{}\", sep, index, upvar_ty)?;\n-                        sep = \", \";\n-                    }\n+                    })\n                 }\n+                TyStr => write!(f, \"str\"),\n+                TyGenerator(did, substs, interior) => ty::tls::with(|tcx| {\n+                    let upvar_tys = substs.upvar_tys(did, tcx);\n+                    write!(f, \"[generator\")?;\n \n-                write!(f, \" {}\", interior)?;\n-\n-                write!(f, \"]\")\n-            }),\n-            TyClosure(did, substs) => ty::tls::with(|tcx| {\n-                let upvar_tys = substs.upvar_tys(did, tcx);\n-                write!(f, \"[closure\")?;\n-\n-                if let Some(node_id) = tcx.hir.as_local_node_id(did) {\n-                    if tcx.sess.opts.debugging_opts.span_free_formats {\n-                        write!(f, \"@{:?}\", node_id)?;\n-                    } else {\n+                    if let Some(node_id) = tcx.hir.as_local_node_id(did) {\n                         write!(f, \"@{:?}\", tcx.hir.span(node_id))?;\n-                    }\n-                    let mut sep = \" \";\n-                    tcx.with_freevars(node_id, |freevars| {\n-                        for (freevar, upvar_ty) in freevars.iter().zip(upvar_tys) {\n-                            write!(f,\n-                                        \"{}{}:{}\",\n-                                        sep,\n-                                        tcx.hir.name(freevar.var_id()),\n-                                        upvar_ty)?;\n+                        let mut sep = \" \";\n+                        tcx.with_freevars(node_id, |freevars| {\n+                            for (freevar, upvar_ty) in freevars.iter().zip(upvar_tys) {\n+                                print!(f, cx,\n+                                       write(\"{}{}:\",\n+                                             sep,\n+                                             tcx.hir.name(freevar.var_id())),\n+                                       print(upvar_ty))?;\n+                                sep = \", \";\n+                            }\n+                            Ok(())\n+                        })?\n+                    } else {\n+                        // cross-crate closure types should only be\n+                        // visible in trans bug reports, I imagine.\n+                        write!(f, \"@{:?}\", did)?;\n+                        let mut sep = \" \";\n+                        for (index, upvar_ty) in upvar_tys.enumerate() {\n+                            print!(f, cx,\n+                                   write(\"{}{}:\", sep, index),\n+                                   print(upvar_ty))?;\n                             sep = \", \";\n                         }\n-                        Ok(())\n-                    })?\n-                } else {\n-                    // cross-crate closure types should only be\n-                    // visible in trans bug reports, I imagine.\n-                    write!(f, \"@{:?}\", did)?;\n-                    let mut sep = \" \";\n-                    for (index, upvar_ty) in upvar_tys.enumerate() {\n-                        write!(f, \"{}{}:{}\", sep, index, upvar_ty)?;\n-                        sep = \", \";\n                     }\n-                }\n \n-                write!(f, \"]\")\n-            }),\n-            TyArray(ty, sz) => {\n-                write!(f, \"[{}; \", ty)?;\n-                match sz.val {\n-                    ConstVal::Integral(ConstInt::Usize(sz)) => {\n-                        write!(f, \"{}\", sz)?;\n-                    }\n-                    ConstVal::Unevaluated(_def_id, substs) => {\n-                        write!(f, \"<unevaluated{:?}>\", &substs[..])?;\n+                    print!(f, cx, write(\" \"), print(interior), write(\"]\"))\n+                }),\n+                TyClosure(did, substs) => ty::tls::with(|tcx| {\n+                    let upvar_tys = substs.upvar_tys(did, tcx);\n+                    write!(f, \"[closure\")?;\n+\n+                    if let Some(node_id) = tcx.hir.as_local_node_id(did) {\n+                        if tcx.sess.opts.debugging_opts.span_free_formats {\n+                            write!(f, \"@{:?}\", node_id)?;\n+                        } else {\n+                            write!(f, \"@{:?}\", tcx.hir.span(node_id))?;\n+                        }\n+                        let mut sep = \" \";\n+                        tcx.with_freevars(node_id, |freevars| {\n+                            for (freevar, upvar_ty) in freevars.iter().zip(upvar_tys) {\n+                                print!(f, cx,\n+                                       write(\"{}{}:\",\n+                                             sep,\n+                                             tcx.hir.name(freevar.var_id())),\n+                                       print(upvar_ty))?;\n+                                sep = \", \";\n+                            }\n+                            Ok(())\n+                        })?\n+                    } else {\n+                        // cross-crate closure types should only be\n+                        // visible in trans bug reports, I imagine.\n+                        write!(f, \"@{:?}\", did)?;\n+                        let mut sep = \" \";\n+                        for (index, upvar_ty) in upvar_tys.enumerate() {\n+                            print!(f, cx,\n+                                   write(\"{}{}:\", sep, index),\n+                                   print(upvar_ty))?;\n+                            sep = \", \";\n+                        }\n                     }\n-                    _ => {\n-                        write!(f, \"{:?}\", sz)?;\n+\n+                    write!(f, \"]\")\n+                }),\n+                TyArray(ty, sz) => {\n+                    print!(f, cx, write(\"[\"), print(ty), write(\"; \"))?;\n+                    match sz.val {\n+                        ConstVal::Integral(ConstInt::Usize(sz)) => {\n+                            write!(f, \"{}\", sz)?;\n+                        }\n+                        ConstVal::Unevaluated(_def_id, substs) => {\n+                            write!(f, \"<unevaluated{:?}>\", &substs[..])?;\n+                        }\n+                        _ => {\n+                            write!(f, \"{:?}\", sz)?;\n+                        }\n                     }\n+                    write!(f, \"]\")\n+                }\n+                TySlice(ty) => {\n+                    print!(f, cx, write(\"[\"), print(ty), write(\"]\"))\n                 }\n-                write!(f, \"]\")\n             }\n-            TySlice(ty) => write!(f, \"[{}]\",  ty)\n         }\n     }\n }\n \n-impl<'tcx> fmt::Display for ty::TyS<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}\", self.sty)\n-    }\n-}\n-\n-impl fmt::Debug for ty::UpvarId {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"UpvarId({:?};`{}`;{:?})\",\n-               self.var_id,\n-               ty::tls::with(|tcx| tcx.hir.name(tcx.hir.hir_to_node_id(self.var_id))),\n-               self.closure_expr_id)\n-    }\n-}\n-\n-impl<'tcx> fmt::Debug for ty::UpvarBorrow<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"UpvarBorrow({:?}, {:?})\",\n-               self.kind, self.region)\n-    }\n-}\n-\n-impl fmt::Display for ty::InferTy {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        let print_var_ids = verbose();\n-        match *self {\n-            ty::TyVar(ref vid) if print_var_ids => write!(f, \"{:?}\", vid),\n-            ty::IntVar(ref vid) if print_var_ids => write!(f, \"{:?}\", vid),\n-            ty::FloatVar(ref vid) if print_var_ids => write!(f, \"{:?}\", vid),\n-            ty::TyVar(_) => write!(f, \"_\"),\n-            ty::IntVar(_) => write!(f, \"{}\", \"{integer}\"),\n-            ty::FloatVar(_) => write!(f, \"{}\", \"{float}\"),\n-            ty::FreshTy(v) => write!(f, \"FreshTy({})\", v),\n-            ty::FreshIntTy(v) => write!(f, \"FreshIntTy({})\", v),\n-            ty::FreshFloatTy(v) => write!(f, \"FreshFloatTy({})\", v)\n+define_print! {\n+    ('tcx) ty::TyS<'tcx>, (self, f, cx) {\n+        display {\n+            self.sty.print(f, cx)\n+        }\n+        debug {\n+            self.sty.print_display(f, cx)\n         }\n     }\n }\n \n-impl fmt::Display for ty::ParamTy {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}\", self.name)\n-    }\n-}\n-\n-impl fmt::Debug for ty::ParamTy {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}/#{}\", self, self.idx)\n-    }\n-}\n-\n-impl<'tcx, T, U> fmt::Display for ty::OutlivesPredicate<T,U>\n-    where T: fmt::Display, U: fmt::Display\n-{\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{} : {}\", self.0, self.1)\n-    }\n-}\n-\n-impl<'tcx> fmt::Display for ty::EquatePredicate<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{} == {}\", self.0, self.1)\n+define_print! {\n+    () ty::ParamTy, (self, f, cx) {\n+        display {\n+            write!(f, \"{}\", self.name)\n+        }\n+        debug {\n+            write!(f, \"{}/#{}\", self.name, self.idx)\n+        }\n     }\n }\n \n-impl<'tcx> fmt::Display for ty::SubtypePredicate<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{} <: {}\", self.a, self.b)\n+define_print! {\n+    ('tcx, T: Print + fmt::Debug, U: Print + fmt::Debug) ty::OutlivesPredicate<T, U>,\n+    (self, f, cx) {\n+        display {\n+            print!(f, cx, print(self.0), write(\" : \"), print(self.1))\n+        }\n     }\n }\n \n-impl<'tcx> fmt::Debug for ty::TraitPredicate<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"TraitPredicate({:?})\",\n-               self.trait_ref)\n+define_print! {\n+    ('tcx) ty::EquatePredicate<'tcx>, (self, f, cx) {\n+        display {\n+            print!(f, cx, print(self.0), write(\" == \"), print(self.1))\n+        }\n     }\n }\n \n-impl<'tcx> fmt::Display for ty::TraitPredicate<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{}: {}\", self.trait_ref.self_ty(), self.trait_ref)\n+define_print! {\n+    ('tcx) ty::SubtypePredicate<'tcx>, (self, f, cx) {\n+        display {\n+            print!(f, cx, print(self.a), write(\" <: \"), print(self.b))\n+        }\n     }\n }\n \n-impl<'tcx> fmt::Debug for ty::ProjectionPredicate<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"ProjectionPredicate({:?}, {:?})\",\n-               self.projection_ty,\n-               self.ty)\n+define_print! {\n+    ('tcx) ty::TraitPredicate<'tcx>, (self, f, cx) {\n+        debug {\n+            write!(f, \"TraitPredicate({:?})\",\n+                   self.trait_ref)\n+        }\n+        display {\n+            print!(f, cx, print(self.trait_ref.self_ty()), write(\": \"), print(self.trait_ref))\n+        }\n     }\n }\n \n-impl<'tcx> fmt::Display for ty::ProjectionPredicate<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        write!(f, \"{} == {}\",\n-               self.projection_ty,\n-               self.ty)\n+define_print! {\n+    ('tcx) ty::ProjectionPredicate<'tcx>, (self, f, cx) {\n+        debug {\n+            print!(f, cx,\n+                   write(\"ProjectionPredicate(\"),\n+                   print(self.projection_ty),\n+                   write(\", \"),\n+                   print(self.ty),\n+                   write(\")\"))\n+        }\n+        display {\n+            print!(f, cx, print(self.projection_ty), write(\" == \"), print(self.ty))\n+        }\n     }\n }\n \n-impl<'tcx> fmt::Display for ty::ProjectionTy<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        // FIXME(tschottdorf): use something like\n-        //   parameterized(f, self.substs, self.item_def_id, &[])\n-        // (which currently ICEs).\n-        let (trait_ref, item_name) = ty::tls::with(|tcx|\n-            (self.trait_ref(tcx), tcx.associated_item(self.item_def_id).name)\n-        );\n-        write!(f, \"{:?}::{}\",\n-               trait_ref,\n-               item_name)\n+define_print! {\n+    ('tcx) ty::ProjectionTy<'tcx>, (self, f, cx) {\n+        display {\n+            // FIXME(tschottdorf): use something like\n+            //   parameterized(f, self.substs, self.item_def_id, &[])\n+            // (which currently ICEs).\n+            let (trait_ref, item_name) = ty::tls::with(|tcx|\n+                (self.trait_ref(tcx), tcx.associated_item(self.item_def_id).name)\n+            );\n+            print!(f, cx, print_debug(trait_ref), write(\"::{}\", item_name))\n+        }\n     }\n }\n \n-impl fmt::Display for ty::ClosureKind {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            ty::ClosureKind::Fn => write!(f, \"Fn\"),\n-            ty::ClosureKind::FnMut => write!(f, \"FnMut\"),\n-            ty::ClosureKind::FnOnce => write!(f, \"FnOnce\"),\n+define_print! {\n+    () ty::ClosureKind, (self, f, cx) {\n+        display {\n+            match *self {\n+                ty::ClosureKind::Fn => write!(f, \"Fn\"),\n+                ty::ClosureKind::FnMut => write!(f, \"FnMut\"),\n+                ty::ClosureKind::FnOnce => write!(f, \"FnOnce\"),\n+            }\n         }\n     }\n }\n \n-impl<'tcx> fmt::Display for ty::Predicate<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n-        match *self {\n-            ty::Predicate::Trait(ref data) => write!(f, \"{}\", data),\n-            ty::Predicate::Equate(ref predicate) => write!(f, \"{}\", predicate),\n-            ty::Predicate::Subtype(ref predicate) => write!(f, \"{}\", predicate),\n-            ty::Predicate::RegionOutlives(ref predicate) => write!(f, \"{}\", predicate),\n-            ty::Predicate::TypeOutlives(ref predicate) => write!(f, \"{}\", predicate),\n-            ty::Predicate::Projection(ref predicate) => write!(f, \"{}\", predicate),\n-            ty::Predicate::WellFormed(ty) => write!(f, \"{} well-formed\", ty),\n-            ty::Predicate::ObjectSafe(trait_def_id) =>\n-                ty::tls::with(|tcx| {\n-                    write!(f, \"the trait `{}` is object-safe\", tcx.item_path_str(trait_def_id))\n-                }),\n-            ty::Predicate::ClosureKind(closure_def_id, kind) =>\n-                ty::tls::with(|tcx| {\n-                    write!(f, \"the closure `{}` implements the trait `{}`\",\n-                           tcx.item_path_str(closure_def_id), kind)\n-                }),\n-            ty::Predicate::ConstEvaluatable(def_id, substs) => {\n-                write!(f, \"the constant `\")?;\n-                parameterized(f, substs, def_id, &[])?;\n-                write!(f, \"` can be evaluated\")\n+define_print! {\n+    ('tcx) ty::Predicate<'tcx>, (self, f, cx) {\n+        display {\n+            match *self {\n+                ty::Predicate::Trait(ref data) => data.print(f, cx),\n+                ty::Predicate::Equate(ref predicate) => predicate.print(f, cx),\n+                ty::Predicate::Subtype(ref predicate) => predicate.print(f, cx),\n+                ty::Predicate::RegionOutlives(ref predicate) => predicate.print(f, cx),\n+                ty::Predicate::TypeOutlives(ref predicate) => predicate.print(f, cx),\n+                ty::Predicate::Projection(ref predicate) => predicate.print(f, cx),\n+                ty::Predicate::WellFormed(ty) => print!(f, cx, print(ty), write(\" well-formed\")),\n+                ty::Predicate::ObjectSafe(trait_def_id) =>\n+                    ty::tls::with(|tcx| {\n+                        write!(f, \"the trait `{}` is object-safe\", tcx.item_path_str(trait_def_id))\n+                    }),\n+                ty::Predicate::ClosureKind(closure_def_id, kind) =>\n+                    ty::tls::with(|tcx| {\n+                        write!(f, \"the closure `{}` implements the trait `{}`\",\n+                               tcx.item_path_str(closure_def_id), kind)\n+                    }),\n+                ty::Predicate::ConstEvaluatable(def_id, substs) => {\n+                    write!(f, \"the constant `\")?;\n+                    cx.parameterized(f, substs, def_id, &[])?;\n+                    write!(f, \"` can be evaluated\")\n+                }\n+            }\n+        }\n+        debug {\n+            match *self {\n+                ty::Predicate::Trait(ref a) => a.print(f, cx),\n+                ty::Predicate::Equate(ref pair) => pair.print(f, cx),\n+                ty::Predicate::Subtype(ref pair) => pair.print(f, cx),\n+                ty::Predicate::RegionOutlives(ref pair) => pair.print(f, cx),\n+                ty::Predicate::TypeOutlives(ref pair) => pair.print(f, cx),\n+                ty::Predicate::Projection(ref pair) => pair.print(f, cx),\n+                ty::Predicate::WellFormed(ty) => ty.print(f, cx),\n+                ty::Predicate::ObjectSafe(trait_def_id) => {\n+                    write!(f, \"ObjectSafe({:?})\", trait_def_id)\n+                }\n+                ty::Predicate::ClosureKind(closure_def_id, kind) => {\n+                    write!(f, \"ClosureKind({:?}, {:?})\", closure_def_id, kind)\n+                }\n+                ty::Predicate::ConstEvaluatable(def_id, substs) => {\n+                    write!(f, \"ConstEvaluatable({:?}, {:?})\", def_id, substs)\n+                }\n             }\n         }\n     }"}]}