{"sha": "4040734e44d72697dbeb35c4c1be1a70cb7b0b37", "node_id": "C_kwDOAAsO6NoAKDQwNDA3MzRlNDRkNzI2OTdkYmViMzVjNGMxYmUxYTcwY2I3YjBiMzc", "commit": {"author": {"name": "b-naber", "email": "bn263@gmx.de", "date": "2022-11-21T19:56:27Z"}, "committer": {"name": "b-naber", "email": "bn263@gmx.de", "date": "2022-11-23T19:55:15Z"}, "message": "get field ty during projecting", "tree": {"sha": "64c4eaf4499cde4f82474ff9876881f6d10e77c7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/64c4eaf4499cde4f82474ff9876881f6d10e77c7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4040734e44d72697dbeb35c4c1be1a70cb7b0b37", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4040734e44d72697dbeb35c4c1be1a70cb7b0b37", "html_url": "https://github.com/rust-lang/rust/commit/4040734e44d72697dbeb35c4c1be1a70cb7b0b37", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4040734e44d72697dbeb35c4c1be1a70cb7b0b37/comments", "author": {"login": "b-naber", "id": 71934879, "node_id": "MDQ6VXNlcjcxOTM0ODc5", "avatar_url": "https://avatars.githubusercontent.com/u/71934879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/b-naber", "html_url": "https://github.com/b-naber", "followers_url": "https://api.github.com/users/b-naber/followers", "following_url": "https://api.github.com/users/b-naber/following{/other_user}", "gists_url": "https://api.github.com/users/b-naber/gists{/gist_id}", "starred_url": "https://api.github.com/users/b-naber/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/b-naber/subscriptions", "organizations_url": "https://api.github.com/users/b-naber/orgs", "repos_url": "https://api.github.com/users/b-naber/repos", "events_url": "https://api.github.com/users/b-naber/events{/privacy}", "received_events_url": "https://api.github.com/users/b-naber/received_events", "type": "User", "site_admin": false}, "committer": {"login": "b-naber", "id": 71934879, "node_id": "MDQ6VXNlcjcxOTM0ODc5", "avatar_url": "https://avatars.githubusercontent.com/u/71934879?v=4", "gravatar_id": "", "url": "https://api.github.com/users/b-naber", "html_url": "https://github.com/b-naber", "followers_url": "https://api.github.com/users/b-naber/followers", "following_url": "https://api.github.com/users/b-naber/following{/other_user}", "gists_url": "https://api.github.com/users/b-naber/gists{/gist_id}", "starred_url": "https://api.github.com/users/b-naber/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/b-naber/subscriptions", "organizations_url": "https://api.github.com/users/b-naber/orgs", "repos_url": "https://api.github.com/users/b-naber/repos", "events_url": "https://api.github.com/users/b-naber/events{/privacy}", "received_events_url": "https://api.github.com/users/b-naber/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "fd6fed3027be425c27a5a8c825575bdd7a1e63dd", "url": "https://api.github.com/repos/rust-lang/rust/commits/fd6fed3027be425c27a5a8c825575bdd7a1e63dd", "html_url": "https://github.com/rust-lang/rust/commit/fd6fed3027be425c27a5a8c825575bdd7a1e63dd"}], "stats": {"total": 407, "additions": 222, "deletions": 185}, "files": [{"sha": "c987bf44ec00db3d92bb60fe108afd54403fc426", "filename": "Cargo.lock", "status": "modified", "additions": 35, "deletions": 17, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/4040734e44d72697dbeb35c4c1be1a70cb7b0b37/Cargo.lock", "raw_url": "https://github.com/rust-lang/rust/raw/4040734e44d72697dbeb35c4c1be1a70cb7b0b37/Cargo.lock", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/Cargo.lock?ref=4040734e44d72697dbeb35c4c1be1a70cb7b0b37", "patch": "@@ -285,7 +285,7 @@ dependencies = [\n \n [[package]]\n name = \"cargo\"\n-version = \"0.67.0\"\n+version = \"0.68.0\"\n dependencies = [\n  \"anyhow\",\n  \"atty\",\n@@ -307,6 +307,7 @@ dependencies = [\n  \"glob\",\n  \"hex 0.4.2\",\n  \"home\",\n+ \"http-auth\",\n  \"humantime 2.0.1\",\n  \"ignore\",\n  \"im-rc\",\n@@ -349,11 +350,11 @@ dependencies = [\n \n [[package]]\n name = \"cargo-credential\"\n-version = \"0.1.0\"\n+version = \"0.2.0\"\n \n [[package]]\n name = \"cargo-credential-1password\"\n-version = \"0.1.0\"\n+version = \"0.2.0\"\n dependencies = [\n  \"cargo-credential\",\n  \"serde\",\n@@ -362,15 +363,15 @@ dependencies = [\n \n [[package]]\n name = \"cargo-credential-macos-keychain\"\n-version = \"0.1.0\"\n+version = \"0.2.0\"\n dependencies = [\n  \"cargo-credential\",\n  \"security-framework\",\n ]\n \n [[package]]\n name = \"cargo-credential-wincred\"\n-version = \"0.1.0\"\n+version = \"0.2.0\"\n dependencies = [\n  \"cargo-credential\",\n  \"winapi\",\n@@ -424,7 +425,6 @@ dependencies = [\n  \"glob\",\n  \"itertools\",\n  \"lazy_static\",\n- \"remove_dir_all\",\n  \"serde_json\",\n  \"snapbox\",\n  \"tar\",\n@@ -436,7 +436,7 @@ dependencies = [\n \n [[package]]\n name = \"cargo-util\"\n-version = \"0.2.2\"\n+version = \"0.2.3\"\n dependencies = [\n  \"anyhow\",\n  \"core-foundation\",\n@@ -446,7 +446,7 @@ dependencies = [\n  \"jobserver\",\n  \"libc\",\n  \"log\",\n- \"miow\",\n+ \"miow 0.5.0\",\n  \"same-file\",\n  \"shell-escape\",\n  \"tempfile\",\n@@ -808,7 +808,7 @@ dependencies = [\n  \"lazy_static\",\n  \"lazycell\",\n  \"libc\",\n- \"miow\",\n+ \"miow 0.3.7\",\n  \"miropt-test-tools\",\n  \"regex\",\n  \"rustfix\",\n@@ -833,7 +833,7 @@ dependencies = [\n  \"lazy_static\",\n  \"libc\",\n  \"log\",\n- \"miow\",\n+ \"miow 0.3.7\",\n  \"regex\",\n  \"rustfix\",\n  \"serde\",\n@@ -846,9 +846,9 @@ dependencies = [\n \n [[package]]\n name = \"concolor\"\n-version = \"0.0.8\"\n+version = \"0.0.9\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"015267563b1df20adccdd00cb05257b1dfbea70a04928e9cf88ffb850c1a40af\"\n+checksum = \"b90f9dcd9490a97db91a85ccd79e38a87e14323f0bb824659ee3274e9143ba37\"\n dependencies = [\n  \"atty\",\n  \"bitflags\",\n@@ -857,9 +857,9 @@ dependencies = [\n \n [[package]]\n name = \"concolor-query\"\n-version = \"0.0.5\"\n+version = \"0.1.0\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"d6417fe6fc03a8b533fd2177742eeb39a90c7233eedec7bac96d4d6b69a09449\"\n+checksum = \"82a90734b3d5dcf656e7624cca6bce9c3a90ee11f900e80141a7427ccfb3d317\"\n \n [[package]]\n name = \"content_inspector\"\n@@ -909,7 +909,7 @@ dependencies = [\n \n [[package]]\n name = \"crates-io\"\n-version = \"0.34.0\"\n+version = \"0.35.0\"\n dependencies = [\n  \"anyhow\",\n  \"curl\",\n@@ -1698,6 +1698,15 @@ dependencies = [\n  \"syn\",\n ]\n \n+[[package]]\n+name = \"http-auth\"\n+version = \"0.1.6\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"c0b40b39d66c28829a0cf4d09f7e139ff8201f7500a5083732848ed3b4b4d850\"\n+dependencies = [\n+ \"memchr\",\n+]\n+\n [[package]]\n name = \"humantime\"\n version = \"1.3.0\"\n@@ -2300,6 +2309,15 @@ dependencies = [\n  \"winapi\",\n ]\n \n+[[package]]\n+name = \"miow\"\n+version = \"0.5.0\"\n+source = \"registry+https://github.com/rust-lang/crates.io-index\"\n+checksum = \"52ffbca2f655e33c08be35d87278e5b18b89550a37dbd598c20db92f6a471123\"\n+dependencies = [\n+ \"windows-sys\",\n+]\n+\n [[package]]\n name = \"miri\"\n version = \"0.1.0\"\n@@ -4693,9 +4711,9 @@ checksum = \"da73c8f77aebc0e40c300b93f0a5f1bece7a248a36eee287d4e095f35c7b7d6e\"\n \n [[package]]\n name = \"snapbox\"\n-version = \"0.3.3\"\n+version = \"0.4.1\"\n source = \"registry+https://github.com/rust-lang/crates.io-index\"\n-checksum = \"44d199ccf8f606592df2d145db26f2aa45344e23c64b074cc5a4047f1d99b0f7\"\n+checksum = \"827c00e91b15e2674d8a5270bae91f898693cbf9561cbb58d8eaa31974597293\"\n dependencies = [\n  \"concolor\",\n  \"content_inspector\","}, {"sha": "5c9459c97f403b581c962c5a74b90fa803991b47", "filename": "compiler/rustc_mir_build/src/build/expr/as_place.rs", "status": "modified", "additions": 173, "deletions": 91, "changes": 264, "blob_url": "https://github.com/rust-lang/rust/blob/4040734e44d72697dbeb35c4c1be1a70cb7b0b37/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4040734e44d72697dbeb35c4c1be1a70cb7b0b37/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_place.rs?ref=4040734e44d72697dbeb35c4c1be1a70cb7b0b37", "patch": "@@ -21,21 +21,28 @@ use rustc_index::vec::Idx;\n use std::assert_matches::assert_matches;\n use std::iter;\n \n-/// The \"outermost\" place that holds this value.\n-#[derive(Copy, Clone, Debug, PartialEq)]\n-pub(crate) enum PlaceBase {\n+/// `PlaceBuilder` is used to create places during MIR construction. It allows you to \"build up\" a\n+/// place by pushing more and more projections onto the end, and then convert the final set into a\n+/// place using the `into_place` method.\n+///\n+/// This is used internally when building a place for an expression like `a.b.c`. The fields `b`\n+/// and `c` can be progressively pushed onto the place builder that is created when converting `a`.\n+#[derive(Clone, Debug, PartialEq)]\n+pub(in crate::build) enum PlaceBuilder<'tcx> {\n     /// Denotes the start of a `Place`.\n-    Local(Local),\n+    ///\n+    /// We use `PlaceElem` since this has all `Field` types available.\n+    Local(Local, Vec<PlaceElem<'tcx>>),\n \n     /// When building place for an expression within a closure, the place might start off a\n     /// captured path. When `capture_disjoint_fields` is enabled, we might not know the capture\n     /// index (within the desugared closure) of the captured path until most of the projections\n-    /// are applied. We use `PlaceBase::Upvar` to keep track of the root variable off of which the\n+    /// are applied. We use `PlaceBuilder::Upvar` to keep track of the root variable off of which the\n     /// captured path starts, the closure the capture belongs to and the trait the closure\n     /// implements.\n     ///\n-    /// Once we have figured out the capture index, we can convert the place builder to start from\n-    /// `PlaceBase::Local`.\n+    /// Once we have figured out the capture index, we can convert the place builder to\n+    /// `PlaceBuilder::Local`.\n     ///\n     /// Consider the following example\n     /// ```rust\n@@ -56,24 +63,16 @@ pub(crate) enum PlaceBase {\n     ///\n     /// When `capture_disjoint_fields` is enabled, `t.0.0.0` is captured and we won't be able to\n     /// figure out that it is captured until all the `Field` projections are applied.\n-    Upvar {\n-        /// HirId of the upvar\n-        var_hir_id: LocalVarId,\n-        /// DefId of the closure\n-        closure_def_id: LocalDefId,\n-    },\n+    ///\n+    /// Note: in contrast to `PlaceBuilder::Local` we have not yet determined all `Field` types\n+    /// and will only do so once converting to `PlaceBuilder::Local`.\n+    UpVar(UpVar, Vec<PlaceElem<'tcx>>),\n }\n \n-/// `PlaceBuilder` is used to create places during MIR construction. It allows you to \"build up\" a\n-/// place by pushing more and more projections onto the end, and then convert the final set into a\n-/// place using the `to_place` method.\n-///\n-/// This is used internally when building a place for an expression like `a.b.c`. The fields `b`\n-/// and `c` can be progressively pushed onto the place builder that is created when converting `a`.\n-#[derive(Clone, Debug, PartialEq)]\n-pub(in crate::build) struct PlaceBuilder<'tcx> {\n-    base: PlaceBase,\n-    projection: Vec<PlaceElem<'tcx>>,\n+#[derive(Copy, Clone, Debug, PartialEq)]\n+pub(crate) struct UpVar {\n+    var_hir_id: LocalVarId,\n+    closure_def_id: LocalDefId,\n }\n \n /// Given a list of MIR projections, convert them to list of HIR ProjectionKind.\n@@ -175,7 +174,7 @@ fn to_upvars_resolved_place_builder<'tcx>(\n     cx: &Builder<'_, 'tcx>,\n     var_hir_id: LocalVarId,\n     closure_def_id: LocalDefId,\n-    projection: &[PlaceElem<'tcx>],\n+    projection: &[UpvarProjectionElem<'tcx>],\n ) -> Option<PlaceBuilder<'tcx>> {\n     let Some((capture_index, capture)) =\n         find_capture_matching_projections(\n@@ -197,23 +196,31 @@ fn to_upvars_resolved_place_builder<'tcx>(\n                 var_hir_id, projection,\n             );\n         }\n+\n         return None;\n     };\n \n     // Access the capture by accessing the field within the Closure struct.\n     let capture_info = &cx.upvars[capture_index];\n \n-    let mut upvar_resolved_place_builder = PlaceBuilder::from(capture_info.use_place);\n+    let Place { local: upvar_resolved_local, projection: local_projection } =\n+        capture_info.use_place;\n \n     // We used some of the projections to build the capture itself,\n     // now we apply the remaining to the upvar resolved place.\n-    trace!(?capture.captured_place, ?projection);\n-    let remaining_projections = strip_prefix(\n+    let upvar_projection = strip_prefix(\n         capture.captured_place.place.base_ty,\n         projection,\n         &capture.captured_place.place.projections,\n+    )\n+    .collect::<Vec<_>>();\n+\n+    let upvar_resolved_place_builder = PlaceBuilder::construct_local_place_builder(\n+        cx,\n+        upvar_resolved_local,\n+        local_projection.to_vec(),\n+        upvar_projection,\n     );\n-    upvar_resolved_place_builder.projection.extend(remaining_projections);\n \n     Some(upvar_resolved_place_builder)\n }\n@@ -235,6 +242,8 @@ fn strip_prefix<'a, 'tcx>(\n         // Filter out opaque casts, they are unnecessary in the prefix.\n         .filter(|elem| !matches!(elem, ProjectionElem::OpaqueCast(..)));\n     for projection in prefix_projections {\n+        debug!(?projection, ?projection.ty);\n+\n         match projection.kind {\n             HirProjectionKind::Deref => {\n                 assert_matches!(iter.next(), Some(ProjectionElem::Deref));\n@@ -249,6 +258,7 @@ fn strip_prefix<'a, 'tcx>(\n                 bug!(\"unexpected projection kind: {:?}\", projection);\n             }\n         }\n+\n         base_ty = projection.ty;\n     }\n     iter\n@@ -263,9 +273,9 @@ impl<'tcx> PlaceBuilder<'tcx> {\n     pub(in crate::build) fn try_to_place(&self, cx: &Builder<'_, 'tcx>) -> Option<Place<'tcx>> {\n         let resolved = self.resolve_upvar(cx);\n         let builder = resolved.as_ref().unwrap_or(self);\n-        let PlaceBase::Local(local) = builder.base else { return None };\n-        let projection = cx.tcx.intern_place_elems(&builder.projection);\n-        Some(Place { local, projection })\n+        let PlaceBuilder::Local(local, projection) = builder else { return None };\n+        let projection = cx.tcx.intern_place_elems(&projection);\n+        Some(Place { local: *local, projection })\n     }\n \n     /// Attempts to resolve the `PlaceBuilder`.\n@@ -282,22 +292,39 @@ impl<'tcx> PlaceBuilder<'tcx> {\n         &self,\n         cx: &Builder<'_, 'tcx>,\n     ) -> Option<PlaceBuilder<'tcx>> {\n-        let PlaceBase::Upvar { var_hir_id, closure_def_id } = self.base else {\n+        let PlaceBuilder::Upvar( Upvar {var_hir_id, closure_def_id }, projection) = self else {\n             return None;\n         };\n-        to_upvars_resolved_place_builder(cx, var_hir_id, closure_def_id, &self.projection)\n-    }\n \n-    pub(crate) fn base(&self) -> PlaceBase {\n-        self.base\n+        to_upvars_resolved_place_builder(cx, var_hir_id, closure_def_id, &projection)\n     }\n \n-    pub(crate) fn projection(&self) -> &[PlaceElem<'tcx>] {\n-        &self.projection\n+    pub(crate) fn get_local_projection(&self) -> &[PlaceElem<'tcx>] {\n+        match self {\n+            Self::Local(_, projection) => projection,\n+            Self::UpVar(..) => {\n+                bug!(\"get_local_projection_mut can only be called on PlaceBuilder::Local\")\n+            }\n+        }\n     }\n \n-    pub(crate) fn field(self, f: Field, ty: Ty<'tcx>) -> Self {\n-        self.project(PlaceElem::Field(f, ty))\n+    #[instrument(skip(cx), level = \"debug\")]\n+    pub(crate) fn field(\n+        self,\n+        cx: &Builder<'_, 'tcx>,\n+        f: Field,\n+        default_field_ty: Ty<'tcx>,\n+    ) -> Self {\n+        let field_ty = match self {\n+            PlaceBuilder::Local(..) => {\n+                let base_place = self.clone();\n+                PlaceBuilder::try_compute_field_ty(cx, f, base_place)\n+                    .unwrap_or_else(|| default_field_ty)\n+            }\n+            PlaceBuilder::UpVar(..) => default_field_ty,\n+        };\n+\n+        self.project(ProjectionElem::Field(f, field_ty))\n     }\n \n     pub(crate) fn deref(self) -> Self {\n@@ -312,16 +339,34 @@ impl<'tcx> PlaceBuilder<'tcx> {\n         self.project(PlaceElem::Index(index))\n     }\n \n-    pub(crate) fn project(mut self, elem: PlaceElem<'tcx>) -> Self {\n-        self.projection.push(elem);\n-        self\n+    #[instrument(level = \"debug\")]\n+    pub(crate) fn project(self, elem: PlaceElem<'tcx>) -> Self {\n+        let result = match self {\n+            PlaceBuilder::Local(local, mut proj) => {\n+                proj.push(elem);\n+                PlaceBuilder::Local(local, proj)\n+            }\n+            PlaceBuilder::UpVar(upvar, mut proj) => {\n+                proj.push(elem);\n+                PlaceBuilder::UpVar(upvar, proj)\n+            }\n+        };\n+\n+        debug!(?result);\n+        result\n     }\n \n     /// Same as `.clone().project(..)` but more efficient\n     pub(crate) fn clone_project(&self, elem: PlaceElem<'tcx>) -> Self {\n-        Self {\n-            base: self.base,\n-            projection: Vec::from_iter(self.projection.iter().copied().chain([elem])),\n+        match self {\n+            PlaceBuilder::Local(local, proj) => PlaceBuilder::Local(\n+                *local,\n+                Vec::from_iter(proj.iter().copied().chain([elem.into()])),\n+            ),\n+            PlaceBuilder::Upvar(upvar, proj) => PlaceBuilder::UpVar(\n+                upvar,\n+                Vec::from_iter(proj.iter().copied().chain([elem.into()])),\n+            ),\n         }\n     }\n \n@@ -332,59 +377,96 @@ impl<'tcx> PlaceBuilder<'tcx> {\n     ///\n     /// Fallible as the root of this place may be an upvar for\n     /// which no base type can be determined.\n-    pub fn try_compute_ty<D>(\n-        &self,\n-        local_decls: &D,\n+    #[instrument(skip(cx), level = \"debug\")]\n+    fn try_compute_field_ty(\n         cx: &Builder<'_, 'tcx>,\n-    ) -> Option<PlaceTy<'tcx>>\n-    where\n-        D: HasLocalDecls<'tcx>,\n-    {\n-        match self.base {\n-            PlaceBase::Local(_) => Some(self.clone().into_place(cx).ty(local_decls, cx.tcx)),\n-            PlaceBase::Upvar { .. } => {\n-                match to_upvars_resolved_place_builder(self.clone(), cx) {\n-                    Ok(resolved_place_builder) => {\n-                        // `base` is guaranteed to be `PlaceBase::Local` now, so recursive call is ok\n-                        resolved_place_builder.try_compute_ty(local_decls, cx)\n-                    }\n-                    Err(place_builder) => {\n-                        match &place_builder.projection[..] {\n-                            &[ProjectionElem::OpaqueCast(base_ty), ref projections @ ..] => {\n-                                let place_ty = projections\n-                                    .iter()\n-                                    .fold(PlaceTy::from_ty(base_ty), |place_ty, &elem| {\n-                                        place_ty.projection_ty(cx.tcx, elem)\n-                                    });\n-\n-                                debug!(?place_ty);\n-\n-                                Some(place_ty)\n-                            }\n-                            _ => None, // would need a base `Ty` for these\n-                        }\n-                    }\n+        field: Field,\n+        base_place: PlaceBuilder<'tcx>,\n+    ) -> Option<Ty<'tcx>> {\n+        let field_idx = field.as_usize();\n+        let PlaceTy { ty, variant_index } = base_place.to_place(cx).ty(&cx.local_decls, cx.tcx);\n+        let base_ty = cx.tcx.normalize_erasing_regions(cx.param_env, ty);\n+        debug!(?base_ty);\n+\n+        let field_ty = match base_ty.kind() {\n+            ty::Adt(adt_def, substs) if adt_def.is_enum() => {\n+                let variant_idx = variant_index.unwrap();\n+                adt_def.variant(variant_idx).fields[field_idx].ty(cx.tcx, substs)\n+            }\n+            ty::Adt(adt_def, substs) => adt_def\n+                .all_fields()\n+                .nth(field_idx)\n+                .unwrap_or_else(|| {\n+                    bug!(\"expected to take field idx {:?} of fields of {:?}\", field_idx, adt_def)\n+                })\n+                .ty(cx.tcx, substs),\n+            ty::Tuple(elems) => elems.iter().nth(field_idx).unwrap_or_else(|| {\n+                bug!(\"expected to take field idx {:?} of {:?}\", field_idx, elems)\n+            }),\n+            _ => return None,\n+        };\n+\n+        Some(cx.tcx.normalize_erasing_regions(cx.param_env, field_ty))\n+    }\n+\n+    /// Creates a `PlaceBuilder::Local` from a `PlaceBuilder::UpVar` whose upvars\n+    /// are resolved. This function takes two kinds of projections: `local_projection`\n+    /// contains the projections of the captured upvar and `upvar_projection` the\n+    /// projections that are applied to the captured upvar. The main purpose of this\n+    /// function is to figure out the `Ty`s of the field projections in `upvar_projection`.\n+    #[instrument(skip(cx, local))]\n+    fn construct_local_place_builder(\n+        cx: &Builder<'_, 'tcx>,\n+        local: Local,\n+        mut local_projection: Vec<PlaceElem<'tcx>>,\n+        upvar_projection: Vec<PlaceElem<'tcx>>,\n+    ) -> Self {\n+        // We iterate through `upvar_projection` and whenever we find a `ProjectionElem::Field` we use\n+        // the ancestor projections, i.e. those projection elements that come before the field projection,\n+        // to get the `Ty` for the field.\n+\n+        for proj in upvar_projection.iter() {\n+            debug!(\"proj: {:?}, local_projection: {:?}\", proj, local_projection);\n+            match *proj {\n+                ProjectionElem::Field(field, default_field_ty) => {\n+                    let ancestor_proj = local_projection.to_vec();\n+                    let base_place = PlaceBuilder::Local(local, ancestor_proj);\n+                    let field_ty = PlaceBuilder::try_compute_field_ty(cx, field, base_place)\n+                        .unwrap_or_else(|| default_field_ty);\n+                    debug!(?field_ty);\n+\n+                    local_projection.push(ProjectionElem::Field(field, field_ty));\n+                    debug!(?local_projection);\n+                }\n+                ProjectionElem::Deref => local_projection.push(ProjectionElem::Deref),\n+                ProjectionElem::Index(idx) => local_projection.push(ProjectionElem::Index(idx)),\n+                ProjectionElem::ConstantIndex { offset, min_length, from_end } => local_projection\n+                    .push(ProjectionElem::ConstantIndex { offset, min_length, from_end }),\n+                ProjectionElem::Subslice { from, to, from_end } => {\n+                    local_projection.push(ProjectionElem::Subslice { from, to, from_end })\n+                }\n+                ProjectionElem::Downcast(sym, variant_idx) => {\n+                    local_projection.push(ProjectionElem::Downcast(sym, variant_idx))\n+                }\n+                ProjectionElem::OpaqueCast(ty) => {\n+                    local_projection.push(ProjectionElem::OpaqueCast(ty))\n                 }\n             }\n         }\n+\n+        PlaceBuilder::Local(local, local_projection)\n     }\n }\n \n impl<'tcx> From<Local> for PlaceBuilder<'tcx> {\n     fn from(local: Local) -> Self {\n-        Self { base: PlaceBase::Local(local), projection: Vec::new() }\n-    }\n-}\n-\n-impl<'tcx> From<PlaceBase> for PlaceBuilder<'tcx> {\n-    fn from(base: PlaceBase) -> Self {\n-        Self { base, projection: Vec::new() }\n+        Self::Local(local, Vec::new())\n     }\n }\n \n impl<'tcx> From<Place<'tcx>> for PlaceBuilder<'tcx> {\n     fn from(p: Place<'tcx>) -> Self {\n-        Self { base: PlaceBase::Local(p.local), projection: p.projection.to_vec() }\n+        Self::Local(p.local, p.projection.to_vec())\n     }\n }\n \n@@ -448,15 +530,14 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         self.expr_as_place(block, expr, Mutability::Not, None)\n     }\n \n+    #[instrument(skip(self, fake_borrow_temps), level = \"debug\")]\n     fn expr_as_place(\n         &mut self,\n         mut block: BasicBlock,\n         expr: &Expr<'tcx>,\n         mutability: Mutability,\n         fake_borrow_temps: Option<&mut Vec<Local>>,\n     ) -> BlockAnd<PlaceBuilder<'tcx>> {\n-        debug!(\"expr_as_place(block={:?}, expr={:?}, mutability={:?})\", block, expr, mutability);\n-\n         let this = self;\n         let expr_span = expr.span;\n         let source_info = this.source_info(expr_span);\n@@ -470,12 +551,13 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 let lhs = &this.thir[lhs];\n                 let mut place_builder =\n                     unpack!(block = this.expr_as_place(block, lhs, mutability, fake_borrow_temps,));\n+                debug!(?place_builder);\n                 if let ty::Adt(adt_def, _) = lhs.ty.kind() {\n                     if adt_def.is_enum() {\n                         place_builder = place_builder.downcast(*adt_def, variant_index);\n                     }\n                 }\n-                block.and(place_builder.field(name, expr.ty))\n+                block.and(place_builder.field(this, name, expr.ty))\n             }\n             ExprKind::Deref { arg } => {\n                 let place_builder = unpack!(\n@@ -617,15 +699,15 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n     }\n \n     /// Lower a captured upvar. Note we might not know the actual capture index,\n-    /// so we create a place starting from `PlaceBase::Upvar`, which will be resolved\n+    /// so we create a place starting from `UpVar`, which will be resolved\n     /// once all projections that allow us to identify a capture have been applied.\n     fn lower_captured_upvar(\n         &mut self,\n         block: BasicBlock,\n         closure_def_id: LocalDefId,\n         var_hir_id: LocalVarId,\n     ) -> BlockAnd<PlaceBuilder<'tcx>> {\n-        block.and(PlaceBuilder::from(PlaceBase::Upvar { var_hir_id, closure_def_id }))\n+        block.and(PlaceBuilder::UpVar(UpVar { var_hir_id, closure_def_id }, vec![]))\n     }\n \n     /// Lower an index expression\n@@ -716,8 +798,8 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         source_info: SourceInfo,\n     ) {\n         let tcx = self.tcx;\n-\n         let place_ty = base_place.ty(&self.local_decls, tcx);\n+\n         if let ty::Slice(_) = place_ty.ty.kind() {\n             // We need to create fake borrows to ensure that the bounds\n             // check that we just did stays valid. Since we can't assign to"}, {"sha": "618aa9e310954130514ffd6de14aeacff6fae8f2", "filename": "compiler/rustc_mir_build/src/build/expr/as_rvalue.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4040734e44d72697dbeb35c4c1be1a70cb7b0b37/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4040734e44d72697dbeb35c4c1be1a70cb7b0b37/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=4040734e44d72697dbeb35c4c1be1a70cb7b0b37", "patch": "@@ -4,9 +4,8 @@ use rustc_index::vec::Idx;\n use rustc_middle::ty::util::IntTypeExt;\n use rustc_target::abi::{Abi, Primitive};\n \n-use crate::build::expr::as_place::PlaceBase;\n use crate::build::expr::category::{Category, RvalueFunc};\n-use crate::build::{BlockAnd, BlockAndExtension, Builder, NeedsTemporary};\n+use crate::build::{BlockAnd, BlockAndExtension, Builder, NeedsTemporary, PlaceBuilder};\n use rustc_hir::lang_items::LangItem;\n use rustc_middle::middle::region;\n use rustc_middle::mir::AssertKind;\n@@ -651,15 +650,15 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n \n         let arg_place_builder = unpack!(block = this.as_place_builder(block, arg));\n \n-        let mutability = match arg_place_builder.base() {\n+        let mutability = match arg_place_builder {\n             // We are capturing a path that starts off a local variable in the parent.\n             // The mutability of the current capture is same as the mutability\n             // of the local declaration in the parent.\n-            PlaceBase::Local(local) => this.local_decls[local].mutability,\n+            PlaceBuilder::Local(local, _) => this.local_decls[local].mutability,\n             // Parent is a closure and we are capturing a path that is captured\n             // by the parent itself. The mutability of the current capture\n             // is same as that of the capture in the parent closure.\n-            PlaceBase::Upvar { .. } => {\n+            PlaceBuilder::UpVar(..) => {\n                 let enclosing_upvars_resolved = arg_place_builder.to_place(this);\n \n                 match enclosing_upvars_resolved.as_ref() {"}, {"sha": "12cd0e65a11588f976a3172eca2b9153bc4c5554", "filename": "compiler/rustc_mir_build/src/build/expr/into.rs", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4040734e44d72697dbeb35c4c1be1a70cb7b0b37/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4040734e44d72697dbeb35c4c1be1a70cb7b0b37/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Finto.rs?ref=4040734e44d72697dbeb35c4c1be1a70cb7b0b37", "patch": "@@ -358,8 +358,10 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                         .map(|(n, ty)| match fields_map.get(&n) {\n                             Some(v) => v.clone(),\n                             None => {\n-                                let place = place_builder.clone_project(PlaceElem::Field(n, *ty));\n-                                this.consume_by_copy_or_move(place.to_place(this))\n+                                let place_builder = place_builder.clone();\n+                                this.consume_by_copy_or_move(\n+                                    place_builder.field(this, n, *ty).to_place(this),\n+                                )\n                             }\n                         })\n                         .collect()"}, {"sha": "7b932eda74432b4031f99c4f2d5c87cfea3338fb", "filename": "compiler/rustc_mir_build/src/build/matches/test.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4040734e44d72697dbeb35c4c1be1a70cb7b0b37/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4040734e44d72697dbeb35c4c1be1a70cb7b0b37/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Ftest.rs?ref=4040734e44d72697dbeb35c4c1be1a70cb7b0b37", "patch": "@@ -760,8 +760,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         let downcast_place = match_pair.place.downcast(adt_def, variant_index); // `(x as Variant)`\n         let consequent_match_pairs = subpatterns.iter().map(|subpattern| {\n             // e.g., `(x as Variant).0`\n-            let place = downcast_place\n-                .clone_project(PlaceElem::Field(subpattern.field, subpattern.pattern.ty));\n+            let place = downcast_place.clone().field(self, subpattern.field, subpattern.pattern.ty);\n             // e.g., `(x as Variant).0 @ P1`\n             MatchPair::new(place, &subpattern.pattern, self)\n         });"}, {"sha": "30f4e49d8bae567c0763332514fe4e12757ef3b1", "filename": "compiler/rustc_mir_build/src/build/matches/util.rs", "status": "modified", "additions": 5, "deletions": 68, "changes": 73, "blob_url": "https://github.com/rust-lang/rust/blob/4040734e44d72697dbeb35c4c1be1a70cb7b0b37/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4040734e44d72697dbeb35c4c1be1a70cb7b0b37/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fmatches%2Futil.rs?ref=4040734e44d72697dbeb35c4c1be1a70cb7b0b37", "patch": "@@ -1,4 +1,3 @@\n-use crate::build::expr::as_place::PlaceBase;\n use crate::build::expr::as_place::PlaceBuilder;\n use crate::build::matches::MatchPair;\n use crate::build::Builder;\n@@ -18,70 +17,7 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n         subpatterns\n             .iter()\n             .map(|fieldpat| {\n-                let place =\n-                    place.clone_project(PlaceElem::Field(fieldpat.field, fieldpat.pattern.ty));\n-                MatchPair::new(place, &fieldpat.pattern, self)\n-            })\n-            .collect()\n-    }\n-\n-    #[instrument(skip(self), level = \"debug\")]\n-    pub(crate) fn field_match_pairs_tuple_struct<'pat>(\n-        &mut self,\n-        place_builder: PlaceBuilder<'tcx>,\n-        subpatterns: &'pat [FieldPat<'tcx>],\n-    ) -> Vec<MatchPair<'pat, 'tcx>> {\n-        let place_ty_and_variant_idx =\n-            place_builder.try_compute_ty(&self.local_decls, self).map(|place_ty| {\n-                (\n-                    self.tcx.normalize_erasing_regions(self.param_env, place_ty.ty),\n-                    place_ty.variant_index,\n-                )\n-            });\n-        debug!(?place_ty_and_variant_idx);\n-\n-        subpatterns\n-            .iter()\n-            .map(|fieldpat| {\n-                // NOTE: With type ascriptions it can happen that we get errors\n-                // during borrow-checking on higher-ranked types if we use the\n-                // ascribed type as the field type, so we try to get the actual field\n-                // type from the `Place`, if possible, see issue #96514\n-                let field_ty = if let Some((place_ty, opt_variant_idx)) = place_ty_and_variant_idx {\n-                    let field_idx = fieldpat.field.as_usize();\n-                    let field_ty = match place_ty.kind() {\n-                        ty::Adt(adt_def, substs) if adt_def.is_enum() => {\n-                            let variant_idx = opt_variant_idx.unwrap();\n-                            adt_def.variant(variant_idx).fields[field_idx].ty(self.tcx, substs)\n-                        }\n-                        ty::Adt(adt_def, substs) => adt_def\n-                            .all_fields()\n-                            .nth(field_idx)\n-                            .unwrap_or_else(|| {\n-                                bug!(\n-                                    \"expected to take field idx {:?} of fields of {:?}\",\n-                                    field_idx,\n-                                    adt_def\n-                                )\n-                            })\n-                            .ty(self.tcx, substs),\n-                        ty::Tuple(elems) => elems.iter().nth(field_idx).unwrap_or_else(|| {\n-                            bug!(\"expected to take field idx {:?} of {:?}\", field_idx, elems)\n-                        }),\n-                        _ => bug!(\n-                            \"no field available, place_ty: {:#?}, kind: {:?}\",\n-                            place_ty,\n-                            place_ty.kind()\n-                        ),\n-                    };\n-\n-                    self.tcx.normalize_erasing_regions(self.param_env, field_ty)\n-                } else {\n-                    fieldpat.pattern.ty\n-                };\n-\n-                let place = place_builder.clone().field(fieldpat.field, field_ty);\n-                debug!(?place, ?field_ty);\n+                let place = place.clone().field(self, fieldpat.field, fieldpat.pattern.ty);\n \n                 MatchPair::new(place, &fieldpat.pattern, self)\n             })\n@@ -171,9 +107,10 @@ impl<'pat, 'tcx> MatchPair<'pat, 'tcx> {\n \n         // Only add the OpaqueCast projection if the given place is an opaque type and the\n         // expected type from the pattern is not.\n-        let may_need_cast = match place.base() {\n-            PlaceBase::Local(local) => {\n-                let ty = Place::ty_from(local, place.projection(), &cx.local_decls, cx.tcx).ty;\n+        let may_need_cast = match place {\n+            PlaceBuilder::Local(local, _) => {\n+                let ty =\n+                    Place::ty_from(local, place.get_local_projection(), &cx.local_decls, cx.tcx).ty;\n                 ty != pattern.ty && ty.has_opaque_types()\n             }\n             _ => true,"}]}