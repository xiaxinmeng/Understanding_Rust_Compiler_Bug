{"sha": "82abc0db816e7441a0d89a3eaa51f439a03f4506", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgyYWJjMGRiODE2ZTc0NDFhMGQ4OWEzZWFhNTFmNDM5YTAzZjQ1MDY=", "commit": {"author": {"name": "Julien Cretin", "email": "cretin@google.com", "date": "2019-05-29T18:29:51Z"}, "committer": {"name": "Julien Cretin", "email": "cretin@google.com", "date": "2019-07-19T17:59:11Z"}, "message": "Remember the span of the Kleene operator in macros\n\nThis is needed for having complete error messages where reporting macro variable\nerrors. Here is what they would look like:\n\nerror: meta-variable repeats with different kleene operator\n  --> $DIR/issue-61053-different-kleene.rs:3:57\n   |\nLL |     ( $( $i:ident = $($j:ident),+ );* ) => { $( $( $i = $j; )* )* };\n   |                                 - expected repetition   ^^   - conflicting repetition", "tree": {"sha": "9674a3548e72a1b15ef4a05022ebd2dd6cfa36ad", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/9674a3548e72a1b15ef4a05022ebd2dd6cfa36ad"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/82abc0db816e7441a0d89a3eaa51f439a03f4506", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/82abc0db816e7441a0d89a3eaa51f439a03f4506", "html_url": "https://github.com/rust-lang/rust/commit/82abc0db816e7441a0d89a3eaa51f439a03f4506", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/82abc0db816e7441a0d89a3eaa51f439a03f4506/comments", "author": {"login": "ia0", "id": 969295, "node_id": "MDQ6VXNlcjk2OTI5NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/969295?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ia0", "html_url": "https://github.com/ia0", "followers_url": "https://api.github.com/users/ia0/followers", "following_url": "https://api.github.com/users/ia0/following{/other_user}", "gists_url": "https://api.github.com/users/ia0/gists{/gist_id}", "starred_url": "https://api.github.com/users/ia0/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ia0/subscriptions", "organizations_url": "https://api.github.com/users/ia0/orgs", "repos_url": "https://api.github.com/users/ia0/repos", "events_url": "https://api.github.com/users/ia0/events{/privacy}", "received_events_url": "https://api.github.com/users/ia0/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ia0", "id": 969295, "node_id": "MDQ6VXNlcjk2OTI5NQ==", "avatar_url": "https://avatars.githubusercontent.com/u/969295?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ia0", "html_url": "https://github.com/ia0", "followers_url": "https://api.github.com/users/ia0/followers", "following_url": "https://api.github.com/users/ia0/following{/other_user}", "gists_url": "https://api.github.com/users/ia0/gists{/gist_id}", "starred_url": "https://api.github.com/users/ia0/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ia0/subscriptions", "organizations_url": "https://api.github.com/users/ia0/orgs", "repos_url": "https://api.github.com/users/ia0/repos", "events_url": "https://api.github.com/users/ia0/events{/privacy}", "received_events_url": "https://api.github.com/users/ia0/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "527dce7137f7a3c7bf47d9a503abf25f88ea22de", "url": "https://api.github.com/repos/rust-lang/rust/commits/527dce7137f7a3c7bf47d9a503abf25f88ea22de", "html_url": "https://github.com/rust-lang/rust/commit/527dce7137f7a3c7bf47d9a503abf25f88ea22de"}], "stats": {"total": 54, "additions": 33, "deletions": 21}, "files": [{"sha": "ae1979540ff8d88df26280642faca4561c1bc791", "filename": "src/libsyntax/ext/tt/macro_parser.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/82abc0db816e7441a0d89a3eaa51f439a03f4506/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82abc0db816e7441a0d89a3eaa51f439a03f4506/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=82abc0db816e7441a0d89a3eaa51f439a03f4506", "patch": "@@ -557,8 +557,8 @@ fn inner_parse_loop<'root, 'tt>(\n                     // implicitly disallowing OneOrMore from having 0 matches here. Thus, that will\n                     // result in a \"no rules expected token\" error by virtue of this matcher not\n                     // working.\n-                    if seq.op == quoted::KleeneOp::ZeroOrMore\n-                        || seq.op == quoted::KleeneOp::ZeroOrOne\n+                    if seq.kleene.op == quoted::KleeneOp::ZeroOrMore\n+                        || seq.kleene.op == quoted::KleeneOp::ZeroOrOne\n                     {\n                         let mut new_item = item.clone();\n                         new_item.match_cur += seq.num_captures;\n@@ -573,7 +573,7 @@ fn inner_parse_loop<'root, 'tt>(\n                     cur_items.push(MatcherPosHandle::Box(Box::new(MatcherPos {\n                         stack: smallvec![],\n                         sep: seq.separator.clone(),\n-                        seq_op: Some(seq.op),\n+                        seq_op: Some(seq.kleene.op),\n                         idx: 0,\n                         matches,\n                         match_lo: item.match_cur,"}, {"sha": "54f901d095b88f9a14b9a74932d693937f923d45", "filename": "src/libsyntax/ext/tt/macro_rules.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/82abc0db816e7441a0d89a3eaa51f439a03f4506/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82abc0db816e7441a0d89a3eaa51f439a03f4506/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=82abc0db816e7441a0d89a3eaa51f439a03f4506", "patch": "@@ -273,7 +273,7 @@ pub fn compile(\n                     if body.legacy { token::Semi } else { token::Comma },\n                     def.span,\n                 )),\n-                op: quoted::KleeneOp::OneOrMore,\n+                kleene: quoted::KleeneToken::new(quoted::KleeneOp::OneOrMore, def.span),\n                 num_captures: 2,\n             }),\n         ),\n@@ -283,7 +283,7 @@ pub fn compile(\n             Lrc::new(quoted::SequenceRepetition {\n                 tts: vec![quoted::TokenTree::token(token::Semi, def.span)],\n                 separator: None,\n-                op: quoted::KleeneOp::ZeroOrMore,\n+                kleene: quoted::KleeneToken::new(quoted::KleeneOp::ZeroOrMore, def.span),\n                 num_captures: 0,\n             }),\n         ),\n@@ -477,8 +477,8 @@ fn check_lhs_no_empty_seq(sess: &ParseSess, tts: &[quoted::TokenTree]) -> bool {\n                     && seq.tts.iter().all(|seq_tt| match *seq_tt {\n                         TokenTree::MetaVarDecl(_, _, id) => id.name == sym::vis,\n                         TokenTree::Sequence(_, ref sub_seq) => {\n-                            sub_seq.op == quoted::KleeneOp::ZeroOrMore\n-                                || sub_seq.op == quoted::KleeneOp::ZeroOrOne\n+                            sub_seq.kleene.op == quoted::KleeneOp::ZeroOrMore\n+                                || sub_seq.kleene.op == quoted::KleeneOp::ZeroOrOne\n                         }\n                         _ => false,\n                     })\n@@ -628,8 +628,8 @@ impl FirstSets {\n \n                         // Reverse scan: Sequence comes before `first`.\n                         if subfirst.maybe_empty\n-                            || seq_rep.op == quoted::KleeneOp::ZeroOrMore\n-                            || seq_rep.op == quoted::KleeneOp::ZeroOrOne\n+                            || seq_rep.kleene.op == quoted::KleeneOp::ZeroOrMore\n+                            || seq_rep.kleene.op == quoted::KleeneOp::ZeroOrOne\n                         {\n                             // If sequence is potentially empty, then\n                             // union them (preserving first emptiness).\n@@ -677,8 +677,8 @@ impl FirstSets {\n                             assert!(first.maybe_empty);\n                             first.add_all(subfirst);\n                             if subfirst.maybe_empty\n-                                || seq_rep.op == quoted::KleeneOp::ZeroOrMore\n-                                || seq_rep.op == quoted::KleeneOp::ZeroOrOne\n+                                || seq_rep.kleene.op == quoted::KleeneOp::ZeroOrMore\n+                                || seq_rep.kleene.op == quoted::KleeneOp::ZeroOrOne\n                             {\n                                 // continue scanning for more first\n                                 // tokens, but also make sure we"}, {"sha": "eff6b9dd429e4130cdc39a91ae0c54f91e4ccdbb", "filename": "src/libsyntax/ext/tt/quoted.rs", "status": "modified", "additions": 21, "deletions": 9, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/82abc0db816e7441a0d89a3eaa51f439a03f4506/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82abc0db816e7441a0d89a3eaa51f439a03f4506/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs?ref=82abc0db816e7441a0d89a3eaa51f439a03f4506", "patch": "@@ -50,11 +50,23 @@ pub struct SequenceRepetition {\n     /// The optional separator\n     pub separator: Option<Token>,\n     /// Whether the sequence can be repeated zero (*), or one or more times (+)\n-    pub op: KleeneOp,\n+    pub kleene: KleeneToken,\n     /// The number of `Match`s that appear in the sequence (and subsequences)\n     pub num_captures: usize,\n }\n \n+#[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Debug, Copy)]\n+pub struct KleeneToken {\n+    pub span: Span,\n+    pub op: KleeneOp,\n+}\n+\n+impl KleeneToken {\n+    pub fn new(op: KleeneOp, span: Span) -> KleeneToken {\n+        KleeneToken { span, op }\n+    }\n+}\n+\n /// A Kleene-style [repetition operator](http://en.wikipedia.org/wiki/Kleene_star)\n /// for token sequences.\n #[derive(Clone, PartialEq, RustcEncodable, RustcDecodable, Hash, Debug, Copy)]\n@@ -273,15 +285,15 @@ fn parse_tree(\n                     macro_node_id,\n                 );\n                 // Get the Kleene operator and optional separator\n-                let (separator, op) = parse_sep_and_kleene_op(trees, span.entire(), sess);\n+                let (separator, kleene) = parse_sep_and_kleene_op(trees, span.entire(), sess);\n                 // Count the number of captured \"names\" (i.e., named metavars)\n                 let name_captures = macro_parser::count_names(&sequence);\n                 TokenTree::Sequence(\n                     span,\n                     Lrc::new(SequenceRepetition {\n                         tts: sequence,\n                         separator,\n-                        op,\n+                        kleene,\n                         num_captures: name_captures,\n                     }),\n                 )\n@@ -379,28 +391,28 @@ fn parse_sep_and_kleene_op(\n     input: &mut Peekable<impl Iterator<Item = tokenstream::TokenTree>>,\n     span: Span,\n     sess: &ParseSess,\n-) -> (Option<Token>, KleeneOp) {\n+) -> (Option<Token>, KleeneToken) {\n     // We basically look at two token trees here, denoted as #1 and #2 below\n     let span = match parse_kleene_op(input, span) {\n         // #1 is a `?`, `+`, or `*` KleeneOp\n-        Ok(Ok((op, _))) => return (None, op),\n+        Ok(Ok((op, span))) => return (None, KleeneToken::new(op, span)),\n \n         // #1 is a separator followed by #2, a KleeneOp\n         Ok(Err(token)) => match parse_kleene_op(input, token.span) {\n             // #2 is the `?` Kleene op, which does not take a separator (error)\n-            Ok(Ok((KleeneOp::ZeroOrOne, _))) => {\n+            Ok(Ok((KleeneOp::ZeroOrOne, span))) => {\n                 // Error!\n                 sess.span_diagnostic.span_err(\n                     token.span,\n                     \"the `?` macro repetition operator does not take a separator\",\n                 );\n \n                 // Return a dummy\n-                return (None, KleeneOp::ZeroOrMore);\n+                return (None, KleeneToken::new(KleeneOp::ZeroOrMore, span));\n             }\n \n             // #2 is a KleeneOp :D\n-            Ok(Ok((op, _))) => return (Some(token), op),\n+            Ok(Ok((op, span))) => return (Some(token), KleeneToken::new(op, span)),\n \n             // #2 is a random token or not a token at all :(\n             Ok(Err(Token { span, .. })) | Err(span) => span,\n@@ -414,5 +426,5 @@ fn parse_sep_and_kleene_op(\n     sess.span_diagnostic.span_err(span, \"expected one of: `*`, `+`, or `?`\");\n \n     // Return a dummy\n-    (None, KleeneOp::ZeroOrMore)\n+    (None, KleeneToken::new(KleeneOp::ZeroOrMore, span))\n }"}, {"sha": "93a2f5069018c01513c732efff276676cbd42c9f", "filename": "src/libsyntax/ext/tt/transcribe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/82abc0db816e7441a0d89a3eaa51f439a03f4506/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/82abc0db816e7441a0d89a3eaa51f439a03f4506/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=82abc0db816e7441a0d89a3eaa51f439a03f4506", "patch": "@@ -183,7 +183,7 @@ pub fn transcribe(\n \n                         // Is the repetition empty?\n                         if len == 0 {\n-                            if seq.op == quoted::KleeneOp::OneOrMore {\n+                            if seq.kleene.op == quoted::KleeneOp::OneOrMore {\n                                 // FIXME: this really ought to be caught at macro definition\n                                 // time... It happens when the Kleene operator in the matcher and\n                                 // the body for the same meta-variable do not match."}]}