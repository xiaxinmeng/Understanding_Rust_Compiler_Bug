{"sha": "49c9686c3cb02d64c077d3002f3c68e6fa2cf407", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQ5Yzk2ODZjM2NiMDJkNjRjMDc3ZDMwMDJmM2M2OGU2ZmEyY2Y0MDc=", "commit": {"author": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2019-04-21T20:17:20Z"}, "committer": {"name": "Edwin Cheng", "email": "edwin0cheng@gmail.com", "date": "2019-04-21T21:04:37Z"}, "message": "Handle `*+` case and single token case", "tree": {"sha": "a440f0ebeb893454d15aaa2a28f845721a6db6e2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/a440f0ebeb893454d15aaa2a28f845721a6db6e2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/49c9686c3cb02d64c077d3002f3c68e6fa2cf407", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/49c9686c3cb02d64c077d3002f3c68e6fa2cf407", "html_url": "https://github.com/rust-lang/rust/commit/49c9686c3cb02d64c077d3002f3c68e6fa2cf407", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/49c9686c3cb02d64c077d3002f3c68e6fa2cf407/comments", "author": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "committer": {"login": "edwin0cheng", "id": 11014119, "node_id": "MDQ6VXNlcjExMDE0MTE5", "avatar_url": "https://avatars.githubusercontent.com/u/11014119?v=4", "gravatar_id": "", "url": "https://api.github.com/users/edwin0cheng", "html_url": "https://github.com/edwin0cheng", "followers_url": "https://api.github.com/users/edwin0cheng/followers", "following_url": "https://api.github.com/users/edwin0cheng/following{/other_user}", "gists_url": "https://api.github.com/users/edwin0cheng/gists{/gist_id}", "starred_url": "https://api.github.com/users/edwin0cheng/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/edwin0cheng/subscriptions", "organizations_url": "https://api.github.com/users/edwin0cheng/orgs", "repos_url": "https://api.github.com/users/edwin0cheng/repos", "events_url": "https://api.github.com/users/edwin0cheng/events{/privacy}", "received_events_url": "https://api.github.com/users/edwin0cheng/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bcf5cf8ac64e8c63b4e083c7f2f88e2fe915cdb5", "url": "https://api.github.com/repos/rust-lang/rust/commits/bcf5cf8ac64e8c63b4e083c7f2f88e2fe915cdb5", "html_url": "https://github.com/rust-lang/rust/commit/bcf5cf8ac64e8c63b4e083c7f2f88e2fe915cdb5"}], "stats": {"total": 61, "additions": 56, "deletions": 5}, "files": [{"sha": "00fb09a3b4a766160b6960b7039030724becf9bb", "filename": "crates/ra_mbe/src/mbe_expander.rs", "status": "modified", "additions": 56, "deletions": 5, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/49c9686c3cb02d64c077d3002f3c68e6fa2cf407/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs", "raw_url": "https://github.com/rust-lang/rust/raw/49c9686c3cb02d64c077d3002f3c68e6fa2cf407/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_mbe%2Fsrc%2Fmbe_expander.rs?ref=49c9686c3cb02d64c077d3002f3c68e6fa2cf407", "patch": "@@ -221,11 +221,13 @@ fn match_lhs(pattern: &crate::Subtree, input: &mut TtCursor) -> Result<Bindings,\n                 }\n                 _ => return Err(ExpandError::UnexpectedToken),\n             },\n-            crate::TokenTree::Repeat(crate::Repeat { subtree, kind: _, separator }) => {\n+            crate::TokenTree::Repeat(crate::Repeat { subtree, kind, separator }) => {\n                 // Dirty hack to make macro-expansion terminate.\n                 // This should be replaced by a propper macro-by-example implementation\n                 let mut limit = 128;\n+                let mut counter = 0;\n                 while let Ok(nested) = match_lhs(subtree, input) {\n+                    counter += 1;\n                     limit -= 1;\n                     if limit == 0 {\n                         break;\n@@ -239,6 +241,17 @@ fn match_lhs(pattern: &crate::Subtree, input: &mut TtCursor) -> Result<Bindings,\n                         }\n                     }\n                 }\n+\n+                match kind {\n+                    crate::RepeatKind::OneOrMore if counter == 0 => {\n+                        return Err(ExpandError::UnexpectedToken);\n+                    }\n+                    crate::RepeatKind::ZeroOrOne if counter > 1 => {\n+                        return Err(ExpandError::UnexpectedToken);\n+                    }\n+\n+                    _ => {}\n+                }\n             }\n             crate::TokenTree::Subtree(subtree) => {\n                 let input_subtree =\n@@ -274,6 +287,20 @@ fn expand_subtree(\n     Ok(tt::Subtree { token_trees, delimiter: template.delimiter })\n }\n \n+/// Reduce single token subtree to single token\n+/// In `tt` matcher case, all tt tokens will be braced by a Delimiter::None\n+/// which makes all sort of problems.\n+fn reduce_single_token(mut subtree: tt::Subtree) -> tt::TokenTree {\n+    if subtree.delimiter != tt::Delimiter::None || subtree.token_trees.len() != 1 {\n+        return subtree.into();\n+    }\n+\n+    match subtree.token_trees.pop().unwrap() {\n+        tt::TokenTree::Subtree(subtree) => reduce_single_token(subtree),\n+        tt::TokenTree::Leaf(token) => token.into(),\n+    }\n+}\n+\n fn expand_tt(\n     template: &crate::TokenTree,\n     bindings: &Bindings,\n@@ -282,22 +309,40 @@ fn expand_tt(\n     let res: tt::TokenTree = match template {\n         crate::TokenTree::Subtree(subtree) => expand_subtree(subtree, bindings, nesting)?.into(),\n         crate::TokenTree::Repeat(repeat) => {\n-            let mut token_trees = Vec::new();\n+            let mut token_trees: Vec<tt::TokenTree> = Vec::new();\n             nesting.push(0);\n             // Dirty hack to make macro-expansion terminate.\n             // This should be replaced by a propper macro-by-example implementation\n             let mut limit = 128;\n+            let mut has_sep = false;\n+\n             while let Ok(t) = expand_subtree(&repeat.subtree, bindings, nesting) {\n                 limit -= 1;\n                 if limit == 0 {\n                     break;\n                 }\n                 let idx = nesting.pop().unwrap();\n                 nesting.push(idx + 1);\n-                token_trees.push(t.into())\n+                token_trees.push(reduce_single_token(t).into());\n+\n+                if let Some(sep) = repeat.separator {\n+                    let punct =\n+                        tt::Leaf::from(tt::Punct { char: sep, spacing: tt::Spacing::Alone });\n+                    token_trees.push(punct.into());\n+                    has_sep = true;\n+                }\n             }\n             nesting.pop().unwrap();\n-            tt::Subtree { token_trees, delimiter: tt::Delimiter::None }.into()\n+\n+            // Dirty hack for remove the last sep\n+            // if it is a \",\" undo the push\n+            if has_sep && repeat.separator.unwrap() == ',' {\n+                token_trees.pop();\n+            }\n+\n+            // Check if it is a singel token subtree without any delimiter\n+            // e.g {Delimiter:None> ['>'] /Delimiter:None>}\n+            reduce_single_token(tt::Subtree { token_trees, delimiter: tt::Delimiter::None })\n         }\n         crate::TokenTree::Leaf(leaf) => match leaf {\n             crate::Leaf::Ident(ident) => {\n@@ -311,7 +356,13 @@ fn expand_tt(\n                     tt::Leaf::from(tt::Ident { text: \"$crate\".into(), id: TokenId::unspecified() })\n                         .into()\n                 } else {\n-                    bindings.get(&v.text, nesting)?.clone()\n+                    let tkn = bindings.get(&v.text, nesting)?.clone();\n+\n+                    if let tt::TokenTree::Subtree(subtree) = tkn {\n+                        reduce_single_token(subtree)\n+                    } else {\n+                        tkn\n+                    }\n                 }\n             }\n             crate::Leaf::Literal(l) => tt::Leaf::from(tt::Literal { text: l.text.clone() }).into(),"}]}