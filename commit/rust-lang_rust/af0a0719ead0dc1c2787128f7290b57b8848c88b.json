{"sha": "af0a0719ead0dc1c2787128f7290b57b8848c88b", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFmMGEwNzE5ZWFkMGRjMWMyNzg3MTI4ZjcyOTBiNTdiODg0OGM4OGI=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-12-02T07:35:06Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-12-02T07:35:06Z"}, "message": "Auto merge of #37936 - tedsta:fuchsia_std_process, r=alexcrichton\n\nFuchsia support for std::process via liblaunchpad.\n\nNow we can launch processes on Fuchsia via the Rust standard library! ... Mostly.\n\nRight now, ~5% of the time, reading the stdout/stderr off the pipes will fail. Some Magenta kernel people think it's probably a bug in Magenta's pipes. I wrote a unit test that demonstrates the issue in C, which I was told will expedite a fix. https://fuchsia-review.googlesource.com/#/c/15628/\n\nHopefully this can get merged once the issue is fixed :)\n\n@raphlinus", "tree": {"sha": "2d6140ae8b47d3c682437e7203e670e52e57845c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2d6140ae8b47d3c682437e7203e670e52e57845c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/af0a0719ead0dc1c2787128f7290b57b8848c88b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/af0a0719ead0dc1c2787128f7290b57b8848c88b", "html_url": "https://github.com/rust-lang/rust/commit/af0a0719ead0dc1c2787128f7290b57b8848c88b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/af0a0719ead0dc1c2787128f7290b57b8848c88b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "10771498273764e25d197209f80830a45b7cfdcd", "url": "https://api.github.com/repos/rust-lang/rust/commits/10771498273764e25d197209f80830a45b7cfdcd", "html_url": "https://github.com/rust-lang/rust/commit/10771498273764e25d197209f80830a45b7cfdcd"}, {"sha": "e1b752b2a1bea9c05e89e52632f2f87ee9777062", "url": "https://api.github.com/repos/rust-lang/rust/commits/e1b752b2a1bea9c05e89e52632f2f87ee9777062", "html_url": "https://github.com/rust-lang/rust/commit/e1b752b2a1bea9c05e89e52632f2f87ee9777062"}], "stats": {"total": 927, "additions": 689, "deletions": 238}, "files": [{"sha": "1087d1f24471b75e1a641ddd453fc79d6e2c5da7", "filename": "src/libstd/build.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af0a0719ead0dc1c2787128f7290b57b8848c88b/src%2Flibstd%2Fbuild.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af0a0719ead0dc1c2787128f7290b57b8848c88b/src%2Flibstd%2Fbuild.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fbuild.rs?ref=af0a0719ead0dc1c2787128f7290b57b8848c88b", "patch": "@@ -60,6 +60,8 @@ fn main() {\n         println!(\"cargo:rustc-link-lib=shell32\");\n     } else if target.contains(\"fuchsia\") {\n         println!(\"cargo:rustc-link-lib=magenta\");\n+        println!(\"cargo:rustc-link-lib=mxio\");\n+        println!(\"cargo:rustc-link-lib=launchpad\"); // for std::process\n     }\n }\n "}, {"sha": "61eb60da486c95e07af92462ef15fd515c0c0534", "filename": "src/libstd/sys/unix/fd.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/af0a0719ead0dc1c2787128f7290b57b8848c88b/src%2Flibstd%2Fsys%2Funix%2Ffd.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af0a0719ead0dc1c2787128f7290b57b8848c88b/src%2Flibstd%2Fsys%2Funix%2Ffd.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Ffd.rs?ref=af0a0719ead0dc1c2787128f7290b57b8848c88b", "patch": "@@ -110,6 +110,7 @@ impl FileDesc {\n     #[cfg(not(any(target_env = \"newlib\",\n                   target_os = \"solaris\",\n                   target_os = \"emscripten\",\n+                  target_os = \"fuchsia\",\n                   target_os = \"haiku\")))]\n     pub fn set_cloexec(&self) -> io::Result<()> {\n         unsafe {\n@@ -120,6 +121,7 @@ impl FileDesc {\n     #[cfg(any(target_env = \"newlib\",\n               target_os = \"solaris\",\n               target_os = \"emscripten\",\n+              target_os = \"fuchsia\",\n               target_os = \"haiku\"))]\n     pub fn set_cloexec(&self) -> io::Result<()> {\n         unsafe {"}, {"sha": "a8ed415b7f47f89216c5e5a83543e1203c7e7252", "filename": "src/libstd/sys/unix/pipe.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/af0a0719ead0dc1c2787128f7290b57b8848c88b/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af0a0719ead0dc1c2787128f7290b57b8848c88b/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fpipe.rs?ref=af0a0719ead0dc1c2787128f7290b57b8848c88b", "patch": "@@ -77,6 +77,7 @@ pub fn read2(p1: AnonPipe,\n              v1: &mut Vec<u8>,\n              p2: AnonPipe,\n              v2: &mut Vec<u8>) -> io::Result<()> {\n+\n     // Set both pipes into nonblocking mode as we're gonna be reading from both\n     // in the `select` loop below, and we wouldn't want one to block the other!\n     let p1 = p1.into_fd();"}, {"sha": "319fbce35cd7b26da6110c2c9eb9cb5b257f66c0", "filename": "src/libstd/sys/unix/process/magenta.rs", "status": "added", "additions": 191, "deletions": 0, "changes": 191, "blob_url": "https://github.com/rust-lang/rust/blob/af0a0719ead0dc1c2787128f7290b57b8848c88b/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fmagenta.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af0a0719ead0dc1c2787128f7290b57b8848c88b/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fmagenta.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fmagenta.rs?ref=af0a0719ead0dc1c2787128f7290b57b8848c88b", "patch": "@@ -0,0 +1,191 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+#![allow(non_camel_case_types)]\n+\n+use convert::TryInto;\n+use io;\n+use os::raw::c_char;\n+use u64;\n+\n+use libc::{c_int, c_void};\n+\n+pub type mx_handle_t = i32;\n+pub type mx_vaddr_t = usize;\n+pub type mx_rights_t = u32;\n+pub type mx_status_t = i32;\n+\n+pub type mx_size_t = usize;\n+pub type mx_ssize_t = isize;\n+\n+pub const MX_HANDLE_INVALID: mx_handle_t = 0;\n+\n+pub type mx_time_t = u64;\n+pub const MX_TIME_INFINITE : mx_time_t = u64::MAX;\n+\n+pub type mx_signals_t = u32;\n+\n+pub const MX_OBJECT_SIGNAL_3         : mx_signals_t = 1 << 3;\n+\n+pub const MX_TASK_TERMINATED        : mx_signals_t = MX_OBJECT_SIGNAL_3;\n+\n+pub const MX_RIGHT_SAME_RIGHTS  : mx_rights_t = 1 << 31;\n+\n+pub type mx_object_info_topic_t = u32;\n+\n+pub const MX_INFO_PROCESS         : mx_object_info_topic_t = 3;\n+\n+pub const MX_HND_TYPE_JOB: u32 = 6;\n+\n+pub fn mx_cvt<T>(t: T) -> io::Result<T> where T: TryInto<mx_status_t>+Copy {\n+    if let Ok(status) = TryInto::try_into(t) {\n+        if status < 0 {\n+            Err(io::Error::from_raw_os_error(status))\n+        } else {\n+            Ok(t)\n+        }\n+    } else {\n+        Err(io::Error::last_os_error())\n+    }\n+}\n+\n+// Safe wrapper around mx_handle_t\n+pub struct Handle {\n+    raw: mx_handle_t,\n+}\n+\n+impl Handle {\n+    pub fn new(raw: mx_handle_t) -> Handle {\n+        Handle {\n+            raw: raw,\n+        }\n+    }\n+\n+    pub fn raw(&self) -> mx_handle_t {\n+        self.raw\n+    }\n+}\n+\n+impl Drop for Handle {\n+    fn drop(&mut self) {\n+        unsafe { mx_cvt(mx_handle_close(self.raw)).expect(\"Failed to close mx_handle_t\"); }\n+    }\n+}\n+\n+// Common MX_INFO header\n+#[derive(Default)]\n+#[repr(C)]\n+pub struct mx_info_header_t {\n+    pub topic: u32,              // identifies the info struct\n+    pub avail_topic_size: u16,   // \u201cnative\u201d size of the struct\n+    pub topic_size: u16,         // size of the returned struct (<=topic_size)\n+    pub avail_count: u32,        // number of records the kernel has\n+    pub count: u32,              // number of records returned (limited by buffer size)\n+}\n+\n+#[derive(Default)]\n+#[repr(C)]\n+pub struct mx_record_process_t {\n+    pub return_code: c_int,\n+}\n+\n+// Returned for topic MX_INFO_PROCESS\n+#[derive(Default)]\n+#[repr(C)]\n+pub struct mx_info_process_t {\n+    pub hdr: mx_info_header_t,\n+    pub rec: mx_record_process_t,\n+}\n+\n+extern {\n+    pub fn mx_task_kill(handle: mx_handle_t) -> mx_status_t;\n+\n+    pub fn mx_handle_close(handle: mx_handle_t) -> mx_status_t;\n+\n+    pub fn mx_handle_duplicate(handle: mx_handle_t, rights: mx_rights_t,\n+                               out: *const mx_handle_t) -> mx_handle_t;\n+\n+    pub fn mx_handle_wait_one(handle: mx_handle_t, signals: mx_signals_t, timeout: mx_time_t,\n+                              pending: *mut mx_signals_t) -> mx_status_t;\n+\n+    pub fn mx_object_get_info(handle: mx_handle_t, topic: u32, buffer: *mut c_void,\n+                              buffer_size: mx_size_t, actual_size: *mut mx_size_t,\n+                              avail: *mut mx_size_t) -> mx_status_t;\n+}\n+\n+// Handle Info entries associate a type and optional\n+// argument with each handle included in the process\n+// arguments message.\n+pub fn mx_hnd_info(hnd_type: u32, arg: u32) -> u32 {\n+    (hnd_type & 0xFFFF) | ((arg & 0xFFFF) << 16)\n+}\n+\n+extern {\n+    pub fn mxio_get_startup_handle(id: u32) -> mx_handle_t;\n+}\n+\n+// From `enum special_handles` in system/ulib/launchpad/launchpad.c\n+#[allow(unused)] pub const HND_LOADER_SVC: usize = 0;\n+// HND_EXEC_VMO = 1\n+#[allow(unused)] pub const HND_SPECIAL_COUNT: usize = 2;\n+\n+#[repr(C)]\n+pub struct launchpad_t {\n+    argc: u32,\n+    envc: u32,\n+    args: *const c_char,\n+    args_len: usize,\n+    env: *const c_char,\n+    env_len: usize,\n+\n+    handles: *mut mx_handle_t,\n+    handles_info: *mut u32,\n+    handle_count: usize,\n+    handle_alloc: usize,\n+\n+    entry: mx_vaddr_t,\n+    base: mx_vaddr_t,\n+    vdso_base: mx_vaddr_t,\n+\n+    stack_size: usize,\n+\n+    special_handles: [mx_handle_t; HND_SPECIAL_COUNT],\n+    loader_message: bool,\n+}\n+\n+extern {\n+    pub fn launchpad_create(job: mx_handle_t, name: *const c_char,\n+                            lp: *mut *mut launchpad_t) -> mx_status_t;\n+\n+    pub fn launchpad_start(lp: *mut launchpad_t) -> mx_status_t;\n+\n+    pub fn launchpad_destroy(lp: *mut launchpad_t);\n+\n+    pub fn launchpad_arguments(lp: *mut launchpad_t, argc: c_int,\n+                               argv: *const *const c_char) -> mx_status_t;\n+\n+    pub fn launchpad_environ(lp: *mut launchpad_t, envp: *const *const c_char) -> mx_status_t;\n+\n+    pub fn launchpad_clone_mxio_root(lp: *mut launchpad_t) -> mx_status_t;\n+\n+    pub fn launchpad_clone_mxio_cwd(lp: *mut launchpad_t) -> mx_status_t;\n+\n+    pub fn launchpad_clone_fd(lp: *mut launchpad_t, fd: c_int, target_fd: c_int) -> mx_status_t;\n+\n+    pub fn launchpad_transfer_fd(lp: *mut launchpad_t, fd: c_int, target_fd: c_int) -> mx_status_t;\n+\n+    pub fn launchpad_elf_load(lp: *mut launchpad_t, vmo: mx_handle_t) -> mx_status_t;\n+\n+    pub fn launchpad_add_vdso_vmo(lp: *mut launchpad_t) -> mx_status_t;\n+\n+    pub fn launchpad_load_vdso(lp: *mut launchpad_t, vmo: mx_handle_t) -> mx_status_t;\n+\n+    pub fn launchpad_vmo_from_file(filename: *const c_char) -> mx_handle_t;\n+}"}, {"sha": "b50384d8eee331fb697c82fa2a4336032374cd1b", "filename": "src/libstd/sys/unix/process/mod.rs", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/af0a0719ead0dc1c2787128f7290b57b8848c88b/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af0a0719ead0dc1c2787128f7290b57b8848c88b/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fmod.rs?ref=af0a0719ead0dc1c2787128f7290b57b8848c88b", "patch": "@@ -0,0 +1,22 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+pub use self::process_common::{Command, ExitStatus, Stdio, StdioPipes};\n+pub use self::process_inner::Process;\n+\n+mod process_common;\n+#[cfg(not(target_os = \"fuchsia\"))]\n+#[path = \"process_unix.rs\"]\n+mod process_inner;\n+#[cfg(target_os = \"fuchsia\")]\n+#[path = \"process_fuchsia.rs\"]\n+mod process_inner;\n+#[cfg(target_os = \"fuchsia\")]\n+mod magenta;"}, {"sha": "3497b266340e4c0f9dfc62cb3c39bb0f01c96b68", "filename": "src/libstd/sys/unix/process/process_common.rs", "status": "renamed", "additions": 47, "deletions": 238, "changes": 285, "blob_url": "https://github.com/rust-lang/rust/blob/af0a0719ead0dc1c2787128f7290b57b8848c88b/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af0a0719ead0dc1c2787128f7290b57b8848c88b/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_common.rs?ref=af0a0719ead0dc1c2787128f7290b57b8848c88b", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2014-2015 The Rust Project Developers. See the COPYRIGHT\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n // file at the top-level directory of this distribution and at\n // http://rust-lang.org/COPYRIGHT.\n //\n@@ -14,14 +14,12 @@ use collections::hash_map::{HashMap, Entry};\n use env;\n use ffi::{OsString, OsStr, CString, CStr};\n use fmt;\n-use io::{self, Error, ErrorKind};\n-use libc::{self, pid_t, c_int, gid_t, uid_t, c_char};\n-use mem;\n+use io;\n+use libc::{self, c_int, gid_t, uid_t, c_char};\n use ptr;\n use sys::fd::FileDesc;\n use sys::fs::{File, OpenOptions};\n use sys::pipe::{self, AnonPipe};\n-use sys::{self, cvt, cvt_r};\n \n ////////////////////////////////////////////////////////////////////////////////\n // Command\n@@ -71,13 +69,13 @@ pub struct StdioPipes {\n \n // passed to do_exec() with configuration of what the child stdio should look\n // like\n-struct ChildPipes {\n-    stdin: ChildStdio,\n-    stdout: ChildStdio,\n-    stderr: ChildStdio,\n+pub struct ChildPipes {\n+    pub stdin: ChildStdio,\n+    pub stdout: ChildStdio,\n+    pub stderr: ChildStdio,\n }\n \n-enum ChildStdio {\n+pub enum ChildStdio {\n     Inherit,\n     Explicit(c_int),\n     Owned(FileDesc),\n@@ -195,6 +193,33 @@ impl Command {\n         self.gid = Some(id);\n     }\n \n+    pub fn saw_nul(&self) -> bool {\n+        self.saw_nul\n+    }\n+    pub fn get_envp(&self) -> &Option<Vec<*const c_char>> {\n+        &self.envp\n+    }\n+    pub fn get_argv(&self) -> &Vec<*const c_char> {\n+        &self.argv\n+    }\n+\n+    #[allow(dead_code)]\n+    pub fn get_cwd(&self) -> &Option<CString> {\n+        &self.cwd\n+    }\n+    #[allow(dead_code)]\n+    pub fn get_uid(&self) -> Option<uid_t> {\n+        self.uid\n+    }\n+    #[allow(dead_code)]\n+    pub fn get_gid(&self) -> Option<gid_t> {\n+        self.gid\n+    }\n+\n+    pub fn get_closures(&mut self) -> &mut Vec<Box<FnMut() -> io::Result<()> + Send + Sync>> {\n+        &mut self.closures\n+    }\n+\n     pub fn before_exec(&mut self,\n                        f: Box<FnMut() -> io::Result<()> + Send + Sync>) {\n         self.closures.push(f);\n@@ -203,200 +228,16 @@ impl Command {\n     pub fn stdin(&mut self, stdin: Stdio) {\n         self.stdin = Some(stdin);\n     }\n+\n     pub fn stdout(&mut self, stdout: Stdio) {\n         self.stdout = Some(stdout);\n     }\n+\n     pub fn stderr(&mut self, stderr: Stdio) {\n         self.stderr = Some(stderr);\n     }\n \n-    pub fn spawn(&mut self, default: Stdio, needs_stdin: bool)\n-                 -> io::Result<(Process, StdioPipes)> {\n-        const CLOEXEC_MSG_FOOTER: &'static [u8] = b\"NOEX\";\n-\n-        if self.saw_nul {\n-            return Err(io::Error::new(ErrorKind::InvalidInput,\n-                                      \"nul byte found in provided data\"));\n-        }\n-\n-        let (ours, theirs) = self.setup_io(default, needs_stdin)?;\n-        let (input, output) = sys::pipe::anon_pipe()?;\n-\n-        let pid = unsafe {\n-            match cvt(libc::fork())? {\n-                0 => {\n-                    drop(input);\n-                    let err = self.do_exec(theirs);\n-                    let errno = err.raw_os_error().unwrap_or(libc::EINVAL) as u32;\n-                    let bytes = [\n-                        (errno >> 24) as u8,\n-                        (errno >> 16) as u8,\n-                        (errno >>  8) as u8,\n-                        (errno >>  0) as u8,\n-                        CLOEXEC_MSG_FOOTER[0], CLOEXEC_MSG_FOOTER[1],\n-                        CLOEXEC_MSG_FOOTER[2], CLOEXEC_MSG_FOOTER[3]\n-                    ];\n-                    // pipe I/O up to PIPE_BUF bytes should be atomic, and then\n-                    // we want to be sure we *don't* run at_exit destructors as\n-                    // we're being torn down regardless\n-                    assert!(output.write(&bytes).is_ok());\n-                    libc::_exit(1)\n-                }\n-                n => n,\n-            }\n-        };\n-\n-        let mut p = Process { pid: pid, status: None };\n-        drop(output);\n-        let mut bytes = [0; 8];\n-\n-        // loop to handle EINTR\n-        loop {\n-            match input.read(&mut bytes) {\n-                Ok(0) => return Ok((p, ours)),\n-                Ok(8) => {\n-                    assert!(combine(CLOEXEC_MSG_FOOTER) == combine(&bytes[4.. 8]),\n-                            \"Validation on the CLOEXEC pipe failed: {:?}\", bytes);\n-                    let errno = combine(&bytes[0.. 4]);\n-                    assert!(p.wait().is_ok(),\n-                            \"wait() should either return Ok or panic\");\n-                    return Err(Error::from_raw_os_error(errno))\n-                }\n-                Err(ref e) if e.kind() == ErrorKind::Interrupted => {}\n-                Err(e) => {\n-                    assert!(p.wait().is_ok(),\n-                            \"wait() should either return Ok or panic\");\n-                    panic!(\"the CLOEXEC pipe failed: {:?}\", e)\n-                },\n-                Ok(..) => { // pipe I/O up to PIPE_BUF bytes should be atomic\n-                    assert!(p.wait().is_ok(),\n-                            \"wait() should either return Ok or panic\");\n-                    panic!(\"short read on the CLOEXEC pipe\")\n-                }\n-            }\n-        }\n-\n-        fn combine(arr: &[u8]) -> i32 {\n-            let a = arr[0] as u32;\n-            let b = arr[1] as u32;\n-            let c = arr[2] as u32;\n-            let d = arr[3] as u32;\n-\n-            ((a << 24) | (b << 16) | (c << 8) | (d << 0)) as i32\n-        }\n-    }\n-\n-    pub fn exec(&mut self, default: Stdio) -> io::Error {\n-        if self.saw_nul {\n-            return io::Error::new(ErrorKind::InvalidInput,\n-                                  \"nul byte found in provided data\")\n-        }\n-\n-        match self.setup_io(default, true) {\n-            Ok((_, theirs)) => unsafe { self.do_exec(theirs) },\n-            Err(e) => e,\n-        }\n-    }\n-\n-    // And at this point we've reached a special time in the life of the\n-    // child. The child must now be considered hamstrung and unable to\n-    // do anything other than syscalls really. Consider the following\n-    // scenario:\n-    //\n-    //      1. Thread A of process 1 grabs the malloc() mutex\n-    //      2. Thread B of process 1 forks(), creating thread C\n-    //      3. Thread C of process 2 then attempts to malloc()\n-    //      4. The memory of process 2 is the same as the memory of\n-    //         process 1, so the mutex is locked.\n-    //\n-    // This situation looks a lot like deadlock, right? It turns out\n-    // that this is what pthread_atfork() takes care of, which is\n-    // presumably implemented across platforms. The first thing that\n-    // threads to *before* forking is to do things like grab the malloc\n-    // mutex, and then after the fork they unlock it.\n-    //\n-    // Despite this information, libnative's spawn has been witnessed to\n-    // deadlock on both OSX and FreeBSD. I'm not entirely sure why, but\n-    // all collected backtraces point at malloc/free traffic in the\n-    // child spawned process.\n-    //\n-    // For this reason, the block of code below should contain 0\n-    // invocations of either malloc of free (or their related friends).\n-    //\n-    // As an example of not having malloc/free traffic, we don't close\n-    // this file descriptor by dropping the FileDesc (which contains an\n-    // allocation). Instead we just close it manually. This will never\n-    // have the drop glue anyway because this code never returns (the\n-    // child will either exec() or invoke libc::exit)\n-    unsafe fn do_exec(&mut self, stdio: ChildPipes) -> io::Error {\n-        macro_rules! t {\n-            ($e:expr) => (match $e {\n-                Ok(e) => e,\n-                Err(e) => return e,\n-            })\n-        }\n-\n-        if let Some(fd) = stdio.stdin.fd() {\n-            t!(cvt_r(|| libc::dup2(fd, libc::STDIN_FILENO)));\n-        }\n-        if let Some(fd) = stdio.stdout.fd() {\n-            t!(cvt_r(|| libc::dup2(fd, libc::STDOUT_FILENO)));\n-        }\n-        if let Some(fd) = stdio.stderr.fd() {\n-            t!(cvt_r(|| libc::dup2(fd, libc::STDERR_FILENO)));\n-        }\n-\n-        if let Some(u) = self.gid {\n-            t!(cvt(libc::setgid(u as gid_t)));\n-        }\n-        if let Some(u) = self.uid {\n-            // When dropping privileges from root, the `setgroups` call\n-            // will remove any extraneous groups. If we don't call this,\n-            // then even though our uid has dropped, we may still have\n-            // groups that enable us to do super-user things. This will\n-            // fail if we aren't root, so don't bother checking the\n-            // return value, this is just done as an optimistic\n-            // privilege dropping function.\n-            let _ = libc::setgroups(0, ptr::null());\n-\n-            t!(cvt(libc::setuid(u as uid_t)));\n-        }\n-        if let Some(ref cwd) = self.cwd {\n-            t!(cvt(libc::chdir(cwd.as_ptr())));\n-        }\n-        if let Some(ref envp) = self.envp {\n-            *sys::os::environ() = envp.as_ptr();\n-        }\n-\n-        // NaCl has no signal support.\n-        if cfg!(not(any(target_os = \"nacl\", target_os = \"emscripten\"))) {\n-            // Reset signal handling so the child process starts in a\n-            // standardized state. libstd ignores SIGPIPE, and signal-handling\n-            // libraries often set a mask. Child processes inherit ignored\n-            // signals and the signal mask from their parent, but most\n-            // UNIX programs do not reset these things on their own, so we\n-            // need to clean things up now to avoid confusing the program\n-            // we're about to run.\n-            let mut set: libc::sigset_t = mem::uninitialized();\n-            t!(cvt(libc::sigemptyset(&mut set)));\n-            t!(cvt(libc::pthread_sigmask(libc::SIG_SETMASK, &set,\n-                                         ptr::null_mut())));\n-            let ret = super::signal(libc::SIGPIPE, libc::SIG_DFL);\n-            if ret == libc::SIG_ERR {\n-                return io::Error::last_os_error()\n-            }\n-        }\n-\n-        for callback in self.closures.iter_mut() {\n-            t!(callback());\n-        }\n-\n-        libc::execvp(self.argv[0], self.argv.as_ptr());\n-        io::Error::last_os_error()\n-    }\n-\n-\n-    fn setup_io(&self, default: Stdio, needs_stdin: bool)\n+    pub fn setup_io(&self, default: Stdio, needs_stdin: bool)\n                 -> io::Result<(StdioPipes, ChildPipes)> {\n         let null = Stdio::Null;\n         let default_stdin = if needs_stdin {&default} else {&null};\n@@ -428,10 +269,12 @@ fn os2c(s: &OsStr, saw_nul: &mut bool) -> CString {\n }\n \n impl Stdio {\n-    fn to_child_stdio(&self, readable: bool)\n+    pub fn to_child_stdio(&self, readable: bool)\n                       -> io::Result<(ChildStdio, Option<AnonPipe>)> {\n         match *self {\n-            Stdio::Inherit => Ok((ChildStdio::Inherit, None)),\n+            Stdio::Inherit => {\n+                Ok((ChildStdio::Inherit, None))\n+            },\n \n             // Make sure that the source descriptors are not an stdio\n             // descriptor, otherwise the order which we set the child's\n@@ -473,7 +316,7 @@ impl Stdio {\n }\n \n impl ChildStdio {\n-    fn fd(&self) -> Option<c_int> {\n+    pub fn fd(&self) -> Option<c_int> {\n         match *self {\n             ChildStdio::Inherit => None,\n             ChildStdio::Explicit(fd) => Some(fd),\n@@ -504,15 +347,15 @@ impl fmt::Debug for Command {\n     }\n }\n \n-////////////////////////////////////////////////////////////////////////////////\n-// Processes\n-////////////////////////////////////////////////////////////////////////////////\n-\n /// Unix exit statuses\n #[derive(PartialEq, Eq, Clone, Copy, Debug)]\n pub struct ExitStatus(c_int);\n \n impl ExitStatus {\n+    pub fn new(status: c_int) -> ExitStatus {\n+        ExitStatus(status)\n+    }\n+\n     fn exited(&self) -> bool {\n         unsafe { libc::WIFEXITED(self.0) }\n     }\n@@ -555,40 +398,6 @@ impl fmt::Display for ExitStatus {\n     }\n }\n \n-/// The unique id of the process (this should never be negative).\n-pub struct Process {\n-    pid: pid_t,\n-    status: Option<ExitStatus>,\n-}\n-\n-impl Process {\n-    pub fn id(&self) -> u32 {\n-        self.pid as u32\n-    }\n-\n-    pub fn kill(&mut self) -> io::Result<()> {\n-        // If we've already waited on this process then the pid can be recycled\n-        // and used for another process, and we probably shouldn't be killing\n-        // random processes, so just return an error.\n-        if self.status.is_some() {\n-            Err(Error::new(ErrorKind::InvalidInput,\n-                           \"invalid argument: can't kill an exited process\"))\n-        } else {\n-            cvt(unsafe { libc::kill(self.pid, libc::SIGKILL) }).map(|_| ())\n-        }\n-    }\n-\n-    pub fn wait(&mut self) -> io::Result<ExitStatus> {\n-        if let Some(status) = self.status {\n-            return Ok(status)\n-        }\n-        let mut status = 0 as c_int;\n-        cvt_r(|| unsafe { libc::waitpid(self.pid, &mut status, 0) })?;\n-        self.status = Some(ExitStatus(status));\n-        Ok(ExitStatus(status))\n-    }\n-}\n-\n #[cfg(all(test, not(target_os = \"emscripten\")))]\n mod tests {\n     use super::*;", "previous_filename": "src/libstd/sys/unix/process.rs"}, {"sha": "f0a42b127998c241881d007bd40a7041bdab9c73", "filename": "src/libstd/sys/unix/process/process_fuchsia.rs", "status": "added", "additions": 174, "deletions": 0, "changes": 174, "blob_url": "https://github.com/rust-lang/rust/blob/af0a0719ead0dc1c2787128f7290b57b8848c88b/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_fuchsia.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af0a0719ead0dc1c2787128f7290b57b8848c88b/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_fuchsia.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_fuchsia.rs?ref=af0a0719ead0dc1c2787128f7290b57b8848c88b", "patch": "@@ -0,0 +1,174 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use io;\n+use libc;\n+use mem;\n+use ptr;\n+\n+use sys::process::magenta::{Handle, launchpad_t, mx_handle_t};\n+use sys::process::process_common::*;\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Command\n+////////////////////////////////////////////////////////////////////////////////\n+\n+impl Command {\n+    pub fn spawn(&mut self, default: Stdio, needs_stdin: bool)\n+                 -> io::Result<(Process, StdioPipes)> {\n+        if self.saw_nul() {\n+            return Err(io::Error::new(io::ErrorKind::InvalidInput,\n+                                      \"nul byte found in provided data\"));\n+        }\n+\n+        let (ours, theirs) = self.setup_io(default, needs_stdin)?;\n+\n+        let (launchpad, process_handle) = unsafe { self.do_exec(theirs)? };\n+\n+        Ok((Process { launchpad: launchpad, handle: Handle::new(process_handle) }, ours))\n+    }\n+\n+    pub fn exec(&mut self, default: Stdio) -> io::Error {\n+        if self.saw_nul() {\n+            return io::Error::new(io::ErrorKind::InvalidInput,\n+                                  \"nul byte found in provided data\")\n+        }\n+\n+        match self.setup_io(default, true) {\n+            Ok((_, _)) => {\n+                // FIXME: This is tough because we don't support the exec syscalls\n+                unimplemented!();\n+            },\n+            Err(e) => e,\n+        }\n+    }\n+\n+    unsafe fn do_exec(&mut self, stdio: ChildPipes)\n+                      -> io::Result<(*mut launchpad_t, mx_handle_t)> {\n+        use sys::process::magenta::*;\n+\n+        let job_handle = mxio_get_startup_handle(mx_hnd_info(MX_HND_TYPE_JOB, 0));\n+        let envp = match *self.get_envp() {\n+            Some(ref envp) => envp.as_ptr(),\n+            None => ptr::null(),\n+        };\n+\n+        // To make sure launchpad_destroy gets called on the launchpad if this function fails\n+        struct LaunchpadDestructor(*mut launchpad_t);\n+        impl Drop for LaunchpadDestructor {\n+            fn drop(&mut self) { unsafe { launchpad_destroy(self.0); } }\n+        }\n+\n+        let mut launchpad: *mut launchpad_t = ptr::null_mut();\n+        let launchpad_destructor = LaunchpadDestructor(launchpad);\n+\n+        // Duplicate the job handle\n+        let mut job_copy: mx_handle_t = MX_HANDLE_INVALID;\n+        mx_cvt(mx_handle_duplicate(job_handle, MX_RIGHT_SAME_RIGHTS, &mut job_copy))?;\n+        // Create a launchpad\n+        mx_cvt(launchpad_create(job_copy, self.get_argv()[0], &mut launchpad))?;\n+        // Set the process argv\n+        mx_cvt(launchpad_arguments(launchpad, self.get_argv().len() as i32 - 1,\n+                                   self.get_argv().as_ptr()))?;\n+        // Setup the environment vars\n+        mx_cvt(launchpad_environ(launchpad, envp))?;\n+        mx_cvt(launchpad_add_vdso_vmo(launchpad))?;\n+        mx_cvt(launchpad_clone_mxio_root(launchpad))?;\n+        // Load the executable\n+        mx_cvt(launchpad_elf_load(launchpad, launchpad_vmo_from_file(self.get_argv()[0])))?;\n+        mx_cvt(launchpad_load_vdso(launchpad, MX_HANDLE_INVALID))?;\n+        mx_cvt(launchpad_clone_mxio_cwd(launchpad))?;\n+\n+        // Clone stdin, stdout, and stderr\n+        if let Some(fd) = stdio.stdin.fd() {\n+            launchpad_transfer_fd(launchpad, fd, 0);\n+        } else {\n+            launchpad_clone_fd(launchpad, 0, 0);\n+        }\n+        if let Some(fd) = stdio.stdout.fd() {\n+            launchpad_transfer_fd(launchpad, fd, 1);\n+        } else {\n+            launchpad_clone_fd(launchpad, 1, 1);\n+        }\n+        if let Some(fd) = stdio.stderr.fd() {\n+            launchpad_transfer_fd(launchpad, fd, 2);\n+        } else {\n+            launchpad_clone_fd(launchpad, 2, 2);\n+        }\n+\n+        // We don't want FileDesc::drop to be called on any stdio. It would close their fds. The\n+        // fds will be closed once the child process finishes.\n+        mem::forget(stdio);\n+\n+        for callback in self.get_closures().iter_mut() {\n+            callback()?;\n+        }\n+\n+        let process_handle = mx_cvt(launchpad_start(launchpad))?;\n+\n+        // Successfully started the launchpad\n+        mem::forget(launchpad_destructor);\n+\n+        Ok((launchpad, process_handle))\n+    }\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Processes\n+////////////////////////////////////////////////////////////////////////////////\n+\n+pub struct Process {\n+    launchpad: *mut launchpad_t,\n+    handle: Handle,\n+}\n+\n+impl Process {\n+    pub fn id(&self) -> u32 {\n+        self.handle.raw() as u32\n+    }\n+\n+    pub fn kill(&mut self) -> io::Result<()> {\n+        use sys::process::magenta::*;\n+\n+        unsafe { mx_cvt(mx_task_kill(self.handle.raw()))?; }\n+\n+        Ok(())\n+    }\n+\n+    pub fn wait(&mut self) -> io::Result<ExitStatus> {\n+        use default::Default;\n+        use sys::process::magenta::*;\n+\n+        let mut proc_info: mx_info_process_t = Default::default();\n+        let mut actual: mx_size_t = 0;\n+        let mut avail: mx_size_t = 0;\n+\n+        unsafe {\n+            mx_cvt(mx_handle_wait_one(self.handle.raw(), MX_TASK_TERMINATED,\n+                                      MX_TIME_INFINITE, ptr::null_mut()))?;\n+            mx_cvt(mx_object_get_info(self.handle.raw(), MX_INFO_PROCESS,\n+                                      &mut proc_info as *mut _ as *mut libc::c_void,\n+                                      mem::size_of::<mx_info_process_t>(), &mut actual,\n+                                      &mut avail))?;\n+        }\n+        if actual != 1 {\n+            return Err(io::Error::new(io::ErrorKind::InvalidData,\n+                                      \"Failed to get exit status of process\"));\n+        }\n+        Ok(ExitStatus::new(proc_info.rec.return_code))\n+    }\n+}\n+\n+impl Drop for Process {\n+    fn drop(&mut self) {\n+        use sys::process::magenta::launchpad_destroy;\n+        unsafe { launchpad_destroy(self.launchpad); }\n+    }\n+}"}, {"sha": "aa42672202559f94d5283064627808c1692c2667", "filename": "src/libstd/sys/unix/process/process_unix.rs", "status": "added", "additions": 250, "deletions": 0, "changes": 250, "blob_url": "https://github.com/rust-lang/rust/blob/af0a0719ead0dc1c2787128f7290b57b8848c88b/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/af0a0719ead0dc1c2787128f7290b57b8848c88b/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsys%2Funix%2Fprocess%2Fprocess_unix.rs?ref=af0a0719ead0dc1c2787128f7290b57b8848c88b", "patch": "@@ -0,0 +1,250 @@\n+// Copyright 2014-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+use io::{self, Error, ErrorKind};\n+use libc::{self, c_int, gid_t, pid_t, uid_t};\n+use mem;\n+use ptr;\n+\n+use sys::cvt;\n+use sys::process::process_common::*;\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Command\n+////////////////////////////////////////////////////////////////////////////////\n+\n+impl Command {\n+    pub fn spawn(&mut self, default: Stdio, needs_stdin: bool)\n+                 -> io::Result<(Process, StdioPipes)> {\n+        use sys;\n+\n+        const CLOEXEC_MSG_FOOTER: &'static [u8] = b\"NOEX\";\n+\n+        if self.saw_nul() {\n+            return Err(io::Error::new(ErrorKind::InvalidInput,\n+                                      \"nul byte found in provided data\"));\n+        }\n+\n+        let (ours, theirs) = self.setup_io(default, needs_stdin)?;\n+        let (input, output) = sys::pipe::anon_pipe()?;\n+\n+        let pid = unsafe {\n+            match cvt(libc::fork())? {\n+                0 => {\n+                    drop(input);\n+                    let err = self.do_exec(theirs);\n+                    let errno = err.raw_os_error().unwrap_or(libc::EINVAL) as u32;\n+                    let bytes = [\n+                        (errno >> 24) as u8,\n+                        (errno >> 16) as u8,\n+                        (errno >>  8) as u8,\n+                        (errno >>  0) as u8,\n+                        CLOEXEC_MSG_FOOTER[0], CLOEXEC_MSG_FOOTER[1],\n+                        CLOEXEC_MSG_FOOTER[2], CLOEXEC_MSG_FOOTER[3]\n+                    ];\n+                    // pipe I/O up to PIPE_BUF bytes should be atomic, and then\n+                    // we want to be sure we *don't* run at_exit destructors as\n+                    // we're being torn down regardless\n+                    assert!(output.write(&bytes).is_ok());\n+                    libc::_exit(1)\n+                }\n+                n => n,\n+            }\n+        };\n+\n+        let mut p = Process { pid: pid, status: None };\n+        drop(output);\n+        let mut bytes = [0; 8];\n+\n+        // loop to handle EINTR\n+        loop {\n+            match input.read(&mut bytes) {\n+                Ok(0) => return Ok((p, ours)),\n+                Ok(8) => {\n+                    assert!(combine(CLOEXEC_MSG_FOOTER) == combine(&bytes[4.. 8]),\n+                            \"Validation on the CLOEXEC pipe failed: {:?}\", bytes);\n+                    let errno = combine(&bytes[0.. 4]);\n+                    assert!(p.wait().is_ok(),\n+                            \"wait() should either return Ok or panic\");\n+                    return Err(Error::from_raw_os_error(errno))\n+                }\n+                Err(ref e) if e.kind() == ErrorKind::Interrupted => {}\n+                Err(e) => {\n+                    assert!(p.wait().is_ok(),\n+                            \"wait() should either return Ok or panic\");\n+                    panic!(\"the CLOEXEC pipe failed: {:?}\", e)\n+                },\n+                Ok(..) => { // pipe I/O up to PIPE_BUF bytes should be atomic\n+                    assert!(p.wait().is_ok(),\n+                            \"wait() should either return Ok or panic\");\n+                    panic!(\"short read on the CLOEXEC pipe\")\n+                }\n+            }\n+        }\n+\n+        fn combine(arr: &[u8]) -> i32 {\n+            let a = arr[0] as u32;\n+            let b = arr[1] as u32;\n+            let c = arr[2] as u32;\n+            let d = arr[3] as u32;\n+\n+            ((a << 24) | (b << 16) | (c << 8) | (d << 0)) as i32\n+        }\n+    }\n+\n+    pub fn exec(&mut self, default: Stdio) -> io::Error {\n+        if self.saw_nul() {\n+            return io::Error::new(ErrorKind::InvalidInput,\n+                                  \"nul byte found in provided data\")\n+        }\n+\n+        match self.setup_io(default, true) {\n+            Ok((_, theirs)) => unsafe { self.do_exec(theirs) },\n+            Err(e) => e,\n+        }\n+    }\n+\n+    // And at this point we've reached a special time in the life of the\n+    // child. The child must now be considered hamstrung and unable to\n+    // do anything other than syscalls really. Consider the following\n+    // scenario:\n+    //\n+    //      1. Thread A of process 1 grabs the malloc() mutex\n+    //      2. Thread B of process 1 forks(), creating thread C\n+    //      3. Thread C of process 2 then attempts to malloc()\n+    //      4. The memory of process 2 is the same as the memory of\n+    //         process 1, so the mutex is locked.\n+    //\n+    // This situation looks a lot like deadlock, right? It turns out\n+    // that this is what pthread_atfork() takes care of, which is\n+    // presumably implemented across platforms. The first thing that\n+    // threads to *before* forking is to do things like grab the malloc\n+    // mutex, and then after the fork they unlock it.\n+    //\n+    // Despite this information, libnative's spawn has been witnessed to\n+    // deadlock on both OSX and FreeBSD. I'm not entirely sure why, but\n+    // all collected backtraces point at malloc/free traffic in the\n+    // child spawned process.\n+    //\n+    // For this reason, the block of code below should contain 0\n+    // invocations of either malloc of free (or their related friends).\n+    //\n+    // As an example of not having malloc/free traffic, we don't close\n+    // this file descriptor by dropping the FileDesc (which contains an\n+    // allocation). Instead we just close it manually. This will never\n+    // have the drop glue anyway because this code never returns (the\n+    // child will either exec() or invoke libc::exit)\n+    unsafe fn do_exec(&mut self, stdio: ChildPipes) -> io::Error {\n+        use sys::{self, cvt_r};\n+\n+        macro_rules! t {\n+            ($e:expr) => (match $e {\n+                Ok(e) => e,\n+                Err(e) => return e,\n+            })\n+        }\n+\n+        if let Some(fd) = stdio.stdin.fd() {\n+            t!(cvt_r(|| libc::dup2(fd, libc::STDIN_FILENO)));\n+        }\n+        if let Some(fd) = stdio.stdout.fd() {\n+            t!(cvt_r(|| libc::dup2(fd, libc::STDOUT_FILENO)));\n+        }\n+        if let Some(fd) = stdio.stderr.fd() {\n+            t!(cvt_r(|| libc::dup2(fd, libc::STDERR_FILENO)));\n+        }\n+\n+        if let Some(u) = self.get_gid() {\n+            t!(cvt(libc::setgid(u as gid_t)));\n+        }\n+        if let Some(u) = self.get_uid() {\n+            // When dropping privileges from root, the `setgroups` call\n+            // will remove any extraneous groups. If we don't call this,\n+            // then even though our uid has dropped, we may still have\n+            // groups that enable us to do super-user things. This will\n+            // fail if we aren't root, so don't bother checking the\n+            // return value, this is just done as an optimistic\n+            // privilege dropping function.\n+            let _ = libc::setgroups(0, ptr::null());\n+\n+            t!(cvt(libc::setuid(u as uid_t)));\n+        }\n+        if let Some(ref cwd) = *self.get_cwd() {\n+            t!(cvt(libc::chdir(cwd.as_ptr())));\n+        }\n+        if let Some(ref envp) = *self.get_envp() {\n+            *sys::os::environ() = envp.as_ptr();\n+        }\n+\n+        // NaCl has no signal support.\n+        if cfg!(not(any(target_os = \"nacl\", target_os = \"emscripten\"))) {\n+            // Reset signal handling so the child process starts in a\n+            // standardized state. libstd ignores SIGPIPE, and signal-handling\n+            // libraries often set a mask. Child processes inherit ignored\n+            // signals and the signal mask from their parent, but most\n+            // UNIX programs do not reset these things on their own, so we\n+            // need to clean things up now to avoid confusing the program\n+            // we're about to run.\n+            let mut set: libc::sigset_t = mem::uninitialized();\n+            t!(cvt(libc::sigemptyset(&mut set)));\n+            t!(cvt(libc::pthread_sigmask(libc::SIG_SETMASK, &set,\n+                                         ptr::null_mut())));\n+            let ret = sys::signal(libc::SIGPIPE, libc::SIG_DFL);\n+            if ret == libc::SIG_ERR {\n+                return io::Error::last_os_error()\n+            }\n+        }\n+\n+        for callback in self.get_closures().iter_mut() {\n+            t!(callback());\n+        }\n+\n+        libc::execvp(self.get_argv()[0], self.get_argv().as_ptr());\n+        io::Error::last_os_error()\n+    }\n+}\n+\n+////////////////////////////////////////////////////////////////////////////////\n+// Processes\n+////////////////////////////////////////////////////////////////////////////////\n+\n+/// The unique id of the process (this should never be negative).\n+pub struct Process {\n+    pid: pid_t,\n+    status: Option<ExitStatus>,\n+}\n+\n+impl Process {\n+    pub fn id(&self) -> u32 {\n+        self.pid as u32\n+    }\n+\n+    pub fn kill(&mut self) -> io::Result<()> {\n+        // If we've already waited on this process then the pid can be recycled\n+        // and used for another process, and we probably shouldn't be killing\n+        // random processes, so just return an error.\n+        if self.status.is_some() {\n+            Err(Error::new(ErrorKind::InvalidInput,\n+                           \"invalid argument: can't kill an exited process\"))\n+        } else {\n+            cvt(unsafe { libc::kill(self.pid, libc::SIGKILL) }).map(|_| ())\n+        }\n+    }\n+    pub fn wait(&mut self) -> io::Result<ExitStatus> {\n+        use sys::cvt_r;\n+        if let Some(status) = self.status {\n+            return Ok(status)\n+        }\n+        let mut status = 0 as c_int;\n+        cvt_r(|| unsafe { libc::waitpid(self.pid, &mut status, 0) })?;\n+        self.status = Some(ExitStatus::new(status));\n+        Ok(ExitStatus::new(status))\n+    }\n+}"}]}