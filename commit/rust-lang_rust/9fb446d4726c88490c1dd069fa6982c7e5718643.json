{"sha": "9fb446d4726c88490c1dd069fa6982c7e5718643", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlmYjQ0NmQ0NzI2Yzg4NDkwYzFkZDA2OWZhNjk4MmM3ZTU3MTg2NDM=", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-11-20T01:11:55Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2019-11-28T20:20:28Z"}, "message": "Deduplicate type param constraint suggestion code", "tree": {"sha": "0eede4afcd1cb8f733d5efb55d62963e98999781", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0eede4afcd1cb8f733d5efb55d62963e98999781"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9fb446d4726c88490c1dd069fa6982c7e5718643", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9fb446d4726c88490c1dd069fa6982c7e5718643", "html_url": "https://github.com/rust-lang/rust/commit/9fb446d4726c88490c1dd069fa6982c7e5718643", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9fb446d4726c88490c1dd069fa6982c7e5718643/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "02bc412d192549977a9244174cd871b394ce4960", "url": "https://api.github.com/repos/rust-lang/rust/commits/02bc412d192549977a9244174cd871b394ce4960", "html_url": "https://github.com/rust-lang/rust/commit/02bc412d192549977a9244174cd871b394ce4960"}], "stats": {"total": 282, "additions": 128, "deletions": 154}, "files": [{"sha": "0b79f6247095b43eec05d771619a2f31b55768a4", "filename": "src/librustc/hir/mod.rs", "status": "modified", "additions": 75, "deletions": 2, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/9fb446d4726c88490c1dd069fa6982c7e5718643/src%2Flibrustc%2Fhir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fb446d4726c88490c1dd069fa6982c7e5718643/src%2Flibrustc%2Fhir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fhir%2Fmod.rs?ref=9fb446d4726c88490c1dd069fa6982c7e5718643", "patch": "@@ -16,9 +16,9 @@ use crate::ty::AdtKind;\n use crate::ty::query::Providers;\n use crate::util::nodemap::{NodeMap, FxHashSet};\n \n-use errors::FatalError;\n+use errors::{Applicability, DiagnosticBuilder, FatalError};\n use syntax_pos::{Span, DUMMY_SP, MultiSpan};\n-use syntax::source_map::Spanned;\n+use syntax::source_map::{Spanned, SourceMap};\n use syntax::ast::{self, CrateSugar, Ident, Name, NodeId, AsmDialect};\n use syntax::ast::{Attribute, Label, LitKind, StrStyle, FloatTy, IntTy, UintTy};\n pub use syntax::ast::{Mutability, Constness, Unsafety, Movability, CaptureBy};\n@@ -644,6 +644,79 @@ impl Generics {\n             self.params.iter().map(|p| p.span).collect::<Vec<Span>>().into()\n         }\n     }\n+\n+    /// Suggest restricting a type param with a new bound.\n+    pub fn suggest_constraining_type_param(\n+        &self,\n+        err: &mut DiagnosticBuilder<'_>,\n+        param_name: &str,\n+        constraint: &str,\n+        source_map: &SourceMap,\n+        span: Span,\n+    ) -> bool {\n+        let restrict_msg = \"consider further restricting this bound\";\n+        if let Some(param) = self.params.iter().filter(|p| {\n+            p.name.ident().as_str() == param_name\n+        }).next() {\n+            if param_name.starts_with(\"impl \") {\n+                // `impl Trait` in argument:\n+                // `fn foo(x: impl Trait) {}` \u2192 `fn foo(t: impl Trait + Trait2) {}`\n+                err.span_suggestion(\n+                    param.span,\n+                    restrict_msg,\n+                    // `impl CurrentTrait + MissingTrait`\n+                    format!(\"{} + {}\", param_name, constraint),\n+                    Applicability::MachineApplicable,\n+                );\n+            } else if self.where_clause.predicates.is_empty() &&\n+                    param.bounds.is_empty()\n+            {\n+                // If there are no bounds whatsoever, suggest adding a constraint\n+                // to the type parameter:\n+                // `fn foo<T>(t: T) {}` \u2192 `fn foo<T: Trait>(t: T) {}`\n+                err.span_suggestion(\n+                    param.span,\n+                    \"consider restricting this bound\",\n+                    format!(\"{}: {}\", param_name, constraint),\n+                    Applicability::MachineApplicable,\n+                );\n+            } else if !self.where_clause.predicates.is_empty() {\n+                // There is a `where` clause, so suggest expanding it:\n+                // `fn foo<T>(t: T) where T: Debug {}` \u2192\n+                // `fn foo<T>(t: T) where T: Debug, T: Trait {}`\n+                err.span_suggestion(\n+                    self.where_clause.span().unwrap().shrink_to_hi(),\n+                    &format!(\"consider further restricting type parameter `{}`\", param_name),\n+                    format!(\", {}: {}\", param_name, constraint),\n+                    Applicability::MachineApplicable,\n+                );\n+            } else {\n+                // If there is no `where` clause lean towards constraining to the\n+                // type parameter:\n+                // `fn foo<X: Bar, T>(t: T, x: X) {}` \u2192 `fn foo<T: Trait>(t: T) {}`\n+                // `fn foo<T: Bar>(t: T) {}` \u2192 `fn foo<T: Bar + Trait>(t: T) {}`\n+                let sp = param.span.with_hi(span.hi());\n+                let span = source_map.span_through_char(sp, ':');\n+                if sp != param.span && sp != span {\n+                    // Only suggest if we have high certainty that the span\n+                    // covers the colon in `foo<T: Trait>`.\n+                    err.span_suggestion(\n+                        span,\n+                        restrict_msg,\n+                        format!(\"{}: {} + \", param_name, constraint),\n+                        Applicability::MachineApplicable,\n+                    );\n+                } else {\n+                    err.span_label(\n+                        param.span,\n+                        &format!(\"consider adding a `where {}: {}` bound\", param_name, constraint),\n+                    );\n+                }\n+            }\n+            return true;\n+        }\n+        false\n+    }\n }\n \n /// Synthetic type parameters are converted to another form during lowering; this allows"}, {"sha": "db7c5c3f77876f7140c9b4c94ca8546d258eab35", "filename": "src/librustc/traits/error_reporting.rs", "status": "modified", "additions": 16, "deletions": 65, "changes": 81, "blob_url": "https://github.com/rust-lang/rust/blob/9fb446d4726c88490c1dd069fa6982c7e5718643/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fb446d4726c88490c1dd069fa6982c7e5718643/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Ftraits%2Ferror_reporting.rs?ref=9fb446d4726c88490c1dd069fa6982c7e5718643", "patch": "@@ -1091,7 +1091,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n     }\n     fn suggest_restricting_param_bound(\n         &self,\n-        err: &mut DiagnosticBuilder<'_>,\n+        mut err: &mut DiagnosticBuilder<'_>,\n         trait_ref: &ty::PolyTraitRef<'_>,\n         body_id: hir::HirId,\n     ) {\n@@ -1102,7 +1102,11 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             _ => return,\n         };\n \n-        let mut suggest_restriction = |generics: &hir::Generics, msg| {\n+        let suggest_restriction = |\n+            generics: &hir::Generics,\n+            msg,\n+            err: &mut DiagnosticBuilder<'_>,\n+        | {\n             let span = generics.where_clause.span_for_predicates_or_empty_place();\n             if !span.from_expansion() && span.desugaring_kind().is_none() {\n                 err.span_suggestion(\n@@ -1132,7 +1136,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     kind: hir::TraitItemKind::Method(..), ..\n                 }) if param_ty && self_ty == self.tcx.types.self_param => {\n                     // Restricting `Self` for a single method.\n-                    suggest_restriction(&generics, \"`Self`\");\n+                    suggest_restriction(&generics, \"`Self`\", err);\n                     return;\n                 }\n \n@@ -1154,7 +1158,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                     kind: hir::ItemKind::Impl(_, _, _, generics, ..), ..\n                 }) if projection.is_some() => {\n                     // Missing associated type bound.\n-                    suggest_restriction(&generics, \"the associated type\");\n+                    suggest_restriction(&generics, \"the associated type\", err);\n                     return;\n                 }\n \n@@ -1183,68 +1187,15 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 hir::Node::ImplItem(hir::ImplItem { generics, span, .. })\n                 if param_ty => {\n                     // Missing generic type parameter bound.\n-                    let restrict_msg = \"consider further restricting this bound\";\n                     let param_name = self_ty.to_string();\n-                    for param in generics.params.iter().filter(|p| {\n-                        p.name.ident().as_str() == param_name\n-                    }) {\n-                        if param_name.starts_with(\"impl \") {\n-                            // `impl Trait` in argument:\n-                            // `fn foo(x: impl Trait) {}` \u2192 `fn foo(t: impl Trait + Trait2) {}`\n-                            err.span_suggestion(\n-                                param.span,\n-                                restrict_msg,\n-                                // `impl CurrentTrait + MissingTrait`\n-                                format!(\"{} + {}\", param.name.ident(), trait_ref),\n-                                Applicability::MachineApplicable,\n-                            );\n-                        } else if generics.where_clause.predicates.is_empty() &&\n-                                param.bounds.is_empty()\n-                        {\n-                            // If there are no bounds whatsoever, suggest adding a constraint\n-                            // to the type parameter:\n-                            // `fn foo<T>(t: T) {}` \u2192 `fn foo<T: Trait>(t: T) {}`\n-                            err.span_suggestion(\n-                                param.span,\n-                                \"consider restricting this bound\",\n-                                format!(\"{}\", trait_ref.to_predicate()),\n-                                Applicability::MachineApplicable,\n-                            );\n-                        } else if !generics.where_clause.predicates.is_empty() {\n-                            // There is a `where` clause, so suggest expanding it:\n-                            // `fn foo<T>(t: T) where T: Debug {}` \u2192\n-                            // `fn foo<T>(t: T) where T: Debug, T: Trait {}`\n-                            err.span_suggestion(\n-                                generics.where_clause.span().unwrap().shrink_to_hi(),\n-                                &format!(\n-                                    \"consider further restricting type parameter `{}`\",\n-                                    param_name,\n-                                ),\n-                                format!(\", {}\", trait_ref.to_predicate()),\n-                                Applicability::MachineApplicable,\n-                            );\n-                        } else {\n-                            // If there is no `where` clause lean towards constraining to the\n-                            // type parameter:\n-                            // `fn foo<X: Bar, T>(t: T, x: X) {}` \u2192 `fn foo<T: Trait>(t: T) {}`\n-                            // `fn foo<T: Bar>(t: T) {}` \u2192 `fn foo<T: Bar + Trait>(t: T) {}`\n-                            let sp = param.span.with_hi(span.hi());\n-                            let span = self.tcx.sess.source_map()\n-                                .span_through_char(sp, ':');\n-                            if sp != param.span && sp != span {\n-                                // Only suggest if we have high certainty that the span\n-                                // covers the colon in `foo<T: Trait>`.\n-                                err.span_suggestion(span, restrict_msg, format!(\n-                                    \"{} + \",\n-                                    trait_ref.to_predicate(),\n-                                ), Applicability::MachineApplicable);\n-                            } else {\n-                                err.span_label(param.span, &format!(\n-                                    \"consider adding a `where {}` bound\",\n-                                    trait_ref.to_predicate(),\n-                                ));\n-                            }\n-                        }\n+                    let constraint = trait_ref.to_string();\n+                    if generics.suggest_constraining_type_param(\n+                        &mut err,\n+                        &param_name,\n+                        &constraint,\n+                        self.tcx.sess.source_map(),\n+                        *span,\n+                    ) {\n                         return;\n                     }\n                 }"}, {"sha": "e9065abcebe76c57cf4e10e89211de4239e7a7ff", "filename": "src/librustc_mir/borrow_check/conflict_errors.rs", "status": "modified", "additions": 7, "deletions": 57, "changes": 64, "blob_url": "https://github.com/rust-lang/rust/blob/9fb446d4726c88490c1dd069fa6982c7e5718643/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9fb446d4726c88490c1dd069fa6982c7e5718643/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Fborrow_check%2Fconflict_errors.rs?ref=9fb446d4726c88490c1dd069fa6982c7e5718643", "patch": "@@ -233,63 +233,13 @@ impl<'cx, 'tcx> MirBorrowckCtxt<'cx, 'tcx> {\n                     let generics = tcx.generics_of(self.mir_def_id);\n                     let param = generics.type_param(&param_ty, tcx);\n                     let generics = tcx.hir().get_generics(self.mir_def_id).unwrap();\n-                    let msg = \"consider adding a `Copy` constraint to this type argument\";\n-                    for param in generics.params.iter().filter(|p| {\n-                        p.name.ident().as_str() == param.name.as_str()\n-                    }) {\n-                        let param_name = param.name.ident().as_str();\n-                        if param_name.starts_with(\"impl \") {\n-                            // `impl Trait` in argument:\n-                            // `fn foo(x: impl Trait) {}` \u2192 `fn foo(t: impl Trait + Trait2) {}`\n-                            err.span_suggestion(\n-                                param.span,\n-                                msg,\n-                                // `impl CurrentTrait + MissingTrait`\n-                                format!(\"{} + Copy\", param_name),\n-                                Applicability::MachineApplicable,\n-                            );\n-                        } else if generics.where_clause.predicates.is_empty() &&\n-                            param.bounds.is_empty()\n-                        {\n-                            // If there are no bounds whatsoever, suggest adding a constraint\n-                            // to the type parameter:\n-                            // `fn foo<T>(t: T) {}` \u2192 `fn foo<T: Trait>(t: T) {}`\n-                            err.span_suggestion(\n-                                param.span,\n-                                msg,\n-                                format!(\"{}: Copy\", param_name),\n-                                Applicability::MachineApplicable,\n-                            );\n-                        } else if !generics.where_clause.predicates.is_empty() {\n-                            // There is a `where` clause, so suggest expanding it:\n-                            // `fn foo<T>(t: T) where T: Debug {}` \u2192\n-                            // `fn foo<T>(t: T) where T: Debug, T: Trait {}`\n-                            err.span_suggestion(\n-                                generics.where_clause.span().unwrap().shrink_to_hi(),\n-                                msg,\n-                                format!(\", {}: Copy\", param_name),\n-                                Applicability::MachineApplicable,\n-                            );\n-                        } else {\n-                            // If there is no `where` clause lean towards constraining to the\n-                            // type parameter:\n-                            // `fn foo<X: Bar, T>(t: T, x: X) {}` \u2192 `fn foo<T: Trait>(t: T) {}`\n-                            // `fn foo<T: Bar>(t: T) {}` \u2192 `fn foo<T: Bar + Trait>(t: T) {}`\n-                            let sp = param.span.with_hi(span.hi());\n-                            let span = tcx.sess.source_map()\n-                                .span_through_char(sp, ':');\n-                            if sp != param.span && sp != span {\n-                                // Only suggest if we have high certainty that the span\n-                                // covers the colon in `foo<T: Trait>`.\n-                                err.span_suggestion(span, msg, format!(\n-                                    \"{}: Copy +\",\n-                                    param_name,\n-                                ), Applicability::MachineApplicable);\n-                            } else {\n-                                err.span_label(param.span, msg);\n-                            }\n-                        }\n-                    }\n+                    generics.suggest_constraining_type_param(\n+                        &mut err,\n+                        &param.name.as_str(),\n+                        \"Copy\",\n+                        tcx.sess.source_map(),\n+                        span,\n+                    );\n                 }\n                 let span = if let Some(local) = place.as_local() {\n                     let decl = &self.body.local_decls[local];"}, {"sha": "876e984ecb0bfbba527526c503e10f5a2df82b3c", "filename": "src/test/ui/binop/binop-consume-args.stderr", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/rust-lang/rust/blob/9fb446d4726c88490c1dd069fa6982c7e5718643/src%2Ftest%2Fui%2Fbinop%2Fbinop-consume-args.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9fb446d4726c88490c1dd069fa6982c7e5718643/src%2Ftest%2Fui%2Fbinop%2Fbinop-consume-args.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbinop%2Fbinop-consume-args.stderr?ref=9fb446d4726c88490c1dd069fa6982c7e5718643", "patch": "@@ -4,7 +4,7 @@ error[E0382]: use of moved value: `lhs`\n LL | fn add<A: Add<B, Output=()>, B>(lhs: A, rhs: B) {\n    |        --                       --- move occurs because `lhs` has type `A`, which does not implement the `Copy` trait\n    |        |\n-   |        help: consider adding a `Copy` constraint to this type argument: `A: Copy +`\n+   |        help: consider further restricting this bound: `A: Copy +`\n LL |     lhs + rhs;\n    |     --- value moved here\n LL |     drop(lhs);\n@@ -16,7 +16,7 @@ error[E0382]: use of moved value: `rhs`\n LL | fn add<A: Add<B, Output=()>, B>(lhs: A, rhs: B) {\n    |                              -          --- move occurs because `rhs` has type `B`, which does not implement the `Copy` trait\n    |                              |\n-   |                              help: consider adding a `Copy` constraint to this type argument: `B: Copy`\n+   |                              help: consider restricting this bound: `B: Copy`\n LL |     lhs + rhs;\n    |           --- value moved here\n LL |     drop(lhs);\n@@ -29,7 +29,7 @@ error[E0382]: use of moved value: `lhs`\n LL | fn sub<A: Sub<B, Output=()>, B>(lhs: A, rhs: B) {\n    |        --                       --- move occurs because `lhs` has type `A`, which does not implement the `Copy` trait\n    |        |\n-   |        help: consider adding a `Copy` constraint to this type argument: `A: Copy +`\n+   |        help: consider further restricting this bound: `A: Copy +`\n LL |     lhs - rhs;\n    |     --- value moved here\n LL |     drop(lhs);\n@@ -41,7 +41,7 @@ error[E0382]: use of moved value: `rhs`\n LL | fn sub<A: Sub<B, Output=()>, B>(lhs: A, rhs: B) {\n    |                              -          --- move occurs because `rhs` has type `B`, which does not implement the `Copy` trait\n    |                              |\n-   |                              help: consider adding a `Copy` constraint to this type argument: `B: Copy`\n+   |                              help: consider restricting this bound: `B: Copy`\n LL |     lhs - rhs;\n    |           --- value moved here\n LL |     drop(lhs);\n@@ -54,7 +54,7 @@ error[E0382]: use of moved value: `lhs`\n LL | fn mul<A: Mul<B, Output=()>, B>(lhs: A, rhs: B) {\n    |        --                       --- move occurs because `lhs` has type `A`, which does not implement the `Copy` trait\n    |        |\n-   |        help: consider adding a `Copy` constraint to this type argument: `A: Copy +`\n+   |        help: consider further restricting this bound: `A: Copy +`\n LL |     lhs * rhs;\n    |     --- value moved here\n LL |     drop(lhs);\n@@ -66,7 +66,7 @@ error[E0382]: use of moved value: `rhs`\n LL | fn mul<A: Mul<B, Output=()>, B>(lhs: A, rhs: B) {\n    |                              -          --- move occurs because `rhs` has type `B`, which does not implement the `Copy` trait\n    |                              |\n-   |                              help: consider adding a `Copy` constraint to this type argument: `B: Copy`\n+   |                              help: consider restricting this bound: `B: Copy`\n LL |     lhs * rhs;\n    |           --- value moved here\n LL |     drop(lhs);\n@@ -79,7 +79,7 @@ error[E0382]: use of moved value: `lhs`\n LL | fn div<A: Div<B, Output=()>, B>(lhs: A, rhs: B) {\n    |        --                       --- move occurs because `lhs` has type `A`, which does not implement the `Copy` trait\n    |        |\n-   |        help: consider adding a `Copy` constraint to this type argument: `A: Copy +`\n+   |        help: consider further restricting this bound: `A: Copy +`\n LL |     lhs / rhs;\n    |     --- value moved here\n LL |     drop(lhs);\n@@ -91,7 +91,7 @@ error[E0382]: use of moved value: `rhs`\n LL | fn div<A: Div<B, Output=()>, B>(lhs: A, rhs: B) {\n    |                              -          --- move occurs because `rhs` has type `B`, which does not implement the `Copy` trait\n    |                              |\n-   |                              help: consider adding a `Copy` constraint to this type argument: `B: Copy`\n+   |                              help: consider restricting this bound: `B: Copy`\n LL |     lhs / rhs;\n    |           --- value moved here\n LL |     drop(lhs);\n@@ -104,7 +104,7 @@ error[E0382]: use of moved value: `lhs`\n LL | fn rem<A: Rem<B, Output=()>, B>(lhs: A, rhs: B) {\n    |        --                       --- move occurs because `lhs` has type `A`, which does not implement the `Copy` trait\n    |        |\n-   |        help: consider adding a `Copy` constraint to this type argument: `A: Copy +`\n+   |        help: consider further restricting this bound: `A: Copy +`\n LL |     lhs % rhs;\n    |     --- value moved here\n LL |     drop(lhs);\n@@ -116,7 +116,7 @@ error[E0382]: use of moved value: `rhs`\n LL | fn rem<A: Rem<B, Output=()>, B>(lhs: A, rhs: B) {\n    |                              -          --- move occurs because `rhs` has type `B`, which does not implement the `Copy` trait\n    |                              |\n-   |                              help: consider adding a `Copy` constraint to this type argument: `B: Copy`\n+   |                              help: consider restricting this bound: `B: Copy`\n LL |     lhs % rhs;\n    |           --- value moved here\n LL |     drop(lhs);\n@@ -129,7 +129,7 @@ error[E0382]: use of moved value: `lhs`\n LL | fn bitand<A: BitAnd<B, Output=()>, B>(lhs: A, rhs: B) {\n    |           --                          --- move occurs because `lhs` has type `A`, which does not implement the `Copy` trait\n    |           |\n-   |           help: consider adding a `Copy` constraint to this type argument: `A: Copy +`\n+   |           help: consider further restricting this bound: `A: Copy +`\n LL |     lhs & rhs;\n    |     --- value moved here\n LL |     drop(lhs);\n@@ -141,7 +141,7 @@ error[E0382]: use of moved value: `rhs`\n LL | fn bitand<A: BitAnd<B, Output=()>, B>(lhs: A, rhs: B) {\n    |                                    -          --- move occurs because `rhs` has type `B`, which does not implement the `Copy` trait\n    |                                    |\n-   |                                    help: consider adding a `Copy` constraint to this type argument: `B: Copy`\n+   |                                    help: consider restricting this bound: `B: Copy`\n LL |     lhs & rhs;\n    |           --- value moved here\n LL |     drop(lhs);\n@@ -154,7 +154,7 @@ error[E0382]: use of moved value: `lhs`\n LL | fn bitor<A: BitOr<B, Output=()>, B>(lhs: A, rhs: B) {\n    |          --                         --- move occurs because `lhs` has type `A`, which does not implement the `Copy` trait\n    |          |\n-   |          help: consider adding a `Copy` constraint to this type argument: `A: Copy +`\n+   |          help: consider further restricting this bound: `A: Copy +`\n LL |     lhs | rhs;\n    |     --- value moved here\n LL |     drop(lhs);\n@@ -166,7 +166,7 @@ error[E0382]: use of moved value: `rhs`\n LL | fn bitor<A: BitOr<B, Output=()>, B>(lhs: A, rhs: B) {\n    |                                  -          --- move occurs because `rhs` has type `B`, which does not implement the `Copy` trait\n    |                                  |\n-   |                                  help: consider adding a `Copy` constraint to this type argument: `B: Copy`\n+   |                                  help: consider restricting this bound: `B: Copy`\n LL |     lhs | rhs;\n    |           --- value moved here\n LL |     drop(lhs);\n@@ -179,7 +179,7 @@ error[E0382]: use of moved value: `lhs`\n LL | fn bitxor<A: BitXor<B, Output=()>, B>(lhs: A, rhs: B) {\n    |           --                          --- move occurs because `lhs` has type `A`, which does not implement the `Copy` trait\n    |           |\n-   |           help: consider adding a `Copy` constraint to this type argument: `A: Copy +`\n+   |           help: consider further restricting this bound: `A: Copy +`\n LL |     lhs ^ rhs;\n    |     --- value moved here\n LL |     drop(lhs);\n@@ -191,7 +191,7 @@ error[E0382]: use of moved value: `rhs`\n LL | fn bitxor<A: BitXor<B, Output=()>, B>(lhs: A, rhs: B) {\n    |                                    -          --- move occurs because `rhs` has type `B`, which does not implement the `Copy` trait\n    |                                    |\n-   |                                    help: consider adding a `Copy` constraint to this type argument: `B: Copy`\n+   |                                    help: consider restricting this bound: `B: Copy`\n LL |     lhs ^ rhs;\n    |           --- value moved here\n LL |     drop(lhs);\n@@ -204,7 +204,7 @@ error[E0382]: use of moved value: `lhs`\n LL | fn shl<A: Shl<B, Output=()>, B>(lhs: A, rhs: B) {\n    |        --                       --- move occurs because `lhs` has type `A`, which does not implement the `Copy` trait\n    |        |\n-   |        help: consider adding a `Copy` constraint to this type argument: `A: Copy +`\n+   |        help: consider further restricting this bound: `A: Copy +`\n LL |     lhs << rhs;\n    |     --- value moved here\n LL |     drop(lhs);\n@@ -216,7 +216,7 @@ error[E0382]: use of moved value: `rhs`\n LL | fn shl<A: Shl<B, Output=()>, B>(lhs: A, rhs: B) {\n    |                              -          --- move occurs because `rhs` has type `B`, which does not implement the `Copy` trait\n    |                              |\n-   |                              help: consider adding a `Copy` constraint to this type argument: `B: Copy`\n+   |                              help: consider restricting this bound: `B: Copy`\n LL |     lhs << rhs;\n    |            --- value moved here\n LL |     drop(lhs);\n@@ -229,7 +229,7 @@ error[E0382]: use of moved value: `lhs`\n LL | fn shr<A: Shr<B, Output=()>, B>(lhs: A, rhs: B) {\n    |        --                       --- move occurs because `lhs` has type `A`, which does not implement the `Copy` trait\n    |        |\n-   |        help: consider adding a `Copy` constraint to this type argument: `A: Copy +`\n+   |        help: consider further restricting this bound: `A: Copy +`\n LL |     lhs >> rhs;\n    |     --- value moved here\n LL |     drop(lhs);\n@@ -241,7 +241,7 @@ error[E0382]: use of moved value: `rhs`\n LL | fn shr<A: Shr<B, Output=()>, B>(lhs: A, rhs: B) {\n    |                              -          --- move occurs because `rhs` has type `B`, which does not implement the `Copy` trait\n    |                              |\n-   |                              help: consider adding a `Copy` constraint to this type argument: `B: Copy`\n+   |                              help: consider restricting this bound: `B: Copy`\n LL |     lhs >> rhs;\n    |            --- value moved here\n LL |     drop(lhs);"}, {"sha": "7552dc669749c0098c7a326f9cfb2ffc3a47d716", "filename": "src/test/ui/binop/binop-move-semantics.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9fb446d4726c88490c1dd069fa6982c7e5718643/src%2Ftest%2Fui%2Fbinop%2Fbinop-move-semantics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9fb446d4726c88490c1dd069fa6982c7e5718643/src%2Ftest%2Fui%2Fbinop%2Fbinop-move-semantics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fbinop%2Fbinop-move-semantics.stderr?ref=9fb446d4726c88490c1dd069fa6982c7e5718643", "patch": "@@ -4,7 +4,7 @@ error[E0382]: use of moved value: `x`\n LL | fn double_move<T: Add<Output=()>>(x: T) {\n    |                --                 - move occurs because `x` has type `T`, which does not implement the `Copy` trait\n    |                |\n-   |                help: consider adding a `Copy` constraint to this type argument: `T: Copy +`\n+   |                help: consider further restricting this bound: `T: Copy +`\n LL |     x\n    |     - value moved here\n LL |     +\n@@ -17,7 +17,7 @@ error[E0382]: borrow of moved value: `x`\n LL | fn move_then_borrow<T: Add<Output=()> + Clone>(x: T) {\n    |                     --                         - move occurs because `x` has type `T`, which does not implement the `Copy` trait\n    |                     |\n-   |                     help: consider adding a `Copy` constraint to this type argument: `T: Copy +`\n+   |                     help: consider further restricting this bound: `T: Copy +`\n LL |     x\n    |     - value moved here\n LL |     +"}, {"sha": "5cd0471cd0d6e520a53ddcbdfedf89b96348e414", "filename": "src/test/ui/borrowck/borrowck-unboxed-closures.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9fb446d4726c88490c1dd069fa6982c7e5718643/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-unboxed-closures.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9fb446d4726c88490c1dd069fa6982c7e5718643/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-unboxed-closures.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fborrowck%2Fborrowck-unboxed-closures.stderr?ref=9fb446d4726c88490c1dd069fa6982c7e5718643", "patch": "@@ -22,7 +22,7 @@ error[E0382]: use of moved value: `f`\n LL | fn c<F:FnOnce(isize, isize) -> isize>(f: F) {\n    |      --                               - move occurs because `f` has type `F`, which does not implement the `Copy` trait\n    |      |\n-   |      help: consider adding a `Copy` constraint to this type argument: `F: Copy +`\n+   |      help: consider further restricting this bound: `F: Copy +`\n LL |     f(1, 2);\n    |     - value moved here\n LL |     f(1, 2);"}, {"sha": "5c38f47b363e9c10d0e2b0b9e649b1327b40f331", "filename": "src/test/ui/hrtb/hrtb-higher-ranker-supertraits-transitive.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9fb446d4726c88490c1dd069fa6982c7e5718643/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-higher-ranker-supertraits-transitive.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9fb446d4726c88490c1dd069fa6982c7e5718643/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-higher-ranker-supertraits-transitive.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-higher-ranker-supertraits-transitive.stderr?ref=9fb446d4726c88490c1dd069fa6982c7e5718643", "patch": "@@ -7,7 +7,7 @@ LL |     where B : for<'ccx> Bar<'ccx>\n    |               ------------------- required by this bound in `want_bar_for_any_ccx`\n ...\n LL |     where B : Qux\n-   |                  - help: consider further restricting type parameter `B`: `, for<'ccx> B: Bar<'ccx>`\n+   |                  - help: consider further restricting type parameter `B`: `, B: for<'ccx> Bar<'ccx>`\n ...\n LL |     want_bar_for_any_ccx(b);\n    |                          ^ the trait `for<'ccx> Bar<'ccx>` is not implemented for `B`"}, {"sha": "768bc6c71847f445934d9cb820cd33a73445acd0", "filename": "src/test/ui/hrtb/hrtb-higher-ranker-supertraits.stderr", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9fb446d4726c88490c1dd069fa6982c7e5718643/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-higher-ranker-supertraits.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9fb446d4726c88490c1dd069fa6982c7e5718643/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-higher-ranker-supertraits.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fhrtb%2Fhrtb-higher-ranker-supertraits.stderr?ref=9fb446d4726c88490c1dd069fa6982c7e5718643", "patch": "@@ -2,7 +2,7 @@ error[E0277]: the trait bound `for<'tcx> F: Foo<'tcx>` is not satisfied\n   --> $DIR/hrtb-higher-ranker-supertraits.rs:18:26\n    |\n LL |     where F : Foo<'x>\n-   |                      - help: consider further restricting type parameter `F`: `, for<'tcx> F: Foo<'tcx>`\n+   |                      - help: consider further restricting type parameter `F`: `, F: for<'tcx> Foo<'tcx>`\n ...\n LL |     want_foo_for_any_tcx(f);\n    |                          ^ the trait `for<'tcx> Foo<'tcx>` is not implemented for `F`\n@@ -16,7 +16,7 @@ error[E0277]: the trait bound `for<'ccx> B: Bar<'ccx>` is not satisfied\n   --> $DIR/hrtb-higher-ranker-supertraits.rs:35:26\n    |\n LL |     where B : Bar<'x>\n-   |                      - help: consider further restricting type parameter `B`: `, for<'ccx> B: Bar<'ccx>`\n+   |                      - help: consider further restricting type parameter `B`: `, B: for<'ccx> Bar<'ccx>`\n ...\n LL |     want_bar_for_any_ccx(b);\n    |                          ^ the trait `for<'ccx> Bar<'ccx>` is not implemented for `B`"}, {"sha": "ba2810ee3d725803e3f8e2f2cca978a7fa9dd9e5", "filename": "src/test/ui/issues/issue-34721.fixed", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9fb446d4726c88490c1dd069fa6982c7e5718643/src%2Ftest%2Fui%2Fissues%2Fissue-34721.fixed", "raw_url": "https://github.com/rust-lang/rust/raw/9fb446d4726c88490c1dd069fa6982c7e5718643/src%2Ftest%2Fui%2Fissues%2Fissue-34721.fixed", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-34721.fixed?ref=9fb446d4726c88490c1dd069fa6982c7e5718643", "patch": "@@ -18,7 +18,7 @@ pub mod bar {\n mod baz {\n     use bar;\n     use Foo;\n-    pub fn baz<T: Copy + Foo>(x: T) -> T {\n+    pub fn baz<T: Copy +  Foo>(x: T) -> T {\n         if 0 == 1 {\n             bar::bar(x.zero())\n         } else {"}, {"sha": "3002b07e8c909ce64559ca1ad4575ce668fe03f6", "filename": "src/test/ui/issues/issue-34721.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9fb446d4726c88490c1dd069fa6982c7e5718643/src%2Ftest%2Fui%2Fissues%2Fissue-34721.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9fb446d4726c88490c1dd069fa6982c7e5718643/src%2Ftest%2Fui%2Fissues%2Fissue-34721.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-34721.stderr?ref=9fb446d4726c88490c1dd069fa6982c7e5718643", "patch": "@@ -4,7 +4,7 @@ error[E0382]: use of moved value: `x`\n LL |     pub fn baz<T: Foo>(x: T) -> T {\n    |                --      - move occurs because `x` has type `T`, which does not implement the `Copy` trait\n    |                |\n-   |                help: consider adding a `Copy` constraint to this type argument: `T: Copy +`\n+   |                help: consider further restricting this bound: `T: Copy +`\n LL |         if 0 == 1 {\n LL |             bar::bar(x.zero())\n    |                      - value moved here"}, {"sha": "fd9980602185653d1b6963d8f6e90b7bade4f623", "filename": "src/test/ui/once-cant-call-twice-on-heap.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9fb446d4726c88490c1dd069fa6982c7e5718643/src%2Ftest%2Fui%2Fonce-cant-call-twice-on-heap.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9fb446d4726c88490c1dd069fa6982c7e5718643/src%2Ftest%2Fui%2Fonce-cant-call-twice-on-heap.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fonce-cant-call-twice-on-heap.stderr?ref=9fb446d4726c88490c1dd069fa6982c7e5718643", "patch": "@@ -4,7 +4,7 @@ error[E0382]: use of moved value: `blk`\n LL | fn foo<F:FnOnce()>(blk: F) {\n    |        --          --- move occurs because `blk` has type `F`, which does not implement the `Copy` trait\n    |        |\n-   |        help: consider adding a `Copy` constraint to this type argument: `F: Copy +`\n+   |        help: consider further restricting this bound: `F: Copy +`\n LL |     blk();\n    |     --- value moved here\n LL |     blk();"}, {"sha": "092c419d7cba861cbf5c3ca689f47f8c38c78da6", "filename": "src/test/ui/unop-move-semantics.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9fb446d4726c88490c1dd069fa6982c7e5718643/src%2Ftest%2Fui%2Funop-move-semantics.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9fb446d4726c88490c1dd069fa6982c7e5718643/src%2Ftest%2Fui%2Funop-move-semantics.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Funop-move-semantics.stderr?ref=9fb446d4726c88490c1dd069fa6982c7e5718643", "patch": "@@ -4,7 +4,7 @@ error[E0382]: borrow of moved value: `x`\n LL | fn move_then_borrow<T: Not<Output=T> + Clone>(x: T) {\n    |                     --                        - move occurs because `x` has type `T`, which does not implement the `Copy` trait\n    |                     |\n-   |                     help: consider adding a `Copy` constraint to this type argument: `T: Copy +`\n+   |                     help: consider further restricting this bound: `T: Copy +`\n LL |     !x;\n    |      - value moved here\n LL | "}]}