{"sha": "102c8fa29028e3fd501fe297a5d7edc86697f3d9", "node_id": "C_kwDOAAsO6NoAKDEwMmM4ZmEyOTAyOGUzZmQ1MDFmZTI5N2E1ZDdlZGM4NjY5N2YzZDk", "commit": {"author": {"name": "clubby789", "email": "jamie@hill-daniel.co.uk", "date": "2023-03-12T16:55:32Z"}, "committer": {"name": "clubby789", "email": "jamie@hill-daniel.co.uk", "date": "2023-03-16T14:33:51Z"}, "message": "Render source page layout with Askama\n\nCo-authored-by: Michael Howell <michael@notriddle.com>", "tree": {"sha": "5614f3a01a1dcaf1b1bad88ccf642555ee8fb05a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/5614f3a01a1dcaf1b1bad88ccf642555ee8fb05a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/102c8fa29028e3fd501fe297a5d7edc86697f3d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/102c8fa29028e3fd501fe297a5d7edc86697f3d9", "html_url": "https://github.com/rust-lang/rust/commit/102c8fa29028e3fd501fe297a5d7edc86697f3d9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/102c8fa29028e3fd501fe297a5d7edc86697f3d9/comments", "author": {"login": "clubby789", "id": 13556931, "node_id": "MDQ6VXNlcjEzNTU2OTMx", "avatar_url": "https://avatars.githubusercontent.com/u/13556931?v=4", "gravatar_id": "", "url": "https://api.github.com/users/clubby789", "html_url": "https://github.com/clubby789", "followers_url": "https://api.github.com/users/clubby789/followers", "following_url": "https://api.github.com/users/clubby789/following{/other_user}", "gists_url": "https://api.github.com/users/clubby789/gists{/gist_id}", "starred_url": "https://api.github.com/users/clubby789/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/clubby789/subscriptions", "organizations_url": "https://api.github.com/users/clubby789/orgs", "repos_url": "https://api.github.com/users/clubby789/repos", "events_url": "https://api.github.com/users/clubby789/events{/privacy}", "received_events_url": "https://api.github.com/users/clubby789/received_events", "type": "User", "site_admin": false}, "committer": {"login": "clubby789", "id": 13556931, "node_id": "MDQ6VXNlcjEzNTU2OTMx", "avatar_url": "https://avatars.githubusercontent.com/u/13556931?v=4", "gravatar_id": "", "url": "https://api.github.com/users/clubby789", "html_url": "https://github.com/clubby789", "followers_url": "https://api.github.com/users/clubby789/followers", "following_url": "https://api.github.com/users/clubby789/following{/other_user}", "gists_url": "https://api.github.com/users/clubby789/gists{/gist_id}", "starred_url": "https://api.github.com/users/clubby789/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/clubby789/subscriptions", "organizations_url": "https://api.github.com/users/clubby789/orgs", "repos_url": "https://api.github.com/users/clubby789/repos", "events_url": "https://api.github.com/users/clubby789/events{/privacy}", "received_events_url": "https://api.github.com/users/clubby789/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "24c0b81c1fd5de8e00276524896d3352ed91a8cb", "url": "https://api.github.com/repos/rust-lang/rust/commits/24c0b81c1fd5de8e00276524896d3352ed91a8cb", "html_url": "https://github.com/rust-lang/rust/commit/24c0b81c1fd5de8e00276524896d3352ed91a8cb"}], "stats": {"total": 136, "additions": 67, "deletions": 69}, "files": [{"sha": "c099d0e4f3f4707b94808ea7dbc5e620ecd0fe2c", "filename": "src/librustdoc/html/highlight.rs", "status": "modified", "additions": 21, "deletions": 38, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/102c8fa29028e3fd501fe297a5d7edc86697f3d9/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "raw_url": "https://github.com/rust-lang/rust/raw/102c8fa29028e3fd501fe297a5d7edc86697f3d9/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fhighlight.rs?ref=102c8fa29028e3fd501fe297a5d7edc86697f3d9", "patch": "@@ -65,23 +65,6 @@ pub(crate) fn render_item_decl_with_highlighting(src: &str, out: &mut Buffer) {\n     write!(out, \"</pre>\");\n }\n \n-/// Highlights `src` as a source code page, returning the HTML output.\n-pub(crate) fn render_source_with_highlighting(\n-    src: &str,\n-    out: &mut Buffer,\n-    line_numbers: Buffer,\n-    href_context: HrefContext<'_, '_>,\n-    decoration_info: DecorationInfo,\n-    extra: Option<&str>,\n-) {\n-    write_header(out, \"\", Some(line_numbers), Tooltip::None);\n-    if let Some(extra) = extra {\n-        out.push_str(extra);\n-    }\n-    write_code(out, src, Some(href_context), Some(decoration_info));\n-    write_footer(out, None);\n-}\n-\n fn write_header(out: &mut Buffer, class: &str, extra_content: Option<Buffer>, tooltip: Tooltip) {\n     write!(\n         out,\n@@ -143,8 +126,8 @@ fn can_merge(class1: Option<Class>, class2: Option<Class>, text: &str) -> bool {\n \n /// This type is used as a conveniency to prevent having to pass all its fields as arguments into\n /// the various functions (which became its methods).\n-struct TokenHandler<'a, 'tcx> {\n-    out: &'a mut Buffer,\n+struct TokenHandler<'a, 'tcx, F: Write> {\n+    out: &'a mut F,\n     /// It contains the closing tag and the associated `Class`.\n     closing_tags: Vec<(&'static str, Class)>,\n     /// This is used because we don't automatically generate the closing tag on `ExitSpan` in\n@@ -159,7 +142,7 @@ struct TokenHandler<'a, 'tcx> {\n     href_context: Option<HrefContext<'a, 'tcx>>,\n }\n \n-impl<'a, 'tcx> TokenHandler<'a, 'tcx> {\n+impl<'a, 'tcx, F: Write> TokenHandler<'a, 'tcx, F> {\n     fn handle_exit_span(&mut self) {\n         // We can't get the last `closing_tags` element using `pop()` because `closing_tags` is\n         // being used in `write_pending_elems`.\n@@ -211,7 +194,7 @@ impl<'a, 'tcx> TokenHandler<'a, 'tcx> {\n     }\n }\n \n-impl<'a, 'tcx> Drop for TokenHandler<'a, 'tcx> {\n+impl<'a, 'tcx, F: Write> Drop for TokenHandler<'a, 'tcx, F> {\n     /// When leaving, we need to flush all pending data to not have missing content.\n     fn drop(&mut self) {\n         if self.pending_exit_span.is_some() {\n@@ -233,8 +216,8 @@ impl<'a, 'tcx> Drop for TokenHandler<'a, 'tcx> {\n /// item definition.\n ///\n /// More explanations about spans and how we use them here are provided in the\n-fn write_code(\n-    out: &mut Buffer,\n+pub(super) fn write_code(\n+    out: &mut impl Write,\n     src: &str,\n     href_context: Option<HrefContext<'_, '_>>,\n     decoration_info: Option<DecorationInfo>,\n@@ -883,7 +866,7 @@ impl<'src> Classifier<'src> {\n /// Called when we start processing a span of text that should be highlighted.\n /// The `Class` argument specifies how it should be highlighted.\n fn enter_span(\n-    out: &mut Buffer,\n+    out: &mut impl Write,\n     klass: Class,\n     href_context: &Option<HrefContext<'_, '_>>,\n ) -> &'static str {\n@@ -894,8 +877,8 @@ fn enter_span(\n }\n \n /// Called at the end of a span of highlighted text.\n-fn exit_span(out: &mut Buffer, closing_tag: &str) {\n-    out.write_str(closing_tag);\n+fn exit_span(out: &mut impl Write, closing_tag: &str) {\n+    out.write_str(closing_tag).unwrap();\n }\n \n /// Called for a span of text. If the text should be highlighted differently\n@@ -915,15 +898,15 @@ fn exit_span(out: &mut Buffer, closing_tag: &str) {\n /// will then try to find this `span` in the `span_correspondance_map`. If found, it'll then\n /// generate a link for this element (which corresponds to where its definition is located).\n fn string<T: Display>(\n-    out: &mut Buffer,\n+    out: &mut impl Write,\n     text: T,\n     klass: Option<Class>,\n     href_context: &Option<HrefContext<'_, '_>>,\n     open_tag: bool,\n ) {\n     if let Some(closing_tag) = string_without_closing_tag(out, text, klass, href_context, open_tag)\n     {\n-        out.write_str(closing_tag);\n+        out.write_str(closing_tag).unwrap();\n     }\n }\n \n@@ -937,24 +920,24 @@ fn string<T: Display>(\n ///   in `span_map.rs::collect_spans_and_sources`. If it cannot retrieve the information, then it's\n ///   the same as the second point (`klass` is `Some` but doesn't have a [`rustc_span::Span`]).\n fn string_without_closing_tag<T: Display>(\n-    out: &mut Buffer,\n+    out: &mut impl Write,\n     text: T,\n     klass: Option<Class>,\n     href_context: &Option<HrefContext<'_, '_>>,\n     open_tag: bool,\n ) -> Option<&'static str> {\n     let Some(klass) = klass\n     else {\n-        write!(out, \"{}\", text);\n+        write!(out, \"{}\", text).unwrap();\n         return None;\n     };\n     let Some(def_span) = klass.get_span()\n     else {\n         if !open_tag {\n-            write!(out, \"{}\", text);\n+            write!(out, \"{}\", text).unwrap();\n             return None;\n         }\n-        write!(out, \"<span class=\\\"{}\\\">{}\", klass.as_html(), text);\n+        write!(out, \"<span class=\\\"{}\\\">{}\", klass.as_html(), text).unwrap();\n         return Some(\"</span>\");\n     };\n \n@@ -1009,28 +992,28 @@ fn string_without_closing_tag<T: Display>(\n             if !open_tag {\n                 // We're already inside an element which has the same klass, no need to give it\n                 // again.\n-                write!(out, \"<a href=\\\"{}\\\">{}\", href, text_s);\n+                write!(out, \"<a href=\\\"{}\\\">{}\", href, text_s).unwrap();\n             } else {\n                 let klass_s = klass.as_html();\n                 if klass_s.is_empty() {\n-                    write!(out, \"<a href=\\\"{}\\\">{}\", href, text_s);\n+                    write!(out, \"<a href=\\\"{}\\\">{}\", href, text_s).unwrap();\n                 } else {\n-                    write!(out, \"<a class=\\\"{}\\\" href=\\\"{}\\\">{}\", klass_s, href, text_s);\n+                    write!(out, \"<a class=\\\"{}\\\" href=\\\"{}\\\">{}\", klass_s, href, text_s).unwrap();\n                 }\n             }\n             return Some(\"</a>\");\n         }\n     }\n     if !open_tag {\n-        write!(out, \"{}\", text_s);\n+        write!(out, \"{}\", text_s).unwrap();\n         return None;\n     }\n     let klass_s = klass.as_html();\n     if klass_s.is_empty() {\n-        write!(out, \"{}\", text_s);\n+        out.write_str(&text_s).unwrap();\n         Some(\"\")\n     } else {\n-        write!(out, \"<span class=\\\"{}\\\">{}\", klass_s, text_s);\n+        write!(out, \"<span class=\\\"{}\\\">{}\", klass_s, text_s).unwrap();\n         Some(\"</span>\")\n     }\n }"}, {"sha": "5161e8fe74d70f70852fbd23f97106ac8c3110d1", "filename": "src/librustdoc/html/sources.rs", "status": "modified", "additions": 27, "deletions": 31, "changes": 58, "blob_url": "https://github.com/rust-lang/rust/blob/102c8fa29028e3fd501fe297a5d7edc86697f3d9/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "raw_url": "https://github.com/rust-lang/rust/raw/102c8fa29028e3fd501fe297a5d7edc86697f3d9/src%2Flibrustdoc%2Fhtml%2Fsources.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fsources.rs?ref=102c8fa29028e3fd501fe297a5d7edc86697f3d9", "patch": "@@ -1,12 +1,14 @@\n use crate::clean;\n use crate::docfs::PathError;\n use crate::error::Error;\n+use crate::html::format;\n use crate::html::format::Buffer;\n use crate::html::highlight;\n use crate::html::layout;\n use crate::html::render::Context;\n use crate::visit::DocVisitor;\n \n+use askama::Template;\n use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n use rustc_hir::def_id::LOCAL_CRATE;\n use rustc_middle::ty::TyCtxt;\n@@ -16,6 +18,7 @@ use rustc_span::source_map::FileName;\n use std::cell::RefCell;\n use std::ffi::OsStr;\n use std::fs;\n+use std::ops::RangeInclusive;\n use std::path::{Component, Path, PathBuf};\n use std::rc::Rc;\n \n@@ -299,39 +302,32 @@ pub(crate) fn print_src(\n     decoration_info: highlight::DecorationInfo,\n     source_context: SourceContext,\n ) {\n+    #[derive(Template)]\n+    #[template(path = \"source.html\")]\n+    struct Source<Code: std::fmt::Display> {\n+        embedded: bool,\n+        needs_expansion: bool,\n+        lines: RangeInclusive<usize>,\n+        code_html: Code,\n+    }\n     let lines = s.lines().count();\n-    let mut line_numbers = Buffer::empty_from(buf);\n-    let extra;\n-    line_numbers.write_str(\"<pre class=\\\"src-line-numbers\\\">\");\n+    let (embedded, needs_expansion, lines) = match source_context {\n+        SourceContext::Standalone => (false, false, 1..=lines),\n+        SourceContext::Embedded { offset, needs_expansion } => {\n+            (true, needs_expansion, (1 + offset)..=(lines + offset))\n+        }\n+    };\n     let current_href = context\n         .href_from_span(clean::Span::new(file_span), false)\n         .expect(\"only local crates should have sources emitted\");\n-    match source_context {\n-        SourceContext::Standalone => {\n-            extra = None;\n-            for line in 1..=lines {\n-                writeln!(line_numbers, \"<a href=\\\"#{line}\\\" id=\\\"{line}\\\">{line}</a>\")\n-            }\n-        }\n-        SourceContext::Embedded { offset, needs_expansion } => {\n-            extra = if needs_expansion {\n-                Some(r#\"<button class=\"expand\">&varr;</button>\"#)\n-            } else {\n-                None\n-            };\n-            for line_number in 1..=lines {\n-                let line = line_number + offset;\n-                writeln!(line_numbers, \"<span>{line}</span>\")\n-            }\n-        }\n-    }\n-    line_numbers.write_str(\"</pre>\");\n-    highlight::render_source_with_highlighting(\n-        s,\n-        buf,\n-        line_numbers,\n-        highlight::HrefContext { context, file_span, root_path, current_href },\n-        decoration_info,\n-        extra,\n-    );\n+    let code = format::display_fn(move |fmt| {\n+        highlight::write_code(\n+            fmt,\n+            s,\n+            Some(highlight::HrefContext { context, file_span, root_path, current_href }),\n+            Some(decoration_info),\n+        );\n+        Ok(())\n+    });\n+    Source { embedded, needs_expansion, lines, code_html: code }.render_into(buf).unwrap();\n }"}, {"sha": "968b55ac158dcb063668ab8d38037e5a8ad306ca", "filename": "src/librustdoc/html/templates/source.html", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/rust-lang/rust/blob/102c8fa29028e3fd501fe297a5d7edc86697f3d9/src%2Flibrustdoc%2Fhtml%2Ftemplates%2Fsource.html", "raw_url": "https://github.com/rust-lang/rust/raw/102c8fa29028e3fd501fe297a5d7edc86697f3d9/src%2Flibrustdoc%2Fhtml%2Ftemplates%2Fsource.html", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Ftemplates%2Fsource.html?ref=102c8fa29028e3fd501fe297a5d7edc86697f3d9", "patch": "@@ -0,0 +1,19 @@\n+<div class=\"example-wrap\"> {# #}\n+    <pre class=\"src-line-numbers\">\n+        {% for line in lines.clone() %}\n+            {% if embedded %}\n+                <span>{{line}}</span>\n+            {%~ else %}\n+                <a href=\"#{{line}}\" id=\"{{line}}\">{{line}}</a>\n+            {%~ endif %}\n+        {% endfor %}\n+    </pre> {# #}\n+    <pre class=\"rust\"> {# #}\n+        <code>\n+            {% if needs_expansion %}\n+                <button class=\"expand\">&varr;</button>\n+            {% endif %}\n+            {{code_html|safe}}\n+        </code> {# #}\n+    </pre> {# #}\n+</div>"}]}