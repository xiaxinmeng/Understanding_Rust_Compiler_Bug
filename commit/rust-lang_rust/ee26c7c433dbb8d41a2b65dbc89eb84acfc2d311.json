{"sha": "ee26c7c433dbb8d41a2b65dbc89eb84acfc2d311", "node_id": "MDY6Q29tbWl0NzI0NzEyOmVlMjZjN2M0MzNkYmI4ZDQxYTJiNjVkYmM4OWViODRhY2ZjMmQzMTE=", "commit": {"author": {"name": "Brendan Zabarauskas", "email": "bjzaba@yahoo.com.au", "date": "2013-05-01T05:40:05Z"}, "committer": {"name": "Brendan Zabarauskas", "email": "bjzaba@yahoo.com.au", "date": "2013-05-01T05:40:05Z"}, "message": "Revert rename of Div to Quot", "tree": {"sha": "3695dcd0a6ef66dcca551d6bb87776694987ee73", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3695dcd0a6ef66dcca551d6bb87776694987ee73"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ee26c7c433dbb8d41a2b65dbc89eb84acfc2d311", "comment_count": 5, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ee26c7c433dbb8d41a2b65dbc89eb84acfc2d311", "html_url": "https://github.com/rust-lang/rust/commit/ee26c7c433dbb8d41a2b65dbc89eb84acfc2d311", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ee26c7c433dbb8d41a2b65dbc89eb84acfc2d311/comments", "author": {"login": "brendanzab", "id": 695077, "node_id": "MDQ6VXNlcjY5NTA3Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/695077?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brendanzab", "html_url": "https://github.com/brendanzab", "followers_url": "https://api.github.com/users/brendanzab/followers", "following_url": "https://api.github.com/users/brendanzab/following{/other_user}", "gists_url": "https://api.github.com/users/brendanzab/gists{/gist_id}", "starred_url": "https://api.github.com/users/brendanzab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brendanzab/subscriptions", "organizations_url": "https://api.github.com/users/brendanzab/orgs", "repos_url": "https://api.github.com/users/brendanzab/repos", "events_url": "https://api.github.com/users/brendanzab/events{/privacy}", "received_events_url": "https://api.github.com/users/brendanzab/received_events", "type": "User", "site_admin": false}, "committer": {"login": "brendanzab", "id": 695077, "node_id": "MDQ6VXNlcjY5NTA3Nw==", "avatar_url": "https://avatars.githubusercontent.com/u/695077?v=4", "gravatar_id": "", "url": "https://api.github.com/users/brendanzab", "html_url": "https://github.com/brendanzab", "followers_url": "https://api.github.com/users/brendanzab/followers", "following_url": "https://api.github.com/users/brendanzab/following{/other_user}", "gists_url": "https://api.github.com/users/brendanzab/gists{/gist_id}", "starred_url": "https://api.github.com/users/brendanzab/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/brendanzab/subscriptions", "organizations_url": "https://api.github.com/users/brendanzab/orgs", "repos_url": "https://api.github.com/users/brendanzab/repos", "events_url": "https://api.github.com/users/brendanzab/events{/privacy}", "received_events_url": "https://api.github.com/users/brendanzab/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7a857673ff76c966ceb061e3794b119e2e498c40", "url": "https://api.github.com/repos/rust-lang/rust/commits/7a857673ff76c966ceb061e3794b119e2e498c40", "html_url": "https://github.com/rust-lang/rust/commit/7a857673ff76c966ceb061e3794b119e2e498c40"}], "stats": {"total": 434, "additions": 199, "deletions": 235}, "files": [{"sha": "e23613e149ce717320b244946e50a15c2e61cbc7", "filename": "doc/rust.md", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ee26c7c433dbb8d41a2b65dbc89eb84acfc2d311/doc%2Frust.md", "raw_url": "https://github.com/rust-lang/rust/raw/ee26c7c433dbb8d41a2b65dbc89eb84acfc2d311/doc%2Frust.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/doc%2Frust.md?ref=ee26c7c433dbb8d41a2b65dbc89eb84acfc2d311", "patch": "@@ -1467,8 +1467,8 @@ A complete list of the built-in language items follows:\n   : Elements can be subtracted.\n `mul`\n   : Elements can be multiplied.\n-`quot`\n-  : Elements have a quotient operation.\n+`div`\n+  : Elements have a division operation.\n `rem`\n   : Elements have a remainder operation.\n `neg`\n@@ -1857,7 +1857,7 @@ The default meaning of the operators on standard types is given here.\n     Calls the `mul` method on the `core::ops::Mul` trait.\n `/`\n   : Quotient.\n-    Calls the `quot` method on the `core::ops::Quot` trait.\n+    Calls the `div` method on the `core::ops::Div` trait.\n `%`\n   : Remainder.\n     Calls the `rem` method on the `core::ops::Rem` trait."}, {"sha": "26398f3fe52361f5149cbaa7ac4b8e25cd65739f", "filename": "src/libcore/core.rc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ee26c7c433dbb8d41a2b65dbc89eb84acfc2d311/src%2Flibcore%2Fcore.rc", "raw_url": "https://github.com/rust-lang/rust/raw/ee26c7c433dbb8d41a2b65dbc89eb84acfc2d311/src%2Flibcore%2Fcore.rc", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcore.rc?ref=ee26c7c433dbb8d41a2b65dbc89eb84acfc2d311", "patch": "@@ -78,7 +78,7 @@ pub use ops::{Drop};\n #[cfg(stage0)]\n pub use ops::{Add, Sub, Mul, Div, Modulo, Neg, Not};\n #[cfg(not(stage0))]\n-pub use ops::{Add, Sub, Mul, Quot, Rem, Neg, Not};\n+pub use ops::{Add, Sub, Mul, Div, Rem, Neg, Not};\n pub use ops::{BitAnd, BitOr, BitXor};\n pub use ops::{Shl, Shr, Index};\n "}, {"sha": "04ddd63a177e74819e0871095c3fe82278320fb3", "filename": "src/libcore/num/f32.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ee26c7c433dbb8d41a2b65dbc89eb84acfc2d311/src%2Flibcore%2Fnum%2Ff32.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee26c7c433dbb8d41a2b65dbc89eb84acfc2d311/src%2Flibcore%2Fnum%2Ff32.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff32.rs?ref=ee26c7c433dbb8d41a2b65dbc89eb84acfc2d311", "patch": "@@ -123,7 +123,7 @@ pub fn sub(x: f32, y: f32) -> f32 { return x - y; }\n pub fn mul(x: f32, y: f32) -> f32 { return x * y; }\n \n #[inline(always)]\n-pub fn quot(x: f32, y: f32) -> f32 { return x / y; }\n+pub fn div(x: f32, y: f32) -> f32 { return x / y; }\n \n #[inline(always)]\n pub fn rem(x: f32, y: f32) -> f32 { return x % y; }\n@@ -279,16 +279,11 @@ impl Mul<f32,f32> for f32 {\n     fn mul(&self, other: &f32) -> f32 { *self * *other }\n }\n \n-#[cfg(stage0,notest)]\n+#[cfg(notest)]\n impl Div<f32,f32> for f32 {\n     #[inline(always)]\n     fn div(&self, other: &f32) -> f32 { *self / *other }\n }\n-#[cfg(not(stage0),notest)]\n-impl Quot<f32,f32> for f32 {\n-    #[inline(always)]\n-    fn quot(&self, other: &f32) -> f32 { *self / *other }\n-}\n \n #[cfg(stage0,notest)]\n impl Modulo<f32,f32> for f32 {"}, {"sha": "9f1944e3fad7fd3dc225ed66bb01bd9ee9f5ccc4", "filename": "src/libcore/num/f64.rs", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/ee26c7c433dbb8d41a2b65dbc89eb84acfc2d311/src%2Flibcore%2Fnum%2Ff64.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee26c7c433dbb8d41a2b65dbc89eb84acfc2d311/src%2Flibcore%2Fnum%2Ff64.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ff64.rs?ref=ee26c7c433dbb8d41a2b65dbc89eb84acfc2d311", "patch": "@@ -149,7 +149,7 @@ pub fn sub(x: f64, y: f64) -> f64 { return x - y; }\n pub fn mul(x: f64, y: f64) -> f64 { return x * y; }\n \n #[inline(always)]\n-pub fn quot(x: f64, y: f64) -> f64 { return x / y; }\n+pub fn div(x: f64, y: f64) -> f64 { return x / y; }\n \n #[inline(always)]\n pub fn rem(x: f64, y: f64) -> f64 { return x % y; }\n@@ -296,15 +296,10 @@ impl Sub<f64,f64> for f64 {\n impl Mul<f64,f64> for f64 {\n     fn mul(&self, other: &f64) -> f64 { *self * *other }\n }\n-#[cfg(stage0,notest)]\n+#[cfg(notest)]\n impl Div<f64,f64> for f64 {\n     fn div(&self, other: &f64) -> f64 { *self / *other }\n }\n-#[cfg(not(stage0),notest)]\n-impl Quot<f64,f64> for f64 {\n-    #[inline(always)]\n-    fn quot(&self, other: &f64) -> f64 { *self / *other }\n-}\n #[cfg(stage0,notest)]\n impl Modulo<f64,f64> for f64 {\n     fn modulo(&self, other: &f64) -> f64 { *self % *other }"}, {"sha": "f163d67a69ccbb1636a9c8c1a33f4f7deff7d8d6", "filename": "src/libcore/num/float.rs", "status": "modified", "additions": 3, "deletions": 7, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ee26c7c433dbb8d41a2b65dbc89eb84acfc2d311/src%2Flibcore%2Fnum%2Ffloat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee26c7c433dbb8d41a2b65dbc89eb84acfc2d311/src%2Flibcore%2Fnum%2Ffloat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Ffloat.rs?ref=ee26c7c433dbb8d41a2b65dbc89eb84acfc2d311", "patch": "@@ -25,7 +25,7 @@ use libc::c_int;\n use num::{Zero, One, strconv};\n use prelude::*;\n \n-pub use f64::{add, sub, mul, quot, rem, lt, le, eq, ne, ge, gt};\n+pub use f64::{add, sub, mul, div, rem, lt, le, eq, ne, ge, gt};\n pub use f64::logarithm;\n pub use f64::{acos, asin, atan2, cbrt, ceil, copysign, cosh, floor};\n pub use f64::{erf, erfc, exp, expm1, exp2, abs_sub};\n@@ -692,16 +692,12 @@ impl Mul<float,float> for float {\n     fn mul(&self, other: &float) -> float { *self * *other }\n }\n \n-#[cfg(stage0,notest)]\n+#[cfg(notest)]\n impl Div<float,float> for float {\n     #[inline(always)]\n     fn div(&self, other: &float) -> float { *self / *other }\n }\n-#[cfg(not(stage0),notest)]\n-impl Quot<float,float> for float {\n-    #[inline(always)]\n-    fn quot(&self, other: &float) -> float { *self / *other }\n-}\n+\n #[cfg(stage0,notest)]\n impl Modulo<float,float> for float {\n     #[inline(always)]"}, {"sha": "fadba84a0fe93fea461e7e87f7e5efc238b6767f", "filename": "src/libcore/num/int-template.rs", "status": "modified", "additions": 59, "deletions": 64, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/ee26c7c433dbb8d41a2b65dbc89eb84acfc2d311/src%2Flibcore%2Fnum%2Fint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee26c7c433dbb8d41a2b65dbc89eb84acfc2d311/src%2Flibcore%2Fnum%2Fint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fint-template.rs?ref=ee26c7c433dbb8d41a2b65dbc89eb84acfc2d311", "patch": "@@ -30,7 +30,7 @@ pub fn sub(x: T, y: T) -> T { x - y }\n #[inline(always)]\n pub fn mul(x: T, y: T) -> T { x * y }\n #[inline(always)]\n-pub fn quot(x: T, y: T) -> T { x / y }\n+pub fn div(x: T, y: T) -> T { x / y }\n \n ///\n /// Returns the remainder of y / x.\n@@ -201,16 +201,11 @@ impl Mul<T,T> for T {\n     fn mul(&self, other: &T) -> T { *self * *other }\n }\n \n-#[cfg(stage0,notest)]\n+#[cfg(notest)]\n impl Div<T,T> for T {\n-    #[inline(always)]\n-    fn div(&self, other: &T) -> T { *self / *other }\n-}\n-#[cfg(not(stage0),notest)]\n-impl Quot<T,T> for T {\n     ///\n-    /// Returns the integer quotient, truncated towards 0. As this behaviour reflects\n-    /// the underlying machine implementation it is more efficient than `Natural::div`.\n+    /// Integer division, truncated towards 0. As this behaviour reflects the underlying\n+    /// machine implementation it is more efficient than `Integer::div_floor`.\n     ///\n     /// # Examples\n     ///\n@@ -227,7 +222,7 @@ impl Quot<T,T> for T {\n     /// ~~~\n     ///\n     #[inline(always)]\n-    fn quot(&self, other: &T) -> T { *self / *other }\n+    fn div(&self, other: &T) -> T { *self / *other }\n }\n \n #[cfg(stage0,notest)]\n@@ -307,51 +302,51 @@ impl Integer for T {\n     /// # Examples\n     ///\n     /// ~~~\n-    /// assert!(( 8).div( 3) ==  2);\n-    /// assert!(( 8).div(-3) == -3);\n-    /// assert!((-8).div( 3) == -3);\n-    /// assert!((-8).div(-3) ==  2);\n+    /// assert!(( 8).div_floor( 3) ==  2);\n+    /// assert!(( 8).div_floor(-3) == -3);\n+    /// assert!((-8).div_floor( 3) == -3);\n+    /// assert!((-8).div_floor(-3) ==  2);\n     ///\n-    /// assert!(( 1).div( 2) ==  0);\n-    /// assert!(( 1).div(-2) == -1);\n-    /// assert!((-1).div( 2) == -1);\n-    /// assert!((-1).div(-2) ==  0);\n+    /// assert!(( 1).div_floor( 2) ==  0);\n+    /// assert!(( 1).div_floor(-2) == -1);\n+    /// assert!((-1).div_floor( 2) == -1);\n+    /// assert!((-1).div_floor(-2) ==  0);\n     /// ~~~\n     ///\n     #[inline(always)]\n-    fn div(&self, other: &T) -> T {\n+    fn div_floor(&self, other: &T) -> T {\n         // Algorithm from [Daan Leijen. _Division and Modulus for Computer Scientists_,\n         // December 2001](http://research.microsoft.com/pubs/151917/divmodnote-letter.pdf)\n-        match self.quot_rem(other) {\n-            (q, r) if (r > 0 && *other < 0)\n-                   || (r < 0 && *other > 0) => q - 1,\n-            (q, _)                          => q,\n+        match self.div_rem(other) {\n+            (d, r) if (r > 0 && *other < 0)\n+                   || (r < 0 && *other > 0) => d - 1,\n+            (d, _)                          => d,\n         }\n     }\n \n     ///\n     /// Integer modulo, satisfying:\n     ///\n     /// ~~~\n-    /// assert!(n.div(d) * d + n.modulo(d) == n)\n+    /// assert!(n.div_floor(d) * d + n.mod_floor(d) == n)\n     /// ~~~\n     ///\n     /// # Examples\n     ///\n     /// ~~~\n-    /// assert!(( 8).modulo( 3) ==  2);\n-    /// assert!(( 8).modulo(-3) == -1);\n-    /// assert!((-8).modulo( 3) ==  1);\n-    /// assert!((-8).modulo(-3) == -2);\n+    /// assert!(( 8).mod_floor( 3) ==  2);\n+    /// assert!(( 8).mod_floor(-3) == -1);\n+    /// assert!((-8).mod_floor( 3) ==  1);\n+    /// assert!((-8).mod_floor(-3) == -2);\n     ///\n-    /// assert!(( 1).modulo( 2) ==  1);\n-    /// assert!(( 1).modulo(-2) == -1);\n-    /// assert!((-1).modulo( 2) ==  1);\n-    /// assert!((-1).modulo(-2) == -1);\n+    /// assert!(( 1).mod_floor( 2) ==  1);\n+    /// assert!(( 1).mod_floor(-2) == -1);\n+    /// assert!((-1).mod_floor( 2) ==  1);\n+    /// assert!((-1).mod_floor(-2) == -1);\n     /// ~~~\n     ///\n     #[inline(always)]\n-    fn modulo(&self, other: &T) -> T {\n+    fn mod_floor(&self, other: &T) -> T {\n         // Algorithm from [Daan Leijen. _Division and Modulus for Computer Scientists_,\n         // December 2001](http://research.microsoft.com/pubs/151917/divmodnote-letter.pdf)\n         match *self % *other {\n@@ -361,21 +356,21 @@ impl Integer for T {\n         }\n     }\n \n-    /// Calculates `div` and `modulo` simultaneously\n+    /// Calculates `div_floor` and `mod_floor` simultaneously\n     #[inline(always)]\n-    fn div_mod(&self, other: &T) -> (T,T) {\n+    fn div_mod_floor(&self, other: &T) -> (T,T) {\n         // Algorithm from [Daan Leijen. _Division and Modulus for Computer Scientists_,\n         // December 2001](http://research.microsoft.com/pubs/151917/divmodnote-letter.pdf)\n-        match self.quot_rem(other) {\n-            (q, r) if (r > 0 && *other < 0)\n-                   || (r < 0 && *other > 0) => (q - 1, r + *other),\n-            (q, r)                          => (q, r),\n+        match self.div_rem(other) {\n+            (d, r) if (r > 0 && *other < 0)\n+                   || (r < 0 && *other > 0) => (d - 1, r + *other),\n+            (d, r)                          => (d, r),\n         }\n     }\n \n-    /// Calculates `quot` (`\\`) and `rem` (`%`) simultaneously\n+    /// Calculates `div` (`\\`) and `rem` (`%`) simultaneously\n     #[inline(always)]\n-    fn quot_rem(&self, other: &T) -> (T,T) {\n+    fn div_rem(&self, other: &T) -> (T,T) {\n         (*self / *other, *self % *other)\n     }\n \n@@ -599,42 +594,42 @@ mod tests {\n     }\n \n     #[test]\n-    fn test_quot_rem() {\n-        fn test_nd_qr(nd: (T,T), qr: (T,T)) {\n+    fn test_div_rem() {\n+        fn test_nd_dr(nd: (T,T), qr: (T,T)) {\n             let (n,d) = nd;\n-            let separate_quot_rem = (n / d, n % d);\n-            let combined_quot_rem = n.quot_rem(&d);\n+            let separate_div_rem = (n / d, n % d);\n+            let combined_div_rem = n.div_rem(&d);\n \n-            assert_eq!(separate_quot_rem, qr);\n-            assert_eq!(combined_quot_rem, qr);\n+            assert_eq!(separate_div_rem, qr);\n+            assert_eq!(combined_div_rem, qr);\n \n-            test_division_rule(nd, separate_quot_rem);\n-            test_division_rule(nd, combined_quot_rem);\n+            test_division_rule(nd, separate_div_rem);\n+            test_division_rule(nd, combined_div_rem);\n         }\n \n-        test_nd_qr(( 8,  3), ( 2,  2));\n-        test_nd_qr(( 8, -3), (-2,  2));\n-        test_nd_qr((-8,  3), (-2, -2));\n-        test_nd_qr((-8, -3), ( 2, -2));\n+        test_nd_dr(( 8,  3), ( 2,  2));\n+        test_nd_dr(( 8, -3), (-2,  2));\n+        test_nd_dr((-8,  3), (-2, -2));\n+        test_nd_dr((-8, -3), ( 2, -2));\n \n-        test_nd_qr(( 1,  2), ( 0,  1));\n-        test_nd_qr(( 1, -2), ( 0,  1));\n-        test_nd_qr((-1,  2), ( 0, -1));\n-        test_nd_qr((-1, -2), ( 0, -1));\n+        test_nd_dr(( 1,  2), ( 0,  1));\n+        test_nd_dr(( 1, -2), ( 0,  1));\n+        test_nd_dr((-1,  2), ( 0, -1));\n+        test_nd_dr((-1, -2), ( 0, -1));\n     }\n \n     #[test]\n-    fn test_div_mod() {\n+    fn test_div_mod_floor() {\n         fn test_nd_dm(nd: (T,T), dm: (T,T)) {\n             let (n,d) = nd;\n-            let separate_div_mod = (n.div(&d), n.modulo(&d));\n-            let combined_div_mod = n.div_mod(&d);\n+            let separate_div_mod_floor = (n.div_floor(&d), n.mod_floor(&d));\n+            let combined_div_mod_floor = n.div_mod_floor(&d);\n \n-            assert_eq!(separate_div_mod, dm);\n-            assert_eq!(combined_div_mod, dm);\n+            assert_eq!(separate_div_mod_floor, dm);\n+            assert_eq!(combined_div_mod_floor, dm);\n \n-            test_division_rule(nd, separate_div_mod);\n-            test_division_rule(nd, combined_div_mod);\n+            test_division_rule(nd, separate_div_mod_floor);\n+            test_division_rule(nd, combined_div_mod_floor);\n         }\n \n         test_nd_dm(( 8,  3), ( 2,  2));"}, {"sha": "b8f47db7d128e791c20cd0d2ce55c068ab346870", "filename": "src/libcore/num/num.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/ee26c7c433dbb8d41a2b65dbc89eb84acfc2d311/src%2Flibcore%2Fnum%2Fnum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee26c7c433dbb8d41a2b65dbc89eb84acfc2d311/src%2Flibcore%2Fnum%2Fnum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fnum.rs?ref=ee26c7c433dbb8d41a2b65dbc89eb84acfc2d311", "patch": "@@ -11,13 +11,11 @@\n //! An interface for numeric types\n use cmp::{Eq, Ord};\n #[cfg(stage0)]\n-use ops::{Add, Sub, Mul, Neg};\n-#[cfg(stage0)]\n-use Quot = ops::Div;\n+use ops::{Add, Sub, Mul, Div, Neg};\n #[cfg(stage0)]\n use Rem = ops::Modulo;\n #[cfg(not(stage0))]\n-use ops::{Add, Sub, Mul, Quot, Rem, Neg};\n+use ops::{Add, Sub, Mul, Div, Rem, Neg};\n use ops::{Not, BitAnd, BitOr, BitXor, Shl, Shr};\n use option::Option;\n use kinds::Copy;\n@@ -32,7 +30,7 @@ pub trait Num: Eq + Zero + One\n              + Add<Self,Self>\n              + Sub<Self,Self>\n              + Mul<Self,Self>\n-             + Quot<Self,Self>\n+             + Div<Self,Self>\n              + Rem<Self,Self> {}\n \n pub trait IntConvertible {\n@@ -76,12 +74,13 @@ pub fn abs<T:Ord + Zero + Neg<T>>(v: T) -> T {\n \n pub trait Integer: Num\n                  + Orderable\n-                 + Quot<Self,Self>\n+                 + Div<Self,Self>\n                  + Rem<Self,Self> {\n-    fn div(&self, other: &Self) -> Self;\n-    fn modulo(&self, other: &Self) -> Self;\n-    fn div_mod(&self, other: &Self) -> (Self,Self);\n-    fn quot_rem(&self, other: &Self) -> (Self,Self);\n+    fn div_rem(&self, other: &Self) -> (Self,Self);\n+\n+    fn div_floor(&self, other: &Self) -> Self;\n+    fn mod_floor(&self, other: &Self) -> Self;\n+    fn div_mod_floor(&self, other: &Self) -> (Self,Self);\n \n     fn gcd(&self, other: &Self) -> Self;\n     fn lcm(&self, other: &Self) -> Self;\n@@ -102,7 +101,7 @@ pub trait Round {\n pub trait Fractional: Num\n                     + Orderable\n                     + Round\n-                    + Quot<Self,Self> {\n+                    + Div<Self,Self> {\n     fn recip(&self) -> Self;\n }\n \n@@ -226,7 +225,7 @@ pub trait Primitive: Num\n                    + Add<Self,Self>\n                    + Sub<Self,Self>\n                    + Mul<Self,Self>\n-                   + Quot<Self,Self>\n+                   + Div<Self,Self>\n                    + Rem<Self,Self> {\n     // FIXME (#5527): These should be associated constants\n     fn bits() -> uint;\n@@ -371,7 +370,7 @@ pub trait FromStrRadix {\n /// - If code written to use this function doesn't care about it, it's\n ///   probably assuming that `x^0` always equals `1`.\n ///\n-pub fn pow_with_uint<T:NumCast+One+Zero+Copy+Quot<T,T>+Mul<T,T>>(\n+pub fn pow_with_uint<T:NumCast+One+Zero+Copy+Div<T,T>+Mul<T,T>>(\n     radix: uint, pow: uint) -> T {\n     let _0: T = Zero::zero();\n     let _1: T = One::one();\n@@ -413,13 +412,13 @@ pub fn test_num<T:Num + NumCast>(ten: T, two: T) {\n     assert_eq!(ten.add(&two),  cast(12));\n     assert_eq!(ten.sub(&two),  cast(8));\n     assert_eq!(ten.mul(&two),  cast(20));\n-    assert_eq!(ten.quot(&two), cast(5));\n+    assert_eq!(ten.div(&two), cast(5));\n     assert_eq!(ten.rem(&two),  cast(0));\n \n     assert_eq!(ten.add(&two),  ten + two);\n     assert_eq!(ten.sub(&two),  ten - two);\n     assert_eq!(ten.mul(&two),  ten * two);\n-    assert_eq!(ten.quot(&two), ten / two);\n+    assert_eq!(ten.div(&two), ten / two);\n     assert_eq!(ten.rem(&two),  ten % two);\n }\n "}, {"sha": "68e3b407a8bc2650fc2710ce18341e69f6109331", "filename": "src/libcore/num/strconv.rs", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/ee26c7c433dbb8d41a2b65dbc89eb84acfc2d311/src%2Flibcore%2Fnum%2Fstrconv.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee26c7c433dbb8d41a2b65dbc89eb84acfc2d311/src%2Flibcore%2Fnum%2Fstrconv.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fstrconv.rs?ref=ee26c7c433dbb8d41a2b65dbc89eb84acfc2d311", "patch": "@@ -10,15 +10,13 @@\n \n use core::cmp::{Ord, Eq};\n #[cfg(stage0)]\n-use ops::{Add, Sub, Mul, Neg};\n-#[cfg(stage0)]\n-use Quot = ops::Div;\n+use ops::{Add, Sub, Mul, Div, Neg};\n #[cfg(stage0)]\n use Rem = ops::Modulo;\n #[cfg(stage1)]\n #[cfg(stage2)]\n #[cfg(stage3)]\n-use ops::{Add, Sub, Mul, Quot, Rem, Neg};\n+use ops::{Add, Sub, Mul, Div, Rem, Neg};\n use option::{None, Option, Some};\n use char;\n use str;\n@@ -67,7 +65,7 @@ fn is_neg_inf<T:Eq+NumStrConv>(num: &T) -> bool {\n }\n \n #[inline(always)]\n-fn is_neg_zero<T:Eq+One+Zero+NumStrConv+Quot<T,T>>(num: &T) -> bool {\n+fn is_neg_zero<T:Eq+One+Zero+NumStrConv+Div<T,T>>(num: &T) -> bool {\n     let _0: T = Zero::zero();\n     let _1: T = One::one();\n \n@@ -180,7 +178,7 @@ static nan_buf:          [u8, ..3] = ['N' as u8, 'a' as u8, 'N' as u8];\n  * - Fails if `radix` < 2 or `radix` > 36.\n  */\n pub fn to_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+NumStrConv+Copy+\n-                                  Quot<T,T>+Neg<T>+Rem<T,T>+Mul<T,T>>(\n+                                  Div<T,T>+Neg<T>+Rem<T,T>+Mul<T,T>>(\n         num: &T, radix: uint, negative_zero: bool,\n         sign: SignFormat, digits: SignificantDigits) -> (~[u8], bool) {\n     if (radix as int) < 2 {\n@@ -388,7 +386,7 @@ pub fn to_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+NumStrConv+Copy+\n  */\n #[inline(always)]\n pub fn to_str_common<T:NumCast+Zero+One+Eq+Ord+NumStrConv+Copy+\n-                            Quot<T,T>+Neg<T>+Rem<T,T>+Mul<T,T>>(\n+                            Div<T,T>+Neg<T>+Rem<T,T>+Mul<T,T>>(\n         num: &T, radix: uint, negative_zero: bool,\n         sign: SignFormat, digits: SignificantDigits) -> (~str, bool) {\n     let (bytes, special) = to_str_bytes_common(num, radix,\n@@ -441,7 +439,7 @@ priv static DIGIT_E_RADIX: uint = ('e' as uint) - ('a' as uint) + 11u;\n  * - Fails if `radix` > 18 and `special == true` due to conflict\n  *   between digit and lowest first character in `inf` and `NaN`, the `'i'`.\n  */\n-pub fn from_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Copy+Quot<T,T>+\n+pub fn from_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Copy+Div<T,T>+\n                                     Mul<T,T>+Sub<T,T>+Neg<T>+Add<T,T>+\n                                     NumStrConv>(\n         buf: &[u8], radix: uint, negative: bool, fractional: bool,\n@@ -638,7 +636,7 @@ pub fn from_str_bytes_common<T:NumCast+Zero+One+Eq+Ord+Copy+Quot<T,T>+\n  * `from_str_bytes_common()`, for details see there.\n  */\n #[inline(always)]\n-pub fn from_str_common<T:NumCast+Zero+One+Eq+Ord+Copy+Quot<T,T>+Mul<T,T>+\n+pub fn from_str_common<T:NumCast+Zero+One+Eq+Ord+Copy+Div<T,T>+Mul<T,T>+\n                               Sub<T,T>+Neg<T>+Add<T,T>+NumStrConv>(\n         buf: &str, radix: uint, negative: bool, fractional: bool,\n         special: bool, exponent: ExponentFormat, empty_zero: bool,"}, {"sha": "f6b98989545d05d5ca43e370bcf40afd04f0afb0", "filename": "src/libcore/num/uint-template.rs", "status": "modified", "additions": 12, "deletions": 17, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/ee26c7c433dbb8d41a2b65dbc89eb84acfc2d311/src%2Flibcore%2Fnum%2Fuint-template.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee26c7c433dbb8d41a2b65dbc89eb84acfc2d311/src%2Flibcore%2Fnum%2Fuint-template.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fnum%2Fuint-template.rs?ref=ee26c7c433dbb8d41a2b65dbc89eb84acfc2d311", "patch": "@@ -31,7 +31,7 @@ pub fn sub(x: T, y: T) -> T { x - y }\n #[inline(always)]\n pub fn mul(x: T, y: T) -> T { x * y }\n #[inline(always)]\n-pub fn quot(x: T, y: T) -> T { x / y }\n+pub fn div(x: T, y: T) -> T { x / y }\n #[inline(always)]\n pub fn rem(x: T, y: T) -> T { x % y }\n \n@@ -166,16 +166,11 @@ impl Mul<T,T> for T {\n     fn mul(&self, other: &T) -> T { *self * *other }\n }\n \n-#[cfg(stage0,notest)]\n+#[cfg(notest)]\n impl Div<T,T> for T {\n     #[inline(always)]\n     fn div(&self, other: &T) -> T { *self / *other }\n }\n-#[cfg(not(stage0),notest)]\n-impl Quot<T,T> for T {\n-    #[inline(always)]\n-    fn quot(&self, other: &T) -> T { *self / *other }\n-}\n \n #[cfg(stage0,notest)]\n impl Modulo<T,T> for T {\n@@ -197,23 +192,23 @@ impl Neg<T> for T {\n impl Unsigned for T {}\n \n impl Integer for T {\n-    /// Unsigned integer division. Returns the same result as `quot` (`/`).\n+    /// Calculates `div` (`\\`) and `rem` (`%`) simultaneously\n     #[inline(always)]\n-    fn div(&self, other: &T) -> T { *self / *other }\n+    fn div_rem(&self, other: &T) -> (T,T) {\n+        (*self / *other, *self % *other)\n+    }\n \n-    /// Unsigned integer modulo operation. Returns the same result as `rem` (`%`).\n+    /// Unsigned integer division. Returns the same result as `div` (`/`).\n     #[inline(always)]\n-    fn modulo(&self, other: &T) -> T { *self / *other }\n+    fn div_floor(&self, other: &T) -> T { *self / *other }\n \n-    /// Calculates `div` and `modulo` simultaneously\n+    /// Unsigned integer modulo operation. Returns the same result as `rem` (`%`).\n     #[inline(always)]\n-    fn div_mod(&self, other: &T) -> (T,T) {\n-        (*self / *other, *self % *other)\n-    }\n+    fn mod_floor(&self, other: &T) -> T { *self / *other }\n \n-    /// Calculates `quot` (`\\`) and `rem` (`%`) simultaneously\n+    /// Calculates `div_floor` and `modulo_floor` simultaneously\n     #[inline(always)]\n-    fn quot_rem(&self, other: &T) -> (T,T) {\n+    fn div_mod_floor(&self, other: &T) -> (T,T) {\n         (*self / *other, *self % *other)\n     }\n "}, {"sha": "5ba860c89c9b915e0d3f999480ea9caed60233f0", "filename": "src/libcore/ops.rs", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ee26c7c433dbb8d41a2b65dbc89eb84acfc2d311/src%2Flibcore%2Fops.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee26c7c433dbb8d41a2b65dbc89eb84acfc2d311/src%2Flibcore%2Fops.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fops.rs?ref=ee26c7c433dbb8d41a2b65dbc89eb84acfc2d311", "patch": "@@ -31,15 +31,9 @@ pub trait Mul<RHS,Result> {\n }\n \n #[lang=\"div\"]\n-#[cfg(stage0)]\n pub trait Div<RHS,Result> {\n     fn div(&self, rhs: &RHS) -> Result;\n }\n-#[lang=\"quot\"]\n-#[cfg(not(stage0))]\n-pub trait Quot<RHS,Result> {\n-    fn quot(&self, rhs: &RHS) -> Result;\n-}\n \n #[lang=\"modulo\"]\n #[cfg(stage0)]"}, {"sha": "4527fcf2923da0102de0e973cbd4d702e4925fcf", "filename": "src/libcore/prelude.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ee26c7c433dbb8d41a2b65dbc89eb84acfc2d311/src%2Flibcore%2Fprelude.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee26c7c433dbb8d41a2b65dbc89eb84acfc2d311/src%2Flibcore%2Fprelude.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fprelude.rs?ref=ee26c7c433dbb8d41a2b65dbc89eb84acfc2d311", "patch": "@@ -17,7 +17,7 @@ pub use kinds::{Const, Copy, Owned, Durable};\n #[cfg(stage0)]\n pub use ops::{Add, Sub, Mul, Div, Modulo, Neg, Not};\n #[cfg(not(stage0))]\n-pub use ops::{Add, Sub, Mul, Quot, Rem, Neg, Not};\n+pub use ops::{Add, Sub, Mul, Div, Rem, Neg, Not};\n pub use ops::{BitAnd, BitOr, BitXor};\n pub use ops::{Drop};\n pub use ops::{Shl, Shr, Index};"}, {"sha": "86b7379bb698ddb5a0e738bf70896e0b15996a45", "filename": "src/librustc/middle/const_eval.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ee26c7c433dbb8d41a2b65dbc89eb84acfc2d311/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee26c7c433dbb8d41a2b65dbc89eb84acfc2d311/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fconst_eval.rs?ref=ee26c7c433dbb8d41a2b65dbc89eb84acfc2d311", "patch": "@@ -279,7 +279,7 @@ pub fn eval_const_expr_partial(tcx: middle::ty::ctxt, e: @expr)\n               add => Ok(const_float(a + b)),\n               subtract => Ok(const_float(a - b)),\n               mul => Ok(const_float(a * b)),\n-              quot => Ok(const_float(a / b)),\n+              div => Ok(const_float(a / b)),\n               rem => Ok(const_float(a % b)),\n               eq => fromb(a == b),\n               lt => fromb(a < b),\n@@ -295,8 +295,8 @@ pub fn eval_const_expr_partial(tcx: middle::ty::ctxt, e: @expr)\n               add => Ok(const_int(a + b)),\n               subtract => Ok(const_int(a - b)),\n               mul => Ok(const_int(a * b)),\n-              quot if b == 0 => Err(~\"attempted quotient with a divisor of zero\"),\n-              quot => Ok(const_int(a / b)),\n+              div if b == 0 => Err(~\"attempted to divide by zero\"),\n+              div => Ok(const_int(a / b)),\n               rem if b == 0 => Err(~\"attempted remainder with a divisor of zero\"),\n               rem => Ok(const_int(a % b)),\n               and | bitand => Ok(const_int(a & b)),\n@@ -317,8 +317,8 @@ pub fn eval_const_expr_partial(tcx: middle::ty::ctxt, e: @expr)\n               add => Ok(const_uint(a + b)),\n               subtract => Ok(const_uint(a - b)),\n               mul => Ok(const_uint(a * b)),\n-              quot if b == 0 => Err(~\"attempted quotient with a divisor of zero\"),\n-              quot => Ok(const_uint(a / b)),\n+              div if b == 0 => Err(~\"attempted to divide by zero\"),\n+              div => Ok(const_uint(a / b)),\n               rem if b == 0 => Err(~\"attempted remainder with a divisor of zero\"),\n               rem => Ok(const_uint(a % b)),\n               and | bitand => Ok(const_uint(a & b)),"}, {"sha": "7298064e1c00d598335fb5dc00e6edefcc8d697d", "filename": "src/librustc/middle/lang_items.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/ee26c7c433dbb8d41a2b65dbc89eb84acfc2d311/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee26c7c433dbb8d41a2b65dbc89eb84acfc2d311/src%2Flibrustc%2Fmiddle%2Flang_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Flang_items.rs?ref=ee26c7c433dbb8d41a2b65dbc89eb84acfc2d311", "patch": "@@ -42,7 +42,7 @@ pub enum LangItem {\n     AddTraitLangItem,           // 5\n     SubTraitLangItem,           // 6\n     MulTraitLangItem,           // 7\n-    QuotTraitLangItem,          // 8\n+    DivTraitLangItem,           // 8\n     RemTraitLangItem,           // 9\n     NegTraitLangItem,           // 10\n     NotTraitLangItem,           // 11\n@@ -105,7 +105,7 @@ pub impl LanguageItems {\n             5  => \"add\",\n             6  => \"sub\",\n             7  => \"mul\",\n-            8  => \"quot\",\n+            8  => \"div\",\n             9  => \"rem\",\n             10 => \"neg\",\n             11 => \"not\",\n@@ -167,8 +167,8 @@ pub impl LanguageItems {\n     pub fn mul_trait(&const self) -> def_id {\n         self.items[MulTraitLangItem as uint].get()\n     }\n-    pub fn quot_trait(&const self) -> def_id {\n-        self.items[QuotTraitLangItem as uint].get()\n+    pub fn div_trait(&const self) -> def_id {\n+        self.items[DivTraitLangItem as uint].get()\n     }\n     pub fn rem_trait(&const self) -> def_id {\n         self.items[RemTraitLangItem as uint].get()\n@@ -268,7 +268,7 @@ fn LanguageItemCollector<'r>(crate: @crate,\n     item_refs.insert(@~\"add\", AddTraitLangItem as uint);\n     item_refs.insert(@~\"sub\", SubTraitLangItem as uint);\n     item_refs.insert(@~\"mul\", MulTraitLangItem as uint);\n-    item_refs.insert(@~\"quot\", QuotTraitLangItem as uint);\n+    item_refs.insert(@~\"div\", DivTraitLangItem as uint);\n     item_refs.insert(@~\"rem\", RemTraitLangItem as uint);\n     item_refs.insert(@~\"neg\", NegTraitLangItem as uint);\n     item_refs.insert(@~\"not\", NotTraitLangItem as uint);"}, {"sha": "d8ad53212e2b7797aa1bd0270ae594f26b654e29", "filename": "src/librustc/middle/resolve.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ee26c7c433dbb8d41a2b65dbc89eb84acfc2d311/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee26c7c433dbb8d41a2b65dbc89eb84acfc2d311/src%2Flibrustc%2Fmiddle%2Fresolve.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fresolve.rs?ref=ee26c7c433dbb8d41a2b65dbc89eb84acfc2d311", "patch": "@@ -33,7 +33,7 @@ use syntax::ast::{def_upvar, def_use, def_variant, expr, expr_assign_op};\n use syntax::ast::{expr_binary, expr_break, expr_field};\n use syntax::ast::{expr_fn_block, expr_index, expr_method_call, expr_path};\n use syntax::ast::{def_prim_ty, def_region, def_self, def_ty, def_ty_param};\n-use syntax::ast::{def_upvar, def_use, def_variant, quot, eq};\n+use syntax::ast::{def_upvar, def_use, def_variant, div, eq};\n use syntax::ast::{expr, expr_again, expr_assign_op};\n use syntax::ast::{expr_index, expr_loop};\n use syntax::ast::{expr_path, expr_struct, expr_unary, fn_decl};\n@@ -4901,9 +4901,9 @@ pub impl Resolver {\n                 self.add_fixed_trait_for_expr(expr.id,\n                                               self.lang_items.mul_trait());\n             }\n-            expr_binary(quot, _, _) | expr_assign_op(quot, _, _) => {\n+            expr_binary(div, _, _) | expr_assign_op(div, _, _) => {\n                 self.add_fixed_trait_for_expr(expr.id,\n-                                              self.lang_items.quot_trait());\n+                                              self.lang_items.div_trait());\n             }\n             expr_binary(rem, _, _) | expr_assign_op(rem, _, _) => {\n                 self.add_fixed_trait_for_expr(expr.id,"}, {"sha": "262196ffffd5c07a564ac4b355df24746509a2ca", "filename": "src/librustc/middle/trans/base.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ee26c7c433dbb8d41a2b65dbc89eb84acfc2d311/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee26c7c433dbb8d41a2b65dbc89eb84acfc2d311/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fbase.rs?ref=ee26c7c433dbb8d41a2b65dbc89eb84acfc2d311", "patch": "@@ -777,10 +777,10 @@ pub fn cast_shift_rhs(op: ast::binop,\n     }\n }\n \n-pub fn fail_if_zero(cx: block, span: span, quotrem: ast::binop,\n+pub fn fail_if_zero(cx: block, span: span, divrem: ast::binop,\n                     rhs: ValueRef, rhs_t: ty::t) -> block {\n-    let text = if quotrem == ast::quot {\n-        @~\"attempted quotient with a divisor of zero\"\n+    let text = if divrem == ast::div {\n+        @~\"attempted to divide by zero\"\n     } else {\n         @~\"attempted remainder with a divisor of zero\"\n     };"}, {"sha": "c6c5561854c0dccb5804a0583545a9ec726fafda", "filename": "src/librustc/middle/trans/consts.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ee26c7c433dbb8d41a2b65dbc89eb84acfc2d311/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee26c7c433dbb8d41a2b65dbc89eb84acfc2d311/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fconsts.rs?ref=ee26c7c433dbb8d41a2b65dbc89eb84acfc2d311", "patch": "@@ -270,7 +270,7 @@ fn const_expr_unadjusted(cx: @CrateContext, e: @ast::expr) -> ValueRef {\n                 if is_float { llvm::LLVMConstFMul(te1, te2) }\n                 else        { llvm::LLVMConstMul(te1, te2) }\n               }\n-              ast::quot   => {\n+              ast::div    => {\n                 if is_float    { llvm::LLVMConstFDiv(te1, te2) }\n                 else if signed { llvm::LLVMConstSDiv(te1, te2) }\n                 else           { llvm::LLVMConstUDiv(te1, te2) }"}, {"sha": "ae510ae6d114f15e0a7d716754e1ec4bb830b450", "filename": "src/librustc/middle/trans/expr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ee26c7c433dbb8d41a2b65dbc89eb84acfc2d311/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee26c7c433dbb8d41a2b65dbc89eb84acfc2d311/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Ftrans%2Fexpr.rs?ref=ee26c7c433dbb8d41a2b65dbc89eb84acfc2d311", "patch": "@@ -1435,7 +1435,7 @@ fn trans_eager_binop(bcx: block,\n         if is_float { FMul(bcx, lhs, rhs) }\n         else { Mul(bcx, lhs, rhs) }\n       }\n-      ast::quot => {\n+      ast::div => {\n         if is_float {\n             FDiv(bcx, lhs, rhs)\n         } else {"}, {"sha": "4280cd4000d818715c4dc0ecfd6977d440267771", "filename": "src/librustc/middle/ty.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ee26c7c433dbb8d41a2b65dbc89eb84acfc2d311/src%2Flibrustc%2Fmiddle%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee26c7c433dbb8d41a2b65dbc89eb84acfc2d311/src%2Flibrustc%2Fmiddle%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fty.rs?ref=ee26c7c433dbb8d41a2b65dbc89eb84acfc2d311", "patch": "@@ -4134,7 +4134,7 @@ pub fn is_binopable(_cx: ctxt, ty: t, op: ast::binop) -> bool {\n           ast::add => opcat_add,\n           ast::subtract => opcat_sub,\n           ast::mul => opcat_mult,\n-          ast::quot => opcat_mult,\n+          ast::div => opcat_mult,\n           ast::rem => opcat_mult,\n           ast::and => opcat_logic,\n           ast::or => opcat_logic,"}, {"sha": "fa9d6318cc9473c76ea62d81a269ac0ca2c20a6e", "filename": "src/libstd/num/bigint.rs", "status": "modified", "additions": 60, "deletions": 63, "changes": 123, "blob_url": "https://github.com/rust-lang/rust/blob/ee26c7c433dbb8d41a2b65dbc89eb84acfc2d311/src%2Flibstd%2Fnum%2Fbigint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee26c7c433dbb8d41a2b65dbc89eb84acfc2d311/src%2Flibstd%2Fnum%2Fbigint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fbigint.rs?ref=ee26c7c433dbb8d41a2b65dbc89eb84acfc2d311", "patch": "@@ -293,18 +293,18 @@ impl Mul<BigUint, BigUint> for BigUint {\n     }\n }\n \n-impl Quot<BigUint, BigUint> for BigUint {\n+impl Div<BigUint, BigUint> for BigUint {\n     #[inline(always)]\n-    fn quot(&self, other: &BigUint) -> BigUint {\n-        let (q, _) = self.quot_rem(other);\n+    fn div(&self, other: &BigUint) -> BigUint {\n+        let (q, _) = self.div_rem(other);\n         return q;\n     }\n }\n \n impl Rem<BigUint, BigUint> for BigUint {\n     #[inline(always)]\n     fn rem(&self, other: &BigUint) -> BigUint {\n-        let (_, r) = self.quot_rem(other);\n+        let (_, r) = self.div_rem(other);\n         return r;\n     }\n }\n@@ -316,19 +316,24 @@ impl Neg<BigUint> for BigUint {\n \n impl Integer for BigUint {\n     #[inline(always)]\n-    fn div(&self, other: &BigUint) -> BigUint {\n-        let (d, _) = self.div_mod(other);\n+    fn div_rem(&self, other: &BigUint) -> (BigUint, BigUint) {\n+        self.div_mod_floor(other)\n+    }\n+\n+    #[inline(always)]\n+    fn div_floor(&self, other: &BigUint) -> BigUint {\n+        let (d, _) = self.div_mod_floor(other);\n         return d;\n     }\n \n     #[inline(always)]\n-    fn modulo(&self, other: &BigUint) -> BigUint {\n-        let (_, m) = self.div_mod(other);\n+    fn mod_floor(&self, other: &BigUint) -> BigUint {\n+        let (_, m) = self.div_mod_floor(other);\n         return m;\n     }\n \n     #[inline(always)]\n-    fn div_mod(&self, other: &BigUint) -> (BigUint, BigUint) {\n+    fn div_mod_floor(&self, other: &BigUint) -> (BigUint, BigUint) {\n         if other.is_zero() { fail!() }\n         if self.is_zero() { return (Zero::zero(), Zero::zero()); }\n         if *other == One::one() { return (copy *self, Zero::zero()); }\n@@ -346,11 +351,11 @@ impl Integer for BigUint {\n             shift += 1;\n         }\n         assert!(shift < BigDigit::bits);\n-        let (d, m) = div_mod_inner(self << shift, other << shift);\n+        let (d, m) = div_mod_floor_inner(self << shift, other << shift);\n         return (d, m >> shift);\n \n         #[inline(always)]\n-        fn div_mod_inner(a: BigUint, b: BigUint) -> (BigUint, BigUint) {\n+        fn div_mod_floor_inner(a: BigUint, b: BigUint) -> (BigUint, BigUint) {\n             let mut m = a;\n             let mut d = Zero::zero::<BigUint>();\n             let mut n = 1;\n@@ -409,11 +414,6 @@ impl Integer for BigUint {\n         }\n     }\n \n-    #[inline(always)]\n-    fn quot_rem(&self, other: &BigUint) -> (BigUint, BigUint) {\n-        self.div_mod(other)\n-    }\n-\n     /**\n      * Calculates the Greatest Common Divisor (GCD) of the number and `other`\n      *\n@@ -485,7 +485,7 @@ impl ToStrRadix for BigUint {\n             let mut result = ~[];\n             let mut m      = n;\n             while m > divider {\n-                let (d, m0) = m.div_mod(&divider);\n+                let (d, m0) = m.div_mod_floor(&divider);\n                 result += [m0.to_uint() as BigDigit];\n                 m = d;\n             }\n@@ -894,18 +894,18 @@ impl Mul<BigInt, BigInt> for BigInt {\n     }\n }\n \n-impl Quot<BigInt, BigInt> for BigInt {\n+impl Div<BigInt, BigInt> for BigInt {\n     #[inline(always)]\n-    fn quot(&self, other: &BigInt) -> BigInt {\n-        let (q, _) = self.quot_rem(other);\n+    fn div(&self, other: &BigInt) -> BigInt {\n+        let (q, _) = self.div_rem(other);\n         return q;\n     }\n }\n \n impl Rem<BigInt, BigInt> for BigInt {\n     #[inline(always)]\n     fn rem(&self, other: &BigInt) -> BigInt {\n-        let (_, r) = self.quot_rem(other);\n+        let (_, r) = self.div_rem(other);\n         return r;\n     }\n }\n@@ -919,21 +919,36 @@ impl Neg<BigInt> for BigInt {\n \n impl Integer for BigInt {\n     #[inline(always)]\n-    fn div(&self, other: &BigInt) -> BigInt {\n-        let (d, _) = self.div_mod(other);\n+    fn div_rem(&self, other: &BigInt) -> (BigInt, BigInt) {\n+        // r.sign == self.sign\n+        let (d_ui, r_ui) = self.data.div_mod_floor(&other.data);\n+        let d = BigInt::from_biguint(Plus, d_ui);\n+        let r = BigInt::from_biguint(Plus, r_ui);\n+        match (self.sign, other.sign) {\n+            (_,    Zero)   => fail!(),\n+            (Plus, Plus)  | (Zero, Plus)  => ( d,  r),\n+            (Plus, Minus) | (Zero, Minus) => (-d,  r),\n+            (Minus, Plus)                 => (-d, -r),\n+            (Minus, Minus)                => ( d, -r)\n+        }\n+    }\n+\n+    #[inline(always)]\n+    fn div_floor(&self, other: &BigInt) -> BigInt {\n+        let (d, _) = self.div_mod_floor(other);\n         return d;\n     }\n \n     #[inline(always)]\n-    fn modulo(&self, other: &BigInt) -> BigInt {\n-        let (_, m) = self.div_mod(other);\n+    fn mod_floor(&self, other: &BigInt) -> BigInt {\n+        let (_, m) = self.div_mod_floor(other);\n         return m;\n     }\n \n     #[inline(always)]\n-    fn div_mod(&self, other: &BigInt) -> (BigInt, BigInt) {\n+    fn div_mod_floor(&self, other: &BigInt) -> (BigInt, BigInt) {\n         // m.sign == other.sign\n-        let (d_ui, m_ui) = self.data.quot_rem(&other.data);\n+        let (d_ui, m_ui) = self.data.div_rem(&other.data);\n         let d = BigInt::from_biguint(Plus, d_ui),\n             m = BigInt::from_biguint(Plus, m_ui);\n         match (self.sign, other.sign) {\n@@ -953,21 +968,6 @@ impl Integer for BigInt {\n         }\n     }\n \n-    #[inline(always)]\n-    fn quot_rem(&self, other: &BigInt) -> (BigInt, BigInt) {\n-        // r.sign == self.sign\n-        let (q_ui, r_ui) = self.data.div_mod(&other.data);\n-        let q = BigInt::from_biguint(Plus, q_ui);\n-        let r = BigInt::from_biguint(Plus, r_ui);\n-        match (self.sign, other.sign) {\n-            (_,    Zero)   => fail!(),\n-            (Plus, Plus)  | (Zero, Plus)  => ( q,  r),\n-            (Plus, Minus) | (Zero, Minus) => (-q,  r),\n-            (Minus, Plus)                 => (-q, -r),\n-            (Minus, Minus)                => ( q, -r)\n-        }\n-    }\n-\n     /**\n      * Calculates the Greatest Common Divisor (GCD) of the number and `other`\n      *\n@@ -1100,8 +1100,6 @@ pub impl BigInt {\n \n #[cfg(test)]\n mod biguint_tests {\n-\n-    use core::*;\n     use core::num::{IntConvertible, Zero, One, FromStrRadix};\n     use core::cmp::{Less, Equal, Greater};\n     use super::{BigUint, BigDigit};\n@@ -1347,7 +1345,7 @@ mod biguint_tests {\n         (&[ 0,  0,  1],     &[ 0,  0,  0,  1], &[0, 0,  0,  0,  0,  1])\n     ];\n \n-    static quot_rem_quadruples: &'static [(&'static [BigDigit],\n+    static div_rem_quadruples: &'static [(&'static [BigDigit],\n                                            &'static [BigDigit],\n                                            &'static [BigDigit],\n                                            &'static [BigDigit])]\n@@ -1371,7 +1369,7 @@ mod biguint_tests {\n             assert!(b * a == c);\n         }\n \n-        for quot_rem_quadruples.each |elm| {\n+        for div_rem_quadruples.each |elm| {\n             let (aVec, bVec, cVec, dVec) = *elm;\n             let a = BigUint::from_slice(aVec);\n             let b = BigUint::from_slice(bVec);\n@@ -1384,29 +1382,29 @@ mod biguint_tests {\n     }\n \n     #[test]\n-    fn test_quot_rem() {\n+    fn test_div_rem() {\n         for mul_triples.each |elm| {\n             let (aVec, bVec, cVec) = *elm;\n             let a = BigUint::from_slice(aVec);\n             let b = BigUint::from_slice(bVec);\n             let c = BigUint::from_slice(cVec);\n \n             if !a.is_zero() {\n-                assert!(c.quot_rem(&a) == (copy b, Zero::zero()));\n+                assert!(c.div_rem(&a) == (copy b, Zero::zero()));\n             }\n             if !b.is_zero() {\n-                assert!(c.quot_rem(&b) == (copy a, Zero::zero()));\n+                assert!(c.div_rem(&b) == (copy a, Zero::zero()));\n             }\n         }\n \n-        for quot_rem_quadruples.each |elm| {\n+        for div_rem_quadruples.each |elm| {\n             let (aVec, bVec, cVec, dVec) = *elm;\n             let a = BigUint::from_slice(aVec);\n             let b = BigUint::from_slice(bVec);\n             let c = BigUint::from_slice(cVec);\n             let d = BigUint::from_slice(dVec);\n \n-            if !b.is_zero() { assert!(a.quot_rem(&b) == (c, d)); }\n+            if !b.is_zero() { assert!(a.div_rem(&b) == (c, d)); }\n         }\n     }\n \n@@ -1558,7 +1556,6 @@ mod biguint_tests {\n #[cfg(test)]\n mod bigint_tests {\n     use super::{BigInt, BigUint, BigDigit, Sign, Minus, Zero, Plus};\n-    use core::*;\n     use core::cmp::{Less, Equal, Greater};\n     use core::num::{IntConvertible, Zero, One, FromStrRadix};\n \n@@ -1750,10 +1747,10 @@ mod bigint_tests {\n         (&[ 0,  0,  1],     &[ 0,  0,  0,  1], &[0, 0,  0,  0,  0,  1])\n     ];\n \n-    static quot_rem_quadruples: &'static [(&'static [BigDigit],\n-                                           &'static [BigDigit],\n-                                           &'static [BigDigit],\n-                                           &'static [BigDigit])]\n+    static div_rem_quadruples: &'static [(&'static [BigDigit],\n+                                          &'static [BigDigit],\n+                                          &'static [BigDigit],\n+                                          &'static [BigDigit])]\n         = &[\n             (&[ 1],        &[ 2], &[],               &[1]),\n             (&[ 1,  1],    &[ 2], &[-1/2+1],         &[1]),\n@@ -1777,7 +1774,7 @@ mod bigint_tests {\n             assert!((-b) * a == -c);\n         }\n \n-        for quot_rem_quadruples.each |elm| {\n+        for div_rem_quadruples.each |elm| {\n             let (aVec, bVec, cVec, dVec) = *elm;\n             let a = BigInt::from_slice(Plus, aVec);\n             let b = BigInt::from_slice(Plus, bVec);\n@@ -1790,9 +1787,9 @@ mod bigint_tests {\n     }\n \n     #[test]\n-    fn test_div_mod() {\n+    fn test_div_mod_floor() {\n         fn check_sub(a: &BigInt, b: &BigInt, ans_d: &BigInt, ans_m: &BigInt) {\n-            let (d, m) = a.div_mod(b);\n+            let (d, m) = a.div_mod_floor(b);\n             if !m.is_zero() {\n                 assert!(m.sign == b.sign);\n             }\n@@ -1826,7 +1823,7 @@ mod bigint_tests {\n             if !b.is_zero() { check(&c, &b, &a, &Zero::zero()); }\n         }\n \n-        for quot_rem_quadruples.each |elm| {\n+        for div_rem_quadruples.each |elm| {\n             let (aVec, bVec, cVec, dVec) = *elm;\n             let a = BigInt::from_slice(Plus, aVec);\n             let b = BigInt::from_slice(Plus, bVec);\n@@ -1841,9 +1838,9 @@ mod bigint_tests {\n \n \n     #[test]\n-    fn test_quot_rem() {\n+    fn test_div_rem() {\n         fn check_sub(a: &BigInt, b: &BigInt, ans_q: &BigInt, ans_r: &BigInt) {\n-            let (q, r) = a.quot_rem(b);\n+            let (q, r) = a.div_rem(b);\n             if !r.is_zero() {\n                 assert!(r.sign == a.sign);\n             }\n@@ -1869,7 +1866,7 @@ mod bigint_tests {\n             if !b.is_zero() { check(&c, &b, &a, &Zero::zero()); }\n         }\n \n-        for quot_rem_quadruples.each |elm| {\n+        for div_rem_quadruples.each |elm| {\n             let (aVec, bVec, cVec, dVec) = *elm;\n             let a = BigInt::from_slice(Plus, aVec);\n             let b = BigInt::from_slice(Plus, bVec);"}, {"sha": "41d2b4a101cd5acb4c4f3087c71494c485a7120d", "filename": "src/libstd/num/complex.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ee26c7c433dbb8d41a2b65dbc89eb84acfc2d311/src%2Flibstd%2Fnum%2Fcomplex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee26c7c433dbb8d41a2b65dbc89eb84acfc2d311/src%2Flibstd%2Fnum%2Fcomplex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Fcomplex.rs?ref=ee26c7c433dbb8d41a2b65dbc89eb84acfc2d311", "patch": "@@ -102,9 +102,9 @@ impl<T: Copy + Num> Mul<Cmplx<T>, Cmplx<T>> for Cmplx<T> {\n \n // (a + i b) / (c + i d) == [(a + i b) * (c - i d)] / (c*c + d*d)\n //   == [(a*c + b*d) / (c*c + d*d)] + i [(b*c - a*d) / (c*c + d*d)]\n-impl<T: Copy + Num> Quot<Cmplx<T>, Cmplx<T>> for Cmplx<T> {\n+impl<T: Copy + Num> Div<Cmplx<T>, Cmplx<T>> for Cmplx<T> {\n     #[inline]\n-    fn quot(&self, other: &Cmplx<T>) -> Cmplx<T> {\n+    fn div(&self, other: &Cmplx<T>) -> Cmplx<T> {\n         let norm_sqr = other.norm_sqr();\n         Cmplx::new((self.re*other.re + self.im*other.im) / norm_sqr,\n                      (self.im*other.re - self.re*other.im) / norm_sqr)\n@@ -275,7 +275,7 @@ mod test {\n             }\n         }\n         #[test]\n-        fn test_quot() {\n+        fn test_div() {\n             assert_eq!(_neg1_1i / _0_1i, _1_1i);\n             for all_consts.each |&c| {\n                 if c != Zero::zero() {"}, {"sha": "9b92b7241b99007839e9049442eeb06a5383110c", "filename": "src/libstd/num/rational.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/ee26c7c433dbb8d41a2b65dbc89eb84acfc2d311/src%2Flibstd%2Fnum%2Frational.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee26c7c433dbb8d41a2b65dbc89eb84acfc2d311/src%2Flibstd%2Fnum%2Frational.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnum%2Frational.rs?ref=ee26c7c433dbb8d41a2b65dbc89eb84acfc2d311", "patch": "@@ -143,9 +143,9 @@ impl<T: Copy + Num + Ord>\n \n // (a/b) / (c/d) = (a*d)/(b*c)\n impl<T: Copy + Num + Ord>\n-    Quot<Ratio<T>,Ratio<T>> for Ratio<T> {\n+    Div<Ratio<T>,Ratio<T>> for Ratio<T> {\n     #[inline]\n-    fn quot(&self, rhs: &Ratio<T>) -> Ratio<T> {\n+    fn div(&self, rhs: &Ratio<T>) -> Ratio<T> {\n         Ratio::new(self.numer * rhs.denom, self.denom * rhs.numer)\n     }\n }\n@@ -395,7 +395,7 @@ mod test {\n         }\n \n         #[test]\n-        fn test_quot() {\n+        fn test_div() {\n             assert_eq!(_1 / _1_2, _2);\n             assert_eq!(_3_2 / _1_2, _1 + _2);\n             assert_eq!(_1 / _neg1_2, _neg1_2 + _neg1_2 + _neg1_2 + _neg1_2);\n@@ -424,7 +424,7 @@ mod test {\n         }\n         #[test]\n         #[should_fail]\n-        fn test_quot_0() {\n+        fn test_div_0() {\n             let _a =  _1 / _0;\n         }\n     }"}, {"sha": "5690502c811fe83b3634cb611b294e316b469f1a", "filename": "src/libsyntax/ast.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ee26c7c433dbb8d41a2b65dbc89eb84acfc2d311/src%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee26c7c433dbb8d41a2b65dbc89eb84acfc2d311/src%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast.rs?ref=ee26c7c433dbb8d41a2b65dbc89eb84acfc2d311", "patch": "@@ -389,7 +389,7 @@ pub enum binop {\n     add,\n     subtract,\n     mul,\n-    quot,\n+    div,\n     rem,\n     and,\n     or,"}, {"sha": "0ffeb684dc051b55f54a2954b6dcd458f673b538", "filename": "src/libsyntax/ast_util.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/ee26c7c433dbb8d41a2b65dbc89eb84acfc2d311/src%2Flibsyntax%2Fast_util.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee26c7c433dbb8d41a2b65dbc89eb84acfc2d311/src%2Flibsyntax%2Fast_util.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fast_util.rs?ref=ee26c7c433dbb8d41a2b65dbc89eb84acfc2d311", "patch": "@@ -73,7 +73,7 @@ pub fn binop_to_str(op: binop) -> ~str {\n       add => return ~\"+\",\n       subtract => return ~\"-\",\n       mul => return ~\"*\",\n-      quot => return ~\"/\",\n+      div => return ~\"/\",\n       rem => return ~\"%\",\n       and => return ~\"&&\",\n       or => return ~\"||\",\n@@ -96,7 +96,7 @@ pub fn binop_to_method_name(op: binop) -> Option<~str> {\n       add => return Some(~\"add\"),\n       subtract => return Some(~\"sub\"),\n       mul => return Some(~\"mul\"),\n-      quot => return Some(~\"quot\"),\n+      div => return Some(~\"div\"),\n       rem => return Some(~\"rem\"),\n       bitxor => return Some(~\"bitxor\"),\n       bitand => return Some(~\"bitand\"),\n@@ -341,7 +341,7 @@ pub fn is_self(d: ast::def) -> bool {\n /// Maps a binary operator to its precedence\n pub fn operator_prec(op: ast::binop) -> uint {\n   match op {\n-      mul | quot | rem   => 12u,\n+      mul | div | rem   => 12u,\n       // 'as' sits between here with 11\n       add | subtract    => 10u,\n       shl | shr         =>  9u,"}, {"sha": "42c6fad64636413741eff826a90ff15b32889cb1", "filename": "src/libsyntax/parse/parser.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/ee26c7c433dbb8d41a2b65dbc89eb84acfc2d311/src%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee26c7c433dbb8d41a2b65dbc89eb84acfc2d311/src%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Fparser.rs?ref=ee26c7c433dbb8d41a2b65dbc89eb84acfc2d311", "patch": "@@ -19,7 +19,7 @@ use ast::{_mod, add, arg, arm, attribute, bind_by_ref, bind_infer};\n use ast::{bind_by_copy, bitand, bitor, bitxor, blk};\n use ast::{blk_check_mode, box};\n use ast::{crate, crate_cfg, decl, decl_item};\n-use ast::{decl_local, default_blk, deref, quot, enum_def};\n+use ast::{decl_local, default_blk, deref, div, enum_def};\n use ast::{expr, expr_, expr_addr_of, expr_match, expr_again};\n use ast::{expr_assign, expr_assign_op, expr_binary, expr_block};\n use ast::{expr_break, expr_call, expr_cast, expr_copy, expr_do_body};\n@@ -1836,7 +1836,7 @@ pub impl Parser {\n                   token::PLUS => aop = add,\n                   token::MINUS => aop = subtract,\n                   token::STAR => aop = mul,\n-                  token::SLASH => aop = quot,\n+                  token::SLASH => aop = div,\n                   token::PERCENT => aop = rem,\n                   token::CARET => aop = bitxor,\n                   token::AND => aop = bitand,"}, {"sha": "9426e9abab3b47fe26b9f11ae6998feca649f631", "filename": "src/libsyntax/parse/token.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ee26c7c433dbb8d41a2b65dbc89eb84acfc2d311/src%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee26c7c433dbb8d41a2b65dbc89eb84acfc2d311/src%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibsyntax%2Fparse%2Ftoken.rs?ref=ee26c7c433dbb8d41a2b65dbc89eb84acfc2d311", "patch": "@@ -371,7 +371,7 @@ impl<'self> to_bytes::IterBytes for StringRef<'self> {\n pub fn token_to_binop(tok: Token) -> Option<ast::binop> {\n   match tok {\n       BINOP(STAR)    => Some(ast::mul),\n-      BINOP(SLASH)   => Some(ast::quot),\n+      BINOP(SLASH)   => Some(ast::div),\n       BINOP(PERCENT) => Some(ast::rem),\n       BINOP(PLUS)    => Some(ast::add),\n       BINOP(MINUS)   => Some(ast::subtract),"}, {"sha": "f92dad961d1344b7b713338b639637ffa6791c3e", "filename": "src/test/compile-fail/eval-enum.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ee26c7c433dbb8d41a2b65dbc89eb84acfc2d311/src%2Ftest%2Fcompile-fail%2Feval-enum.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee26c7c433dbb8d41a2b65dbc89eb84acfc2d311/src%2Ftest%2Fcompile-fail%2Feval-enum.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Feval-enum.rs?ref=ee26c7c433dbb8d41a2b65dbc89eb84acfc2d311", "patch": "@@ -1,5 +1,5 @@\n enum test {\n-    quot_zero = 1/0, //~ERROR expected constant: attempted quotient with a divisor of zero\n+    div_zero = 1/0, //~ERROR expected constant: attempted to divide by zero\n     rem_zero = 1%0  //~ERROR expected constant: attempted remainder with a divisor of zero\n }\n "}, {"sha": "9c996807ad8668e1fdf8e9cc87aac5c174b77da6", "filename": "src/test/run-fail/divide-by-zero.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/ee26c7c433dbb8d41a2b65dbc89eb84acfc2d311/src%2Ftest%2Frun-fail%2Fdivide-by-zero.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ee26c7c433dbb8d41a2b65dbc89eb84acfc2d311/src%2Ftest%2Frun-fail%2Fdivide-by-zero.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-fail%2Fdivide-by-zero.rs?ref=ee26c7c433dbb8d41a2b65dbc89eb84acfc2d311", "patch": "@@ -8,7 +8,7 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-// error-pattern:attempted quotient with a divisor of zero\n+// error-pattern:attempted to divide by zero\n fn main() {\n     let y = 0;\n     let z = 1 / y;"}]}