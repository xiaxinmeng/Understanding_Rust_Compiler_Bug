{"sha": "c1ff089c275592044057841673256ec78d6c400c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmMxZmYwODljMjc1NTkyMDQ0MDU3ODQxNjczMjU2ZWM3OGQ2YzQwMGM=", "commit": {"author": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2014-06-23T23:48:09Z"}, "committer": {"name": "Erick Tryzelaar", "email": "erick.tryzelaar@gmail.com", "date": "2014-06-30T13:57:05Z"}, "message": "std: micro optimize Hash{Map,Set}::{new,with_capacity}", "tree": {"sha": "84a4688429edc41e55500c37e9367f53ab67bb88", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/84a4688429edc41e55500c37e9367f53ab67bb88"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/c1ff089c275592044057841673256ec78d6c400c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/c1ff089c275592044057841673256ec78d6c400c", "html_url": "https://github.com/rust-lang/rust/commit/c1ff089c275592044057841673256ec78d6c400c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/c1ff089c275592044057841673256ec78d6c400c/comments", "author": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "committer": {"login": "erickt", "id": 84711, "node_id": "MDQ6VXNlcjg0NzEx", "avatar_url": "https://avatars.githubusercontent.com/u/84711?v=4", "gravatar_id": "", "url": "https://api.github.com/users/erickt", "html_url": "https://github.com/erickt", "followers_url": "https://api.github.com/users/erickt/followers", "following_url": "https://api.github.com/users/erickt/following{/other_user}", "gists_url": "https://api.github.com/users/erickt/gists{/gist_id}", "starred_url": "https://api.github.com/users/erickt/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/erickt/subscriptions", "organizations_url": "https://api.github.com/users/erickt/orgs", "repos_url": "https://api.github.com/users/erickt/repos", "events_url": "https://api.github.com/users/erickt/events{/privacy}", "received_events_url": "https://api.github.com/users/erickt/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "8284ef63a517690a893ffda1083fb966a76b6fbc", "url": "https://api.github.com/repos/rust-lang/rust/commits/8284ef63a517690a893ffda1083fb966a76b6fbc", "html_url": "https://github.com/rust-lang/rust/commit/8284ef63a517690a893ffda1083fb966a76b6fbc"}], "stats": {"total": 8, "additions": 8, "deletions": 0}, "files": [{"sha": "7c01a0342edc71b30bbcaf89597f1bfc10240b4c", "filename": "src/libstd/collections/hashmap.rs", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/c1ff089c275592044057841673256ec78d6c400c/src%2Flibstd%2Fcollections%2Fhashmap.rs", "raw_url": "https://github.com/rust-lang/rust/raw/c1ff089c275592044057841673256ec78d6c400c/src%2Flibstd%2Fcollections%2Fhashmap.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fcollections%2Fhashmap.rs?ref=c1ff089c275592044057841673256ec78d6c400c", "patch": "@@ -1033,11 +1033,13 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> MutableMap<K, V> for HashMap<K, V, H>\n \n impl<K: Hash + Eq, V> HashMap<K, V, RandomSipHasher> {\n     /// Create an empty HashMap.\n+    #[inline]\n     pub fn new() -> HashMap<K, V, RandomSipHasher> {\n         HashMap::with_capacity(INITIAL_CAPACITY)\n     }\n \n     /// Creates an empty hash map with the given initial capacity.\n+    #[inline]\n     pub fn with_capacity(capacity: uint) -> HashMap<K, V, RandomSipHasher> {\n         let hasher = RandomSipHasher::new();\n         HashMap::with_capacity_and_hasher(capacity, hasher)\n@@ -1048,6 +1050,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// Creates an empty hashmap which will use the given hasher to hash keys.\n     ///\n     /// The creates map has the default initial capacity.\n+    #[inline]\n     pub fn with_hasher(hasher: H) -> HashMap<K, V, H> {\n         HashMap::with_capacity_and_hasher(INITIAL_CAPACITY, hasher)\n     }\n@@ -1059,6 +1062,7 @@ impl<K: Eq + Hash<S>, V, S, H: Hasher<S>> HashMap<K, V, H> {\n     /// is designed to allow HashMaps to be resistant to attacks that\n     /// cause many collisions and very poor performance. Setting it\n     /// manually using this function can expose a DoS attack vector.\n+    #[inline]\n     pub fn with_capacity_and_hasher(capacity: uint, hasher: H) -> HashMap<K, V, H> {\n         let cap = num::next_power_of_two(max(INITIAL_CAPACITY, capacity));\n         HashMap {\n@@ -1526,12 +1530,14 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> MutableSet<T> for HashSet<T, H> {\n \n impl<T: Hash + Eq> HashSet<T, RandomSipHasher> {\n     /// Create an empty HashSet\n+    #[inline]\n     pub fn new() -> HashSet<T, RandomSipHasher> {\n         HashSet::with_capacity(INITIAL_CAPACITY)\n     }\n \n     /// Create an empty HashSet with space for at least `n` elements in\n     /// the hash table.\n+    #[inline]\n     pub fn with_capacity(capacity: uint) -> HashSet<T, RandomSipHasher> {\n         HashSet { map: HashMap::with_capacity(capacity) }\n     }\n@@ -1542,6 +1548,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// keys.\n     ///\n     /// The hash set is also created with the default initial capacity.\n+    #[inline]\n     pub fn with_hasher(hasher: H) -> HashSet<T, H> {\n         HashSet::with_capacity_and_hasher(INITIAL_CAPACITY, hasher)\n     }\n@@ -1553,6 +1560,7 @@ impl<T: Eq + Hash<S>, S, H: Hasher<S>> HashSet<T, H> {\n     /// is designed to allow `HashSet`s to be resistant to attacks that\n     /// cause many collisions and very poor performance. Setting it\n     /// manually using this function can expose a DoS attack vector.\n+    #[inline]\n     pub fn with_capacity_and_hasher(capacity: uint, hasher: H) -> HashSet<T, H> {\n         HashSet { map: HashMap::with_capacity_and_hasher(capacity, hasher) }\n     }"}]}