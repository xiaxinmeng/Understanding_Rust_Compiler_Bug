{"sha": "bca07b5ebb59738ef64cd5891507a06c7002dd26", "node_id": "MDY6Q29tbWl0NzI0NzEyOmJjYTA3YjVlYmI1OTczOGVmNjRjZDU4OTE1MDdhMDZjNzAwMmRkMjY=", "commit": {"author": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-03-18T18:47:40Z"}, "committer": {"name": "Niko Matsakis", "email": "niko@alum.mit.edu", "date": "2016-03-18T20:38:52Z"}, "message": "make suggestion stuff not swallow errors\n\nThe older code would sometimes swallow errors or fail to produce a\nsuggestion. The newer code does not. However, just printing everything\nwould produce a bunch of new and kind of annoying errors, so continue\nto swallow `T: 'a` errors so long as there are other things to show.", "tree": {"sha": "0817bfe3aece0837934813133eba9a8cb43158c7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0817bfe3aece0837934813133eba9a8cb43158c7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/bca07b5ebb59738ef64cd5891507a06c7002dd26", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/bca07b5ebb59738ef64cd5891507a06c7002dd26", "html_url": "https://github.com/rust-lang/rust/commit/bca07b5ebb59738ef64cd5891507a06c7002dd26", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/bca07b5ebb59738ef64cd5891507a06c7002dd26/comments", "author": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "committer": {"login": "nikomatsakis", "id": 155238, "node_id": "MDQ6VXNlcjE1NTIzOA==", "avatar_url": "https://avatars.githubusercontent.com/u/155238?v=4", "gravatar_id": "", "url": "https://api.github.com/users/nikomatsakis", "html_url": "https://github.com/nikomatsakis", "followers_url": "https://api.github.com/users/nikomatsakis/followers", "following_url": "https://api.github.com/users/nikomatsakis/following{/other_user}", "gists_url": "https://api.github.com/users/nikomatsakis/gists{/gist_id}", "starred_url": "https://api.github.com/users/nikomatsakis/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/nikomatsakis/subscriptions", "organizations_url": "https://api.github.com/users/nikomatsakis/orgs", "repos_url": "https://api.github.com/users/nikomatsakis/repos", "events_url": "https://api.github.com/users/nikomatsakis/events{/privacy}", "received_events_url": "https://api.github.com/users/nikomatsakis/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5abacd36f0149a9106d7ee04e97eadba4e523bb4", "url": "https://api.github.com/repos/rust-lang/rust/commits/5abacd36f0149a9106d7ee04e97eadba4e523bb4", "html_url": "https://github.com/rust-lang/rust/commit/5abacd36f0149a9106d7ee04e97eadba4e523bb4"}], "stats": {"total": 244, "additions": 155, "deletions": 89}, "files": [{"sha": "089eae89d0492630c98f42bab5dae0bf10d697d8", "filename": "src/librustc/middle/infer/error_reporting.rs", "status": "modified", "additions": 138, "deletions": 76, "changes": 214, "blob_url": "https://github.com/rust-lang/rust/blob/bca07b5ebb59738ef64cd5891507a06c7002dd26/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca07b5ebb59738ef64cd5891507a06c7002dd26/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Ferror_reporting.rs?ref=bca07b5ebb59738ef64cd5891507a06c7002dd26", "patch": "@@ -68,6 +68,7 @@ use super::region_inference::SubSupConflict;\n use super::region_inference::GenericBoundFailure;\n use super::region_inference::GenericKind;\n use super::region_inference::ProcessedErrors;\n+use super::region_inference::ProcessedErrorOrigin;\n use super::region_inference::SameRegions;\n \n use std::collections::HashSet;\n@@ -232,7 +233,7 @@ pub trait ErrorReporting<'tcx> {\n                             errors: &Vec<RegionResolutionError<'tcx>>);\n \n     fn process_errors(&self, errors: &Vec<RegionResolutionError<'tcx>>)\n-                      -> Vec<RegionResolutionError<'tcx>>;\n+                      -> Option<Vec<RegionResolutionError<'tcx>>>;\n \n     fn report_type_error(&self,\n                          trace: TypeTrace<'tcx>,\n@@ -246,7 +247,8 @@ pub trait ErrorReporting<'tcx> {\n \n     fn report_and_explain_type_error(&self,\n                                      trace: TypeTrace<'tcx>,\n-                                     terr: &TypeError<'tcx>);\n+                                     terr: &TypeError<'tcx>)\n+                                     -> DiagnosticBuilder<'tcx>;\n \n     fn values_str(&self, values: &ValuePairs<'tcx>) -> Option<String>;\n \n@@ -258,7 +260,8 @@ pub trait ErrorReporting<'tcx> {\n     fn report_concrete_failure(&self,\n                                origin: SubregionOrigin<'tcx>,\n                                sub: Region,\n-                               sup: Region);\n+                               sup: Region)\n+                                -> DiagnosticBuilder<'tcx>;\n \n     fn report_generic_bound_failure(&self,\n                                     origin: SubregionOrigin<'tcx>,\n@@ -273,8 +276,7 @@ pub trait ErrorReporting<'tcx> {\n                                sup_region: Region);\n \n     fn report_processed_errors(&self,\n-                               var_origin: &[RegionVariableOrigin],\n-                               trace_origin: &[(TypeTrace<'tcx>, TypeError<'tcx>)],\n+                               origins: &[ProcessedErrorOrigin<'tcx>],\n                                same_regions: &[SameRegions]);\n \n     fn give_suggestion(&self, err: &mut DiagnosticBuilder, same_regions: &[SameRegions]);\n@@ -303,12 +305,19 @@ trait ErrorReportingHelpers<'tcx> {\n impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n     fn report_region_errors(&self,\n                             errors: &Vec<RegionResolutionError<'tcx>>) {\n-        let p_errors = self.process_errors(errors);\n-        let errors = if p_errors.is_empty() { errors } else { &p_errors };\n+        debug!(\"report_region_errors(): {} errors to start\", errors.len());\n+\n+        // try to pre-process the errors, which will group some of them\n+        // together into a `ProcessedErrors` group:\n+        let processed_errors = self.process_errors(errors);\n+        let errors = processed_errors.as_ref().unwrap_or(errors);\n+\n+        debug!(\"report_region_errors: {} errors after preprocessing\", errors.len());\n+\n         for error in errors {\n             match error.clone() {\n                 ConcreteFailure(origin, sub, sup) => {\n-                    self.report_concrete_failure(origin, sub, sup);\n+                    self.report_concrete_failure(origin, sub, sup).emit();\n                 }\n \n                 GenericBoundFailure(kind, param_ty, sub) => {\n@@ -323,13 +332,10 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                                                  sup_origin, sup_r);\n                 }\n \n-                ProcessedErrors(ref var_origins,\n-                                ref trace_origins,\n+                ProcessedErrors(ref origins,\n                                 ref same_regions) => {\n                     if !same_regions.is_empty() {\n-                        self.report_processed_errors(&var_origins[..],\n-                                                     &trace_origins[..],\n-                                                     &same_regions[..]);\n+                        self.report_processed_errors(origins, same_regions);\n                     }\n                 }\n             }\n@@ -341,46 +347,73 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n     // parameters to the user. This is done so that we can have a more\n     // complete view of what lifetimes should be the same.\n     // If the return value is an empty vector, it means that processing\n-    // failed (so the return value of this method should not be used)\n+    // failed (so the return value of this method should not be used).\n+    //\n+    // The method also attempts to weed out messages that seem like\n+    // duplicates that will be unhelpful to the end-user. But\n+    // obviously it never weeds out ALL errors.\n     fn process_errors(&self, errors: &Vec<RegionResolutionError<'tcx>>)\n-                      -> Vec<RegionResolutionError<'tcx>> {\n+                      -> Option<Vec<RegionResolutionError<'tcx>>> {\n         debug!(\"process_errors()\");\n-        let mut var_origins = Vec::new();\n-        let mut trace_origins = Vec::new();\n+        let mut origins = Vec::new();\n+\n+        // we collect up ConcreteFailures and SubSupConflicts that are\n+        // relating free-regions bound on the fn-header and group them\n+        // together into this vector\n         let mut same_regions = Vec::new();\n-        let mut processed_errors = Vec::new();\n+\n+        // here we put errors that we will not be able to process nicely\n+        let mut other_errors = Vec::new();\n+\n+        // we collect up GenericBoundFailures in here.\n+        let mut bound_failures = Vec::new();\n+\n         for error in errors {\n-            match error.clone() {\n-                ConcreteFailure(origin, sub, sup) => {\n+            match *error {\n+                ConcreteFailure(ref origin, sub, sup) => {\n                     debug!(\"processing ConcreteFailure\");\n-                    let trace = match origin {\n-                        infer::Subtype(trace) => Some(trace),\n-                        _ => None,\n-                    };\n                     match free_regions_from_same_fn(self.tcx, sub, sup) {\n-                        Some(ref same_frs) if trace.is_some() => {\n-                            let trace = trace.unwrap();\n-                            let terr = TypeError::RegionsDoesNotOutlive(sup,\n-                                                                        sub);\n-                            trace_origins.push((trace, terr));\n+                        Some(ref same_frs) => {\n+                            origins.push(\n+                                ProcessedErrorOrigin::ConcreteFailure(\n+                                    origin.clone(),\n+                                    sub,\n+                                    sup));\n                             append_to_same_regions(&mut same_regions, same_frs);\n                         }\n-                        _ => processed_errors.push((*error).clone()),\n+                        _ => {\n+                            other_errors.push(error.clone());\n+                        }\n                     }\n                 }\n-                SubSupConflict(var_origin, _, sub_r, _, sup_r) => {\n+                SubSupConflict(ref var_origin, _, sub_r, _, sup_r) => {\n                     debug!(\"processing SubSupConflict sub: {:?} sup: {:?}\", sub_r, sup_r);\n                     match free_regions_from_same_fn(self.tcx, sub_r, sup_r) {\n                         Some(ref same_frs) => {\n-                            var_origins.push(var_origin);\n+                            origins.push(\n+                                ProcessedErrorOrigin::VariableFailure(\n+                                    var_origin.clone()));\n                             append_to_same_regions(&mut same_regions, same_frs);\n                         }\n-                        None => processed_errors.push((*error).clone()),\n+                        None => {\n+                            other_errors.push(error.clone());\n+                        }\n                     }\n                 }\n-                _ => ()  // This shouldn't happen\n+                GenericBoundFailure(ref origin, ref kind, region) => {\n+                    bound_failures.push((origin.clone(), kind.clone(), region));\n+                }\n+                ProcessedErrors(..) => {\n+                    panic!(\"should not encounter a `ProcessedErrors` yet: {:?}\", error)\n+                }\n             }\n         }\n+\n+        // ok, let's pull together the errors, sorted in an order that\n+        // we think will help user the best\n+        let mut processed_errors = vec![];\n+\n+        // first, put the processed errors, if any\n         if !same_regions.is_empty() {\n             let common_scope_id = same_regions[0].scope_id;\n             for sr in &same_regions {\n@@ -390,16 +423,39 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                 if sr.scope_id != common_scope_id {\n                     debug!(\"returning empty result from process_errors because\n                             {} != {}\", sr.scope_id, common_scope_id);\n-                    return vec!();\n+                    return None;\n                 }\n             }\n-            let pe = ProcessedErrors(var_origins, trace_origins, same_regions);\n+            assert!(origins.len() > 0);\n+            let pe = ProcessedErrors(origins, same_regions);\n             debug!(\"errors processed: {:?}\", pe);\n             processed_errors.push(pe);\n         }\n-        return processed_errors;\n \n+        // next, put the other misc errors\n+        processed_errors.extend(other_errors);\n+\n+        // finally, put the `T: 'a` errors, but only if there were no\n+        // other errors. otherwise, these have a very high rate of\n+        // being unhelpful in practice. This is because they are\n+        // basically secondary checks that test the state of the\n+        // region graph after the rest of inference is done, and the\n+        // other kinds of errors indicate that the region constraint\n+        // graph is internally inconsistent, so these test results are\n+        // likely to be meaningless.\n+        if processed_errors.is_empty() {\n+            for (origin, kind, region) in bound_failures {\n+                processed_errors.push(GenericBoundFailure(origin, kind, region));\n+            }\n+        }\n+\n+        // we should always wind up with SOME errors, unless there were no\n+        // errors to start\n+        assert!(if errors.len() > 0 {processed_errors.len() > 0} else {true});\n \n+        return Some(processed_errors);\n+\n+        #[derive(Debug)]\n         struct FreeRegionsFromSameFn {\n             sub_fr: ty::FreeRegion,\n             sup_fr: ty::FreeRegion,\n@@ -459,11 +515,12 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n \n         fn append_to_same_regions(same_regions: &mut Vec<SameRegions>,\n                                   same_frs: &FreeRegionsFromSameFn) {\n+            debug!(\"append_to_same_regions(same_regions={:?}, same_frs={:?})\",\n+                   same_regions, same_frs);\n             let scope_id = same_frs.scope_id;\n             let (sub_fr, sup_fr) = (same_frs.sub_fr, same_frs.sup_fr);\n-            for sr in &mut *same_regions {\n-                if sr.contains(&sup_fr.bound_region)\n-                   && scope_id == sr.scope_id {\n+            for sr in same_regions.iter_mut() {\n+                if sr.contains(&sup_fr.bound_region) && scope_id == sr.scope_id {\n                     sr.push(sub_fr.bound_region);\n                     return\n                 }\n@@ -569,11 +626,12 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n \n     fn report_and_explain_type_error(&self,\n                                      trace: TypeTrace<'tcx>,\n-                                     terr: &TypeError<'tcx>) {\n+                                     terr: &TypeError<'tcx>)\n+                                     -> DiagnosticBuilder<'tcx> {\n         let span = trace.origin.span();\n         let mut err = self.report_type_error(trace, terr);\n         self.tcx.note_and_explain_type_err(&mut err, terr, span);\n-        err.emit();\n+        err\n     }\n \n     /// Returns a string of the form \"expected `{}`, found `{}`\", or None if this is a derived\n@@ -678,11 +736,12 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n     fn report_concrete_failure(&self,\n                                origin: SubregionOrigin<'tcx>,\n                                sub: Region,\n-                               sup: Region) {\n+                               sup: Region)\n+                                -> DiagnosticBuilder<'tcx> {\n         match origin {\n             infer::Subtype(trace) => {\n                 let terr = TypeError::RegionsDoesNotOutlive(sup, sub);\n-                self.report_and_explain_type_error(trace, &terr);\n+                self.report_and_explain_type_error(trace, &terr)\n             }\n             infer::Reborrow(span) => {\n                 let mut err = struct_span_err!(self.tcx.sess, span, E0312,\n@@ -696,7 +755,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     \"...but the borrowed content is only valid for \",\n                     sup,\n                     \"\");\n-                err.emit();\n+                err\n             }\n             infer::ReborrowUpvar(span, ref upvar_id) => {\n                 let mut err = struct_span_err!(self.tcx.sess, span, E0313,\n@@ -712,7 +771,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                              self.tcx.local_var_name_str(upvar_id.var_id)),\n                     sup,\n                     \"\");\n-                err.emit();\n+                err\n             }\n             infer::InfStackClosure(span) => {\n                 let mut err = struct_span_err!(self.tcx.sess, span, E0314,\n@@ -725,7 +784,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     \"...but the closure's stack frame is only valid for \",\n                     sup,\n                     \"\");\n-                err.emit();\n+                err\n             }\n             infer::InvokeClosure(span) => {\n                 let mut err = struct_span_err!(self.tcx.sess, span, E0315,\n@@ -734,7 +793,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     \"the closure is only valid for \",\n                     sup,\n                     \"\");\n-                err.emit();\n+                err\n             }\n             infer::DerefPointer(span) => {\n                 let mut err = struct_span_err!(self.tcx.sess, span, E0473,\n@@ -743,7 +802,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     \"the reference is only valid for \",\n                     sup,\n                     \"\");\n-                err.emit();\n+                err\n             }\n             infer::FreeVariable(span, id) => {\n                 let mut err = struct_span_err!(self.tcx.sess, span, E0474,\n@@ -757,7 +816,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     \"closure is valid for \",\n                     sub,\n                     \"\");\n-                err.emit();\n+                err\n             }\n             infer::IndexSlice(span) => {\n                 let mut err = struct_span_err!(self.tcx.sess, span, E0475,\n@@ -766,7 +825,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     \"the slice is only valid for \",\n                     sup,\n                     \"\");\n-                err.emit();\n+                err\n             }\n             infer::RelateObjectBound(span) => {\n                 let mut err = struct_span_err!(self.tcx.sess, span, E0476,\n@@ -780,7 +839,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     \"source pointer is only valid for \",\n                     sup,\n                     \"\");\n-                err.emit();\n+                err\n             }\n             infer::RelateParamBound(span, ty) => {\n                 let mut err = struct_span_err!(self.tcx.sess, span, E0477,\n@@ -790,7 +849,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                                         \"type must outlive \",\n                                         sub,\n                                         \"\");\n-                err.emit();\n+                err\n             }\n             infer::RelateRegionParamBound(span) => {\n                 let mut err = struct_span_err!(self.tcx.sess, span, E0478,\n@@ -803,7 +862,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     \"but lifetime parameter must outlive \",\n                     sub,\n                     \"\");\n-                err.emit();\n+                err\n             }\n             infer::RelateDefaultParamBound(span, ty) => {\n                 let mut err = struct_span_err!(self.tcx.sess, span, E0479,\n@@ -814,7 +873,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                                         \"type must outlive \",\n                                         sub,\n                                         \"\");\n-                err.emit();\n+                err\n             }\n             infer::CallRcvr(span) => {\n                 let mut err = struct_span_err!(self.tcx.sess, span, E0480,\n@@ -824,7 +883,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     \"the receiver is only valid for \",\n                     sup,\n                     \"\");\n-                err.emit();\n+                err\n             }\n             infer::CallArg(span) => {\n                 let mut err = struct_span_err!(self.tcx.sess, span, E0481,\n@@ -834,7 +893,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     \"the function argument is only valid for \",\n                     sup,\n                     \"\");\n-                err.emit();\n+                err\n             }\n             infer::CallReturn(span) => {\n                 let mut err = struct_span_err!(self.tcx.sess, span, E0482,\n@@ -844,7 +903,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     \"the return value is only valid for \",\n                     sup,\n                     \"\");\n-                err.emit();\n+                err\n             }\n             infer::Operand(span) => {\n                 let mut err = struct_span_err!(self.tcx.sess, span, E0483,\n@@ -854,7 +913,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     \"the operand is only valid for \",\n                     sup,\n                     \"\");\n-                err.emit();\n+                err\n             }\n             infer::AddrOf(span) => {\n                 let mut err = struct_span_err!(self.tcx.sess, span, E0484,\n@@ -863,7 +922,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     \"the borrow is only valid for \",\n                     sup,\n                     \"\");\n-                err.emit();\n+                err\n             }\n             infer::AutoBorrow(span) => {\n                 let mut err = struct_span_err!(self.tcx.sess, span, E0485,\n@@ -873,7 +932,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     \"the automatic borrow is only valid for \",\n                     sup,\n                     \"\");\n-                err.emit();\n+                err\n             }\n             infer::ExprTypeIsNotInScope(t, span) => {\n                 let mut err = struct_span_err!(self.tcx.sess, span, E0486,\n@@ -884,7 +943,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     \"type is only valid for \",\n                     sup,\n                     \"\");\n-                err.emit();\n+                err\n             }\n             infer::SafeDestructor(span) => {\n                 let mut err = struct_span_err!(self.tcx.sess, span, E0487,\n@@ -899,7 +958,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     \"subregion: \",\n                     sub,\n                     \"\");\n-                err.emit();\n+                err\n             }\n             infer::BindingTypeIsNotValidAtDecl(span) => {\n                 let mut err = struct_span_err!(self.tcx.sess, span, E0488,\n@@ -908,7 +967,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     \"the variable is only valid for \",\n                     sup,\n                     \"\");\n-                err.emit();\n+                err\n             }\n             infer::ParameterInScope(_, span) => {\n                 let mut err = struct_span_err!(self.tcx.sess, span, E0489,\n@@ -917,15 +976,15 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     \"the parameter is only valid for \",\n                     sub,\n                     \"\");\n-                err.emit();\n+                err\n             }\n             infer::DataBorrowed(ty, span) => {\n                 let mut err = struct_span_err!(self.tcx.sess, span, E0490,\n                           \"a value of type `{}` is borrowed for too long\",\n                           self.ty_to_string(ty));\n                 self.tcx.note_and_explain_region(&mut err, \"the type is valid for \", sub, \"\");\n                 self.tcx.note_and_explain_region(&mut err, \"but the borrow lasts for \", sup, \"\");\n-                err.emit();\n+                err\n             }\n             infer::ReferenceOutlivesReferent(ty, span) => {\n                 let mut err = struct_span_err!(self.tcx.sess, span, E0491,\n@@ -940,7 +999,7 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n                     \"but the referenced data is only valid for \",\n                     sup,\n                     \"\");\n-                err.emit();\n+                err\n             }\n         }\n     }\n@@ -970,19 +1029,22 @@ impl<'a, 'tcx> ErrorReporting<'tcx> for InferCtxt<'a, 'tcx> {\n     }\n \n     fn report_processed_errors(&self,\n-                               var_origins: &[RegionVariableOrigin],\n-                               trace_origins: &[(TypeTrace<'tcx>, TypeError<'tcx>)],\n+                               origins: &[ProcessedErrorOrigin<'tcx>],\n                                same_regions: &[SameRegions]) {\n-        for (i, vo) in var_origins.iter().enumerate() {\n-            let mut err = self.report_inference_failure(vo.clone());\n-            if i == var_origins.len() - 1 {\n+        for (i, origin) in origins.iter().enumerate() {\n+            let mut err = match *origin {\n+                ProcessedErrorOrigin::VariableFailure(ref var_origin) =>\n+                    self.report_inference_failure(var_origin.clone()),\n+                ProcessedErrorOrigin::ConcreteFailure(ref sr_origin, sub, sup) =>\n+                    self.report_concrete_failure(sr_origin.clone(), sub, sup),\n+            };\n+\n+            // attach the suggestion to the last such error\n+            if i == origins.len() - 1 {\n                 self.give_suggestion(&mut err, same_regions);\n             }\n-            err.emit();\n-        }\n \n-        for &(ref trace, ref terr) in trace_origins {\n-            self.report_and_explain_type_error(trace.clone(), terr);\n+            err.emit();\n         }\n     }\n "}, {"sha": "290d9afa44981e35318588b3949538c18fcfc499", "filename": "src/librustc/middle/infer/mod.rs", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/bca07b5ebb59738ef64cd5891507a06c7002dd26/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca07b5ebb59738ef64cd5891507a06c7002dd26/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fmod.rs?ref=bca07b5ebb59738ef64cd5891507a06c7002dd26", "patch": "@@ -407,7 +407,7 @@ pub fn common_supertype<'a, 'tcx>(cx: &InferCtxt<'a, 'tcx>,\n     match result {\n         Ok(t) => t,\n         Err(ref err) => {\n-            cx.report_and_explain_type_error(trace, err);\n+            cx.report_and_explain_type_error(trace, err).emit();\n             cx.tcx.types.err\n         }\n     }\n@@ -1396,7 +1396,7 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n                 found: actual\n             })\n         };\n-        self.report_and_explain_type_error(trace, &err);\n+        self.report_and_explain_type_error(trace, &err).emit();\n     }\n \n     pub fn report_conflicting_default_types(&self,\n@@ -1411,11 +1411,13 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n             })\n         };\n \n-        self.report_and_explain_type_error(trace,\n+        self.report_and_explain_type_error(\n+            trace,\n             &TypeError::TyParamDefaultMismatch(ExpectedFound {\n                 expected: expected,\n                 found: actual\n-        }));\n+            }))\n+            .emit();\n     }\n \n     pub fn replace_late_bound_regions_with_fresh_var<T>("}, {"sha": "7bba495e46779eab5a53f0e31fa161971abcabf2", "filename": "src/librustc/middle/infer/region_inference/mod.rs", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/bca07b5ebb59738ef64cd5891507a06c7002dd26/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca07b5ebb59738ef64cd5891507a06c7002dd26/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Finfer%2Fregion_inference%2Fmod.rs?ref=bca07b5ebb59738ef64cd5891507a06c7002dd26", "patch": "@@ -17,7 +17,7 @@ pub use self::CombineMapType::*;\n pub use self::RegionResolutionError::*;\n pub use self::VarValue::*;\n \n-use super::{RegionVariableOrigin, SubregionOrigin, TypeTrace, MiscVariable};\n+use super::{RegionVariableOrigin, SubregionOrigin, MiscVariable};\n use super::unify_key;\n \n use rustc_data_structures::graph::{self, Direction, NodeIndex};\n@@ -27,7 +27,6 @@ use middle::ty::{self, Ty, TyCtxt};\n use middle::ty::{BoundRegion, Region, RegionVid};\n use middle::ty::{ReEmpty, ReStatic, ReFree, ReEarlyBound};\n use middle::ty::{ReLateBound, ReScope, ReVar, ReSkolemized, BrFresh};\n-use middle::ty::error::TypeError;\n use util::common::indenter;\n use util::nodemap::{FnvHashMap, FnvHashSet};\n \n@@ -152,11 +151,16 @@ pub enum RegionResolutionError<'tcx> {\n     /// more specific errors message by suggesting to the user where they\n     /// should put a lifetime. In those cases we process and put those errors\n     /// into `ProcessedErrors` before we do any reporting.\n-    ProcessedErrors(Vec<RegionVariableOrigin>,\n-                    Vec<(TypeTrace<'tcx>, TypeError<'tcx>)>,\n+    ProcessedErrors(Vec<ProcessedErrorOrigin<'tcx>>,\n                     Vec<SameRegions>),\n }\n \n+#[derive(Clone, Debug)]\n+pub enum ProcessedErrorOrigin<'tcx> {\n+    ConcreteFailure(SubregionOrigin<'tcx>, Region, Region),\n+    VariableFailure(RegionVariableOrigin),\n+}\n+\n /// SameRegions is used to group regions that we think are the same and would\n /// like to indicate so to the user.\n /// For example, the following function"}, {"sha": "b552d7678d563701f3282fa6ef290365ecc67fc4", "filename": "src/test/compile-fail/issue-13058.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/bca07b5ebb59738ef64cd5891507a06c7002dd26/src%2Ftest%2Fcompile-fail%2Fissue-13058.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca07b5ebb59738ef64cd5891507a06c7002dd26/src%2Ftest%2Fcompile-fail%2Fissue-13058.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fissue-13058.rs?ref=bca07b5ebb59738ef64cd5891507a06c7002dd26", "patch": "@@ -36,9 +36,5 @@ fn check<'r, I: Iterator<Item=usize>, T: Itble<'r, usize, I>>(cont: &T) -> bool\n fn main() {\n     check((3, 5));\n //~^ ERROR mismatched types\n-//~| expected `&_`\n-//~| found `(_, _)`\n-//~| expected &-ptr\n-//~| found tuple\n //~| HELP run `rustc --explain E0308` to see a detailed explanation\n }"}, {"sha": "e0ea1ed74340783001fd75971980b68550f2e7bd", "filename": "src/test/compile-fail/lifetime-inference-give-expl-lifetime-param-3.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bca07b5ebb59738ef64cd5891507a06c7002dd26/src%2Ftest%2Fcompile-fail%2Flifetime-inference-give-expl-lifetime-param-3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca07b5ebb59738ef64cd5891507a06c7002dd26/src%2Ftest%2Fcompile-fail%2Flifetime-inference-give-expl-lifetime-param-3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flifetime-inference-give-expl-lifetime-param-3.rs?ref=bca07b5ebb59738ef64cd5891507a06c7002dd26", "patch": "@@ -22,7 +22,7 @@ fn bar1<'a>(x: &Bar) -> (&'a i32, &'a i32, &'a i32) {\n }\n \n fn bar2<'a, 'b, 'c>(x: &Bar<'a, 'b, 'c>) -> (&'a i32, &'a i32, &'a i32) {\n-    //~^ HELP: consider using an explicit lifetime parameter as shown: fn bar2<'a, 'b, 'c>(x: &'a Bar<'a, 'b, 'c>) -> (&'a i32, &'a i32, &'a i32)\n+    //~^ HELP: consider using an explicit lifetime parameter as shown: fn bar2<'a, 'c>(x: &'a Bar<'a, 'a, 'c>) -> (&'a i32, &'a i32, &'a i32)\n     (x.bar, &x.baz, &x.baz)\n     //~^ ERROR E0312\n     //~| ERROR cannot infer"}, {"sha": "73d89beb2202f84369e048588a346945b6cd2179", "filename": "src/test/compile-fail/lifetime-inference-give-expl-lifetime-param.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/bca07b5ebb59738ef64cd5891507a06c7002dd26/src%2Ftest%2Fcompile-fail%2Flifetime-inference-give-expl-lifetime-param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/bca07b5ebb59738ef64cd5891507a06c7002dd26/src%2Ftest%2Fcompile-fail%2Flifetime-inference-give-expl-lifetime-param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Flifetime-inference-give-expl-lifetime-param.rs?ref=bca07b5ebb59738ef64cd5891507a06c7002dd26", "patch": "@@ -39,6 +39,7 @@ struct Cat<'x, T> { cat: &'x isize, t: T }\n struct Dog<'y> { dog: &'y isize }\n \n fn cat2<'x, 'y>(x: Cat<'x, Dog<'y>>) -> &'x isize {\n+    //~^ HELP consider using an explicit lifetime parameter as shown: fn cat2<'x>(x: Cat<'x, Dog<'x>>) -> &'x isize\n     x.t.dog //~ ERROR E0312\n }\n \n@@ -48,6 +49,7 @@ struct Baz<'x> {\n \n impl<'a> Baz<'a> {\n     fn baz2<'b>(&self, x: &isize) -> (&'b isize, &'b isize) {\n+        //~^ HELP consider using an explicit lifetime parameter as shown: fn baz2<'b>(&self, x: &'b isize) -> (&'a isize, &'a isize)\n         (self.bar, x) //~ ERROR E0312\n         //~^ ERROR E0312\n     }"}]}