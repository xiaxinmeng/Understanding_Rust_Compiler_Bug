{"sha": "1402cd101bfd2b0235900dfd07593572f34f4844", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE0MDJjZDEwMWJmZDJiMDIzNTkwMGRmZDA3NTkzNTcyZjM0ZjQ4NDQ=", "commit": {"author": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2011-06-02T01:10:10Z"}, "committer": {"name": "Tim Chevalier", "email": "chevalier@alum.wellesley.edu", "date": "2011-06-02T01:14:48Z"}, "message": "Redo typestate-related data structures to support predicate constraints. No actual support yet, just infrastructure.", "tree": {"sha": "4e8f1cd6440a8d719b7c9800dcc6564450cf616d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/4e8f1cd6440a8d719b7c9800dcc6564450cf616d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1402cd101bfd2b0235900dfd07593572f34f4844", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1402cd101bfd2b0235900dfd07593572f34f4844", "html_url": "https://github.com/rust-lang/rust/commit/1402cd101bfd2b0235900dfd07593572f34f4844", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1402cd101bfd2b0235900dfd07593572f34f4844/comments", "author": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "committer": {"login": "catamorphism", "id": 427212, "node_id": "MDQ6VXNlcjQyNzIxMg==", "avatar_url": "https://avatars.githubusercontent.com/u/427212?v=4", "gravatar_id": "", "url": "https://api.github.com/users/catamorphism", "html_url": "https://github.com/catamorphism", "followers_url": "https://api.github.com/users/catamorphism/followers", "following_url": "https://api.github.com/users/catamorphism/following{/other_user}", "gists_url": "https://api.github.com/users/catamorphism/gists{/gist_id}", "starred_url": "https://api.github.com/users/catamorphism/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/catamorphism/subscriptions", "organizations_url": "https://api.github.com/users/catamorphism/orgs", "repos_url": "https://api.github.com/users/catamorphism/repos", "events_url": "https://api.github.com/users/catamorphism/events{/privacy}", "received_events_url": "https://api.github.com/users/catamorphism/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "af4554aadf0bb1a883d574c7968eeb4b992bdc1e", "url": "https://api.github.com/repos/rust-lang/rust/commits/af4554aadf0bb1a883d574c7968eeb4b992bdc1e", "html_url": "https://github.com/rust-lang/rust/commit/af4554aadf0bb1a883d574c7968eeb4b992bdc1e"}], "stats": {"total": 620, "additions": 473, "deletions": 147}, "files": [{"sha": "e49262e05afe214fb1fd86a2da064c4874ca9f7d", "filename": "src/comp/middle/tstate/annotate.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/1402cd101bfd2b0235900dfd07593572f34f4844/src%2Fcomp%2Fmiddle%2Ftstate%2Fannotate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1402cd101bfd2b0235900dfd07593572f34f4844/src%2Fcomp%2Fmiddle%2Ftstate%2Fannotate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fannotate.rs?ref=1402cd101bfd2b0235900dfd07593572f34f4844", "patch": "@@ -51,7 +51,7 @@ import util::common::log_stmt;\n \n import aux::fn_info;\n import aux::fn_info_map;\n-import aux::num_locals;\n+import aux::num_constraints;\n import aux::get_fn_info;\n import aux::crate_ctxt;\n import aux::add_node;\n@@ -109,19 +109,19 @@ fn init_vecs(&crate_ctxt ccx, @vec[uint] node_ids, uint len) -> () {\n     }\n }\n \n-fn visit_fn(&crate_ctxt ccx, uint num_locals, &_fn f,\n+fn visit_fn(&crate_ctxt ccx, uint num_constraints, &_fn f,\n             &span sp, &ident i, &def_id d, &ann a) -> () {\n     let vec[uint] node_ids_ = [];\n     let @vec[uint] node_ids = @node_ids_;\n     node_ids_in_fn(f, sp, i, d, a, node_ids);\n-    init_vecs(ccx, node_ids, num_locals);\n+    init_vecs(ccx, node_ids, num_constraints);\n }\n \n fn annotate_in_fn(&crate_ctxt ccx, &_fn f, &span sp, &ident i,\n                   &def_id f_id, &ann a)\n     -> () {\n     auto f_info = get_fn_info(ccx, f_id);\n-    visit_fn(ccx, num_locals(f_info), f, sp, i, f_id, a);\n+    visit_fn(ccx, num_constraints(f_info), f, sp, i, f_id, a);\n }\n \n fn annotate_crate(&crate_ctxt ccx, &crate crate) -> () {"}, {"sha": "4aa178d6c5c127723635f360ac1030fab57461bd", "filename": "src/comp/middle/tstate/auxiliary.rs", "status": "modified", "additions": 164, "deletions": 37, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/1402cd101bfd2b0235900dfd07593572f34f4844/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1402cd101bfd2b0235900dfd07593572f34f4844/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fauxiliary.rs?ref=1402cd101bfd2b0235900dfd07593572f34f4844", "patch": "@@ -8,35 +8,21 @@ import std::option::none;\n import std::option::some;\n import std::option::maybe;\n \n-import front::ast;\n-import front::ast::def;\n-import front::ast::def_fn;\n-import front::ast::_fn;\n-import front::ast::def_obj_field;\n-import front::ast::def_id;\n-import front::ast::expr_path;\n-import front::ast::ident;\n-import front::ast::controlflow;\n-import front::ast::ann;\n-import front::ast::stmt;\n-import front::ast::expr;\n-import front::ast::block;\n-import front::ast::block_;\n-import front::ast::stmt_decl;\n-import front::ast::stmt_expr;\n-import front::ast::stmt_crate_directive;\n-import front::ast::return;\n-import front::ast::expr_field;\n+import front::ast::*;\n \n import middle::ty::expr_ann;\n \n import util::common;\n import util::common::span;\n+import util::common::respan;\n import util::common::log_block;\n import util::common::new_def_hash;\n import util::common::new_uint_hash;\n import util::common::log_expr_err;\n import util::common::uistr;\n+import util::common::lit_eq;\n+import pretty::pprust::path_to_str;\n+import pretty::pprust::lit_to_str;\n \n import tstate::ann::pre_and_post;\n import tstate::ann::pre_and_post_state;\n@@ -63,14 +49,51 @@ fn def_id_to_str(def_id d) -> str {\n    ret (istr(d._0) + \",\" + istr(d._1));\n }\n \n+fn comma_str(vec[@constr_arg] args) -> str {\n+    auto res = \"\";\n+    auto comma = false;\n+    for (@constr_arg a in args) {\n+        if (comma) {\n+            res += \", \";\n+        }\n+        else {\n+            comma = true;\n+        }\n+        alt (a.node) {\n+            case (carg_base) {\n+                res += \"*\";\n+            }\n+            case (carg_ident(?i)) {\n+                res += i;\n+            }\n+            case (carg_lit(?l)) {\n+                res += lit_to_str(l);\n+            }\n+        }\n+    }\n+    ret res;\n+}\n+\n+fn constraint_to_str(ty::ctxt tcx, constr c) -> str {\n+    alt (c.node) {\n+        case (ninit(?i)) {\n+            ret \"init(\" + i + \" [\" + tcx.sess.span_str(c.span) + \"])\";\n+        }\n+        case (npred(?p, ?args)) {\n+            ret path_to_str(p) + \"(\" + comma_str(args) + \")\"\n+                + \"[\" + tcx.sess.span_str(c.span) + \"]\";\n+        }\n+    }\n+}\n+\n fn bitv_to_str(fn_ctxt fcx, bitv::t v) -> str {\n   auto s = \"\";\n   auto comma = false;\n \n-  for each (@tup(def_id, var_info) p in fcx.enclosing.vars.items()) {\n-      if (bitv::get(v, p._1.bit_num)) {\n+  for (norm_constraint p in constraints(fcx)) {\n+      if (bitv::get(v, p.bit_num)) {\n           s += (if (comma) { \", \" } else { comma = true; \"\" })\n-               + p._1.name + \" [\" + fcx.ccx.tcx.sess.span_str(p._1.sp) + \"]\";\n+              + aux::constraint_to_str(fcx.ccx.tcx, p.c);\n       }\n   }\n   ret s;\n@@ -84,19 +107,19 @@ fn first_difference_string(&fn_ctxt fcx, &bitv::t expected,\n                            &bitv::t actual) -> str {\n     let str s = \"\";\n     auto done = false;\n-    for each (@tup(def_id, var_info) p in fcx.enclosing.vars.items()) {\n+    for (norm_constraint c in constraints(fcx)) {\n         if (!done) {\n-            if (bitv::get(expected, p._1.bit_num) &&\n-                !bitv::get(actual, p._1.bit_num)) {\n+            if (bitv::get(expected, c.bit_num) &&\n+                !bitv::get(actual, c.bit_num)) {\n                 \n             /*\n+              FIXME\n               for fun, try either:\n               * \"ret s\" after the assignment to s\n               or\n               * using break here\n               */\n-            s = (p._1.name + \" [\"\n-                 + fcx.ccx.tcx.sess.span_str(p._1.sp) + \"]\");\n+                s = constraint_to_str(fcx.ccx.tcx, c.c);\n             \n             done = true;\n             }\n@@ -183,14 +206,35 @@ fn print_idents(vec[ident] idents) -> () {\n /* data structures */\n \n /**********************************************************************/\n-/* mapping from variable name (def_id is assumed to be for a local\n-   variable in a given function) to bit number \n-   (also remembers the ident and span for error-logging purposes) */\n-type var_info     = rec(uint bit_num,\n-                        ident name,\n-                        span sp);\n-type fn_info      = rec(@std::map::hashmap[def_id, var_info] vars,\n-                        controlflow cf);\n+/* mapping from def_id to bit number and other data\n+   (ident/path/span are there for error-logging purposes) */\n+\n+type pred_desc_ = rec(vec[@constr_arg] args,\n+                      uint bit_num);\n+type pred_desc = spanned[pred_desc_];\n+tag constraint {\n+    cinit(uint, span, ident);\n+    cpred(path, vec[pred_desc]);\n+}\n+tag constr_ {\n+    ninit(ident);\n+    npred(path, vec[@constr_arg]);\n+}\n+type constr = spanned[constr_];\n+type norm_constraint = rec(uint bit_num,\n+                           constr c);\n+/* \"constraint occurrence\" to disambiguate\n+   between constraints. either \"this is an\n+   init constraint\", or the list of args for\n+   a pred. */\n+tag constr_occ {\n+    occ_init;\n+    occ_args(vec[@constr_arg]);\n+}\n+   \n+type constr_map = @std::map::hashmap[def_id, constraint];\n+\n+type fn_info  = rec(constr_map constrs, uint num_constraints, controlflow cf);\n \n /* mapping from node ID to typestate annotation */\n type node_ann_table = @vec[ts_ann];\n@@ -418,8 +462,8 @@ fn fixed_point_states(&fn_ctxt fcx,\n   }\n }\n \n-fn num_locals(fn_info m) -> uint {\n-  ret m.vars.size();\n+fn num_constraints(fn_info m) -> uint {\n+    ret m.num_constraints;\n }\n \n fn new_crate_ctxt(ty::ctxt cx) -> crate_ctxt {\n@@ -463,6 +507,89 @@ fn ann_to_def(&crate_ctxt ccx, &ann a) -> option::t[def] {\n     ret ccx.tcx.def_map.find(a.id);\n }\n \n+fn norm_a_constraint(&constraint c) -> vec[norm_constraint] {\n+    alt (c) {\n+        case (cinit(?n, ?sp, ?i)) {\n+            ret [rec(bit_num=n, c=respan(sp, ninit(i)))];\n+        }\n+        case (cpred(?p, ?descs)) {\n+            let vec[norm_constraint] res = [];\n+            for (pred_desc pd in descs) {\n+                vec::push(res, rec(bit_num=pd.node.bit_num,\n+                  c=respan(pd.span, npred(p, pd.node.args))));\n+            }\n+            ret res;\n+        }\n+    }\n+}\n+\n+// Tried to write this as an iterator, but I got a\n+// non-exhaustive match in trans.\n+fn constraints(&fn_ctxt fcx) -> vec[norm_constraint] {\n+    let vec[norm_constraint] res = [];\n+    for each (@tup(def_id, constraint) p in\n+              fcx.enclosing.constrs.items()) {\n+        res += norm_a_constraint(p._1);\n+    }\n+    ret res;\n+}\n+\n+fn arg_eq(@constr_arg a, @constr_arg b) -> bool {\n+    alt (a.node) {\n+        case (carg_base) {\n+            alt (b.node) {\n+                case (carg_base) {\n+                    ret true;\n+                }\n+                case (_) {\n+                    ret false;\n+                }\n+            }\n+        }\n+        case (carg_ident(?s)) {\n+            alt (b.node) {\n+                case (carg_ident(?t)) {\n+                    ret (s == t);\n+                }\n+                case (_) {\n+                    ret false;\n+                }\n+            }\n+        }\n+        case (carg_lit(?l)) {\n+            alt (b.node) {\n+                case (carg_lit(?m)) {\n+                    ret lit_eq(l, m);\n+                }\n+                case (_) {\n+                    ret false;\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+fn args_eq(vec[@constr_arg] a, vec[@constr_arg] b) -> bool {\n+    let uint i = 0u;\n+    for (@constr_arg arg in a) {\n+        if (!arg_eq(arg, b.(i))) {\n+            ret false;\n+        }\n+        i += 1u;\n+    }\n+    ret true;\n+}\n+\n+fn match_args(&fn_ctxt fcx, vec[pred_desc] occs,\n+              vec[@constr_arg] occ) -> uint {\n+    for (pred_desc pd in occs) {\n+        if (args_eq(pd.node.args, occ)) {\n+            ret pd.node.bit_num;\n+        }\n+    }\n+    fcx.ccx.tcx.sess.bug(\"match_args: no match for occurring args\");  \n+}\n+\n //\n // Local Variables:\n // mode: rust"}, {"sha": "0eb924eeaff84cb18e8e0715d7d1344552a85ce0", "filename": "src/comp/middle/tstate/bitvectors.rs", "status": "modified", "additions": 61, "deletions": 28, "changes": 89, "blob_url": "https://github.com/rust-lang/rust/blob/1402cd101bfd2b0235900dfd07593572f34f4844/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1402cd101bfd2b0235900dfd07593572f34f4844/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fbitvectors.rs?ref=1402cd101bfd2b0235900dfd07593572f34f4844", "patch": "@@ -3,15 +3,19 @@ import std::vec;\n import std::vec::len;\n import std::vec::slice;\n \n-import front::ast;\n-import front::ast::def_id;\n-import front::ast::expr;\n-import front::ast::ann;\n+import front::ast::*;\n \n import aux::fn_ctxt;\n import aux::fn_info;\n import aux::log_bitv;\n-import aux::num_locals;\n+import aux::num_constraints;\n+import aux::constr_occ;\n+import aux::occ_init;\n+import aux::occ_args;\n+import aux::cinit;\n+import aux::cpred;\n+import aux::pred_desc;\n+import aux::match_args;\n \n import tstate::aux::ann_to_ts_ann;\n import tstate::ann::pre_and_post;\n@@ -30,14 +34,38 @@ import tstate::ann::clone;\n import tstate::ann::set_in_postcond;\n import tstate::ann::set_in_poststate;\n import tstate::ann::clear_in_poststate;\n-             \n-fn bit_num(def_id v, fn_info m) -> uint {\n-  assert (m.vars.contains_key(v));\n-  ret m.vars.get(v).bit_num;\n+           \n+fn bit_num(&fn_ctxt fcx, &def_id v, &constr_occ o) -> uint {\n+    assert (fcx.enclosing.constrs.contains_key(v));\n+    auto res = fcx.enclosing.constrs.get(v);\n+    alt (o) {\n+        case (occ_init) {\n+            alt (res) {\n+                case (cinit(?n,_,_)) {\n+                    ret n;\n+                }\n+                case (_) {\n+                    fcx.ccx.tcx.sess.bug(\"bit_num: asked for init constraint,\"\n+                                         + \" found a pred constraint\");\n+                }\n+            }\n+        }\n+        case (occ_args(?args)) {\n+            alt (res) {\n+                case (cpred(_, ?descs)) {\n+                    ret match_args(fcx, descs, args);\n+                }\n+                case (_) {\n+                    fcx.ccx.tcx.sess.bug(\"bit_num: asked for pred constraint,\"\n+                                         + \" found an init constraint\");\n+                }\n+            }\n+        }\n+    }\n }\n \n-fn promises(&poststate p, def_id v, fn_info m) -> bool {\n-    ret bitv::get(p, bit_num(v, m));\n+fn promises(&fn_ctxt fcx, &poststate p, &def_id v, &constr_occ o) -> bool {\n+    ret bitv::get(p, bit_num(fcx, v, o));\n }\n \n // Given a list of pres and posts for exprs e0 ... en,\n@@ -46,7 +74,7 @@ fn promises(&poststate p, def_id v, fn_info m) -> bool {\n // precondition shouldn't include x.\n fn seq_preconds(fn_ctxt fcx, vec[pre_and_post] pps) -> precond {\n   let uint sz = len[pre_and_post](pps);\n-  let uint num_vars = num_locals(fcx.enclosing);\n+  let uint num_vars = num_constraints(fcx.enclosing);\n \n   if (sz >= 1u) {\n     auto first = pps.(0);\n@@ -115,33 +143,38 @@ fn intersect_postconds(&vec[postcond] pcs) -> postcond {\n   ret intersect_postconds_go(bitv::clone(pcs.(0)), pcs);\n }\n \n-fn gen(&fn_ctxt fcx, &ann a, def_id id) -> bool {\n+fn gen(&fn_ctxt fcx, &ann a, &def_id id, &constr_occ o) -> bool {\n   log \"gen\";\n-  assert (fcx.enclosing.vars.contains_key(id));\n-  let uint i = (fcx.enclosing.vars.get(id)).bit_num;\n-  ret set_in_postcond(i, (ann_to_ts_ann(fcx.ccx, a)).conditions);\n+  ret set_in_postcond(bit_num(fcx, id, o),\n+                      (ann_to_ts_ann(fcx.ccx, a)).conditions);\n }\n \n-fn declare_var(&fn_info enclosing, def_id id, prestate pre)\n+fn declare_var(&fn_ctxt fcx, def_id id, prestate pre)\n    -> prestate {\n-    assert (enclosing.vars.contains_key(id));\n-    let uint i = (enclosing.vars.get(id)).bit_num;\n     auto res = clone(pre);\n-    relax_prestate(i, res);\n+    relax_prestate(bit_num(fcx, id, occ_init), res);\n     ret res;\n }\n \n-fn gen_poststate(&fn_ctxt fcx, &ann a, def_id id) -> bool {\n+fn gen_poststate(&fn_ctxt fcx, &ann a, &def_id id, &constr_occ o) -> bool {\n   log \"gen_poststate\";\n-  assert (fcx.enclosing.vars.contains_key(id));\n-  let uint i = (fcx.enclosing.vars.get(id)).bit_num;\n-  ret set_in_poststate(i, (ann_to_ts_ann(fcx.ccx, a)).states);\n+  ret set_in_poststate(bit_num(fcx, id, o),\n+                       (ann_to_ts_ann(fcx.ccx, a)).states);\n }\n \n-fn kill_poststate(&fn_ctxt fcx, &ann a, def_id id) -> bool {\n+fn kill_poststate(&fn_ctxt fcx, &ann a, def_id id, &constr_occ o) -> bool {\n   log \"kill_poststate\";\n-  assert (fcx.enclosing.vars.contains_key(id));\n-  let uint i = (fcx.enclosing.vars.get(id)).bit_num;\n-  ret clear_in_poststate(i, (ann_to_ts_ann(fcx.ccx, a)).states);\n+  ret clear_in_poststate(bit_num(fcx, id, o),\n+                         (ann_to_ts_ann(fcx.ccx, a)).states);\n }\n \n+//\n+// Local Variables:\n+// mode: rust\n+// fill-column: 78;\n+// indent-tabs-mode: nil\n+// c-basic-offset: 4\n+// buffer-file-coding-system: utf-8-unix\n+// compile-command: \"make -k -C $RBUILD 2>&1 | sed -e 's/\\\\/x\\\\//x:\\\\//g'\";\n+// End:\n+//"}, {"sha": "9ba06711cd96075ff9e927ea3bad324e4b0d8095", "filename": "src/comp/middle/tstate/ck.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/1402cd101bfd2b0235900dfd07593572f34f4844/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1402cd101bfd2b0235900dfd07593572f34f4844/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fck.rs?ref=1402cd101bfd2b0235900dfd07593572f34f4844", "patch": "@@ -50,7 +50,7 @@ import aux::expr_prestate;\n import aux::expr_poststate;\n import aux::stmt_poststate;\n import aux::stmt_to_ann;\n-import aux::num_locals;\n+import aux::num_constraints;\n import aux::fixed_point_states;\n import aux::bitv_to_str;\n import aux::first_difference_string;\n@@ -113,7 +113,7 @@ fn check_states_stmt(&fn_ctxt fcx, &stmt s) -> () {\n \n fn check_states_against_conditions(&fn_ctxt fcx, &_fn f, &ann a) -> () {\n     auto enclosing = fcx.enclosing;\n-    auto nv   = num_locals(enclosing);\n+    auto nv   = num_constraints(enclosing);\n     auto post = @empty_poststate(nv);\n \n     fn do_one_(fn_ctxt fcx, &@stmt s, @poststate post) -> () {\n@@ -134,7 +134,7 @@ fn check_states_against_conditions(&fn_ctxt fcx, &_fn f, &ann a) -> () {\n     auto cf = fcx.enclosing.cf;\n     /* Finally, check that the return value is initialized */\n     if (f.proto == ast::proto_fn\n-        && ! promises(*post, fcx.id, enclosing)\n+        && ! promises(fcx, *post, fcx.id, aux::occ_init)\n         && ! type_is_nil(fcx.ccx.tcx,\n                          ret_ty_of_fn(fcx.ccx.tcx, a))\n         && cf == return) {\n@@ -147,8 +147,8 @@ fn check_states_against_conditions(&fn_ctxt fcx, &_fn f, &ann a) -> () {\n     else if (cf == noreturn) {\n         // check that this really always fails\n         // the fcx.id bit means \"returns\" for a returning fn,\n-        // \"diverges\" for a non-returning fn (I need to use the word\n-        if (! promises(*post, fcx.id, enclosing)) {\n+        // \"diverges\" for a non-returning fn\n+        if (! promises(fcx, *post, fcx.id, aux::occ_init)) {\n             fcx.ccx.tcx.sess.span_err(f.body.span,\n               \"In non-returning function \" + fcx.name +\n               \", some control paths may return to the caller\");"}, {"sha": "8be160a865a5bd3fc3a2cff6d4a8207e53f9b961", "filename": "src/comp/middle/tstate/collect_locals.rs", "status": "modified", "additions": 143, "deletions": 47, "changes": 190, "blob_url": "https://github.com/rust-lang/rust/blob/1402cd101bfd2b0235900dfd07593572f34f4844/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1402cd101bfd2b0235900dfd07593572f34f4844/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fcollect_locals.rs?ref=1402cd101bfd2b0235900dfd07593572f34f4844", "patch": "@@ -1,96 +1,192 @@\n import std::vec;\n import std::vec::plus_option;\n \n-import front::ast;\n-import front::ast::crate;\n-import front::ast::ann;\n-import front::ast::arg;\n-import front::ast::method;\n-import front::ast::local;\n-import front::ast::item;\n-import front::ast::item_fn;\n-import front::ast::item_obj;\n-import front::ast::_obj;\n-import front::ast::obj_def_ids;\n-import front::ast::_fn;\n-import front::ast::ty_param;\n-import front::ast::_mod;\n-import front::ast::decl;\n-import front::ast::decl_local;\n-import front::ast::def_id;\n-import front::ast::ident;\n+import front::ast::*;\n+import option::*;\n \n import middle::walk::walk_crate;\n import middle::walk::walk_fn;\n import middle::walk::ast_visitor;\n \n+import aux::cinit;\n+import aux::ninit;\n+import aux::npred;\n+import aux::cpred;\n+import aux::constraint;\n import aux::fn_info;\n-import aux::var_info;\n import aux::crate_ctxt;\n+import aux::num_constraints;\n+import aux::constr_map;\n \n import util::common::new_def_hash;\n import util::common::uistr;\n import util::common::span;\n+import util::common::respan;\n \n-type identifier = rec(ident name, def_id id, span sp);\n+type ctxt = rec(@vec[constraint_info] cs,\n+                ty::ctxt tcx);\n \n-fn var_is_local(def_id v, fn_info m) -> bool {\n-  ret (m.vars.contains_key(v));\n-}\n+type constraint_info = rec(def_id id, aux::constr c);\n \n-fn collect_local(&@vec[identifier] vars, &@decl d) -> () {\n+fn collect_local(&ctxt cx, &@decl d) -> () {\n     alt (d.node) {\n       case (decl_local(?loc)) {\n         log(\"collect_local: pushing \" + loc.ident);\n-        vec::push[identifier](*vars, rec(name=loc.ident,\n-                                         id=loc.id,\n-                                         sp=d.span));\n+        vec::push[constraint_info](*cx.cs,\n+                                   rec(id=loc.id,\n+                                       c=respan(d.span,\n+                                                ninit(loc.ident))));\n       }\n       case (_) { ret; }\n     }\n }\n \n-fn find_locals(&_fn f, &span sp, &ident i, &def_id d, &ann a)\n-    -> @vec[identifier] {\n-  auto res = @vec::alloc[identifier](0u);\n-  auto visitor = walk::default_visitor();\n-  visitor = rec(visit_decl_pre=bind collect_local(res,_) with visitor);\n-  walk_fn(visitor, f, sp, i, d, a);\n-  ret res;\n+fn exprs_to_constr_args(ty::ctxt tcx, vec[@expr] args) -> vec[@constr_arg] {\n+    fn one(ty::ctxt tcx, &@expr e) -> @constr_arg {\n+        alt (e.node) {\n+            case (expr_path(?p, _)) {\n+                if (vec::len(p.node.idents) == 1u) {\n+                    ret @respan(p.span, carg_ident(p.node.idents.(0)));\n+                }\n+                else {\n+                    tcx.sess.bug(\"exprs_to_constr_args: non-local variable \"\n+                                 + \"as pred arg\");\n+                }\n+            }\n+            case (expr_lit(?l, _)) {\n+                ret @respan(e.span, carg_lit(l));\n+            }\n+            case (_) {\n+                tcx.sess.bug(\"exprs_to_constr_args: ill-formed pred arg\");\n+            }\n+        }\n+    }\n+    auto f = bind one(tcx, _);\n+    ret vec::map(f, args); \n }\n \n+fn def_id_for_constr(ty::ctxt tcx, uint t) -> def_id {\n+    alt (tcx.def_map.find(t)) {\n+        case (none) {\n+            tcx.sess.bug(\"def_id_for_constr: bad node_id \" + uistr(t));\n+         }\n+        case (some(def_fn(?i))) {\n+            ret i;\n+        }\n+        case (_) {\n+            tcx.sess.bug(\"def_id_for_constr: pred is not a function\");\n+        }\n+    }\n+}\n \n-fn add_var(def_id v, span sp, ident nm, uint next, fn_info tbl) -> uint {\n-  log(nm + \" |-> \" + util::common::uistr(next));\n-  tbl.vars.insert(v, rec(bit_num=next, name=nm, sp=sp));\n-  ret (next + 1u);\n+fn expr_to_constr(ty::ctxt tcx, &@expr e) -> constraint_info {\n+    alt (e.node) {\n+        // change the first pattern to expr_path to test a typechecker bug\n+        case (expr_call(?operator, ?args, _)) {\n+            alt (operator.node) {\n+                case (expr_path(?p, ?a)) {\n+                    ret rec(id=def_id_for_constr(tcx, a.id),\n+                            c=respan(e.span,\n+                                npred(p, exprs_to_constr_args(tcx, args)))); \n+                }\n+                case (_) {\n+                    tcx.sess.span_err(operator.span, \"Internal error: \" +\n+                       \" ill-formed operator in predicate\");\n+                }\n+            }\n+        }\n+        case (_) {\n+            tcx.sess.span_err(e.span, \"Internal error: \" +\n+                              \" ill-formed predicate\");\n+        }\n+    }\n+}\n+\n+fn collect_pred(&ctxt cx, &@expr e) -> () {\n+    alt (e.node) {\n+        case (expr_check(?e, _)) {\n+            vec::push[constraint_info](*cx.cs, expr_to_constr(cx.tcx, e));\n+        }\n+        case (_) { }\n+    }\n+}\n+\n+fn find_locals(&ty::ctxt tcx, &_fn f, &span sp, &ident i, &def_id d, &ann a)\n+    -> ctxt {\n+    let ctxt cx = rec(cs=@vec::alloc[constraint_info](0u), tcx=tcx);\n+    auto visitor = walk::default_visitor();\n+    visitor = rec(visit_decl_pre=bind collect_local(cx,_),\n+                  visit_expr_pre=bind collect_pred(cx,_)\n+                  with visitor);\n+    walk_fn(visitor, f, sp, i, d, a);\n+    ret cx;\n+}\n+\n+fn add_constraint(&ty::ctxt tcx, constraint_info c, uint next, constr_map tbl)\n+    -> uint {\n+    log(aux::constraint_to_str(tcx, c.c) + \" |-> \"\n+        + util::common::uistr(next));\n+    let aux::constr cn = c.c;\n+    alt (cn.node) {\n+        case (ninit(?i)) {\n+            tbl.insert(c.id, cinit(next, cn.span, i));\n+        }\n+        case (npred(?p, ?args)) {\n+            alt (tbl.find(c.id)) {\n+                case (some[constraint](?ct)) {\n+                    alt (ct) {\n+                        case (cinit(_,_,_)) {\n+                            tcx.sess.bug(\"add_constraint: same def_id used\"\n+                                         + \" as a variable and a pred\");\n+                        }\n+                        case (cpred(_, ?pds)) {\n+                            vec::push(pds, respan(cn.span,\n+                              rec(args=args, bit_num=next)));\n+                        }\n+                    }\n+                }\n+                case (none[constraint]) {\n+                    tbl.insert(c.id, cpred(p,\n+                      [respan(cn.span, rec(args=args, bit_num=next))]));\n+                }\n+            }\n+        }\n+    }\n+    ret (next + 1u);\n }\n \n /* builds a table mapping each local var defined in f\n    to a bit number in the precondition/postcondition vectors */\n fn mk_fn_info(&crate_ctxt ccx, &_fn f, &span f_sp,\n               &ident f_name, &def_id f_id, &ann a)\n     -> () {\n-    auto res = rec(vars=@new_def_hash[var_info](),\n-                   cf=f.decl.cf);\n+    auto res_map = @new_def_hash[constraint]();\n     let uint next = 0u;\n     let vec[arg] f_args = f.decl.inputs;\n \n     /* ignore args, which we know are initialized;\n        just collect locally declared vars */\n \n-    let @vec[identifier] locals = find_locals(f, f_sp, f_name, f_id, a);\n-    for (identifier p in *locals) {\n-        next = add_var(p.id, p.sp, p.name, next, res);\n+    let ctxt cx = find_locals(ccx.tcx, f, f_sp, f_name, f_id, a);\n+    /* now we have to add bit nums for both the constraints\n+       and the variables... */\n+\n+    for (constraint_info c in *cx.cs) {\n+        next = add_constraint(cx.tcx, c, next, res_map);\n     }\n     /* add a pseudo-entry for the function's return value\n        we can safely use the function's name itself for this purpose */\n-    add_var(f_id, f_sp, f_name, next, res);\n+    add_constraint(cx.tcx, rec(id=f_id,\n+                               c=respan(f_sp, ninit(f_name))), next, res_map);\n+    \n+    auto res = rec(constrs=res_map,\n+                            num_constraints=vec::len(*cx.cs) + 1u,\n+                   cf=f.decl.cf);\n \n-    log(f_name + \" has \" + uistr(vec::len[identifier](*locals))\n-            + \" locals\");\n-   \n     ccx.fm.insert(f_id, res);\n+    \n+    log(f_name + \" has \" + uistr(num_constraints(res)) + \" constraints\");\n+\n }\n \n /* initializes the global fn_info_map (mapping each function ID, including"}, {"sha": "d1df649f7a61ee8c5dd57441b64648776d36044e", "filename": "src/comp/middle/tstate/pre_post_conditions.rs", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/1402cd101bfd2b0235900dfd07593572f34f4844/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1402cd101bfd2b0235900dfd07593572f34f4844/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fpre_post_conditions.rs?ref=1402cd101bfd2b0235900dfd07593572f34f4844", "patch": "@@ -17,10 +17,11 @@ import tstate::ann::pp_clone;\n import tstate::ann::empty_prestate;\n import tstate::ann::set_precondition;\n import tstate::ann::set_postcondition;\n-import aux::var_info;\n import aux::crate_ctxt;\n import aux::fn_ctxt;\n-import aux::num_locals;\n+import aux::occ_init;\n+import aux::num_constraints;\n+import aux::constraint;\n import aux::expr_pp;\n import aux::stmt_pp;\n import aux::block_pp;\n@@ -93,8 +94,10 @@ fn find_pre_post_item(&crate_ctxt ccx, &item i) -> () {\n     alt (i.node) {\n         case (item_const(?id, ?t, ?e, ?di, ?a)) {\n             // make a fake fcx\n-            auto fake_fcx = rec(enclosing=rec(vars=@new_def_hash[var_info](),\n-                                              cf=return),\n+            auto fake_fcx = rec(enclosing=\n+                rec(constrs=@new_def_hash[constraint](),\n+                    num_constraints=0u,\n+                    cf=return),\n                                 id=tup(0,0),\n                                 name=\"\",\n                                 ccx=ccx);\n@@ -136,7 +139,7 @@ fn find_pre_post_exprs(&fn_ctxt fcx, &vec[@expr] args, ann a) {\n \n     auto enclosing = fcx.enclosing;\n     auto fm        = fcx.ccx.fm;\n-    auto nv        = num_locals(enclosing);\n+    auto nv        = num_constraints(enclosing);\n \n     fn do_one(fn_ctxt fcx, &@expr e) -> () {\n         find_pre_post_expr(fcx, e);\n@@ -163,7 +166,7 @@ fn find_pre_post_loop(&fn_ctxt fcx, &@decl d, &@expr index,\n     find_pre_post_expr(fcx, index);\n     find_pre_post_block(fcx, body);\n     log(\"222\");\n-    auto loop_precond = declare_var(fcx.enclosing, decl_lhs(d),\n+    auto loop_precond = declare_var(fcx, decl_lhs(d),\n       seq_preconds(fcx, [expr_pp(fcx.ccx, index), block_pp(fcx.ccx, body)]));\n     auto loop_postcond = intersect_postconds\n         ([expr_postcond(fcx.ccx, index), block_postcond(fcx.ccx, body)]);\n@@ -180,7 +183,7 @@ fn gen_if_local(&fn_ctxt fcx, @expr lhs, @expr rhs,\n                   auto p = expr_pp(fcx.ccx, rhs);\n                   set_pre_and_post(fcx.ccx, larger_ann,\n                                    p.precondition, p.postcondition);\n-                  gen(fcx, larger_ann, d_id);\n+                  gen(fcx, larger_ann, d_id, aux::occ_init);\n               }\n               case (_) { find_pre_post_exprs(fcx, [lhs, rhs], larger_ann); }\n           }\n@@ -192,13 +195,13 @@ fn gen_if_local(&fn_ctxt fcx, @expr lhs, @expr rhs,\n /* Fills in annotations as a side effect. Does not rebuild the expr */\n fn find_pre_post_expr(&fn_ctxt fcx, @expr e) -> () {\n     auto enclosing      = fcx.enclosing;\n-    auto num_local_vars = num_locals(enclosing);\n+    auto num_local_vars = num_constraints(enclosing);\n \n     fn do_rand_(fn_ctxt fcx, &@expr e) -> () {\n         find_pre_post_expr(fcx, e);\n     }\n     \n-    log(\"find_pre_post_expr (num_locals =\" +\n+    log(\"find_pre_post_expr (num_constraints =\" +\n         uistr(num_local_vars) + \"):\");\n     log_expr(*e);\n \n@@ -233,7 +236,7 @@ fn find_pre_post_expr(&fn_ctxt fcx, @expr e) -> () {\n             auto df = ann_to_def_strict(fcx.ccx, a);\n             alt (df) {\n                 case (def_local(?d_id)) {\n-                    auto i = bit_num(d_id, enclosing);\n+                    auto i = bit_num(fcx, d_id, occ_init);\n                     require_and_preserve(i, res);\n                 }\n                 case (_) { /* nothing to check */ }\n@@ -511,7 +514,7 @@ fn find_pre_post_stmt(&fn_ctxt fcx, &stmt s)\n     log_stmt(s);\n \n     auto enclosing      = fcx.enclosing;\n-    auto num_local_vars = num_locals(enclosing);\n+    auto num_local_vars = num_constraints(enclosing);\n     alt(s.node) {\n         case(stmt_decl(?adecl, ?a)) {\n             alt(adecl.node) {\n@@ -526,11 +529,11 @@ fn find_pre_post_stmt(&fn_ctxt fcx, &stmt s)\n                             copy_pre_post(fcx.ccx, a, an_init.expr);\n                             /*  log(\"gen (decl):\");\n                                 log_stmt(s); */\n-                            gen(fcx, a, alocal.id); \n-                            /*                     log_err(\"for stmt\");\n-                                                   log_stmt(s);\n-                                                   log_err(\"pp = \");\n-                                                   log_pp(stmt_pp(s)); */\n+                            gen(fcx, a, alocal.id, occ_init); \n+                            /*  log_err(\"for stmt\");\n+                                log_stmt(s);\n+                                log_err(\"pp = \");\n+                                log_pp(stmt_pp(s)); */\n                         }\n                         case(none) {\n                             clear_pp(ann_to_ts_ann(fcx.ccx,\n@@ -569,7 +572,7 @@ fn find_pre_post_block(&fn_ctxt fcx, block b) -> () {\n \n      won't have a postcondition that says x is initialized, but that's ok.\n      */\n-    auto nv = num_locals(fcx.enclosing);\n+    auto nv = num_constraints(fcx.enclosing);\n \n     fn do_one_(fn_ctxt fcx, &@stmt s) -> () {\n         find_pre_post_stmt(fcx, *s);"}, {"sha": "37cc40b5c9eb5eee6838b1ab3dab8bc2da36c67d", "filename": "src/comp/middle/tstate/states.rs", "status": "modified", "additions": 13, "deletions": 9, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/1402cd101bfd2b0235900dfd07593572f34f4844/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1402cd101bfd2b0235900dfd07593572f34f4844/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Fmiddle%2Ftstate%2Fstates.rs?ref=1402cd101bfd2b0235900dfd07593572f34f4844", "patch": "@@ -24,10 +24,9 @@ import tstate::ann::false_postcond;\n import tstate::ann::ts_ann;\n import tstate::ann::extend_prestate;\n import tstate::ann::extend_poststate;\n-import aux::var_info;\n import aux::crate_ctxt;\n import aux::fn_ctxt;\n-import aux::num_locals;\n+import aux::num_constraints;\n import aux::expr_pp;\n import aux::stmt_pp;\n import aux::block_pp;\n@@ -49,6 +48,7 @@ import aux::log_states;\n import aux::block_states;\n import aux::controlflow_expr;\n import aux::ann_to_def;\n+import aux::occ_init;\n \n import bitvectors::seq_preconds;\n import bitvectors::union_postconds;\n@@ -121,15 +121,15 @@ fn find_pre_post_state_loop(&fn_ctxt fcx, prestate pres, &@decl d,\n fn gen_if_local(&fn_ctxt fcx, &ann a_new_var, &ann a) -> bool {\n   alt (ann_to_def(fcx.ccx, a_new_var)) {\n       case (some(def_local(?loc))) {\n-          ret gen_poststate(fcx, a, loc);\n+          ret gen_poststate(fcx, a, loc, occ_init);\n       }\n       case (_) { ret false; }\n   }\n }\n \n fn find_pre_post_state_expr(&fn_ctxt fcx, &prestate pres, @expr e) -> bool {\n   auto changed = false;\n-  auto num_local_vars = num_locals(fcx.enclosing);\n+  auto num_local_vars = num_constraints(fcx.enclosing);\n \n   /*  \n   log_err(\"states:\");\n@@ -319,11 +319,14 @@ fn find_pre_post_state_expr(&fn_ctxt fcx, &prestate pres, @expr e) -> bool {\n \n     case (expr_ret(?maybe_ret_val, ?a)) {\n         changed = extend_prestate_ann(fcx.ccx, a, pres) || changed;\n+        /* normally, everything is true if execution continues after\n+           a ret expression (since execution never continues locally\n+           after a ret expression */\n         set_poststate_ann(fcx.ccx, a, false_postcond(num_local_vars));\n         /* return from an always-failing function clears the return bit */\n         alt (fcx.enclosing.cf) {\n             case (noreturn) {\n-                kill_poststate(fcx, a, fcx.id);\n+                kill_poststate(fcx, a, fcx.id, occ_init);\n             }\n             case (_) {}\n         }\n@@ -578,7 +581,8 @@ fn find_pre_post_state_stmt(&fn_ctxt fcx, &prestate pres, @stmt s) -> bool {\n                                 (stmt_ann.states.poststate,\n                                  expr_poststate(fcx.ccx, an_init.expr))\n                                 || changed;\n-                            changed = gen_poststate(fcx, a, alocal.id)\n+                            changed = gen_poststate(fcx, a,\n+                                                    alocal.id, occ_init)\n                                 || changed;\n                             log(\"Summary: stmt = \");\n                             log_stmt(*s);\n@@ -642,7 +646,7 @@ fn find_pre_post_state_block(&fn_ctxt fcx, &prestate pres0, &block b)\n   -> bool {\n     \n   auto changed = false;\n-  auto num_local_vars = num_locals(fcx.enclosing);\n+  auto num_local_vars = num_constraints(fcx.enclosing);\n \n   /* First, set the pre-states and post-states for every expression */\n   auto pres = pres0;\n@@ -694,7 +698,7 @@ fn find_pre_post_state_block(&fn_ctxt fcx, &prestate pres0, &block b)\n }\n \n fn find_pre_post_state_fn(&fn_ctxt fcx, &_fn f) -> bool {\n-    auto num_local_vars = num_locals(fcx.enclosing);\n+    auto num_local_vars = num_constraints(fcx.enclosing);\n     auto changed = find_pre_post_state_block(fcx,\n                      empty_prestate(num_local_vars), f.body);\n \n@@ -715,7 +719,7 @@ fn find_pre_post_state_fn(&fn_ctxt fcx, &_fn f) -> bool {\n                                   false_postcond(num_local_vars));\n                 alt (fcx.enclosing.cf) {\n                     case (noreturn) {\n-                        kill_poststate(fcx, tailann, fcx.id);\n+                        kill_poststate(fcx, tailann, fcx.id, occ_init);\n                     }\n                     case (_) { }\n                 }"}, {"sha": "2435c2610e766485864ae6d97735f8a93a63082d", "filename": "src/comp/util/common.rs", "status": "modified", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/1402cd101bfd2b0235900dfd07593572f34f4844/src%2Fcomp%2Futil%2Fcommon.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1402cd101bfd2b0235900dfd07593572f34f4844/src%2Fcomp%2Futil%2Fcommon.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fcomp%2Futil%2Fcommon.rs?ref=1402cd101bfd2b0235900dfd07593572f34f4844", "patch": "@@ -9,6 +9,8 @@ import front::ast;\n import front::ast::ty;\n import front::ast::pat;\n import front::codemap::codemap;\n+import front::ast::lit;\n+import front::ast::path;\n import middle::walk;\n \n import std::io::stdout;\n@@ -17,9 +19,11 @@ import std::io::string_writer;\n import pretty::pprust::print_block;\n import pretty::pprust::print_item;\n import pretty::pprust::print_expr;\n+import pretty::pprust::print_path;\n import pretty::pprust::print_decl;\n import pretty::pprust::print_fn;\n import pretty::pprust::print_type;\n+import pretty::pprust::print_literal;\n import pretty::pprust::mo_untyped;\n import pretty::pp::mk_printer;\n \n@@ -227,6 +231,65 @@ fn local_rhs_span(&@ast::local l, &span def) -> span {\n     }\n }\n \n+fn lit_eq(&@ast::lit l, &@ast::lit m) -> bool {\n+    alt (l.node) {\n+        case (ast::lit_str(?s)) {\n+            alt (m.node) {\n+                case (ast::lit_str(?t)) { ret s == t; }\n+                case (_)           { ret false; }\n+            }\n+        }\n+        case (ast::lit_char(?c)) {\n+            alt (m.node) {\n+                case (ast::lit_char(?d)) { ret c == d; }\n+                case (_)           { ret false; }\n+            }\n+        }\n+        case (ast::lit_int(?i)) {\n+            alt (m.node) {\n+                case (ast::lit_int(?j)) { ret i == j; }\n+                case (_)           { ret false; }\n+            }\n+        }\n+        case (ast::lit_uint(?i)) {\n+            alt (m.node) {\n+                case (ast::lit_uint(?j)) { ret i == j; }\n+                case (_)            { ret false; }\n+            }\n+        }\n+        case (ast::lit_mach_int(_, ?i)) {\n+            alt (m.node) {\n+                case (ast::lit_mach_int(_, ?j)) { ret i == j; }\n+                case (_)                    { ret false; }\n+            }\n+        }\n+        case (ast::lit_float(?s)) {\n+            alt (m.node) {\n+                case (ast::lit_float(?t)) { ret s == t; }\n+                case (_)             { ret false; }\n+            }\n+        }\n+        case (ast::lit_mach_float(_,?s)) {\n+            alt (m.node) {\n+                case (ast::lit_mach_float(_,?t)) { ret s == t; }\n+                case (_)               { ret false; }\n+            }\n+        }\n+        case (ast::lit_nil) {\n+            alt (m.node) {\n+                case (ast::lit_nil) { ret true; }\n+                case (_)       { ret false; }\n+            }\n+        }\n+        case (ast::lit_bool(?b)) {\n+            alt (m.node) {\n+                case (ast::lit_bool(?c)) { ret b == c; }\n+                case (_)            { ret false; }\n+            }\n+        }\n+    }\n+}\n+\n fn respan[T](&span sp, &T t) -> spanned[T] {\n     ret rec(node=t, span=sp);\n }"}]}