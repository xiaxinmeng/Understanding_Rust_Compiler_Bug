{"sha": "de561a9d3d8d06969abc4f6851fd532f584ff52c", "node_id": "MDY6Q29tbWl0NzI0NzEyOmRlNTYxYTlkM2Q4ZDA2OTY5YWJjNGY2ODUxZmQ1MzJmNTg0ZmY1MmM=", "commit": {"author": {"name": "Ralf Jung", "email": "post@ralfj.de", "date": "2020-05-29T19:58:29Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2020-05-29T19:58:29Z"}, "message": "Rollup merge of #72407 - Lucretiel:ipv6-display, r=Mark-Simulacrum\n\nVarious minor improvements to Ipv6Addr::Display\n\nCleaned up `Ipv6Addr::Display`, especially with an eye towards simplifying and reducing duplicated logic. Also added a fast-path optimization, similar to #72399 and #72398.\n\n- Defer to `Ipv4Addr::fmt` when printing an Ipv4 address\n- Fast path: write directly to `f` without an intermediary buffer when there are no alignment options\n- Simplify finding the inner zeroes-span", "tree": {"sha": "2e51f1e2ec4fec6b702ced9685a95474bdad99df", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2e51f1e2ec4fec6b702ced9685a95474bdad99df"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/de561a9d3d8d06969abc4f6851fd532f584ff52c", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJe0WlmCRBK7hj4Ov3rIwAAdHIIAAkQuOl12wjCdPgxTaIWVkMr\nAeq4eLQj2NcNKGuRx4U4inWll5T2CFvFC8yAYNNUrHdkYObdHC3kom+OwJPmh1Ai\ntV3wacZwGPGpD7YgDJoP8el4dUjc3NmyiPoey+m33OK0cUX84+aj2f6GQDAy8bRq\nc4VId0T1VtgYXUZ4cJGibwn8oPIDrzGWEpumcGmikvuzt7VH8AyVOsraP7aQPAZO\nh4KLQAocjkn3FUSHEB+1WwKg9b6konnjWtw5rHCdLe8ZU+s0ftZxRfK4HmHamMpo\nChB6sWpjzD5P0I1up9khNiLXUiIIIUkB/eUznEA72dojWRub2UbnlnBktaP6U3A=\n=Fyjd\n-----END PGP SIGNATURE-----\n", "payload": "tree 2e51f1e2ec4fec6b702ced9685a95474bdad99df\nparent e229d6e73b0a665aaad8802b8b9b66c1c4fef499\nparent 44ca3da9a386665834e34d27e30ed471253f2777\nauthor Ralf Jung <post@ralfj.de> 1590782309 +0200\ncommitter GitHub <noreply@github.com> 1590782309 +0200\n\nRollup merge of #72407 - Lucretiel:ipv6-display, r=Mark-Simulacrum\n\nVarious minor improvements to Ipv6Addr::Display\n\nCleaned up `Ipv6Addr::Display`, especially with an eye towards simplifying and reducing duplicated logic. Also added a fast-path optimization, similar to #72399 and #72398.\n\n- Defer to `Ipv4Addr::fmt` when printing an Ipv4 address\n- Fast path: write directly to `f` without an intermediary buffer when there are no alignment options\n- Simplify finding the inner zeroes-span\n"}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/de561a9d3d8d06969abc4f6851fd532f584ff52c", "html_url": "https://github.com/rust-lang/rust/commit/de561a9d3d8d06969abc4f6851fd532f584ff52c", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/de561a9d3d8d06969abc4f6851fd532f584ff52c/comments", "author": {"login": "RalfJung", "id": 330628, "node_id": "MDQ6VXNlcjMzMDYyOA==", "avatar_url": "https://avatars.githubusercontent.com/u/330628?v=4", "gravatar_id": "", "url": "https://api.github.com/users/RalfJung", "html_url": "https://github.com/RalfJung", "followers_url": "https://api.github.com/users/RalfJung/followers", "following_url": "https://api.github.com/users/RalfJung/following{/other_user}", "gists_url": "https://api.github.com/users/RalfJung/gists{/gist_id}", "starred_url": "https://api.github.com/users/RalfJung/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/RalfJung/subscriptions", "organizations_url": "https://api.github.com/users/RalfJung/orgs", "repos_url": "https://api.github.com/users/RalfJung/repos", "events_url": "https://api.github.com/users/RalfJung/events{/privacy}", "received_events_url": "https://api.github.com/users/RalfJung/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e229d6e73b0a665aaad8802b8b9b66c1c4fef499", "url": "https://api.github.com/repos/rust-lang/rust/commits/e229d6e73b0a665aaad8802b8b9b66c1c4fef499", "html_url": "https://github.com/rust-lang/rust/commit/e229d6e73b0a665aaad8802b8b9b66c1c4fef499"}, {"sha": "44ca3da9a386665834e34d27e30ed471253f2777", "url": "https://api.github.com/repos/rust-lang/rust/commits/44ca3da9a386665834e34d27e30ed471253f2777", "html_url": "https://github.com/rust-lang/rust/commit/44ca3da9a386665834e34d27e30ed471253f2777"}], "stats": {"total": 158, "additions": 78, "deletions": 80}, "files": [{"sha": "0f0be2c4883149d60a4add91d583c6d712cf6f5f", "filename": "src/libstd/net/ip.rs", "status": "modified", "additions": 78, "deletions": 80, "changes": 158, "blob_url": "https://github.com/rust-lang/rust/blob/de561a9d3d8d06969abc4f6851fd532f584ff52c/src%2Flibstd%2Fnet%2Fip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/de561a9d3d8d06969abc4f6851fd532f584ff52c/src%2Flibstd%2Fnet%2Fip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fnet%2Fip.rs?ref=de561a9d3d8d06969abc4f6851fd532f584ff52c", "patch": "@@ -7,9 +7,9 @@\n )]\n \n use crate::cmp::Ordering;\n-use crate::fmt;\n+use crate::fmt::{self, Write as FmtWrite};\n use crate::hash;\n-use crate::io::Write;\n+use crate::io::Write as IoWrite;\n use crate::sys::net::netc as c;\n use crate::sys_common::{AsInner, FromInner};\n \n@@ -1532,102 +1532,100 @@ impl Ipv6Addr {\n     }\n }\n \n+/// Write an Ipv6Addr, conforming to the canonical style described by\n+/// [RFC 5952](https://tools.ietf.org/html/rfc5952).\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl fmt::Display for Ipv6Addr {\n-    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        // Note: The calls to write should never fail, hence the unwraps in the function\n-        // Long enough for the longest possible IPv6: 39\n-        const IPV6_BUF_LEN: usize = 39;\n-        let mut buf = [0u8; IPV6_BUF_LEN];\n-        let mut buf_slice = &mut buf[..];\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        // If there are no alignment requirements, write out the IP address to\n+        // f. Otherwise, write it to a local buffer, then use f.pad.\n+        if f.precision().is_none() && f.width().is_none() {\n+            let segments = self.segments();\n+\n+            // Special case for :: and ::1; otherwise they get written with the\n+            // IPv4 formatter\n+            if self.is_unspecified() {\n+                f.write_str(\"::\")\n+            } else if self.is_loopback() {\n+                f.write_str(\"::1\")\n+            } else if let Some(ipv4) = self.to_ipv4() {\n+                match segments[5] {\n+                    // IPv4 Compatible address\n+                    0 => write!(f, \"::{}\", ipv4),\n+                    // IPv4 Mapped address\n+                    0xffff => write!(f, \"::ffff:{}\", ipv4),\n+                    _ => unreachable!(),\n+                }\n+            } else {\n+                #[derive(Copy, Clone, Default)]\n+                struct Span {\n+                    start: usize,\n+                    len: usize,\n+                }\n \n-        match self.segments() {\n-            // We need special cases for :: and ::1, otherwise they're formatted\n-            // as ::0.0.0.[01]\n-            [0, 0, 0, 0, 0, 0, 0, 0] => write!(buf_slice, \"::\").unwrap(),\n-            [0, 0, 0, 0, 0, 0, 0, 1] => write!(buf_slice, \"::1\").unwrap(),\n-            // Ipv4 Compatible address\n-            [0, 0, 0, 0, 0, 0, g, h] => {\n-                write!(\n-                    buf_slice,\n-                    \"::{}.{}.{}.{}\",\n-                    (g >> 8) as u8,\n-                    g as u8,\n-                    (h >> 8) as u8,\n-                    h as u8\n-                )\n-                .unwrap();\n-            }\n-            // Ipv4-Mapped address\n-            [0, 0, 0, 0, 0, 0xffff, g, h] => {\n-                write!(\n-                    buf_slice,\n-                    \"::ffff:{}.{}.{}.{}\",\n-                    (g >> 8) as u8,\n-                    g as u8,\n-                    (h >> 8) as u8,\n-                    h as u8\n-                )\n-                .unwrap();\n-            }\n-            _ => {\n-                fn find_zero_slice(segments: &[u16; 8]) -> (usize, usize) {\n-                    let mut longest_span_len = 0;\n-                    let mut longest_span_at = 0;\n-                    let mut cur_span_len = 0;\n-                    let mut cur_span_at = 0;\n-\n-                    for i in 0..8 {\n-                        if segments[i] == 0 {\n-                            if cur_span_len == 0 {\n-                                cur_span_at = i;\n+                // Find the inner 0 span\n+                let zeroes = {\n+                    let mut longest = Span::default();\n+                    let mut current = Span::default();\n+\n+                    for (i, &segment) in segments.iter().enumerate() {\n+                        if segment == 0 {\n+                            if current.len == 0 {\n+                                current.start = i;\n                             }\n \n-                            cur_span_len += 1;\n+                            current.len += 1;\n \n-                            if cur_span_len > longest_span_len {\n-                                longest_span_len = cur_span_len;\n-                                longest_span_at = cur_span_at;\n+                            if current.len > longest.len {\n+                                longest = current;\n                             }\n                         } else {\n-                            cur_span_len = 0;\n-                            cur_span_at = 0;\n+                            current = Span::default();\n                         }\n                     }\n \n-                    (longest_span_at, longest_span_len)\n-                }\n-\n-                let (zeros_at, zeros_len) = find_zero_slice(&self.segments());\n-\n-                if zeros_len > 1 {\n-                    fn fmt_subslice(segments: &[u16], buf: &mut &mut [u8]) {\n-                        if !segments.is_empty() {\n-                            write!(*buf, \"{:x}\", segments[0]).unwrap();\n-                            for &seg in &segments[1..] {\n-                                write!(*buf, \":{:x}\", seg).unwrap();\n-                            }\n+                    longest\n+                };\n+\n+                /// Write a colon-separated part of the address\n+                #[inline]\n+                fn fmt_subslice(f: &mut fmt::Formatter<'_>, chunk: &[u16]) -> fmt::Result {\n+                    if let Some(first) = chunk.first() {\n+                        fmt::LowerHex::fmt(first, f)?;\n+                        for segment in &chunk[1..] {\n+                            f.write_char(':')?;\n+                            fmt::LowerHex::fmt(segment, f)?;\n                         }\n                     }\n+                    Ok(())\n+                }\n \n-                    fmt_subslice(&self.segments()[..zeros_at], &mut buf_slice);\n-                    write!(buf_slice, \"::\").unwrap();\n-                    fmt_subslice(&self.segments()[zeros_at + zeros_len..], &mut buf_slice);\n+                if zeroes.len > 1 {\n+                    fmt_subslice(f, &segments[..zeroes.start])?;\n+                    f.write_str(\"::\")?;\n+                    fmt_subslice(f, &segments[zeroes.start + zeroes.len..])\n                 } else {\n-                    let &[a, b, c, d, e, f, g, h] = &self.segments();\n-                    write!(\n-                        buf_slice,\n-                        \"{:x}:{:x}:{:x}:{:x}:{:x}:{:x}:{:x}:{:x}\",\n-                        a, b, c, d, e, f, g, h\n-                    )\n-                    .unwrap();\n+                    fmt_subslice(f, &segments)\n                 }\n             }\n+        } else {\n+            // Slow path: write the address to a local buffer, the use f.pad.\n+            // Defined recursively by using the fast path to write to the\n+            // buffer.\n+\n+            // This is the largest possible size of an IPv6 address\n+            const IPV6_BUF_LEN: usize = (4 * 8) + 7;\n+            let mut buf = [0u8; IPV6_BUF_LEN];\n+            let mut buf_slice = &mut buf[..];\n+\n+            // Note: This call to write should never fail, so unwrap is okay.\n+            write!(buf_slice, \"{}\", self).unwrap();\n+            let len = IPV6_BUF_LEN - buf_slice.len();\n+\n+            // This is safe because we know exactly what can be in this buffer\n+            let buf = unsafe { crate::str::from_utf8_unchecked(&buf[..len]) };\n+            f.pad(buf)\n         }\n-        let len = IPV6_BUF_LEN - buf_slice.len();\n-        // This is safe because we know exactly what can be in this buffer\n-        let buf = unsafe { crate::str::from_utf8_unchecked(&buf[..len]) };\n-        fmt.pad(buf)\n     }\n }\n "}]}