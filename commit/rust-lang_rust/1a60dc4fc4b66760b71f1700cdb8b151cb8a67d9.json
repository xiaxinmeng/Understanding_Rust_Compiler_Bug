{"sha": "1a60dc4fc4b66760b71f1700cdb8b151cb8a67d9", "node_id": "MDY6Q29tbWl0NzI0NzEyOjFhNjBkYzRmYzRiNjY3NjBiNzFmMTcwMGNkYjhiMTUxY2I4YTY3ZDk=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-05-03T17:22:09Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2015-05-03T17:22:09Z"}, "message": "Auto merge of #24737 - P1start:dst-cell, r=alexcrichton\n\nThis + DST coercions (#24619) would allow code like `Rc<RefCell<Box<Trait>>>` to be simplified to `Rc<RefCell<Trait>>`.", "tree": {"sha": "3998daf2afd0c715a001ea3f4ae962e5827d7b97", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/3998daf2afd0c715a001ea3f4ae962e5827d7b97"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/1a60dc4fc4b66760b71f1700cdb8b151cb8a67d9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/1a60dc4fc4b66760b71f1700cdb8b151cb8a67d9", "html_url": "https://github.com/rust-lang/rust/commit/1a60dc4fc4b66760b71f1700cdb8b151cb8a67d9", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/1a60dc4fc4b66760b71f1700cdb8b151cb8a67d9/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "26933a638c360442412b51aa70fe25e419f44314", "url": "https://api.github.com/repos/rust-lang/rust/commits/26933a638c360442412b51aa70fe25e419f44314", "html_url": "https://github.com/rust-lang/rust/commit/26933a638c360442412b51aa70fe25e419f44314"}, {"sha": "57d8289754767e046a01abaab6054b7146c51f74", "url": "https://api.github.com/repos/rust-lang/rust/commits/57d8289754767e046a01abaab6054b7146c51f74", "html_url": "https://github.com/rust-lang/rust/commit/57d8289754767e046a01abaab6054b7146c51f74"}], "stats": {"total": 190, "additions": 122, "deletions": 68}, "files": [{"sha": "c717b608a246ef1014da6a675d53b5d57f9e2ea2", "filename": "src/libcore/cell.rs", "status": "modified", "additions": 32, "deletions": 27, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/1a60dc4fc4b66760b71f1700cdb8b151cb8a67d9/src%2Flibcore%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a60dc4fc4b66760b71f1700cdb8b151cb8a67d9/src%2Flibcore%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fcell.rs?ref=1a60dc4fc4b66760b71f1700cdb8b151cb8a67d9", "patch": "@@ -144,7 +144,7 @@\n use clone::Clone;\n use cmp::PartialEq;\n use default::Default;\n-use marker::{Copy, Send, Sync};\n+use marker::{Copy, Send, Sync, Sized};\n use ops::{Deref, DerefMut, Drop};\n use option::Option;\n use option::Option::{None, Some};\n@@ -266,9 +266,9 @@ impl<T:PartialEq + Copy> PartialEq for Cell<T> {\n ///\n /// See the [module-level documentation](index.html) for more.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct RefCell<T> {\n-    value: UnsafeCell<T>,\n+pub struct RefCell<T: ?Sized> {\n     borrow: Cell<BorrowFlag>,\n+    value: UnsafeCell<T>,\n }\n \n /// An enumeration of values returned from the `state` method on a `RefCell<T>`.\n@@ -328,7 +328,9 @@ impl<T> RefCell<T> {\n         debug_assert!(self.borrow.get() == UNUSED);\n         unsafe { self.value.into_inner() }\n     }\n+}\n \n+impl<T: ?Sized> RefCell<T> {\n     /// Query the current state of this `RefCell`\n     ///\n     /// The returned value can be dispatched on to determine if a call to\n@@ -449,7 +451,7 @@ impl<T> RefCell<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-unsafe impl<T> Send for RefCell<T> where T: Send {}\n+unsafe impl<T: ?Sized> Send for RefCell<T> where T: Send {}\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n impl<T: Clone> Clone for RefCell<T> {\n@@ -469,7 +471,7 @@ impl<T:Default> Default for RefCell<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: PartialEq> PartialEq for RefCell<T> {\n+impl<T: ?Sized + PartialEq> PartialEq for RefCell<T> {\n     #[inline]\n     fn eq(&self, other: &RefCell<T>) -> bool {\n         *self.borrow() == *other.borrow()\n@@ -519,15 +521,15 @@ impl<'b> Clone for BorrowRef<'b> {\n ///\n /// See the [module-level documentation](index.html) for more.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Ref<'b, T:'b> {\n+pub struct Ref<'b, T: ?Sized + 'b> {\n     // FIXME #12808: strange name to try to avoid interfering with\n     // field accesses of the contained type via Deref\n     _value: &'b T,\n     _borrow: BorrowRef<'b>,\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'b, T> Deref for Ref<'b, T> {\n+impl<'b, T: ?Sized> Deref for Ref<'b, T> {\n     type Target = T;\n \n     #[inline]\n@@ -582,15 +584,15 @@ impl<'b> BorrowRefMut<'b> {\n ///\n /// See the [module-level documentation](index.html) for more.\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct RefMut<'b, T:'b> {\n+pub struct RefMut<'b, T: ?Sized + 'b> {\n     // FIXME #12808: strange name to try to avoid interfering with\n     // field accesses of the contained type via Deref\n     _value: &'b mut T,\n     _borrow: BorrowRefMut<'b>,\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'b, T> Deref for RefMut<'b, T> {\n+impl<'b, T: ?Sized> Deref for RefMut<'b, T> {\n     type Target = T;\n \n     #[inline]\n@@ -600,7 +602,7 @@ impl<'b, T> Deref for RefMut<'b, T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'b, T> DerefMut for RefMut<'b, T> {\n+impl<'b, T: ?Sized> DerefMut for RefMut<'b, T> {\n     #[inline]\n     fn deref_mut<'a>(&'a mut self) -> &'a mut T {\n         self._value\n@@ -633,7 +635,7 @@ impl<'b, T> DerefMut for RefMut<'b, T> {\n /// recommended to access its fields directly, `get` should be used instead.\n #[lang=\"unsafe_cell\"]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct UnsafeCell<T> {\n+pub struct UnsafeCell<T: ?Sized> {\n     /// Wrapped value\n     ///\n     /// This field should not be accessed directly, it is made public for static\n@@ -642,7 +644,7 @@ pub struct UnsafeCell<T> {\n     pub value: T,\n }\n \n-impl<T> !Sync for UnsafeCell<T> {}\n+impl<T: ?Sized> !Sync for UnsafeCell<T> {}\n \n impl<T> UnsafeCell<T> {\n     /// Constructs a new instance of `UnsafeCell` which will wrap the specified\n@@ -664,7 +666,12 @@ impl<T> UnsafeCell<T> {\n         UnsafeCell { value: value }\n     }\n \n-    /// Gets a mutable pointer to the wrapped value.\n+    /// Unwraps the value.\n+    ///\n+    /// # Unsafety\n+    ///\n+    /// This function is unsafe because there is no guarantee that this or other threads are\n+    /// currently inspecting the inner value.\n     ///\n     /// # Examples\n     ///\n@@ -673,22 +680,15 @@ impl<T> UnsafeCell<T> {\n     ///\n     /// let uc = UnsafeCell::new(5);\n     ///\n-    /// let five = uc.get();\n+    /// let five = unsafe { uc.into_inner() };\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub fn get(&self) -> *mut T {\n-        // FIXME(#23542) Replace with type ascription.\n-        #![allow(trivial_casts)]\n-        &self.value as *const T as *mut T\n-    }\n+    pub unsafe fn into_inner(self) -> T { self.value }\n+}\n \n-    /// Unwraps the value.\n-    ///\n-    /// # Unsafety\n-    ///\n-    /// This function is unsafe because there is no guarantee that this or other threads are\n-    /// currently inspecting the inner value.\n+impl<T: ?Sized> UnsafeCell<T> {\n+    /// Gets a mutable pointer to the wrapped value.\n     ///\n     /// # Examples\n     ///\n@@ -697,9 +697,14 @@ impl<T> UnsafeCell<T> {\n     ///\n     /// let uc = UnsafeCell::new(5);\n     ///\n-    /// let five = unsafe { uc.into_inner() };\n+    /// let five = uc.get();\n     /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-    pub unsafe fn into_inner(self) -> T { self.value }\n+    pub fn get(&self) -> *mut T {\n+        // FIXME(#23542) Replace with type ascription.\n+        #![allow(trivial_casts)]\n+        &self.value as *const T as *mut T\n+    }\n+\n }"}, {"sha": "f8a1ef96bcc337df56aa33f6eb301bfd58b31d43", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/1a60dc4fc4b66760b71f1700cdb8b151cb8a67d9/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a60dc4fc4b66760b71f1700cdb8b151cb8a67d9/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=1a60dc4fc4b66760b71f1700cdb8b151cb8a67d9", "patch": "@@ -1062,7 +1062,7 @@ impl<T: Copy + Debug> Debug for Cell<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: Debug> Debug for RefCell<T> {\n+impl<T: ?Sized + Debug> Debug for RefCell<T> {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         match self.borrow_state() {\n             BorrowState::Unused | BorrowState::Reading => {\n@@ -1074,14 +1074,14 @@ impl<T: Debug> Debug for RefCell<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'b, T: Debug> Debug for Ref<'b, T> {\n+impl<'b, T: ?Sized + Debug> Debug for Ref<'b, T> {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         Debug::fmt(&**self, f)\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'b, T: Debug> Debug for RefMut<'b, T> {\n+impl<'b, T: ?Sized + Debug> Debug for RefMut<'b, T> {\n     fn fmt(&self, f: &mut Formatter) -> Result {\n         Debug::fmt(&*(self.deref()), f)\n     }"}, {"sha": "0bd0b66318f1b12ecc17e6d532a1246d786fe9bb", "filename": "src/libcoretest/cell.rs", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/1a60dc4fc4b66760b71f1700cdb8b151cb8a67d9/src%2Flibcoretest%2Fcell.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a60dc4fc4b66760b71f1700cdb8b151cb8a67d9/src%2Flibcoretest%2Fcell.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fcell.rs?ref=1a60dc4fc4b66760b71f1700cdb8b151cb8a67d9", "patch": "@@ -159,3 +159,27 @@ fn refcell_default() {\n     let cell: RefCell<u64> = Default::default();\n     assert_eq!(0, *cell.borrow());\n }\n+\n+#[test]\n+fn unsafe_cell_unsized() {\n+    let cell: &UnsafeCell<[i32]> = &UnsafeCell::new([1, 2, 3]);\n+    {\n+        let val: &mut [i32] = unsafe { &mut *cell.get() };\n+        val[0] = 4;\n+        val[2] = 5;\n+    }\n+    let comp: &mut [i32] = &mut [4, 2, 5];\n+    assert_eq!(unsafe { &mut *cell.get() }, comp);\n+}\n+\n+#[test]\n+fn refcell_unsized() {\n+    let cell: &RefCell<[i32]> = &RefCell::new([1, 2, 3]);\n+    {\n+        let b = &mut *cell.borrow_mut();\n+        b[0] = 4;\n+        b[2] = 5;\n+    }\n+    let comp: &mut [i32] = &mut [4, 2, 5];\n+    assert_eq!(&*cell.borrow(), comp);\n+}"}, {"sha": "222aff9188a6acb321467d081191d336cd4a856a", "filename": "src/libstd/sync/mutex.rs", "status": "modified", "additions": 29, "deletions": 15, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/1a60dc4fc4b66760b71f1700cdb8b151cb8a67d9/src%2Flibstd%2Fsync%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a60dc4fc4b66760b71f1700cdb8b151cb8a67d9/src%2Flibstd%2Fsync%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Fmutex.rs?ref=1a60dc4fc4b66760b71f1700cdb8b151cb8a67d9", "patch": "@@ -112,7 +112,7 @@ use sys_common::poison::{self, TryLockError, TryLockResult, LockResult};\n /// *guard += 1;\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct Mutex<T> {\n+pub struct Mutex<T: ?Sized> {\n     // Note that this static mutex is in a *box*, not inlined into the struct\n     // itself. Once a native mutex has been used once, its address can never\n     // change (it can't be moved). This mutex type can be safely moved at any\n@@ -124,9 +124,9 @@ pub struct Mutex<T> {\n \n // these are the only places where `T: Send` matters; all other\n // functionality works fine on a single thread.\n-unsafe impl<T: Send> Send for Mutex<T> { }\n+unsafe impl<T: ?Sized + Send> Send for Mutex<T> { }\n \n-unsafe impl<T: Send> Sync for Mutex<T> { }\n+unsafe impl<T: ?Sized + Send> Sync for Mutex<T> { }\n \n /// The static mutex type is provided to allow for static allocation of mutexes.\n ///\n@@ -164,15 +164,15 @@ pub struct StaticMutex {\n /// `Deref` and `DerefMut` implementations\n #[must_use]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct MutexGuard<'a, T: 'a> {\n+pub struct MutexGuard<'a, T: ?Sized + 'a> {\n     // funny underscores due to how Deref/DerefMut currently work (they\n     // disregard field privacy).\n     __lock: &'a StaticMutex,\n     __data: &'a UnsafeCell<T>,\n     __poison: poison::Guard,\n }\n \n-impl<'a, T> !marker::Send for MutexGuard<'a, T> {}\n+impl<'a, T: ?Sized> !marker::Send for MutexGuard<'a, T> {}\n \n /// Static initialization of a mutex. This constant can be used to initialize\n /// other mutex constants.\n@@ -192,7 +192,9 @@ impl<T> Mutex<T> {\n             data: UnsafeCell::new(t),\n         }\n     }\n+}\n \n+impl<T: ?Sized> Mutex<T> {\n     /// Acquires a mutex, blocking the current task until it is able to do so.\n     ///\n     /// This function will block the local task until it is available to acquire\n@@ -245,7 +247,7 @@ impl<T> Mutex<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> Drop for Mutex<T> {\n+impl<T: ?Sized> Drop for Mutex<T> {\n     fn drop(&mut self) {\n         // This is actually safe b/c we know that there is no further usage of\n         // this mutex (it's up to the user to arrange for a mutex to get\n@@ -255,12 +257,12 @@ impl<T> Drop for Mutex<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: fmt::Debug + 'static> fmt::Debug for Mutex<T> {\n+impl<T: ?Sized + fmt::Debug + 'static> fmt::Debug for Mutex<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match self.try_lock() {\n-            Ok(guard) => write!(f, \"Mutex {{ data: {:?} }}\", *guard),\n+            Ok(guard) => write!(f, \"Mutex {{ data: {:?} }}\", &*guard),\n             Err(TryLockError::Poisoned(err)) => {\n-                write!(f, \"Mutex {{ data: Poisoned({:?}) }}\", **err.get_ref())\n+                write!(f, \"Mutex {{ data: Poisoned({:?}) }}\", &**err.get_ref())\n             },\n             Err(TryLockError::WouldBlock) => write!(f, \"Mutex {{ <locked> }}\")\n         }\n@@ -310,7 +312,7 @@ impl StaticMutex {\n     }\n }\n \n-impl<'mutex, T> MutexGuard<'mutex, T> {\n+impl<'mutex, T: ?Sized> MutexGuard<'mutex, T> {\n \n     fn new(lock: &'mutex StaticMutex, data: &'mutex UnsafeCell<T>)\n            -> LockResult<MutexGuard<'mutex, T>> {\n@@ -325,22 +327,22 @@ impl<'mutex, T> MutexGuard<'mutex, T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'mutex, T> Deref for MutexGuard<'mutex, T> {\n+impl<'mutex, T: ?Sized> Deref for MutexGuard<'mutex, T> {\n     type Target = T;\n \n     fn deref<'a>(&'a self) -> &'a T {\n         unsafe { &*self.__data.get() }\n     }\n }\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'mutex, T> DerefMut for MutexGuard<'mutex, T> {\n+impl<'mutex, T: ?Sized> DerefMut for MutexGuard<'mutex, T> {\n     fn deref_mut<'a>(&'a mut self) -> &'a mut T {\n         unsafe { &mut *self.__data.get() }\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T> Drop for MutexGuard<'a, T> {\n+impl<'a, T: ?Sized> Drop for MutexGuard<'a, T> {\n     #[inline]\n     fn drop(&mut self) {\n         unsafe {\n@@ -350,11 +352,11 @@ impl<'a, T> Drop for MutexGuard<'a, T> {\n     }\n }\n \n-pub fn guard_lock<'a, T>(guard: &MutexGuard<'a, T>) -> &'a sys::Mutex {\n+pub fn guard_lock<'a, T: ?Sized>(guard: &MutexGuard<'a, T>) -> &'a sys::Mutex {\n     &guard.__lock.lock\n }\n \n-pub fn guard_poison<'a, T>(guard: &MutexGuard<'a, T>) -> &'a poison::Flag {\n+pub fn guard_poison<'a, T: ?Sized>(guard: &MutexGuard<'a, T>) -> &'a poison::Flag {\n     &guard.__lock.poison\n }\n \n@@ -528,4 +530,16 @@ mod tests {\n         let lock = arc.lock().unwrap();\n         assert_eq!(*lock, 2);\n     }\n+\n+    #[test]\n+    fn test_mutex_unsized() {\n+        let mutex: &Mutex<[i32]> = &Mutex::new([1, 2, 3]);\n+        {\n+            let b = &mut *mutex.lock().unwrap();\n+            b[0] = 4;\n+            b[2] = 5;\n+        }\n+        let comp: &[i32] = &[4, 2, 5];\n+        assert_eq!(&*mutex.lock().unwrap(), comp);\n+    }\n }"}, {"sha": "9294fb64783bdee24914543ef23be674c13af90d", "filename": "src/libstd/sync/rwlock.rs", "status": "modified", "additions": 34, "deletions": 19, "changes": 53, "blob_url": "https://github.com/rust-lang/rust/blob/1a60dc4fc4b66760b71f1700cdb8b151cb8a67d9/src%2Flibstd%2Fsync%2Frwlock.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a60dc4fc4b66760b71f1700cdb8b151cb8a67d9/src%2Flibstd%2Fsync%2Frwlock.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fsync%2Frwlock.rs?ref=1a60dc4fc4b66760b71f1700cdb8b151cb8a67d9", "patch": "@@ -60,13 +60,13 @@ use sys_common::rwlock as sys;\n /// } // write lock is dropped here\n /// ```\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct RwLock<T> {\n+pub struct RwLock<T: ?Sized> {\n     inner: Box<StaticRwLock>,\n     data: UnsafeCell<T>,\n }\n \n-unsafe impl<T: Send + Sync> Send for RwLock<T> {}\n-unsafe impl<T: Send + Sync> Sync for RwLock<T> {}\n+unsafe impl<T: ?Sized + Send + Sync> Send for RwLock<T> {}\n+unsafe impl<T: ?Sized + Send + Sync> Sync for RwLock<T> {}\n \n /// Structure representing a statically allocated RwLock.\n ///\n@@ -111,24 +111,24 @@ pub const RW_LOCK_INIT: StaticRwLock = StaticRwLock {\n /// dropped.\n #[must_use]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct RwLockReadGuard<'a, T: 'a> {\n+pub struct RwLockReadGuard<'a, T: ?Sized + 'a> {\n     __lock: &'a StaticRwLock,\n     __data: &'a UnsafeCell<T>,\n }\n \n-impl<'a, T> !marker::Send for RwLockReadGuard<'a, T> {}\n+impl<'a, T: ?Sized> !marker::Send for RwLockReadGuard<'a, T> {}\n \n /// RAII structure used to release the exclusive write access of a lock when\n /// dropped.\n #[must_use]\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-pub struct RwLockWriteGuard<'a, T: 'a> {\n+pub struct RwLockWriteGuard<'a, T: ?Sized + 'a> {\n     __lock: &'a StaticRwLock,\n     __data: &'a UnsafeCell<T>,\n     __poison: poison::Guard,\n }\n \n-impl<'a, T> !marker::Send for RwLockWriteGuard<'a, T> {}\n+impl<'a, T: ?Sized> !marker::Send for RwLockWriteGuard<'a, T> {}\n \n impl<T> RwLock<T> {\n     /// Creates a new instance of an `RwLock<T>` which is unlocked.\n@@ -144,7 +144,9 @@ impl<T> RwLock<T> {\n     pub fn new(t: T) -> RwLock<T> {\n         RwLock { inner: box RW_LOCK_INIT, data: UnsafeCell::new(t) }\n     }\n+}\n \n+impl<T: ?Sized> RwLock<T> {\n     /// Locks this rwlock with shared read access, blocking the current thread\n     /// until it can be acquired.\n     ///\n@@ -250,19 +252,19 @@ impl<T> RwLock<T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T> Drop for RwLock<T> {\n+impl<T: ?Sized> Drop for RwLock<T> {\n     fn drop(&mut self) {\n         unsafe { self.inner.lock.destroy() }\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<T: fmt::Debug> fmt::Debug for RwLock<T> {\n+impl<T: ?Sized + fmt::Debug> fmt::Debug for RwLock<T> {\n     fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n         match self.try_read() {\n-            Ok(guard) => write!(f, \"RwLock {{ data: {:?} }}\", *guard),\n+            Ok(guard) => write!(f, \"RwLock {{ data: {:?} }}\", &*guard),\n             Err(TryLockError::Poisoned(err)) => {\n-                write!(f, \"RwLock {{ data: Poisoned({:?}) }}\", **err.get_ref())\n+                write!(f, \"RwLock {{ data: Poisoned({:?}) }}\", &**err.get_ref())\n             },\n             Err(TryLockError::WouldBlock) => write!(f, \"RwLock {{ <locked> }}\")\n         }\n@@ -341,8 +343,7 @@ impl StaticRwLock {\n     }\n }\n \n-impl<'rwlock, T> RwLockReadGuard<'rwlock, T> {\n-\n+impl<'rwlock, T: ?Sized> RwLockReadGuard<'rwlock, T> {\n     fn new(lock: &'rwlock StaticRwLock, data: &'rwlock UnsafeCell<T>)\n            -> LockResult<RwLockReadGuard<'rwlock, T>> {\n         poison::map_result(lock.poison.borrow(), |_| {\n@@ -353,8 +354,8 @@ impl<'rwlock, T> RwLockReadGuard<'rwlock, T> {\n         })\n     }\n }\n-impl<'rwlock, T> RwLockWriteGuard<'rwlock, T> {\n \n+impl<'rwlock, T: ?Sized> RwLockWriteGuard<'rwlock, T> {\n     fn new(lock: &'rwlock StaticRwLock, data: &'rwlock UnsafeCell<T>)\n            -> LockResult<RwLockWriteGuard<'rwlock, T>> {\n         poison::map_result(lock.poison.borrow(), |guard| {\n@@ -368,33 +369,35 @@ impl<'rwlock, T> RwLockWriteGuard<'rwlock, T> {\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'rwlock, T> Deref for RwLockReadGuard<'rwlock, T> {\n+impl<'rwlock, T: ?Sized> Deref for RwLockReadGuard<'rwlock, T> {\n     type Target = T;\n \n     fn deref(&self) -> &T { unsafe { &*self.__data.get() } }\n }\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'rwlock, T> Deref for RwLockWriteGuard<'rwlock, T> {\n+impl<'rwlock, T: ?Sized> Deref for RwLockWriteGuard<'rwlock, T> {\n     type Target = T;\n \n     fn deref(&self) -> &T { unsafe { &*self.__data.get() } }\n }\n+\n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'rwlock, T> DerefMut for RwLockWriteGuard<'rwlock, T> {\n+impl<'rwlock, T: ?Sized> DerefMut for RwLockWriteGuard<'rwlock, T> {\n     fn deref_mut(&mut self) -> &mut T {\n         unsafe { &mut *self.__data.get() }\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T> Drop for RwLockReadGuard<'a, T> {\n+impl<'a, T: ?Sized> Drop for RwLockReadGuard<'a, T> {\n     fn drop(&mut self) {\n         unsafe { self.__lock.lock.read_unlock(); }\n     }\n }\n \n #[stable(feature = \"rust1\", since = \"1.0.0\")]\n-impl<'a, T> Drop for RwLockWriteGuard<'a, T> {\n+impl<'a, T: ?Sized> Drop for RwLockWriteGuard<'a, T> {\n     fn drop(&mut self) {\n         self.__lock.poison.done(&self.__poison);\n         unsafe { self.__lock.lock.write_unlock(); }\n@@ -562,4 +565,16 @@ mod tests {\n         let lock = arc.read().unwrap();\n         assert_eq!(*lock, 2);\n     }\n+\n+    #[test]\n+    fn test_rwlock_unsized() {\n+        let rw: &RwLock<[i32]> = &RwLock::new([1, 2, 3]);\n+        {\n+            let b = &mut *rw.write().unwrap();\n+            b[0] = 4;\n+            b[2] = 5;\n+        }\n+        let comp: &[i32] = &[4, 2, 5];\n+        assert_eq!(&*rw.read().unwrap(), comp);\n+    }\n }"}, {"sha": "8c13ff70515313a63ed79e9a1371d8563fe12fbe", "filename": "src/test/compile-fail/bad-sized.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/1a60dc4fc4b66760b71f1700cdb8b151cb8a67d9/src%2Ftest%2Fcompile-fail%2Fbad-sized.rs", "raw_url": "https://github.com/rust-lang/rust/raw/1a60dc4fc4b66760b71f1700cdb8b151cb8a67d9/src%2Ftest%2Fcompile-fail%2Fbad-sized.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcompile-fail%2Fbad-sized.rs?ref=1a60dc4fc4b66760b71f1700cdb8b151cb8a67d9", "patch": "@@ -8,14 +8,10 @@\n // option. This file may not be copied, modified, or distributed\n // except according to those terms.\n \n-use std::cell::RefCell;\n-\n trait Trait {}\n \n pub fn main() {\n     let x: Vec<Trait + Sized> = Vec::new();\n     //~^ ERROR the trait `core::marker::Sized` is not implemented\n     //~^^ ERROR the trait `core::marker::Sized` is not implemented\n-    let x: Vec<Box<RefCell<Trait + Sized>>> = Vec::new();\n-    //~^ ERROR the trait `core::marker::Sized` is not implemented\n }"}]}