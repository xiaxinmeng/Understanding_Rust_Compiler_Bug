{"sha": "21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "node_id": "C_kwDOAAsO6NoAKDIxZTVkYzJhZjk4NmQyZWNjYjlkN2NhYTc0NDU1YTQ4YjI2YzdhZTY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-25T12:04:16Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-05-25T12:04:16Z"}, "message": "Auto merge of #14881 - Veykril:name-display, r=Veykril\n\ninternal: Replace Display impl for Name\n\nThis allows us to plug in interner for `Name`s that live inside the database.", "tree": {"sha": "42586121527558a355f5991ef033cf5319defcd9", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/42586121527558a355f5991ef033cf5319defcd9"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "html_url": "https://github.com/rust-lang/rust/commit/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "a512774fd97ba8645fd7bc123b179f40a76017b2", "url": "https://api.github.com/repos/rust-lang/rust/commits/a512774fd97ba8645fd7bc123b179f40a76017b2", "html_url": "https://github.com/rust-lang/rust/commit/a512774fd97ba8645fd7bc123b179f40a76017b2"}, {"sha": "c7ef6c25b7c2a41f0fef8b9de5827b7b074586bd", "url": "https://api.github.com/repos/rust-lang/rust/commits/c7ef6c25b7c2a41f0fef8b9de5827b7b074586bd", "html_url": "https://github.com/rust-lang/rust/commit/c7ef6c25b7c2a41f0fef8b9de5827b7b074586bd"}], "stats": {"total": 1697, "additions": 1043, "deletions": 654}, "files": [{"sha": "7390a8f1f2b188fff84d5f8105d9e8fde37d7bb0", "filename": "crates/hir-def/src/body/pretty.rs", "status": "modified", "additions": 30, "deletions": 20, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fhir-def%2Fsrc%2Fbody%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fhir-def%2Fsrc%2Fbody%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbody%2Fpretty.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -2,6 +2,7 @@\n \n use std::fmt::{self, Write};\n \n+use hir_expand::db::ExpandDatabase;\n use syntax::ast::HasName;\n \n use crate::{\n@@ -18,16 +19,22 @@ pub(super) fn print_body_hir(db: &dyn DefDatabase, body: &Body, owner: DefWithBo\n     let header = match owner {\n         DefWithBodyId::FunctionId(it) => {\n             let item_tree_id = it.lookup(db).id;\n-            format!(\"fn {}\", item_tree_id.item_tree(db)[item_tree_id.value].name)\n+            format!(\n+                \"fn {}\",\n+                item_tree_id.item_tree(db)[item_tree_id.value].name.display(db.upcast())\n+            )\n         }\n         DefWithBodyId::StaticId(it) => {\n             let item_tree_id = it.lookup(db).id;\n-            format!(\"static {} = \", item_tree_id.item_tree(db)[item_tree_id.value].name)\n+            format!(\n+                \"static {} = \",\n+                item_tree_id.item_tree(db)[item_tree_id.value].name.display(db.upcast())\n+            )\n         }\n         DefWithBodyId::ConstId(it) => {\n             let item_tree_id = it.lookup(db).id;\n             let name = match &item_tree_id.item_tree(db)[item_tree_id.value].name {\n-                Some(name) => name.to_string(),\n+                Some(name) => name.display(db.upcast()).to_string(),\n                 None => \"_\".to_string(),\n             };\n             format!(\"const {name} = \")\n@@ -42,7 +49,8 @@ pub(super) fn print_body_hir(db: &dyn DefDatabase, body: &Body, owner: DefWithBo\n         }\n     };\n \n-    let mut p = Printer { body, buf: header, indent_level: 0, needs_indent: false };\n+    let mut p =\n+        Printer { db: db.upcast(), body, buf: header, indent_level: 0, needs_indent: false };\n     if let DefWithBodyId::FunctionId(it) = owner {\n         p.buf.push('(');\n         body.params.iter().zip(&db.function_data(it).params).for_each(|(&param, ty)| {\n@@ -61,12 +69,13 @@ pub(super) fn print_body_hir(db: &dyn DefDatabase, body: &Body, owner: DefWithBo\n }\n \n pub(super) fn print_expr_hir(\n-    _db: &dyn DefDatabase,\n+    db: &dyn DefDatabase,\n     body: &Body,\n     _owner: DefWithBodyId,\n     expr: ExprId,\n ) -> String {\n-    let mut p = Printer { body, buf: String::new(), indent_level: 0, needs_indent: false };\n+    let mut p =\n+        Printer { db: db.upcast(), body, buf: String::new(), indent_level: 0, needs_indent: false };\n     p.print_expr(expr);\n     p.buf\n }\n@@ -87,6 +96,7 @@ macro_rules! wln {\n }\n \n struct Printer<'a> {\n+    db: &'a dyn ExpandDatabase,\n     body: &'a Body,\n     buf: String,\n     indent_level: usize,\n@@ -161,22 +171,22 @@ impl<'a> Printer<'a> {\n             }\n             Expr::Loop { body, label } => {\n                 if let Some(lbl) = label {\n-                    w!(self, \"{}: \", self.body[*lbl].name);\n+                    w!(self, \"{}: \", self.body[*lbl].name.display(self.db));\n                 }\n                 w!(self, \"loop \");\n                 self.print_expr(*body);\n             }\n             Expr::While { condition, body, label } => {\n                 if let Some(lbl) = label {\n-                    w!(self, \"{}: \", self.body[*lbl].name);\n+                    w!(self, \"{}: \", self.body[*lbl].name.display(self.db));\n                 }\n                 w!(self, \"while \");\n                 self.print_expr(*condition);\n                 self.print_expr(*body);\n             }\n             Expr::For { iterable, pat, body, label } => {\n                 if let Some(lbl) = label {\n-                    w!(self, \"{}: \", self.body[*lbl].name);\n+                    w!(self, \"{}: \", self.body[*lbl].name.display(self.db));\n                 }\n                 w!(self, \"for \");\n                 self.print_pat(*pat);\n@@ -199,10 +209,10 @@ impl<'a> Printer<'a> {\n             }\n             Expr::MethodCall { receiver, method_name, args, generic_args } => {\n                 self.print_expr(*receiver);\n-                w!(self, \".{}\", method_name);\n+                w!(self, \".{}\", method_name.display(self.db));\n                 if let Some(args) = generic_args {\n                     w!(self, \"::<\");\n-                    print_generic_args(args, self).unwrap();\n+                    print_generic_args(self.db, args, self).unwrap();\n                     w!(self, \">\");\n                 }\n                 w!(self, \"(\");\n@@ -237,13 +247,13 @@ impl<'a> Printer<'a> {\n             Expr::Continue { label } => {\n                 w!(self, \"continue\");\n                 if let Some(lbl) = label {\n-                    w!(self, \" {}\", self.body[*lbl].name);\n+                    w!(self, \" {}\", self.body[*lbl].name.display(self.db));\n                 }\n             }\n             Expr::Break { expr, label } => {\n                 w!(self, \"break\");\n                 if let Some(lbl) = label {\n-                    w!(self, \" {}\", self.body[*lbl].name);\n+                    w!(self, \" {}\", self.body[*lbl].name.display(self.db));\n                 }\n                 if let Some(expr) = expr {\n                     self.whitespace();\n@@ -282,7 +292,7 @@ impl<'a> Printer<'a> {\n                 w!(self, \"{{\");\n                 self.indented(|p| {\n                     for field in &**fields {\n-                        w!(p, \"{}: \", field.name);\n+                        w!(p, \"{}: \", field.name.display(self.db));\n                         p.print_expr(field.expr);\n                         wln!(p, \",\");\n                     }\n@@ -299,7 +309,7 @@ impl<'a> Printer<'a> {\n             }\n             Expr::Field { expr, name } => {\n                 self.print_expr(*expr);\n-                w!(self, \".{}\", name);\n+                w!(self, \".{}\", name.display(self.db));\n             }\n             Expr::Await { expr } => {\n                 self.print_expr(*expr);\n@@ -437,7 +447,7 @@ impl<'a> Printer<'a> {\n             }\n             Expr::Literal(lit) => self.print_literal(lit),\n             Expr::Block { id: _, statements, tail, label } => {\n-                let label = label.map(|lbl| format!(\"{}: \", self.body[lbl].name));\n+                let label = label.map(|lbl| format!(\"{}: \", self.body[lbl].name.display(self.db)));\n                 self.print_block(label.as_deref(), statements, tail);\n             }\n             Expr::Unsafe { id: _, statements, tail } => {\n@@ -513,7 +523,7 @@ impl<'a> Printer<'a> {\n                 w!(self, \" {{\");\n                 self.indented(|p| {\n                     for arg in args.iter() {\n-                        w!(p, \"{}: \", arg.name);\n+                        w!(p, \"{}: \", arg.name.display(self.db));\n                         p.print_pat(arg.pat);\n                         wln!(p, \",\");\n                     }\n@@ -646,11 +656,11 @@ impl<'a> Printer<'a> {\n     }\n \n     fn print_type_ref(&mut self, ty: &TypeRef) {\n-        print_type_ref(ty, self).unwrap();\n+        print_type_ref(self.db, ty, self).unwrap();\n     }\n \n     fn print_path(&mut self, path: &Path) {\n-        print_path(path, self).unwrap();\n+        print_path(self.db, path, self).unwrap();\n     }\n \n     fn print_binding(&mut self, id: BindingId) {\n@@ -661,6 +671,6 @@ impl<'a> Printer<'a> {\n             BindingAnnotation::Ref => \"ref \",\n             BindingAnnotation::RefMut => \"ref mut \",\n         };\n-        w!(self, \"{}{}\", mode, name);\n+        w!(self, \"{}{}\", mode, name.display(self.db));\n     }\n }"}, {"sha": "61b2481978e2711f3587328cdeae18021b8e56fa", "filename": "crates/hir-def/src/builtin_type.rs", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fhir-def%2Fsrc%2Fbuiltin_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fhir-def%2Fsrc%2Fbuiltin_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fbuiltin_type.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -106,8 +106,14 @@ impl AsName for BuiltinType {\n \n impl fmt::Display for BuiltinType {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        let type_name = self.as_name();\n-        type_name.fmt(f)\n+        match self {\n+            BuiltinType::Char => f.write_str(\"char\"),\n+            BuiltinType::Bool => f.write_str(\"bool\"),\n+            BuiltinType::Str => f.write_str(\"str\"),\n+            BuiltinType::Int(it) => it.fmt(f),\n+            BuiltinType::Uint(it) => it.fmt(f),\n+            BuiltinType::Float(it) => it.fmt(f),\n+        }\n     }\n }\n "}, {"sha": "0573c9a6f8af411d64f5ae7dcf4ee874a0b890a4", "filename": "crates/hir-def/src/hir/type_ref.rs", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fhir-def%2Fsrc%2Fhir%2Ftype_ref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fhir-def%2Fsrc%2Fhir%2Ftype_ref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fhir%2Ftype_ref.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -1,9 +1,11 @@\n //! HIR for references to types. Paths in these are not yet resolved. They can\n //! be directly created from an ast::TypeRef, without further queries.\n \n+use core::fmt;\n use std::fmt::Write;\n \n use hir_expand::{\n+    db::ExpandDatabase,\n     name::{AsName, Name},\n     AstId,\n };\n@@ -383,15 +385,6 @@ pub enum ConstRefOrPath {\n     Path(Name),\n }\n \n-impl std::fmt::Display for ConstRefOrPath {\n-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n-        match self {\n-            ConstRefOrPath::Scalar(s) => s.fmt(f),\n-            ConstRefOrPath::Path(n) => n.fmt(f),\n-        }\n-    }\n-}\n-\n impl ConstRefOrPath {\n     pub(crate) fn from_expr_opt(expr: Option<ast::Expr>) -> Self {\n         match expr {\n@@ -400,6 +393,19 @@ impl ConstRefOrPath {\n         }\n     }\n \n+    pub fn display<'a>(&'a self, db: &'a dyn ExpandDatabase) -> impl fmt::Display + 'a {\n+        struct Display<'a>(&'a dyn ExpandDatabase, &'a ConstRefOrPath);\n+        impl fmt::Display for Display<'_> {\n+            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+                match self.1 {\n+                    ConstRefOrPath::Scalar(s) => s.fmt(f),\n+                    ConstRefOrPath::Path(n) => n.display(self.0).fmt(f),\n+                }\n+            }\n+        }\n+        Display(db, self)\n+    }\n+\n     // FIXME: as per the comments on `TypeRef::Array`, this evaluation should not happen at this\n     // parse stage.\n     fn from_expr(expr: ast::Expr) -> Self {"}, {"sha": "6ef2949ef51a198974fe3adf51b845177c2e2937", "filename": "crates/hir-def/src/import_map.rs", "status": "modified", "additions": 62, "deletions": 25, "changes": 87, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fhir-def%2Fsrc%2Fimport_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fhir-def%2Fsrc%2Fimport_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fimport_map.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -33,13 +33,23 @@ pub struct ImportPath {\n     pub segments: Vec<Name>,\n }\n \n-impl fmt::Display for ImportPath {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        fmt::Display::fmt(&self.segments.iter().format(\"::\"), f)\n+impl ImportPath {\n+    pub fn display<'a>(&'a self, db: &'a dyn DefDatabase) -> impl fmt::Display + 'a {\n+        struct Display<'a> {\n+            db: &'a dyn DefDatabase,\n+            path: &'a ImportPath,\n+        }\n+        impl fmt::Display for Display<'_> {\n+            fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+                fmt::Display::fmt(\n+                    &self.path.segments.iter().map(|it| it.display(self.db.upcast())).format(\"::\"),\n+                    f,\n+                )\n+            }\n+        }\n+        Display { db, path: self }\n     }\n-}\n \n-impl ImportPath {\n     fn len(&self) -> usize {\n         self.segments.len()\n     }\n@@ -76,7 +86,7 @@ impl ImportMap {\n         let mut importables = import_map\n             .map\n             .iter()\n-            .map(|(item, info)| (item, fst_path(&info.path)))\n+            .map(|(item, info)| (item, fst_path(db, &info.path)))\n             .collect::<Vec<_>>();\n         importables.sort_by(|(_, fst_path), (_, fst_path2)| fst_path.cmp(fst_path2));\n \n@@ -113,6 +123,25 @@ impl ImportMap {\n         self.map.get(&item)\n     }\n \n+    #[cfg(test)]\n+    fn fmt_for_test(&self, db: &dyn DefDatabase) -> String {\n+        let mut importable_paths: Vec<_> = self\n+            .map\n+            .iter()\n+            .map(|(item, info)| {\n+                let ns = match item {\n+                    ItemInNs::Types(_) => \"t\",\n+                    ItemInNs::Values(_) => \"v\",\n+                    ItemInNs::Macros(_) => \"m\",\n+                };\n+                format!(\"- {} ({ns})\", info.path.display(db))\n+            })\n+            .collect();\n+\n+        importable_paths.sort();\n+        importable_paths.join(\"\\n\")\n+    }\n+\n     fn collect_trait_assoc_items(\n         &mut self,\n         db: &dyn DefDatabase,\n@@ -238,13 +267,10 @@ impl fmt::Debug for ImportMap {\n         let mut importable_paths: Vec<_> = self\n             .map\n             .iter()\n-            .map(|(item, info)| {\n-                let ns = match item {\n-                    ItemInNs::Types(_) => \"t\",\n-                    ItemInNs::Values(_) => \"v\",\n-                    ItemInNs::Macros(_) => \"m\",\n-                };\n-                format!(\"- {} ({ns})\", info.path)\n+            .map(|(item, _)| match item {\n+                ItemInNs::Types(it) => format!(\"- {it:?} (t)\",),\n+                ItemInNs::Values(it) => format!(\"- {it:?} (v)\",),\n+                ItemInNs::Macros(it) => format!(\"- {it:?} (m)\",),\n             })\n             .collect();\n \n@@ -253,9 +279,9 @@ impl fmt::Debug for ImportMap {\n     }\n }\n \n-fn fst_path(path: &ImportPath) -> String {\n+fn fst_path(db: &dyn DefDatabase, path: &ImportPath) -> String {\n     let _p = profile::span(\"fst_path\");\n-    let mut s = path.to_string();\n+    let mut s = path.display(db).to_string();\n     s.make_ascii_lowercase();\n     s\n }\n@@ -348,7 +374,12 @@ impl Query {\n         self\n     }\n \n-    fn import_matches(&self, import: &ImportInfo, enforce_lowercase: bool) -> bool {\n+    fn import_matches(\n+        &self,\n+        db: &dyn DefDatabase,\n+        import: &ImportInfo,\n+        enforce_lowercase: bool,\n+    ) -> bool {\n         let _p = profile::span(\"import_map::Query::import_matches\");\n         if import.is_trait_assoc_item {\n             if self.exclude_import_kinds.contains(&ImportKind::AssociatedItem) {\n@@ -359,9 +390,9 @@ impl Query {\n         }\n \n         let mut input = if import.is_trait_assoc_item || self.name_only {\n-            import.path.segments.last().unwrap().to_string()\n+            import.path.segments.last().unwrap().display(db.upcast()).to_string()\n         } else {\n-            import.path.to_string()\n+            import.path.display(db).to_string()\n         };\n         if enforce_lowercase || !self.case_sensitive {\n             input.make_ascii_lowercase();\n@@ -426,25 +457,27 @@ pub fn search_dependencies(\n         let importables = &import_map.importables[indexed_value.value as usize..];\n \n         let common_importable_data = &import_map.map[&importables[0]];\n-        if !query.import_matches(common_importable_data, true) {\n+        if !query.import_matches(db, common_importable_data, true) {\n             continue;\n         }\n \n         // Path shared by the importable items in this group.\n-        let common_importables_path_fst = fst_path(&common_importable_data.path);\n+        let common_importables_path_fst = fst_path(db, &common_importable_data.path);\n         // Add the items from this `ModPath` group. Those are all subsequent items in\n         // `importables` whose paths match `path`.\n         let iter = importables\n             .iter()\n             .copied()\n-            .take_while(|item| common_importables_path_fst == fst_path(&import_map.map[item].path))\n+            .take_while(|item| {\n+                common_importables_path_fst == fst_path(db, &import_map.map[item].path)\n+            })\n             .filter(|&item| match item_import_kind(item) {\n                 Some(import_kind) => !query.exclude_import_kinds.contains(&import_kind),\n                 None => true,\n             })\n             .filter(|item| {\n                 !query.case_sensitive // we've already checked the common importables path case-insensitively\n-                        || query.import_matches(&import_map.map[item], false)\n+                        || query.import_matches(db, &import_map.map[item], false)\n             });\n         res.extend(iter);\n \n@@ -501,7 +534,7 @@ mod tests {\n                 let (path, mark) = match assoc_item_path(&db, &dependency_imports, dependency) {\n                     Some(assoc_item_path) => (assoc_item_path, \"a\"),\n                     None => (\n-                        dependency_imports.path_of(dependency)?.to_string(),\n+                        dependency_imports.path_of(dependency)?.display(&db).to_string(),\n                         match dependency {\n                             ItemInNs::Types(ModuleDefId::FunctionId(_))\n                             | ItemInNs::Values(ModuleDefId::FunctionId(_)) => \"f\",\n@@ -552,7 +585,11 @@ mod tests {\n                         None\n                     }\n                 })?;\n-            return Some(format!(\"{}::{assoc_item_name}\", dependency_imports.path_of(trait_)?));\n+            return Some(format!(\n+                \"{}::{}\",\n+                dependency_imports.path_of(trait_)?.display(db),\n+                assoc_item_name.display(db.upcast())\n+            ));\n         }\n         None\n     }\n@@ -592,7 +629,7 @@ mod tests {\n \n                 let map = db.import_map(krate);\n \n-                Some(format!(\"{name}:\\n{map:?}\\n\"))\n+                Some(format!(\"{name}:\\n{}\\n\", map.fmt_for_test(db.upcast())))\n             })\n             .sorted()\n             .collect::<String>();"}, {"sha": "3ed321d189d3652a66c92a5a49620bb4e116dc9c", "filename": "crates/hir-def/src/item_scope.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fhir-def%2Fsrc%2Fitem_scope.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fhir-def%2Fsrc%2Fitem_scope.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fitem_scope.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -4,7 +4,7 @@\n use std::collections::hash_map::Entry;\n \n use base_db::CrateId;\n-use hir_expand::{attrs::AttrId, name::Name, AstId, MacroCallId};\n+use hir_expand::{attrs::AttrId, db::ExpandDatabase, name::Name, AstId, MacroCallId};\n use itertools::Itertools;\n use once_cell::sync::Lazy;\n use profile::Count;\n@@ -358,12 +358,16 @@ impl ItemScope {\n         }\n     }\n \n-    pub(crate) fn dump(&self, buf: &mut String) {\n+    pub(crate) fn dump(&self, db: &dyn ExpandDatabase, buf: &mut String) {\n         let mut entries: Vec<_> = self.resolutions().collect();\n         entries.sort_by_key(|(name, _)| name.clone());\n \n         for (name, def) in entries {\n-            format_to!(buf, \"{}:\", name.map_or(\"_\".to_string(), |name| name.to_string()));\n+            format_to!(\n+                buf,\n+                \"{}:\",\n+                name.map_or(\"_\".to_string(), |name| name.display(db).to_string())\n+            );\n \n             if def.types.is_some() {\n                 buf.push_str(\" t\");"}, {"sha": "590ed64af5d802e95f67dc8221edbd4117d82449", "filename": "crates/hir-def/src/item_tree.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fhir-def%2Fsrc%2Fitem_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fhir-def%2Fsrc%2Fitem_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fitem_tree.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -167,8 +167,8 @@ impl ItemTree {\n         Attrs::filter(db, krate, self.raw_attrs(of).clone())\n     }\n \n-    pub fn pretty_print(&self) -> String {\n-        pretty::print_item_tree(self)\n+    pub fn pretty_print(&self, db: &dyn DefDatabase) -> String {\n+        pretty::print_item_tree(db.upcast(), self)\n     }\n \n     fn data(&self) -> &ItemTreeData {"}, {"sha": "e873316a578c074fd9dbe9006c538542a56d2368", "filename": "crates/hir-def/src/item_tree/pretty.rs", "status": "modified", "additions": 41, "deletions": 33, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fhir-def%2Fsrc%2Fitem_tree%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fhir-def%2Fsrc%2Fitem_tree%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fitem_tree%2Fpretty.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -2,6 +2,8 @@\n \n use std::fmt::{self, Write};\n \n+use hir_expand::db::ExpandDatabase;\n+\n use crate::{\n     generics::{TypeOrConstParamData, WherePredicate, WherePredicateTypeTarget},\n     pretty::{print_path, print_type_bounds, print_type_ref},\n@@ -10,8 +12,8 @@ use crate::{\n \n use super::*;\n \n-pub(super) fn print_item_tree(tree: &ItemTree) -> String {\n-    let mut p = Printer { tree, buf: String::new(), indent_level: 0, needs_indent: true };\n+pub(super) fn print_item_tree(db: &dyn ExpandDatabase, tree: &ItemTree) -> String {\n+    let mut p = Printer { db, tree, buf: String::new(), indent_level: 0, needs_indent: true };\n \n     if let Some(attrs) = tree.attrs.get(&AttrOwner::TopLevel) {\n         p.print_attrs(attrs, true);\n@@ -43,6 +45,7 @@ macro_rules! wln {\n }\n \n struct Printer<'a> {\n+    db: &'a dyn ExpandDatabase,\n     tree: &'a ItemTree,\n     buf: String,\n     indent_level: usize,\n@@ -88,7 +91,7 @@ impl<'a> Printer<'a> {\n                 self,\n                 \"#{}[{}{}]\",\n                 inner,\n-                attr.path,\n+                attr.path.display(self.db),\n                 attr.input.as_ref().map(|it| it.to_string()).unwrap_or_default(),\n             );\n         }\n@@ -102,7 +105,7 @@ impl<'a> Printer<'a> {\n \n     fn print_visibility(&mut self, vis: RawVisibilityId) {\n         match &self.tree[vis] {\n-            RawVisibility::Module(path) => w!(self, \"pub({}) \", path),\n+            RawVisibility::Module(path) => w!(self, \"pub({}) \", path.display(self.db)),\n             RawVisibility::Public => w!(self, \"pub \"),\n         };\n     }\n@@ -117,7 +120,7 @@ impl<'a> Printer<'a> {\n                         let Field { visibility, name, type_ref, ast_id: _ } = &this.tree[field];\n                         this.print_attrs_of(field);\n                         this.print_visibility(*visibility);\n-                        w!(this, \"{}: \", name);\n+                        w!(this, \"{}: \", name.display(self.db));\n                         this.print_type_ref(type_ref);\n                         wln!(this, \",\");\n                     }\n@@ -131,7 +134,7 @@ impl<'a> Printer<'a> {\n                         let Field { visibility, name, type_ref, ast_id: _ } = &this.tree[field];\n                         this.print_attrs_of(field);\n                         this.print_visibility(*visibility);\n-                        w!(this, \"{}: \", name);\n+                        w!(this, \"{}: \", name.display(self.db));\n                         this.print_type_ref(type_ref);\n                         wln!(this, \",\");\n                     }\n@@ -164,20 +167,20 @@ impl<'a> Printer<'a> {\n     fn print_use_tree(&mut self, use_tree: &UseTree) {\n         match &use_tree.kind {\n             UseTreeKind::Single { path, alias } => {\n-                w!(self, \"{}\", path);\n+                w!(self, \"{}\", path.display(self.db));\n                 if let Some(alias) = alias {\n                     w!(self, \" as {}\", alias);\n                 }\n             }\n             UseTreeKind::Glob { path } => {\n                 if let Some(path) = path {\n-                    w!(self, \"{}::\", path);\n+                    w!(self, \"{}::\", path.display(self.db));\n                 }\n                 w!(self, \"*\");\n             }\n             UseTreeKind::Prefixed { prefix, list } => {\n                 if let Some(prefix) = prefix {\n-                    w!(self, \"{}::\", prefix);\n+                    w!(self, \"{}::\", prefix.display(self.db));\n                 }\n                 w!(self, \"{{\");\n                 for (i, tree) in list.iter().enumerate() {\n@@ -205,7 +208,7 @@ impl<'a> Printer<'a> {\n             ModItem::ExternCrate(it) => {\n                 let ExternCrate { name, alias, visibility, ast_id: _ } = &self.tree[it];\n                 self.print_visibility(*visibility);\n-                w!(self, \"extern crate {}\", name);\n+                w!(self, \"extern crate {}\", name.display(self.db));\n                 if let Some(alias) = alias {\n                     w!(self, \" as {}\", alias);\n                 }\n@@ -252,7 +255,7 @@ impl<'a> Printer<'a> {\n                 if let Some(abi) = abi {\n                     w!(self, \"extern \\\"{}\\\" \", abi);\n                 }\n-                w!(self, \"fn {}\", name);\n+                w!(self, \"fn {}\", name.display(self.db));\n                 self.print_generic_params(explicit_generic_params);\n                 w!(self, \"(\");\n                 if !params.is_empty() {\n@@ -286,7 +289,7 @@ impl<'a> Printer<'a> {\n             ModItem::Struct(it) => {\n                 let Struct { visibility, name, fields, generic_params, ast_id: _ } = &self.tree[it];\n                 self.print_visibility(*visibility);\n-                w!(self, \"struct {}\", name);\n+                w!(self, \"struct {}\", name.display(self.db));\n                 self.print_generic_params(generic_params);\n                 self.print_fields_and_where_clause(fields, generic_params);\n                 if matches!(fields, Fields::Record(_)) {\n@@ -298,7 +301,7 @@ impl<'a> Printer<'a> {\n             ModItem::Union(it) => {\n                 let Union { name, visibility, fields, generic_params, ast_id: _ } = &self.tree[it];\n                 self.print_visibility(*visibility);\n-                w!(self, \"union {}\", name);\n+                w!(self, \"union {}\", name.display(self.db));\n                 self.print_generic_params(generic_params);\n                 self.print_fields_and_where_clause(fields, generic_params);\n                 if matches!(fields, Fields::Record(_)) {\n@@ -310,14 +313,14 @@ impl<'a> Printer<'a> {\n             ModItem::Enum(it) => {\n                 let Enum { name, visibility, variants, generic_params, ast_id: _ } = &self.tree[it];\n                 self.print_visibility(*visibility);\n-                w!(self, \"enum {}\", name);\n+                w!(self, \"enum {}\", name.display(self.db));\n                 self.print_generic_params(generic_params);\n                 self.print_where_clause_and_opening_brace(generic_params);\n                 self.indented(|this| {\n                     for variant in variants.clone() {\n                         let Variant { name, fields, ast_id: _ } = &this.tree[variant];\n                         this.print_attrs_of(variant);\n-                        w!(this, \"{}\", name);\n+                        w!(this, \"{}\", name.display(self.db));\n                         this.print_fields(fields);\n                         wln!(this, \",\");\n                     }\n@@ -329,7 +332,7 @@ impl<'a> Printer<'a> {\n                 self.print_visibility(*visibility);\n                 w!(self, \"const \");\n                 match name {\n-                    Some(name) => w!(self, \"{}\", name),\n+                    Some(name) => w!(self, \"{}\", name.display(self.db)),\n                     None => w!(self, \"_\"),\n                 }\n                 w!(self, \": \");\n@@ -343,7 +346,7 @@ impl<'a> Printer<'a> {\n                 if *mutable {\n                     w!(self, \"mut \");\n                 }\n-                w!(self, \"{}: \", name);\n+                w!(self, \"{}: \", name.display(self.db));\n                 self.print_type_ref(type_ref);\n                 w!(self, \" = _;\");\n                 wln!(self);\n@@ -365,7 +368,7 @@ impl<'a> Printer<'a> {\n                 if *is_auto {\n                     w!(self, \"auto \");\n                 }\n-                w!(self, \"trait {}\", name);\n+                w!(self, \"trait {}\", name.display(self.db));\n                 self.print_generic_params(generic_params);\n                 self.print_where_clause_and_opening_brace(generic_params);\n                 self.indented(|this| {\n@@ -378,7 +381,7 @@ impl<'a> Printer<'a> {\n             ModItem::TraitAlias(it) => {\n                 let TraitAlias { name, visibility, generic_params, ast_id: _ } = &self.tree[it];\n                 self.print_visibility(*visibility);\n-                w!(self, \"trait {}\", name);\n+                w!(self, \"trait {}\", name.display(self.db));\n                 self.print_generic_params(generic_params);\n                 w!(self, \" = \");\n                 self.print_where_clause(generic_params);\n@@ -411,7 +414,7 @@ impl<'a> Printer<'a> {\n                 let TypeAlias { name, visibility, bounds, type_ref, generic_params, ast_id: _ } =\n                     &self.tree[it];\n                 self.print_visibility(*visibility);\n-                w!(self, \"type {}\", name);\n+                w!(self, \"type {}\", name.display(self.db));\n                 self.print_generic_params(generic_params);\n                 if !bounds.is_empty() {\n                     w!(self, \": \");\n@@ -428,7 +431,7 @@ impl<'a> Printer<'a> {\n             ModItem::Mod(it) => {\n                 let Mod { name, visibility, kind, ast_id: _ } = &self.tree[it];\n                 self.print_visibility(*visibility);\n-                w!(self, \"mod {}\", name);\n+                w!(self, \"mod {}\", name.display(self.db));\n                 match kind {\n                     ModKind::Inline { items } => {\n                         w!(self, \" {{\");\n@@ -446,32 +449,32 @@ impl<'a> Printer<'a> {\n             }\n             ModItem::MacroCall(it) => {\n                 let MacroCall { path, ast_id: _, expand_to: _ } = &self.tree[it];\n-                wln!(self, \"{}!(...);\", path);\n+                wln!(self, \"{}!(...);\", path.display(self.db));\n             }\n             ModItem::MacroRules(it) => {\n                 let MacroRules { name, ast_id: _ } = &self.tree[it];\n-                wln!(self, \"macro_rules! {} {{ ... }}\", name);\n+                wln!(self, \"macro_rules! {} {{ ... }}\", name.display(self.db));\n             }\n             ModItem::MacroDef(it) => {\n                 let MacroDef { name, visibility, ast_id: _ } = &self.tree[it];\n                 self.print_visibility(*visibility);\n-                wln!(self, \"macro {} {{ ... }}\", name);\n+                wln!(self, \"macro {} {{ ... }}\", name.display(self.db));\n             }\n         }\n \n         self.blank();\n     }\n \n     fn print_type_ref(&mut self, type_ref: &TypeRef) {\n-        print_type_ref(type_ref, self).unwrap();\n+        print_type_ref(self.db, type_ref, self).unwrap();\n     }\n \n     fn print_type_bounds(&mut self, bounds: &[Interned<TypeBound>]) {\n-        print_type_bounds(bounds, self).unwrap();\n+        print_type_bounds(self.db, bounds, self).unwrap();\n     }\n \n     fn print_path(&mut self, path: &Path) {\n-        print_path(path, self).unwrap();\n+        print_path(self.db, path, self).unwrap();\n     }\n \n     fn print_generic_params(&mut self, params: &GenericParams) {\n@@ -486,7 +489,7 @@ impl<'a> Printer<'a> {\n                 w!(self, \", \");\n             }\n             first = false;\n-            w!(self, \"{}\", lt.name);\n+            w!(self, \"{}\", lt.name.display(self.db));\n         }\n         for (idx, x) in params.type_or_consts.iter() {\n             if !first {\n@@ -495,11 +498,11 @@ impl<'a> Printer<'a> {\n             first = false;\n             match x {\n                 TypeOrConstParamData::TypeParamData(ty) => match &ty.name {\n-                    Some(name) => w!(self, \"{}\", name),\n+                    Some(name) => w!(self, \"{}\", name.display(self.db)),\n                     None => w!(self, \"_anon_{}\", idx.into_raw()),\n                 },\n                 TypeOrConstParamData::ConstParamData(konst) => {\n-                    w!(self, \"const {}: \", konst.name);\n+                    w!(self, \"const {}: \", konst.name.display(self.db));\n                     self.print_type_ref(&konst.ty);\n                 }\n             }\n@@ -531,7 +534,12 @@ impl<'a> Printer<'a> {\n                 let (target, bound) = match pred {\n                     WherePredicate::TypeBound { target, bound } => (target, bound),\n                     WherePredicate::Lifetime { target, bound } => {\n-                        wln!(this, \"{}: {},\", target.name, bound.name);\n+                        wln!(\n+                            this,\n+                            \"{}: {},\",\n+                            target.name.display(self.db),\n+                            bound.name.display(self.db)\n+                        );\n                         continue;\n                     }\n                     WherePredicate::ForLifetime { lifetimes, target, bound } => {\n@@ -540,7 +548,7 @@ impl<'a> Printer<'a> {\n                             if i != 0 {\n                                 w!(this, \", \");\n                             }\n-                            w!(this, \"{}\", lt);\n+                            w!(this, \"{}\", lt.display(self.db));\n                         }\n                         w!(this, \"> \");\n                         (target, bound)\n@@ -551,7 +559,7 @@ impl<'a> Printer<'a> {\n                     WherePredicateTypeTarget::TypeRef(ty) => this.print_type_ref(ty),\n                     WherePredicateTypeTarget::TypeOrConstParam(id) => {\n                         match &params.type_or_consts[*id].name() {\n-                            Some(name) => w!(this, \"{}\", name),\n+                            Some(name) => w!(this, \"{}\", name.display(self.db)),\n                             None => w!(this, \"_anon_{}\", id.into_raw()),\n                         }\n                     }"}, {"sha": "5ded4b6b273ae54fadfdc4b6edffea9d6c5052fa", "filename": "crates/hir-def/src/item_tree/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fhir-def%2Fsrc%2Fitem_tree%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fhir-def%2Fsrc%2Fitem_tree%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fitem_tree%2Ftests.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -6,7 +6,7 @@ use crate::{db::DefDatabase, test_db::TestDB};\n fn check(ra_fixture: &str, expect: Expect) {\n     let (db, file_id) = TestDB::with_single_file(ra_fixture);\n     let item_tree = db.file_item_tree(file_id.into());\n-    let pretty = item_tree.pretty_print();\n+    let pretty = item_tree.pretty_print(&db);\n     expect.assert_eq(&pretty);\n }\n "}, {"sha": "8aceb4952a546c23a67d53673c8ca37932340bd8", "filename": "crates/hir-def/src/nameres.rs", "status": "modified", "additions": 12, "deletions": 6, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fhir-def%2Fsrc%2Fnameres.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fhir-def%2Fsrc%2Fnameres.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -463,25 +463,31 @@ impl DefMap {\n         let mut arc;\n         let mut current_map = self;\n         while let Some(block) = current_map.block {\n-            go(&mut buf, current_map, \"block scope\", current_map.root);\n+            go(&mut buf, db, current_map, \"block scope\", current_map.root);\n             buf.push('\\n');\n             arc = block.parent.def_map(db);\n             current_map = &arc;\n         }\n-        go(&mut buf, current_map, \"crate\", current_map.root);\n+        go(&mut buf, db, current_map, \"crate\", current_map.root);\n         return buf;\n \n-        fn go(buf: &mut String, map: &DefMap, path: &str, module: LocalModuleId) {\n+        fn go(\n+            buf: &mut String,\n+            db: &dyn DefDatabase,\n+            map: &DefMap,\n+            path: &str,\n+            module: LocalModuleId,\n+        ) {\n             format_to!(buf, \"{}\\n\", path);\n \n-            map.modules[module].scope.dump(buf);\n+            map.modules[module].scope.dump(db.upcast(), buf);\n \n             for (name, child) in\n                 map.modules[module].children.iter().sorted_by(|a, b| Ord::cmp(&a.0, &b.0))\n             {\n-                let path = format!(\"{path}::{name}\");\n+                let path = format!(\"{path}::{}\", name.display(db.upcast()));\n                 buf.push('\\n');\n-                go(buf, map, &path, *child);\n+                go(buf, db, map, &path, *child);\n             }\n         }\n     }"}, {"sha": "c49bb248a7b08962b32a332a36abdcd2e158820b", "filename": "crates/hir-def/src/nameres/collector.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres%2Fcollector.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -565,7 +565,7 @@ impl DefCollector<'_> {\n             types => {\n                 tracing::debug!(\n                     \"could not resolve prelude path `{}` to module (resolved to {:?})\",\n-                    path,\n+                    path.display(self.db.upcast()),\n                     types\n                 );\n             }\n@@ -766,7 +766,8 @@ impl DefCollector<'_> {\n     }\n \n     fn resolve_import(&self, module_id: LocalModuleId, import: &Import) -> PartialResolvedImport {\n-        let _p = profile::span(\"resolve_import\").detail(|| format!(\"{}\", import.path));\n+        let _p = profile::span(\"resolve_import\")\n+            .detail(|| format!(\"{}\", import.path.display(self.db.upcast())));\n         tracing::debug!(\"resolving import: {:?} ({:?})\", import, self.def_map.edition);\n         if import.is_extern_crate {\n             let name = import\n@@ -1985,7 +1986,10 @@ impl ModCollector<'_, '_> {\n             if self.def_collector.def_map.is_builtin_or_registered_attr(&attr.path) {\n                 continue;\n             }\n-            tracing::debug!(\"non-builtin attribute {}\", attr.path);\n+            tracing::debug!(\n+                \"non-builtin attribute {}\",\n+                attr.path.display(self.def_collector.db.upcast())\n+            );\n \n             let ast_id = AstIdWithPath::new(\n                 self.file_id(),\n@@ -2119,8 +2123,8 @@ impl ModCollector<'_, '_> {\n                         stdx::always!(\n                             name == mac.name,\n                             \"built-in macro {} has #[rustc_builtin_macro] which declares different name {}\",\n-                            mac.name,\n-                            name\n+                            mac.name.display(self.def_collector.db.upcast()),\n+                            name.display(self.def_collector.db.upcast())\n                         );\n                         helpers_opt = Some(helpers);\n                     }"}, {"sha": "2dcc2c30fe1698792b15deecb94b1119e2ba34e3", "filename": "crates/hir-def/src/nameres/mod_resolution.rs", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fhir-def%2Fsrc%2Fnameres%2Fmod_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fhir-def%2Fsrc%2Fnameres%2Fmod_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres%2Fmod_resolution.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -74,12 +74,20 @@ impl ModDir {\n                 candidate_files.push(self.dir_path.join_attr(attr_path, self.root_non_dir_owner))\n             }\n             None if file_id.is_include_macro(db.upcast()) => {\n-                candidate_files.push(format!(\"{name}.rs\"));\n-                candidate_files.push(format!(\"{name}/mod.rs\"));\n+                candidate_files.push(format!(\"{}.rs\", name.display(db.upcast())));\n+                candidate_files.push(format!(\"{}/mod.rs\", name.display(db.upcast())));\n             }\n             None => {\n-                candidate_files.push(format!(\"{}{name}.rs\", self.dir_path.0));\n-                candidate_files.push(format!(\"{}{name}/mod.rs\", self.dir_path.0));\n+                candidate_files.push(format!(\n+                    \"{}{}.rs\",\n+                    self.dir_path.0,\n+                    name.display(db.upcast())\n+                ));\n+                candidate_files.push(format!(\n+                    \"{}{}/mod.rs\",\n+                    self.dir_path.0,\n+                    name.display(db.upcast())\n+                ));\n             }\n         };\n \n@@ -91,7 +99,7 @@ impl ModDir {\n                 let (dir_path, root_non_dir_owner) = if is_mod_rs || attr_path.is_some() {\n                     (DirPath::empty(), false)\n                 } else {\n-                    (DirPath::new(format!(\"{name}/\")), true)\n+                    (DirPath::new(format!(\"{}/\", name.display(db.upcast()))), true)\n                 };\n                 if let Some(mod_dir) = self.child(dir_path, root_non_dir_owner) {\n                     return Ok((file_id, is_mod_rs, mod_dir));"}, {"sha": "24dc4e243bf4a777bba9066156a0ac47b5792826", "filename": "crates/hir-def/src/nameres/path_resolution.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fhir-def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fhir-def%2Fsrc%2Fnameres%2Fpath_resolution.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres%2Fpath_resolution.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -192,8 +192,11 @@ impl DefMap {\n     ) -> ResolvePathResult {\n         let graph = db.crate_graph();\n         let _cx = stdx::panic_context::enter(format!(\n-            \"DefMap {:?} crate_name={:?} block={:?} path={path}\",\n-            self.krate, graph[self.krate].display_name, self.block\n+            \"DefMap {:?} crate_name={:?} block={:?} path={}\",\n+            self.krate,\n+            graph[self.krate].display_name,\n+            self.block,\n+            path.display(db.upcast())\n         ));\n \n         let mut segments = path.segments().iter().enumerate();\n@@ -262,8 +265,8 @@ impl DefMap {\n                                 );\n                                 tracing::debug!(\n                                     \"`super` path: {} -> {} in parent map\",\n-                                    path,\n-                                    new_path\n+                                    path.display(db.upcast()),\n+                                    new_path.display(db.upcast())\n                                 );\n                                 return block.parent.def_map(db).resolve_path_fp_with_macro(\n                                     db,"}, {"sha": "57f0233607b31ce7b46f03ff00bcb6529b51e636", "filename": "crates/hir-def/src/nameres/tests/macros.rs", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fnameres%2Ftests%2Fmacros.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -1080,7 +1080,7 @@ macro_rules! mbe {\n \n #[test]\n fn collects_derive_helpers() {\n-    let def_map = compute_crate_def_map(\n+    let db = TestDB::with_files(\n         r#\"\n #![crate_type=\"proc-macro\"]\n struct TokenStream;\n@@ -1091,11 +1091,13 @@ pub fn derive_macro_2(_item: TokenStream) -> TokenStream {\n }\n \"#,\n     );\n+    let krate = db.crate_graph().iter().next().unwrap();\n+    let def_map = db.crate_def_map(krate);\n \n     assert_eq!(def_map.exported_derives.len(), 1);\n     match def_map.exported_derives.values().next() {\n         Some(helpers) => match &**helpers {\n-            [attr] => assert_eq!(attr.to_string(), \"helper_attr\"),\n+            [attr] => assert_eq!(attr.display(&db).to_string(), \"helper_attr\"),\n             _ => unreachable!(),\n         },\n         _ => unreachable!(),\n@@ -1258,7 +1260,7 @@ struct A;\n \n #[test]\n fn macro_use_imports_all_macro_types() {\n-    let def_map = compute_crate_def_map(\n+    let db = TestDB::with_files(\n         r#\"\n //- /main.rs crate:main deps:lib\n #[macro_use]\n@@ -1281,14 +1283,21 @@ struct TokenStream;\n fn proc_attr(a: TokenStream, b: TokenStream) -> TokenStream { a }\n     \"#,\n     );\n+    let krate = db.crate_graph().iter().next().unwrap();\n+    let def_map = db.crate_def_map(krate);\n \n     let root_module = &def_map[def_map.root()].scope;\n     assert!(\n         root_module.legacy_macros().count() == 0,\n         \"`#[macro_use]` shouldn't bring macros into textual macro scope\",\n     );\n \n-    let actual = def_map.macro_use_prelude.iter().map(|(name, _)| name).sorted().join(\"\\n\");\n+    let actual = def_map\n+        .macro_use_prelude\n+        .iter()\n+        .map(|(name, _)| name.display(&db).to_string())\n+        .sorted()\n+        .join(\"\\n\");\n \n     expect![[r#\"\n         legacy"}, {"sha": "0aead6f37f73f4406022d0d6ab2392c38fa69517", "filename": "crates/hir-def/src/pretty.rs", "status": "modified", "additions": 45, "deletions": 32, "changes": 77, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fhir-def%2Fsrc%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fhir-def%2Fsrc%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-def%2Fsrc%2Fpretty.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -2,7 +2,7 @@\n \n use std::fmt::{self, Write};\n \n-use hir_expand::mod_path::PathKind;\n+use hir_expand::{db::ExpandDatabase, mod_path::PathKind};\n use intern::Interned;\n use itertools::Itertools;\n \n@@ -11,14 +11,14 @@ use crate::{\n     type_ref::{Mutability, TraitBoundModifier, TypeBound, TypeRef},\n };\n \n-pub(crate) fn print_path(path: &Path, buf: &mut dyn Write) -> fmt::Result {\n+pub(crate) fn print_path(db: &dyn ExpandDatabase, path: &Path, buf: &mut dyn Write) -> fmt::Result {\n     if let Path::LangItem(x) = path {\n         return write!(buf, \"$lang_item::{x:?}\");\n     }\n     match path.type_anchor() {\n         Some(anchor) => {\n             write!(buf, \"<\")?;\n-            print_type_ref(anchor, buf)?;\n+            print_type_ref(db, anchor, buf)?;\n             write!(buf, \">::\")?;\n         }\n         None => match path.kind() {\n@@ -44,10 +44,10 @@ pub(crate) fn print_path(path: &Path, buf: &mut dyn Write) -> fmt::Result {\n             write!(buf, \"::\")?;\n         }\n \n-        write!(buf, \"{}\", segment.name)?;\n+        write!(buf, \"{}\", segment.name.display(db))?;\n         if let Some(generics) = segment.args_and_bindings {\n             write!(buf, \"::<\")?;\n-            print_generic_args(generics, buf)?;\n+            print_generic_args(db, generics, buf)?;\n \n             write!(buf, \">\")?;\n         }\n@@ -56,12 +56,16 @@ pub(crate) fn print_path(path: &Path, buf: &mut dyn Write) -> fmt::Result {\n     Ok(())\n }\n \n-pub(crate) fn print_generic_args(generics: &GenericArgs, buf: &mut dyn Write) -> fmt::Result {\n+pub(crate) fn print_generic_args(\n+    db: &dyn ExpandDatabase,\n+    generics: &GenericArgs,\n+    buf: &mut dyn Write,\n+) -> fmt::Result {\n     let mut first = true;\n     let args = if generics.has_self_type {\n         let (self_ty, args) = generics.args.split_first().unwrap();\n         write!(buf, \"Self=\")?;\n-        print_generic_arg(self_ty, buf)?;\n+        print_generic_arg(db, self_ty, buf)?;\n         first = false;\n         args\n     } else {\n@@ -72,35 +76,43 @@ pub(crate) fn print_generic_args(generics: &GenericArgs, buf: &mut dyn Write) ->\n             write!(buf, \", \")?;\n         }\n         first = false;\n-        print_generic_arg(arg, buf)?;\n+        print_generic_arg(db, arg, buf)?;\n     }\n     for binding in generics.bindings.iter() {\n         if !first {\n             write!(buf, \", \")?;\n         }\n         first = false;\n-        write!(buf, \"{}\", binding.name)?;\n+        write!(buf, \"{}\", binding.name.display(db))?;\n         if !binding.bounds.is_empty() {\n             write!(buf, \": \")?;\n-            print_type_bounds(&binding.bounds, buf)?;\n+            print_type_bounds(db, &binding.bounds, buf)?;\n         }\n         if let Some(ty) = &binding.type_ref {\n             write!(buf, \" = \")?;\n-            print_type_ref(ty, buf)?;\n+            print_type_ref(db, ty, buf)?;\n         }\n     }\n     Ok(())\n }\n \n-pub(crate) fn print_generic_arg(arg: &GenericArg, buf: &mut dyn Write) -> fmt::Result {\n+pub(crate) fn print_generic_arg(\n+    db: &dyn ExpandDatabase,\n+    arg: &GenericArg,\n+    buf: &mut dyn Write,\n+) -> fmt::Result {\n     match arg {\n-        GenericArg::Type(ty) => print_type_ref(ty, buf),\n-        GenericArg::Const(c) => write!(buf, \"{c}\"),\n-        GenericArg::Lifetime(lt) => write!(buf, \"{}\", lt.name),\n+        GenericArg::Type(ty) => print_type_ref(db, ty, buf),\n+        GenericArg::Const(c) => write!(buf, \"{}\", c.display(db)),\n+        GenericArg::Lifetime(lt) => write!(buf, \"{}\", lt.name.display(db)),\n     }\n }\n \n-pub(crate) fn print_type_ref(type_ref: &TypeRef, buf: &mut dyn Write) -> fmt::Result {\n+pub(crate) fn print_type_ref(\n+    db: &dyn ExpandDatabase,\n+    type_ref: &TypeRef,\n+    buf: &mut dyn Write,\n+) -> fmt::Result {\n     // FIXME: deduplicate with `HirDisplay` impl\n     match type_ref {\n         TypeRef::Never => write!(buf, \"!\")?,\n@@ -111,18 +123,18 @@ pub(crate) fn print_type_ref(type_ref: &TypeRef, buf: &mut dyn Write) -> fmt::Re\n                 if i != 0 {\n                     write!(buf, \", \")?;\n                 }\n-                print_type_ref(field, buf)?;\n+                print_type_ref(db, field, buf)?;\n             }\n             write!(buf, \")\")?;\n         }\n-        TypeRef::Path(path) => print_path(path, buf)?,\n+        TypeRef::Path(path) => print_path(db, path, buf)?,\n         TypeRef::RawPtr(pointee, mtbl) => {\n             let mtbl = match mtbl {\n                 Mutability::Shared => \"*const\",\n                 Mutability::Mut => \"*mut\",\n             };\n             write!(buf, \"{mtbl} \")?;\n-            print_type_ref(pointee, buf)?;\n+            print_type_ref(db, pointee, buf)?;\n         }\n         TypeRef::Reference(pointee, lt, mtbl) => {\n             let mtbl = match mtbl {\n@@ -131,19 +143,19 @@ pub(crate) fn print_type_ref(type_ref: &TypeRef, buf: &mut dyn Write) -> fmt::Re\n             };\n             write!(buf, \"&\")?;\n             if let Some(lt) = lt {\n-                write!(buf, \"{} \", lt.name)?;\n+                write!(buf, \"{} \", lt.name.display(db))?;\n             }\n             write!(buf, \"{mtbl}\")?;\n-            print_type_ref(pointee, buf)?;\n+            print_type_ref(db, pointee, buf)?;\n         }\n         TypeRef::Array(elem, len) => {\n             write!(buf, \"[\")?;\n-            print_type_ref(elem, buf)?;\n-            write!(buf, \"; {len}]\")?;\n+            print_type_ref(db, elem, buf)?;\n+            write!(buf, \"; {}]\", len.display(db))?;\n         }\n         TypeRef::Slice(elem) => {\n             write!(buf, \"[\")?;\n-            print_type_ref(elem, buf)?;\n+            print_type_ref(db, elem, buf)?;\n             write!(buf, \"]\")?;\n         }\n         TypeRef::Fn(args_and_ret, varargs, is_unsafe) => {\n@@ -157,7 +169,7 @@ pub(crate) fn print_type_ref(type_ref: &TypeRef, buf: &mut dyn Write) -> fmt::Re\n                 if i != 0 {\n                     write!(buf, \", \")?;\n                 }\n-                print_type_ref(typeref, buf)?;\n+                print_type_ref(db, typeref, buf)?;\n             }\n             if *varargs {\n                 if !args.is_empty() {\n@@ -166,26 +178,27 @@ pub(crate) fn print_type_ref(type_ref: &TypeRef, buf: &mut dyn Write) -> fmt::Re\n                 write!(buf, \"...\")?;\n             }\n             write!(buf, \") -> \")?;\n-            print_type_ref(return_type, buf)?;\n+            print_type_ref(db, return_type, buf)?;\n         }\n         TypeRef::Macro(_ast_id) => {\n             write!(buf, \"<macro>\")?;\n         }\n         TypeRef::Error => write!(buf, \"{{unknown}}\")?,\n         TypeRef::ImplTrait(bounds) => {\n             write!(buf, \"impl \")?;\n-            print_type_bounds(bounds, buf)?;\n+            print_type_bounds(db, bounds, buf)?;\n         }\n         TypeRef::DynTrait(bounds) => {\n             write!(buf, \"dyn \")?;\n-            print_type_bounds(bounds, buf)?;\n+            print_type_bounds(db, bounds, buf)?;\n         }\n     }\n \n     Ok(())\n }\n \n pub(crate) fn print_type_bounds(\n+    db: &dyn ExpandDatabase,\n     bounds: &[Interned<TypeBound>],\n     buf: &mut dyn Write,\n ) -> fmt::Result {\n@@ -200,13 +213,13 @@ pub(crate) fn print_type_bounds(\n                     TraitBoundModifier::None => (),\n                     TraitBoundModifier::Maybe => write!(buf, \"?\")?,\n                 }\n-                print_path(path, buf)?;\n+                print_path(db, path, buf)?;\n             }\n             TypeBound::ForLifetime(lifetimes, path) => {\n-                write!(buf, \"for<{}> \", lifetimes.iter().format(\", \"))?;\n-                print_path(path, buf)?;\n+                write!(buf, \"for<{}> \", lifetimes.iter().map(|it| it.display(db)).format(\", \"))?;\n+                print_path(db, path, buf)?;\n             }\n-            TypeBound::Lifetime(lt) => write!(buf, \"{}\", lt.name)?,\n+            TypeBound::Lifetime(lt) => write!(buf, \"{}\", lt.name.display(db))?,\n             TypeBound::Error => write!(buf, \"{{unknown}}\")?,\n         }\n     }"}, {"sha": "47a8ab7de77f94da97801b8f0f9a4518b42a4000", "filename": "crates/hir-expand/src/mod_path.rs", "status": "modified", "additions": 63, "deletions": 39, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fhir-expand%2Fsrc%2Fmod_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fhir-expand%2Fsrc%2Fmod_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-expand%2Fsrc%2Fmod_path.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -1,7 +1,7 @@\n //! A lowering for `use`-paths (more generally, paths without angle-bracketed segments).\n \n use std::{\n-    fmt::{self, Display},\n+    fmt::{self, Display as _},\n     iter,\n };\n \n@@ -24,6 +24,12 @@ pub struct ModPath {\n #[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub struct UnescapedModPath<'a>(&'a ModPath);\n \n+impl<'a> UnescapedModPath<'a> {\n+    pub fn display(&'a self, db: &'a dyn crate::db::ExpandDatabase) -> impl fmt::Display + 'a {\n+        UnescapedDisplay { db, path: self }\n+    }\n+}\n+\n #[derive(Debug, Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub enum PathKind {\n     Plain,\n@@ -110,52 +116,30 @@ impl ModPath {\n         UnescapedModPath(self)\n     }\n \n-    fn _fmt(&self, f: &mut fmt::Formatter<'_>, escaped: bool) -> fmt::Result {\n-        let mut first_segment = true;\n-        let mut add_segment = |s| -> fmt::Result {\n-            if !first_segment {\n-                f.write_str(\"::\")?;\n-            }\n-            first_segment = false;\n-            f.write_str(s)?;\n-            Ok(())\n-        };\n-        match self.kind {\n-            PathKind::Plain => {}\n-            PathKind::Super(0) => add_segment(\"self\")?,\n-            PathKind::Super(n) => {\n-                for _ in 0..n {\n-                    add_segment(\"super\")?;\n-                }\n-            }\n-            PathKind::Crate => add_segment(\"crate\")?,\n-            PathKind::Abs => add_segment(\"\")?,\n-            PathKind::DollarCrate(_) => add_segment(\"$crate\")?,\n-        }\n-        for segment in &self.segments {\n-            if !first_segment {\n-                f.write_str(\"::\")?;\n-            }\n-            first_segment = false;\n-            if escaped {\n-                segment.fmt(f)?\n-            } else {\n-                segment.unescaped().fmt(f)?\n-            };\n-        }\n-        Ok(())\n+    pub fn display<'a>(&'a self, db: &'a dyn crate::db::ExpandDatabase) -> impl fmt::Display + 'a {\n+        Display { db, path: self }\n     }\n }\n \n-impl Display for ModPath {\n+struct Display<'a> {\n+    db: &'a dyn ExpandDatabase,\n+    path: &'a ModPath,\n+}\n+\n+impl<'a> fmt::Display for Display<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        self._fmt(f, true)\n+        display_fmt_path(self.db, self.path, f, true)\n     }\n }\n \n-impl<'a> Display for UnescapedModPath<'a> {\n+struct UnescapedDisplay<'a> {\n+    db: &'a dyn ExpandDatabase,\n+    path: &'a UnescapedModPath<'a>,\n+}\n+\n+impl<'a> fmt::Display for UnescapedDisplay<'a> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        self.0._fmt(f, false)\n+        display_fmt_path(self.db, self.path.0, f, false)\n     }\n }\n \n@@ -164,6 +148,46 @@ impl From<Name> for ModPath {\n         ModPath::from_segments(PathKind::Plain, iter::once(name))\n     }\n }\n+fn display_fmt_path(\n+    db: &dyn ExpandDatabase,\n+    path: &ModPath,\n+    f: &mut fmt::Formatter<'_>,\n+    escaped: bool,\n+) -> fmt::Result {\n+    let mut first_segment = true;\n+    let mut add_segment = |s| -> fmt::Result {\n+        if !first_segment {\n+            f.write_str(\"::\")?;\n+        }\n+        first_segment = false;\n+        f.write_str(s)?;\n+        Ok(())\n+    };\n+    match path.kind {\n+        PathKind::Plain => {}\n+        PathKind::Super(0) => add_segment(\"self\")?,\n+        PathKind::Super(n) => {\n+            for _ in 0..n {\n+                add_segment(\"super\")?;\n+            }\n+        }\n+        PathKind::Crate => add_segment(\"crate\")?,\n+        PathKind::Abs => add_segment(\"\")?,\n+        PathKind::DollarCrate(_) => add_segment(\"$crate\")?,\n+    }\n+    for segment in &path.segments {\n+        if !first_segment {\n+            f.write_str(\"::\")?;\n+        }\n+        first_segment = false;\n+        if escaped {\n+            segment.display(db).fmt(f)?;\n+        } else {\n+            segment.unescaped().display(db).fmt(f)?;\n+        }\n+    }\n+    Ok(())\n+}\n \n fn convert_path(\n     db: &dyn ExpandDatabase,"}, {"sha": "0e95673dbd439d309d56b9409cd99b260d9a604a", "filename": "crates/hir-expand/src/name.rs", "status": "modified", "additions": 39, "deletions": 21, "changes": 60, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fhir-expand%2Fsrc%2Fname.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fhir-expand%2Fsrc%2Fname.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-expand%2Fsrc%2Fname.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -24,27 +24,6 @@ enum Repr {\n     TupleField(usize),\n }\n \n-impl fmt::Display for Name {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match &self.0 {\n-            Repr::Text(text) => fmt::Display::fmt(&text, f),\n-            Repr::TupleField(idx) => fmt::Display::fmt(&idx, f),\n-        }\n-    }\n-}\n-\n-impl<'a> fmt::Display for UnescapedName<'a> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match &self.0 .0 {\n-            Repr::Text(text) => {\n-                let text = text.strip_prefix(\"r#\").unwrap_or(text);\n-                fmt::Display::fmt(&text, f)\n-            }\n-            Repr::TupleField(idx) => fmt::Display::fmt(&idx, f),\n-        }\n-    }\n-}\n-\n impl<'a> UnescapedName<'a> {\n     /// Returns the textual representation of this name as a [`SmolStr`]. Prefer using this over\n     /// [`ToString::to_string`] if possible as this conversion is cheaper in the general case.\n@@ -60,6 +39,11 @@ impl<'a> UnescapedName<'a> {\n             Repr::TupleField(it) => SmolStr::new(it.to_string()),\n         }\n     }\n+\n+    pub fn display(&'a self, db: &dyn crate::db::ExpandDatabase) -> impl fmt::Display + 'a {\n+        _ = db;\n+        UnescapedDisplay { name: self }\n+    }\n }\n \n impl Name {\n@@ -167,6 +151,40 @@ impl Name {\n             Repr::TupleField(_) => false,\n         }\n     }\n+\n+    pub fn display<'a>(&'a self, db: &dyn crate::db::ExpandDatabase) -> impl fmt::Display + 'a {\n+        _ = db;\n+        Display { name: self }\n+    }\n+}\n+\n+struct Display<'a> {\n+    name: &'a Name,\n+}\n+\n+impl<'a> fmt::Display for Display<'a> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match &self.name.0 {\n+            Repr::Text(text) => fmt::Display::fmt(&text, f),\n+            Repr::TupleField(idx) => fmt::Display::fmt(&idx, f),\n+        }\n+    }\n+}\n+\n+struct UnescapedDisplay<'a> {\n+    name: &'a UnescapedName<'a>,\n+}\n+\n+impl<'a> fmt::Display for UnescapedDisplay<'a> {\n+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n+        match &self.name.0 .0 {\n+            Repr::Text(text) => {\n+                let text = text.strip_prefix(\"r#\").unwrap_or(text);\n+                fmt::Display::fmt(&text, f)\n+            }\n+            Repr::TupleField(idx) => fmt::Display::fmt(&idx, f),\n+        }\n+    }\n }\n \n pub trait AsName {"}, {"sha": "ac962c9e3e1f07602f1250f61d8e32f8d5d09a20", "filename": "crates/hir-ty/src/chalk_db.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fhir-ty%2Fsrc%2Fchalk_db.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fhir-ty%2Fsrc%2Fchalk_db.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fchalk_db.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -365,13 +365,19 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n \n     fn trait_name(&self, trait_id: chalk_ir::TraitId<Interner>) -> String {\n         let id = from_chalk_trait_id(trait_id);\n-        self.db.trait_data(id).name.to_string()\n+        self.db.trait_data(id).name.display(self.db.upcast()).to_string()\n     }\n     fn adt_name(&self, chalk_ir::AdtId(adt_id): AdtId) -> String {\n         match adt_id {\n-            hir_def::AdtId::StructId(id) => self.db.struct_data(id).name.to_string(),\n-            hir_def::AdtId::EnumId(id) => self.db.enum_data(id).name.to_string(),\n-            hir_def::AdtId::UnionId(id) => self.db.union_data(id).name.to_string(),\n+            hir_def::AdtId::StructId(id) => {\n+                self.db.struct_data(id).name.display(self.db.upcast()).to_string()\n+            }\n+            hir_def::AdtId::EnumId(id) => {\n+                self.db.enum_data(id).name.display(self.db.upcast()).to_string()\n+            }\n+            hir_def::AdtId::UnionId(id) => {\n+                self.db.union_data(id).name.display(self.db.upcast()).to_string()\n+            }\n         }\n     }\n     fn adt_size_align(&self, _id: chalk_ir::AdtId<Interner>) -> Arc<rust_ir::AdtSizeAlign> {\n@@ -380,7 +386,7 @@ impl<'a> chalk_solve::RustIrDatabase<Interner> for ChalkContext<'a> {\n     }\n     fn assoc_type_name(&self, assoc_ty_id: chalk_ir::AssocTypeId<Interner>) -> String {\n         let id = self.db.associated_ty_data(assoc_ty_id).name;\n-        self.db.type_alias_data(id).name.to_string()\n+        self.db.type_alias_data(id).name.display(self.db.upcast()).to_string()\n     }\n     fn opaque_type_name(&self, opaque_ty_id: chalk_ir::OpaqueTyId<Interner>) -> String {\n         format!(\"Opaque_{}\", opaque_ty_id.0)"}, {"sha": "6ff8e2de67de51555e3d00d2de9935b4b3bdd3ff", "filename": "crates/hir-ty/src/consteval/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fconsteval%2Ftests.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -79,7 +79,7 @@ fn eval_goal(db: &TestDB, file_id: FileId) -> Result<Const, ConstEvalError> {\n         .declarations()\n         .find_map(|x| match x {\n             hir_def::ModuleDefId::ConstId(x) => {\n-                if db.const_data(x).name.as_ref()?.to_string() == \"GOAL\" {\n+                if db.const_data(x).name.as_ref()?.display(db).to_string() == \"GOAL\" {\n                     Some(x)\n                 } else {\n                     None"}, {"sha": "3aa43dedcd57140bf0af1c7cd53270a1e2dd4abe", "filename": "crates/hir-ty/src/db.rs", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fhir-ty%2Fsrc%2Fdb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fhir-ty%2Fsrc%2Fdb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fdb.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -243,13 +243,19 @@ pub trait HirDatabase: DefDatabase + Upcast<dyn DefDatabase> {\n \n fn infer_wait(db: &dyn HirDatabase, def: DefWithBodyId) -> Arc<InferenceResult> {\n     let _p = profile::span(\"infer:wait\").detail(|| match def {\n-        DefWithBodyId::FunctionId(it) => db.function_data(it).name.to_string(),\n-        DefWithBodyId::StaticId(it) => db.static_data(it).name.clone().to_string(),\n-        DefWithBodyId::ConstId(it) => {\n-            db.const_data(it).name.clone().unwrap_or_else(Name::missing).to_string()\n+        DefWithBodyId::FunctionId(it) => db.function_data(it).name.display(db.upcast()).to_string(),\n+        DefWithBodyId::StaticId(it) => {\n+            db.static_data(it).name.clone().display(db.upcast()).to_string()\n         }\n+        DefWithBodyId::ConstId(it) => db\n+            .const_data(it)\n+            .name\n+            .clone()\n+            .unwrap_or_else(Name::missing)\n+            .display(db.upcast())\n+            .to_string(),\n         DefWithBodyId::VariantId(it) => {\n-            db.enum_data(it.parent).variants[it.local_id].name.to_string()\n+            db.enum_data(it.parent).variants[it.local_id].name.display(db.upcast()).to_string()\n         }\n     });\n     db.infer_query(def)"}, {"sha": "1233469b947b48cbaf1a009ce58128a44677835f", "filename": "crates/hir-ty/src/diagnostics/decl_check.rs", "status": "modified", "additions": 23, "deletions": 16, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fdecl_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fdecl_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fdecl_check.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -223,7 +223,7 @@ impl<'a> DeclValidator<'a> {\n         }\n \n         // Check the function name.\n-        let function_name = data.name.to_string();\n+        let function_name = data.name.display(self.db.upcast()).to_string();\n         let fn_name_replacement = to_lower_snake_case(&function_name).map(|new_name| Replacement {\n             current_name: data.name.clone(),\n             suggested_text: new_name,\n@@ -244,7 +244,9 @@ impl<'a> DeclValidator<'a> {\n                     id,\n                     Replacement {\n                         current_name: bind_name.clone(),\n-                        suggested_text: to_lower_snake_case(&bind_name.to_string())?,\n+                        suggested_text: to_lower_snake_case(\n+                            &bind_name.display(self.db.upcast()).to_string(),\n+                        )?,\n                         expected_case: CaseType::LowerSnakeCase,\n                     },\n                 ))\n@@ -287,7 +289,7 @@ impl<'a> DeclValidator<'a> {\n             ident_type: IdentType::Function,\n             ident: AstPtr::new(&ast_ptr),\n             expected_case: fn_name_replacement.expected_case,\n-            ident_text: fn_name_replacement.current_name.to_string(),\n+            ident_text: fn_name_replacement.current_name.display(self.db.upcast()).to_string(),\n             suggested_text: fn_name_replacement.suggested_text,\n         };\n \n@@ -343,7 +345,10 @@ impl<'a> DeclValidator<'a> {\n                             ident_type,\n                             ident: AstPtr::new(&name_ast),\n                             expected_case: replacement.expected_case,\n-                            ident_text: replacement.current_name.to_string(),\n+                            ident_text: replacement\n+                                .current_name\n+                                .display(self.db.upcast())\n+                                .to_string(),\n                             suggested_text: replacement.suggested_text,\n                         };\n \n@@ -362,7 +367,7 @@ impl<'a> DeclValidator<'a> {\n         let non_snake_case_allowed = self.allowed(struct_id.into(), allow::NON_SNAKE_CASE, false);\n \n         // Check the structure name.\n-        let struct_name = data.name.to_string();\n+        let struct_name = data.name.display(self.db.upcast()).to_string();\n         let struct_name_replacement = if !non_camel_case_allowed {\n             to_camel_case(&struct_name).map(|new_name| Replacement {\n                 current_name: data.name.clone(),\n@@ -379,7 +384,7 @@ impl<'a> DeclValidator<'a> {\n         if !non_snake_case_allowed {\n             if let VariantData::Record(fields) = data.variant_data.as_ref() {\n                 for (_, field) in fields.iter() {\n-                    let field_name = field.name.to_string();\n+                    let field_name = field.name.display(self.db.upcast()).to_string();\n                     if let Some(new_name) = to_lower_snake_case(&field_name) {\n                         let replacement = Replacement {\n                             current_name: field.name.clone(),\n@@ -434,7 +439,7 @@ impl<'a> DeclValidator<'a> {\n                 ident_type: IdentType::Structure,\n                 ident: AstPtr::new(&ast_ptr),\n                 expected_case: replacement.expected_case,\n-                ident_text: replacement.current_name.to_string(),\n+                ident_text: replacement.current_name.display(self.db.upcast()).to_string(),\n                 suggested_text: replacement.suggested_text,\n             };\n \n@@ -479,7 +484,7 @@ impl<'a> DeclValidator<'a> {\n                 ident_type: IdentType::Field,\n                 ident: AstPtr::new(&ast_ptr),\n                 expected_case: field_to_rename.expected_case,\n-                ident_text: field_to_rename.current_name.to_string(),\n+                ident_text: field_to_rename.current_name.display(self.db.upcast()).to_string(),\n                 suggested_text: field_to_rename.suggested_text,\n             };\n \n@@ -496,7 +501,7 @@ impl<'a> DeclValidator<'a> {\n         }\n \n         // Check the enum name.\n-        let enum_name = data.name.to_string();\n+        let enum_name = data.name.display(self.db.upcast()).to_string();\n         let enum_name_replacement = to_camel_case(&enum_name).map(|new_name| Replacement {\n             current_name: data.name.clone(),\n             suggested_text: new_name,\n@@ -510,7 +515,9 @@ impl<'a> DeclValidator<'a> {\n             .filter_map(|(_, variant)| {\n                 Some(Replacement {\n                     current_name: variant.name.clone(),\n-                    suggested_text: to_camel_case(&variant.name.to_string())?,\n+                    suggested_text: to_camel_case(\n+                        &variant.name.display(self.db.upcast()).to_string(),\n+                    )?,\n                     expected_case: CaseType::UpperCamelCase,\n                 })\n             })\n@@ -558,7 +565,7 @@ impl<'a> DeclValidator<'a> {\n                 ident_type: IdentType::Enum,\n                 ident: AstPtr::new(&ast_ptr),\n                 expected_case: replacement.expected_case,\n-                ident_text: replacement.current_name.to_string(),\n+                ident_text: replacement.current_name.display(self.db.upcast()).to_string(),\n                 suggested_text: replacement.suggested_text,\n             };\n \n@@ -603,7 +610,7 @@ impl<'a> DeclValidator<'a> {\n                 ident_type: IdentType::Variant,\n                 ident: AstPtr::new(&ast_ptr),\n                 expected_case: variant_to_rename.expected_case,\n-                ident_text: variant_to_rename.current_name.to_string(),\n+                ident_text: variant_to_rename.current_name.display(self.db.upcast()).to_string(),\n                 suggested_text: variant_to_rename.suggested_text,\n             };\n \n@@ -623,7 +630,7 @@ impl<'a> DeclValidator<'a> {\n             None => return,\n         };\n \n-        let const_name = name.to_string();\n+        let const_name = name.display(self.db.upcast()).to_string();\n         let replacement = if let Some(new_name) = to_upper_snake_case(&const_name) {\n             Replacement {\n                 current_name: name.clone(),\n@@ -648,7 +655,7 @@ impl<'a> DeclValidator<'a> {\n             ident_type: IdentType::Constant,\n             ident: AstPtr::new(&ast_ptr),\n             expected_case: replacement.expected_case,\n-            ident_text: replacement.current_name.to_string(),\n+            ident_text: replacement.current_name.display(self.db.upcast()).to_string(),\n             suggested_text: replacement.suggested_text,\n         };\n \n@@ -668,7 +675,7 @@ impl<'a> DeclValidator<'a> {\n \n         let name = &data.name;\n \n-        let static_name = name.to_string();\n+        let static_name = name.display(self.db.upcast()).to_string();\n         let replacement = if let Some(new_name) = to_upper_snake_case(&static_name) {\n             Replacement {\n                 current_name: name.clone(),\n@@ -693,7 +700,7 @@ impl<'a> DeclValidator<'a> {\n             ident_type: IdentType::StaticVariable,\n             ident: AstPtr::new(&ast_ptr),\n             expected_case: replacement.expected_case,\n-            ident_text: replacement.current_name.to_string(),\n+            ident_text: replacement.current_name.display(self.db.upcast()).to_string(),\n             suggested_text: replacement.suggested_text,\n         };\n "}, {"sha": "f8cdeaa5e35493dfc55846352c3c636724bb7723", "filename": "crates/hir-ty/src/diagnostics/match_check.rs", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fdiagnostics%2Fmatch_check.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -153,7 +153,7 @@ impl<'a> PatCtxt<'a> {\n                 match (bm, ty.kind(Interner)) {\n                     (BindingMode::Ref(_), TyKind::Ref(.., rty)) => ty = rty,\n                     (BindingMode::Ref(_), _) => {\n-                        never!(\"`ref {}` has wrong type {:?}\", name, ty);\n+                        never!(\"`ref {}` has wrong type {:?}\", name.display(self.db.upcast()), ty);\n                         self.errors.push(PatternError::UnexpectedType);\n                         return Pat { ty: ty.clone(), kind: PatKind::Wild.into() };\n                     }\n@@ -298,7 +298,7 @@ impl HirDisplay for Pat {\n         match &*self.kind {\n             PatKind::Wild => write!(f, \"_\"),\n             PatKind::Binding { name, subpattern } => {\n-                write!(f, \"{name}\")?;\n+                write!(f, \"{}\", name.display(f.db.upcast()))?;\n                 if let Some(subpattern) = subpattern {\n                     write!(f, \" @ \")?;\n                     subpattern.hir_fmt(f)?;\n@@ -319,10 +319,14 @@ impl HirDisplay for Pat {\n                     match variant {\n                         VariantId::EnumVariantId(v) => {\n                             let data = f.db.enum_data(v.parent);\n-                            write!(f, \"{}\", data.variants[v.local_id].name)?;\n+                            write!(f, \"{}\", data.variants[v.local_id].name.display(f.db.upcast()))?;\n+                        }\n+                        VariantId::StructId(s) => {\n+                            write!(f, \"{}\", f.db.struct_data(s).name.display(f.db.upcast()))?\n+                        }\n+                        VariantId::UnionId(u) => {\n+                            write!(f, \"{}\", f.db.union_data(u).name.display(f.db.upcast()))?\n                         }\n-                        VariantId::StructId(s) => write!(f, \"{}\", f.db.struct_data(s).name)?,\n-                        VariantId::UnionId(u) => write!(f, \"{}\", f.db.union_data(u).name)?,\n                     };\n \n                     let variant_data = variant.variant_data(f.db.upcast());\n@@ -336,7 +340,11 @@ impl HirDisplay for Pat {\n                             .map(|p| {\n                                 printed += 1;\n                                 WriteWith(move |f| {\n-                                    write!(f, \"{}: \", rec_fields[p.field].name)?;\n+                                    write!(\n+                                        f,\n+                                        \"{}: \",\n+                                        rec_fields[p.field].name.display(f.db.upcast())\n+                                    )?;\n                                     p.pattern.hir_fmt(f)\n                                 })\n                             });"}, {"sha": "3a34485adc44dfc7b9d244d8b096e136c0960a87", "filename": "crates/hir-ty/src/display.rs", "status": "modified", "additions": 59, "deletions": 33, "changes": 92, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fhir-ty%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fhir-ty%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fdisplay.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -372,7 +372,13 @@ impl HirDisplay for ProjectionTy {\n         let trait_ref = self.trait_ref(f.db);\n         write!(f, \"<\")?;\n         fmt_trait_ref(f, &trait_ref, true)?;\n-        write!(f, \">::{}\", f.db.type_alias_data(from_assoc_type_id(self.associated_ty_id)).name)?;\n+        write!(\n+            f,\n+            \">::{}\",\n+            f.db.type_alias_data(from_assoc_type_id(self.associated_ty_id))\n+                .name\n+                .display(f.db.upcast())\n+        )?;\n         let proj_params_count =\n             self.substitution.len(Interner) - trait_ref.substitution.len(Interner);\n         let proj_params = &self.substitution.as_slice(Interner)[..proj_params_count];\n@@ -415,7 +421,8 @@ impl HirDisplay for Const {\n                 let id = from_placeholder_idx(f.db, *idx);\n                 let generics = generics(f.db.upcast(), id.parent);\n                 let param_data = &generics.params.type_or_consts[id.local_id];\n-                write!(f, \"{}\", param_data.name().unwrap())\n+                write!(f, \"{}\", param_data.name().unwrap().display(f.db.upcast()))?;\n+                Ok(())\n             }\n             ConstValue::Concrete(c) => match &c.interned {\n                 ConstScalar::Bytes(b, m) => render_const_scalar(f, &b, m, &data.ty),\n@@ -546,19 +553,19 @@ fn render_const_scalar(\n                         };\n                         let mut it = fields.iter();\n                         if matches!(data.variant_data.as_ref(), VariantData::Record(_)) {\n-                            write!(f, \"{} {{\", data.name)?;\n+                            write!(f, \"{} {{\", data.name.display(f.db.upcast()))?;\n                             if let Some((id, data)) = it.next() {\n-                                write!(f, \" {}: \", data.name)?;\n+                                write!(f, \" {}: \", data.name.display(f.db.upcast()))?;\n                                 render_field(f, id)?;\n                             }\n                             for (id, data) in it {\n-                                write!(f, \", {}: \", data.name)?;\n+                                write!(f, \", {}: \", data.name.display(f.db.upcast()))?;\n                                 render_field(f, id)?;\n                             }\n                             write!(f, \" }}\")?;\n                         } else {\n                             let mut it = it.map(|x| x.0);\n-                            write!(f, \"{}(\", data.name)?;\n+                            write!(f, \"{}(\", data.name.display(f.db.upcast()))?;\n                             if let Some(id) = it.next() {\n                                 render_field(f, id)?;\n                             }\n@@ -570,10 +577,12 @@ fn render_const_scalar(\n                         }\n                         return Ok(());\n                     }\n-                    VariantData::Unit => write!(f, \"{}\", data.name),\n+                    VariantData::Unit => write!(f, \"{}\", data.name.display(f.db.upcast())),\n                 }\n             }\n-            hir_def::AdtId::UnionId(u) => write!(f, \"{}\", f.db.union_data(u).name),\n+            hir_def::AdtId::UnionId(u) => {\n+                write!(f, \"{}\", f.db.union_data(u).name.display(f.db.upcast()))\n+            }\n             hir_def::AdtId::EnumId(_) => f.write_str(\"<enum-not-supported>\"),\n         },\n         chalk_ir::TyKind::FnDef(..) => ty.hir_fmt(f),\n@@ -739,11 +748,17 @@ impl HirDisplay for Ty {\n                 let sig = db.callable_item_signature(def).substitute(Interner, parameters);\n                 f.start_location_link(def.into());\n                 match def {\n-                    CallableDefId::FunctionId(ff) => write!(f, \"fn {}\", db.function_data(ff).name)?,\n-                    CallableDefId::StructId(s) => write!(f, \"{}\", db.struct_data(s).name)?,\n-                    CallableDefId::EnumVariantId(e) => {\n-                        write!(f, \"{}\", db.enum_data(e.parent).variants[e.local_id].name)?\n+                    CallableDefId::FunctionId(ff) => {\n+                        write!(f, \"fn {}\", db.function_data(ff).name.display(f.db.upcast()))?\n+                    }\n+                    CallableDefId::StructId(s) => {\n+                        write!(f, \"{}\", db.struct_data(s).name.display(f.db.upcast()))?\n                     }\n+                    CallableDefId::EnumVariantId(e) => write!(\n+                        f,\n+                        \"{}\",\n+                        db.enum_data(e.parent).variants[e.local_id].name.display(f.db.upcast())\n+                    )?,\n                 };\n                 f.end_location_link();\n                 if parameters.len(Interner) > 0 {\n@@ -783,7 +798,7 @@ impl HirDisplay for Ty {\n                             hir_def::AdtId::UnionId(it) => db.union_data(it).name.clone(),\n                             hir_def::AdtId::EnumId(it) => db.enum_data(it).name.clone(),\n                         };\n-                        write!(f, \"{name}\")?;\n+                        write!(f, \"{}\", name.display(f.db.upcast()))?;\n                     }\n                     DisplayTarget::SourceCode { module_id, allow_opaque: _ } => {\n                         if let Some(path) = find_path::find_path(\n@@ -792,7 +807,7 @@ impl HirDisplay for Ty {\n                             module_id,\n                             false,\n                         ) {\n-                            write!(f, \"{path}\")?;\n+                            write!(f, \"{}\", path.display(f.db.upcast()))?;\n                         } else {\n                             return Err(HirDisplayError::DisplaySourceCodeError(\n                                 DisplaySourceCodeError::PathNotFound,\n@@ -818,12 +833,12 @@ impl HirDisplay for Ty {\n                 // Use placeholder associated types when the target is test (https://rust-lang.github.io/chalk/book/clauses/type_equality.html#placeholder-associated-types)\n                 if f.display_target.is_test() {\n                     f.start_location_link(trait_.into());\n-                    write!(f, \"{}\", trait_data.name)?;\n+                    write!(f, \"{}\", trait_data.name.display(f.db.upcast()))?;\n                     f.end_location_link();\n                     write!(f, \"::\")?;\n \n                     f.start_location_link(type_alias.into());\n-                    write!(f, \"{}\", type_alias_data.name)?;\n+                    write!(f, \"{}\", type_alias_data.name.display(f.db.upcast()))?;\n                     f.end_location_link();\n                     // Note that the generic args for the associated type come before those for the\n                     // trait (including the self type).\n@@ -846,7 +861,7 @@ impl HirDisplay for Ty {\n                 let alias = from_foreign_def_id(*type_alias);\n                 let type_alias = db.type_alias_data(alias);\n                 f.start_location_link(alias.into());\n-                write!(f, \"{}\", type_alias.name)?;\n+                write!(f, \"{}\", type_alias.name.display(f.db.upcast()))?;\n                 f.end_location_link();\n             }\n             TyKind::OpaqueType(opaque_ty_id, parameters) => {\n@@ -954,7 +969,11 @@ impl HirDisplay for Ty {\n                 match param_data {\n                     TypeOrConstParamData::TypeParamData(p) => match p.provenance {\n                         TypeParamProvenance::TypeParamList | TypeParamProvenance::TraitSelf => {\n-                            write!(f, \"{}\", p.name.clone().unwrap_or_else(Name::missing))?\n+                            write!(\n+                                f,\n+                                \"{}\",\n+                                p.name.clone().unwrap_or_else(Name::missing).display(f.db.upcast())\n+                            )?\n                         }\n                         TypeParamProvenance::ArgumentImplTrait => {\n                             let substs = generics.placeholder_subst(db);\n@@ -983,7 +1002,7 @@ impl HirDisplay for Ty {\n                         }\n                     },\n                     TypeOrConstParamData::ConstParamData(p) => {\n-                        write!(f, \"{}\", p.name)?;\n+                        write!(f, \"{}\", p.name.display(f.db.upcast()))?;\n                     }\n                 }\n             }\n@@ -1258,7 +1277,7 @@ fn write_bounds_like_dyn_trait(\n                 // existential) here, which is the only thing that's\n                 // possible in actual Rust, and hence don't print it\n                 f.start_location_link(trait_.into());\n-                write!(f, \"{}\", f.db.trait_data(trait_).name)?;\n+                write!(f, \"{}\", f.db.trait_data(trait_).name.display(f.db.upcast()))?;\n                 f.end_location_link();\n                 if let [_, params @ ..] = &*trait_ref.substitution.as_slice(Interner) {\n                     if is_fn_trait {\n@@ -1297,7 +1316,7 @@ fn write_bounds_like_dyn_trait(\n                     let assoc_ty_id = from_assoc_type_id(proj.associated_ty_id);\n                     let type_alias = f.db.type_alias_data(assoc_ty_id);\n                     f.start_location_link(assoc_ty_id.into());\n-                    write!(f, \"{}\", type_alias.name)?;\n+                    write!(f, \"{}\", type_alias.name.display(f.db.upcast()))?;\n                     f.end_location_link();\n \n                     let proj_arg_count = generics(f.db.upcast(), assoc_ty_id.into()).len_self();\n@@ -1364,7 +1383,7 @@ fn fmt_trait_ref(\n     }\n     let trait_ = tr.hir_trait_id();\n     f.start_location_link(trait_.into());\n-    write!(f, \"{}\", f.db.trait_data(trait_).name)?;\n+    write!(f, \"{}\", f.db.trait_data(trait_).name.display(f.db.upcast()))?;\n     f.end_location_link();\n     if tr.substitution.len(Interner) > 1 {\n         write!(f, \"<\")?;\n@@ -1394,7 +1413,7 @@ impl HirDisplay for WhereClause {\n                 write!(f, \">::\",)?;\n                 let type_alias = from_assoc_type_id(projection_ty.associated_ty_id);\n                 f.start_location_link(type_alias.into());\n-                write!(f, \"{}\", f.db.type_alias_data(type_alias).name,)?;\n+                write!(f, \"{}\", f.db.type_alias_data(type_alias).name.display(f.db.upcast()),)?;\n                 f.end_location_link();\n                 write!(f, \" = \")?;\n                 ty.hir_fmt(f)?;\n@@ -1432,7 +1451,8 @@ impl HirDisplay for LifetimeData {\n                 let id = lt_from_placeholder_idx(f.db, *idx);\n                 let generics = generics(f.db.upcast(), id.parent);\n                 let param_data = &generics.params.lifetimes[id.local_id];\n-                write!(f, \"{}\", param_data.name)\n+                write!(f, \"{}\", param_data.name.display(f.db.upcast()))?;\n+                Ok(())\n             }\n             LifetimeData::Static => write!(f, \"'static\"),\n             LifetimeData::Erased => Ok(()),\n@@ -1508,15 +1528,15 @@ impl HirDisplay for TypeRef {\n                 };\n                 write!(f, \"&\")?;\n                 if let Some(lifetime) = lifetime {\n-                    write!(f, \"{} \", lifetime.name)?;\n+                    write!(f, \"{} \", lifetime.name.display(f.db.upcast()))?;\n                 }\n                 write!(f, \"{mutability}\")?;\n                 inner.hir_fmt(f)?;\n             }\n             TypeRef::Array(inner, len) => {\n                 write!(f, \"[\")?;\n                 inner.hir_fmt(f)?;\n-                write!(f, \"; {len}]\")?;\n+                write!(f, \"; {}]\", len.display(f.db.upcast()))?;\n             }\n             TypeRef::Slice(inner) => {\n                 write!(f, \"[\")?;\n@@ -1533,7 +1553,7 @@ impl HirDisplay for TypeRef {\n                     for index in 0..function_parameters.len() {\n                         let (param_name, param_type) = &function_parameters[index];\n                         if let Some(name) = param_name {\n-                            write!(f, \"{name}: \")?;\n+                            write!(f, \"{}: \", name.display(f.db.upcast()))?;\n                         }\n \n                         param_type.hir_fmt(f)?;\n@@ -1594,9 +1614,13 @@ impl HirDisplay for TypeBound {\n                 }\n                 path.hir_fmt(f)\n             }\n-            TypeBound::Lifetime(lifetime) => write!(f, \"{}\", lifetime.name),\n+            TypeBound::Lifetime(lifetime) => write!(f, \"{}\", lifetime.name.display(f.db.upcast())),\n             TypeBound::ForLifetime(lifetimes, path) => {\n-                write!(f, \"for<{}> \", lifetimes.iter().format(\", \"))?;\n+                write!(\n+                    f,\n+                    \"for<{}> \",\n+                    lifetimes.iter().map(|it| it.display(f.db.upcast())).format(\", \")\n+                )?;\n                 path.hir_fmt(f)\n             }\n             TypeBound::Error => write!(f, \"{{error}}\"),\n@@ -1642,7 +1666,7 @@ impl HirDisplay for Path {\n             if !matches!(self.kind(), PathKind::Plain) || seg_idx > 0 {\n                 write!(f, \"::\")?;\n             }\n-            write!(f, \"{}\", segment.name)?;\n+            write!(f, \"{}\", segment.name.display(f.db.upcast()))?;\n             if let Some(generic_args) = segment.args_and_bindings {\n                 // We should be in type context, so format as `Foo<Bar>` instead of `Foo::<Bar>`.\n                 // Do we actually format expressions?\n@@ -1689,7 +1713,7 @@ impl HirDisplay for Path {\n                     } else {\n                         write!(f, \", \")?;\n                     }\n-                    write!(f, \"{}\", binding.name)?;\n+                    write!(f, \"{}\", binding.name.display(f.db.upcast()))?;\n                     match &binding.type_ref {\n                         Some(ty) => {\n                             write!(f, \" = \")?;\n@@ -1712,8 +1736,10 @@ impl HirDisplay for hir_def::path::GenericArg {\n     fn hir_fmt(&self, f: &mut HirFormatter<'_>) -> Result<(), HirDisplayError> {\n         match self {\n             hir_def::path::GenericArg::Type(ty) => ty.hir_fmt(f),\n-            hir_def::path::GenericArg::Const(c) => write!(f, \"{c}\"),\n-            hir_def::path::GenericArg::Lifetime(lifetime) => write!(f, \"{}\", lifetime.name),\n+            hir_def::path::GenericArg::Const(c) => write!(f, \"{}\", c.display(f.db.upcast())),\n+            hir_def::path::GenericArg::Lifetime(lifetime) => {\n+                write!(f, \"{}\", lifetime.name.display(f.db.upcast()))\n+            }\n         }\n     }\n }"}, {"sha": "7878ebcc58663e97ac17c3bffa55498bf27e4fc5", "filename": "crates/hir-ty/src/infer/closure.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fhir-ty%2Fsrc%2Finfer%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fhir-ty%2Fsrc%2Finfer%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Finfer%2Fclosure.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -181,7 +181,7 @@ impl CapturedItem {\n \n     pub fn display_place(&self, owner: DefWithBodyId, db: &dyn HirDatabase) -> String {\n         let body = db.body(owner);\n-        let mut result = body[self.place.local].name.to_string();\n+        let mut result = body[self.place.local].name.display(db.upcast()).to_string();\n         let mut field_need_paren = false;\n         for proj in &self.place.projections {\n             match proj {"}, {"sha": "a1f69b1f286677b5956772283a1887121f203ff8", "filename": "crates/hir-ty/src/mir/eval.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -309,7 +309,12 @@ impl MirEvalError {\n             match func {\n                 Either::Left(func) => {\n                     let function_name = db.function_data(*func);\n-                    writeln!(f, \"In function {} ({:?})\", function_name.name, func)?;\n+                    writeln!(\n+                        f,\n+                        \"In function {} ({:?})\",\n+                        function_name.name.display(db.upcast()),\n+                        func\n+                    )?;\n                 }\n                 Either::Right(clos) => {\n                     writeln!(f, \"In {:?}\", clos)?;\n@@ -349,7 +354,7 @@ impl MirEvalError {\n                 writeln!(\n                     f,\n                     \"Generic arg not provided for {}\",\n-                    param.name().unwrap_or(&Name::missing())\n+                    param.name().unwrap_or(&Name::missing()).display(db.upcast())\n                 )?;\n                 writeln!(f, \"Provided args: [\")?;\n                 for g in subst.iter(Interner) {\n@@ -362,7 +367,8 @@ impl MirEvalError {\n                 writeln!(\n                     f,\n                     \"MIR lowering for function `{}` ({:?}) failed due:\",\n-                    function_name.name, func\n+                    function_name.name.display(db.upcast()),\n+                    func\n                 )?;\n                 err.pretty_print(f, db, span_formatter)?;\n             }\n@@ -2070,7 +2076,11 @@ impl Evaluator<'_> {\n             Ok(r) => Ok(r),\n             Err(e) => {\n                 let data = self.db.enum_data(variant.parent);\n-                let name = format!(\"{}::{}\", data.name, data.variants[variant.local_id].name);\n+                let name = format!(\n+                    \"{}::{}\",\n+                    data.name.display(self.db.upcast()),\n+                    data.variants[variant.local_id].name.display(self.db.upcast())\n+                );\n                 Err(MirEvalError::ConstEvalError(name, Box::new(e)))\n             }\n         }"}, {"sha": "6a9d3c5b4f3f70c1d78ac4656fa57ce853b192cb", "filename": "crates/hir-ty/src/mir/eval/tests.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Feval%2Ftests.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -13,7 +13,7 @@ fn eval_main(db: &TestDB, file_id: FileId) -> Result<(String, String), MirEvalEr\n         .declarations()\n         .find_map(|x| match x {\n             hir_def::ModuleDefId::FunctionId(x) => {\n-                if db.function_data(x).name.to_string() == \"main\" {\n+                if db.function_data(x).name.display(db).to_string() == \"main\" {\n                     Some(x)\n                 } else {\n                     None"}, {"sha": "b77e2c1c80193e7c26f75494bf2d46a6cc34cfd7", "filename": "crates/hir-ty/src/mir/lower.rs", "status": "modified", "additions": 16, "deletions": 8, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Flower.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -619,7 +619,7 @@ impl<'ctx> MirLowerCtx<'ctx> {\n             }\n             Expr::MethodCall { receiver, args, method_name, .. } => {\n                 let (func_id, generic_args) =\n-                    self.infer.method_resolution(expr_id).ok_or_else(|| MirLowerError::UnresolvedMethod(format!(\"{}\", method_name)))?;\n+                    self.infer.method_resolution(expr_id).ok_or_else(|| MirLowerError::UnresolvedMethod(method_name.display(self.db.upcast()).to_string()))?;\n                 let func = Operand::from_fn(self.db, func_id, generic_args);\n                 self.lower_call_and_args(\n                     func,\n@@ -1614,7 +1614,11 @@ impl<'ctx> MirLowerCtx<'ctx> {\n             Ok(r) => Ok(r),\n             Err(e) => {\n                 let data = self.db.enum_data(variant.parent);\n-                let name = format!(\"{}::{}\", data.name, data.variants[variant.local_id].name);\n+                let name = format!(\n+                    \"{}::{}\",\n+                    data.name.display(self.db.upcast()),\n+                    data.variants[variant.local_id].name.display(self.db.upcast())\n+                );\n                 Err(MirLowerError::ConstEvalError(name, Box::new(e)))\n             }\n         }\n@@ -1766,13 +1770,17 @@ pub fn mir_body_for_closure_query(\n \n pub fn mir_body_query(db: &dyn HirDatabase, def: DefWithBodyId) -> Result<Arc<MirBody>> {\n     let _p = profile::span(\"mir_body_query\").detail(|| match def {\n-        DefWithBodyId::FunctionId(it) => db.function_data(it).name.to_string(),\n-        DefWithBodyId::StaticId(it) => db.static_data(it).name.clone().to_string(),\n-        DefWithBodyId::ConstId(it) => {\n-            db.const_data(it).name.clone().unwrap_or_else(Name::missing).to_string()\n-        }\n+        DefWithBodyId::FunctionId(it) => db.function_data(it).name.display(db.upcast()).to_string(),\n+        DefWithBodyId::StaticId(it) => db.static_data(it).name.display(db.upcast()).to_string(),\n+        DefWithBodyId::ConstId(it) => db\n+            .const_data(it)\n+            .name\n+            .clone()\n+            .unwrap_or_else(Name::missing)\n+            .display(db.upcast())\n+            .to_string(),\n         DefWithBodyId::VariantId(it) => {\n-            db.enum_data(it.parent).variants[it.local_id].name.to_string()\n+            db.enum_data(it.parent).variants[it.local_id].name.display(db.upcast()).to_string()\n         }\n     });\n     let body = db.body(def);"}, {"sha": "3821e6a59c2d744c32a9c14151267b0f6fba5fac", "filename": "crates/hir-ty/src/mir/pretty.rs", "status": "modified", "additions": 33, "deletions": 14, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fhir-ty%2Fsrc%2Fmir%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fhir-ty%2Fsrc%2Fmir%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Fmir%2Fpretty.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -42,19 +42,23 @@ impl MirBody {\n         ctx.for_body(|this| match ctx.body.owner {\n             hir_def::DefWithBodyId::FunctionId(id) => {\n                 let data = db.function_data(id);\n-                w!(this, \"fn {}() \", data.name);\n+                w!(this, \"fn {}() \", data.name.display(db.upcast()));\n             }\n             hir_def::DefWithBodyId::StaticId(id) => {\n                 let data = db.static_data(id);\n-                w!(this, \"static {}: _ = \", data.name);\n+                w!(this, \"static {}: _ = \", data.name.display(db.upcast()));\n             }\n             hir_def::DefWithBodyId::ConstId(id) => {\n                 let data = db.const_data(id);\n-                w!(this, \"const {}: _ = \", data.name.as_ref().unwrap_or(&Name::missing()));\n+                w!(\n+                    this,\n+                    \"const {}: _ = \",\n+                    data.name.as_ref().unwrap_or(&Name::missing()).display(db.upcast())\n+                );\n             }\n             hir_def::DefWithBodyId::VariantId(id) => {\n                 let data = db.enum_data(id.parent);\n-                w!(this, \"enum {} = \", data.name);\n+                w!(this, \"enum {} = \", data.name.display(db.upcast()));\n             }\n         });\n         ctx.result\n@@ -99,11 +103,16 @@ enum LocalName {\n     Binding(Name, LocalId),\n }\n \n-impl Display for LocalName {\n-    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+impl HirDisplay for LocalName {\n+    fn hir_fmt(\n+        &self,\n+        f: &mut crate::display::HirFormatter<'_>,\n+    ) -> Result<(), crate::display::HirDisplayError> {\n         match self {\n             LocalName::Unknown(l) => write!(f, \"_{}\", u32::from(l.into_raw())),\n-            LocalName::Binding(n, l) => write!(f, \"{n}_{}\", u32::from(l.into_raw())),\n+            LocalName::Binding(n, l) => {\n+                write!(f, \"{}_{}\", n.display(f.db.upcast()), u32::from(l.into_raw()))\n+            }\n         }\n     }\n }\n@@ -177,7 +186,12 @@ impl<'a> MirPrettyCtx<'a> {\n \n     fn locals(&mut self) {\n         for (id, local) in self.body.locals.iter() {\n-            wln!(self, \"let {}: {};\", self.local_name(id), self.hir_display(&local.ty));\n+            wln!(\n+                self,\n+                \"let {}: {};\",\n+                self.local_name(id).display(self.db),\n+                self.hir_display(&local.ty)\n+            );\n         }\n     }\n \n@@ -206,10 +220,10 @@ impl<'a> MirPrettyCtx<'a> {\n                             wln!(this, \";\");\n                         }\n                         StatementKind::StorageDead(p) => {\n-                            wln!(this, \"StorageDead({})\", this.local_name(*p));\n+                            wln!(this, \"StorageDead({})\", this.local_name(*p).display(self.db));\n                         }\n                         StatementKind::StorageLive(p) => {\n-                            wln!(this, \"StorageLive({})\", this.local_name(*p));\n+                            wln!(this, \"StorageLive({})\", this.local_name(*p).display(self.db));\n                         }\n                         StatementKind::Deinit(p) => {\n                             w!(this, \"Deinit(\");\n@@ -267,7 +281,7 @@ impl<'a> MirPrettyCtx<'a> {\n         fn f(this: &mut MirPrettyCtx<'_>, local: LocalId, projections: &[PlaceElem]) {\n             let Some((last, head)) = projections.split_last() else {\n                 // no projection\n-                w!(this, \"{}\", this.local_name(local));\n+                w!(this, \"{}\", this.local_name(local).display(this.db));\n                 return;\n             };\n             match last {\n@@ -285,11 +299,16 @@ impl<'a> MirPrettyCtx<'a> {\n                             f(this, local, head);\n                             let variant_name =\n                                 &this.db.enum_data(e.parent).variants[e.local_id].name;\n-                            w!(this, \" as {}).{}\", variant_name, name);\n+                            w!(\n+                                this,\n+                                \" as {}).{}\",\n+                                variant_name.display(this.db.upcast()),\n+                                name.display(this.db.upcast())\n+                            );\n                         }\n                         hir_def::VariantId::StructId(_) | hir_def::VariantId::UnionId(_) => {\n                             f(this, local, head);\n-                            w!(this, \".{name}\");\n+                            w!(this, \".{}\", name.display(this.db.upcast()));\n                         }\n                     }\n                 }\n@@ -299,7 +318,7 @@ impl<'a> MirPrettyCtx<'a> {\n                 }\n                 ProjectionElem::Index(l) => {\n                     f(this, local, head);\n-                    w!(this, \"[{}]\", this.local_name(*l));\n+                    w!(this, \"[{}]\", this.local_name(*l).display(this.db));\n                 }\n                 x => {\n                     f(this, local, head);"}, {"sha": "83814ed0ec1f199b91bbb73ee907ecebe800060f", "filename": "crates/hir-ty/src/tls.rs", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fhir-ty%2Fsrc%2Ftls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fhir-ty%2Fsrc%2Ftls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftls.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -24,7 +24,8 @@ impl DebugContext<'_> {\n             AdtId::UnionId(it) => self.0.union_data(it).name.clone(),\n             AdtId::EnumId(it) => self.0.enum_data(it).name.clone(),\n         };\n-        name.fmt(f)\n+        name.display(self.0.upcast()).fmt(f)?;\n+        Ok(())\n     }\n \n     pub(crate) fn debug_trait_id(\n@@ -34,7 +35,8 @@ impl DebugContext<'_> {\n     ) -> Result<(), fmt::Error> {\n         let trait_: hir_def::TraitId = from_chalk_trait_id(id);\n         let trait_data = self.0.trait_data(trait_);\n-        trait_data.name.fmt(f)\n+        trait_data.name.display(self.0.upcast()).fmt(f)?;\n+        Ok(())\n     }\n \n     pub(crate) fn debug_assoc_type_id(\n@@ -49,7 +51,13 @@ impl DebugContext<'_> {\n             _ => panic!(\"associated type not in trait\"),\n         };\n         let trait_data = self.0.trait_data(trait_);\n-        write!(fmt, \"{}::{}\", trait_data.name, type_alias_data.name)\n+        write!(\n+            fmt,\n+            \"{}::{}\",\n+            trait_data.name.display(self.0.upcast()),\n+            type_alias_data.name.display(self.0.upcast())\n+        )?;\n+        Ok(())\n     }\n \n     pub(crate) fn debug_projection_ty(\n@@ -67,15 +75,15 @@ impl DebugContext<'_> {\n         let trait_ref = projection_ty.trait_ref(self.0);\n         let trait_params = trait_ref.substitution.as_slice(Interner);\n         let self_ty = trait_ref.self_type_parameter(Interner);\n-        write!(fmt, \"<{self_ty:?} as {trait_name}\")?;\n+        write!(fmt, \"<{self_ty:?} as {}\", trait_name.display(self.0.upcast()))?;\n         if trait_params.len() > 1 {\n             write!(\n                 fmt,\n                 \"<{}>\",\n                 trait_params[1..].iter().format_with(\", \", |x, f| f(&format_args!(\"{x:?}\"))),\n             )?;\n         }\n-        write!(fmt, \">::{}\", type_alias_data.name)?;\n+        write!(fmt, \">::{}\", type_alias_data.name.display(self.0.upcast()))?;\n \n         let proj_params_count = projection_ty.substitution.len(Interner) - trait_params.len();\n         let proj_params = &projection_ty.substitution.as_slice(Interner)[..proj_params_count];\n@@ -105,9 +113,9 @@ impl DebugContext<'_> {\n             }\n         };\n         match def {\n-            CallableDefId::FunctionId(_) => write!(fmt, \"{{fn {name}}}\"),\n+            CallableDefId::FunctionId(_) => write!(fmt, \"{{fn {}}}\", name.display(self.0.upcast())),\n             CallableDefId::StructId(_) | CallableDefId::EnumVariantId(_) => {\n-                write!(fmt, \"{{ctor {name}}}\")\n+                write!(fmt, \"{{ctor {}}}\", name.display(self.0.upcast()))\n             }\n         }\n     }"}, {"sha": "d2ca6e5ed7c8f2d790e1faefae4bb2b4a5d2933c", "filename": "crates/hir-ty/src/traits.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fhir-ty%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fhir-ty%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir-ty%2Fsrc%2Ftraits.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -88,7 +88,7 @@ pub(crate) fn trait_solve_query(\n ) -> Option<Solution> {\n     let _p = profile::span(\"trait_solve_query\").detail(|| match &goal.value.goal.data(Interner) {\n         GoalData::DomainGoal(DomainGoal::Holds(WhereClause::Implemented(it))) => {\n-            db.trait_data(it.hir_trait_id()).name.to_string()\n+            db.trait_data(it.hir_trait_id()).name.display(db.upcast()).to_string()\n         }\n         GoalData::DomainGoal(DomainGoal::Holds(WhereClause::AliasEq(_))) => \"alias_eq\".to_string(),\n         _ => \"??\".to_string(),"}, {"sha": "0c8793c6df0316ab6022521bef39b0f4cd785b95", "filename": "crates/hir/src/display.rs", "status": "modified", "additions": 31, "deletions": 26, "changes": 57, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fhir%2Fsrc%2Fdisplay.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fhir%2Fsrc%2Fdisplay.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Fdisplay.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -51,7 +51,7 @@ impl HirDisplay for Function {\n             // FIXME: String escape?\n             write!(f, \"extern \\\"{}\\\" \", &**abi)?;\n         }\n-        write!(f, \"fn {}\", data.name)?;\n+        write!(f, \"fn {}\", data.name.display(f.db.upcast()))?;\n \n         write_generic_params(GenericDefId::FunctionId(self.id), f)?;\n \n@@ -63,7 +63,7 @@ impl HirDisplay for Function {\n             {\n                 f.write_char('&')?;\n                 if let Some(lifetime) = lifetime {\n-                    write!(f, \"{} \", lifetime.name)?;\n+                    write!(f, \"{} \", lifetime.name.display(f.db.upcast()))?;\n                 }\n                 if let hir_def::type_ref::Mutability::Mut = mut_ {\n                     f.write_str(\"mut \")?;\n@@ -90,7 +90,7 @@ impl HirDisplay for Function {\n                 }\n             }\n             match local {\n-                Some(name) => write!(f, \"{name}: \")?,\n+                Some(name) => write!(f, \"{}: \", name.display(f.db.upcast()))?,\n                 None => f.write_str(\"_: \")?,\n             }\n             type_ref.hir_fmt(f)?;\n@@ -151,7 +151,7 @@ impl HirDisplay for Struct {\n     fn hir_fmt(&self, f: &mut HirFormatter<'_>) -> Result<(), HirDisplayError> {\n         write_visibility(self.module(f.db).id, self.visibility(f.db), f)?;\n         f.write_str(\"struct \")?;\n-        write!(f, \"{}\", self.name(f.db))?;\n+        write!(f, \"{}\", self.name(f.db).display(f.db.upcast()))?;\n         let def_id = GenericDefId::AdtId(AdtId::StructId(self.id));\n         write_generic_params(def_id, f)?;\n         write_where_clause(def_id, f)?;\n@@ -163,7 +163,7 @@ impl HirDisplay for Enum {\n     fn hir_fmt(&self, f: &mut HirFormatter<'_>) -> Result<(), HirDisplayError> {\n         write_visibility(self.module(f.db).id, self.visibility(f.db), f)?;\n         f.write_str(\"enum \")?;\n-        write!(f, \"{}\", self.name(f.db))?;\n+        write!(f, \"{}\", self.name(f.db).display(f.db.upcast()))?;\n         let def_id = GenericDefId::AdtId(AdtId::EnumId(self.id));\n         write_generic_params(def_id, f)?;\n         write_where_clause(def_id, f)?;\n@@ -175,7 +175,7 @@ impl HirDisplay for Union {\n     fn hir_fmt(&self, f: &mut HirFormatter<'_>) -> Result<(), HirDisplayError> {\n         write_visibility(self.module(f.db).id, self.visibility(f.db), f)?;\n         f.write_str(\"union \")?;\n-        write!(f, \"{}\", self.name(f.db))?;\n+        write!(f, \"{}\", self.name(f.db).display(f.db.upcast()))?;\n         let def_id = GenericDefId::AdtId(AdtId::UnionId(self.id));\n         write_generic_params(def_id, f)?;\n         write_where_clause(def_id, f)?;\n@@ -186,14 +186,14 @@ impl HirDisplay for Union {\n impl HirDisplay for Field {\n     fn hir_fmt(&self, f: &mut HirFormatter<'_>) -> Result<(), HirDisplayError> {\n         write_visibility(self.parent.module(f.db).id, self.visibility(f.db), f)?;\n-        write!(f, \"{}: \", self.name(f.db))?;\n+        write!(f, \"{}: \", self.name(f.db).display(f.db.upcast()))?;\n         self.ty(f.db).hir_fmt(f)\n     }\n }\n \n impl HirDisplay for Variant {\n     fn hir_fmt(&self, f: &mut HirFormatter<'_>) -> Result<(), HirDisplayError> {\n-        write!(f, \"{}\", self.name(f.db))?;\n+        write!(f, \"{}\", self.name(f.db).display(f.db.upcast()))?;\n         let data = self.variant_data(f.db);\n         match &*data {\n             VariantData::Unit => {}\n@@ -222,7 +222,7 @@ impl HirDisplay for Variant {\n                         f.write_str(\", \")?;\n                     }\n                     // Enum variant fields must be pub.\n-                    write!(f, \"{}: \", field.name)?;\n+                    write!(f, \"{}: \", field.name.display(f.db.upcast()))?;\n                     field.type_ref.hir_fmt(f)?;\n                 }\n                 f.write_str(\" }\")?;\n@@ -259,7 +259,7 @@ impl HirDisplay for TypeOrConstParam {\n \n impl HirDisplay for TypeParam {\n     fn hir_fmt(&self, f: &mut HirFormatter<'_>) -> Result<(), HirDisplayError> {\n-        write!(f, \"{}\", self.name(f.db))?;\n+        write!(f, \"{}\", self.name(f.db).display(f.db.upcast()))?;\n         if f.omit_verbose_types() {\n             return Ok(());\n         }\n@@ -286,13 +286,13 @@ impl HirDisplay for TypeParam {\n \n impl HirDisplay for LifetimeParam {\n     fn hir_fmt(&self, f: &mut HirFormatter<'_>) -> Result<(), HirDisplayError> {\n-        write!(f, \"{}\", self.name(f.db))\n+        write!(f, \"{}\", self.name(f.db).display(f.db.upcast()))\n     }\n }\n \n impl HirDisplay for ConstParam {\n     fn hir_fmt(&self, f: &mut HirFormatter<'_>) -> Result<(), HirDisplayError> {\n-        write!(f, \"const {}: \", self.name(f.db))?;\n+        write!(f, \"const {}: \", self.name(f.db).display(f.db.upcast()))?;\n         self.ty(f.db).hir_fmt(f)\n     }\n }\n@@ -325,7 +325,7 @@ fn write_generic_params(\n     };\n     for (_, lifetime) in params.lifetimes.iter() {\n         delim(f)?;\n-        write!(f, \"{}\", lifetime.name)?;\n+        write!(f, \"{}\", lifetime.name.display(f.db.upcast()))?;\n     }\n     for (_, ty) in params.type_or_consts.iter() {\n         if let Some(name) = &ty.name() {\n@@ -335,15 +335,15 @@ fn write_generic_params(\n                         continue;\n                     }\n                     delim(f)?;\n-                    write!(f, \"{name}\")?;\n+                    write!(f, \"{}\", name.display(f.db.upcast()))?;\n                     if let Some(default) = &ty.default {\n                         f.write_str(\" = \")?;\n                         default.hir_fmt(f)?;\n                     }\n                 }\n                 TypeOrConstParamData::ConstParamData(c) => {\n                     delim(f)?;\n-                    write!(f, \"const {name}: \")?;\n+                    write!(f, \"const {}: \", name.display(f.db.upcast()))?;\n                     c.ty.hir_fmt(f)?;\n                 }\n             }\n@@ -380,7 +380,7 @@ fn write_where_clause(def: GenericDefId, f: &mut HirFormatter<'_>) -> Result<(),\n         WherePredicateTypeTarget::TypeRef(ty) => ty.hir_fmt(f),\n         WherePredicateTypeTarget::TypeOrConstParam(id) => {\n             match &params.type_or_consts[*id].name() {\n-                Some(name) => write!(f, \"{name}\"),\n+                Some(name) => write!(f, \"{}\", name.display(f.db.upcast())),\n                 None => f.write_str(\"{unnamed}\"),\n             }\n         }\n@@ -412,10 +412,15 @@ fn write_where_clause(def: GenericDefId, f: &mut HirFormatter<'_>) -> Result<(),\n             WherePredicate::Lifetime { target, bound } => {\n                 if matches!(prev_pred, Some(WherePredicate::Lifetime { target: target_, .. }) if target_ == target)\n                 {\n-                    write!(f, \" + {}\", bound.name)?;\n+                    write!(f, \" + {}\", bound.name.display(f.db.upcast()))?;\n                 } else {\n                     new_predicate(f)?;\n-                    write!(f, \"{}: {}\", target.name, bound.name)?;\n+                    write!(\n+                        f,\n+                        \"{}: {}\",\n+                        target.name.display(f.db.upcast()),\n+                        bound.name.display(f.db.upcast())\n+                    )?;\n                 }\n             }\n             WherePredicate::ForLifetime { lifetimes, target, bound } => {\n@@ -432,7 +437,7 @@ fn write_where_clause(def: GenericDefId, f: &mut HirFormatter<'_>) -> Result<(),\n                         if idx != 0 {\n                             f.write_str(\", \")?;\n                         }\n-                        write!(f, \"{lifetime}\")?;\n+                        write!(f, \"{}\", lifetime.display(f.db.upcast()))?;\n                     }\n                     f.write_str(\"> \")?;\n                     write_target(target, f)?;\n@@ -462,7 +467,7 @@ impl HirDisplay for Const {\n         let data = db.const_data(self.id);\n         f.write_str(\"const \")?;\n         match &data.name {\n-            Some(name) => write!(f, \"{name}: \")?,\n+            Some(name) => write!(f, \"{}: \", name.display(f.db.upcast()))?,\n             None => f.write_str(\"_: \")?,\n         }\n         data.type_ref.hir_fmt(f)?;\n@@ -478,7 +483,7 @@ impl HirDisplay for Static {\n         if data.mutable {\n             f.write_str(\"mut \")?;\n         }\n-        write!(f, \"{}: \", &data.name)?;\n+        write!(f, \"{}: \", data.name.display(f.db.upcast()))?;\n         data.type_ref.hir_fmt(f)?;\n         Ok(())\n     }\n@@ -494,7 +499,7 @@ impl HirDisplay for Trait {\n         if data.is_auto {\n             f.write_str(\"auto \")?;\n         }\n-        write!(f, \"trait {}\", data.name)?;\n+        write!(f, \"trait {}\", data.name.display(f.db.upcast()))?;\n         let def_id = GenericDefId::TraitId(self.id);\n         write_generic_params(def_id, f)?;\n         write_where_clause(def_id, f)?;\n@@ -506,7 +511,7 @@ impl HirDisplay for TraitAlias {\n     fn hir_fmt(&self, f: &mut HirFormatter<'_>) -> Result<(), HirDisplayError> {\n         write_visibility(self.module(f.db).id, self.visibility(f.db), f)?;\n         let data = f.db.trait_alias_data(self.id);\n-        write!(f, \"trait {}\", data.name)?;\n+        write!(f, \"trait {}\", data.name.display(f.db.upcast()))?;\n         let def_id = GenericDefId::TraitAliasId(self.id);\n         write_generic_params(def_id, f)?;\n         f.write_str(\" = \")?;\n@@ -522,7 +527,7 @@ impl HirDisplay for TypeAlias {\n     fn hir_fmt(&self, f: &mut HirFormatter<'_>) -> Result<(), HirDisplayError> {\n         write_visibility(self.module(f.db).id, self.visibility(f.db), f)?;\n         let data = f.db.type_alias_data(self.id);\n-        write!(f, \"type {}\", data.name)?;\n+        write!(f, \"type {}\", data.name.display(f.db.upcast()))?;\n         let def_id = GenericDefId::TypeAliasId(self.id);\n         write_generic_params(def_id, f)?;\n         write_where_clause(def_id, f)?;\n@@ -542,7 +547,7 @@ impl HirDisplay for Module {\n     fn hir_fmt(&self, f: &mut HirFormatter<'_>) -> Result<(), HirDisplayError> {\n         // FIXME: Module doesn't have visibility saved in data.\n         match self.name(f.db) {\n-            Some(name) => write!(f, \"mod {name}\"),\n+            Some(name) => write!(f, \"mod {}\", name.display(f.db.upcast())),\n             None if self.is_crate_root(f.db) => match self.krate(f.db).display_name(f.db) {\n                 Some(name) => write!(f, \"extern crate {name}\"),\n                 None => f.write_str(\"extern crate {unknown}\"),\n@@ -559,6 +564,6 @@ impl HirDisplay for Macro {\n             hir_def::MacroId::MacroRulesId(_) => f.write_str(\"macro_rules!\"),\n             hir_def::MacroId::ProcMacroId(_) => f.write_str(\"proc_macro\"),\n         }?;\n-        write!(f, \" {}\", self.name(f.db))\n+        write!(f, \" {}\", self.name(f.db).display(f.db.upcast()))\n     }\n }"}, {"sha": "64f97452769d227f0f05c73788c8d6851b305be2", "filename": "crates/hir/src/lib.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fhir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fhir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir%2Fsrc%2Flib.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -329,7 +329,7 @@ impl ModuleDef {\n             segments.extend(m.name(db))\n         }\n         segments.reverse();\n-        Some(segments.into_iter().join(\"::\"))\n+        Some(segments.iter().map(|it| it.display(db.upcast())).join(\"::\"))\n     }\n \n     pub fn canonical_module_path(\n@@ -555,7 +555,11 @@ impl Module {\n     /// Fills `acc` with the module's diagnostics.\n     pub fn diagnostics(self, db: &dyn HirDatabase, acc: &mut Vec<AnyDiagnostic>) {\n         let _p = profile::span(\"Module::diagnostics\").detail(|| {\n-            format!(\"{:?}\", self.name(db).map_or(\"<unknown>\".into(), |name| name.to_string()))\n+            format!(\n+                \"{:?}\",\n+                self.name(db)\n+                    .map_or(\"<unknown>\".into(), |name| name.display(db.upcast()).to_string())\n+            )\n         });\n         let def_map = self.id.def_map(db.upcast());\n         for diag in def_map.diagnostics() {"}, {"sha": "6340feda452e14f1545fe70baf88621581d26d72", "filename": "crates/ide-assists/src/handlers/add_missing_impl_members.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fadd_missing_impl_members.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -184,7 +184,8 @@ fn try_gen_trait_body(\n     trait_ref: hir::TraitRef,\n     impl_def: &ast::Impl,\n ) -> Option<()> {\n-    let trait_path = make::ext::ident_path(&trait_ref.trait_().name(ctx.db()).to_string());\n+    let trait_path =\n+        make::ext::ident_path(&trait_ref.trait_().name(ctx.db()).display(ctx.db()).to_string());\n     let hir_ty = ctx.sema.resolve_type(&impl_def.self_ty()?)?;\n     let adt = hir_ty.as_adt()?.source(ctx.db())?;\n     gen_trait_fn_body(func, &trait_path, &adt.value, Some(trait_ref))"}, {"sha": "7acf2ea0a0de64bf75ff1b9738e4a41afd618d59", "filename": "crates/ide-assists/src/handlers/auto_import.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fauto_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fauto_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fauto_import.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -132,7 +132,7 @@ pub(crate) fn auto_import(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<\n         acc.add_group(\n             &group_label,\n             AssistId(\"auto_import\", AssistKind::QuickFix),\n-            format!(\"Import `{import_path}`\"),\n+            format!(\"Import `{}`\", import_path.display(ctx.db())),\n             range,\n             |builder| {\n                 let scope = match scope.clone() {"}, {"sha": "1af52c592183d4e7f7b403eb2b99c06c5dfca87e", "filename": "crates/ide-assists/src/handlers/convert_bool_then.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_bool_then.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_bool_then.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_bool_then.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -160,7 +160,7 @@ pub(crate) fn convert_bool_then_to_if(acc: &mut Assists, ctx: &AssistContext<'_>\n     };\n     // Verify this is `bool::then` that is being called.\n     let func = ctx.sema.resolve_method_call(&mcall)?;\n-    if func.name(ctx.sema.db).to_string() != \"then\" {\n+    if func.name(ctx.sema.db).display(ctx.db()).to_string() != \"then\" {\n         return None;\n     }\n     let assoc = func.as_assoc_item(ctx.sema.db)?;"}, {"sha": "db96c8fe40aa585329679309d674c48ab19c1dbc", "filename": "crates/ide-assists/src/handlers/convert_iter_for_each_to_for.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_iter_for_each_to_for.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_iter_for_each_to_for.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fconvert_iter_for_each_to_for.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -119,7 +119,7 @@ pub(crate) fn convert_for_loop_with_for_each(\n             {\n                 // We have either \"for x in &col\" and col implements a method called iter\n                 //             or \"for x in &mut col\" and col implements a method called iter_mut\n-                format_to!(buf, \"{expr_behind_ref}.{method}()\");\n+                format_to!(buf, \"{expr_behind_ref}.{}()\", method.display(ctx.db()));\n             } else if let ast::Expr::RangeExpr(..) = iterable {\n                 // range expressions need to be parenthesized for the syntax to be correct\n                 format_to!(buf, \"({iterable})\");"}, {"sha": "5c435dd9c2960ae852d619d7afa86f461c3b7a88", "filename": "crates/ide-assists/src/handlers/expand_glob_import.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fexpand_glob_import.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fexpand_glob_import.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fexpand_glob_import.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -65,7 +65,7 @@ pub(crate) fn expand_glob_import(acc: &mut Assists, ctx: &AssistContext<'_>) ->\n \n             let names_to_import = find_names_to_import(ctx, refs_in_target, imported_defs);\n             let expanded = make::use_tree_list(names_to_import.iter().map(|n| {\n-                let path = make::ext::ident_path(&n.to_string());\n+                let path = make::ext::ident_path(&n.display(ctx.db()).to_string());\n                 make::use_tree(path, None, None, false)\n             }))\n             .clone_for_update();"}, {"sha": "62cc7488298ad06940be862d46c7b8579c67c2e4", "filename": "crates/ide-assists/src/handlers/extract_function.rs", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_function.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -183,7 +183,9 @@ pub(crate) fn extract_function(acc: &mut Assists, ctx: &AssistContext<'_>) -> Op\n \n fn make_function_name(semantics_scope: &hir::SemanticsScope<'_>) -> ast::NameRef {\n     let mut names_in_scope = vec![];\n-    semantics_scope.process_all_names(&mut |name, _| names_in_scope.push(name.to_string()));\n+    semantics_scope.process_all_names(&mut |name, _| {\n+        names_in_scope.push(name.display(semantics_scope.db.upcast()).to_string())\n+    });\n \n     let default_name = \"fun_name\";\n \n@@ -443,7 +445,7 @@ impl Param {\n     }\n \n     fn to_param(&self, ctx: &AssistContext<'_>, module: hir::Module) -> ast::Param {\n-        let var = self.var.name(ctx.db()).to_string();\n+        let var = self.var.name(ctx.db()).display(ctx.db()).to_string();\n         let var_name = make::name(&var);\n         let pat = match self.kind() {\n             ParamKind::MutValue => make::ident_pat(false, true, var_name),\n@@ -473,7 +475,8 @@ impl TryKind {\n         let name = adt.name(ctx.db());\n         // FIXME: use lang items to determine if it is std type or user defined\n         //        E.g. if user happens to define type named `Option`, we would have false positive\n-        match name.to_string().as_str() {\n+        let name = &name.display(ctx.db()).to_string();\n+        match name.as_str() {\n             \"Option\" => Some(TryKind::Option),\n             \"Result\" => Some(TryKind::Result { ty }),\n             _ => None,\n@@ -1341,14 +1344,15 @@ fn make_call(ctx: &AssistContext<'_>, fun: &Function, indent: IndentLevel) -> St\n         [var] => {\n             let modifier = mut_modifier(var);\n             let name = var.local.name(ctx.db());\n-            format_to!(buf, \"let {modifier}{name} = \")\n+            format_to!(buf, \"let {modifier}{} = \", name.display(ctx.db()))\n         }\n         vars => {\n             buf.push_str(\"let (\");\n             let bindings = vars.iter().format_with(\", \", |local, f| {\n                 let modifier = mut_modifier(local);\n                 let name = local.local.name(ctx.db());\n-                f(&format_args!(\"{modifier}{name}\"))\n+                f(&format_args!(\"{modifier}{}\", name.display(ctx.db())))?;\n+                Ok(())\n             });\n             format_to!(buf, \"{bindings}\");\n             buf.push_str(\") = \");\n@@ -1487,7 +1491,7 @@ impl FlowHandler {\n }\n \n fn path_expr_from_local(ctx: &AssistContext<'_>, var: Local) -> ast::Expr {\n-    let name = var.name(ctx.db()).to_string();\n+    let name = var.name(ctx.db()).display(ctx.db()).to_string();\n     make::expr_path(make::ext::ident_path(&name))\n }\n "}, {"sha": "de37f5f130fca9bdf167cfbb8bb63c9ea6e63829", "filename": "crates/ide-assists/src/handlers/extract_module.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_module.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_module.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_module.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -904,7 +904,7 @@ fn compare_hir_and_ast_module(\n ) -> Option<()> {\n     let hir_mod_name = hir_module.name(ctx.db())?;\n     let ast_mod_name = ast_module.name()?;\n-    if hir_mod_name.to_string() != ast_mod_name.to_string() {\n+    if hir_mod_name.display(ctx.db()).to_string() != ast_mod_name.to_string() {\n         return None;\n     }\n "}, {"sha": "e4f64ccc754e099233e3e6237cbc807a61e65bc3", "filename": "crates/ide-assists/src/handlers/extract_struct_from_enum_variant.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fextract_struct_from_enum_variant.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -158,7 +158,7 @@ fn existing_definition(db: &RootDatabase, variant_name: &ast::Name, variant: &Va\n             ),\n             _ => false,\n         })\n-        .any(|(name, _)| name.to_string() == variant_name.to_string())\n+        .any(|(name, _)| name.display(db).to_string() == variant_name.to_string())\n }\n \n fn extract_generic_params("}, {"sha": "d6c59a9c829503d14a3891d057830d2525e59bb0", "filename": "crates/ide-assists/src/handlers/fix_visibility.rs", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-assists%2Fsrc%2Fhandlers%2Ffix_visibility.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-assists%2Fsrc%2Fhandlers%2Ffix_visibility.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Ffix_visibility.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -62,7 +62,9 @@ fn add_vis_to_referenced_module_def(acc: &mut Assists, ctx: &AssistContext<'_>)\n \n     let assist_label = match target_name {\n         None => format!(\"Change visibility to {missing_visibility}\"),\n-        Some(name) => format!(\"Change visibility of {name} to {missing_visibility}\"),\n+        Some(name) => {\n+            format!(\"Change visibility of {} to {missing_visibility}\", name.display(ctx.db()))\n+        }\n     };\n \n     acc.add(AssistId(\"fix_visibility\", AssistKind::QuickFix), assist_label, target, |builder| {\n@@ -117,8 +119,11 @@ fn add_vis_to_referenced_record_field(acc: &mut Assists, ctx: &AssistContext<'_>\n     let target_file = in_file_source.file_id.original_file(ctx.db());\n \n     let target_name = record_field_def.name(ctx.db());\n-    let assist_label =\n-        format!(\"Change visibility of {parent_name}.{target_name} to {missing_visibility}\");\n+    let assist_label = format!(\n+        \"Change visibility of {}.{} to {missing_visibility}\",\n+        parent_name.display(ctx.db()),\n+        target_name.display(ctx.db())\n+    );\n \n     acc.add(AssistId(\"fix_visibility\", AssistKind::QuickFix), assist_label, target, |builder| {\n         builder.edit_file(target_file);"}, {"sha": "c6d0ebd7022f0e606c48300ea45019e761d024ac", "filename": "crates/ide-assists/src/handlers/generate_delegate_methods.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_delegate_methods.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_delegate_methods.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_delegate_methods.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -85,13 +85,16 @@ pub(crate) fn generate_delegate_methods(acc: &mut Assists, ctx: &AssistContext<'\n \n     for method in methods {\n         let adt = ast::Adt::Struct(strukt.clone());\n-        let name = method.name(ctx.db()).to_string();\n+        let name = method.name(ctx.db()).display(ctx.db()).to_string();\n         // if `find_struct_impl` returns None, that means that a function named `name` already exists.\n         let Some(impl_def) = find_struct_impl(ctx, &adt, &[name]) else { continue; };\n         acc.add_group(\n             &GroupLabel(\"Generate delegate methods\u2026\".to_owned()),\n             AssistId(\"generate_delegate_methods\", AssistKind::Generate),\n-            format!(\"Generate delegate for `{field_name}.{}()`\", method.name(ctx.db())),\n+            format!(\n+                \"Generate delegate for `{field_name}.{}()`\",\n+                method.name(ctx.db()).display(ctx.db())\n+            ),\n             target,\n             |builder| {\n                 // Create the function\n@@ -101,7 +104,7 @@ pub(crate) fn generate_delegate_methods(acc: &mut Assists, ctx: &AssistContext<'\n                 };\n                 let method_name = method.name(ctx.db());\n                 let vis = method_source.visibility();\n-                let name = make::name(&method.name(ctx.db()).to_string());\n+                let name = make::name(&method.name(ctx.db()).display(ctx.db()).to_string());\n                 let params =\n                     method_source.param_list().unwrap_or_else(|| make::param_list(None, []));\n                 let type_params = method_source.generic_param_list();\n@@ -111,7 +114,7 @@ pub(crate) fn generate_delegate_methods(acc: &mut Assists, ctx: &AssistContext<'\n                 };\n                 let tail_expr = make::expr_method_call(\n                     make::ext::field_from_idents([\"self\", &field_name]).unwrap(), // This unwrap is ok because we have at least 1 arg in the list\n-                    make::name_ref(&method_name.to_string()),\n+                    make::name_ref(&method_name.display(ctx.db()).to_string()),\n                     arg_list,\n                 );\n                 let ret_type = method_source.ret_type();"}, {"sha": "81545396175bae58a4c91e6d189286047a5f4078", "filename": "crates/ide-assists/src/handlers/generate_deref.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_deref.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_deref.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_deref.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -70,6 +70,7 @@ fn generate_record_deref(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<(\n         target,\n         |edit| {\n             generate_edit(\n+                ctx.db(),\n                 edit,\n                 strukt,\n                 field_type.syntax(),\n@@ -109,6 +110,7 @@ fn generate_tuple_deref(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()\n         target,\n         |edit| {\n             generate_edit(\n+                ctx.db(),\n                 edit,\n                 strukt,\n                 field_type.syntax(),\n@@ -121,6 +123,7 @@ fn generate_tuple_deref(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option<()\n }\n \n fn generate_edit(\n+    db: &RootDatabase,\n     edit: &mut SourceChangeBuilder,\n     strukt: ast::Struct,\n     field_type_syntax: &SyntaxNode,\n@@ -144,7 +147,8 @@ fn generate_edit(\n         ),\n     };\n     let strukt_adt = ast::Adt::Struct(strukt);\n-    let deref_impl = generate_trait_impl_text(&strukt_adt, &trait_path.to_string(), &impl_code);\n+    let deref_impl =\n+        generate_trait_impl_text(&strukt_adt, &trait_path.display(db).to_string(), &impl_code);\n     edit.insert(start_offset, deref_impl);\n }\n "}, {"sha": "4634cfc189c5b55b4ed8d5ccc8e5a0f039cecc33", "filename": "crates/ide-assists/src/handlers/generate_function.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fgenerate_function.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -196,7 +196,7 @@ fn add_func_to_accumulator(\n         let mut func = function_template.to_string(ctx.config.snippet_cap);\n         if let Some(name) = adt_name {\n             // FIXME: adt may have generic params.\n-            func = format!(\"\\n{indent}impl {name} {{\\n{func}\\n{indent}}}\");\n+            func = format!(\"\\n{indent}impl {} {{\\n{func}\\n{indent}}}\", name.display(ctx.db()));\n         }\n         builder.edit_file(file);\n         match ctx.config.snippet_cap {"}, {"sha": "b6027eac55dee7a5cbb803253bd912ec86c7f7a8", "filename": "crates/ide-assists/src/handlers/move_const_to_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_const_to_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_const_to_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_const_to_impl.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -98,7 +98,7 @@ pub(crate) fn move_const_to_impl(acc: &mut Assists, ctx: &AssistContext<'_>) ->\n             };\n             builder.delete(range_to_delete);\n \n-            let const_ref = format!(\"Self::{name}\");\n+            let const_ref = format!(\"Self::{}\", name.display(ctx.db()));\n             for range in usages.all().file_ranges().map(|it| it.range) {\n                 builder.replace(range, const_ref.clone());\n             }"}, {"sha": "917d0b3671e8eec85cf3cb49b70c2885d5cca99b", "filename": "crates/ide-assists/src/handlers/move_from_mod_rs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_from_mod_rs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_from_mod_rs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_from_mod_rs.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -39,7 +39,7 @@ pub(crate) fn move_from_mod_rs(acc: &mut Assists, ctx: &AssistContext<'_>) -> Op\n     }\n \n     let target = source_file.syntax().text_range();\n-    let module_name = module.name(ctx.db())?.to_string();\n+    let module_name = module.name(ctx.db())?.display(ctx.db()).to_string();\n     let path = format!(\"../{module_name}.rs\");\n     let dst = AnchoredPathBuf { anchor: ctx.file_id(), path };\n     acc.add("}, {"sha": "166b25c69e188b55334d36ef5b2367464d3171e9", "filename": "crates/ide-assists/src/handlers/move_module_to_file.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_module_to_file.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_module_to_file.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_module_to_file.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -52,7 +52,7 @@ pub(crate) fn move_module_to_file(acc: &mut Assists, ctx: &AssistContext<'_>) ->\n                 let mut buf = String::from(\"./\");\n                 match parent_module.name(ctx.db()) {\n                     Some(name) if !parent_module.is_mod_rs(ctx.db()) => {\n-                        format_to!(buf, \"{name}/\")\n+                        format_to!(buf, \"{}/\", name.display(ctx.db()))\n                     }\n                     _ => (),\n                 }"}, {"sha": "b73270cd05fb5259658385d6ff2bfefd22e8ad57", "filename": "crates/ide-assists/src/handlers/move_to_mod_rs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_to_mod_rs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_to_mod_rs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fmove_to_mod_rs.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -39,7 +39,7 @@ pub(crate) fn move_to_mod_rs(acc: &mut Assists, ctx: &AssistContext<'_>) -> Opti\n     }\n \n     let target = source_file.syntax().text_range();\n-    let module_name = module.name(ctx.db())?.to_string();\n+    let module_name = module.name(ctx.db())?.display(ctx.db()).to_string();\n     let path = format!(\"./{module_name}/mod.rs\");\n     let dst = AnchoredPathBuf { anchor: ctx.file_id(), path };\n     acc.add("}, {"sha": "239149dc411d6c065e0a1c8112748f261bd711ef", "filename": "crates/ide-assists/src/handlers/qualify_path.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fqualify_path.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fqualify_path.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Fqualify_path.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -86,7 +86,7 @@ pub(crate) fn qualify_path(acc: &mut Assists, ctx: &AssistContext<'_>) -> Option\n         acc.add_group(\n             &group_label,\n             AssistId(\"qualify_path\", AssistKind::QuickFix),\n-            label(candidate, &import),\n+            label(ctx.db(), candidate, &import),\n             range,\n             |builder| {\n                 qualify_candidate.qualify(\n@@ -186,7 +186,7 @@ fn find_trait_method(\n     if let Some(hir::AssocItem::Function(method)) =\n         trait_.items(db).into_iter().find(|item: &hir::AssocItem| {\n             item.name(db)\n-                .map(|name| name.to_string() == trait_method_name.to_string())\n+                .map(|name| name.display(db).to_string() == trait_method_name.to_string())\n                 .unwrap_or(false)\n         })\n     {\n@@ -216,14 +216,14 @@ fn group_label(candidate: &ImportCandidate) -> GroupLabel {\n     GroupLabel(format!(\"Qualify {name}\"))\n }\n \n-fn label(candidate: &ImportCandidate, import: &LocatedImport) -> String {\n+fn label(db: &RootDatabase, candidate: &ImportCandidate, import: &LocatedImport) -> String {\n     let import_path = &import.import_path;\n \n     match candidate {\n         ImportCandidate::Path(candidate) if candidate.qualifier.is_none() => {\n-            format!(\"Qualify as `{import_path}`\")\n+            format!(\"Qualify as `{}`\", import_path.display(db))\n         }\n-        _ => format!(\"Qualify with `{import_path}`\"),\n+        _ => format!(\"Qualify with `{}`\", import_path.display(db)),\n     }\n }\n "}, {"sha": "02562566977400d0f3fbad36b25d43d483c08bf9", "filename": "crates/ide-assists/src/handlers/reorder_fields.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freorder_fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freorder_fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freorder_fields.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -97,7 +97,7 @@ fn compute_fields_ranks(\n         .fields(ctx.db())\n         .into_iter()\n         .enumerate()\n-        .map(|(idx, field)| (field.name(ctx.db()).to_string(), idx))\n+        .map(|(idx, field)| (field.name(ctx.db()).display(ctx.db()).to_string(), idx))\n         .collect();\n \n     Some(res)"}, {"sha": "66669662316fef39e6a2f272599fd44d6b938717", "filename": "crates/ide-assists/src/handlers/reorder_impl_items.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freorder_impl_items.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freorder_impl_items.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Fhandlers%2Freorder_impl_items.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -114,7 +114,7 @@ fn compute_item_ranks(\n             .iter()\n             .flat_map(|i| i.name(ctx.db()))\n             .enumerate()\n-            .map(|(idx, name)| (name.to_string(), idx))\n+            .map(|(idx, name)| (name.display(ctx.db()).to_string(), idx))\n             .collect(),\n     )\n }"}, {"sha": "f74ebfae02c77423b88f5384d509288af2cd95d7", "filename": "crates/ide-assists/src/utils/suggest_name.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-assists%2Fsrc%2Futils%2Fsuggest_name.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-assists%2Fsrc%2Futils%2Fsuggest_name.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-assists%2Fsrc%2Futils%2Fsuggest_name.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -234,7 +234,7 @@ fn from_type(expr: &ast::Expr, sema: &Semantics<'_, RootDatabase>) -> Option<Str\n \n fn name_of_type(ty: &hir::Type, db: &RootDatabase) -> Option<String> {\n     let name = if let Some(adt) = ty.as_adt() {\n-        let name = adt.name(db).to_string();\n+        let name = adt.name(db).display(db).to_string();\n \n         if WRAPPER_TYPES.contains(&name.as_str()) {\n             let inner_ty = ty.type_arguments().next()?;\n@@ -258,7 +258,7 @@ fn name_of_type(ty: &hir::Type, db: &RootDatabase) -> Option<String> {\n }\n \n fn trait_name(trait_: &hir::Trait, db: &RootDatabase) -> Option<String> {\n-    let name = trait_.name(db).to_string();\n+    let name = trait_.name(db).display(db).to_string();\n     if USELESS_TRAITS.contains(&name.as_str()) {\n         return None;\n     }"}, {"sha": "d53e9e2fa90788e4196393e7cb4b1ac27dc6630e", "filename": "crates/ide-completion/src/completions.rs", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-completion%2Fsrc%2Fcompletions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-completion%2Fsrc%2Fcompletions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -24,7 +24,7 @@ pub(crate) mod env_vars;\n use std::iter;\n \n use hir::{known, HasAttrs, ScopeDef, Variant};\n-use ide_db::{imports::import_assets::LocatedImport, SymbolKind};\n+use ide_db::{imports::import_assets::LocatedImport, RootDatabase, SymbolKind};\n use syntax::ast;\n \n use crate::{\n@@ -62,8 +62,8 @@ impl From<Completions> for Vec<CompletionItem> {\n impl Builder {\n     /// Convenience method, which allows to add a freshly created completion into accumulator\n     /// without binding it to the variable.\n-    pub(crate) fn add_to(self, acc: &mut Completions) {\n-        acc.add(self.build())\n+    pub(crate) fn add_to(self, acc: &mut Completions, db: &RootDatabase) {\n+        acc.add(self.build(db))\n     }\n }\n \n@@ -80,7 +80,7 @@ impl Completions {\n \n     pub(crate) fn add_keyword(&mut self, ctx: &CompletionContext<'_>, keyword: &'static str) {\n         let item = CompletionItem::new(CompletionItemKind::Keyword, ctx.source_range(), keyword);\n-        item.add_to(self);\n+        item.add_to(self, ctx.db);\n     }\n \n     pub(crate) fn add_nameref_keywords_with_colon(&mut self, ctx: &CompletionContext<'_>) {\n@@ -134,7 +134,7 @@ impl Completions {\n                 item.insert_text(if snippet.contains('$') { kw } else { snippet });\n             }\n         };\n-        item.add_to(self);\n+        item.add_to(self, ctx.db);\n     }\n \n     pub(crate) fn add_keyword_snippet(\n@@ -149,7 +149,7 @@ impl Completions {\n             Some(cap) => item.insert_snippet(cap, snippet),\n             None => item.insert_text(if snippet.contains('$') { kw } else { snippet }),\n         };\n-        item.add_to(self);\n+        item.add_to(self, ctx.db);\n     }\n \n     pub(crate) fn add_crate_roots(\n@@ -190,7 +190,7 @@ impl Completions {\n                 local_name,\n                 resolution,\n             )\n-            .build(),\n+            .build(ctx.db),\n         );\n     }\n \n@@ -216,7 +216,7 @@ impl Completions {\n                 local_name,\n                 resolution,\n             )\n-            .build(),\n+            .build(ctx.db),\n         );\n     }\n \n@@ -276,7 +276,7 @@ impl Completions {\n                 local_name,\n                 mac,\n             )\n-            .build(),\n+            .build(ctx.db),\n         );\n     }\n \n@@ -305,7 +305,7 @@ impl Completions {\n                 local_name,\n                 func,\n             )\n-            .build(),\n+            .build(ctx.db),\n         );\n     }\n \n@@ -336,7 +336,7 @@ impl Completions {\n                 local_name,\n                 func,\n             )\n-            .build(),\n+            .build(ctx.db),\n         );\n     }\n \n@@ -367,7 +367,7 @@ impl Completions {\n                 None,\n                 func,\n             )\n-            .build(),\n+            .build(ctx.db),\n         );\n     }\n \n@@ -429,7 +429,7 @@ impl Completions {\n         if let Some(builder) =\n             render_variant_lit(RenderContext::new(ctx), path_ctx, None, variant, Some(path))\n         {\n-            self.add(builder.build());\n+            self.add(builder.build(ctx.db));\n         }\n     }\n \n@@ -452,7 +452,7 @@ impl Completions {\n         if let Some(builder) =\n             render_variant_lit(RenderContext::new(ctx), path_ctx, local_name, variant, None)\n         {\n-            self.add(builder.build());\n+            self.add(builder.build(ctx.db));\n         }\n     }\n \n@@ -497,7 +497,7 @@ impl Completions {\n         if let Some(builder) =\n             render_struct_literal(RenderContext::new(ctx), path_ctx, strukt, path, local_name)\n         {\n-            self.add(builder.build());\n+            self.add(builder.build(ctx.db));\n         }\n     }\n \n@@ -530,11 +530,12 @@ impl Completions {\n \n     pub(crate) fn add_lifetime(&mut self, ctx: &CompletionContext<'_>, name: hir::Name) {\n         CompletionItem::new(SymbolKind::LifetimeParam, ctx.source_range(), name.to_smol_str())\n-            .add_to(self)\n+            .add_to(self, ctx.db)\n     }\n \n     pub(crate) fn add_label(&mut self, ctx: &CompletionContext<'_>, name: hir::Name) {\n-        CompletionItem::new(SymbolKind::Label, ctx.source_range(), name.to_smol_str()).add_to(self)\n+        CompletionItem::new(SymbolKind::Label, ctx.source_range(), name.to_smol_str())\n+            .add_to(self, ctx.db)\n     }\n \n     pub(crate) fn add_variant_pat("}, {"sha": "466f0b1fb7f9b29d7f2444e602d12236ae4d45c1", "filename": "crates/ide-completion/src/completions/attribute.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -139,7 +139,7 @@ pub(crate) fn complete_attribute_path(\n         }\n \n         if is_inner || !attr_completion.prefer_inner {\n-            item.add_to(acc);\n+            item.add_to(acc, ctx.db);\n         }\n     };\n "}, {"sha": "19bfd294b25cc2a1229a73b6fb55318d8d4c46c0", "filename": "crates/ide-completion/src/completions/attribute/cfg.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute%2Fcfg.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute%2Fcfg.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute%2Fcfg.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -12,7 +12,7 @@ pub(crate) fn complete_cfg(acc: &mut Completions, ctx: &CompletionContext<'_>) {\n     let add_completion = |item: &str| {\n         let mut completion = CompletionItem::new(SymbolKind::BuiltinAttr, ctx.source_range(), item);\n         completion.insert_text(format!(r#\"\"{item}\"\"#));\n-        acc.add(completion.build());\n+        acc.add(completion.build(ctx.db));\n     };\n \n     let previous = iter::successors(ctx.original_token.prev_token(), |t| {\n@@ -33,11 +33,11 @@ pub(crate) fn complete_cfg(acc: &mut Completions, ctx: &CompletionContext<'_>) {\n             let mut item = CompletionItem::new(SymbolKind::BuiltinAttr, ctx.source_range(), s);\n             item.insert_text(insert_text);\n \n-            acc.add(item.build());\n+            acc.add(item.build(ctx.db));\n         }),\n         None => ctx.krate.potential_cfg(ctx.db).get_cfg_keys().cloned().unique().for_each(|s| {\n             let item = CompletionItem::new(SymbolKind::BuiltinAttr, ctx.source_range(), s);\n-            acc.add(item.build());\n+            acc.add(item.build(ctx.db));\n         }),\n     };\n }"}, {"sha": "9447bc7db0a79989467dbce50c87c4cda588185e", "filename": "crates/ide-completion/src/completions/attribute/derive.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute%2Fderive.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute%2Fderive.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute%2Fderive.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -90,7 +90,7 @@ pub(crate) fn complete_derive_path(\n                             item.documentation(docs);\n                         }\n                         item.lookup_by(lookup);\n-                        item.add_to(acc);\n+                        item.add_to(acc, ctx.db);\n                     }\n                     None => acc.add_macro(ctx, path_ctx, mac, name),\n                 }"}, {"sha": "6bc6f34ed41b30f27b679bfcb635216d495d051f", "filename": "crates/ide-completion/src/completions/attribute/lint.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute%2Flint.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute%2Flint.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute%2Flint.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -56,6 +56,6 @@ pub(super) fn complete_lint(\n         };\n         let mut item = CompletionItem::new(SymbolKind::Attribute, ctx.source_range(), label);\n         item.documentation(hir::Documentation::new(description.to_owned()));\n-        item.add_to(acc)\n+        item.add_to(acc, ctx.db)\n     }\n }"}, {"sha": "14f464b7753d7dbf7c8289bcf0469461a386448a", "filename": "crates/ide-completion/src/completions/attribute/repr.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute%2Frepr.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute%2Frepr.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fattribute%2Frepr.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -37,7 +37,7 @@ pub(super) fn complete_repr(\n             if let Some((snippet, cap)) = snippet.zip(ctx.config.snippet_cap) {\n                 item.insert_snippet(cap, snippet);\n             }\n-            item.add_to(acc);\n+            item.add_to(acc, ctx.db);\n         }\n     }\n }"}, {"sha": "57a784c45b6142e092ed861ebf2ecfe821bcad85", "filename": "crates/ide-completion/src/completions/dot.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fdot.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fdot.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fdot.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -23,7 +23,7 @@ pub(crate) fn complete_dot(\n         let mut item =\n             CompletionItem::new(CompletionItemKind::Keyword, ctx.source_range(), \"await\");\n         item.detail(\"expr.await\");\n-        item.add_to(acc);\n+        item.add_to(acc, ctx.db);\n     }\n \n     if let DotAccessKind::Method { .. } = dot_access.kind {"}, {"sha": "419b86456555989aea06baa1a90bd0af9feecf97", "filename": "crates/ide-completion/src/completions/env_vars.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fenv_vars.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fenv_vars.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fenv_vars.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -40,7 +40,7 @@ pub(crate) fn complete_cargo_env_vars(\n     CARGO_DEFINED_VARS.into_iter().for_each(|&(var, detail)| {\n         let mut item = CompletionItem::new(CompletionItemKind::Keyword, range, var);\n         item.detail(detail);\n-        item.add_to(acc);\n+        item.add_to(acc, ctx.db);\n     });\n \n     Some(())"}, {"sha": "c717a9cb55b8e8373ad95ff1f937808f155bcdf2", "filename": "crates/ide-completion/src/completions/extern_abi.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fextern_abi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fextern_abi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fextern_abi.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -42,7 +42,7 @@ const SUPPORTED_CALLING_CONVENTIONS: &[&str] = &[\n \n pub(crate) fn complete_extern_abi(\n     acc: &mut Completions,\n-    _ctx: &CompletionContext<'_>,\n+    ctx: &CompletionContext<'_>,\n     expanded: &ast::String,\n ) -> Option<()> {\n     if !expanded.syntax().parent().map_or(false, |it| ast::Abi::can_cast(it.kind())) {\n@@ -51,7 +51,7 @@ pub(crate) fn complete_extern_abi(\n     let abi_str = expanded;\n     let source_range = abi_str.text_range_between_quotes()?;\n     for &abi in SUPPORTED_CALLING_CONVENTIONS {\n-        CompletionItem::new(CompletionItemKind::Keyword, source_range, abi).add_to(acc);\n+        CompletionItem::new(CompletionItemKind::Keyword, source_range, abi).add_to(acc, ctx.db);\n     }\n     Some(())\n }"}, {"sha": "39c1b7f7b3fb4846a7bd87a39c054279abebb0db", "filename": "crates/ide-completion/src/completions/flyimport.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fflyimport.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fflyimport.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -273,7 +273,7 @@ fn import_on_the_fly(\n         .filter_map(|import| {\n             render_resolution_with_import(RenderContext::new(ctx), path_ctx, import)\n         })\n-        .map(|builder| builder.build())\n+        .map(|builder| builder.build(ctx.db))\n         .for_each(|item| acc.add(item));\n     Some(())\n }\n@@ -315,7 +315,7 @@ fn import_on_the_fly_pat_(\n         .filter_map(|import| {\n             render_resolution_with_import_pat(RenderContext::new(ctx), pattern_ctx, import)\n         })\n-        .map(|builder| builder.build())\n+        .map(|builder| builder.build(ctx.db))\n         .for_each(|item| acc.add(item));\n     Some(())\n }"}, {"sha": "8b38d4f01f6730d04aa252504dba3e9a97abaf72", "filename": "crates/ide-completion/src/completions/fn_param.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-completion%2Fsrc%2Fcompletions%2Ffn_param.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-completion%2Fsrc%2Fcompletions%2Ffn_param.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Ffn_param.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -40,7 +40,7 @@ pub(crate) fn complete_fn_param(\n         };\n         // Completion lookup is omitted intentionally here.\n         // See the full discussion: https://github.com/rust-lang/rust-analyzer/issues/12073\n-        item.add_to(acc)\n+        item.add_to(acc, ctx.db)\n     };\n \n     match kind {\n@@ -50,7 +50,7 @@ pub(crate) fn complete_fn_param(\n         ParamKind::Closure(closure) => {\n             let stmt_list = closure.syntax().ancestors().find_map(ast::StmtList::cast)?;\n             params_from_stmt_list_scope(ctx, stmt_list, |name, ty| {\n-                add_new_item_to_acc(&format!(\"{name}: {ty}\"));\n+                add_new_item_to_acc(&format!(\"{}: {ty}\", name.display(ctx.db)));\n             });\n         }\n     }\n@@ -100,7 +100,9 @@ fn fill_fn_params(\n \n     if let Some(stmt_list) = function.syntax().parent().and_then(ast::StmtList::cast) {\n         params_from_stmt_list_scope(ctx, stmt_list, |name, ty| {\n-            file_params.entry(format!(\"{name}: {ty}\")).or_insert(name.to_string());\n+            file_params\n+                .entry(format!(\"{}: {ty}\", name.display(ctx.db)))\n+                .or_insert(name.display(ctx.db).to_string());\n         });\n     }\n     remove_duplicated(&mut file_params, param_list.params());"}, {"sha": "8e904fd605a8dbc6b5fb301ab4a70c062f3a173a", "filename": "crates/ide-completion/src/completions/format_string.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fformat_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fformat_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fformat_string.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -32,7 +32,7 @@ pub(crate) fn format_string(\n     let source_range = TextRange::new(brace_offset, cursor);\n     ctx.locals.iter().for_each(|(name, _)| {\n         CompletionItem::new(CompletionItemKind::Binding, source_range, name.to_smol_str())\n-            .add_to(acc);\n+            .add_to(acc, ctx.db);\n     })\n }\n "}, {"sha": "7de1bf2dc131fccaa31a5c2b99be4f3135e4bc27", "filename": "crates/ide-completion/src/completions/item_list/trait_impl.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list%2Ftrait_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list%2Ftrait_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fitem_list%2Ftrait_impl.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -182,7 +182,7 @@ fn add_function_impl(\n \n     let label = format!(\n         \"fn {}({})\",\n-        fn_name,\n+        fn_name.display(ctx.db),\n         if func.assoc_fn_params(ctx.db).is_empty() { \"\" } else { \"..\" }\n     );\n \n@@ -193,7 +193,7 @@ fn add_function_impl(\n     };\n \n     let mut item = CompletionItem::new(completion_kind, replacement_range, label);\n-    item.lookup_by(format!(\"fn {fn_name}\"))\n+    item.lookup_by(format!(\"fn {}\", fn_name.display(ctx.db)))\n         .set_documentation(func.docs(ctx.db))\n         .set_relevance(CompletionRelevance { is_item_from_trait: true, ..Default::default() });\n \n@@ -216,7 +216,7 @@ fn add_function_impl(\n                     item.text_edit(TextEdit::replace(replacement_range, header));\n                 }\n             };\n-            item.add_to(acc);\n+            item.add_to(acc, ctx.db);\n         }\n     }\n }\n@@ -300,7 +300,7 @@ fn add_type_alias_impl(\n                     item.text_edit(TextEdit::replace(replacement_range, decl));\n                 }\n             };\n-            item.add_to(acc);\n+            item.add_to(acc, ctx.db);\n         }\n     }\n }\n@@ -340,7 +340,7 @@ fn add_const_impl(\n                     ),\n                     None => item.text_edit(TextEdit::replace(replacement_range, replacement)),\n                 };\n-                item.add_to(acc);\n+                item.add_to(acc, ctx.db);\n             }\n         }\n     }"}, {"sha": "d3e75c6da4761df4b4ae50bc5518dbbee40fda9c", "filename": "crates/ide-completion/src/completions/mod_.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fmod_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fmod_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fmod_.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -52,7 +52,7 @@ pub(crate) fn complete_mod(\n \n     let existing_mod_declarations = current_module\n         .children(ctx.db)\n-        .filter_map(|module| Some(module.name(ctx.db)?.to_string()))\n+        .filter_map(|module| Some(module.name(ctx.db)?.display(ctx.db).to_string()))\n         .filter(|module| module != ctx.original_token.text())\n         .collect::<FxHashSet<_>>();\n \n@@ -99,7 +99,7 @@ pub(crate) fn complete_mod(\n                 label.push(';');\n             }\n             let item = CompletionItem::new(SymbolKind::Module, ctx.source_range(), &label);\n-            item.add_to(acc)\n+            item.add_to(acc, ctx.db)\n         });\n \n     Some(())"}, {"sha": "2ffe123374471a4a73b53fb725914e5421c10d66", "filename": "crates/ide-completion/src/completions/postfix.rs", "status": "modified", "additions": 25, "deletions": 22, "changes": 47, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fpostfix.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fpostfix.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fpostfix.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -64,7 +64,7 @@ pub(crate) fn complete_postfix(\n                     &format!(\"drop($0{receiver_text})\"),\n                 );\n                 item.set_documentation(drop_fn.docs(ctx.db));\n-                item.add_to(acc);\n+                item.add_to(acc, ctx.db);\n             }\n         }\n     }\n@@ -78,50 +78,50 @@ pub(crate) fn complete_postfix(\n                     \"if let Ok {}\",\n                     &format!(\"if let Ok($1) = {receiver_text} {{\\n    $0\\n}}\"),\n                 )\n-                .add_to(acc);\n+                .add_to(acc, ctx.db);\n \n                 postfix_snippet(\n                     \"while\",\n                     \"while let Ok {}\",\n                     &format!(\"while let Ok($1) = {receiver_text} {{\\n    $0\\n}}\"),\n                 )\n-                .add_to(acc);\n+                .add_to(acc, ctx.db);\n             }\n             TryEnum::Option => {\n                 postfix_snippet(\n                     \"ifl\",\n                     \"if let Some {}\",\n                     &format!(\"if let Some($1) = {receiver_text} {{\\n    $0\\n}}\"),\n                 )\n-                .add_to(acc);\n+                .add_to(acc, ctx.db);\n \n                 postfix_snippet(\n                     \"while\",\n                     \"while let Some {}\",\n                     &format!(\"while let Some($1) = {receiver_text} {{\\n    $0\\n}}\"),\n                 )\n-                .add_to(acc);\n+                .add_to(acc, ctx.db);\n             }\n         }\n     } else if receiver_ty.is_bool() || receiver_ty.is_unknown() {\n         postfix_snippet(\"if\", \"if expr {}\", &format!(\"if {receiver_text} {{\\n    $0\\n}}\"))\n-            .add_to(acc);\n+            .add_to(acc, ctx.db);\n         postfix_snippet(\"while\", \"while expr {}\", &format!(\"while {receiver_text} {{\\n    $0\\n}}\"))\n-            .add_to(acc);\n-        postfix_snippet(\"not\", \"!expr\", &format!(\"!{receiver_text}\")).add_to(acc);\n+            .add_to(acc, ctx.db);\n+        postfix_snippet(\"not\", \"!expr\", &format!(\"!{receiver_text}\")).add_to(acc, ctx.db);\n     } else if let Some(trait_) = ctx.famous_defs().core_iter_IntoIterator() {\n         if receiver_ty.impls_trait(ctx.db, trait_, &[]) {\n             postfix_snippet(\n                 \"for\",\n                 \"for ele in expr {}\",\n                 &format!(\"for ele in {receiver_text} {{\\n    $0\\n}}\"),\n             )\n-            .add_to(acc);\n+            .add_to(acc, ctx.db);\n         }\n     }\n \n-    postfix_snippet(\"ref\", \"&expr\", &format!(\"&{receiver_text}\")).add_to(acc);\n-    postfix_snippet(\"refm\", \"&mut expr\", &format!(\"&mut {receiver_text}\")).add_to(acc);\n+    postfix_snippet(\"ref\", \"&expr\", &format!(\"&{receiver_text}\")).add_to(acc, ctx.db);\n+    postfix_snippet(\"refm\", \"&mut expr\", &format!(\"&mut {receiver_text}\")).add_to(acc, ctx.db);\n \n     let mut unsafe_should_be_wrapped = true;\n     if dot_receiver.syntax().kind() == BLOCK_EXPR {\n@@ -137,7 +137,7 @@ pub(crate) fn complete_postfix(\n     } else {\n         format!(\"unsafe {receiver_text}\")\n     };\n-    postfix_snippet(\"unsafe\", \"unsafe {}\", &unsafe_completion_string).add_to(acc);\n+    postfix_snippet(\"unsafe\", \"unsafe {}\", &unsafe_completion_string).add_to(acc, ctx.db);\n \n     // The rest of the postfix completions create an expression that moves an argument,\n     // so it's better to consider references now to avoid breaking the compilation\n@@ -162,7 +162,7 @@ pub(crate) fn complete_postfix(\n                     \"match expr {}\",\n                     &format!(\"match {receiver_text} {{\\n    Ok(${{1:_}}) => {{$2}},\\n    Err(${{3:_}}) => {{$0}},\\n}}\"),\n                 )\n-                .add_to(acc);\n+                .add_to(acc, ctx.db);\n             }\n             TryEnum::Option => {\n                 postfix_snippet(\n@@ -172,7 +172,7 @@ pub(crate) fn complete_postfix(\n                         \"match {receiver_text} {{\\n    Some(${{1:_}}) => {{$2}},\\n    None => {{$0}},\\n}}\"\n                     ),\n                 )\n-                .add_to(acc);\n+                .add_to(acc, ctx.db);\n             }\n         },\n         None => {\n@@ -181,20 +181,23 @@ pub(crate) fn complete_postfix(\n                 \"match expr {}\",\n                 &format!(\"match {receiver_text} {{\\n    ${{1:_}} => {{$0}},\\n}}\"),\n             )\n-            .add_to(acc);\n+            .add_to(acc, ctx.db);\n         }\n     }\n \n-    postfix_snippet(\"box\", \"Box::new(expr)\", &format!(\"Box::new({receiver_text})\")).add_to(acc);\n-    postfix_snippet(\"dbg\", \"dbg!(expr)\", &format!(\"dbg!({receiver_text})\")).add_to(acc); // fixme\n-    postfix_snippet(\"dbgr\", \"dbg!(&expr)\", &format!(\"dbg!(&{receiver_text})\")).add_to(acc);\n-    postfix_snippet(\"call\", \"function(expr)\", &format!(\"${{1}}({receiver_text})\")).add_to(acc);\n+    postfix_snippet(\"box\", \"Box::new(expr)\", &format!(\"Box::new({receiver_text})\"))\n+        .add_to(acc, ctx.db);\n+    postfix_snippet(\"dbg\", \"dbg!(expr)\", &format!(\"dbg!({receiver_text})\")).add_to(acc, ctx.db); // fixme\n+    postfix_snippet(\"dbgr\", \"dbg!(&expr)\", &format!(\"dbg!(&{receiver_text})\")).add_to(acc, ctx.db);\n+    postfix_snippet(\"call\", \"function(expr)\", &format!(\"${{1}}({receiver_text})\"))\n+        .add_to(acc, ctx.db);\n \n     if let Some(parent) = dot_receiver.syntax().parent().and_then(|p| p.parent()) {\n         if matches!(parent.kind(), STMT_LIST | EXPR_STMT) {\n-            postfix_snippet(\"let\", \"let\", &format!(\"let $0 = {receiver_text};\")).add_to(acc);\n+            postfix_snippet(\"let\", \"let\", &format!(\"let $0 = {receiver_text};\"))\n+                .add_to(acc, ctx.db);\n             postfix_snippet(\"letm\", \"let mut\", &format!(\"let mut $0 = {receiver_text};\"))\n-                .add_to(acc);\n+                .add_to(acc, ctx.db);\n         }\n     }\n \n@@ -315,7 +318,7 @@ fn add_custom_postfix_completions(\n             for import in imports.into_iter() {\n                 builder.add_import(import);\n             }\n-            builder.add_to(acc);\n+            builder.add_to(acc, ctx.db);\n         },\n     );\n     None"}, {"sha": "cb242e4aa68695dda953bd1fc725af3a20b59e25", "filename": "crates/ide-completion/src/completions/postfix/format_like.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fpostfix%2Fformat_like.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fpostfix%2Fformat_like.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fpostfix%2Fformat_like.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -60,7 +60,7 @@ pub(crate) fn add_format_like_completions(\n                 format!(r#\"{}({}, {})\"#, macro_name, out, exprs.join(\", \"))\n             };\n \n-            postfix_snippet(label, macro_name, &snippet).add_to(acc);\n+            postfix_snippet(label, macro_name, &snippet).add_to(acc, ctx.db);\n         }\n     }\n }"}, {"sha": "945c3945bfa39c7e2f8bd00af2624ee18911e6e2", "filename": "crates/ide-completion/src/completions/record.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-completion%2Fsrc%2Fcompletions%2Frecord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-completion%2Fsrc%2Fcompletions%2Frecord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Frecord.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -69,7 +69,7 @@ pub(crate) fn complete_record_expr_fields(\n                 let mut item =\n                     CompletionItem::new(CompletionItemKind::Snippet, ctx.source_range(), \"..\");\n                 item.insert_text(\".\");\n-                item.add_to(acc);\n+                item.add_to(acc, ctx.db);\n                 return;\n             }\n             missing_fields\n@@ -98,7 +98,7 @@ pub(crate) fn add_default_update(\n             postfix_match: Some(CompletionRelevancePostfixMatch::Exact),\n             ..Default::default()\n         });\n-        item.add_to(acc);\n+        item.add_to(acc, ctx.db);\n     }\n }\n "}, {"sha": "e9831a5b2a1216c5ee4199cc519ff1e41b8c1f50", "filename": "crates/ide-completion/src/completions/snippet.rs", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fsnippet.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fsnippet.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fsnippet.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -32,8 +32,8 @@ pub(crate) fn complete_expr_snippet(\n     }\n \n     if in_block_expr {\n-        snippet(ctx, cap, \"pd\", \"eprintln!(\\\"$0 = {:?}\\\", $0);\").add_to(acc);\n-        snippet(ctx, cap, \"ppd\", \"eprintln!(\\\"$0 = {:#?}\\\", $0);\").add_to(acc);\n+        snippet(ctx, cap, \"pd\", \"eprintln!(\\\"$0 = {:?}\\\", $0);\").add_to(acc, ctx.db);\n+        snippet(ctx, cap, \"ppd\", \"eprintln!(\\\"$0 = {:#?}\\\", $0);\").add_to(acc, ctx.db);\n         let item = snippet(\n             ctx,\n             cap,\n@@ -45,7 +45,7 @@ macro_rules! $1 {\n     };\n }\",\n         );\n-        item.add_to(acc);\n+        item.add_to(acc, ctx.db);\n     }\n }\n \n@@ -88,7 +88,7 @@ mod tests {\n }\",\n         );\n         item.lookup_by(\"tmod\");\n-        item.add_to(acc);\n+        item.add_to(acc, ctx.db);\n \n         let mut item = snippet(\n             ctx,\n@@ -101,7 +101,7 @@ fn ${1:feature}() {\n }\",\n         );\n         item.lookup_by(\"tfn\");\n-        item.add_to(acc);\n+        item.add_to(acc, ctx.db);\n \n         let item = snippet(\n             ctx,\n@@ -114,7 +114,7 @@ macro_rules! $1 {\n     };\n }\",\n         );\n-        item.add_to(acc);\n+        item.add_to(acc, ctx.db);\n     }\n }\n \n@@ -146,7 +146,7 @@ fn add_custom_completions(\n                 builder.add_import(import);\n             }\n             builder.set_detail(snip.description.clone());\n-            builder.add_to(acc);\n+            builder.add_to(acc, ctx.db);\n         },\n     );\n     None"}, {"sha": "7a60030e9ef72bdab28ab9c0b4353e085d079954", "filename": "crates/ide-completion/src/completions/use_.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fuse_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fuse_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcompletions%2Fuse_.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -75,7 +75,7 @@ pub(crate) fn complete_use_path(\n                                 is_name_already_imported,\n                                 ..Default::default()\n                             });\n-                            acc.add(builder.build());\n+                            acc.add(builder.build(ctx.db));\n                         }\n                     }\n                 }\n@@ -108,9 +108,9 @@ pub(crate) fn complete_use_path(\n                             let item = CompletionItem::new(\n                                 CompletionItemKind::SymbolKind(SymbolKind::Enum),\n                                 ctx.source_range(),\n-                                format!(\"{}::\", e.name(ctx.db)),\n+                                format!(\"{}::\", e.name(ctx.db).display(ctx.db)),\n                             );\n-                            acc.add(item.build());\n+                            acc.add(item.build(ctx.db));\n                         }\n                     }\n                     _ => {}"}, {"sha": "cc5221cfccbdc35a5b8546efd076220bfc649705", "filename": "crates/ide-completion/src/context/analysis.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fcontext%2Fanalysis.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -1190,7 +1190,7 @@ fn pattern_context_for(\n                                     })\n                                 }).and_then(|variants| {\n                                    Some(variants.iter().filter_map(|variant| {\n-                                        let variant_name = variant.name(sema.db).to_string();\n+                                        let variant_name = variant.name(sema.db).display(sema.db).to_string();\n \n                                         let variant_already_present = match_arm_list.arms().any(|arm| {\n                                             arm.pat().and_then(|pat| {"}, {"sha": "e850f7bfdf3f90ff0e00199e3f7e57211583806a", "filename": "crates/ide-completion/src/item.rs", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-completion%2Fsrc%2Fitem.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-completion%2Fsrc%2Fitem.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Fitem.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -3,7 +3,7 @@\n use std::fmt;\n \n use hir::{Documentation, Mutability};\n-use ide_db::{imports::import_assets::LocatedImport, SnippetCap, SymbolKind};\n+use ide_db::{imports::import_assets::LocatedImport, RootDatabase, SnippetCap, SymbolKind};\n use itertools::Itertools;\n use smallvec::SmallVec;\n use stdx::{impl_from, never};\n@@ -76,7 +76,8 @@ pub struct CompletionItem {\n     pub ref_match: Option<(Mutability, TextSize)>,\n \n     /// The import data to add to completion's edits.\n-    pub import_to_add: SmallVec<[LocatedImport; 1]>,\n+    /// (ImportPath, LastSegment)\n+    pub import_to_add: SmallVec<[(String, String); 1]>,\n }\n \n // We use custom debug for CompletionItem to make snapshot tests more readable.\n@@ -418,7 +419,7 @@ impl Builder {\n         )\n     }\n \n-    pub(crate) fn build(self) -> CompletionItem {\n+    pub(crate) fn build(self, db: &RootDatabase) -> CompletionItem {\n         let _p = profile::span(\"item::Builder::build\");\n \n         let mut label = self.label;\n@@ -433,7 +434,7 @@ impl Builder {\n         if let [import_edit] = &*self.imports_to_add {\n             // snippets can have multiple imports, but normal completions only have up to one\n             if let Some(original_path) = import_edit.original_path.as_ref() {\n-                label = SmolStr::from(format!(\"{label} (use {original_path})\"));\n+                label = SmolStr::from(format!(\"{label} (use {})\", original_path.display(db)));\n             }\n         } else if let Some(trait_name) = self.trait_name {\n             label = SmolStr::from(format!(\"{label} (as {trait_name})\"));\n@@ -444,6 +445,17 @@ impl Builder {\n             None => TextEdit::replace(self.source_range, insert_text),\n         };\n \n+        let import_to_add = self\n+            .imports_to_add\n+            .into_iter()\n+            .filter_map(|import| {\n+                Some((\n+                    import.import_path.display(db).to_string(),\n+                    import.import_path.segments().last()?.display(db).to_string(),\n+                ))\n+            })\n+            .collect();\n+\n         CompletionItem {\n             source_range: self.source_range,\n             label,\n@@ -457,7 +469,7 @@ impl Builder {\n             trigger_call_info: self.trigger_call_info,\n             relevance: self.relevance,\n             ref_match: self.ref_match,\n-            import_to_add: self.imports_to_add,\n+            import_to_add,\n         }\n     }\n     pub(crate) fn lookup_by(&mut self, lookup: impl Into<SmolStr>) -> &mut Builder {"}, {"sha": "106d4e1e52f9a2f14d7659cfeb796d01101b8794", "filename": "crates/ide-completion/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-completion%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-completion%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Flib.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -243,7 +243,7 @@ pub fn resolve_completion_edits(\n                     config.prefer_no_std,\n                 )\n             })\n-            .find(|mod_path| mod_path.to_string() == full_import_path);\n+            .find(|mod_path| mod_path.display(db).to_string() == full_import_path);\n         if let Some(import_path) = import {\n             insert_use::insert_use(&new_ast, mod_path_to_ast(&import_path), &config.insert_use);\n         }"}, {"sha": "1953eb4795772a807b226248b2e78e16becca35e", "filename": "crates/ide-completion/src/render.rs", "status": "modified", "additions": 20, "deletions": 12, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-completion%2Fsrc%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-completion%2Fsrc%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Frender.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -126,24 +126,25 @@ pub(crate) fn render_field(\n     field: hir::Field,\n     ty: &hir::Type,\n ) -> CompletionItem {\n+    let db = ctx.db();\n     let is_deprecated = ctx.is_deprecated(field);\n-    let name = field.name(ctx.db());\n+    let name = field.name(db);\n     let (name, escaped_name) = (name.unescaped().to_smol_str(), name.to_smol_str());\n     let mut item = CompletionItem::new(\n         SymbolKind::Field,\n         ctx.source_range(),\n-        field_with_receiver(receiver.as_ref(), &name),\n+        field_with_receiver(db, receiver.as_ref(), &name),\n     );\n     item.set_relevance(CompletionRelevance {\n         type_match: compute_type_match(ctx.completion, ty),\n         exact_name_match: compute_exact_name_match(ctx.completion, name.as_str()),\n         ..CompletionRelevance::default()\n     });\n-    item.detail(ty.display(ctx.db()).to_string())\n-        .set_documentation(field.docs(ctx.db()))\n+    item.detail(ty.display(db).to_string())\n+        .set_documentation(field.docs(db))\n         .set_deprecated(is_deprecated)\n         .lookup_by(name);\n-    item.insert_text(field_with_receiver(receiver.as_ref(), &escaped_name));\n+    item.insert_text(field_with_receiver(db, receiver.as_ref(), &escaped_name));\n     if let Some(receiver) = &dot_access.receiver {\n         if let Some(original) = ctx.completion.sema.original_ast_node(receiver.clone()) {\n             if let Some(ref_match) = compute_ref_match(ctx.completion, ty) {\n@@ -152,11 +153,18 @@ pub(crate) fn render_field(\n         }\n     }\n     item.doc_aliases(ctx.doc_aliases);\n-    item.build()\n+    item.build(db)\n }\n \n-fn field_with_receiver(receiver: Option<&hir::Name>, field_name: &str) -> SmolStr {\n-    receiver.map_or_else(|| field_name.into(), |receiver| format!(\"{receiver}.{field_name}\").into())\n+fn field_with_receiver(\n+    db: &RootDatabase,\n+    receiver: Option<&hir::Name>,\n+    field_name: &str,\n+) -> SmolStr {\n+    receiver.map_or_else(\n+        || field_name.into(),\n+        |receiver| format!(\"{}.{field_name}\", receiver.display(db)).into(),\n+    )\n }\n \n pub(crate) fn render_tuple_field(\n@@ -168,10 +176,10 @@ pub(crate) fn render_tuple_field(\n     let mut item = CompletionItem::new(\n         SymbolKind::Field,\n         ctx.source_range(),\n-        field_with_receiver(receiver.as_ref(), &field.to_string()),\n+        field_with_receiver(ctx.db(), receiver.as_ref(), &field.to_string()),\n     );\n     item.detail(ty.display(ctx.db()).to_string()).lookup_by(field.to_string());\n-    item.build()\n+    item.build(ctx.db())\n }\n \n pub(crate) fn render_type_inference(\n@@ -181,7 +189,7 @@ pub(crate) fn render_type_inference(\n     let mut builder =\n         CompletionItem::new(CompletionItemKind::InferredType, ctx.source_range(), ty_string);\n     builder.set_relevance(CompletionRelevance { is_definite: true, ..Default::default() });\n-    builder.build()\n+    builder.build(ctx.db)\n }\n \n pub(crate) fn render_path_resolution(\n@@ -319,7 +327,7 @@ fn render_resolution_path(\n                 item.lookup_by(name.clone())\n                     .label(SmolStr::from_iter([&name, \"<\u2026>\"]))\n                     .trigger_call_info()\n-                    .insert_snippet(cap, format!(\"{local_name}<$0>\"));\n+                    .insert_snippet(cap, format!(\"{}<$0>\", local_name.display(db)));\n             }\n         }\n     }"}, {"sha": "3c73983c39a2befca4975aeb3d3f0a0092cf65fe", "filename": "crates/ide-completion/src/render/const_.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-completion%2Fsrc%2Frender%2Fconst_.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-completion%2Fsrc%2Frender%2Fconst_.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Frender%2Fconst_.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -29,5 +29,5 @@ fn render(ctx: RenderContext<'_>, const_: hir::Const) -> Option<CompletionItem>\n     }\n     item.insert_text(escaped_name);\n \n-    Some(item.build())\n+    Some(item.build(ctx.db()))\n }"}, {"sha": "8afce8db5ea86745f2b69e7731b440b3fb71340d", "filename": "crates/ide-completion/src/render/function.rs", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-completion%2Fsrc%2Frender%2Ffunction.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-completion%2Fsrc%2Frender%2Ffunction.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Frender%2Ffunction.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -52,8 +52,13 @@ fn render(\n \n     let (call, escaped_call) = match &func_kind {\n         FuncKind::Method(_, Some(receiver)) => (\n-            format!(\"{}.{}\", receiver.unescaped(), name.unescaped()).into(),\n-            format!(\"{receiver}.{name}\").into(),\n+            format!(\n+                \"{}.{}\",\n+                receiver.unescaped().display(ctx.db()),\n+                name.unescaped().display(ctx.db())\n+            )\n+            .into(),\n+            format!(\"{}.{}\", receiver.display(ctx.db()), name.display(ctx.db())).into(),\n         ),\n         _ => (name.unescaped().to_smol_str(), name.to_smol_str()),\n     };"}, {"sha": "728d236dff47612b90d74129f45ea349618eaa4b", "filename": "crates/ide-completion/src/render/literal.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-completion%2Fsrc%2Frender%2Fliteral.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-completion%2Fsrc%2Frender%2Fliteral.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Frender%2Fliteral.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -71,8 +71,10 @@ fn render(\n         }\n         None => (name.clone().into(), name.into(), false),\n     };\n-    let (qualified_name, escaped_qualified_name) =\n-        (qualified_name.unescaped().to_string(), qualified_name.to_string());\n+    let (qualified_name, escaped_qualified_name) = (\n+        qualified_name.unescaped().display(ctx.db()).to_string(),\n+        qualified_name.display(ctx.db()).to_string(),\n+    );\n     let snippet_cap = ctx.snippet_cap();\n \n     let mut rendered = match kind {\n@@ -98,7 +100,7 @@ fn render(\n     }\n     let label = format_literal_label(&qualified_name, kind, snippet_cap);\n     let lookup = if qualified {\n-        format_literal_lookup(&short_qualified_name.to_string(), kind)\n+        format_literal_lookup(&short_qualified_name.display(ctx.db()).to_string(), kind)\n     } else {\n         format_literal_lookup(&qualified_name, kind)\n     };"}, {"sha": "d06abc5e91e0bc4dddb70eb0ea65c26aaa977141", "filename": "crates/ide-completion/src/render/pattern.rs", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-completion%2Fsrc%2Frender%2Fpattern.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-completion%2Fsrc%2Frender%2Fpattern.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Frender%2Fpattern.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -57,7 +57,10 @@ pub(crate) fn render_variant_pat(\n     let enum_ty = variant.parent_enum(ctx.db()).ty(ctx.db());\n \n     let (name, escaped_name) = match path {\n-        Some(path) => (path.unescaped().to_string().into(), path.to_string().into()),\n+        Some(path) => (\n+            path.unescaped().display(ctx.db()).to_string().into(),\n+            path.display(ctx.db()).to_string().into(),\n+        ),\n         None => {\n             let name = local_name.unwrap_or_else(|| variant.name(ctx.db()));\n             (name.unescaped().to_smol_str(), name.to_smol_str())\n@@ -121,7 +124,7 @@ fn build_completion(\n         Some(snippet_cap) => item.insert_snippet(snippet_cap, pat),\n         None => item.insert_text(pat),\n     };\n-    item.build()\n+    item.build(ctx.db())\n }\n \n fn render_pat(\n@@ -172,7 +175,7 @@ fn render_record_as_pat(\n             format!(\n                 \"{name} {{ {}{} }}\",\n                 fields.enumerate().format_with(\", \", |(idx, field), f| {\n-                    f(&format_args!(\"{}${}\", field.name(db), idx + 1))\n+                    f(&format_args!(\"{}${}\", field.name(db).display(db.upcast()), idx + 1))\n                 }),\n                 if fields_omitted { \", ..\" } else { \"\" },\n                 name = name"}, {"sha": "343ba7e28d8e0bd975b438056d6d82d8e21d4ae2", "filename": "crates/ide-completion/src/render/type_alias.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-completion%2Fsrc%2Frender%2Ftype_alias.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-completion%2Fsrc%2Frender%2Ftype_alias.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Frender%2Ftype_alias.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -53,5 +53,5 @@ fn render(\n     }\n     item.insert_text(escaped_name);\n \n-    Some(item.build())\n+    Some(item.build(ctx.db()))\n }"}, {"sha": "93e943dbed98e68ccd7b73b2715c5f9e400ab757", "filename": "crates/ide-completion/src/render/union_literal.rs", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-completion%2Fsrc%2Frender%2Funion_literal.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-completion%2Fsrc%2Frender%2Funion_literal.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Frender%2Funion_literal.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -21,8 +21,10 @@ pub(crate) fn render_union_literal(\n     let name = local_name.unwrap_or_else(|| un.name(ctx.db()));\n \n     let (qualified_name, escaped_qualified_name) = match path {\n-        Some(p) => (p.unescaped().to_string(), p.to_string()),\n-        None => (name.unescaped().to_string(), name.to_string()),\n+        Some(p) => (p.unescaped().display(ctx.db()).to_string(), p.display(ctx.db()).to_string()),\n+        None => {\n+            (name.unescaped().display(ctx.db()).to_string(), name.display(ctx.db()).to_string())\n+        }\n     };\n     let label = format_literal_label(&name.to_smol_str(), StructKind::Record, ctx.snippet_cap());\n     let lookup = format_literal_lookup(&name.to_smol_str(), StructKind::Record);\n@@ -51,17 +53,21 @@ pub(crate) fn render_union_literal(\n         format!(\n             \"{} {{ {} }}\",\n             escaped_qualified_name,\n-            fields\n-                .iter()\n-                .format_with(\", \", |field, f| { f(&format_args!(\"{}: ()\", field.name(ctx.db()))) })\n+            fields.iter().format_with(\", \", |field, f| {\n+                f(&format_args!(\"{}: ()\", field.name(ctx.db()).display(ctx.db())))\n+            })\n         )\n     };\n \n     let detail = format!(\n         \"{} {{ {}{} }}\",\n         qualified_name,\n         fields.iter().format_with(\", \", |field, f| {\n-            f(&format_args!(\"{}: {}\", field.name(ctx.db()), field.ty(ctx.db()).display(ctx.db())))\n+            f(&format_args!(\n+                \"{}: {}\",\n+                field.name(ctx.db()).display(ctx.db()),\n+                field.ty(ctx.db()).display(ctx.db())\n+            ))\n         }),\n         if fields_omitted { \", ..\" } else { \"\" }\n     );\n@@ -76,5 +82,5 @@ pub(crate) fn render_union_literal(\n         None => item.insert_text(literal),\n     };\n \n-    Some(item.build())\n+    Some(item.build(ctx.db()))\n }"}, {"sha": "a9a01a3a30f5b9cbc656585968086da41e8ae99b", "filename": "crates/ide-completion/src/render/variant.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-completion%2Fsrc%2Frender%2Fvariant.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-completion%2Fsrc%2Frender%2Fvariant.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Frender%2Fvariant.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -27,14 +27,14 @@ pub(crate) fn render_record_lit(\n     }\n     let completions = fields.iter().enumerate().format_with(\", \", |(idx, field), f| {\n         if snippet_cap.is_some() {\n-            f(&format_args!(\"{}: ${{{}:()}}\", field.name(db), idx + 1))\n+            f(&format_args!(\"{}: ${{{}:()}}\", field.name(db).display(db.upcast()), idx + 1))\n         } else {\n-            f(&format_args!(\"{}: ()\", field.name(db)))\n+            f(&format_args!(\"{}: ()\", field.name(db).display(db.upcast())))\n         }\n     });\n \n     let types = fields.iter().format_with(\", \", |field, f| {\n-        f(&format_args!(\"{}: {}\", field.name(db), field.ty(db).display(db)))\n+        f(&format_args!(\"{}: {}\", field.name(db).display(db.upcast()), field.ty(db).display(db)))\n     });\n \n     RenderedLiteral {"}, {"sha": "2464e8d5f81751ba668aaa87bd512548ce4921d0", "filename": "crates/ide-completion/src/tests.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-completion%2Fsrc%2Ftests.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-completion%2Fsrc%2Ftests.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-completion%2Fsrc%2Ftests.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -198,11 +198,11 @@ pub(crate) fn check_edit_with_config(\n         &db,\n         &config,\n         position,\n-        completion.import_to_add.iter().filter_map(|import_edit| {\n-            let import_path = &import_edit.import_path;\n-            let import_name = import_path.segments().last()?;\n-            Some((import_path.to_string(), import_name.to_string()))\n-        }),\n+        completion\n+            .import_to_add\n+            .iter()\n+            .cloned()\n+            .filter_map(|(import_path, import_name)| Some((import_path, import_name))),\n     )\n     .into_iter()\n     .flatten()"}, {"sha": "901d592c69104458fde917d3d86f78bc11192f04", "filename": "crates/ide-db/src/imports/import_assets.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-db%2Fsrc%2Fimports%2Fimport_assets.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-db%2Fsrc%2Fimports%2Fimport_assets.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Fimports%2Fimport_assets.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -362,12 +362,12 @@ fn import_for_item(\n \n     let original_item_candidate = item_for_path_search(db, original_item)?;\n     let import_path_candidate = mod_path(original_item_candidate)?;\n-    let import_path_string = import_path_candidate.to_string();\n+    let import_path_string = import_path_candidate.display(db).to_string();\n \n     let expected_import_end = if item_as_assoc(db, original_item).is_some() {\n         unresolved_qualifier.to_string()\n     } else {\n-        format!(\"{unresolved_qualifier}::{}\", item_name(db, original_item)?)\n+        format!(\"{unresolved_qualifier}::{}\", item_name(db, original_item)?.display(db))\n     };\n     if !import_path_string.contains(unresolved_first_segment)\n         || !import_path_string.ends_with(&expected_import_end)"}, {"sha": "5b2558ea8fe03ef03e7bbda4c804e3c66204a095", "filename": "crates/ide-db/src/rename.rs", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-db%2Fsrc%2Frename.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-db%2Fsrc%2Frename.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Frename.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -202,12 +202,13 @@ fn rename_mod(\n         //  - Module has submodules defined in separate files\n         let dir_paths = match (is_mod_rs, has_detached_child, module.name(sema.db)) {\n             // Go up one level since the anchor is inside the dir we're trying to rename\n-            (true, _, Some(mod_name)) => {\n-                Some((format!(\"../{}\", mod_name.unescaped()), format!(\"../{new_name}\")))\n-            }\n+            (true, _, Some(mod_name)) => Some((\n+                format!(\"../{}\", mod_name.unescaped().display(sema.db)),\n+                format!(\"../{new_name}\"),\n+            )),\n             // The anchor is on the same level as target dir\n             (false, true, Some(mod_name)) => {\n-                Some((mod_name.unescaped().to_string(), new_name.to_owned()))\n+                Some((mod_name.unescaped().display(sema.db).to_string(), new_name.to_owned()))\n             }\n             _ => None,\n         };"}, {"sha": "9abbc344142912ed3fa086271ec2e4b8c25f2af7", "filename": "crates/ide-db/src/traits.rs", "status": "modified", "additions": 10, "deletions": 8, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-db%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-db%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-db%2Fsrc%2Ftraits.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -38,15 +38,15 @@ pub fn get_missing_assoc_items(\n     for item in imp.items(sema.db) {\n         match item {\n             hir::AssocItem::Function(it) => {\n-                impl_fns_consts.insert(it.name(sema.db).to_string());\n+                impl_fns_consts.insert(it.name(sema.db).display(sema.db).to_string());\n             }\n             hir::AssocItem::Const(it) => {\n                 if let Some(name) = it.name(sema.db) {\n-                    impl_fns_consts.insert(name.to_string());\n+                    impl_fns_consts.insert(name.display(sema.db).to_string());\n                 }\n             }\n             hir::AssocItem::TypeAlias(it) => {\n-                impl_type.insert(it.name(sema.db).to_string());\n+                impl_type.insert(it.name(sema.db).display(sema.db).to_string());\n             }\n         }\n     }\n@@ -57,12 +57,14 @@ pub fn get_missing_assoc_items(\n             .into_iter()\n             .filter(|i| match i {\n                 hir::AssocItem::Function(f) => {\n-                    !impl_fns_consts.contains(&f.name(sema.db).to_string())\n+                    !impl_fns_consts.contains(&f.name(sema.db).display(sema.db).to_string())\n+                }\n+                hir::AssocItem::TypeAlias(t) => {\n+                    !impl_type.contains(&t.name(sema.db).display(sema.db).to_string())\n                 }\n-                hir::AssocItem::TypeAlias(t) => !impl_type.contains(&t.name(sema.db).to_string()),\n                 hir::AssocItem::Const(c) => c\n                     .name(sema.db)\n-                    .map(|n| !impl_fns_consts.contains(&n.to_string()))\n+                    .map(|n| !impl_fns_consts.contains(&n.display(sema.db).to_string()))\n                     .unwrap_or_default(),\n             })\n             .collect()\n@@ -137,7 +139,7 @@ mod tests {\n             sema.find_node_at_offset_with_descend(file.syntax(), position.offset).unwrap();\n         let trait_ = crate::traits::resolve_target_trait(&sema, &impl_block);\n         let actual = match trait_ {\n-            Some(trait_) => trait_.name(&db).to_string(),\n+            Some(trait_) => trait_.name(&db).display(&db).to_string(),\n             None => String::new(),\n         };\n         expect.assert_eq(&actual);\n@@ -152,7 +154,7 @@ mod tests {\n         let items = crate::traits::get_missing_assoc_items(&sema, &impl_block);\n         let actual = items\n             .into_iter()\n-            .map(|item| item.name(&db).unwrap().to_string())\n+            .map(|item| item.name(&db).unwrap().display(&db).to_string())\n             .collect::<Vec<_>>()\n             .join(\"\\n\");\n         expect.assert_eq(&actual);"}, {"sha": "60ccc41df01cc0fb4d26969cbc78de9ecd9cff87", "filename": "crates/ide-diagnostics/src/handlers/missing_fields.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmissing_fields.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmissing_fields.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmissing_fields.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -31,7 +31,7 @@ use crate::{fix, Diagnostic, DiagnosticsContext};\n pub(crate) fn missing_fields(ctx: &DiagnosticsContext<'_>, d: &hir::MissingFields) -> Diagnostic {\n     let mut message = String::from(\"missing structure fields:\\n\");\n     for field in &d.missed_fields {\n-        format_to!(message, \"- {}\\n\", field);\n+        format_to!(message, \"- {}\\n\", field.display(ctx.sema.db));\n     }\n \n     let ptr = InFile::new(\n@@ -175,7 +175,7 @@ fn fixes(ctx: &DiagnosticsContext<'_>, d: &hir::MissingFields) -> Option<Vec<Ass\n \n fn make_ty(ty: &hir::Type, db: &dyn HirDatabase, module: hir::Module) -> ast::Type {\n     let ty_str = match ty.as_adt() {\n-        Some(adt) => adt.name(db).to_string(),\n+        Some(adt) => adt.name(db).display(db.upcast()).to_string(),\n         None => {\n             ty.display_source_code(db, module.into(), false).ok().unwrap_or_else(|| \"_\".to_string())\n         }"}, {"sha": "0af41001808262f871c8c976852097f2554a35d8", "filename": "crates/ide-diagnostics/src/handlers/mutability_errors.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmutability_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmutability_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fmutability_errors.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -30,7 +30,10 @@ pub(crate) fn need_mut(ctx: &DiagnosticsContext<'_>, d: &hir::NeedMut) -> Diagno\n     })();\n     Diagnostic::new(\n         \"need-mut\",\n-        format!(\"cannot mutate immutable variable `{}`\", d.local.name(ctx.sema.db)),\n+        format!(\n+            \"cannot mutate immutable variable `{}`\",\n+            d.local.name(ctx.sema.db).display(ctx.sema.db)\n+        ),\n         ctx.sema.diagnostics_display_range(d.span.clone()).range,\n     )\n     .with_fixes(fixes)"}, {"sha": "4cd85a479a061b923611cbdd754f45fffd3686ec", "filename": "crates/ide-diagnostics/src/handlers/private_assoc_item.rs", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fprivate_assoc_item.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fprivate_assoc_item.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fprivate_assoc_item.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -11,7 +11,11 @@ pub(crate) fn private_assoc_item(\n     d: &hir::PrivateAssocItem,\n ) -> Diagnostic {\n     // FIXME: add quickfix\n-    let name = d.item.name(ctx.sema.db).map(|name| format!(\"`{name}` \")).unwrap_or_default();\n+    let name = d\n+        .item\n+        .name(ctx.sema.db)\n+        .map(|name| format!(\"`{}` \", name.display(ctx.sema.db)))\n+        .unwrap_or_default();\n     Diagnostic::new(\n         \"private-assoc-item\",\n         format!("}, {"sha": "de7f51f693c42283caf29e8cdd8632ced26d5a2b", "filename": "crates/ide-diagnostics/src/handlers/private_field.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fprivate_field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fprivate_field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fprivate_field.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -9,8 +9,8 @@ pub(crate) fn private_field(ctx: &DiagnosticsContext<'_>, d: &hir::PrivateField)\n         \"private-field\",\n         format!(\n             \"field `{}` of `{}` is private\",\n-            d.field.name(ctx.sema.db),\n-            d.field.parent_def(ctx.sema.db).name(ctx.sema.db)\n+            d.field.name(ctx.sema.db).display(ctx.sema.db),\n+            d.field.parent_def(ctx.sema.db).name(ctx.sema.db).display(ctx.sema.db)\n         ),\n         ctx.sema.diagnostics_display_range(d.expr.clone().map(|it| it.into())).range,\n     )"}, {"sha": "768efecb086e5378eaeb90ad3f2d174f2c7e5ead", "filename": "crates/ide-diagnostics/src/handlers/undeclared_label.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fundeclared_label.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fundeclared_label.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Fundeclared_label.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -8,7 +8,7 @@ pub(crate) fn undeclared_label(\n     let name = &d.name;\n     Diagnostic::new(\n         \"undeclared-label\",\n-        format!(\"use of undeclared label `{name}`\"),\n+        format!(\"use of undeclared label `{}`\", name.display(ctx.sema.db)),\n         ctx.sema.diagnostics_display_range(d.node.clone().map(|it| it.into())).range,\n     )\n }"}, {"sha": "9fedadeae03592c68001f138a436475eee0d7a36", "filename": "crates/ide-diagnostics/src/handlers/unreachable_label.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funreachable_label.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funreachable_label.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funreachable_label.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -8,7 +8,7 @@ pub(crate) fn unreachable_label(\n     let name = &d.name;\n     Diagnostic::new(\n         \"unreachable-label\",\n-        format!(\"use of unreachable label `{name}`\"),\n+        format!(\"use of unreachable label `{}`\", name.display(ctx.sema.db)),\n         ctx.sema.diagnostics_display_range(d.node.clone().map(|it| it.into())).range,\n     )\n }"}, {"sha": "5e4efa41fd9c3c1bb381c498ea3feabd1245013e", "filename": "crates/ide-diagnostics/src/handlers/unresolved_field.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funresolved_field.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funresolved_field.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funresolved_field.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -26,7 +26,7 @@ pub(crate) fn unresolved_field(\n         \"unresolved-field\",\n         format!(\n             \"no field `{}` on type `{}`{method_suffix}\",\n-            d.name,\n+            d.name.display(ctx.sema.db),\n             d.receiver.display(ctx.sema.db)\n         ),\n         ctx.sema.diagnostics_display_range(d.expr.clone().map(|it| it.into())).range,"}, {"sha": "3943b51ab422d5ee16bed34000cc744521edaf36", "filename": "crates/ide-diagnostics/src/handlers/unresolved_macro_call.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funresolved_macro_call.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funresolved_macro_call.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funresolved_macro_call.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -13,7 +13,7 @@ pub(crate) fn unresolved_macro_call(\n     let bang = if d.is_bang { \"!\" } else { \"\" };\n     Diagnostic::new(\n         \"unresolved-macro-call\",\n-        format!(\"unresolved macro `{}{bang}`\", d.path),\n+        format!(\"unresolved macro `{}{bang}`\", d.path.display(ctx.sema.db)),\n         display_range,\n     )\n     .experimental()"}, {"sha": "8bbb837e6709e5c3e064cdffd1c580f09320746c", "filename": "crates/ide-diagnostics/src/handlers/unresolved_method.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funresolved_method.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funresolved_method.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-diagnostics%2Fsrc%2Fhandlers%2Funresolved_method.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -26,7 +26,7 @@ pub(crate) fn unresolved_method(\n         \"unresolved-method\",\n         format!(\n             \"no method `{}` on type `{}`{field_suffix}\",\n-            d.name,\n+            d.name.display(ctx.sema.db),\n             d.receiver.display(ctx.sema.db)\n         ),\n         ctx.sema.diagnostics_display_range(d.expr.clone().map(|it| it.into())).range,"}, {"sha": "66832a0bee49665072a519abb5eabead88a9df05", "filename": "crates/ide-ssr/src/lib.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-ssr%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-ssr%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-ssr%2Fsrc%2Flib.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -184,6 +184,7 @@ impl<'db> MatchFinder<'db> {\n                 (\n                     file_id,\n                     replacing::matches_to_edit(\n+                        self.sema.db,\n                         &matches,\n                         &self.sema.db.file_text(file_id),\n                         &self.rules,"}, {"sha": "b4b83f62da240cd48fba50e006b0a30db03d65e9", "filename": "crates/ide-ssr/src/replacing.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-ssr%2Fsrc%2Freplacing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide-ssr%2Fsrc%2Freplacing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide-ssr%2Fsrc%2Freplacing.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -14,14 +14,16 @@ use crate::{fragments, resolving::ResolvedRule, Match, SsrMatches};\n /// template. Placeholders in the template will have been substituted with whatever they matched to\n /// in the original code.\n pub(crate) fn matches_to_edit(\n+    db: &dyn hir::db::ExpandDatabase,\n     matches: &SsrMatches,\n     file_src: &str,\n     rules: &[ResolvedRule],\n ) -> TextEdit {\n-    matches_to_edit_at_offset(matches, file_src, 0.into(), rules)\n+    matches_to_edit_at_offset(db, matches, file_src, 0.into(), rules)\n }\n \n fn matches_to_edit_at_offset(\n+    db: &dyn hir::db::ExpandDatabase,\n     matches: &SsrMatches,\n     file_src: &str,\n     relative_start: TextSize,\n@@ -31,13 +33,14 @@ fn matches_to_edit_at_offset(\n     for m in &matches.matches {\n         edit_builder.replace(\n             m.range.range.checked_sub(relative_start).unwrap(),\n-            render_replace(m, file_src, rules),\n+            render_replace(db, m, file_src, rules),\n         );\n     }\n     edit_builder.finish()\n }\n \n struct ReplacementRenderer<'a> {\n+    db: &'a dyn hir::db::ExpandDatabase,\n     match_info: &'a Match,\n     file_src: &'a str,\n     rules: &'a [ResolvedRule],\n@@ -53,13 +56,19 @@ struct ReplacementRenderer<'a> {\n     placeholder_tokens_requiring_parenthesis: FxHashSet<SyntaxToken>,\n }\n \n-fn render_replace(match_info: &Match, file_src: &str, rules: &[ResolvedRule]) -> String {\n+fn render_replace(\n+    db: &dyn hir::db::ExpandDatabase,\n+    match_info: &Match,\n+    file_src: &str,\n+    rules: &[ResolvedRule],\n+) -> String {\n     let rule = &rules[match_info.rule_index];\n     let template = rule\n         .template\n         .as_ref()\n         .expect(\"You called MatchFinder::edits after calling MatchFinder::add_search_pattern\");\n     let mut renderer = ReplacementRenderer {\n+        db,\n         match_info,\n         file_src,\n         rules,\n@@ -96,7 +105,7 @@ impl ReplacementRenderer<'_> {\n \n     fn render_node(&mut self, node: &SyntaxNode) {\n         if let Some(mod_path) = self.match_info.rendered_template_paths.get(node) {\n-            self.out.push_str(&mod_path.to_string());\n+            self.out.push_str(&mod_path.display(self.db).to_string());\n             // Emit everything except for the segment's name-ref, since we already effectively\n             // emitted that as part of `mod_path`.\n             if let Some(path) = ast::Path::cast(node.clone()) {\n@@ -144,6 +153,7 @@ impl ReplacementRenderer<'_> {\n                     );\n                 }\n                 let edit = matches_to_edit_at_offset(\n+                    self.db,\n                     &placeholder_value.inner_matches,\n                     self.file_src,\n                     range.start(),"}, {"sha": "8112c4f7259cf95656da8968ce9341a2150f19fe", "filename": "crates/ide/src/doc_links.rs", "status": "modified", "additions": 29, "deletions": 19, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide%2Fsrc%2Fdoc_links.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide%2Fsrc%2Fdoc_links.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fdoc_links.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -394,7 +394,7 @@ fn rewrite_url_link(db: &RootDatabase, def: Definition, target: &str) -> Option<\n fn mod_path_of_def(db: &RootDatabase, def: Definition) -> Option<String> {\n     def.canonical_module_path(db).map(|it| {\n         let mut path = String::new();\n-        it.flat_map(|it| it.name(db)).for_each(|name| format_to!(path, \"{}/\", name));\n+        it.flat_map(|it| it.name(db)).for_each(|name| format_to!(path, \"{}/\", name.display(db)));\n         path\n     })\n }\n@@ -567,39 +567,47 @@ fn filename_and_frag_for_def(\n \n     let res = match def {\n         Definition::Adt(adt) => match adt {\n-            Adt::Struct(s) => format!(\"struct.{}.html\", s.name(db)),\n-            Adt::Enum(e) => format!(\"enum.{}.html\", e.name(db)),\n-            Adt::Union(u) => format!(\"union.{}.html\", u.name(db)),\n+            Adt::Struct(s) => format!(\"struct.{}.html\", s.name(db).display(db.upcast())),\n+            Adt::Enum(e) => format!(\"enum.{}.html\", e.name(db).display(db.upcast())),\n+            Adt::Union(u) => format!(\"union.{}.html\", u.name(db).display(db.upcast())),\n         },\n         Definition::Module(m) => match m.name(db) {\n             // `#[doc(keyword = \"...\")]` is internal used only by rust compiler\n             Some(name) => match m.attrs(db).by_key(\"doc\").find_string_value_in_tt(\"keyword\") {\n                 Some(kw) => {\n                     format!(\"keyword.{}.html\", kw.trim_matches('\"'))\n                 }\n-                None => format!(\"{name}/index.html\"),\n+                None => format!(\"{}/index.html\", name.display(db.upcast())),\n             },\n             None => String::from(\"index.html\"),\n         },\n-        Definition::Trait(t) => format!(\"trait.{}.html\", t.name(db)),\n-        Definition::TraitAlias(t) => format!(\"traitalias.{}.html\", t.name(db)),\n-        Definition::TypeAlias(t) => format!(\"type.{}.html\", t.name(db)),\n-        Definition::BuiltinType(t) => format!(\"primitive.{}.html\", t.name()),\n-        Definition::Function(f) => format!(\"fn.{}.html\", f.name(db)),\n+        Definition::Trait(t) => format!(\"trait.{}.html\", t.name(db).display(db.upcast())),\n+        Definition::TraitAlias(t) => format!(\"traitalias.{}.html\", t.name(db).display(db.upcast())),\n+        Definition::TypeAlias(t) => format!(\"type.{}.html\", t.name(db).display(db.upcast())),\n+        Definition::BuiltinType(t) => format!(\"primitive.{}.html\", t.name().display(db.upcast())),\n+        Definition::Function(f) => format!(\"fn.{}.html\", f.name(db).display(db.upcast())),\n         Definition::Variant(ev) => {\n-            format!(\"enum.{}.html#variant.{}\", ev.parent_enum(db).name(db), ev.name(db))\n+            format!(\n+                \"enum.{}.html#variant.{}\",\n+                ev.parent_enum(db).name(db).display(db.upcast()),\n+                ev.name(db).display(db.upcast())\n+            )\n         }\n-        Definition::Const(c) => format!(\"const.{}.html\", c.name(db)?),\n-        Definition::Static(s) => format!(\"static.{}.html\", s.name(db)),\n-        Definition::Macro(mac) => format!(\"macro.{}.html\", mac.name(db)),\n+        Definition::Const(c) => format!(\"const.{}.html\", c.name(db)?.display(db.upcast())),\n+        Definition::Static(s) => format!(\"static.{}.html\", s.name(db).display(db.upcast())),\n+        Definition::Macro(mac) => format!(\"macro.{}.html\", mac.name(db).display(db.upcast())),\n         Definition::Field(field) => {\n             let def = match field.parent_def(db) {\n                 hir::VariantDef::Struct(it) => Definition::Adt(it.into()),\n                 hir::VariantDef::Union(it) => Definition::Adt(it.into()),\n                 hir::VariantDef::Variant(it) => Definition::Variant(it),\n             };\n             let (_, file, _) = filename_and_frag_for_def(db, def)?;\n-            return Some((def, file, Some(format!(\"structfield.{}\", field.name(db)))));\n+            return Some((\n+                def,\n+                file,\n+                Some(format!(\"structfield.{}\", field.name(db).display(db.upcast()))),\n+            ));\n         }\n         Definition::SelfType(impl_) => {\n             let adt = impl_.self_ty(db).as_adt()?.into();\n@@ -633,12 +641,14 @@ fn get_assoc_item_fragment(db: &dyn HirDatabase, assoc_item: hir::AssocItem) ->\n             // Rustdoc makes this decision based on whether a method 'has defaultness'.\n             // Currently this is only the case for provided trait methods.\n             if is_trait_method && !function.has_body(db) {\n-                format!(\"tymethod.{}\", function.name(db))\n+                format!(\"tymethod.{}\", function.name(db).display(db.upcast()))\n             } else {\n-                format!(\"method.{}\", function.name(db))\n+                format!(\"method.{}\", function.name(db).display(db.upcast()))\n             }\n         }\n-        AssocItem::Const(constant) => format!(\"associatedconstant.{}\", constant.name(db)?),\n-        AssocItem::TypeAlias(ty) => format!(\"associatedtype.{}\", ty.name(db)),\n+        AssocItem::Const(constant) => {\n+            format!(\"associatedconstant.{}\", constant.name(db)?.display(db.upcast()))\n+        }\n+        AssocItem::TypeAlias(ty) => format!(\"associatedtype.{}\", ty.name(db).display(db.upcast())),\n     })\n }"}, {"sha": "d6bbf2bf794dc7e7a950557b5a0ef25a39353f4e", "filename": "crates/ide/src/expand_macro.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide%2Fsrc%2Fexpand_macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide%2Fsrc%2Fexpand_macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fexpand_macro.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -76,7 +76,7 @@ pub(crate) fn expand_macro(db: &RootDatabase, position: FilePosition) -> Option<\n         if let Some(item) = ast::Item::cast(node.clone()) {\n             if let Some(def) = sema.resolve_attr_macro_call(&item) {\n                 break (\n-                    def.name(db).to_string(),\n+                    def.name(db).display(db).to_string(),\n                     expand_attr_macro_recur(&sema, &item)?,\n                     SyntaxKind::MACRO_ITEMS,\n                 );"}, {"sha": "1a84a963f55b6e1e5d032bfc3a18e0338620b3dc", "filename": "crates/ide/src/hover.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide%2Fsrc%2Fhover.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide%2Fsrc%2Fhover.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -56,7 +56,7 @@ impl HoverAction {\n                     mod_path: render::path(\n                         db,\n                         it.module(db)?,\n-                        it.name(db).map(|name| name.to_string()),\n+                        it.name(db).map(|name| name.display(db).to_string()),\n                     ),\n                     nav: it.try_to_nav(db)?,\n                 })"}, {"sha": "d9d4a1a99212dd175355e89b73e74c3c05998ef6", "filename": "crates/ide/src/hover/render.rs", "status": "modified", "additions": 13, "deletions": 11, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide%2Fsrc%2Fhover%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide%2Fsrc%2Fhover%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fhover%2Frender.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -370,7 +370,7 @@ fn definition_owner_name(db: &RootDatabase, def: &Definition) -> Option<String>\n         Definition::Variant(e) => Some(e.parent_enum(db).name(db)),\n         _ => None,\n     }\n-    .map(|name| name.to_string())\n+    .map(|name| name.display(db).to_string())\n }\n \n pub(super) fn path(db: &RootDatabase, module: hir::Module, item_name: Option<String>) -> String {\n@@ -380,7 +380,7 @@ pub(super) fn path(db: &RootDatabase, module: hir::Module, item_name: Option<Str\n         .path_to_root(db)\n         .into_iter()\n         .rev()\n-        .flat_map(|it| it.name(db).map(|name| name.to_string()));\n+        .flat_map(|it| it.name(db).map(|name| name.display(db).to_string()));\n     crate_name.into_iter().chain(module_path).chain(item_name).join(\"::\")\n }\n \n@@ -468,18 +468,20 @@ pub(super) fn definition(\n         Definition::BuiltinType(it) => {\n             return famous_defs\n                 .and_then(|fd| builtin(fd, it))\n-                .or_else(|| Some(Markup::fenced_block(&it.name())))\n+                .or_else(|| Some(Markup::fenced_block(&it.name().display(db))))\n         }\n         Definition::Local(it) => return local(db, it, config),\n         Definition::SelfType(impl_def) => {\n             impl_def.self_ty(db).as_adt().map(|adt| label_and_docs(db, adt))?\n         }\n         Definition::GenericParam(it) => label_and_docs(db, it),\n-        Definition::Label(it) => return Some(Markup::fenced_block(&it.name(db))),\n+        Definition::Label(it) => return Some(Markup::fenced_block(&it.name(db).display(db))),\n         // FIXME: We should be able to show more info about these\n         Definition::BuiltinAttr(it) => return render_builtin_attr(db, it),\n         Definition::ToolModule(it) => return Some(Markup::fenced_block(&it.name(db))),\n-        Definition::DeriveHelper(it) => (format!(\"derive_helper {}\", it.name(db)), None),\n+        Definition::DeriveHelper(it) => {\n+            (format!(\"derive_helper {}\", it.name(db).display(db)), None)\n+        }\n     };\n \n     let docs = docs\n@@ -717,19 +719,19 @@ fn markup(docs: Option<String>, desc: String, mod_path: Option<String>) -> Optio\n \n fn builtin(famous_defs: &FamousDefs<'_, '_>, builtin: hir::BuiltinType) -> Option<Markup> {\n     // std exposes prim_{} modules with docstrings on the root to document the builtins\n-    let primitive_mod = format!(\"prim_{}\", builtin.name());\n+    let primitive_mod = format!(\"prim_{}\", builtin.name().display(famous_defs.0.db));\n     let doc_owner = find_std_module(famous_defs, &primitive_mod)?;\n     let docs = doc_owner.attrs(famous_defs.0.db).docs()?;\n-    markup(Some(docs.into()), builtin.name().to_string(), None)\n+    markup(Some(docs.into()), builtin.name().display(famous_defs.0.db).to_string(), None)\n }\n \n fn find_std_module(famous_defs: &FamousDefs<'_, '_>, name: &str) -> Option<hir::Module> {\n     let db = famous_defs.0.db;\n     let std_crate = famous_defs.std()?;\n     let std_root_module = std_crate.root_module(db);\n-    std_root_module\n-        .children(db)\n-        .find(|module| module.name(db).map_or(false, |module| module.to_string() == name))\n+    std_root_module.children(db).find(|module| {\n+        module.name(db).map_or(false, |module| module.display(db).to_string() == name)\n+    })\n }\n \n fn local(db: &RootDatabase, it: hir::Local, config: &HoverConfig) -> Option<Markup> {\n@@ -748,7 +750,7 @@ fn local(db: &RootDatabase, it: hir::Local, config: &HoverConfig) -> Option<Mark\n             } else {\n                 \"\"\n             };\n-            format!(\"{let_kw}{is_mut}{name}: {ty}\")\n+            format!(\"{let_kw}{is_mut}{}: {ty}\", name.display(db))\n         }\n         None => format!(\"{is_mut}self: {ty}\"),\n     };"}, {"sha": "2cefd5acdc2e4fe50b7206ebd4d66df4057cd23e", "filename": "crates/ide/src/inlay_hints/closing_brace.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide%2Fsrc%2Finlay_hints%2Fclosing_brace.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide%2Fsrc%2Finlay_hints%2Fclosing_brace.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Finlay_hints%2Fclosing_brace.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -35,7 +35,7 @@ pub(super) fn hints(\n                     let ty = imp.self_ty(sema.db);\n                     let trait_ = imp.trait_(sema.db);\n                     let hint_text = match trait_ {\n-                        Some(tr) => format!(\"impl {} for {}\", tr.name(sema.db), ty.display_truncated(sema.db, config.max_length)),\n+                        Some(tr) => format!(\"impl {} for {}\", tr.name(sema.db).display(sema.db), ty.display_truncated(sema.db, config.max_length)),\n                         None => format!(\"impl {}\", ty.display_truncated(sema.db, config.max_length)),\n                     };\n                     (hint_text, None)"}, {"sha": "0d57e63d29c9103cafa1cce03dc74567728a39d7", "filename": "crates/ide/src/moniker.rs", "status": "modified", "additions": 64, "deletions": 50, "changes": 114, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide%2Fsrc%2Fmoniker.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide%2Fsrc%2Fmoniker.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fmoniker.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -1,7 +1,7 @@\n //! This module generates [moniker](https://microsoft.github.io/language-server-protocol/specifications/lsif/0.6.0/specification/#exportsImports)\n //! for LSIF and LSP.\n \n-use hir::{AsAssocItem, AssocItemContainer, Crate, Name, Semantics};\n+use hir::{AsAssocItem, AssocItemContainer, Crate, Semantics};\n use ide_db::{\n     base_db::{CrateOrigin, FilePosition, LangCrateOrigin},\n     defs::{Definition, IdentClass},\n@@ -27,7 +27,7 @@ pub enum MonikerDescriptorKind {\n \n #[derive(Debug, Clone, PartialEq, Eq, PartialOrd, Ord, Hash)]\n pub struct MonikerDescriptor {\n-    pub name: Name,\n+    pub name: String,\n     pub desc: MonikerDescriptorKind,\n }\n \n@@ -41,11 +41,7 @@ impl ToString for MonikerIdentifier {\n     fn to_string(&self) -> String {\n         match self {\n             MonikerIdentifier { description, crate_name } => {\n-                format!(\n-                    \"{}::{}\",\n-                    crate_name,\n-                    description.iter().map(|x| x.name.to_string()).join(\"::\")\n-                )\n+                format!(\"{}::{}\", crate_name, description.iter().map(|x| &x.name).join(\"::\"))\n             }\n         }\n     }\n@@ -136,7 +132,10 @@ pub(crate) fn def_to_moniker(\n     let krate = module.krate();\n     let mut description = vec![];\n     description.extend(module.path_to_root(db).into_iter().filter_map(|x| {\n-        Some(MonikerDescriptor { name: x.name(db)?, desc: MonikerDescriptorKind::Namespace })\n+        Some(MonikerDescriptor {\n+            name: x.name(db)?.display(db).to_string(),\n+            desc: MonikerDescriptorKind::Namespace,\n+        })\n     }));\n \n     // Handle associated items within a trait\n@@ -147,7 +146,7 @@ pub(crate) fn def_to_moniker(\n                 // Because different traits can have functions with the same name,\n                 // we have to include the trait name as part of the moniker for uniqueness.\n                 description.push(MonikerDescriptor {\n-                    name: trait_.name(db),\n+                    name: trait_.name(db).display(db).to_string(),\n                     desc: MonikerDescriptorKind::Type,\n                 });\n             }\n@@ -156,14 +155,14 @@ pub(crate) fn def_to_moniker(\n                 // we add both the struct name and the trait name to the path\n                 if let Some(adt) = impl_.self_ty(db).as_adt() {\n                     description.push(MonikerDescriptor {\n-                        name: adt.name(db),\n+                        name: adt.name(db).display(db).to_string(),\n                         desc: MonikerDescriptorKind::Type,\n                     });\n                 }\n \n                 if let Some(trait_) = impl_.trait_(db) {\n                     description.push(MonikerDescriptor {\n-                        name: trait_.name(db),\n+                        name: trait_.name(db).display(db).to_string(),\n                         desc: MonikerDescriptorKind::Type,\n                     });\n                 }\n@@ -173,7 +172,7 @@ pub(crate) fn def_to_moniker(\n \n     if let Definition::Field(it) = def {\n         description.push(MonikerDescriptor {\n-            name: it.parent_def(db).name(db),\n+            name: it.parent_def(db).name(db).display(db).to_string(),\n             desc: MonikerDescriptorKind::Type,\n         });\n     }\n@@ -191,48 +190,63 @@ pub(crate) fn def_to_moniker(\n                 return None;\n             }\n \n-            MonikerDescriptor { name: local.name(db), desc: MonikerDescriptorKind::Parameter }\n-        }\n-        Definition::Macro(m) => {\n-            MonikerDescriptor { name: m.name(db), desc: MonikerDescriptorKind::Macro }\n-        }\n-        Definition::Function(f) => {\n-            MonikerDescriptor { name: f.name(db), desc: MonikerDescriptorKind::Method }\n-        }\n-        Definition::Variant(v) => {\n-            MonikerDescriptor { name: v.name(db), desc: MonikerDescriptorKind::Type }\n-        }\n-        Definition::Const(c) => {\n-            MonikerDescriptor { name: c.name(db)?, desc: MonikerDescriptorKind::Term }\n-        }\n-        Definition::Trait(trait_) => {\n-            MonikerDescriptor { name: trait_.name(db), desc: MonikerDescriptorKind::Type }\n-        }\n-        Definition::TraitAlias(ta) => {\n-            MonikerDescriptor { name: ta.name(db), desc: MonikerDescriptorKind::Type }\n-        }\n-        Definition::TypeAlias(ta) => {\n-            MonikerDescriptor { name: ta.name(db), desc: MonikerDescriptorKind::TypeParameter }\n-        }\n-        Definition::Module(m) => {\n-            MonikerDescriptor { name: m.name(db)?, desc: MonikerDescriptorKind::Namespace }\n-        }\n-        Definition::BuiltinType(b) => {\n-            MonikerDescriptor { name: b.name(), desc: MonikerDescriptorKind::Type }\n+            MonikerDescriptor {\n+                name: local.name(db).display(db).to_string(),\n+                desc: MonikerDescriptorKind::Parameter,\n+            }\n         }\n+        Definition::Macro(m) => MonikerDescriptor {\n+            name: m.name(db).display(db).to_string(),\n+            desc: MonikerDescriptorKind::Macro,\n+        },\n+        Definition::Function(f) => MonikerDescriptor {\n+            name: f.name(db).display(db).to_string(),\n+            desc: MonikerDescriptorKind::Method,\n+        },\n+        Definition::Variant(v) => MonikerDescriptor {\n+            name: v.name(db).display(db).to_string(),\n+            desc: MonikerDescriptorKind::Type,\n+        },\n+        Definition::Const(c) => MonikerDescriptor {\n+            name: c.name(db)?.display(db).to_string(),\n+            desc: MonikerDescriptorKind::Term,\n+        },\n+        Definition::Trait(trait_) => MonikerDescriptor {\n+            name: trait_.name(db).display(db).to_string(),\n+            desc: MonikerDescriptorKind::Type,\n+        },\n+        Definition::TraitAlias(ta) => MonikerDescriptor {\n+            name: ta.name(db).display(db).to_string(),\n+            desc: MonikerDescriptorKind::Type,\n+        },\n+        Definition::TypeAlias(ta) => MonikerDescriptor {\n+            name: ta.name(db).display(db).to_string(),\n+            desc: MonikerDescriptorKind::TypeParameter,\n+        },\n+        Definition::Module(m) => MonikerDescriptor {\n+            name: m.name(db)?.display(db).to_string(),\n+            desc: MonikerDescriptorKind::Namespace,\n+        },\n+        Definition::BuiltinType(b) => MonikerDescriptor {\n+            name: b.name().display(db).to_string(),\n+            desc: MonikerDescriptorKind::Type,\n+        },\n         Definition::SelfType(imp) => MonikerDescriptor {\n-            name: imp.self_ty(db).as_adt()?.name(db),\n+            name: imp.self_ty(db).as_adt()?.name(db).display(db).to_string(),\n             desc: MonikerDescriptorKind::Type,\n         },\n-        Definition::Field(it) => {\n-            MonikerDescriptor { name: it.name(db), desc: MonikerDescriptorKind::Term }\n-        }\n-        Definition::Adt(adt) => {\n-            MonikerDescriptor { name: adt.name(db), desc: MonikerDescriptorKind::Type }\n-        }\n-        Definition::Static(s) => {\n-            MonikerDescriptor { name: s.name(db), desc: MonikerDescriptorKind::Meta }\n-        }\n+        Definition::Field(it) => MonikerDescriptor {\n+            name: it.name(db).display(db).to_string(),\n+            desc: MonikerDescriptorKind::Term,\n+        },\n+        Definition::Adt(adt) => MonikerDescriptor {\n+            name: adt.name(db).display(db).to_string(),\n+            desc: MonikerDescriptorKind::Type,\n+        },\n+        Definition::Static(s) => MonikerDescriptor {\n+            name: s.name(db).display(db).to_string(),\n+            desc: MonikerDescriptorKind::Meta,\n+        },\n     };\n \n     description.push(name_desc);"}, {"sha": "78972241bdfc19f2feff852cefacdd7dc65a0695", "filename": "crates/ide/src/runnables.rs", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide%2Fsrc%2Frunnables.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide%2Fsrc%2Frunnables.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Frunnables.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -349,8 +349,13 @@ pub(crate) fn runnable_mod(\n     if !has_test_function_or_multiple_test_submodules(sema, &def) {\n         return None;\n     }\n-    let path =\n-        def.path_to_root(sema.db).into_iter().rev().filter_map(|it| it.name(sema.db)).join(\"::\");\n+    let path = def\n+        .path_to_root(sema.db)\n+        .into_iter()\n+        .rev()\n+        .filter_map(|it| it.name(sema.db))\n+        .map(|it| it.display(sema.db).to_string())\n+        .join(\"::\");\n \n     let attrs = def.attrs(sema.db);\n     let cfg = attrs.cfg();\n@@ -376,7 +381,7 @@ pub(crate) fn runnable_impl(\n     } else {\n         String::new()\n     };\n-    let mut test_id = format!(\"{adt_name}{params}\");\n+    let mut test_id = format!(\"{}{params}\", adt_name.display(sema.db));\n     test_id.retain(|c| c != ' ');\n     let test_id = TestId::Path(test_id);\n \n@@ -391,8 +396,13 @@ fn runnable_mod_outline_definition(\n     if !has_test_function_or_multiple_test_submodules(sema, &def) {\n         return None;\n     }\n-    let path =\n-        def.path_to_root(sema.db).into_iter().rev().filter_map(|it| it.name(sema.db)).join(\"::\");\n+    let path = def\n+        .path_to_root(sema.db)\n+        .into_iter()\n+        .rev()\n+        .filter_map(|it| it.name(sema.db))\n+        .map(|it| it.display(sema.db).to_string())\n+        .join(\"::\");\n \n     let attrs = def.attrs(sema.db);\n     let cfg = attrs.cfg();\n@@ -430,25 +440,25 @@ fn module_def_doctest(db: &RootDatabase, def: Definition) -> Option<Runnable> {\n         let mut path = String::new();\n         def.canonical_module_path(db)?\n             .flat_map(|it| it.name(db))\n-            .for_each(|name| format_to!(path, \"{}::\", name));\n+            .for_each(|name| format_to!(path, \"{}::\", name.display(db)));\n         // This probably belongs to canonical_path?\n         if let Some(assoc_item) = def.as_assoc_item(db) {\n             if let hir::AssocItemContainer::Impl(imp) = assoc_item.container(db) {\n                 let ty = imp.self_ty(db);\n                 if let Some(adt) = ty.as_adt() {\n                     let name = adt.name(db);\n                     let mut ty_args = ty.generic_parameters(db).peekable();\n-                    format_to!(path, \"{}\", name);\n+                    format_to!(path, \"{}\", name.display(db));\n                     if ty_args.peek().is_some() {\n                         format_to!(path, \"<{}>\", ty_args.format_with(\",\", |ty, cb| cb(&ty)));\n                     }\n-                    format_to!(path, \"::{}\", def_name);\n+                    format_to!(path, \"::{}\", def_name.display(db));\n                     path.retain(|c| c != ' ');\n                     return Some(path);\n                 }\n             }\n         }\n-        format_to!(path, \"{}\", def_name);\n+        format_to!(path, \"{}\", def_name.display(db));\n         Some(path)\n     })();\n "}, {"sha": "9a0529ec20fee9c33fc4bcfa09e0b69c4b743657", "filename": "crates/ide/src/signature_help.rs", "status": "modified", "additions": 29, "deletions": 19, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide%2Fsrc%2Fsignature_help.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide%2Fsrc%2Fsignature_help.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fsignature_help.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -162,23 +162,23 @@ fn signature_help_for_call(\n     match callable.kind() {\n         hir::CallableKind::Function(func) => {\n             res.doc = func.docs(db).map(|it| it.into());\n-            format_to!(res.signature, \"fn {}\", func.name(db));\n+            format_to!(res.signature, \"fn {}\", func.name(db).display(db));\n             fn_params = Some(match callable.receiver_param(db) {\n                 Some(_self) => func.params_without_self(db),\n                 None => func.assoc_fn_params(db),\n             });\n         }\n         hir::CallableKind::TupleStruct(strukt) => {\n             res.doc = strukt.docs(db).map(|it| it.into());\n-            format_to!(res.signature, \"struct {}\", strukt.name(db));\n+            format_to!(res.signature, \"struct {}\", strukt.name(db).display(db));\n         }\n         hir::CallableKind::TupleEnumVariant(variant) => {\n             res.doc = variant.docs(db).map(|it| it.into());\n             format_to!(\n                 res.signature,\n                 \"enum {}::{}\",\n-                variant.parent_enum(db).name(db),\n-                variant.name(db)\n+                variant.parent_enum(db).name(db).display(db),\n+                variant.name(db).display(db)\n             );\n         }\n         hir::CallableKind::Closure | hir::CallableKind::FnPtr | hir::CallableKind::Other => (),\n@@ -248,39 +248,39 @@ fn signature_help_for_generics(\n     match generics_def {\n         hir::GenericDef::Function(it) => {\n             res.doc = it.docs(db).map(|it| it.into());\n-            format_to!(res.signature, \"fn {}\", it.name(db));\n+            format_to!(res.signature, \"fn {}\", it.name(db).display(db));\n         }\n         hir::GenericDef::Adt(hir::Adt::Enum(it)) => {\n             res.doc = it.docs(db).map(|it| it.into());\n-            format_to!(res.signature, \"enum {}\", it.name(db));\n+            format_to!(res.signature, \"enum {}\", it.name(db).display(db));\n         }\n         hir::GenericDef::Adt(hir::Adt::Struct(it)) => {\n             res.doc = it.docs(db).map(|it| it.into());\n-            format_to!(res.signature, \"struct {}\", it.name(db));\n+            format_to!(res.signature, \"struct {}\", it.name(db).display(db));\n         }\n         hir::GenericDef::Adt(hir::Adt::Union(it)) => {\n             res.doc = it.docs(db).map(|it| it.into());\n-            format_to!(res.signature, \"union {}\", it.name(db));\n+            format_to!(res.signature, \"union {}\", it.name(db).display(db));\n         }\n         hir::GenericDef::Trait(it) => {\n             res.doc = it.docs(db).map(|it| it.into());\n-            format_to!(res.signature, \"trait {}\", it.name(db));\n+            format_to!(res.signature, \"trait {}\", it.name(db).display(db));\n         }\n         hir::GenericDef::TraitAlias(it) => {\n             res.doc = it.docs(db).map(|it| it.into());\n-            format_to!(res.signature, \"trait {}\", it.name(db));\n+            format_to!(res.signature, \"trait {}\", it.name(db).display(db));\n         }\n         hir::GenericDef::TypeAlias(it) => {\n             res.doc = it.docs(db).map(|it| it.into());\n-            format_to!(res.signature, \"type {}\", it.name(db));\n+            format_to!(res.signature, \"type {}\", it.name(db).display(db));\n         }\n         hir::GenericDef::Variant(it) => {\n             // In paths, generics of an enum can be specified *after* one of its variants.\n             // eg. `None::<u8>`\n             // We'll use the signature of the enum, but include the docs of the variant.\n             res.doc = it.docs(db).map(|it| it.into());\n             let enum_ = it.parent_enum(db);\n-            format_to!(res.signature, \"enum {}\", enum_.name(db));\n+            format_to!(res.signature, \"enum {}\", enum_.name(db).display(db));\n             generics_def = enum_.into();\n         }\n         // These don't have generic args that can be specified\n@@ -412,7 +412,12 @@ fn signature_help_for_tuple_struct_pat(\n         let en = variant.parent_enum(db);\n \n         res.doc = en.docs(db).map(|it| it.into());\n-        format_to!(res.signature, \"enum {}::{} (\", en.name(db), variant.name(db));\n+        format_to!(\n+            res.signature,\n+            \"enum {}::{} (\",\n+            en.name(db).display(db),\n+            variant.name(db).display(db)\n+        );\n         variant.fields(db)\n     } else {\n         let adt = match path_res {\n@@ -424,7 +429,7 @@ fn signature_help_for_tuple_struct_pat(\n         match adt {\n             hir::Adt::Struct(it) => {\n                 res.doc = it.docs(db).map(|it| it.into());\n-                format_to!(res.signature, \"struct {} (\", it.name(db));\n+                format_to!(res.signature, \"struct {} (\", it.name(db).display(db));\n                 it.fields(db)\n             }\n             _ => return None,\n@@ -486,7 +491,12 @@ fn signature_help_for_record_(\n         let en = variant.parent_enum(db);\n \n         res.doc = en.docs(db).map(|it| it.into());\n-        format_to!(res.signature, \"enum {}::{} {{ \", en.name(db), variant.name(db));\n+        format_to!(\n+            res.signature,\n+            \"enum {}::{} {{ \",\n+            en.name(db).display(db),\n+            variant.name(db).display(db)\n+        );\n     } else {\n         let adt = match path_res {\n             PathResolution::SelfType(imp) => imp.self_ty(db).as_adt()?,\n@@ -498,12 +508,12 @@ fn signature_help_for_record_(\n             hir::Adt::Struct(it) => {\n                 fields = it.fields(db);\n                 res.doc = it.docs(db).map(|it| it.into());\n-                format_to!(res.signature, \"struct {} {{ \", it.name(db));\n+                format_to!(res.signature, \"struct {} {{ \", it.name(db).display(db));\n             }\n             hir::Adt::Union(it) => {\n                 fields = it.fields(db);\n                 res.doc = it.docs(db).map(|it| it.into());\n-                format_to!(res.signature, \"union {} {{ \", it.name(db));\n+                format_to!(res.signature, \"union {} {{ \", it.name(db).display(db));\n             }\n             _ => return None,\n         }\n@@ -514,7 +524,7 @@ fn signature_help_for_record_(\n     let mut buf = String::new();\n     for (field, ty) in fields2 {\n         let name = field.name(db);\n-        format_to!(buf, \"{name}: {}\", ty.display_truncated(db, Some(20)));\n+        format_to!(buf, \"{}: {}\", name.display(db), ty.display_truncated(db, Some(20)));\n         res.push_record_field(&buf);\n         buf.clear();\n \n@@ -524,7 +534,7 @@ fn signature_help_for_record_(\n     }\n     for (name, field) in fields {\n         let Some(field) = field else { continue };\n-        format_to!(buf, \"{name}: {}\", field.ty(db).display_truncated(db, Some(20)));\n+        format_to!(buf, \"{}: {}\", name.display(db), field.ty(db).display_truncated(db, Some(20)));\n         res.push_record_field(&buf);\n         buf.clear();\n     }"}, {"sha": "e072df430fc0de13dd75ada7a4b12296296ac7cd", "filename": "crates/ide/src/view_item_tree.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide%2Fsrc%2Fview_item_tree.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Fide%2Fsrc%2Fview_item_tree.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fide%2Fsrc%2Fview_item_tree.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -12,5 +12,5 @@ use ide_db::RootDatabase;\n // | VS Code | **rust-analyzer: Debug ItemTree**\n // |===\n pub(crate) fn view_item_tree(db: &RootDatabase, file_id: FileId) -> String {\n-    db.file_item_tree(file_id.into()).pretty_print()\n+    db.file_item_tree(file_id.into()).pretty_print(db)\n }"}, {"sha": "2c2a9a18d2e3112b4bdb4eae09afca7db07fbe0e", "filename": "crates/rust-analyzer/src/cli/analysis_stats.rs", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_stats.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_stats.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fanalysis_stats.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -221,6 +221,7 @@ impl flags::AnalysisStats {\n                     .rev()\n                     .filter_map(|it| it.name(db))\n                     .chain(Some(a.name(db)))\n+                    .map(|it| it.display(db).to_string())\n                     .join(\"::\");\n                 println!(\"Data layout for {full_name} failed due {e:?}\");\n             }\n@@ -248,6 +249,7 @@ impl flags::AnalysisStats {\n                     .rev()\n                     .filter_map(|it| it.name(db))\n                     .chain(c.name(db))\n+                    .map(|it| it.display(db).to_string())\n                     .join(\"::\");\n                 println!(\"Const eval for {full_name} failed due {e:?}\");\n             }\n@@ -274,6 +276,7 @@ impl flags::AnalysisStats {\n                     .rev()\n                     .filter_map(|it| it.name(db))\n                     .chain(Some(f.name(db)))\n+                    .map(|it| it.display(db).to_string())\n                     .join(\"::\");\n                 println!(\"Mir body for {full_name} failed due {e:?}\");\n             }\n@@ -332,9 +335,10 @@ impl flags::AnalysisStats {\n                 .rev()\n                 .filter_map(|it| it.name(db))\n                 .chain(Some(f.name(db)))\n+                .map(|it| it.display(db).to_string())\n                 .join(\"::\");\n             if let Some(only_name) = self.only.as_deref() {\n-                if name.to_string() != only_name && full_name != only_name {\n+                if name.display(db).to_string() != only_name && full_name != only_name {\n                     continue;\n                 }\n             }\n@@ -376,7 +380,7 @@ impl flags::AnalysisStats {\n                                 end.col,\n                             ));\n                         } else {\n-                            bar.println(format!(\"{name}: Unknown type\",));\n+                            bar.println(format!(\"{}: Unknown type\", name.display(db)));\n                         }\n                     }\n                     true\n@@ -431,7 +435,7 @@ impl flags::AnalysisStats {\n                         } else {\n                             bar.println(format!(\n                                 \"{}: Expected {}, got {}\",\n-                                name,\n+                                name.display(db),\n                                 mismatch.expected.display(db),\n                                 mismatch.actual.display(db)\n                             ));\n@@ -479,7 +483,7 @@ impl flags::AnalysisStats {\n                                 end.col,\n                             ));\n                         } else {\n-                            bar.println(format!(\"{name}: Unknown type\",));\n+                            bar.println(format!(\"{}: Unknown type\", name.display(db)));\n                         }\n                     }\n                     true\n@@ -533,7 +537,7 @@ impl flags::AnalysisStats {\n                         } else {\n                             bar.println(format!(\n                                 \"{}: Expected {}, got {}\",\n-                                name,\n+                                name.display(db),\n                                 mismatch.expected.display(db),\n                                 mismatch.actual.display(db)\n                             ));"}, {"sha": "61924d5843193086f13d6c6f8e8f139716433d76", "filename": "crates/rust-analyzer/src/cli/scip.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fscip.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fscip.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fcli%2Fscip.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -9,7 +9,6 @@ use crate::{\n     cli::load_cargo::ProcMacroServerChoice,\n     line_index::{LineEndings, LineIndex, PositionEncoding},\n };\n-use hir::Name;\n use ide::{\n     LineCol, MonikerDescriptorKind, StaticIndex, StaticIndexedFile, TextRange, TokenId,\n     TokenStaticData,\n@@ -209,13 +208,12 @@ fn new_descriptor_str(\n     }\n }\n \n-fn new_descriptor(name: Name, suffix: scip_types::descriptor::Suffix) -> scip_types::Descriptor {\n-    let mut name = name.to_string();\n+fn new_descriptor(name: &str, suffix: scip_types::descriptor::Suffix) -> scip_types::Descriptor {\n     if name.contains('\\'') {\n-        name = format!(\"`{name}`\");\n+        new_descriptor_str(&format!(\"`{name}`\"), suffix)\n+    } else {\n+        new_descriptor_str(&name, suffix)\n     }\n-\n-    new_descriptor_str(name.as_str(), suffix)\n }\n \n /// Loosely based on `def_to_moniker`\n@@ -235,7 +233,7 @@ fn token_to_symbol(token: &TokenStaticData) -> Option<scip_types::Symbol> {\n         .iter()\n         .map(|desc| {\n             new_descriptor(\n-                desc.name.clone(),\n+                &desc.name,\n                 match desc.desc {\n                     MonikerDescriptorKind::Namespace => Namespace,\n                     MonikerDescriptorKind::Type => Type,"}, {"sha": "8a9e947ded0adebed7bceee4fb168e15813ba626", "filename": "crates/rust-analyzer/src/to_proto.rs", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "raw_url": "https://github.com/rust-lang/rust/raw/21e5dc2af986d2eccb9d7caa74455a48b26c7ae6/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Frust-analyzer%2Fsrc%2Fto_proto.rs?ref=21e5dc2af986d2eccb9d7caa74455a48b26c7ae6", "patch": "@@ -306,12 +306,10 @@ fn completion_item(\n             let imports: Vec<_> = item\n                 .import_to_add\n                 .into_iter()\n-                .filter_map(|import_edit| {\n-                    let import_path = &import_edit.import_path;\n-                    let import_name = import_path.segments().last()?;\n+                .filter_map(|(import_path, import_name)| {\n                     Some(lsp_ext::CompletionImport {\n-                        full_import_path: import_path.to_string(),\n-                        imported_name: import_name.to_string(),\n+                        full_import_path: import_path,\n+                        imported_name: import_name,\n                     })\n                 })\n                 .collect();"}]}