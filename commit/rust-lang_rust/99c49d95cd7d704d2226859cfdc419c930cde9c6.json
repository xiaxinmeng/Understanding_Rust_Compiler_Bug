{"sha": "99c49d95cd7d704d2226859cfdc419c930cde9c6", "node_id": "C_kwDOAAsO6NoAKDk5YzQ5ZDk1Y2Q3ZDcwNGQyMjI2ODU5Y2ZkYzQxOWM5MzBjZGU5YzY", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-23T12:35:05Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2023-03-23T12:35:05Z"}, "message": "Auto merge of #109517 - matthiaskrgr:rollup-m3orqzd, r=matthiaskrgr\n\nRollup of 7 pull requests\n\nSuccessful merges:\n\n - #108541 (Suppress `opaque_hidden_inferred_bound` for nested RPITs)\n - #109137 (resolve: Querify most cstore access methods (subset 2))\n - #109380 (add `known-bug` test for unsoundness issue)\n - #109462 (Make alias-eq have a relation direction (and rename it to alias-relate))\n - #109475 (Simpler checked shifts in MIR building)\n - #109504 (Stabilize `arc_into_inner` and `rc_into_inner`.)\n - #109506 (make param bound vars visibly bound vars with -Zverbose)\n\nFailed merges:\n\nr? `@ghost`\n`@rustbot` modify labels: rollup", "tree": {"sha": "0a65913f2764e2daaf06faf6883e3f8119096c5a", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/0a65913f2764e2daaf06faf6883e3f8119096c5a"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/99c49d95cd7d704d2226859cfdc419c930cde9c6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/99c49d95cd7d704d2226859cfdc419c930cde9c6", "html_url": "https://github.com/rust-lang/rust/commit/99c49d95cd7d704d2226859cfdc419c930cde9c6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/99c49d95cd7d704d2226859cfdc419c930cde9c6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9a6b0c3326f3577f330d8828d3b706c0eea9cf29", "url": "https://api.github.com/repos/rust-lang/rust/commits/9a6b0c3326f3577f330d8828d3b706c0eea9cf29", "html_url": "https://github.com/rust-lang/rust/commit/9a6b0c3326f3577f330d8828d3b706c0eea9cf29"}, {"sha": "477ce585d420735ef536c3dd1417911fbe7e9a70", "url": "https://api.github.com/repos/rust-lang/rust/commits/477ce585d420735ef536c3dd1417911fbe7e9a70", "html_url": "https://github.com/rust-lang/rust/commit/477ce585d420735ef536c3dd1417911fbe7e9a70"}], "stats": {"total": 976, "additions": 730, "deletions": 246}, "files": [{"sha": "6d9dfe9697c0c2d5a2ddda6c971056555bee940a", "filename": "compiler/rustc_hir_analysis/src/astconv/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99c49d95cd7d704d2226859cfdc419c930cde9c6/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99c49d95cd7d704d2226859cfdc419c930cde9c6/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fastconv%2Fmod.rs?ref=99c49d95cd7d704d2226859cfdc419c930cde9c6", "patch": "@@ -1336,7 +1336,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     ty::Clause::RegionOutlives(_) | ty::Clause::ConstArgHasType(..) => bug!(),\n                 },\n                 ty::PredicateKind::WellFormed(_)\n-                | ty::PredicateKind::AliasEq(..)\n+                | ty::PredicateKind::AliasRelate(..)\n                 | ty::PredicateKind::ObjectSafe(_)\n                 | ty::PredicateKind::ClosureKind(_, _, _)\n                 | ty::PredicateKind::Subtype(_)"}, {"sha": "7f1e4ccc9647b79de5f0dde67540ba25d40583d3", "filename": "compiler/rustc_hir_analysis/src/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99c49d95cd7d704d2226859cfdc419c930cde9c6/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99c49d95cd7d704d2226859cfdc419c930cde9c6/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs?ref=99c49d95cd7d704d2226859cfdc419c930cde9c6", "patch": "@@ -528,7 +528,7 @@ fn trait_predicate_kind<'tcx>(\n         | ty::PredicateKind::Clause(ty::Clause::TypeOutlives(_))\n         | ty::PredicateKind::Clause(ty::Clause::Projection(_))\n         | ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(..))\n-        | ty::PredicateKind::AliasEq(..)\n+        | ty::PredicateKind::AliasRelate(..)\n         | ty::PredicateKind::WellFormed(_)\n         | ty::PredicateKind::Subtype(_)\n         | ty::PredicateKind::Coerce(_)"}, {"sha": "357deb07b8f31ef930c3d74f2c9a1214cfa0f998", "filename": "compiler/rustc_hir_analysis/src/outlives/explicit.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99c49d95cd7d704d2226859cfdc419c930cde9c6/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fexplicit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99c49d95cd7d704d2226859cfdc419c930cde9c6/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fexplicit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_analysis%2Fsrc%2Foutlives%2Fexplicit.rs?ref=99c49d95cd7d704d2226859cfdc419c930cde9c6", "patch": "@@ -56,7 +56,7 @@ impl<'tcx> ExplicitPredicatesMap<'tcx> {\n                     | ty::PredicateKind::Clause(ty::Clause::Projection(..))\n                     | ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(..))\n                     | ty::PredicateKind::WellFormed(..)\n-                    | ty::PredicateKind::AliasEq(..)\n+                    | ty::PredicateKind::AliasRelate(..)\n                     | ty::PredicateKind::ObjectSafe(..)\n                     | ty::PredicateKind::ClosureKind(..)\n                     | ty::PredicateKind::Subtype(..)"}, {"sha": "3def97bca4789c95020cad0d09656461c777be2e", "filename": "compiler/rustc_hir_typeck/src/fn_ctxt/_impl.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99c49d95cd7d704d2226859cfdc419c930cde9c6/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99c49d95cd7d704d2226859cfdc419c930cde9c6/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Ffn_ctxt%2F_impl.rs?ref=99c49d95cd7d704d2226859cfdc419c930cde9c6", "patch": "@@ -666,7 +666,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 | ty::PredicateKind::Clause(ty::Clause::TypeOutlives(..))\n                 | ty::PredicateKind::WellFormed(..)\n                 | ty::PredicateKind::ObjectSafe(..)\n-                | ty::PredicateKind::AliasEq(..)\n+                | ty::PredicateKind::AliasRelate(..)\n                 | ty::PredicateKind::ConstEvaluatable(..)\n                 | ty::PredicateKind::ConstEquate(..)\n                 // N.B., this predicate is created by breaking down a"}, {"sha": "0eff5c956ef642e06d1dfc9ff5d234c5fa778365", "filename": "compiler/rustc_hir_typeck/src/method/probe.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99c49d95cd7d704d2226859cfdc419c930cde9c6/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99c49d95cd7d704d2226859cfdc419c930cde9c6/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_hir_typeck%2Fsrc%2Fmethod%2Fprobe.rs?ref=99c49d95cd7d704d2226859cfdc419c930cde9c6", "patch": "@@ -838,7 +838,7 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n                 | ty::PredicateKind::ConstEvaluatable(..)\n                 | ty::PredicateKind::ConstEquate(..)\n                 | ty::PredicateKind::Ambiguous\n-                | ty::PredicateKind::AliasEq(..)\n+                | ty::PredicateKind::AliasRelate(..)\n                 | ty::PredicateKind::TypeWellFormedFromEnv(..) => None,\n             }\n         });"}, {"sha": "88a28e26005d62f54ecb2120364ab94b96cbae75", "filename": "compiler/rustc_infer/src/infer/combine.rs", "status": "modified", "additions": 11, "deletions": 9, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/99c49d95cd7d704d2226859cfdc419c930cde9c6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99c49d95cd7d704d2226859cfdc419c930cde9c6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs?ref=99c49d95cd7d704d2226859cfdc419c930cde9c6", "patch": "@@ -128,7 +128,7 @@ impl<'tcx> InferCtxt<'tcx> {\n             (_, ty::Alias(AliasKind::Projection, _)) | (ty::Alias(AliasKind::Projection, _), _)\n                 if self.tcx.trait_solver_next() =>\n             {\n-                relation.register_type_equate_obligation(a, b);\n+                relation.register_type_relate_obligation(a, b);\n                 Ok(a)\n             }\n \n@@ -842,23 +842,25 @@ pub trait ObligationEmittingRelation<'tcx>: TypeRelation<'tcx> {\n         let (a, b) = if self.a_is_expected() { (a, b) } else { (b, a) };\n \n         self.register_predicates([ty::Binder::dummy(if self.tcx().trait_solver_next() {\n-            ty::PredicateKind::AliasEq(a.into(), b.into())\n+            ty::PredicateKind::AliasRelate(a.into(), b.into(), ty::AliasRelationDirection::Equate)\n         } else {\n             ty::PredicateKind::ConstEquate(a, b)\n         })]);\n     }\n \n-    /// Register an obligation that both types must be equal to each other.\n-    ///\n-    /// If they aren't equal then the relation doesn't hold.\n-    fn register_type_equate_obligation(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) {\n-        let (a, b) = if self.a_is_expected() { (a, b) } else { (b, a) };\n-\n-        self.register_predicates([ty::Binder::dummy(ty::PredicateKind::AliasEq(\n+    /// Register an obligation that both types must be related to each other according to\n+    /// the [`ty::AliasRelationDirection`] given by [`ObligationEmittingRelation::alias_relate_direction`]\n+    fn register_type_relate_obligation(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) {\n+        self.register_predicates([ty::Binder::dummy(ty::PredicateKind::AliasRelate(\n             a.into(),\n             b.into(),\n+            self.alias_relate_direction(),\n         ))]);\n     }\n+\n+    /// Relation direction emitted for `AliasRelate` predicates, corresponding to the direction\n+    /// of the relation.\n+    fn alias_relate_direction(&self) -> ty::AliasRelationDirection;\n }\n \n fn int_unification_error<'tcx>("}, {"sha": "38002357cde35cbe948c221d95792c4935228e56", "filename": "compiler/rustc_infer/src/infer/equate.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/99c49d95cd7d704d2226859cfdc419c930cde9c6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99c49d95cd7d704d2226859cfdc419c930cde9c6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fequate.rs?ref=99c49d95cd7d704d2226859cfdc419c930cde9c6", "patch": "@@ -210,4 +210,8 @@ impl<'tcx> ObligationEmittingRelation<'tcx> for Equate<'_, '_, 'tcx> {\n     fn register_obligations(&mut self, obligations: PredicateObligations<'tcx>) {\n         self.fields.register_obligations(obligations);\n     }\n+\n+    fn alias_relate_direction(&self) -> ty::AliasRelationDirection {\n+        ty::AliasRelationDirection::Equate\n+    }\n }"}, {"sha": "6395c4d4b20781f86ec5dd01dfe1d3f559a83a74", "filename": "compiler/rustc_infer/src/infer/glb.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/99c49d95cd7d704d2226859cfdc419c930cde9c6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fglb.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99c49d95cd7d704d2226859cfdc419c930cde9c6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fglb.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fglb.rs?ref=99c49d95cd7d704d2226859cfdc419c930cde9c6", "patch": "@@ -155,4 +155,9 @@ impl<'tcx> ObligationEmittingRelation<'tcx> for Glb<'_, '_, 'tcx> {\n     fn register_obligations(&mut self, obligations: PredicateObligations<'tcx>) {\n         self.fields.register_obligations(obligations);\n     }\n+\n+    fn alias_relate_direction(&self) -> ty::AliasRelationDirection {\n+        // FIXME(deferred_projection_equality): This isn't right, I think?\n+        ty::AliasRelationDirection::Equate\n+    }\n }"}, {"sha": "98cbd4c561c52d0b6d6703c170ff2bd7db914ffc", "filename": "compiler/rustc_infer/src/infer/lub.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/99c49d95cd7d704d2226859cfdc419c930cde9c6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99c49d95cd7d704d2226859cfdc419c930cde9c6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Flub.rs?ref=99c49d95cd7d704d2226859cfdc419c930cde9c6", "patch": "@@ -155,4 +155,9 @@ impl<'tcx> ObligationEmittingRelation<'tcx> for Lub<'_, '_, 'tcx> {\n     fn register_obligations(&mut self, obligations: PredicateObligations<'tcx>) {\n         self.fields.register_obligations(obligations)\n     }\n+\n+    fn alias_relate_direction(&self) -> ty::AliasRelationDirection {\n+        // FIXME(deferred_projection_equality): This isn't right, I think?\n+        ty::AliasRelationDirection::Equate\n+    }\n }"}, {"sha": "f5d20cb7ebfeba81e2e531031eecf20b1ab2bec6", "filename": "compiler/rustc_infer/src/infer/nll_relate/mod.rs", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/99c49d95cd7d704d2226859cfdc419c930cde9c6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99c49d95cd7d704d2226859cfdc419c930cde9c6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fnll_relate%2Fmod.rs?ref=99c49d95cd7d704d2226859cfdc419c930cde9c6", "patch": "@@ -711,6 +711,34 @@ where\n     fn register_obligations(&mut self, obligations: PredicateObligations<'tcx>) {\n         self.delegate.register_obligations(obligations);\n     }\n+\n+    fn alias_relate_direction(&self) -> ty::AliasRelationDirection {\n+        unreachable!(\"manually overridden to handle ty::Variance::Contravariant ambient variance\")\n+    }\n+\n+    fn register_type_relate_obligation(&mut self, a: Ty<'tcx>, b: Ty<'tcx>) {\n+        self.register_predicates([ty::Binder::dummy(match self.ambient_variance {\n+            ty::Variance::Covariant => ty::PredicateKind::AliasRelate(\n+                a.into(),\n+                b.into(),\n+                ty::AliasRelationDirection::Subtype,\n+            ),\n+            // a :> b is b <: a\n+            ty::Variance::Contravariant => ty::PredicateKind::AliasRelate(\n+                b.into(),\n+                a.into(),\n+                ty::AliasRelationDirection::Subtype,\n+            ),\n+            ty::Variance::Invariant => ty::PredicateKind::AliasRelate(\n+                a.into(),\n+                b.into(),\n+                ty::AliasRelationDirection::Equate,\n+            ),\n+            // FIXME(deferred_projection_equality): Implement this when we trigger it.\n+            // Probably just need to do nothing here.\n+            ty::Variance::Bivariant => unreachable!(),\n+        })]);\n+    }\n }\n \n /// When we encounter a binder like `for<..> fn(..)`, we actually have"}, {"sha": "048dad3a48bc2a8c623bc893c095829957b2fe87", "filename": "compiler/rustc_infer/src/infer/outlives/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99c49d95cd7d704d2226859cfdc419c930cde9c6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99c49d95cd7d704d2226859cfdc419c930cde9c6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fmod.rs?ref=99c49d95cd7d704d2226859cfdc419c930cde9c6", "patch": "@@ -22,7 +22,7 @@ pub fn explicit_outlives_bounds<'tcx>(\n             ty::PredicateKind::Clause(ty::Clause::Projection(..))\n             | ty::PredicateKind::Clause(ty::Clause::Trait(..))\n             | ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(..))\n-            | ty::PredicateKind::AliasEq(..)\n+            | ty::PredicateKind::AliasRelate(..)\n             | ty::PredicateKind::Coerce(..)\n             | ty::PredicateKind::Subtype(..)\n             | ty::PredicateKind::WellFormed(..)"}, {"sha": "fa6529dfa93ec886216f9961857f28798105a9fb", "filename": "compiler/rustc_infer/src/infer/projection.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99c49d95cd7d704d2226859cfdc419c930cde9c6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fprojection.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99c49d95cd7d704d2226859cfdc419c930cde9c6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fprojection.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fprojection.rs?ref=99c49d95cd7d704d2226859cfdc419c930cde9c6", "patch": "@@ -26,7 +26,7 @@ impl<'tcx> InferCtxt<'tcx> {\n             // completely change the normalization routine with the new solver.\n             //\n             // The new solver correctly handles projection equality so this hack\n-            // is not necessary. if re-enabled it should emit `PredicateKind::AliasEq`\n+            // is not necessary. if re-enabled it should emit `PredicateKind::AliasRelate`\n             // not `PredicateKind::Clause(Clause::Projection(..))` as in the new solver\n             // `Projection` is used as `normalizes-to` which will fail for `<T as Trait>::Assoc eq ?0`.\n             return projection_ty.to_ty(self.tcx);"}, {"sha": "fc73ca7606d238213c3edbc74b7dc4045c4ac9c4", "filename": "compiler/rustc_infer/src/infer/sub.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/99c49d95cd7d704d2226859cfdc419c930cde9c6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99c49d95cd7d704d2226859cfdc419c930cde9c6/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs?ref=99c49d95cd7d704d2226859cfdc419c930cde9c6", "patch": "@@ -236,4 +236,8 @@ impl<'tcx> ObligationEmittingRelation<'tcx> for Sub<'_, '_, 'tcx> {\n     fn register_obligations(&mut self, obligations: PredicateObligations<'tcx>) {\n         self.fields.register_obligations(obligations);\n     }\n+\n+    fn alias_relate_direction(&self) -> ty::AliasRelationDirection {\n+        ty::AliasRelationDirection::Subtype\n+    }\n }"}, {"sha": "0d2faeba5fc0fe73021a29f9edc5ca59f308984f", "filename": "compiler/rustc_infer/src/traits/util.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99c49d95cd7d704d2226859cfdc419c930cde9c6/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99c49d95cd7d704d2226859cfdc419c930cde9c6/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs?ref=99c49d95cd7d704d2226859cfdc419c930cde9c6", "patch": "@@ -293,7 +293,7 @@ impl<'tcx> Elaborator<'tcx> {\n                 // Nothing to elaborate\n             }\n             ty::PredicateKind::Ambiguous => {}\n-            ty::PredicateKind::AliasEq(..) => {\n+            ty::PredicateKind::AliasRelate(..) => {\n                 // No\n             }\n             ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(..)) => {"}, {"sha": "64c3ef451374efc12a89794b7b8e004432ccfcef", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99c49d95cd7d704d2226859cfdc419c930cde9c6/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99c49d95cd7d704d2226859cfdc419c930cde9c6/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=99c49d95cd7d704d2226859cfdc419c930cde9c6", "patch": "@@ -1600,7 +1600,7 @@ impl<'tcx> LateLintPass<'tcx> for TrivialConstraints {\n                     // Ignore projections, as they can only be global\n                     // if the trait bound is global\n                     Clause(Clause::Projection(..)) |\n-                    AliasEq(..) |\n+                    AliasRelate(..) |\n                     // Ignore bounds that a user can't type\n                     WellFormed(..) |\n                     ObjectSafe(..) |"}, {"sha": "f9d43fe220036e70c527e792ea10944d027e9f5d", "filename": "compiler/rustc_lint/src/opaque_hidden_inferred_bound.rs", "status": "modified", "additions": 18, "deletions": 3, "changes": 21, "blob_url": "https://github.com/rust-lang/rust/blob/99c49d95cd7d704d2226859cfdc419c930cde9c6/compiler%2Frustc_lint%2Fsrc%2Fopaque_hidden_inferred_bound.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99c49d95cd7d704d2226859cfdc419c930cde9c6/compiler%2Frustc_lint%2Fsrc%2Fopaque_hidden_inferred_bound.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fopaque_hidden_inferred_bound.rs?ref=99c49d95cd7d704d2226859cfdc419c930cde9c6", "patch": "@@ -27,6 +27,8 @@ declare_lint! {\n     /// ### Example\n     ///\n     /// ```rust\n+    /// #![feature(type_alias_impl_trait)]\n+    ///\n     /// trait Duh {}\n     ///\n     /// impl Duh for i32 {}\n@@ -41,7 +43,9 @@ declare_lint! {\n     ///     type Assoc = F;\n     /// }\n     ///\n-    /// fn test() -> impl Trait<Assoc = impl Sized> {\n+    /// type Tait = impl Sized;\n+    ///\n+    /// fn test() -> impl Trait<Assoc = Tait> {\n     ///     42\n     /// }\n     /// ```\n@@ -54,7 +58,7 @@ declare_lint! {\n     ///\n     /// Although the hidden type, `i32` does satisfy this bound, we do not\n     /// consider the return type to be well-formed with this lint. It can be\n-    /// fixed by changing `impl Sized` into `impl Sized + Send`.\n+    /// fixed by changing `Tait = impl Sized` into `Tait = impl Sized + Send`.\n     pub OPAQUE_HIDDEN_INFERRED_BOUND,\n     Warn,\n     \"detects the use of nested `impl Trait` types in associated type bounds that are not general enough\"\n@@ -64,7 +68,7 @@ declare_lint_pass!(OpaqueHiddenInferredBound => [OPAQUE_HIDDEN_INFERRED_BOUND]);\n \n impl<'tcx> LateLintPass<'tcx> for OpaqueHiddenInferredBound {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::Item<'tcx>) {\n-        let hir::ItemKind::OpaqueTy(_) = &item.kind else { return; };\n+        let hir::ItemKind::OpaqueTy(opaque) = &item.kind else { return; };\n         let def_id = item.owner_id.def_id.to_def_id();\n         let infcx = &cx.tcx.infer_ctxt().build();\n         // For every projection predicate in the opaque type's explicit bounds,\n@@ -81,6 +85,17 @@ impl<'tcx> LateLintPass<'tcx> for OpaqueHiddenInferredBound {\n             // have opaques in them anyways.\n             let Some(proj_term) = proj.term.ty() else { continue };\n \n+            // HACK: `impl Trait<Assoc = impl Trait2>` from an RPIT is \"ok\"...\n+            if let ty::Alias(ty::Opaque, opaque_ty) = *proj_term.kind()\n+                && cx.tcx.parent(opaque_ty.def_id) == def_id\n+                && matches!(\n+                    opaque.origin,\n+                    hir::OpaqueTyOrigin::FnReturn(_) | hir::OpaqueTyOrigin::AsyncFn(_)\n+                )\n+            {\n+                continue;\n+            }\n+\n             let proj_ty =\n                 cx.tcx.mk_projection(proj.projection_ty.def_id, proj.projection_ty.substs);\n             // For every instance of the projection type in the bounds,"}, {"sha": "2438c061475e51045e0fb6f72c51e6da139f41e6", "filename": "compiler/rustc_metadata/src/rmeta/decoder.rs", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/99c49d95cd7d704d2226859cfdc419c930cde9c6/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99c49d95cd7d704d2226859cfdc419c930cde9c6/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder.rs?ref=99c49d95cd7d704d2226859cfdc419c930cde9c6", "patch": "@@ -925,10 +925,6 @@ impl<'a, 'tcx> CrateMetadataRef<'a> {\n         tcx.mk_adt_def(did, adt_kind, variants, repr)\n     }\n \n-    fn get_generics(self, item_id: DefIndex, sess: &Session) -> ty::Generics {\n-        self.root.tables.generics_of.get(self, item_id).unwrap().decode((self, sess))\n-    }\n-\n     fn get_visibility(self, id: DefIndex) -> Visibility<DefId> {\n         self.root\n             .tables"}, {"sha": "3182c6c08873ee47fb943a84db8d154838279db7", "filename": "compiler/rustc_metadata/src/rmeta/decoder/cstore_impl.rs", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/99c49d95cd7d704d2226859cfdc419c930cde9c6/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99c49d95cd7d704d2226859cfdc419c930cde9c6/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fdecoder%2Fcstore_impl.rs?ref=99c49d95cd7d704d2226859cfdc419c930cde9c6", "patch": "@@ -545,10 +545,6 @@ impl CStore {\n         self.get_crate_data(def.krate).def_kind(def.index)\n     }\n \n-    pub fn item_generics_num_lifetimes(&self, def_id: DefId, sess: &Session) -> usize {\n-        self.get_crate_data(def_id.krate).get_generics(def_id.index, sess).own_counts().lifetimes\n-    }\n-\n     pub fn module_expansion_untracked(&self, def_id: DefId, sess: &Session) -> ExpnId {\n         self.get_crate_data(def_id.krate).module_expansion(def_id.index, sess)\n     }\n@@ -560,14 +556,6 @@ impl CStore {\n         self.get_crate_data(cnum).num_def_ids()\n     }\n \n-    pub fn item_attrs_untracked<'a>(\n-        &'a self,\n-        def_id: DefId,\n-        sess: &'a Session,\n-    ) -> impl Iterator<Item = ast::Attribute> + 'a {\n-        self.get_crate_data(def_id.krate).get_item_attrs(def_id.index, sess)\n-    }\n-\n     pub fn get_proc_macro_quoted_span_untracked(\n         &self,\n         cnum: CrateNum,"}, {"sha": "5a6ee1238112cb14dc2207cf463a1d1bbca256f5", "filename": "compiler/rustc_middle/src/ty/flags.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99c49d95cd7d704d2226859cfdc419c930cde9c6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99c49d95cd7d704d2226859cfdc419c930cde9c6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs?ref=99c49d95cd7d704d2226859cfdc419c930cde9c6", "patch": "@@ -288,7 +288,7 @@ impl FlagComputation {\n                 self.add_ty(ty);\n             }\n             ty::PredicateKind::Ambiguous => {}\n-            ty::PredicateKind::AliasEq(t1, t2) => {\n+            ty::PredicateKind::AliasRelate(t1, t2, _) => {\n                 self.add_term(t1);\n                 self.add_term(t2);\n             }"}, {"sha": "b17749c1ebafa87c3702f98aba04443f2c28a41c", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/99c49d95cd7d704d2226859cfdc419c930cde9c6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99c49d95cd7d704d2226859cfdc419c930cde9c6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=99c49d95cd7d704d2226859cfdc419c930cde9c6", "patch": "@@ -543,7 +543,7 @@ impl<'tcx> Predicate<'tcx> {\n             | PredicateKind::Clause(Clause::TypeOutlives(_))\n             | PredicateKind::Clause(Clause::Projection(_))\n             | PredicateKind::Clause(Clause::ConstArgHasType(..))\n-            | PredicateKind::AliasEq(..)\n+            | PredicateKind::AliasRelate(..)\n             | PredicateKind::ObjectSafe(_)\n             | PredicateKind::ClosureKind(_, _, _)\n             | PredicateKind::Subtype(_)\n@@ -640,7 +640,23 @@ pub enum PredicateKind<'tcx> {\n     /// This predicate requires two terms to be equal to eachother.\n     ///\n     /// Only used for new solver\n-    AliasEq(Term<'tcx>, Term<'tcx>),\n+    AliasRelate(Term<'tcx>, Term<'tcx>, AliasRelationDirection),\n+}\n+\n+#[derive(Clone, Copy, PartialEq, Eq, Hash, TyEncodable, TyDecodable)]\n+#[derive(HashStable, Debug)]\n+pub enum AliasRelationDirection {\n+    Equate,\n+    Subtype,\n+}\n+\n+impl std::fmt::Display for AliasRelationDirection {\n+    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {\n+        match self {\n+            AliasRelationDirection::Equate => write!(f, \" == \"),\n+            AliasRelationDirection::Subtype => write!(f, \" <: \"),\n+        }\n+    }\n }\n \n /// The crate outlives map is computed during typeck and contains the\n@@ -976,11 +992,11 @@ impl<'tcx> Term<'tcx> {\n         }\n     }\n \n-    /// This function returns `None` for `AliasKind::Opaque`.\n+    /// This function returns the inner `AliasTy` if this term is a projection.\n     ///\n     /// FIXME: rename `AliasTy` to `AliasTerm` and make sure we correctly\n     /// deal with constants.\n-    pub fn to_alias_term_no_opaque(&self, tcx: TyCtxt<'tcx>) -> Option<AliasTy<'tcx>> {\n+    pub fn to_projection_term(&self, tcx: TyCtxt<'tcx>) -> Option<AliasTy<'tcx>> {\n         match self.unpack() {\n             TermKind::Ty(ty) => match ty.kind() {\n                 ty::Alias(kind, alias_ty) => match kind {\n@@ -1206,7 +1222,7 @@ impl<'tcx> Predicate<'tcx> {\n             PredicateKind::Clause(Clause::Trait(t)) => Some(predicate.rebind(t)),\n             PredicateKind::Clause(Clause::Projection(..))\n             | PredicateKind::Clause(Clause::ConstArgHasType(..))\n-            | PredicateKind::AliasEq(..)\n+            | PredicateKind::AliasRelate(..)\n             | PredicateKind::Subtype(..)\n             | PredicateKind::Coerce(..)\n             | PredicateKind::Clause(Clause::RegionOutlives(..))\n@@ -1227,7 +1243,7 @@ impl<'tcx> Predicate<'tcx> {\n             PredicateKind::Clause(Clause::Projection(t)) => Some(predicate.rebind(t)),\n             PredicateKind::Clause(Clause::Trait(..))\n             | PredicateKind::Clause(Clause::ConstArgHasType(..))\n-            | PredicateKind::AliasEq(..)\n+            | PredicateKind::AliasRelate(..)\n             | PredicateKind::Subtype(..)\n             | PredicateKind::Coerce(..)\n             | PredicateKind::Clause(Clause::RegionOutlives(..))\n@@ -1249,7 +1265,7 @@ impl<'tcx> Predicate<'tcx> {\n             PredicateKind::Clause(Clause::Trait(..))\n             | PredicateKind::Clause(Clause::ConstArgHasType(..))\n             | PredicateKind::Clause(Clause::Projection(..))\n-            | PredicateKind::AliasEq(..)\n+            | PredicateKind::AliasRelate(..)\n             | PredicateKind::Subtype(..)\n             | PredicateKind::Coerce(..)\n             | PredicateKind::Clause(Clause::RegionOutlives(..))"}, {"sha": "de4c703107e1405f8aa05594e2d5733e6ec06943", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/99c49d95cd7d704d2226859cfdc419c930cde9c6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99c49d95cd7d704d2226859cfdc419c930cde9c6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=99c49d95cd7d704d2226859cfdc419c930cde9c6", "patch": "@@ -704,7 +704,11 @@ pub trait PrettyPrinter<'tcx>:\n                 ty::BoundTyKind::Anon(bv) => {\n                     self.pretty_print_bound_var(debruijn, ty::BoundVar::from_u32(bv))?\n                 }\n-                ty::BoundTyKind::Param(_, s) => p!(write(\"{}\", s)),\n+                ty::BoundTyKind::Param(_, s) => match self.should_print_verbose() {\n+                    true if debruijn == ty::INNERMOST => p!(write(\"^{}\", s)),\n+                    true => p!(write(\"^{}_{}\", debruijn.index(), s)),\n+                    false => p!(write(\"{}\", s)),\n+                },\n             },\n             ty::Adt(def, substs) => {\n                 p!(print_def_path(def.did(), substs));\n@@ -2847,7 +2851,7 @@ define_print_and_forward_display! {\n                 p!(\"the type `\", print(ty), \"` is found in the environment\")\n             }\n             ty::PredicateKind::Ambiguous => p!(\"ambiguous\"),\n-            ty::PredicateKind::AliasEq(t1, t2) => p!(print(t1), \" == \", print(t2)),\n+            ty::PredicateKind::AliasRelate(t1, t2, dir) => p!(print(t1), write(\" {} \", dir), print(t2)),\n         }\n     }\n "}, {"sha": "c6bb8146795869ef95866a097556ea79766fae97", "filename": "compiler/rustc_middle/src/ty/structural_impls.rs", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/99c49d95cd7d704d2226859cfdc419c930cde9c6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99c49d95cd7d704d2226859cfdc419c930cde9c6/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs?ref=99c49d95cd7d704d2226859cfdc419c930cde9c6", "patch": "@@ -177,7 +177,9 @@ impl<'tcx> fmt::Debug for ty::PredicateKind<'tcx> {\n                 write!(f, \"TypeWellFormedFromEnv({:?})\", ty)\n             }\n             ty::PredicateKind::Ambiguous => write!(f, \"Ambiguous\"),\n-            ty::PredicateKind::AliasEq(t1, t2) => write!(f, \"AliasEq({t1:?}, {t2:?})\"),\n+            ty::PredicateKind::AliasRelate(t1, t2, dir) => {\n+                write!(f, \"AliasRelate({t1:?}, {dir:?}, {t2:?})\")\n+            }\n         }\n     }\n }\n@@ -250,6 +252,7 @@ TrivialTypeTraversalAndLiftImpls! {\n     crate::ty::AssocItem,\n     crate::ty::AssocKind,\n     crate::ty::AliasKind,\n+    crate::ty::AliasRelationDirection,\n     crate::ty::Placeholder<crate::ty::BoundRegionKind>,\n     crate::ty::Placeholder<crate::ty::BoundTyKind>,\n     crate::ty::ClosureKind,"}, {"sha": "3b775f590a4c1fa8427ebd66e6a33f6d6c88a177", "filename": "compiler/rustc_mir_build/src/build/expr/as_rvalue.rs", "status": "modified", "additions": 33, "deletions": 23, "changes": 56, "blob_url": "https://github.com/rust-lang/rust/blob/99c49d95cd7d704d2226859cfdc419c930cde9c6/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99c49d95cd7d704d2226859cfdc419c930cde9c6/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir_build%2Fsrc%2Fbuild%2Fexpr%2Fas_rvalue.rs?ref=99c49d95cd7d704d2226859cfdc419c930cde9c6", "patch": "@@ -566,41 +566,51 @@ impl<'a, 'tcx> Builder<'a, 'tcx> {\n                 Rvalue::Use(Operand::Move(val))\n             }\n             BinOp::Shl | BinOp::Shr if self.check_overflow && ty.is_integral() => {\n-                // Consider that the shift overflows if `rhs < 0` or `rhs >= bits`.\n-                // This can be encoded as a single operation as `(rhs & -bits) != 0`.\n-                let (size, _) = ty.int_size_and_signed(self.tcx);\n-                let bits = size.bits();\n-                debug_assert!(bits.is_power_of_two());\n-                let mask = !((bits - 1) as u128);\n-\n+                // For an unsigned RHS, the shift is in-range for `rhs < bits`.\n+                // For a signed RHS, `IntToInt` cast to the equivalent unsigned\n+                // type and do that same comparison.  Because the type is the\n+                // same size, there's no negative shift amount that ends up\n+                // overlapping with valid ones, thus it catches negatives too.\n+                let (lhs_size, _) = ty.int_size_and_signed(self.tcx);\n                 let rhs_ty = rhs.ty(&self.local_decls, self.tcx);\n                 let (rhs_size, _) = rhs_ty.int_size_and_signed(self.tcx);\n-                let mask = Operand::const_from_scalar(\n+\n+                let (unsigned_rhs, unsigned_ty) = match rhs_ty.kind() {\n+                    ty::Uint(_) => (rhs.to_copy(), rhs_ty),\n+                    ty::Int(int_width) => {\n+                        let uint_ty = self.tcx.mk_mach_uint(int_width.to_unsigned());\n+                        let rhs_temp = self.temp(uint_ty, span);\n+                        self.cfg.push_assign(\n+                            block,\n+                            source_info,\n+                            rhs_temp,\n+                            Rvalue::Cast(CastKind::IntToInt, rhs.to_copy(), uint_ty),\n+                        );\n+                        (Operand::Move(rhs_temp), uint_ty)\n+                    }\n+                    _ => unreachable!(\"only integers are shiftable\"),\n+                };\n+\n+                // This can't overflow because the largest shiftable types are 128-bit,\n+                // which fits in `u8`, the smallest possible `unsigned_ty`.\n+                // (And `from_uint` will `bug!` if that's ever no longer true.)\n+                let lhs_bits = Operand::const_from_scalar(\n                     self.tcx,\n-                    rhs_ty,\n-                    Scalar::from_uint(rhs_size.truncate(mask), rhs_size),\n+                    unsigned_ty,\n+                    Scalar::from_uint(lhs_size.bits(), rhs_size),\n                     span,\n                 );\n \n-                let outer_bits = self.temp(rhs_ty, span);\n-                self.cfg.push_assign(\n-                    block,\n-                    source_info,\n-                    outer_bits,\n-                    Rvalue::BinaryOp(BinOp::BitAnd, Box::new((rhs.to_copy(), mask))),\n-                );\n-\n-                let overflows = self.temp(bool_ty, span);\n-                let zero = self.zero_literal(span, rhs_ty);\n+                let inbounds = self.temp(bool_ty, span);\n                 self.cfg.push_assign(\n                     block,\n                     source_info,\n-                    overflows,\n-                    Rvalue::BinaryOp(BinOp::Ne, Box::new((Operand::Move(outer_bits), zero))),\n+                    inbounds,\n+                    Rvalue::BinaryOp(BinOp::Lt, Box::new((unsigned_rhs, lhs_bits))),\n                 );\n \n                 let overflow_err = AssertKind::Overflow(op, lhs.to_copy(), rhs.to_copy());\n-                block = self.assert(block, Operand::Move(overflows), false, overflow_err, span);\n+                block = self.assert(block, Operand::Move(inbounds), true, overflow_err, span);\n                 Rvalue::BinaryOp(op, Box::new((lhs, rhs)))\n             }\n             BinOp::Div | BinOp::Rem if ty.is_integral() => {"}, {"sha": "3be0160d56173d40a6e8878a44ec161220334fb6", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99c49d95cd7d704d2226859cfdc419c930cde9c6/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99c49d95cd7d704d2226859cfdc419c930cde9c6/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=99c49d95cd7d704d2226859cfdc419c930cde9c6", "patch": "@@ -180,7 +180,7 @@ where\n             | ty::PredicateKind::ConstEquate(_, _)\n             | ty::PredicateKind::TypeWellFormedFromEnv(_)\n             | ty::PredicateKind::Ambiguous\n-            | ty::PredicateKind::AliasEq(_, _) => bug!(\"unexpected predicate: {:?}\", predicate),\n+            | ty::PredicateKind::AliasRelate(..) => bug!(\"unexpected predicate: {:?}\", predicate),\n         }\n     }\n "}, {"sha": "f031d7cdb1aa3227954c31c6c1bea0eae5e621d6", "filename": "compiler/rustc_resolve/src/build_reduced_graph.rs", "status": "modified", "additions": 16, "deletions": 26, "changes": 42, "blob_url": "https://github.com/rust-lang/rust/blob/99c49d95cd7d704d2226859cfdc419c930cde9c6/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99c49d95cd7d704d2226859cfdc419c930cde9c6/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Fbuild_reduced_graph.rs?ref=99c49d95cd7d704d2226859cfdc419c930cde9c6", "patch": "@@ -27,7 +27,6 @@ use rustc_hir::def_id::{DefId, LocalDefId, CRATE_DEF_ID};\n use rustc_metadata::creader::LoadedMacro;\n use rustc_middle::metadata::ModChild;\n use rustc_middle::{bug, ty};\n-use rustc_session::cstore::CrateStore;\n use rustc_span::hygiene::{ExpnId, LocalExpnId, MacroKind};\n use rustc_span::symbol::{kw, sym, Ident, Symbol};\n use rustc_span::Span;\n@@ -116,33 +115,24 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n \n         if !def_id.is_local() {\n             let def_kind = self.cstore().def_kind(def_id);\n-            match def_kind {\n-                DefKind::Mod | DefKind::Enum | DefKind::Trait => {\n-                    let def_key = self.cstore().def_key(def_id);\n-                    let parent = def_key.parent.map(|index| {\n-                        self.get_nearest_non_block_module(DefId { index, krate: def_id.krate })\n-                    });\n-                    let name = if let Some(cnum) = def_id.as_crate_root() {\n-                        self.cstore().crate_name(cnum)\n-                    } else {\n-                        def_key.disambiguated_data.data.get_opt_name().expect(\"module without name\")\n-                    };\n-\n-                    let expn_id = self.cstore().module_expansion_untracked(def_id, &self.tcx.sess);\n-                    Some(self.new_module(\n-                        parent,\n-                        ModuleKind::Def(def_kind, def_id, name),\n-                        expn_id,\n-                        self.def_span(def_id),\n-                        // FIXME: Account for `#[no_implicit_prelude]` attributes.\n-                        parent.map_or(false, |module| module.no_implicit_prelude),\n-                    ))\n-                }\n-                _ => None,\n+            if let DefKind::Mod | DefKind::Enum | DefKind::Trait = def_kind {\n+                let parent = self\n+                    .tcx\n+                    .opt_parent(def_id)\n+                    .map(|parent_id| self.get_nearest_non_block_module(parent_id));\n+                let expn_id = self.cstore().module_expansion_untracked(def_id, &self.tcx.sess);\n+                return Some(self.new_module(\n+                    parent,\n+                    ModuleKind::Def(def_kind, def_id, self.tcx.item_name(def_id)),\n+                    expn_id,\n+                    self.def_span(def_id),\n+                    // FIXME: Account for `#[no_implicit_prelude]` attributes.\n+                    parent.map_or(false, |module| module.no_implicit_prelude),\n+                ));\n             }\n-        } else {\n-            None\n         }\n+\n+        None\n     }\n \n     pub(crate) fn expn_def_scope(&mut self, expn_id: ExpnId) -> Module<'a> {"}, {"sha": "0a99295b59a737c136eeef85d9eb8b0edc0961a1", "filename": "compiler/rustc_resolve/src/lib.rs", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/99c49d95cd7d704d2226859cfdc419c930cde9c6/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99c49d95cd7d704d2226859cfdc419c930cde9c6/compiler%2Frustc_resolve%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_resolve%2Fsrc%2Flib.rs?ref=99c49d95cd7d704d2226859cfdc419c930cde9c6", "patch": "@@ -1168,7 +1168,7 @@ impl<'tcx> Resolver<'_, 'tcx> {\n         if let Some(def_id) = def_id.as_local() {\n             self.item_generics_num_lifetimes[&def_id]\n         } else {\n-            self.cstore().item_generics_num_lifetimes(def_id, self.tcx.sess)\n+            self.tcx.generics_of(def_id).own_counts().lifetimes\n         }\n     }\n \n@@ -1906,10 +1906,7 @@ impl<'a, 'tcx> Resolver<'a, 'tcx> {\n                     return v.clone();\n                 }\n \n-                let attr = self\n-                    .cstore()\n-                    .item_attrs_untracked(def_id, self.tcx.sess)\n-                    .find(|a| a.has_name(sym::rustc_legacy_const_generics))?;\n+                let attr = self.tcx.get_attr(def_id, sym::rustc_legacy_const_generics)?;\n                 let mut ret = Vec::new();\n                 for meta in attr.meta_item_list()? {\n                     match meta.lit()?.kind {"}, {"sha": "f1f0132c7b805657dbaf51583b0c5cc9d0c85f5c", "filename": "compiler/rustc_trait_selection/src/solve/eval_ctxt.rs", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/rust-lang/rust/blob/99c49d95cd7d704d2226859cfdc419c930cde9c6/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99c49d95cd7d704d2226859cfdc419c930cde9c6/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Feval_ctxt.rs?ref=99c49d95cd7d704d2226859cfdc419c930cde9c6", "patch": "@@ -236,9 +236,11 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n                 ty::PredicateKind::TypeWellFormedFromEnv(..) => {\n                     bug!(\"TypeWellFormedFromEnv is only used for Chalk\")\n                 }\n-                ty::PredicateKind::AliasEq(lhs, rhs) => {\n-                    self.compute_alias_eq_goal(Goal { param_env, predicate: (lhs, rhs) })\n-                }\n+                ty::PredicateKind::AliasRelate(lhs, rhs, direction) => self\n+                    .compute_alias_relate_goal(Goal {\n+                        param_env,\n+                        predicate: (lhs, rhs, direction),\n+                    }),\n             }\n         } else {\n             let kind = self.infcx.instantiate_binder_with_placeholders(kind);\n@@ -470,6 +472,25 @@ impl<'tcx> EvalCtxt<'_, 'tcx> {\n             })\n     }\n \n+    #[instrument(level = \"debug\", skip(self, param_env), ret)]\n+    pub(super) fn sub<T: ToTrace<'tcx>>(\n+        &mut self,\n+        param_env: ty::ParamEnv<'tcx>,\n+        sub: T,\n+        sup: T,\n+    ) -> Result<(), NoSolution> {\n+        self.infcx\n+            .at(&ObligationCause::dummy(), param_env)\n+            .sub(DefineOpaqueTypes::No, sub, sup)\n+            .map(|InferOk { value: (), obligations }| {\n+                self.add_goals(obligations.into_iter().map(|o| o.into()));\n+            })\n+            .map_err(|e| {\n+                debug!(?e, \"failed to subtype\");\n+                NoSolution\n+            })\n+    }\n+\n     /// Equates two values returning the nested goals without adding them\n     /// to the nested goals of the `EvalCtxt`.\n     ///"}, {"sha": "01f171762ab67e33698f30190842458db7b05897", "filename": "compiler/rustc_trait_selection/src/solve/fulfill.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99c49d95cd7d704d2226859cfdc419c930cde9c6/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99c49d95cd7d704d2226859cfdc419c930cde9c6/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Ffulfill.rs?ref=99c49d95cd7d704d2226859cfdc419c930cde9c6", "patch": "@@ -73,7 +73,7 @@ impl<'tcx> TraitEngine<'tcx> for FulfillmentCtxt<'tcx> {\n                                         MismatchedProjectionTypes { err: TypeError::Mismatch },\n                                     )\n                                 }\n-                                ty::PredicateKind::AliasEq(_, _) => {\n+                                ty::PredicateKind::AliasRelate(_, _, _) => {\n                                     FulfillmentErrorCode::CodeProjectionError(\n                                         MismatchedProjectionTypes { err: TypeError::Mismatch },\n                                     )"}, {"sha": "6a64dfdedd42fe6c40a3f6256b2997f895dbf0a4", "filename": "compiler/rustc_trait_selection/src/solve/mod.rs", "status": "modified", "additions": 77, "deletions": 43, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/99c49d95cd7d704d2226859cfdc419c930cde9c6/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99c49d95cd7d704d2226859cfdc419c930cde9c6/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fsolve%2Fmod.rs?ref=99c49d95cd7d704d2226859cfdc419c930cde9c6", "patch": "@@ -13,7 +13,6 @@\n \n use rustc_hir::def_id::DefId;\n use rustc_infer::infer::canonical::{Canonical, CanonicalVarValues};\n-use rustc_infer::infer::{DefineOpaqueTypes, InferOk};\n use rustc_infer::traits::query::NoSolution;\n use rustc_middle::traits::solve::{\n     CanonicalGoal, CanonicalResponse, Certainty, ExternalConstraints, ExternalConstraintsData,\n@@ -110,11 +109,7 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n             // That won't actually reflect in the query response, so it seems moot.\n             self.evaluate_added_goals_and_make_canonical_response(Certainty::AMBIGUOUS)\n         } else {\n-            let InferOk { value: (), obligations } = self\n-                .infcx\n-                .at(&ObligationCause::dummy(), goal.param_env)\n-                .sub(DefineOpaqueTypes::No, goal.predicate.a, goal.predicate.b)?;\n-            self.add_goals(obligations.into_iter().map(|pred| pred.into()));\n+            self.sub(goal.param_env, goal.predicate.a, goal.predicate.b)?;\n             self.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n         }\n     }\n@@ -165,55 +160,94 @@ impl<'a, 'tcx> EvalCtxt<'a, 'tcx> {\n     }\n \n     #[instrument(level = \"debug\", skip(self), ret)]\n-    fn compute_alias_eq_goal(\n+    fn compute_alias_relate_goal(\n         &mut self,\n-        goal: Goal<'tcx, (ty::Term<'tcx>, ty::Term<'tcx>)>,\n+        goal: Goal<'tcx, (ty::Term<'tcx>, ty::Term<'tcx>, ty::AliasRelationDirection)>,\n     ) -> QueryResult<'tcx> {\n         let tcx = self.tcx();\n+        // We may need to invert the alias relation direction if dealing an alias on the RHS.\n+        enum Invert {\n+            No,\n+            Yes,\n+        }\n+        let evaluate_normalizes_to =\n+            |ecx: &mut EvalCtxt<'_, 'tcx>, alias, other, direction, invert| {\n+                debug!(\"evaluate_normalizes_to(alias={:?}, other={:?})\", alias, other);\n+                let result = ecx.probe(|ecx| {\n+                    let other = match direction {\n+                        // This is purely an optimization.\n+                        ty::AliasRelationDirection::Equate => other,\n+\n+                        ty::AliasRelationDirection::Subtype => {\n+                            let fresh = ecx.next_term_infer_of_kind(other);\n+                            let (sub, sup) = match invert {\n+                                Invert::No => (fresh, other),\n+                                Invert::Yes => (other, fresh),\n+                            };\n+                            ecx.sub(goal.param_env, sub, sup)?;\n+                            fresh\n+                        }\n+                    };\n+                    ecx.add_goal(goal.with(\n+                        tcx,\n+                        ty::Binder::dummy(ty::ProjectionPredicate {\n+                            projection_ty: alias,\n+                            term: other,\n+                        }),\n+                    ));\n+                    ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n+                });\n+                debug!(\"evaluate_normalizes_to({alias}, {other}, {direction:?}) -> {result:?}\");\n+                result\n+            };\n \n-        let evaluate_normalizes_to = |ecx: &mut EvalCtxt<'_, 'tcx>, alias, other| {\n-            debug!(\"evaluate_normalizes_to(alias={:?}, other={:?})\", alias, other);\n-            let r = ecx.probe(|ecx| {\n-                ecx.add_goal(goal.with(\n-                    tcx,\n-                    ty::Binder::dummy(ty::ProjectionPredicate {\n-                        projection_ty: alias,\n-                        term: other,\n-                    }),\n-                ));\n-                ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n-            });\n-            debug!(\"evaluate_normalizes_to(..) -> {:?}\", r);\n-            r\n-        };\n+        let (lhs, rhs, direction) = goal.predicate;\n \n-        if goal.predicate.0.is_infer() || goal.predicate.1.is_infer() {\n+        if lhs.is_infer() || rhs.is_infer() {\n             bug!(\n-                \"`AliasEq` goal with an infer var on lhs or rhs which should have been instantiated\"\n+                \"`AliasRelate` goal with an infer var on lhs or rhs which should have been instantiated\"\n             );\n         }\n \n-        match (\n-            goal.predicate.0.to_alias_term_no_opaque(tcx),\n-            goal.predicate.1.to_alias_term_no_opaque(tcx),\n-        ) {\n-            (None, None) => bug!(\"`AliasEq` goal without an alias on either lhs or rhs\"),\n-            (Some(alias), None) => evaluate_normalizes_to(self, alias, goal.predicate.1),\n-            (None, Some(alias)) => evaluate_normalizes_to(self, alias, goal.predicate.0),\n-            (Some(alias_lhs), Some(alias_rhs)) => {\n-                debug!(\"compute_alias_eq_goal: both sides are aliases\");\n+        match (lhs.to_projection_term(tcx), rhs.to_projection_term(tcx)) {\n+            (None, None) => bug!(\"`AliasRelate` goal without an alias on either lhs or rhs\"),\n \n-                let mut candidates = Vec::with_capacity(3);\n+            // RHS is not a projection, only way this is true is if LHS normalizes-to RHS\n+            (Some(alias_lhs), None) => {\n+                evaluate_normalizes_to(self, alias_lhs, rhs, direction, Invert::No)\n+            }\n \n-                // Evaluate all 3 potential candidates for the alias' being equal\n-                candidates.push(evaluate_normalizes_to(self, alias_lhs, goal.predicate.1));\n-                candidates.push(evaluate_normalizes_to(self, alias_rhs, goal.predicate.0));\n-                candidates.push(self.probe(|ecx| {\n-                    debug!(\"compute_alias_eq_goal: alias defids are equal, equating substs\");\n-                    ecx.eq(goal.param_env, alias_lhs, alias_rhs)?;\n-                    ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n-                }));\n+            // LHS is not a projection, only way this is true is if RHS normalizes-to LHS\n+            (None, Some(alias_rhs)) => {\n+                evaluate_normalizes_to(self, alias_rhs, lhs, direction, Invert::Yes)\n+            }\n \n+            (Some(alias_lhs), Some(alias_rhs)) => {\n+                debug!(\"compute_alias_relate_goal: both sides are aliases\");\n+\n+                let candidates = vec![\n+                    // LHS normalizes-to RHS\n+                    evaluate_normalizes_to(self, alias_lhs, rhs, direction, Invert::No),\n+                    // RHS normalizes-to RHS\n+                    evaluate_normalizes_to(self, alias_rhs, lhs, direction, Invert::Yes),\n+                    // Relate via substs\n+                    self.probe(|ecx| {\n+                        debug!(\n+                            \"compute_alias_relate_goal: alias defids are equal, equating substs\"\n+                        );\n+\n+                        match direction {\n+                            ty::AliasRelationDirection::Equate => {\n+                                ecx.eq(goal.param_env, alias_lhs, alias_rhs)?;\n+                            }\n+                            ty::AliasRelationDirection::Subtype => {\n+                                ecx.sub(goal.param_env, alias_lhs, alias_rhs)?;\n+                            }\n+                        }\n+\n+                        ecx.evaluate_added_goals_and_make_canonical_response(Certainty::Yes)\n+                    }),\n+                ];\n                 debug!(?candidates);\n \n                 self.try_merge_responses(candidates.into_iter())"}, {"sha": "6b3a59b1ed545f4e5926530c8cdd68387b0ae9f5", "filename": "compiler/rustc_trait_selection/src/traits/auto_trait.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99c49d95cd7d704d2226859cfdc419c930cde9c6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99c49d95cd7d704d2226859cfdc419c930cde9c6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs?ref=99c49d95cd7d704d2226859cfdc419c930cde9c6", "patch": "@@ -832,7 +832,7 @@ impl<'tcx> AutoTraitFinder<'tcx> {\n                 // the `ParamEnv`.\n                 ty::PredicateKind::WellFormed(..)\n                 | ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(..))\n-                | ty::PredicateKind::AliasEq(..)\n+                | ty::PredicateKind::AliasRelate(..)\n                 | ty::PredicateKind::ObjectSafe(..)\n                 | ty::PredicateKind::ClosureKind(..)\n                 | ty::PredicateKind::Subtype(..)"}, {"sha": "13607b9079a75d120a712ca7da44a1a40b5158d7", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/method_chain.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/99c49d95cd7d704d2226859cfdc419c930cde9c6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmethod_chain.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99c49d95cd7d704d2226859cfdc419c930cde9c6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmethod_chain.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmethod_chain.rs?ref=99c49d95cd7d704d2226859cfdc419c930cde9c6", "patch": "@@ -92,6 +92,11 @@ impl<'a, 'tcx> TypeRelation<'tcx> for CollectAllMismatches<'a, 'tcx> {\n }\n \n impl<'tcx> ObligationEmittingRelation<'tcx> for CollectAllMismatches<'_, 'tcx> {\n+    fn alias_relate_direction(&self) -> ty::AliasRelationDirection {\n+        // FIXME(deferred_projection_equality): We really should get rid of this relation.\n+        ty::AliasRelationDirection::Equate\n+    }\n+\n     fn register_obligations(&mut self, _obligations: PredicateObligations<'tcx>) {\n         // FIXME(deferred_projection_equality)\n     }"}, {"sha": "617d53b609dbcd4bf81644a1c42abf07ab45f00b", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/99c49d95cd7d704d2226859cfdc419c930cde9c6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99c49d95cd7d704d2226859cfdc419c930cde9c6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=99c49d95cd7d704d2226859cfdc419c930cde9c6", "patch": "@@ -1276,9 +1276,9 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                         \"TypeWellFormedFromEnv predicate should only exist in the environment\"\n                     ),\n \n-                    ty::PredicateKind::AliasEq(..) => span_bug!(\n+                    ty::PredicateKind::AliasRelate(..) => span_bug!(\n                         span,\n-                        \"AliasEq predicate should never be the predicate cause of a SelectionError\"\n+                        \"AliasRelate predicate should never be the predicate cause of a SelectionError\"\n                     ),\n \n                     ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(ct, ty)) => {"}, {"sha": "07e31e87bfb4646bea05120ab4403b5603d67f27", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/99c49d95cd7d704d2226859cfdc419c930cde9c6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99c49d95cd7d704d2226859cfdc419c930cde9c6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=99c49d95cd7d704d2226859cfdc419c930cde9c6", "patch": "@@ -361,8 +361,8 @@ impl<'a, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'tcx> {\n                 ty::PredicateKind::TypeWellFormedFromEnv(..) => {\n                     bug!(\"TypeWellFormedFromEnv is only used for Chalk\")\n                 }\n-                ty::PredicateKind::AliasEq(..) => {\n-                    bug!(\"AliasEq is only used for new solver\")\n+                ty::PredicateKind::AliasRelate(..) => {\n+                    bug!(\"AliasRelate is only used for new solver\")\n                 }\n             },\n             Some(pred) => match pred {\n@@ -630,8 +630,8 @@ impl<'a, 'tcx> ObligationProcessor for FulfillProcessor<'a, 'tcx> {\n                 ty::PredicateKind::TypeWellFormedFromEnv(..) => {\n                     bug!(\"TypeWellFormedFromEnv is only used for Chalk\")\n                 }\n-                ty::PredicateKind::AliasEq(..) => {\n-                    bug!(\"AliasEq is only used for new solver\")\n+                ty::PredicateKind::AliasRelate(..) => {\n+                    bug!(\"AliasRelate is only used for new solver\")\n                 }\n                 ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(ct, ty)) => {\n                     match self.selcx.infcx.at(&obligation.cause, obligation.param_env).eq("}, {"sha": "5d2af5ff33c8fbf292f4d5897bbcd8b7cfa11e3d", "filename": "compiler/rustc_trait_selection/src/traits/object_safety.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/99c49d95cd7d704d2226859cfdc419c930cde9c6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99c49d95cd7d704d2226859cfdc419c930cde9c6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs?ref=99c49d95cd7d704d2226859cfdc419c930cde9c6", "patch": "@@ -335,7 +335,7 @@ fn predicate_references_self<'tcx>(\n             has_self_ty(&ty.into()).then_some(sp)\n         }\n \n-        ty::PredicateKind::AliasEq(..) => bug!(\"`AliasEq` not allowed as assumption\"),\n+        ty::PredicateKind::AliasRelate(..) => bug!(\"`AliasRelate` not allowed as assumption\"),\n \n         ty::PredicateKind::WellFormed(..)\n         | ty::PredicateKind::ObjectSafe(..)\n@@ -395,7 +395,7 @@ fn generics_require_sized_self(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n             | ty::PredicateKind::Clause(ty::Clause::TypeOutlives(..))\n             | ty::PredicateKind::ConstEvaluatable(..)\n             | ty::PredicateKind::ConstEquate(..)\n-            | ty::PredicateKind::AliasEq(..)\n+            | ty::PredicateKind::AliasRelate(..)\n             | ty::PredicateKind::Ambiguous\n             | ty::PredicateKind::TypeWellFormedFromEnv(..) => false,\n         }"}, {"sha": "bffefdf359ad5c407ed27da9de3230a27db90ab0", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/99c49d95cd7d704d2226859cfdc419c930cde9c6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99c49d95cd7d704d2226859cfdc419c930cde9c6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=99c49d95cd7d704d2226859cfdc419c930cde9c6", "patch": "@@ -977,8 +977,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                 ty::PredicateKind::TypeWellFormedFromEnv(..) => {\n                     bug!(\"TypeWellFormedFromEnv is only used for chalk\")\n                 }\n-                ty::PredicateKind::AliasEq(..) => {\n-                    bug!(\"AliasEq is only used for new solver\")\n+                ty::PredicateKind::AliasRelate(..) => {\n+                    bug!(\"AliasRelate is only used for new solver\")\n                 }\n                 ty::PredicateKind::Ambiguous => Ok(EvaluatedToAmbig),\n                 ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(ct, ty)) => {"}, {"sha": "ec5bd982a3c987c2df50fa916cbb62bd98955f6c", "filename": "compiler/rustc_trait_selection/src/traits/wf.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/99c49d95cd7d704d2226859cfdc419c930cde9c6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99c49d95cd7d704d2226859cfdc419c930cde9c6/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs?ref=99c49d95cd7d704d2226859cfdc419c930cde9c6", "patch": "@@ -191,8 +191,8 @@ pub fn predicate_obligations<'tcx>(\n         ty::PredicateKind::TypeWellFormedFromEnv(..) => {\n             bug!(\"TypeWellFormedFromEnv is only used for Chalk\")\n         }\n-        ty::PredicateKind::AliasEq(..) => {\n-            bug!(\"We should only wf check where clauses and `AliasEq` is not a `Clause`\")\n+        ty::PredicateKind::AliasRelate(..) => {\n+            bug!(\"We should only wf check where clauses and `AliasRelate` is not a `Clause`\")\n         }\n     }\n \n@@ -936,7 +936,7 @@ pub(crate) fn required_region_bounds<'tcx>(\n                 | ty::PredicateKind::ConstEvaluatable(..)\n                 | ty::PredicateKind::ConstEquate(..)\n                 | ty::PredicateKind::Ambiguous\n-                | ty::PredicateKind::AliasEq(..)\n+                | ty::PredicateKind::AliasRelate(..)\n                 | ty::PredicateKind::TypeWellFormedFromEnv(..) => None,\n                 ty::PredicateKind::Clause(ty::Clause::TypeOutlives(ty::OutlivesPredicate(\n                     ref t,"}, {"sha": "0e9bccba8d4c56b727dad49edcce15fbb08e87f9", "filename": "compiler/rustc_traits/src/chalk/lowering.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/99c49d95cd7d704d2226859cfdc419c930cde9c6/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99c49d95cd7d704d2226859cfdc419c930cde9c6/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs?ref=99c49d95cd7d704d2226859cfdc419c930cde9c6", "patch": "@@ -119,7 +119,7 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::InEnvironment<chalk_ir::Goal<RustInterner<'\n                 },\n                 ty::PredicateKind::ObjectSafe(..)\n                 | ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(..))\n-                | ty::PredicateKind::AliasEq(..)\n+                | ty::PredicateKind::AliasRelate(..)\n                 | ty::PredicateKind::ClosureKind(..)\n                 | ty::PredicateKind::Subtype(..)\n                 | ty::PredicateKind::Coerce(..)\n@@ -215,7 +215,7 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::GoalData<RustInterner<'tcx>>> for ty::Predi\n             // some of these in terms of chalk operations.\n             ty::PredicateKind::ClosureKind(..)\n             | ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(..))\n-            | ty::PredicateKind::AliasEq(..)\n+            | ty::PredicateKind::AliasRelate(..)\n             | ty::PredicateKind::Coerce(..)\n             | ty::PredicateKind::ConstEvaluatable(..)\n             | ty::PredicateKind::Ambiguous\n@@ -652,7 +652,7 @@ impl<'tcx> LowerInto<'tcx, Option<chalk_ir::QuantifiedWhereClause<RustInterner<'\n             ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(..)) => None,\n \n             ty::PredicateKind::ObjectSafe(..)\n-            | ty::PredicateKind::AliasEq(..)\n+            | ty::PredicateKind::AliasRelate(..)\n             | ty::PredicateKind::ClosureKind(..)\n             | ty::PredicateKind::Subtype(..)\n             | ty::PredicateKind::Coerce(..)\n@@ -787,7 +787,7 @@ impl<'tcx> LowerInto<'tcx, Option<chalk_solve::rust_ir::QuantifiedInlineBound<Ru\n             ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(..)) => None,\n \n             ty::PredicateKind::Clause(ty::Clause::RegionOutlives(..))\n-            | ty::PredicateKind::AliasEq(..)\n+            | ty::PredicateKind::AliasRelate(..)\n             | ty::PredicateKind::ObjectSafe(..)\n             | ty::PredicateKind::ClosureKind(..)\n             | ty::PredicateKind::Subtype(..)"}, {"sha": "f5bba14d2fb9cb6b1f866ec87e8722be3680f61e", "filename": "compiler/rustc_traits/src/implied_outlives_bounds.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/99c49d95cd7d704d2226859cfdc419c930cde9c6/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99c49d95cd7d704d2226859cfdc419c930cde9c6/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs?ref=99c49d95cd7d704d2226859cfdc419c930cde9c6", "patch": "@@ -86,7 +86,7 @@ fn compute_implied_outlives_bounds<'tcx>(\n             if obligation.predicate.has_non_region_infer() {\n                 match obligation.predicate.kind().skip_binder() {\n                     ty::PredicateKind::Clause(ty::Clause::Projection(..))\n-                    | ty::PredicateKind::AliasEq(..) => {\n+                    | ty::PredicateKind::AliasRelate(..) => {\n                         ocx.register_obligation(obligation.clone());\n                     }\n                     _ => {}\n@@ -110,7 +110,7 @@ fn compute_implied_outlives_bounds<'tcx>(\n                 | ty::PredicateKind::ConstEvaluatable(..)\n                 | ty::PredicateKind::ConstEquate(..)\n                 | ty::PredicateKind::Ambiguous\n-                | ty::PredicateKind::AliasEq(..)\n+                | ty::PredicateKind::AliasRelate(..)\n                 | ty::PredicateKind::TypeWellFormedFromEnv(..) => {}\n \n                 // We need to search through *all* WellFormed predicates"}, {"sha": "126a494f34fd6870773e704e97a5e357ecdcd91f", "filename": "compiler/rustc_traits/src/normalize_erasing_regions.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99c49d95cd7d704d2226859cfdc419c930cde9c6/compiler%2Frustc_traits%2Fsrc%2Fnormalize_erasing_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99c49d95cd7d704d2226859cfdc419c930cde9c6/compiler%2Frustc_traits%2Fsrc%2Fnormalize_erasing_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fnormalize_erasing_regions.rs?ref=99c49d95cd7d704d2226859cfdc419c930cde9c6", "patch": "@@ -61,7 +61,7 @@ fn not_outlives_predicate(p: ty::Predicate<'_>) -> bool {\n         ty::PredicateKind::Clause(ty::Clause::Trait(..))\n         | ty::PredicateKind::Clause(ty::Clause::Projection(..))\n         | ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(..))\n-        | ty::PredicateKind::AliasEq(..)\n+        | ty::PredicateKind::AliasRelate(..)\n         | ty::PredicateKind::WellFormed(..)\n         | ty::PredicateKind::ObjectSafe(..)\n         | ty::PredicateKind::ClosureKind(..)"}, {"sha": "8b23fbc75833cf357a86786d8a29b88bc53759e3", "filename": "compiler/rustc_type_ir/src/lib.rs", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/99c49d95cd7d704d2226859cfdc419c930cde9c6/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99c49d95cd7d704d2226859cfdc419c930cde9c6/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_type_ir%2Fsrc%2Flib.rs?ref=99c49d95cd7d704d2226859cfdc419c930cde9c6", "patch": "@@ -432,6 +432,17 @@ impl IntTy {\n             _ => *self,\n         }\n     }\n+\n+    pub fn to_unsigned(self) -> UintTy {\n+        match self {\n+            IntTy::Isize => UintTy::Usize,\n+            IntTy::I8 => UintTy::U8,\n+            IntTy::I16 => UintTy::U16,\n+            IntTy::I32 => UintTy::U32,\n+            IntTy::I64 => UintTy::U64,\n+            IntTy::I128 => UintTy::U128,\n+        }\n+    }\n }\n \n #[derive(Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Copy, Debug)]\n@@ -479,6 +490,17 @@ impl UintTy {\n             _ => *self,\n         }\n     }\n+\n+    pub fn to_signed(self) -> IntTy {\n+        match self {\n+            UintTy::Usize => IntTy::Isize,\n+            UintTy::U8 => IntTy::I8,\n+            UintTy::U16 => IntTy::I16,\n+            UintTy::U32 => IntTy::I32,\n+            UintTy::U64 => IntTy::I64,\n+            UintTy::U128 => IntTy::I128,\n+        }\n+    }\n }\n \n #[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]"}, {"sha": "1e9cf404f77ea10af86cfaeaff32fb2db1417d2f", "filename": "library/alloc/src/rc.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/99c49d95cd7d704d2226859cfdc419c930cde9c6/library%2Falloc%2Fsrc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99c49d95cd7d704d2226859cfdc419c930cde9c6/library%2Falloc%2Fsrc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Frc.rs?ref=99c49d95cd7d704d2226859cfdc419c930cde9c6", "patch": "@@ -692,10 +692,10 @@ impl<T> Rc<T> {\n     /// it is guaranteed that exactly one of the calls returns the inner value.\n     /// This means in particular that the inner value is not dropped.\n     ///\n-    /// This is equivalent to `Rc::try_unwrap(...).ok()`. (Note that these are not equivalent for\n-    /// `Arc`, due to race conditions that do not apply to `Rc`.)\n+    /// This is equivalent to `Rc::try_unwrap(this).ok()`. (Note that these are not equivalent for\n+    /// [`Arc`](crate::sync::Arc), due to race conditions that do not apply to `Rc`.)\n     #[inline]\n-    #[unstable(feature = \"rc_into_inner\", issue = \"106894\")]\n+    #[stable(feature = \"rc_into_inner\", since = \"CURRENT_RUSTC_VERSION\")]\n     pub fn into_inner(this: Self) -> Option<T> {\n         Rc::try_unwrap(this).ok()\n     }"}, {"sha": "150924851d21d9cbf63f670ef3d543bf0ca70fea", "filename": "library/alloc/src/sync.rs", "status": "modified", "additions": 3, "deletions": 20, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/99c49d95cd7d704d2226859cfdc419c930cde9c6/library%2Falloc%2Fsrc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99c49d95cd7d704d2226859cfdc419c930cde9c6/library%2Falloc%2Fsrc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/library%2Falloc%2Fsrc%2Fsync.rs?ref=99c49d95cd7d704d2226859cfdc419c930cde9c6", "patch": "@@ -662,20 +662,17 @@ impl<T> Arc<T> {\n     ///\n     /// This will succeed even if there are outstanding weak references.\n     ///\n-    // FIXME: when `Arc::into_inner` is stabilized, add this paragraph:\n-    /*\n     /// It is strongly recommended to use [`Arc::into_inner`] instead if you don't\n     /// want to keep the `Arc` in the [`Err`] case.\n     /// Immediately dropping the [`Err`] payload, like in the expression\n     /// `Arc::try_unwrap(this).ok()`, can still cause the strong count to\n     /// drop to zero and the inner value of the `Arc` to be dropped:\n-    /// For instance if two threads execute this expression in parallel, then\n+    /// For instance if two threads each execute this expression in parallel, then\n     /// there is a race condition. The threads could first both check whether they\n     /// have the last clone of their `Arc` via `Arc::try_unwrap`, and then\n     /// both drop their `Arc` in the call to [`ok`][`Result::ok`],\n     /// taking the strong count from two down to zero.\n     ///\n-     */\n     /// # Examples\n     ///\n     /// ```\n@@ -719,20 +716,13 @@ impl<T> Arc<T> {\n     /// This means in particular that the inner value is not dropped.\n     ///\n     /// The similar expression `Arc::try_unwrap(this).ok()` does not\n-    /// offer such a guarantee. See the last example below.\n-    //\n-    // FIXME: when `Arc::into_inner` is stabilized, add this to end\n-    // of the previous sentence:\n-    /*\n+    /// offer such a guarantee. See the last example below\n     /// and the documentation of [`Arc::try_unwrap`].\n-     */\n     ///\n     /// # Examples\n     ///\n     /// Minimal example demonstrating the guarantee that `Arc::into_inner` gives.\n     /// ```\n-    /// #![feature(arc_into_inner)]\n-    ///\n     /// use std::sync::Arc;\n     ///\n     /// let x = Arc::new(3);\n@@ -756,8 +746,6 @@ impl<T> Arc<T> {\n     ///\n     /// A more practical example demonstrating the need for `Arc::into_inner`:\n     /// ```\n-    /// #![feature(arc_into_inner)]\n-    ///\n     /// use std::sync::Arc;\n     ///\n     /// // Definition of a simple singly linked list using `Arc`:\n@@ -807,13 +795,8 @@ impl<T> Arc<T> {\n     /// x_thread.join().unwrap();\n     /// y_thread.join().unwrap();\n     /// ```\n-\n-    // FIXME: when `Arc::into_inner` is stabilized, adjust above documentation\n-    // and the documentation of `Arc::try_unwrap` according to the `FIXME`s. Also\n-    // open an issue on rust-lang/rust-clippy, asking for a lint against\n-    // `Arc::try_unwrap(...).ok()`.\n     #[inline]\n-    #[unstable(feature = \"arc_into_inner\", issue = \"106894\")]\n+    #[stable(feature = \"arc_into_inner\", since = \"CURRENT_RUSTC_VERSION\")]\n     pub fn into_inner(this: Self) -> Option<T> {\n         // Make sure that the ordinary `Drop` implementation isn\u2019t called as well\n         let mut this = mem::ManuallyDrop::new(this);"}, {"sha": "c00fa5994bfce661a6ee669100206f745fb206b1", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99c49d95cd7d704d2226859cfdc419c930cde9c6/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99c49d95cd7d704d2226859cfdc419c930cde9c6/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=99c49d95cd7d704d2226859cfdc419c930cde9c6", "patch": "@@ -324,7 +324,7 @@ pub(crate) fn clean_predicate<'tcx>(\n         ty::PredicateKind::Clause(ty::Clause::ConstArgHasType(..)) => None,\n \n         ty::PredicateKind::Subtype(..)\n-        | ty::PredicateKind::AliasEq(..)\n+        | ty::PredicateKind::AliasRelate(..)\n         | ty::PredicateKind::Coerce(..)\n         | ty::PredicateKind::ObjectSafe(..)\n         | ty::PredicateKind::ClosureKind(..)"}, {"sha": "58f7742ab8764ff382dacf96a67b1858d673a3dc", "filename": "src/tools/clippy/clippy_utils/src/qualify_min_const_fn.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/99c49d95cd7d704d2226859cfdc419c930cde9c6/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99c49d95cd7d704d2226859cfdc419c930cde9c6/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_utils%2Fsrc%2Fqualify_min_const_fn.rs?ref=99c49d95cd7d704d2226859cfdc419c930cde9c6", "patch": "@@ -37,7 +37,7 @@ pub fn is_min_const_fn<'tcx>(tcx: TyCtxt<'tcx>, body: &Body<'tcx>, msrv: &Msrv)\n                 | ty::PredicateKind::ConstEvaluatable(..)\n                 | ty::PredicateKind::ConstEquate(..)\n                 | ty::PredicateKind::TypeWellFormedFromEnv(..) => continue,\n-                ty::PredicateKind::AliasEq(..) => panic!(\"alias eq predicate on function: {predicate:#?}\"),\n+                ty::PredicateKind::AliasRelate(..) => panic!(\"alias relate predicate on function: {predicate:#?}\"),\n                 ty::PredicateKind::ObjectSafe(_) => panic!(\"object safe predicate on function: {predicate:#?}\"),\n                 ty::PredicateKind::ClosureKind(..) => panic!(\"closure kind predicate on function: {predicate:#?}\"),\n                 ty::PredicateKind::Subtype(_) => panic!(\"subtype predicate on function: {predicate:#?}\"),"}, {"sha": "4b63a00a304dc80b7df45071d42a444c24a3d3de", "filename": "tests/mir-opt/building/shifts.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/99c49d95cd7d704d2226859cfdc419c930cde9c6/tests%2Fmir-opt%2Fbuilding%2Fshifts.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99c49d95cd7d704d2226859cfdc419c930cde9c6/tests%2Fmir-opt%2Fbuilding%2Fshifts.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fbuilding%2Fshifts.rs?ref=99c49d95cd7d704d2226859cfdc419c930cde9c6", "patch": "@@ -0,0 +1,20 @@\n+// compile-flags: -C debug-assertions=yes\n+\n+// EMIT_MIR shifts.shift_signed.built.after.mir\n+fn shift_signed(small: i8, big: u128, a: i8, b: i32, c: i128) -> ([i8; 3], [u128; 3]) {\n+    (\n+        [small >> a, small >> b, small >> c],\n+        [big << a, big << b, big << c],\n+    )\n+}\n+\n+// EMIT_MIR shifts.shift_unsigned.built.after.mir\n+fn shift_unsigned(small: u8, big: i128, a: u8, b: u32, c: u128) -> ([u8; 3], [i128; 3]) {\n+    (\n+        [small >> a, small >> b, small >> c],\n+        [big << a, big << b, big << c],\n+    )\n+}\n+\n+fn main() {\n+}"}, {"sha": "028777cefdd10a932dbf552153d8ba3f85dbdca1", "filename": "tests/mir-opt/building/shifts.shift_signed.built.after.mir", "status": "added", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/rust-lang/rust/blob/99c49d95cd7d704d2226859cfdc419c930cde9c6/tests%2Fmir-opt%2Fbuilding%2Fshifts.shift_signed.built.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/99c49d95cd7d704d2226859cfdc419c930cde9c6/tests%2Fmir-opt%2Fbuilding%2Fshifts.shift_signed.built.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fbuilding%2Fshifts.shift_signed.built.after.mir?ref=99c49d95cd7d704d2226859cfdc419c930cde9c6", "patch": "@@ -0,0 +1,147 @@\n+// MIR for `shift_signed` after built\n+\n+fn shift_signed(_1: i8, _2: u128, _3: i8, _4: i32, _5: i128) -> ([i8; 3], [u128; 3]) {\n+    debug small => _1;                   // in scope 0 at $DIR/shifts.rs:+0:17: +0:22\n+    debug big => _2;                     // in scope 0 at $DIR/shifts.rs:+0:28: +0:31\n+    debug a => _3;                       // in scope 0 at $DIR/shifts.rs:+0:39: +0:40\n+    debug b => _4;                       // in scope 0 at $DIR/shifts.rs:+0:46: +0:47\n+    debug c => _5;                       // in scope 0 at $DIR/shifts.rs:+0:54: +0:55\n+    let mut _0: ([i8; 3], [u128; 3]);    // return place in scope 0 at $DIR/shifts.rs:+0:66: +0:86\n+    let mut _6: [i8; 3];                 // in scope 0 at $DIR/shifts.rs:+2:9: +2:45\n+    let mut _7: i8;                      // in scope 0 at $DIR/shifts.rs:+2:10: +2:20\n+    let mut _8: i8;                      // in scope 0 at $DIR/shifts.rs:+2:10: +2:15\n+    let mut _9: i8;                      // in scope 0 at $DIR/shifts.rs:+2:19: +2:20\n+    let mut _10: u8;                     // in scope 0 at $DIR/shifts.rs:+2:10: +2:20\n+    let mut _11: bool;                   // in scope 0 at $DIR/shifts.rs:+2:10: +2:20\n+    let mut _12: i8;                     // in scope 0 at $DIR/shifts.rs:+2:22: +2:32\n+    let mut _13: i8;                     // in scope 0 at $DIR/shifts.rs:+2:22: +2:27\n+    let mut _14: i32;                    // in scope 0 at $DIR/shifts.rs:+2:31: +2:32\n+    let mut _15: u32;                    // in scope 0 at $DIR/shifts.rs:+2:22: +2:32\n+    let mut _16: bool;                   // in scope 0 at $DIR/shifts.rs:+2:22: +2:32\n+    let mut _17: i8;                     // in scope 0 at $DIR/shifts.rs:+2:34: +2:44\n+    let mut _18: i8;                     // in scope 0 at $DIR/shifts.rs:+2:34: +2:39\n+    let mut _19: i128;                   // in scope 0 at $DIR/shifts.rs:+2:43: +2:44\n+    let mut _20: u128;                   // in scope 0 at $DIR/shifts.rs:+2:34: +2:44\n+    let mut _21: bool;                   // in scope 0 at $DIR/shifts.rs:+2:34: +2:44\n+    let mut _22: [u128; 3];              // in scope 0 at $DIR/shifts.rs:+3:9: +3:39\n+    let mut _23: u128;                   // in scope 0 at $DIR/shifts.rs:+3:10: +3:18\n+    let mut _24: u128;                   // in scope 0 at $DIR/shifts.rs:+3:10: +3:13\n+    let mut _25: i8;                     // in scope 0 at $DIR/shifts.rs:+3:17: +3:18\n+    let mut _26: u8;                     // in scope 0 at $DIR/shifts.rs:+3:10: +3:18\n+    let mut _27: bool;                   // in scope 0 at $DIR/shifts.rs:+3:10: +3:18\n+    let mut _28: u128;                   // in scope 0 at $DIR/shifts.rs:+3:20: +3:28\n+    let mut _29: u128;                   // in scope 0 at $DIR/shifts.rs:+3:20: +3:23\n+    let mut _30: i32;                    // in scope 0 at $DIR/shifts.rs:+3:27: +3:28\n+    let mut _31: u32;                    // in scope 0 at $DIR/shifts.rs:+3:20: +3:28\n+    let mut _32: bool;                   // in scope 0 at $DIR/shifts.rs:+3:20: +3:28\n+    let mut _33: u128;                   // in scope 0 at $DIR/shifts.rs:+3:30: +3:38\n+    let mut _34: u128;                   // in scope 0 at $DIR/shifts.rs:+3:30: +3:33\n+    let mut _35: i128;                   // in scope 0 at $DIR/shifts.rs:+3:37: +3:38\n+    let mut _36: u128;                   // in scope 0 at $DIR/shifts.rs:+3:30: +3:38\n+    let mut _37: bool;                   // in scope 0 at $DIR/shifts.rs:+3:30: +3:38\n+\n+    bb0: {\n+        StorageLive(_6);                 // scope 0 at $DIR/shifts.rs:+2:9: +2:45\n+        StorageLive(_7);                 // scope 0 at $DIR/shifts.rs:+2:10: +2:20\n+        StorageLive(_8);                 // scope 0 at $DIR/shifts.rs:+2:10: +2:15\n+        _8 = _1;                         // scope 0 at $DIR/shifts.rs:+2:10: +2:15\n+        StorageLive(_9);                 // scope 0 at $DIR/shifts.rs:+2:19: +2:20\n+        _9 = _3;                         // scope 0 at $DIR/shifts.rs:+2:19: +2:20\n+        _10 = _9 as u8 (IntToInt);       // scope 0 at $DIR/shifts.rs:+2:10: +2:20\n+        _11 = Lt(move _10, const 8_u8);  // scope 0 at $DIR/shifts.rs:+2:10: +2:20\n+        assert(move _11, \"attempt to shift right by `{}`, which would overflow\", _9) -> [success: bb1, unwind: bb7]; // scope 0 at $DIR/shifts.rs:+2:10: +2:20\n+    }\n+\n+    bb1: {\n+        _7 = Shr(move _8, move _9);      // scope 0 at $DIR/shifts.rs:+2:10: +2:20\n+        StorageDead(_9);                 // scope 0 at $DIR/shifts.rs:+2:19: +2:20\n+        StorageDead(_8);                 // scope 0 at $DIR/shifts.rs:+2:19: +2:20\n+        StorageLive(_12);                // scope 0 at $DIR/shifts.rs:+2:22: +2:32\n+        StorageLive(_13);                // scope 0 at $DIR/shifts.rs:+2:22: +2:27\n+        _13 = _1;                        // scope 0 at $DIR/shifts.rs:+2:22: +2:27\n+        StorageLive(_14);                // scope 0 at $DIR/shifts.rs:+2:31: +2:32\n+        _14 = _4;                        // scope 0 at $DIR/shifts.rs:+2:31: +2:32\n+        _15 = _14 as u32 (IntToInt);     // scope 0 at $DIR/shifts.rs:+2:22: +2:32\n+        _16 = Lt(move _15, const 8_u32); // scope 0 at $DIR/shifts.rs:+2:22: +2:32\n+        assert(move _16, \"attempt to shift right by `{}`, which would overflow\", _14) -> [success: bb2, unwind: bb7]; // scope 0 at $DIR/shifts.rs:+2:22: +2:32\n+    }\n+\n+    bb2: {\n+        _12 = Shr(move _13, move _14);   // scope 0 at $DIR/shifts.rs:+2:22: +2:32\n+        StorageDead(_14);                // scope 0 at $DIR/shifts.rs:+2:31: +2:32\n+        StorageDead(_13);                // scope 0 at $DIR/shifts.rs:+2:31: +2:32\n+        StorageLive(_17);                // scope 0 at $DIR/shifts.rs:+2:34: +2:44\n+        StorageLive(_18);                // scope 0 at $DIR/shifts.rs:+2:34: +2:39\n+        _18 = _1;                        // scope 0 at $DIR/shifts.rs:+2:34: +2:39\n+        StorageLive(_19);                // scope 0 at $DIR/shifts.rs:+2:43: +2:44\n+        _19 = _5;                        // scope 0 at $DIR/shifts.rs:+2:43: +2:44\n+        _20 = _19 as u128 (IntToInt);    // scope 0 at $DIR/shifts.rs:+2:34: +2:44\n+        _21 = Lt(move _20, const 8_u128); // scope 0 at $DIR/shifts.rs:+2:34: +2:44\n+        assert(move _21, \"attempt to shift right by `{}`, which would overflow\", _19) -> [success: bb3, unwind: bb7]; // scope 0 at $DIR/shifts.rs:+2:34: +2:44\n+    }\n+\n+    bb3: {\n+        _17 = Shr(move _18, move _19);   // scope 0 at $DIR/shifts.rs:+2:34: +2:44\n+        StorageDead(_19);                // scope 0 at $DIR/shifts.rs:+2:43: +2:44\n+        StorageDead(_18);                // scope 0 at $DIR/shifts.rs:+2:43: +2:44\n+        _6 = [move _7, move _12, move _17]; // scope 0 at $DIR/shifts.rs:+2:9: +2:45\n+        StorageDead(_17);                // scope 0 at $DIR/shifts.rs:+2:44: +2:45\n+        StorageDead(_12);                // scope 0 at $DIR/shifts.rs:+2:44: +2:45\n+        StorageDead(_7);                 // scope 0 at $DIR/shifts.rs:+2:44: +2:45\n+        StorageLive(_22);                // scope 0 at $DIR/shifts.rs:+3:9: +3:39\n+        StorageLive(_23);                // scope 0 at $DIR/shifts.rs:+3:10: +3:18\n+        StorageLive(_24);                // scope 0 at $DIR/shifts.rs:+3:10: +3:13\n+        _24 = _2;                        // scope 0 at $DIR/shifts.rs:+3:10: +3:13\n+        StorageLive(_25);                // scope 0 at $DIR/shifts.rs:+3:17: +3:18\n+        _25 = _3;                        // scope 0 at $DIR/shifts.rs:+3:17: +3:18\n+        _26 = _25 as u8 (IntToInt);      // scope 0 at $DIR/shifts.rs:+3:10: +3:18\n+        _27 = Lt(move _26, const 128_u8); // scope 0 at $DIR/shifts.rs:+3:10: +3:18\n+        assert(move _27, \"attempt to shift left by `{}`, which would overflow\", _25) -> [success: bb4, unwind: bb7]; // scope 0 at $DIR/shifts.rs:+3:10: +3:18\n+    }\n+\n+    bb4: {\n+        _23 = Shl(move _24, move _25);   // scope 0 at $DIR/shifts.rs:+3:10: +3:18\n+        StorageDead(_25);                // scope 0 at $DIR/shifts.rs:+3:17: +3:18\n+        StorageDead(_24);                // scope 0 at $DIR/shifts.rs:+3:17: +3:18\n+        StorageLive(_28);                // scope 0 at $DIR/shifts.rs:+3:20: +3:28\n+        StorageLive(_29);                // scope 0 at $DIR/shifts.rs:+3:20: +3:23\n+        _29 = _2;                        // scope 0 at $DIR/shifts.rs:+3:20: +3:23\n+        StorageLive(_30);                // scope 0 at $DIR/shifts.rs:+3:27: +3:28\n+        _30 = _4;                        // scope 0 at $DIR/shifts.rs:+3:27: +3:28\n+        _31 = _30 as u32 (IntToInt);     // scope 0 at $DIR/shifts.rs:+3:20: +3:28\n+        _32 = Lt(move _31, const 128_u32); // scope 0 at $DIR/shifts.rs:+3:20: +3:28\n+        assert(move _32, \"attempt to shift left by `{}`, which would overflow\", _30) -> [success: bb5, unwind: bb7]; // scope 0 at $DIR/shifts.rs:+3:20: +3:28\n+    }\n+\n+    bb5: {\n+        _28 = Shl(move _29, move _30);   // scope 0 at $DIR/shifts.rs:+3:20: +3:28\n+        StorageDead(_30);                // scope 0 at $DIR/shifts.rs:+3:27: +3:28\n+        StorageDead(_29);                // scope 0 at $DIR/shifts.rs:+3:27: +3:28\n+        StorageLive(_33);                // scope 0 at $DIR/shifts.rs:+3:30: +3:38\n+        StorageLive(_34);                // scope 0 at $DIR/shifts.rs:+3:30: +3:33\n+        _34 = _2;                        // scope 0 at $DIR/shifts.rs:+3:30: +3:33\n+        StorageLive(_35);                // scope 0 at $DIR/shifts.rs:+3:37: +3:38\n+        _35 = _5;                        // scope 0 at $DIR/shifts.rs:+3:37: +3:38\n+        _36 = _35 as u128 (IntToInt);    // scope 0 at $DIR/shifts.rs:+3:30: +3:38\n+        _37 = Lt(move _36, const 128_u128); // scope 0 at $DIR/shifts.rs:+3:30: +3:38\n+        assert(move _37, \"attempt to shift left by `{}`, which would overflow\", _35) -> [success: bb6, unwind: bb7]; // scope 0 at $DIR/shifts.rs:+3:30: +3:38\n+    }\n+\n+    bb6: {\n+        _33 = Shl(move _34, move _35);   // scope 0 at $DIR/shifts.rs:+3:30: +3:38\n+        StorageDead(_35);                // scope 0 at $DIR/shifts.rs:+3:37: +3:38\n+        StorageDead(_34);                // scope 0 at $DIR/shifts.rs:+3:37: +3:38\n+        _22 = [move _23, move _28, move _33]; // scope 0 at $DIR/shifts.rs:+3:9: +3:39\n+        StorageDead(_33);                // scope 0 at $DIR/shifts.rs:+3:38: +3:39\n+        StorageDead(_28);                // scope 0 at $DIR/shifts.rs:+3:38: +3:39\n+        StorageDead(_23);                // scope 0 at $DIR/shifts.rs:+3:38: +3:39\n+        _0 = (move _6, move _22);        // scope 0 at $DIR/shifts.rs:+1:5: +4:6\n+        StorageDead(_22);                // scope 0 at $DIR/shifts.rs:+4:5: +4:6\n+        StorageDead(_6);                 // scope 0 at $DIR/shifts.rs:+4:5: +4:6\n+        return;                          // scope 0 at $DIR/shifts.rs:+5:2: +5:2\n+    }\n+\n+    bb7 (cleanup): {\n+        resume;                          // scope 0 at $DIR/shifts.rs:+0:1: +5:2\n+    }\n+}"}, {"sha": "04da2d20d242fab460c7537a2c28532c207635d0", "filename": "tests/mir-opt/building/shifts.shift_unsigned.built.after.mir", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/rust-lang/rust/blob/99c49d95cd7d704d2226859cfdc419c930cde9c6/tests%2Fmir-opt%2Fbuilding%2Fshifts.shift_unsigned.built.after.mir", "raw_url": "https://github.com/rust-lang/rust/raw/99c49d95cd7d704d2226859cfdc419c930cde9c6/tests%2Fmir-opt%2Fbuilding%2Fshifts.shift_unsigned.built.after.mir", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fbuilding%2Fshifts.shift_unsigned.built.after.mir?ref=99c49d95cd7d704d2226859cfdc419c930cde9c6", "patch": "@@ -0,0 +1,135 @@\n+// MIR for `shift_unsigned` after built\n+\n+fn shift_unsigned(_1: u8, _2: i128, _3: u8, _4: u32, _5: u128) -> ([u8; 3], [i128; 3]) {\n+    debug small => _1;                   // in scope 0 at $DIR/shifts.rs:+0:19: +0:24\n+    debug big => _2;                     // in scope 0 at $DIR/shifts.rs:+0:30: +0:33\n+    debug a => _3;                       // in scope 0 at $DIR/shifts.rs:+0:41: +0:42\n+    debug b => _4;                       // in scope 0 at $DIR/shifts.rs:+0:48: +0:49\n+    debug c => _5;                       // in scope 0 at $DIR/shifts.rs:+0:56: +0:57\n+    let mut _0: ([u8; 3], [i128; 3]);    // return place in scope 0 at $DIR/shifts.rs:+0:68: +0:88\n+    let mut _6: [u8; 3];                 // in scope 0 at $DIR/shifts.rs:+2:9: +2:45\n+    let mut _7: u8;                      // in scope 0 at $DIR/shifts.rs:+2:10: +2:20\n+    let mut _8: u8;                      // in scope 0 at $DIR/shifts.rs:+2:10: +2:15\n+    let mut _9: u8;                      // in scope 0 at $DIR/shifts.rs:+2:19: +2:20\n+    let mut _10: bool;                   // in scope 0 at $DIR/shifts.rs:+2:10: +2:20\n+    let mut _11: u8;                     // in scope 0 at $DIR/shifts.rs:+2:22: +2:32\n+    let mut _12: u8;                     // in scope 0 at $DIR/shifts.rs:+2:22: +2:27\n+    let mut _13: u32;                    // in scope 0 at $DIR/shifts.rs:+2:31: +2:32\n+    let mut _14: bool;                   // in scope 0 at $DIR/shifts.rs:+2:22: +2:32\n+    let mut _15: u8;                     // in scope 0 at $DIR/shifts.rs:+2:34: +2:44\n+    let mut _16: u8;                     // in scope 0 at $DIR/shifts.rs:+2:34: +2:39\n+    let mut _17: u128;                   // in scope 0 at $DIR/shifts.rs:+2:43: +2:44\n+    let mut _18: bool;                   // in scope 0 at $DIR/shifts.rs:+2:34: +2:44\n+    let mut _19: [i128; 3];              // in scope 0 at $DIR/shifts.rs:+3:9: +3:39\n+    let mut _20: i128;                   // in scope 0 at $DIR/shifts.rs:+3:10: +3:18\n+    let mut _21: i128;                   // in scope 0 at $DIR/shifts.rs:+3:10: +3:13\n+    let mut _22: u8;                     // in scope 0 at $DIR/shifts.rs:+3:17: +3:18\n+    let mut _23: bool;                   // in scope 0 at $DIR/shifts.rs:+3:10: +3:18\n+    let mut _24: i128;                   // in scope 0 at $DIR/shifts.rs:+3:20: +3:28\n+    let mut _25: i128;                   // in scope 0 at $DIR/shifts.rs:+3:20: +3:23\n+    let mut _26: u32;                    // in scope 0 at $DIR/shifts.rs:+3:27: +3:28\n+    let mut _27: bool;                   // in scope 0 at $DIR/shifts.rs:+3:20: +3:28\n+    let mut _28: i128;                   // in scope 0 at $DIR/shifts.rs:+3:30: +3:38\n+    let mut _29: i128;                   // in scope 0 at $DIR/shifts.rs:+3:30: +3:33\n+    let mut _30: u128;                   // in scope 0 at $DIR/shifts.rs:+3:37: +3:38\n+    let mut _31: bool;                   // in scope 0 at $DIR/shifts.rs:+3:30: +3:38\n+\n+    bb0: {\n+        StorageLive(_6);                 // scope 0 at $DIR/shifts.rs:+2:9: +2:45\n+        StorageLive(_7);                 // scope 0 at $DIR/shifts.rs:+2:10: +2:20\n+        StorageLive(_8);                 // scope 0 at $DIR/shifts.rs:+2:10: +2:15\n+        _8 = _1;                         // scope 0 at $DIR/shifts.rs:+2:10: +2:15\n+        StorageLive(_9);                 // scope 0 at $DIR/shifts.rs:+2:19: +2:20\n+        _9 = _3;                         // scope 0 at $DIR/shifts.rs:+2:19: +2:20\n+        _10 = Lt(_9, const 8_u8);        // scope 0 at $DIR/shifts.rs:+2:10: +2:20\n+        assert(move _10, \"attempt to shift right by `{}`, which would overflow\", _9) -> [success: bb1, unwind: bb7]; // scope 0 at $DIR/shifts.rs:+2:10: +2:20\n+    }\n+\n+    bb1: {\n+        _7 = Shr(move _8, move _9);      // scope 0 at $DIR/shifts.rs:+2:10: +2:20\n+        StorageDead(_9);                 // scope 0 at $DIR/shifts.rs:+2:19: +2:20\n+        StorageDead(_8);                 // scope 0 at $DIR/shifts.rs:+2:19: +2:20\n+        StorageLive(_11);                // scope 0 at $DIR/shifts.rs:+2:22: +2:32\n+        StorageLive(_12);                // scope 0 at $DIR/shifts.rs:+2:22: +2:27\n+        _12 = _1;                        // scope 0 at $DIR/shifts.rs:+2:22: +2:27\n+        StorageLive(_13);                // scope 0 at $DIR/shifts.rs:+2:31: +2:32\n+        _13 = _4;                        // scope 0 at $DIR/shifts.rs:+2:31: +2:32\n+        _14 = Lt(_13, const 8_u32);      // scope 0 at $DIR/shifts.rs:+2:22: +2:32\n+        assert(move _14, \"attempt to shift right by `{}`, which would overflow\", _13) -> [success: bb2, unwind: bb7]; // scope 0 at $DIR/shifts.rs:+2:22: +2:32\n+    }\n+\n+    bb2: {\n+        _11 = Shr(move _12, move _13);   // scope 0 at $DIR/shifts.rs:+2:22: +2:32\n+        StorageDead(_13);                // scope 0 at $DIR/shifts.rs:+2:31: +2:32\n+        StorageDead(_12);                // scope 0 at $DIR/shifts.rs:+2:31: +2:32\n+        StorageLive(_15);                // scope 0 at $DIR/shifts.rs:+2:34: +2:44\n+        StorageLive(_16);                // scope 0 at $DIR/shifts.rs:+2:34: +2:39\n+        _16 = _1;                        // scope 0 at $DIR/shifts.rs:+2:34: +2:39\n+        StorageLive(_17);                // scope 0 at $DIR/shifts.rs:+2:43: +2:44\n+        _17 = _5;                        // scope 0 at $DIR/shifts.rs:+2:43: +2:44\n+        _18 = Lt(_17, const 8_u128);     // scope 0 at $DIR/shifts.rs:+2:34: +2:44\n+        assert(move _18, \"attempt to shift right by `{}`, which would overflow\", _17) -> [success: bb3, unwind: bb7]; // scope 0 at $DIR/shifts.rs:+2:34: +2:44\n+    }\n+\n+    bb3: {\n+        _15 = Shr(move _16, move _17);   // scope 0 at $DIR/shifts.rs:+2:34: +2:44\n+        StorageDead(_17);                // scope 0 at $DIR/shifts.rs:+2:43: +2:44\n+        StorageDead(_16);                // scope 0 at $DIR/shifts.rs:+2:43: +2:44\n+        _6 = [move _7, move _11, move _15]; // scope 0 at $DIR/shifts.rs:+2:9: +2:45\n+        StorageDead(_15);                // scope 0 at $DIR/shifts.rs:+2:44: +2:45\n+        StorageDead(_11);                // scope 0 at $DIR/shifts.rs:+2:44: +2:45\n+        StorageDead(_7);                 // scope 0 at $DIR/shifts.rs:+2:44: +2:45\n+        StorageLive(_19);                // scope 0 at $DIR/shifts.rs:+3:9: +3:39\n+        StorageLive(_20);                // scope 0 at $DIR/shifts.rs:+3:10: +3:18\n+        StorageLive(_21);                // scope 0 at $DIR/shifts.rs:+3:10: +3:13\n+        _21 = _2;                        // scope 0 at $DIR/shifts.rs:+3:10: +3:13\n+        StorageLive(_22);                // scope 0 at $DIR/shifts.rs:+3:17: +3:18\n+        _22 = _3;                        // scope 0 at $DIR/shifts.rs:+3:17: +3:18\n+        _23 = Lt(_22, const 128_u8);     // scope 0 at $DIR/shifts.rs:+3:10: +3:18\n+        assert(move _23, \"attempt to shift left by `{}`, which would overflow\", _22) -> [success: bb4, unwind: bb7]; // scope 0 at $DIR/shifts.rs:+3:10: +3:18\n+    }\n+\n+    bb4: {\n+        _20 = Shl(move _21, move _22);   // scope 0 at $DIR/shifts.rs:+3:10: +3:18\n+        StorageDead(_22);                // scope 0 at $DIR/shifts.rs:+3:17: +3:18\n+        StorageDead(_21);                // scope 0 at $DIR/shifts.rs:+3:17: +3:18\n+        StorageLive(_24);                // scope 0 at $DIR/shifts.rs:+3:20: +3:28\n+        StorageLive(_25);                // scope 0 at $DIR/shifts.rs:+3:20: +3:23\n+        _25 = _2;                        // scope 0 at $DIR/shifts.rs:+3:20: +3:23\n+        StorageLive(_26);                // scope 0 at $DIR/shifts.rs:+3:27: +3:28\n+        _26 = _4;                        // scope 0 at $DIR/shifts.rs:+3:27: +3:28\n+        _27 = Lt(_26, const 128_u32);    // scope 0 at $DIR/shifts.rs:+3:20: +3:28\n+        assert(move _27, \"attempt to shift left by `{}`, which would overflow\", _26) -> [success: bb5, unwind: bb7]; // scope 0 at $DIR/shifts.rs:+3:20: +3:28\n+    }\n+\n+    bb5: {\n+        _24 = Shl(move _25, move _26);   // scope 0 at $DIR/shifts.rs:+3:20: +3:28\n+        StorageDead(_26);                // scope 0 at $DIR/shifts.rs:+3:27: +3:28\n+        StorageDead(_25);                // scope 0 at $DIR/shifts.rs:+3:27: +3:28\n+        StorageLive(_28);                // scope 0 at $DIR/shifts.rs:+3:30: +3:38\n+        StorageLive(_29);                // scope 0 at $DIR/shifts.rs:+3:30: +3:33\n+        _29 = _2;                        // scope 0 at $DIR/shifts.rs:+3:30: +3:33\n+        StorageLive(_30);                // scope 0 at $DIR/shifts.rs:+3:37: +3:38\n+        _30 = _5;                        // scope 0 at $DIR/shifts.rs:+3:37: +3:38\n+        _31 = Lt(_30, const 128_u128);   // scope 0 at $DIR/shifts.rs:+3:30: +3:38\n+        assert(move _31, \"attempt to shift left by `{}`, which would overflow\", _30) -> [success: bb6, unwind: bb7]; // scope 0 at $DIR/shifts.rs:+3:30: +3:38\n+    }\n+\n+    bb6: {\n+        _28 = Shl(move _29, move _30);   // scope 0 at $DIR/shifts.rs:+3:30: +3:38\n+        StorageDead(_30);                // scope 0 at $DIR/shifts.rs:+3:37: +3:38\n+        StorageDead(_29);                // scope 0 at $DIR/shifts.rs:+3:37: +3:38\n+        _19 = [move _20, move _24, move _28]; // scope 0 at $DIR/shifts.rs:+3:9: +3:39\n+        StorageDead(_28);                // scope 0 at $DIR/shifts.rs:+3:38: +3:39\n+        StorageDead(_24);                // scope 0 at $DIR/shifts.rs:+3:38: +3:39\n+        StorageDead(_20);                // scope 0 at $DIR/shifts.rs:+3:38: +3:39\n+        _0 = (move _6, move _19);        // scope 0 at $DIR/shifts.rs:+1:5: +4:6\n+        StorageDead(_19);                // scope 0 at $DIR/shifts.rs:+4:5: +4:6\n+        StorageDead(_6);                 // scope 0 at $DIR/shifts.rs:+4:5: +4:6\n+        return;                          // scope 0 at $DIR/shifts.rs:+5:2: +5:2\n+    }\n+\n+    bb7 (cleanup): {\n+        resume;                          // scope 0 at $DIR/shifts.rs:+0:1: +5:2\n+    }\n+}"}, {"sha": "b377a65b96418f7af20a4f182832246a640e7c73", "filename": "tests/mir-opt/issue_101973.inner.ConstProp.diff", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/99c49d95cd7d704d2226859cfdc419c930cde9c6/tests%2Fmir-opt%2Fissue_101973.inner.ConstProp.diff", "raw_url": "https://github.com/rust-lang/rust/raw/99c49d95cd7d704d2226859cfdc419c930cde9c6/tests%2Fmir-opt%2Fissue_101973.inner.ConstProp.diff", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fmir-opt%2Fissue_101973.inner.ConstProp.diff?ref=99c49d95cd7d704d2226859cfdc419c930cde9c6", "patch": "@@ -12,9 +12,9 @@\n       let mut _7: u32;                     // in scope 0 at $DIR/issue_101973.rs:+1:31: +1:52\n       let mut _8: u32;                     // in scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n       let mut _9: u32;                     // in scope 0 at $DIR/issue_101973.rs:+1:33: +1:39\n-      let mut _10: i32;                    // in scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n+      let mut _10: u32;                    // in scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n       let mut _11: bool;                   // in scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n-      let mut _12: i32;                    // in scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n+      let mut _12: u32;                    // in scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n       let mut _13: bool;                   // in scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n       scope 1 (inlined imm8) {             // at $DIR/issue_101973.rs:14:5: 14:17\n           debug x => _1;                   // in scope 1 at $DIR/issue_101973.rs:5:13: 5:14\n@@ -43,24 +43,24 @@\n           StorageLive(_6);                 // scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n           StorageLive(_7);                 // scope 0 at $DIR/issue_101973.rs:+1:31: +1:52\n           StorageLive(_8);                 // scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n--         _10 = BitAnd(const 8_i32, const -32_i32); // scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n--         _11 = Ne(move _10, const 0_i32); // scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n--         assert(!move _11, \"attempt to shift right by `{}`, which would overflow\", const 8_i32) -> bb1; // scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n-+         _10 = const 0_i32;               // scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n-+         _11 = const false;               // scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n-+         assert(!const false, \"attempt to shift right by `{}`, which would overflow\", const 8_i32) -> bb1; // scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n+-         _10 = const 8_i32 as u32 (IntToInt); // scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n+-         _11 = Lt(move _10, const 32_u32); // scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n+-         assert(move _11, \"attempt to shift right by `{}`, which would overflow\", const 8_i32) -> bb1; // scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n++         _10 = const 8_u32;               // scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n++         _11 = const true;                // scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n++         assert(const true, \"attempt to shift right by `{}`, which would overflow\", const 8_i32) -> bb1; // scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n       }\n   \n       bb1: {\n           _8 = Shr(_1, const 8_i32);       // scope 0 at $DIR/issue_101973.rs:+1:32: +1:45\n           _7 = BitAnd(move _8, const 15_u32); // scope 0 at $DIR/issue_101973.rs:+1:31: +1:52\n           StorageDead(_8);                 // scope 0 at $DIR/issue_101973.rs:+1:51: +1:52\n--         _12 = BitAnd(const 1_i32, const -32_i32); // scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n--         _13 = Ne(move _12, const 0_i32); // scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n--         assert(!move _13, \"attempt to shift left by `{}`, which would overflow\", const 1_i32) -> bb2; // scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n-+         _12 = const 0_i32;               // scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n-+         _13 = const false;               // scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n-+         assert(!const false, \"attempt to shift left by `{}`, which would overflow\", const 1_i32) -> bb2; // scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n+-         _12 = const 1_i32 as u32 (IntToInt); // scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n+-         _13 = Lt(move _12, const 32_u32); // scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n+-         assert(move _13, \"attempt to shift left by `{}`, which would overflow\", const 1_i32) -> bb2; // scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n++         _12 = const 1_u32;               // scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n++         _13 = const true;                // scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n++         assert(const true, \"attempt to shift left by `{}`, which would overflow\", const 1_i32) -> bb2; // scope 0 at $DIR/issue_101973.rs:+1:31: +1:57\n       }\n   \n       bb2: {"}, {"sha": "64317b9d39aae4d99ea034982337a7821b3a61f4", "filename": "tests/ui/const-generics/generic_const_exprs/typeid-equality-by-subtyping.rs", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/rust-lang/rust/blob/99c49d95cd7d704d2226859cfdc419c930cde9c6/tests%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Ftypeid-equality-by-subtyping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99c49d95cd7d704d2226859cfdc419c930cde9c6/tests%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Ftypeid-equality-by-subtyping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fconst-generics%2Fgeneric_const_exprs%2Ftypeid-equality-by-subtyping.rs?ref=99c49d95cd7d704d2226859cfdc419c930cde9c6", "patch": "@@ -0,0 +1,52 @@\n+// check-pass\n+// known-bug: #97156\n+\n+#![feature(const_type_id, generic_const_exprs)]\n+#![allow(incomplete_features)]\n+\n+use std::any::TypeId;\n+// `One` and `Two` are currently considered equal types, as both\n+// `One <: Two` and `One :> Two` holds.\n+type One = for<'a> fn(&'a (), &'a ());\n+type Two = for<'a, 'b> fn(&'a (), &'b ());\n+trait AssocCt {\n+    const ASSOC: usize;\n+}\n+const fn to_usize<T: 'static>() -> usize {\n+    const WHAT_A_TYPE: TypeId = TypeId::of::<One>();\n+    match TypeId::of::<T>() {\n+        WHAT_A_TYPE => 0,\n+        _ => 1000,\n+    } \n+}\n+impl<T: 'static> AssocCt for T {\n+    const ASSOC: usize = to_usize::<T>();\n+}\n+\n+trait WithAssoc<U> {\n+    type Assoc;\n+}\n+impl<T: 'static> WithAssoc<()> for T where [(); <T as AssocCt>::ASSOC]: {\n+    type Assoc = [u8; <T as AssocCt>::ASSOC];\n+}\n+\n+fn generic<T: 'static, U>(x: <T as WithAssoc<U>>::Assoc) -> <T as WithAssoc<U>>::Assoc\n+where\n+    [(); <T as AssocCt>::ASSOC]:,\n+    T: WithAssoc<U>,\n+{\n+    x\n+}\n+\n+\n+fn unsound<T>(x: <One as WithAssoc<T>>::Assoc) -> <Two as WithAssoc<T>>::Assoc\n+where\n+    One: WithAssoc<T>,\n+{\n+    let x: <Two as WithAssoc<T>>::Assoc = generic::<One, T>(x);\n+    x\n+}\n+\n+fn main() {\n+    println!(\"{:?}\", unsound::<()>([]));\n+}"}, {"sha": "e1d5511379e7a9f2875dd1b1405637a8ea7a8937", "filename": "tests/ui/impl-trait/nested-return-type2.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/99c49d95cd7d704d2226859cfdc419c930cde9c6/tests%2Fui%2Fimpl-trait%2Fnested-return-type2.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99c49d95cd7d704d2226859cfdc419c930cde9c6/tests%2Fui%2Fimpl-trait%2Fnested-return-type2.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fnested-return-type2.rs?ref=99c49d95cd7d704d2226859cfdc419c930cde9c6", "patch": "@@ -26,7 +26,6 @@ impl<R: Duh, F: FnMut() -> R> Trait for F {\n // Lazy TAIT would error out, but we inserted a hack to make it work again,\n // keeping backwards compatibility.\n fn foo() -> impl Trait<Assoc = impl Send> {\n-    //~^ WARN opaque type `impl Trait<Assoc = impl Send>` does not satisfy its associated type bounds\n     || 42\n }\n "}, {"sha": "09ad3bd05c1b3dda20e4842d09f3186cde6d8249", "filename": "tests/ui/impl-trait/nested-return-type2.stderr", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9a6b0c3326f3577f330d8828d3b706c0eea9cf29/tests%2Fui%2Fimpl-trait%2Fnested-return-type2.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a6b0c3326f3577f330d8828d3b706c0eea9cf29/tests%2Fui%2Fimpl-trait%2Fnested-return-type2.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fnested-return-type2.stderr?ref=9a6b0c3326f3577f330d8828d3b706c0eea9cf29", "patch": "@@ -1,17 +0,0 @@\n-warning: opaque type `impl Trait<Assoc = impl Send>` does not satisfy its associated type bounds\n-  --> $DIR/nested-return-type2.rs:28:24\n-   |\n-LL |     type Assoc: Duh;\n-   |                 --- this associated type bound is unsatisfied for `impl Send`\n-...\n-LL | fn foo() -> impl Trait<Assoc = impl Send> {\n-   |                        ^^^^^^^^^^^^^^^^^\n-   |\n-   = note: `#[warn(opaque_hidden_inferred_bound)]` on by default\n-help: add this bound\n-   |\n-LL | fn foo() -> impl Trait<Assoc = impl Send + Duh> {\n-   |                                          +++++\n-\n-warning: 1 warning emitted\n-"}, {"sha": "74b4dae22ebfd32a5ee845c1ec3d8834f4bc447e", "filename": "tests/ui/impl-trait/nested-return-type3.rs", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/99c49d95cd7d704d2226859cfdc419c930cde9c6/tests%2Fui%2Fimpl-trait%2Fnested-return-type3.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99c49d95cd7d704d2226859cfdc419c930cde9c6/tests%2Fui%2Fimpl-trait%2Fnested-return-type3.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fnested-return-type3.rs?ref=99c49d95cd7d704d2226859cfdc419c930cde9c6", "patch": "@@ -13,7 +13,6 @@ impl<F: Duh> Trait for F {\n }\n \n fn foo() -> impl Trait<Assoc = impl Send> {\n-    //~^ WARN opaque type `impl Trait<Assoc = impl Send>` does not satisfy its associated type bounds\n     42\n }\n "}, {"sha": "632de71aa4c880246ad942242eae3b6ab01f4beb", "filename": "tests/ui/impl-trait/nested-return-type3.stderr", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/rust-lang/rust/blob/9a6b0c3326f3577f330d8828d3b706c0eea9cf29/tests%2Fui%2Fimpl-trait%2Fnested-return-type3.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/9a6b0c3326f3577f330d8828d3b706c0eea9cf29/tests%2Fui%2Fimpl-trait%2Fnested-return-type3.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Fimpl-trait%2Fnested-return-type3.stderr?ref=9a6b0c3326f3577f330d8828d3b706c0eea9cf29", "patch": "@@ -1,17 +0,0 @@\n-warning: opaque type `impl Trait<Assoc = impl Send>` does not satisfy its associated type bounds\n-  --> $DIR/nested-return-type3.rs:15:24\n-   |\n-LL |     type Assoc: Duh;\n-   |                 --- this associated type bound is unsatisfied for `impl Send`\n-...\n-LL | fn foo() -> impl Trait<Assoc = impl Send> {\n-   |                        ^^^^^^^^^^^^^^^^^\n-   |\n-   = note: `#[warn(opaque_hidden_inferred_bound)]` on by default\n-help: add this bound\n-   |\n-LL | fn foo() -> impl Trait<Assoc = impl Send + Duh> {\n-   |                                          +++++\n-\n-warning: 1 warning emitted\n-"}, {"sha": "30c1981a92eceed582a7460fb904ec75ad431dbc", "filename": "tests/ui/traits/new-solver/alias-sub.rs", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/rust-lang/rust/blob/99c49d95cd7d704d2226859cfdc419c930cde9c6/tests%2Fui%2Ftraits%2Fnew-solver%2Falias-sub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/99c49d95cd7d704d2226859cfdc419c930cde9c6/tests%2Fui%2Ftraits%2Fnew-solver%2Falias-sub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/tests%2Fui%2Ftraits%2Fnew-solver%2Falias-sub.rs?ref=99c49d95cd7d704d2226859cfdc419c930cde9c6", "patch": "@@ -0,0 +1,34 @@\n+// compile-flags: -Ztrait-solver=next\n+// check-pass\n+\n+trait Trait {\n+    type Assoc: Sized;\n+}\n+\n+impl Trait for &'static str {\n+    type Assoc = &'static str;\n+}\n+\n+// Wrapper is just here to get around stupid `Sized` obligations in mir typeck\n+struct Wrapper<T: ?Sized>(std::marker::PhantomData<T>);\n+fn mk<T: Trait>(x: T) -> Wrapper<<T as Trait>::Assoc> { todo!() }\n+\n+\n+trait IsStaticStr {}\n+impl IsStaticStr for (&'static str,) {}\n+fn define<T: IsStaticStr>(_: T) {}\n+\n+fn foo<'a, T: Trait>() {\n+    let y = Default::default();\n+\n+    // `<?0 as Trait>::Assoc <: &'a str`\n+    // In the old solver, this would *equate* the LHS and RHS.\n+    let _: Wrapper<&'a str> = mk(y);\n+\n+    // ... then later on, we constrain `?0 = &'static str`\n+    // but that should not mean that `'a = 'static`, because\n+    // we should use *sub* above.\n+    define((y,));\n+}\n+\n+fn main() {}"}]}