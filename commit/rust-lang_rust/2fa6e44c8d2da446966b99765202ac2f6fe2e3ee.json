{"sha": "2fa6e44c8d2da446966b99765202ac2f6fe2e3ee", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJmYTZlNDRjOGQyZGE0NDY5NjZiOTk3NjUyMDJhYzJmNmZlMmUzZWU=", "commit": {"author": {"name": "Josh Stone", "email": "jistone@redhat.com", "date": "2020-08-08T03:44:12Z"}, "committer": {"name": "Josh Stone", "email": "jistone@redhat.com", "date": "2020-08-09T19:25:22Z"}, "message": "rustc_metadata: use IndexSet in EncodeContext", "tree": {"sha": "400af6e98627ff9e06194cbf69ad669004240356", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/400af6e98627ff9e06194cbf69ad669004240356"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2fa6e44c8d2da446966b99765202ac2f6fe2e3ee", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2fa6e44c8d2da446966b99765202ac2f6fe2e3ee", "html_url": "https://github.com/rust-lang/rust/commit/2fa6e44c8d2da446966b99765202ac2f6fe2e3ee", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2fa6e44c8d2da446966b99765202ac2f6fe2e3ee/comments", "author": {"login": "cuviper", "id": 36186, "node_id": "MDQ6VXNlcjM2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/36186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cuviper", "html_url": "https://github.com/cuviper", "followers_url": "https://api.github.com/users/cuviper/followers", "following_url": "https://api.github.com/users/cuviper/following{/other_user}", "gists_url": "https://api.github.com/users/cuviper/gists{/gist_id}", "starred_url": "https://api.github.com/users/cuviper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cuviper/subscriptions", "organizations_url": "https://api.github.com/users/cuviper/orgs", "repos_url": "https://api.github.com/users/cuviper/repos", "events_url": "https://api.github.com/users/cuviper/events{/privacy}", "received_events_url": "https://api.github.com/users/cuviper/received_events", "type": "User", "site_admin": false}, "committer": {"login": "cuviper", "id": 36186, "node_id": "MDQ6VXNlcjM2MTg2", "avatar_url": "https://avatars.githubusercontent.com/u/36186?v=4", "gravatar_id": "", "url": "https://api.github.com/users/cuviper", "html_url": "https://github.com/cuviper", "followers_url": "https://api.github.com/users/cuviper/followers", "following_url": "https://api.github.com/users/cuviper/following{/other_user}", "gists_url": "https://api.github.com/users/cuviper/gists{/gist_id}", "starred_url": "https://api.github.com/users/cuviper/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/cuviper/subscriptions", "organizations_url": "https://api.github.com/users/cuviper/orgs", "repos_url": "https://api.github.com/users/cuviper/repos", "events_url": "https://api.github.com/users/cuviper/events{/privacy}", "received_events_url": "https://api.github.com/users/cuviper/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "d3c70b8af516497cbc817f4b5d907ff7cf91661f", "url": "https://api.github.com/repos/rust-lang/rust/commits/d3c70b8af516497cbc817f4b5d907ff7cf91661f", "html_url": "https://github.com/rust-lang/rust/commit/d3c70b8af516497cbc817f4b5d907ff7cf91661f"}], "stats": {"total": 22, "additions": 5, "deletions": 17}, "files": [{"sha": "974fde3d8099d493057a6a91049fbc60bae99255", "filename": "src/librustc_metadata/rmeta/encoder.rs", "status": "modified", "additions": 5, "deletions": 17, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/2fa6e44c8d2da446966b99765202ac2f6fe2e3ee/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fa6e44c8d2da446966b99765202ac2f6fe2e3ee/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Frmeta%2Fencoder.rs?ref=2fa6e44c8d2da446966b99765202ac2f6fe2e3ee", "patch": "@@ -4,7 +4,7 @@ use crate::rmeta::*;\n use log::{debug, trace};\n use rustc_ast::ast;\n use rustc_data_structures::fingerprint::Fingerprint;\n-use rustc_data_structures::fx::{FxHashMap, FxHashSet};\n+use rustc_data_structures::fx::{FxHashMap, FxHashSet, FxIndexSet};\n use rustc_data_structures::stable_hasher::StableHasher;\n use rustc_data_structures::sync::{join, Lrc};\n use rustc_hir as hir;\n@@ -48,8 +48,7 @@ struct EncodeContext<'a, 'tcx> {\n     type_shorthands: FxHashMap<Ty<'tcx>, usize>,\n     predicate_shorthands: FxHashMap<ty::Predicate<'tcx>, usize>,\n \n-    interpret_allocs: FxHashMap<interpret::AllocId, usize>,\n-    interpret_allocs_inverse: Vec<interpret::AllocId>,\n+    interpret_allocs: FxIndexSet<interpret::AllocId>,\n \n     // This is used to speed up Span encoding.\n     // The `usize` is an index into the `MonotonicVec`\n@@ -327,17 +326,7 @@ impl<'a, 'b, 'tcx> SpecializedEncoder<ty::Predicate<'b>> for EncodeContext<'a, '\n \n impl<'a, 'tcx> SpecializedEncoder<interpret::AllocId> for EncodeContext<'a, 'tcx> {\n     fn specialized_encode(&mut self, alloc_id: &interpret::AllocId) -> Result<(), Self::Error> {\n-        use std::collections::hash_map::Entry;\n-        let index = match self.interpret_allocs.entry(*alloc_id) {\n-            Entry::Occupied(e) => *e.get(),\n-            Entry::Vacant(e) => {\n-                let idx = self.interpret_allocs_inverse.len();\n-                self.interpret_allocs_inverse.push(*alloc_id);\n-                e.insert(idx);\n-                idx\n-            }\n-        };\n-\n+        let (index, _) = self.interpret_allocs.insert_full(*alloc_id);\n         index.encode(self)\n     }\n }\n@@ -579,15 +568,15 @@ impl<'a, 'tcx> EncodeContext<'a, 'tcx> {\n             let mut n = 0;\n             trace!(\"beginning to encode alloc ids\");\n             loop {\n-                let new_n = self.interpret_allocs_inverse.len();\n+                let new_n = self.interpret_allocs.len();\n                 // if we have found new ids, serialize those, too\n                 if n == new_n {\n                     // otherwise, abort\n                     break;\n                 }\n                 trace!(\"encoding {} further alloc ids\", new_n - n);\n                 for idx in n..new_n {\n-                    let id = self.interpret_allocs_inverse[idx];\n+                    let id = self.interpret_allocs[idx];\n                     let pos = self.position() as u32;\n                     interpret_alloc_index.push(pos);\n                     interpret::specialized_encode_alloc_id(self, tcx, id).unwrap();\n@@ -2015,7 +2004,6 @@ fn encode_metadata_impl(tcx: TyCtxt<'_>) -> EncodedMetadata {\n         predicate_shorthands: Default::default(),\n         source_file_cache: (source_map_files[0].clone(), 0),\n         interpret_allocs: Default::default(),\n-        interpret_allocs_inverse: Default::default(),\n         required_source_files: Some(GrowableBitSet::with_capacity(source_map_files.len())),\n         is_proc_macro: tcx.sess.crate_types().contains(&CrateType::ProcMacro),\n         hygiene_ctxt: &hygiene_ctxt,"}]}