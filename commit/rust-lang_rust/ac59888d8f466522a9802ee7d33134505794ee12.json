{"sha": "ac59888d8f466522a9802ee7d33134505794ee12", "node_id": "MDY6Q29tbWl0NzI0NzEyOmFjNTk4ODhkOGY0NjY1MjJhOTgwMmVlN2QzMzEzNDUwNTc5NGVlMTI=", "commit": {"author": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-11-26T01:55:41Z"}, "committer": {"name": "Alex Crichton", "email": "alex@alexcrichton.com", "date": "2013-11-26T01:55:41Z"}, "message": "Move LittleLock to using RAII\n\nThis moves the locking/waiting methods to returning an RAII struct instead of\nrelying on closures. Additionally, this changes the methods to all take\n'&mut self' to discourage recursive locking. The new method to block is to call\n`wait` on the returned RAII structure instead of calling it on the lock itself\n(this enforces that the lock is held).\n\nAt the same time, this improves the Mutex interface a bit by allowing\ndestruction of non-initialized members and by allowing construction of an empty\nmutex (nothing initialized inside).", "tree": {"sha": "f3577feb56ac8aec687895d58fdd6938848aae33", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/f3577feb56ac8aec687895d58fdd6938848aae33"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/ac59888d8f466522a9802ee7d33134505794ee12", "comment_count": 9, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/ac59888d8f466522a9802ee7d33134505794ee12", "html_url": "https://github.com/rust-lang/rust/commit/ac59888d8f466522a9802ee7d33134505794ee12", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/ac59888d8f466522a9802ee7d33134505794ee12/comments", "author": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "committer": {"login": "alexcrichton", "id": 64996, "node_id": "MDQ6VXNlcjY0OTk2", "avatar_url": "https://avatars.githubusercontent.com/u/64996?v=4", "gravatar_id": "", "url": "https://api.github.com/users/alexcrichton", "html_url": "https://github.com/alexcrichton", "followers_url": "https://api.github.com/users/alexcrichton/followers", "following_url": "https://api.github.com/users/alexcrichton/following{/other_user}", "gists_url": "https://api.github.com/users/alexcrichton/gists{/gist_id}", "starred_url": "https://api.github.com/users/alexcrichton/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/alexcrichton/subscriptions", "organizations_url": "https://api.github.com/users/alexcrichton/orgs", "repos_url": "https://api.github.com/users/alexcrichton/repos", "events_url": "https://api.github.com/users/alexcrichton/events{/privacy}", "received_events_url": "https://api.github.com/users/alexcrichton/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "679a2c042fb2541f55f1192ca97672907b258337", "url": "https://api.github.com/repos/rust-lang/rust/commits/679a2c042fb2541f55f1192ca97672907b258337", "html_url": "https://github.com/rust-lang/rust/commit/679a2c042fb2541f55f1192ca97672907b258337"}], "stats": {"total": 142, "additions": 71, "deletions": 71}, "files": [{"sha": "ff46824d82359cb2e9ecaaaf31df6ef1837dd9e0", "filename": "src/libstd/unstable/mutex.rs", "status": "modified", "additions": 21, "deletions": 2, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/ac59888d8f466522a9802ee7d33134505794ee12/src%2Flibstd%2Funstable%2Fmutex.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac59888d8f466522a9802ee7d33134505794ee12/src%2Flibstd%2Funstable%2Fmutex.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fmutex.rs?ref=ac59888d8f466522a9802ee7d33134505794ee12", "patch": "@@ -70,6 +70,15 @@ impl Mutex {\n         }\n     }\n \n+    /// Creates a new mutex, with the lock/condition variable not initialized.\n+    /// This is the same as initializing from the MUTEX_INIT static.\n+    pub unsafe fn empty() -> Mutex {\n+        Mutex {\n+            lock: atomics::AtomicUint::new(0),\n+            cond: atomics::AtomicUint::new(0),\n+        }\n+    }\n+\n     /// Creates a new copy of this mutex. This is an unsafe operation because\n     /// there is no reference counting performed on this type.\n     ///\n@@ -117,8 +126,10 @@ impl Mutex {\n     /// that no other thread is currently holding the lock or waiting on the\n     /// condition variable contained inside.\n     pub unsafe fn destroy(&mut self) {\n-        imp::free_lock(self.lock.swap(0, atomics::Relaxed));\n-        imp::free_cond(self.cond.swap(0, atomics::Relaxed));\n+        let lock = self.lock.swap(0, atomics::Relaxed);\n+        let cond = self.cond.swap(0, atomics::Relaxed);\n+        if lock != 0 { imp::free_lock(lock) }\n+        if cond != 0 { imp::free_cond(cond) }\n     }\n \n     unsafe fn getlock(&mut self) -> *c_void {\n@@ -333,4 +344,12 @@ mod test {\n             t.join();\n         }\n     }\n+\n+    #[test]\n+    fn destroy_immediately() {\n+        unsafe {\n+            let mut m = Mutex::empty();\n+            m.destroy();\n+        }\n+    }\n }"}, {"sha": "e80b58d01efb2acebb2b4180f90cd45669f519cb", "filename": "src/libstd/unstable/sync.rs", "status": "modified", "additions": 50, "deletions": 69, "changes": 119, "blob_url": "https://github.com/rust-lang/rust/blob/ac59888d8f466522a9802ee7d33134505794ee12/src%2Flibstd%2Funstable%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/ac59888d8f466522a9802ee7d33134505794ee12/src%2Flibstd%2Funstable%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Funstable%2Fsync.rs?ref=ac59888d8f466522a9802ee7d33134505794ee12", "patch": "@@ -319,67 +319,49 @@ pub struct LittleLock {\n     priv l: Mutex,\n }\n \n+pub struct LittleGuard<'a> {\n+    priv l: &'a mut Mutex,\n+}\n+\n impl Drop for LittleLock {\n     fn drop(&mut self) {\n-        unsafe {\n-            self.l.destroy();\n-        }\n+        unsafe { self.l.destroy(); }\n+    }\n+}\n+\n+#[unsafe_destructor]\n+impl<'a> Drop for LittleGuard<'a> {\n+    fn drop(&mut self) {\n+        unsafe { self.l.unlock(); }\n     }\n }\n \n impl LittleLock {\n     pub fn new() -> LittleLock {\n-        unsafe {\n-            LittleLock {\n-                l: Mutex::new()\n-            }\n-        }\n+        unsafe { LittleLock { l: Mutex::new() } }\n     }\n \n-    pub unsafe fn lock<T>(&self, f: || -> T) -> T {\n-        let this = cast::transmute_mut(self);\n-        do atomically {\n-            this.l.lock();\n-            do (|| {\n-                f()\n-            }).finally {\n-                this.l.unlock();\n-            }\n-        }\n+    pub unsafe fn lock<'a>(&'a mut self) -> LittleGuard<'a> {\n+        self.l.lock();\n+        LittleGuard { l: &mut self.l }\n     }\n \n-    pub unsafe fn try_lock<T>(&self, f: || -> T) -> Option<T> {\n-        let this = cast::transmute_mut(self);\n-        do atomically {\n-            if this.l.trylock() {\n-                Some(do (|| {\n-                    f()\n-                }).finally {\n-                    this.l.unlock();\n-                })\n-            } else {\n-                None\n-            }\n+    pub unsafe fn try_lock<'a>(&'a mut self) -> Option<LittleGuard<'a>> {\n+        if self.l.trylock() {\n+            Some(LittleGuard { l: &mut self.l })\n+        } else {\n+            None\n         }\n     }\n \n-    pub unsafe fn signal(&self) {\n-        let this = cast::transmute_mut(self);\n-        this.l.signal();\n+    pub unsafe fn signal(&mut self) {\n+        self.l.signal();\n     }\n+}\n \n-    pub unsafe fn lock_and_wait(&self, f: || -> bool) {\n-        let this = cast::transmute_mut(self);\n-        do atomically {\n-            this.l.lock();\n-            do (|| {\n-                if f() {\n-                    this.l.wait();\n-                }\n-            }).finally {\n-                this.l.unlock();\n-            }\n-        }\n+impl<'a> LittleGuard<'a> {\n+    pub unsafe fn wait(&mut self) {\n+        self.l.wait();\n     }\n }\n \n@@ -431,15 +413,14 @@ impl<T:Send> Exclusive<T> {\n     #[inline]\n     pub unsafe fn with<U>(&self, f: |x: &mut T| -> U) -> U {\n         let rec = self.x.get();\n-        do (*rec).lock.lock {\n-            if (*rec).failed {\n-                fail!(\"Poisoned Exclusive::new - another task failed inside!\");\n-            }\n-            (*rec).failed = true;\n-            let result = f(&mut (*rec).data);\n-            (*rec).failed = false;\n-            result\n+        let _l = (*rec).lock.lock();\n+        if (*rec).failed {\n+            fail!(\"Poisoned Exclusive::new - another task failed inside!\");\n         }\n+        (*rec).failed = true;\n+        let result = f(&mut (*rec).data);\n+        (*rec).failed = false;\n+        result\n     }\n \n     #[inline]\n@@ -452,28 +433,28 @@ impl<T:Send> Exclusive<T> {\n     #[inline]\n     pub unsafe fn hold_and_signal(&self, f: |x: &mut T|) {\n         let rec = self.x.get();\n-        do (*rec).lock.lock {\n-            if (*rec).failed {\n-                fail!(\"Poisoned Exclusive::new - another task failed inside!\");\n-            }\n-            (*rec).failed = true;\n-            f(&mut (*rec).data);\n-            (*rec).failed = false;\n-            (*rec).lock.signal();\n+        let _l = (*rec).lock.lock();\n+        if (*rec).failed {\n+            fail!(\"Poisoned Exclusive::new - another task failed inside!\");\n         }\n+        (*rec).failed = true;\n+        f(&mut (*rec).data);\n+        (*rec).failed = false;\n+        (*rec).lock.signal();\n     }\n \n     #[inline]\n     pub unsafe fn hold_and_wait(&self, f: |x: &T| -> bool) {\n         let rec = self.x.get();\n-        do (*rec).lock.lock_and_wait {\n-            if (*rec).failed {\n-                fail!(\"Poisoned Exclusive::new - another task failed inside!\");\n-            }\n-            (*rec).failed = true;\n-            let result = f(&(*rec).data);\n-            (*rec).failed = false;\n-            result\n+        let mut l = (*rec).lock.lock();\n+        if (*rec).failed {\n+            fail!(\"Poisoned Exclusive::new - another task failed inside!\");\n+        }\n+        (*rec).failed = true;\n+        let result = f(&(*rec).data);\n+        (*rec).failed = false;\n+        if result {\n+            l.wait();\n         }\n     }\n "}]}