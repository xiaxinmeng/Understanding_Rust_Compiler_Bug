{"sha": "fba32ea79f1828ef441d91abca3635fad57f323d", "node_id": "MDY6Q29tbWl0NzI0NzEyOmZiYTMyZWE3OWYxODI4ZWY0NDFkOTFhYmNhMzYzNWZhZDU3ZjMyM2Q=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-15T10:36:27Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2014-02-15T10:36:27Z"}, "message": "auto merge of #12283 : kballard/rust/env-args-bytes, r=erickt\n\nChange `os::args()` and `os::env()` to use `str::from_utf8_lossy()`.\r\nAdd new functions `os::args_as_bytes()` and `os::env_as_bytes()` to retrieve the args/env as byte vectors instead.\r\n\r\nThe existing methods were left returning strings because I expect that the common use-case is to want string handling.\r\n\r\nFixes #7188.", "tree": {"sha": "1d07a3053f3492b25816a46f912df95bd208bd6e", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/1d07a3053f3492b25816a46f912df95bd208bd6e"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/fba32ea79f1828ef441d91abca3635fad57f323d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/fba32ea79f1828ef441d91abca3635fad57f323d", "html_url": "https://github.com/rust-lang/rust/commit/fba32ea79f1828ef441d91abca3635fad57f323d", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/fba32ea79f1828ef441d91abca3635fad57f323d/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c9f13b47febb81ef339a15adf0f6ad7a2265c46d", "url": "https://api.github.com/repos/rust-lang/rust/commits/c9f13b47febb81ef339a15adf0f6ad7a2265c46d", "html_url": "https://github.com/rust-lang/rust/commit/c9f13b47febb81ef339a15adf0f6ad7a2265c46d"}, {"sha": "d22b1646aafd51ffc85fcd24492a6211c2c0dfab", "url": "https://api.github.com/repos/rust-lang/rust/commits/d22b1646aafd51ffc85fcd24492a6211c2c0dfab", "html_url": "https://github.com/rust-lang/rust/commit/d22b1646aafd51ffc85fcd24492a6211c2c0dfab"}], "stats": {"total": 190, "additions": 148, "deletions": 42}, "files": [{"sha": "adbd4be316c8b78419834f1b38a4e2b2b86fa1be", "filename": "src/libstd/c_str.rs", "status": "modified", "additions": 37, "deletions": 4, "changes": 41, "blob_url": "https://github.com/rust-lang/rust/blob/fba32ea79f1828ef441d91abca3635fad57f323d/src%2Flibstd%2Fc_str.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fba32ea79f1828ef441d91abca3635fad57f323d/src%2Flibstd%2Fc_str.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fc_str.rs?ref=fba32ea79f1828ef441d91abca3635fad57f323d", "patch": "@@ -79,6 +79,7 @@ use str;\n use vec::{ImmutableVector, MutableVector};\n use vec;\n use rt::global_heap::malloc_raw;\n+use unstable::raw::Slice;\n \n /// The representation of a C String.\n ///\n@@ -169,6 +170,7 @@ impl CString {\n     }\n \n     /// Converts the CString into a `&[u8]` without copying.\n+    /// Includes the terminating NUL byte.\n     ///\n     /// # Failure\n     ///\n@@ -177,7 +179,21 @@ impl CString {\n     pub fn as_bytes<'a>(&'a self) -> &'a [u8] {\n         if self.buf.is_null() { fail!(\"CString is null!\"); }\n         unsafe {\n-            cast::transmute((self.buf, self.len() + 1))\n+            cast::transmute(Slice { data: self.buf, len: self.len() + 1 })\n+        }\n+    }\n+\n+    /// Converts the CString into a `&[u8]` without copying.\n+    /// Does not include the terminating NUL byte.\n+    ///\n+    /// # Failure\n+    ///\n+    /// Fails if the CString is null.\n+    #[inline]\n+    pub fn as_bytes_no_nul<'a>(&'a self) -> &'a [u8] {\n+        if self.buf.is_null() { fail!(\"CString is null!\"); }\n+        unsafe {\n+            cast::transmute(Slice { data: self.buf, len: self.len() })\n         }\n     }\n \n@@ -189,8 +205,7 @@ impl CString {\n     /// Fails if the CString is null.\n     #[inline]\n     pub fn as_str<'a>(&'a self) -> Option<&'a str> {\n-        let buf = self.as_bytes();\n-        let buf = buf.slice_to(buf.len()-1); // chop off the trailing NUL\n+        let buf = self.as_bytes_no_nul();\n         str::from_utf8(buf)\n     }\n \n@@ -417,7 +432,7 @@ mod tests {\n             let expected = [\"zero\", \"one\"];\n             let mut it = expected.iter();\n             let result = from_c_multistring(ptr as *libc::c_char, None, |c| {\n-                let cbytes = c.as_bytes().slice_to(c.len());\n+                let cbytes = c.as_bytes_no_nul();\n                 assert_eq!(cbytes, it.next().unwrap().as_bytes());\n             });\n             assert_eq!(result, 2);\n@@ -552,13 +567,31 @@ mod tests {\n         assert_eq!(c_str.as_bytes(), bytes!(\"foo\", 0xff, 0));\n     }\n \n+    #[test]\n+    fn test_as_bytes_no_nul() {\n+        let c_str = \"hello\".to_c_str();\n+        assert_eq!(c_str.as_bytes_no_nul(), bytes!(\"hello\"));\n+        let c_str = \"\".to_c_str();\n+        let exp: &[u8] = [];\n+        assert_eq!(c_str.as_bytes_no_nul(), exp);\n+        let c_str = bytes!(\"foo\", 0xff).to_c_str();\n+        assert_eq!(c_str.as_bytes_no_nul(), bytes!(\"foo\", 0xff));\n+    }\n+\n     #[test]\n     #[should_fail]\n     fn test_as_bytes_fail() {\n         let c_str = unsafe { CString::new(ptr::null(), false) };\n         c_str.as_bytes();\n     }\n \n+    #[test]\n+    #[should_fail]\n+    fn test_as_bytes_no_nul_fail() {\n+        let c_str = unsafe { CString::new(ptr::null(), false) };\n+        c_str.as_bytes_no_nul();\n+    }\n+\n     #[test]\n     fn test_as_str() {\n         let c_str = \"hello\".to_c_str();"}, {"sha": "20d1ae2f3e2214a22026390c64a022062dedf7b4", "filename": "src/libstd/os.rs", "status": "modified", "additions": 87, "deletions": 15, "changes": 102, "blob_url": "https://github.com/rust-lang/rust/blob/fba32ea79f1828ef441d91abca3635fad57f323d/src%2Flibstd%2Fos.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fba32ea79f1828ef441d91abca3635fad57f323d/src%2Flibstd%2Fos.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fos.rs?ref=fba32ea79f1828ef441d91abca3635fad57f323d", "patch": "@@ -53,6 +53,8 @@ use ptr::RawPtr;\n \n #[cfg(unix)]\n use c_str::ToCStr;\n+#[cfg(windows)]\n+use str::OwnedStr;\n \n /// Delegates to the libc close() function, returning the same return value.\n pub fn close(fd: int) -> int {\n@@ -158,10 +160,23 @@ fn with_env_lock<T>(f: || -> T) -> T {\n \n /// Returns a vector of (variable, value) pairs for all the environment\n /// variables of the current process.\n+///\n+/// Invalid UTF-8 bytes are replaced with \\uFFFD. See `str::from_utf8_lossy()`\n+/// for details.\n pub fn env() -> ~[(~str,~str)] {\n+    env_as_bytes().move_iter().map(|(k,v)| {\n+        let k = str::from_utf8_lossy(k).into_owned();\n+        let v = str::from_utf8_lossy(v).into_owned();\n+        (k,v)\n+    }).collect()\n+}\n+\n+/// Returns a vector of (variable, value) byte-vector pairs for all the\n+/// environment variables of the current process.\n+pub fn env_as_bytes() -> ~[(~[u8],~[u8])] {\n     unsafe {\n         #[cfg(windows)]\n-        unsafe fn get_env_pairs() -> ~[~str] {\n+        unsafe fn get_env_pairs() -> ~[~[u8]] {\n             use c_str;\n             use str::StrSlice;\n \n@@ -176,13 +191,15 @@ pub fn env() -> ~[(~str,~str)] {\n             }\n             let mut result = ~[];\n             c_str::from_c_multistring(ch as *c_char, None, |cstr| {\n-                result.push(cstr.as_str().unwrap().to_owned());\n+                result.push(cstr.as_bytes_no_nul().to_owned());\n             });\n             FreeEnvironmentStringsA(ch);\n             result\n         }\n         #[cfg(unix)]\n-        unsafe fn get_env_pairs() -> ~[~str] {\n+        unsafe fn get_env_pairs() -> ~[~[u8]] {\n+            use c_str::CString;\n+\n             extern {\n                 fn rust_env_pairs() -> **c_char;\n             }\n@@ -193,20 +210,19 @@ pub fn env() -> ~[(~str,~str)] {\n             }\n             let mut result = ~[];\n             ptr::array_each(environ, |e| {\n-                let env_pair = str::raw::from_c_str(e);\n-                debug!(\"get_env_pairs: {}\", env_pair);\n+                let env_pair = CString::new(e, false).as_bytes_no_nul().to_owned();\n                 result.push(env_pair);\n             });\n             result\n         }\n \n-        fn env_convert(input: ~[~str]) -> ~[(~str, ~str)] {\n+        fn env_convert(input: ~[~[u8]]) -> ~[(~[u8], ~[u8])] {\n             let mut pairs = ~[];\n             for p in input.iter() {\n-                let vs: ~[&str] = p.splitn('=', 1).collect();\n-                debug!(\"splitting: len: {}\", vs.len());\n-                assert_eq!(vs.len(), 2);\n-                pairs.push((vs[0].to_owned(), vs[1].to_owned()));\n+                let vs: ~[&[u8]] = p.splitn(1, |b| *b == '=' as u8).collect();\n+                let key = vs[0].to_owned();\n+                let val = (if vs.len() < 2 { ~[] } else { vs[1].to_owned() });\n+                pairs.push((key, val));\n             }\n             pairs\n         }\n@@ -220,14 +236,34 @@ pub fn env() -> ~[(~str,~str)] {\n #[cfg(unix)]\n /// Fetches the environment variable `n` from the current process, returning\n /// None if the variable isn't set.\n+///\n+/// Any invalid UTF-8 bytes in the value are replaced by \\uFFFD. See\n+/// `str::from_utf8_lossy()` for details.\n+///\n+/// # Failure\n+///\n+/// Fails if `n` has any interior NULs.\n pub fn getenv(n: &str) -> Option<~str> {\n+    getenv_as_bytes(n).map(|v| str::from_utf8_lossy(v).into_owned())\n+}\n+\n+#[cfg(unix)]\n+/// Fetches the environment variable `n` byte vector from the current process,\n+/// returning None if the variable isn't set.\n+///\n+/// # Failure\n+///\n+/// Fails if `n` has any interior NULs.\n+pub fn getenv_as_bytes(n: &str) -> Option<~[u8]> {\n+    use c_str::CString;\n+\n     unsafe {\n         with_env_lock(|| {\n             let s = n.with_c_str(|buf| libc::getenv(buf));\n             if s.is_null() {\n                 None\n             } else {\n-                Some(str::raw::from_c_str(s))\n+                Some(CString::new(s, false).as_bytes_no_nul().to_owned())\n             }\n         })\n     }\n@@ -249,10 +285,21 @@ pub fn getenv(n: &str) -> Option<~str> {\n     }\n }\n \n+#[cfg(windows)]\n+/// Fetches the environment variable `n` byte vector from the current process,\n+/// returning None if the variable isn't set.\n+pub fn getenv_as_bytes(n: &str) -> Option<~[u8]> {\n+    getenv(n).map(|s| s.into_bytes())\n+}\n+\n \n #[cfg(unix)]\n /// Sets the environment variable `n` to the value `v` for the currently running\n /// process\n+///\n+/// # Failure\n+///\n+/// Fails if `n` or `v` have any interior NULs.\n pub fn setenv(n: &str, v: &str) {\n     unsafe {\n         with_env_lock(|| {\n@@ -283,6 +330,10 @@ pub fn setenv(n: &str, v: &str) {\n }\n \n /// Remove a variable from the environment entirely\n+///\n+/// # Failure\n+///\n+/// Fails (on unix) if `n` has any interior NULs.\n pub fn unsetenv(n: &str) {\n     #[cfg(unix)]\n     fn _unsetenv(n: &str) {\n@@ -722,10 +773,12 @@ pub fn get_exit_status() -> int {\n }\n \n #[cfg(target_os = \"macos\")]\n-unsafe fn load_argc_and_argv(argc: int, argv: **c_char) -> ~[~str] {\n+unsafe fn load_argc_and_argv(argc: int, argv: **c_char) -> ~[~[u8]] {\n+    use c_str::CString;\n+\n     let mut args = ~[];\n     for i in range(0u, argc as uint) {\n-        args.push(str::raw::from_c_str(*argv.offset(i as int)));\n+        args.push(CString::new(*argv.offset(i as int), false).as_bytes_no_nul().to_owned())\n     }\n     args\n }\n@@ -736,7 +789,7 @@ unsafe fn load_argc_and_argv(argc: int, argv: **c_char) -> ~[~str] {\n  * Returns a list of the command line arguments.\n  */\n #[cfg(target_os = \"macos\")]\n-fn real_args() -> ~[~str] {\n+fn real_args_as_bytes() -> ~[~[u8]] {\n     unsafe {\n         let (argc, argv) = (*_NSGetArgc() as int,\n                             *_NSGetArgv() as **c_char);\n@@ -747,7 +800,7 @@ fn real_args() -> ~[~str] {\n #[cfg(target_os = \"linux\")]\n #[cfg(target_os = \"android\")]\n #[cfg(target_os = \"freebsd\")]\n-fn real_args() -> ~[~str] {\n+fn real_args_as_bytes() -> ~[~[u8]] {\n     use rt;\n \n     match rt::args::clone() {\n@@ -756,6 +809,11 @@ fn real_args() -> ~[~str] {\n     }\n }\n \n+#[cfg(not(windows))]\n+fn real_args() -> ~[~str] {\n+    real_args_as_bytes().move_iter().map(|v| str::from_utf8_lossy(v).into_owned()).collect()\n+}\n+\n #[cfg(windows)]\n fn real_args() -> ~[~str] {\n     use vec;\n@@ -786,6 +844,11 @@ fn real_args() -> ~[~str] {\n     return args;\n }\n \n+#[cfg(windows)]\n+fn real_args_as_bytes() -> ~[~[u8]] {\n+    real_args().move_iter().map(|s| s.into_bytes()).collect()\n+}\n+\n type LPCWSTR = *u16;\n \n #[cfg(windows)]\n@@ -803,10 +866,19 @@ extern \"system\" {\n \n /// Returns the arguments which this program was started with (normally passed\n /// via the command line).\n+///\n+/// The arguments are interpreted as utf-8, with invalid bytes replaced with \\uFFFD.\n+/// See `str::from_utf8_lossy` for details.\n pub fn args() -> ~[~str] {\n     real_args()\n }\n \n+/// Returns the arguments which this program was started with (normally passed\n+/// via the command line) as byte vectors.\n+pub fn args_as_bytes() -> ~[~[u8]] {\n+    real_args_as_bytes()\n+}\n+\n #[cfg(target_os = \"macos\")]\n extern {\n     // These functions are in crt_externs.h."}, {"sha": "13496033fd0e539ddaec35b6cadba0dc5717aec4", "filename": "src/libstd/path/mod.rs", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/fba32ea79f1828ef441d91abca3635fad57f323d/src%2Flibstd%2Fpath%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fba32ea79f1828ef441d91abca3635fad57f323d/src%2Flibstd%2Fpath%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Fpath%2Fmod.rs?ref=fba32ea79f1828ef441d91abca3635fad57f323d", "patch": "@@ -578,8 +578,7 @@ impl BytesContainer for ~[u8] {\n impl BytesContainer for CString {\n     #[inline]\n     fn container_as_bytes<'a>(&'a self) -> &'a [u8] {\n-        let s = self.as_bytes();\n-        s.slice_to(s.len()-1)\n+        self.as_bytes_no_nul()\n     }\n }\n "}, {"sha": "c417ea375fd38186218b6d3e0740321db73e42b8", "filename": "src/libstd/rt/args.rs", "status": "modified", "additions": 23, "deletions": 21, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/fba32ea79f1828ef441d91abca3635fad57f323d/src%2Flibstd%2Frt%2Fargs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/fba32ea79f1828ef441d91abca3635fad57f323d/src%2Flibstd%2Frt%2Fargs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Frt%2Fargs.rs?ref=fba32ea79f1828ef441d91abca3635fad57f323d", "patch": "@@ -36,8 +36,8 @@ pub unsafe fn init(argc: int, argv: **u8) { realargs::init(argc, argv) }\n #[cfg(test)]      pub unsafe fn cleanup() { realargs::cleanup() }\n \n /// Take the global arguments from global storage.\n-#[cfg(not(test))] pub fn take() -> Option<~[~str]> { imp::take() }\n-#[cfg(test)]      pub fn take() -> Option<~[~str]> {\n+#[cfg(not(test))] pub fn take() -> Option<~[~[u8]]> { imp::take() }\n+#[cfg(test)]      pub fn take() -> Option<~[~[u8]]> {\n     match realargs::take() {\n         realstd::option::Some(a) => Some(a),\n         realstd::option::None => None,\n@@ -47,12 +47,12 @@ pub unsafe fn init(argc: int, argv: **u8) { realargs::init(argc, argv) }\n /// Give the global arguments to global storage.\n ///\n /// It is an error if the arguments already exist.\n-#[cfg(not(test))] pub fn put(args: ~[~str]) { imp::put(args) }\n-#[cfg(test)]      pub fn put(args: ~[~str]) { realargs::put(args) }\n+#[cfg(not(test))] pub fn put(args: ~[~[u8]]) { imp::put(args) }\n+#[cfg(test)]      pub fn put(args: ~[~[u8]]) { realargs::put(args) }\n \n /// Make a clone of the global arguments.\n-#[cfg(not(test))] pub fn clone() -> Option<~[~str]> { imp::clone() }\n-#[cfg(test)]      pub fn clone() -> Option<~[~str]> {\n+#[cfg(not(test))] pub fn clone() -> Option<~[~[u8]]> { imp::clone() }\n+#[cfg(test)]      pub fn clone() -> Option<~[~[u8]]> {\n     match realargs::clone() {\n         realstd::option::Some(a) => Some(a),\n         realstd::option::None => None,\n@@ -65,15 +65,12 @@ pub unsafe fn init(argc: int, argv: **u8) { realargs::init(argc, argv) }\n mod imp {\n     use cast;\n     use clone::Clone;\n-    #[cfg(not(test))] use libc;\n     use option::{Option, Some, None};\n     use ptr::RawPtr;\n     use iter::Iterator;\n-    #[cfg(not(test))] use str;\n     use unstable::finally::Finally;\n     use unstable::mutex::{Mutex, MUTEX_INIT};\n     use mem;\n-    #[cfg(not(test))] use vec;\n \n     static mut global_args_ptr: uint = 0;\n     static mut lock: Mutex = MUTEX_INIT;\n@@ -90,26 +87,26 @@ mod imp {\n         lock.destroy();\n     }\n \n-    pub fn take() -> Option<~[~str]> {\n+    pub fn take() -> Option<~[~[u8]]> {\n         with_lock(|| unsafe {\n             let ptr = get_global_ptr();\n             let val = mem::replace(&mut *ptr, None);\n-            val.as_ref().map(|s: &~~[~str]| (**s).clone())\n+            val.as_ref().map(|s: &~~[~[u8]]| (**s).clone())\n         })\n     }\n \n-    pub fn put(args: ~[~str]) {\n+    pub fn put(args: ~[~[u8]]) {\n         with_lock(|| unsafe {\n             let ptr = get_global_ptr();\n             rtassert!((*ptr).is_none());\n             (*ptr) = Some(~args.clone());\n         })\n     }\n \n-    pub fn clone() -> Option<~[~str]> {\n+    pub fn clone() -> Option<~[~[u8]]> {\n         with_lock(|| unsafe {\n             let ptr = get_global_ptr();\n-            (*ptr).as_ref().map(|s: &~~[~str]| (**s).clone())\n+            (*ptr).as_ref().map(|s: &~~[~[u8]]| (**s).clone())\n         })\n     }\n \n@@ -126,15 +123,20 @@ mod imp {\n         })\n     }\n \n-    fn get_global_ptr() -> *mut Option<~~[~str]> {\n+    fn get_global_ptr() -> *mut Option<~~[~[u8]]> {\n         unsafe { cast::transmute(&global_args_ptr) }\n     }\n \n     // Copied from `os`.\n     #[cfg(not(test))]\n-    unsafe fn load_argc_and_argv(argc: int, argv: **u8) -> ~[~str] {\n+    unsafe fn load_argc_and_argv(argc: int, argv: **u8) -> ~[~[u8]] {\n+        use c_str::CString;\n+        use {vec, libc};\n+        use vec::CloneableVector;\n+\n         vec::from_fn(argc as uint, |i| {\n-            str::raw::from_c_str(*(argv as **libc::c_char).offset(i as int))\n+            let cs = CString::new(*(argv as **libc::c_char).offset(i as int), false);\n+            cs.as_bytes_no_nul().to_owned()\n         })\n     }\n \n@@ -149,7 +151,7 @@ mod imp {\n             // Preserve the actual global state.\n             let saved_value = take();\n \n-            let expected = ~[~\"happy\", ~\"today?\"];\n+            let expected = ~[bytes!(\"happy\").to_owned(), bytes!(\"today?\").to_owned()];\n \n             put(expected.clone());\n             assert!(clone() == Some(expected.clone()));\n@@ -179,15 +181,15 @@ mod imp {\n     pub fn cleanup() {\n     }\n \n-    pub fn take() -> Option<~[~str]> {\n+    pub fn take() -> Option<~[~[u8]]> {\n         fail!()\n     }\n \n-    pub fn put(_args: ~[~str]) {\n+    pub fn put(_args: ~[~[u8]]) {\n         fail!()\n     }\n \n-    pub fn clone() -> Option<~[~str]> {\n+    pub fn clone() -> Option<~[~[u8]]> {\n         fail!()\n     }\n }"}]}