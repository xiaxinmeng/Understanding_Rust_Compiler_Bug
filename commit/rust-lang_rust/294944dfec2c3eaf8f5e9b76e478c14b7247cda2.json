{"sha": "294944dfec2c3eaf8f5e9b76e478c14b7247cda2", "node_id": "C_kwDOAAsO6NoAKDI5NDk0NGRmZWMyYzNlYWY4ZjVlOWI3NmU0NzhjMTRiNzI0N2NkYTI", "commit": {"author": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2022-12-13T01:39:08Z"}, "committer": {"name": "Esteban K\u00fcber", "email": "esteban@kuber.com.ar", "date": "2022-12-15T19:13:44Z"}, "message": "Point at method chains on `E0271` errors", "tree": {"sha": "8c5d0e9dabe7073db6b76e804ca4963d0b6b16dd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/8c5d0e9dabe7073db6b76e804ca4963d0b6b16dd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/294944dfec2c3eaf8f5e9b76e478c14b7247cda2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/294944dfec2c3eaf8f5e9b76e478c14b7247cda2", "html_url": "https://github.com/rust-lang/rust/commit/294944dfec2c3eaf8f5e9b76e478c14b7247cda2", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/294944dfec2c3eaf8f5e9b76e478c14b7247cda2/comments", "author": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "committer": {"login": "estebank", "id": 1606434, "node_id": "MDQ6VXNlcjE2MDY0MzQ=", "avatar_url": "https://avatars.githubusercontent.com/u/1606434?v=4", "gravatar_id": "", "url": "https://api.github.com/users/estebank", "html_url": "https://github.com/estebank", "followers_url": "https://api.github.com/users/estebank/followers", "following_url": "https://api.github.com/users/estebank/following{/other_user}", "gists_url": "https://api.github.com/users/estebank/gists{/gist_id}", "starred_url": "https://api.github.com/users/estebank/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/estebank/subscriptions", "organizations_url": "https://api.github.com/users/estebank/orgs", "repos_url": "https://api.github.com/users/estebank/repos", "events_url": "https://api.github.com/users/estebank/events{/privacy}", "received_events_url": "https://api.github.com/users/estebank/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "984eab57f708e62c09b3d708033fe620130b5f39", "url": "https://api.github.com/repos/rust-lang/rust/commits/984eab57f708e62c09b3d708033fe620130b5f39", "html_url": "https://github.com/rust-lang/rust/commit/984eab57f708e62c09b3d708033fe620130b5f39"}], "stats": {"total": 227, "additions": 138, "deletions": 89}, "files": [{"sha": "b18f675e562f6126050d6d6bb9bbba9193578499", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 119, "deletions": 89, "changes": 208, "blob_url": "https://github.com/rust-lang/rust/blob/294944dfec2c3eaf8f5e9b76e478c14b7247cda2/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/294944dfec2c3eaf8f5e9b76e478c14b7247cda2/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=294944dfec2c3eaf8f5e9b76e478c14b7247cda2", "patch": "@@ -352,6 +352,14 @@ pub trait TypeErrCtxtExt<'tcx> {\n         param_env: ty::ParamEnv<'tcx>,\n         err: &mut Diagnostic,\n     );\n+    fn probe_assoc_types_at_expr(\n+        &self,\n+        type_diffs: &[TypeError<'tcx>],\n+        span: Span,\n+        prev_ty: Ty<'tcx>,\n+        body_id: hir::HirId,\n+        param_env: ty::ParamEnv<'tcx>,\n+    ) -> Vec<Option<(Span, (DefId, Ty<'tcx>))>>;\n }\n \n fn predicate_constraint(generics: &hir::Generics<'_>, pred: ty::Predicate<'_>) -> (Span, String) {\n@@ -3152,23 +3160,37 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             if let ObligationCauseCode::ExprBindingObligation(def_id, _, _, idx) = parent_code.deref()\n                 && let predicates = self.tcx.predicates_of(def_id).instantiate_identity(self.tcx)\n                 && let Some(pred) = predicates.predicates.get(*idx)\n-                && let Ok(trait_pred) = pred.kind().try_map_bound(|pred| match pred {\n-                    ty::PredicateKind::Clause(ty::Clause::Trait(trait_pred)) => Ok(trait_pred),\n-                    _ => Err(()),\n-                })\n             {\n-                let mut c = CollectAllMismatches {\n-                    infcx: self.infcx,\n-                    param_env,\n-                    errors: vec![],\n-                };\n-                if let Ok(trait_predicate) = predicate.kind().try_map_bound(|pred| match pred {\n+                if let Ok(trait_pred) = pred.kind().try_map_bound(|pred| match pred {\n                     ty::PredicateKind::Clause(ty::Clause::Trait(trait_pred)) => Ok(trait_pred),\n                     _ => Err(()),\n-                }) {\n+                })\n+                    && let Ok(trait_predicate) = predicate.kind().try_map_bound(|pred| match pred {\n+                        ty::PredicateKind::Clause(ty::Clause::Trait(trait_pred)) => Ok(trait_pred),\n+                        _ => Err(()),\n+                    })\n+                {\n+                    let mut c = CollectAllMismatches {\n+                        infcx: self.infcx,\n+                        param_env,\n+                        errors: vec![],\n+                    };\n                     if let Ok(_) = c.relate(trait_pred, trait_predicate) {\n                         type_diffs = c.errors;\n                     }\n+                } else if let ty::PredicateKind::Clause(\n+                    ty::Clause::Projection(proj)\n+                ) = pred.kind().skip_binder()\n+                    && let ty::PredicateKind::Clause(\n+                        ty::Clause::Projection(projection)\n+                    ) = predicate.kind().skip_binder()\n+                {\n+                    type_diffs = vec![\n+                        Sorts(ty::error::ExpectedFound {\n+                            expected: self.tcx.mk_ty(ty::Alias(ty::Projection, proj.projection_ty)),\n+                            found: projection.term.ty().unwrap(),\n+                        }),\n+                    ];\n                 }\n             }\n             if let hir::ExprKind::Path(hir::QPath::Resolved(None, path)) = expr.kind\n@@ -3221,10 +3243,8 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n \n         let tcx = self.tcx;\n \n+        let mut print_root_expr = true;\n         let mut assocs = vec![];\n-        // We still want to point at the different methods even if there hasn't\n-        // been a change of assoc type.\n-        let mut call_spans = vec![];\n         let mut expr = expr;\n         let mut prev_ty = self.resolve_vars_if_possible(\n             typeck_results.expr_ty_adjusted_opt(expr).unwrap_or(tcx.ty_error()),\n@@ -3234,63 +3254,8 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             // vec![1, 2, 3].iter().map(mapper).sum<i32>()\n             //               ^^^^^^ ^^^^^^^^^^^\n             expr = rcvr_expr;\n-            let mut assocs_in_this_method = Vec::with_capacity(type_diffs.len());\n-            call_spans.push(span);\n-\n-            let ocx = ObligationCtxt::new_in_snapshot(self.infcx);\n-            for diff in &type_diffs {\n-                let Sorts(expected_found) = diff else { continue; };\n-                let ty::Alias(ty::Projection, proj) = expected_found.expected.kind() else { continue; };\n-\n-                let origin =\n-                    TypeVariableOrigin { kind: TypeVariableOriginKind::TypeInference, span };\n-                let trait_def_id = proj.trait_def_id(self.tcx);\n-                // Make `Self` be equivalent to the type of the call chain\n-                // expression we're looking at now, so that we can tell what\n-                // for example `Iterator::Item` is at this point in the chain.\n-                let substs = InternalSubsts::for_item(self.tcx, trait_def_id, |param, _| {\n-                    match param.kind {\n-                        ty::GenericParamDefKind::Type { .. } => {\n-                            if param.index == 0 {\n-                                return prev_ty.into();\n-                            }\n-                        }\n-                        ty::GenericParamDefKind::Lifetime\n-                        | ty::GenericParamDefKind::Const { .. } => {}\n-                    }\n-                    self.var_for_def(span, param)\n-                });\n-                // This will hold the resolved type of the associated type, if the\n-                // current expression implements the trait that associated type is\n-                // in. For example, this would be what `Iterator::Item` is here.\n-                let ty_var = self.infcx.next_ty_var(origin);\n-                // This corresponds to `<ExprTy as Iterator>::Item = _`.\n-                let projection = ty::Binder::dummy(ty::PredicateKind::Clause(\n-                    ty::Clause::Projection(ty::ProjectionPredicate {\n-                        projection_ty: tcx.mk_alias_ty(proj.def_id, substs),\n-                        term: ty_var.into(),\n-                    }),\n-                ));\n-                // Add `<ExprTy as Iterator>::Item = _` obligation.\n-                ocx.register_obligation(Obligation::misc(\n-                    self.tcx,\n-                    span,\n-                    expr.hir_id,\n-                    param_env,\n-                    projection,\n-                ));\n-                if ocx.select_where_possible().is_empty() {\n-                    // `ty_var` now holds the type that `Item` is for `ExprTy`.\n-                    let ty_var = self.resolve_vars_if_possible(ty_var);\n-                    assocs_in_this_method.push(Some((span, (proj.def_id, ty_var))));\n-                } else {\n-                    // `<ExprTy as Iterator>` didn't select, so likely we've\n-                    // reached the end of the iterator chain, like the originating\n-                    // `Vec<_>`.\n-                    // Keep the space consistent for later zipping.\n-                    assocs_in_this_method.push(None);\n-                }\n-            }\n+            let assocs_in_this_method =\n+                self.probe_assoc_types_at_expr(&type_diffs, span, prev_ty, expr.hir_id, param_env);\n             assocs.push(assocs_in_this_method);\n             prev_ty = self.resolve_vars_if_possible(\n                 typeck_results.expr_ty_adjusted_opt(expr).unwrap_or(tcx.ty_error()),\n@@ -3300,17 +3265,32 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 && let hir::Path { res: hir::def::Res::Local(hir_id), .. } = path\n                 && let Some(hir::Node::Pat(binding)) = self.tcx.hir().find(*hir_id)\n                 && let parent_hir_id = self.tcx.hir().get_parent_node(binding.hir_id)\n-                && let Some(hir::Node::Local(local)) = self.tcx.hir().find(parent_hir_id)\n-                && let Some(binding_expr) = local.init\n+                && let Some(parent) = self.tcx.hir().find(parent_hir_id)\n             {\n-                // We've reached the root of the method call chain and it is a\n-                // binding. Get the binding creation and try to continue the chain.\n-                expr = binding_expr;\n+                // We've reached the root of the method call chain...\n+                if let hir::Node::Local(local) = parent\n+                    && let Some(binding_expr) = local.init\n+                {\n+                    // ...and it is a binding. Get the binding creation and continue the chain.\n+                    expr = binding_expr;\n+                }\n+                if let hir::Node::Param(param) = parent {\n+                    // ...and it is a an fn argument.\n+                    let prev_ty = self.resolve_vars_if_possible(\n+                        typeck_results.node_type_opt(param.hir_id).unwrap_or(tcx.ty_error()),\n+                    );\n+                    let assocs_in_this_method = self.probe_assoc_types_at_expr(&type_diffs, param.ty_span, prev_ty, param.hir_id, param_env);\n+                    if assocs_in_this_method.iter().any(|a| a.is_some()) {\n+                        assocs.push(assocs_in_this_method);\n+                        print_root_expr = false;\n+                    }\n+                    break;\n+                }\n             }\n         }\n         // We want the type before deref coercions, otherwise we talk about `&[_]`\n         // instead of `Vec<_>`.\n-        if let Some(ty) = typeck_results.expr_ty_opt(expr) {\n+        if let Some(ty) = typeck_results.expr_ty_opt(expr) && print_root_expr {\n             let ty = with_forced_trimmed_paths!(self.ty_to_string(ty));\n             // Point at the root expression\n             // vec![1, 2, 3].iter().map(mapper).sum<i32>()\n@@ -3324,7 +3304,7 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n             let Some(prev_assoc_in_method) = assocs.peek() else {\n                 for entry in assocs_in_method {\n                     let Some((span, (assoc, ty))) = entry else { continue; };\n-                    if type_diffs.iter().any(|diff| {\n+                    if primary_spans.is_empty() || type_diffs.iter().any(|diff| {\n                         let Sorts(expected_found) = diff else { return false; };\n                         self.can_eq(param_env, expected_found.found, ty).is_ok()\n                     }) {\n@@ -3380,27 +3360,77 @@ impl<'tcx> TypeErrCtxtExt<'tcx> for TypeErrCtxt<'_, 'tcx> {\n                 }\n             }\n         }\n-        for span in call_spans {\n-            if span_labels.iter().find(|(s, _)| *s == span).is_none() {\n-                // Ensure we are showing the entire chain, even if the assoc types\n-                // haven't changed.\n-                span_labels.push((span, String::new()));\n-            }\n-        }\n         if !primary_spans.is_empty() {\n             let mut multi_span: MultiSpan = primary_spans.into();\n             for (span, label) in span_labels {\n                 multi_span.push_span_label(span, label);\n             }\n             err.span_note(\n                 multi_span,\n-                format!(\n-                    \"the method call chain might not have had the expected \\\n-                                     associated types\",\n-                ),\n+                format!(\"the method call chain might not have had the expected associated types\"),\n             );\n         }\n     }\n+\n+    fn probe_assoc_types_at_expr(\n+        &self,\n+        type_diffs: &[TypeError<'tcx>],\n+        span: Span,\n+        prev_ty: Ty<'tcx>,\n+        body_id: hir::HirId,\n+        param_env: ty::ParamEnv<'tcx>,\n+    ) -> Vec<Option<(Span, (DefId, Ty<'tcx>))>> {\n+        let ocx = ObligationCtxt::new_in_snapshot(self.infcx);\n+        let mut assocs_in_this_method = Vec::with_capacity(type_diffs.len());\n+        for diff in type_diffs {\n+            let Sorts(expected_found) = diff else { continue; };\n+            let ty::Alias(ty::Projection, proj) = expected_found.expected.kind() else { continue; };\n+\n+            let origin = TypeVariableOrigin { kind: TypeVariableOriginKind::TypeInference, span };\n+            let trait_def_id = proj.trait_def_id(self.tcx);\n+            // Make `Self` be equivalent to the type of the call chain\n+            // expression we're looking at now, so that we can tell what\n+            // for example `Iterator::Item` is at this point in the chain.\n+            let substs = InternalSubsts::for_item(self.tcx, trait_def_id, |param, _| {\n+                match param.kind {\n+                    ty::GenericParamDefKind::Type { .. } => {\n+                        if param.index == 0 {\n+                            return prev_ty.into();\n+                        }\n+                    }\n+                    ty::GenericParamDefKind::Lifetime | ty::GenericParamDefKind::Const { .. } => {}\n+                }\n+                self.var_for_def(span, param)\n+            });\n+            // This will hold the resolved type of the associated type, if the\n+            // current expression implements the trait that associated type is\n+            // in. For example, this would be what `Iterator::Item` is here.\n+            let ty_var = self.infcx.next_ty_var(origin);\n+            // This corresponds to `<ExprTy as Iterator>::Item = _`.\n+            let projection = ty::Binder::dummy(ty::PredicateKind::Clause(ty::Clause::Projection(\n+                ty::ProjectionPredicate {\n+                    projection_ty: self.tcx.mk_alias_ty(proj.def_id, substs),\n+                    term: ty_var.into(),\n+                },\n+            )));\n+            // Add `<ExprTy as Iterator>::Item = _` obligation.\n+            ocx.register_obligation(Obligation::misc(\n+                self.tcx, span, body_id, param_env, projection,\n+            ));\n+            if ocx.select_where_possible().is_empty() {\n+                // `ty_var` now holds the type that `Item` is for `ExprTy`.\n+                let ty_var = self.resolve_vars_if_possible(ty_var);\n+                assocs_in_this_method.push(Some((span, (proj.def_id, ty_var))));\n+            } else {\n+                // `<ExprTy as Iterator>` didn't select, so likely we've\n+                // reached the end of the iterator chain, like the originating\n+                // `Vec<_>`.\n+                // Keep the space consistent for later zipping.\n+                assocs_in_this_method.push(None);\n+            }\n+        }\n+        assocs_in_this_method\n+    }\n }\n \n /// Add a hint to add a missing borrow or remove an unnecessary one."}, {"sha": "99f0519b14cc40cff5048b71f9e2076b59146c2a", "filename": "src/test/ui/issues/issue-31173.stderr", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/294944dfec2c3eaf8f5e9b76e478c14b7247cda2/src%2Ftest%2Fui%2Fissues%2Fissue-31173.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/294944dfec2c3eaf8f5e9b76e478c14b7247cda2/src%2Ftest%2Fui%2Fissues%2Fissue-31173.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-31173.stderr?ref=294944dfec2c3eaf8f5e9b76e478c14b7247cda2", "patch": "@@ -6,6 +6,18 @@ LL |         .cloned()\n    |\n    = note: expected reference `&_`\n                    found type `u8`\n+note: the method call chain might not have had the expected associated types\n+  --> $DIR/issue-31173.rs:3:20\n+   |\n+LL |   pub fn get_tok(it: &mut IntoIter<u8>) {\n+   |                      ^^^^^^^^^^^^^^^^^ `Iterator::Item` is `u8` here\n+...\n+LL |           .take_while(|&x| {\n+   |  __________-\n+LL | |             found_e = true;\n+LL | |             false\n+LL | |         })\n+   | |__________- `Iterator::Item` remains `u8` here\n note: required by a bound in `cloned`\n   --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n "}, {"sha": "f33d33308d7568e6f478ec56647b0f574b512dea", "filename": "src/test/ui/issues/issue-33941.stderr", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/rust-lang/rust/blob/294944dfec2c3eaf8f5e9b76e478c14b7247cda2/src%2Ftest%2Fui%2Fissues%2Fissue-33941.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/294944dfec2c3eaf8f5e9b76e478c14b7247cda2/src%2Ftest%2Fui%2Fissues%2Fissue-33941.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-33941.stderr?ref=294944dfec2c3eaf8f5e9b76e478c14b7247cda2", "patch": "@@ -6,6 +6,13 @@ LL |     for _ in HashMap::new().iter().cloned() {}\n    |\n    = note: expected reference `&_`\n                   found tuple `(&_, &_)`\n+note: the method call chain might not have had the expected associated types\n+  --> $DIR/issue-33941.rs:6:29\n+   |\n+LL |     for _ in HashMap::new().iter().cloned() {}\n+   |              -------------- ^^^^^^ `Iterator::Item` is `(&_, &_)` here\n+   |              |\n+   |              this expression has type `HashMap<_, _>`\n note: required by a bound in `cloned`\n   --> $SRC_DIR/core/src/iter/traits/iterator.rs:LL:COL\n "}]}