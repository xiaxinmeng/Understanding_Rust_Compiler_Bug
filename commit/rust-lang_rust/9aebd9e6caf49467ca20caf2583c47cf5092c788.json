{"sha": "9aebd9e6caf49467ca20caf2583c47cf5092c788", "node_id": "MDY6Q29tbWl0NzI0NzEyOjlhZWJkOWU2Y2FmNDk0NjdjYTIwY2FmMjU4M2M0N2NmNTA5MmM3ODg=", "commit": {"author": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2018-11-12T15:59:47Z"}, "committer": {"name": "bors[bot]", "email": "bors[bot]@users.noreply.github.com", "date": "2018-11-12T15:59:47Z"}, "message": "Merge #226\n\n226: Validate byte literals and byte strings r=aochagavia a=aochagavia\n\n\n\nCo-authored-by: Adolfo Ochagav\u00eda <aochagavia92@gmail.com>", "tree": {"sha": "93c56d8301131a01de13b73010f615291eb1d6d4", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/93c56d8301131a01de13b73010f615291eb1d6d4"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/9aebd9e6caf49467ca20caf2583c47cf5092c788", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/9aebd9e6caf49467ca20caf2583c47cf5092c788", "html_url": "https://github.com/rust-lang/rust/commit/9aebd9e6caf49467ca20caf2583c47cf5092c788", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/9aebd9e6caf49467ca20caf2583c47cf5092c788/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "parents": [{"sha": "a4f7d7a7cd85a5b9b64a935dd84ad493b6860236", "url": "https://api.github.com/repos/rust-lang/rust/commits/a4f7d7a7cd85a5b9b64a935dd84ad493b6860236", "html_url": "https://github.com/rust-lang/rust/commit/a4f7d7a7cd85a5b9b64a935dd84ad493b6860236"}, {"sha": "c96bfe7e2d4465653fe6b0eff053f0dfb48313fa", "url": "https://api.github.com/repos/rust-lang/rust/commits/c96bfe7e2d4465653fe6b0eff053f0dfb48313fa", "html_url": "https://github.com/rust-lang/rust/commit/c96bfe7e2d4465653fe6b0eff053f0dfb48313fa"}], "stats": {"total": 1648, "additions": 1141, "deletions": 507}, "files": [{"sha": "bf056131efc4409ffc3880ba1e923f3b5caba1c3", "filename": "crates/ra_syntax/src/ast/generated.rs", "status": "modified", "additions": 74, "deletions": 0, "changes": 74, "blob_url": "https://github.com/rust-lang/rust/blob/9aebd9e6caf49467ca20caf2583c47cf5092c788/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aebd9e6caf49467ca20caf2583c47cf5092c788/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fgenerated.rs?ref=9aebd9e6caf49467ca20caf2583c47cf5092c788", "patch": "@@ -372,6 +372,80 @@ impl<R: TreeRoot<RaTypes>> BreakExprNode<R> {\n \n impl<'a> BreakExpr<'a> {}\n \n+// Byte\n+#[derive(Debug, Clone, Copy,)]\n+pub struct ByteNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n+    pub(crate) syntax: SyntaxNode<R>,\n+}\n+pub type Byte<'a> = ByteNode<RefRoot<'a>>;\n+\n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<ByteNode<R1>> for ByteNode<R2> {\n+    fn eq(&self, other: &ByteNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for ByteNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for ByteNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n+impl<'a> AstNode<'a> for Byte<'a> {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n+        match syntax.kind() {\n+            BYTE => Some(Byte { syntax }),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }\n+}\n+\n+impl<R: TreeRoot<RaTypes>> ByteNode<R> {\n+    pub fn borrowed(&self) -> Byte {\n+        ByteNode { syntax: self.syntax.borrowed() }\n+    }\n+    pub fn owned(&self) -> ByteNode {\n+        ByteNode { syntax: self.syntax.owned() }\n+    }\n+}\n+\n+\n+impl<'a> Byte<'a> {}\n+\n+// ByteString\n+#[derive(Debug, Clone, Copy,)]\n+pub struct ByteStringNode<R: TreeRoot<RaTypes> = OwnedRoot> {\n+    pub(crate) syntax: SyntaxNode<R>,\n+}\n+pub type ByteString<'a> = ByteStringNode<RefRoot<'a>>;\n+\n+impl<R1: TreeRoot<RaTypes>, R2: TreeRoot<RaTypes>> PartialEq<ByteStringNode<R1>> for ByteStringNode<R2> {\n+    fn eq(&self, other: &ByteStringNode<R1>) -> bool { self.syntax == other.syntax }\n+}\n+impl<R: TreeRoot<RaTypes>> Eq for ByteStringNode<R> {}\n+impl<R: TreeRoot<RaTypes>> Hash for ByteStringNode<R> {\n+    fn hash<H: Hasher>(&self, state: &mut H) { self.syntax.hash(state) }\n+}\n+\n+impl<'a> AstNode<'a> for ByteString<'a> {\n+    fn cast(syntax: SyntaxNodeRef<'a>) -> Option<Self> {\n+        match syntax.kind() {\n+            BYTE_STRING => Some(ByteString { syntax }),\n+            _ => None,\n+        }\n+    }\n+    fn syntax(self) -> SyntaxNodeRef<'a> { self.syntax }\n+}\n+\n+impl<R: TreeRoot<RaTypes>> ByteStringNode<R> {\n+    pub fn borrowed(&self) -> ByteString {\n+        ByteStringNode { syntax: self.syntax.borrowed() }\n+    }\n+    pub fn owned(&self) -> ByteStringNode {\n+        ByteStringNode { syntax: self.syntax.owned() }\n+    }\n+}\n+\n+\n+impl<'a> ByteString<'a> {}\n+\n // CallExpr\n #[derive(Debug, Clone, Copy,)]\n pub struct CallExprNode<R: TreeRoot<RaTypes> = OwnedRoot> {"}, {"sha": "7077e349223006fb9d3f98d1bf30126a24716412", "filename": "crates/ra_syntax/src/ast/mod.rs", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/9aebd9e6caf49467ca20caf2583c47cf5092c788/crates%2Fra_syntax%2Fsrc%2Fast%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aebd9e6caf49467ca20caf2583c47cf5092c788/crates%2Fra_syntax%2Fsrc%2Fast%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fast%2Fmod.rs?ref=9aebd9e6caf49467ca20caf2583c47cf5092c788", "patch": "@@ -134,6 +134,18 @@ impl<'a> Char<'a> {\n     }\n }\n \n+impl<'a> Byte<'a> {\n+    pub fn text(&self) -> &SmolStr {\n+        &self.syntax().leaf_text().unwrap()\n+    }\n+}\n+\n+impl<'a> ByteString<'a> {\n+    pub fn text(&self) -> &SmolStr {\n+        &self.syntax().leaf_text().unwrap()\n+    }\n+}\n+\n impl<'a> String<'a> {\n     pub fn text(&self) -> &SmolStr {\n         &self.syntax().leaf_text().unwrap()"}, {"sha": "53cd2118f3d4478ff9fecee9da5241745165230c", "filename": "crates/ra_syntax/src/grammar.ron", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/9aebd9e6caf49467ca20caf2583c47cf5092c788/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron", "raw_url": "https://github.com/rust-lang/rust/raw/9aebd9e6caf49467ca20caf2583c47cf5092c788/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fgrammar.ron?ref=9aebd9e6caf49467ca20caf2583c47cf5092c788", "patch": "@@ -412,6 +412,8 @@ Grammar(\n         \"RangeExpr\": (),\n         \"BinExpr\": (),\n         \"String\": (),\n+        \"Byte\": (),\n+        \"ByteString\": (),\n         \"Char\": (),\n         \"Literal\": (),\n "}, {"sha": "d613bb0429a9ce11cfa3da3db99c19c92440e3ae", "filename": "crates/ra_syntax/src/string_lexing.rs", "status": "removed", "additions": 0, "deletions": 414, "changes": 414, "blob_url": "https://github.com/rust-lang/rust/blob/a4f7d7a7cd85a5b9b64a935dd84ad493b6860236/crates%2Fra_syntax%2Fsrc%2Fstring_lexing.rs", "raw_url": "https://github.com/rust-lang/rust/raw/a4f7d7a7cd85a5b9b64a935dd84ad493b6860236/crates%2Fra_syntax%2Fsrc%2Fstring_lexing.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fstring_lexing.rs?ref=a4f7d7a7cd85a5b9b64a935dd84ad493b6860236", "patch": "@@ -1,414 +0,0 @@\n-use self::CharComponentKind::*;\n-use rowan::{TextRange, TextUnit};\n-\n-pub fn parse_string_literal(src: &str) -> StringComponentIterator {\n-    StringComponentIterator {\n-        parser: Parser::new(src),\n-        has_closing_quote: false,\n-    }\n-}\n-\n-#[derive(Debug, Eq, PartialEq, Clone)]\n-pub struct StringComponent {\n-    pub range: TextRange,\n-    pub kind: StringComponentKind,\n-}\n-\n-impl StringComponent {\n-    fn new(range: TextRange, kind: StringComponentKind) -> StringComponent {\n-        StringComponent { range, kind }\n-    }\n-}\n-\n-#[derive(Debug, Eq, PartialEq, Clone)]\n-pub enum StringComponentKind {\n-    IgnoreNewline,\n-    Char(CharComponentKind),\n-}\n-\n-pub struct StringComponentIterator<'a> {\n-    parser: Parser<'a>,\n-    pub has_closing_quote: bool,\n-}\n-\n-impl<'a> Iterator for StringComponentIterator<'a> {\n-    type Item = StringComponent;\n-    fn next(&mut self) -> Option<StringComponent> {\n-        if self.parser.pos == 0 {\n-            assert!(\n-                self.parser.advance() == '\"',\n-                \"string literal should start with double quotes\"\n-            );\n-        }\n-\n-        if let Some(component) = self.parser.parse_string_component() {\n-            return Some(component);\n-        }\n-\n-        // We get here when there are no char components left to parse\n-        if self.parser.peek() == Some('\"') {\n-            self.parser.advance();\n-            self.has_closing_quote = true;\n-        }\n-\n-        assert!(\n-            self.parser.peek() == None,\n-            \"string literal should leave no unparsed input: src = {}, pos = {}, length = {}\",\n-            self.parser.src,\n-            self.parser.pos,\n-            self.parser.src.len()\n-        );\n-\n-        None\n-    }\n-}\n-\n-pub fn parse_char_literal(src: &str) -> CharComponentIterator {\n-    CharComponentIterator {\n-        parser: Parser::new(src),\n-        has_closing_quote: false,\n-    }\n-}\n-\n-#[derive(Debug, Eq, PartialEq, Clone)]\n-pub struct CharComponent {\n-    pub range: TextRange,\n-    pub kind: CharComponentKind,\n-}\n-\n-impl CharComponent {\n-    fn new(range: TextRange, kind: CharComponentKind) -> CharComponent {\n-        CharComponent { range, kind }\n-    }\n-}\n-\n-#[derive(Debug, Eq, PartialEq, Clone)]\n-pub enum CharComponentKind {\n-    CodePoint,\n-    AsciiEscape,\n-    AsciiCodeEscape,\n-    UnicodeEscape,\n-}\n-\n-pub struct CharComponentIterator<'a> {\n-    parser: Parser<'a>,\n-    pub has_closing_quote: bool,\n-}\n-\n-impl<'a> Iterator for CharComponentIterator<'a> {\n-    type Item = CharComponent;\n-    fn next(&mut self) -> Option<CharComponent> {\n-        if self.parser.pos == 0 {\n-            assert!(\n-                self.parser.advance() == '\\'',\n-                \"char literal should start with a quote\"\n-            );\n-        }\n-\n-        if let Some(component) = self.parser.parse_char_component() {\n-            return Some(component);\n-        }\n-\n-        // We get here when there are no char components left to parse\n-        if self.parser.peek() == Some('\\'') {\n-            self.parser.advance();\n-            self.has_closing_quote = true;\n-        }\n-\n-        assert!(\n-            self.parser.peek() == None,\n-            \"char literal should leave no unparsed input: src = {}, pos = {}, length = {}\",\n-            self.parser.src,\n-            self.parser.pos,\n-            self.parser.src.len()\n-        );\n-\n-        None\n-    }\n-}\n-\n-pub struct Parser<'a> {\n-    src: &'a str,\n-    pos: usize,\n-}\n-\n-impl<'a> Parser<'a> {\n-    pub fn new(src: &'a str) -> Parser<'a> {\n-        Parser { src, pos: 0 }\n-    }\n-\n-    // Utility methods\n-\n-    pub fn peek(&self) -> Option<char> {\n-        if self.pos == self.src.len() {\n-            return None;\n-        }\n-\n-        self.src[self.pos..].chars().next()\n-    }\n-\n-    pub fn advance(&mut self) -> char {\n-        let next = self\n-            .peek()\n-            .expect(\"cannot advance if end of input is reached\");\n-        self.pos += next.len_utf8();\n-        next\n-    }\n-\n-    pub fn skip_whitespace(&mut self) {\n-        while self.peek().map(|c| c.is_whitespace()) == Some(true) {\n-            self.advance();\n-        }\n-    }\n-\n-    pub fn get_pos(&self) -> TextUnit {\n-        (self.pos as u32).into()\n-    }\n-\n-    // Char parsing methods\n-\n-    fn parse_unicode_escape(&mut self, start: TextUnit) -> CharComponent {\n-        match self.peek() {\n-            Some('{') => {\n-                self.advance();\n-\n-                // Parse anything until we reach `}`\n-                while let Some(next) = self.peek() {\n-                    self.advance();\n-                    if next == '}' {\n-                        break;\n-                    }\n-                }\n-\n-                let end = self.get_pos();\n-                CharComponent::new(TextRange::from_to(start, end), UnicodeEscape)\n-            }\n-            Some(_) | None => {\n-                let end = self.get_pos();\n-                CharComponent::new(TextRange::from_to(start, end), UnicodeEscape)\n-            }\n-        }\n-    }\n-\n-    fn parse_ascii_code_escape(&mut self, start: TextUnit) -> CharComponent {\n-        let code_start = self.get_pos();\n-        while let Some(next) = self.peek() {\n-            if next == '\\'' || (self.get_pos() - code_start == 2.into()) {\n-                break;\n-            }\n-\n-            self.advance();\n-        }\n-\n-        let end = self.get_pos();\n-        CharComponent::new(TextRange::from_to(start, end), AsciiCodeEscape)\n-    }\n-\n-    fn parse_escape(&mut self, start: TextUnit) -> CharComponent {\n-        if self.peek().is_none() {\n-            return CharComponent::new(TextRange::from_to(start, start), AsciiEscape);\n-        }\n-\n-        let next = self.advance();\n-        let end = self.get_pos();\n-        let range = TextRange::from_to(start, end);\n-        match next {\n-            'x' => self.parse_ascii_code_escape(start),\n-            'u' => self.parse_unicode_escape(start),\n-            _ => CharComponent::new(range, AsciiEscape),\n-        }\n-    }\n-\n-    pub fn parse_char_component(&mut self) -> Option<CharComponent> {\n-        let next = self.peek()?;\n-\n-        // Ignore character close\n-        if next == '\\'' {\n-            return None;\n-        }\n-\n-        let start = self.get_pos();\n-        self.advance();\n-\n-        if next == '\\\\' {\n-            Some(self.parse_escape(start))\n-        } else {\n-            let end = self.get_pos();\n-            Some(CharComponent::new(\n-                TextRange::from_to(start, end),\n-                CodePoint,\n-            ))\n-        }\n-    }\n-\n-    pub fn parse_ignore_newline(&mut self, start: TextUnit) -> Option<StringComponent> {\n-        // In string literals, when a `\\` occurs immediately before the newline, the `\\`,\n-        // the newline, and all whitespace at the beginning of the next line are ignored\n-        match self.peek() {\n-            Some('\\n') | Some('\\r') => {\n-                self.skip_whitespace();\n-                Some(StringComponent::new(\n-                    TextRange::from_to(start, self.get_pos()),\n-                    StringComponentKind::IgnoreNewline,\n-                ))\n-            }\n-            _ => None,\n-        }\n-    }\n-\n-    pub fn parse_string_component(&mut self) -> Option<StringComponent> {\n-        let next = self.peek()?;\n-\n-        // Ignore string close\n-        if next == '\"' {\n-            return None;\n-        }\n-\n-        let start = self.get_pos();\n-        self.advance();\n-\n-        if next == '\\\\' {\n-            // Strings can use `\\` to ignore newlines, so we first try to parse one of those\n-            // before falling back to parsing char escapes\n-            self.parse_ignore_newline(start).or_else(|| {\n-                let char_component = self.parse_escape(start);\n-                Some(StringComponent::new(\n-                    char_component.range,\n-                    StringComponentKind::Char(char_component.kind),\n-                ))\n-            })\n-        } else {\n-            let end = self.get_pos();\n-            Some(StringComponent::new(\n-                TextRange::from_to(start, end),\n-                StringComponentKind::Char(CodePoint),\n-            ))\n-        }\n-    }\n-}\n-\n-#[cfg(test)]\n-mod tests {\n-    use super::*;\n-\n-    fn parse(src: &str) -> (bool, Vec<CharComponent>) {\n-        let component_iterator = &mut super::parse_char_literal(src);\n-        let components: Vec<_> = component_iterator.collect();\n-        (component_iterator.has_closing_quote, components)\n-    }\n-\n-    fn unclosed_char_component(src: &str) -> CharComponent {\n-        let (has_closing_quote, components) = parse(src);\n-        assert!(!has_closing_quote, \"char should not have closing quote\");\n-        assert!(components.len() == 1);\n-        components[0].clone()\n-    }\n-\n-    fn closed_char_component(src: &str) -> CharComponent {\n-        let (has_closing_quote, components) = parse(src);\n-        assert!(has_closing_quote, \"char should have closing quote\");\n-        assert!(\n-            components.len() == 1,\n-            \"Literal: {}\\nComponents: {:#?}\",\n-            src,\n-            components\n-        );\n-        components[0].clone()\n-    }\n-\n-    fn closed_char_components(src: &str) -> Vec<CharComponent> {\n-        let (has_closing_quote, components) = parse(src);\n-        assert!(has_closing_quote, \"char should have closing quote\");\n-        components\n-    }\n-\n-    fn range_closed(src: &str) -> TextRange {\n-        TextRange::from_to(1.into(), (src.len() as u32 - 1).into())\n-    }\n-\n-    fn range_unclosed(src: &str) -> TextRange {\n-        TextRange::from_to(1.into(), (src.len() as u32).into())\n-    }\n-\n-    #[test]\n-    fn test_unicode_escapes() {\n-        let unicode_escapes = &[r\"{DEAD}\", \"{BEEF}\", \"{FF}\", \"{}\", \"\"];\n-        for escape in unicode_escapes {\n-            let escape_sequence = format!(r\"'\\u{}'\", escape);\n-            let component = closed_char_component(&escape_sequence);\n-            let expected_range = range_closed(&escape_sequence);\n-            assert_eq!(component.kind, CharComponentKind::UnicodeEscape);\n-            assert_eq!(component.range, expected_range);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_unicode_escapes_unclosed() {\n-        let unicode_escapes = &[\"{DEAD\", \"{BEEF\", \"{FF\"];\n-        for escape in unicode_escapes {\n-            let escape_sequence = format!(r\"'\\u{}'\", escape);\n-            let component = unclosed_char_component(&escape_sequence);\n-            let expected_range = range_unclosed(&escape_sequence);\n-            assert_eq!(component.kind, CharComponentKind::UnicodeEscape);\n-            assert_eq!(component.range, expected_range);\n-        }\n-    }\n-\n-    #[test]\n-    fn test_empty_char() {\n-        let (has_closing_quote, components) = parse(\"''\");\n-        assert!(has_closing_quote, \"char should have closing quote\");\n-        assert!(components.len() == 0);\n-    }\n-\n-    #[test]\n-    fn test_unclosed_char() {\n-        let component = unclosed_char_component(\"'a\");\n-        assert!(component.kind == CodePoint);\n-        assert!(component.range == TextRange::from_to(1.into(), 2.into()));\n-    }\n-\n-    #[test]\n-    fn test_digit_escapes() {\n-        let literals = &[r\"\", r\"5\", r\"55\"];\n-\n-        for literal in literals {\n-            let lit_text = format!(r\"'\\x{}'\", literal);\n-            let component = closed_char_component(&lit_text);\n-            assert!(component.kind == CharComponentKind::AsciiCodeEscape);\n-            assert!(component.range == range_closed(&lit_text));\n-        }\n-\n-        // More than 2 digits starts a new codepoint\n-        let components = closed_char_components(r\"'\\x555'\");\n-        assert!(components.len() == 2);\n-        assert!(components[1].kind == CharComponentKind::CodePoint);\n-    }\n-\n-    #[test]\n-    fn test_ascii_escapes() {\n-        let literals = &[\n-            r\"\\'\", \"\\\\\\\"\", // equivalent to \\\"\n-            r\"\\n\", r\"\\r\", r\"\\t\", r\"\\\\\", r\"\\0\",\n-        ];\n-\n-        for literal in literals {\n-            let lit_text = format!(\"'{}'\", literal);\n-            let component = closed_char_component(&lit_text);\n-            assert!(component.kind == CharComponentKind::AsciiEscape);\n-            assert!(component.range == range_closed(&lit_text));\n-        }\n-    }\n-\n-    #[test]\n-    fn test_no_escapes() {\n-        let literals = &['\"', 'n', 'r', 't', '0', 'x', 'u'];\n-\n-        for &literal in literals {\n-            let lit_text = format!(\"'{}'\", literal);\n-            let component = closed_char_component(&lit_text);\n-            assert!(component.kind == CharComponentKind::CodePoint);\n-            assert!(component.range == range_closed(&lit_text));\n-        }\n-    }\n-}"}, {"sha": "24424349caf11b26963e0455483fc8baac673761", "filename": "crates/ra_syntax/src/string_lexing/byte.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/9aebd9e6caf49467ca20caf2583c47cf5092c788/crates%2Fra_syntax%2Fsrc%2Fstring_lexing%2Fbyte.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aebd9e6caf49467ca20caf2583c47cf5092c788/crates%2Fra_syntax%2Fsrc%2Fstring_lexing%2Fbyte.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fstring_lexing%2Fbyte.rs?ref=9aebd9e6caf49467ca20caf2583c47cf5092c788", "patch": "@@ -0,0 +1,51 @@\n+use super::parser::Parser;\n+use super::CharComponent;\n+\n+pub fn parse_byte_literal(src: &str) -> ByteComponentIterator {\n+    ByteComponentIterator {\n+        parser: Parser::new(src),\n+        has_closing_quote: false,\n+    }\n+}\n+\n+pub struct ByteComponentIterator<'a> {\n+    parser: Parser<'a>,\n+    pub has_closing_quote: bool,\n+}\n+\n+impl<'a> Iterator for ByteComponentIterator<'a> {\n+    type Item = CharComponent;\n+    fn next(&mut self) -> Option<CharComponent> {\n+        if self.parser.pos == 0 {\n+            assert!(\n+                self.parser.advance() == 'b',\n+                \"Byte literal should start with a `b`\"\n+            );\n+\n+            assert!(\n+                self.parser.advance() == '\\'',\n+                \"Byte literal should start with a `b`, followed by a quote\"\n+            );\n+        }\n+\n+        if let Some(component) = self.parser.parse_char_component() {\n+            return Some(component);\n+        }\n+\n+        // We get here when there are no char components left to parse\n+        if self.parser.peek() == Some('\\'') {\n+            self.parser.advance();\n+            self.has_closing_quote = true;\n+        }\n+\n+        assert!(\n+            self.parser.peek() == None,\n+            \"byte literal should leave no unparsed input: src = {}, pos = {}, length = {}\",\n+            self.parser.src,\n+            self.parser.pos,\n+            self.parser.src.len()\n+        );\n+\n+        None\n+    }\n+}"}, {"sha": "5b6dda7605818704d3e7275e771b0e2ba3e92b28", "filename": "crates/ra_syntax/src/string_lexing/byte_string.rs", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/9aebd9e6caf49467ca20caf2583c47cf5092c788/crates%2Fra_syntax%2Fsrc%2Fstring_lexing%2Fbyte_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aebd9e6caf49467ca20caf2583c47cf5092c788/crates%2Fra_syntax%2Fsrc%2Fstring_lexing%2Fbyte_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fstring_lexing%2Fbyte_string.rs?ref=9aebd9e6caf49467ca20caf2583c47cf5092c788", "patch": "@@ -0,0 +1,51 @@\n+use super::parser::Parser;\n+use super::StringComponent;\n+\n+pub fn parse_byte_string_literal(src: &str) -> ByteStringComponentIterator {\n+    ByteStringComponentIterator {\n+        parser: Parser::new(src),\n+        has_closing_quote: false,\n+    }\n+}\n+\n+pub struct ByteStringComponentIterator<'a> {\n+    parser: Parser<'a>,\n+    pub has_closing_quote: bool,\n+}\n+\n+impl<'a> Iterator for ByteStringComponentIterator<'a> {\n+    type Item = StringComponent;\n+    fn next(&mut self) -> Option<StringComponent> {\n+        if self.parser.pos == 0 {\n+            assert!(\n+                self.parser.advance() == 'b',\n+                \"byte string literal should start with a `b`\"\n+            );\n+\n+            assert!(\n+                self.parser.advance() == '\"',\n+                \"byte string literal should start with a `b`, followed by double quotes\"\n+            );\n+        }\n+\n+        if let Some(component) = self.parser.parse_string_component() {\n+            return Some(component);\n+        }\n+\n+        // We get here when there are no char components left to parse\n+        if self.parser.peek() == Some('\"') {\n+            self.parser.advance();\n+            self.has_closing_quote = true;\n+        }\n+\n+        assert!(\n+            self.parser.peek() == None,\n+            \"byte string literal should leave no unparsed input: src = {}, pos = {}, length = {}\",\n+            self.parser.src,\n+            self.parser.pos,\n+            self.parser.src.len()\n+        );\n+\n+        None\n+    }\n+}"}, {"sha": "885c03b14a9faf37e27656f2e0a665c822640319", "filename": "crates/ra_syntax/src/string_lexing/char.rs", "status": "added", "additions": 176, "deletions": 0, "changes": 176, "blob_url": "https://github.com/rust-lang/rust/blob/9aebd9e6caf49467ca20caf2583c47cf5092c788/crates%2Fra_syntax%2Fsrc%2Fstring_lexing%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aebd9e6caf49467ca20caf2583c47cf5092c788/crates%2Fra_syntax%2Fsrc%2Fstring_lexing%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fstring_lexing%2Fchar.rs?ref=9aebd9e6caf49467ca20caf2583c47cf5092c788", "patch": "@@ -0,0 +1,176 @@\n+use super::parser::Parser;\n+use super::CharComponent;\n+\n+pub fn parse_char_literal(src: &str) -> CharComponentIterator {\n+    CharComponentIterator {\n+        parser: Parser::new(src),\n+        has_closing_quote: false,\n+    }\n+}\n+\n+pub struct CharComponentIterator<'a> {\n+    parser: Parser<'a>,\n+    pub has_closing_quote: bool,\n+}\n+\n+impl<'a> Iterator for CharComponentIterator<'a> {\n+    type Item = CharComponent;\n+    fn next(&mut self) -> Option<CharComponent> {\n+        if self.parser.pos == 0 {\n+            assert!(\n+                self.parser.advance() == '\\'',\n+                \"char literal should start with a quote\"\n+            );\n+        }\n+\n+        if let Some(component) = self.parser.parse_char_component() {\n+            return Some(component);\n+        }\n+\n+        // We get here when there are no char components left to parse\n+        if self.parser.peek() == Some('\\'') {\n+            self.parser.advance();\n+            self.has_closing_quote = true;\n+        }\n+\n+        assert!(\n+            self.parser.peek() == None,\n+            \"char literal should leave no unparsed input: src = {}, pos = {}, length = {}\",\n+            self.parser.src,\n+            self.parser.pos,\n+            self.parser.src.len()\n+        );\n+\n+        None\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use rowan::TextRange;\n+    use crate::string_lexing::{\n+        CharComponent,\n+        CharComponentKind::*,\n+};\n+\n+    fn parse(src: &str) -> (bool, Vec<CharComponent>) {\n+        let component_iterator = &mut super::parse_char_literal(src);\n+        let components: Vec<_> = component_iterator.collect();\n+        (component_iterator.has_closing_quote, components)\n+    }\n+\n+    fn unclosed_char_component(src: &str) -> CharComponent {\n+        let (has_closing_quote, components) = parse(src);\n+        assert!(!has_closing_quote, \"char should not have closing quote\");\n+        assert!(components.len() == 1);\n+        components[0].clone()\n+    }\n+\n+    fn closed_char_component(src: &str) -> CharComponent {\n+        let (has_closing_quote, components) = parse(src);\n+        assert!(has_closing_quote, \"char should have closing quote\");\n+        assert!(\n+            components.len() == 1,\n+            \"Literal: {}\\nComponents: {:#?}\",\n+            src,\n+            components\n+        );\n+        components[0].clone()\n+    }\n+\n+    fn closed_char_components(src: &str) -> Vec<CharComponent> {\n+        let (has_closing_quote, components) = parse(src);\n+        assert!(has_closing_quote, \"char should have closing quote\");\n+        components\n+    }\n+\n+    fn range_closed(src: &str) -> TextRange {\n+        TextRange::from_to(1.into(), (src.len() as u32 - 1).into())\n+    }\n+\n+    fn range_unclosed(src: &str) -> TextRange {\n+        TextRange::from_to(1.into(), (src.len() as u32).into())\n+    }\n+\n+    #[test]\n+    fn test_unicode_escapes() {\n+        let unicode_escapes = &[r\"{DEAD}\", \"{BEEF}\", \"{FF}\", \"{}\", \"\"];\n+        for escape in unicode_escapes {\n+            let escape_sequence = format!(r\"'\\u{}'\", escape);\n+            let component = closed_char_component(&escape_sequence);\n+            let expected_range = range_closed(&escape_sequence);\n+            assert_eq!(component.kind, UnicodeEscape);\n+            assert_eq!(component.range, expected_range);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_unicode_escapes_unclosed() {\n+        let unicode_escapes = &[\"{DEAD\", \"{BEEF\", \"{FF\"];\n+        for escape in unicode_escapes {\n+            let escape_sequence = format!(r\"'\\u{}'\", escape);\n+            let component = unclosed_char_component(&escape_sequence);\n+            let expected_range = range_unclosed(&escape_sequence);\n+            assert_eq!(component.kind, UnicodeEscape);\n+            assert_eq!(component.range, expected_range);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_empty_char() {\n+        let (has_closing_quote, components) = parse(\"''\");\n+        assert!(has_closing_quote, \"char should have closing quote\");\n+        assert!(components.len() == 0);\n+    }\n+\n+    #[test]\n+    fn test_unclosed_char() {\n+        let component = unclosed_char_component(\"'a\");\n+        assert!(component.kind == CodePoint);\n+        assert!(component.range == TextRange::from_to(1.into(), 2.into()));\n+    }\n+\n+    #[test]\n+    fn test_digit_escapes() {\n+        let literals = &[r\"\", r\"5\", r\"55\"];\n+\n+        for literal in literals {\n+            let lit_text = format!(r\"'\\x{}'\", literal);\n+            let component = closed_char_component(&lit_text);\n+            assert!(component.kind == AsciiCodeEscape);\n+            assert!(component.range == range_closed(&lit_text));\n+        }\n+\n+        // More than 2 digits starts a new codepoint\n+        let components = closed_char_components(r\"'\\x555'\");\n+        assert!(components.len() == 2);\n+        assert!(components[1].kind == CodePoint);\n+    }\n+\n+    #[test]\n+    fn test_ascii_escapes() {\n+        let literals = &[\n+            r\"\\'\", \"\\\\\\\"\", // equivalent to \\\"\n+            r\"\\n\", r\"\\r\", r\"\\t\", r\"\\\\\", r\"\\0\",\n+        ];\n+\n+        for literal in literals {\n+            let lit_text = format!(\"'{}'\", literal);\n+            let component = closed_char_component(&lit_text);\n+            assert!(component.kind == AsciiEscape);\n+            assert!(component.range == range_closed(&lit_text));\n+        }\n+    }\n+\n+    #[test]\n+    fn test_no_escapes() {\n+        let literals = &['\"', 'n', 'r', 't', '0', 'x', 'u'];\n+\n+        for &literal in literals {\n+            let lit_text = format!(\"'{}'\", literal);\n+            let component = closed_char_component(&lit_text);\n+            assert!(component.kind == CodePoint);\n+            assert!(component.range == range_closed(&lit_text));\n+        }\n+    }\n+}"}, {"sha": "94853331f2e89417b4767bbfddaec0b104cd01cf", "filename": "crates/ra_syntax/src/string_lexing/mod.rs", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/9aebd9e6caf49467ca20caf2583c47cf5092c788/crates%2Fra_syntax%2Fsrc%2Fstring_lexing%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aebd9e6caf49467ca20caf2583c47cf5092c788/crates%2Fra_syntax%2Fsrc%2Fstring_lexing%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fstring_lexing%2Fmod.rs?ref=9aebd9e6caf49467ca20caf2583c47cf5092c788", "patch": "@@ -0,0 +1,13 @@\n+mod parser;\n+mod byte;\n+mod byte_string;\n+mod char;\n+mod string;\n+\n+pub use self::{\n+    byte::parse_byte_literal,\n+    byte_string::parse_byte_string_literal,\n+    char::parse_char_literal,\n+    parser::{CharComponent, CharComponentKind, StringComponent, StringComponentKind},\n+    string::parse_string_literal,\n+};"}, {"sha": "4a6d5bc935233ac96c479b6d4d748fbba930e2ed", "filename": "crates/ra_syntax/src/string_lexing/parser.rs", "status": "added", "additions": 201, "deletions": 0, "changes": 201, "blob_url": "https://github.com/rust-lang/rust/blob/9aebd9e6caf49467ca20caf2583c47cf5092c788/crates%2Fra_syntax%2Fsrc%2Fstring_lexing%2Fparser.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aebd9e6caf49467ca20caf2583c47cf5092c788/crates%2Fra_syntax%2Fsrc%2Fstring_lexing%2Fparser.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fstring_lexing%2Fparser.rs?ref=9aebd9e6caf49467ca20caf2583c47cf5092c788", "patch": "@@ -0,0 +1,201 @@\n+use rowan::{TextRange, TextUnit};\n+\n+use self::CharComponentKind::*;\n+\n+pub struct Parser<'a> {\n+    pub(super) src: &'a str,\n+    pub(super) pos: usize,\n+}\n+\n+impl<'a> Parser<'a> {\n+    pub fn new(src: &'a str) -> Parser<'a> {\n+        Parser { src, pos: 0 }\n+    }\n+\n+    // Utility methods\n+\n+    pub fn peek(&self) -> Option<char> {\n+        if self.pos == self.src.len() {\n+            return None;\n+        }\n+\n+        self.src[self.pos..].chars().next()\n+    }\n+\n+    pub fn advance(&mut self) -> char {\n+        let next = self\n+            .peek()\n+            .expect(\"cannot advance if end of input is reached\");\n+        self.pos += next.len_utf8();\n+        next\n+    }\n+\n+    pub fn skip_whitespace(&mut self) {\n+        while self.peek().map(|c| c.is_whitespace()) == Some(true) {\n+            self.advance();\n+        }\n+    }\n+\n+    pub fn get_pos(&self) -> TextUnit {\n+        (self.pos as u32).into()\n+    }\n+\n+    // Char parsing methods\n+\n+    fn parse_unicode_escape(&mut self, start: TextUnit) -> CharComponent {\n+        match self.peek() {\n+            Some('{') => {\n+                self.advance();\n+\n+                // Parse anything until we reach `}`\n+                while let Some(next) = self.peek() {\n+                    self.advance();\n+                    if next == '}' {\n+                        break;\n+                    }\n+                }\n+\n+                let end = self.get_pos();\n+                CharComponent::new(TextRange::from_to(start, end), UnicodeEscape)\n+            }\n+            Some(_) | None => {\n+                let end = self.get_pos();\n+                CharComponent::new(TextRange::from_to(start, end), UnicodeEscape)\n+            }\n+        }\n+    }\n+\n+    fn parse_ascii_code_escape(&mut self, start: TextUnit) -> CharComponent {\n+        let code_start = self.get_pos();\n+        while let Some(next) = self.peek() {\n+            if next == '\\'' || (self.get_pos() - code_start == 2.into()) {\n+                break;\n+            }\n+\n+            self.advance();\n+        }\n+\n+        let end = self.get_pos();\n+        CharComponent::new(TextRange::from_to(start, end), AsciiCodeEscape)\n+    }\n+\n+    fn parse_escape(&mut self, start: TextUnit) -> CharComponent {\n+        if self.peek().is_none() {\n+            return CharComponent::new(TextRange::from_to(start, start), AsciiEscape);\n+        }\n+\n+        let next = self.advance();\n+        let end = self.get_pos();\n+        let range = TextRange::from_to(start, end);\n+        match next {\n+            'x' => self.parse_ascii_code_escape(start),\n+            'u' => self.parse_unicode_escape(start),\n+            _ => CharComponent::new(range, AsciiEscape),\n+        }\n+    }\n+\n+    pub fn parse_char_component(&mut self) -> Option<CharComponent> {\n+        let next = self.peek()?;\n+\n+        // Ignore character close\n+        if next == '\\'' {\n+            return None;\n+        }\n+\n+        let start = self.get_pos();\n+        self.advance();\n+\n+        if next == '\\\\' {\n+            Some(self.parse_escape(start))\n+        } else {\n+            let end = self.get_pos();\n+            Some(CharComponent::new(\n+                TextRange::from_to(start, end),\n+                CodePoint,\n+            ))\n+        }\n+    }\n+\n+    pub fn parse_ignore_newline(&mut self, start: TextUnit) -> Option<StringComponent> {\n+        // In string literals, when a `\\` occurs immediately before the newline, the `\\`,\n+        // the newline, and all whitespace at the beginning of the next line are ignored\n+        match self.peek() {\n+            Some('\\n') | Some('\\r') => {\n+                self.skip_whitespace();\n+                Some(StringComponent::new(\n+                    TextRange::from_to(start, self.get_pos()),\n+                    StringComponentKind::IgnoreNewline,\n+                ))\n+            }\n+            _ => None,\n+        }\n+    }\n+\n+    pub fn parse_string_component(&mut self) -> Option<StringComponent> {\n+        let next = self.peek()?;\n+\n+        // Ignore string close\n+        if next == '\"' {\n+            return None;\n+        }\n+\n+        let start = self.get_pos();\n+        self.advance();\n+\n+        if next == '\\\\' {\n+            // Strings can use `\\` to ignore newlines, so we first try to parse one of those\n+            // before falling back to parsing char escapes\n+            self.parse_ignore_newline(start).or_else(|| {\n+                let char_component = self.parse_escape(start);\n+                Some(StringComponent::new(\n+                    char_component.range,\n+                    StringComponentKind::Char(char_component.kind),\n+                ))\n+            })\n+        } else {\n+            let end = self.get_pos();\n+            Some(StringComponent::new(\n+                TextRange::from_to(start, end),\n+                StringComponentKind::Char(CodePoint),\n+            ))\n+        }\n+    }\n+}\n+\n+#[derive(Debug, Eq, PartialEq, Clone)]\n+pub struct StringComponent {\n+    pub range: TextRange,\n+    pub kind: StringComponentKind,\n+}\n+\n+impl StringComponent {\n+    fn new(range: TextRange, kind: StringComponentKind) -> StringComponent {\n+        StringComponent { range, kind }\n+    }\n+}\n+\n+#[derive(Debug, Eq, PartialEq, Clone)]\n+pub enum StringComponentKind {\n+    IgnoreNewline,\n+    Char(CharComponentKind),\n+}\n+\n+#[derive(Debug, Eq, PartialEq, Clone)]\n+pub struct CharComponent {\n+    pub range: TextRange,\n+    pub kind: CharComponentKind,\n+}\n+\n+impl CharComponent {\n+    fn new(range: TextRange, kind: CharComponentKind) -> CharComponent {\n+        CharComponent { range, kind }\n+    }\n+}\n+\n+#[derive(Debug, Eq, PartialEq, Clone)]\n+pub enum CharComponentKind {\n+    CodePoint,\n+    AsciiEscape,\n+    AsciiCodeEscape,\n+    UnicodeEscape,\n+}"}, {"sha": "1b23029c64e4332696093b1ac344cf6e587c702c", "filename": "crates/ra_syntax/src/string_lexing/string.rs", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/9aebd9e6caf49467ca20caf2583c47cf5092c788/crates%2Fra_syntax%2Fsrc%2Fstring_lexing%2Fstring.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aebd9e6caf49467ca20caf2583c47cf5092c788/crates%2Fra_syntax%2Fsrc%2Fstring_lexing%2Fstring.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fstring_lexing%2Fstring.rs?ref=9aebd9e6caf49467ca20caf2583c47cf5092c788", "patch": "@@ -0,0 +1,46 @@\n+use super::parser::Parser;\n+use super::StringComponent;\n+\n+pub fn parse_string_literal(src: &str) -> StringComponentIterator {\n+    StringComponentIterator {\n+        parser: Parser::new(src),\n+        has_closing_quote: false,\n+    }\n+}\n+\n+pub struct StringComponentIterator<'a> {\n+    parser: Parser<'a>,\n+    pub has_closing_quote: bool,\n+}\n+\n+impl<'a> Iterator for StringComponentIterator<'a> {\n+    type Item = StringComponent;\n+    fn next(&mut self) -> Option<StringComponent> {\n+        if self.parser.pos == 0 {\n+            assert!(\n+                self.parser.advance() == '\"',\n+                \"string literal should start with double quotes\"\n+            );\n+        }\n+\n+        if let Some(component) = self.parser.parse_string_component() {\n+            return Some(component);\n+        }\n+\n+        // We get here when there are no char components left to parse\n+        if self.parser.peek() == Some('\"') {\n+            self.parser.advance();\n+            self.has_closing_quote = true;\n+        }\n+\n+        assert!(\n+            self.parser.peek() == None,\n+            \"string literal should leave no unparsed input: src = {}, pos = {}, length = {}\",\n+            self.parser.src,\n+            self.parser.pos,\n+            self.parser.src.len()\n+        );\n+\n+        None\n+    }\n+}"}, {"sha": "43c0d7edda55b91e09b87a769c78e6f8dd64fbef", "filename": "crates/ra_syntax/src/validation/byte.rs", "status": "added", "additions": 211, "deletions": 0, "changes": 211, "blob_url": "https://github.com/rust-lang/rust/blob/9aebd9e6caf49467ca20caf2583c47cf5092c788/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fbyte.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aebd9e6caf49467ca20caf2583c47cf5092c788/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fbyte.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fbyte.rs?ref=9aebd9e6caf49467ca20caf2583c47cf5092c788", "patch": "@@ -0,0 +1,211 @@\n+//! Validation of byte literals\n+\n+use crate::{\n+    ast::{self, AstNode},\n+    string_lexing::{self, CharComponentKind},\n+    TextRange,\n+    validation::char,\n+    yellow::{\n+        SyntaxError,\n+        SyntaxErrorKind::*,\n+    },\n+};\n+\n+pub(super) fn validate_byte_node(node: ast::Byte, errors: &mut Vec<SyntaxError>) {\n+    let literal_text = node.text();\n+    let literal_range = node.syntax().range();\n+    let mut components = string_lexing::parse_byte_literal(literal_text);\n+    let mut len = 0;\n+    for component in &mut components {\n+        len += 1;\n+        let text = &literal_text[component.range];\n+        let range = component.range + literal_range.start();\n+        validate_byte_component(text, component.kind, range, errors);\n+    }\n+\n+    if !components.has_closing_quote {\n+        errors.push(SyntaxError::new(UnclosedByte, literal_range));\n+    }\n+\n+    if len == 0 {\n+        errors.push(SyntaxError::new(EmptyByte, literal_range));\n+    }\n+\n+    if len > 1 {\n+        errors.push(SyntaxError::new(OverlongByte, literal_range));\n+    }\n+}\n+\n+pub(super) fn validate_byte_component(\n+    text: &str,\n+    kind: CharComponentKind,\n+    range: TextRange,\n+    errors: &mut Vec<SyntaxError>,\n+) {\n+    use self::CharComponentKind::*;\n+    match kind {\n+        AsciiEscape => validate_byte_escape(text, range, errors),\n+        AsciiCodeEscape => validate_byte_code_escape(text, range, errors),\n+        UnicodeEscape => errors.push(SyntaxError::new(UnicodeEscapeForbidden, range)),\n+        CodePoint => {\n+            let c = text\n+                .chars()\n+                .next()\n+                .expect(\"Code points should be one character long\");\n+\n+            // These bytes must always be escaped\n+            if c == '\\t' || c == '\\r' || c == '\\n' {\n+                errors.push(SyntaxError::new(UnescapedByte, range));\n+            }\n+\n+            // Only ASCII bytes are allowed\n+            if c > 0x7F as char {\n+                errors.push(SyntaxError::new(ByteOutOfRange, range));\n+            }\n+        }\n+    }\n+}\n+\n+fn validate_byte_escape(text: &str, range: TextRange, errors: &mut Vec<SyntaxError>) {\n+    if text.len() == 1 {\n+        // Escape sequence consists only of leading `\\`\n+        errors.push(SyntaxError::new(EmptyByteEscape, range));\n+    } else {\n+        let escape_code = text.chars().skip(1).next().unwrap();\n+        if !char::is_ascii_escape(escape_code) {\n+            errors.push(SyntaxError::new(InvalidByteEscape, range));\n+        }\n+    }\n+}\n+\n+fn validate_byte_code_escape(text: &str, range: TextRange, errors: &mut Vec<SyntaxError>) {\n+    // A ByteCodeEscape has 4 chars, example: `\\xDD`\n+    if text.len() < 4 {\n+        errors.push(SyntaxError::new(TooShortByteCodeEscape, range));\n+    } else {\n+        assert!(\n+            text.chars().count() == 4,\n+            \"ByteCodeEscape cannot be longer than 4 chars\"\n+        );\n+\n+        if u8::from_str_radix(&text[2..], 16).is_err() {\n+            errors.push(SyntaxError::new(MalformedByteCodeEscape, range));\n+        }\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use crate::SourceFileNode;\n+\n+    fn build_file(literal: &str) -> SourceFileNode {\n+        let src = format!(\"const C: u8 = b'{}';\", literal);\n+        SourceFileNode::parse(&src)\n+    }\n+\n+    fn assert_valid_byte(literal: &str) {\n+        let file = build_file(literal);\n+        assert!(\n+            file.errors().len() == 0,\n+            \"Errors for literal '{}': {:?}\",\n+            literal,\n+            file.errors()\n+        );\n+    }\n+\n+    fn assert_invalid_byte(literal: &str) {\n+        let file = build_file(literal);\n+        assert!(file.errors().len() > 0);\n+    }\n+\n+    #[test]\n+    fn test_ansi_codepoints() {\n+        for byte in 0..128 {\n+            match byte {\n+                b'\\n' | b'\\r' | b'\\t' => assert_invalid_byte(&(byte as char).to_string()),\n+                b'\\'' | b'\\\\' => { /* Ignore character close and backslash */ }\n+                _ => assert_valid_byte(&(byte as char).to_string()),\n+            }\n+        }\n+\n+        for byte in 128..=255u8 {\n+            assert_invalid_byte(&(byte as char).to_string());\n+        }\n+    }\n+\n+    #[test]\n+    fn test_unicode_codepoints() {\n+        let invalid = [\"\u0191\", \"\u30d0\", \"\u30e1\", \"\ufdfd\"];\n+        for c in &invalid {\n+            assert_invalid_byte(c);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_unicode_multiple_codepoints() {\n+        let invalid = [\"\u0928\u0940\", \"\ud83d\udc68\u200d\ud83d\udc68\u200d\"];\n+        for c in &invalid {\n+            assert_invalid_byte(c);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_valid_byte_escape() {\n+        let valid = [r\"\\'\", \"\\\"\", \"\\\\\\\\\", \"\\\\\\\"\", r\"\\n\", r\"\\r\", r\"\\t\", r\"\\0\"];\n+        for c in &valid {\n+            assert_valid_byte(c);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_invalid_byte_escape() {\n+        let invalid = [r\"\\a\", r\"\\?\", r\"\\\"];\n+        for c in &invalid {\n+            assert_invalid_byte(c);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_valid_byte_code_escape() {\n+        let valid = [r\"\\x00\", r\"\\x7F\", r\"\\x55\", r\"\\xF0\"];\n+        for c in &valid {\n+            assert_valid_byte(c);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_invalid_byte_code_escape() {\n+        let invalid = [r\"\\x\", r\"\\x7\"];\n+        for c in &invalid {\n+            assert_invalid_byte(c);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_invalid_unicode_escape() {\n+        let well_formed = [\n+            r\"\\u{FF}\",\n+            r\"\\u{0}\",\n+            r\"\\u{F}\",\n+            r\"\\u{10FFFF}\",\n+            r\"\\u{1_0__FF___FF_____}\",\n+        ];\n+        for c in &well_formed {\n+            assert_invalid_byte(c);\n+        }\n+\n+        let invalid = [\n+            r\"\\u\",\n+            r\"\\u{}\",\n+            r\"\\u{\",\n+            r\"\\u{FF\",\n+            r\"\\u{FFFFFF}\",\n+            r\"\\u{_F}\",\n+            r\"\\u{00FFFFF}\",\n+            r\"\\u{110000}\",\n+        ];\n+        for c in &invalid {\n+            assert_invalid_byte(c);\n+        }\n+    }\n+}"}, {"sha": "7b830e97cde1945fb42624b8524f096efab807b4", "filename": "crates/ra_syntax/src/validation/byte_string.rs", "status": "added", "additions": 178, "deletions": 0, "changes": 178, "blob_url": "https://github.com/rust-lang/rust/blob/9aebd9e6caf49467ca20caf2583c47cf5092c788/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fbyte_string.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aebd9e6caf49467ca20caf2583c47cf5092c788/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fbyte_string.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fbyte_string.rs?ref=9aebd9e6caf49467ca20caf2583c47cf5092c788", "patch": "@@ -0,0 +1,178 @@\n+use crate::{\n+    ast::{self, AstNode},\n+    string_lexing::{self, StringComponentKind},\n+    yellow::{\n+        SyntaxError,\n+        SyntaxErrorKind::*,\n+    },\n+};\n+\n+use super::byte;\n+\n+pub(crate) fn validate_byte_string_node(node: ast::ByteString, errors: &mut Vec<SyntaxError>) {\n+    let literal_text = node.text();\n+    let literal_range = node.syntax().range();\n+    let mut components = string_lexing::parse_byte_string_literal(literal_text);\n+    for component in &mut components {\n+        let range = component.range + literal_range.start();\n+\n+        match component.kind {\n+            StringComponentKind::Char(kind) => {\n+                // Chars must escape \\t, \\n and \\r codepoints, but strings don't\n+                let text = &literal_text[component.range];\n+                match text {\n+                    \"\\t\" | \"\\n\" | \"\\r\" => { /* always valid */ }\n+                    _ => byte::validate_byte_component(text, kind, range, errors),\n+                }\n+            }\n+            StringComponentKind::IgnoreNewline => { /* always valid */ }\n+        }\n+    }\n+\n+    if !components.has_closing_quote {\n+        errors.push(SyntaxError::new(UnclosedString, literal_range));\n+    }\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use crate::SourceFileNode;\n+\n+    fn build_file(literal: &str) -> SourceFileNode {\n+        let src = format!(r#\"const S: &'static [u8] = b\"{}\";\"#, literal);\n+        println!(\"Source: {}\", src);\n+        SourceFileNode::parse(&src)\n+    }\n+\n+    fn assert_valid_str(literal: &str) {\n+        let file = build_file(literal);\n+        assert!(\n+            file.errors().len() == 0,\n+            \"Errors for literal '{}': {:?}\",\n+            literal,\n+            file.errors()\n+        );\n+    }\n+\n+    fn assert_invalid_str(literal: &str) {\n+        let file = build_file(literal);\n+        assert!(file.errors().len() > 0);\n+    }\n+\n+    #[test]\n+    fn test_ansi_codepoints() {\n+        for byte in 0..128 {\n+            match byte {\n+                b'\\\"' | b'\\\\' => { /* Ignore string close and backslash */ }\n+                _ => assert_valid_str(&(byte as char).to_string()),\n+            }\n+        }\n+\n+        for byte in 128..=255u8 {\n+            assert_invalid_str(&(byte as char).to_string());\n+        }\n+    }\n+\n+    #[test]\n+    fn test_unicode_codepoints() {\n+        let invalid = [\"\u0191\", \"\u30d0\", \"\u30e1\", \"\ufdfd\"];\n+        for c in &invalid {\n+            assert_invalid_str(c);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_unicode_multiple_codepoints() {\n+        let invalid = [\"\u0928\u0940\", \"\ud83d\udc68\u200d\ud83d\udc68\u200d\"];\n+        for c in &invalid {\n+            assert_invalid_str(c);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_valid_ascii_escape() {\n+        let valid = [r\"\\'\", r#\"\\\"\"#, r\"\\\\\", r\"\\n\", r\"\\r\", r\"\\t\", r\"\\0\", \"a\", \"b\"];\n+        for c in &valid {\n+            assert_valid_str(c);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_invalid_ascii_escape() {\n+        let invalid = [r\"\\a\", r\"\\?\", r\"\\\"];\n+        for c in &invalid {\n+            assert_invalid_str(c);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_valid_ascii_code_escape() {\n+        let valid = [r\"\\x00\", r\"\\x7F\", r\"\\x55\", r\"\\xF0\"];\n+        for c in &valid {\n+            assert_valid_str(c);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_invalid_ascii_code_escape() {\n+        let invalid = [r\"\\x\", r\"\\x7\"];\n+        for c in &invalid {\n+            assert_invalid_str(c);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_invalid_unicode_escape() {\n+        let well_formed = [\n+            r\"\\u{FF}\",\n+            r\"\\u{0}\",\n+            r\"\\u{F}\",\n+            r\"\\u{10FFFF}\",\n+            r\"\\u{1_0__FF___FF_____}\",\n+        ];\n+        for c in &well_formed {\n+            assert_invalid_str(c);\n+        }\n+\n+        let invalid = [\n+            r\"\\u\",\n+            r\"\\u{}\",\n+            r\"\\u{\",\n+            r\"\\u{FF\",\n+            r\"\\u{FFFFFF}\",\n+            r\"\\u{_F}\",\n+            r\"\\u{00FFFFF}\",\n+            r\"\\u{110000}\",\n+        ];\n+        for c in &invalid {\n+            assert_invalid_str(c);\n+        }\n+    }\n+\n+    #[test]\n+    fn test_mixed_invalid() {\n+        assert_invalid_str(\n+            r\"This is the tale of a string\n+with a newline in between, some emoji (\ud83d\udc68\u200d\ud83d\udc68\u200d) here and there,\n+unicode escapes like this: \\u{1FFBB} and weird stuff like\n+this \ufdfd\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_mixed_valid() {\n+        assert_valid_str(\n+            r\"This is the tale of a string\n+with a newline in between, no emoji at all,\n+nor unicode escapes or weird stuff\",\n+        );\n+    }\n+\n+    #[test]\n+    fn test_ignore_newline() {\n+        assert_valid_str(\n+            \"Hello \\\n+             World\",\n+        );\n+    }\n+}"}, {"sha": "4728c85e6fd1f5a12b91bbceeda6a054a6758772", "filename": "crates/ra_syntax/src/validation/char.rs", "status": "modified", "additions": 99, "deletions": 93, "changes": 192, "blob_url": "https://github.com/rust-lang/rust/blob/9aebd9e6caf49467ca20caf2583c47cf5092c788/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aebd9e6caf49467ca20caf2583c47cf5092c788/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fchar.rs?ref=9aebd9e6caf49467ca20caf2583c47cf5092c788", "patch": "@@ -1,3 +1,5 @@\n+//! Validation of char literals\n+\n use std::u32;\n \n use arrayvec::ArrayString;\n@@ -12,7 +14,7 @@ use crate::{\n     },\n };\n \n-pub(crate) fn validate_char_node(node: ast::Char, errors: &mut Vec<SyntaxError>) {\n+pub(super) fn validate_char_node(node: ast::Char, errors: &mut Vec<SyntaxError>) {\n     let literal_text = node.text();\n     let literal_range = node.syntax().range();\n     let mut components = string_lexing::parse_char_literal(literal_text);\n@@ -37,7 +39,7 @@ pub(crate) fn validate_char_node(node: ast::Char, errors: &mut Vec<SyntaxError>)\n     }\n }\n \n-pub(crate) fn validate_char_component(\n+pub(super) fn validate_char_component(\n     text: &str,\n     kind: CharComponentKind,\n     range: TextRange,\n@@ -46,109 +48,115 @@ pub(crate) fn validate_char_component(\n     // Validate escapes\n     use self::CharComponentKind::*;\n     match kind {\n-        AsciiEscape => {\n-            if text.len() == 1 {\n-                // Escape sequence consists only of leading `\\`\n-                errors.push(SyntaxError::new(EmptyAsciiEscape, range));\n-            } else {\n-                let escape_code = text.chars().skip(1).next().unwrap();\n-                if !is_ascii_escape(escape_code) {\n-                    errors.push(SyntaxError::new(InvalidAsciiEscape, range));\n-                }\n+        AsciiEscape => validate_ascii_escape(text, range, errors),\n+        AsciiCodeEscape => validate_ascii_code_escape(text, range, errors),\n+        UnicodeEscape => validate_unicode_escape(text, range, errors),\n+        CodePoint => {\n+            // These code points must always be escaped\n+            if text == \"\\t\" || text == \"\\r\" || text == \"\\n\" {\n+                errors.push(SyntaxError::new(UnescapedCodepoint, range));\n             }\n         }\n-        AsciiCodeEscape => {\n-            // An AsciiCodeEscape has 4 chars, example: `\\xDD`\n-            if text.len() < 4 {\n-                errors.push(SyntaxError::new(TooShortAsciiCodeEscape, range));\n-            } else {\n-                assert!(\n-                    text.chars().count() == 4,\n-                    \"AsciiCodeEscape cannot be longer than 4 chars\"\n-                );\n-\n-                match u8::from_str_radix(&text[2..], 16) {\n-                    Ok(code) if code < 128 => { /* Escape code is valid */ }\n-                    Ok(_) => errors.push(SyntaxError::new(AsciiCodeEscapeOutOfRange, range)),\n-                    Err(_) => errors.push(SyntaxError::new(MalformedAsciiCodeEscape, range)),\n-                }\n-            }\n+    }\n+}\n+\n+fn validate_ascii_escape(text: &str, range: TextRange, errors: &mut Vec<SyntaxError>) {\n+    if text.len() == 1 {\n+        // Escape sequence consists only of leading `\\`\n+        errors.push(SyntaxError::new(EmptyAsciiEscape, range));\n+    } else {\n+        let escape_code = text.chars().skip(1).next().unwrap();\n+        if !is_ascii_escape(escape_code) {\n+            errors.push(SyntaxError::new(InvalidAsciiEscape, range));\n         }\n-        UnicodeEscape => {\n-            assert!(&text[..2] == \"\\\\u\", \"UnicodeEscape always starts with \\\\u\");\n+    }\n+}\n \n-            if text.len() == 2 {\n-                // No starting `{`\n-                errors.push(SyntaxError::new(MalformedUnicodeEscape, range));\n-                return;\n-            }\n+pub(super) fn is_ascii_escape(code: char) -> bool {\n+    match code {\n+        '\\\\' | '\\'' | '\"' | 'n' | 'r' | 't' | '0' => true,\n+        _ => false,\n+    }\n+}\n \n-            if text.len() == 3 {\n-                // Only starting `{`\n-                errors.push(SyntaxError::new(UnclosedUnicodeEscape, range));\n-                return;\n-            }\n+fn validate_ascii_code_escape(text: &str, range: TextRange, errors: &mut Vec<SyntaxError>) {\n+    // An AsciiCodeEscape has 4 chars, example: `\\xDD`\n+    if text.len() < 4 {\n+        errors.push(SyntaxError::new(TooShortAsciiCodeEscape, range));\n+    } else {\n+        assert!(\n+            text.chars().count() == 4,\n+            \"AsciiCodeEscape cannot be longer than 4 chars\"\n+        );\n \n-            let mut code = ArrayString::<[_; 6]>::new();\n-            let mut closed = false;\n-            for c in text[3..].chars() {\n-                assert!(!closed, \"no characters after escape is closed\");\n-\n-                if c.is_digit(16) {\n-                    if code.len() == 6 {\n-                        errors.push(SyntaxError::new(OverlongUnicodeEscape, range));\n-                        return;\n-                    }\n-\n-                    code.push(c);\n-                } else if c == '_' {\n-                    // Reject leading _\n-                    if code.len() == 0 {\n-                        errors.push(SyntaxError::new(MalformedUnicodeEscape, range));\n-                        return;\n-                    }\n-                } else if c == '}' {\n-                    closed = true;\n-                } else {\n-                    errors.push(SyntaxError::new(MalformedUnicodeEscape, range));\n-                    return;\n-                }\n-            }\n+        match u8::from_str_radix(&text[2..], 16) {\n+            Ok(code) if code < 128 => { /* Escape code is valid */ }\n+            Ok(_) => errors.push(SyntaxError::new(AsciiCodeEscapeOutOfRange, range)),\n+            Err(_) => errors.push(SyntaxError::new(MalformedAsciiCodeEscape, range)),\n+        }\n+    }\n+}\n \n-            if !closed {\n-                errors.push(SyntaxError::new(UnclosedUnicodeEscape, range))\n-            }\n+fn validate_unicode_escape(text: &str, range: TextRange, errors: &mut Vec<SyntaxError>) {\n+    assert!(&text[..2] == \"\\\\u\", \"UnicodeEscape always starts with \\\\u\");\n \n-            if code.len() == 0 {\n-                errors.push(SyntaxError::new(EmptyUnicodeEcape, range));\n+    if text.len() == 2 {\n+        // No starting `{`\n+        errors.push(SyntaxError::new(MalformedUnicodeEscape, range));\n+        return;\n+    }\n+\n+    if text.len() == 3 {\n+        // Only starting `{`\n+        errors.push(SyntaxError::new(UnclosedUnicodeEscape, range));\n+        return;\n+    }\n+\n+    let mut code = ArrayString::<[_; 6]>::new();\n+    let mut closed = false;\n+    for c in text[3..].chars() {\n+        assert!(!closed, \"no characters after escape is closed\");\n+\n+        if c.is_digit(16) {\n+            if code.len() == 6 {\n+                errors.push(SyntaxError::new(OverlongUnicodeEscape, range));\n                 return;\n             }\n \n-            match u32::from_str_radix(&code, 16) {\n-                Ok(code_u32) if code_u32 > 0x10FFFF => {\n-                    errors.push(SyntaxError::new(UnicodeEscapeOutOfRange, range));\n-                }\n-                Ok(_) => {\n-                    // Valid escape code\n-                }\n-                Err(_) => {\n-                    errors.push(SyntaxError::new(MalformedUnicodeEscape, range));\n-                }\n-            }\n-        }\n-        CodePoint => {\n-            // These code points must always be escaped\n-            if text == \"\\t\" || text == \"\\r\" {\n-                errors.push(SyntaxError::new(UnescapedCodepoint, range));\n+            code.push(c);\n+        } else if c == '_' {\n+            // Reject leading _\n+            if code.len() == 0 {\n+                errors.push(SyntaxError::new(MalformedUnicodeEscape, range));\n+                return;\n             }\n+        } else if c == '}' {\n+            closed = true;\n+        } else {\n+            errors.push(SyntaxError::new(MalformedUnicodeEscape, range));\n+            return;\n         }\n     }\n-}\n \n-fn is_ascii_escape(code: char) -> bool {\n-    match code {\n-        '\\\\' | '\\'' | '\"' | 'n' | 'r' | 't' | '0' => true,\n-        _ => false,\n+    if !closed {\n+        errors.push(SyntaxError::new(UnclosedUnicodeEscape, range))\n+    }\n+\n+    if code.len() == 0 {\n+        errors.push(SyntaxError::new(EmptyUnicodeEcape, range));\n+        return;\n+    }\n+\n+    match u32::from_str_radix(&code, 16) {\n+        Ok(code_u32) if code_u32 > 0x10FFFF => {\n+            errors.push(SyntaxError::new(UnicodeEscapeOutOfRange, range));\n+        }\n+        Ok(_) => {\n+            // Valid escape code\n+        }\n+        Err(_) => {\n+            errors.push(SyntaxError::new(MalformedUnicodeEscape, range));\n+        }\n     }\n }\n \n@@ -205,9 +213,7 @@ mod test {\n \n     #[test]\n     fn test_valid_ascii_escape() {\n-        let valid = [\n-            r\"\\'\", \"\\\"\", \"\\\\\\\\\", \"\\\\\\\"\", r\"\\n\", r\"\\r\", r\"\\t\", r\"\\0\", \"a\", \"b\",\n-        ];\n+        let valid = [r\"\\'\", \"\\\"\", \"\\\\\\\\\", \"\\\\\\\"\", r\"\\n\", r\"\\r\", r\"\\t\", r\"\\0\"];\n         for c in &valid {\n             assert_valid_char(c);\n         }"}, {"sha": "bdee8120c91cec63c794ee364027559ed52fe60f", "filename": "crates/ra_syntax/src/validation/mod.rs", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/9aebd9e6caf49467ca20caf2583c47cf5092c788/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aebd9e6caf49467ca20caf2583c47cf5092c788/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fvalidation%2Fmod.rs?ref=9aebd9e6caf49467ca20caf2583c47cf5092c788", "patch": "@@ -5,13 +5,17 @@ use crate::{\n     yellow::SyntaxError,\n };\n \n+mod byte;\n+mod byte_string;\n mod char;\n mod string;\n \n pub(crate) fn validate(file: &SourceFileNode) -> Vec<SyntaxError> {\n     let mut errors = Vec::new();\n     for node in file.syntax().descendants() {\n         let _ = visitor_ctx(&mut errors)\n+            .visit::<ast::Byte, _>(self::byte::validate_byte_node)\n+            .visit::<ast::ByteString, _>(self::byte_string::validate_byte_string_node)\n             .visit::<ast::Char, _>(self::char::validate_char_node)\n             .visit::<ast::String, _>(self::string::validate_string_node)\n             .accept(node);"}, {"sha": "c32ee650dd880ea75bd65694e94ef2ba7130e710", "filename": "crates/ra_syntax/src/yellow/syntax_error.rs", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/rust-lang/rust/blob/9aebd9e6caf49467ca20caf2583c47cf5092c788/crates%2Fra_syntax%2Fsrc%2Fyellow%2Fsyntax_error.rs", "raw_url": "https://github.com/rust-lang/rust/raw/9aebd9e6caf49467ca20caf2583c47cf5092c788/crates%2Fra_syntax%2Fsrc%2Fyellow%2Fsyntax_error.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fra_syntax%2Fsrc%2Fyellow%2Fsyntax_error.rs?ref=9aebd9e6caf49467ca20caf2583c47cf5092c788", "patch": "@@ -72,6 +72,16 @@ pub enum SyntaxErrorKind {\n     EmptyChar,\n     UnclosedChar,\n     OverlongChar,\n+    EmptyByte,\n+    UnclosedByte,\n+    OverlongByte,\n+    ByteOutOfRange,\n+    UnescapedByte,\n+    EmptyByteEscape,\n+    InvalidByteEscape,\n+    TooShortByteCodeEscape,\n+    MalformedByteCodeEscape,\n+    UnicodeEscapeForbidden,\n     EmptyAsciiEscape,\n     InvalidAsciiEscape,\n     TooShortAsciiCodeEscape,\n@@ -98,6 +108,19 @@ impl fmt::Display for SyntaxErrorKind {\n             EmptyChar => write!(f, \"Empty char literal\"),\n             UnclosedChar => write!(f, \"Unclosed char literal\"),\n             OverlongChar => write!(f, \"Char literal should be one character long\"),\n+            EmptyByte => write!(f, \"Empty byte literal\"),\n+            UnclosedByte => write!(f, \"Unclosed byte literal\"),\n+            OverlongByte => write!(f, \"Byte literal should be one character long\"),\n+            ByteOutOfRange => write!(f, \"Byte should be a valid ASCII character\"),\n+            UnescapedByte => write!(f, \"This byte should always be escaped\"),\n+            EmptyByteEscape => write!(f, \"Empty escape sequence\"),\n+            InvalidByteEscape => write!(f, \"Invalid escape sequence\"),\n+            TooShortByteCodeEscape => write!(f, \"Escape sequence should have two digits\"),\n+            MalformedByteCodeEscape => write!(f, \"Escape sequence should be a hexadecimal number\"),\n+            UnicodeEscapeForbidden => write!(\n+                f,\n+                \"Unicode escapes are not allowed in byte literals or byte strings\"\n+            ),\n             TooShortAsciiCodeEscape => write!(f, \"Escape sequence should have two digits\"),\n             AsciiCodeEscapeOutOfRange => {\n                 write!(f, \"Escape sequence should be between \\\\x00 and \\\\x7F\")"}]}