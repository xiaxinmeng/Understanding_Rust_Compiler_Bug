{"sha": "287e9a870c90650f2779c25de498602782a0f683", "node_id": "MDY6Q29tbWl0NzI0NzEyOjI4N2U5YTg3MGM5MDY1MGYyNzc5YzI1ZGU0OTg2MDI3ODJhMGY2ODM=", "commit": {"author": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2021-03-15T17:22:25Z"}, "committer": {"name": "Florian Diebold", "email": "flodiebold@gmail.com", "date": "2021-03-15T18:14:10Z"}, "message": "Fix unification logic", "tree": {"sha": "430c99d6ad936c36036ab69f6d144082d9b6fbbd", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/430c99d6ad936c36036ab69f6d144082d9b6fbbd"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/287e9a870c90650f2779c25de498602782a0f683", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/287e9a870c90650f2779c25de498602782a0f683", "html_url": "https://github.com/rust-lang/rust/commit/287e9a870c90650f2779c25de498602782a0f683", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/287e9a870c90650f2779c25de498602782a0f683/comments", "author": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "committer": {"login": "flodiebold", "id": 906069, "node_id": "MDQ6VXNlcjkwNjA2OQ==", "avatar_url": "https://avatars.githubusercontent.com/u/906069?v=4", "gravatar_id": "", "url": "https://api.github.com/users/flodiebold", "html_url": "https://github.com/flodiebold", "followers_url": "https://api.github.com/users/flodiebold/followers", "following_url": "https://api.github.com/users/flodiebold/following{/other_user}", "gists_url": "https://api.github.com/users/flodiebold/gists{/gist_id}", "starred_url": "https://api.github.com/users/flodiebold/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/flodiebold/subscriptions", "organizations_url": "https://api.github.com/users/flodiebold/orgs", "repos_url": "https://api.github.com/users/flodiebold/repos", "events_url": "https://api.github.com/users/flodiebold/events{/privacy}", "received_events_url": "https://api.github.com/users/flodiebold/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1f28345b37130659438a8d2427f8879a19a14ae9", "url": "https://api.github.com/repos/rust-lang/rust/commits/1f28345b37130659438a8d2427f8879a19a14ae9", "html_url": "https://github.com/rust-lang/rust/commit/1f28345b37130659438a8d2427f8879a19a14ae9"}], "stats": {"total": 218, "additions": 117, "deletions": 101}, "files": [{"sha": "7795f446f511eb4743ee3e4f72c1dedb766a004d", "filename": "crates/hir_ty/src/infer/unify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/287e9a870c90650f2779c25de498602782a0f683/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/287e9a870c90650f2779c25de498602782a0f683/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Finfer%2Funify.rs?ref=287e9a870c90650f2779c25de498602782a0f683", "patch": "@@ -300,7 +300,7 @@ impl InferenceTable {\n                 | (TyKind::Raw(_, ty1), TyKind::Raw(_, ty2))\n                 | (TyKind::Array(ty1), TyKind::Array(ty2))\n                 | (TyKind::Slice(ty1), TyKind::Slice(ty2)) => self.unify_inner(ty1, ty2, depth + 1),\n-                _ => false,\n+                _ => true, /* we checked equals_ctor already */\n             }\n         } else {\n             self.unify_inner_trivial(&ty1, &ty2, depth)"}, {"sha": "93d3ad020a8d3502dbfcb08bdabab6d2fdcd70f5", "filename": "crates/hir_ty/src/tests/traits.rs", "status": "modified", "additions": 116, "deletions": 100, "changes": 216, "blob_url": "https://github.com/rust-lang/rust/blob/287e9a870c90650f2779c25de498602782a0f683/crates%2Fhir_ty%2Fsrc%2Ftests%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/287e9a870c90650f2779c25de498602782a0f683/crates%2Fhir_ty%2Fsrc%2Ftests%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/crates%2Fhir_ty%2Fsrc%2Ftests%2Ftraits.rs?ref=287e9a870c90650f2779c25de498602782a0f683", "patch": "@@ -1699,7 +1699,7 @@ fn super_trait_assoc_type_bounds() {\n \n #[test]\n fn fn_trait() {\n-    check_infer(\n+    check_infer_with_mismatches(\n         r#\"\n         trait FnOnce<Args> {\n             type Output;\n@@ -1727,7 +1727,7 @@ fn fn_trait() {\n \n #[test]\n fn fn_ptr_and_item() {\n-    check_infer(\n+    check_infer_with_mismatches(\n         r#\"\n         #[lang=\"fn_once\"]\n         trait FnOnce<Args> {\n@@ -1743,12 +1743,12 @@ fn fn_ptr_and_item() {\n         struct Bar<T>(T);\n \n         impl<A1, R, F: FnOnce(A1) -> R> Foo<(A1, R)> for Bar<F> {\n-            fn foo(&self) -> (A1, R) {}\n+            fn foo(&self) -> (A1, R) { loop {} }\n         }\n \n         enum Opt<T> { None, Some(T) }\n         impl<T> Opt<T> {\n-            fn map<U, F: FnOnce(T) -> U>(self, f: F) -> Opt<U> {}\n+            fn map<U, F: FnOnce(T) -> U>(self, f: F) -> Opt<U> { loop {} }\n         }\n \n         fn test() {\n@@ -1765,19 +1765,23 @@ fn fn_ptr_and_item() {\n             80..84 'args': Args\n             139..143 'self': &Self\n             243..247 'self': &Bar<F>\n-            260..262 '{}': ()\n-            346..350 'self': Opt<T>\n-            352..353 'f': F\n-            368..370 '{}': ()\n-            384..500 '{     ...(f); }': ()\n-            394..397 'bar': Bar<fn(u8) -> u32>\n-            423..426 'bar': Bar<fn(u8) -> u32>\n-            423..432 'bar.foo()': (u8, u32)\n-            443..446 'opt': Opt<u8>\n-            465..466 'f': fn(u8) -> u32\n-            487..490 'opt': Opt<u8>\n-            487..497 'opt.map(f)': Opt<u32>\n-            495..496 'f': fn(u8) -> u32\n+            260..271 '{ loop {} }': (A1, R)\n+            262..269 'loop {}': !\n+            267..269 '{}': ()\n+            355..359 'self': Opt<T>\n+            361..362 'f': F\n+            377..388 '{ loop {} }': Opt<U>\n+            379..386 'loop {}': !\n+            384..386 '{}': ()\n+            402..518 '{     ...(f); }': ()\n+            412..415 'bar': Bar<fn(u8) -> u32>\n+            441..444 'bar': Bar<fn(u8) -> u32>\n+            441..450 'bar.foo()': (u8, u32)\n+            461..464 'opt': Opt<u8>\n+            483..484 'f': fn(u8) -> u32\n+            505..508 'opt': Opt<u8>\n+            505..515 'opt.map(f)': Opt<u32>\n+            513..514 'f': fn(u8) -> u32\n         \"#]],\n     );\n }\n@@ -1859,7 +1863,7 @@ fn fn_trait_deref_with_ty_default() {\n \n #[test]\n fn closure_1() {\n-    check_infer(\n+    check_infer_with_mismatches(\n         r#\"\n         #[lang = \"fn_once\"]\n         trait FnOnce<Args> {\n@@ -1868,7 +1872,7 @@ fn closure_1() {\n \n         enum Option<T> { Some(T), None }\n         impl<T> Option<T> {\n-            fn map<U, F: FnOnce(T) -> U>(self, f: F) -> Option<U> {}\n+            fn map<U, F: FnOnce(T) -> U>(self, f: F) -> Option<U> { loop {} }\n         }\n \n         fn test() {\n@@ -1881,37 +1885,39 @@ fn closure_1() {\n         expect![[r#\"\n             147..151 'self': Option<T>\n             153..154 'f': F\n-            172..174 '{}': ()\n-            188..307 '{     ... 1); }': ()\n-            198..199 'x': Option<u32>\n-            202..214 'Option::Some': Some<u32>(u32) -> Option<u32>\n-            202..220 'Option...(1u32)': Option<u32>\n-            215..219 '1u32': u32\n-            226..227 'x': Option<u32>\n-            226..242 'x.map(...v + 1)': Option<u32>\n-            232..241 '|v| v + 1': |u32| -> u32\n-            233..234 'v': u32\n-            236..237 'v': u32\n-            236..241 'v + 1': u32\n-            240..241 '1': u32\n-            248..249 'x': Option<u32>\n-            248..264 'x.map(... 1u64)': Option<u64>\n-            254..263 '|_v| 1u64': |u32| -> u64\n-            255..257 '_v': u32\n-            259..263 '1u64': u64\n-            274..275 'y': Option<i64>\n-            291..292 'x': Option<u32>\n-            291..304 'x.map(|_v| 1)': Option<i64>\n-            297..303 '|_v| 1': |u32| -> i64\n-            298..300 '_v': u32\n-            302..303 '1': i64\n+            172..183 '{ loop {} }': Option<U>\n+            174..181 'loop {}': !\n+            179..181 '{}': ()\n+            197..316 '{     ... 1); }': ()\n+            207..208 'x': Option<u32>\n+            211..223 'Option::Some': Some<u32>(u32) -> Option<u32>\n+            211..229 'Option...(1u32)': Option<u32>\n+            224..228 '1u32': u32\n+            235..236 'x': Option<u32>\n+            235..251 'x.map(...v + 1)': Option<u32>\n+            241..250 '|v| v + 1': |u32| -> u32\n+            242..243 'v': u32\n+            245..246 'v': u32\n+            245..250 'v + 1': u32\n+            249..250 '1': u32\n+            257..258 'x': Option<u32>\n+            257..273 'x.map(... 1u64)': Option<u64>\n+            263..272 '|_v| 1u64': |u32| -> u64\n+            264..266 '_v': u32\n+            268..272 '1u64': u64\n+            283..284 'y': Option<i64>\n+            300..301 'x': Option<u32>\n+            300..313 'x.map(|_v| 1)': Option<i64>\n+            306..312 '|_v| 1': |u32| -> i64\n+            307..309 '_v': u32\n+            311..312 '1': i64\n         \"#]],\n     );\n }\n \n #[test]\n fn closure_2() {\n-    check_infer(\n+    check_infer_with_mismatches(\n         r#\"\n         trait FnOnce<Args> {\n             type Output;\n@@ -1951,22 +1957,22 @@ fn closure_2() {\n \n #[test]\n fn closure_as_argument_inference_order() {\n-    check_infer(\n+    check_infer_with_mismatches(\n         r#\"\n         #[lang = \"fn_once\"]\n         trait FnOnce<Args> {\n             type Output;\n         }\n \n-        fn foo1<T, U, F: FnOnce(T) -> U>(x: T, f: F) -> U {}\n-        fn foo2<T, U, F: FnOnce(T) -> U>(f: F, x: T) -> U {}\n+        fn foo1<T, U, F: FnOnce(T) -> U>(x: T, f: F) -> U { loop {} }\n+        fn foo2<T, U, F: FnOnce(T) -> U>(f: F, x: T) -> U { loop {} }\n \n         struct S;\n         impl S {\n             fn method(self) -> u64;\n \n-            fn foo1<T, U, F: FnOnce(T) -> U>(self, x: T, f: F) -> U {}\n-            fn foo2<T, U, F: FnOnce(T) -> U>(self, f: F, x: T) -> U {}\n+            fn foo1<T, U, F: FnOnce(T) -> U>(self, x: T, f: F) -> U { loop {} }\n+            fn foo2<T, U, F: FnOnce(T) -> U>(self, f: F, x: T) -> U { loop {} }\n         }\n \n         fn test() {\n@@ -1979,52 +1985,60 @@ fn closure_as_argument_inference_order() {\n         expect![[r#\"\n             94..95 'x': T\n             100..101 'f': F\n-            111..113 '{}': ()\n-            147..148 'f': F\n-            153..154 'x': T\n-            164..166 '{}': ()\n-            201..205 'self': S\n-            253..257 'self': S\n-            259..260 'x': T\n-            265..266 'f': F\n-            276..278 '{}': ()\n-            316..320 'self': S\n-            322..323 'f': F\n-            328..329 'x': T\n-            339..341 '{}': ()\n-            355..514 '{     ... S); }': ()\n-            365..367 'x1': u64\n-            370..374 'foo1': fn foo1<S, u64, |S| -> u64>(S, |S| -> u64) -> u64\n-            370..393 'foo1(S...hod())': u64\n-            375..376 'S': S\n-            378..392 '|s| s.method()': |S| -> u64\n-            379..380 's': S\n-            382..383 's': S\n-            382..392 's.method()': u64\n-            403..405 'x2': u64\n-            408..412 'foo2': fn foo2<S, u64, |S| -> u64>(|S| -> u64, S) -> u64\n-            408..431 'foo2(|...(), S)': u64\n-            413..427 '|s| s.method()': |S| -> u64\n-            414..415 's': S\n-            417..418 's': S\n-            417..427 's.method()': u64\n-            429..430 'S': S\n-            441..443 'x3': u64\n-            446..447 'S': S\n-            446..471 'S.foo1...hod())': u64\n-            453..454 'S': S\n-            456..470 '|s| s.method()': |S| -> u64\n-            457..458 's': S\n-            460..461 's': S\n-            460..470 's.method()': u64\n-            481..483 'x4': u64\n-            486..487 'S': S\n-            486..511 'S.foo2...(), S)': u64\n-            493..507 '|s| s.method()': |S| -> u64\n-            494..495 's': S\n-            497..498 's': S\n-            497..507 's.method()': u64\n-            509..510 'S': S\n+            111..122 '{ loop {} }': U\n+            113..120 'loop {}': !\n+            118..120 '{}': ()\n+            156..157 'f': F\n+            162..163 'x': T\n+            173..184 '{ loop {} }': U\n+            175..182 'loop {}': !\n+            180..182 '{}': ()\n+            219..223 'self': S\n+            271..275 'self': S\n+            277..278 'x': T\n+            283..284 'f': F\n+            294..305 '{ loop {} }': U\n+            296..303 'loop {}': !\n+            301..303 '{}': ()\n+            343..347 'self': S\n+            349..350 'f': F\n+            355..356 'x': T\n+            366..377 '{ loop {} }': U\n+            368..375 'loop {}': !\n+            373..375 '{}': ()\n+            391..550 '{     ... S); }': ()\n+            401..403 'x1': u64\n+            406..410 'foo1': fn foo1<S, u64, |S| -> u64>(S, |S| -> u64) -> u64\n+            406..429 'foo1(S...hod())': u64\n+            411..412 'S': S\n+            414..428 '|s| s.method()': |S| -> u64\n+            415..416 's': S\n+            418..419 's': S\n+            418..428 's.method()': u64\n+            439..441 'x2': u64\n+            444..448 'foo2': fn foo2<S, u64, |S| -> u64>(|S| -> u64, S) -> u64\n+            444..467 'foo2(|...(), S)': u64\n+            449..463 '|s| s.method()': |S| -> u64\n+            450..451 's': S\n+            453..454 's': S\n+            453..463 's.method()': u64\n+            465..466 'S': S\n+            477..479 'x3': u64\n+            482..483 'S': S\n+            482..507 'S.foo1...hod())': u64\n+            489..490 'S': S\n+            492..506 '|s| s.method()': |S| -> u64\n+            493..494 's': S\n+            496..497 's': S\n+            496..506 's.method()': u64\n+            517..519 'x4': u64\n+            522..523 'S': S\n+            522..547 'S.foo2...(), S)': u64\n+            529..543 '|s| s.method()': |S| -> u64\n+            530..531 's': S\n+            533..534 's': S\n+            533..543 's.method()': u64\n+            545..546 'S': S\n         \"#]],\n     );\n }\n@@ -2536,7 +2550,7 @@ fn test() {\n \n #[test]\n fn iterator_chain() {\n-    check_infer(\n+    check_infer_with_mismatches(\n         r#\"\n         //- /main.rs\n         #[lang = \"fn_once\"]\n@@ -2939,7 +2953,7 @@ fn infer_closure_arg() {\n \n #[test]\n fn infer_fn_trait_arg() {\n-    check_infer(\n+    check_infer_with_mismatches(\n         r#\"\n         //- /lib.rs deps:std\n \n@@ -2986,7 +3000,8 @@ fn infer_fn_trait_arg() {\n \n #[test]\n fn infer_box_fn_arg() {\n-    check_infer(\n+    // The type mismatch is a bug\n+    check_infer_with_mismatches(\n         r#\"\n         //- /lib.rs deps:std\n \n@@ -3025,7 +3040,7 @@ fn infer_box_fn_arg() {\n         fn foo() {\n             let s = Option::None;\n             let f: Box<dyn FnOnce(&Option<i32>)> = box (|ps| {});\n-            f(&s)\n+            f(&s);\n         }\n         \"#,\n         expect![[r#\"\n@@ -3037,7 +3052,7 @@ fn infer_box_fn_arg() {\n             406..417 '&self.inner': &*mut T\n             407..411 'self': &Box<T>\n             407..417 'self.inner': *mut T\n-            478..575 '{     ...(&s) }': FnOnce::Output<dyn FnOnce(&Option<i32>), (&Option<i32>,)>\n+            478..576 '{     ...&s); }': ()\n             488..489 's': Option<i32>\n             492..504 'Option::None': Option<i32>\n             514..515 'f': Box<dyn FnOnce(&Option<i32>)>\n@@ -3049,6 +3064,7 @@ fn infer_box_fn_arg() {\n             568..573 'f(&s)': FnOnce::Output<dyn FnOnce(&Option<i32>), (&Option<i32>,)>\n             570..572 '&s': &Option<i32>\n             571..572 's': Option<i32>\n+            549..562: expected Box<dyn FnOnce(&Option<i32>)>, got Box<|_| -> ()>\n         \"#]],\n     );\n }"}]}