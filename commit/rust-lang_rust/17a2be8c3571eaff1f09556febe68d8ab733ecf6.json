{"sha": "17a2be8c3571eaff1f09556febe68d8ab733ecf6", "node_id": "MDY6Q29tbWl0NzI0NzEyOjE3YTJiZThjMzU3MWVhZmYxZjA5NTU2ZmViZTY4ZDhhYjczM2VjZjY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2016-08-25T11:35:52Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2016-08-25T11:35:52Z"}, "message": "Auto merge of #35979 - Manishearth:rollup, r=Manishearth\n\nRollup of 6 pull requests\n\n- Successful merges: #35238, #35867, #35885, #35916, #35947, #35955\n- Failed merges:", "tree": {"sha": "04bb552c5227ce77dbe47421b4d5bc4a3726386d", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/04bb552c5227ce77dbe47421b4d5bc4a3726386d"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/17a2be8c3571eaff1f09556febe68d8ab733ecf6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/17a2be8c3571eaff1f09556febe68d8ab733ecf6", "html_url": "https://github.com/rust-lang/rust/commit/17a2be8c3571eaff1f09556febe68d8ab733ecf6", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/17a2be8c3571eaff1f09556febe68d8ab733ecf6/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "f5499a001d9cbde6a672f9d393d9c80c63745f00", "url": "https://api.github.com/repos/rust-lang/rust/commits/f5499a001d9cbde6a672f9d393d9c80c63745f00", "html_url": "https://github.com/rust-lang/rust/commit/f5499a001d9cbde6a672f9d393d9c80c63745f00"}, {"sha": "cf597ab2bac769164bffd9eda3fac77de7de870a", "url": "https://api.github.com/repos/rust-lang/rust/commits/cf597ab2bac769164bffd9eda3fac77de7de870a", "html_url": "https://github.com/rust-lang/rust/commit/cf597ab2bac769164bffd9eda3fac77de7de870a"}], "stats": {"total": 907, "additions": 640, "deletions": 267}, "files": [{"sha": "f7d4993bee3b99ee04fcf8aef21e891963b845f6", "filename": "src/libcore/char.rs", "status": "modified", "additions": 69, "deletions": 13, "changes": 82, "blob_url": "https://github.com/rust-lang/rust/blob/17a2be8c3571eaff1f09556febe68d8ab733ecf6/src%2Flibcore%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17a2be8c3571eaff1f09556febe68d8ab733ecf6/src%2Flibcore%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fchar.rs?ref=17a2be8c3571eaff1f09556febe68d8ab733ecf6", "patch": "@@ -752,25 +752,81 @@ pub struct InvalidSequence(());\n impl<I: Iterator<Item = u8>> Iterator for DecodeUtf8<I> {\n     type Item = Result<char, InvalidSequence>;\n     #[inline]\n+\n     fn next(&mut self) -> Option<Result<char, InvalidSequence>> {\n-        self.0.next().map(|b| {\n-            if b & 0x80 == 0 { Ok(b as char) } else {\n-                let l = (!b).leading_zeros() as usize; // number of bytes in UTF-8 representation\n-                if l < 2 || l > 6 { return Err(InvalidSequence(())) };\n-                let mut x = (b as u32) & (0x7F >> l);\n-                for _ in 0..l-1 {\n+        self.0.next().map(|first_byte| {\n+            // Emit InvalidSequence according to\n+            // Unicode \u00a75.22 Best Practice for U+FFFD Substitution\n+            // http://www.unicode.org/versions/Unicode9.0.0/ch05.pdf#G40630\n+\n+            // Roughly: consume at least one byte,\n+            // then validate one byte at a time and stop before the first unexpected byte\n+            // (which might be the valid start of the next byte sequence).\n+\n+            let mut code_point;\n+            macro_rules! first_byte {\n+                ($mask: expr) => {\n+                    code_point = u32::from(first_byte & $mask)\n+                }\n+            }\n+            macro_rules! continuation_byte {\n+                () => { continuation_byte!(0x80...0xBF) };\n+                ($range: pat) => {\n                     match self.0.peek() {\n-                        Some(&b) if b & 0xC0 == 0x80 => {\n+                        Some(&byte @ $range) => {\n+                            code_point = (code_point << 6) | u32::from(byte & 0b0011_1111);\n                             self.0.next();\n-                            x = (x << 6) | (b as u32) & 0x3F;\n-                        },\n-                        _ => return Err(InvalidSequence(())),\n+                        }\n+                        _ => return Err(InvalidSequence(()))\n                     }\n                 }\n-                match from_u32(x) {\n-                    Some(x) if l == x.len_utf8() => Ok(x),\n-                    _ => Err(InvalidSequence(())),\n+            }\n+\n+            match first_byte {\n+                0x00...0x7F => {\n+                    first_byte!(0b1111_1111);\n+                }\n+                0xC2...0xDF => {\n+                    first_byte!(0b0001_1111);\n+                    continuation_byte!();\n+                }\n+                0xE0 => {\n+                    first_byte!(0b0000_1111);\n+                    continuation_byte!(0xA0...0xBF);  // 0x80...0x9F here are overlong\n+                    continuation_byte!();\n                 }\n+                0xE1...0xEC | 0xEE...0xEF => {\n+                    first_byte!(0b0000_1111);\n+                    continuation_byte!();\n+                    continuation_byte!();\n+                }\n+                0xED => {\n+                    first_byte!(0b0000_1111);\n+                    continuation_byte!(0x80...0x9F);  // 0xA0..0xBF here are surrogates\n+                    continuation_byte!();\n+                }\n+                0xF0 => {\n+                    first_byte!(0b0000_0111);\n+                    continuation_byte!(0x90...0xBF);  // 0x80..0x8F here are overlong\n+                    continuation_byte!();\n+                    continuation_byte!();\n+                }\n+                0xF1...0xF3 => {\n+                    first_byte!(0b0000_0111);\n+                    continuation_byte!();\n+                    continuation_byte!();\n+                    continuation_byte!();\n+                }\n+                0xF4 => {\n+                    first_byte!(0b0000_0111);\n+                    continuation_byte!(0x80...0x8F);  // 0x90..0xBF here are beyond char::MAX\n+                    continuation_byte!();\n+                    continuation_byte!();\n+                }\n+                _ => return Err(InvalidSequence(()))  // Illegal first byte, overlong, or beyond MAX\n+            }\n+            unsafe {\n+                Ok(from_u32_unchecked(code_point))\n             }\n         })\n     }"}, {"sha": "333503d738943b10cd74584cfb34c1119eed4579", "filename": "src/libcoretest/char.rs", "status": "modified", "additions": 45, "deletions": 24, "changes": 69, "blob_url": "https://github.com/rust-lang/rust/blob/17a2be8c3571eaff1f09556febe68d8ab733ecf6/src%2Flibcoretest%2Fchar.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17a2be8c3571eaff1f09556febe68d8ab733ecf6/src%2Flibcoretest%2Fchar.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcoretest%2Fchar.rs?ref=17a2be8c3571eaff1f09556febe68d8ab733ecf6", "patch": "@@ -358,29 +358,50 @@ fn eu_iterator_specializations() {\n \n #[test]\n fn test_decode_utf8() {\n-    use core::char::*;\n-    use core::iter::FromIterator;\n-\n-    for &(str, bs) in [(\"\", &[] as &[u8]),\n-                       (\"A\", &[0x41u8] as &[u8]),\n-                       (\"\ufffd\", &[0xC1u8, 0x81u8] as &[u8]),\n-                       (\"\u2665\", &[0xE2u8, 0x99u8, 0xA5u8]),\n-                       (\"\u2665A\", &[0xE2u8, 0x99u8, 0xA5u8, 0x41u8] as &[u8]),\n-                       (\"\ufffd\", &[0xE2u8, 0x99u8] as &[u8]),\n-                       (\"\ufffdA\", &[0xE2u8, 0x99u8, 0x41u8] as &[u8]),\n-                       (\"\ufffd\", &[0xC0u8] as &[u8]),\n-                       (\"\ufffdA\", &[0xC0u8, 0x41u8] as &[u8]),\n-                       (\"\ufffd\", &[0x80u8] as &[u8]),\n-                       (\"\ufffdA\", &[0x80u8, 0x41u8] as &[u8]),\n-                       (\"\ufffd\", &[0xFEu8] as &[u8]),\n-                       (\"\ufffdA\", &[0xFEu8, 0x41u8] as &[u8]),\n-                       (\"\ufffd\", &[0xFFu8] as &[u8]),\n-                       (\"\ufffdA\", &[0xFFu8, 0x41u8] as &[u8])].into_iter() {\n-        assert!(Iterator::eq(str.chars(),\n-                             decode_utf8(bs.into_iter().map(|&b|b))\n-                                 .map(|r_b| r_b.unwrap_or('\\u{FFFD}'))),\n-                \"chars = {}, bytes = {:?}, decoded = {:?}\", str, bs,\n-                Vec::from_iter(decode_utf8(bs.into_iter().map(|&b|b))\n-                                   .map(|r_b| r_b.unwrap_or('\\u{FFFD}'))));\n+    macro_rules! assert_decode_utf8 {\n+        ($input_bytes: expr, $expected_str: expr) => {\n+            let input_bytes: &[u8] = &$input_bytes;\n+            let s = char::decode_utf8(input_bytes.iter().cloned())\n+                .map(|r_b| r_b.unwrap_or('\\u{FFFD}'))\n+                .collect::<String>();\n+            assert_eq!(s, $expected_str,\n+                       \"input bytes: {:?}, expected str: {:?}, result: {:?}\",\n+                       input_bytes, $expected_str, s);\n+            assert_eq!(String::from_utf8_lossy(&$input_bytes), $expected_str);\n+        }\n     }\n+\n+    assert_decode_utf8!([], \"\");\n+    assert_decode_utf8!([0x41], \"A\");\n+    assert_decode_utf8!([0xC1, 0x81], \"\ufffd\ufffd\");\n+    assert_decode_utf8!([0xE2, 0x99, 0xA5], \"\u2665\");\n+    assert_decode_utf8!([0xE2, 0x99, 0xA5, 0x41], \"\u2665A\");\n+    assert_decode_utf8!([0xE2, 0x99], \"\ufffd\");\n+    assert_decode_utf8!([0xE2, 0x99, 0x41], \"\ufffdA\");\n+    assert_decode_utf8!([0xC0], \"\ufffd\");\n+    assert_decode_utf8!([0xC0, 0x41], \"\ufffdA\");\n+    assert_decode_utf8!([0x80], \"\ufffd\");\n+    assert_decode_utf8!([0x80, 0x41], \"\ufffdA\");\n+    assert_decode_utf8!([0xFE], \"\ufffd\");\n+    assert_decode_utf8!([0xFE, 0x41], \"\ufffdA\");\n+    assert_decode_utf8!([0xFF], \"\ufffd\");\n+    assert_decode_utf8!([0xFF, 0x41], \"\ufffdA\");\n+    assert_decode_utf8!([0xC0, 0x80], \"\ufffd\ufffd\");\n+\n+    // Surrogates\n+    assert_decode_utf8!([0xED, 0x9F, 0xBF], \"\\u{D7FF}\");\n+    assert_decode_utf8!([0xED, 0xA0, 0x80], \"\ufffd\ufffd\ufffd\");\n+    assert_decode_utf8!([0xED, 0xBF, 0x80], \"\ufffd\ufffd\ufffd\");\n+    assert_decode_utf8!([0xEE, 0x80, 0x80], \"\\u{E000}\");\n+\n+    // char::MAX\n+    assert_decode_utf8!([0xF4, 0x8F, 0xBF, 0xBF], \"\\u{10FFFF}\");\n+    assert_decode_utf8!([0xF4, 0x8F, 0xBF, 0x41], \"\ufffdA\");\n+    assert_decode_utf8!([0xF4, 0x90, 0x80, 0x80], \"\ufffd\ufffd\ufffd\ufffd\");\n+\n+    // 5 and 6 bytes sequence\n+    // Part of the original design of UTF-8,\n+    // but invalid now that UTF-8 is artificially restricted to match the range of UTF-16.\n+    assert_decode_utf8!([0xF8, 0x80, 0x80, 0x80, 0x80], \"\ufffd\ufffd\ufffd\ufffd\ufffd\");\n+    assert_decode_utf8!([0xFC, 0x80, 0x80, 0x80, 0x80, 0x80], \"\ufffd\ufffd\ufffd\ufffd\ufffd\ufffd\");\n }"}, {"sha": "1825a892cf55415d0832167c03310faa0a921541", "filename": "src/librbml/lib.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/17a2be8c3571eaff1f09556febe68d8ab733ecf6/src%2Flibrbml%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17a2be8c3571eaff1f09556febe68d8ab733ecf6/src%2Flibrbml%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrbml%2Flib.rs?ref=17a2be8c3571eaff1f09556febe68d8ab733ecf6", "patch": "@@ -173,12 +173,12 @@ impl<'doc> Doc<'doc> {\n         self.start == self.end\n     }\n \n-    pub fn as_str_slice(&self) -> &'doc str {\n+    pub fn as_str(&self) -> &'doc str {\n         str::from_utf8(&self.data[self.start..self.end]).unwrap()\n     }\n \n-    pub fn as_str(&self) -> String {\n-        self.as_str_slice().to_string()\n+    pub fn to_string(&self) -> String {\n+        self.as_str().to_string()\n     }\n }\n \n@@ -773,7 +773,7 @@ pub mod reader {\n             Ok(char::from_u32(doc_as_u32(self.next_doc(EsChar)?)).unwrap())\n         }\n         fn read_str(&mut self) -> DecodeResult<String> {\n-            Ok(self.next_doc(EsStr)?.as_str())\n+            Ok(self.next_doc(EsStr)?.to_string())\n         }\n \n         // Compound types:"}, {"sha": "29bcc1257fd3182c78f0bfdde13aa25444c7f2b3", "filename": "src/librustc/lint/context.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/17a2be8c3571eaff1f09556febe68d8ab733ecf6/src%2Flibrustc%2Flint%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17a2be8c3571eaff1f09556febe68d8ab733ecf6/src%2Flibrustc%2Flint%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fcontext.rs?ref=17a2be8c3571eaff1f09556febe68d8ab733ecf6", "patch": "@@ -601,7 +601,7 @@ pub trait LintContext: Sized {\n             for (lint_id, level, span) in v {\n                 let (now, now_source) = self.lints().get_level_source(lint_id);\n                 if now == Forbid && level != Forbid {\n-                    let lint_name = lint_id.as_str();\n+                    let lint_name = lint_id.to_string();\n                     let mut diag_builder = struct_span_err!(self.sess(), span, E0453,\n                                                             \"{}({}) overruled by outer forbid({})\",\n                                                             level.as_str(), lint_name,\n@@ -1216,7 +1216,7 @@ pub fn check_crate<'a, 'tcx>(tcx: TyCtxt<'a, 'tcx, 'tcx>,\n         for &(lint, span, ref msg) in v {\n             span_bug!(span,\n                       \"unprocessed lint {} at {}: {}\",\n-                      lint.as_str(), tcx.map.node_to_string(*id), *msg)\n+                      lint.to_string(), tcx.map.node_to_string(*id), *msg)\n         }\n     }\n \n@@ -1252,7 +1252,7 @@ pub fn check_ast_crate(sess: &Session, krate: &ast::Crate) {\n     // in the iteration code.\n     for (_, v) in sess.lints.borrow().iter() {\n         for &(lint, span, ref msg) in v {\n-            span_bug!(span, \"unprocessed lint {}: {}\", lint.as_str(), *msg)\n+            span_bug!(span, \"unprocessed lint {}: {}\", lint.to_string(), *msg)\n         }\n     }\n }"}, {"sha": "0938086b000c037b1c22ac592ceb12deb8390c37", "filename": "src/librustc/lint/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/17a2be8c3571eaff1f09556febe68d8ab733ecf6/src%2Flibrustc%2Flint%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17a2be8c3571eaff1f09556febe68d8ab733ecf6/src%2Flibrustc%2Flint%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Flint%2Fmod.rs?ref=17a2be8c3571eaff1f09556febe68d8ab733ecf6", "patch": "@@ -263,7 +263,7 @@ impl LintId {\n     }\n \n     /// Get the name of the lint.\n-    pub fn as_str(&self) -> String {\n+    pub fn to_string(&self) -> String {\n         self.lint.name_lower()\n     }\n }"}, {"sha": "faf2f7dae08c5a9793eb8ba303e02e8f88e146ee", "filename": "src/librustc/middle/region.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/17a2be8c3571eaff1f09556febe68d8ab733ecf6/src%2Flibrustc%2Fmiddle%2Fregion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17a2be8c3571eaff1f09556febe68d8ab733ecf6/src%2Flibrustc%2Fmiddle%2Fregion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fmiddle%2Fregion.rs?ref=17a2be8c3571eaff1f09556febe68d8ab733ecf6", "patch": "@@ -237,7 +237,7 @@ impl CodeExtent {\n                         // (This is the special case aluded to in the\n                         // doc-comment for this method)\n                         let stmt_span = blk.stmts[r.first_statement_index as usize].span;\n-                        Some(Span { lo: stmt_span.hi, ..blk.span })\n+                        Some(Span { lo: stmt_span.hi, hi: blk.span.hi, expn_id: stmt_span.expn_id })\n                     }\n                 }\n             }"}, {"sha": "8a32797dbd75a82e59410042408129a16b6a874f", "filename": "src/librustc/session/config.rs", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/17a2be8c3571eaff1f09556febe68d8ab733ecf6/src%2Flibrustc%2Fsession%2Fconfig.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17a2be8c3571eaff1f09556febe68d8ab733ecf6/src%2Flibrustc%2Fsession%2Fconfig.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc%2Fsession%2Fconfig.rs?ref=17a2be8c3571eaff1f09556febe68d8ab733ecf6", "patch": "@@ -891,6 +891,8 @@ options! {DebuggingOptions, DebuggingSetter, basic_debugging_options,\n           \"force overflow checks on or off\"),\n     trace_macros: bool = (false, parse_bool, [UNTRACKED],\n           \"for every macro invocation, print its name and arguments\"),\n+    debug_macros: bool = (false, parse_bool, [TRACKED],\n+          \"emit line numbers debug info inside macros\"),\n     enable_nonzeroing_move_hints: bool = (false, parse_bool, [TRACKED],\n           \"force nonzeroing move optimization on\"),\n     keep_hygiene_data: bool = (false, parse_bool, [UNTRACKED],"}, {"sha": "4e87c931cc19daf47c55c3d65e77a3fea4a1f5d7", "filename": "src/librustc_driver/lib.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/17a2be8c3571eaff1f09556febe68d8ab733ecf6/src%2Flibrustc_driver%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17a2be8c3571eaff1f09556febe68d8ab733ecf6/src%2Flibrustc_driver%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_driver%2Flib.rs?ref=17a2be8c3571eaff1f09556febe68d8ab733ecf6", "patch": "@@ -861,7 +861,7 @@ Available lint options:\n         for (name, to) in lints {\n             let name = name.to_lowercase().replace(\"_\", \"-\");\n             let desc = to.into_iter()\n-                         .map(|x| x.as_str().replace(\"_\", \"-\"))\n+                         .map(|x| x.to_string().replace(\"_\", \"-\"))\n                          .collect::<Vec<String>>()\n                          .join(\", \");\n             println!(\"    {}  {}\", padded(&name[..]), desc);"}, {"sha": "754910c246d6f599203a47dd72590b7927406867", "filename": "src/librustc_llvm/ffi.rs", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/17a2be8c3571eaff1f09556febe68d8ab733ecf6/src%2Flibrustc_llvm%2Fffi.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17a2be8c3571eaff1f09556febe68d8ab733ecf6/src%2Flibrustc_llvm%2Fffi.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_llvm%2Fffi.rs?ref=17a2be8c3571eaff1f09556febe68d8ab733ecf6", "patch": "@@ -1796,6 +1796,11 @@ extern {\n                                                Col: c_uint)\n                                                -> DILexicalBlock;\n \n+    pub fn LLVMRustDIBuilderCreateLexicalBlockFile(Builder: DIBuilderRef,\n+                                                   Scope: DIScope,\n+                                                   File: DIFile)\n+                                                   -> DILexicalBlock;\n+\n     pub fn LLVMRustDIBuilderCreateStaticVariable(Builder: DIBuilderRef,\n                                                  Context: DIScope,\n                                                  Name: *const c_char,"}, {"sha": "b0335258b4041d8e1e6afe95125fd1a265d427fc", "filename": "src/librustc_metadata/decoder.rs", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/17a2be8c3571eaff1f09556febe68d8ab733ecf6/src%2Flibrustc_metadata%2Fdecoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17a2be8c3571eaff1f09556febe68d8ab733ecf6/src%2Flibrustc_metadata%2Fdecoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_metadata%2Fdecoder.rs?ref=17a2be8c3571eaff1f09556febe68d8ab733ecf6", "patch": "@@ -86,7 +86,7 @@ pub fn load_index(data: &[u8]) -> index::Index {\n \n pub fn crate_rustc_version(data: &[u8]) -> Option<String> {\n     let doc = rbml::Doc::new(data);\n-    reader::maybe_get_doc(doc, tag_rustc_version).map(|s| s.as_str())\n+    reader::maybe_get_doc(doc, tag_rustc_version).map(|s| s.to_string())\n }\n \n pub fn load_xrefs(data: &[u8]) -> index::DenseIndex {\n@@ -207,7 +207,7 @@ fn item_defaultness(item: rbml::Doc) -> hir::Defaultness {\n \n fn item_sort(item: rbml::Doc) -> Option<char> {\n     reader::tagged_docs(item, tag_item_trait_item_sort).nth(0).map(|doc| {\n-        doc.as_str_slice().as_bytes()[0] as char\n+        doc.as_str().as_bytes()[0] as char\n     })\n }\n \n@@ -282,7 +282,7 @@ fn item_name(item: rbml::Doc) -> ast::Name {\n \n fn maybe_item_name(item: rbml::Doc) -> Option<ast::Name> {\n     reader::maybe_get_doc(item, tag_paths_data_name).map(|name| {\n-        let string = name.as_str_slice();\n+        let string = name.as_str();\n         token::intern(string)\n     })\n }\n@@ -368,7 +368,7 @@ fn parse_polarity(item_doc: rbml::Doc) -> hir::ImplPolarity {\n fn parse_associated_type_names(item_doc: rbml::Doc) -> Vec<ast::Name> {\n     let names_doc = reader::get_doc(item_doc, tag_associated_type_names);\n     reader::tagged_docs(names_doc, tag_associated_type_name)\n-        .map(|name_doc| token::intern(name_doc.as_str_slice()))\n+        .map(|name_doc| token::intern(name_doc.as_str()))\n         .collect()\n }\n \n@@ -682,7 +682,7 @@ fn each_child_of_item_or_crate<F, G>(cdata: Cmd,\n \n         let name_doc = reader::get_doc(reexport_doc,\n                                        tag_items_data_item_reexport_name);\n-        let name = name_doc.as_str_slice();\n+        let name = name_doc.as_str();\n \n         // This reexport may be in yet another crate.\n         let crate_data = if child_def_id.krate == cdata.cnum {\n@@ -869,7 +869,7 @@ fn get_explicit_self(item: rbml::Doc) -> ty::ExplicitSelfCategory {\n     }\n \n     let explicit_self_doc = reader::get_doc(item, tag_item_trait_method_explicit_self);\n-    let string = explicit_self_doc.as_str_slice();\n+    let string = explicit_self_doc.as_str();\n \n     let explicit_self_kind = string.as_bytes()[0];\n     match explicit_self_kind as char {\n@@ -1124,19 +1124,19 @@ pub fn get_struct_field_names(cdata: Cmd, id: DefIndex) -> Vec<ast::Name> {\n fn get_meta_items(md: rbml::Doc) -> Vec<P<ast::MetaItem>> {\n     reader::tagged_docs(md, tag_meta_item_word).map(|meta_item_doc| {\n         let nd = reader::get_doc(meta_item_doc, tag_meta_item_name);\n-        let n = token::intern_and_get_ident(nd.as_str_slice());\n+        let n = token::intern_and_get_ident(nd.as_str());\n         attr::mk_word_item(n)\n     }).chain(reader::tagged_docs(md, tag_meta_item_name_value).map(|meta_item_doc| {\n         let nd = reader::get_doc(meta_item_doc, tag_meta_item_name);\n         let vd = reader::get_doc(meta_item_doc, tag_meta_item_value);\n-        let n = token::intern_and_get_ident(nd.as_str_slice());\n-        let v = token::intern_and_get_ident(vd.as_str_slice());\n+        let n = token::intern_and_get_ident(nd.as_str());\n+        let v = token::intern_and_get_ident(vd.as_str());\n         // FIXME (#623): Should be able to decode MetaItemKind::NameValue variants,\n         // but currently the encoder just drops them\n         attr::mk_name_value_item_str(n, v)\n     })).chain(reader::tagged_docs(md, tag_meta_item_list).map(|meta_item_doc| {\n         let nd = reader::get_doc(meta_item_doc, tag_meta_item_name);\n-        let n = token::intern_and_get_ident(nd.as_str_slice());\n+        let n = token::intern_and_get_ident(nd.as_str());\n         let subitems = get_meta_items(meta_item_doc);\n         attr::mk_list_item(n, subitems)\n     })).collect()\n@@ -1191,7 +1191,7 @@ pub fn get_crate_deps(data: &[u8]) -> Vec<CrateDep> {\n \n     fn docstr(doc: rbml::Doc, tag_: usize) -> String {\n         let d = reader::get_doc(doc, tag_);\n-        d.as_str_slice().to_string()\n+        d.as_str().to_string()\n     }\n \n     reader::tagged_docs(depsdoc, tag_crate_dep).enumerate().map(|(crate_num, depdoc)| {\n@@ -1233,14 +1233,14 @@ pub fn get_crate_hash(data: &[u8]) -> Svh {\n pub fn maybe_get_crate_name(data: &[u8]) -> Option<&str> {\n     let cratedoc = rbml::Doc::new(data);\n     reader::maybe_get_doc(cratedoc, tag_crate_crate_name).map(|doc| {\n-        doc.as_str_slice()\n+        doc.as_str()\n     })\n }\n \n pub fn get_crate_disambiguator<'a>(data: &'a [u8]) -> &'a str {\n     let crate_doc = rbml::Doc::new(data);\n     let disambiguator_doc = reader::get_doc(crate_doc, tag_crate_disambiguator);\n-    let slice: &'a str = disambiguator_doc.as_str_slice();\n+    let slice: &'a str = disambiguator_doc.as_str();\n     slice\n }\n \n@@ -1446,11 +1446,12 @@ pub fn get_dylib_dependency_formats(cdata: Cmd)\n                                   tag_dylib_dependency_formats);\n     let mut result = Vec::new();\n \n-    debug!(\"found dylib deps: {}\", formats.as_str_slice());\n-    for spec in formats.as_str_slice().split(',') {\n+    debug!(\"found dylib deps: {}\", formats.as_str());\n+    for spec in formats.as_str().split(',') {\n         if spec.is_empty() { continue }\n-        let cnum = spec.split(':').nth(0).unwrap();\n-        let link = spec.split(':').nth(1).unwrap();\n+        let mut split = spec.split(':');\n+        let cnum = split.next().unwrap();\n+        let link = split.next().unwrap();\n         let cnum: ast::CrateNum = cnum.parse().unwrap();\n         let cnum = cdata.cnum_map.borrow()[cnum];\n         result.push((cnum, if link == \"d\" {\n@@ -1476,7 +1477,7 @@ pub fn get_method_arg_names(cdata: Cmd, id: DefIndex) -> Vec<String> {\n     match reader::maybe_get_doc(method_doc, tag_method_argument_names) {\n         Some(args_doc) => {\n             reader::tagged_docs(args_doc, tag_method_argument_name).map(|name_doc| {\n-                name_doc.as_str_slice().to_string()\n+                name_doc.as_str().to_string()\n             }).collect()\n         },\n         None => vec![],\n@@ -1641,7 +1642,7 @@ fn item_def_key(item_doc: rbml::Doc) -> hir_map::DefKey {\n             let mut decoder = reader::Decoder::new(def_key_doc);\n             let simple_key = def_key::DefKey::decode(&mut decoder).unwrap();\n             let name = reader::maybe_get_doc(item_doc, tag_paths_data_name).map(|name| {\n-                token::intern(name.as_str_slice()).as_str()\n+                token::intern(name.as_str()).as_str()\n             });\n             def_key::recover_def_key(simple_key, name)\n         }"}, {"sha": "21716d55ac6fa33c67d950d467f4d49deae26574", "filename": "src/librustc_trans/debuginfo/create_scope_map.rs", "status": "modified", "additions": 40, "deletions": 8, "changes": 48, "blob_url": "https://github.com/rust-lang/rust/blob/17a2be8c3571eaff1f09556febe68d8ab733ecf6/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17a2be8c3571eaff1f09556febe68d8ab733ecf6/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fcreate_scope_map.rs?ref=17a2be8c3571eaff1f09556febe68d8ab733ecf6", "patch": "@@ -25,11 +25,33 @@ use syntax_pos::Pos;\n use rustc_data_structures::bitvec::BitVector;\n use rustc_data_structures::indexed_vec::{Idx, IndexVec};\n \n+use syntax_pos::BytePos;\n+\n+#[derive(Clone, Copy, Debug)]\n+pub struct MirDebugScope {\n+    pub scope_metadata: DIScope,\n+    // Start and end offsets of the file to which this DIScope belongs.\n+    // These are used to quickly determine whether some span refers to the same file.\n+    pub file_start_pos: BytePos,\n+    pub file_end_pos: BytePos,\n+}\n+\n+impl MirDebugScope {\n+    pub fn is_valid(&self) -> bool {\n+        !self.scope_metadata.is_null()\n+    }\n+}\n+\n /// Produce DIScope DIEs for each MIR Scope which has variables defined in it.\n /// If debuginfo is disabled, the returned vector is empty.\n-pub fn create_mir_scopes(fcx: &FunctionContext) -> IndexVec<VisibilityScope, DIScope> {\n+pub fn create_mir_scopes(fcx: &FunctionContext) -> IndexVec<VisibilityScope, MirDebugScope> {\n     let mir = fcx.mir.clone().expect(\"create_mir_scopes: missing MIR for fn\");\n-    let mut scopes = IndexVec::from_elem(ptr::null_mut(), &mir.visibility_scopes);\n+    let null_scope = MirDebugScope {\n+        scope_metadata: ptr::null_mut(),\n+        file_start_pos: BytePos(0),\n+        file_end_pos: BytePos(0)\n+    };\n+    let mut scopes = IndexVec::from_elem(null_scope, &mir.visibility_scopes);\n \n     let fn_metadata = match fcx.debug_context {\n         FunctionDebugContext::RegularContext(box ref data) => data.fn_metadata,\n@@ -59,8 +81,8 @@ fn make_mir_scope(ccx: &CrateContext,\n                   has_variables: &BitVector,\n                   fn_metadata: DISubprogram,\n                   scope: VisibilityScope,\n-                  scopes: &mut IndexVec<VisibilityScope, DIScope>) {\n-    if !scopes[scope].is_null() {\n+                  scopes: &mut IndexVec<VisibilityScope, MirDebugScope>) {\n+    if scopes[scope].is_valid() {\n         return;\n     }\n \n@@ -70,7 +92,12 @@ fn make_mir_scope(ccx: &CrateContext,\n         scopes[parent]\n     } else {\n         // The root is the function itself.\n-        scopes[scope] = fn_metadata;\n+        let loc = span_start(ccx, mir.span);\n+        scopes[scope] = MirDebugScope {\n+            scope_metadata: fn_metadata,\n+            file_start_pos: loc.file.start_pos,\n+            file_end_pos: loc.file.end_pos,\n+        };\n         return;\n     };\n \n@@ -81,20 +108,25 @@ fn make_mir_scope(ccx: &CrateContext,\n         // However, we don't skip creating a nested scope if\n         // our parent is the root, because we might want to\n         // put arguments in the root and not have shadowing.\n-        if parent_scope != fn_metadata {\n+        if parent_scope.scope_metadata != fn_metadata {\n             scopes[scope] = parent_scope;\n             return;\n         }\n     }\n \n     let loc = span_start(ccx, scope_data.span);\n-    scopes[scope] = unsafe {\n     let file_metadata = file_metadata(ccx, &loc.file.name, &loc.file.abs_path);\n+    let scope_metadata = unsafe {\n         llvm::LLVMRustDIBuilderCreateLexicalBlock(\n             DIB(ccx),\n-            parent_scope,\n+            parent_scope.scope_metadata,\n             file_metadata,\n             loc.line as c_uint,\n             loc.col.to_usize() as c_uint)\n     };\n+    scopes[scope] = MirDebugScope {\n+        scope_metadata: scope_metadata,\n+        file_start_pos: loc.file.start_pos,\n+        file_end_pos: loc.file.end_pos,\n+    };\n }"}, {"sha": "fccb326b23221ecc0c69f1923bff6979947fc265", "filename": "src/librustc_trans/debuginfo/metadata.rs", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/17a2be8c3571eaff1f09556febe68d8ab733ecf6/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17a2be8c3571eaff1f09556febe68d8ab733ecf6/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmetadata.rs?ref=17a2be8c3571eaff1f09556febe68d8ab733ecf6", "patch": "@@ -22,7 +22,7 @@ use context::SharedCrateContext;\n use session::Session;\n \n use llvm::{self, ValueRef};\n-use llvm::debuginfo::{DIType, DIFile, DIScope, DIDescriptor, DICompositeType};\n+use llvm::debuginfo::{DIType, DIFile, DIScope, DIDescriptor, DICompositeType, DILexicalBlock};\n \n use rustc::hir::def_id::DefId;\n use rustc::ty::subst::Substs;\n@@ -1839,3 +1839,17 @@ pub fn create_global_var_metadata(cx: &CrateContext,\n                                                     ptr::null_mut());\n     }\n }\n+\n+// Creates an \"extension\" of an existing DIScope into another file.\n+pub fn extend_scope_to_file(ccx: &CrateContext,\n+                            scope_metadata: DIScope,\n+                            file: &syntax_pos::FileMap)\n+                            -> DILexicalBlock {\n+    let file_metadata = file_metadata(ccx, &file.name, &file.abs_path);\n+    unsafe {\n+        llvm::LLVMRustDIBuilderCreateLexicalBlockFile(\n+            DIB(ccx),\n+            scope_metadata,\n+            file_metadata)\n+    }\n+}\n\\ No newline at end of file"}, {"sha": "58425cf60d5500767513c864eb47362fdeac5c5f", "filename": "src/librustc_trans/debuginfo/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/17a2be8c3571eaff1f09556febe68d8ab733ecf6/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17a2be8c3571eaff1f09556febe68d8ab733ecf6/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fdebuginfo%2Fmod.rs?ref=17a2be8c3571eaff1f09556febe68d8ab733ecf6", "patch": "@@ -53,9 +53,10 @@ pub mod metadata;\n mod create_scope_map;\n mod source_loc;\n \n-pub use self::create_scope_map::create_mir_scopes;\n+pub use self::create_scope_map::{create_mir_scopes, MirDebugScope};\n pub use self::source_loc::start_emitting_source_locations;\n pub use self::metadata::create_global_var_metadata;\n+pub use self::metadata::extend_scope_to_file;\n \n #[allow(non_upper_case_globals)]\n const DW_TAG_auto_variable: c_uint = 0x100;"}, {"sha": "66eb78aef07b4f0fc7b5bde612daf4996261bed9", "filename": "src/librustc_trans/mir/analyze.rs", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/17a2be8c3571eaff1f09556febe68d8ab733ecf6/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17a2be8c3571eaff1f09556febe68d8ab733ecf6/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fanalyze.rs?ref=17a2be8c3571eaff1f09556febe68d8ab733ecf6", "patch": "@@ -48,6 +48,12 @@ pub fn lvalue_locals<'bcx, 'tcx>(bcx: Block<'bcx,'tcx>,\n                     common::type_is_fat_ptr(bcx.tcx(), ty));\n         } else if common::type_is_imm_pair(bcx.ccx(), ty) {\n             // We allow pairs and uses of any of their 2 fields.\n+        } else if !analyzer.seen_assigned.contains(index) {\n+            // No assignment has been seen, which means that\n+            // either the local has been marked as lvalue\n+            // already, or there is no possible initialization\n+            // for the local, making any reads invalid.\n+            // This is useful in weeding out dead temps.\n         } else {\n             // These sorts of types require an alloca. Note that\n             // type_is_immediate() may *still* be true, particularly"}, {"sha": "1934f7b870d187be0f06dbd18ca2b306a20c7570", "filename": "src/librustc_trans/mir/mod.rs", "status": "modified", "additions": 100, "deletions": 41, "changes": 141, "blob_url": "https://github.com/rust-lang/rust/blob/17a2be8c3571eaff1f09556febe68d8ab733ecf6/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17a2be8c3571eaff1f09556febe68d8ab733ecf6/src%2Flibrustc_trans%2Fmir%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_trans%2Fmir%2Fmod.rs?ref=17a2be8c3571eaff1f09556febe68d8ab733ecf6", "patch": "@@ -10,18 +10,17 @@\n \n use libc::c_uint;\n use llvm::{self, ValueRef};\n-use llvm::debuginfo::DIScope;\n use rustc::ty;\n use rustc::mir::repr as mir;\n use rustc::mir::tcx::LvalueTy;\n use session::config::FullDebugInfo;\n use base;\n use common::{self, Block, BlockAndBuilder, CrateContext, FunctionContext, C_null};\n-use debuginfo::{self, declare_local, DebugLoc, VariableAccess, VariableKind};\n+use debuginfo::{self, declare_local, DebugLoc, VariableAccess, VariableKind, FunctionDebugContext};\n use machine;\n use type_of;\n \n-use syntax_pos::DUMMY_SP;\n+use syntax_pos::{DUMMY_SP, NO_EXPANSION, COMMAND_LINE_EXPN, BytePos};\n use syntax::parse::token::keywords;\n \n use std::ops::Deref;\n@@ -103,12 +102,67 @@ pub struct MirContext<'bcx, 'tcx:'bcx> {\n     locals: IndexVec<mir::Local, LocalRef<'tcx>>,\n \n     /// Debug information for MIR scopes.\n-    scopes: IndexVec<mir::VisibilityScope, DIScope>\n+    scopes: IndexVec<mir::VisibilityScope, debuginfo::MirDebugScope>,\n }\n \n impl<'blk, 'tcx> MirContext<'blk, 'tcx> {\n-    pub fn debug_loc(&self, source_info: mir::SourceInfo) -> DebugLoc {\n-        DebugLoc::ScopeAt(self.scopes[source_info.scope], source_info.span)\n+    pub fn debug_loc(&mut self, source_info: mir::SourceInfo) -> DebugLoc {\n+        // Bail out if debug info emission is not enabled.\n+        match self.fcx.debug_context {\n+            FunctionDebugContext::DebugInfoDisabled |\n+            FunctionDebugContext::FunctionWithoutDebugInfo => {\n+                // Can't return DebugLoc::None here because intrinsic::trans_intrinsic_call()\n+                // relies on debug location to obtain span of the call site.\n+                return DebugLoc::ScopeAt(self.scopes[source_info.scope].scope_metadata,\n+                                         source_info.span);\n+            }\n+            FunctionDebugContext::RegularContext(_) =>{}\n+        }\n+\n+        // In order to have a good line stepping behavior in debugger, we overwrite debug\n+        // locations of macro expansions with that of the outermost expansion site\n+        // (unless the crate is being compiled with `-Z debug-macros`).\n+        if source_info.span.expn_id == NO_EXPANSION ||\n+            source_info.span.expn_id == COMMAND_LINE_EXPN ||\n+            self.fcx.ccx.sess().opts.debugging_opts.debug_macros {\n+\n+            let scope_metadata = self.scope_metadata_for_loc(source_info.scope,\n+                                                             source_info.span.lo);\n+            DebugLoc::ScopeAt(scope_metadata, source_info.span)\n+        } else {\n+            let cm = self.fcx.ccx.sess().codemap();\n+            // Walk up the macro expansion chain until we reach a non-expanded span.\n+            let mut span = source_info.span;\n+            while span.expn_id != NO_EXPANSION && span.expn_id != COMMAND_LINE_EXPN {\n+                if let Some(callsite_span) = cm.with_expn_info(span.expn_id,\n+                                                    |ei| ei.map(|ei| ei.call_site.clone())) {\n+                    span = callsite_span;\n+                } else {\n+                    break;\n+                }\n+            }\n+            let scope_metadata = self.scope_metadata_for_loc(source_info.scope, span.lo);\n+            // Use span of the outermost call site, while keeping the original lexical scope\n+            DebugLoc::ScopeAt(scope_metadata, span)\n+        }\n+    }\n+\n+    // DILocations inherit source file name from the parent DIScope.  Due to macro expansions\n+    // it may so happen that the current span belongs to a different file than the DIScope\n+    // corresponding to span's containing visibility scope.  If so, we need to create a DIScope\n+    // \"extension\" into that file.\n+    fn scope_metadata_for_loc(&self, scope_id: mir::VisibilityScope, pos: BytePos)\n+                               -> llvm::debuginfo::DIScope {\n+        let scope_metadata = self.scopes[scope_id].scope_metadata;\n+        if pos < self.scopes[scope_id].file_start_pos ||\n+           pos >= self.scopes[scope_id].file_end_pos {\n+            let cm = self.fcx.ccx.sess().codemap();\n+            debuginfo::extend_scope_to_file(self.fcx.ccx,\n+                                            scope_metadata,\n+                                            &cm.lookup_char_pos(pos).file)\n+        } else {\n+            scope_metadata\n+        }\n     }\n }\n \n@@ -155,16 +209,38 @@ pub fn trans_mir<'blk, 'tcx: 'blk>(fcx: &'blk FunctionContext<'blk, 'tcx>) {\n          analyze::cleanup_kinds(bcx, &mir))\n     });\n \n+    // Allocate a `Block` for every basic block\n+    let block_bcxs: IndexVec<mir::BasicBlock, Block<'blk,'tcx>> =\n+        mir.basic_blocks().indices().map(|bb| {\n+            if bb == mir::START_BLOCK {\n+                fcx.new_block(\"start\")\n+            } else {\n+                fcx.new_block(&format!(\"{:?}\", bb))\n+            }\n+        }).collect();\n+\n     // Compute debuginfo scopes from MIR scopes.\n     let scopes = debuginfo::create_mir_scopes(fcx);\n \n+    let mut mircx = MirContext {\n+        mir: mir.clone(),\n+        fcx: fcx,\n+        llpersonalityslot: None,\n+        blocks: block_bcxs,\n+        unreachable_block: None,\n+        cleanup_kinds: cleanup_kinds,\n+        landing_pads: IndexVec::from_elem(None, mir.basic_blocks()),\n+        scopes: scopes,\n+        locals: IndexVec::new(),\n+    };\n+\n     // Allocate variable and temp allocas\n-    let locals = {\n-        let args = arg_local_refs(&bcx, &mir, &scopes, &lvalue_locals);\n+    mircx.locals = {\n+        let args = arg_local_refs(&bcx, &mir, &mircx.scopes, &lvalue_locals);\n         let vars = mir.var_decls.iter().enumerate().map(|(i, decl)| {\n             let ty = bcx.monomorphize(&decl.ty);\n-            let scope = scopes[decl.source_info.scope];\n-            let dbg = !scope.is_null() && bcx.sess().opts.debuginfo == FullDebugInfo;\n+            let debug_scope = mircx.scopes[decl.source_info.scope];\n+            let dbg = debug_scope.is_valid() && bcx.sess().opts.debuginfo == FullDebugInfo;\n \n             let local = mir.local_index(&mir::Lvalue::Var(mir::Var::new(i))).unwrap();\n             if !lvalue_locals.contains(local.index()) && !dbg {\n@@ -173,11 +249,16 @@ pub fn trans_mir<'blk, 'tcx: 'blk>(fcx: &'blk FunctionContext<'blk, 'tcx>) {\n \n             let lvalue = LvalueRef::alloca(&bcx, ty, &decl.name.as_str());\n             if dbg {\n-                bcx.with_block(|bcx| {\n-                    declare_local(bcx, decl.name, ty, scope,\n-                                VariableAccess::DirectVariable { alloca: lvalue.llval },\n-                                VariableKind::LocalVariable, decl.source_info.span);\n-                });\n+                let dbg_loc = mircx.debug_loc(decl.source_info);\n+                if let DebugLoc::ScopeAt(scope, span) = dbg_loc {\n+                    bcx.with_block(|bcx| {\n+                        declare_local(bcx, decl.name, ty, scope,\n+                                    VariableAccess::DirectVariable { alloca: lvalue.llval },\n+                                    VariableKind::LocalVariable, span);\n+                    });\n+                } else {\n+                    panic!(\"Unexpected\");\n+                }\n             }\n             LocalRef::Lvalue(lvalue)\n         });\n@@ -203,37 +284,15 @@ pub fn trans_mir<'blk, 'tcx: 'blk>(fcx: &'blk FunctionContext<'blk, 'tcx>) {\n         })).collect()\n     };\n \n-    // Allocate a `Block` for every basic block\n-    let block_bcxs: IndexVec<mir::BasicBlock, Block<'blk,'tcx>> =\n-        mir.basic_blocks().indices().map(|bb| {\n-            if bb == mir::START_BLOCK {\n-                fcx.new_block(\"start\")\n-            } else {\n-                fcx.new_block(&format!(\"{:?}\", bb))\n-            }\n-        }).collect();\n-\n     // Branch to the START block\n-    let start_bcx = block_bcxs[mir::START_BLOCK];\n+    let start_bcx = mircx.blocks[mir::START_BLOCK];\n     bcx.br(start_bcx.llbb);\n \n     // Up until here, IR instructions for this function have explicitly not been annotated with\n     // source code location, so we don't step into call setup code. From here on, source location\n     // emitting should be enabled.\n     debuginfo::start_emitting_source_locations(fcx);\n \n-    let mut mircx = MirContext {\n-        mir: mir.clone(),\n-        fcx: fcx,\n-        llpersonalityslot: None,\n-        blocks: block_bcxs,\n-        unreachable_block: None,\n-        cleanup_kinds: cleanup_kinds,\n-        landing_pads: IndexVec::from_elem(None, mir.basic_blocks()),\n-        locals: locals,\n-        scopes: scopes\n-    };\n-\n     let mut visited = BitVector::new(mir.basic_blocks().len());\n \n     let mut rpo = traversal::reverse_postorder(&mir);\n@@ -271,7 +330,7 @@ pub fn trans_mir<'blk, 'tcx: 'blk>(fcx: &'blk FunctionContext<'blk, 'tcx>) {\n /// indirect.\n fn arg_local_refs<'bcx, 'tcx>(bcx: &BlockAndBuilder<'bcx, 'tcx>,\n                               mir: &mir::Mir<'tcx>,\n-                              scopes: &IndexVec<mir::VisibilityScope, DIScope>,\n+                              scopes: &IndexVec<mir::VisibilityScope, debuginfo::MirDebugScope>,\n                               lvalue_locals: &BitVector)\n                               -> Vec<LocalRef<'tcx>> {\n     let fcx = bcx.fcx();\n@@ -281,8 +340,8 @@ fn arg_local_refs<'bcx, 'tcx>(bcx: &BlockAndBuilder<'bcx, 'tcx>,\n \n     // Get the argument scope, if it exists and if we need it.\n     let arg_scope = scopes[mir::ARGUMENT_VISIBILITY_SCOPE];\n-    let arg_scope = if !arg_scope.is_null() && bcx.sess().opts.debuginfo == FullDebugInfo {\n-        Some(arg_scope)\n+    let arg_scope = if arg_scope.is_valid() && bcx.sess().opts.debuginfo == FullDebugInfo {\n+        Some(arg_scope.scope_metadata)\n     } else {\n         None\n     };"}, {"sha": "e2e655ce38bccc807f04796d12b39ede5aeb0b24", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 134, "deletions": 104, "changes": 238, "blob_url": "https://github.com/rust-lang/rust/blob/17a2be8c3571eaff1f09556febe68d8ab733ecf6/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17a2be8c3571eaff1f09556febe68d8ab733ecf6/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=17a2be8c3571eaff1f09556febe68d8ab733ecf6", "patch": "@@ -12,7 +12,6 @@\n //! that clean them.\n \n pub use self::Type::*;\n-pub use self::PrimitiveType::*;\n pub use self::TypeKind::*;\n pub use self::VariantKind::*;\n pub use self::Mutability::*;\n@@ -287,34 +286,34 @@ impl Item {\n         }\n     }\n     pub fn is_mod(&self) -> bool {\n-        ItemType::from_item(self) == ItemType::Module\n+        ItemType::from(self) == ItemType::Module\n     }\n     pub fn is_trait(&self) -> bool {\n-        ItemType::from_item(self) == ItemType::Trait\n+        ItemType::from(self) == ItemType::Trait\n     }\n     pub fn is_struct(&self) -> bool {\n-        ItemType::from_item(self) == ItemType::Struct\n+        ItemType::from(self) == ItemType::Struct\n     }\n     pub fn is_enum(&self) -> bool {\n-        ItemType::from_item(self) == ItemType::Module\n+        ItemType::from(self) == ItemType::Module\n     }\n     pub fn is_fn(&self) -> bool {\n-        ItemType::from_item(self) == ItemType::Function\n+        ItemType::from(self) == ItemType::Function\n     }\n     pub fn is_associated_type(&self) -> bool {\n-        ItemType::from_item(self) == ItemType::AssociatedType\n+        ItemType::from(self) == ItemType::AssociatedType\n     }\n     pub fn is_associated_const(&self) -> bool {\n-        ItemType::from_item(self) == ItemType::AssociatedConst\n+        ItemType::from(self) == ItemType::AssociatedConst\n     }\n     pub fn is_method(&self) -> bool {\n-        ItemType::from_item(self) == ItemType::Method\n+        ItemType::from(self) == ItemType::Method\n     }\n     pub fn is_ty_method(&self) -> bool {\n-        ItemType::from_item(self) == ItemType::TyMethod\n+        ItemType::from(self) == ItemType::TyMethod\n     }\n     pub fn is_primitive(&self) -> bool {\n-        ItemType::from_item(self) == ItemType::Primitive\n+        ItemType::from(self) == ItemType::Primitive\n     }\n     pub fn is_stripped(&self) -> bool {\n         match self.inner { StrippedItem(..) => true, _ => false }\n@@ -380,6 +379,23 @@ pub enum ItemEnum {\n     StrippedItem(Box<ItemEnum>),\n }\n \n+impl ItemEnum {\n+    pub fn generics(&self) -> Option<&Generics> {\n+        Some(match *self {\n+            ItemEnum::StructItem(ref s) => &s.generics,\n+            ItemEnum::EnumItem(ref e) => &e.generics,\n+            ItemEnum::FunctionItem(ref f) => &f.generics,\n+            ItemEnum::TypedefItem(ref t, _) => &t.generics,\n+            ItemEnum::TraitItem(ref t) => &t.generics,\n+            ItemEnum::ImplItem(ref i) => &i.generics,\n+            ItemEnum::TyMethodItem(ref i) => &i.generics,\n+            ItemEnum::MethodItem(ref i) => &i.generics,\n+            ItemEnum::ForeignFunctionItem(ref f) => &f.generics,\n+            _ => return None,\n+        })\n+    }\n+}\n+\n #[derive(Clone, RustcEncodable, RustcDecodable, Debug)]\n pub struct Module {\n     pub items: Vec<Item>,\n@@ -1469,8 +1485,8 @@ pub enum PrimitiveType {\n     Str,\n     Slice,\n     Array,\n-    PrimitiveTuple,\n-    PrimitiveRawPointer,\n+    Tuple,\n+    RawPointer,\n }\n \n #[derive(Clone, RustcEncodable, RustcDecodable, Copy, Debug)]\n@@ -1500,12 +1516,12 @@ impl Type {\n     pub fn primitive_type(&self) -> Option<PrimitiveType> {\n         match *self {\n             Primitive(p) | BorrowedRef { type_: box Primitive(p), ..} => Some(p),\n-            Vector(..) | BorrowedRef{ type_: box Vector(..), ..  } => Some(Slice),\n+            Vector(..) | BorrowedRef{ type_: box Vector(..), ..  } => Some(PrimitiveType::Slice),\n             FixedVector(..) | BorrowedRef { type_: box FixedVector(..), .. } => {\n-                Some(Array)\n+                Some(PrimitiveType::Array)\n             }\n-            Tuple(..) => Some(PrimitiveTuple),\n-            RawPointer(..) => Some(PrimitiveRawPointer),\n+            Tuple(..) => Some(PrimitiveType::Tuple),\n+            RawPointer(..) => Some(PrimitiveType::RawPointer),\n             _ => None,\n         }\n     }\n@@ -1530,25 +1546,25 @@ impl GetDefId for Type {\n impl PrimitiveType {\n     fn from_str(s: &str) -> Option<PrimitiveType> {\n         match s {\n-            \"isize\" => Some(Isize),\n-            \"i8\" => Some(I8),\n-            \"i16\" => Some(I16),\n-            \"i32\" => Some(I32),\n-            \"i64\" => Some(I64),\n-            \"usize\" => Some(Usize),\n-            \"u8\" => Some(U8),\n-            \"u16\" => Some(U16),\n-            \"u32\" => Some(U32),\n-            \"u64\" => Some(U64),\n-            \"bool\" => Some(Bool),\n-            \"char\" => Some(Char),\n-            \"str\" => Some(Str),\n-            \"f32\" => Some(F32),\n-            \"f64\" => Some(F64),\n-            \"array\" => Some(Array),\n-            \"slice\" => Some(Slice),\n-            \"tuple\" => Some(PrimitiveTuple),\n-            \"pointer\" => Some(PrimitiveRawPointer),\n+            \"isize\" => Some(PrimitiveType::Isize),\n+            \"i8\" => Some(PrimitiveType::I8),\n+            \"i16\" => Some(PrimitiveType::I16),\n+            \"i32\" => Some(PrimitiveType::I32),\n+            \"i64\" => Some(PrimitiveType::I64),\n+            \"usize\" => Some(PrimitiveType::Usize),\n+            \"u8\" => Some(PrimitiveType::U8),\n+            \"u16\" => Some(PrimitiveType::U16),\n+            \"u32\" => Some(PrimitiveType::U32),\n+            \"u64\" => Some(PrimitiveType::U64),\n+            \"bool\" => Some(PrimitiveType::Bool),\n+            \"char\" => Some(PrimitiveType::Char),\n+            \"str\" => Some(PrimitiveType::Str),\n+            \"f32\" => Some(PrimitiveType::F32),\n+            \"f64\" => Some(PrimitiveType::F64),\n+            \"array\" => Some(PrimitiveType::Array),\n+            \"slice\" => Some(PrimitiveType::Slice),\n+            \"tuple\" => Some(PrimitiveType::Tuple),\n+            \"pointer\" => Some(PrimitiveType::RawPointer),\n             _ => None,\n         }\n     }\n@@ -1568,25 +1584,25 @@ impl PrimitiveType {\n \n     pub fn to_string(&self) -> &'static str {\n         match *self {\n-            Isize => \"isize\",\n-            I8 => \"i8\",\n-            I16 => \"i16\",\n-            I32 => \"i32\",\n-            I64 => \"i64\",\n-            Usize => \"usize\",\n-            U8 => \"u8\",\n-            U16 => \"u16\",\n-            U32 => \"u32\",\n-            U64 => \"u64\",\n-            F32 => \"f32\",\n-            F64 => \"f64\",\n-            Str => \"str\",\n-            Bool => \"bool\",\n-            Char => \"char\",\n-            Array => \"array\",\n-            Slice => \"slice\",\n-            PrimitiveTuple => \"tuple\",\n-            PrimitiveRawPointer => \"pointer\",\n+            PrimitiveType::Isize => \"isize\",\n+            PrimitiveType::I8 => \"i8\",\n+            PrimitiveType::I16 => \"i16\",\n+            PrimitiveType::I32 => \"i32\",\n+            PrimitiveType::I64 => \"i64\",\n+            PrimitiveType::Usize => \"usize\",\n+            PrimitiveType::U8 => \"u8\",\n+            PrimitiveType::U16 => \"u16\",\n+            PrimitiveType::U32 => \"u32\",\n+            PrimitiveType::U64 => \"u64\",\n+            PrimitiveType::F32 => \"f32\",\n+            PrimitiveType::F64 => \"f64\",\n+            PrimitiveType::Str => \"str\",\n+            PrimitiveType::Bool => \"bool\",\n+            PrimitiveType::Char => \"char\",\n+            PrimitiveType::Array => \"array\",\n+            PrimitiveType::Slice => \"slice\",\n+            PrimitiveType::Tuple => \"tuple\",\n+            PrimitiveType::RawPointer => \"pointer\",\n         }\n     }\n \n@@ -1603,6 +1619,38 @@ impl PrimitiveType {\n     }\n }\n \n+impl From<ast::IntTy> for PrimitiveType {\n+    fn from(int_ty: ast::IntTy) -> PrimitiveType {\n+        match int_ty {\n+            ast::IntTy::Is => PrimitiveType::Isize,\n+            ast::IntTy::I8 => PrimitiveType::I8,\n+            ast::IntTy::I16 => PrimitiveType::I16,\n+            ast::IntTy::I32 => PrimitiveType::I32,\n+            ast::IntTy::I64 => PrimitiveType::I64,\n+        }\n+    }\n+}\n+\n+impl From<ast::UintTy> for PrimitiveType {\n+    fn from(uint_ty: ast::UintTy) -> PrimitiveType {\n+        match uint_ty {\n+            ast::UintTy::Us => PrimitiveType::Usize,\n+            ast::UintTy::U8 => PrimitiveType::U8,\n+            ast::UintTy::U16 => PrimitiveType::U16,\n+            ast::UintTy::U32 => PrimitiveType::U32,\n+            ast::UintTy::U64 => PrimitiveType::U64,\n+        }\n+    }\n+}\n+\n+impl From<ast::FloatTy> for PrimitiveType {\n+    fn from(float_ty: ast::FloatTy) -> PrimitiveType {\n+        match float_ty {\n+            ast::FloatTy::F32 => PrimitiveType::F32,\n+            ast::FloatTy::F64 => PrimitiveType::F64,\n+        }\n+    }\n+}\n \n // Poor man's type parameter substitution at HIR level.\n // Used to replace private type aliases in public signatures with their aliased types.\n@@ -1754,21 +1802,12 @@ impl<'tcx> Clean<Type> for ty::Ty<'tcx> {\n     fn clean(&self, cx: &DocContext) -> Type {\n         match self.sty {\n             ty::TyNever => Never,\n-            ty::TyBool => Primitive(Bool),\n-            ty::TyChar => Primitive(Char),\n-            ty::TyInt(ast::IntTy::Is) => Primitive(Isize),\n-            ty::TyInt(ast::IntTy::I8) => Primitive(I8),\n-            ty::TyInt(ast::IntTy::I16) => Primitive(I16),\n-            ty::TyInt(ast::IntTy::I32) => Primitive(I32),\n-            ty::TyInt(ast::IntTy::I64) => Primitive(I64),\n-            ty::TyUint(ast::UintTy::Us) => Primitive(Usize),\n-            ty::TyUint(ast::UintTy::U8) => Primitive(U8),\n-            ty::TyUint(ast::UintTy::U16) => Primitive(U16),\n-            ty::TyUint(ast::UintTy::U32) => Primitive(U32),\n-            ty::TyUint(ast::UintTy::U64) => Primitive(U64),\n-            ty::TyFloat(ast::FloatTy::F32) => Primitive(F32),\n-            ty::TyFloat(ast::FloatTy::F64) => Primitive(F64),\n-            ty::TyStr => Primitive(Str),\n+            ty::TyBool => Primitive(PrimitiveType::Bool),\n+            ty::TyChar => Primitive(PrimitiveType::Char),\n+            ty::TyInt(int_ty) => Primitive(int_ty.into()),\n+            ty::TyUint(uint_ty) => Primitive(uint_ty.into()),\n+            ty::TyFloat(float_ty) => Primitive(float_ty.into()),\n+            ty::TyStr => Primitive(PrimitiveType::Str),\n             ty::TyBox(t) => {\n                 let box_did = cx.tcx_opt().and_then(|tcx| {\n                     tcx.lang_items.owned_box()\n@@ -2421,25 +2460,25 @@ fn build_deref_target_impls(cx: &DocContext,\n             }\n         };\n         let did = match primitive {\n-            Isize => tcx.lang_items.isize_impl(),\n-            I8 => tcx.lang_items.i8_impl(),\n-            I16 => tcx.lang_items.i16_impl(),\n-            I32 => tcx.lang_items.i32_impl(),\n-            I64 => tcx.lang_items.i64_impl(),\n-            Usize => tcx.lang_items.usize_impl(),\n-            U8 => tcx.lang_items.u8_impl(),\n-            U16 => tcx.lang_items.u16_impl(),\n-            U32 => tcx.lang_items.u32_impl(),\n-            U64 => tcx.lang_items.u64_impl(),\n-            F32 => tcx.lang_items.f32_impl(),\n-            F64 => tcx.lang_items.f64_impl(),\n-            Char => tcx.lang_items.char_impl(),\n-            Bool => None,\n-            Str => tcx.lang_items.str_impl(),\n-            Slice => tcx.lang_items.slice_impl(),\n-            Array => tcx.lang_items.slice_impl(),\n-            PrimitiveTuple => None,\n-            PrimitiveRawPointer => tcx.lang_items.const_ptr_impl(),\n+            PrimitiveType::Isize => tcx.lang_items.isize_impl(),\n+            PrimitiveType::I8 => tcx.lang_items.i8_impl(),\n+            PrimitiveType::I16 => tcx.lang_items.i16_impl(),\n+            PrimitiveType::I32 => tcx.lang_items.i32_impl(),\n+            PrimitiveType::I64 => tcx.lang_items.i64_impl(),\n+            PrimitiveType::Usize => tcx.lang_items.usize_impl(),\n+            PrimitiveType::U8 => tcx.lang_items.u8_impl(),\n+            PrimitiveType::U16 => tcx.lang_items.u16_impl(),\n+            PrimitiveType::U32 => tcx.lang_items.u32_impl(),\n+            PrimitiveType::U64 => tcx.lang_items.u64_impl(),\n+            PrimitiveType::F32 => tcx.lang_items.f32_impl(),\n+            PrimitiveType::F64 => tcx.lang_items.f64_impl(),\n+            PrimitiveType::Char => tcx.lang_items.char_impl(),\n+            PrimitiveType::Bool => None,\n+            PrimitiveType::Str => tcx.lang_items.str_impl(),\n+            PrimitiveType::Slice => tcx.lang_items.slice_impl(),\n+            PrimitiveType::Array => tcx.lang_items.slice_impl(),\n+            PrimitiveType::Tuple => None,\n+            PrimitiveType::RawPointer => tcx.lang_items.const_ptr_impl(),\n         };\n         if let Some(did) = did {\n             if !did.is_local() {\n@@ -2722,21 +2761,12 @@ fn resolve_type(cx: &DocContext,\n \n     let is_generic = match def {\n         Def::PrimTy(p) => match p {\n-            hir::TyStr => return Primitive(Str),\n-            hir::TyBool => return Primitive(Bool),\n-            hir::TyChar => return Primitive(Char),\n-            hir::TyInt(ast::IntTy::Is) => return Primitive(Isize),\n-            hir::TyInt(ast::IntTy::I8) => return Primitive(I8),\n-            hir::TyInt(ast::IntTy::I16) => return Primitive(I16),\n-            hir::TyInt(ast::IntTy::I32) => return Primitive(I32),\n-            hir::TyInt(ast::IntTy::I64) => return Primitive(I64),\n-            hir::TyUint(ast::UintTy::Us) => return Primitive(Usize),\n-            hir::TyUint(ast::UintTy::U8) => return Primitive(U8),\n-            hir::TyUint(ast::UintTy::U16) => return Primitive(U16),\n-            hir::TyUint(ast::UintTy::U32) => return Primitive(U32),\n-            hir::TyUint(ast::UintTy::U64) => return Primitive(U64),\n-            hir::TyFloat(ast::FloatTy::F32) => return Primitive(F32),\n-            hir::TyFloat(ast::FloatTy::F64) => return Primitive(F64),\n+            hir::TyStr => return Primitive(PrimitiveType::Str),\n+            hir::TyBool => return Primitive(PrimitiveType::Bool),\n+            hir::TyChar => return Primitive(PrimitiveType::Char),\n+            hir::TyInt(int_ty) => return Primitive(int_ty.into()),\n+            hir::TyUint(uint_ty) => return Primitive(uint_ty.into()),\n+            hir::TyFloat(float_ty) => return Primitive(float_ty.into()),\n         },\n         Def::SelfTy(..) if path.segments.len() == 1 => {\n             return Generic(keywords::SelfType.name().to_string());"}, {"sha": "65992798ab0995382ef32a4457c53e42347c00a6", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/rust-lang/rust/blob/17a2be8c3571eaff1f09556febe68d8ab733ecf6/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17a2be8c3571eaff1f09556febe68d8ab733ecf6/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=17a2be8c3571eaff1f09556febe68d8ab733ecf6", "patch": "@@ -23,7 +23,7 @@ use rustc::hir::def_id::DefId;\n use syntax::abi::Abi;\n use rustc::hir;\n \n-use clean;\n+use clean::{self, PrimitiveType};\n use core::DocAccessLevels;\n use html::item_type::ItemType;\n use html::escape::Escape;\n@@ -468,39 +468,39 @@ impl fmt::Display for clean::Type {\n             }\n             clean::Tuple(ref typs) => {\n                 match &typs[..] {\n-                    &[] => primitive_link(f, clean::PrimitiveTuple, \"()\"),\n+                    &[] => primitive_link(f, PrimitiveType::Tuple, \"()\"),\n                     &[ref one] => {\n-                        primitive_link(f, clean::PrimitiveTuple, \"(\")?;\n+                        primitive_link(f, PrimitiveType::Tuple, \"(\")?;\n                         write!(f, \"{},\", one)?;\n-                        primitive_link(f, clean::PrimitiveTuple, \")\")\n+                        primitive_link(f, PrimitiveType::Tuple, \")\")\n                     }\n                     many => {\n-                        primitive_link(f, clean::PrimitiveTuple, \"(\")?;\n+                        primitive_link(f, PrimitiveType::Tuple, \"(\")?;\n                         write!(f, \"{}\", CommaSep(&many))?;\n-                        primitive_link(f, clean::PrimitiveTuple, \")\")\n+                        primitive_link(f, PrimitiveType::Tuple, \")\")\n                     }\n                 }\n             }\n             clean::Vector(ref t) => {\n-                primitive_link(f, clean::Slice, &format!(\"[\"))?;\n+                primitive_link(f, PrimitiveType::Slice, &format!(\"[\"))?;\n                 write!(f, \"{}\", t)?;\n-                primitive_link(f, clean::Slice, &format!(\"]\"))\n+                primitive_link(f, PrimitiveType::Slice, &format!(\"]\"))\n             }\n             clean::FixedVector(ref t, ref s) => {\n-                primitive_link(f, clean::PrimitiveType::Array, \"[\")?;\n+                primitive_link(f, PrimitiveType::Array, \"[\")?;\n                 write!(f, \"{}\", t)?;\n-                primitive_link(f, clean::PrimitiveType::Array,\n+                primitive_link(f, PrimitiveType::Array,\n                                &format!(\"; {}]\", Escape(s)))\n             }\n             clean::Never => f.write_str(\"!\"),\n             clean::RawPointer(m, ref t) => {\n                 match **t {\n                     clean::Generic(_) | clean::ResolvedPath {is_generic: true, ..} => {\n-                        primitive_link(f, clean::PrimitiveType::PrimitiveRawPointer,\n+                        primitive_link(f, clean::PrimitiveType::RawPointer,\n                                        &format!(\"*{}{}\", RawMutableSpace(m), t))\n                     }\n                     _ => {\n-                        primitive_link(f, clean::PrimitiveType::PrimitiveRawPointer,\n+                        primitive_link(f, clean::PrimitiveType::RawPointer,\n                                        &format!(\"*{}\", RawMutableSpace(m)))?;\n                         write!(f, \"{}\", t)\n                     }\n@@ -516,12 +516,13 @@ impl fmt::Display for clean::Type {\n                     clean::Vector(ref bt) => { // BorrowedRef{ ... Vector(T) } is &[T]\n                         match **bt {\n                             clean::Generic(_) =>\n-                                primitive_link(f, clean::Slice,\n+                                primitive_link(f, PrimitiveType::Slice,\n                                     &format!(\"&amp;{}{}[{}]\", lt, m, **bt)),\n                             _ => {\n-                                primitive_link(f, clean::Slice, &format!(\"&amp;{}{}[\", lt, m))?;\n+                                primitive_link(f, PrimitiveType::Slice,\n+                                               &format!(\"&amp;{}{}[\", lt, m))?;\n                                 write!(f, \"{}\", **bt)?;\n-                                primitive_link(f, clean::Slice, \"]\")\n+                                primitive_link(f, PrimitiveType::Slice, \"]\")\n                             }\n                         }\n                     }"}, {"sha": "be192179284676b9b76fa40162cf22c4ef8ffc31", "filename": "src/librustdoc/html/item_type.rs", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/17a2be8c3571eaff1f09556febe68d8ab733ecf6/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17a2be8c3571eaff1f09556febe68d8ab733ecf6/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fitem_type.rs?ref=17a2be8c3571eaff1f09556febe68d8ab733ecf6", "patch": "@@ -50,8 +50,8 @@ pub enum NameSpace {\n     Macro,\n }\n \n-impl ItemType {\n-    pub fn from_item(item: &clean::Item) -> ItemType {\n+impl<'a> From<&'a clean::Item> for ItemType {\n+    fn from(item: &'a clean::Item) -> ItemType {\n         let inner = match item.inner {\n             clean::StrippedItem(box ref item) => item,\n             ref inner@_ => inner,\n@@ -83,8 +83,10 @@ impl ItemType {\n             clean::StrippedItem(..)        => unreachable!(),\n         }\n     }\n+}\n \n-    pub fn from_type_kind(kind: clean::TypeKind) -> ItemType {\n+impl From<clean::TypeKind> for ItemType {\n+    fn from(kind: clean::TypeKind) -> ItemType {\n         match kind {\n             clean::TypeStruct   => ItemType::Struct,\n             clean::TypeEnum     => ItemType::Enum,\n@@ -97,7 +99,9 @@ impl ItemType {\n             clean::TypeTypedef  => ItemType::Typedef,\n         }\n     }\n+}\n \n+impl ItemType {\n     pub fn css_class(&self) -> &'static str {\n         match *self {\n             ItemType::Module          => \"mod\","}, {"sha": "6993f85c3d9a47f1a0d39697f0e04191b760a522", "filename": "src/librustdoc/html/render.rs", "status": "modified", "additions": 18, "deletions": 27, "changes": 45, "blob_url": "https://github.com/rust-lang/rust/blob/17a2be8c3571eaff1f09556febe68d8ab733ecf6/src%2Flibrustdoc%2Fhtml%2Frender.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17a2be8c3571eaff1f09556febe68d8ab733ecf6/src%2Flibrustdoc%2Fhtml%2Frender.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender.rs?ref=17a2be8c3571eaff1f09556febe68d8ab733ecf6", "patch": "@@ -509,7 +509,7 @@ pub fn run(mut krate: clean::Crate,\n     } = renderinfo;\n \n     let external_paths = external_paths.into_iter()\n-        .map(|(k, (v, t))| (k, (v, ItemType::from_type_kind(t))))\n+        .map(|(k, (v, t))| (k, (v, ItemType::from(t))))\n         .collect();\n \n     let mut cache = Cache {\n@@ -833,7 +833,7 @@ fn mkdir(path: &Path) -> io::Result<()> {\n \n /// Returns a documentation-level item type from the item.\n fn item_type(item: &clean::Item) -> ItemType {\n-    ItemType::from_item(item)\n+    ItemType::from(item)\n }\n \n /// Takes a path to a source file and cleans the path to it. This canonicalizes\n@@ -997,17 +997,8 @@ impl DocFolder for Cache {\n \n         // Register any generics to their corresponding string. This is used\n         // when pretty-printing types\n-        match item.inner {\n-            clean::StructItem(ref s)          => self.generics(&s.generics),\n-            clean::EnumItem(ref e)            => self.generics(&e.generics),\n-            clean::FunctionItem(ref f)        => self.generics(&f.generics),\n-            clean::TypedefItem(ref t, _)      => self.generics(&t.generics),\n-            clean::TraitItem(ref t)           => self.generics(&t.generics),\n-            clean::ImplItem(ref i)            => self.generics(&i.generics),\n-            clean::TyMethodItem(ref i)        => self.generics(&i.generics),\n-            clean::MethodItem(ref i)          => self.generics(&i.generics),\n-            clean::ForeignFunctionItem(ref f) => self.generics(&f.generics),\n-            _ => {}\n+        if let Some(generics) = item.inner.generics() {\n+            self.generics(generics);\n         }\n \n         if !self.seen_mod {\n@@ -1362,7 +1353,7 @@ impl Context {\n         // these modules are recursed into, but not rendered normally\n         // (a flag on the context).\n         if !self.render_redirect_pages {\n-            self.render_redirect_pages = self.maybe_ignore_item(&item);\n+            self.render_redirect_pages = maybe_ignore_item(&item);\n         }\n \n         if item.is_mod() {\n@@ -1445,7 +1436,7 @@ impl Context {\n         // BTreeMap instead of HashMap to get a sorted output\n         let mut map = BTreeMap::new();\n         for item in &m.items {\n-            if self.maybe_ignore_item(item) { continue }\n+            if maybe_ignore_item(item) { continue }\n \n             let short = item_type(item).css_class();\n             let myname = match item.name {\n@@ -1462,17 +1453,6 @@ impl Context {\n         }\n         return map;\n     }\n-\n-    fn maybe_ignore_item(&self, it: &clean::Item) -> bool {\n-        match it.inner {\n-            clean::StrippedItem(..) => true,\n-            clean::ModuleItem(ref m) => {\n-                it.doc_value().is_none() && m.items.is_empty()\n-                                         && it.visibility != Some(clean::Public)\n-            },\n-            _ => false,\n-        }\n-    }\n }\n \n impl<'a> Item<'a> {\n@@ -1715,7 +1695,7 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n         if let clean::DefaultImplItem(..) = items[*i].inner {\n             return false;\n         }\n-        !cx.maybe_ignore_item(&items[*i])\n+        !maybe_ignore_item(&items[*i])\n     }).collect::<Vec<usize>>();\n \n     // the order of item types in the listing\n@@ -1863,6 +1843,17 @@ fn item_module(w: &mut fmt::Formatter, cx: &Context,\n     Ok(())\n }\n \n+fn maybe_ignore_item(it: &clean::Item) -> bool {\n+    match it.inner {\n+        clean::StrippedItem(..) => true,\n+        clean::ModuleItem(ref m) => {\n+            it.doc_value().is_none() && m.items.is_empty()\n+                                     && it.visibility != Some(clean::Public)\n+        },\n+        _ => false,\n+    }\n+}\n+\n fn short_stability(item: &clean::Item, cx: &Context, show_reason: bool) -> Vec<String> {\n     let mut stability = vec![];\n "}, {"sha": "82fb2b0918f79fcfedb4f37614103f47bbd1dee3", "filename": "src/rustllvm/RustWrapper.cpp", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/17a2be8c3571eaff1f09556febe68d8ab733ecf6/src%2Frustllvm%2FRustWrapper.cpp", "raw_url": "https://github.com/rust-lang/rust/raw/17a2be8c3571eaff1f09556febe68d8ab733ecf6/src%2Frustllvm%2FRustWrapper.cpp", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Frustllvm%2FRustWrapper.cpp?ref=17a2be8c3571eaff1f09556febe68d8ab733ecf6", "patch": "@@ -521,6 +521,15 @@ extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreateLexicalBlock(\n         ));\n }\n \n+extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreateLexicalBlockFile(\n+    LLVMRustDIBuilderRef Builder,\n+    LLVMRustMetadataRef Scope,\n+    LLVMRustMetadataRef File) {\n+    return wrap(Builder->createLexicalBlockFile(\n+        unwrapDI<DIDescriptor>(Scope),\n+        unwrapDI<DIFile>(File)));\n+}\n+\n extern \"C\" LLVMRustMetadataRef LLVMRustDIBuilderCreateStaticVariable(\n     LLVMRustDIBuilderRef Builder,\n     LLVMRustMetadataRef Context,"}, {"sha": "1006b684a8c22e1f4fafc322ddbad1a5efee393b", "filename": "src/test/debuginfo/auxiliary/macro-stepping.rs", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/17a2be8c3571eaff1f09556febe68d8ab733ecf6/src%2Ftest%2Fdebuginfo%2Fauxiliary%2Fmacro-stepping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17a2be8c3571eaff1f09556febe68d8ab733ecf6/src%2Ftest%2Fdebuginfo%2Fauxiliary%2Fmacro-stepping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fauxiliary%2Fmacro-stepping.rs?ref=17a2be8c3571eaff1f09556febe68d8ab733ecf6", "patch": "@@ -0,0 +1,20 @@\n+// Copyright 2013-2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// compile-flags:-g\n+\n+#![crate_type = \"rlib\"]\n+\n+#[macro_export]\n+macro_rules! new_scope {\n+    () => {\n+        let x = 1;\n+    }\n+}"}, {"sha": "eb5798dc7cc486746d250e2ca2481ea0eabeaab6", "filename": "src/test/debuginfo/lexical-scope-with-macro.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/17a2be8c3571eaff1f09556febe68d8ab733ecf6/src%2Ftest%2Fdebuginfo%2Flexical-scope-with-macro.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17a2be8c3571eaff1f09556febe68d8ab733ecf6/src%2Ftest%2Fdebuginfo%2Flexical-scope-with-macro.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Flexical-scope-with-macro.rs?ref=17a2be8c3571eaff1f09556febe68d8ab733ecf6", "patch": "@@ -10,7 +10,7 @@\n \n // min-lldb-version: 310\n \n-// compile-flags:-g\n+// compile-flags:-g -Zdebug-macros\n \n // === GDB TESTS ===================================================================================\n "}, {"sha": "52a2a58ed7d27d17bf6445df6eb234e67c0f3af5", "filename": "src/test/debuginfo/macro-stepping.rs", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/rust-lang/rust/blob/17a2be8c3571eaff1f09556febe68d8ab733ecf6/src%2Ftest%2Fdebuginfo%2Fmacro-stepping.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17a2be8c3571eaff1f09556febe68d8ab733ecf6/src%2Ftest%2Fdebuginfo%2Fmacro-stepping.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fdebuginfo%2Fmacro-stepping.rs?ref=17a2be8c3571eaff1f09556febe68d8ab733ecf6", "patch": "@@ -0,0 +1,103 @@\n+// Copyright 2013-2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// ignore-windows\n+// ignore-android\n+// min-lldb-version: 310\n+\n+// aux-build:macro-stepping.rs\n+\n+#![allow(unused)]\n+\n+#[macro_use]\n+extern crate macro_stepping; // exports new_scope!()\n+\n+// compile-flags:-g\n+\n+// === GDB TESTS ===================================================================================\n+\n+// gdb-command:run\n+// gdb-command:next\n+// gdb-command:frame\n+// gdb-check:[...]#loc1[...]\n+// gdb-command:next\n+// gdb-command:frame\n+// gdb-check:[...]#loc2[...]\n+// gdb-command:next\n+// gdb-command:frame\n+// gdb-check:[...]#loc3[...]\n+// gdb-command:next\n+// gdb-command:frame\n+// gdb-check:[...]#loc4[...]\n+// gdb-command:next\n+// gdb-command:frame\n+// gdb-check:[...]#loc5[...]\n+// gdb-command:next\n+// gdb-command:frame\n+// gdb-check:[...]#loc6[...]\n+\n+// === LLDB TESTS ==================================================================================\n+\n+// lldb-command:set set stop-line-count-before 0\n+// lldb-command:set set stop-line-count-after 1\n+// Can't set both to zero or lldb will stop printing source at all.  So it will output the current\n+// line and the next.  We deal with this by having at least 2 lines between the #loc's\n+\n+// lldb-command:run\n+// lldb-command:next\n+// lldb-command:frame select\n+// lldb-check:[...]#loc1[...]\n+// lldb-command:next\n+// lldb-command:frame select\n+// lldb-check:[...]#loc2[...]\n+// lldb-command:next\n+// lldb-command:frame select\n+// lldb-check:[...]#loc3[...]\n+// lldb-command:next\n+// lldb-command:frame select\n+// lldb-check:[...]#loc4[...]\n+// lldb-command:next\n+// lldb-command:frame select\n+// lldb-check:[...]#loc5[...]\n+\n+macro_rules! foo {\n+    () => {\n+        let a = 1;\n+        let b = 2;\n+        let c = 3;\n+    }\n+}\n+\n+macro_rules! foo2 {\n+    () => {\n+        foo!();\n+        let x = 1;\n+        foo!();\n+    }\n+}\n+\n+fn main() {\n+    zzz(); // #break\n+\n+    foo!(); // #loc1\n+\n+    foo2!(); // #loc2\n+\n+    let x = vec![42]; // #loc3\n+\n+    new_scope!(); // #loc4\n+\n+    println!(\"Hello {}\", // #loc5\n+             \"world\");\n+\n+    zzz(); // #loc6\n+}\n+\n+fn zzz() {()}"}, {"sha": "9e033421574b9eb333c1d2c3c65943d2c710d751", "filename": "src/test/run-pass/mir_heavy_promoted.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/17a2be8c3571eaff1f09556febe68d8ab733ecf6/src%2Ftest%2Frun-pass%2Fmir_heavy_promoted.rs", "raw_url": "https://github.com/rust-lang/rust/raw/17a2be8c3571eaff1f09556febe68d8ab733ecf6/src%2Ftest%2Frun-pass%2Fmir_heavy_promoted.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frun-pass%2Fmir_heavy_promoted.rs?ref=17a2be8c3571eaff1f09556febe68d8ab733ecf6", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+const TEST_DATA: [u8; 32 * 1024 * 1024] = [42; 32 * 1024 * 1024];\n+\n+// Check that the promoted copy of TEST_DATA doesn't\n+// leave an alloca from an unused temp behind, which,\n+// without optimizations, can still blow the stack.\n+fn main() {\n+    println!(\"{}\", TEST_DATA.len());\n+}"}]}