{"sha": "831ae3c1364b7b033bd1da430bc1cb86d93ad186", "node_id": "MDY6Q29tbWl0NzI0NzEyOjgzMWFlM2MxMzY0YjdiMDMzYmQxZGE0MzBiYzFjYjg2ZDkzYWQxODY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-06-26T10:52:16Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-06-26T10:52:16Z"}, "message": "Auto merge of #84814 - Stupremee:properly-render-hrtbs, r=GuillaumeGomez\n\nProperly render HRTBs\n\n```rust\npub fn test<T>()\nwhere\n    for<'a> &'a T: Iterator,\n{}\n```\n\nThis will now render properly including the `for<'a>`\n![image](https://user-images.githubusercontent.com/39732259/116808426-fe6ce600-ab38-11eb-9452-f33f554fbb8e.png)\n\nI do not know if this covers all cases, it only covers everything that I could think of that includes `for` and lifetimes in where bounds.\nAlso someone need to mentor me on how to add a proper rustdoc test for this.\n\nResolves #78482", "tree": {"sha": "32db4a7d7858a85aefba7d95d4e728858b1ebee1", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/32db4a7d7858a85aefba7d95d4e728858b1ebee1"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/831ae3c1364b7b033bd1da430bc1cb86d93ad186", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/831ae3c1364b7b033bd1da430bc1cb86d93ad186", "html_url": "https://github.com/rust-lang/rust/commit/831ae3c1364b7b033bd1da430bc1cb86d93ad186", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/831ae3c1364b7b033bd1da430bc1cb86d93ad186/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "481971978fda83aa7cf1f1f3c80cfad822377cf2", "url": "https://api.github.com/repos/rust-lang/rust/commits/481971978fda83aa7cf1f1f3c80cfad822377cf2", "html_url": "https://github.com/rust-lang/rust/commit/481971978fda83aa7cf1f1f3c80cfad822377cf2"}, {"sha": "4ea27484c9582389cded2301d1f0dd4f421c8c35", "url": "https://api.github.com/repos/rust-lang/rust/commits/4ea27484c9582389cded2301d1f0dd4f421c8c35", "html_url": "https://github.com/rust-lang/rust/commit/4ea27484c9582389cded2301d1f0dd4f421c8c35"}], "stats": {"total": 351, "additions": 233, "deletions": 118}, "files": [{"sha": "ebab3add6c55dd96ad642ec0c81be2b01a35961c", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 7, "deletions": 11, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/831ae3c1364b7b033bd1da430bc1cb86d93ad186/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/831ae3c1364b7b033bd1da430bc1cb86d93ad186/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=831ae3c1364b7b033bd1da430bc1cb86d93ad186", "patch": "@@ -353,12 +353,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                     let (poly_trait, output) =\n                         (data.0.as_ref().expect(\"as_ref failed\").clone(), data.1.as_ref().cloned());\n                     let new_ty = match poly_trait.trait_ {\n-                        Type::ResolvedPath {\n-                            ref path,\n-                            ref param_names,\n-                            ref did,\n-                            ref is_generic,\n-                        } => {\n+                        Type::ResolvedPath { ref path, ref did, ref is_generic } => {\n                             let mut new_path = path.clone();\n                             let last_segment =\n                                 new_path.segments.pop().expect(\"segments were empty\");\n@@ -395,7 +390,6 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n \n                             Type::ResolvedPath {\n                                 path: new_path,\n-                                param_names: param_names.clone(),\n                                 did: *did,\n                                 is_generic: *is_generic,\n                             }\n@@ -414,7 +408,11 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                 let mut bounds_vec = bounds.into_iter().collect();\n                 self.sort_where_bounds(&mut bounds_vec);\n \n-                Some(WherePredicate::BoundPredicate { ty, bounds: bounds_vec })\n+                Some(WherePredicate::BoundPredicate {\n+                    ty,\n+                    bounds: bounds_vec,\n+                    bound_params: Vec::new(),\n+                })\n             })\n             .chain(\n                 lifetime_to_bounds.into_iter().filter(|&(_, ref bounds)| !bounds.is_empty()).map(\n@@ -492,7 +490,7 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n             }\n             let p = p.unwrap();\n             match p {\n-                WherePredicate::BoundPredicate { ty, mut bounds } => {\n+                WherePredicate::BoundPredicate { ty, mut bounds, .. } => {\n                     // Writing a projection trait bound of the form\n                     // <T as Trait>::Name : ?Sized\n                     // is illegal, because ?Sized bounds can only\n@@ -566,7 +564,6 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                             match **trait_ {\n                                 Type::ResolvedPath {\n                                     path: ref trait_path,\n-                                    ref param_names,\n                                     ref did,\n                                     ref is_generic,\n                                 } => {\n@@ -613,7 +610,6 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n                                         PolyTrait {\n                                             trait_: Type::ResolvedPath {\n                                                 path: new_trait_path,\n-                                                param_names: param_names.clone(),\n                                                 did: *did,\n                                                 is_generic: *is_generic,\n                                             },"}, {"sha": "829b54f1fc1cd3b1041a74e869d7b96942ec8529", "filename": "src/librustdoc/clean/inline.rs", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/831ae3c1364b7b033bd1da430bc1cb86d93ad186/src%2Flibrustdoc%2Fclean%2Finline.rs", "raw_url": "https://github.com/rust-lang/rust/raw/831ae3c1364b7b033bd1da430bc1cb86d93ad186/src%2Flibrustdoc%2Fclean%2Finline.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Finline.rs?ref=831ae3c1364b7b033bd1da430bc1cb86d93ad186", "patch": "@@ -583,9 +583,11 @@ fn build_macro(cx: &mut DocContext<'_>, did: DefId, name: Symbol) -> clean::Item\n fn filter_non_trait_generics(trait_did: DefId, mut g: clean::Generics) -> clean::Generics {\n     for pred in &mut g.where_predicates {\n         match *pred {\n-            clean::WherePredicate::BoundPredicate { ty: clean::Generic(ref s), ref mut bounds }\n-                if *s == kw::SelfUpper =>\n-            {\n+            clean::WherePredicate::BoundPredicate {\n+                ty: clean::Generic(ref s),\n+                ref mut bounds,\n+                ..\n+            } if *s == kw::SelfUpper => {\n                 bounds.retain(|bound| match *bound {\n                     clean::GenericBound::TraitBound(\n                         clean::PolyTrait { trait_: clean::ResolvedPath { did, .. }, .. },\n@@ -608,6 +610,7 @@ fn filter_non_trait_generics(trait_did: DefId, mut g: clean::Generics) -> clean:\n                     ..\n                 },\n             ref bounds,\n+            ..\n         } => !(bounds.is_empty() || *s == kw::SelfUpper && did == trait_did),\n         _ => true,\n     });\n@@ -622,7 +625,7 @@ fn separate_supertrait_bounds(\n ) -> (clean::Generics, Vec<clean::GenericBound>) {\n     let mut ty_bounds = Vec::new();\n     g.where_predicates.retain(|pred| match *pred {\n-        clean::WherePredicate::BoundPredicate { ty: clean::Generic(ref s), ref bounds }\n+        clean::WherePredicate::BoundPredicate { ty: clean::Generic(ref s), ref bounds, .. }\n             if *s == kw::SelfUpper =>\n         {\n             ty_bounds.extend(bounds.iter().cloned());"}, {"sha": "fea09b383c0b181483a00a29fabb4d6c562d1825", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 35, "deletions": 49, "changes": 84, "blob_url": "https://github.com/rust-lang/rust/blob/831ae3c1364b7b033bd1da430bc1cb86d93ad186/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/831ae3c1364b7b033bd1da430bc1cb86d93ad186/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=831ae3c1364b7b033bd1da430bc1cb86d93ad186", "patch": "@@ -180,7 +180,7 @@ impl Clean<Type> for (ty::TraitRef<'_>, &[TypeBinding]) {\n \n         debug!(\"ty::TraitRef\\n  subst: {:?}\\n\", trait_ref.substs);\n \n-        ResolvedPath { path, param_names: None, did: trait_ref.def_id, is_generic: false }\n+        ResolvedPath { path, did: trait_ref.def_id, is_generic: false }\n     }\n }\n \n@@ -330,6 +330,7 @@ impl Clean<WherePredicate> for hir::WherePredicate<'_> {\n             hir::WherePredicate::BoundPredicate(ref wbp) => WherePredicate::BoundPredicate {\n                 ty: wbp.bounded_ty.clean(cx),\n                 bounds: wbp.bounds.clean(cx),\n+                bound_params: wbp.bound_generic_params.into_iter().map(|x| x.clean(cx)).collect(),\n             },\n \n             hir::WherePredicate::RegionPredicate(ref wrp) => WherePredicate::RegionPredicate {\n@@ -370,6 +371,7 @@ impl<'a> Clean<WherePredicate> for ty::PolyTraitPredicate<'a> {\n         WherePredicate::BoundPredicate {\n             ty: poly_trait_ref.skip_binder().self_ty().clean(cx),\n             bounds: vec![poly_trait_ref.clean(cx)],\n+            bound_params: Vec::new(),\n         }\n     }\n }\n@@ -402,6 +404,7 @@ impl<'tcx> Clean<Option<WherePredicate>> for ty::OutlivesPredicate<Ty<'tcx>, ty:\n         Some(WherePredicate::BoundPredicate {\n             ty: ty.clean(cx),\n             bounds: vec![GenericBound::Outlives(lt.clean(cx).expect(\"failed to clean lifetimes\"))],\n+            bound_params: Vec::new(),\n         })\n     }\n }\n@@ -567,7 +570,9 @@ impl Clean<Generics> for hir::Generics<'_> {\n         // to where predicates when such cases occur.\n         for where_pred in &mut generics.where_predicates {\n             match *where_pred {\n-                WherePredicate::BoundPredicate { ty: Generic(ref name), ref mut bounds } => {\n+                WherePredicate::BoundPredicate {\n+                    ty: Generic(ref name), ref mut bounds, ..\n+                } => {\n                     if bounds.is_empty() {\n                         for param in &mut generics.params {\n                             match param.kind {\n@@ -721,7 +726,7 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics, ty::GenericPredicates<'tcx\n         // handled in cleaning associated types\n         let mut sized_params = FxHashSet::default();\n         where_predicates.retain(|pred| match *pred {\n-            WP::BoundPredicate { ty: Generic(ref g), ref bounds } => {\n+            WP::BoundPredicate { ty: Generic(ref g), ref bounds, .. } => {\n                 if bounds.iter().any(|b| b.is_sized_bound(cx)) {\n                     sized_params.insert(*g);\n                     false\n@@ -741,6 +746,7 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics, ty::GenericPredicates<'tcx\n                 where_predicates.push(WP::BoundPredicate {\n                     ty: Type::Generic(tp.name),\n                     bounds: vec![GenericBound::maybe_sized(cx)],\n+                    bound_params: Vec::new(),\n                 })\n             }\n         }\n@@ -1117,6 +1123,7 @@ impl Clean<Item> for ty::AssocItem {\n                                 WherePredicate::BoundPredicate {\n                                     ty: QPath { ref name, ref self_type, ref trait_, .. },\n                                     ref bounds,\n+                                    ..\n                                 } => (name, self_type, trait_, bounds),\n                                 _ => return None,\n                             };\n@@ -1371,24 +1378,9 @@ impl Clean<Type> for hir::Ty<'_> {\n             }\n             TyKind::Path(_) => clean_qpath(&self, cx),\n             TyKind::TraitObject(ref bounds, ref lifetime, _) => {\n-                match bounds[0].clean(cx).trait_ {\n-                    ResolvedPath { path, param_names: None, did, is_generic } => {\n-                        let mut bounds: Vec<self::GenericBound> = bounds[1..]\n-                            .iter()\n-                            .map(|bound| {\n-                                self::GenericBound::TraitBound(\n-                                    bound.clean(cx),\n-                                    hir::TraitBoundModifier::None,\n-                                )\n-                            })\n-                            .collect();\n-                        if !lifetime.is_elided() {\n-                            bounds.push(self::GenericBound::Outlives(lifetime.clean(cx)));\n-                        }\n-                        ResolvedPath { path, param_names: Some(bounds), did, is_generic }\n-                    }\n-                    _ => Infer, // shouldn't happen\n-                }\n+                let bounds = bounds.iter().map(|bound| bound.clean(cx)).collect();\n+                let lifetime = if !lifetime.is_elided() { Some(lifetime.clean(cx)) } else { None };\n+                DynTrait(bounds, lifetime)\n             }\n             TyKind::BareFn(ref barefn) => BareFunction(box barefn.clean(cx)),\n             TyKind::Infer | TyKind::Err => Infer,\n@@ -1471,7 +1463,7 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                 };\n                 inline::record_extern_fqn(cx, did, kind);\n                 let path = external_path(cx, cx.tcx.item_name(did), None, false, vec![], substs);\n-                ResolvedPath { path, param_names: None, did, is_generic: false }\n+                ResolvedPath { path, did, is_generic: false }\n             }\n             ty::Foreign(did) => {\n                 inline::record_extern_fqn(cx, did, ItemType::ForeignType);\n@@ -1483,7 +1475,7 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                     vec![],\n                     InternalSubsts::empty(),\n                 );\n-                ResolvedPath { path, param_names: None, did, is_generic: false }\n+                ResolvedPath { path, did, is_generic: false }\n             }\n             ty::Dynamic(ref obj, ref reg) => {\n                 // HACK: pick the first `did` as the `did` of the trait object. Someone\n@@ -1501,28 +1493,19 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n \n                 inline::record_extern_fqn(cx, did, ItemType::Trait);\n \n-                let mut param_names = vec![];\n-                if let Some(b) = reg.clean(cx) {\n-                    param_names.push(GenericBound::Outlives(b));\n-                }\n+                let lifetime = reg.clean(cx);\n+                let mut bounds = vec![];\n+\n                 for did in dids {\n                     let empty = cx.tcx.intern_substs(&[]);\n                     let path =\n                         external_path(cx, cx.tcx.item_name(did), Some(did), false, vec![], empty);\n                     inline::record_extern_fqn(cx, did, ItemType::Trait);\n-                    let bound = GenericBound::TraitBound(\n-                        PolyTrait {\n-                            trait_: ResolvedPath {\n-                                path,\n-                                param_names: None,\n-                                did,\n-                                is_generic: false,\n-                            },\n-                            generic_params: Vec::new(),\n-                        },\n-                        hir::TraitBoundModifier::None,\n-                    );\n-                    param_names.push(bound);\n+                    let bound = PolyTrait {\n+                        trait_: ResolvedPath { path, did, is_generic: false },\n+                        generic_params: Vec::new(),\n+                    };\n+                    bounds.push(bound);\n                 }\n \n                 let mut bindings = vec![];\n@@ -1535,7 +1518,15 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n \n                 let path =\n                     external_path(cx, cx.tcx.item_name(did), Some(did), false, bindings, substs);\n-                ResolvedPath { path, param_names: Some(param_names), did, is_generic: false }\n+                bounds.insert(\n+                    0,\n+                    PolyTrait {\n+                        trait_: ResolvedPath { path, did, is_generic: false },\n+                        generic_params: Vec::new(),\n+                    },\n+                );\n+\n+                DynTrait(bounds, lifetime)\n             }\n             ty::Tuple(ref t) => {\n                 Tuple(t.iter().map(|t| t.expect_ty()).collect::<Vec<_>>().clean(cx))\n@@ -2239,14 +2230,9 @@ impl From<GenericBound> for SimpleBound {\n         match bound.clone() {\n             GenericBound::Outlives(l) => SimpleBound::Outlives(l),\n             GenericBound::TraitBound(t, mod_) => match t.trait_ {\n-                Type::ResolvedPath { path, param_names, .. } => SimpleBound::TraitBound(\n-                    path.segments,\n-                    param_names.map_or_else(Vec::new, |v| {\n-                        v.iter().map(|p| SimpleBound::from(p.clone())).collect()\n-                    }),\n-                    t.generic_params,\n-                    mod_,\n-                ),\n+                Type::ResolvedPath { path, .. } => {\n+                    SimpleBound::TraitBound(path.segments, Vec::new(), t.generic_params, mod_)\n+                }\n                 _ => panic!(\"Unexpected bound {:?}\", bound),\n             },\n         }"}, {"sha": "3ec0a22a2c09a4a3f8b91a1f6e85c2180af7a08a", "filename": "src/librustdoc/clean/simplify.rs", "status": "modified", "additions": 19, "deletions": 9, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/831ae3c1364b7b033bd1da430bc1cb86d93ad186/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/831ae3c1364b7b033bd1da430bc1cb86d93ad186/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fsimplify.rs?ref=831ae3c1364b7b033bd1da430bc1cb86d93ad186", "patch": "@@ -24,16 +24,20 @@ use crate::core::DocContext;\n \n crate fn where_clauses(cx: &DocContext<'_>, clauses: Vec<WP>) -> Vec<WP> {\n     // First, partition the where clause into its separate components\n-    let mut params: BTreeMap<_, Vec<_>> = BTreeMap::new();\n+    let mut params: BTreeMap<_, (Vec<_>, Vec<_>)> = BTreeMap::new();\n     let mut lifetimes = Vec::new();\n     let mut equalities = Vec::new();\n     let mut tybounds = Vec::new();\n \n     for clause in clauses {\n         match clause {\n-            WP::BoundPredicate { ty, bounds } => match ty {\n-                clean::Generic(s) => params.entry(s).or_default().extend(bounds),\n-                t => tybounds.push((t, bounds)),\n+            WP::BoundPredicate { ty, bounds, bound_params } => match ty {\n+                clean::Generic(s) => {\n+                    let (b, p) = params.entry(s).or_default();\n+                    b.extend(bounds);\n+                    p.extend(bound_params);\n+                }\n+                t => tybounds.push((t, (bounds, bound_params))),\n             },\n             WP::RegionPredicate { lifetime, bounds } => {\n                 lifetimes.push((lifetime, bounds));\n@@ -54,7 +58,7 @@ crate fn where_clauses(cx: &DocContext<'_>, clauses: Vec<WP>) -> Vec<WP> {\n             clean::Generic(s) => s,\n             _ => return true,\n         };\n-        let bounds = match params.get_mut(generic) {\n+        let (bounds, _) = match params.get_mut(generic) {\n             Some(bound) => bound,\n             None => return true,\n         };\n@@ -67,10 +71,16 @@ crate fn where_clauses(cx: &DocContext<'_>, clauses: Vec<WP>) -> Vec<WP> {\n     clauses.extend(\n         lifetimes.into_iter().map(|(lt, bounds)| WP::RegionPredicate { lifetime: lt, bounds }),\n     );\n-    clauses.extend(\n-        params.into_iter().map(|(k, v)| WP::BoundPredicate { ty: clean::Generic(k), bounds: v }),\n-    );\n-    clauses.extend(tybounds.into_iter().map(|(ty, bounds)| WP::BoundPredicate { ty, bounds }));\n+    clauses.extend(params.into_iter().map(|(k, (bounds, params))| WP::BoundPredicate {\n+        ty: clean::Generic(k),\n+        bounds,\n+        bound_params: params,\n+    }));\n+    clauses.extend(tybounds.into_iter().map(|(ty, (bounds, bound_params))| WP::BoundPredicate {\n+        ty,\n+        bounds,\n+        bound_params,\n+    }));\n     clauses.extend(equalities.into_iter().map(|(lhs, rhs)| WP::EqPredicate { lhs, rhs }));\n     clauses\n }"}, {"sha": "4da2f14ce8a8d9e884b3324339669faf0cf4b625", "filename": "src/librustdoc/clean/types.rs", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/831ae3c1364b7b033bd1da430bc1cb86d93ad186/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "raw_url": "https://github.com/rust-lang/rust/raw/831ae3c1364b7b033bd1da430bc1cb86d93ad186/src%2Flibrustdoc%2Fclean%2Ftypes.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Ftypes.rs?ref=831ae3c1364b7b033bd1da430bc1cb86d93ad186", "patch": "@@ -1168,7 +1168,7 @@ impl GenericBound {\n         inline::record_extern_fqn(cx, did, ItemType::Trait);\n         GenericBound::TraitBound(\n             PolyTrait {\n-                trait_: ResolvedPath { path, param_names: None, did, is_generic: false },\n+                trait_: ResolvedPath { path, did, is_generic: false },\n                 generic_params: Vec::new(),\n             },\n             hir::TraitBoundModifier::Maybe,\n@@ -1220,7 +1220,7 @@ impl Lifetime {\n \n #[derive(Clone, Debug)]\n crate enum WherePredicate {\n-    BoundPredicate { ty: Type, bounds: Vec<GenericBound> },\n+    BoundPredicate { ty: Type, bounds: Vec<GenericBound>, bound_params: Vec<Lifetime> },\n     RegionPredicate { lifetime: Lifetime, bounds: Vec<GenericBound> },\n     EqPredicate { lhs: Type, rhs: Type },\n }\n@@ -1434,11 +1434,12 @@ crate enum Type {\n     /// Structs/enums/traits (most that would be an `hir::TyKind::Path`).\n     ResolvedPath {\n         path: Path,\n-        param_names: Option<Vec<GenericBound>>,\n         did: DefId,\n         /// `true` if is a `T::Name` path for associated types.\n         is_generic: bool,\n     },\n+    /// `dyn for<'a> Trait<'a> + Send + 'static`\n+    DynTrait(Vec<PolyTrait>, Option<Lifetime>),\n     /// For parameterized types, so the consumer of the JSON don't go\n     /// looking for types which don't exist anywhere.\n     Generic(Symbol),\n@@ -1625,6 +1626,7 @@ impl Type {\n     fn inner_def_id(&self, cache: Option<&Cache>) -> Option<DefId> {\n         let t: PrimitiveType = match *self {\n             ResolvedPath { did, .. } => return Some(did.into()),\n+            DynTrait(ref bounds, _) => return bounds[0].trait_.inner_def_id(cache),\n             Primitive(p) => return cache.and_then(|c| c.primitive_locations.get(&p).cloned()),\n             BorrowedRef { type_: box Generic(..), .. } => PrimitiveType::Reference,\n             BorrowedRef { ref type_, .. } => return type_.inner_def_id(cache),"}, {"sha": "3d056979780f43b0ab110767b0c6a161fa11804c", "filename": "src/librustdoc/clean/utils.rs", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/831ae3c1364b7b033bd1da430bc1cb86d93ad186/src%2Flibrustdoc%2Fclean%2Futils.rs", "raw_url": "https://github.com/rust-lang/rust/raw/831ae3c1364b7b033bd1da430bc1cb86d93ad186/src%2Flibrustdoc%2Fclean%2Futils.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Futils.rs?ref=831ae3c1364b7b033bd1da430bc1cb86d93ad186", "patch": "@@ -2,7 +2,7 @@ use crate::clean::auto_trait::AutoTraitFinder;\n use crate::clean::blanket_impl::BlanketImplFinder;\n use crate::clean::{\n     inline, Clean, Crate, Generic, GenericArg, GenericArgs, ImportSource, Item, ItemKind, Lifetime,\n-    Path, PathSegment, Primitive, PrimitiveType, ResolvedPath, Type, TypeBinding,\n+    Path, PathSegment, PolyTrait, Primitive, PrimitiveType, ResolvedPath, Type, TypeBinding,\n };\n use crate::core::DocContext;\n use crate::formats::item_type::ItemType;\n@@ -163,8 +163,18 @@ pub(super) fn external_path(\n \n crate fn strip_type(ty: Type) -> Type {\n     match ty {\n-        Type::ResolvedPath { path, param_names, did, is_generic } => {\n-            Type::ResolvedPath { path: strip_path(&path), param_names, did, is_generic }\n+        Type::ResolvedPath { path, did, is_generic } => {\n+            Type::ResolvedPath { path: strip_path(&path), did, is_generic }\n+        }\n+        Type::DynTrait(mut bounds, lt) => {\n+            let first = bounds.remove(0);\n+            let stripped_trait = strip_type(first.trait_);\n+\n+            bounds.insert(\n+                0,\n+                PolyTrait { trait_: stripped_trait, generic_params: first.generic_params },\n+            );\n+            Type::DynTrait(bounds, lt)\n         }\n         Type::Tuple(inner_tys) => {\n             Type::Tuple(inner_tys.iter().map(|t| strip_type(t.clone())).collect())\n@@ -431,7 +441,7 @@ crate fn resolve_type(cx: &mut DocContext<'_>, path: Path, id: hir::HirId) -> Ty\n         _ => false,\n     };\n     let did = register_res(cx, path.res);\n-    ResolvedPath { path, param_names: None, did, is_generic }\n+    ResolvedPath { path, did, is_generic }\n }\n \n crate fn get_auto_trait_and_blanket_impls("}, {"sha": "1e1fc2436aac1f46acec439aeef6e66c4bd8f475", "filename": "src/librustdoc/formats/cache.rs", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/rust-lang/rust/blob/831ae3c1364b7b033bd1da430bc1cb86d93ad186/src%2Flibrustdoc%2Fformats%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/831ae3c1364b7b033bd1da430bc1cb86d93ad186/src%2Flibrustdoc%2Fformats%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fformats%2Fcache.rs?ref=831ae3c1364b7b033bd1da430bc1cb86d93ad186", "patch": "@@ -402,6 +402,15 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n                         self.cache.parent_stack.push(did);\n                         true\n                     }\n+                    clean::DynTrait(ref bounds, _)\n+                    | clean::BorrowedRef { type_: box clean::DynTrait(ref bounds, _), .. } => {\n+                        if let Some(did) = bounds[0].trait_.def_id() {\n+                            self.cache.parent_stack.push(did);\n+                            true\n+                        } else {\n+                            false\n+                        }\n+                    }\n                     ref t => {\n                         let prim_did = t\n                             .primitive_type()\n@@ -432,6 +441,12 @@ impl<'a, 'tcx> DocFolder for CacheBuilder<'a, 'tcx> {\n                 | clean::BorrowedRef { type_: box clean::ResolvedPath { did, .. }, .. } => {\n                     dids.insert(did);\n                 }\n+                clean::DynTrait(ref bounds, _)\n+                | clean::BorrowedRef { type_: box clean::DynTrait(ref bounds, _), .. } => {\n+                    if let Some(did) = bounds[0].trait_.def_id() {\n+                        dids.insert(did);\n+                    }\n+                }\n                 ref t => {\n                     let did = t\n                         .primitive_type()"}, {"sha": "1e08aeb379a2b056a941ef2d124a6b86c3d09e76", "filename": "src/librustdoc/html/format.rs", "status": "modified", "additions": 42, "deletions": 21, "changes": 63, "blob_url": "https://github.com/rust-lang/rust/blob/831ae3c1364b7b033bd1da430bc1cb86d93ad186/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "raw_url": "https://github.com/rust-lang/rust/raw/831ae3c1364b7b033bd1da430bc1cb86d93ad186/src%2Flibrustdoc%2Fhtml%2Fformat.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Fformat.rs?ref=831ae3c1364b7b033bd1da430bc1cb86d93ad186", "patch": "@@ -250,17 +250,33 @@ crate fn print_where_clause<'a, 'tcx: 'a>(\n             }\n \n             match pred {\n-                clean::WherePredicate::BoundPredicate { ty, bounds } => {\n+                clean::WherePredicate::BoundPredicate { ty, bounds, bound_params } => {\n                     let bounds = bounds;\n+                    let for_prefix = match bound_params.len() {\n+                        0 => String::new(),\n+                        _ if f.alternate() => {\n+                            format!(\n+                                \"for<{:#}> \",\n+                                comma_sep(bound_params.iter().map(|lt| lt.print()))\n+                            )\n+                        }\n+                        _ => format!(\n+                            \"for&lt;{}&gt; \",\n+                            comma_sep(bound_params.iter().map(|lt| lt.print()))\n+                        ),\n+                    };\n+\n                     if f.alternate() {\n                         clause.push_str(&format!(\n-                            \"{:#}: {:#}\",\n+                            \"{}{:#}: {:#}\",\n+                            for_prefix,\n                             ty.print(cx),\n                             print_generic_bounds(bounds, cx)\n                         ));\n                     } else {\n                         clause.push_str(&format!(\n-                            \"{}: {}\",\n+                            \"{}{}: {}\",\n+                            for_prefix,\n                             ty.print(cx),\n                             print_generic_bounds(bounds, cx)\n                         ));\n@@ -631,18 +647,24 @@ fn primitive_link(\n \n /// Helper to render type parameters\n fn tybounds<'a, 'tcx: 'a>(\n-    param_names: &'a Option<Vec<clean::GenericBound>>,\n+    bounds: &'a Vec<clean::PolyTrait>,\n+    lt: &'a Option<clean::Lifetime>,\n     cx: &'a Context<'tcx>,\n ) -> impl fmt::Display + 'a + Captures<'tcx> {\n-    display_fn(move |f| match *param_names {\n-        Some(ref params) => {\n-            for param in params {\n+    display_fn(move |f| {\n+        for (i, bound) in bounds.iter().enumerate() {\n+            if i > 0 {\n                 write!(f, \" + \")?;\n-                fmt::Display::fmt(&param.print(cx), f)?;\n             }\n-            Ok(())\n+\n+            fmt::Display::fmt(&bound.print(cx), f)?;\n         }\n-        None => Ok(()),\n+\n+        if let Some(lt) = lt {\n+            write!(f, \" + \")?;\n+            fmt::Display::fmt(&lt.print(), f)?;\n+        }\n+        Ok(())\n     })\n }\n \n@@ -679,13 +701,13 @@ fn fmt_type<'cx>(\n \n     match *t {\n         clean::Generic(name) => write!(f, \"{}\", name),\n-        clean::ResolvedPath { did, ref param_names, ref path, is_generic } => {\n-            if param_names.is_some() {\n-                f.write_str(\"dyn \")?;\n-            }\n+        clean::ResolvedPath { did, ref path, is_generic } => {\n             // Paths like `T::Output` and `Self::Output` should be rendered with all segments.\n-            resolved_path(f, did, path, is_generic, use_absolute, cx)?;\n-            fmt::Display::fmt(&tybounds(param_names, cx), f)\n+            resolved_path(f, did, path, is_generic, use_absolute, cx)\n+        }\n+        clean::DynTrait(ref bounds, ref lt) => {\n+            f.write_str(\"dyn \")?;\n+            fmt::Display::fmt(&tybounds(bounds, lt, cx), f)\n         }\n         clean::Infer => write!(f, \"_\"),\n         clean::Primitive(prim) => primitive_link(f, prim, &*prim.as_sym().as_str(), cx),\n@@ -820,7 +842,9 @@ fn fmt_type<'cx>(\n                         }\n                     }\n                 }\n-                clean::ResolvedPath { param_names: Some(ref v), .. } if !v.is_empty() => {\n+                clean::DynTrait(ref bounds, ref trait_lt)\n+                    if bounds.len() > 1 || trait_lt.is_some() =>\n+                {\n                     write!(f, \"{}{}{}(\", amp, lt, m)?;\n                     fmt_type(&ty, f, use_absolute, cx)?;\n                     write!(f, \")\")\n@@ -881,7 +905,7 @@ fn fmt_type<'cx>(\n                 //        the ugliness comes from inlining across crates where\n                 //        everything comes in as a fully resolved QPath (hard to\n                 //        look at).\n-                box clean::ResolvedPath { did, ref param_names, .. } => {\n+                box clean::ResolvedPath { did, .. } => {\n                     match href(did.into(), cx) {\n                         Some((ref url, _, ref path)) if !f.alternate() => {\n                             write!(\n@@ -896,9 +920,6 @@ fn fmt_type<'cx>(\n                         }\n                         _ => write!(f, \"{}\", name)?,\n                     }\n-\n-                    // FIXME: `param_names` are not rendered, and this seems bad?\n-                    drop(param_names);\n                     Ok(())\n                 }\n                 _ => write!(f, \"{}\", name),"}, {"sha": "4372ece5c0105489865f1f74df635cad73dfcc9b", "filename": "src/librustdoc/html/render/cache.rs", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/rust-lang/rust/blob/831ae3c1364b7b033bd1da430bc1cb86d93ad186/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/831ae3c1364b7b033bd1da430bc1cb86d93ad186/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fhtml%2Frender%2Fcache.rs?ref=831ae3c1364b7b033bd1da430bc1cb86d93ad186", "patch": "@@ -234,6 +234,7 @@ fn get_index_type_name(clean_type: &clean::Type, accept_generic: bool) -> Option\n             });\n             Some(path_segment.name)\n         }\n+        clean::DynTrait(ref bounds, _) => get_index_type_name(&bounds[0].trait_, accept_generic),\n         clean::Generic(s) if accept_generic => Some(s),\n         clean::Primitive(ref p) => Some(p.as_sym()),\n         clean::BorrowedRef { ref type_, .. } => get_index_type_name(type_, accept_generic),"}, {"sha": "b89a266a695e99e752cca3bd0cfa123cd094fdbe", "filename": "src/librustdoc/json/conversions.rs", "status": "modified", "additions": 27, "deletions": 5, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/831ae3c1364b7b033bd1da430bc1cb86d93ad186/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/831ae3c1364b7b033bd1da430bc1cb86d93ad186/src%2Flibrustdoc%2Fjson%2Fconversions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fjson%2Fconversions.rs?ref=831ae3c1364b7b033bd1da430bc1cb86d93ad186", "patch": "@@ -328,9 +328,10 @@ impl FromWithTcx<clean::WherePredicate> for WherePredicate {\n     fn from_tcx(predicate: clean::WherePredicate, tcx: TyCtxt<'_>) -> Self {\n         use clean::WherePredicate::*;\n         match predicate {\n-            BoundPredicate { ty, bounds } => WherePredicate::BoundPredicate {\n+            BoundPredicate { ty, bounds, .. } => WherePredicate::BoundPredicate {\n                 ty: ty.into_tcx(tcx),\n                 bounds: bounds.into_iter().map(|x| x.into_tcx(tcx)).collect(),\n+                // FIXME: add `bound_params` to rustdoc-json-params?\n             },\n             RegionPredicate { lifetime, bounds } => WherePredicate::RegionPredicate {\n                 lifetime: lifetime.0.to_string(),\n@@ -372,14 +373,35 @@ impl FromWithTcx<clean::Type> for Type {\n     fn from_tcx(ty: clean::Type, tcx: TyCtxt<'_>) -> Self {\n         use clean::Type::*;\n         match ty {\n-            ResolvedPath { path, param_names, did, is_generic: _ } => Type::ResolvedPath {\n+            ResolvedPath { path, did, is_generic: _ } => Type::ResolvedPath {\n                 name: path.whole_name(),\n                 id: from_def_id(did.into()),\n                 args: path.segments.last().map(|args| Box::new(args.clone().args.into_tcx(tcx))),\n-                param_names: param_names\n-                    .map(|v| v.into_iter().map(|x| x.into_tcx(tcx)).collect())\n-                    .unwrap_or_default(),\n+                param_names: Vec::new(),\n             },\n+            DynTrait(mut bounds, lt) => {\n+                let (path, id) = match bounds.remove(0).trait_ {\n+                    ResolvedPath { path, did, .. } => (path, did),\n+                    _ => unreachable!(),\n+                };\n+\n+                Type::ResolvedPath {\n+                    name: path.whole_name(),\n+                    id: from_def_id(id.into()),\n+                    args: path\n+                        .segments\n+                        .last()\n+                        .map(|args| Box::new(args.clone().args.into_tcx(tcx))),\n+                    param_names: bounds\n+                        .into_iter()\n+                        .map(|t| {\n+                            clean::GenericBound::TraitBound(t, rustc_hir::TraitBoundModifier::None)\n+                        })\n+                        .chain(lt.into_iter().map(|lt| clean::GenericBound::Outlives(lt)))\n+                        .map(|bound| bound.into_tcx(tcx))\n+                        .collect(),\n+                }\n+            }\n             Generic(s) => Type::Generic(s.to_string()),\n             Primitive(p) => Type::Primitive(p.as_sym().to_string()),\n             BareFunction(f) => Type::FunctionPointer(Box::new((*f).into_tcx(tcx))),"}, {"sha": "34a7eae31c79062fde794a43e560dc7e72d8375d", "filename": "src/test/rustdoc/for-lifetime.rs", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/481971978fda83aa7cf1f1f3c80cfad822377cf2/src%2Ftest%2Frustdoc%2Ffor-lifetime.rs", "raw_url": "https://github.com/rust-lang/rust/raw/481971978fda83aa7cf1f1f3c80cfad822377cf2/src%2Ftest%2Frustdoc%2Ffor-lifetime.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Ffor-lifetime.rs?ref=481971978fda83aa7cf1f1f3c80cfad822377cf2", "patch": "@@ -1,12 +0,0 @@\n-#![crate_name = \"foo\"]\n-#![crate_type = \"lib\"]\n-\n-pub struct Foo {\n-    pub some_func: for<'a> fn(val: &'a i32) -> i32,\n-    pub some_trait: dyn for<'a> Trait<'a>,\n-}\n-\n-// @has foo/struct.Foo.html '//span[@id=\"structfield.some_func\"]' \"some_func: for<'a> fn(val: &'a i32) -> i32\"\n-// @has foo/struct.Foo.html '//span[@id=\"structfield.some_trait\"]' \"some_trait: dyn Trait<'a>\"\n-\n-pub trait Trait<'a> {}"}, {"sha": "41940b0884e4307a9312d373eba97d87a0d2960d", "filename": "src/test/rustdoc/higher-ranked-trait-bounds.rs", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/rust-lang/rust/blob/831ae3c1364b7b033bd1da430bc1cb86d93ad186/src%2Ftest%2Frustdoc%2Fhigher-ranked-trait-bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/831ae3c1364b7b033bd1da430bc1cb86d93ad186/src%2Ftest%2Frustdoc%2Fhigher-ranked-trait-bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Frustdoc%2Fhigher-ranked-trait-bounds.rs?ref=831ae3c1364b7b033bd1da430bc1cb86d93ad186", "patch": "@@ -0,0 +1,61 @@\n+#![crate_name = \"foo\"]\n+\n+// @has foo/trait.Trait.html\n+pub trait Trait<'x> {}\n+\n+// @has foo/fn.test1.html\n+// @has - '//pre' \"pub fn test1<T>() where for<'a> &'a T: Iterator,\"\n+pub fn test1<T>()\n+where\n+    for<'a> &'a T: Iterator,\n+{\n+}\n+\n+// @has foo/fn.test2.html\n+// @has - '//pre' \"pub fn test2<T>() where for<'a, 'b> &'a T: Trait<'b>,\"\n+pub fn test2<T>()\n+where\n+    for<'a, 'b> &'a T: Trait<'b>,\n+{\n+}\n+\n+// @has foo/fn.test3.html\n+// @has - '//pre' \"pub fn test3<F>() where F: for<'a, 'b> Fn(&'a u8, &'b u8),\"\n+pub fn test3<F>()\n+where\n+    F: for<'a, 'b> Fn(&'a u8, &'b u8),\n+{\n+}\n+\n+// @has foo/struct.Foo.html\n+pub struct Foo<'a> {\n+    _x: &'a u8,\n+    pub some_trait: &'a dyn for<'b> Trait<'b>,\n+    pub some_func: for<'c> fn(val: &'c i32) -> i32,\n+}\n+\n+// @has - '//span[@id=\"structfield.some_func\"]' \"some_func: for<'c> fn(val: &'c i32) -> i32\"\n+// @has - '//span[@id=\"structfield.some_trait\"]' \"some_trait: &'a dyn for<'b> Trait<'b>\"\n+\n+impl<'a> Foo<'a> {\n+    // @has - '//code' \"pub fn bar<T>() where T: Trait<'a>,\"\n+    pub fn bar<T>()\n+    where\n+        T: Trait<'a>,\n+    {\n+    }\n+}\n+\n+// @has foo/trait.B.html\n+pub trait B<'x> {}\n+\n+// @has - '//code[@class=\"in-band\"]' \"impl<'a> B<'a> for dyn for<'b> Trait<'b>\"\n+impl<'a> B<'a> for dyn for<'b> Trait<'b> {}\n+\n+// @has foo/struct.Bar.html\n+// @has - '//span[@id=\"structfield.bar\"]' \"bar: &'a (dyn for<'b> Trait<'b> + Unpin)\"\n+// @has - '//span[@id=\"structfield.baz\"]' \"baz: &'a (dyn Unpin + for<'b> Trait<'b>)\"\n+pub struct Bar<'a> {\n+    pub bar: &'a (dyn for<'b> Trait<'b> + Unpin),\n+    pub baz: &'a (dyn Unpin + for<'b> Trait<'b>),\n+}"}]}