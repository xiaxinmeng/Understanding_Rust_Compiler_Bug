{"sha": "4253153db205251f72ea4493687a31e04a2a8ca0", "node_id": "MDY6Q29tbWl0NzI0NzEyOjQyNTMxNTNkYjIwNTI1MWY3MmVhNDQ5MzY4N2EzMWUwNGEyYThjYTA=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-01-17T20:49:11Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2021-01-17T20:49:11Z"}, "message": "Auto merge of #80679 - jackh726:predicate-kind-take2, r=lcnr\n\nRemove PredicateKind and instead only use Binder<PredicateAtom>\n\nOriginally brought up in https://github.com/rust-lang/rust/pull/76814#discussion_r546858171\n\nr? `@lcnr`", "tree": {"sha": "e1c25749be58c8ca538627492b6e53f995f7342c", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/e1c25749be58c8ca538627492b6e53f995f7342c"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/4253153db205251f72ea4493687a31e04a2a8ca0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/4253153db205251f72ea4493687a31e04a2a8ca0", "html_url": "https://github.com/rust-lang/rust/commit/4253153db205251f72ea4493687a31e04a2a8ca0", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/4253153db205251f72ea4493687a31e04a2a8ca0/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1f0fc02cc8ab4e0d9dd3e06a6d46fcb72b2a026f", "url": "https://api.github.com/repos/rust-lang/rust/commits/1f0fc02cc8ab4e0d9dd3e06a6d46fcb72b2a026f", "html_url": "https://github.com/rust-lang/rust/commit/1f0fc02cc8ab4e0d9dd3e06a6d46fcb72b2a026f"}, {"sha": "c4376ba24a488bf78003e35427d06e52b8b7479f", "url": "https://api.github.com/repos/rust-lang/rust/commits/c4376ba24a488bf78003e35427d06e52b8b7479f", "html_url": "https://github.com/rust-lang/rust/commit/c4376ba24a488bf78003e35427d06e52b8b7479f"}], "stats": {"total": 1414, "additions": 655, "deletions": 759}, "files": [{"sha": "4357eb34add23c515ac7000397be6666c2d275a1", "filename": "compiler/rustc_infer/src/infer/canonical/query_response.rs", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcanonical%2Fquery_response.rs?ref=4253153db205251f72ea4493687a31e04a2a8ca0", "patch": "@@ -530,19 +530,18 @@ impl<'cx, 'tcx> InferCtxt<'cx, 'tcx> {\n \n             let atom = match k1.unpack() {\n                 GenericArgKind::Lifetime(r1) => {\n-                    ty::PredicateAtom::RegionOutlives(ty::OutlivesPredicate(r1, r2))\n+                    ty::PredicateKind::RegionOutlives(ty::OutlivesPredicate(r1, r2))\n                 }\n                 GenericArgKind::Type(t1) => {\n-                    ty::PredicateAtom::TypeOutlives(ty::OutlivesPredicate(t1, r2))\n+                    ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(t1, r2))\n                 }\n                 GenericArgKind::Const(..) => {\n                     // Consts cannot outlive one another, so we don't expect to\n                     // encounter this branch.\n                     span_bug!(cause.span, \"unexpected const outlives {:?}\", constraint);\n                 }\n             };\n-            let predicate =\n-                predicate.rebind(atom).potentially_quantified(self.tcx, ty::PredicateKind::ForAll);\n+            let predicate = predicate.rebind(atom).to_predicate(self.tcx);\n \n             Obligation::new(cause.clone(), param_env, predicate)\n         })\n@@ -664,7 +663,7 @@ impl<'tcx> TypeRelatingDelegate<'tcx> for QueryTypeRelatingDelegate<'_, 'tcx> {\n         self.obligations.push(Obligation {\n             cause: self.cause.clone(),\n             param_env: self.param_env,\n-            predicate: ty::PredicateAtom::RegionOutlives(ty::OutlivesPredicate(sup, sub))\n+            predicate: ty::PredicateKind::RegionOutlives(ty::OutlivesPredicate(sup, sub))\n                 .to_predicate(self.infcx.tcx),\n             recursion_depth: 0,\n         });"}, {"sha": "b344086e95e77370d2f8dc1ead3da9ed1f223806", "filename": "compiler/rustc_infer/src/infer/combine.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fcombine.rs?ref=4253153db205251f72ea4493687a31e04a2a8ca0", "patch": "@@ -358,7 +358,7 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n             self.obligations.push(Obligation::new(\n                 self.trace.cause.clone(),\n                 self.param_env,\n-                ty::PredicateAtom::WellFormed(b_ty.into()).to_predicate(self.infcx.tcx),\n+                ty::PredicateKind::WellFormed(b_ty.into()).to_predicate(self.infcx.tcx),\n             ));\n         }\n \n@@ -451,9 +451,9 @@ impl<'infcx, 'tcx> CombineFields<'infcx, 'tcx> {\n         b: &'tcx ty::Const<'tcx>,\n     ) {\n         let predicate = if a_is_expected {\n-            ty::PredicateAtom::ConstEquate(a, b)\n+            ty::PredicateKind::ConstEquate(a, b)\n         } else {\n-            ty::PredicateAtom::ConstEquate(b, a)\n+            ty::PredicateKind::ConstEquate(b, a)\n         };\n         self.obligations.push(Obligation::new(\n             self.trace.cause.clone(),"}, {"sha": "c39daea0811e021bbfc800c4d3fbbd5962fff837", "filename": "compiler/rustc_infer/src/infer/error_reporting/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Ferror_reporting%2Fmod.rs?ref=4253153db205251f72ea4493687a31e04a2a8ca0", "patch": "@@ -1706,8 +1706,8 @@ impl<'a, 'tcx> InferCtxt<'a, 'tcx> {\n \n             for (predicate, _) in bounds {\n                 let predicate = predicate.subst(self.tcx, substs);\n-                if let ty::PredicateAtom::Projection(projection_predicate) =\n-                    predicate.skip_binders()\n+                if let ty::PredicateKind::Projection(projection_predicate) =\n+                    predicate.kind().skip_binder()\n                 {\n                     if projection_predicate.projection_ty.item_def_id == item_def_id {\n                         // We don't account for multiple `Future::Output = Ty` contraints."}, {"sha": "07c75d50d91da2bed9ccd65dac7e0424f3844b21", "filename": "compiler/rustc_infer/src/infer/outlives/mod.rs", "status": "modified", "additions": 14, "deletions": 15, "changes": 29, "blob_url": "https://github.com/rust-lang/rust/blob/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Foutlives%2Fmod.rs?ref=4253153db205251f72ea4493687a31e04a2a8ca0", "patch": "@@ -6,7 +6,6 @@ pub mod verify;\n \n use rustc_middle::traits::query::OutlivesBound;\n use rustc_middle::ty;\n-use rustc_middle::ty::fold::TypeFoldable;\n \n pub fn explicit_outlives_bounds<'tcx>(\n     param_env: ty::ParamEnv<'tcx>,\n@@ -15,20 +14,20 @@ pub fn explicit_outlives_bounds<'tcx>(\n     param_env\n         .caller_bounds()\n         .into_iter()\n-        .map(ty::Predicate::skip_binders)\n-        .filter(|atom| !atom.has_escaping_bound_vars())\n-        .filter_map(move |atom| match atom {\n-            ty::PredicateAtom::Projection(..)\n-            | ty::PredicateAtom::Trait(..)\n-            | ty::PredicateAtom::Subtype(..)\n-            | ty::PredicateAtom::WellFormed(..)\n-            | ty::PredicateAtom::ObjectSafe(..)\n-            | ty::PredicateAtom::ClosureKind(..)\n-            | ty::PredicateAtom::TypeOutlives(..)\n-            | ty::PredicateAtom::ConstEvaluatable(..)\n-            | ty::PredicateAtom::ConstEquate(..)\n-            | ty::PredicateAtom::TypeWellFormedFromEnv(..) => None,\n-            ty::PredicateAtom::RegionOutlives(ty::OutlivesPredicate(r_a, r_b)) => {\n+        .map(ty::Predicate::kind)\n+        .filter_map(ty::Binder::no_bound_vars)\n+        .filter_map(move |kind| match kind {\n+            ty::PredicateKind::Projection(..)\n+            | ty::PredicateKind::Trait(..)\n+            | ty::PredicateKind::Subtype(..)\n+            | ty::PredicateKind::WellFormed(..)\n+            | ty::PredicateKind::ObjectSafe(..)\n+            | ty::PredicateKind::ClosureKind(..)\n+            | ty::PredicateKind::TypeOutlives(..)\n+            | ty::PredicateKind::ConstEvaluatable(..)\n+            | ty::PredicateKind::ConstEquate(..)\n+            | ty::PredicateKind::TypeWellFormedFromEnv(..) => None,\n+            ty::PredicateKind::RegionOutlives(ty::OutlivesPredicate(r_a, r_b)) => {\n                 Some(OutlivesBound::RegionSubRegion(r_b, r_a))\n             }\n         })"}, {"sha": "668719851583c6efb6eb6e916c46f548a3a26f7d", "filename": "compiler/rustc_infer/src/infer/sub.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Finfer%2Fsub.rs?ref=4253153db205251f72ea4493687a31e04a2a8ca0", "patch": "@@ -100,7 +100,7 @@ impl TypeRelation<'tcx> for Sub<'combine, 'infcx, 'tcx> {\n                 self.fields.obligations.push(Obligation::new(\n                     self.fields.trace.cause.clone(),\n                     self.fields.param_env,\n-                    ty::PredicateAtom::Subtype(ty::SubtypePredicate {\n+                    ty::PredicateKind::Subtype(ty::SubtypePredicate {\n                         a_is_expected: self.a_is_expected,\n                         a,\n                         b,"}, {"sha": "13cf1e1083f7fdc328dd3d3e611fe904293acf62", "filename": "compiler/rustc_infer/src/traits/util.rs", "status": "modified", "additions": 16, "deletions": 21, "changes": 37, "blob_url": "https://github.com/rust-lang/rust/blob/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_infer%2Fsrc%2Ftraits%2Futil.rs?ref=4253153db205251f72ea4493687a31e04a2a8ca0", "patch": "@@ -9,13 +9,8 @@ pub fn anonymize_predicate<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     pred: ty::Predicate<'tcx>,\n ) -> ty::Predicate<'tcx> {\n-    match *pred.kind() {\n-        ty::PredicateKind::ForAll(binder) => {\n-            let new = ty::PredicateKind::ForAll(tcx.anonymize_late_bound_regions(binder));\n-            tcx.reuse_or_mk_predicate(pred, new)\n-        }\n-        ty::PredicateKind::Atom(_) => pred,\n-    }\n+    let new = tcx.anonymize_late_bound_regions(pred.kind());\n+    tcx.reuse_or_mk_predicate(pred, new)\n }\n \n struct PredicateSet<'tcx> {\n@@ -126,9 +121,9 @@ impl Elaborator<'tcx> {\n     fn elaborate(&mut self, obligation: &PredicateObligation<'tcx>) {\n         let tcx = self.visited.tcx;\n \n-        let bound_predicate = obligation.predicate.bound_atom();\n+        let bound_predicate = obligation.predicate.kind();\n         match bound_predicate.skip_binder() {\n-            ty::PredicateAtom::Trait(data, _) => {\n+            ty::PredicateKind::Trait(data, _) => {\n                 // Get predicates declared on the trait.\n                 let predicates = tcx.super_predicates_of(data.def_id());\n \n@@ -150,36 +145,36 @@ impl Elaborator<'tcx> {\n \n                 self.stack.extend(obligations);\n             }\n-            ty::PredicateAtom::WellFormed(..) => {\n+            ty::PredicateKind::WellFormed(..) => {\n                 // Currently, we do not elaborate WF predicates,\n                 // although we easily could.\n             }\n-            ty::PredicateAtom::ObjectSafe(..) => {\n+            ty::PredicateKind::ObjectSafe(..) => {\n                 // Currently, we do not elaborate object-safe\n                 // predicates.\n             }\n-            ty::PredicateAtom::Subtype(..) => {\n+            ty::PredicateKind::Subtype(..) => {\n                 // Currently, we do not \"elaborate\" predicates like `X <: Y`,\n                 // though conceivably we might.\n             }\n-            ty::PredicateAtom::Projection(..) => {\n+            ty::PredicateKind::Projection(..) => {\n                 // Nothing to elaborate in a projection predicate.\n             }\n-            ty::PredicateAtom::ClosureKind(..) => {\n+            ty::PredicateKind::ClosureKind(..) => {\n                 // Nothing to elaborate when waiting for a closure's kind to be inferred.\n             }\n-            ty::PredicateAtom::ConstEvaluatable(..) => {\n+            ty::PredicateKind::ConstEvaluatable(..) => {\n                 // Currently, we do not elaborate const-evaluatable\n                 // predicates.\n             }\n-            ty::PredicateAtom::ConstEquate(..) => {\n+            ty::PredicateKind::ConstEquate(..) => {\n                 // Currently, we do not elaborate const-equate\n                 // predicates.\n             }\n-            ty::PredicateAtom::RegionOutlives(..) => {\n+            ty::PredicateKind::RegionOutlives(..) => {\n                 // Nothing to elaborate from `'a: 'b`.\n             }\n-            ty::PredicateAtom::TypeOutlives(ty::OutlivesPredicate(ty_max, r_min)) => {\n+            ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(ty_max, r_min)) => {\n                 // We know that `T: 'a` for some type `T`. We can\n                 // often elaborate this. For example, if we know that\n                 // `[U]: 'a`, that implies that `U: 'a`. Similarly, if\n@@ -209,15 +204,15 @@ impl Elaborator<'tcx> {\n                                 if r.is_late_bound() {\n                                     None\n                                 } else {\n-                                    Some(ty::PredicateAtom::RegionOutlives(ty::OutlivesPredicate(\n+                                    Some(ty::PredicateKind::RegionOutlives(ty::OutlivesPredicate(\n                                         r, r_min,\n                                     )))\n                                 }\n                             }\n \n                             Component::Param(p) => {\n                                 let ty = tcx.mk_ty_param(p.index, p.name);\n-                                Some(ty::PredicateAtom::TypeOutlives(ty::OutlivesPredicate(\n+                                Some(ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(\n                                     ty, r_min,\n                                 )))\n                             }\n@@ -242,7 +237,7 @@ impl Elaborator<'tcx> {\n                         }),\n                 );\n             }\n-            ty::PredicateAtom::TypeWellFormedFromEnv(..) => {\n+            ty::PredicateKind::TypeWellFormedFromEnv(..) => {\n                 // Nothing to elaborate\n             }\n         }"}, {"sha": "8cdb33ea3175f681be4cd6e5e9d8293b14153d7e", "filename": "compiler/rustc_lint/src/builtin.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Fbuiltin.rs?ref=4253153db205251f72ea4493687a31e04a2a8ca0", "patch": "@@ -1550,13 +1550,13 @@ declare_lint_pass!(\n impl<'tcx> LateLintPass<'tcx> for TrivialConstraints {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::Item<'tcx>) {\n         use rustc_middle::ty::fold::TypeFoldable;\n-        use rustc_middle::ty::PredicateAtom::*;\n+        use rustc_middle::ty::PredicateKind::*;\n \n         if cx.tcx.features().trivial_bounds {\n             let def_id = cx.tcx.hir().local_def_id(item.hir_id);\n             let predicates = cx.tcx.predicates_of(def_id);\n             for &(predicate, span) in predicates.predicates {\n-                let predicate_kind_name = match predicate.skip_binders() {\n+                let predicate_kind_name = match predicate.kind().skip_binder() {\n                     Trait(..) => \"Trait\",\n                     TypeOutlives(..) |\n                     RegionOutlives(..) => \"Lifetime\",\n@@ -1936,8 +1936,8 @@ impl ExplicitOutlivesRequirements {\n     ) -> Vec<ty::Region<'tcx>> {\n         inferred_outlives\n             .iter()\n-            .filter_map(|(pred, _)| match pred.skip_binders() {\n-                ty::PredicateAtom::RegionOutlives(ty::OutlivesPredicate(a, b)) => match a {\n+            .filter_map(|(pred, _)| match pred.kind().skip_binder() {\n+                ty::PredicateKind::RegionOutlives(ty::OutlivesPredicate(a, b)) => match a {\n                     ty::ReEarlyBound(ebr) if ebr.index == index => Some(b),\n                     _ => None,\n                 },\n@@ -1952,8 +1952,8 @@ impl ExplicitOutlivesRequirements {\n     ) -> Vec<ty::Region<'tcx>> {\n         inferred_outlives\n             .iter()\n-            .filter_map(|(pred, _)| match pred.skip_binders() {\n-                ty::PredicateAtom::TypeOutlives(ty::OutlivesPredicate(a, b)) => {\n+            .filter_map(|(pred, _)| match pred.kind().skip_binder() {\n+                ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(a, b)) => {\n                     a.is_param(index).then_some(b)\n                 }\n                 _ => None,"}, {"sha": "b031c1108c66f9423f1b46a77b8a97e74830fcf2", "filename": "compiler/rustc_lint/src/traits.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_lint%2Fsrc%2Ftraits.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_lint%2Fsrc%2Ftraits.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Ftraits.rs?ref=4253153db205251f72ea4493687a31e04a2a8ca0", "patch": "@@ -45,12 +45,12 @@ declare_lint_pass!(\n \n impl<'tcx> LateLintPass<'tcx> for DropTraitConstraints {\n     fn check_item(&mut self, cx: &LateContext<'tcx>, item: &'tcx hir::Item<'tcx>) {\n-        use rustc_middle::ty::PredicateAtom::*;\n+        use rustc_middle::ty::PredicateKind::*;\n \n         let def_id = cx.tcx.hir().local_def_id(item.hir_id);\n         let predicates = cx.tcx.explicit_predicates_of(def_id);\n         for &(predicate, span) in predicates.predicates {\n-            let trait_predicate = match predicate.skip_binders() {\n+            let trait_predicate = match predicate.kind().skip_binder() {\n                 Trait(trait_predicate, _constness) => trait_predicate,\n                 _ => continue,\n             };"}, {"sha": "c1a3eecbbc7efe53b5ecb3ab54299994b034c296", "filename": "compiler/rustc_lint/src/unused.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_lint%2Fsrc%2Funused.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_lint%2Fsrc%2Funused.rs?ref=4253153db205251f72ea4493687a31e04a2a8ca0", "patch": "@@ -202,8 +202,8 @@ impl<'tcx> LateLintPass<'tcx> for UnusedResults {\n                     let mut has_emitted = false;\n                     for &(predicate, _) in cx.tcx.explicit_item_bounds(def) {\n                         // We only look at the `DefId`, so it is safe to skip the binder here.\n-                        if let ty::PredicateAtom::Trait(ref poly_trait_predicate, _) =\n-                            predicate.skip_binders()\n+                        if let ty::PredicateKind::Trait(ref poly_trait_predicate, _) =\n+                            predicate.kind().skip_binder()\n                         {\n                             let def_id = poly_trait_predicate.trait_ref.def_id;\n                             let descr_pre ="}, {"sha": "5e2674254b2955116a6929f12930f89438fbc51e", "filename": "compiler/rustc_metadata/src/rmeta/encoder.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_metadata%2Fsrc%2Frmeta%2Fencoder.rs?ref=4253153db205251f72ea4493687a31e04a2a8ca0", "patch": "@@ -46,7 +46,7 @@ pub(super) struct EncodeContext<'a, 'tcx> {\n \n     lazy_state: LazyState,\n     type_shorthands: FxHashMap<Ty<'tcx>, usize>,\n-    predicate_shorthands: FxHashMap<ty::Predicate<'tcx>, usize>,\n+    predicate_shorthands: FxHashMap<ty::PredicateKind<'tcx>, usize>,\n \n     interpret_allocs: FxIndexSet<interpret::AllocId>,\n \n@@ -328,7 +328,7 @@ impl<'a, 'tcx> TyEncoder<'tcx> for EncodeContext<'a, 'tcx> {\n         &mut self.type_shorthands\n     }\n \n-    fn predicate_shorthands(&mut self) -> &mut FxHashMap<rustc_middle::ty::Predicate<'tcx>, usize> {\n+    fn predicate_shorthands(&mut self) -> &mut FxHashMap<ty::PredicateKind<'tcx>, usize> {\n         &mut self.predicate_shorthands\n     }\n "}, {"sha": "a7b0ff45b976c5231f94fcbbdee2c854313b1075", "filename": "compiler/rustc_middle/src/ty/codec.rs", "status": "modified", "additions": 49, "deletions": 10, "changes": 59, "blob_url": "https://github.com/rust-lang/rust/blob/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcodec.rs?ref=4253153db205251f72ea4493687a31e04a2a8ca0", "patch": "@@ -43,10 +43,12 @@ impl<'tcx, E: TyEncoder<'tcx>> EncodableWithShorthand<'tcx, E> for Ty<'tcx> {\n     }\n }\n \n-impl<'tcx, E: TyEncoder<'tcx>> EncodableWithShorthand<'tcx, E> for ty::Predicate<'tcx> {\n+impl<'tcx, E: TyEncoder<'tcx>> EncodableWithShorthand<'tcx, E> for ty::PredicateKind<'tcx> {\n     type Variant = ty::PredicateKind<'tcx>;\n+\n+    #[inline]\n     fn variant(&self) -> &Self::Variant {\n-        self.kind()\n+        self\n     }\n }\n \n@@ -55,7 +57,7 @@ pub trait TyEncoder<'tcx>: Encoder {\n \n     fn position(&self) -> usize;\n     fn type_shorthands(&mut self) -> &mut FxHashMap<Ty<'tcx>, usize>;\n-    fn predicate_shorthands(&mut self) -> &mut FxHashMap<ty::Predicate<'tcx>, usize>;\n+    fn predicate_shorthands(&mut self) -> &mut FxHashMap<ty::PredicateKind<'tcx>, usize>;\n     fn encode_alloc_id(&mut self, alloc_id: &AllocId) -> Result<(), Self::Error>;\n }\n \n@@ -118,9 +120,15 @@ impl<'tcx, E: TyEncoder<'tcx>> Encodable<E> for Ty<'tcx> {\n     }\n }\n \n+impl<'tcx, E: TyEncoder<'tcx>> Encodable<E> for ty::Binder<ty::PredicateKind<'tcx>> {\n+    fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n+        encode_with_shorthand(e, &self.skip_binder(), TyEncoder::predicate_shorthands)\n+    }\n+}\n+\n impl<'tcx, E: TyEncoder<'tcx>> Encodable<E> for ty::Predicate<'tcx> {\n     fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n-        encode_with_shorthand(e, self, TyEncoder::predicate_shorthands)\n+        self.kind().encode(e)\n     }\n }\n \n@@ -218,18 +226,24 @@ impl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for Ty<'tcx> {\n     }\n }\n \n-impl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for ty::Predicate<'tcx> {\n-    fn decode(decoder: &mut D) -> Result<ty::Predicate<'tcx>, D::Error> {\n+impl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for ty::Binder<ty::PredicateKind<'tcx>> {\n+    fn decode(decoder: &mut D) -> Result<ty::Binder<ty::PredicateKind<'tcx>>, D::Error> {\n         // Handle shorthands first, if we have an usize > 0x80.\n-        let predicate_kind = if decoder.positioned_at_shorthand() {\n+        Ok(ty::Binder::bind(if decoder.positioned_at_shorthand() {\n             let pos = decoder.read_usize()?;\n             assert!(pos >= SHORTHAND_OFFSET);\n             let shorthand = pos - SHORTHAND_OFFSET;\n \n-            decoder.with_position(shorthand, ty::PredicateKind::decode)\n+            decoder.with_position(shorthand, ty::PredicateKind::decode)?\n         } else {\n-            ty::PredicateKind::decode(decoder)\n-        }?;\n+            ty::PredicateKind::decode(decoder)?\n+        }))\n+    }\n+}\n+\n+impl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for ty::Predicate<'tcx> {\n+    fn decode(decoder: &mut D) -> Result<ty::Predicate<'tcx>, D::Error> {\n+        let predicate_kind = Decodable::decode(decoder)?;\n         let predicate = decoder.tcx().mk_predicate(predicate_kind);\n         Ok(predicate)\n     }\n@@ -457,3 +471,28 @@ macro_rules! implement_ty_decoder {\n         }\n     }\n }\n+\n+macro_rules! impl_binder_encode_decode {\n+    ($($t:ty),+ $(,)?) => {\n+        $(\n+            impl<'tcx, E: TyEncoder<'tcx>> Encodable<E> for ty::Binder<$t> {\n+                fn encode(&self, e: &mut E) -> Result<(), E::Error> {\n+                    self.as_ref().skip_binder().encode(e)\n+                }\n+            }\n+            impl<'tcx, D: TyDecoder<'tcx>> Decodable<D> for ty::Binder<$t> {\n+                fn decode(decoder: &mut D) -> Result<Self, D::Error> {\n+                    Ok(ty::Binder::bind(Decodable::decode(decoder)?))\n+                }\n+            }\n+        )*\n+    }\n+}\n+\n+impl_binder_encode_decode! {\n+    &'tcx ty::List<Ty<'tcx>>,\n+    ty::FnSig<'tcx>,\n+    ty::ExistentialPredicate<'tcx>,\n+    ty::TraitRef<'tcx>,\n+    Vec<ty::GeneratorInteriorTypeCause<'tcx>>,\n+}"}, {"sha": "1cbf761e6c738fc5c9b688088e9fe44809718db0", "filename": "compiler/rustc_middle/src/ty/context.rs", "status": "modified", "additions": 10, "deletions": 16, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fcontext.rs?ref=4253153db205251f72ea4493687a31e04a2a8ca0", "patch": "@@ -18,9 +18,9 @@ use crate::ty::query::{self, TyCtxtAt};\n use crate::ty::subst::{GenericArg, GenericArgKind, InternalSubsts, Subst, SubstsRef, UserSubsts};\n use crate::ty::TyKind::*;\n use crate::ty::{\n-    self, AdtDef, AdtKind, BindingMode, BoundVar, CanonicalPolyFnSig, Const, ConstVid, DefIdTree,\n-    ExistentialPredicate, FloatVar, FloatVid, GenericParamDefKind, InferConst, InferTy, IntVar,\n-    IntVid, List, ParamConst, ParamTy, PolyFnSig, Predicate, PredicateInner, PredicateKind,\n+    self, AdtDef, AdtKind, Binder, BindingMode, BoundVar, CanonicalPolyFnSig, Const, ConstVid,\n+    DefIdTree, ExistentialPredicate, FloatVar, FloatVid, GenericParamDefKind, InferConst, InferTy,\n+    IntVar, IntVid, List, ParamConst, ParamTy, PolyFnSig, Predicate, PredicateInner, PredicateKind,\n     ProjectionTy, Region, RegionKind, ReprOptions, TraitObjectVisitor, Ty, TyKind, TyS, TyVar,\n     TyVid, TypeAndMut, Visibility,\n };\n@@ -134,7 +134,7 @@ impl<'tcx> CtxtInterners<'tcx> {\n     }\n \n     #[inline(never)]\n-    fn intern_predicate(&self, kind: PredicateKind<'tcx>) -> &'tcx PredicateInner<'tcx> {\n+    fn intern_predicate(&self, kind: Binder<PredicateKind<'tcx>>) -> &'tcx PredicateInner<'tcx> {\n         self.predicate\n             .intern(kind, |kind| {\n                 let flags = super::flags::FlagComputation::for_predicate(kind);\n@@ -1951,8 +1951,8 @@ impl<'tcx> Hash for Interned<'tcx, PredicateInner<'tcx>> {\n     }\n }\n \n-impl<'tcx> Borrow<PredicateKind<'tcx>> for Interned<'tcx, PredicateInner<'tcx>> {\n-    fn borrow<'a>(&'a self) -> &'a PredicateKind<'tcx> {\n+impl<'tcx> Borrow<Binder<PredicateKind<'tcx>>> for Interned<'tcx, PredicateInner<'tcx>> {\n+    fn borrow<'a>(&'a self) -> &'a Binder<PredicateKind<'tcx>> {\n         &self.0.kind\n     }\n }\n@@ -1990,12 +1990,6 @@ impl<'tcx> Borrow<Const<'tcx>> for Interned<'tcx, Const<'tcx>> {\n     }\n }\n \n-impl<'tcx> Borrow<PredicateKind<'tcx>> for Interned<'tcx, PredicateKind<'tcx>> {\n-    fn borrow<'a>(&'a self) -> &'a PredicateKind<'tcx> {\n-        &self.0\n-    }\n-}\n-\n macro_rules! direct_interners {\n     ($($name:ident: $method:ident($ty:ty),)+) => {\n         $(impl<'tcx> PartialEq for Interned<'tcx, $ty> {\n@@ -2094,18 +2088,18 @@ impl<'tcx> TyCtxt<'tcx> {\n     }\n \n     #[inline]\n-    pub fn mk_predicate(self, kind: PredicateKind<'tcx>) -> Predicate<'tcx> {\n-        let inner = self.interners.intern_predicate(kind);\n+    pub fn mk_predicate(self, binder: Binder<PredicateKind<'tcx>>) -> Predicate<'tcx> {\n+        let inner = self.interners.intern_predicate(binder);\n         Predicate { inner }\n     }\n \n     #[inline]\n     pub fn reuse_or_mk_predicate(\n         self,\n         pred: Predicate<'tcx>,\n-        kind: PredicateKind<'tcx>,\n+        binder: Binder<PredicateKind<'tcx>>,\n     ) -> Predicate<'tcx> {\n-        if *pred.kind() != kind { self.mk_predicate(kind) } else { pred }\n+        if pred.kind() != binder { self.mk_predicate(binder) } else { pred }\n     }\n \n     pub fn mk_mach_int(self, tm: ast::IntTy) -> Ty<'tcx> {"}, {"sha": "6ecd1ebf37039b3c0f3d8a6f26cddf89bad0b7a4", "filename": "compiler/rustc_middle/src/ty/flags.rs", "status": "modified", "additions": 16, "deletions": 23, "changes": 39, "blob_url": "https://github.com/rust-lang/rust/blob/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fflags.rs?ref=4253153db205251f72ea4493687a31e04a2a8ca0", "patch": "@@ -22,9 +22,9 @@ impl FlagComputation {\n         result\n     }\n \n-    pub fn for_predicate(kind: ty::PredicateKind<'_>) -> FlagComputation {\n+    pub fn for_predicate(binder: ty::Binder<ty::PredicateKind<'_>>) -> FlagComputation {\n         let mut result = FlagComputation::new();\n-        result.add_predicate_kind(kind);\n+        result.add_predicate(binder);\n         result\n     }\n \n@@ -204,53 +204,46 @@ impl FlagComputation {\n         }\n     }\n \n-    fn add_predicate_kind(&mut self, kind: ty::PredicateKind<'_>) {\n-        match kind {\n-            ty::PredicateKind::ForAll(binder) => {\n-                self.bound_computation(binder, |computation, atom| {\n-                    computation.add_predicate_atom(atom)\n-                });\n-            }\n-            ty::PredicateKind::Atom(atom) => self.add_predicate_atom(atom),\n-        }\n+    fn add_predicate(&mut self, binder: ty::Binder<ty::PredicateKind<'_>>) {\n+        self.bound_computation(binder, |computation, atom| computation.add_predicate_atom(atom));\n     }\n \n-    fn add_predicate_atom(&mut self, atom: ty::PredicateAtom<'_>) {\n+    fn add_predicate_atom(&mut self, atom: ty::PredicateKind<'_>) {\n         match atom {\n-            ty::PredicateAtom::Trait(trait_pred, _constness) => {\n+            ty::PredicateKind::Trait(trait_pred, _constness) => {\n                 self.add_substs(trait_pred.trait_ref.substs);\n             }\n-            ty::PredicateAtom::RegionOutlives(ty::OutlivesPredicate(a, b)) => {\n+            ty::PredicateKind::RegionOutlives(ty::OutlivesPredicate(a, b)) => {\n                 self.add_region(a);\n                 self.add_region(b);\n             }\n-            ty::PredicateAtom::TypeOutlives(ty::OutlivesPredicate(ty, region)) => {\n+            ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(ty, region)) => {\n                 self.add_ty(ty);\n                 self.add_region(region);\n             }\n-            ty::PredicateAtom::Subtype(ty::SubtypePredicate { a_is_expected: _, a, b }) => {\n+            ty::PredicateKind::Subtype(ty::SubtypePredicate { a_is_expected: _, a, b }) => {\n                 self.add_ty(a);\n                 self.add_ty(b);\n             }\n-            ty::PredicateAtom::Projection(ty::ProjectionPredicate { projection_ty, ty }) => {\n+            ty::PredicateKind::Projection(ty::ProjectionPredicate { projection_ty, ty }) => {\n                 self.add_projection_ty(projection_ty);\n                 self.add_ty(ty);\n             }\n-            ty::PredicateAtom::WellFormed(arg) => {\n+            ty::PredicateKind::WellFormed(arg) => {\n                 self.add_substs(slice::from_ref(&arg));\n             }\n-            ty::PredicateAtom::ObjectSafe(_def_id) => {}\n-            ty::PredicateAtom::ClosureKind(_def_id, substs, _kind) => {\n+            ty::PredicateKind::ObjectSafe(_def_id) => {}\n+            ty::PredicateKind::ClosureKind(_def_id, substs, _kind) => {\n                 self.add_substs(substs);\n             }\n-            ty::PredicateAtom::ConstEvaluatable(_def_id, substs) => {\n+            ty::PredicateKind::ConstEvaluatable(_def_id, substs) => {\n                 self.add_substs(substs);\n             }\n-            ty::PredicateAtom::ConstEquate(expected, found) => {\n+            ty::PredicateKind::ConstEquate(expected, found) => {\n                 self.add_const(expected);\n                 self.add_const(found);\n             }\n-            ty::PredicateAtom::TypeWellFormedFromEnv(ty) => {\n+            ty::PredicateKind::TypeWellFormedFromEnv(ty) => {\n                 self.add_ty(ty);\n             }\n         }"}, {"sha": "c6970df01785e3f946127ace349218dbbd7e2420", "filename": "compiler/rustc_middle/src/ty/mod.rs", "status": "modified", "additions": 39, "deletions": 121, "changes": 160, "blob_url": "https://github.com/rust-lang/rust/blob/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fmod.rs?ref=4253153db205251f72ea4493687a31e04a2a8ca0", "patch": "@@ -1069,14 +1069,14 @@ impl<'tcx> GenericPredicates<'tcx> {\n \n #[derive(Debug)]\n crate struct PredicateInner<'tcx> {\n-    kind: PredicateKind<'tcx>,\n+    kind: Binder<PredicateKind<'tcx>>,\n     flags: TypeFlags,\n     /// See the comment for the corresponding field of [TyS].\n     outer_exclusive_binder: ty::DebruijnIndex,\n }\n \n #[cfg(target_arch = \"x86_64\")]\n-static_assert_size!(PredicateInner<'_>, 48);\n+static_assert_size!(PredicateInner<'_>, 40);\n \n #[derive(Clone, Copy, Lift)]\n pub struct Predicate<'tcx> {\n@@ -1099,59 +1099,9 @@ impl Hash for Predicate<'_> {\n impl<'tcx> Eq for Predicate<'tcx> {}\n \n impl<'tcx> Predicate<'tcx> {\n-    #[inline(always)]\n-    pub fn kind(self) -> &'tcx PredicateKind<'tcx> {\n-        &self.inner.kind\n-    }\n-\n-    /// Returns the inner `PredicateAtom`.\n-    ///\n-    /// The returned atom may contain unbound variables bound to binders skipped in this method.\n-    /// It is safe to reapply binders to the given atom.\n-    ///\n-    /// Note that this method panics in case this predicate has unbound variables.\n-    pub fn skip_binders(self) -> PredicateAtom<'tcx> {\n-        match self.kind() {\n-            &PredicateKind::ForAll(binder) => binder.skip_binder(),\n-            &PredicateKind::Atom(atom) => {\n-                debug_assert!(!atom.has_escaping_bound_vars());\n-                atom\n-            }\n-        }\n-    }\n-\n-    /// Returns the inner `PredicateAtom`.\n-    ///\n-    /// Note that this method does not check if the predicate has unbound variables.\n-    ///\n-    /// Rebinding the returned atom can causes the previously bound variables\n-    /// to end up at the wrong binding level.\n-    pub fn skip_binders_unchecked(self) -> PredicateAtom<'tcx> {\n-        match self.kind() {\n-            &PredicateKind::ForAll(binder) => binder.skip_binder(),\n-            &PredicateKind::Atom(atom) => atom,\n-        }\n-    }\n-\n-    /// Converts this to a `Binder<PredicateAtom<'tcx>>`. If the value was an\n-    /// `Atom`, then it is not allowed to contain escaping bound vars.\n-    pub fn bound_atom(self) -> Binder<PredicateAtom<'tcx>> {\n-        match self.kind() {\n-            &PredicateKind::ForAll(binder) => binder,\n-            &PredicateKind::Atom(atom) => {\n-                debug_assert!(!atom.has_escaping_bound_vars());\n-                Binder::dummy(atom)\n-            }\n-        }\n-    }\n-\n-    /// Allows using a `Binder<PredicateAtom<'tcx>>` even if the given predicate previously\n-    /// contained unbound variables by shifting these variables outwards.\n-    pub fn bound_atom_with_opt_escaping(self, tcx: TyCtxt<'tcx>) -> Binder<PredicateAtom<'tcx>> {\n-        match self.kind() {\n-            &PredicateKind::ForAll(binder) => binder,\n-            &PredicateKind::Atom(atom) => Binder::wrap_nonbinding(tcx, atom),\n-        }\n+    /// Gets the inner `Binder<PredicateKind<'tcx>>`.\n+    pub fn kind(self) -> Binder<PredicateKind<'tcx>> {\n+        self.inner.kind\n     }\n }\n \n@@ -1173,14 +1123,6 @@ impl<'a, 'tcx> HashStable<StableHashingContext<'a>> for Predicate<'tcx> {\n #[derive(Clone, Copy, PartialEq, Eq, Hash, TyEncodable, TyDecodable)]\n #[derive(HashStable, TypeFoldable)]\n pub enum PredicateKind<'tcx> {\n-    /// `for<'a>: ...`\n-    ForAll(Binder<PredicateAtom<'tcx>>),\n-    Atom(PredicateAtom<'tcx>),\n-}\n-\n-#[derive(Clone, Copy, PartialEq, Eq, Hash, TyEncodable, TyDecodable)]\n-#[derive(HashStable, TypeFoldable)]\n-pub enum PredicateAtom<'tcx> {\n     /// Corresponds to `where Foo: Bar<A, B, C>`. `Foo` here would be\n     /// the `Self` type of the trait reference and `A`, `B`, and `C`\n     /// would be the type parameters.\n@@ -1226,21 +1168,6 @@ pub enum PredicateAtom<'tcx> {\n     TypeWellFormedFromEnv(Ty<'tcx>),\n }\n \n-impl<'tcx> Binder<PredicateAtom<'tcx>> {\n-    /// Wraps `self` with the given qualifier if this predicate has any unbound variables.\n-    pub fn potentially_quantified(\n-        self,\n-        tcx: TyCtxt<'tcx>,\n-        qualifier: impl FnOnce(Binder<PredicateAtom<'tcx>>) -> PredicateKind<'tcx>,\n-    ) -> Predicate<'tcx> {\n-        match self.no_bound_vars() {\n-            Some(atom) => PredicateKind::Atom(atom),\n-            None => qualifier(self),\n-        }\n-        .to_predicate(tcx)\n-    }\n-}\n-\n /// The crate outlives map is computed during typeck and contains the\n /// outlives of every item in the local crate. You should not use it\n /// directly, because to do so will make your pass dependent on the\n@@ -1326,13 +1253,9 @@ impl<'tcx> Predicate<'tcx> {\n         // from the substitution and the value being substituted into, and\n         // this trick achieves that).\n         let substs = trait_ref.skip_binder().substs;\n-        let pred = self.skip_binders();\n+        let pred = self.kind().skip_binder();\n         let new = pred.subst(tcx, substs);\n-        if new != pred {\n-            ty::Binder::bind(new).potentially_quantified(tcx, PredicateKind::ForAll)\n-        } else {\n-            self\n-        }\n+        tcx.reuse_or_mk_predicate(self, ty::Binder::bind(new))\n     }\n }\n \n@@ -1453,24 +1376,23 @@ pub trait ToPredicate<'tcx> {\n     fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx>;\n }\n \n-impl ToPredicate<'tcx> for PredicateKind<'tcx> {\n+impl ToPredicate<'tcx> for Binder<PredicateKind<'tcx>> {\n     #[inline(always)]\n     fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n         tcx.mk_predicate(self)\n     }\n }\n \n-impl ToPredicate<'tcx> for PredicateAtom<'tcx> {\n+impl ToPredicate<'tcx> for PredicateKind<'tcx> {\n     #[inline(always)]\n     fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n-        debug_assert!(!self.has_escaping_bound_vars(), \"escaping bound vars for {:?}\", self);\n-        tcx.mk_predicate(PredicateKind::Atom(self))\n+        tcx.mk_predicate(Binder::dummy(self))\n     }\n }\n \n impl<'tcx> ToPredicate<'tcx> for ConstnessAnd<TraitRef<'tcx>> {\n     fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n-        PredicateAtom::Trait(ty::TraitPredicate { trait_ref: self.value }, self.constness)\n+        PredicateKind::Trait(ty::TraitPredicate { trait_ref: self.value }, self.constness)\n             .to_predicate(tcx)\n     }\n }\n@@ -1487,66 +1409,62 @@ impl<'tcx> ToPredicate<'tcx> for ConstnessAnd<PolyTraitRef<'tcx>> {\n \n impl<'tcx> ToPredicate<'tcx> for ConstnessAnd<PolyTraitPredicate<'tcx>> {\n     fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n-        self.value\n-            .map_bound(|value| PredicateAtom::Trait(value, self.constness))\n-            .potentially_quantified(tcx, PredicateKind::ForAll)\n+        self.value.map_bound(|value| PredicateKind::Trait(value, self.constness)).to_predicate(tcx)\n     }\n }\n \n impl<'tcx> ToPredicate<'tcx> for PolyRegionOutlivesPredicate<'tcx> {\n     fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n-        self.map_bound(PredicateAtom::RegionOutlives)\n-            .potentially_quantified(tcx, PredicateKind::ForAll)\n+        self.map_bound(PredicateKind::RegionOutlives).to_predicate(tcx)\n     }\n }\n \n impl<'tcx> ToPredicate<'tcx> for PolyTypeOutlivesPredicate<'tcx> {\n     fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n-        self.map_bound(PredicateAtom::TypeOutlives)\n-            .potentially_quantified(tcx, PredicateKind::ForAll)\n+        self.map_bound(PredicateKind::TypeOutlives).to_predicate(tcx)\n     }\n }\n \n impl<'tcx> ToPredicate<'tcx> for PolyProjectionPredicate<'tcx> {\n     fn to_predicate(self, tcx: TyCtxt<'tcx>) -> Predicate<'tcx> {\n-        self.map_bound(PredicateAtom::Projection).potentially_quantified(tcx, PredicateKind::ForAll)\n+        self.map_bound(PredicateKind::Projection).to_predicate(tcx)\n     }\n }\n \n impl<'tcx> Predicate<'tcx> {\n     pub fn to_opt_poly_trait_ref(self) -> Option<ConstnessAnd<PolyTraitRef<'tcx>>> {\n-        let predicate = self.bound_atom();\n+        let predicate = self.kind();\n         match predicate.skip_binder() {\n-            PredicateAtom::Trait(t, constness) => {\n+            PredicateKind::Trait(t, constness) => {\n                 Some(ConstnessAnd { constness, value: predicate.rebind(t.trait_ref) })\n             }\n-            PredicateAtom::Projection(..)\n-            | PredicateAtom::Subtype(..)\n-            | PredicateAtom::RegionOutlives(..)\n-            | PredicateAtom::WellFormed(..)\n-            | PredicateAtom::ObjectSafe(..)\n-            | PredicateAtom::ClosureKind(..)\n-            | PredicateAtom::TypeOutlives(..)\n-            | PredicateAtom::ConstEvaluatable(..)\n-            | PredicateAtom::ConstEquate(..)\n-            | PredicateAtom::TypeWellFormedFromEnv(..) => None,\n+            PredicateKind::Projection(..)\n+            | PredicateKind::Subtype(..)\n+            | PredicateKind::RegionOutlives(..)\n+            | PredicateKind::WellFormed(..)\n+            | PredicateKind::ObjectSafe(..)\n+            | PredicateKind::ClosureKind(..)\n+            | PredicateKind::TypeOutlives(..)\n+            | PredicateKind::ConstEvaluatable(..)\n+            | PredicateKind::ConstEquate(..)\n+            | PredicateKind::TypeWellFormedFromEnv(..) => None,\n         }\n     }\n \n     pub fn to_opt_type_outlives(self) -> Option<PolyTypeOutlivesPredicate<'tcx>> {\n-        let predicate = self.bound_atom();\n+        let predicate = self.kind();\n         match predicate.skip_binder() {\n-            PredicateAtom::TypeOutlives(data) => Some(predicate.rebind(data)),\n-            PredicateAtom::Trait(..)\n-            | PredicateAtom::Projection(..)\n-            | PredicateAtom::Subtype(..)\n-            | PredicateAtom::RegionOutlives(..)\n-            | PredicateAtom::WellFormed(..)\n-            | PredicateAtom::ObjectSafe(..)\n-            | PredicateAtom::ClosureKind(..)\n-            | PredicateAtom::ConstEvaluatable(..)\n-            | PredicateAtom::ConstEquate(..)\n-            | PredicateAtom::TypeWellFormedFromEnv(..) => None,\n+            PredicateKind::TypeOutlives(data) => Some(predicate.rebind(data)),\n+            PredicateKind::Trait(..)\n+            | PredicateKind::Projection(..)\n+            | PredicateKind::Subtype(..)\n+            | PredicateKind::RegionOutlives(..)\n+            | PredicateKind::WellFormed(..)\n+            | PredicateKind::ObjectSafe(..)\n+            | PredicateKind::ClosureKind(..)\n+            | PredicateKind::ConstEvaluatable(..)\n+            | PredicateKind::ConstEquate(..)\n+            | PredicateKind::TypeWellFormedFromEnv(..) => None,\n         }\n     }\n }"}, {"sha": "8911de41c6d8ebec3ae67669ee5b49f3aac3f1e9", "filename": "compiler/rustc_middle/src/ty/print/pretty.rs", "status": "modified", "additions": 16, "deletions": 22, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fprint%2Fpretty.rs?ref=4253153db205251f72ea4493687a31e04a2a8ca0", "patch": "@@ -623,12 +623,8 @@ pub trait PrettyPrinter<'tcx>:\n                     p!(\"impl\");\n                     for (predicate, _) in bounds {\n                         let predicate = predicate.subst(self.tcx(), substs);\n-                        // Note: We can't use `to_opt_poly_trait_ref` here as `predicate`\n-                        // may contain unbound variables. We therefore do this manually.\n-                        //\n-                        // FIXME(lcnr): Find out why exactly this is the case :)\n-                        let bound_predicate = predicate.bound_atom_with_opt_escaping(self.tcx());\n-                        if let ty::PredicateAtom::Trait(pred, _) = bound_predicate.skip_binder() {\n+                        let bound_predicate = predicate.kind();\n+                        if let ty::PredicateKind::Trait(pred, _) = bound_predicate.skip_binder() {\n                             let trait_ref = bound_predicate.rebind(pred.trait_ref);\n                             // Don't print +Sized, but rather +?Sized if absent.\n                             if Some(trait_ref.def_id()) == self.tcx().lang_items().sized_trait() {\n@@ -2068,40 +2064,38 @@ define_print_and_forward_display! {\n     }\n \n     ty::Predicate<'tcx> {\n-        match self.kind() {\n-            &ty::PredicateKind::Atom(atom) => p!(print(atom)),\n-            ty::PredicateKind::ForAll(binder) => p!(print(binder)),\n-        }\n+        let binder = self.kind();\n+        p!(print(binder))\n     }\n \n-    ty::PredicateAtom<'tcx> {\n+    ty::PredicateKind<'tcx> {\n         match *self {\n-            ty::PredicateAtom::Trait(ref data, constness) => {\n+            ty::PredicateKind::Trait(ref data, constness) => {\n                 if let hir::Constness::Const = constness {\n                     p!(\"const \");\n                 }\n                 p!(print(data))\n             }\n-            ty::PredicateAtom::Subtype(predicate) => p!(print(predicate)),\n-            ty::PredicateAtom::RegionOutlives(predicate) => p!(print(predicate)),\n-            ty::PredicateAtom::TypeOutlives(predicate) => p!(print(predicate)),\n-            ty::PredicateAtom::Projection(predicate) => p!(print(predicate)),\n-            ty::PredicateAtom::WellFormed(arg) => p!(print(arg), \" well-formed\"),\n-            ty::PredicateAtom::ObjectSafe(trait_def_id) => {\n+            ty::PredicateKind::Subtype(predicate) => p!(print(predicate)),\n+            ty::PredicateKind::RegionOutlives(predicate) => p!(print(predicate)),\n+            ty::PredicateKind::TypeOutlives(predicate) => p!(print(predicate)),\n+            ty::PredicateKind::Projection(predicate) => p!(print(predicate)),\n+            ty::PredicateKind::WellFormed(arg) => p!(print(arg), \" well-formed\"),\n+            ty::PredicateKind::ObjectSafe(trait_def_id) => {\n                 p!(\"the trait `\", print_def_path(trait_def_id, &[]), \"` is object-safe\")\n             }\n-            ty::PredicateAtom::ClosureKind(closure_def_id, _closure_substs, kind) => {\n+            ty::PredicateKind::ClosureKind(closure_def_id, _closure_substs, kind) => {\n                 p!(\"the closure `\",\n                 print_value_path(closure_def_id, &[]),\n                 write(\"` implements the trait `{}`\", kind))\n             }\n-            ty::PredicateAtom::ConstEvaluatable(def, substs) => {\n+            ty::PredicateKind::ConstEvaluatable(def, substs) => {\n                 p!(\"the constant `\", print_value_path(def.did, substs), \"` can be evaluated\")\n             }\n-            ty::PredicateAtom::ConstEquate(c1, c2) => {\n+            ty::PredicateKind::ConstEquate(c1, c2) => {\n                 p!(\"the constant `\", print(c1), \"` equals `\", print(c2), \"`\")\n             }\n-            ty::PredicateAtom::TypeWellFormedFromEnv(ty) => {\n+            ty::PredicateKind::TypeWellFormedFromEnv(ty) => {\n                 p!(\"the type `\", print(ty), \"` is found in the environment\")\n             }\n         }"}, {"sha": "cfe47004e01b67fd309d59f6451c6226e10b8691", "filename": "compiler/rustc_middle/src/ty/query/on_disk_cache.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fon_disk_cache.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fon_disk_cache.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fquery%2Fon_disk_cache.rs?ref=4253153db205251f72ea4493687a31e04a2a8ca0", "patch": "@@ -989,7 +989,7 @@ struct CacheEncoder<'a, 'tcx, E: OpaqueEncoder> {\n     tcx: TyCtxt<'tcx>,\n     encoder: &'a mut E,\n     type_shorthands: FxHashMap<Ty<'tcx>, usize>,\n-    predicate_shorthands: FxHashMap<ty::Predicate<'tcx>, usize>,\n+    predicate_shorthands: FxHashMap<ty::PredicateKind<'tcx>, usize>,\n     interpret_allocs: FxIndexSet<interpret::AllocId>,\n     source_map: CachingSourceMapView<'tcx>,\n     file_to_file_index: FxHashMap<*const SourceFile, SourceFileIndex>,\n@@ -1103,7 +1103,7 @@ where\n     fn type_shorthands(&mut self) -> &mut FxHashMap<Ty<'tcx>, usize> {\n         &mut self.type_shorthands\n     }\n-    fn predicate_shorthands(&mut self) -> &mut FxHashMap<ty::Predicate<'tcx>, usize> {\n+    fn predicate_shorthands(&mut self) -> &mut FxHashMap<ty::PredicateKind<'tcx>, usize> {\n         &mut self.predicate_shorthands\n     }\n     fn encode_alloc_id(&mut self, alloc_id: &interpret::AllocId) -> Result<(), Self::Error> {"}, {"sha": "44c173e356dfb8fbca34ef3063461d7a6ca1e7ae", "filename": "compiler/rustc_middle/src/ty/structural_impls.rs", "status": "modified", "additions": 33, "deletions": 52, "changes": 85, "blob_url": "https://github.com/rust-lang/rust/blob/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fstructural_impls.rs?ref=4253153db205251f72ea4493687a31e04a2a8ca0", "patch": "@@ -231,37 +231,28 @@ impl fmt::Debug for ty::Predicate<'tcx> {\n impl fmt::Debug for ty::PredicateKind<'tcx> {\n     fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n         match *self {\n-            ty::PredicateKind::ForAll(binder) => write!(f, \"ForAll({:?})\", binder),\n-            ty::PredicateKind::Atom(atom) => write!(f, \"{:?}\", atom),\n-        }\n-    }\n-}\n-\n-impl fmt::Debug for ty::PredicateAtom<'tcx> {\n-    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {\n-        match *self {\n-            ty::PredicateAtom::Trait(ref a, constness) => {\n+            ty::PredicateKind::Trait(ref a, constness) => {\n                 if let hir::Constness::Const = constness {\n                     write!(f, \"const \")?;\n                 }\n                 a.fmt(f)\n             }\n-            ty::PredicateAtom::Subtype(ref pair) => pair.fmt(f),\n-            ty::PredicateAtom::RegionOutlives(ref pair) => pair.fmt(f),\n-            ty::PredicateAtom::TypeOutlives(ref pair) => pair.fmt(f),\n-            ty::PredicateAtom::Projection(ref pair) => pair.fmt(f),\n-            ty::PredicateAtom::WellFormed(data) => write!(f, \"WellFormed({:?})\", data),\n-            ty::PredicateAtom::ObjectSafe(trait_def_id) => {\n+            ty::PredicateKind::Subtype(ref pair) => pair.fmt(f),\n+            ty::PredicateKind::RegionOutlives(ref pair) => pair.fmt(f),\n+            ty::PredicateKind::TypeOutlives(ref pair) => pair.fmt(f),\n+            ty::PredicateKind::Projection(ref pair) => pair.fmt(f),\n+            ty::PredicateKind::WellFormed(data) => write!(f, \"WellFormed({:?})\", data),\n+            ty::PredicateKind::ObjectSafe(trait_def_id) => {\n                 write!(f, \"ObjectSafe({:?})\", trait_def_id)\n             }\n-            ty::PredicateAtom::ClosureKind(closure_def_id, closure_substs, kind) => {\n+            ty::PredicateKind::ClosureKind(closure_def_id, closure_substs, kind) => {\n                 write!(f, \"ClosureKind({:?}, {:?}, {:?})\", closure_def_id, closure_substs, kind)\n             }\n-            ty::PredicateAtom::ConstEvaluatable(def_id, substs) => {\n+            ty::PredicateKind::ConstEvaluatable(def_id, substs) => {\n                 write!(f, \"ConstEvaluatable({:?}, {:?})\", def_id, substs)\n             }\n-            ty::PredicateAtom::ConstEquate(c1, c2) => write!(f, \"ConstEquate({:?}, {:?})\", c1, c2),\n-            ty::PredicateAtom::TypeWellFormedFromEnv(ty) => {\n+            ty::PredicateKind::ConstEquate(c1, c2) => write!(f, \"ConstEquate({:?}, {:?})\", c1, c2),\n+            ty::PredicateKind::TypeWellFormedFromEnv(ty) => {\n                 write!(f, \"TypeWellFormedFromEnv({:?})\", ty)\n             }\n         }\n@@ -485,46 +476,36 @@ impl<'a, 'tcx> Lift<'tcx> for ty::PredicateKind<'a> {\n     type Lifted = ty::PredicateKind<'tcx>;\n     fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n         match self {\n-            ty::PredicateKind::ForAll(binder) => tcx.lift(binder).map(ty::PredicateKind::ForAll),\n-            ty::PredicateKind::Atom(atom) => tcx.lift(atom).map(ty::PredicateKind::Atom),\n-        }\n-    }\n-}\n-\n-impl<'a, 'tcx> Lift<'tcx> for ty::PredicateAtom<'a> {\n-    type Lifted = ty::PredicateAtom<'tcx>;\n-    fn lift_to_tcx(self, tcx: TyCtxt<'tcx>) -> Option<Self::Lifted> {\n-        match self {\n-            ty::PredicateAtom::Trait(data, constness) => {\n-                tcx.lift(data).map(|data| ty::PredicateAtom::Trait(data, constness))\n+            ty::PredicateKind::Trait(data, constness) => {\n+                tcx.lift(data).map(|data| ty::PredicateKind::Trait(data, constness))\n             }\n-            ty::PredicateAtom::Subtype(data) => tcx.lift(data).map(ty::PredicateAtom::Subtype),\n-            ty::PredicateAtom::RegionOutlives(data) => {\n-                tcx.lift(data).map(ty::PredicateAtom::RegionOutlives)\n+            ty::PredicateKind::Subtype(data) => tcx.lift(data).map(ty::PredicateKind::Subtype),\n+            ty::PredicateKind::RegionOutlives(data) => {\n+                tcx.lift(data).map(ty::PredicateKind::RegionOutlives)\n             }\n-            ty::PredicateAtom::TypeOutlives(data) => {\n-                tcx.lift(data).map(ty::PredicateAtom::TypeOutlives)\n+            ty::PredicateKind::TypeOutlives(data) => {\n+                tcx.lift(data).map(ty::PredicateKind::TypeOutlives)\n             }\n-            ty::PredicateAtom::Projection(data) => {\n-                tcx.lift(data).map(ty::PredicateAtom::Projection)\n+            ty::PredicateKind::Projection(data) => {\n+                tcx.lift(data).map(ty::PredicateKind::Projection)\n             }\n-            ty::PredicateAtom::WellFormed(ty) => tcx.lift(ty).map(ty::PredicateAtom::WellFormed),\n-            ty::PredicateAtom::ClosureKind(closure_def_id, closure_substs, kind) => {\n+            ty::PredicateKind::WellFormed(ty) => tcx.lift(ty).map(ty::PredicateKind::WellFormed),\n+            ty::PredicateKind::ClosureKind(closure_def_id, closure_substs, kind) => {\n                 tcx.lift(closure_substs).map(|closure_substs| {\n-                    ty::PredicateAtom::ClosureKind(closure_def_id, closure_substs, kind)\n+                    ty::PredicateKind::ClosureKind(closure_def_id, closure_substs, kind)\n                 })\n             }\n-            ty::PredicateAtom::ObjectSafe(trait_def_id) => {\n-                Some(ty::PredicateAtom::ObjectSafe(trait_def_id))\n+            ty::PredicateKind::ObjectSafe(trait_def_id) => {\n+                Some(ty::PredicateKind::ObjectSafe(trait_def_id))\n             }\n-            ty::PredicateAtom::ConstEvaluatable(def_id, substs) => {\n-                tcx.lift(substs).map(|substs| ty::PredicateAtom::ConstEvaluatable(def_id, substs))\n+            ty::PredicateKind::ConstEvaluatable(def_id, substs) => {\n+                tcx.lift(substs).map(|substs| ty::PredicateKind::ConstEvaluatable(def_id, substs))\n             }\n-            ty::PredicateAtom::ConstEquate(c1, c2) => {\n-                tcx.lift((c1, c2)).map(|(c1, c2)| ty::PredicateAtom::ConstEquate(c1, c2))\n+            ty::PredicateKind::ConstEquate(c1, c2) => {\n+                tcx.lift((c1, c2)).map(|(c1, c2)| ty::PredicateKind::ConstEquate(c1, c2))\n             }\n-            ty::PredicateAtom::TypeWellFormedFromEnv(ty) => {\n-                tcx.lift(ty).map(ty::PredicateAtom::TypeWellFormedFromEnv)\n+            ty::PredicateKind::TypeWellFormedFromEnv(ty) => {\n+                tcx.lift(ty).map(ty::PredicateKind::TypeWellFormedFromEnv)\n             }\n         }\n     }\n@@ -1036,12 +1017,12 @@ impl<'tcx> TypeFoldable<'tcx> for ty::Region<'tcx> {\n \n impl<'tcx> TypeFoldable<'tcx> for ty::Predicate<'tcx> {\n     fn super_fold_with<F: TypeFolder<'tcx>>(self, folder: &mut F) -> Self {\n-        let new = ty::PredicateKind::super_fold_with(self.inner.kind, folder);\n+        let new = self.inner.kind.fold_with(folder);\n         folder.tcx().reuse_or_mk_predicate(self, new)\n     }\n \n     fn super_visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {\n-        ty::PredicateKind::super_visit_with(&self.inner.kind, visitor)\n+        self.inner.kind.visit_with(visitor)\n     }\n \n     fn visit_with<V: TypeVisitor<'tcx>>(&self, visitor: &mut V) -> ControlFlow<V::BreakTy> {"}, {"sha": "e53977b5eb9787a72ff3ea828ab716a2c743dc93", "filename": "compiler/rustc_middle/src/ty/sty.rs", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_middle%2Fsrc%2Fty%2Fsty.rs?ref=4253153db205251f72ea4493687a31e04a2a8ca0", "patch": "@@ -955,7 +955,9 @@ impl<'tcx> PolyExistentialTraitRef<'tcx> {\n /// erase, or otherwise \"discharge\" these bound vars, we change the\n /// type from `Binder<T>` to just `T` (see\n /// e.g., `liberate_late_bound_regions`).\n-#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug, TyEncodable, TyDecodable)]\n+///\n+/// `Decodable` and `Encodable` are implemented for `Binder<T>` using the `impl_binder_encode_decode!` macro.\n+#[derive(Copy, Clone, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]\n pub struct Binder<T>(T);\n \n impl<T> Binder<T> {"}, {"sha": "ab83fc8dfaf753a00787692efab2175c7f02f03e", "filename": "compiler/rustc_mir/src/borrow_check/diagnostics/region_errors.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Fdiagnostics%2Fregion_errors.rs?ref=4253153db205251f72ea4493687a31e04a2a8ca0", "patch": "@@ -590,8 +590,8 @@ impl<'a, 'tcx> MirBorrowckCtxt<'a, 'tcx> {\n \n                     let mut found = false;\n                     for (bound, _) in bounds {\n-                        if let ty::PredicateAtom::TypeOutlives(ty::OutlivesPredicate(_, r)) =\n-                            bound.skip_binders()\n+                        if let ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(_, r)) =\n+                            bound.kind().skip_binder()\n                         {\n                             let r = r.subst(self.infcx.tcx, substs);\n                             if let ty::RegionKind::ReStatic = r {"}, {"sha": "fb9820e853f8f38b463e28df6b2ba1d6cd2c18e2", "filename": "compiler/rustc_mir/src/borrow_check/type_check/mod.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Fborrow_check%2Ftype_check%2Fmod.rs?ref=4253153db205251f72ea4493687a31e04a2a8ca0", "patch": "@@ -1014,7 +1014,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     }\n \n                     self.prove_predicate(\n-                        ty::PredicateAtom::WellFormed(inferred_ty.into()).to_predicate(self.tcx()),\n+                        ty::PredicateKind::WellFormed(inferred_ty.into()).to_predicate(self.tcx()),\n                         Locations::All(span),\n                         ConstraintCategory::TypeAnnotation,\n                     );\n@@ -1266,7 +1266,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                     obligations.obligations.push(traits::Obligation::new(\n                         ObligationCause::dummy(),\n                         param_env,\n-                        ty::PredicateAtom::WellFormed(revealed_ty.into()).to_predicate(infcx.tcx),\n+                        ty::PredicateKind::WellFormed(revealed_ty.into()).to_predicate(infcx.tcx),\n                     ));\n                     obligations.add(\n                         infcx\n@@ -1611,7 +1611,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n                 self.check_call_dest(body, term, &sig, destination, term_location);\n \n                 self.prove_predicates(\n-                    sig.inputs_and_output.iter().map(|ty| ty::PredicateAtom::WellFormed(ty.into())),\n+                    sig.inputs_and_output.iter().map(|ty| ty::PredicateKind::WellFormed(ty.into())),\n                     term_location.to_locations(),\n                     ConstraintCategory::Boring,\n                 );\n@@ -2694,7 +2694,7 @@ impl<'a, 'tcx> TypeChecker<'a, 'tcx> {\n         category: ConstraintCategory,\n     ) {\n         self.prove_predicates(\n-            Some(ty::PredicateAtom::Trait(\n+            Some(ty::PredicateKind::Trait(\n                 ty::TraitPredicate { trait_ref },\n                 hir::Constness::NotConst,\n             )),"}, {"sha": "88b2378cd06e71b49c70ba98d324c8d6a9513dd4", "filename": "compiler/rustc_mir/src/transform/check_consts/validation.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fvalidation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Fcheck_consts%2Fvalidation.rs?ref=4253153db205251f72ea4493687a31e04a2a8ca0", "patch": "@@ -411,24 +411,24 @@ impl Validator<'mir, 'tcx> {\n         loop {\n             let predicates = tcx.predicates_of(current);\n             for (predicate, _) in predicates.predicates {\n-                match predicate.skip_binders() {\n-                    ty::PredicateAtom::RegionOutlives(_)\n-                    | ty::PredicateAtom::TypeOutlives(_)\n-                    | ty::PredicateAtom::WellFormed(_)\n-                    | ty::PredicateAtom::Projection(_)\n-                    | ty::PredicateAtom::ConstEvaluatable(..)\n-                    | ty::PredicateAtom::ConstEquate(..)\n-                    | ty::PredicateAtom::TypeWellFormedFromEnv(..) => continue,\n-                    ty::PredicateAtom::ObjectSafe(_) => {\n+                match predicate.kind().skip_binder() {\n+                    ty::PredicateKind::RegionOutlives(_)\n+                    | ty::PredicateKind::TypeOutlives(_)\n+                    | ty::PredicateKind::WellFormed(_)\n+                    | ty::PredicateKind::Projection(_)\n+                    | ty::PredicateKind::ConstEvaluatable(..)\n+                    | ty::PredicateKind::ConstEquate(..)\n+                    | ty::PredicateKind::TypeWellFormedFromEnv(..) => continue,\n+                    ty::PredicateKind::ObjectSafe(_) => {\n                         bug!(\"object safe predicate on function: {:#?}\", predicate)\n                     }\n-                    ty::PredicateAtom::ClosureKind(..) => {\n+                    ty::PredicateKind::ClosureKind(..) => {\n                         bug!(\"closure kind predicate on function: {:#?}\", predicate)\n                     }\n-                    ty::PredicateAtom::Subtype(_) => {\n+                    ty::PredicateKind::Subtype(_) => {\n                         bug!(\"subtype predicate on function: {:#?}\", predicate)\n                     }\n-                    ty::PredicateAtom::Trait(pred, constness) => {\n+                    ty::PredicateKind::Trait(pred, constness) => {\n                         if Some(pred.def_id()) == tcx.lang_items().sized_trait() {\n                             continue;\n                         }"}, {"sha": "8d02ac6d9b774eb2633966e4f0ba4160ffe2d685", "filename": "compiler/rustc_mir/src/transform/function_item_references.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Ffunction_item_references.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Ffunction_item_references.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_mir%2Fsrc%2Ftransform%2Ffunction_item_references.rs?ref=4253153db205251f72ea4493687a31e04a2a8ca0", "patch": "@@ -5,7 +5,7 @@ use rustc_middle::mir::*;\n use rustc_middle::ty::{\n     self,\n     subst::{GenericArgKind, Subst, SubstsRef},\n-    PredicateAtom, Ty, TyCtxt, TyS,\n+    PredicateKind, Ty, TyCtxt, TyS,\n };\n use rustc_session::lint::builtin::FUNCTION_ITEM_REFERENCES;\n use rustc_span::{symbol::sym, Span};\n@@ -105,7 +105,7 @@ impl<'a, 'tcx> FunctionItemRefChecker<'a, 'tcx> {\n         let param_env = self.tcx.param_env(def_id);\n         let bounds = param_env.caller_bounds();\n         for bound in bounds {\n-            if let Some(bound_ty) = self.is_pointer_trait(&bound.skip_binders()) {\n+            if let Some(bound_ty) = self.is_pointer_trait(&bound.kind().skip_binder()) {\n                 // Get the argument types as they appear in the function signature.\n                 let arg_defs = self.tcx.fn_sig(def_id).skip_binder().inputs();\n                 for (arg_num, arg_def) in arg_defs.iter().enumerate() {\n@@ -131,8 +131,8 @@ impl<'a, 'tcx> FunctionItemRefChecker<'a, 'tcx> {\n     }\n \n     /// If the given predicate is the trait `fmt::Pointer`, returns the bound parameter type.\n-    fn is_pointer_trait(&self, bound: &PredicateAtom<'tcx>) -> Option<Ty<'tcx>> {\n-        if let ty::PredicateAtom::Trait(predicate, _) = bound {\n+    fn is_pointer_trait(&self, bound: &PredicateKind<'tcx>) -> Option<Ty<'tcx>> {\n+        if let ty::PredicateKind::Trait(predicate, _) = bound {\n             if self.tcx.is_diagnostic_item(sym::pointer_trait, predicate.def_id()) {\n                 Some(predicate.trait_ref.self_ty())\n             } else {"}, {"sha": "66206ca46c3a7463a2835d37a9877fbb5506e755", "filename": "compiler/rustc_privacy/src/lib.rs", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_privacy%2Fsrc%2Flib.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_privacy%2Fsrc%2Flib.rs?ref=4253153db205251f72ea4493687a31e04a2a8ca0", "patch": "@@ -100,19 +100,19 @@ where\n     }\n \n     fn visit_predicate(&mut self, predicate: ty::Predicate<'tcx>) -> ControlFlow<V::BreakTy> {\n-        match predicate.skip_binders() {\n-            ty::PredicateAtom::Trait(ty::TraitPredicate { trait_ref }, _) => {\n+        match predicate.kind().skip_binder() {\n+            ty::PredicateKind::Trait(ty::TraitPredicate { trait_ref }, _) => {\n                 self.visit_trait(trait_ref)\n             }\n-            ty::PredicateAtom::Projection(ty::ProjectionPredicate { projection_ty, ty }) => {\n+            ty::PredicateKind::Projection(ty::ProjectionPredicate { projection_ty, ty }) => {\n                 ty.visit_with(self)?;\n                 self.visit_trait(projection_ty.trait_ref(self.def_id_visitor.tcx()))\n             }\n-            ty::PredicateAtom::TypeOutlives(ty::OutlivesPredicate(ty, _region)) => {\n+            ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(ty, _region)) => {\n                 ty.visit_with(self)\n             }\n-            ty::PredicateAtom::RegionOutlives(..) => ControlFlow::CONTINUE,\n-            ty::PredicateAtom::ConstEvaluatable(..)\n+            ty::PredicateKind::RegionOutlives(..) => ControlFlow::CONTINUE,\n+            ty::PredicateKind::ConstEvaluatable(..)\n                 if self.def_id_visitor.tcx().features().const_evaluatable_checked =>\n             {\n                 // FIXME(const_evaluatable_checked): If the constant used here depends on a"}, {"sha": "25ba489032bf1f825e453f5fca3f8d876e61d657", "filename": "compiler/rustc_trait_selection/src/opaque_types.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Fopaque_types.rs?ref=4253153db205251f72ea4493687a31e04a2a8ca0", "patch": "@@ -1153,7 +1153,7 @@ impl<'a, 'tcx> Instantiator<'a, 'tcx> {\n         debug!(\"instantiate_opaque_types: ty_var={:?}\", ty_var);\n \n         for predicate in &bounds {\n-            if let ty::PredicateAtom::Projection(projection) = predicate.skip_binders() {\n+            if let ty::PredicateKind::Projection(projection) = predicate.kind().skip_binder() {\n                 if projection.ty.references_error() {\n                     // No point on adding these obligations since there's a type error involved.\n                     return ty_var;\n@@ -1251,18 +1251,18 @@ crate fn required_region_bounds(\n     traits::elaborate_predicates(tcx, predicates)\n         .filter_map(|obligation| {\n             debug!(\"required_region_bounds(obligation={:?})\", obligation);\n-            match obligation.predicate.skip_binders() {\n-                ty::PredicateAtom::Projection(..)\n-                | ty::PredicateAtom::Trait(..)\n-                | ty::PredicateAtom::Subtype(..)\n-                | ty::PredicateAtom::WellFormed(..)\n-                | ty::PredicateAtom::ObjectSafe(..)\n-                | ty::PredicateAtom::ClosureKind(..)\n-                | ty::PredicateAtom::RegionOutlives(..)\n-                | ty::PredicateAtom::ConstEvaluatable(..)\n-                | ty::PredicateAtom::ConstEquate(..)\n-                | ty::PredicateAtom::TypeWellFormedFromEnv(..) => None,\n-                ty::PredicateAtom::TypeOutlives(ty::OutlivesPredicate(ref t, ref r)) => {\n+            match obligation.predicate.kind().skip_binder() {\n+                ty::PredicateKind::Projection(..)\n+                | ty::PredicateKind::Trait(..)\n+                | ty::PredicateKind::Subtype(..)\n+                | ty::PredicateKind::WellFormed(..)\n+                | ty::PredicateKind::ObjectSafe(..)\n+                | ty::PredicateKind::ClosureKind(..)\n+                | ty::PredicateKind::RegionOutlives(..)\n+                | ty::PredicateKind::ConstEvaluatable(..)\n+                | ty::PredicateKind::ConstEquate(..)\n+                | ty::PredicateKind::TypeWellFormedFromEnv(..) => None,\n+                ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(ref t, ref r)) => {\n                     // Search for a bound of the form `erased_self_ty\n                     // : 'a`, but be wary of something like `for<'a>\n                     // erased_self_ty : 'a` (we interpret a"}, {"sha": "6593c1000f28386cf6b36ac782310a52712113c6", "filename": "compiler/rustc_trait_selection/src/traits/auto_trait.rs", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/rust-lang/rust/blob/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fauto_trait.rs?ref=4253153db205251f72ea4493687a31e04a2a8ca0", "patch": "@@ -414,9 +414,9 @@ impl AutoTraitFinder<'tcx> {\n         let mut should_add_new = true;\n         user_computed_preds.retain(|&old_pred| {\n             if let (\n-                ty::PredicateAtom::Trait(new_trait, _),\n-                ty::PredicateAtom::Trait(old_trait, _),\n-            ) = (new_pred.skip_binders(), old_pred.skip_binders())\n+                ty::PredicateKind::Trait(new_trait, _),\n+                ty::PredicateKind::Trait(old_trait, _),\n+            ) = (new_pred.kind().skip_binder(), old_pred.kind().skip_binder())\n             {\n                 if new_trait.def_id() == old_trait.def_id() {\n                     let new_substs = new_trait.trait_ref.substs;\n@@ -633,16 +633,16 @@ impl AutoTraitFinder<'tcx> {\n             // We check this by calling is_of_param on the relevant types\n             // from the various possible predicates\n \n-            let bound_predicate = predicate.bound_atom();\n+            let bound_predicate = predicate.kind();\n             match bound_predicate.skip_binder() {\n-                ty::PredicateAtom::Trait(p, _) => {\n+                ty::PredicateKind::Trait(p, _) => {\n                     // Add this to `predicates` so that we end up calling `select`\n                     // with it. If this predicate ends up being unimplemented,\n                     // then `evaluate_predicates` will handle adding it the `ParamEnv`\n                     // if possible.\n                     predicates.push_back(bound_predicate.rebind(p));\n                 }\n-                ty::PredicateAtom::Projection(p) => {\n+                ty::PredicateKind::Projection(p) => {\n                     let p = bound_predicate.rebind(p);\n                     debug!(\n                         \"evaluate_nested_obligations: examining projection predicate {:?}\",\n@@ -772,13 +772,13 @@ impl AutoTraitFinder<'tcx> {\n                         }\n                     }\n                 }\n-                ty::PredicateAtom::RegionOutlives(binder) => {\n+                ty::PredicateKind::RegionOutlives(binder) => {\n                     let binder = bound_predicate.rebind(binder);\n                     if select.infcx().region_outlives_predicate(&dummy_cause, binder).is_err() {\n                         return false;\n                     }\n                 }\n-                ty::PredicateAtom::TypeOutlives(binder) => {\n+                ty::PredicateKind::TypeOutlives(binder) => {\n                     let binder = bound_predicate.rebind(binder);\n                     match (\n                         binder.no_bound_vars(),\n@@ -801,7 +801,7 @@ impl AutoTraitFinder<'tcx> {\n                         _ => {}\n                     };\n                 }\n-                ty::PredicateAtom::ConstEquate(c1, c2) => {\n+                ty::PredicateKind::ConstEquate(c1, c2) => {\n                     let evaluate = |c: &'tcx ty::Const<'tcx>| {\n                         if let ty::ConstKind::Unevaluated(def, substs, promoted) = c.val {\n                             match select.infcx().const_eval_resolve("}, {"sha": "ad229e03b0b6b9b97fa9a2b8bb9be374e1338a77", "filename": "compiler/rustc_trait_selection/src/traits/const_evaluatable.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fconst_evaluatable.rs?ref=4253153db205251f72ea4493687a31e04a2a8ca0", "patch": "@@ -41,8 +41,8 @@ pub fn is_const_evaluatable<'cx, 'tcx>(\n             // We are looking at a generic abstract constant.\n             Some(ct) => {\n                 for pred in param_env.caller_bounds() {\n-                    match pred.skip_binders() {\n-                        ty::PredicateAtom::ConstEvaluatable(b_def, b_substs) => {\n+                    match pred.kind().skip_binder() {\n+                        ty::PredicateKind::ConstEvaluatable(b_def, b_substs) => {\n                             debug!(\n                                 \"is_const_evaluatable: caller_bound={:?}, {:?}\",\n                                 b_def, b_substs"}, {"sha": "3eeb5038f3693bb68289d2b461ab8b502dba1d82", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/mod.rs", "status": "modified", "additions": 26, "deletions": 25, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fmod.rs?ref=4253153db205251f72ea4493687a31e04a2a8ca0", "patch": "@@ -256,9 +256,9 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                     return;\n                 }\n \n-                let bound_predicate = obligation.predicate.bound_atom();\n+                let bound_predicate = obligation.predicate.kind();\n                 match bound_predicate.skip_binder() {\n-                    ty::PredicateAtom::Trait(trait_predicate, _) => {\n+                    ty::PredicateKind::Trait(trait_predicate, _) => {\n                         let trait_predicate = bound_predicate.rebind(trait_predicate);\n                         let trait_predicate = self.resolve_vars_if_possible(trait_predicate);\n \n@@ -517,14 +517,14 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         err\n                     }\n \n-                    ty::PredicateAtom::Subtype(predicate) => {\n+                    ty::PredicateKind::Subtype(predicate) => {\n                         // Errors for Subtype predicates show up as\n                         // `FulfillmentErrorCode::CodeSubtypeError`,\n                         // not selection error.\n                         span_bug!(span, \"subtype requirement gave wrong error: `{:?}`\", predicate)\n                     }\n \n-                    ty::PredicateAtom::RegionOutlives(predicate) => {\n+                    ty::PredicateKind::RegionOutlives(predicate) => {\n                         let predicate = bound_predicate.rebind(predicate);\n                         let predicate = self.resolve_vars_if_possible(predicate);\n                         let err = self\n@@ -541,7 +541,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         )\n                     }\n \n-                    ty::PredicateAtom::Projection(..) | ty::PredicateAtom::TypeOutlives(..) => {\n+                    ty::PredicateKind::Projection(..) | ty::PredicateKind::TypeOutlives(..) => {\n                         let predicate = self.resolve_vars_if_possible(obligation.predicate);\n                         struct_span_err!(\n                             self.tcx.sess,\n@@ -552,12 +552,12 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         )\n                     }\n \n-                    ty::PredicateAtom::ObjectSafe(trait_def_id) => {\n+                    ty::PredicateKind::ObjectSafe(trait_def_id) => {\n                         let violations = self.tcx.object_safety_violations(trait_def_id);\n                         report_object_safety_error(self.tcx, span, trait_def_id, violations)\n                     }\n \n-                    ty::PredicateAtom::ClosureKind(closure_def_id, closure_substs, kind) => {\n+                    ty::PredicateKind::ClosureKind(closure_def_id, closure_substs, kind) => {\n                         let found_kind = self.closure_kind(closure_substs).unwrap();\n                         let closure_span =\n                             self.tcx.sess.source_map().guess_head_span(\n@@ -617,7 +617,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         return;\n                     }\n \n-                    ty::PredicateAtom::WellFormed(ty) => {\n+                    ty::PredicateKind::WellFormed(ty) => {\n                         if !self.tcx.sess.opts.debugging_opts.chalk {\n                             // WF predicates cannot themselves make\n                             // errors. They can only block due to\n@@ -635,7 +635,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         }\n                     }\n \n-                    ty::PredicateAtom::ConstEvaluatable(..) => {\n+                    ty::PredicateKind::ConstEvaluatable(..) => {\n                         // Errors for `ConstEvaluatable` predicates show up as\n                         // `SelectionError::ConstEvalFailure`,\n                         // not `Unimplemented`.\n@@ -646,7 +646,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         )\n                     }\n \n-                    ty::PredicateAtom::ConstEquate(..) => {\n+                    ty::PredicateKind::ConstEquate(..) => {\n                         // Errors for `ConstEquate` predicates show up as\n                         // `SelectionError::ConstEvalFailure`,\n                         // not `Unimplemented`.\n@@ -657,7 +657,7 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n                         )\n                     }\n \n-                    ty::PredicateAtom::TypeWellFormedFromEnv(..) => span_bug!(\n+                    ty::PredicateKind::TypeWellFormedFromEnv(..) => span_bug!(\n                         span,\n                         \"TypeWellFormedFromEnv predicate should only exist in the environment\"\n                     ),\n@@ -1069,9 +1069,9 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n         }\n \n         // FIXME: It should be possible to deal with `ForAll` in a cleaner way.\n-        let bound_error = error.bound_atom();\n-        let (cond, error) = match (cond.skip_binders(), bound_error.skip_binder()) {\n-            (ty::PredicateAtom::Trait(..), ty::PredicateAtom::Trait(error, _)) => {\n+        let bound_error = error.kind();\n+        let (cond, error) = match (cond.kind().skip_binder(), bound_error.skip_binder()) {\n+            (ty::PredicateKind::Trait(..), ty::PredicateKind::Trait(error, _)) => {\n                 (cond, bound_error.rebind(error))\n             }\n             _ => {\n@@ -1081,8 +1081,8 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n         };\n \n         for obligation in super::elaborate_predicates(self.tcx, std::iter::once(cond)) {\n-            let bound_predicate = obligation.predicate.bound_atom();\n-            if let ty::PredicateAtom::Trait(implication, _) = bound_predicate.skip_binder() {\n+            let bound_predicate = obligation.predicate.kind();\n+            if let ty::PredicateKind::Trait(implication, _) = bound_predicate.skip_binder() {\n                 let error = error.to_poly_trait_ref();\n                 let implication = bound_predicate.rebind(implication.trait_ref);\n                 // FIXME: I'm just not taking associated types at all here.\n@@ -1162,8 +1162,8 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n             //\n             // this can fail if the problem was higher-ranked, in which\n             // cause I have no idea for a good error message.\n-            let bound_predicate = predicate.bound_atom();\n-            if let ty::PredicateAtom::Projection(data) = bound_predicate.skip_binder() {\n+            let bound_predicate = predicate.kind();\n+            if let ty::PredicateKind::Projection(data) = bound_predicate.skip_binder() {\n                 let mut selcx = SelectionContext::new(self);\n                 let (data, _) = self.replace_bound_vars_with_fresh_vars(\n                     obligation.cause.span,\n@@ -1452,9 +1452,9 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n             return;\n         }\n \n-        let bound_predicate = predicate.bound_atom();\n+        let bound_predicate = predicate.kind();\n         let mut err = match bound_predicate.skip_binder() {\n-            ty::PredicateAtom::Trait(data, _) => {\n+            ty::PredicateKind::Trait(data, _) => {\n                 let trait_ref = bound_predicate.rebind(data.trait_ref);\n                 debug!(\"trait_ref {:?}\", trait_ref);\n \n@@ -1559,7 +1559,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 err\n             }\n \n-            ty::PredicateAtom::WellFormed(arg) => {\n+            ty::PredicateKind::WellFormed(arg) => {\n                 // Same hacky approach as above to avoid deluging user\n                 // with error messages.\n                 if arg.references_error() || self.tcx.sess.has_errors() {\n@@ -1569,7 +1569,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 self.emit_inference_failure_err(body_id, span, arg, ErrorCode::E0282)\n             }\n \n-            ty::PredicateAtom::Subtype(data) => {\n+            ty::PredicateKind::Subtype(data) => {\n                 if data.references_error() || self.tcx.sess.has_errors() {\n                     // no need to overload user in such cases\n                     return;\n@@ -1579,7 +1579,7 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n                 assert!(a.is_ty_var() && b.is_ty_var());\n                 self.emit_inference_failure_err(body_id, span, a.into(), ErrorCode::E0282)\n             }\n-            ty::PredicateAtom::Projection(data) => {\n+            ty::PredicateKind::Projection(data) => {\n                 let trait_ref = bound_predicate.rebind(data).to_poly_trait_ref(self.tcx);\n                 let self_ty = trait_ref.skip_binder().self_ty();\n                 let ty = data.ty;\n@@ -1709,9 +1709,10 @@ impl<'a, 'tcx> InferCtxtPrivExt<'tcx> for InferCtxt<'a, 'tcx> {\n         obligation: &PredicateObligation<'tcx>,\n     ) {\n         let (pred, item_def_id, span) =\n-            match (obligation.predicate.skip_binders(), obligation.cause.code.peel_derives()) {\n+            match (obligation.predicate.kind().skip_binder(), obligation.cause.code.peel_derives())\n+            {\n                 (\n-                    ty::PredicateAtom::Trait(pred, _),\n+                    ty::PredicateKind::Trait(pred, _),\n                     &ObligationCauseCode::BindingObligation(item_def_id, span),\n                 ) => (pred, item_def_id, span),\n                 _ => return,"}, {"sha": "1830aaa4471a6a9dbbb0d57d936a05e96e0d95da", "filename": "compiler/rustc_trait_selection/src/traits/error_reporting/suggestions.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ferror_reporting%2Fsuggestions.rs?ref=4253153db205251f72ea4493687a31e04a2a8ca0", "patch": "@@ -1292,8 +1292,8 @@ impl<'a, 'tcx> InferCtxtExt<'tcx> for InferCtxt<'a, 'tcx> {\n         // the type. The last generator (`outer_generator` below) has information about where the\n         // bound was introduced. At least one generator should be present for this diagnostic to be\n         // modified.\n-        let (mut trait_ref, mut target_ty) = match obligation.predicate.skip_binders() {\n-            ty::PredicateAtom::Trait(p, _) => (Some(p.trait_ref), Some(p.self_ty())),\n+        let (mut trait_ref, mut target_ty) = match obligation.predicate.kind().skip_binder() {\n+            ty::PredicateKind::Trait(p, _) => (Some(p.trait_ref), Some(p.self_ty())),\n             _ => (None, None),\n         };\n         let mut generator = None;"}, {"sha": "d4ced20f86319ac5296e9c8308a3aae44d1f3aae", "filename": "compiler/rustc_trait_selection/src/traits/fulfill.rs", "status": "modified", "additions": 26, "deletions": 25, "changes": 51, "blob_url": "https://github.com/rust-lang/rust/blob/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Ffulfill.rs?ref=4253153db205251f72ea4493687a31e04a2a8ca0", "patch": "@@ -345,12 +345,13 @@ impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n \n         let infcx = self.selcx.infcx();\n \n-        match *obligation.predicate.kind() {\n-            ty::PredicateKind::ForAll(binder) => match binder.skip_binder() {\n+        let binder = obligation.predicate.kind();\n+        match binder.no_bound_vars() {\n+            None => match binder.skip_binder() {\n                 // Evaluation will discard candidates using the leak check.\n                 // This means we need to pass it the bound version of our\n                 // predicate.\n-                ty::PredicateAtom::Trait(trait_ref, _constness) => {\n+                ty::PredicateKind::Trait(trait_ref, _constness) => {\n                     let trait_obligation = obligation.with(binder.rebind(trait_ref));\n \n                     self.process_trait_obligation(\n@@ -359,33 +360,33 @@ impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n                         &mut pending_obligation.stalled_on,\n                     )\n                 }\n-                ty::PredicateAtom::Projection(data) => {\n+                ty::PredicateKind::Projection(data) => {\n                     let project_obligation = obligation.with(binder.rebind(data));\n \n                     self.process_projection_obligation(\n                         project_obligation,\n                         &mut pending_obligation.stalled_on,\n                     )\n                 }\n-                ty::PredicateAtom::RegionOutlives(_)\n-                | ty::PredicateAtom::TypeOutlives(_)\n-                | ty::PredicateAtom::WellFormed(_)\n-                | ty::PredicateAtom::ObjectSafe(_)\n-                | ty::PredicateAtom::ClosureKind(..)\n-                | ty::PredicateAtom::Subtype(_)\n-                | ty::PredicateAtom::ConstEvaluatable(..)\n-                | ty::PredicateAtom::ConstEquate(..) => {\n+                ty::PredicateKind::RegionOutlives(_)\n+                | ty::PredicateKind::TypeOutlives(_)\n+                | ty::PredicateKind::WellFormed(_)\n+                | ty::PredicateKind::ObjectSafe(_)\n+                | ty::PredicateKind::ClosureKind(..)\n+                | ty::PredicateKind::Subtype(_)\n+                | ty::PredicateKind::ConstEvaluatable(..)\n+                | ty::PredicateKind::ConstEquate(..) => {\n                     let pred = infcx.replace_bound_vars_with_placeholders(binder);\n                     ProcessResult::Changed(mk_pending(vec![\n                         obligation.with(pred.to_predicate(self.selcx.tcx())),\n                     ]))\n                 }\n-                ty::PredicateAtom::TypeWellFormedFromEnv(..) => {\n+                ty::PredicateKind::TypeWellFormedFromEnv(..) => {\n                     bug!(\"TypeWellFormedFromEnv is only used for Chalk\")\n                 }\n             },\n-            ty::PredicateKind::Atom(atom) => match atom {\n-                ty::PredicateAtom::Trait(data, _) => {\n+            Some(pred) => match pred {\n+                ty::PredicateKind::Trait(data, _) => {\n                     let trait_obligation = obligation.with(Binder::dummy(data));\n \n                     self.process_trait_obligation(\n@@ -395,14 +396,14 @@ impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n                     )\n                 }\n \n-                ty::PredicateAtom::RegionOutlives(data) => {\n+                ty::PredicateKind::RegionOutlives(data) => {\n                     match infcx.region_outlives_predicate(&obligation.cause, Binder::dummy(data)) {\n                         Ok(()) => ProcessResult::Changed(vec![]),\n                         Err(_) => ProcessResult::Error(CodeSelectionError(Unimplemented)),\n                     }\n                 }\n \n-                ty::PredicateAtom::TypeOutlives(ty::OutlivesPredicate(t_a, r_b)) => {\n+                ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(t_a, r_b)) => {\n                     if self.register_region_obligations {\n                         self.selcx.infcx().register_region_obligation_with_cause(\n                             t_a,\n@@ -413,7 +414,7 @@ impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n                     ProcessResult::Changed(vec![])\n                 }\n \n-                ty::PredicateAtom::Projection(ref data) => {\n+                ty::PredicateKind::Projection(ref data) => {\n                     let project_obligation = obligation.with(Binder::dummy(*data));\n \n                     self.process_projection_obligation(\n@@ -422,15 +423,15 @@ impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n                     )\n                 }\n \n-                ty::PredicateAtom::ObjectSafe(trait_def_id) => {\n+                ty::PredicateKind::ObjectSafe(trait_def_id) => {\n                     if !self.selcx.tcx().is_object_safe(trait_def_id) {\n                         ProcessResult::Error(CodeSelectionError(Unimplemented))\n                     } else {\n                         ProcessResult::Changed(vec![])\n                     }\n                 }\n \n-                ty::PredicateAtom::ClosureKind(_, closure_substs, kind) => {\n+                ty::PredicateKind::ClosureKind(_, closure_substs, kind) => {\n                     match self.selcx.infcx().closure_kind(closure_substs) {\n                         Some(closure_kind) => {\n                             if closure_kind.extends(kind) {\n@@ -443,7 +444,7 @@ impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n                     }\n                 }\n \n-                ty::PredicateAtom::WellFormed(arg) => {\n+                ty::PredicateKind::WellFormed(arg) => {\n                     match wf::obligations(\n                         self.selcx.infcx(),\n                         obligation.param_env,\n@@ -461,7 +462,7 @@ impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n                     }\n                 }\n \n-                ty::PredicateAtom::Subtype(subtype) => {\n+                ty::PredicateKind::Subtype(subtype) => {\n                     match self.selcx.infcx().subtype_predicate(\n                         &obligation.cause,\n                         obligation.param_env,\n@@ -487,7 +488,7 @@ impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n                     }\n                 }\n \n-                ty::PredicateAtom::ConstEvaluatable(def_id, substs) => {\n+                ty::PredicateKind::ConstEvaluatable(def_id, substs) => {\n                     match const_evaluatable::is_const_evaluatable(\n                         self.selcx.infcx(),\n                         def_id,\n@@ -507,7 +508,7 @@ impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n                     }\n                 }\n \n-                ty::PredicateAtom::ConstEquate(c1, c2) => {\n+                ty::PredicateKind::ConstEquate(c1, c2) => {\n                     debug!(?c1, ?c2, \"equating consts\");\n                     if self.selcx.tcx().features().const_evaluatable_checked {\n                         // FIXME: we probably should only try to unify abstract constants\n@@ -593,7 +594,7 @@ impl<'a, 'b, 'tcx> FulfillProcessor<'a, 'b, 'tcx> {\n                         }\n                     }\n                 }\n-                ty::PredicateAtom::TypeWellFormedFromEnv(..) => {\n+                ty::PredicateKind::TypeWellFormedFromEnv(..) => {\n                     bug!(\"TypeWellFormedFromEnv is only used for Chalk\")\n                 }\n             },"}, {"sha": "dbc40a2eb9662a624c40051128481a24fc745cda", "filename": "compiler/rustc_trait_selection/src/traits/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fmod.rs?ref=4253153db205251f72ea4493687a31e04a2a8ca0", "patch": "@@ -324,7 +324,7 @@ pub fn normalize_param_env_or_error<'tcx>(\n     // TypeOutlives predicates - these are normally used by regionck.\n     let outlives_predicates: Vec<_> = predicates\n         .drain_filter(|predicate| {\n-            matches!(predicate.skip_binders(), ty::PredicateAtom::TypeOutlives(..))\n+            matches!(predicate.kind().skip_binder(), ty::PredicateKind::TypeOutlives(..))\n         })\n         .collect();\n "}, {"sha": "a9723611f8113beba4aa1313b8fb700f6a8ec4e5", "filename": "compiler/rustc_trait_selection/src/traits/object_safety.rs", "status": "modified", "additions": 25, "deletions": 25, "changes": 50, "blob_url": "https://github.com/rust-lang/rust/blob/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fobject_safety.rs?ref=4253153db205251f72ea4493687a31e04a2a8ca0", "patch": "@@ -273,12 +273,12 @@ fn predicate_references_self(\n ) -> Option<Span> {\n     let self_ty = tcx.types.self_param;\n     let has_self_ty = |arg: &GenericArg<'_>| arg.walk().any(|arg| arg == self_ty.into());\n-    match predicate.skip_binders() {\n-        ty::PredicateAtom::Trait(ref data, _) => {\n+    match predicate.kind().skip_binder() {\n+        ty::PredicateKind::Trait(ref data, _) => {\n             // In the case of a trait predicate, we can skip the \"self\" type.\n             if data.trait_ref.substs[1..].iter().any(has_self_ty) { Some(sp) } else { None }\n         }\n-        ty::PredicateAtom::Projection(ref data) => {\n+        ty::PredicateKind::Projection(ref data) => {\n             // And similarly for projections. This should be redundant with\n             // the previous check because any projection should have a\n             // matching `Trait` predicate with the same inputs, but we do\n@@ -300,15 +300,15 @@ fn predicate_references_self(\n                 None\n             }\n         }\n-        ty::PredicateAtom::WellFormed(..)\n-        | ty::PredicateAtom::ObjectSafe(..)\n-        | ty::PredicateAtom::TypeOutlives(..)\n-        | ty::PredicateAtom::RegionOutlives(..)\n-        | ty::PredicateAtom::ClosureKind(..)\n-        | ty::PredicateAtom::Subtype(..)\n-        | ty::PredicateAtom::ConstEvaluatable(..)\n-        | ty::PredicateAtom::ConstEquate(..)\n-        | ty::PredicateAtom::TypeWellFormedFromEnv(..) => None,\n+        ty::PredicateKind::WellFormed(..)\n+        | ty::PredicateKind::ObjectSafe(..)\n+        | ty::PredicateKind::TypeOutlives(..)\n+        | ty::PredicateKind::RegionOutlives(..)\n+        | ty::PredicateKind::ClosureKind(..)\n+        | ty::PredicateKind::Subtype(..)\n+        | ty::PredicateKind::ConstEvaluatable(..)\n+        | ty::PredicateKind::ConstEquate(..)\n+        | ty::PredicateKind::TypeWellFormedFromEnv(..) => None,\n     }\n }\n \n@@ -328,20 +328,20 @@ fn generics_require_sized_self(tcx: TyCtxt<'_>, def_id: DefId) -> bool {\n     let predicates = tcx.predicates_of(def_id);\n     let predicates = predicates.instantiate_identity(tcx).predicates;\n     elaborate_predicates(tcx, predicates.into_iter()).any(|obligation| {\n-        match obligation.predicate.skip_binders() {\n-            ty::PredicateAtom::Trait(ref trait_pred, _) => {\n+        match obligation.predicate.kind().skip_binder() {\n+            ty::PredicateKind::Trait(ref trait_pred, _) => {\n                 trait_pred.def_id() == sized_def_id && trait_pred.self_ty().is_param(0)\n             }\n-            ty::PredicateAtom::Projection(..)\n-            | ty::PredicateAtom::Subtype(..)\n-            | ty::PredicateAtom::RegionOutlives(..)\n-            | ty::PredicateAtom::WellFormed(..)\n-            | ty::PredicateAtom::ObjectSafe(..)\n-            | ty::PredicateAtom::ClosureKind(..)\n-            | ty::PredicateAtom::TypeOutlives(..)\n-            | ty::PredicateAtom::ConstEvaluatable(..)\n-            | ty::PredicateAtom::ConstEquate(..)\n-            | ty::PredicateAtom::TypeWellFormedFromEnv(..) => false,\n+            ty::PredicateKind::Projection(..)\n+            | ty::PredicateKind::Subtype(..)\n+            | ty::PredicateKind::RegionOutlives(..)\n+            | ty::PredicateKind::WellFormed(..)\n+            | ty::PredicateKind::ObjectSafe(..)\n+            | ty::PredicateKind::ClosureKind(..)\n+            | ty::PredicateKind::TypeOutlives(..)\n+            | ty::PredicateKind::ConstEvaluatable(..)\n+            | ty::PredicateKind::ConstEquate(..)\n+            | ty::PredicateKind::TypeWellFormedFromEnv(..) => false,\n         }\n     })\n }\n@@ -843,7 +843,7 @@ fn contains_illegal_self_type_reference<'tcx, T: TypeFoldable<'tcx>>(\n         }\n \n         fn visit_predicate(&mut self, pred: ty::Predicate<'tcx>) -> ControlFlow<Self::BreakTy> {\n-            if let ty::PredicateAtom::ConstEvaluatable(def, substs) = pred.skip_binders() {\n+            if let ty::PredicateKind::ConstEvaluatable(def, substs) = pred.kind().skip_binder() {\n                 // FIXME(const_evaluatable_checked): We should probably deduplicate the logic for\n                 // `AbstractConst`s here, it might make sense to change `ConstEvaluatable` to\n                 // take a `ty::Const` instead."}, {"sha": "75ff93197126c3be9a3520f66e5122ad0360b773", "filename": "compiler/rustc_trait_selection/src/traits/project.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fproject.rs?ref=4253153db205251f72ea4493687a31e04a2a8ca0", "patch": "@@ -625,7 +625,7 @@ fn prune_cache_value_obligations<'a, 'tcx>(\n         .obligations\n         .iter()\n         .filter(|obligation| {\n-            let bound_predicate = obligation.predicate.bound_atom();\n+            let bound_predicate = obligation.predicate.kind();\n             match bound_predicate.skip_binder() {\n                 // We found a `T: Foo<X = U>` predicate, let's check\n                 // if `U` references any unresolved type\n@@ -636,7 +636,7 @@ fn prune_cache_value_obligations<'a, 'tcx>(\n                 // indirect obligations (e.g., we project to `?0`,\n                 // but we have `T: Foo<X = ?1>` and `?1: Bar<X =\n                 // ?0>`).\n-                ty::PredicateAtom::Projection(data) => {\n+                ty::PredicateKind::Projection(data) => {\n                     infcx.unresolved_type_vars(&bound_predicate.rebind(data.ty)).is_some()\n                 }\n \n@@ -917,8 +917,8 @@ fn assemble_candidates_from_predicates<'cx, 'tcx>(\n     let infcx = selcx.infcx();\n     for predicate in env_predicates {\n         debug!(?predicate);\n-        let bound_predicate = predicate.bound_atom();\n-        if let ty::PredicateAtom::Projection(data) = predicate.skip_binders() {\n+        let bound_predicate = predicate.kind();\n+        if let ty::PredicateKind::Projection(data) = predicate.kind().skip_binder() {\n             let data = bound_predicate.rebind(data);\n             let same_def_id = data.projection_def_id() == obligation.predicate.item_def_id;\n "}, {"sha": "de538c62c5e3988aa017c7051dffaf763378c310", "filename": "compiler/rustc_trait_selection/src/traits/query/type_op/prove_predicate.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fprove_predicate.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fprove_predicate.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fquery%2Ftype_op%2Fprove_predicate.rs?ref=4253153db205251f72ea4493687a31e04a2a8ca0", "patch": "@@ -15,7 +15,7 @@ impl<'tcx> super::QueryTypeOp<'tcx> for ProvePredicate<'tcx> {\n         // `&T`, accounts for about 60% percentage of the predicates\n         // we have to prove. No need to canonicalize and all that for\n         // such cases.\n-        if let ty::PredicateAtom::Trait(trait_ref, _) = key.value.predicate.skip_binders() {\n+        if let ty::PredicateKind::Trait(trait_ref, _) = key.value.predicate.kind().skip_binder() {\n             if let Some(sized_def_id) = tcx.lang_items().sized_trait() {\n                 if trait_ref.def_id() == sized_def_id {\n                     if trait_ref.self_ty().is_trivially_sized(tcx) {"}, {"sha": "3015188fd447ac16a334774a148fcfaa2ef9d3e0", "filename": "compiler/rustc_trait_selection/src/traits/select/confirmation.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fconfirmation.rs?ref=4253153db205251f72ea4493687a31e04a2a8ca0", "patch": "@@ -432,7 +432,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             .predicates\n             .into_iter()\n         {\n-            if let ty::PredicateAtom::Trait(..) = super_trait.skip_binders() {\n+            if let ty::PredicateKind::Trait(..) = super_trait.kind().skip_binder() {\n                 let normalized_super_trait = normalize_with_depth_to(\n                     self,\n                     obligation.param_env,\n@@ -641,7 +641,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             obligations.push(Obligation::new(\n                 obligation.cause.clone(),\n                 obligation.param_env,\n-                ty::PredicateAtom::ClosureKind(closure_def_id, substs, kind)\n+                ty::PredicateKind::ClosureKind(closure_def_id, substs, kind)\n                     .to_predicate(self.tcx()),\n             ));\n         }"}, {"sha": "614a551004ecf50c209c9a2a5a4cefd8a20a5e2e", "filename": "compiler/rustc_trait_selection/src/traits/select/mod.rs", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/rust-lang/rust/blob/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fselect%2Fmod.rs?ref=4253153db205251f72ea4493687a31e04a2a8ca0", "patch": "@@ -454,16 +454,16 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n         }\n \n         let result = ensure_sufficient_stack(|| {\n-            let bound_predicate = obligation.predicate.bound_atom();\n+            let bound_predicate = obligation.predicate.kind();\n             match bound_predicate.skip_binder() {\n-                ty::PredicateAtom::Trait(t, _) => {\n+                ty::PredicateKind::Trait(t, _) => {\n                     let t = bound_predicate.rebind(t);\n                     debug_assert!(!t.has_escaping_bound_vars());\n                     let obligation = obligation.with(t);\n                     self.evaluate_trait_predicate_recursively(previous_stack, obligation)\n                 }\n \n-                ty::PredicateAtom::Subtype(p) => {\n+                ty::PredicateKind::Subtype(p) => {\n                     let p = bound_predicate.rebind(p);\n                     // Does this code ever run?\n                     match self.infcx.subtype_predicate(&obligation.cause, obligation.param_env, p) {\n@@ -479,7 +479,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     }\n                 }\n \n-                ty::PredicateAtom::WellFormed(arg) => match wf::obligations(\n+                ty::PredicateKind::WellFormed(arg) => match wf::obligations(\n                     self.infcx,\n                     obligation.param_env,\n                     obligation.cause.body_id,\n@@ -494,20 +494,20 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     None => Ok(EvaluatedToAmbig),\n                 },\n \n-                ty::PredicateAtom::TypeOutlives(..) | ty::PredicateAtom::RegionOutlives(..) => {\n+                ty::PredicateKind::TypeOutlives(..) | ty::PredicateKind::RegionOutlives(..) => {\n                     // We do not consider region relationships when evaluating trait matches.\n                     Ok(EvaluatedToOkModuloRegions)\n                 }\n \n-                ty::PredicateAtom::ObjectSafe(trait_def_id) => {\n+                ty::PredicateKind::ObjectSafe(trait_def_id) => {\n                     if self.tcx().is_object_safe(trait_def_id) {\n                         Ok(EvaluatedToOk)\n                     } else {\n                         Ok(EvaluatedToErr)\n                     }\n                 }\n \n-                ty::PredicateAtom::Projection(data) => {\n+                ty::PredicateKind::Projection(data) => {\n                     let data = bound_predicate.rebind(data);\n                     let project_obligation = obligation.with(data);\n                     match project::poly_project_and_unify_type(self, &project_obligation) {\n@@ -528,7 +528,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     }\n                 }\n \n-                ty::PredicateAtom::ClosureKind(_, closure_substs, kind) => {\n+                ty::PredicateKind::ClosureKind(_, closure_substs, kind) => {\n                     match self.infcx.closure_kind(closure_substs) {\n                         Some(closure_kind) => {\n                             if closure_kind.extends(kind) {\n@@ -541,7 +541,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     }\n                 }\n \n-                ty::PredicateAtom::ConstEvaluatable(def_id, substs) => {\n+                ty::PredicateKind::ConstEvaluatable(def_id, substs) => {\n                     match const_evaluatable::is_const_evaluatable(\n                         self.infcx,\n                         def_id,\n@@ -555,7 +555,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                     }\n                 }\n \n-                ty::PredicateAtom::ConstEquate(c1, c2) => {\n+                ty::PredicateKind::ConstEquate(c1, c2) => {\n                     debug!(?c1, ?c2, \"evaluate_predicate_recursively: equating consts\");\n \n                     let evaluate = |c: &'tcx ty::Const<'tcx>| {\n@@ -598,7 +598,7 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n                         }\n                     }\n                 }\n-                ty::PredicateAtom::TypeWellFormedFromEnv(..) => {\n+                ty::PredicateKind::TypeWellFormedFromEnv(..) => {\n                     bug!(\"TypeWellFormedFromEnv is only used for chalk\")\n                 }\n             }\n@@ -845,8 +845,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n     }\n \n     fn coinductive_predicate(&self, predicate: ty::Predicate<'tcx>) -> bool {\n-        let result = match predicate.skip_binders() {\n-            ty::PredicateAtom::Trait(ref data, _) => self.tcx().trait_is_auto(data.def_id()),\n+        let result = match predicate.kind().skip_binder() {\n+            ty::PredicateKind::Trait(ref data, _) => self.tcx().trait_is_auto(data.def_id()),\n             _ => false,\n         };\n         debug!(?predicate, ?result, \"coinductive_predicate\");\n@@ -1174,8 +1174,8 @@ impl<'cx, 'tcx> SelectionContext<'cx, 'tcx> {\n             .iter()\n             .enumerate()\n             .filter_map(|(idx, bound)| {\n-                let bound_predicate = bound.bound_atom();\n-                if let ty::PredicateAtom::Trait(pred, _) = bound_predicate.skip_binder() {\n+                let bound_predicate = bound.kind();\n+                if let ty::PredicateKind::Trait(pred, _) = bound_predicate.skip_binder() {\n                     let bound = bound_predicate.rebind(pred.trait_ref);\n                     if self.infcx.probe(|_| {\n                         match self.match_normalize_trait_ref("}, {"sha": "e6ef9b137d89991f56f6b2722e0e36f8c2e5cd28", "filename": "compiler/rustc_trait_selection/src/traits/wf.rs", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/rust-lang/rust/blob/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs?ref=4253153db205251f72ea4493687a31e04a2a8ca0", "patch": "@@ -106,40 +106,40 @@ pub fn predicate_obligations<'a, 'tcx>(\n     };\n \n     // It's ok to skip the binder here because wf code is prepared for it\n-    match predicate.skip_binders() {\n-        ty::PredicateAtom::Trait(t, _) => {\n+    match predicate.kind().skip_binder() {\n+        ty::PredicateKind::Trait(t, _) => {\n             wf.compute_trait_ref(&t.trait_ref, Elaborate::None);\n         }\n-        ty::PredicateAtom::RegionOutlives(..) => {}\n-        ty::PredicateAtom::TypeOutlives(ty::OutlivesPredicate(ty, _reg)) => {\n+        ty::PredicateKind::RegionOutlives(..) => {}\n+        ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(ty, _reg)) => {\n             wf.compute(ty.into());\n         }\n-        ty::PredicateAtom::Projection(t) => {\n+        ty::PredicateKind::Projection(t) => {\n             wf.compute_projection(t.projection_ty);\n             wf.compute(t.ty.into());\n         }\n-        ty::PredicateAtom::WellFormed(arg) => {\n+        ty::PredicateKind::WellFormed(arg) => {\n             wf.compute(arg);\n         }\n-        ty::PredicateAtom::ObjectSafe(_) => {}\n-        ty::PredicateAtom::ClosureKind(..) => {}\n-        ty::PredicateAtom::Subtype(ty::SubtypePredicate { a, b, a_is_expected: _ }) => {\n+        ty::PredicateKind::ObjectSafe(_) => {}\n+        ty::PredicateKind::ClosureKind(..) => {}\n+        ty::PredicateKind::Subtype(ty::SubtypePredicate { a, b, a_is_expected: _ }) => {\n             wf.compute(a.into());\n             wf.compute(b.into());\n         }\n-        ty::PredicateAtom::ConstEvaluatable(def, substs) => {\n+        ty::PredicateKind::ConstEvaluatable(def, substs) => {\n             let obligations = wf.nominal_obligations(def.did, substs);\n             wf.out.extend(obligations);\n \n             for arg in substs.iter() {\n                 wf.compute(arg);\n             }\n         }\n-        ty::PredicateAtom::ConstEquate(c1, c2) => {\n+        ty::PredicateKind::ConstEquate(c1, c2) => {\n             wf.compute(c1.into());\n             wf.compute(c2.into());\n         }\n-        ty::PredicateAtom::TypeWellFormedFromEnv(..) => {\n+        ty::PredicateKind::TypeWellFormedFromEnv(..) => {\n             bug!(\"TypeWellFormedFromEnv is only used for Chalk\")\n         }\n     }\n@@ -209,8 +209,8 @@ fn extend_cause_with_original_assoc_item_obligation<'tcx>(\n         };\n \n     // It is fine to skip the binder as we don't care about regions here.\n-    match pred.skip_binders() {\n-        ty::PredicateAtom::Projection(proj) => {\n+    match pred.kind().skip_binder() {\n+        ty::PredicateKind::Projection(proj) => {\n             // The obligation comes not from the current `impl` nor the `trait` being implemented,\n             // but rather from a \"second order\" obligation, where an associated type has a\n             // projection coming from another associated type. See\n@@ -225,7 +225,7 @@ fn extend_cause_with_original_assoc_item_obligation<'tcx>(\n                 }\n             }\n         }\n-        ty::PredicateAtom::Trait(pred, _) => {\n+        ty::PredicateKind::Trait(pred, _) => {\n             // An associated item obligation born out of the `trait` failed to be met. An example\n             // can be seen in `ui/associated-types/point-at-type-on-obligation-failure-2.rs`.\n             debug!(\"extended_cause_with_original_assoc_item_obligation trait proj {:?}\", pred);\n@@ -343,7 +343,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                         new_cause,\n                         depth,\n                         param_env,\n-                        ty::PredicateAtom::WellFormed(arg).to_predicate(tcx),\n+                        ty::PredicateKind::WellFormed(arg).to_predicate(tcx),\n                     )\n                 }),\n         );\n@@ -393,7 +393,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                         cause.clone(),\n                         depth,\n                         param_env,\n-                        ty::PredicateAtom::WellFormed(arg).to_predicate(tcx),\n+                        ty::PredicateKind::WellFormed(arg).to_predicate(tcx),\n                     )\n                 }),\n         );\n@@ -436,7 +436,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                             let obligations = self.nominal_obligations(def.did, substs);\n                             self.out.extend(obligations);\n \n-                            let predicate = ty::PredicateAtom::ConstEvaluatable(def, substs)\n+                            let predicate = ty::PredicateKind::ConstEvaluatable(def, substs)\n                                 .to_predicate(self.tcx());\n                             let cause = self.cause(traits::MiscObligation);\n                             self.out.push(traits::Obligation::with_depth(\n@@ -460,7 +460,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                                     cause,\n                                     self.recursion_depth,\n                                     self.param_env,\n-                                    ty::PredicateAtom::WellFormed(resolved_constant.into())\n+                                    ty::PredicateKind::WellFormed(resolved_constant.into())\n                                         .to_predicate(self.tcx()),\n                                 ));\n                             }\n@@ -547,7 +547,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                             cause,\n                             depth,\n                             param_env,\n-                            ty::PredicateAtom::TypeOutlives(ty::OutlivesPredicate(rty, r))\n+                            ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(rty, r))\n                                 .to_predicate(self.tcx()),\n                         ));\n                     }\n@@ -637,7 +637,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                                 cause.clone(),\n                                 depth,\n                                 param_env,\n-                                ty::PredicateAtom::ObjectSafe(did).to_predicate(tcx),\n+                                ty::PredicateKind::ObjectSafe(did).to_predicate(tcx),\n                             )\n                         }));\n                     }\n@@ -664,7 +664,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                             cause,\n                             self.recursion_depth,\n                             param_env,\n-                            ty::PredicateAtom::WellFormed(ty.into()).to_predicate(self.tcx()),\n+                            ty::PredicateKind::WellFormed(ty.into()).to_predicate(self.tcx()),\n                         ));\n                     } else {\n                         // Yes, resolved, proceed with the result."}, {"sha": "48d47054a418289dd978c339d99cc142d43153a7", "filename": "compiler/rustc_traits/src/chalk/lowering.rs", "status": "modified", "additions": 54, "deletions": 66, "changes": 120, "blob_url": "https://github.com/rust-lang/rust/blob/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fchalk%2Flowering.rs?ref=4253153db205251f72ea4493687a31e04a2a8ca0", "patch": "@@ -81,39 +81,36 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::InEnvironment<chalk_ir::Goal<RustInterner<'\n         interner: &RustInterner<'tcx>,\n     ) -> chalk_ir::InEnvironment<chalk_ir::Goal<RustInterner<'tcx>>> {\n         let clauses = self.environment.into_iter().map(|predicate| {\n-            let (predicate, binders, _named_regions) = collect_bound_vars(\n-                interner,\n-                interner.tcx,\n-                predicate.bound_atom_with_opt_escaping(interner.tcx),\n-            );\n+            let (predicate, binders, _named_regions) =\n+                collect_bound_vars(interner, interner.tcx, predicate.kind());\n             let consequence = match predicate {\n-                ty::PredicateAtom::TypeWellFormedFromEnv(ty) => {\n+                ty::PredicateKind::TypeWellFormedFromEnv(ty) => {\n                     chalk_ir::DomainGoal::FromEnv(chalk_ir::FromEnv::Ty(ty.lower_into(interner)))\n                 }\n-                ty::PredicateAtom::Trait(predicate, _) => chalk_ir::DomainGoal::FromEnv(\n+                ty::PredicateKind::Trait(predicate, _) => chalk_ir::DomainGoal::FromEnv(\n                     chalk_ir::FromEnv::Trait(predicate.trait_ref.lower_into(interner)),\n                 ),\n-                ty::PredicateAtom::RegionOutlives(predicate) => chalk_ir::DomainGoal::Holds(\n+                ty::PredicateKind::RegionOutlives(predicate) => chalk_ir::DomainGoal::Holds(\n                     chalk_ir::WhereClause::LifetimeOutlives(chalk_ir::LifetimeOutlives {\n                         a: predicate.0.lower_into(interner),\n                         b: predicate.1.lower_into(interner),\n                     }),\n                 ),\n-                ty::PredicateAtom::TypeOutlives(predicate) => chalk_ir::DomainGoal::Holds(\n+                ty::PredicateKind::TypeOutlives(predicate) => chalk_ir::DomainGoal::Holds(\n                     chalk_ir::WhereClause::TypeOutlives(chalk_ir::TypeOutlives {\n                         ty: predicate.0.lower_into(interner),\n                         lifetime: predicate.1.lower_into(interner),\n                     }),\n                 ),\n-                ty::PredicateAtom::Projection(predicate) => chalk_ir::DomainGoal::Holds(\n+                ty::PredicateKind::Projection(predicate) => chalk_ir::DomainGoal::Holds(\n                     chalk_ir::WhereClause::AliasEq(predicate.lower_into(interner)),\n                 ),\n-                ty::PredicateAtom::WellFormed(..)\n-                | ty::PredicateAtom::ObjectSafe(..)\n-                | ty::PredicateAtom::ClosureKind(..)\n-                | ty::PredicateAtom::Subtype(..)\n-                | ty::PredicateAtom::ConstEvaluatable(..)\n-                | ty::PredicateAtom::ConstEquate(..) => bug!(\"unexpected predicate {}\", predicate),\n+                ty::PredicateKind::WellFormed(..)\n+                | ty::PredicateKind::ObjectSafe(..)\n+                | ty::PredicateKind::ClosureKind(..)\n+                | ty::PredicateKind::Subtype(..)\n+                | ty::PredicateKind::ConstEvaluatable(..)\n+                | ty::PredicateKind::ConstEquate(..) => bug!(\"unexpected predicate {}\", predicate),\n             };\n             let value = chalk_ir::ProgramClauseImplication {\n                 consequence,\n@@ -136,40 +133,37 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::InEnvironment<chalk_ir::Goal<RustInterner<'\n \n impl<'tcx> LowerInto<'tcx, chalk_ir::GoalData<RustInterner<'tcx>>> for ty::Predicate<'tcx> {\n     fn lower_into(self, interner: &RustInterner<'tcx>) -> chalk_ir::GoalData<RustInterner<'tcx>> {\n-        let (predicate, binders, _named_regions) = collect_bound_vars(\n-            interner,\n-            interner.tcx,\n-            self.bound_atom_with_opt_escaping(interner.tcx),\n-        );\n+        let (predicate, binders, _named_regions) =\n+            collect_bound_vars(interner, interner.tcx, self.kind());\n \n         let value = match predicate {\n-            ty::PredicateAtom::Trait(predicate, _) => {\n+            ty::PredicateKind::Trait(predicate, _) => {\n                 chalk_ir::GoalData::DomainGoal(chalk_ir::DomainGoal::Holds(\n                     chalk_ir::WhereClause::Implemented(predicate.trait_ref.lower_into(interner)),\n                 ))\n             }\n-            ty::PredicateAtom::RegionOutlives(predicate) => {\n+            ty::PredicateKind::RegionOutlives(predicate) => {\n                 chalk_ir::GoalData::DomainGoal(chalk_ir::DomainGoal::Holds(\n                     chalk_ir::WhereClause::LifetimeOutlives(chalk_ir::LifetimeOutlives {\n                         a: predicate.0.lower_into(interner),\n                         b: predicate.1.lower_into(interner),\n                     }),\n                 ))\n             }\n-            ty::PredicateAtom::TypeOutlives(predicate) => {\n+            ty::PredicateKind::TypeOutlives(predicate) => {\n                 chalk_ir::GoalData::DomainGoal(chalk_ir::DomainGoal::Holds(\n                     chalk_ir::WhereClause::TypeOutlives(chalk_ir::TypeOutlives {\n                         ty: predicate.0.lower_into(interner),\n                         lifetime: predicate.1.lower_into(interner),\n                     }),\n                 ))\n             }\n-            ty::PredicateAtom::Projection(predicate) => {\n+            ty::PredicateKind::Projection(predicate) => {\n                 chalk_ir::GoalData::DomainGoal(chalk_ir::DomainGoal::Holds(\n                     chalk_ir::WhereClause::AliasEq(predicate.lower_into(interner)),\n                 ))\n             }\n-            ty::PredicateAtom::WellFormed(arg) => match arg.unpack() {\n+            ty::PredicateKind::WellFormed(arg) => match arg.unpack() {\n                 GenericArgKind::Type(ty) => match ty.kind() {\n                     // FIXME(chalk): In Chalk, a placeholder is WellFormed if it\n                     // `FromEnv`. However, when we \"lower\" Params, we don't update\n@@ -189,21 +183,21 @@ impl<'tcx> LowerInto<'tcx, chalk_ir::GoalData<RustInterner<'tcx>>> for ty::Predi\n                 GenericArgKind::Lifetime(lt) => bug!(\"unexpect well formed predicate: {:?}\", lt),\n             },\n \n-            ty::PredicateAtom::ObjectSafe(t) => chalk_ir::GoalData::DomainGoal(\n+            ty::PredicateKind::ObjectSafe(t) => chalk_ir::GoalData::DomainGoal(\n                 chalk_ir::DomainGoal::ObjectSafe(chalk_ir::TraitId(t)),\n             ),\n \n             // FIXME(chalk): other predicates\n             //\n             // We can defer this, but ultimately we'll want to express\n             // some of these in terms of chalk operations.\n-            ty::PredicateAtom::ClosureKind(..)\n-            | ty::PredicateAtom::Subtype(..)\n-            | ty::PredicateAtom::ConstEvaluatable(..)\n-            | ty::PredicateAtom::ConstEquate(..) => {\n+            ty::PredicateKind::ClosureKind(..)\n+            | ty::PredicateKind::Subtype(..)\n+            | ty::PredicateKind::ConstEvaluatable(..)\n+            | ty::PredicateKind::ConstEquate(..) => {\n                 chalk_ir::GoalData::All(chalk_ir::Goals::empty(interner))\n             }\n-            ty::PredicateAtom::TypeWellFormedFromEnv(ty) => chalk_ir::GoalData::DomainGoal(\n+            ty::PredicateKind::TypeWellFormedFromEnv(ty) => chalk_ir::GoalData::DomainGoal(\n                 chalk_ir::DomainGoal::FromEnv(chalk_ir::FromEnv::Ty(ty.lower_into(interner))),\n             ),\n         };\n@@ -573,38 +567,35 @@ impl<'tcx> LowerInto<'tcx, Option<chalk_ir::QuantifiedWhereClause<RustInterner<'\n         self,\n         interner: &RustInterner<'tcx>,\n     ) -> Option<chalk_ir::QuantifiedWhereClause<RustInterner<'tcx>>> {\n-        let (predicate, binders, _named_regions) = collect_bound_vars(\n-            interner,\n-            interner.tcx,\n-            self.bound_atom_with_opt_escaping(interner.tcx),\n-        );\n+        let (predicate, binders, _named_regions) =\n+            collect_bound_vars(interner, interner.tcx, self.kind());\n         let value = match predicate {\n-            ty::PredicateAtom::Trait(predicate, _) => {\n+            ty::PredicateKind::Trait(predicate, _) => {\n                 Some(chalk_ir::WhereClause::Implemented(predicate.trait_ref.lower_into(interner)))\n             }\n-            ty::PredicateAtom::RegionOutlives(predicate) => {\n+            ty::PredicateKind::RegionOutlives(predicate) => {\n                 Some(chalk_ir::WhereClause::LifetimeOutlives(chalk_ir::LifetimeOutlives {\n                     a: predicate.0.lower_into(interner),\n                     b: predicate.1.lower_into(interner),\n                 }))\n             }\n-            ty::PredicateAtom::TypeOutlives(predicate) => {\n+            ty::PredicateKind::TypeOutlives(predicate) => {\n                 Some(chalk_ir::WhereClause::TypeOutlives(chalk_ir::TypeOutlives {\n                     ty: predicate.0.lower_into(interner),\n                     lifetime: predicate.1.lower_into(interner),\n                 }))\n             }\n-            ty::PredicateAtom::Projection(predicate) => {\n+            ty::PredicateKind::Projection(predicate) => {\n                 Some(chalk_ir::WhereClause::AliasEq(predicate.lower_into(interner)))\n             }\n-            ty::PredicateAtom::WellFormed(_ty) => None,\n-\n-            ty::PredicateAtom::ObjectSafe(..)\n-            | ty::PredicateAtom::ClosureKind(..)\n-            | ty::PredicateAtom::Subtype(..)\n-            | ty::PredicateAtom::ConstEvaluatable(..)\n-            | ty::PredicateAtom::ConstEquate(..)\n-            | ty::PredicateAtom::TypeWellFormedFromEnv(..) => {\n+            ty::PredicateKind::WellFormed(_ty) => None,\n+\n+            ty::PredicateKind::ObjectSafe(..)\n+            | ty::PredicateKind::ClosureKind(..)\n+            | ty::PredicateKind::Subtype(..)\n+            | ty::PredicateKind::ConstEvaluatable(..)\n+            | ty::PredicateKind::ConstEquate(..)\n+            | ty::PredicateKind::TypeWellFormedFromEnv(..) => {\n                 bug!(\"unexpected predicate {}\", &self)\n             }\n         };\n@@ -707,32 +698,29 @@ impl<'tcx> LowerInto<'tcx, Option<chalk_solve::rust_ir::QuantifiedInlineBound<Ru\n         self,\n         interner: &RustInterner<'tcx>,\n     ) -> Option<chalk_solve::rust_ir::QuantifiedInlineBound<RustInterner<'tcx>>> {\n-        let (predicate, binders, _named_regions) = collect_bound_vars(\n-            interner,\n-            interner.tcx,\n-            self.bound_atom_with_opt_escaping(interner.tcx),\n-        );\n+        let (predicate, binders, _named_regions) =\n+            collect_bound_vars(interner, interner.tcx, self.kind());\n         match predicate {\n-            ty::PredicateAtom::Trait(predicate, _) => Some(chalk_ir::Binders::new(\n+            ty::PredicateKind::Trait(predicate, _) => Some(chalk_ir::Binders::new(\n                 binders,\n                 chalk_solve::rust_ir::InlineBound::TraitBound(\n                     predicate.trait_ref.lower_into(interner),\n                 ),\n             )),\n-            ty::PredicateAtom::Projection(predicate) => Some(chalk_ir::Binders::new(\n+            ty::PredicateKind::Projection(predicate) => Some(chalk_ir::Binders::new(\n                 binders,\n                 chalk_solve::rust_ir::InlineBound::AliasEqBound(predicate.lower_into(interner)),\n             )),\n-            ty::PredicateAtom::TypeOutlives(_predicate) => None,\n-            ty::PredicateAtom::WellFormed(_ty) => None,\n-\n-            ty::PredicateAtom::RegionOutlives(..)\n-            | ty::PredicateAtom::ObjectSafe(..)\n-            | ty::PredicateAtom::ClosureKind(..)\n-            | ty::PredicateAtom::Subtype(..)\n-            | ty::PredicateAtom::ConstEvaluatable(..)\n-            | ty::PredicateAtom::ConstEquate(..)\n-            | ty::PredicateAtom::TypeWellFormedFromEnv(..) => {\n+            ty::PredicateKind::TypeOutlives(_predicate) => None,\n+            ty::PredicateKind::WellFormed(_ty) => None,\n+\n+            ty::PredicateKind::RegionOutlives(..)\n+            | ty::PredicateKind::ObjectSafe(..)\n+            | ty::PredicateKind::ClosureKind(..)\n+            | ty::PredicateKind::Subtype(..)\n+            | ty::PredicateKind::ConstEvaluatable(..)\n+            | ty::PredicateKind::ConstEquate(..)\n+            | ty::PredicateKind::TypeWellFormedFromEnv(..) => {\n                 bug!(\"unexpected predicate {}\", &self)\n             }\n         }"}, {"sha": "90ba90259c32bcd2b11a4a9127c9e9f60c79a368", "filename": "compiler/rustc_traits/src/implied_outlives_bounds.rs", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/rust-lang/rust/blob/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fimplied_outlives_bounds.rs?ref=4253153db205251f72ea4493687a31e04a2a8ca0", "patch": "@@ -94,27 +94,27 @@ fn compute_implied_outlives_bounds<'tcx>(\n         // region relationships.\n         implied_bounds.extend(obligations.into_iter().flat_map(|obligation| {\n             assert!(!obligation.has_escaping_bound_vars());\n-            match obligation.predicate.kind() {\n-                &ty::PredicateKind::ForAll(..) => vec![],\n-                &ty::PredicateKind::Atom(atom) => match atom {\n-                    ty::PredicateAtom::Trait(..)\n-                    | ty::PredicateAtom::Subtype(..)\n-                    | ty::PredicateAtom::Projection(..)\n-                    | ty::PredicateAtom::ClosureKind(..)\n-                    | ty::PredicateAtom::ObjectSafe(..)\n-                    | ty::PredicateAtom::ConstEvaluatable(..)\n-                    | ty::PredicateAtom::ConstEquate(..)\n-                    | ty::PredicateAtom::TypeWellFormedFromEnv(..) => vec![],\n-                    ty::PredicateAtom::WellFormed(arg) => {\n+            match obligation.predicate.kind().no_bound_vars() {\n+                None => vec![],\n+                Some(pred) => match pred {\n+                    ty::PredicateKind::Trait(..)\n+                    | ty::PredicateKind::Subtype(..)\n+                    | ty::PredicateKind::Projection(..)\n+                    | ty::PredicateKind::ClosureKind(..)\n+                    | ty::PredicateKind::ObjectSafe(..)\n+                    | ty::PredicateKind::ConstEvaluatable(..)\n+                    | ty::PredicateKind::ConstEquate(..)\n+                    | ty::PredicateKind::TypeWellFormedFromEnv(..) => vec![],\n+                    ty::PredicateKind::WellFormed(arg) => {\n                         wf_args.push(arg);\n                         vec![]\n                     }\n \n-                    ty::PredicateAtom::RegionOutlives(ty::OutlivesPredicate(r_a, r_b)) => {\n+                    ty::PredicateKind::RegionOutlives(ty::OutlivesPredicate(r_a, r_b)) => {\n                         vec![OutlivesBound::RegionSubRegion(r_b, r_a)]\n                     }\n \n-                    ty::PredicateAtom::TypeOutlives(ty::OutlivesPredicate(ty_a, r_b)) => {\n+                    ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(ty_a, r_b)) => {\n                         let ty_a = infcx.resolve_vars_if_possible(ty_a);\n                         let mut components = smallvec![];\n                         tcx.push_outlives_components(ty_a, &mut components);"}, {"sha": "1213e5539084ea6d1e8e8c87f3d570ca4490eb7a", "filename": "compiler/rustc_traits/src/normalize_erasing_regions.rs", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/rust-lang/rust/blob/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_traits%2Fsrc%2Fnormalize_erasing_regions.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_traits%2Fsrc%2Fnormalize_erasing_regions.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Fnormalize_erasing_regions.rs?ref=4253153db205251f72ea4493687a31e04a2a8ca0", "patch": "@@ -46,16 +46,16 @@ fn normalize_generic_arg_after_erasing_regions<'tcx>(\n }\n \n fn not_outlives_predicate(p: &ty::Predicate<'tcx>) -> bool {\n-    match p.skip_binders() {\n-        ty::PredicateAtom::RegionOutlives(..) | ty::PredicateAtom::TypeOutlives(..) => false,\n-        ty::PredicateAtom::Trait(..)\n-        | ty::PredicateAtom::Projection(..)\n-        | ty::PredicateAtom::WellFormed(..)\n-        | ty::PredicateAtom::ObjectSafe(..)\n-        | ty::PredicateAtom::ClosureKind(..)\n-        | ty::PredicateAtom::Subtype(..)\n-        | ty::PredicateAtom::ConstEvaluatable(..)\n-        | ty::PredicateAtom::ConstEquate(..)\n-        | ty::PredicateAtom::TypeWellFormedFromEnv(..) => true,\n+    match p.kind().skip_binder() {\n+        ty::PredicateKind::RegionOutlives(..) | ty::PredicateKind::TypeOutlives(..) => false,\n+        ty::PredicateKind::Trait(..)\n+        | ty::PredicateKind::Projection(..)\n+        | ty::PredicateKind::WellFormed(..)\n+        | ty::PredicateKind::ObjectSafe(..)\n+        | ty::PredicateKind::ClosureKind(..)\n+        | ty::PredicateKind::Subtype(..)\n+        | ty::PredicateKind::ConstEvaluatable(..)\n+        | ty::PredicateKind::ConstEquate(..)\n+        | ty::PredicateKind::TypeWellFormedFromEnv(..) => true,\n     }\n }"}, {"sha": "6304f696b00fad2d02c0086618d0d46abc172197", "filename": "compiler/rustc_traits/src/type_op.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_traits%2Fsrc%2Ftype_op.rs?ref=4253153db205251f72ea4493687a31e04a2a8ca0", "patch": "@@ -140,7 +140,7 @@ impl AscribeUserTypeCx<'me, 'tcx> {\n             self.relate(self_ty, Variance::Invariant, impl_self_ty)?;\n \n             self.prove_predicate(\n-                ty::PredicateAtom::WellFormed(impl_self_ty.into()).to_predicate(self.tcx()),\n+                ty::PredicateKind::WellFormed(impl_self_ty.into()).to_predicate(self.tcx()),\n             );\n         }\n \n@@ -155,7 +155,7 @@ impl AscribeUserTypeCx<'me, 'tcx> {\n         // them?  This would only be relevant if some input\n         // type were ill-formed but did not appear in `ty`,\n         // which...could happen with normalization...\n-        self.prove_predicate(ty::PredicateAtom::WellFormed(ty.into()).to_predicate(self.tcx()));\n+        self.prove_predicate(ty::PredicateKind::WellFormed(ty.into()).to_predicate(self.tcx()));\n         Ok(())\n     }\n }"}, {"sha": "bd1d9cc895fb0d0507d5a96a5807d95215c3ced4", "filename": "compiler/rustc_ty_utils/src/ty.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_ty_utils%2Fsrc%2Fty.rs?ref=4253153db205251f72ea4493687a31e04a2a8ca0", "patch": "@@ -5,7 +5,7 @@ use rustc_hir::def_id::{CrateNum, DefId, LocalDefId, LOCAL_CRATE};\n use rustc_middle::hir::map as hir_map;\n use rustc_middle::ty::subst::Subst;\n use rustc_middle::ty::{\n-    self, Binder, Predicate, PredicateAtom, PredicateKind, ToPredicate, Ty, TyCtxt, WithConstness,\n+    self, Binder, Predicate, PredicateKind, ToPredicate, Ty, TyCtxt, WithConstness,\n };\n use rustc_session::CrateDisambiguator;\n use rustc_span::symbol::Symbol;\n@@ -378,8 +378,8 @@ fn well_formed_types_in_env<'tcx>(\n     let input_clauses = inputs.into_iter().filter_map(|arg| {\n         match arg.unpack() {\n             GenericArgKind::Type(ty) => {\n-                let binder = Binder::dummy(PredicateAtom::TypeWellFormedFromEnv(ty));\n-                Some(tcx.mk_predicate(PredicateKind::ForAll(binder)))\n+                let binder = Binder::dummy(PredicateKind::TypeWellFormedFromEnv(ty));\n+                Some(tcx.mk_predicate(binder))\n             }\n \n             // FIXME(eddyb) no WF conditions from lifetimes?"}, {"sha": "059f9b41068c70a58d963546147f48116fbab679", "filename": "compiler/rustc_typeck/src/astconv/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fastconv%2Fmod.rs?ref=4253153db205251f72ea4493687a31e04a2a8ca0", "patch": "@@ -1177,9 +1177,9 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                     obligation.predicate\n                 );\n \n-                let bound_predicate = obligation.predicate.bound_atom();\n+                let bound_predicate = obligation.predicate.kind();\n                 match bound_predicate.skip_binder() {\n-                    ty::PredicateAtom::Trait(pred, _) => {\n+                    ty::PredicateKind::Trait(pred, _) => {\n                         let pred = bound_predicate.rebind(pred);\n                         associated_types.entry(span).or_default().extend(\n                             tcx.associated_items(pred.def_id())\n@@ -1188,7 +1188,7 @@ impl<'o, 'tcx> dyn AstConv<'tcx> + 'o {\n                                 .map(|item| item.def_id),\n                         );\n                     }\n-                    ty::PredicateAtom::Projection(pred) => {\n+                    ty::PredicateKind::Projection(pred) => {\n                         let pred = bound_predicate.rebind(pred);\n                         // A `Self` within the original bound will be substituted with a\n                         // `trait_object_dummy_self`, so check for that."}, {"sha": "30e0e3eecd4a318cfd8ab92c8a0206f6d0292a8d", "filename": "compiler/rustc_typeck/src/check/_match.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2F_match.rs?ref=4253153db205251f72ea4493687a31e04a2a8ca0", "patch": "@@ -544,9 +544,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     self.infcx.instantiate_opaque_types(id, self.body_id, self.param_env, ty, span);\n                 let mut suggest_box = !impl_trait_ret_ty.obligations.is_empty();\n                 for o in impl_trait_ret_ty.obligations {\n-                    match o.predicate.skip_binders_unchecked() {\n-                        ty::PredicateAtom::Trait(t, constness) => {\n-                            let pred = ty::PredicateAtom::Trait(\n+                    match o.predicate.kind().skip_binder() {\n+                        ty::PredicateKind::Trait(t, constness) => {\n+                            let pred = ty::PredicateKind::Trait(\n                                 ty::TraitPredicate {\n                                     trait_ref: ty::TraitRef {\n                                         def_id: t.def_id(),"}, {"sha": "f34aaec10a9b96230cff8cdc2e9feac7ac2eb422", "filename": "compiler/rustc_typeck/src/check/closure.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fclosure.rs?ref=4253153db205251f72ea4493687a31e04a2a8ca0", "patch": "@@ -192,9 +192,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     obligation.predicate\n                 );\n \n-                let bound_predicate = obligation.predicate.bound_atom();\n-                if let ty::PredicateAtom::Projection(proj_predicate) =\n-                    obligation.predicate.skip_binders()\n+                let bound_predicate = obligation.predicate.kind();\n+                if let ty::PredicateKind::Projection(proj_predicate) =\n+                    obligation.predicate.kind().skip_binder()\n                 {\n                     // Given a Projection predicate, we can potentially infer\n                     // the complete signature.\n@@ -622,8 +622,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         // where R is the return type we are expecting. This type `T`\n         // will be our output.\n         let output_ty = self.obligations_for_self_ty(ret_vid).find_map(|(_, obligation)| {\n-            let bound_predicate = obligation.predicate.bound_atom();\n-            if let ty::PredicateAtom::Projection(proj_predicate) = bound_predicate.skip_binder() {\n+            let bound_predicate = obligation.predicate.kind();\n+            if let ty::PredicateKind::Projection(proj_predicate) = bound_predicate.skip_binder() {\n                 self.deduce_future_output_from_projection(\n                     obligation.cause.span,\n                     bound_predicate.rebind(proj_predicate),"}, {"sha": "34ad8ec08984e6b6de8c1524dca8b2fe3d26de2f", "filename": "compiler/rustc_typeck/src/check/coercion.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fcoercion.rs?ref=4253153db205251f72ea4493687a31e04a2a8ca0", "patch": "@@ -583,9 +583,9 @@ impl<'f, 'tcx> Coerce<'f, 'tcx> {\n         while !queue.is_empty() {\n             let obligation = queue.remove(0);\n             debug!(\"coerce_unsized resolve step: {:?}\", obligation);\n-            let bound_predicate = obligation.predicate.bound_atom();\n+            let bound_predicate = obligation.predicate.kind();\n             let trait_pred = match bound_predicate.skip_binder() {\n-                ty::PredicateAtom::Trait(trait_pred, _)\n+                ty::PredicateKind::Trait(trait_pred, _)\n                     if traits.contains(&trait_pred.def_id()) =>\n                 {\n                     if unsize_did == trait_pred.def_id() {"}, {"sha": "4c3c4fd447058d5544f433a89b120691b538c639", "filename": "compiler/rustc_typeck/src/check/dropck.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fdropck.rs?ref=4253153db205251f72ea4493687a31e04a2a8ca0", "patch": "@@ -226,13 +226,13 @@ fn ensure_drop_predicates_are_implied_by_item_defn<'tcx>(\n         // could be extended easily also to the other `Predicate`.\n         let predicate_matches_closure = |p: Predicate<'tcx>| {\n             let mut relator: SimpleEqRelation<'tcx> = SimpleEqRelation::new(tcx, self_param_env);\n-            let predicate = predicate.bound_atom();\n-            let p = p.bound_atom();\n+            let predicate = predicate.kind();\n+            let p = p.kind();\n             match (predicate.skip_binder(), p.skip_binder()) {\n-                (ty::PredicateAtom::Trait(a, _), ty::PredicateAtom::Trait(b, _)) => {\n+                (ty::PredicateKind::Trait(a, _), ty::PredicateKind::Trait(b, _)) => {\n                     relator.relate(predicate.rebind(a), p.rebind(b)).is_ok()\n                 }\n-                (ty::PredicateAtom::Projection(a), ty::PredicateAtom::Projection(b)) => {\n+                (ty::PredicateKind::Projection(a), ty::PredicateKind::Projection(b)) => {\n                     relator.relate(predicate.rebind(a), p.rebind(b)).is_ok()\n                 }\n                 _ => predicate == p,"}, {"sha": "5a372c0aaabf1893da7c0b2b1b62b3ac9aa8e05e", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/_impl.rs", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2F_impl.rs?ref=4253153db205251f72ea4493687a31e04a2a8ca0", "patch": "@@ -542,7 +542,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         self.register_predicate(traits::Obligation::new(\n             cause,\n             self.param_env,\n-            ty::PredicateAtom::WellFormed(arg).to_predicate(self.tcx),\n+            ty::PredicateKind::WellFormed(arg).to_predicate(self.tcx),\n         ));\n     }\n \n@@ -764,21 +764,21 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             .pending_obligations()\n             .into_iter()\n             .filter_map(move |obligation| {\n-                let bound_predicate = obligation.predicate.bound_atom();\n+                let bound_predicate = obligation.predicate.kind();\n                 match bound_predicate.skip_binder() {\n-                    ty::PredicateAtom::Projection(data) => {\n+                    ty::PredicateKind::Projection(data) => {\n                         Some((bound_predicate.rebind(data).to_poly_trait_ref(self.tcx), obligation))\n                     }\n-                    ty::PredicateAtom::Trait(data, _) => {\n+                    ty::PredicateKind::Trait(data, _) => {\n                         Some((bound_predicate.rebind(data).to_poly_trait_ref(), obligation))\n                     }\n-                    ty::PredicateAtom::Subtype(..) => None,\n-                    ty::PredicateAtom::RegionOutlives(..) => None,\n-                    ty::PredicateAtom::TypeOutlives(..) => None,\n-                    ty::PredicateAtom::WellFormed(..) => None,\n-                    ty::PredicateAtom::ObjectSafe(..) => None,\n-                    ty::PredicateAtom::ConstEvaluatable(..) => None,\n-                    ty::PredicateAtom::ConstEquate(..) => None,\n+                    ty::PredicateKind::Subtype(..) => None,\n+                    ty::PredicateKind::RegionOutlives(..) => None,\n+                    ty::PredicateKind::TypeOutlives(..) => None,\n+                    ty::PredicateKind::WellFormed(..) => None,\n+                    ty::PredicateKind::ObjectSafe(..) => None,\n+                    ty::PredicateKind::ConstEvaluatable(..) => None,\n+                    ty::PredicateKind::ConstEquate(..) => None,\n                     // N.B., this predicate is created by breaking down a\n                     // `ClosureType: FnFoo()` predicate, where\n                     // `ClosureType` represents some `Closure`. It can't\n@@ -787,8 +787,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     // this closure yet; this is exactly why the other\n                     // code is looking for a self type of a unresolved\n                     // inference variable.\n-                    ty::PredicateAtom::ClosureKind(..) => None,\n-                    ty::PredicateAtom::TypeWellFormedFromEnv(..) => None,\n+                    ty::PredicateKind::ClosureKind(..) => None,\n+                    ty::PredicateKind::TypeWellFormedFromEnv(..) => None,\n                 }\n             })\n             .filter(move |(tr, _)| self.self_type_matches_expected_vid(*tr, ty_var_root))"}, {"sha": "6df9e3ab7dbe8d515fa214c89d3b0ee805fa48ce", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/checks.rs", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/rust-lang/rust/blob/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fchecks.rs?ref=4253153db205251f72ea4493687a31e04a2a8ca0", "patch": "@@ -923,8 +923,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 continue;\n             }\n \n-            if let ty::PredicateAtom::Trait(predicate, _) =\n-                error.obligation.predicate.skip_binders()\n+            if let ty::PredicateKind::Trait(predicate, _) =\n+                error.obligation.predicate.kind().skip_binder()\n             {\n                 // Collect the argument position for all arguments that could have caused this\n                 // `FulfillmentError`.\n@@ -974,8 +974,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n             if let hir::ExprKind::Path(qpath) = &path.kind {\n                 if let hir::QPath::Resolved(_, path) = &qpath {\n                     for error in errors {\n-                        if let ty::PredicateAtom::Trait(predicate, _) =\n-                            error.obligation.predicate.skip_binders()\n+                        if let ty::PredicateKind::Trait(predicate, _) =\n+                            error.obligation.predicate.kind().skip_binder()\n                         {\n                             // If any of the type arguments in this path segment caused the\n                             // `FullfillmentError`, point at its span (#61860)."}, {"sha": "6d09043bd50334eca7ab12997bab152c9d5e205d", "filename": "compiler/rustc_typeck/src/check/fn_ctxt/mod.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Ffn_ctxt%2Fmod.rs?ref=4253153db205251f72ea4493687a31e04a2a8ca0", "patch": "@@ -194,8 +194,8 @@ impl<'a, 'tcx> AstConv<'tcx> for FnCtxt<'a, 'tcx> {\n             parent: None,\n             predicates: tcx.arena.alloc_from_iter(\n                 self.param_env.caller_bounds().iter().filter_map(|predicate| {\n-                    match predicate.skip_binders() {\n-                        ty::PredicateAtom::Trait(data, _) if data.self_ty().is_param(index) => {\n+                    match predicate.kind().skip_binder() {\n+                        ty::PredicateKind::Trait(data, _) if data.self_ty().is_param(index) => {\n                             // HACK(eddyb) should get the original `Span`.\n                             let span = tcx.def_span(def_id);\n                             Some((predicate, span))"}, {"sha": "af91514ba4bcd4996eae766e83c2d0ce17d2fdfc", "filename": "compiler/rustc_typeck/src/check/method/confirm.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fconfirm.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fconfirm.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fconfirm.rs?ref=4253153db205251f72ea4493687a31e04a2a8ca0", "patch": "@@ -478,8 +478,8 @@ impl<'a, 'tcx> ConfirmContext<'a, 'tcx> {\n \n         traits::elaborate_predicates(self.tcx, predicates.predicates.iter().copied())\n             // We don't care about regions here.\n-            .filter_map(|obligation| match obligation.predicate.skip_binders() {\n-                ty::PredicateAtom::Trait(trait_pred, _) if trait_pred.def_id() == sized_def_id => {\n+            .filter_map(|obligation| match obligation.predicate.kind().skip_binder() {\n+                ty::PredicateKind::Trait(trait_pred, _) if trait_pred.def_id() == sized_def_id => {\n                     let span = predicates\n                         .predicates\n                         .iter()"}, {"sha": "44343234117a4f6e9b54bdf8a99b9b646e51bfa5", "filename": "compiler/rustc_typeck/src/check/method/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fmod.rs?ref=4253153db205251f72ea4493687a31e04a2a8ca0", "patch": "@@ -399,7 +399,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n         obligations.push(traits::Obligation::new(\n             cause,\n             self.param_env,\n-            ty::PredicateAtom::WellFormed(method_ty.into()).to_predicate(tcx),\n+            ty::PredicateKind::WellFormed(method_ty.into()).to_predicate(tcx),\n         ));\n \n         let callee = MethodCallee { def_id, substs: trait_ref.substs, sig: fn_sig };"}, {"sha": "be80b638260b78a4b6ac0d8435b149364dd956d7", "filename": "compiler/rustc_typeck/src/check/method/probe.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fprobe.rs?ref=4253153db205251f72ea4493687a31e04a2a8ca0", "patch": "@@ -795,26 +795,26 @@ impl<'a, 'tcx> ProbeContext<'a, 'tcx> {\n         debug!(\"assemble_inherent_candidates_from_param(param_ty={:?})\", param_ty);\n \n         let bounds = self.param_env.caller_bounds().iter().filter_map(|predicate| {\n-            let bound_predicate = predicate.bound_atom();\n+            let bound_predicate = predicate.kind();\n             match bound_predicate.skip_binder() {\n-                ty::PredicateAtom::Trait(trait_predicate, _) => {\n+                ty::PredicateKind::Trait(trait_predicate, _) => {\n                     match *trait_predicate.trait_ref.self_ty().kind() {\n                         ty::Param(p) if p == param_ty => {\n                             Some(bound_predicate.rebind(trait_predicate.trait_ref))\n                         }\n                         _ => None,\n                     }\n                 }\n-                ty::PredicateAtom::Subtype(..)\n-                | ty::PredicateAtom::Projection(..)\n-                | ty::PredicateAtom::RegionOutlives(..)\n-                | ty::PredicateAtom::WellFormed(..)\n-                | ty::PredicateAtom::ObjectSafe(..)\n-                | ty::PredicateAtom::ClosureKind(..)\n-                | ty::PredicateAtom::TypeOutlives(..)\n-                | ty::PredicateAtom::ConstEvaluatable(..)\n-                | ty::PredicateAtom::ConstEquate(..)\n-                | ty::PredicateAtom::TypeWellFormedFromEnv(..) => None,\n+                ty::PredicateKind::Subtype(..)\n+                | ty::PredicateKind::Projection(..)\n+                | ty::PredicateKind::RegionOutlives(..)\n+                | ty::PredicateKind::WellFormed(..)\n+                | ty::PredicateKind::ObjectSafe(..)\n+                | ty::PredicateKind::ClosureKind(..)\n+                | ty::PredicateKind::TypeOutlives(..)\n+                | ty::PredicateKind::ConstEvaluatable(..)\n+                | ty::PredicateKind::ConstEquate(..)\n+                | ty::PredicateKind::TypeWellFormedFromEnv(..) => None,\n             }\n         });\n "}, {"sha": "c553fda49c3083efce25809220f9a85a819546ef", "filename": "compiler/rustc_typeck/src/check/method/suggest.rs", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmethod%2Fsuggest.rs?ref=4253153db205251f72ea4493687a31e04a2a8ca0", "patch": "@@ -582,8 +582,8 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                     let mut collect_type_param_suggestions =\n                         |self_ty: Ty<'tcx>, parent_pred: &ty::Predicate<'tcx>, obligation: &str| {\n                             // We don't care about regions here, so it's fine to skip the binder here.\n-                            if let (ty::Param(_), ty::PredicateAtom::Trait(p, _)) =\n-                                (self_ty.kind(), parent_pred.skip_binders())\n+                            if let (ty::Param(_), ty::PredicateKind::Trait(p, _)) =\n+                                (self_ty.kind(), parent_pred.kind().skip_binder())\n                             {\n                                 if let ty::Adt(def, _) = p.trait_ref.self_ty().kind() {\n                                     let node = def.did.as_local().map(|def_id| {\n@@ -637,9 +637,9 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                         }\n                     };\n                     let mut format_pred = |pred: ty::Predicate<'tcx>| {\n-                        let bound_predicate = pred.bound_atom();\n+                        let bound_predicate = pred.kind();\n                         match bound_predicate.skip_binder() {\n-                            ty::PredicateAtom::Projection(pred) => {\n+                            ty::PredicateKind::Projection(pred) => {\n                                 let pred = bound_predicate.rebind(pred);\n                                 // `<Foo as Iterator>::Item = String`.\n                                 let trait_ref =\n@@ -658,7 +658,7 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                                 bound_span_label(trait_ref.self_ty(), &obligation, &quiet);\n                                 Some((obligation, trait_ref.self_ty()))\n                             }\n-                            ty::PredicateAtom::Trait(poly_trait_ref, _) => {\n+                            ty::PredicateKind::Trait(poly_trait_ref, _) => {\n                                 let p = poly_trait_ref.trait_ref;\n                                 let self_ty = p.self_ty();\n                                 let path = p.print_only_trait_path();\n@@ -992,11 +992,11 @@ impl<'a, 'tcx> FnCtxt<'a, 'tcx> {\n                 // implementing a trait would be legal but is rejected\n                 // here).\n                 unsatisfied_predicates.iter().all(|(p, _)| {\n-                    match p.skip_binders() {\n+                    match p.kind().skip_binder() {\n                         // Hide traits if they are present in predicates as they can be fixed without\n                         // having to implement them.\n-                        ty::PredicateAtom::Trait(t, _) => t.def_id() == info.def_id,\n-                        ty::PredicateAtom::Projection(p) => {\n+                        ty::PredicateKind::Trait(t, _) => t.def_id() == info.def_id,\n+                        ty::PredicateKind::Projection(p) => {\n                             p.projection_ty.item_def_id == info.def_id\n                         }\n                         _ => false,"}, {"sha": "52276ed4beeaa4711f77f970e6fbb07a074a3a13", "filename": "compiler/rustc_typeck/src/check/mod.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fmod.rs?ref=4253153db205251f72ea4493687a31e04a2a8ca0", "patch": "@@ -864,9 +864,9 @@ fn bounds_from_generic_predicates<'tcx>(\n     let mut projections = vec![];\n     for (predicate, _) in predicates.predicates {\n         debug!(\"predicate {:?}\", predicate);\n-        let bound_predicate = predicate.bound_atom();\n+        let bound_predicate = predicate.kind();\n         match bound_predicate.skip_binder() {\n-            ty::PredicateAtom::Trait(trait_predicate, _) => {\n+            ty::PredicateKind::Trait(trait_predicate, _) => {\n                 let entry = types.entry(trait_predicate.self_ty()).or_default();\n                 let def_id = trait_predicate.def_id();\n                 if Some(def_id) != tcx.lang_items().sized_trait() {\n@@ -875,7 +875,7 @@ fn bounds_from_generic_predicates<'tcx>(\n                     entry.push(trait_predicate.def_id());\n                 }\n             }\n-            ty::PredicateAtom::Projection(projection_pred) => {\n+            ty::PredicateKind::Projection(projection_pred) => {\n                 projections.push(bound_predicate.rebind(projection_pred));\n             }\n             _ => {}"}, {"sha": "c90db4786e35fbc793594af9d559114a86219ae0", "filename": "compiler/rustc_typeck/src/check/wfcheck.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcheck%2Fwfcheck.rs?ref=4253153db205251f72ea4493687a31e04a2a8ca0", "patch": "@@ -532,7 +532,7 @@ fn check_type_defn<'tcx, F>(\n                 fcx.register_predicate(traits::Obligation::new(\n                     cause,\n                     fcx.param_env,\n-                    ty::PredicateAtom::ConstEvaluatable(\n+                    ty::PredicateKind::ConstEvaluatable(\n                         ty::WithOptConstParam::unknown(discr_def_id.to_def_id()),\n                         discr_substs,\n                     )"}, {"sha": "d589989511db17e1fb1ad59b02dfb65d2d0d6422", "filename": "compiler/rustc_typeck/src/collect.rs", "status": "modified", "additions": 17, "deletions": 19, "changes": 36, "blob_url": "https://github.com/rust-lang/rust/blob/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect.rs?ref=4253153db205251f72ea4493687a31e04a2a8ca0", "patch": "@@ -562,8 +562,8 @@ fn type_param_predicates(\n     let extra_predicates = extend.into_iter().chain(\n         icx.type_parameter_bounds_in_generics(ast_generics, param_id, ty, OnlySelfBounds(true))\n             .into_iter()\n-            .filter(|(predicate, _)| match predicate.skip_binders() {\n-                ty::PredicateAtom::Trait(data, _) => data.self_ty().is_param(index),\n+            .filter(|(predicate, _)| match predicate.kind().skip_binder() {\n+                ty::PredicateKind::Trait(data, _) => data.self_ty().is_param(index),\n                 _ => false,\n             }),\n     );\n@@ -1027,7 +1027,7 @@ fn super_predicates_of(tcx: TyCtxt<'_>, trait_def_id: DefId) -> ty::GenericPredi\n     // which will, in turn, reach indirect supertraits.\n     for &(pred, span) in superbounds {\n         debug!(\"superbound: {:?}\", pred);\n-        if let ty::PredicateAtom::Trait(bound, _) = pred.skip_binders() {\n+        if let ty::PredicateKind::Trait(bound, _) = pred.kind().skip_binder() {\n             tcx.at(span).super_predicates_of(bound.def_id());\n         }\n     }\n@@ -1946,13 +1946,10 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericP\n                     } else {\n                         let span = bound_pred.bounded_ty.span;\n                         let re_root_empty = tcx.lifetimes.re_root_empty;\n-                        let predicate = ty::Binder::bind(ty::PredicateAtom::TypeOutlives(\n+                        let predicate = ty::Binder::bind(ty::PredicateKind::TypeOutlives(\n                             ty::OutlivesPredicate(ty, re_root_empty),\n                         ));\n-                        predicates.insert((\n-                            predicate.potentially_quantified(tcx, ty::PredicateKind::ForAll),\n-                            span,\n-                        ));\n+                        predicates.insert((predicate.to_predicate(tcx), span));\n                     }\n                 }\n \n@@ -1993,10 +1990,10 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericP\n                         hir::GenericBound::Outlives(lifetime) => {\n                             let region = AstConv::ast_region_to_region(&icx, lifetime, None);\n                             predicates.insert((\n-                                ty::Binder::bind(ty::PredicateAtom::TypeOutlives(\n+                                ty::Binder::bind(ty::PredicateKind::TypeOutlives(\n                                     ty::OutlivesPredicate(ty, region),\n                                 ))\n-                                .potentially_quantified(tcx, ty::PredicateKind::ForAll),\n+                                .to_predicate(tcx),\n                                 lifetime.span,\n                             ));\n                         }\n@@ -2013,7 +2010,7 @@ fn gather_explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericP\n                         }\n                         _ => bug!(),\n                     };\n-                    let pred = ty::PredicateAtom::RegionOutlives(ty::OutlivesPredicate(r1, r2))\n+                    let pred = ty::PredicateKind::RegionOutlives(ty::OutlivesPredicate(r1, r2))\n                         .to_predicate(icx.tcx);\n \n                     (pred, span)\n@@ -2078,7 +2075,7 @@ fn const_evaluatable_predicates_of<'tcx>(\n             if let ty::ConstKind::Unevaluated(def, substs, None) = ct.val {\n                 let span = self.tcx.hir().span(c.hir_id);\n                 self.preds.insert((\n-                    ty::PredicateAtom::ConstEvaluatable(def, substs).to_predicate(self.tcx),\n+                    ty::PredicateKind::ConstEvaluatable(def, substs).to_predicate(self.tcx),\n                     span,\n                 ));\n             }\n@@ -2097,7 +2094,7 @@ fn const_evaluatable_predicates_of<'tcx>(\n                 fn visit_const(&mut self, ct: &'tcx Const<'tcx>) -> ControlFlow<Self::BreakTy> {\n                     if let ty::ConstKind::Unevaluated(def, substs, None) = ct.val {\n                         self.preds.insert((\n-                            ty::PredicateAtom::ConstEvaluatable(def, substs).to_predicate(self.tcx),\n+                            ty::PredicateKind::ConstEvaluatable(def, substs).to_predicate(self.tcx),\n                             self.span,\n                         ));\n                     }\n@@ -2183,12 +2180,12 @@ fn explicit_predicates_of(tcx: TyCtxt<'_>, def_id: DefId) -> ty::GenericPredicat\n             .predicates\n             .iter()\n             .copied()\n-            .filter(|(pred, _)| match pred.skip_binders() {\n-                ty::PredicateAtom::Trait(tr, _) => !is_assoc_item_ty(tr.self_ty()),\n-                ty::PredicateAtom::Projection(proj) => {\n+            .filter(|(pred, _)| match pred.kind().skip_binder() {\n+                ty::PredicateKind::Trait(tr, _) => !is_assoc_item_ty(tr.self_ty()),\n+                ty::PredicateKind::Projection(proj) => {\n                     !is_assoc_item_ty(proj.projection_ty.self_ty())\n                 }\n-                ty::PredicateAtom::TypeOutlives(outlives) => !is_assoc_item_ty(outlives.0),\n+                ty::PredicateKind::TypeOutlives(outlives) => !is_assoc_item_ty(outlives.0),\n                 _ => true,\n             })\n             .collect();\n@@ -2217,7 +2214,8 @@ fn projection_ty_from_predicates(\n     let (ty_def_id, item_def_id) = key;\n     let mut projection_ty = None;\n     for (predicate, _) in tcx.predicates_of(ty_def_id).predicates {\n-        if let ty::PredicateAtom::Projection(projection_predicate) = predicate.skip_binders() {\n+        if let ty::PredicateKind::Projection(projection_predicate) = predicate.kind().skip_binder()\n+        {\n             if item_def_id == projection_predicate.projection_ty.item_def_id {\n                 projection_ty = Some(projection_predicate.projection_ty);\n                 break;\n@@ -2264,7 +2262,7 @@ fn predicates_from_bound<'tcx>(\n         }\n         hir::GenericBound::Outlives(ref lifetime) => {\n             let region = astconv.ast_region_to_region(lifetime, None);\n-            let pred = ty::PredicateAtom::TypeOutlives(ty::OutlivesPredicate(param_ty, region))\n+            let pred = ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(param_ty, region))\n                 .to_predicate(astconv.tcx());\n             vec![(pred, lifetime.span)]\n         }"}, {"sha": "537a58328942bff36316759565ee0c9237f9cc19", "filename": "compiler/rustc_typeck/src/collect/item_bounds.rs", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Fitem_bounds.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Fitem_bounds.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fcollect%2Fitem_bounds.rs?ref=4253153db205251f72ea4493687a31e04a2a8ca0", "patch": "@@ -36,13 +36,14 @@ fn associated_type_bounds<'tcx>(\n     let trait_def_id = tcx.associated_item(assoc_item_def_id).container.id();\n     let trait_predicates = tcx.trait_explicit_predicates_and_bounds(trait_def_id.expect_local());\n \n-    let bounds_from_parent =\n-        trait_predicates.predicates.iter().copied().filter(|(pred, _)| match pred.skip_binders() {\n-            ty::PredicateAtom::Trait(tr, _) => tr.self_ty() == item_ty,\n-            ty::PredicateAtom::Projection(proj) => proj.projection_ty.self_ty() == item_ty,\n-            ty::PredicateAtom::TypeOutlives(outlives) => outlives.0 == item_ty,\n+    let bounds_from_parent = trait_predicates.predicates.iter().copied().filter(|(pred, _)| {\n+        match pred.kind().skip_binder() {\n+            ty::PredicateKind::Trait(tr, _) => tr.self_ty() == item_ty,\n+            ty::PredicateKind::Projection(proj) => proj.projection_ty.self_ty() == item_ty,\n+            ty::PredicateKind::TypeOutlives(outlives) => outlives.0 == item_ty,\n             _ => false,\n-        });\n+        }\n+    });\n \n     let all_bounds = tcx\n         .arena"}, {"sha": "95670b9bdb9838bfa9809c1217135609e83bc333", "filename": "compiler/rustc_typeck/src/constrained_generic_params.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_typeck%2Fsrc%2Fconstrained_generic_params.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_typeck%2Fsrc%2Fconstrained_generic_params.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fconstrained_generic_params.rs?ref=4253153db205251f72ea4493687a31e04a2a8ca0", "patch": "@@ -183,7 +183,8 @@ pub fn setup_constraining_predicates<'tcx>(\n         for j in i..predicates.len() {\n             // Note that we don't have to care about binders here,\n             // as the impl trait ref never contains any late-bound regions.\n-            if let ty::PredicateAtom::Projection(projection) = predicates[j].0.skip_binders() {\n+            if let ty::PredicateKind::Projection(projection) = predicates[j].0.kind().skip_binder()\n+            {\n                 // Special case: watch out for some kind of sneaky attempt\n                 // to project out an associated type defined by this very\n                 // trait."}, {"sha": "505d9a59d9c2f69036085675ae98249a21fdf795", "filename": "compiler/rustc_typeck/src/impl_wf_check/min_specialization.rs", "status": "modified", "additions": 16, "deletions": 16, "changes": 32, "blob_url": "https://github.com/rust-lang/rust/blob/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Fimpl_wf_check%2Fmin_specialization.rs?ref=4253153db205251f72ea4493687a31e04a2a8ca0", "patch": "@@ -198,7 +198,7 @@ fn unconstrained_parent_impl_substs<'tcx>(\n     // the functions in `cgp` add the constrained parameters to a list of\n     // unconstrained parameters.\n     for (predicate, _) in impl_generic_predicates.predicates.iter() {\n-        if let ty::PredicateAtom::Projection(proj) = predicate.skip_binders() {\n+        if let ty::PredicateKind::Projection(proj) = predicate.kind().skip_binder() {\n             let projection_ty = proj.projection_ty;\n             let projected_ty = proj.ty;\n \n@@ -360,13 +360,13 @@ fn check_predicates<'tcx>(\n \n fn check_specialization_on<'tcx>(tcx: TyCtxt<'tcx>, predicate: ty::Predicate<'tcx>, span: Span) {\n     debug!(\"can_specialize_on(predicate = {:?})\", predicate);\n-    match predicate.skip_binders() {\n+    match predicate.kind().skip_binder() {\n         // Global predicates are either always true or always false, so we\n         // are fine to specialize on.\n         _ if predicate.is_global() => (),\n         // We allow specializing on explicitly marked traits with no associated\n         // items.\n-        ty::PredicateAtom::Trait(pred, hir::Constness::NotConst) => {\n+        ty::PredicateKind::Trait(pred, hir::Constness::NotConst) => {\n             if !matches!(\n                 trait_predicate_kind(tcx, predicate),\n                 Some(TraitSpecializationKind::Marker)\n@@ -393,20 +393,20 @@ fn trait_predicate_kind<'tcx>(\n     tcx: TyCtxt<'tcx>,\n     predicate: ty::Predicate<'tcx>,\n ) -> Option<TraitSpecializationKind> {\n-    match predicate.skip_binders() {\n-        ty::PredicateAtom::Trait(pred, hir::Constness::NotConst) => {\n+    match predicate.kind().skip_binder() {\n+        ty::PredicateKind::Trait(pred, hir::Constness::NotConst) => {\n             Some(tcx.trait_def(pred.def_id()).specialization_kind)\n         }\n-        ty::PredicateAtom::Trait(_, hir::Constness::Const)\n-        | ty::PredicateAtom::RegionOutlives(_)\n-        | ty::PredicateAtom::TypeOutlives(_)\n-        | ty::PredicateAtom::Projection(_)\n-        | ty::PredicateAtom::WellFormed(_)\n-        | ty::PredicateAtom::Subtype(_)\n-        | ty::PredicateAtom::ObjectSafe(_)\n-        | ty::PredicateAtom::ClosureKind(..)\n-        | ty::PredicateAtom::ConstEvaluatable(..)\n-        | ty::PredicateAtom::ConstEquate(..)\n-        | ty::PredicateAtom::TypeWellFormedFromEnv(..) => None,\n+        ty::PredicateKind::Trait(_, hir::Constness::Const)\n+        | ty::PredicateKind::RegionOutlives(_)\n+        | ty::PredicateKind::TypeOutlives(_)\n+        | ty::PredicateKind::Projection(_)\n+        | ty::PredicateKind::WellFormed(_)\n+        | ty::PredicateKind::Subtype(_)\n+        | ty::PredicateKind::ObjectSafe(_)\n+        | ty::PredicateKind::ClosureKind(..)\n+        | ty::PredicateKind::ConstEvaluatable(..)\n+        | ty::PredicateKind::ConstEquate(..)\n+        | ty::PredicateKind::TypeWellFormedFromEnv(..) => None,\n     }\n }"}, {"sha": "6e5be87928d593257303455bb79acd9166b35ee7", "filename": "compiler/rustc_typeck/src/outlives/explicit.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Fexplicit.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Fexplicit.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Fexplicit.rs?ref=4253153db205251f72ea4493687a31e04a2a8ca0", "patch": "@@ -29,8 +29,8 @@ impl<'tcx> ExplicitPredicatesMap<'tcx> {\n \n             // process predicates and convert to `RequiredPredicates` entry, see below\n             for &(predicate, span) in predicates.predicates {\n-                match predicate.skip_binders() {\n-                    ty::PredicateAtom::TypeOutlives(OutlivesPredicate(ref ty, ref reg)) => {\n+                match predicate.kind().skip_binder() {\n+                    ty::PredicateKind::TypeOutlives(OutlivesPredicate(ref ty, ref reg)) => {\n                         insert_outlives_predicate(\n                             tcx,\n                             (*ty).into(),\n@@ -40,7 +40,7 @@ impl<'tcx> ExplicitPredicatesMap<'tcx> {\n                         )\n                     }\n \n-                    ty::PredicateAtom::RegionOutlives(OutlivesPredicate(ref reg1, ref reg2)) => {\n+                    ty::PredicateKind::RegionOutlives(OutlivesPredicate(ref reg1, ref reg2)) => {\n                         insert_outlives_predicate(\n                             tcx,\n                             (*reg1).into(),\n@@ -50,15 +50,15 @@ impl<'tcx> ExplicitPredicatesMap<'tcx> {\n                         )\n                     }\n \n-                    ty::PredicateAtom::Trait(..)\n-                    | ty::PredicateAtom::Projection(..)\n-                    | ty::PredicateAtom::WellFormed(..)\n-                    | ty::PredicateAtom::ObjectSafe(..)\n-                    | ty::PredicateAtom::ClosureKind(..)\n-                    | ty::PredicateAtom::Subtype(..)\n-                    | ty::PredicateAtom::ConstEvaluatable(..)\n-                    | ty::PredicateAtom::ConstEquate(..)\n-                    | ty::PredicateAtom::TypeWellFormedFromEnv(..) => (),\n+                    ty::PredicateKind::Trait(..)\n+                    | ty::PredicateKind::Projection(..)\n+                    | ty::PredicateKind::WellFormed(..)\n+                    | ty::PredicateKind::ObjectSafe(..)\n+                    | ty::PredicateKind::ClosureKind(..)\n+                    | ty::PredicateKind::Subtype(..)\n+                    | ty::PredicateKind::ConstEvaluatable(..)\n+                    | ty::PredicateKind::ConstEquate(..)\n+                    | ty::PredicateKind::TypeWellFormedFromEnv(..) => (),\n                 }\n             }\n "}, {"sha": "e94b8450bfd056ab87f8cb52e226147f91a80fd7", "filename": "compiler/rustc_typeck/src/outlives/mod.rs", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/rust-lang/rust/blob/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4253153db205251f72ea4493687a31e04a2a8ca0/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_typeck%2Fsrc%2Foutlives%2Fmod.rs?ref=4253153db205251f72ea4493687a31e04a2a8ca0", "patch": "@@ -30,13 +30,9 @@ fn inferred_outlives_of(tcx: TyCtxt<'_>, item_def_id: DefId) -> &[(ty::Predicate\n                 if tcx.has_attr(item_def_id, sym::rustc_outlives) {\n                     let mut pred: Vec<String> = predicates\n                         .iter()\n-                        .map(|(out_pred, _)| match out_pred.kind() {\n-                            ty::PredicateKind::Atom(ty::PredicateAtom::RegionOutlives(p)) => {\n-                                p.to_string()\n-                            }\n-                            ty::PredicateKind::Atom(ty::PredicateAtom::TypeOutlives(p)) => {\n-                                p.to_string()\n-                            }\n+                        .map(|(out_pred, _)| match out_pred.kind().skip_binder() {\n+                            ty::PredicateKind::RegionOutlives(p) => p.to_string(),\n+                            ty::PredicateKind::TypeOutlives(p) => p.to_string(),\n                             err => bug!(\"unexpected predicate {:?}\", err),\n                         })\n                         .collect();\n@@ -89,12 +85,12 @@ fn inferred_outlives_crate(tcx: TyCtxt<'_>, crate_num: CrateNum) -> CratePredica\n                 |(ty::OutlivesPredicate(kind1, region2), &span)| {\n                     match kind1.unpack() {\n                         GenericArgKind::Type(ty1) => Some((\n-                            ty::PredicateAtom::TypeOutlives(ty::OutlivesPredicate(ty1, region2))\n+                            ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(ty1, region2))\n                                 .to_predicate(tcx),\n                             span,\n                         )),\n                         GenericArgKind::Lifetime(region1) => Some((\n-                            ty::PredicateAtom::RegionOutlives(ty::OutlivesPredicate(\n+                            ty::PredicateKind::RegionOutlives(ty::OutlivesPredicate(\n                                 region1, region2,\n                             ))\n                             .to_predicate(tcx),"}, {"sha": "83114a72b8d5aea6add71f235f0740f9a836d1e9", "filename": "src/librustdoc/clean/auto_trait.rs", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/rust-lang/rust/blob/4253153db205251f72ea4493687a31e04a2a8ca0/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4253153db205251f72ea4493687a31e04a2a8ca0/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fauto_trait.rs?ref=4253153db205251f72ea4493687a31e04a2a8ca0", "patch": "@@ -313,12 +313,12 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n         tcx: TyCtxt<'tcx>,\n         pred: ty::Predicate<'tcx>,\n     ) -> FxHashSet<GenericParamDef> {\n-        let bound_predicate = pred.bound_atom();\n+        let bound_predicate = pred.kind();\n         let regions = match bound_predicate.skip_binder() {\n-            ty::PredicateAtom::Trait(poly_trait_pred, _) => {\n+            ty::PredicateKind::Trait(poly_trait_pred, _) => {\n                 tcx.collect_referenced_late_bound_regions(&bound_predicate.rebind(poly_trait_pred))\n             }\n-            ty::PredicateAtom::Projection(poly_proj_pred) => {\n+            ty::PredicateKind::Projection(poly_proj_pred) => {\n                 tcx.collect_referenced_late_bound_regions(&bound_predicate.rebind(poly_proj_pred))\n             }\n             _ => return FxHashSet::default(),\n@@ -463,8 +463,8 @@ impl<'a, 'tcx> AutoTraitFinder<'a, 'tcx> {\n             .iter()\n             .filter(|p| {\n                 !orig_bounds.contains(p)\n-                    || match p.skip_binders() {\n-                        ty::PredicateAtom::Trait(pred, _) => pred.def_id() == sized_trait,\n+                    || match p.kind().skip_binder() {\n+                        ty::PredicateKind::Trait(pred, _) => pred.def_id() == sized_trait,\n                         _ => false,\n                     }\n             })"}, {"sha": "3ddb2adbf0aa742eaa22b4679c0b6199d9c7f7e7", "filename": "src/librustdoc/clean/mod.rs", "status": "modified", "additions": 22, "deletions": 24, "changes": 46, "blob_url": "https://github.com/rust-lang/rust/blob/4253153db205251f72ea4493687a31e04a2a8ca0/src%2Flibrustdoc%2Fclean%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4253153db205251f72ea4493687a31e04a2a8ca0/src%2Flibrustdoc%2Fclean%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fmod.rs?ref=4253153db205251f72ea4493687a31e04a2a8ca0", "patch": "@@ -465,20 +465,20 @@ impl Clean<WherePredicate> for hir::WherePredicate<'_> {\n \n impl<'a> Clean<Option<WherePredicate>> for ty::Predicate<'a> {\n     fn clean(&self, cx: &DocContext<'_>) -> Option<WherePredicate> {\n-        let bound_predicate = self.bound_atom();\n+        let bound_predicate = self.kind();\n         match bound_predicate.skip_binder() {\n-            ty::PredicateAtom::Trait(pred, _) => Some(bound_predicate.rebind(pred).clean(cx)),\n-            ty::PredicateAtom::RegionOutlives(pred) => pred.clean(cx),\n-            ty::PredicateAtom::TypeOutlives(pred) => pred.clean(cx),\n-            ty::PredicateAtom::Projection(pred) => Some(pred.clean(cx)),\n-\n-            ty::PredicateAtom::Subtype(..)\n-            | ty::PredicateAtom::WellFormed(..)\n-            | ty::PredicateAtom::ObjectSafe(..)\n-            | ty::PredicateAtom::ClosureKind(..)\n-            | ty::PredicateAtom::ConstEvaluatable(..)\n-            | ty::PredicateAtom::ConstEquate(..)\n-            | ty::PredicateAtom::TypeWellFormedFromEnv(..) => panic!(\"not user writable\"),\n+            ty::PredicateKind::Trait(pred, _) => Some(bound_predicate.rebind(pred).clean(cx)),\n+            ty::PredicateKind::RegionOutlives(pred) => pred.clean(cx),\n+            ty::PredicateKind::TypeOutlives(pred) => pred.clean(cx),\n+            ty::PredicateKind::Projection(pred) => Some(pred.clean(cx)),\n+\n+            ty::PredicateKind::Subtype(..)\n+            | ty::PredicateKind::WellFormed(..)\n+            | ty::PredicateKind::ObjectSafe(..)\n+            | ty::PredicateKind::ClosureKind(..)\n+            | ty::PredicateKind::ConstEvaluatable(..)\n+            | ty::PredicateKind::ConstEquate(..)\n+            | ty::PredicateKind::TypeWellFormedFromEnv(..) => panic!(\"not user writable\"),\n         }\n     }\n }\n@@ -743,19 +743,19 @@ impl<'a, 'tcx> Clean<Generics> for (&'a ty::Generics, ty::GenericPredicates<'tcx\n             .flat_map(|(p, _)| {\n                 let mut projection = None;\n                 let param_idx = (|| {\n-                    let bound_p = p.bound_atom();\n+                    let bound_p = p.kind();\n                     match bound_p.skip_binder() {\n-                        ty::PredicateAtom::Trait(pred, _constness) => {\n+                        ty::PredicateKind::Trait(pred, _constness) => {\n                             if let ty::Param(param) = pred.self_ty().kind() {\n                                 return Some(param.index);\n                             }\n                         }\n-                        ty::PredicateAtom::TypeOutlives(ty::OutlivesPredicate(ty, _reg)) => {\n+                        ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(ty, _reg)) => {\n                             if let ty::Param(param) = ty.kind() {\n                                 return Some(param.index);\n                             }\n                         }\n-                        ty::PredicateAtom::Projection(p) => {\n+                        ty::PredicateKind::Projection(p) => {\n                             if let ty::Param(param) = p.projection_ty.self_ty().kind() {\n                                 projection = Some(bound_p.rebind(p));\n                                 return Some(param.index);\n@@ -1684,14 +1684,12 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                 let mut bounds = bounds\n                     .iter()\n                     .filter_map(|bound| {\n-                        // Note: The substs of opaque types can contain unbound variables,\n-                        // meaning that we have to use `ignore_quantifiers_with_unbound_vars` here.\n-                        let bound_predicate = bound.bound_atom_with_opt_escaping(cx.tcx);\n+                        let bound_predicate = bound.kind();\n                         let trait_ref = match bound_predicate.skip_binder() {\n-                            ty::PredicateAtom::Trait(tr, _constness) => {\n+                            ty::PredicateKind::Trait(tr, _constness) => {\n                                 bound_predicate.rebind(tr.trait_ref)\n                             }\n-                            ty::PredicateAtom::TypeOutlives(ty::OutlivesPredicate(_ty, reg)) => {\n+                            ty::PredicateKind::TypeOutlives(ty::OutlivesPredicate(_ty, reg)) => {\n                                 if let Some(r) = reg.clean(cx) {\n                                     regions.push(GenericBound::Outlives(r));\n                                 }\n@@ -1710,8 +1708,8 @@ impl<'tcx> Clean<Type> for Ty<'tcx> {\n                         let bounds: Vec<_> = bounds\n                             .iter()\n                             .filter_map(|bound| {\n-                                if let ty::PredicateAtom::Projection(proj) =\n-                                    bound.bound_atom_with_opt_escaping(cx.tcx).skip_binder()\n+                                if let ty::PredicateKind::Projection(proj) =\n+                                    bound.kind().skip_binder()\n                                 {\n                                     if proj.projection_ty.trait_ref(cx.tcx)\n                                         == trait_ref.skip_binder()"}, {"sha": "d4d0a8ce24c7b90677290f9d4143f9d0449a8b7a", "filename": "src/librustdoc/clean/simplify.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4253153db205251f72ea4493687a31e04a2a8ca0/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4253153db205251f72ea4493687a31e04a2a8ca0/src%2Flibrustdoc%2Fclean%2Fsimplify.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustdoc%2Fclean%2Fsimplify.rs?ref=4253153db205251f72ea4493687a31e04a2a8ca0", "patch": "@@ -129,7 +129,7 @@ fn trait_is_same_or_supertrait(cx: &DocContext<'_>, child: DefId, trait_: DefId)\n         .predicates\n         .iter()\n         .filter_map(|(pred, _)| {\n-            if let ty::PredicateAtom::Trait(pred, _) = pred.skip_binders() {\n+            if let ty::PredicateKind::Trait(pred, _) = pred.kind().skip_binder() {\n                 if pred.trait_ref.self_ty() == self_ty { Some(pred.def_id()) } else { None }\n             } else {\n                 None"}, {"sha": "92208231b17356ebe5f4303c6bb659b2147a2e8b", "filename": "src/test/ui/specialization/min_specialization/repeated_projection_type.stderr", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4253153db205251f72ea4493687a31e04a2a8ca0/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Frepeated_projection_type.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/4253153db205251f72ea4493687a31e04a2a8ca0/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Frepeated_projection_type.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fspecialization%2Fmin_specialization%2Frepeated_projection_type.stderr?ref=4253153db205251f72ea4493687a31e04a2a8ca0", "patch": "@@ -1,4 +1,4 @@\n-error: cannot specialize on `ProjectionPredicate(ProjectionTy { substs: [V], item_def_id: DefId(0:6 ~ repeated_projection_type[317d]::Id::This) }, (I,))`\n+error: cannot specialize on `Binder(ProjectionPredicate(ProjectionTy { substs: [V], item_def_id: DefId(0:6 ~ repeated_projection_type[317d]::Id::This) }, (I,)))`\n   --> $DIR/repeated_projection_type.rs:19:1\n    |\n LL | / impl<I, V: Id<This = (I,)>> X for V {"}, {"sha": "a3a38fad9a377534a7a6ad6f117d677466df4172", "filename": "src/tools/clippy/clippy_lints/src/future_not_send.rs", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/rust-lang/rust/blob/4253153db205251f72ea4493687a31e04a2a8ca0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffuture_not_send.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4253153db205251f72ea4493687a31e04a2a8ca0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffuture_not_send.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Ffuture_not_send.rs?ref=4253153db205251f72ea4493687a31e04a2a8ca0", "patch": "@@ -4,7 +4,7 @@ use rustc_hir::{Body, FnDecl, HirId};\n use rustc_infer::infer::TyCtxtInferExt;\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty::subst::Subst;\n-use rustc_middle::ty::{Opaque, PredicateAtom::Trait};\n+use rustc_middle::ty::{Opaque, PredicateKind::Trait};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::{sym, Span};\n use rustc_trait_selection::traits::error_reporting::suggestions::InferCtxtExt;\n@@ -97,7 +97,7 @@ impl<'tcx> LateLintPass<'tcx> for FutureNotSend {\n                                         &obligation,\n                                     );\n                                     if let Trait(trait_pred, _) =\n-                                        obligation.predicate.skip_binders()\n+                                        obligation.predicate.kind().skip_binder()\n                                     {\n                                         db.note(&format!(\n                                             \"`{}` doesn't implement `{}`\","}, {"sha": "f7231bba17504b1e6d443b2e2bcee2ab65480ee4", "filename": "src/tools/clippy/clippy_lints/src/methods/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4253153db205251f72ea4493687a31e04a2a8ca0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4253153db205251f72ea4493687a31e04a2a8ca0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fmethods%2Fmod.rs?ref=4253153db205251f72ea4493687a31e04a2a8ca0", "patch": "@@ -1697,7 +1697,7 @@ impl<'tcx> LateLintPass<'tcx> for Methods {\n             if let ty::Opaque(def_id, _) = *ret_ty.kind() {\n                 // one of the associated types must be Self\n                 for &(predicate, _span) in cx.tcx.explicit_item_bounds(def_id) {\n-                    if let ty::PredicateAtom::Projection(projection_predicate) = predicate.skip_binders() {\n+                    if let ty::PredicateKind::Projection(projection_predicate) = predicate.kind().skip_binder() {\n                         // walk the associated type and check for Self\n                         if contains_ty(projection_predicate.ty, self_ty) {\n                             return;"}, {"sha": "3b71f1b46e2ea1d815d0117df10f7611818555cb", "filename": "src/tools/clippy/clippy_lints/src/needless_pass_by_value.rs", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/rust-lang/rust/blob/4253153db205251f72ea4493687a31e04a2a8ca0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4253153db205251f72ea4493687a31e04a2a8ca0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Fneedless_pass_by_value.rs?ref=4253153db205251f72ea4493687a31e04a2a8ca0", "patch": "@@ -115,13 +115,11 @@ impl<'tcx> LateLintPass<'tcx> for NeedlessPassByValue {\n             .filter(|p| !p.is_global())\n             .filter_map(|obligation| {\n                 // Note that we do not want to deal with qualified predicates here.\n-                if let ty::PredicateKind::Atom(ty::PredicateAtom::Trait(pred, _)) = obligation.predicate.kind() {\n-                    if pred.def_id() == sized_trait {\n-                        return None;\n-                    }\n-                    Some(pred)\n-                } else {\n-                    None\n+                match obligation.predicate.kind().no_bound_vars() {\n+                    Some(ty::PredicateKind::Trait(pred, _)) if pred.def_id() != sized_trait => {\n+                        Some(pred)\n+                    },\n+                    _ => None,\n                 }\n             })\n             .collect::<Vec<_>>();"}, {"sha": "c6ae8b9b59837f608bdf9a531b19f6473d6abe0c", "filename": "src/tools/clippy/clippy_lints/src/unit_return_expecting_ord.rs", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/rust-lang/rust/blob/4253153db205251f72ea4493687a31e04a2a8ca0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funit_return_expecting_ord.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4253153db205251f72ea4493687a31e04a2a8ca0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funit_return_expecting_ord.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Funit_return_expecting_ord.rs?ref=4253153db205251f72ea4493687a31e04a2a8ca0", "patch": "@@ -4,7 +4,7 @@ use rustc_hir::def_id::DefId;\n use rustc_hir::{Expr, ExprKind, StmtKind};\n use rustc_lint::{LateContext, LateLintPass};\n use rustc_middle::ty;\n-use rustc_middle::ty::{GenericPredicates, PredicateAtom, ProjectionPredicate, TraitPredicate};\n+use rustc_middle::ty::{GenericPredicates, PredicateKind, ProjectionPredicate, TraitPredicate};\n use rustc_session::{declare_lint_pass, declare_tool_lint};\n use rustc_span::{BytePos, Span};\n \n@@ -42,7 +42,7 @@ fn get_trait_predicates_for_trait_id<'tcx>(\n     let mut preds = Vec::new();\n     for (pred, _) in generics.predicates {\n         if_chain! {\n-            if let PredicateAtom::Trait(poly_trait_pred, _) = pred.skip_binders();\n+            if let PredicateKind::Trait(poly_trait_pred, _) = pred.kind().skip_binder();\n             let trait_pred = cx.tcx.erase_late_bound_regions(ty::Binder::bind(poly_trait_pred));\n             if let Some(trait_def_id) = trait_id;\n             if trait_def_id == trait_pred.trait_ref.def_id;\n@@ -60,7 +60,7 @@ fn get_projection_pred<'tcx>(\n     pred: TraitPredicate<'tcx>,\n ) -> Option<ProjectionPredicate<'tcx>> {\n     generics.predicates.iter().find_map(|(proj_pred, _)| {\n-        if let ty::PredicateAtom::Projection(proj_pred) = proj_pred.skip_binders() {\n+        if let ty::PredicateKind::Projection(proj_pred) = proj_pred.kind().skip_binder() {\n             let projection_pred = cx.tcx.erase_late_bound_regions(ty::Binder::bind(proj_pred));\n             if projection_pred.projection_ty.substs == pred.trait_ref.substs {\n                 return Some(projection_pred);"}, {"sha": "4c707c4b90446ecbd804dd5c90b37b4e1118f2f7", "filename": "src/tools/clippy/clippy_lints/src/utils/mod.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/4253153db205251f72ea4493687a31e04a2a8ca0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4253153db205251f72ea4493687a31e04a2a8ca0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fmod.rs?ref=4253153db205251f72ea4493687a31e04a2a8ca0", "patch": "@@ -1470,7 +1470,7 @@ pub fn is_must_use_ty<'tcx>(cx: &LateContext<'tcx>, ty: Ty<'tcx>) -> bool {\n         ty::Tuple(ref substs) => substs.types().any(|ty| is_must_use_ty(cx, ty)),\n         ty::Opaque(ref def_id, _) => {\n             for (predicate, _) in cx.tcx.explicit_item_bounds(*def_id) {\n-                if let ty::PredicateAtom::Trait(trait_predicate, _) = predicate.skip_binders() {\n+                if let ty::PredicateKind::Trait(trait_predicate, _) = predicate.kind().skip_binder() {\n                     if must_use_attr(&cx.tcx.get_attrs(trait_predicate.trait_ref.def_id)).is_some() {\n                         return true;\n                     }"}, {"sha": "a482017afeb136339277386cd0f78be46d91c3cf", "filename": "src/tools/clippy/clippy_lints/src/utils/qualify_min_const_fn.rs", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/rust-lang/rust/blob/4253153db205251f72ea4493687a31e04a2a8ca0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fqualify_min_const_fn.rs", "raw_url": "https://github.com/rust-lang/rust/raw/4253153db205251f72ea4493687a31e04a2a8ca0/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fqualify_min_const_fn.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftools%2Fclippy%2Fclippy_lints%2Fsrc%2Futils%2Fqualify_min_const_fn.rs?ref=4253153db205251f72ea4493687a31e04a2a8ca0", "patch": "@@ -19,18 +19,18 @@ pub fn is_min_const_fn(tcx: TyCtxt<'tcx>, body: &'a Body<'tcx>) -> McfResult {\n     loop {\n         let predicates = tcx.predicates_of(current);\n         for (predicate, _) in predicates.predicates {\n-            match predicate.skip_binders() {\n-                ty::PredicateAtom::RegionOutlives(_)\n-                | ty::PredicateAtom::TypeOutlives(_)\n-                | ty::PredicateAtom::WellFormed(_)\n-                | ty::PredicateAtom::Projection(_)\n-                | ty::PredicateAtom::ConstEvaluatable(..)\n-                | ty::PredicateAtom::ConstEquate(..)\n-                | ty::PredicateAtom::TypeWellFormedFromEnv(..) => continue,\n-                ty::PredicateAtom::ObjectSafe(_) => panic!(\"object safe predicate on function: {:#?}\", predicate),\n-                ty::PredicateAtom::ClosureKind(..) => panic!(\"closure kind predicate on function: {:#?}\", predicate),\n-                ty::PredicateAtom::Subtype(_) => panic!(\"subtype predicate on function: {:#?}\", predicate),\n-                ty::PredicateAtom::Trait(pred, _) => {\n+            match predicate.kind().skip_binder() {\n+                ty::PredicateKind::RegionOutlives(_)\n+                | ty::PredicateKind::TypeOutlives(_)\n+                | ty::PredicateKind::WellFormed(_)\n+                | ty::PredicateKind::Projection(_)\n+                | ty::PredicateKind::ConstEvaluatable(..)\n+                | ty::PredicateKind::ConstEquate(..)\n+                | ty::PredicateKind::TypeWellFormedFromEnv(..) => continue,\n+                ty::PredicateKind::ObjectSafe(_) => panic!(\"object safe predicate on function: {:#?}\", predicate),\n+                ty::PredicateKind::ClosureKind(..) => panic!(\"closure kind predicate on function: {:#?}\", predicate),\n+                ty::PredicateKind::Subtype(_) => panic!(\"subtype predicate on function: {:#?}\", predicate),\n+                ty::PredicateKind::Trait(pred, _) => {\n                     if Some(pred.def_id()) == tcx.lang_items().sized_trait() {\n                         continue;\n                     }"}]}