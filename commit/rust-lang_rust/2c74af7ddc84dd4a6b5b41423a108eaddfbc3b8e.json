{"sha": "2c74af7ddc84dd4a6b5b41423a108eaddfbc3b8e", "node_id": "MDY6Q29tbWl0NzI0NzEyOjJjNzRhZjdkZGM4NGRkNGE2YjViNDE0MjNhMTA4ZWFkZGZiYzNiOGU=", "commit": {"author": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2017-12-22T16:21:45Z"}, "committer": {"name": "Aleksey Kladov", "email": "aleksey.kladov@gmail.com", "date": "2017-12-22T16:21:45Z"}, "message": "Minor tweaks", "tree": {"sha": "2b3181658cd16496ded25f8dbd3e26edc1b172f2", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/2b3181658cd16496ded25f8dbd3e26edc1b172f2"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2c74af7ddc84dd4a6b5b41423a108eaddfbc3b8e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2c74af7ddc84dd4a6b5b41423a108eaddfbc3b8e", "html_url": "https://github.com/rust-lang/rust/commit/2c74af7ddc84dd4a6b5b41423a108eaddfbc3b8e", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2c74af7ddc84dd4a6b5b41423a108eaddfbc3b8e/comments", "author": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "committer": {"login": "matklad", "id": 1711539, "node_id": "MDQ6VXNlcjE3MTE1Mzk=", "avatar_url": "https://avatars.githubusercontent.com/u/1711539?v=4", "gravatar_id": "", "url": "https://api.github.com/users/matklad", "html_url": "https://github.com/matklad", "followers_url": "https://api.github.com/users/matklad/followers", "following_url": "https://api.github.com/users/matklad/following{/other_user}", "gists_url": "https://api.github.com/users/matklad/gists{/gist_id}", "starred_url": "https://api.github.com/users/matklad/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/matklad/subscriptions", "organizations_url": "https://api.github.com/users/matklad/orgs", "repos_url": "https://api.github.com/users/matklad/repos", "events_url": "https://api.github.com/users/matklad/events{/privacy}", "received_events_url": "https://api.github.com/users/matklad/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "80c3e57f9687b4a3616f7b6ca62d120f660f1cfb", "url": "https://api.github.com/repos/rust-lang/rust/commits/80c3e57f9687b4a3616f7b6ca62d120f660f1cfb", "html_url": "https://github.com/rust-lang/rust/commit/80c3e57f9687b4a3616f7b6ca62d120f660f1cfb"}], "stats": {"total": 253, "additions": 131, "deletions": 122}, "files": [{"sha": "48d200fe76090daf4252e9b24659d824949c6abc", "filename": "rfc.md", "status": "modified", "additions": 131, "deletions": 122, "changes": 253, "blob_url": "https://github.com/rust-lang/rust/blob/2c74af7ddc84dd4a6b5b41423a108eaddfbc3b8e/rfc.md", "raw_url": "https://github.com/rust-lang/rust/raw/2c74af7ddc84dd4a6b5b41423a108eaddfbc3b8e/rfc.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/rfc.md?ref=2c74af7ddc84dd4a6b5b41423a108eaddfbc3b8e", "patch": "@@ -38,8 +38,8 @@ be `0.1.0`.\n \n ## Reusability\n \n-In theory, parsing can be a pure function, which takes a `&str` as an\n-input, and produces a `ParseTree` as an output.\n+In theory, the parser can be a pure function, which takes a `&str` as\n+an input, and produces a `ParseTree` as an output.\n \n This is great for reusability: for example, you can compile this\n function to WASM and use it for fast client-side validation of syntax\n@@ -64,13 +64,13 @@ Unfortunately, the current libsyntax is far from this ideal. For\n example, even the lexer makes use of the `FileMap` which is\n essentially a global state of the compiler which represents all know\n files. As a data point, it turned out to be easier to move `rustfmt`\n-inside of main `rustc` repository than to move libsyntax outside!\n+into the main `rustc` repository than to move libsyntax outside!\n \n \n ## IDE support\n \n There is one big difference in how IDEs and compilers typically treat\n-source code. \n+source code.\n \n In the compiler, it is convenient to transform the source\n code into Abstract Syntax Tree form, which is independent of the\n@@ -86,9 +86,8 @@ necessary to correctly handle certain code-editing actions like\n autoindentation or joining lines. IDE also must be able to produce\n partial parse trees when some input is missing or invalid.\n \n-Currently rustc uses the AST approach, which preserves the source code\n-information to some extent by storing spans in the AST.\n-\n+Currently rustc uses the AST approach, and preserves some of the\n+source code information in the form of spans in the AST.\n \n \n # Guide-level explanation\n@@ -114,8 +113,8 @@ compiler.\n ## Untyped Tree\n \n The main idea is to store the minimal amount of information in the\n-tree itself, and instead lean heavily on the source code string for\n-the actual data about identifier names, constant values etc.\n+tree itself, and instead lean heavily on the source code for the\n+actual data about identifier names, constant values etc.\n \n All nodes in the tree are of the same type and store a constant for\n the syntactic category of the element and a range in the source code.\n@@ -129,70 +128,70 @@ syntactic categories\n pub struct NodeKind(u16);\n \n pub struct File {\n-    text: String,\n-    nodes: Vec<NodeData>,\n+\ttext: String,\n+\tnodes: Vec<NodeData>,\n }\n \n struct NodeData {\n-    kind: NodeKind,\n-    range: (u32, u32),\n-    parent: Option<u32>,\n-    first_child: Option<u32>,\n-    next_sibling: Option<u32>,\n+\tkind: NodeKind,\n+\trange: (u32, u32),\n+\tparent: Option<u32>,\n+\tfirst_child: Option<u32>,\n+\tnext_sibling: Option<u32>,\n }\n \n #[derive(Clone, Copy)]\n pub struct Node<'f> {\n-    file: &'f File,\n-    idx: u32,\n+\tfile: &'f File,\n+\tidx: u32,\n }\n \n pub struct Children<'f> {\n-    next: Option<Node<'f>>,\n+\tnext: Option<Node<'f>>,\n }\n \n impl File {\n-    pub fn root<'f>(&'f self) -> Node<'f> {\n-        assert!(!self.nodes.is_empty());\n-        Node { file: self, idx: 0 }\n-    }\n+\tpub fn root<'f>(&'f self) -> Node<'f> {\n+\t\tassert!(!self.nodes.is_empty());\n+\t\tNode { file: self, idx: 0 }\n+\t}\n }\n \n impl<'f> Node<'f> {\n-    pub fn kind(&self) -> NodeKind {\n-        self.data().kind\n-    }\n-\n-    pub fn text(&self) -> &'f str {\n-        let (start, end) = self.data().range;\n-        &self.file.text[start as usize..end as usize]\n-    }\n-\n-    pub fn parent(&self) -> Option<Node<'f>> {\n-        self.as_node(self.data().parent)\n-    }\n-\n-    pub fn children(&self) -> Children<'f> {\n-        Children { next: self.as_node(self.data().first_child) }\n-    }\n-\n-    fn data(&self) -> &'f NodeData {\n-        &self.file.nodes[self.idx as usize]\n-    }\n-\n-    fn as_node(&self, idx: Option<u32>) -> Option<Node<'f>> {\n-        idx.map(|idx| Node { file: self.file, idx })\n-    }\n+\tpub fn kind(&self) -> NodeKind {\n+\t\tself.data().kind\n+\t}\n+\n+\tpub fn text(&self) -> &'f str {\n+\t\tlet (start, end) = self.data().range;\n+\t\t&self.file.text[start as usize..end as usize]\n+\t}\n+\n+\tpub fn parent(&self) -> Option<Node<'f>> {\n+\t\tself.as_node(self.data().parent)\n+\t}\n+\n+\tpub fn children(&self) -> Children<'f> {\n+\t\tChildren { next: self.as_node(self.data().first_child) }\n+\t}\n+\n+\tfn data(&self) -> &'f NodeData {\n+\t\t&self.file.nodes[self.idx as usize]\n+\t}\n+\n+\tfn as_node(&self, idx: Option<u32>) -> Option<Node<'f>> {\n+\t\tidx.map(|idx| Node { file: self.file, idx })\n+\t}\n }\n \n impl<'f> Iterator for Children<'f> {\n-    type Item = Node<'f>;\n+\ttype Item = Node<'f>;\n \n-    fn next(&mut self) -> Option<Node<'f>> {\n-        let next = self.next;\n-        self.next = next.and_then(|node| node.as_node(node.data().next_sibling));\n-        next\n-    }\n+\tfn next(&mut self) -> Option<Node<'f>> {\n+\t\tlet next = self.next;\n+\t\tself.next = next.and_then(|node| node.as_node(node.data().next_sibling));\n+\t\tnext\n+\t}\n }\n \n pub const ERROR: NodeKind = NodeKind(0);\n@@ -215,10 +214,10 @@ Here is a rust snippet and the corresponding parse tree:\n \n ```rust\n struct Foo {\n-    field1: u32,\n-    &\n-    // non-doc comment\n-    field2:\n+\tfield1: u32,\n+\t&\n+\t// non-doc comment\n+\tfield2:\n }\n ```\n \n@@ -227,30 +226,30 @@ struct Foo {\n FILE\n   STRUCT_DEF\n     STRUCT_KW\n-\tWHITESPACE\n-\tIDENT\n-\tWHITESPACE\n-\tL_CURLY\n-\tWHITESPACE\n-\tFIELD_DEF\n-\t  IDENT\n-\t  COLON\n-\t  WHITESPACE\n-\t  TYPE_REF\n-\t    IDENT\n-\tCOMMA\n-\tWHITESPACE\n-\tERROR\n-\t  AMP\n-\tWHITESPACE\n-\tFIELD_DEF\n-\t  LINE_COMMENT\n-\t  WHITESPACE\n-\t  IDENT\n-\t  COLON\n-\t  ERROR\n-\tWHITESPACE\n-\tR_CURLY\n+    WHITESPACE\n+    IDENT\n+    WHITESPACE\n+    L_CURLY\n+    WHITESPACE\n+    FIELD_DEF\n+      IDENT\n+      COLON\n+      WHITESPACE\n+      TYPE_REF\n+        IDENT\n+    COMMA\n+    WHITESPACE\n+    ERROR\n+      AMP\n+    WHITESPACE\n+    FIELD_DEF\n+      LINE_COMMENT\n+      WHITESPACE\n+      IDENT\n+      COLON\n+      ERROR\n+    WHITESPACE\n+    R_CURLY\n ```\n \n Note several features of the tree:\n@@ -259,37 +258,41 @@ Note several features of the tree:\n \n * The node for `STRUCT_DEF` contains the error element for `&`, but\n   still represents the following field correctly.\n-  \n+\n * The second field of the struct is incomplete: `FIELD_DEF` node for\n   it contains an `ERROR` element, but nevertheless has the correct\n   `NodeKind`.\n-  \n+\n * The non-documenting comment is correctly attached to the following\n   field.\n-  \n+\n \n ## Typed Tree\n-  \n+\n It's hard to work with this raw parse tree, because it is untyped:\n node containing a struct definition has the same API as the node for\n the struct field. But it's possible to add a strongly typed layer on\n-top of this raw tree, and get a zero-cost typed AST. Here is an\n-example which adds type-safe wrappers for structs and fields:\n+top of this raw tree, and get a zero-cost AST. Here is an example\n+which adds type-safe wrappers for structs and fields:\n \n ```rust\n+// generic infrastructure\n+\n pub trait AstNode<'f>: Copy + 'f {\n-    fn new(node: Node<'f>) -> Option<Self>;\n-    fn node(&self) -> Node<'f>;\n+\tfn new(node: Node<'f>) -> Option<Self>;\n+\tfn node(&self) -> Node<'f>;\n }\n \n pub fn child_of_kind<'f>(node: Node<'f>, kind: NodeKind) -> Option<Node<'f>> {\n-    node.children().find(|child| child.kind() == kind)\n+\tnode.children().find(|child| child.kind() == kind)\n }\n \n pub fn ast_children<'f, A: AstNode<'f>>(node: Node<'f>) -> Box<Iterator<Item=A> + 'f> {\n-    Box::new(node.children().filter_map(A::new))\n+\tBox::new(node.children().filter_map(A::new))\n }\n \n+// AST elements, specific to Rust\n+\n #[derive(Clone, Copy)]\n pub struct StructDef<'f>(Node<'f>);\n \n@@ -300,48 +303,51 @@ pub struct FieldDef<'f>(Node<'f>);\n pub struct TypeRef<'f>(Node<'f>);\n \n pub trait NameOwner<'f>: AstNode<'f> {\n-    fn name_ident(&self) -> Node<'f> {\n-        child_of_kind(self.node(), IDENT).unwrap()\n-    }\n+\tfn name_ident(&self) -> Node<'f> {\n+\t\tchild_of_kind(self.node(), IDENT).unwrap()\n+\t}\n \n-    fn name(&self) -> &'f str { self.name_ident().text() }\n+\tfn name(&self) -> &'f str { self.name_ident().text() }\n }\n \n \n impl<'f> AstNode<'f> for StructDef<'f> {\n-    fn new(node: Node<'f>) -> Option<Self> {\n-        if node.kind() == STRUCT_DEF { Some(StructDef(node)) } else { None }\n-    }\n-    fn node(&self) -> Node<'f> { self.0 }\n+\tfn new(node: Node<'f>) -> Option<Self> {\n+\t\tif node.kind() == STRUCT_DEF { Some(StructDef(node)) } else { None }\n+\t}\n+\tfn node(&self) -> Node<'f> { self.0 }\n }\n \n+impl<'f> NameOwner<'f> for StructDef<'f> {}\n+\n+impl<'f> StructDef<'f> {\n+\tpub fn fields(&self) -> Box<Iterator<Item=FieldDef<'f>> + 'f> {\n+\t\tast_children(self.node())\n+\t}\n+}\n+\n+\n impl<'f> AstNode<'f> for FieldDef<'f> {\n-    fn new(node: Node<'f>) -> Option<Self> {\n-        if node.kind() == FIELD_DEF { Some(FieldDef(node)) } else { None }\n-    }\n-    fn node(&self) -> Node<'f> { self.0 }\n+\tfn new(node: Node<'f>) -> Option<Self> {\n+\t\tif node.kind() == FIELD_DEF { Some(FieldDef(node)) } else { None }\n+\t}\n+\tfn node(&self) -> Node<'f> { self.0 }\n }\n \n-impl<'f> AstNode<'f> for TypeRef<'f> {\n-    fn new(node: Node<'f>) -> Option<Self> {\n-        if node.kind() == TYPE_REF { Some(TypeRef(node)) } else { None }\n-    }\n-    fn node(&self) -> Node<'f> { self.0 }\n+impl<'f> FieldDef<'f> {\n+\tpub fn type_ref(&self) -> Option<TypeRef<'f>> {\n+\t\tast_children(self.node()).next()\n+\t}\n }\n \n-impl<'f> NameOwner<'f> for StructDef<'f> {}\n impl<'f> NameOwner<'f> for FieldDef<'f> {}\n \n-impl<'f> StructDef<'f> {\n-    pub fn fields(&self) -> Box<Iterator<Item=FieldDef<'f>> + 'f> {\n-        ast_children(self.node())\n-    }\n-}\n \n-impl<'f> FieldDef<'f> {\n-    pub fn type_ref(&self) -> Option<TypeRef<'f>> {\n-        ast_children(self.node()).next()\n-    }\n+impl<'f> AstNode<'f> for TypeRef<'f> {\n+\tfn new(node: Node<'f>) -> Option<Self> {\n+\t\tif node.kind() == TYPE_REF { Some(TypeRef(node)) } else { None }\n+\t}\n+\tfn node(&self) -> Node<'f> { self.0 }\n }\n ```\n \n@@ -371,9 +377,11 @@ plan is suggested:\n * RFC discussion about the theoretical feasibility of the proposal.\n \n * Implementation of the proposal as a completely separate crates.io\n-  crate.\n-  \n-* A prototype implementation of the macro expansion on top of the new sytnax tree.\n+  crate, by refactoring existing libsyntax source code to produce a\n+  new tree.\n+\n+* A prototype implementation of the macro expansion on top of the new\n+  sytnax tree.\n \n * Additional round of discussion/RFC about merging with the mainline\n   compiler.\n@@ -390,8 +398,9 @@ plan is suggested:\n [alternatives]: #alternatives\n \n - Incrementally add more information about source code to the current AST.\n-- Move the current libsyntax to crates.io as is. \n+- Move the current libsyntax to crates.io as is.\n - Explore alternative representations for the parse tree.\n+- Use parser generator instead of hand written parser.\n \n # Unresolved questions\n [unresolved]: #unresolved-questions"}]}