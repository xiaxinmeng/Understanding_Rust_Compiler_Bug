{"sha": "2fa64d0e53c15e1920bd394500da010a4cdd057b", "node_id": "C_kwDOAAsO6NoAKDJmYTY0ZDBlNTNjMTVlMTkyMGJkMzk0NTAwZGEwMTBhNGNkZDA1N2I", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-18T03:07:26Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2022-07-18T03:07:26Z"}, "message": "Auto merge of #99137 - jackh726:wf-no-infcx, r=estebank\n\nDon't pass InferCtxt to WfPredicates\n\nSimple cleanup. Infer vars will get passed up as obligations and shallowed resolved later. This actually improves one test output.", "tree": {"sha": "ad1c97bada3d68c27d1c3db7e04108d6ed6beda0", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/ad1c97bada3d68c27d1c3db7e04108d6ed6beda0"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/2fa64d0e53c15e1920bd394500da010a4cdd057b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/2fa64d0e53c15e1920bd394500da010a4cdd057b", "html_url": "https://github.com/rust-lang/rust/commit/2fa64d0e53c15e1920bd394500da010a4cdd057b", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/2fa64d0e53c15e1920bd394500da010a4cdd057b/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "e1d9a202fc97301c4abadf707d7ee62432d02c1c", "url": "https://api.github.com/repos/rust-lang/rust/commits/e1d9a202fc97301c4abadf707d7ee62432d02c1c", "html_url": "https://github.com/rust-lang/rust/commit/e1d9a202fc97301c4abadf707d7ee62432d02c1c"}, {"sha": "a479f23f376eb3acc363ab743b3d2db40ad3f336", "url": "https://api.github.com/repos/rust-lang/rust/commits/a479f23f376eb3acc363ab743b3d2db40ad3f336", "html_url": "https://github.com/rust-lang/rust/commit/a479f23f376eb3acc363ab743b3d2db40ad3f336"}], "stats": {"total": 115, "additions": 54, "deletions": 61}, "files": [{"sha": "6e23c84219145c820e647a03ba77cfc5b773e4f1", "filename": "compiler/rustc_trait_selection/src/traits/wf.rs", "status": "modified", "additions": 46, "deletions": 58, "changes": 104, "blob_url": "https://github.com/rust-lang/rust/blob/2fa64d0e53c15e1920bd394500da010a4cdd057b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "raw_url": "https://github.com/rust-lang/rust/raw/2fa64d0e53c15e1920bd394500da010a4cdd057b/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/compiler%2Frustc_trait_selection%2Fsrc%2Ftraits%2Fwf.rs?ref=2fa64d0e53c15e1920bd394500da010a4cdd057b", "patch": "@@ -60,12 +60,19 @@ pub fn obligations<'a, 'tcx>(\n         GenericArgKind::Lifetime(..) => return Some(Vec::new()),\n     };\n \n-    let mut wf =\n-        WfPredicates { infcx, param_env, body_id, span, out: vec![], recursion_depth, item: None };\n+    let mut wf = WfPredicates {\n+        tcx: infcx.tcx,\n+        param_env,\n+        body_id,\n+        span,\n+        out: vec![],\n+        recursion_depth,\n+        item: None,\n+    };\n     wf.compute(arg);\n     debug!(\"wf::obligations({:?}, body_id={:?}) = {:?}\", arg, body_id, wf.out);\n \n-    let result = wf.normalize();\n+    let result = wf.normalize(infcx);\n     debug!(\"wf::obligations({:?}, body_id={:?}) ~~> {:?}\", arg, body_id, result);\n     Some(result)\n }\n@@ -83,7 +90,7 @@ pub fn trait_obligations<'a, 'tcx>(\n     item: &'tcx hir::Item<'tcx>,\n ) -> Vec<traits::PredicateObligation<'tcx>> {\n     let mut wf = WfPredicates {\n-        infcx,\n+        tcx: infcx.tcx,\n         param_env,\n         body_id,\n         span,\n@@ -93,7 +100,7 @@ pub fn trait_obligations<'a, 'tcx>(\n     };\n     wf.compute_trait_ref(trait_ref, Elaborate::All);\n     debug!(obligations = ?wf.out);\n-    wf.normalize()\n+    wf.normalize(infcx)\n }\n \n pub fn predicate_obligations<'a, 'tcx>(\n@@ -104,7 +111,7 @@ pub fn predicate_obligations<'a, 'tcx>(\n     span: Span,\n ) -> Vec<traits::PredicateObligation<'tcx>> {\n     let mut wf = WfPredicates {\n-        infcx,\n+        tcx: infcx.tcx,\n         param_env,\n         body_id,\n         span,\n@@ -159,11 +166,11 @@ pub fn predicate_obligations<'a, 'tcx>(\n         }\n     }\n \n-    wf.normalize()\n+    wf.normalize(infcx)\n }\n \n-struct WfPredicates<'a, 'tcx> {\n-    infcx: &'a InferCtxt<'a, 'tcx>,\n+struct WfPredicates<'tcx> {\n+    tcx: TyCtxt<'tcx>,\n     param_env: ty::ParamEnv<'tcx>,\n     body_id: hir::HirId,\n     span: Span,\n@@ -260,18 +267,17 @@ fn extend_cause_with_original_assoc_item_obligation<'tcx>(\n     }\n }\n \n-impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n+impl<'tcx> WfPredicates<'tcx> {\n     fn tcx(&self) -> TyCtxt<'tcx> {\n-        self.infcx.tcx\n+        self.tcx\n     }\n \n     fn cause(&self, code: traits::ObligationCauseCode<'tcx>) -> traits::ObligationCause<'tcx> {\n         traits::ObligationCause::new(self.span, self.body_id, code)\n     }\n \n-    fn normalize(mut self) -> Vec<traits::PredicateObligation<'tcx>> {\n+    fn normalize(self, infcx: &InferCtxt<'_, 'tcx>) -> Vec<traits::PredicateObligation<'tcx>> {\n         let cause = self.cause(traits::WellFormed(None));\n-        let infcx = &mut self.infcx;\n         let param_env = self.param_env;\n         let mut obligations = Vec::with_capacity(self.out.len());\n         for mut obligation in self.out {\n@@ -296,7 +302,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n \n     /// Pushes the obligations required for `trait_ref` to be WF into `self.out`.\n     fn compute_trait_ref(&mut self, trait_ref: &ty::TraitRef<'tcx>, elaborate: Elaborate) {\n-        let tcx = self.infcx.tcx;\n+        let tcx = self.tcx;\n         let obligations = self.nominal_obligations(trait_ref.def_id, trait_ref.substs);\n \n         debug!(\"compute_trait_ref obligations {:?}\", obligations);\n@@ -410,14 +416,14 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n         if !subty.has_escaping_bound_vars() {\n             let cause = self.cause(cause);\n             let trait_ref = ty::TraitRef {\n-                def_id: self.infcx.tcx.require_lang_item(LangItem::Sized, None),\n-                substs: self.infcx.tcx.mk_substs_trait(subty, &[]),\n+                def_id: self.tcx.require_lang_item(LangItem::Sized, None),\n+                substs: self.tcx.mk_substs_trait(subty, &[]),\n             };\n             self.out.push(traits::Obligation::with_depth(\n                 cause,\n                 self.recursion_depth,\n                 self.param_env,\n-                ty::Binder::dummy(trait_ref).without_const().to_predicate(self.infcx.tcx),\n+                ty::Binder::dummy(trait_ref).without_const().to_predicate(self.tcx),\n             ));\n         }\n     }\n@@ -452,26 +458,16 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                                 predicate,\n                             ));\n                         }\n-                        ty::ConstKind::Infer(infer) => {\n-                            let resolved = self.infcx.shallow_resolve(infer);\n-                            // the `InferConst` changed, meaning that we made progress.\n-                            if resolved != infer {\n-                                let cause = self.cause(traits::WellFormed(None));\n-\n-                                let resolved_constant = self.infcx.tcx.mk_const(ty::ConstS {\n-                                    kind: ty::ConstKind::Infer(resolved),\n-                                    ty: constant.ty(),\n-                                });\n-                                self.out.push(traits::Obligation::with_depth(\n-                                    cause,\n-                                    self.recursion_depth,\n-                                    self.param_env,\n-                                    ty::Binder::dummy(ty::PredicateKind::WellFormed(\n-                                        resolved_constant.into(),\n-                                    ))\n+                        ty::ConstKind::Infer(_) => {\n+                            let cause = self.cause(traits::WellFormed(None));\n+\n+                            self.out.push(traits::Obligation::with_depth(\n+                                cause,\n+                                self.recursion_depth,\n+                                self.param_env,\n+                                ty::Binder::dummy(ty::PredicateKind::WellFormed(constant.into()))\n                                     .to_predicate(self.tcx()),\n-                                ));\n-                            }\n+                            ));\n                         }\n                         ty::ConstKind::Error(_)\n                         | ty::ConstKind::Param(_)\n@@ -627,7 +623,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                     // of whatever returned this exact `impl Trait`.\n \n                     // for named opaque `impl Trait` types we still need to check them\n-                    if ty::is_impl_trait_defn(self.infcx.tcx, did).is_none() {\n+                    if ty::is_impl_trait_defn(self.tcx, did).is_none() {\n                         let obligations = self.nominal_obligations(did, substs);\n                         self.out.extend(obligations);\n                     }\n@@ -675,22 +671,14 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                 // See also the comment on `fn obligations`, describing \"livelock\"\n                 // prevention, which happens before this can be reached.\n                 ty::Infer(_) => {\n-                    let ty = self.infcx.shallow_resolve(ty);\n-                    if let ty::Infer(ty::TyVar(_)) = ty.kind() {\n-                        // Not yet resolved, but we've made progress.\n-                        let cause = self.cause(traits::WellFormed(None));\n-                        self.out.push(traits::Obligation::with_depth(\n-                            cause,\n-                            self.recursion_depth,\n-                            param_env,\n-                            ty::Binder::dummy(ty::PredicateKind::WellFormed(ty.into()))\n-                                .to_predicate(self.tcx()),\n-                        ));\n-                    } else {\n-                        // Yes, resolved, proceed with the result.\n-                        // FIXME(eddyb) add the type to `walker` instead of recursing.\n-                        self.compute(ty.into());\n-                    }\n+                    let cause = self.cause(traits::WellFormed(None));\n+                    self.out.push(traits::Obligation::with_depth(\n+                        cause,\n+                        self.recursion_depth,\n+                        param_env,\n+                        ty::Binder::dummy(ty::PredicateKind::WellFormed(ty.into()))\n+                            .to_predicate(self.tcx()),\n+                    ));\n                 }\n             }\n         }\n@@ -701,15 +689,15 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n         def_id: DefId,\n         substs: SubstsRef<'tcx>,\n     ) -> Vec<traits::PredicateObligation<'tcx>> {\n-        let predicates = self.infcx.tcx.predicates_of(def_id);\n+        let predicates = self.tcx.predicates_of(def_id);\n         let mut origins = vec![def_id; predicates.predicates.len()];\n         let mut head = predicates;\n         while let Some(parent) = head.parent {\n-            head = self.infcx.tcx.predicates_of(parent);\n+            head = self.tcx.predicates_of(parent);\n             origins.extend(iter::repeat(parent).take(head.predicates.len()));\n         }\n \n-        let predicates = predicates.instantiate(self.infcx.tcx, substs);\n+        let predicates = predicates.instantiate(self.tcx, substs);\n         debug_assert_eq!(predicates.predicates.len(), origins.len());\n \n         iter::zip(iter::zip(predicates.predicates, predicates.spans), origins.into_iter().rev())\n@@ -764,7 +752,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n         // Note: in fact we only permit builtin traits, not `Bar<'d>`, I\n         // am looking forward to the future here.\n         if !data.has_escaping_bound_vars() && !region.has_escaping_bound_vars() {\n-            let implicit_bounds = object_region_bounds(self.infcx.tcx, data);\n+            let implicit_bounds = object_region_bounds(self.tcx, data);\n \n             let explicit_bound = region;\n \n@@ -777,7 +765,7 @@ impl<'a, 'tcx> WfPredicates<'a, 'tcx> {\n                     cause,\n                     self.recursion_depth,\n                     self.param_env,\n-                    outlives.to_predicate(self.infcx.tcx),\n+                    outlives.to_predicate(self.tcx),\n                 ));\n             }\n         }"}, {"sha": "fd905392a21ad230f0240541764287fbf99ca923", "filename": "src/test/ui/issues/issue-98299.stderr", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/2fa64d0e53c15e1920bd394500da010a4cdd057b/src%2Ftest%2Fui%2Fissues%2Fissue-98299.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/2fa64d0e53c15e1920bd394500da010a4cdd057b/src%2Ftest%2Fui%2Fissues%2Fissue-98299.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-98299.stderr?ref=2fa64d0e53c15e1920bd394500da010a4cdd057b", "patch": "@@ -1,8 +1,13 @@\n-error[E0282]: type annotations needed\n-  --> $DIR/issue-98299.rs:4:5\n+error[E0282]: type annotations needed for `SmallCString<N>`\n+  --> $DIR/issue-98299.rs:4:36\n    |\n LL |     SmallCString::try_from(p).map(|cstr| cstr);\n-   |     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^ cannot infer type for enum `Result<SmallCString<{_: usize}>, ()>`\n+   |                                    ^^^^\n+   |\n+help: consider giving this closure parameter an explicit type, where the the value of const parameter `N` is specified\n+   |\n+LL |     SmallCString::try_from(p).map(|cstr: SmallCString<N>| cstr);\n+   |                                        +++++++++++++++++\n \n error: aborting due to previous error\n "}]}