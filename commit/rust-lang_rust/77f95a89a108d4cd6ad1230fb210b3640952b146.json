{"sha": "77f95a89a108d4cd6ad1230fb210b3640952b146", "node_id": "MDY6Q29tbWl0NzI0NzEyOjc3Zjk1YTg5YTEwOGQ0Y2Q2YWQxMjMwZmIyMTBiMzY0MDk1MmIxNDY=", "commit": {"author": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-29T07:52:06Z"}, "committer": {"name": "bors", "email": "bors@rust-lang.org", "date": "2020-05-29T07:52:06Z"}, "message": "Auto merge of #72727 - JohnTitor:rollup-nni16m2, r=JohnTitor\n\nRollup of 11 pull requests\n\nSuccessful merges:\n\n - #71633 (Impl Error for Infallible)\n - #71843 (Tweak and stabilize AtomicN::fetch_update)\n - #72288 (Stabilization of weak-into-raw)\n - #72324 (Stabilize AtomicN::fetch_min and AtomicN::fetch_max)\n - #72452 (Clarified the documentation for Formatter::precision)\n - #72495 (Improve E0601 explanation)\n - #72534 (Improve missing `@` in slice binding pattern diagnostics)\n - #72547 (Added a codegen test for a recent optimization for overflow-checks=on)\n - #72711 (remove redundant `mk_const`)\n - #72713 (Whitelist #[allow_internal_unstable])\n - #72720 (Clarify the documentation of `take`)\n\nFailed merges:\n\nr? @ghost", "tree": {"sha": "52be6fd4f91f284178f2d81208b27cd6780602d7", "url": "https://api.github.com/repos/rust-lang/rust/git/trees/52be6fd4f91f284178f2d81208b27cd6780602d7"}, "url": "https://api.github.com/repos/rust-lang/rust/git/commits/77f95a89a108d4cd6ad1230fb210b3640952b146", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/rust-lang/rust/commits/77f95a89a108d4cd6ad1230fb210b3640952b146", "html_url": "https://github.com/rust-lang/rust/commit/77f95a89a108d4cd6ad1230fb210b3640952b146", "comments_url": "https://api.github.com/repos/rust-lang/rust/commits/77f95a89a108d4cd6ad1230fb210b3640952b146/comments", "author": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "committer": {"login": "bors", "id": 3372342, "node_id": "MDQ6VXNlcjMzNzIzNDI=", "avatar_url": "https://avatars.githubusercontent.com/u/3372342?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors", "html_url": "https://github.com/bors", "followers_url": "https://api.github.com/users/bors/followers", "following_url": "https://api.github.com/users/bors/following{/other_user}", "gists_url": "https://api.github.com/users/bors/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors/subscriptions", "organizations_url": "https://api.github.com/users/bors/orgs", "repos_url": "https://api.github.com/users/bors/repos", "events_url": "https://api.github.com/users/bors/events{/privacy}", "received_events_url": "https://api.github.com/users/bors/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9cd3f1c54956e5b306567161d1965277c9ef8455", "url": "https://api.github.com/repos/rust-lang/rust/commits/9cd3f1c54956e5b306567161d1965277c9ef8455", "html_url": "https://github.com/rust-lang/rust/commit/9cd3f1c54956e5b306567161d1965277c9ef8455"}, {"sha": "fb506af138c40ebc3a62ada931259d60a74a6266", "url": "https://api.github.com/repos/rust-lang/rust/commits/fb506af138c40ebc3a62ada931259d60a74a6266", "html_url": "https://github.com/rust-lang/rust/commit/fb506af138c40ebc3a62ada931259d60a74a6266"}], "stats": {"total": 169, "additions": 112, "deletions": 57}, "files": [{"sha": "4edbc2ff3ac9b62dd7988e05e333af2fd72aad12", "filename": "src/liballoc/rc.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/77f95a89a108d4cd6ad1230fb210b3640952b146/src%2Fliballoc%2Frc.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77f95a89a108d4cd6ad1230fb210b3640952b146/src%2Fliballoc%2Frc.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Frc.rs?ref=77f95a89a108d4cd6ad1230fb210b3640952b146", "patch": "@@ -580,8 +580,6 @@ impl<T: ?Sized> Rc<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(weak_into_raw)]\n-    ///\n     /// use std::rc::Rc;\n     ///\n     /// let x = Rc::new(\"hello\".to_owned());\n@@ -590,7 +588,7 @@ impl<T: ?Sized> Rc<T> {\n     /// assert_eq!(x_ptr, Rc::as_ptr(&y));\n     /// assert_eq!(unsafe { &*x_ptr }, \"hello\");\n     /// ```\n-    #[unstable(feature = \"weak_into_raw\", issue = \"60728\")]\n+    #[stable(feature = \"weak_into_raw\", since = \"1.45.0\")]\n     pub fn as_ptr(this: &Self) -> *const T {\n         let ptr: *mut RcBox<T> = NonNull::as_ptr(this.ptr);\n         let fake_ptr = ptr as *mut T;\n@@ -1681,8 +1679,6 @@ impl<T> Weak<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(weak_into_raw)]\n-    ///\n     /// use std::rc::Rc;\n     /// use std::ptr;\n     ///\n@@ -1700,7 +1696,7 @@ impl<T> Weak<T> {\n     /// ```\n     ///\n     /// [`null`]: ../../std/ptr/fn.null.html\n-    #[unstable(feature = \"weak_into_raw\", issue = \"60728\")]\n+    #[stable(feature = \"weak_into_raw\", since = \"1.45.0\")]\n     pub fn as_ptr(&self) -> *const T {\n         let offset = data_offset_sized::<T>();\n         let ptr = self.ptr.cast::<u8>().as_ptr().wrapping_offset(offset);\n@@ -1718,8 +1714,6 @@ impl<T> Weak<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(weak_into_raw)]\n-    ///\n     /// use std::rc::{Rc, Weak};\n     ///\n     /// let strong = Rc::new(\"hello\".to_owned());\n@@ -1735,7 +1729,7 @@ impl<T> Weak<T> {\n     ///\n     /// [`from_raw`]: struct.Weak.html#method.from_raw\n     /// [`as_ptr`]: struct.Weak.html#method.as_ptr\n-    #[unstable(feature = \"weak_into_raw\", issue = \"60728\")]\n+    #[stable(feature = \"weak_into_raw\", since = \"1.45.0\")]\n     pub fn into_raw(self) -> *const T {\n         let result = self.as_ptr();\n         mem::forget(self);\n@@ -1762,8 +1756,6 @@ impl<T> Weak<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(weak_into_raw)]\n-    ///\n     /// use std::rc::{Rc, Weak};\n     ///\n     /// let strong = Rc::new(\"hello\".to_owned());\n@@ -1788,7 +1780,7 @@ impl<T> Weak<T> {\n     /// [`Weak`]: struct.Weak.html\n     /// [`new`]: struct.Weak.html#method.new\n     /// [`forget`]: ../../std/mem/fn.forget.html\n-    #[unstable(feature = \"weak_into_raw\", issue = \"60728\")]\n+    #[stable(feature = \"weak_into_raw\", since = \"1.45.0\")]\n     pub unsafe fn from_raw(ptr: *const T) -> Self {\n         if ptr.is_null() {\n             Self::new()"}, {"sha": "5de3cac9d5382a249cddb5a9bb8dc835e0e0d6a7", "filename": "src/liballoc/sync.rs", "status": "modified", "additions": 4, "deletions": 12, "changes": 16, "blob_url": "https://github.com/rust-lang/rust/blob/77f95a89a108d4cd6ad1230fb210b3640952b146/src%2Fliballoc%2Fsync.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77f95a89a108d4cd6ad1230fb210b3640952b146/src%2Fliballoc%2Fsync.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Fliballoc%2Fsync.rs?ref=77f95a89a108d4cd6ad1230fb210b3640952b146", "patch": "@@ -579,8 +579,6 @@ impl<T: ?Sized> Arc<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(weak_into_raw)]\n-    ///\n     /// use std::sync::Arc;\n     ///\n     /// let x = Arc::new(\"hello\".to_owned());\n@@ -589,7 +587,7 @@ impl<T: ?Sized> Arc<T> {\n     /// assert_eq!(x_ptr, Arc::as_ptr(&y));\n     /// assert_eq!(unsafe { &*x_ptr }, \"hello\");\n     /// ```\n-    #[unstable(feature = \"weak_into_raw\", issue = \"60728\")]\n+    #[stable(feature = \"weak_into_raw\", since = \"1.45.0\")]\n     pub fn as_ptr(this: &Self) -> *const T {\n         let ptr: *mut ArcInner<T> = NonNull::as_ptr(this.ptr);\n         let fake_ptr = ptr as *mut T;\n@@ -1449,8 +1447,6 @@ impl<T> Weak<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(weak_into_raw)]\n-    ///\n     /// use std::sync::Arc;\n     /// use std::ptr;\n     ///\n@@ -1468,7 +1464,7 @@ impl<T> Weak<T> {\n     /// ```\n     ///\n     /// [`null`]: ../../std/ptr/fn.null.html\n-    #[unstable(feature = \"weak_into_raw\", issue = \"60728\")]\n+    #[stable(feature = \"weak_into_raw\", since = \"1.45.0\")]\n     pub fn as_ptr(&self) -> *const T {\n         let offset = data_offset_sized::<T>();\n         let ptr = self.ptr.cast::<u8>().as_ptr().wrapping_offset(offset);\n@@ -1486,8 +1482,6 @@ impl<T> Weak<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(weak_into_raw)]\n-    ///\n     /// use std::sync::{Arc, Weak};\n     ///\n     /// let strong = Arc::new(\"hello\".to_owned());\n@@ -1503,7 +1497,7 @@ impl<T> Weak<T> {\n     ///\n     /// [`from_raw`]: struct.Weak.html#method.from_raw\n     /// [`as_ptr`]: struct.Weak.html#method.as_ptr\n-    #[unstable(feature = \"weak_into_raw\", issue = \"60728\")]\n+    #[stable(feature = \"weak_into_raw\", since = \"1.45.0\")]\n     pub fn into_raw(self) -> *const T {\n         let result = self.as_ptr();\n         mem::forget(self);\n@@ -1531,8 +1525,6 @@ impl<T> Weak<T> {\n     /// # Examples\n     ///\n     /// ```\n-    /// #![feature(weak_into_raw)]\n-    ///\n     /// use std::sync::{Arc, Weak};\n     ///\n     /// let strong = Arc::new(\"hello\".to_owned());\n@@ -1557,7 +1549,7 @@ impl<T> Weak<T> {\n     /// [`Weak`]: struct.Weak.html\n     /// [`Arc`]: struct.Arc.html\n     /// [`forget`]: ../../std/mem/fn.forget.html\n-    #[unstable(feature = \"weak_into_raw\", issue = \"60728\")]\n+    #[stable(feature = \"weak_into_raw\", since = \"1.45.0\")]\n     pub unsafe fn from_raw(ptr: *const T) -> Self {\n         if ptr.is_null() {\n             Self::new()"}, {"sha": "9c5dbb5e6f3567fd567be94c44d00038e638d58b", "filename": "src/libcore/fmt/mod.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/77f95a89a108d4cd6ad1230fb210b3640952b146/src%2Flibcore%2Ffmt%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77f95a89a108d4cd6ad1230fb210b3640952b146/src%2Flibcore%2Ffmt%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Ffmt%2Fmod.rs?ref=77f95a89a108d4cd6ad1230fb210b3640952b146", "patch": "@@ -1618,7 +1618,8 @@ impl<'a> Formatter<'a> {\n         self.width\n     }\n \n-    /// Optionally specified precision for numeric types.\n+    /// Optionally specified precision for numeric types. Alternatively, the\n+    /// maximum width for string types.\n     ///\n     /// # Examples\n     ///"}, {"sha": "7f081f732fd5817b1ad2c4027b1a81aa0ae16ab2", "filename": "src/libcore/iter/traits/iterator.rs", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/rust-lang/rust/blob/77f95a89a108d4cd6ad1230fb210b3640952b146/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77f95a89a108d4cd6ad1230fb210b3640952b146/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fiter%2Ftraits%2Fiterator.rs?ref=77f95a89a108d4cd6ad1230fb210b3640952b146", "patch": "@@ -1180,6 +1180,17 @@ pub trait Iterator {\n     /// assert_eq!(iter.next(), Some(2));\n     /// assert_eq!(iter.next(), None);\n     /// ```\n+    ///\n+    /// If less than `n` elements are available,\n+    /// `take` will limit itself to the size of the underlying iterator:\n+    ///\n+    /// ```\n+    /// let v = vec![1, 2];\n+    /// let mut iter = v.into_iter().take(5);\n+    /// assert_eq!(iter.next(), Some(1));\n+    /// assert_eq!(iter.next(), Some(2));\n+    /// assert_eq!(iter.next(), None);\n+    /// ```\n     #[inline]\n     #[stable(feature = \"rust1\", since = \"1.0.0\")]\n     fn take(self, n: usize) -> Take<Self>"}, {"sha": "449aac85bc7731fe75aa4fa1f404550720299e0c", "filename": "src/libcore/sync/atomic.rs", "status": "modified", "additions": 13, "deletions": 25, "changes": 38, "blob_url": "https://github.com/rust-lang/rust/blob/77f95a89a108d4cd6ad1230fb210b3640952b146/src%2Flibcore%2Fsync%2Fatomic.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77f95a89a108d4cd6ad1230fb210b3640952b146/src%2Flibcore%2Fsync%2Fatomic.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibcore%2Fsync%2Fatomic.rs?ref=77f95a89a108d4cd6ad1230fb210b3640952b146", "patch": "@@ -1807,13 +1807,12 @@ new value. Returns a `Result` of `Ok(previous_value)` if the function returned `\n \n Note: This may call the function multiple times if the value has been changed from other threads in\n the meantime, as long as the function returns `Some(_)`, but the function will have been applied\n-but once to the stored value.\n+only once to the stored value.\n \n-`fetch_update` takes two [`Ordering`] arguments to describe the memory\n-ordering of this operation. The first describes the required ordering for loads\n-and failed updates while the second describes the required ordering when the\n-operation finally succeeds. Beware that this is different from the two\n-modes in [`compare_exchange`]!\n+`fetch_update` takes two [`Ordering`] arguments to describe the memory ordering of this operation.\n+The first describes the required ordering for when the operation finally succeeds while the second\n+describes the required ordering for loads. These correspond to the success and failure orderings of\n+[`compare_exchange`] respectively.\n \n Using [`Acquire`] as success ordering makes the store part\n of this operation [`Relaxed`], and using [`Release`] makes the final successful load\n@@ -1831,24 +1830,21 @@ and must be equivalent to or weaker than the success ordering.\n # Examples\n \n ```rust\n-#![feature(no_more_cas)]\n \", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n \n let x = \", stringify!($atomic_type), \"::new(7);\n-assert_eq!(x.fetch_update(|_| None, Ordering::SeqCst, Ordering::SeqCst), Err(7));\n-assert_eq!(x.fetch_update(|x| Some(x + 1), Ordering::SeqCst, Ordering::SeqCst), Ok(7));\n-assert_eq!(x.fetch_update(|x| Some(x + 1), Ordering::SeqCst, Ordering::SeqCst), Ok(8));\n+assert_eq!(x.fetch_update(Ordering::SeqCst, Ordering::SeqCst, |_| None), Err(7));\n+assert_eq!(x.fetch_update(Ordering::SeqCst, Ordering::SeqCst, |x| Some(x + 1)), Ok(7));\n+assert_eq!(x.fetch_update(Ordering::SeqCst, Ordering::SeqCst, |x| Some(x + 1)), Ok(8));\n assert_eq!(x.load(Ordering::SeqCst), 9);\n ```\"),\n                 #[inline]\n-                #[unstable(feature = \"no_more_cas\",\n-                       reason = \"no more CAS loops in user code\",\n-                       issue = \"48655\")]\n+                #[stable(feature = \"no_more_cas\", since = \"1.45.0\")]\n                 #[$cfg_cas]\n                 pub fn fetch_update<F>(&self,\n-                                       mut f: F,\n+                                       set_order: Ordering,\n                                        fetch_order: Ordering,\n-                                       set_order: Ordering) -> Result<$int_type, $int_type>\n+                                       mut f: F) -> Result<$int_type, $int_type>\n                 where F: FnMut($int_type) -> Option<$int_type> {\n                     let mut prev = self.load(fetch_order);\n                     while let Some(next) = f(prev) {\n@@ -1882,7 +1878,6 @@ using [`Release`] makes the load part [`Relaxed`].\n # Examples\n \n ```\n-#![feature(atomic_min_max)]\n \", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n \n let foo = \", stringify!($atomic_type), \"::new(23);\n@@ -1893,7 +1888,6 @@ assert_eq!(foo.load(Ordering::SeqCst), 42);\n If you want to obtain the maximum value in one step, you can use the following:\n \n ```\n-#![feature(atomic_min_max)]\n \", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n \n let foo = \", stringify!($atomic_type), \"::new(23);\n@@ -1902,9 +1896,7 @@ let max_foo = foo.fetch_max(bar, Ordering::SeqCst).max(bar);\n assert!(max_foo == 42);\n ```\"),\n                 #[inline]\n-                #[unstable(feature = \"atomic_min_max\",\n-                       reason = \"easier and faster min/max than writing manual CAS loop\",\n-                       issue = \"48655\")]\n+                #[stable(feature = \"atomic_min_max\", since = \"1.45.0\")]\n                 #[$cfg_cas]\n                 pub fn fetch_max(&self, val: $int_type, order: Ordering) -> $int_type {\n                     // SAFETY: data races are prevented by atomic intrinsics.\n@@ -1933,7 +1925,6 @@ using [`Release`] makes the load part [`Relaxed`].\n # Examples\n \n ```\n-#![feature(atomic_min_max)]\n \", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n \n let foo = \", stringify!($atomic_type), \"::new(23);\n@@ -1946,7 +1937,6 @@ assert_eq!(foo.load(Ordering::Relaxed), 22);\n If you want to obtain the minimum value in one step, you can use the following:\n \n ```\n-#![feature(atomic_min_max)]\n \", $extra_feature, \"use std::sync::atomic::{\", stringify!($atomic_type), \", Ordering};\n \n let foo = \", stringify!($atomic_type), \"::new(23);\n@@ -1955,9 +1945,7 @@ let min_foo = foo.fetch_min(bar, Ordering::SeqCst).min(bar);\n assert_eq!(min_foo, 12);\n ```\"),\n                 #[inline]\n-                #[unstable(feature = \"atomic_min_max\",\n-                       reason = \"easier and faster min/max than writing manual CAS loop\",\n-                       issue = \"48655\")]\n+                #[stable(feature = \"atomic_min_max\", since = \"1.45.0\")]\n                 #[$cfg_cas]\n                 pub fn fetch_min(&self, val: $int_type, order: Ordering) -> $int_type {\n                     // SAFETY: data races are prevented by atomic intrinsics."}, {"sha": "7194b7971d38f168a374d48bf4d2e231a0102738", "filename": "src/librustc_error_codes/error_codes/E0601.md", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/77f95a89a108d4cd6ad1230fb210b3640952b146/src%2Flibrustc_error_codes%2Ferror_codes%2FE0601.md", "raw_url": "https://github.com/rust-lang/rust/raw/77f95a89a108d4cd6ad1230fb210b3640952b146/src%2Flibrustc_error_codes%2Ferror_codes%2FE0601.md", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_error_codes%2Ferror_codes%2FE0601.md?ref=77f95a89a108d4cd6ad1230fb210b3640952b146", "patch": "@@ -1,5 +1,6 @@\n-No `main` function was found in a binary crate. To fix this error, add a\n-`main` function. For example:\n+No `main` function was found in a binary crate.\n+\n+To fix this error, add a `main` function:\n \n ```\n fn main() {"}, {"sha": "524a35797102917acd4a601019fd2718f3bbc824", "filename": "src/librustc_feature/builtin_attrs.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/77f95a89a108d4cd6ad1230fb210b3640952b146/src%2Flibrustc_feature%2Fbuiltin_attrs.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77f95a89a108d4cd6ad1230fb210b3640952b146/src%2Flibrustc_feature%2Fbuiltin_attrs.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_feature%2Fbuiltin_attrs.rs?ref=77f95a89a108d4cd6ad1230fb210b3640952b146", "patch": "@@ -366,7 +366,7 @@ pub const BUILTIN_ATTRIBUTES: &[BuiltinAttribute] = &[\n     // FIXME(#14407)\n     ungated!(rustc_const_stable, Whitelisted, template!(List: r#\"feature = \"name\"\"#)),\n     gated!(\n-        allow_internal_unstable, Normal, template!(Word, List: \"feat1, feat2, ...\"),\n+        allow_internal_unstable, Whitelisted, template!(Word, List: \"feat1, feat2, ...\"),\n         \"allow_internal_unstable side-steps feature gating and stability checks\",\n     ),\n     gated!("}, {"sha": "92000e6411354e8ddfa7bc311ae16c8084b0c6be", "filename": "src/librustc_mir/transform/const_prop.rs", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/rust-lang/rust/blob/77f95a89a108d4cd6ad1230fb210b3640952b146/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77f95a89a108d4cd6ad1230fb210b3640952b146/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_mir%2Ftransform%2Fconst_prop.rs?ref=77f95a89a108d4cd6ad1230fb210b3640952b146", "patch": "@@ -606,7 +606,7 @@ impl<'mir, 'tcx> ConstPropagator<'mir, 'tcx> {\n         Operand::Constant(Box::new(Constant {\n             span,\n             user_ty: None,\n-            literal: self.tcx.mk_const(*ty::Const::from_scalar(self.tcx, scalar, ty)),\n+            literal: ty::Const::from_scalar(self.tcx, scalar, ty),\n         }))\n     }\n "}, {"sha": "c00b60848293346a3cd31cc48b09eb10c3385da7", "filename": "src/librustc_parse/parser/mod.rs", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/rust-lang/rust/blob/77f95a89a108d4cd6ad1230fb210b3640952b146/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77f95a89a108d4cd6ad1230fb210b3640952b146/src%2Flibrustc_parse%2Fparser%2Fmod.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibrustc_parse%2Fparser%2Fmod.rs?ref=77f95a89a108d4cd6ad1230fb210b3640952b146", "patch": "@@ -672,6 +672,26 @@ impl<'a> Parser<'a> {\n                                 }\n                             }\n \n+                            // If this was a missing `@` in a binding pattern\n+                            // bail with a suggestion\n+                            // https://github.com/rust-lang/rust/issues/72373\n+                            if self.prev_token.is_ident() && &self.token.kind == &token::DotDot {\n+                                let msg = format!(\n+                                    \"if you meant to bind the contents of \\\n+                                    the rest of the array pattern into `{}`, use `@`\",\n+                                    pprust::token_to_string(&self.prev_token)\n+                                );\n+                                expect_err\n+                                    .span_suggestion_verbose(\n+                                        self.prev_token.span.shrink_to_hi().until(self.token.span),\n+                                        &msg,\n+                                        \" @ \".to_string(),\n+                                        Applicability::MaybeIncorrect,\n+                                    )\n+                                    .emit();\n+                                break;\n+                            }\n+\n                             // Attempt to keep parsing if it was an omitted separator.\n                             match f(self) {\n                                 Ok(t) => {"}, {"sha": "3b4cb859dd425a2469a3acd643848d714552ab15", "filename": "src/libstd/error.rs", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/rust-lang/rust/blob/77f95a89a108d4cd6ad1230fb210b3640952b146/src%2Flibstd%2Ferror.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77f95a89a108d4cd6ad1230fb210b3640952b146/src%2Flibstd%2Ferror.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Flibstd%2Ferror.rs?ref=77f95a89a108d4cd6ad1230fb210b3640952b146", "patch": "@@ -14,6 +14,7 @@\n // reconsider what crate these items belong in.\n \n use core::array;\n+use core::convert::Infallible;\n \n use crate::alloc::{AllocErr, LayoutErr};\n use crate::any::TypeId;\n@@ -474,7 +475,7 @@ impl Error for string::FromUtf16Error {\n }\n \n #[stable(feature = \"str_parse_error2\", since = \"1.8.0\")]\n-impl Error for string::ParseError {\n+impl Error for Infallible {\n     fn description(&self) -> &str {\n         match *self {}\n     }"}, {"sha": "183de56db9685bb6f4cf1eaf98a8d3640d924c67", "filename": "src/test/codegen/integer-overflow.rs", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/rust-lang/rust/blob/77f95a89a108d4cd6ad1230fb210b3640952b146/src%2Ftest%2Fcodegen%2Finteger-overflow.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77f95a89a108d4cd6ad1230fb210b3640952b146/src%2Ftest%2Fcodegen%2Finteger-overflow.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fcodegen%2Finteger-overflow.rs?ref=77f95a89a108d4cd6ad1230fb210b3640952b146", "patch": "@@ -0,0 +1,26 @@\n+// no-system-llvm\n+// compile-flags: -O -C overflow-checks=on\n+\n+#![crate_type = \"lib\"]\n+\n+\n+pub struct S1<'a> {\n+    data: &'a [u8],\n+    position: usize,\n+}\n+\n+// CHECK-LABEL: @slice_no_index_order\n+#[no_mangle]\n+pub fn slice_no_index_order<'a>(s: &'a mut S1, n: usize) -> &'a [u8] {\n+    // CHECK-NOT: slice_index_order_fail\n+    let d = &s.data[s.position..s.position+n];\n+    s.position += n;\n+    return d;\n+}\n+\n+// CHECK-LABEL: @test_check\n+#[no_mangle]\n+pub fn test_check<'a>(s: &'a mut S1, x: usize, y: usize) -> &'a [u8] {\n+    // CHECK: slice_index_order_fail\n+    &s.data[x..y]\n+}"}, {"sha": "4da6061c27fe840a82da12e0cb340dece6a4745e", "filename": "src/test/ui/issues/issue-72373.rs", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/rust-lang/rust/blob/77f95a89a108d4cd6ad1230fb210b3640952b146/src%2Ftest%2Fui%2Fissues%2Fissue-72373.rs", "raw_url": "https://github.com/rust-lang/rust/raw/77f95a89a108d4cd6ad1230fb210b3640952b146/src%2Ftest%2Fui%2Fissues%2Fissue-72373.rs", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-72373.rs?ref=77f95a89a108d4cd6ad1230fb210b3640952b146", "patch": "@@ -0,0 +1,9 @@\n+fn foo(c: &[u32], n: u32) -> u32 {\n+    match *c {\n+        [h, ..] if h > n => 0,\n+        [h, ..] if h == n => 1,\n+        [h, ref ts..] => foo(c, n - h) + foo(ts, n),\n+        //~^ ERROR expected one of `,`, `@`, `]`, or `|`, found `..`\n+        [] => 0,\n+    }\n+}"}, {"sha": "dfde8624814f8e154303dbefedf3ce963d031e21", "filename": "src/test/ui/issues/issue-72373.stderr", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/rust-lang/rust/blob/77f95a89a108d4cd6ad1230fb210b3640952b146/src%2Ftest%2Fui%2Fissues%2Fissue-72373.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/77f95a89a108d4cd6ad1230fb210b3640952b146/src%2Ftest%2Fui%2Fissues%2Fissue-72373.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fissues%2Fissue-72373.stderr?ref=77f95a89a108d4cd6ad1230fb210b3640952b146", "patch": "@@ -0,0 +1,13 @@\n+error: expected one of `,`, `@`, `]`, or `|`, found `..`\n+  --> $DIR/issue-72373.rs:5:19\n+   |\n+LL |         [h, ref ts..] => foo(c, n - h) + foo(ts, n),\n+   |                   ^^ expected one of `,`, `@`, `]`, or `|`\n+   |\n+help: if you meant to bind the contents of the rest of the array pattern into `ts`, use `@`\n+   |\n+LL |         [h, ref ts @ ..] => foo(c, n - h) + foo(ts, n),\n+   |                    ^\n+\n+error: aborting due to previous error\n+"}, {"sha": "3bd85b083d002d4e8021e41faa9d9cfc8044e8ae", "filename": "src/test/ui/json-short.stderr", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/rust-lang/rust/blob/77f95a89a108d4cd6ad1230fb210b3640952b146/src%2Ftest%2Fui%2Fjson-short.stderr", "raw_url": "https://github.com/rust-lang/rust/raw/77f95a89a108d4cd6ad1230fb210b3640952b146/src%2Ftest%2Fui%2Fjson-short.stderr", "contents_url": "https://api.github.com/repos/rust-lang/rust/contents/src%2Ftest%2Fui%2Fjson-short.stderr?ref=77f95a89a108d4cd6ad1230fb210b3640952b146", "patch": "@@ -1,5 +1,6 @@\n-{\"message\":\"`main` function not found in crate `json_short`\",\"code\":{\"code\":\"E0601\",\"explanation\":\"No `main` function was found in a binary crate. To fix this error, add a\n-`main` function. For example:\n+{\"message\":\"`main` function not found in crate `json_short`\",\"code\":{\"code\":\"E0601\",\"explanation\":\"No `main` function was found in a binary crate.\n+\n+To fix this error, add a `main` function:\n \n ```\n fn main() {"}]}